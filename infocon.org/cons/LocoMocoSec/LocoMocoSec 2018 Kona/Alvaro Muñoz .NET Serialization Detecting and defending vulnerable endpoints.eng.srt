1
00:00:02,899 --> 00:00:08,068
thank you

2
00:00:04,230 --> 00:00:11,099
can you hear me yeah so alright thank

3
00:00:08,069 --> 00:00:12,599
you Jim for the introduction so as Jim

4
00:00:11,099 --> 00:00:16,079
said I'm algorithm unit also known as

5
00:00:12,599 --> 00:00:19,080
pond tested in social network Twitter

6
00:00:16,079 --> 00:00:21,060
github and so on I work as a principal

7
00:00:19,080 --> 00:00:23,698
security researcher with fortify team I

8
00:00:21,060 --> 00:00:27,330
mainly do static analysis related

9
00:00:23,699 --> 00:00:29,130
research and probably well I focus on on

10
00:00:27,330 --> 00:00:31,169
web application security right

11
00:00:29,130 --> 00:00:34,079
why find more interesting is for getting

12
00:00:31,170 --> 00:00:36,680
remote code execution on web

13
00:00:34,079 --> 00:00:39,420
applications and I have responsibly

14
00:00:36,680 --> 00:00:41,309
reported critical remote code execution

15
00:00:39,420 --> 00:00:44,579
boon abilities to companies like

16
00:00:41,309 --> 00:00:48,570
Microsoft Oracle workday Salesforce and

17
00:00:44,579 --> 00:00:50,399
so on so one of them in Microsoft I will

18
00:00:48,570 --> 00:00:52,920
be sharing with you today hopefully if

19
00:00:50,399 --> 00:00:55,260
we have time so apart from that I have

20
00:00:52,920 --> 00:00:59,579
some experience around digitalization I

21
00:00:55,260 --> 00:01:02,519
started not in 2015 when as Jim said but

22
00:00:59,579 --> 00:01:04,349
actually in 2012 playing with XML

23
00:01:02,520 --> 00:01:06,479
decoder and access stream trying to get

24
00:01:04,349 --> 00:01:09,360
remote code execution in restful Web

25
00:01:06,479 --> 00:01:11,280
Services right so we were able to get

26
00:01:09,360 --> 00:01:14,520
remote code execution and some libraries

27
00:01:11,280 --> 00:01:18,299
like Restylane and rustici and then I

28
00:01:14,520 --> 00:01:21,119
moved into the binary format of Java

29
00:01:18,299 --> 00:01:23,070
visualization right and I found too

30
00:01:21,119 --> 00:01:26,369
worried to my knowledge is the first

31
00:01:23,070 --> 00:01:28,139
remote code execution gadget for Java

32
00:01:26,369 --> 00:01:30,990
desalinization but for the binary format

33
00:01:28,140 --> 00:01:32,670
back in 2013 and it was not in a patchy

34
00:01:30,990 --> 00:01:36,000
commerce collection but actually in the

35
00:01:32,670 --> 00:01:39,479
spring libraries right so unfortunately

36
00:01:36,000 --> 00:01:41,220
this gadget didn't become as popular as

37
00:01:39,479 --> 00:01:43,679
the Apache Commerce collection gadget

38
00:01:41,220 --> 00:01:46,439
became and I'm saying unfortunately

39
00:01:43,680 --> 00:01:49,049
because we all saw that this was like a

40
00:01:46,439 --> 00:01:50,610
tipping point right and when Chris for

41
00:01:49,049 --> 00:01:53,549
hope and Gabriel Lawrence family's cut

42
00:01:50,610 --> 00:01:54,869
yet the community started looking for

43
00:01:53,549 --> 00:01:56,490
these vulnerabilities they started

44
00:01:54,869 --> 00:01:58,290
fixing them and so on so we could have

45
00:01:56,490 --> 00:02:01,439
saved ourselves like a couple of years

46
00:01:58,290 --> 00:02:04,259
by starting back in 2013 or even even

47
00:02:01,439 --> 00:02:06,329
before so at this point in 2015 Chris

48
00:02:04,259 --> 00:02:08,479
Roth and Gabrielle Oryza published the

49
00:02:06,329 --> 00:02:10,978
Apache Commons collection gadget and

50
00:02:08,479 --> 00:02:13,260
everything changes right all the

51
00:02:10,979 --> 00:02:13,890
researchers start looking into Java this

52
00:02:13,260 --> 00:02:15,630
realization

53
00:02:13,890 --> 00:02:17,730
they start publishing vulnerabilities

54
00:02:15,630 --> 00:02:20,670
like in WebLogic websphere and many

55
00:02:17,730 --> 00:02:23,609
other applications so I retook my

56
00:02:20,670 --> 00:02:26,670
interest in Java serialization I I found

57
00:02:23,610 --> 00:02:28,410
like a technique to bypass what is known

58
00:02:26,670 --> 00:02:30,089
as the Luca head object digitization

59
00:02:28,410 --> 00:02:32,400
that is like the standard mitigation

60
00:02:30,090 --> 00:02:34,440
technique for this kind of attacks in

61
00:02:32,400 --> 00:02:36,390
Java and also I found like multiple

62
00:02:34,440 --> 00:02:38,550
gadgets to lead into remote code

63
00:02:36,390 --> 00:02:41,029
execution including one in the Java

64
00:02:38,550 --> 00:02:43,730
Runtime itself so not requiring any

65
00:02:41,030 --> 00:02:47,459
third-party libraries in order to work

66
00:02:43,730 --> 00:02:49,410
so then I switch gears and star appeared

67
00:02:47,459 --> 00:02:51,450
looking into JSON to close the circle

68
00:02:49,410 --> 00:02:54,060
right so from XML to binary and then to

69
00:02:51,450 --> 00:02:56,399
Jason and I publish some approaches to

70
00:02:54,060 --> 00:02:58,980
get remote execution in JSON deserialize

71
00:02:56,400 --> 00:03:02,010
errs back in last year in black hat on

72
00:02:58,980 --> 00:03:04,230
and DEF CON so most of this is Java

73
00:03:02,010 --> 00:03:06,899
right and this is what is known as the

74
00:03:04,230 --> 00:03:09,030
Java DC allocation apocalypse and I

75
00:03:06,900 --> 00:03:10,530
think well it it's bad because I mean

76
00:03:09,030 --> 00:03:12,750
there was many application that were

77
00:03:10,530 --> 00:03:15,480
affected by these bugs but in the other

78
00:03:12,750 --> 00:03:17,700
hand it was good because we got this

79
00:03:15,480 --> 00:03:21,268
categorical together to go into the

80
00:03:17,700 --> 00:03:23,250
OWASP top 10 right and we as a security

81
00:03:21,269 --> 00:03:25,650
community we have knowledge about the

82
00:03:23,250 --> 00:03:28,890
latest trends and latest categories like

83
00:03:25,650 --> 00:03:31,799
I don't know SPL injection or jndi

84
00:03:28,890 --> 00:03:34,920
injection but developers don't normally

85
00:03:31,799 --> 00:03:36,750
have these visibility in what boon

86
00:03:34,920 --> 00:03:38,160
abilities they should focus on and I

87
00:03:36,750 --> 00:03:40,230
think that having secured this

88
00:03:38,160 --> 00:03:42,209
realization in the August of 10 is a

89
00:03:40,230 --> 00:03:43,679
good thing in order for developers to

90
00:03:42,209 --> 00:03:47,549
start looking and fixing these

91
00:03:43,680 --> 00:03:49,560
vulnerabilities so at that point I

92
00:03:47,549 --> 00:03:51,329
decided to take a look into that net

93
00:03:49,560 --> 00:03:53,670
because well I'm not about net developer

94
00:03:51,329 --> 00:03:55,290
and not a dotnet researcher but since I

95
00:03:53,670 --> 00:03:57,268
had some previous experience with this

96
00:03:55,290 --> 00:03:59,820
realization I decided to take a look

97
00:03:57,269 --> 00:04:02,100
because apparently there was a previous

98
00:03:59,820 --> 00:04:03,930
research around o net visualization but

99
00:04:02,100 --> 00:04:07,200
there was no remote or execution gadget

100
00:04:03,930 --> 00:04:09,120
and has happened with Java before it was

101
00:04:07,200 --> 00:04:11,369
not until a remote code execution gadget

102
00:04:09,120 --> 00:04:13,019
was published that the community started

103
00:04:11,370 --> 00:04:14,549
fixing and taking care of this

104
00:04:13,019 --> 00:04:16,769
vulnerabilities so I decided to look for

105
00:04:14,549 --> 00:04:19,680
one in order to start you know the ball

106
00:04:16,769 --> 00:04:22,890
moving so what I'm going to present

107
00:04:19,680 --> 00:04:25,169
today is the result of these research so

108
00:04:22,890 --> 00:04:27,330
I will first introduce brief

109
00:04:25,169 --> 00:04:29,219
introduction into a serialization

110
00:04:27,330 --> 00:04:31,289
then we will be reviewing what are the

111
00:04:29,220 --> 00:04:33,689
most common doesn't net serialize have

112
00:04:31,289 --> 00:04:35,550
some formatters and then we will move to

113
00:04:33,689 --> 00:04:36,840
the more like builder and defender part

114
00:04:35,550 --> 00:04:39,259
of the top that is finding

115
00:04:36,840 --> 00:04:42,750
vulnerabilities and fixing them

116
00:04:39,259 --> 00:04:45,150
alright so Marceline pickles I will be

117
00:04:42,750 --> 00:04:47,759
using Rick and Morty picture because why

118
00:04:45,150 --> 00:04:51,750
not so this is Rick right he's an

119
00:04:47,759 --> 00:04:54,659
instance an object living in the VM and

120
00:04:51,750 --> 00:04:57,000
at some point the developer want to take

121
00:04:54,659 --> 00:04:59,009
Rick out of the VM right so he wants to

122
00:04:57,000 --> 00:05:00,530
put it in the file system or into the

123
00:04:59,009 --> 00:05:04,139
database or send it across the network

124
00:05:00,530 --> 00:05:10,169
so he put a rig across the magic portal

125
00:05:04,139 --> 00:05:12,990
and then he gets a pickle ring so at a

126
00:05:10,169 --> 00:05:15,000
later stage we want to recover the

127
00:05:12,990 --> 00:05:17,219
object back in the VM so we will put

128
00:05:15,000 --> 00:05:19,289
pickle Rick back into the magic portal

129
00:05:17,219 --> 00:05:22,440
and then recover and reconstruct Rick

130
00:05:19,289 --> 00:05:24,870
again alright so there is one thing in

131
00:05:22,440 --> 00:05:29,029
this slide that is critical for this DC

132
00:05:24,870 --> 00:05:29,029
allocation attacks to work anyone

133
00:05:31,370 --> 00:05:37,879
something that is like the design flow

134
00:05:34,409 --> 00:05:37,879
of all these formats like death

135
00:05:43,140 --> 00:05:54,400
so say that again sorry yeah well this

136
00:05:52,750 --> 00:05:57,040
is just a very simplification a

137
00:05:54,400 --> 00:05:59,260
simplified model of visualization but

138
00:05:57,040 --> 00:06:02,020
the issue I was are referring to is that

139
00:05:59,260 --> 00:06:04,539
we're not sending just the pickle itself

140
00:06:02,020 --> 00:06:07,090
but we are sending a pickle week as long

141
00:06:04,540 --> 00:06:09,940
I love with the satellite data as well

142
00:06:07,090 --> 00:06:12,010
so this is what is known as the type

143
00:06:09,940 --> 00:06:13,530
discriminator and basically if you're

144
00:06:12,010 --> 00:06:16,180
familiar with Java additional ization

145
00:06:13,530 --> 00:06:18,549
even though it's a binary format you

146
00:06:16,180 --> 00:06:20,380
will find like class names or type names

147
00:06:18,550 --> 00:06:22,810
in the industry lies data

148
00:06:20,380 --> 00:06:24,850
same thing with dotnet for example this

149
00:06:22,810 --> 00:06:26,620
is JSON Dannette you will find some

150
00:06:24,850 --> 00:06:28,150
dollar attributes there are type

151
00:06:26,620 --> 00:06:32,050
attributes containing something that

152
00:06:28,150 --> 00:06:34,750
looks like dotnet type and dotnet

153
00:06:32,050 --> 00:06:37,510
assembly names so if the attacker can

154
00:06:34,750 --> 00:06:39,970
control the type discriminator and they

155
00:06:37,510 --> 00:06:43,120
change picker rig with a pickle morty

156
00:06:39,970 --> 00:06:45,370
then the server will blindly trust that

157
00:06:43,120 --> 00:06:47,020
and then will instantiate an instance of

158
00:06:45,370 --> 00:06:49,390
Mort instead of the of the brick one

159
00:06:47,020 --> 00:06:51,909
right so there is probably nothing

160
00:06:49,390 --> 00:06:53,409
really dangerous here because they're

161
00:06:51,910 --> 00:06:57,940
going to invoke the default constructor

162
00:06:53,410 --> 00:07:00,340
of this morty class which is it takes no

163
00:06:57,940 --> 00:07:03,520
parameters so there is nothing where the

164
00:07:00,340 --> 00:07:05,789
attacker can modify the behavior of this

165
00:07:03,520 --> 00:07:07,750
and just get arbitrary code execution

166
00:07:05,790 --> 00:07:09,250
however apart from the default

167
00:07:07,750 --> 00:07:12,070
constructor there will be other methods

168
00:07:09,250 --> 00:07:14,440
will get invoke like for example in Java

169
00:07:12,070 --> 00:07:17,140
will get the read object and with result

170
00:07:14,440 --> 00:07:18,790
methods and in.net the same thing will

171
00:07:17,140 --> 00:07:21,280
have like this initialization

172
00:07:18,790 --> 00:07:23,320
constructor over here visualization

173
00:07:21,280 --> 00:07:24,909
callbacks even some annotations that we

174
00:07:23,320 --> 00:07:26,200
can use to annotate methods that are

175
00:07:24,910 --> 00:07:28,600
going to be involved with the framework

176
00:07:26,200 --> 00:07:29,409
in order to fully reconstruct the object

177
00:07:28,600 --> 00:07:33,370
right

178
00:07:29,410 --> 00:07:35,169
same thing with XML and JSON the this

179
00:07:33,370 --> 00:07:36,880
libraries will normally just invoke the

180
00:07:35,169 --> 00:07:39,280
default constructor and then invoke

181
00:07:36,880 --> 00:07:41,650
setters in order to populate the data in

182
00:07:39,280 --> 00:07:45,280
the class types and we they will be

183
00:07:41,650 --> 00:07:47,950
invoking centers in order to do that all

184
00:07:45,280 --> 00:07:50,020
right so all that the attackers

185
00:07:47,950 --> 00:07:52,599
need to do is find a gadget right and a

186
00:07:50,020 --> 00:07:54,909
gadget is nothing else that a type or a

187
00:07:52,599 --> 00:07:56,500
class that is sitting in the target

188
00:07:54,910 --> 00:07:58,660
application class path so they

189
00:07:56,500 --> 00:08:01,260
provide implementation for the precise

190
00:07:58,660 --> 00:08:04,390
they can only provide the type name and

191
00:08:01,260 --> 00:08:07,060
since they can control the values for

192
00:08:04,390 --> 00:08:09,159
these properties of this class then they

193
00:08:07,060 --> 00:08:11,470
are able to actually modify the behavior

194
00:08:09,160 --> 00:08:13,210
of the methods that are going to involve

195
00:08:11,470 --> 00:08:16,530
to be invoke like for example the

196
00:08:13,210 --> 00:08:19,690
desalinization callbacks or the setters

197
00:08:16,530 --> 00:08:21,580
so this is more like a builder and

198
00:08:19,690 --> 00:08:26,830
defender talk and I'm not going to focus

199
00:08:21,580 --> 00:08:28,539
on how to find and get final gadgets we

200
00:08:26,830 --> 00:08:29,979
live in two remote code execution but I

201
00:08:28,540 --> 00:08:32,320
think it's good to whom show you an

202
00:08:29,980 --> 00:08:34,479
example of a very simple one live in two

203
00:08:32,320 --> 00:08:37,810
remote code execution so you can have

204
00:08:34,479 --> 00:08:41,110
like an idea of how they look like so

205
00:08:37,809 --> 00:08:43,569
this is a system windows data object

206
00:08:41,110 --> 00:08:45,400
data provider is app type in the windows

207
00:08:43,570 --> 00:08:50,920
guard so is available without any

208
00:08:45,400 --> 00:08:52,930
third-party dependencies required and it

209
00:08:50,920 --> 00:08:57,040
contains three different setters right

210
00:08:52,930 --> 00:08:59,709
that will initiate some invocations that

211
00:08:57,040 --> 00:09:01,990
will end up invoking this method over

212
00:08:59,710 --> 00:09:06,430
here and here we are basically just

213
00:09:01,990 --> 00:09:08,589
using reflection to invoke method name

214
00:09:06,430 --> 00:09:10,870
on an object instance passing some

215
00:09:08,589 --> 00:09:14,110
parameters right and those are exactly

216
00:09:10,870 --> 00:09:15,520
the one that we can control if we can

217
00:09:14,110 --> 00:09:17,620
control the values that are passed to

218
00:09:15,520 --> 00:09:20,140
the setters right so if an attacker

219
00:09:17,620 --> 00:09:22,780
provides a piece of JSON the net data

220
00:09:20,140 --> 00:09:23,949
like this one to a burnable endpoint the

221
00:09:22,780 --> 00:09:26,319
vulnerable endpoint will basically

222
00:09:23,950 --> 00:09:28,990
instantiate the object data provider and

223
00:09:26,320 --> 00:09:30,460
then it will invoke the setters for the

224
00:09:28,990 --> 00:09:32,020
object instance for the method

225
00:09:30,460 --> 00:09:35,080
parameters and for the method name and

226
00:09:32,020 --> 00:09:37,030
as we saw before this will initiate this

227
00:09:35,080 --> 00:09:39,190
this calls here and we'll end up

228
00:09:37,030 --> 00:09:42,839
invoking the reflection and getting the

229
00:09:39,190 --> 00:09:45,339
in this case the calculator to papad oh

230
00:09:42,839 --> 00:09:48,370
right so I'm not going to talk more

231
00:09:45,339 --> 00:09:50,500
about gadgets if you want to check which

232
00:09:48,370 --> 00:09:52,870
cards are available for Java obviously

233
00:09:50,500 --> 00:09:55,750
the white serial project if you want to

234
00:09:52,870 --> 00:09:57,790
know more about what gadgets internet I

235
00:09:55,750 --> 00:10:00,550
grow this project that is called why

236
00:09:57,790 --> 00:10:03,760
social net that basically it can be used

237
00:10:00,550 --> 00:10:06,209
to generate payloads and gadgets for

238
00:10:03,760 --> 00:10:08,770
different formats in the dotnet family

239
00:10:06,209 --> 00:10:09,880
so this is a simple example for example

240
00:10:08,770 --> 00:10:12,250
just you

241
00:10:09,880 --> 00:10:14,230
walk it like the one that we just saw if

242
00:10:12,250 --> 00:10:16,660
you want to attack the nation on that

243
00:10:14,230 --> 00:10:19,000
just specify the format there specify

244
00:10:16,660 --> 00:10:20,740
the Gardea to specify the command and it

245
00:10:19,000 --> 00:10:22,780
will generate the payload for you to use

246
00:10:20,740 --> 00:10:25,050
in your penetration test and pocs and so

247
00:10:22,780 --> 00:10:27,970
on so with that let's move into

248
00:10:25,050 --> 00:10:29,620
reviewing what format herbs and Syria

249
00:10:27,970 --> 00:10:33,400
lasers are vulnerable in they donate

250
00:10:29,620 --> 00:10:35,380
family so as I said this is nothing new

251
00:10:33,400 --> 00:10:37,390
and back in 2012

252
00:10:35,380 --> 00:10:40,230
James Forster from the Google project

253
00:10:37,390 --> 00:10:42,880
zero was already presenting on how

254
00:10:40,230 --> 00:10:44,500
passing untrusted data to binary

255
00:10:42,880 --> 00:10:48,040
formatted or net data contracts

256
00:10:44,500 --> 00:10:50,380
dialyzers could live into some malicious

257
00:10:48,040 --> 00:10:52,420
code being run at that time there was no

258
00:10:50,380 --> 00:10:54,070
remote code execution gadget and I think

259
00:10:52,420 --> 00:10:55,750
that he only presented a Katia that was

260
00:10:54,070 --> 00:10:59,200
able to delete files from the file

261
00:10:55,750 --> 00:11:02,140
system or initiate some SM bid relay

262
00:10:59,200 --> 00:11:04,450
attacks right so has happened with Java

263
00:11:02,140 --> 00:11:06,699
before since there was since there were

264
00:11:04,450 --> 00:11:08,950
no remote code execution cut yet no one

265
00:11:06,700 --> 00:11:11,170
paid really you know attention to these

266
00:11:08,950 --> 00:11:14,320
vulnerabilities and there were like many

267
00:11:11,170 --> 00:11:18,160
many vulnerabilities are related with

268
00:11:14,320 --> 00:11:21,460
dotnet visualization until until last

269
00:11:18,160 --> 00:11:23,050
year probably so last year in 2017 my

270
00:11:21,460 --> 00:11:24,670
colleague Alexander meters and myself we

271
00:11:23,050 --> 00:11:27,130
found our remote code execution gadget

272
00:11:24,670 --> 00:11:29,380
in dotnet and that was followed by James

273
00:11:27,130 --> 00:11:33,880
for so presenting two more so there like

274
00:11:29,380 --> 00:11:37,090
a number of them right now so as we said

275
00:11:33,880 --> 00:11:38,470
James presented a couple of four matters

276
00:11:37,090 --> 00:11:40,180
that are vulnerable in their default

277
00:11:38,470 --> 00:11:41,650
configuration those are binary format

278
00:11:40,180 --> 00:11:44,020
there and net data contract serializer

279
00:11:41,650 --> 00:11:45,939
but they are more right these are the

280
00:11:44,020 --> 00:11:47,680
ones like I said that are vulnerable in

281
00:11:45,940 --> 00:11:49,900
their default configuration they should

282
00:11:47,680 --> 00:11:52,209
never be used with untrusted data at

283
00:11:49,900 --> 00:11:54,490
least in this default configuration and

284
00:11:52,210 --> 00:11:56,680
they include the binary formatter one

285
00:11:54,490 --> 00:11:58,480
that is the one that James presented but

286
00:11:56,680 --> 00:12:01,390
this one is also used internally by

287
00:11:58,480 --> 00:12:02,890
other serializers right for example this

288
00:12:01,390 --> 00:12:05,050
binary message format that is used by

289
00:12:02,890 --> 00:12:07,390
the Microsoft message queue system so if

290
00:12:05,050 --> 00:12:08,770
you can send them arbitrary types you

291
00:12:07,390 --> 00:12:09,340
will be able to get arbitrary code

292
00:12:08,770 --> 00:12:11,650
execution

293
00:12:09,340 --> 00:12:13,450
same thing with the object state

294
00:12:11,650 --> 00:12:16,720
formatter that is used by the asp.net

295
00:12:13,450 --> 00:12:19,720
view state so if you can change the view

296
00:12:16,720 --> 00:12:21,670
state and survive the h mark

297
00:12:19,720 --> 00:12:23,230
verification that will also lead to

298
00:12:21,670 --> 00:12:26,589
remote code execution and we will

299
00:12:23,230 --> 00:12:28,210
more about this later so then we have

300
00:12:26,590 --> 00:12:30,130
more like sub format that is using web

301
00:12:28,210 --> 00:12:33,310
services for JSON sweet Jason

302
00:12:30,130 --> 00:12:36,280
those are like third-party libraries so

303
00:12:33,310 --> 00:12:38,589
the most popular and used one is the

304
00:12:36,280 --> 00:12:40,720
binary formatter and this is probably

305
00:12:38,590 --> 00:12:43,300
the most common and P pattern that I

306
00:12:40,720 --> 00:12:46,390
found I literally found like thousands

307
00:12:43,300 --> 00:12:47,770
of applications in southern vulnerable

308
00:12:46,390 --> 00:12:50,620
to remote code execution because they

309
00:12:47,770 --> 00:12:52,329
were using exactly this pattern and this

310
00:12:50,620 --> 00:12:55,060
is basically well this is very simple

311
00:12:52,330 --> 00:12:56,320
they are basically instance here in the

312
00:12:55,060 --> 00:12:58,359
binary format there and then say they're

313
00:12:56,320 --> 00:13:00,100
licensed some data basics de for

314
00:12:58,360 --> 00:13:03,550
encoding that data and putting that into

315
00:13:00,100 --> 00:13:05,530
a cookie so if that cookie came back the

316
00:13:03,550 --> 00:13:08,410
server is going to deserialize that and

317
00:13:05,530 --> 00:13:11,079
since there is no H Mac verification it

318
00:13:08,410 --> 00:13:13,990
will go in and run arbitrary commands

319
00:13:11,080 --> 00:13:16,420
using these gadgets so the first time

320
00:13:13,990 --> 00:13:20,140
that I found that was in app Harbor and

321
00:13:16,420 --> 00:13:24,280
one nose up Harbor yeah I know you use

322
00:13:20,140 --> 00:13:26,890
it so well browse on the side I realized

323
00:13:24,280 --> 00:13:29,980
that they were setting this cookie with

324
00:13:26,890 --> 00:13:32,140
this AE AE d that is nothing else that

325
00:13:29,980 --> 00:13:34,270
the magic number for the binary format

326
00:13:32,140 --> 00:13:36,280
there and then basic ste for encoding so

327
00:13:34,270 --> 00:13:38,350
that means that this side that is

328
00:13:36,280 --> 00:13:40,810
basically like Heroku for for donut

329
00:13:38,350 --> 00:13:42,970
applications like to host donut

330
00:13:40,810 --> 00:13:46,270
applications I was born about to remote

331
00:13:42,970 --> 00:13:48,400
code execution we reported that and they

332
00:13:46,270 --> 00:13:51,880
fix it but then we realized that they

333
00:13:48,400 --> 00:13:53,670
even had a blog post explaining how to

334
00:13:51,880 --> 00:13:56,200
do exactly what they were doing so

335
00:13:53,670 --> 00:13:59,349
instead of keeping some objects in the

336
00:13:56,200 --> 00:14:00,670
server side just saved some memory and

337
00:13:59,350 --> 00:14:02,290
put them in the client side by

338
00:14:00,670 --> 00:14:04,839
sterilizing them and putting them into a

339
00:14:02,290 --> 00:14:07,180
cookie so we tell them about this blog

340
00:14:04,840 --> 00:14:10,120
post and they are now deleted these this

341
00:14:07,180 --> 00:14:12,219
blog post however this same advice is

342
00:14:10,120 --> 00:14:15,160
everywhere you can find like multiple

343
00:14:12,220 --> 00:14:18,010
and yeasts and blog posts and even in

344
00:14:15,160 --> 00:14:20,589
Microsoft asp.net MVC framework was

345
00:14:18,010 --> 00:14:24,160
using the very same approach that they

346
00:14:20,590 --> 00:14:26,530
silently removed back in 2013 right and

347
00:14:24,160 --> 00:14:29,410
this is relatable with what Jeremy was

348
00:14:26,530 --> 00:14:30,819
talking before like if they don't

349
00:14:29,410 --> 00:14:32,500
publish like a CV

350
00:14:30,820 --> 00:14:34,180
German you don't know that there is

351
00:14:32,500 --> 00:14:34,910
something that you should update and so

352
00:14:34,180 --> 00:14:39,229
on this

353
00:14:34,910 --> 00:14:40,880
is kind of important so let's see a demo

354
00:14:39,230 --> 00:14:46,850
this is a vulnerability that I found in

355
00:14:40,880 --> 00:14:49,730
Asia yeah so this is from last year so

356
00:14:46,850 --> 00:14:51,710
as you can see even though this research

357
00:14:49,730 --> 00:14:55,250
by James first was published in 2012

358
00:14:51,710 --> 00:14:57,920
there were many developers even

359
00:14:55,250 --> 00:14:59,900
Microsoft developers using binary format

360
00:14:57,920 --> 00:15:01,569
there with untrusted data so if you are

361
00:14:59,900 --> 00:15:05,030
familiar with Asia or Active Directory

362
00:15:01,570 --> 00:15:07,610
or application proxy you basically have

363
00:15:05,030 --> 00:15:09,380
your intranet here and you have the web

364
00:15:07,610 --> 00:15:11,450
application that you want to do sir

365
00:15:09,380 --> 00:15:13,910
right to to expose to your remote

366
00:15:11,450 --> 00:15:15,680
employees so your employees will

367
00:15:13,910 --> 00:15:18,439
basically connect to the application

368
00:15:15,680 --> 00:15:21,469
proxy and will be redirected to the AC

369
00:15:18,440 --> 00:15:23,870
or Active Directory well they will be

370
00:15:21,470 --> 00:15:26,240
like ask for the credentials that will

371
00:15:23,870 --> 00:15:28,040
be checked against your own instance of

372
00:15:26,240 --> 00:15:30,530
the active Active Directory and then

373
00:15:28,040 --> 00:15:32,060
they will be returning a token and then

374
00:15:30,530 --> 00:15:34,400
authenticating against the application

375
00:15:32,060 --> 00:15:38,930
proxy I think that is very better

376
00:15:34,400 --> 00:15:41,240
explained with a video so this is where

377
00:15:38,930 --> 00:15:44,290
visiting a application that I'm exposing

378
00:15:41,240 --> 00:15:47,720
through this is your application proxy

379
00:15:44,290 --> 00:15:50,329
and I'm ready ducted to the Microsoft

380
00:15:47,720 --> 00:15:52,790
single sign-on right I don't even need

381
00:15:50,330 --> 00:15:54,130
to login into a sure because this is a

382
00:15:52,790 --> 00:15:56,689
pre authentication remote code execution

383
00:15:54,130 --> 00:16:04,610
so I will basically send a request

384
00:15:56,690 --> 00:16:07,910
through a burp or any proxy and well

385
00:16:04,610 --> 00:16:10,820
basically I will just send this request

386
00:16:07,910 --> 00:16:13,240
to the repeater so we can see what is

387
00:16:10,820 --> 00:16:13,240
going on

388
00:16:17,670 --> 00:16:23,279
and as you can see here we get a 302 red

389
00:16:21,089 --> 00:16:25,620
erection to the single sign-on page in

390
00:16:23,279 --> 00:16:28,500
Microsoft and then we get this cookie

391
00:16:25,620 --> 00:16:30,990
assign here right if you recognize this

392
00:16:28,500 --> 00:16:32,579
magic number the same one in app Harbor

393
00:16:30,990 --> 00:16:38,310
this basically means remote code

394
00:16:32,579 --> 00:16:41,279
execution so we just get what we have to

395
00:16:38,310 --> 00:16:45,630
do now is generate our our payload and

396
00:16:41,279 --> 00:16:47,790
we will be basically this was before I

397
00:16:45,630 --> 00:16:49,800
wrote the white social donut so I had to

398
00:16:47,790 --> 00:16:51,870
do it by hand but basically I will be

399
00:16:49,800 --> 00:16:54,569
doing a DNS resolution against my own

400
00:16:51,870 --> 00:16:56,250
DNS server and I will be leaking the

401
00:16:54,570 --> 00:16:58,550
computer name just to prove that the

402
00:16:56,250 --> 00:17:01,560
remote code execution was not in my own

403
00:16:58,550 --> 00:17:05,040
intranet servers but actually in Asia

404
00:17:01,560 --> 00:17:07,438
servers so with that I will just

405
00:17:05,040 --> 00:17:09,059
generate the payload during the process

406
00:17:07,439 --> 00:17:11,640
of generation of generating the payload

407
00:17:09,059 --> 00:17:14,490
the payload will get executed so I will

408
00:17:11,640 --> 00:17:23,429
get a connection back to my DNS server

409
00:17:14,490 --> 00:17:26,370
from my own VM as you can see here so

410
00:17:23,429 --> 00:17:29,610
that's my VM computer name so nothing

411
00:17:26,369 --> 00:17:32,790
interesting so far but now if we copy

412
00:17:29,610 --> 00:17:36,270
paste the payload generated by our Cod

413
00:17:32,790 --> 00:17:40,100
yet or payload generator into the cookie

414
00:17:36,270 --> 00:17:43,910
and we send this request to Microsoft

415
00:17:40,100 --> 00:17:48,659
Word to lazer Network we will see that

416
00:17:43,910 --> 00:17:51,840
we will get some connection back from

417
00:17:48,660 --> 00:17:57,200
different servers actually not just one

418
00:17:51,840 --> 00:17:57,199
so for example the first one is from

419
00:17:57,679 --> 00:18:03,179
this server down here that is Microsoft

420
00:18:00,660 --> 00:18:05,010
servers and then if I submit the request

421
00:18:03,179 --> 00:18:08,220
again I will get a different connection

422
00:18:05,010 --> 00:18:10,080
which means that I can compromise all

423
00:18:08,220 --> 00:18:12,870
the application proxies that are working

424
00:18:10,080 --> 00:18:15,570
like in a load balancer way which means

425
00:18:12,870 --> 00:18:17,790
that I can intercept any traffic going

426
00:18:15,570 --> 00:18:21,809
to any intranet of customers using this

427
00:18:17,790 --> 00:18:23,850
a sure thing so that was pretty bad the

428
00:18:21,809 --> 00:18:25,918
good thing is that Microsoft only had to

429
00:18:23,850 --> 00:18:30,020
patch them their own system and that was

430
00:18:25,919 --> 00:18:30,020
quite easy and they did it very quickly

431
00:18:30,220 --> 00:18:34,360
all right so apart from those DC

432
00:18:32,950 --> 00:18:36,490
realizes that are vulnerable in their

433
00:18:34,360 --> 00:18:38,709
default configuration there are other

434
00:18:36,490 --> 00:18:41,889
said allies errs that are known as

435
00:18:38,710 --> 00:18:44,980
template this a realizers that work with

436
00:18:41,889 --> 00:18:46,750
an expected type right so if you want to

437
00:18:44,980 --> 00:18:48,820
decide allies something they will only

438
00:18:46,750 --> 00:18:50,139
work with one type right for example if

439
00:18:48,820 --> 00:18:52,750
you're expecting a shopping cart

440
00:18:50,139 --> 00:18:55,299
instance then you cannot send like an

441
00:18:52,750 --> 00:18:57,870
object data provider payload because

442
00:18:55,299 --> 00:18:59,980
that won't work right so those examples

443
00:18:57,870 --> 00:19:01,719
examples of that is for example the data

444
00:18:59,980 --> 00:19:03,759
contract serializer that there are

445
00:19:01,720 --> 00:19:06,610
contract jesse realized and the xml said

446
00:19:03,759 --> 00:19:08,320
serialize so in these cases they are

447
00:19:06,610 --> 00:19:09,969
still vulnerable but the attacker needs

448
00:19:08,320 --> 00:19:11,799
to control not just the data that is

449
00:19:09,970 --> 00:19:14,230
going to be dis alized but also the

450
00:19:11,799 --> 00:19:16,120
suspected type you may think that this

451
00:19:14,230 --> 00:19:18,279
is not very common but I found out for

452
00:19:16,120 --> 00:19:19,959
example one good example in DotNetNuke

453
00:19:18,279 --> 00:19:22,120
that is the most popular content

454
00:19:19,960 --> 00:19:24,429
management system in in.net and

455
00:19:22,120 --> 00:19:26,350
basically at some point they were taking

456
00:19:24,429 --> 00:19:29,049
the contents of a cookie that was not

457
00:19:26,350 --> 00:19:30,668
sign it and that was like an XML cookie

458
00:19:29,049 --> 00:19:33,519
I don't know why but anyway they were

459
00:19:30,669 --> 00:19:36,730
extracting some type name from this XML

460
00:19:33,519 --> 00:19:38,320
and then they were invoking the

461
00:19:36,730 --> 00:19:40,389
constructor of the XML satellizer

462
00:19:38,320 --> 00:19:41,710
with these data that can be controlled

463
00:19:40,389 --> 00:19:44,500
by the attacker so now the attacker can

464
00:19:41,710 --> 00:19:46,960
control the expected type and then it

465
00:19:44,500 --> 00:19:49,840
will it was extracting the rest of the

466
00:19:46,960 --> 00:19:51,730
XML and then deserializing that so now

467
00:19:49,840 --> 00:19:53,620
that I can control the expected type and

468
00:19:51,730 --> 00:19:55,690
the data being DC realized which means

469
00:19:53,620 --> 00:19:57,668
that the attacker can control the whole

470
00:19:55,690 --> 00:20:00,370
object graph and run an arbitrary code

471
00:19:57,669 --> 00:20:04,029
in the server so that was reported and

472
00:20:00,370 --> 00:20:06,820
was fixed okay so the third group is

473
00:20:04,029 --> 00:20:09,759
those serializers that are vulnerable in

474
00:20:06,820 --> 00:20:11,470
some specific configuration right so

475
00:20:09,759 --> 00:20:13,840
those are for example JavaScript

476
00:20:11,470 --> 00:20:17,049
serializer that is the native microsoft

477
00:20:13,840 --> 00:20:18,879
don't JSON deserialize ER and json dot

478
00:20:17,049 --> 00:20:20,710
net that is the third party one that is

479
00:20:18,879 --> 00:20:23,500
even more popular than the Microsoft one

480
00:20:20,710 --> 00:20:26,399
so let's see the first one this is

481
00:20:23,500 --> 00:20:29,019
JavaScript serialize a javascript

482
00:20:26,399 --> 00:20:31,149
serialize it is safe to be used with

483
00:20:29,019 --> 00:20:33,370
untrusted data as long as you don't do

484
00:20:31,149 --> 00:20:35,979
this that is basically passing a type

485
00:20:33,370 --> 00:20:37,719
resolver if you use a type resolver that

486
00:20:35,980 --> 00:20:39,970
means that is going to include the type

487
00:20:37,720 --> 00:20:42,909
information along the with a JSON data

488
00:20:39,970 --> 00:20:43,720
and then is going to process that type

489
00:20:42,909 --> 00:20:45,399
information

490
00:20:43,720 --> 00:20:47,350
so it's going to allow the attackers to

491
00:20:45,399 --> 00:20:49,299
are to instantiate arbitrary types and

492
00:20:47,350 --> 00:20:50,610
invoke these setters that will lead to

493
00:20:49,299 --> 00:20:54,519
arbitrary code execution

494
00:20:50,610 --> 00:20:56,949
same thing with JSON dotnet but instead

495
00:20:54,519 --> 00:20:58,929
from an argument to the to the

496
00:20:56,950 --> 00:21:00,820
constructor in this case is a property

497
00:20:58,929 --> 00:21:02,799
right and they are set in this type name

498
00:21:00,820 --> 00:21:04,658
handling which means that it will

499
00:21:02,799 --> 00:21:08,139
include and process the type information

500
00:21:04,659 --> 00:21:11,259
in the JSON data so you have to set

501
00:21:08,139 --> 00:21:13,840
known because if you set objects arrays

502
00:21:11,259 --> 00:21:16,120
or router then the framework will be

503
00:21:13,840 --> 00:21:20,080
including this information and it will

504
00:21:16,120 --> 00:21:22,178
make the the endpoint vulnerable alright

505
00:21:20,080 --> 00:21:23,918
so how about finding if your

506
00:21:22,179 --> 00:21:25,389
applications are vulnerable so they are

507
00:21:23,919 --> 00:21:27,279
like different approaches there the

508
00:21:25,389 --> 00:21:29,769
first one probably the most simple one

509
00:21:27,279 --> 00:21:31,690
is to inspect the traffic flow in in and

510
00:21:29,769 --> 00:21:35,169
out of your applications and look for

511
00:21:31,690 --> 00:21:38,080
magic numbers or these signatures of the

512
00:21:35,169 --> 00:21:41,649
traffic being sterilized data as we saw

513
00:21:38,080 --> 00:21:44,529
before this a EAD is an example of this

514
00:21:41,649 --> 00:21:46,508
this is the basis basics t4 format for

515
00:21:44,529 --> 00:21:49,450
the magic number of the binary formatter

516
00:21:46,509 --> 00:21:51,159
but there are other magic numbers like

517
00:21:49,450 --> 00:21:53,110
for example for the object state format

518
00:21:51,159 --> 00:21:55,509
error for the XML serialization and

519
00:21:53,110 --> 00:21:58,508
there are other encoding so I wrote this

520
00:21:55,509 --> 00:22:00,970
simple bear plug-in that you can freely

521
00:21:58,509 --> 00:22:03,250
use and basically we will use I will

522
00:22:00,970 --> 00:22:07,929
check for this magic magic numbers in

523
00:22:03,250 --> 00:22:10,539
different encodings so what I didn't

524
00:22:07,929 --> 00:22:12,639
meant to be like a perfect very accurate

525
00:22:10,539 --> 00:22:14,408
plug-in so it will have some false

526
00:22:12,639 --> 00:22:16,750
positives like for example if this magic

527
00:22:14,409 --> 00:22:19,659
number is found in in some images that

528
00:22:16,750 --> 00:22:21,639
will be reported and also it might find

529
00:22:19,659 --> 00:22:23,980
that you are sending said a lies data

530
00:22:21,639 --> 00:22:25,959
but it's not checking if there is a

531
00:22:23,980 --> 00:22:28,570
signature for that serialize data so

532
00:22:25,960 --> 00:22:30,009
maybe you cannot exploit it it's not a

533
00:22:28,570 --> 00:22:31,480
false positive because there is

534
00:22:30,009 --> 00:22:32,889
sterilized data but it's not straight

535
00:22:31,480 --> 00:22:35,320
about so we will see more about the

536
00:22:32,889 --> 00:22:36,939
viewstate later so the second approach

537
00:22:35,320 --> 00:22:39,309
is an active approach where you are

538
00:22:36,940 --> 00:22:42,429
basically sending a payload and watching

539
00:22:39,309 --> 00:22:43,059
if that payload gets executed and trying

540
00:22:42,429 --> 00:22:45,460
to recognize

541
00:22:43,059 --> 00:22:47,289
out-of-band if that gets executed so

542
00:22:45,460 --> 00:22:49,600
example of this is like for example

543
00:22:47,289 --> 00:22:51,639
making the server asleep for our number

544
00:22:49,600 --> 00:22:53,889
of seconds and then check if the

545
00:22:51,639 --> 00:22:56,678
response gets delayed or for example

546
00:22:53,889 --> 00:22:57,290
like I did with a sure you can run at

547
00:22:56,679 --> 00:22:59,870
the ns

548
00:22:57,290 --> 00:23:02,928
look up in order to if you control the

549
00:22:59,870 --> 00:23:07,610
DNS server to check if the payload is

550
00:23:02,929 --> 00:23:09,380
been executed IIST is another approach I

551
00:23:07,610 --> 00:23:10,610
don't know if it's passive active or

552
00:23:09,380 --> 00:23:12,650
something in the middle but I consider

553
00:23:10,610 --> 00:23:15,620
it active because you can you have to

554
00:23:12,650 --> 00:23:17,210
actually instrument your filter machines

555
00:23:15,620 --> 00:23:18,889
right so you instrument the virtual

556
00:23:17,210 --> 00:23:20,780
machines do you monitor what is going on

557
00:23:18,890 --> 00:23:23,299
inside of the virtual machine and then

558
00:23:20,780 --> 00:23:26,149
if some untrusted data gets into this

559
00:23:23,299 --> 00:23:29,870
deserialized method then we will report

560
00:23:26,150 --> 00:23:32,630
that that's good for pre-production but

561
00:23:29,870 --> 00:23:33,830
not for production anyway if you have

562
00:23:32,630 --> 00:23:36,110
access to the source code that's

563
00:23:33,830 --> 00:23:37,970
probably the easiest approach just check

564
00:23:36,110 --> 00:23:40,340
if some and think that there are some

565
00:23:37,970 --> 00:23:42,860
untrusted data flows into one of these

566
00:23:40,340 --> 00:23:44,510
three serialize things if you do that

567
00:23:42,860 --> 00:23:46,520
you have to consider that it's not as

568
00:23:44,510 --> 00:23:49,070
simple well for some for matters like

569
00:23:46,520 --> 00:23:51,590
binary format it is very simple first

570
00:23:49,070 --> 00:23:52,220
for some others for matters such as XML

571
00:23:51,590 --> 00:23:53,899
serialization

572
00:23:52,220 --> 00:23:56,270
you have to correlate different data

573
00:23:53,900 --> 00:23:58,190
flows and also taking a control flow

574
00:23:56,270 --> 00:23:59,809
into account because there can be a

575
00:23:58,190 --> 00:24:02,450
serialization binder that we will see

576
00:23:59,809 --> 00:24:04,070
later so you have to consider that but

577
00:24:02,450 --> 00:24:06,290
this is something that most of the

578
00:24:04,070 --> 00:24:08,030
static analysis tool can do so if you

579
00:24:06,290 --> 00:24:09,889
use fortify I know it worked because I

580
00:24:08,030 --> 00:24:14,750
brought the support for that so you are

581
00:24:09,890 --> 00:24:17,090
saying also fixing vulnerable endpoints

582
00:24:14,750 --> 00:24:18,260
right so now you find that you're the

583
00:24:17,090 --> 00:24:26,928
found that your application is

584
00:24:18,260 --> 00:24:31,760
vulnerable sorry so how can you fix it

585
00:24:26,929 --> 00:24:35,049
right so the first approach is do you

586
00:24:31,760 --> 00:24:38,450
really need to sterilize that data and

587
00:24:35,049 --> 00:24:39,770
this seems silly but I found like many

588
00:24:38,450 --> 00:24:42,830
application that were using

589
00:24:39,770 --> 00:24:44,809
serialization for Strings right and one

590
00:24:42,830 --> 00:24:47,240
good case for for this and one good

591
00:24:44,809 --> 00:24:49,460
example is the Nancy web application

592
00:24:47,240 --> 00:24:50,720
framework the Nancy is basically a web

593
00:24:49,460 --> 00:24:53,240
application framework that is very

594
00:24:50,720 --> 00:24:55,820
similar to Sinatra framework in in Ruby

595
00:24:53,240 --> 00:24:57,620
and they care about security and they

596
00:24:55,820 --> 00:24:59,570
implemented this hard protection but

597
00:24:57,620 --> 00:25:00,409
instead of putting a unique token into

598
00:24:59,570 --> 00:25:03,830
the safe

599
00:25:00,410 --> 00:25:06,530
cookie they were sterilizing that token

600
00:25:03,830 --> 00:25:08,720
into binary format sterilized data and

601
00:25:06,530 --> 00:25:11,928
then putting that into the cookie so

602
00:25:08,720 --> 00:25:13,250
making the whole framework and then all

603
00:25:11,929 --> 00:25:15,140
the applications build using this

604
00:25:13,250 --> 00:25:17,480
framework vulnerable to remote execution

605
00:25:15,140 --> 00:25:19,250
because of this implementation of the

606
00:25:17,480 --> 00:25:21,950
CSR protection

607
00:25:19,250 --> 00:25:25,940
same thing with type discriminators and

608
00:25:21,950 --> 00:25:28,730
JSON and XML is okay to to use but you

609
00:25:25,940 --> 00:25:31,760
should not use it we use them with type

610
00:25:28,730 --> 00:25:33,919
information right so that was the case

611
00:25:31,760 --> 00:25:35,169
of the breeze framework breeze is a

612
00:25:33,919 --> 00:25:37,250
dotnet

613
00:25:35,169 --> 00:25:38,720
entity management framework they

614
00:25:37,250 --> 00:25:39,770
basically suppose it's very similar to

615
00:25:38,720 --> 00:25:41,870
spring data rest

616
00:25:39,770 --> 00:25:44,929
so they expose some database entities

617
00:25:41,870 --> 00:25:47,600
through our restful web service

618
00:25:44,929 --> 00:25:49,850
automatically and they were sending the

619
00:25:47,600 --> 00:25:52,309
type information to the JavaScript

620
00:25:49,850 --> 00:25:54,230
client so that made no sense because

621
00:25:52,309 --> 00:25:56,899
javascript is not going to understand

622
00:25:54,230 --> 00:25:59,990
the dotnet type so they were not using

623
00:25:56,900 --> 00:26:01,790
that so because of these a mistake the

624
00:25:59,990 --> 00:26:04,280
whole framework was vulnerable to

625
00:26:01,790 --> 00:26:07,158
promote code execution and they fix it

626
00:26:04,280 --> 00:26:09,290
very quickly in a matter of hours by

627
00:26:07,159 --> 00:26:11,929
just setting this type name handling

628
00:26:09,290 --> 00:26:14,210
setting to known right so this is

629
00:26:11,929 --> 00:26:15,559
actually the default value so probably

630
00:26:14,210 --> 00:26:17,150
at some point they were playing with

631
00:26:15,559 --> 00:26:18,950
that and they change that and they

632
00:26:17,150 --> 00:26:20,960
remain in the code so I think it's a

633
00:26:18,950 --> 00:26:24,169
good idea to explicitly stab these

634
00:26:20,960 --> 00:26:26,679
secure values explicitly and then even

635
00:26:24,169 --> 00:26:29,660
add a comment like do not change this

636
00:26:26,679 --> 00:26:34,320
please

637
00:26:29,660 --> 00:26:36,390
so okay well if you really need to

638
00:26:34,320 --> 00:26:38,370
serialize data so the first case was

639
00:26:36,390 --> 00:26:41,400
when do were satellites in a stream so

640
00:26:38,370 --> 00:26:43,169
that was not required now if you have

641
00:26:41,400 --> 00:26:45,240
some object graph that you want to

642
00:26:43,170 --> 00:26:47,610
persist in the client side for example

643
00:26:45,240 --> 00:26:50,880
for performance reasons or whatever

644
00:26:47,610 --> 00:26:54,000
reasons then if you're not expecting the

645
00:26:50,880 --> 00:26:56,100
client to modify that data then sign it

646
00:26:54,000 --> 00:26:59,130
I'm verified that the data hasn't been

647
00:26:56,100 --> 00:27:01,590
modified right if you do that always use

648
00:26:59,130 --> 00:27:04,440
an H Mac and never use something like

649
00:27:01,590 --> 00:27:06,480
md5 or sha-1 with secret and data

650
00:27:04,440 --> 00:27:09,420
because that's what about two has length

651
00:27:06,480 --> 00:27:12,000
extension attacks and this is the way

652
00:27:09,420 --> 00:27:14,940
that app Harbor and issuer actually fix

653
00:27:12,000 --> 00:27:17,190
their issues and they just sign the the

654
00:27:14,940 --> 00:27:19,500
data that they were not expecting anyone

655
00:27:17,190 --> 00:27:23,160
to change and then they verify that

656
00:27:19,500 --> 00:27:25,559
touch ends didn't get modified same

657
00:27:23,160 --> 00:27:27,840
thing with asp.net if you remember back

658
00:27:25,559 --> 00:27:29,940
in 2013 they removed this cookie temp

659
00:27:27,840 --> 00:27:31,889
data provider and they replace it with

660
00:27:29,940 --> 00:27:34,559
something else and that was basically

661
00:27:31,890 --> 00:27:36,690
the same approach of sterilizing

662
00:27:34,559 --> 00:27:39,270
server-side data into the client side

663
00:27:36,690 --> 00:27:41,490
but this time they were using the data

664
00:27:39,270 --> 00:27:43,350
protector API right they were doing

665
00:27:41,490 --> 00:27:45,480
something very similar to this call the

666
00:27:43,350 --> 00:27:48,659
data protector API protected by it and

667
00:27:45,480 --> 00:27:51,030
that will basically sign and encrypt the

668
00:27:48,660 --> 00:27:54,300
data using the web config validation and

669
00:27:51,030 --> 00:27:56,760
encryption keys and then this data won't

670
00:27:54,300 --> 00:27:59,940
be able to be tampered with without the

671
00:27:56,760 --> 00:28:01,650
server-side noticing so another good

672
00:27:59,940 --> 00:28:05,780
example of sign-in I'm verifying that

673
00:28:01,650 --> 00:28:08,100
the data is the asp.net viewstate right

674
00:28:05,780 --> 00:28:10,080
so for those of you that are not

675
00:28:08,100 --> 00:28:14,189
familiar with the viewstate it's like a

676
00:28:10,080 --> 00:28:17,370
representation of the state of a page so

677
00:28:14,190 --> 00:28:20,160
the server is going to send you the

678
00:28:17,370 --> 00:28:23,580
state of the page to you as a hidden

679
00:28:20,160 --> 00:28:25,290
field for the form field and then when

680
00:28:23,580 --> 00:28:27,000
you submit the form back you are

681
00:28:25,290 --> 00:28:28,920
submitting their previous state so the

682
00:28:27,000 --> 00:28:31,020
server can reconstruct a previous state

683
00:28:28,920 --> 00:28:35,070
and then continue from there so this is

684
00:28:31,020 --> 00:28:37,860
used by asp.net and I think that in the

685
00:28:35,070 --> 00:28:41,370
beginning they were not even forcing or

686
00:28:37,860 --> 00:28:43,379
they were not signing and encrypting the

687
00:28:41,370 --> 00:28:46,050
view state so their problem

688
00:28:43,380 --> 00:28:48,840
back in these days was that if there was

689
00:28:46,050 --> 00:28:49,350
some sensitive data for example in the

690
00:28:48,840 --> 00:28:51,629
viewstate

691
00:28:49,350 --> 00:28:55,800
then the clients were going to be able

692
00:28:51,630 --> 00:28:58,080
to extract and dig that data also if the

693
00:28:55,800 --> 00:29:00,030
client was able to modify the data

694
00:28:58,080 --> 00:29:02,189
because it was not it was not sign it

695
00:29:00,030 --> 00:29:04,350
and then they could change the

696
00:29:02,190 --> 00:29:07,410
application logic so that was back in

697
00:29:04,350 --> 00:29:11,219
the good days like many years ago and at

698
00:29:07,410 --> 00:29:13,680
some point in version 4.5.2 Microsoft

699
00:29:11,220 --> 00:29:16,260
even started ignoring the enable video

700
00:29:13,680 --> 00:29:17,100
State Mac meaning that even if you set

701
00:29:16,260 --> 00:29:19,890
that to false

702
00:29:17,100 --> 00:29:21,870
they will always encrypt and sign your

703
00:29:19,890 --> 00:29:25,650
view state which is good and they even

704
00:29:21,870 --> 00:29:28,409
back ported that back to 1.1 so I was

705
00:29:25,650 --> 00:29:31,440
curious and I run Arshavin query and I

706
00:29:28,410 --> 00:29:34,080
found that more than 200 servers is

707
00:29:31,440 --> 00:29:36,570
still running vulnerable version that

708
00:29:34,080 --> 00:29:38,730
are not using any signature or

709
00:29:36,570 --> 00:29:42,330
encryption in the view state which makes

710
00:29:38,730 --> 00:29:45,960
like a good cryptocurrency botnet or

711
00:29:42,330 --> 00:29:48,300
something like that anyway at some point

712
00:29:45,960 --> 00:29:51,450
they improve the cryptographic posture

713
00:29:48,300 --> 00:29:53,520
of the abuse state by actually using a

714
00:29:51,450 --> 00:29:56,490
key derivation function and this was a

715
00:29:53,520 --> 00:29:58,530
very interesting approach because if the

716
00:29:56,490 --> 00:30:01,080
attacker is able to leak the validation

717
00:29:58,530 --> 00:30:02,639
and encryption key then they will be

718
00:30:01,080 --> 00:30:05,220
able to actually change the encryption

719
00:30:02,640 --> 00:30:07,530
and change will not change the christian

720
00:30:05,220 --> 00:30:09,210
but changing the view state and then put

721
00:30:07,530 --> 00:30:13,050
in the payload there and get our query

722
00:30:09,210 --> 00:30:15,750
code execution so what they did is that

723
00:30:13,050 --> 00:30:18,210
they generate some per request are

724
00:30:15,750 --> 00:30:21,210
unique strings that they call purposes

725
00:30:18,210 --> 00:30:23,070
and what they do is that they run these

726
00:30:21,210 --> 00:30:25,230
through a key DF a key derivation

727
00:30:23,070 --> 00:30:28,290
function in order to generate some keys

728
00:30:25,230 --> 00:30:29,940
that are unique for each request now if

729
00:30:28,290 --> 00:30:32,310
the attacker is able to link this

730
00:30:29,940 --> 00:30:34,980
encryption and validation keys those

731
00:30:32,310 --> 00:30:36,629
kids won't be able to tamper and modify

732
00:30:34,980 --> 00:30:38,910
the view state because the ones that

733
00:30:36,630 --> 00:30:42,600
will be used are these ones over here

734
00:30:38,910 --> 00:30:45,060
right so I just you know connected a

735
00:30:42,600 --> 00:30:48,629
debugger and took a look and I visit the

736
00:30:45,060 --> 00:30:51,540
account register page and then I check

737
00:30:48,630 --> 00:30:53,490
the values for these purposes strings so

738
00:30:51,540 --> 00:30:55,680
the first one is primary purpose right

739
00:30:53,490 --> 00:30:56,600
and this one is always going to be the

740
00:30:55,680 --> 00:30:58,519
same is this

741
00:30:56,600 --> 00:31:00,259
over here with the client state if he's

742
00:30:58,519 --> 00:31:02,389
for the viewstate other values for other

743
00:31:00,259 --> 00:31:05,529
things and then you have these specific

744
00:31:02,389 --> 00:31:08,360
purposes right so the first one is a

745
00:31:05,529 --> 00:31:13,070
template source directory a slash

746
00:31:08,360 --> 00:31:16,340
account the second one is an account

747
00:31:13,070 --> 00:31:19,129
register aspx so both of them quite

748
00:31:16,340 --> 00:31:21,850
predictable for an attacker right the

749
00:31:19,130 --> 00:31:24,350
third one looks like pretty random

750
00:31:21,850 --> 00:31:26,779
generated like these seven seven six

751
00:31:24,350 --> 00:31:30,199
easy whatever value that looks like

752
00:31:26,779 --> 00:31:31,940
arbitrary value however this is the same

753
00:31:30,200 --> 00:31:35,330
value that is used in your anti

754
00:31:31,940 --> 00:31:37,460
cross-site request forgery token cookie

755
00:31:35,330 --> 00:31:39,799
right so the attacker is going to be

756
00:31:37,460 --> 00:31:44,179
able to read that and it's going to be

757
00:31:39,799 --> 00:31:46,250
able to generate all these strings and

758
00:31:44,179 --> 00:31:48,019
therefore if they are able to leak this

759
00:31:46,250 --> 00:31:50,179
case then they will be able to generate

760
00:31:48,019 --> 00:31:52,220
those keys right so now the problem is

761
00:31:50,179 --> 00:31:55,309
you have to be very careful with not

762
00:31:52,220 --> 00:31:57,169
leaking the case the first way that the

763
00:31:55,309 --> 00:31:59,178
attacker can actually lick the keys is

764
00:31:57,169 --> 00:32:00,590
if they find a file disclosure

765
00:31:59,179 --> 00:32:04,820
vulnerability in your application like

766
00:32:00,590 --> 00:32:06,889
for example and xxe vulnerability also

767
00:32:04,820 --> 00:32:10,100
they may be some vulnerabilities in the

768
00:32:06,889 --> 00:32:11,508
framework like in 2010 and 15 that allow

769
00:32:10,100 --> 00:32:16,250
the attackers to actually leak those

770
00:32:11,509 --> 00:32:18,379
keys from Troy's side you may recognize

771
00:32:16,250 --> 00:32:21,049
these apparently you can actually leak

772
00:32:18,379 --> 00:32:23,389
the validation key and decryption key if

773
00:32:21,049 --> 00:32:26,658
you are not using custom errors at least

774
00:32:23,389 --> 00:32:29,178
in the past also I found like hundreds

775
00:32:26,659 --> 00:32:31,610
of validation and decryption keys in

776
00:32:29,179 --> 00:32:34,279
github so if you are going to install

777
00:32:31,610 --> 00:32:38,090
something like a CMS or a block just by

778
00:32:34,279 --> 00:32:40,789
you know cloning the repo from from

779
00:32:38,090 --> 00:32:42,649
github and then installing that be very

780
00:32:40,789 --> 00:32:44,299
careful and always generate nucleus

781
00:32:42,649 --> 00:32:46,158
never use the ones that are provided by

782
00:32:44,299 --> 00:32:48,440
these kind of projects same thing with

783
00:32:46,159 --> 00:32:50,960
one-click installer do you get the

784
00:32:48,440 --> 00:32:53,509
latest version of these whatever CMS or

785
00:32:50,960 --> 00:32:55,639
whatever block application and then you

786
00:32:53,509 --> 00:32:58,549
stole it and some of them will use

787
00:32:55,639 --> 00:33:00,439
static keys that they won't generate per

788
00:32:58,549 --> 00:33:02,629
installation in those cases the attacker

789
00:33:00,440 --> 00:33:05,059
will be able to install the same at CMS

790
00:33:02,629 --> 00:33:07,158
for example for example and then ma'am

791
00:33:05,059 --> 00:33:07,879
you know no lick the keys and then

792
00:33:07,159 --> 00:33:09,410
attack and get

793
00:33:07,879 --> 00:33:12,110
arbitrary code execution in yours

794
00:33:09,410 --> 00:33:14,150
EMS block application or whatever so be

795
00:33:12,110 --> 00:33:16,850
very very careful with leaking the key a

796
00:33:14,150 --> 00:33:19,490
good advice is to encrypt some sections

797
00:33:16,850 --> 00:33:21,830
of your web config file so you can

798
00:33:19,490 --> 00:33:24,470
actually ask a is to encrypt this

799
00:33:21,830 --> 00:33:25,879
section so if you get like xxe

800
00:33:24,470 --> 00:33:27,590
vulnerability or a file displeasure

801
00:33:25,880 --> 00:33:32,060
vulnerability at least they won't be

802
00:33:27,590 --> 00:33:33,889
able to leak those keys so sign-in is

803
00:33:32,060 --> 00:33:36,260
okay if the client doesn't need to

804
00:33:33,890 --> 00:33:38,510
modify the data so that's that's that's

805
00:33:36,260 --> 00:33:40,700
okay but what if this is a pure like

806
00:33:38,510 --> 00:33:42,920
client server that are sending like

807
00:33:40,700 --> 00:33:45,740
arbitrary messages then you cannot sign

808
00:33:42,920 --> 00:33:48,200
the the data because in that case the

809
00:33:45,740 --> 00:33:50,300
client needs to have the signature keys

810
00:33:48,200 --> 00:33:52,490
the validation keys which if the

811
00:33:50,300 --> 00:33:53,540
attacker is in control of the client it

812
00:33:52,490 --> 00:33:56,240
makes no sense

813
00:33:53,540 --> 00:34:00,220
so these in this case what you have to

814
00:33:56,240 --> 00:34:02,750
do is actually bind it right this is

815
00:34:00,220 --> 00:34:04,790
very simple it's very similar to the

816
00:34:02,750 --> 00:34:06,860
concept of the look-ahead visualization

817
00:34:04,790 --> 00:34:08,480
in Java so basically right before

818
00:34:06,860 --> 00:34:10,699
instantiate in those types that are

819
00:34:08,480 --> 00:34:13,460
controlled by the attacker just stop for

820
00:34:10,699 --> 00:34:16,040
a while and ask yourself if you want to

821
00:34:13,460 --> 00:34:17,990
really be serialize yes this assembly

822
00:34:16,040 --> 00:34:20,389
name and this type name right so you are

823
00:34:17,989 --> 00:34:22,310
provided with this assembly name and

824
00:34:20,389 --> 00:34:24,290
type name and you can stop and apply a

825
00:34:22,310 --> 00:34:26,060
white list or a black list and then

826
00:34:24,290 --> 00:34:29,690
decide if you want to continue with the

827
00:34:26,060 --> 00:34:31,460
digitalization or stop right so this is

828
00:34:29,690 --> 00:34:34,070
a done by implementing the serialization

829
00:34:31,460 --> 00:34:36,699
binder interface this is a good example

830
00:34:34,070 --> 00:34:39,260
by jonathan built from Microsoft

831
00:34:36,699 --> 00:34:42,799
basically just implement this interface

832
00:34:39,260 --> 00:34:44,780
and then prepare like a list of allowed

833
00:34:42,800 --> 00:34:47,110
types with the type names that you are

834
00:34:44,780 --> 00:34:49,520
going to allow and then a pre-loaded

835
00:34:47,110 --> 00:34:52,760
instance of those types this will be

836
00:34:49,520 --> 00:34:54,530
important I will show you why later then

837
00:34:52,760 --> 00:34:57,560
just implement they override their bind

838
00:34:54,530 --> 00:34:59,030
to type and then check if the type that

839
00:34:57,560 --> 00:35:01,850
the attacker is sending is what is

840
00:34:59,030 --> 00:35:04,070
within the white list of allowed types

841
00:35:01,850 --> 00:35:05,990
and if that's the case then continuum

842
00:35:04,070 --> 00:35:10,240
returned the preloaded type otherwise

843
00:35:05,990 --> 00:35:15,350
just throw an exception and aboard the

844
00:35:10,240 --> 00:35:17,509
the visualization so then you have to

845
00:35:15,350 --> 00:35:19,580
actually instantiate the serialization

846
00:35:17,510 --> 00:35:22,460
binder assign it to the binder property

847
00:35:19,580 --> 00:35:25,160
and deserialize right easy

848
00:35:22,460 --> 00:35:27,109
so while I was reviewing some Microsoft

849
00:35:25,160 --> 00:35:28,670
product I found one of them being

850
00:35:27,109 --> 00:35:32,000
vulnerable to remote code execution

851
00:35:28,670 --> 00:35:34,040
through visualization and they had

852
00:35:32,000 --> 00:35:36,290
something they have a additional ization

853
00:35:34,040 --> 00:35:39,349
binder in place so it was like okay they

854
00:35:36,290 --> 00:35:41,779
arcane about this but then I realized

855
00:35:39,349 --> 00:35:44,960
that the serialization ban there was not

856
00:35:41,780 --> 00:35:48,200
that secure as they thought for example

857
00:35:44,960 --> 00:35:50,720
so this is not the actual Microsoft code

858
00:35:48,200 --> 00:35:53,089
but this is something that I've put

859
00:35:50,720 --> 00:35:55,250
together in order to reproduce more or

860
00:35:53,089 --> 00:35:56,509
less what they were doing so I'm still

861
00:35:55,250 --> 00:35:58,609
in the process of this closing this one

862
00:35:56,510 --> 00:36:00,319
everything I haven't been fixed so at

863
00:35:58,609 --> 00:36:03,170
some point what they were doing is they

864
00:36:00,319 --> 00:36:05,210
were checking if the namespace starts

865
00:36:03,170 --> 00:36:07,369
with Microsoft dot put the name of a

866
00:36:05,210 --> 00:36:10,490
very popular Microsoft product here and

867
00:36:07,369 --> 00:36:13,760
if that's the case then load the type

868
00:36:10,490 --> 00:36:16,058
and return it otherwise return neuro so

869
00:36:13,760 --> 00:36:20,540
there are multiple vulnerabilities here

870
00:36:16,059 --> 00:36:22,760
first of all if you return null it may

871
00:36:20,540 --> 00:36:24,470
not do what you may think that is doing

872
00:36:22,760 --> 00:36:26,270
it's not going to avoid the desal

873
00:36:24,470 --> 00:36:29,029
ization it's going to fall back to the

874
00:36:26,270 --> 00:36:31,040
default binder which will bind anything

875
00:36:29,030 --> 00:36:33,650
which will bind including the remote

876
00:36:31,040 --> 00:36:36,558
code execution gadget type so it's not I

877
00:36:33,650 --> 00:36:39,589
am not protecting anything so the second

878
00:36:36,559 --> 00:36:42,109
problem here is that loading the type

879
00:36:39,589 --> 00:36:44,750
using reflection at this realization

880
00:36:42,109 --> 00:36:46,250
time is very costly and actually this

881
00:36:44,750 --> 00:36:48,290
will lead to the OS the attacker can

882
00:36:46,250 --> 00:36:50,210
easily do it your application because

883
00:36:48,290 --> 00:36:52,369
you are not using pre-loaded types if

884
00:36:50,210 --> 00:36:55,160
you remember the good example from from

885
00:36:52,369 --> 00:36:56,839
jonathan he was actually pre loading the

886
00:36:55,160 --> 00:36:59,359
types here and then just returning them

887
00:36:56,839 --> 00:37:02,359
in a method that gets executed you then

888
00:36:59,359 --> 00:37:05,540
did this realization and the third

889
00:37:02,359 --> 00:37:07,848
problem here is that this space this

890
00:37:05,540 --> 00:37:09,859
namespace here is just huge it contains

891
00:37:07,849 --> 00:37:12,470
like thousands of applicable of types

892
00:37:09,859 --> 00:37:14,390
right so even if the attacker cannot

893
00:37:12,470 --> 00:37:16,598
find a remote code execution gadget

894
00:37:14,390 --> 00:37:19,730
within this Microsoft dot something

895
00:37:16,599 --> 00:37:21,410
namespace they will be able probably

896
00:37:19,730 --> 00:37:23,960
chances are that they will be able to

897
00:37:21,410 --> 00:37:26,930
find what is known as a bypass and cut

898
00:37:23,960 --> 00:37:29,030
yet and what is a bypass guard yet it's

899
00:37:26,930 --> 00:37:30,710
just a gadget so it starts with a desire

900
00:37:29,030 --> 00:37:32,990
a station callback and at some point

901
00:37:30,710 --> 00:37:35,270
instead of running arbitrary code for

902
00:37:32,990 --> 00:37:36,229
example or doing bad things they just

903
00:37:35,270 --> 00:37:38,750
run

904
00:37:36,230 --> 00:37:40,790
nested this realization operation the

905
00:37:38,750 --> 00:37:42,920
problem here is that even though you are

906
00:37:40,790 --> 00:37:45,830
protecting your outer digitization

907
00:37:42,920 --> 00:37:49,070
operation the inner one the one that is

908
00:37:45,830 --> 00:37:52,060
run by this bypass cut yet has no binder

909
00:37:49,070 --> 00:37:54,590
in it right you have its instantiated

910
00:37:52,060 --> 00:37:56,750
here and then just this realizing there

911
00:37:54,590 --> 00:37:58,910
is no binder assignment so that means

912
00:37:56,750 --> 00:38:00,440
that this distillation operation will

913
00:37:58,910 --> 00:38:03,618
let all the remote code execution

914
00:38:00,440 --> 00:38:05,390
graduate types to be processed and

915
00:38:03,619 --> 00:38:09,170
deserialize and and the pillows to be

916
00:38:05,390 --> 00:38:11,118
executed so yeah this is basically some

917
00:38:09,170 --> 00:38:12,980
apps what I was talking about never

918
00:38:11,119 --> 00:38:14,570
return null because that this will fall

919
00:38:12,980 --> 00:38:19,040
back to the default binder and that's

920
00:38:14,570 --> 00:38:21,200
bad also don't use reflection to load

921
00:38:19,040 --> 00:38:25,279
types at runtime because that will do as

922
00:38:21,200 --> 00:38:27,950
your application and the fourth approach

923
00:38:25,280 --> 00:38:29,960
is to replace it right so we so the

924
00:38:27,950 --> 00:38:32,089
first one is stop using it if you don't

925
00:38:29,960 --> 00:38:33,440
need it the second one if the client

926
00:38:32,090 --> 00:38:35,780
doesn't need to change the data then

927
00:38:33,440 --> 00:38:38,690
sign it and verify that third approach

928
00:38:35,780 --> 00:38:41,030
is if the client needs to actually send

929
00:38:38,690 --> 00:38:44,030
you data then use a binder to control

930
00:38:41,030 --> 00:38:47,090
what types gets digitized and the fourth

931
00:38:44,030 --> 00:38:49,430
approach is if the architecture of your

932
00:38:47,090 --> 00:38:51,680
application allows you to do that change

933
00:38:49,430 --> 00:38:53,240
these formats that include the type

934
00:38:51,680 --> 00:38:55,279
discriminators the type information

935
00:38:53,240 --> 00:38:56,990
change that with something else and a

936
00:38:55,280 --> 00:39:00,020
good alternative here is Google protocol

937
00:38:56,990 --> 00:39:01,669
buffers where do you agree the client

938
00:39:00,020 --> 00:39:04,640
and the server agree in what they are

939
00:39:01,670 --> 00:39:06,560
going to exchange and then the exchange

940
00:39:04,640 --> 00:39:08,720
does the data so if the urban talks

941
00:39:06,560 --> 00:39:10,759
change an instance of a comb dog acme

942
00:39:08,720 --> 00:39:12,649
dot user then they will agree they will

943
00:39:10,760 --> 00:39:14,690
know in advance that they are going to

944
00:39:12,650 --> 00:39:16,670
exchange that and then they will just

945
00:39:14,690 --> 00:39:18,050
share the name of the user the last name

946
00:39:16,670 --> 00:39:20,210
of the user the address of the user but

947
00:39:18,050 --> 00:39:23,600
no type information no property type

948
00:39:20,210 --> 00:39:25,070
names or much like that and also if you

949
00:39:23,600 --> 00:39:27,049
don't really need the type information

950
00:39:25,070 --> 00:39:29,660
like we said before just don't use it

951
00:39:27,050 --> 00:39:31,640
and that will make those JSON XML

952
00:39:29,660 --> 00:39:35,540
sterilizers to be safe at least from

953
00:39:31,640 --> 00:39:37,819
this kind of attacks so with that mahalo

954
00:39:35,540 --> 00:39:41,080
and if you have any questions I think we

955
00:39:37,820 --> 00:39:41,080
have time right to take questions

956
00:40:15,450 --> 00:40:18,689
[Music]

957
00:40:19,829 --> 00:40:22,829
yeah

958
00:40:33,750 --> 00:40:43,480
yeah yes that's that's this approach and

959
00:40:39,510 --> 00:40:44,800
and basically the only cases where you

960
00:40:43,480 --> 00:40:47,230
really need include type information

961
00:40:44,800 --> 00:40:49,810
that I can think of is if you are

962
00:40:47,230 --> 00:40:52,839
dealing with for example polymorphism

963
00:40:49,810 --> 00:40:55,990
types where you may send I don't know an

964
00:40:52,839 --> 00:40:58,480
instance of an animal but that may you

965
00:40:55,990 --> 00:41:00,339
need the information to need to to know

966
00:40:58,480 --> 00:41:01,810
if you need to reconstruct a dog or a

967
00:41:00,339 --> 00:41:03,069
cat for example so you need to send

968
00:41:01,810 --> 00:41:04,960
information the type information with

969
00:41:03,069 --> 00:41:07,960
that and that's the whole purpose of all

970
00:41:04,960 --> 00:41:10,810
these time named handling things the

971
00:41:07,960 --> 00:41:12,849
JSON JavaScript scripts I realized there

972
00:41:10,810 --> 00:41:15,880
are these simple type resolver and so on

973
00:41:12,849 --> 00:41:17,290
so those are meant to deal with some of

974
00:41:15,880 --> 00:41:19,660
the object object-oriented programming

975
00:41:17,290 --> 00:41:22,720
features like polymorphism generics and

976
00:41:19,660 --> 00:41:24,759
so on so if you you should be only be

977
00:41:22,720 --> 00:41:27,459
sending things like dto some employers

978
00:41:24,760 --> 00:41:29,490
write something very simple if you find

979
00:41:27,460 --> 00:41:32,170
yourself that you require things like

980
00:41:29,490 --> 00:41:36,629
polymorphism then maybe you need to

981
00:41:32,170 --> 00:41:36,630
rethink what you're sending

982
00:41:53,619 --> 00:42:10,279
Ivano Africa there you go

983
00:42:03,019 --> 00:42:12,799
I love this is life sorry just again so

984
00:42:10,279 --> 00:42:15,199
yeah this is the the whole design flow

985
00:42:12,799 --> 00:42:17,659
in DC analyzation is that they allow you

986
00:42:15,199 --> 00:42:19,999
to change the type discriminators and

987
00:42:17,659 --> 00:42:22,159
mean that happens then attackers can

988
00:42:19,999 --> 00:42:25,749
arbitrary instantiate any type and

989
00:42:22,159 --> 00:42:25,749
that's the big problem here

990
00:42:28,149 --> 00:42:34,120
any questions

991
00:42:31,389 --> 00:42:40,249
alright so thank you

992
00:42:34,120 --> 00:42:40,249
[Applause]

