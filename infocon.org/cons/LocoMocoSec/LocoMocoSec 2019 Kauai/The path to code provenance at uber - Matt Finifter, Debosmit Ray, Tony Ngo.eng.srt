1
00:00:00,089 --> 00:00:04,560
thank you all for coming today so right

2
00:00:02,639 --> 00:00:07,048
now we will start talking about how we

3
00:00:04,560 --> 00:00:11,489
approach the problem of code provenance

4
00:00:07,049 --> 00:00:13,290
at uber my name is Babu I am a software

5
00:00:11,490 --> 00:00:15,990
engineer on the application security

6
00:00:13,290 --> 00:00:42,989
team I was born in Mordor and raised by

7
00:00:15,990 --> 00:00:45,420
wolves and hey I'm I'm Tony and I you

8
00:00:42,989 --> 00:00:49,919
know I'm gonna change that first bullet

9
00:00:45,420 --> 00:00:52,350
I recently got to spend a couple days in

10
00:00:49,920 --> 00:00:56,120
Hawaii so I actually wish I was born and

11
00:00:52,350 --> 00:00:56,120
raised in Hawaii because it's awesome

12
00:00:57,510 --> 00:01:01,649
I have not escaped this F yet I still

13
00:00:59,760 --> 00:01:04,979
live there where I am constantly

14
00:01:01,649 --> 00:01:09,210
terrorized for food by this face my pups

15
00:01:04,979 --> 00:01:11,549
oh yeah for sure you guys you're me cool

16
00:01:09,210 --> 00:01:13,048
all right so we're here to talk to you

17
00:01:11,549 --> 00:01:15,930
guys about code providence right and

18
00:01:13,049 --> 00:01:19,799
Before we jump in we're gonna take a

19
00:01:15,930 --> 00:01:22,229
look at the agenda so we'll first start

20
00:01:19,799 --> 00:01:25,740
by defining kind of what code provenance

21
00:01:22,229 --> 00:01:28,289
is and what we aim to solve and then

22
00:01:25,740 --> 00:01:31,199
we'll dive into a bit of some exam you

23
00:01:28,290 --> 00:01:33,570
know some a bit on the software

24
00:01:31,200 --> 00:01:36,450
development process at uber mainly to

25
00:01:33,570 --> 00:01:37,889
kind of give you guys a base onto some

26
00:01:36,450 --> 00:01:40,829
of the work that we put in place in that

27
00:01:37,890 --> 00:01:42,689
process and then we'll dive into some

28
00:01:40,829 --> 00:01:45,779
examples commit signing and third-party

29
00:01:42,689 --> 00:01:47,279
dependencies to kind of get all the fun

30
00:01:45,780 --> 00:01:50,100
learnings and experiences we got from

31
00:01:47,280 --> 00:01:52,110
that and then we'll wrap it all up by

32
00:01:50,100 --> 00:01:54,298
kind of taking a look at on how we

33
00:01:52,110 --> 00:01:56,520
utilize these foundations in order to

34
00:01:54,299 --> 00:01:58,140
build and chain enforcement's all along

35
00:01:56,520 --> 00:02:00,000
the way all along the software

36
00:01:58,140 --> 00:02:01,320
development lifecycle and of course

37
00:02:00,000 --> 00:02:05,479
we'll leave some some time at the end

38
00:02:01,320 --> 00:02:09,209
for us and some Q&A cool let's dive in

39
00:02:05,479 --> 00:02:09,899
so code providence what is code

40
00:02:09,209 --> 00:02:11,670
provenance

41
00:02:09,899 --> 00:02:13,130
right what what is this thing that we're

42
00:02:11,670 --> 00:02:16,640
talking about

43
00:02:13,130 --> 00:02:19,070
so we kind of like to begin by defining

44
00:02:16,640 --> 00:02:21,640
it with words before we actually dive

45
00:02:19,070 --> 00:02:27,829
into defining what it means with slides

46
00:02:21,640 --> 00:02:30,649
so to us code provenance is ensuring

47
00:02:27,830 --> 00:02:33,080
that we have a verifiable attestation of

48
00:02:30,650 --> 00:02:35,450
the origin of all code running in

49
00:02:33,080 --> 00:02:38,300
production so that we can have a route

50
00:02:35,450 --> 00:02:41,030
of trust as we kind of move forward to

51
00:02:38,300 --> 00:02:43,610
define and enforce a collection of

52
00:02:41,030 --> 00:02:47,450
policies throughout the different stages

53
00:02:43,610 --> 00:02:53,930
of the software development process you

54
00:02:47,450 --> 00:02:55,970
guys get all that we're done um so let's

55
00:02:53,930 --> 00:02:58,220
let's talk a little bit about what we're

56
00:02:55,970 --> 00:02:59,600
kind of protecting against when we were

57
00:02:58,220 --> 00:03:01,390
talking about code profit it's like what

58
00:02:59,600 --> 00:03:05,959
are we protecting against here

59
00:03:01,390 --> 00:03:08,089
well checking for vulnerable and or

60
00:03:05,959 --> 00:03:09,560
unreliable or buggy code it's kind of

61
00:03:08,090 --> 00:03:12,020
it's kind of standard right and it's it

62
00:03:09,560 --> 00:03:14,270
it's a small subset of things and

63
00:03:12,020 --> 00:03:16,190
reasons for why you want code to go

64
00:03:14,270 --> 00:03:19,519
through a process before it actually

65
00:03:16,190 --> 00:03:21,680
goes and makes it into production so a

66
00:03:19,519 --> 00:03:24,140
code review time this is kind of our

67
00:03:21,680 --> 00:03:27,769
first time and first chance to check for

68
00:03:24,140 --> 00:03:30,589
errors check for bugs check for

69
00:03:27,769 --> 00:03:33,140
vulnerabilities right both through human

70
00:03:30,590 --> 00:03:37,519
through peer review or robots through

71
00:03:33,140 --> 00:03:39,380
automated analysis we can then we can

72
00:03:37,519 --> 00:03:41,680
check the diff to make sure that no new

73
00:03:39,380 --> 00:03:46,370
issue have has been kind of introduced

74
00:03:41,680 --> 00:03:48,590
at CI testing time we can ensure that

75
00:03:46,370 --> 00:03:51,530
the code does not regress both in logic

76
00:03:48,590 --> 00:03:53,810
and reliability and and make sure that

77
00:03:51,530 --> 00:03:56,360
the diff is stable security unit tests

78
00:03:53,810 --> 00:03:57,910
here can add some some checks for

79
00:03:56,360 --> 00:04:00,680
security vulnerabilities

80
00:03:57,910 --> 00:04:03,019
when code lands on the repo more

81
00:04:00,680 --> 00:04:05,510
broad-stroke analysis can be done like

82
00:04:03,019 --> 00:04:09,650
checking for CV ease or more advanced

83
00:04:05,510 --> 00:04:11,959
analysis at Build time analysis is run

84
00:04:09,650 --> 00:04:14,420
on the built artifacts like a container

85
00:04:11,959 --> 00:04:15,440
to weed out kind of things and

86
00:04:14,420 --> 00:04:17,238
vulnerabilities that have been

87
00:04:15,440 --> 00:04:19,880
introduced at that time like in secure

88
00:04:17,238 --> 00:04:23,150
configurations or in secure system

89
00:04:19,880 --> 00:04:24,560
libraries or frameworks integration

90
00:04:23,150 --> 00:04:25,380
tests after that gives us another round

91
00:04:24,560 --> 00:04:28,860
of stability

92
00:04:25,380 --> 00:04:30,690
reliability testing and of course at

93
00:04:28,860 --> 00:04:32,760
deploy time we do a final check of

94
00:04:30,690 --> 00:04:34,590
authenticity integrity and security

95
00:04:32,760 --> 00:04:37,680
attestation before we actually deployed

96
00:04:34,590 --> 00:04:40,890
the built release of course this is not

97
00:04:37,680 --> 00:04:42,300
a catch-all for all mistakes right but

98
00:04:40,890 --> 00:04:44,550
at least gives us some level of

99
00:04:42,300 --> 00:04:48,450
assurance that we're catching some known

100
00:04:44,550 --> 00:04:50,550
issues so the idea of code provenance is

101
00:04:48,450 --> 00:04:51,900
to kind of protect us from a number of

102
00:04:50,550 --> 00:04:54,000
different scenarios where both the

103
00:04:51,900 --> 00:04:57,510
malicious and non malicious code it's

104
00:04:54,000 --> 00:05:00,870
kind of shortcutted there shortcutted

105
00:04:57,510 --> 00:05:03,270
through these checks right so first we

106
00:05:00,870 --> 00:05:06,120
we have kind of what we call a lazy or

107
00:05:03,270 --> 00:05:08,190
shortcutting insider and this is someone

108
00:05:06,120 --> 00:05:10,680
who doesn't really they're not really

109
00:05:08,190 --> 00:05:13,790
malicious they mean well right but they

110
00:05:10,680 --> 00:05:17,220
they they kind of want to just get past

111
00:05:13,790 --> 00:05:18,210
past the test pass the reviews past the

112
00:05:17,220 --> 00:05:19,770
lint warned and they don't care about

113
00:05:18,210 --> 00:05:21,390
that stuff right they they just need to

114
00:05:19,770 --> 00:05:22,140
get their code into production as soon

115
00:05:21,390 --> 00:05:26,610
as possible

116
00:05:22,140 --> 00:05:29,130
policies be damned next up we kind of

117
00:05:26,610 --> 00:05:31,710
have a our malicious insider someone who

118
00:05:29,130 --> 00:05:33,690
has engineering access and unlike the

119
00:05:31,710 --> 00:05:37,229
non malicious they this person wants to

120
00:05:33,690 --> 00:05:39,480
do some harm some malicious harm and

121
00:05:37,230 --> 00:05:41,730
they want to sneak code into into

122
00:05:39,480 --> 00:05:43,950
production they may attempt to try to

123
00:05:41,730 --> 00:05:46,680
sneak code and make it look like someone

124
00:05:43,950 --> 00:05:48,870
else has submitted this or they might

125
00:05:46,680 --> 00:05:51,690
just want to get around some review

126
00:05:48,870 --> 00:05:53,070
requirements they they kind of want to

127
00:05:51,690 --> 00:05:57,870
get malicious code into production

128
00:05:53,070 --> 00:06:01,920
without raising any alarms next we have

129
00:05:57,870 --> 00:06:05,880
an outsider who has control of maybe an

130
00:06:01,920 --> 00:06:08,160
engineer's laptop right similar to the

131
00:06:05,880 --> 00:06:10,770
malicious insider they want to use this

132
00:06:08,160 --> 00:06:13,160
access to put a malicious code into

133
00:06:10,770 --> 00:06:15,930
production without raising any alarms

134
00:06:13,160 --> 00:06:18,090
and then finally we have an outsider who

135
00:06:15,930 --> 00:06:23,970
may attempt to directly attack the build

136
00:06:18,090 --> 00:06:25,200
and deploy infrastructure okay so what

137
00:06:23,970 --> 00:06:27,510
about the flipside what do we what are

138
00:06:25,200 --> 00:06:28,890
we actually gaining when we we add code

139
00:06:27,510 --> 00:06:31,620
provenance right what are we enabling

140
00:06:28,890 --> 00:06:33,990
well once all said and done we should

141
00:06:31,620 --> 00:06:35,610
effectively have a verifiable chain of

142
00:06:33,990 --> 00:06:37,129
custody for every bit of code that ends

143
00:06:35,610 --> 00:06:39,659
up in production

144
00:06:37,129 --> 00:06:40,979
ideally we can sample any sample of

145
00:06:39,659 --> 00:06:42,839
running code and know that it came from

146
00:06:40,979 --> 00:06:44,969
a specific authorized build and that

147
00:06:42,839 --> 00:06:47,099
authorized build was constructed from a

148
00:06:44,969 --> 00:06:49,469
specific set of commits each of which

149
00:06:47,099 --> 00:06:52,079
has a known and verifiable author each

150
00:06:49,469 --> 00:06:53,998
of whom is an engineer with a correct

151
00:06:52,079 --> 00:06:57,269
level of access to actually make that

152
00:06:53,999 --> 00:06:59,189
change and in the event that some code

153
00:06:57,269 --> 00:07:00,509
or you know malicious or anomalous code

154
00:06:59,189 --> 00:07:02,249
does end up in production

155
00:07:00,509 --> 00:07:04,349
our security response team should be

156
00:07:02,249 --> 00:07:06,539
able to trust the bread crumbs the

157
00:07:04,349 --> 00:07:08,279
metadata that we put in place in order

158
00:07:06,539 --> 00:07:11,248
to kind of learn what happened kind of

159
00:07:08,279 --> 00:07:13,079
figure out that story along the way in

160
00:07:11,249 --> 00:07:15,149
addition to all that we should be able

161
00:07:13,079 --> 00:07:16,949
to be assured that nothing made it

162
00:07:15,149 --> 00:07:19,199
through our entire software development

163
00:07:16,949 --> 00:07:21,029
process without without verifiably

164
00:07:19,199 --> 00:07:23,159
passing any of the checks that we've put

165
00:07:21,029 --> 00:07:25,259
in place along the way for example if we

166
00:07:23,159 --> 00:07:27,360
had a blacklist of third-party

167
00:07:25,259 --> 00:07:29,399
dependencies that we did not want in

168
00:07:27,360 --> 00:07:32,519
production no developer and engineers

169
00:07:29,399 --> 00:07:34,649
should should be able to add that in you

170
00:07:32,519 --> 00:07:37,549
know they should not be able to get that

171
00:07:34,649 --> 00:07:37,549
all the way into production

172
00:07:39,139 --> 00:07:44,729
so a quick a quick disclaimer though

173
00:07:43,079 --> 00:07:46,050
before we actually move forward into

174
00:07:44,729 --> 00:07:48,058
defining some of the things that we've

175
00:07:46,050 --> 00:07:50,610
done this this journey is not complete

176
00:07:48,059 --> 00:07:54,119
and although we have we have a roadmap

177
00:07:50,610 --> 00:07:55,739
we have a overall vision on this there

178
00:07:54,119 --> 00:07:58,379
there's definitely work to be done so

179
00:07:55,739 --> 00:08:01,709
we're we're getting to it or better yet

180
00:07:58,379 --> 00:08:03,719
come help us build this all out with

181
00:08:01,709 --> 00:08:07,439
that I'm gonna pass it on to you Matt

182
00:08:03,719 --> 00:08:09,058
okay so everyone in the room probably

183
00:08:07,439 --> 00:08:10,499
has a sense of what software development

184
00:08:09,059 --> 00:08:12,749
works what the software development

185
00:08:10,499 --> 00:08:14,399
process the process is but I want to go

186
00:08:12,749 --> 00:08:15,419
into some of the details here for what

187
00:08:14,399 --> 00:08:18,539
this looks like at it movers

188
00:08:15,419 --> 00:08:20,489
specifically so if we start with just

189
00:08:18,539 --> 00:08:23,369
one product for now thinking about for

190
00:08:20,489 --> 00:08:25,229
example the uber iOS rider app which is

191
00:08:23,369 --> 00:08:27,389
probably the app that most of us are

192
00:08:25,229 --> 00:08:28,498
familiar with in the room we go through

193
00:08:27,389 --> 00:08:31,169
what looks like a fairly standard

194
00:08:28,499 --> 00:08:33,779
development workflow you go ahead and

195
00:08:31,169 --> 00:08:35,338
write some code you test it locally you

196
00:08:33,779 --> 00:08:38,029
get your code review you make sure it

197
00:08:35,339 --> 00:08:38,029
passes NCI

198
00:08:38,539 --> 00:08:42,588
this eventually triggers a build of a

199
00:08:40,490 --> 00:08:45,019
release candidate that will include the

200
00:08:42,589 --> 00:08:48,050
new code and then this will undergo some

201
00:08:45,019 --> 00:08:49,970
integration testing and dogfooding this

202
00:08:48,050 --> 00:08:52,160
ultimately ends up in an app that gets

203
00:08:49,970 --> 00:08:54,529
released in the App Store so bringing us

204
00:08:52,160 --> 00:08:56,089
back to what Tony just talked about what

205
00:08:54,529 --> 00:08:58,069
we want to do here is increase our

206
00:08:56,089 --> 00:09:00,110
assurance that the code that lands in

207
00:08:58,069 --> 00:09:01,490
this production release is in fact the

208
00:09:00,110 --> 00:09:03,589
code that was supposed to have landed

209
00:09:01,490 --> 00:09:05,839
here and that we have all this metadata

210
00:09:03,589 --> 00:09:08,600
along the way so we can understand what

211
00:09:05,839 --> 00:09:10,819
happening and any policies have been met

212
00:09:08,600 --> 00:09:15,050
along this process so all fairly

213
00:09:10,819 --> 00:09:17,389
straightforward so far but that's just

214
00:09:15,050 --> 00:09:19,609
one out right so that's our ios app

215
00:09:17,389 --> 00:09:22,670
turns out we also have an android app

216
00:09:19,610 --> 00:09:24,889
and so this same diagram it's fairly

217
00:09:22,670 --> 00:09:27,620
similar write your code get it reviewed

218
00:09:24,889 --> 00:09:29,360
etc but now writing the code in a

219
00:09:27,620 --> 00:09:30,920
different language we're doing code

220
00:09:29,360 --> 00:09:33,230
review with slightly different policies

221
00:09:30,920 --> 00:09:36,170
we have CI testing and slightly

222
00:09:33,230 --> 00:09:37,759
different CI infrastructure the release

223
00:09:36,170 --> 00:09:40,040
gets built through a distinct process

224
00:09:37,759 --> 00:09:41,779
and on and on and on right this is

225
00:09:40,040 --> 00:09:43,910
actually a separate process that was

226
00:09:41,779 --> 00:09:48,410
thrown up independently of the first one

227
00:09:43,910 --> 00:09:49,939
that I talked about still may be fairly

228
00:09:48,410 --> 00:09:53,269
straightforward but now that's just two

229
00:09:49,939 --> 00:09:55,129
of the apps right we also have many web

230
00:09:53,269 --> 00:09:57,699
services so one of these is the uber web

231
00:09:55,129 --> 00:09:59,839
service with its own distinct process

232
00:09:57,699 --> 00:10:01,729
slightly different tool a different

233
00:09:59,839 --> 00:10:09,019
language different team that owns this

234
00:10:01,730 --> 00:10:10,670
process and this kind of goes on and on

235
00:10:09,019 --> 00:10:11,809
and on we have all these different

236
00:10:10,670 --> 00:10:14,149
processes for all these different

237
00:10:11,809 --> 00:10:15,379
applications and services all of which

238
00:10:14,149 --> 00:10:17,120
in many cases have grown up

239
00:10:15,379 --> 00:10:20,120
independently from each other and are

240
00:10:17,120 --> 00:10:21,620
managed by different teams many many

241
00:10:20,120 --> 00:10:24,170
times over so the key word here is

242
00:10:21,620 --> 00:10:26,240
heterogeneity right we have all these

243
00:10:24,170 --> 00:10:28,610
different applications with all this

244
00:10:26,240 --> 00:10:32,420
different tooling and so I like to think

245
00:10:28,610 --> 00:10:34,410
of these as special snowflakes

246
00:10:32,420 --> 00:10:38,490
different processes different teams

247
00:10:34,410 --> 00:10:39,600
different norms and so if you start with

248
00:10:38,490 --> 00:10:42,720
just thinking about one of these

249
00:10:39,600 --> 00:10:44,760
services let's say it's the uber iOS app

250
00:10:42,720 --> 00:10:46,350
the one I mentioned at first and we

251
00:10:44,760 --> 00:10:46,950
start to try to think about what this

252
00:10:46,350 --> 00:10:50,430
looks like

253
00:10:46,950 --> 00:10:53,310
holistically go ahead and take the iOS

254
00:10:50,430 --> 00:10:55,199
out now multiply by 32 because we

255
00:10:53,310 --> 00:10:57,869
actually have thirty two distinct iOS

256
00:10:55,200 --> 00:11:00,330
apps go ahead and double it because we

257
00:10:57,870 --> 00:11:02,310
have just as many Android apps now go

258
00:11:00,330 --> 00:11:04,500
ahead and add all the back-end services

259
00:11:02,310 --> 00:11:06,449
and we quickly run out of space on the

260
00:11:04,500 --> 00:11:09,090
slide and so when we take a step back

261
00:11:06,450 --> 00:11:11,190
and zoom out this is what you get this

262
00:11:09,090 --> 00:11:13,650
is this is the software that makes up

263
00:11:11,190 --> 00:11:16,430
the uber machine something like 64

264
00:11:13,650 --> 00:11:19,319
mobile apps and four thousand services

265
00:11:16,430 --> 00:11:21,689
well so what what's what's the point of

266
00:11:19,320 --> 00:11:24,120
all of this right the idea here is that

267
00:11:21,690 --> 00:11:26,340
we need to be really thoughtful about

268
00:11:24,120 --> 00:11:27,810
how we can do something general enough

269
00:11:26,340 --> 00:11:29,850
that will work for all of these

270
00:11:27,810 --> 00:11:30,900
different special snowflakes all these

271
00:11:29,850 --> 00:11:33,000
different applications all these

272
00:11:30,900 --> 00:11:35,010
different teams we had we have to find

273
00:11:33,000 --> 00:11:36,180
some point of commonality or some choke

274
00:11:35,010 --> 00:11:37,890
point something that these have in

275
00:11:36,180 --> 00:11:40,140
common so that we can create these

276
00:11:37,890 --> 00:11:41,460
general solution for code provenance and

277
00:11:40,140 --> 00:11:43,199
we have to do so in a way that's

278
00:11:41,460 --> 00:11:45,330
thoughtful enough that we don't break

279
00:11:43,200 --> 00:11:47,640
production systems or upset too many of

280
00:11:45,330 --> 00:11:49,980
our engineers and so in our experience

281
00:11:47,640 --> 00:11:52,500
off-the-shelf solutions generally don't

282
00:11:49,980 --> 00:11:54,360
work any solution that starts with well

283
00:11:52,500 --> 00:11:58,500
why don't you just has been a

284
00:11:54,360 --> 00:11:59,850
non-starter in our experience so I'll

285
00:11:58,500 --> 00:12:01,590
attempt to drive this point home a

286
00:11:59,850 --> 00:12:05,130
little bit with a concrete example of

287
00:12:01,590 --> 00:12:07,020
commit signing so many of you may know

288
00:12:05,130 --> 00:12:09,540
already that git has built-in support

289
00:12:07,020 --> 00:12:13,710
for signing or commits and the way this

290
00:12:09,540 --> 00:12:16,020
works is that it uses GPG keys now in

291
00:12:13,710 --> 00:12:17,550
our infrastructure our developers have a

292
00:12:16,020 --> 00:12:19,650
different set of keys they don't have

293
00:12:17,550 --> 00:12:21,209
GPT keys they have short-lived as the

294
00:12:19,650 --> 00:12:22,829
same certificates and all of the

295
00:12:21,210 --> 00:12:24,630
infrastructure that goes along with that

296
00:12:22,830 --> 00:12:26,339
so these are great because they're

297
00:12:24,630 --> 00:12:28,949
actually renewed

298
00:12:26,339 --> 00:12:30,420
every 24 hours using multi-factor

299
00:12:28,949 --> 00:12:32,459
authentication so we have sort of this

300
00:12:30,420 --> 00:12:34,110
better infrastructure around key

301
00:12:32,459 --> 00:12:36,209
management for all of our developers and

302
00:12:34,110 --> 00:12:38,699
it's already rolled out so we're stuck

303
00:12:36,209 --> 00:12:40,829
with this interesting choice of re

304
00:12:38,699 --> 00:12:43,349
solving the key distribution problem for

305
00:12:40,829 --> 00:12:44,998
a new set of keys that I would argue is

306
00:12:43,350 --> 00:12:49,050
actually worse than the set of keys our

307
00:12:44,999 --> 00:12:50,999
developers already have or and in that

308
00:12:49,050 --> 00:12:53,910
case using the built in commit signing

309
00:12:50,999 --> 00:12:55,379
that they get provides or using this

310
00:12:53,910 --> 00:12:57,870
better set of keys that we have and

311
00:12:55,379 --> 00:13:01,410
implementing our own custom designing

312
00:12:57,870 --> 00:13:04,439
solution so as you may guess we opted

313
00:13:01,410 --> 00:13:06,449
for the latter the commonality that we

314
00:13:04,439 --> 00:13:08,730
use in this case that I mentioned before

315
00:13:06,449 --> 00:13:10,109
is that we have that all of our

316
00:13:08,730 --> 00:13:11,910
developers have this verifiable

317
00:13:10,110 --> 00:13:14,459
cryptographic identity via these SSH

318
00:13:11,910 --> 00:13:16,019
certificates and fortunately all of our

319
00:13:14,459 --> 00:13:17,849
repositories use git so we take

320
00:13:16,019 --> 00:13:20,279
advantage of these two things in common

321
00:13:17,850 --> 00:13:22,439
to build a base for all these special

322
00:13:20,279 --> 00:13:23,610
snowflakes for all these developers to

323
00:13:22,439 --> 00:13:26,819
sign their commits across these

324
00:13:23,610 --> 00:13:28,170
different repositories but I'd like to

325
00:13:26,819 --> 00:13:30,449
take a step back before I take a couple

326
00:13:28,170 --> 00:13:32,660
steps forward so why are we even signing

327
00:13:30,449 --> 00:13:37,620
commits what is this all about

328
00:13:32,660 --> 00:13:39,959
so commits are just meta data sorry

329
00:13:37,620 --> 00:13:41,879
commit identity is just metadata that

330
00:13:39,959 --> 00:13:43,709
exists inside the commit so you have

331
00:13:41,879 --> 00:13:45,629
this author field and inside your commit

332
00:13:43,709 --> 00:13:47,579
and that says who authored the commit

333
00:13:45,629 --> 00:13:49,800
but how does this Association actually

334
00:13:47,579 --> 00:13:51,300
happen well it's just a configuration

335
00:13:49,800 --> 00:13:53,099
setting you can send a different name

336
00:13:51,300 --> 00:13:55,050
into your commit message or into your

337
00:13:53,100 --> 00:13:57,269
gate configuration and so it's actually

338
00:13:55,050 --> 00:13:59,729
fairly easy to create a commit that says

339
00:13:57,269 --> 00:14:05,800
it was created by someone else and so

340
00:13:59,730 --> 00:14:08,139
thinking back this is not

341
00:14:05,800 --> 00:14:15,849
what we need is metadata that is tied

342
00:14:08,139 --> 00:14:17,829
back to some cryptographic identity so

343
00:14:15,850 --> 00:14:20,499
how do we actually go ahead my segments

344
00:14:17,829 --> 00:14:22,799
we have this fork in the road you can do

345
00:14:20,499 --> 00:14:25,600
this in there at the server side where

346
00:14:22,799 --> 00:14:27,730
developers push the developers

347
00:14:25,600 --> 00:14:30,579
authenticate to the git server push the

348
00:14:27,730 --> 00:14:33,519
commits and the git server ban knows who

349
00:14:30,579 --> 00:14:35,920
authenticated SSH and writes out some

350
00:14:33,519 --> 00:14:37,869
that add a bit I did that or we can do

351
00:14:35,920 --> 00:14:39,959
this via the client-side use those

352
00:14:37,869 --> 00:14:42,579
necessary typical that I mentioned and

353
00:14:39,959 --> 00:14:43,988
developers create commit signatures sort

354
00:14:42,579 --> 00:14:46,378
of a long side of the commits they

355
00:14:43,989 --> 00:14:48,429
create and then go ahead and store these

356
00:14:46,379 --> 00:14:50,439
so these are two very different paths

357
00:14:48,429 --> 00:14:52,629
with different challenges and that

358
00:14:50,439 --> 00:14:55,029
effect a different set of systems in our

359
00:14:52,629 --> 00:14:57,009
case on balance we decided that it'd be

360
00:14:55,029 --> 00:14:59,920
easier to do this on the client side and

361
00:14:57,009 --> 00:15:01,809
it also is more parallel to the sort of

362
00:14:59,920 --> 00:15:02,290
native commit signing that git has that

363
00:15:01,809 --> 00:15:03,899
I mentioned earlier

364
00:15:02,290 --> 00:15:08,769
[Music]

365
00:15:03,899 --> 00:15:10,869
so our high-level approach is to use git

366
00:15:08,769 --> 00:15:14,290
hooks pre-committed than post-it notes

367
00:15:10,869 --> 00:15:16,269
to actually do the signatures and then

368
00:15:14,290 --> 00:15:19,509
to store the signatures in this feature

369
00:15:16,269 --> 00:15:21,850
that get provides cog get notes and get

370
00:15:19,509 --> 00:15:24,069
notes are this functionality for storing

371
00:15:21,850 --> 00:15:26,559
metadata about commits but outside of

372
00:15:24,069 --> 00:15:28,209
the commitments off so we create the

373
00:15:26,559 --> 00:15:30,579
signatures when developers create their

374
00:15:28,209 --> 00:15:33,489
commits we store these signature store

375
00:15:30,579 --> 00:15:35,709
the signatures in yet notes and then we

376
00:15:33,490 --> 00:15:39,339
have yet another committee look sorry

377
00:15:35,709 --> 00:15:42,758
push book that will push the signatures

378
00:15:39,339 --> 00:15:45,999
alongside alongside the actual units and

379
00:15:42,759 --> 00:15:47,679
then to top this off we distribute this

380
00:15:45,999 --> 00:15:50,319
configuration to tell it to use the

381
00:15:47,679 --> 00:15:54,429
books and the books themselves with chef

382
00:15:50,319 --> 00:15:55,748
to all our developer and price fairly

383
00:15:54,429 --> 00:15:58,379
straightforward right what could

384
00:15:55,749 --> 00:15:58,379
possibly go wrong

385
00:15:59,100 --> 00:16:05,860
special snowflakes of course so we ran

386
00:16:02,680 --> 00:16:09,790
into conflicting gimmicks for a vast

387
00:16:05,860 --> 00:16:12,250
minority of repositories the most common

388
00:16:09,790 --> 00:16:15,339
example we saw here was repositories

389
00:16:12,250 --> 00:16:16,990
that use client-side commit vote to

390
00:16:15,339 --> 00:16:19,330
format commit messages in a very

391
00:16:16,990 --> 00:16:21,070
specific way so that they all contained

392
00:16:19,330 --> 00:16:24,190
sort of the same set of metadata and

393
00:16:21,070 --> 00:16:25,450
they all look the same before so

394
00:16:24,190 --> 00:16:28,209
initially our thought was look at any

395
00:16:25,450 --> 00:16:30,700
well this should be no problem yet

396
00:16:28,209 --> 00:16:33,040
surely provide some mechanism for us to

397
00:16:30,700 --> 00:16:34,959
run multiple hooks and to say which

398
00:16:33,040 --> 00:16:37,689
repositories they should run on and in

399
00:16:34,959 --> 00:16:40,149
what order this turned out not to be the

400
00:16:37,690 --> 00:16:43,930
case so this was some sub problem that

401
00:16:40,149 --> 00:16:45,490
we had to go solve and we did so by

402
00:16:43,930 --> 00:16:48,849
developing what we call a get hooks

403
00:16:45,490 --> 00:16:50,230
middleware so again this was a something

404
00:16:48,850 --> 00:16:54,070
that the distributor influenced be a

405
00:16:50,230 --> 00:16:57,160
chef and it manages a set of distinct

406
00:16:54,070 --> 00:16:59,770
get hooks it it uses configuration

407
00:16:57,160 --> 00:17:01,350
options to say which hooks run on which

408
00:16:59,770 --> 00:17:03,610
repositories so we have our global

409
00:17:01,350 --> 00:17:05,679
commit signing hook that runs on all

410
00:17:03,610 --> 00:17:07,209
repositories and then we have these

411
00:17:05,679 --> 00:17:11,770
special snowflakes that get to run their

412
00:17:07,209 --> 00:17:13,329
hooks just for their remix okay so at

413
00:17:11,770 --> 00:17:16,270
this point we've we've rolled our

414
00:17:13,329 --> 00:17:18,188
commits I know solution D conflicted the

415
00:17:16,270 --> 00:17:20,800
hooks with the existing hooks that we

416
00:17:18,189 --> 00:17:22,449
found along the way all these hooks are

417
00:17:20,800 --> 00:17:24,819
centrally managed no doubt to our

418
00:17:22,449 --> 00:17:26,259
developers they run

419
00:17:24,819 --> 00:17:29,590
five order on the correct set of

420
00:17:26,259 --> 00:17:32,620
repositories so we're done right what

421
00:17:29,590 --> 00:17:33,600
else could possibly be especially

422
00:17:32,620 --> 00:17:36,158
snowflakes

423
00:17:33,600 --> 00:17:38,439
so we discovered amongst the thousands

424
00:17:36,159 --> 00:17:41,230
of repositories a single server-side

425
00:17:38,440 --> 00:17:42,820
book in one repository that caused

426
00:17:41,230 --> 00:17:45,549
problems for us and so this was doing a

427
00:17:42,820 --> 00:17:47,309
very specific thing it was a hook on the

428
00:17:45,549 --> 00:17:50,200
server side that was checking a

429
00:17:47,309 --> 00:17:52,059
configuration file to make sure it was

430
00:17:50,200 --> 00:17:55,809
in the right format for every single

431
00:17:52,059 --> 00:17:58,178
branch push to the push and so with this

432
00:17:55,809 --> 00:18:01,269
met in our case based on how get notes

433
00:17:58,179 --> 00:18:04,210
actually work is that when our notes

434
00:18:01,269 --> 00:18:05,679
graph was pushed to origin this looked

435
00:18:04,210 --> 00:18:08,740
to that hook just like another branch

436
00:18:05,679 --> 00:18:10,419
and so look at our get notes containing

437
00:18:08,740 --> 00:18:12,789
all our signatures that would of course

438
00:18:10,419 --> 00:18:15,429
not find this configuration file at all

439
00:18:12,789 --> 00:18:18,700
because this is not the code repository

440
00:18:15,429 --> 00:18:20,500
in this case and it would fail every

441
00:18:18,700 --> 00:18:23,590
single push of signatures which in turn

442
00:18:20,500 --> 00:18:25,179
would fail every code bush so this was

443
00:18:23,590 --> 00:18:27,549
an interesting case because the bug was

444
00:18:25,179 --> 00:18:29,440
actually in the server side hook but the

445
00:18:27,549 --> 00:18:31,120
bug didn't manifest until we use this

446
00:18:29,440 --> 00:18:34,539
get notes feature that we decided to do

447
00:18:31,120 --> 00:18:36,570
this so what's the takeaway from all

448
00:18:34,539 --> 00:18:39,730
this we learned a bunch of lessons here

449
00:18:36,570 --> 00:18:40,520
the first one is that nothing is

450
00:18:39,730 --> 00:18:42,800
initially

451
00:18:40,520 --> 00:18:44,690
seems we sort of realized that we can't

452
00:18:42,800 --> 00:18:49,250
necessarily predict in advance all of

453
00:18:44,690 --> 00:18:50,059
the things in such a heavy genius

454
00:18:49,250 --> 00:18:53,240
american tartars

455
00:18:50,059 --> 00:18:55,879
and so the thing that works for 90% of

456
00:18:53,240 --> 00:18:58,010
some cases 99% of your developers and

457
00:18:55,880 --> 00:19:02,630
repositories will sort of catastrophic

458
00:18:58,010 --> 00:19:04,040
rate and so because we knew that we

459
00:19:02,630 --> 00:19:06,020
couldn't predict everything in advance

460
00:19:04,040 --> 00:19:08,300
we knew we had to have a plan and so

461
00:19:06,020 --> 00:19:11,210
this plan was sort of threefold the

462
00:19:08,300 --> 00:19:13,669
first one is making sure we have the

463
00:19:11,210 --> 00:19:22,250
ability to deploy infinitely so that we

464
00:19:13,670 --> 00:19:24,320
could roll out to just a test cohort and

465
00:19:22,250 --> 00:19:25,820
the great thing about this is that lets

466
00:19:24,320 --> 00:19:29,450
us discover these problems what I

467
00:19:25,820 --> 00:19:31,370
mentioned previously but in such a way

468
00:19:29,450 --> 00:19:33,770
that we don't break everything for

469
00:19:31,370 --> 00:19:35,479
everyone at once and we don't take on

470
00:19:33,770 --> 00:19:39,410
the support we wouldn't have to fix

471
00:19:35,480 --> 00:19:40,910
everything and so related to this is the

472
00:19:39,410 --> 00:19:44,120
idea of just being I need to turn

473
00:19:40,910 --> 00:19:46,220
everything off so we had this built in

474
00:19:44,120 --> 00:19:49,399
to be able to just shut this off he's

475
00:19:46,220 --> 00:19:51,890
WDS job for when we discover these

476
00:19:49,400 --> 00:19:53,900
problems we could sort of take our time

477
00:19:51,890 --> 00:19:58,790
a little bit to address these problems

478
00:19:53,900 --> 00:20:01,580
and then turn back and if I made the

479
00:19:58,790 --> 00:20:05,359
third prong is

480
00:20:01,580 --> 00:20:05,359
[Music]

481
00:20:10,850 --> 00:21:20,799
[Music]

482
00:20:16,720 --> 00:21:24,080
so thank you myself

483
00:21:20,799 --> 00:21:26,480
so a lot of the code that we run it

484
00:21:24,080 --> 00:21:29,360
uber is open-source third-party software

485
00:21:26,480 --> 00:21:31,039
right and this ends up being a majority

486
00:21:29,360 --> 00:21:34,820
of the software that runs in our

487
00:21:31,039 --> 00:21:37,129
production systems given that it should

488
00:21:34,820 --> 00:21:39,230
amount to us putting at least the same

489
00:21:37,130 --> 00:21:40,789
level of security stringent series when

490
00:21:39,230 --> 00:21:43,610
it comes to using these third-party

491
00:21:40,789 --> 00:21:46,879
libraries right but unfortunately that

492
00:21:43,610 --> 00:21:48,379
is not the case and usually we can panel

493
00:21:46,880 --> 00:21:53,630
third-party dependencies with

494
00:21:48,380 --> 00:21:56,240
essentially little to no oversight so

495
00:21:53,630 --> 00:21:58,909
what exactly is the risk from these

496
00:21:56,240 --> 00:22:01,399
third-party libraries right third-party

497
00:21:58,909 --> 00:22:05,120
software can pull in malicious or

498
00:22:01,399 --> 00:22:08,149
vulnerable code and these are some of

499
00:22:05,120 --> 00:22:11,840
the examples that we have seen in the

500
00:22:08,149 --> 00:22:14,239
recent past and the part of this problem

501
00:22:11,840 --> 00:22:16,189
is also actually understanding where

502
00:22:14,240 --> 00:22:18,110
this third-party software is coming from

503
00:22:16,190 --> 00:22:20,630
is it really coming from the

504
00:22:18,110 --> 00:22:23,689
trusted registry that we think it is and

505
00:22:20,630 --> 00:22:29,510
this essentially leads to the problem of

506
00:22:23,690 --> 00:22:31,549
having a verifiable attestation so in

507
00:22:29,510 --> 00:22:33,679
order for us to understand how we can

508
00:22:31,549 --> 00:22:36,289
secure these dependencies we need to

509
00:22:33,679 --> 00:22:38,559
bring the problem through two parts so

510
00:22:36,289 --> 00:22:41,000
the future facing efforts would be

511
00:22:38,559 --> 00:22:42,980
essentially covering whatever

512
00:22:41,000 --> 00:22:45,409
dependencies will be introduced in our

513
00:22:42,980 --> 00:22:48,260
infrastructure from year or now and then

514
00:22:45,409 --> 00:22:49,880
the existing world would tackle all the

515
00:22:48,260 --> 00:22:52,940
dependencies that we already have

516
00:22:49,880 --> 00:22:55,909
running in our infrastructure so if the

517
00:22:52,940 --> 00:22:58,370
future phasing scenario or newly

518
00:22:55,909 --> 00:23:01,039
introduced dependencies from global

519
00:22:58,370 --> 00:23:04,370
context will undergo a lightweight

520
00:23:01,039 --> 00:23:06,169
vetting process we'll have some policy

521
00:23:04,370 --> 00:23:08,928
backing this which would cover things

522
00:23:06,169 --> 00:23:11,210
like high plus CV ease maybe some

523
00:23:08,929 --> 00:23:15,649
package blacklist some licensing

524
00:23:11,210 --> 00:23:17,779
constraints and so on then for all newly

525
00:23:15,649 --> 00:23:20,449
introduced third-party libraries from

526
00:23:17,779 --> 00:23:23,539
the repo local context we'd want to

527
00:23:20,450 --> 00:23:27,380
start assigning internal Dolan's why is

528
00:23:23,539 --> 00:23:29,029
that this whenever we actually encounter

529
00:23:27,380 --> 00:23:32,419
a known vulnerability and this would

530
00:23:29,029 --> 00:23:37,130
help us with our remediation process so

531
00:23:32,419 --> 00:23:42,529
now let's get a little bit into how we

532
00:23:37,130 --> 00:23:45,710
can implement something like this so in

533
00:23:42,529 --> 00:23:49,519
our system we have developed some pull

534
00:23:45,710 --> 00:23:51,529
request type hooks what do they do when

535
00:23:49,519 --> 00:23:53,450
whenever there's actually a change in

536
00:23:51,529 --> 00:23:55,730
the requirements manifest file which

537
00:23:53,450 --> 00:23:57,070
ultimately becomes okay so someone is

538
00:23:55,730 --> 00:24:00,590
trying to introduce a new dependency

539
00:23:57,070 --> 00:24:02,450
we'd want to find out if this dependency

540
00:24:00,590 --> 00:24:06,740
has already been introduced at over

541
00:24:02,450 --> 00:24:10,010
before so we have a little inventory

542
00:24:06,740 --> 00:24:12,559
system that tells us okay if this is a

543
00:24:10,010 --> 00:24:15,879
new dependency from the global context

544
00:24:12,559 --> 00:24:18,799
let's kick off a new vetting process

545
00:24:15,880 --> 00:24:20,779
alternatively if this is a new

546
00:24:18,799 --> 00:24:23,750
dependency from the repo local

547
00:24:20,779 --> 00:24:26,029
perspective the pull request or third

548
00:24:23,750 --> 00:24:28,730
essentially becomes the owner of that

549
00:24:26,029 --> 00:24:31,520
dependency for that repository

550
00:24:28,730 --> 00:24:35,780
and now we also make a note of it in our

551
00:24:31,520 --> 00:24:38,030
inventory system with this all four new

552
00:24:35,780 --> 00:24:41,389
third-party dependencies are somewhat

553
00:24:38,030 --> 00:24:44,590
accounted for and we also have a level

554
00:24:41,390 --> 00:24:44,590
of verifiable attestation

555
00:24:49,970 --> 00:24:56,539
okay so how can we for our existing

556
00:24:53,659 --> 00:24:59,149
dependencies we have two approaches that

557
00:24:56,539 --> 00:25:03,230
we can are taken one is the process of

558
00:24:59,149 --> 00:25:05,449
green keeping so we try to keep all of

559
00:25:03,230 --> 00:25:06,590
our dependencies updated to the latest

560
00:25:05,450 --> 00:25:08,659
versions at all times

561
00:25:06,590 --> 00:25:11,600
but there's a slight problem with this

562
00:25:08,659 --> 00:25:14,149
as matt had mentioned we have 4000 micro

563
00:25:11,600 --> 00:25:17,539
services and thousands of dependencies

564
00:25:14,149 --> 00:25:20,479
and it really doesn't at this at this

565
00:25:17,539 --> 00:25:23,980
size we can't scale our team to keep all

566
00:25:20,480 --> 00:25:26,629
of these dependencies updated reliably

567
00:25:23,980 --> 00:25:28,580
alternatively we can also make targeted

568
00:25:26,629 --> 00:25:31,250
library updates so whenever we encounter

569
00:25:28,580 --> 00:25:33,590
a known vulnerability forward that to

570
00:25:31,250 --> 00:25:35,240
the product engineering team and then

571
00:25:33,590 --> 00:25:37,610
have them be responsible for updating

572
00:25:35,240 --> 00:25:40,309
the library version and there are also

573
00:25:37,610 --> 00:25:41,959
some vendor companies that are working

574
00:25:40,309 --> 00:25:46,750
on this problem space

575
00:25:41,960 --> 00:25:49,309
so with this it seems fairly easy right

576
00:25:46,750 --> 00:25:51,950
but to understand this a little further

577
00:25:49,309 --> 00:25:54,158
we need to look at the composite of our

578
00:25:51,950 --> 00:25:57,080
composition of a package service a

579
00:25:54,159 --> 00:25:59,000
back-end service usually takes a direct

580
00:25:57,080 --> 00:26:03,168
dependency on multiple third-party

581
00:25:59,000 --> 00:26:06,230
libraries these libraries then pull in

582
00:26:03,169 --> 00:26:11,000
multiple other dependencies and this

583
00:26:06,230 --> 00:26:12,919
keeps going on and on so what if we find

584
00:26:11,000 --> 00:26:17,299
a known vulnerability in one of these

585
00:26:12,919 --> 00:26:19,279
third-party packages this in turn would

586
00:26:17,299 --> 00:26:21,889
taint whichever dependency was

587
00:26:19,279 --> 00:26:28,370
responsible for pulling it in and this

588
00:26:21,889 --> 00:26:30,799
keeps going up the trail so okay we have

589
00:26:28,370 --> 00:26:34,908
found a potentially vulnerable library

590
00:26:30,799 --> 00:26:37,340
now but a vulnerability in a third party

591
00:26:34,909 --> 00:26:39,580
package does not necessarily manifest

592
00:26:37,340 --> 00:26:43,220
itself as an exploitable vulnerability

593
00:26:39,580 --> 00:26:46,399
let me give you a little example so if

594
00:26:43,220 --> 00:26:49,220
we have a URL parsing vulnerability in

595
00:26:46,399 --> 00:26:52,309
some package but if the first party code

596
00:26:49,220 --> 00:26:55,210
is passing that vulnerable library of

597
00:26:52,309 --> 00:26:57,740
static URL this does not necessarily

598
00:26:55,210 --> 00:26:58,690
manifest itself as an exploitable

599
00:26:57,740 --> 00:27:02,770
vulnerability

600
00:26:58,690 --> 00:27:05,290
takes back to the world right and given

601
00:27:02,770 --> 00:27:07,150
our scale we can't just forward all

602
00:27:05,290 --> 00:27:09,730
these hundreds or thousands of issues to

603
00:27:07,150 --> 00:27:14,050
the product engineering teams and wish

604
00:27:09,730 --> 00:27:18,040
them back so a good question to ask here

605
00:27:14,050 --> 00:27:21,580
is is user input actually ever touching

606
00:27:18,040 --> 00:27:25,030
a vulnerable library so in the instance

607
00:27:21,580 --> 00:27:26,189
to your right you'll see that user input

608
00:27:25,030 --> 00:27:29,050
touches of potentially vulnerable

609
00:27:26,190 --> 00:27:31,690
library but that does not end up hitting

610
00:27:29,050 --> 00:27:34,180
an actually vulnerable library but in

611
00:27:31,690 --> 00:27:38,260
the case to your left we'll see that it

612
00:27:34,180 --> 00:27:40,980
actually does so it's clearly not very

613
00:27:38,260 --> 00:27:44,020
straightforward

614
00:27:40,980 --> 00:27:45,940
till now we have established that we

615
00:27:44,020 --> 00:27:47,950
have back-end services that have direct

616
00:27:45,940 --> 00:27:50,980
dependencies which have indirect

617
00:27:47,950 --> 00:27:53,710
dependencies some user input will just

618
00:27:50,980 --> 00:27:56,350
touch the first party code some of it

619
00:27:53,710 --> 00:27:59,560
hits a direct dependency and some of it

620
00:27:56,350 --> 00:28:02,050
hits an indirect dependency but the real

621
00:27:59,560 --> 00:28:04,659
question we need to ask your is what the

622
00:28:02,050 --> 00:28:08,590
vulnerable function is and whether user

623
00:28:04,660 --> 00:28:11,470
input is actually ever touching it so

624
00:28:08,590 --> 00:28:13,689
there are some vendor companies working

625
00:28:11,470 --> 00:28:16,300
in this problem space right now they

626
00:28:13,690 --> 00:28:19,090
call it advanced analysis which

627
00:28:16,300 --> 00:28:21,250
ultimately is a combination of two

628
00:28:19,090 --> 00:28:23,260
things so from the static analysis

629
00:28:21,250 --> 00:28:25,030
perspective it's using control and data

630
00:28:23,260 --> 00:28:26,920
flow graphs to figure out whether avala

631
00:28:25,030 --> 00:28:30,160
a vulnerable function is ever being

632
00:28:26,920 --> 00:28:31,930
called and from the dynamic analysis

633
00:28:30,160 --> 00:28:34,180
perspective they have some code

634
00:28:31,930 --> 00:28:35,740
instrumentation to also figure out when

635
00:28:34,180 --> 00:28:39,340
a vulnerable function is actually being

636
00:28:35,740 --> 00:28:42,340
called at runtime but unfortunately none

637
00:28:39,340 --> 00:28:45,280
of these solutions band out in our

638
00:28:42,340 --> 00:28:51,100
environment for multiple reasons so we

639
00:28:45,280 --> 00:28:53,110
had to come up with our own what when

640
00:28:51,100 --> 00:28:54,340
you have a vulnerability the thing we

641
00:28:53,110 --> 00:28:57,070
usually care about is the severity

642
00:28:54,340 --> 00:28:59,889
associated with it right and severity is

643
00:28:57,070 --> 00:29:02,200
the product of risk likelihood an impact

644
00:28:59,890 --> 00:29:03,910
and in our environment we can make

645
00:29:02,200 --> 00:29:05,950
justified arguments about risk and

646
00:29:03,910 --> 00:29:08,170
likelihood but impact is something we

647
00:29:05,950 --> 00:29:09,320
start to struggle with what exactly is

648
00:29:08,170 --> 00:29:11,149
the vulnerable function

649
00:29:09,320 --> 00:29:15,379
and is the first party court actually

650
00:29:11,149 --> 00:29:17,299
calling it so we actually went out and

651
00:29:15,380 --> 00:29:20,360
manually evaluated a whole bunch of

652
00:29:17,299 --> 00:29:24,918
findings and after exactly this amount

653
00:29:20,360 --> 00:29:28,758
of time we made an observation so the

654
00:29:24,919 --> 00:29:31,429
deeper in a dependency graph that a

655
00:29:28,759 --> 00:29:35,419
vulnerable library would appear the less

656
00:29:31,429 --> 00:29:38,090
likely was it to be used in a in an

657
00:29:35,419 --> 00:29:41,710
exploitable vulnerable in a vulnerable

658
00:29:38,090 --> 00:29:45,379
way with this we developed a heuristic

659
00:29:41,710 --> 00:29:47,720
for now we'd only care about libraries

660
00:29:45,379 --> 00:29:50,719
that were less than three levels deep in

661
00:29:47,720 --> 00:29:52,519
the dependency tree and we'd also focus

662
00:29:50,720 --> 00:29:56,450
our efforts on just critical and high

663
00:29:52,519 --> 00:29:58,820
severity issues admittedly this process

664
00:29:56,450 --> 00:30:01,159
still has a lot of false positives but

665
00:29:58,820 --> 00:30:03,049
this leaves us with a triage process

666
00:30:01,159 --> 00:30:05,419
that is essentially more manageable at

667
00:30:03,049 --> 00:30:06,918
scale and this is kind of the path we

668
00:30:05,419 --> 00:30:09,649
are taking right now with respect to our

669
00:30:06,919 --> 00:30:15,049
third-party dependencies and with that I

670
00:30:09,649 --> 00:30:17,360
will hand it over to you all right I'm

671
00:30:15,049 --> 00:30:19,039
gonna try to wrap this up by talking a

672
00:30:17,360 --> 00:30:20,539
little bit about how we're taking these

673
00:30:19,039 --> 00:30:23,419
foundations and kind of moving it

674
00:30:20,539 --> 00:30:25,100
forward in a meaningful way right so so

675
00:30:23,419 --> 00:30:26,840
far we've covered up to committing code

676
00:30:25,100 --> 00:30:29,240
and as we know there's a bunch of

677
00:30:26,840 --> 00:30:31,070
different steps between committing code

678
00:30:29,240 --> 00:30:32,990
and actually deploying an application

679
00:30:31,070 --> 00:30:34,580
there's building the application there's

680
00:30:32,990 --> 00:30:36,110
testing the application there's actually

681
00:30:34,580 --> 00:30:37,939
going through the deploy process of

682
00:30:36,110 --> 00:30:39,799
deploying that application and these

683
00:30:37,940 --> 00:30:42,200
in-between steps kind of open up a lot

684
00:30:39,799 --> 00:30:45,529
of service area for things like code

685
00:30:42,200 --> 00:30:47,539
injection or injecting code or or

686
00:30:45,529 --> 00:30:49,909
third-party dependencies within within

687
00:30:47,539 --> 00:30:52,279
that surface area so in order to truly

688
00:30:49,909 --> 00:30:54,110
ensure that the code that is running in

689
00:30:52,279 --> 00:30:56,809
production is the same code that we've

690
00:30:54,110 --> 00:30:58,879
approved that has been approved we need

691
00:30:56,809 --> 00:31:00,559
to make sure that we one set up

692
00:30:58,879 --> 00:31:03,439
enforcement's all along the software

693
00:31:00,559 --> 00:31:06,019
development process and we chain those

694
00:31:03,440 --> 00:31:08,090
enforcement's in a way where it starts

695
00:31:06,019 --> 00:31:11,360
with the approved commits all the way to

696
00:31:08,090 --> 00:31:14,360
production so let's talk a little bit

697
00:31:11,360 --> 00:31:15,830
about how we change results so code is

698
00:31:14,360 --> 00:31:18,830
written by an engineer and one or more

699
00:31:15,830 --> 00:31:20,269
languages and is packaged into the form

700
00:31:18,830 --> 00:31:22,370
of a dip or a pull request or whatever

701
00:31:20,269 --> 00:31:22,970
you're using and these are committed to

702
00:31:22,370 --> 00:31:24,978
a bust

703
00:31:22,970 --> 00:31:28,340
we'll call the sum of all these commits

704
00:31:24,979 --> 00:31:30,859
that end up in a repo a commit box this

705
00:31:28,340 --> 00:31:32,869
commit box is created with a theoretical

706
00:31:30,859 --> 00:31:35,330
stamp that ensures us that this is

707
00:31:32,869 --> 00:31:37,478
coming from an approved author ie you

708
00:31:35,330 --> 00:31:40,189
know it has a commit signature on it

709
00:31:37,479 --> 00:31:41,509
commits are then landed on a repo and

710
00:31:40,190 --> 00:31:44,659
given a shot to represent their exact

711
00:31:41,509 --> 00:31:46,549
state this will call the repo box the

712
00:31:44,659 --> 00:31:48,320
repo box creation process has its own

713
00:31:46,549 --> 00:31:50,359
set of checks before creation right

714
00:31:48,320 --> 00:31:52,999
which includes security scans but it

715
00:31:50,359 --> 00:31:55,249
also includes checking the commit box

716
00:31:52,999 --> 00:31:56,029
stand to ensure that this is coming from

717
00:31:55,249 --> 00:31:58,059
an approver

718
00:31:56,029 --> 00:32:01,580
without actually having to do that check

719
00:31:58,059 --> 00:32:04,129
one or more of these gets built into and

720
00:32:01,580 --> 00:32:07,399
packaged along other things like system

721
00:32:04,129 --> 00:32:09,619
packages frameworks etc into a box that

722
00:32:07,399 --> 00:32:12,498
represents the application itself call

723
00:32:09,619 --> 00:32:14,269
the container or an iOS or Android case

724
00:32:12,499 --> 00:32:15,649
an application package an IPA or an apk

725
00:32:14,269 --> 00:32:18,470
but what just caught a container for

726
00:32:15,649 --> 00:32:19,488
simplicity so it's kind of weird to call

727
00:32:18,470 --> 00:32:21,379
this a container box because the

728
00:32:19,489 --> 00:32:22,669
container is kind of like a box but

729
00:32:21,379 --> 00:32:25,399
we're just gonna call this a container

730
00:32:22,669 --> 00:32:28,549
box anyway deal with it

731
00:32:25,399 --> 00:32:32,119
this container box also has its own set

732
00:32:28,549 --> 00:32:34,639
of checks right which includes checking

733
00:32:32,119 --> 00:32:36,199
the repo box stamp which ensures us of

734
00:32:34,639 --> 00:32:38,269
both the fact that it meets security

735
00:32:36,200 --> 00:32:40,070
policy and that it's coming from improve

736
00:32:38,269 --> 00:32:43,489
author without actually having to do

737
00:32:40,070 --> 00:32:47,720
that this container box is then checked

738
00:32:43,489 --> 00:32:50,690
and and then deployed this chain of

739
00:32:47,720 --> 00:32:53,629
custody that actually routes back to an

740
00:32:50,690 --> 00:32:56,779
SSH key at commit signing time will

741
00:32:53,629 --> 00:32:58,759
enable us to inherit trust by kind of

742
00:32:56,779 --> 00:33:01,789
verifying just one layer deep in your

743
00:32:58,759 --> 00:33:06,440
nested boxes so you kind of never have

744
00:33:01,789 --> 00:33:08,840
to ask the question cuz it's totally

745
00:33:06,440 --> 00:33:10,479
fine you can trust nothing's bad in the

746
00:33:08,840 --> 00:33:13,789
box

747
00:33:10,479 --> 00:33:15,619
all right so I'm gonna try to another

748
00:33:13,789 --> 00:33:16,999
way to kind of drive this home is to

749
00:33:15,619 --> 00:33:19,249
kind of compare this to the OSI model

750
00:33:16,999 --> 00:33:20,869
and layers right the main attributes

751
00:33:19,249 --> 00:33:22,429
kind of being that make it kind of

752
00:33:20,869 --> 00:33:25,099
similar are the fact that each layer has

753
00:33:22,429 --> 00:33:27,289
its own scope responsibilities only

754
00:33:25,099 --> 00:33:29,299
really communicates one layer above or

755
00:33:27,289 --> 00:33:31,009
below but still gets kind of those

756
00:33:29,299 --> 00:33:33,979
benefits because of the encapsulation

757
00:33:31,009 --> 00:33:36,739
chain that's actually happening so I

758
00:33:33,979 --> 00:33:37,640
present to you the four layers of the

759
00:33:36,739 --> 00:33:40,070
code prop

760
00:33:37,640 --> 00:33:43,070
the commit layer which is in charge of

761
00:33:40,070 --> 00:33:47,120
approvals and identity right and it

762
00:33:43,070 --> 00:33:49,129
takes as input SSH keys and uses that to

763
00:33:47,120 --> 00:33:51,520
sign commits ensuring that we have a

764
00:33:49,130 --> 00:33:55,580
form of identity connected to all code

765
00:33:51,520 --> 00:33:57,920
moving forward the repo layer is where

766
00:33:55,580 --> 00:33:59,510
software analysis is run and we find

767
00:33:57,920 --> 00:34:01,400
ourselves with commits as inputs and

768
00:33:59,510 --> 00:34:03,980
from earlier we know that commits holds

769
00:34:01,400 --> 00:34:05,630
a verifiable attestation of the origin

770
00:34:03,980 --> 00:34:08,480
of code that's being added via the

771
00:34:05,630 --> 00:34:10,610
commit signature so the presence of a

772
00:34:08,480 --> 00:34:12,710
valid commit signature allows us to set

773
00:34:10,610 --> 00:34:15,020
up some enforcement's based on policies

774
00:34:12,710 --> 00:34:16,699
to ensure us that the code that we're

775
00:34:15,020 --> 00:34:19,639
dealing with comes from an approved

776
00:34:16,699 --> 00:34:22,158
source this of course doesn't assure us

777
00:34:19,639 --> 00:34:24,139
that the code is actually not far below

778
00:34:22,159 --> 00:34:27,200
we we still have to do some scans for

779
00:34:24,139 --> 00:34:29,270
that on both the app and third-party

780
00:34:27,199 --> 00:34:31,069
code something that debo discussed in

781
00:34:29,270 --> 00:34:32,960
his previous sections

782
00:34:31,070 --> 00:34:35,899
but then the signature put on that repo

783
00:34:32,960 --> 00:34:37,850
at this state can verify both those

784
00:34:35,899 --> 00:34:39,830
things moving forward the container

785
00:34:37,850 --> 00:34:40,969
layer is where OCI scanners are used to

786
00:34:39,830 --> 00:34:43,370
check for vulnerabilities in the

787
00:34:40,969 --> 00:34:46,219
operating system packages frameworks or

788
00:34:43,370 --> 00:34:48,830
configurations this takes repose as

789
00:34:46,219 --> 00:34:50,209
inputs and inherits kind of inherits the

790
00:34:48,830 --> 00:34:52,879
at to stations that come with it right

791
00:34:50,210 --> 00:34:55,370
secure application third-party code and

792
00:34:52,879 --> 00:34:57,170
all the code that's introduced is coming

793
00:34:55,370 --> 00:34:58,640
from the proved author and the signature

794
00:34:57,170 --> 00:35:00,380
associate so this container can be used

795
00:34:58,640 --> 00:35:02,720
to verify all that and of course the

796
00:35:00,380 --> 00:35:05,960
fact that of course to authenticate the

797
00:35:02,720 --> 00:35:08,779
origin of where this was built and then

798
00:35:05,960 --> 00:35:10,010
of course we have the the host and

799
00:35:08,780 --> 00:35:11,750
deployment layer where the container

800
00:35:10,010 --> 00:35:13,280
signature is verified which kind of

801
00:35:11,750 --> 00:35:17,600
inherits everything before the app

802
00:35:13,280 --> 00:35:18,800
actually gets deployed so we go back to

803
00:35:17,600 --> 00:35:20,810
our big-picture state of the uber

804
00:35:18,800 --> 00:35:24,650
machine where everyone is kind of their

805
00:35:20,810 --> 00:35:28,790
own special snowflake and we we zoom

806
00:35:24,650 --> 00:35:31,220
back into one of the services so from

807
00:35:28,790 --> 00:35:34,100
all we've talked about about what we've

808
00:35:31,220 --> 00:35:36,200
done in this in this talk we can

809
00:35:34,100 --> 00:35:38,299
actually begin to see some guaranteed

810
00:35:36,200 --> 00:35:40,910
similarities right some patterns that

811
00:35:38,300 --> 00:35:43,030
can actually bring some homogeneity in

812
00:35:40,910 --> 00:35:46,220
our inherently heterogeneous environment

813
00:35:43,030 --> 00:35:48,290
we can see this by kind of walking

814
00:35:46,220 --> 00:35:49,480
backwards or peeling the onion if you

815
00:35:48,290 --> 00:35:51,900
may

816
00:35:49,480 --> 00:35:55,450
in our software development process

817
00:35:51,900 --> 00:35:57,760
because deployed applications they're

818
00:35:55,450 --> 00:36:00,419
really just containers of some sort that

819
00:35:57,760 --> 00:36:03,250
have a signature to be verified and

820
00:36:00,420 --> 00:36:05,860
these containers are known to be built

821
00:36:03,250 --> 00:36:08,620
by our build systems and known to be

822
00:36:05,860 --> 00:36:11,620
secure containers consists of

823
00:36:08,620 --> 00:36:15,210
repositories write repositories that

824
00:36:11,620 --> 00:36:17,620
have secure code added through commits

825
00:36:15,210 --> 00:36:21,910
commits that no we know come from

826
00:36:17,620 --> 00:36:24,279
approved engineers and through that we

827
00:36:21,910 --> 00:36:25,720
can guarantee code provenance of all the

828
00:36:24,280 --> 00:36:28,800
code that make up the lifeblood of the

829
00:36:25,720 --> 00:36:34,839
euro machine thank you

830
00:36:28,800 --> 00:36:34,839
[Applause]

