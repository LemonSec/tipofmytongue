1
00:00:00,030 --> 00:00:11,879
how not to use OAuth or maybe also how

2
00:00:05,250 --> 00:00:25,439
to use OAuth so let's start well it's

3
00:00:11,880 --> 00:00:27,420
not working ok it's working ok let's

4
00:00:25,439 --> 00:00:29,759
start with this question who is who in

5
00:00:27,420 --> 00:00:34,610
this room is familiar with OAuth like

6
00:00:29,760 --> 00:00:37,710
all the details all the four grand types

7
00:00:34,610 --> 00:00:39,750
ok and when I'm saying auth I'm talking

8
00:00:37,710 --> 00:00:42,980
about OAuth 2 0 so we're not talking

9
00:00:39,750 --> 00:00:46,230
about the order wants you ok

10
00:00:42,980 --> 00:00:49,800
so o 0 let's get everybody on the same

11
00:00:46,230 --> 00:00:52,769
page and start with a brief usage

12
00:00:49,800 --> 00:00:54,750
example you so we have a user and she'd

13
00:00:52,770 --> 00:00:57,329
like to authorize some online photo

14
00:00:54,750 --> 00:01:00,239
editor app to access her photos at

15
00:00:57,329 --> 00:01:04,979
Google Google photos her Google Photos

16
00:01:00,239 --> 00:01:07,369
account or whatever so in off the photo

17
00:01:04,979 --> 00:01:09,479
editor app would be the client and

18
00:01:07,369 --> 00:01:11,520
Google photos would provide the

19
00:01:09,479 --> 00:01:17,549
authorization server and the resource

20
00:01:11,520 --> 00:01:20,158
server now earth works in orth knows

21
00:01:17,549 --> 00:01:21,830
four different grant types and the most

22
00:01:20,159 --> 00:01:24,570
important one is the so-called

23
00:01:21,830 --> 00:01:28,320
authorization code grant type and this

24
00:01:24,570 --> 00:01:31,110
works as follows first the user says ok

25
00:01:28,320 --> 00:01:33,809
connect the photo editor app to my

26
00:01:31,110 --> 00:01:36,750
Google account and then the photo editor

27
00:01:33,810 --> 00:01:39,930
app here acting as the OAuth client will

28
00:01:36,750 --> 00:01:42,390
create an authorization request that

29
00:01:39,930 --> 00:01:44,490
will be sent to the user and the users

30
00:01:42,390 --> 00:01:47,970
browser will be redirected to the

31
00:01:44,490 --> 00:01:52,048
authorization server of auth in the next

32
00:01:47,970 --> 00:01:54,539
step the next step Google will ask the

33
00:01:52,049 --> 00:01:56,850
user do you want to give access to your

34
00:01:54,540 --> 00:01:59,189
photos to the photo editor app and the

35
00:01:56,850 --> 00:02:01,949
user of course needs to authenticate to

36
00:01:59,189 --> 00:02:05,758
a Google need to log in to your Google

37
00:02:01,950 --> 00:02:08,940
account and then can give access to her

38
00:02:05,759 --> 00:02:11,670
photos and then an authorization

39
00:02:08,940 --> 00:02:13,350
response is created and this

40
00:02:11,670 --> 00:02:15,709
authorization response in the

41
00:02:13,350 --> 00:02:18,150
both authorization code Graham type

42
00:02:15,710 --> 00:02:21,540
contains the so called authorization

43
00:02:18,150 --> 00:02:25,230
code which is then redirected back to

44
00:02:21,540 --> 00:02:27,929
the client and the client now can use

45
00:02:25,230 --> 00:02:31,829
that code to send the so called token

46
00:02:27,930 --> 00:02:34,140
request to the token endpoint and it

47
00:02:31,830 --> 00:02:36,300
sends the code and it gets back the

48
00:02:34,140 --> 00:02:38,029
access token and the access token is the

49
00:02:36,300 --> 00:02:41,190
single most important thing in all

50
00:02:38,030 --> 00:02:44,370
overflows because it's what gives access

51
00:02:41,190 --> 00:02:46,859
to the users data so with the extra stop

52
00:02:44,370 --> 00:02:51,360
and you can do whatever the user granted

53
00:02:46,860 --> 00:02:54,270
you to do that's exactly what the client

54
00:02:51,360 --> 00:02:56,400
will do in the next step okay so this is

55
00:02:54,270 --> 00:02:58,550
the authorization code grant type we see

56
00:02:56,400 --> 00:03:01,290
the important things here the

57
00:02:58,550 --> 00:03:03,840
authorization code the exes token and of

58
00:03:01,290 --> 00:03:08,250
course there's a lot of checks going on

59
00:03:03,840 --> 00:03:10,110
in the background for example we here

60
00:03:08,250 --> 00:03:12,600
have a so called redirect your I

61
00:03:10,110 --> 00:03:15,330
parameter that parameter is used to

62
00:03:12,600 --> 00:03:18,299
determine where the authorization

63
00:03:15,330 --> 00:03:20,520
response is being sent to of course we

64
00:03:18,300 --> 00:03:23,910
don't want that response to go straight

65
00:03:20,520 --> 00:03:27,450
to some attacker and therefore there's a

66
00:03:23,910 --> 00:03:30,660
check at in this case Google that checks

67
00:03:27,450 --> 00:03:33,420
whether this client is using that your

68
00:03:30,660 --> 00:03:35,549
i4 so it has a list of redirect your

69
00:03:33,420 --> 00:03:39,989
eyes or a pattern of redirect your eyes

70
00:03:35,550 --> 00:03:41,520
and then it checks the redirect URI here

71
00:03:39,990 --> 00:03:44,180
and if it passes then it will redirect

72
00:03:41,520 --> 00:03:47,790
the client the user back to that client

73
00:03:44,180 --> 00:03:50,700
there's also another check the so called

74
00:03:47,790 --> 00:03:54,600
state parameter here it's filled with

75
00:03:50,700 --> 00:03:56,429
some random mounts and in the request so

76
00:03:54,600 --> 00:03:58,680
this is created by the client in the

77
00:03:56,430 --> 00:04:02,220
request it just puts some random number

78
00:03:58,680 --> 00:04:04,590
there and this is returned by the

79
00:04:02,220 --> 00:04:08,160
authorization server and if it's not the

80
00:04:04,590 --> 00:04:12,510
same number appearing here then the oil

81
00:04:08,160 --> 00:04:15,240
flow is aborted okay and another thing

82
00:04:12,510 --> 00:04:16,980
we can optionally have here client so

83
00:04:15,240 --> 00:04:20,070
called client authentication the client

84
00:04:16,980 --> 00:04:23,610
might need to provide some credentials

85
00:04:20,070 --> 00:04:25,700
to send the token request we all we need

86
00:04:23,610 --> 00:04:28,100
all these details later

87
00:04:25,700 --> 00:04:31,159
also talking about how to make auth more

88
00:04:28,100 --> 00:04:34,160
secure and then that's also another

89
00:04:31,160 --> 00:04:36,770
important brand type and it's called the

90
00:04:34,160 --> 00:04:41,030
so called implicit grant and the

91
00:04:36,770 --> 00:04:43,039
implicit grant starts similar but works

92
00:04:41,030 --> 00:04:47,900
a bit different in the starting in the

93
00:04:43,040 --> 00:04:49,820
authorization response we see in the

94
00:04:47,900 --> 00:04:52,489
authorization response there are no

95
00:04:49,820 --> 00:04:55,130
query parameters added here but instead

96
00:04:52,490 --> 00:04:55,910
in a fragment part of the URI there's an

97
00:04:55,130 --> 00:04:58,460
access token

98
00:04:55,910 --> 00:05:00,560
so no authorization code used here

99
00:04:58,460 --> 00:05:02,180
instead an access token is created

100
00:05:00,560 --> 00:05:08,390
immediately in the authorization

101
00:05:02,180 --> 00:05:11,270
response so the browser is redirected to

102
00:05:08,390 --> 00:05:14,060
that year I for example client example

103
00:05:11,270 --> 00:05:15,740
slash auth ok and the browser will now

104
00:05:14,060 --> 00:05:17,600
retrieve that URI so that's the location

105
00:05:15,740 --> 00:05:20,300
redirect the browser will retrieve that

106
00:05:17,600 --> 00:05:25,280
your I and the browser will do so

107
00:05:20,300 --> 00:05:26,960
without sending the fragment part of the

108
00:05:25,280 --> 00:05:29,270
URI to the server

109
00:05:26,960 --> 00:05:30,620
that's just how browsers work so the

110
00:05:29,270 --> 00:05:33,169
fragment part is never sent to the

111
00:05:30,620 --> 00:05:35,120
server but the server can return some

112
00:05:33,170 --> 00:05:37,550
JavaScript and that JavaScript now has

113
00:05:35,120 --> 00:05:40,790
access to the excess server and can

114
00:05:37,550 --> 00:05:43,730
either use it directly and just send it

115
00:05:40,790 --> 00:05:46,370
to the resource server and get some

116
00:05:43,730 --> 00:05:49,250
photos from Google photos or whatever or

117
00:05:46,370 --> 00:05:53,180
it can pass it to the backend and then

118
00:05:49,250 --> 00:05:57,260
the backend can use the access token so

119
00:05:53,180 --> 00:06:01,640
this is the implicit grant so who uses

120
00:05:57,260 --> 00:06:04,450
all well almost everybody does it's it's

121
00:06:01,640 --> 00:06:08,659
everywhere nowadays so it was

122
00:06:04,450 --> 00:06:13,729
standardized in 2012 and by the ITF in

123
00:06:08,660 --> 00:06:16,130
our C 67 49 and our C 6750 and since

124
00:06:13,730 --> 00:06:18,980
then we've seen a tremendous adoption

125
00:06:16,130 --> 00:06:22,610
across the industry for authorization

126
00:06:18,980 --> 00:06:25,820
and also for authentication where we're

127
00:06:22,610 --> 00:06:27,650
so earth itself is not intended to do

128
00:06:25,820 --> 00:06:29,630
authentication but you can do or

129
00:06:27,650 --> 00:06:32,150
authentication with open ID connect and

130
00:06:29,630 --> 00:06:34,340
open ID Connect is based on off

131
00:06:32,150 --> 00:06:37,830
it's essentially off plus some extras

132
00:06:34,340 --> 00:06:40,500
and for example Google locking users

133
00:06:37,830 --> 00:06:42,690
open idly connect and the key success

134
00:06:40,500 --> 00:06:45,720
factors were simplicity and versatility

135
00:06:42,690 --> 00:06:50,840
you can use it for almost everything but

136
00:06:45,720 --> 00:06:55,680
is it also secure well let's see let's

137
00:06:50,840 --> 00:06:57,869
start with the OAuth implementations so

138
00:06:55,680 --> 00:07:01,800
with clients authorization service and

139
00:06:57,870 --> 00:07:04,919
resource service and if you look at the

140
00:07:01,800 --> 00:07:07,680
existing research in that area and also

141
00:07:04,919 --> 00:07:10,318
so this is also confirmed by what you

142
00:07:07,680 --> 00:07:13,860
experience when you see the

143
00:07:10,319 --> 00:07:18,870
implementations many many

144
00:07:13,860 --> 00:07:21,479
implementations contain flaws for

145
00:07:18,870 --> 00:07:23,099
example we see many implementations that

146
00:07:21,479 --> 00:07:26,330
don't properly protect against

147
00:07:23,099 --> 00:07:29,940
cross-site request forgery even in the

148
00:07:26,330 --> 00:07:32,219
even the 25 in the OAuth client in the

149
00:07:29,940 --> 00:07:35,580
Alexa top 10 thousand websites 25

150
00:07:32,219 --> 00:07:37,919
percent of them don't manage to prevent

151
00:07:35,580 --> 00:07:42,930
cross-site request forgery probably

152
00:07:37,919 --> 00:07:46,109
which is a lot also the Afghan

153
00:07:42,930 --> 00:07:48,569
vulnerability is in an official SDKs for

154
00:07:46,110 --> 00:07:51,180
example by Facebook and of course and

155
00:07:48,569 --> 00:07:54,539
the beginning of the year you might have

156
00:07:51,180 --> 00:07:57,479
heard about the big Facebook hack that

157
00:07:54,539 --> 00:08:01,639
was essentially also called crossed by a

158
00:07:57,479 --> 00:08:04,469
North implementation back okay so

159
00:08:01,639 --> 00:08:08,129
implementations have a lot of flaws but

160
00:08:04,469 --> 00:08:12,029
what what if you have an excellent

161
00:08:08,129 --> 00:08:14,520
implementation if you follow our C 67 49

162
00:08:12,029 --> 00:08:18,090
and all the others perfectly is it

163
00:08:14,520 --> 00:08:21,270
secure them well there's a lot of

164
00:08:18,090 --> 00:08:23,638
security advice in the to our CSR

165
00:08:21,270 --> 00:08:31,219
already named and the the third one the

166
00:08:23,639 --> 00:08:37,320
fourth threat model our 68 19 but still

167
00:08:31,219 --> 00:08:39,448
worth has a lot of faces a lot of

168
00:08:37,320 --> 00:08:42,779
challenges we have a complex and

169
00:08:39,448 --> 00:08:45,979
evolving environment so 2012 is seven

170
00:08:42,779 --> 00:08:49,620
years ago many things changed since then

171
00:08:45,980 --> 00:08:51,690
and we see off being used in new

172
00:08:49,620 --> 00:08:55,230
applications that we did

173
00:08:51,690 --> 00:08:59,400
see or that that nobody even imagined in

174
00:08:55,230 --> 00:09:05,310
2012 so what are the challenges that

175
00:08:59,400 --> 00:09:08,579
earth faces right now let's start with

176
00:09:05,310 --> 00:09:11,849
the first one implantation flaws we

177
00:09:08,580 --> 00:09:16,400
talked about that we still see a lot of

178
00:09:11,850 --> 00:09:20,460
them and they are always the same so

179
00:09:16,400 --> 00:09:21,120
people always are doing always the same

180
00:09:20,460 --> 00:09:23,280
mistakes

181
00:09:21,120 --> 00:09:26,790
for example insufficient redirect URI

182
00:09:23,280 --> 00:09:28,589
matching so the code or the access token

183
00:09:26,790 --> 00:09:32,160
is being sent to an attacker very easily

184
00:09:28,590 --> 00:09:33,690
or the state parameter is not used

185
00:09:32,160 --> 00:09:35,189
properly so the state parameter is

186
00:09:33,690 --> 00:09:38,670
intended to protect against cross-site

187
00:09:35,190 --> 00:09:41,340
request forgery and in our C 67 49 and

188
00:09:38,670 --> 00:09:43,290
68 19 it says you have to put a random

189
00:09:41,340 --> 00:09:46,740
number there and it's a freshman random

190
00:09:43,290 --> 00:09:49,140
number and then you check it when you

191
00:09:46,740 --> 00:09:54,630
get it back and people are not really

192
00:09:49,140 --> 00:09:59,520
following that and then technology

193
00:09:54,630 --> 00:10:02,450
changed for example the URI fragment

194
00:09:59,520 --> 00:10:06,210
handling so how the the fragment of the

195
00:10:02,450 --> 00:10:09,900
URI is handled when a browser gets a

196
00:10:06,210 --> 00:10:13,710
redirect this behavior has changed since

197
00:10:09,900 --> 00:10:18,540
2012 and the earth standard needs to

198
00:10:13,710 --> 00:10:20,700
yeah kind of add up to that and that can

199
00:10:18,540 --> 00:10:22,709
actually lead to a vulnerability when it

200
00:10:20,700 --> 00:10:27,330
is used together with an open redirector

201
00:10:22,710 --> 00:10:30,510
sowhat's nope redirect oh well very

202
00:10:27,330 --> 00:10:33,240
simple it's a parameterised unchecked

203
00:10:30,510 --> 00:10:35,790
redirection so say for example you have

204
00:10:33,240 --> 00:10:38,810
a year I like this client at example

205
00:10:35,790 --> 00:10:42,480
slash anything whatever and then a

206
00:10:38,810 --> 00:10:45,239
parameter resumed at and then you can

207
00:10:42,480 --> 00:10:49,500
provide some your I and if you call that

208
00:10:45,240 --> 00:10:51,930
your I then it will redirect you it will

209
00:10:49,500 --> 00:10:53,510
send your location redirect header to

210
00:10:51,930 --> 00:10:58,229
that URI

211
00:10:53,510 --> 00:11:02,790
so how can that be exploited well let's

212
00:10:58,230 --> 00:11:04,810
look at an example again so here we have

213
00:11:02,790 --> 00:11:09,010
more parties than before because we have

214
00:11:04,810 --> 00:11:13,270
right an attacker and that attacker now

215
00:11:09,010 --> 00:11:15,930
redirect a user to that your ISO example

216
00:11:13,270 --> 00:11:18,670
the example that comes less authorized

217
00:11:15,930 --> 00:11:22,359
and to redirect your eye which of course

218
00:11:18,670 --> 00:11:25,240
need some URI encoding as clan taught

219
00:11:22,360 --> 00:11:28,779
example slash auth ok resume at evil dot

220
00:11:25,240 --> 00:11:30,360
example slash harvest so what happens

221
00:11:28,779 --> 00:11:33,760
now

222
00:11:30,360 --> 00:11:38,680
well the user or the users browser

223
00:11:33,760 --> 00:11:41,529
rather follows that redirect and ends up

224
00:11:38,680 --> 00:11:43,839
at the authorization server the

225
00:11:41,529 --> 00:11:46,120
authorization server now probably check

226
00:11:43,839 --> 00:11:48,910
the redirect URI and sees that it points

227
00:11:46,120 --> 00:11:50,529
to client at example slash auth okay so

228
00:11:48,910 --> 00:11:52,630
everything is fine the points to the

229
00:11:50,529 --> 00:11:56,560
client the token will be redirected to

230
00:11:52,630 --> 00:11:58,960
the client the user authenticates

231
00:11:56,560 --> 00:12:02,920
contents to the authorization and so on

232
00:11:58,960 --> 00:12:05,440
and we are in the implicit flow here so

233
00:12:02,920 --> 00:12:08,199
the authorization server will create an

234
00:12:05,440 --> 00:12:09,970
access token and put it in the fragment

235
00:12:08,200 --> 00:12:12,130
path and redirect the user back to

236
00:12:09,970 --> 00:12:14,740
client at example slash auth okay resume

237
00:12:12,130 --> 00:12:20,189
at something-something and then the

238
00:12:14,740 --> 00:12:20,190
access token so what happens next

239
00:12:20,760 --> 00:12:28,420
well the browser goes to client dot

240
00:12:26,020 --> 00:12:31,319
example slash off ok resume at something

241
00:12:28,420 --> 00:12:34,750
without sending the fragment here and

242
00:12:31,320 --> 00:12:37,360
then the open redirector comes sends a

243
00:12:34,750 --> 00:12:40,540
location header to evil dot example

244
00:12:37,360 --> 00:12:46,270
slash harvest and now what happens it's

245
00:12:40,540 --> 00:12:49,540
a following the browser will call evil

246
00:12:46,270 --> 00:12:54,160
dot example slash harvest and attach the

247
00:12:49,540 --> 00:12:56,920
fragment to the that URI so the attacker

248
00:12:54,160 --> 00:12:59,740
can use some JavaScript so that does not

249
00:12:56,920 --> 00:13:01,420
send in the get request there but the

250
00:12:59,740 --> 00:13:04,690
attacker can just use some JavaScript to

251
00:13:01,420 --> 00:13:07,900
harvest that token so how did that

252
00:13:04,690 --> 00:13:10,540
happen well in 2012 this didn't happen

253
00:13:07,900 --> 00:13:13,360
because in 2012 the browser would not

254
00:13:10,540 --> 00:13:17,260
have reattached that fragment part to

255
00:13:13,360 --> 00:13:18,080
the URI after the location redirect so

256
00:13:17,260 --> 00:13:21,700
this is an exam

257
00:13:18,080 --> 00:13:24,290
of how technology changed and make that

258
00:13:21,700 --> 00:13:31,279
protocol that used to be more secure

259
00:13:24,290 --> 00:13:34,089
less secure so technological changes can

260
00:13:31,279 --> 00:13:39,820
cause implementation flaws

261
00:13:34,089 --> 00:13:42,890
next challenge high-stakes environments

262
00:13:39,820 --> 00:13:45,519
originally it was anticipated that earth

263
00:13:42,890 --> 00:13:48,649
would be used to give access to your

264
00:13:45,519 --> 00:13:52,279
photos like we've seen before for

265
00:13:48,649 --> 00:13:56,120
Facebook or whatever but not maybe for

266
00:13:52,279 --> 00:13:59,240
open banking but nowadays it's used for

267
00:13:56,120 --> 00:14:02,300
open banking across the EU we have the

268
00:13:59,240 --> 00:14:04,459
PSD to regulation which forces banks to

269
00:14:02,300 --> 00:14:07,910
implement interfaces for third parties

270
00:14:04,459 --> 00:14:10,640
to their users accounts and most of the

271
00:14:07,910 --> 00:14:14,660
standards that we see like open banking

272
00:14:10,640 --> 00:14:17,630
UK stat in France the Berlin group and

273
00:14:14,660 --> 00:14:20,779
also open ID financial great API they

274
00:14:17,630 --> 00:14:22,880
all build on top of all and now many

275
00:14:20,779 --> 00:14:25,880
more that I didn't didn't even put on

276
00:14:22,880 --> 00:14:27,770
here I think every open banking API that

277
00:14:25,880 --> 00:14:30,920
we are seeing in development now is

278
00:14:27,770 --> 00:14:35,870
faced to some degree on off and most of

279
00:14:30,920 --> 00:14:38,000
them just say use our C 67 49 and then

280
00:14:35,870 --> 00:14:40,700
you're done you're safe and you're not

281
00:14:38,000 --> 00:14:42,709
and yeah so that's that's a big problem

282
00:14:40,700 --> 00:14:46,850
and we also see other applications like

283
00:14:42,709 --> 00:14:49,910
également mobile operators the cloud

284
00:14:46,850 --> 00:14:52,730
signature consortium is building a

285
00:14:49,910 --> 00:14:56,680
technology to create legally binding

286
00:14:52,730 --> 00:15:00,079
electronic signatures just based on what

287
00:14:56,680 --> 00:15:04,250
we also see be health applications so a

288
00:15:00,079 --> 00:15:06,560
lot of or yeah wide range also of

289
00:15:04,250 --> 00:15:08,449
high-stakes environments and everybody's

290
00:15:06,560 --> 00:15:11,989
using OAuth and most of them just say

291
00:15:08,449 --> 00:15:15,859
yeah just use just follow our C 67 49

292
00:15:11,990 --> 00:15:18,140
and then you're done okay so we have a

293
00:15:15,860 --> 00:15:21,769
completely different threat model here I

294
00:15:18,140 --> 00:15:25,569
think that's pretty obvious next

295
00:15:21,769 --> 00:15:28,680
challenge dynamic and complex set ups

296
00:15:25,570 --> 00:15:31,680
originally in 2012 again

297
00:15:28,680 --> 00:15:34,618
it was anticipated that earth was used

298
00:15:31,680 --> 00:15:37,410
like this so we have one client and that

299
00:15:34,619 --> 00:15:39,300
one client is configured with one to

300
00:15:37,410 --> 00:15:42,649
connect to one authorization server and

301
00:15:39,300 --> 00:15:46,529
maybe one or more resource service and

302
00:15:42,649 --> 00:15:49,679
this relationship is configured

303
00:15:46,529 --> 00:15:51,929
statically and they kind of trust each

304
00:15:49,679 --> 00:15:55,259
other so everybody's trustworthy in this

305
00:15:51,929 --> 00:15:59,970
setup but this is not how off is used

306
00:15:55,259 --> 00:16:02,160
today today it looks more like this we

307
00:15:59,970 --> 00:16:04,019
have one client connecting to many

308
00:16:02,160 --> 00:16:08,009
authorization servers in many resource

309
00:16:04,019 --> 00:16:10,920
servers this these relationships are

310
00:16:08,009 --> 00:16:12,600
built dynamically so maybe user comes

311
00:16:10,920 --> 00:16:15,329
and says I'd like to use that auto

312
00:16:12,600 --> 00:16:16,619
relation server and then your client has

313
00:16:15,329 --> 00:16:19,618
to connect through that authorization

314
00:16:16,619 --> 00:16:21,209
server depending on on which ecosystem

315
00:16:19,619 --> 00:16:26,459
you're talking about but these setups

316
00:16:21,209 --> 00:16:29,128
exist so many participants and some of

317
00:16:26,459 --> 00:16:33,779
these can of course be not trustworthy

318
00:16:29,129 --> 00:16:35,639
or less trustworthy than others so we

319
00:16:33,779 --> 00:16:37,800
have a completely different set up we

320
00:16:35,639 --> 00:16:40,579
have dynamic setups dynamic

321
00:16:37,800 --> 00:16:43,849
relationships we have multiple a as

322
00:16:40,579 --> 00:16:49,410
multiple resource servers and so on and

323
00:16:43,850 --> 00:16:51,839
this exactly is where new attacks appear

324
00:16:49,410 --> 00:16:55,259
and one of these attacks that appeared

325
00:16:51,839 --> 00:16:57,660
was the authorization server mix-up

326
00:16:55,259 --> 00:17:01,559
attack not going to talk about the

327
00:16:57,660 --> 00:17:03,660
details of that attack here but the

328
00:17:01,559 --> 00:17:07,168
interesting thing here is held was found

329
00:17:03,660 --> 00:17:09,389
because it was not found by the

330
00:17:07,169 --> 00:17:12,959
standardization body and it was not

331
00:17:09,390 --> 00:17:15,919
found during pen testing or whatever it

332
00:17:12,959 --> 00:17:18,620
was found using a formal analysis and

333
00:17:15,919 --> 00:17:21,600
this is an interesting thing because

334
00:17:18,619 --> 00:17:23,698
this attack might teach us how to find

335
00:17:21,599 --> 00:17:27,020
similar attacks and different protocols

336
00:17:23,699 --> 00:17:31,279
and the same protocols in the future so

337
00:17:27,020 --> 00:17:35,309
let's briefly talk about formal analysis

338
00:17:31,279 --> 00:17:38,429
so what what does it mean as a

339
00:17:35,309 --> 00:17:41,370
practitioner you might not have

340
00:17:38,429 --> 00:17:46,110
precise picture of what formula analysis

341
00:17:41,370 --> 00:17:49,799
so let's I will try to give you an idea

342
00:17:46,110 --> 00:17:52,139
of how that works and that Folan

343
00:17:49,799 --> 00:17:53,970
analysis means you build a formal model

344
00:17:52,140 --> 00:17:55,950
of some system and then you do some

345
00:17:53,970 --> 00:17:58,799
analysis on top of it

346
00:17:55,950 --> 00:18:01,230
so essentially you can do offline

347
00:17:58,799 --> 00:18:04,289
testing of your application logic or in

348
00:18:01,230 --> 00:18:06,630
the case of all of your standard of the

349
00:18:04,289 --> 00:18:09,179
logic that is built into the center you

350
00:18:06,630 --> 00:18:11,220
can do that before even writing a single

351
00:18:09,179 --> 00:18:14,549
line of code so it's not static analysis

352
00:18:11,220 --> 00:18:17,659
it's not dynamic analysis it's analyzing

353
00:18:14,549 --> 00:18:20,760
the logic behind the application and

354
00:18:17,659 --> 00:18:25,890
this can help us to find regressions as

355
00:18:20,760 --> 00:18:27,658
we have seen before in the in yeah

356
00:18:25,890 --> 00:18:29,990
technical course by technological

357
00:18:27,659 --> 00:18:32,159
changes and this has actually been

358
00:18:29,990 --> 00:18:35,429
successfully been used for cryptographic

359
00:18:32,159 --> 00:18:37,860
protocols for many years now but we are

360
00:18:35,429 --> 00:18:40,350
not used to have that on the web right

361
00:18:37,860 --> 00:18:43,860
now but if you think for example of TLS

362
00:18:40,350 --> 00:18:47,520
1.3 this the standard was developed

363
00:18:43,860 --> 00:18:50,729
together with many people of the formula

364
00:18:47,520 --> 00:18:53,610
analysis community and they provided a

365
00:18:50,730 --> 00:18:55,559
lot of input they really try to make

366
00:18:53,610 --> 00:19:01,049
sure that this is a very very secure

367
00:18:55,559 --> 00:19:04,529
protocol and if you do this it will also

368
00:19:01,049 --> 00:19:06,330
help you to provide to precisely define

369
00:19:04,529 --> 00:19:08,520
what you mean when you write a

370
00:19:06,330 --> 00:19:10,500
specification so you also have this

371
00:19:08,520 --> 00:19:13,309
benefit of getting a better

372
00:19:10,500 --> 00:19:17,279
specification if you use formal methods

373
00:19:13,309 --> 00:19:19,049
okay and last but not least it also can

374
00:19:17,279 --> 00:19:22,919
provide you with security guarantees of

375
00:19:19,049 --> 00:19:24,690
course within the limits of the model so

376
00:19:22,919 --> 00:19:28,380
this is not common for web applications

377
00:19:24,690 --> 00:19:30,840
or web standards yet but how does it

378
00:19:28,380 --> 00:19:32,840
work if you want to analyze a web

379
00:19:30,840 --> 00:19:36,289
application or website let's say you are

380
00:19:32,840 --> 00:19:40,199
well on a high level it looks like this

381
00:19:36,289 --> 00:19:42,179
so you start with a generic description

382
00:19:40,200 --> 00:19:47,190
of how the web works okay that's a lot

383
00:19:42,179 --> 00:19:49,770
to ask but you can boil it down to what

384
00:19:47,190 --> 00:19:51,510
is relevant for security so most of the

385
00:19:49,770 --> 00:19:52,100
time we're not caring about whether it's

386
00:19:51,510 --> 00:19:55,460
a cat Pig

387
00:19:52,100 --> 00:19:57,320
or a dot picture so no don't need to

388
00:19:55,460 --> 00:19:59,780
talk about user interface details most

389
00:19:57,320 --> 00:20:03,500
of the time for example but you need to

390
00:19:59,780 --> 00:20:06,110
define how a browser works at least on

391
00:20:03,500 --> 00:20:09,260
some specific level you need to define

392
00:20:06,110 --> 00:20:11,809
how a network works and so on you create

393
00:20:09,260 --> 00:20:13,429
a formal description of that so you

394
00:20:11,809 --> 00:20:15,168
write it down in some formal language

395
00:20:13,429 --> 00:20:18,799
you can use a tool for that or you can

396
00:20:15,169 --> 00:20:21,100
just use pen and paper and then on top

397
00:20:18,799 --> 00:20:24,918
of that you build the application

398
00:20:21,100 --> 00:20:26,990
specific model so you take the standard

399
00:20:24,919 --> 00:20:30,289
for example the earth standard and then

400
00:20:26,990 --> 00:20:32,480
you define what's what's written in the

401
00:20:30,289 --> 00:20:34,730
standard essentially you say how is an

402
00:20:32,480 --> 00:20:37,370
application using OAuth behavior what

403
00:20:34,730 --> 00:20:40,220
does it do how what what methods of the

404
00:20:37,370 --> 00:20:44,719
browser does it invoke what JavaScript

405
00:20:40,220 --> 00:20:47,360
does it use and so on then you have all

406
00:20:44,720 --> 00:20:50,299
the tools you need to precisely define

407
00:20:47,360 --> 00:20:52,219
what security means which is often not

408
00:20:50,299 --> 00:20:54,379
as easy as it sounds because intuitively

409
00:20:52,220 --> 00:20:56,600
you know that with all nobody else

410
00:20:54,380 --> 00:21:00,320
should be able to add on or access your

411
00:20:56,600 --> 00:21:03,408
Facebook account that's pretty clear but

412
00:21:00,320 --> 00:21:06,590
if you want to define it precisely it's

413
00:21:03,409 --> 00:21:09,559
not so easy but you can now do it you

414
00:21:06,590 --> 00:21:11,600
have all the tools and then you can try

415
00:21:09,559 --> 00:21:15,980
to prove that your application is secure

416
00:21:11,600 --> 00:21:18,350
and you're done right no course not in

417
00:21:15,980 --> 00:21:20,270
an ideal world this world this would

418
00:21:18,350 --> 00:21:22,639
work but it will not work like this

419
00:21:20,270 --> 00:21:26,090
instead you will not be able to prove

420
00:21:22,640 --> 00:21:30,950
that because you will find an attack

421
00:21:26,090 --> 00:21:33,649
most likely you will find in sec one or

422
00:21:30,950 --> 00:21:36,200
more but the good thing is your phone on

423
00:21:33,650 --> 00:21:39,980
attack and now you can try to fix that

424
00:21:36,200 --> 00:21:42,230
attack and of course then integrate

425
00:21:39,980 --> 00:21:46,010
these fixes into your model again and

426
00:21:42,230 --> 00:21:48,530
then you can do the same thing again and

427
00:21:46,010 --> 00:21:51,830
then rinse and repeat until your proof

428
00:21:48,530 --> 00:21:55,340
goes through and then you found some

429
00:21:51,830 --> 00:21:57,470
attacks and ideally you also have a

430
00:21:55,340 --> 00:22:00,770
proof within the limits of the model of

431
00:21:57,470 --> 00:22:04,580
the security of your application this is

432
00:22:00,770 --> 00:22:05,820
exactly what I did in my PhD thesis for

433
00:22:04,580 --> 00:22:08,189
wolf

434
00:22:05,820 --> 00:22:09,899
and also some other things but we're

435
00:22:08,190 --> 00:22:11,730
talking about worth today

436
00:22:09,900 --> 00:22:13,530
I created the so called web

437
00:22:11,730 --> 00:22:14,610
infrastructure model which is just a

438
00:22:13,530 --> 00:22:16,889
description of how the web

439
00:22:14,610 --> 00:22:19,199
infrastructure works it's a manual pen

440
00:22:16,890 --> 00:22:22,020
and paper model so it's not based on

441
00:22:19,200 --> 00:22:24,300
some model checker or any other tool

442
00:22:22,020 --> 00:22:27,690
because I wanted to create a very

443
00:22:24,300 --> 00:22:33,230
comprehensive and precise Tiffany model

444
00:22:27,690 --> 00:22:37,020
of how the web works and this model

445
00:22:33,230 --> 00:22:39,570
contains browser behavior scripts

446
00:22:37,020 --> 00:22:40,980
windows documents how different

447
00:22:39,570 --> 00:22:43,800
documents can interact with each other

448
00:22:40,980 --> 00:22:46,560
in a browser and so on there's also an

449
00:22:43,800 --> 00:22:49,050
abstract model for DNS for networks and

450
00:22:46,560 --> 00:22:51,600
so on so it's a very comprehensive model

451
00:22:49,050 --> 00:22:55,050
we have a lot of features in there and

452
00:22:51,600 --> 00:22:58,409
using that model I created a model of or

453
00:22:55,050 --> 00:23:00,360
two zeros so I just took our C 67 49 and

454
00:22:58,410 --> 00:23:03,090
all the other security recommendations

455
00:23:00,360 --> 00:23:04,620
out there to build a model of earth with

456
00:23:03,090 --> 00:23:08,100
all the security features that were

457
00:23:04,620 --> 00:23:09,870
known to date in place because I was not

458
00:23:08,100 --> 00:23:12,659
interested to find in finding any

459
00:23:09,870 --> 00:23:13,560
attacks that we already know about then

460
00:23:12,660 --> 00:23:16,680
in the next step

461
00:23:13,560 --> 00:23:18,840
I provided detailed definitions for

462
00:23:16,680 --> 00:23:21,110
authorization authentication and session

463
00:23:18,840 --> 00:23:25,639
integrity where a session integrity

464
00:23:21,110 --> 00:23:29,250
means things kind of things such as

465
00:23:25,640 --> 00:23:34,170
session swapping attacks and then I

466
00:23:29,250 --> 00:23:38,100
tried to prove the security and I failed

467
00:23:34,170 --> 00:23:39,660
because I found the text attacks like

468
00:23:38,100 --> 00:23:41,879
the three or seven redirect attack

469
00:23:39,660 --> 00:23:44,640
various attacks on session integrity

470
00:23:41,880 --> 00:23:48,030
with the state parameter and similar

471
00:23:44,640 --> 00:23:49,620
things and the AES mix of attack again

472
00:23:48,030 --> 00:23:51,060
I'm not talking about the details of the

473
00:23:49,620 --> 00:23:52,739
text because we're not on an attack

474
00:23:51,060 --> 00:23:57,929
conference here but we're interested in

475
00:23:52,740 --> 00:24:00,030
how to defend I then developed fixes

476
00:23:57,930 --> 00:24:03,330
against these attacks integrated them

477
00:24:00,030 --> 00:24:06,840
into the model and where it was able to

478
00:24:03,330 --> 00:24:09,240
prove the security of the earth of the

479
00:24:06,840 --> 00:24:15,659
earth protocol again within the limits

480
00:24:09,240 --> 00:24:16,640
of this model of course okay das mix-up

481
00:24:15,660 --> 00:24:20,570
attack

482
00:24:16,640 --> 00:24:24,649
very briefly it's a you confuse the

483
00:24:20,570 --> 00:24:27,289
client to send the user to an honest a s

484
00:24:24,649 --> 00:24:32,059
so the user goes to Google and gives

485
00:24:27,289 --> 00:24:34,760
authorization and then the client still

486
00:24:32,059 --> 00:24:36,980
thinks that you that the user doesn't go

487
00:24:34,760 --> 00:24:40,580
to the honest a s but the client thinks

488
00:24:36,980 --> 00:24:42,500
that the user goes to your own a s or

489
00:24:40,580 --> 00:24:44,928
the attacker a s and therefore the

490
00:24:42,500 --> 00:24:47,360
client sends the code and the token to

491
00:24:44,929 --> 00:24:49,010
the attacker if you interested in

492
00:24:47,360 --> 00:24:53,658
details of this attack we could talk

493
00:24:49,010 --> 00:24:55,669
about that after the talk the followed

494
00:24:53,659 --> 00:25:00,039
is interesting of the a s mix-up attack

495
00:24:55,669 --> 00:25:02,779
because it kind of inspired a new

496
00:25:00,039 --> 00:25:06,500
security workshop seriously all security

497
00:25:02,779 --> 00:25:15,649
workshop Jim was there a month ago in

498
00:25:06,500 --> 00:25:20,929
Stuttgart and this is Jim and more

499
00:25:15,649 --> 00:25:23,090
importantly we created a new IT FRC the

500
00:25:20,929 --> 00:25:26,570
or security best current practice and

501
00:25:23,090 --> 00:25:29,240
that is a new document that essentially

502
00:25:26,570 --> 00:25:32,450
updates all the security practice the

503
00:25:29,240 --> 00:25:34,850
security best practice you know for it's

504
00:25:32,450 --> 00:25:38,360
currently under development we hope to

505
00:25:34,850 --> 00:25:41,209
finish it soon and it doesn't replace

506
00:25:38,360 --> 00:25:44,330
but it complements the existing security

507
00:25:41,210 --> 00:25:46,370
advice you get for all of the main

508
00:25:44,330 --> 00:25:48,080
features are an updated and more

509
00:25:46,370 --> 00:25:51,080
comprehensive threat model to account

510
00:25:48,080 --> 00:25:53,658
for these high-stakes environments we

511
00:25:51,080 --> 00:25:56,870
have a description of the attacks that

512
00:25:53,659 --> 00:25:59,690
are known now that are not known back

513
00:25:56,870 --> 00:26:04,428
then and we provide simple and

514
00:25:59,690 --> 00:26:06,139
actionable recommendations okay so the

515
00:26:04,429 --> 00:26:08,809
seven most important recommendations in

516
00:26:06,139 --> 00:26:10,760
the earth security BCP I see we're in

517
00:26:08,809 --> 00:26:15,590
this confidence today we see a lot of

518
00:26:10,760 --> 00:26:18,260
seven things talks let's see okay first

519
00:26:15,590 --> 00:26:25,459
one most important one do not use the

520
00:26:18,260 --> 00:26:27,470
implicit grant any longer thank you why

521
00:26:25,460 --> 00:26:29,899
let us perceive by many as being the

522
00:26:27,470 --> 00:26:33,440
simpler auth it is mainly the more

523
00:26:29,899 --> 00:26:35,658
insecure so off so don't use it it has

524
00:26:33,440 --> 00:26:39,559
so many problems and doesn't provide any

525
00:26:35,659 --> 00:26:42,679
defense-in-depth for example the access

526
00:26:39,559 --> 00:26:45,500
token is contained in the URI your eyes

527
00:26:42,679 --> 00:26:47,630
can leak from your or they are in your

528
00:26:45,500 --> 00:26:49,789
browsing history they can end up in

529
00:26:47,630 --> 00:26:53,149
proxies they can be locked by operating

530
00:26:49,789 --> 00:26:54,770
systems and of course the access token

531
00:26:53,149 --> 00:26:56,989
being available through the JavaScript

532
00:26:54,770 --> 00:27:00,200
here makes it such as to go to

533
00:26:56,990 --> 00:27:04,340
cross-site scripting so this is kind of

534
00:27:00,200 --> 00:27:05,870
dangerous at the same time you can't

535
00:27:04,340 --> 00:27:07,908
really protect against access token

536
00:27:05,870 --> 00:27:10,668
replay anybody having this access token

537
00:27:07,909 --> 00:27:14,980
can use it you don't have any sender

538
00:27:10,669 --> 00:27:18,649
constraining for the access token then

539
00:27:14,980 --> 00:27:20,779
access token injection so at this point

540
00:27:18,649 --> 00:27:22,549
an attacker can just use some excess

541
00:27:20,779 --> 00:27:26,270
token he got from some other flow and

542
00:27:22,549 --> 00:27:27,889
inject it here and then the client will

543
00:27:26,270 --> 00:27:29,840
use that excess of my client cannot

544
00:27:27,889 --> 00:27:34,309
check the origin of that access token

545
00:27:29,840 --> 00:27:35,899
essentially so the implicit grant sends

546
00:27:34,309 --> 00:27:37,580
this powerful and long-lived access

547
00:27:35,899 --> 00:27:38,120
token through the browser which is not a

548
00:27:37,580 --> 00:27:40,039
good idea

549
00:27:38,120 --> 00:27:42,350
it lacks features for sender

550
00:27:40,039 --> 00:27:44,720
constraining we have replay an injection

551
00:27:42,350 --> 00:27:46,340
problems and it doesn't provide any

552
00:27:44,720 --> 00:27:49,029
defense in that so if any of your

553
00:27:46,340 --> 00:27:52,549
defense lines falls then you're screwed

554
00:27:49,029 --> 00:27:54,919
so why is it even there

555
00:27:52,549 --> 00:27:56,870
well because back in 2000 have

556
00:27:54,919 --> 00:27:59,360
cross-origin resource sharing so it was

557
00:27:56,870 --> 00:28:01,870
hard to do the token exchange where you

558
00:27:59,360 --> 00:28:06,830
sent the code and get back the token

559
00:28:01,870 --> 00:28:09,860
therefore we had this simpler option for

560
00:28:06,830 --> 00:28:12,620
auth but this is not needed in 2019

561
00:28:09,860 --> 00:28:15,529
don't use it this is exactly what the

562
00:28:12,620 --> 00:28:17,809
new PCP says clients should not use the

563
00:28:15,529 --> 00:28:20,299
implicit grant this is a short note for

564
00:28:17,809 --> 00:28:22,970
political reasons clients should instead

565
00:28:20,299 --> 00:28:26,160
use the response type code so the

566
00:28:22,970 --> 00:28:29,970
authorization code granted

567
00:28:26,160 --> 00:28:32,820
okay next one used instead the

568
00:28:29,970 --> 00:28:35,490
authorization code grant but don't use

569
00:28:32,820 --> 00:28:37,919
it like it was written in our C 67 49

570
00:28:35,490 --> 00:28:41,250
instead use modern security features

571
00:28:37,920 --> 00:28:44,340
that we have for the auth code grant for

572
00:28:41,250 --> 00:28:48,870
example pick C proof key for code

573
00:28:44,340 --> 00:28:51,540
exchanged this means it's a very simple

574
00:28:48,870 --> 00:28:53,370
mechanism actually so any authorization

575
00:28:51,540 --> 00:28:54,600
request the client sends a so-called

576
00:28:53,370 --> 00:28:57,629
Coachella

577
00:28:54,600 --> 00:29:02,399
that is a sha-256 hash of some random

578
00:28:57,630 --> 00:29:05,160
number and then the authorization code

579
00:29:02,400 --> 00:29:07,800
that is created here will be bound to

580
00:29:05,160 --> 00:29:10,620
that code challenge and if you if

581
00:29:07,800 --> 00:29:13,110
anybody wants to use that code he has to

582
00:29:10,620 --> 00:29:15,689
provide the code verifier which is just

583
00:29:13,110 --> 00:29:18,860
the plain text so the random number that

584
00:29:15,690 --> 00:29:22,890
was hashed before which nobody can know

585
00:29:18,860 --> 00:29:25,350
because this was the hash and therefore

586
00:29:22,890 --> 00:29:28,560
nobody can use the code except for the

587
00:29:25,350 --> 00:29:30,419
original client and if anything is this

588
00:29:28,560 --> 00:29:33,300
does not only provide you with replay an

589
00:29:30,420 --> 00:29:35,430
injection prevention for the

590
00:29:33,300 --> 00:29:36,540
authorization code but instead also

591
00:29:35,430 --> 00:29:39,240
provides you with cross-site request

592
00:29:36,540 --> 00:29:44,040
forgery protection if you think about so

593
00:29:39,240 --> 00:29:47,820
nice feature second one you can make new

594
00:29:44,040 --> 00:29:49,800
single you can make code single use so

595
00:29:47,820 --> 00:29:53,240
anybody replaying this whole request

596
00:29:49,800 --> 00:29:55,740
cannot just get a new access token and

597
00:29:53,240 --> 00:29:59,340
also a very important feature you can

598
00:29:55,740 --> 00:30:02,910
use the authorization code grant to send

599
00:29:59,340 --> 00:30:06,179
a constrain your access circuits how

600
00:30:02,910 --> 00:30:09,510
does that work so it's very simple you

601
00:30:06,180 --> 00:30:11,670
use TLS client authentication with a

602
00:30:09,510 --> 00:30:13,740
client certificate that is just self

603
00:30:11,670 --> 00:30:17,400
signed so no PKI in the background just

604
00:30:13,740 --> 00:30:19,770
a self signed client certificate and the

605
00:30:17,400 --> 00:30:22,680
client sends that certificate in this

606
00:30:19,770 --> 00:30:24,930
connection the server will then bind

607
00:30:22,680 --> 00:30:27,930
this access token to the client

608
00:30:24,930 --> 00:30:30,540
certificate and anybody using that

609
00:30:27,930 --> 00:30:34,740
access token has to prevent present the

610
00:30:30,540 --> 00:30:37,770
same client certificate that's all token

611
00:30:34,740 --> 00:30:39,480
binding using mutual TLS and it's a very

612
00:30:37,770 --> 00:30:43,920
good mechanism for sender constraint

613
00:30:39,480 --> 00:30:45,870
chuckles so to sum up

614
00:30:43,920 --> 00:30:48,030
authorization code grant with pixee

615
00:30:45,870 --> 00:30:51,780
proof p4 code exchange and M TLS

616
00:30:48,030 --> 00:30:53,760
protects against injection and replay we

617
00:30:51,780 --> 00:30:57,480
have defense and death because we have

618
00:30:53,760 --> 00:30:59,220
many lines of Defense's this is exactly

619
00:30:57,480 --> 00:31:02,340
the recommendation that is contained in

620
00:30:59,220 --> 00:31:04,560
a security PCP there you must use pixie

621
00:31:02,340 --> 00:31:06,659
if you use the off-brand and you should

622
00:31:04,560 --> 00:31:10,379
use TLS based method for sender

623
00:31:06,660 --> 00:31:12,360
constraint access tokens okay before

624
00:31:10,380 --> 00:31:15,690
this is the first and most important

625
00:31:12,360 --> 00:31:20,669
recommendation in the new PCP second one

626
00:31:15,690 --> 00:31:23,220
prevent mix-up attacks we have seen not

627
00:31:20,670 --> 00:31:25,200
many details about the mix-up attack but

628
00:31:23,220 --> 00:31:28,410
it's very simple to defend against a

629
00:31:25,200 --> 00:31:30,870
mix-up attack the client must be able to

630
00:31:28,410 --> 00:31:33,330
see where the authorization response

631
00:31:30,870 --> 00:31:35,760
came from and this is simple to

632
00:31:33,330 --> 00:31:39,990
accomplish the client needs to ensure

633
00:31:35,760 --> 00:31:43,470
that for every a s it is using the a s

634
00:31:39,990 --> 00:31:45,840
uses a different redirect URI so the

635
00:31:43,470 --> 00:31:48,510
client exactly sees from which a s

636
00:31:45,840 --> 00:31:51,090
response comes the authorization

637
00:31:48,510 --> 00:31:52,740
response comes you get that for free if

638
00:31:51,090 --> 00:31:55,860
you're using opener D connect you just

639
00:31:52,740 --> 00:31:58,680
have to check it and the client must

640
00:31:55,860 --> 00:32:02,699
keep track of which a s was intended and

641
00:31:58,680 --> 00:32:08,270
then I am sure that only this a s can

642
00:32:02,700 --> 00:32:11,430
send can send the authorization response

643
00:32:08,270 --> 00:32:17,370
third recommendations stop redirection

644
00:32:11,430 --> 00:32:19,140
scan wires we need we still see that

645
00:32:17,370 --> 00:32:22,020
many people don't get those right so

646
00:32:19,140 --> 00:32:25,110
they use for example pattern matching

647
00:32:22,020 --> 00:32:27,270
for redirect URIs and this always goes

648
00:32:25,110 --> 00:32:28,919
wrong for some reason people don't get

649
00:32:27,270 --> 00:32:31,080
their regular expressions correct and

650
00:32:28,920 --> 00:32:36,630
made they use wild card all over the

651
00:32:31,080 --> 00:32:38,850
place so just don't do that instead use

652
00:32:36,630 --> 00:32:42,450
exact redirect URI matching use one

653
00:32:38,850 --> 00:32:46,409
redirect URI pas and this redirect URI

654
00:32:42,450 --> 00:32:50,030
is the one and and no no dynamic things

655
00:32:46,410 --> 00:32:50,030
just just one redirect URI

656
00:32:50,420 --> 00:32:56,630
and do not use do not build open we

657
00:32:54,950 --> 00:32:59,780
directors so if you want to redirect

658
00:32:56,630 --> 00:33:01,850
based on some your I parameter then use

659
00:32:59,780 --> 00:33:04,149
a white listing or you some some means

660
00:33:01,850 --> 00:33:08,419
of authentication for that you arrived

661
00:33:04,150 --> 00:33:13,340
okay fourth one prevent CSI after text

662
00:33:08,420 --> 00:33:15,890
that's not a new one but so already in

663
00:33:13,340 --> 00:33:19,100
the old our C's it says use the state

664
00:33:15,890 --> 00:33:22,100
parameter but as I said before if you

665
00:33:19,100 --> 00:33:24,530
use pixie and the client any

666
00:33:22,100 --> 00:33:28,219
authorization server both support pixie

667
00:33:24,530 --> 00:33:29,870
then you get CSF protection for free so

668
00:33:28,220 --> 00:33:31,280
you don't need to use stake any longer

669
00:33:29,870 --> 00:33:32,870
you don't need to think about random

670
00:33:31,280 --> 00:33:38,899
numbers just except for the one for

671
00:33:32,870 --> 00:33:40,610
pixie so do that so use pixie then you

672
00:33:38,900 --> 00:33:43,160
don't need to use state any longer then

673
00:33:40,610 --> 00:33:45,830
you can use state for its original

674
00:33:43,160 --> 00:33:48,280
purpose namely just some application

675
00:33:45,830 --> 00:33:51,350
state okay

676
00:33:48,280 --> 00:33:53,840
fifth one limit the privileges

677
00:33:51,350 --> 00:33:56,270
associated with access tokens we have

678
00:33:53,840 --> 00:33:58,909
seen sender constraining so that not

679
00:33:56,270 --> 00:34:01,010
anybody can send the access token you

680
00:33:58,910 --> 00:34:04,040
should also do receiver constraining

681
00:34:01,010 --> 00:34:06,650
limit the access token to be valid at

682
00:34:04,040 --> 00:34:08,570
one single resource server only so that

683
00:34:06,650 --> 00:34:11,630
if one resource server becomes

684
00:34:08,570 --> 00:34:14,630
compromised it cannot just use the

685
00:34:11,630 --> 00:34:17,150
access token somewhere else and of

686
00:34:14,630 --> 00:34:19,730
course reduce try to reduce the scope

687
00:34:17,150 --> 00:34:22,010
and the lifetime that is associated with

688
00:34:19,730 --> 00:34:25,760
the nexus token with each access token

689
00:34:22,010 --> 00:34:28,040
to do that you might want to use refresh

690
00:34:25,760 --> 00:34:30,740
tokens which you can use in the

691
00:34:28,040 --> 00:34:32,480
authorization code grant refresh tokens

692
00:34:30,739 --> 00:34:36,469
are not a new concept are they a great

693
00:34:32,480 --> 00:34:37,969
concept they are very simple so each

694
00:34:36,469 --> 00:34:40,879
time you get an access token you also

695
00:34:37,969 --> 00:34:43,699
get a long-lived refresh token and if

696
00:34:40,880 --> 00:34:46,550
your access token expires you can use

697
00:34:43,699 --> 00:34:50,960
the Refresh token to get a new pair of

698
00:34:46,550 --> 00:34:53,360
access token and refresh token so the

699
00:34:50,960 --> 00:34:56,889
access token can be more limited in its

700
00:34:53,360 --> 00:34:59,660
scope and in its lifetime and you can

701
00:34:56,889 --> 00:35:03,420
throw all your protection mechanisms on

702
00:34:59,660 --> 00:35:06,118
the Refresh token what are these

703
00:35:03,420 --> 00:35:08,250
well you can use client authentication

704
00:35:06,119 --> 00:35:10,020
client binding you can say only this

705
00:35:08,250 --> 00:35:14,400
specific line that needs to authenticate

706
00:35:10,020 --> 00:35:16,349
can use the Refresh token you have a

707
00:35:14,400 --> 00:35:19,799
sender constraining mechanism just like

708
00:35:16,349 --> 00:35:23,930
for the access tokens and you can use

709
00:35:19,799 --> 00:35:26,579
refresh token rotation so each time

710
00:35:23,930 --> 00:35:28,348
anybody saw we've seen before that you

711
00:35:26,579 --> 00:35:30,809
get a new refresh token each time the

712
00:35:28,349 --> 00:35:33,299
user refresh token but if anybody is

713
00:35:30,809 --> 00:35:35,369
using an old refresh token you

714
00:35:33,299 --> 00:35:36,930
immediately invalidate all the refresh

715
00:35:35,369 --> 00:35:40,109
tokens and all the access tokens

716
00:35:36,930 --> 00:35:42,868
associated with that grant so if

717
00:35:40,109 --> 00:35:45,690
somebody tries to replay a refresh token

718
00:35:42,869 --> 00:35:51,390
everything will be thrown down

719
00:35:45,690 --> 00:35:53,040
essentially seventh and last do not use

720
00:35:51,390 --> 00:35:56,150
the resource on a password credentials

721
00:35:53,040 --> 00:36:01,440
grant any longer this is it's really

722
00:35:56,150 --> 00:36:03,329
it's it's strange so it works as follows

723
00:36:01,440 --> 00:36:05,670
the user sensor username and password

724
00:36:03,329 --> 00:36:07,770
for the AES to the client and the client

725
00:36:05,670 --> 00:36:10,380
uses that username and password at the

726
00:36:07,770 --> 00:36:13,890
AES to get an access token I think the

727
00:36:10,380 --> 00:36:15,079
downsides are obvious the client sees

728
00:36:13,890 --> 00:36:18,210
the username and password of the user

729
00:36:15,079 --> 00:36:20,220
this is completely orthogonal to what

730
00:36:18,210 --> 00:36:21,869
you do with two-factor authentication so

731
00:36:20,220 --> 00:36:24,390
it's it's hard or impossible to

732
00:36:21,869 --> 00:36:26,790
integrate and it was only me des means

733
00:36:24,390 --> 00:36:28,950
as it means as a stopgap solution for

734
00:36:26,790 --> 00:36:34,349
migrating to Worf and it's a really long

735
00:36:28,950 --> 00:36:37,558
grant name even for German so what else

736
00:36:34,349 --> 00:36:39,720
this was last one we have a number of

737
00:36:37,559 --> 00:36:43,740
smaller recommendations do not use the

738
00:36:39,720 --> 00:36:45,509
HP 307 redirect prevent code leakage and

739
00:36:43,740 --> 00:36:48,209
referral from referrer headers and other

740
00:36:45,510 --> 00:36:51,510
sources use client authentication as

741
00:36:48,210 --> 00:36:53,250
possible and and some others so i if

742
00:36:51,510 --> 00:36:54,750
you're using oauth i advise that you

743
00:36:53,250 --> 00:36:57,299
look into that document it's a draft

744
00:36:54,750 --> 00:36:59,700
right now but it's already quite quite

745
00:36:57,299 --> 00:37:05,190
complete I think and yeah it's it's

746
00:36:59,700 --> 00:37:07,799
maybe 90 percent 95 percent bad to sum

747
00:37:05,190 --> 00:37:09,960
up we have seen that all implementations

748
00:37:07,799 --> 00:37:14,400
of binary we have seen that in practice

749
00:37:09,960 --> 00:37:15,720
and in research the earth protocol

750
00:37:14,400 --> 00:37:17,160
definitely needs an update regarding

751
00:37:15,720 --> 00:37:19,500
security guidance

752
00:37:17,160 --> 00:37:22,348
protect against new attacks to protect

753
00:37:19,500 --> 00:37:25,289
it in high-stakes environments and to

754
00:37:22,349 --> 00:37:28,770
adapted to the evolving web environment

755
00:37:25,289 --> 00:37:32,069
itself we have seen that formal analysis

756
00:37:28,770 --> 00:37:33,809
can be helpful although it's not widely

757
00:37:32,069 --> 00:37:36,808
used right now but it can be very

758
00:37:33,809 --> 00:37:40,710
helpful especially in standardization to

759
00:37:36,809 --> 00:37:44,910
find attacks test solutions against also

760
00:37:40,710 --> 00:37:47,339
to find regressions potentially and all

761
00:37:44,910 --> 00:37:49,500
of this ended up in the new ITF or

762
00:37:47,339 --> 00:37:52,078
security BCP which addresses new and old

763
00:37:49,500 --> 00:37:55,710
security vulnerabilities and provides

764
00:37:52,079 --> 00:37:57,299
actionable solutions so that was my talk

765
00:37:55,710 --> 00:37:59,460
if you're interested come talk to me

766
00:37:57,299 --> 00:38:02,069
about details of the attacks and the

767
00:37:59,460 --> 00:38:04,020
mitigations the formal analysis of

768
00:38:02,069 --> 00:38:05,930
course if you're interested to join us

769
00:38:04,020 --> 00:38:08,250
at the earth security workshop we're not

770
00:38:05,930 --> 00:38:10,828
we don't have a date yet for the next

771
00:38:08,250 --> 00:38:12,390
year but we will soon and of course we

772
00:38:10,829 --> 00:38:13,380
are looking for developers with a

773
00:38:12,390 --> 00:38:16,109
security background

774
00:38:13,380 --> 00:38:23,400
eds calm thank you

775
00:38:16,110 --> 00:38:26,410
[Applause]

776
00:38:23,400 --> 00:38:28,240
okay how does a high-stake environment

777
00:38:26,410 --> 00:38:30,220
change the threat model of OAuth on

778
00:38:28,240 --> 00:38:34,899
other words why is the current

779
00:38:30,220 --> 00:38:37,299
implementation not sufficient let's

780
00:38:34,900 --> 00:38:39,119
let's go back I really don't have to say

781
00:38:37,300 --> 00:38:45,730
okay that's fine

782
00:38:39,119 --> 00:38:49,050
so in the okay so in the high-stakes

783
00:38:45,730 --> 00:38:52,810
environments we have a problem and

784
00:38:49,050 --> 00:38:55,930
because we don't have a problem in percy

785
00:38:52,810 --> 00:38:58,750
but we have a new situation where for

786
00:38:55,930 --> 00:39:02,799
example we have to assume that some

787
00:38:58,750 --> 00:39:06,760
resource servers might become

788
00:39:02,800 --> 00:39:10,930
compromised so this might be a bank but

789
00:39:06,760 --> 00:39:13,390
this resource server might be one branch

790
00:39:10,930 --> 00:39:16,328
of the bank or something like that so it

791
00:39:13,390 --> 00:39:19,210
might be loosely coupled to the bank but

792
00:39:16,329 --> 00:39:22,329
still if that resource server is

793
00:39:19,210 --> 00:39:24,130
compromised it should not be able to use

794
00:39:22,329 --> 00:39:26,170
the same access token at a different

795
00:39:24,130 --> 00:39:27,849
resource or at the same bank with the

796
00:39:26,170 --> 00:39:30,390
old world security model that would be

797
00:39:27,849 --> 00:39:32,890
possible because we don't have the

798
00:39:30,390 --> 00:39:34,868
receiver / sender constraining of the

799
00:39:32,890 --> 00:39:38,170
access tokens let's for example a driver

800
00:39:34,869 --> 00:39:39,880
for the security advice on the sender

801
00:39:38,170 --> 00:39:41,890
and receiver constraining of the access

802
00:39:39,880 --> 00:39:45,160
tokens we have similar situations like

803
00:39:41,890 --> 00:39:47,710
this also for example regarding TLS

804
00:39:45,160 --> 00:39:49,540
connections again and banks that have to

805
00:39:47,710 --> 00:39:51,160
be broken up or something like that so

806
00:39:49,540 --> 00:39:54,640
you need to provide an additional layer

807
00:39:51,160 --> 00:40:02,680
of security service at different points

808
00:39:54,640 --> 00:40:05,170
in protocol one more okay okay that's a

809
00:40:02,680 --> 00:40:06,578
good one how complex is the web

810
00:40:05,170 --> 00:40:09,280
infrastructure model for the formal

811
00:40:06,579 --> 00:40:11,140
analysis even same origin policy is

812
00:40:09,280 --> 00:40:14,520
nowhere specified and has a lot of

813
00:40:11,140 --> 00:40:16,930
quirks and corner cases this is exactly

814
00:40:14,520 --> 00:40:22,650
why it's complicated to build a web

815
00:40:16,930 --> 00:40:26,140
model but it's also very interesting so

816
00:40:22,650 --> 00:40:31,900
the model is very complex to answer the

817
00:40:26,140 --> 00:40:34,400
first question it's it fits on I think

818
00:40:31,900 --> 00:40:37,580
so it takes like 40 pages in my

819
00:40:34,400 --> 00:40:40,400
feels plus a lot of explanation and it's

820
00:40:37,580 --> 00:40:41,900
nothing you can just take and build

821
00:40:40,400 --> 00:40:44,600
something on top of that because it's

822
00:40:41,900 --> 00:40:46,130
currently it's too complicated and

823
00:40:44,600 --> 00:40:48,470
that's also what makes it too

824
00:40:46,130 --> 00:40:52,370
complicated to build to put this into

825
00:40:48,470 --> 00:40:54,020
some tool but we're working on it so I'm

826
00:40:52,370 --> 00:41:01,370
not working about my former colleagues

827
00:40:54,020 --> 00:41:02,600
are working on it you have even so even

828
00:41:01,370 --> 00:41:05,480
if you don't look at all the corner

829
00:41:02,600 --> 00:41:08,120
cases you have a lot of complexity you

830
00:41:05,480 --> 00:41:13,040
need to read like a few hundred or maybe

831
00:41:08,120 --> 00:41:15,890
a thousand pages of specifications like

832
00:41:13,040 --> 00:41:17,420
html5 and many many other things and

833
00:41:15,890 --> 00:41:20,089
some of these are not documented

834
00:41:17,420 --> 00:41:22,430
anywhere some of these you just have to

835
00:41:20,090 --> 00:41:25,750
test in some web browser the good thing

836
00:41:22,430 --> 00:41:28,129
is in a model you can you can really

837
00:41:25,750 --> 00:41:29,720
take into account different behaviors

838
00:41:28,130 --> 00:41:32,570
you can just say okay I'm not sure

839
00:41:29,720 --> 00:41:35,660
what's happening here in this case let's

840
00:41:32,570 --> 00:41:35,990
just say anything happens or within some

841
00:41:35,660 --> 00:41:37,910
limits

842
00:41:35,990 --> 00:41:40,790
anything happens now you can actually

843
00:41:37,910 --> 00:41:45,049
work with that in a model so it's not a

844
00:41:40,790 --> 00:41:47,660
software product in this in a sense but

845
00:41:45,050 --> 00:41:49,880
yeah it's very complex and some things

846
00:41:47,660 --> 00:41:51,980
like same origin policy Cora cases you

847
00:41:49,880 --> 00:41:53,810
just have to test or you just have to

848
00:41:51,980 --> 00:41:55,400
assume the worst and this in a model

849
00:41:53,810 --> 00:41:59,600
like this you can also sometimes just

850
00:41:55,400 --> 00:42:01,670
assume that no security exists so assume

851
00:41:59,600 --> 00:42:04,029
the worst and then see where leads you

852
00:42:01,670 --> 00:42:04,030
from there

