1
00:00:00,000 --> 00:00:02,960
hi everyone thank you

2
00:00:03,360 --> 00:00:05,440
it's fantastic to see this security card

3
00:00:05,440 --> 00:00:07,600
turning into two days and so many people

4
00:00:07,600 --> 00:00:10,000
i'm really really pleased for this event

5
00:00:10,000 --> 00:00:12,559
so yes my name is liz rice i am chief

6
00:00:12,559 --> 00:00:15,599
open source officer at iso valence

7
00:00:15,599 --> 00:00:18,000
and i was until recently chair of the

8
00:00:18,000 --> 00:00:20,640
cncf's technical oversight committee

9
00:00:20,640 --> 00:00:23,279
some of you may have come across a book

10
00:00:23,279 --> 00:00:26,560
that i wrote about container security um

11
00:00:26,560 --> 00:00:29,439
i've just recently written a new report

12
00:00:29,439 --> 00:00:31,279
about ebpf

13
00:00:31,279 --> 00:00:33,360
hopefully we will be giving away copies

14
00:00:33,360 --> 00:00:35,280
later this week

15
00:00:35,280 --> 00:00:37,200
apparently they have been released from

16
00:00:37,200 --> 00:00:39,760
customs and are on their way here now i

17
00:00:39,760 --> 00:00:40,719
hope

18
00:00:40,719 --> 00:00:41,600
so

19
00:00:41,600 --> 00:00:43,840
if you want to hear more about or learn

20
00:00:43,840 --> 00:00:46,000
more about what ebpf is i hope that book

21
00:00:46,000 --> 00:00:48,480
will be as useful to you as i know some

22
00:00:48,480 --> 00:00:50,079
of you have said the container security

23
00:00:50,079 --> 00:00:52,079
book was

24
00:00:52,079 --> 00:00:54,719
so today i want to talk about how we can

25
00:00:54,719 --> 00:00:56,879
use evpf for

26
00:00:56,879 --> 00:00:59,120
runtime security

27
00:00:59,120 --> 00:01:00,879
and how many of you were here for the

28
00:01:00,879 --> 00:01:04,080
loxi talk just a couple of talks ago

29
00:01:04,080 --> 00:01:07,119
okay so some of what was discussed there

30
00:01:07,119 --> 00:01:09,920
we'll dive a little bit in more detail

31
00:01:09,920 --> 00:01:11,600
in this talk

32
00:01:11,600 --> 00:01:13,520
i'm going to show you some different

33
00:01:13,520 --> 00:01:15,200
uses of ebpf

34
00:01:15,200 --> 00:01:17,600
and a new tool that we've

35
00:01:17,600 --> 00:01:21,199
added to the psyllium family

36
00:01:21,360 --> 00:01:22,640
a lot of

37
00:01:22,640 --> 00:01:24,799
the discussions i think at security.com

38
00:01:24,799 --> 00:01:27,200
there's been lots of things about

39
00:01:27,200 --> 00:01:30,799
supply chain and dependency management

40
00:01:30,799 --> 00:01:33,200
things that happen before you deploy

41
00:01:33,200 --> 00:01:34,000
your

42
00:01:34,000 --> 00:01:35,439
workloads

43
00:01:35,439 --> 00:01:37,840
what i'm talking about now is the real

44
00:01:37,840 --> 00:01:40,799
time detection and prevention of

45
00:01:40,799 --> 00:01:43,759
malicious activity while your workload's

46
00:01:43,759 --> 00:01:45,200
running

47
00:01:45,200 --> 00:01:46,320
so

48
00:01:46,320 --> 00:01:48,399
we need a way of detecting when

49
00:01:48,399 --> 00:01:50,880
something that looks suspicious

50
00:01:50,880 --> 00:01:53,840
is happening in real

51
00:01:53,840 --> 00:01:55,360
at a minimum we need to be able to

52
00:01:55,360 --> 00:01:57,439
report that perhaps that's going to

53
00:01:57,439 --> 00:01:59,600
generate alerts or it's going to go into

54
00:01:59,600 --> 00:02:02,079
a sim or some kind of

55
00:02:02,079 --> 00:02:04,000
notification that something suspicious

56
00:02:04,000 --> 00:02:06,159
or malicious has happened

57
00:02:06,159 --> 00:02:09,199
but even better if we can actually spot

58
00:02:09,199 --> 00:02:11,440
when something suspicious is about to

59
00:02:11,440 --> 00:02:15,680
happen and we can prevent it

60
00:02:16,640 --> 00:02:19,520
the kind of activity we're talking about

61
00:02:19,520 --> 00:02:22,000
i think falls largely into four main

62
00:02:22,000 --> 00:02:23,920
categories

63
00:02:23,920 --> 00:02:26,319
we want to make sure that if

64
00:02:26,319 --> 00:02:28,480
there's network traffic to a suspicious

65
00:02:28,480 --> 00:02:32,400
destination or from a suspicious address

66
00:02:32,400 --> 00:02:35,120
that we spot that

67
00:02:35,120 --> 00:02:37,040
access to files we want to make sure

68
00:02:37,040 --> 00:02:39,760
that workloads are only accessing files

69
00:02:39,760 --> 00:02:42,560
that we expect them to access

70
00:02:42,560 --> 00:02:43,360
we

71
00:02:43,360 --> 00:02:45,440
only expect our workloads to run a

72
00:02:45,440 --> 00:02:48,239
certain set of executables

73
00:02:48,239 --> 00:02:51,519
i often use the example that if my nginx

74
00:02:51,519 --> 00:02:52,800
pod suddenly starts running a

75
00:02:52,800 --> 00:02:54,959
cryptocurrency minor executable that's

76
00:02:54,959 --> 00:02:57,360
probably not what it was supposed to be

77
00:02:57,360 --> 00:03:00,720
doing so we can particularly in a

78
00:03:00,720 --> 00:03:03,120
microservices environment in a cloud

79
00:03:03,120 --> 00:03:04,400
native environment

80
00:03:04,400 --> 00:03:06,879
we can often reason about what

81
00:03:06,879 --> 00:03:09,280
executables we expect to be running and

82
00:03:09,280 --> 00:03:11,680
what file activity and network activity

83
00:03:11,680 --> 00:03:14,000
we expect

84
00:03:14,000 --> 00:03:16,959
and also we're interested when

85
00:03:16,959 --> 00:03:18,800
an executable

86
00:03:18,800 --> 00:03:20,959
appears to have or

87
00:03:20,959 --> 00:03:23,440
a process appears to have more

88
00:03:23,440 --> 00:03:25,040
privileges or appears to be trying to

89
00:03:25,040 --> 00:03:27,840
gain more privileges than we expected

90
00:03:27,840 --> 00:03:29,599
that's often uh

91
00:03:29,599 --> 00:03:31,360
the

92
00:03:31,360 --> 00:03:33,360
the the way that an exploit of

93
00:03:33,360 --> 00:03:35,599
vulnerability uh

94
00:03:35,599 --> 00:03:37,680
kind of takes hold is by escalating

95
00:03:37,680 --> 00:03:39,920
privileges

96
00:03:39,920 --> 00:03:40,799
now

97
00:03:40,799 --> 00:03:43,280
all of these different types of activity

98
00:03:43,280 --> 00:03:46,720
require support from the kernel so just

99
00:03:46,720 --> 00:03:48,319
to make sure that we're completely on

100
00:03:48,319 --> 00:03:50,080
the same page about user space and

101
00:03:50,080 --> 00:03:51,200
kernel

102
00:03:51,200 --> 00:03:55,040
we write application code in user space

103
00:03:55,040 --> 00:03:58,000
but whenever we want to do anything

104
00:03:58,000 --> 00:04:00,319
interesting really certainly anything

105
00:04:00,319 --> 00:04:02,799
that involves any hardware we have to

106
00:04:02,799 --> 00:04:05,519
ask the kernel to do that on our behalf

107
00:04:05,519 --> 00:04:07,840
and we do that through the system call

108
00:04:07,840 --> 00:04:09,040
interface

109
00:04:09,040 --> 00:04:10,640
so those four categories of things that

110
00:04:10,640 --> 00:04:13,040
i was talking about the file access the

111
00:04:13,040 --> 00:04:14,640
network access

112
00:04:14,640 --> 00:04:16,478
even memory access

113
00:04:16,478 --> 00:04:19,600
and processes and privileges

114
00:04:19,600 --> 00:04:21,120
they're all

115
00:04:21,120 --> 00:04:23,759
accessed via system calls so whenever

116
00:04:23,759 --> 00:04:25,600
we're doing any of those activities in

117
00:04:25,600 --> 00:04:26,960
an application

118
00:04:26,960 --> 00:04:31,198
the colonel will be involved

119
00:04:32,000 --> 00:04:34,639
so if we want to spot those

120
00:04:34,639 --> 00:04:37,280
potentially suspicious activities

121
00:04:37,280 --> 00:04:39,440
if we can look at

122
00:04:39,440 --> 00:04:42,720
how the kernels behaving then

123
00:04:42,720 --> 00:04:44,720
that that could be a mechanism we can

124
00:04:44,720 --> 00:04:46,960
use to spot

125
00:04:46,960 --> 00:04:49,199
potentially malicious activity

126
00:04:49,199 --> 00:04:51,040
and we've had

127
00:04:51,040 --> 00:04:53,440
several mechanisms for doing this over

128
00:04:53,440 --> 00:04:55,120
the years

129
00:04:55,120 --> 00:04:56,960
and many of these are available in open

130
00:04:56,960 --> 00:05:00,160
source or proprietary tools today

131
00:05:00,160 --> 00:05:02,160
um i'm gonna just run through these

132
00:05:02,160 --> 00:05:04,880
pretty quickly but um ld preload is

133
00:05:04,880 --> 00:05:07,199
anybody here familiar with ld preload

134
00:05:07,199 --> 00:05:09,039
i'm guessing so it's quite often used

135
00:05:09,039 --> 00:05:12,960
for kind of red team work i think

136
00:05:12,960 --> 00:05:14,960
ptrace i'm sure a lot of you have used

137
00:05:14,960 --> 00:05:17,280
ptrace setcomp i'm sure you've all come

138
00:05:17,280 --> 00:05:18,320
across

139
00:05:18,320 --> 00:05:20,479
and then finally we will turn to some

140
00:05:20,479 --> 00:05:24,160
things we can do with evps

141
00:05:24,160 --> 00:05:27,199
ld preload

142
00:05:27,199 --> 00:05:29,280
assumes that your application is using

143
00:05:29,280 --> 00:05:32,000
the standard c library to make those

144
00:05:32,000 --> 00:05:34,240
system calls so whenever you're going to

145
00:05:34,240 --> 00:05:36,080
do those

146
00:05:36,080 --> 00:05:37,919
operations that require support from the

147
00:05:37,919 --> 00:05:40,960
kernel you'll actually do that by making

148
00:05:40,960 --> 00:05:41,919
a

149
00:05:41,919 --> 00:05:45,039
call via the standard c library

150
00:05:45,039 --> 00:05:47,520
which gives you an abstraction

151
00:05:47,520 --> 00:05:49,440
for those system calls

152
00:05:49,440 --> 00:05:51,520
and with ld preload

153
00:05:51,520 --> 00:05:54,720
because that library is typically

154
00:05:54,720 --> 00:05:56,639
dynamically linked

155
00:05:56,639 --> 00:05:57,600
we

156
00:05:57,600 --> 00:06:00,639
replace the standard one with an

157
00:06:00,639 --> 00:06:02,240
alternative one which might just be a

158
00:06:02,240 --> 00:06:04,240
thin shim layer that does some detection

159
00:06:04,240 --> 00:06:05,120
and then

160
00:06:05,120 --> 00:06:06,720
passes through to the

161
00:06:06,720 --> 00:06:10,319
the normal standard c library

162
00:06:10,319 --> 00:06:13,759
and that's all well and good except for

163
00:06:13,759 --> 00:06:15,919
if you're using statically linked

164
00:06:15,919 --> 00:06:18,240
applications for example if you're using

165
00:06:18,240 --> 00:06:19,840
go applications they don't use the

166
00:06:19,840 --> 00:06:22,000
standard c library they have their own

167
00:06:22,000 --> 00:06:25,280
statically linked interface to syscalls

168
00:06:25,280 --> 00:06:27,600
so ld preload is a perfectly valid way

169
00:06:27,600 --> 00:06:29,520
of trying to intercept what the user

170
00:06:29,520 --> 00:06:30,479
space

171
00:06:30,479 --> 00:06:32,960
application is asking your kernel to do

172
00:06:32,960 --> 00:06:35,440
but it can be pretty easily bypassed

173
00:06:35,440 --> 00:06:37,600
especially these days with lots of go

174
00:06:37,600 --> 00:06:40,319
applications

175
00:06:40,479 --> 00:06:43,360
so then we get to the category of tools

176
00:06:43,360 --> 00:06:44,880
that

177
00:06:44,880 --> 00:06:46,319
hook into

178
00:06:46,319 --> 00:06:49,280
the top layer if you like of a cisco

179
00:06:49,280 --> 00:06:52,000
being processed within the kernel

180
00:06:52,000 --> 00:06:55,599
and p trace setcomp

181
00:06:55,599 --> 00:06:56,560
and

182
00:06:56,560 --> 00:06:57,840
ebpf

183
00:06:57,840 --> 00:07:00,880
k pro what's called a k probe um that

184
00:07:00,880 --> 00:07:03,440
hook into this sort of initial

185
00:07:03,440 --> 00:07:06,639
processing of a system call

186
00:07:06,639 --> 00:07:09,120
and they all have the same

187
00:07:09,120 --> 00:07:10,560
problem that's actually been well

188
00:07:10,560 --> 00:07:12,400
understood in the kernel community for a

189
00:07:12,400 --> 00:07:15,120
very long time and it's turned out to be

190
00:07:15,120 --> 00:07:17,520
uh you know it's the kernel working as

191
00:07:17,520 --> 00:07:19,120
designed

192
00:07:19,120 --> 00:07:20,479
if you

193
00:07:20,479 --> 00:07:22,960
look at the system core parameters when

194
00:07:22,960 --> 00:07:24,800
they're very first passed into the

195
00:07:24,800 --> 00:07:26,160
kernel

196
00:07:26,160 --> 00:07:28,400
the colonel has oops the kernel hasn't

197
00:07:28,400 --> 00:07:31,039
had a chance to inspect those yet oh

198
00:07:31,039 --> 00:07:32,080
i've just remembered i was supposed to

199
00:07:32,080 --> 00:07:34,639
be doing a demo before i go into this

200
00:07:34,639 --> 00:07:37,120
thing so let's let's just do detecting a

201
00:07:37,120 --> 00:07:40,240
system call with ebpf

202
00:07:40,240 --> 00:07:41,280
so

203
00:07:41,280 --> 00:07:45,280
this is a very very simple the simplest

204
00:07:45,280 --> 00:07:46,400
of

205
00:07:46,400 --> 00:07:47,680
um

206
00:07:47,680 --> 00:07:49,840
ebpf programs this is going to run in

207
00:07:49,840 --> 00:07:51,759
the kernel

208
00:07:51,759 --> 00:07:53,680
and i'm going to attach this to the

209
00:07:53,680 --> 00:07:56,160
system call for

210
00:07:56,160 --> 00:07:59,599
changing the permissions mode of a file

211
00:07:59,599 --> 00:08:02,400
i'm using a k probe k-pro is kernel

212
00:08:02,400 --> 00:08:05,199
probe it's attaching to the entry point

213
00:08:05,199 --> 00:08:08,000
of this function

214
00:08:08,479 --> 00:08:10,479
and i also have some user space code

215
00:08:10,479 --> 00:08:12,560
that loads this function that's not

216
00:08:12,560 --> 00:08:15,520
really that important for this demo so

217
00:08:15,520 --> 00:08:16,800
let me just

218
00:08:16,800 --> 00:08:18,720
make

219
00:08:18,720 --> 00:08:19,759
make this

220
00:08:19,759 --> 00:08:23,199
tool let's make this little tool

221
00:08:23,199 --> 00:08:24,160
okay

222
00:08:24,160 --> 00:08:25,280
this

223
00:08:25,280 --> 00:08:27,120
tracing that it's going to generate is

224
00:08:27,120 --> 00:08:30,720
going to go into a kernel trace file

225
00:08:30,720 --> 00:08:32,320
that i'm going to just start piping the

226
00:08:32,320 --> 00:08:34,799
output from

227
00:08:34,799 --> 00:08:36,799
and i'm going to run my

228
00:08:36,799 --> 00:08:38,399
little

229
00:08:38,399 --> 00:08:42,240
oops i have to be root to do this

230
00:08:46,160 --> 00:08:49,120
hopefully i can type

231
00:08:49,120 --> 00:08:51,120
okay so that's running

232
00:08:51,120 --> 00:08:52,959
if i uh

233
00:08:52,959 --> 00:08:55,200
look at the bpf

234
00:08:55,200 --> 00:08:57,600
programs that have been loaded into this

235
00:08:57,600 --> 00:09:00,560
virtual machine we can see one here it's

236
00:09:00,560 --> 00:09:02,880
a k probe called hello that's my

237
00:09:02,880 --> 00:09:05,279
application successfully loaded into the

238
00:09:05,279 --> 00:09:07,040
kernel

239
00:09:07,040 --> 00:09:10,720
and now if i try to change the mode of a

240
00:09:10,720 --> 00:09:12,480
file

241
00:09:12,480 --> 00:09:14,959
we'll see some trace generated it's a

242
00:09:14,959 --> 00:09:17,279
very very simple trigger to detect that

243
00:09:17,279 --> 00:09:20,560
that system call has been triggered

244
00:09:21,440 --> 00:09:23,120
so

245
00:09:23,120 --> 00:09:24,720
that

246
00:09:24,720 --> 00:09:26,320
ebpf program

247
00:09:26,320 --> 00:09:28,800
was triggered at the entry point to that

248
00:09:28,800 --> 00:09:30,000
system call

249
00:09:30,000 --> 00:09:32,080
and it suffers from

250
00:09:32,080 --> 00:09:34,000
a well-known time of check to time of

251
00:09:34,000 --> 00:09:36,720
use issue that affects all of these

252
00:09:36,720 --> 00:09:39,760
tools that hook into that sort of first

253
00:09:39,760 --> 00:09:41,680
point where you start processing system

254
00:09:41,680 --> 00:09:43,279
calls

255
00:09:43,279 --> 00:09:45,680
this was very well explained by leo di

256
00:09:45,680 --> 00:09:48,320
donato and kp singh

257
00:09:48,320 --> 00:09:51,920
at cloud native ebpf day last year

258
00:09:51,920 --> 00:09:55,040
and the exploits that um or a

259
00:09:55,040 --> 00:09:57,440
demonstration of exploiting this was

260
00:09:57,440 --> 00:10:00,080
shown at defcon 29 last year it's called

261
00:10:00,080 --> 00:10:02,000
phantom attacks

262
00:10:02,000 --> 00:10:04,800
and it can affect all of these

263
00:10:04,800 --> 00:10:05,839
tools

264
00:10:05,839 --> 00:10:08,480
that inspect parameters

265
00:10:08,480 --> 00:10:11,360
before they've been copied into

266
00:10:11,360 --> 00:10:12,640
kernel

267
00:10:12,640 --> 00:10:15,360
into kernel data structures

268
00:10:15,360 --> 00:10:17,200
what we need to do to avoid being

269
00:10:17,200 --> 00:10:19,120
vulnerable to this time of check time of

270
00:10:19,120 --> 00:10:22,959
use issue is we need to

271
00:10:22,959 --> 00:10:25,760
look at the parameters to assist call

272
00:10:25,760 --> 00:10:27,600
after they've been copied into kernel

273
00:10:27,600 --> 00:10:29,760
memory so there's no possibility that

274
00:10:29,760 --> 00:10:32,240
the parameter has been changed before it

275
00:10:32,240 --> 00:10:35,680
gets copied into the kernel

276
00:10:36,320 --> 00:10:39,279
and there is a well-known way to do this

277
00:10:39,279 --> 00:10:41,920
it's called linux security modules

278
00:10:41,920 --> 00:10:43,600
so the lsm

279
00:10:43,600 --> 00:10:46,560
api is a stable interface within the

280
00:10:46,560 --> 00:10:47,519
kernel

281
00:10:47,519 --> 00:10:49,040
that gives

282
00:10:49,040 --> 00:10:51,360
dozens of function call

283
00:10:51,360 --> 00:10:52,640
hooks

284
00:10:52,640 --> 00:10:54,320
where

285
00:10:54,320 --> 00:10:56,560
relevant information has already been

286
00:10:56,560 --> 00:10:58,880
copied into kernel data structures

287
00:10:58,880 --> 00:11:01,519
essentially all of these

288
00:11:01,519 --> 00:11:03,680
function calls on this api

289
00:11:03,680 --> 00:11:05,760
are the kernel saying here you are

290
00:11:05,760 --> 00:11:07,839
here's a data structure perhaps that

291
00:11:07,839 --> 00:11:11,200
describes a file or describes a socket

292
00:11:11,200 --> 00:11:13,519
here it is this is what i'm about to act

293
00:11:13,519 --> 00:11:14,959
on

294
00:11:14,959 --> 00:11:17,120
do you have an opinion on that is this

295
00:11:17,120 --> 00:11:19,519
malicious in some way are you okay with

296
00:11:19,519 --> 00:11:23,279
me to go ahead and do this operation

297
00:11:23,279 --> 00:11:24,320
so

298
00:11:24,320 --> 00:11:26,720
linux security module

299
00:11:26,720 --> 00:11:28,800
function calls are a safe place that

300
00:11:28,800 --> 00:11:30,480
don't suffer from this time of check's

301
00:11:30,480 --> 00:11:33,839
time of use issue

302
00:11:34,720 --> 00:11:35,440
with

303
00:11:35,440 --> 00:11:38,880
bpf lsm that you heard referred to with

304
00:11:38,880 --> 00:11:40,880
in the loxi talk

305
00:11:40,880 --> 00:11:43,440
we don't have to use a kernel module

306
00:11:43,440 --> 00:11:44,800
we can

307
00:11:44,800 --> 00:11:47,360
use ebpf programs

308
00:11:47,360 --> 00:11:51,040
hooked onto those lsm function calls

309
00:11:51,040 --> 00:11:54,000
so we're using that stable interface

310
00:11:54,000 --> 00:11:55,279
we've got these

311
00:11:55,279 --> 00:11:56,800
kernel data structures that we can

312
00:11:56,800 --> 00:11:59,360
inspect we can run

313
00:11:59,360 --> 00:12:01,760
dynamic programs we can load them into

314
00:12:01,760 --> 00:12:03,360
the kernel as we

315
00:12:03,360 --> 00:12:05,279
choose

316
00:12:05,279 --> 00:12:08,399
to do our checks on

317
00:12:08,399 --> 00:12:10,560
whether or not we think that activity

318
00:12:10,560 --> 00:12:13,120
looks suspicious in some way

319
00:12:13,120 --> 00:12:14,320
the other thing that's very cool if

320
00:12:14,320 --> 00:12:17,200
we're doing this with ebpf is

321
00:12:17,200 --> 00:12:19,920
it protects any process it doesn't

322
00:12:19,920 --> 00:12:21,760
matter whether the process was already

323
00:12:21,760 --> 00:12:24,560
running when you load the ebpf program

324
00:12:24,560 --> 00:12:26,720
it has visibility into everything that's

325
00:12:26,720 --> 00:12:29,120
running on that virtual machine

326
00:12:29,120 --> 00:12:29,839
so

327
00:12:29,839 --> 00:12:31,920
we can protect against malicious

328
00:12:31,920 --> 00:12:36,319
behavior in pre-existing processes

329
00:12:36,639 --> 00:12:39,680
so let's have a look at an ebpf program

330
00:12:39,680 --> 00:12:42,320
again a very simple ebpf program that

331
00:12:42,320 --> 00:12:44,880
uses an lsm hook

332
00:12:44,880 --> 00:12:46,720
and i've actually got it in here

333
00:12:46,720 --> 00:12:49,200
already commented out

334
00:12:49,200 --> 00:12:50,839
i'll just uncomment

335
00:12:50,839 --> 00:12:52,959
that and

336
00:12:52,959 --> 00:12:55,600
it's extremely similar to what i showed

337
00:12:55,600 --> 00:12:59,279
you before with the k-probe

338
00:12:59,360 --> 00:13:01,920
ebpf program

339
00:13:01,920 --> 00:13:04,160
again all i'm doing here is i'm just

340
00:13:04,160 --> 00:13:07,200
going to trace out some a message

341
00:13:07,200 --> 00:13:10,800
but in this particular example for

342
00:13:10,800 --> 00:13:13,120
path to mod which is a function on that

343
00:13:13,120 --> 00:13:14,720
lsm

344
00:13:14,720 --> 00:13:15,920
interface

345
00:13:15,920 --> 00:13:17,200
i get this

346
00:13:17,200 --> 00:13:19,040
path structure

347
00:13:19,040 --> 00:13:20,720
let's just compare that to the the

348
00:13:20,720 --> 00:13:23,279
system call before where we just had a

349
00:13:23,279 --> 00:13:26,160
void pointer to a context structure

350
00:13:26,160 --> 00:13:28,480
here we have a data structure that

351
00:13:28,480 --> 00:13:30,079
contains

352
00:13:30,079 --> 00:13:32,560
the kernel's pre-populated information

353
00:13:32,560 --> 00:13:34,720
about the file that i want to change the

354
00:13:34,720 --> 00:13:36,560
permissions on

355
00:13:36,560 --> 00:13:37,839
and i can

356
00:13:37,839 --> 00:13:40,320
it makes it very easy for me to find the

357
00:13:40,320 --> 00:13:44,880
name of that file so let me just

358
00:13:44,880 --> 00:13:47,519
build this again

359
00:13:47,519 --> 00:13:48,639
and

360
00:13:48,639 --> 00:13:51,120
this time i've got

361
00:13:51,120 --> 00:13:54,639
i didn't save it did i did i

362
00:13:54,720 --> 00:13:58,160
let me just remove that

363
00:13:58,160 --> 00:13:59,760
i'm not confident whether that actually

364
00:13:59,760 --> 00:14:00,959
did the right thing so i'm just going to

365
00:14:00,959 --> 00:14:03,600
rebuild it

366
00:14:03,600 --> 00:14:05,600
okay

367
00:14:05,600 --> 00:14:07,040
so

368
00:14:07,040 --> 00:14:10,399
let's go back bring up back the tracing

369
00:14:10,399 --> 00:14:12,399
both my

370
00:14:12,399 --> 00:14:14,560
ebpf programs will be loaded this time

371
00:14:14,560 --> 00:14:18,560
so let's run the application

372
00:14:18,560 --> 00:14:20,399
let's check the

373
00:14:20,399 --> 00:14:22,160
programs that have been loaded and yeah

374
00:14:22,160 --> 00:14:23,839
this time we've got

375
00:14:23,839 --> 00:14:26,560
the k probe called hello and we've got

376
00:14:26,560 --> 00:14:28,000
an lsm

377
00:14:28,000 --> 00:14:31,199
hook called path to mod

378
00:14:31,199 --> 00:14:32,000
so

379
00:14:32,000 --> 00:14:34,800
this time if i trace

380
00:14:34,800 --> 00:14:36,720
where i change the mode we get two

381
00:14:36,720 --> 00:14:38,160
traces

382
00:14:38,160 --> 00:14:39,920
one for each entry point and we can see

383
00:14:39,920 --> 00:14:42,320
the name of the file that i

384
00:14:42,320 --> 00:14:45,839
was operating on

385
00:14:47,120 --> 00:14:50,880
so that interface is super useful it's

386
00:14:50,880 --> 00:14:52,959
stable it doesn't suffer from any kind

387
00:14:52,959 --> 00:14:55,600
of known vulnerabilities

388
00:14:55,600 --> 00:14:56,399
but

389
00:14:56,399 --> 00:14:58,320
it needs a modern kernel it was only

390
00:14:58,320 --> 00:15:01,199
introduced into 5.7

391
00:15:01,199 --> 00:15:03,120
so unless you're running with that

392
00:15:03,120 --> 00:15:05,279
kernel or newer you don't really have

393
00:15:05,279 --> 00:15:09,839
the option to use ebpf against

394
00:15:09,839 --> 00:15:13,279
that lsm interface

395
00:15:13,279 --> 00:15:14,800
so

396
00:15:14,800 --> 00:15:16,959
do we have an alternative well yeah we

397
00:15:16,959 --> 00:15:17,760
do

398
00:15:17,760 --> 00:15:21,440
just because that is a declared staple

399
00:15:21,440 --> 00:15:23,360
interface doesn't mean to say there

400
00:15:23,360 --> 00:15:25,279
aren't plenty of other

401
00:15:25,279 --> 00:15:27,519
function calls in the kernel that

402
00:15:27,519 --> 00:15:30,399
haven't changed for quite a long time

403
00:15:30,399 --> 00:15:33,120
with ebpf we can hook into anywhere in

404
00:15:33,120 --> 00:15:34,800
the kernel

405
00:15:34,800 --> 00:15:36,000
so

406
00:15:36,000 --> 00:15:38,839
what if we were to pick

407
00:15:38,839 --> 00:15:40,800
other

408
00:15:40,800 --> 00:15:43,279
stable not by sort of declared this is

409
00:15:43,279 --> 00:15:44,959
never going to change but stable in the

410
00:15:44,959 --> 00:15:46,399
sense that they haven't changed for a

411
00:15:46,399 --> 00:15:49,680
long time there's no expected reason why

412
00:15:49,680 --> 00:15:52,240
these uh functions would change

413
00:15:52,240 --> 00:15:55,600
and hook ebpf programs into those and

414
00:15:55,600 --> 00:15:58,240
that's what we're doing with a new

415
00:15:58,240 --> 00:15:59,440
project that we've added into the

416
00:15:59,440 --> 00:16:03,199
psyllium family called tetragon

417
00:16:03,440 --> 00:16:05,440
tetragon is actually

418
00:16:05,440 --> 00:16:07,759
the open sourcing of something that as

419
00:16:07,759 --> 00:16:10,399
isovalent we've been including as part

420
00:16:10,399 --> 00:16:12,000
of our commercial offering for quite a

421
00:16:12,000 --> 00:16:14,160
while so we're open sourcing something

422
00:16:14,160 --> 00:16:16,880
that has been used in production

423
00:16:16,880 --> 00:16:18,880
in some pretty large scale

424
00:16:18,880 --> 00:16:21,360
deployments so we we know that this is

425
00:16:21,360 --> 00:16:23,680
useful and that it really does

426
00:16:23,680 --> 00:16:26,240
help our customers or the commercial

427
00:16:26,240 --> 00:16:29,199
version has helped our customers detect

428
00:16:29,199 --> 00:16:32,079
malicious activity

429
00:16:32,079 --> 00:16:33,680
but now we're making it into an open

430
00:16:33,680 --> 00:16:38,240
source project so that we can all use it

431
00:16:38,240 --> 00:16:41,279
so it's using this knowledge of what

432
00:16:41,279 --> 00:16:43,680
functions in the kernel are

433
00:16:43,680 --> 00:16:46,000
safe to use and

434
00:16:46,000 --> 00:16:48,959
de facto stable enough that we don't

435
00:16:48,959 --> 00:16:50,639
anticipate them changing and if they

436
00:16:50,639 --> 00:16:52,560
aren't if they do change in the future

437
00:16:52,560 --> 00:16:53,839
well we'll we'll deal with that but

438
00:16:53,839 --> 00:16:56,560
there's no expectation that they will

439
00:16:56,560 --> 00:16:58,000
and we have

440
00:16:58,000 --> 00:17:00,639
the ability to coordinate

441
00:17:00,639 --> 00:17:04,000
many different ebpf programs to provide

442
00:17:04,000 --> 00:17:07,039
security tooling

443
00:17:08,559 --> 00:17:10,240
in

444
00:17:10,240 --> 00:17:13,359
in psyllium we have knowledge of

445
00:17:13,359 --> 00:17:16,079
kubernetes we have all this contextual

446
00:17:16,079 --> 00:17:19,359
information about what processes are

447
00:17:19,359 --> 00:17:22,400
part of which pods which namespace

448
00:17:22,400 --> 00:17:25,760
they're operating in and we can use

449
00:17:25,760 --> 00:17:29,280
that knowledge to make it very efficient

450
00:17:29,280 --> 00:17:31,440
filtered in the kernel or filtered in

451
00:17:31,440 --> 00:17:33,840
user space

452
00:17:34,640 --> 00:17:36,320
you might be wondering why it's called

453
00:17:36,320 --> 00:17:38,799
tetragon this is why

454
00:17:38,799 --> 00:17:42,160
the tetragoniska angustula is a kind of

455
00:17:42,160 --> 00:17:44,880
bee there are a few other tetragoniska

456
00:17:44,880 --> 00:17:47,520
bees in this family

457
00:17:47,520 --> 00:17:48,240
the

458
00:17:48,240 --> 00:17:50,320
if you look this up on wikipedia this

459
00:17:50,320 --> 00:17:53,919
particular bee is uh it's a very small

460
00:17:53,919 --> 00:17:56,799
bee it builds unobtrusive nests it

461
00:17:56,799 --> 00:17:58,559
produces lots of honey and it's

462
00:17:58,559 --> 00:18:01,600
considered to not be a threat to humans

463
00:18:01,600 --> 00:18:04,160
i feel like that's very apt as a name

464
00:18:04,160 --> 00:18:05,679
for a project that is

465
00:18:05,679 --> 00:18:08,960
very small efficient uh you know

466
00:18:08,960 --> 00:18:11,919
resource unintensive and produces lots

467
00:18:11,919 --> 00:18:15,520
of really useful sweet information for

468
00:18:15,520 --> 00:18:17,919
detecting security

469
00:18:17,919 --> 00:18:20,640
violations

470
00:18:21,440 --> 00:18:23,440
so yeah context is everything when you

471
00:18:23,440 --> 00:18:25,679
get these

472
00:18:25,679 --> 00:18:28,559
if you define a policy for the kind of

473
00:18:28,559 --> 00:18:29,919
security event that you might be

474
00:18:29,919 --> 00:18:31,440
interested in

475
00:18:31,440 --> 00:18:33,760
but you want to know what the context

476
00:18:33,760 --> 00:18:36,080
was where that

477
00:18:36,080 --> 00:18:38,960
suspicious looking activity took place

478
00:18:38,960 --> 00:18:40,080
so

479
00:18:40,080 --> 00:18:42,799
we can see that some

480
00:18:42,799 --> 00:18:44,640
suspicious activity happened we can

481
00:18:44,640 --> 00:18:47,120
combine it with this information about

482
00:18:47,120 --> 00:18:49,760
the kubernetes context it's running in

483
00:18:49,760 --> 00:18:52,880
and that will be really useful for

484
00:18:52,880 --> 00:18:54,400
both determining whether or not it

485
00:18:54,400 --> 00:18:55,520
really is

486
00:18:55,520 --> 00:18:57,760
something to worry about and more

487
00:18:57,760 --> 00:19:00,000
importantly to as forensics for trying

488
00:19:00,000 --> 00:19:01,360
to track down

489
00:19:01,360 --> 00:19:05,039
how the pod got compromised

490
00:19:05,919 --> 00:19:08,160
the other thing that's really different

491
00:19:08,160 --> 00:19:09,200
from

492
00:19:09,200 --> 00:19:10,559
all of the other

493
00:19:10,559 --> 00:19:12,880
kind of approaches that we've seen is

494
00:19:12,880 --> 00:19:13,919
the

495
00:19:13,919 --> 00:19:16,880
ability to prevent

496
00:19:16,880 --> 00:19:20,320
a malicious or suspicious activity

497
00:19:20,320 --> 00:19:21,200
so

498
00:19:21,200 --> 00:19:23,360
the kind of kernel probes that we've

499
00:19:23,360 --> 00:19:24,640
talked about

500
00:19:24,640 --> 00:19:26,960
previously whether they're

501
00:19:26,960 --> 00:19:31,120
ebpf kernel probes for cisco's or ptrace

502
00:19:31,120 --> 00:19:32,880
or

503
00:19:32,880 --> 00:19:34,480
any of that kind of family that hook

504
00:19:34,480 --> 00:19:37,200
into the early point of system cause

505
00:19:37,200 --> 00:19:38,480
what they will

506
00:19:38,480 --> 00:19:39,919
do is

507
00:19:39,919 --> 00:19:42,640
notify a user space application which

508
00:19:42,640 --> 00:19:45,600
can then take some preventative action

509
00:19:45,600 --> 00:19:47,520
and that could be

510
00:19:47,520 --> 00:19:49,280
as simple as just killing the process

511
00:19:49,280 --> 00:19:50,960
that's responsible

512
00:19:50,960 --> 00:19:52,960
but the problem with this approach is

513
00:19:52,960 --> 00:19:54,559
that it's asynchronous

514
00:19:54,559 --> 00:19:56,320
and between spotting that there's some

515
00:19:56,320 --> 00:19:59,520
malicious activity if you have to

516
00:19:59,520 --> 00:20:02,240
notify something in user space and then

517
00:20:02,240 --> 00:20:04,240
take your preventative action

518
00:20:04,240 --> 00:20:07,200
it may be too late there may have been

519
00:20:07,200 --> 00:20:08,559
time to

520
00:20:08,559 --> 00:20:11,679
exfiltrate some data or

521
00:20:11,679 --> 00:20:15,679
change something that allows um

522
00:20:15,679 --> 00:20:18,000
an exploit to kind of persist

523
00:20:18,000 --> 00:20:20,240
into the future

524
00:20:20,240 --> 00:20:22,320
what's different with tetragon

525
00:20:22,320 --> 00:20:24,799
is that we can asynchronously trigger

526
00:20:24,799 --> 00:20:27,360
sid kill from within the kernel so as

527
00:20:27,360 --> 00:20:30,159
soon as we detect a malicious event we

528
00:20:30,159 --> 00:20:30,960
can

529
00:20:30,960 --> 00:20:34,960
kill the process immediately

530
00:20:34,960 --> 00:20:35,919
and

531
00:20:35,919 --> 00:20:37,679
if the

532
00:20:37,679 --> 00:20:40,000
demo gods are with me we will see that

533
00:20:40,000 --> 00:20:41,520
in action

534
00:20:41,520 --> 00:20:43,200
okay

535
00:20:43,200 --> 00:20:46,799
so i have a kind cluster here with a few

536
00:20:46,799 --> 00:20:48,960
pods running

537
00:20:48,960 --> 00:20:50,880
and i think at the moment i don't have

538
00:20:50,880 --> 00:20:51,760
any

539
00:20:51,760 --> 00:20:53,440
we have um

540
00:20:53,440 --> 00:20:56,480
tracing policies as the name of security

541
00:20:56,480 --> 00:21:00,880
policies that tetragon enforces

542
00:21:00,880 --> 00:21:03,520
and i'm just gonna run

543
00:21:03,520 --> 00:21:05,120
well i'll start by showing you the the

544
00:21:05,120 --> 00:21:07,360
raw logs from from tetragon there will

545
00:21:07,360 --> 00:21:08,559
be some

546
00:21:08,559 --> 00:21:10,080
whatever's been happening in the past

547
00:21:10,080 --> 00:21:12,799
will will appear in this uh log already

548
00:21:12,799 --> 00:21:16,400
so it's been generating a bunch of

549
00:21:16,400 --> 00:21:17,440
logs

550
00:21:17,440 --> 00:21:18,880
not very human readable but you can

551
00:21:18,880 --> 00:21:22,640
probably make out these a json

552
00:21:23,120 --> 00:21:24,960
event or they're json structures

553
00:21:24,960 --> 00:21:26,640
describing the event we can see here

554
00:21:26,640 --> 00:21:28,080
this one is a

555
00:21:28,080 --> 00:21:30,400
a process exit

556
00:21:30,400 --> 00:21:32,720
by default tetragon will tell you about

557
00:21:32,720 --> 00:21:34,480
all of the process

558
00:21:34,480 --> 00:21:36,720
entries and exits that happen so

559
00:21:36,720 --> 00:21:38,640
basically whenever a new executable is

560
00:21:38,640 --> 00:21:41,679
started or stopped you'll get a log

561
00:21:41,679 --> 00:21:42,799
so

562
00:21:42,799 --> 00:21:44,960
what we can do with this output is pipe

563
00:21:44,960 --> 00:21:46,720
it into

564
00:21:46,720 --> 00:21:48,400
what we actually uh

565
00:21:48,400 --> 00:21:50,240
internally for a long time before we

566
00:21:50,240 --> 00:21:51,760
knew we were going to call it tetragon

567
00:21:51,760 --> 00:21:55,440
we just called this the amazing cli

568
00:21:55,440 --> 00:21:57,600
and i'm going to filter out

569
00:21:57,600 --> 00:21:59,039
so we just see

570
00:21:59,039 --> 00:22:00,559
oops

571
00:22:00,559 --> 00:22:02,159
just see things happening in the default

572
00:22:02,159 --> 00:22:04,640
namespace

573
00:22:04,640 --> 00:22:08,240
so again there's some historical

574
00:22:08,799 --> 00:22:12,080
what's been happening before going on

575
00:22:12,080 --> 00:22:15,679
so if i exact into uh

576
00:22:15,679 --> 00:22:18,640
let's say an x-wing fighter

577
00:22:18,640 --> 00:22:21,280
and i'll run a

578
00:22:21,280 --> 00:22:23,600
bash here and we can see immediately

579
00:22:23,600 --> 00:22:26,480
that we've seen a process started for

580
00:22:26,480 --> 00:22:27,919
bash is that big enough for you all to

581
00:22:27,919 --> 00:22:32,240
see is it okay i see nodding that's good

582
00:22:32,559 --> 00:22:34,240
okay

583
00:22:34,240 --> 00:22:35,280
so

584
00:22:35,280 --> 00:22:38,080
let's say we want to protect

585
00:22:38,080 --> 00:22:41,120
files in the etc directory

586
00:22:41,120 --> 00:22:44,320
and i have a policy here that will

587
00:22:44,320 --> 00:22:46,960
do that did i use underscore or dash

588
00:22:46,960 --> 00:22:49,120
let's see

589
00:22:49,120 --> 00:22:52,678
i'm in the wrong directory

590
00:22:54,240 --> 00:22:57,520
examples so we have a bunch of example

591
00:22:57,520 --> 00:22:59,600
uh policies

592
00:22:59,600 --> 00:23:05,199
and let's take a look at the etc one

593
00:23:06,400 --> 00:23:07,440
now

594
00:23:07,440 --> 00:23:08,400
tetragon

595
00:23:08,400 --> 00:23:11,039
policies are actually pretty low level

596
00:23:11,039 --> 00:23:12,640
they allow us

597
00:23:12,640 --> 00:23:14,559
we can think of tetragon as an engine

598
00:23:14,559 --> 00:23:16,799
that allows us to attach

599
00:23:16,799 --> 00:23:18,159
policies

600
00:23:18,159 --> 00:23:20,000
into these

601
00:23:20,000 --> 00:23:22,880
generic points across the kernel

602
00:23:22,880 --> 00:23:24,960
in this example i'm using a kernel

603
00:23:24,960 --> 00:23:26,799
called a kernel function called fd

604
00:23:26,799 --> 00:23:29,280
install and that's essentially when the

605
00:23:29,280 --> 00:23:31,600
kernel has a file descriptor that it

606
00:23:31,600 --> 00:23:34,080
kind of has in its hands

607
00:23:34,080 --> 00:23:35,760
and

608
00:23:35,760 --> 00:23:37,919
we we're essentially going to follow

609
00:23:37,919 --> 00:23:40,480
with this policy any actions that happen

610
00:23:40,480 --> 00:23:42,400
on that file descriptor

611
00:23:42,400 --> 00:23:44,559
and we're also going to be interested

612
00:23:44,559 --> 00:23:46,000
if there are some

613
00:23:46,000 --> 00:23:49,520
read system calls closed system calls

614
00:23:49,520 --> 00:23:51,360
and if we go down to the end right

615
00:23:51,360 --> 00:23:53,440
system calls

616
00:23:53,440 --> 00:23:55,840
so essentially with this policy we can

617
00:23:55,840 --> 00:23:56,799
track

618
00:23:56,799 --> 00:23:58,799
when anybody opens the file oh i missed

619
00:23:58,799 --> 00:24:02,400
the bit where it matches on slash etc

620
00:24:02,400 --> 00:24:04,640
okay so we'll see

621
00:24:04,640 --> 00:24:06,720
any file being opened

622
00:24:06,720 --> 00:24:09,360
reading writing and closing events on

623
00:24:09,360 --> 00:24:11,919
files inside the et cetera directory

624
00:24:11,919 --> 00:24:14,400
so let me apply that

625
00:24:14,400 --> 00:24:17,400
policy

626
00:24:20,480 --> 00:24:22,640
okay

627
00:24:22,640 --> 00:24:26,400
and if i were in my x-wing fighter to

628
00:24:26,400 --> 00:24:30,559
let's try and edit the password file

629
00:24:30,720 --> 00:24:32,640
okay we're allowed to there's nothing

630
00:24:32,640 --> 00:24:34,559
preventing us from doing it but we can

631
00:24:34,559 --> 00:24:35,520
see

632
00:24:35,520 --> 00:24:38,720
data about it we can see that here the

633
00:24:38,720 --> 00:24:40,580
file has been opened and then

634
00:24:40,580 --> 00:24:41,679
[Music]

635
00:24:41,679 --> 00:24:43,679
1200 odd bytes have been read from it

636
00:24:43,679 --> 00:24:46,240
and then by apparently closes the file

637
00:24:46,240 --> 00:24:49,440
while it's showing it to you

638
00:24:49,440 --> 00:24:50,480
okay

639
00:24:50,480 --> 00:24:52,080
so

640
00:24:52,080 --> 00:24:55,039
suppose i am the uh

641
00:24:55,039 --> 00:24:56,559
i don't know rebel commander and i want

642
00:24:56,559 --> 00:24:58,320
to stop people from being able to change

643
00:24:58,320 --> 00:25:01,120
passwords in my x-wing fighters

644
00:25:01,120 --> 00:25:04,000
perhaps what i should do

645
00:25:04,000 --> 00:25:05,200
is have

646
00:25:05,200 --> 00:25:07,039
a policy that not only tells me that

647
00:25:07,039 --> 00:25:08,960
it's happening but that prevents it from

648
00:25:08,960 --> 00:25:10,720
happening

649
00:25:10,720 --> 00:25:13,679
i have another version of basically the

650
00:25:13,679 --> 00:25:14,640
same

651
00:25:14,640 --> 00:25:15,760
policy

652
00:25:15,760 --> 00:25:17,279
but this time

653
00:25:17,279 --> 00:25:18,799
i've added in

654
00:25:18,799 --> 00:25:21,600
a kill action this this is part of the

655
00:25:21,600 --> 00:25:22,480
right

656
00:25:22,480 --> 00:25:24,960
so when we match on a right operation

657
00:25:24,960 --> 00:25:26,559
we're going to

658
00:25:26,559 --> 00:25:29,919
issue a kill to this process

659
00:25:29,919 --> 00:25:32,320
so let me apply this version of the

660
00:25:32,320 --> 00:25:34,799
policy

661
00:25:38,480 --> 00:25:40,880
kill

662
00:25:40,960 --> 00:25:43,120
okay

663
00:25:43,120 --> 00:25:44,400
and

664
00:25:44,400 --> 00:25:46,799
i'm going to come along and

665
00:25:46,799 --> 00:25:49,120
we see the detection of open read and

666
00:25:49,120 --> 00:25:50,799
close

667
00:25:50,799 --> 00:25:53,279
let's say we want to add in you know

668
00:25:53,279 --> 00:25:55,840
maybe i'm on the dark side and i want to

669
00:25:55,840 --> 00:25:57,120
add

670
00:25:57,120 --> 00:26:00,719
an account for a stormtrooper

671
00:26:00,960 --> 00:26:04,720
let me try and write that file

672
00:26:04,720 --> 00:26:06,480
and we can see here

673
00:26:06,480 --> 00:26:08,159
sig kill

674
00:26:08,159 --> 00:26:10,799
did that happen in time

675
00:26:10,799 --> 00:26:14,559
let's find out let's look at that file

676
00:26:15,600 --> 00:26:17,919
go to the end of the file there is no

677
00:26:17,919 --> 00:26:20,240
sign of permissions for the stormtrooper

678
00:26:20,240 --> 00:26:22,240
so we were able to intercept that right

679
00:26:22,240 --> 00:26:24,480
operation before it took effect

680
00:26:24,480 --> 00:26:26,480
and killed the process that was

681
00:26:26,480 --> 00:26:29,600
trying to perform it

682
00:26:29,840 --> 00:26:31,520
so

683
00:26:31,520 --> 00:26:34,320
file operations is just one example of

684
00:26:34,320 --> 00:26:36,960
the kind of things that we can build

685
00:26:36,960 --> 00:26:38,720
profiles to protect against with

686
00:26:38,720 --> 00:26:41,840
tetragon we've got a ton of examples in

687
00:26:41,840 --> 00:26:42,559
the

688
00:26:42,559 --> 00:26:45,039
repo

689
00:26:46,240 --> 00:26:47,760
we can protect against all of those

690
00:26:47,760 --> 00:26:50,640
categories of

691
00:26:50,640 --> 00:26:53,039
suspicious or you know potentially

692
00:26:53,039 --> 00:26:55,279
the kinds of behaviors that we might be

693
00:26:55,279 --> 00:26:57,679
we might find suspicious be that network

694
00:26:57,679 --> 00:26:58,960
activity

695
00:26:58,960 --> 00:27:02,000
file access memory access privilege

696
00:27:02,000 --> 00:27:03,520
escalation

697
00:27:03,520 --> 00:27:05,520
if you come and find us later in the

698
00:27:05,520 --> 00:27:08,720
week i think we will have on the uh on

699
00:27:08,720 --> 00:27:10,240
the stand for on the cilium stand we

700
00:27:10,240 --> 00:27:12,320
should have a demo for

701
00:27:12,320 --> 00:27:16,240
detecting privilege escalation

702
00:27:16,559 --> 00:27:19,039
and there's you know example

703
00:27:19,039 --> 00:27:21,760
tracing profiles for for a variety of

704
00:27:21,760 --> 00:27:23,200
different

705
00:27:23,200 --> 00:27:25,679
things you might want to protect against

706
00:27:25,679 --> 00:27:27,120
one thing to be aware of though is

707
00:27:27,120 --> 00:27:28,880
because it's quite a general purpose

708
00:27:28,880 --> 00:27:31,679
engine you could write a policy that

709
00:27:31,679 --> 00:27:33,520
just looks at the entry points to

710
00:27:33,520 --> 00:27:36,399
syscalls and would still have the same

711
00:27:36,399 --> 00:27:38,640
time of check to time of use issues that

712
00:27:38,640 --> 00:27:40,720
we've seen with other tools

713
00:27:40,720 --> 00:27:42,000
so you do have to be a little bit

714
00:27:42,000 --> 00:27:43,840
careful about what policies you write

715
00:27:43,840 --> 00:27:46,480
and how you apply them but we have lots

716
00:27:46,480 --> 00:27:48,799
of examples there

717
00:27:48,799 --> 00:27:50,640
so

718
00:27:50,640 --> 00:27:53,039
go check out cillian tetragon put a star

719
00:27:53,039 --> 00:27:55,919
on it that would be great

720
00:27:55,919 --> 00:27:57,039
it's

721
00:27:57,039 --> 00:27:59,600
ebpf based so it's very lightweight and

722
00:27:59,600 --> 00:28:01,120
high performance

723
00:28:01,120 --> 00:28:03,200
it doesn't rely on a kernel that's so

724
00:28:03,200 --> 00:28:04,880
modern that none of you are using it i'm

725
00:28:04,880 --> 00:28:06,320
pretty sure that all of you will be

726
00:28:06,320 --> 00:28:08,080
using kernels that are compatible with

727
00:28:08,080 --> 00:28:09,200
tetragon

728
00:28:09,200 --> 00:28:11,360
it gives you that contextual information

729
00:28:11,360 --> 00:28:14,000
about kubernetes and i think most

730
00:28:14,000 --> 00:28:16,640
importantly and most excitingly we can

731
00:28:16,640 --> 00:28:19,039
block events before

732
00:28:19,039 --> 00:28:22,559
they happen if they're suspicious

733
00:28:22,559 --> 00:28:25,360
so yeah come and see us during the rest

734
00:28:25,360 --> 00:28:27,440
of this week check out the project on

735
00:28:27,440 --> 00:28:28,559
github

736
00:28:28,559 --> 00:28:32,480
i also want to uh mention a book that my

737
00:28:32,480 --> 00:28:35,200
colleague natalia ivanko and

738
00:28:35,200 --> 00:28:37,440
salazar worked on called security

739
00:28:37,440 --> 00:28:40,000
observability with ebpf which talks a

740
00:28:40,000 --> 00:28:41,760
lot about

741
00:28:41,760 --> 00:28:44,559
tetragon and how you can use

742
00:28:44,559 --> 00:28:47,520
profiles to detect and prevent different

743
00:28:47,520 --> 00:28:48,880
types of

744
00:28:48,880 --> 00:28:51,760
security relevant events

745
00:28:51,760 --> 00:28:54,240
so with that thank you very much i hope

746
00:28:54,240 --> 00:28:56,559
you are excited about ebpf because i

747
00:28:56,559 --> 00:29:00,000
really am and do come and find me or my

748
00:29:00,000 --> 00:29:01,919
colleagues during the the week and we

749
00:29:01,919 --> 00:29:03,760
will

750
00:29:03,760 --> 00:29:05,679
chew your ears off about how excited we

751
00:29:05,679 --> 00:29:09,650
are about ebpf so thank you very much

752
00:29:09,650 --> 00:29:17,039
[Applause]

753
00:29:17,039 --> 00:29:19,760
yeah i think we have time for a question

754
00:29:19,760 --> 00:29:22,720
do you have any questions

755
00:29:23,200 --> 00:29:26,679
questions anybody

756
00:29:38,640 --> 00:29:40,320
thank you thank you very much for the

757
00:29:40,320 --> 00:29:42,080
presentation i have the question about

758
00:29:42,080 --> 00:29:43,600
context

759
00:29:43,600 --> 00:29:47,760
uh is it easy to link

760
00:29:47,760 --> 00:29:50,960
for example do two types of detections

761
00:29:50,960 --> 00:29:52,640
like for example would be an interactive

762
00:29:52,640 --> 00:29:55,520
session and then the process of spawning

763
00:29:55,520 --> 00:29:57,440
doing suspicious activities

764
00:29:57,440 --> 00:29:59,760
or it needs to be

765
00:29:59,760 --> 00:30:02,320
events happening only on that syscall in

766
00:30:02,320 --> 00:30:04,720
particular

767
00:30:04,720 --> 00:30:08,200
so um

768
00:30:08,320 --> 00:30:11,279
because tetragon is so kind of general

769
00:30:11,279 --> 00:30:12,960
purpose you can

770
00:30:12,960 --> 00:30:14,080
write

771
00:30:14,080 --> 00:30:16,080
the profile

772
00:30:16,080 --> 00:30:17,360
um

773
00:30:17,360 --> 00:30:19,600
to

774
00:30:20,000 --> 00:30:21,840
i mean in the example that i showed

775
00:30:21,840 --> 00:30:23,760
there it had like three system calls

776
00:30:23,760 --> 00:30:25,520
because they're all related to that

777
00:30:25,520 --> 00:30:27,760
particular file descriptor so it's not

778
00:30:27,760 --> 00:30:28,559
just

779
00:30:28,559 --> 00:30:31,200
any old file it's it starts with that fd

780
00:30:31,200 --> 00:30:32,960
installed that says here is a file

781
00:30:32,960 --> 00:30:34,480
descriptor that i'm interested in

782
00:30:34,480 --> 00:30:37,200
because it matches etc

783
00:30:37,200 --> 00:30:39,200
now if i see any

784
00:30:39,200 --> 00:30:41,679
subsequent activity related to that file

785
00:30:41,679 --> 00:30:42,960
descriptor

786
00:30:42,960 --> 00:30:45,600
be it a reader write a close then i'm

787
00:30:45,600 --> 00:30:47,840
interested so it's kind of all in the

788
00:30:47,840 --> 00:30:51,120
way the profile is constructed how

789
00:30:51,120 --> 00:30:53,760
you link the context of those different

790
00:30:53,760 --> 00:30:55,600
events in the profile if that makes

791
00:30:55,600 --> 00:30:57,519
sense yeah yeah perfect thank you very

792
00:30:57,519 --> 00:30:59,760
much

793
00:31:01,679 --> 00:31:05,159
any more questions

794
00:31:07,519 --> 00:31:09,679
okay

795
00:31:09,679 --> 00:31:12,799
just a quick one um just wondering for

796
00:31:12,799 --> 00:31:13,679
um

797
00:31:13,679 --> 00:31:15,360
i'm not too familiar with the interface

798
00:31:15,360 --> 00:31:19,120
the sm api but how does it handle like

799
00:31:19,120 --> 00:31:21,519
buffers in the kernel

800
00:31:21,519 --> 00:31:23,279
if you're writing to a file where you

801
00:31:23,279 --> 00:31:25,600
know you're writing one byte at a time

802
00:31:25,600 --> 00:31:28,960
is it able to inspect the entire buffer

803
00:31:28,960 --> 00:31:32,399
um i would refer you to lsm hooks the

804
00:31:32,399 --> 00:31:34,000
header file that will tell you all the

805
00:31:34,000 --> 00:31:36,480
different now actually that is that does

806
00:31:36,480 --> 00:31:38,159
make me think a sort of important point

807
00:31:38,159 --> 00:31:39,679
where

808
00:31:39,679 --> 00:31:41,760
if you want to use the lsm interface you

809
00:31:41,760 --> 00:31:44,320
can but you don't have to and actually

810
00:31:44,320 --> 00:31:46,399
what we've used in tetragon is

811
00:31:46,399 --> 00:31:47,360
not

812
00:31:47,360 --> 00:31:50,000
the lsm interface because we've chosen

813
00:31:50,000 --> 00:31:51,679
to use some different entry points

814
00:31:51,679 --> 00:31:53,519
specifically about buffers i'm sure we

815
00:31:53,519 --> 00:31:56,399
can find someone to answer specifically

816
00:31:56,399 --> 00:31:59,559
thank you

817
00:32:01,200 --> 00:32:02,799
yeah

818
00:32:02,799 --> 00:32:05,440
all right thanks this was a great talk

819
00:32:05,440 --> 00:32:07,250
thank you

820
00:32:07,250 --> 00:32:13,029
[Applause]

