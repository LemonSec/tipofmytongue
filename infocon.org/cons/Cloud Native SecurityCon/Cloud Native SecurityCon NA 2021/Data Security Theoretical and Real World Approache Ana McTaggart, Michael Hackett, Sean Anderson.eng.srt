1
00:00:00,960 --> 00:00:02,240
hi everybody

2
00:00:02,240 --> 00:00:04,240
at the cloud native security conference

3
00:00:04,240 --> 00:00:05,600
welcome

4
00:00:05,600 --> 00:00:07,680
today we're going to discuss from theory

5
00:00:07,680 --> 00:00:10,320
to practice with sean anderson myself

6
00:00:10,320 --> 00:00:13,519
anna mctaggart and michael hackett

7
00:00:13,519 --> 00:00:15,280
here we are

8
00:00:15,280 --> 00:00:18,400
and michael hackett and i are at red hat

9
00:00:18,400 --> 00:00:20,800
i'm a security analyst and he is a

10
00:00:20,800 --> 00:00:23,359
principal product experience engineer

11
00:00:23,359 --> 00:00:25,279
sean anderson is a phd student at

12
00:00:25,279 --> 00:00:27,199
portland state university with a focus

13
00:00:27,199 --> 00:00:30,320
on formal methods

14
00:00:30,320 --> 00:00:31,760
so

15
00:00:31,760 --> 00:00:34,000
here's a little thing this is actually

16
00:00:34,000 --> 00:00:36,079
from practice to theory

17
00:00:36,079 --> 00:00:38,079
the title was created prior to this

18
00:00:38,079 --> 00:00:40,399
decision we're going to be starting off

19
00:00:40,399 --> 00:00:43,120
for clarity of this talk the practical

20
00:00:43,120 --> 00:00:45,120
security used in stuff

21
00:00:45,120 --> 00:00:47,680
the flaws with those methods

22
00:00:47,680 --> 00:00:49,440
and a better way with theory we're going

23
00:00:49,440 --> 00:00:51,840
to start off by discussing rook forsaff

24
00:00:51,840 --> 00:00:53,120
moving into the shortfalls of this

25
00:00:53,120 --> 00:00:55,360
current practice and other security

26
00:00:55,360 --> 00:00:56,879
features with saf

27
00:00:56,879 --> 00:00:58,719
and we're going to show how theory and

28
00:00:58,719 --> 00:01:00,559
in particular formal methods will help

29
00:01:00,559 --> 00:01:03,039
us fix these flaws

30
00:01:03,039 --> 00:01:04,400
and i'm going to hand it over to michael

31
00:01:04,400 --> 00:01:06,240
hackett now

32
00:01:06,240 --> 00:01:07,439
thanks anna

33
00:01:07,439 --> 00:01:10,000
so before we get into the practical

34
00:01:10,000 --> 00:01:12,080
security side of of rook ceph i'd like

35
00:01:12,080 --> 00:01:14,240
to just give a quick overview on on why

36
00:01:14,240 --> 00:01:15,680
we're we're talking about rooksef today

37
00:01:15,680 --> 00:01:16,479
right

38
00:01:16,479 --> 00:01:17,439
um

39
00:01:17,439 --> 00:01:18,880
we all know from a development

40
00:01:18,880 --> 00:01:21,360
standpoint that looking at deploying

41
00:01:21,360 --> 00:01:23,200
cloud native applications in can be

42
00:01:23,200 --> 00:01:25,040
extremely complex and challenging when

43
00:01:25,040 --> 00:01:26,240
we're when we're looking at it from the

44
00:01:26,240 --> 00:01:29,439
outside in right large clouds um large

45
00:01:29,439 --> 00:01:31,360
number of compute um

46
00:01:31,360 --> 00:01:33,280
can lead to a very overwhelming

47
00:01:33,280 --> 00:01:35,759
situation so why we're looking at rook

48
00:01:35,759 --> 00:01:37,600
ceph is because we're we're simplifying

49
00:01:37,600 --> 00:01:39,520
the underlying storage aspect and

50
00:01:39,520 --> 00:01:43,200
allowing our developers or our our end

51
00:01:43,200 --> 00:01:46,159
customers to focus on writing

52
00:01:46,159 --> 00:01:48,720
applications and and testing code

53
00:01:48,720 --> 00:01:49,920
what we've done with workstaff is we've

54
00:01:49,920 --> 00:01:52,880
basically designed an um a way to

55
00:01:52,880 --> 00:01:54,960
automate packaging deployment cluster

56
00:01:54,960 --> 00:01:57,759
management upgrading and and scaling of

57
00:01:57,759 --> 00:01:59,520
of storage

58
00:01:59,520 --> 00:02:00,960
um all underneath the stateful

59
00:02:00,960 --> 00:02:02,479
applications as well as providing

60
00:02:02,479 --> 00:02:04,479
infrastructure services such as as an

61
00:02:04,479 --> 00:02:06,640
area to provide logging in metrics and

62
00:02:06,640 --> 00:02:10,239
registry to kubernetes clusters

63
00:02:10,639 --> 00:02:12,879
we do this by augmenting kubernetes by

64
00:02:12,879 --> 00:02:14,560
giving them access to storage services

65
00:02:14,560 --> 00:02:16,720
including block file system and object

66
00:02:16,720 --> 00:02:18,080
storage

67
00:02:18,080 --> 00:02:21,200
and you can go to the next slide

68
00:02:21,760 --> 00:02:23,440
so so why are we focusing on rook seth

69
00:02:23,440 --> 00:02:25,360
right um

70
00:02:25,360 --> 00:02:26,480
working at red hat we can see the

71
00:02:26,480 --> 00:02:28,800
container adoption is just exploding

72
00:02:28,800 --> 00:02:30,800
throughout our customers um more and

73
00:02:30,800 --> 00:02:32,080
more businesses are looking at using

74
00:02:32,080 --> 00:02:34,080
kubernetes buzzwords

75
00:02:34,080 --> 00:02:37,200
as ways to to uh automate and drive

76
00:02:37,200 --> 00:02:39,200
automation um just improve overall

77
00:02:39,200 --> 00:02:41,120
efficiency with their teams

78
00:02:41,120 --> 00:02:43,840
um and and just be able to to

79
00:02:43,840 --> 00:02:45,760
to to scale at

80
00:02:45,760 --> 00:02:46,640
at

81
00:02:46,640 --> 00:02:49,200
um at need be without the the

82
00:02:49,200 --> 00:02:50,879
requirements of of going out and

83
00:02:50,879 --> 00:02:52,400
purchasing these these large storage

84
00:02:52,400 --> 00:02:53,519
arrays

85
00:02:53,519 --> 00:02:54,640
um

86
00:02:54,640 --> 00:02:55,920
the trouble that we have with cloud

87
00:02:55,920 --> 00:02:57,360
native environments uh which we're

88
00:02:57,360 --> 00:02:58,959
looking to cover here is

89
00:02:58,959 --> 00:03:00,879
is how do we actually secure and protect

90
00:03:00,879 --> 00:03:02,560
this the all this data that's going in

91
00:03:02,560 --> 00:03:04,720
here um this we don't want to leave this

92
00:03:04,720 --> 00:03:06,640
to the development engineer in in order

93
00:03:06,640 --> 00:03:08,080
to figure this out so we need to have

94
00:03:08,080 --> 00:03:09,360
these

95
00:03:09,360 --> 00:03:11,040
these

96
00:03:11,040 --> 00:03:12,480
um

97
00:03:12,480 --> 00:03:13,920
these these features in place that are

98
00:03:13,920 --> 00:03:15,840
able to provide the this type of

99
00:03:15,840 --> 00:03:17,440
security and protection for the data

100
00:03:17,440 --> 00:03:20,000
that resides in our kubernetes clusters

101
00:03:20,000 --> 00:03:23,680
go ahead and go to the next slide please

102
00:03:25,680 --> 00:03:29,120
so where are we currently at with rook

103
00:03:30,000 --> 00:03:32,400
rook gives us the ability to to

104
00:03:32,400 --> 00:03:34,560
auto scale itself and also auto heal

105
00:03:34,560 --> 00:03:36,400
itself when we're facing any type of

106
00:03:36,400 --> 00:03:38,319
underlying hardware failure or or

107
00:03:38,319 --> 00:03:39,760
something that may impact the underlying

108
00:03:39,760 --> 00:03:42,159
cluster situation or or data access for

109
00:03:42,159 --> 00:03:44,080
our end users there's no requirement to

110
00:03:44,080 --> 00:03:46,159
go in there and and

111
00:03:46,159 --> 00:03:48,080
recover a filled object storage name in

112
00:03:48,080 --> 00:03:50,000
yourself the the rook operator

113
00:03:50,000 --> 00:03:52,239
automatically goes out there um restarts

114
00:03:52,239 --> 00:03:54,080
the pod for you so we're dealing with a

115
00:03:54,080 --> 00:03:55,439
a self-healing cluster where the

116
00:03:55,439 --> 00:03:58,080
developer doesn't have to take his time

117
00:03:58,080 --> 00:03:59,840
away from moving forward on on any of

118
00:03:59,840 --> 00:04:02,080
this application work uh to to

119
00:04:02,080 --> 00:04:04,879
troubleshoot an issue and and um auto

120
00:04:04,879 --> 00:04:06,480
recover the class um self recover the

121
00:04:06,480 --> 00:04:08,799
cluster this is auto done all from uh

122
00:04:08,799 --> 00:04:11,680
the the rook stuff operator

123
00:04:11,680 --> 00:04:14,319
we're also allowing um ceph which can be

124
00:04:14,319 --> 00:04:16,238
a complex storage product to run on our

125
00:04:16,238 --> 00:04:18,160
kubernetes platform with these

126
00:04:18,160 --> 00:04:19,519
via the rook stuff operator this is

127
00:04:19,519 --> 00:04:21,199
enabling the benefits of of

128
00:04:21,199 --> 00:04:22,639
containerization and the ease of using

129
00:04:22,639 --> 00:04:25,199
containers

130
00:04:26,240 --> 00:04:27,759
and push that down to our developers the

131
00:04:27,759 --> 00:04:29,280
ease of using containers is obvious it

132
00:04:29,280 --> 00:04:31,600
gives us the the the auto packaging the

133
00:04:31,600 --> 00:04:34,000
the auto upgrade and and those types of

134
00:04:34,000 --> 00:04:34,960
features that i discussed in the

135
00:04:34,960 --> 00:04:37,599
previous slide

136
00:04:38,000 --> 00:04:39,600
looking at uh security from a practical

137
00:04:39,600 --> 00:04:41,600
standpoint we can apply these from from

138
00:04:41,600 --> 00:04:43,360
openshift to our rooksef clusters and we

139
00:04:43,360 --> 00:04:45,120
can look them up these based upon a

140
00:04:45,120 --> 00:04:47,680
individual emo file or in your crds

141
00:04:47,680 --> 00:04:50,479
specified for each one of your um

142
00:04:50,479 --> 00:04:52,240
your resources a crd is a custom

143
00:04:52,240 --> 00:04:53,840
resource definition

144
00:04:53,840 --> 00:04:54,720
um

145
00:04:54,720 --> 00:04:57,680
in ceph standalone outside of kubernetes

146
00:04:57,680 --> 00:04:59,680
um you when you're when you're dealing

147
00:04:59,680 --> 00:05:01,600
with these types of of changes to any of

148
00:05:01,600 --> 00:05:04,080
the security policies or or features

149
00:05:04,080 --> 00:05:06,160
inside ceph it's usually a

150
00:05:06,160 --> 00:05:08,000
a very manual process where you update

151
00:05:08,000 --> 00:05:10,320
configuration and then push out to a set

152
00:05:10,320 --> 00:05:11,440
of nodes

153
00:05:11,440 --> 00:05:13,360
um that's a manual configuration when

154
00:05:13,360 --> 00:05:15,440
we're dealing with ceph um and the rook

155
00:05:15,440 --> 00:05:17,039
ceph operator we're still dealing with

156
00:05:17,039 --> 00:05:19,199
somewhat of a manual configuration here

157
00:05:19,199 --> 00:05:23,199
but uh it's it's a a a lot less

158
00:05:23,199 --> 00:05:24,320
overhead than it would be if we're

159
00:05:24,320 --> 00:05:26,560
dealing with a a set cluster outside a

160
00:05:26,560 --> 00:05:27,840
bare metal subcluster outside of

161
00:05:27,840 --> 00:05:29,360
kubernetes

162
00:05:29,360 --> 00:05:32,720
and you can go to the next slide please

163
00:05:34,160 --> 00:05:35,360
so addressing a little bit where more

164
00:05:35,360 --> 00:05:37,039
where we are from the practical side of

165
00:05:37,039 --> 00:05:39,199
security with seth um i want to go over

166
00:05:39,199 --> 00:05:40,560
a little bit of what we're currently

167
00:05:40,560 --> 00:05:41,520
offering

168
00:05:41,520 --> 00:05:43,520
um we can we can deploy our object

169
00:05:43,520 --> 00:05:45,440
storage daemons which are your your

170
00:05:45,440 --> 00:05:48,080
underlying data storage devices in ceph

171
00:05:48,080 --> 00:05:49,360
uh we can deploy these as being

172
00:05:49,360 --> 00:05:51,759
encrypted uh using dmc during the osd's

173
00:05:51,759 --> 00:05:52,960
creation

174
00:05:52,960 --> 00:05:54,320
uh these can be done in multiple

175
00:05:54,320 --> 00:05:55,840
different ways using lux this can be

176
00:05:55,840 --> 00:05:57,680
done on the the actual device layer or

177
00:05:57,680 --> 00:05:59,520
we can do it on the lvm abstraction

178
00:05:59,520 --> 00:06:00,720
layer

179
00:06:00,720 --> 00:06:02,880
um as of our nautilus release we're

180
00:06:02,880 --> 00:06:05,840
actually supporting external kms um via

181
00:06:05,840 --> 00:06:08,080
hashicorp being the only kms server that

182
00:06:08,080 --> 00:06:10,560
um that we're that we're um supporting

183
00:06:10,560 --> 00:06:11,840
currently and that was made available

184
00:06:11,840 --> 00:06:14,080
with a 1.5 release

185
00:06:14,080 --> 00:06:16,720
um this the way that we we set

186
00:06:16,720 --> 00:06:18,960
encryption on these osds does need to be

187
00:06:18,960 --> 00:06:21,280
uh applied manually so this isn't in an

188
00:06:21,280 --> 00:06:22,560
automated concentrate that can be done

189
00:06:22,560 --> 00:06:24,000
or something that can done to an osd

190
00:06:24,000 --> 00:06:26,319
that's already online unfortunately

191
00:06:26,319 --> 00:06:28,800
um this is done by updating a respected

192
00:06:28,800 --> 00:06:30,880
uh storage uh class device

193
00:06:30,880 --> 00:06:32,479
yaml or template and setting your

194
00:06:32,479 --> 00:06:34,400
encryption value to true

195
00:06:34,400 --> 00:06:36,080
um by default this is stored in

196
00:06:36,080 --> 00:06:38,720
kubernetes secret um

197
00:06:38,720 --> 00:06:41,199
which uh from a security standpoint

198
00:06:41,199 --> 00:06:44,240
isn't as as um

199
00:06:44,240 --> 00:06:46,319
as secure as i i would i would that

200
00:06:46,319 --> 00:06:48,880
would be fit for a certain requirements

201
00:06:48,880 --> 00:06:50,319
for users which is why we introduce

202
00:06:50,319 --> 00:06:52,319
support for the external kms hashicorp

203
00:06:52,319 --> 00:06:54,080
vault when a requirement is for the key

204
00:06:54,080 --> 00:06:55,680
to live outside of kubernetes and on an

205
00:06:55,680 --> 00:06:57,039
external um

206
00:06:57,039 --> 00:06:59,599
vault device

207
00:06:59,919 --> 00:07:01,759
we also in nautilus released um

208
00:07:01,759 --> 00:07:03,039
something called the v2 messenger

209
00:07:03,039 --> 00:07:05,039
protocol so what the v2 messenger

210
00:07:05,039 --> 00:07:07,599
protocol is it actually introduces

211
00:07:07,599 --> 00:07:09,120
encryption on the wire when we're

212
00:07:09,120 --> 00:07:11,360
talking the the encrypted level of osds

213
00:07:11,360 --> 00:07:13,199
we're talking data at rest encryption

214
00:07:13,199 --> 00:07:14,720
what we're doing with the v2 messenger

215
00:07:14,720 --> 00:07:16,560
is actually encrypting data that is

216
00:07:16,560 --> 00:07:18,160
running through the network

217
00:07:18,160 --> 00:07:20,479
um and and this is done utilizing our

218
00:07:20,479 --> 00:07:23,360
own authentication system called suffix

219
00:07:23,360 --> 00:07:26,160
um so what we do there is is is

220
00:07:26,160 --> 00:07:28,880
there is a a default method called crc

221
00:07:28,880 --> 00:07:30,400
check which basically

222
00:07:30,400 --> 00:07:32,880
uh sets a valid crc on on traffic

223
00:07:32,880 --> 00:07:34,639
flowing through the the network and

224
00:07:34,639 --> 00:07:36,960
validates it when we reach an additional

225
00:07:36,960 --> 00:07:40,080
endpoint crc check is the default method

226
00:07:40,080 --> 00:07:42,560
of v2 messenger that we use but there is

227
00:07:42,560 --> 00:07:44,960
also a secure setting which is a a more

228
00:07:44,960 --> 00:07:47,360
in-depth full encryption of all the the

229
00:07:47,360 --> 00:07:49,120
the traffic going through so we were

230
00:07:49,120 --> 00:07:50,319
looking at a full cryptographic

231
00:07:50,319 --> 00:07:51,680
integrity check of the traffic running

232
00:07:51,680 --> 00:07:53,199
through the network

233
00:07:53,199 --> 00:07:57,039
um this requires a also a manual editing

234
00:07:57,039 --> 00:07:58,639
setting of the cluster crd during the

235
00:07:58,639 --> 00:08:00,639
cluster creation so we can't just turn

236
00:08:00,639 --> 00:08:03,199
on secure mode during um

237
00:08:03,199 --> 00:08:04,720
uh that the cluster being up and running

238
00:08:04,720 --> 00:08:06,160
this is the setting that required that

239
00:08:06,160 --> 00:08:07,840
is required to be set while the cluster

240
00:08:07,840 --> 00:08:10,479
is is in creation

241
00:08:10,479 --> 00:08:13,360
this this is done by defining um

242
00:08:13,360 --> 00:08:16,400
your cluster crd

243
00:08:16,639 --> 00:08:18,000
another area that that we look at

244
00:08:18,000 --> 00:08:19,360
instead from a security standpoint is

245
00:08:19,360 --> 00:08:20,720
actually the ability to modify user

246
00:08:20,720 --> 00:08:22,319
permissions per pulse

247
00:08:22,319 --> 00:08:24,479
uh this is this is giving certain users

248
00:08:24,479 --> 00:08:25,599
read write

249
00:08:25,599 --> 00:08:27,759
or or executive access to any of the

250
00:08:27,759 --> 00:08:28,639
pools

251
00:08:28,639 --> 00:08:30,720
this can be configured by setting a a

252
00:08:30,720 --> 00:08:32,320
the client custom resource definition

253
00:08:32,320 --> 00:08:34,399
for a specific client

254
00:08:34,399 --> 00:08:35,679
looking at this primarily for for

255
00:08:35,679 --> 00:08:37,919
library use cases for example openstack

256
00:08:37,919 --> 00:08:40,559
running on open shift um where we may

257
00:08:40,559 --> 00:08:41,839
have a registry or something like that

258
00:08:41,839 --> 00:08:44,159
where a user may may be required

259
00:08:44,159 --> 00:08:46,720
permissions to access specific pools

260
00:08:46,720 --> 00:08:48,640
but um

261
00:08:48,640 --> 00:08:50,080
there are also other use cases for

262
00:08:50,080 --> 00:08:51,680
example your

263
00:08:51,680 --> 00:08:53,440
your radios gateway or object store user

264
00:08:53,440 --> 00:08:55,839
crd can also be set to to specify

265
00:08:55,839 --> 00:08:57,680
specific users to to access different

266
00:08:57,680 --> 00:08:59,680
sets of object store pools

267
00:08:59,680 --> 00:09:03,199
on the underlying subcluster as well

268
00:09:06,080 --> 00:09:08,320
so that that that's currently uh from

269
00:09:08,320 --> 00:09:10,160
the the tactical standpoint what we're

270
00:09:10,160 --> 00:09:12,240
offering right now from the the

271
00:09:12,240 --> 00:09:15,200
the the sephirok standpoint uh we we

272
00:09:15,200 --> 00:09:17,920
understand we are um

273
00:09:17,920 --> 00:09:20,000
limiting in some areas in in particular

274
00:09:20,000 --> 00:09:22,399
we're we're looking at a a

275
00:09:22,399 --> 00:09:23,839
there's no automation right when we're

276
00:09:23,839 --> 00:09:25,040
when we're looking at setting these

277
00:09:25,040 --> 00:09:26,640
these these types of security principles

278
00:09:26,640 --> 00:09:28,800
on this on on rook ceph we're looking at

279
00:09:28,800 --> 00:09:32,320
manual um additions to to to and changes

280
00:09:32,320 --> 00:09:33,839
to anything required to enable these

281
00:09:33,839 --> 00:09:36,000
types of features

282
00:09:36,000 --> 00:09:37,120
hey you want to cover the next slide

283
00:09:37,120 --> 00:09:40,000
please yeah thank you michael

284
00:09:40,000 --> 00:09:42,720
so this is really state of the art stuff

285
00:09:42,720 --> 00:09:45,360
and it's really important it's amazing

286
00:09:45,360 --> 00:09:47,200
seth is continually improving our

287
00:09:47,200 --> 00:09:50,080
security as our media as are many other

288
00:09:50,080 --> 00:09:53,120
places in industry it's really good it's

289
00:09:53,120 --> 00:09:55,600
not enough i still have a job analyzing

290
00:09:55,600 --> 00:09:57,120
cves

291
00:09:57,120 --> 00:09:58,320
day-to-day

292
00:09:58,320 --> 00:10:00,399
stuff on work is really good it enables

293
00:10:00,399 --> 00:10:02,480
all the benefits of containerization it

294
00:10:02,480 --> 00:10:04,959
enables a lot of security benefits

295
00:10:04,959 --> 00:10:06,959
but it doesn't formally guarantee a

296
00:10:06,959 --> 00:10:08,160
whole lot

297
00:10:08,160 --> 00:10:10,160
it's not bulletproof

298
00:10:10,160 --> 00:10:12,000
we still get cves

299
00:10:12,000 --> 00:10:14,160
what causes our cves and how can we

300
00:10:14,160 --> 00:10:15,839
reduce the number of them

301
00:10:15,839 --> 00:10:18,560
going from a whole lot of cves

302
00:10:18,560 --> 00:10:20,640
to just a few

303
00:10:20,640 --> 00:10:22,160
so let's think about some of our sources

304
00:10:22,160 --> 00:10:25,519
of flaws and cves many of our flaws

305
00:10:25,519 --> 00:10:27,279
occur with access control and with

306
00:10:27,279 --> 00:10:29,360
buffer overflow attacks going to discuss

307
00:10:29,360 --> 00:10:31,040
these categories of flaws and then how

308
00:10:31,040 --> 00:10:32,800
to prevent them in theory and in

309
00:10:32,800 --> 00:10:34,560
practice

310
00:10:34,560 --> 00:10:36,480
so access control

311
00:10:36,480 --> 00:10:38,399
you know we deal with this we're dealing

312
00:10:38,399 --> 00:10:39,519
with a lot of stuff by applying

313
00:10:39,519 --> 00:10:41,600
permissions checking user authorization

314
00:10:41,600 --> 00:10:44,320
making sure our key management is set up

315
00:10:44,320 --> 00:10:46,720
it hasn't eliminated the flaws it has

316
00:10:46,720 --> 00:10:49,040
decreased the number of flaws

317
00:10:49,040 --> 00:10:52,399
down to about one percent under cwe 284

318
00:10:52,399 --> 00:10:55,360
aka and proper access control in 2020

319
00:10:55,360 --> 00:10:57,200
and it's a decrease from prior years but

320
00:10:57,200 --> 00:10:59,360
these flaws still exist

321
00:10:59,360 --> 00:11:01,360
we could eliminate these flaws if we had

322
00:11:01,360 --> 00:11:03,519
formal guarantees that state only

323
00:11:03,519 --> 00:11:05,440
certain users are authorized to access

324
00:11:05,440 --> 00:11:08,000
particular things we don't have a formal

325
00:11:08,000 --> 00:11:09,920
bulletproof guarantee we just have

326
00:11:09,920 --> 00:11:12,320
software that enables that and that

327
00:11:12,320 --> 00:11:15,040
roughly provides a general

328
00:11:15,040 --> 00:11:17,920
way to generally prevent these flaws

329
00:11:17,920 --> 00:11:20,399
another the most common and overwhelming

330
00:11:20,399 --> 00:11:22,160
source of cves are related to buffer

331
00:11:22,160 --> 00:11:24,240
overflow and memory buffer attacks this

332
00:11:24,240 --> 00:11:27,600
is 21 of our cves in 2019.

333
00:11:27,600 --> 00:11:29,200
these are entirely preventable with

334
00:11:29,200 --> 00:11:31,440
guardrails from overflowing languages

335
00:11:31,440 --> 00:11:33,519
from programming languages there is no

336
00:11:33,519 --> 00:11:36,959
need to have a buffer overflow in 2021

337
00:11:36,959 --> 00:11:38,880
it happens due to the use of languages

338
00:11:38,880 --> 00:11:40,399
and of course we fix them when they

339
00:11:40,399 --> 00:11:41,519
occur

340
00:11:41,519 --> 00:11:42,959
but there are languages that prevent

341
00:11:42,959 --> 00:11:45,040
buffer overflow attacks

342
00:11:45,040 --> 00:11:48,160
for example go and rust go in rough are

343
00:11:48,160 --> 00:11:50,480
both memory safe meaning that you can't

344
00:11:50,480 --> 00:11:52,240
write to sections of memory that you

345
00:11:52,240 --> 00:11:54,320
don't mean to write to

346
00:11:54,320 --> 00:11:57,360
they eliminate buffer overflow attacks

347
00:11:57,360 --> 00:11:58,959
just by having these guardrails from a

348
00:11:58,959 --> 00:12:01,920
programming language and taking

349
00:12:01,920 --> 00:12:03,279
a little bit of a technique that says

350
00:12:03,279 --> 00:12:05,120
that you cannot have this you can design

351
00:12:05,120 --> 00:12:06,399
a system so that these attacks are

352
00:12:06,399 --> 00:12:08,320
impossible go undressed have different

353
00:12:08,320 --> 00:12:12,320
benefits um you know go obviously has

354
00:12:12,320 --> 00:12:14,399
garbage collection rust does not and it

355
00:12:14,399 --> 00:12:16,079
all depends but rust can be a little bit

356
00:12:16,079 --> 00:12:17,920
faster so it all depends on your goal as

357
00:12:17,920 --> 00:12:19,440
to which language you use but we can

358
00:12:19,440 --> 00:12:20,639
eliminate

359
00:12:20,639 --> 00:12:22,959
buffer overflow attacks even with older

360
00:12:22,959 --> 00:12:25,680
languages with c you can have verifiable

361
00:12:25,680 --> 00:12:27,680
verified compilers that do not allow

362
00:12:27,680 --> 00:12:29,760
security flaws the biggest downside is

363
00:12:29,760 --> 00:12:32,240
efficiency but as we're seeing it's

364
00:12:32,240 --> 00:12:34,000
starting to be practical with languages

365
00:12:34,000 --> 00:12:36,000
such as go and rust being widely adopted

366
00:12:36,000 --> 00:12:38,800
in industry these techniques are not

367
00:12:38,800 --> 00:12:40,880
just in the realm of theory they're very

368
00:12:40,880 --> 00:12:42,959
practical

369
00:12:42,959 --> 00:12:44,720
so how are we even enforcing security

370
00:12:44,720 --> 00:12:47,600
nowadays on rel we're using sc linux and

371
00:12:47,600 --> 00:12:50,000
subcomp and this helps but it relies on

372
00:12:50,000 --> 00:12:51,839
user configuration which as we touched

373
00:12:51,839 --> 00:12:54,639
on can be a huge pain doing all this

374
00:12:54,639 --> 00:12:56,720
manual user configuration

375
00:12:56,720 --> 00:12:59,200
containerization really helps to contain

376
00:12:59,200 --> 00:13:01,279
flaws and decrease their security

377
00:13:01,279 --> 00:13:03,920
severity but alone it doesn't eliminate

378
00:13:03,920 --> 00:13:06,560
the flaws it reduces it it provides a

379
00:13:06,560 --> 00:13:09,760
stop gap but we still get cves

380
00:13:09,760 --> 00:13:12,079
again we want to eliminate these

381
00:13:12,079 --> 00:13:13,760
security flaws eventually so that there

382
00:13:13,760 --> 00:13:16,880
are no more cvs of these types

383
00:13:16,880 --> 00:13:19,600
so how would we do that

384
00:13:19,600 --> 00:13:21,440
well we really need to make it so that

385
00:13:21,440 --> 00:13:23,519
security is impossible to mess up

386
00:13:23,519 --> 00:13:25,680
again

387
00:13:25,680 --> 00:13:27,600
we are very optimistic we're making

388
00:13:27,600 --> 00:13:29,519
progress in reality

389
00:13:29,519 --> 00:13:31,519
but we want to make this impossible to

390
00:13:31,519 --> 00:13:33,360
mess up and we want to make it so that

391
00:13:33,360 --> 00:13:36,560
programmer errors don't lead to exploits

392
00:13:36,560 --> 00:13:38,720
a programmer error should not just be a

393
00:13:38,720 --> 00:13:40,880
personal flaw but it should be a flaw

394
00:13:40,880 --> 00:13:42,639
within your design

395
00:13:42,639 --> 00:13:44,399
how do we make it so

396
00:13:44,399 --> 00:13:46,160
it's idiot proof you can't mess up you

397
00:13:46,160 --> 00:13:48,959
can't create a major security flaw

398
00:13:48,959 --> 00:13:50,320
so

399
00:13:50,320 --> 00:13:52,399
we can do that using formal methods

400
00:13:52,399 --> 00:13:53,440
currently

401
00:13:53,440 --> 00:13:55,440
we're the deniedies we're bringing our

402
00:13:55,440 --> 00:13:57,920
buckets of water our patches

403
00:13:57,920 --> 00:13:59,440
to

404
00:13:59,440 --> 00:14:02,399
a sieve that pours it out day in day out

405
00:14:02,399 --> 00:14:04,160
for all of eternity

406
00:14:04,160 --> 00:14:05,760
um

407
00:14:05,760 --> 00:14:08,480
it's annoying

408
00:14:08,880 --> 00:14:10,800
it's honest work to be fixing all of

409
00:14:10,800 --> 00:14:14,839
these cves but it can feel repetitive

410
00:14:14,839 --> 00:14:18,480
so what's our way to the future

411
00:14:18,480 --> 00:14:20,480
i'm going to let sean here speak about

412
00:14:20,480 --> 00:14:23,120
formalizing security and formal methods

413
00:14:23,120 --> 00:14:24,959
and ways to actually stop these at the

414
00:14:24,959 --> 00:14:27,440
source we're no longer the denieties

415
00:14:27,440 --> 00:14:28,800
we're no longer having it flow out the

416
00:14:28,800 --> 00:14:31,680
bottom but we're slapping on a cv we're

417
00:14:31,680 --> 00:14:32,959
going a little bit more than slapping on

418
00:14:32,959 --> 00:14:36,800
a cv effects here and actually

419
00:14:36,800 --> 00:14:39,279
fixing that entire bucket so that it's

420
00:14:39,279 --> 00:14:40,560
not just held together with the duct

421
00:14:40,560 --> 00:14:43,199
tape but there's a nice solid glass

422
00:14:43,199 --> 00:14:45,279
speaker up there

423
00:14:45,279 --> 00:14:47,199
and over to sean

424
00:14:47,199 --> 00:14:49,120
all right thanks anna

425
00:14:49,120 --> 00:14:50,240
all right so

426
00:14:50,240 --> 00:14:51,040
um

427
00:14:51,040 --> 00:14:52,560
we've been hearing this this term formal

428
00:14:52,560 --> 00:14:55,040
methods uh a bunch in this talk

429
00:14:55,040 --> 00:14:55,839
and

430
00:14:55,839 --> 00:14:58,720
uh one might reasonably wonder uh what

431
00:14:58,720 --> 00:15:00,240
is that what what do i mean by

432
00:15:00,240 --> 00:15:03,040
formalizing and why is this helpful um

433
00:15:03,040 --> 00:15:04,079
and

434
00:15:04,079 --> 00:15:06,720
why uh do we have these visions that one

435
00:15:06,720 --> 00:15:08,639
day this will you know take us beyond

436
00:15:08,639 --> 00:15:12,720
the era of flex tape security um so the

437
00:15:12,720 --> 00:15:14,720
the essence of formal methods uh it's a

438
00:15:14,720 --> 00:15:18,160
kind of broad uh class of research uh

439
00:15:18,160 --> 00:15:19,760
connected to programming language theory

440
00:15:19,760 --> 00:15:22,079
uh and formal logic uh the essence is

441
00:15:22,079 --> 00:15:24,079
that we're going to represent programs

442
00:15:24,079 --> 00:15:26,560
uh and systems uh in some kind of

443
00:15:26,560 --> 00:15:30,160
logical system uh that is amenable to

444
00:15:30,160 --> 00:15:33,360
uh mathematical proof um so we're

445
00:15:33,360 --> 00:15:36,000
we're going to uh rigorously model our

446
00:15:36,000 --> 00:15:39,040
systems and uh programs um

447
00:15:39,040 --> 00:15:41,440
and what that means uh for instance in

448
00:15:41,440 --> 00:15:43,440
the area of my research is that we can

449
00:15:43,440 --> 00:15:46,560
uh define logical propositions uh

450
00:15:46,560 --> 00:15:49,040
representing uh the essence of some

451
00:15:49,040 --> 00:15:51,680
concept of security um

452
00:15:51,680 --> 00:15:52,880
and so

453
00:15:52,880 --> 00:15:54,000
we can think of this as just a very

454
00:15:54,000 --> 00:15:56,240
rigorous way of specifying uh what our

455
00:15:56,240 --> 00:15:58,079
system is supposed to do uh and then

456
00:15:58,079 --> 00:15:59,600
ideally uh we then take that

457
00:15:59,600 --> 00:16:02,079
specification and uh the fact that it's

458
00:16:02,079 --> 00:16:03,920
embedded in this formal logic and we

459
00:16:03,920 --> 00:16:06,079
actually build a logical proof uh that

460
00:16:06,079 --> 00:16:08,720
guarantees uh that for a given system

461
00:16:08,720 --> 00:16:11,040
whatever property we've claimed we want

462
00:16:11,040 --> 00:16:13,279
actually does apply to that system uh

463
00:16:13,279 --> 00:16:14,639
and then the very nice thing is that

464
00:16:14,639 --> 00:16:18,720
with uh recent technologies uh we can

465
00:16:18,720 --> 00:16:20,560
we make these formal logics machine

466
00:16:20,560 --> 00:16:23,600
checkable uh so you know it's not just

467
00:16:23,600 --> 00:16:26,000
that i wrote down in my notebook a proof

468
00:16:26,000 --> 00:16:28,000
that you know you take uh your eyeball

469
00:16:28,000 --> 00:16:30,079
and say it looks right but actually we

470
00:16:30,079 --> 00:16:33,120
can feed the uh the proof into a machine

471
00:16:33,120 --> 00:16:35,759
that will say yes absolutely

472
00:16:35,759 --> 00:16:37,199
this proof holds

473
00:16:37,199 --> 00:16:38,720
um

474
00:16:38,720 --> 00:16:40,720
now that is uh

475
00:16:40,720 --> 00:16:42,000
a pretty high bar

476
00:16:42,000 --> 00:16:43,120
and

477
00:16:43,120 --> 00:16:46,480
um as i'll get to in a couple of slides

478
00:16:46,480 --> 00:16:48,639
it's not always uh it's not currently

479
00:16:48,639 --> 00:16:50,240
viewed as super practical to do this for

480
00:16:50,240 --> 00:16:52,560
large scale projects um so for my part

481
00:16:52,560 --> 00:16:55,199
of this talk uh i also kind of want to

482
00:16:55,199 --> 00:16:56,399
focus on

483
00:16:56,399 --> 00:16:57,920
um

484
00:16:57,920 --> 00:17:00,480
the secondary benefit of formal methods

485
00:17:00,480 --> 00:17:01,519
um

486
00:17:01,519 --> 00:17:03,680
that which is that when you start

487
00:17:03,680 --> 00:17:05,679
thinking in terms of these

488
00:17:05,679 --> 00:17:08,559
logical systems and properties uh

489
00:17:08,559 --> 00:17:10,160
you kind of change the way that you

490
00:17:10,160 --> 00:17:12,319
think about security in a way that

491
00:17:12,319 --> 00:17:14,400
even absent the formal proofs can be

492
00:17:14,400 --> 00:17:15,839
helpful in

493
00:17:15,839 --> 00:17:17,919
understanding the nature of security in

494
00:17:17,919 --> 00:17:19,919
a system um so we want to get beyond

495
00:17:19,919 --> 00:17:22,000
thinking about just um

496
00:17:22,000 --> 00:17:23,839
individual exploits and examples of bad

497
00:17:23,839 --> 00:17:24,880
behavior

498
00:17:24,880 --> 00:17:26,400
and we want to think about at a higher

499
00:17:26,400 --> 00:17:27,919
level a more abstract

500
00:17:27,919 --> 00:17:29,200
level

501
00:17:29,200 --> 00:17:31,440
hit the slide

502
00:17:31,440 --> 00:17:33,360
uh so we want to think in some sense in

503
00:17:33,360 --> 00:17:34,799
terms of abstractions and this is

504
00:17:34,799 --> 00:17:37,919
something that as computer scientists uh

505
00:17:37,919 --> 00:17:39,760
we i i think you know most most

506
00:17:39,760 --> 00:17:42,000
programmers have uh some natural natural

507
00:17:42,000 --> 00:17:43,600
ability to do this just by the nature of

508
00:17:43,600 --> 00:17:46,720
programming uh certainly we uh

509
00:17:46,720 --> 00:17:48,880
we have many many layers of abstractions

510
00:17:48,880 --> 00:17:51,760
in all of our systems um and it's useful

511
00:17:51,760 --> 00:17:53,200
to just think more explicitly about what

512
00:17:53,200 --> 00:17:54,880
those abstractions are and what they do

513
00:17:54,880 --> 00:17:57,440
for us um certainly

514
00:17:57,440 --> 00:17:59,200
programmers uh

515
00:17:59,200 --> 00:18:01,039
you know perhaps our end user or perhaps

516
00:18:01,039 --> 00:18:02,799
the programmers working on a system like

517
00:18:02,799 --> 00:18:04,799
rook steph um

518
00:18:04,799 --> 00:18:06,400
rely on abstractions that are given to

519
00:18:06,400 --> 00:18:08,480
them by the programming language uh they

520
00:18:08,480 --> 00:18:11,760
rely on uh the idea that if i call alec

521
00:18:11,760 --> 00:18:13,280
i'm going to get a block of a particular

522
00:18:13,280 --> 00:18:15,840
size uh that is sort of separate from

523
00:18:15,840 --> 00:18:17,039
everything else in the system that's

524
00:18:17,039 --> 00:18:20,160
memory safety um you know i expect that

525
00:18:20,160 --> 00:18:21,440
if i write through a pointer to this

526
00:18:21,440 --> 00:18:23,200
block i don't accidentally

527
00:18:23,200 --> 00:18:25,120
write into this other block

528
00:18:25,120 --> 00:18:26,240
um

529
00:18:26,240 --> 00:18:28,240
that's an abstraction and that makes it

530
00:18:28,240 --> 00:18:30,640
easier to to write a program but

531
00:18:30,640 --> 00:18:33,200
often uh those abstractions don't

532
00:18:33,200 --> 00:18:35,039
actually hold uh can you click twice

533
00:18:35,039 --> 00:18:37,360
anna

534
00:18:37,440 --> 00:18:39,679
uh often the programmer's mental model

535
00:18:39,679 --> 00:18:42,080
of what's going on in the in the system

536
00:18:42,080 --> 00:18:46,240
has some holes in it and um

537
00:18:46,240 --> 00:18:48,000
there are all sorts of different places

538
00:18:48,000 --> 00:18:50,000
that these holes can exist and

539
00:18:50,000 --> 00:18:52,880
a lot of cves come from the fact that

540
00:18:52,880 --> 00:18:54,720
someone was thinking in terms of some

541
00:18:54,720 --> 00:18:56,480
kind of higher level abstraction

542
00:18:56,480 --> 00:18:59,600
and missed the fact that uh

543
00:18:59,600 --> 00:19:01,120
underneath that abstraction there's

544
00:19:01,120 --> 00:19:03,440
actually a much a lower level more

545
00:19:03,440 --> 00:19:05,280
concrete system that's doing something a

546
00:19:05,280 --> 00:19:08,160
little unexpected and um you know the

547
00:19:08,160 --> 00:19:10,559
classic example that anna referenced is

548
00:19:10,559 --> 00:19:12,080
the memory uh you know the buffer

549
00:19:12,080 --> 00:19:14,559
overflow um you know the fact is that

550
00:19:14,559 --> 00:19:16,160
our buffers are not separate from one

551
00:19:16,160 --> 00:19:19,120
another and in languages like c you can

552
00:19:19,120 --> 00:19:21,440
do simple pointer arithmetic and jump

553
00:19:21,440 --> 00:19:22,799
from one to another and nothing will

554
00:19:22,799 --> 00:19:24,160
actually stop you even though it's not

555
00:19:24,160 --> 00:19:25,200
illegal

556
00:19:25,200 --> 00:19:26,960
um

557
00:19:26,960 --> 00:19:28,720
and so

558
00:19:28,720 --> 00:19:30,080
these assumptions we can almost think of

559
00:19:30,080 --> 00:19:32,080
as being in our trusted computing base

560
00:19:32,080 --> 00:19:32,880
um

561
00:19:32,880 --> 00:19:34,400
and that's sometimes a problem because

562
00:19:34,400 --> 00:19:36,080
we aren't actually

563
00:19:36,080 --> 00:19:38,640
uh we shouldn't actually trust them uh

564
00:19:38,640 --> 00:19:41,440
so be to the next slide

565
00:19:41,440 --> 00:19:43,679
um

566
00:19:44,880 --> 00:19:47,200
what the formal methods community uh

567
00:19:47,200 --> 00:19:49,039
will sometimes get into when we're

568
00:19:49,039 --> 00:19:51,360
talking about solutions to this is um

569
00:19:51,360 --> 00:19:53,120
can be thought some people find it a bit

570
00:19:53,120 --> 00:19:57,679
utopian um it's the idea that we can uh

571
00:19:57,679 --> 00:19:59,600
actually specify at all the layers of

572
00:19:59,600 --> 00:20:01,679
abstraction in a system uh what things

573
00:20:01,679 --> 00:20:04,240
do and how they work um and that gives

574
00:20:04,240 --> 00:20:05,679
the programmers working up near the top

575
00:20:05,679 --> 00:20:08,559
the ability to prove and then verify

576
00:20:08,559 --> 00:20:11,280
um or sorry to specify and then verify

577
00:20:11,280 --> 00:20:12,559
exactly what their program is supposed

578
00:20:12,559 --> 00:20:14,880
to do um

579
00:20:14,880 --> 00:20:15,919
and

580
00:20:15,919 --> 00:20:17,919
uh and then because the

581
00:20:17,919 --> 00:20:20,320
specifications for the lower levels uh

582
00:20:20,320 --> 00:20:23,120
should also be verified um

583
00:20:23,120 --> 00:20:25,600
they are actually able to trust uh that

584
00:20:25,600 --> 00:20:28,000
the abstractions they're relying on are

585
00:20:28,000 --> 00:20:29,840
going to hold um and that's very

586
00:20:29,840 --> 00:20:31,600
important um you know there's

587
00:20:31,600 --> 00:20:33,360
really there's been plenty of work done

588
00:20:33,360 --> 00:20:36,480
in specific programs being verified um

589
00:20:36,480 --> 00:20:38,480
a flagship example is concert a c

590
00:20:38,480 --> 00:20:41,360
compiler uh that's verified and

591
00:20:41,360 --> 00:20:44,320
um and the verification there is well

592
00:20:44,320 --> 00:20:46,720
it does exactly what it's supposed to do

593
00:20:46,720 --> 00:20:48,559
um it's not that it doesn't have

594
00:20:48,559 --> 00:20:50,159
security vulnerabilities luckily with a

595
00:20:50,159 --> 00:20:51,760
compiler you don't

596
00:20:51,760 --> 00:20:53,760
uh you're not you know running it

597
00:20:53,760 --> 00:20:55,679
actively on a production system so maybe

598
00:20:55,679 --> 00:20:57,440
that's not as big a deal but

599
00:20:57,440 --> 00:20:59,440
um

600
00:20:59,440 --> 00:21:01,840
you know we we sort of have the like you

601
00:21:01,840 --> 00:21:03,440
can verify our program

602
00:21:03,440 --> 00:21:04,880
uh and

603
00:21:04,880 --> 00:21:06,559
there's also a lot of work being done in

604
00:21:06,559 --> 00:21:07,440
like

605
00:21:07,440 --> 00:21:09,679
mitigation of these um

606
00:21:09,679 --> 00:21:13,280
abstraction breaking things uh

607
00:21:13,280 --> 00:21:15,280
in the in the lower levels of our system

608
00:21:15,280 --> 00:21:18,880
and that includes things like um

609
00:21:18,880 --> 00:21:20,240
hardware and software security

610
00:21:20,240 --> 00:21:21,760
mechanisms uh you know there's a whole

611
00:21:21,760 --> 00:21:23,200
movement toward

612
00:21:23,200 --> 00:21:25,039
hardware that provides

613
00:21:25,039 --> 00:21:27,120
security enforcement primitives

614
00:21:27,120 --> 00:21:30,159
um there's also when when anna's talking

615
00:21:30,159 --> 00:21:31,600
about um

616
00:21:31,600 --> 00:21:33,360
programming languages feature

617
00:21:33,360 --> 00:21:35,039
programming language features that uh

618
00:21:35,039 --> 00:21:38,480
exclude certain kinds of bugs such as uh

619
00:21:38,480 --> 00:21:42,000
memory safety and rust and go um

620
00:21:42,000 --> 00:21:43,120
you know these

621
00:21:43,120 --> 00:21:46,320
help us be more confident in the um

622
00:21:46,320 --> 00:21:47,760
abstractions that we're giving the the

623
00:21:47,760 --> 00:21:50,320
final programmer uh even without

624
00:21:50,320 --> 00:21:53,520
actually doing all the work of uh

625
00:21:53,520 --> 00:21:56,080
of specifying and verifying every level

626
00:21:56,080 --> 00:21:59,039
um

627
00:21:59,039 --> 00:22:01,600
which is a lot of work uh you have to

628
00:22:01,600 --> 00:22:04,320
specify everything and then do a formal

629
00:22:04,320 --> 00:22:06,320
proof and that involves uh you know we

630
00:22:06,320 --> 00:22:07,600
have we have good tools for writing

631
00:22:07,600 --> 00:22:09,039
those proofs now we have things like

632
00:22:09,039 --> 00:22:12,240
 and isabelle hall um that are

633
00:22:12,240 --> 00:22:13,600
improve assistance and let us do that in

634
00:22:13,600 --> 00:22:16,480
an interactive environment um

635
00:22:16,480 --> 00:22:19,039
but it still is it's a lot of uh

636
00:22:19,039 --> 00:22:21,120
person months to verify even fairly

637
00:22:21,120 --> 00:22:23,600
simple programs um

638
00:22:23,600 --> 00:22:25,520
and then you know you have to build up

639
00:22:25,520 --> 00:22:26,880
this whole system or you just start at

640
00:22:26,880 --> 00:22:29,360
the top and you make assumptions um so

641
00:22:29,360 --> 00:22:31,280
often this is viewed as impractical um

642
00:22:31,280 --> 00:22:33,200
maybe we'll be doing something in fact

643
00:22:33,200 --> 00:22:35,120
there there are some

644
00:22:35,120 --> 00:22:37,679
programs that are getting uh

645
00:22:37,679 --> 00:22:39,919
you know close to making realistic uh

646
00:22:39,919 --> 00:22:41,120
attempts at this and there are many

647
00:22:41,120 --> 00:22:43,360
things um

648
00:22:43,360 --> 00:22:45,760
that prove you know a core uh set of

649
00:22:45,760 --> 00:22:47,760
functionality um one thing i want to

650
00:22:47,760 --> 00:22:49,520
call attention to is micro v a recent

651
00:22:49,520 --> 00:22:52,840
work uh that does this with a um fairly

652
00:22:52,840 --> 00:22:54,960
realistic hypervisor

653
00:22:54,960 --> 00:22:56,799
um

654
00:22:56,799 --> 00:22:58,960
but you know given that this is not

655
00:22:58,960 --> 00:23:00,559
something that we're going to just start

656
00:23:00,559 --> 00:23:04,080
being able to do overnight um

657
00:23:04,080 --> 00:23:05,360
what are some takeaways that we can do

658
00:23:05,360 --> 00:23:06,400
right now

659
00:23:06,400 --> 00:23:09,280
uh hit the slide

660
00:23:09,280 --> 00:23:10,400
um

661
00:23:10,400 --> 00:23:11,919
i think one of the big ones is just kind

662
00:23:11,919 --> 00:23:13,760
of

663
00:23:13,760 --> 00:23:16,559
on maybe a development philosophy level

664
00:23:16,559 --> 00:23:17,600
um

665
00:23:17,600 --> 00:23:19,120
starting to think in terms of these

666
00:23:19,120 --> 00:23:20,559
abstractions uh in terms of the

667
00:23:20,559 --> 00:23:23,600
properties that uh we are depending on

668
00:23:23,600 --> 00:23:26,240
and that we are offering further users

669
00:23:26,240 --> 00:23:28,240
of our software uh and then and this is

670
00:23:28,240 --> 00:23:29,120
where

671
00:23:29,120 --> 00:23:30,720
uh you know if i want to connect this to

672
00:23:30,720 --> 00:23:32,720
seth i might think okay so we have all

673
00:23:32,720 --> 00:23:34,640
these different security features

674
00:23:34,640 --> 00:23:37,360
uh that are being offered to the

675
00:23:37,360 --> 00:23:39,760
end user um

676
00:23:39,760 --> 00:23:41,600
but what it what are the what is the end

677
00:23:41,600 --> 00:23:44,240
users are uh actually using these for

678
00:23:44,240 --> 00:23:46,000
what um

679
00:23:46,000 --> 00:23:47,919
you know can can i write down

680
00:23:47,919 --> 00:23:50,080
a formal description of how the system

681
00:23:50,080 --> 00:23:52,480
should behave so that the end user can

682
00:23:52,480 --> 00:23:55,520
uh rely on that um you know if

683
00:23:55,520 --> 00:23:57,760
if the end user were writing uh their

684
00:23:57,760 --> 00:23:59,279
own code that they were going to verify

685
00:23:59,279 --> 00:24:01,039
in this very rigorous way

686
00:24:01,039 --> 00:24:02,640
and i were providing them with some

687
00:24:02,640 --> 00:24:05,360
axioms that they'll use in their proof

688
00:24:05,360 --> 00:24:06,960
what would they want to assume

689
00:24:06,960 --> 00:24:09,520
uh can you get this slide

690
00:24:09,520 --> 00:24:10,880
um

691
00:24:10,880 --> 00:24:13,840
and there is a whole uh area of research

692
00:24:13,840 --> 00:24:16,559
around just writing these properties i

693
00:24:16,559 --> 00:24:18,320
won't spend a huge amount of time on

694
00:24:18,320 --> 00:24:20,559
them now um but like for example if

695
00:24:20,559 --> 00:24:23,360
we're talking about containers uh

696
00:24:23,360 --> 00:24:24,080
the

697
00:24:24,080 --> 00:24:25,039
sort of

698
00:24:25,039 --> 00:24:27,120
official way in the security literature

699
00:24:27,120 --> 00:24:29,440
to describe a compartmentalization

700
00:24:29,440 --> 00:24:31,279
system uh where containers don't talk to

701
00:24:31,279 --> 00:24:32,720
each other uh is something called

702
00:24:32,720 --> 00:24:34,320
non-interference um actually we use

703
00:24:34,320 --> 00:24:36,000
non-interference for a lot of different

704
00:24:36,000 --> 00:24:36,960
uh

705
00:24:36,960 --> 00:24:38,720
purposes but in this case

706
00:24:38,720 --> 00:24:40,960
non-interference means you know if i'm a

707
00:24:40,960 --> 00:24:43,760
container living in some larger system

708
00:24:43,760 --> 00:24:45,520
um

709
00:24:45,520 --> 00:24:48,080
well maybe that larger system

710
00:24:48,080 --> 00:24:49,919
could be two different systems

711
00:24:49,919 --> 00:24:51,200
uh

712
00:24:51,200 --> 00:24:52,559
and i can't tell the difference between

713
00:24:52,559 --> 00:24:53,919
them because

714
00:24:53,919 --> 00:24:55,760
the parts of the system that i can see

715
00:24:55,760 --> 00:24:58,960
my own memory my own storage uh

716
00:24:58,960 --> 00:25:00,640
between these two systems it's identical

717
00:25:00,640 --> 00:25:03,120
but but other containers in the system

718
00:25:03,120 --> 00:25:04,240
might be doing

719
00:25:04,240 --> 00:25:06,000
who knows what uh right they might be

720
00:25:06,000 --> 00:25:07,919
different from one another uh so if i'm

721
00:25:07,919 --> 00:25:09,039
living in in either of these

722
00:25:09,039 --> 00:25:11,120
environments and i can't tell which one

723
00:25:11,120 --> 00:25:12,320
and then

724
00:25:12,320 --> 00:25:14,960
we execute for a while uh i should still

725
00:25:14,960 --> 00:25:16,799
not be able to tell the difference

726
00:25:16,799 --> 00:25:19,520
between uh the rest of the system you

727
00:25:19,520 --> 00:25:21,600
know if i'm in system a or system b

728
00:25:21,600 --> 00:25:23,039
um

729
00:25:23,039 --> 00:25:23,760
and

730
00:25:23,760 --> 00:25:25,039
that means

731
00:25:25,039 --> 00:25:26,880
that that's kind of an abstract notion

732
00:25:26,880 --> 00:25:28,320
but we can think about what that means

733
00:25:28,320 --> 00:25:30,240
that means that if out there in that

734
00:25:30,240 --> 00:25:32,400
system there is an attacker in system a

735
00:25:32,400 --> 00:25:34,400
but no attacker in system b and i can't

736
00:25:34,400 --> 00:25:35,919
tell the difference then clearly i

737
00:25:35,919 --> 00:25:37,279
didn't get attacked

738
00:25:37,279 --> 00:25:38,960
right and uh on the flip side if i'm an

739
00:25:38,960 --> 00:25:39,919
attacker

740
00:25:39,919 --> 00:25:40,720
and

741
00:25:40,720 --> 00:25:43,200
uh out there in system a there's some

742
00:25:43,200 --> 00:25:45,360
secret that i'm trying to uncover uh and

743
00:25:45,360 --> 00:25:46,960
if there's a different secret in system

744
00:25:46,960 --> 00:25:47,760
b

745
00:25:47,760 --> 00:25:49,360
uh well if i still can't tell which

746
00:25:49,360 --> 00:25:50,720
system i'm in after executing for a

747
00:25:50,720 --> 00:25:51,840
while then i must not have discovered

748
00:25:51,840 --> 00:25:54,000
that secret right and by phrasing things

749
00:25:54,000 --> 00:25:55,120
in this way

750
00:25:55,120 --> 00:25:58,400
um it may seem kind of convoluted or uh

751
00:25:58,400 --> 00:26:01,200
you know just like too abstract um

752
00:26:01,200 --> 00:26:02,880
but it means that we don't have to talk

753
00:26:02,880 --> 00:26:05,840
about specific actions like memory

754
00:26:05,840 --> 00:26:06,960
accesses

755
00:26:06,960 --> 00:26:08,640
or uh

756
00:26:08,640 --> 00:26:10,880
things like that and so um

757
00:26:10,880 --> 00:26:12,960
we can actually capture a wider range of

758
00:26:12,960 --> 00:26:14,640
behaviors that lead to the leaking of

759
00:26:14,640 --> 00:26:17,200
data or the the interference with uh

760
00:26:17,200 --> 00:26:20,400
programs um so you can get the slide

761
00:26:20,400 --> 00:26:23,360
the other thing to think about with uh

762
00:26:23,360 --> 00:26:25,600
they suppose let's pretend that you sat

763
00:26:25,600 --> 00:26:27,760
down for a bit and said well how would i

764
00:26:27,760 --> 00:26:29,279
show my system obeys this

765
00:26:29,279 --> 00:26:31,120
non-interference property and you start

766
00:26:31,120 --> 00:26:32,720
thinking about like

767
00:26:32,720 --> 00:26:33,919
okay in

768
00:26:33,919 --> 00:26:37,279
uh in a c semantics if we step and step

769
00:26:37,279 --> 00:26:38,880
and step uh these are the different

770
00:26:38,880 --> 00:26:40,320
steps we can take

771
00:26:40,320 --> 00:26:41,120
and

772
00:26:41,120 --> 00:26:43,279
uh

773
00:26:44,159 --> 00:26:45,840
at each of these steps i want to say

774
00:26:45,840 --> 00:26:48,720
well i'm only reading from my own uh

775
00:26:48,720 --> 00:26:49,919
from the things that i'm allowed to see

776
00:26:49,919 --> 00:26:51,039
and i'm only writing to things that i'm

777
00:26:51,039 --> 00:26:53,679
about to change um well we might we'll

778
00:26:53,679 --> 00:26:55,440
pretty rapidly hit some circumstance

779
00:26:55,440 --> 00:26:57,279
where actually uh this doesn't hold this

780
00:26:57,279 --> 00:27:00,159
this property as i've stated it here is

781
00:27:00,159 --> 00:27:02,799
too strong um

782
00:27:02,799 --> 00:27:04,640
and that's kind of intentional uh this

783
00:27:04,640 --> 00:27:08,080
is like the utmost level of safety um so

784
00:27:08,080 --> 00:27:09,760
if we want to think about applying it in

785
00:27:09,760 --> 00:27:11,520
practice we need maybe to make it

786
00:27:11,520 --> 00:27:13,760
probabilistic because there um the

787
00:27:13,760 --> 00:27:15,440
underlying mechanisms that michael

788
00:27:15,440 --> 00:27:18,159
talked about uh rely on encryption and

789
00:27:18,159 --> 00:27:20,480
encryption uh gives us probabilistic

790
00:27:20,480 --> 00:27:23,440
guarantees and not absolute ones um

791
00:27:23,440 --> 00:27:25,440
and of course many systems will have

792
00:27:25,440 --> 00:27:26,720
ways that containers are going to talk

793
00:27:26,720 --> 00:27:28,399
to each other and so we'll need to model

794
00:27:28,399 --> 00:27:29,919
that and it's not going to be this nice

795
00:27:29,919 --> 00:27:31,840
straightforward isolation thing um but

796
00:27:31,840 --> 00:27:34,000
the really powerful thing about a model

797
00:27:34,000 --> 00:27:35,360
like this is it gives us this starting

798
00:27:35,360 --> 00:27:36,880
point to say this is the

799
00:27:36,880 --> 00:27:38,799
extreme of what security is and now here

800
00:27:38,799 --> 00:27:40,880
are the ways that it doesn't apply and

801
00:27:40,880 --> 00:27:42,320
we can

802
00:27:42,320 --> 00:27:44,799
uh you know build our model from there

803
00:27:44,799 --> 00:27:47,039
and hit slide

804
00:27:47,039 --> 00:27:49,120
um and then

805
00:27:49,120 --> 00:27:51,039
you know we can we can talk about what

806
00:27:51,039 --> 00:27:52,960
kind of security guarantees we do don't

807
00:27:52,960 --> 00:27:55,120
offer and um

808
00:27:55,120 --> 00:27:56,799
so if

809
00:27:56,799 --> 00:27:58,960
if i'm gonna give any guidance as to you

810
00:27:58,960 --> 00:28:01,039
know how to use formal methods uh

811
00:28:01,039 --> 00:28:03,360
without really formalizing everything

812
00:28:03,360 --> 00:28:05,360
and just informally getting value from

813
00:28:05,360 --> 00:28:06,559
these ideas

814
00:28:06,559 --> 00:28:08,159
um

815
00:28:08,159 --> 00:28:09,760
it's that you know you think about these

816
00:28:09,760 --> 00:28:11,120
abstractions and the way that you're

817
00:28:11,120 --> 00:28:12,799
relying on them and you think about the

818
00:28:12,799 --> 00:28:15,760
extractions that you offer

819
00:28:15,760 --> 00:28:18,240
and you kind of do in your head an

820
00:28:18,240 --> 00:28:20,720
informal reasoning about

821
00:28:20,720 --> 00:28:23,279
what those are and you know why you

822
00:28:23,279 --> 00:28:25,360
believe that your security mechanisms

823
00:28:25,360 --> 00:28:28,559
are sufficient to uh to offer them uh

824
00:28:28,559 --> 00:28:29,679
and then you can tell your customers

825
00:28:29,679 --> 00:28:32,080
that and you can have some new buzzwords

826
00:28:32,080 --> 00:28:33,360
um

827
00:28:33,360 --> 00:28:35,360
you know we all love a good security

828
00:28:35,360 --> 00:28:36,640
buzzword and i'm frankly a little

829
00:28:36,640 --> 00:28:38,559
surprised that non-interference isn't

830
00:28:38,559 --> 00:28:40,320
one of them yet i'm sure the marketing

831
00:28:40,320 --> 00:28:41,919
people would love to slap that on your

832
00:28:41,919 --> 00:28:43,840
software if you have a reasonable belief

833
00:28:43,840 --> 00:28:46,879
that you can provide it

834
00:28:47,360 --> 00:28:49,600
but just by going through that process

835
00:28:49,600 --> 00:28:50,799
of thinking about

836
00:28:50,799 --> 00:28:54,000
security in this way um

837
00:28:54,000 --> 00:28:57,120
you have a kind of higher level view of

838
00:28:57,120 --> 00:28:58,799
the sort of security that you're trying

839
00:28:58,799 --> 00:29:00,720
to offer and the reasons that you might

840
00:29:00,720 --> 00:29:03,279
fail to offer it um and that's even

841
00:29:03,279 --> 00:29:05,760
before you've started doing any

842
00:29:05,760 --> 00:29:08,720
real formal methods work um

843
00:29:08,720 --> 00:29:10,399
and of course as a

844
00:29:10,399 --> 00:29:12,159
formal methods person i advocate for you

845
00:29:12,159 --> 00:29:14,720
to also do the formal methods work but

846
00:29:14,720 --> 00:29:15,919
um

847
00:29:15,919 --> 00:29:18,559
i'm a little biased there um and then of

848
00:29:18,559 --> 00:29:20,640
course the other thing is um

849
00:29:20,640 --> 00:29:22,240
you know as this

850
00:29:22,240 --> 00:29:25,840
uh talk is an example of uh it's good

851
00:29:25,840 --> 00:29:26,640
for

852
00:29:26,640 --> 00:29:28,320
developers and

853
00:29:28,320 --> 00:29:30,559
product people and security people and

854
00:29:30,559 --> 00:29:32,240
formal methods people to all be talking

855
00:29:32,240 --> 00:29:33,840
about the um

856
00:29:33,840 --> 00:29:36,240
our own different perspectives on

857
00:29:36,240 --> 00:29:41,039
uh on how to make systems more secure um

858
00:29:41,039 --> 00:29:42,880
and you know i think that cross

859
00:29:42,880 --> 00:29:44,799
pollination is uh

860
00:29:44,799 --> 00:29:46,799
going to be very valuable um because at

861
00:29:46,799 --> 00:29:47,760
the moment

862
00:29:47,760 --> 00:29:50,320
in industry at large and

863
00:29:50,320 --> 00:29:52,840
academia um these are kind of very

864
00:29:52,840 --> 00:29:57,440
siloed uh disciplines and

865
00:29:57,440 --> 00:29:58,559
we really could use more

866
00:29:58,559 --> 00:30:00,559
cross-pollination

867
00:30:00,559 --> 00:30:03,120
so i think that's it for this talk

868
00:30:03,120 --> 00:30:07,520
and we'll now take questions

