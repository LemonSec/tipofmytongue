1
00:00:00,000 --> 00:00:03,000
welcome to Json web tokens understanding

2
00:00:03,000 --> 00:00:06,660
common pitfalls my name is Bruce

3
00:00:06,660 --> 00:00:08,940
you may recognize me from the show floor

4
00:00:08,940 --> 00:00:10,860
as the guy that's overly

5
00:00:10,860 --> 00:00:12,540
enthusiastically handing out info

6
00:00:12,540 --> 00:00:15,599
stickers I'm actually a software

7
00:00:15,599 --> 00:00:17,940
developer my background is in web

8
00:00:17,940 --> 00:00:21,180
development application security and

9
00:00:21,180 --> 00:00:24,660
access management so in those roles I've

10
00:00:24,660 --> 00:00:25,939
spent a lot of time reading

11
00:00:25,939 --> 00:00:28,019
specifications for the web

12
00:00:28,019 --> 00:00:31,500
such as the Json web token RFC

13
00:00:31,500 --> 00:00:34,200
and uh today I hope to distill some of

14
00:00:34,200 --> 00:00:36,540
that knowledge and uh

15
00:00:36,540 --> 00:00:39,320
bring it to you

16
00:00:39,840 --> 00:00:42,480
so this is a 101 track lecture which

17
00:00:42,480 --> 00:00:44,219
means I'd like to start from a base

18
00:00:44,219 --> 00:00:45,960
foundational knowledge to get us all on

19
00:00:45,960 --> 00:00:48,059
the same page first but if you've worked

20
00:00:48,059 --> 00:00:50,820
with Json web tokens before then this

21
00:00:50,820 --> 00:00:52,680
might be a good review Once you have

22
00:00:52,680 --> 00:00:54,300
them implemented you generally just

23
00:00:54,300 --> 00:00:55,920
start relying on them and trusting that

24
00:00:55,920 --> 00:00:58,440
they're working as expected so this

25
00:00:58,440 --> 00:01:00,420
might also give you a way to go back and

26
00:01:00,420 --> 00:01:01,500
make sure that you're actually using

27
00:01:01,500 --> 00:01:03,600
Json web tokens securely

28
00:01:03,600 --> 00:01:06,659
uh starting from the base uh we're going

29
00:01:06,659 --> 00:01:08,460
to be going over a Json web token format

30
00:01:08,460 --> 00:01:10,260
so what they actually look like and

31
00:01:10,260 --> 00:01:12,299
what's inside of them along with how

32
00:01:12,299 --> 00:01:13,740
they're actually used

33
00:01:13,740 --> 00:01:16,260
then we're going to move on to signing

34
00:01:16,260 --> 00:01:19,140
Json web tokens this is the key

35
00:01:19,140 --> 00:01:20,640
infinitive information that I want to

36
00:01:20,640 --> 00:01:22,140
make sure everybody can get on the same

37
00:01:22,140 --> 00:01:25,080
page for because the signature is the

38
00:01:25,080 --> 00:01:27,659
key to security for the Json web token

39
00:01:27,659 --> 00:01:30,540
if your signature invalidation is not

40
00:01:30,540 --> 00:01:32,640
good then

41
00:01:32,640 --> 00:01:35,880
uh pretty much

42
00:01:35,880 --> 00:01:37,560
all bets are off

43
00:01:37,560 --> 00:01:39,840
anybody can tell anything to your

44
00:01:39,840 --> 00:01:41,579
applications and they will trust those

45
00:01:41,579 --> 00:01:42,659
tokens

46
00:01:42,659 --> 00:01:44,640
the signature is important because

47
00:01:44,640 --> 00:01:47,040
there's information encoded in the Json

48
00:01:47,040 --> 00:01:49,500
web token that whoever is receiving the

49
00:01:49,500 --> 00:01:51,299
token will look at and take us true

50
00:01:51,299 --> 00:01:53,640
based off of this signature

51
00:01:53,640 --> 00:01:55,860
and then finally once we understand that

52
00:01:55,860 --> 00:01:58,259
signature then we'll move on to the

53
00:01:58,259 --> 00:02:00,420
security and common attacks on Json web

54
00:02:00,420 --> 00:02:01,860
tokens

55
00:02:01,860 --> 00:02:04,020
by the end of this talk you should be

56
00:02:04,020 --> 00:02:06,240
able to accept Json web tokens create

57
00:02:06,240 --> 00:02:09,239
Json web tokens validate them and

58
00:02:09,239 --> 00:02:13,220
identify some common vulnerabilities

59
00:02:14,819 --> 00:02:16,800
I like to start things off with some

60
00:02:16,800 --> 00:02:18,420
real world analogies before we actually

61
00:02:18,420 --> 00:02:20,700
dig down into the technical details

62
00:02:20,700 --> 00:02:23,099
anybody here actually go to the bar last

63
00:02:23,099 --> 00:02:25,560
night after the conference I know I did

64
00:02:25,560 --> 00:02:28,379
and the first thing that happened when I

65
00:02:28,379 --> 00:02:29,760
went to the bar I guess I have a

66
00:02:29,760 --> 00:02:32,879
youthful glow is they asked for my ID

67
00:02:32,879 --> 00:02:35,160
so I produced this government ID and

68
00:02:35,160 --> 00:02:36,660
gave it to the bartender

69
00:02:36,660 --> 00:02:38,340
the first thing the bartender did was

70
00:02:38,340 --> 00:02:40,620
look to see that the ID was valid issued

71
00:02:40,620 --> 00:02:42,239
by somebody they trusted which was the

72
00:02:42,239 --> 00:02:43,440
Canadian government

73
00:02:43,440 --> 00:02:45,360
uh if it looked like it had all the

74
00:02:45,360 --> 00:02:48,180
anti-forgery features that an ID has and

75
00:02:48,180 --> 00:02:50,160
finally once they trusted it they read

76
00:02:50,160 --> 00:02:51,959
the information on the ID to make sure

77
00:02:51,959 --> 00:02:54,300
that I was actually who I say I am and I

78
00:02:54,300 --> 00:02:55,500
can buy alcohol

79
00:02:55,500 --> 00:02:57,120
finally once they validated that

80
00:02:57,120 --> 00:02:59,099
information was correct then they served

81
00:02:59,099 --> 00:03:00,060
me

82
00:03:00,060 --> 00:03:02,640
this is actually pretty similar to the

83
00:03:02,640 --> 00:03:05,340
process of validating a Json web token

84
00:03:05,340 --> 00:03:08,120
with an application

85
00:03:09,000 --> 00:03:11,340
so I was able to validate who I was at

86
00:03:11,340 --> 00:03:14,280
the bar using my ID but how am I going

87
00:03:14,280 --> 00:03:16,560
to do that online obviously I can't scan

88
00:03:16,560 --> 00:03:19,319
my passport and send it along to every

89
00:03:19,319 --> 00:03:21,300
website that would be inconvenience and

90
00:03:21,300 --> 00:03:23,159
extremely insecure

91
00:03:23,159 --> 00:03:25,620
I need some kind of virtual piece of ID

92
00:03:25,620 --> 00:03:28,980
that's issued by a trusted Authority but

93
00:03:28,980 --> 00:03:30,739
maybe in this case not the governments

94
00:03:30,739 --> 00:03:33,780
that also wouldn't scale very well

95
00:03:33,780 --> 00:03:37,260
so who do we trust online we trust the

96
00:03:37,260 --> 00:03:39,239
big tech companies like Google or

97
00:03:39,239 --> 00:03:41,640
Microsoft so maybe we can use them to

98
00:03:41,640 --> 00:03:44,040
sign in or maybe even on a smaller scale

99
00:03:44,040 --> 00:03:46,080
if we have our own micro Services we're

100
00:03:46,080 --> 00:03:48,120
using maybe we have an authentication

101
00:03:48,120 --> 00:03:50,099
Service that we trust that our other

102
00:03:50,099 --> 00:03:52,200
micro Services can rely on

103
00:03:52,200 --> 00:03:54,239
this is where Json web tokens come in

104
00:03:54,239 --> 00:03:57,420
they're like a digital online piece of

105
00:03:57,420 --> 00:03:58,860
identification

106
00:03:58,860 --> 00:04:02,580
uh so going back to our bar analogy when

107
00:04:02,580 --> 00:04:05,040
I presented the bartender with the ID

108
00:04:05,040 --> 00:04:08,159
that's like the Json web token itself

109
00:04:08,159 --> 00:04:09,959
when the bartender looked at the Json

110
00:04:09,959 --> 00:04:11,879
web token and saw that it was issued by

111
00:04:11,879 --> 00:04:14,640
the Canadian governments uh that was

112
00:04:14,640 --> 00:04:16,380
like seeing that the Json web token was

113
00:04:16,380 --> 00:04:18,000
signed by a trusted Authority like

114
00:04:18,000 --> 00:04:20,820
Google or your authentication Service

115
00:04:20,820 --> 00:04:23,220
finally they read the information from

116
00:04:23,220 --> 00:04:25,020
the ID or token

117
00:04:25,020 --> 00:04:27,360
and made some assumptions about who I

118
00:04:27,360 --> 00:04:30,740
was because they trusted it

119
00:04:32,100 --> 00:04:37,320
so what is in a Json web token or JWT

120
00:04:37,320 --> 00:04:39,660
well it's an acronym and you can break

121
00:04:39,660 --> 00:04:42,240
it down to its three parts uh pretty

122
00:04:42,240 --> 00:04:45,360
straightforwardly the first part is Json

123
00:04:45,360 --> 00:04:48,300
or JavaScript object notation if you've

124
00:04:48,300 --> 00:04:49,979
done web developments I'm sure this

125
00:04:49,979 --> 00:04:51,780
looks familiar it's a pretty standard

126
00:04:51,780 --> 00:04:54,900
way to send information about an object

127
00:04:54,900 --> 00:04:56,940
between a server and a client in a way

128
00:04:56,940 --> 00:04:58,620
that's easily readable

129
00:04:58,620 --> 00:05:01,380
the next part W for web this is the

130
00:05:01,380 --> 00:05:03,720
expected place that Json web tokens are

131
00:05:03,720 --> 00:05:05,340
to be used normally between

132
00:05:05,340 --> 00:05:08,040
microservices or any other application

133
00:05:08,040 --> 00:05:09,180
running on the web

134
00:05:09,180 --> 00:05:12,720
and finally there's t for token and this

135
00:05:12,720 --> 00:05:15,240
isn't a token in the sense like a

136
00:05:15,240 --> 00:05:17,160
Bitcoin or any other kind of

137
00:05:17,160 --> 00:05:20,340
cryptocurrency uh this is just token in

138
00:05:20,340 --> 00:05:22,919
the form of a piece of information that

139
00:05:22,919 --> 00:05:24,780
asserts something about the person that

140
00:05:24,780 --> 00:05:27,679
holds that token

141
00:05:28,620 --> 00:05:30,419
so this is what a Json web token

142
00:05:30,419 --> 00:05:32,580
actually looks like it's

143
00:05:32,580 --> 00:05:34,380
pretty esoteric and intimidating to

144
00:05:34,380 --> 00:05:35,940
humans pretty clearly not meant to be

145
00:05:35,940 --> 00:05:37,220
read by us

146
00:05:37,220 --> 00:05:40,080
and if you look closer even though it's

147
00:05:40,080 --> 00:05:41,699
intimidating with a bunch of numbers and

148
00:05:41,699 --> 00:05:43,740
letters you'll see there's actually

149
00:05:43,740 --> 00:05:47,880
three dots separating distinct parts of

150
00:05:47,880 --> 00:05:49,680
this Json web token

151
00:05:49,680 --> 00:05:52,440
so what we're actually looking at is the

152
00:05:52,440 --> 00:05:54,000
three different components of a Json web

153
00:05:54,000 --> 00:05:56,699
token the header the blue Parts the

154
00:05:56,699 --> 00:05:58,680
payload in pink which is the information

155
00:05:58,680 --> 00:06:01,860
about who holds this Json web token and

156
00:06:01,860 --> 00:06:04,259
the green part is the signature

157
00:06:04,259 --> 00:06:06,780
one important thing to note is that

158
00:06:06,780 --> 00:06:10,560
although this looks very obscured and

159
00:06:10,560 --> 00:06:13,020
potentially secure it's actually just

160
00:06:13,020 --> 00:06:16,919
base64 encoded base64 encoding is just a

161
00:06:16,919 --> 00:06:18,720
standard way to encode information to

162
00:06:18,720 --> 00:06:22,100
send it over the wire uh so a common

163
00:06:22,100 --> 00:06:24,060
misconception I guess I've seen when

164
00:06:24,060 --> 00:06:25,800
people are working with Json web tokens

165
00:06:25,800 --> 00:06:28,500
is that they think they can store secret

166
00:06:28,500 --> 00:06:31,319
information in them and in the case of a

167
00:06:31,319 --> 00:06:33,600
standard Json web token that is not the

168
00:06:33,600 --> 00:06:36,840
case it's just base64 encoded so whoever

169
00:06:36,840 --> 00:06:38,580
receives this token can decode it and

170
00:06:38,580 --> 00:06:40,979
read whatever's inside of it there is

171
00:06:40,979 --> 00:06:42,780
something called an encrypted Json web

172
00:06:42,780 --> 00:06:44,460
token which I'm not going to talk about

173
00:06:44,460 --> 00:06:45,960
here but if you're looking to send

174
00:06:45,960 --> 00:06:48,240
encrypted secret information to somebody

175
00:06:48,240 --> 00:06:52,100
that's what you'll want to use instead

176
00:06:52,680 --> 00:06:54,600
so let's go through the components the

177
00:06:54,600 --> 00:06:56,520
first component of the Json web token is

178
00:06:56,520 --> 00:06:59,220
the header so this is information about

179
00:06:59,220 --> 00:07:00,900
how the token should actually be

180
00:07:00,900 --> 00:07:02,759
validated by the party that receives the

181
00:07:02,759 --> 00:07:05,759
token in this case you can see that it's

182
00:07:05,759 --> 00:07:08,940
specifying the hs-256 algorithm was used

183
00:07:08,940 --> 00:07:12,479
to create the signature and in the case

184
00:07:12,479 --> 00:07:15,120
of all Json web tokens as far as I know

185
00:07:15,120 --> 00:07:17,460
the type will be jots there can be other

186
00:07:17,460 --> 00:07:21,300
things here if it's not a Json web token

187
00:07:21,300 --> 00:07:23,220
the next part of the token is the

188
00:07:23,220 --> 00:07:26,220
payload this is the midi bit that's your

189
00:07:26,220 --> 00:07:28,620
clients will actually be looking at this

190
00:07:28,620 --> 00:07:30,780
contains all the information about the

191
00:07:30,780 --> 00:07:32,880
party that is presenting the token so

192
00:07:32,880 --> 00:07:34,740
this could be a token presented by a

193
00:07:34,740 --> 00:07:36,720
user or it could also be a token

194
00:07:36,720 --> 00:07:38,880
presented by say a machine like another

195
00:07:38,880 --> 00:07:41,460
micro service calling it to a different

196
00:07:41,460 --> 00:07:43,740
micro service

197
00:07:43,740 --> 00:07:45,479
um in our example here we've got the

198
00:07:45,479 --> 00:07:46,979
email of the user that the token was

199
00:07:46,979 --> 00:07:49,500
created for hello at example.com

200
00:07:49,500 --> 00:07:51,660
and then two other commonly seen fields

201
00:07:51,660 --> 00:07:54,000
and Json web tokens so these are

202
00:07:54,000 --> 00:07:56,400
abbreviated for the point of just saving

203
00:07:56,400 --> 00:07:59,099
space in the Json web token but you can

204
00:07:59,099 --> 00:08:01,680
see the second field there is IAT which

205
00:08:01,680 --> 00:08:03,960
stands for issued at this is the time

206
00:08:03,960 --> 00:08:06,479
the token was created and if you receive

207
00:08:06,479 --> 00:08:08,220
a token with an issued ad in the future

208
00:08:08,220 --> 00:08:09,960
it's not valid

209
00:08:09,960 --> 00:08:12,539
and the Third Field which is also an

210
00:08:12,539 --> 00:08:14,819
extremely important one is exp the

211
00:08:14,819 --> 00:08:17,759
expiry of the token these are both Unix

212
00:08:17,759 --> 00:08:20,400
timestamps the expiry is important

213
00:08:20,400 --> 00:08:21,900
because if you receive a token that's

214
00:08:21,900 --> 00:08:23,819
after the expiry the information in it

215
00:08:23,819 --> 00:08:26,699
may no longer be valid so kind of going

216
00:08:26,699 --> 00:08:30,120
back to the ID analogy from earlier this

217
00:08:30,120 --> 00:08:31,560
is like the information that was written

218
00:08:31,560 --> 00:08:35,039
on your driver's license or passport and

219
00:08:35,039 --> 00:08:37,020
for the expiry that's like the expiry of

220
00:08:37,020 --> 00:08:38,339
the passport like maybe somebody's

221
00:08:38,339 --> 00:08:40,380
address has changed or maybe some of

222
00:08:40,380 --> 00:08:42,958
their features have changed since this

223
00:08:42,958 --> 00:08:46,218
passport was issued

224
00:08:46,860 --> 00:08:49,200
and finally there's this signature there

225
00:08:49,200 --> 00:08:51,959
this part is kind of a little bit more

226
00:08:51,959 --> 00:08:53,339
difficult to demonstrate because it

227
00:08:53,339 --> 00:08:55,680
doesn't decode into Json it's just an

228
00:08:55,680 --> 00:08:57,540
Integrity check value for that header

229
00:08:57,540 --> 00:09:00,120
and payload like I said this is actually

230
00:09:00,120 --> 00:09:01,800
the most important component because it

231
00:09:01,800 --> 00:09:03,660
lets us know that the information in

232
00:09:03,660 --> 00:09:05,519
those first two sections has not been

233
00:09:05,519 --> 00:09:08,760
tampered with and we can trust it

234
00:09:08,760 --> 00:09:10,860
so let's break down actually how we get

235
00:09:10,860 --> 00:09:12,660
this signature to make sure that we're

236
00:09:12,660 --> 00:09:14,100
doing it correctly and validating it

237
00:09:14,100 --> 00:09:16,459
correctly

238
00:09:16,680 --> 00:09:19,019
well there's two ways to actually get

239
00:09:19,019 --> 00:09:21,660
the token signature the first way is

240
00:09:21,660 --> 00:09:24,720
using symmetric key signing so according

241
00:09:24,720 --> 00:09:27,600
to my research this is actually the most

242
00:09:27,600 --> 00:09:30,720
common way to sign a Json web token in

243
00:09:30,720 --> 00:09:33,300
my experience asymmetric key signing has

244
00:09:33,300 --> 00:09:34,580
been more popular

245
00:09:34,580 --> 00:09:37,200
but it's pretty straightforward

246
00:09:37,200 --> 00:09:38,399
so

247
00:09:38,399 --> 00:09:40,740
when the party is creating a Json web

248
00:09:40,740 --> 00:09:42,300
token they'll take that header and

249
00:09:42,300 --> 00:09:44,820
payload so the information about how the

250
00:09:44,820 --> 00:09:46,260
token was signed and the information

251
00:09:46,260 --> 00:09:48,959
about who the token was for and they'll

252
00:09:48,959 --> 00:09:51,180
generate a hashed based message

253
00:09:51,180 --> 00:09:53,100
authentication code which is in both

254
00:09:53,100 --> 00:09:56,519
full using the header and payload along

255
00:09:56,519 --> 00:09:58,980
with a shared secret key

256
00:09:58,980 --> 00:10:01,740
this outputs a unique value which they

257
00:10:01,740 --> 00:10:03,480
said is that third section of the Json

258
00:10:03,480 --> 00:10:05,760
web token

259
00:10:05,760 --> 00:10:07,680
um one important thing to note here is

260
00:10:07,680 --> 00:10:09,480
that you don't really have to worry

261
00:10:09,480 --> 00:10:11,100
about how hash based message

262
00:10:11,100 --> 00:10:13,080
authentication codes are working just

263
00:10:13,080 --> 00:10:15,480
know that when you pass in this shared

264
00:10:15,480 --> 00:10:18,180
secret key which is like a password it's

265
00:10:18,180 --> 00:10:21,000
going to Output some unique value and if

266
00:10:21,000 --> 00:10:22,860
anything in the payload of the token

267
00:10:22,860 --> 00:10:24,899
changes like say somebody decodes the

268
00:10:24,899 --> 00:10:26,940
token and changes their email to admin

269
00:10:26,940 --> 00:10:28,500
example.com

270
00:10:28,500 --> 00:10:31,440
then this signature will no longer be

271
00:10:31,440 --> 00:10:33,540
valid and the signing party will reject

272
00:10:33,540 --> 00:10:35,580
the token

273
00:10:35,580 --> 00:10:38,399
so how sorry the receiving party will

274
00:10:38,399 --> 00:10:39,839
reject the token

275
00:10:39,839 --> 00:10:41,940
so what does that actually look like

276
00:10:41,940 --> 00:10:43,920
so the party receiving the token will

277
00:10:43,920 --> 00:10:46,500
follow a similar process they'll take

278
00:10:46,500 --> 00:10:48,540
the header and payload values and

279
00:10:48,540 --> 00:10:50,160
they'll also use this shared secret key

280
00:10:50,160 --> 00:10:52,019
which they've established somehow

281
00:10:52,019 --> 00:10:53,940
beforehand to exchanged with the other

282
00:10:53,940 --> 00:10:55,019
party

283
00:10:55,019 --> 00:10:57,000
and then they'll find the unique value

284
00:10:57,000 --> 00:10:59,220
and compare it to this signature sent in

285
00:10:59,220 --> 00:11:01,800
since these signatures match they'll

286
00:11:01,800 --> 00:11:03,540
know the token is valid and they can

287
00:11:03,540 --> 00:11:05,339
proceed safely

288
00:11:05,339 --> 00:11:07,740
uh kind of the downside of this

289
00:11:07,740 --> 00:11:10,440
symmetric signing approach here is that

290
00:11:10,440 --> 00:11:12,000
although it is pretty straightforward

291
00:11:12,000 --> 00:11:14,820
using the shared secret key establishing

292
00:11:14,820 --> 00:11:17,279
that shared secret key is a little bit

293
00:11:17,279 --> 00:11:19,380
less secure you don't know who all has

294
00:11:19,380 --> 00:11:21,660
access to it so

295
00:11:21,660 --> 00:11:23,579
since the person validating the key has

296
00:11:23,579 --> 00:11:26,279
that same password secret key they could

297
00:11:26,279 --> 00:11:28,140
also generate tokens that would be seen

298
00:11:28,140 --> 00:11:29,640
as valid and if there's other people

299
00:11:29,640 --> 00:11:32,040
that are validating those those tokens

300
00:11:32,040 --> 00:11:34,500
then you can't actually tell who it came

301
00:11:34,500 --> 00:11:35,279
from

302
00:11:35,279 --> 00:11:38,399
since the key is distributed

303
00:11:38,399 --> 00:11:41,940
due to this I've used asymmetric signing

304
00:11:41,940 --> 00:11:45,000
more this is a good approach if you've

305
00:11:45,000 --> 00:11:47,339
got a bunch of micro services and you've

306
00:11:47,339 --> 00:11:49,860
got one service that's only focused on

307
00:11:49,860 --> 00:11:51,420
authentication you don't want the other

308
00:11:51,420 --> 00:11:53,160
services to be able to create their own

309
00:11:53,160 --> 00:11:54,540
tokens at all

310
00:11:54,540 --> 00:11:57,420
so asymmetric signing is like how

311
00:11:57,420 --> 00:11:59,220
cryptocurrency while it works you've got

312
00:11:59,220 --> 00:12:01,680
a private key and a public key and the

313
00:12:01,680 --> 00:12:03,300
private key is only held by the

314
00:12:03,300 --> 00:12:05,399
authentication Service meanwhile the

315
00:12:05,399 --> 00:12:07,980
public key is available on some endpoint

316
00:12:07,980 --> 00:12:10,740
for anybody to access it's public

317
00:12:10,740 --> 00:12:12,360
intentionally and can be used to

318
00:12:12,360 --> 00:12:14,100
validate signatures created with this

319
00:12:14,100 --> 00:12:15,240
private key

320
00:12:15,240 --> 00:12:17,339
so here's what it looks like to actually

321
00:12:17,339 --> 00:12:20,220
create a

322
00:12:20,220 --> 00:12:22,440
signature for a Json web token using

323
00:12:22,440 --> 00:12:24,959
asymmetric signing once again we take

324
00:12:24,959 --> 00:12:27,660
the header and payload and we hash them

325
00:12:27,660 --> 00:12:29,399
which creates a unique value

326
00:12:29,399 --> 00:12:31,920
then since we're the party that's

327
00:12:31,920 --> 00:12:33,600
creating this token we can use our

328
00:12:33,600 --> 00:12:35,640
private key to encrypt that unique value

329
00:12:35,640 --> 00:12:39,260
and add it as the signature

330
00:12:39,420 --> 00:12:41,160
when somebody receives the token and

331
00:12:41,160 --> 00:12:44,399
they need to validate it they will use

332
00:12:44,399 --> 00:12:46,920
the public key of whoever signs that

333
00:12:46,920 --> 00:12:49,380
token to decrypt that third section of

334
00:12:49,380 --> 00:12:52,440
the token the signature this will reveal

335
00:12:52,440 --> 00:12:54,420
what the person that created the token

336
00:12:54,420 --> 00:12:57,959
says the unique value was and then they

337
00:12:57,959 --> 00:12:59,459
can compute the hash of the header and

338
00:12:59,459 --> 00:13:01,320
payload and compare them to make sure

339
00:13:01,320 --> 00:13:03,420
that nothing has changed

340
00:13:03,420 --> 00:13:06,720
due to the nature of asymmetric Keys

341
00:13:06,720 --> 00:13:08,459
um

342
00:13:08,459 --> 00:13:10,139
only the person that holds that private

343
00:13:10,139 --> 00:13:11,399
key would be able to generate that

344
00:13:11,399 --> 00:13:15,019
signature so you know that it's valid

345
00:13:15,120 --> 00:13:16,700
so what does this look like in practice

346
00:13:16,700 --> 00:13:21,060
this is a super simple diagram of what a

347
00:13:21,060 --> 00:13:23,220
microservice architecture might look

348
00:13:23,220 --> 00:13:23,940
like

349
00:13:23,940 --> 00:13:26,100
you can see on the left here we've got

350
00:13:26,100 --> 00:13:28,079
the authentication Service and on the

351
00:13:28,079 --> 00:13:29,639
right is some other service

352
00:13:29,639 --> 00:13:31,320
let's say it sends emails or something

353
00:13:31,320 --> 00:13:33,180
it could really do anything

354
00:13:33,180 --> 00:13:35,820
so step one the clients the laptop down

355
00:13:35,820 --> 00:13:37,620
there will log into the authentication

356
00:13:37,620 --> 00:13:39,300
Service stay with the username and

357
00:13:39,300 --> 00:13:40,260
password

358
00:13:40,260 --> 00:13:42,600
the authentication Service will validate

359
00:13:42,600 --> 00:13:44,220
that username and password and then

360
00:13:44,220 --> 00:13:47,639
create the token for that client's and

361
00:13:47,639 --> 00:13:50,399
sign it with their private key

362
00:13:50,399 --> 00:13:51,899
the token is then sent back to the

363
00:13:51,899 --> 00:13:53,459
client and they can make requests to the

364
00:13:53,459 --> 00:13:55,620
email service for whatever feature they

365
00:13:55,620 --> 00:13:57,959
want say they call an endpoint to send

366
00:13:57,959 --> 00:14:00,060
an email they'll send along that token

367
00:14:00,060 --> 00:14:02,040
in the header of the request and the

368
00:14:02,040 --> 00:14:03,959
other service can

369
00:14:03,959 --> 00:14:06,839
then take that token out of the header

370
00:14:06,839 --> 00:14:08,399
look at the public key for the

371
00:14:08,399 --> 00:14:10,260
authentication Service which is public

372
00:14:10,260 --> 00:14:11,779
and everybody knows

373
00:14:11,779 --> 00:14:14,220
validate the signature and that the

374
00:14:14,220 --> 00:14:16,019
contents of the token haven't changed

375
00:14:16,019 --> 00:14:18,779
validate the tokens not expired and then

376
00:14:18,779 --> 00:14:20,639
finally proceed to do

377
00:14:20,639 --> 00:14:24,000
whatever it wants send the email

378
00:14:24,000 --> 00:14:25,260
so let's break that down into an

379
00:14:25,260 --> 00:14:27,839
algorithm so what we did there was we've

380
00:14:27,839 --> 00:14:29,880
separated the Json web token into its

381
00:14:29,880 --> 00:14:31,980
three segments header payload and

382
00:14:31,980 --> 00:14:33,060
signature

383
00:14:33,060 --> 00:14:35,880
we've decoded the header and payload and

384
00:14:35,880 --> 00:14:37,980
checked from the header which signature

385
00:14:37,980 --> 00:14:40,079
algorithm algorithm we should use to

386
00:14:40,079 --> 00:14:41,579
verify the token

387
00:14:41,579 --> 00:14:44,100
then based on that algorithm we've

388
00:14:44,100 --> 00:14:47,519
verified that the signed hash matches

389
00:14:47,519 --> 00:14:49,560
the header and payload the hash of the

390
00:14:49,560 --> 00:14:51,240
header and payload of the token that we

391
00:14:51,240 --> 00:14:52,380
received

392
00:14:52,380 --> 00:14:54,180
finally we know that's valid so we check

393
00:14:54,180 --> 00:14:56,760
the information is who is this user is

394
00:14:56,760 --> 00:14:58,740
the token expired is it after the time

395
00:14:58,740 --> 00:15:00,779
the token is issued at and then we can

396
00:15:00,779 --> 00:15:02,279
proceed

397
00:15:02,279 --> 00:15:04,680
seems pretty solid right

398
00:15:04,680 --> 00:15:07,079
well there's one fatal flaw in here

399
00:15:07,079 --> 00:15:09,180
that's actually enabled by the Json web

400
00:15:09,180 --> 00:15:12,180
token specification and that's step

401
00:15:12,180 --> 00:15:14,880
three so when you're validating the

402
00:15:14,880 --> 00:15:18,560
header segments of the Json web token

403
00:15:18,560 --> 00:15:22,980
the RFC actually says a none algorithm

404
00:15:22,980 --> 00:15:27,839
is valid to use so what this means is

405
00:15:27,839 --> 00:15:29,940
whoever's receiving the token will check

406
00:15:29,940 --> 00:15:31,860
the header to see which algorithm they

407
00:15:31,860 --> 00:15:34,019
should use to validate the signature

408
00:15:34,019 --> 00:15:36,660
and in the case of none that means don't

409
00:15:36,660 --> 00:15:38,459
validate this token just take it as

410
00:15:38,459 --> 00:15:39,660
valid

411
00:15:39,660 --> 00:15:42,120
so this is actually a pretty a pretty

412
00:15:42,120 --> 00:15:44,279
big foot gun if you're just immediately

413
00:15:44,279 --> 00:15:46,320
writing to the spec of the Json web

414
00:15:46,320 --> 00:15:47,940
tokens

415
00:15:47,940 --> 00:15:48,600
um

416
00:15:48,600 --> 00:15:51,360
and it might seem extremely obvious but

417
00:15:51,360 --> 00:15:53,820
this is actually something that's

418
00:15:53,820 --> 00:15:57,000
fairly common in 2019 I don't know if

419
00:15:57,000 --> 00:15:59,399
you've heard of auth zero they're a

420
00:15:59,399 --> 00:16:01,800
fairly prominent oauth sign-in service

421
00:16:01,800 --> 00:16:04,019
they were actually vulnerable to this

422
00:16:04,019 --> 00:16:08,459
signature algorithm confusion and uh

423
00:16:08,459 --> 00:16:10,320
that meant that any token that was sent

424
00:16:10,320 --> 00:16:13,079
in with the none algorithm uh in a

425
00:16:13,079 --> 00:16:14,519
different casing in their case I guess

426
00:16:14,519 --> 00:16:17,100
they were comparing the actual like

427
00:16:17,100 --> 00:16:19,260
none capitalized to like a different

428
00:16:19,260 --> 00:16:23,240
casing uh was seen as valid

429
00:16:24,180 --> 00:16:27,300
so how do we project against this

430
00:16:27,300 --> 00:16:29,820
well it's pretty straightforward is we

431
00:16:29,820 --> 00:16:31,500
go off of the spec

432
00:16:31,500 --> 00:16:33,839
actually here's a demonstration actually

433
00:16:33,839 --> 00:16:36,240
of what it would look like to attack a

434
00:16:36,240 --> 00:16:37,620
service that's not validating the

435
00:16:37,620 --> 00:16:39,779
algorithm is what they expect

436
00:16:39,779 --> 00:16:40,980
uh

437
00:16:40,980 --> 00:16:42,480
I'm running commands in the terminal

438
00:16:42,480 --> 00:16:44,759
here I'm just creating a header here

439
00:16:44,759 --> 00:16:47,459
with the none algorithm for signing the

440
00:16:47,459 --> 00:16:50,100
token and base64 encoding it then I'm

441
00:16:50,100 --> 00:16:52,620
creating the body of the Json web token

442
00:16:52,620 --> 00:16:54,959
setting the email to whatever I want in

443
00:16:54,959 --> 00:16:58,019
this case admin example.com and since

444
00:16:58,019 --> 00:16:59,880
it's not being validated at all the

445
00:16:59,880 --> 00:17:03,000
service accepts that as correct and

446
00:17:03,000 --> 00:17:05,160
allows me to proceed as admin

447
00:17:05,160 --> 00:17:07,880
example.com

448
00:17:08,040 --> 00:17:09,900
so yeah we can protect against this by

449
00:17:09,900 --> 00:17:12,000
going off the spec and only allowing

450
00:17:12,000 --> 00:17:15,240
specific signature algorithms that we

451
00:17:15,240 --> 00:17:17,760
accept is valid so in our case let's

452
00:17:17,760 --> 00:17:19,859
make sure that the token is using an

453
00:17:19,859 --> 00:17:22,740
rs-256 signature

454
00:17:22,740 --> 00:17:25,799
um most Json web token libraries will

455
00:17:25,799 --> 00:17:27,599
protect you against this and just

456
00:17:27,599 --> 00:17:30,059
decline the none algorithm but it's

457
00:17:30,059 --> 00:17:31,919
worth checking the library using and

458
00:17:31,919 --> 00:17:35,240
making sure that's actually the case

459
00:17:35,520 --> 00:17:38,039
the next vulnerability is in the case of

460
00:17:38,039 --> 00:17:40,380
symmetric key signing so

461
00:17:40,380 --> 00:17:43,679
as I pointed out that secret key is

462
00:17:43,679 --> 00:17:45,360
the keys to the kingdom and if that's

463
00:17:45,360 --> 00:17:48,059
compromised then any token that comes

464
00:17:48,059 --> 00:17:49,280
into your service

465
00:17:49,280 --> 00:17:52,980
could potentially be not correct

466
00:17:52,980 --> 00:17:55,200
um so in my example here I've got a

467
00:17:55,200 --> 00:17:57,059
token that was signed using a symmetric

468
00:17:57,059 --> 00:18:00,360
key it was a really short one sn1f I

469
00:18:00,360 --> 00:18:02,160
found a random two along GitHub called

470
00:18:02,160 --> 00:18:04,740
shotcrack which just brute forces the

471
00:18:04,740 --> 00:18:06,720
secret key used to sign a symmetric key

472
00:18:06,720 --> 00:18:09,600
signed token and I ran it here against

473
00:18:09,600 --> 00:18:11,880
this token and my MacBook was able to

474
00:18:11,880 --> 00:18:15,080
crack it in 10 seconds

475
00:18:16,980 --> 00:18:18,960
so once a party has access to your

476
00:18:18,960 --> 00:18:21,240
secret key they can use any

477
00:18:21,240 --> 00:18:24,240
legitimate tool like job.io this is just

478
00:18:24,240 --> 00:18:26,700
for decoding tokens and modifying them

479
00:18:26,700 --> 00:18:30,059
uh and plug in that secret key and enter

480
00:18:30,059 --> 00:18:32,039
whatever whatever information they want

481
00:18:32,039 --> 00:18:34,260
so you can see here it might be a little

482
00:18:34,260 --> 00:18:35,640
bit small

483
00:18:35,640 --> 00:18:39,840
I set my name to admin example.com and I

484
00:18:39,840 --> 00:18:42,059
plugged in that secret key and it was

485
00:18:42,059 --> 00:18:44,460
valid so anybody that passed that token

486
00:18:44,460 --> 00:18:46,380
into our service would be able to make

487
00:18:46,380 --> 00:18:50,720
whatever calls they wanted as an admin

488
00:18:51,000 --> 00:18:53,400
the protection against this is pretty

489
00:18:53,400 --> 00:18:54,720
straightforward you're just going to

490
00:18:54,720 --> 00:18:56,220
want to use a sufficiently long secret

491
00:18:56,220 --> 00:18:59,039
key the length of that secret key varies

492
00:18:59,039 --> 00:19:01,080
depending on what signing algorithm

493
00:19:01,080 --> 00:19:03,539
you're using

494
00:19:03,539 --> 00:19:06,480
uh kind of building on that a Less

495
00:19:06,480 --> 00:19:09,059
Direct but increasingly common attack

496
00:19:09,059 --> 00:19:10,320
that

497
00:19:10,320 --> 00:19:12,919
I've personally seen growing in the wild

498
00:19:12,919 --> 00:19:14,700
is that

499
00:19:14,700 --> 00:19:16,740
attackers are now going directly after

500
00:19:16,740 --> 00:19:18,960
tokens rather than usernames and

501
00:19:18,960 --> 00:19:20,100
passwords

502
00:19:20,100 --> 00:19:22,919
and the reason for this is that as MFA

503
00:19:22,919 --> 00:19:26,660
is getting more popular uh

504
00:19:26,820 --> 00:19:28,919
if you have a username and password then

505
00:19:28,919 --> 00:19:30,480
you still need access to whatever the

506
00:19:30,480 --> 00:19:32,340
second form of authentication is so

507
00:19:32,340 --> 00:19:34,799
maybe you have to like Sim Jack them and

508
00:19:34,799 --> 00:19:37,020
get access to their actual phone number

509
00:19:37,020 --> 00:19:39,179
to do like a text verification or

510
00:19:39,179 --> 00:19:39,960
something

511
00:19:39,960 --> 00:19:42,539
but as an attacker if you can get access

512
00:19:42,539 --> 00:19:45,120
to the tokens then you can bypass the

513
00:19:45,120 --> 00:19:47,880
whole initial authentication flow and

514
00:19:47,880 --> 00:19:49,559
just make requests until that token

515
00:19:49,559 --> 00:19:52,020
expires so this is a pretty tempting

516
00:19:52,020 --> 00:19:54,600
Target for a user or for an attacker

517
00:19:54,600 --> 00:19:55,940
sorry

518
00:19:55,940 --> 00:19:58,260
so you're going to want to make sure you

519
00:19:58,260 --> 00:20:00,840
store these Json web tokens securely

520
00:20:00,840 --> 00:20:04,080
in my case I prefer storing Json web

521
00:20:04,080 --> 00:20:06,059
tokens in a cookie for the user

522
00:20:06,059 --> 00:20:09,179
experience but this comes with some

523
00:20:09,179 --> 00:20:10,740
pitfalls that I wanted to point out as

524
00:20:10,740 --> 00:20:13,440
well so if you're storing the Json web

525
00:20:13,440 --> 00:20:14,760
token in a cookie you're going to want

526
00:20:14,760 --> 00:20:16,980
to make sure that cookie is secure that

527
00:20:16,980 --> 00:20:20,520
means using an HTTP only cookie which

528
00:20:20,520 --> 00:20:24,240
can only be sent or sorry HTT yeah HTTP

529
00:20:24,240 --> 00:20:27,720
only cookie which can only be accessed

530
00:20:27,720 --> 00:20:29,640
when sending requests it can't be

531
00:20:29,640 --> 00:20:31,620
accessed by JavaScript which means no

532
00:20:31,620 --> 00:20:33,900
malicious scripts in the browser can

533
00:20:33,900 --> 00:20:37,320
actually access that cookie you're also

534
00:20:37,320 --> 00:20:38,700
going to want to make sure the cookie is

535
00:20:38,700 --> 00:20:40,740
set to secure so it's only sent over

536
00:20:40,740 --> 00:20:43,440
https nobody intercepting the traffic

537
00:20:43,440 --> 00:20:45,120
will be able to read the cookie in that

538
00:20:45,120 --> 00:20:46,080
case

539
00:20:46,080 --> 00:20:48,419
and finally if you're not doing some

540
00:20:48,419 --> 00:20:51,360
fancy redirects for single sign-on then

541
00:20:51,360 --> 00:20:53,880
you'll also want to set a same-site flag

542
00:20:53,880 --> 00:20:56,880
on the cookie probably too secure so

543
00:20:56,880 --> 00:21:00,559
that it can't be sent across redirects

544
00:21:00,840 --> 00:21:03,000
the other option is to actually not

545
00:21:03,000 --> 00:21:05,880
store cookies at all this means just

546
00:21:05,880 --> 00:21:08,520
keeping the Json web token in memory

547
00:21:08,520 --> 00:21:11,539
while running your application but

548
00:21:11,539 --> 00:21:13,620
that's a little bit of a trade-off for

549
00:21:13,620 --> 00:21:15,179
user experience because if they refresh

550
00:21:15,179 --> 00:21:18,860
the page they'll log back in

551
00:21:19,260 --> 00:21:22,380
as you saw in both the signature

552
00:21:22,380 --> 00:21:25,140
algorithm confusion and a secret brute

553
00:21:25,140 --> 00:21:26,480
forcing attacks

554
00:21:26,480 --> 00:21:28,799
the most important thing is definitely

555
00:21:28,799 --> 00:21:30,900
storing your keys securely that you're

556
00:21:30,900 --> 00:21:33,559
using to sign these tokens

557
00:21:33,559 --> 00:21:36,360
the best thing to do is to store the key

558
00:21:36,360 --> 00:21:38,100
in a place that it can't be accessed at

559
00:21:38,100 --> 00:21:41,640
all like an Hardware signed Hardware

560
00:21:41,640 --> 00:21:43,440
certificate manager or something like

561
00:21:43,440 --> 00:21:47,280
that like AWS HSM I'd recommend

562
00:21:47,280 --> 00:21:49,919
something like AWS Key Management so

563
00:21:49,919 --> 00:21:52,380
only the parties that are expected to be

564
00:21:52,380 --> 00:21:54,659
able to access the key can access it or

565
00:21:54,659 --> 00:21:56,580
something like vaults so that's more

566
00:21:56,580 --> 00:21:57,960
auditable

567
00:21:57,960 --> 00:22:00,480
anybody calling in to access your keys

568
00:22:00,480 --> 00:22:03,120
you can see who's using them and in the

569
00:22:03,120 --> 00:22:05,460
unfortunate case that your secret key

570
00:22:05,460 --> 00:22:07,679
actually is compromised it's much easier

571
00:22:07,679 --> 00:22:10,380
to roll it it's contained only in one

572
00:22:10,380 --> 00:22:12,360
place you can go change it there rather

573
00:22:12,360 --> 00:22:13,919
than finding everywhere the secret key

574
00:22:13,919 --> 00:22:15,840
is just stored in the environments and

575
00:22:15,840 --> 00:22:19,100
going and change them individually

576
00:22:22,200 --> 00:22:24,480
so we've gone through the main security

577
00:22:24,480 --> 00:22:27,179
pitfalls

578
00:22:27,179 --> 00:22:30,480
but I think another common Pitfall that

579
00:22:30,480 --> 00:22:33,240
I wanted to point out was making sure

580
00:22:33,240 --> 00:22:35,820
you're actually using Json web tokens in

581
00:22:35,820 --> 00:22:38,100
a way that makes sense

582
00:22:38,100 --> 00:22:42,480
so Json web tokens really shine in a

583
00:22:42,480 --> 00:22:44,880
distributed environment they're

584
00:22:44,880 --> 00:22:46,620
stateless which means you don't have to

585
00:22:46,620 --> 00:22:48,419
call into some Central authentication

586
00:22:48,419 --> 00:22:51,299
Service to make sure they're valid and

587
00:22:51,299 --> 00:22:54,120
this is good for if you're making calls

588
00:22:54,120 --> 00:22:57,120
to many like distributed systems they

589
00:22:57,120 --> 00:22:59,340
don't have to call back always to

590
00:22:59,340 --> 00:23:01,080
validate the token they know the public

591
00:23:01,080 --> 00:23:02,880
key so they can validate what it says is

592
00:23:02,880 --> 00:23:03,840
true

593
00:23:03,840 --> 00:23:06,120
this will reduce their Network calls

594
00:23:06,120 --> 00:23:08,820
reduce latency and it's also nice just

595
00:23:08,820 --> 00:23:10,140
to be able to assert some information

596
00:23:10,140 --> 00:23:12,480
about whoever's calling your service by

597
00:23:12,480 --> 00:23:15,679
checking the token they used

598
00:23:15,720 --> 00:23:18,120
uh but you might not even need a Json

599
00:23:18,120 --> 00:23:21,500
web token so if you're using just like a

600
00:23:21,500 --> 00:23:24,539
monolithic or simple service then

601
00:23:24,539 --> 00:23:26,520
session tokens might still be enough and

602
00:23:26,520 --> 00:23:27,960
you don't need to worry about any of

603
00:23:27,960 --> 00:23:29,880
this complicated stuff at all

604
00:23:29,880 --> 00:23:32,820
so it's tried and true just creating

605
00:23:32,820 --> 00:23:35,159
like a simple hash secret to send back

606
00:23:35,159 --> 00:23:38,039
to the users and then validating that

607
00:23:38,039 --> 00:23:39,539
when the request comes in if you have

608
00:23:39,539 --> 00:23:42,299
quick access to the database

609
00:23:42,299 --> 00:23:44,360
um

610
00:23:46,080 --> 00:23:48,120
the other kind of downfall of Json web

611
00:23:48,120 --> 00:23:50,100
tokens that I didn't really touch on

612
00:23:50,100 --> 00:23:51,780
earlier was that due to their

613
00:23:51,780 --> 00:23:53,760
statelessness if you need to invalidate

614
00:23:53,760 --> 00:23:56,880
them then it can be a bit of a pain so

615
00:23:56,880 --> 00:23:58,740
since you're accepting any token that's

616
00:23:58,740 --> 00:24:01,559
signed as valid up until it expires

617
00:24:01,559 --> 00:24:03,780
there's no way to revoke it unless you

618
00:24:03,780 --> 00:24:06,659
do some complicated stuff like a token

619
00:24:06,659 --> 00:24:09,360
block list but that kind of defeats the

620
00:24:09,360 --> 00:24:11,580
purpose of using Json web tokens

621
00:24:11,580 --> 00:24:15,539
so that's another Pitfall is that

622
00:24:15,539 --> 00:24:17,400
session tokens can be easily revoked

623
00:24:17,400 --> 00:24:19,919
Json web tokens might be valid for the

624
00:24:19,919 --> 00:24:21,480
duration of their lifetime

625
00:24:21,480 --> 00:24:22,679
so you're going to want to make sure

626
00:24:22,679 --> 00:24:25,140
also to keep the session lifetime of the

627
00:24:25,140 --> 00:24:28,880
Json web token as low as you can

628
00:24:29,400 --> 00:24:31,559
so that's it we have the base knowledge

629
00:24:31,559 --> 00:24:34,020
to create verify and securely work with

630
00:24:34,020 --> 00:24:37,679
Json web tokens you can go forth now and

631
00:24:37,679 --> 00:24:39,360
check that make your make sure that your

632
00:24:39,360 --> 00:24:41,039
libraries are actually validating Json

633
00:24:41,039 --> 00:24:42,659
web tokens correctly

634
00:24:42,659 --> 00:24:44,280
and that you're creating them correctly

635
00:24:44,280 --> 00:24:47,400
thanks for coming out if you'd like to

636
00:24:47,400 --> 00:24:49,200
talk with me about tokens at all I'll be

637
00:24:49,200 --> 00:24:51,120
at the infra booth at the conference

638
00:24:51,120 --> 00:24:53,159
floor I'd love to hear from you

639
00:24:53,159 --> 00:24:54,660
thank you

640
00:24:54,660 --> 00:24:57,660
[Applause]

