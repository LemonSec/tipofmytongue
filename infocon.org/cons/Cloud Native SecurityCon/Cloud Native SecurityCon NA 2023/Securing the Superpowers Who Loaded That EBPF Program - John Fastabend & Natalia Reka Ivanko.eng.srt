1
00:00:00,840 --> 00:00:03,419
um so hello welcome everyone on one of

2
00:00:03,419 --> 00:00:05,759
the last talk today so it's going to be

3
00:00:05,759 --> 00:00:08,580
about securing the superpowers and who

4
00:00:08,580 --> 00:00:11,280
loaded the evpf program so basically

5
00:00:11,280 --> 00:00:14,040
auditing ebpf programs

6
00:00:14,040 --> 00:00:17,100
so who is speaking today I'm Natalia I'm

7
00:00:17,100 --> 00:00:19,140
a security product lead at ISO villain

8
00:00:19,140 --> 00:00:22,380
and here is with me John who is a

9
00:00:22,380 --> 00:00:24,720
tetragon lead and psyllium maintainer as

10
00:00:24,720 --> 00:00:28,019
well as staff engineer at ISO Island

11
00:00:28,019 --> 00:00:30,539
so I wanted to start with a background

12
00:00:30,539 --> 00:00:32,700
and the motivation to this talk first

13
00:00:32,700 --> 00:00:35,460
and as you already know like evpf is on

14
00:00:35,460 --> 00:00:38,460
the rise or already Rose it became one

15
00:00:38,460 --> 00:00:40,379
of the leading Linux kernel technology

16
00:00:40,379 --> 00:00:41,940
today

17
00:00:41,940 --> 00:00:44,340
so more and more projects are using it

18
00:00:44,340 --> 00:00:46,200
under the hood for different use cases

19
00:00:46,200 --> 00:00:49,200
for example networking observability and

20
00:00:49,200 --> 00:00:50,219
security

21
00:00:50,219 --> 00:00:52,500
so this is just a small subset of

22
00:00:52,500 --> 00:00:54,780
projects that are using ebpf but this

23
00:00:54,780 --> 00:00:57,120
would give you a glimpse of what can be

24
00:00:57,120 --> 00:00:58,860
done in different areas

25
00:00:58,860 --> 00:01:01,440
so for example in networking it can be

26
00:01:01,440 --> 00:01:03,539
used for high performance and load

27
00:01:03,539 --> 00:01:06,240
balancing in other data centers as well

28
00:01:06,240 --> 00:01:08,700
as in Cloud native environments so one

29
00:01:08,700 --> 00:01:11,340
good example is catron which is a high

30
00:01:11,340 --> 00:01:13,260
performance load balancing from Facebook

31
00:01:13,260 --> 00:01:16,560
that they created to replace ipvs this

32
00:01:16,560 --> 00:01:18,479
is another software-based load branching

33
00:01:18,479 --> 00:01:20,759
solution so they switched actually to

34
00:01:20,759 --> 00:01:22,740
ebpf and saw a massive performance

35
00:01:22,740 --> 00:01:25,619
increase this is actually open source so

36
00:01:25,619 --> 00:01:27,720
you can actually go to the GitHub

37
00:01:27,720 --> 00:01:30,360
repository and check it out it's

38
00:01:30,360 --> 00:01:32,580
Facebook specific but good for other

39
00:01:32,580 --> 00:01:34,500
Linux based software infrastructure

40
00:01:34,500 --> 00:01:36,240
systems as well

41
00:01:36,240 --> 00:01:39,180
so we have celium which is providing

42
00:01:39,180 --> 00:01:41,340
networking load balancing security for

43
00:01:41,340 --> 00:01:43,640
kubernetes services

44
00:01:43,640 --> 00:01:46,500
on the observability side in the middle

45
00:01:46,500 --> 00:01:49,920
we have BCC and BPF trees so these are

46
00:01:49,920 --> 00:01:52,979
for application profiling and tracing so

47
00:01:52,979 --> 00:01:55,100
for example understanding what my

48
00:01:55,100 --> 00:01:58,320
application is doing what my my

49
00:01:58,320 --> 00:02:00,720
application is not behaving the way we

50
00:02:00,720 --> 00:02:03,180
expect for example how many block I

51
00:02:03,180 --> 00:02:05,460
occurs it's using and so on

52
00:02:05,460 --> 00:02:08,459
we have Hubble which is the visibility

53
00:02:08,459 --> 00:02:11,280
component of psyllium and it can use for

54
00:02:11,280 --> 00:02:12,780
example for Network policy

55
00:02:12,780 --> 00:02:15,480
troubleshooting auditing so for example

56
00:02:15,480 --> 00:02:18,239
which network flows are denied by which

57
00:02:18,239 --> 00:02:20,700
network we see what is the source spot

58
00:02:20,700 --> 00:02:22,260
and so on

59
00:02:22,260 --> 00:02:25,319
and then for security so we will deep

60
00:02:25,319 --> 00:02:27,900
dive into these use cases later but we

61
00:02:27,900 --> 00:02:30,360
have tetragon and Falco which is

62
00:02:30,360 --> 00:02:32,520
applying BPF for container runtime

63
00:02:32,520 --> 00:02:35,160
security so inspect the kernel function

64
00:02:35,160 --> 00:02:37,680
system cause and figuring out if a

65
00:02:37,680 --> 00:02:39,840
malicious behavior has happened

66
00:02:39,840 --> 00:02:42,540
we can also Implement for example these

67
00:02:42,540 --> 00:02:45,540
privilege policies and then we can

68
00:02:45,540 --> 00:02:48,660
create proflies based on the observed

69
00:02:48,660 --> 00:02:51,840
event and then we should say like these

70
00:02:51,840 --> 00:02:55,080
are only the allow Demons by that Source

71
00:02:55,080 --> 00:02:57,360
but and then we should prevent

72
00:02:57,360 --> 00:03:00,180
everything else we can also use BPF for

73
00:03:00,180 --> 00:03:03,200
preventative security so terminate any

74
00:03:03,200 --> 00:03:05,940
kernel functions or system calls inside

75
00:03:05,940 --> 00:03:08,640
the kernel instead of having like a user

76
00:03:08,640 --> 00:03:12,200
space agent observing it

77
00:03:12,420 --> 00:03:14,760
so for example these are two security

78
00:03:14,760 --> 00:03:17,700
use cases that we can do one is data ex

79
00:03:17,700 --> 00:03:19,500
filtration so a security team can

80
00:03:19,500 --> 00:03:21,599
observe occupancy's namespace and figure

81
00:03:21,599 --> 00:03:24,360
out like which which parts were the most

82
00:03:24,360 --> 00:03:26,940
outbound to occurs in the last hour is

83
00:03:26,940 --> 00:03:29,340
it expected who sent out the most

84
00:03:29,340 --> 00:03:32,700
traffic can it be detox filtration

85
00:03:32,700 --> 00:03:34,800
and we can also do like file Integrity

86
00:03:34,800 --> 00:03:37,739
monitoring so which pods or workloads

87
00:03:37,739 --> 00:03:40,560
open sensitive files with which binaries

88
00:03:40,560 --> 00:03:44,879
who was root and is it even expected

89
00:03:44,879 --> 00:03:47,819
we can also do capability and namespace

90
00:03:47,819 --> 00:03:50,040
success monitoring so security team

91
00:03:50,040 --> 00:03:52,560
camera for example certain name spaces

92
00:03:52,560 --> 00:03:55,019
and ask questions like which ports were

93
00:03:55,019 --> 00:03:57,599
running with cops's admin or cut net

94
00:03:57,599 --> 00:04:01,080
rule do we expect this which which ports

95
00:04:01,080 --> 00:04:03,540
had for example whose speed or network

96
00:04:03,540 --> 00:04:06,000
names with success do we even expect

97
00:04:06,000 --> 00:04:08,940
this how long who started this spot and

98
00:04:08,940 --> 00:04:11,299
so on

99
00:04:11,879 --> 00:04:14,659
so EVPs became cross-platform

100
00:04:14,659 --> 00:04:17,160
and windows machines with the windows

101
00:04:17,160 --> 00:04:19,738
runtime recently it's available on most

102
00:04:19,738 --> 00:04:22,560
Linux distributions and then all the

103
00:04:22,560 --> 00:04:26,160
major Cloud providers also supports

104
00:04:26,160 --> 00:04:27,720
so

105
00:04:27,720 --> 00:04:30,540
um as a motivation since EVP has become

106
00:04:30,540 --> 00:04:31,979
so powerful

107
00:04:31,979 --> 00:04:34,560
security teams needs to answer functions

108
00:04:34,560 --> 00:04:37,680
like who is watching evpf

109
00:04:37,680 --> 00:04:40,620
um during a secure it's actually

110
00:04:40,620 --> 00:04:43,259
important to keep track and audit which

111
00:04:43,259 --> 00:04:46,080
BPF programs have alluded and then which

112
00:04:46,080 --> 00:04:48,840
ppf's map were created

113
00:04:48,840 --> 00:04:50,699
so what does how did it mean exactly

114
00:04:50,699 --> 00:04:53,460
like who what did it which guberty's

115
00:04:53,460 --> 00:04:55,800
workload which process of each binary

116
00:04:55,800 --> 00:04:57,720
from which ancestors

117
00:04:57,720 --> 00:04:59,820
when was it loaded

118
00:04:59,820 --> 00:05:02,639
um should this program be expected have

119
00:05:02,639 --> 00:05:04,979
you seen this program or process before

120
00:05:04,979 --> 00:05:09,360
and should this process touch BPS at all

121
00:05:09,360 --> 00:05:11,220
so these are the questions that we are

122
00:05:11,220 --> 00:05:13,020
trying to answer today with

123
00:05:13,020 --> 00:05:14,520
um tetragon

124
00:05:14,520 --> 00:05:16,199
okay

125
00:05:16,199 --> 00:05:18,800
hey everyone

126
00:05:19,800 --> 00:05:22,500
awesome all right so first I want to

127
00:05:22,500 --> 00:05:24,240
talk about tetragon so that's our tool

128
00:05:24,240 --> 00:05:26,280
right and um and we saw some of the use

129
00:05:26,280 --> 00:05:28,199
cases that it solves and we saw some of

130
00:05:28,199 --> 00:05:30,120
the dashboards that you can create and

131
00:05:30,120 --> 00:05:31,740
so I'm going to kind of talk a little

132
00:05:31,740 --> 00:05:33,720
bit about the architecture here from

133
00:05:33,720 --> 00:05:35,520
this um this cartoon but at least it

134
00:05:35,520 --> 00:05:37,139
gives you the big kind of bullet points

135
00:05:37,139 --> 00:05:39,539
and then from there we can dive into how

136
00:05:39,539 --> 00:05:42,780
we address the BPF monitoring piece of

137
00:05:42,780 --> 00:05:44,580
it that specific part that the talk is

138
00:05:44,580 --> 00:05:47,220
going to focus on so first what is

139
00:05:47,220 --> 00:05:49,139
tetragon it's our security observability

140
00:05:49,139 --> 00:05:51,600
and runtime enforcement what this means

141
00:05:51,600 --> 00:05:54,060
is you take BPF you hook the Linux

142
00:05:54,060 --> 00:05:55,860
kernel and you can hook all of these

143
00:05:55,860 --> 00:05:58,080
locations right use it the tcpip stack

144
00:05:58,080 --> 00:05:59,639
you can hook system calls to process

145
00:05:59,639 --> 00:06:02,639
execution file systems you get all of

146
00:06:02,639 --> 00:06:05,100
your c groups and namespace monitoring

147
00:06:05,100 --> 00:06:07,440
right and and what tetragon can do

148
00:06:07,440 --> 00:06:09,900
inside is kubernetes since we're at the

149
00:06:09,900 --> 00:06:12,479
cncf here is you can take all of that

150
00:06:12,479 --> 00:06:15,900
kernel level data and put on top of it

151
00:06:15,900 --> 00:06:18,539
the kubernetes metadata and get

152
00:06:18,539 --> 00:06:20,220
something that operators and people that

153
00:06:20,220 --> 00:06:21,720
monitor and manage kubernetes

154
00:06:21,720 --> 00:06:23,400
environments can make some sense of

155
00:06:23,400 --> 00:06:26,039
right because if you didn't do this and

156
00:06:26,039 --> 00:06:27,479
you just said okay I'm going to put a

157
00:06:27,479 --> 00:06:29,340
BPF probe here maybe I'm running BPF

158
00:06:29,340 --> 00:06:31,979
trace or I'm running BCC tools if you're

159
00:06:31,979 --> 00:06:33,360
familiar with that these are kind of low

160
00:06:33,360 --> 00:06:36,180
level BPF things what you would really

161
00:06:36,180 --> 00:06:39,240
just get out of your system then is uh

162
00:06:39,240 --> 00:06:42,360
you know PID name a random PID launch

163
00:06:42,360 --> 00:06:45,479
some file fd3 and oh by the way it's in

164
00:06:45,479 --> 00:06:47,280
some random C group on some random node

165
00:06:47,280 --> 00:06:48,840
in your system right so what you really

166
00:06:48,840 --> 00:06:50,940
want to do is up level all of that and

167
00:06:50,940 --> 00:06:52,560
that's what tetragon is really good at

168
00:06:52,560 --> 00:06:54,900
doing taking these low-level data so you

169
00:06:54,900 --> 00:06:57,539
can monitor all your files monitor all

170
00:06:57,539 --> 00:06:59,940
your execution create a nice execution

171
00:06:59,940 --> 00:07:02,520
trace for anywhere in your cluster along

172
00:07:02,520 --> 00:07:04,919
with timestamps into a data stream right

173
00:07:04,919 --> 00:07:06,960
so now you can analyze all of that data

174
00:07:06,960 --> 00:07:10,080
right you can ask questions like what

175
00:07:10,080 --> 00:07:12,419
executed three days ago on this system

176
00:07:12,419 --> 00:07:15,479
and what programs did it run what files

177
00:07:15,479 --> 00:07:18,300
did it open who did it connect to this

178
00:07:18,300 --> 00:07:19,620
question

179
00:07:19,620 --> 00:07:21,419
um you might even ask you know what are

180
00:07:21,419 --> 00:07:24,180
the DNS entries for those IP addresses

181
00:07:24,180 --> 00:07:26,400
that I saw these connects for and what's

182
00:07:26,400 --> 00:07:28,740
really interesting for today what BPF

183
00:07:28,740 --> 00:07:31,800
programs did it launch right

184
00:07:31,800 --> 00:07:35,180
um because that's what we want to answer

185
00:07:35,580 --> 00:07:36,960
so

186
00:07:36,960 --> 00:07:38,819
when we talk about BPF the next thing we

187
00:07:38,819 --> 00:07:40,319
want to talk about is what is a BPF

188
00:07:40,319 --> 00:07:43,380
program right so typically I think of an

189
00:07:43,380 --> 00:07:44,940
application program you're thinking of a

190
00:07:44,940 --> 00:07:46,740
set of a like an executable something

191
00:07:46,740 --> 00:07:48,960
that you launched but BPF is slightly

192
00:07:48,960 --> 00:07:50,280
different for one that runs in the

193
00:07:50,280 --> 00:07:52,199
kernel that's also interesting but what

194
00:07:52,199 --> 00:07:54,060
is kind of interesting from the question

195
00:07:54,060 --> 00:07:57,060
of what's running is that BPF is not

196
00:07:57,060 --> 00:07:58,919
just a set of instructions there's an

197
00:07:58,919 --> 00:08:01,020
entire run time around it so you can

198
00:08:01,020 --> 00:08:02,639
think of it as a set of instructions

199
00:08:02,639 --> 00:08:05,099
plus all this other stuff and the other

200
00:08:05,099 --> 00:08:07,979
stuff here include core what core does

201
00:08:07,979 --> 00:08:10,919
is when you load your BPF program it's

202
00:08:10,919 --> 00:08:12,660
actually a runtime rewriting kind of

203
00:08:12,660 --> 00:08:14,699
framework and so it takes the program it

204
00:08:14,699 --> 00:08:16,319
loads it in you're going to replace a

205
00:08:16,319 --> 00:08:19,259
bunch of the instructions with kernel

206
00:08:19,259 --> 00:08:21,840
specifics so if you think about I want

207
00:08:21,840 --> 00:08:23,940
to read a structure a field in a

208
00:08:23,940 --> 00:08:25,919
structure maybe the PID of a task or

209
00:08:25,919 --> 00:08:28,379
something and when you do that that PID

210
00:08:28,379 --> 00:08:30,120
location that structure you're going to

211
00:08:30,120 --> 00:08:33,059
say read the task struct and then read

212
00:08:33,059 --> 00:08:35,279
the offset into that task direct is not

213
00:08:35,279 --> 00:08:37,320
the same across all the kernels so what

214
00:08:37,320 --> 00:08:38,820
it will do when you load your program

215
00:08:38,820 --> 00:08:40,320
but the core infrastructure does is

216
00:08:40,320 --> 00:08:41,820
rewrite those instructions so that they

217
00:08:41,820 --> 00:08:43,080
actually read what you're interested in

218
00:08:43,080 --> 00:08:45,060
so for one that's interesting because

219
00:08:45,060 --> 00:08:46,620
now your set of instructions that you

220
00:08:46,620 --> 00:08:48,120
downloaded onto your program it's not

221
00:08:48,120 --> 00:08:49,200
the same instructions that you actually

222
00:08:49,200 --> 00:08:50,940
run okay

223
00:08:50,940 --> 00:08:53,220
um just one I one kind of point on why

224
00:08:53,220 --> 00:08:55,740
your BPF program is sort of different

225
00:08:55,740 --> 00:08:58,260
than just a set of instructions in

226
00:08:58,260 --> 00:09:00,360
addition you have a bunch of maps so the

227
00:09:00,360 --> 00:09:02,519
maps are the piece between BPF

228
00:09:02,519 --> 00:09:04,560
um between the kernel and user space

229
00:09:04,560 --> 00:09:06,420
that communicate between the different

230
00:09:06,420 --> 00:09:08,580
programs so your kernel piece might

231
00:09:08,580 --> 00:09:10,680
write to that BPF map but also multiple

232
00:09:10,680 --> 00:09:12,120
user space applications might write to

233
00:09:12,120 --> 00:09:13,500
that map are multiple kernel pieces

234
00:09:13,500 --> 00:09:14,700
might write to that Spectrum so if you

235
00:09:14,700 --> 00:09:16,320
think about it it's almost like a um

236
00:09:16,320 --> 00:09:18,000
like a message bus between different

237
00:09:18,000 --> 00:09:20,700
programs and applications it can be

238
00:09:20,700 --> 00:09:22,800
memory mapped for example so that

239
00:09:22,800 --> 00:09:25,140
influences what map that program is

240
00:09:25,140 --> 00:09:26,700
attached to will influence kind of what

241
00:09:26,700 --> 00:09:28,560
the system is doing

242
00:09:28,560 --> 00:09:29,820
um and then you know there's what are

243
00:09:29,820 --> 00:09:31,740
you connected to what type of program

244
00:09:31,740 --> 00:09:34,019
you are and so on

245
00:09:34,019 --> 00:09:36,720
um and all that together in my mind is

246
00:09:36,720 --> 00:09:38,279
actually what you want to monitor you

247
00:09:38,279 --> 00:09:40,320
want to monitor that bundle of BPF stuff

248
00:09:40,320 --> 00:09:43,320
because if you imagine a BPF program

249
00:09:43,320 --> 00:09:45,060
that's connected to the wrong map is

250
00:09:45,060 --> 00:09:48,360
going to be buggy or Worse malicious a

251
00:09:48,360 --> 00:09:49,740
BPF program that's attached to the wrong

252
00:09:49,740 --> 00:09:52,500
function isn't going to work either in

253
00:09:52,500 --> 00:09:54,180
the way you expect so you really want to

254
00:09:54,180 --> 00:09:57,300
get that full full profile

255
00:09:57,300 --> 00:09:58,080
um

256
00:09:58,080 --> 00:10:00,000
this is a diagram that Brendan Gregg

257
00:10:00,000 --> 00:10:01,440
made and then we modified it slightly

258
00:10:01,440 --> 00:10:02,700
Daniel borkman

259
00:10:02,700 --> 00:10:04,260
um one of my colleagues also modified it

260
00:10:04,260 --> 00:10:07,620
and what it shows Is That Flow graph of

261
00:10:07,620 --> 00:10:10,140
what loading a BPF program involves and

262
00:10:10,140 --> 00:10:11,399
so on the right side you see the

263
00:10:11,399 --> 00:10:13,140
application side what is the BPF

264
00:10:13,140 --> 00:10:14,820
application or sorry

265
00:10:14,820 --> 00:10:17,100
yeah left side you see the BPF

266
00:10:17,100 --> 00:10:20,040
application and what we have over there

267
00:10:20,040 --> 00:10:22,380
is like the instructions like we talked

268
00:10:22,380 --> 00:10:24,060
about you have a compiler because at

269
00:10:24,060 --> 00:10:26,339
some point you need to create probably C

270
00:10:26,339 --> 00:10:28,500
code into bytecode

271
00:10:28,500 --> 00:10:30,540
um and you create your maps and all this

272
00:10:30,540 --> 00:10:31,680
kind of stuff and then what we see

273
00:10:31,680 --> 00:10:33,779
between the left and the right side is

274
00:10:33,779 --> 00:10:36,420
the boundary between the um between the

275
00:10:36,420 --> 00:10:39,360
kernel and the user space slide and you

276
00:10:39,360 --> 00:10:41,279
see a bunch of different objects you can

277
00:10:41,279 --> 00:10:43,440
modify the bottom there you have

278
00:10:43,440 --> 00:10:46,320
perforing BPF ring buffer shared Maps

279
00:10:46,320 --> 00:10:48,240
Perforating is just a high performance

280
00:10:48,240 --> 00:10:49,500
way to get stuff out of the kernel

281
00:10:49,500 --> 00:10:52,620
between user space and kernel shared BPF

282
00:10:52,620 --> 00:10:54,300
Maps or any of the other map types we

283
00:10:54,300 --> 00:10:57,380
have hash Maps array Maps

284
00:10:57,380 --> 00:11:00,779
Stacks so on people are always adding

285
00:11:00,779 --> 00:11:02,940
new things there and then the top is

286
00:11:02,940 --> 00:11:05,160
where you actually load your programs

287
00:11:05,160 --> 00:11:06,240
which is actually done through a system

288
00:11:06,240 --> 00:11:09,180
call and um

289
00:11:09,180 --> 00:11:12,240
and loaded that way with an opcode

290
00:11:12,240 --> 00:11:14,399
so when we think about monitoring this

291
00:11:14,399 --> 00:11:16,079
the question is like how do we want to

292
00:11:16,079 --> 00:11:19,079
monitor this well we don't want to hook

293
00:11:19,079 --> 00:11:23,880
the syscalls directly usually there's a

294
00:11:23,880 --> 00:11:26,820
good reason for that one of them being

295
00:11:26,820 --> 00:11:28,019
that we don't want to hook every

296
00:11:28,019 --> 00:11:29,760
possible syscall that interfaces with

297
00:11:29,760 --> 00:11:32,220
BPF and so what we do is we hook the BPF

298
00:11:32,220 --> 00:11:34,740
verifier the verifier is the piece that

299
00:11:34,740 --> 00:11:36,360
when you load your program it's going to

300
00:11:36,360 --> 00:11:37,860
make sure your program is safe to run in

301
00:11:37,860 --> 00:11:39,240
the kernel it's going to make sure it's

302
00:11:39,240 --> 00:11:41,160
not writing to random data trying not to

303
00:11:41,160 --> 00:11:42,920
make sure it's not reading random data

304
00:11:42,920 --> 00:11:46,140
it'll also do other things for safety uh

305
00:11:46,140 --> 00:11:48,420
check for divide by zero those kind of

306
00:11:48,420 --> 00:11:49,380
things that you would think of what

307
00:11:49,380 --> 00:11:51,540
should normally cause seg faults in

308
00:11:51,540 --> 00:11:52,940
normal programs

309
00:11:52,940 --> 00:11:55,140
so there's one one reason to put it

310
00:11:55,140 --> 00:11:56,160
there is just because it's the central

311
00:11:56,160 --> 00:11:57,839
place where all BPF programs come

312
00:11:57,839 --> 00:12:00,360
through the other advantage of having it

313
00:12:00,360 --> 00:12:02,640
there is it's after the user to Kernel

314
00:12:02,640 --> 00:12:06,060
space copy okay so one thing about BPF

315
00:12:06,060 --> 00:12:08,459
if you hook a syscall what can happen is

316
00:12:08,459 --> 00:12:10,980
if you try to read user memory which is

317
00:12:10,980 --> 00:12:12,899
just a pointer into user memory it's

318
00:12:12,899 --> 00:12:15,060
entirely owned by the user space process

319
00:12:15,060 --> 00:12:17,459
at that point right so from a security

320
00:12:17,459 --> 00:12:18,899
standpoint we don't want to try to read

321
00:12:18,899 --> 00:12:20,220
user memory

322
00:12:20,220 --> 00:12:22,079
and race with a user right because a

323
00:12:22,079 --> 00:12:23,640
user owns the memory they can they can

324
00:12:23,640 --> 00:12:25,260
change the data right so if we're trying

325
00:12:25,260 --> 00:12:27,660
to do a security property and we say I

326
00:12:27,660 --> 00:12:29,640
want to read your instructions or read

327
00:12:29,640 --> 00:12:31,500
the name of your BPF program

328
00:12:31,500 --> 00:12:34,500
and I'm going to say do some some

329
00:12:34,500 --> 00:12:36,120
analysis of that program from the BPS

330
00:12:36,120 --> 00:12:37,740
side or even if I'm going to copy it out

331
00:12:37,740 --> 00:12:39,899
to user space for sort of post analysis

332
00:12:39,899 --> 00:12:42,600
I need to make sure that I can't do that

333
00:12:42,600 --> 00:12:44,820
copy and then have the user just change

334
00:12:44,820 --> 00:12:46,980
the data right there's also a more

335
00:12:46,980 --> 00:12:48,779
fundamental reason

336
00:12:48,779 --> 00:12:50,579
um would be that user space can actually

337
00:12:50,579 --> 00:12:52,680
just fault right you try to read user

338
00:12:52,680 --> 00:12:54,180
memory it's not in

339
00:12:54,180 --> 00:12:55,019
um

340
00:12:55,019 --> 00:12:56,459
it's not in Cache it's going to fault

341
00:12:56,459 --> 00:12:59,880
and then because BPF on most instances

342
00:12:59,880 --> 00:13:01,920
does not want to sleep will not be able

343
00:13:01,920 --> 00:13:04,320
to pull that fault into the memory and

344
00:13:04,320 --> 00:13:05,700
so what you'll get is just an error

345
00:13:05,700 --> 00:13:08,519
you'll get no data and now you have a

346
00:13:08,519 --> 00:13:11,639
big glaring Gap in your um in your

347
00:13:11,639 --> 00:13:13,740
security analysis tools presumably

348
00:13:13,740 --> 00:13:15,839
running behind this

349
00:13:15,839 --> 00:13:18,480
um so that's why we hook BPF verify the

350
00:13:18,480 --> 00:13:19,800
summary is we see every BPF program

351
00:13:19,800 --> 00:13:21,720
that's loaded we've put a BPF program

352
00:13:21,720 --> 00:13:23,820
right on that call anytime you load

353
00:13:23,820 --> 00:13:25,980
something we'll get a call back and then

354
00:13:25,980 --> 00:13:27,420
I'll talk in the next couple slides what

355
00:13:27,420 --> 00:13:29,220
we do with that callback and then we

356
00:13:29,220 --> 00:13:31,620
also hook these other entries you have

357
00:13:31,620 --> 00:13:32,700
to be a little bit careful for the

358
00:13:32,700 --> 00:13:33,899
syscall reason

359
00:13:33,899 --> 00:13:36,360
um they're actually done on the other

360
00:13:36,360 --> 00:13:38,519
side of the copy inside

361
00:13:38,519 --> 00:13:40,019
that was this call so they're not

362
00:13:40,019 --> 00:13:41,760
technically ciscalled but in this box we

363
00:13:41,760 --> 00:13:43,680
just show them on the edge there

364
00:13:43,680 --> 00:13:44,279
um

365
00:13:44,279 --> 00:13:46,200
and those are for all your maps and the

366
00:13:46,200 --> 00:13:47,700
important thing is um if you look at

367
00:13:47,700 --> 00:13:49,560
that dotted line everything that's going

368
00:13:49,560 --> 00:13:51,180
from the user space to Kernel space

369
00:13:51,180 --> 00:13:53,880
going across that dotted line can't get

370
00:13:53,880 --> 00:13:56,339
to the core networking part in this

371
00:13:56,339 --> 00:13:58,079
example but we have other slides that

372
00:13:58,079 --> 00:13:59,639
show kind of K probes and other things

373
00:13:59,639 --> 00:14:01,680
can't get to the far right without going

374
00:14:01,680 --> 00:14:03,839
from one of our red boxes from left to

375
00:14:03,839 --> 00:14:05,959
right

376
00:14:09,000 --> 00:14:12,959
oh okay so the the text in red is where

377
00:14:12,959 --> 00:14:16,800
we're going to put hooks um BPF hooks to

378
00:14:16,800 --> 00:14:20,639
capture the BPF loads and so the

379
00:14:20,639 --> 00:14:22,500
um sorry if I wasn't clear so when you

380
00:14:22,500 --> 00:14:23,940
look at like this flowchart going from

381
00:14:23,940 --> 00:14:25,800
left to right we want to make sure that

382
00:14:25,800 --> 00:14:28,139
we go through a red box before we get to

383
00:14:28,139 --> 00:14:30,060
the far right where the programs

384
00:14:30,060 --> 00:14:33,180
actually run to ensure that our analysis

385
00:14:33,180 --> 00:14:35,399
tools that are running in BPF get an

386
00:14:35,399 --> 00:14:37,380
event that something happened from the

387
00:14:37,380 --> 00:14:39,120
from the application to the kernel side

388
00:14:39,120 --> 00:14:40,320
is that clear

389
00:14:40,320 --> 00:14:42,420
great perfect thanks sorry about that if

390
00:14:42,420 --> 00:14:45,420
I didn't say that up front

391
00:14:45,420 --> 00:14:48,779
so then once we get this flowchart

392
00:14:48,779 --> 00:14:52,320
instrumented with BPF we now have a way

393
00:14:52,320 --> 00:14:54,000
to get these events so then the question

394
00:14:54,000 --> 00:14:55,800
is like what are we actually looking for

395
00:14:55,800 --> 00:14:57,480
and

396
00:14:57,480 --> 00:15:00,420
what do we care about so the first case

397
00:15:00,420 --> 00:15:03,660
in our kind of cartoon picture here is

398
00:15:03,660 --> 00:15:06,420
the good case where you have some

399
00:15:06,420 --> 00:15:10,019
application I call it Alice here

400
00:15:10,019 --> 00:15:13,440
um that application probably has a hash

401
00:15:13,440 --> 00:15:15,240
associated with it that's like a shot

402
00:15:15,240 --> 00:15:18,000
256 for the executable I called it Foo

403
00:15:18,000 --> 00:15:20,820
here but you know usually it's 256 a

404
00:15:20,820 --> 00:15:23,040
shot 256 or 512 or whatever you set up

405
00:15:23,040 --> 00:15:24,180
your system for

406
00:15:24,180 --> 00:15:27,420
and then it has a program and some maps

407
00:15:27,420 --> 00:15:30,060
so alice.o is the BPF executable here

408
00:15:30,060 --> 00:15:31,980
and then I call it map a and map B are

409
00:15:31,980 --> 00:15:34,019
those two maps that let you push data

410
00:15:34,019 --> 00:15:36,600
between kernel and user space

411
00:15:36,600 --> 00:15:38,220
um what that application is then going

412
00:15:38,220 --> 00:15:40,680
to do is cause that call that CIS BPF

413
00:15:40,680 --> 00:15:42,540
call that's the system call to load a

414
00:15:42,540 --> 00:15:45,660
BPF program if you go back a slide to

415
00:15:45,660 --> 00:15:48,420
this what that's going to do is cause

416
00:15:48,420 --> 00:15:50,880
that BPF loader Block in the Middle top

417
00:15:50,880 --> 00:15:53,160
middle there to call the BPF verifier

418
00:15:53,160 --> 00:15:55,680
with that alice.o which is then going to

419
00:15:55,680 --> 00:15:57,300
trigger our event system so that we get

420
00:15:57,300 --> 00:15:58,980
a notification that a program has

421
00:15:58,980 --> 00:16:00,480
actually been loaded

422
00:16:00,480 --> 00:16:01,740
okay

423
00:16:01,740 --> 00:16:03,959
and then on the bottom here as I put

424
00:16:03,959 --> 00:16:06,120
what our system spits out at that event

425
00:16:06,120 --> 00:16:08,339
we see that event we say there's a BPF

426
00:16:08,339 --> 00:16:10,139
load happened

427
00:16:10,139 --> 00:16:10,980
um

428
00:16:10,980 --> 00:16:14,339
this is annotated with the kubernetes

429
00:16:14,339 --> 00:16:16,320
namespace so we put the kubernetes

430
00:16:16,320 --> 00:16:18,199
namespace there

431
00:16:18,199 --> 00:16:22,019
BPF and S the Pod Alice in this case

432
00:16:22,019 --> 00:16:25,019
along with the application that loaded

433
00:16:25,019 --> 00:16:28,620
it Espin Alice we can put the shot 256

434
00:16:28,620 --> 00:16:30,060
there if you have the system set up for

435
00:16:30,060 --> 00:16:32,459
it we gave a talk at kubecon about that

436
00:16:32,459 --> 00:16:35,100
so I won't go into details there we give

437
00:16:35,100 --> 00:16:36,600
you the program type which will tell you

438
00:16:36,600 --> 00:16:38,459
what it what kind of program it was if

439
00:16:38,459 --> 00:16:40,199
you're familiar with BPF there's K

440
00:16:40,199 --> 00:16:42,000
probes and there's networking Hooks and

441
00:16:42,000 --> 00:16:43,620
there's security Hooks and all this kind

442
00:16:43,620 --> 00:16:44,699
of stuff so you kind of want to know

443
00:16:44,699 --> 00:16:46,440
that as well and then we'll give you

444
00:16:46,440 --> 00:16:48,240
some details about the function about

445
00:16:48,240 --> 00:16:50,399
the instruction set that was loaded they

446
00:16:50,399 --> 00:16:52,079
have a name Alice function here

447
00:16:52,079 --> 00:16:55,079
extraction count and because with BPF

448
00:16:55,079 --> 00:16:57,060
program now has access to the entire BPF

449
00:16:57,060 --> 00:17:00,000
op as it's being loaded we can put

450
00:17:00,000 --> 00:17:02,519
arbitrary other data there as well for

451
00:17:02,519 --> 00:17:04,559
pretty printing pick some things that we

452
00:17:04,559 --> 00:17:06,540
think are as interesting but we actually

453
00:17:06,540 --> 00:17:08,220
have access to the entire BPF

454
00:17:08,220 --> 00:17:10,559
instruction so you can do things like

455
00:17:10,559 --> 00:17:13,619
copy that program out so that you have a

456
00:17:13,619 --> 00:17:15,359
copy of every program ppf program that

457
00:17:15,359 --> 00:17:16,380
was loaded

458
00:17:16,380 --> 00:17:18,059
they can be kind of large 4K

459
00:17:18,059 --> 00:17:20,880
instructions but you know one page

460
00:17:20,880 --> 00:17:23,040
BPF loading BPF programs is usually not

461
00:17:23,040 --> 00:17:23,939
something that you're doing very

462
00:17:23,939 --> 00:17:27,059
frequently so doing a copy of 4K bytes

463
00:17:27,059 --> 00:17:28,140
is

464
00:17:28,140 --> 00:17:29,820
usually negligible but it depends on

465
00:17:29,820 --> 00:17:31,500
what your use case actually is so this

466
00:17:31,500 --> 00:17:34,200
is the good case program gets loaded

467
00:17:34,200 --> 00:17:35,539
events happen

468
00:17:35,539 --> 00:17:37,860
nice nice pretty printing of the

469
00:17:37,860 --> 00:17:39,840
auditing flow

470
00:17:39,840 --> 00:17:42,419
so let's just explode our example

471
00:17:42,419 --> 00:17:44,340
slightly

472
00:17:44,340 --> 00:17:47,039
and to check my time explode our example

473
00:17:47,039 --> 00:17:48,840
slightly and we'll add Eve and Bob here

474
00:17:48,840 --> 00:17:50,940
and of course they have their Shaws and

475
00:17:50,940 --> 00:17:52,500
I think we called it

476
00:17:52,500 --> 00:17:55,500
um bad and bar there

477
00:17:55,500 --> 00:17:57,480
so the next question is what happens if

478
00:17:57,480 --> 00:17:58,919
Eve tries to load something we don't

479
00:17:58,919 --> 00:18:01,440
expect Eve to load something right well

480
00:18:01,440 --> 00:18:03,720
just like before since the since the

481
00:18:03,720 --> 00:18:05,700
tooling doesn't care right it's going to

482
00:18:05,700 --> 00:18:07,440
give you the event for the two but

483
00:18:07,440 --> 00:18:09,000
what's actually

484
00:18:09,000 --> 00:18:10,799
a little bit extra interesting about

485
00:18:10,799 --> 00:18:13,020
this is

486
00:18:13,020 --> 00:18:14,820
I think you would make the argument that

487
00:18:14,820 --> 00:18:16,559
if Eve is running in its own pod you

488
00:18:16,559 --> 00:18:17,520
probably should have never gave it cut

489
00:18:17,520 --> 00:18:19,620
BPF if it wasn't meant to load BPF

490
00:18:19,620 --> 00:18:22,380
programs right like basic uh basic

491
00:18:22,380 --> 00:18:24,539
capabilities here for pods but what's

492
00:18:24,539 --> 00:18:26,760
extra interesting about this is even if

493
00:18:26,760 --> 00:18:29,160
this eve happens to be running in Alice

494
00:18:29,160 --> 00:18:31,320
which you gave cap vpf because you

495
00:18:31,320 --> 00:18:33,480
needed Alice to load a BPF program you

496
00:18:33,480 --> 00:18:35,760
still get the audit so if for some

497
00:18:35,760 --> 00:18:37,679
reason something inside your pod is

498
00:18:37,679 --> 00:18:39,360
loading BPF programs besides what you

499
00:18:39,360 --> 00:18:41,460
expect to you'll get an audit record for

500
00:18:41,460 --> 00:18:42,840
it

501
00:18:42,840 --> 00:18:45,120
and the next interesting thing is with

502
00:18:45,120 --> 00:18:47,460
tetragon we have enforcement and which

503
00:18:47,460 --> 00:18:50,340
allows you to say match on binaries or

504
00:18:50,340 --> 00:18:53,100
Shaw 256s if you want it's easier to

505
00:18:53,100 --> 00:18:56,100
look at it's easier to look at um

506
00:18:56,100 --> 00:18:59,160
uh program names than Shaw names what

507
00:18:59,160 --> 00:19:02,160
you can say is if I see this call and

508
00:19:02,160 --> 00:19:04,380
it's not Alice

509
00:19:04,380 --> 00:19:06,840
stop it from happening right so even if

510
00:19:06,840 --> 00:19:08,160
you're in the same pod so you need to

511
00:19:08,160 --> 00:19:10,620
have cat BPF but you know exactly what

512
00:19:10,620 --> 00:19:12,419
program should be loading BPF programs

513
00:19:12,419 --> 00:19:14,100
you can encode that into your policy

514
00:19:14,100 --> 00:19:17,100
that's a crd and tetragon world and then

515
00:19:17,100 --> 00:19:19,080
what happens is if anything else inside

516
00:19:19,080 --> 00:19:21,960
that pod tries to load the program under

517
00:19:21,960 --> 00:19:24,660
BPF program we'll block it out right

518
00:19:24,660 --> 00:19:26,760
an extra layer of kind of protection

519
00:19:26,760 --> 00:19:28,500
from things trying to load BPF programs

520
00:19:28,500 --> 00:19:30,740
for you

521
00:19:30,840 --> 00:19:32,340
um and of course like I mentioned you

522
00:19:32,340 --> 00:19:33,780
could also use Shaw's but that's a

523
00:19:33,780 --> 00:19:35,039
different talk

524
00:19:35,039 --> 00:19:37,380
requires a little bit of extra setup

525
00:19:37,380 --> 00:19:39,059
um

526
00:19:39,059 --> 00:19:41,100
so the next question would be what

527
00:19:41,100 --> 00:19:42,360
happens if you have a file system

528
00:19:42,360 --> 00:19:44,940
problem where you have since Maps inside

529
00:19:44,940 --> 00:19:48,660
of BPF are usually filed descriptors but

530
00:19:48,660 --> 00:19:49,679
they're always file descriptors

531
00:19:49,679 --> 00:19:51,240
sometimes those file descriptors are

532
00:19:51,240 --> 00:19:54,120
penned into a file system and so you

533
00:19:54,120 --> 00:19:56,039
might say well Eve tries to access a

534
00:19:56,039 --> 00:19:58,260
file from Alice and this could be like a

535
00:19:58,260 --> 00:20:00,480
policy file it might have sensitive data

536
00:20:00,480 --> 00:20:01,980
in it and so on

537
00:20:01,980 --> 00:20:02,640
um

538
00:20:02,640 --> 00:20:04,140
well your first layer of his fans should

539
00:20:04,140 --> 00:20:06,720
be well don't let Eve actually access

540
00:20:06,720 --> 00:20:08,940
the file you know maintain your amounts

541
00:20:08,940 --> 00:20:10,440
but if you can't do that for some other

542
00:20:10,440 --> 00:20:13,200
reason tetragon can also monitor file

543
00:20:13,200 --> 00:20:15,240
access so you'll be able to see which

544
00:20:15,240 --> 00:20:18,299
BPF programs access which files those

545
00:20:18,299 --> 00:20:21,240
files are to Maps so you can see Eve is

546
00:20:21,240 --> 00:20:24,900
accessing map B there and um again you

547
00:20:24,900 --> 00:20:26,340
can enforce or you can just create an

548
00:20:26,340 --> 00:20:29,178
audit Trail for it

549
00:20:32,280 --> 00:20:35,660
um so

550
00:20:36,960 --> 00:20:39,299
this is so that

551
00:20:39,299 --> 00:20:40,799
um if this is the other discussion we're

552
00:20:40,799 --> 00:20:43,140
talking about Bob loading BPF

553
00:20:43,140 --> 00:20:44,820
and I'll just skip this one I think for

554
00:20:44,820 --> 00:20:46,380
now so

555
00:20:46,380 --> 00:20:47,039
um

556
00:20:47,039 --> 00:20:49,440
in summary what we've covered then is

557
00:20:49,440 --> 00:20:51,900
Alice is the good case Alice loads a

558
00:20:51,900 --> 00:20:53,580
program we get a nice audit log for it

559
00:20:53,580 --> 00:20:56,220
Eve is the malicious program or at least

560
00:20:56,220 --> 00:20:58,200
erroneous program tries to load

561
00:20:58,200 --> 00:21:00,000
something gets blocked even when it's in

562
00:21:00,000 --> 00:21:01,679
the same pod because we built this

563
00:21:01,679 --> 00:21:03,179
policy

564
00:21:03,179 --> 00:21:04,020
um

565
00:21:04,020 --> 00:21:06,240
and then we have the file monitoring so

566
00:21:06,240 --> 00:21:07,919
there is one case that I want to call

567
00:21:07,919 --> 00:21:09,780
out that the um we're working on inside

568
00:21:09,780 --> 00:21:12,000
the BPF foundation and there's kind of a

569
00:21:12,000 --> 00:21:13,140
working group around this if you're

570
00:21:13,140 --> 00:21:15,299
interested is what you can say well what

571
00:21:15,299 --> 00:21:17,880
if Alice or Bob in this case is allowed

572
00:21:17,880 --> 00:21:20,520
to load BPF programs but they load a

573
00:21:20,520 --> 00:21:21,840
different BPF program than they are

574
00:21:21,840 --> 00:21:22,860
supposed to

575
00:21:22,860 --> 00:21:24,539
meaning

576
00:21:24,539 --> 00:21:27,140
you launch Bob you checked you did some

577
00:21:27,140 --> 00:21:29,280
Integrity check to make sure it has the

578
00:21:29,280 --> 00:21:31,440
right Shaw somewhere along its lifetime

579
00:21:31,440 --> 00:21:33,059
it decided to load some random

580
00:21:33,059 --> 00:21:34,860
instructions that are not the

581
00:21:34,860 --> 00:21:37,380
instructions you expect right which it's

582
00:21:37,380 --> 00:21:39,179
allowed to do but these are perhaps

583
00:21:39,179 --> 00:21:40,620
instructions you didn't want it to load

584
00:21:40,620 --> 00:21:42,480
like a malicious program because the

585
00:21:42,480 --> 00:21:45,600
maybe Bob has been compromised somehow

586
00:21:45,600 --> 00:21:46,799
um

587
00:21:46,799 --> 00:21:50,658
so there's a couple things you can do

588
00:21:50,940 --> 00:21:53,400
one thing we've suggested is if you just

589
00:21:53,400 --> 00:21:55,799
keep a log of all these app these

590
00:21:55,799 --> 00:21:57,179
programs since they're loaded copy the

591
00:21:57,179 --> 00:21:59,340
instructions out at least you'll know

592
00:21:59,340 --> 00:22:00,600
what programs are loaded and you can

593
00:22:00,600 --> 00:22:02,880
kind of post analysis and say this

594
00:22:02,880 --> 00:22:04,919
application is loading this BPF program

595
00:22:04,919 --> 00:22:07,200
it's not the one I expect it's a new one

596
00:22:07,200 --> 00:22:08,400
I've seen I've never seen this one

597
00:22:08,400 --> 00:22:10,260
before please fire an alert off to my

598
00:22:10,260 --> 00:22:11,720
alerting tools

599
00:22:11,720 --> 00:22:14,340
the there's a working group also going

600
00:22:14,340 --> 00:22:16,980
on about how to get the right

601
00:22:16,980 --> 00:22:20,220
um how to put a Shaw on that BPF program

602
00:22:20,220 --> 00:22:21,380
itself

603
00:22:21,380 --> 00:22:24,419
and this is actually more difficult than

604
00:22:24,419 --> 00:22:26,100
it may sound on the surface because if

605
00:22:26,100 --> 00:22:27,539
we go back to when I talked about the

606
00:22:27,539 --> 00:22:30,539
core that that application is not static

607
00:22:30,539 --> 00:22:33,179
it's being Rewritten by the runtime so

608
00:22:33,179 --> 00:22:34,919
if you were to just take a shot of the

609
00:22:34,919 --> 00:22:36,480
program up front

610
00:22:36,480 --> 00:22:39,059
it wouldn't match what the Shah was

611
00:22:39,059 --> 00:22:40,500
after the program's been Rewritten to

612
00:22:40,500 --> 00:22:42,539
load on your kernel so

613
00:22:42,539 --> 00:22:44,880
um what we're doing is trying to get the

614
00:22:44,880 --> 00:22:47,159
kernel to do a lot of these rewrites and

615
00:22:47,159 --> 00:22:48,600
have sort of a consistent Shaw before

616
00:22:48,600 --> 00:22:51,000
and after the modifications

617
00:22:51,000 --> 00:22:52,260
um find me afterwards if you want to

618
00:22:52,260 --> 00:22:53,220
talk about it it's really quite

619
00:22:53,220 --> 00:22:55,799
interesting but it's it's a kind of a

620
00:22:55,799 --> 00:22:57,240
work in progress I don't think anyone

621
00:22:57,240 --> 00:22:59,280
has it fully deployed yet although some

622
00:22:59,280 --> 00:23:01,380
of the newer kernels can support most of

623
00:23:01,380 --> 00:23:04,700
the base functionality for that

624
00:23:04,700 --> 00:23:07,500
and I think in summary

625
00:23:07,500 --> 00:23:09,659
like you said Alice is good to load we

626
00:23:09,659 --> 00:23:12,059
get an audit we can block Eve we can

627
00:23:12,059 --> 00:23:14,220
watch the files and then we got a plan

628
00:23:14,220 --> 00:23:16,140
um at least to audit the the kind of

629
00:23:16,140 --> 00:23:17,400
erroneous program loading bad

630
00:23:17,400 --> 00:23:18,720
instructions

631
00:23:18,720 --> 00:23:20,100
um and then in the future we'll have a

632
00:23:20,100 --> 00:23:22,500
full solution for signing the VPN

633
00:23:22,500 --> 00:23:24,720
programs

634
00:23:24,720 --> 00:23:27,840
yeah so in the last 10 minutes five

635
00:23:27,840 --> 00:23:29,700
minutes I will just show you like a

636
00:23:29,700 --> 00:23:31,620
quick demo like how could we actually do

637
00:23:31,620 --> 00:23:34,080
it with um tetragon

638
00:23:34,080 --> 00:23:37,260
so how we will do it we will introduce a

639
00:23:37,260 --> 00:23:39,780
test environment apply a security policy

640
00:23:39,780 --> 00:23:42,299
which would actually observe BPF program

641
00:23:42,299 --> 00:23:45,419
loads and the map creations and then we

642
00:23:45,419 --> 00:23:47,760
will have like a simple use case just

643
00:23:47,760 --> 00:23:50,220
from raiko test pod it's called BPF

644
00:23:50,220 --> 00:23:53,520
Droid and then the last one will be

645
00:23:53,520 --> 00:23:55,440
um we will actually see like what kind

646
00:23:55,440 --> 00:23:58,320
of BPF programs clu loads and then what

647
00:23:58,320 --> 00:24:01,140
kind of BPF map serium craze during its

648
00:24:01,140 --> 00:24:02,520
boot up

649
00:24:02,520 --> 00:24:04,740
so how the test environment looks like

650
00:24:04,740 --> 00:24:07,080
it's going to be a one node GK cluster

651
00:24:07,080 --> 00:24:09,780
we are going to have tetragon deployed

652
00:24:09,780 --> 00:24:13,260
on it as a demon set and then we will

653
00:24:13,260 --> 00:24:15,539
apply a security policy which would

654
00:24:15,539 --> 00:24:18,059
generate events during a BPF program

655
00:24:18,059 --> 00:24:21,780
loads and then BPF map creation so for

656
00:24:21,780 --> 00:24:23,760
example if you would have like a

657
00:24:23,760 --> 00:24:26,940
multiple node cluster then you would

658
00:24:26,940 --> 00:24:29,580
Deploy tetragon on each node as well and

659
00:24:29,580 --> 00:24:32,100
then you would use a grpc collector to

660
00:24:32,100 --> 00:24:35,039
observe actually all these events

661
00:24:35,039 --> 00:24:37,919
so this is how actually the policy would

662
00:24:37,919 --> 00:24:40,260
look like uh we are going to observe

663
00:24:40,260 --> 00:24:43,080
like three main kernel functions BPF

664
00:24:43,080 --> 00:24:45,480
check so this is when the verifier

665
00:24:45,480 --> 00:24:47,700
actually checks the program before

666
00:24:47,700 --> 00:24:50,400
loading it we have security perfect

667
00:24:50,400 --> 00:24:52,380
event unlock so this is actually

668
00:24:52,380 --> 00:24:54,000
creating a map

669
00:24:54,000 --> 00:24:56,159
um to transfer events between user space

670
00:24:56,159 --> 00:24:58,679
and the kernel and then the last one is

671
00:24:58,679 --> 00:25:01,919
security BPF metallic this is basically

672
00:25:01,919 --> 00:25:05,460
um when we create a BPF map

673
00:25:05,460 --> 00:25:08,580
so we have a simpler pod and then what

674
00:25:08,580 --> 00:25:11,100
it's doing it's actually loading uh BPF

675
00:25:11,100 --> 00:25:14,280
programs yet a BPF prog and then via

676
00:25:14,280 --> 00:25:17,280
bpf2 and then it's going to sleep for 30

677
00:25:17,280 --> 00:25:19,799
seconds and then it's going to create a

678
00:25:19,799 --> 00:25:23,039
map a tetragram BPF map with hash type

679
00:25:23,039 --> 00:25:25,320
and then it's going to sleep for 30

680
00:25:25,320 --> 00:25:27,120
seconds as well

681
00:25:27,120 --> 00:25:30,840
and then this is actually how the events

682
00:25:30,840 --> 00:25:34,140
look like so we extract it as Json

683
00:25:34,140 --> 00:25:36,419
events and this is just a CLI like 3D

684
00:25:36,419 --> 00:25:38,580
printing it and then basically in the

685
00:25:38,580 --> 00:25:41,100
first row we can see that the BPF tool

686
00:25:41,100 --> 00:25:43,860
probe load process started we can see

687
00:25:43,860 --> 00:25:46,559
the kubernetes namespace and then the

688
00:25:46,559 --> 00:25:48,779
Pod we can see Washington namespace and

689
00:25:48,779 --> 00:25:52,860
the Seattle BPF Android mode and then on

690
00:25:52,860 --> 00:25:54,900
the third row we can actually see like

691
00:25:54,900 --> 00:25:57,900
that our program was loaded we can see

692
00:25:57,900 --> 00:25:59,760
the function name the amazing function

693
00:25:59,760 --> 00:26:02,279
and the instructions and then a couple

694
00:26:02,279 --> 00:26:04,140
of row later we can actually see like

695
00:26:04,140 --> 00:26:06,419
when the map was created so we can see

696
00:26:06,419 --> 00:26:08,820
like it's tetragram BPF we can see the

697
00:26:08,820 --> 00:26:11,520
key and values and then we can see also

698
00:26:11,520 --> 00:26:12,539
the

699
00:26:12,539 --> 00:26:15,179
um hashmap type

700
00:26:15,179 --> 00:26:17,279
so for cerium it's a bit more

701
00:26:17,279 --> 00:26:18,900
complicated so I will just like

702
00:26:18,900 --> 00:26:21,960
highlight certain events and steps that

703
00:26:21,960 --> 00:26:25,140
are that are executed during the boot up

704
00:26:25,140 --> 00:26:27,600
so it's going to grow probe a bunch of

705
00:26:27,600 --> 00:26:29,940
features and maps that are available in

706
00:26:29,940 --> 00:26:32,279
the curler version and then it's going

707
00:26:32,279 --> 00:26:35,340
to check and remove some IP tables and

708
00:26:35,340 --> 00:26:38,039
then it's going to execute a script

709
00:26:38,039 --> 00:26:39,779
um basically figuring out like which

710
00:26:39,779 --> 00:26:42,179
programs to load and then what network

711
00:26:42,179 --> 00:26:44,460
devices to load them on and then

712
00:26:44,460 --> 00:26:45,960
basically it's going to compile those

713
00:26:45,960 --> 00:26:48,360
programs and then basically it's going

714
00:26:48,360 --> 00:26:51,539
to load those programs for each pod on

715
00:26:51,539 --> 00:26:52,559
the Node

716
00:26:52,559 --> 00:26:55,440
so basically this is the screenshot

717
00:26:55,440 --> 00:26:57,659
um that was captured by during the demo

718
00:26:57,659 --> 00:26:59,640
and then we will see it alive so these

719
00:26:59,640 --> 00:27:01,320
are all the programs

720
00:27:01,320 --> 00:27:03,120
um that are going to be loaded for each

721
00:27:03,120 --> 00:27:05,460
but on the Node so we can actually see

722
00:27:05,460 --> 00:27:07,320
here for example

723
00:27:07,320 --> 00:27:10,020
um an example like a program named sand

724
00:27:10,020 --> 00:27:12,840
drop node so this is basically Bambi

725
00:27:12,840 --> 00:27:15,059
send notification whenever a packet was

726
00:27:15,059 --> 00:27:17,039
dropped we can actually see how many

727
00:27:17,039 --> 00:27:20,279
instruction did it count we can also see

728
00:27:20,279 --> 00:27:23,700
the Terra call handling programs

729
00:27:23,700 --> 00:27:27,059
um we can also see policy handle so this

730
00:27:27,059 --> 00:27:28,980
is related to how psyllium handles

731
00:27:28,980 --> 00:27:30,059
actually

732
00:27:30,059 --> 00:27:33,059
um Network policies and so on

733
00:27:33,059 --> 00:27:35,220
so I will just switch the terminal and

734
00:27:35,220 --> 00:27:36,840
show it

735
00:27:36,840 --> 00:27:39,860
um live

736
00:27:39,900 --> 00:27:43,100
if it works

737
00:27:44,700 --> 00:27:46,020
all right

738
00:27:46,020 --> 00:27:47,520
so

739
00:27:47,520 --> 00:27:50,760
I'm just connected to the GK cluster and

740
00:27:50,760 --> 00:27:55,580
I should have tetragon running on it

741
00:28:00,960 --> 00:28:03,120
all right here we go

742
00:28:03,120 --> 00:28:05,700
so let me just start to observe the

743
00:28:05,700 --> 00:28:07,679
events related to the

744
00:28:07,679 --> 00:28:09,679
um

745
00:28:10,440 --> 00:28:13,740
to the BPF trade the test spot first and

746
00:28:13,740 --> 00:28:15,720
then after I will show the celium use

747
00:28:15,720 --> 00:28:18,380
case as well

748
00:28:44,059 --> 00:28:49,220
all right so I will just apply the pod

749
00:28:55,799 --> 00:28:58,980
and the money one seeds get it gets

750
00:28:58,980 --> 00:29:00,720
created we should see some events as

751
00:29:00,720 --> 00:29:02,340
well

752
00:29:02,340 --> 00:29:04,860
all right so basically we will see like

753
00:29:04,860 --> 00:29:07,620
the bpf2 progload you can see the

754
00:29:07,620 --> 00:29:11,340
program uh program type here

755
00:29:11,340 --> 00:29:14,640
um like BPI prototype crypto we can see

756
00:29:14,640 --> 00:29:17,520
the functions and the instructions and

757
00:29:17,520 --> 00:29:19,440
then we can see actually the sleep

758
00:29:19,440 --> 00:29:21,480
and then we can see also the kubernetes

759
00:29:21,480 --> 00:29:22,799
information here like Washington

760
00:29:22,799 --> 00:29:26,399
namespace and the Seattle BPF Droid dot

761
00:29:26,399 --> 00:29:28,559
source code and then it's going to stay

762
00:29:28,559 --> 00:29:30,960
for 30 seconds and then we are going to

763
00:29:30,960 --> 00:29:32,580
see actually the um

764
00:29:32,580 --> 00:29:35,279
the map creation so it's BPF mapa log

765
00:29:35,279 --> 00:29:39,120
then we can actually see the BPF map uh

766
00:29:39,120 --> 00:29:41,460
the hash no it's a hash map and then we

767
00:29:41,460 --> 00:29:43,740
can see the type here and then we can

768
00:29:43,740 --> 00:29:46,799
actually see the name the map name and

769
00:29:46,799 --> 00:29:48,960
then basically a key and values and the

770
00:29:48,960 --> 00:29:50,880
max entries

771
00:29:50,880 --> 00:29:54,179
so I will actually just stop this and

772
00:29:54,179 --> 00:29:56,220
then I will start to observe the events

773
00:29:56,220 --> 00:29:58,620
from psyllium I actually have psyllium

774
00:29:58,620 --> 00:30:02,640
set up on on a different namespace it's

775
00:30:02,640 --> 00:30:05,720
the celium namespace

776
00:30:06,480 --> 00:30:08,340
all right

777
00:30:08,340 --> 00:30:10,799
so it's actually running on the celium

778
00:30:10,799 --> 00:30:13,559
namespace so I will just restart the

779
00:30:13,559 --> 00:30:17,279
agent and then we will see all the BPF

780
00:30:17,279 --> 00:30:19,679
program loads and map Creations so it's

781
00:30:19,679 --> 00:30:21,899
going to load or going to probe a bunch

782
00:30:21,899 --> 00:30:23,820
of features like what features are

783
00:30:23,820 --> 00:30:26,399
available on that kernel version and

784
00:30:26,399 --> 00:30:29,039
what BPF map types are available on that

785
00:30:29,039 --> 00:30:31,620
corner version so

786
00:30:31,620 --> 00:30:33,720
um we will see a bunch of Proverbs in

787
00:30:33,720 --> 00:30:35,880
the beginning

788
00:30:35,880 --> 00:30:38,340
okay so we will see actually the

789
00:30:38,340 --> 00:30:40,200
termination

790
00:30:40,200 --> 00:30:43,679
we will see the put up

791
00:30:43,679 --> 00:30:46,140
so these are all the probes that cilium

792
00:30:46,140 --> 00:30:47,880
is actually like running to figure out

793
00:30:47,880 --> 00:30:49,799
like what features are available and

794
00:30:49,799 --> 00:30:52,740
what what map types are available

795
00:30:52,740 --> 00:30:56,279
we will see some IP table rules like

796
00:30:56,279 --> 00:30:58,620
figuring out like what

797
00:30:58,620 --> 00:31:00,678
um

798
00:31:01,100 --> 00:31:03,960
delete delete so

799
00:31:03,960 --> 00:31:05,750
I will just like

800
00:31:05,750 --> 00:31:06,120
[Music]

801
00:31:06,120 --> 00:31:07,140
um

802
00:31:07,140 --> 00:31:09,840
highlight the ones which are related to

803
00:31:09,840 --> 00:31:12,539
program loads

804
00:31:12,539 --> 00:31:14,460
so there is always like a recurring

805
00:31:14,460 --> 00:31:17,340
pattern here and then it always starts

806
00:31:17,340 --> 00:31:18,539
with like

807
00:31:18,539 --> 00:31:21,539
um filter replace and then basically it

808
00:31:21,539 --> 00:31:24,360
ends when the command exits so for

809
00:31:24,360 --> 00:31:27,779
example these are what the BPF programs

810
00:31:27,779 --> 00:31:29,640
that are loaded for example for each pod

811
00:31:29,640 --> 00:31:31,860
and then we can see for example the

812
00:31:31,860 --> 00:31:34,860
center of notification here and then for

813
00:31:34,860 --> 00:31:37,919
example the terracott related ones and

814
00:31:37,919 --> 00:31:39,840
then we can also see for example handle

815
00:31:39,840 --> 00:31:42,299
policy which is like how

816
00:31:42,299 --> 00:31:43,320
um

817
00:31:43,320 --> 00:31:45,419
psyllium handle policies

818
00:31:45,419 --> 00:31:47,820
and then basically it just does it for

819
00:31:47,820 --> 00:31:50,340
each board on that specific node so this

820
00:31:50,340 --> 00:31:52,919
is for example like um audiover the

821
00:31:52,919 --> 00:31:54,600
example like how could we create for

822
00:31:54,600 --> 00:31:57,000
example audit list for each programs

823
00:31:57,000 --> 00:31:58,020
like

824
00:31:58,020 --> 00:32:01,140
um from each pod from each binary and

825
00:32:01,140 --> 00:32:03,779
then basically keep track of like what

826
00:32:03,779 --> 00:32:05,700
has been loaded and should we expect

827
00:32:05,700 --> 00:32:07,020
this

828
00:32:07,020 --> 00:32:09,918
um or not

829
00:32:09,980 --> 00:32:12,360
so let me just switch back to these

830
00:32:12,360 --> 00:32:14,658
slides

831
00:32:21,659 --> 00:32:24,320
groups

832
00:32:28,380 --> 00:32:31,919
all right so as I wrap up like ebpf is

833
00:32:31,919 --> 00:32:33,960
on the rise and then we see more and

834
00:32:33,960 --> 00:32:35,580
more applications for networking

835
00:32:35,580 --> 00:32:38,460
observability and security

836
00:32:38,460 --> 00:32:41,159
um it's basically cross-platform and

837
00:32:41,159 --> 00:32:43,080
then what is important to keep track and

838
00:32:43,080 --> 00:32:44,460
that would it like

839
00:32:44,460 --> 00:32:48,240
um who is watching eppf like um reach

840
00:32:48,240 --> 00:32:50,700
programs and Maps were created by who

841
00:32:50,700 --> 00:32:53,640
and when and then basically we saw an

842
00:32:53,640 --> 00:32:56,760
implementation on how tetragon could do

843
00:32:56,760 --> 00:32:57,720
it

844
00:32:57,720 --> 00:33:01,940
so a bit more on like how to contribute

845
00:33:06,240 --> 00:33:08,279
sorry

846
00:33:08,279 --> 00:33:10,320
there we go

847
00:33:10,320 --> 00:33:11,039
um

848
00:33:11,039 --> 00:33:13,919
how to contribute yeah so join the join

849
00:33:13,919 --> 00:33:15,779
the slack Channel come to the GitHub

850
00:33:15,779 --> 00:33:17,940
page and

851
00:33:17,940 --> 00:33:19,559
um

852
00:33:19,559 --> 00:33:22,080
what else did I put up sorry

853
00:33:22,080 --> 00:33:23,760
um oh we're always looking for more use

854
00:33:23,760 --> 00:33:25,380
cases so if you do if you go to the

855
00:33:25,380 --> 00:33:28,019
tetracon repo there's the crd's examples

856
00:33:28,019 --> 00:33:29,640
um you know they're sort of incomplete

857
00:33:29,640 --> 00:33:31,200
list of things that we care about but

858
00:33:31,200 --> 00:33:32,700
you know mostly it's things that I

859
00:33:32,700 --> 00:33:34,740
thought were interesting but either

860
00:33:34,740 --> 00:33:37,679
contribute or if you just file an issue

861
00:33:37,679 --> 00:33:40,320
and say like I have this use case

862
00:33:40,320 --> 00:33:41,820
um the nice thing about getting them in

863
00:33:41,820 --> 00:33:43,980
there is that we generally run those

864
00:33:43,980 --> 00:33:45,779
before we do a release so if you're

865
00:33:45,779 --> 00:33:47,760
using tetragon for something or you want

866
00:33:47,760 --> 00:33:49,500
to use tetragon for something put your

867
00:33:49,500 --> 00:33:50,820
use case in there and that's a really

868
00:33:50,820 --> 00:33:52,380
good way to make sure that we know if we

869
00:33:52,380 --> 00:33:53,720
break it somehow

870
00:33:53,720 --> 00:33:56,460
even better would be to write a CI test

871
00:33:56,460 --> 00:33:59,580
case but hey we do run those before we

872
00:33:59,580 --> 00:34:01,500
release so that's kind of your first

873
00:34:01,500 --> 00:34:03,000
gate

874
00:34:03,000 --> 00:34:04,320
um

875
00:34:04,320 --> 00:34:07,080
yeah and any feedback uh let us know to

876
00:34:07,080 --> 00:34:08,760
find a bug let us know of course we

877
00:34:08,760 --> 00:34:10,679
always always fixing things and adding

878
00:34:10,679 --> 00:34:12,719
new things so if you have a new use case

879
00:34:12,719 --> 00:34:14,280
let us know

880
00:34:14,280 --> 00:34:16,859
um and you know documentation and all

881
00:34:16,859 --> 00:34:18,239
that good stuff would be would be great

882
00:34:18,239 --> 00:34:20,940
so thanks a lot

883
00:34:20,940 --> 00:34:22,239
okay thank you

884
00:34:22,239 --> 00:34:26,759
[Applause]

885
00:34:31,619 --> 00:34:33,418
any questions right we have a few

886
00:34:33,418 --> 00:34:34,560
minutes for questions if anybody's got

887
00:34:34,560 --> 00:34:36,480
anything

888
00:34:36,480 --> 00:34:38,280
if not

889
00:34:38,280 --> 00:34:40,580
yeah

890
00:34:45,300 --> 00:34:47,820
okay I'll just repeat the question the

891
00:34:47,820 --> 00:34:50,699
question is does tetragon use bpfl at

892
00:34:50,699 --> 00:34:51,960
SIM for anything

893
00:34:51,960 --> 00:34:54,000
um to preemptively block things no we do

894
00:34:54,000 --> 00:34:56,460
not use BPF LSM we do preemptively block

895
00:34:56,460 --> 00:34:58,560
things though we have a synchronous way

896
00:34:58,560 --> 00:35:01,020
to use um to kill processes so instead

897
00:35:01,020 --> 00:35:03,000
of blocking the call we just kill the

898
00:35:03,000 --> 00:35:06,500
process if it's violating the policy

899
00:35:07,820 --> 00:35:10,440
no the action would not have gone

900
00:35:10,440 --> 00:35:12,300
through because we do the Sig the the

901
00:35:12,300 --> 00:35:15,540
send happens in in line in the kernel so

902
00:35:15,540 --> 00:35:17,820
we kill the process from the BPF program

903
00:35:17,820 --> 00:35:20,160
which will then cause all of the cores

904
00:35:20,160 --> 00:35:21,839
on the application to see it as a

905
00:35:21,839 --> 00:35:23,220
terminating signal that it cannot block

906
00:35:23,220 --> 00:35:25,619
because it's a Sig kill so your

907
00:35:25,619 --> 00:35:27,060
application cannot catch and block a Sig

908
00:35:27,060 --> 00:35:29,880
Kill from the kernel is

909
00:35:29,880 --> 00:35:32,339
from a BPF probe yeah

910
00:35:32,339 --> 00:35:37,500
so there's a BPF helper to do it yeah

911
00:35:37,500 --> 00:35:39,839
yeah and so that does it uh there there

912
00:35:39,839 --> 00:35:42,839
is uh some slight

913
00:35:42,839 --> 00:35:44,520
caution you can't do that from anywhere

914
00:35:44,520 --> 00:35:46,619
in the kernel but when we deploy this we

915
00:35:46,619 --> 00:35:47,760
ensure that we do it from the right

916
00:35:47,760 --> 00:35:49,320
places in the kernel so it requires some

917
00:35:49,320 --> 00:35:54,200
care when using but um it is doable

918
00:35:55,740 --> 00:35:59,540
yeah anything else

919
00:36:00,420 --> 00:36:02,339
maybe I just that's where that um when

920
00:36:02,339 --> 00:36:03,660
you looked at the BPF when we stopped

921
00:36:03,660 --> 00:36:05,099
blocked the BPF program that's that's

922
00:36:05,099 --> 00:36:07,640
how we did that

923
00:36:09,000 --> 00:36:11,520
anything else

924
00:36:11,520 --> 00:36:12,780
cool

925
00:36:12,780 --> 00:36:15,300
all right well thanks for coming yeah

926
00:36:15,300 --> 00:36:16,340
thank you for coming

927
00:36:16,340 --> 00:36:20,859
[Applause]

