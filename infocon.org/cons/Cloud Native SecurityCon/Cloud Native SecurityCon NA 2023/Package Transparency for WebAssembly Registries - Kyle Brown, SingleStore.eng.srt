1
00:00:00,120 --> 00:00:01,920
my name is Kyle Brown I'm an engineer at

2
00:00:01,920 --> 00:00:03,720
single store and today I'm going to talk

3
00:00:03,720 --> 00:00:05,940
to you about package transparency and

4
00:00:05,940 --> 00:00:07,740
webassembly registries

5
00:00:07,740 --> 00:00:09,599
to a brief overview of the talk

6
00:00:09,599 --> 00:00:11,280
structure we're going to begin by

7
00:00:11,280 --> 00:00:12,900
explaining what webassembly commonly

8
00:00:12,900 --> 00:00:15,660
abbreviated as wasm even is

9
00:00:15,660 --> 00:00:18,300
then we're going to step back and ask

10
00:00:18,300 --> 00:00:20,220
the question what is a package registry

11
00:00:20,220 --> 00:00:21,960
and what kind of package registry that

12
00:00:21,960 --> 00:00:24,119
webassembly needs I want to propose a

13
00:00:24,119 --> 00:00:25,859
simple if maybe somewhat surprising

14
00:00:25,859 --> 00:00:26,880
answer

15
00:00:26,880 --> 00:00:28,800
then we'll talk about applying some

16
00:00:28,800 --> 00:00:31,080
ideas from certificate transparency to

17
00:00:31,080 --> 00:00:32,579
package registries

18
00:00:32,579 --> 00:00:34,559
talk about package transparency itself

19
00:00:34,559 --> 00:00:37,620
this term created by combining the two

20
00:00:37,620 --> 00:00:40,500
and Warg a protocol implementing it and

21
00:00:40,500 --> 00:00:42,660
wrap up by showing how the properties of

22
00:00:42,660 --> 00:00:44,460
package transparency help us mitigate

23
00:00:44,460 --> 00:00:48,200
different kinds of attacks

24
00:00:48,480 --> 00:00:51,899
so jumping in to webassembly what is

25
00:00:51,899 --> 00:00:54,120
webassembly well the simplest way that

26
00:00:54,120 --> 00:00:55,260
we can really explain it is that

27
00:00:55,260 --> 00:00:57,000
webassembly is a platform agnostic

28
00:00:57,000 --> 00:00:58,920
compile Target or in other words it's

29
00:00:58,920 --> 00:01:01,020
something that you compile programs to

30
00:01:01,020 --> 00:01:02,699
you could write it by hand but you're

31
00:01:02,699 --> 00:01:04,199
not likely to write a lot of by hand for

32
00:01:04,199 --> 00:01:05,159
the same reason you don't write a lot of

33
00:01:05,159 --> 00:01:06,659
machine code by hand right it's ergonaut

34
00:01:06,659 --> 00:01:08,400
it's not very ergonomic it's very low

35
00:01:08,400 --> 00:01:09,960
level Instead at the moment you're

36
00:01:09,960 --> 00:01:11,400
likely to create web assembly by

37
00:01:11,400 --> 00:01:13,439
compiling well-supported languages like

38
00:01:13,439 --> 00:01:16,799
rust and C plus plus to wasm and these

39
00:01:16,799 --> 00:01:18,479
sort of got support earlier than a lot

40
00:01:18,479 --> 00:01:20,040
of other languages because they do their

41
00:01:20,040 --> 00:01:21,479
own memory management they're very low

42
00:01:21,479 --> 00:01:22,740
level you don't have to bring along an

43
00:01:22,740 --> 00:01:24,659
interpreter there's sort of the simpler

44
00:01:24,659 --> 00:01:27,000
side of the problem of building

45
00:01:27,000 --> 00:01:30,000
webassembly modules with that said work

46
00:01:30,000 --> 00:01:31,740
is in progress for a variety of other

47
00:01:31,740 --> 00:01:33,540
languages and we're working on solving

48
00:01:33,540 --> 00:01:35,100
sort of The Interpreter problem and

49
00:01:35,100 --> 00:01:36,600
there's different options for handling

50
00:01:36,600 --> 00:01:38,640
garbage collection whether walls and

51
00:01:38,640 --> 00:01:39,840
modules bring garbage collection with

52
00:01:39,840 --> 00:01:42,479
them or they use a runtime facility for

53
00:01:42,479 --> 00:01:43,740
doing that

54
00:01:43,740 --> 00:01:46,380
for a little bit of History wasm was a

55
00:01:46,380 --> 00:01:48,000
web technology was created in the web

56
00:01:48,000 --> 00:01:49,740
that's why it's called Web assembly

57
00:01:49,740 --> 00:01:52,680
after all and it became a w3c standard

58
00:01:52,680 --> 00:01:54,180
in 2019

59
00:01:54,180 --> 00:01:56,640
even before then back to 2017 it was

60
00:01:56,640 --> 00:01:59,040
supported in all the major browsers so

61
00:01:59,040 --> 00:02:01,979
it's been out there for a few years now

62
00:02:01,979 --> 00:02:04,619
despite being a web technology being

63
00:02:04,619 --> 00:02:06,060
something that came from the web is

64
00:02:06,060 --> 00:02:08,520
supported in browsers it isn't just a

65
00:02:08,520 --> 00:02:11,099
web technology it's not just for the web

66
00:02:11,099 --> 00:02:13,260
it has these other these valuable

67
00:02:13,260 --> 00:02:14,760
properties that were created for the web

68
00:02:14,760 --> 00:02:16,500
that everybody else kind of wants to

69
00:02:16,500 --> 00:02:18,300
believe it or not you know the

70
00:02:18,300 --> 00:02:20,280
portability that it needed to run in all

71
00:02:20,280 --> 00:02:21,840
the major browsers on a wide variety of

72
00:02:21,840 --> 00:02:23,280
systems is useful no matter where you're

73
00:02:23,280 --> 00:02:24,300
trying to deploy your applications

74
00:02:24,300 --> 00:02:27,000
portability is great you need to be fast

75
00:02:27,000 --> 00:02:28,860
to run in the web we expect for example

76
00:02:28,860 --> 00:02:30,840
out of a web page really low latencies

77
00:02:30,840 --> 00:02:33,239
with them to load quickly really we

78
00:02:33,239 --> 00:02:35,340
should hope expect that more

79
00:02:35,340 --> 00:02:37,260
um and so as a result wasm has a really

80
00:02:37,260 --> 00:02:39,720
low startup latency in fact you can

81
00:02:39,720 --> 00:02:42,000
actually start compiling wasm before

82
00:02:42,000 --> 00:02:43,440
you've even finished downloading it all

83
00:02:43,440 --> 00:02:45,360
using streaming compilation it's gonna

84
00:02:45,360 --> 00:02:47,280
do code generation validation

85
00:02:47,280 --> 00:02:49,260
sequentially

86
00:02:49,260 --> 00:02:51,000
it's also capable of near native

87
00:02:51,000 --> 00:02:52,800
performance think within about 20 to 30

88
00:02:52,800 --> 00:02:54,239
percent of native so there's a wide

89
00:02:54,239 --> 00:02:55,620
variety of applications that are capable

90
00:02:55,620 --> 00:02:57,239
of running in this kind of environment

91
00:02:57,239 --> 00:02:59,040
that maybe you wouldn't want to run in

92
00:02:59,040 --> 00:03:01,739
per se JavaScript

93
00:03:01,739 --> 00:03:03,780
on the security side to run the browser

94
00:03:03,780 --> 00:03:06,120
it needed to you couldn't have ambient

95
00:03:06,120 --> 00:03:07,319
authority to the entire user's

96
00:03:07,319 --> 00:03:08,459
permissions right these needed to be

97
00:03:08,459 --> 00:03:10,379
sandboxed in some way and so Walzem does

98
00:03:10,379 --> 00:03:12,420
that by being capability safe which you

99
00:03:12,420 --> 00:03:13,800
can just think of as you know

100
00:03:13,800 --> 00:03:15,060
webassembly modules can only do the

101
00:03:15,060 --> 00:03:16,440
things they've been given permission to

102
00:03:16,440 --> 00:03:18,239
do you feel like actually give and you

103
00:03:18,239 --> 00:03:20,099
satisfy an import buying some capability

104
00:03:20,099 --> 00:03:21,239
to them for them to be able to call

105
00:03:21,239 --> 00:03:23,819
something and additionally they have

106
00:03:23,819 --> 00:03:26,099
sandboxing each wasm's linear memory is

107
00:03:26,099 --> 00:03:28,260
independent from any other ones and a

108
00:03:28,260 --> 00:03:29,879
web assembly module can't call out and

109
00:03:29,879 --> 00:03:31,920
access a linear memory that it hasn't

110
00:03:31,920 --> 00:03:33,840
been given

111
00:03:33,840 --> 00:03:35,099
um and so for all these different

112
00:03:35,099 --> 00:03:37,140
reasons you could sort of imagine why

113
00:03:37,140 --> 00:03:38,040
people would want to use somebody

114
00:03:38,040 --> 00:03:39,720
outside the browser the company I work

115
00:03:39,720 --> 00:03:41,760
for a single store uses webassembly for

116
00:03:41,760 --> 00:03:43,799
database extensibility we let you know

117
00:03:43,799 --> 00:03:45,659
customers compile their code to

118
00:03:45,659 --> 00:03:47,940
webassembly and run it in process in the

119
00:03:47,940 --> 00:03:49,379
database as a user-defined function

120
00:03:49,379 --> 00:03:51,659
companies like cosmonic are using it to

121
00:03:51,659 --> 00:03:54,420
create distributed application systems

122
00:03:54,420 --> 00:03:56,760
fastly is using it for Edge computing

123
00:03:56,760 --> 00:03:58,799
fermion is using it for service runtimes

124
00:03:58,799 --> 00:04:00,180
and platforms

125
00:04:00,180 --> 00:04:02,340
Shopify is using it for plugins and

126
00:04:02,340 --> 00:04:05,099
extensibility and Microsoft in addition

127
00:04:05,099 --> 00:04:06,840
to the Blazer project was about running

128
00:04:06,840 --> 00:04:09,360
webassembly in the browser.net style

129
00:04:09,360 --> 00:04:11,760
also supports running Wazi modules in

130
00:04:11,760 --> 00:04:14,899
its Azure kubernetes service

131
00:04:15,060 --> 00:04:16,500
all six of these companies and many

132
00:04:16,500 --> 00:04:18,358
others are part of the bytecode alliance

133
00:04:18,358 --> 00:04:20,639
a non-profit Foundation working on

134
00:04:20,639 --> 00:04:22,560
implementations of these Open Standards

135
00:04:22,560 --> 00:04:25,400
to help mature and Advance the ecosystem

136
00:04:25,400 --> 00:04:27,540
and the sort of webassembly that we're

137
00:04:27,540 --> 00:04:28,860
all creating that's going outside the

138
00:04:28,860 --> 00:04:31,620
browser needs to be composed shared and

139
00:04:31,620 --> 00:04:32,699
deployed in a bunch of different

140
00:04:32,699 --> 00:04:34,680
environments and to do that we really

141
00:04:34,680 --> 00:04:36,000
need

142
00:04:36,000 --> 00:04:37,440
our package registry we really need

143
00:04:37,440 --> 00:04:39,120
somewhere to publish your wasms and pull

144
00:04:39,120 --> 00:04:40,560
them down and that's part that's

145
00:04:40,560 --> 00:04:41,940
something you can interact with at build

146
00:04:41,940 --> 00:04:44,400
time as you're compiling and also maybe

147
00:04:44,400 --> 00:04:47,400
at deploy time

148
00:04:47,400 --> 00:04:49,860
and when we're creating this registry we

149
00:04:49,860 --> 00:04:51,060
really want it to be as secure as

150
00:04:51,060 --> 00:04:53,220
webassembly itself if webassembly you

151
00:04:53,220 --> 00:04:54,540
know has these really nice isolated

152
00:04:54,540 --> 00:04:56,880
properties and capability safety but you

153
00:04:56,880 --> 00:04:58,979
deploy it in securely then you sort of

154
00:04:58,979 --> 00:05:01,020
lose all the advantages you know you

155
00:05:01,020 --> 00:05:04,020
wouldn't want to secure a vault with a

156
00:05:04,020 --> 00:05:07,020
Cheeto per se

157
00:05:07,020 --> 00:05:09,120
so stepping back now we've said that

158
00:05:09,120 --> 00:05:11,220
websally needs a package registry what

159
00:05:11,220 --> 00:05:12,600
is a package registry what's this thing

160
00:05:12,600 --> 00:05:14,400
that webassembly needs at a more sort of

161
00:05:14,400 --> 00:05:15,740
abstract level

162
00:05:15,740 --> 00:05:18,540
the main role of package registry sort

163
00:05:18,540 --> 00:05:20,460
of as the in the kind of packages we're

164
00:05:20,460 --> 00:05:21,479
talking about because there's diverse

165
00:05:21,479 --> 00:05:23,580
kinds of Registries out there really its

166
00:05:23,580 --> 00:05:26,100
main job is to delegate names like

167
00:05:26,100 --> 00:05:27,660
you're now the owner of leftpad I've

168
00:05:27,660 --> 00:05:29,580
given you permission over left pad to

169
00:05:29,580 --> 00:05:30,900
package owners

170
00:05:30,900 --> 00:05:33,180
who then use that permission to publish

171
00:05:33,180 --> 00:05:35,699
releases that are versioned of those

172
00:05:35,699 --> 00:05:36,840
packages

173
00:05:36,840 --> 00:05:39,900
so put a different way a registry is

174
00:05:39,900 --> 00:05:41,940
really just an index it's a mapping from

175
00:05:41,940 --> 00:05:43,860
the name and version of a package to

176
00:05:43,860 --> 00:05:45,539
what's there to the digest of the

177
00:05:45,539 --> 00:05:47,520
package contents and it has some special

178
00:05:47,520 --> 00:05:49,979
rules about how it gets updated

179
00:05:49,979 --> 00:05:52,259
so fundamentally this kind of registry

180
00:05:52,259 --> 00:05:54,120
that's this mapping of names and

181
00:05:54,120 --> 00:05:56,039
versions to contents has to own the

182
00:05:56,039 --> 00:05:57,479
metadative packages it has to be the

183
00:05:57,479 --> 00:05:58,860
sort of authoritative place where that

184
00:05:58,860 --> 00:06:00,479
info lives that you can establish the

185
00:06:00,479 --> 00:06:02,220
mapping between things and their

186
00:06:02,220 --> 00:06:04,139
contents but fundamentally it doesn't

187
00:06:04,139 --> 00:06:05,880
actually have to be the thing that does

188
00:06:05,880 --> 00:06:07,860
the content storing well you can

189
00:06:07,860 --> 00:06:09,840
actually store the content in a

190
00:06:09,840 --> 00:06:11,340
self-hosted you know location that's

191
00:06:11,340 --> 00:06:13,620
with the registry you could also defer

192
00:06:13,620 --> 00:06:16,620
to a CDN use an existing oci registry or

193
00:06:16,620 --> 00:06:18,360
any sort of third party content mirror

194
00:06:18,360 --> 00:06:20,039
to deliver the content and since you

195
00:06:20,039 --> 00:06:21,419
already know what hash you're expecting

196
00:06:21,419 --> 00:06:23,340
you can validate that you got the right

197
00:06:23,340 --> 00:06:24,960
thing no matter where you chose to try

198
00:06:24,960 --> 00:06:27,560
to get it from

199
00:06:28,740 --> 00:06:31,080
um and so now in building a secure

200
00:06:31,080 --> 00:06:33,120
registry for webassembly there is an

201
00:06:33,120 --> 00:06:34,620
index that solves the problem that we

202
00:06:34,620 --> 00:06:36,780
need to solve we can't essentiate ideas

203
00:06:36,780 --> 00:06:38,400
about applying certificate transparency

204
00:06:38,400 --> 00:06:41,460
Concepts to package registries

205
00:06:41,460 --> 00:06:44,639
so the rough analogy and bear with me a

206
00:06:44,639 --> 00:06:46,380
little bit is that with certificate

207
00:06:46,380 --> 00:06:48,360
transparency people are able to detect

208
00:06:48,360 --> 00:06:50,400
when ca's mississue certificates right

209
00:06:50,400 --> 00:06:52,199
whether it's accidentally or maliciously

210
00:06:52,199 --> 00:06:54,180
you can tell that something was done

211
00:06:54,180 --> 00:06:56,280
incorrectly that something was done uh

212
00:06:56,280 --> 00:06:59,340
wrong and with Registries it wouldn't be

213
00:06:59,340 --> 00:07:01,560
kind of nice if clients could detect

214
00:07:01,560 --> 00:07:04,020
when Registries except invalid package

215
00:07:04,020 --> 00:07:05,880
updates so for example somebody else

216
00:07:05,880 --> 00:07:07,139
tries to publish an update to your

217
00:07:07,139 --> 00:07:09,539
package a new release but they're not

218
00:07:09,539 --> 00:07:10,740
the actual owners of that package

219
00:07:10,740 --> 00:07:11,940
they're not the ones who are supposed to

220
00:07:11,940 --> 00:07:14,160
be controlling that that name

221
00:07:14,160 --> 00:07:16,740
so packet transparency does this it

222
00:07:16,740 --> 00:07:18,479
applies these ideas some tools and ideas

223
00:07:18,479 --> 00:07:20,460
from circuit transparency to package

224
00:07:20,460 --> 00:07:23,940
Registries to give us these properties

225
00:07:23,940 --> 00:07:24,660
um

226
00:07:24,660 --> 00:07:26,759
packet transparency as defined by

227
00:07:26,759 --> 00:07:28,380
Landmark who coined the term in our

228
00:07:28,380 --> 00:07:30,900
project uh is you know publishing

229
00:07:30,900 --> 00:07:33,360
cryptographically verifiable commitments

230
00:07:33,360 --> 00:07:35,880
to the state of a package registry and

231
00:07:35,880 --> 00:07:37,979
bear with me on this part to allow

232
00:07:37,979 --> 00:07:39,900
auditing of the actions of package

233
00:07:39,900 --> 00:07:41,819
authors and the registry itself over

234
00:07:41,819 --> 00:07:42,720
time

235
00:07:42,720 --> 00:07:43,919
so that's a bit of a mouthful we're

236
00:07:43,919 --> 00:07:45,900
going to break into three parts the

237
00:07:45,900 --> 00:07:47,699
first of which is publicly available

238
00:07:47,699 --> 00:07:49,440
registry State everybody needs to be

239
00:07:49,440 --> 00:07:51,599
able to download and access the

240
00:07:51,599 --> 00:07:54,419
fundamental data of the registry

241
00:07:54,419 --> 00:07:56,699
and we need the registry to make

242
00:07:56,699 --> 00:07:58,620
cryptographically verifiable commitments

243
00:07:58,620 --> 00:08:00,660
to that state in that data

244
00:08:00,660 --> 00:08:03,900
that then allows us to audit it both in

245
00:08:03,900 --> 00:08:06,240
various different ways

246
00:08:06,240 --> 00:08:09,539
um so we so this definition came up with

247
00:08:09,539 --> 00:08:11,220
what we're trying to do and we've

248
00:08:11,220 --> 00:08:12,900
created a protocol that is an

249
00:08:12,900 --> 00:08:15,539
implementation of these ideas Warg it

250
00:08:15,539 --> 00:08:17,639
stands for webassembly registry sort of

251
00:08:17,639 --> 00:08:20,220
is the idea is this implementation of

252
00:08:20,220 --> 00:08:22,560
package transparency

253
00:08:22,560 --> 00:08:24,539
and it it implements these three

254
00:08:24,539 --> 00:08:25,440
different steps you're just talking

255
00:08:25,440 --> 00:08:26,819
about and we're going to try to burn

256
00:08:26,819 --> 00:08:28,379
through explaining them the first part

257
00:08:28,379 --> 00:08:29,520
of it needs to have publicly available

258
00:08:29,520 --> 00:08:30,720
State people need to be able to download

259
00:08:30,720 --> 00:08:32,640
information about what the registry knew

260
00:08:32,640 --> 00:08:34,679
about at different points in time and it

261
00:08:34,679 --> 00:08:36,779
does that by representing every package

262
00:08:36,779 --> 00:08:39,419
as an append-only log of signed records

263
00:08:39,419 --> 00:08:41,000
they all begin with an initial record

264
00:08:41,000 --> 00:08:43,740
and that record says who the original

265
00:08:43,740 --> 00:08:45,180
owner of that package is and if a

266
00:08:45,180 --> 00:08:47,160
registry accepts this record that means

267
00:08:47,160 --> 00:08:48,540
that it's saying that you now own this

268
00:08:48,540 --> 00:08:49,680
new package

269
00:08:49,680 --> 00:08:51,959
every subsequent record contains the

270
00:08:51,959 --> 00:08:53,279
hash of the one before it that's what

271
00:08:53,279 --> 00:08:55,200
that right to left arrow is and can do

272
00:08:55,200 --> 00:08:56,339
things that affect the state of the

273
00:08:56,339 --> 00:08:59,040
package like creating releases but also

274
00:08:59,040 --> 00:09:00,540
like granting the permission to do

275
00:09:00,540 --> 00:09:01,860
releases into

276
00:09:01,860 --> 00:09:04,620
manage authorization now that Bob sort

277
00:09:04,620 --> 00:09:06,120
of has been given the ability to do a

278
00:09:06,120 --> 00:09:08,100
release he subsequently can do that he

279
00:09:08,100 --> 00:09:09,839
can append records to the log and submit

280
00:09:09,839 --> 00:09:11,700
them to the the registry and when

281
00:09:11,700 --> 00:09:13,080
they're accepted these releases now

282
00:09:13,080 --> 00:09:14,339
exist and they're part of the state of

283
00:09:14,339 --> 00:09:16,380
this package since an appendal new log

284
00:09:16,380 --> 00:09:17,940
you might think well I can't get rid of

285
00:09:17,940 --> 00:09:19,680
those releases somehow I can't delete

286
00:09:19,680 --> 00:09:21,240
records from it it's immutable it's a

287
00:09:21,240 --> 00:09:24,060
pen only so the answer to how you would

288
00:09:24,060 --> 00:09:26,580
delete something is that you mark it as

289
00:09:26,580 --> 00:09:28,320
yanked right these are a second kind of

290
00:09:28,320 --> 00:09:30,180
record that you can append to this that

291
00:09:30,180 --> 00:09:32,459
says pretend that didn't exist if you've

292
00:09:32,459 --> 00:09:33,540
still got it you still know the hash

293
00:09:33,540 --> 00:09:35,580
that's fine but for most clients in

294
00:09:35,580 --> 00:09:37,500
discoverability and things treat that as

295
00:09:37,500 --> 00:09:39,660
having been deleted

296
00:09:39,660 --> 00:09:41,700
and so really registry can be made up of

297
00:09:41,700 --> 00:09:43,380
a bunch of these package logs a

298
00:09:43,380 --> 00:09:45,600
collection of package logs

299
00:09:45,600 --> 00:09:47,519
and that then is the publicly available

300
00:09:47,519 --> 00:09:49,800
state of the registry this the records

301
00:09:49,800 --> 00:09:51,600
that make up the logs

302
00:09:51,600 --> 00:09:53,760
for each package

303
00:09:53,760 --> 00:09:55,200
now we need to make cryptographically

304
00:09:55,200 --> 00:09:58,260
verifiable commitments to these data and

305
00:09:58,260 --> 00:10:01,800
we're going to start by somehow making

306
00:10:01,800 --> 00:10:03,660
the registry commit to what's happened

307
00:10:03,660 --> 00:10:06,360
in the past like which records are part

308
00:10:06,360 --> 00:10:08,640
of its accepted history and what order

309
00:10:08,640 --> 00:10:12,300
they happened and we do this by taking a

310
00:10:12,300 --> 00:10:14,399
data structure from certificate

311
00:10:14,399 --> 00:10:15,779
transparency that maybe some of you be

312
00:10:15,779 --> 00:10:17,420
familiar with called a verifiable log

313
00:10:17,420 --> 00:10:19,680
that's based on the idea of a Merkle

314
00:10:19,680 --> 00:10:20,940
tree

315
00:10:20,940 --> 00:10:22,680
um and so sort of the abstract data type

316
00:10:22,680 --> 00:10:24,300
of a verifiable log what do we get out

317
00:10:24,300 --> 00:10:26,760
of it is that a verifiable log provides

318
00:10:26,760 --> 00:10:28,260
a total ordering

319
00:10:28,260 --> 00:10:29,940
describes the state at any given point

320
00:10:29,940 --> 00:10:31,440
with a unique checkpoint

321
00:10:31,440 --> 00:10:33,779
and we can verify if a record is in the

322
00:10:33,779 --> 00:10:35,760
log by comparing the record and the

323
00:10:35,760 --> 00:10:37,080
checkpoint that's what we're going to

324
00:10:37,080 --> 00:10:38,160
get out of it

325
00:10:38,160 --> 00:10:39,240
and here's how we're going to do it

326
00:10:39,240 --> 00:10:41,339
right there's a sequence of records and

327
00:10:41,339 --> 00:10:43,019
unlike the other kind of log we had here

328
00:10:43,019 --> 00:10:44,519
they don't have the hash of the previous

329
00:10:44,519 --> 00:10:46,680
one they're all Independent Records and

330
00:10:46,680 --> 00:10:48,000
they all have their own independent hash

331
00:10:48,000 --> 00:10:49,860
that we can compute and if we want to

332
00:10:49,860 --> 00:10:51,360
know what the representative checkpoint

333
00:10:51,360 --> 00:10:53,279
is for this whole log we can hash

334
00:10:53,279 --> 00:10:56,820
together these leaves of a tree to form

335
00:10:56,820 --> 00:10:58,620
branches and then the root of that tree

336
00:10:58,620 --> 00:11:01,140
in a particular way

337
00:11:01,140 --> 00:11:03,420
and as we add more records to this log

338
00:11:03,420 --> 00:11:05,519
what we find is that the root hash that

339
00:11:05,519 --> 00:11:07,680
represents it changes

340
00:11:07,680 --> 00:11:10,079
and sometimes that root hash is a sub

341
00:11:10,079 --> 00:11:11,519
tree of the future but sometimes it's

342
00:11:11,519 --> 00:11:13,200
not and it has to do with whether or not

343
00:11:13,200 --> 00:11:15,420
the length is you know an even you know

344
00:11:15,420 --> 00:11:18,240
power of two but we'll show later on

345
00:11:18,240 --> 00:11:19,440
that that doesn't that's not an issue

346
00:11:19,440 --> 00:11:21,360
that's just part of how it works

347
00:11:21,360 --> 00:11:23,940
um and so since every single leaf

348
00:11:23,940 --> 00:11:25,740
contributed to the value at the top we

349
00:11:25,740 --> 00:11:28,560
can show that a given value is in the

350
00:11:28,560 --> 00:11:31,800
root by reconstructing the root from the

351
00:11:31,800 --> 00:11:33,240
leaf right and we do that simply by

352
00:11:33,240 --> 00:11:35,160
hashing together values with their

353
00:11:35,160 --> 00:11:37,500
siblings to get higher and higher nodes

354
00:11:37,500 --> 00:11:39,240
in the tree until we get to the top and

355
00:11:39,240 --> 00:11:40,380
if that matches what we're expecting

356
00:11:40,380 --> 00:11:42,779
we've shown it's been included

357
00:11:42,779 --> 00:11:43,740
there's also something called

358
00:11:43,740 --> 00:11:45,120
consistency proof you're going to want

359
00:11:45,120 --> 00:11:47,040
to generally know that this log of the

360
00:11:47,040 --> 00:11:49,560
state of the registry only fast forwards

361
00:11:49,560 --> 00:11:51,540
the history doesn't get changed and you

362
00:11:51,540 --> 00:11:53,339
do that by showing that the new state is

363
00:11:53,339 --> 00:11:54,779
consistent with the old state right that

364
00:11:54,779 --> 00:11:56,399
only six and seven have been added and

365
00:11:56,399 --> 00:11:58,500
changed uh and you do that essentially

366
00:11:58,500 --> 00:12:00,720
just by showing that all the stuff that

367
00:12:00,720 --> 00:12:02,940
used to be in the log is included we

368
00:12:02,940 --> 00:12:04,980
don't need an inclusion proof for zero

369
00:12:04,980 --> 00:12:07,079
through five individually we just need

370
00:12:07,079 --> 00:12:09,480
uh inclusion proofs that show that their

371
00:12:09,480 --> 00:12:11,220
parent branches are that you can

372
00:12:11,220 --> 00:12:13,740
recompute root six from them

373
00:12:13,740 --> 00:12:16,079
so what does the registry claim has

374
00:12:16,079 --> 00:12:17,100
happened

375
00:12:17,100 --> 00:12:19,079
and the answer that is the sequence of

376
00:12:19,079 --> 00:12:21,720
values that are in its verifiable log

377
00:12:21,720 --> 00:12:24,180
and each of these records has both the

378
00:12:24,180 --> 00:12:27,420
the record itself hash and the um the

379
00:12:27,420 --> 00:12:28,860
name of the package hashed into it so

380
00:12:28,860 --> 00:12:31,140
you can tell that this is a0 was put

381
00:12:31,140 --> 00:12:33,120
into a right it's been appended to the

382
00:12:33,120 --> 00:12:34,980
package a

383
00:12:34,980 --> 00:12:36,839
but one thing clients can't efficiently

384
00:12:36,839 --> 00:12:38,399
do here is tell what the the most

385
00:12:38,399 --> 00:12:40,740
up-to-date the latest record is in each

386
00:12:40,740 --> 00:12:42,060
of these logs they have to walk the

387
00:12:42,060 --> 00:12:44,220
entire verifiable log backwards and now

388
00:12:44,220 --> 00:12:45,360
in the worst case that's walking

389
00:12:45,360 --> 00:12:46,800
everything that ever happened if your

390
00:12:46,800 --> 00:12:48,060
package has not been updated in forever

391
00:12:48,060 --> 00:12:49,800
so that's just entirely you know

392
00:12:49,800 --> 00:12:51,779
intractable to clients so we need

393
00:12:51,779 --> 00:12:52,920
something that helps us solve this

394
00:12:52,920 --> 00:12:54,540
problem and that tool is another thing

395
00:12:54,540 --> 00:12:56,519
from transparency called a verifiable

396
00:12:56,519 --> 00:12:59,519
map and where the other thing was a log

397
00:12:59,519 --> 00:13:01,380
this thing's a map it's sort of that

398
00:13:01,380 --> 00:13:03,240
straightforward really it's a key value

399
00:13:03,240 --> 00:13:05,700
mapping it's also described by unique

400
00:13:05,700 --> 00:13:07,320
cache we can also check that things are

401
00:13:07,320 --> 00:13:09,180
included in it those are sort of the

402
00:13:09,180 --> 00:13:11,339
fundamental things we want out of it and

403
00:13:11,339 --> 00:13:12,600
unlike the other one where we had this

404
00:13:12,600 --> 00:13:14,339
like sequence of records that built up a

405
00:13:14,339 --> 00:13:17,040
Merkle tree we actually have sort of a

406
00:13:17,040 --> 00:13:18,420
Radix tree and if some of you are

407
00:13:18,420 --> 00:13:19,440
familiar with Radix trees you'll know

408
00:13:19,440 --> 00:13:21,420
that at each branch you decide which

409
00:13:21,420 --> 00:13:23,940
child to go to based on part of the key

410
00:13:23,940 --> 00:13:26,579
right and so if we want to insert 0 0 1

411
00:13:26,579 --> 00:13:28,980
into this tree we go left then left then

412
00:13:28,980 --> 00:13:30,959
right so we've walked in the tree to the

413
00:13:30,959 --> 00:13:32,459
correct position that corresponds to

414
00:13:32,459 --> 00:13:34,500
that key now in reality this tree is

415
00:13:34,500 --> 00:13:37,079
actually has a height that is directly

416
00:13:37,079 --> 00:13:39,060
equal to the number of bits in the hash

417
00:13:39,060 --> 00:13:41,339
so it's quite large but on screen we can

418
00:13:41,339 --> 00:13:43,339
fit three levels so that's what we do

419
00:13:43,339 --> 00:13:45,899
and we've inserted X here and what that

420
00:13:45,899 --> 00:13:47,399
means is that the the hash that

421
00:13:47,399 --> 00:13:49,260
represents this Leaf is the hash of X

422
00:13:49,260 --> 00:13:50,940
we'll get to that later and if we insert

423
00:13:50,940 --> 00:13:52,079
more things in the tree we'll see it

424
00:13:52,079 --> 00:13:53,760
fills out that it more things are

425
00:13:53,760 --> 00:13:55,380
present and this tree is fundamentally

426
00:13:55,380 --> 00:13:57,360
sparse it's not a full tree it's a tree

427
00:13:57,360 --> 00:13:59,279
with only some values present and we'll

428
00:13:59,279 --> 00:14:01,200
finally insert your Z here at one one

429
00:14:01,200 --> 00:14:02,899
you can sort of see how this is working

430
00:14:02,899 --> 00:14:05,639
and like the other one we build the hash

431
00:14:05,639 --> 00:14:07,440
of the root it you know incrementally

432
00:14:07,440 --> 00:14:09,720
from the bottom up so that every leaf

433
00:14:09,720 --> 00:14:11,940
and key every key in value in the leaf

434
00:14:11,940 --> 00:14:14,459
you know contributes to the root value

435
00:14:14,459 --> 00:14:16,980
so we hash in this case all the leaves

436
00:14:16,980 --> 00:14:18,779
to get their value with a unique prefix

437
00:14:18,779 --> 00:14:21,600
then we can hash branches like the one

438
00:14:21,600 --> 00:14:24,180
one branch over there and show you know

439
00:14:24,180 --> 00:14:25,980
that it combines the two values of its

440
00:14:25,980 --> 00:14:28,079
children but we also have these branches

441
00:14:28,079 --> 00:14:29,700
out here that only have one sub-child

442
00:14:29,700 --> 00:14:31,800
right only one subtree to the left or

443
00:14:31,800 --> 00:14:33,600
right and in that case we prevent

444
00:14:33,600 --> 00:14:35,820
Collision attacks by modifying the

445
00:14:35,820 --> 00:14:37,800
prefix so there's a bit that indicates

446
00:14:37,800 --> 00:14:39,480
essentially which subtree is not present

447
00:14:39,480 --> 00:14:41,639
and in the top both subjects are present

448
00:14:41,639 --> 00:14:44,160
so it's the normal case of one one and

449
00:14:44,160 --> 00:14:45,600
together that way we've hashed up the

450
00:14:45,600 --> 00:14:47,040
information about a key value mapping

451
00:14:47,040 --> 00:14:48,720
and just like in the same one we can do

452
00:14:48,720 --> 00:14:51,300
an inclusion proof we can check that 1 1

453
00:14:51,300 --> 00:14:54,420
0 was mapped to Y in this root we can

454
00:14:54,420 --> 00:14:57,060
verify that in log n hashes by simply

455
00:14:57,060 --> 00:14:59,399
reconstructing the root using those same

456
00:14:59,399 --> 00:15:01,380
hashes we were using before to construct

457
00:15:01,380 --> 00:15:03,300
the root originally

458
00:15:03,300 --> 00:15:05,579
so how do clients know what the latest

459
00:15:05,579 --> 00:15:08,519
record is we have a verifiable map that

460
00:15:08,519 --> 00:15:10,680
Associates every log ID which is the

461
00:15:10,680 --> 00:15:13,620
hash of its name with the most recent

462
00:15:13,620 --> 00:15:15,899
value in that log in that way people can

463
00:15:15,899 --> 00:15:17,459
verifiably say that was the latest thing

464
00:15:17,459 --> 00:15:18,720
the registry knew at that point in time

465
00:15:18,720 --> 00:15:22,160
that's as far as I have to read up to

466
00:15:22,500 --> 00:15:23,940
and these two data structures get

467
00:15:23,940 --> 00:15:25,620
combined together into a single

468
00:15:25,620 --> 00:15:27,300
checkpoint which is sort of includes the

469
00:15:27,300 --> 00:15:29,459
hash of both the root hash of both and a

470
00:15:29,459 --> 00:15:31,740
signature by the registry and that is

471
00:15:31,740 --> 00:15:33,600
the state that we're committing to for

472
00:15:33,600 --> 00:15:35,399
the registry you note that this uniquely

473
00:15:35,399 --> 00:15:37,440
identifies the state of every package at

474
00:15:37,440 --> 00:15:39,120
one point in time so if you ask the

475
00:15:39,120 --> 00:15:41,519
question what was the latest version of

476
00:15:41,519 --> 00:15:44,220
Foo for some checkpoint that has a

477
00:15:44,220 --> 00:15:45,720
single immutable answer throughout all

478
00:15:45,720 --> 00:15:46,920
of the future

479
00:15:46,920 --> 00:15:48,959
and you can actually granularly update

480
00:15:48,959 --> 00:15:50,459
to new checkpoints and verify that

481
00:15:50,459 --> 00:15:52,380
everything stays sane as you do so it's

482
00:15:52,380 --> 00:15:54,660
just quite a nice property

483
00:15:54,660 --> 00:15:56,339
um so our third part if you remember we

484
00:15:56,339 --> 00:15:57,480
had three parts we had publicly

485
00:15:57,480 --> 00:15:59,040
available registry State we just

486
00:15:59,040 --> 00:16:00,180
finished making cryptographic

487
00:16:00,180 --> 00:16:02,040
commitments to it now we need to audit

488
00:16:02,040 --> 00:16:02,880
it

489
00:16:02,880 --> 00:16:04,800
and we audit it well from a few

490
00:16:04,800 --> 00:16:05,699
different people but the first person

491
00:16:05,699 --> 00:16:07,680
that audited is the clients

492
00:16:07,680 --> 00:16:09,480
um clients are fundamentally resource

493
00:16:09,480 --> 00:16:11,339
constrained right you know most clients

494
00:16:11,339 --> 00:16:13,139
don't have you know super computers

495
00:16:13,139 --> 00:16:14,579
running just because they want to

496
00:16:14,579 --> 00:16:16,019
download a package that's sort of a

497
00:16:16,019 --> 00:16:18,300
insane view of it even small devices

498
00:16:18,300 --> 00:16:20,040
should be able to be clients and they

499
00:16:20,040 --> 00:16:21,240
only really care about some things if

500
00:16:21,240 --> 00:16:22,860
you're a client and you want this

501
00:16:22,860 --> 00:16:24,300
package it's dependencies you don't want

502
00:16:24,300 --> 00:16:25,800
to verify the entire registry State

503
00:16:25,800 --> 00:16:27,120
that'd be absurd

504
00:16:27,120 --> 00:16:29,579
so what you only want to do is verify

505
00:16:29,579 --> 00:16:31,620
the relevant package State and that that

506
00:16:31,620 --> 00:16:33,839
package state is committed by the

507
00:16:33,839 --> 00:16:35,279
registry that the registry is committed

508
00:16:35,279 --> 00:16:37,019
to that information so you don't care

509
00:16:37,019 --> 00:16:38,940
about a slice

510
00:16:38,940 --> 00:16:40,199
um and you also want to know of course

511
00:16:40,199 --> 00:16:41,759
that the commitments are valid and

512
00:16:41,759 --> 00:16:43,259
correct

513
00:16:43,259 --> 00:16:44,699
so the beginning a client knows nothing

514
00:16:44,699 --> 00:16:47,100
complete clean slate and what they'll do

515
00:16:47,100 --> 00:16:49,139
is they'll download the logs for the

516
00:16:49,139 --> 00:16:50,399
packages they care about in this case

517
00:16:50,399 --> 00:16:51,600
it's all the packages in our fake

518
00:16:51,600 --> 00:16:52,920
registry but you can imagine that

519
00:16:52,920 --> 00:16:54,420
there's many many packages they don't

520
00:16:54,420 --> 00:16:55,980
care about

521
00:16:55,980 --> 00:16:57,720
then they're going to verify the package

522
00:16:57,720 --> 00:17:00,120
logs and

523
00:17:00,120 --> 00:17:01,380
they're going to sort of sequentially

524
00:17:01,380 --> 00:17:03,060
process each one using that sort of

525
00:17:03,060 --> 00:17:04,380
logic we talked about earlier where you

526
00:17:04,380 --> 00:17:05,939
know if I grant someone a key then they

527
00:17:05,939 --> 00:17:07,260
can do something if I don't then they

528
00:17:07,260 --> 00:17:08,939
can't and releases have to you know you

529
00:17:08,939 --> 00:17:09,959
can't release two things in the same

530
00:17:09,959 --> 00:17:11,220
version instead of those rules that you

531
00:17:11,220 --> 00:17:12,660
sequentially validate on

532
00:17:12,660 --> 00:17:14,520
uh for all the packages you care about

533
00:17:14,520 --> 00:17:17,280
in this case we're processing this log

534
00:17:17,280 --> 00:17:19,380
that actually fails because for some

535
00:17:19,380 --> 00:17:21,119
reason this guy named Charlie is trying

536
00:17:21,119 --> 00:17:22,980
to publish a release but he never got

537
00:17:22,980 --> 00:17:24,480
permission so this log is going to fail

538
00:17:24,480 --> 00:17:26,459
a validation we can Tech detect for sure

539
00:17:26,459 --> 00:17:28,020
that this was not supposed to happen

540
00:17:28,020 --> 00:17:30,419
we'll continue in the success case where

541
00:17:30,419 --> 00:17:31,919
the logs are fine and show you what

542
00:17:31,919 --> 00:17:33,419
would happen next but you could already

543
00:17:33,419 --> 00:17:34,500
have bailed at this point if you

544
00:17:34,500 --> 00:17:36,179
detected that so the next thing you get

545
00:17:36,179 --> 00:17:37,799
is the checkpoints in this case sort of

546
00:17:37,799 --> 00:17:39,900
the word log in the word map represent

547
00:17:39,900 --> 00:17:42,120
that root hash of each structure for

548
00:17:42,120 --> 00:17:43,679
compactness and you notice we don't have

549
00:17:43,679 --> 00:17:44,940
any of the other information about the

550
00:17:44,940 --> 00:17:46,080
logger map we don't have any of the

551
00:17:46,080 --> 00:17:47,340
things that make them up we don't need

552
00:17:47,340 --> 00:17:48,900
them yet

553
00:17:48,900 --> 00:17:50,460
until now because now what we're going

554
00:17:50,460 --> 00:17:51,840
to do is actually download just enough

555
00:17:51,840 --> 00:17:53,160
information for those data structures

556
00:17:53,160 --> 00:17:55,260
just the Merkle audit paths the little

557
00:17:55,260 --> 00:17:57,960
sibling and Uncle nodes required to

558
00:17:57,960 --> 00:17:59,820
verify exactly what we need very

559
00:17:59,820 --> 00:18:02,400
sparsely and we can show here that the

560
00:18:02,400 --> 00:18:03,539
registry is committed to these things

561
00:18:03,539 --> 00:18:05,340
being the latest and these things are

562
00:18:05,340 --> 00:18:08,000
part of its history

563
00:18:08,940 --> 00:18:10,919
clients will sort of also validate the

564
00:18:10,919 --> 00:18:12,419
signature on the checkpoint and say that

565
00:18:12,419 --> 00:18:14,640
this was actually committed to claimed

566
00:18:14,640 --> 00:18:16,380
by the actual registry not some random

567
00:18:16,380 --> 00:18:18,539
third party that made up a registry

568
00:18:18,539 --> 00:18:19,679
checkpoint

569
00:18:19,679 --> 00:18:21,000
now

570
00:18:21,000 --> 00:18:23,820
oh yeah in addition one thing they can

571
00:18:23,820 --> 00:18:24,900
also do is if they already had a

572
00:18:24,900 --> 00:18:26,820
checkpoint then for the log at least

573
00:18:26,820 --> 00:18:28,500
they can ensure very quickly that it's a

574
00:18:28,500 --> 00:18:30,240
fast forward that all the records they

575
00:18:30,240 --> 00:18:31,919
previously knew about are still part of

576
00:18:31,919 --> 00:18:34,080
the registry

577
00:18:34,080 --> 00:18:35,520
the one thing that they can't really do

578
00:18:35,520 --> 00:18:37,980
is verify that the login map agree with

579
00:18:37,980 --> 00:18:39,480
each other right they can't they can't

580
00:18:39,480 --> 00:18:41,280
easily check that there isn't some

581
00:18:41,280 --> 00:18:43,500
record in the log that's not represented

582
00:18:43,500 --> 00:18:44,820
in the map that's newer than what they

583
00:18:44,820 --> 00:18:47,520
know about so who are clients going to

584
00:18:47,520 --> 00:18:48,320
call

585
00:18:48,320 --> 00:18:52,020
monitors not MythBusters uh

586
00:18:52,020 --> 00:18:54,840
uh but so the monitors are able to do

587
00:18:54,840 --> 00:18:56,100
this they are long running processes

588
00:18:56,100 --> 00:18:57,120
they only care about valid and

589
00:18:57,120 --> 00:18:58,380
cryptographic information in a stream

590
00:18:58,380 --> 00:19:01,200
and so monitors are able to process all

591
00:19:01,200 --> 00:19:02,760
the checkpoints that ever were and make

592
00:19:02,760 --> 00:19:03,960
sure they all agree with each other

593
00:19:03,960 --> 00:19:06,419
internally and across time uh and so

594
00:19:06,419 --> 00:19:08,280
that's what the clients can't do and

595
00:19:08,280 --> 00:19:09,660
because clients can talk to as many or

596
00:19:09,660 --> 00:19:11,580
as few monitors as they want you can add

597
00:19:11,580 --> 00:19:12,960
security by simply standing up more

598
00:19:12,960 --> 00:19:15,000
monitors and sort of create a web of

599
00:19:15,000 --> 00:19:16,200
trust

600
00:19:16,200 --> 00:19:17,820
um

601
00:19:17,820 --> 00:19:20,460
right so revisiting our three parts of

602
00:19:20,460 --> 00:19:22,980
package transparency we needed publicly

603
00:19:22,980 --> 00:19:24,840
available registry state that we got

604
00:19:24,840 --> 00:19:26,820
with a collection of package logs we

605
00:19:26,820 --> 00:19:28,020
need a cryptographically verifiable

606
00:19:28,020 --> 00:19:30,120
commitments that we got using signed log

607
00:19:30,120 --> 00:19:32,039
and map checkpoints we needed auditing

608
00:19:32,039 --> 00:19:33,840
of package authors in the registry and

609
00:19:33,840 --> 00:19:35,580
we do that using a client and monitor

610
00:19:35,580 --> 00:19:37,919
sort of system once again akin to stick

611
00:19:37,919 --> 00:19:40,340
with transparency

612
00:19:40,340 --> 00:19:43,440
so we've done all this how does it hold

613
00:19:43,440 --> 00:19:45,120
up against attacks

614
00:19:45,120 --> 00:19:47,940
well let's imagine that the registry

615
00:19:47,940 --> 00:19:49,559
gives you package data you download

616
00:19:49,559 --> 00:19:52,500
package data but it gives you an a

617
00:19:52,500 --> 00:19:54,600
modified record in the past

618
00:19:54,600 --> 00:19:55,740
how are you going to know that they

619
00:19:55,740 --> 00:19:57,360
modified a record in the past

620
00:19:57,360 --> 00:19:58,919
the answer is that two things are going

621
00:19:58,919 --> 00:20:00,720
to immediately stop being true they're

622
00:20:00,720 --> 00:20:02,340
stop validating correctly the hash

623
00:20:02,340 --> 00:20:04,559
linkage from A2 backwards to A1 will no

624
00:20:04,559 --> 00:20:06,299
longer work because A2 didn't contain

625
00:20:06,299 --> 00:20:07,740
the hash of this modified record it

626
00:20:07,740 --> 00:20:10,140
contained the hash of actual A1 which is

627
00:20:10,140 --> 00:20:11,700
not what you have here Additionally the

628
00:20:11,700 --> 00:20:13,980
log inclusion proof here won't succeed

629
00:20:13,980 --> 00:20:15,539
because that checkpoint did not include

630
00:20:15,539 --> 00:20:17,760
this provably

631
00:20:17,760 --> 00:20:19,440
what if a registry tries to hide

632
00:20:19,440 --> 00:20:20,880
something from you right if it tries to

633
00:20:20,880 --> 00:20:22,020
say no this thing didn't exist don't

634
00:20:22,020 --> 00:20:23,039
worry there's there's not a security

635
00:20:23,039 --> 00:20:24,720
patch you're fine that version wasn't

636
00:20:24,720 --> 00:20:27,780
yanked if it does that then the linkage

637
00:20:27,780 --> 00:20:29,820
here from the map is going to fail right

638
00:20:29,820 --> 00:20:31,799
the inclusion proof that says No A1 is

639
00:20:31,799 --> 00:20:33,299
the newest thing as of my checkpoint

640
00:20:33,299 --> 00:20:35,340
will fail because it wasn't and it

641
00:20:35,340 --> 00:20:36,900
already committed to the fact that it

642
00:20:36,900 --> 00:20:39,299
wasn't now you'll note we already talked

643
00:20:39,299 --> 00:20:40,440
a little bit about the consistency of

644
00:20:40,440 --> 00:20:42,780
the login map here so the idea is that

645
00:20:42,780 --> 00:20:45,780
if if the registry had created a map and

646
00:20:45,780 --> 00:20:47,640
log that didn't agree where it did say

647
00:20:47,640 --> 00:20:49,860
A1 was the latest thing in the map but

648
00:20:49,860 --> 00:20:51,780
it still already knew about A1 and its

649
00:20:51,780 --> 00:20:53,700
log then the monitor's job is to catch

650
00:20:53,700 --> 00:20:55,020
that at this point those two things have

651
00:20:55,020 --> 00:20:57,539
already been proven to be consistent and

652
00:20:57,539 --> 00:20:58,679
so then that's how you know that you're

653
00:20:58,679 --> 00:21:00,240
not getting indefinitely Frozen for

654
00:21:00,240 --> 00:21:01,980
example

655
00:21:01,980 --> 00:21:04,799
so to summarize sort of the broad points

656
00:21:04,799 --> 00:21:05,940
of the talk

657
00:21:05,940 --> 00:21:08,400
wasm is a promising way to make portable

658
00:21:08,400 --> 00:21:10,440
and secure software

659
00:21:10,440 --> 00:21:12,000
package Registries or at least the kind

660
00:21:12,000 --> 00:21:14,160
that we need are really indexes of

661
00:21:14,160 --> 00:21:16,679
content that map name and version to

662
00:21:16,679 --> 00:21:18,960
what's actually there

663
00:21:18,960 --> 00:21:20,640
packet transparency is this combination

664
00:21:20,640 --> 00:21:22,260
of certificate transparency and package

665
00:21:22,260 --> 00:21:23,760
Concepts

666
00:21:23,760 --> 00:21:25,620
and it helps us provide some really

667
00:21:25,620 --> 00:21:27,480
interesting defenses against different

668
00:21:27,480 --> 00:21:29,280
kinds of attacks

669
00:21:29,280 --> 00:21:31,020
with that all said I'd like to give a

670
00:21:31,020 --> 00:21:32,280
special thanks to a few people who

671
00:21:32,280 --> 00:21:34,440
helped review and devise this talk like

672
00:21:34,440 --> 00:21:37,980
Land Martin and Luke Wagner and thanks

673
00:21:37,980 --> 00:21:39,240
to some other contributors to the ward

674
00:21:39,240 --> 00:21:41,100
project like Bailey Hayes and Peter Hume

675
00:21:41,100 --> 00:21:44,580
finally my company single store for

676
00:21:44,580 --> 00:21:47,340
supporting work by enabling me to work

677
00:21:47,340 --> 00:21:50,340
on this project and that's all

678
00:21:50,340 --> 00:21:54,780
[Applause]

679
00:22:03,299 --> 00:22:05,960
right

680
00:22:06,000 --> 00:22:09,179
here right

681
00:22:09,179 --> 00:22:12,480
so Warg itself is really about managing

682
00:22:12,480 --> 00:22:15,299
name spaces right and saying that this

683
00:22:15,299 --> 00:22:17,100
name is owned by these people and this

684
00:22:17,100 --> 00:22:19,080
version is authoritatively that version

685
00:22:19,080 --> 00:22:21,120
that was claimed to be if you want to

686
00:22:21,120 --> 00:22:22,320
claim some the thing that you're

687
00:22:22,320 --> 00:22:23,820
probably interested in and I think a lot

688
00:22:23,820 --> 00:22:24,960
of people want and are currently doing

689
00:22:24,960 --> 00:22:27,419
and we really are interested as well you

690
00:22:27,419 --> 00:22:28,919
want to verify that the author of that

691
00:22:28,919 --> 00:22:30,960
content is someone in particular and

692
00:22:30,960 --> 00:22:33,120
you'll actually do that inside the

693
00:22:33,120 --> 00:22:34,740
content in our case because webassembly

694
00:22:34,740 --> 00:22:37,200
for example is has an emerging proposal

695
00:22:37,200 --> 00:22:39,240
to actually include signatures in the

696
00:22:39,240 --> 00:22:41,700
wasem blob itself and that component can

697
00:22:41,700 --> 00:22:43,260
contain a section with signatures in it

698
00:22:43,260 --> 00:22:44,880
and it registry as a matter of policy

699
00:22:44,880 --> 00:22:46,559
could even require that your component

700
00:22:46,559 --> 00:22:48,840
has that section because that's sort of

701
00:22:48,840 --> 00:22:50,159
a separate question once again is like

702
00:22:50,159 --> 00:22:52,260
this was actually made by Microsoft

703
00:22:52,260 --> 00:22:54,000
Google Fubar or whatever is one question

704
00:22:54,000 --> 00:22:56,760
that it is actually the rightful version

705
00:22:56,760 --> 00:23:01,460
1.0 of Fubar is a separate question

706
00:23:07,140 --> 00:23:11,780
a good video that when dogs

707
00:23:16,559 --> 00:23:18,000
but you can't trace back right because

708
00:23:18,000 --> 00:23:19,799
the signature is in the log all are

709
00:23:19,799 --> 00:23:21,120
contiguous right and they sort of

710
00:23:21,120 --> 00:23:25,820
authorize subsequent signatures so

711
00:23:25,919 --> 00:23:27,539
that's how you can know that the people

712
00:23:27,539 --> 00:23:29,280
you originally gave it to gave it to

713
00:23:29,280 --> 00:23:30,179
people who originally gave it to

714
00:23:30,179 --> 00:23:31,620
whatever and this is not that different

715
00:23:31,620 --> 00:23:32,940
from in fact this is much more

716
00:23:32,940 --> 00:23:35,039
verifiable than like npm for instance if

717
00:23:35,039 --> 00:23:36,360
you want to know the people that you

718
00:23:36,360 --> 00:23:38,340
gave permission to be left pet on npm

719
00:23:38,340 --> 00:23:40,860
are actually the same people today you

720
00:23:40,860 --> 00:23:42,000
you currently here have way more than

721
00:23:42,000 --> 00:23:43,799
you ever had before

722
00:23:43,799 --> 00:23:45,659
um

723
00:23:45,659 --> 00:23:47,340
and and if you want this thing about

724
00:23:47,340 --> 00:23:49,500
author verification once again that is

725
00:23:49,500 --> 00:23:51,059
just an aspect of content signature

726
00:23:51,059 --> 00:23:52,140
that's a separate question that's

727
00:23:52,140 --> 00:23:54,799
handled separately

728
00:24:00,250 --> 00:24:03,359
[Music]

729
00:24:05,960 --> 00:24:08,700
how do I know what this the key of this

730
00:24:08,700 --> 00:24:10,020
registry is

731
00:24:10,020 --> 00:24:13,320
so one thing in the current design and

732
00:24:13,320 --> 00:24:14,520
this is something I didn't talk about in

733
00:24:14,520 --> 00:24:15,659
the talk because it's sort of a detail

734
00:24:15,659 --> 00:24:18,360
there's actually not just logs for every

735
00:24:18,360 --> 00:24:20,700
package there's actually also an extra

736
00:24:20,700 --> 00:24:22,980
log that's the operator's own log where

737
00:24:22,980 --> 00:24:25,200
they can track their own key rotation

738
00:24:25,200 --> 00:24:27,000
and that's actually since it's part of

739
00:24:27,000 --> 00:24:28,919
this committed State you can also

740
00:24:28,919 --> 00:24:30,960
actually track and verify changes to

741
00:24:30,960 --> 00:24:32,220
that key as well

742
00:24:32,220 --> 00:24:33,840
and it has a bit of a strange

743
00:24:33,840 --> 00:24:35,940
circularity but it's one that works out

744
00:24:35,940 --> 00:24:37,559
we think

745
00:24:37,559 --> 00:24:40,039
yes

746
00:24:47,880 --> 00:24:49,320
so the way we currently Envision and

747
00:24:49,320 --> 00:24:50,820
Visage monitors working is that monitors

748
00:24:50,820 --> 00:24:52,740
are going to subscribe to a stream of

749
00:24:52,740 --> 00:24:54,299
registry data from the Registries that

750
00:24:54,299 --> 00:24:55,140
they monitor and they're going to

751
00:24:55,140 --> 00:24:57,240
process it and then clients actually

752
00:24:57,240 --> 00:24:59,100
like the actual API client you'll set

753
00:24:59,100 --> 00:25:00,960
you'll pick your registry that you're

754
00:25:00,960 --> 00:25:02,640
using you'll actually pick a list of

755
00:25:02,640 --> 00:25:04,679
monitors that you trust and when you do

756
00:25:04,679 --> 00:25:06,480
that then whenever you pull down data

757
00:25:06,480 --> 00:25:07,200
you're actually going to ask that

758
00:25:07,200 --> 00:25:09,120
monitor hey do you know about is this

759
00:25:09,120 --> 00:25:10,799
checkpoint safe

760
00:25:10,799 --> 00:25:13,080
um and so it's not that monitors tell

761
00:25:13,080 --> 00:25:15,360
clients things clients ask monitors

762
00:25:15,360 --> 00:25:17,159
things and so it goes in that direction

763
00:25:17,159 --> 00:25:19,440
and we expect monitors to be able to

764
00:25:19,440 --> 00:25:20,700
process quickly enough that you can do

765
00:25:20,700 --> 00:25:22,799
this sort of nearly or essentially

766
00:25:22,799 --> 00:25:24,360
synchronously with the the install

767
00:25:24,360 --> 00:25:25,860
process

768
00:25:25,860 --> 00:25:26,520
um

769
00:25:26,520 --> 00:25:27,900
yeah and the monitors actually is

770
00:25:27,900 --> 00:25:29,400
another thing are one of the defenses

771
00:25:29,400 --> 00:25:31,020
against indefinite freezes because what

772
00:25:31,020 --> 00:25:32,760
a modern can do is tell you you say hey

773
00:25:32,760 --> 00:25:34,260
I just installed this checkpoint right

774
00:25:34,260 --> 00:25:36,240
this checkpoint blah blah you can say

775
00:25:36,240 --> 00:25:37,500
whoa that's like three months out of

776
00:25:37,500 --> 00:25:39,120
date buddy somebody is holding things

777
00:25:39,120 --> 00:25:40,919
back from you

778
00:25:40,919 --> 00:25:42,539
um but yeah it goes from client to

779
00:25:42,539 --> 00:25:43,860
monitor is the direction of the

780
00:25:43,860 --> 00:25:46,520
interaction

781
00:25:48,360 --> 00:25:50,899
oh yes

782
00:26:12,659 --> 00:26:14,400
right so

783
00:26:14,400 --> 00:26:16,799
because of the separation of namespace

784
00:26:16,799 --> 00:26:19,200
and content we fully expect people will

785
00:26:19,200 --> 00:26:20,940
bring their own storage into some extent

786
00:26:20,940 --> 00:26:23,159
their own registry systems but when they

787
00:26:23,159 --> 00:26:24,900
want to be part of the name spacing that

788
00:26:24,900 --> 00:26:26,279
we're creating for webassembly packages

789
00:26:26,279 --> 00:26:28,620
when you say like this is so-and-so's

790
00:26:28,620 --> 00:26:30,659
registry so package name version is

791
00:26:30,659 --> 00:26:32,279
whatever that they will probably choose

792
00:26:32,279 --> 00:26:33,659
to run that on top of their existing

793
00:26:33,659 --> 00:26:36,059
systems and that we actually the use

794
00:26:36,059 --> 00:26:37,860
cases Registries are really varied

795
00:26:37,860 --> 00:26:39,779
because we start to see some a general

796
00:26:39,779 --> 00:26:41,580
purpose good Registries at least some of

797
00:26:41,580 --> 00:26:43,260
them uh potentially one run by the

798
00:26:43,260 --> 00:26:44,400
bytecode alliance but maybe not we'll

799
00:26:44,400 --> 00:26:46,679
see uh we'll see different the riskers

800
00:26:46,679 --> 00:26:47,640
are very expensive is the thing

801
00:26:47,640 --> 00:26:49,620
Registries run by different individual

802
00:26:49,620 --> 00:26:52,080
companies and projects like if you're a

803
00:26:52,080 --> 00:26:54,659
company or let's see what's that um

804
00:26:54,659 --> 00:26:56,279
if you're like Envoy maybe you want to

805
00:26:56,279 --> 00:26:58,440
have different sort of like your own

806
00:26:58,440 --> 00:27:00,000
registry of your own Envoy sort of

807
00:27:00,000 --> 00:27:01,559
extensions and things right my company

808
00:27:01,559 --> 00:27:03,480
may run a registry at some point of

809
00:27:03,480 --> 00:27:05,400
database extensions you also potentially

810
00:27:05,400 --> 00:27:06,960
have deployment Registries inside your

811
00:27:06,960 --> 00:27:08,279
company that are the only place that you

812
00:27:08,279 --> 00:27:10,020
go to download things that mirror

813
00:27:10,020 --> 00:27:11,820
content from other places a lot of

814
00:27:11,820 --> 00:27:12,720
companies will probably run their might

815
00:27:12,720 --> 00:27:14,039
run their own monitor because monitors

816
00:27:14,039 --> 00:27:15,000
what's going to be expected to be

817
00:27:15,000 --> 00:27:17,220
relatively cheap and as a result you can

818
00:27:17,220 --> 00:27:18,720
have your own and then use another

819
00:27:18,720 --> 00:27:20,039
registry but know that you're always

820
00:27:20,039 --> 00:27:21,380
monitoring it

821
00:27:21,380 --> 00:27:23,460
to see a bunch of different Registries

822
00:27:23,460 --> 00:27:24,779
run on top of whatever people want to

823
00:27:24,779 --> 00:27:27,320
run them on top of

824
00:27:27,539 --> 00:27:30,320
yes

825
00:27:40,200 --> 00:27:43,340
but do you have an opinion

826
00:27:43,620 --> 00:27:46,740
at the moment the all of the actions

827
00:27:46,740 --> 00:27:48,960
that are taken on a package are doable

828
00:27:48,960 --> 00:27:50,640
only by the people who've been granted

829
00:27:50,640 --> 00:27:52,260
those permissions directly in the log

830
00:27:52,260 --> 00:27:54,480
itself in log authorization

831
00:27:54,480 --> 00:27:55,200
um

832
00:27:55,200 --> 00:27:56,760
there is another tool actually as well

833
00:27:56,760 --> 00:27:58,200
that sort of adds on to that where

834
00:27:58,200 --> 00:28:00,360
Registries can unilaterally reject

835
00:28:00,360 --> 00:28:02,760
anything actually this is actually just

836
00:28:02,760 --> 00:28:03,900
a fundamental property of all these

837
00:28:03,900 --> 00:28:05,279
systems anyway you can always ignore our

838
00:28:05,279 --> 00:28:07,080
HTTP request you get and more

839
00:28:07,080 --> 00:28:08,880
fundamentally here you know you're able

840
00:28:08,880 --> 00:28:10,200
to just not include something in your

841
00:28:10,200 --> 00:28:12,179
locks it didn't happen and so one thing

842
00:28:12,179 --> 00:28:13,380
that we expect is that Registries will

843
00:28:13,380 --> 00:28:16,020
use this in actually a good way uh for

844
00:28:16,020 --> 00:28:17,820
just policy so one thing you do is you

845
00:28:17,820 --> 00:28:18,840
can simply say yeah I'm not going to

846
00:28:18,840 --> 00:28:19,919
allow you to release that thing that has

847
00:28:19,919 --> 00:28:21,299
known vulnerabilities you as a registry

848
00:28:21,299 --> 00:28:22,440
operator can choose as a matter of

849
00:28:22,440 --> 00:28:24,000
policy that you only allow things that

850
00:28:24,000 --> 00:28:25,740
are signed have no known full movies Etc

851
00:28:25,740 --> 00:28:27,000
and that's the thing that different

852
00:28:27,000 --> 00:28:28,500
Registries will choose different answers

853
00:28:28,500 --> 00:28:31,140
to one other thing that's sort of a an

854
00:28:31,140 --> 00:28:32,400
interesting idea that we're currently

855
00:28:32,400 --> 00:28:34,080
thinking about is that the registry can

856
00:28:34,080 --> 00:28:35,700
actually as a matter of policy reject

857
00:28:35,700 --> 00:28:38,700
new package creation that doesn't give

858
00:28:38,700 --> 00:28:40,620
the registry operator some permission in

859
00:28:40,620 --> 00:28:42,240
the log you can say I'm only going to

860
00:28:42,240 --> 00:28:44,460
let you have the name Fubar if you give

861
00:28:44,460 --> 00:28:46,980
me the permission to yank stuff

862
00:28:46,980 --> 00:28:48,960
and so it's all still in log but in

863
00:28:48,960 --> 00:28:50,460
combination this idea of operator policy

864
00:28:50,460 --> 00:28:51,779
through rejection you can actually

865
00:28:51,779 --> 00:28:53,039
achieve some of these like higher level

866
00:28:53,039 --> 00:28:54,900
policy ideas about like giving yourself

867
00:28:54,900 --> 00:28:58,039
the ability to yank things

868
00:29:01,860 --> 00:29:03,960
we're not entirely sure the there's some

869
00:29:03,960 --> 00:29:05,700
trade-offs there uh especially around

870
00:29:05,700 --> 00:29:07,620
the size of these logs and besides these

871
00:29:07,620 --> 00:29:10,140
data structures so we're not sure at the

872
00:29:10,140 --> 00:29:11,820
very least this will give you a strongly

873
00:29:11,820 --> 00:29:13,140
identifiable way of talking about

874
00:29:13,140 --> 00:29:15,299
packages so you can build tools like

875
00:29:15,299 --> 00:29:16,620
that on top of or interoperate with

876
00:29:16,620 --> 00:29:18,059
existing tools which is maybe the best

877
00:29:18,059 --> 00:29:20,399
way for this to work

878
00:29:20,399 --> 00:29:23,059
yes

879
00:29:23,820 --> 00:29:26,460
I guess since you have this

880
00:29:26,460 --> 00:29:30,299
chain of how users were branded

881
00:29:30,299 --> 00:29:31,500
stuff

882
00:29:31,500 --> 00:29:33,720
um in the event that you someone was

883
00:29:33,720 --> 00:29:36,740
granted too much information

884
00:29:40,580 --> 00:29:44,220
would that be tied to this chain is

885
00:29:44,220 --> 00:29:45,840
something yeah how do you recover from

886
00:29:45,840 --> 00:29:47,940
like compromise of these Keys that's

887
00:29:47,940 --> 00:29:50,100
sort of a big question

888
00:29:50,100 --> 00:29:52,860
um one of the answers once it goes back

889
00:29:52,860 --> 00:29:55,380
to this idea about like initial package

890
00:29:55,380 --> 00:29:57,000
creation policy where you could say

891
00:29:57,000 --> 00:30:00,059
actually in order to as a register in

892
00:30:00,059 --> 00:30:01,080
order to create a package in my place

893
00:30:01,080 --> 00:30:02,279
you have to give me the ability to

894
00:30:02,279 --> 00:30:04,200
actually reassign key permissions and

895
00:30:04,200 --> 00:30:06,000
that's really scary sounding the only

896
00:30:06,000 --> 00:30:07,020
thing that helps that sound a little

897
00:30:07,020 --> 00:30:08,340
less scary is that you can tell when

898
00:30:08,340 --> 00:30:10,200
they do it right so you can actually say

899
00:30:10,200 --> 00:30:11,760
like I'm not actually gonna I'm gonna

900
00:30:11,760 --> 00:30:13,559
the log is fine log is fine and if the

901
00:30:13,559 --> 00:30:14,940
registry uses this power that they've

902
00:30:14,940 --> 00:30:16,380
required you to give it to reset the

903
00:30:16,380 --> 00:30:17,760
keys then it's sort of like an oh crap

904
00:30:17,760 --> 00:30:19,620
moment where you actually are going to

905
00:30:19,620 --> 00:30:21,059
want external information it's going to

906
00:30:21,059 --> 00:30:23,880
Halt the next poll or whatever so that's

907
00:30:23,880 --> 00:30:25,080
sort of the best answer we have at the

908
00:30:25,080 --> 00:30:26,820
moment is that you know but there's some

909
00:30:26,820 --> 00:30:28,740
combination of operator policy the

910
00:30:28,740 --> 00:30:31,260
direct ability to rotate Keys

911
00:30:31,260 --> 00:30:33,299
um and there's the transparency of all

912
00:30:33,299 --> 00:30:35,100
this that you do have the ingredients to

913
00:30:35,100 --> 00:30:37,320
make an answer to this question

914
00:30:37,320 --> 00:30:38,700
um there's also potentially an ability

915
00:30:38,700 --> 00:30:40,380
to make a special kind of record that

916
00:30:40,380 --> 00:30:42,779
operators can always do that like takes

917
00:30:42,779 --> 00:30:44,279
over a package and that would obviously

918
00:30:44,279 --> 00:30:45,720
be very like you know you wouldn't

919
00:30:45,720 --> 00:30:47,580
download past that point without a so

920
00:30:47,580 --> 00:30:48,840
it's a reset of your trust in the

921
00:30:48,840 --> 00:30:50,580
package authors obviously and you'd want

922
00:30:50,580 --> 00:30:52,200
to know why they did it

923
00:30:52,200 --> 00:30:53,340
um but that has some interesting

924
00:30:53,340 --> 00:30:54,899
complexity actually because it um

925
00:30:54,899 --> 00:30:57,179
answering the question what operator

926
00:30:57,179 --> 00:30:58,320
keys were allowed to do that at some

927
00:30:58,320 --> 00:30:59,880
point in time requires you to correlate

928
00:30:59,880 --> 00:31:02,159
the operator log in the package log so

929
00:31:02,159 --> 00:31:03,240
it's sort of like weird to have this

930
00:31:03,240 --> 00:31:05,340
special operator records record type

931
00:31:05,340 --> 00:31:06,600
that has permissions that come from

932
00:31:06,600 --> 00:31:08,640
outside the package log so at the moment

933
00:31:08,640 --> 00:31:10,500
it's all in log you'd have to have built

934
00:31:10,500 --> 00:31:12,179
in when you created it the ability to do

935
00:31:12,179 --> 00:31:13,620
that to recover

936
00:31:13,620 --> 00:31:17,779
which is a little scary sounding but

937
00:31:24,779 --> 00:31:27,539
so existing Registries may have a hard

938
00:31:27,539 --> 00:31:29,399
time using this maybe they won't I'm not

939
00:31:29,399 --> 00:31:30,720
entirely sure because you have to go

940
00:31:30,720 --> 00:31:32,279
back and like rewrite your history as

941
00:31:32,279 --> 00:31:33,600
one of these histories and I don't know

942
00:31:33,600 --> 00:31:34,980
how tractable that is for most of them

943
00:31:34,980 --> 00:31:36,539
but to some extent what we're saying

944
00:31:36,539 --> 00:31:38,460
here isn't really very wasn't specific

945
00:31:38,460 --> 00:31:39,480
the only thing that you really have to

946
00:31:39,480 --> 00:31:40,980
do with work to run some other type of

947
00:31:40,980 --> 00:31:43,140
content is to add a new content type and

948
00:31:43,140 --> 00:31:44,520
describe how you digest it how you

949
00:31:44,520 --> 00:31:45,779
create your content digest for that type

950
00:31:45,779 --> 00:31:48,000
and once you've done that everything

951
00:31:48,000 --> 00:31:50,220
else is just a matter of policy right

952
00:31:50,220 --> 00:31:51,360
um so no you could do you could use work

953
00:31:51,360 --> 00:31:52,200
for something else it's not very

954
00:31:52,200 --> 00:31:53,940
reminiscently specific but we came to it

955
00:31:53,940 --> 00:31:55,140
from the direction of webassembly and

956
00:31:55,140 --> 00:31:56,580
solving the needs that webassembly has

957
00:31:56,580 --> 00:32:00,120
for Federated verifiable namespaces

958
00:32:00,120 --> 00:32:02,460
um but if everybody else also needs that

959
00:32:02,460 --> 00:32:03,779
they're welcome to come take a look

960
00:32:03,779 --> 00:32:07,700
we're happy to work with anybody

961
00:32:10,200 --> 00:32:12,860
yes

962
00:32:14,640 --> 00:32:16,919
yes uh not at the moment Warg is

963
00:32:16,919 --> 00:32:18,720
currently written in Rust but it's a

964
00:32:18,720 --> 00:32:19,860
protocol it can be implemented in any

965
00:32:19,860 --> 00:32:22,200
different place it has HTTP apis it has

966
00:32:22,200 --> 00:32:23,880
some protobuf that describes the layout

967
00:32:23,880 --> 00:32:25,919
of these records in the log and some

968
00:32:25,919 --> 00:32:27,360
abstract semantics for how these hashes

969
00:32:27,360 --> 00:32:28,919
are created but largely you could create

970
00:32:28,919 --> 00:32:30,480
in any language and we expect at some

971
00:32:30,480 --> 00:32:31,799
point that we will actually compile our

972
00:32:31,799 --> 00:32:33,659
rust to webassembly and there's some

973
00:32:33,659 --> 00:32:35,039
really fun bootstrapping things that you

974
00:32:35,039 --> 00:32:36,720
get to do there actually another thing

975
00:32:36,720 --> 00:32:37,919
that has a lot of people excited about

976
00:32:37,919 --> 00:32:39,600
having sort of trying to be really

977
00:32:39,600 --> 00:32:40,740
thoughtful about supply chain security

978
00:32:40,740 --> 00:32:42,659
and webassembly is that you can have

979
00:32:42,659 --> 00:32:44,039
like the ultimate version of a build

980
00:32:44,039 --> 00:32:45,779
pack where you have like a Wazi

981
00:32:45,779 --> 00:32:48,059
component that actually takes you from

982
00:32:48,059 --> 00:32:51,720
source source code to actual artifact in

983
00:32:51,720 --> 00:32:53,399
very verifiable ways deterministically

984
00:32:53,399 --> 00:32:54,899
even because wasm can be run in a

985
00:32:54,899 --> 00:32:56,039
deterministic mode

986
00:32:56,039 --> 00:32:58,020
so there's some exciting opportunities

987
00:32:58,020 --> 00:33:00,000
there for

988
00:33:00,000 --> 00:33:02,340
maybe something similar

989
00:33:02,340 --> 00:33:04,260
uh to leverage compiling things it

990
00:33:04,260 --> 00:33:05,520
wasn't that's really how it gotten

991
00:33:05,520 --> 00:33:07,760
attention

992
00:33:08,340 --> 00:33:09,659
and yeah and additionally if we can

993
00:33:09,659 --> 00:33:10,980
compile the core logic of the registry

994
00:33:10,980 --> 00:33:12,600
to wasm and you can run was in a lot of

995
00:33:12,600 --> 00:33:13,799
places it becomes a lot easier to

996
00:33:13,799 --> 00:33:15,179
interact with these things because

997
00:33:15,179 --> 00:33:16,620
there's some complex cryptography

998
00:33:16,620 --> 00:33:18,899
cryptographical things being used and we

999
00:33:18,899 --> 00:33:20,279
didn't rewrite Shaw by any means right

1000
00:33:20,279 --> 00:33:21,779
but there's still some the use the

1001
00:33:21,779 --> 00:33:22,919
security design the use of those things

1002
00:33:22,919 --> 00:33:24,480
is still complicated to do it correctly

1003
00:33:24,480 --> 00:33:26,640
and so the more people can leverage one

1004
00:33:26,640 --> 00:33:28,080
shared open source and of course all

1005
00:33:28,080 --> 00:33:29,220
this is open source maybe I didn't say

1006
00:33:29,220 --> 00:33:31,500
that but clearly this is all open source

1007
00:33:31,500 --> 00:33:32,519
the registry's out there by code

1008
00:33:32,519 --> 00:33:34,940
Alliance you know github.com

1009
00:33:34,940 --> 00:33:38,039
registry you know org.io if you want the

1010
00:33:38,039 --> 00:33:39,240
short version of getting around our

1011
00:33:39,240 --> 00:33:40,380
stuff

1012
00:33:40,380 --> 00:33:42,299
um and yeah and if we can share an

1013
00:33:42,299 --> 00:33:43,320
implementation of these things that

1014
00:33:43,320 --> 00:33:44,820
compiles to webassembly and runs quickly

1015
00:33:44,820 --> 00:33:47,220
like why not use a singular or like at

1016
00:33:47,220 --> 00:33:48,600
least a limited number of clients that

1017
00:33:48,600 --> 00:33:50,580
we've audited really well

1018
00:33:50,580 --> 00:33:53,059
so

1019
00:33:57,179 --> 00:33:58,440
right well I think it's about to be

1020
00:33:58,440 --> 00:34:00,120
lunch so I think we'll call it there

1021
00:34:00,120 --> 00:34:02,418
thanks

