1
00:00:00,000 --> 00:00:02,340
so first let me welcome you my name is

2
00:00:02,340 --> 00:00:04,319
Jeremy Cowan and I am a developer

3
00:00:04,319 --> 00:00:08,639
Advocate manager for Amazon eks and

4
00:00:08,639 --> 00:00:10,800
joining me today

5
00:00:10,800 --> 00:00:13,740
I'm Muhammad wasser and I'm a principal

6
00:00:13,740 --> 00:00:16,500
security engineer with AWS in particular

7
00:00:16,500 --> 00:00:20,220
I work with Amazon guard Duty team

8
00:00:20,220 --> 00:00:23,279
and today we're going to be talking to

9
00:00:23,279 --> 00:00:25,439
you about finding the needles in

10
00:00:25,439 --> 00:00:28,080
Haystack or identifying suspicious

11
00:00:28,080 --> 00:00:31,800
behaviors with evpf

12
00:00:31,800 --> 00:00:35,579
and I'd like to start by first looking

13
00:00:35,579 --> 00:00:37,320
at the challenges that you're likely to

14
00:00:37,320 --> 00:00:40,079
encounter When developing a solution for

15
00:00:40,079 --> 00:00:44,100
detecting threats in runtime events now

16
00:00:44,100 --> 00:00:46,860
for starters the solution should be

17
00:00:46,860 --> 00:00:49,020
lightweight and stable

18
00:00:49,020 --> 00:00:51,960
it also should be able to handle a high

19
00:00:51,960 --> 00:00:56,280
volume of events and assuming that you

20
00:00:56,280 --> 00:00:59,579
can overcome those challenges you then

21
00:00:59,579 --> 00:01:01,440
need to separate the wheat from the

22
00:01:01,440 --> 00:01:04,619
chaff so all that you're left with are

23
00:01:04,619 --> 00:01:06,479
actionable insights

24
00:01:06,479 --> 00:01:10,380
and in this talk we'll explain how AWS

25
00:01:10,380 --> 00:01:11,700
approached these these different

26
00:01:11,700 --> 00:01:17,600
problems and why we settled on ebpf

27
00:01:18,659 --> 00:01:23,340
so there are various approaches to uh

28
00:01:23,340 --> 00:01:25,020
this problem

29
00:01:25,020 --> 00:01:28,500
uh we could have tried to extend the

30
00:01:28,500 --> 00:01:31,080
linguist kernel and the advantage there

31
00:01:31,080 --> 00:01:33,259
is that you have enormous flexibility

32
00:01:33,259 --> 00:01:37,259
however the likelihood that your change

33
00:01:37,259 --> 00:01:39,500
is going to be accepted Upstream is

34
00:01:39,500 --> 00:01:42,740
significantly as is significantly small

35
00:01:42,740 --> 00:01:46,920
because when modifying the kernel your

36
00:01:46,920 --> 00:01:49,200
changes typically have to be broadly

37
00:01:49,200 --> 00:01:52,560
applicable and so it's unlikely that you

38
00:01:52,560 --> 00:01:54,899
would choose to extend the the Linux

39
00:01:54,899 --> 00:01:58,680
kernel to solve this type of problem you

40
00:01:58,680 --> 00:02:01,020
could also write a a kernel module and

41
00:02:01,020 --> 00:02:03,600
again that also gives you a lot of

42
00:02:03,600 --> 00:02:04,700
flexibility

43
00:02:04,700 --> 00:02:07,979
but a lot of folks are a little

44
00:02:07,979 --> 00:02:10,318
apprehensive about installing kernel

45
00:02:10,318 --> 00:02:13,140
modules in their system as they can

46
00:02:13,140 --> 00:02:17,040
affect the stability and security of the

47
00:02:17,040 --> 00:02:19,560
system of the operating system

48
00:02:19,560 --> 00:02:21,239
um you could also try deploying a

49
00:02:21,239 --> 00:02:22,980
sidecar container and this is good

50
00:02:22,980 --> 00:02:24,239
because you have a separation of

51
00:02:24,239 --> 00:02:26,959
concerns you don't have to

52
00:02:26,959 --> 00:02:30,660
muddy your application logic with

53
00:02:30,660 --> 00:02:34,860
um security code but this increases

54
00:02:34,860 --> 00:02:38,760
overhead and it can be circumvented so

55
00:02:38,760 --> 00:02:40,500
for example if you're using an emission

56
00:02:40,500 --> 00:02:43,319
controller to inject a sidecar into a

57
00:02:43,319 --> 00:02:45,360
container that's deployed into a

58
00:02:45,360 --> 00:02:48,000
particular particular namespace you

59
00:02:48,000 --> 00:02:50,040
could you could circumvent that by

60
00:02:50,040 --> 00:02:51,900
deploying a pod into a different

61
00:02:51,900 --> 00:02:55,040
namespace for instance

62
00:02:55,860 --> 00:02:58,440
and yet another option that has come to

63
00:02:58,440 --> 00:03:01,860
the fore recently is evpf

64
00:03:01,860 --> 00:03:05,580
and evpf like kernel modules is

65
00:03:05,580 --> 00:03:08,519
extremely versatile in that it allows

66
00:03:08,519 --> 00:03:11,099
you to capture a rich information about

67
00:03:11,099 --> 00:03:13,560
events that are occurring from within

68
00:03:13,560 --> 00:03:17,340
the kernel and uh ebpf happens to

69
00:03:17,340 --> 00:03:19,019
address a lot of the challenges that I

70
00:03:19,019 --> 00:03:20,099
mentioned at the beginning of the

71
00:03:20,099 --> 00:03:21,440
presentation

72
00:03:21,440 --> 00:03:27,200
for instance programs ebpf programs

73
00:03:27,200 --> 00:03:29,879
are typically considered safe to run

74
00:03:29,879 --> 00:03:34,260
because they're sandboxed they also only

75
00:03:34,260 --> 00:03:36,540
have read-only access to the system

76
00:03:36,540 --> 00:03:39,239
called parameters they can't modify uh

77
00:03:39,239 --> 00:03:42,900
the parameters of the of the syscalls

78
00:03:42,900 --> 00:03:45,780
um they're also very performant because

79
00:03:45,780 --> 00:03:48,720
they run within kernel space and they

80
00:03:48,720 --> 00:03:51,540
can be loaded dynamically that is they

81
00:03:51,540 --> 00:03:54,420
don't require you to reboot the system

82
00:03:54,420 --> 00:03:56,480
which is really nice

83
00:03:56,480 --> 00:04:00,180
and ebpf has really evolved since it was

84
00:04:00,180 --> 00:04:04,940
initially introduced in the Linux kernel

85
00:04:04,940 --> 00:04:07,440
3.18 I believe it was and at that time

86
00:04:07,440 --> 00:04:10,860
it was largely designed for filtering

87
00:04:10,860 --> 00:04:13,400
Network traffic but

88
00:04:13,400 --> 00:04:16,798
it has since evolved and new

89
00:04:16,798 --> 00:04:18,798
capabilities have been added to it to

90
00:04:18,798 --> 00:04:22,680
now where you can

91
00:04:22,680 --> 00:04:25,740
uh deny certain syscalls

92
00:04:25,740 --> 00:04:28,080
um and the the implementation that we're

93
00:04:28,080 --> 00:04:30,180
probably uh a lot of us are probably

94
00:04:30,180 --> 00:04:34,040
familiar with is is SEC comp

95
00:04:35,820 --> 00:04:38,040
okay so let me uh spend a moment here to

96
00:04:38,040 --> 00:04:41,040
explain uh how it works

97
00:04:41,040 --> 00:04:41,699
um

98
00:04:41,699 --> 00:04:44,699
so first uh the uh the operating system

99
00:04:44,699 --> 00:04:48,360
uh loads your evpf program or the byte

100
00:04:48,360 --> 00:04:51,540
code for your ebpf program verifies that

101
00:04:51,540 --> 00:04:53,639
it's safe to run it's typically run

102
00:04:53,639 --> 00:04:56,100
through a verifier looking for things

103
00:04:56,100 --> 00:04:58,560
like infinite loops and that your

104
00:04:58,560 --> 00:05:02,400
program exits gracefully and so on the

105
00:05:02,400 --> 00:05:03,960
program is then just just in time

106
00:05:03,960 --> 00:05:05,900
compiled and then run

107
00:05:05,900 --> 00:05:09,780
and typically there is a an accompanying

108
00:05:09,780 --> 00:05:11,940
user space application that is used to

109
00:05:11,940 --> 00:05:15,180
load the ebpf program and then reads the

110
00:05:15,180 --> 00:05:19,020
output or enriches the output with

111
00:05:19,020 --> 00:05:21,540
additional metadata like in a kubernetes

112
00:05:21,540 --> 00:05:23,820
environment uh it's it's valuable to

113
00:05:23,820 --> 00:05:25,500
know the container ID or the Pod name

114
00:05:25,500 --> 00:05:28,020
but reading that output from ebbf is

115
00:05:28,020 --> 00:05:31,020
completely optional you don't you don't

116
00:05:31,020 --> 00:05:33,900
have to do that

117
00:05:33,900 --> 00:05:36,539
um and I feel like uh this is a replica

118
00:05:36,539 --> 00:05:40,259
of Liz's slide from this morning

119
00:05:40,259 --> 00:05:42,180
um this basically is depicting how

120
00:05:42,180 --> 00:05:44,820
applications in user space uh

121
00:05:44,820 --> 00:05:48,180
communicate with uh with the kernel

122
00:05:48,180 --> 00:05:49,800
um you know this happens when you have

123
00:05:49,800 --> 00:05:51,360
an application that has to access an

124
00:05:51,360 --> 00:05:54,600
area of memory or accessing a file on

125
00:05:54,600 --> 00:05:58,560
disk it uh it interfaces through

126
00:05:58,560 --> 00:06:00,360
interfaces with the kernel through these

127
00:06:00,360 --> 00:06:02,720
syscalls

128
00:06:02,720 --> 00:06:07,020
and ebpf can attach itself or an ebpf

129
00:06:07,020 --> 00:06:09,840
program can attach itself to these to

130
00:06:09,840 --> 00:06:13,020
these syscalls and that's where you can

131
00:06:13,020 --> 00:06:15,139
you can get additional information about

132
00:06:15,139 --> 00:06:18,720
the the program that invoked that

133
00:06:18,720 --> 00:06:20,340
particular syscall

134
00:06:20,340 --> 00:06:22,380
so here's a very simplistic example of

135
00:06:22,380 --> 00:06:24,900
how guard duty is using ebpf in this

136
00:06:24,900 --> 00:06:27,840
example we have a process that's running

137
00:06:27,840 --> 00:06:29,699
in user space that's attempting to open

138
00:06:29,699 --> 00:06:33,259
a file it calls the system Handler and

139
00:06:33,259 --> 00:06:36,120
the the arguments that were that were

140
00:06:36,120 --> 00:06:39,900
used to call that Handler is passed to

141
00:06:39,900 --> 00:06:43,819
the ebpf probe and then that ebpf probe

142
00:06:43,819 --> 00:06:47,060
has the ability to send that information

143
00:06:47,060 --> 00:06:51,960
to a user space agent and with Zeke here

144
00:06:51,960 --> 00:06:53,520
he's going to run through this in

145
00:06:53,520 --> 00:06:56,100
Greater detail a little later when we

146
00:06:56,100 --> 00:06:59,240
get to his part of the presentation

147
00:06:59,880 --> 00:07:04,259
as for getting started with evpf

148
00:07:04,259 --> 00:07:06,240
I'll say this if you're if you're not a

149
00:07:06,240 --> 00:07:09,720
seed programmer uh like like me writing

150
00:07:09,720 --> 00:07:11,940
your own ebpf program

151
00:07:11,940 --> 00:07:14,160
um might not be very feasible practical

152
00:07:14,160 --> 00:07:15,380
or easy

153
00:07:15,380 --> 00:07:19,979
and having said that uh I I'm pretty

154
00:07:19,979 --> 00:07:21,900
sure there are plans for ebpf to support

155
00:07:21,900 --> 00:07:24,840
rust and other languages in the near

156
00:07:24,840 --> 00:07:27,199
future which will make evpf a lot more

157
00:07:27,199 --> 00:07:31,319
accessible to developers and in

158
00:07:31,319 --> 00:07:34,020
preparing for this talk I found three

159
00:07:34,020 --> 00:07:37,500
really useful resources the first is a

160
00:07:37,500 --> 00:07:40,099
project from solo i o called Bumblebee

161
00:07:40,099 --> 00:07:44,099
which I'll say automatically generates

162
00:07:44,099 --> 00:07:47,039
boilerplate code based on your answers

163
00:07:47,039 --> 00:07:49,800
to a series of questions it also comes

164
00:07:49,800 --> 00:07:51,900
with the CLI which makes loading your

165
00:07:51,900 --> 00:07:54,860
evpf program relatively easy

166
00:07:54,860 --> 00:07:58,080
the other resource is a book that

167
00:07:58,080 --> 00:08:00,979
appeared on Liz's slide this morning

168
00:08:00,979 --> 00:08:04,380
called learning evpf

169
00:08:04,380 --> 00:08:06,180
um I managed to get through like the

170
00:08:06,180 --> 00:08:09,180
first half dozen chapters uh very very

171
00:08:09,180 --> 00:08:12,419
good resource on ebpf especially if

172
00:08:12,419 --> 00:08:13,740
you're getting started and then the last

173
00:08:13,740 --> 00:08:16,259
resource that I'll mention here is the

174
00:08:16,259 --> 00:08:18,000
ebpf summit

175
00:08:18,000 --> 00:08:19,979
um all the talks from that event are now

176
00:08:19,979 --> 00:08:21,840
available to watch On Demand if you're

177
00:08:21,840 --> 00:08:25,039
so interested

178
00:08:26,879 --> 00:08:30,180
and similar to the earlier slide where I

179
00:08:30,180 --> 00:08:32,099
showed you the advantages and

180
00:08:32,099 --> 00:08:34,979
disadvantages of different approaches to

181
00:08:34,979 --> 00:08:37,140
threat detection I've created a table

182
00:08:37,140 --> 00:08:38,520
here showing the advantages and

183
00:08:38,520 --> 00:08:41,520
disadvantages of evpf we know from

184
00:08:41,520 --> 00:08:44,300
earlier that it's extremely versatile

185
00:08:44,300 --> 00:08:47,640
and faster to write and deploy than say

186
00:08:47,640 --> 00:08:51,060
Linux kernel module or to change the

187
00:08:51,060 --> 00:08:52,519
kernel itself

188
00:08:52,519 --> 00:08:55,100
there are other advantages

189
00:08:55,100 --> 00:08:58,380
like memory safety and and great

190
00:08:58,380 --> 00:09:00,899
performance and portability with things

191
00:09:00,899 --> 00:09:03,560
like compile once and run everywhere

192
00:09:03,560 --> 00:09:08,000
along with BTF or

193
00:09:08,000 --> 00:09:13,320
ebpf type format yeah which

194
00:09:14,279 --> 00:09:17,220
uh which can translate with data

195
00:09:17,220 --> 00:09:18,480
structures within the kernel between

196
00:09:18,480 --> 00:09:21,779
different kernel versions yeah now the

197
00:09:21,779 --> 00:09:24,360
downside of evpf

198
00:09:24,360 --> 00:09:26,600
is that the tooling for it is relatively

199
00:09:26,600 --> 00:09:29,820
immature and debugging it is still

200
00:09:29,820 --> 00:09:33,899
pretty hard but I'm sure that as it

201
00:09:33,899 --> 00:09:36,600
becomes increasingly popular that these

202
00:09:36,600 --> 00:09:38,580
challenges will be overcome

203
00:09:38,580 --> 00:09:42,000
as for common use cases for evpf

204
00:09:42,000 --> 00:09:45,120
security of course but it's also found

205
00:09:45,120 --> 00:09:47,839
in a lot of networking applications

206
00:09:47,839 --> 00:09:50,959
and observability tools like Hubble

207
00:09:50,959 --> 00:09:54,000
which you saw a few pictures of during

208
00:09:54,000 --> 00:09:57,240
the keynote along with Pixie and lots of

209
00:09:57,240 --> 00:10:00,839
other networking and observability tools

210
00:10:00,839 --> 00:10:05,940
and at AWS we love evpf we have several

211
00:10:05,940 --> 00:10:07,920
groups that are using it it's becoming

212
00:10:07,920 --> 00:10:10,980
increasingly uh popular at AWS here are

213
00:10:10,980 --> 00:10:15,300
a smattering of examples of how AWS is

214
00:10:15,300 --> 00:10:19,380
making use of ebpf Lambda is using it

215
00:10:19,380 --> 00:10:22,080
today to create pools of geneve network

216
00:10:22,080 --> 00:10:25,220
tunnels and this allowed us to reduce

217
00:10:25,220 --> 00:10:30,000
the VPC function code start from 150

218
00:10:30,000 --> 00:10:33,360
milliseconds to 150 microseconds a

219
00:10:33,360 --> 00:10:35,519
pretty significant Improvement

220
00:10:35,519 --> 00:10:39,300
um and then VPC is actually using it in

221
00:10:39,300 --> 00:10:41,100
several different places they're

222
00:10:41,100 --> 00:10:44,220
currently using it to observe TCP TCP

223
00:10:44,220 --> 00:10:46,680
flow level performance we have

224
00:10:46,680 --> 00:10:49,380
applications like S3 that can be

225
00:10:49,380 --> 00:10:51,720
accessed in a variety of different ways

226
00:10:51,720 --> 00:10:55,740
and so they're looking at the TCP flows

227
00:10:55,740 --> 00:10:57,899
for performance and then later they're

228
00:10:57,899 --> 00:10:59,820
they're looking at to looking at

229
00:10:59,820 --> 00:11:02,279
dynamically tuning the performance of

230
00:11:02,279 --> 00:11:04,040
the TCP stack

231
00:11:04,040 --> 00:11:06,660
for different uh for different services

232
00:11:06,660 --> 00:11:10,380
and uh and their access patterns

233
00:11:10,380 --> 00:11:11,940
um we're also using it

234
00:11:11,940 --> 00:11:15,000
um or we have a a distributed packet

235
00:11:15,000 --> 00:11:16,980
processing pipeline

236
00:11:16,980 --> 00:11:20,700
um written in ebpf and then it's also

237
00:11:20,700 --> 00:11:22,380
used to implement security groups and

238
00:11:22,380 --> 00:11:23,779
and knackles

239
00:11:23,779 --> 00:11:29,820
and if if you used Amazon eks Amazon's

240
00:11:29,820 --> 00:11:33,180
managed kubernetes offering it has its

241
00:11:33,180 --> 00:11:37,260
own vpcc cni today it does not include a

242
00:11:37,260 --> 00:11:41,839
policy engine we make use of Calico

243
00:11:41,839 --> 00:11:44,459
policy engine or the psyllium policy

244
00:11:44,459 --> 00:11:46,680
engine in the future we're going to add

245
00:11:46,680 --> 00:11:49,640
support for Network policy

246
00:11:49,640 --> 00:11:53,300
using evpf

247
00:11:54,540 --> 00:11:58,079
and then uh why EBP why ebpf for guard

248
00:11:58,079 --> 00:11:59,540
Duty

249
00:11:59,540 --> 00:12:03,540
ebpf elected to use

250
00:12:03,540 --> 00:12:05,880
guard Duty elected to use ebpf for

251
00:12:05,880 --> 00:12:08,820
threat detection for a variety of

252
00:12:08,820 --> 00:12:10,800
reasons first it can be implemented

253
00:12:10,800 --> 00:12:13,320
quickly as I mentioned

254
00:12:13,320 --> 00:12:15,260
there's less apprehension about

255
00:12:15,260 --> 00:12:18,420
installing evpf programs than there is

256
00:12:18,420 --> 00:12:21,000
about kernel modules because they're

257
00:12:21,000 --> 00:12:24,600
because evpf programs are sandboxed and

258
00:12:24,600 --> 00:12:27,240
ebpf programs are relatively easy to

259
00:12:27,240 --> 00:12:30,420
install and update

260
00:12:30,420 --> 00:12:32,820
um finally ebpf provides Rich

261
00:12:32,820 --> 00:12:35,480
information about kernel events and

262
00:12:35,480 --> 00:12:38,160
these these events

263
00:12:38,160 --> 00:12:40,620
can be enriched with additional

264
00:12:40,620 --> 00:12:43,139
information like container ID and pod

265
00:12:43,139 --> 00:12:45,380
name which gives

266
00:12:45,380 --> 00:12:49,980
gives the the user additional context to

267
00:12:49,980 --> 00:12:52,200
help identify threats to their

268
00:12:52,200 --> 00:12:53,660
environment

269
00:12:53,660 --> 00:12:58,079
and ebpf can be used to provide

270
00:12:58,079 --> 00:13:00,240
protection at runtime which also makes

271
00:13:00,240 --> 00:13:03,019
it very appealing for threat prevention

272
00:13:03,019 --> 00:13:05,639
which you might talk about later right

273
00:13:05,639 --> 00:13:08,399
yeah so today car duty is primarily

274
00:13:08,399 --> 00:13:11,600
using it for threat detection but

275
00:13:11,600 --> 00:13:14,100
the appealing thing about evpf is that

276
00:13:14,100 --> 00:13:16,519
it could be used to prevent

277
00:13:16,519 --> 00:13:18,540
prevent attacks

278
00:13:18,540 --> 00:13:20,760
in addition to detecting them so with

279
00:13:20,760 --> 00:13:22,740
that I'm going to hand the Baton to

280
00:13:22,740 --> 00:13:25,459
lazique

281
00:13:32,279 --> 00:13:34,860
yeah so

282
00:13:34,860 --> 00:13:37,800
I'm gonna go I'm going to dive into some

283
00:13:37,800 --> 00:13:40,260
more details about how we are using evpf

284
00:13:40,260 --> 00:13:42,600
what choices we have made what type of

285
00:13:42,600 --> 00:13:44,639
events we are collecting

286
00:13:44,639 --> 00:13:48,899
and we'll also go into a scenario and

287
00:13:48,899 --> 00:13:51,139
show you what type of events

288
00:13:51,139 --> 00:13:54,480
will will result in that scenario and

289
00:13:54,480 --> 00:13:56,399
what type of detections we'll be able to

290
00:13:56,399 --> 00:13:58,639
get

291
00:13:58,860 --> 00:13:59,519
um

292
00:13:59,519 --> 00:14:02,279
currently we are primarily using ebpf

293
00:14:02,279 --> 00:14:05,040
for system called tracing because it's

294
00:14:05,040 --> 00:14:08,339
very effective for threat monitoring and

295
00:14:08,339 --> 00:14:10,740
threat detection

296
00:14:10,740 --> 00:14:12,720
when

297
00:14:12,720 --> 00:14:14,820
uh when you're using system called

298
00:14:14,820 --> 00:14:16,860
tracing For Thread detection there are

299
00:14:16,860 --> 00:14:20,040
three main objectives number one you

300
00:14:20,040 --> 00:14:22,860
need to capture the input arguments of

301
00:14:22,860 --> 00:14:24,600
the system calls so that you could

302
00:14:24,600 --> 00:14:26,760
figure out what it is trying to do

303
00:14:26,760 --> 00:14:28,680
number two you need to capture the

304
00:14:28,680 --> 00:14:30,540
details of the actor process or the

305
00:14:30,540 --> 00:14:33,060
process that invoke the system call

306
00:14:33,060 --> 00:14:35,700
number three you may also need to

307
00:14:35,700 --> 00:14:38,760
capture the the written value of the

308
00:14:38,760 --> 00:14:40,740
system call so you could figure out if

309
00:14:40,740 --> 00:14:42,720
the system call was successful or it

310
00:14:42,720 --> 00:14:45,740
returned an error

311
00:14:45,860 --> 00:14:47,579
ebpf

312
00:14:47,579 --> 00:14:50,160
allows you to

313
00:14:50,160 --> 00:14:53,279
as Jeremy mentioned allows you to attach

314
00:14:53,279 --> 00:14:57,000
ebpf code or ebpf probe to various Trace

315
00:14:57,000 --> 00:15:00,000
points or hook points inside the kernel

316
00:15:00,000 --> 00:15:03,000
for system called tracing one such hook

317
00:15:03,000 --> 00:15:06,600
point is system called enter hook

318
00:15:06,600 --> 00:15:10,320
or system call enter Trace point this

319
00:15:10,320 --> 00:15:12,120
Trace Point triggers as soon as the

320
00:15:12,120 --> 00:15:16,199
kernel starts processing the system call

321
00:15:16,199 --> 00:15:18,839
when an ebpf probe is attached to this

322
00:15:18,839 --> 00:15:21,600
Trace point the kernel passes all the

323
00:15:21,600 --> 00:15:24,300
input arguments of the system call

324
00:15:24,300 --> 00:15:26,339
to the abpf probe

325
00:15:26,339 --> 00:15:29,940
the ebpf probe can also get the details

326
00:15:29,940 --> 00:15:32,100
of the actor process from the task

327
00:15:32,100 --> 00:15:34,800
structure which is an internal kernel

328
00:15:34,800 --> 00:15:38,100
structure then it can send the input

329
00:15:38,100 --> 00:15:40,019
arguments as well as the details of the

330
00:15:40,019 --> 00:15:42,779
actor process to user space for further

331
00:15:42,779 --> 00:15:44,579
processing

332
00:15:44,579 --> 00:15:46,680
another option for system call

333
00:15:46,680 --> 00:15:48,360
processing or sorry system called

334
00:15:48,360 --> 00:15:50,279
tracing with ebpf

335
00:15:50,279 --> 00:15:53,339
is to attach an ebpf probe to an

336
00:15:53,339 --> 00:15:55,980
internal kernel function which is

337
00:15:55,980 --> 00:15:58,019
invoked as part of the kernel processing

338
00:15:58,019 --> 00:15:59,579
of the system call

339
00:15:59,579 --> 00:16:01,320
these type of

340
00:16:01,320 --> 00:16:04,620
probes are called K probes

341
00:16:04,620 --> 00:16:07,980
when you attach an ebpf probe to to an

342
00:16:07,980 --> 00:16:10,139
internal kernel function the kernel

343
00:16:10,139 --> 00:16:12,360
passes all the input arguments of that

344
00:16:12,360 --> 00:16:15,120
function to the eppf probe the ebpf

345
00:16:15,120 --> 00:16:17,100
probe can then take these input

346
00:16:17,100 --> 00:16:18,959
arguments as well as the actor process

347
00:16:18,959 --> 00:16:22,920
details and send those to user space

348
00:16:22,920 --> 00:16:26,040
for further processing

349
00:16:26,040 --> 00:16:28,800
in order to get the return value the

350
00:16:28,800 --> 00:16:31,079
primary option is to hook into the

351
00:16:31,079 --> 00:16:34,199
system called exit Trace point or hook

352
00:16:34,199 --> 00:16:37,079
when you attach a probe to that or ebpf

353
00:16:37,079 --> 00:16:39,180
probe to that the kernel passes the

354
00:16:39,180 --> 00:16:41,940
written value of the system call to your

355
00:16:41,940 --> 00:16:43,920
ebpf probe you can collect the return

356
00:16:43,920 --> 00:16:44,880
value

357
00:16:44,880 --> 00:16:48,380
and send it to the user space

358
00:16:49,620 --> 00:16:52,440
now I'll also talk about you know

359
00:16:52,440 --> 00:16:54,899
solve the security considerations when

360
00:16:54,899 --> 00:16:58,699
you are choosing a proper Trace point

361
00:16:58,740 --> 00:17:02,040
um I talked about the system called

362
00:17:02,040 --> 00:17:04,980
enter Trace point for act for capturing

363
00:17:04,980 --> 00:17:08,280
system called arguments although it's an

364
00:17:08,280 --> 00:17:10,380
easy and efficient way of capturing

365
00:17:10,380 --> 00:17:12,599
system call arguments it is vulnerable

366
00:17:12,599 --> 00:17:14,939
to race conditions or time of check time

367
00:17:14,939 --> 00:17:17,040
of use issues

368
00:17:17,040 --> 00:17:19,140
let's consider the example of open

369
00:17:19,140 --> 00:17:20,459
syscall

370
00:17:20,459 --> 00:17:23,040
in order to understand this point

371
00:17:23,040 --> 00:17:25,319
when you hook an abpf probe into open

372
00:17:25,319 --> 00:17:26,760
system call

373
00:17:26,760 --> 00:17:29,100
as I said the kernel passes all the

374
00:17:29,100 --> 00:17:31,799
input arguments to your ebpf probe

375
00:17:31,799 --> 00:17:34,200
one of those arguments in case of the

376
00:17:34,200 --> 00:17:36,900
open system call is path name which is a

377
00:17:36,900 --> 00:17:39,299
pointer to a user space address that

378
00:17:39,299 --> 00:17:41,580
contains the path name of the file being

379
00:17:41,580 --> 00:17:43,320
opened

380
00:17:43,320 --> 00:17:46,559
now your ebpf probe in this case has to

381
00:17:46,559 --> 00:17:48,660
read the path name from

382
00:17:48,660 --> 00:17:52,080
from this user space address

383
00:17:52,080 --> 00:17:55,679
and some point later the kernel also

384
00:17:55,679 --> 00:17:56,640
reads

385
00:17:56,640 --> 00:17:58,799
the same path name from the same user

386
00:17:58,799 --> 00:18:01,140
space address you can notice that there

387
00:18:01,140 --> 00:18:03,720
is a Time window between the time when

388
00:18:03,720 --> 00:18:06,419
the ebpf probe reads the path name

389
00:18:06,419 --> 00:18:09,179
and the kernel reads the path name right

390
00:18:09,179 --> 00:18:12,360
and an attacker can potentially exploit

391
00:18:12,360 --> 00:18:14,100
this time window

392
00:18:14,100 --> 00:18:17,700
so since it's since

393
00:18:17,700 --> 00:18:19,500
both the probe and the kernel are

394
00:18:19,500 --> 00:18:21,480
reading the path name at different times

395
00:18:21,480 --> 00:18:24,179
from user space a user space attacker

396
00:18:24,179 --> 00:18:27,660
can modify the path name between in in

397
00:18:27,660 --> 00:18:29,160
that time window

398
00:18:29,160 --> 00:18:31,980
if that happens your probe is going to

399
00:18:31,980 --> 00:18:34,740
read a different path name than what

400
00:18:34,740 --> 00:18:38,419
kernel reads and processes

401
00:18:40,919 --> 00:18:44,400
a safe option or a safe alternative is

402
00:18:44,400 --> 00:18:45,360
to

403
00:18:45,360 --> 00:18:47,880
attach your ebpf probe to an internal

404
00:18:47,880 --> 00:18:50,280
kernel function for example in case of

405
00:18:50,280 --> 00:18:52,140
open system call one such internal

406
00:18:52,140 --> 00:18:55,500
kernel function is security file open

407
00:18:55,500 --> 00:18:59,039
when you hook to your ebpf probe to this

408
00:18:59,039 --> 00:19:00,780
internal kernel function

409
00:19:00,780 --> 00:19:03,299
you can read the path name from internal

410
00:19:03,299 --> 00:19:06,780
kernel data structures for example the

411
00:19:06,780 --> 00:19:08,940
file is struck in this case

412
00:19:08,940 --> 00:19:11,039
this is not vulnerable to race

413
00:19:11,039 --> 00:19:13,080
conditions or time of check time of use

414
00:19:13,080 --> 00:19:15,240
exploitation because

415
00:19:15,240 --> 00:19:17,700
a user space attacker cannot manipulate

416
00:19:17,700 --> 00:19:20,100
the internal kernel function sorry the

417
00:19:20,100 --> 00:19:24,199
internal kernel data structure

418
00:19:24,600 --> 00:19:26,760
so we have learned if you are interested

419
00:19:26,760 --> 00:19:29,340
in more details of these type of attacks

420
00:19:29,340 --> 00:19:31,799
you can view this Defcon presentation

421
00:19:31,799 --> 00:19:34,140
Phantom attack evading system called

422
00:19:34,140 --> 00:19:35,220
monitoring

423
00:19:35,220 --> 00:19:37,620
very interesting presentation

424
00:19:37,620 --> 00:19:39,539
so we have learned from the research on

425
00:19:39,539 --> 00:19:41,580
these attacks and we have implemented

426
00:19:41,580 --> 00:19:44,760
our ebpf probe in Secure fashion

427
00:19:44,760 --> 00:19:47,580
in particular none of our ebpf probe

428
00:19:47,580 --> 00:19:49,160
reads

429
00:19:49,160 --> 00:19:52,760
user space memory

430
00:19:54,419 --> 00:19:59,179
now I'll talk a little bit about the the

431
00:19:59,700 --> 00:20:04,820
level of context which ebpf provides us

432
00:20:06,360 --> 00:20:08,340
a significant percentage of our

433
00:20:08,340 --> 00:20:12,059
customers now use container workloads on

434
00:20:12,059 --> 00:20:13,679
platforms like

435
00:20:13,679 --> 00:20:14,220
um

436
00:20:14,220 --> 00:20:16,320
Amazon eks

437
00:20:16,320 --> 00:20:18,299
when it comes to threat detection the

438
00:20:18,299 --> 00:20:21,179
primary demand is that the detections

439
00:20:21,179 --> 00:20:24,059
should contain container level details

440
00:20:24,059 --> 00:20:27,000
in other words if a detection originated

441
00:20:27,000 --> 00:20:29,160
from inside a container it should have

442
00:20:29,160 --> 00:20:31,260
the details of that container otherwise

443
00:20:31,260 --> 00:20:33,960
that detection is not very useful or

444
00:20:33,960 --> 00:20:36,000
actionable for them

445
00:20:36,000 --> 00:20:38,760
ebpf allows us to not just provide the

446
00:20:38,760 --> 00:20:40,740
container and pod level details it also

447
00:20:40,740 --> 00:20:42,660
allows us to provide all the process

448
00:20:42,660 --> 00:20:45,240
process level details

449
00:20:45,240 --> 00:20:47,700
which is a significant Improvement of on

450
00:20:47,700 --> 00:20:51,600
ah on guard duties existing flow logs

451
00:20:51,600 --> 00:20:53,880
and DNS logs based detections which only

452
00:20:53,880 --> 00:20:59,780
provide host level or ec2 level details

453
00:21:01,320 --> 00:21:04,080
a little bit about how we are collecting

454
00:21:04,080 --> 00:21:07,440
the context details which details we are

455
00:21:07,440 --> 00:21:09,240
collecting from kernel which from user

456
00:21:09,240 --> 00:21:11,400
space

457
00:21:11,400 --> 00:21:14,160
our strategy is is to collect as much

458
00:21:14,160 --> 00:21:16,740
information or data from inside the

459
00:21:16,740 --> 00:21:18,960
kernel as much possible

460
00:21:18,960 --> 00:21:21,059
because that's more efficient and it's

461
00:21:21,059 --> 00:21:22,799
also safer

462
00:21:22,799 --> 00:21:25,679
so we are able to get all the process

463
00:21:25,679 --> 00:21:28,380
level details from the kernel such as

464
00:21:28,380 --> 00:21:30,960
the PID of the process executable path

465
00:21:30,960 --> 00:21:34,080
we are also even able to get the

466
00:21:34,080 --> 00:21:36,720
container ID if if a process happens to

467
00:21:36,720 --> 00:21:38,820
be running inside a container from the

468
00:21:38,820 --> 00:21:40,260
kernel

469
00:21:40,260 --> 00:21:42,120
of course there is some information

470
00:21:42,120 --> 00:21:44,340
which is not available inside the kernel

471
00:21:44,340 --> 00:21:46,980
we have to get it from the user space so

472
00:21:46,980 --> 00:21:50,039
for example container image name image

473
00:21:50,039 --> 00:21:52,559
digest we have to get it from the user

474
00:21:52,559 --> 00:21:56,340
space ah similarly kubernetes spot IDs

475
00:21:56,340 --> 00:21:58,140
namespace and name

476
00:21:58,140 --> 00:22:00,960
is also obtained from the user space and

477
00:22:00,960 --> 00:22:03,240
then the shaw 256 hash of the executable

478
00:22:03,240 --> 00:22:07,159
is also obtained from the user space

479
00:22:08,640 --> 00:22:10,440
now what type of events we are

480
00:22:10,440 --> 00:22:12,620
collecting

481
00:22:12,620 --> 00:22:16,559
Linux supports or has 300 plus system

482
00:22:16,559 --> 00:22:20,220
calls ebpf can capture all those but

483
00:22:20,220 --> 00:22:22,020
that wouldn't be very efficient

484
00:22:22,020 --> 00:22:24,659
so what we do we try to collect all the

485
00:22:24,659 --> 00:22:27,179
relevant system call events which are

486
00:22:27,179 --> 00:22:29,760
valuable in terms of thread detection

487
00:22:29,760 --> 00:22:33,240
ah some of the main ones that we collect

488
00:22:33,240 --> 00:22:35,460
include

489
00:22:35,460 --> 00:22:39,059
process creation execution events

490
00:22:39,059 --> 00:22:41,820
these events allow us to provide process

491
00:22:41,820 --> 00:22:44,400
level details they also allow us to

492
00:22:44,400 --> 00:22:47,280
identify suspicious process executions

493
00:22:47,280 --> 00:22:49,980
they also allow us to

494
00:22:49,980 --> 00:22:53,780
to profile or or track

495
00:22:54,000 --> 00:22:57,179
behavior of various executables and pods

496
00:22:57,179 --> 00:22:58,860
and containers

497
00:22:58,860 --> 00:23:00,780
next up we also collect file system

498
00:23:00,780 --> 00:23:04,740
operations such as file open and file

499
00:23:04,740 --> 00:23:07,620
mounts file system mounts

500
00:23:07,620 --> 00:23:09,179
um

501
00:23:09,179 --> 00:23:11,820
these events allow us to identify

502
00:23:11,820 --> 00:23:13,740
suspicious file system operations they

503
00:23:13,740 --> 00:23:15,780
also allow us to track file system

504
00:23:15,780 --> 00:23:17,659
activity of various processes

505
00:23:17,659 --> 00:23:21,720
executables pods and containers

506
00:23:21,720 --> 00:23:24,840
and then another useful category is

507
00:23:24,840 --> 00:23:27,900
network connection events these events

508
00:23:27,900 --> 00:23:30,539
allow us to identify connections with

509
00:23:30,539 --> 00:23:32,820
known bad IP addresses or known

510
00:23:32,820 --> 00:23:35,100
malicious IP addresses they also allow

511
00:23:35,100 --> 00:23:37,980
us to again track network based activity

512
00:23:37,980 --> 00:23:40,860
of various processes executables pods

513
00:23:40,860 --> 00:23:43,520
and containers

514
00:23:43,740 --> 00:23:47,039
ah DNS requests and responses are also

515
00:23:47,039 --> 00:23:51,020
another useful set of data

516
00:23:51,020 --> 00:23:54,960
they allow us to detect when a process

517
00:23:54,960 --> 00:23:58,140
tries to look up a suspicious domain

518
00:23:58,140 --> 00:24:00,380
name

519
00:24:03,000 --> 00:24:04,320
and then

520
00:24:04,320 --> 00:24:07,020
um another category is inter-process

521
00:24:07,020 --> 00:24:09,299
interactions or when one process tries

522
00:24:09,299 --> 00:24:11,100
to inject into the memory of another

523
00:24:11,100 --> 00:24:15,059
process we try to collect events

524
00:24:15,059 --> 00:24:18,780
relevant to this category because these

525
00:24:18,780 --> 00:24:21,059
these these techniques or these system

526
00:24:21,059 --> 00:24:24,360
calls are commonly used for in attacks

527
00:24:24,360 --> 00:24:27,620
like process injection

528
00:24:28,740 --> 00:24:31,620
and there are some other events that we

529
00:24:31,620 --> 00:24:33,000
collect there's some miscellaneous

530
00:24:33,000 --> 00:24:34,980
events system call events that we

531
00:24:34,980 --> 00:24:38,299
collect which are primarily

532
00:24:38,299 --> 00:24:41,640
commonly used in exploitation techniques

533
00:24:41,640 --> 00:24:43,260
like

534
00:24:43,260 --> 00:24:44,280
um

535
00:24:44,280 --> 00:24:47,100
like halting kernel processing or

536
00:24:47,100 --> 00:24:49,380
interrupting kernel from from the user

537
00:24:49,380 --> 00:24:51,559
space

538
00:24:53,220 --> 00:24:55,919
and last but not least we also collect

539
00:24:55,919 --> 00:24:58,140
container creation events because

540
00:24:58,140 --> 00:25:00,000
these events allow us to provide

541
00:25:00,000 --> 00:25:01,740
container level details and pod level

542
00:25:01,740 --> 00:25:05,240
details and they also allow us to track

543
00:25:05,240 --> 00:25:10,159
behavior of various containers and parts

544
00:25:13,679 --> 00:25:16,740
the ebpf agent ah

545
00:25:16,740 --> 00:25:20,640
primarily collects events and sends

546
00:25:20,640 --> 00:25:23,700
those events out to the back end it does

547
00:25:23,700 --> 00:25:26,400
not Implement any rules

548
00:25:26,400 --> 00:25:29,480
within the agent

549
00:25:30,059 --> 00:25:33,659
this architecture allows us to update

550
00:25:33,659 --> 00:25:38,100
and add rules quickly it also allows us

551
00:25:38,100 --> 00:25:40,200
to perform more complex processing on

552
00:25:40,200 --> 00:25:42,299
the back end

553
00:25:42,299 --> 00:25:44,580
so after the agent sends the events we

554
00:25:44,580 --> 00:25:46,679
collect events at the back end

555
00:25:46,679 --> 00:25:50,179
and then we pass all the events

556
00:25:50,179 --> 00:25:53,400
and we apply threat intelligence

557
00:25:53,400 --> 00:25:56,299
to all those events to identify

558
00:25:56,299 --> 00:25:59,580
to identify connections with known bad

559
00:25:59,580 --> 00:26:03,020
IP addresses and domains

560
00:26:03,419 --> 00:26:05,880
we then also Pass events to our estate

561
00:26:05,880 --> 00:26:08,940
less rules these are the rules which are

562
00:26:08,940 --> 00:26:12,659
which use a single event in isolation

563
00:26:12,659 --> 00:26:14,820
and then we also have more complex

564
00:26:14,820 --> 00:26:18,480
stateful rules which depend on more than

565
00:26:18,480 --> 00:26:20,159
one events

566
00:26:20,159 --> 00:26:23,640
and in future we also plan to pass these

567
00:26:23,640 --> 00:26:27,120
events to machine learning in order to

568
00:26:27,120 --> 00:26:29,820
profile behavior of various entities in

569
00:26:29,820 --> 00:26:31,620
customers environment

570
00:26:31,620 --> 00:26:35,400
and use those learnings for anomaly

571
00:26:35,400 --> 00:26:37,760
detection

572
00:26:41,880 --> 00:26:45,360
now I'm going to go through a simple

573
00:26:45,360 --> 00:26:46,559
scenario

574
00:26:46,559 --> 00:26:48,860
in order to just illustrate what type of

575
00:26:48,860 --> 00:26:50,880
detections that

576
00:26:50,880 --> 00:26:54,600
ebpf allows us to generate this is a

577
00:26:54,600 --> 00:26:56,580
simple command injection scenario a

578
00:26:56,580 --> 00:26:58,020
command injection vulnerability

579
00:26:58,020 --> 00:27:00,539
exploitation inside a web application

580
00:27:00,539 --> 00:27:03,020
which is running inside a container

581
00:27:03,020 --> 00:27:05,400
inside a pod

582
00:27:05,400 --> 00:27:07,799
so the attacker exploits or the threat

583
00:27:07,799 --> 00:27:09,779
actor exploits this command injection

584
00:27:09,779 --> 00:27:11,400
vulnerability

585
00:27:11,400 --> 00:27:15,480
in order to First download a cryptominer

586
00:27:15,480 --> 00:27:17,820
and then they download they execute the

587
00:27:17,820 --> 00:27:19,140
cryptominer

588
00:27:19,140 --> 00:27:21,720
and then the crypto Miner connects to a

589
00:27:21,720 --> 00:27:24,140
mining pool

590
00:27:25,679 --> 00:27:27,659
so in the first step when the attacker

591
00:27:27,659 --> 00:27:29,820
downloads the crypto Miner

592
00:27:29,820 --> 00:27:32,700
using file system operations we detect

593
00:27:32,700 --> 00:27:34,799
that a new file

594
00:27:34,799 --> 00:27:37,320
has been downloaded at runtime which is

595
00:27:37,320 --> 00:27:40,140
kind of container runtime drift

596
00:27:40,140 --> 00:27:42,000
right at this point we don't generate

597
00:27:42,000 --> 00:27:45,059
any detection we just maintain or store

598
00:27:45,059 --> 00:27:47,159
these States state that this is a new

599
00:27:47,159 --> 00:27:49,020
file which has been downloaded to The

600
00:27:49,020 --> 00:27:51,120
Container at runtime

601
00:27:51,120 --> 00:27:53,820
in the next step when the attacker

602
00:27:53,820 --> 00:27:57,480
executes this new file

603
00:27:57,480 --> 00:28:00,179
we detect that oh this was a new file

604
00:28:00,179 --> 00:28:02,940
and it was executed inside the container

605
00:28:02,940 --> 00:28:05,700
so we generate new binary executed

606
00:28:05,700 --> 00:28:07,380
detection

607
00:28:07,380 --> 00:28:10,080
so this detection is good in context of

608
00:28:10,080 --> 00:28:11,760
containers because containers are

609
00:28:11,760 --> 00:28:14,460
supposed to be immutable at runtime so

610
00:28:14,460 --> 00:28:17,419
there is detections shows that you know

611
00:28:17,419 --> 00:28:19,559
something was downloaded to The

612
00:28:19,559 --> 00:28:24,200
Container during runtime and execute it

613
00:28:26,460 --> 00:28:28,200
next up

614
00:28:28,200 --> 00:28:30,659
using the execution process execution

615
00:28:30,659 --> 00:28:32,220
event

616
00:28:32,220 --> 00:28:33,240
um

617
00:28:33,240 --> 00:28:35,880
we are also able to identify that in

618
00:28:35,880 --> 00:28:38,299
known binary which is a known

619
00:28:38,299 --> 00:28:42,179
crypto Miner was executed using its

620
00:28:42,179 --> 00:28:45,240
short 256 hash as well as using the the

621
00:28:45,240 --> 00:28:47,940
name of the binary

622
00:28:47,940 --> 00:28:49,679
and then when the crypto Miner connects

623
00:28:49,679 --> 00:28:52,320
to the mining pool

624
00:28:52,320 --> 00:28:54,900
we have the the IP address of that

625
00:28:54,900 --> 00:28:57,720
mining pool as a known IP address or

626
00:28:57,720 --> 00:28:59,760
known mining pool IP address when it

627
00:28:59,760 --> 00:29:01,679
connects to that IP address based on the

628
00:29:01,679 --> 00:29:03,860
threat intelligence we are able to

629
00:29:03,860 --> 00:29:06,720
generate a Direction

630
00:29:06,720 --> 00:29:09,179
so these are the types of detections

631
00:29:09,179 --> 00:29:11,520
which ebpf allows us to generate the

632
00:29:11,520 --> 00:29:13,320
main difference the the main point here

633
00:29:13,320 --> 00:29:15,559
is that that we are able to provide

634
00:29:15,559 --> 00:29:18,600
detailed context information in these

635
00:29:18,600 --> 00:29:20,580
detections

636
00:29:20,580 --> 00:29:24,120
so this is just an example of one of

637
00:29:24,120 --> 00:29:26,880
these detections so you can see that

638
00:29:26,880 --> 00:29:29,940
we are able to provide pod level details

639
00:29:29,940 --> 00:29:32,340
and then container level details such as

640
00:29:32,340 --> 00:29:34,980
container name

641
00:29:34,980 --> 00:29:37,020
and then we also are able to provide

642
00:29:37,020 --> 00:29:39,659
process level details all the details of

643
00:29:39,659 --> 00:29:42,059
the process and even the lineage of the

644
00:29:42,059 --> 00:29:46,320
process or which which shows you the the

645
00:29:46,320 --> 00:29:48,120
ancestors of the process like the direct

646
00:29:48,120 --> 00:29:52,699
parent grandparent of the process

647
00:29:52,980 --> 00:29:55,679
and we are also able to provide the

648
00:29:55,679 --> 00:29:59,100
runtime context which is related to or

649
00:29:59,100 --> 00:30:00,960
which is specific to the finding for

650
00:30:00,960 --> 00:30:02,760
example this is for the new binary

651
00:30:02,760 --> 00:30:04,980
executed file finding

652
00:30:04,980 --> 00:30:07,080
and in this case binary path which is

653
00:30:07,080 --> 00:30:09,179
the path of the new binary which was

654
00:30:09,179 --> 00:30:12,539
executed and the process that created

655
00:30:12,539 --> 00:30:15,000
the binary or modified the binary we are

656
00:30:15,000 --> 00:30:16,500
able to provide the details of that

657
00:30:16,500 --> 00:30:18,799
process

658
00:30:18,840 --> 00:30:20,520
yeah

659
00:30:20,520 --> 00:30:23,100
so I'm going to pass

660
00:30:23,100 --> 00:30:24,779
to Jeremy

661
00:30:24,779 --> 00:30:26,760
to wrap up the presentation

662
00:30:26,760 --> 00:30:30,260
great thanks Lucy

663
00:30:31,860 --> 00:30:33,539
okay

664
00:30:33,539 --> 00:30:36,539
uh so to quickly summarize what we

665
00:30:36,539 --> 00:30:37,820
talked about here

666
00:30:37,820 --> 00:30:40,860
ebpf is an attractive option for threat

667
00:30:40,860 --> 00:30:43,679
detection because it can capture events

668
00:30:43,679 --> 00:30:47,940
from the kernel and the data can also be

669
00:30:47,940 --> 00:30:51,059
enriched to provide additional context

670
00:30:51,059 --> 00:30:53,820
and it's really good for threat

671
00:30:53,820 --> 00:30:56,460
detection applications such as guard

672
00:30:56,460 --> 00:30:59,520
Duty because it's lightweight it's

673
00:30:59,520 --> 00:31:02,220
portable and doesn't require changes to

674
00:31:02,220 --> 00:31:05,340
the kernel and when it's combined with

675
00:31:05,340 --> 00:31:08,820
the power of the cloud it can be used to

676
00:31:08,820 --> 00:31:11,399
find the proverbial needles in the

677
00:31:11,399 --> 00:31:14,039
haystack that allow you to focus on the

678
00:31:14,039 --> 00:31:16,620
root cause of a security incident

679
00:31:16,620 --> 00:31:18,840
uh and with that I want to thank you for

680
00:31:18,840 --> 00:31:21,179
coming to the session today again my

681
00:31:21,179 --> 00:31:24,000
name is Jeremy Cowan uh this is Muhammad

682
00:31:24,000 --> 00:31:26,760
and we'll be here if you have questions

683
00:31:26,760 --> 00:31:28,510
thanks

684
00:31:28,510 --> 00:31:35,119
[Applause]

685
00:31:38,159 --> 00:31:40,460
yes

686
00:31:46,980 --> 00:31:49,700
not yet

687
00:31:51,600 --> 00:31:53,600
um

688
00:31:54,000 --> 00:31:56,820
I I wouldn't I cannot say if there are

689
00:31:56,820 --> 00:31:59,220
any plans or like we are not actively

690
00:31:59,220 --> 00:32:01,919
working just to be accurate on those

691
00:32:01,919 --> 00:32:05,419
second question is

692
00:32:06,299 --> 00:32:10,279
a typical traffic site foreign

693
00:32:18,720 --> 00:32:21,179
so is the question what is the size or

694
00:32:21,179 --> 00:32:22,799
what is the performance impact of

695
00:32:22,799 --> 00:32:26,179
running an ebpf program

696
00:32:29,820 --> 00:32:32,580
yeah that's one of the major

697
00:32:32,580 --> 00:32:34,799
considerations right the volume of the

698
00:32:34,799 --> 00:32:37,380
events that you collect on Linux

699
00:32:37,380 --> 00:32:41,279
workloads is pretty significant the size

700
00:32:41,279 --> 00:32:45,059
of individual events is not that much in

701
00:32:45,059 --> 00:32:46,140
general

702
00:32:46,140 --> 00:32:48,419
um it's typically what we have noticed

703
00:32:48,419 --> 00:32:52,080
is that it's around 1K 1K bytes per

704
00:32:52,080 --> 00:32:54,659
event but the the volume of events is

705
00:32:54,659 --> 00:32:55,760
pretty high

706
00:32:55,760 --> 00:32:58,980
so and this is the reason at the back

707
00:32:58,980 --> 00:33:01,740
end we have to use certain several

708
00:33:01,740 --> 00:33:03,779
optimization techniques to bring down

709
00:33:03,779 --> 00:33:06,140
the cost

710
00:33:13,860 --> 00:33:15,480
immigrated

711
00:33:15,480 --> 00:33:20,000
this is a feature we are thinking about

712
00:33:36,659 --> 00:33:39,600
this is going to be part of guard Duty

713
00:33:39,600 --> 00:33:42,480
Patrol which was announced at re invent

714
00:33:42,480 --> 00:33:45,140
last year

715
00:33:46,919 --> 00:33:50,960
it's looking at the kubernetes auto lock

716
00:33:51,539 --> 00:33:54,019
yes

717
00:34:14,760 --> 00:34:17,760
okay

718
00:34:29,399 --> 00:34:31,580
yeah the question is

719
00:34:31,580 --> 00:34:34,800
Falco is deployed as Damon said

720
00:34:34,800 --> 00:34:35,399
um

721
00:34:35,399 --> 00:34:38,460
then what's the

722
00:34:38,460 --> 00:34:41,219
demons had said and

723
00:34:41,219 --> 00:34:43,379
what we are doing and then how we are

724
00:34:43,379 --> 00:34:45,239
managing the resources how we are making

725
00:34:45,239 --> 00:34:47,219
sure that enough resources are are

726
00:34:47,219 --> 00:34:48,899
available on nodes

727
00:34:48,899 --> 00:34:51,780
and secondly what's the advantage over

728
00:34:51,780 --> 00:34:54,500
open source

729
00:34:55,560 --> 00:34:58,260
so we are working to offer multiple

730
00:34:58,260 --> 00:35:00,420
deployment options one of the primary

731
00:35:00,420 --> 00:35:02,700
ones again would be using Daemon set on

732
00:35:02,700 --> 00:35:06,599
eks right and we are trying to make it

733
00:35:06,599 --> 00:35:08,940
as hands-free as possible for customers

734
00:35:08,940 --> 00:35:11,579
the customers that choose to choose to

735
00:35:11,579 --> 00:35:13,859
do it right and then there will be other

736
00:35:13,859 --> 00:35:16,079
options as well where customers will be

737
00:35:16,079 --> 00:35:17,180
able to

738
00:35:17,180 --> 00:35:20,400
integrate the agent with their CID CD

739
00:35:20,400 --> 00:35:22,940
Pipeline and then deploy themselves

740
00:35:22,940 --> 00:35:26,460
so we are working with to provide

741
00:35:26,460 --> 00:35:29,180
multiple options

742
00:35:30,480 --> 00:35:33,859
in terms of advantages

743
00:35:34,500 --> 00:35:37,560
I believe it's it's it's

744
00:35:37,560 --> 00:35:41,839
the primary benefit is is

745
00:35:42,000 --> 00:35:45,359
the customers just like guard Duty

746
00:35:45,359 --> 00:35:46,320
um

747
00:35:46,320 --> 00:35:49,320
the customers the the the the customers

748
00:35:49,320 --> 00:35:50,700
are going to get

749
00:35:50,700 --> 00:35:53,880
kind of a ready product where they don't

750
00:35:53,880 --> 00:35:55,619
have to really pick and choose what

751
00:35:55,619 --> 00:35:58,020
rules they need to enable what type of

752
00:35:58,020 --> 00:36:00,119
settings that they need for Daemon set

753
00:36:00,119 --> 00:36:02,640
or you know what

754
00:36:02,640 --> 00:36:03,960
um

755
00:36:03,960 --> 00:36:06,060
how they are going to set up the back

756
00:36:06,060 --> 00:36:08,700
end in order for backend processing of

757
00:36:08,700 --> 00:36:12,420
the events you know if the volume of the

758
00:36:12,420 --> 00:36:15,240
events is too high then you need lots of

759
00:36:15,240 --> 00:36:17,760
engineering even for an individual

760
00:36:17,760 --> 00:36:21,359
customer you may end up you know

761
00:36:21,359 --> 00:36:23,760
deploying lots of processing

762
00:36:23,760 --> 00:36:26,400
capabilities in order to manage the

763
00:36:26,400 --> 00:36:29,460
volumes of the events so that's the

764
00:36:29,460 --> 00:36:32,400
customers are going to be relieved from

765
00:36:32,400 --> 00:36:35,420
from that work

766
00:36:37,619 --> 00:36:40,619
foreign

767
00:36:44,339 --> 00:36:47,280
how it reduced the VPC function start

768
00:36:47,280 --> 00:36:48,060
time

769
00:36:48,060 --> 00:36:51,599
I don't I don't have the details on that

770
00:36:51,599 --> 00:36:52,680
um

771
00:36:52,680 --> 00:36:54,599
I I didn't have an opportunity to talk

772
00:36:54,599 --> 00:36:57,480
to a member of the team before this this

773
00:36:57,480 --> 00:37:02,220
presentation I did read a paper on it I

774
00:37:02,220 --> 00:37:03,180
have to admit I didn't understand

775
00:37:03,180 --> 00:37:06,000
everything that was in that paper

776
00:37:06,000 --> 00:37:07,920
um but if you come see me afterwards I

777
00:37:07,920 --> 00:37:10,760
can give you my contact information

778
00:37:32,280 --> 00:37:36,240
yeah as much as we could uh we we try to

779
00:37:36,240 --> 00:37:39,000
hook into LSM hook points or

780
00:37:39,000 --> 00:37:42,660
or the internal kernel functions which

781
00:37:42,660 --> 00:37:44,700
are invoked after the kernel has read

782
00:37:44,700 --> 00:37:47,660
the input arguments

783
00:38:02,760 --> 00:38:04,320
more than just secure

784
00:38:04,320 --> 00:38:06,180
security exactly it was just an example

785
00:38:06,180 --> 00:38:08,820
okay okay there's several LSM hooks that

786
00:38:08,820 --> 00:38:11,420
we are working in

787
00:38:19,020 --> 00:38:21,960
any other questions

788
00:38:21,960 --> 00:38:23,160
all right well if there are other

789
00:38:23,160 --> 00:38:24,540
questions thanks again for coming to the

790
00:38:24,540 --> 00:38:26,420
session I really appreciate it thank you

791
00:38:26,420 --> 00:38:29,460
oh and um don't forget to rate the

792
00:38:29,460 --> 00:38:31,700
session

