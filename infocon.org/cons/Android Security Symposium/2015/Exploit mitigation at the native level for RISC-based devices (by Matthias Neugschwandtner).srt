1
00:00:08,330 --> 00:00:11,030
so thankful

2
00:00:11,030 --> 00:00:12,290
yeah

3
00:00:12,290 --> 00:00:15,209
there is no end right

4
00:00:15,210 --> 00:00:19,070
and so we taking actually a little bit
of broader perspective it's not just

5
00:00:19,070 --> 00:00:23,939
like it but it's very bad advice
especially ones that are based on risk

6
00:00:23,939 --> 00:00:28,740
processes my name is like to thank you
for the introduction and actually added

7
00:00:28,740 --> 00:00:33,739
to work together with Collin Mulliner
who would have had to slot today but

8
00:00:33,739 --> 00:00:37,890
unfortunately he couldn't come recently
started a new job and most of the work

9
00:00:37,890 --> 00:00:43,710
was actually done we did together at
Northeastern University ok let's get

10
00:00:43,710 --> 00:00:47,040
started as a setting for liver the
broader perspective and I'm going to

11
00:00:47,040 --> 00:00:51,980
talk about embedded devices which of
course the phone most precious my phone

12
00:00:51,980 --> 00:00:57,069
but like any phones are just one of them
right and if you look at embedded

13
00:00:57,070 --> 00:01:01,289
devices really interesting because
they're producing very large quantities

14
00:01:01,289 --> 00:01:06,740
they're not actually a computer but the
our computer and it sounds are often

15
00:01:06,740 --> 00:01:11,600
based on low-cost risk-based CPUs
producing masses cross exceptions as

16
00:01:11,600 --> 00:01:12,309
well

17
00:01:12,310 --> 00:01:16,159
example CPUs for smartphones have more
features

18
00:01:16,159 --> 00:01:22,100
system devices round full-fledged
operating system sometimes trip down to

19
00:01:22,100 --> 00:01:26,658
seven degrees some features remove some
features editor and so on but for

20
00:01:26,659 --> 00:01:30,220
example to take a look at the course and
writers Linux and many smart TVs

21
00:01:30,220 --> 00:01:39,180
actually run Linux and relatives R under
root root root of Linux but it was

22
00:01:39,180 --> 00:01:44,049
interesting from a security point of
view because they're very little types

23
00:01:44,049 --> 00:01:47,430
they're always on the contain
interesting personal data especially

24
00:01:47,430 --> 00:01:54,100
phones right and sometimes in control
quite important things and of course

25
00:01:54,100 --> 00:01:55,079
they contain

26
00:01:55,079 --> 00:02:01,798
bilities runs of them might be subject
to memory corruption vulnerabilities and

27
00:02:01,799 --> 00:02:05,450
so that exploded like that stop
themselves however the problem with

28
00:02:05,450 --> 00:02:09,300
embedded devices and journalists at the
medications on those devices are often

29
00:02:09,300 --> 00:02:10,830
very often

30
00:02:10,830 --> 00:02:18,780
of state of the art so native coat I'm
really glad that we've heard native Cody

31
00:02:18,780 --> 00:02:20,690
mentioned before already

32
00:02:20,690 --> 00:02:26,440
memory corruption of what we talked
about it yet we fought and red cross the

33
00:02:26,440 --> 00:02:30,620
apps run Java but it's definitely
possible to run native code as well and

34
00:02:30,620 --> 00:02:35,480
Justin Tuck before I have been
introduced to stage fright already on

35
00:02:35,480 --> 00:02:39,959
Android you can have sometimes difficult
running if developers frown and more

36
00:02:39,960 --> 00:02:44,930
insecure let's put it that way if you
take a look at our state of the art

37
00:02:44,930 --> 00:02:49,880
litigations well known monster estate
Execution Prevention which is really

38
00:02:49,880 --> 00:02:55,660
nice because you can make memory pages
not executable and discusses hinders

39
00:02:55,660 --> 00:03:01,230
codex protection against this requires
harder support which only proper CPU

40
00:03:01,230 --> 00:03:06,970
somewhat higher and for example armament
devices to have and emulation exists but

41
00:03:06,970 --> 00:03:13,140
is usually slow and they can also be
bypassed to some extent using code reuse

42
00:03:13,140 --> 00:03:18,510
techniques such as return to divert its
own oriented programming than others

43
00:03:18,510 --> 00:03:23,489
address space layout randomization which
is also state of the art physically move

44
00:03:23,490 --> 00:03:28,220
colliton unpredictable location and
memories of it can be exploited using

45
00:03:28,220 --> 00:03:34,010
code reuse this again can be bypassed
although it's hard of course using

46
00:03:34,010 --> 00:03:39,590
information being sent to return to
problem thanks again then already

47
00:03:39,590 --> 00:03:44,280
also ahead controls integrity been
mentioned in the talk before which

48
00:03:44,280 --> 00:03:48,810
basically takes about an old blogs
executed out of order to mitigate code

49
00:03:48,810 --> 00:03:54,420
reuse attacks but in order to work
efficiency it out every crisis or scold

50
00:03:54,420 --> 00:04:00,040
end or compiler support and in other
cases that leads to really high overhead

51
00:04:00,040 --> 00:04:04,970
then again from a very different angle
this system call opposing for

52
00:04:04,970 --> 00:04:11,420
enforcement methods like a saloon legs
and arm are our system call anomaly

53
00:04:11,420 --> 00:04:18,048
detection they require use of the prep
configuration or two on what the

54
00:04:18,048 --> 00:04:21,979
implications then

55
00:04:21,980 --> 00:04:28,640
again where some of us a lot of research
that uses hardware features that were

56
00:04:28,640 --> 00:04:34,320
not originally designed for security but
can be used to dispel 228 insecurity on

57
00:04:34,320 --> 00:04:40,620
devices for example the last branch
record simply register physically tracks

58
00:04:40,620 --> 00:04:46,120
allows branches that can be used for COD
to detect code reuse attacks and salsa

59
00:04:46,120 --> 00:04:50,050
performance measurement count insist can
be used for the same reason but the

60
00:04:50,050 --> 00:04:55,740
problem with them again is there x86
only usually they're not present on on

61
00:04:55,740 --> 00:05:03,160
risk and lower-end devices okay I'm
sorry he was somehow leverage common

62
00:05:03,160 --> 00:05:08,970
hardware features of risk for security
many risks Lee vs under Smith's super

63
00:05:08,970 --> 00:05:17,460
age and so on and they all follow the
same design physically and at the same

64
00:05:17,460 --> 00:05:22,680
time we wanted to avoid a very very
specific venture to avoid using specific

65
00:05:22,680 --> 00:05:28,980
functionality such as the last branch
Record Office x86 and so when you look

66
00:05:28,980 --> 00:05:33,790
at this architecture features of risk
factors are excuses register only

67
00:05:33,790 --> 00:05:37,990
operation so you have to slow start
architecture deal the slot for memory in

68
00:05:37,990 --> 00:05:43,930
to register and safe from this again
there's a couple of specialists

69
00:05:43,930 --> 00:05:49,100
registers and yet many registers for
example in control so we'll come back to

70
00:05:49,100 --> 00:05:50,100
that later

71
00:05:50,100 --> 00:05:53,530
yes fix instruction lens that makes it a
little bit more easy to disassemble

72
00:05:53,530 --> 00:06:00,859
workers have to travel the transfection
x86 and you usually have enforcement off

73
00:06:00,860 --> 00:06:04,980
instruction or adverse alignment so that
you can't just jump into the middle of

74
00:06:04,980 --> 00:06:11,490
destruction which you would normally do
with retirement program so our goal is

75
00:06:11,490 --> 00:06:15,870
to bring state of the obligations to me
by the wrist devices we wanted to build

76
00:06:15,870 --> 00:06:21,510
a life with text me to Goshen that is
also suitable for more budget systems

77
00:06:21,510 --> 00:06:26,230
that uses risks hardware features and

78
00:06:26,230 --> 00:06:30,070
unless the third feature that is
tailored for binary only are coming off

79
00:06:30,070 --> 00:06:34,230
the shelf program basically where you
often don't have to source code

80
00:06:34,230 --> 00:06:37,590
available so you're bound to using a
sudden library and you only have to live

81
00:06:37,590 --> 00:06:47,570
in finery but not to Sasuke taking sides
stop when we look at fundamentals of

82
00:06:47,570 --> 00:06:53,099
exploits exploits use operating system
functionality so to read and write a

83
00:06:53,100 --> 00:06:57,600
total launched a program that will
process that will usually ship it to the

84
00:06:57,600 --> 00:07:06,070
caramel and see that they can perform
certain functions and inside his the

85
00:07:06,070 --> 00:07:10,700
operating system usage of an exploit
usually differs from that of an original

86
00:07:10,700 --> 00:07:14,650
program so I have different system
caused a used order used with different

87
00:07:14,650 --> 00:07:23,179
parameters and if we can ensure that the
runtime operating system usage is

88
00:07:23,180 --> 00:07:28,770
coherent with the operating use it with
the USA in the binary executive orders

89
00:07:28,770 --> 00:07:33,880
are stored on a disk then would
definitely better security benefit of

90
00:07:33,880 --> 00:07:40,260
that wants to make sure that system
costs have been used actually also used

91
00:07:40,260 --> 00:07:43,760
by der executive orders start and disk
that's awesome

92
00:07:43,760 --> 00:07:48,380
argument matches and the culturing that
leads up to the system costs that they

93
00:07:48,380 --> 00:07:51,440
also match and becoming the whole thing

94
00:07:51,440 --> 00:07:58,790
minor integrity of our shop integrity
from a different angle if you look at

95
00:07:58,790 --> 00:08:03,330
this so many people security if you have
definitely heard of all this system

96
00:08:03,330 --> 00:08:08,530
monitors and so on and a policy based
solutions for you but you're locked down

97
00:08:08,530 --> 00:08:14,450
what's but an application can do but the
problem with policy based solutions is

98
00:08:14,450 --> 00:08:20,080
policies first they need to be defined
and then they need to be kept updated if

99
00:08:20,080 --> 00:08:25,359
you do make them to white maybe an
attacker can bypass time should make

100
00:08:25,360 --> 00:08:29,250
them to narrow maybe the app doesn't
work correctly anymore she update the

101
00:08:29,250 --> 00:08:33,729
absentee add some new functionalities
you might actually break to happen and

102
00:08:33,729 --> 00:08:36,159
it doesn't run

103
00:08:36,159 --> 00:08:40,870
so with integrity we have a nice
approach that the application binaries

104
00:08:40,870 --> 00:08:45,839
actually the policy so the binary the
program itself provides us with all the

105
00:08:45,839 --> 00:08:55,480
information about what it is doing and
attractive programs run time state and

106
00:08:55,480 --> 00:08:59,980
we always compare it with state PA zip
code that we extract from the banner

107
00:08:59,980 --> 00:09:07,209
image and if we have none matching
States something diverge here then we

108
00:09:07,209 --> 00:09:15,969
can say okay and attack us happened to
provide something like that

109
00:09:15,970 --> 00:09:21,839
functionality I don't exactly like like
to say that we just provide it excuse my

110
00:09:21,839 --> 00:09:25,300
French because it's actually a little
bit more than we do so what we do is we

111
00:09:25,300 --> 00:09:30,889
don't execute code that is present on
the binary under disc there is some

112
00:09:30,889 --> 00:09:37,279
super lightweight see if I metal stud we
use and we also provide a secure system

113
00:09:37,279 --> 00:09:45,259
call filter policy approach without
actually having to specify a policy

114
00:09:45,259 --> 00:09:51,850
yeah there's by no means there's no
effort needed instrumentation effort

115
00:09:51,850 --> 00:09:57,910
needed and also no extra configuration
if you take a look at the threat model

116
00:09:57,910 --> 00:10:02,300
that we take into account what we're
seeing is that we have a trusted Carmel

117
00:10:02,300 --> 00:10:08,319
so we protect users basecoat basically
we see ok we trust all the banners of

118
00:10:08,319 --> 00:10:14,050
the start on this because of costs are
higher ground to ground truth and we

119
00:10:14,050 --> 00:10:18,758
assume that the executive salaries are
not modified been attacker however

120
00:10:18,759 --> 00:10:25,579
memories basically the process runtime
estate is America's uses untrusted

121
00:10:25,579 --> 00:10:30,769
because we will try to fight off memory
corruption index

122
00:10:30,769 --> 00:10:36,910
after the system works if that out with
a binary acceptable to the store and a

123
00:10:36,910 --> 00:10:41,469
disk and it's been launched then we end
up with a random process that has all

124
00:10:41,470 --> 00:10:46,209
the memory and register sounds on
associated with it and at some point

125
00:10:46,209 --> 00:10:49,649
because of us do something the process
will issue a system call and request

126
00:10:49,649 --> 00:10:56,389
service from the operating system so
that's where we intercept we basically

127
00:10:56,389 --> 00:11:01,999
check and take a look at the bank
executives and at around 10 process and

128
00:11:01,999 --> 00:11:08,049
CEO kay has to run time process been
corrupted in any way is not behaving

129
00:11:08,049 --> 00:11:14,949
according to do finally on the desk and
if that's ok we were operating system

130
00:11:14,949 --> 00:11:21,299
called proceed if not we terminate the
program what kind of information do we

131
00:11:21,299 --> 00:11:26,239
extract from the runtime state-owned
what do we basically need what we have

132
00:11:26,239 --> 00:11:31,110
here is like the typical state of a
process front of a process at the time

133
00:11:31,110 --> 00:11:36,449
of a system call after program that
first performance function call into a

134
00:11:36,449 --> 00:11:43,219
library say Lipsy we're usually have
some system call rapper and the system

135
00:11:43,220 --> 00:11:47,459
called rapid and actually performs the
actual system call into the conf weather

136
00:11:47,459 --> 00:11:52,199
system cause being taken care of by the
system call handler so the information

137
00:11:52,199 --> 00:11:58,118
that we have at the system convocation
is first the return address which points

138
00:11:58,119 --> 00:12:04,179
back into the library but we also have
is the system cannot possibly know of

139
00:12:04,179 --> 00:12:07,689
course which system call has been
involved and we do have the system call

140
00:12:07,689 --> 00:12:13,419
arguments physically ok see you bright
ok which further scripted we write and

141
00:12:13,419 --> 00:12:17,350
then what we have as well on the risk is
the link address linked addresses pretty

142
00:12:17,350 --> 00:12:21,230
nice because it's Register containing
the return addresses the last

143
00:12:21,230 --> 00:12:28,489
functioning location which was then went
back into the program and I'm upstairs

144
00:12:28,489 --> 00:12:33,799
actually even one additional register
the beginning take that we can use a

145
00:12:33,799 --> 00:12:38,689
cause de vir specifies that usually use
an extra register to perform indirect

146
00:12:38,689 --> 00:12:42,160
transfer we have too tired for this one
as well

147
00:12:42,160 --> 00:12:47,889
ok given all the information we now need
to inspect the binary rights we need to

148
00:12:47,889 --> 00:12:55,420
take a look at the winery on the disc
and here we have a function we have a

149
00:12:55,420 --> 00:13:00,729
function product does say this is the
same Dakota start on that this virus of

150
00:13:00,730 --> 00:13:05,620
some sex face the argument assignment
you can see the arguments which are

151
00:13:05,620 --> 00:13:09,939
being loaded into the argument registers
is also pretty risks and that so you

152
00:13:09,939 --> 00:13:16,189
Pastor arguments to function invocation
by registers and then we have a function

153
00:13:16,189 --> 00:13:16,819
call

154
00:13:16,819 --> 00:13:21,399
29 register which is standard register
to perform an indirect function called

155
00:13:21,399 --> 00:13:29,740
over and the final Dunlop instructions
basically a link address points back

156
00:13:29,740 --> 00:13:38,279
into the now from does from this from
this link address offset in the binary

157
00:13:38,279 --> 00:13:42,379
so the system does is basically dakotas
been starving to death because we want

158
00:13:42,379 --> 00:13:48,829
to get our ground truth we start to
disassemble backwards we do that I don't

159
00:13:48,829 --> 00:13:53,410
have the function beginning or until we
get some control for their version and

160
00:13:53,410 --> 00:14:00,199
when we stop this is coming back once
you start to execute that basically

161
00:14:00,199 --> 00:14:07,859
forward and then be basically V extract
all the invariance which other countries

162
00:14:07,860 --> 00:14:13,439
values at the end of execution in this
case we would know for example after

163
00:14:13,439 --> 00:14:20,219
week this execution in relation that in
the argument register a zero we have

164
00:14:20,220 --> 00:14:27,920
been telling sapir seven right and yet
as a set-aside aesthetic announces that

165
00:14:27,920 --> 00:14:31,540
we perform on a binary executable on a
disk and not on the memory confidence

166
00:14:31,540 --> 00:14:40,670
can be used to structure the enforce the
Spanish integrity so there's three three

167
00:14:40,670 --> 00:14:45,490
basic pillars let's put it that way too
far sometimes called provenance so

168
00:14:45,490 --> 00:14:49,250
which are basically where do the
function invocation is originated from

169
00:14:49,250 --> 00:14:55,870
and we only allow alleged locations so
say if we have functioned location that

170
00:14:55,870 --> 00:15:00,420
comes from the sticker data segment or
something then we then this is of course

171
00:15:00,420 --> 00:15:05,420
not alleged than we have called
integrity very checkered a call chain is

172
00:15:05,420 --> 00:15:09,490
reflected by the banner itself and
whether the system call arguments that

173
00:15:09,490 --> 00:15:13,670
we concede matched invariant said we
have extracted before from the binary on

174
00:15:13,670 --> 00:15:18,520
the disc and the third thing that we do
sample integrity here which Ecuador

175
00:15:18,520 --> 00:15:23,680
system covers that our system called
rapid that has been used but has

176
00:15:23,680 --> 00:15:31,319
actually been imported by the native
code program that's been execute to

177
00:15:31,320 --> 00:15:37,190
enforce this cold provenance which is
like our yeah that's the Super date

178
00:15:37,190 --> 00:15:40,680
Execution Prevention that we do that's
why don't really like to ever date

179
00:15:40,680 --> 00:15:45,890
execution because we do more a little
bit so we first construct our trusted

180
00:15:45,890 --> 00:15:51,170
application code base and distrusted
application code base is it contains all

181
00:15:51,170 --> 00:15:56,050
the valid code regions after process
runtime emerged so these are the map

182
00:15:56,050 --> 00:16:00,319
text segments of the running process
itself and it also includes the text

183
00:16:00,320 --> 00:16:04,860
segments of drivers of costs and it's
been fixated after linking stage say

184
00:16:04,860 --> 00:16:10,550
anything that's outside just trusted
application called business section

185
00:16:10,550 --> 00:16:15,579
envelop so both the return addresses the
return of a softer system call and a

186
00:16:15,579 --> 00:16:23,620
link address need to pointed to a dog's
coat which for enforcing code integrity

187
00:16:23,620 --> 00:16:32,200
again I have to assemble snip snip its
talks a little bit more

188
00:16:32,200 --> 00:16:38,360
and somewhat we can check HERE and sign
the left hand side we have to we have to

189
00:16:38,360 --> 00:16:42,720
the program called basically those been
executed by the program you can see that

190
00:16:42,720 --> 00:16:48,540
should be called here in the city for
example and on the right hand side we

191
00:16:48,540 --> 00:16:51,819
have two system call rubber which
actually then will execute the system

192
00:16:51,820 --> 00:16:57,680
just end up system called so knowing the
return address you can check whether the

193
00:16:57,680 --> 00:16:59,520
previous of the return address

194
00:16:59,520 --> 00:17:03,170
actually is a system called so the
return address will point to the

195
00:17:03,170 --> 00:17:10,819
construction on the right 10,000 and so
the first thing that we can verify Okies

196
00:17:10,819 --> 00:17:15,409
to code actually there and then the next
thing that we can take it has to write

197
00:17:15,410 --> 00:17:20,270
system called been involved because the
system call number of courses in a

198
00:17:20,270 --> 00:17:27,650
signed writing system qualification then
the next thing that we can do is check

199
00:17:27,650 --> 00:17:30,570
the link address and you can check
whether the predecessor of the link

200
00:17:30,570 --> 00:17:36,770
address is really like similar to the
system called case is actually really a

201
00:17:36,770 --> 00:17:42,660
jumper dress DDD address voters as
traction issues and whether the target

202
00:17:42,660 --> 00:17:48,150
of the branch actually matches colleague
the right system has actually been

203
00:17:48,150 --> 00:17:52,150
involved and

204
00:17:52,150 --> 00:17:56,030
you can also check whether the actual
system call arguments match the

205
00:17:56,030 --> 00:18:05,330
invariance said we have extracted before
simple integrity so if you think of just

206
00:18:05,330 --> 00:18:13,010
a normal program uses a map to assemble
a map has to be under 100 exported by

207
00:18:13,010 --> 00:18:17,670
the library which would be the decision
and it has to be imported by the program

208
00:18:17,670 --> 00:18:23,900
writes it has to be an import able to
export program and with simple and what

209
00:18:23,900 --> 00:18:28,050
we basically do is be checked at the
symbol of the function that we have

210
00:18:28,050 --> 00:18:33,780
identified by the return address so in
Lipsy ok we can see that misused so

211
00:18:33,780 --> 00:18:40,340
endemic is associated with me and export
to check that it also has been imported

212
00:18:40,340 --> 00:18:45,510
by the binary that has been identified
by the link address system for example

213
00:18:45,510 --> 00:18:51,060
system has been used and system has
never been imported by the boundary to

214
00:18:51,060 --> 00:18:56,070
begin with but a program then this is
also clearly not a valid information

215
00:18:56,070 --> 00:19:05,169
which kinds of a text can be mitigated
with this technique so first of all

216
00:19:05,170 --> 00:19:11,460
those are basically indexes injection
attacks so say I want to inject code

217
00:19:11,460 --> 00:19:15,240
into the data segment than the defense
would be too cold provenance because

218
00:19:15,240 --> 00:19:20,880
it's in a day to Sacramento and those
that say I don't know I put something in

219
00:19:20,880 --> 00:19:25,750
the cheaper and it's not actually in the
background of this have caught robbing

220
00:19:25,750 --> 00:19:33,890
and prevent this from happening if I
decide I okay so protected so I try to

221
00:19:33,890 --> 00:19:40,880
override to text second say I might the
text segments writable then again we

222
00:19:40,880 --> 00:19:43,870
have called integrity because
instructions with actually mismatch with

223
00:19:43,870 --> 00:19:46,469
the binary on the disc

224
00:19:46,470 --> 00:19:50,590
reuse our texts got a little bit more
complicated it is an indirect

225
00:19:50,590 --> 00:19:55,709
championship being used then we will see
that the target of the branch actually

226
00:19:55,710 --> 00:19:59,870
doesn't does not match

227
00:19:59,870 --> 00:20:07,830
another we would be that the symbol
integrity dozen fires so that for

228
00:20:07,830 --> 00:20:17,300
example say system has not been imported
and if you retire into programming

229
00:20:17,300 --> 00:20:21,309
so-called reuse attack again and
actually use it to call the library

230
00:20:21,309 --> 00:20:26,809
function instead directly without going
through an indirect rampaged then we can

231
00:20:26,809 --> 00:20:32,410
still check if we if we have static
arguments whether those arguments match

232
00:20:32,410 --> 00:20:37,030
so better the runtime arguments actually
match from the arguments have been

233
00:20:37,030 --> 00:20:45,670
extracted from the bosnia running on the
disc also since the table before I got

234
00:20:45,670 --> 00:20:50,270
some some concrete examples of what we
have here is such an indirect captured

235
00:20:50,270 --> 00:20:56,290
as I said before so you should try to
tease address is being loaded into T

236
00:20:56,290 --> 00:21:01,250
nine and down the argument is being
loaded into a zero and then we have to

237
00:21:01,250 --> 00:21:09,040
indirect John piety nine so in this case
if we if an attack of word abuses by by

238
00:21:09,040 --> 00:21:12,220
putting something else and T nine and
dentures compound interest going

239
00:21:12,220 --> 00:21:19,350
directly to this indirect champ then
yeah 29 but not mention invariant and

240
00:21:19,350 --> 00:21:27,379
we've got to basically detector
different here we have a fixed budget

241
00:21:27,380 --> 00:21:38,920
this is very clear branches 22 right so
to the right system cover and as we can

242
00:21:38,920 --> 00:21:45,250
see here at statically 2021 which
basically corresponds to send out for

243
00:21:45,250 --> 00:21:57,080
example discounted could not be reused
to rise to a different script with a map

244
00:21:57,080 --> 00:22:02,669
that happens actually quite often so in
this case we have something here that is

245
00:22:02,670 --> 00:22:06,419
originally being called

246
00:22:06,419 --> 00:22:13,799
an argument to the past memories just
read an exception table which is the

247
00:22:13,799 --> 00:22:21,700
value 5 and again if an attacker would
see modified is here and 22 load to load

248
00:22:21,700 --> 00:22:25,580
7 which which corresponds to read write
executive rights into the argument

249
00:22:25,580 --> 00:22:34,570
register and try to overwrite this again
see that we govern our commitment and

250
00:22:34,570 --> 00:22:40,840
this is actually the case that I
mentioned before so say I've got them in

251
00:22:40,840 --> 00:22:45,619
the Reg temperature does not have any
restrictions so the last thing that that

252
00:22:45,619 --> 00:22:53,570
still can still kick in here is that if
29 has been replaced by the adverse

253
00:22:53,570 --> 00:23:03,899
after after system of the system
function in Ypsi but system is not used

254
00:23:03,899 --> 00:23:08,320
by the program itself so it's not an
import able then we will again see I see

255
00:23:08,320 --> 00:23:12,529
ok it has not been important either
imported by the program so we terminated

256
00:23:12,529 --> 00:23:20,830
if you take a look at the typical drop
staged reading program in which is a

257
00:23:20,830 --> 00:23:24,460
physical examination off mama return
oriented programming traditional sale

258
00:23:24,460 --> 00:23:30,230
code that first users retirement and
programming to mark an executive member

259
00:23:30,230 --> 00:23:39,100
region by commemoration expectable sorry
basically puts up a lot in there and

260
00:23:39,100 --> 00:23:43,840
done on maps with also need to flush the
cache physically manifested in the

261
00:23:43,840 --> 00:23:47,970
memory than here the code reuse
mitigation would kick in and at the same

262
00:23:47,970 --> 00:23:53,570
time when it's us to try to execute a
traditional shouted the payload in

263
00:23:53,570 --> 00:23:59,950
December region we would have to code
injection mitigation so yeah we

264
00:23:59,950 --> 00:24:07,810
implemented this whole system as a model
for Linux

265
00:24:07,810 --> 00:24:12,490
and which basically consists of a couple
of parts so it interacts with both

266
00:24:12,490 --> 00:24:18,000
process to extractor on time information
and with the boundaries on the disk then

267
00:24:18,000 --> 00:24:22,940
we have two Malaysian engine which
consists of an El Paso because we need

268
00:24:22,940 --> 00:24:28,440
to parse pacifier is on the disc and
actually does evokes with strict

269
00:24:28,440 --> 00:24:30,610
boundaries not a problem

270
00:24:30,610 --> 00:24:35,709
disassembler and a complete code
emulator in it that we implemented for

271
00:24:35,710 --> 00:24:44,970
both arms and the MIPS architecture and
we also have an invariant cast which I

272
00:24:44,970 --> 00:24:49,910
will come back to later because these
are quite costly operations

273
00:24:49,910 --> 00:24:57,720
disassembling and emulation so we also
catch some information our

274
00:24:57,720 --> 00:25:00,840
implementation supports different
checking levels because not all

275
00:25:00,840 --> 00:25:06,080
functions are critical the same way and
so we can reduce checking to increase

276
00:25:06,080 --> 00:25:12,169
performance and some ways as an option
that this model supports so we have

277
00:25:12,170 --> 00:25:16,950
physical level one checks that just
check for code provenance level two

278
00:25:16,950 --> 00:25:22,770
checks that includes on top of that code
integrity and Level three checks on top

279
00:25:22,770 --> 00:25:30,440
of that include simple integrity as well
so basically 24 program and so and Linux

280
00:25:30,440 --> 00:25:39,140
we identify 233 security critical system
cause and this instrument basically 11

281
00:25:39,140 --> 00:25:44,390
attacking level 20 and 22 checking level
3 the reason for this is also dead

282
00:25:44,390 --> 00:25:49,940
some sanctions are just used by every
program so checking them too

283
00:25:49,940 --> 00:25:55,529
for example for some integrity does not
does not provide any additional security

284
00:25:55,529 --> 00:26:02,039
benefit example if you write will
probably be used by almost every program

285
00:26:02,039 --> 00:26:09,950
which has checked were called integrity
of course we also did a performance

286
00:26:09,950 --> 00:26:16,960
evaluation we had something to do come
right so get abused them over have to do

287
00:26:16,960 --> 00:26:25,590
this we used the Buffalo router that
runs runs Linux open beauty and used a

288
00:26:25,590 --> 00:26:29,600
patch of benchmarking and genetics and
be governor proximate run from overhead

289
00:26:29,600 --> 00:26:36,789
of 2 percent on this we also evaluated
on the Galaxy Nexus phone just running

290
00:26:36,789 --> 00:26:41,879
stock Android although I don't remember
the exact Android version that you ran

291
00:26:41,879 --> 00:26:47,408
yesterday and 22 benchmark cost of us
divested we could find a measured the

292
00:26:47,409 --> 00:26:56,860
Android runtime NL sub system and here
we had an even though he also did an

293
00:26:56,860 --> 00:27:00,408
entire performance evaluation as I said
before we have quite costly operation

294
00:27:00,409 --> 00:27:07,480
said I involved we read and pass highest
at the start of this honor system call

295
00:27:07,480 --> 00:27:13,370
indication that usually takes lots of
time we also have to instruction

296
00:27:13,370 --> 00:27:21,459
emulation and we also have a certain
memory footprint model code which is not

297
00:27:21,460 --> 00:27:29,620
that big and we also have the invariant
cash actually is stores variants of this

298
00:27:29,620 --> 00:27:37,008
debated at the extraction the binaries
for around 257 points so it's roughly

299
00:27:37,009 --> 00:27:47,710
requires total of 12 kilobytes per
process against not that much actually

300
00:27:47,710 --> 00:27:55,360
sells how much cashing heights of
catching us to the whole thing so that

301
00:27:55,360 --> 00:28:00,449
the red box shows how much the overhead
would be under the scale if we would not

302
00:28:00,450 --> 00:28:01,920
have cashing but as soon as

303
00:28:01,920 --> 00:28:11,140
article points in a significantly lower
so whenever we have cascaded actually

304
00:28:11,140 --> 00:28:20,520
it's not that bad and we have yeah so
what we did here is we had that summer

305
00:28:20,520 --> 00:28:24,490
running on on the router be busted

306
00:28:24,490 --> 00:28:31,360
weapons on the relative absence of a
browser running on Android on are and

307
00:28:31,360 --> 00:28:35,100
what we can see here and I see is that
at program startup we have lots of

308
00:28:35,100 --> 00:28:40,750
invariant extractions so this of course
lots of system calls have been done at

309
00:28:40,750 --> 00:28:46,100
program startup then cashing in and we
are basically I think regarding to

310
00:28:46,100 --> 00:28:49,980
invariant instructions and only as soon
as we actually saw off to the website

311
00:28:49,980 --> 00:28:56,470
and open it up we have again a peak and
then any subsequent texts this basically

312
00:28:56,470 --> 00:29:07,160
don't exercise super new code paths so
it cannot levels out over time coming to

313
00:29:07,160 --> 00:29:13,000
conclusions so what we did as
architectural features of risks that are

314
00:29:13,000 --> 00:29:17,680
basically intrinsic to risk and they're
down fairly generic to the improved

315
00:29:17,680 --> 00:29:23,380
security of embedded devices and we
provide addition to say this is a

316
00:29:23,380 --> 00:29:27,270
traditional benefit for platforms
without hardware security and this is

317
00:29:27,270 --> 00:29:35,500
not super super additional benefit for
top of the line Android phones dead

318
00:29:35,500 --> 00:29:40,890
already run and Bryant the newest
version but will definitely benefit the

319
00:29:40,890 --> 00:29:46,720
world and budget crisis and we provides
that plaque functionality for those

320
00:29:46,720 --> 00:29:52,830
devices we have light weights for body
only applications so we don't require

321
00:29:52,830 --> 00:30:00,449
source code and yeah system called
filter policy extraction method from the

322
00:30:00,450 --> 00:30:04,340
actual binary image so you don't need to
write extra policies for this and it

323
00:30:04,340 --> 00:30:11,740
also has produced no overhead and
transparent to applications this is also

324
00:30:11,740 --> 00:30:13,570
not research paper route to stuff

325
00:30:13,570 --> 00:30:17,730
actually exists and you're interested
you can also have a look at the source

326
00:30:17,730 --> 00:30:29,650
code here so thank you for the talk

327
00:30:29,650 --> 00:30:44,950
any questions right now

328
00:30:44,950 --> 00:30:51,380
you say that your solution is different
from previous works because you don't

329
00:30:51,380 --> 00:30:57,149
need kind of policy you can just look
into the binary so my question is why

330
00:30:57,149 --> 00:31:03,330
you think it is much different because
to restore possible targets you have to

331
00:31:03,330 --> 00:31:09,299
analyze control for graph of the
application and maybe previous works

332
00:31:09,299 --> 00:31:14,059
they just extracted the policy then
stored somewhere you don't story to just

333
00:31:14,059 --> 00:31:15,580
do it on the fly

334
00:31:15,580 --> 00:31:20,639
why conceptually addressing it is
different so one thing that i think is

335
00:31:20,639 --> 00:31:27,709
different its stately that basically
everything happens at runtime so it's

336
00:31:27,710 --> 00:31:33,480
transparent is no policy that user has
to take care of anything being involved

337
00:31:33,480 --> 00:31:38,110
and usually this solutions would not
involve the user they would just analyze

338
00:31:38,110 --> 00:31:43,340
the binary they would make a policy and
automated way and then in force at

339
00:31:43,340 --> 00:31:47,649
runtime what you're doing you do the
same but just you don't store it you

340
00:31:47,649 --> 00:31:53,149
just applied immediately and I don't you
can really struggled very precise fully

341
00:31:53,149 --> 00:32:00,479
seized because actually static analysis
cannot restore the targets very

342
00:32:00,480 --> 00:32:06,919
precisely so your policy would be who's
this is my guess is also pretty likely

343
00:32:06,919 --> 00:32:11,580
solution right we do this time and we do
the system qualification and we also we

344
00:32:11,580 --> 00:32:16,029
don't expect tractor pulls his chief of
the of the program we don't do that so

345
00:32:16,029 --> 00:32:21,100
really we just two is at runtime when
this happens we peek back into the into

346
00:32:21,100 --> 00:32:26,209
the boundary and we look what kind of
coldest and hottest disco too so there's

347
00:32:26,210 --> 00:32:31,429
no complete see if G generation involved
just take a look at those too cold

348
00:32:31,429 --> 00:32:38,080
points as really targeted at ya at the
very very low level right before the

349
00:32:38,080 --> 00:32:43,779
system convocation so you'll probably be
able to throw he beats some pressure

350
00:32:43,779 --> 00:32:50,410
militias transfers but you don't know

351
00:32:50,410 --> 00:32:57,360
transfers many targets and you cannot be
sure if the one which happens currently

352
00:32:57,360 --> 00:33:03,610
the correct one and send it entirely

353
00:33:03,610 --> 00:33:08,429
know it's it's not a pure CFI solution
that world that that will enforce the

354
00:33:08,430 --> 00:33:18,340
whole path up to the system i mean
because can you ensure that

355
00:33:18,340 --> 00:33:29,279
by verifying the binary you can resolve
the exact target by static analysis of

356
00:33:29,279 --> 00:33:37,260
your binary can you be sure that my
point is you can never be sure and it

357
00:33:37,260 --> 00:33:48,658
doesn't matter if you do not help
against all attacks and if you have a

358
00:33:48,659 --> 00:33:52,230
very very severe determined attacker he
will for sure

359
00:33:52,230 --> 00:34:01,260
find a way of crafting a path that that
will that will try to buy passes I mean

360
00:34:01,260 --> 00:34:05,629
it's with many security solutions it's
fun it's another way of raising the bar

361
00:34:05,630 --> 00:34:16,010
right

362
00:34:16,010 --> 00:34:22,320
so first of all I think this is a very
interesting solution may be out just got

363
00:34:22,320 --> 00:34:30,520
lost in the details but exploits left to
execute functions like system and what

364
00:34:30,520 --> 00:34:37,889
about to target application actually use
assistance Oda importantly the arguments

365
00:34:37,889 --> 00:34:45,490
are not in the area and can your
solution that completely depends on how

366
00:34:45,489 --> 00:34:49,330
system is involved in how it is being
used right so if the system is always

367
00:34:49,330 --> 00:34:53,940
been used with string constant at the
start and a binary then yes because we

368
00:34:53,940 --> 00:34:59,020
have to spring concert in the binary if
if I write native code and invoke system

369
00:34:59,020 --> 00:35:05,270
with a dynamically generated string I'm
not sure it's it's like super super

370
00:35:05,270 --> 00:35:11,770
security sensitive coating and I mean
it's it's in some way of course limited

371
00:35:11,770 --> 00:35:16,100
to what application gives you everything
that we can enforce depends on how it

372
00:35:16,100 --> 00:35:23,970
has been written original ok I'm afraid
calls to system actually to construct

373
00:35:23,970 --> 00:35:39,480
thank you

374
00:35:39,480 --> 00:35:47,890
you mentioned that you're actually
comparing the winery that loaded against

375
00:35:47,890 --> 00:35:58,529
the winery located we are comparing data
run home process image in memory against

376
00:35:58,530 --> 00:36:03,230
the binary data stored on the disk so
actually

377
00:36:03,230 --> 00:36:08,250
in Java application they the binary on
the

378
00:36:08,250 --> 00:36:11,680
is text format

379
00:36:11,680 --> 00:36:18,299
something that the dollar is actually
cheating and you get when you receive

380
00:36:18,300 --> 00:36:26,080
something totally different format from
what the disc yes there's also this

381
00:36:26,080 --> 00:36:31,230
applies to two native quarter ever does
not apply to 22 July 22 2009 mean we are

382
00:36:31,230 --> 00:36:39,700
compatible with it because basically
what we do is we get it right but but

383
00:36:39,700 --> 00:37:02,250
not not steal Java code that has been
executed thank you

384
00:37:02,250 --> 00:37:17,890
work but was wondering where are you
could also portis 286 performs there are

385
00:37:17,890 --> 00:37:24,930
those who stare but what do you think
that your solution supporting in to exit

386
00:37:24,930 --> 00:37:31,450
262 don't stand correctly yes or whether
or not you can you can integrity

387
00:37:31,450 --> 00:37:38,250
integrity to the excess exposed so
certain difficulties involved on x86

388
00:37:38,250 --> 00:37:43,360
because for example we use have it
backwards this assembly which is easy on

389
00:37:43,360 --> 00:37:48,340
risk because we have six instructions
that length insists this is i mean you

390
00:37:48,340 --> 00:37:52,820
never really know what you're going to
bed because this assembly right so this

391
00:37:52,820 --> 00:37:58,510
will definitely be one of the strikers
and then we rely heavily under under

392
00:37:58,510 --> 00:38:04,200
register base architecture so physical
that passes arguments in registers

393
00:38:04,200 --> 00:38:09,890
usually tries not to modify them in a
certain way and so on which you don't

394
00:38:09,890 --> 00:38:15,460
have to do is extend on x86 I mean I
know it and an X on 64 bit edition

395
00:38:15,460 --> 00:38:21,360
leader calling conventions to pass
already arguments in registers yes that

396
00:38:21,360 --> 00:38:30,320
would only target then 64 bits

397
00:38:30,320 --> 00:38:38,730
questions to me to have a tough one
again did you try to the specific

398
00:38:38,730 --> 00:38:46,210
exploit the driver that specific exploit
so the problem is no we did not which

399
00:38:46,210 --> 00:38:51,560
which doesn't matter the beginning right
but we took a look at various experts

400
00:38:51,560 --> 00:38:56,540
but they're very hard to to recreate
because for example we looked at a

401
00:38:56,540 --> 00:39:01,460
drought exploits but you need to have
the exact same router model running the

402
00:39:01,460 --> 00:39:08,030
exact same software on the router and
really we struggle to to to to get to

403
00:39:08,030 --> 00:39:11,410
get a whole set of basically running
because some of the roads are not

404
00:39:11,410 --> 00:39:17,180
available anymore they need to go to
Ebay and I thought ok I can spend time

405
00:39:17,180 --> 00:39:22,200
better than doing this but we looked at
the actual exploits and how day and yes

406
00:39:22,200 --> 00:39:26,000
actually I mean there's a paper on this
mission academic conference that

407
00:39:26,000 --> 00:39:32,470
exploits which would have been me to get
many of them would still go through them

408
00:39:32,470 --> 00:39:42,180
would still go through that I don't have
exact numbers in my head so

409
00:39:42,180 --> 00:39:43,690
thanks again thanks a lot

