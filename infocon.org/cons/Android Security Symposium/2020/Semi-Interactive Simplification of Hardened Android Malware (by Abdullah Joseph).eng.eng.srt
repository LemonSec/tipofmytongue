1
00:00:07,839 --> 00:00:11,679
the next

2
00:00:08,720 --> 00:00:12,719
talk is called semi interactive

3
00:00:11,679 --> 00:00:15,839
simplification

4
00:00:12,719 --> 00:00:18,640
of hardened android malware

5
00:00:15,839 --> 00:00:20,640
abdullah is the mobile security team

6
00:00:18,640 --> 00:00:23,680
lead of the company at just

7
00:00:20,640 --> 00:00:26,000
located in berlin germany providing

8
00:00:23,680 --> 00:00:29,039
mobile analytics services

9
00:00:26,000 --> 00:00:30,240
and overseeing the security of mobile

10
00:00:29,039 --> 00:00:32,640
open source

11
00:00:30,240 --> 00:00:33,360
libraries integrated into tens of

12
00:00:32,640 --> 00:00:36,320
thousands

13
00:00:33,360 --> 00:00:37,760
of devices hitting a total of more than

14
00:00:36,320 --> 00:00:40,960
400 billion

15
00:00:37,760 --> 00:00:42,640
data points per month which is a quite

16
00:00:40,960 --> 00:00:45,120
impressive number to deal with

17
00:00:42,640 --> 00:00:46,399
he's researching on mobile advertisement

18
00:00:45,120 --> 00:00:48,959
fraud schemes

19
00:00:46,399 --> 00:00:49,920
and how to develop appropriate counter

20
00:00:48,960 --> 00:00:51,600
measures

21
00:00:49,920 --> 00:00:53,600
today he's going to talk about the

22
00:00:51,600 --> 00:00:56,239
omnipresent technique of

23
00:00:53,600 --> 00:00:57,280
binary code obfuscation as far as i

24
00:00:56,239 --> 00:01:00,559
understood that

25
00:00:57,280 --> 00:01:03,280
and semi-automated methods to simplify

26
00:01:00,559 --> 00:01:04,158
a hardened android code base so uh

27
00:01:03,280 --> 00:01:06,320
welcome

28
00:01:04,159 --> 00:01:08,880
abdullah we're eager to hear your

29
00:01:06,320 --> 00:01:08,880
insights

30
00:01:08,960 --> 00:01:17,520
hey eric can you hear me

31
00:01:13,840 --> 00:01:17,520
um is the voice okay

32
00:01:18,880 --> 00:01:23,520
yes the voice is okay thanks perfect uh

33
00:01:21,920 --> 00:01:24,640
just one thing about the title

34
00:01:23,520 --> 00:01:26,320
uh thank you so much for the

35
00:01:24,640 --> 00:01:27,439
introduction about the title me and my

36
00:01:26,320 --> 00:01:29,758
friend had a bet

37
00:01:27,439 --> 00:01:31,679
if we can make a tech talk with the

38
00:01:29,759 --> 00:01:35,200
longest possible title that we can

39
00:01:31,680 --> 00:01:38,560
and i think i won so

40
00:01:35,200 --> 00:01:38,560
all right let me see if i can share my

41
00:01:38,840 --> 00:01:41,840
screen

42
00:01:42,000 --> 00:01:48,079
can you see my screen

43
00:01:46,079 --> 00:01:50,320
with this yes you can see your screen

44
00:01:48,079 --> 00:01:55,839
everything's working fine

45
00:01:50,320 --> 00:01:55,839
perfect perfect well

46
00:01:55,920 --> 00:02:00,079
one second hello guys uh i would

47
00:01:58,880 --> 00:02:04,079
actually it's a shame that

48
00:02:00,079 --> 00:02:05,919
uh we can't have a physical meeting

49
00:02:04,079 --> 00:02:07,039
but i guess due to the times that we

50
00:02:05,920 --> 00:02:08,479
live in right now we're just gonna have

51
00:02:07,040 --> 00:02:12,080
to settle for zoom

52
00:02:08,479 --> 00:02:13,599
um my name is abdullah joseph and

53
00:02:12,080 --> 00:02:16,000
today i would like to talk to you guys

54
00:02:13,599 --> 00:02:18,000
about uh something that

55
00:02:16,000 --> 00:02:19,440
i was researching as part of my job

56
00:02:18,000 --> 00:02:22,720
which is

57
00:02:19,440 --> 00:02:26,000
usually looking into fraud ad fraud

58
00:02:22,720 --> 00:02:27,440
prevention techniques because of that

59
00:02:26,000 --> 00:02:29,680
most of the things that i look at are

60
00:02:27,440 --> 00:02:30,800
malware adware usually it's called in

61
00:02:29,680 --> 00:02:32,640
that space

62
00:02:30,800 --> 00:02:34,160
and adware has some really interesting

63
00:02:32,640 --> 00:02:36,720
functionality

64
00:02:34,160 --> 00:02:37,599
people usually do it without any some

65
00:02:36,720 --> 00:02:41,040
without any

66
00:02:37,599 --> 00:02:42,238
um interesting root kits or jailbreaks

67
00:02:41,040 --> 00:02:43,920
that you can see

68
00:02:42,239 --> 00:02:46,160
uh exploits running in the wild they

69
00:02:43,920 --> 00:02:48,160
usually use whatever it is that is

70
00:02:46,160 --> 00:02:49,599
that they have living off of the land i

71
00:02:48,160 --> 00:02:51,599
guess that's what it's called

72
00:02:49,599 --> 00:02:53,920
so you basically see them trying to

73
00:02:51,599 --> 00:02:56,319
install an application

74
00:02:53,920 --> 00:02:57,599
an apk downloaded for the sole purpose

75
00:02:56,319 --> 00:03:01,119
of making what's called

76
00:02:57,599 --> 00:03:03,040
in the um in the ad industry an install

77
00:03:01,120 --> 00:03:04,879
which means that you can get attributed

78
00:03:03,040 --> 00:03:07,200
to a network with that money

79
00:03:04,879 --> 00:03:09,840
and basically if you keep doing this add

80
00:03:07,200 --> 00:03:11,599
infinitum

81
00:03:09,840 --> 00:03:13,280
i don't know 1 000 times you can make

82
00:03:11,599 --> 00:03:15,200
very good money

83
00:03:13,280 --> 00:03:16,720
so this is the field of research that i

84
00:03:15,200 --> 00:03:18,319
work on

85
00:03:16,720 --> 00:03:21,280
and today i would like to talk to you a

86
00:03:18,319 --> 00:03:23,359
little bit about some of the

87
00:03:21,280 --> 00:03:25,599
interesting malware that you can find

88
00:03:23,360 --> 00:03:27,040
the 20 percentile not the most of the

89
00:03:25,599 --> 00:03:28,720
ones that you see on the wild

90
00:03:27,040 --> 00:03:31,040
these are the ones that you see that

91
00:03:28,720 --> 00:03:32,640
have really cool affiscation techniques

92
00:03:31,040 --> 00:03:33,920
and software protection mechanisms

93
00:03:32,640 --> 00:03:36,079
behind it

94
00:03:33,920 --> 00:03:38,079
this is the agenda for today uh it does

95
00:03:36,080 --> 00:03:39,599
include a small demo so i really hope

96
00:03:38,080 --> 00:03:41,120
that with the new laptop because my

97
00:03:39,599 --> 00:03:43,760
laptop

98
00:03:41,120 --> 00:03:44,400
my macbook spilled coffee on it

99
00:03:43,760 --> 00:03:47,120
yesterday

100
00:03:44,400 --> 00:03:48,000
this is a new laptop i really hope the

101
00:03:47,120 --> 00:03:50,239
demo works

102
00:03:48,000 --> 00:03:51,760
and if it doesn't that's god just

103
00:03:50,239 --> 00:03:53,680
doesn't like me today

104
00:03:51,760 --> 00:03:56,319
so uh without further ado let's talk

105
00:03:53,680 --> 00:03:59,360
about software protection

106
00:03:56,319 --> 00:04:00,319
so i met a few malware authors in my

107
00:03:59,360 --> 00:04:03,680
life

108
00:04:00,319 --> 00:04:05,439
i don't know exactly how their job

109
00:04:03,680 --> 00:04:07,680
their 40-hour week looks like but

110
00:04:05,439 --> 00:04:09,439
imagining it's something like this

111
00:04:07,680 --> 00:04:10,799
so basically your boss comes and he

112
00:04:09,439 --> 00:04:11,840
tells you you need to make something

113
00:04:10,799 --> 00:04:14,560
that works

114
00:04:11,840 --> 00:04:16,959
something that can get us money through

115
00:04:14,560 --> 00:04:18,880
malicious ways and it's undetectable

116
00:04:16,959 --> 00:04:20,720
why should it be undetectable because

117
00:04:18,880 --> 00:04:21,680
malware is actually detected all the

118
00:04:20,720 --> 00:04:25,120
time

119
00:04:21,680 --> 00:04:26,960
techcrunch loves titles like adware

120
00:04:25,120 --> 00:04:29,199
found in 200 apps in google play

121
00:04:26,960 --> 00:04:30,799
150 million people got impacted by

122
00:04:29,199 --> 00:04:35,440
something and they keep giving it really

123
00:04:30,800 --> 00:04:35,440
cool names like viking horde and simbad

124
00:04:36,080 --> 00:04:39,599
so this is something that is always

125
00:04:38,880 --> 00:04:42,560
being

126
00:04:39,600 --> 00:04:43,840
counter-measured as a malware author you

127
00:04:42,560 --> 00:04:45,919
really need to

128
00:04:43,840 --> 00:04:47,359
start innovating in different techniques

129
00:04:45,919 --> 00:04:50,159
this is not a how to

130
00:04:47,360 --> 00:04:52,960
how to become a black hat talk it's not

131
00:04:50,160 --> 00:04:55,840
this is something that

132
00:04:52,960 --> 00:04:57,198
basically using and trying to expose

133
00:04:55,840 --> 00:05:01,039
some of the techniques that

134
00:04:57,199 --> 00:05:02,880
malware and other good people use

135
00:05:01,039 --> 00:05:05,039
so for example you always see

136
00:05:02,880 --> 00:05:08,159
malwarebytes and snort and

137
00:05:05,039 --> 00:05:09,759
different idss trying to protect against

138
00:05:08,160 --> 00:05:11,199
such malwares trying to protect against

139
00:05:09,759 --> 00:05:12,880
the signatures behind it

140
00:05:11,199 --> 00:05:14,400
trying to for example execute it in a

141
00:05:12,880 --> 00:05:15,759
virtual machine in a virtualized

142
00:05:14,400 --> 00:05:18,159
container

143
00:05:15,759 --> 00:05:20,400
so that it sees the system calls that it

144
00:05:18,160 --> 00:05:23,919
does and it categorizes it if it's

145
00:05:20,400 --> 00:05:24,880
dangerous or not 132 api is very good

146
00:05:23,919 --> 00:05:28,159
with that because

147
00:05:24,880 --> 00:05:28,719
with 132 api you can even see functions

148
00:05:28,160 --> 00:05:31,759
like

149
00:05:28,720 --> 00:05:33,600
crypt encrypt and if you

150
00:05:31,759 --> 00:05:35,039
your friend shared with you a

151
00:05:33,600 --> 00:05:38,320
presentation

152
00:05:35,039 --> 00:05:40,800
about next quarters fiscal

153
00:05:38,320 --> 00:05:41,440
year plan i'm not a finance person and

154
00:05:40,800 --> 00:05:44,400
that

155
00:05:41,440 --> 00:05:46,639
pdf file or the spreadsheet started

156
00:05:44,400 --> 00:05:47,758
calling crypt encrypt and improtect and

157
00:05:46,639 --> 00:05:50,479
trying to allocate

158
00:05:47,759 --> 00:05:51,199
executable readable and writable memory

159
00:05:50,479 --> 00:05:54,000
ranges

160
00:05:51,199 --> 00:05:55,600
don't open it so the thing that we're

161
00:05:54,000 --> 00:05:56,560
going to talk about today is software

162
00:05:55,600 --> 00:05:58,639
protection and

163
00:05:56,560 --> 00:06:00,000
with the percentage of malware that

164
00:05:58,639 --> 00:06:01,840
deals with this techniques

165
00:06:00,000 --> 00:06:03,680
let me adjust the screen a little bit

166
00:06:01,840 --> 00:06:05,280
and it's usually obscure techniques it's

167
00:06:03,680 --> 00:06:06,960
usually things that you find on

168
00:06:05,280 --> 00:06:08,318
freak magazine if anybody is a

169
00:06:06,960 --> 00:06:12,239
subscriber i

170
00:06:08,319 --> 00:06:16,160
usually find it in the really old

171
00:06:12,240 --> 00:06:19,440
html websites techniques relating to

172
00:06:16,160 --> 00:06:21,919
code injection and code caves for

173
00:06:19,440 --> 00:06:22,960
elf binaries and for pe binaries it's

174
00:06:21,919 --> 00:06:25,758
not things that

175
00:06:22,960 --> 00:06:27,599
a lot of people try to it's not things

176
00:06:25,759 --> 00:06:31,039
that you would find

177
00:06:27,600 --> 00:06:34,400
on on just any regular blog

178
00:06:31,039 --> 00:06:35,919
tech blog and the techniques that we are

179
00:06:34,400 --> 00:06:37,440
going to talk about today it's used for

180
00:06:35,919 --> 00:06:39,520
example in stock trading companies if

181
00:06:37,440 --> 00:06:41,600
you have a proprietary trading algorithm

182
00:06:39,520 --> 00:06:43,919
and that's your bread and butter if that

183
00:06:41,600 --> 00:06:45,919
algorithm got leaked there is a problem

184
00:06:43,919 --> 00:06:47,120
you need to execute it on the cloud or

185
00:06:45,919 --> 00:06:49,039
on a client device

186
00:06:47,120 --> 00:06:50,639
that's going to be a problem there's

187
00:06:49,039 --> 00:06:53,120
really cool research right now coming up

188
00:06:50,639 --> 00:06:55,120
called verifiable computation

189
00:06:53,120 --> 00:06:56,720
and multi-party computation that

190
00:06:55,120 --> 00:06:59,440
actually tries to address

191
00:06:56,720 --> 00:07:00,240
exactly this problem you have a function

192
00:06:59,440 --> 00:07:01,840
y

193
00:07:00,240 --> 00:07:03,520
and it has an input x and you want to

194
00:07:01,840 --> 00:07:05,919
execute that function

195
00:07:03,520 --> 00:07:07,039
without revealing too much about how

196
00:07:05,919 --> 00:07:08,560
it's done

197
00:07:07,039 --> 00:07:10,240
and you just basically want to use a

198
00:07:08,560 --> 00:07:12,319
worker there are reasons there is

199
00:07:10,240 --> 00:07:13,840
research that's now happening about that

200
00:07:12,319 --> 00:07:15,919
one of the most important things is game

201
00:07:13,840 --> 00:07:17,840
companies

202
00:07:15,919 --> 00:07:19,440
i believe one time i read a tweet about

203
00:07:17,840 --> 00:07:21,919
the

204
00:07:19,440 --> 00:07:24,000
game creator the game designer for

205
00:07:21,919 --> 00:07:26,000
bioshock the original one

206
00:07:24,000 --> 00:07:27,360
and they basically said that they

207
00:07:26,000 --> 00:07:32,000
achieved their goal of

208
00:07:27,360 --> 00:07:34,319
remaining uncracked for 48 hours

209
00:07:32,000 --> 00:07:35,360
that was a that was an understatement

210
00:07:34,319 --> 00:07:37,280
but um

211
00:07:35,360 --> 00:07:38,639
yeah i mean that thing happens all the

212
00:07:37,280 --> 00:07:39,599
time people try to protect their

213
00:07:38,639 --> 00:07:42,840
proprietary

214
00:07:39,599 --> 00:07:45,759
libraries their proprietary apps

215
00:07:42,840 --> 00:07:47,440
but somehow if you have an analyst

216
00:07:45,759 --> 00:07:48,000
that's dedicated and knowledgeable it's

217
00:07:47,440 --> 00:07:50,319
gonna

218
00:07:48,000 --> 00:07:51,759
it's gonna crack eventually weapon

219
00:07:50,319 --> 00:07:52,560
manufacturing is actually quite

220
00:07:51,759 --> 00:07:55,199
interesting

221
00:07:52,560 --> 00:07:55,680
quite interesting um i stumbled upon

222
00:07:55,199 --> 00:07:58,479
this

223
00:07:55,680 --> 00:07:59,520
u.s army solicitation that says that

224
00:07:58,479 --> 00:08:02,719
anti-tamper

225
00:07:59,520 --> 00:08:05,680
technologies at technologies uh

226
00:08:02,720 --> 00:08:07,280
should be providing exploit it should be

227
00:08:05,680 --> 00:08:08,240
providing protection against

228
00:08:07,280 --> 00:08:10,239
exploitation

229
00:08:08,240 --> 00:08:12,400
via reverse engineering and the purpose

230
00:08:10,240 --> 00:08:14,240
in here is to add longevity

231
00:08:12,400 --> 00:08:15,520
that's a very important word longevity

232
00:08:14,240 --> 00:08:18,400
you can't protect

233
00:08:15,520 --> 00:08:20,159
100 a black box that's not possible

234
00:08:18,400 --> 00:08:22,080
because you you are executing it

235
00:08:20,160 --> 00:08:23,360
okay it's executed on a host and the

236
00:08:22,080 --> 00:08:25,039
idea in here

237
00:08:23,360 --> 00:08:27,120
is that you need to protect it against

238
00:08:25,039 --> 00:08:29,039
the host that you're executing

239
00:08:27,120 --> 00:08:30,560
i'm giving you instructions and you have

240
00:08:29,039 --> 00:08:33,279
to follow those instructions

241
00:08:30,560 --> 00:08:34,399
and if you have memory and if you know

242
00:08:33,279 --> 00:08:36,240
what i'm talking about

243
00:08:34,399 --> 00:08:37,599
you can follow along and say oh this

244
00:08:36,240 --> 00:08:39,200
happened and then this happened and then

245
00:08:37,599 --> 00:08:40,640
this happened that means that the user

246
00:08:39,200 --> 00:08:43,120
is trying to do this

247
00:08:40,640 --> 00:08:45,199
the purpose of software protection is

248
00:08:43,120 --> 00:08:48,000
literally to go against that logic

249
00:08:45,200 --> 00:08:48,800
is to try to make it as diverse and as

250
00:08:48,000 --> 00:08:52,640
diffused

251
00:08:48,800 --> 00:08:54,319
as much as possible so that the person

252
00:08:52,640 --> 00:08:57,040
who's executing the code doesn't know

253
00:08:54,320 --> 00:08:59,760
what they're executing

254
00:08:57,040 --> 00:09:01,519
so this is the cia triad preserving

255
00:08:59,760 --> 00:09:03,439
confidentiality integrity and

256
00:09:01,519 --> 00:09:05,360
availability of data and algorithms and

257
00:09:03,440 --> 00:09:08,080
it applies perfectly in here

258
00:09:05,360 --> 00:09:10,080
so i have a quick example in here um i

259
00:09:08,080 --> 00:09:11,600
would have loved to do this with a live

260
00:09:10,080 --> 00:09:13,600
audience

261
00:09:11,600 --> 00:09:14,880
and ask them questions about it but it

262
00:09:13,600 --> 00:09:16,320
would have been a lot nicer and more

263
00:09:14,880 --> 00:09:19,040
interactive but i'm just going to

264
00:09:16,320 --> 00:09:20,839
stick with my monologue in here so we

265
00:09:19,040 --> 00:09:24,240
have an example in here this is

266
00:09:20,839 --> 00:09:26,720
x86 and no need to be a jedi

267
00:09:24,240 --> 00:09:28,640
basically the explanation is right here

268
00:09:26,720 --> 00:09:29,120
so the first instruction would move zero

269
00:09:28,640 --> 00:09:33,040
to

270
00:09:29,120 --> 00:09:36,720
eax it would test if eax is zero

271
00:09:33,040 --> 00:09:38,000
and if so it will jump to this location

272
00:09:36,720 --> 00:09:40,320
it's pretty straightforward there's

273
00:09:38,000 --> 00:09:41,279
nothing too much about it what happens

274
00:09:40,320 --> 00:09:45,600
if we do

275
00:09:41,279 --> 00:09:48,800
this so let's try to go through it

276
00:09:45,600 --> 00:09:50,160
we move zero to eax we test if eax is

277
00:09:48,800 --> 00:09:53,279
equal to zero

278
00:09:50,160 --> 00:09:56,079
if so we try to jump to hello

279
00:09:53,279 --> 00:09:56,959
and then we're trying to move ebx to eax

280
00:09:56,080 --> 00:09:58,959
and then there is

281
00:09:56,959 --> 00:10:00,000
sid t happening and then we're trying to

282
00:09:58,959 --> 00:10:03,518
get system clock

283
00:10:00,000 --> 00:10:06,320
which is what's happening

284
00:10:03,519 --> 00:10:07,360
the idea in here is that this is all

285
00:10:06,320 --> 00:10:11,200
garbage

286
00:10:07,360 --> 00:10:14,560
that will never be executed ever

287
00:10:11,200 --> 00:10:16,000
x y and z are 100 that you could fill it

288
00:10:14,560 --> 00:10:17,680
in there with data you could fill it

289
00:10:16,000 --> 00:10:18,560
with bunny fufu instructions whatever it

290
00:10:17,680 --> 00:10:21,439
is that you want

291
00:10:18,560 --> 00:10:22,719
this code will live in the binary in the

292
00:10:21,440 --> 00:10:24,640
txt section

293
00:10:22,720 --> 00:10:26,399
and the dot text section but it will

294
00:10:24,640 --> 00:10:28,240
never be executed

295
00:10:26,399 --> 00:10:30,320
why because this is a constant statement

296
00:10:28,240 --> 00:10:32,720
it's called a positive opaque predicate

297
00:10:30,320 --> 00:10:36,000
that means that it's always going to

298
00:10:32,720 --> 00:10:36,880
jump from here from from number three to

299
00:10:36,000 --> 00:10:39,200
number four

300
00:10:36,880 --> 00:10:40,959
always it will never look at x y and z

301
00:10:39,200 --> 00:10:42,160
so you can throw garbage in there that's

302
00:10:40,959 --> 00:10:43,839
another sketching technique it's called

303
00:10:42,160 --> 00:10:46,880
dead code injection

304
00:10:43,839 --> 00:10:48,880
as opposed to a optimization technique

305
00:10:46,880 --> 00:10:52,240
that's called that code elimination

306
00:10:48,880 --> 00:10:52,880
something what llvm is heavily trying to

307
00:10:52,240 --> 00:10:55,519
invest

308
00:10:52,880 --> 00:10:56,800
their time on so this is a technique why

309
00:10:55,519 --> 00:11:00,240
would i throw this in there

310
00:10:56,800 --> 00:11:00,880
confusion literally just confusing the

311
00:11:00,240 --> 00:11:02,880
analyst

312
00:11:00,880 --> 00:11:04,959
trying to make it as hard and as

313
00:11:02,880 --> 00:11:08,320
annoying as possible

314
00:11:04,959 --> 00:11:11,279
to try to google what the hell is sidt

315
00:11:08,320 --> 00:11:12,160
and what's its relationship with the ebp

316
00:11:11,279 --> 00:11:15,120
register

317
00:11:12,160 --> 00:11:17,199
and why am i querying for this thing

318
00:11:15,120 --> 00:11:19,519
this is simple to ignore because you see

319
00:11:17,200 --> 00:11:22,240
a jump set hello in here immediately

320
00:11:19,519 --> 00:11:23,680
if i throw those instructions in between

321
00:11:22,240 --> 00:11:26,000
one and two

322
00:11:23,680 --> 00:11:26,959
and try to make it a little bit more

323
00:11:26,000 --> 00:11:29,120
complicated

324
00:11:26,959 --> 00:11:30,160
we might get to an interesting result

325
00:11:29,120 --> 00:11:33,760
let's take a look at this

326
00:11:30,160 --> 00:11:34,880
example so i have in here a function

327
00:11:33,760 --> 00:11:37,279
don't ask me about the programming

328
00:11:34,880 --> 00:11:40,399
language i think this is you can

329
00:11:37,279 --> 00:11:41,839
this is c yeah this is c

330
00:11:40,399 --> 00:11:43,519
this would work in c this would also

331
00:11:41,839 --> 00:11:46,160
work in java but this is

332
00:11:43,519 --> 00:11:48,240
this is c for now so um actually java

333
00:11:46,160 --> 00:11:49,920
doesn't have int type forget about it

334
00:11:48,240 --> 00:11:52,160
uh so in here we have a function called

335
00:11:49,920 --> 00:11:52,560
foo and it takes three arguments a b and

336
00:11:52,160 --> 00:11:56,160
c

337
00:11:52,560 --> 00:11:59,518
integers and then we do a boolean

338
00:11:56,160 --> 00:12:02,240
mixed boolean operation in here and

339
00:11:59,519 --> 00:12:02,720
we do a minus c what's the result of

340
00:12:02,240 --> 00:12:04,880
this

341
00:12:02,720 --> 00:12:07,839
before anybody wipes out their python

342
00:12:04,880 --> 00:12:10,079
calculators it's a zero

343
00:12:07,839 --> 00:12:11,200
and this is very easy to interpret this

344
00:12:10,079 --> 00:12:13,279
is very easy to do

345
00:12:11,200 --> 00:12:14,399
for a machine this is very easy to do

346
00:12:13,279 --> 00:12:16,480
for a human

347
00:12:14,399 --> 00:12:17,839
with a calculator it should be

348
00:12:16,480 --> 00:12:21,519
straightforward

349
00:12:17,839 --> 00:12:25,120
and if we try to do something like this

350
00:12:21,519 --> 00:12:28,160
which was very hard to write

351
00:12:25,120 --> 00:12:30,160
this executes and it executes well

352
00:12:28,160 --> 00:12:31,519
and there is no problem a machine will

353
00:12:30,160 --> 00:12:35,519
understand this

354
00:12:31,519 --> 00:12:38,560
however if i ask you right now

355
00:12:35,519 --> 00:12:40,399
foo one two three what's the result by

356
00:12:38,560 --> 00:12:43,279
looking at it statically

357
00:12:40,399 --> 00:12:44,160
i don't think you can you can infer the

358
00:12:43,279 --> 00:12:46,880
result in here

359
00:12:44,160 --> 00:12:48,480
it's still zero by the way this will

360
00:12:46,880 --> 00:12:51,200
evaluate to zero

361
00:12:48,480 --> 00:12:52,399
with the arguments one two and three but

362
00:12:51,200 --> 00:12:55,680
right now you just added

363
00:12:52,399 --> 00:12:58,000
a lot of different layers of confusion

364
00:12:55,680 --> 00:12:59,839
and this actually works this is really

365
00:12:58,000 --> 00:13:01,279
complicated if you ask any reverse

366
00:12:59,839 --> 00:13:03,760
engineer

367
00:13:01,279 --> 00:13:05,360
and they would have a certain

368
00:13:03,760 --> 00:13:07,439
methodology of doing things they would

369
00:13:05,360 --> 00:13:09,120
go static analysis maybe or dynamic

370
00:13:07,440 --> 00:13:12,079
analysis depending on

371
00:13:09,120 --> 00:13:13,200
your depending on your work you might go

372
00:13:12,079 --> 00:13:14,560
for something in the middle like

373
00:13:13,200 --> 00:13:15,680
executing it in a virtualized

374
00:13:14,560 --> 00:13:18,000
environment

375
00:13:15,680 --> 00:13:19,439
or emulation for example you might go

376
00:13:18,000 --> 00:13:20,959
for symbolic execution

377
00:13:19,440 --> 00:13:23,120
there is a certain methodology but if

378
00:13:20,959 --> 00:13:24,719
your methodology is relating to

379
00:13:23,120 --> 00:13:26,160
i want to look at the disassembled or

380
00:13:24,720 --> 00:13:29,200
decompiled code

381
00:13:26,160 --> 00:13:30,079
this will really hinder you and the idea

382
00:13:29,200 --> 00:13:32,160
in here

383
00:13:30,079 --> 00:13:33,920
for obfuscation software protection

384
00:13:32,160 --> 00:13:35,439
binary hardening they're all the same is

385
00:13:33,920 --> 00:13:37,920
to make it functionally equivalent but

386
00:13:35,440 --> 00:13:39,600
harder to analyze

387
00:13:37,920 --> 00:13:41,680
so let's talk about the next part of the

388
00:13:39,600 --> 00:13:44,639
presentation automating analysis

389
00:13:41,680 --> 00:13:46,479
so i'm a good guy i'm a analyst and i

390
00:13:44,639 --> 00:13:49,519
got handed a malware

391
00:13:46,480 --> 00:13:51,279
adware something and they are using

392
00:13:49,519 --> 00:13:52,800
automated ways to create something like

393
00:13:51,279 --> 00:13:55,279
this

394
00:13:52,800 --> 00:13:57,279
how would i try to understand it how

395
00:13:55,279 --> 00:13:58,880
would i try to make sense of a certain

396
00:13:57,279 --> 00:14:01,839
operation that's happening

397
00:13:58,880 --> 00:14:02,639
so let's take an example of this this is

398
00:14:01,839 --> 00:14:04,560
java

399
00:14:02,639 --> 00:14:06,639
and i think anybody who looks at this

400
00:14:04,560 --> 00:14:08,638
for with java knowledge

401
00:14:06,639 --> 00:14:10,079
should understand what's happening

402
00:14:08,639 --> 00:14:13,040
basically in here

403
00:14:10,079 --> 00:14:15,519
you have a map it's a hash map or a

404
00:14:13,040 --> 00:14:17,680
dictionary if you're a python person

405
00:14:15,519 --> 00:14:18,880
you basically put some keys and some

406
00:14:17,680 --> 00:14:21,199
values into the map

407
00:14:18,880 --> 00:14:23,040
here we put the key aaa with bunny fufu

408
00:14:21,199 --> 00:14:25,040
bbb with fubuni fu

409
00:14:23,040 --> 00:14:26,800
you get the point and we make a make a

410
00:14:25,040 --> 00:14:30,639
post request

411
00:14:26,800 --> 00:14:34,319
with this ip address and

412
00:14:30,639 --> 00:14:36,160
with this um end point and that's pretty

413
00:14:34,320 --> 00:14:36,800
much it we just passed this parameters

414
00:14:36,160 --> 00:14:39,519
into it

415
00:14:36,800 --> 00:14:40,800
now without looking at make post request

416
00:14:39,519 --> 00:14:42,320
without looking at it if you're

417
00:14:40,800 --> 00:14:44,719
analyzing such a

418
00:14:42,320 --> 00:14:45,920
such a binary and you decompiled it and

419
00:14:44,720 --> 00:14:46,560
you want to understand what's happening

420
00:14:45,920 --> 00:14:47,920
behind it

421
00:14:46,560 --> 00:14:50,079
you really don't need to look at make

422
00:14:47,920 --> 00:14:51,040
post requests to infer what's happening

423
00:14:50,079 --> 00:14:53,359
in here

424
00:14:51,040 --> 00:14:55,839
this is good so far i understand i

425
00:14:53,360 --> 00:14:58,320
wanted to focus on exactly

426
00:14:55,839 --> 00:14:58,959
the parameters that are being sent to

427
00:14:58,320 --> 00:15:01,360
this

428
00:14:58,959 --> 00:15:02,880
drop point that's one way of doing it

429
00:15:01,360 --> 00:15:04,639
another way would be doing something a

430
00:15:02,880 --> 00:15:06,800
little bit more straightforward like

431
00:15:04,639 --> 00:15:07,839
man in the middle attack you would

432
00:15:06,800 --> 00:15:10,240
attach a proxy

433
00:15:07,839 --> 00:15:11,760
in the middle of your host and you run

434
00:15:10,240 --> 00:15:12,639
it on an emulator or you just run the

435
00:15:11,760 --> 00:15:14,560
code

436
00:15:12,639 --> 00:15:17,199
the binary itself and you would analyze

437
00:15:14,560 --> 00:15:18,719
the request for sake of simplicity just

438
00:15:17,199 --> 00:15:19,920
for the sake of presentation

439
00:15:18,720 --> 00:15:21,839
let's assume that man in the middle

440
00:15:19,920 --> 00:15:25,040
attack doesn't exist you

441
00:15:21,839 --> 00:15:25,440
are you see encrypted text so you have

442
00:15:25,040 --> 00:15:28,000
to

443
00:15:25,440 --> 00:15:29,040
jump into the code and you see something

444
00:15:28,000 --> 00:15:31,519
like this

445
00:15:29,040 --> 00:15:33,120
what would happen if uh right now my

446
00:15:31,519 --> 00:15:34,399
goal was to understand the parameters

447
00:15:33,120 --> 00:15:37,279
what would happen if you see something

448
00:15:34,399 --> 00:15:39,360
like this and let's assume just for

449
00:15:37,279 --> 00:15:40,560
um just a thought experiment that man in

450
00:15:39,360 --> 00:15:42,800
the middle attacks

451
00:15:40,560 --> 00:15:43,920
is a little bit hard maybe this post

452
00:15:42,800 --> 00:15:46,880
request is

453
00:15:43,920 --> 00:15:48,079
aes encrypted and you would have to dive

454
00:15:46,880 --> 00:15:49,600
into static analysis

455
00:15:48,079 --> 00:15:52,000
you would have to dive into the code to

456
00:15:49,600 --> 00:15:52,720
understand the values that are being

457
00:15:52,000 --> 00:15:57,040
sent

458
00:15:52,720 --> 00:15:59,600
and you see something like this so

459
00:15:57,040 --> 00:16:01,599
basically in here the first step i would

460
00:15:59,600 --> 00:16:03,839
do is i'm going to try to just take a

461
00:16:01,600 --> 00:16:06,000
cursory look at crypto.get

462
00:16:03,839 --> 00:16:08,160
what what's happening in here um and

463
00:16:06,000 --> 00:16:09,600
what are the parameters what is the uh

464
00:16:08,160 --> 00:16:12,399
return values

465
00:16:09,600 --> 00:16:14,160
for crypto dot get i'm assuming it's not

466
00:16:12,399 --> 00:16:16,160
the same return value

467
00:16:14,160 --> 00:16:17,360
for different arguments so if i give it

468
00:16:16,160 --> 00:16:18,880
different numbers it would give me

469
00:16:17,360 --> 00:16:21,759
different return values just

470
00:16:18,880 --> 00:16:23,279
that's just an assumption let's actually

471
00:16:21,759 --> 00:16:26,160
take a look at crypto.get

472
00:16:23,279 --> 00:16:28,160
and we see something like this if the

473
00:16:26,160 --> 00:16:29,920
screen is a little bit too small

474
00:16:28,160 --> 00:16:31,199
you're not meant to read it but i'm just

475
00:16:29,920 --> 00:16:33,759
going to go ahead and

476
00:16:31,199 --> 00:16:34,839
scroll over it in here we see an

477
00:16:33,759 --> 00:16:38,320
interesting

478
00:16:34,839 --> 00:16:39,199
unicode byte array in here character

479
00:16:38,320 --> 00:16:40,959
array

480
00:16:39,199 --> 00:16:44,319
and we see some interesting things

481
00:16:40,959 --> 00:16:48,160
happening in here with xor is going on

482
00:16:44,320 --> 00:16:49,040
and then we see things like this plus 99

483
00:16:48,160 --> 00:16:51,120
and we have some

484
00:16:49,040 --> 00:16:52,480
interesting fields that were the names

485
00:16:51,120 --> 00:16:54,399
were automatically generated by my

486
00:16:52,480 --> 00:16:55,360
decompiler and we see a switch statement

487
00:16:54,399 --> 00:16:58,079
that looks

488
00:16:55,360 --> 00:16:58,720
pretty readable this is very very

489
00:16:58,079 --> 00:17:01,040
readable

490
00:16:58,720 --> 00:17:05,199
i can understand it perfectly and we see

491
00:17:01,040 --> 00:17:07,599
some interesting predicates like this

492
00:17:05,199 --> 00:17:09,039
and we move on to the third one and you

493
00:17:07,599 --> 00:17:11,119
understood everything and now you can

494
00:17:09,039 --> 00:17:13,439
come back to this

495
00:17:11,119 --> 00:17:15,359
and say yes crypto dot get when executed

496
00:17:13,439 --> 00:17:15,760
with 100 200 and 300 it's going to bring

497
00:17:15,359 --> 00:17:19,359
us

498
00:17:15,760 --> 00:17:21,919
xyz value that's right now

499
00:17:19,359 --> 00:17:22,879
not possible static analysis just died

500
00:17:21,919 --> 00:17:25,120
immediately

501
00:17:22,880 --> 00:17:26,720
this is if you're an operating system

502
00:17:25,119 --> 00:17:27,520
developer or your work with compiler

503
00:17:26,720 --> 00:17:30,080
optimizations

504
00:17:27,520 --> 00:17:31,600
this is a nightmare i'm pretty sure this

505
00:17:30,080 --> 00:17:33,039
code is not optimized at all

506
00:17:31,600 --> 00:17:35,120
but does it do the job that we are

507
00:17:33,039 --> 00:17:37,360
trying to make it do which is

508
00:17:35,120 --> 00:17:38,559
functionally equivalent but harder to

509
00:17:37,360 --> 00:17:41,918
analyze yes

510
00:17:38,559 --> 00:17:44,000
it does and these

511
00:17:41,919 --> 00:17:46,880
this there are other skaters out in the

512
00:17:44,000 --> 00:17:50,240
world that actually do this

513
00:17:46,880 --> 00:17:52,080
java layer obfuscation so now my next

514
00:17:50,240 --> 00:17:54,240
step as an analyst i really still want

515
00:17:52,080 --> 00:17:55,678
to understand what's happening in here

516
00:17:54,240 --> 00:17:57,760
i really still want to understand what

517
00:17:55,679 --> 00:17:59,679
are the values that are being sent

518
00:17:57,760 --> 00:18:02,879
and again management attack is not an

519
00:17:59,679 --> 00:18:05,200
option here so let's move forward

520
00:18:02,880 --> 00:18:07,200
um so the next thing i would look at is

521
00:18:05,200 --> 00:18:08,880
something like dynamic analysis

522
00:18:07,200 --> 00:18:10,640
and there is a really cool tool called

523
00:18:08,880 --> 00:18:13,840
frida which i believe

524
00:18:10,640 --> 00:18:17,360
uh mr guatem the previous speaker for

525
00:18:13,840 --> 00:18:19,199
virtual life containers did speak about

526
00:18:17,360 --> 00:18:21,360
it's a very good tool it's a very useful

527
00:18:19,200 --> 00:18:24,320
tool i highly recommend it

528
00:18:21,360 --> 00:18:25,039
and with this tool you can do things

529
00:18:24,320 --> 00:18:29,840
like

530
00:18:25,039 --> 00:18:33,200
basically write a javascript

531
00:18:29,840 --> 00:18:35,360
script and you would be able to

532
00:18:33,200 --> 00:18:37,280
hook into a function and understand what

533
00:18:35,360 --> 00:18:37,760
are the arguments and what's the return

534
00:18:37,280 --> 00:18:40,320
value

535
00:18:37,760 --> 00:18:40,879
and this is a super simple presentation

536
00:18:40,320 --> 00:18:42,799
for

537
00:18:40,880 --> 00:18:44,320
for this this is i think the simplest

538
00:18:42,799 --> 00:18:44,879
one the simplest script that you could

539
00:18:44,320 --> 00:18:48,240
write

540
00:18:44,880 --> 00:18:50,400
you basically in here try to hook into

541
00:18:48,240 --> 00:18:51,840
um a class and then hook into the

542
00:18:50,400 --> 00:18:54,880
function for that class

543
00:18:51,840 --> 00:18:58,559
and you have this entire function

544
00:18:54,880 --> 00:18:59,200
callback as a implementation that will

545
00:18:58,559 --> 00:19:01,200
occur

546
00:18:59,200 --> 00:19:02,799
before the actual execution of the class

547
00:19:01,200 --> 00:19:04,559
actually no um

548
00:19:02,799 --> 00:19:06,240
i need to correct myself because i use

549
00:19:04,559 --> 00:19:09,440
dot implementation this will happen

550
00:19:06,240 --> 00:19:11,120
in lieu of the actual

551
00:19:09,440 --> 00:19:12,720
get so crypto bucket right now is not

552
00:19:11,120 --> 00:19:13,678
going to get executed this will get

553
00:19:12,720 --> 00:19:15,360
executed

554
00:19:13,679 --> 00:19:18,640
what am i telling it to do i'm telling

555
00:19:15,360 --> 00:19:21,520
it to just print called crypter.get

556
00:19:18,640 --> 00:19:22,960
and then i wanted to run the actual

557
00:19:21,520 --> 00:19:24,639
implementation

558
00:19:22,960 --> 00:19:26,480
and print the arguments in the return

559
00:19:24,640 --> 00:19:28,880
value this is pretty cool

560
00:19:26,480 --> 00:19:31,760
it's pretty simple to do and the result

561
00:19:28,880 --> 00:19:31,760
that i see is this

562
00:19:33,200 --> 00:19:40,559
so i just tried to understand

563
00:19:37,200 --> 00:19:43,919
what three

564
00:19:40,559 --> 00:19:47,280
instances of crypto.get do

565
00:19:43,919 --> 00:19:49,280
and i try to run a semi debugger to

566
00:19:47,280 --> 00:19:52,879
basically tell me what it's doing

567
00:19:49,280 --> 00:19:56,000
and i was welcomed with this

568
00:19:52,880 --> 00:19:57,120
this is seven more times than what i

569
00:19:56,000 --> 00:19:59,039
wanted

570
00:19:57,120 --> 00:20:00,879
as an analyst i just increased the

571
00:19:59,039 --> 00:20:02,879
number of man hours i need to spend to

572
00:20:00,880 --> 00:20:04,480
understand what's happening in here

573
00:20:02,880 --> 00:20:06,159
this is not so good because now i have

574
00:20:04,480 --> 00:20:09,120
to investigate other locations

575
00:20:06,159 --> 00:20:09,600
and that's not that's not giving me the

576
00:20:09,120 --> 00:20:12,158
the

577
00:20:09,600 --> 00:20:13,600
uh the result that i want i want just to

578
00:20:12,159 --> 00:20:16,320
focus on those

579
00:20:13,600 --> 00:20:17,760
three instances of crypto.get and i just

580
00:20:16,320 --> 00:20:18,720
want to understand what that post

581
00:20:17,760 --> 00:20:19,919
request is doing

582
00:20:18,720 --> 00:20:21,919
i really don't want to look at seven

583
00:20:19,919 --> 00:20:23,360
other instances and i assure you it's

584
00:20:21,919 --> 00:20:24,480
not going to be seven other instances

585
00:20:23,360 --> 00:20:26,719
it's going to be like a

586
00:20:24,480 --> 00:20:28,559
thousand other instances if you use an

587
00:20:26,720 --> 00:20:30,799
automatic obfuscator

588
00:20:28,559 --> 00:20:33,280
to obfuscate your code it's not going to

589
00:20:30,799 --> 00:20:34,720
be obfuscating 10 percent of it or 20

590
00:20:33,280 --> 00:20:36,799
of it it's going to be obfuscating most

591
00:20:34,720 --> 00:20:39,039
probably 90 of it so you're going to see

592
00:20:36,799 --> 00:20:41,760
a lot of this

593
00:20:39,039 --> 00:20:42,080
so the next step that you could work

594
00:20:41,760 --> 00:20:44,080
with

595
00:20:42,080 --> 00:20:45,840
is that right now you have distinct

596
00:20:44,080 --> 00:20:48,559
numbers right so i have a 100 being

597
00:20:45,840 --> 00:20:52,399
called in here and a 200 and then a 300

598
00:20:48,559 --> 00:20:54,879
and it's different than 2 3 1 2 3 2 1 2

599
00:20:52,400 --> 00:20:55,840
11 and 300. it's different right so we

600
00:20:54,880 --> 00:20:58,960
have a

601
00:20:55,840 --> 00:21:00,399
shared last argument but the others are

602
00:20:58,960 --> 00:21:01,360
different and i'm assuming that it's

603
00:21:00,400 --> 00:21:03,120
going to be

604
00:21:01,360 --> 00:21:05,678
different arguments are going to give me

605
00:21:03,120 --> 00:21:07,360
different return values

606
00:21:05,679 --> 00:21:08,799
so since they have distinct numbers

607
00:21:07,360 --> 00:21:11,280
maybe we can somehow

608
00:21:08,799 --> 00:21:12,400
trace the call stack print the function

609
00:21:11,280 --> 00:21:14,799
arguments and

610
00:21:12,400 --> 00:21:16,000
we'll be like okay if we find 100 200

611
00:21:14,799 --> 00:21:20,158
300 then it belongs

612
00:21:16,000 --> 00:21:21,840
to key number aaa key with aaa

613
00:21:20,159 --> 00:21:23,360
and if we found it with something like

614
00:21:21,840 --> 00:21:24,559
this it should belong to bbb and we

615
00:21:23,360 --> 00:21:25,120
don't care about these seven other

616
00:21:24,559 --> 00:21:27,039
instances

617
00:21:25,120 --> 00:21:28,399
that's one way to move forward and to do

618
00:21:27,039 --> 00:21:29,200
that we actually have to print the call

619
00:21:28,400 --> 00:21:31,919
stack

620
00:21:29,200 --> 00:21:33,919
luckily for us the printing the call

621
00:21:31,919 --> 00:21:37,200
stack is pretty simple

622
00:21:33,919 --> 00:21:39,679
it's something that any exception and

623
00:21:37,200 --> 00:21:40,880
java would do and translate 100 to

624
00:21:39,679 --> 00:21:43,200
android

625
00:21:40,880 --> 00:21:45,120
so i have this handwritten function

626
00:21:43,200 --> 00:21:47,520
which i

627
00:21:45,120 --> 00:21:48,879
cropped in here for sake of readability

628
00:21:47,520 --> 00:21:51,280
called get caller info

629
00:21:48,880 --> 00:21:52,000
it's very simple if you just google how

630
00:21:51,280 --> 00:21:54,000
to

631
00:21:52,000 --> 00:21:55,840
write an exception in java you could

632
00:21:54,000 --> 00:21:57,840
easily translate it in here

633
00:21:55,840 --> 00:21:59,199
and i'm basically trying to print the

634
00:21:57,840 --> 00:22:00,720
call stack i'm trying to understand

635
00:21:59,200 --> 00:22:02,240
where is it coming from

636
00:22:00,720 --> 00:22:03,760
and maybe if i know where is it coming

637
00:22:02,240 --> 00:22:05,600
from i know

638
00:22:03,760 --> 00:22:08,080
which function should i focus on and

639
00:22:05,600 --> 00:22:11,199
which function i should just ignore

640
00:22:08,080 --> 00:22:14,158
and i executed it and then i found that

641
00:22:11,200 --> 00:22:15,760
the execution is like this all of them

642
00:22:14,159 --> 00:22:17,360
are coming from crypto dot get

643
00:22:15,760 --> 00:22:19,120
that's obvious because i'm hooking into

644
00:22:17,360 --> 00:22:21,439
crypto dot get

645
00:22:19,120 --> 00:22:22,158
all of them are being called with line

646
00:22:21,440 --> 00:22:25,600
number

647
00:22:22,159 --> 00:22:30,000
one one one

648
00:22:25,600 --> 00:22:32,399
one so that's a problem

649
00:22:30,000 --> 00:22:33,760
and that's the the disassembled smallie

650
00:22:32,400 --> 00:22:37,280
smalley is a

651
00:22:33,760 --> 00:22:39,440
this is a dalvik um as adult

652
00:22:37,280 --> 00:22:41,440
is a dalvik bytecode representation

653
00:22:39,440 --> 00:22:43,280
language that you can use for

654
00:22:41,440 --> 00:22:44,480
disassembly it's very useful if you want

655
00:22:43,280 --> 00:22:46,720
to do any sort of

656
00:22:44,480 --> 00:22:48,559
android reverse engineering and if i

657
00:22:46,720 --> 00:22:52,240
look at the code i see that there are

658
00:22:48,559 --> 00:22:56,399
dot line directives they call them

659
00:22:52,240 --> 00:22:59,280
and they are all the same

660
00:22:56,400 --> 00:23:00,799
and this is allowed unfortunately in the

661
00:22:59,280 --> 00:23:04,320
android ecosystem

662
00:23:00,799 --> 00:23:07,120
you can have duplicate uh

663
00:23:04,320 --> 00:23:08,000
debug directives and the idea in here is

664
00:23:07,120 --> 00:23:10,000
that

665
00:23:08,000 --> 00:23:11,280
uh there's only one limitation which i

666
00:23:10,000 --> 00:23:13,600
just highlighted in here

667
00:23:11,280 --> 00:23:15,440
that the line register represents source

668
00:23:13,600 --> 00:23:16,639
line should be associated with the next

669
00:23:15,440 --> 00:23:19,280
position table

670
00:23:16,640 --> 00:23:21,120
it should always be a positive number

671
00:23:19,280 --> 00:23:23,520
that means that zero is not allowed

672
00:23:21,120 --> 00:23:24,479
but anything anything less than 1 is not

673
00:23:23,520 --> 00:23:26,320
allowed

674
00:23:24,480 --> 00:23:28,799
but apart from that you can have

675
00:23:26,320 --> 00:23:30,720
duplicate numbers that's possible

676
00:23:28,799 --> 00:23:32,960
i will show you right now a demo how

677
00:23:30,720 --> 00:23:35,919
this is very much possible

678
00:23:32,960 --> 00:23:36,559
so we've reached an interesting point we

679
00:23:35,919 --> 00:23:38,480
have

680
00:23:36,559 --> 00:23:39,600
10 instances of crypto.get that we

681
00:23:38,480 --> 00:23:42,320
really don't care about

682
00:23:39,600 --> 00:23:45,678
and we only have one that we care about

683
00:23:42,320 --> 00:23:48,559
three that we care about actually

684
00:23:45,679 --> 00:23:50,159
how do we move forward from here one

685
00:23:48,559 --> 00:23:52,240
option that we can do is something

686
00:23:50,159 --> 00:23:53,760
called realigning the apk this is not a

687
00:23:52,240 --> 00:23:55,120
common technique i actually didn't find

688
00:23:53,760 --> 00:23:57,120
any tools for it

689
00:23:55,120 --> 00:24:00,080
um and the idea in here is that you can

690
00:23:57,120 --> 00:24:02,559
basically try to

691
00:24:00,080 --> 00:24:04,320
realign all the numbers that are there

692
00:24:02,559 --> 00:24:06,000
so that they are sequential instead of

693
00:24:04,320 --> 00:24:07,039
being duplicates like one one one one

694
00:24:06,000 --> 00:24:09,200
one

695
00:24:07,039 --> 00:24:10,320
um i don't think i have too much time

696
00:24:09,200 --> 00:24:12,480
for this so i have a

697
00:24:10,320 --> 00:24:13,918
i was supposed to show two demos i will

698
00:24:12,480 --> 00:24:15,520
only show one

699
00:24:13,919 --> 00:24:17,360
and if we have time i will get back to

700
00:24:15,520 --> 00:24:18,000
the realigning demo but right now let's

701
00:24:17,360 --> 00:24:20,559
just move forward

702
00:24:18,000 --> 00:24:21,279
with the presentation and later if the q

703
00:24:20,559 --> 00:24:24,960
a was

704
00:24:21,279 --> 00:24:28,799
short i can try to execute this demo

705
00:24:24,960 --> 00:24:32,240
so let's go back to the next steps

706
00:24:28,799 --> 00:24:34,400
we try to understand which

707
00:24:32,240 --> 00:24:36,000
uh descriptor does get business we

708
00:24:34,400 --> 00:24:37,840
hooked into it and we saw it's being

709
00:24:36,000 --> 00:24:39,360
executed multiple times

710
00:24:37,840 --> 00:24:41,279
we tried to get some sort of a call

711
00:24:39,360 --> 00:24:42,639
stack to see okay it's being called from

712
00:24:41,279 --> 00:24:44,400
this function so we can just analyze

713
00:24:42,640 --> 00:24:46,320
this function and this line

714
00:24:44,400 --> 00:24:47,760
and that failed because they were all

715
00:24:46,320 --> 00:24:48,960
executing in the same function in the

716
00:24:47,760 --> 00:24:51,200
same line

717
00:24:48,960 --> 00:24:53,120
so the next step would be that as i said

718
00:24:51,200 --> 00:24:54,720
somehow realigning the code base

719
00:24:53,120 --> 00:24:57,039
however what i would like to see as an

720
00:24:54,720 --> 00:24:58,720
analyst is that i would like to

721
00:24:57,039 --> 00:25:01,360
basically execute the code

722
00:24:58,720 --> 00:25:04,400
just execute it once run the code base

723
00:25:01,360 --> 00:25:06,479
and then have it being annotated

724
00:25:04,400 --> 00:25:08,240
basically by annotating i mean some sort

725
00:25:06,480 --> 00:25:11,039
of a comment some sort of a

726
00:25:08,240 --> 00:25:12,480
comment of the execution flow there are

727
00:25:11,039 --> 00:25:15,679
a few tools that do this

728
00:25:12,480 --> 00:25:16,240
there was a tool called finrez long time

729
00:25:15,679 --> 00:25:20,480
ago

730
00:25:16,240 --> 00:25:22,480
it was using ptrace to actually do that

731
00:25:20,480 --> 00:25:23,679
the tool has been discontinued i found

732
00:25:22,480 --> 00:25:26,080
it in

733
00:25:23,679 --> 00:25:28,000
archive.org there is no trace of it on

734
00:25:26,080 --> 00:25:30,320
github or anything like that

735
00:25:28,000 --> 00:25:31,520
there is a tool that does this it's

736
00:25:30,320 --> 00:25:35,120
called it's a

737
00:25:31,520 --> 00:25:37,600
layer on top of gdb called gif gef

738
00:25:35,120 --> 00:25:39,678
and it has a function called trace dash

739
00:25:37,600 --> 00:25:41,678
run and it will do something like that

740
00:25:39,679 --> 00:25:42,960
however both those tools are native i

741
00:25:41,679 --> 00:25:45,600
want something that could run

742
00:25:42,960 --> 00:25:47,679
on java on a virtualized on the java

743
00:25:45,600 --> 00:25:49,360
virtual machine

744
00:25:47,679 --> 00:25:51,039
and give me something like this

745
00:25:49,360 --> 00:25:52,959
basically have a

746
00:25:51,039 --> 00:25:54,799
get which is the name of the function

747
00:25:52,960 --> 00:25:55,039
i'm calling with the arguments that i'm

748
00:25:54,799 --> 00:25:57,600
be

749
00:25:55,039 --> 00:25:58,559
that i'm calling and gives me the return

750
00:25:57,600 --> 00:26:00,959
value

751
00:25:58,559 --> 00:26:02,240
perfectly clean and perfectly readable i

752
00:26:00,960 --> 00:26:04,320
don't care about

753
00:26:02,240 --> 00:26:06,159
recompiling the code base that's not my

754
00:26:04,320 --> 00:26:07,200
intention my intention is to basically

755
00:26:06,159 --> 00:26:09,279
just annotate

756
00:26:07,200 --> 00:26:12,080
these execution flows and try to

757
00:26:09,279 --> 00:26:14,480
understand them for myself as an analyst

758
00:26:12,080 --> 00:26:15,199
write them in my report for example for

759
00:26:14,480 --> 00:26:17,840
a specific

760
00:26:15,200 --> 00:26:19,360
run so if i execute different buttons in

761
00:26:17,840 --> 00:26:20,240
the program it should give me different

762
00:26:19,360 --> 00:26:21,678
results so

763
00:26:20,240 --> 00:26:23,200
that should be a different code base

764
00:26:21,679 --> 00:26:24,640
that's the situation i would like to see

765
00:26:23,200 --> 00:26:27,679
as an analyst

766
00:26:24,640 --> 00:26:29,760
and now we have the demo i think i don't

767
00:26:27,679 --> 00:26:33,200
have too much time but i'm

768
00:26:29,760 --> 00:26:36,640
hoping i can try to

769
00:26:33,200 --> 00:26:36,640
show you guys how this works

770
00:26:37,360 --> 00:26:42,000
i really hope everybody can see my

771
00:26:39,039 --> 00:26:45,120
screen and i3 didn't die on me

772
00:26:42,000 --> 00:26:45,840
uh right so i'm just gonna run the test

773
00:26:45,120 --> 00:26:47,678
suite for

774
00:26:45,840 --> 00:26:50,639
uh the project that i'm working on which

775
00:26:47,679 --> 00:26:50,640
is the cryptocon

776
00:26:50,880 --> 00:26:59,039
and it failed miserably all right

777
00:26:55,520 --> 00:27:01,279
android home equals

778
00:26:59,039 --> 00:27:01,279
uh

779
00:27:02,320 --> 00:27:05,439
where did i save it this time that

780
00:27:04,880 --> 00:27:07,279
failed

781
00:27:05,440 --> 00:27:10,480
um let me see if i can show you the

782
00:27:07,279 --> 00:27:13,679
result of what this is going to happen

783
00:27:10,480 --> 00:27:15,840
yeah the demo i have android home i

784
00:27:13,679 --> 00:27:17,840
forgot where i actually installed it

785
00:27:15,840 --> 00:27:19,439
and this is a new computer so if i start

786
00:27:17,840 --> 00:27:21,120
right now fighting with it i assure you

787
00:27:19,440 --> 00:27:22,559
it's going to be 20 minutes

788
00:27:21,120 --> 00:27:24,158
with you guys looking at me and it's not

789
00:27:22,559 --> 00:27:26,320
going to work so i'm just going to show

790
00:27:24,159 --> 00:27:28,080
you the result of what it's going to do

791
00:27:26,320 --> 00:27:29,520
so the result is you would execute it

792
00:27:28,080 --> 00:27:30,320
with something like and there is a

793
00:27:29,520 --> 00:27:32,879
readme

794
00:27:30,320 --> 00:27:33,600
in the project the uh that i'm working

795
00:27:32,880 --> 00:27:35,120
on

796
00:27:33,600 --> 00:27:37,199
that will actually show you the

797
00:27:35,120 --> 00:27:39,279
execution environment so you would have

798
00:27:37,200 --> 00:27:43,360
to run something like this

799
00:27:39,279 --> 00:27:45,120
basically you would run an emulator

800
00:27:43,360 --> 00:27:47,199
you would run a script called install

801
00:27:45,120 --> 00:27:48,799
freda server both of those are included

802
00:27:47,200 --> 00:27:51,120
in the project so all you have to do is

803
00:27:48,799 --> 00:27:52,799
basically just copy paste this line

804
00:27:51,120 --> 00:27:54,000
and this and run it and it should be

805
00:27:52,799 --> 00:27:55,520
okay and it should install all the

806
00:27:54,000 --> 00:27:56,960
dependencies for you

807
00:27:55,520 --> 00:27:58,799
and then you would run something like

808
00:27:56,960 --> 00:28:01,520
this

809
00:27:58,799 --> 00:28:02,639
in here you would specify the apk that

810
00:28:01,520 --> 00:28:05,039
you're working on

811
00:28:02,640 --> 00:28:06,559
you will specify a hooks file and this

812
00:28:05,039 --> 00:28:08,000
hooks file should look something like

813
00:28:06,559 --> 00:28:10,080
this

814
00:28:08,000 --> 00:28:11,520
let me zoom in a little bit on it so

815
00:28:10,080 --> 00:28:15,199
this is basically

816
00:28:11,520 --> 00:28:17,760
the radare 2 representation

817
00:28:15,200 --> 00:28:19,600
of how that function should look like so

818
00:28:17,760 --> 00:28:22,720
if you have a function called crypter

819
00:28:19,600 --> 00:28:24,959
get it should look like this um

820
00:28:22,720 --> 00:28:26,000
jni uses the same thing actually radari

821
00:28:24,960 --> 00:28:27,760
copied it from jni

822
00:28:26,000 --> 00:28:30,559
and you can get this thing from

823
00:28:27,760 --> 00:28:32,480
practically any decompilation tool

824
00:28:30,559 --> 00:28:34,960
jadex apk tool anything like that it

825
00:28:32,480 --> 00:28:36,960
will give you this function signature

826
00:28:34,960 --> 00:28:38,399
and you can put as many functions as you

827
00:28:36,960 --> 00:28:39,520
want in here the things that you're

828
00:28:38,399 --> 00:28:41,520
interested in the things that you would

829
00:28:39,520 --> 00:28:42,639
like it to be annotated in our example

830
00:28:41,520 --> 00:28:44,559
we only cared about

831
00:28:42,640 --> 00:28:45,760
crypter.get we didn't have second and

832
00:28:44,559 --> 00:28:47,200
third

833
00:28:45,760 --> 00:28:49,200
and then you would run it with something

834
00:28:47,200 --> 00:28:51,120
that looks like this

835
00:28:49,200 --> 00:28:52,880
uh let me jump to the result right now

836
00:28:51,120 --> 00:28:56,158
the result of this thing would look

837
00:28:52,880 --> 00:28:56,159
a little bit like

838
00:28:56,880 --> 00:29:02,519
uh

839
00:28:59,220 --> 00:29:02,519
[Music]

840
00:29:03,360 --> 00:29:07,039
i really hope this works right now it

841
00:29:06,080 --> 00:29:10,240
does not

842
00:29:07,039 --> 00:29:12,559
because i didn't run it it's a new

843
00:29:10,240 --> 00:29:13,840
computer and i didn't run it so this

844
00:29:12,559 --> 00:29:14,960
bumped right now

845
00:29:13,840 --> 00:29:17,279
uh so that's what i'm telling you the

846
00:29:14,960 --> 00:29:18,480
demo gods didn't like me today

847
00:29:17,279 --> 00:29:20,399
so what i'm going to show you is that

848
00:29:18,480 --> 00:29:22,320
it's going to look something like this

849
00:29:20,399 --> 00:29:23,439
ideally i have on my website which i'm

850
00:29:22,320 --> 00:29:25,520
going to have a link to

851
00:29:23,440 --> 00:29:26,880
a video of this thing it's already live

852
00:29:25,520 --> 00:29:27,120
you can go and check it out and there is

853
00:29:26,880 --> 00:29:30,559
a

854
00:29:27,120 --> 00:29:31,600
pdf of a fat presentation that includes

855
00:29:30,559 --> 00:29:33,760
a lot more

856
00:29:31,600 --> 00:29:34,719
um context of what i'm talking about so

857
00:29:33,760 --> 00:29:37,520
it's basically

858
00:29:34,720 --> 00:29:39,279
you can consider it kind of an appendix

859
00:29:37,520 --> 00:29:41,918
to this talk

860
00:29:39,279 --> 00:29:43,679
and this is how it should look like it

861
00:29:41,919 --> 00:29:45,279
should basically be annotating it with

862
00:29:43,679 --> 00:29:48,080
this prefix and it will

863
00:29:45,279 --> 00:29:49,039
give you um the function argument in

864
00:29:48,080 --> 00:29:52,240
here

865
00:29:49,039 --> 00:29:54,158
with the return value and that's how

866
00:29:52,240 --> 00:29:58,159
that's the entire purpose of this tool

867
00:29:54,159 --> 00:30:00,320
um it started out basically as a

868
00:29:58,159 --> 00:30:02,480
tool that i wanted to do for my own job

869
00:30:00,320 --> 00:30:04,639
to tackle layered java obfuscation

870
00:30:02,480 --> 00:30:05,520
so if you have something that is doing

871
00:30:04,640 --> 00:30:07,279
um

872
00:30:05,520 --> 00:30:08,639
some sort of a string obfuscation like

873
00:30:07,279 --> 00:30:10,559
what we're seeing in here with

874
00:30:08,640 --> 00:30:12,320
crypter.get or something like that

875
00:30:10,559 --> 00:30:13,678
there are commercial obfuscators that do

876
00:30:12,320 --> 00:30:16,960
that

877
00:30:13,679 --> 00:30:19,840
um and it will tackle something like

878
00:30:16,960 --> 00:30:22,000
realigning all the codebase this is what

879
00:30:19,840 --> 00:30:23,840
the tool was supposed to handle

880
00:30:22,000 --> 00:30:25,520
i'm very happy i used it in at least

881
00:30:23,840 --> 00:30:26,480
five malwares right now and it works

882
00:30:25,520 --> 00:30:28,158
just fine

883
00:30:26,480 --> 00:30:30,159
and the idea behind it is that it will

884
00:30:28,159 --> 00:30:31,440
automatically do all of this for me so

885
00:30:30,159 --> 00:30:33,840
that i don't have to worry about it i

886
00:30:31,440 --> 00:30:37,120
will just go into static analysis i will

887
00:30:33,840 --> 00:30:39,199
stop at this location

888
00:30:37,120 --> 00:30:40,399
right here the initial slide that we had

889
00:30:39,200 --> 00:30:41,919
i will see this

890
00:30:40,399 --> 00:30:43,840
and then i wouldn't have to worry i will

891
00:30:41,919 --> 00:30:46,640
just basically run it against

892
00:30:43,840 --> 00:30:48,840
the signature of crypto.get and it would

893
00:30:46,640 --> 00:30:50,960
work

894
00:30:48,840 --> 00:30:52,240
automatically i don't have to worry

895
00:30:50,960 --> 00:30:54,080
about myself

896
00:30:52,240 --> 00:30:56,080
diverting attention to seven other

897
00:30:54,080 --> 00:30:57,600
instances or having to worry about how

898
00:30:56,080 --> 00:30:58,559
to set up freeda or i haven't worry

899
00:30:57,600 --> 00:31:01,600
about the

900
00:30:58,559 --> 00:31:03,279
emulator that i'm working with and x86

901
00:31:01,600 --> 00:31:05,360
does it have an x86 or does it have an

902
00:31:03,279 --> 00:31:07,120
arm architecture

903
00:31:05,360 --> 00:31:09,039
i just want to worry about this this

904
00:31:07,120 --> 00:31:11,678
exact point and that's it

905
00:31:09,039 --> 00:31:13,760
and this is what the tool is trying to

906
00:31:11,679 --> 00:31:16,080
do it basically parses an apk and

907
00:31:13,760 --> 00:31:17,600
realigns it entirely it has a built-in

908
00:31:16,080 --> 00:31:20,960
smallie parser

909
00:31:17,600 --> 00:31:21,840
and it's trying to actually handle it so

910
00:31:20,960 --> 00:31:24,080
that

911
00:31:21,840 --> 00:31:26,080
i can show you this if you're seeing

912
00:31:24,080 --> 00:31:29,360
here

913
00:31:26,080 --> 00:31:31,760
dot line one so

914
00:31:29,360 --> 00:31:32,799
as you can see in here this is a

915
00:31:31,760 --> 00:31:35,840
disassembled

916
00:31:32,799 --> 00:31:37,440
apk that has multiple line ones actually

917
00:31:35,840 --> 00:31:38,720
all the lines are number one

918
00:31:37,440 --> 00:31:40,000
there is an issue that you're gonna get

919
00:31:38,720 --> 00:31:41,440
if you're trying to just use it with

920
00:31:40,000 --> 00:31:44,159
like a bash script that runs

921
00:31:41,440 --> 00:31:45,039
sid and you just try to sequentially put

922
00:31:44,159 --> 00:31:47,600
all the lines

923
00:31:45,039 --> 00:31:48,559
is that you can have multiple and this

924
00:31:47,600 --> 00:31:50,399
is very legal

925
00:31:48,559 --> 00:31:52,799
you can have multiple invoke virtual in

926
00:31:50,399 --> 00:31:54,000
here that's not a problem if i recompile

927
00:31:52,799 --> 00:31:57,200
the code base right now

928
00:31:54,000 --> 00:31:58,880
this will work just fine i hope so

929
00:31:57,200 --> 00:32:01,760
this is a problem because if i'm trying

930
00:31:58,880 --> 00:32:03,760
to hunt down for the specific crypto.get

931
00:32:01,760 --> 00:32:07,279
instance that is in between

932
00:32:03,760 --> 00:32:09,919
line two and line for example

933
00:32:07,279 --> 00:32:11,519
um three remember it should be

934
00:32:09,919 --> 00:32:15,039
sequential

935
00:32:11,519 --> 00:32:18,399
i will get 10 instances of

936
00:32:15,039 --> 00:32:19,919
well not 10. i will get six instances of

937
00:32:18,399 --> 00:32:21,918
the function that i'm trying to hook

938
00:32:19,919 --> 00:32:22,720
into which is a problem because i only

939
00:32:21,919 --> 00:32:25,679
want

940
00:32:22,720 --> 00:32:26,399
one line to correspond with one instance

941
00:32:25,679 --> 00:32:28,320
it will make

942
00:32:26,399 --> 00:32:29,760
a lot easier sense for me to understand

943
00:32:28,320 --> 00:32:31,918
it like that

944
00:32:29,760 --> 00:32:33,039
so the tool actually goes through every

945
00:32:31,919 --> 00:32:35,039
single line

946
00:32:33,039 --> 00:32:36,480
and try to see if it's illegal or not

947
00:32:35,039 --> 00:32:38,799
for example you can't put lines in the

948
00:32:36,480 --> 00:32:40,640
middle of an annotation block

949
00:32:38,799 --> 00:32:42,480
and it will try to have a threshold of

950
00:32:40,640 --> 00:32:43,919
usually two lines you can of course

951
00:32:42,480 --> 00:32:46,080
customize it to have it

952
00:32:43,919 --> 00:32:47,120
in between each line it will have

953
00:32:46,080 --> 00:32:50,320
something

954
00:32:47,120 --> 00:32:52,158
that's the idea of the tool it using

955
00:32:50,320 --> 00:32:53,760
something like sid

956
00:32:52,159 --> 00:32:56,000
or just a simple python script that

957
00:32:53,760 --> 00:32:58,720
tries to sequentially change everything

958
00:32:56,000 --> 00:32:59,760
didn't work for me because the malware

959
00:32:58,720 --> 00:33:03,200
that i was looking at

960
00:32:59,760 --> 00:33:05,120
it even used reflection to

961
00:33:03,200 --> 00:33:06,480
and string of fuscation with reflection

962
00:33:05,120 --> 00:33:09,360
to try to call methods

963
00:33:06,480 --> 00:33:10,960
so literally every single function call

964
00:33:09,360 --> 00:33:14,479
in there was reflected

965
00:33:10,960 --> 00:33:16,960
in a specific hotspot of the program

966
00:33:14,480 --> 00:33:18,720
and every time you try to do anything

967
00:33:16,960 --> 00:33:20,080
there is always a call to kryptor.com

968
00:33:18,720 --> 00:33:22,799
there is always a call to

969
00:33:20,080 --> 00:33:24,240
a reflection afterwards and it's always

970
00:33:22,799 --> 00:33:25,918
realigned and there was

971
00:33:24,240 --> 00:33:27,600
you they were using opaque predicates

972
00:33:25,919 --> 00:33:30,080
that means that the

973
00:33:27,600 --> 00:33:31,279
there were junk code you remember that

974
00:33:30,080 --> 00:33:33,039
that code

975
00:33:31,279 --> 00:33:35,120
injection technique they were using it

976
00:33:33,039 --> 00:33:35,919
so it's even bloating the code base even

977
00:33:35,120 --> 00:33:38,639
further

978
00:33:35,919 --> 00:33:40,480
looking at it gave me a headache so the

979
00:33:38,640 --> 00:33:42,080
tool that i wanted to use oh by the way

980
00:33:40,480 --> 00:33:44,080
realign is an actual word

981
00:33:42,080 --> 00:33:45,360
i didn't invent it i almost started

982
00:33:44,080 --> 00:33:47,360
using it in the company and nobody

983
00:33:45,360 --> 00:33:50,240
believed that it was a word

984
00:33:47,360 --> 00:33:51,918
thank you merriam-webster so the idea

985
00:33:50,240 --> 00:33:53,440
behind it is that i needed something

986
00:33:51,919 --> 00:33:54,880
that is simple to use and could be

987
00:33:53,440 --> 00:33:58,000
reproducible

988
00:33:54,880 --> 00:33:59,919
by anybody later

989
00:33:58,000 --> 00:34:01,760
and this is the tool that i came up with

990
00:33:59,919 --> 00:34:04,240
the idea that i would love to have

991
00:34:01,760 --> 00:34:05,600
behind it is to include more

992
00:34:04,240 --> 00:34:08,560
simplification techniques

993
00:34:05,600 --> 00:34:10,159
and this is where you guys come in uh

994
00:34:08,560 --> 00:34:11,279
the idea is that i would love to get

995
00:34:10,159 --> 00:34:14,000
some more emails

996
00:34:11,280 --> 00:34:15,200
issues open on the github repo that

997
00:34:14,000 --> 00:34:17,440
tells me

998
00:34:15,199 --> 00:34:18,638
what other data affiliation techniques

999
00:34:17,440 --> 00:34:21,200
that you try to use

1000
00:34:18,639 --> 00:34:22,879
could something like this work with it

1001
00:34:21,199 --> 00:34:24,560
there is a lot of

1002
00:34:22,879 --> 00:34:26,639
automatic the other skaters that are out

1003
00:34:24,560 --> 00:34:27,599
there i will i have a slide after this

1004
00:34:26,639 --> 00:34:29,440
to show it

1005
00:34:27,599 --> 00:34:31,359
however the ones that i want that i used

1006
00:34:29,440 --> 00:34:32,639
didn't fulfill this purpose for me i

1007
00:34:31,359 --> 00:34:33,440
needed something that could be used by

1008
00:34:32,639 --> 00:34:36,320
an analyst

1009
00:34:33,440 --> 00:34:37,918
for specific cases in this case layered

1010
00:34:36,320 --> 00:34:39,200
java application

1011
00:34:37,918 --> 00:34:41,440
would be really cool to use some sort of

1012
00:34:39,199 --> 00:34:43,118
a symbolic execution engine like anger

1013
00:34:41,440 --> 00:34:45,760
or measure

1014
00:34:43,119 --> 00:34:47,119
using something like that you could even

1015
00:34:45,760 --> 00:34:50,240
try to

1016
00:34:47,119 --> 00:34:51,040
simplify kryptor.get so if you actually

1017
00:34:50,239 --> 00:34:54,638
would like to

1018
00:34:51,040 --> 00:34:56,560
understand the algorithm for crypto.get

1019
00:34:54,639 --> 00:34:59,599
which looks like

1020
00:34:56,560 --> 00:35:00,078
egyptian hero glyphs ideally you should

1021
00:34:59,599 --> 00:35:01,680
do

1022
00:35:00,079 --> 00:35:03,280
you should use a symbolic execution

1023
00:35:01,680 --> 00:35:04,960
engine that could give you instructions

1024
00:35:03,280 --> 00:35:06,960
that are easier to use

1025
00:35:04,960 --> 00:35:08,240
if you want to replicate this thing if

1026
00:35:06,960 --> 00:35:09,520
what you if what you care about is

1027
00:35:08,240 --> 00:35:11,919
scripter.get

1028
00:35:09,520 --> 00:35:13,599
not for example our example make post

1029
00:35:11,920 --> 00:35:17,119
request

1030
00:35:13,599 --> 00:35:18,480
that would be something cool to see and

1031
00:35:17,119 --> 00:35:20,560
i did mention about sharing your

1032
00:35:18,480 --> 00:35:23,119
experiences with me um

1033
00:35:20,560 --> 00:35:23,759
and that's pretty much it uh sorry guys

1034
00:35:23,119 --> 00:35:26,480
for the

1035
00:35:23,760 --> 00:35:27,200
demo that actually sucked but uh yeah i

1036
00:35:26,480 --> 00:35:28,960
mean

1037
00:35:27,200 --> 00:35:30,560
spelling coffee on the laptop kind of

1038
00:35:28,960 --> 00:35:32,560
ruins the motherboard so

1039
00:35:30,560 --> 00:35:34,078
i'm happy my colleague let me lend his

1040
00:35:32,560 --> 00:35:37,680
uh his thinkpad for

1041
00:35:34,079 --> 00:35:39,839
for this talk um this is

1042
00:35:37,680 --> 00:35:40,960
i think the last slide it's similar work

1043
00:35:39,839 --> 00:35:43,040
to the things that i

1044
00:35:40,960 --> 00:35:44,640
that i just mentioned in here both of

1045
00:35:43,040 --> 00:35:46,800
those repos simplifying

1046
00:35:44,640 --> 00:35:48,319
dex oracle were made by an amazing

1047
00:35:46,800 --> 00:35:51,520
person called caleb fenton

1048
00:35:48,320 --> 00:35:55,280
very very smart guy uh the krypticon

1049
00:35:51,520 --> 00:35:57,359
the tool that i was supposed to show you

1050
00:35:55,280 --> 00:35:59,200
is taking a lot of influence from dex

1051
00:35:57,359 --> 00:36:00,880
oracle and the idea behind it is that

1052
00:35:59,200 --> 00:36:04,480
dick's oracle does some static

1053
00:36:00,880 --> 00:36:07,200
android obfuscation rather than

1054
00:36:04,480 --> 00:36:08,960
running it running it once running the

1055
00:36:07,200 --> 00:36:10,799
entire execution flow and then trying to

1056
00:36:08,960 --> 00:36:12,880
understand

1057
00:36:10,800 --> 00:36:14,800
the arguments and the return values

1058
00:36:12,880 --> 00:36:15,440
there are some cases where for example

1059
00:36:14,800 --> 00:36:18,400
if you have a

1060
00:36:15,440 --> 00:36:19,119
bloated code base with multiple positive

1061
00:36:18,400 --> 00:36:22,800
and negative

1062
00:36:19,119 --> 00:36:24,240
uh um opaque predicates basically that

1063
00:36:22,800 --> 00:36:26,560
code all over the place

1064
00:36:24,240 --> 00:36:27,439
dex oracle wouldn't work there is

1065
00:36:26,560 --> 00:36:30,720
another tool

1066
00:36:27,440 --> 00:36:33,520
made by um

1067
00:36:30,720 --> 00:36:35,439
i can't remember the name it's a very

1068
00:36:33,520 --> 00:36:37,359
famous tool it's called text hunter

1069
00:36:35,440 --> 00:36:38,800
and it does automatic android unpacking

1070
00:36:37,359 --> 00:36:40,960
using some really

1071
00:36:38,800 --> 00:36:42,960
simplified generics for example if you

1072
00:36:40,960 --> 00:36:44,880
have something like m protect

1073
00:36:42,960 --> 00:36:46,880
it will try to map an executable

1074
00:36:44,880 --> 00:36:50,079
writable readable range of memory

1075
00:36:46,880 --> 00:36:51,599
and then it will try to unpack the code

1076
00:36:50,079 --> 00:36:53,440
there if you're working with a

1077
00:36:51,599 --> 00:36:55,280
sophisticated packer it should do

1078
00:36:53,440 --> 00:36:57,440
something a little bit more complicated

1079
00:36:55,280 --> 00:36:58,400
dexhaunter works a lot i use this a lot

1080
00:36:57,440 --> 00:37:01,680
in the wild

1081
00:36:58,400 --> 00:37:03,359
so the semantics behind the work that i

1082
00:37:01,680 --> 00:37:06,399
tried to do i tried to adapt the same

1083
00:37:03,359 --> 00:37:08,720
flow that those three projects had

1084
00:37:06,400 --> 00:37:10,560
they don't replace uh the project that i

1085
00:37:08,720 --> 00:37:12,078
made doesn't replace those i believe

1086
00:37:10,560 --> 00:37:14,799
that it could be used

1087
00:37:12,079 --> 00:37:15,920
as a there was a scene in the matrix

1088
00:37:14,800 --> 00:37:18,960
really cool

1089
00:37:15,920 --> 00:37:22,079
where morpheus uh trinity

1090
00:37:18,960 --> 00:37:24,640
and neo went to uh the matrix and then

1091
00:37:22,079 --> 00:37:25,680
there was just rows and rows of guns all

1092
00:37:24,640 --> 00:37:28,879
over them

1093
00:37:25,680 --> 00:37:30,240
and what when trinity asked neo it's

1094
00:37:28,880 --> 00:37:31,440
like oh what do you want and he said

1095
00:37:30,240 --> 00:37:33,118
guns lots of guns

1096
00:37:31,440 --> 00:37:35,200
this is exactly the same case you have

1097
00:37:33,119 --> 00:37:35,599
multiple guns you're you're an analyst

1098
00:37:35,200 --> 00:37:37,598
okay

1099
00:37:35,599 --> 00:37:39,040
you need more than one tool to do the

1100
00:37:37,599 --> 00:37:40,640
same job

1101
00:37:39,040 --> 00:37:42,079
because when one tool breaks the other

1102
00:37:40,640 --> 00:37:43,598
hopefully wouldn't

1103
00:37:42,079 --> 00:37:45,839
this is what i try to think about these

1104
00:37:43,599 --> 00:37:48,160
projects and it would be nice to see

1105
00:37:45,839 --> 00:37:50,799
more projects like this actually

1106
00:37:48,160 --> 00:37:51,680
and that's pretty much it guys thank you

1107
00:37:50,800 --> 00:37:54,079
so much

1108
00:37:51,680 --> 00:37:55,040
um this is the repo that i was telling

1109
00:37:54,079 --> 00:37:56,480
you about

1110
00:37:55,040 --> 00:37:58,240
let me know if there is any issues with

1111
00:37:56,480 --> 00:38:00,720
it i'm trying to be active with

1112
00:37:58,240 --> 00:38:02,240
open source communities this is my

1113
00:38:00,720 --> 00:38:04,078
twitter you can reach me out with any

1114
00:38:02,240 --> 00:38:06,160
issues that you have

1115
00:38:04,079 --> 00:38:07,200
and as i mentioned the slides for this

1116
00:38:06,160 --> 00:38:09,520
presentation

1117
00:38:07,200 --> 00:38:11,118
and hopefully a video of the execution

1118
00:38:09,520 --> 00:38:14,400
will be on the website

1119
00:38:11,119 --> 00:38:17,200
uh my website malwarecheese.com and

1120
00:38:14,400 --> 00:38:19,119
we are hiring on adjust so if you would

1121
00:38:17,200 --> 00:38:21,919
like to work with some

1122
00:38:19,119 --> 00:38:22,560
interesting adware fraud prevention

1123
00:38:21,920 --> 00:38:25,119
techniques

1124
00:38:22,560 --> 00:38:25,920
try you're good with c you're good with

1125
00:38:25,119 --> 00:38:28,079
binaries

1126
00:38:25,920 --> 00:38:29,359
please reach out here's the channels

1127
00:38:28,079 --> 00:38:31,680
that you can find me at

1128
00:38:29,359 --> 00:38:33,200
many many many many many thanks thank

1129
00:38:31,680 --> 00:38:34,399
you android security symposium for

1130
00:38:33,200 --> 00:38:38,240
allowing me to

1131
00:38:34,400 --> 00:38:42,640
to present and now i think the q a

1132
00:38:38,240 --> 00:38:44,879
is up okay thank you very much abdullah

1133
00:38:42,640 --> 00:38:46,560
uh now that my audio setup seems to work

1134
00:38:44,880 --> 00:38:49,440
as intended again we're ready to

1135
00:38:46,560 --> 00:38:51,279
continue with the q and a session

1136
00:38:49,440 --> 00:38:53,040
once again you can raise your hand in

1137
00:38:51,280 --> 00:38:55,520
assume in order to ask your question

1138
00:38:53,040 --> 00:38:58,560
using audio or simply type it into the

1139
00:38:55,520 --> 00:39:03,520
program day 1 q and 8 channel

1140
00:38:58,560 --> 00:39:03,520
in metamost so

1141
00:39:05,359 --> 00:39:08,720
until people are going to start typing i

1142
00:39:07,839 --> 00:39:11,599
would like to

1143
00:39:08,720 --> 00:39:12,399
ask a rather general question so as an

1144
00:39:11,599 --> 00:39:14,960
analyst

1145
00:39:12,400 --> 00:39:16,240
what do you think is the most i'd say

1146
00:39:14,960 --> 00:39:19,119
nerve wrecking

1147
00:39:16,240 --> 00:39:20,640
technique regarding obfuscation is it

1148
00:39:19,119 --> 00:39:23,520
that code injection

1149
00:39:20,640 --> 00:39:25,598
no it's not the most annoying tool that

1150
00:39:23,520 --> 00:39:28,320
you can find and

1151
00:39:25,599 --> 00:39:30,079
i can safely say that if you find that

1152
00:39:28,320 --> 00:39:32,160
you're going to spend a very very very

1153
00:39:30,079 --> 00:39:32,480
long time analyzing a very simple block

1154
00:39:32,160 --> 00:39:35,598
is

1155
00:39:32,480 --> 00:39:38,480
a virtualization and

1156
00:39:35,599 --> 00:39:40,079
something like mixed boolean algebra

1157
00:39:38,480 --> 00:39:42,160
which is a technique that

1158
00:39:40,079 --> 00:39:43,760
there is a really cool talk from ruer

1159
00:39:42,160 --> 00:39:47,359
universitat bochum

1160
00:39:43,760 --> 00:39:48,960
and triple c um by a person called tim

1161
00:39:47,359 --> 00:39:51,200
blastico i really hope i'm not

1162
00:39:48,960 --> 00:39:52,800
missing the name the name of the talk is

1163
00:39:51,200 --> 00:39:54,000
called modern binary obfuscation it's

1164
00:39:52,800 --> 00:39:55,119
very easy to find this from chaos

1165
00:39:54,000 --> 00:39:57,520
computer club

1166
00:39:55,119 --> 00:39:59,119
and uh he mentioned really cool

1167
00:39:57,520 --> 00:39:59,759
techniques regarding mixed boolean

1168
00:39:59,119 --> 00:40:02,800
algebra

1169
00:39:59,760 --> 00:40:04,960
that breaks symbolic execution engines

1170
00:40:02,800 --> 00:40:06,640
so your last case scenario after static

1171
00:40:04,960 --> 00:40:08,319
failed and dynamic failed you want to

1172
00:40:06,640 --> 00:40:09,759
analyze the simple block

1173
00:40:08,319 --> 00:40:11,839
and you would have to go for something

1174
00:40:09,760 --> 00:40:13,440
automatic like symbolic execution

1175
00:40:11,839 --> 00:40:15,040
these techniques are meant to even break

1176
00:40:13,440 --> 00:40:17,520
that so

1177
00:40:15,040 --> 00:40:19,359
i would say virtualization and something

1178
00:40:17,520 --> 00:40:22,800
related to

1179
00:40:19,359 --> 00:40:24,480
compiler de-optimization is the most

1180
00:40:22,800 --> 00:40:25,440
annoying two things that you can find

1181
00:40:24,480 --> 00:40:27,280
and

1182
00:40:25,440 --> 00:40:28,640
weirdly enough it is actually easy for a

1183
00:40:27,280 --> 00:40:30,960
defender to create those

1184
00:40:28,640 --> 00:40:32,000
if you know if you know good enough

1185
00:40:30,960 --> 00:40:35,119
development

1186
00:40:32,000 --> 00:40:38,960
you can so those two things

1187
00:40:35,119 --> 00:40:41,280
okay um another question

1188
00:40:38,960 --> 00:40:42,960
so from your practical experience uh

1189
00:40:41,280 --> 00:40:44,960
regarding that code injection

1190
00:40:42,960 --> 00:40:46,000
once again how much would an

1191
00:40:44,960 --> 00:40:48,640
applications

1192
00:40:46,000 --> 00:40:49,920
machine code or bytecode for that matter

1193
00:40:48,640 --> 00:40:52,160
grow in size

1194
00:40:49,920 --> 00:40:53,280
typically so from a practical point of

1195
00:40:52,160 --> 00:40:55,440
view regarding

1196
00:40:53,280 --> 00:40:57,839
obfuscation tools which are readily

1197
00:40:55,440 --> 00:41:00,720
available out there

1198
00:40:57,839 --> 00:41:02,560
are there any experience values to this

1199
00:41:00,720 --> 00:41:06,000
how would it grow in size so

1200
00:41:02,560 --> 00:41:08,400
um can you see my screen

1201
00:41:06,000 --> 00:41:10,400
yes we can see your screen perfect let's

1202
00:41:08,400 --> 00:41:13,119
look at something like crypter.get

1203
00:41:10,400 --> 00:41:14,960
for example crypto.get what it does at

1204
00:41:13,119 --> 00:41:18,000
least what i understood it should do

1205
00:41:14,960 --> 00:41:20,240
is basically try to match

1206
00:41:18,000 --> 00:41:21,200
characters in here unicode characters

1207
00:41:20,240 --> 00:41:22,959
with each other

1208
00:41:21,200 --> 00:41:25,118
based on whatever it is that you're

1209
00:41:22,960 --> 00:41:28,240
passing so if you're passing it 100

1210
00:41:25,119 --> 00:41:29,200
it will loop uh with a modulus over a

1211
00:41:28,240 --> 00:41:30,799
specific number

1212
00:41:29,200 --> 00:41:32,640
i extracted the number once i think it

1213
00:41:30,800 --> 00:41:33,280
was 128 in here and it will just

1214
00:41:32,640 --> 00:41:35,759
basically

1215
00:41:33,280 --> 00:41:37,760
loop over it and keep extracting it so

1216
00:41:35,760 --> 00:41:38,960
this entire function could be simplified

1217
00:41:37,760 --> 00:41:41,520
by like

1218
00:41:38,960 --> 00:41:42,480
four lines of code with the exclusion of

1219
00:41:41,520 --> 00:41:44,160
the array

1220
00:41:42,480 --> 00:41:46,480
and you can see in here that it grew in

1221
00:41:44,160 --> 00:41:49,520
size quite a bit there's really no limit

1222
00:41:46,480 --> 00:41:50,240
to bitcoin code however i can say that

1223
00:41:49,520 --> 00:41:52,480
most of the

1224
00:41:50,240 --> 00:41:53,839
malware i encountered had a very

1225
00:41:52,480 --> 00:41:55,920
specific section

1226
00:41:53,839 --> 00:41:58,319
that they highlighted with all the

1227
00:41:55,920 --> 00:42:01,040
techniques they threw everything there

1228
00:41:58,319 --> 00:42:02,720
um there is a really cool paper about

1229
00:42:01,040 --> 00:42:05,200
affo skater llvm

1230
00:42:02,720 --> 00:42:06,399
the original ollvm paper and they

1231
00:42:05,200 --> 00:42:08,720
measured

1232
00:42:06,400 --> 00:42:10,319
they had a pass in there a compiler pass

1233
00:42:08,720 --> 00:42:11,839
called bogus control flow and they

1234
00:42:10,319 --> 00:42:12,319
basically do something very similar to

1235
00:42:11,839 --> 00:42:16,000
this

1236
00:42:12,319 --> 00:42:18,480
they measured the increase in

1237
00:42:16,000 --> 00:42:19,040
speed sorry the decrease in speed and it

1238
00:42:18,480 --> 00:42:22,000
was

1239
00:42:19,040 --> 00:42:24,200
with all three passes that they had was

1240
00:42:22,000 --> 00:42:26,960
uh

1241
00:42:24,200 --> 00:42:31,040
1.25 x

1242
00:42:26,960 --> 00:42:33,680
more than the original execution so it's

1243
00:42:31,040 --> 00:42:35,680
it's heavy but if you try to control it

1244
00:42:33,680 --> 00:42:37,200
you can really try to reach a very nice

1245
00:42:35,680 --> 00:42:38,160
sweet spot between functionally

1246
00:42:37,200 --> 00:42:41,200
equivalent

1247
00:42:38,160 --> 00:42:42,720
and still secure enough to

1248
00:42:41,200 --> 00:42:46,078
not have an analyst break into your

1249
00:42:42,720 --> 00:42:48,879
stock trading proprietary algorithm

1250
00:42:46,079 --> 00:42:49,839
it's the original paper from olvm that

1251
00:42:48,880 --> 00:42:53,040
they had those

1252
00:42:49,839 --> 00:42:56,160
speed tests so you can check it out i

1253
00:42:53,040 --> 00:42:58,640
actually i can share my screen

1254
00:42:56,160 --> 00:43:00,640
it's for those who you who don't know if

1255
00:42:58,640 --> 00:43:01,359
you just google llvm you're gonna see in

1256
00:43:00,640 --> 00:43:05,200
here

1257
00:43:01,359 --> 00:43:07,440
apple skater llvm and

1258
00:43:05,200 --> 00:43:08,319
i think you can find it here right here

1259
00:43:07,440 --> 00:43:09,760
this is the paper

1260
00:43:08,319 --> 00:43:12,160
i think it should be on spring or

1261
00:43:09,760 --> 00:43:12,720
something like that you can easily read

1262
00:43:12,160 --> 00:43:15,359
it

1263
00:43:12,720 --> 00:43:16,319
as a pdf and you will see it it's not

1264
00:43:15,359 --> 00:43:19,200
too old

1265
00:43:16,319 --> 00:43:19,200
as well so

1266
00:43:20,000 --> 00:43:25,119
okay thank you very much for that we do

1267
00:43:23,119 --> 00:43:28,640
have another question from

1268
00:43:25,119 --> 00:43:32,000
marcus forte he asks

1269
00:43:28,640 --> 00:43:32,319
how common are anti-analysis methods

1270
00:43:32,000 --> 00:43:36,000
like

1271
00:43:32,319 --> 00:43:36,720
detecting frida exposed or debuggers in

1272
00:43:36,000 --> 00:43:39,440
the wild

1273
00:43:36,720 --> 00:43:39,839
so codes that behaves differently in

1274
00:43:39,440 --> 00:43:42,720
these

1275
00:43:39,839 --> 00:43:44,160
environments or when they are detected

1276
00:43:42,720 --> 00:43:45,279
i'm sorry i didn't understand the

1277
00:43:44,160 --> 00:43:48,000
question exactly can

1278
00:43:45,280 --> 00:43:48,760
can you repeat it yeah sure how common

1279
00:43:48,000 --> 00:43:51,839
are

1280
00:43:48,760 --> 00:43:54,960
anti-analysis methods like

1281
00:43:51,839 --> 00:43:55,839
programs trying to detect tools like

1282
00:43:54,960 --> 00:43:59,119
frida or

1283
00:43:55,839 --> 00:44:01,440
exposed or debuggers okay so that the

1284
00:43:59,119 --> 00:44:03,599
code behaves differently

1285
00:44:01,440 --> 00:44:04,800
inside these environments or when they

1286
00:44:03,599 --> 00:44:08,480
are detected

1287
00:44:04,800 --> 00:44:09,200
so they are common they're very common

1288
00:44:08,480 --> 00:44:10,880
actually like

1289
00:44:09,200 --> 00:44:13,279
uh one of the most common things you can

1290
00:44:10,880 --> 00:44:14,960
do to deter a debugger is something

1291
00:44:13,280 --> 00:44:17,599
called the p-trace attach

1292
00:44:14,960 --> 00:44:18,160
uh trace me trick which is basically you

1293
00:44:17,599 --> 00:44:20,560
have the

1294
00:44:18,160 --> 00:44:22,078
binary trace itself which means that no

1295
00:44:20,560 --> 00:44:24,240
other debugger could hook into it

1296
00:44:22,079 --> 00:44:25,760
that's the most common one uh you find

1297
00:44:24,240 --> 00:44:29,279
it a lot but honestly

1298
00:44:25,760 --> 00:44:30,800
uh my old mentor told me if you're

1299
00:44:29,280 --> 00:44:32,560
running with a debugger or something

1300
00:44:30,800 --> 00:44:33,760
like a debugger like friday or exposed

1301
00:44:32,560 --> 00:44:35,520
you're in god mode

1302
00:44:33,760 --> 00:44:36,880
there is nothing you really there is

1303
00:44:35,520 --> 00:44:39,359
nothing that you that

1304
00:44:36,880 --> 00:44:41,119
you can run away from because if you

1305
00:44:39,359 --> 00:44:42,799
have a p-trace

1306
00:44:41,119 --> 00:44:44,480
method that tries to hook itself all you

1307
00:44:42,800 --> 00:44:47,520
have to do in a debugger is just

1308
00:44:44,480 --> 00:44:49,520
break into p-trace and then

1309
00:44:47,520 --> 00:44:50,880
knob it and that's it you're done and

1310
00:44:49,520 --> 00:44:52,560
you can even move it to

1311
00:44:50,880 --> 00:44:54,960
your disk and you can have your friends

1312
00:44:52,560 --> 00:44:57,920
executed and it's just a dead

1313
00:44:54,960 --> 00:44:59,599
uh technique so it is very common you

1314
00:44:57,920 --> 00:45:00,160
see it a lot especially the features

1315
00:44:59,599 --> 00:45:03,680
attach

1316
00:45:00,160 --> 00:45:06,000
trace me i even think mstg os at msdg

1317
00:45:03,680 --> 00:45:09,040
has that technique if i'm not mistaken

1318
00:45:06,000 --> 00:45:10,240
i i think they do so it's very common to

1319
00:45:09,040 --> 00:45:14,640
see it it's even in

1320
00:45:10,240 --> 00:45:17,439
ossip but breaking it is

1321
00:45:14,640 --> 00:45:18,000
for for a talented analyst should be

1322
00:45:17,440 --> 00:45:19,280
nuts

1323
00:45:18,000 --> 00:45:22,480
it shouldn't take too much man hours

1324
00:45:19,280 --> 00:45:26,720
from them as i believe

1325
00:45:22,480 --> 00:45:29,359
okay thank you any other questions

1326
00:45:26,720 --> 00:45:29,359
let me see

1327
00:45:30,800 --> 00:45:35,599
okay so uh i would have one more

1328
00:45:33,920 --> 00:45:38,079
question until the next uh

1329
00:45:35,599 --> 00:45:39,680
then the next talk starts so from my

1330
00:45:38,079 --> 00:45:43,359
very sparse experience

1331
00:45:39,680 --> 00:45:46,399
in in reverse engineering um doing that

1332
00:45:43,359 --> 00:45:50,160
using smiley code is considerably more

1333
00:45:46,400 --> 00:45:53,280
doable than x86 i would say x86 assembly

1334
00:45:50,160 --> 00:45:55,520
and maybe for that reason i don't know

1335
00:45:53,280 --> 00:45:56,400
it seems that obfuscation is more

1336
00:45:55,520 --> 00:45:59,440
widespread

1337
00:45:56,400 --> 00:46:01,599
in the android world would you agree to

1338
00:45:59,440 --> 00:46:06,560
that from your practical experience

1339
00:46:01,599 --> 00:46:06,560
i do agree x86 is not fixed size

1340
00:46:07,280 --> 00:46:11,760
instructions arm is fixed size so it's a

1341
00:46:09,839 --> 00:46:13,759
lot easier to

1342
00:46:11,760 --> 00:46:16,000
edit a binary if you want to say uh

1343
00:46:13,760 --> 00:46:18,240
basically try to inject things in the

1344
00:46:16,000 --> 00:46:20,880
middle but with x86 it's not fixed size

1345
00:46:18,240 --> 00:46:22,879
so if you try to inject something you're

1346
00:46:20,880 --> 00:46:24,240
gonna have a horrible time working with

1347
00:46:22,880 --> 00:46:25,680
relative offsets

1348
00:46:24,240 --> 00:46:27,279
for the jumps you basically broke

1349
00:46:25,680 --> 00:46:28,560
everything so

1350
00:46:27,280 --> 00:46:30,240
if you just i am not saying i'm not

1351
00:46:28,560 --> 00:46:30,640
joking if you just insert one single

1352
00:46:30,240 --> 00:46:32,078
knob

1353
00:46:30,640 --> 00:46:35,598
you just broke all the jumps and the

1354
00:46:32,079 --> 00:46:38,960
references and llvm and gcc

1355
00:46:35,599 --> 00:46:40,160
try their best to optimize things so

1356
00:46:38,960 --> 00:46:42,000
you're going to have a very hard time

1357
00:46:40,160 --> 00:46:45,040
with doing it with x86 the best thing

1358
00:46:42,000 --> 00:46:47,119
i would suggest is if you target native

1359
00:46:45,040 --> 00:46:48,720
is to do it from the compiler side so

1360
00:46:47,119 --> 00:46:50,400
you can take something like tiny

1361
00:46:48,720 --> 00:46:53,040
underscore cc

1362
00:46:50,400 --> 00:46:54,240
a very small c compiler and you can hack

1363
00:46:53,040 --> 00:46:57,359
it that's possible

1364
00:46:54,240 --> 00:46:58,959
mob for skater uh it's an

1365
00:46:57,359 --> 00:47:01,279
awful skater that turns all instructions

1366
00:46:58,960 --> 00:47:04,400
to mav it's amazing it's just

1367
00:47:01,280 --> 00:47:06,240
beautiful it's it attacked tiny cc the

1368
00:47:04,400 --> 00:47:06,880
person who did it hack tiny cc to do it

1369
00:47:06,240 --> 00:47:08,879
which is

1370
00:47:06,880 --> 00:47:10,480
just the most genius thing in the world

1371
00:47:08,880 --> 00:47:13,440
with java you

1372
00:47:10,480 --> 00:47:14,640
still have jumps but it's uh sorry

1373
00:47:13,440 --> 00:47:15,920
without but you still have jumps but

1374
00:47:14,640 --> 00:47:18,960
it's a lot easier

1375
00:47:15,920 --> 00:47:22,480
and i can imagine that you can do binary

1376
00:47:18,960 --> 00:47:24,000
editing a lot easier in there than

1377
00:47:22,480 --> 00:47:25,839
than in something like a compiler

1378
00:47:24,000 --> 00:47:27,760
optimization but then again you have

1379
00:47:25,839 --> 00:47:29,759
more people who understand x86

1380
00:47:27,760 --> 00:47:32,559
historically speaking than you do

1381
00:47:29,760 --> 00:47:34,319
people who understand velvek so there is

1382
00:47:32,559 --> 00:47:37,520
a tradeoff i guess

1383
00:47:34,319 --> 00:47:39,040
okay so uh one final question we are

1384
00:47:37,520 --> 00:47:42,960
already a little bit over time

1385
00:47:39,040 --> 00:47:45,440
uh eduardo asks do you consider that

1386
00:47:42,960 --> 00:47:46,160
virtual machine obfuscation can be

1387
00:47:45,440 --> 00:47:49,359
attacked

1388
00:47:46,160 --> 00:47:50,078
in android in the same way as you would

1389
00:47:49,359 --> 00:47:53,359
do

1390
00:47:50,079 --> 00:47:54,160
on windows yes you can uh the one of the

1391
00:47:53,359 --> 00:47:57,279
most famous

1392
00:47:54,160 --> 00:48:00,000
uh vm pro protection um

1393
00:47:57,280 --> 00:48:00,960
commercial vm protection um uh tools

1394
00:48:00,000 --> 00:48:03,920
that you can use is

1395
00:48:00,960 --> 00:48:05,040
uh two the meda and vm protect both of

1396
00:48:03,920 --> 00:48:07,440
them are windows

1397
00:48:05,040 --> 00:48:08,800
some people try to port it into android

1398
00:48:07,440 --> 00:48:10,000
you basically should use the same

1399
00:48:08,800 --> 00:48:12,720
heuristics the same

1400
00:48:10,000 --> 00:48:14,079
analysis methodology you try to

1401
00:48:12,720 --> 00:48:16,240
understand the handlers

1402
00:48:14,079 --> 00:48:17,359
try to understand where the fetch decode

1403
00:48:16,240 --> 00:48:20,000
execute loop

1404
00:48:17,359 --> 00:48:20,640
i would even say it's simpler on android

1405
00:48:20,000 --> 00:48:22,480
because

1406
00:48:20,640 --> 00:48:24,558
android ecosystem doesn't give you a lot

1407
00:48:22,480 --> 00:48:28,240
of

1408
00:48:24,559 --> 00:48:30,160
room to play with you can't run

1409
00:48:28,240 --> 00:48:31,359
it's very hard to run a different

1410
00:48:30,160 --> 00:48:33,839
process on

1411
00:48:31,359 --> 00:48:35,440
android if you're an app and you track

1412
00:48:33,839 --> 00:48:38,799
it around a different process

1413
00:48:35,440 --> 00:48:41,280
even if you look at the uh fork um

1414
00:48:38,800 --> 00:48:42,880
import from bionic slip c it's not

1415
00:48:41,280 --> 00:48:44,720
really forking it's cloning

1416
00:48:42,880 --> 00:48:46,480
it's cloning the thread into something

1417
00:48:44,720 --> 00:48:49,759
else uh forking is

1418
00:48:46,480 --> 00:48:51,599
not so easy to do and it's not very

1419
00:48:49,760 --> 00:48:53,599
it's it's not very it's not recommended

1420
00:48:51,599 --> 00:48:55,200
by the android developers

1421
00:48:53,599 --> 00:48:56,559
uh the people who create an android

1422
00:48:55,200 --> 00:48:59,200
operating system so i would say it's

1423
00:48:56,559 --> 00:49:01,200
even easier to do it because you don't

1424
00:48:59,200 --> 00:49:02,960
for example i doubt any virtual machine

1425
00:49:01,200 --> 00:49:04,160
obfuscation technique would try to do

1426
00:49:02,960 --> 00:49:06,640
something like a

1427
00:49:04,160 --> 00:49:07,839
just-in-time compiler an android they

1428
00:49:06,640 --> 00:49:09,839
would do something simpler like

1429
00:49:07,839 --> 00:49:12,960
interpretation or something like that so

1430
00:49:09,839 --> 00:49:14,960
it's a lot simpler i would even say okay

1431
00:49:12,960 --> 00:49:17,599
i hope that answered the question

1432
00:49:14,960 --> 00:49:18,480
i i guess so abdullah thank you very

1433
00:49:17,599 --> 00:49:26,640
much again

1434
00:49:18,480 --> 00:49:26,640
for your talk this was very interesting

