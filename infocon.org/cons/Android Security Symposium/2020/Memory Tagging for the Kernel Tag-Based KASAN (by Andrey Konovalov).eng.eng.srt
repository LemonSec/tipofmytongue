1
00:00:08,080 --> 00:00:11,280
um that's going to move us into the

2
00:00:09,519 --> 00:00:15,040
second talk of this session

3
00:00:11,280 --> 00:00:16,799
we have andre kovanov

4
00:00:15,040 --> 00:00:18,640
from google who's going to be diving

5
00:00:16,800 --> 00:00:20,640
down a bit further in the

6
00:00:18,640 --> 00:00:21,680
into stack into the into the kernel

7
00:00:20,640 --> 00:00:24,720
itself

8
00:00:21,680 --> 00:00:25,840
um and so um andre if you'd like to

9
00:00:24,720 --> 00:00:29,119
share your screen

10
00:00:25,840 --> 00:00:29,599
okay thank you so thank you for allowing

11
00:00:29,119 --> 00:00:32,159
me to

12
00:00:29,599 --> 00:00:34,079
allow me allowing me to present on

13
00:00:32,159 --> 00:00:36,078
android security symposium

14
00:00:34,079 --> 00:00:38,160
and welcome to my talk about memory

15
00:00:36,079 --> 00:00:41,600
tagging for the linux kernel

16
00:00:38,160 --> 00:00:44,480
so my name is andrei i am employed

17
00:00:41,600 --> 00:00:45,680
by google and i mostly work on different

18
00:00:44,480 --> 00:00:48,160
bug finding

19
00:00:45,680 --> 00:00:49,360
tools for the linux kernel since some

20
00:00:48,160 --> 00:00:52,959
time ago actually

21
00:00:49,360 --> 00:00:54,719
also started doing work that is related

22
00:00:52,960 --> 00:00:56,559
to security exploit mitigations

23
00:00:54,719 --> 00:00:58,640
and this is where memory tagging

24
00:00:56,559 --> 00:01:01,839
actually comes in

25
00:00:58,640 --> 00:01:03,199
and so the plan for today is first of

26
00:01:01,840 --> 00:01:04,720
all i'm going to introduce my team

27
00:01:03,199 --> 00:01:06,640
i'm going to tell you about different

28
00:01:04,720 --> 00:01:08,479
kinds of tools that we have for user

29
00:01:06,640 --> 00:01:10,400
space and for the kernel

30
00:01:08,479 --> 00:01:12,159
the next part is going to be about

31
00:01:10,400 --> 00:01:15,040
memory tagging itself i'm gonna explain

32
00:01:12,159 --> 00:01:16,880
the concept i'm gonna

33
00:01:15,040 --> 00:01:18,479
address i mean i'm gonna explain what

34
00:01:16,880 --> 00:01:19,520
what is the current state of memory

35
00:01:18,479 --> 00:01:22,560
tagging in

36
00:01:19,520 --> 00:01:24,840
linux and android user space and finally

37
00:01:22,560 --> 00:01:26,320
the last part is gonna be about the

38
00:01:24,840 --> 00:01:28,080
kernel

39
00:01:26,320 --> 00:01:29,758
so my team actually consists of two

40
00:01:28,080 --> 00:01:32,640
parts the first part

41
00:01:29,759 --> 00:01:34,720
works on user space and there we have

42
00:01:32,640 --> 00:01:35,119
some bug finding tools like sanitizers i

43
00:01:34,720 --> 00:01:37,920
think

44
00:01:35,119 --> 00:01:39,119
people who write cnc plus plus code have

45
00:01:37,920 --> 00:01:41,680
heard of them or have

46
00:01:39,119 --> 00:01:42,560
probably also used them we have some

47
00:01:41,680 --> 00:01:44,640
tools that

48
00:01:42,560 --> 00:01:46,399
assist you with fuzzing and one of the

49
00:01:44,640 --> 00:01:48,240
recent developments you also have

50
00:01:46,399 --> 00:01:50,560
what's called grip a sound which is a

51
00:01:48,240 --> 00:01:51,759
sampling based memory back detector and

52
00:01:50,560 --> 00:01:54,399
the idea is that

53
00:01:51,759 --> 00:01:55,040
you can actually use it in production to

54
00:01:54,399 --> 00:01:56,880
find

55
00:01:55,040 --> 00:01:59,759
memory box that happen in production

56
00:01:56,880 --> 00:02:02,158
code while it's running

57
00:01:59,759 --> 00:02:04,560
the user space part of the team also

58
00:02:02,159 --> 00:02:06,479
works on mitigations like cfi shadow

59
00:02:04,560 --> 00:02:09,520
call stack and some of the others and

60
00:02:06,479 --> 00:02:11,200
of course memory tagging today

61
00:02:09,520 --> 00:02:13,040
we're going to be mentioning i'm going

62
00:02:11,200 --> 00:02:14,958
to be expanding more on

63
00:02:13,040 --> 00:02:16,239
huasan which is hardware assisted

64
00:02:14,959 --> 00:02:18,879
address sanitizer and

65
00:02:16,239 --> 00:02:20,080
memory tagging itself of course so the

66
00:02:18,879 --> 00:02:22,879
second part of the team

67
00:02:20,080 --> 00:02:25,599
is where i've work and that that part of

68
00:02:22,879 --> 00:02:27,599
the team actually works on kernel tools

69
00:02:25,599 --> 00:02:29,519
for kernels for the kernel we also have

70
00:02:27,599 --> 00:02:30,879
a set of sanitizers that allow you to

71
00:02:29,520 --> 00:02:33,519
find different kinds of bugs

72
00:02:30,879 --> 00:02:35,760
i guess the oldest one is the address

73
00:02:33,519 --> 00:02:36,400
sanitizer that finds memory corruptions

74
00:02:35,760 --> 00:02:38,879
and

75
00:02:36,400 --> 00:02:39,680
the new was the newest one that was just

76
00:02:38,879 --> 00:02:41,359
merged

77
00:02:39,680 --> 00:02:42,959
into the mainline kernel a few months

78
00:02:41,360 --> 00:02:45,920
ago is kcsan

79
00:02:42,959 --> 00:02:47,760
which finds data races we have c scholar

80
00:02:45,920 --> 00:02:50,160
which is our coverage guided buzzer

81
00:02:47,760 --> 00:02:51,040
and right now we're also working on k

82
00:02:50,160 --> 00:02:53,280
fans

83
00:02:51,040 --> 00:02:54,799
which is something like grip ice and but

84
00:02:53,280 --> 00:02:56,239
for the kernel so it's a sampling based

85
00:02:54,800 --> 00:03:00,319
memory bug detector

86
00:02:56,239 --> 00:03:01,840
for production use for mitigations

87
00:03:00,319 --> 00:03:03,599
in the kernel first of all we've been

88
00:03:01,840 --> 00:03:05,440
working on mirror installation

89
00:03:03,599 --> 00:03:08,319
and with memory installation the idea is

90
00:03:05,440 --> 00:03:11,040
really simple we want to initialize

91
00:03:08,319 --> 00:03:13,359
heap and stack memory to avoid leaking

92
00:03:11,040 --> 00:03:16,799
information from the kernel

93
00:03:13,360 --> 00:03:18,319
and today i will mostly focus on a new

94
00:03:16,800 --> 00:03:20,480
cassand mod which

95
00:03:18,319 --> 00:03:22,399
a software implementation of the memory

96
00:03:20,480 --> 00:03:26,079
tagging concept for the kernel

97
00:03:22,400 --> 00:03:26,080
and it's called tag-based kasan

98
00:03:26,319 --> 00:03:29,599
so a typical point that's being made

99
00:03:28,400 --> 00:03:31,120
here is

100
00:03:29,599 --> 00:03:33,200
we do have a lot of software that's

101
00:03:31,120 --> 00:03:35,599
written in unsafe languages

102
00:03:33,200 --> 00:03:36,560
and those unsafe languages allow you to

103
00:03:35,599 --> 00:03:39,040
do a lot of

104
00:03:36,560 --> 00:03:40,640
weird things and as a result you do get

105
00:03:39,040 --> 00:03:42,798
a lot of bugs and a lot of

106
00:03:40,640 --> 00:03:44,559
memory corruptions as you know some of

107
00:03:42,799 --> 00:03:45,440
the memory corruptions are exploitable

108
00:03:44,560 --> 00:03:48,400
so

109
00:03:45,440 --> 00:03:50,000
instead of investing into fixing bugs it

110
00:03:48,400 --> 00:03:52,239
makes sense to also invest into

111
00:03:50,000 --> 00:03:53,920
mitigation that will actually prevent

112
00:03:52,239 --> 00:03:55,439
those memory corruptions from being

113
00:03:53,920 --> 00:03:57,760
exploited

114
00:03:55,439 --> 00:04:00,720
and one of the links that i have here is

115
00:03:57,760 --> 00:04:03,040
a link to our csbot dashboard

116
00:04:00,720 --> 00:04:04,159
and this bot is an automation on top of

117
00:04:03,040 --> 00:04:06,959
this caller

118
00:04:04,159 --> 00:04:08,159
that essentially fuzzes the linux kernel

119
00:04:06,959 --> 00:04:10,720
in the cloud

120
00:04:08,159 --> 00:04:11,280
and currently we have almost 700 open

121
00:04:10,720 --> 00:04:13,439
bucks

122
00:04:11,280 --> 00:04:17,279
in the mainline linux kernel and the

123
00:04:13,439 --> 00:04:21,279
situation is not getting better in time

124
00:04:17,279 --> 00:04:22,559
so memory tagging is one of the

125
00:04:21,279 --> 00:04:24,559
it can be used to the security

126
00:04:22,560 --> 00:04:26,800
mitigation and right now

127
00:04:24,560 --> 00:04:29,040
let me explain you the concept so the

128
00:04:26,800 --> 00:04:31,919
goal of memory tagging is to ensure that

129
00:04:29,040 --> 00:04:32,479
memory accesses are safe the way this is

130
00:04:31,919 --> 00:04:34,400
done

131
00:04:32,479 --> 00:04:36,800
is by splitting the memory into memory

132
00:04:34,400 --> 00:04:38,080
granules and each memory granule is

133
00:04:36,800 --> 00:04:41,360
associated with attack

134
00:04:38,080 --> 00:04:43,280
which is also sometimes called a color

135
00:04:41,360 --> 00:04:44,960
each pointer that points into memory

136
00:04:43,280 --> 00:04:47,679
also has an assigned tag

137
00:04:44,960 --> 00:04:48,880
and the idea is to make sure that on

138
00:04:47,680 --> 00:04:51,680
every memory access

139
00:04:48,880 --> 00:04:53,919
the attack on the pointer actually

140
00:04:51,680 --> 00:04:55,680
equals the attack on the memory

141
00:04:53,919 --> 00:04:57,599
if they are not equal then this raises

142
00:04:55,680 --> 00:04:59,360
an exception

143
00:04:57,600 --> 00:05:02,080
and of course depending on the

144
00:04:59,360 --> 00:05:04,479
implementation you can have different

145
00:05:02,080 --> 00:05:05,758
sizes for memory granules you can use

146
00:05:04,479 --> 00:05:07,440
different types of text

147
00:05:05,759 --> 00:05:10,400
you know usually attack is an integer

148
00:05:07,440 --> 00:05:13,440
and the integer you're using

149
00:05:10,400 --> 00:05:14,880
some bits to store it the way this is

150
00:05:13,440 --> 00:05:17,520
typically implemented

151
00:05:14,880 --> 00:05:19,680
is the allocator does the following

152
00:05:17,520 --> 00:05:20,719
allocation first of all it has to align

153
00:05:19,680 --> 00:05:23,440
the allocation

154
00:05:20,720 --> 00:05:24,639
up to the granule size because we cannot

155
00:05:23,440 --> 00:05:26,560
use

156
00:05:24,639 --> 00:05:28,479
like this is the smallest green light

157
00:05:26,560 --> 00:05:30,479
granularity that we have

158
00:05:28,479 --> 00:05:32,159
then the allocator chooses a random tag

159
00:05:30,479 --> 00:05:33,199
or uses some other rules to choose

160
00:05:32,160 --> 00:05:35,039
attack

161
00:05:33,199 --> 00:05:37,120
tags the allocated memory tags the

162
00:05:35,039 --> 00:05:39,039
pointer and returns the pointer

163
00:05:37,120 --> 00:05:40,960
and of course the pointer and the memory

164
00:05:39,039 --> 00:05:43,120
tacked with the same tag

165
00:05:40,960 --> 00:05:44,799
on the allocation we can re-tag the

166
00:05:43,120 --> 00:05:46,479
memory with a different attack

167
00:05:44,800 --> 00:05:47,919
and then on memory access what happens

168
00:05:46,479 --> 00:05:51,199
is we actually check that the pointer

169
00:05:47,919 --> 00:05:54,719
attack is the same at the memory tag

170
00:05:51,199 --> 00:05:55,039
so here's a small example let's say we

171
00:05:54,720 --> 00:05:58,720
are

172
00:05:55,039 --> 00:06:00,560
allocating k bytes and n is our granular

173
00:05:58,720 --> 00:06:02,800
granularity

174
00:06:00,560 --> 00:06:04,000
and let's just say that k is actually

175
00:06:02,800 --> 00:06:05,919
more than n

176
00:06:04,000 --> 00:06:08,000
which means that it's not enough to have

177
00:06:05,919 --> 00:06:10,000
one granule to hold k bytes but it's

178
00:06:08,000 --> 00:06:11,680
enough to have two

179
00:06:10,000 --> 00:06:13,199
so this is the how the memory is going

180
00:06:11,680 --> 00:06:15,759
to look like and here

181
00:06:13,199 --> 00:06:16,800
each cell actually represents a memory

182
00:06:15,759 --> 00:06:19,440
granule

183
00:06:16,800 --> 00:06:20,160
and our p pointer actually starts with

184
00:06:19,440 --> 00:06:23,199
address zero

185
00:06:20,160 --> 00:06:25,520
our object of k bytes so

186
00:06:23,199 --> 00:06:26,319
here we can see that the p pointer is

187
00:06:25,520 --> 00:06:29,520
stacked with

188
00:06:26,319 --> 00:06:31,280
the green tag or green color and the two

189
00:06:29,520 --> 00:06:33,758
memory granules that hold

190
00:06:31,280 --> 00:06:34,799
the object of k bytes are also tagged

191
00:06:33,759 --> 00:06:36,160
with green and this is what the

192
00:06:34,800 --> 00:06:38,319
allocator did

193
00:06:36,160 --> 00:06:41,199
the other objects that are on this

194
00:06:38,319 --> 00:06:43,280
picture are tagged with different colors

195
00:06:41,199 --> 00:06:44,720
so now let's say we're accessing byte

196
00:06:43,280 --> 00:06:47,198
number to n

197
00:06:44,720 --> 00:06:48,240
byte number to n actually lies in the

198
00:06:47,199 --> 00:06:51,680
next granule

199
00:06:48,240 --> 00:06:53,360
and it has the color purple but since

200
00:06:51,680 --> 00:06:54,400
we're using the pointer p which is

201
00:06:53,360 --> 00:06:56,319
stacked with green

202
00:06:54,400 --> 00:06:58,400
and the memory stacked is purple green

203
00:06:56,319 --> 00:07:01,440
does not equal purple and here we have

204
00:06:58,400 --> 00:07:04,000
an out of bounds similarly

205
00:07:01,440 --> 00:07:06,479
for a use of the free what happens is

206
00:07:04,000 --> 00:07:08,800
that after we free memory we retack

207
00:07:06,479 --> 00:07:10,800
the granules that belong to the object

208
00:07:08,800 --> 00:07:13,360
and here we use the red tag

209
00:07:10,800 --> 00:07:14,000
and when the access to the object

210
00:07:13,360 --> 00:07:15,599
happens

211
00:07:14,000 --> 00:07:17,680
we have the pointer that the stacked is

212
00:07:15,599 --> 00:07:18,400
green we have the memory that is stacked

213
00:07:17,680 --> 00:07:20,960
as

214
00:07:18,400 --> 00:07:21,919
red and since the attack do not are not

215
00:07:20,960 --> 00:07:25,359
the same

216
00:07:21,919 --> 00:07:29,120
we do detect a memory violation access

217
00:07:25,360 --> 00:07:31,039
memory access violation so

218
00:07:29,120 --> 00:07:33,120
if you actually look at this picture and

219
00:07:31,039 --> 00:07:37,440
think about it what's going to happen

220
00:07:33,120 --> 00:07:40,639
if our out of bound access actually

221
00:07:37,440 --> 00:07:43,680
still in the same granule as i mean

222
00:07:40,639 --> 00:07:46,800
still in the second granule but

223
00:07:43,680 --> 00:07:48,319
is accessing past the k bytes so

224
00:07:46,800 --> 00:07:50,240
in that sense that access is not going

225
00:07:48,319 --> 00:07:52,319
to be detected and our

226
00:07:50,240 --> 00:07:54,720
bug detection with memory attacking is

227
00:07:52,319 --> 00:07:58,000
actually actually probabilistic

228
00:07:54,720 --> 00:08:00,400
so here's an example let's say that our

229
00:07:58,000 --> 00:08:01,120
memory granule size is 16 and let's say

230
00:08:00,400 --> 00:08:04,080
we use

231
00:08:01,120 --> 00:08:04,400
four bits to store attack which means we

232
00:08:04,080 --> 00:08:07,599
have

233
00:08:04,400 --> 00:08:10,799
16 different tax attack values

234
00:08:07,599 --> 00:08:12,479
and let's allocate 35 bytes and when

235
00:08:10,800 --> 00:08:13,520
we're going to be accessing byte number

236
00:08:12,479 --> 00:08:15,599
40

237
00:08:13,520 --> 00:08:16,639
byte number 40 is going to be actually

238
00:08:15,599 --> 00:08:20,000
falling within the

239
00:08:16,639 --> 00:08:23,039
third granule so to hold 35

240
00:08:20,000 --> 00:08:25,680
bytes we need three granules of size 16

241
00:08:23,039 --> 00:08:26,318
and byte number 40 is within the third

242
00:08:25,680 --> 00:08:28,160
granule

243
00:08:26,319 --> 00:08:29,680
so in this case this axis will not be

244
00:08:28,160 --> 00:08:31,280
detected

245
00:08:29,680 --> 00:08:33,120
if you're going to be actually accessing

246
00:08:31,280 --> 00:08:36,319
the next granule the fourth granule

247
00:08:33,120 --> 00:08:38,640
with offset 64 the

248
00:08:36,320 --> 00:08:40,320
there is still a chance if the attacks

249
00:08:38,640 --> 00:08:42,479
are assigned randomly that the attack

250
00:08:40,320 --> 00:08:44,640
on the next granule will actually match

251
00:08:42,479 --> 00:08:45,920
the attack on our object

252
00:08:44,640 --> 00:08:47,680
and the chance of this is we're

253
00:08:45,920 --> 00:08:51,199
assigning if we're assigning

254
00:08:47,680 --> 00:08:53,680
text randomly is one out of 16.

255
00:08:51,200 --> 00:08:54,959
here we can actually make sure so it's

256
00:08:53,680 --> 00:08:55,920
up to the implementation but the

257
00:08:54,959 --> 00:08:59,040
implementation

258
00:08:55,920 --> 00:08:59,760
can make sure that objects that are next

259
00:08:59,040 --> 00:09:02,640
to each other

260
00:08:59,760 --> 00:09:03,360
in memory actually get different text in

261
00:09:02,640 --> 00:09:05,439
this case

262
00:09:03,360 --> 00:09:07,040
for linear buffer overflows we can

263
00:09:05,440 --> 00:09:09,519
actually make sure that

264
00:09:07,040 --> 00:09:10,560
memory tagging always detects them but

265
00:09:09,519 --> 00:09:13,120
if you're accessing

266
00:09:10,560 --> 00:09:13,920
a very very far out of bounds let's say

267
00:09:13,120 --> 00:09:17,279
you're accessing

268
00:09:13,920 --> 00:09:18,560
100 500 then there is no way for us to

269
00:09:17,279 --> 00:09:19,920
make sure that the attacks are different

270
00:09:18,560 --> 00:09:22,000
and there is still a chance that the

271
00:09:19,920 --> 00:09:25,120
attack is going to be the same

272
00:09:22,000 --> 00:09:26,880
and the same happens with use of the

273
00:09:25,120 --> 00:09:28,320
three so let's say we free the pointer

274
00:09:26,880 --> 00:09:31,600
but that someone else

275
00:09:28,320 --> 00:09:33,760
allocated object on this place and

276
00:09:31,600 --> 00:09:35,279
someone else retacked the point the

277
00:09:33,760 --> 00:09:37,839
memory with a random tag

278
00:09:35,279 --> 00:09:39,920
so in this case there is still one one

279
00:09:37,839 --> 00:09:44,000
out of 16 chance that the attack on the

280
00:09:39,920 --> 00:09:44,000
memory will be the same as we had before

281
00:09:44,560 --> 00:09:48,000
so now this was the description on

282
00:09:46,000 --> 00:09:49,920
concept and a particular

283
00:09:48,000 --> 00:09:51,600
implementation of memory tagging has to

284
00:09:49,920 --> 00:09:52,719
address the following questions

285
00:09:51,600 --> 00:09:54,800
first of all we have to choose a

286
00:09:52,720 --> 00:09:56,480
particular granule size we have to

287
00:09:54,800 --> 00:09:58,160
decide how many different tags we have

288
00:09:56,480 --> 00:09:59,040
and how many bits do we use to store

289
00:09:58,160 --> 00:10:01,040
attack

290
00:09:59,040 --> 00:10:03,040
we have to figure out how to assign and

291
00:10:01,040 --> 00:10:04,319
store pointer tags and how to assign and

292
00:10:03,040 --> 00:10:06,480
store memory tax

293
00:10:04,320 --> 00:10:09,040
and finally something has to perform the

294
00:10:06,480 --> 00:10:11,200
actual comparison of tax

295
00:10:09,040 --> 00:10:13,040
so one of those questions i'm going to

296
00:10:11,200 --> 00:10:14,399
actually answer right now how pointer

297
00:10:13,040 --> 00:10:15,839
attacks are stored because

298
00:10:14,399 --> 00:10:18,000
all of the implementations we'll be

299
00:10:15,839 --> 00:10:19,680
discussing today are going to be using

300
00:10:18,000 --> 00:10:22,079
the same approach

301
00:10:19,680 --> 00:10:23,279
and this approach lies on arm top byte

302
00:10:22,079 --> 00:10:25,680
ignore

303
00:10:23,279 --> 00:10:27,200
arm top byte ignore is an arm feature

304
00:10:25,680 --> 00:10:30,479
that allows you

305
00:10:27,200 --> 00:10:31,600
when enabled to ignore so the cpu

306
00:10:30,480 --> 00:10:34,800
actually ignores

307
00:10:31,600 --> 00:10:36,640
the top eight bits of any address it

308
00:10:34,800 --> 00:10:38,959
references

309
00:10:36,640 --> 00:10:41,439
and you can enable it with setting the

310
00:10:38,959 --> 00:10:42,959
tbi bits in the tcr register and there

311
00:10:41,440 --> 00:10:45,040
is separate bit for the user space there

312
00:10:42,959 --> 00:10:49,119
is separate bit for the kernel

313
00:10:45,040 --> 00:10:50,079
and since the top byte of any pointer is

314
00:10:49,120 --> 00:10:52,240
going to be ignored

315
00:10:50,079 --> 00:10:53,839
we can store any value in the top byte

316
00:10:52,240 --> 00:10:55,839
right and

317
00:10:53,839 --> 00:10:57,360
this way we can actually store the tag

318
00:10:55,839 --> 00:10:58,959
that's assigned to the pointer in the

319
00:10:57,360 --> 00:11:00,800
top byte

320
00:10:58,959 --> 00:11:02,640
of course the limit that we have here

321
00:11:00,800 --> 00:11:05,120
since we can only use one byte

322
00:11:02,640 --> 00:11:05,920
is that we have eight bits per tag so we

323
00:11:05,120 --> 00:11:10,800
can only

324
00:11:05,920 --> 00:11:10,800
use 256 different stack values

325
00:11:11,519 --> 00:11:15,360
there are a few memory tagging

326
00:11:12,959 --> 00:11:18,399
implementations that are either exist

327
00:11:15,360 --> 00:11:19,040
or are in development right now and the

328
00:11:18,399 --> 00:11:22,480
first one

329
00:11:19,040 --> 00:11:23,920
is the spark agi

330
00:11:22,480 --> 00:11:25,680
and this one i'm going to not going to

331
00:11:23,920 --> 00:11:26,959
be discussing but it actually exists in

332
00:11:25,680 --> 00:11:29,839
some spark cpus

333
00:11:26,959 --> 00:11:30,319
it it's implemented in hardware and they

334
00:11:29,839 --> 00:11:32,560
use

335
00:11:30,320 --> 00:11:34,640
four bit tags for and memory granules of

336
00:11:32,560 --> 00:11:36,000
64 bytes

337
00:11:34,640 --> 00:11:37,839
the one that i'm going to discuss on the

338
00:11:36,000 --> 00:11:39,279
next slide in details is our memory

339
00:11:37,839 --> 00:11:40,800
tagging extension and it's being

340
00:11:39,279 --> 00:11:43,839
developed by arm

341
00:11:40,800 --> 00:11:45,359
and finally right now we actually have a

342
00:11:43,839 --> 00:11:47,279
software a partially software

343
00:11:45,360 --> 00:11:47,839
implementation of the memory tagging

344
00:11:47,279 --> 00:11:50,720
concept

345
00:11:47,839 --> 00:11:51,279
as a hardware assisted address sanitizer

346
00:11:50,720 --> 00:11:53,920
i say

347
00:11:51,279 --> 00:11:55,519
partially software because it still

348
00:11:53,920 --> 00:11:57,439
relies on the top byte ignore but

349
00:11:55,519 --> 00:12:01,279
luckily top byte ignore is present

350
00:11:57,440 --> 00:12:05,120
in a lot of modern arm cpus

351
00:12:01,279 --> 00:12:06,800
and i'm not going to discuss

352
00:12:05,120 --> 00:12:08,240
hardware assist address sanitizer right

353
00:12:06,800 --> 00:12:09,760
now because in the third part of the

354
00:12:08,240 --> 00:12:11,600
talk i'm going to be discussing its

355
00:12:09,760 --> 00:12:13,920
implementation for the kernel

356
00:12:11,600 --> 00:12:15,519
and let's concentrate on memory tagging

357
00:12:13,920 --> 00:12:18,479
for now

358
00:12:15,519 --> 00:12:19,200
so our memory tagging extension is has

359
00:12:18,480 --> 00:12:22,800
been added

360
00:12:19,200 --> 00:12:25,519
in arm v 0.5 not very long ago

361
00:12:22,800 --> 00:12:28,079
and right now it only exists as a spec

362
00:12:25,519 --> 00:12:30,160
so there is no actual hardware yet

363
00:12:28,079 --> 00:12:31,519
and with our memory tagging we have

364
00:12:30,160 --> 00:12:34,800
granule size of

365
00:12:31,519 --> 00:12:35,680
granule size of 16 and we have four bit

366
00:12:34,800 --> 00:12:38,079
tags

367
00:12:35,680 --> 00:12:39,920
for memory and four pointers and the

368
00:12:38,079 --> 00:12:40,560
four bit tag is actually stored in top

369
00:12:39,920 --> 00:12:42,719
bytes so

370
00:12:40,560 --> 00:12:44,479
our memory tagging also relies on the

371
00:12:42,720 --> 00:12:46,399
top byte ignore

372
00:12:44,480 --> 00:12:47,839
with our memory tagging extension

373
00:12:46,399 --> 00:12:49,680
extension

374
00:12:47,839 --> 00:12:52,160
the load and store instructions they

375
00:12:49,680 --> 00:12:54,560
will actually compare tags in hardware

376
00:12:52,160 --> 00:12:56,800
and make sure that attack on the pointer

377
00:12:54,560 --> 00:12:58,319
matches the attack on the memory

378
00:12:56,800 --> 00:13:00,079
and of course we have new instructions

379
00:12:58,320 --> 00:13:00,800
to manipulate attacks like set tech

380
00:13:00,079 --> 00:13:04,000
values

381
00:13:00,800 --> 00:13:04,000
and stuff like that

382
00:13:04,399 --> 00:13:07,680
if you think about it we have two

383
00:13:06,000 --> 00:13:10,560
different applications for

384
00:13:07,680 --> 00:13:12,638
mte and the first one is we can make

385
00:13:10,560 --> 00:13:13,359
better and faster debugging and testing

386
00:13:12,639 --> 00:13:16,000
tools

387
00:13:13,360 --> 00:13:18,160
for example we have right now we have a

388
00:13:16,000 --> 00:13:19,760
software implementation croissant

389
00:13:18,160 --> 00:13:21,360
and we can actually change it to depend

390
00:13:19,760 --> 00:13:22,959
on mte it's still going to be a

391
00:13:21,360 --> 00:13:24,959
debugging tool but instead of

392
00:13:22,959 --> 00:13:26,638
relying on software it's going to be

393
00:13:24,959 --> 00:13:27,680
using the hardware which is going to be

394
00:13:26,639 --> 00:13:29,519
faster

395
00:13:27,680 --> 00:13:31,439
the same thing we can do for the kernel

396
00:13:29,519 --> 00:13:34,000
and the same thing we can do for our

397
00:13:31,440 --> 00:13:35,120
sampling based tools for example the

398
00:13:34,000 --> 00:13:38,480
second application

399
00:13:35,120 --> 00:13:40,399
is using mte as a security mitigation

400
00:13:38,480 --> 00:13:42,320
and it can be used in the kernel it can

401
00:13:40,399 --> 00:13:44,320
be used in the user space

402
00:13:42,320 --> 00:13:46,639
and i highly recommend looking at this

403
00:13:44,320 --> 00:13:48,959
paper by microsoft

404
00:13:46,639 --> 00:13:49,680
where they address so they're trying to

405
00:13:48,959 --> 00:13:52,160
figure out

406
00:13:49,680 --> 00:13:53,279
what kind of exploitation techniques

407
00:13:52,160 --> 00:13:56,959
does memory tagging

408
00:13:53,279 --> 00:13:58,639
protect from and

409
00:13:56,959 --> 00:14:00,319
yeah there is also another interesting

410
00:13:58,639 --> 00:14:02,639
point is that actually

411
00:14:00,320 --> 00:14:03,760
if when you have memory tagging it turns

412
00:14:02,639 --> 00:14:05,199
out that you can

413
00:14:03,760 --> 00:14:07,439
when you're setting the attack on the

414
00:14:05,199 --> 00:14:10,880
memory you can initialize the memory

415
00:14:07,440 --> 00:14:13,279
at the same time without no extra cost

416
00:14:10,880 --> 00:14:14,399
so you actually get memory tagging plus

417
00:14:13,279 --> 00:14:17,360
memory installation

418
00:14:14,399 --> 00:14:18,639
for the same performance impact and

419
00:14:17,360 --> 00:14:21,519
there is a link here you can follow and

420
00:14:18,639 --> 00:14:25,440
find out the details

421
00:14:21,519 --> 00:14:28,079
so this is let's say you're using memory

422
00:14:25,440 --> 00:14:30,800
tagging or let's say you're using hwasan

423
00:14:28,079 --> 00:14:31,359
in user space and we have a problem the

424
00:14:30,800 --> 00:14:33,760
problem

425
00:14:31,360 --> 00:14:35,600
is that when we use top weight ignore

426
00:14:33,760 --> 00:14:37,680
the pointers the user space pointers

427
00:14:35,600 --> 00:14:39,680
will end up with stop byte set

428
00:14:37,680 --> 00:14:41,359
but the linux kernel by default does not

429
00:14:39,680 --> 00:14:43,680
expect that the linux kernel

430
00:14:41,360 --> 00:14:44,399
only accepts user pointers that have

431
00:14:43,680 --> 00:14:47,439
zero

432
00:14:44,399 --> 00:14:50,720
in the top byte so to address this issue

433
00:14:47,440 --> 00:14:52,560
a tact address api was developed it took

434
00:14:50,720 --> 00:14:54,399
a long time to figure out but right now

435
00:14:52,560 --> 00:14:55,760
it's in the mainline kernel and has been

436
00:14:54,399 --> 00:14:59,279
backported to

437
00:14:55,760 --> 00:15:00,639
android kernels 4.14 4.19 and 5.4 of

438
00:14:59,279 --> 00:15:04,000
course

439
00:15:00,639 --> 00:15:06,000
so this is required for

440
00:15:04,000 --> 00:15:07,920
hwasong to work and in the future will

441
00:15:06,000 --> 00:15:09,920
be required for mte

442
00:15:07,920 --> 00:15:12,000
and you can find out more details in the

443
00:15:09,920 --> 00:15:13,519
documentation link that i have here but

444
00:15:12,000 --> 00:15:15,360
the general idea is that you just

445
00:15:13,519 --> 00:15:17,360
we just taught the kernel we explained

446
00:15:15,360 --> 00:15:19,920
to the kernel that stacked

447
00:15:17,360 --> 00:15:22,320
users user pointers are okay in certain

448
00:15:19,920 --> 00:15:22,319
cases

449
00:15:22,480 --> 00:15:25,760
and here we come to the current state of

450
00:15:25,199 --> 00:15:28,479
mte

451
00:15:25,760 --> 00:15:30,160
in user space so first of all for user

452
00:15:28,480 --> 00:15:32,320
space mt we do have the software

453
00:15:30,160 --> 00:15:34,719
implementation that works

454
00:15:32,320 --> 00:15:35,600
and we do actually have an android open

455
00:15:34,720 --> 00:15:38,320
source based

456
00:15:35,600 --> 00:15:39,680
image that includes user space apps

457
00:15:38,320 --> 00:15:41,279
built with hassan

458
00:15:39,680 --> 00:15:42,959
and you can just download the image and

459
00:15:41,279 --> 00:15:43,839
you can flash it onto your android

460
00:15:42,959 --> 00:15:45,279
device

461
00:15:43,839 --> 00:15:46,880
and this of course requires what i

462
00:15:45,279 --> 00:15:49,120
mentioned on the last slide the

463
00:15:46,880 --> 00:15:49,920
tagged address api but this has been

464
00:15:49,120 --> 00:15:52,959
merged

465
00:15:49,920 --> 00:15:56,479
into android common kernels

466
00:15:52,959 --> 00:15:58,638
the second thing that we have that we

467
00:15:56,480 --> 00:16:00,639
will be required for proper user space

468
00:15:58,639 --> 00:16:02,880
and key is more kernel support

469
00:16:00,639 --> 00:16:04,720
and more kernel support is in progress

470
00:16:02,880 --> 00:16:06,560
there are patches on the mailing list

471
00:16:04,720 --> 00:16:07,759
and has been discussed for mainline

472
00:16:06,560 --> 00:16:09,839
inclusion

473
00:16:07,759 --> 00:16:11,519
it's not in mainline yet and it's not in

474
00:16:09,839 --> 00:16:13,040
android yet but hopefully will be at

475
00:16:11,519 --> 00:16:15,920
some point

476
00:16:13,040 --> 00:16:18,079
and finally arm actually has an emulator

477
00:16:15,920 --> 00:16:22,000
that you can try to use and it has

478
00:16:18,079 --> 00:16:23,758
mte available

479
00:16:22,000 --> 00:16:25,680
okay now we come to the third part of

480
00:16:23,759 --> 00:16:28,959
the talk which is about

481
00:16:25,680 --> 00:16:31,680
software tag-based kasana and

482
00:16:28,959 --> 00:16:33,599
initially it was called colonel hwasan

483
00:16:31,680 --> 00:16:34,399
so we wanted to implement hwasong for

484
00:16:33,600 --> 00:16:36,399
the kernel

485
00:16:34,399 --> 00:16:38,480
but at some point we decided to change

486
00:16:36,399 --> 00:16:40,320
the name to better

487
00:16:38,480 --> 00:16:43,279
integrated with the current naming

488
00:16:40,320 --> 00:16:45,759
scheme that is used for kasan

489
00:16:43,279 --> 00:16:47,680
and so for those who don't know kassan

490
00:16:45,759 --> 00:16:48,160
is a memory bug detector for the linux

491
00:16:47,680 --> 00:16:51,120
kernel

492
00:16:48,160 --> 00:16:51,600
it can find out of bounds box on heap

493
00:16:51,120 --> 00:16:53,519
stack

494
00:16:51,600 --> 00:16:55,519
and globals and it can find use of the

495
00:16:53,519 --> 00:16:58,160
free box and some other types of

496
00:16:55,519 --> 00:17:00,000
issues memory issues it's really easy to

497
00:16:58,160 --> 00:17:02,000
use the only thing that you need to do

498
00:17:00,000 --> 00:17:03,440
is to flip config cassand when you build

499
00:17:02,000 --> 00:17:05,199
the kernel and

500
00:17:03,440 --> 00:17:06,959
that's it just build the kernel and run

501
00:17:05,199 --> 00:17:10,240
it

502
00:17:06,959 --> 00:17:12,640
this tool is really useful in case

503
00:17:10,240 --> 00:17:13,839
you want to detect memory corruptions so

504
00:17:12,640 --> 00:17:14,480
let's say you have some memory

505
00:17:13,839 --> 00:17:16,240
corruption

506
00:17:14,480 --> 00:17:18,400
and you're trying to track it down but

507
00:17:16,240 --> 00:17:20,319
the problem quite often is that

508
00:17:18,400 --> 00:17:22,319
memory corruptions actually crash your

509
00:17:20,319 --> 00:17:24,240
kernel or your program and some random

510
00:17:22,319 --> 00:17:26,959
points because the memory is corrupted

511
00:17:24,240 --> 00:17:28,400
and kazan tries to detect the corruption

512
00:17:26,959 --> 00:17:31,200
as early as possible

513
00:17:28,400 --> 00:17:32,880
preferably at the point where the memory

514
00:17:31,200 --> 00:17:35,120
corruption occurred

515
00:17:32,880 --> 00:17:36,160
so when it detects a memory corruption

516
00:17:35,120 --> 00:17:39,280
it's going to print

517
00:17:36,160 --> 00:17:41,120
a report like this address was

518
00:17:39,280 --> 00:17:42,720
involved this object was involved here's

519
00:17:41,120 --> 00:17:43,840
the call trace here where the object was

520
00:17:42,720 --> 00:17:46,160
allocated

521
00:17:43,840 --> 00:17:48,080
here's when the object was freed in case

522
00:17:46,160 --> 00:17:51,039
in cases the use of the free and

523
00:17:48,080 --> 00:17:52,639
all information like that and it

524
00:17:51,039 --> 00:17:54,240
actually has a very moderate slowdown in

525
00:17:52,640 --> 00:17:56,720
memory overhead so you can use it for

526
00:17:54,240 --> 00:17:58,799
testing no problem

527
00:17:56,720 --> 00:18:01,360
in this software tag-based kazan we just

528
00:17:58,799 --> 00:18:02,480
added another mode of to kasan that is

529
00:18:01,360 --> 00:18:05,120
based on

530
00:18:02,480 --> 00:18:07,280
hardware assisted address intel so the

531
00:18:05,120 --> 00:18:10,000
original mod that is now called generic

532
00:18:07,280 --> 00:18:12,840
is based on user space asan and the

533
00:18:10,000 --> 00:18:14,559
tag-based kasan is based on user space

534
00:18:12,840 --> 00:18:17,600
hassan

535
00:18:14,559 --> 00:18:18,559
and the idea of the new name was first

536
00:18:17,600 --> 00:18:20,480
of all we

537
00:18:18,559 --> 00:18:22,160
rely on memory tagging so that's why we

538
00:18:20,480 --> 00:18:24,080
called it tag based

539
00:18:22,160 --> 00:18:26,400
and the software part comes from the

540
00:18:24,080 --> 00:18:28,720
fact that this does not yet require

541
00:18:26,400 --> 00:18:30,240
this does not require any hardware

542
00:18:28,720 --> 00:18:31,919
implementation for memory tagging it

543
00:18:30,240 --> 00:18:33,919
does it in software

544
00:18:31,919 --> 00:18:35,760
in the future we will hopefully have a

545
00:18:33,919 --> 00:18:37,760
hardware attack-based cassand

546
00:18:35,760 --> 00:18:41,200
which will actually use hardware

547
00:18:37,760 --> 00:18:43,039
implementation in the form of mte

548
00:18:41,200 --> 00:18:45,360
and stack-based cassand can be enabled

549
00:18:43,039 --> 00:18:48,240
with config cassand sw tags

550
00:18:45,360 --> 00:18:48,959
and it's been merged into mainline over

551
00:18:48,240 --> 00:18:50,960
a year ago

552
00:18:48,960 --> 00:18:53,200
and it's been backported into android

553
00:18:50,960 --> 00:18:55,440
4.14 4.19 and

554
00:18:53,200 --> 00:18:56,400
of course since it's loaded in 5.4 since

555
00:18:55,440 --> 00:18:59,360
it's

556
00:18:56,400 --> 00:19:00,160
after it was merged into mainland it

557
00:18:59,360 --> 00:19:02,399
currently

558
00:19:00,160 --> 00:19:04,320
only works with clang so it's not

559
00:19:02,400 --> 00:19:06,320
supported in gcc

560
00:19:04,320 --> 00:19:07,760
and the original kasan mod that we had

561
00:19:06,320 --> 00:19:11,280
is now called generic

562
00:19:07,760 --> 00:19:12,720
and the idea here is the original mode

563
00:19:11,280 --> 00:19:15,000
actually does not depend on any

564
00:19:12,720 --> 00:19:18,000
architecture so it can be used for arm

565
00:19:15,000 --> 00:19:18,000
xhx

566
00:19:18,400 --> 00:19:22,240
it can be used for arm x86 and other

567
00:19:20,960 --> 00:19:25,039
architectures there is quite a list

568
00:19:22,240 --> 00:19:29,039
right now actually

569
00:19:25,039 --> 00:19:30,400
okay so for if you remember when we were

570
00:19:29,039 --> 00:19:32,000
discussing memory tagging

571
00:19:30,400 --> 00:19:33,840
for a particular memory tagging

572
00:19:32,000 --> 00:19:34,960
implementation we need to answer these

573
00:19:33,840 --> 00:19:36,639
questions

574
00:19:34,960 --> 00:19:38,480
so i'm going to explain to you how

575
00:19:36,640 --> 00:19:40,960
cassandra works and then present the

576
00:19:38,480 --> 00:19:43,280
answers to all of those questions

577
00:19:40,960 --> 00:19:44,880
first of all most of the sanitizers i

578
00:19:43,280 --> 00:19:46,960
think even all of the sanitaries

579
00:19:44,880 --> 00:19:48,000
that we have they actually consist of

580
00:19:46,960 --> 00:19:50,640
two parts

581
00:19:48,000 --> 00:19:52,000
the first part is a compiler module that

582
00:19:50,640 --> 00:19:53,919
inserts instructions

583
00:19:52,000 --> 00:19:55,280
around each memory access and those

584
00:19:53,919 --> 00:19:57,120
extraction actually

585
00:19:55,280 --> 00:19:58,799
there are the function calls for actual

586
00:19:57,120 --> 00:20:00,080
instructions to make sure that the

587
00:19:58,799 --> 00:20:03,520
memory access is

588
00:20:00,080 --> 00:20:05,918
valid and we have the runtime part

589
00:20:03,520 --> 00:20:07,918
that implements the hooks that are

590
00:20:05,919 --> 00:20:08,799
inserted by the compiler that has some

591
00:20:07,919 --> 00:20:12,240
annotations

592
00:20:08,799 --> 00:20:14,320
for the allocator for example in case of

593
00:20:12,240 --> 00:20:15,280
tag based cassandra will need to mark

594
00:20:14,320 --> 00:20:18,000
the memory

595
00:20:15,280 --> 00:20:18,960
stack trade and it puts all of those

596
00:20:18,000 --> 00:20:22,400
things together

597
00:20:18,960 --> 00:20:22,400
to actually detect box

598
00:20:22,960 --> 00:20:27,840
so we stuck based cassand to store tags

599
00:20:25,760 --> 00:20:28,960
we use shadow memory and shadow memory

600
00:20:27,840 --> 00:20:31,120
is just the region

601
00:20:28,960 --> 00:20:32,480
of memory that is reserved specifically

602
00:20:31,120 --> 00:20:36,000
focus on

603
00:20:32,480 --> 00:20:37,840
we use one byte tag for each 16 bytes of

604
00:20:36,000 --> 00:20:40,320
memory

605
00:20:37,840 --> 00:20:41,600
since the native kernel pointers

606
00:20:40,320 --> 00:20:44,240
actually have ff

607
00:20:41,600 --> 00:20:46,399
in their top byte we initialize all

608
00:20:44,240 --> 00:20:49,360
shadow memory with ff

609
00:20:46,400 --> 00:20:51,360
and we when it comes to attack values we

610
00:20:49,360 --> 00:20:52,959
actually do have to reserve tech values

611
00:20:51,360 --> 00:20:55,039
that are not being used when

612
00:20:52,960 --> 00:20:56,240
random tuck are being generated the

613
00:20:55,039 --> 00:20:58,879
first one is ff

614
00:20:56,240 --> 00:21:01,520
because it's a native kernel pointer tag

615
00:20:58,880 --> 00:21:03,840
like native kernel point or top byte

616
00:21:01,520 --> 00:21:04,879
and the second one is invalid which is

617
00:21:03,840 --> 00:21:06,559
fe

618
00:21:04,880 --> 00:21:08,159
and we use it for memory that is

619
00:21:06,559 --> 00:21:11,280
definitely inaccessible

620
00:21:08,159 --> 00:21:13,840
for example cassandra actually stores

621
00:21:11,280 --> 00:21:14,960
metadata rich allocated object and this

622
00:21:13,840 --> 00:21:17,520
metadata stores

623
00:21:14,960 --> 00:21:19,039
handles to stack traces allocation and

624
00:21:17,520 --> 00:21:22,080
allocation stack traces

625
00:21:19,039 --> 00:21:23,679
and we mark that metadata with fe and we

626
00:21:22,080 --> 00:21:26,720
also mark freed object with

627
00:21:23,679 --> 00:21:27,600
the invalid tag so this is how the

628
00:21:26,720 --> 00:21:30,080
shadow memory

629
00:21:27,600 --> 00:21:31,600
looks like it just basically part of

630
00:21:30,080 --> 00:21:32,879
address space and the whole kernel

631
00:21:31,600 --> 00:21:36,000
address sprays

632
00:21:32,880 --> 00:21:39,120
linearly maps onto shadow memory

633
00:21:36,000 --> 00:21:39,520
since each 16 bytes of kernel memory

634
00:21:39,120 --> 00:21:41,760
have

635
00:21:39,520 --> 00:21:44,080
one byte of shadow we just divide

636
00:21:41,760 --> 00:21:47,440
address by 16 or shifted by 4

637
00:21:44,080 --> 00:21:48,000
and at the offset to calculate the

638
00:21:47,440 --> 00:21:51,840
address

639
00:21:48,000 --> 00:21:55,360
of the shadow memory byte based on the

640
00:21:51,840 --> 00:21:55,760
address of the kernel memory this is the

641
00:21:55,360 --> 00:21:58,959
way

642
00:21:55,760 --> 00:22:01,039
allocator annotations look like

643
00:21:58,960 --> 00:22:02,559
so let's say we have a kmala k-malek as

644
00:22:01,039 --> 00:22:03,679
a kernel function that actually

645
00:22:02,559 --> 00:22:06,240
allocates memory

646
00:22:03,679 --> 00:22:07,919
one of them at least and by default it

647
00:22:06,240 --> 00:22:10,840
just returns a pointer

648
00:22:07,919 --> 00:22:12,000
with stack-based kasan we actually have

649
00:22:10,840 --> 00:22:14,799
a

650
00:22:12,000 --> 00:22:15,679
call around the return pointer which is

651
00:22:14,799 --> 00:22:18,240
called here okay

652
00:22:15,679 --> 00:22:19,520
cassand k malloc and that call is going

653
00:22:18,240 --> 00:22:21,520
to generate random tag

654
00:22:19,520 --> 00:22:23,039
it's going to tag the memory by setting

655
00:22:21,520 --> 00:22:25,679
the shadow memory

656
00:22:23,039 --> 00:22:27,440
it's going to embed the generated tag

657
00:22:25,679 --> 00:22:28,720
into the top byte of the return pointer

658
00:22:27,440 --> 00:22:31,039
and return it

659
00:22:28,720 --> 00:22:32,799
it also of course does other bookkeeping

660
00:22:31,039 --> 00:22:34,559
stuff like saving stack trace handles

661
00:22:32,799 --> 00:22:37,760
into the metadata

662
00:22:34,559 --> 00:22:39,918
and stuff like that so

663
00:22:37,760 --> 00:22:41,120
since and of course also all of the

664
00:22:39,919 --> 00:22:44,320
objects are

665
00:22:41,120 --> 00:22:45,840
aligned to the granule size 16 and since

666
00:22:44,320 --> 00:22:47,439
all of the objects actually store

667
00:22:45,840 --> 00:22:50,000
metadata also have to increase the

668
00:22:47,440 --> 00:22:53,120
object size by the size of metadata

669
00:22:50,000 --> 00:22:54,080
cassand k3 which is the annotation for

670
00:22:53,120 --> 00:22:55,678
the k3 function

671
00:22:54,080 --> 00:22:58,559
that freeze memory actually re-attacks

672
00:22:55,679 --> 00:23:00,480
memory with invalid tag

673
00:22:58,559 --> 00:23:02,080
here's a small example in this case i'm

674
00:23:00,480 --> 00:23:04,880
going to be using tbi

675
00:23:02,080 --> 00:23:06,879
to bite ignore to show the tags so let's

676
00:23:04,880 --> 00:23:07,600
say we're allocating 35 bytes with k

677
00:23:06,880 --> 00:23:09,360
malloc

678
00:23:07,600 --> 00:23:11,199
and let's say the random tag that k

679
00:23:09,360 --> 00:23:13,600
malek generated is 42.

680
00:23:11,200 --> 00:23:14,880
so the pointer has been tagged with 42

681
00:23:13,600 --> 00:23:18,320
with green tag

682
00:23:14,880 --> 00:23:21,840
the and the top by tag says 42

683
00:23:18,320 --> 00:23:23,120
and the object of size 35 when you

684
00:23:21,840 --> 00:23:26,320
allocate it in the kernel

685
00:23:23,120 --> 00:23:29,039
it's going to use the k malik 64 cache

686
00:23:26,320 --> 00:23:30,559
so 35 bytes actually requires three

687
00:23:29,039 --> 00:23:31,840
granules of size 16

688
00:23:30,559 --> 00:23:34,000
and then there is going to be the fourth

689
00:23:31,840 --> 00:23:35,280
granule that is actually used to store

690
00:23:34,000 --> 00:23:36,480
cassand metadata

691
00:23:35,280 --> 00:23:39,280
and this is the way it's going to look

692
00:23:36,480 --> 00:23:41,440
in memory and

693
00:23:39,280 --> 00:23:43,039
shadow memory will store the attack

694
00:23:41,440 --> 00:23:45,600
values for these

695
00:23:43,039 --> 00:23:46,720
memory granules the three accessible

696
00:23:45,600 --> 00:23:49,918
memory granules

697
00:23:46,720 --> 00:23:52,480
are going to store the same value as the

698
00:23:49,919 --> 00:23:54,880
top byte of the pointer which is 42

699
00:23:52,480 --> 00:23:58,480
and the last granule is going to be

700
00:23:54,880 --> 00:24:00,159
marked with invalid sfe

701
00:23:58,480 --> 00:24:02,159
and finally when you freeze the memory

702
00:24:00,159 --> 00:24:04,159
the memory is also retacked to invalid

703
00:24:02,159 --> 00:24:07,360
and this is the way it looks in memory

704
00:24:04,159 --> 00:24:07,360
and in shadow memory

705
00:24:07,520 --> 00:24:11,679
so let me answer the question that i've

706
00:24:09,039 --> 00:24:12,799
presented before the granule size with

707
00:24:11,679 --> 00:24:16,000
stack based kasan

708
00:24:12,799 --> 00:24:18,799
is 16 bytes like with mt we have

709
00:24:16,000 --> 00:24:20,640
256 different tags but two of those are

710
00:24:18,799 --> 00:24:22,080
reserved we have eight bits to store

711
00:24:20,640 --> 00:24:24,799
attack

712
00:24:22,080 --> 00:24:26,158
and the tag i mean software attack based

713
00:24:24,799 --> 00:24:29,840
custom uses tbi

714
00:24:26,159 --> 00:24:31,840
to embed tax into pointer stop byte

715
00:24:29,840 --> 00:24:33,439
and the tax are assigned an allocator

716
00:24:31,840 --> 00:24:35,279
and stored in shadow memory

717
00:24:33,440 --> 00:24:36,960
and finally the comparisons are

718
00:24:35,279 --> 00:24:40,159
performed performed

719
00:24:36,960 --> 00:24:41,919
by the compiler by the instructions that

720
00:24:40,159 --> 00:24:44,320
compiler inserts when compiling the

721
00:24:41,919 --> 00:24:44,320
kernel

722
00:24:44,640 --> 00:24:49,840
let's compare the overheads that we have

723
00:24:47,679 --> 00:24:52,720
for software attack based cassand and

724
00:24:49,840 --> 00:24:55,039
the old original generic mode of cassand

725
00:24:52,720 --> 00:24:56,880
the cpu overhead turned out to be almost

726
00:24:55,039 --> 00:24:58,960
the same around 2x

727
00:24:56,880 --> 00:25:00,159
but the memory overhead is completely

728
00:24:58,960 --> 00:25:03,039
different

729
00:25:00,159 --> 00:25:05,039
first of all when it comes to hassan

730
00:25:03,039 --> 00:25:06,080
memory overhead actually consists of a

731
00:25:05,039 --> 00:25:07,679
few parts

732
00:25:06,080 --> 00:25:09,279
and the first part is actually slop

733
00:25:07,679 --> 00:25:11,520
memory usage

734
00:25:09,279 --> 00:25:13,279
overhead and it comes from the fact that

735
00:25:11,520 --> 00:25:14,080
first of all we need to store metadata

736
00:25:13,279 --> 00:25:16,400
after the object

737
00:25:14,080 --> 00:25:17,279
and then we have to also align the

738
00:25:16,400 --> 00:25:19,600
object

739
00:25:17,279 --> 00:25:21,440
up to the granule size and in case of

740
00:25:19,600 --> 00:25:23,360
generic kasan the

741
00:25:21,440 --> 00:25:25,360
overhead is actually 2x but in case of

742
00:25:23,360 --> 00:25:28,479
tag-based cassand it's only 20

743
00:25:25,360 --> 00:25:30,080
which is extremely low the second part

744
00:25:28,480 --> 00:25:31,600
that contributes to the memory overhead

745
00:25:30,080 --> 00:25:34,720
is the shadow memory

746
00:25:31,600 --> 00:25:36,399
and with software attack-based hassan we

747
00:25:34,720 --> 00:25:38,559
have to use twice less shadow memory

748
00:25:36,400 --> 00:25:40,480
than with generic kazan

749
00:25:38,559 --> 00:25:42,080
and finally tag-based kasam does not

750
00:25:40,480 --> 00:25:44,159
require quarantine

751
00:25:42,080 --> 00:25:46,799
quarantine is a feature that generic

752
00:25:44,159 --> 00:25:48,640
hassan uses to delay the reuse of memory

753
00:25:46,799 --> 00:25:49,679
and increase the chance of detecting use

754
00:25:48,640 --> 00:25:51,360
of the free

755
00:25:49,679 --> 00:25:54,159
and software tag-based kazan does not

756
00:25:51,360 --> 00:25:57,520
need it just by design

757
00:25:54,159 --> 00:25:58,960
and putting all of this together come

758
00:25:57,520 --> 00:26:00,720
we come to the following conclusion that

759
00:25:58,960 --> 00:26:02,000
software tag-based kasan is actually

760
00:26:00,720 --> 00:26:05,840
suitable for

761
00:26:02,000 --> 00:26:08,840
use user usage on actual testing devices

762
00:26:05,840 --> 00:26:10,559
and we actually do that internally at

763
00:26:08,840 --> 00:26:11,760
google and

764
00:26:10,559 --> 00:26:14,158
yeah something that i want to mention

765
00:26:11,760 --> 00:26:16,400
here is that if you get a device

766
00:26:14,159 --> 00:26:18,640
we actually create actually have an

767
00:26:16,400 --> 00:26:20,960
image an android image that has

768
00:26:18,640 --> 00:26:22,000
software tag-based kasan for the kernel

769
00:26:20,960 --> 00:26:24,559
and then hwasan

770
00:26:22,000 --> 00:26:26,320
for the user space in the same image and

771
00:26:24,559 --> 00:26:27,039
the device is usable you can actually

772
00:26:26,320 --> 00:26:28,559
use it for

773
00:26:27,039 --> 00:26:30,960
day-to-day stuff and it's perfect for

774
00:26:28,559 --> 00:26:32,639
testing with the old

775
00:26:30,960 --> 00:26:35,440
generic cassandra actually had a problem

776
00:26:32,640 --> 00:26:36,799
since it required too much memory it's

777
00:26:35,440 --> 00:26:39,840
most of the time it would make the

778
00:26:36,799 --> 00:26:39,840
device unusable

779
00:26:40,320 --> 00:26:45,120
so currently what we have is the

780
00:26:42,960 --> 00:26:47,039
software implementation

781
00:26:45,120 --> 00:26:49,279
of memory tagging for the kernel in the

782
00:26:47,039 --> 00:26:51,760
form of software tag-based kasan

783
00:26:49,279 --> 00:26:53,360
currently it only covers the heap memory

784
00:26:51,760 --> 00:26:54,720
of the slop memory how it's called in

785
00:26:53,360 --> 00:26:56,320
case of the kernel

786
00:26:54,720 --> 00:26:58,480
and the first thing we would want to do

787
00:26:56,320 --> 00:27:00,399
is to add stack and global support for

788
00:26:58,480 --> 00:27:00,960
it as well to be able to detect bugs in

789
00:27:00,400 --> 00:27:02,960
stack

790
00:27:00,960 --> 00:27:04,640
and globals the stack is currently in

791
00:27:02,960 --> 00:27:06,080
progress and globals will be addressed

792
00:27:04,640 --> 00:27:08,880
after that

793
00:27:06,080 --> 00:27:10,799
the second part after finishing this

794
00:27:08,880 --> 00:27:11,919
would be to add a hardware mod for

795
00:27:10,799 --> 00:27:14,080
tag-based kasan

796
00:27:11,919 --> 00:27:15,200
that is actually based on mte just to

797
00:27:14,080 --> 00:27:17,039
make it faster

798
00:27:15,200 --> 00:27:18,399
and it's still going to be a debugging

799
00:27:17,039 --> 00:27:20,960
tool and

800
00:27:18,399 --> 00:27:23,120
finally the last step which we will

801
00:27:20,960 --> 00:27:26,480
hopefully reach at some point

802
00:27:23,120 --> 00:27:27,520
is to have the empty implementation in

803
00:27:26,480 --> 00:27:30,960
the kernel

804
00:27:27,520 --> 00:27:34,639
and to have it usable as a production

805
00:27:30,960 --> 00:27:36,720
grade mitigation technique

806
00:27:34,640 --> 00:27:37,760
this is the last part that is a call to

807
00:27:36,720 --> 00:27:40,640
action for

808
00:27:37,760 --> 00:27:42,720
people who actually write kernel code or

809
00:27:40,640 --> 00:27:45,520
for vendors to actually make

810
00:27:42,720 --> 00:27:46,240
android devices first of all please use

811
00:27:45,520 --> 00:27:48,960
kasan

812
00:27:46,240 --> 00:27:51,679
for testing the kernel and it's really

813
00:27:48,960 --> 00:27:55,120
easy to use just flip the config and

814
00:27:51,679 --> 00:27:57,039
that's it i realize that the testing

815
00:27:55,120 --> 00:27:58,080
story when it comes to the linux kernel

816
00:27:57,039 --> 00:27:59,919
is complicated

817
00:27:58,080 --> 00:28:01,760
so if you don't have any tests any

818
00:27:59,919 --> 00:28:03,039
kernel tests please make sure that

819
00:28:01,760 --> 00:28:06,320
device boots at least

820
00:28:03,039 --> 00:28:07,360
without any bug reports the second two

821
00:28:06,320 --> 00:28:09,039
points

822
00:28:07,360 --> 00:28:10,799
are actually about using tag-based

823
00:28:09,039 --> 00:28:11,520
hassan and the two reasons that you want

824
00:28:10,799 --> 00:28:14,000
to do that

825
00:28:11,520 --> 00:28:16,240
first of all because tag-based kasan is

826
00:28:14,000 --> 00:28:17,039
usable on testing devices you can

827
00:28:16,240 --> 00:28:19,919
actually

828
00:28:17,039 --> 00:28:21,679
use it to find bugs that are not

829
00:28:19,919 --> 00:28:23,600
reproducible during testing

830
00:28:21,679 --> 00:28:25,520
but are reproducible during the normal

831
00:28:23,600 --> 00:28:29,120
usage of a device

832
00:28:25,520 --> 00:28:30,879
and we use it internally and finally

833
00:28:29,120 --> 00:28:32,559
attack-based cassand is a good way to

834
00:28:30,880 --> 00:28:34,240
prepare yourself for mte

835
00:28:32,559 --> 00:28:36,158
because it's the software implementation

836
00:28:34,240 --> 00:28:38,640
of a very of the same concept

837
00:28:36,159 --> 00:28:39,279
right so you can try it and try to find

838
00:28:38,640 --> 00:28:41,200
out

839
00:28:39,279 --> 00:28:42,480
whether your kernel code has any

840
00:28:41,200 --> 00:28:44,720
compatibilities

841
00:28:42,480 --> 00:28:45,919
with it or whether your private drivers

842
00:28:44,720 --> 00:28:48,559
have some issues

843
00:28:45,919 --> 00:28:52,960
and this will definitely simplify the

844
00:28:48,559 --> 00:28:52,960
future integration of in kernel mte

845
00:28:53,200 --> 00:29:00,320
so this is the slides that they have

846
00:28:56,240 --> 00:29:03,600
thank you wonderful thank you

847
00:29:00,320 --> 00:29:06,720
um so we've got some time for questions

848
00:29:03,600 --> 00:29:07,360
um if you have anyone i'm keeping an eye

849
00:29:06,720 --> 00:29:10,720
on both

850
00:29:07,360 --> 00:29:14,320
uh mattermost uh and the zoom chat or

851
00:29:10,720 --> 00:29:14,320
if you want to raise your hand and zoom

852
00:29:19,520 --> 00:29:25,679
um really you're welcome to ask your

853
00:29:23,360 --> 00:29:25,678
question

854
00:29:25,760 --> 00:29:31,440
thanks andre for the excellent talk on

855
00:29:28,640 --> 00:29:32,799
introducing not only that specific case

856
00:29:31,440 --> 00:29:35,600
and version but the whole

857
00:29:32,799 --> 00:29:36,720
topic of memory tagging which i think

858
00:29:35,600 --> 00:29:38,799
maybe

859
00:29:36,720 --> 00:29:40,640
may have been new to some developers but

860
00:29:38,799 --> 00:29:42,480
is something that

861
00:29:40,640 --> 00:29:43,679
most of us will have to deal with in the

862
00:29:42,480 --> 00:29:47,760
near future

863
00:29:43,679 --> 00:29:50,159
now what i was wondering is if you

864
00:29:47,760 --> 00:29:50,960
already if syscaller was now already

865
00:29:50,159 --> 00:29:54,159
able to

866
00:29:50,960 --> 00:29:57,520
find more kernel bugs by enabling

867
00:29:54,159 --> 00:30:00,880
kasan in your

868
00:29:57,520 --> 00:30:04,480
kernel test cases and if so how does

869
00:30:00,880 --> 00:30:07,440
the linux upstream kernel community

870
00:30:04,480 --> 00:30:09,600
react to another flurry of cisco bugs

871
00:30:07,440 --> 00:30:12,640
coming in

872
00:30:09,600 --> 00:30:14,639
okay i see so she's caller

873
00:30:12,640 --> 00:30:16,960
actually initially we've developed the

874
00:30:14,640 --> 00:30:18,880
first version of kazan the generic kazan

875
00:30:16,960 --> 00:30:21,520
before we had c scholar

876
00:30:18,880 --> 00:30:22,000
so from the first the very first moment

877
00:30:21,520 --> 00:30:24,480
of using

878
00:30:22,000 --> 00:30:26,320
syscolar we actually had casan enabled

879
00:30:24,480 --> 00:30:28,880
on cisco

880
00:30:26,320 --> 00:30:30,000
and we stuck based on we do not

881
00:30:28,880 --> 00:30:33,120
currently have

882
00:30:30,000 --> 00:30:34,000
an instance that is running on csbot in

883
00:30:33,120 --> 00:30:37,039
the cloud

884
00:30:34,000 --> 00:30:40,640
in the cloud because we do not have

885
00:30:37,039 --> 00:30:44,158
proper setup for fuzzing arm

886
00:30:40,640 --> 00:30:45,279
kernels in the cloud yet um actually if

887
00:30:44,159 --> 00:30:47,679
you start using

888
00:30:45,279 --> 00:30:48,559
tug based kasan for fuzzing with this

889
00:30:47,679 --> 00:30:50,559
color

890
00:30:48,559 --> 00:30:52,240
i am not sure you're gonna get many new

891
00:30:50,559 --> 00:30:55,760
bugs because

892
00:30:52,240 --> 00:30:57,600
tag-based kazan will not find like new

893
00:30:55,760 --> 00:30:58,480
types of issues in terms of memory

894
00:30:57,600 --> 00:31:01,439
safety

895
00:30:58,480 --> 00:31:02,159
it might find new issues in terms of

896
00:31:01,440 --> 00:31:04,240
income

897
00:31:02,159 --> 00:31:05,840
incompatibilities with using top byte

898
00:31:04,240 --> 00:31:07,840
ignore for example

899
00:31:05,840 --> 00:31:10,240
but the bugs the memory safety issues

900
00:31:07,840 --> 00:31:12,000
for generic sun and tag-based kasana are

901
00:31:10,240 --> 00:31:14,880
the same classes of issues

902
00:31:12,000 --> 00:31:16,000
and since tag-based kazan is actually a

903
00:31:14,880 --> 00:31:18,159
little bit

904
00:31:16,000 --> 00:31:21,039
weaker than generic hassan because the

905
00:31:18,159 --> 00:31:24,320
generic hassan has more

906
00:31:21,039 --> 00:31:27,840
capability of detecting really small um

907
00:31:24,320 --> 00:31:28,559
out-of-bound successes the main the main

908
00:31:27,840 --> 00:31:31,199
use case

909
00:31:28,559 --> 00:31:32,720
for tag-based kazan is not actually

910
00:31:31,200 --> 00:31:34,799
fuzzing

911
00:31:32,720 --> 00:31:36,159
i mean it can it can actually be really

912
00:31:34,799 --> 00:31:38,080
useful for fuzzing on

913
00:31:36,159 --> 00:31:39,279
actual android devices if you ever do

914
00:31:38,080 --> 00:31:41,760
that because

915
00:31:39,279 --> 00:31:43,039
generic sound can make the device really

916
00:31:41,760 --> 00:31:44,960
slow and unusable

917
00:31:43,039 --> 00:31:46,080
and tag-based kasan should allow the

918
00:31:44,960 --> 00:31:48,080
device to keep up

919
00:31:46,080 --> 00:31:49,519
so you can use it for fuzzing on devices

920
00:31:48,080 --> 00:31:50,639
but for fuzzy in the cloud

921
00:31:49,519 --> 00:31:55,840
i don't think it's going to be very

922
00:31:50,640 --> 00:31:55,840
useful thanks for clarifying

923
00:31:57,600 --> 00:32:01,199
so as other folks are thinking of

924
00:31:58,960 --> 00:32:03,279
potential questions um

925
00:32:01,200 --> 00:32:05,279
so again thank you for the great

926
00:32:03,279 --> 00:32:07,039
overview of the topic it's an area that

927
00:32:05,279 --> 00:32:08,880
i'm not particularly familiar with and i

928
00:32:07,039 --> 00:32:10,000
learned a lot throughout the talk

929
00:32:08,880 --> 00:32:12,080
you know one of the things that you

930
00:32:10,000 --> 00:32:12,960
mentioned was there's slowly becoming

931
00:32:12,080 --> 00:32:15,039
more and more

932
00:32:12,960 --> 00:32:16,240
hardware support for for doing these

933
00:32:15,039 --> 00:32:18,640
these tests

934
00:32:16,240 --> 00:32:20,880
as this hardware support becomes more

935
00:32:18,640 --> 00:32:22,880
widely available do you see potential

936
00:32:20,880 --> 00:32:25,440
for these techniques

937
00:32:22,880 --> 00:32:27,039
to possibly be used more generally as a

938
00:32:25,440 --> 00:32:28,559
runtime defense or is this always going

939
00:32:27,039 --> 00:32:31,840
to be a testing

940
00:32:28,559 --> 00:32:33,760
sort of capability yeah so my hope is

941
00:32:31,840 --> 00:32:36,000
that eventually we will have

942
00:32:33,760 --> 00:32:37,360
in particular memory tagging be used as

943
00:32:36,000 --> 00:32:40,080
a mitigation

944
00:32:37,360 --> 00:32:41,918
and not only for testing it's like the

945
00:32:40,080 --> 00:32:44,158
ultimate goal is to actually have it to

946
00:32:41,919 --> 00:32:46,640
be used as a mitigation

947
00:32:44,159 --> 00:32:48,720
so in in that context then one of the

948
00:32:46,640 --> 00:32:49,279
one of the early slides you had talking

949
00:32:48,720 --> 00:32:51,679
about

950
00:32:49,279 --> 00:32:53,519
um how the tagging works and the

951
00:32:51,679 --> 00:32:54,640
limitations of what you can actually put

952
00:32:53,519 --> 00:32:57,360
in the tag size

953
00:32:54,640 --> 00:32:58,159
it became somewhat probabilistic am i

954
00:32:57,360 --> 00:33:00,879
right

955
00:32:58,159 --> 00:33:01,279
correct correct so so if you think about

956
00:33:00,880 --> 00:33:02,960
you know

957
00:33:01,279 --> 00:33:05,279
probabilistic defenses of course are

958
00:33:02,960 --> 00:33:07,120
useful aslr is tremendously

959
00:33:05,279 --> 00:33:09,440
useful but there are ways of getting

960
00:33:07,120 --> 00:33:10,799
around asr by just trying lots and lots

961
00:33:09,440 --> 00:33:12,559
of times

962
00:33:10,799 --> 00:33:13,918
do you see similar sorts of issues here

963
00:33:12,559 --> 00:33:15,279
or is some or is it the fact that this

964
00:33:13,919 --> 00:33:17,360
would be in the kernel

965
00:33:15,279 --> 00:33:18,720
make it less so because it would it's

966
00:33:17,360 --> 00:33:21,918
not scalable to try

967
00:33:18,720 --> 00:33:21,919
as many times as you would need

968
00:33:22,080 --> 00:33:26,320
yes so there are of course the

969
00:33:24,880 --> 00:33:29,360
probabilistic nature of

970
00:33:26,320 --> 00:33:30,799
mte makes it possible to bypass in

971
00:33:29,360 --> 00:33:32,559
certain cases

972
00:33:30,799 --> 00:33:34,000
and the initial version that we will

973
00:33:32,559 --> 00:33:36,720
have will probably

974
00:33:34,000 --> 00:33:38,000
i mean be vulnerable to those and again

975
00:33:36,720 --> 00:33:39,840
i'm going to split it into parts

976
00:33:38,000 --> 00:33:41,279
first of all about the probabilistic

977
00:33:39,840 --> 00:33:42,959
nature so

978
00:33:41,279 --> 00:33:44,720
there are some modifications that you

979
00:33:42,960 --> 00:33:46,320
can do to memory tagging to make sure

980
00:33:44,720 --> 00:33:49,200
that certain bug classes

981
00:33:46,320 --> 00:33:51,200
are detected with 100 probability for

982
00:33:49,200 --> 00:33:54,720
example what i've mentioned with

983
00:33:51,200 --> 00:33:56,559
assigning different tags to

984
00:33:54,720 --> 00:33:57,919
memory objects that are next to each

985
00:33:56,559 --> 00:33:59,440
other in memory and you can just make

986
00:33:57,919 --> 00:34:01,600
sure that the tags are different you

987
00:33:59,440 --> 00:34:02,720
for example you can keep generating a

988
00:34:01,600 --> 00:34:04,799
new random tag

989
00:34:02,720 --> 00:34:07,120
until you get a tag that is different

990
00:34:04,799 --> 00:34:10,000
from the ones that are around those

991
00:34:07,120 --> 00:34:11,839
right for use of the freeze there is

992
00:34:10,000 --> 00:34:13,599
actually discussion right now

993
00:34:11,839 --> 00:34:15,839
it's mostly being discussed for user

994
00:34:13,599 --> 00:34:17,440
space mte i'm not sure if this will be

995
00:34:15,839 --> 00:34:19,918
applicable to the kernel

996
00:34:17,440 --> 00:34:20,480
it's about so those who are interested

997
00:34:19,918 --> 00:34:23,520
you can

998
00:34:20,480 --> 00:34:24,240
search for a mark us paper it's called

999
00:34:23,520 --> 00:34:27,440
like mark

1000
00:34:24,239 --> 00:34:27,439
us and

1001
00:34:27,520 --> 00:34:31,440
so i'm not going to go into details but

1002
00:34:29,839 --> 00:34:33,440
the idea is that there is an approach

1003
00:34:31,440 --> 00:34:36,240
that will actually allow you to

1004
00:34:33,440 --> 00:34:38,399
detect use of the freeze with something

1005
00:34:36,239 --> 00:34:40,799
very very close to 100 percent

1006
00:34:38,399 --> 00:34:43,118
probability maybe even 100 and without

1007
00:34:40,800 --> 00:34:46,320
any additional impact

1008
00:34:43,119 --> 00:34:49,919
and when it comes to the kernel actually

1009
00:34:46,320 --> 00:34:51,839
bypassing mte when exploiting bug

1010
00:34:49,918 --> 00:34:53,199
will be when we have empty will be very

1011
00:34:51,839 --> 00:34:56,560
interesting topic

1012
00:34:53,199 --> 00:35:00,319
for research and in kernel work

1013
00:34:56,560 --> 00:35:00,320
of course of course have less

1014
00:35:00,400 --> 00:35:03,520
flexibility in terms of that we cannot

1015
00:35:02,240 --> 00:35:05,359
retry

1016
00:35:03,520 --> 00:35:06,720
to exploit a particular box hundred

1017
00:35:05,359 --> 00:35:08,480
times because the first time kernel

1018
00:35:06,720 --> 00:35:11,279
crashes it's just gonna crash

1019
00:35:08,480 --> 00:35:13,520
it's not a easier space process a user

1020
00:35:11,280 --> 00:35:14,800
space daemon that will just be restarted

1021
00:35:13,520 --> 00:35:16,640
right so in this case attacking the

1022
00:35:14,800 --> 00:35:19,760
kernel is harder

1023
00:35:16,640 --> 00:35:22,879
and what i remember is that one of the

1024
00:35:19,760 --> 00:35:25,280
talks of jan horn who is also

1025
00:35:22,880 --> 00:35:27,040
who is a project zero security

1026
00:35:25,280 --> 00:35:27,920
researcher that works in linux kernel he

1027
00:35:27,040 --> 00:35:32,480
actually mentioned

1028
00:35:27,920 --> 00:35:35,040
that a particular way that

1029
00:35:32,480 --> 00:35:36,560
a user might be able to extract tags

1030
00:35:35,040 --> 00:35:38,720
from the kernel and by using a

1031
00:35:36,560 --> 00:35:40,880
particular syscall that allows

1032
00:35:38,720 --> 00:35:42,399
you to predict whether two regions of

1033
00:35:40,880 --> 00:35:44,000
memory actually

1034
00:35:42,400 --> 00:35:45,839
have the same tag so there are going to

1035
00:35:44,000 --> 00:35:48,880
be attacks like that for sure

1036
00:35:45,839 --> 00:35:49,680
and the probabilistic nature of mt of

1037
00:35:48,880 --> 00:35:53,440
course makes it

1038
00:35:49,680 --> 00:35:54,399
not 100 not 100 protection from

1039
00:35:53,440 --> 00:35:57,040
everything

1040
00:35:54,400 --> 00:35:59,359
but my understanding based on my

1041
00:35:57,040 --> 00:36:02,000
experiences writing current exploits

1042
00:35:59,359 --> 00:36:04,560
is that this is going to make writing

1043
00:36:02,000 --> 00:36:08,079
kernel exploits an order of magnitude

1044
00:36:04,560 --> 00:36:10,560
harder or maybe even more that's awesome

1045
00:36:08,079 --> 00:36:11,520
uh so we've got a question on on

1046
00:36:10,560 --> 00:36:13,119
mattermost

1047
00:36:11,520 --> 00:36:14,960
um kind of two-part question the first

1048
00:36:13,119 --> 00:36:16,400
part uh might be the conference

1049
00:36:14,960 --> 00:36:18,480
organization organizers but

1050
00:36:16,400 --> 00:36:19,440
whether the the slides will will be

1051
00:36:18,480 --> 00:36:21,680
available

1052
00:36:19,440 --> 00:36:22,640
yes i will publish them on twitter in

1053
00:36:21,680 --> 00:36:24,879
like 10 minutes

1054
00:36:22,640 --> 00:36:26,560
after the end right and then the second

1055
00:36:24,880 --> 00:36:27,760
question which um

1056
00:36:26,560 --> 00:36:29,680
you touched on a little bit kind of

1057
00:36:27,760 --> 00:36:31,200
informally but um

1058
00:36:29,680 --> 00:36:33,040
i think the question of more specific

1059
00:36:31,200 --> 00:36:34,879
martin's asking what the expected

1060
00:36:33,040 --> 00:36:36,800
overhead for hardware implementation is

1061
00:36:34,880 --> 00:36:38,560
on a mobile device

1062
00:36:36,800 --> 00:36:40,400
yeah it's a good question before we have

1063
00:36:38,560 --> 00:36:43,359
the actual hardware implementation

1064
00:36:40,400 --> 00:36:44,160
no one knows yet but the expectation is

1065
00:36:43,359 --> 00:36:46,799
to have it

1066
00:36:44,160 --> 00:36:47,839
in like it's usually been expressed as a

1067
00:36:46,800 --> 00:36:50,160
single digit

1068
00:36:47,839 --> 00:36:52,839
percent impact something like this so

1069
00:36:50,160 --> 00:36:55,520
it's less than ten percent

1070
00:36:52,839 --> 00:36:57,200
okay all right well excellent talk and

1071
00:36:55,520 --> 00:36:58,079
and thank you for all the the answers to

1072
00:36:57,200 --> 00:37:00,560
the questions

1073
00:36:58,079 --> 00:37:02,079
um i think that concludes well first

1074
00:37:00,560 --> 00:37:09,839
virtual round of applause for

1075
00:37:02,079 --> 00:37:09,839
for andre a wonderful talk

1076
00:37:23,680 --> 00:37:25,759
you

