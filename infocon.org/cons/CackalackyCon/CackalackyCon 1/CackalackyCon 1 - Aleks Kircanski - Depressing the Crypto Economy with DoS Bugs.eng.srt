1
00:00:00,000 --> 00:00:03,540
so yeah yeah I'm Alex I'm gonna talk

2
00:00:02,280 --> 00:00:09,660
about hacking how to hack a

3
00:00:03,540 --> 00:00:11,700
cryptocurrency client so what are what

4
00:00:09,660 --> 00:00:13,320
I'm going to cover here is first I'm

5
00:00:11,700 --> 00:00:15,629
going to talk about like what the

6
00:00:13,320 --> 00:00:18,690
typical Satoshi blockchain client looks

7
00:00:15,630 --> 00:00:20,789
like what's in there then I'm going to

8
00:00:18,690 --> 00:00:23,400
talk about most common security issue

9
00:00:20,789 --> 00:00:26,330
types for this type of clients and then

10
00:00:23,400 --> 00:00:28,890
I'm going to kind of go in detail

11
00:00:26,330 --> 00:00:31,709
talking about some netsplit and fork

12
00:00:28,890 --> 00:00:33,660
attacks that happen in Bitcoin and also

13
00:00:31,710 --> 00:00:37,710
talk about some application level dos

14
00:00:33,660 --> 00:00:40,050
issues if there is time so yeah I'm not

15
00:00:37,710 --> 00:00:42,780
going to talk about a smart contract

16
00:00:40,050 --> 00:00:44,849
hacking I'm not going to come talk about

17
00:00:42,780 --> 00:00:47,160
that privacy-preserving crypto such as

18
00:00:44,850 --> 00:00:49,620
stuff like a crypto in Z cash and Mon

19
00:00:47,160 --> 00:00:51,660
error and stuff like that and I'm not

20
00:00:49,620 --> 00:00:54,030
going to talk about the alternative

21
00:00:51,660 --> 00:00:55,949
consensus algorithms there is now race

22
00:00:54,030 --> 00:00:59,670
who is going to make a scalable

23
00:00:55,949 --> 00:01:02,399
blockchain basically many transactions

24
00:00:59,670 --> 00:01:04,439
per second that's the goal so what's the

25
00:01:02,399 --> 00:01:07,619
goal here of this presentation really is

26
00:01:04,438 --> 00:01:09,600
to provide an idea what basic blockchain

27
00:01:07,619 --> 00:01:11,700
vulnerabilities look like so this is a

28
00:01:09,600 --> 00:01:14,339
time machine I'm going back 11 years ago

29
00:01:11,700 --> 00:01:17,340
or maybe not 11 but maybe six or seven

30
00:01:14,340 --> 00:01:20,400
when Satoshi published his paper in 2008

31
00:01:17,340 --> 00:01:22,470
and then the community found some bugs

32
00:01:20,400 --> 00:01:24,900
and they keep on repeating so that's the

33
00:01:22,470 --> 00:01:27,360
goal here so if you want to audit a

34
00:01:24,900 --> 00:01:28,860
blockchain software this presentation I

35
00:01:27,360 --> 00:01:31,500
hope is going to be helpful or if you

36
00:01:28,860 --> 00:01:34,970
want to implement a Satoshi client or

37
00:01:31,500 --> 00:01:38,970
some new generation blockchain client

38
00:01:34,970 --> 00:01:40,679
yeah so yeah as some people seem to

39
00:01:38,970 --> 00:01:41,908
think that aliens have created Bitcoin

40
00:01:40,680 --> 00:01:46,049
it's fun

41
00:01:41,909 --> 00:01:47,189
in October 2008 it was published that

42
00:01:46,049 --> 00:01:50,880
the paper was published and the

43
00:01:47,189 --> 00:01:54,059
implementation came three months later

44
00:01:50,880 --> 00:01:57,149
it was only for Windows but then I think

45
00:01:54,060 --> 00:01:59,960
about six or seven minutes not minutes

46
00:01:57,149 --> 00:02:02,460
but the years not years but months later

47
00:01:59,960 --> 00:02:05,100
it got ported to Linux

48
00:02:02,460 --> 00:02:08,038
so was the idea here the idea is to have

49
00:02:05,100 --> 00:02:11,060
electronic cash without any central

50
00:02:08,038 --> 00:02:13,359
authority or any financial institution

51
00:02:11,060 --> 00:02:16,300
so if someone wants this

52
00:02:13,360 --> 00:02:20,110
for a system it's kind of natural to try

53
00:02:16,300 --> 00:02:21,490
with a peer-to-peer network so what's

54
00:02:20,110 --> 00:02:23,860
really the main question that the

55
00:02:21,490 --> 00:02:25,740
Bitcoin people tried to answer is how

56
00:02:23,860 --> 00:02:28,390
can notes in a peer-to-peer network

57
00:02:25,740 --> 00:02:33,340
established a synchronized view of the

58
00:02:28,390 --> 00:02:36,399
ledger and essentially the main novel

59
00:02:33,340 --> 00:02:39,010
idea in the Bitcoin paper was how to

60
00:02:36,400 --> 00:02:42,970
establish consensus we had the proof of

61
00:02:39,010 --> 00:02:45,700
work concept so plug in proof of concept

62
00:02:42,970 --> 00:02:51,100
for the purpose of synchronized

63
00:02:45,700 --> 00:02:54,280
synchronizing the ledger so over the

64
00:02:51,100 --> 00:02:55,680
last 11 years the Bitcoin community did

65
00:02:54,280 --> 00:02:58,480
a huge amount of work

66
00:02:55,680 --> 00:03:01,239
so they maintained and refactor the code

67
00:02:58,480 --> 00:03:03,100
change existing features and added new

68
00:03:01,239 --> 00:03:05,560
ones and also uncovered a fixed number

69
00:03:03,100 --> 00:03:07,900
of important security issues the

70
00:03:05,560 --> 00:03:10,930
original Satoshi implementation was

71
00:03:07,900 --> 00:03:15,370
solid but still there is a bunch of

72
00:03:10,930 --> 00:03:17,590
issues that got uncovered so if you're

73
00:03:15,370 --> 00:03:20,709
auditing or implementing a blockchain

74
00:03:17,590 --> 00:03:23,080
client it makes sense to kind of process

75
00:03:20,709 --> 00:03:26,769
what happened in the Bitcoin in Bitcoin

76
00:03:23,080 --> 00:03:29,320
in last 11 years to rely on their

77
00:03:26,769 --> 00:03:32,670
experience and to avoid the same things

78
00:03:29,320 --> 00:03:36,310
because these things keep on repeating

79
00:03:32,670 --> 00:03:38,920
so if we try to kind of look at what's

80
00:03:36,310 --> 00:03:41,019
happening in this area it's really you

81
00:03:38,920 --> 00:03:43,320
know there is a lot of implementations

82
00:03:41,019 --> 00:03:46,000
but we could come up with some criteria

83
00:03:43,320 --> 00:03:48,549
how to differentiate if we take a like a

84
00:03:46,000 --> 00:03:50,700
random block train project out there at

85
00:03:48,549 --> 00:03:53,320
least some features we can definitely

86
00:03:50,700 --> 00:03:55,000
discern what this is about so it could

87
00:03:53,320 --> 00:03:58,390
be a permission or permissionless

88
00:03:55,000 --> 00:04:01,390
blockchain if it's permission one that's

89
00:03:58,390 --> 00:04:03,640
typically aimed to be deployed inside

90
00:04:01,390 --> 00:04:06,190
banks or some kind of financial

91
00:04:03,640 --> 00:04:09,339
institutions and all nodes authenticate

92
00:04:06,190 --> 00:04:12,070
each other and oftentimes this is

93
00:04:09,340 --> 00:04:13,959
actually centralized system where there

94
00:04:12,070 --> 00:04:17,260
is one central authority with some

95
00:04:13,959 --> 00:04:19,298
accountability to to its clients so this

96
00:04:17,260 --> 00:04:21,608
is actually usually not Satoshi

97
00:04:19,298 --> 00:04:24,400
blockchain there is no proof of work and

98
00:04:21,608 --> 00:04:26,320
there is no decentralization in the

99
00:04:24,400 --> 00:04:30,400
degree there is in blocking in

100
00:04:26,320 --> 00:04:31,980
shriyak train so then we can take a look

101
00:04:30,400 --> 00:04:34,840
at what kind of smart contract

102
00:04:31,980 --> 00:04:37,930
capabilities this is an imaginary

103
00:04:34,840 --> 00:04:39,489
product we were looking at has so it

104
00:04:37,930 --> 00:04:41,770
will have a Turing complete language so

105
00:04:39,490 --> 00:04:46,630
this this would be a theorem for example

106
00:04:41,770 --> 00:04:48,460
or you have it have a kind of minimally

107
00:04:46,630 --> 00:04:50,860
expressive or in expressive smell

108
00:04:48,460 --> 00:04:52,870
contract language which is aimed to be

109
00:04:50,860 --> 00:04:55,000
secure but it's not really expressive so

110
00:04:52,870 --> 00:04:57,970
this will be Bitcoin and nowadays it

111
00:04:55,000 --> 00:04:59,860
seems that like the trend is to try to

112
00:04:57,970 --> 00:05:02,320
aim between these two not have a Turing

113
00:04:59,860 --> 00:05:06,700
complete language but have something

114
00:05:02,320 --> 00:05:08,050
really kind of in between these two and

115
00:05:06,700 --> 00:05:09,969
also then we could ask what's the

116
00:05:08,050 --> 00:05:11,590
consensus algorithm the nodes are using

117
00:05:09,970 --> 00:05:14,500
so this could be for example proof of

118
00:05:11,590 --> 00:05:16,960
work or proof of stake or some kind of

119
00:05:14,500 --> 00:05:19,480
adaptation on Byzantine fault tolerance

120
00:05:16,960 --> 00:05:22,060
algorithms this is coming from

121
00:05:19,480 --> 00:05:24,160
distributed systems research and the

122
00:05:22,060 --> 00:05:26,800
main problem there it it does not scale

123
00:05:24,160 --> 00:05:29,560
to many nodes and then the scalable

124
00:05:26,800 --> 00:05:32,140
blockchain solutions that are racing to

125
00:05:29,560 --> 00:05:33,850
deliver and all blockchain solution are

126
00:05:32,140 --> 00:05:37,659
kind of trying to adapt on this and

127
00:05:33,850 --> 00:05:39,430
change DFT algorithms to scale and also

128
00:05:37,660 --> 00:05:45,610
we could ask if it has fancy crypto

129
00:05:39,430 --> 00:05:49,090
inside such as easy cash or manera so

130
00:05:45,610 --> 00:05:52,750
now when it comes to security

131
00:05:49,090 --> 00:05:54,669
researchers let's take a look how well

132
00:05:52,750 --> 00:05:56,980
researched are are these types of

133
00:05:54,670 --> 00:05:59,800
products so permission blockchain there

134
00:05:56,980 --> 00:06:02,200
is zero research most likely so these

135
00:05:59,800 --> 00:06:04,060
projects aren't many of them are not

136
00:06:02,200 --> 00:06:06,550
finished yet they are still being

137
00:06:04,060 --> 00:06:09,360
developed most of them are not open

138
00:06:06,550 --> 00:06:12,340
source this is proprietary software and

139
00:06:09,360 --> 00:06:15,610
really the security of the systems is

140
00:06:12,340 --> 00:06:17,580
not well understood on the other end

141
00:06:15,610 --> 00:06:20,380
smart control hacking is quite popular

142
00:06:17,580 --> 00:06:22,060
lots of companies offer smart contract

143
00:06:20,380 --> 00:06:24,690
review as a service so it's a kind of

144
00:06:22,060 --> 00:06:28,030
niche consulting area smart contract

145
00:06:24,690 --> 00:06:29,740
review there is also static analysis

146
00:06:28,030 --> 00:06:34,690
tools which are supposed to do this

147
00:06:29,740 --> 00:06:37,540
automatically and then if we take a look

148
00:06:34,690 --> 00:06:39,469
at what consensus implemented like how

149
00:06:37,540 --> 00:06:41,330
well understood

150
00:06:39,470 --> 00:06:42,950
since implementation issues well they're

151
00:06:41,330 --> 00:06:46,099
understood very well by by by the

152
00:06:42,950 --> 00:06:48,950
Bitcoin community but as for security

153
00:06:46,100 --> 00:06:53,210
researchers it's kind of under research

154
00:06:48,950 --> 00:06:59,450
that I would say so yeah maybe this gap

155
00:06:53,210 --> 00:07:01,190
should be filled yeah um so let's take a

156
00:06:59,450 --> 00:07:03,320
look kind of mechanically what does a

157
00:07:01,190 --> 00:07:06,290
blockchain client do Satoshi blockchain

158
00:07:03,320 --> 00:07:11,060
so it listens on the network for new

159
00:07:06,290 --> 00:07:14,360
protocol messages typically this is not

160
00:07:11,060 --> 00:07:18,320
something like REST API it's more

161
00:07:14,360 --> 00:07:21,260
usually some kind of custom protocol it

162
00:07:18,320 --> 00:07:23,900
ingests transactions and blocks so node

163
00:07:21,260 --> 00:07:26,180
sends send transactions and block blocks

164
00:07:23,900 --> 00:07:29,270
to each other and each node validates

165
00:07:26,180 --> 00:07:32,020
them they store a copy of the ledger

166
00:07:29,270 --> 00:07:35,840
basically who owns what at the moment

167
00:07:32,020 --> 00:07:40,969
they contain capability to mine new

168
00:07:35,840 --> 00:07:45,710
blocks and they do that if they're full

169
00:07:40,970 --> 00:07:48,110
nodes and also they try to be in sync

170
00:07:45,710 --> 00:07:51,229
with other nodes they every node would

171
00:07:48,110 --> 00:07:52,940
like it should see the same ledger as

172
00:07:51,230 --> 00:07:55,040
other and also so there is this

173
00:07:52,940 --> 00:07:56,840
distributed idea of what the current

174
00:07:55,040 --> 00:07:58,060
ladder is and it's kind of consistent

175
00:07:56,840 --> 00:08:00,619
over all nodes

176
00:07:58,060 --> 00:08:03,080
yeah so this is a complicated list of

177
00:08:00,620 --> 00:08:05,780
tasks and if someone tries to do all

178
00:08:03,080 --> 00:08:10,340
this it's it's likely that some mistakes

179
00:08:05,780 --> 00:08:12,169
will creep in so if we take a look in a

180
00:08:10,340 --> 00:08:14,599
little bit more detail what what a

181
00:08:12,169 --> 00:08:18,620
blockchain client had does it have well

182
00:08:14,600 --> 00:08:20,780
the state it keeps is the it wants to

183
00:08:18,620 --> 00:08:24,320
keep the ledger obviously who owns what

184
00:08:20,780 --> 00:08:27,830
and it keeps blocks so there are blocks

185
00:08:24,320 --> 00:08:29,540
blocks contain transactions each

186
00:08:27,830 --> 00:08:31,880
transaction so for example there may be

187
00:08:29,540 --> 00:08:34,099
a truck actually this is B 2 should be B

188
00:08:31,880 --> 00:08:39,169
3 before so it transaction actually

189
00:08:34,099 --> 00:08:42,560
points to transaction whose coins it

190
00:08:39,169 --> 00:08:44,300
spends so yeah transactions point to

191
00:08:42,559 --> 00:08:47,180
previous transactions and each block

192
00:08:44,300 --> 00:08:49,010
points to a previous block so this is

193
00:08:47,180 --> 00:08:50,900
the sequence of blocks and the ledger is

194
00:08:49,010 --> 00:08:52,100
actually what's currently the

195
00:08:50,900 --> 00:08:56,329
transactions that

196
00:08:52,100 --> 00:09:02,120
not been spent yet so that's our ledger

197
00:08:56,330 --> 00:09:05,630
essentially so now since since the nodes

198
00:09:02,120 --> 00:09:08,810
can actually everyone can pose blocks in

199
00:09:05,630 --> 00:09:11,630
this network there is no nothing to

200
00:09:08,810 --> 00:09:13,790
enforce that the blockchain will look

201
00:09:11,630 --> 00:09:17,330
like venner like a line in this picture

202
00:09:13,790 --> 00:09:20,329
in fact participants can can post these

203
00:09:17,330 --> 00:09:21,920
blocks and have multiple blocks pointing

204
00:09:20,330 --> 00:09:26,480
to one previous lock

205
00:09:21,920 --> 00:09:28,339
so actually nodes keep to keep a block

206
00:09:26,480 --> 00:09:31,370
tree they end up keeping a block tree

207
00:09:28,340 --> 00:09:34,670
not just the blockchain and for each

208
00:09:31,370 --> 00:09:37,940
node the blockchain actually the ledger

209
00:09:34,670 --> 00:09:43,550
is a branch from the Genesis block to

210
00:09:37,940 --> 00:09:45,620
one of the Leafs and now if that's that

211
00:09:43,550 --> 00:09:47,199
that that's called kind of the active

212
00:09:45,620 --> 00:09:49,940
branch rakugo that the active range

213
00:09:47,200 --> 00:09:51,350
interior node could also switch to a

214
00:09:49,940 --> 00:09:54,800
different branch for example it would

215
00:09:51,350 --> 00:10:00,350
have before be that the final block here

216
00:09:54,800 --> 00:10:02,990
and Genesis b1 b3 and before so now when

217
00:10:00,350 --> 00:10:05,330
it comes to this block tree if we assume

218
00:10:02,990 --> 00:10:07,150
that all nodes in network see the same

219
00:10:05,330 --> 00:10:10,250
block tree so these blocks get

220
00:10:07,150 --> 00:10:12,020
broadcasted and and they should assuming

221
00:10:10,250 --> 00:10:14,330
good network conditions and no major

222
00:10:12,020 --> 00:10:16,310
discrepancies in the state and

223
00:10:14,330 --> 00:10:18,980
implementation of the nodes all of the

224
00:10:16,310 --> 00:10:23,030
nodes should see the same block tree the

225
00:10:18,980 --> 00:10:26,150
question really is how do we decide

226
00:10:23,030 --> 00:10:29,390
what's the active branch what's really

227
00:10:26,150 --> 00:10:35,600
the the ledger that we kind of believe

228
00:10:29,390 --> 00:10:38,960
in currently so we need to come up with

229
00:10:35,600 --> 00:10:40,460
a criterion what is going to be the

230
00:10:38,960 --> 00:10:43,160
ledger from us from all these branches

231
00:10:40,460 --> 00:10:45,740
and this criterion should be resistant

232
00:10:43,160 --> 00:10:48,290
to manipulation so I should not be able

233
00:10:45,740 --> 00:10:50,870
to make notes kind of arbitrarily switch

234
00:10:48,290 --> 00:10:53,120
branches in a block tree because then

235
00:10:50,870 --> 00:10:56,660
I'm going to change the view of all the

236
00:10:53,120 --> 00:10:58,730
luxuries for other nodes so switching

237
00:10:56,660 --> 00:11:02,360
granters in this block tree should be

238
00:10:58,730 --> 00:11:04,130
should be somehow controlled then this

239
00:11:02,360 --> 00:11:05,990
is the reason also is to prevent the

240
00:11:04,130 --> 00:11:08,270
double spin attack so what's a double

241
00:11:05,990 --> 00:11:10,310
attack all the ideas of a double spam

242
00:11:08,270 --> 00:11:11,959
attack is to create a transaction that's

243
00:11:10,310 --> 00:11:17,540
going to spend some coins in block

244
00:11:11,959 --> 00:11:19,219
before and then revert basically

245
00:11:17,540 --> 00:11:23,089
switched to a different branch and the

246
00:11:19,220 --> 00:11:25,550
transaction gets reverted so in a bit

247
00:11:23,089 --> 00:11:28,640
more detail in Bitcoin we have a six

248
00:11:25,550 --> 00:11:29,990
confirmation rule so the transaction

249
00:11:28,640 --> 00:11:31,939
suppose there is a that there is a

250
00:11:29,990 --> 00:11:37,190
transaction in block a1 which gets

251
00:11:31,940 --> 00:11:39,589
confirmed in block a6 and then that

252
00:11:37,190 --> 00:11:42,320
whoever send the transaction can can

253
00:11:39,589 --> 00:11:44,839
exchange it for goods or services and

254
00:11:42,320 --> 00:11:46,459
then the attacker publishes another

255
00:11:44,839 --> 00:11:49,339
branch which does not contain this

256
00:11:46,459 --> 00:11:51,380
transaction at all and the the effect of

257
00:11:49,339 --> 00:11:54,709
transaction gets nullified and he can

258
00:11:51,380 --> 00:11:58,510
spend his point in this B branch so

259
00:11:54,709 --> 00:11:58,510
that's the idea of a double span attack

260
00:11:59,930 --> 00:12:06,319
yeah so really a lot of the Bitcoin

261
00:12:03,649 --> 00:12:08,870
people motivation is how to defend from

262
00:12:06,320 --> 00:12:11,630
the double span attack how to defend how

263
00:12:08,870 --> 00:12:17,779
to really control switching branches in

264
00:12:11,630 --> 00:12:20,000
this block tree and to come up with the

265
00:12:17,779 --> 00:12:21,680
solution to that the Bitcoin paper

266
00:12:20,000 --> 00:12:25,520
proposes to use the proof-of-work puzzle

267
00:12:21,680 --> 00:12:29,599
so proof of work is just a puzzle that's

268
00:12:25,520 --> 00:12:31,939
easy to verify but difficult to solve so

269
00:12:29,600 --> 00:12:33,410
we can use a hash function to to to

270
00:12:31,940 --> 00:12:37,459
create a proof-of-work puzzle for

271
00:12:33,410 --> 00:12:41,120
example we can ask basically we can

272
00:12:37,459 --> 00:12:42,800
require two to four an input to the hash

273
00:12:41,120 --> 00:12:44,750
function to be found such that the

274
00:12:42,800 --> 00:12:50,630
output has some number of zeros in the

275
00:12:44,750 --> 00:12:53,959
outlet yeah so the Bitcoin idea is

276
00:12:50,630 --> 00:12:56,000
really to kind of control switching

277
00:12:53,959 --> 00:12:57,859
branches making note switching branches

278
00:12:56,000 --> 00:12:59,270
by the proof by leveraging the

279
00:12:57,860 --> 00:13:03,620
proof-of-work puzzle so how does that

280
00:12:59,270 --> 00:13:06,770
work well if someone wants to add the

281
00:13:03,620 --> 00:13:09,740
Block on this block tree then he needs

282
00:13:06,770 --> 00:13:12,410
to solve the proof of work puzzle at the

283
00:13:09,740 --> 00:13:14,930
certain difficulty so now an active

284
00:13:12,410 --> 00:13:17,089
branch will be considered the active

285
00:13:14,930 --> 00:13:18,709
branch the ledger will be considered the

286
00:13:17,089 --> 00:13:22,820
branch with most work

287
00:13:18,710 --> 00:13:24,850
and work so we can kind of calculate how

288
00:13:22,820 --> 00:13:28,580
much work has been put in this branch

289
00:13:24,850 --> 00:13:32,630
and if if that amount of hash work or

290
00:13:28,580 --> 00:13:34,640
proof-of-work puzzle work is more than

291
00:13:32,630 --> 00:13:40,160
than other branches then that's the

292
00:13:34,640 --> 00:13:41,930
active range so now if I want to make

293
00:13:40,160 --> 00:13:43,910
another node switch to a different

294
00:13:41,930 --> 00:13:46,130
branch switch to a different ledger I

295
00:13:43,910 --> 00:13:49,610
will have to attach more blocks here for

296
00:13:46,130 --> 00:13:52,640
example before and then I need to invest

297
00:13:49,610 --> 00:13:55,970
computing power in that and whether I'll

298
00:13:52,640 --> 00:13:59,510
be able to do that depends on how much

299
00:13:55,970 --> 00:14:02,029
computing how much hash power has exists

300
00:13:59,510 --> 00:14:06,140
in in the network overall so this place

301
00:14:02,029 --> 00:14:08,990
is control over how difficult it is to

302
00:14:06,140 --> 00:14:11,149
switch branches in the block tree or how

303
00:14:08,990 --> 00:14:13,850
difficult it is to manipulate the the

304
00:14:11,149 --> 00:14:17,810
other nodes view of what the ledger is

305
00:14:13,850 --> 00:14:21,140
and that's basically the main idea of

306
00:14:17,810 --> 00:14:25,099
the Bitcoin paper I'm so yeah now

307
00:14:21,140 --> 00:14:29,000
zooming out a little bit what do we have

308
00:14:25,100 --> 00:14:33,760
in the Bitcoin series last 11 years so

309
00:14:29,000 --> 00:14:36,350
there is around 30 of them it's kind of

310
00:14:33,760 --> 00:14:37,790
reasonable to say that many of probably

311
00:14:36,350 --> 00:14:40,160
many of the issues that have been found

312
00:14:37,790 --> 00:14:42,500
never made it into series and maybe have

313
00:14:40,160 --> 00:14:44,270
been silently fixed so no one even knows

314
00:14:42,500 --> 00:14:47,000
about them but at least this is some

315
00:14:44,270 --> 00:14:49,490
kind of approximation of what what the

316
00:14:47,000 --> 00:14:51,400
bugs looked like in Bitcoin so there

317
00:14:49,490 --> 00:14:54,320
were 14 dos attacks

318
00:14:51,400 --> 00:14:56,240
so in dos attacks this would be kind of

319
00:14:54,320 --> 00:14:59,930
occation security dos attacks meaning

320
00:14:56,240 --> 00:15:07,490
for example crashes due to a division by

321
00:14:59,930 --> 00:15:10,699
zero or some assertion fails our or CPU

322
00:15:07,490 --> 00:15:12,380
exhaustion so someone sent some kind of

323
00:15:10,700 --> 00:15:14,720
you know block to a node and the node

324
00:15:12,380 --> 00:15:19,220
end up processing it forever and cannot

325
00:15:14,720 --> 00:15:21,260
ever stop processing it also memory

326
00:15:19,220 --> 00:15:25,279
memory filling out the memory of nodes

327
00:15:21,260 --> 00:15:27,319
stuff like that yeah so then there is

328
00:15:25,279 --> 00:15:28,960
net split attack so net split attack

329
00:15:27,320 --> 00:15:31,450
would be when

330
00:15:28,960 --> 00:15:34,270
one part of the nodes of the network see

331
00:15:31,450 --> 00:15:37,240
one letter or active rent and the other

332
00:15:34,270 --> 00:15:38,860
part of the note see had another branch

333
00:15:37,240 --> 00:15:42,310
so what we're going to go into detail

334
00:15:38,860 --> 00:15:44,110
with that there is theft attack so theft

335
00:15:42,310 --> 00:15:46,089
would be something like it could be

336
00:15:44,110 --> 00:15:50,200
there theft on the blockchain itself

337
00:15:46,089 --> 00:15:52,209
meaning that the the during validation

338
00:15:50,200 --> 00:15:54,430
simply the blockchain accepts invalid

339
00:15:52,209 --> 00:15:57,880
transactions and for example creates

340
00:15:54,430 --> 00:16:01,870
coins out of nothing or it could be some

341
00:15:57,880 --> 00:16:03,520
localhost API in wallet issues and there

342
00:16:01,870 --> 00:16:05,830
are also some others such as inflation

343
00:16:03,520 --> 00:16:07,899
that's actually interesting inflation is

344
00:16:05,830 --> 00:16:10,360
when you create coins out of nothing and

345
00:16:07,899 --> 00:16:12,730
then the value of the coins drops and

346
00:16:10,360 --> 00:16:15,450
stuff like that so I'm going to talk

347
00:16:12,730 --> 00:16:18,550
about netsplit attack night attacks next

348
00:16:15,450 --> 00:16:21,339
actually before that so yeah this is the

349
00:16:18,550 --> 00:16:24,310
Bitcoin TV list and if we kind of try to

350
00:16:21,339 --> 00:16:28,470
not only focus on Bitcoin and can try to

351
00:16:24,310 --> 00:16:31,149
come up with like Oh was top five of

352
00:16:28,470 --> 00:16:32,920
vulnerabilities in in kind of Satoshi

353
00:16:31,149 --> 00:16:35,279
blockchain implementation not only

354
00:16:32,920 --> 00:16:38,260
Satoshi sorry not only Bitcoin but

355
00:16:35,279 --> 00:16:42,760
whichever other coins are similar to

356
00:16:38,260 --> 00:16:44,890
Satoshi blockchain this could be the top

357
00:16:42,760 --> 00:16:50,860
five list so let's start from the last

358
00:16:44,890 --> 00:16:53,319
one local host wallet API issues if I

359
00:16:50,860 --> 00:16:56,920
run like a real kind of harvester any

360
00:16:53,320 --> 00:17:00,279
any coin no to client it's likely going

361
00:16:56,920 --> 00:17:03,520
to open a local host wallet API for

362
00:17:00,279 --> 00:17:06,520
managing the wallet and issues around

363
00:17:03,520 --> 00:17:07,569
here our lack of authentication course

364
00:17:06,520 --> 00:17:10,389
Heather issues

365
00:17:07,569 --> 00:17:12,159
C surf and stuff like that cross-site

366
00:17:10,390 --> 00:17:15,220
request forgery and this type of attacks

367
00:17:12,160 --> 00:17:19,990
then there is a website and Network API

368
00:17:15,220 --> 00:17:21,939
issues so this is all possible issues

369
00:17:19,990 --> 00:17:23,910
that come with app sack so it could be

370
00:17:21,939 --> 00:17:26,650
memory corruption denial of service

371
00:17:23,910 --> 00:17:29,250
serialization deserialization problems

372
00:17:26,650 --> 00:17:31,900
and so on

373
00:17:29,250 --> 00:17:34,000
improper timestamp validation so in

374
00:17:31,900 --> 00:17:37,000
proper time servant validation every

375
00:17:34,000 --> 00:17:40,210
block has a timestamp and why is that

376
00:17:37,000 --> 00:17:42,160
well it's your time stamps inside blocks

377
00:17:40,210 --> 00:17:45,640
are used to control the

378
00:17:42,160 --> 00:17:48,310
difficulty of mining if blocks come in

379
00:17:45,640 --> 00:17:50,920
too often then this means that the

380
00:17:48,310 --> 00:17:53,230
difficulty of mining is should be

381
00:17:50,920 --> 00:17:56,980
increased and that's why every block has

382
00:17:53,230 --> 00:17:58,840
a time stamp and now when nodes are

383
00:17:56,980 --> 00:18:01,270
processing blocks they need to validate

384
00:17:58,840 --> 00:18:04,050
this time stamp and this well it's not

385
00:18:01,270 --> 00:18:07,960
super hard it's not trivial either and

386
00:18:04,050 --> 00:18:09,960
coins routinely get this wrong and they

387
00:18:07,960 --> 00:18:13,060
just do a kind of very kind of you know

388
00:18:09,960 --> 00:18:16,450
first thing that comes to mind time

389
00:18:13,060 --> 00:18:18,550
stamp validation instead of that they

390
00:18:16,450 --> 00:18:20,950
should look how Bitcoin or aetherium do

391
00:18:18,550 --> 00:18:23,409
it and n do it that way and this results

392
00:18:20,950 --> 00:18:28,030
in netsplit also chain wedging and

393
00:18:23,410 --> 00:18:32,190
mining difficulty manipulation it's kind

394
00:18:28,030 --> 00:18:34,810
of a bug that's easy to find yeah

395
00:18:32,190 --> 00:18:38,170
there's also integer under flow and

396
00:18:34,810 --> 00:18:40,179
overflow it's very common so transaction

397
00:18:38,170 --> 00:18:42,730
amount arithmetics when when nodes are

398
00:18:40,180 --> 00:18:45,820
evaluating transactions they need to add

399
00:18:42,730 --> 00:18:49,200
or subtract some kind of number

400
00:18:45,820 --> 00:18:52,510
representation such as integers or and

401
00:18:49,200 --> 00:18:57,900
also if there is an ocean of gas in the

402
00:18:52,510 --> 00:19:01,060
coin then the same holds for that and

403
00:18:57,900 --> 00:19:03,160
integer under flow and overflow do

404
00:19:01,060 --> 00:19:05,020
things like they allow creating

405
00:19:03,160 --> 00:19:06,730
buildings of coins out of small

406
00:19:05,020 --> 00:19:10,480
transactions and stuff like that so

407
00:19:06,730 --> 00:19:13,180
they're very bad and there is net split

408
00:19:10,480 --> 00:19:15,840
attacks so this is when the view of the

409
00:19:13,180 --> 00:19:18,640
ledger gets split across the nodes so

410
00:19:15,840 --> 00:19:21,129
there are several is reasons it could be

411
00:19:18,640 --> 00:19:23,590
unintentional soft or hard fork so if

412
00:19:21,130 --> 00:19:25,240
I'm updating the client that I have

413
00:19:23,590 --> 00:19:26,830
already used in the network and the

414
00:19:25,240 --> 00:19:30,130
whole network is supposed to update it

415
00:19:26,830 --> 00:19:31,870
then an unintentional fork will be

416
00:19:30,130 --> 00:19:33,940
something like I'm not expecting the

417
00:19:31,870 --> 00:19:36,729
concept in the consensus rules to be

418
00:19:33,940 --> 00:19:39,160
changed and yet they do change and then

419
00:19:36,730 --> 00:19:41,680
some nodes that have not updated can

420
00:19:39,160 --> 00:19:47,380
process my transactions and there is a

421
00:19:41,680 --> 00:19:49,360
net plate as a consequence now yeah

422
00:19:47,380 --> 00:19:52,150
there's other reason so we'll go in

423
00:19:49,360 --> 00:19:55,459
detail through the block transaction has

424
00:19:52,150 --> 00:19:57,290
poisoning and Merkle three issues

425
00:19:55,460 --> 00:19:59,330
yes so this is the net plate conditions

426
00:19:57,290 --> 00:20:02,210
how could it happen

427
00:19:59,330 --> 00:20:04,639
I suppose the tip of the blockchain is

428
00:20:02,210 --> 00:20:08,840
block X zero so there is no net split

429
00:20:04,640 --> 00:20:12,740
until block at X 0 and then comes in a 1

430
00:20:08,840 --> 00:20:14,990
and and some blocks after a 1 and they

431
00:20:12,740 --> 00:20:18,770
get valuated and integrated into the

432
00:20:14,990 --> 00:20:22,040
chain however due to some reason nodes B

433
00:20:18,770 --> 00:20:23,420
can't really process this block a 1 it

434
00:20:22,040 --> 00:20:25,340
could be they could be in different

435
00:20:23,420 --> 00:20:27,050
state or they may be using like a

436
00:20:25,340 --> 00:20:28,970
different implementation for example a

437
00:20:27,050 --> 00:20:31,580
nodes may be using the C++

438
00:20:28,970 --> 00:20:33,350
implementation and B nodes are using a

439
00:20:31,580 --> 00:20:35,689
Python implementation and then they

440
00:20:33,350 --> 00:20:38,780
don't exactly agree on what a valid

441
00:20:35,690 --> 00:20:41,720
block is so now at this point nodes be

442
00:20:38,780 --> 00:20:43,970
rejected block a1 and as a consequence

443
00:20:41,720 --> 00:20:46,070
they also rejected blockade to a 3 and a

444
00:20:43,970 --> 00:20:48,560
4 and they can't really do anything with

445
00:20:46,070 --> 00:20:51,860
this change so that for them the tip of

446
00:20:48,560 --> 00:20:54,379
the block train is block X 0 and then

447
00:20:51,860 --> 00:20:56,929
since they have mining capabilities they

448
00:20:54,380 --> 00:20:59,690
just mined from X 0 since X 0 is their

449
00:20:56,930 --> 00:21:02,810
last block and then they mined Block B 1

450
00:20:59,690 --> 00:21:05,300
and B 2 and B 3 and they the the the one

451
00:21:02,810 --> 00:21:07,490
part of the nodes is the a chain as the

452
00:21:05,300 --> 00:21:12,190
a nodes and the other part of love

453
00:21:07,490 --> 00:21:17,120
changes the B B blocks and this is the

454
00:21:12,190 --> 00:21:19,040
binos and that there is a split so

455
00:21:17,120 --> 00:21:21,110
another question is like it is the

456
00:21:19,040 --> 00:21:23,270
situation going to self-heal is that

457
00:21:21,110 --> 00:21:27,639
this are all nodes going to start

458
00:21:23,270 --> 00:21:33,889
looking at at the same blockchain or not

459
00:21:27,640 --> 00:21:37,310
so this isn't going to only if chain B

460
00:21:33,890 --> 00:21:39,680
outpaces train a because nodes B can't

461
00:21:37,310 --> 00:21:42,110
really switch to chain a because they

462
00:21:39,680 --> 00:21:44,450
don't accept the a one block however a

463
00:21:42,110 --> 00:21:47,060
nodes a could switch to the same B

464
00:21:44,450 --> 00:21:50,210
because they there's nothing wrong here

465
00:21:47,060 --> 00:21:52,700
it's just the fact that a is stronger

466
00:21:50,210 --> 00:21:55,910
than chain B so if there is more hashing

467
00:21:52,700 --> 00:21:58,700
power in train B then the situation will

468
00:21:55,910 --> 00:22:01,390
heal if not then this plate will be

469
00:21:58,700 --> 00:22:01,390
permanent

470
00:22:02,980 --> 00:22:07,370
so now this netsplit condition looks

471
00:22:05,870 --> 00:22:09,260
like a denial of service condition

472
00:22:07,370 --> 00:22:11,030
that's causing confusion but it's kind

473
00:22:09,260 --> 00:22:13,100
of important to understand that the

474
00:22:11,030 --> 00:22:16,879
netsplit condition actually facilitates

475
00:22:13,100 --> 00:22:19,730
the double spend attack so what's the

476
00:22:16,880 --> 00:22:22,250
general idea how would we execute a

477
00:22:19,730 --> 00:22:25,430
double spin attack in dig in when there

478
00:22:22,250 --> 00:22:27,770
is a net split well execute the

479
00:22:25,430 --> 00:22:29,630
transaction into a wait for confirmation

480
00:22:27,770 --> 00:22:33,470
Oh

481
00:22:29,630 --> 00:22:35,870
could be six blocks for example and then

482
00:22:33,470 --> 00:22:38,510
this chain will be dropped at some point

483
00:22:35,870 --> 00:22:40,760
when when the net heals or there is an

484
00:22:38,510 --> 00:22:43,850
intervention and the transaction that

485
00:22:40,760 --> 00:22:46,940
was spent on on chain a simply

486
00:22:43,850 --> 00:22:52,750
disappears and now it's kind of

487
00:22:46,940 --> 00:22:55,040
nullified however it's not that simple

488
00:22:52,750 --> 00:22:58,130
the assumption is that the same

489
00:22:55,040 --> 00:23:00,050
transaction will not across this this

490
00:22:58,130 --> 00:23:03,770
kind of invisible line here it will not

491
00:23:00,050 --> 00:23:06,560
go to gym B if we executed a transaction

492
00:23:03,770 --> 00:23:08,090
on a on with some nodes what's to

493
00:23:06,560 --> 00:23:12,230
guarantee that it's not going to be

494
00:23:08,090 --> 00:23:13,820
executed on other nodes if we broadcast

495
00:23:12,230 --> 00:23:15,950
at the transaction there is really no

496
00:23:13,820 --> 00:23:20,270
network barrier between these medicinal

497
00:23:15,950 --> 00:23:22,250
so this transaction may likely just you

498
00:23:20,270 --> 00:23:24,379
know move to the chain B as well and get

499
00:23:22,250 --> 00:23:27,320
integrated in Train B so the attacker

500
00:23:24,380 --> 00:23:29,030
doesn't really achieve anything so how

501
00:23:27,320 --> 00:23:31,100
could we try to prevent that if we

502
00:23:29,030 --> 00:23:32,960
broadcast at that transaction then then

503
00:23:31,100 --> 00:23:35,030
this transaction is going to go to the

504
00:23:32,960 --> 00:23:37,220
chain B so we don't want to broadcast it

505
00:23:35,030 --> 00:23:38,899
we could try to bribing some minors to

506
00:23:37,220 --> 00:23:41,300
include that transaction in block a to

507
00:23:38,900 --> 00:23:43,450
for example and not only bribing I think

508
00:23:41,300 --> 00:23:45,889
some minors offer that as a service

509
00:23:43,450 --> 00:23:48,260
maybe I'm wrong there I'm not sure but

510
00:23:45,890 --> 00:23:50,030
you can just ask them to include your

511
00:23:48,260 --> 00:23:53,870
transaction without revealing it to

512
00:23:50,030 --> 00:23:57,530
other nodes however even then if we just

513
00:23:53,870 --> 00:24:01,939
include that transaction in in block a

514
00:23:57,530 --> 00:24:04,790
to the the transaction itself is is

515
00:24:01,940 --> 00:24:06,940
visible and it's it's public and it's

516
00:24:04,790 --> 00:24:10,370
signed by the cryptographic hero of the

517
00:24:06,940 --> 00:24:12,260
originator of the transaction so someone

518
00:24:10,370 --> 00:24:13,909
you know someone from the B Network

519
00:24:12,260 --> 00:24:15,860
could just take that transaction or to

520
00:24:13,910 --> 00:24:21,950
blockade to and post it

521
00:24:15,860 --> 00:24:26,389
to to network be so to to bypass all

522
00:24:21,950 --> 00:24:29,809
those problems the the one could try

523
00:24:26,390 --> 00:24:33,350
mining the transaction privately on

524
00:24:29,809 --> 00:24:35,178
train a by making someone a miner

525
00:24:33,350 --> 00:24:38,750
include his transaction or her

526
00:24:35,179 --> 00:24:40,850
transaction and at the same time as soon

527
00:24:38,750 --> 00:24:44,770
as this transaction is mined a broadcast

528
00:24:40,850 --> 00:24:47,149
a double spend and if a double spend

529
00:24:44,770 --> 00:24:48,559
basically the double spend is going to

530
00:24:47,150 --> 00:24:50,980
spend the same coins that the

531
00:24:48,559 --> 00:24:54,500
transaction on the a changement and then

532
00:24:50,980 --> 00:24:56,510
we can't really you know replay the the

533
00:24:54,500 --> 00:24:59,690
transaction from the a chain because the

534
00:24:56,510 --> 00:25:01,760
coins have been already spent so yeah so

535
00:24:59,690 --> 00:25:04,070
the point here is that net split is not

536
00:25:01,760 --> 00:25:06,020
only a denial of service condition if

537
00:25:04,070 --> 00:25:08,559
someone manages to perform a net split

538
00:25:06,020 --> 00:25:14,450
on the cryptocurrency Network she can

539
00:25:08,559 --> 00:25:16,280
steal coins so let's look at how would

540
00:25:14,450 --> 00:25:17,900
it be possible to cause a net split

541
00:25:16,280 --> 00:25:21,559
condition

542
00:25:17,900 --> 00:25:23,510
there was a CV so the one typical way

543
00:25:21,559 --> 00:25:26,870
that comes up in in cryptocurrency

544
00:25:23,510 --> 00:25:32,360
client is via block cache poisoning so

545
00:25:26,870 --> 00:25:34,219
what's that well when nodes process

546
00:25:32,360 --> 00:25:37,850
blocks they since this is a peer-to-peer

547
00:25:34,220 --> 00:25:40,820
network the nodes want to do this only

548
00:25:37,850 --> 00:25:45,860
once so once a node receives a block the

549
00:25:40,820 --> 00:25:48,470
hash gets cached and in future the node

550
00:25:45,860 --> 00:25:51,590
is going to reject processing this block

551
00:25:48,470 --> 00:25:53,870
twice so yeah I send the block to the

552
00:25:51,590 --> 00:25:57,139
network and and regardless if it's valid

553
00:25:53,870 --> 00:26:00,350
or invalid the node is going to process

554
00:25:57,140 --> 00:26:02,900
it and once it once it's processed the

555
00:26:00,350 --> 00:26:04,909
hash is going to go into a fresh list of

556
00:26:02,900 --> 00:26:07,610
processed blocks and if I resent the

557
00:26:04,910 --> 00:26:09,410
same block twice it's not going to

558
00:26:07,610 --> 00:26:13,540
process it anymore it's it's been

559
00:26:09,410 --> 00:26:17,299
processed so the idea here really is to

560
00:26:13,540 --> 00:26:19,100
poison a valid blocks fresh so an

561
00:26:17,299 --> 00:26:24,320
attacker listens on the Bitcoin network

562
00:26:19,100 --> 00:26:27,080
for new blocks and then tweaks the block

563
00:26:24,320 --> 00:26:30,169
content to invalidate the block without

564
00:26:27,080 --> 00:26:32,750
changing the blocks fresh

565
00:26:30,170 --> 00:26:35,960
and then the notes that received the the

566
00:26:32,750 --> 00:26:40,160
tweaked invalidated block are going to

567
00:26:35,960 --> 00:26:42,710
Demeter's invalid and cache that

568
00:26:40,160 --> 00:26:45,950
basically the hash of that block and not

569
00:26:42,710 --> 00:26:48,020
process it ever again so yeah once again

570
00:26:45,950 --> 00:26:51,500
the main idea here is to listen on the

571
00:26:48,020 --> 00:26:54,110
network for for new blocks and as soon

572
00:26:51,500 --> 00:26:57,110
as the new block is broadcasted before

573
00:26:54,110 --> 00:26:59,990
it reaches all the nodes you tweak the

574
00:26:57,110 --> 00:27:02,270
block without changing its hash but

575
00:26:59,990 --> 00:27:04,190
invalidate that invalidates the block

576
00:27:02,270 --> 00:27:06,710
and you quickly brought try to broadcast

577
00:27:04,190 --> 00:27:08,990
it to some other nodes and if they

578
00:27:06,710 --> 00:27:11,660
receive that block first which has been

579
00:27:08,990 --> 00:27:14,419
invalidated you have kind of squatted on

580
00:27:11,660 --> 00:27:17,870
the Bob valid block cache and these

581
00:27:14,419 --> 00:27:20,809
nodes can't really anymore process valid

582
00:27:17,870 --> 00:27:22,850
blog / and that's why we situation here

583
00:27:20,809 --> 00:27:25,340
with a one block for example nodes B

584
00:27:22,850 --> 00:27:28,040
have already received invalidated block

585
00:27:25,340 --> 00:27:32,030
a one with the same hash and they refuse

586
00:27:28,040 --> 00:27:35,178
to process it so now the question here

587
00:27:32,030 --> 00:27:37,970
really is is block as malleable can we

588
00:27:35,179 --> 00:27:39,950
take a block and change something inside

589
00:27:37,970 --> 00:27:41,809
the block without changing its hash if

590
00:27:39,950 --> 00:27:46,460
we can do that then we can perform an

591
00:27:41,809 --> 00:27:47,540
exploit attack on on the network so

592
00:27:46,460 --> 00:27:50,360
what's in a block ash

593
00:27:47,540 --> 00:27:53,030
well this is a like a probably not

594
00:27:50,360 --> 00:27:55,969
Bitcoin but it looks like Bitcoin there

595
00:27:53,030 --> 00:27:57,830
is some that there is a couple of fields

596
00:27:55,970 --> 00:28:01,340
here that get hashed so there is a

597
00:27:57,830 --> 00:28:04,159
previous block hash nonce time stamp and

598
00:28:01,340 --> 00:28:05,870
transaction merkel wrote so previous

599
00:28:04,160 --> 00:28:08,000
block hash is the pointer to the

600
00:28:05,870 --> 00:28:10,820
previous block the nonce is used to

601
00:28:08,000 --> 00:28:13,280
solve the proof-of-work puzzle and there

602
00:28:10,820 --> 00:28:14,960
is a timestamp and there is the merkel

603
00:28:13,280 --> 00:28:19,160
root which is nothing but really a

604
00:28:14,960 --> 00:28:22,820
digest of transactions in that block so

605
00:28:19,160 --> 00:28:25,580
yeah every block yeah has transactions

606
00:28:22,820 --> 00:28:30,320
and we instead of kind of directly

607
00:28:25,580 --> 00:28:33,168
hashing the transactions we we hash the

608
00:28:30,320 --> 00:28:35,030
the merkel root of difference actions

609
00:28:33,169 --> 00:28:37,100
and these are transactions so this block

610
00:28:35,030 --> 00:28:41,780
will have like for transactions example

611
00:28:37,100 --> 00:28:42,330
here T 1 T 2 T 3 and T 4 and in order to

612
00:28:41,780 --> 00:28:46,649
compute

613
00:28:42,330 --> 00:28:48,809
the merkel route we hash t1 t2 we hash

614
00:28:46,649 --> 00:28:51,059
the leaf's basically and then we

615
00:28:48,809 --> 00:28:53,519
concatenate these hashes and has them

616
00:28:51,059 --> 00:28:57,178
again and we do that pairwise and we

617
00:28:53,519 --> 00:28:59,909
then do the same for four for the these

618
00:28:57,179 --> 00:29:01,950
inner nodes and get the root but it's

619
00:28:59,909 --> 00:29:04,019
not really important how this works

620
00:29:01,950 --> 00:29:09,149
what's important is this is a this is a

621
00:29:04,019 --> 00:29:12,210
digest of the of all the transactions so

622
00:29:09,149 --> 00:29:14,969
now if what our goal here is to change

623
00:29:12,210 --> 00:29:15,570
something here so that the hash remains

624
00:29:14,970 --> 00:29:17,519
the same

625
00:29:15,570 --> 00:29:19,950
that's actually the attackers goal he is

626
00:29:17,519 --> 00:29:23,190
trying to do to invalidate the block

627
00:29:19,950 --> 00:29:24,899
without changing the hash so now what we

628
00:29:23,190 --> 00:29:28,110
have here is actually a multi field

629
00:29:24,899 --> 00:29:32,360
value so we have a couple of fields here

630
00:29:28,110 --> 00:29:35,729
for fields that need to get hashed so if

631
00:29:32,360 --> 00:29:37,199
hashing like a multi field value we need

632
00:29:35,730 --> 00:29:40,230
to come up with some serialization

633
00:29:37,200 --> 00:29:43,889
function we need to somehow you know

634
00:29:40,230 --> 00:29:47,190
convert these four fields into a byte

635
00:29:43,889 --> 00:29:48,899
string and so we need some kind of

636
00:29:47,190 --> 00:29:50,789
serialization so that's denoted with

637
00:29:48,899 --> 00:29:53,518
serialization here it is the hash

638
00:29:50,789 --> 00:30:00,029
function and we serialize these four

639
00:29:53,519 --> 00:30:02,490
fields and also here in the picture we

640
00:30:00,029 --> 00:30:04,679
have four transactions but what if we

641
00:30:02,490 --> 00:30:06,659
have three strange transactions then

642
00:30:04,679 --> 00:30:09,600
we're going to have a missing field here

643
00:30:06,659 --> 00:30:11,820
and we'll need to come up with something

644
00:30:09,600 --> 00:30:14,639
to put here because we can't compute the

645
00:30:11,820 --> 00:30:17,279
Merkle tree if the number of

646
00:30:14,639 --> 00:30:20,039
transactions is not 4 or 8 or 16 or a

647
00:30:17,279 --> 00:30:22,769
power of 2 so that you note with the pad

648
00:30:20,039 --> 00:30:24,980
function will do bad transactions so

649
00:30:22,769 --> 00:30:34,019
that the number of transactions is a

650
00:30:24,980 --> 00:30:36,059
power of two yeah so if we're looking

651
00:30:34,019 --> 00:30:38,279
for a collision a hash function like

652
00:30:36,059 --> 00:30:41,970
just a pure function that's that's hard

653
00:30:38,279 --> 00:30:44,100
to have or not doable however we're not

654
00:30:41,970 --> 00:30:45,659
dealing with with the hash function here

655
00:30:44,100 --> 00:30:48,000
we're dealing with this whole

656
00:30:45,659 --> 00:30:53,669
construction it has theorization and it

657
00:30:48,000 --> 00:30:55,620
has padding and so suppose how would an

658
00:30:53,669 --> 00:30:57,840
attack look like if on

659
00:30:55,620 --> 00:31:00,570
the civilization function so let's try

660
00:30:57,840 --> 00:31:04,139
to exploit the civilization function for

661
00:31:00,570 --> 00:31:07,439
the purpose of obtaining the collision

662
00:31:04,140 --> 00:31:09,420
on this whole block hash so suppose that

663
00:31:07,440 --> 00:31:11,340
serialization function is a really

664
00:31:09,420 --> 00:31:13,770
simplistic one we'll just concatenating

665
00:31:11,340 --> 00:31:17,280
fields so we have these four fields here

666
00:31:13,770 --> 00:31:19,139
and we're just concatenating them so

667
00:31:17,280 --> 00:31:20,940
yeah that's shown here we take the

668
00:31:19,140 --> 00:31:25,910
previous block hash concatenate with

669
00:31:20,940 --> 00:31:28,830
nonce timestamp and Merkle hash so then

670
00:31:25,910 --> 00:31:31,620
someone could take a valid block hash

671
00:31:28,830 --> 00:31:33,960
and take the last character of the nonce

672
00:31:31,620 --> 00:31:37,860
here and just move it into the timestamp

673
00:31:33,960 --> 00:31:40,410
so if we do that then the concatenation

674
00:31:37,860 --> 00:31:43,770
of these fields is not going to change

675
00:31:40,410 --> 00:31:47,730
because we just moved last character

676
00:31:43,770 --> 00:31:51,900
from the nose into the timestamp and

677
00:31:47,730 --> 00:31:53,880
that changes the fields here and and if

678
00:31:51,900 --> 00:31:55,890
we add the character into the timestamp

679
00:31:53,880 --> 00:31:57,960
or remove a character in turn us that

680
00:31:55,890 --> 00:31:59,580
may as well invalidate a block because

681
00:31:57,960 --> 00:32:01,770
it's going to change for example the

682
00:31:59,580 --> 00:32:04,080
timestamp or it's just going to going to

683
00:32:01,770 --> 00:32:05,760
be a formatting problem the number of

684
00:32:04,080 --> 00:32:09,120
characters in the notes is not going to

685
00:32:05,760 --> 00:32:12,150
be valid so if we if we take a block and

686
00:32:09,120 --> 00:32:14,370
we take the last character after out of

687
00:32:12,150 --> 00:32:16,710
one field and move it into the adjacent

688
00:32:14,370 --> 00:32:18,330
field the concatenation in the

689
00:32:16,710 --> 00:32:20,940
serialization function is going to

690
00:32:18,330 --> 00:32:22,649
remain constant and the whole hash

691
00:32:20,940 --> 00:32:25,440
function is going to ash to the same

692
00:32:22,650 --> 00:32:27,320
value and as such we basically obtain

693
00:32:25,440 --> 00:32:30,000
the collision in this whole construction

694
00:32:27,320 --> 00:32:33,270
this was never the case in Bitcoin but

695
00:32:30,000 --> 00:32:37,080
there is it kind of happens from time to

696
00:32:33,270 --> 00:32:39,270
time it's the point here is is if we're

697
00:32:37,080 --> 00:32:41,850
if we're civilizing multi field values

698
00:32:39,270 --> 00:32:45,240
and then hashing or signing them we

699
00:32:41,850 --> 00:32:47,250
should not use plain concatenation as a

700
00:32:45,240 --> 00:32:53,130
civilization function otherwise we were

701
00:32:47,250 --> 00:32:54,630
vulnerable to this attack so now let's

702
00:32:53,130 --> 00:32:56,490
take a look if we can do something about

703
00:32:54,630 --> 00:32:58,140
that Merkel tree could we could we cause

704
00:32:56,490 --> 00:33:01,080
a collision through the Merkel tree so

705
00:32:58,140 --> 00:33:03,210
if we take them like a valid block and

706
00:33:01,080 --> 00:33:05,460
and they its transactions and suppose we

707
00:33:03,210 --> 00:33:09,000
just wreak one bit inside transaction

708
00:33:05,460 --> 00:33:11,070
one or one bite the

709
00:33:09,000 --> 00:33:13,039
difference is going to propagate the

710
00:33:11,070 --> 00:33:15,779
hash function output is going to be

711
00:33:13,039 --> 00:33:17,490
totally changed and this is going to

712
00:33:15,779 --> 00:33:19,799
propagate into the merkel root so we

713
00:33:17,490 --> 00:33:21,450
can't really do anything that way but if

714
00:33:19,799 --> 00:33:23,460
you look at the padding function here

715
00:33:21,450 --> 00:33:25,710
that's really the weak link in this

716
00:33:23,460 --> 00:33:28,230
construction so let's take a look how

717
00:33:25,710 --> 00:33:30,120
padding cause padding of transactions

718
00:33:28,230 --> 00:33:32,309
for the purpose of Merkel route

719
00:33:30,120 --> 00:33:34,559
calculation works in Bitcoin and so

720
00:33:32,309 --> 00:33:37,110
suppose I have three transactions

721
00:33:34,559 --> 00:33:39,299
instead of four the padding the goal of

722
00:33:37,110 --> 00:33:41,309
the padding is is to make them into a

723
00:33:39,299 --> 00:33:43,049
power power of two so it's going to the

724
00:33:41,309 --> 00:33:46,830
goal is to extend them into four

725
00:33:43,049 --> 00:33:48,899
transactions so in Bitcoin it's going to

726
00:33:46,830 --> 00:33:51,779
just take the last transaction in the

727
00:33:48,899 --> 00:33:53,879
list and copy it once again or if there

728
00:33:51,779 --> 00:33:55,230
is five transactions it's just going to

729
00:33:53,880 --> 00:33:58,159
take the last three different

730
00:33:55,230 --> 00:34:04,110
transactions and copy them in the end to

731
00:33:58,159 --> 00:34:07,860
reach to to the 2003 which is eight and

732
00:34:04,110 --> 00:34:10,469
and basically you know pad transactions

733
00:34:07,860 --> 00:34:13,109
that are needed for to fill out these

734
00:34:10,469 --> 00:34:16,799
question marks here so it's again a very

735
00:34:13,109 --> 00:34:18,750
simplistic padding scheme and it's easy

736
00:34:16,800 --> 00:34:24,089
to find collisions and this padding so

737
00:34:18,750 --> 00:34:26,219
if if we take t1 t2 t3 the the result of

738
00:34:24,089 --> 00:34:31,619
the padding is going to be T 1 T 2 T 3

739
00:34:26,219 --> 00:34:33,388
and T 3 and if we take T 1 T 2 T 3 and T

740
00:34:31,619 --> 00:34:35,070
3 well the padding is not going to do

741
00:34:33,389 --> 00:34:37,050
anything so the result is going to this

742
00:34:35,070 --> 00:34:38,760
to be the same so here this is a

743
00:34:37,050 --> 00:34:42,570
collision on the padding function and

744
00:34:38,760 --> 00:34:48,020
the padding function is really used here

745
00:34:42,570 --> 00:34:51,690
in the in the in the hole construction

746
00:34:48,020 --> 00:34:54,030
so based on this padding property there

747
00:34:51,690 --> 00:35:00,359
was an attack on Bitcoin which was a CV

748
00:34:54,030 --> 00:35:03,060
in 2012 basically the idea is to observe

749
00:35:00,359 --> 00:35:05,730
a block with less than 2 to the M

750
00:35:03,060 --> 00:35:07,710
transactions had the pad that the

751
00:35:05,730 --> 00:35:09,450
transactions that would be padded

752
00:35:07,710 --> 00:35:12,420
through the Merkel route computation

753
00:35:09,450 --> 00:35:14,640
inside block and send that block to

754
00:35:12,420 --> 00:35:16,020
target not nodes the validation will

755
00:35:14,640 --> 00:35:20,540
fail because there are duplicate

756
00:35:16,020 --> 00:35:24,710
transactions but the hash did not change

757
00:35:20,540 --> 00:35:30,320
the output of this is that correct block

758
00:35:24,710 --> 00:35:34,160
gets blacklisted yeah okay

759
00:35:30,320 --> 00:35:36,530
so now let's take a look at another net

760
00:35:34,160 --> 00:35:39,009
split attack that happened in Bitcoin to

761
00:35:36,530 --> 00:35:45,680
see how much time I have

762
00:35:39,010 --> 00:35:50,630
okay so this was inconsistent berkeley

763
00:35:45,680 --> 00:35:52,069
DB lock limit interactions so this was a

764
00:35:50,630 --> 00:35:56,180
net split that happened during the

765
00:35:52,070 --> 00:35:58,910
software update so there was a kind of

766
00:35:56,180 --> 00:36:01,310
Bitcoin client update that that was

767
00:35:58,910 --> 00:36:04,520
supposed to take place and this was

768
00:36:01,310 --> 00:36:06,500
supposed to be non forking update the

769
00:36:04,520 --> 00:36:08,960
consensus rules of what's a valid

770
00:36:06,500 --> 00:36:11,840
transaction and a valid block did not

771
00:36:08,960 --> 00:36:15,620
change should not have been changed and

772
00:36:11,840 --> 00:36:17,990
and the what was the change well the

773
00:36:15,620 --> 00:36:19,810
only goal was to replace the berkeley

774
00:36:17,990 --> 00:36:23,479
database with the level database

775
00:36:19,810 --> 00:36:27,410
berkeley database was database it was

776
00:36:23,480 --> 00:36:30,040
used early on by satoshi and it supports

777
00:36:27,410 --> 00:36:32,870
thousands of simultaneous threads and

778
00:36:30,040 --> 00:36:35,029
like it's good in multi-threaded access

779
00:36:32,870 --> 00:36:37,100
to the database and stuff like that but

780
00:36:35,030 --> 00:36:39,860
it had some problem so the community

781
00:36:37,100 --> 00:36:44,230
decided to swap out this database and to

782
00:36:39,860 --> 00:36:48,170
move on to level DB and after the update

783
00:36:44,230 --> 00:36:50,620
happened about 60% of the nodes accepted

784
00:36:48,170 --> 00:36:54,770
the change and used level DB in their

785
00:36:50,620 --> 00:36:56,660
bitcoin clients and about 40% of the

786
00:36:54,770 --> 00:37:01,370
nodes remained on the old version and

787
00:36:56,660 --> 00:37:05,140
use berkeley DB so that was the

788
00:37:01,370 --> 00:37:08,259
situation and yeah the berkeley DB

789
00:37:05,140 --> 00:37:11,000
configuration has a maximum number of

790
00:37:08,260 --> 00:37:13,790
simultaneously open locks that can be

791
00:37:11,000 --> 00:37:15,920
specified when when it's configured

792
00:37:13,790 --> 00:37:20,509
basically in the client and this was set

793
00:37:15,920 --> 00:37:23,000
to ten thousand so until that point

794
00:37:20,510 --> 00:37:25,250
processing blocks never triggered this

795
00:37:23,000 --> 00:37:28,310
limit so if I if I'm processing a block

796
00:37:25,250 --> 00:37:30,610
I'm kind of looking up transactions from

797
00:37:28,310 --> 00:37:33,620
that block in the berkeley database and

798
00:37:30,610 --> 00:37:34,460
it has not previously occurred that i

799
00:37:33,620 --> 00:37:36,558
hit

800
00:37:34,460 --> 00:37:39,770
Laak limit that berkeley database

801
00:37:36,559 --> 00:37:43,220
configuration imposed however there was

802
00:37:39,770 --> 00:37:45,410
a block some block height it had

803
00:37:43,220 --> 00:37:48,848
unusually high number of transaction

804
00:37:45,410 --> 00:37:53,180
inputs in transactions and this

805
00:37:48,849 --> 00:37:55,670
triggered basically the this this limit

806
00:37:53,180 --> 00:37:58,609
got triggered and the vertical DB

807
00:37:55,670 --> 00:38:01,569
returned an error when trying to process

808
00:37:58,609 --> 00:38:03,980
that block and the berkeley DB nodes

809
00:38:01,569 --> 00:38:06,049
rejected that block so that's the a one

810
00:38:03,980 --> 00:38:07,970
block here and since they reject the

811
00:38:06,049 --> 00:38:10,880
dead walk they had to go on on their own

812
00:38:07,970 --> 00:38:16,819
fork and the level DB notes accepted

813
00:38:10,880 --> 00:38:19,520
that block and split happened so then

814
00:38:16,819 --> 00:38:21,799
yeah there was actually a double spend

815
00:38:19,520 --> 00:38:26,799
based on this nets belief condition the

816
00:38:21,799 --> 00:38:29,589
in the bib post-mortem blip beep it's

817
00:38:26,799 --> 00:38:31,250
it's like a document that outlines

818
00:38:29,589 --> 00:38:34,400
Bitcoin changes

819
00:38:31,250 --> 00:38:36,770
it's called bit the it was claimed it

820
00:38:34,400 --> 00:38:38,420
it's it's it was known malicious I'm not

821
00:38:36,770 --> 00:38:41,150
sure what he means maybe the money was

822
00:38:38,420 --> 00:38:43,670
returned in any case it's interesting

823
00:38:41,150 --> 00:38:49,220
that this this net split condition was

824
00:38:43,670 --> 00:38:51,710
was abused for a double spend okay so so

825
00:38:49,220 --> 00:38:54,770
back to the kinda if we zoom out a

826
00:38:51,710 --> 00:38:57,230
little bit from these details yeah

827
00:38:54,770 --> 00:38:59,359
net split condition means that part of

828
00:38:57,230 --> 00:39:01,369
nodes see one letter and the other part

829
00:38:59,359 --> 00:39:03,950
of node see the other letter and this is

830
00:39:01,369 --> 00:39:08,589
a unexplored area of research in my

831
00:39:03,950 --> 00:39:11,328
opinion so it's a good thing to look at

832
00:39:08,589 --> 00:39:14,328
so what could be the the reasons in

833
00:39:11,329 --> 00:39:15,589
general for for net split attacks so

834
00:39:14,329 --> 00:39:17,559
there could be different client

835
00:39:15,589 --> 00:39:20,180
implementations acting on the network

836
00:39:17,559 --> 00:39:22,190
for instance I may be running a Python

837
00:39:20,180 --> 00:39:23,960
implementation of a coin and someone

838
00:39:22,190 --> 00:39:26,960
else may be running a C++ implementation

839
00:39:23,960 --> 00:39:29,450
on the coin and the question here is

840
00:39:26,960 --> 00:39:34,250
really are we sure that my C++

841
00:39:29,450 --> 00:39:36,710
implementation of the coin really has

842
00:39:34,250 --> 00:39:40,010
the same notion of what a valid

843
00:39:36,710 --> 00:39:41,690
transaction and a valid block is as the

844
00:39:40,010 --> 00:39:44,270
Python implementation if there is an

845
00:39:41,690 --> 00:39:46,880
edge case in which my C++ implementation

846
00:39:44,270 --> 00:39:47,900
is going to accept a block and the

847
00:39:46,880 --> 00:39:50,180
Python implementation

848
00:39:47,900 --> 00:39:53,029
is going to reject the block then we get

849
00:39:50,180 --> 00:39:56,000
a net split and probably not sweat it

850
00:39:53,029 --> 00:39:58,010
facilitates double span attack so kind

851
00:39:56,000 --> 00:40:01,460
of interesting research topic is to take

852
00:39:58,010 --> 00:40:05,329
like any coin you want to take and and

853
00:40:01,460 --> 00:40:07,220
look for four different implementations

854
00:40:05,329 --> 00:40:10,160
in different languages and and come up

855
00:40:07,220 --> 00:40:11,839
with edge cases where one implementation

856
00:40:10,160 --> 00:40:14,379
would react one way and the other

857
00:40:11,839 --> 00:40:17,690
implementation would react the other way

858
00:40:14,380 --> 00:40:19,490
so to have like full security against

859
00:40:17,690 --> 00:40:21,260
netsplit attacks in this scenario we

860
00:40:19,490 --> 00:40:22,640
need to have full equivalents of the two

861
00:40:21,260 --> 00:40:27,319
implementations which is a hard

862
00:40:22,640 --> 00:40:30,710
requirement so what else

863
00:40:27,319 --> 00:40:32,930
execution environment discrepancies well

864
00:40:30,710 --> 00:40:35,210
though if even if there is no multiple

865
00:40:32,930 --> 00:40:38,078
implementations running even if I have

866
00:40:35,210 --> 00:40:41,420
just my for example C++ implementation

867
00:40:38,079 --> 00:40:43,309
then it may still be running on

868
00:40:41,420 --> 00:40:46,760
different operating systems on different

869
00:40:43,309 --> 00:40:49,670
architectures like 32 or 64-bit and

870
00:40:46,760 --> 00:40:51,170
there may be some kind of some

871
00:40:49,670 --> 00:40:52,880
differences that I don't know about

872
00:40:51,170 --> 00:40:57,529
currently that are going to make the

873
00:40:52,880 --> 00:40:59,390
client behave differently or it may the

874
00:40:57,529 --> 00:41:01,730
client may use some kind of undefined

875
00:40:59,390 --> 00:41:04,150
behavior for example undefined C++

876
00:41:01,730 --> 00:41:07,309
behavior which which is which will

877
00:41:04,150 --> 00:41:10,700
return one way and on one system and to

878
00:41:07,309 --> 00:41:16,250
another way on another system also if I

879
00:41:10,700 --> 00:41:19,578
if I download or make a client that on

880
00:41:16,250 --> 00:41:21,349
my own the question is whether is going

881
00:41:19,579 --> 00:41:23,299
to use the libraries that are available

882
00:41:21,349 --> 00:41:25,339
in the system or is going to fix the

883
00:41:23,299 --> 00:41:28,700
version of the underlined libraries it

884
00:41:25,339 --> 00:41:29,359
uses so if my client uses OpenSSL

885
00:41:28,700 --> 00:41:32,000
version

886
00:41:29,359 --> 00:41:33,650
whichever and the other system uses

887
00:41:32,000 --> 00:41:35,420
another OpenSSL there may be a

888
00:41:33,650 --> 00:41:39,260
difference there may be a fork in these

889
00:41:35,420 --> 00:41:40,940
OpenSSL libraries so that may be that

890
00:41:39,260 --> 00:41:43,400
may yield the edge case which is going

891
00:41:40,940 --> 00:41:46,700
to make one sort of client behave one

892
00:41:43,400 --> 00:41:49,579
way and the other type of clients behave

893
00:41:46,700 --> 00:41:53,058
other way and then it will be a source

894
00:41:49,579 --> 00:41:55,670
of an exploit attack and finally when we

895
00:41:53,059 --> 00:41:59,510
have client software upgrades so I you

896
00:41:55,670 --> 00:42:01,640
know the developers roll out new

897
00:41:59,510 --> 00:42:04,100
version and and and it's claimed that

898
00:42:01,640 --> 00:42:08,180
this new version does not change any

899
00:42:04,100 --> 00:42:10,069
consensus rules but it may look like it

900
00:42:08,180 --> 00:42:11,629
does not change any rules but does it

901
00:42:10,070 --> 00:42:15,500
not really change the rules I guess

902
00:42:11,630 --> 00:42:17,390
that's that's a program for research for

903
00:42:15,500 --> 00:42:20,330
example in this Berkeley DB with level

904
00:42:17,390 --> 00:42:22,009
DB case it looks like if you swap out

905
00:42:20,330 --> 00:42:25,069
one database software with another

906
00:42:22,010 --> 00:42:30,340
database things should not change but

907
00:42:25,070 --> 00:42:37,160
yeah things could go unnoticed here yeah

908
00:42:30,340 --> 00:42:40,760
okay so yeah so if you now take a look

909
00:42:37,160 --> 00:42:43,700
at what the scan application security

910
00:42:40,760 --> 00:42:46,940
does attacks look like they're most

911
00:42:43,700 --> 00:42:49,609
numerous types of attack in in in this

912
00:42:46,940 --> 00:42:52,670
kind of environment they can be

913
00:42:49,610 --> 00:42:55,880
categorized so the crashes stuff like

914
00:42:52,670 --> 00:42:59,480
assert failures or divide by 0

915
00:42:55,880 --> 00:43:02,240
there could be CPU exhaustion so for

916
00:42:59,480 --> 00:43:06,890
example if I send a transaction that

917
00:43:02,240 --> 00:43:10,399
makes other clients validate hundreds of

918
00:43:06,890 --> 00:43:12,589
thousands of signatures that's going

919
00:43:10,400 --> 00:43:18,740
that's likely going to exhaust the CPU

920
00:43:12,590 --> 00:43:23,690
of those nodes or yeah whichever if

921
00:43:18,740 --> 00:43:25,939
these clients are just operating some

922
00:43:23,690 --> 00:43:28,850
difficult computer on some difficult

923
00:43:25,940 --> 00:43:31,520
computations and and an attacker can can

924
00:43:28,850 --> 00:43:34,970
make them do arbitrary amount of

925
00:43:31,520 --> 00:43:36,830
computation that's a problem there was

926
00:43:34,970 --> 00:43:39,500
problems with orphan transaction

927
00:43:36,830 --> 00:43:43,400
handling so processing blocks and

928
00:43:39,500 --> 00:43:46,280
transactions is kind of kind of involved

929
00:43:43,400 --> 00:43:49,340
so it's kind of likely that those

930
00:43:46,280 --> 00:43:51,200
vectors will happen in while

931
00:43:49,340 --> 00:43:52,730
transactions are being processed and

932
00:43:51,200 --> 00:43:54,830
blocks are being processed

933
00:43:52,730 --> 00:43:56,390
there's also memory and space exhaustion

934
00:43:54,830 --> 00:43:59,900
this is very simple you just upload a

935
00:43:56,390 --> 00:44:01,910
ton of data continually on the network

936
00:43:59,900 --> 00:44:03,920
or on the client and and it kind of runs

937
00:44:01,910 --> 00:44:06,319
out of memory and also Network

938
00:44:03,920 --> 00:44:09,710
exhaustion here at the network starts

939
00:44:06,320 --> 00:44:11,750
starts forwarding spam and huge amounts

940
00:44:09,710 --> 00:44:13,820
of data between the nodes

941
00:44:11,750 --> 00:44:16,250
Network exhaustion is also kind of

942
00:44:13,820 --> 00:44:19,100
dangerous since it often means that the

943
00:44:16,250 --> 00:44:23,660
whole network will start forwarding junk

944
00:44:19,100 --> 00:44:25,580
data across so now if we compared us in

945
00:44:23,660 --> 00:44:28,430
blockchain like a Satoshi locked in

946
00:44:25,580 --> 00:44:30,920
Bitcoin with us in other software yeah

947
00:44:28,430 --> 00:44:34,129
does is regarded as a kind of issue

948
00:44:30,920 --> 00:44:37,160
that's not that important so for example

949
00:44:34,130 --> 00:44:39,350
in web app it affects availability which

950
00:44:37,160 --> 00:44:42,200
is a huge issue if this is really really

951
00:44:39,350 --> 00:44:44,480
important web app but it does not affect

952
00:44:42,200 --> 00:44:47,029
other security goals so it does not

953
00:44:44,480 --> 00:44:49,730
affect confidentiality so for example I

954
00:44:47,030 --> 00:44:53,270
I mean if I have a DOS attack on a web

955
00:44:49,730 --> 00:44:56,420
app I am NOT going to see the passwords

956
00:44:53,270 --> 00:44:58,940
of users on inside that system however

957
00:44:56,420 --> 00:45:01,550
the simple octane is different so the

958
00:44:58,940 --> 00:45:07,070
simple octane results basically if you

959
00:45:01,550 --> 00:45:10,520
crash nodes such as nodes that mine you

960
00:45:07,070 --> 00:45:13,580
know new blocks then effectively the

961
00:45:10,520 --> 00:45:15,410
network's hash power is reduced and then

962
00:45:13,580 --> 00:45:18,259
there is less security against the

963
00:45:15,410 --> 00:45:21,350
double spin attack so in blocking does

964
00:45:18,260 --> 00:45:24,800
cleaner gets this new power and it's

965
00:45:21,350 --> 00:45:28,040
more powerful than elsewhere it allows

966
00:45:24,800 --> 00:45:29,660
people to it basically reduce the

967
00:45:28,040 --> 00:45:33,020
security against the double spend double

968
00:45:29,660 --> 00:45:34,580
spend really is the main resistance

969
00:45:33,020 --> 00:45:36,320
against the double spam attack is the

970
00:45:34,580 --> 00:45:40,490
main point of blockchain Satoshi

971
00:45:36,320 --> 00:45:47,000
doctrine yeah so those factors have

972
00:45:40,490 --> 00:45:48,740
higher severity in blocking so let's

973
00:45:47,000 --> 00:45:53,810
take a look what's here CPU and memory

974
00:45:48,740 --> 00:45:56,149
exhaustion bugs so how could we what

975
00:45:53,810 --> 00:45:58,820
would be the source of a CPU exhaustion

976
00:45:56,150 --> 00:46:00,560
back well whenever we have expose an

977
00:45:58,820 --> 00:46:03,530
algorithm which is a quadratic quadratic

978
00:46:00,560 --> 00:46:06,350
complexity algorithms that as such as we

979
00:46:03,530 --> 00:46:09,170
have a bad sorting algorithm which is n

980
00:46:06,350 --> 00:46:11,360
square complexity this means we can send

981
00:46:09,170 --> 00:46:14,510
small inputs that are going to result in

982
00:46:11,360 --> 00:46:16,610
huge amount of computation so that if

983
00:46:14,510 --> 00:46:18,260
there is like in REST API it exposes a

984
00:46:16,610 --> 00:46:20,530
quadratic complexity algorithm that's

985
00:46:18,260 --> 00:46:20,530
about

986
00:46:20,960 --> 00:46:29,089
so also iterating over sets with user

987
00:46:24,650 --> 00:46:32,030
control sighs if at the endpoint that

988
00:46:29,089 --> 00:46:35,390
I'm hitting there is a for loop which

989
00:46:32,030 --> 00:46:39,320
goes over a set where the attacker

990
00:46:35,390 --> 00:46:41,660
controls the the set then this set can

991
00:46:39,320 --> 00:46:44,330
be made arbitrarily large and then at

992
00:46:41,660 --> 00:46:46,490
some point one request will mean a

993
00:46:44,330 --> 00:46:50,150
million iterations already set so that's

994
00:46:46,490 --> 00:46:53,089
also a problem also crypto operations

995
00:46:50,150 --> 00:46:54,500
they consume a lot of CPU and it's

996
00:46:53,089 --> 00:46:56,570
important to have a bound on how many

997
00:46:54,500 --> 00:47:02,780
crypt operations can be executed with

998
00:46:56,570 --> 00:47:05,089
little network use it yeah there's also

999
00:47:02,780 --> 00:47:07,490
unlimited memory or disk storage so

1000
00:47:05,089 --> 00:47:10,580
there is unconference transaction pool

1001
00:47:07,490 --> 00:47:13,069
it's called memo in Bitcoin and this was

1002
00:47:10,580 --> 00:47:16,670
also a problem it will be possible to

1003
00:47:13,070 --> 00:47:18,800
just send on transactions that never get

1004
00:47:16,670 --> 00:47:21,890
confirmed and the whole network starts

1005
00:47:18,800 --> 00:47:25,550
caching these transactions endlessly and

1006
00:47:21,890 --> 00:47:30,549
runs out of memory sometimes and also

1007
00:47:25,550 --> 00:47:33,290
there is orphan transaction pool so now

1008
00:47:30,550 --> 00:47:35,900
you know this kind of breached reducing

1009
00:47:33,290 --> 00:47:37,550
some kind of run you know of time orphan

1010
00:47:35,900 --> 00:47:40,099
transaction handling so there was an

1011
00:47:37,550 --> 00:47:42,830
interesting does factor in Bitcoin which

1012
00:47:40,099 --> 00:47:44,960
involved orphan transaction handling if

1013
00:47:42,830 --> 00:47:47,598
we recall how Bitcoin transactions look

1014
00:47:44,960 --> 00:47:50,420
look like it have multiple inputs and

1015
00:47:47,599 --> 00:47:52,280
multiple outputs inputs are basically

1016
00:47:50,420 --> 00:47:55,730
hashes of previous transactions and

1017
00:47:52,280 --> 00:47:59,420
indices of outputs in these transactions

1018
00:47:55,730 --> 00:48:01,490
we're spending and outputs are new coins

1019
00:47:59,420 --> 00:48:02,630
that we are kind of creating not

1020
00:48:01,490 --> 00:48:03,310
creating new coins were just

1021
00:48:02,630 --> 00:48:08,030
transferring

1022
00:48:03,310 --> 00:48:10,160
coins into new places so what's an

1023
00:48:08,030 --> 00:48:13,010
orphan transaction orphan transaction is

1024
00:48:10,160 --> 00:48:16,160
a transaction that where an input is

1025
00:48:13,010 --> 00:48:18,140
unknown so if someone sends a

1026
00:48:16,160 --> 00:48:19,790
transaction that refers to a previous

1027
00:48:18,140 --> 00:48:22,220
transaction that's not on the blockchain

1028
00:48:19,790 --> 00:48:26,660
it's it's unknown

1029
00:48:22,220 --> 00:48:29,680
that's an orphan transaction and Bitcoin

1030
00:48:26,660 --> 00:48:32,660
has to keep these transactions because

1031
00:48:29,680 --> 00:48:34,779
this is a peer-to-peer network and the

1032
00:48:32,660 --> 00:48:37,730
order of transactions is not

1033
00:48:34,779 --> 00:48:39,259
so that's an orphan transaction so now

1034
00:48:37,730 --> 00:48:41,569
how does a Bitcoin handle these

1035
00:48:39,259 --> 00:48:44,269
transactions well first of all there is

1036
00:48:41,569 --> 00:48:47,210
like a map or front transaction map

1037
00:48:44,269 --> 00:48:49,250
which is just like mapping hashes of

1038
00:48:47,210 --> 00:48:51,559
transactions into transactions

1039
00:48:49,250 --> 00:48:55,160
themselves so it's just a map so that's

1040
00:48:51,559 --> 00:48:57,710
reasonable however when I send when

1041
00:48:55,160 --> 00:49:00,279
someone sends a regular non orphan

1042
00:48:57,710 --> 00:49:05,599
transaction this transaction may be

1043
00:49:00,279 --> 00:49:07,819
referring to maybe actually the parent

1044
00:49:05,599 --> 00:49:11,900
as action that an orphan transaction is

1045
00:49:07,819 --> 00:49:15,410
missing so in that case the transaction

1046
00:49:11,900 --> 00:49:17,150
needs to be an orphaned so if we have an

1047
00:49:15,410 --> 00:49:18,769
orphan transaction that means one parent

1048
00:49:17,150 --> 00:49:21,049
transaction of that orphan transaction

1049
00:49:18,769 --> 00:49:26,269
is missing and if there is a regular

1050
00:49:21,049 --> 00:49:29,480
transaction then this this regular

1051
00:49:26,269 --> 00:49:31,419
transaction may be the parent that we

1052
00:49:29,480 --> 00:49:33,980
are missing so there needs to be

1053
00:49:31,420 --> 00:49:36,950
procedure for an orphan in transactions

1054
00:49:33,980 --> 00:49:40,869
and we could try going through through

1055
00:49:36,950 --> 00:49:43,339
this whole map here and identifying

1056
00:49:40,869 --> 00:49:47,990
which transactions you need to be an

1057
00:49:43,339 --> 00:49:50,420
orphaned but that's kind of ficient and

1058
00:49:47,990 --> 00:49:51,979
also the the number of orphan

1059
00:49:50,420 --> 00:49:54,289
transactions here is really user

1060
00:49:51,980 --> 00:49:56,869
controlled if there is no bound on the

1061
00:49:54,289 --> 00:49:59,750
number of transactions then then the

1062
00:49:56,869 --> 00:50:03,109
problem is then there is the spectre

1063
00:49:59,750 --> 00:50:04,849
isn't in there so I'm running out of

1064
00:50:03,109 --> 00:50:05,509
time I will not spend much time here

1065
00:50:04,849 --> 00:50:09,920
anymore

1066
00:50:05,509 --> 00:50:13,579
the idea is the problem is how do nodes

1067
00:50:09,920 --> 00:50:16,519
delete orphan transactions it comes down

1068
00:50:13,579 --> 00:50:19,880
to deleting edges in this graph which

1069
00:50:16,519 --> 00:50:22,430
which and the number of edges is user

1070
00:50:19,880 --> 00:50:25,130
controlled so basically you send a lot

1071
00:50:22,430 --> 00:50:27,288
of weirdly formatted kind of actually

1072
00:50:25,130 --> 00:50:29,900
not you send a lot of transactions which

1073
00:50:27,289 --> 00:50:33,079
creates a weirdly formatted map which

1074
00:50:29,900 --> 00:50:34,640
looks basically like like this and then

1075
00:50:33,079 --> 00:50:36,500
when the node needs to delete the

1076
00:50:34,640 --> 00:50:38,660
transaction that that also kind of

1077
00:50:36,500 --> 00:50:41,690
remotely trigger well then the node

1078
00:50:38,660 --> 00:50:43,940
needs to go over a million edges here to

1079
00:50:41,690 --> 00:50:46,310
delete properly delete that transaction

1080
00:50:43,940 --> 00:50:50,360
and that yields with us

1081
00:50:46,310 --> 00:50:52,310
and a fish okay

1082
00:50:50,360 --> 00:50:54,200
so yeah we're going back to auditing

1083
00:50:52,310 --> 00:50:56,750
cryptocurrency software if you want to

1084
00:50:54,200 --> 00:51:00,140
do that there is a lot of non templated

1085
00:50:56,750 --> 00:51:02,450
bugs in in this area some of the things

1086
00:51:00,140 --> 00:51:04,220
have been seen for the first time such

1087
00:51:02,450 --> 00:51:08,359
as these netsplit attacks and the

1088
00:51:04,220 --> 00:51:10,939
requirement of equivalence between you

1089
00:51:08,360 --> 00:51:13,490
know node implementations if we have a

1090
00:51:10,940 --> 00:51:16,010
small divergence between the Python and

1091
00:51:13,490 --> 00:51:18,350
a C++ implementation that's that's a bug

1092
00:51:16,010 --> 00:51:21,410
so I'm not sure if that that kind of

1093
00:51:18,350 --> 00:51:24,770
situation has been seen before yeah pick

1094
00:51:21,410 --> 00:51:28,970
your own your your your favorite coin

1095
00:51:24,770 --> 00:51:31,160
and and familiarize with with these with

1096
00:51:28,970 --> 00:51:34,069
issues and in in these areas that

1097
00:51:31,160 --> 00:51:38,000
Bitcoin went through and try to find

1098
00:51:34,070 --> 00:51:40,100
find them in your favorite coin yeah I

1099
00:51:38,000 --> 00:51:42,320
think these are references I'm happy if

1100
00:51:40,100 --> 00:51:47,020
anyone wants to collaborate on this I'll

1101
00:51:42,320 --> 00:51:47,020
be happy to the death yeah okay

1102
00:51:47,760 --> 00:51:53,089
[Applause]

