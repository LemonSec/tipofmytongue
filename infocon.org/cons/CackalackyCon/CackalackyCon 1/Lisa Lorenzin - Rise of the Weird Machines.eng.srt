1
00:00:00,000 --> 00:00:09,480
to be here so you will notice that my

2
00:00:06,950 --> 00:00:11,460
description of myself does not anywhere

3
00:00:09,480 --> 00:00:12,630
include the word coding programming

4
00:00:11,460 --> 00:00:14,820
anything like that

5
00:00:12,630 --> 00:00:16,590
I don't code and I'm here to talk to you

6
00:00:14,820 --> 00:00:18,029
about a coding topic so I'm gonna be a

7
00:00:16,590 --> 00:00:19,439
little more dependent on my speaker

8
00:00:18,029 --> 00:00:20,759
notes than usual because I really want

9
00:00:19,439 --> 00:00:22,859
to get this right because it's

10
00:00:20,760 --> 00:00:24,810
fascinating to me you can sort of think

11
00:00:22,859 --> 00:00:27,449
about this as somewhere between a book

12
00:00:24,810 --> 00:00:29,820
report and a love letter it's a bunch of

13
00:00:27,449 --> 00:00:32,579
conference talks and papers that other

14
00:00:29,820 --> 00:00:35,700
people did over probably a three to five

15
00:00:32,579 --> 00:00:37,739
year period and I stumbled across it and

16
00:00:35,700 --> 00:00:39,780
just got hooked it's completely outside

17
00:00:37,739 --> 00:00:41,760
of my swimlane so I'm really here to

18
00:00:39,780 --> 00:00:43,500
tell you about it and hopefully share

19
00:00:41,760 --> 00:00:48,360
that enthusiasm and get you hooked on it

20
00:00:43,500 --> 00:00:49,200
too in 2012 I went to a conference

21
00:00:48,360 --> 00:00:52,140
called shmoocon

22
00:00:49,200 --> 00:00:55,289
in DC who here's been to shmoocon yay

23
00:00:52,140 --> 00:00:58,109
it's excellent and when I go to shmoocon

24
00:00:55,289 --> 00:01:00,239
I make a point to try to go to talks

25
00:00:58,109 --> 00:01:01,530
that are not only talks that are

26
00:01:00,239 --> 00:01:03,390
relevant to me but talks that look like

27
00:01:01,530 --> 00:01:05,519
something I know nothing about I've seen

28
00:01:03,390 --> 00:01:07,890
some of my favorite talks that way the

29
00:01:05,519 --> 00:01:10,680
mainframe hacking talk this year I mean

30
00:01:07,890 --> 00:01:12,330
that again I don't think I've ever

31
00:01:10,680 --> 00:01:15,180
actually seen a mainframe and that's one

32
00:01:12,330 --> 00:01:17,729
of the best talks I've ever seen in 2012

33
00:01:15,180 --> 00:01:20,549
by far the best talk I saw was this talk

34
00:01:17,729 --> 00:01:24,470
on the science of insecurity Sergey

35
00:01:20,549 --> 00:01:27,540
Broadus and Meredith Patterson and their

36
00:01:24,470 --> 00:01:30,298
Co collaborator Len sassman was

37
00:01:27,540 --> 00:01:32,220
unfortunately not able to participate so

38
00:01:30,299 --> 00:01:34,740
the thing that they said that really

39
00:01:32,220 --> 00:01:37,979
struck me is that insecurity is really

40
00:01:34,740 --> 00:01:40,020
about computation so our trust in a

41
00:01:37,979 --> 00:01:42,990
computing system is really based on what

42
00:01:40,020 --> 00:01:44,789
that system we think that system can and

43
00:01:42,990 --> 00:01:47,070
can't compute if you make an assertion

44
00:01:44,790 --> 00:01:49,290
of trust you're asserting that it will

45
00:01:47,070 --> 00:01:51,779
do what you expect it to do will it

46
00:01:49,290 --> 00:01:53,720
expose your data will it be vulnerable

47
00:01:51,780 --> 00:01:58,380
to somebody getting a shell on it and

48
00:01:53,720 --> 00:02:00,869
the way that that takes form is each

49
00:01:58,380 --> 00:02:03,000
system receives input and it has to

50
00:02:00,869 --> 00:02:05,640
decide whether that input is good or bad

51
00:02:03,000 --> 00:02:08,038
does it accept the input and act on it

52
00:02:05,640 --> 00:02:10,378
or does it reject the input can you

53
00:02:08,038 --> 00:02:13,599
trust it to make that distinction and to

54
00:02:10,378 --> 00:02:15,548
only act on valid input

55
00:02:13,599 --> 00:02:18,879
when you start to think about it in this

56
00:02:15,549 --> 00:02:23,859
way what they said was that exploitation

57
00:02:18,879 --> 00:02:26,108
is unexpected computation so an exploit

58
00:02:23,859 --> 00:02:27,939
is at its core something that you run on

59
00:02:26,109 --> 00:02:30,909
a target and it causes the target to do

60
00:02:27,939 --> 00:02:36,579
something you didn't expect it is a

61
00:02:30,909 --> 00:02:38,709
program captured in input and there may

62
00:02:36,579 --> 00:02:40,329
be computational structures on the

63
00:02:38,709 --> 00:02:41,889
target that you created without

64
00:02:40,329 --> 00:02:46,480
intending or without even knowing they

65
00:02:41,889 --> 00:02:48,700
were there so I had been working in tech

66
00:02:46,480 --> 00:02:50,168
for over 15 years at that point and in

67
00:02:48,700 --> 00:02:53,560
information security for over a decade

68
00:02:50,169 --> 00:02:56,980
and that talk fundamentally changed my

69
00:02:53,560 --> 00:02:59,560
perception of cybersecurity I wanted to

70
00:02:56,980 --> 00:03:02,198
learn more about this and I mentioned in

71
00:02:59,560 --> 00:03:06,000
that talk another talk the previous year

72
00:03:02,199 --> 00:03:08,290
on dwarf which what the hell is that

73
00:03:06,000 --> 00:03:10,419
okay let's go find out and fortunately

74
00:03:08,290 --> 00:03:12,040
shmoocon god bless him puts all their

75
00:03:10,419 --> 00:03:14,500
talks online the shmoocon archive on

76
00:03:12,040 --> 00:03:16,328
archive.org is just one of the best

77
00:03:14,500 --> 00:03:17,530
things on the internet and so there's

78
00:03:16,329 --> 00:03:19,720
this talk about how dwarf is

79
00:03:17,530 --> 00:03:22,269
turing-complete I was a Medieval Studies

80
00:03:19,720 --> 00:03:24,790
major in college and I'm a huge Tolkien

81
00:03:22,269 --> 00:03:26,290
nerd so the fact that they translated

82
00:03:24,790 --> 00:03:28,689
they were so committed they translated

83
00:03:26,290 --> 00:03:30,728
their title slide into dwarven runes I

84
00:03:28,689 --> 00:03:31,930
am all about this I got completely

85
00:03:30,729 --> 00:03:33,280
sidetracked trying to see if I could

86
00:03:31,930 --> 00:03:35,889
still read it because at some point I

87
00:03:33,280 --> 00:03:37,120
could read Toki and dwarvish in line

88
00:03:35,889 --> 00:03:42,419
can't anymore

89
00:03:37,120 --> 00:03:45,609
umm untranslated they were talking about

90
00:03:42,419 --> 00:03:47,019
exploiting the hard-working dwarf again

91
00:03:45,609 --> 00:03:48,939
bear in mind I don't know what dwarf is

92
00:03:47,019 --> 00:03:50,829
their first slide was an executive

93
00:03:48,939 --> 00:03:52,659
summary I'm doing pretty well I'm

94
00:03:50,829 --> 00:03:55,949
hanging in there and then they start

95
00:03:52,659 --> 00:04:00,009
talking about bytecode and stacks and

96
00:03:55,949 --> 00:04:02,409
return to live C attacks I may have been

97
00:04:00,009 --> 00:04:04,988
working in tech for 15 years but I don't

98
00:04:02,409 --> 00:04:07,540
understand any of that right so I

99
00:04:04,989 --> 00:04:09,489
could have asked Mike my partner codes

100
00:04:07,540 --> 00:04:12,340
and he has answered my dumb questions

101
00:04:09,489 --> 00:04:14,109
for you know over two decades now but I

102
00:04:12,340 --> 00:04:17,108
figured I should probably go educate

103
00:04:14,109 --> 00:04:19,780
myself a little better first so they had

104
00:04:17,108 --> 00:04:21,849
also mentioned another talk which was

105
00:04:19,779 --> 00:04:24,729
given by how far flake at infiltrate

106
00:04:21,849 --> 00:04:26,889
2011 and by the way I'm going to put

107
00:04:24,729 --> 00:04:27,099
these slides up as a PDF somewhere it'll

108
00:04:26,889 --> 00:04:28,750
be

109
00:04:27,100 --> 00:04:30,340
either on the cackalacky Khan site or

110
00:04:28,750 --> 00:04:34,000
somewhere findable and all of these

111
00:04:30,340 --> 00:04:36,219
talks both the videos and very often the

112
00:04:34,000 --> 00:04:38,320
slides in PDF form and possibly even a

113
00:04:36,220 --> 00:04:39,940
paper that underlies it again all

114
00:04:38,320 --> 00:04:43,570
available so I've got all that in the

115
00:04:39,940 --> 00:04:44,680
slide notes and anything that I say that

116
00:04:43,570 --> 00:04:45,940
sounds interesting you can go and

117
00:04:44,680 --> 00:04:46,240
actually hear it from the people who did

118
00:04:45,940 --> 00:04:49,870
it

119
00:04:46,240 --> 00:04:51,160
by following those references so I'm

120
00:04:49,870 --> 00:04:53,050
getting a little farther this time I'm

121
00:04:51,160 --> 00:04:55,690
getting about every third word instead

122
00:04:53,050 --> 00:04:56,890
of completely not tracking I didn't

123
00:04:55,690 --> 00:04:58,630
really understand the details but the

124
00:04:56,890 --> 00:05:00,190
concepts are still fascinating and so

125
00:04:58,630 --> 00:05:01,810
what I want to do is I want to take you

126
00:05:00,190 --> 00:05:05,680
down the rabbit hole with me on these

127
00:05:01,810 --> 00:05:07,450
concepts anything interesting in these

128
00:05:05,680 --> 00:05:09,790
next few so these next few slides are my

129
00:05:07,450 --> 00:05:11,800
attempt to summarize the basics of the

130
00:05:09,790 --> 00:05:13,480
science of insecurity talk anything

131
00:05:11,800 --> 00:05:15,370
interesting in those slides comes from

132
00:05:13,480 --> 00:05:16,510
Meredith and Sergey and Len anything

133
00:05:15,370 --> 00:05:20,380
that doesn't make sense is my

134
00:05:16,510 --> 00:05:21,909
translation layer trust me one thing

135
00:05:20,380 --> 00:05:24,760
that we have to sort of have as a

136
00:05:21,910 --> 00:05:27,310
baseline is what turing-complete means

137
00:05:24,760 --> 00:05:28,800
so who in here is comfortable with the

138
00:05:27,310 --> 00:05:31,570
term turing-complete

139
00:05:28,800 --> 00:05:33,040
cool less than half the room I feel

140
00:05:31,570 --> 00:05:34,980
better because I didn't know what the

141
00:05:33,040 --> 00:05:38,590
hell it meant either so a Turing machine

142
00:05:34,980 --> 00:05:41,080
invented by Alan Turing is a theoretical

143
00:05:38,590 --> 00:05:43,690
computer and it's basically there's a

144
00:05:41,080 --> 00:05:45,550
tape that symbols are printed on that

145
00:05:43,690 --> 00:05:47,590
represent computing instructions and the

146
00:05:45,550 --> 00:05:49,780
tape can move forward and backward and

147
00:05:47,590 --> 00:05:52,119
the Machine can read the instructions

148
00:05:49,780 --> 00:05:53,890
and write the resulting output back onto

149
00:05:52,120 --> 00:05:56,740
the tape so it's a pretty simple concept

150
00:05:53,890 --> 00:05:59,110
but despite how simple this is

151
00:05:56,740 --> 00:06:03,880
a Turing machine can simulate any

152
00:05:59,110 --> 00:06:08,350
computer algorithm so a Turing complete

153
00:06:03,880 --> 00:06:10,719
system means a system in which a program

154
00:06:08,350 --> 00:06:12,730
can be written that will generate an

155
00:06:10,720 --> 00:06:15,610
answer when presented with a series of

156
00:06:12,730 --> 00:06:17,890
input so if a system is Turing complete

157
00:06:15,610 --> 00:06:19,990
it can be used to solve a computational

158
00:06:17,890 --> 00:06:21,370
problem and Turing complete systems

159
00:06:19,990 --> 00:06:24,550
appear in places that you really

160
00:06:21,370 --> 00:06:27,610
wouldn't expect them the thing that a

161
00:06:24,550 --> 00:06:30,820
Turing machine cannot do as it can't

162
00:06:27,610 --> 00:06:32,560
take another Turing machine and decide

163
00:06:30,820 --> 00:06:34,960
if that other machine will ever

164
00:06:32,560 --> 00:06:38,840
terminate it's called the halting

165
00:06:34,960 --> 00:06:42,500
problem and it's uncomputable

166
00:06:38,840 --> 00:06:44,659
so trying to decide an undecidable

167
00:06:42,500 --> 00:06:49,850
problem actually turns out to be the

168
00:06:44,660 --> 00:06:51,740
root of a lot of insecurities so this

169
00:06:49,850 --> 00:06:54,680
quote the illusion that your program is

170
00:06:51,740 --> 00:06:56,389
manipulating data is powerful but it's

171
00:06:54,680 --> 00:06:59,479
an illusion the data is actually

172
00:06:56,389 --> 00:07:03,560
controlling your program everything in

173
00:06:59,479 --> 00:07:05,710
our world of programs and software and

174
00:07:03,560 --> 00:07:08,990
things that run on computers is

175
00:07:05,710 --> 00:07:12,620
distributed it's composed so programs

176
00:07:08,990 --> 00:07:15,440
consist of many components flying in

177
00:07:12,620 --> 00:07:17,120
hopefully tight formation and these

178
00:07:15,440 --> 00:07:19,639
components have to do two things at a

179
00:07:17,120 --> 00:07:22,970
minimum the first thing they have to do

180
00:07:19,639 --> 00:07:25,430
is accept input and as a corollary they

181
00:07:22,970 --> 00:07:27,860
should reject input that isn't valid and

182
00:07:25,430 --> 00:07:30,289
then the second thing they have to do is

183
00:07:27,860 --> 00:07:34,340
when two programs communicate with each

184
00:07:30,289 --> 00:07:35,750
other you want the interpretation of

185
00:07:34,340 --> 00:07:38,599
that communication to be the same on

186
00:07:35,750 --> 00:07:42,020
both sides so if I say to Mike that the

187
00:07:38,600 --> 00:07:43,910
sky is blue and he walks away thinking

188
00:07:42,020 --> 00:07:46,990
the sky is green and goes and looks for

189
00:07:43,910 --> 00:07:50,750
a tornado shelter we have a problem and

190
00:07:46,990 --> 00:07:52,280
the way that programs determine the

191
00:07:50,750 --> 00:07:55,010
meaning of a message is with a parser

192
00:07:52,280 --> 00:07:56,510
and so you need to have parsers on both

193
00:07:55,010 --> 00:07:59,659
ends that interpret the input

194
00:07:56,510 --> 00:08:01,159
identically this is the point where you

195
00:07:59,660 --> 00:08:02,690
can start to have problems because if

196
00:08:01,160 --> 00:08:05,150
your parsers don't interpret those

197
00:08:02,690 --> 00:08:08,030
inputs identically then you may end up

198
00:08:05,150 --> 00:08:09,500
with state on one side that is not what

199
00:08:08,030 --> 00:08:12,020
is intended from what was sent on the

200
00:08:09,500 --> 00:08:13,490
other side or if it's an attack you may

201
00:08:12,020 --> 00:08:15,289
have state that is what's intended but

202
00:08:13,490 --> 00:08:16,669
it's not what you intended when you

203
00:08:15,289 --> 00:08:19,099
wrote the program to receive the message

204
00:08:16,669 --> 00:08:22,460
so input handling is one of the keys

205
00:08:19,099 --> 00:08:25,219
here is this input good is it valid or

206
00:08:22,460 --> 00:08:27,469
is it possibly harmful and checking

207
00:08:25,220 --> 00:08:30,650
input to validate it can be an

208
00:08:27,470 --> 00:08:33,979
unsolvable problem so again this is

209
00:08:30,650 --> 00:08:37,120
where we get in security so when you

210
00:08:33,979 --> 00:08:39,849
think about the concept that X runs on Y

211
00:08:37,120 --> 00:08:44,209
the obvious some the obvious ones are

212
00:08:39,849 --> 00:08:46,490
inputs execute on parsers it's not just

213
00:08:44,208 --> 00:08:48,609
that the parser is processing the input

214
00:08:46,490 --> 00:08:53,080
the input is executing on the parser

215
00:08:48,610 --> 00:08:57,460
packets execute on tcp/ip stacks

216
00:08:53,080 --> 00:09:00,980
malloc and free execute on Heep managers

217
00:08:57,460 --> 00:09:04,370
binary format metadata execute saan

218
00:09:00,980 --> 00:09:06,260
loaders and linkers and then page tables

219
00:09:04,370 --> 00:09:08,480
and global descriptor tables and

220
00:09:06,260 --> 00:09:09,080
interrupts descriptor tables execute on

221
00:09:08,480 --> 00:09:11,900
an MMU

222
00:09:09,080 --> 00:09:13,760
I hope you understand what all those

223
00:09:11,900 --> 00:09:17,090
words mean I understand a lot better

224
00:09:13,760 --> 00:09:22,330
than I did when I started but again this

225
00:09:17,090 --> 00:09:24,740
was kind of foreign to me this means or

226
00:09:22,330 --> 00:09:28,010
one of the one of the fundamental

227
00:09:24,740 --> 00:09:31,390
principles here is that inputs are a

228
00:09:28,010 --> 00:09:33,650
language they have a grammar and

229
00:09:31,390 --> 00:09:36,260
understanding what the grammar is of

230
00:09:33,650 --> 00:09:38,240
that language helps you to interpret the

231
00:09:36,260 --> 00:09:40,970
language helps you to first recognize it

232
00:09:38,240 --> 00:09:43,040
and then interpret it so if we break

233
00:09:40,970 --> 00:09:46,130
this down going back to the previous IP

234
00:09:43,040 --> 00:09:49,010
packets are a language they have nested

235
00:09:46,130 --> 00:09:51,080
structures they have length fields so

236
00:09:49,010 --> 00:09:51,950
they're weakly context-sensitive we'll

237
00:09:51,080 --> 00:09:54,590
get into that in a minute

238
00:09:51,950 --> 00:09:57,110
and the stack the IP stack is a

239
00:09:54,590 --> 00:10:01,190
recognizer at every layer for every

240
00:09:57,110 --> 00:10:03,920
protocol in servers like SQL servers

241
00:10:01,190 --> 00:10:06,800
valid requests make a language in memory

242
00:10:03,920 --> 00:10:09,890
managers heaps make a language in

243
00:10:06,800 --> 00:10:11,599
function call flow valid stacks make a

244
00:10:09,890 --> 00:10:13,699
language and we get context sensitivity

245
00:10:11,600 --> 00:10:17,270
again here because which bytes are data

246
00:10:13,700 --> 00:10:21,920
and which bytes are meta data so if you

247
00:10:17,270 --> 00:10:24,850
have more context then your program can

248
00:10:21,920 --> 00:10:28,880
handle you start to be in trouble

249
00:10:24,850 --> 00:10:30,500
because that means that the input you

250
00:10:28,880 --> 00:10:34,870
get may cause your program to do

251
00:10:30,500 --> 00:10:36,680
something you don't expect one of the

252
00:10:34,870 --> 00:10:38,420
indications you get from that is that

253
00:10:36,680 --> 00:10:40,370
the simpler the input language is and

254
00:10:38,420 --> 00:10:44,930
the less context you need to handle the

255
00:10:40,370 --> 00:10:47,980
input language the safer you are so how

256
00:10:44,930 --> 00:10:52,099
do we get there languages have hierarchy

257
00:10:47,980 --> 00:10:53,780
this is language theory Noam Chomsky not

258
00:10:52,100 --> 00:10:57,200
just programming languages but any kind

259
00:10:53,780 --> 00:11:01,280
of languages so a regular language has

260
00:10:57,200 --> 00:11:03,110
no context dependency it's very easy to

261
00:11:01,280 --> 00:11:06,020
work with if you have two regular

262
00:11:03,110 --> 00:11:08,330
expressions you can decide

263
00:11:06,020 --> 00:11:12,079
pretty easily whether they express the

264
00:11:08,330 --> 00:11:15,890
same language or not then you get a

265
00:11:12,080 --> 00:11:18,740
context-free language like Perl so you

266
00:11:15,890 --> 00:11:20,779
have a grouping thing Perl regular

267
00:11:18,740 --> 00:11:23,870
expressions can recurse on themselves

268
00:11:20,779 --> 00:11:28,189
and that gives them that makes them a

269
00:11:23,870 --> 00:11:30,290
context-free grammar context sensitive

270
00:11:28,190 --> 00:11:33,490
languages we're moving up the complexity

271
00:11:30,290 --> 00:11:37,099
levels they can refer to other parts of

272
00:11:33,490 --> 00:11:38,720
the tree so if you have a payload and it

273
00:11:37,100 --> 00:11:41,630
has a length that was specified earlier

274
00:11:38,720 --> 00:11:43,240
in the packet you have to refer back to

275
00:11:41,630 --> 00:11:45,500
that to make sure the length field

276
00:11:43,240 --> 00:11:47,870
specifies the same length as the payload

277
00:11:45,500 --> 00:11:50,959
you actually got a failure mode here is

278
00:11:47,870 --> 00:11:53,360
padding attacks and then recursively

279
00:11:50,959 --> 00:11:55,010
enumerable languages are the most

280
00:11:53,360 --> 00:11:59,930
complex types of languages and just

281
00:11:55,010 --> 00:12:03,080
don't go there so any sufficiently

282
00:11:59,930 --> 00:12:08,839
complex input is indistinguishable from

283
00:12:03,080 --> 00:12:11,540
bytecode again from that talk and magic

284
00:12:08,839 --> 00:12:14,300
and the corollary is that any code that

285
00:12:11,540 --> 00:12:19,339
takes that input is indistinguishable

286
00:12:14,300 --> 00:12:23,660
from a virtual machine so some languages

287
00:12:19,339 --> 00:12:26,000
are harder to recognize than others if

288
00:12:23,660 --> 00:12:28,760
you have a regular expression you have a

289
00:12:26,000 --> 00:12:31,820
finite state machine so you can express

290
00:12:28,760 --> 00:12:34,490
simple nesting but if you're trying to

291
00:12:31,820 --> 00:12:36,410
do something complicated you may need

292
00:12:34,490 --> 00:12:42,529
more complexity you may need to combine

293
00:12:36,410 --> 00:12:44,779
data so if you try to parse a more

294
00:12:42,529 --> 00:12:45,680
complex language with a regular

295
00:12:44,779 --> 00:12:46,510
expression you're going to get in

296
00:12:45,680 --> 00:12:50,120
trouble

297
00:12:46,510 --> 00:12:52,459
you can't with a regular expression you

298
00:12:50,120 --> 00:12:56,420
can't easily parse recursive nested

299
00:12:52,459 --> 00:12:59,300
structures so Internet Explorer 8 had a

300
00:12:56,420 --> 00:13:03,770
problem with a CSS module where they

301
00:12:59,300 --> 00:13:05,270
tried to build a protection tool but it

302
00:13:03,770 --> 00:13:07,010
was actually not complex enough to

303
00:13:05,270 --> 00:13:08,810
handle the inputs that it was receiving

304
00:13:07,010 --> 00:13:11,300
and so it created new vulnerabilities

305
00:13:08,810 --> 00:13:14,060
and when you're performing validation

306
00:13:11,300 --> 00:13:16,400
you have to make sure that you match up

307
00:13:14,060 --> 00:13:18,050
the strength of your validator with the

308
00:13:16,400 --> 00:13:19,850
strength of the input that it's getting

309
00:13:18,050 --> 00:13:23,689
regular with regular context

310
00:13:19,850 --> 00:13:27,800
with context-free etc so what happens

311
00:13:23,690 --> 00:13:29,660
when input recognition fails internal

312
00:13:27,800 --> 00:13:33,649
code gets something that it doesn't

313
00:13:29,660 --> 00:13:35,649
expect and primitives are exposed so you

314
00:13:33,649 --> 00:13:39,230
can get things like memory corruption

315
00:13:35,649 --> 00:13:42,230
implicit data flow or unexpected control

316
00:13:39,230 --> 00:13:42,920
flow so SQL injection is a recognizer

317
00:13:42,230 --> 00:13:46,190
failure

318
00:13:42,920 --> 00:13:48,949
what escapes the escape symbol being

319
00:13:46,190 --> 00:13:50,630
able to slip in and unescape the escape

320
00:13:48,949 --> 00:13:54,680
symbol is a failure of the recognizer

321
00:13:50,630 --> 00:13:57,529
and that is a language problem that's

322
00:13:54,680 --> 00:14:01,758
what leads to SQL injection in memory

323
00:13:57,529 --> 00:14:05,420
managers heap metadata exploits abuse

324
00:14:01,759 --> 00:14:07,550
the context sensitivity so heaps are

325
00:14:05,420 --> 00:14:09,529
complicated and they can be exploited if

326
00:14:07,550 --> 00:14:11,779
you can properly do metadata overrides

327
00:14:09,529 --> 00:14:12,620
and I love this this exploit technique

328
00:14:11,779 --> 00:14:16,370
is called

329
00:14:12,620 --> 00:14:18,470
heap feng-shui so Alexander Sedov that's

330
00:14:16,370 --> 00:14:20,540
who you research for that so in each of

331
00:14:18,470 --> 00:14:22,490
these cases the problem is that the

332
00:14:20,540 --> 00:14:25,370
piece of code looking into the data

333
00:14:22,490 --> 00:14:27,410
can't make a determination whether the

334
00:14:25,370 --> 00:14:30,920
next step is going to be correct in the

335
00:14:27,410 --> 00:14:33,620
context it's in there's context beyond

336
00:14:30,920 --> 00:14:35,779
what the code can handle buffer

337
00:14:33,620 --> 00:14:37,519
overflows overwriting return pointers on

338
00:14:35,779 --> 00:14:39,560
the stack this works because valid

339
00:14:37,519 --> 00:14:41,360
stacks are a language and the language

340
00:14:39,560 --> 00:14:43,399
is so complicated that to unwind the

341
00:14:41,360 --> 00:14:46,399
stack frames you really need a fully

342
00:14:43,399 --> 00:14:47,959
Turing complete virtual machine so this

343
00:14:46,399 --> 00:14:50,319
is what the door standard offers and

344
00:14:47,959 --> 00:14:54,920
this is where that 2011 talk comes in

345
00:14:50,319 --> 00:14:57,079
we'll get to that these failures result

346
00:14:54,920 --> 00:14:59,180
in the birth of a weird machine and a

347
00:14:57,079 --> 00:15:03,979
weird machine is a term that was coined

348
00:14:59,180 --> 00:15:07,250
I think in 2009 possibly but it's when

349
00:15:03,980 --> 00:15:09,500
you have a more powerful programmable

350
00:15:07,250 --> 00:15:12,620
execution environment than you think you

351
00:15:09,500 --> 00:15:15,199
do so input into a program drives

352
00:15:12,620 --> 00:15:18,620
changes in state in the input handlers

353
00:15:15,199 --> 00:15:20,089
and you have to be confident that those

354
00:15:18,620 --> 00:15:22,880
state changes are going to proceed in

355
00:15:20,089 --> 00:15:25,130
the way that you expect the structure of

356
00:15:22,880 --> 00:15:27,889
a program is such that some you have

357
00:15:25,130 --> 00:15:29,240
basic blocks that do recognition these

358
00:15:27,889 --> 00:15:32,089
are things like the parser the

359
00:15:29,240 --> 00:15:33,470
recognizer and then some things are some

360
00:15:32,089 --> 00:15:37,490
blocks are things you want to do

361
00:15:33,470 --> 00:15:41,030
so processing components when people

362
00:15:37,490 --> 00:15:42,920
write code I am told you don't really

363
00:15:41,030 --> 00:15:44,449
generally think about you're gonna parse

364
00:15:42,920 --> 00:15:45,380
you're gonna recognize everything first

365
00:15:44,450 --> 00:15:46,760
and then you're gonna parse it then

366
00:15:45,380 --> 00:15:49,340
you're gonna hand it off to the

367
00:15:46,760 --> 00:15:51,020
execution that you want code ends up

368
00:15:49,340 --> 00:15:52,790
getting written piecemeal and so you get

369
00:15:51,020 --> 00:15:53,990
a little bit of parsing here and a

370
00:15:52,790 --> 00:15:55,189
little bit of recognizing there and then

371
00:15:53,990 --> 00:15:56,360
it does something then you go back and

372
00:15:55,190 --> 00:15:58,100
parse the next bit then you recognize

373
00:15:56,360 --> 00:16:00,530
then you do something fragmentation

374
00:15:58,100 --> 00:16:02,090
attacks take advantage of that and so

375
00:16:00,530 --> 00:16:04,490
when you don't do all the checks that

376
00:16:02,090 --> 00:16:06,650
need to be done this is where you can

377
00:16:04,490 --> 00:16:10,210
have things like memory corruption so an

378
00:16:06,650 --> 00:16:14,030
expectation in the code is not fulfilled

379
00:16:10,210 --> 00:16:16,190
something unexpected happens and you get

380
00:16:14,030 --> 00:16:18,770
a weird machine so it's a more powerful

381
00:16:16,190 --> 00:16:22,360
computational structure and it's driven

382
00:16:18,770 --> 00:16:27,610
by this crafted input make sense so far

383
00:16:22,360 --> 00:16:31,610
cool oops that's the wrong direction so

384
00:16:27,610 --> 00:16:33,910
this is the fundamental message from the

385
00:16:31,610 --> 00:16:37,430
infiltrate 2011 talk exploitation is

386
00:16:33,910 --> 00:16:39,140
setting up instantiating and then

387
00:16:37,430 --> 00:16:42,890
executing a weird machine programming a

388
00:16:39,140 --> 00:16:46,220
weird machine vaguely understood input

389
00:16:42,890 --> 00:16:49,400
languages are then the mother of zero

390
00:16:46,220 --> 00:16:50,720
day because if you don't understand the

391
00:16:49,400 --> 00:16:53,030
input language you can't really

392
00:16:50,720 --> 00:16:56,000
determine whether it's a valid message

393
00:16:53,030 --> 00:16:58,130
and even if you understand the input

394
00:16:56,000 --> 00:17:00,500
language combining the flow of input

395
00:16:58,130 --> 00:17:02,600
handling and input processing opens you

396
00:17:00,500 --> 00:17:08,720
up to these problems so that's what how

397
00:17:02,600 --> 00:17:11,060
our Flake gets into and you get you lose

398
00:17:08,720 --> 00:17:14,380
the ability to expect secure computation

399
00:17:11,060 --> 00:17:18,109
from whatever program you're running

400
00:17:14,380 --> 00:17:21,170
Sergei brightest has on line a weird

401
00:17:18,109 --> 00:17:23,359
machines ooh I love that and he also has

402
00:17:21,170 --> 00:17:26,120
links to other collections like

403
00:17:23,359 --> 00:17:30,050
accidentally Turing complete and by the

404
00:17:26,119 --> 00:17:32,840
way the critter here there's a deviant

405
00:17:30,050 --> 00:17:34,909
art artist called a mechanical mind and

406
00:17:32,840 --> 00:17:36,560
that's where I swiped this image from so

407
00:17:34,910 --> 00:17:38,810
I want to give him credit and also say

408
00:17:36,560 --> 00:17:40,610
he has a million of these they're made

409
00:17:38,810 --> 00:17:46,250
out of watch pieces and they're

410
00:17:40,610 --> 00:17:47,300
beautiful so this principle applies all

411
00:17:46,250 --> 00:17:49,670
the way up and down

412
00:17:47,300 --> 00:17:52,300
the OSI model if we start at the bottom

413
00:17:49,670 --> 00:17:56,500
and we start at layer one

414
00:17:52,300 --> 00:18:02,000
Travis Goodspeed did a talk at route

415
00:17:56,500 --> 00:18:05,720
2011 and it was on packet in packet four

416
00:18:02,000 --> 00:18:08,090
layer one injection exploits so he

417
00:18:05,720 --> 00:18:10,400
called back to Orson Welles War of the

418
00:18:08,090 --> 00:18:12,679
Worlds how many of you are familiar with

419
00:18:10,400 --> 00:18:15,800
how War of the Worlds was introduced to

420
00:18:12,680 --> 00:18:18,740
the American public oh my god history

421
00:18:15,800 --> 00:18:21,770
and people I love it so it was a radio

422
00:18:18,740 --> 00:18:25,160
broadcast but it intentionally started

423
00:18:21,770 --> 00:18:26,960
after the station identification and the

424
00:18:25,160 --> 00:18:29,960
general announcements that you get that

425
00:18:26,960 --> 00:18:31,460
give you context so he was able to

426
00:18:29,960 --> 00:18:33,800
convince his listeners that they were

427
00:18:31,460 --> 00:18:35,360
listening to legitimate news broadcasts

428
00:18:33,800 --> 00:18:38,500
of an alien invasion rather than

429
00:18:35,360 --> 00:18:41,449
tonight's entertainment on the radio a

430
00:18:38,500 --> 00:18:44,660
packet in packet injection relies on the

431
00:18:41,450 --> 00:18:49,160
same principle you missed the start of a

432
00:18:44,660 --> 00:18:50,930
frame then what happens so ZigBee has

433
00:18:49,160 --> 00:18:53,510
packets with fields in the header and

434
00:18:50,930 --> 00:18:56,300
then a body and one of those header

435
00:18:53,510 --> 00:18:58,190
fields is a sink so you have a preamble

436
00:18:56,300 --> 00:19:01,070
then you have a sink then you have the

437
00:18:58,190 --> 00:19:03,410
body what happens if you put a sink in

438
00:19:01,070 --> 00:19:05,750
the body hardware doesn't know what to

439
00:19:03,410 --> 00:19:09,950
do about it that's not my job that's

440
00:19:05,750 --> 00:19:11,870
layer two so if a symbol error occurs in

441
00:19:09,950 --> 00:19:13,370
the preamble or the sink the receiver

442
00:19:11,870 --> 00:19:18,260
can also think that the body is a new

443
00:19:13,370 --> 00:19:20,419
packet you end up being able to embed a

444
00:19:18,260 --> 00:19:23,180
packet in a packet and do something

445
00:19:20,420 --> 00:19:25,850
unexpected encryption actually

446
00:19:23,180 --> 00:19:28,070
eliminates this problem because clearly

447
00:19:25,850 --> 00:19:31,250
you're making a clean differentiation

448
00:19:28,070 --> 00:19:33,590
between the header and the body so if

449
00:19:31,250 --> 00:19:35,800
you can attack layer 1 in packet radio

450
00:19:33,590 --> 00:19:39,409
where else can you do it

451
00:19:35,800 --> 00:19:42,379
how about Ethernet same principle

452
00:19:39,410 --> 00:19:44,180
applies it's a fairly esoteric technique

453
00:19:42,380 --> 00:19:49,300
you have to have custom hardware to

454
00:19:44,180 --> 00:19:52,180
execute it but the concept still holds

455
00:19:49,300 --> 00:19:57,350
moving up the stack

456
00:19:52,180 --> 00:19:59,000
layer-3 this is a great paper this is

457
00:19:57,350 --> 00:20:02,330
the part where I start to understand it

458
00:19:59,000 --> 00:20:06,530
thank you but they showed that they can

459
00:20:02,330 --> 00:20:08,960
map between BGP and a logic circuit they

460
00:20:06,530 --> 00:20:11,690
can create simple networks with routers

461
00:20:08,960 --> 00:20:14,660
that have basic BGP configurations that

462
00:20:11,690 --> 00:20:17,240
simulate logic gates clocks and

463
00:20:14,660 --> 00:20:21,830
flip-flops and you can interconnect that

464
00:20:17,240 --> 00:20:24,470
to create circuits so under reasonable

465
00:20:21,830 --> 00:20:25,250
assumptions on message timing BGP can be

466
00:20:24,470 --> 00:20:29,270
turing-complete

467
00:20:25,250 --> 00:20:31,970
and so they have a new method for

468
00:20:29,270 --> 00:20:35,290
studying the complexity of analyzing BGP

469
00:20:31,970 --> 00:20:38,240
configurations and exploiting this

470
00:20:35,290 --> 00:20:40,370
they're also saying a few other things

471
00:20:38,240 --> 00:20:43,520
that I don't care about but the idea

472
00:20:40,370 --> 00:20:47,419
here is we find turing completeness in

473
00:20:43,520 --> 00:20:52,990
the most unexpected places the really

474
00:20:47,420 --> 00:20:58,970
cool stuff is at layer 7 so this was a

475
00:20:52,990 --> 00:21:01,790
presentation at woot 2013 and the TL DR

476
00:20:58,970 --> 00:21:05,240
is that rebecca shapiro created a turing

477
00:21:01,790 --> 00:21:07,550
machine in linux from relocation data in

478
00:21:05,240 --> 00:21:10,190
an elf file so elf is the executable and

479
00:21:07,550 --> 00:21:12,680
linking file format and basically she

480
00:21:10,190 --> 00:21:17,660
hid code in the elf metadata for ping

481
00:21:12,680 --> 00:21:19,640
and got a root shell so this elf format

482
00:21:17,660 --> 00:21:21,830
is basically everywhere it's run

483
00:21:19,640 --> 00:21:24,710
whenever processes are set up and

484
00:21:21,830 --> 00:21:27,710
serviced or dynamically linked and the

485
00:21:24,710 --> 00:21:30,190
loader can be tricked into performing

486
00:21:27,710 --> 00:21:32,990
computation by presenting it with

487
00:21:30,190 --> 00:21:36,710
well-formed but crafted elf

488
00:21:32,990 --> 00:21:40,280
metadata so that metadata and symbol

489
00:21:36,710 --> 00:21:43,970
table entries can act as instructions to

490
00:21:40,280 --> 00:21:46,160
cause the linker loader to perform

491
00:21:43,970 --> 00:21:50,360
arbitrary computation and they actually

492
00:21:46,160 --> 00:21:52,070
had a proof of concept of constructing

493
00:21:50,360 --> 00:21:54,530
elf metadata that implemented

494
00:21:52,070 --> 00:21:57,230
turing-complete brain-fuck language

495
00:21:54,530 --> 00:22:00,560
primitives also anyone who names their

496
00:21:57,230 --> 00:22:03,380
language that gets points and they were

497
00:22:00,560 --> 00:22:06,100
able to use that to insert a back door

498
00:22:03,380 --> 00:22:11,539
into an executable

499
00:22:06,100 --> 00:22:17,990
the dwarf talked 2011 at shmoocon what

500
00:22:11,539 --> 00:22:20,240
they did is dwarf bytecode is exception

501
00:22:17,990 --> 00:22:22,940
handling so all GCC compiled binaries

502
00:22:20,240 --> 00:22:25,279
have this and it describes the stack

503
00:22:22,940 --> 00:22:27,320
frame layout and it's interpreted to

504
00:22:25,279 --> 00:22:30,830
unwind the stack after an exception

505
00:22:27,320 --> 00:22:32,389
occurs so a process image will include

506
00:22:30,830 --> 00:22:35,360
the interpreter for the dwarf bytecode

507
00:22:32,390 --> 00:22:37,039
and it can be written to have the

508
00:22:35,360 --> 00:22:38,840
interpreter perform almost any

509
00:22:37,039 --> 00:22:41,690
computation so it can also be turing

510
00:22:38,840 --> 00:22:43,610
complete so Dorf expressions are

511
00:22:41,690 --> 00:22:47,149
essentially functioning like assembly

512
00:22:43,610 --> 00:22:49,908
language and the computation works like

513
00:22:47,149 --> 00:22:52,158
an RPM calculator so you can backdoor a

514
00:22:49,909 --> 00:22:54,140
program such that the program works

515
00:22:52,159 --> 00:22:57,679
normally until an exception is thrown

516
00:22:54,140 --> 00:22:59,450
and then you can return from that

517
00:22:57,679 --> 00:23:01,850
exception anywhere in the program with

518
00:22:59,450 --> 00:23:05,000
control over most of the registers so

519
00:23:01,850 --> 00:23:07,250
this means you can modify no executable

520
00:23:05,000 --> 00:23:09,309
or normal program data and you can still

521
00:23:07,250 --> 00:23:13,779
hijack the exceptions to get a shell

522
00:23:09,309 --> 00:23:16,510
I'm very cool page fault Liberation Army

523
00:23:13,779 --> 00:23:20,029
again people with a sense of humor

524
00:23:16,510 --> 00:23:23,870
Julian Bangert he created a Turing

525
00:23:20,029 --> 00:23:26,029
machine in the x86 MMU by way of address

526
00:23:23,870 --> 00:23:27,649
translation and he has a demo on github

527
00:23:26,029 --> 00:23:31,880
you can fly a glider around a screen

528
00:23:27,649 --> 00:23:34,428
so trust analysis basically determining

529
00:23:31,880 --> 00:23:37,549
whether a computer will not execute some

530
00:23:34,429 --> 00:23:39,679
classes of computation generally assumes

531
00:23:37,549 --> 00:23:42,408
that computation is captured by an

532
00:23:39,679 --> 00:23:44,899
instruction trace and what he showed is

533
00:23:42,409 --> 00:23:47,450
that computation is possible on x86

534
00:23:44,899 --> 00:23:51,469
processors without executing any CPU

535
00:23:47,450 --> 00:23:53,240
instructions so it's driven solely by

536
00:23:51,470 --> 00:23:55,909
the interrupt handling and memory

537
00:23:53,240 --> 00:23:58,010
translation tables the processor gets

538
00:23:55,909 --> 00:24:00,020
trapped in a series of page faults and

539
00:23:58,010 --> 00:24:02,210
double faults without successfully

540
00:24:00,020 --> 00:24:04,610
dispatching any instructions and the

541
00:24:02,210 --> 00:24:07,309
hardwired logic of handling those faults

542
00:24:04,610 --> 00:24:10,668
is used to perform the computation as

543
00:24:07,309 --> 00:24:12,950
well as memory reads and writes so they

544
00:24:10,669 --> 00:24:14,840
can even use this to perform branches

545
00:24:12,950 --> 00:24:17,570
and loops if the memory is set up and

546
00:24:14,840 --> 00:24:19,620
mapped perfectly so it's a proof by

547
00:24:17,570 --> 00:24:20,790
construction that the intel mmm use

548
00:24:19,620 --> 00:24:23,219
fault handling mechanism is

549
00:24:20,790 --> 00:24:26,159
turing-complete and they constructed an

550
00:24:23,220 --> 00:24:28,500
assembler that translated move branch if

551
00:24:26,160 --> 00:24:31,110
zero and decrement in structures into

552
00:24:28,500 --> 00:24:33,720
instructions into c source set up the

553
00:24:31,110 --> 00:24:36,030
processor control tables and the cpu

554
00:24:33,720 --> 00:24:40,410
computes by attempting default without

555
00:24:36,030 --> 00:24:42,149
ever executing a single instruction the

556
00:24:40,410 --> 00:24:44,130
one thing all of these have in common so

557
00:24:42,150 --> 00:24:46,170
far other than being weird machines is

558
00:24:44,130 --> 00:24:49,590
that they're all six to eight years old

559
00:24:46,170 --> 00:24:52,710
so these papers and talks were from 2011

560
00:24:49,590 --> 00:24:56,129
to 2013 and I thought you know surely

561
00:24:52,710 --> 00:25:01,890
it's six eight years later this is a

562
00:24:56,130 --> 00:25:04,770
solved problem by now right nope this is

563
00:25:01,890 --> 00:25:09,300
the 2018 mer sec keynote December of

564
00:25:04,770 --> 00:25:11,610
2018 I might add same guy oh by the way

565
00:25:09,300 --> 00:25:12,780
Thomas Dillion is Hoffer flake talking

566
00:25:11,610 --> 00:25:15,178
about the same thing he was talking

567
00:25:12,780 --> 00:25:19,500
about in 2011 so apparently this is

568
00:25:15,179 --> 00:25:21,290
still relevant there are people looking

569
00:25:19,500 --> 00:25:23,730
at how to address these problems and

570
00:25:21,290 --> 00:25:27,178
suggesting how to deal with them and

571
00:25:23,730 --> 00:25:31,020
that is the language theoretic security

572
00:25:27,179 --> 00:25:33,840
crowd or Lang SEC for short and they

573
00:25:31,020 --> 00:25:35,700
have a wonderful single page overview

574
00:25:33,840 --> 00:25:37,409
which I have completely ripped off so

575
00:25:35,700 --> 00:25:42,170
everything on the next five or six

576
00:25:37,410 --> 00:25:42,170
slides is from Lang SEC org slash occupy

577
00:25:42,920 --> 00:25:49,440
so the fundamental step zero is full

578
00:25:46,830 --> 00:25:51,379
recognition before processing every

579
00:25:49,440 --> 00:25:54,630
piece of software that takes inputs

580
00:25:51,380 --> 00:25:57,000
contains a recognizer for accepting

581
00:25:54,630 --> 00:25:59,850
valid or expected inputs and rejecting

582
00:25:57,000 --> 00:26:01,679
invalid or malicious ones and this code

583
00:25:59,850 --> 00:26:04,409
is often spread throughout the program

584
00:26:01,679 --> 00:26:06,510
and interspersed with the processing

585
00:26:04,410 --> 00:26:09,860
logic they call that a shotgun parser by

586
00:26:06,510 --> 00:26:12,330
an alligator shotgun debugging so this

587
00:26:09,860 --> 00:26:14,250
means you have a tendency to

588
00:26:12,330 --> 00:26:15,949
exploitation and it makes programmers

589
00:26:14,250 --> 00:26:18,570
have false assumptions of data security

590
00:26:15,950 --> 00:26:22,490
the way to solve that is do your

591
00:26:18,570 --> 00:26:22,490
recognizing then do your processing

592
00:26:22,550 --> 00:26:27,600
another step here is to reduce the

593
00:26:25,500 --> 00:26:30,780
computing power needed to handle your

594
00:26:27,600 --> 00:26:33,350
inputs if you're implementing a program

595
00:26:30,780 --> 00:26:34,879
that accepts SQL queries and you

596
00:26:33,350 --> 00:26:38,260
know that you're only going to use a

597
00:26:34,880 --> 00:26:41,240
subset of the available SQL queries then

598
00:26:38,260 --> 00:26:42,830
write your recognition your validator to

599
00:26:41,240 --> 00:26:45,080
only accept those queries if you're

600
00:26:42,830 --> 00:26:47,210
never gonna do an administrative delete

601
00:26:45,080 --> 00:26:50,870
or something like that then that's not a

602
00:26:47,210 --> 00:26:54,559
valid input you want to make sure that

603
00:26:50,870 --> 00:26:57,320
you use as low a protocol that's as low

604
00:26:54,559 --> 00:26:59,600
on the language hierarchy as possible if

605
00:26:57,320 --> 00:27:01,850
you can use a regular protocol a lack of

606
00:26:59,600 --> 00:27:03,469
protocol that's regular do it if you

607
00:27:01,850 --> 00:27:05,360
can't use something that's context-free

608
00:27:03,470 --> 00:27:06,799
if you have to use something that's

609
00:27:05,360 --> 00:27:13,299
context-sensitive make sure you

610
00:27:06,799 --> 00:27:13,299
understand the implications of that so

611
00:27:13,539 --> 00:27:19,520
the other thing here is when you

612
00:27:17,110 --> 00:27:23,059
generate what you're going to send and

613
00:27:19,520 --> 00:27:26,000
receive generate your parser out of the

614
00:27:23,059 --> 00:27:30,340
grammar for the language itself so

615
00:27:26,000 --> 00:27:32,659
instead of writing it fairly loosely

616
00:27:30,340 --> 00:27:34,189
take the grammar generate the parser

617
00:27:32,659 --> 00:27:37,580
from there and then validate your input

618
00:27:34,190 --> 00:27:40,610
based on that with fixed length strings

619
00:27:37,580 --> 00:27:43,149
like an IP address you could parse that

620
00:27:40,610 --> 00:27:46,850
with a reg X you really wouldn't want to

621
00:27:43,150 --> 00:27:49,490
so you need to figure out where you are

622
00:27:46,850 --> 00:27:51,620
and use a validator that matches that

623
00:27:49,490 --> 00:27:53,380
level of complexity so regular

624
00:27:51,620 --> 00:27:56,120
expressions have a finite state machine

625
00:27:53,380 --> 00:27:59,720
infinite recursion like XML or HTML

626
00:27:56,120 --> 00:28:02,658
requires a context-free language context

627
00:27:59,720 --> 00:28:04,370
sensitive languages you need a linear

628
00:28:02,659 --> 00:28:06,350
bounded parser

629
00:28:04,370 --> 00:28:08,479
it's a Turing machine with a finite tape

630
00:28:06,350 --> 00:28:10,730
so it's still decidable the thing you

631
00:28:08,480 --> 00:28:13,039
want to avoid when you're validating

632
00:28:10,730 --> 00:28:15,500
your language is trying to compute an

633
00:28:13,039 --> 00:28:18,020
uncomputable problem if you're trying to

634
00:28:15,500 --> 00:28:20,510
decide whether javascript is valid the

635
00:28:18,020 --> 00:28:23,059
only way to really do that is to execute

636
00:28:20,510 --> 00:28:24,500
it or for someone to look at it by hand

637
00:28:23,059 --> 00:28:29,230
and figure out what it's going to do you

638
00:28:24,500 --> 00:28:31,850
can't decide that with a validator so

639
00:28:29,230 --> 00:28:32,929
program protocols and file formats that

640
00:28:31,850 --> 00:28:35,899
are turing-complete

641
00:28:32,929 --> 00:28:39,200
input languages are really dangerous and

642
00:28:35,900 --> 00:28:42,110
this is where you lose security if you

643
00:28:39,200 --> 00:28:44,840
can avoid using a fully

644
00:28:42,110 --> 00:28:46,790
context-sensitive or recursively

645
00:28:44,840 --> 00:28:51,050
enumerable languages should

646
00:28:46,790 --> 00:28:52,639
and then the other thing is try to make

647
00:28:51,050 --> 00:28:54,080
sure that the protocol you're using is

648
00:28:52,640 --> 00:28:56,270
going to be interpreted the same way on

649
00:28:54,080 --> 00:28:58,639
one side is on the other side and this

650
00:28:56,270 --> 00:29:01,040
comes back to some work that Meredith

651
00:28:58,640 --> 00:29:05,540
and I think Len did and maybe Dan

652
00:29:01,040 --> 00:29:07,570
Kaminsky in like the lead 2009-2010

653
00:29:05,540 --> 00:29:10,940
frame time frame around x.509 and

654
00:29:07,570 --> 00:29:16,720
certificates if you can request a

655
00:29:10,940 --> 00:29:19,360
certificate signed by a CA that is WWE

656
00:29:16,720 --> 00:29:23,810
pal com no bite

657
00:29:19,360 --> 00:29:26,479
WWE Volcom and get that signed then when

658
00:29:23,810 --> 00:29:29,540
you present that certificate is it going

659
00:29:26,480 --> 00:29:31,850
to be interpreted as WWE Volcom or WWE

660
00:29:29,540 --> 00:29:33,889
PayPal com different parsers may

661
00:29:31,850 --> 00:29:35,990
interpret it differently so they went

662
00:29:33,890 --> 00:29:38,570
through and pulled a whole bunch of

663
00:29:35,990 --> 00:29:41,150
similar bugs out of x.509 because of

664
00:29:38,570 --> 00:29:44,450
different interpretations as well as

665
00:29:41,150 --> 00:29:46,250
poorly scoped inputs and they said they

666
00:29:44,450 --> 00:29:49,420
stopped when they got bored they didn't

667
00:29:46,250 --> 00:29:52,070
stop because they ran out of bugs so

668
00:29:49,420 --> 00:29:55,910
again the other thing to bear in mind is

669
00:29:52,070 --> 00:29:59,570
that if you have ambiguous context-free

670
00:29:55,910 --> 00:30:02,240
grammars or context sensitive and above

671
00:29:59,570 --> 00:30:03,800
then you can't decide whether the two

672
00:30:02,240 --> 00:30:04,850
parsers are equivalent you can't decide

673
00:30:03,800 --> 00:30:08,750
whether the message is going to be

674
00:30:04,850 --> 00:30:12,070
interpreted the same way so pastels

675
00:30:08,750 --> 00:30:15,680
principle at the birth of the internet

676
00:30:12,070 --> 00:30:19,550
he said be conservative in what you send

677
00:30:15,680 --> 00:30:21,770
be liberal in what you accept and this

678
00:30:19,550 --> 00:30:23,419
is how the Internet came into being this

679
00:30:21,770 --> 00:30:26,750
is why things can talk to each other

680
00:30:23,420 --> 00:30:29,300
today but it's also why the internet

681
00:30:26,750 --> 00:30:32,660
works the way it does today and they

682
00:30:29,300 --> 00:30:35,960
proposed a patch for pastels principle

683
00:30:32,660 --> 00:30:39,550
which is be conservative in what you

684
00:30:35,960 --> 00:30:43,370
send but be definite in what you accept

685
00:30:39,550 --> 00:30:45,710
the goal here is to do secure software

686
00:30:43,370 --> 00:30:50,000
design and to avoid a lot of these

687
00:30:45,710 --> 00:30:53,540
issues there's a really good overview

688
00:30:50,000 --> 00:30:55,190
that Meredith gave in 2013 what had been

689
00:30:53,540 --> 00:30:58,040
done and obviously looking into the

690
00:30:55,190 --> 00:31:00,200
future and it's a tour of various

691
00:30:58,040 --> 00:31:03,680
projects that are implemented

692
00:31:00,200 --> 00:31:07,100
and different tools for language

693
00:31:03,680 --> 00:31:10,540
theoretic security that's a great video

694
00:31:07,100 --> 00:31:13,909
as well and the timeline that she builds

695
00:31:10,540 --> 00:31:16,280
goes you know over probably five or six

696
00:31:13,910 --> 00:31:20,150
different years of projects ranging from

697
00:31:16,280 --> 00:31:22,030
web server implementations to simpler

698
00:31:20,150 --> 00:31:27,470
parsers that can be dropped into other

699
00:31:22,030 --> 00:31:30,020
coding projects that group is on the

700
00:31:27,470 --> 00:31:33,080
Lange sect org website and they've been

701
00:31:30,020 --> 00:31:37,870
holding Lange sack workshops at the I

702
00:31:33,080 --> 00:31:42,949
Triple E security and privacy meetings

703
00:31:37,870 --> 00:31:44,989
symposiums for ninety-five years we

704
00:31:42,950 --> 00:31:47,690
can't count quickly six years these are

705
00:31:44,990 --> 00:31:50,240
a wealth of interesting information the

706
00:31:47,690 --> 00:31:52,520
keynote by dan gear so I'm a Dan gear

707
00:31:50,240 --> 00:31:54,800
groupie I will read anything dan gear

708
00:31:52,520 --> 00:31:57,470
writes on any subject he has the

709
00:31:54,800 --> 00:32:00,620
wonderful habit of putting his keynotes

710
00:31:57,470 --> 00:32:03,260
and talks in clear text on his website

711
00:32:00,620 --> 00:32:06,260
and about every six months I go to his

712
00:32:03,260 --> 00:32:09,470
website and see what's new that keynote

713
00:32:06,260 --> 00:32:14,000
is amazing the DARPA keynote from 2018

714
00:32:09,470 --> 00:32:15,890
is also fascinating and this in addition

715
00:32:14,000 --> 00:32:18,140
to the Proceedings of the workshops they

716
00:32:15,890 --> 00:32:20,270
also have links to all of these

717
00:32:18,140 --> 00:32:22,160
different talks and to a variety of

718
00:32:20,270 --> 00:32:24,500
tools that have been developed so if you

719
00:32:22,160 --> 00:32:26,960
would like to learn more about weird

720
00:32:24,500 --> 00:32:33,130
machines and how to handle them this is

721
00:32:26,960 --> 00:32:33,130
the way to do that that's what I've got

722
00:32:33,180 --> 00:32:38,440
[Applause]

