1
00:00:04,690 --> 00:00:24,430
alright as today we're going to be
talking about arm firmware reverse

2
00:00:24,430 --> 00:00:31,300
engineering the DA here is that you have
a small embedded system we're talking

3
00:00:31,300 --> 00:00:35,469
something too small to run the next or
Android something that has no memory

4
00:00:35,469 --> 00:00:41,409
management unit but is still running the
ARM architecture arm is also used by

5
00:00:41,409 --> 00:00:49,359
Android by phone by some of the
Chromebooks and and so there's lots of

6
00:00:49,359 --> 00:00:55,839
open source tools that you can use
forearm on the bigger system that also

7
00:00:55,839 --> 00:01:00,280
apply to things that you might find in
the smaller system they can aid you in

8
00:01:00,280 --> 00:01:06,549
reverse engineering so this specific
example that i'm going to be using is a

9
00:01:06,549 --> 00:01:11,560
ham radio a handheld digital ham radio
that I've been reverse engineering show

10
00:01:11,560 --> 00:01:14,110
hands how many of you have
reverse-engineered something from China

11
00:01:14,110 --> 00:01:17,110
malware does not count

12
00:01:17,710 --> 00:01:28,899
ok few hands get up and so I took a
chinese amateur radio and i started

13
00:01:28,900 --> 00:01:34,690
writing linux tools for it and as I was
writing them at some point i typed in

14
00:01:34,690 --> 00:01:39,610
the the commands wrong and instead of
sending me back a copy of its settings

15
00:01:39,610 --> 00:01:43,480
and sent me back the beginning of
firmware it turned out this was a no

16
00:01:43,480 --> 00:01:48,730
pointer dereference read that was
unindexed which was exploitable and can

17
00:01:48,730 --> 00:01:54,850
be used to dump out the firmware the
firmware dump could be used to turn jtag

18
00:01:54,850 --> 00:02:01,960
back on jtag could be used to dump a
complete copy of all of the firmware x

19
00:02:01,960 --> 00:02:05,890
ordering the complete copy of all of the
firmware with the encrypted from her

20
00:02:05,890 --> 00:02:12,250
update gave me a a clear text key that I
could use to encrypt and decrypt any

21
00:02:12,250 --> 00:02:16,700
other former image and and then by
reverse engineering some patching it

22
00:02:16,700 --> 00:02:22,399
i was able to add new features so we
have a phone book of all 35,000 amateur

23
00:02:22,400 --> 00:02:27,860
radio users of the DMR protocol that is
held inside of the radio that we have an

24
00:02:27,860 --> 00:02:33,500
incoming call you see the name callsign
city state and country of the the party

25
00:02:33,500 --> 00:02:35,150
on the other line

26
00:02:35,150 --> 00:02:38,690
this protocol is internationally trunked
so you can make calls between countries

27
00:02:38,690 --> 00:02:44,420
it's not yet popular in Serbia but it's
very popular in the United States in

28
00:02:44,420 --> 00:02:50,958
france in south africa and it when it
reaches a heavy sigh doorbell glad

29
00:02:50,959 --> 00:02:54,709
you'll be able to make calls to all of
these countries without a cellphone and

30
00:02:54,709 --> 00:03:00,230
without any commercial infrastructure
and since i started the project I was

31
00:03:00,230 --> 00:03:10,190
joined by Apollo is GD four CR alex daf
8 AV and David ab3 TL in the United

32
00:03:10,190 --> 00:03:14,480
States my call sign is kilo for Victor
Charlie Zulu but here in Serbia that's

33
00:03:14,480 --> 00:03:21,138
why use / kilo kilo for Victor Charlie
Zulu as i'm roaming and the purpose of

34
00:03:21,139 --> 00:03:23,870
this lecture today is not to talk about
the ham radio

35
00:03:23,870 --> 00:03:26,600
although i love the ham radio and I
would be happy to talk about that a lot

36
00:03:26,600 --> 00:03:28,340
after the lecture

37
00:03:28,340 --> 00:03:31,970
the purpose is to actually talk about
how you reverse engineer these embedded

38
00:03:31,970 --> 00:03:37,970
systems because I've already reversed
engineered this radio and the only

39
00:03:37,970 --> 00:03:41,480
reason you would give a damn about it is
a target is to add new features to this

40
00:03:41,480 --> 00:03:45,319
product of this project which you're
free to do all of the code is on github

41
00:03:45,319 --> 00:03:50,420
and we welcome new contributions but
that's not why you're in the audience

42
00:03:50,420 --> 00:03:53,450
today you're in the audience here today
because you want to learn how to do this

43
00:03:53,450 --> 00:03:58,700
on your own machine your own target
hardware that I've never heard of so the

44
00:03:58,700 --> 00:04:04,399
the tricks that will be talking about
our sort of designed to work on other

45
00:04:04,400 --> 00:04:11,269
targets and i'm going to be teaching you
how to extract from where through a null

46
00:04:11,269 --> 00:04:16,548
pointer dereference that is unindexed
and only a read this is not explainable

47
00:04:16,548 --> 00:04:23,419
on desktop linux or mac or windows but
it's very often exploitable on embedded

48
00:04:23,419 --> 00:04:28,880
arm because embedded arm likes to put a
copy of the code address 0 so it's legal

49
00:04:28,880 --> 00:04:29,680
to read from

50
00:04:29,680 --> 00:04:33,280
address 0 whenever you have Malik
returning zero and you try to read from

51
00:04:33,280 --> 00:04:36,460
it you got a copy of the firmware
whenever you write to that the rights

52
00:04:36,460 --> 00:04:41,650
are silently ignored which is a very
convenient way to rip software out of

53
00:04:41,650 --> 00:04:45,580
protective devices i'm going to teach
you how to reverse engineer and embedded

54
00:04:45,580 --> 00:04:51,490
USB stack how to reverse engineer weird
networking protocols in my case the DMR

55
00:04:51,490 --> 00:04:58,210
or digital mobile radio protocol is used
for voice and for text messaging and it

56
00:04:58,210 --> 00:05:06,310
the it's weird it has three bite
addresses so it has 1 256 the number of

57
00:05:06,310 --> 00:05:12,580
addresses that ipv4 has if we all try
really hard we can fill it up there are

58
00:05:12,580 --> 00:05:17,500
only 24 million to go around i'll be
teaching you how to recognize io

59
00:05:17,500 --> 00:05:22,120
addresses and the few like constant
points of reference that you have an

60
00:05:22,120 --> 00:05:26,229
embedded system because you don't have
similar names they're not included in

61
00:05:26,229 --> 00:05:31,300
the firmware as it's written into the
device i'll also be talking about China

62
00:05:31,300 --> 00:05:36,370
and how great it is to reverse engineer
Chinese things for example in if your

63
00:05:36,370 --> 00:05:40,120
reverse engineering the Western product
and you want a copy of the schematic

64
00:05:40,120 --> 00:05:41,590
diagram

65
00:05:41,590 --> 00:05:45,039
well you have to take apart the board
you have to sand it down you have to

66
00:05:45,039 --> 00:05:48,370
photographic you have to recover the
photographs that's a lot of work if you

67
00:05:48,370 --> 00:05:52,360
want to reverse-engineer a Chinese
product you write an email to the

68
00:05:52,360 --> 00:05:56,320
manufacturer and you say hey david said
that I could have a copy of this could

69
00:05:56,320 --> 00:06:02,800
you please email it to me and they will
also be talking about how to port

70
00:06:02,800 --> 00:06:07,539
symbols between different from our
versions when you're writing and

71
00:06:07,539 --> 00:06:12,940
maintaining patches to something as
opposed to doing like a a one-off patch

72
00:06:12,940 --> 00:06:18,009
or a brief product you you need to be
able to upgrade your patches to work on

73
00:06:18,009 --> 00:06:22,960
new versions and the more functions you
tie into the more labor that involves so

74
00:06:22,960 --> 00:06:27,219
you would very much like to automate it
and it turns out that fermented arm it's

75
00:06:27,220 --> 00:06:32,470
very easy to automate the symbol
conversions and and then you know you

76
00:06:32,470 --> 00:06:37,419
need test cases you need to be able to
ensure that your code still works on

77
00:06:37,419 --> 00:06:40,799
every version without manual testing
without having to

78
00:06:40,800 --> 00:06:47,789
you booted up and exercise every feature
for this it turns out that Linux is

79
00:06:47,789 --> 00:06:52,830
awesome because qmo allows you to run
for inland executables look for other

80
00:06:52,830 --> 00:06:58,650
architectures so you can make an arm
linux binary and then run it on amd64 as

81
00:06:58,650 --> 00:07:03,330
is without any changes and i'll be
teaching you how to do these things in

82
00:07:03,330 --> 00:07:09,719
the course of the lecture the radio that
I'm using is this model it's the high

83
00:07:09,720 --> 00:07:17,430
Tara md 380 when you when you transmit
with this model it transmits either

84
00:07:17,430 --> 00:07:23,460
analog or digital and you can hit an
analog repeater or a digital repeater

85
00:07:23,460 --> 00:07:28,318
into the digital repeater you can send
compressed audio using half of the time

86
00:07:28,319 --> 00:07:37,169
slots you can have two conversations on
the same radio repeater it transmits

87
00:07:37,169 --> 00:07:41,340
with five watts this is a hell of a lot
more powerful than any Wi-Fi card you've

88
00:07:41,340 --> 00:07:42,448
ever had

89
00:07:42,449 --> 00:07:48,930
you don't really need a yogi or direct
line of sight to the tower this is the

90
00:07:48,930 --> 00:07:55,650
sort of thing that you would have in a
taxi cab or handheld police radio and

91
00:07:55,650 --> 00:08:00,120
with that much power you get coverage
indoors so even though there's only one

92
00:08:00,120 --> 00:08:06,690
tower in the city and that tower is
rather far away and the tower itself is

93
00:08:06,690 --> 00:08:10,710
blocked by all of these walls by the
infrastructure of the building if i

94
00:08:10,710 --> 00:08:19,109
transmit you'll actually hear the tower
come back and if I said hello they would

95
00:08:19,110 --> 00:08:25,889
say hello back and legally I probably
should have just identified myself now

96
00:08:25,889 --> 00:08:30,000
you can do either digital or analog
traffic the analog is done for backward

97
00:08:30,000 --> 00:08:34,169
compatibility which is how it connects
to the tower that's been here for a

98
00:08:34,169 --> 00:08:39,510
dozen years the digital towers are
rather knew they were originally used

99
00:08:39,510 --> 00:08:46,050
for broke police departments and four
universities and dump trucks and that

100
00:08:46,050 --> 00:08:51,029
sort of stuff but now that the cheap
radios are available they're filtering

101
00:08:51,029 --> 00:08:52,060
down

102
00:08:52,060 --> 00:08:57,520
two amateur use you can take a test of
the local amateur radio club get a

103
00:08:57,520 --> 00:09:01,540
license and hop on the air and freely
use this is a replacement for cellphones

104
00:09:01,540 --> 00:09:09,459
the hardware in this device is the stm32
f 405 which is a 32-bit arm core it does

105
00:09:09,460 --> 00:09:13,540
not run the arm instruction set it runs
a reduced instruction set called thumb

106
00:09:13,540 --> 00:09:21,160
and your are your cell phones which are
armed run both instruction sets and the

107
00:09:21,160 --> 00:09:24,760
way that they know which is which is
that if the program counter is odd

108
00:09:25,270 --> 00:09:30,670
it runs some code and if it's even it
runs arm code and this way you can have

109
00:09:30,670 --> 00:09:36,550
two instruction sets simultaneously
existing inside of the same program you

110
00:09:36,550 --> 00:09:40,599
can bounce back and forth between
individual functions it has one megabyte

111
00:09:40,600 --> 00:09:46,060
of flash it has two different regions of
ram one of them is 128 kilobytes and the

112
00:09:46,060 --> 00:09:50,979
other is 64 kilobytes combined you got a
hundred ninety-two but the c compiler

113
00:09:50,980 --> 00:09:55,210
really doesn't like randomly split up
this way so it only knows how to

114
00:09:55,210 --> 00:10:00,400
allocate it in one region or the other
by the linking script and the radio

115
00:10:00,400 --> 00:10:07,750
baseband is a custom Chinese designed a6
chip called the d5000 this is different

116
00:10:07,750 --> 00:10:13,900
from the Texas designed c5000 ship which
is unrelated and you sort of give it

117
00:10:13,900 --> 00:10:19,810
either your audio frame or your data
frame during the time when it's not

118
00:10:19,810 --> 00:10:24,280
transmitting and then in the other half
of the time it does the transmission and

119
00:10:24,280 --> 00:10:28,390
the opposite and reception but you
always using that idle time and in this

120
00:10:28,390 --> 00:10:31,930
way you can have two conversations
running at once but the radio is only

121
00:10:31,930 --> 00:10:35,920
able to participate in one of them so
you're not going to get stereo sound or

122
00:10:35,920 --> 00:10:40,120
to be able to transmit and receive in
the same conversation at the same time

123
00:10:40,120 --> 00:10:44,140
so you have to physically push the
button to transmit and release it to

124
00:10:44,140 --> 00:10:50,500
receive it also has 16 megabytes of SBI
flash and the reason why they use 16

125
00:10:50,500 --> 00:10:55,209
megabytes of SBI flash is that a 16
megabytes chip is a lot cheaper than the

126
00:10:55,209 --> 00:11:00,969
one megabyte ship that they designed the
firmware for so 15 megabytes or unused

127
00:11:00,970 --> 00:11:04,540
and this is where we store things like
our caller ID database in order

128
00:11:05,040 --> 00:11:13,139
to display all of the incoming contacts
and a network for this protocol is very

129
00:11:13,139 --> 00:11:20,130
large this is a map of Tennessee which
is where I'm from in the middle is

130
00:11:20,130 --> 00:11:26,399
nashville which is sort of like our
Belgrad and toward the right in the

131
00:11:26,399 --> 00:11:30,509
middle of that big green area is
knoxville which is our best city and are

132
00:11:30,509 --> 00:11:34,949
equivalent of Nova sod it's like a
university town with very good beer and

133
00:11:34,949 --> 00:11:35,939
friendly people

134
00:11:35,940 --> 00:11:42,720
although most of the turbo folk concerts
are in the bigger city to the west and

135
00:11:42,720 --> 00:11:49,290
CA this network has six hours they're
bigger networks of course but through

136
00:11:49,290 --> 00:11:52,980
these six towers you can transmit to any
one of them and be heard through the

137
00:11:52,980 --> 00:11:58,529
others so i have my friend josh's in
Nashville if I'm a knoxville I can

138
00:11:58,529 --> 00:12:01,529
transmit to my local repeater and it
will route that traffic through the

139
00:12:01,529 --> 00:12:06,329
internet and he will hear me on the
other side you can do either group calls

140
00:12:06,329 --> 00:12:11,819
or private calls and you can also do
text messaging the radio supports

141
00:12:11,819 --> 00:12:16,949
cryptography but not very good
cryptography and of particular interest

142
00:12:16,949 --> 00:12:24,689
is that the audio cable the pronounced
which I show here also contains USB and

143
00:12:24,690 --> 00:12:29,339
it's not a USB to serial chip like many
other amateur videos its actual us be

144
00:12:29,339 --> 00:12:33,269
implemented on the stm32 you can
reprogram this ship to do mass storage

145
00:12:33,269 --> 00:12:37,199
pretend to be a printer or hard disk or
whatever else you like you could boot

146
00:12:37,199 --> 00:12:39,300
from it if you cared to

147
00:12:39,300 --> 00:12:46,529
so as part of my reverse engineering i
wanted to figure out how to capture

148
00:12:46,529 --> 00:12:51,449
packets for there is no packet sniffing
hardware available when I began this

149
00:12:51,449 --> 00:12:56,189
project so i wrote a series of python
script combined with firmware patches

150
00:12:56,189 --> 00:13:00,569
that allow you to do things like a dump
text messages this is a text message

151
00:13:00,569 --> 00:13:08,160
that i sent from one radio to another
and the the contents of it is a ski with

152
00:13:08,160 --> 00:13:14,339
a couple of access marks so it's 16 bit
wide ask instead of a bit wide ascii but

153
00:13:14,339 --> 00:13:18,209
it's not encrypted even if you enable
encryption for the channel the

154
00:13:18,720 --> 00:13:22,680
hi Tara radios the ones that I've been
reverse engineering leave all of the

155
00:13:22,680 --> 00:13:29,849
encrypted traffic cleartext the same
thing happens with audio for all of the

156
00:13:29,850 --> 00:13:35,310
metadata so even if you couldn't break
the crypto you would still see what my

157
00:13:35,310 --> 00:13:39,420
source address was and what my
destination address was if that's not

158
00:13:39,420 --> 00:13:44,939
enough a lot of the very most common
audio frame that you get is actually the

159
00:13:44,939 --> 00:13:52,439
silence frame and the cryptography is it
wasn't designed to be this way but in

160
00:13:52,439 --> 00:13:58,769
practice it's a very secretive algorithm
called exclusive or and so if you just

161
00:13:58,769 --> 00:14:01,560
explore with the Silent Spring which is
also zero zeros

162
00:14:01,560 --> 00:14:06,569
you can recover the audio and I also
wanted to be able to communicate with

163
00:14:06,569 --> 00:14:11,610
this radio like from my phone as i'm
wandering around right

164
00:14:11,610 --> 00:14:16,379
I didn't want to have to have a laptop
to do all of this so i wrote an Android

165
00:14:16,379 --> 00:14:22,470
application you can see this blurry
photograph here and the the android

166
00:14:22,470 --> 00:14:28,980
application is actually able to do
everything that the the desktop software

167
00:14:28,980 --> 00:14:34,170
we do so you can reprogram the radio you
can dump out the frames it still work in

168
00:14:34,170 --> 00:14:37,740
progress but as soon as this is finished
it will be publicly available in the app

169
00:14:37,740 --> 00:14:44,339
store for free and you'll be able to
have your crappy andrade phone talk to

170
00:14:44,339 --> 00:14:52,769
your radio now in in reverse engineering
software for a pc you have a lot of

171
00:14:52,769 --> 00:14:56,850
advantages that you don't actually get
on the radio or on the embedded system

172
00:14:56,850 --> 00:15:00,089
one of these is that when you reverse
engineering something on a desktop

173
00:15:00,089 --> 00:15:05,009
almost always you get a copy of the
executable for free and if you don't get

174
00:15:05,009 --> 00:15:10,920
a copy of the executable for free then
you get it through a nun packers you at

175
00:15:10,920 --> 00:15:15,420
some point there is a process which you
can rip out of your operating system and

176
00:15:15,420 --> 00:15:19,860
your operating system will help you to
do it in embedded systems you don't have

177
00:15:19,860 --> 00:15:25,680
a copy of the code you only have the
physical device and it has a USB port or

178
00:15:25,680 --> 00:15:30,388
maybe a serial for that you can talk to
but it's usually defended so they will

179
00:15:30,389 --> 00:15:31,920
lock jtag

180
00:15:31,920 --> 00:15:36,120
so you can't connect a debugger they
will lock the bootloader so you're not

181
00:15:36,120 --> 00:15:42,269
allowed to read anything out until you
erase everything by favorite method for

182
00:15:42,269 --> 00:15:46,410
ripping former out of these devices is
to exploit the bootloader and my second

183
00:15:46,410 --> 00:15:50,459
favorite method is to exploit the
regular application through an unindexed

184
00:15:50,459 --> 00:15:56,459
null pointer read a note . read is when
you have a pointer to address 0 and the

185
00:15:56,459 --> 00:16:02,609
software reads from that address and
gives you the result on windows or on

186
00:16:02,610 --> 00:16:08,010
linux there's a guard page address 0 and
if you try to read from it it will

187
00:16:08,010 --> 00:16:13,439
trigger a segmentation fault and your
program will crash on embedded systems

188
00:16:13,440 --> 00:16:18,300
it doesn't do that because there's no
memory management unit to actually

189
00:16:18,300 --> 00:16:21,180
trigger the crash

190
00:16:21,180 --> 00:16:27,209
so what happens when you read from zero
is whatever the hell the chip defaults

191
00:16:27,209 --> 00:16:35,399
to and to make it very convenient for
compiler writers arm embedded arm maps a

192
00:16:35,399 --> 00:16:39,839
duplicate copy of flash to address zeros
if you read from it you got a copy of

193
00:16:39,839 --> 00:16:47,310
the flash so you have this uninitialized
pointer that sticks to address 0 on

194
00:16:47,310 --> 00:16:52,349
Windows is a trigger a fault but on and
in order to explain it on windows you

195
00:16:52,350 --> 00:16:57,300
need an offset you need to be able to
say no no i didn't want 20 i want the 16

196
00:16:57,300 --> 00:17:02,160
million item in the array that begins at
zero and that will read for far enough

197
00:17:02,160 --> 00:17:09,089
up in the cortex m4 because this is this
uninitialized buffer . 20 that you can

198
00:17:09,089 --> 00:17:16,438
read from flash which is normally at
0800 and change gets duplicated here and

199
00:17:16,439 --> 00:17:22,169
if you read from it you get a copy of it
so no pointer pages don't actually

200
00:17:22,169 --> 00:17:25,260
trigger fault when you read them they
give you a copy of the code and you can

201
00:17:25,260 --> 00:17:28,860
recognize that it's the code because it
begins with the interrupt vector table

202
00:17:28,860 --> 00:17:34,260
which is a series of addresses for the
interrupt handlers preceded by the

203
00:17:34,260 --> 00:17:39,690
initial stack pointer the initial stack
pointer is always in ram the interrupt

204
00:17:39,690 --> 00:17:44,340
handlers are always in flash and they're
always thumb code so you wind up with

205
00:17:45,000 --> 00:17:52,620
a single number that's above 2000 and
change and is even followed by many

206
00:17:52,620 --> 00:18:03,600
numbers that are at 0800 and change at
all odd so the radios speaks a semi

207
00:18:03,600 --> 00:18:07,409
standard protocol club dfu or the USB
device firmware update protocol

208
00:18:07,950 --> 00:18:14,880
this is the same protocol that was
exploited in the iphone 3g for the lime

209
00:18:14,880 --> 00:18:19,320
rain-x plate so when people to jailbreak
their iphones they would exploit the

210
00:18:19,320 --> 00:18:23,580
same protocol that we're exploiting here
and the protocol allows you to read and

211
00:18:23,580 --> 00:18:28,470
write memory pages but there are
multiple memories that you read from so

212
00:18:28,470 --> 00:18:32,850
in the end III 80 implementation for the
radio that I'm attacking you can

213
00:18:32,850 --> 00:18:36,209
actually specify which radio you'd like
to read from and if you don't specify

214
00:18:36,210 --> 00:18:42,270
any than it defaults to address 0 so the
port buffer is null and when you read

215
00:18:42,270 --> 00:18:43,170
out of it

216
00:18:43,170 --> 00:18:48,420
it begins at zero and the maximum amount
you can read is 48 kilobytes it just so

217
00:18:48,420 --> 00:18:54,960
happens that the first 48 kilobytes are
the bootloader the decrypt the main

218
00:18:54,960 --> 00:18:58,920
firmer image this is even better than
having a copy of the main former image

219
00:18:58,920 --> 00:19:03,660
because this is the code that actually
decrypt it and it's also the code that's

220
00:19:03,660 --> 00:19:09,600
responsible for locking jtag so i can
change one bite of this program right it

221
00:19:09,600 --> 00:19:15,270
back into a fresh brand-new chip and
have the exact same bootloader with the

222
00:19:15,270 --> 00:19:20,010
exact same behavior and the only
difference is that it never locks do

223
00:19:20,010 --> 00:19:23,910
buggers out so that i can install the
firmware update attached to bugger and

224
00:19:23,910 --> 00:19:28,980
read out a copy of all of the code be
allowing me to read all of the firmware

225
00:19:28,980 --> 00:19:37,890
so I had a friend of mine visit town she
comes to town I give her a copy the code

226
00:19:37,890 --> 00:19:44,400
base and in the course of a couple of
days she realized that the firmware

227
00:19:44,400 --> 00:19:50,190
update was using AES encounter mode
counter mode is where you use the aes

228
00:19:50,190 --> 00:19:55,260
encryption algorithm as a random number
generator and then you XOR those random

229
00:19:55,260 --> 00:19:55,950
numbers

230
00:19:55,950 --> 00:20:00,720
with the data that you want to keep
secret the bug was that they repeated

231
00:20:00,720 --> 00:20:08,010
the position in that random number
stream every 512 bits so for every block

232
00:20:08,010 --> 00:20:11,760
of memory that was being read or written
they were exploring it with the exact

233
00:20:11,760 --> 00:20:17,220
same key string so if you just explored
one block of this from the encrypted

234
00:20:17,220 --> 00:20:23,730
firmware update with the unencrypted
former update you would get the key and

235
00:20:23,730 --> 00:20:26,580
then you could explore that with
anything else to encrypt and decrypt it

236
00:20:26,580 --> 00:20:32,490
same operation and and this allows you
to then decrypt the official updates

237
00:20:32,490 --> 00:20:36,000
from the manufacturer and Riaan crypt
them to run

238
00:20:37,169 --> 00:20:41,429
I'd like to resign your own code so that
will be installed by the official

239
00:20:41,429 --> 00:20:46,590
factory update protocol and firmware so
at this stage we no longer need to

240
00:20:46,590 --> 00:20:50,340
modify the hardware or use our own
hardware we can just reuse the existing

241
00:20:50,340 --> 00:20:56,970
manufacturer hardware and software and
protocols but it's at this stage that

242
00:20:56,970 --> 00:21:01,950
you need to begin reverse engineering it
so like how do you find the useful

243
00:21:01,950 --> 00:21:07,200
useful parts and how do you figure out
what they do and then having found them

244
00:21:07,200 --> 00:21:11,820
like how do you make changes to them so
that your code instead of their code

245
00:21:11,820 --> 00:21:16,950
runs at just the critical portions for
example you might find the function that

246
00:21:16,950 --> 00:21:22,559
matches an address and then attach that
to accept all addresses in order to

247
00:21:22,559 --> 00:21:27,149
enable promiscuous mode which is you'll
recall from Wi-Fi was pretty fucking

248
00:21:27,149 --> 00:21:33,120
handi and actually being able to exploit
vulnerabilities and Wi-Fi that prior to

249
00:21:33,120 --> 00:21:36,120
$MONTH 2006 we're kind of untouchable

250
00:21:36,720 --> 00:21:42,659
the first thing you need to know is
where things are in memory and unlike

251
00:21:42,659 --> 00:21:49,860
unix or windows where you have a a
varying memory layout / process with

252
00:21:49,860 --> 00:21:53,729
address basic layout randomization
moving things around on an embedded

253
00:21:53,730 --> 00:21:59,070
system everything is stuck in a fixed
physical address and there is no such

254
00:21:59,070 --> 00:22:04,649
thing as virtual memory so all of the
i/o ports when you read from the serial

255
00:22:04,649 --> 00:22:09,209
port when you write to a serial port
when you access the USB controller

256
00:22:09,210 --> 00:22:15,539
are all of those addresses begin with a
four and most of your ram begins with

257
00:22:15,539 --> 00:22:20,309
the two except for a smaller region of
faster ram that begins with a 1 the

258
00:22:20,309 --> 00:22:25,200
faster ram is called tightly coupled ram
it's connected directly to the data

259
00:22:25,200 --> 00:22:31,380
fetch bus and I the data fetch caching
so it's actually faster to read from

260
00:22:31,380 --> 00:22:37,020
them the SRAM is but it's not connected
to the instruction path so you can't

261
00:22:37,020 --> 00:22:45,570
actually execute this code and you can't
DMAA so if you try to for example send a

262
00:22:45,570 --> 00:22:49,559
USB packet out of tightly coupled ram it
doesn't work you have to send it out of

263
00:22:49,559 --> 00:22:55,020
it out of SRAM and all of those begin
with one if it begins with the 08 it's

264
00:22:55,020 --> 00:23:10,110
in flash the bootloader is from 0800 40
oz 208 00 c 3 zeros at 0800 see thousand

265
00:23:10,110 --> 00:23:14,279
you have the actual application this is
the piece that we're interested in

266
00:23:14,279 --> 00:23:20,010
changing because all of the code at this
address is what runs after the radio has

267
00:23:20,010 --> 00:23:26,010
turned on the the bootloader is only
involved in from our updates and in the

268
00:23:26,010 --> 00:23:32,610
initial startup process in either pro
which is hellishly expensive but very

269
00:23:32,610 --> 00:23:34,740
effective

270
00:23:34,740 --> 00:23:41,370
all you need to do is get a copy of the
firmer dump loaded into a process and

271
00:23:41,370 --> 00:23:48,120
then tell it that it should have ram add
the location ram should be so in this

272
00:23:48,120 --> 00:23:52,289
screenshot I'm telling Ida that ram
starts at two thousand and change

273
00:23:52,289 --> 00:24:01,260
hexadecimal and that rom starts at 0800
see 000 and then I give it a copy of the

274
00:24:01,260 --> 00:24:05,250
binary firmware image that I've
extracted from a firmware update by

275
00:24:05,250 --> 00:24:10,320
doing these 3 firmware update i can use
the manufacturers own publicly released

276
00:24:10,320 --> 00:24:15,418
files and I never have to leak any
confidential information myself or

277
00:24:15,419 --> 00:24:18,419
extract this information from a physical
device

278
00:24:20,260 --> 00:24:27,700
and now Ida probably is very very
expensive and there's a free competitor

279
00:24:27,700 --> 00:24:34,210
to it called Rivera to and there was a
conference these past few days in

280
00:24:34,210 --> 00:24:38,890
Barcelona where they were all the
developers of it are two got together

281
00:24:38,890 --> 00:24:42,910
and added new features there is some
tricky pieces to it the first is that

282
00:24:42,910 --> 00:24:49,600
you have to run today's version because
they fix bugs every single day every

283
00:24:49,600 --> 00:24:53,139
time you sit down at your laptop you
grab a new version and then you build it

284
00:24:53,140 --> 00:24:58,600
and then you run it and it's used from
the command line with an optional web

285
00:24:58,600 --> 00:24:59,500
interface

286
00:24:59,500 --> 00:25:04,810
this is the command that will load my
firmware dump as a 16-bit image to the

287
00:25:04,810 --> 00:25:13,690
correct address as an arm application
now the first thing that you need to do

288
00:25:13,690 --> 00:25:18,610
is you need to find useful functions if
we were on a pc application we would

289
00:25:18,610 --> 00:25:23,260
look for things like printf maybe hunt
all of the printing of error messages

290
00:25:23,260 --> 00:25:27,640
and then work our way backwards in order
to figure out which functions called

291
00:25:27,640 --> 00:25:33,580
them and what those functions do it in
embedded systems you don't have error

292
00:25:33,580 --> 00:25:38,919
messages if it crashes it crashes and
touch it but when you can track our the

293
00:25:38,920 --> 00:25:45,370
i/o addresses so i know that all of the
i/o addresses begin with a four and I i

294
00:25:45,370 --> 00:25:49,149
have a complete listing of all of them
from stmicroelectronics is the

295
00:25:49,150 --> 00:25:56,410
manufacturer of the cpu and he's the
same for also all units of that cpu so i

296
00:25:56,410 --> 00:26:02,200
know that the flash controller begins at
40 2300 and I know that the flash

297
00:26:02,200 --> 00:26:10,000
protection register which disables the
right protect field is at 400 23 c15 so

298
00:26:10,000 --> 00:26:17,530
if I search through all of memory for an
access to 400 23 c15 I know that that

299
00:26:17,530 --> 00:26:22,420
function is being used to either enable
the right protection or disable the

300
00:26:22,420 --> 00:26:26,860
right protection of the flash its parent
function is probably disabling the

301
00:26:26,860 --> 00:26:28,830
protection and then

302
00:26:28,830 --> 00:26:33,779
writing the flash and then re-enabling
the protection there are similar

303
00:26:33,779 --> 00:26:41,190
features for the serial port more recent
models of this have a gps receiver in

304
00:26:41,190 --> 00:26:43,679
order to get the GPS coordinates

305
00:26:43,679 --> 00:26:49,649
well that gps receiver is connected over
a serial port and by looking for the

306
00:26:49,649 --> 00:26:57,120
serial ports address i can identify all
of the gps code you can also look for

307
00:26:57,120 --> 00:27:02,219
unique mask so this is a 32-bit
architecture every register is 32 bits

308
00:27:02,220 --> 00:27:10,919
wide but the DMR protocol uses 24-bit
addresses so it has to mask off the

309
00:27:10,919 --> 00:27:16,559
biggest fight whenever it's reading and
address out of memory so i can identify

310
00:27:16,559 --> 00:27:21,779
everything that involves the addressing
in this unique networking protocol just

311
00:27:21,779 --> 00:27:30,419
by looking for all of the code that
contains 0 x0 0 FF FF and there's

312
00:27:30,419 --> 00:27:34,139
similar masks for other features when
you have something that's maybe a 7-bit

313
00:27:34,139 --> 00:27:40,080
field you'll see a mask again 7f and
this allows you to identify all of that

314
00:27:40,080 --> 00:27:48,090
code now you can also look for
particularly awkward implementations of

315
00:27:48,090 --> 00:27:52,139
things because you have multiple authors
who write libraries and then those

316
00:27:52,139 --> 00:27:57,029
libraries are statically linked to
create one former image for example DMR

317
00:27:57,029 --> 00:28:03,539
uses a proprietary audio compression
codec called an b+ to there are lots of

318
00:28:03,539 --> 00:28:07,769
hard feelings about this audio codec
because even though the patents have

319
00:28:07,769 --> 00:28:11,250
expired the company has made pretty
clear that they will sue anyone who

320
00:28:11,250 --> 00:28:17,490
doesn't give them a licensing fee so
we'd be really handy to understand this

321
00:28:17,490 --> 00:28:25,049
Kodak or maybe we re implement it now md
functions use shorts 16-bit fields in

322
00:28:25,049 --> 00:28:29,460
order to store bits and they do this
because someone when writing the code

323
00:28:29,460 --> 00:28:33,210
created an array of shorts because that
was particularly efficient on his

324
00:28:33,210 --> 00:28:38,880
architecture on this architecture not so
efficient there are better ways to do it

325
00:28:38,880 --> 00:28:40,999
but that's still the way that it was
done

326
00:28:40,999 --> 00:28:46,129
so any code that's actually referencing
an array of shorts is probably related

327
00:28:46,129 --> 00:28:50,208
to the imac codec because there's no
other reason to use an array of shorts

328
00:28:50,209 --> 00:28:56,419
you can also look through memory find
every array in which all of the four

329
00:28:56,419 --> 00:29:06,109
byte as are all the to bite fields are
zeros or 0001 and anything that touches

330
00:29:06,109 --> 00:29:16,908
that data is the audio codec it's also
handy to reverse-engineer the USB stack

331
00:29:16,909 --> 00:29:25,399
so the USB socket is by a different
author than the audio codec and the main

332
00:29:25,399 --> 00:29:30,948
application and they used a nifty trick
here which was that they they took the

333
00:29:30,949 --> 00:29:36,769
example USB stack from the manufacturer
and then they reuse that when you do

334
00:29:36,769 --> 00:29:40,669
this the source code is available so
unlike the rest of the radio you can

335
00:29:40,669 --> 00:29:46,249
actually go to stmicroelectronics
website and get a copy of the example

336
00:29:46,249 --> 00:29:52,279
that was forked for this project this
then tells you how its architected all

337
00:29:52,279 --> 00:29:55,279
of the data structures it gives you the
header files

338
00:29:56,029 --> 00:29:59,719
it's lovely for reverse engineering so
you see that the handlers are function

339
00:29:59,719 --> 00:30:04,609
pointers function pointer called
functions are sort of like

340
00:30:04,609 --> 00:30:09,228
misinterpreted by idea pro android ARA
to in that they're they're not called

341
00:30:09,229 --> 00:30:13,369
buy anything so the audio analyzer won't
find them so you just look at the gap

342
00:30:13,369 --> 00:30:20,509
between functions and that's where your
USB handlers are and so in order to find

343
00:30:20,509 --> 00:30:20,899
them

344
00:30:20,899 --> 00:30:25,549
you searched through ram for pointers to
flash memory you'll find these four

345
00:30:25,549 --> 00:30:29,839
things like graphics because you know if
you have a sprite you want to a pointer

346
00:30:29,839 --> 00:30:34,668
to the sprite a sprite will be in
read-only memory and but the the

347
00:30:34,669 --> 00:30:42,349
functions are data and the spur so the
functions are code and the the sprites

348
00:30:42,349 --> 00:30:46,519
are data data is that an even a dress
code is that an odd address in this

349
00:30:46,519 --> 00:30:51,319
architecture to use that to throw away
all of the data references and give you

350
00:30:51,319 --> 00:30:53,810
only the function pointers and all of
the function

351
00:30:53,810 --> 00:31:01,970
your targets once you get a dump of ram
you can also look through the d compiled

352
00:31:01,970 --> 00:31:06,110
code after you've identified these
functions and look for the one-bite

353
00:31:06,110 --> 00:31:11,149
commands that are used in their
implementation of the USB device from

354
00:31:11,150 --> 00:31:14,930
the update protocol so in my case I know
that there are special manufacturer

355
00:31:14,930 --> 00:31:22,490
commands for 2141 a 291 and ce4 well how
many functions in this code base

356
00:31:22,490 --> 00:31:27,950
reference all five of those bites
separately in if statements turns out

357
00:31:27,950 --> 00:31:34,010
there's only one the decompiler is able
to identify that and show me all of the

358
00:31:34,010 --> 00:31:39,530
code that references these regions you
can also do you

359
00:31:39,530 --> 00:31:43,970
we also need to do function hooking
because once you've identified the USB

360
00:31:43,970 --> 00:31:48,470
stack you don't want to make minor
changes to it in assembly language

361
00:31:48,470 --> 00:31:53,810
because that is a ton of labor and it's
not portable between versions what you

362
00:31:53,810 --> 00:31:59,060
would much rather do is write your
changes in sea so what you do is you

363
00:31:59,060 --> 00:32:03,409
rewrite all of the function calls to run
to your version instead of the

364
00:32:03,410 --> 00:32:08,930
manufacturers version now for runtime
function pointers like the USB stack

365
00:32:08,930 --> 00:32:14,960
there is a 4-byte address in RAM and you
just need to change those four bytes 2.2

366
00:32:14,960 --> 00:32:18,920
your function instead of the original
and what you usually do is you'll have

367
00:32:18,920 --> 00:32:22,190
an if statement to see if you should
manage that function and if not you run

368
00:32:22,190 --> 00:32:30,470
it over to the manufacturer's version
and this for non function pointer calls

369
00:32:30,470 --> 00:32:36,800
when they actually have the machine code
to call the particular address in thon

370
00:32:36,800 --> 00:32:40,850
these are done through the BL
instruction or branch and Link branch

371
00:32:40,850 --> 00:32:45,350
link is secretly to instructions in a
row the first which loads the upper part

372
00:32:45,350 --> 00:32:49,850
of the address in the second which loads
the lower part and the alignments a

373
00:32:49,850 --> 00:32:55,429
little bit confusing and but you can
write a two three lines of see that will

374
00:32:55,430 --> 00:32:59,900
actually calculate this offset and then
you can run through and identify all of

375
00:32:59,900 --> 00:33:02,029
the calls to a particular offset and
then

376
00:33:02,029 --> 00:33:10,190
catch them now you need room to put your
code so there's one megabyte a flash

377
00:33:10,190 --> 00:33:14,479
internal flash flash that you can
execute code from there are 16 megabytes

378
00:33:14,479 --> 00:33:18,379
of external flash but you can't execute
in place for that so it might as well

379
00:33:18,379 --> 00:33:23,209
not be there but this is a Chinese
design so in the one megabyte where

380
00:33:23,210 --> 00:33:27,200
they've taken all of the memory and used
all of it

381
00:33:27,200 --> 00:33:37,219
I'm a fifth of that 200 kilobytes is the
Chinese fun now you can cut this out and

382
00:33:37,219 --> 00:33:41,899
the only side effect is that you see
random crap instead of Chinese letters

383
00:33:41,899 --> 00:33:48,408
so you cut that out and you see random
crap instead of Chinese letters and then

384
00:33:48,409 --> 00:33:51,769
you use the Latin alphabet instead and
you're good

385
00:33:51,769 --> 00:34:00,529
this allows you to then have a complex c
compiler with a lot of code and plenty

386
00:34:00,529 --> 00:34:03,589
of memory left over as far as the code
goes

387
00:34:03,589 --> 00:34:09,049
you also need room for your own ramp
because these two hundred kilobytes are

388
00:34:09,049 --> 00:34:12,770
executable and the readable but they're
not writable or they're not quickly

389
00:34:12,770 --> 00:34:18,649
writable so you need to find unused room
and the way that you do this is you

390
00:34:18,649 --> 00:34:21,710
realize that there are two different ram
regions this one that begins to the one

391
00:34:21,710 --> 00:34:26,960
and another begins with a to you
overwrite all of this with the string

392
00:34:26,960 --> 00:34:33,409
that you can look for later in my case I
use deadbeef I'm wondering if there's a

393
00:34:33,409 --> 00:34:38,419
yeah you you could write overwrite all
of it with sets up like that's acepta

394
00:34:38,418 --> 00:34:44,868
and then check back afterward in order
to see how much of that got damaged by

395
00:34:44,869 --> 00:34:50,779
the main application for example the
main application has a global variables

396
00:34:50,779 --> 00:34:56,389
that it initializes 20 at the beginning
with all of those will be overwritten

397
00:34:56,389 --> 00:35:00,529
and you won't mistake them unless the
author of that application also thought

398
00:35:00,529 --> 00:35:07,190
it would be a great idea to have a large
region with sets a there's no g but

399
00:35:07,190 --> 00:35:13,520
maybe the six is close enough and you
can do gogogogogo see you . this before

400
00:35:13,520 --> 00:35:15,690
you actually enter the

401
00:35:15,690 --> 00:35:21,119
manufacturers firmware by overriding all
of the words and ran with it and then

402
00:35:21,119 --> 00:35:25,829
after you started the manufacturing
software you then dumped out all of the

403
00:35:25,829 --> 00:35:32,970
ram overstay USB you then look for large
continuous chunks of gogogogogo or seta

404
00:35:32,970 --> 00:35:38,430
and you'll find that 20 kilobytes of the
tightly coupled grammar unused so you

405
00:35:38,430 --> 00:35:43,618
tell your compiler to target this region
and then you can overlap your firmware

406
00:35:43,619 --> 00:35:48,240
with their firmware and have a
completely functional combined

407
00:35:48,240 --> 00:35:53,310
application at this point you have a
proper c compiler you can redirect

408
00:35:53,310 --> 00:35:58,589
function calls from the original
firmware and you can call back to the

409
00:35:58,589 --> 00:36:04,290
regular code and your gut your golden
until some jackass releases a new

410
00:36:04,290 --> 00:36:09,300
firmware version with a killer feature
like fixing a major bug or adding

411
00:36:09,300 --> 00:36:15,000
support for you for GPS which is what
happened to ask after about nine months

412
00:36:15,000 --> 00:36:21,270
of no firmware updates from the
manufacturer they released a forked the

413
00:36:21,270 --> 00:36:27,569
hardware once in order to change the
audio codec and the copy protection ship

414
00:36:27,569 --> 00:36:31,470
for the audio codec which was the very
first time in this project we found the

415
00:36:31,470 --> 00:36:36,270
copy protection ship or realize that it
was a thing and then separately they did

416
00:36:36,270 --> 00:36:39,990
a fork to add gps support and they did
these different times so there are now

417
00:36:39,990 --> 00:36:44,819
four variants of the hardware that have
the exact same model number that are

418
00:36:44,819 --> 00:36:48,210
sold through the exact same distribution
channels and we have to support all of

419
00:36:48,210 --> 00:36:56,130
them the way that we did this was
through building a tool to port the

420
00:36:56,130 --> 00:37:04,410
function addresses now this is an arm
application but suppose for a second

421
00:37:04,410 --> 00:37:11,009
that where Andy 64 this screenshot is
from a tool called binary ninja which is

422
00:37:11,010 --> 00:37:15,450
a much cheaper reverse engineering tool
than Ida and much faster

423
00:37:16,260 --> 00:37:19,530
what does not yet support arm so you'll
have to wait two or three months before

424
00:37:19,530 --> 00:37:26,069
you can use this for embedded targets
and in amd64 when you have these

425
00:37:26,700 --> 00:37:30,750
as calls you have lots of address is
being loaded that are adjusted by the

426
00:37:30,750 --> 00:37:36,089
linker in this case you have the 49
opcode that's loading an address in

427
00:37:36,089 --> 00:37:41,849
there are eight register your the 48
opcode that loads it into the RCX and

428
00:37:41,849 --> 00:37:46,349
then you have a another 48 that leads
into the RDI you need a good

429
00:37:46,349 --> 00:37:51,300
disassembler in order to compare this
function to the exact same function from

430
00:37:51,300 --> 00:37:56,700
another application or another version
because all of these addresses live ccsu

431
00:37:56,700 --> 00:37:59,098
fini lives ccsu in it

432
00:37:59,099 --> 00:38:03,720
main Lindsay start main all of these
addresses get retargeted by the linker

433
00:38:03,720 --> 00:38:08,339
and change to new addresses so the bites
of the functions will not equal each

434
00:38:08,339 --> 00:38:16,828
other in arm this screenshot is from
madera to in army you can you a lovely

435
00:38:16,829 --> 00:38:21,839
little trick to get around this which is
that arm does not have as many ways to

436
00:38:21,839 --> 00:38:29,339
load an address into a register thumb
has even fewer ways so these three lines

437
00:38:29,339 --> 00:38:39,299
at the bottom 1044 c10 450 and those are
what's called a constant pool because in

438
00:38:39,300 --> 00:38:45,359
arm and even more so in thumb and the
immediate addresses are very awkward and

439
00:38:45,359 --> 00:38:46,619
difficult to use

440
00:38:46,619 --> 00:38:50,550
so instead of using immediate addresses
they do program counter relative

441
00:38:50,550 --> 00:38:56,760
addressing they say hey 16 words further
is the word that I want loaded into this

442
00:38:56,760 --> 00:39:03,089
register which means that all of the
data addresses get shoved to the end of

443
00:39:03,089 --> 00:39:07,109
the function and aren't in the middle
for you to have to disassemble and skip

444
00:39:07,109 --> 00:39:11,759
and the only exception to this is the
function call the branch and Link

445
00:39:11,760 --> 00:39:21,540
instructions now on thumb all the
branches link instructions have an f as

446
00:39:21,540 --> 00:39:26,790
their first nibble and the remaining
three nipples don't matter some

447
00:39:26,790 --> 00:39:32,310
instructions are 16 bits wide instead of
32 bits wide so if you want to compare

448
00:39:32,310 --> 00:39:37,828
two thumb functions for equality all you
have to do is compare all of the 16 that

449
00:39:37,829 --> 00:39:38,910
words together

450
00:39:38,910 --> 00:39:45,000
and you consider it a match if either
they are perfectly equal or if the first

451
00:39:45,000 --> 00:39:53,010
level is an F in both of them and if so
you continue along this is enough to

452
00:39:53,010 --> 00:39:58,170
identify any functions that have been
relinked so for example a vendor library

453
00:39:58,170 --> 00:40:02,130
that's being thrown in or a/c function
that's being compiled with the same

454
00:40:02,130 --> 00:40:08,369
version of the compiler and this code
here a quick little do-while statement

455
00:40:08,369 --> 00:40:12,990
is all that's required to actually do
the comparison and give you a score for

456
00:40:12,990 --> 00:40:19,348
equality if the score is more than 10 or
12 and it's the highest score it's

457
00:40:19,349 --> 00:40:27,869
always a proper match no false negatives
one other thing that you would like to

458
00:40:27,869 --> 00:40:30,510
do

459
00:40:30,510 --> 00:40:35,250
it's one thing to be able to patch the
firmer and run it in the radio so i take

460
00:40:35,250 --> 00:40:37,140
my radio i turn it on

461
00:40:37,140 --> 00:40:41,730
I make a phone call to the repeater
billy-bob calls back to me and says that

462
00:40:41,730 --> 00:40:48,119
he can hear me fine and then I know that
I have not fucked up the audio but when

463
00:40:48,119 --> 00:40:52,680
I have to support multiple target
firmware versions and my code has to be

464
00:40:52,680 --> 00:40:57,210
bug free where Billy baubles call of his
friends and they will all file separate

465
00:40:57,210 --> 00:41:02,609
support tickets on my issue tracker I
really really need to make sure that i

466
00:41:02,609 --> 00:41:08,670
can test my code automatically rather
than having it be tested by the for user

467
00:41:08,670 --> 00:41:15,660
who tries to run at first so i made this
tool which is called mp3 email mp3 EMU

468
00:41:15,660 --> 00:41:23,578
is the firmware for this radio
recompiled to run on linux and the code

469
00:41:23,579 --> 00:41:28,650
to get this working is very very small
we're talking two pages the trick for

470
00:41:28,650 --> 00:41:33,270
this is I begin with an arm linux
executable something that you might run

471
00:41:33,270 --> 00:41:41,549
in debian shell on an android phone and
there's a system called nmap and map

472
00:41:41,549 --> 00:41:46,980
allows you to map a file into ram this
is what you use when you have a file

473
00:41:46,980 --> 00:41:51,380
that's much larger than ram but you need
to randomly seek inside of it

474
00:41:51,380 --> 00:41:56,630
and you need to be at a particular
address

475
00:41:57,470 --> 00:42:02,390
I don't actually remember the historical
reason why you are allowed to specify

476
00:42:02,390 --> 00:42:09,529
the address but you are so what you do
is you tell it that you really want the

477
00:42:09,529 --> 00:42:15,109
firmware file mapped into memory at the
exact same address that it would be in

478
00:42:15,109 --> 00:42:19,609
the radio firmware and then you can call
all of the functions inside of the

479
00:42:19,609 --> 00:42:23,299
firmware and as long as they don't
require a hardware feature that's in the

480
00:42:23,299 --> 00:42:26,390
radio but not in your phone

481
00:42:26,390 --> 00:42:31,759
they still work it can run the same
instruction sets it can run the same

482
00:42:31,759 --> 00:42:35,750
vector editions all of the audio codec
still works

483
00:42:35,750 --> 00:42:44,690
you can also use obj copy to take the
firmware image and then copy it into an

484
00:42:44,690 --> 00:42:51,559
elf linkable module and then you can
link those modules together in order to

485
00:42:51,559 --> 00:42:58,430
have a regular arm linux executable that
that contains the former image and is

486
00:42:58,430 --> 00:43:01,669
able to execute all of the functions
that are in that image

487
00:43:01,670 --> 00:43:06,349
these are the same functions that you
reverse engineered in order to interact

488
00:43:06,349 --> 00:43:11,420
with the code and you're patching if you
could turn the audio 1

489
00:43:14,839 --> 00:43:19,519
ok so the other thing that you can do is
you can then take this code and you can

490
00:43:19,519 --> 00:43:24,558
use it to turn any of the libraries that
were used in the radio in the libraries

491
00:43:24,559 --> 00:43:30,440
that you can use on your desktop because
now i told you that this is an arm linux

492
00:43:30,440 --> 00:43:39,079
executable but my laptop is amd64
there's this convenient little tool

493
00:43:39,079 --> 00:43:46,759
called qmo that is like normally viewed
as a poor man's competitor to vmware or

494
00:43:46,759 --> 00:43:53,299
virtual box but one thing that is very
very good at is that you can run linux

495
00:43:53,299 --> 00:43:58,038
executables from one architecture on a
different architecture and it

496
00:43:58,039 --> 00:44:02,900
transparently emulate sit while
maintaining all system calls so your

497
00:44:02,900 --> 00:44:04,410
phone can use this to

498
00:44:04,410 --> 00:44:07,830
run proprietary software that was
intended for your desktop and your

499
00:44:07,830 --> 00:44:12,420
desktop can run proprietary software
that was intended for a Raspberry Pi in

500
00:44:12,420 --> 00:44:17,550
this case my desktop is running the
audio codec from the radio inside of a

501
00:44:17,550 --> 00:44:22,560
regular command-line application that
allows me to decode that radio image

502
00:44:22,560 --> 00:44:28,380
decode the radio audio packets and
convert them into a standard wav file

503
00:44:34,850 --> 00:44:41,029
people take forever Charlie's is
attaching so i can play the audio that

504
00:44:41,030 --> 00:44:47,690
came out over the radio on my desktop I
can route I without storing and

505
00:44:47,690 --> 00:45:00,590
decompressed or exporting the wrong way
file I this allows you to do things like

506
00:45:00,590 --> 00:45:08,960
a convert music so for example I in that
gogo song she has that the canoeing

507
00:45:08,960 --> 00:45:15,950
audio clip sexy businessman she says no
problem right so you can hook the

508
00:45:15,950 --> 00:45:20,629
encoding end and then convert the goga
sample to play at the end of every

509
00:45:20,630 --> 00:45:24,680
transmission you ever make from your
radio so that you know you hop on the

510
00:45:24,680 --> 00:45:28,250
radio you talk to Billy Bob for a while
and the minute you click off the way

511
00:45:28,250 --> 00:45:31,370
that your radio will tell the tower
you're done is the goga sacrilege will

512
00:45:31,370 --> 00:45:34,580
say no problem and you're good

513
00:45:34,580 --> 00:45:38,360
those are the tricks that I have for you
today

514
00:45:43,930 --> 00:45:45,480
yeah

515
00:45:45,480 --> 00:45:54,540
cool and this here is the mean she's a
very good cat

516
00:45:54,540 --> 00:46:05,910
thank you kindly for your time and
attention yeah I yes

517
00:46:07,770 --> 00:46:15,180
ok so the question was how do I handle
privilege constructions you mean like

518
00:46:15,180 --> 00:46:17,220
user to system

519
00:46:17,220 --> 00:46:22,830
ok so the way that I handled user system
stuff is that embedded arm developers

520
00:46:22,830 --> 00:46:25,440
except for materials here in the back

521
00:46:25,440 --> 00:46:31,290
don't actually use those features so in
my firmware image everything is running

522
00:46:31,290 --> 00:46:37,380
in user mode it never actually makes a
system call if they were to use these

523
00:46:37,380 --> 00:46:43,830
features as a as my neighbor here knows
they could make the software a lot more

524
00:46:43,830 --> 00:46:49,830
reliable for example they could detect
an access to address 0 and they could

525
00:46:49,830 --> 00:46:54,960
say this is fucking illegal I'm not
allowing it and they could fall out but

526
00:46:54,960 --> 00:47:00,359
they don't do any of that because the
integrated system the application

527
00:47:00,359 --> 00:47:04,350
developer the guy who is tasked with
making the product and the product ship

528
00:47:04,350 --> 00:47:09,569
on time is very often the same guy
riding the operating system and he's not

529
00:47:09,570 --> 00:47:14,910
interested in making the operating
system correctly he is interested in

530
00:47:14,910 --> 00:47:21,420
getting the hello world and then getting
hello world into a shippable product so

531
00:47:21,420 --> 00:47:26,790
there are all sorts of nifty features in
here that might be is that as your

532
00:47:26,790 --> 00:47:32,580
reverse engineering a product you never
find when you just map all the other

533
00:47:32,580 --> 00:47:37,410
memory like memory-mapped registers and
so on so that it doesn't crash oh no and

534
00:47:37,410 --> 00:47:43,020
set you can do that so for example the
they might access the i/o registers

535
00:47:43,020 --> 00:47:49,619
begin with the four right and if I need
to say implement the external spy flash

536
00:47:49,619 --> 00:47:53,910
memory which is accessed over an SPI bus
there are two ways to do that the first

537
00:47:53,910 --> 00:47:58,170
way is to completely emulator by
actually

538
00:47:58,170 --> 00:48:03,270
handling the segmentation fault
recognizing the access to the the i/o

539
00:48:03,270 --> 00:48:09,600
register faking the results and then
returning the other way to do that is to

540
00:48:09,600 --> 00:48:14,759
identify the functions that actually
talk to the device so spy flash reads by

541
00:48:14,760 --> 00:48:19,590
flash right and hook just those
functions to run to my overloaded copy

542
00:48:19,590 --> 00:48:25,770
and particularly nice way to do that is
to just map the code as a writable page

543
00:48:25,770 --> 00:48:31,590
so that even though i'm not able to do
runtime overriding of the firmware

544
00:48:31,590 --> 00:48:32,970
inside of the device

545
00:48:32,970 --> 00:48:37,410
I certainly can in a unix process and
that way i only have to hook to see

546
00:48:37,410 --> 00:48:43,649
functions instead of having to hook nine
registers you can do it either way

547
00:48:43,650 --> 00:48:45,210
though

548
00:48:45,210 --> 00:48:49,710
any other questions in the front

549
00:48:54,430 --> 00:48:59,140
thanks stock up to questions are is
there anything you can add about China

550
00:48:59,770 --> 00:49:06,009
oh and the second one is you mentioned
something called turbo folk what what is

551
00:49:06,010 --> 00:49:09,010
that that don't care about that

552
00:49:09,940 --> 00:49:16,359
so China is number one mandiant is
number two and turbo folk has to reset

553
00:49:16,359 --> 00:49:26,200
the scales the turbo folk is indexed 0
no go

554
00:49:26,200 --> 00:49:29,230
thank you coming I'll be in the area if
you have any further questions

