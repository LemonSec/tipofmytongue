1
00:00:04,680 --> 00:00:25,169
ok so i would like to enter introduce
you to our first lecture for today

2
00:00:25,170 --> 00:00:29,699
officially and it's called memory
corruption why we can't have nice things

3
00:00:29,699 --> 00:00:30,900
by the animal

4
00:00:30,900 --> 00:00:38,100
enjoy guys

5
00:00:38,910 --> 00:00:45,120
the pleasure to be here i'm at aspire
organum oh I'm research faculty at

6
00:00:45,120 --> 00:00:51,120
Purdue University and I leave the hex hi
free search group Barbie collaboratively

7
00:00:51,120 --> 00:00:55,828
try to solve different part challenges
in software security and we try to

8
00:00:55,829 --> 00:01:01,230
develop new defense mechanisms for
different forms off our software based

9
00:01:01,230 --> 00:01:06,780
attacks packs and so on but also try to
develop new attack vectors and today i

10
00:01:06,780 --> 00:01:10,530
will talk to you about memory corruption
which is afoot research focus in our

11
00:01:10,530 --> 00:01:13,830
group and you'll see why we can't have
nice things

12
00:01:14,430 --> 00:01:18,540
so overall the story that i'm going to
tell you is how i learned to stop

13
00:01:18,540 --> 00:01:21,030
worrying and embrace the SEC fault

14
00:01:21,030 --> 00:01:26,850
over the course of several years so
India and we are facing a problem that

15
00:01:26,850 --> 00:01:29,490
software is unsafe and insecure

16
00:01:29,490 --> 00:01:35,699
we have millions upon millions of lines
of code written in c and c++ and these

17
00:01:35,700 --> 00:01:41,970
languages trade type safety and memory
safety for some potential or promise of

18
00:01:41,970 --> 00:01:45,450
performance and if you're programming
these languages

19
00:01:46,140 --> 00:01:50,880
the program is fully responsible for all
the checks for security checks bound to

20
00:01:50,880 --> 00:01:56,250
bounce checks memory safety checks type
safety tracks and so on and as we know

21
00:01:56,250 --> 00:02:00,150
programmers are very likely to screw up
especially if the language makes it very

22
00:02:00,150 --> 00:02:07,049
easy for you to screw up and there's a
tremendous amount of software out there

23
00:02:07,049 --> 00:02:13,169
that is written in these languages think
about the are the the base system that

24
00:02:13,169 --> 00:02:15,250
you're running the operating system
kernel

25
00:02:15,250 --> 00:02:18,880
the hypervisor and most of the
applications that you have on your

26
00:02:18,880 --> 00:02:19,570
system

27
00:02:19,570 --> 00:02:23,590
you're all written in c++ and even when
you

28
00:02:23,590 --> 00:02:27,880
applications are being developed they
are started in c++ because of the

29
00:02:27,880 --> 00:02:32,049
promise of performance think of the
google chrome browser which is a

30
00:02:32,050 --> 00:02:38,290
insanely big c++ project with about I
think 15 or 20 million lines of code

31
00:02:38,290 --> 00:02:43,450
which is all written in c++ and although
google has very strict coding standards

32
00:02:43,450 --> 00:02:49,390
are chrome is being pound year after
year again and again and we are finding

33
00:02:49,390 --> 00:02:54,549
a large amount of vulnerabilities in
there and they're just way too many

34
00:02:54,550 --> 00:03:00,700
bucks out there in the software to find
and fix them all manually so what we are

35
00:03:00,700 --> 00:03:05,738
doing and our research group is to
protect the integrity or find mechanisms

36
00:03:05,739 --> 00:03:10,150
to protect the integrity of software
mechanisms through some forms of safe

37
00:03:10,150 --> 00:03:15,400
runtime systems are trying to make
systems resilient against underlying

38
00:03:15,400 --> 00:03:19,780
attacks so even if you do have a memory
corruption vulnerability in your system

39
00:03:19,780 --> 00:03:25,209
will detect this corruption when it is
being exploited and then terminate the

40
00:03:25,209 --> 00:03:30,400
system protecting the integrity after
whole system and your data at a slight

41
00:03:30,400 --> 00:03:38,380
performance cost so a couple of years
ago we looked at heartbeat and who have

42
00:03:38,380 --> 00:03:44,049
you guys heard of partly just a quick
show of hands so most of you have who

43
00:03:44,049 --> 00:03:49,450
has not heard of heartbleed ok so I top
of you have heard of heartbleed about

44
00:03:49,450 --> 00:03:54,609
attends have not heard about heartbleed
the others have no opinion so heartbleed

45
00:03:54,610 --> 00:04:01,600
was or is this very nice our memory or
information is very nice information

46
00:04:01,600 --> 00:04:06,760
leak that was present in a openssl
library so you are sending the server

47
00:04:06,760 --> 00:04:07,780
core request

48
00:04:07,780 --> 00:04:13,600
hey please report reply to me an echo
packet and I want you to reply the

49
00:04:13,600 --> 00:04:18,459
string hi mr. letters and the server
parts to message and said oh I I've got

50
00:04:18,459 --> 00:04:22,180
a request incoming I should replace high
into letters and it was sending two

51
00:04:22,180 --> 00:04:25,539
letters back but an evil attacker could
craft the message

52
00:04:26,289 --> 00:04:27,300
hey server please

53
00:04:27,300 --> 00:04:32,190
good to me hi was 200 collectors and
then the server happily copied whatever

54
00:04:32,190 --> 00:04:38,370
was behind this string is allocated
memory and disclosed different forms off

55
00:04:38,370 --> 00:04:43,259
or different pieces of memory which
allowed the attacker to read passwords

56
00:04:43,259 --> 00:04:51,449
are SL keys and so on from the memory of
the system so we worked on our orbit

57
00:04:51,449 --> 00:04:54,840
when you heard about this attack without
pages is a very severe attack we have to

58
00:04:54,840 --> 00:05:00,568
measure if people are actually able to
patch the system's after they learn

59
00:05:00,569 --> 00:05:06,090
about it and how they patch it and what
we did is we did internet white skins

60
00:05:06,090 --> 00:05:11,969
are two days after the vulnerability was
closed and we scanned every single

61
00:05:11,969 --> 00:05:16,590
system out there and checked after
vulnerability was still present most of

62
00:05:16,590 --> 00:05:23,190
the credit for this work goes to the
folks at UIUC university of michigan UC

63
00:05:23,190 --> 00:05:27,719
Berkeley XC and I was just a small
component in there that help look at the

64
00:05:27,719 --> 00:05:33,000
results a little bit so we did with
these scans and we had to develop a

65
00:05:33,000 --> 00:05:37,740
mechanism to figure out a system was
vulnerable or not and as this was a

66
00:05:37,740 --> 00:05:41,610
university project we had lawyers
breathing down our necks that we had to

67
00:05:41,610 --> 00:05:45,930
make really really sure that we were not
exploiting the vulnerability because how

68
00:05:45,930 --> 00:05:49,409
would you explain explain to a lawyer
that you just exploited all the systems

69
00:05:49,409 --> 00:05:53,130
on the internet this would lead to a
very very bad press

70
00:05:53,130 --> 00:05:57,120
so we developed the mechanism that
allowed us to test for the vulnerability

71
00:05:57,120 --> 00:05:58,770
without exploiting it

72
00:05:58,770 --> 00:06:04,318
so we connected over SSL and the
vulnerable SL version had a an

73
00:06:04,319 --> 00:06:09,270
additional software bug so if you
replied or if you ask the server please

74
00:06:09,270 --> 00:06:14,849
send me an echo package with zero bytes
the protocol should return an error but

75
00:06:14,849 --> 00:06:18,750
the vulnerable version return a packet
of like 0 so we were not reading any

76
00:06:18,750 --> 00:06:22,770
bites of the of the memory of the server
you're perfectly fine and we had a way

77
00:06:22,770 --> 00:06:27,990
to test for the vulnerability so we
tested all the servers out there and we

78
00:06:27,990 --> 00:06:32,819
started two days after disclosure of the
attack and we found a huge amount of the

79
00:06:32,819 --> 00:06:39,190
systems are still vulnerable and we
looked at the full ipv4 address range

80
00:06:39,190 --> 00:06:45,160
and also at the top 1 million domains
and patching happened very very slowly

81
00:06:45,160 --> 00:06:50,200
so people or attackers had a large
amount of time to actually prepare their

82
00:06:50,200 --> 00:06:54,729
attacks and readout all private keys so
we have to you have to consider that all

83
00:06:54,730 --> 00:07:00,940
private keys were are disclosed and
vulnerable interesting the eleven

84
00:07:00,940 --> 00:07:06,550
percent of server's remained vulnerable
even after 48 hours after the public

85
00:07:06,550 --> 00:07:09,970
disclosure of the attack which is a very
long time especially if you consider

86
00:07:09,970 --> 00:07:15,130
that your user base is completely
vulnerable and everybody can snoop in on

87
00:07:15,130 --> 00:07:17,200
your connections after that

88
00:07:17,200 --> 00:07:22,120
patching plateaued at four percent so at
one point in time a large amount of

89
00:07:22,120 --> 00:07:25,780
system administrators didn't even care
about patching it just kept the

90
00:07:25,780 --> 00:07:27,250
vulnerable versions running

91
00:07:27,250 --> 00:07:33,400
interestingly what we also found out
only ten percent of the vulnerable sites

92
00:07:33,400 --> 00:07:38,440
actually replaced your certificates and
after your private key sleek you should

93
00:07:38,440 --> 00:07:43,090
totally replace your certificate because
otherwise it's not really useful to even

94
00:07:43,090 --> 00:07:47,140
if you've updated the server because
people can still read out your your

95
00:07:47,140 --> 00:07:52,690
connections and even worse of the people
that actually replaced your certificates

96
00:07:52,690 --> 00:07:56,110
fifty percent of those replace the
certificates was vulnerable

97
00:07:56,110 --> 00:08:00,070
cryptographic keys to reduce the amount
of security even more so this is a

98
00:08:00,070 --> 00:08:05,169
terrible terrible process so we can
conclude is that the update process is

99
00:08:05,169 --> 00:08:15,549
slow incomplete and often incorrect and
it's just terrible out there and over

100
00:08:15,550 --> 00:08:22,600
the last couple of years we had a large
amount of security outbreaks which was

101
00:08:22,600 --> 00:08:26,320
awesome for me because I was applying
for a lot of funding so I had a lot of

102
00:08:26,320 --> 00:08:30,550
good examples to give to the funding
agencies that it was heart bleed out

103
00:08:30,550 --> 00:08:35,260
there there was shell-shocked and ghost
cities were all very nice vulnerability

104
00:08:35,260 --> 00:08:40,870
that allowed me to our acquire more
funding in the area of memory safety or

105
00:08:40,870 --> 00:08:46,300
memory unsafety so let's just look a
little bit at different problems that we

106
00:08:46,300 --> 00:08:49,359
are facing in memory safety

107
00:08:49,360 --> 00:08:54,850
and we'll talk about two different
aspects of memory safety and then how

108
00:08:54,850 --> 00:09:02,079
this leads to possible exploits so at
the core memory safety for programming

109
00:09:02,079 --> 00:09:10,089
in c RQ of URC programmers who has
written more than a thousand line of see

110
00:09:10,089 --> 00:09:20,260
10,000 a hundred thousand who has
written an operating system

111
00:09:22,390 --> 00:09:25,390
ok a bunch

112
00:09:25,910 --> 00:09:32,270
so you guys are well aware of the of the
different kind of vulnerabilities in

113
00:09:32,270 --> 00:09:37,189
there but let me just repeat for for
those that are not as proficiency so

114
00:09:37,190 --> 00:09:43,490
there's two kind of invalid key
references that can happen when you're

115
00:09:43,490 --> 00:09:47,900
programming and see there's a dangling
pointer so this is a temporal memory

116
00:09:47,900 --> 00:09:52,340
safety violation as we call it and at
one point in time that the point that

117
00:09:52,340 --> 00:09:57,020
you have the reference points to a valid
object but later on

118
00:09:57,530 --> 00:10:01,670
you freed an object we return it back to
memory or you return from the from the

119
00:10:01,670 --> 00:10:05,959
function call that allocated the object
on a stack it is no longer ballot but

120
00:10:05,960 --> 00:10:10,310
the pointer still points to that object
that was now do reference that was now

121
00:10:10,310 --> 00:10:13,910
deallocated and maybe something else is
allocated on its behalf

122
00:10:14,450 --> 00:10:21,560
so after it is freed if you use it it
results in an invalid dereferencing a

123
00:10:21,560 --> 00:10:23,030
memory safety violation

124
00:10:23,030 --> 00:10:27,140
the second form of memory safety
violation is an out-of-bounds pointer

125
00:10:27,140 --> 00:10:33,680
like a recall is a spatial memory error
so at one point in time the pointer is

126
00:10:33,680 --> 00:10:38,839
pointing at a valid memory location and
as we keep computing we might be

127
00:10:38,840 --> 00:10:44,510
iterating the pointer maybe we are
walking through an airy and accessing

128
00:10:44,510 --> 00:10:48,230
individual elements of an area and later
at a later point in time the pointer

129
00:10:48,230 --> 00:10:52,160
points outside of the bounds of the
underlying object that was allocated to

130
00:10:52,160 --> 00:10:59,390
so we allocate an object can be access
it out of bounds so according to the c

131
00:10:59,390 --> 00:11:05,480
language standard it's perfectly fine to
have pointers pointing to invalid

132
00:11:05,480 --> 00:11:09,950
locations so you're free to have as many
of these pointers as you want

133
00:11:09,950 --> 00:11:16,490
the only bad stuff happens as soon if
the pointer is read written or freed

134
00:11:16,490 --> 00:11:23,660
again so if you do an action on this
invalid pointer and then bad things

135
00:11:23,660 --> 00:11:29,240
happen and according to the c language
standard this is undefined behavior and

136
00:11:29,240 --> 00:11:32,720
this is where all the attacks lift the
all living is undefined behavior space

137
00:11:32,720 --> 00:11:38,480
so these are two main forms of memory
unsafety

138
00:11:38,480 --> 00:11:41,930
that we had in the past in recent years

139
00:11:41,930 --> 00:11:46,760
another problem became more and more
prominent especially when exploiting

140
00:11:46,760 --> 00:11:53,959
large software systems like Google
Chrome or a GD k or are different other

141
00:11:53,959 --> 00:12:01,939
forms of c++ programs the jvm is not a
nice example for that and that the

142
00:12:01,940 --> 00:12:08,899
so-called type confusion attack so if
you're programming in C++ you are

143
00:12:08,899 --> 00:12:15,019
allocating classes and we have a very
simple class be here that has a data

144
00:12:15,019 --> 00:12:22,250
field and we extend this class as a
called classy and a second form of data

145
00:12:22,250 --> 00:12:26,750
so you do have memory objects with two
pieces of data two slots the P data and

146
00:12:26,750 --> 00:12:33,949
the sea data now if the allocate a new p
so we allocated somewhere on the on a

147
00:12:33,949 --> 00:12:40,130
heap be allocated memory object that has
the size of a pea data and in c++ for

148
00:12:40,130 --> 00:12:47,870
performance reasons you can do a static
cast that casts an object from type from

149
00:12:47,870 --> 00:12:58,370
one type for example p into another type
for example C so the object at location

150
00:12:58,370 --> 00:13:05,029
c or c pointer now assumes that you have
to total size of a sea object but before

151
00:13:05,029 --> 00:13:10,670
we only allocated an object for 4p and
this works well as long as you only use

152
00:13:10,670 --> 00:13:17,000
the fields that were present p but as
soon as you access to the sea data field

153
00:13:17,000 --> 00:13:22,310
you have a memory corruption and the
type confusion actually happens at the

154
00:13:22,310 --> 00:13:29,388
time of the static cast because the
downcast is not legal from from the from

155
00:13:29,389 --> 00:13:33,350
the type to the parent type and then we
have a second memory safety violation

156
00:13:33,350 --> 00:13:37,819
which would be in out-of-bounds
violation here as soon as we access that

157
00:13:37,819 --> 00:13:43,250
data but interestingly the initial
violation happens at the time of the

158
00:13:43,250 --> 00:13:49,850
static cast so building on these types
of memory safety violations either a

159
00:13:49,850 --> 00:13:51,440
spatial temporal

160
00:13:51,440 --> 00:13:55,550
roll types of memory safety violations
or the type confusion we can have to

161
00:13:55,550 --> 00:13:59,839
conform two types of attacks there are
two fun control-flow hi check attacks

162
00:13:59,840 --> 00:14:04,280
which laude attackers to execute
different forms of code or dr data only

163
00:14:04,280 --> 00:14:10,250
attacks which allow the attacker to leak
some pieces of memory and for example

164
00:14:10,250 --> 00:14:14,810
the heartbleed bug was a information
leak that allow the attacker to looking

165
00:14:14,810 --> 00:14:19,250
for information but let's focus on the
phone code execution part first

166
00:14:20,300 --> 00:14:27,439
or let's focus here on a code execution
part so a contraflow hi check attack is

167
00:14:27,440 --> 00:14:33,920
if we are executing new code there was
not intended by the program think of the

168
00:14:33,920 --> 00:14:41,180
program as an abstract graph that
connects individual pieces so you can

169
00:14:41,180 --> 00:14:47,089
now you can brought checked or you can
transform the program that you're

170
00:14:47,090 --> 00:14:51,260
executing into some form of execution
graph that execute one step after the

171
00:14:51,260 --> 00:14:57,350
other and the individual basic blocks
can be pieces or nodes in the graph and

172
00:14:57,350 --> 00:15:02,510
the edges are connections between these
basic blocks so here for example we

173
00:15:02,510 --> 00:15:08,000
would have some form of if condition or
or loop from as long as the loop

174
00:15:08,000 --> 00:15:13,460
condition in basic block one is true we
execute basic block and return to block

175
00:15:13,460 --> 00:15:19,460
1 so this is the representation of the
loop as soon as Luke condition is false

176
00:15:19,460 --> 00:15:24,020
we go to basic block numbers three and
execute the statement after the loop and

177
00:15:24,020 --> 00:15:29,360
then continue to basic block for now in
a benign execution the execution will

178
00:15:29,360 --> 00:15:33,800
always stay inside this existing graph
and we can abstract this graph somehow

179
00:15:33,800 --> 00:15:40,430
in an attack form at one point in time
the attacker is able to overwrite a code

180
00:15:40,430 --> 00:15:45,319
pointer and the attacker modify the code
pointer and it could be either the

181
00:15:45,320 --> 00:15:50,450
return address on the stack that encodes
very over coming from so that you can

182
00:15:50,450 --> 00:15:54,890
transform ctrl to an alternate location
it could be a function pointer in see

183
00:15:54,890 --> 00:15:58,939
that somewhere on the heater on the
stack or it could be the three table .

184
00:15:58,940 --> 00:16:02,330
in c++ so for c++ are

185
00:16:02,950 --> 00:16:10,030
to allow the dynamic dispatch we have
some form of the table . of is a set of

186
00:16:10,030 --> 00:16:14,560
our code pointers that an attacker can
then modify to redirect somewhere else

187
00:16:14,560 --> 00:16:18,969
so assuming the attacker has modified
any of these three types of code

188
00:16:18,970 --> 00:16:24,760
pointers the control flow at one point
I'm leaves this predefined graph leaves

189
00:16:24,760 --> 00:16:29,260
Valley graph and we now have a contract
for high check attack and we can reuse

190
00:16:29,260 --> 00:16:35,170
existing code to level of your first
paycheck attack and for example to a

191
00:16:35,170 --> 00:16:39,699
return oriented programming attack
chopper into programming attack then

192
00:16:39,700 --> 00:16:46,120
inject more more code for it to execute
a search stage so this sounds very very

193
00:16:46,120 --> 00:16:51,760
Cerreta chol arm so let's make a more
practical example we have a small

194
00:16:51,760 --> 00:16:55,630
snippet of C code here and i'll give you
two seconds to think about the

195
00:16:55,630 --> 00:16:58,630
vulnerability

196
00:17:01,860 --> 00:17:05,339
so we assume that the attacker can
control both arguments to the function

197
00:17:05,339 --> 00:17:13,500
we do have a function pointer in the
function and then be calculate an offset

198
00:17:13,500 --> 00:17:20,309
of the buffer and then use this later on
so if you look at memory the memory

199
00:17:20,309 --> 00:17:25,439
looks somewhat like this we do have a
storage space for q4 buffer for a

200
00:17:25,439 --> 00:17:31,590
function pointer and some code and who
is actually supposed to . somewhere into

201
00:17:31,590 --> 00:17:36,570
buffer so the goal of the function was
the programmer intended you to . into

202
00:17:36,570 --> 00:17:41,399
the buffer so that the user could modify
a value in that offer think of it as an

203
00:17:41,400 --> 00:17:44,400
area where you're changing some value
somewhere in between

204
00:17:45,000 --> 00:17:51,000
now at this point in time the attacker
if the attacker controls are the offset

205
00:17:51,000 --> 00:17:56,970
as a first parameter the attacker can
actually modify q and implemented in a

206
00:17:56,970 --> 00:18:00,540
way so that cue points to the function
pointer to the precise location of the

207
00:18:00,540 --> 00:18:05,520
function pointer and this works if we
know the distance between the buffer

208
00:18:05,520 --> 00:18:12,600
objects and a function pointer on the
stack or on the heat so now you points

209
00:18:12,600 --> 00:18:19,559
to the to the function pointer and
interestingly so the benign coats its

210
00:18:19,559 --> 00:18:24,870
function pointer the function pointer to
point to the value of foo so as

211
00:18:24,870 --> 00:18:28,409
execution continuous function pointers
set to the value of true but a later

212
00:18:28,410 --> 00:18:33,480
point in time then the value in the
buffer is actually set the to the user

213
00:18:33,480 --> 00:18:38,970
defined value the ask you is now
pointing to the function pointer the

214
00:18:38,970 --> 00:18:44,460
attacker is able to overwrite this
function pointer and modify it so the

215
00:18:44,460 --> 00:18:48,000
attacker can . the function . or
somewhere else and in most cases this

216
00:18:48,000 --> 00:18:52,080
will lead to some form up a segmentation
fault because you're jumping summer into

217
00:18:52,080 --> 00:18:59,460
the beats but if you align it correctly
after attacker knows where individual

218
00:18:59,460 --> 00:19:03,960
code snippets are the attack can
redirected to the first form of gadgets

219
00:19:03,960 --> 00:19:08,910
first execution gadget and then execute
arbitrary code and this gets the

220
00:19:08,910 --> 00:19:14,510
attacker full control of the system and
most times the attackers well then

221
00:19:14,510 --> 00:19:19,220
make another piece of code executable
that gives them more functionalities and

222
00:19:19,220 --> 00:19:22,670
more permissions this is a some form of
privilege escalation attack or the

223
00:19:22,670 --> 00:19:28,460
attacker can then gain control so we
have now gained control of the system

224
00:19:28,460 --> 00:19:34,430
there are a whole bunch of defense
systems over the last 30 years we've

225
00:19:34,430 --> 00:19:38,780
developed a plethora of defense
mechanism and some of them actually made

226
00:19:38,780 --> 00:19:44,120
it into real systems so we do have many
different defense mechanisms out there

227
00:19:44,120 --> 00:19:48,560
and let's just look at the ones that are
available on your everyday computer or

228
00:19:48,560 --> 00:19:53,600
on your smartphone or in your tablet if
you have a view of memory back in the

229
00:19:53,600 --> 00:19:54,620
old days

230
00:19:54,620 --> 00:19:58,939
everything was it fix addresses so the
stack was always at the same address the

231
00:19:58,940 --> 00:20:02,480
data section was always at the same
address and the text section was at the

232
00:20:02,480 --> 00:20:06,290
same address as well so everything was
well known background in fact we could

233
00:20:06,290 --> 00:20:11,870
have used all these features also armed
the old systems did not distinguish

234
00:20:11,870 --> 00:20:16,310
between executable code and data so you
could just jump to any data and

235
00:20:16,310 --> 00:20:25,010
executors ass code and many times the
our code section varietal as well depend

236
00:20:25,010 --> 00:20:28,910
explicitly on microcontrollers this is
still true because you don't have to use

237
00:20:28,910 --> 00:20:32,900
these permission bits but on desktop
systems and smartphones we've developed

238
00:20:32,900 --> 00:20:37,010
a large amount of Defense's building on
that so there's data execution

239
00:20:37,010 --> 00:20:44,570
prevention which removes the executable
bit of any page that is mapped as data

240
00:20:44,570 --> 00:20:49,790
so that nowadays on a heap and on the
stack you can no longer have coat you

241
00:20:49,790 --> 00:20:53,960
can only have code in code regions and
all the code regions must be mapped as

242
00:20:53,960 --> 00:20:58,670
read-only so you cannot execute these
regions so this makes it harder for the

243
00:20:58,670 --> 00:21:04,400
attacker to inject code but clever
attackers actually reuse code in

244
00:21:04,400 --> 00:21:08,120
different ways and stitch together
pieces and snippets off the existing

245
00:21:08,120 --> 00:21:13,399
code region to circumvent this
protection here for there's address

246
00:21:13,400 --> 00:21:18,080
space layout randomization so instead of
using about no locations we just shuffle

247
00:21:18,080 --> 00:21:22,189
all these regions around so that the
attacker does not know over the Internet

248
00:21:22,190 --> 00:21:28,100
pieces of code are and this helps us in
hiding information from the attacker to

249
00:21:28,100 --> 00:21:32,899
the attacker first need some auxiliary
attack to learn all the locations of the

250
00:21:32,899 --> 00:21:38,090
code so that makes it harder if the
attacker doesn't know over the code

251
00:21:38,090 --> 00:21:43,309
snippets are the attacker cannot reuse
it simple case in addition to that we

252
00:21:43,309 --> 00:21:49,879
have stacked calories that are a simple
defends against armed stack-based buffer

253
00:21:49,879 --> 00:21:55,039
overflows and safe exception handlers
that help against some form of overflow

254
00:21:55,039 --> 00:22:02,360
this film think of those calories as
some form of special values that are in

255
00:22:02,360 --> 00:22:07,459
jected summer in the in a stack and you
can continue to check these values if

256
00:22:07,460 --> 00:22:10,730
you still have the correct value if
they're if the attacker overwrote those

257
00:22:10,730 --> 00:22:13,580
values you know that something has gone
wrong and you can terminate the

258
00:22:13,580 --> 00:22:21,949
application so if you look at the status
of the deployed defenses we noted SLR

259
00:22:21,950 --> 00:22:26,720
and data execution prevention are only
effective in combination

260
00:22:26,720 --> 00:22:30,860
only if you have both defenses running
at the same time you can stop an attack

261
00:22:30,860 --> 00:22:35,990
if an attacker learns to pieces or the
locations of code you can get around the

262
00:22:35,990 --> 00:22:41,960
UH both of the defense's one after the
other and as soon as you break a SLR you

263
00:22:41,960 --> 00:22:48,409
get code reuse and then you can build up
your second stage of the attack and on

264
00:22:48,409 --> 00:22:52,250
desktops information leaks are fairly
common especially on the under windows

265
00:22:52,250 --> 00:22:56,480
system so they make it easy for you to
detect these attacks on servers code

266
00:22:56,480 --> 00:23:00,559
reuse attacks have decreased because
it's gotten much harder to leak this

267
00:23:00,559 --> 00:23:07,730
underlying information so interestingly
we had a an attack at rude last year and

268
00:23:07,730 --> 00:23:13,039
some colleagues hadn't follow-up paper
at oakland this year which are two

269
00:23:13,039 --> 00:23:18,139
security conferences that show that you
can leak the base address of a SLR was

270
00:23:18,139 --> 00:23:23,269
very high probability and this is a very
very fun attack because you break a SLR

271
00:23:23,269 --> 00:23:29,029
you can reuse code and then you can go
and drop yourself away and start owning

272
00:23:29,029 --> 00:23:33,649
the machine so if you look at what's
actually deployed on the system and we

273
00:23:33,649 --> 00:23:35,229
look what kind of attacks are happy

274
00:23:35,230 --> 00:23:40,270
meaning the we are way past . so the
defenses are completely failing us and

275
00:23:40,270 --> 00:23:44,049
and stopping as if you're stumbling
along the way and it's just breaking all

276
00:23:44,049 --> 00:23:49,360
over the place and we're doing a
terrible job at securing our systems so

277
00:23:49,360 --> 00:23:54,159
what we need are more principled
offenses that have type safety stack

278
00:23:54,160 --> 00:23:56,799
integrity and control for integrity

279
00:23:56,799 --> 00:24:00,970
I'm trying to show you here are some
interesting mechanisms that we are

280
00:24:00,970 --> 00:24:05,590
developing in academia and trying to
push through onto real system so that we

281
00:24:05,590 --> 00:24:10,840
can we can have principal defenses
against attacks and i'll give you all

282
00:24:10,840 --> 00:24:16,659
start with a sneak preview of paper we
got accepted at ccs this year which is

283
00:24:16,660 --> 00:24:21,850
one of the top security conferences so
will present this in a in a couple of

284
00:24:21,850 --> 00:24:28,780
weeks in Indiana and this is a couple of
colleagues of mine from fri university

285
00:24:28,780 --> 00:24:35,020
and a couple of my students at purdue
university / be in force strong type

286
00:24:35,020 --> 00:24:46,270
safety for applications written in c++
so again we have to object and use the

287
00:24:46,270 --> 00:24:51,370
same code as in the in the type safety
example as before we have to object p

288
00:24:51,370 --> 00:24:56,739
and you have the object see that extends
object p now they're allocating object p

289
00:24:56,740 --> 00:25:02,559
as we did before but in addition to that
we have a so called me today the table

290
00:25:02,559 --> 00:25:08,168
that stores for each object for each
address of the object

291
00:25:08,169 --> 00:25:12,669
what kind of type it is so we remember
the type and the type hierarchy of the

292
00:25:12,669 --> 00:25:23,559
object so as soon as we see a cast we
can look up the underlying type of it so

293
00:25:23,559 --> 00:25:28,510
we wrote a compiler pass and we
implemented this on pop off llvm and

294
00:25:28,510 --> 00:25:34,090
this is open source that replaces every
single static cost that is in the source

295
00:25:34,090 --> 00:25:40,360
code with our own function that does a
check cost so we make all the costs

296
00:25:40,360 --> 00:25:46,449
explicit which leads to a slight
overhead of a couple of percent but we

297
00:25:46,450 --> 00:25:48,540
are checking every single typecast

298
00:25:48,540 --> 00:25:54,240
runtime so at the point of this cast and
not at the later stage when the data is

299
00:25:54,240 --> 00:25:58,680
used to detect there's a type confusion
and we can terminate the program and

300
00:25:58,680 --> 00:26:01,530
give the programmer some feedback

301
00:26:01,530 --> 00:26:08,610
hey a type confusion happened i expected
type an object of type C but the

302
00:26:08,610 --> 00:26:13,740
underlying object was actually of type p
so these types cannot be cast into each

303
00:26:13,740 --> 00:26:17,760
other and we can thereby terminate the
application and tell the programmer hey

304
00:26:17,760 --> 00:26:22,890
you need to fix this and this is a
principal defense that we will detect

305
00:26:22,890 --> 00:26:27,450
all these type confusion problems and
stop the underlying exploitation as it

306
00:26:27,450 --> 00:26:33,300
continues and if you look back at last
couple of vulnerabilities against the

307
00:26:33,300 --> 00:26:34,409
Chrome browser

308
00:26:34,410 --> 00:26:39,120
these were all type confusion
vulnerabilities another principle

309
00:26:39,120 --> 00:26:43,679
defense that we looked at is stick
integrity so enforcing dynamic

310
00:26:43,680 --> 00:26:49,920
restrictions on return instructions so
if you have function returns return

311
00:26:49,920 --> 00:26:57,060
pointer on the stack is basically and
pointer code binder can reach arbitrary

312
00:26:57,060 --> 00:27:01,950
code so we protect the return
instruction through some form of shadow

313
00:27:01,950 --> 00:27:07,620
stack or safe stack that ensures full
integrity for these instructions if you

314
00:27:07,620 --> 00:27:13,139
have are these two functions a and B
they both called food and you have a

315
00:27:13,140 --> 00:27:18,600
function foo if you have the control
flow graph if we know that you're

316
00:27:18,600 --> 00:27:24,240
calling through from from function a we
will remember that origin origin came

317
00:27:24,240 --> 00:27:28,440
from function a so when we are returning
from food the only location that you can

318
00:27:28,440 --> 00:27:32,670
reach for that you are allowed to reach
is functioning and we do this check at

319
00:27:32,670 --> 00:27:37,110
the return instruction . on the other
hand if you're calling from function B

320
00:27:37,110 --> 00:27:40,979
we make sure that the only only place
that you can reach when you're returning

321
00:27:40,980 --> 00:27:46,530
is function be so we ensure the
integrity of the code . on the stack so

322
00:27:46,530 --> 00:27:51,570
the attacker is unable to modify this
this code pointer or modifications will

323
00:27:51,570 --> 00:27:56,580
be detected and determining the
application so this is a strong property

324
00:27:56,580 --> 00:28:00,879
that guarantees that the attacker cannot
use return oriented programming

325
00:28:00,880 --> 00:28:06,370
because we will detect it in any case
another hot topic is control for

326
00:28:06,370 --> 00:28:11,709
integrity let me do a quick poll who of
you has heard of control flow integrity

327
00:28:11,710 --> 00:28:19,780
about five does any did anybody hear
about control flow guard the new defense

328
00:28:19,780 --> 00:28:24,730
mechanism that microsoft added to the
recent visual studio there was 1i think

329
00:28:24,730 --> 00:28:32,620
wanted to so contraflow integrity is a
defense mechanism that restricts the

330
00:28:32,620 --> 00:28:39,429
allowed targets that an indirect control
transfer is allowed to reach so if you

331
00:28:39,430 --> 00:28:43,990
have a function pointer in principle you
can this function pointer can reach any

332
00:28:43,990 --> 00:28:51,850
are executable address in memory of the
program and so you have an sheer

333
00:28:51,850 --> 00:28:57,760
unlimited amount of possible targets and
on x86 every address of all location in

334
00:28:57,760 --> 00:29:01,300
memory does not mean every single
instruction but you can jump inside

335
00:29:01,300 --> 00:29:09,340
instructions as well for extra fun so a
control for integrity does it uses an

336
00:29:09,340 --> 00:29:14,949
analysis to figure out the valid targets
so it executes an additional check

337
00:29:14,950 --> 00:29:20,140
before the function pointer is used and
using his analysis that is usually done

338
00:29:20,140 --> 00:29:24,250
statically before the execution of the
program you figure out which of the

339
00:29:24,250 --> 00:29:29,050
targets are actually allowed so at
runtime you check is it one of these two

340
00:29:29,050 --> 00:29:33,490
targets that we allowed if not if it is
any other target or if the attack was

341
00:29:33,490 --> 00:29:38,020
able to change it using some form of
memory corruption we stop the execution

342
00:29:38,020 --> 00:29:42,100
of the program right there so we are
limiting the amount of targets and this

343
00:29:42,100 --> 00:29:48,490
can happen on the keep when using a
function . or virtual call in c++ but

344
00:29:48,490 --> 00:29:49,720
also on the stack

345
00:29:49,720 --> 00:29:55,360
we checked the return target and check
if the target isn't one of the sets of

346
00:29:55,360 --> 00:30:01,719
one of the allowed colors so it is one
of the loud colors be allowed to return

347
00:30:01,720 --> 00:30:09,850
target now when looking at the stack
this is slightly different than the

348
00:30:09,850 --> 00:30:12,699
property that we defined for

349
00:30:12,700 --> 00:30:20,800
stack integrity because we have a set of
allowed targets now let's look at the

350
00:30:20,800 --> 00:30:25,720
example again so the attacker may write
to memory the code pointers are only

351
00:30:25,720 --> 00:30:30,280
very fight when you are used later on
when you look again looking again at the

352
00:30:30,280 --> 00:30:35,800
same example and you have two possible
calls from a day or be to function

353
00:30:35,800 --> 00:30:42,820
through the analysis will go through the
source code and attacked

354
00:30:43,360 --> 00:30:48,310
hey there's one possible call to through
from function a so function eight may

355
00:30:48,310 --> 00:30:55,600
call function food but the analysis
found that both A&B may call function

356
00:30:55,600 --> 00:31:01,449
food so at the return . when function
for returns both targets either a and B

357
00:31:01,450 --> 00:31:08,440
are valid because they are both industry
Atta clean own set of possible call

358
00:31:08,440 --> 00:31:14,260
locations so the attacker no can
construct the same analysis and figure

359
00:31:14,260 --> 00:31:18,160
out what the possible call targets are
instead of being able to call return to

360
00:31:18,160 --> 00:31:22,360
any possible location as we usually do
in return oriented programming we now

361
00:31:22,360 --> 00:31:26,889
have a set of locations that are allowed
in practice there would only be one

362
00:31:26,890 --> 00:31:31,990
valley location but see if I restricted
to a smaller set of locations that are

363
00:31:31,990 --> 00:31:38,860
all possibly valid and the attacker is
able to exploit this and select any of

364
00:31:38,860 --> 00:31:46,570
these possible locations at his or her
choosing so did you take your notes the

365
00:31:46,570 --> 00:31:51,639
attacker may be able to exploit this by
changing and shifting between these

366
00:31:51,640 --> 00:31:55,750
things and there are a couple of novel
code reuse attacks that we can develop

367
00:31:55,750 --> 00:32:01,960
this way and last year we developed
control flow bending and have been a

368
00:32:01,960 --> 00:32:06,610
couple of additional attacks building on
top of that there are published more

369
00:32:06,610 --> 00:32:14,860
recently so we construct the same
analysis that the are cfi mechanism does

370
00:32:14,860 --> 00:32:19,419
and we construct the control flow graph
so we define the valid graph of control

371
00:32:19,420 --> 00:32:24,519
flow that the attacker or the program is
allowed to follow and we then

372
00:32:24,519 --> 00:32:31,809
steer the execution of the program along
those graphs so we know that CF is

373
00:32:31,809 --> 00:32:37,599
stateless so for each of the possible
locations we can redirect according to

374
00:32:37,599 --> 00:32:45,070
our choosing and thereby achieve
reasonable side effects so according to

375
00:32:45,070 --> 00:32:49,629
our control flow blending technique we
make sure that every single control flow

376
00:32:49,629 --> 00:32:55,748
transfer that is executed is valid
according to the security policy but if

377
00:32:55,749 --> 00:32:59,559
you would observe the execution trace it
would not be a valid execution of the

378
00:32:59,559 --> 00:33:06,219
program and this allows us to circumvent
our static fully precise cfi and get

379
00:33:06,219 --> 00:33:12,549
around this defense mechanism the
underlying limitation of cfi is that

380
00:33:12,549 --> 00:33:17,049
it's stateless so each state is very
fight without context so if you would

381
00:33:17,049 --> 00:33:21,759
validate the complete part of the
program you can make sure that on the

382
00:33:21,759 --> 00:33:25,989
attacker cannot redirected because the
past dependencies will make sure that

383
00:33:25,989 --> 00:33:31,239
only one possible target is valid so we
keep bending the control flow along

384
00:33:31,239 --> 00:33:35,139
valid pass that are undetectable and
research a pass in this control flow

385
00:33:35,139 --> 00:33:41,320
graph that matches the desired behavior
after attacker and the desired behavior

386
00:33:41,320 --> 00:33:46,658
is using usually executing code reaching
system and then supplying the argument

387
00:33:46,659 --> 00:33:55,119
that we can escalate our privileges are
other academics have already shown that

388
00:33:55,119 --> 00:34:01,059
we control for integrity that uses a
week analysis is already broken so we

389
00:34:01,059 --> 00:34:05,139
are not looking into that that much
further and Microsoft control-flow guard

390
00:34:05,139 --> 00:34:13,089
is an instance of week of a week cfi
mechanism so it makes exploitation a

391
00:34:13,089 --> 00:34:18,969
little harder but it can be mitigated in
all pretty much all cases and the

392
00:34:18,969 --> 00:34:20,168
attacker is able

393
00:34:20,168 --> 00:34:23,529
if you give if you devised a clever
attack to get around it

394
00:34:23,529 --> 00:34:28,239
microsoft consciously choose to make a
week implementation because it's a

395
00:34:28,239 --> 00:34:33,908
trade-off between usability and the
complexity of the software so they

396
00:34:33,909 --> 00:34:36,980
traded off security for you

397
00:34:36,980 --> 00:34:42,139
use of deployability let's look at
strong see a fine what we can do Fe if

398
00:34:42,139 --> 00:34:46,760
you would have a strong CF is we assume
that the underlying cfi defense

399
00:34:46,760 --> 00:34:51,290
mechanism uses a strong control flow
graph without any our approximation

400
00:34:51,290 --> 00:34:57,020
assume stack integrity for example
shadow stack and then assume that a

401
00:34:57,020 --> 00:35:02,960
contraflow transfer is only valid if
some benign execution actually execute

402
00:35:02,960 --> 00:35:03,530
it

403
00:35:03,530 --> 00:35:09,530
so how secure is it and we evaluate two
different options with and without stack

404
00:35:09,530 --> 00:35:18,560
integrity so results deck integrity we
obviously want to do Rob so we have to

405
00:35:18,560 --> 00:35:24,590
find a pass to system in our control
flow graph so we look at the graph of

406
00:35:24,590 --> 00:35:28,820
the execution how to the different
program notes are connected and we try

407
00:35:28,820 --> 00:35:33,500
to divert as part of our attack the
contract law of the application to reach

408
00:35:33,500 --> 00:35:37,130
this point in time we are constrained
through the memory of vulnerability and

409
00:35:37,130 --> 00:35:41,270
we set individual memory location so
that the program follows this path and

410
00:35:41,270 --> 00:35:47,300
then reaches system with arguments that
we control so how does the control flow

411
00:35:47,300 --> 00:35:51,830
graph actually look like people thought
for a very long time that these condo

412
00:35:51,830 --> 00:35:56,990
photographs are very very complex so it
will be almost impossible to find a pass

413
00:35:56,990 --> 00:36:01,430
from the location where we control the
argument that the vulnerability for the

414
00:36:01,430 --> 00:36:05,930
vulnerable function to the actual system
call that we want to reach it is

415
00:36:05,930 --> 00:36:12,230
immensely complex to control all the
arguments along this pass and the attack

416
00:36:12,230 --> 00:36:16,940
would be highly unlikely and people
thought that this makes the system very

417
00:36:16,940 --> 00:36:17,720
secure

418
00:36:17,720 --> 00:36:23,509
what we found out that a control flow
graph actually looks like this there are

419
00:36:23,510 --> 00:36:27,859
a lot of functions in there that are
pretty much connected everywhere think

420
00:36:27,859 --> 00:36:32,690
about men copy think about printer those
functions are called from so many

421
00:36:32,690 --> 00:36:38,540
contexts and remember if you are
returning from this function you can

422
00:36:38,540 --> 00:36:43,880
pretty much returned to any location
that caused this function and this

423
00:36:43,880 --> 00:36:48,980
allows us to connect different parts of
the complex control flow graph in a very

424
00:36:48,980 --> 00:36:49,640
very easy

425
00:36:49,640 --> 00:36:54,319
manor and for example for mem copy this
is what we call a powerful dispatcher

426
00:36:54,319 --> 00:37:00,049
function and allows us to redirect the
call easily and then control the

427
00:37:00,049 --> 00:37:02,630
argument system now

428
00:37:02,630 --> 00:37:06,589
dispatcher functions are frequently
called and the arguments are under the

429
00:37:06,589 --> 00:37:12,109
attackers control and they may override
their own return address and we found a

430
00:37:12,109 --> 00:37:15,019
whole bunch of examples of these
dispatcher functions that are pretty

431
00:37:15,019 --> 00:37:20,029
much everywhere in the code which makes
exploitation understand very easily so

432
00:37:20,029 --> 00:37:23,779
if you have a mem copy we have a caller
stack frame we have the spectrum of mem

433
00:37:23,779 --> 00:37:29,269
copy and the stack frame of the mem copy
function is divided into the return

434
00:37:29,269 --> 00:37:36,288
address and local data if we adjust the
locations correctly we can override the

435
00:37:36,289 --> 00:37:43,250
call to mem copy so that the attacker or
attackers return address is written into

436
00:37:43,250 --> 00:37:47,480
the return address of the function then
return to any of the possible callers

437
00:37:47,480 --> 00:37:54,079
and this allows us to connect pretty
much arbitrary graphs on the control

438
00:37:54,079 --> 00:37:58,640
flow graph from one note to the other
and we can jump around in a control flow

439
00:37:58,640 --> 00:38:02,960
graph and get from one end of the
program to the other end to then reach

440
00:38:02,960 --> 00:38:10,279
system as you want if you have stack
integrity so you know cfi without shaq

441
00:38:10,279 --> 00:38:15,890
integrity is broken like broken beyond
repair and Status defenses are

442
00:38:15,890 --> 00:38:19,220
insufficient for snack attacks so we
need to have some form of stack

443
00:38:19,220 --> 00:38:20,180
integrity

444
00:38:20,180 --> 00:38:25,399
that's why we pushed the stack integrity
approach that we did two years ago into

445
00:38:25,400 --> 00:38:32,960
a log N and if you use all um with are
the arguments use are safe stack stack

446
00:38:32,960 --> 00:38:37,490
integrity you're using our mechanism to
protect your stack against such forms of

447
00:38:37,490 --> 00:38:41,598
attacks so this is actually out in
regular lbs if you're completing your

448
00:38:41,599 --> 00:38:49,819
software use the same stack to make your
systems more secure if we don't have if

449
00:38:49,819 --> 00:38:53,779
you have sec integrity the attack
becomes program dependent and we found

450
00:38:53,779 --> 00:38:57,049
that in many cases we are protected
against the tax

451
00:38:58,360 --> 00:39:06,550
so just to remember for control flow
integrity if you do have indirect

452
00:39:06,550 --> 00:39:11,980
control for transfers like indirect
jumps in our calls are so the individual

453
00:39:11,980 --> 00:39:17,050
targets are encoded in these equivalence
classes so there are multiple targets

454
00:39:17,050 --> 00:39:21,130
are allowed for each target and this is
what we are exploiting in this attack

455
00:39:21,130 --> 00:39:27,340
and the size of the class is crucial for
the affected effectiveness of control

456
00:39:27,340 --> 00:39:33,280
for integrity and we actually evaluated
about 50 or 60 approaches that are

457
00:39:33,280 --> 00:39:39,130
proposed and looked at how precise
deliver on in their underlying analysis

458
00:39:39,130 --> 00:39:44,320
and we compared all of them and try to
exploit them and just to show you a

459
00:39:44,320 --> 00:39:49,240
couple are there is the google I FCC
which is in alghemiss call the microsoft

460
00:39:49,240 --> 00:39:54,819
control-flow grow up guard llvm
contraflow integrity and mcf I pie cfi

461
00:39:54,820 --> 00:40:00,460
and binary only approach called lockdown
and we tested all of them for contraflow

462
00:40:00,460 --> 00:40:05,890
bending the forward edge specifies the
protection for indirect calls and

463
00:40:05,890 --> 00:40:11,319
indirect jumps the backward edge it
protects the return targets and you see

464
00:40:11,320 --> 00:40:16,060
that the first three of them the google
ifcc microsoft contraflow guard and

465
00:40:16,060 --> 00:40:20,560
logmc if I don't protect the backward at
all so we can easily do contraflow

466
00:40:20,560 --> 00:40:26,770
bending for all of them out of those
three the first to be found are very in

467
00:40:26,770 --> 00:40:32,110
precise they're very large equivalence
classes and easily allow attacks on the

468
00:40:32,110 --> 00:40:33,400
forward as well

469
00:40:33,400 --> 00:40:38,530
llvm cfi is rather precise and protect
the forward edge so as soon as they

470
00:40:38,530 --> 00:40:44,020
protect the shadow of the backward ads
with shadow stack or safe stack logmc if

471
00:40:44,020 --> 00:40:49,390
I will be very effective mcf I is
robbery effective on the forward edge

472
00:40:49,390 --> 00:40:53,500
and somewhat effective on a backward
edge and lockdown uses a shadow stack

473
00:40:53,500 --> 00:40:59,710
but you to the binary only approach it
is only reasonably effective on the

474
00:40:59,710 --> 00:41:06,340
forward edge so what if you have stack
integrity many times

475
00:41:06,340 --> 00:41:10,240
rob is no longer and an opportunity to
attack becomes much harder

476
00:41:10,930 --> 00:41:15,009
so we need to find a pass through the
program that uses different forms of

477
00:41:15,010 --> 00:41:17,980
virtual calls and if you guys are
interested in that

478
00:41:17,980 --> 00:41:22,359
look up the coop contra fight
object-oriented programming attack that

479
00:41:22,359 --> 00:41:29,200
simplifies and and describes this this
process and in the end if you would have

480
00:41:29,200 --> 00:41:35,169
a subset of the program that allows us
to inject code and execute code this

481
00:41:35,170 --> 00:41:40,089
will make the attacks much simpler and
if we can automate this this would be

482
00:41:40,089 --> 00:41:47,170
very awesome and we can just go and
start execute stuff so what we introduce

483
00:41:47,170 --> 00:41:55,150
is printf oriented programming assume
that you can execute or you can you get

484
00:41:55,150 --> 00:42:00,579
control of a format string and we've
shown that format strings are touring

485
00:42:00,579 --> 00:42:07,150
complete do you guys know what or
incomplete mrs. who knows what or

486
00:42:07,150 --> 00:42:09,609
incomplete mrs. ok

487
00:42:09,609 --> 00:42:13,450
half of you Tori completeness defines
that you can compute an arbitrary

488
00:42:13,450 --> 00:42:19,089
function see if an inter interpreter is
touring complete you can use it to

489
00:42:19,089 --> 00:42:23,020
compute arbitrary functionality so you
can pretty much execute any arbitrary

490
00:42:23,020 --> 00:42:29,859
code it's mostly an academic exercise
attackers don't really care about but

491
00:42:29,859 --> 00:42:34,839
for us academics it is a nice proof and
simple proof of concept and we showed

492
00:42:34,839 --> 00:42:38,319
that printf is storing complete so you
can do memory read you can do memory

493
00:42:38,319 --> 00:42:43,240
writes and you can do conditional
instructions and loops are implemented

494
00:42:43,240 --> 00:42:49,029
in a way that if you have two calls to
the same function if you have no stake

495
00:42:49,030 --> 00:42:53,530
integrity you can return to the first
loop and thereby implement the loop and

496
00:42:53,530 --> 00:42:58,119
you get your touring completeness the
program counter becomes to format string

497
00:42:58,119 --> 00:43:03,280
counter and you can use use dad's to
execute arbitrary code so this is very

498
00:43:03,280 --> 00:43:10,630
complex to construct and Nicholas
Carolinian UC Berkeley it's the this

499
00:43:10,630 --> 00:43:15,940
awesome implementation of a full
interpreter that we developed as a

500
00:43:15,940 --> 00:43:19,750
domain-specific language that you can
use the arbitrary programming language

501
00:43:19,750 --> 00:43:23,000
and you can write your program in a
string

502
00:43:23,000 --> 00:43:27,950
and then if you control the arguments to
any printf you can execute arbitrary

503
00:43:27,950 --> 00:43:29,960
behavior

504
00:43:29,960 --> 00:43:37,280
have you ever heard of brain fuck Chris
known brainfuck so far okay most of you

505
00:43:37,280 --> 00:43:43,760
bring fuck is a awesome little language
that is touring complete allows you to

506
00:43:43,760 --> 00:43:51,170
do arbitrary computations and as it only
consists of these 80 instructions on the

507
00:43:51,170 --> 00:43:54,980
side so you can you can go forward with
the data . you can go backwards the data

508
00:43:54,980 --> 00:43:59,690
pointer you can increment the data . you
can decrement the data . er there's an

509
00:43:59,690 --> 00:44:05,630
if put chart and gets chart you can read
input and output and it allows you to

510
00:44:05,630 --> 00:44:11,180
arbitrary computation now we went
through the process and define format

511
00:44:11,180 --> 00:44:18,470
strings for each of those instructions
so you can have a format string for each

512
00:44:18,470 --> 00:44:23,930
of these little things and if you
connect them in a specific way you can

513
00:44:23,930 --> 00:44:31,640
then execute an arbitrary brainfuck
program to assume that you have a

514
00:44:31,640 --> 00:44:38,839
program the calls printf in a loop we
divide the execution of the brain fog

515
00:44:38,840 --> 00:44:46,040
program into four stages if you ever had
a computer architecture class and

516
00:44:46,040 --> 00:44:49,580
instruction is executed on your system
by first decoding the instruction

517
00:44:49,580 --> 00:44:55,940
executing the instruction updating the
program counter and then possibly are

518
00:44:55,940 --> 00:45:00,650
writing back to memory and we followed
the same approach so we have four calls

519
00:45:00,650 --> 00:45:04,190
to print app so if you're calling printf
in the loop you're iterating through

520
00:45:04,190 --> 00:45:10,220
these four calls you are fetching the
instruction executing it updating the pc

521
00:45:10,220 --> 00:45:17,569
and then you're printing it so you can
now pass a format string that contains a

522
00:45:17,570 --> 00:45:24,200
brainfuck program into an exploit that
overrides the format string for printf

523
00:45:24,200 --> 00:45:28,850
and execute arbitrary computations how
awesome is that

524
00:45:30,740 --> 00:45:38,299
so let's do a very quick demo and look
at how that happens if I'm able to bring

525
00:45:38,300 --> 00:45:41,660
the screen over there

526
00:45:58,840 --> 00:46:04,060
ok so i got my files here i'll make
clean

527
00:46:05,740 --> 00:46:14,109
I do have the example here and we'll
just scroll down these this is pretty

528
00:46:14,110 --> 00:46:19,030
much the example that I showed you
before on the slide so we do have the

529
00:46:19,030 --> 00:46:27,250
loop here that execute one brainfuck
instruction and interpreter loop so it

530
00:46:27,250 --> 00:46:33,940
just assume that this is the main
function that Barbie inject some code

531
00:46:33,940 --> 00:46:38,800
into this is just a simple program that
allows us to inject code and override

532
00:46:38,800 --> 00:46:46,720
the individual format strings and we
have the execution of the instruction

533
00:46:46,720 --> 00:46:56,049
and the update of the pc so all this
code is on get up so you can check it

534
00:46:56,050 --> 00:47:02,770
out and test yourself and make sure that
I'm not not cheating and using my

535
00:47:02,770 --> 00:47:10,870
awesome pison skills i wrote a small
program that translates the an arbitrary

536
00:47:10,870 --> 00:47:16,810
brainfuck program into a format string
that is then check the injected into the

537
00:47:16,810 --> 00:47:22,779
program and passed us arguments that we
can inject the program and executed as

538
00:47:22,780 --> 00:47:28,480
part of the format string imagine that
the target program does in a loop a call

539
00:47:28,480 --> 00:47:30,190
to print out and we are

540
00:47:30,190 --> 00:47:38,950
hi checking that call to printf to
inject an arbitrary arm an arbitrary

541
00:47:38,950 --> 00:47:44,259
brainfuck program and I've got a couple
of brainfuck programs here let's see the

542
00:47:47,599 --> 00:47:56,299
this is hello world in brainfuck so if
we are iterating through the different

543
00:47:56,299 --> 00:47:59,269
cells huh

544
00:47:59,269 --> 00:48:09,439
yes well this is commented so it added a
little bit and we also have as your

545
00:48:09,440 --> 00:48:14,269
Pinsky trying off a brainfuck program
that princess or Prince you dry trying

546
00:48:14,269 --> 00:48:17,598
all formatted as your friends keep
trying

547
00:48:18,950 --> 00:48:24,859
brainfuck is an awesome language so
let's let's translate these two programs

548
00:48:24,859 --> 00:48:30,440
brainfuck programs into our format
strings that we can inject into our

549
00:48:30,440 --> 00:48:38,450
small small little program and I've got
a couple of other programs here that you

550
00:48:38,450 --> 00:48:43,460
can try on your on your computer when
you test it out later so we now have a

551
00:48:43,460 --> 00:48:49,220
couple of refineries let's execute hello
world and it prints hello world

552
00:48:49,729 --> 00:48:55,160
so we've injected format string that
contains a translated version of a

553
00:48:55,160 --> 00:49:01,549
brainfuck program and our interpreter
and executors as part of an execution to

554
00:49:01,549 --> 00:49:09,499
the format string let's execute the
brain fart code for the sierpinski

555
00:49:09,499 --> 00:49:21,109
triangle and we printed the sierpinski
triangle or a so this is online go check

556
00:49:21,109 --> 00:49:26,930
it out on get up and play with it for
for fun

557
00:49:29,119 --> 00:49:36,920
let me conclude so the low-level
languages like C and C++ are here to

558
00:49:36,920 --> 00:49:42,380
stay and they allows hackers a huge
amount of opportunities and allow us to

559
00:49:42,380 --> 00:49:48,680
play in very different and unintended
ways and we are working on the security

560
00:49:48,680 --> 00:49:52,819
side to defend against these
opportunities and on the hacker side

561
00:49:52,819 --> 00:49:56,240
we're trying to explore new
opportunities and both ends so there's a

562
00:49:56,240 --> 00:50:01,308
lot of fun project and fund research
project in there the defense's that we

563
00:50:01,309 --> 00:50:08,240
design our require a very careful policy
and very careful design and many of the

564
00:50:08,240 --> 00:50:11,299
current defenses especially the ones
that are deployed in our systems are

565
00:50:11,299 --> 00:50:16,880
broken and as we've shown without stack
integrity they can easily be mitigated

566
00:50:16,880 --> 00:50:20,990
so we need to get back integrity out
there are more people to use it so if

567
00:50:20,990 --> 00:50:25,819
you're combining the llvm use the safe
stack make sure that an attacker cannot

568
00:50:25,819 --> 00:50:30,980
just use drop on your on your program
and it comes very low performance cost

569
00:50:30,980 --> 00:50:35,569
and it's especially for the safe stack
it has met negligible overhead you will

570
00:50:35,569 --> 00:50:42,288
not even notice any difference to
regular execution and cfi which is the

571
00:50:42,289 --> 00:50:46,549
hottest defense mechanism that is
currently being discussed makes attack

572
00:50:46,549 --> 00:50:51,170
harder but is no Panik here so there are
corner cases in there that still allows

573
00:50:51,170 --> 00:50:53,599
exploitation undersea a fine

574
00:50:53,599 --> 00:50:57,259
so we need more principled offenses like
memory and type safety that we are

575
00:50:57,259 --> 00:51:01,400
currently proposing and hoping to get
into mainstream compilers so that all of

576
00:51:01,400 --> 00:51:05,329
you can profit from them and make
yourself feel more secure and resilient

577
00:51:05,329 --> 00:51:09,950
against any attacks and if that i would
like to end my talk and I'm happy to

578
00:51:09,950 --> 00:51:12,950
take any questions

579
00:51:15,869 --> 00:51:18,910
yeah

580
00:51:18,910 --> 00:51:26,020
welcome before any question we have one
tradition in Serbia it's your first time

581
00:51:26,020 --> 00:51:26,470
here

582
00:51:26,470 --> 00:51:29,470
yeah i think so you need to take one
drink

583
00:51:30,819 --> 00:51:33,819
I like that

584
00:51:37,520 --> 00:51:43,700
are you gonna try not to enjoin yeah

585
00:51:47,340 --> 00:51:50,340
it already

586
00:51:51,540 --> 00:52:04,350
ya goin I really sure that that's
choosing service is right for me will

587
00:52:04,350 --> 00:52:08,069
you

588
00:52:11,010 --> 00:52:14,010
thank you cheers

589
00:52:19,050 --> 00:52:20,829
yeah

590
00:52:20,829 --> 00:52:41,739
it was good i like it here now questions
that was a huge shot any question guys

591
00:52:41,739 --> 00:52:44,739
yeah

592
00:52:46,200 --> 00:52:55,890
did you guys have a microphone for with
the type control stuff you were talking

593
00:52:55,890 --> 00:53:00,240
at the beginning about controlling a
callback for college solutions that are

594
00:53:00,240 --> 00:53:05,819
based on a particular type of object
without packing doesn't that increase a

595
00:53:05,820 --> 00:53:11,099
programs vulnerability to reverse
engineering because the data descriptors

596
00:53:11,099 --> 00:53:18,660
are easier to trace um when I interested
in trading between academic answer it

597
00:53:18,660 --> 00:53:26,129
depends so that the thing is if your
readers engineering up the majority of

598
00:53:26,130 --> 00:53:30,510
objects already has a vtable pointer and
you get the same information on every

599
00:53:30,510 --> 00:53:34,500
table pointer so the information we use
doesn't make a difference for the

600
00:53:34,500 --> 00:53:39,300
majority of programs now there's a
slight amount of prof. see objects or

601
00:53:39,300 --> 00:53:44,730
C++ object that do not have a table
pointer for dose for the subset of C

602
00:53:44,730 --> 00:53:50,190
object or C classes that doesn't have
that do not have virtual calls and

603
00:53:50,190 --> 00:53:54,480
thereby a vtable pointer we do an add
additional information to the program

604
00:53:54,480 --> 00:53:59,579
but excited for example in in many large
software projects like chrome the vast

605
00:53:59,579 --> 00:54:04,410
majority of classes already has virtual
functions and we don't add any

606
00:54:04,410 --> 00:54:09,328
additional information there so it
depends you can add more information but

607
00:54:09,329 --> 00:54:15,630
we strongly believe that the security
benefit likely outweighs the additional

608
00:54:15,630 --> 00:54:24,549
increase in information that you give a
potential reverse-engineer sure thanks

609
00:54:24,549 --> 00:54:27,549
yeah

610
00:54:38,270 --> 00:54:46,730
help so I have a type safety question as
well what are the performance

611
00:54:46,730 --> 00:54:52,250
implications of that past that you
implemented that the past or at runtime

612
00:54:52,250 --> 00:54:59,480
well with you talk about the compilation
time or no i'm talking about the runtime

613
00:54:59,480 --> 00:55:01,250
no no compilation time

614
00:55:01,250 --> 00:55:10,610
um it's rather low a couple of percent
but so we do have performance results in

615
00:55:10,610 --> 00:55:17,330
the paper that is on my home page so you
can just look at the paper itself and go

616
00:55:17,330 --> 00:55:22,580
and look through the details of the
performance numbers it's for respect cpu

617
00:55:22,580 --> 00:55:27,620
programs which are a common benchmark
when evaluating performance overhead ads

618
00:55:27,620 --> 00:55:35,750
in the single-digit percent and same for
google chrome and firefox it's a couple

619
00:55:35,750 --> 00:55:40,040
of percent but you're still working on
optimizations so this is a research

620
00:55:40,040 --> 00:55:40,970
prototype

621
00:55:40,970 --> 00:55:45,259
I mean we haven't pushed it to mainline
LOL yet you're working on a on

622
00:55:45,260 --> 00:55:51,170
extensions to that system and will
hopefully push it sometime with the even

623
00:55:51,170 --> 00:55:55,070
lower overhead so we're still working on
performance optimizations so far it's in

624
00:55:55,070 --> 00:56:00,050
a single digits percent doesn't cook
does community have an equal any

625
00:56:00,050 --> 00:56:06,530
comments on the past I mean lbm
community so this paper will be

626
00:56:06,530 --> 00:56:14,390
presented in four weeks of so this was a
like a preview so if you haven't up

627
00:56:14,390 --> 00:56:18,379
truck we haven't started up straining
the packet okay but we've released the

628
00:56:18,380 --> 00:56:23,900
source code so you can check it out if
you want to arm will start up streaming

629
00:56:23,900 --> 00:56:25,700
as soon as the code has settled

630
00:56:25,700 --> 00:56:30,020
remember we are on academic research
group so we are developing a first

631
00:56:30,020 --> 00:56:34,280
prototype then you're publishing it then
it takes some time until we actually

632
00:56:34,280 --> 00:56:35,780
going upstream it

633
00:56:35,780 --> 00:56:39,269
okay thank you it was one more

634
00:56:39,269 --> 00:56:43,140
yeah

635
00:56:48,600 --> 00:56:51,600
I think this thanks

636
00:56:55,170 --> 00:57:01,349
hi I was wondering is for on these
attacks with a contraflow that you've

637
00:57:01,349 --> 00:57:07,829
shown with mem copy what it would be
what we would happen if you in line all

638
00:57:07,829 --> 00:57:16,920
of these functions it would it would be
better armed sure if you in line the

639
00:57:16,920 --> 00:57:20,400
code you don't get a return instruction
without a return instruction cannot

640
00:57:20,400 --> 00:57:22,290
override the target

641
00:57:22,290 --> 00:57:28,319
luckily arm these are lipsy functions
and most of the time there they are not

642
00:57:28,319 --> 00:57:33,299
in liable in a way they are developed so
you're still lucky there from the

643
00:57:33,299 --> 00:57:40,020
attacker side arm i do know that album
has primitives for some of these

644
00:57:40,020 --> 00:57:45,000
functions and they try to inline their
own versions of lvm under some

645
00:57:45,000 --> 00:57:54,480
conditions and as an interesting side
note we recently found a bug in some lip

646
00:57:54,480 --> 00:57:59,609
sees version of mem copy that allowed
other arbitrary behavior but this might

647
00:57:59,609 --> 00:58:11,578
be a discussion . for the bar later on
any other questions thanks again

648
00:58:11,579 --> 00:58:12,359
go play with the code

