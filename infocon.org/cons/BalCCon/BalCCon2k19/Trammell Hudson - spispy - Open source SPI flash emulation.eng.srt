1
00:00:25,520 --> 00:00:31,259
hello everyone we are going to listen

2
00:00:28,830 --> 00:00:35,360
now spy spy open-source spi flash

3
00:00:31,260 --> 00:00:35,360
emulation by drum Oh

4
00:00:40,309 --> 00:00:45,629
I'm really glad everyone is here today

5
00:00:43,350 --> 00:00:47,160
to learn about the spy spy flash

6
00:00:45,629 --> 00:00:50,809
emulator it's project I've been working

7
00:00:47,160 --> 00:00:53,669
on for the past few months and it's a

8
00:00:50,809 --> 00:00:55,970
open source tool that lets us more

9
00:00:53,670 --> 00:00:58,530
quickly work with spy flashes and

10
00:00:55,970 --> 00:01:00,360
hopefully at the end of the talk you'll

11
00:00:58,530 --> 00:01:03,449
understand what those are why we're

12
00:01:00,360 --> 00:01:06,900
doing it and how it works so first let's

13
00:01:03,449 --> 00:01:08,880
talk about what is a spy flash and if we

14
00:01:06,900 --> 00:01:11,820
look at a motherboard there are some

15
00:01:08,880 --> 00:01:14,460
small chips on it that store the

16
00:01:11,820 --> 00:01:18,089
firmware that the CPU executes before it

17
00:01:14,460 --> 00:01:20,940
loads the operating system and in days

18
00:01:18,090 --> 00:01:23,430
past these were around 64 kilobytes and

19
00:01:20,940 --> 00:01:26,340
they destroyed the BIOS these days

20
00:01:23,430 --> 00:01:28,890
there's a lot more complexity typically

21
00:01:26,340 --> 00:01:30,899
things like the the closed source UEFI

22
00:01:28,890 --> 00:01:33,689
firmware but there's also open source

23
00:01:30,899 --> 00:01:37,369
firmware like Linux boot and core boot

24
00:01:33,689 --> 00:01:40,109
that you can install into those flashes

25
00:01:37,369 --> 00:01:42,899
if we get really close to the flash we

26
00:01:40,109 --> 00:01:45,630
can make out the part number and we can

27
00:01:42,899 --> 00:01:47,210
look up that datasheet to find out more

28
00:01:45,630 --> 00:01:49,859
about it

29
00:01:47,210 --> 00:01:51,839
this gives us the definition of spy is

30
00:01:49,859 --> 00:01:54,449
serial peripheral interface which is a

31
00:01:51,840 --> 00:01:56,719
pre generic term in this case they're

32
00:01:54,450 --> 00:01:59,640
typically three wire three or four wires

33
00:01:56,719 --> 00:02:03,149
it also tells us that the size of it's

34
00:01:59,640 --> 00:02:05,909
128 mega bits this one's 16 megabytes

35
00:02:03,149 --> 00:02:09,030
which may not seem like a lot in this

36
00:02:05,909 --> 00:02:11,880
modern era of gigabyte or terabyte SD

37
00:02:09,030 --> 00:02:16,560
cards but it's a huge step up from the

38
00:02:11,880 --> 00:02:19,650
64 K we used to have so why do we want

39
00:02:16,560 --> 00:02:23,730
to emulate spy flashes well if you're

40
00:02:19,650 --> 00:02:26,040
working on open source for firmware like

41
00:02:23,730 --> 00:02:27,810
poor boot or Linux boot or if you're

42
00:02:26,040 --> 00:02:30,480
doing security research on the close

43
00:02:27,810 --> 00:02:32,970
source things like UEFI you end up

44
00:02:30,480 --> 00:02:35,399
having to reflash these chips a lot

45
00:02:32,970 --> 00:02:36,840
in fact I have spent an enormous amount

46
00:02:35,400 --> 00:02:39,150
of my time in the past few years

47
00:02:36,840 --> 00:02:44,310
reflashing these chips

48
00:02:39,150 --> 00:02:47,400
and it is really really slow and you

49
00:02:44,310 --> 00:02:49,950
might think it's only 16 megabytes how

50
00:02:47,400 --> 00:02:51,930
slow could it be and the problem is that

51
00:02:49,950 --> 00:02:53,700
these are designed to be roms they're

52
00:02:51,930 --> 00:02:56,430
not designed to be updated all the time

53
00:02:53,700 --> 00:02:58,619
so they haven't optimized for the right

54
00:02:56,430 --> 00:03:01,260
speed you have to erase them for

55
00:02:58,620 --> 00:03:04,410
kilobytes at a time and in the worst

56
00:03:01,260 --> 00:03:09,420
case it's a 120 milliseconds to erase a

57
00:03:04,410 --> 00:03:11,700
4k sector so if we do the math it's 120

58
00:03:09,420 --> 00:03:14,670
milliseconds times 16 Meg's divided by 4

59
00:03:11,700 --> 00:03:16,679
we're talking about 8 minutes to to

60
00:03:14,670 --> 00:03:18,480
rewrite one of these things and that's

61
00:03:16,680 --> 00:03:21,660
an enormous amount of time to spend

62
00:03:18,480 --> 00:03:23,670
every time you want to reprogram it so

63
00:03:21,660 --> 00:03:25,980
let's look at how this works out for the

64
00:03:23,670 --> 00:03:28,679
a day in the life of a core boot

65
00:03:25,980 --> 00:03:32,130
developer you finally finished building

66
00:03:28,680 --> 00:03:34,290
core boot and it's time to flash it but

67
00:03:32,130 --> 00:03:35,850
first you have to turn off the power to

68
00:03:34,290 --> 00:03:38,160
the Machine you're going to flash

69
00:03:35,850 --> 00:03:40,230
because the flashes aren't multi

70
00:03:38,160 --> 00:03:42,000
mastered you then have to carefully

71
00:03:40,230 --> 00:03:43,829
attach your flash programmer because

72
00:03:42,000 --> 00:03:46,140
most of the commercial flash programmers

73
00:03:43,830 --> 00:03:49,140
won't let you tri-state the lines so you

74
00:03:46,140 --> 00:03:51,570
can't boot with them attached and then

75
00:03:49,140 --> 00:03:53,850
you can finally run flash rom it start

76
00:03:51,570 --> 00:03:55,859
flashing the first bit goes pretty fast

77
00:03:53,850 --> 00:03:57,780
because you probably haven't changed the

78
00:03:55,860 --> 00:04:00,420
management engine section unless you're

79
00:03:57,780 --> 00:04:04,170
doing security research on that which I

80
00:04:00,420 --> 00:04:05,760
used to do as well and then it hits the

81
00:04:04,170 --> 00:04:11,790
core boot part and it has to start

82
00:04:05,760 --> 00:04:15,480
erasing this box and yeah three minutes

83
00:04:11,790 --> 00:04:20,880
in it's still slowly erasing and right

84
00:04:15,480 --> 00:04:22,019
in five minutes in I mean this is not

85
00:04:20,880 --> 00:04:25,830
the way you want to spend your day

86
00:04:22,019 --> 00:04:28,290
waiting for these chips so finally five

87
00:04:25,830 --> 00:04:29,969
and half minutes later at 49 kilobytes

88
00:04:28,290 --> 00:04:33,200
per second we're talking about dial-up

89
00:04:29,970 --> 00:04:36,000
modem speeds it's finally done flashing

90
00:04:33,200 --> 00:04:38,310
but you're not done yet because now you

91
00:04:36,000 --> 00:04:40,440
have to remove the the flash programmer

92
00:04:38,310 --> 00:04:43,830
clip from the board power on the machine

93
00:04:40,440 --> 00:04:45,150
and hopefully it boots but if you've

94
00:04:43,830 --> 00:04:46,200
done firmware development it probably

95
00:04:45,150 --> 00:04:49,729
doesn't

96
00:04:46,200 --> 00:04:52,830
and you have to rebuild and reflash and

97
00:04:49,730 --> 00:04:55,980
you know this is this is how I used to

98
00:04:52,830 --> 00:04:59,039
spend my day and like they say on TV

99
00:04:55,980 --> 00:05:01,740
there's got to be a better way so but I

100
00:04:59,040 --> 00:05:05,490
wanted to show you today is a live demo

101
00:05:01,740 --> 00:05:09,330
so can I get a volunteer with a ThinkPad

102
00:05:05,490 --> 00:05:14,820
X 220 or 230 can't promise it's not

103
00:05:09,330 --> 00:05:17,250
gonna get bricked but thus far I have

104
00:05:14,820 --> 00:05:23,420
not bricked any but if it if I do break

105
00:05:17,250 --> 00:05:31,080
it you can keep both pieces so yes I

106
00:05:23,420 --> 00:05:33,390
love it thank you sir

107
00:05:31,080 --> 00:05:35,969
what I love about hacker conferences is

108
00:05:33,390 --> 00:05:39,530
there's always somebody willing to jump

109
00:05:35,970 --> 00:05:39,530
up with that so

110
00:05:41,719 --> 00:05:50,479
I guess that's first let's boot it and

111
00:05:45,409 --> 00:05:54,159
see what it comes up with and this

112
00:05:50,479 --> 00:05:54,159
should just be the the stock firmware

113
00:05:56,530 --> 00:06:03,700
UEFI takes a little while sometimes okay

114
00:05:59,680 --> 00:06:08,740
this is the stock firmware so we're

115
00:06:03,700 --> 00:06:11,320
gonna we're gonna power it off the nice

116
00:06:08,740 --> 00:06:14,020
thing about the the X 200 is the flash

117
00:06:11,320 --> 00:06:16,500
chip is very accessible underneath the

118
00:06:14,020 --> 00:06:16,500
mousepad

119
00:06:26,610 --> 00:06:34,750
all right so here we have the spy flash

120
00:06:29,950 --> 00:06:37,440
chip and we have the spy spy so we're

121
00:06:34,750 --> 00:06:37,440
going to attach it to it

122
00:06:37,909 --> 00:06:45,550
making sure to note pin 1 is the one

123
00:06:41,990 --> 00:06:45,550
with the the dot on it

124
00:06:53,620 --> 00:07:02,650
okay so I've built a coreboot image and

125
00:06:57,430 --> 00:07:06,160
now we're going to we're going to upload

126
00:07:02,650 --> 00:07:11,590
it with the spy spy tool into the end of

127
00:07:06,160 --> 00:07:14,020
the board and put it in monitor mode so

128
00:07:11,590 --> 00:07:17,159
this is going at USB serial speeds about

129
00:07:14,020 --> 00:07:17,159
one megabyte per second

130
00:07:19,220 --> 00:07:25,970
okay it's now in monitor mode so when we

131
00:07:21,950 --> 00:07:27,650
turn on the machine now we get a

132
00:07:25,970 --> 00:07:31,550
printout from bunch things and now we

133
00:07:27,650 --> 00:07:35,060
have C BIOS from the corporate tree up

134
00:07:31,550 --> 00:07:37,930
and running so this is way faster than

135
00:07:35,060 --> 00:07:37,930
eight minutes

136
00:07:39,080 --> 00:07:46,729
but wait there's more so as I mentioned

137
00:07:44,300 --> 00:07:49,759
you frequently end up having to change

138
00:07:46,729 --> 00:07:50,719
these things all the time and when

139
00:07:49,759 --> 00:07:52,490
you're doing firmware development you

140
00:07:50,720 --> 00:07:56,409
end up having to tweak them so we're

141
00:07:52,490 --> 00:08:00,919
gonna we're gonna modify the firmware

142
00:07:56,409 --> 00:08:05,389
and we're gonna rebuild a core boot and

143
00:08:00,919 --> 00:08:09,549
see BIOS okay and now we're going to

144
00:08:05,389 --> 00:08:09,550
upload just the the coreboot section

145
00:08:16,469 --> 00:08:20,580
that's pretty fast and now when we boot

146
00:08:19,289 --> 00:08:22,998
it we're going to get something a little

147
00:08:20,580 --> 00:08:22,998
different

148
00:08:24,230 --> 00:08:35,690
and all right so this is a Wade if

149
00:08:34,760 --> 00:08:37,490
you're doing this sort of firmware

150
00:08:35,690 --> 00:08:40,370
development this is a way to make it way

151
00:08:37,490 --> 00:08:42,289
way faster and way more convenient it

152
00:08:40,370 --> 00:08:46,220
also lets us start to think about adding

153
00:08:42,289 --> 00:08:47,329
other things like fuzzing and continuous

154
00:08:46,220 --> 00:08:52,420
integration into our firmware

155
00:08:47,330 --> 00:08:52,420
development trays so

156
00:08:53,740 --> 00:08:59,860
okay it's nothing

157
00:08:56,660 --> 00:08:59,860
all right so

158
00:09:01,330 --> 00:09:05,890
so we can skip the the parts about you

159
00:09:03,580 --> 00:09:07,990
know if it didn't work with the demo its

160
00:09:05,890 --> 00:09:11,830
net loaded at what about you might per

161
00:09:07,990 --> 00:09:13,720
second which was limited by the the USB

162
00:09:11,830 --> 00:09:15,670
serial port that we don't implemented in

163
00:09:13,720 --> 00:09:16,870
the fpga we can definitely get a lot

164
00:09:15,670 --> 00:09:19,630
faster than that

165
00:09:16,870 --> 00:09:21,459
but this is just world's better so

166
00:09:19,630 --> 00:09:24,880
haven't been motivated to really go into

167
00:09:21,459 --> 00:09:26,319
it that much yet the other big

168
00:09:24,880 --> 00:09:27,939
difference is we can now soft reboot

169
00:09:26,320 --> 00:09:29,470
into these new firmware so we don't

170
00:09:27,940 --> 00:09:30,580
necessarily have to power cycle we don't

171
00:09:29,470 --> 00:09:32,680
have to keep removing the flash

172
00:09:30,580 --> 00:09:36,040
programmer so that also speeds up the

173
00:09:32,680 --> 00:09:38,319
time the other really neat thing that

174
00:09:36,040 --> 00:09:41,140
this gives us is insight into what the

175
00:09:38,320 --> 00:09:42,430
CPU is doing when it starts out if you

176
00:09:41,140 --> 00:09:46,779
just come here to Congress from the

177
00:09:42,430 --> 00:09:50,620
1970s you might think that the x86 loads

178
00:09:46,779 --> 00:09:52,750
the legacy reset vector from the top of

179
00:09:50,620 --> 00:09:56,830
memory and jumps into it but that's that

180
00:09:52,750 --> 00:09:59,620
is no longer what actually happens so if

181
00:09:56,830 --> 00:10:01,270
you watched the my computer screen when

182
00:09:59,620 --> 00:10:03,399
the system is booting it printed out a

183
00:10:01,270 --> 00:10:05,020
bunch of read addresses and we can

184
00:10:03,399 --> 00:10:07,390
correlate those with what's in the ROM

185
00:10:05,020 --> 00:10:09,790
contents to see what the CPU is doing as

186
00:10:07,390 --> 00:10:12,250
it starts out the first thing that

187
00:10:09,790 --> 00:10:14,709
happens is it loads the that the

188
00:10:12,250 --> 00:10:16,630
platform controller hub reads the Intel

189
00:10:14,709 --> 00:10:19,270
flash descriptor to determine what type

190
00:10:16,630 --> 00:10:21,850
of chip there is then the Intel

191
00:10:19,270 --> 00:10:26,860
management engine reads its

192
00:10:21,850 --> 00:10:29,050
firmware and gets run in the Emme starts

193
00:10:26,860 --> 00:10:32,560
the x86 but it doesn't go to the reset

194
00:10:29,050 --> 00:10:34,689
vector instead CPU microcode finds the

195
00:10:32,560 --> 00:10:37,209
firmware interface table it parses it

196
00:10:34,690 --> 00:10:41,380
and then looks for micro code updates

197
00:10:37,209 --> 00:10:43,839
and applies them to the cpu if you have

198
00:10:41,380 --> 00:10:48,339
a boot card equip CPU which this one is

199
00:10:43,839 --> 00:10:51,910
not the boot guard ACM is then fetched

200
00:10:48,339 --> 00:10:54,250
validated and run and then finally we

201
00:10:51,910 --> 00:10:58,180
get to the reset vector and which jumps

202
00:10:54,250 --> 00:11:00,820
into the BIOS in this case 13,000 reads

203
00:10:58,180 --> 00:11:03,040
from the from the flash chip later so

204
00:11:00,820 --> 00:11:04,839
you know the way systems have started

205
00:11:03,040 --> 00:11:07,719
out this completely changed but we can

206
00:11:04,839 --> 00:11:11,730
now see that by watching this is kind of

207
00:11:07,720 --> 00:11:15,910
like Wireshark for the for the spy bus

208
00:11:11,730 --> 00:11:18,310
if we plot those addresses versus time

209
00:11:15,910 --> 00:11:18,939
we also can find some interesting

210
00:11:18,310 --> 00:11:22,689
patterns

211
00:11:18,940 --> 00:11:25,120
so there's addresses on the y-axis time

212
00:11:22,690 --> 00:11:29,560
on the x-axis and I've colored the

213
00:11:25,120 --> 00:11:31,149
addresses based on if they're the first

214
00:11:29,560 --> 00:11:35,500
time the address is red or the second

215
00:11:31,149 --> 00:11:38,259
time so this linear scan of those

216
00:11:35,500 --> 00:11:40,949
addresses is when Boogaard is doing a

217
00:11:38,259 --> 00:11:44,170
signature check on part of the firmware

218
00:11:40,949 --> 00:11:47,620
which means these rereads of those

219
00:11:44,170 --> 00:11:51,959
addresses are a time check time of use

220
00:11:47,620 --> 00:11:55,870
security vulnerability potentially and

221
00:11:51,959 --> 00:11:59,018
my colleague Peter Bosch and I were able

222
00:11:55,870 --> 00:12:03,069
to leverage that to get a root of trust

223
00:11:59,019 --> 00:12:05,680
bypass in Intel's boot guard that they

224
00:12:03,069 --> 00:12:09,160
are still working on mitigating we went

225
00:12:05,680 --> 00:12:12,370
through disclosure with them about 150

226
00:12:09,160 --> 00:12:14,410
days and finally they they said it's

227
00:12:12,370 --> 00:12:16,269
taking too long for them and we were

228
00:12:14,410 --> 00:12:21,750
cleared to go ahead and print it at hack

229
00:12:16,269 --> 00:12:21,750
in the Box in Amsterdam a few months ago

230
00:12:21,810 --> 00:12:27,119
so again this is a computer Congress and

231
00:12:25,769 --> 00:12:30,959
you all are very technical so let's talk

232
00:12:27,120 --> 00:12:33,240
about how this this works and before we

233
00:12:30,959 --> 00:12:35,758
get into to the code I really want to

234
00:12:33,240 --> 00:12:37,499
thank the projects that this project

235
00:12:35,759 --> 00:12:39,449
depends on that with a lot of these

236
00:12:37,499 --> 00:12:41,189
open-source projects

237
00:12:39,449 --> 00:12:43,920
we're not developing it in isolation

238
00:12:41,189 --> 00:12:46,730
we're building on the work that other

239
00:12:43,920 --> 00:12:49,829
people are doing that's really valuable

240
00:12:46,730 --> 00:12:53,279
in this case we're using the open-source

241
00:12:49,829 --> 00:12:55,949
fpga tool chain of uses project trellis

242
00:12:53,279 --> 00:12:58,379
and next PNR that has completely

243
00:12:55,949 --> 00:13:02,219
revolutionized how fpga development is

244
00:12:58,379 --> 00:13:04,410
being done and I'm really excited that

245
00:13:02,220 --> 00:13:06,660
there's now a completely open-source way

246
00:13:04,410 --> 00:13:10,469
to work with this sort of program little

247
00:13:06,660 --> 00:13:12,899
hardware I also want to thank the folks

248
00:13:10,470 --> 00:13:15,809
at red space the hacker space Tintin hog

249
00:13:12,899 --> 00:13:18,139
for letting me hang out there and work

250
00:13:15,809 --> 00:13:21,389
with some of them while we're developing

251
00:13:18,139 --> 00:13:26,819
these tools specifically ELISA Milburn

252
00:13:21,389 --> 00:13:28,649
and Peter Bosch the what we developed at

253
00:13:26,819 --> 00:13:32,250
rest phase for the hack in the box demo

254
00:13:28,649 --> 00:13:35,399
was based on a small ice 40 FPGA it has

255
00:13:32,250 --> 00:13:37,230
one mega bit of block ram which isn't

256
00:13:35,399 --> 00:13:39,269
enough to store the whole the whole

257
00:13:37,230 --> 00:13:40,860
firmware image but it was enough to do

258
00:13:39,269 --> 00:13:43,559
our proof of concept for the time of

259
00:13:40,860 --> 00:13:45,209
check time of use in order to store the

260
00:13:43,559 --> 00:13:48,480
full one we need something bigger

261
00:13:45,209 --> 00:13:51,869
and again hackerspaces came through and

262
00:13:48,480 --> 00:13:53,730
delivered a wonderful open-source fpga

263
00:13:51,870 --> 00:13:58,980
board this is from a croatian hacker

264
00:13:53,730 --> 00:14:02,639
space that has a ECP 5 FPGA and 32

265
00:13:58,980 --> 00:14:04,500
megabytes of DRAM that we can read and

266
00:14:02,639 --> 00:14:06,949
write from at about 250 megabytes per

267
00:14:04,500 --> 00:14:06,949
second

268
00:14:07,290 --> 00:14:16,709
SD RAM or DRAM in general is a really

269
00:14:10,650 --> 00:14:18,660
complex sort of design it has all of

270
00:14:16,710 --> 00:14:20,600
these sort of dark magic state

271
00:14:18,660 --> 00:14:24,680
transitions that you have to deal with

272
00:14:20,600 --> 00:14:28,830
in order to be able to interface with it

273
00:14:24,680 --> 00:14:30,660
and you know I'm lazy I don't want to

274
00:14:28,830 --> 00:14:32,730
have to implement that but again there's

275
00:14:30,660 --> 00:14:34,770
a wonderful open-source tool that people

276
00:14:32,730 --> 00:14:38,570
have put out there

277
00:14:34,770 --> 00:14:43,290
Stefan Christensen wrote and published a

278
00:14:38,570 --> 00:14:45,780
modular SDRAM a bit of error log that we

279
00:14:43,290 --> 00:14:49,760
were able to interfere would emerge into

280
00:14:45,780 --> 00:14:53,610
spy spy and get working on the ECB five

281
00:14:49,760 --> 00:14:56,280
us want to give thanks to scanline who

282
00:14:53,610 --> 00:14:59,730
as with many projects had already done

283
00:14:56,280 --> 00:15:02,400
something very similar back in 2009 she

284
00:14:59,730 --> 00:15:05,130
was immolated a Nintendo DS save

285
00:15:02,400 --> 00:15:06,800
cartridge which is a very small spy

286
00:15:05,130 --> 00:15:09,120
flash that's read at a very slow speed

287
00:15:06,800 --> 00:15:11,099
but she documented enough of the

288
00:15:09,120 --> 00:15:14,250
protocol that it made it very easy for

289
00:15:11,100 --> 00:15:18,930
us to build on her work to build a our

290
00:15:14,250 --> 00:15:21,650
emulator so let's talk about what that

291
00:15:18,930 --> 00:15:21,650
protocol looks like

292
00:15:22,010 --> 00:15:26,150
I mentioned that it's important to

293
00:15:24,470 --> 00:15:27,830
notice where the dot is on the chip

294
00:15:26,150 --> 00:15:32,209
because in the datasheet that tells us

295
00:15:27,830 --> 00:15:35,980
which one is going to be pin 1 and I

296
00:15:32,210 --> 00:15:38,030
mentioned it's a four wire protocol

297
00:15:35,980 --> 00:15:41,210
obviously power ground is very important

298
00:15:38,030 --> 00:15:43,699
but the the chip select line is the one

299
00:15:41,210 --> 00:15:46,970
that tells the flash chip when it's time

300
00:15:43,700 --> 00:15:51,200
that it's the the x86 wants to talk to

301
00:15:46,970 --> 00:15:52,910
it and while that's low the chip is

302
00:15:51,200 --> 00:15:55,940
selected so we would say this is a

303
00:15:52,910 --> 00:15:59,000
active low signal and we designate that

304
00:15:55,940 --> 00:16:03,560
with either a an exclamation mark or a

305
00:15:59,000 --> 00:16:10,580
pound sign in the name the next pin we

306
00:16:03,560 --> 00:16:14,000
need is the clock which is moving at

307
00:16:10,580 --> 00:16:19,040
some speed controlled by the x86 and the

308
00:16:14,000 --> 00:16:20,420
data lines are are clocked on the rising

309
00:16:19,040 --> 00:16:22,370
edge that they're sorting to the

310
00:16:20,420 --> 00:16:26,750
registers so we would call this rising

311
00:16:22,370 --> 00:16:29,600
edge clocked and then this the serial in

312
00:16:26,750 --> 00:16:31,100
line is from the from the x86 and the

313
00:16:29,600 --> 00:16:33,710
protocol typically consists of a command

314
00:16:31,100 --> 00:16:37,730
byte followed by some number of address

315
00:16:33,710 --> 00:16:41,480
bytes and then the spy flash responds on

316
00:16:37,730 --> 00:16:44,840
the serial out line with some number of

317
00:16:41,480 --> 00:16:48,100
data bytes as well and again those are

318
00:16:44,840 --> 00:16:48,100
also rising edge clocked

319
00:16:49,130 --> 00:16:55,640
if we go into the data see we can see

320
00:16:51,500 --> 00:16:57,620
the read command which is what most of

321
00:16:55,640 --> 00:17:01,670
the bulk of what we saw scrolling by

322
00:16:57,620 --> 00:17:04,460
were and these have a three byte address

323
00:17:01,670 --> 00:17:10,909
into the flash three bytes gives you 2

324
00:17:04,460 --> 00:17:13,910
to the 24th or 16 megabytes and on the

325
00:17:10,910 --> 00:17:17,120
wire you typically see the 0 3 followed

326
00:17:13,910 --> 00:17:20,930
by the 24 bits followed by then up to

327
00:17:17,119 --> 00:17:23,409
256 bytes of response data now they get

328
00:17:20,930 --> 00:17:23,410
clocked out

329
00:17:23,910 --> 00:17:28,289
and the very log code that we used for

330
00:17:26,459 --> 00:17:31,740
the hack of the box Jim oh look sort of

331
00:17:28,289 --> 00:17:33,990
like this pretty this is a little bit of

332
00:17:31,740 --> 00:17:37,620
previant but basically on every rising

333
00:17:33,990 --> 00:17:39,900
edge of the spy clock we shift an

334
00:17:37,620 --> 00:17:41,039
address fit in from the data in line we

335
00:17:39,900 --> 00:17:43,710
increment the number of bits we've

336
00:17:41,039 --> 00:17:48,929
received and if we've received 23 bits

337
00:17:43,710 --> 00:17:52,080
then we we look up in our block ram for

338
00:17:48,929 --> 00:17:55,169
the data at that address and we shifted

339
00:17:52,080 --> 00:17:58,230
out the data out register this worked

340
00:17:55,169 --> 00:18:00,659
wonderfully on the ice for tea with one

341
00:17:58,230 --> 00:18:02,549
megabit of block ram we were able to do

342
00:18:00,659 --> 00:18:04,500
our very small proof-of-concept

343
00:18:02,549 --> 00:18:08,429
but when we tried doing this with the

344
00:18:04,500 --> 00:18:12,809
DRAM it didn't work what we ended up

345
00:18:08,429 --> 00:18:14,850
seeing is that the first bit coming out

346
00:18:12,809 --> 00:18:16,950
from that DRAM when we clocked it out in

347
00:18:14,850 --> 00:18:20,100
the data outline was delayed by about 50

348
00:18:16,950 --> 00:18:22,500
nanoseconds from the rising edge of the

349
00:18:20,100 --> 00:18:24,629
clock and that meant that we didn't meet

350
00:18:22,500 --> 00:18:26,760
timing and the system just wouldn't even

351
00:18:24,630 --> 00:18:30,289
start up who wouldn't boot because the

352
00:18:26,760 --> 00:18:32,760
data were almost always corrupted and

353
00:18:30,289 --> 00:18:36,960
the reason for that is due to the way

354
00:18:32,760 --> 00:18:38,490
reads happen in DRAM that what we think

355
00:18:36,960 --> 00:18:41,340
of as an atomic operation where we say

356
00:18:38,490 --> 00:18:44,640
you know index some address into the RAM

357
00:18:41,340 --> 00:18:47,340
happens over multiple clock cycles where

358
00:18:44,640 --> 00:18:53,700
on the first clock cycle the row is

359
00:18:47,340 --> 00:18:56,459
addressed and this is typically 12 bits

360
00:18:53,700 --> 00:18:58,919
out of it then some number of clock

361
00:18:56,460 --> 00:19:00,750
cycles later a column from that row is

362
00:18:58,919 --> 00:19:02,690
addressed and this has to do with the

363
00:19:00,750 --> 00:19:05,700
way DRAM is implemented it has to copy

364
00:19:02,690 --> 00:19:08,460
values from a bunch of capacitors into

365
00:19:05,700 --> 00:19:13,380
registers and then you can read from

366
00:19:08,460 --> 00:19:16,740
those registers and this latency is

367
00:19:13,380 --> 00:19:18,929
typically 5 to 7 DRAM clocks or 50 to

368
00:19:16,740 --> 00:19:21,450
100 nanoseconds and what's really

369
00:19:18,929 --> 00:19:24,000
interesting is this doesn't depend on

370
00:19:21,450 --> 00:19:28,080
the speed of the DRAM that if you go to

371
00:19:24,000 --> 00:19:32,040
your your brand-new PC with 2.4

372
00:19:28,080 --> 00:19:34,620
gigahertz ddr4 it probably takes about

373
00:19:32,040 --> 00:19:36,299
100 nanoseconds to do a random read

374
00:19:34,620 --> 00:19:36,790
it's just that caches do a good job of

375
00:19:36,299 --> 00:19:39,100
hiding

376
00:19:36,790 --> 00:19:41,409
but in this case we don't know what the

377
00:19:39,100 --> 00:19:44,860
cash is what the read performance is

378
00:19:41,410 --> 00:19:50,080
going to be so this is not going to work

379
00:19:44,860 --> 00:19:51,370
for us and the problem that we're

380
00:19:50,080 --> 00:19:54,159
running into is we don't control the

381
00:19:51,370 --> 00:19:57,939
clock it's being controlled by the x86

382
00:19:54,160 --> 00:20:01,060
is talking to the flash simulator so we

383
00:19:57,940 --> 00:20:03,880
basically have from the rising edge of

384
00:20:01,060 --> 00:20:05,950
that twenty fourth bit to the falling

385
00:20:03,880 --> 00:20:10,990
edge of the clock to get a some data

386
00:20:05,950 --> 00:20:13,090
available which at a 20 megahertz spy

387
00:20:10,990 --> 00:20:19,510
clock means we have to have a result in

388
00:20:13,090 --> 00:20:21,310
about 25 nanoseconds or less luckily we

389
00:20:19,510 --> 00:20:23,860
have an open source memory controller

390
00:20:21,310 --> 00:20:26,649
that we're using so we can modify it to

391
00:20:23,860 --> 00:20:29,949
let us do these sorts of things in this

392
00:20:26,650 --> 00:20:32,860
case what we do is we can detect once

393
00:20:29,950 --> 00:20:34,570
we've received 14 bits of the address we

394
00:20:32,860 --> 00:20:38,709
can actually go ahead and kick off the

395
00:20:34,570 --> 00:20:40,720
row activation once we received another

396
00:20:38,710 --> 00:20:45,520
9 bits of the address we can do the

397
00:20:40,720 --> 00:20:49,090
column read from that row and then we

398
00:20:45,520 --> 00:20:51,220
get back 16 bits from that column which

399
00:20:49,090 --> 00:20:52,959
means that on the falling edge we can

400
00:20:51,220 --> 00:20:55,960
select either the upper or lower byte

401
00:20:52,960 --> 00:21:00,040
from from that result and write it out

402
00:20:55,960 --> 00:21:03,220
to to the data outline and this actually

403
00:21:00,040 --> 00:21:05,440
works we're only about 10 nanoseconds

404
00:21:03,220 --> 00:21:07,630
slower than the real flash chip which is

405
00:21:05,440 --> 00:21:10,360
enough to meet the timing the setup and

406
00:21:07,630 --> 00:21:15,310
hold timing requirements for this for

407
00:21:10,360 --> 00:21:16,659
the read and at a 20 megahertz clock so

408
00:21:15,310 --> 00:21:19,870
we do actually have to cheat a little

409
00:21:16,660 --> 00:21:22,570
bit and not let the x86 run that clock

410
00:21:19,870 --> 00:21:25,260
faster but luckily that's a

411
00:21:22,570 --> 00:21:27,669
configuration in that flash descriptor I

412
00:21:25,260 --> 00:21:29,650
think the one of the things I'm most

413
00:21:27,670 --> 00:21:32,080
proud about with this project is that a

414
00:21:29,650 --> 00:21:35,830
white quark said called it impressive

415
00:21:32,080 --> 00:21:37,990
and she is an incredibly gifted hardware

416
00:21:35,830 --> 00:21:41,429
engineer and for her to say that you

417
00:21:37,990 --> 00:21:41,430
know made me very very proud

418
00:21:43,230 --> 00:21:47,850
so if we go back and look at that that

419
00:21:44,850 --> 00:21:50,519
waveform we can actually read the data

420
00:21:47,850 --> 00:21:53,760
stream that's going in the zero one zero

421
00:21:50,519 --> 00:21:57,090
one one zero you know works out to be

422
00:21:53,760 --> 00:22:00,450
five a a five if we look the the hex in

423
00:21:57,090 --> 00:22:03,720
the hex dump of the the ROM we can see

424
00:22:00,450 --> 00:22:06,740
that appears there on the in the Intel

425
00:22:03,720 --> 00:22:10,080
flash descriptor and based on what

426
00:22:06,740 --> 00:22:12,539
putter Worth and Cova documented in

427
00:22:10,080 --> 00:22:14,610
their advanced BIOS training this is the

428
00:22:12,539 --> 00:22:17,279
valid flash descriptor the CPU won't

429
00:22:14,610 --> 00:22:19,678
start up if that Reed doesn't come in so

430
00:22:17,279 --> 00:22:22,679
getting that one to work was in the

431
00:22:19,679 --> 00:22:27,330
first sort of key victory in getting the

432
00:22:22,679 --> 00:22:30,899
spy spy to function unfortunately it

433
00:22:27,330 --> 00:22:32,309
wasn't reliable that a lot of times we

434
00:22:30,899 --> 00:22:34,489
could get most of the way into the

435
00:22:32,309 --> 00:22:39,950
firmware but we'd frequently get sort of

436
00:22:34,490 --> 00:22:42,389
bad bad errors or CRC errors or

437
00:22:39,950 --> 00:22:46,230
decompression errors on on the firmware

438
00:22:42,389 --> 00:22:48,719
and this has to do with another work of

439
00:22:46,230 --> 00:22:51,179
DRAM which is that there's a auto

440
00:22:48,720 --> 00:22:53,120
refresh cycle that every seven point

441
00:22:51,179 --> 00:22:57,210
eight microseconds

442
00:22:53,120 --> 00:23:00,959
Yuson you need to do a refresh command

443
00:22:57,210 --> 00:23:03,269
which will choose a row from the from

444
00:23:00,960 --> 00:23:05,850
the RAM copy it from capacitors to

445
00:23:03,269 --> 00:23:07,919
registers and then copy it back to the

446
00:23:05,850 --> 00:23:10,740
capacitors and this has to do with the

447
00:23:07,919 --> 00:23:12,570
fact that DRAM capacitors are slowly

448
00:23:10,740 --> 00:23:16,049
losing charge so you have to

449
00:23:12,570 --> 00:23:21,299
continuously reread them and refresh

450
00:23:16,049 --> 00:23:24,960
them luckily we have an open source DRAM

451
00:23:21,299 --> 00:23:27,600
controller so we were able to add to the

452
00:23:24,960 --> 00:23:30,240
to the interface to it an additional

453
00:23:27,600 --> 00:23:32,309
input line that says hold off on doing a

454
00:23:30,240 --> 00:23:35,370
refresh you know we're going to need to

455
00:23:32,309 --> 00:23:37,139
flat the memory very very soon so when

456
00:23:35,370 --> 00:23:39,449
we get a read command we can assert this

457
00:23:37,139 --> 00:23:42,629
this wire into the into the DRAM

458
00:23:39,450 --> 00:23:44,279
controller and it will it guarantees

459
00:23:42,630 --> 00:23:49,549
that we won't have any refresh cycles

460
00:23:44,279 --> 00:23:49,549
while the x86 is trying to read from us

461
00:23:50,530 --> 00:23:57,350
so you might have noticed that you're

462
00:23:52,760 --> 00:23:59,960
using a saw girlis flash chip clip when

463
00:23:57,350 --> 00:24:03,199
we put it on the board and you might be

464
00:23:59,960 --> 00:24:06,890
thinking but why doesn't the the real

465
00:24:03,200 --> 00:24:10,370
flash chip respond how do we how do we

466
00:24:06,890 --> 00:24:13,160
override it and it turns out that on

467
00:24:10,370 --> 00:24:17,600
most of these main boards the the spy

468
00:24:13,160 --> 00:24:20,990
flash pins are connected via small

469
00:24:17,600 --> 00:24:23,870
serious resistors to the the PCH for the

470
00:24:20,990 --> 00:24:27,890
x86 so as long as we can sync more

471
00:24:23,870 --> 00:24:31,429
current than the PCH we can change the

472
00:24:27,890 --> 00:24:33,530
value of this of this line and because

473
00:24:31,430 --> 00:24:36,800
there's that resistor it doesn't cause

474
00:24:33,530 --> 00:24:40,330
any damage to anything so schematically

475
00:24:36,800 --> 00:24:45,050
this is what the spice file looks like

476
00:24:40,330 --> 00:24:47,419
when the PCH the x86 asserts the CA the

477
00:24:45,050 --> 00:24:50,750
chip select line both the X eighties

478
00:24:47,420 --> 00:24:56,810
with the spy flash and the FPGA picked

479
00:24:50,750 --> 00:25:00,130
that up the spy flash starts asserting

480
00:24:56,810 --> 00:25:05,960
data on the serial out line but the FPGA

481
00:25:00,130 --> 00:25:08,570
drives the the CS line high which then

482
00:25:05,960 --> 00:25:10,640
causes the real spy flash to turn off

483
00:25:08,570 --> 00:25:13,460
its output driver we're essentially

484
00:25:10,640 --> 00:25:16,970
releasing the bus and then the FPGA is

485
00:25:13,460 --> 00:25:19,310
able to send data all on the bus without

486
00:25:16,970 --> 00:25:21,670
worrying about damaging the output

487
00:25:19,310 --> 00:25:21,669
drivers

488
00:25:21,870 --> 00:25:26,908
the drawback is we can't tell when the

489
00:25:24,360 --> 00:25:30,570
spot when the PCH has stopped a certain

490
00:25:26,909 --> 00:25:32,640
the cs line so we instead have a little

491
00:25:30,570 --> 00:25:36,450
bit of a hack that we watch the clock

492
00:25:32,640 --> 00:25:37,860
line and once that we haven't seen a

493
00:25:36,450 --> 00:25:40,230
clock toggle for some number of

494
00:25:37,860 --> 00:25:42,629
nanoseconds we assume the PCH is no

495
00:25:40,230 --> 00:25:46,440
longer engaged in a transaction and we

496
00:25:42,630 --> 00:25:48,150
can then under sir at the CS and let the

497
00:25:46,440 --> 00:25:51,360
bus go back into the state where the

498
00:25:48,150 --> 00:25:55,980
platform controller hub can can turn it

499
00:25:51,360 --> 00:25:58,649
on and off so we have this working on

500
00:25:55,980 --> 00:26:00,149
laptops as you saw we also have it

501
00:25:58,649 --> 00:26:03,840
working on quite a few different server

502
00:26:00,149 --> 00:26:06,418
platforms that we've worked on and if we

503
00:26:03,840 --> 00:26:09,689
zoom way into that that that first

504
00:26:06,419 --> 00:26:11,070
server main word that I put up you'll

505
00:26:09,690 --> 00:26:14,279
see that there actually to flash chips

506
00:26:11,070 --> 00:26:17,010
one for the x86 and then one for the

507
00:26:14,279 --> 00:26:19,919
board management controller which is in

508
00:26:17,010 --> 00:26:25,320
this case an arm CPU that front and most

509
00:26:19,919 --> 00:26:29,070
the time runs Linux we now have as of

510
00:26:25,320 --> 00:26:30,928
last week support for overwrite doing

511
00:26:29,070 --> 00:26:37,020
the same trick to override the chip

512
00:26:30,929 --> 00:26:40,080
select line on the on the a speed 2400

513
00:26:37,020 --> 00:26:42,480
series and 2500 series arm CPUs which

514
00:26:40,080 --> 00:26:45,539
means we can use the spice by not only

515
00:26:42,480 --> 00:26:47,640
for core boot Linux boot and UEFI

516
00:26:45,539 --> 00:26:51,390
research but also for things like open

517
00:26:47,640 --> 00:26:54,450
BMC and micro BMC to help accelerate the

518
00:26:51,390 --> 00:26:56,130
firmware development there and that

519
00:26:54,450 --> 00:26:59,159
works on this particular Super Micro

520
00:26:56,130 --> 00:27:01,590
board which is also supported by core

521
00:26:59,159 --> 00:27:05,299
boot so if you want a fully open server

522
00:27:01,590 --> 00:27:05,299
this is wanted to check out

523
00:27:05,950 --> 00:27:10,000
you might notice that everything I've

524
00:27:07,450 --> 00:27:13,990
talked about has been somewhat Intel

525
00:27:10,000 --> 00:27:18,070
specific we are working with a group in

526
00:27:13,990 --> 00:27:20,710
Berlin on supporting the AMD CPUs we

527
00:27:18,070 --> 00:27:22,419
have support for booting the the PSP

528
00:27:20,710 --> 00:27:25,780
which is Intel's version of the

529
00:27:22,420 --> 00:27:27,850
management engine off of spy spy and

530
00:27:25,780 --> 00:27:30,100
this is going to enable some interesting

531
00:27:27,850 --> 00:27:32,469
security research there because much

532
00:27:30,100 --> 00:27:35,679
like the management engine the PSP is a

533
00:27:32,470 --> 00:27:40,020
hardware root of trust that potentially

534
00:27:35,680 --> 00:27:42,970
can be key to a lot of security issues

535
00:27:40,020 --> 00:27:45,879
it is open source so we would love for

536
00:27:42,970 --> 00:27:48,130
you all to help out there are quite a

537
00:27:45,880 --> 00:27:49,000
few things that we don't support right

538
00:27:48,130 --> 00:27:51,130
now

539
00:27:49,000 --> 00:27:54,100
but if you have a system that needs dual

540
00:27:51,130 --> 00:27:55,870
or quad spy or fast to read or if you

541
00:27:54,100 --> 00:27:58,629
want to help us with the user interface

542
00:27:55,870 --> 00:28:01,899
or maybe support other buses like the

543
00:27:58,630 --> 00:28:04,990
LPC bus or East by you know we'd love to

544
00:28:01,900 --> 00:28:08,170
be able to turn this into a Swiss Army

545
00:28:04,990 --> 00:28:12,970
knife of bus man in the middle and talk

546
00:28:08,170 --> 00:28:15,940
towel sort of projects so you can check

547
00:28:12,970 --> 00:28:18,190
out from github you can join us on the

548
00:28:15,940 --> 00:28:20,770
open source firmware slack

549
00:28:18,190 --> 00:28:23,140
I'm also love to take questions we have

550
00:28:20,770 --> 00:28:25,150
Mastodon or Twitter and with that I'd

551
00:28:23,140 --> 00:28:27,510
like to open the floor up to any

552
00:28:25,150 --> 00:28:27,510
questions

553
00:28:47,620 --> 00:28:55,600
and also to reassemble the the victim

554
00:28:51,049 --> 00:28:58,700
laptop hi

555
00:28:55,600 --> 00:29:00,980
so first of all congrats these are

556
00:28:58,700 --> 00:29:04,820
really a couple of really great hacks

557
00:29:00,980 --> 00:29:07,340
and so my question is does this then

558
00:29:04,820 --> 00:29:12,770
open a door for running coreboot or

559
00:29:07,340 --> 00:29:14,480
laptops newer than 230 because if I

560
00:29:12,770 --> 00:29:17,418
understood correctly from your slide

561
00:29:14,480 --> 00:29:22,730
with the first time at second time of

562
00:29:17,419 --> 00:29:24,470
reading the the memory we could just the

563
00:29:22,730 --> 00:29:27,770
first time that it reads we could just

564
00:29:24,470 --> 00:29:31,340
give them the original firmware and next

565
00:29:27,770 --> 00:29:33,470
time we could just run the Corbett yes

566
00:29:31,340 --> 00:29:35,408
so the question is can can the spy spy

567
00:29:33,470 --> 00:29:37,909
or something similar if you use to

568
00:29:35,409 --> 00:29:43,990
enable coreboot on boot guard equipped

569
00:29:37,909 --> 00:29:46,789
laptops and yes you can use this on most

570
00:29:43,990 --> 00:29:50,899
i've successfully done so on a variety

571
00:29:46,789 --> 00:29:51,830
of thing pads the expunge in sticks was

572
00:29:50,899 --> 00:29:55,399
the one that i was using in that

573
00:29:51,830 --> 00:29:58,189
particular attack it would require a

574
00:29:55,399 --> 00:30:01,428
hardware implant because bypassing boot

575
00:29:58,190 --> 00:30:04,789
guard is a per boot sort of thing but

576
00:30:01,429 --> 00:30:08,450
using i built a small mock-up with the

577
00:30:04,789 --> 00:30:11,720
ice forty up 5k that would actually fit

578
00:30:08,450 --> 00:30:15,200
underneath a spy flash chip and you

579
00:30:11,720 --> 00:30:17,240
could then solder on top it's someone

580
00:30:15,200 --> 00:30:21,279
inspired by my BMC hardware implant talk

581
00:30:17,240 --> 00:30:21,279
that I gave a congress last year

582
00:30:21,860 --> 00:30:29,209
the other option however is if the nine

583
00:30:26,000 --> 00:30:32,020
elements folks are have coreboot port

584
00:30:29,210 --> 00:30:34,610
for the t-80 because maybe the t4 80s

585
00:30:32,020 --> 00:30:36,680
which is a brand new blue card equip one

586
00:30:34,610 --> 00:30:41,979
that they've been able to get without

587
00:30:36,680 --> 00:30:41,980
blue card enabled direct from Lenovo

588
00:30:49,120 --> 00:30:57,820
just a small question the ThinkPad that

589
00:30:53,690 --> 00:31:01,700
you have flashed basically to a new

590
00:30:57,820 --> 00:31:05,000
bootstrap are you gonna flash it back or

591
00:31:01,700 --> 00:31:08,630
do you know is it gonna flash it back

592
00:31:05,000 --> 00:31:11,899
itself there were no change is made to

593
00:31:08,630 --> 00:31:15,590
the ThinkPad once the clip is removed it

594
00:31:11,899 --> 00:31:19,510
is back to the it will boot from the

595
00:31:15,590 --> 00:31:23,360
usual the usual flash so it's it's a

596
00:31:19,510 --> 00:31:27,639
it's useful both for firmer development

597
00:31:23,360 --> 00:31:27,639
and evil made attacks okay

598
00:31:29,290 --> 00:31:33,389
yeah yeah it goes normal for

599
00:31:34,030 --> 00:31:41,020
can you connect up the BIOS and flash

600
00:31:37,330 --> 00:31:46,270
with the Vulcan corporate Edition please

601
00:31:41,020 --> 00:31:48,520
I didn't actually verify that it boots

602
00:31:46,270 --> 00:31:50,590
it did look like he got into grub but

603
00:31:48,520 --> 00:31:52,750
I'm not sure about the health if it

604
00:31:50,590 --> 00:31:54,850
occurs the wrestle a hell man you can

605
00:31:52,750 --> 00:31:59,070
also flash with the tool this stuff on

606
00:31:54,850 --> 00:32:03,060
the chip or only read alt and override

607
00:31:59,070 --> 00:32:06,879
right now the very log only supports the

608
00:32:03,060 --> 00:32:08,440
emulation mode but that say would be a

609
00:32:06,880 --> 00:32:10,360
useful feature to add is something that

610
00:32:08,440 --> 00:32:12,730
would say read out the current contents

611
00:32:10,360 --> 00:32:15,370
of the chip to pre-populate the DRAM let

612
00:32:12,730 --> 00:32:17,260
you tweak just a few pieces of it test

613
00:32:15,370 --> 00:32:19,149
it and then maybe you write that back to

614
00:32:17,260 --> 00:32:21,520
the flash that note you a good feature

615
00:32:19,150 --> 00:32:26,080
to add feel free to open a github issue

616
00:32:21,520 --> 00:32:28,480
and assign this yourself thank you very

617
00:32:26,080 --> 00:32:31,379
much if I have some free time left we

618
00:32:28,480 --> 00:32:31,380
can physical body

619
00:32:39,179 --> 00:32:46,469
is there any sort of sensible mitigation

620
00:32:43,049 --> 00:32:48,450
that the manufacturers wanted to do to

621
00:32:46,469 --> 00:32:50,989
prevent the sort of evil made attacks

622
00:32:48,450 --> 00:32:57,179
you're talking about

623
00:32:50,989 --> 00:32:59,549
so yeah Intel boot guard does a a really

624
00:32:57,179 --> 00:33:02,399
good job of preventing a lot of evil

625
00:32:59,549 --> 00:33:04,609
mate attacks firmware level ill-made

626
00:33:02,399 --> 00:33:10,080
attacks just because it does provide a

627
00:33:04,609 --> 00:33:12,809
route of trust in hardware changed from

628
00:33:10,080 --> 00:33:18,119
the the management engine into the x86

629
00:33:12,809 --> 00:33:20,399
so that largely has eliminated evil made

630
00:33:18,119 --> 00:33:24,718
firmware attacks for systems that have

631
00:33:20,399 --> 00:33:27,748
it enabled other vendors are taking a

632
00:33:24,719 --> 00:33:31,379
different approach for instance Apple

633
00:33:27,749 --> 00:33:33,719
has their the t2 security coprocessor

634
00:33:31,379 --> 00:33:36,149
that is doing a very similar thing to

635
00:33:33,719 --> 00:33:39,839
despised by where it is doing firmware

636
00:33:36,149 --> 00:33:42,629
validation fire to releasing the x86

637
00:33:39,839 --> 00:33:45,089
from reset and then delivering this

638
00:33:42,629 --> 00:33:47,699
validated firmware over east by to the

639
00:33:45,089 --> 00:33:49,229
x86 there's a really neat way to do it

640
00:33:47,700 --> 00:33:51,059
unfortunately it's closed source is a

641
00:33:49,229 --> 00:33:54,029
proprietary solution that only works in

642
00:33:51,059 --> 00:33:55,619
their proprietary platform Google has

643
00:33:54,029 --> 00:33:58,019
done a similar thing with the

644
00:33:55,619 --> 00:34:03,209
Chromebooks that they have their Titan

645
00:33:58,019 --> 00:34:05,849
chip that replaces both sort of the

646
00:34:03,210 --> 00:34:07,649
embedded controller and the TPM and a

647
00:34:05,849 --> 00:34:10,980
few other functions

648
00:34:07,649 --> 00:34:13,770
and it does a similar validation prior

649
00:34:10,980 --> 00:34:15,480
to releasing reset at least in the

650
00:34:13,770 --> 00:34:18,418
server class ones in the Chromebook ones

651
00:34:15,480 --> 00:34:20,909
I think it only does validation at at

652
00:34:18,418 --> 00:34:22,618
firmware load time that they're not evil

653
00:34:20,909 --> 00:34:26,069
made physical attacks are not in the

654
00:34:22,619 --> 00:34:28,770
Chromebook security model Microsoft's

655
00:34:26,069 --> 00:34:32,699
Cerberus has a also some similar things

656
00:34:28,770 --> 00:34:35,989
but currently vaporware as far as actual

657
00:34:32,699 --> 00:34:35,989
chips for end users

658
00:34:47,719 --> 00:34:52,759
and the motor questions alright well I

659
00:34:51,199 --> 00:34:55,879
will be around all week so if you have

660
00:34:52,760 --> 00:34:59,990
laptops and you want to try it out love

661
00:34:55,879 --> 00:35:02,390
to test it on a variety of them and

662
00:34:59,990 --> 00:35:07,359
again feel free to connect on a variety

663
00:35:02,390 --> 00:35:07,359
of places and let's chat further

664
00:35:34,130 --> 00:35:36,190
you

