1
00:00:29,810 --> 00:00:36,870
thank you so to start off I'll just

2
00:00:33,120 --> 00:00:38,849
introduce myself my name is Sam I'm a

3
00:00:36,870 --> 00:00:42,660
developer advocate and former developer

4
00:00:38,850 --> 00:00:45,720
for Cemil worked on LG TM calm for a

5
00:00:42,660 --> 00:00:47,129
good number of years I've been

6
00:00:45,720 --> 00:00:50,309
passionate about open source and

7
00:00:47,129 --> 00:00:53,730
security in particular for a number of

8
00:00:50,309 --> 00:00:58,080
years now you should be a contributor to

9
00:00:53,730 --> 00:01:01,409
signal Android and desktop say yeah that

10
00:00:58,080 --> 00:01:03,989
was a well I spend most of my evenings

11
00:01:01,409 --> 00:01:07,620
doing for at least six months of kind of

12
00:01:03,989 --> 00:01:11,610
fun and that's my twitter handle i

13
00:01:07,620 --> 00:01:12,900
that'll be on every slide so you can if

14
00:01:11,610 --> 00:01:14,960
you take a picture of something and you

15
00:01:12,900 --> 00:01:18,420
want to follow me later you can do that

16
00:01:14,960 --> 00:01:24,869
so I'm gonna start off today with a

17
00:01:18,420 --> 00:01:28,380
story and it's a story of many bugs so

18
00:01:24,869 --> 00:01:31,590
back on the 7th of September 2017 my

19
00:01:28,380 --> 00:01:33,560
coworker Moe found and disclosed a

20
00:01:31,590 --> 00:01:36,750
vulnerability in the spring framework

21
00:01:33,560 --> 00:01:37,979
now this particular vulnerability made

22
00:01:36,750 --> 00:01:40,590
use of what was called the spring

23
00:01:37,979 --> 00:01:44,030
expression language which allows you to

24
00:01:40,590 --> 00:01:48,119
effectively up run arbitrary Java code

25
00:01:44,030 --> 00:01:50,100
from strings that you can pass in now in

26
00:01:48,119 --> 00:01:55,649
this particular instance and they were

27
00:01:50,100 --> 00:01:57,749
interpreting some HTTP headers as spring

28
00:01:55,649 --> 00:02:00,990
expressions which then meant that anyone

29
00:01:57,749 --> 00:02:02,850
that could send a specific HTTP request

30
00:02:00,990 --> 00:02:04,408
to a spring server would be able to get

31
00:02:02,850 --> 00:02:07,439
remote code execution on that server

32
00:02:04,409 --> 00:02:10,679
so pretty severe so he reported the

33
00:02:07,439 --> 00:02:13,680
vulnerability and then on the 21st of

34
00:02:10,679 --> 00:02:16,290
September pivotal published a patch that

35
00:02:13,680 --> 00:02:17,610
fixed the vulnerability and then made a

36
00:02:16,290 --> 00:02:20,609
public announcement to let everyone know

37
00:02:17,610 --> 00:02:23,640
that they should update well it turns

38
00:02:20,610 --> 00:02:26,010
out that the patch didn't work on the

39
00:02:23,640 --> 00:02:27,510
22nd of September Moe went in checked

40
00:02:26,010 --> 00:02:30,690
the patch saw that it was still

41
00:02:27,510 --> 00:02:32,640
vulnerable and send a new exploit that

42
00:02:30,690 --> 00:02:34,409
use a slightly different execution path

43
00:02:32,640 --> 00:02:35,380
there was still a remote code execution

44
00:02:34,409 --> 00:02:40,380
and he sent

45
00:02:35,380 --> 00:02:44,650
pivotal then on the 26th of September

46
00:02:40,380 --> 00:02:47,140
pivotal sent Moe the details of how they

47
00:02:44,650 --> 00:02:48,550
were planning to fix it so that he could

48
00:02:47,140 --> 00:02:51,660
check this time before they went public

49
00:02:48,550 --> 00:02:55,570
whether or not the fix was complete

50
00:02:51,660 --> 00:02:58,090
turned out the fix wasn't complete it

51
00:02:55,570 --> 00:02:59,380
was still vulnerable to effectively the

52
00:02:58,090 --> 00:03:04,780
same kind of mistake that they were

53
00:02:59,380 --> 00:03:06,100
making so in the end on the 25th of

54
00:03:04,780 --> 00:03:09,010
October they actually published a

55
00:03:06,100 --> 00:03:11,340
complete refactoring of the code that

56
00:03:09,010 --> 00:03:14,230
was affected and continuously vulnerable

57
00:03:11,340 --> 00:03:17,730
because they realized that they were

58
00:03:14,230 --> 00:03:19,869
unable to prevent more of these

59
00:03:17,730 --> 00:03:24,030
happening and added how to go about a

60
00:03:19,870 --> 00:03:28,960
different way a slightly different story

61
00:03:24,030 --> 00:03:31,270
it's an also a story of many bugs so in

62
00:03:28,960 --> 00:03:35,230
27th of April 2016

63
00:03:31,270 --> 00:03:37,810
Apache struts announced an RC e which

64
00:03:35,230 --> 00:03:39,369
had a very similar kind of behavior they

65
00:03:37,810 --> 00:03:42,640
had an expression language called HTML

66
00:03:39,370 --> 00:03:45,610
that allows you to access arbitrary Java

67
00:03:42,640 --> 00:03:51,489
objects and you could use that to run

68
00:03:45,610 --> 00:03:53,140
arbitrary code so in this instance they

69
00:03:51,490 --> 00:03:55,660
were interpreting user data and user

70
00:03:53,140 --> 00:03:58,329
data was flowing to one of these places

71
00:03:55,660 --> 00:04:00,520
where they were running or interpreting

72
00:03:58,330 --> 00:04:02,290
as stirring is o T&L and then allowing a

73
00:04:00,520 --> 00:04:05,680
user to effectively run any code they

74
00:04:02,290 --> 00:04:08,880
want on the machine on the 12th of May

75
00:04:05,680 --> 00:04:11,770
someone else found an RC e

76
00:04:08,880 --> 00:04:15,100
and different RC e in Apache struts that

77
00:04:11,770 --> 00:04:18,549
interpreted user data is HTML on the

78
00:04:15,100 --> 00:04:20,709
20th of June 2016 someone else found an

79
00:04:18,548 --> 00:04:23,500
RC e in Apache struts the entire

80
00:04:20,709 --> 00:04:27,370
producer data is out Reena on the 19th

81
00:04:23,500 --> 00:04:30,130
of March another RCE in apache struts

82
00:04:27,370 --> 00:04:33,580
for adrianel and on the 22nd of

83
00:04:30,130 --> 00:04:37,570
September 2017 and on the 24th of

84
00:04:33,580 --> 00:04:39,460
September 2018 and what you'll see is

85
00:04:37,570 --> 00:04:41,020
the same mistake being made over and

86
00:04:39,460 --> 00:04:42,820
over again in different parts of the

87
00:04:41,020 --> 00:04:44,469
code base where user data is being

88
00:04:42,820 --> 00:04:48,279
interpreted in a certain way that allows

89
00:04:44,470 --> 00:04:50,049
them to exploit the server

90
00:04:48,279 --> 00:04:52,389
now there was only so much space on my

91
00:04:50,049 --> 00:04:54,638
slides so I didn't actually include the

92
00:04:52,389 --> 00:04:58,389
other ten vulnerabilities that are all

93
00:04:54,639 --> 00:05:05,999
of the same type interpreting user data

94
00:04:58,389 --> 00:05:09,009
as ogia now so yeah that's not very good

95
00:05:05,999 --> 00:05:10,329
we're seeing the same source of mistakes

96
00:05:09,009 --> 00:05:12,669
we made over and over again in these

97
00:05:10,329 --> 00:05:14,739
projects and it might seem like I'm I'm

98
00:05:12,669 --> 00:05:17,349
making fun of these two open-source

99
00:05:14,739 --> 00:05:19,239
products in particular but these stories

100
00:05:17,349 --> 00:05:20,878
are common across the industry both in

101
00:05:19,239 --> 00:05:23,438
open source and closed source software

102
00:05:20,879 --> 00:05:26,949
and it's not just small companies either

103
00:05:23,439 --> 00:05:31,029
for example Apple publish part of their

104
00:05:26,949 --> 00:05:35,049
source code for mac OS and iOS called

105
00:05:31,029 --> 00:05:37,089
the X and u kernel and my coworker kevin

106
00:05:35,049 --> 00:05:39,029
discovered a remote code execution in a

107
00:05:37,089 --> 00:05:41,199
component called the packet Mangala

108
00:05:39,029 --> 00:05:44,919
happy reported this vulnerability to

109
00:05:41,199 --> 00:05:48,149
Apple we're the POC exploit they fixed

110
00:05:44,919 --> 00:05:51,099
the vulnerability pushed out an update

111
00:05:48,149 --> 00:05:52,119
and when they later published the source

112
00:05:51,099 --> 00:05:53,829
code for that version

113
00:05:52,119 --> 00:05:55,839
Kevin discovered that there was still a

114
00:05:53,829 --> 00:05:59,889
bug in the exact same block of source

115
00:05:55,839 --> 00:06:02,649
code that they patched so he sent them a

116
00:05:59,889 --> 00:06:05,259
new exploit that triggered a very

117
00:06:02,649 --> 00:06:06,849
similar vulnerability and then Apple

118
00:06:05,259 --> 00:06:08,529
then later fix that one again so they

119
00:06:06,849 --> 00:06:12,878
ended up with two CVEs for the price of

120
00:06:08,529 --> 00:06:14,379
one so how do we what do we do about

121
00:06:12,879 --> 00:06:16,059
this how do we solve this if these same

122
00:06:14,379 --> 00:06:18,099
sorts of mistakes are being made over

123
00:06:16,059 --> 00:06:20,499
and over and over again across many

124
00:06:18,099 --> 00:06:23,259
different software projects could we

125
00:06:20,499 --> 00:06:24,610
potentially use this information of a

126
00:06:23,259 --> 00:06:27,029
new vulnerability as an opportunity

127
00:06:24,610 --> 00:06:27,029
instead

128
00:06:28,850 --> 00:06:34,220
so once you've found the root course you

129
00:06:31,520 --> 00:06:36,349
can ask yourself the question at that

130
00:06:34,220 --> 00:06:38,660
point before you push out a patch or

131
00:06:36,350 --> 00:06:40,670
anything else is there a possibility

132
00:06:38,660 --> 00:06:43,520
that a similar mistake may be made

133
00:06:40,670 --> 00:06:45,830
somewhere else in my code that could be

134
00:06:43,520 --> 00:06:47,359
something architectural II that means a

135
00:06:45,830 --> 00:06:48,919
certain class of vulnerability is more

136
00:06:47,360 --> 00:06:51,290
likely to happen in your codebase for

137
00:06:48,920 --> 00:06:52,400
example you your use of C may increase

138
00:06:51,290 --> 00:06:54,440
your chances of having a memory

139
00:06:52,400 --> 00:06:56,960
corruption issue or using something like

140
00:06:54,440 --> 00:06:58,790
Apache OGL or a Springs expression

141
00:06:56,960 --> 00:07:01,909
language might make you vulnerable to a

142
00:06:58,790 --> 00:07:03,230
remote code execution so you should try

143
00:07:01,910 --> 00:07:05,170
and find similar mistakes because the

144
00:07:03,230 --> 00:07:08,180
chances are that you will find something

145
00:07:05,170 --> 00:07:09,140
companies like Google and Microsoft who

146
00:07:08,180 --> 00:07:13,460
have been doing this for a while now

147
00:07:09,140 --> 00:07:14,840
call this process variant analysis so

148
00:07:13,460 --> 00:07:17,440
this is a quote from a blog post from

149
00:07:14,840 --> 00:07:20,719
their Microsoft Security Response Center

150
00:07:17,440 --> 00:07:22,640
says after doing root cause analysis our

151
00:07:20,720 --> 00:07:25,120
next step is to find its variant

152
00:07:22,640 --> 00:07:27,409
analysis finding and investigating any

153
00:07:25,120 --> 00:07:29,240
variants of the vulnerability it's

154
00:07:27,410 --> 00:07:31,280
important that we find all such variants

155
00:07:29,240 --> 00:07:32,750
and patch them simultaneously otherwise

156
00:07:31,280 --> 00:07:35,539
we bear the risk of these being

157
00:07:32,750 --> 00:07:38,270
exploited in the wild so for them it's

158
00:07:35,540 --> 00:07:40,430
simply not an option not to do it it's a

159
00:07:38,270 --> 00:07:42,140
stage of their vulnerability response

160
00:07:40,430 --> 00:07:44,300
process that happens before making

161
00:07:42,140 --> 00:07:46,010
details of a patch public so that they

162
00:07:44,300 --> 00:07:48,320
can patch the original vulnerability and

163
00:07:46,010 --> 00:07:50,960
all variants simultaneously at the same

164
00:07:48,320 --> 00:07:53,360
time because if they don't do that once

165
00:07:50,960 --> 00:07:54,799
they release a patch other people will

166
00:07:53,360 --> 00:07:57,050
take a look at the patch perhaps

167
00:07:54,800 --> 00:07:58,430
reverse-engineer it and try and find

168
00:07:57,050 --> 00:08:01,670
similar vulnerabilities in that code so

169
00:07:58,430 --> 00:08:05,750
it can exploit it and perhaps do some

170
00:08:01,670 --> 00:08:08,420
malicious things with it so how do you

171
00:08:05,750 --> 00:08:11,210
do variant analysis well to be honest

172
00:08:08,420 --> 00:08:13,010
until recently most of the big players

173
00:08:11,210 --> 00:08:15,140
have been predominately relying on lots

174
00:08:13,010 --> 00:08:17,120
of manual work by their security

175
00:08:15,140 --> 00:08:19,190
researchers all their security response

176
00:08:17,120 --> 00:08:21,260
teams so you can may be focusing on

177
00:08:19,190 --> 00:08:22,640
particularly sensitive areas of the

178
00:08:21,260 --> 00:08:25,039
codebase that are more likely to have

179
00:08:22,640 --> 00:08:26,659
vulnerabilities or manually checking how

180
00:08:25,040 --> 00:08:28,490
data flows through an application using

181
00:08:26,660 --> 00:08:30,740
techniques like control flow analysis

182
00:08:28,490 --> 00:08:32,900
data flow analysis and checking the

183
00:08:30,740 --> 00:08:34,310
range that certain of our variables can

184
00:08:32,900 --> 00:08:37,098
take and ensuring that the bounds are

185
00:08:34,309 --> 00:08:39,079
being shared correctly you often make

186
00:08:37,099 --> 00:08:41,160
use of tech search tools like grep and

187
00:08:39,080 --> 00:08:45,370
aw Kay

188
00:08:41,159 --> 00:08:47,439
but it can be quite tedious things can

189
00:08:45,370 --> 00:08:49,060
be made easier if you use an IDE or

190
00:08:47,440 --> 00:08:50,770
something else that's language aware

191
00:08:49,060 --> 00:08:54,010
like sauce graph that allows you to use

192
00:08:50,770 --> 00:08:57,819
jump to definition allows you to finally

193
00:08:54,010 --> 00:09:00,250
quick quickly find references to like

194
00:08:57,820 --> 00:09:02,770
functions and classes and allows you to

195
00:09:00,250 --> 00:09:05,770
jump through the cool graph but as you

196
00:09:02,770 --> 00:09:09,819
can imagine this sort of manual process

197
00:09:05,770 --> 00:09:11,350
has its downsides it can be repetitive

198
00:09:09,820 --> 00:09:13,270
and time-consuming particularly for

199
00:09:11,350 --> 00:09:14,860
large code bases requires lots of

200
00:09:13,270 --> 00:09:16,150
iterative exploration like you might go

201
00:09:14,860 --> 00:09:17,650
down one code path and you realize that

202
00:09:16,150 --> 00:09:18,730
it doesn't really do anywhere so you go

203
00:09:17,650 --> 00:09:21,010
back up and then you go back down

204
00:09:18,730 --> 00:09:23,770
another path and it can take a long long

205
00:09:21,010 --> 00:09:26,680
time manually checking your code base is

206
00:09:23,770 --> 00:09:28,630
also prone to human error so the more

207
00:09:26,680 --> 00:09:31,209
complex for the mistake you that you're

208
00:09:28,630 --> 00:09:32,710
tracking for the larger the code base or

209
00:09:31,210 --> 00:09:34,660
the closer the deadline that you have

210
00:09:32,710 --> 00:09:38,860
the more likely it is that you'll miss

211
00:09:34,660 --> 00:09:40,980
something it's simply not scalable as

212
00:09:38,860 --> 00:09:42,970
the size of a code based increases

213
00:09:40,980 --> 00:09:45,280
manually checking for a class of

214
00:09:42,970 --> 00:09:47,040
vulnerability every time a new one is

215
00:09:45,280 --> 00:09:49,270
discovered becomes it becomes infeasible

216
00:09:47,040 --> 00:09:51,099
particularly as the size of security

217
00:09:49,270 --> 00:09:52,449
teams is often so much smaller than the

218
00:09:51,100 --> 00:09:56,620
size of development teams often it's

219
00:09:52,450 --> 00:09:58,780
like one or two percent and if you want

220
00:09:56,620 --> 00:10:00,250
to actually get your developers to do

221
00:09:58,780 --> 00:10:04,360
this as well as part of the code review

222
00:10:00,250 --> 00:10:06,250
process as the number of mistakes that

223
00:10:04,360 --> 00:10:07,870
you're checking for increases over time

224
00:10:06,250 --> 00:10:09,580
as you'll come across more and more

225
00:10:07,870 --> 00:10:10,630
different types of vulnerabilities the

226
00:10:09,580 --> 00:10:12,550
number of things you need to check a

227
00:10:10,630 --> 00:10:14,650
code review also increases which will

228
00:10:12,550 --> 00:10:18,069
slow down your code review to an

229
00:10:14,650 --> 00:10:20,230
absolute crawl so what can you do if

230
00:10:18,070 --> 00:10:21,790
variant analysis is critical for you

231
00:10:20,230 --> 00:10:24,960
otherwise you bear the risk of being

232
00:10:21,790 --> 00:10:27,160
exploited yet it's completely infeasible

233
00:10:24,960 --> 00:10:30,070
and you don't really have the money at

234
00:10:27,160 --> 00:10:33,600
Microsoft or Google did get pay for like

235
00:10:30,070 --> 00:10:37,330
100 or so people to be doing this like

236
00:10:33,600 --> 00:10:41,640
for their entire job could we perhaps

237
00:10:37,330 --> 00:10:41,640
automate some of this do you think

238
00:10:42,370 --> 00:10:46,569
so what if there is a way in which we

239
00:10:44,079 --> 00:10:48,878
could describe mistakes that would allow

240
00:10:46,569 --> 00:10:51,128
us to automatically find them allow the

241
00:10:48,879 --> 00:10:53,350
computer to do all the work for us using

242
00:10:51,129 --> 00:10:54,579
not just the syntactic information but

243
00:10:53,350 --> 00:10:56,980
including a bunch of semantic

244
00:10:54,579 --> 00:11:00,099
information - things like using the cool

245
00:10:56,980 --> 00:11:01,959
graph or control flow or data flow we

246
00:11:00,100 --> 00:11:04,779
could then run it across our entire code

247
00:11:01,959 --> 00:11:07,119
base automatically or run them across

248
00:11:04,779 --> 00:11:09,009
multiple code bases but we could also

249
00:11:07,120 --> 00:11:11,980
run them continuously so that we can

250
00:11:09,009 --> 00:11:13,389
catch future mistakes being made that

251
00:11:11,980 --> 00:11:16,449
was similar to past mistakes that we

252
00:11:13,389 --> 00:11:17,980
know about well it turns out that there

253
00:11:16,449 --> 00:11:21,339
are a few tools out there that allow you

254
00:11:17,980 --> 00:11:23,350
to do exactly this clanked ID for

255
00:11:21,339 --> 00:11:25,149
example part of the clan compiler can be

256
00:11:23,350 --> 00:11:27,009
extended to write rules for C++ that

257
00:11:25,149 --> 00:11:30,009
take into account both syntactic and

258
00:11:27,009 --> 00:11:32,379
semantic information so Mozilla for

259
00:11:30,009 --> 00:11:34,360
example have a custom set of rules that

260
00:11:32,379 --> 00:11:35,980
are run against every patch for Firefox

261
00:11:34,360 --> 00:11:38,170
submitted to fabricator

262
00:11:35,980 --> 00:11:39,579
and they're building this rule set over

263
00:11:38,170 --> 00:11:41,769
time so every time they come across a

264
00:11:39,579 --> 00:11:44,378
new type of vulnerability the like cool

265
00:11:41,769 --> 00:11:45,939
can we write a clang rule for that and

266
00:11:44,379 --> 00:11:47,439
lint is as well are actually starting to

267
00:11:45,939 --> 00:11:49,649
include more and more semantic

268
00:11:47,439 --> 00:11:51,879
information for their rules sets to use

269
00:11:49,649 --> 00:11:54,939
particularly those on more started you

270
00:11:51,879 --> 00:11:56,589
typed languages there are also a number

271
00:11:54,939 --> 00:11:59,349
of technologies emerging that Ally to

272
00:11:56,589 --> 00:12:01,089
interactively write queries over source

273
00:11:59,350 --> 00:12:03,850
code that includes semantic information

274
00:12:01,089 --> 00:12:06,759
and including one solution by my company

275
00:12:03,850 --> 00:12:08,980
actually I'm not going to compare all

276
00:12:06,759 --> 00:12:11,350
these different technologies in this

277
00:12:08,980 --> 00:12:12,850
presentation if but I do want you to

278
00:12:11,350 --> 00:12:14,800
know that there are lots of different

279
00:12:12,850 --> 00:12:17,860
things you can use to make your life a

280
00:12:14,800 --> 00:12:20,109
lot easier doing this and I do want to

281
00:12:17,860 --> 00:12:21,970
give you an idea of what such a query

282
00:12:20,110 --> 00:12:24,759
would look like or such a description of

283
00:12:21,970 --> 00:12:29,199
a problem so I'm going to go through an

284
00:12:24,759 --> 00:12:30,429
example but if you want to talk to me

285
00:12:29,199 --> 00:12:31,870
afterwards about the different

286
00:12:30,429 --> 00:12:35,050
technologies that are available and I'm

287
00:12:31,870 --> 00:12:36,610
happy to chat so this example I'm going

288
00:12:35,050 --> 00:12:38,769
to go through and it's from the same

289
00:12:36,610 --> 00:12:40,839
blog post as I took that quote from for

290
00:12:38,769 --> 00:12:44,410
them Microsoft Security Response Center

291
00:12:40,839 --> 00:12:48,550
earlier so this can we see that it's

292
00:12:44,410 --> 00:12:50,350
little blurry but hopefully I'll be

293
00:12:48,550 --> 00:12:51,089
stepping through and expanding it so you

294
00:12:50,350 --> 00:12:53,999
should be

295
00:12:51,089 --> 00:12:56,129
to hopefully understand so this is some

296
00:12:53,999 --> 00:12:58,680
illustrative code from chakracore which

297
00:12:56,129 --> 00:13:00,899
is Microsoft's JavaScript engine the

298
00:12:58,680 --> 00:13:02,059
powers edge and a bunch of applications

299
00:13:00,899 --> 00:13:05,490
and windows

300
00:13:02,059 --> 00:13:09,480
so this C++ code is part of a built-in

301
00:13:05,490 --> 00:13:13,350
function that can be called from within

302
00:13:09,480 --> 00:13:17,519
JavaScript code now the first thing it

303
00:13:13,350 --> 00:13:19,319
does here is that it gets the pointer to

304
00:13:17,519 --> 00:13:21,809
and the size of a particular block of

305
00:13:19,319 --> 00:13:25,559
memory that represents a javascript

306
00:13:21,809 --> 00:13:28,410
array buffer one that is being passed in

307
00:13:25,559 --> 00:13:30,329
via arced the arguments and assigns

308
00:13:28,410 --> 00:13:34,410
those values the local variables P

309
00:13:30,329 --> 00:13:37,170
buffer and buffer size after that the

310
00:13:34,410 --> 00:13:39,839
call to Vartan may potentially run

311
00:13:37,170 --> 00:13:42,479
arbitrary JavaScript code because it

312
00:13:39,839 --> 00:13:44,459
uses the passed objects value of method

313
00:13:42,480 --> 00:13:46,920
to calculate its value and you can

314
00:13:44,459 --> 00:13:50,248
overwrite that method in the JavaScript

315
00:13:46,920 --> 00:13:52,498
code you could for example make that

316
00:13:50,249 --> 00:13:54,600
method free the buffer and then when the

317
00:13:52,499 --> 00:13:58,410
code returns P buffer would be a

318
00:13:54,600 --> 00:14:00,360
dangling pointer so this point P buffer

319
00:13:58,410 --> 00:14:02,370
is a dangling pointer and buffer size

320
00:14:00,360 --> 00:14:05,420
refers to the size that the array buffer

321
00:14:02,370 --> 00:14:07,860
used to be but it doesn't exist anymore

322
00:14:05,420 --> 00:14:10,079
then when we later try to pull an

323
00:14:07,860 --> 00:14:11,850
operation on the array using these two

324
00:14:10,079 --> 00:14:14,870
variables we encounter a memory

325
00:14:11,850 --> 00:14:14,870
corruption vulnerability

326
00:14:16,180 --> 00:14:20,800
and this is more or less what the

327
00:14:17,959 --> 00:14:23,089
JavaScript exploit would look like and

328
00:14:20,800 --> 00:14:25,729
here you can see that they're replacing

329
00:14:23,089 --> 00:14:27,500
the value of method with a function that

330
00:14:25,730 --> 00:14:31,310
runs their own code which triggers a

331
00:14:27,500 --> 00:14:33,620
vulnerability so Microsoft assess this

332
00:14:31,310 --> 00:14:35,388
vulnerability is critical it could

333
00:14:33,620 --> 00:14:38,060
potentially allow arbitrary code

334
00:14:35,389 --> 00:14:40,399
execution in the JavaScript engine which

335
00:14:38,060 --> 00:14:43,388
is pretty bad it's about as bad an

336
00:14:40,399 --> 00:14:45,649
exploit you can get on a web browser and

337
00:14:43,389 --> 00:14:46,910
Microsoft wanted to know whether they

338
00:14:45,649 --> 00:14:49,100
had any similar mistakes of this

339
00:14:46,910 --> 00:14:50,810
anywhere else in the chakra code so they

340
00:14:49,100 --> 00:14:52,370
wrote a query that described the pattern

341
00:14:50,810 --> 00:14:54,170
of assigning the pointer to an array

342
00:14:52,370 --> 00:14:56,509
buffer of an array buffer to a variable

343
00:14:54,170 --> 00:15:00,079
then calling back into JavaScript before

344
00:14:56,509 --> 00:15:02,120
using the pointer so this is what the

345
00:15:00,079 --> 00:15:04,040
query you looked like I've modified it a

346
00:15:02,120 --> 00:15:05,750
little bit here so it fit on to one

347
00:15:04,040 --> 00:15:07,819
slide and if you having difficulty

348
00:15:05,750 --> 00:15:11,300
reading it I can show it to you after

349
00:15:07,819 --> 00:15:13,550
the presentation as well but for anyone

350
00:15:11,300 --> 00:15:16,029
who's used a database query language

351
00:15:13,550 --> 00:15:19,609
like SQL there'll be a few similar

352
00:15:16,029 --> 00:15:21,620
familiar concepts here the first thing

353
00:15:19,610 --> 00:15:23,029
is we've got a from clause here the list

354
00:15:21,620 --> 00:15:24,860
the relationships that are the ratios

355
00:15:23,029 --> 00:15:27,019
were interested in looking at in this

356
00:15:24,860 --> 00:15:29,449
case we're looking at variables accesses

357
00:15:27,019 --> 00:15:31,760
to array buffer pointers function calls

358
00:15:29,449 --> 00:15:34,939
and accesses to variables which is

359
00:15:31,760 --> 00:15:36,939
either a read or write where lists some

360
00:15:34,940 --> 00:15:39,230
conditions that need to be satisfied and

361
00:15:36,940 --> 00:15:41,959
select lists the columns that we want to

362
00:15:39,230 --> 00:15:44,240
output so jumping into the where

363
00:15:41,959 --> 00:15:46,399
condition this line ensures that the

364
00:15:44,240 --> 00:15:49,130
pointer assignment and variable use are

365
00:15:46,399 --> 00:15:51,350
talking about the same variable so here

366
00:15:49,130 --> 00:15:53,089
in making sure that definition and use

367
00:15:51,350 --> 00:15:56,800
and V are all talking about the same

368
00:15:53,089 --> 00:15:56,800
variable which in this case is P buffer

369
00:15:57,180 --> 00:16:01,199
this next line is a little bit more

370
00:15:58,740 --> 00:16:05,640
complex and it ensures that the function

371
00:16:01,200 --> 00:16:07,890
call call might potentially execute

372
00:16:05,640 --> 00:16:10,590
JavaScript code now rather than

373
00:16:07,890 --> 00:16:12,449
enumerate in every single function that

374
00:16:10,590 --> 00:16:14,040
could possibly execute JavaScript code

375
00:16:12,450 --> 00:16:15,960
in the Shocker code base of which there

376
00:16:14,040 --> 00:16:18,599
are many I'm sure you can imagine and

377
00:16:15,960 --> 00:16:21,210
the security researchers knew that any

378
00:16:18,600 --> 00:16:23,280
code that calls back into JavaScript may

379
00:16:21,210 --> 00:16:27,990
eventually call this function method

380
00:16:23,280 --> 00:16:31,680
call too primitive so what they have

381
00:16:27,990 --> 00:16:34,200
expressed here is that call might at

382
00:16:31,680 --> 00:16:37,890
some point in the core draft call this

383
00:16:34,200 --> 00:16:39,330
method called a primitive function so

384
00:16:37,890 --> 00:16:40,800
they might a might call it directly or a

385
00:16:39,330 --> 00:16:41,970
might call a function that calls it or a

386
00:16:40,800 --> 00:16:47,069
might call a function that calls another

387
00:16:41,970 --> 00:16:49,440
function that calls L and so on so yeah

388
00:16:47,070 --> 00:16:53,220
this is this is the function that that

389
00:16:49,440 --> 00:16:56,550
refers to you then this line effectively

390
00:16:53,220 --> 00:17:00,600
says that the call to JavaScript happens

391
00:16:56,550 --> 00:17:03,000
after we assign the pointer so first we

392
00:17:00,600 --> 00:17:05,130
have a P buffer assignment and then we

393
00:17:03,000 --> 00:17:06,599
make the call and then this next line

394
00:17:05,130 --> 00:17:08,430
says that the east edge of the pointer

395
00:17:06,599 --> 00:17:11,550
happens after we get back into

396
00:17:08,430 --> 00:17:17,839
JavaScript code so we first make my call

397
00:17:11,550 --> 00:17:20,970
and then we use it now in the blog post

398
00:17:17,839 --> 00:17:22,679
Stephen hunter the the researcher that

399
00:17:20,970 --> 00:17:24,900
was writing this query and during the

400
00:17:22,680 --> 00:17:27,030
research said that in addition to

401
00:17:24,900 --> 00:17:29,630
finding the original vulnerability this

402
00:17:27,030 --> 00:17:32,070
query found four additional variants

403
00:17:29,630 --> 00:17:35,150
that they also assessed being critical

404
00:17:32,070 --> 00:17:35,149
within the chakra codebase

405
00:17:35,900 --> 00:17:40,670
so that example was very specific to the

406
00:17:38,510 --> 00:17:42,320
chakra codebase but there are many kinds

407
00:17:40,670 --> 00:17:46,010
of mistakes that are a lot more general

408
00:17:42,320 --> 00:17:48,860
that will just apply across potentially

409
00:17:46,010 --> 00:17:51,020
a whole anyone that uses a particular

410
00:17:48,860 --> 00:17:52,699
programming language for example there

411
00:17:51,020 --> 00:17:54,920
might be a misuse of a language feature

412
00:17:52,700 --> 00:17:58,040
for mistakes that are commonly made with

413
00:17:54,920 --> 00:17:59,570
a certain type of API and in those cases

414
00:17:58,040 --> 00:18:01,940
you can actually go one step further and

415
00:17:59,570 --> 00:18:03,919
share your queries and checks with the

416
00:18:01,940 --> 00:18:07,940
world and open source your queries open

417
00:18:03,920 --> 00:18:09,650
source your client ID checks etc and I'm

418
00:18:07,940 --> 00:18:15,380
going to go through an example of when

419
00:18:09,650 --> 00:18:18,440
this happened yep had some things there

420
00:18:15,380 --> 00:18:23,630
as well so raise your hands if you've

421
00:18:18,440 --> 00:18:26,450
heard of zip slip one person call that

422
00:18:23,630 --> 00:18:27,679
means I get to explain it so like all

423
00:18:26,450 --> 00:18:33,890
called vulnerabilities this one had a

424
00:18:27,679 --> 00:18:37,250
logo and it was discovered by the

425
00:18:33,890 --> 00:18:41,780
researchers it's Nick now and it takes

426
00:18:37,250 --> 00:18:43,970
advantage of the way that zip files are

427
00:18:41,780 --> 00:18:46,899
structured so you might think that a zip

428
00:18:43,970 --> 00:18:49,940
file contains a directory structure with

429
00:18:46,900 --> 00:18:53,870
parent nodes etc that details exactly

430
00:18:49,940 --> 00:18:56,120
what's inside the zip file it's actually

431
00:18:53,870 --> 00:18:59,449
a lot simpler than that a zip file this

432
00:18:56,120 --> 00:19:02,360
is a list of entries where each entry

433
00:18:59,450 --> 00:19:04,400
has a path which is a string which might

434
00:19:02,360 --> 00:19:05,899
include slashes which then is how you

435
00:19:04,400 --> 00:19:08,300
know that something is in the directory

436
00:19:05,900 --> 00:19:09,800
it's not actually stored as a graph

437
00:19:08,300 --> 00:19:11,990
inside a zip file it's just a list of

438
00:19:09,800 --> 00:19:13,879
strings and then of course you have the

439
00:19:11,990 --> 00:19:16,030
the file contents and the metadata as

440
00:19:13,880 --> 00:19:16,030
well

441
00:19:16,530 --> 00:19:20,820
so what this means is that you could put

442
00:19:19,110 --> 00:19:24,500
a string in a zip file that contains

443
00:19:20,820 --> 00:19:27,179
these paths traversal components and

444
00:19:24,500 --> 00:19:29,250
what happens in a lot of programs that

445
00:19:27,180 --> 00:19:32,160
are trying to unzip zip files is they'll

446
00:19:29,250 --> 00:19:35,760
just concatenate a string like this onto

447
00:19:32,160 --> 00:19:37,860
their target directory and then they

448
00:19:35,760 --> 00:19:39,150
will then unzip files outside of their

449
00:19:37,860 --> 00:19:41,010
target directory and he could

450
00:19:39,150 --> 00:19:43,050
potentially overwrite files you didn't

451
00:19:41,010 --> 00:19:46,500
mean to say if you're running one of

452
00:19:43,050 --> 00:19:49,250
these programs as route and there was a

453
00:19:46,500 --> 00:19:52,890
file that was dot slash tilde slash etc

454
00:19:49,250 --> 00:19:55,950
crontab then you would be able to inject

455
00:19:52,890 --> 00:19:58,800
on the server some scripts that would

456
00:19:55,950 --> 00:20:02,810
run when he chose to and there would be

457
00:19:58,800 --> 00:20:02,810
no indication that this has happened and

458
00:20:03,260 --> 00:20:12,629
yes it's pretty bad now this turned out

459
00:20:10,530 --> 00:20:14,310
that it was a very widespread mistake

460
00:20:12,630 --> 00:20:17,430
that's made in pretty much every

461
00:20:14,310 --> 00:20:18,600
programming language any programming

462
00:20:17,430 --> 00:20:22,920
language you might want to be able to

463
00:20:18,600 --> 00:20:24,209
write an unzipping method you might be

464
00:20:22,920 --> 00:20:26,160
vulnerable to this and here's an example

465
00:20:24,210 --> 00:20:27,920
of what the code looked like so this is

466
00:20:26,160 --> 00:20:30,120
some Java code that does some unzipping

467
00:20:27,920 --> 00:20:33,690
and this line in particular is the

468
00:20:30,120 --> 00:20:36,209
problematic one so you take the name

469
00:20:33,690 --> 00:20:37,710
which is the path of the zip entry then

470
00:20:36,210 --> 00:20:39,240
you add it to the end of this

471
00:20:37,710 --> 00:20:43,710
destination day which is just a file

472
00:20:39,240 --> 00:20:45,900
somewhere on your computer and if it's

473
00:20:43,710 --> 00:20:49,020
got or slashes in it it could be

474
00:20:45,900 --> 00:20:51,000
extracted anywhere now to fix this is

475
00:20:49,020 --> 00:20:53,550
relatively simple you just need to check

476
00:20:51,000 --> 00:20:55,230
that once you've joined the path

477
00:20:53,550 --> 00:20:56,370
together and you normalize it that it's

478
00:20:55,230 --> 00:20:58,530
still within the destination directory

479
00:20:56,370 --> 00:21:00,899
and most programming languages this will

480
00:20:58,530 --> 00:21:02,629
be about one or two lines to check so

481
00:21:00,900 --> 00:21:04,740
there's really no excuse not to do this

482
00:21:02,630 --> 00:21:06,990
even if you know what the corners of the

483
00:21:04,740 --> 00:21:10,800
zip file are you really should should do

484
00:21:06,990 --> 00:21:12,720
this so when snick announced this

485
00:21:10,800 --> 00:21:15,030
vulnerability they actually put in a

486
00:21:12,720 --> 00:21:16,710
great deal of effort to try and find as

487
00:21:15,030 --> 00:21:18,500
many of these as possible and that the

488
00:21:16,710 --> 00:21:20,640
maintainers of those projects know

489
00:21:18,500 --> 00:21:23,550
because the repercussions were quite

490
00:21:20,640 --> 00:21:26,430
large and they had maybe though 20 or 30

491
00:21:23,550 --> 00:21:30,060
or so projects that they reached out to

492
00:21:26,430 --> 00:21:32,820
and and they all addressed this issue

493
00:21:30,060 --> 00:21:35,669
but they obviously couldn't find

494
00:21:32,820 --> 00:21:37,230
everything everywhere because it's very

495
00:21:35,670 --> 00:21:39,870
difficult to do that sort of analysis on

496
00:21:37,230 --> 00:21:41,280
a wide scale so when they announced this

497
00:21:39,870 --> 00:21:42,780
Microsoft one didn't know if they were

498
00:21:41,280 --> 00:21:43,550
making the mistake internally with any

499
00:21:42,780 --> 00:21:46,260
of their code

500
00:21:43,550 --> 00:21:48,899
they wrote a query effectively like the

501
00:21:46,260 --> 00:21:52,310
last one the search for this pattern in

502
00:21:48,900 --> 00:21:56,610
c-sharp and they effectively looked for

503
00:21:52,310 --> 00:21:59,460
data that flows from a zip file entry to

504
00:21:56,610 --> 00:22:02,520
an i/o operation without any

505
00:21:59,460 --> 00:22:04,080
sanitization along the way and they ran

506
00:22:02,520 --> 00:22:06,330
across their code found a bunch of

507
00:22:04,080 --> 00:22:08,399
vulnerabilities but after they did that

508
00:22:06,330 --> 00:22:10,649
they open sourced this query so that

509
00:22:08,400 --> 00:22:11,730
other people could also run it against

510
00:22:10,650 --> 00:22:15,480
their code to see if they were making

511
00:22:11,730 --> 00:22:22,110
the same mistake which was really really

512
00:22:15,480 --> 00:22:23,970
cool of them so I think I've gone over

513
00:22:22,110 --> 00:22:25,260
like the power of the sort of the sort

514
00:22:23,970 --> 00:22:28,770
of thing that you can find with vert

515
00:22:25,260 --> 00:22:31,560
analysis and there's a good few examples

516
00:22:28,770 --> 00:22:34,310
of what happens when you don't do it

517
00:22:31,560 --> 00:22:37,080
such as the the examples at the start

518
00:22:34,310 --> 00:22:38,850
but how would you actually take very

519
00:22:37,080 --> 00:22:42,000
Nasus and fit it into your workflow if

520
00:22:38,850 --> 00:22:45,149
you're a development organization so

521
00:22:42,000 --> 00:22:47,280
let's assume that you already have a

522
00:22:45,150 --> 00:22:49,380
workflow in place to respond to

523
00:22:47,280 --> 00:22:52,440
vulnerabilities that you may have found

524
00:22:49,380 --> 00:22:55,200
either internally or externally it might

525
00:22:52,440 --> 00:22:57,300
look something like this you find a new

526
00:22:55,200 --> 00:22:59,580
security bug maybe get it through your

527
00:22:57,300 --> 00:23:02,040
bug bounty or through pen testing or

528
00:22:59,580 --> 00:23:05,399
something you diagnose it to find this

529
00:23:02,040 --> 00:23:09,330
root course you fix the bug and then you

530
00:23:05,400 --> 00:23:11,400
push out a fix to your users so the

531
00:23:09,330 --> 00:23:12,990
natural place for this to fit in would

532
00:23:11,400 --> 00:23:15,030
be as additional steps that follow the

533
00:23:12,990 --> 00:23:17,250
root cause diagnosis so after you've

534
00:23:15,030 --> 00:23:21,420
worked out what's going on this is where

535
00:23:17,250 --> 00:23:22,740
you would then do very analysis so or

536
00:23:21,420 --> 00:23:25,080
automated rat analysis you would then

537
00:23:22,740 --> 00:23:26,910
describe the mistake as a clang overall

538
00:23:25,080 --> 00:23:31,169
or using any of the other tools

539
00:23:26,910 --> 00:23:32,580
available and you would see what results

540
00:23:31,170 --> 00:23:34,710
you get you would probably get a few

541
00:23:32,580 --> 00:23:35,820
false positives because there might be

542
00:23:34,710 --> 00:23:38,520
some things you didn't take into account

543
00:23:35,820 --> 00:23:39,590
or some ways that data sanitized or some

544
00:23:38,520 --> 00:23:43,639
check

545
00:23:39,590 --> 00:23:46,189
you haven't like written in so you then

546
00:23:43,640 --> 00:23:47,750
refine your query until you've reduced

547
00:23:46,190 --> 00:23:49,820
the set of results down to a small

548
00:23:47,750 --> 00:23:51,770
enough number that you can then manually

549
00:23:49,820 --> 00:23:56,330
go through them and see what what what's

550
00:23:51,770 --> 00:23:58,400
that you'll probably find a few

551
00:23:56,330 --> 00:24:00,439
vulnerabilities that you didn't find

552
00:23:58,400 --> 00:24:04,550
that with other other than the initial

553
00:24:00,440 --> 00:24:07,580
one so now at this point you can fix

554
00:24:04,550 --> 00:24:08,899
those as well and deploy a fix to all

555
00:24:07,580 --> 00:24:11,030
your users that includes not just the

556
00:24:08,900 --> 00:24:13,010
original vulnerability but all of the

557
00:24:11,030 --> 00:24:15,370
variants which is effectively what

558
00:24:13,010 --> 00:24:20,030
Microsoft do and Google for their

559
00:24:15,370 --> 00:24:21,649
process now beyond that now that the

560
00:24:20,030 --> 00:24:24,139
query is written or now that the

561
00:24:21,650 --> 00:24:28,450
description of your mistake is written

562
00:24:24,140 --> 00:24:30,890
you can run it on a regular basis

563
00:24:28,450 --> 00:24:33,350
continuously monitoring to see whether

564
00:24:30,890 --> 00:24:35,120
anyone accidentally tries to reintroduce

565
00:24:33,350 --> 00:24:40,129
a problem that you're very familiar with

566
00:24:35,120 --> 00:24:41,389
because that will happen and you could

567
00:24:40,130 --> 00:24:46,520
potentially even integrate it with your

568
00:24:41,390 --> 00:24:47,930
code review so that or have it lightly

569
00:24:46,520 --> 00:24:50,240
built or something and fix these bugs

570
00:24:47,930 --> 00:24:55,250
before they merged back into your

571
00:24:50,240 --> 00:24:59,990
codebase now beyond that going one step

572
00:24:55,250 --> 00:25:01,460
further Oh before I say that though this

573
00:24:59,990 --> 00:25:03,290
is effectively what Mozilla are doing

574
00:25:01,460 --> 00:25:06,620
and that screenshot I showed you earlier

575
00:25:03,290 --> 00:25:08,840
with their clanked ID and so whenever

576
00:25:06,620 --> 00:25:11,239
anyone submits code they have a bot that

577
00:25:08,840 --> 00:25:12,379
runs all their results if it finds

578
00:25:11,240 --> 00:25:16,430
anything it posts them and you can

579
00:25:12,380 --> 00:25:19,010
address it before the code is merged so

580
00:25:16,430 --> 00:25:22,580
the final steps beyond this to sort of

581
00:25:19,010 --> 00:25:23,960
really go the extra mile would be open

582
00:25:22,580 --> 00:25:25,879
sourcing the checks that you've written

583
00:25:23,960 --> 00:25:27,440
so that other security teams or other

584
00:25:25,880 --> 00:25:29,210
developers from outside your

585
00:25:27,440 --> 00:25:32,210
organization can benefit from it and

586
00:25:29,210 --> 00:25:34,430
going one step further you can then also

587
00:25:32,210 --> 00:25:36,290
use the knowledge of other security

588
00:25:34,430 --> 00:25:39,560
teams from outside your organization or

589
00:25:36,290 --> 00:25:41,899
outside your group of maintainer x' and

590
00:25:39,560 --> 00:25:44,169
run those checks on your repository as

591
00:25:41,900 --> 00:25:48,110
well to take advantage of that knowledge

592
00:25:44,170 --> 00:25:52,640
so not everyone in here I'm sure our

593
00:25:48,110 --> 00:25:53,990
developers or part of a developerworks

594
00:25:52,640 --> 00:25:56,230
what happens if if you're one of those

595
00:25:53,990 --> 00:25:59,330
people and maybe you don't have a

596
00:25:56,230 --> 00:26:01,790
vulnerability response process so you

597
00:25:59,330 --> 00:26:03,139
might be part of a small startup or you

598
00:26:01,790 --> 00:26:05,570
might be working on an open-source

599
00:26:03,140 --> 00:26:07,250
project maybe just as a maintainer well

600
00:26:05,570 --> 00:26:08,990
the first thing to understand is that

601
00:26:07,250 --> 00:26:11,510
sooner or later if you're working on

602
00:26:08,990 --> 00:26:12,920
software at all you may very well be

603
00:26:11,510 --> 00:26:15,200
faced with a vulnerability that you need

604
00:26:12,920 --> 00:26:16,880
to deal with and it would be good if you

605
00:26:15,200 --> 00:26:18,620
had an idea of how to go about dealing

606
00:26:16,880 --> 00:26:19,970
with that situation but in the meantime

607
00:26:18,620 --> 00:26:23,409
if there's any code that you're in

608
00:26:19,970 --> 00:26:27,770
charge of I would highly recommend

609
00:26:23,410 --> 00:26:29,300
making some sort of automated checks

610
00:26:27,770 --> 00:26:33,680
that are like freely available for you

611
00:26:29,300 --> 00:26:34,610
to use and running them on your code so

612
00:26:33,680 --> 00:26:35,720
what about if you're not involved in

613
00:26:34,610 --> 00:26:37,340
software development but you're just

614
00:26:35,720 --> 00:26:40,040
involved in vulnerability discovery

615
00:26:37,340 --> 00:26:41,870
maybe you're part of some bug bounty

616
00:26:40,040 --> 00:26:48,200
programs maybe you just like breaking

617
00:26:41,870 --> 00:26:50,149
things so that other people suffer so

618
00:26:48,200 --> 00:26:52,820
very nervous can also be useful to you

619
00:26:50,150 --> 00:26:54,770
as well so at the start of the

620
00:26:52,820 --> 00:26:57,530
presentation I mentioned two of my

621
00:26:54,770 --> 00:26:59,270
co-workers marenkov that I found these

622
00:26:57,530 --> 00:27:02,930
vulnerabilities they're actually part of

623
00:26:59,270 --> 00:27:05,030
my company security researcher team and

624
00:27:02,930 --> 00:27:07,670
about 80% of the vulnerabilities they

625
00:27:05,030 --> 00:27:09,200
find they find using variant analysis so

626
00:27:07,670 --> 00:27:11,030
they'd know like they'll look at an open

627
00:27:09,200 --> 00:27:13,760
source project my cool what mistakes is

628
00:27:11,030 --> 00:27:14,870
this project made before and I'll pick

629
00:27:13,760 --> 00:27:16,460
out one they're like alright let's try

630
00:27:14,870 --> 00:27:18,830
and write a query for that and they run

631
00:27:16,460 --> 00:27:21,260
the query and see if there are any more

632
00:27:18,830 --> 00:27:22,970
results still and most of the time there

633
00:27:21,260 --> 00:27:24,350
are still results so then they can

634
00:27:22,970 --> 00:27:29,270
report those vulnerabilities and got a

635
00:27:24,350 --> 00:27:32,750
bunch of CVS most recently one of our

636
00:27:29,270 --> 00:27:35,690
researchers found a vulnerability in you

637
00:27:32,750 --> 00:27:39,320
booth and rat created a query for it and

638
00:27:35,690 --> 00:27:43,190
found 13 in total of the same mistake

639
00:27:39,320 --> 00:27:44,540
elsewhere throughout u-boot so yeah so

640
00:27:43,190 --> 00:27:46,340
the finding just one vulnerability find

641
00:27:44,540 --> 00:27:50,840
four or five or six and get all of those

642
00:27:46,340 --> 00:27:52,550
CVS but still likes so much low-hanging

643
00:27:50,840 --> 00:27:54,379
fruit left so many projects are still

644
00:27:52,550 --> 00:27:55,639
making the same mistakes over and over

645
00:27:54,380 --> 00:27:58,700
again that they made in the past so

646
00:27:55,640 --> 00:28:00,730
there's plenty of plenty of opportunity

647
00:27:58,700 --> 00:28:04,340
for everyone

648
00:28:00,730 --> 00:28:06,129
so I'm getting close to the end I've

649
00:28:04,340 --> 00:28:09,459
actually run through this pretty quick

650
00:28:06,129 --> 00:28:13,189
but there's a couple of things I want to

651
00:28:09,460 --> 00:28:17,360
talk about firstly I want to say a few

652
00:28:13,190 --> 00:28:19,159
things that very analysis is not so it

653
00:28:17,360 --> 00:28:21,229
is not a replacement for good security

654
00:28:19,159 --> 00:28:23,029
architecture or a way to avoid doing a

655
00:28:21,230 --> 00:28:24,529
lot of you factors if for example you

656
00:28:23,029 --> 00:28:26,179
are coming across a whole bunch of

657
00:28:24,529 --> 00:28:29,409
memory corruption issues in your

658
00:28:26,179 --> 00:28:33,710
application maybe still consider

659
00:28:29,409 --> 00:28:35,149
migrating to rust instead of C if you're

660
00:28:33,710 --> 00:28:36,350
using expression languages and you

661
00:28:35,149 --> 00:28:40,939
getting those developers that may be

662
00:28:36,350 --> 00:28:42,469
stopped using those maybe if you're if

663
00:28:40,940 --> 00:28:45,100
you're getting a lot of SQL injections

664
00:28:42,470 --> 00:28:47,929
use or to escaping database libraries

665
00:28:45,100 --> 00:28:50,389
it's not a replacement for or it's not

666
00:28:47,929 --> 00:28:51,619
an excuse not to improve the security of

667
00:28:50,389 --> 00:28:55,490
your application you should go ahead and

668
00:28:51,619 --> 00:28:58,639
do that anyway it is not a replacement

669
00:28:55,490 --> 00:29:00,529
for exploit mitigation stuff like

670
00:28:58,639 --> 00:29:02,779
address space layout randomization or

671
00:29:00,529 --> 00:29:06,889
stack Canaries are still super useful

672
00:29:02,779 --> 00:29:07,850
and very important to prevent at least

673
00:29:06,889 --> 00:29:10,969
the hand that you can do when

674
00:29:07,850 --> 00:29:12,678
vulnerabilities are found it is not a

675
00:29:10,970 --> 00:29:15,019
replacement for other security processes

676
00:29:12,679 --> 00:29:17,869
that are also very important fuzzing for

677
00:29:15,019 --> 00:29:19,759
example it actually complements it very

678
00:29:17,869 --> 00:29:21,350
well you might find a bag through

679
00:29:19,759 --> 00:29:23,059
fuzzing you look at the vulnerability

680
00:29:21,350 --> 00:29:24,379
you look at the root cause describe your

681
00:29:23,059 --> 00:29:26,619
mistake for it and then instead of

682
00:29:24,379 --> 00:29:28,789
fuzzing resulting in one vulnerability

683
00:29:26,619 --> 00:29:31,449
fuzzing invariant analysis is resulted

684
00:29:28,789 --> 00:29:33,769
in five or six or ten vulnerabilities

685
00:29:31,450 --> 00:29:35,480
it's not a replacement for doing

686
00:29:33,769 --> 00:29:37,970
vulnerability disclosure or bug bounties

687
00:29:35,480 --> 00:29:40,190
they're also both very important and in

688
00:29:37,970 --> 00:29:42,049
fact it can be a good source at the

689
00:29:40,190 --> 00:29:44,240
start for you to them do very analysis

690
00:29:42,049 --> 00:29:47,059
it's not a replacement for audits or pen

691
00:29:44,240 --> 00:29:49,940
testing or red teaming or writing unit

692
00:29:47,059 --> 00:29:52,759
tests or doing dependency monitoring all

693
00:29:49,940 --> 00:29:54,950
of those are still super crucial and it

694
00:29:52,759 --> 00:29:56,690
doesn't replace on your face and the

695
00:29:54,950 --> 00:29:58,220
last thing it is not it is not something

696
00:29:56,690 --> 00:30:00,919
that autumn must be fixes bugs for you

697
00:29:58,220 --> 00:30:02,570
it just finds them and it's a process so

698
00:30:00,919 --> 00:30:04,490
you how you go about actually fixing

699
00:30:02,570 --> 00:30:08,259
vulnerabilities is still down to you or

700
00:30:04,490 --> 00:30:08,259
the people maintaining the code

701
00:30:08,340 --> 00:30:13,740
so to recap the variant analysis is

702
00:30:11,340 --> 00:30:15,149
relevant to you if you either develop

703
00:30:13,740 --> 00:30:18,510
your own software or you do security

704
00:30:15,150 --> 00:30:21,360
research at least white white box

705
00:30:18,510 --> 00:30:23,760
security research and then if you have

706
00:30:21,360 --> 00:30:25,469
your own software you probably should be

707
00:30:23,760 --> 00:30:28,379
doing very analysis otherwise you might

708
00:30:25,470 --> 00:30:29,850
be leaving yourself exposed and if you

709
00:30:28,380 --> 00:30:31,080
are a security researcher you can take

710
00:30:29,850 --> 00:30:33,030
advantage of those that aren't doing

711
00:30:31,080 --> 00:30:41,280
very analysis to find lots of bugs in

712
00:30:33,030 --> 00:30:44,370
their code because there are a lot if

713
00:30:41,280 --> 00:30:45,690
you are finding doing Brett analysis and

714
00:30:44,370 --> 00:30:47,760
finding queries for new types of

715
00:30:45,690 --> 00:30:49,020
vulnerabilities share those queries with

716
00:30:47,760 --> 00:30:51,390
other people so that other people can

717
00:30:49,020 --> 00:30:56,040
secure their own code it's very

718
00:30:51,390 --> 00:30:57,060
important and also like use the

719
00:30:56,040 --> 00:30:59,310
knowledge that other people are doing

720
00:30:57,060 --> 00:31:00,899
and sharing and use all the security

721
00:30:59,310 --> 00:31:02,820
tools and checks that are being made

722
00:31:00,900 --> 00:31:06,980
freely available and because there's

723
00:31:02,820 --> 00:31:09,450
lots happening every every day and then

724
00:31:06,980 --> 00:31:12,000
very nice isn't a once-off process when

725
00:31:09,450 --> 00:31:14,280
you get a vulnerability and like I said

726
00:31:12,000 --> 00:31:17,280
someone can always reintroduce a mistake

727
00:31:14,280 --> 00:31:19,080
in the future that similar to ones

728
00:31:17,280 --> 00:31:20,520
they've done in the past and you want to

729
00:31:19,080 --> 00:31:25,100
be able to prevent and check against

730
00:31:20,520 --> 00:31:25,100
that as well so run them continuously

731
00:31:25,940 --> 00:31:32,460
and VA like very Nasus will complement

732
00:31:30,720 --> 00:31:34,470
existing security practices you can take

733
00:31:32,460 --> 00:31:37,200
your knowledge from fuzzing and from

734
00:31:34,470 --> 00:31:39,600
other things and then do VA on that and

735
00:31:37,200 --> 00:31:45,110
then find even more vulnerabilities and

736
00:31:39,600 --> 00:31:51,590
lock down and prevent further mistakes

737
00:31:45,110 --> 00:31:51,590
all right that's all I have thank you

738
00:31:55,280 --> 00:31:58,360
deaf questions

739
00:32:07,800 --> 00:32:10,340
my

740
00:32:10,450 --> 00:32:13,400
it works better when I turn it on thank

741
00:32:13,070 --> 00:32:15,560
you

742
00:32:13,400 --> 00:32:18,110
I have one question you have a query

743
00:32:15,560 --> 00:32:20,480
language in you have an engine I have a

744
00:32:18,110 --> 00:32:23,540
couple of things first how can we use

745
00:32:20,480 --> 00:32:26,600
this in our projects second on how can

746
00:32:23,540 --> 00:32:29,500
we improve on the engine so is this open

747
00:32:26,600 --> 00:32:33,830
source is this closed source is this

748
00:32:29,500 --> 00:32:35,840
where we add that so

749
00:32:33,830 --> 00:32:39,620
parts of it are open source and part of

750
00:32:35,840 --> 00:32:44,570
its a closed source and so there are all

751
00:32:39,620 --> 00:32:47,239
the all of the checks that we provide

752
00:32:44,570 --> 00:32:48,950
and all of the base libraries and our

753
00:32:47,240 --> 00:32:52,370
open open source and they're being

754
00:32:48,950 --> 00:32:53,870
contributed to by four or five different

755
00:32:52,370 --> 00:32:57,080
organizations including Microsoft

756
00:32:53,870 --> 00:32:58,280
security research and and fire and

757
00:32:57,080 --> 00:33:02,510
Mozilla as well and they're all

758
00:32:58,280 --> 00:33:05,420
submitting so many things to that so so

759
00:33:02,510 --> 00:33:07,129
that my second source the actual engine

760
00:33:05,420 --> 00:33:10,700
that runs the query is currently closed

761
00:33:07,130 --> 00:33:12,620
source but we're thinking about what we

762
00:33:10,700 --> 00:33:15,650
want to do with that in the future as

763
00:33:12,620 --> 00:33:17,479
far as being able to use it open source

764
00:33:15,650 --> 00:33:20,480
projects are allowed to use it for free

765
00:33:17,480 --> 00:33:22,670
and so if anyone has open source stuff

766
00:33:20,480 --> 00:33:25,790
they can just go ahead and use it

767
00:33:22,670 --> 00:33:28,760
and yeah that answer your question fully

768
00:33:25,790 --> 00:33:34,070
okay I'll bug you later on for the rest

769
00:33:28,760 --> 00:33:36,620
of the details but there are lots of

770
00:33:34,070 --> 00:33:38,149
there are similar projects are but that

771
00:33:36,620 --> 00:33:39,139
are existing that have different

772
00:33:38,150 --> 00:33:43,570
licensing models by different

773
00:33:39,140 --> 00:33:43,570
organizations and companies so yeah

774
00:33:48,360 --> 00:33:51,289
anything else

775
00:33:53,490 --> 00:33:56,960
cool or I feel oh yeah

776
00:34:00,070 --> 00:34:08,020
so you've presented us with the tool

777
00:34:03,460 --> 00:34:10,899
that the company work for has built with

778
00:34:08,020 --> 00:34:15,030
some open source parts how does it

779
00:34:10,899 --> 00:34:21,159
compare to purely open source tools like

780
00:34:15,030 --> 00:34:26,079
linters like sonar cube etc etc cool so

781
00:34:21,159 --> 00:34:27,520
the the main difference over all so

782
00:34:26,079 --> 00:34:30,960
let's let's take lentes for example so

783
00:34:27,520 --> 00:34:35,799
linters typically focus mostly on

784
00:34:30,960 --> 00:34:37,510
syntactic checks so and as a result they

785
00:34:35,799 --> 00:34:39,699
often run very fast so you'll take a

786
00:34:37,510 --> 00:34:41,819
linter you'll feed it a file it'll run

787
00:34:39,699 --> 00:34:45,668
some checks on that linters don't

788
00:34:41,819 --> 00:34:50,290
typically do much like cross file checks

789
00:34:45,668 --> 00:34:51,339
or things like being able to track data

790
00:34:50,290 --> 00:34:53,579
flow throughout an entire application

791
00:34:51,339 --> 00:34:56,859
because doing that just doesn't really

792
00:34:53,579 --> 00:34:58,240
you can't really do that in a quick

793
00:34:56,859 --> 00:35:01,720
enough turnaround time that Linda's are

794
00:34:58,240 --> 00:35:03,669
expected to run they are starting to

795
00:35:01,720 --> 00:35:05,379
improve on that in terms of getting some

796
00:35:03,670 --> 00:35:07,299
or at least local semantic information

797
00:35:05,380 --> 00:35:09,490
such as knowing like getting getting

798
00:35:07,299 --> 00:35:15,309
variable references and and stuff like

799
00:35:09,490 --> 00:35:17,500
that but linters are still you wouldn't

800
00:35:15,309 --> 00:35:18,910
be able to do like global data flow

801
00:35:17,500 --> 00:35:21,190
throughout your entire application for

802
00:35:18,910 --> 00:35:22,598
that and so stuff like SQL injections

803
00:35:21,190 --> 00:35:27,490
you might be able to find sun but not

804
00:35:22,599 --> 00:35:30,819
all of them applications like sonar cube

805
00:35:27,490 --> 00:35:36,308
I can remember exactly how sonar cube

806
00:35:30,819 --> 00:35:38,859
compares but a lot of the existing open

807
00:35:36,309 --> 00:35:42,190
source things stuff like find bugs and I

808
00:35:38,859 --> 00:35:44,650
believe they mostly have a built-in set

809
00:35:42,190 --> 00:35:46,930
of rules so you can't really do the

810
00:35:44,650 --> 00:35:50,049
investigation without modifying the code

811
00:35:46,930 --> 00:35:55,930
and then recompiling it and then going

812
00:35:50,049 --> 00:35:58,000
and actually like it's like a long

813
00:35:55,930 --> 00:35:59,440
turnaround time to do for Varanasi so I

814
00:35:58,000 --> 00:36:02,079
think the best solution for that would

815
00:35:59,440 --> 00:36:03,849
be clanked ID you still need to set up a

816
00:36:02,079 --> 00:36:05,559
few scripts and stuff to do like recon

817
00:36:03,849 --> 00:36:08,020
compiling and rerunning it and stuff for

818
00:36:05,559 --> 00:36:11,349
you but that's getting closer and closer

819
00:36:08,020 --> 00:36:13,130
and there are also a couple of other

820
00:36:11,349 --> 00:36:18,069
open source tools I can't remember then

821
00:36:13,130 --> 00:36:20,180
names of that are doing more graph-based

822
00:36:18,069 --> 00:36:21,710
like cool graphs and stuff like that and

823
00:36:20,180 --> 00:36:23,230
they're definitely getting a lot closer

824
00:36:21,710 --> 00:36:27,559
and stuff as well

825
00:36:23,230 --> 00:36:30,519
so the difference is decreasing okay

826
00:36:27,559 --> 00:36:30,519
thank you yeah

827
00:36:35,550 --> 00:36:41,740
how do you know that some part of your

828
00:36:39,099 --> 00:36:44,590
software has just too many bugs and it's

829
00:36:41,740 --> 00:36:47,229
time to not just match them but to

830
00:36:44,590 --> 00:36:52,890
change the architecture how do you know

831
00:36:47,230 --> 00:36:58,230
that that's the point it's a feeling you

832
00:36:52,890 --> 00:37:01,960
know is probably you might measure it by

833
00:36:58,230 --> 00:37:03,580
realizing that you're spending 90 80 90

834
00:37:01,960 --> 00:37:05,500
percent of your time patching and

835
00:37:03,580 --> 00:37:07,270
dealing with problems as they come up

836
00:37:05,500 --> 00:37:11,140
rather than actually improving the

837
00:37:07,270 --> 00:37:12,820
application and I think that will happen

838
00:37:11,140 --> 00:37:14,920
for any sort of like architectural floor

839
00:37:12,820 --> 00:37:16,240
any sort of code smell it doesn't

840
00:37:14,920 --> 00:37:17,650
necessarily to be vulnerabilities but

841
00:37:16,240 --> 00:37:19,529
the more time you're spending dealing

842
00:37:17,650 --> 00:37:22,599
with problems rather than actually

843
00:37:19,530 --> 00:37:24,190
working on developing new features or

844
00:37:22,599 --> 00:37:27,010
stuff like that that's a good indicator

845
00:37:24,190 --> 00:37:28,210
that you're due for a refactoring so the

846
00:37:27,010 --> 00:37:30,849
more vulnerable like if you're spending

847
00:37:28,210 --> 00:37:32,560
50 60 % of your time just addressing

848
00:37:30,849 --> 00:37:34,780
vulnerability reports as they're coming

849
00:37:32,560 --> 00:37:37,060
in constantly then you've probably got a

850
00:37:34,780 --> 00:37:39,210
big problem that you need to fix I would

851
00:37:37,060 --> 00:37:39,210
say

852
00:37:44,740 --> 00:37:48,310
cool all right well I'll be around for

853
00:37:46,750 --> 00:37:50,520
the whole weekends or if you have any

854
00:37:48,310 --> 00:37:53,880
more questions feel free to come find me

855
00:37:50,520 --> 00:37:53,880
yeah thank you

856
00:38:19,640 --> 00:38:21,700
you

