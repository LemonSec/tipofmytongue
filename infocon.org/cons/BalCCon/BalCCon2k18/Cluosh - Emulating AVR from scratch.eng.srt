1
00:00:00,000 --> 00:00:12,130
[Music]

2
00:00:11,270 --> 00:00:14,899
[Applause]

3
00:00:12,130 --> 00:00:18,840
[Music]

4
00:00:14,900 --> 00:00:29,250
now<font color="#CCCCCC"> hush</font><font color="#E5E5E5"> will we'll talk about emulating</font>

5
00:00:18,840 --> 00:00:31,859
<font color="#CCCCCC">AVR from scratch thank you so hi I'm</font>

6
00:00:29,250 --> 00:00:33,899
<font color="#CCCCCC">Chloe</font><font color="#E5E5E5"> and today I'm gonna talk a bit</font>

7
00:00:31,859 --> 00:00:37,230
<font color="#E5E5E5">about emulating AVR and the AVR</font>

8
00:00:33,899 --> 00:00:39,390
architecture in<font color="#CCCCCC"> general after some</font>

9
00:00:37,230 --> 00:00:42,260
technical issues<font color="#E5E5E5"> the presentation looks</font>

10
00:00:39,390 --> 00:00:45,210
like this but I think<font color="#E5E5E5"> this will work out</font>

11
00:00:42,260 --> 00:00:47,339
I'm a student at Vienna University<font color="#E5E5E5"> of</font>

12
00:00:45,210 --> 00:00:49,890
Technology<font color="#E5E5E5"> currently studying software</font>

13
00:00:47,340 --> 00:00:52,620
<font color="#E5E5E5">engineering</font><font color="#CCCCCC"> you can find me on Twitter</font>

14
00:00:49,890 --> 00:00:55,079
and mastodons and I'm a member of the<font color="#CCCCCC"> vo</font>

15
00:00:52,620 --> 00:00:57,690
<font color="#E5E5E5">new CTF team which is probably the</font>

16
00:00:55,079 --> 00:01:01,530
<font color="#CCCCCC">reason this presentation is happening at</font>

17
00:00:57,690 --> 00:01:06,090
all<font color="#CCCCCC"> what are we going</font><font color="#E5E5E5"> to talk about</font>

18
00:01:01,530 --> 00:01:09,810
we're going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> talk about</font><font color="#E5E5E5"> AVR AVR</font><font color="#CCCCCC"> is a</font>

19
00:01:06,090 --> 00:01:15,150
microcontroller architecture<font color="#CCCCCC"> probably</font>

20
00:01:09,810 --> 00:01:16,950
most known for the<font color="#E5E5E5"> Arduino</font><font color="#CCCCCC"> and it's a</font>

21
00:01:15,150 --> 00:01:19,350
<font color="#E5E5E5">popular 8-bit microcontroller</font>

22
00:01:16,950 --> 00:01:22,710
<font color="#E5E5E5">architecture</font><font color="#CCCCCC"> in general you can find it</font>

23
00:01:19,350 --> 00:01:25,679
in cars in keys everywhere<font color="#E5E5E5"> it's cheap</font>

24
00:01:22,710 --> 00:01:31,439
and it's efficient<font color="#CCCCCC"> and it's easy</font><font color="#E5E5E5"> to</font>

25
00:01:25,680 --> 00:01:36,540
learn so how did I<font color="#CCCCCC"> come up with the idea</font>

26
00:01:31,439 --> 00:01:38,369
of<font color="#E5E5E5"> writing an AVR emulator anyways it</font>

27
00:01:36,540 --> 00:01:42,560
started<font color="#E5E5E5"> with participating in the our</font>

28
00:01:38,369 --> 00:01:46,829
<font color="#E5E5E5">HMI CTF which is an embedded CTF</font>

29
00:01:42,560 --> 00:01:50,579
<font color="#E5E5E5">designed to simulate the embedded system</font>

30
00:01:46,829 --> 00:01:53,329
in a car<font color="#E5E5E5"> and after the qualification</font>

31
00:01:50,579 --> 00:01:58,008
period<font color="#E5E5E5"> they would</font><font color="#CCCCCC"> send you an AVR</font><font color="#E5E5E5"> board</font>

32
00:01:53,329 --> 00:02:02,880
customly designed with a can bus module

33
00:01:58,009 --> 00:02:04,710
<font color="#E5E5E5">and this was the main CTF challenge so</font>

34
00:02:02,880 --> 00:02:07,408
there were quite a few reversing

35
00:02:04,710 --> 00:02:08,940
challenges other than the reversing

36
00:02:07,409 --> 00:02:10,879
<font color="#E5E5E5">channel challenges he could not read the</font>

37
00:02:08,940 --> 00:02:14,010
phone work as the firmware<font color="#E5E5E5"> was</font><font color="#CCCCCC"> encrypted</font>

38
00:02:10,878 --> 00:02:15,359
and<font color="#E5E5E5"> I just started statically analyzing</font>

39
00:02:14,010 --> 00:02:18,120
the firm<font color="#E5E5E5"> we're just looking at the</font>

40
00:02:15,360 --> 00:02:19,680
disassembly<font color="#CCCCCC"> and I thought</font><font color="#E5E5E5"> okay maybe it</font>

41
00:02:18,120 --> 00:02:26,519
would<font color="#CCCCCC"> be</font><font color="#E5E5E5"> nice</font><font color="#CCCCCC"> if I could execute this</font>

42
00:02:19,680 --> 00:02:29,099
and see what<font color="#E5E5E5"> it does so I was</font><font color="#CCCCCC"> looking</font>

43
00:02:26,519 --> 00:02:31,200
for existing emulators<font color="#CCCCCC"> that would help</font>

44
00:02:29,099 --> 00:02:36,690
me find out what I wanted to<font color="#E5E5E5"> find out</font>

45
00:02:31,200 --> 00:02:38,399
namely what is the what<font color="#CCCCCC"> is the software</font>

46
00:02:36,690 --> 00:02:42,930
doing<font color="#E5E5E5"> what is it sending on the uart</font>

47
00:02:38,400 --> 00:02:47,760
port<font color="#E5E5E5"> and I was looking at mainly free</font>

48
00:02:42,930 --> 00:02:50,880
<font color="#E5E5E5">emulators before</font><font color="#CCCCCC"> net I saw similar AVR I</font>

49
00:02:47,760 --> 00:02:54,690
saw similar VR and I saw<font color="#CCCCCC"> Atmos</font><font color="#E5E5E5"> -</font><font color="#CCCCCC"> DME</font>

50
00:02:50,880 --> 00:02:57,390
<font color="#E5E5E5">later</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> admins to the emulator was did</font>

51
00:02:54,690 --> 00:03:00,180
not<font color="#CCCCCC"> do what I wanted it to do</font><font color="#E5E5E5"> because I</font>

52
00:02:57,390 --> 00:03:02,190
<font color="#E5E5E5">could not load a firmware image without</font>

53
00:03:00,180 --> 00:03:04,709
<font color="#E5E5E5">any symbols into it and just run it I</font>

54
00:03:02,190 --> 00:03:07,349
just<font color="#E5E5E5"> couldn't get it to run it should be</font>

55
00:03:04,709 --> 00:03:11,040
theoretically possible<font color="#E5E5E5"> to give it an elf</font>

56
00:03:07,349 --> 00:03:13,859
binary with symbols but it didn't<font color="#CCCCCC"> work</font>

57
00:03:11,040 --> 00:03:17,819
out<font color="#E5E5E5"> so there were simulaid are and see</font>

58
00:03:13,860 --> 00:03:19,920
<font color="#E5E5E5">maybe R and C maybe</font><font color="#CCCCCC"> are had more AVR</font>

59
00:03:17,819 --> 00:03:24,060
cores implemented<font color="#E5E5E5"> so I chose to go with</font>

60
00:03:19,920 --> 00:03:26,130
C<font color="#CCCCCC"> maybe R and I looked at the Summa VR</font>

61
00:03:24,060 --> 00:03:30,480
repository and figured<font color="#E5E5E5"> out I</font><font color="#CCCCCC"> had no idea</font>

62
00:03:26,130 --> 00:03:35,489
<font color="#E5E5E5">what I was</font><font color="#CCCCCC"> doing because unlike usual</font>

63
00:03:30,480 --> 00:03:36,090
<font color="#E5E5E5">emulators or debuggers</font><font color="#CCCCCC"> CA VR is somewhat</font>

64
00:03:35,489 --> 00:03:38,040
hackable

65
00:03:36,090 --> 00:03:40,650
this means you<font color="#E5E5E5"> eff have to actually</font>

66
00:03:38,040 --> 00:03:43,888
write<font color="#CCCCCC"> code to</font><font color="#E5E5E5"> get it running</font><font color="#CCCCCC"> but I</font>

67
00:03:40,650 --> 00:03:45,150
didn't understand what I needed to do

68
00:03:43,889 --> 00:03:47,780
because<font color="#E5E5E5"> I didn't understand the</font>

69
00:03:45,150 --> 00:03:47,780
underlying architecture

70
00:03:51,920 --> 00:04:00,799
so to get around<font color="#E5E5E5"> that I just decided to</font>

71
00:03:56,959 --> 00:04:03,770
write<font color="#E5E5E5"> my</font><font color="#CCCCCC"> own</font><font color="#E5E5E5"> emulator mainly to</font>

72
00:04:00,800 --> 00:04:05,690
understand what is<font color="#E5E5E5"> happening in Seema VR</font>

73
00:04:03,770 --> 00:04:09,320
<font color="#E5E5E5">and what is happening in the underlying</font>

74
00:04:05,690 --> 00:04:11,840
AVR<font color="#E5E5E5"> architecture</font><font color="#CCCCCC"> I also wanted to make</font>

75
00:04:09,320 --> 00:04:14,930
<font color="#E5E5E5">it somewhat simple to use with a</font>

76
00:04:11,840 --> 00:04:16,459
<font color="#E5E5E5">graphical interface because I'm more the</font>

77
00:04:14,930 --> 00:04:22,060
visual type I like working<font color="#CCCCCC"> with visual</font>

78
00:04:16,459 --> 00:04:25,240
<font color="#E5E5E5">tools and I just wanted to run a binary</font>

79
00:04:22,060 --> 00:04:29,030
<font color="#CCCCCC">firmware binary and see what it</font><font color="#E5E5E5"> does and</font>

80
00:04:25,240 --> 00:04:35,180
<font color="#CCCCCC">that was</font><font color="#E5E5E5"> a the</font><font color="#CCCCCC"> perfor of a VRS</font><font color="#E5E5E5"> which is</font>

81
00:04:29,030 --> 00:04:36,919
my bird feeder so<font color="#E5E5E5"> I'm roughly going to</font>

82
00:04:35,180 --> 00:04:38,590
talk about<font color="#E5E5E5"> four points</font><font color="#CCCCCC"> I'm going to talk</font>

83
00:04:36,919 --> 00:04:40,729
<font color="#E5E5E5">about the general architecture or</font>

84
00:04:38,590 --> 00:04:45,200
architecture which which stays the same

85
00:04:40,730 --> 00:04:48,530
across AVR course I'm gonna talk<font color="#E5E5E5"> about</font>

86
00:04:45,200 --> 00:04:50,960
how<font color="#E5E5E5"> to emulate the basic stuff and I'm</font>

87
00:04:48,530 --> 00:04:53,659
<font color="#E5E5E5">going to talk</font><font color="#CCCCCC"> about how to</font><font color="#E5E5E5"> emulate</font>

88
00:04:50,960 --> 00:04:59,870
peripherals<font color="#E5E5E5"> and then I'm gonna show</font><font color="#CCCCCC"> off</font>

89
00:04:53,660 --> 00:05:05,150
the emulator as it exists<font color="#CCCCCC"> now so let's</font>

90
00:04:59,870 --> 00:05:09,310
talk about<font color="#E5E5E5"> the</font><font color="#CCCCCC"> architecture</font><font color="#E5E5E5"> when we say</font>

91
00:05:05,150 --> 00:05:13,429
AVR ik architecture<font color="#E5E5E5"> we mean something</font>

92
00:05:09,310 --> 00:05:15,770
<font color="#CCCCCC">vague because</font><font color="#E5E5E5"> there are a lot of device</font>

93
00:05:13,430 --> 00:05:18,650
specific differences across all the

94
00:05:15,770 --> 00:05:21,640
existing AVR course if you write

95
00:05:18,650 --> 00:05:28,460
software for one AVR core you<font color="#CCCCCC"> can just</font>

96
00:05:21,640 --> 00:05:30,349
run it<font color="#CCCCCC"> on</font><font color="#E5E5E5"> any other other AVR core but</font>

97
00:05:28,460 --> 00:05:33,140
there are things<font color="#CCCCCC"> to stay same</font><font color="#E5E5E5"> across</font><font color="#CCCCCC"> the</font>

98
00:05:30,350 --> 00:05:36,020
architecture which is<font color="#E5E5E5"> that we have a</font>

99
00:05:33,140 --> 00:05:38,930
<font color="#E5E5E5">Harvard architecture so the program</font>

100
00:05:36,020 --> 00:05:41,090
memory<font color="#E5E5E5"> and the actual</font><font color="#CCCCCC"> RAM or working</font>

101
00:05:38,930 --> 00:05:43,550
<font color="#CCCCCC">memory is completely separate this means</font>

102
00:05:41,090 --> 00:05:46,460
you can just<font color="#E5E5E5"> write code into the RAM and</font>

103
00:05:43,550 --> 00:05:49,340
execute<font color="#E5E5E5"> it from there</font><font color="#CCCCCC"> you'll have to</font>

104
00:05:46,460 --> 00:05:53,060
flash your<font color="#E5E5E5"> code or into the flash memory</font>

105
00:05:49,340 --> 00:05:55,580
<font color="#E5E5E5">and it will be executed from there</font><font color="#CCCCCC"> the</font>

106
00:05:53,060 --> 00:05:59,270
flash<font color="#CCCCCC"> memory is usually</font><font color="#E5E5E5"> bigger than the</font>

107
00:05:55,580 --> 00:06:01,669
SRAM because it's cheaper and<font color="#CCCCCC"> it has</font>

108
00:05:59,270 --> 00:06:04,760
limited write cycles you so you can just

109
00:06:01,669 --> 00:06:08,870
<font color="#E5E5E5">go ahead and</font><font color="#CCCCCC"> modify</font>

110
00:06:04,760 --> 00:06:11,780
the firmware while<font color="#E5E5E5"> it's running</font><font color="#CCCCCC"> as much</font>

111
00:06:08,870 --> 00:06:15,370
<font color="#E5E5E5">as you want</font><font color="#CCCCCC"> because</font><font color="#E5E5E5"> sometimes you won't</font>

112
00:06:11,780 --> 00:06:15,369
<font color="#E5E5E5">have the</font><font color="#CCCCCC"> ability to write there anymore</font>

113
00:06:16,840 --> 00:06:23,000
<font color="#E5E5E5">yeah you usually have some</font><font color="#CCCCCC"> kind of</font>

114
00:06:19,700 --> 00:06:25,820
EEPROM<font color="#E5E5E5"> on the AVR board because you want</font>

115
00:06:23,000 --> 00:06:28,730
to persist some data across across

116
00:06:25,820 --> 00:06:32,360
reboots or resets<font color="#CCCCCC"> for example if you</font>

117
00:06:28,730 --> 00:06:37,910
have a car key you might want<font color="#E5E5E5"> to store</font>

118
00:06:32,360 --> 00:06:39,500
the nonce<font color="#E5E5E5"> of the key in the EEPROM</font><font color="#CCCCCC"> you</font>

119
00:06:37,910 --> 00:06:44,240
also have different<font color="#CCCCCC"> memory layouts per</font>

120
00:06:39,500 --> 00:06:48,040
device which is mainly on<font color="#E5E5E5"> the on the</font>

121
00:06:44,240 --> 00:06:51,860
SRAM side the<font color="#E5E5E5"> the program memory layout</font>

122
00:06:48,040 --> 00:06:55,330
stays<font color="#E5E5E5"> usually the same with a</font><font color="#CCCCCC"> few</font>

123
00:06:51,860 --> 00:06:57,710
differences<font color="#E5E5E5"> so the program memory</font>

124
00:06:55,330 --> 00:07:02,060
consists of the application section<font color="#E5E5E5"> and</font>

125
00:06:57,710 --> 00:07:04,669
if your AVR<font color="#E5E5E5"> CPU supports it</font><font color="#CCCCCC"> you will</font>

126
00:07:02,060 --> 00:07:07,540
<font color="#CCCCCC">also</font><font color="#E5E5E5"> have a boot flash section where</font>

127
00:07:04,670 --> 00:07:12,680
this boot flash section ends<font color="#E5E5E5"> and starts</font>

128
00:07:07,540 --> 00:07:14,600
can be defined with<font color="#E5E5E5"> fuses also if it can</font>

129
00:07:12,680 --> 00:07:17,150
write and which section section can

130
00:07:14,600 --> 00:07:18,710
write to<font color="#E5E5E5"> the flash memory because you</font>

131
00:07:17,150 --> 00:07:23,000
have a<font color="#CCCCCC"> specific instruction</font><font color="#E5E5E5"> which can</font>

132
00:07:18,710 --> 00:07:25,430
write to<font color="#E5E5E5"> the flash memory</font><font color="#CCCCCC"> but if you</font>

133
00:07:23,000 --> 00:07:27,860
have<font color="#CCCCCC"> permission settings protective bits</font>

134
00:07:25,430 --> 00:07:29,990
for the sections you'll have to<font color="#E5E5E5"> enable</font>

135
00:07:27,860 --> 00:07:32,210
them in order<font color="#E5E5E5"> to be able to write there</font>

136
00:07:29,990 --> 00:07:35,870
because you might<font color="#CCCCCC"> not want to have a</font>

137
00:07:32,210 --> 00:07:38,000
firmware writing<font color="#E5E5E5"> to to the program</font>

138
00:07:35,870 --> 00:07:40,520
memory<font color="#E5E5E5"> all the time and waste your write</font>

139
00:07:38,000 --> 00:07:43,910
cycles but rather have it<font color="#E5E5E5"> to</font><font color="#CCCCCC"> buy the</font>

140
00:07:40,520 --> 00:07:46,849
boot to<font color="#CCCCCC"> it by</font><font color="#E5E5E5"> a bootloader and you can</font>

141
00:07:43,910 --> 00:07:49,460
do<font color="#CCCCCC"> the stuff</font><font color="#E5E5E5"> like encrypting or</font>

142
00:07:46,850 --> 00:07:51,020
decrypting parts of the firmware with

143
00:07:49,460 --> 00:07:55,789
the bootloader before you actually<font color="#CCCCCC"> run</font>

144
00:07:51,020 --> 00:07:58,580
it the data memory is more interesting

145
00:07:55,790 --> 00:08:03,970
<font color="#E5E5E5">because it doesn't only consist of yes</font>

146
00:07:58,580 --> 00:08:03,969
Ram but it<font color="#E5E5E5"> Maps a lot of stuff in there</font>

147
00:08:05,600 --> 00:08:10,800
things that are<font color="#E5E5E5"> in the data memory</font><font color="#CCCCCC"> on</font>

148
00:08:08,220 --> 00:08:13,290
almost all devices or on<font color="#E5E5E5"> all devices are</font>

149
00:08:10,800 --> 00:08:17,430
I<font color="#E5E5E5"> already stirs which enables</font>

150
00:08:13,290 --> 00:08:21,540
communication with peripherals<font color="#E5E5E5"> and some</font>

151
00:08:17,430 --> 00:08:25,290
kind of SRAM<font color="#E5E5E5"> everything else is usually</font>

152
00:08:21,540 --> 00:08:27,389
<font color="#E5E5E5">not fixed so you might have the first</font><font color="#CCCCCC"> 32</font>

153
00:08:25,290 --> 00:08:30,300
registers in there you might not<font color="#E5E5E5"> have</font>

154
00:08:27,389 --> 00:08:34,820
them in there on a<font color="#CCCCCC"> VXR mega</font><font color="#E5E5E5"> you have</font>

155
00:08:30,300 --> 00:08:37,409
EEPROM mapped into the data memory<font color="#E5E5E5"> and</font>

156
00:08:34,820 --> 00:08:39,270
the different<font color="#CCCCCC"> sections of memory behave</font>

157
00:08:37,409 --> 00:08:42,000
differently<font color="#E5E5E5"> because if you want to</font>

158
00:08:39,270 --> 00:08:46,170
access registers accessing registers is

159
00:08:42,000 --> 00:08:48,930
cheap accessing<font color="#E5E5E5"> I or adjuster</font><font color="#CCCCCC"> comes with</font>

160
00:08:46,170 --> 00:08:50,520
<font color="#E5E5E5">side</font><font color="#CCCCCC"> effects meaning if you write to and</font>

161
00:08:48,930 --> 00:08:52,290
I already<font color="#E5E5E5"> stir you'll trigger some side</font>

162
00:08:50,520 --> 00:08:54,270
effects<font color="#E5E5E5"> and if you read from an</font><font color="#CCCCCC"> our</font>

163
00:08:52,290 --> 00:08:55,770
register<font color="#CCCCCC"> you're not gonna get the same</font>

164
00:08:54,270 --> 00:08:59,100
result<font color="#E5E5E5"> or not always going to get the</font>

165
00:08:55,770 --> 00:09:01,079
same result back and then you'll have

166
00:08:59,100 --> 00:09:08,550
the SRAM<font color="#CCCCCC"> which behaves</font><font color="#E5E5E5"> as we would</font>

167
00:09:01,080 --> 00:09:11,970
expect memory to behave what<font color="#E5E5E5"> else is</font>

168
00:09:08,550 --> 00:09:16,040
there you'll<font color="#E5E5E5"> have interrupts interrupts</font>

169
00:09:11,970 --> 00:09:19,170
are used for<font color="#E5E5E5"> communication with devices</font>

170
00:09:16,040 --> 00:09:22,189
<font color="#CCCCCC">mainly in situations when you don't want</font>

171
00:09:19,170 --> 00:09:25,800
to waste program<font color="#CCCCCC"> processor cycles</font>

172
00:09:22,190 --> 00:09:29,790
<font color="#E5E5E5">waiting on some event to</font><font color="#CCCCCC"> happen</font><font color="#E5E5E5"> this way</font>

173
00:09:25,800 --> 00:09:32,430
you can for<font color="#CCCCCC"> example put you put your AVR</font>

174
00:09:29,790 --> 00:09:36,060
CPU into sleep mode and<font color="#E5E5E5"> just wait for</font><font color="#CCCCCC"> an</font>

175
00:09:32,430 --> 00:09:37,739
UART interrupt to happen<font color="#CCCCCC"> signalling okay</font>

176
00:09:36,060 --> 00:09:43,290
<font color="#E5E5E5">you've got some data there you can now</font>

177
00:09:37,740 --> 00:09:46,140
read it you<font color="#E5E5E5"> can also do timing stuff for</font>

178
00:09:43,290 --> 00:09:48,959
example<font color="#CCCCCC"> trigger timing interrupts every</font>

179
00:09:46,140 --> 00:09:51,140
other second<font color="#E5E5E5"> and perform some actions</font>

180
00:09:48,959 --> 00:09:51,140
there

181
00:09:52,470 --> 00:09:58,650
then there's the<font color="#E5E5E5"> instruction</font><font color="#CCCCCC"> set which</font>

182
00:09:54,540 --> 00:10:01,170
stays mostly<font color="#E5E5E5"> the</font><font color="#CCCCCC"> same across course</font><font color="#E5E5E5"> for</font>

183
00:09:58,650 --> 00:10:05,370
the instruction<font color="#E5E5E5"> sets you have to think</font>

184
00:10:01,170 --> 00:10:07,860
of the<font color="#E5E5E5"> program memory an instruction is</font>

185
00:10:05,370 --> 00:10:11,550
to<font color="#E5E5E5"> byte long and this is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> word size</font>

186
00:10:07,860 --> 00:10:14,250
for instructions then you have registers

187
00:10:11,550 --> 00:10:16,829
<font color="#E5E5E5">which store bytes each register can</font>

188
00:10:14,250 --> 00:10:19,790
store one bite and you have 32 of them

189
00:10:16,830 --> 00:10:23,730
and you<font color="#E5E5E5"> have point the register</font>

190
00:10:19,790 --> 00:10:26,819
registers which can access memory<font color="#E5E5E5"> with</font>

191
00:10:23,730 --> 00:10:28,080
<font color="#CCCCCC">two bytes again and the way those point</font>

192
00:10:26,820 --> 00:10:31,140
the registers work is<font color="#CCCCCC"> they're just</font>

193
00:10:28,080 --> 00:10:36,240
<font color="#E5E5E5">aliases</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> two other registers in this</font>

194
00:10:31,140 --> 00:10:39,740
case<font color="#CCCCCC"> the registers</font><font color="#E5E5E5"> from 27 to 31</font><font color="#CCCCCC"> which</font>

195
00:10:36,240 --> 00:10:48,420
will be addressed<font color="#CCCCCC"> as X Y or Z in</font>

196
00:10:39,740 --> 00:10:51,420
disassembly<font color="#CCCCCC"> this is a piece from for my</font>

197
00:10:48,420 --> 00:10:53,880
binary and here we can see a few<font color="#CCCCCC"> things</font>

198
00:10:51,420 --> 00:10:55,829
about the instruction set on the left

199
00:10:53,880 --> 00:10:58,400
side you can<font color="#CCCCCC"> see the actual bytes</font><font color="#E5E5E5"> in</font>

200
00:10:55,830 --> 00:11:01,140
instruction from the instruction stream

201
00:10:58,400 --> 00:11:03,750
<font color="#E5E5E5">and you might note I said instructions</font>

202
00:11:01,140 --> 00:11:06,840
are<font color="#CCCCCC"> 2 bytes but it's actually a variable</font>

203
00:11:03,750 --> 00:11:08,370
<font color="#E5E5E5">length instruction set you can have one</font>

204
00:11:06,840 --> 00:11:12,870
word instructions or two word

205
00:11:08,370 --> 00:11:15,570
instructions<font color="#CCCCCC"> the two word instructions</font>

206
00:11:12,870 --> 00:11:17,520
are rare<font color="#CCCCCC"> you have four four of them you</font>

207
00:11:15,570 --> 00:11:20,790
<font color="#CCCCCC">have a long jump you have a long call</font>

208
00:11:17,520 --> 00:11:27,390
<font color="#E5E5E5">and you have store two data memory</font><font color="#CCCCCC"> and</font>

209
00:11:20,790 --> 00:11:29,370
store and<font color="#E5E5E5"> load from data memory because</font>

210
00:11:27,390 --> 00:11:31,949
of the two word<font color="#E5E5E5"> instruction size and the</font>

211
00:11:29,370 --> 00:11:34,680
addressing<font color="#E5E5E5"> working with</font><font color="#CCCCCC"> a word size in</font>

212
00:11:31,950 --> 00:11:36,720
program memory you can't jump in<font color="#E5E5E5"> the</font>

213
00:11:34,680 --> 00:11:40,650
<font color="#E5E5E5">middle of instruction like you can do on</font>

214
00:11:36,720 --> 00:11:44,100
x86<font color="#E5E5E5"> and just obfuscated but you can jump</font>

215
00:11:40,650 --> 00:11:46,530
<font color="#CCCCCC">in</font><font color="#E5E5E5"> do</font><font color="#CCCCCC"> into the middle of a long</font>

216
00:11:44,100 --> 00:11:50,630
instruction<font color="#E5E5E5"> so you could potentially</font>

217
00:11:46,530 --> 00:11:53,040
<font color="#E5E5E5">hide data in a call or in a jump which</font>

218
00:11:50,630 --> 00:11:54,570
you might<font color="#CCCCCC"> want to disassemble the</font><font color="#E5E5E5"> second</font>

219
00:11:53,040 --> 00:11:56,610
part of the instruction additionally so

220
00:11:54,570 --> 00:11:58,820
you can maybe see<font color="#CCCCCC"> if there's some data</font>

221
00:11:56,610 --> 00:11:58,820
head

222
00:12:00,600 --> 00:12:07,480
<font color="#CCCCCC">what else can</font><font color="#E5E5E5"> we see here we</font><font color="#CCCCCC"> see that we</font>

223
00:12:05,380 --> 00:12:08,710
<font color="#CCCCCC">have to load</font><font color="#E5E5E5"> memory into</font><font color="#CCCCCC"> the registers</font>

224
00:12:07,480 --> 00:12:11,350
first so we<font color="#E5E5E5"> have a load store</font>

225
00:12:08,710 --> 00:12:13,420
instruction<font color="#E5E5E5"> we can't just address memory</font>

226
00:12:11,350 --> 00:12:16,120
with every<font color="#E5E5E5"> instruction we have like on</font>

227
00:12:13,420 --> 00:12:18,430
x86<font color="#E5E5E5"> we'll have to actually load</font><font color="#CCCCCC"> it into</font>

228
00:12:16,120 --> 00:12:20,820
read into the registers<font color="#E5E5E5"> work with it and</font>

229
00:12:18,430 --> 00:12:23,680
<font color="#E5E5E5">then store</font><font color="#CCCCCC"> it back</font><font color="#E5E5E5"> to the registers</font>

230
00:12:20,820 --> 00:12:28,030
<font color="#E5E5E5">which makes it relatively</font><font color="#CCCCCC"> simple to</font>

231
00:12:23,680 --> 00:12:30,370
<font color="#CCCCCC">Emily</font><font color="#E5E5E5"> emulate later on</font><font color="#CCCCCC"> since we have</font>

232
00:12:28,030 --> 00:12:33,939
those pointer registers which work with

233
00:12:30,370 --> 00:12:36,580
words<font color="#E5E5E5"> instead of bytes we also have some</font>

234
00:12:33,940 --> 00:12:39,190
instructions working on words are

235
00:12:36,580 --> 00:12:41,800
working on pairs of registers in general

236
00:12:39,190 --> 00:12:49,570
this allows<font color="#CCCCCC"> us</font><font color="#E5E5E5"> to efficiently work with</font>

237
00:12:41,800 --> 00:12:52,120
the pointer registers and additional to

238
00:12:49,570 --> 00:12:55,870
the long call and<font color="#CCCCCC"> the long jump</font><font color="#E5E5E5"> we have</font>

239
00:12:52,120 --> 00:12:58,810
relative jumps and relative<font color="#E5E5E5"> calls which</font>

240
00:12:55,870 --> 00:13:01,360
if you have a device with program memory

241
00:12:58,810 --> 00:13:05,020
memory less than 8<font color="#E5E5E5"> kilobyte</font><font color="#CCCCCC"> you can use</font>

242
00:13:01,360 --> 00:13:08,160
to<font color="#E5E5E5"> access all the locations in the</font>

243
00:13:05,020 --> 00:13:10,750
program<font color="#CCCCCC"> memory without</font><font color="#E5E5E5"> using</font><font color="#CCCCCC"> long calls</font>

244
00:13:08,160 --> 00:13:16,180
then those devices<font color="#CCCCCC"> usually won't have</font>

245
00:13:10,750 --> 00:13:19,920
the long call<font color="#CCCCCC"> instruction anyway so how</font>

246
00:13:16,180 --> 00:13:19,920
<font color="#CCCCCC">would we</font><font color="#E5E5E5"> go about emulating this now</font>

247
00:13:25,760 --> 00:13:30,020
first we'll<font color="#E5E5E5"> have</font><font color="#CCCCCC"> to look at the</font>

248
00:13:27,200 --> 00:13:31,520
instruction stream and<font color="#E5E5E5"> decode the</font>

249
00:13:30,020 --> 00:13:35,990
external instruction to find out what

250
00:13:31,520 --> 00:13:40,360
it's<font color="#CCCCCC"> doing the easiest way for</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> to</font>

251
00:13:35,990 --> 00:13:42,800
work is<font color="#E5E5E5"> to have a table or more tables</font>

252
00:13:40,360 --> 00:13:45,530
<font color="#E5E5E5">where you can just look up the high byte</font>

253
00:13:42,800 --> 00:13:47,660
and look up the low byte so you'll use

254
00:13:45,530 --> 00:13:51,470
the first<font color="#CCCCCC"> table</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> look up the general</font>

255
00:13:47,660 --> 00:13:53,449
<font color="#E5E5E5">area of what kind of type the</font>

256
00:13:51,470 --> 00:13:56,120
instruction is and then you'll use<font color="#E5E5E5"> the</font>

257
00:13:53,450 --> 00:14:00,440
second table to<font color="#E5E5E5"> actually decode the</font>

258
00:13:56,120 --> 00:14:03,800
instruction<font color="#CCCCCC"> this is a pretty neat way</font>

259
00:14:00,440 --> 00:14:07,670
because if you just decode it in table

260
00:14:03,800 --> 00:14:09,439
format<font color="#E5E5E5"> you'll easily find out if you</font>

261
00:14:07,670 --> 00:14:10,880
<font color="#E5E5E5">missed an instruction or if you have an</font>

262
00:14:09,440 --> 00:14:14,990
<font color="#CCCCCC">arrow</font><font color="#E5E5E5"> somewhere in your instruction</font>

263
00:14:10,880 --> 00:14:21,470
decode up<font color="#CCCCCC"> what does</font><font color="#E5E5E5"> the table</font><font color="#CCCCCC"> actually</font>

264
00:14:14,990 --> 00:14:23,210
<font color="#E5E5E5">do for us now if we look at this</font><font color="#CCCCCC"> for</font>

265
00:14:21,470 --> 00:14:24,740
<font color="#CCCCCC">example if we look</font><font color="#E5E5E5"> up an instruction in</font>

266
00:14:23,210 --> 00:14:28,340
the instruction manual we'll get this

267
00:14:24,740 --> 00:14:30,470
bit set and we<font color="#CCCCCC"> can apply this to the</font>

268
00:14:28,340 --> 00:14:34,610
instruction stream so we have<font color="#E5E5E5"> two bytes</font>

269
00:14:30,470 --> 00:14:37,790
here from the instruction stream<font color="#CCCCCC"> the</font>

270
00:14:34,610 --> 00:14:41,540
instructions are read as words and the

271
00:14:37,790 --> 00:14:44,060
words are read as interpreted as<font color="#CCCCCC"> little</font>

272
00:14:41,540 --> 00:14:48,160
<font color="#CCCCCC">endian</font><font color="#E5E5E5"> so even though these are</font><font color="#CCCCCC"> a high</font>

273
00:14:44,060 --> 00:14:52,609
<font color="#CCCCCC">four bits the those aren't the</font><font color="#E5E5E5"> first</font>

274
00:14:48,160 --> 00:14:55,010
four bits and the instruction stream so

275
00:14:52,610 --> 00:14:57,920
we can see on the<font color="#E5E5E5"> first of on the high</font>

276
00:14:55,010 --> 00:15:00,410
<font color="#E5E5E5">four bits that those that this is a load</font>

277
00:14:57,920 --> 00:15:05,660
immediate instruction and then we know

278
00:15:00,410 --> 00:15:09,010
the instruction has to<font color="#CCCCCC"> look like the</font>

279
00:15:05,660 --> 00:15:17,030
table here<font color="#CCCCCC"> so we'll have</font><font color="#E5E5E5"> some kind of</font>

280
00:15:09,010 --> 00:15:20,000
register<font color="#CCCCCC"> a lot of instruction use</font><font color="#E5E5E5"> four</font>

281
00:15:17,030 --> 00:15:23,089
bits<font color="#CCCCCC"> four registers</font><font color="#E5E5E5"> which means we can</font>

282
00:15:20,000 --> 00:15:25,430
<font color="#E5E5E5">only access sixteen registers and we'll</font>

283
00:15:23,090 --> 00:15:29,420
be accessing<font color="#E5E5E5"> the high</font><font color="#CCCCCC"> sixteen registers</font>

284
00:15:25,430 --> 00:15:31,699
so in<font color="#E5E5E5"> this case there</font><font color="#CCCCCC"> is a one in the</font>

285
00:15:29,420 --> 00:15:35,229
instruction stream which means we'll

286
00:15:31,700 --> 00:15:38,330
decode it to<font color="#E5E5E5"> register</font><font color="#CCCCCC"> seventeen because</font>

287
00:15:35,230 --> 00:15:39,890
we only have<font color="#E5E5E5"> four bits for decoding and</font>

288
00:15:38,330 --> 00:15:44,060
we'll have to<font color="#CCCCCC"> use the high regice</font>

289
00:15:39,890 --> 00:15:47,750
and then the rest<font color="#E5E5E5"> of the instruction</font><font color="#CCCCCC"> are</font>

290
00:15:44,060 --> 00:15:52,339
<font color="#CCCCCC">bites</font><font color="#E5E5E5"> is just the value we want</font><font color="#CCCCCC"> to load</font>

291
00:15:47,750 --> 00:15:57,080
into<font color="#E5E5E5"> the register</font><font color="#CCCCCC"> now simay</font><font color="#E5E5E5"> VR for</font>

292
00:15:52,340 --> 00:15:58,930
example<font color="#CCCCCC"> now has the decode and</font>

293
00:15:57,080 --> 00:16:01,730
instruction<font color="#E5E5E5"> and just emulates it</font><font color="#CCCCCC"> I</font>

294
00:15:58,930 --> 00:16:05,510
wanted<font color="#E5E5E5"> to store it in structure in some</font>

295
00:16:01,730 --> 00:16:08,180
kind of format<font color="#E5E5E5"> I could work with some</font>

296
00:16:05,510 --> 00:16:10,910
kind of immediate format<font color="#E5E5E5"> this is just a</font>

297
00:16:08,180 --> 00:16:13,760
rusty enumeration<font color="#CCCCCC"> which would</font><font color="#E5E5E5"> be</font>

298
00:16:10,910 --> 00:16:22,969
equivalent to<font color="#E5E5E5"> C to a C Union with a type</font>

299
00:16:13,760 --> 00:16:24,770
tag now when we<font color="#E5E5E5"> emulate it there's</font>

300
00:16:22,970 --> 00:16:27,050
<font color="#E5E5E5">really not much more</font><font color="#CCCCCC"> to do than doing</font>

301
00:16:24,770 --> 00:16:30,319
what's in<font color="#CCCCCC"> the instruction manual in this</font>

302
00:16:27,050 --> 00:16:33,109
case we'll load<font color="#CCCCCC"> the value into the</font>

303
00:16:30,320 --> 00:16:34,100
register memory of course there are

304
00:16:33,110 --> 00:16:37,600
<font color="#E5E5E5">instructions that</font><font color="#CCCCCC"> are a lot more</font>

305
00:16:34,100 --> 00:16:37,600
<font color="#CCCCCC">complicated like this to implement</font>

306
00:16:39,279 --> 00:16:47,120
<font color="#CCCCCC">you'll have to handle</font><font color="#E5E5E5"> a lot of bit</font>

307
00:16:41,960 --> 00:16:48,980
twiddling because most<font color="#CCCCCC"> are</font><font color="#E5E5E5"> arithmetic</font>

308
00:16:47,120 --> 00:16:52,339
instructions use a half carry<font color="#E5E5E5"> bits and</font>

309
00:16:48,980 --> 00:16:53,780
the carry bit<font color="#E5E5E5"> and on most computers you</font>

310
00:16:52,339 --> 00:16:59,030
can't directly access this information

311
00:16:53,780 --> 00:17:01,699
<font color="#E5E5E5">so you'll have to perform the bit the</font>

312
00:16:59,030 --> 00:17:06,579
bit combinations yourself to get<font color="#E5E5E5"> the</font>

313
00:17:01,700 --> 00:17:06,579
flags and set it in the status<font color="#CCCCCC"> register</font>

314
00:17:07,060 --> 00:17:11,329
another important<font color="#E5E5E5"> thing is depending</font><font color="#CCCCCC"> on</font>

315
00:17:09,679 --> 00:17:13,640
how much program<font color="#E5E5E5"> memory you have</font>

316
00:17:11,329 --> 00:17:15,678
available<font color="#E5E5E5"> the size of the program</font>

317
00:17:13,640 --> 00:17:18,079
<font color="#E5E5E5">counter changes this means</font><font color="#CCCCCC"> you'll</font><font color="#E5E5E5"> have</font>

318
00:17:15,679 --> 00:17:23,449
<font color="#CCCCCC">different behavior for stack</font>

319
00:17:18,079 --> 00:17:26,119
instructions like call and return<font color="#E5E5E5"> so if</font>

320
00:17:23,449 --> 00:17:28,270
it's enough<font color="#CCCCCC"> you</font><font color="#E5E5E5"> can use</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> bytes for</font>

321
00:17:26,119 --> 00:17:31,070
the program counter<font color="#E5E5E5"> but if you have a</font>

322
00:17:28,270 --> 00:17:33,889
<font color="#E5E5E5">lot of program memory</font><font color="#CCCCCC"> you'll have to use</font>

323
00:17:31,070 --> 00:17:37,428
free bytes<font color="#E5E5E5"> and you have to think of that</font>

324
00:17:33,890 --> 00:17:42,590
<font color="#E5E5E5">then you use a call or a return</font>

325
00:17:37,429 --> 00:17:44,679
instruction<font color="#E5E5E5"> also</font><font color="#CCCCCC"> we have different</font>

326
00:17:42,590 --> 00:17:47,600
<font color="#E5E5E5">instruction sets for different devices</font>

327
00:17:44,679 --> 00:17:50,480
which isn't that<font color="#E5E5E5"> much of</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> problem</font>

328
00:17:47,600 --> 00:17:51,980
because usually if you<font color="#E5E5E5"> have another</font>

329
00:17:50,480 --> 00:17:53,110
<font color="#E5E5E5">device it's just missing a few</font>

330
00:17:51,980 --> 00:17:55,570
instruction from the

331
00:17:53,110 --> 00:17:58,709
struction set and those simply won't<font color="#E5E5E5"> be</font>

332
00:17:55,570 --> 00:18:03,100
executed<font color="#CCCCCC"> but in the case</font><font color="#E5E5E5"> of an AVR tiny</font>

333
00:17:58,710 --> 00:18:06,220
in the AVR tiny<font color="#CCCCCC"> 10 a few instruction</font>

334
00:18:03,100 --> 00:18:08,678
have been removed<font color="#E5E5E5"> and at the place where</font>

335
00:18:06,220 --> 00:18:11,650
<font color="#E5E5E5">those instructions were in the opcode</font>

336
00:18:08,679 --> 00:18:14,410
space they have been added a few other

337
00:18:11,650 --> 00:18:19,929
instructions<font color="#E5E5E5"> so you'll have to make</font><font color="#CCCCCC"> some</font>

338
00:18:14,410 --> 00:18:22,600
kind<font color="#E5E5E5"> of exceptions for this and yeah</font><font color="#CCCCCC"> the</font>

339
00:18:19,929 --> 00:18:25,240
memory map since<font color="#E5E5E5"> you have to exist</font>

340
00:18:22,600 --> 00:18:28,750
<font color="#E5E5E5">access the status register for storing</font>

341
00:18:25,240 --> 00:18:31,830
some data during emulation<font color="#E5E5E5"> and the</font>

342
00:18:28,750 --> 00:18:36,090
status<font color="#E5E5E5"> rageous register is in</font><font color="#CCCCCC"> i/o space</font>

343
00:18:31,830 --> 00:18:38,370
<font color="#E5E5E5">you'll have to make sure to</font><font color="#CCCCCC"> know if</font><font color="#E5E5E5"> the</font>

344
00:18:36,090 --> 00:18:41,260
registers are memory mapped or not

345
00:18:38,370 --> 00:18:44,020
because the registers would<font color="#E5E5E5"> be the first</font>

346
00:18:41,260 --> 00:18:47,290
32 addresses in the memory space<font color="#E5E5E5"> if they</font>

347
00:18:44,020 --> 00:18:50,080
are mapped<font color="#E5E5E5"> and then is the i/o space but</font>

348
00:18:47,290 --> 00:18:54,760
if the registers are<font color="#E5E5E5"> missing the i/o</font>

349
00:18:50,080 --> 00:19:02,559
addresses shift by 32 so you'll<font color="#E5E5E5"> have to</font>

350
00:18:54,760 --> 00:19:05,160
<font color="#E5E5E5">take care</font><font color="#CCCCCC"> of that</font><font color="#E5E5E5"> to interrupt emulation</font>

351
00:19:02,559 --> 00:19:07,270
isn't too bad either

352
00:19:05,160 --> 00:19:09,309
<font color="#CCCCCC">since most of the stuff is handled</font><font color="#E5E5E5"> by</font>

353
00:19:07,270 --> 00:19:12,059
<font color="#E5E5E5">the interrupt handler itself you'll just</font>

354
00:19:09,309 --> 00:19:16,750
have to set the<font color="#E5E5E5"> program</font><font color="#CCCCCC"> counter to</font><font color="#E5E5E5"> the</font>

355
00:19:12,059 --> 00:19:18,940
address of<font color="#E5E5E5"> the interrupt vector only</font><font color="#CCCCCC"> if</font>

356
00:19:16,750 --> 00:19:20,590
the global<font color="#CCCCCC"> interrupt flag is set and if</font>

357
00:19:18,940 --> 00:19:23,549
the interrupt<font color="#E5E5E5"> is enabled in the</font>

358
00:19:20,590 --> 00:19:25,870
corresponding bit for the<font color="#E5E5E5"> interrupt</font>

359
00:19:23,549 --> 00:19:27,520
<font color="#CCCCCC">what's important</font><font color="#E5E5E5"> to note here</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> the</font>

360
00:19:25,870 --> 00:19:29,649
<font color="#E5E5E5">decree the interrupt</font><font color="#CCCCCC"> flag when entering</font>

361
00:19:27,520 --> 00:19:33,010
the<font color="#E5E5E5"> interrupt handler because if you</font>

362
00:19:29,650 --> 00:19:35,440
leave<font color="#E5E5E5"> it</font><font color="#CCCCCC"> on you'll get pretty</font><font color="#E5E5E5"> much a</font>

363
00:19:33,010 --> 00:19:37,450
stack overflow<font color="#CCCCCC"> because</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> interrupts</font>

364
00:19:35,440 --> 00:19:39,780
rule will trigger again immediately most

365
00:19:37,450 --> 00:19:39,780
probably

366
00:19:47,530 --> 00:19:51,360
<font color="#E5E5E5">you'll also need some</font><font color="#CCCCCC"> kind of logical</font>

367
00:19:49,330 --> 00:19:54,820
clock at least

368
00:19:51,360 --> 00:19:56,979
so most firmware will have some<font color="#E5E5E5"> kind of</font>

369
00:19:54,820 --> 00:19:59,049
<font color="#CCCCCC">timeout functionality</font><font color="#E5E5E5"> for example</font>

370
00:19:56,980 --> 00:20:02,620
triggering and<font color="#E5E5E5"> interrupt every</font>

371
00:19:59,049 --> 00:20:05,679
millisecond or so<font color="#CCCCCC"> so the processor needs</font>

372
00:20:02,620 --> 00:20:09,309
<font color="#CCCCCC">a concept</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> time</font><font color="#E5E5E5"> the easiest way to do</font>

373
00:20:05,679 --> 00:20:11,830
this<font color="#E5E5E5"> is just to assign</font><font color="#CCCCCC"> one</font><font color="#E5E5E5"> cycle to give</font>

374
00:20:09,309 --> 00:20:14,399
every instruction<font color="#E5E5E5"> and just use the count</font>

375
00:20:11,830 --> 00:20:14,399
as a clock

376
00:20:14,500 --> 00:20:19,480
this isn't<font color="#CCCCCC"> accurate because different</font>

377
00:20:17,110 --> 00:20:23,740
instructions take different cycles to

378
00:20:19,480 --> 00:20:26,559
execute<font color="#E5E5E5"> but it will do to just introduce</font>

379
00:20:23,740 --> 00:20:29,230
some concept<font color="#E5E5E5"> of time time and accuracy</font>

380
00:20:26,559 --> 00:20:35,590
<font color="#CCCCCC">usually isn't</font><font color="#E5E5E5"> that important for the use</font>

381
00:20:29,230 --> 00:20:38,080
case at least<font color="#E5E5E5"> one not for</font><font color="#CCCCCC"> mine where can</font>

382
00:20:35,590 --> 00:20:39,760
<font color="#CCCCCC">you find all</font><font color="#E5E5E5"> this information usually</font>

383
00:20:38,080 --> 00:20:43,000
<font color="#CCCCCC">you</font><font color="#E5E5E5"> just</font><font color="#CCCCCC"> have to look up look it up in a</font>

384
00:20:39,760 --> 00:20:45,789
<font color="#E5E5E5">datasheet if you know I want to go ahead</font>

385
00:20:43,000 --> 00:20:47,669
and<font color="#CCCCCC"> implement all the AVR course reading</font>

386
00:20:45,789 --> 00:20:51,760
the<font color="#E5E5E5"> data sheets is a bit bothersome</font><font color="#CCCCCC"> and</font>

387
00:20:47,669 --> 00:20:52,990
you can put pull most of<font color="#CCCCCC"> the information</font>

388
00:20:51,760 --> 00:20:56,500
that's on the<font color="#E5E5E5"> datasheet and</font><font color="#CCCCCC"> that's</font>

389
00:20:52,990 --> 00:21:00,490
important<font color="#E5E5E5"> for you out of</font><font color="#CCCCCC"> so-called tech</font>

390
00:20:56,500 --> 00:21:02,559
files from<font color="#CCCCCC"> Atmel</font><font color="#E5E5E5"> which are just XML</font>

391
00:21:00,490 --> 00:21:11,289
descriptions of what<font color="#E5E5E5"> would other</font><font color="#CCCCCC"> PI</font>

392
00:21:02,559 --> 00:21:14,139
<font color="#E5E5E5">otherwise be listed in the datasheet now</font>

393
00:21:11,289 --> 00:21:16,990
you can't do much with the instruction

394
00:21:14,140 --> 00:21:18,580
set alone<font color="#CCCCCC"> if you implemented all</font>

395
00:21:16,990 --> 00:21:21,400
instructions<font color="#CCCCCC"> as</font><font color="#E5E5E5"> in the instruction</font>

396
00:21:18,580 --> 00:21:25,000
manual<font color="#CCCCCC"> you'll still</font><font color="#E5E5E5"> need some way</font><font color="#CCCCCC"> to</font>

397
00:21:21,400 --> 00:21:27,460
<font color="#CCCCCC">communicate</font><font color="#E5E5E5"> with the outside world or to</font>

398
00:21:25,000 --> 00:21:31,000
perform<font color="#CCCCCC"> some operation that is too</font>

399
00:21:27,460 --> 00:21:33,700
complex to<font color="#CCCCCC"> be too complex to be included</font>

400
00:21:31,000 --> 00:21:39,159
in the instruction set<font color="#CCCCCC"> for example</font>

401
00:21:33,700 --> 00:21:43,380
setting<font color="#E5E5E5"> some processor settings or</font><font color="#CCCCCC"> the</font>

402
00:21:39,159 --> 00:21:47,160
watchdog timer and

403
00:21:43,380 --> 00:21:49,710
for the sake of simplicity<font color="#E5E5E5"> I'll just</font>

404
00:21:47,160 --> 00:21:52,500
treat all those devices<font color="#E5E5E5"> the same</font>

405
00:21:49,710 --> 00:21:54,000
regarding whether it's a device<font color="#CCCCCC"> that</font>

406
00:21:52,500 --> 00:21:57,600
actually<font color="#E5E5E5"> communicates with the outside</font>

407
00:21:54,000 --> 00:21:59,850
world<font color="#E5E5E5"> or whether it's actually some</font>

408
00:21:57,600 --> 00:22:04,049
process<font color="#E5E5E5"> or setting that never leaves the</font>

409
00:21:59,850 --> 00:22:06,149
processor<font color="#E5E5E5"> itself</font><font color="#CCCCCC"> the peripheral</font>

410
00:22:04,049 --> 00:22:10,049
communication happens mainly with I

411
00:22:06,150 --> 00:22:13,650
already stirs this means you control the

412
00:22:10,049 --> 00:22:18,799
peripherals<font color="#E5E5E5"> by writing to it or reading</font>

413
00:22:13,650 --> 00:22:22,580
from<font color="#CCCCCC"> it as an</font><font color="#E5E5E5"> example I'll give a quick</font>

414
00:22:18,799 --> 00:22:29,639
<font color="#E5E5E5">overview what you would need to emulate</font>

415
00:22:22,580 --> 00:22:31,830
<font color="#E5E5E5">basic</font><font color="#CCCCCC"> UART on the AV our side we only</font>

416
00:22:29,640 --> 00:22:34,289
care about the UART on the AVR side

417
00:22:31,830 --> 00:22:38,399
<font color="#E5E5E5">because on my case which is</font>

418
00:22:34,289 --> 00:22:41,370
<font color="#CCCCCC">reverse-engineering AVR firmware I just</font>

419
00:22:38,400 --> 00:22:43,559
want to see what is<font color="#E5E5E5"> being sent and I</font>

420
00:22:41,370 --> 00:22:47,158
won't<font color="#CCCCCC"> actually send it to a terminal</font>

421
00:22:43,559 --> 00:22:50,549
<font color="#CCCCCC">emulator so I won't</font><font color="#E5E5E5"> have to implement</font>

422
00:22:47,159 --> 00:22:54,750
<font color="#E5E5E5">the actual you</font><font color="#CCCCCC"> our protocol but just how</font>

423
00:22:50,549 --> 00:22:57,150
it behaves on the AVR side<font color="#E5E5E5"> for the</font><font color="#CCCCCC"> proof</font>

424
00:22:54,750 --> 00:23:00,090
<font color="#E5E5E5">of concept will use the registers as</font>

425
00:22:57,150 --> 00:23:05,970
specified for the 80 mega of<font color="#E5E5E5"> 328 cuz</font>

426
00:23:00,090 --> 00:23:10,370
those change<font color="#E5E5E5"> if you use another core so</font>

427
00:23:05,970 --> 00:23:13,559
we have a few registers<font color="#E5E5E5"> specific to UART</font>

428
00:23:10,370 --> 00:23:16,530
<font color="#E5E5E5">we have</font><font color="#CCCCCC"> three control registers</font><font color="#E5E5E5"> two</font>

429
00:23:13,559 --> 00:23:19,139
registers to set the baud rate<font color="#E5E5E5"> and one</font>

430
00:23:16,530 --> 00:23:22,408
data register where we store<font color="#CCCCCC"> the data we</font>

431
00:23:19,140 --> 00:23:28,110
<font color="#CCCCCC">want to send and the data we want to</font>

432
00:23:22,409 --> 00:23:29,880
<font color="#E5E5E5">receive is being written there we don't</font>

433
00:23:28,110 --> 00:23:33,240
<font color="#E5E5E5">need</font><font color="#CCCCCC"> two other free control registers</font>

434
00:23:29,880 --> 00:23:34,980
<font color="#E5E5E5">for basic</font><font color="#CCCCCC"> us implementation and we won't</font>

435
00:23:33,240 --> 00:23:37,080
<font color="#E5E5E5">meet the baud rate setting because we</font>

436
00:23:34,980 --> 00:23:42,480
<font color="#E5E5E5">won't send it anywhere we're just</font><font color="#CCCCCC"> gonna</font>

437
00:23:37,080 --> 00:23:44,789
<font color="#E5E5E5">dump</font><font color="#CCCCCC"> the values we might need the the</font>

438
00:23:42,480 --> 00:23:47,580
second control register which enables or

439
00:23:44,789 --> 00:23:48,929
disables to interrupt<font color="#E5E5E5"> but for the sake</font>

440
00:23:47,580 --> 00:23:54,928
of simplicity we're just going to do it

441
00:23:48,929 --> 00:23:56,820
<font color="#E5E5E5">without the interrupt now how would you</font>

442
00:23:54,929 --> 00:24:00,330
<font color="#E5E5E5">go</font><font color="#CCCCCC"> about implementing a peripheral</font>

443
00:23:56,820 --> 00:24:02,790
my<font color="#E5E5E5"> usual process is I monitor what is</font>

444
00:24:00,330 --> 00:24:06,090
<font color="#E5E5E5">the firmware actually doing how it is</font>

445
00:24:02,790 --> 00:24:09,090
communicating with the<font color="#CCCCCC"> i/o ports dump</font>

446
00:24:06,090 --> 00:24:11,790
the trace of the communication<font color="#E5E5E5"> and look</font>

447
00:24:09,090 --> 00:24:15,990
up in the datasheet<font color="#E5E5E5"> what the</font>

448
00:24:11,790 --> 00:24:17,490
communication<font color="#E5E5E5"> means usually it just it</font>

449
00:24:15,990 --> 00:24:21,690
would be enough if you<font color="#CCCCCC"> just go ahead</font><font color="#E5E5E5"> and</font>

450
00:24:17,490 --> 00:24:24,420
read<font color="#E5E5E5"> the datasheet but I personally</font>

451
00:24:21,690 --> 00:24:26,550
<font color="#E5E5E5">think</font><font color="#CCCCCC"> the process of tracing</font><font color="#E5E5E5"> it and then</font>

452
00:24:24,420 --> 00:24:28,290
looking it up in<font color="#E5E5E5"> the datasheet is bit</font>

453
00:24:26,550 --> 00:24:31,040
faster and makes a bit clearer to

454
00:24:28,290 --> 00:24:31,040
understand how it works

455
00:24:32,430 --> 00:24:39,030
so the UART control register<font color="#CCCCCC"> a is</font>

456
00:24:34,970 --> 00:24:42,840
<font color="#CCCCCC">composed of a few</font><font color="#E5E5E5"> bits where</font><font color="#CCCCCC"> we only</font>

457
00:24:39,030 --> 00:24:45,270
<font color="#E5E5E5">need</font><font color="#CCCCCC"> three for now the rest is parity</font>

458
00:24:42,840 --> 00:24:47,570
<font color="#E5E5E5">are our parity RS we won't need to check</font>

459
00:24:45,270 --> 00:24:50,850
<font color="#CCCCCC">because we won't actually send anything</font>

460
00:24:47,570 --> 00:24:53,520
and we can<font color="#E5E5E5"> concentrate on the receive</font>

461
00:24:50,850 --> 00:24:58,429
complete flag the transmit complete flag

462
00:24:53,520 --> 00:24:58,430
and<font color="#E5E5E5"> their data register empty flag</font>

463
00:24:59,390 --> 00:25:03,900
<font color="#CCCCCC">register receive complete and transmit</font>

464
00:25:01,950 --> 00:25:06,060
complete is pretty straightforward<font color="#CCCCCC"> if</font>

465
00:25:03,900 --> 00:25:08,790
we're done sending something<font color="#E5E5E5"> the</font>

466
00:25:06,060 --> 00:25:10,850
<font color="#E5E5E5">transmit a complete flag is</font><font color="#CCCCCC"> said if we</font>

467
00:25:08,790 --> 00:25:16,050
have received<font color="#CCCCCC"> something the receive</font>

468
00:25:10,850 --> 00:25:18,740
complete flag is set<font color="#E5E5E5"> the data register</font>

469
00:25:16,050 --> 00:25:23,100
empty flag is relevant for sending data

470
00:25:18,740 --> 00:25:27,180
<font color="#E5E5E5">transmitting because we're only able to</font>

471
00:25:23,100 --> 00:25:30,290
<font color="#E5E5E5">push data into the data register</font><font color="#CCCCCC"> if the</font>

472
00:25:27,180 --> 00:25:36,330
data<font color="#CCCCCC"> rigid register is actually</font><font color="#E5E5E5"> empty so</font>

473
00:25:30,290 --> 00:25:38,909
if the data<font color="#E5E5E5"> register empty flag is not</font>

474
00:25:36,330 --> 00:25:44,070
<font color="#E5E5E5">set meaning there</font><font color="#CCCCCC"> is some data in the</font>

475
00:25:38,910 --> 00:25:48,000
data register<font color="#E5E5E5"> we we can write there but</font>

476
00:25:44,070 --> 00:25:50,850
it will<font color="#CCCCCC"> just be ignored</font><font color="#E5E5E5"> and the emulator</font>

477
00:25:48,000 --> 00:25:53,160
<font color="#CCCCCC">has to deal with this</font><font color="#E5E5E5"> and think about</font>

478
00:25:50,850 --> 00:25:57,060
this<font color="#E5E5E5"> so you can just replace the value</font>

479
00:25:53,160 --> 00:26:00,480
every<font color="#CCCCCC"> time you write to</font><font color="#E5E5E5"> it so how would</font>

480
00:25:57,060 --> 00:26:06,540
we<font color="#E5E5E5"> go about sending we wait till the</font>

481
00:26:00,480 --> 00:26:09,240
<font color="#E5E5E5">data registers</font><font color="#CCCCCC"> empty we write to the</font>

482
00:26:06,540 --> 00:26:10,649
<font color="#CCCCCC">data register and then our emulator goes</font>

483
00:26:09,240 --> 00:26:13,350
ahead and takes the value<font color="#E5E5E5"> from</font>

484
00:26:10,649 --> 00:26:16,739
data register<font color="#E5E5E5"> and does something with it</font>

485
00:26:13,350 --> 00:26:23,668
<font color="#E5E5E5">in my</font><font color="#CCCCCC"> case I'm just dumping</font><font color="#E5E5E5"> it to stand</font>

486
00:26:16,740 --> 00:26:27,659
it out<font color="#CCCCCC"> you could essentially implement</font>

487
00:26:23,669 --> 00:26:30,539
the whole<font color="#E5E5E5"> emulate the terminal on top of</font>

488
00:26:27,659 --> 00:26:34,440
it and use the actual<font color="#CCCCCC"> uot protocol to</font>

489
00:26:30,539 --> 00:26:37,169
send<font color="#CCCCCC"> the values</font><font color="#E5E5E5"> and once we've dealt</font>

490
00:26:34,440 --> 00:26:39,179
with the data in the data register<font color="#CCCCCC"> we'll</font>

491
00:26:37,169 --> 00:26:42,299
have to set the<font color="#E5E5E5"> data</font><font color="#CCCCCC"> register</font><font color="#E5E5E5"> empty flag</font>

492
00:26:39,179 --> 00:26:45,299
and the<font color="#E5E5E5"> transmission complete flag of</font>

493
00:26:42,299 --> 00:26:48,899
course this isn't equivalent if you

494
00:26:45,299 --> 00:26:51,629
would<font color="#E5E5E5"> actually implement</font><font color="#CCCCCC"> the actual</font>

495
00:26:48,899 --> 00:26:54,508
<font color="#CCCCCC">Ewart protocol but since we're just</font>

496
00:26:51,629 --> 00:26:55,980
dumping<font color="#E5E5E5"> the values we can treat the data</font>

497
00:26:54,509 --> 00:27:03,029
register empty<font color="#E5E5E5"> and the transmission</font>

498
00:26:55,980 --> 00:27:07,830
complete<font color="#CCCCCC"> is somewhat equivalent so what</font>

499
00:27:03,029 --> 00:27:10,529
<font color="#CCCCCC">about reading reading is basically the</font>

500
00:27:07,830 --> 00:27:16,889
<font color="#E5E5E5">other way around</font><font color="#CCCCCC"> except we won't have</font>

501
00:27:10,529 --> 00:27:18,779
the data register empty flag because now

502
00:27:16,889 --> 00:27:21,539
the data register has to have some value

503
00:27:18,779 --> 00:27:24,720
and we can<font color="#E5E5E5"> just read from the data</font>

504
00:27:21,539 --> 00:27:28,320
register<font color="#E5E5E5"> now how does</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> work</font>

505
00:27:24,720 --> 00:27:30,539
when combined with<font color="#CCCCCC"> transmuting if you</font>

506
00:27:28,320 --> 00:27:32,428
read from<font color="#E5E5E5"> the data register you'll get</font>

507
00:27:30,539 --> 00:27:35,340
different<font color="#E5E5E5"> behavior than when you write</font>

508
00:27:32,429 --> 00:27:37,230
<font color="#CCCCCC">to it</font><font color="#E5E5E5"> meaning if</font><font color="#CCCCCC"> you read from</font><font color="#E5E5E5"> the data</font>

509
00:27:35,340 --> 00:27:40,230
register<font color="#CCCCCC"> it will trigger an internal</font>

510
00:27:37,230 --> 00:27:43,169
read<font color="#CCCCCC"> queue</font><font color="#E5E5E5"> give you the top of</font><font color="#CCCCCC"> the read</font>

511
00:27:40,230 --> 00:27:45,840
queue and move to read q1 along and if

512
00:27:43,169 --> 00:27:49,830
you write<font color="#CCCCCC"> to</font><font color="#E5E5E5"> it a whole other code will</font>

513
00:27:45,840 --> 00:27:53,070
be executed<font color="#E5E5E5"> so you can use it both ways</font>

514
00:27:49,830 --> 00:27:58,949
<font color="#E5E5E5">you just</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> to remember how and</font><font color="#CCCCCC"> you</font>

515
00:27:53,070 --> 00:28:01,049
have to<font color="#E5E5E5"> emulate it well we just busy</font>

516
00:27:58,950 --> 00:28:03,869
waiting<font color="#E5E5E5"> for the repeat receive complete</font>

517
00:28:01,049 --> 00:28:06,480
<font color="#E5E5E5">flag to be set would not be very smart</font>

518
00:28:03,869 --> 00:28:09,869
<font color="#E5E5E5">so you can put the UART controller to</font>

519
00:28:06,480 --> 00:28:12,200
sleep and then wait for<font color="#E5E5E5"> the interrupt to</font>

520
00:28:09,869 --> 00:28:12,199
be triggered

521
00:28:15,450 --> 00:28:22,470
so yeah<font color="#E5E5E5"> what would you need to implement</font>

522
00:28:19,440 --> 00:28:24,119
peripherals in general as I said you

523
00:28:22,470 --> 00:28:26,489
would need to monitor how<font color="#CCCCCC"> the</font>

524
00:28:24,119 --> 00:28:28,249
communication<font color="#E5E5E5"> is occurring</font><font color="#CCCCCC"> you will have</font>

525
00:28:26,489 --> 00:28:31,139
to look it up in a datasheet

526
00:28:28,249 --> 00:28:33,749
but on the emulator side it's important

527
00:28:31,139 --> 00:28:35,668
to<font color="#E5E5E5"> track the memory access</font><font color="#CCCCCC"> because if</font>

528
00:28:33,749 --> 00:28:39,059
you don't track the<font color="#E5E5E5"> memory access you</font>

529
00:28:35,669 --> 00:28:42,679
won't<font color="#E5E5E5"> have any way to know if and now I</font>

530
00:28:39,059 --> 00:28:46,259
or adjuster has<font color="#E5E5E5"> been accessed or not</font>

531
00:28:42,679 --> 00:28:50,239
you'll<font color="#CCCCCC"> have to supply some kind of</font>

532
00:28:46,259 --> 00:28:52,889
mechanism<font color="#CCCCCC"> to allow</font><font color="#E5E5E5"> handler routines</font>

533
00:28:50,239 --> 00:28:55,729
<font color="#CCCCCC">which you can just use</font><font color="#E5E5E5"> those callbacks</font>

534
00:28:52,889 --> 00:28:58,258
<font color="#E5E5E5">for read and</font><font color="#CCCCCC"> write on Lyle registers</font><font color="#E5E5E5"> and</font>

535
00:28:55,729 --> 00:29:01,739
you'll have some kind of main handler

536
00:28:58,259 --> 00:29:04,619
<font color="#E5E5E5">where you handle the peripheral logic</font>

537
00:29:01,739 --> 00:29:06,749
<font color="#E5E5E5">for example copying values</font><font color="#CCCCCC"> around or</font>

538
00:29:04,619 --> 00:29:08,070
dumping it to the<font color="#E5E5E5"> command line</font><font color="#CCCCCC"> or</font>

539
00:29:06,749 --> 00:29:13,080
whatever<font color="#E5E5E5"> you want to do with the</font>

540
00:29:08,070 --> 00:29:16,649
<font color="#E5E5E5">peripheral how does</font><font color="#CCCCCC"> see maybe are going</font>

541
00:29:13,080 --> 00:29:20,369
<font color="#CCCCCC">about this this was a one point</font><font color="#E5E5E5"> I wasn't</font>

542
00:29:16,649 --> 00:29:22,949
able to understand in the beginning<font color="#CCCCCC"> see</font>

543
00:29:20,369 --> 00:29:26,849
<font color="#CCCCCC">Maivia has pretty modules</font><font color="#E5E5E5"> modular system</font>

544
00:29:22,950 --> 00:29:28,830
for adding new components and the main

545
00:29:26,849 --> 00:29:31,229
free interface points for those

546
00:29:28,830 --> 00:29:34,499
<font color="#CCCCCC">components are the internal interrupts</font>

547
00:29:31,229 --> 00:29:38,809
definitions<font color="#CCCCCC"> handlers</font><font color="#E5E5E5"> for I all read and</font>

548
00:29:34,499 --> 00:29:41,729
<font color="#E5E5E5">write and internal interrupt requests</font>

549
00:29:38,809 --> 00:29:43,859
<font color="#E5E5E5">internal interrupt requests in C may be</font>

550
00:29:41,729 --> 00:29:46,320
odd<font color="#E5E5E5"> don't have to do with actual</font>

551
00:29:43,859 --> 00:29:48,389
<font color="#E5E5E5">interrupts on the AVR device and are</font>

552
00:29:46,320 --> 00:29:52,139
used as some<font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of signal slot</font>

553
00:29:48,389 --> 00:29:58,379
mechanism for communicating between<font color="#CCCCCC"> C</font>

554
00:29:52,139 --> 00:30:00,029
<font color="#E5E5E5">maybe</font><font color="#CCCCCC"> our modules defining</font><font color="#E5E5E5"> the</font>

555
00:29:58,379 --> 00:30:01,619
<font color="#CCCCCC">interrupts of the module is pretty</font>

556
00:30:00,029 --> 00:30:05,099
<font color="#CCCCCC">straightforward with the C maybe</font><font color="#E5E5E5"> our</font>

557
00:30:01,619 --> 00:30:10,080
macros and once you're done<font color="#E5E5E5"> with</font>

558
00:30:05,099 --> 00:30:13,220
<font color="#E5E5E5">defining your your</font><font color="#CCCCCC"> interrupts you'll</font>

559
00:30:10,080 --> 00:30:13,220
just registered

560
00:30:15,340 --> 00:30:21,159
as I said you can put<font color="#CCCCCC"> handless on I all</font>

561
00:30:18,429 --> 00:30:24,370
read and<font color="#CCCCCC"> write you'll just write</font><font color="#E5E5E5"> your</font>

562
00:30:21,160 --> 00:30:25,870
<font color="#CCCCCC">callback function to</font><font color="#E5E5E5"> handle the logic</font>

563
00:30:24,370 --> 00:30:30,459
what happens on the read<font color="#CCCCCC"> or write</font><font color="#E5E5E5"> and</font>

564
00:30:25,870 --> 00:30:33,129
then you'll<font color="#CCCCCC"> register it on a specific</font><font color="#E5E5E5"> IO</font>

565
00:30:30,460 --> 00:30:39,010
register and it will be<font color="#E5E5E5"> executed once</font>

566
00:30:33,130 --> 00:30:42,370
you write or read<font color="#CCCCCC"> from</font><font color="#E5E5E5"> it and you have</font>

567
00:30:39,010 --> 00:30:44,950
the internal interrupt requests<font color="#CCCCCC"> which</font>

568
00:30:42,370 --> 00:30:47,260
mainly consists of three<font color="#E5E5E5"> functions you</font>

569
00:30:44,950 --> 00:30:49,240
can register a callback which will be

570
00:30:47,260 --> 00:30:51,900
<font color="#E5E5E5">called once the interrupt request</font>

571
00:30:49,240 --> 00:30:54,520
request is raised

572
00:30:51,900 --> 00:30:56,559
you can raise an interrupt request<font color="#CCCCCC"> and</font>

573
00:30:54,520 --> 00:31:00,210
you connect can connect to interrupt

574
00:30:56,559 --> 00:31:04,510
<font color="#CCCCCC">request</font><font color="#E5E5E5"> now what you can do with this is</font>

575
00:31:00,210 --> 00:31:06,490
for example<font color="#CCCCCC"> - what I have done with the</font>

576
00:31:04,510 --> 00:31:08,830
UART example where I can just<font color="#CCCCCC"> dump the</font>

577
00:31:06,490 --> 00:31:11,950
values to standard out<font color="#E5E5E5"> in this case you</font>

578
00:31:08,830 --> 00:31:15,370
could do the same in<font color="#E5E5E5"> C</font><font color="#CCCCCC"> maybe R and have</font>

579
00:31:11,950 --> 00:31:16,929
another<font color="#CCCCCC"> module where you</font><font color="#E5E5E5"> instead of just</font>

580
00:31:15,370 --> 00:31:21,070
dump the you add values to standard out

581
00:31:16,929 --> 00:31:23,890
could collect data from<font color="#E5E5E5"> all peripherals</font>

582
00:31:21,070 --> 00:31:26,200
in one module and have<font color="#E5E5E5"> this one module</font>

583
00:31:23,890 --> 00:31:31,809
<font color="#E5E5E5">lock all the interactions with the</font><font color="#CCCCCC"> other</font>

584
00:31:26,200 --> 00:31:33,280
modules yeah and here's some C<font color="#CCCCCC"> maybe our</font>

585
00:31:31,809 --> 00:31:33,549
<font color="#E5E5E5">resources if you want</font><font color="#CCCCCC"> to have a look</font><font color="#E5E5E5"> at</font>

586
00:31:33,280 --> 00:31:37,330
it

587
00:31:33,549 --> 00:31:39,700
I recommend C maybe<font color="#E5E5E5"> our C maybe</font><font color="#CCCCCC"> R is</font>

588
00:31:37,330 --> 00:31:42,309
pretty mature and if you know how the

589
00:31:39,700 --> 00:31:45,220
underlying<font color="#CCCCCC"> architecture works it isn't</font>

590
00:31:42,309 --> 00:31:48,100
that hard<font color="#E5E5E5"> to</font><font color="#CCCCCC"> actually</font><font color="#E5E5E5"> get into it so if</font>

591
00:31:45,220 --> 00:31:51,190
you want to<font color="#E5E5E5"> use it</font><font color="#CCCCCC"> for production</font>

592
00:31:48,100 --> 00:31:53,549
<font color="#CCCCCC">reverse engineering this is probably</font><font color="#E5E5E5"> the</font>

593
00:31:51,190 --> 00:31:53,549
best<font color="#CCCCCC"> bet</font>

594
00:31:54,900 --> 00:32:01,660
how did I go about implementing my

595
00:31:57,490 --> 00:32:04,990
<font color="#E5E5E5">emulator</font><font color="#CCCCCC"> I used</font><font color="#E5E5E5"> Rastus back-end and C++</font>

596
00:32:01,660 --> 00:32:08,290
for the<font color="#CCCCCC"> Qt GUI the project is still</font>

597
00:32:04,990 --> 00:32:12,160
<font color="#CCCCCC">pretty much ongoing for now</font><font color="#E5E5E5"> only the 80</font>

598
00:32:08,290 --> 00:32:17,379
mega<font color="#E5E5E5"> 3:28 which is the Arduino core and</font>

599
00:32:12,160 --> 00:32:19,450
the ATX mega<font color="#E5E5E5"> 128 is supported</font><font color="#CCCCCC"> I will</font>

600
00:32:17,380 --> 00:32:23,020
release the code as soon as I<font color="#CCCCCC"> handled in</font>

601
00:32:19,450 --> 00:32:24,640
<font color="#CCCCCC">my bachelor thesis because the project</font>

602
00:32:23,020 --> 00:32:25,929
is bound to my bachelor<font color="#CCCCCC"> thesis and don't</font>

603
00:32:24,640 --> 00:32:27,490
know if it's a<font color="#E5E5E5"> good idea to race to</font>

604
00:32:25,929 --> 00:32:31,950
release the code

605
00:32:27,490 --> 00:32:36,450
beforehand<font color="#CCCCCC"> before we go to questions</font>

606
00:32:31,950 --> 00:32:36,450
<font color="#CCCCCC">let's do a live demo</font>

607
00:33:02,610 --> 00:33:09,340
so we have some<font color="#CCCCCC"> forum where which</font><font color="#E5E5E5"> is</font>

608
00:33:07,120 --> 00:33:13,090
actually a small<font color="#E5E5E5"> reverse engineering</font>

609
00:33:09,340 --> 00:33:15,580
correct me a friend of mine wrote<font color="#E5E5E5"> and we</font>

610
00:33:13,090 --> 00:33:18,610
load it into<font color="#E5E5E5"> the</font><font color="#CCCCCC"> emulator</font><font color="#E5E5E5"> and what we</font>

611
00:33:15,580 --> 00:33:20,620
see is we<font color="#CCCCCC"> see the disassembly</font><font color="#E5E5E5"> which we</font>

612
00:33:18,610 --> 00:33:23,709
get for free<font color="#E5E5E5"> once we do the instruction</font>

613
00:33:20,620 --> 00:33:25,299
decoding<font color="#E5E5E5"> and once we actually start the</font>

614
00:33:23,710 --> 00:33:28,540
emulator<font color="#CCCCCC"> we'll get a trace of</font><font color="#E5E5E5"> the</font>

615
00:33:25,299 --> 00:33:31,960
instructions<font color="#E5E5E5"> being executed while the</font>

616
00:33:28,540 --> 00:33:33,879
<font color="#E5E5E5">execution is happening the functions</font>

617
00:33:31,960 --> 00:33:36,160
will be<font color="#E5E5E5"> recorded every time a function</font>

618
00:33:33,880 --> 00:33:39,610
call is<font color="#E5E5E5"> being taken the function will</font><font color="#CCCCCC"> be</font>

619
00:33:36,160 --> 00:33:41,200
listed in<font color="#CCCCCC"> a function overview so we get</font>

620
00:33:39,610 --> 00:33:44,590
function detection for free in dynamic

621
00:33:41,200 --> 00:33:47,290
analysis<font color="#CCCCCC"> and on the right</font><font color="#E5E5E5"> hand</font><font color="#CCCCCC"> side we</font>

622
00:33:44,590 --> 00:33:52,299
can<font color="#CCCCCC"> see a</font><font color="#E5E5E5"> memory heap map which is the</font>

623
00:33:47,290 --> 00:33:57,820
<font color="#CCCCCC">i/o memory and the SRAM so let's just</font>

624
00:33:52,299 --> 00:33:59,760
start it up<font color="#E5E5E5"> and</font><font color="#CCCCCC"> in the panic</font><font color="#E5E5E5"> in the</font>

625
00:33:57,820 --> 00:34:04,210
beginning the<font color="#CCCCCC"> program just copies data</font>

626
00:33:59,760 --> 00:34:06,549
into SRAM or clears the SRAM<font color="#E5E5E5"> as we can</font>

627
00:34:04,210 --> 00:34:09,280
see in the heat map in the<font color="#E5E5E5"> heap maps</font>

628
00:34:06,549 --> 00:34:11,850
<font color="#E5E5E5">right</font><font color="#CCCCCC"> X's are marked with red color</font><font color="#E5E5E5"> and</font>

629
00:34:09,280 --> 00:34:15,970
<font color="#E5E5E5">the read</font><font color="#CCCCCC"> axis with blue color</font><font color="#E5E5E5"> and</font>

630
00:34:11,850 --> 00:34:22,918
depending on<font color="#E5E5E5"> how recent the axis is it</font>

631
00:34:15,969 --> 00:34:26,638
is either brighter or darker so

632
00:34:22,918 --> 00:34:31,379
<font color="#E5E5E5">you might see</font><font color="#CCCCCC"> something yeah since I</font>

633
00:34:26,639 --> 00:34:33,720
found out put the<font color="#CCCCCC"> UART</font><font color="#E5E5E5"> in the GUI yet</font><font color="#CCCCCC"> I</font>

634
00:34:31,379 --> 00:34:37,589
output it to<font color="#CCCCCC"> standard</font><font color="#E5E5E5"> out and it just</font>

635
00:34:33,719 --> 00:34:42,058
says<font color="#CCCCCC"> enter your PIN</font><font color="#E5E5E5"> now we can enter</font>

636
00:34:37,589 --> 00:34:46,109
something yeah<font color="#CCCCCC"> but it won't</font><font color="#E5E5E5"> give you any</font>

637
00:34:42,059 --> 00:34:47,760
feedback<font color="#E5E5E5"> right now but we can see once</font>

638
00:34:46,109 --> 00:34:50,848
we<font color="#E5E5E5"> enter the pin a lot of other</font>

639
00:34:47,760 --> 00:34:54,329
functions<font color="#E5E5E5"> are being triggered and then</font>

640
00:34:50,849 --> 00:35:01,559
we could go<font color="#E5E5E5"> and reverse engineer what's</font>

641
00:34:54,329 --> 00:35:06,329
the actual pin is<font color="#E5E5E5"> and we can also stop</font>

642
00:35:01,559 --> 00:35:11,970
and<font color="#CCCCCC"> single-step if we want</font><font color="#E5E5E5"> to look</font>

643
00:35:06,329 --> 00:35:14,549
something<font color="#E5E5E5"> in detail and that's as</font><font color="#CCCCCC"> much</font>

644
00:35:11,970 --> 00:35:18,450
functionality<font color="#E5E5E5"> as</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> graphical user</font>

645
00:35:14,549 --> 00:35:20,640
interface<font color="#E5E5E5"> has right now the</font><font color="#CCCCCC"> backend is</font>

646
00:35:18,450 --> 00:35:22,460
mostly complete<font color="#E5E5E5"> now I just need to</font>

647
00:35:20,640 --> 00:35:26,069
<font color="#E5E5E5">implement most of the cool features</font>

648
00:35:22,460 --> 00:35:28,290
<font color="#CCCCCC">there are or already some other features</font>

649
00:35:26,069 --> 00:35:30,599
<font color="#CCCCCC">like memory of you but I have</font><font color="#E5E5E5"> disabled</font>

650
00:35:28,290 --> 00:35:32,808
them because I<font color="#E5E5E5"> don't want it to crash in</font>

651
00:35:30,599 --> 00:35:32,809
<font color="#CCCCCC">your life</font>

652
00:35:38,800 --> 00:35:49,650
[Music]

653
00:35:48,790 --> 00:35:52,939
[Applause]

654
00:35:49,650 --> 00:35:52,939
[Music]

