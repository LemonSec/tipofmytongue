1
00:00:00,000 --> 00:00:12,130
[Music]

2
00:00:11,270 --> 00:00:14,360
[Applause]

3
00:00:12,130 --> 00:00:17,970
[Music]

4
00:00:14,360 --> 00:00:20,250
<font color="#CCCCCC">this lecture</font><font color="#E5E5E5"> will</font><font color="#CCCCCC"> be had</font><font color="#E5E5E5"> by by</font><font color="#CCCCCC"> Marian</font>

5
00:00:17,970 --> 00:00:22,619
<font color="#E5E5E5">Mariana and it will be on the topic</font><font color="#CCCCCC"> of</font>

6
00:00:20,250 --> 00:00:31,529
preventing CPU side<font color="#E5E5E5"> channel text with</font>

7
00:00:22,619 --> 00:00:34,890
Colonel<font color="#CCCCCC"> trace tracking</font><font color="#E5E5E5"> thank you</font><font color="#CCCCCC"> before</font>

8
00:00:31,529 --> 00:00:39,570
<font color="#CCCCCC">I start</font><font color="#E5E5E5"> how many of you have heard about</font>

9
00:00:34,890 --> 00:00:42,090
CPU side channel attacks<font color="#CCCCCC"> Hey so good</font>

10
00:00:39,570 --> 00:00:43,950
that I prepared more<font color="#CCCCCC"> their</font><font color="#E5E5E5"> picture</font>

11
00:00:42,090 --> 00:00:46,739
outside<font color="#E5E5E5"> of this so you can understand</font>

12
00:00:43,950 --> 00:00:49,230
what is<font color="#CCCCCC"> a</font><font color="#E5E5E5"> CPU side channel attack so</font>

13
00:00:46,739 --> 00:00:54,300
firstly my<font color="#CCCCCC"> and chief System Architect</font>

14
00:00:49,230 --> 00:00:59,489
aside ground since 2004<font color="#E5E5E5"> and system</font>

15
00:00:54,300 --> 00:01:02,280
administrator<font color="#CCCCCC"> for 23 22 years</font><font color="#E5E5E5"> now</font><font color="#CCCCCC"> I'm</font>

16
00:00:59,489 --> 00:01:04,768
<font color="#E5E5E5">organizing a few events in Bulgaria</font><font color="#CCCCCC"> I'm</font>

17
00:01:02,280 --> 00:01:06,360
also teaching network security and

18
00:01:04,769 --> 00:01:08,790
system administration in Sofia

19
00:01:06,360 --> 00:01:15,270
University and I'm<font color="#CCCCCC"> also helping</font><font color="#E5E5E5"> with the</font>

20
00:01:08,790 --> 00:01:18,630
<font color="#E5E5E5">video team of FOSDEM so let's start with</font>

21
00:01:15,270 --> 00:01:21,509
what we<font color="#E5E5E5"> have as a CPU caches right now</font>

22
00:01:18,630 --> 00:01:24,530
we have four different<font color="#CCCCCC"> caches in the</font>

23
00:01:21,509 --> 00:01:26,909
more in the newest

24
00:01:24,530 --> 00:01:29,549
<font color="#E5E5E5">architectures</font><font color="#CCCCCC"> that we have in a</font><font color="#E5E5E5"> single</font>

25
00:01:26,909 --> 00:01:32,159
core<font color="#E5E5E5"> you would have layer 1 cache that</font>

26
00:01:29,549 --> 00:01:34,290
<font color="#CCCCCC">is the fastest cache and it is</font><font color="#E5E5E5"> separated</font>

27
00:01:32,159 --> 00:01:36,810
in two parts<font color="#CCCCCC"> you have</font><font color="#E5E5E5"> the instructions</font>

28
00:01:34,290 --> 00:01:38,939
the CPU instructions are cached<font color="#E5E5E5"> and then</font>

29
00:01:36,810 --> 00:01:41,880
you have the data for these<font color="#E5E5E5"> instructions</font>

30
00:01:38,939 --> 00:01:45,298
also cached and then you have the layer

31
00:01:41,880 --> 00:01:49,229
2 cache that keeps the data<font color="#E5E5E5"> after or</font>

32
00:01:45,299 --> 00:01:52,079
before it enters layer 1 and you<font color="#CCCCCC"> have</font>

33
00:01:49,229 --> 00:01:55,470
the level<font color="#E5E5E5"> 3 cache that is shared across</font>

34
00:01:52,079 --> 00:01:57,960
<font color="#CCCCCC">all of your course</font><font color="#E5E5E5"> so when you have a</font>

35
00:01:55,470 --> 00:02:00,450
multi core tech chure CPU that has

36
00:01:57,960 --> 00:02:04,110
multiple cores<font color="#E5E5E5"> inside of it you have</font>

37
00:02:00,450 --> 00:02:07,409
these caches here<font color="#E5E5E5"> and layer 2 cache is</font>

38
00:02:04,110 --> 00:02:10,410
shared within a single<font color="#E5E5E5"> core but you have</font>

39
00:02:07,409 --> 00:02:12,680
to keep in<font color="#CCCCCC"> mind</font><font color="#E5E5E5"> that most CPU</font>

40
00:02:10,410 --> 00:02:14,480
architectures currently support in a

41
00:02:12,680 --> 00:02:17,510
<font color="#CCCCCC">single-core</font><font color="#E5E5E5"> to have multiple frets</font>

42
00:02:14,480 --> 00:02:20,510
multiple threads executing part in

43
00:02:17,510 --> 00:02:22,790
parallel for so this means that layer

44
00:02:20,510 --> 00:02:26,540
<font color="#CCCCCC">two cache is also shared between</font><font color="#E5E5E5"> these</font>

45
00:02:22,790 --> 00:02:32,180
frets the only<font color="#E5E5E5"> cash that isn't shared is</font>

46
00:02:26,540 --> 00:02:34,548
the layer<font color="#CCCCCC"> 1 layer 1 cache so we actually</font>

47
00:02:32,180 --> 00:02:37,939
have in newest architectures we also

48
00:02:34,549 --> 00:02:41,269
have layer for cache that<font color="#CCCCCC"> is beneath the</font>

49
00:02:37,939 --> 00:02:44,659
<font color="#E5E5E5">layer 3 all these caches that we have</font>

50
00:02:41,269 --> 00:02:49,250
are<font color="#E5E5E5"> because getting data from</font><font color="#CCCCCC"> memory to</font>

51
00:02:44,659 --> 00:02:54,649
<font color="#CCCCCC">the to the CPU takes</font><font color="#E5E5E5"> a long</font><font color="#CCCCCC"> time</font><font color="#E5E5E5"> and by</font>

52
00:02:49,250 --> 00:02:56,840
a long time I<font color="#E5E5E5"> mean tens of CPU cycles</font>

53
00:02:54,650 --> 00:02:58,819
<font color="#CCCCCC">this means</font><font color="#E5E5E5"> that if</font><font color="#CCCCCC"> you have an</font>

54
00:02:56,840 --> 00:03:03,290
instruction<font color="#CCCCCC"> that is waiting</font><font color="#E5E5E5"> for its data</font>

55
00:02:58,819 --> 00:03:06,469
<font color="#E5E5E5">from the memory</font><font color="#CCCCCC"> it would</font><font color="#E5E5E5"> take like 10 to</font>

56
00:03:03,290 --> 00:03:10,219
15 CPU cycles<font color="#E5E5E5"> to get that data and you</font>

57
00:03:06,469 --> 00:03:11,780
shouldn't stop the<font color="#E5E5E5"> CPU because</font><font color="#CCCCCC"> you are</font>

58
00:03:10,219 --> 00:03:15,049
<font color="#CCCCCC">waiting for the data</font><font color="#E5E5E5"> this is why you</font>

59
00:03:11,780 --> 00:03:16,459
have the caches<font color="#CCCCCC"> that cache the data and</font>

60
00:03:15,049 --> 00:03:21,620
when you need<font color="#E5E5E5"> it</font>

61
00:03:16,459 --> 00:03:25,010
<font color="#E5E5E5">you pull the data from there so layer 1</font>

62
00:03:21,620 --> 00:03:27,669
and<font color="#CCCCCC"> their two caches can</font><font color="#E5E5E5"> be shared in</font>

63
00:03:25,010 --> 00:03:30,978
hyper threads and layer<font color="#E5E5E5"> two</font><font color="#CCCCCC"> caches are</font>

64
00:03:27,669 --> 00:03:34,780
shared between different parts of the

65
00:03:30,979 --> 00:03:38,959
core like<font color="#CCCCCC"> ethnical</font><font color="#E5E5E5"> what</font><font color="#CCCCCC"> cool</font><font color="#E5E5E5"> unit fuse</font>

66
00:03:34,780 --> 00:03:41,680
fuse<font color="#E5E5E5"> Mewtwo multiply add and so on</font>

67
00:03:38,959 --> 00:03:45,139
you<font color="#CCCCCC"> seed and they're free caches are</font>

68
00:03:41,680 --> 00:03:50,090
shared across<font color="#E5E5E5"> all cores on a single CPU</font>

69
00:03:45,139 --> 00:03:52,489
<font color="#E5E5E5">single CPU</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is the AMD bulldozer</font>

70
00:03:50,090 --> 00:03:56,659
architecture it's an<font color="#E5E5E5"> altar detector it's</font>

71
00:03:52,489 --> 00:03:58,209
not the<font color="#CCCCCC"> Rison but I don't want</font><font color="#E5E5E5"> to copy</font>

72
00:03:56,659 --> 00:04:01,220
that

73
00:03:58,209 --> 00:04:05,090
picture it here you can<font color="#CCCCCC"> clearly see that</font>

74
00:04:01,220 --> 00:04:07,519
<font color="#E5E5E5">you have integer instructions here oops</font>

75
00:04:05,090 --> 00:04:11,060
<font color="#E5E5E5">here you have integer cluster</font><font color="#CCCCCC"> intent</font>

76
00:04:07,519 --> 00:04:14,389
<font color="#E5E5E5">intercoastal</font><font color="#CCCCCC"> Deezer</font><font color="#E5E5E5"> two units</font><font color="#CCCCCC"> that can</font>

77
00:04:11,060 --> 00:04:16,759
execute<font color="#E5E5E5"> integer operations so integer</font>

78
00:04:14,389 --> 00:04:18,859
instructions go there<font color="#E5E5E5"> you have faulting</font>

79
00:04:16,759 --> 00:04:21,049
point unit here that<font color="#CCCCCC"> is executing</font>

80
00:04:18,858 --> 00:04:23,180
<font color="#CCCCCC">currently floating-point Rajic</font><font color="#E5E5E5"> there so</font>

81
00:04:21,048 --> 00:04:26,770
<font color="#E5E5E5">only</font><font color="#CCCCCC"> fourteen point instructions will go</font>

82
00:04:23,180 --> 00:04:29,780
to this part of<font color="#CCCCCC"> the CPU you have</font>

83
00:04:26,770 --> 00:04:32,568
everything you see<font color="#CCCCCC"> here is a single-core</font>

84
00:04:29,780 --> 00:04:35,000
<font color="#CCCCCC">button this architecture</font><font color="#E5E5E5"> have multiple</font>

85
00:04:32,569 --> 00:04:37,789
<font color="#CCCCCC">cores</font><font color="#E5E5E5"> so what you can see here</font><font color="#CCCCCC"> is that</font>

86
00:04:35,000 --> 00:04:40,880
we have a branch predictor here<font color="#E5E5E5"> and what</font>

87
00:04:37,789 --> 00:04:43,599
is what is<font color="#E5E5E5"> branch predictor</font><font color="#CCCCCC"> let's</font><font color="#E5E5E5"> see</font>

88
00:04:40,880 --> 00:04:46,849
you have an if statement in your<font color="#E5E5E5"> code</font>

89
00:04:43,599 --> 00:04:51,009
<font color="#CCCCCC">that if</font><font color="#E5E5E5"> statement is pretty simple</font>

90
00:04:46,849 --> 00:04:57,469
either it evaluates to true or to false

91
00:04:51,009 --> 00:04:59,660
but if it is true<font color="#CCCCCC"> you would have like 10</font>

92
00:04:57,470 --> 00:05:02,150
lines of code inside of<font color="#E5E5E5"> it if it is</font>

93
00:04:59,660 --> 00:05:07,280
false<font color="#CCCCCC"> you would get only</font><font color="#E5E5E5"> one line of</font>

94
00:05:02,150 --> 00:05:10,609
<font color="#CCCCCC">code in the else</font><font color="#E5E5E5"> clause so what you can</font>

95
00:05:07,280 --> 00:05:14,359
do is actually execute both the truth

96
00:05:10,610 --> 00:05:18,289
path and<font color="#E5E5E5"> the false path simultaneously</font>

97
00:05:14,360 --> 00:05:22,580
and whichever is actually true

98
00:05:18,289 --> 00:05:26,210
if the statement was true<font color="#E5E5E5"> you would get</font>

99
00:05:22,580 --> 00:05:28,400
the result directly<font color="#CCCCCC"> from the decision</font>

100
00:05:26,210 --> 00:05:32,948
<font color="#CCCCCC">that was taken so the branch predictor</font>

101
00:05:28,400 --> 00:05:39,169
is a part of the CPUs that predicts if

102
00:05:32,949 --> 00:05:42,979
this statement<font color="#CCCCCC"> this particular</font><font color="#E5E5E5"> sequence</font>

103
00:05:39,169 --> 00:05:46,250
of instructions<font color="#E5E5E5"> will go inside</font><font color="#CCCCCC"> that if</font>

104
00:05:42,979 --> 00:05:49,758
or in the else<font color="#CCCCCC"> Clause of your if</font>

105
00:05:46,250 --> 00:05:53,630
statement<font color="#E5E5E5"> which is very interesting part</font>

106
00:05:49,759 --> 00:05:57,320
<font color="#CCCCCC">until</font><font color="#E5E5E5"> which branch predictor later in</font>

107
00:05:53,630 --> 00:06:01,669
<font color="#E5E5E5">meltdown and</font><font color="#CCCCCC"> Specter attacks so you have</font>

108
00:05:57,320 --> 00:06:03,590
<font color="#E5E5E5">instruction feature this thing's this</font>

109
00:06:01,669 --> 00:06:06,049
part of the CPU actually gets your

110
00:06:03,590 --> 00:06:08,929
instructions and converts them into a

111
00:06:06,050 --> 00:06:11,419
<font color="#E5E5E5">different thing</font><font color="#CCCCCC"> I'll explain in a bit</font>

112
00:06:08,930 --> 00:06:14,570
<font color="#E5E5E5">all these instructions go to the</font>

113
00:06:11,419 --> 00:06:17,599
pipeline<font color="#CCCCCC"> and this top part</font><font color="#E5E5E5"> of the</font><font color="#CCCCCC"> CPU</font>

114
00:06:14,570 --> 00:06:20,500
here<font color="#E5E5E5"> actually this here is sequential</font>

115
00:06:17,599 --> 00:06:25,159
<font color="#CCCCCC">this is fine you</font><font color="#E5E5E5"> know that everything is</font>

116
00:06:20,500 --> 00:06:27,169
<font color="#E5E5E5">executed in order</font><font color="#CCCCCC"> well after you get all</font>

117
00:06:25,159 --> 00:06:30,710
<font color="#E5E5E5">of your instructions into</font><font color="#CCCCCC"> the pipeline</font>

118
00:06:27,169 --> 00:06:32,870
<font color="#E5E5E5">you</font><font color="#CCCCCC"> get an instruction decoder that gets</font>

119
00:06:30,710 --> 00:06:34,390
your assembly instructions or machine

120
00:06:32,870 --> 00:06:36,670
instructions

121
00:06:34,390 --> 00:06:40,810
<font color="#E5E5E5">converts them</font><font color="#CCCCCC"> to something</font><font color="#E5E5E5"> called micro</font>

122
00:06:36,670 --> 00:06:43,180
/ micro parents<font color="#CCCCCC"> deserve</font><font color="#E5E5E5"> different types</font>

123
00:06:40,810 --> 00:06:46,870
of instructions<font color="#CCCCCC"> that only</font><font color="#E5E5E5"> the inner part</font>

124
00:06:43,180 --> 00:06:50,170
of the CPU understand<font color="#CCCCCC"> and after that</font>

125
00:06:46,870 --> 00:06:52,840
everything can<font color="#CCCCCC"> be executed out of</font><font color="#E5E5E5"> order</font>

126
00:06:50,170 --> 00:06:59,470
this means that something<font color="#CCCCCC"> that requires</font>

127
00:06:52,840 --> 00:07:03,280
data can be<font color="#CCCCCC"> reordered later</font><font color="#E5E5E5"> after for</font>

128
00:06:59,470 --> 00:07:05,710
example<font color="#CCCCCC"> the in the if statement you get</font>

129
00:07:03,280 --> 00:07:08,739
like three lines<font color="#E5E5E5"> of code after these</font>

130
00:07:05,710 --> 00:07:12,190
three lines of codes were executed<font color="#E5E5E5"> then</font>

131
00:07:08,740 --> 00:07:15,040
you get the data for the if statement

132
00:07:12,190 --> 00:07:18,730
itself<font color="#E5E5E5"> this can happen and it</font><font color="#CCCCCC"> actually</font>

133
00:07:15,040 --> 00:07:22,360
happens a lot of in<font color="#E5E5E5"> your CPUs so this is</font>

134
00:07:18,730 --> 00:07:25,290
the basic architecture this is basic

135
00:07:22,360 --> 00:07:29,140
it's a little bit more complex<font color="#CCCCCC"> than this</font>

136
00:07:25,290 --> 00:07:32,760
so<font color="#E5E5E5"> we have</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> side channel attacks that</font>

137
00:07:29,140 --> 00:07:37,320
<font color="#CCCCCC">are pretty old they're from 2009 and</font>

138
00:07:32,760 --> 00:07:41,640
<font color="#E5E5E5">2011</font><font color="#CCCCCC"> flow center volt and</font><font color="#E5E5E5"> full force</font>

139
00:07:37,320 --> 00:07:43,599
<font color="#CCCCCC">what are these attacks</font><font color="#E5E5E5"> doing first</font>

140
00:07:41,640 --> 00:07:46,950
<font color="#E5E5E5">pushing through</font><font color="#CCCCCC"> wall to quarter</font>

141
00:07:43,600 --> 00:07:52,090
<font color="#CCCCCC">anyone here knows</font><font color="#E5E5E5"> forcing</font><font color="#CCCCCC"> two volt</font>

142
00:07:46,950 --> 00:07:54,370
perfect so you get your coat but if all

143
00:07:52,090 --> 00:07:56,440
<font color="#E5E5E5">of your applications compiled are</font>

144
00:07:54,370 --> 00:07:59,110
compiled with all the data inside of

145
00:07:56,440 --> 00:08:01,510
<font color="#E5E5E5">them with all the libraries you'd get</font>

146
00:07:59,110 --> 00:08:04,210
binaries that<font color="#E5E5E5"> are huge this is why we</font>

147
00:08:01,510 --> 00:08:06,130
have shared libraries so shared

148
00:08:04,210 --> 00:08:09,820
libraries are nice<font color="#E5E5E5"> because you want them</font>

149
00:08:06,130 --> 00:08:11,320
once<font color="#CCCCCC"> in the memory</font><font color="#E5E5E5"> and the kernel</font><font color="#CCCCCC"> the</font>

150
00:08:09,820 --> 00:08:13,570
operating system<font color="#E5E5E5"> actually knows that</font>

151
00:08:11,320 --> 00:08:16,930
<font color="#E5E5E5">this is a shared library and doesn't</font>

152
00:08:13,570 --> 00:08:19,540
duplicate the memory<font color="#E5E5E5"> for this so you get</font>

153
00:08:16,930 --> 00:08:21,780
this<font color="#E5E5E5"> sharecropper voltage in the memory</font>

154
00:08:19,540 --> 00:08:21,780
and

155
00:08:23,430 --> 00:08:29,010
after that<font color="#E5E5E5"> you executed by another</font>

156
00:08:26,550 --> 00:08:32,430
binary<font color="#E5E5E5"> the other binary world's the</font><font color="#CCCCCC"> same</font>

157
00:08:29,010 --> 00:08:35,159
library<font color="#CCCCCC"> it</font><font color="#E5E5E5"> is with different virtual</font>

158
00:08:32,429 --> 00:08:37,559
memory addresses<font color="#E5E5E5"> but the physical memory</font>

159
00:08:35,159 --> 00:08:41,849
address<font color="#CCCCCC"> of the library is the</font><font color="#E5E5E5"> same in</font>

160
00:08:37,559 --> 00:08:45,989
memory<font color="#E5E5E5"> so what you need to do is get</font>

161
00:08:41,849 --> 00:08:48,870
this library<font color="#CCCCCC"> into the CPU cache will</font><font color="#E5E5E5"> use</font>

162
00:08:45,990 --> 00:08:53,700
the last level cache or layer 3 cache

163
00:08:48,870 --> 00:08:56,010
and because we<font color="#E5E5E5"> are constantly executing</font>

164
00:08:53,700 --> 00:09:00,029
<font color="#E5E5E5">to our binary it will stay in the CPU</font>

165
00:08:56,010 --> 00:09:03,330
cache<font color="#E5E5E5"> for considerable time after we</font>

166
00:09:00,029 --> 00:09:07,589
find where<font color="#CCCCCC"> this shared library resides</font>

167
00:09:03,330 --> 00:09:11,070
in the memory<font color="#E5E5E5"> we need to check the</font>

168
00:09:07,589 --> 00:09:12,900
access<font color="#E5E5E5"> time to this actual memory so</font>

169
00:09:11,070 --> 00:09:16,190
this<font color="#E5E5E5"> is our library</font>

170
00:09:12,900 --> 00:09:20,160
<font color="#CCCCCC">the red dots</font><font color="#E5E5E5"> over there</font><font color="#CCCCCC"> you actually</font>

171
00:09:16,190 --> 00:09:22,470
<font color="#E5E5E5">wrote the binary and you get the library</font>

172
00:09:20,160 --> 00:09:24,750
inside the cache<font color="#CCCCCC"> not the whole binary</font>

173
00:09:22,470 --> 00:09:26,670
but actually the instructions for the

174
00:09:24,750 --> 00:09:30,680
functions that<font color="#CCCCCC"> you</font><font color="#E5E5E5"> are interested in and</font>

175
00:09:26,670 --> 00:09:36,000
you find them in<font color="#E5E5E5"> the cache so after that</font>

176
00:09:30,680 --> 00:09:37,410
<font color="#E5E5E5">you want to not execute this and for</font>

177
00:09:36,000 --> 00:09:39,990
example<font color="#E5E5E5"> these are integer instructions</font>

178
00:09:37,410 --> 00:09:50,310
and they go to the integer<font color="#E5E5E5"> part of the</font>

179
00:09:39,990 --> 00:09:54,630
CPU<font color="#CCCCCC"> and then what you get is</font><font color="#E5E5E5"> you you can</font>

180
00:09:50,310 --> 00:09:56,430
time how<font color="#E5E5E5"> much time</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> takes the it took</font>

181
00:09:54,630 --> 00:09:59,160
the CPU<font color="#E5E5E5"> to actually execute these</font>

182
00:09:56,430 --> 00:10:02,969
instructions<font color="#E5E5E5"> if the data was in the</font>

183
00:09:59,160 --> 00:10:06,240
cache the instructions would take less

184
00:10:02,970 --> 00:10:07,830
<font color="#CCCCCC">time</font><font color="#E5E5E5"> in the CPU less CPU cycles to</font>

185
00:10:06,240 --> 00:10:09,540
execute because<font color="#CCCCCC"> you already had the</font>

186
00:10:07,830 --> 00:10:12,420
instructions for<font color="#E5E5E5"> this library in the</font>

187
00:10:09,540 --> 00:10:14,449
<font color="#E5E5E5">city of</font><font color="#CCCCCC"> cache but if</font><font color="#E5E5E5"> they weren't there</font>

188
00:10:12,420 --> 00:10:16,979
you would actually<font color="#E5E5E5"> wait for the</font>

189
00:10:14,450 --> 00:10:18,839
instructions and the data for them to

190
00:10:16,980 --> 00:10:23,640
come from<font color="#E5E5E5"> memory inside the CPU cache</font>

191
00:10:18,839 --> 00:10:26,250
which is simple<font color="#E5E5E5"> and obvious but</font><font color="#CCCCCC"> you have</font>

192
00:10:23,640 --> 00:10:30,930
a function instruction inside the x86

193
00:10:26,250 --> 00:10:33,540
<font color="#E5E5E5">architecture that is called catch</font><font color="#CCCCCC"> whine</font>

194
00:10:30,930 --> 00:10:36,370
for what you know what this means is

195
00:10:33,540 --> 00:10:39,160
that you can clear all caches

196
00:10:36,370 --> 00:10:42,580
related to memory region<font color="#E5E5E5"> so you can say</font>

197
00:10:39,160 --> 00:10:45,459
this<font color="#E5E5E5"> is my memory region this is my</font>

198
00:10:42,580 --> 00:10:47,950
memory region and I want to flush<font color="#CCCCCC"> all</font>

199
00:10:45,460 --> 00:10:50,830
<font color="#CCCCCC">the caches inside the CPU that that</font><font color="#E5E5E5"> are</font>

200
00:10:47,950 --> 00:10:54,490
related to<font color="#CCCCCC"> this memory</font><font color="#E5E5E5"> region so you</font><font color="#CCCCCC"> can</font>

201
00:10:50,830 --> 00:10:57,670
<font color="#E5E5E5">fold this and essentially since you know</font>

202
00:10:54,490 --> 00:11:01,270
the memory<font color="#CCCCCC"> region after you flush you</font>

203
00:10:57,670 --> 00:11:06,390
can time how<font color="#CCCCCC"> much</font><font color="#E5E5E5"> time it took the CPU</font>

204
00:11:01,270 --> 00:11:09,550
to get the data back to<font color="#E5E5E5"> the cache again</font>

205
00:11:06,390 --> 00:11:13,510
<font color="#E5E5E5">timing this would actually tell you if</font>

206
00:11:09,550 --> 00:11:16,630
you get what types of bits<font color="#E5E5E5"> you get there</font>

207
00:11:13,510 --> 00:11:19,150
once<font color="#E5E5E5"> or</font><font color="#CCCCCC"> zeros you have to know the</font>

208
00:11:16,630 --> 00:11:23,020
<font color="#E5E5E5">actual code that</font><font color="#CCCCCC"> is in memory</font><font color="#E5E5E5"> to perform</font>

209
00:11:19,150 --> 00:11:26,319
this attack<font color="#E5E5E5"> but it's pretty easy to</font>

210
00:11:23,020 --> 00:11:29,410
<font color="#CCCCCC">achieve and doesn't require any root</font>

211
00:11:26,320 --> 00:11:32,350
access it<font color="#CCCCCC"> these</font><font color="#E5E5E5"> instructions are all</font>

212
00:11:29,410 --> 00:11:34,480
<font color="#CCCCCC">user space instructions that you can</font>

213
00:11:32,350 --> 00:11:36,910
execute<font color="#E5E5E5"> you can either write them</font>

214
00:11:34,480 --> 00:11:39,760
<font color="#CCCCCC">directly in assembly or write a C C++</font>

215
00:11:36,910 --> 00:11:42,480
code that does this<font color="#CCCCCC"> for you and your</font>

216
00:11:39,760 --> 00:11:44,709
<font color="#CCCCCC">timing this information</font><font color="#E5E5E5"> with the newest</font>

217
00:11:42,480 --> 00:11:47,560
<font color="#CCCCCC">side-channel</font><font color="#E5E5E5"> attacks you can actually do</font>

218
00:11:44,709 --> 00:11:50,709
this in a browser<font color="#E5E5E5"> on this machine ran in</font>

219
00:11:47,560 --> 00:11:55,180
written write the code in<font color="#E5E5E5"> JavaScript and</font>

220
00:11:50,709 --> 00:11:58,439
time it<font color="#E5E5E5"> so it works so this is fortune</font>

221
00:11:55,180 --> 00:12:02,469
to<font color="#E5E5E5"> world everyone every time you have to</font>

222
00:11:58,440 --> 00:12:04,930
forge the<font color="#CCCCCC"> cache and then execute again</font>

223
00:12:02,470 --> 00:12:07,750
the<font color="#E5E5E5"> application and when you</font><font color="#CCCCCC"> are</font>

224
00:12:04,930 --> 00:12:12,359
<font color="#E5E5E5">executing this application you'd check</font>

225
00:12:07,750 --> 00:12:15,990
the memory region again<font color="#E5E5E5"> for this data</font>

226
00:12:12,360 --> 00:12:20,140
the next<font color="#E5E5E5"> level is first flush it's</font>

227
00:12:15,990 --> 00:12:24,730
almost the same attack but this time you

228
00:12:20,140 --> 00:12:27,490
don't need<font color="#E5E5E5"> to access the memory so with</font>

229
00:12:24,730 --> 00:12:31,750
<font color="#E5E5E5">version</font><font color="#CCCCCC"> 2 volt</font><font color="#E5E5E5"> at certain points you get</font>

230
00:12:27,490 --> 00:12:35,410
cache miss and CPUs currently all CPUs

231
00:12:31,750 --> 00:12:37,450
<font color="#CCCCCC">have performance counters inside of them</font>

232
00:12:35,410 --> 00:12:40,150
and you can actually count<font color="#E5E5E5"> how</font><font color="#CCCCCC"> many</font>

233
00:12:37,450 --> 00:12:44,170
<font color="#E5E5E5">times you go out the cache miss so</font><font color="#CCCCCC"> if</font>

234
00:12:40,150 --> 00:12:46,870
you try to address the attack and detect

235
00:12:44,170 --> 00:12:48,540
it by simply checking for<font color="#E5E5E5"> the cache</font>

236
00:12:46,870 --> 00:12:52,089
misses

237
00:12:48,540 --> 00:12:54,879
you're not in work<font color="#E5E5E5"> because someone would</font>

238
00:12:52,089 --> 00:12:56,859
simply switch<font color="#CCCCCC"> to the next attack two</font>

239
00:12:54,879 --> 00:12:59,470
<font color="#E5E5E5">years later first first which only</font>

240
00:12:56,859 --> 00:13:06,040
requires for you to flush and force

241
00:12:59,470 --> 00:13:10,629
again<font color="#CCCCCC"> the caches you are only</font><font color="#E5E5E5"> observing</font>

242
00:13:06,040 --> 00:13:15,248
the time it takes<font color="#E5E5E5"> for</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> CPU to execute</font>

243
00:13:10,629 --> 00:13:18,519
<font color="#E5E5E5">then for the code in the first let</font><font color="#CCCCCC"> me</font>

244
00:13:15,249 --> 00:13:20,379
start again with first force you<font color="#E5E5E5"> have</font>

245
00:13:18,519 --> 00:13:24,160
the same<font color="#E5E5E5"> shared library you</font><font color="#CCCCCC"> want</font><font color="#E5E5E5"> it</font>

246
00:13:20,379 --> 00:13:26,679
directly but instead<font color="#CCCCCC"> of</font><font color="#E5E5E5"> checking the</font>

247
00:13:24,160 --> 00:13:30,059
memory if it is there you're simply

248
00:13:26,679 --> 00:13:33,608
checking<font color="#CCCCCC"> how much time it takes</font><font color="#E5E5E5"> for the</font>

249
00:13:30,059 --> 00:13:36,160
<font color="#E5E5E5">clear cache</font><font color="#CCCCCC"> fine force command to</font>

250
00:13:33,609 --> 00:13:39,639
execute<font color="#E5E5E5"> if the cache is actually full</font>

251
00:13:36,160 --> 00:13:43,209
with data<font color="#CCCCCC"> co-wash the seal force</font>

252
00:13:39,639 --> 00:13:48,429
instruction<font color="#E5E5E5"> who take longer and then if</font>

253
00:13:43,209 --> 00:13:50,108
it if it<font color="#E5E5E5"> is already empty so you don't</font>

254
00:13:48,429 --> 00:13:52,689
need to access the memory at all

255
00:13:50,109 --> 00:13:55,379
you<font color="#E5E5E5"> simply clear the cache and you can</font>

256
00:13:52,689 --> 00:14:00,610
clear<font color="#E5E5E5"> the cache from within</font><font color="#CCCCCC"> different</font>

257
00:13:55,379 --> 00:14:02,949
process and you can time the clearing of

258
00:14:00,610 --> 00:14:07,589
the cache in different process in

259
00:14:02,949 --> 00:14:11,128
different<font color="#E5E5E5"> user on the same machine so</font>

260
00:14:07,589 --> 00:14:14,639
these are<font color="#E5E5E5"> for</font><font color="#CCCCCC"> center out and force force</font>

261
00:14:11,129 --> 00:14:19,470
attacks<font color="#CCCCCC"> any questions here because I</font>

262
00:14:14,639 --> 00:14:19,470
think<font color="#E5E5E5"> some people don't understand it</font>

263
00:14:19,660 --> 00:14:28,060
<font color="#E5E5E5">okay I'll take questions later so we</font>

264
00:14:24,130 --> 00:14:31,480
first<font color="#E5E5E5"> dated in real yep first again so</font>

265
00:14:28,060 --> 00:14:35,219
both of these attacks required<font color="#CCCCCC"> CPU</font>

266
00:14:31,480 --> 00:14:38,530
<font color="#E5E5E5">fishing but forcing the cache is</font>

267
00:14:35,220 --> 00:14:41,320
instruction that you can actually check

268
00:14:38,530 --> 00:14:44,350
<font color="#E5E5E5">how many times is executed and</font><font color="#CCCCCC"> you</font>

269
00:14:41,320 --> 00:14:48,880
currently have<font color="#E5E5E5"> two full instructions</font><font color="#CCCCCC"> see</font>

270
00:14:44,350 --> 00:14:53,680
<font color="#E5E5E5">of wash and see of wash opt and the</font>

271
00:14:48,880 --> 00:14:56,470
other side the<font color="#CCCCCC"> other possible attack</font>

272
00:14:53,680 --> 00:14:58,989
vector here is not<font color="#E5E5E5"> forcing the cache but</font>

273
00:14:56,470 --> 00:15:01,840
filling the cache with data<font color="#E5E5E5"> that you</font>

274
00:14:58,990 --> 00:15:04,030
already<font color="#E5E5E5"> know so this is related only to</font>

275
00:15:01,840 --> 00:15:07,150
<font color="#CCCCCC">force entry</font><font color="#E5E5E5"> world if you force the cache</font>

276
00:15:04,030 --> 00:15:09,939
with data that<font color="#CCCCCC"> you already</font><font color="#E5E5E5"> know and you</font>

277
00:15:07,150 --> 00:15:12,100
<font color="#CCCCCC">want other data there you don't</font><font color="#E5E5E5"> need to</font>

278
00:15:09,940 --> 00:15:15,430
force<font color="#CCCCCC"> the cash you need to simply check</font>

279
00:15:12,100 --> 00:15:18,820
if your data is<font color="#CCCCCC"> not there if it is not</font>

280
00:15:15,430 --> 00:15:21,760
your data then other data is on<font color="#E5E5E5"> the same</font>

281
00:15:18,820 --> 00:15:24,820
in the same memory region<font color="#E5E5E5"> this is</font>

282
00:15:21,760 --> 00:15:29,230
actually used in<font color="#CCCCCC"> the Spector attacks</font><font color="#E5E5E5"> so</font>

283
00:15:24,820 --> 00:15:33,000
in<font color="#CCCCCC"> January</font><font color="#E5E5E5"> this talk was started in</font>

284
00:15:29,230 --> 00:15:37,270
January simply<font color="#E5E5E5"> because in</font><font color="#CCCCCC"> January - very</font>

285
00:15:33,000 --> 00:15:40,480
annoying for<font color="#CCCCCC"> severe guys attacks</font><font color="#E5E5E5"> came</font>

286
00:15:37,270 --> 00:15:44,370
<font color="#E5E5E5">out</font><font color="#CCCCCC"> meltdown inspector and the problem</font>

287
00:15:40,480 --> 00:15:47,830
is not big for<font color="#E5E5E5"> people with desktops but</font>

288
00:15:44,370 --> 00:15:50,260
it's big for<font color="#E5E5E5"> people with servers and</font>

289
00:15:47,830 --> 00:15:53,460
especially<font color="#E5E5E5"> for people like me that</font><font color="#CCCCCC"> learn</font>

290
00:15:50,260 --> 00:15:58,180
a lot<font color="#E5E5E5"> of software that is</font><font color="#CCCCCC"> not their own</font>

291
00:15:53,460 --> 00:16:01,740
so let<font color="#E5E5E5"> me explain more about meltdown</font>

292
00:15:58,180 --> 00:16:04,510
inspector<font color="#E5E5E5"> the idea was that you can use</font>

293
00:16:01,740 --> 00:16:06,760
speculative execution<font color="#CCCCCC"> the</font><font color="#E5E5E5"> side-channel</font>

294
00:16:04,510 --> 00:16:10,240
<font color="#E5E5E5">attacks fortune to halt and first</font><font color="#CCCCCC"> flush</font>

295
00:16:06,760 --> 00:16:14,140
that<font color="#E5E5E5"> I was talking about are only for</font>

296
00:16:10,240 --> 00:16:19,060
the cache of the<font color="#E5E5E5"> CPU there let's say</font>

297
00:16:14,140 --> 00:16:23,350
<font color="#E5E5E5">memory</font><font color="#CCCCCC"> related but the CPU as I started</font>

298
00:16:19,060 --> 00:16:26,680
to explain can execute instructions out

299
00:16:23,350 --> 00:16:28,940
of order<font color="#E5E5E5"> and also can predict what will</font>

300
00:16:26,680 --> 00:16:32,390
happen<font color="#CCCCCC"> at certain</font><font color="#E5E5E5"> point</font>

301
00:16:28,940 --> 00:16:34,880
in your<font color="#E5E5E5"> cold so you're called as you</font>

302
00:16:32,390 --> 00:16:37,910
<font color="#CCCCCC">rotate for</font><font color="#E5E5E5"> example in</font><font color="#CCCCCC"> Beach B converts</font>

303
00:16:34,880 --> 00:16:40,310
to actual instructions<font color="#CCCCCC"> CPU instructions</font>

304
00:16:37,910 --> 00:16:45,140
in the CPU<font color="#E5E5E5"> these instructions can be</font>

305
00:16:40,310 --> 00:16:48,369
executed out of order<font color="#E5E5E5"> and this is</font>

306
00:16:45,140 --> 00:16:52,340
because the branch predictor<font color="#E5E5E5"> can be</font>

307
00:16:48,370 --> 00:16:53,750
taught to actually predict wrong<font color="#E5E5E5"> so the</font>

308
00:16:52,340 --> 00:16:57,490
branch predictor the first branch

309
00:16:53,750 --> 00:17:00,950
predictors<font color="#E5E5E5"> which were like 20 years ago</font>

310
00:16:57,490 --> 00:17:05,599
<font color="#E5E5E5">in the CPUs they were simple very simple</font>

311
00:17:00,950 --> 00:17:09,140
statistics<font color="#E5E5E5"> if the past for example</font><font color="#CCCCCC"> 20</font>

312
00:17:05,599 --> 00:17:12,770
instructions<font color="#CCCCCC"> always evaluated to the if</font>

313
00:17:09,140 --> 00:17:17,270
calls<font color="#E5E5E5"> will go this this</font><font color="#CCCCCC"> way</font><font color="#E5E5E5"> if the past</font>

314
00:17:12,770 --> 00:17:19,609
<font color="#E5E5E5">20 instructions always executed the else</font>

315
00:17:17,270 --> 00:17:23,119
<font color="#CCCCCC">quotes will predict that the next time</font>

316
00:17:19,609 --> 00:17:26,510
<font color="#E5E5E5">we</font><font color="#CCCCCC"> have these 20 instructions will go to</font>

317
00:17:23,119 --> 00:17:29,750
the else<font color="#CCCCCC"> clause of your code with the</font>

318
00:17:26,510 --> 00:17:32,120
newest<font color="#E5E5E5"> CPU architectures you have for</font>

319
00:17:29,750 --> 00:17:35,240
example<font color="#CCCCCC"> MD had neural networks inside of</font>

320
00:17:32,120 --> 00:17:37,909
their CPUs<font color="#E5E5E5"> just to predict the</font>

321
00:17:35,240 --> 00:17:41,300
instructions the outcome of<font color="#CCCCCC"> these</font>

322
00:17:37,910 --> 00:17:45,530
<font color="#E5E5E5">instructions in to have more complex</font>

323
00:17:41,300 --> 00:17:48,669
logic for predicting<font color="#CCCCCC"> the branch the</font>

324
00:17:45,530 --> 00:17:51,139
correct outcome of the branching so

325
00:17:48,670 --> 00:17:54,290
different architectures but the same

326
00:17:51,140 --> 00:17:57,740
thing if you have a lot of executions of

327
00:17:54,290 --> 00:18:00,139
<font color="#E5E5E5">the same thing you can train the branch</font>

328
00:17:57,740 --> 00:18:02,390
predictor to miss predict the<font color="#E5E5E5"> actual</font>

329
00:18:00,140 --> 00:18:04,850
execution<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is not a security problem</font>

330
00:18:02,390 --> 00:18:07,850
<font color="#E5E5E5">simply because</font><font color="#CCCCCC"> at the end</font><font color="#E5E5E5"> of the</font>

331
00:18:04,850 --> 00:18:10,340
<font color="#CCCCCC">execution the CPU will check if this was</font>

332
00:18:07,850 --> 00:18:13,429
<font color="#CCCCCC">the</font><font color="#E5E5E5"> correct prediction and if it wasn't</font>

333
00:18:10,340 --> 00:18:17,419
<font color="#E5E5E5">it will swap</font><font color="#CCCCCC"> the results this</font><font color="#E5E5E5"> is not a</font>

334
00:18:13,430 --> 00:18:20,330
problem<font color="#CCCCCC"> the problem</font><font color="#E5E5E5"> is that since we</font>

335
00:18:17,420 --> 00:18:24,170
miss predicted<font color="#E5E5E5"> the result and we</font>

336
00:18:20,330 --> 00:18:27,139
executed<font color="#CCCCCC"> the wrong path and in the wrong</font>

337
00:18:24,170 --> 00:18:29,810
path<font color="#CCCCCC"> we actually put data that we</font>

338
00:18:27,140 --> 00:18:32,930
weren't<font color="#E5E5E5"> supposed to pull and we put it</font>

339
00:18:29,810 --> 00:18:35,690
<font color="#E5E5E5">inside the cache</font><font color="#CCCCCC"> the last level cache</font>

340
00:18:32,930 --> 00:18:37,750
the layer<font color="#E5E5E5"> 3 cache what happened was</font>

341
00:18:35,690 --> 00:18:41,289
written

342
00:18:37,750 --> 00:18:47,679
and let me sorry<font color="#CCCCCC"> I can go back to the</font>

343
00:18:41,289 --> 00:18:50,559
architecture here so since we have this

344
00:18:47,679 --> 00:18:53,590
data in the last layer cache and it is

345
00:18:50,559 --> 00:18:55,600
not removed<font color="#CCCCCC"> from there</font><font color="#E5E5E5"> it's simply it's</font>

346
00:18:53,590 --> 00:18:57,580
not<font color="#E5E5E5"> removed because this was</font>

347
00:18:55,600 --> 00:19:01,719
<font color="#E5E5E5">misprediction and</font><font color="#CCCCCC"> ii don't care about</font>

348
00:18:57,580 --> 00:19:04,210
<font color="#E5E5E5">this data it will not go to the user it</font>

349
00:19:01,720 --> 00:19:06,370
<font color="#CCCCCC">will not reach the user but it stays in</font>

350
00:19:04,210 --> 00:19:08,440
the layer 3 cache and this is why<font color="#E5E5E5"> I</font>

351
00:19:06,370 --> 00:19:10,479
<font color="#E5E5E5">started</font><font color="#CCCCCC"> with the first</font><font color="#E5E5E5"> person</font><font color="#CCCCCC"> first</font><font color="#E5E5E5"> and</font>

352
00:19:08,440 --> 00:19:12,399
<font color="#E5E5E5">throughout attacks because if you have</font>

353
00:19:10,480 --> 00:19:14,799
something<font color="#E5E5E5"> in</font><font color="#CCCCCC"> the cache you</font><font color="#E5E5E5"> already have</font>

354
00:19:12,399 --> 00:19:18,489
attack vectors to read this data from

355
00:19:14,799 --> 00:19:21,759
<font color="#E5E5E5">the cache so combine the reading of the</font>

356
00:19:18,490 --> 00:19:24,879
cache and this<font color="#E5E5E5"> misprediction and to get</font>

357
00:19:21,759 --> 00:19:27,549
a<font color="#E5E5E5"> possibility</font><font color="#CCCCCC"> of a process a normal</font>

358
00:19:24,879 --> 00:19:31,029
process<font color="#E5E5E5"> normal user space process to</font>

359
00:19:27,549 --> 00:19:35,429
<font color="#E5E5E5">actually read any data inside the memory</font>

360
00:19:31,029 --> 00:19:39,490
<font color="#CCCCCC">any data which is</font><font color="#E5E5E5"> very annoying for</font>

361
00:19:35,429 --> 00:19:43,120
people<font color="#E5E5E5"> that are on other</font><font color="#CCCCCC"> else's code</font>

362
00:19:39,490 --> 00:19:47,850
because obviously when you don't control

363
00:19:43,120 --> 00:19:47,850
the<font color="#E5E5E5"> code now you cannot fix the code and</font>

364
00:19:48,000 --> 00:19:53,320
this code<font color="#E5E5E5"> actually can attack anything</font>

365
00:19:50,679 --> 00:19:56,590
<font color="#CCCCCC">from</font><font color="#E5E5E5"> your machine it can read your SSH</font>

366
00:19:53,320 --> 00:20:02,259
keys<font color="#E5E5E5"> it carried passwords</font><font color="#CCCCCC"> it can do</font><font color="#E5E5E5"> it</font>

367
00:19:56,590 --> 00:20:04,769
credit cards and stuff<font color="#E5E5E5"> like this</font><font color="#CCCCCC"> so the</font>

368
00:20:02,259 --> 00:20:08,909
branch predictor can be trained

369
00:20:04,769 --> 00:20:11,830
misprediction actually causes the<font color="#CCCCCC"> cpu to</font>

370
00:20:08,909 --> 00:20:14,139
<font color="#E5E5E5">execute the wrong instructions the</font>

371
00:20:11,830 --> 00:20:17,379
instructions<font color="#E5E5E5"> will end up in for example</font>

372
00:20:14,139 --> 00:20:21,610
the<font color="#CCCCCC"> FPO or the integer cluster and these</font>

373
00:20:17,379 --> 00:20:24,908
<font color="#E5E5E5">devices will actually call for</font><font color="#CCCCCC"> the data</font>

374
00:20:21,610 --> 00:20:28,229
and<font color="#E5E5E5"> the data will be</font><font color="#CCCCCC"> stored in layer 2</font>

375
00:20:24,909 --> 00:20:28,230
and layer 3 caches

376
00:20:33,019 --> 00:20:39,570
<font color="#E5E5E5">okay so the other thing is that as I</font>

377
00:20:37,200 --> 00:20:42,749
<font color="#CCCCCC">said most</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> the modern architectures</font>

378
00:20:39,570 --> 00:20:46,019
<font color="#E5E5E5">have multiple threads on the same core</font>

379
00:20:42,749 --> 00:20:48,960
these multiple threads are not<font color="#E5E5E5"> other</font>

380
00:20:46,019 --> 00:20:52,139
course<font color="#E5E5E5"> so they're not the same</font><font color="#CCCCCC"> thing as</font>

381
00:20:48,960 --> 00:20:53,999
a real core but what happens is<font color="#CCCCCC"> for</font>

382
00:20:52,139 --> 00:20:56,178
<font color="#CCCCCC">example you have one faulting point</font>

383
00:20:53,999 --> 00:20:58,529
instruction that is executing this way

384
00:20:56,179 --> 00:21:01,080
<font color="#E5E5E5">it is going through</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> floating point</font>

385
00:20:58,529 --> 00:21:05,220
<font color="#E5E5E5">unit but at this point the integer unit</font>

386
00:21:01,080 --> 00:21:09,360
is free to execute<font color="#CCCCCC"> whatever you want</font><font color="#E5E5E5"> so</font>

387
00:21:05,220 --> 00:21:11,999
if you have instructions<font color="#CCCCCC"> that are</font><font color="#E5E5E5"> not</font>

388
00:21:09,360 --> 00:21:14,748
all floating point<font color="#E5E5E5"> or not</font><font color="#CCCCCC"> all integers</font>

389
00:21:11,999 --> 00:21:17,190
<font color="#E5E5E5">you could actually execute multiple</font>

390
00:21:14,749 --> 00:21:20,820
threads<font color="#E5E5E5"> at the same time and this is</font>

391
00:21:17,190 --> 00:21:23,759
this is multi-threading so you have to

392
00:21:20,820 --> 00:21:28,320
know that<font color="#E5E5E5"> most of the new CPUs actually</font>

393
00:21:23,759 --> 00:21:31,649
have eight or more<font color="#E5E5E5"> integer integer</font>

394
00:21:28,320 --> 00:21:35,779
clusters or integer execution units and

395
00:21:31,649 --> 00:21:38,580
have two or<font color="#CCCCCC"> more</font><font color="#E5E5E5"> floating point units</font>

396
00:21:35,779 --> 00:21:42,029
<font color="#E5E5E5">everything below has well for Intel for</font>

397
00:21:38,580 --> 00:21:46,289
example<font color="#E5E5E5"> everything other than two years</font>

398
00:21:42,029 --> 00:21:50,759
for<font color="#CCCCCC"> AMD has only one</font><font color="#E5E5E5"> floating-point unit</font>

399
00:21:46,289 --> 00:21:54,200
but has multiple integers<font color="#E5E5E5"> for all the</font>

400
00:21:50,759 --> 00:21:57,809
new instructions that you have a seed

401
00:21:54,200 --> 00:22:00,629
<font color="#E5E5E5">nvx and so on you'd have other units</font>

402
00:21:57,809 --> 00:22:03,090
<font color="#E5E5E5">inside the CPU that can be used for this</font>

403
00:22:00,629 --> 00:22:06,449
<font color="#E5E5E5">this means that you can in</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> same time</font>

404
00:22:03,090 --> 00:22:08,100
execute<font color="#E5E5E5"> AVX instruction into integer</font>

405
00:22:06,450 --> 00:22:11,159
instruction<font color="#E5E5E5"> faulting point instruction</font>

406
00:22:08,100 --> 00:22:13,110
in the same<font color="#E5E5E5"> CPU in the same cycle so</font>

407
00:22:11,159 --> 00:22:18,779
this<font color="#E5E5E5"> means</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> you essentially have</font>

408
00:22:13,110 --> 00:22:21,869
three frets<font color="#E5E5E5"> but this is software</font><font color="#CCCCCC"> bound</font>

409
00:22:18,779 --> 00:22:25,999
to two or four threads per core

410
00:22:21,869 --> 00:22:28,980
depending on the marketing<font color="#E5E5E5"> of this chip</font>

411
00:22:25,999 --> 00:22:34,019
<font color="#E5E5E5">this is software change for the same</font>

412
00:22:28,980 --> 00:22:37,139
chip so you get this multi-threading<font color="#E5E5E5"> but</font>

413
00:22:34,019 --> 00:22:39,210
in this case the integer instruction and

414
00:22:37,139 --> 00:22:43,408
the floating<font color="#E5E5E5"> point instruction</font>

415
00:22:39,210 --> 00:22:46,529
share the same<font color="#CCCCCC"> cache and since you have</font>

416
00:22:43,409 --> 00:22:48,720
multiple integer<font color="#E5E5E5"> execution units</font><font color="#CCCCCC"> you</font>

417
00:22:46,529 --> 00:22:51,990
could have multiple integer instructions

418
00:22:48,720 --> 00:22:54,179
that<font color="#E5E5E5"> are requesting the same cache so</font>

419
00:22:51,990 --> 00:22:57,720
executing the first version<font color="#E5E5E5"> percent of</font>

420
00:22:54,179 --> 00:23:00,240
<font color="#E5E5E5">all the tax on the</font><font color="#CCCCCC"> same cycle you are</font>

421
00:22:57,720 --> 00:23:05,100
<font color="#E5E5E5">actually getting the data</font><font color="#CCCCCC"> miss predicted</font>

422
00:23:00,240 --> 00:23:08,549
data by meltdown so<font color="#E5E5E5"> meltdown</font>

423
00:23:05,100 --> 00:23:11,908
most people decided<font color="#CCCCCC"> that they would</font>

424
00:23:08,549 --> 00:23:14,309
<font color="#E5E5E5">simply fix this problem by on mapping</font>

425
00:23:11,909 --> 00:23:17,340
<font color="#CCCCCC">the</font><font color="#E5E5E5"> kernel memory from the user space</font>

426
00:23:14,309 --> 00:23:20,580
currently<font color="#CCCCCC"> okay let's let</font><font color="#E5E5E5"> them say</font>

427
00:23:17,340 --> 00:23:25,678
currently but quite before January this

428
00:23:20,580 --> 00:23:27,600
year<font color="#CCCCCC"> both</font><font color="#E5E5E5"> Windows and Linux</font><font color="#CCCCCC"> shared the</font>

429
00:23:25,679 --> 00:23:30,059
memory this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> memory space that you</font>

430
00:23:27,600 --> 00:23:33,600
<font color="#CCCCCC">see here shared the memory between</font><font color="#E5E5E5"> the</font>

431
00:23:30,059 --> 00:23:36,990
user space<font color="#E5E5E5"> and the kernel and you</font>

432
00:23:33,600 --> 00:23:42,330
<font color="#CCCCCC">actually could see them mapped kernel</font>

433
00:23:36,990 --> 00:23:44,580
pages<font color="#E5E5E5"> inside</font><font color="#CCCCCC"> your viewer process you</font>

434
00:23:42,330 --> 00:23:49,529
simply didn't have access<font color="#E5E5E5"> to them</font>

435
00:23:44,580 --> 00:23:54,510
because<font color="#E5E5E5"> you require ring</font><font color="#CCCCCC"> 0</font><font color="#E5E5E5"> access to</font>

436
00:23:49,529 --> 00:23:57,210
this so you<font color="#CCCCCC"> could see</font><font color="#E5E5E5"> the addresses but</font>

437
00:23:54,510 --> 00:24:02,158
you cannot access<font color="#E5E5E5"> them so the protection</font>

438
00:23:57,210 --> 00:24:04,559
<font color="#E5E5E5">was that we will split this okay we'll</font>

439
00:24:02,159 --> 00:24:07,140
split this<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> will leave</font><font color="#E5E5E5"> a few</font>

440
00:24:04,559 --> 00:24:12,270
pointers inside the user space that can

441
00:24:07,140 --> 00:24:16,200
be<font color="#CCCCCC"> used</font><font color="#E5E5E5"> to access the memory but</font><font color="#CCCCCC"> your</font>

442
00:24:12,270 --> 00:24:18,960
<font color="#E5E5E5">sis system calls which means that before</font>

443
00:24:16,200 --> 00:24:21,870
<font color="#E5E5E5">we splitted the memory when we execute</font>

444
00:24:18,960 --> 00:24:24,510
<font color="#E5E5E5">the system call we could leave the data</font>

445
00:24:21,870 --> 00:24:26,610
inside user space memory<font color="#E5E5E5"> and the system</font>

446
00:24:24,510 --> 00:24:28,970
call would have<font color="#E5E5E5"> an address</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> is</font>

447
00:24:26,610 --> 00:24:31,949
actually reachable from kernel space

448
00:24:28,970 --> 00:24:35,130
inside user space and you won't need<font color="#CCCCCC"> to</font>

449
00:24:31,950 --> 00:24:37,230
translate<font color="#E5E5E5"> copy this data from user space</font>

450
00:24:35,130 --> 00:24:41,039
<font color="#E5E5E5">to kernel space</font><font color="#CCCCCC"> you simply need to have</font>

451
00:24:37,230 --> 00:24:43,710
the correct others with kernel page

452
00:24:41,039 --> 00:24:47,629
table is relation or<font color="#CCCCCC"> kpti you actually</font>

453
00:24:43,710 --> 00:24:47,630
split this and you need to have

454
00:24:47,650 --> 00:24:54,040
<font color="#E5E5E5">this code that</font><font color="#CCCCCC"> will actually copy your</font>

455
00:24:50,800 --> 00:24:56,680
data<font color="#CCCCCC"> since now you're introducing</font>

456
00:24:54,040 --> 00:24:59,470
copying of data<font color="#CCCCCC"> this is actually slowing</font>

457
00:24:56,680 --> 00:25:01,930
down your processes<font color="#E5E5E5"> simply because every</font>

458
00:24:59,470 --> 00:25:04,240
time<font color="#E5E5E5"> that</font><font color="#CCCCCC"> you're requesting</font><font color="#E5E5E5"> the kernel</font>

459
00:25:01,930 --> 00:25:06,310
to do something for you<font color="#E5E5E5"> you'd actually</font>

460
00:25:04,240 --> 00:25:10,930
need to copy the data to<font color="#CCCCCC"> the kernel</font>

461
00:25:06,310 --> 00:25:14,320
first<font color="#CCCCCC"> meltdown actually uses can be</font>

462
00:25:10,930 --> 00:25:17,850
<font color="#E5E5E5">exported by using</font><font color="#CCCCCC"> fortune to worlds or</font>

463
00:25:14,320 --> 00:25:19,870
for sauce<font color="#CCCCCC"> and you also need</font>

464
00:25:17,850 --> 00:25:22,600
transactional restrictions I'll talk

465
00:25:19,870 --> 00:25:25,060
about<font color="#CCCCCC"> them in a bit you can use either</font>

466
00:25:22,600 --> 00:25:30,580
transactional institutions or you can

467
00:25:25,060 --> 00:25:33,040
use a<font color="#E5E5E5"> process that you spawn and it will</font>

468
00:25:30,580 --> 00:25:35,020
die because of<font color="#CCCCCC"> the misprediction</font><font color="#E5E5E5"> it will</font>

469
00:25:33,040 --> 00:25:37,120
die with segmentation<font color="#E5E5E5"> fault because it</font>

470
00:25:35,020 --> 00:25:40,360
tries to<font color="#E5E5E5"> access</font><font color="#CCCCCC"> memory that it should</font>

471
00:25:37,120 --> 00:25:42,280
not access<font color="#E5E5E5"> in first place and the kernel</font>

472
00:25:40,360 --> 00:25:42,760
stops it with the segmentation<font color="#CCCCCC"> fault</font>

473
00:25:42,280 --> 00:25:46,389
<font color="#CCCCCC">error</font>

474
00:25:42,760 --> 00:25:49,770
however the<font color="#E5E5E5"> CPU already got your data in</font>

475
00:25:46,390 --> 00:25:53,110
<font color="#CCCCCC">the cache and</font><font color="#E5E5E5"> pirate process simply</font>

476
00:25:49,770 --> 00:25:56,139
checks this cache info and gets the data

477
00:25:53,110 --> 00:25:59,520
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> very nice attack it's pretty genius</font>

478
00:25:56,140 --> 00:26:02,530
and nice<font color="#E5E5E5"> and simple</font><font color="#CCCCCC"> the problem is</font><font color="#E5E5E5"> that</font>

479
00:25:59,520 --> 00:26:04,720
most<font color="#E5E5E5"> programs actually don't work this</font>

480
00:26:02,530 --> 00:26:07,930
<font color="#E5E5E5">way so you don't have a program</font><font color="#CCCCCC"> that</font>

481
00:26:04,720 --> 00:26:10,570
spawns a child and the child's main

482
00:26:07,930 --> 00:26:13,390
purpose is to die you don't<font color="#E5E5E5"> have</font>

483
00:26:10,570 --> 00:26:16,810
programs<font color="#CCCCCC"> like this or most of us don't</font>

484
00:26:13,390 --> 00:26:19,180
write programs like this so this<font color="#CCCCCC"> is an</font>

485
00:26:16,810 --> 00:26:22,360
exception of behavior<font color="#CCCCCC"> that you can</font>

486
00:26:19,180 --> 00:26:24,010
pretty easily observe on<font color="#E5E5E5"> the machine if</font>

487
00:26:22,360 --> 00:26:27,129
<font color="#E5E5E5">there is a process that is constantly</font>

488
00:26:24,010 --> 00:26:29,020
<font color="#E5E5E5">spawning process that</font><font color="#CCCCCC"> die this is</font>

489
00:26:27,130 --> 00:26:32,560
something there's<font color="#E5E5E5"> something fishy</font><font color="#CCCCCC"> here</font>

490
00:26:29,020 --> 00:26:35,050
and instead<font color="#E5E5E5"> of</font><font color="#CCCCCC"> splitting</font><font color="#E5E5E5"> the kernel and</font>

491
00:26:32,560 --> 00:26:38,860
<font color="#CCCCCC">user</font><font color="#E5E5E5"> space memory you can actually try</font>

492
00:26:35,050 --> 00:26:41,879
<font color="#CCCCCC">to detect</font><font color="#E5E5E5"> these events and protect your</font>

493
00:26:38,860 --> 00:26:45,969
machine<font color="#E5E5E5"> this way however</font><font color="#CCCCCC"> this is not a</font>

494
00:26:41,880 --> 00:26:48,640
perfect<font color="#CCCCCC"> solution first of all you're</font>

495
00:26:45,970 --> 00:26:51,790
<font color="#CCCCCC">still</font><font color="#E5E5E5"> you still have at least one child</font>

496
00:26:48,640 --> 00:26:55,030
<font color="#E5E5E5">process that</font><font color="#CCCCCC"> process that will die</font><font color="#E5E5E5"> this</font>

497
00:26:51,790 --> 00:26:57,399
will leak<font color="#E5E5E5"> around</font><font color="#CCCCCC"> four kilobytes of data</font>

498
00:26:55,030 --> 00:27:00,220
so you can<font color="#CCCCCC"> leak 4 kilobytes of data</font>

499
00:26:57,400 --> 00:27:02,620
<font color="#E5E5E5">before you actually detect this and stop</font>

500
00:27:00,220 --> 00:27:07,870
it<font color="#E5E5E5"> even</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> managed to</font><font color="#E5E5E5"> stop it the</font>

501
00:27:02,620 --> 00:27:11,080
first place<font color="#E5E5E5"> if it dies</font><font color="#CCCCCC"> in order</font><font color="#E5E5E5"> to make</font>

502
00:27:07,870 --> 00:27:14,260
meltdown work better<font color="#CCCCCC"> you actually have</font>

503
00:27:11,080 --> 00:27:17,470
to shadow the<font color="#CCCCCC"> child process on the same</font>

504
00:27:14,260 --> 00:27:20,200
<font color="#E5E5E5">CPU where the parent is because this way</font>

505
00:27:17,470 --> 00:27:24,460
the parent can access the same cache

506
00:27:20,200 --> 00:27:26,680
memory if you don't do this<font color="#CCCCCC"> on machine</font>

507
00:27:24,460 --> 00:27:28,300
with multiple cores<font color="#CCCCCC"> and</font><font color="#E5E5E5"> I'm not talking</font>

508
00:27:26,680 --> 00:27:31,840
about laptops<font color="#E5E5E5"> or I'm talking about</font>

509
00:27:28,300 --> 00:27:36,100
machines<font color="#E5E5E5"> with 2014 more cores on a</font>

510
00:27:31,840 --> 00:27:38,169
single CPU<font color="#CCCCCC"> it's a little bit more</font><font color="#E5E5E5"> tricky</font>

511
00:27:36,100 --> 00:27:42,669
to<font color="#CCCCCC"> actually trigger the same thing</font>

512
00:27:38,170 --> 00:27:44,890
<font color="#E5E5E5">because the misprediction who will</font>

513
00:27:42,670 --> 00:27:46,570
happen every time<font color="#E5E5E5"> on different</font><font color="#CCCCCC"> the</font>

514
00:27:44,890 --> 00:27:50,950
branch predictor that<font color="#CCCCCC"> you're accessing</font>

515
00:27:46,570 --> 00:27:53,169
<font color="#E5E5E5">will be not every time but a lot</font><font color="#CCCCCC"> of</font>

516
00:27:50,950 --> 00:27:55,420
<font color="#E5E5E5">times would</font><font color="#CCCCCC"> be on different cores so you</font>

517
00:27:53,170 --> 00:27:57,730
would be to actually<font color="#CCCCCC"> training different</font>

518
00:27:55,420 --> 00:28:02,920
<font color="#CCCCCC">cores</font><font color="#E5E5E5"> net your own core that actually</font>

519
00:27:57,730 --> 00:28:04,810
can detect this so in<font color="#CCCCCC"> order</font><font color="#E5E5E5"> to be more</font>

520
00:28:02,920 --> 00:28:08,650
<font color="#E5E5E5">effective with meltdown</font><font color="#CCCCCC"> you actually</font>

521
00:28:04,810 --> 00:28:11,050
have to<font color="#E5E5E5"> issue one Cisco and it's in</font>

522
00:28:08,650 --> 00:28:14,200
Linux it's called set affinity<font color="#CCCCCC"> you</font>

523
00:28:11,050 --> 00:28:16,300
<font color="#E5E5E5">actually have to pin your child process</font>

524
00:28:14,200 --> 00:28:21,580
on the same CPU where your part

525
00:28:16,300 --> 00:28:24,810
processes<font color="#CCCCCC"> Quechua and full</font><font color="#E5E5E5"> instructions</font>

526
00:28:21,580 --> 00:28:28,090
<font color="#CCCCCC">are userspace</font><font color="#E5E5E5"> they are not privileged</font>

527
00:28:24,810 --> 00:28:34,030
instructions however<font color="#E5E5E5"> setting affinity of</font>

528
00:28:28,090 --> 00:28:37,929
<font color="#E5E5E5">your CPU</font><font color="#CCCCCC"> your process to another CPU</font><font color="#E5E5E5"> is</font>

529
00:28:34,030 --> 00:28:40,030
privileged operation it requires the

530
00:28:37,930 --> 00:28:43,630
kernel to do something for you<font color="#E5E5E5"> and it</font>

531
00:28:40,030 --> 00:28:46,930
requires<font color="#CCCCCC"> a</font><font color="#E5E5E5"> system Cisco in the kernel</font>

532
00:28:43,630 --> 00:28:49,930
you actually can grab this<font color="#E5E5E5"> Cisco</font>

533
00:28:46,930 --> 00:28:52,270
check it and beside what we want to do

534
00:28:49,930 --> 00:28:54,750
and I'll explain a little<font color="#E5E5E5"> bit</font><font color="#CCCCCC"> more about</font>

535
00:28:52,270 --> 00:28:54,750
<font color="#E5E5E5">this</font><font color="#CCCCCC"> later</font>

536
00:28:54,760 --> 00:29:01,230
general<font color="#E5E5E5"> thing is the spectral attack the</font>

537
00:28:58,300 --> 00:29:04,909
<font color="#CCCCCC">specter attack was similar to</font>

538
00:29:01,230 --> 00:29:07,440
down<font color="#E5E5E5"> however it works inside</font><font color="#CCCCCC"> the same</font>

539
00:29:04,910 --> 00:29:09,660
process<font color="#E5E5E5"> only inside</font><font color="#CCCCCC"> the same process</font>

540
00:29:07,440 --> 00:29:12,390
<font color="#CCCCCC">this means</font><font color="#E5E5E5"> that it can attack</font><font color="#CCCCCC"> things</font>

541
00:29:09,660 --> 00:29:15,140
<font color="#CCCCCC">like for example</font><font color="#E5E5E5"> my sequel with stored</font>

542
00:29:12,390 --> 00:29:19,110
procedure<font color="#E5E5E5"> or your browser with</font>

543
00:29:15,140 --> 00:29:22,049
JavaScript<font color="#E5E5E5"> so on the server</font><font color="#CCCCCC"> you can use</font>

544
00:29:19,110 --> 00:29:25,530
it okay if we<font color="#CCCCCC"> use SQL injections as the</font>

545
00:29:22,049 --> 00:29:28,400
previous talk<font color="#CCCCCC"> was talking about we can</font>

546
00:29:25,530 --> 00:29:31,168
use SQL injection to actually infuse

547
00:29:28,400 --> 00:29:37,080
generate<font color="#CCCCCC"> Specter</font><font color="#E5E5E5"> attack on the machine</font>

548
00:29:31,169 --> 00:29:39,750
with the<font color="#CCCCCC"> SQL Server on the desktops it's</font>

549
00:29:37,080 --> 00:29:42,629
usually JavaScript that<font color="#E5E5E5"> is used the idea</font>

550
00:29:39,750 --> 00:29:47,160
is that<font color="#E5E5E5"> you'll need a code that is</font>

551
00:29:42,630 --> 00:29:52,650
<font color="#E5E5E5">called it's called</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> gadget it's simple</font>

552
00:29:47,160 --> 00:29:55,980
<font color="#E5E5E5">if that after the misprediction has a</font>

553
00:29:52,650 --> 00:30:00,090
<font color="#E5E5E5">request to an array and you have the</font>

554
00:29:55,980 --> 00:30:05,700
value of this array<font color="#E5E5E5"> so for example if</font>

555
00:30:00,090 --> 00:30:08,580
you want the second part of the re<font color="#E5E5E5"> you'd</font>

556
00:30:05,700 --> 00:30:12,150
need value<font color="#CCCCCC"> one there and if you have</font>

557
00:30:08,580 --> 00:30:14,250
this one<font color="#E5E5E5"> in a variable X and this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> the</font>

558
00:30:12,150 --> 00:30:17,340
X<font color="#E5E5E5"> that you</font><font color="#CCCCCC"> are evaluating in the if</font>

559
00:30:14,250 --> 00:30:20,130
statement<font color="#CCCCCC"> what you'll get is a code that</font>

560
00:30:17,340 --> 00:30:26,309
<font color="#E5E5E5">can be mispredicted</font><font color="#CCCCCC"> and if miss</font>

561
00:30:20,130 --> 00:30:30,090
prediction is wrong it will<font color="#E5E5E5"> die or but</font>

562
00:30:26,309 --> 00:30:33,570
in this dying<font color="#E5E5E5"> it will get the data</font>

563
00:30:30,090 --> 00:30:36,750
because the<font color="#E5E5E5"> I request for this</font><font color="#CCCCCC"> X would</font>

564
00:30:33,570 --> 00:30:39,780
<font color="#CCCCCC">be actually handled by the CPU and you'd</font>

565
00:30:36,750 --> 00:30:44,280
get<font color="#E5E5E5"> the data for this value inside</font><font color="#CCCCCC"> the</font>

566
00:30:39,780 --> 00:30:48,480
cache<font color="#E5E5E5"> you would get the data inside</font><font color="#CCCCCC"> the</font>

567
00:30:44,280 --> 00:30:51,480
memory<font color="#CCCCCC"> space of your current process so</font>

568
00:30:48,480 --> 00:30:55,380
for<font color="#E5E5E5"> me this</font><font color="#CCCCCC"> is not a big</font><font color="#E5E5E5"> deal because I</font>

569
00:30:51,480 --> 00:30:57,690
work on the server side however<font color="#E5E5E5"> it's</font><font color="#CCCCCC"> too</font>

570
00:30:55,380 --> 00:31:02,309
a problem for a lot<font color="#E5E5E5"> of</font><font color="#CCCCCC"> applications that</font>

571
00:30:57,690 --> 00:31:05,040
<font color="#E5E5E5">execute someone else's code inside</font><font color="#CCCCCC"> the</font>

572
00:31:02,309 --> 00:31:07,530
context of the application<font color="#CCCCCC"> so there</font><font color="#E5E5E5"> is a</font>

573
00:31:05,040 --> 00:31:11,340
<font color="#CCCCCC">solution at least in loops and UNIX</font>

574
00:31:07,530 --> 00:31:13,270
environments<font color="#CCCCCC"> you can use</font><font color="#E5E5E5"> something</font>

575
00:31:11,340 --> 00:31:19,300
called<font color="#E5E5E5"> return oriented</font>

576
00:31:13,270 --> 00:31:21,610
or inserting the results at the

577
00:31:19,300 --> 00:31:23,980
beginning of your function<font color="#E5E5E5"> instead</font><font color="#CCCCCC"> of</font>

578
00:31:21,610 --> 00:31:26,080
the end of<font color="#CCCCCC"> your function so your results</font>

579
00:31:23,980 --> 00:31:28,870
have to<font color="#CCCCCC"> go there in the beginning and</font>

580
00:31:26,080 --> 00:31:34,840
<font color="#CCCCCC">you have to</font><font color="#E5E5E5"> turn</font><font color="#CCCCCC"> back there</font><font color="#E5E5E5"> to get this</font>

581
00:31:28,870 --> 00:31:38,050
data and this way this<font color="#CCCCCC"> is simple if that</font>

582
00:31:34,840 --> 00:31:41,169
I explained<font color="#E5E5E5"> simply breaks because you</font>

583
00:31:38,050 --> 00:31:43,419
your<font color="#E5E5E5"> instructions that go to the CPU are</font>

584
00:31:41,170 --> 00:31:47,010
not executed in the<font color="#CCCCCC"> order that</font><font color="#E5E5E5"> we</font>

585
00:31:43,420 --> 00:31:49,780
require for<font color="#CCCCCC"> them to be mispredicted so</font>

586
00:31:47,010 --> 00:31:52,390
in<font color="#E5E5E5"> order to fix specter attack you</font>

587
00:31:49,780 --> 00:31:53,740
actually have to recompile<font color="#E5E5E5"> all of your</font>

588
00:31:52,390 --> 00:31:58,840
<font color="#E5E5E5">software that you are</font><font color="#CCCCCC"> running</font><font color="#E5E5E5"> on your</font>

589
00:31:53,740 --> 00:32:00,940
<font color="#E5E5E5">machine with the</font><font color="#CCCCCC"> apt wine</font><font color="#E5E5E5"> protection the</font>

590
00:31:58,840 --> 00:32:04,959
other protections if you don't want to

591
00:32:00,940 --> 00:32:09,130
fix your problem inside<font color="#E5E5E5"> the code you can</font>

592
00:32:04,960 --> 00:32:12,540
actually use micro code updates from

593
00:32:09,130 --> 00:32:16,080
your vendor from<font color="#E5E5E5"> your</font><font color="#CCCCCC"> cpu vendor and</font>

594
00:32:12,540 --> 00:32:19,990
these micro code updates<font color="#E5E5E5"> introduce these</font>

595
00:32:16,080 --> 00:32:22,600
new features<font color="#E5E5E5"> of the CPU</font><font color="#CCCCCC"> indirect branch</font>

596
00:32:19,990 --> 00:32:27,730
restricted speculation<font color="#E5E5E5"> what this means</font>

597
00:32:22,600 --> 00:32:30,730
is that if you have a spectral

598
00:32:27,730 --> 00:32:33,640
<font color="#E5E5E5">speculative execution it would be</font>

599
00:32:30,730 --> 00:32:38,260
restricted<font color="#E5E5E5"> within the same core so it</font>

600
00:32:33,640 --> 00:32:40,510
can be used on<font color="#CCCCCC"> a high profit high profit</font>

601
00:32:38,260 --> 00:32:42,790
can be<font color="#CCCCCC"> used to mispredict something the</font>

602
00:32:40,510 --> 00:32:44,920
predictions would<font color="#E5E5E5"> be actually limited</font>

603
00:32:42,790 --> 00:32:48,659
only to<font color="#E5E5E5"> the same core but will be shared</font>

604
00:32:44,920 --> 00:32:52,570
between threads and hyper tests<font color="#CCCCCC"> if you</font>

605
00:32:48,660 --> 00:32:54,670
<font color="#E5E5E5">move this a</font><font color="#CCCCCC"> little bit more</font><font color="#E5E5E5"> you the</font>

606
00:32:52,570 --> 00:32:56,800
second test<font color="#E5E5E5"> single</font><font color="#CCCCCC"> threat indirect</font>

607
00:32:54,670 --> 00:32:58,360
branch predictor predictions this means

608
00:32:56,800 --> 00:33:00,730
<font color="#E5E5E5">that you are now limiting these</font>

609
00:32:58,360 --> 00:33:05,740
predictions<font color="#E5E5E5"> to be handled on</font><font color="#CCCCCC"> the inside</font>

610
00:33:00,730 --> 00:33:08,560
a<font color="#E5E5E5"> single</font><font color="#CCCCCC"> thread and indirect branch</font>

611
00:33:05,740 --> 00:33:14,290
predictor barrier is the whole thing<font color="#CCCCCC"> is</font>

612
00:33:08,560 --> 00:33:16,870
<font color="#CCCCCC">actually every prediction you are</font>

613
00:33:14,290 --> 00:33:20,040
<font color="#E5E5E5">essentially preventing predictions from</font>

614
00:33:16,870 --> 00:33:23,530
happening<font color="#CCCCCC"> so all three of these are</font>

615
00:33:20,040 --> 00:33:24,950
removing performance improvements in

616
00:33:23,530 --> 00:33:28,399
your CPUs that

617
00:33:24,950 --> 00:33:30,500
<font color="#CCCCCC">were hard to get</font><font color="#E5E5E5"> and you're actually</font>

618
00:33:28,399 --> 00:33:32,629
<font color="#E5E5E5">moving</font><font color="#CCCCCC"> backwards with the CPU</font>

619
00:33:30,500 --> 00:33:35,450
architecture if you're introducing<font color="#CCCCCC"> any</font>

620
00:33:32,630 --> 00:33:37,820
of these inside your CPU because<font color="#E5E5E5"> the</font>

621
00:33:35,450 --> 00:33:41,149
<font color="#E5E5E5">performance will drop simply because you</font>

622
00:33:37,820 --> 00:33:43,250
can<font color="#E5E5E5"> know now you can if</font><font color="#CCCCCC"> you're</font><font color="#E5E5E5"> using</font>

623
00:33:41,149 --> 00:33:45,080
only<font color="#CCCCCC"> indirect in direct branch there are</font>

624
00:33:43,250 --> 00:33:46,789
<font color="#CCCCCC">certain speculation</font><font color="#E5E5E5"> you're actually</font>

625
00:33:45,080 --> 00:33:49,820
limiting the branch predictor<font color="#E5E5E5"> to this</font>

626
00:33:46,789 --> 00:33:53,539
core<font color="#E5E5E5"> and inside this core</font><font color="#CCCCCC"> you're not</font>

627
00:33:49,820 --> 00:33:55,549
using<font color="#E5E5E5"> anything any data information that</font>

628
00:33:53,539 --> 00:33:58,190
you can have<font color="#E5E5E5"> from other executions on</font>

629
00:33:55,549 --> 00:34:00,860
other course if you're<font color="#E5E5E5"> using on single</font>

630
00:33:58,190 --> 00:34:03,440
the protection on single<font color="#CCCCCC"> thread</font><font color="#E5E5E5"> you</font>

631
00:34:00,860 --> 00:34:05,120
<font color="#E5E5E5">actually get the other problem that's on</font>

632
00:34:03,440 --> 00:34:07,940
<font color="#E5E5E5">the same core you cannot share</font>

633
00:34:05,120 --> 00:34:14,679
predictions and if you simply remove

634
00:34:07,940 --> 00:34:14,679
predictions<font color="#E5E5E5"> it's obvious so</font>

635
00:34:16,310 --> 00:34:24,889
yeah with preventing<font color="#E5E5E5"> predictions you</font>

636
00:34:22,940 --> 00:34:26,720
actually prevent<font color="#E5E5E5"> userspace predictions</font>

637
00:34:24,889 --> 00:34:29,690
to leak inside<font color="#CCCCCC"> kernel-space</font>

638
00:34:26,719 --> 00:34:39,428
at all on every context which you now

639
00:34:29,690 --> 00:34:43,090
have to do<font color="#E5E5E5"> predictions again all these</font>

640
00:34:39,429 --> 00:34:47,560
protections<font color="#CCCCCC"> supporting</font><font color="#E5E5E5"> the kernel memory</font>

641
00:34:43,090 --> 00:34:51,800
<font color="#E5E5E5">introducing these</font><font color="#CCCCCC"> limitations because</font>

642
00:34:47,560 --> 00:34:54,918
<font color="#E5E5E5">they cost different performance problems</font>

643
00:34:51,800 --> 00:34:57,950
and this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> a benchmark from last week</font>

644
00:34:54,918 --> 00:35:03,650
from froning's<font color="#CCCCCC"> they are testing the</font>

645
00:34:57,950 --> 00:35:07,879
<font color="#E5E5E5">linux kpti kernel most a lot</font><font color="#CCCCCC"> of the</font>

646
00:35:03,650 --> 00:35:10,640
things that<font color="#CCCCCC"> don't</font><font color="#E5E5E5"> require the kernel to</font>

647
00:35:07,880 --> 00:35:14,420
take part in your<font color="#E5E5E5"> execution they're not</font>

648
00:35:10,640 --> 00:35:17,330
affected by kpti simply because if you

649
00:35:14,420 --> 00:35:20,240
don't execute<font color="#CCCCCC"> the Cisco's your code is</font>

650
00:35:17,330 --> 00:35:21,890
<font color="#CCCCCC">stink in</font><font color="#E5E5E5"> user space</font><font color="#CCCCCC"> if your stinking</font>

651
00:35:20,240 --> 00:35:24,140
user space<font color="#E5E5E5"> you don't need to copy</font>

652
00:35:21,890 --> 00:35:26,120
anything<font color="#E5E5E5"> to kernel and you don't have</font>

653
00:35:24,140 --> 00:35:28,040
performance overhead furnace but

654
00:35:26,120 --> 00:35:30,710
anything that<font color="#E5E5E5"> requires a lot of</font><font color="#CCCCCC"> i/o a</font>

655
00:35:28,040 --> 00:35:34,730
lot of networking<font color="#CCCCCC"> a lot of cycling</font>

656
00:35:30,710 --> 00:35:38,150
synchronization<font color="#E5E5E5"> this actually gets to</font>

657
00:35:34,730 --> 00:35:41,800
<font color="#E5E5E5">the</font><font color="#CCCCCC"> KPI problem this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> why I purposely</font>

658
00:35:38,150 --> 00:35:45,440
<font color="#E5E5E5">took only this snapshot from their</font>

659
00:35:41,800 --> 00:35:48,410
research<font color="#CCCCCC"> you can see the benchmarks on</font>

660
00:35:45,440 --> 00:35:50,570
their side on the link<font color="#E5E5E5"> down but you can</font>

661
00:35:48,410 --> 00:35:53,299
clearly<font color="#CCCCCC"> see the difference here with</font>

662
00:35:50,570 --> 00:35:58,700
kpti<font color="#E5E5E5"> off you get a little bit more</font>

663
00:35:53,300 --> 00:36:02,840
operations than not a little bit but you

664
00:35:58,700 --> 00:36:08,720
can<font color="#E5E5E5"> get 5 to 15% better performance</font>

665
00:36:02,840 --> 00:36:11,290
without KPI so this is a 5 to<font color="#CCCCCC"> 15%</font><font color="#E5E5E5"> is not</font>

666
00:36:08,720 --> 00:36:11,290
a big deal

667
00:36:13,040 --> 00:36:22,279
we wait<font color="#CCCCCC"> 5 to 15%</font><font color="#E5E5E5"> is not a big deal for</font>

668
00:36:18,550 --> 00:36:24,560
most people<font color="#E5E5E5"> but if</font><font color="#CCCCCC"> you're if you have</font>

669
00:36:22,280 --> 00:36:28,910
like hundreds of servers<font color="#E5E5E5"> or in my case</font>

670
00:36:24,560 --> 00:36:31,609
<font color="#E5E5E5">thousands of servers 5 to 15% would</font>

671
00:36:28,910 --> 00:36:35,540
actually get you<font color="#CCCCCC"> to a very annoying</font>

672
00:36:31,609 --> 00:36:38,270
<font color="#E5E5E5">number and a number that will translate</font>

673
00:36:35,540 --> 00:36:40,880
<font color="#E5E5E5">directly to buying like a hunger new</font>

674
00:36:38,270 --> 00:36:43,730
servers simply because you're<font color="#CCCCCC"> changing</font>

675
00:36:40,880 --> 00:36:44,300
the kernel with one that<font color="#CCCCCC"> has protections</font>

676
00:36:43,730 --> 00:36:47,690
for you

677
00:36:44,300 --> 00:36:49,609
so yeah the number is pretty ugly when

678
00:36:47,690 --> 00:36:51,440
you<font color="#E5E5E5"> have a lot</font><font color="#CCCCCC"> of them a lot</font><font color="#E5E5E5"> of machines</font>

679
00:36:49,609 --> 00:36:55,600
<font color="#E5E5E5">if you have like 10</font><font color="#CCCCCC"> machines in the</font>

680
00:36:51,440 --> 00:37:00,530
office<font color="#E5E5E5"> you don't have a problem</font>

681
00:36:55,600 --> 00:37:05,618
so what others did to protect<font color="#CCCCCC"> themselves</font>

682
00:37:00,530 --> 00:37:08,390
from<font color="#E5E5E5"> meltdown</font><font color="#CCCCCC"> most of the people</font>

683
00:37:05,619 --> 00:37:10,670
resorted to monitoring<font color="#E5E5E5"> and analysis and</font>

684
00:37:08,390 --> 00:37:11,270
only two other companies<font color="#CCCCCC"> except</font>

685
00:37:10,670 --> 00:37:15,020
<font color="#CCCCCC">SiteGround</font>

686
00:37:11,270 --> 00:37:18,109
actually wrote something on this<font color="#E5E5E5"> CAPTCHA</font>

687
00:37:15,020 --> 00:37:20,509
<font color="#E5E5E5">wait</font><font color="#CCCCCC"> they wrote on January 5th</font><font color="#E5E5E5"> the</font>

688
00:37:18,109 --> 00:37:24,500
meltdown inspector attacks were public

689
00:37:20,510 --> 00:37:27,290
in January<font color="#CCCCCC"> on</font><font color="#E5E5E5"> January 4th so on the</font><font color="#CCCCCC"> next</font>

690
00:37:24,500 --> 00:37:30,710
day they<font color="#E5E5E5"> released some information how</font>

691
00:37:27,290 --> 00:37:33,500
<font color="#CCCCCC">you can actually detect this endgame</font>

692
00:37:30,710 --> 00:37:37,100
they<font color="#CCCCCC"> shared their research without</font><font color="#E5E5E5"> any</font>

693
00:37:33,500 --> 00:37:40,480
<font color="#E5E5E5">code but they shared some research on</font>

694
00:37:37,100 --> 00:37:42,700
how you can detect those attacks

695
00:37:40,480 --> 00:37:46,609
<font color="#CCCCCC">unfortunately at that</font><font color="#E5E5E5"> time</font><font color="#CCCCCC"> I didn't</font>

696
00:37:42,700 --> 00:37:50,930
found about the<font color="#CCCCCC"> Dare</font><font color="#E5E5E5"> solution so we</font>

697
00:37:46,609 --> 00:37:54,230
started<font color="#CCCCCC"> developing our own</font><font color="#E5E5E5"> inside gun so</font>

698
00:37:50,930 --> 00:37:57,020
a few<font color="#E5E5E5"> days later I</font><font color="#CCCCCC"> found a about capsule</font>

699
00:37:54,230 --> 00:38:01,400
8<font color="#CCCCCC"> & 10 game but you see the difference</font>

700
00:37:57,020 --> 00:38:03,680
<font color="#CCCCCC">in approaches so</font><font color="#E5E5E5"> CAPTCHA</font><font color="#CCCCCC"> wait it's an</font>

701
00:38:01,400 --> 00:38:07,190
open<font color="#E5E5E5"> source project you can get there</font>

702
00:38:03,680 --> 00:38:12,589
<font color="#E5E5E5">called they decided</font><font color="#CCCCCC"> to simply check if</font>

703
00:38:07,190 --> 00:38:17,240
there are page faults so<font color="#E5E5E5"> missus memory</font>

704
00:38:12,590 --> 00:38:19,640
misses in kernel space this doesn't

705
00:38:17,240 --> 00:38:22,240
happen so often in kernel space<font color="#E5E5E5"> the</font>

706
00:38:19,640 --> 00:38:25,180
kernel is were ordered<font color="#CCCCCC"> and</font><font color="#E5E5E5"> shouldn't</font>

707
00:38:22,240 --> 00:38:28,689
situations or<font color="#CCCCCC"> at least is</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> kernel</font>

708
00:38:25,180 --> 00:38:32,169
programmers<font color="#CCCCCC"> try to optimize</font><font color="#E5E5E5"> to get the</font>

709
00:38:28,690 --> 00:38:36,150
most of the<font color="#E5E5E5"> CPU so they try to avoid</font>

710
00:38:32,170 --> 00:38:39,580
<font color="#E5E5E5">cache misses as much as possible</font><font color="#CCCCCC"> so</font>

711
00:38:36,150 --> 00:38:42,520
<font color="#CCCCCC">triggering could page fault</font><font color="#E5E5E5"> inside the</font>

712
00:38:39,580 --> 00:38:45,460
kernel<font color="#E5E5E5"> is not so</font><font color="#CCCCCC"> awful</font>

713
00:38:42,520 --> 00:38:49,840
and<font color="#E5E5E5"> you can</font><font color="#CCCCCC"> actually detect this</font><font color="#E5E5E5"> with</font>

714
00:38:45,460 --> 00:38:51,880
the perfect colors of the perf<font color="#CCCCCC"> - of the</font>

715
00:38:49,840 --> 00:38:55,150
kernel<font color="#E5E5E5"> and these are the counters they</font>

716
00:38:51,880 --> 00:38:58,480
used operate<font color="#E5E5E5"> result</font><font color="#CCCCCC"> axis and the main</font>

717
00:38:55,150 --> 00:39:05,020
that they were they<font color="#CCCCCC"> they that</font><font color="#E5E5E5"> they based</font>

718
00:38:58,480 --> 00:39:07,210
their check on is result miss so the

719
00:39:05,020 --> 00:39:12,520
result of the operation was<font color="#CCCCCC"> missed from</font>

720
00:39:07,210 --> 00:39:15,550
<font color="#E5E5E5">the cache so the problem for this is</font>

721
00:39:12,520 --> 00:39:19,530
<font color="#E5E5E5">that they're trying to check if there is</font>

722
00:39:15,550 --> 00:39:22,260
<font color="#CCCCCC">a cache miss this will be</font><font color="#E5E5E5"> okay if</font>

723
00:39:19,530 --> 00:39:25,330
everyone<font color="#CCCCCC"> was using</font><font color="#E5E5E5"> the proof of concepts</font>

724
00:39:22,260 --> 00:39:28,450
<font color="#E5E5E5">exploits with meltdown</font><font color="#CCCCCC"> that rely</font><font color="#E5E5E5"> upon</font>

725
00:39:25,330 --> 00:39:30,970
<font color="#CCCCCC">fortune to world but as I showed in the</font>

726
00:39:28,450 --> 00:39:33,279
<font color="#E5E5E5">beginning you can simply replace version</font>

727
00:39:30,970 --> 00:39:37,779
<font color="#CCCCCC">vault</font><font color="#E5E5E5"> with first first and you no longer</font>

728
00:39:33,280 --> 00:39:41,260
<font color="#E5E5E5">get the page misses and your detection</font>

729
00:39:37,780 --> 00:39:45,910
is<font color="#CCCCCC"> not working anymore darer</font><font color="#E5E5E5"> thing is</font>

730
00:39:41,260 --> 00:39:48,400
that with this<font color="#CCCCCC"> you</font><font color="#E5E5E5"> can actually only</font>

731
00:39:45,910 --> 00:39:50,379
detect the process but while you're

732
00:39:48,400 --> 00:39:55,270
<font color="#CCCCCC">detecting this process a lot</font><font color="#E5E5E5"> of CPU</font>

733
00:39:50,380 --> 00:39:59,200
<font color="#CCCCCC">cycles will it would take a lot of time</font>

734
00:39:55,270 --> 00:40:01,450
<font color="#E5E5E5">CPU time and while you're</font><font color="#CCCCCC"> detecting this</font>

735
00:39:59,200 --> 00:40:04,419
the exploit<font color="#E5E5E5"> is actually getting pulling</font>

736
00:40:01,450 --> 00:40:07,359
data from<font color="#E5E5E5"> your memory so you</font><font color="#CCCCCC"> now have</font><font color="#E5E5E5"> to</font>

737
00:40:04,420 --> 00:40:10,630
<font color="#E5E5E5">decide what to do and capsulate doesn't</font>

738
00:40:07,359 --> 00:40:12,790
provide you with the<font color="#CCCCCC"> side mechanism you</font>

739
00:40:10,630 --> 00:40:15,880
<font color="#E5E5E5">have to decide for</font><font color="#CCCCCC"> yourself what to do</font>

740
00:40:12,790 --> 00:40:19,259
for<font color="#CCCCCC"> example you can kill the process</font><font color="#E5E5E5"> but</font>

741
00:40:15,880 --> 00:40:22,410
if this is an exploit<font color="#CCCCCC"> if you kill it</font>

742
00:40:19,260 --> 00:40:25,570
<font color="#E5E5E5">they will simply start it again</font>

743
00:40:22,410 --> 00:40:29,629
so the I think<font color="#E5E5E5"> was the</font><font color="#CCCCCC"> endgame research</font>

744
00:40:25,570 --> 00:40:32,720
<font color="#E5E5E5">they provided a lot of insight about the</font>

745
00:40:29,630 --> 00:40:38,000
performance counters of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> cpu</font><font color="#E5E5E5"> the</font>

746
00:40:32,720 --> 00:40:42,919
performance performance monitoring unit

747
00:40:38,000 --> 00:40:45,800
of the CPU CPM use these statistics<font color="#E5E5E5"> they</font>

748
00:40:42,920 --> 00:40:48,500
<font color="#CCCCCC">measure</font><font color="#E5E5E5"> them and show us they show</font>

749
00:40:45,800 --> 00:40:53,990
<font color="#E5E5E5">actual results you can read their blog</font>

750
00:40:48,500 --> 00:40:57,350
post there the counter measures here are

751
00:40:53,990 --> 00:41:01,220
the same<font color="#CCCCCC"> endgame</font><font color="#E5E5E5"> and captivate one at</font>

752
00:40:57,350 --> 00:41:03,950
you as a developer<font color="#CCCCCC"> system administrator</font>

753
00:41:01,220 --> 00:41:07,790
to<font color="#E5E5E5"> decide what to do with</font><font color="#CCCCCC"> the detected</font>

754
00:41:03,950 --> 00:41:16,910
data attack<font color="#E5E5E5"> however they don't tell you</font>

755
00:41:07,790 --> 00:41:19,910
that<font color="#E5E5E5"> it takes a lot</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> time yes</font><font color="#CCCCCC"> so the</font>

756
00:41:16,910 --> 00:41:24,310
question<font color="#CCCCCC"> is is modifying still full</font>

757
00:41:19,910 --> 00:41:32,330
instructions will help give me two<font color="#CCCCCC"> sides</font>

758
00:41:24,310 --> 00:41:35,509
so what<font color="#E5E5E5"> we did was instead</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> okay we're</font>

759
00:41:32,330 --> 00:41:38,870
using the same<font color="#E5E5E5"> thing yes we are using</font>

760
00:41:35,510 --> 00:41:42,110
the count the counters of the processor

761
00:41:38,870 --> 00:41:44,960
processor monitoring unit<font color="#E5E5E5"> however in the</font>

762
00:41:42,110 --> 00:41:47,000
<font color="#CCCCCC">beginning I didn't</font><font color="#E5E5E5"> know that the cache</font>

763
00:41:44,960 --> 00:41:49,460
counters were already<font color="#E5E5E5"> available in perf</font>

764
00:41:47,000 --> 00:41:50,990
<font color="#CCCCCC">I wrote the same all the</font><font color="#E5E5E5"> code in</font>

765
00:41:49,460 --> 00:41:55,430
assembly and<font color="#E5E5E5"> put it in</font><font color="#CCCCCC"> a kernel module</font>

766
00:41:50,990 --> 00:41:58,700
<font color="#E5E5E5">and got the dating from there afterwards</font>

767
00:41:55,430 --> 00:42:03,020
<font color="#E5E5E5">as I spoke with other kernel developers</font>

768
00:41:58,700 --> 00:42:05,810
I found out that I'm<font color="#E5E5E5"> stupid and perf has</font>

769
00:42:03,020 --> 00:42:10,310
all the things<font color="#CCCCCC"> that I need we introduced</font>

770
00:42:05,810 --> 00:42:13,900
the perf counters inside our inside our

771
00:42:10,310 --> 00:42:17,240
<font color="#E5E5E5">code however the perf counters were not</font>

772
00:42:13,900 --> 00:42:21,080
great as I told you first<font color="#CCCCCC"> vs. bit</font>

773
00:42:17,240 --> 00:42:25,839
problematic<font color="#E5E5E5"> so we decided to attack</font><font color="#CCCCCC"> the</font>

774
00:42:21,080 --> 00:42:28,549
attack and simply detect when there is a

775
00:42:25,840 --> 00:42:31,130
<font color="#E5E5E5">winning there is a process that spawns</font>

776
00:42:28,550 --> 00:42:33,170
processes that die constantly<font color="#E5E5E5"> and count</font>

777
00:42:31,130 --> 00:42:34,240
<font color="#E5E5E5">all the segmentation faults only the</font>

778
00:42:33,170 --> 00:42:37,730
segmentation<font color="#CCCCCC"> fault</font>

779
00:42:34,240 --> 00:42:40,529
so we<font color="#CCCCCC"> changed</font><font color="#E5E5E5"> the task struct of the</font>

780
00:42:37,730 --> 00:42:44,920
kernel and that

781
00:42:40,530 --> 00:42:49,480
more<font color="#E5E5E5"> field to count all the</font><font color="#CCCCCC"> child's that</font>

782
00:42:44,920 --> 00:42:51,910
died with<font color="#E5E5E5"> segmentation fault when we</font>

783
00:42:49,480 --> 00:42:55,540
detect such a process<font color="#E5E5E5"> which</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> detected</font>

784
00:42:51,910 --> 00:42:58,060
<font color="#CCCCCC">from every rochedo of a process so this</font>

785
00:42:55,540 --> 00:43:00,400
is<font color="#E5E5E5"> exactly after the segmentation fault</font>

786
00:42:58,060 --> 00:43:05,290
<font color="#E5E5E5">we already know that there was a process</font>

787
00:43:00,400 --> 00:43:07,590
that had a child that was that already

788
00:43:05,290 --> 00:43:11,680
died with segmentation<font color="#E5E5E5"> fault so we</font>

789
00:43:07,590 --> 00:43:13,420
<font color="#CCCCCC">stopped</font><font color="#E5E5E5"> this process we are not killing</font>

790
00:43:11,680 --> 00:43:16,390
<font color="#E5E5E5">kill - kill</font>

791
00:43:13,420 --> 00:43:19,600
we are kill stopping it<font color="#CCCCCC"> so</font><font color="#E5E5E5"> essentially</font>

792
00:43:16,390 --> 00:43:21,970
we are pausing the process but when<font color="#CCCCCC"> we</font>

793
00:43:19,600 --> 00:43:24,430
<font color="#CCCCCC">were</font><font color="#E5E5E5"> pausing this we know that the user</font>

794
00:43:21,970 --> 00:43:26,799
that started the process<font color="#E5E5E5"> has the ability</font>

795
00:43:24,430 --> 00:43:29,980
to<font color="#E5E5E5"> sense account and to continue this</font>

796
00:43:26,800 --> 00:43:34,660
process<font color="#E5E5E5"> so we changed a little bit the</font>

797
00:43:29,980 --> 00:43:37,180
logic of kill and now you<font color="#CCCCCC"> cannot send a</font>

798
00:43:34,660 --> 00:43:40,839
signal<font color="#E5E5E5"> to continue a process that was</font>

799
00:43:37,180 --> 00:43:43,060
stopped by our implementation so only

800
00:43:40,840 --> 00:43:46,060
the<font color="#E5E5E5"> root on the host machine can</font>

801
00:43:43,060 --> 00:43:49,090
actually<font color="#E5E5E5"> cure this process the user can</font>

802
00:43:46,060 --> 00:43:52,000
see the<font color="#E5E5E5"> process that it is in D state</font>

803
00:43:49,090 --> 00:43:56,200
that it stopped but you cannot<font color="#E5E5E5"> continue</font>

804
00:43:52,000 --> 00:43:58,780
it we also walk that we have stopped

805
00:43:56,200 --> 00:44:01,240
this process<font color="#E5E5E5"> so we know the user the</font>

806
00:43:58,780 --> 00:44:05,440
process<font color="#CCCCCC"> ID the</font><font color="#E5E5E5"> actual</font><font color="#CCCCCC"> comments</font><font color="#E5E5E5"> the path</font>

807
00:44:01,240 --> 00:44:09,189
<font color="#E5E5E5">to the comment and we can inspect the</font>

808
00:44:05,440 --> 00:44:11,680
comment or spend the<font color="#E5E5E5"> account or suspend</font>

809
00:44:09,190 --> 00:44:14,260
the container<font color="#CCCCCC"> so in our infrastructure</font>

810
00:44:11,680 --> 00:44:17,649
we<font color="#E5E5E5"> are shared hosting company which we</font>

811
00:44:14,260 --> 00:44:19,720
we have a lot of<font color="#E5E5E5"> accounts</font><font color="#CCCCCC"> on single</font>

812
00:44:17,650 --> 00:44:22,900
machine<font color="#CCCCCC"> but we also have other machines</font>

813
00:44:19,720 --> 00:44:25,750
with a lot<font color="#E5E5E5"> of containers</font><font color="#CCCCCC"> that have root</font>

814
00:44:22,900 --> 00:44:28,120
<font color="#E5E5E5">access inside of them so these guys have</font>

815
00:44:25,750 --> 00:44:30,940
<font color="#E5E5E5">root and they still cannot kill their</font>

816
00:44:28,120 --> 00:44:33,359
process this was our change what we did

817
00:44:30,940 --> 00:44:37,440
this was<font color="#E5E5E5"> to prevent this</font><font color="#CCCCCC"> from happening</font>

818
00:44:33,360 --> 00:44:37,440
<font color="#E5E5E5">from</font><font color="#CCCCCC"> leaking a lot</font><font color="#E5E5E5"> of data</font>

819
00:44:38,900 --> 00:44:48,230
so<font color="#CCCCCC"> sippy opening we simply change the</font>

820
00:44:43,630 --> 00:44:52,580
set<font color="#CCCCCC"> affinity to report to the user that</font>

821
00:44:48,230 --> 00:44:56,120
it did change it<font color="#E5E5E5"> did the pinning however</font>

822
00:44:52,580 --> 00:44:59,569
it doesn't<font color="#CCCCCC"> do anything for</font><font color="#E5E5E5"> the user CP</font>

823
00:44:56,120 --> 00:45:02,930
opening is available only for<font color="#E5E5E5"> the root</font>

824
00:44:59,570 --> 00:45:05,390
of the host machine<font color="#CCCCCC"> and nobody else this</font>

825
00:45:02,930 --> 00:45:07,310
<font color="#E5E5E5">is because we need to print the CPUs in</font>

826
00:45:05,390 --> 00:45:09,560
<font color="#E5E5E5">the beginning when</font><font color="#CCCCCC"> we start the machine</font>

827
00:45:07,310 --> 00:45:12,590
and after<font color="#E5E5E5"> that after your machine has</font>

828
00:45:09,560 --> 00:45:15,980
booted and entities configured we don't

829
00:45:12,590 --> 00:45:18,820
<font color="#E5E5E5">need to change anything on the CPUs how</font>

830
00:45:15,980 --> 00:45:22,400
they are arranged<font color="#CCCCCC"> so the user</font>

831
00:45:18,820 --> 00:45:24,040
he's running concert environments<font color="#CCCCCC"> these</font>

832
00:45:22,400 --> 00:45:27,950
are the<font color="#E5E5E5"> limitations that we provide but</font>

833
00:45:24,040 --> 00:45:30,650
<font color="#CCCCCC">it's still quite good because now</font>

834
00:45:27,950 --> 00:45:35,060
<font color="#E5E5E5">meltdown is pretty hard to execute</font>

835
00:45:30,650 --> 00:45:38,420
without<font color="#E5E5E5"> the pinning now</font><font color="#CCCCCC"> then we</font><font color="#E5E5E5"> decided</font>

836
00:45:35,060 --> 00:45:41,870
<font color="#CCCCCC">ok</font><font color="#E5E5E5"> we'll go to the</font><font color="#CCCCCC"> silk versions Co for</font>

837
00:45:38,420 --> 00:45:44,900
short and if we limit them<font color="#CCCCCC"> we will</font>

838
00:45:41,870 --> 00:45:47,589
effectively<font color="#E5E5E5"> stop both for first version</font>

839
00:45:44,900 --> 00:45:48,860
to<font color="#CCCCCC"> out</font><font color="#E5E5E5"> and essentially we will stop</font>

840
00:45:47,590 --> 00:45:53,090
<font color="#CCCCCC">meltdown</font>

841
00:45:48,860 --> 00:45:55,370
however since<font color="#E5E5E5"> their user space I can</font>

842
00:45:53,090 --> 00:45:58,400
write an assembly compile it put it on

843
00:45:55,370 --> 00:46:01,100
your machine<font color="#CCCCCC"> and it will execute my</font>

844
00:45:58,400 --> 00:46:02,900
instructions<font color="#E5E5E5"> simply because they are not</font>

845
00:46:01,100 --> 00:46:05,569
privileged instructions it doesn't

846
00:46:02,900 --> 00:46:07,490
require to<font color="#E5E5E5"> go to the kernel to execute</font>

847
00:46:05,570 --> 00:46:12,070
this it's<font color="#E5E5E5"> not like set affinity which</font>

848
00:46:07,490 --> 00:46:16,129
<font color="#CCCCCC">required a Cisco so the other thing</font><font color="#E5E5E5"> was</font>

849
00:46:12,070 --> 00:46:19,250
our<font color="#CCCCCC"> kernel developer found that even</font><font color="#E5E5E5"> if</font>

850
00:46:16,130 --> 00:46:22,480
you tackle the problem with the silver

851
00:46:19,250 --> 00:46:25,820
<font color="#CCCCCC">since he overshot</font><font color="#E5E5E5"> the cache can be</font>

852
00:46:22,480 --> 00:46:29,060
implicitly forced<font color="#E5E5E5"> when there is an</font>

853
00:46:25,820 --> 00:46:30,740
invalid instruction in<font color="#E5E5E5"> your code he</font>

854
00:46:29,060 --> 00:46:33,950
simply write an invalid instruction

855
00:46:30,740 --> 00:46:36,979
<font color="#E5E5E5">compile it without a care</font><font color="#CCCCCC"> that it's</font>

856
00:46:33,950 --> 00:46:40,040
around instruction execute this code and

857
00:46:36,980 --> 00:46:43,250
your application will die<font color="#E5E5E5"> that's not a</font>

858
00:46:40,040 --> 00:46:47,690
problem because<font color="#E5E5E5"> it will</font><font color="#CCCCCC"> clear the cache</font>

859
00:46:43,250 --> 00:46:49,790
<font color="#E5E5E5">so</font><font color="#CCCCCC"> it you not be using the efficiency of</font>

860
00:46:47,690 --> 00:46:54,100
a shop<font color="#E5E5E5"> and again you will be</font>

861
00:46:49,790 --> 00:46:54,100
fuck yes

862
00:47:00,260 --> 00:47:07,700
about the<font color="#CCCCCC"> accuracy about the accuracy I</font>

863
00:47:04,400 --> 00:47:08,359
would say that for<font color="#CCCCCC"> center world is more</font>

864
00:47:07,700 --> 00:47:10,700
reliable

865
00:47:08,359 --> 00:47:13,580
simply because you<font color="#E5E5E5"> get the actual data</font>

866
00:47:10,700 --> 00:47:16,790
you're not assuming anything<font color="#E5E5E5"> like with</font>

867
00:47:13,580 --> 00:47:19,759
first flush<font color="#E5E5E5"> yeah it first was</font><font color="#CCCCCC"> your</font>

868
00:47:16,790 --> 00:47:22,940
<font color="#E5E5E5">assuming things and your detecting</font>

869
00:47:19,760 --> 00:47:26,300
timings<font color="#CCCCCC"> if you read the papers I have</font>

870
00:47:22,940 --> 00:47:28,820
linked the papers at<font color="#CCCCCC"> the backend at the</font>

871
00:47:26,300 --> 00:47:31,550
final site of my presentation<font color="#E5E5E5"> if you</font>

872
00:47:28,820 --> 00:47:35,330
<font color="#CCCCCC">read the papers you see that there are</font>

873
00:47:31,550 --> 00:47:38,109
actual time charts that both force first

874
00:47:35,330 --> 00:47:41,869
and first<font color="#CCCCCC"> enter all generate in order to</font>

875
00:47:38,109 --> 00:47:44,230
detect<font color="#E5E5E5"> which symbol you</font><font color="#CCCCCC"> have in memory</font>

876
00:47:41,869 --> 00:47:44,230
<font color="#E5E5E5">right now</font>

877
00:47:49,310 --> 00:47:56,810
<font color="#CCCCCC">I don't know</font><font color="#E5E5E5"> which is faster actually</font><font color="#CCCCCC"> I</font>

878
00:47:54,650 --> 00:47:59,450
have tested<font color="#CCCCCC"> both but I simply</font><font color="#E5E5E5"> don't</font>

879
00:47:56,810 --> 00:48:02,450
<font color="#E5E5E5">remember if there is a significant</font>

880
00:47:59,450 --> 00:48:06,020
<font color="#CCCCCC">difference in the speed of</font><font color="#E5E5E5"> them flush</font>

881
00:48:02,450 --> 00:48:08,799
<font color="#E5E5E5">flush</font><font color="#CCCCCC"> is faster</font><font color="#E5E5E5"> simply</font><font color="#CCCCCC"> because it</font>

882
00:48:06,020 --> 00:48:11,270
doesn't<font color="#CCCCCC"> pull data</font><font color="#E5E5E5"> it checks only timings</font>

883
00:48:08,800 --> 00:48:14,900
<font color="#CCCCCC">but on my machine</font>

884
00:48:11,270 --> 00:48:16,820
it wasn't significantly<font color="#E5E5E5"> faster</font><font color="#CCCCCC"> in the</font>

885
00:48:14,900 --> 00:48:20,540
<font color="#E5E5E5">research it says that first force is a</font>

886
00:48:16,820 --> 00:48:28,130
lot<font color="#E5E5E5"> faster but I can't tell you</font><font color="#CCCCCC"> anything</font>

887
00:48:20,540 --> 00:48:30,830
about this so we decided<font color="#CCCCCC"> to try</font><font color="#E5E5E5"> to trap</font>

888
00:48:28,130 --> 00:48:31,340
those instructions<font color="#CCCCCC"> silvers</font><font color="#E5E5E5"> and silver</font>

889
00:48:30,830 --> 00:48:34,549
shop

890
00:48:31,340 --> 00:48:39,350
however<font color="#E5E5E5"> trapping those</font><font color="#CCCCCC"> see</font><font color="#E5E5E5"> their image</font>

891
00:48:34,550 --> 00:48:41,690
<font color="#CCCCCC">it is</font><font color="#E5E5E5"> not possible there is no machinery</font>

892
00:48:39,350 --> 00:48:43,850
sounds inside the CPU<font color="#CCCCCC"> that will allow</font>

893
00:48:41,690 --> 00:48:48,050
you to<font color="#CCCCCC"> trap an instruction that</font><font color="#E5E5E5"> isn't</font>

894
00:48:43,850 --> 00:48:52,390
privileged<font color="#E5E5E5"> so then we started thinking</font>

895
00:48:48,050 --> 00:48:57,350
<font color="#E5E5E5">about what if we start the process</font><font color="#CCCCCC"> and</font>

896
00:48:52,390 --> 00:48:59,660
we don't<font color="#E5E5E5"> read the</font><font color="#CCCCCC"> whole process</font><font color="#E5E5E5"> binary</font>

897
00:48:57,350 --> 00:49:02,450
<font color="#E5E5E5">we return</font><font color="#CCCCCC"> the instructions it has and</font>

898
00:48:59,660 --> 00:49:07,640
the<font color="#E5E5E5"> tech if if there is an instruction</font>

899
00:49:02,450 --> 00:49:10,430
<font color="#CCCCCC">that is co for sale for shop in this way</font>

900
00:49:07,640 --> 00:49:14,540
we can<font color="#E5E5E5"> also can implement detection if</font>

901
00:49:10,430 --> 00:49:16,759
there would be an implicit fault<font color="#E5E5E5"> by</font>

902
00:49:14,540 --> 00:49:19,040
seeing<font color="#CCCCCC"> that in the code there there is</font>

903
00:49:16,760 --> 00:49:22,940
an invalid instruction

904
00:49:19,040 --> 00:49:25,550
this however is slow simply<font color="#CCCCCC"> because</font><font color="#E5E5E5"> you</font>

905
00:49:22,940 --> 00:49:30,110
have to execute<font color="#E5E5E5"> the</font><font color="#CCCCCC"> actual code and in</font>

906
00:49:25,550 --> 00:49:34,160
<font color="#E5E5E5">parallel you have to execute the</font>

907
00:49:30,110 --> 00:49:37,430
detector<font color="#E5E5E5"> or it can be even slower if you</font>

908
00:49:34,160 --> 00:49:40,839
check each instruction<font color="#E5E5E5"> if it is silver</font>

909
00:49:37,430 --> 00:49:44,350
sure if it is<font color="#E5E5E5"> invalid instruction so</font>

910
00:49:40,840 --> 00:49:46,550
direct checking we simply scratch that

911
00:49:44,350 --> 00:49:48,830
<font color="#E5E5E5">inspecting the binary for partner in</font>

912
00:49:46,550 --> 00:49:50,980
parallel<font color="#E5E5E5"> we're still thinking</font><font color="#CCCCCC"> about this</font>

913
00:49:48,830 --> 00:49:53,450
<font color="#E5E5E5">and there's another solution</font>

914
00:49:50,980 --> 00:49:56,570
<font color="#E5E5E5">virtualizing the system in pure</font><font color="#CCCCCC"> moon so</font>

915
00:49:53,450 --> 00:50:00,649
your whole machine gets inside the<font color="#CCCCCC"> q mu</font>

916
00:49:56,570 --> 00:50:04,370
the<font color="#E5E5E5"> cumin can get you the requests you</font>

917
00:50:00,650 --> 00:50:07,190
get<font color="#E5E5E5"> for silvers and silver shop</font><font color="#CCCCCC"> you get</font>

918
00:50:04,370 --> 00:50:10,640
them inside<font color="#CCCCCC"> your host machine and you</font>

919
00:50:07,190 --> 00:50:12,670
can<font color="#E5E5E5"> chop them</font><font color="#CCCCCC"> like</font><font color="#E5E5E5"> I essentially</font><font color="#CCCCCC"> Kumu is</font>

920
00:50:10,640 --> 00:50:17,390
doing the same<font color="#E5E5E5"> thing when it is</font>

921
00:50:12,670 --> 00:50:20,510
<font color="#E5E5E5">emulating different options for the CPUs</font>

922
00:50:17,390 --> 00:50:23,930
<font color="#E5E5E5">so when you for example</font><font color="#CCCCCC"> start a KVM you</font>

923
00:50:20,510 --> 00:50:26,440
can say that it is<font color="#CCCCCC"> 32-bit CPU even</font>

924
00:50:23,930 --> 00:50:29,569
though you're running on<font color="#CCCCCC"> a 64-bit</font>

925
00:50:26,440 --> 00:50:32,810
architecture it can say that this CPU

926
00:50:29,570 --> 00:50:36,260
supports<font color="#CCCCCC"> AVX</font><font color="#E5E5E5"> or doesn't support</font><font color="#CCCCCC"> a VX and</font>

927
00:50:32,810 --> 00:50:41,570
this is by capturing<font color="#E5E5E5"> one pretty neat</font>

928
00:50:36,260 --> 00:50:45,740
instruction<font color="#CCCCCC"> cpuid</font><font color="#E5E5E5"> that returns a a a</font>

929
00:50:41,570 --> 00:50:48,440
binary bit stream and in this bit stream

930
00:50:45,740 --> 00:50:50,390
every bit<font color="#CCCCCC"> the sides</font><font color="#E5E5E5"> do have this</font>

931
00:50:48,440 --> 00:50:53,030
instruction or not<font color="#E5E5E5"> do you</font><font color="#CCCCCC"> have this</font>

932
00:50:50,390 --> 00:50:55,879
functionality or not<font color="#E5E5E5"> so you</font><font color="#CCCCCC"> get this</font>

933
00:50:53,030 --> 00:50:59,480
<font color="#E5E5E5">inside you capture this inside</font><font color="#CCCCCC"> q mu and</font>

934
00:50:55,880 --> 00:51:01,970
this<font color="#E5E5E5"> tater for turning the actual</font><font color="#CCCCCC"> result</font>

935
00:50:59,480 --> 00:51:05,870
<font color="#E5E5E5">from the CPU at the instruction of the</font>

936
00:51:01,970 --> 00:51:10,250
<font color="#E5E5E5">CPU you get this data and filter it or</font>

937
00:51:05,870 --> 00:51:14,109
directly<font color="#CCCCCC"> Y to the</font><font color="#E5E5E5"> game that it has only</font>

938
00:51:10,250 --> 00:51:18,080
these functionalities<font color="#E5E5E5"> that's it</font>

939
00:51:14,110 --> 00:51:19,700
so it's possible<font color="#E5E5E5"> to do something</font><font color="#CCCCCC"> about</font>

940
00:51:18,080 --> 00:51:24,470
it<font color="#CCCCCC"> in a vectorization</font>

941
00:51:19,700 --> 00:51:28,609
in into a virtualized environment for

942
00:51:24,470 --> 00:51:31,669
people<font color="#E5E5E5"> that are not true no developers</font>

943
00:51:28,610 --> 00:51:34,370
<font color="#E5E5E5">they may be tempted</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> add the</font><font color="#CCCCCC"> non zero</font>

944
00:51:31,670 --> 00:51:36,920
<font color="#E5E5E5">full option on the kernel wine when you</font>

945
00:51:34,370 --> 00:51:39,460
boot your kernel and<font color="#E5E5E5"> would think</font><font color="#CCCCCC"> that</font>

946
00:51:36,920 --> 00:51:42,680
this<font color="#E5E5E5"> will simply remove the</font><font color="#CCCCCC"> co flush</font>

947
00:51:39,460 --> 00:51:45,190
functionality<font color="#E5E5E5"> no this will remove the</font><font color="#CCCCCC"> co</font>

948
00:51:42,680 --> 00:51:47,450
for calls from it in<font color="#E5E5E5"> within the kernel</font>

949
00:51:45,190 --> 00:51:49,820
but only from<font color="#CCCCCC"> within the kernel code</font>

950
00:51:47,450 --> 00:51:54,080
<font color="#E5E5E5">every user space application will still</font>

951
00:51:49,820 --> 00:51:56,690
be able<font color="#CCCCCC"> to execute a</font><font color="#E5E5E5"> flush so don't do</font>

952
00:51:54,080 --> 00:52:00,740
this not do<font color="#E5E5E5"> this there is no reason to</font>

953
00:51:56,690 --> 00:52:01,880
do it<font color="#E5E5E5"> at all events that you can monitor</font>

954
00:52:00,740 --> 00:52:05,660
<font color="#E5E5E5">from</font>

955
00:52:01,880 --> 00:52:08,390
with<font color="#CCCCCC"> proof</font><font color="#E5E5E5"> you can monitor the demand</font>

956
00:52:05,660 --> 00:52:12,080
clean<font color="#E5E5E5"> this is actually event that is</font>

957
00:52:08,390 --> 00:52:15,529
fired<font color="#E5E5E5"> every time</font><font color="#CCCCCC"> a silver Shore nose or</font>

958
00:52:12,080 --> 00:52:18,560
silver shop or implicit<font color="#CCCCCC"> Co fish is</font>

959
00:52:15,530 --> 00:52:21,950
called so every time the<font color="#E5E5E5"> cash is cleaned</font>

960
00:52:18,560 --> 00:52:27,790
<font color="#E5E5E5">you get an event so you can monitor</font><font color="#CCCCCC"> for</font>

961
00:52:21,950 --> 00:52:30,620
this<font color="#E5E5E5"> you can also monitor for their</font>

962
00:52:27,790 --> 00:52:32,630
<font color="#E5E5E5">freaking cache misses</font><font color="#CCCCCC"> last layer cache</font>

963
00:52:30,620 --> 00:52:37,400
the cache that<font color="#CCCCCC"> is</font><font color="#E5E5E5"> shared between all</font>

964
00:52:32,630 --> 00:52:39,850
course you can monitor this and<font color="#CCCCCC"> the</font>

965
00:52:37,400 --> 00:52:42,340
<font color="#CCCCCC">other</font><font color="#E5E5E5"> things are mentioned in the</font>

966
00:52:39,850 --> 00:52:45,680
<font color="#CCCCCC">involve captivate and</font><font color="#E5E5E5"> tenth game</font>

967
00:52:42,340 --> 00:52:49,450
<font color="#E5E5E5">research the operators owe taxes and</font>

968
00:52:45,680 --> 00:52:51,799
turns out miss<font color="#CCCCCC"> directing that</font><font color="#E5E5E5"> I didn't</font>

969
00:52:49,450 --> 00:52:55,430
tell<font color="#E5E5E5"> you about is the</font><font color="#CCCCCC"> transactional</font>

970
00:52:51,800 --> 00:52:58,460
<font color="#E5E5E5">synchronization extension of Intel</font><font color="#CCCCCC"> it's</font>

971
00:52:55,430 --> 00:53:00,200
a nice way to<font color="#E5E5E5"> actually synchronize</font>

972
00:52:58,460 --> 00:53:04,460
multiple<font color="#E5E5E5"> threats inside your application</font>

973
00:53:00,200 --> 00:53:06,919
<font color="#CCCCCC">but instead of synchronizing</font><font color="#E5E5E5"> them in in</font>

974
00:53:04,460 --> 00:53:09,170
the kernel or<font color="#E5E5E5"> in user space</font><font color="#CCCCCC"> you can</font>

975
00:53:06,920 --> 00:53:12,050
actually say<font color="#CCCCCC"> to the CPU synchronize</font>

976
00:53:09,170 --> 00:53:16,160
these execute these instructions<font color="#E5E5E5"> and</font>

977
00:53:12,050 --> 00:53:20,060
either<font color="#E5E5E5"> finish the execution for all the</font>

978
00:53:16,160 --> 00:53:22,339
<font color="#E5E5E5">instructions or return nothing</font><font color="#CCCCCC"> so this</font>

979
00:53:20,060 --> 00:53:24,890
is this is executing a transaction<font color="#E5E5E5"> of</font>

980
00:53:22,340 --> 00:53:30,530
instructions inside the CPU which is

981
00:53:24,890 --> 00:53:33,470
very nice but before has well<font color="#E5E5E5"> inside has</font>

982
00:53:30,530 --> 00:53:34,970
well you should<font color="#E5E5E5"> have this</font><font color="#CCCCCC"> disable</font>

983
00:53:33,470 --> 00:53:37,520
because there is a<font color="#E5E5E5"> harder problem</font>

984
00:53:34,970 --> 00:53:40,189
<font color="#CCCCCC">there's an errata for this and you</font>

985
00:53:37,520 --> 00:53:43,300
should<font color="#CCCCCC"> have already patched</font><font color="#E5E5E5"> Europe CPUs</font>

986
00:53:40,190 --> 00:53:46,190
with the<font color="#E5E5E5"> microcode that is removing</font>

987
00:53:43,300 --> 00:53:49,220
disabling the<font color="#E5E5E5"> tsx instructions however</font>

988
00:53:46,190 --> 00:53:51,710
<font color="#E5E5E5">these available</font><font color="#CCCCCC"> is callek</font><font color="#E5E5E5"> so if you have</font>

989
00:53:49,220 --> 00:53:54,399
newer<font color="#CCCCCC"> CPUs</font><font color="#E5E5E5"> you have these instructions</font>

990
00:53:51,710 --> 00:53:58,310
<font color="#E5E5E5">and somebody could use instead of</font>

991
00:53:54,400 --> 00:54:02,340
creating more process that will say a

992
00:53:58,310 --> 00:54:05,070
<font color="#CCCCCC">seg fault these instructions you</font>

993
00:54:02,340 --> 00:54:07,890
the<font color="#CCCCCC"> parent can issue a transactional</font>

994
00:54:05,070 --> 00:54:12,180
instructions inside<font color="#E5E5E5"> the CPU that would</font>

995
00:54:07,890 --> 00:54:16,170
be<font color="#E5E5E5"> mispredicted that would be removed</font>

996
00:54:12,180 --> 00:54:18,299
from the<font color="#CCCCCC"> CPU however you still get the</font>

997
00:54:16,170 --> 00:54:22,520
cash<font color="#E5E5E5"> filled with the data that you want</font>

998
00:54:18,300 --> 00:54:25,140
<font color="#E5E5E5">so</font><font color="#CCCCCC"> three</font><font color="#E5E5E5"> six instructions are bad for</font>

999
00:54:22,520 --> 00:54:28,560
there is almost no software<font color="#E5E5E5"> that uses</font>

1000
00:54:25,140 --> 00:54:31,410
them so try to find<font color="#CCCCCC"> the micro code that</font>

1001
00:54:28,560 --> 00:54:35,790
disables dolls on<font color="#E5E5E5"> your husband previous</font>

1002
00:54:31,410 --> 00:54:38,339
chips and<font color="#E5E5E5"> for skylake the solution is in</font>

1003
00:54:35,790 --> 00:54:44,640
you not<font color="#E5E5E5"> gonna like it</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> you have to</font>

1004
00:54:38,340 --> 00:54:46,560
<font color="#CCCCCC">monitor for aborted transactions</font><font color="#E5E5E5"> because</font>

1005
00:54:44,640 --> 00:54:48,810
most of<font color="#E5E5E5"> the time you wouldn't get</font>

1006
00:54:46,560 --> 00:54:51,779
software<font color="#E5E5E5"> that is using transactional</font>

1007
00:54:48,810 --> 00:54:55,080
restrictions on your<font color="#E5E5E5"> machines this</font>

1008
00:54:51,780 --> 00:54:57,450
<font color="#E5E5E5">should be</font><font color="#CCCCCC"> zero and</font><font color="#E5E5E5"> you can see the</font>

1009
00:54:55,080 --> 00:55:00,600
<font color="#E5E5E5">counter increasing during attacks and</font>

1010
00:54:57,450 --> 00:55:02,609
then based on this you<font color="#CCCCCC"> have to</font><font color="#E5E5E5"> find the</font>

1011
00:55:00,600 --> 00:55:05,610
process<font color="#CCCCCC"> that</font><font color="#E5E5E5"> actually issued the</font>

1012
00:55:02,610 --> 00:55:08,820
transactional instructions and then stop

1013
00:55:05,610 --> 00:55:11,700
this process<font color="#E5E5E5"> and this is only based on</font>

1014
00:55:08,820 --> 00:55:18,690
statistics<font color="#E5E5E5"> so you have to write</font><font color="#CCCCCC"> a lot</font><font color="#E5E5E5"> of</font>

1015
00:55:11,700 --> 00:55:21,270
crappy software tracks<font color="#E5E5E5"> they do this yeah</font>

1016
00:55:18,690 --> 00:55:22,700
the<font color="#E5E5E5"> t6 instructions are also in</font>

1017
00:55:21,270 --> 00:55:25,560
<font color="#CCCCCC">userspace</font>

1018
00:55:22,700 --> 00:55:29,370
<font color="#CCCCCC">this is a big problem again</font><font color="#E5E5E5"> because you</font>

1019
00:55:25,560 --> 00:55:35,160
cannot trap them<font color="#E5E5E5"> and</font><font color="#CCCCCC"> you left</font><font color="#E5E5E5"> with the</font>

1020
00:55:29,370 --> 00:55:38,100
statistics<font color="#E5E5E5"> rewind concede counters</font><font color="#CCCCCC"> is</font>

1021
00:55:35,160 --> 00:55:43,980
not enough<font color="#CCCCCC"> simply because</font><font color="#E5E5E5"> it would take</font>

1022
00:55:38,100 --> 00:55:47,310
a<font color="#E5E5E5"> lot of time to find the process that</font>

1023
00:55:43,980 --> 00:55:49,530
is causing this<font color="#E5E5E5"> and then stopping it</font><font color="#CCCCCC"> so</font>

1024
00:55:47,310 --> 00:55:51,870
you can use<font color="#CCCCCC"> the same mitigations that</font><font color="#E5E5E5"> we</font>

1025
00:55:49,530 --> 00:55:54,480
introduced inside<font color="#E5E5E5"> our kernel to count</font>

1026
00:55:51,870 --> 00:55:56,880
this and<font color="#E5E5E5"> there to stop it but now you</font>

1027
00:55:54,480 --> 00:56:02,970
would<font color="#CCCCCC"> think not four kilobytes but a lot</font>

1028
00:55:56,880 --> 00:56:04,930
more<font color="#CCCCCC"> I don't have time so I'll simply</font>

1029
00:56:02,970 --> 00:56:11,098
<font color="#E5E5E5">skip to</font>

1030
00:56:04,930 --> 00:56:11,098
questions do<font color="#E5E5E5"> you have any questions</font>

1031
00:56:13,420 --> 00:56:23,780
how many<font color="#CCCCCC"> exports have</font><font color="#E5E5E5"> I seen on</font><font color="#CCCCCC"> our</font>

1032
00:56:18,140 --> 00:56:26,750
machines<font color="#CCCCCC"> since January 0 excluding our</font>

1033
00:56:23,780 --> 00:56:32,530
tests on<font color="#E5E5E5"> our machines because we do</font><font color="#CCCCCC"> 5</font>

1034
00:56:26,750 --> 00:56:32,530
testings<font color="#E5E5E5"> any other questions</font>

1035
00:56:33,960 --> 00:56:36,619
yes

1036
00:56:53,860 --> 00:56:59,690
you were saying that<font color="#E5E5E5"> you're stopping the</font>

1037
00:56:57,560 --> 00:57:02,810
processes and only the uppermost<font color="#CCCCCC"> route</font>

1038
00:56:59,690 --> 00:57:05,000
can kill them now<font color="#CCCCCC"> does this mean you</font>

1039
00:57:02,810 --> 00:57:07,160
could we<font color="#CCCCCC"> could attack you now with</font>

1040
00:57:05,000 --> 00:57:12,140
denial<font color="#E5E5E5"> of service by exhausting all your</font>

1041
00:57:07,160 --> 00:57:15,460
process IDs<font color="#E5E5E5"> try let's say that</font><font color="#CCCCCC"> Jim I</font>

1042
00:57:12,140 --> 00:57:19,879
<font color="#CCCCCC">think is my wife and limiting users is</font>

1043
00:57:15,460 --> 00:57:22,220
<font color="#E5E5E5">not so hard so there is</font><font color="#CCCCCC"> one shared</font>

1044
00:57:19,880 --> 00:57:26,600
hosting<font color="#E5E5E5"> environments at least an hour</font>

1045
00:57:22,220 --> 00:57:28,250
you have the max process limit first for

1046
00:57:26,600 --> 00:57:31,310
the user then you<font color="#E5E5E5"> have a control group</font>

1047
00:57:28,250 --> 00:57:33,860
<font color="#CCCCCC">for that user</font><font color="#E5E5E5"> and then you have another</font>

1048
00:57:31,310 --> 00:57:36,290
<font color="#E5E5E5">control group for</font><font color="#CCCCCC"> this container machine</font>

1049
00:57:33,860 --> 00:57:38,330
and then inside this container<font color="#E5E5E5"> you have</font>

1050
00:57:36,290 --> 00:57:41,869
<font color="#E5E5E5">another control group</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> is limiting</font>

1051
00:57:38,330 --> 00:57:44,660
and we will still have processes<font color="#CCCCCC"> left on</font>

1052
00:57:41,869 --> 00:57:47,900
the host<font color="#E5E5E5"> machine and since we</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> using</font>

1053
00:57:44,660 --> 00:57:49,670
namespaces for the containers let's look

1054
00:57:47,900 --> 00:57:51,740
at the container site where we<font color="#CCCCCC"> have an</font>

1055
00:57:49,670 --> 00:57:53,630
attacker that<font color="#E5E5E5"> has bought a container</font>

1056
00:57:51,740 --> 00:58:00,140
with root access on our infrastructure

1057
00:57:53,630 --> 00:58:04,250
<font color="#E5E5E5">and she has his own</font><font color="#CCCCCC"> bid namespace</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> he</font>

1058
00:58:00,140 --> 00:58:06,049
can<font color="#CCCCCC"> affect only his own container it is</font>

1059
00:58:04,250 --> 00:58:08,660
not going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> affect</font><font color="#E5E5E5"> the host machine</font>

1060
00:58:06,050 --> 00:58:13,280
<font color="#CCCCCC">it's not a big problem we currently</font><font color="#E5E5E5"> have</font>

1061
00:58:08,660 --> 00:58:15,680
<font color="#E5E5E5">machines with between 20 and</font><font color="#CCCCCC"> 30</font>

1062
00:58:13,280 --> 00:58:18,830
<font color="#CCCCCC">thousands process earning at the same</font>

1063
00:58:15,680 --> 00:58:20,930
time and it's<font color="#E5E5E5"> not a problem and I have</font>

1064
00:58:18,830 --> 00:58:23,200
<font color="#CCCCCC">personally tested to a million</font><font color="#E5E5E5"> without a</font>

1065
00:58:20,930 --> 00:58:23,200
problem

1066
00:58:24,280 --> 00:58:39,030
other questions<font color="#CCCCCC"> yes how how bad is</font>

1067
00:58:34,869 --> 00:58:42,730
leaking<font color="#CCCCCC"> for kilobytes let's say that not</font>

1068
00:58:39,030 --> 00:58:47,080
many people<font color="#E5E5E5"> have SSH keys that are</font><font color="#CCCCCC"> 4</font>

1069
00:58:42,730 --> 00:58:56,140
kilobytes<font color="#E5E5E5"> most use</font><font color="#CCCCCC"> 2q by</font><font color="#E5E5E5"> T's and this is</font>

1070
00:58:47,080 --> 00:58:59,170
<font color="#E5E5E5">SSH key how bad is it you tell me so the</font>

1071
00:58:56,140 --> 00:59:03,190
question is when<font color="#E5E5E5"> the</font><font color="#CCCCCC"> attacker gets</font><font color="#E5E5E5"> the</font>

1072
00:58:59,170 --> 00:59:05,770
<font color="#CCCCCC">4k does he knows what he</font><font color="#E5E5E5"> gets or he</font>

1073
00:59:03,190 --> 00:59:07,480
<font color="#E5E5E5">needs more data to</font><font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to know all</font>

1074
00:59:05,770 --> 00:59:09,970
these things<font color="#CCCCCC"> which usually usually</font><font color="#E5E5E5"> the</font>

1075
00:59:07,480 --> 00:59:13,050
attacker<font color="#E5E5E5"> needs more data statistical</font>

1076
00:59:09,970 --> 00:59:16,720
data to actually<font color="#E5E5E5"> understand what he got</font>

1077
00:59:13,050 --> 00:59:19,630
however<font color="#E5E5E5"> depending on</font><font color="#CCCCCC"> the memory address</font>

1078
00:59:16,720 --> 00:59:22,330
from where he<font color="#E5E5E5"> got it and based on the</font>

1079
00:59:19,630 --> 00:59:24,790
idea<font color="#CCCCCC"> that the Linux</font><font color="#E5E5E5"> kernel source is</font>

1080
00:59:22,330 --> 00:59:27,960
<font color="#E5E5E5">available to everyone and knowing the</font>

1081
00:59:24,790 --> 00:59:33,070
version<font color="#E5E5E5"> of the kernel</font><font color="#CCCCCC"> you would actually</font>

1082
00:59:27,960 --> 00:59:36,490
<font color="#E5E5E5">easily guess what you got from there if</font>

1083
00:59:33,070 --> 00:59:39,670
it is<font color="#CCCCCC"> a user</font><font color="#E5E5E5"> space memory</font><font color="#CCCCCC"> then you can</font>

1084
00:59:36,490 --> 00:59:41,950
try<font color="#E5E5E5"> to without attacking the</font><font color="#CCCCCC"> Machine</font>

1085
00:59:39,670 --> 00:59:45,940
<font color="#E5E5E5">without actually triggering meltdown</font><font color="#CCCCCC"> you</font>

1086
00:59:41,950 --> 00:59:48,759
<font color="#CCCCCC">can try to see what each library is</font>

1087
00:59:45,940 --> 00:59:53,500
loading into memory how it<font color="#E5E5E5"> looks like as</font>

1088
00:59:48,760 --> 00:59:56,650
a memory layout<font color="#E5E5E5"> and again with pretty</font>

1089
00:59:53,500 --> 01:00:00,369
<font color="#E5E5E5">easily get the right assumption that</font>

1090
00:59:56,650 --> 01:00:03,280
this<font color="#CCCCCC"> is for example</font><font color="#E5E5E5"> from the new PG or</font>

1091
01:00:00,369 --> 01:00:07,260
<font color="#E5E5E5">from</font><font color="#CCCCCC"> OpenSSH or from open SSL or</font>

1092
01:00:03,280 --> 01:00:10,869
whatever so<font color="#CCCCCC"> the libraries are not so</font>

1093
01:00:07,260 --> 01:00:14,140
they're not the same<font color="#E5E5E5"> as memory footprint</font>

1094
01:00:10,869 --> 01:00:16,240
<font color="#E5E5E5">so you could actually very easily find</font>

1095
01:00:14,140 --> 01:00:18,848
out that<font color="#CCCCCC"> if you</font><font color="#E5E5E5"> have this structure in</font>

1096
01:00:16,240 --> 01:00:20,740
memory<font color="#E5E5E5"> this is a structure from open SSL</font>

1097
01:00:18,849 --> 01:00:22,630
if you have this structure<font color="#E5E5E5"> from memory</font>

1098
01:00:20,740 --> 01:00:25,419
<font color="#CCCCCC">this is from managing</font><font color="#E5E5E5"> or this is from</font>

1099
01:00:22,630 --> 01:00:27,490
<font color="#CCCCCC">OpenSSH so if you're a good attacker</font><font color="#E5E5E5"> and</font>

1100
01:00:25,420 --> 01:00:32,260
you already<font color="#E5E5E5"> have</font><font color="#CCCCCC"> these statistics on</font>

1101
01:00:27,490 --> 01:00:36,450
your machine yeah you can assume a lot

1102
01:00:32,260 --> 01:00:36,450
<font color="#E5E5E5">of things about memory that</font><font color="#CCCCCC"> you got or</font>

1103
01:00:36,920 --> 01:00:40,430
other questions

1104
01:00:41,110 --> 01:00:49,090
then thank you<font color="#CCCCCC"> very much I hope you</font>

1105
01:00:48,250 --> 01:01:00,390
enjoyed<font color="#E5E5E5"> it</font>

1106
01:00:49,090 --> 01:01:01,250
[Music]

1107
01:01:00,390 --> 01:01:04,460
[Applause]

1108
01:01:01,250 --> 01:01:04,460
[Music]

