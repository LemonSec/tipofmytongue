1
00:00:05,870 --> 00:00:08,929
[Music]

2
00:00:09,360 --> 00:00:11,760
all right

3
00:00:11,920 --> 00:00:14,240
thanks everybody for showing up to this

4
00:00:14,240 --> 00:00:16,960
fourth day of the conference

5
00:00:16,960 --> 00:00:19,920
uh it's now 9 30 and we'll start the

6
00:00:19,920 --> 00:00:23,279
first presentation of the day

7
00:00:23,279 --> 00:00:26,640
and with me now i have matthias and

8
00:00:26,640 --> 00:00:28,320
patrick

9
00:00:28,320 --> 00:00:30,960
who will take us deep

10
00:00:30,960 --> 00:00:35,440
into the world of malware engineering

11
00:00:35,760 --> 00:00:38,399
i'll hand it over to them now and

12
00:00:38,399 --> 00:00:40,719
enjoy

13
00:00:43,760 --> 00:00:46,879
all right good morning everyone um

14
00:00:46,879 --> 00:00:48,320
i'm still surprised that there's so many

15
00:00:48,320 --> 00:00:49,840
people here because it's already or it's

16
00:00:49,840 --> 00:00:53,120
still early in the morning right um so

17
00:00:53,120 --> 00:00:56,079
we will try to make the best for it

18
00:00:56,079 --> 00:00:57,840
it's a pretty exciting moment for us

19
00:00:57,840 --> 00:00:59,840
because it's the first time for both of

20
00:00:59,840 --> 00:01:01,120
us that we're here at such a huge

21
00:01:01,120 --> 00:01:02,719
conference and it's also the first time

22
00:01:02,719 --> 00:01:04,479
that we do speaking here

23
00:01:04,479 --> 00:01:06,960
uh so it's yeah kind of pretty exciting

24
00:01:06,960 --> 00:01:09,280
within the next half an hour probably we

25
00:01:09,280 --> 00:01:12,720
will um talk about is everything

26
00:01:12,720 --> 00:01:14,400
and it will be about

27
00:01:14,400 --> 00:01:16,799
memory dumping for malware analysis and

28
00:01:16,799 --> 00:01:18,720
we will talk about our experience with

29
00:01:18,720 --> 00:01:20,080
it from the past we just want to share

30
00:01:20,080 --> 00:01:23,200
it with you um and yeah hopefully

31
00:01:23,200 --> 00:01:25,040
basically everybody can can get some

32
00:01:25,040 --> 00:01:27,439
informations out of it

33
00:01:27,439 --> 00:01:29,439
so very quick introduction for us this

34
00:01:29,439 --> 00:01:31,520
is my colleague matthias i'm patrick we

35
00:01:31,520 --> 00:01:34,960
both joined vmware back in 2019

36
00:01:34,960 --> 00:01:37,439
um if you haven't heard of vmware before

37
00:01:37,439 --> 00:01:39,280
please feel free to stop by our move at

38
00:01:39,280 --> 00:01:40,640
the ground floor our colleagues there

39
00:01:40,640 --> 00:01:42,320
will be very happy to give an

40
00:01:42,320 --> 00:01:44,159
introduction what we're doing

41
00:01:44,159 --> 00:01:46,240
and parts of our

42
00:01:46,240 --> 00:01:47,680
daily business are basically metal

43
00:01:47,680 --> 00:01:51,200
analysis we do reverse engineering we do

44
00:01:51,200 --> 00:01:53,040
monitoring the threat landscape we do

45
00:01:53,040 --> 00:01:55,759
family monitoring basically

46
00:01:55,759 --> 00:01:57,280
and out of the information we get from

47
00:01:57,280 --> 00:01:59,600
there we are developing configuration

48
00:01:59,600 --> 00:02:02,880
extractor from alba to extract iocs

49
00:02:02,880 --> 00:02:05,119
and we do also basically improve

50
00:02:05,119 --> 00:02:06,960
signature-based deductions for

51
00:02:06,960 --> 00:02:09,840
those kind of families

52
00:02:09,840 --> 00:02:11,440
so today we want to talk about memory

53
00:02:11,440 --> 00:02:13,520
dumping and the first questions of it

54
00:02:13,520 --> 00:02:17,280
might be why do we need it in general

55
00:02:17,280 --> 00:02:19,040
that's somehow pretty easy to explain

56
00:02:19,040 --> 00:02:22,160
because malware is mostly delivered in a

57
00:02:22,160 --> 00:02:24,640
packed or encrypted state to the to its

58
00:02:24,640 --> 00:02:27,599
target and the reason for it is because

59
00:02:27,599 --> 00:02:29,360
the authors or the threat actor

60
00:02:29,360 --> 00:02:31,760
basically just doesn't want to

61
00:02:31,760 --> 00:02:34,560
get its malware to get its software what

62
00:02:34,560 --> 00:02:36,239
he developed basically to be detected

63
00:02:36,239 --> 00:02:37,760
already somewhere in the delivery way

64
00:02:37,760 --> 00:02:39,840
right so he always wants that the end

65
00:02:39,840 --> 00:02:41,840
system is getting infected

66
00:02:41,840 --> 00:02:44,319
and packing or encrypting stuff is a

67
00:02:44,319 --> 00:02:46,640
very popular way to just bypass those

68
00:02:46,640 --> 00:02:48,480
security measurements

69
00:02:48,480 --> 00:02:51,040
either they have an automated way or

70
00:02:51,040 --> 00:02:52,560
either it's it's also pretty good

71
00:02:52,560 --> 00:02:55,280
protection against melbourne analysis

72
00:02:55,280 --> 00:02:56,160
and

73
00:02:56,160 --> 00:02:57,920
what can we do against it i mean there's

74
00:02:57,920 --> 00:02:59,840
a simple solution so we just can write

75
00:02:59,840 --> 00:03:02,319
an unpacker for each available packer

76
00:03:02,319 --> 00:03:04,239
that's probably the most easiest thing

77
00:03:04,239 --> 00:03:05,200
but

78
00:03:05,200 --> 00:03:06,879
this was used in the past and it turned

79
00:03:06,879 --> 00:03:09,200
out to be very complex

80
00:03:09,200 --> 00:03:12,000
and it also requires lots of maintenance

81
00:03:12,000 --> 00:03:13,680
just due to the fact that there are so

82
00:03:13,680 --> 00:03:15,760
many different packets available some of

83
00:03:15,760 --> 00:03:17,360
them are commercial some of them just

84
00:03:17,360 --> 00:03:19,200
open source and everybody else who

85
00:03:19,200 --> 00:03:21,200
basically has the knowledge can write

86
00:03:21,200 --> 00:03:23,760
out his own one and that's probably the

87
00:03:23,760 --> 00:03:25,120
thing why those things are getting too

88
00:03:25,120 --> 00:03:26,400
complex

89
00:03:26,400 --> 00:03:27,280
and

90
00:03:27,280 --> 00:03:29,680
therefore we need a way

91
00:03:29,680 --> 00:03:31,920
kind of a generic way how we can bypass

92
00:03:31,920 --> 00:03:34,000
this issue and how we can approach this

93
00:03:34,000 --> 00:03:35,519
in a more generic way without having

94
00:03:35,519 --> 00:03:37,599
this high maintenance

95
00:03:37,599 --> 00:03:39,680
and this is exactly the reason or the

96
00:03:39,680 --> 00:03:41,360
situation where memory dumping comes

97
00:03:41,360 --> 00:03:43,440
into place

98
00:03:43,440 --> 00:03:45,840
so what is the idea of it and what are

99
00:03:45,840 --> 00:03:47,599
our goals with it

100
00:03:47,599 --> 00:03:50,080
we just want to to take the sample we

101
00:03:50,080 --> 00:03:52,879
want to execute or let execute itself

102
00:03:52,879 --> 00:03:55,280
and during this there must be some way

103
00:03:55,280 --> 00:03:57,920
how the sample unpacks itself

104
00:03:57,920 --> 00:03:59,840
and we want to let it let do this step

105
00:03:59,840 --> 00:04:01,519
by the sample itself

106
00:04:01,519 --> 00:04:04,159
um and once done so basically at some

107
00:04:04,159 --> 00:04:06,480
certain point during the execution um

108
00:04:06,480 --> 00:04:08,959
the unpacking is done the sample um

109
00:04:08,959 --> 00:04:11,760
basically the packer has decrypted or

110
00:04:11,760 --> 00:04:14,239
de-obfuscated its payload and this is

111
00:04:14,239 --> 00:04:15,680
exactly the point where we just want to

112
00:04:15,680 --> 00:04:16,880
jump into

113
00:04:16,880 --> 00:04:19,120
we will find it in the process memory we

114
00:04:19,120 --> 00:04:21,199
will read it out basically so we will

115
00:04:21,199 --> 00:04:22,560
dump it and write it anywhere else so

116
00:04:22,560 --> 00:04:25,280
that we can use it later on

117
00:04:25,280 --> 00:04:27,520
this has a lot of advantages so it makes

118
00:04:27,520 --> 00:04:30,160
the analysis and also detection way more

119
00:04:30,160 --> 00:04:33,440
easier just due to the fact that

120
00:04:33,440 --> 00:04:35,360
we have access to the actual payload so

121
00:04:35,360 --> 00:04:37,120
there's nothing probably nothing

122
00:04:37,120 --> 00:04:39,199
encrypted anymore

123
00:04:39,199 --> 00:04:41,120
we can also use signature base detection

124
00:04:41,120 --> 00:04:44,960
on it to identify the family to identify

125
00:04:44,960 --> 00:04:46,960
versioning and stuff like this

126
00:04:46,960 --> 00:04:49,040
and we also can use melba configuration

127
00:04:49,040 --> 00:04:50,960
extraction based on this data because

128
00:04:50,960 --> 00:04:53,600
it's obviously in an unpacked state

129
00:04:53,600 --> 00:04:56,639
and the goal is to get really good iocs

130
00:04:56,639 --> 00:04:58,320
out of it

131
00:04:58,320 --> 00:05:00,320
and to summarize this in just one simple

132
00:05:00,320 --> 00:05:01,600
sentence

133
00:05:01,600 --> 00:05:03,520
we want to create as few high quality

134
00:05:03,520 --> 00:05:05,520
memory dumps as possible but still as

135
00:05:05,520 --> 00:05:07,199
many as needed

136
00:05:07,199 --> 00:05:09,440
and we define a high quality memory dump

137
00:05:09,440 --> 00:05:12,479
in a certain way that we say it contains

138
00:05:12,479 --> 00:05:14,800
valuable data for us valuable data for

139
00:05:14,800 --> 00:05:16,960
an analyst for example so either if it's

140
00:05:16,960 --> 00:05:20,639
the unpacked payload or if it's

141
00:05:20,639 --> 00:05:22,400
some additional data like decrypted

142
00:05:22,400 --> 00:05:23,919
configuration data everything but

143
00:05:23,919 --> 00:05:25,840
somehow provides us some information is

144
00:05:25,840 --> 00:05:28,560
available for us

145
00:05:29,280 --> 00:05:31,360
so this leads probably to the question

146
00:05:31,360 --> 00:05:33,440
is memory dumping really that hard and i

147
00:05:33,440 --> 00:05:34,800
guess if it

148
00:05:34,800 --> 00:05:36,560
would not be that hard we may not stand

149
00:05:36,560 --> 00:05:40,240
here today but it turns out that it is

150
00:05:40,240 --> 00:05:41,919
there are a couple of reasons for it so

151
00:05:41,919 --> 00:05:44,080
one reason is basically

152
00:05:44,080 --> 00:05:46,160
we need to find the correct timing so as

153
00:05:46,160 --> 00:05:48,160
mentioned earlier

154
00:05:48,160 --> 00:05:50,720
at a point during process execution we

155
00:05:50,720 --> 00:05:52,960
want to identify when the sample has

156
00:05:52,960 --> 00:05:54,880
unpacked itself

157
00:05:54,880 --> 00:05:56,960
so we need to find the correct time when

158
00:05:56,960 --> 00:05:59,599
this happened

159
00:06:00,080 --> 00:06:01,759
and at that certain point of time we

160
00:06:01,759 --> 00:06:03,280
just want to search and we want to dump

161
00:06:03,280 --> 00:06:03,919
it

162
00:06:03,919 --> 00:06:05,520
but there's a different thing and

163
00:06:05,520 --> 00:06:06,800
different issue basically it's

164
00:06:06,800 --> 00:06:08,080
performance

165
00:06:08,080 --> 00:06:10,560
so we can also dump a lot during process

166
00:06:10,560 --> 00:06:11,759
execution

167
00:06:11,759 --> 00:06:13,280
but this will slow down the performance

168
00:06:13,280 --> 00:06:15,120
in general because for dumping process

169
00:06:15,120 --> 00:06:17,759
memory you need to pause the execution

170
00:06:17,759 --> 00:06:19,680
um you need to read the memory and you

171
00:06:19,680 --> 00:06:21,039
need to write it out so this just slows

172
00:06:21,039 --> 00:06:22,560
down everything

173
00:06:22,560 --> 00:06:24,720
so what we need or what we we want to

174
00:06:24,720 --> 00:06:27,039
have are some kind of generic trigger

175
00:06:27,039 --> 00:06:29,840
events which are somehow pretty pretty

176
00:06:29,840 --> 00:06:32,240
good and high quality

177
00:06:32,240 --> 00:06:34,319
that are actually addressing those

178
00:06:34,319 --> 00:06:36,080
issues so we want those events to be at

179
00:06:36,080 --> 00:06:38,160
the correct time and we also want those

180
00:06:38,160 --> 00:06:41,039
events to to bypass this or yeah to fix

181
00:06:41,039 --> 00:06:44,400
this issue with the performance

182
00:06:44,800 --> 00:06:46,479
so there are already some some

183
00:06:46,479 --> 00:06:48,560
well-known triggers out there and they

184
00:06:48,560 --> 00:06:49,919
are available

185
00:06:49,919 --> 00:06:52,319
they i think exist already a couple of

186
00:06:52,319 --> 00:06:54,319
years for a long time basically

187
00:06:54,319 --> 00:06:55,759
the first one is a pretty simple one

188
00:06:55,759 --> 00:06:57,599
it's just we want to dump executable

189
00:06:57,599 --> 00:06:59,280
memory regions when the process

190
00:06:59,280 --> 00:07:00,880
terminates

191
00:07:00,880 --> 00:07:02,960
it's a very simple idea

192
00:07:02,960 --> 00:07:04,639
it's still pretty useful it still works

193
00:07:04,639 --> 00:07:06,720
and we still use it

194
00:07:06,720 --> 00:07:08,800
but it could be the case that

195
00:07:08,800 --> 00:07:11,440
the data we get out of it is not enough

196
00:07:11,440 --> 00:07:13,360
so it can happen that for example the

197
00:07:13,360 --> 00:07:15,280
unpacked payload or any kind of

198
00:07:15,280 --> 00:07:17,039
additional data is not available anymore

199
00:07:17,039 --> 00:07:18,080
because

200
00:07:18,080 --> 00:07:20,479
memory regions were he reused they were

201
00:07:20,479 --> 00:07:22,080
overwritten they were freed already

202
00:07:22,080 --> 00:07:24,000
turned back to the operating system so a

203
00:07:24,000 --> 00:07:27,680
couple of reasons why this can be hard

204
00:07:28,800 --> 00:07:30,400
we can bypass or we can address this

205
00:07:30,400 --> 00:07:32,240
issue with a different trigger we can or

206
00:07:32,240 --> 00:07:34,240
with a different approach so we can say

207
00:07:34,240 --> 00:07:36,160
for example instead of dumping only

208
00:07:36,160 --> 00:07:38,000
implosive termination

209
00:07:38,000 --> 00:07:39,440
we dump every

210
00:07:39,440 --> 00:07:41,919
time or quite often when memory regions

211
00:07:41,919 --> 00:07:43,520
are getting freed when memory regions

212
00:07:43,520 --> 00:07:45,360
are getting overwritten

213
00:07:45,360 --> 00:07:47,520
we just take them and we dump them

214
00:07:47,520 --> 00:07:49,520
this would provide us way more memory

215
00:07:49,520 --> 00:07:50,639
dumps

216
00:07:50,639 --> 00:07:53,360
and probably way too much of them

217
00:07:53,360 --> 00:07:54,479
especially

218
00:07:54,479 --> 00:07:56,879
when you use frameworks underneath

219
00:07:56,879 --> 00:08:00,800
execution like java.net they frequently

220
00:08:00,800 --> 00:08:02,720
require memory allocations they

221
00:08:02,720 --> 00:08:04,479
frequently free memory to earn a memory

222
00:08:04,479 --> 00:08:06,319
back so this would produce a lot of

223
00:08:06,319 --> 00:08:07,360
noise

224
00:08:07,360 --> 00:08:09,520
and end up with with yeah data we

225
00:08:09,520 --> 00:08:10,800
probably don't need because it's not

226
00:08:10,800 --> 00:08:12,479
relevant for us because it's just used

227
00:08:12,479 --> 00:08:15,758
by the framework itself

228
00:08:16,000 --> 00:08:17,440
but still those two memory dumping

229
00:08:17,440 --> 00:08:19,199
trigger reasons are pretty good and

230
00:08:19,199 --> 00:08:20,800
they're pretty used but as mentioned

231
00:08:20,800 --> 00:08:22,400
they might just not be enough so there

232
00:08:22,400 --> 00:08:24,319
must be more we need to find we need to

233
00:08:24,319 --> 00:08:26,160
address certain issues which are still

234
00:08:26,160 --> 00:08:28,080
exist here

235
00:08:28,080 --> 00:08:32,639
so to to summarize the issues we have

236
00:08:32,719 --> 00:08:33,599
we have

237
00:08:33,599 --> 00:08:35,839
very existing approaches they are good

238
00:08:35,839 --> 00:08:37,519
we still use them and we are happy that

239
00:08:37,519 --> 00:08:39,919
they are basically there

240
00:08:39,919 --> 00:08:42,399
but they are in some cases when a lot of

241
00:08:42,399 --> 00:08:44,399
cases just not good enough so there must

242
00:08:44,399 --> 00:08:45,519
be more

243
00:08:45,519 --> 00:08:48,399
um as mentioned before we could have and

244
00:08:48,399 --> 00:08:50,320
could end up with the issue that there

245
00:08:50,320 --> 00:08:52,080
are

246
00:08:52,080 --> 00:08:53,760
just not enough data so we miss some

247
00:08:53,760 --> 00:08:55,360
important things that could be the

248
00:08:55,360 --> 00:08:57,440
reason that we have too many data so we

249
00:08:57,440 --> 00:08:59,360
have lots of memory dumps we need to

250
00:08:59,360 --> 00:09:01,279
manually investigate them which takes

251
00:09:01,279 --> 00:09:02,240
time

252
00:09:02,240 --> 00:09:04,959
which is time consuming and just we

253
00:09:04,959 --> 00:09:06,839
doesn't want to to do that

254
00:09:06,839 --> 00:09:10,399
basically and it could also happen that

255
00:09:10,399 --> 00:09:13,120
those memory dumps we get have a low

256
00:09:13,120 --> 00:09:15,839
quality or bad quality and bad quality

257
00:09:15,839 --> 00:09:17,360
for us is just if those stumps are

258
00:09:17,360 --> 00:09:19,200
containing data which are not relevant

259
00:09:19,200 --> 00:09:20,160
at all

260
00:09:20,160 --> 00:09:21,760
for example

261
00:09:21,760 --> 00:09:23,360
it's just a couple of bytes which have

262
00:09:23,360 --> 00:09:25,360
been changed uh there are some null bets

263
00:09:25,360 --> 00:09:27,279
in it this is related to to any

264
00:09:27,279 --> 00:09:29,279
framework so just dumps which we're not

265
00:09:29,279 --> 00:09:31,200
interested in should not be done because

266
00:09:31,200 --> 00:09:32,880
this will slow down the process for us

267
00:09:32,880 --> 00:09:34,240
as well

268
00:09:34,240 --> 00:09:37,360
as an analyst for example

269
00:09:37,360 --> 00:09:39,200
there are also some open source

270
00:09:39,200 --> 00:09:41,920
solutions which exist there um in most

271
00:09:41,920 --> 00:09:43,920
cases they're focusing on on different

272
00:09:43,920 --> 00:09:46,000
goals and on different approaches but

273
00:09:46,000 --> 00:09:47,920
they are still

274
00:09:47,920 --> 00:09:49,519
can be used for memory damping so for

275
00:09:49,519 --> 00:09:51,760
example there's pe seif

276
00:09:51,760 --> 00:09:54,240
from hashtag servers8 but please forgive

277
00:09:54,240 --> 00:09:57,519
me if i pronounce that name incorrectly

278
00:09:57,519 --> 00:09:59,920
pec this is a tool it's a library which

279
00:09:59,920 --> 00:10:03,360
can be used to to dump injected payloads

280
00:10:03,360 --> 00:10:05,040
because it just implements a couple of

281
00:10:05,040 --> 00:10:07,120
different trigger reasons of heuristics

282
00:10:07,120 --> 00:10:08,959
which are able to detect those process

283
00:10:08,959 --> 00:10:10,800
injections

284
00:10:10,800 --> 00:10:12,959
and it's mainly designed at least in its

285
00:10:12,959 --> 00:10:15,200
default configuration to dump only

286
00:10:15,200 --> 00:10:18,560
executable regions because in most cases

287
00:10:18,560 --> 00:10:20,079
if you're interested in payloads they

288
00:10:20,079 --> 00:10:21,600
are somewhere stored in executable

289
00:10:21,600 --> 00:10:23,839
regions because those are

290
00:10:23,839 --> 00:10:25,600
executable files those are the lls or

291
00:10:25,600 --> 00:10:27,360
shell codes so the region must somehow

292
00:10:27,360 --> 00:10:30,079
be marked flagged as executable

293
00:10:30,079 --> 00:10:31,839
but this could lead to missing data as

294
00:10:31,839 --> 00:10:33,680
well so for example if the region isn't

295
00:10:33,680 --> 00:10:36,880
flagged as executable the process mildly

296
00:10:36,880 --> 00:10:39,440
the memory might be missed right if we

297
00:10:39,440 --> 00:10:41,360
are interested in regions which are in

298
00:10:41,360 --> 00:10:43,279
general just only readable and writable

299
00:10:43,279 --> 00:10:45,279
because they only contain infrared

300
00:10:45,279 --> 00:10:47,519
configuration data or stuff like this

301
00:10:47,519 --> 00:10:49,279
we could miss them as well so there's

302
00:10:49,279 --> 00:10:51,360
still some some kind of improvement but

303
00:10:51,360 --> 00:10:52,959
it always depends on what you need and

304
00:10:52,959 --> 00:10:55,440
what you want

305
00:10:55,440 --> 00:10:58,640
a different tool is escape sandbox it's

306
00:10:58,640 --> 00:11:00,959
a very powerful sandbox and it's a very

307
00:11:00,959 --> 00:11:02,880
great tool

308
00:11:02,880 --> 00:11:04,640
it focuses awesome configuration and

309
00:11:04,640 --> 00:11:06,640
also payload extraction so it's actually

310
00:11:06,640 --> 00:11:09,279
the same thing we are interested in

311
00:11:09,279 --> 00:11:11,600
but it just uses a different way how

312
00:11:11,600 --> 00:11:14,240
this will be achieved

313
00:11:14,240 --> 00:11:16,640
in cape sandbox they're using some

314
00:11:16,640 --> 00:11:18,880
automated debugging features which you

315
00:11:18,880 --> 00:11:20,800
can define by yourself so you have kind

316
00:11:20,800 --> 00:11:22,560
of a rule set which matches somewhere in

317
00:11:22,560 --> 00:11:25,839
the memory and then you can define

318
00:11:25,839 --> 00:11:27,920
debugging actions basically which are

319
00:11:27,920 --> 00:11:29,600
then just executed when those rules

320
00:11:29,600 --> 00:11:31,920
match so this basically can can write a

321
00:11:31,920 --> 00:11:33,600
rule and when the rule matches then the

322
00:11:33,600 --> 00:11:35,839
debugger will execute your definitions

323
00:11:35,839 --> 00:11:38,160
to defines to basically write right read

324
00:11:38,160 --> 00:11:40,880
and write the memory out of process

325
00:11:40,880 --> 00:11:41,680
but

326
00:11:41,680 --> 00:11:43,600
this has some pre-requirements or it

327
00:11:43,600 --> 00:11:45,519
requires some some some steps you need

328
00:11:45,519 --> 00:11:47,600
to take before because

329
00:11:47,600 --> 00:11:49,360
that you can write those signatures and

330
00:11:49,360 --> 00:11:50,959
then you can write your debugging

331
00:11:50,959 --> 00:11:52,560
actions you need to know the family you

332
00:11:52,560 --> 00:11:53,519
need

333
00:11:53,519 --> 00:11:54,880
you need to know the internals of the

334
00:11:54,880 --> 00:11:57,360
family how it works how it's structured

335
00:11:57,360 --> 00:11:58,720
so you need to analyze it somehow

336
00:11:58,720 --> 00:12:01,040
beforehand already

337
00:12:01,040 --> 00:12:03,279
another thing is that for example

338
00:12:03,279 --> 00:12:05,279
updates to the melba family may also

339
00:12:05,279 --> 00:12:06,720
lead to missing memory dumps because

340
00:12:06,720 --> 00:12:08,639
some internals change and the rules

341
00:12:08,639 --> 00:12:10,240
maybe doesn't match anymore or the

342
00:12:10,240 --> 00:12:12,160
debugging actions won't fit any more

343
00:12:12,160 --> 00:12:13,839
than needs

344
00:12:13,839 --> 00:12:14,880
and

345
00:12:14,880 --> 00:12:16,959
it probably i mean depending on how you

346
00:12:16,959 --> 00:12:18,560
use it in issues also the debugging

347
00:12:18,560 --> 00:12:20,399
always slows down the precis the the

348
00:12:20,399 --> 00:12:22,320
whole performance of the system

349
00:12:22,320 --> 00:12:24,560
debugging is slow

350
00:12:24,560 --> 00:12:26,320
and if you want to have a couple of

351
00:12:26,320 --> 00:12:28,320
thousand samples to be analyzed and get

352
00:12:28,320 --> 00:12:30,480
out a memory dump it might be slow as

353
00:12:30,480 --> 00:12:31,600
well

354
00:12:31,600 --> 00:12:33,680
but still it's a very powerful feature

355
00:12:33,680 --> 00:12:36,000
and it depends on the need what you want

356
00:12:36,000 --> 00:12:39,600
to use it for it's a very good solution

357
00:12:39,600 --> 00:12:40,399
but

358
00:12:40,399 --> 00:12:42,000
we will come up with some

359
00:12:42,000 --> 00:12:44,240
more generic triggers some more generic

360
00:12:44,240 --> 00:12:46,320
events you can use to to dump process

361
00:12:46,320 --> 00:12:47,360
memory

362
00:12:47,360 --> 00:12:48,959
um and that's what we're going to talk

363
00:12:48,959 --> 00:12:50,480
about today

364
00:12:50,480 --> 00:12:52,399
so we want to have a very small set of

365
00:12:52,399 --> 00:12:54,639
trigger events that cover many families

366
00:12:54,639 --> 00:12:57,279
so we don't want to be family specific

367
00:12:57,279 --> 00:12:59,360
we want to find only some events that

368
00:12:59,360 --> 00:13:02,160
apply to multiple families

369
00:13:02,160 --> 00:13:03,519
we also don't want to have that there

370
00:13:03,519 --> 00:13:04,800
are many

371
00:13:04,800 --> 00:13:06,320
that there's many maintenance needed for

372
00:13:06,320 --> 00:13:08,240
those rules so we for this events we

373
00:13:08,240 --> 00:13:11,120
want to have them with less maintenance

374
00:13:11,120 --> 00:13:13,120
and the result we expect from it should

375
00:13:13,120 --> 00:13:15,120
be memory dumps of high quality as

376
00:13:15,120 --> 00:13:17,279
mentioned before um they should contain

377
00:13:17,279 --> 00:13:19,440
valuable data for us

378
00:13:19,440 --> 00:13:21,120
the result of it

379
00:13:21,120 --> 00:13:23,440
should be useful for detection and also

380
00:13:23,440 --> 00:13:26,079
for malware family inference

381
00:13:26,079 --> 00:13:28,959
um it should also be useful to um

382
00:13:28,959 --> 00:13:31,839
develop configure to

383
00:13:31,839 --> 00:13:33,519
get the decrypted file basically to get

384
00:13:33,519 --> 00:13:35,519
decrypted configuration files that we

385
00:13:35,519 --> 00:13:37,440
can have a configuration extraction on

386
00:13:37,440 --> 00:13:39,519
them and we also want to have the final

387
00:13:39,519 --> 00:13:41,760
payload because of signature based

388
00:13:41,760 --> 00:13:43,839
detection and also some further manual

389
00:13:43,839 --> 00:13:45,519
investigation if needed so you really

390
00:13:45,519 --> 00:13:47,680
get the unpacked sample you can throw it

391
00:13:47,680 --> 00:13:49,920
into to add or git or anyone any tool

392
00:13:49,920 --> 00:13:51,519
you basically want to have and they can

393
00:13:51,519 --> 00:13:53,279
look at it

394
00:13:53,279 --> 00:13:54,880
so the trigger events

395
00:13:54,880 --> 00:13:57,120
my colleague matthias will basically now

396
00:13:57,120 --> 00:13:58,560
present to you is

397
00:13:58,560 --> 00:14:00,480
just a couple of of them so it's a small

398
00:14:00,480 --> 00:14:02,880
set of them we have defined in the past

399
00:14:02,880 --> 00:14:05,360
uh just due to timing reasons

400
00:14:05,360 --> 00:14:07,760
and they should and can be useful for

401
00:14:07,760 --> 00:14:09,600
everyone basically so it's not only for

402
00:14:09,600 --> 00:14:11,519
sandboxes it's not only for antivirus

403
00:14:11,519 --> 00:14:12,880
systems

404
00:14:12,880 --> 00:14:14,399
and not only from manual analysis so

405
00:14:14,399 --> 00:14:16,240
there are many different use cases

406
00:14:16,240 --> 00:14:17,360
basically

407
00:14:17,360 --> 00:14:19,600
someone can use them and we hope that

408
00:14:19,600 --> 00:14:23,440
this would help anyone here basically

409
00:14:24,880 --> 00:14:28,240
okay so let's start with an overview of

410
00:14:28,240 --> 00:14:30,160
some of the triggers that work well

411
00:14:30,160 --> 00:14:31,360
together

412
00:14:31,360 --> 00:14:33,120
um we'll be

413
00:14:33,120 --> 00:14:34,880
basically discussing the first four of

414
00:14:34,880 --> 00:14:37,199
them but i'll also

415
00:14:37,199 --> 00:14:38,320
go into

416
00:14:38,320 --> 00:14:41,680
some details for the others

417
00:14:41,680 --> 00:14:43,519
um so let's start with the aggressive

418
00:14:43,519 --> 00:14:46,160
memory dumping of injected processes um

419
00:14:46,160 --> 00:14:50,000
so injection is a big part of unpacking

420
00:14:50,000 --> 00:14:52,880
at least that's often the case um

421
00:14:52,880 --> 00:14:55,120
basically when the pucker starts

422
00:14:55,120 --> 00:14:57,760
executing the payload um the packed

423
00:14:57,760 --> 00:15:00,000
payload compressed encrypted payload

424
00:15:00,000 --> 00:15:01,519
somewhere in the

425
00:15:01,519 --> 00:15:03,680
the binary maybe in the resources and so

426
00:15:03,680 --> 00:15:05,519
so when it's encrypted it's then

427
00:15:05,519 --> 00:15:07,760
injected into a separate process

428
00:15:07,760 --> 00:15:10,880
and we could and probably should dump it

429
00:15:10,880 --> 00:15:12,959
at this point but that's often not

430
00:15:12,959 --> 00:15:15,760
enough um so there are often multiple

431
00:15:15,760 --> 00:15:17,040
stages to

432
00:15:17,040 --> 00:15:19,680
unpacking and we might not get the

433
00:15:19,680 --> 00:15:22,399
actual payload at that point but just a

434
00:15:22,399 --> 00:15:24,560
encrypted blob of data with a a step

435
00:15:24,560 --> 00:15:28,079
that's responsible for um decrypting it

436
00:15:28,079 --> 00:15:31,120
so from our experience a good um

437
00:15:31,120 --> 00:15:33,440
approximation is

438
00:15:33,440 --> 00:15:35,360
basically to wait till the process

439
00:15:35,360 --> 00:15:37,199
terminates and

440
00:15:37,199 --> 00:15:39,680
it can be either self-termination or if

441
00:15:39,680 --> 00:15:42,160
it's a sandbox basically analysis an

442
00:15:42,160 --> 00:15:43,839
external timeout

443
00:15:43,839 --> 00:15:46,639
and at that point we want to dump

444
00:15:46,639 --> 00:15:48,160
various memory regions so we are

445
00:15:48,160 --> 00:15:50,480
interested in the executable regions

446
00:15:50,480 --> 00:15:52,880
obviously to get the payload but also in

447
00:15:52,880 --> 00:15:55,199
the retried regions because those often

448
00:15:55,199 --> 00:15:57,199
contain the

449
00:15:57,199 --> 00:16:00,959
decrypted configuration files

450
00:16:01,680 --> 00:16:03,839
the next trigger

451
00:16:03,839 --> 00:16:06,959
a very interesting one and

452
00:16:06,959 --> 00:16:08,639
very simple

453
00:16:08,639 --> 00:16:10,720
is the first network behavior

454
00:16:10,720 --> 00:16:13,040
it also works very well as we'll see

455
00:16:13,040 --> 00:16:14,320
later

456
00:16:14,320 --> 00:16:18,399
the idea is very simple so basically the

457
00:16:18,399 --> 00:16:22,079
malware or the majority of it will try

458
00:16:22,079 --> 00:16:24,240
at some point to communicate with a with

459
00:16:24,240 --> 00:16:26,079
an external server

460
00:16:26,079 --> 00:16:28,000
so

461
00:16:28,000 --> 00:16:31,680
when we detect the communication

462
00:16:31,680 --> 00:16:34,639
we want to perform a memory done so

463
00:16:34,639 --> 00:16:36,560
at that point we expect that the malware

464
00:16:36,560 --> 00:16:39,120
is unpacked um it has to be in a

465
00:16:39,120 --> 00:16:42,880
runnable state and also um at least the

466
00:16:42,880 --> 00:16:45,519
address of the server it's like url ip

467
00:16:45,519 --> 00:16:47,680
and port has to be somewhere in in

468
00:16:47,680 --> 00:16:48,800
memory

469
00:16:48,800 --> 00:16:51,519
so that's our expectation and

470
00:16:51,519 --> 00:16:53,040
when we detect the first network

471
00:16:53,040 --> 00:16:54,880
behavior we want to perform a dump of

472
00:16:54,880 --> 00:16:57,199
the process so we want to dump the again

473
00:16:57,199 --> 00:16:59,680
executable regions the

474
00:16:59,680 --> 00:17:01,199
read write regions

475
00:17:01,199 --> 00:17:02,959
and also the

476
00:17:02,959 --> 00:17:06,000
thread stacks basically because those

477
00:17:06,000 --> 00:17:09,119
also can contain decrypted configuration

478
00:17:09,119 --> 00:17:13,199
urls and so on um so not every malware

479
00:17:13,199 --> 00:17:14,959
uses the heap for that

480
00:17:14,959 --> 00:17:17,199
um we want them all what we do not want

481
00:17:17,199 --> 00:17:20,400
to uh dump are basically

482
00:17:20,400 --> 00:17:22,640
system files like mapped

483
00:17:22,640 --> 00:17:25,439
dlls and so on that were not modified so

484
00:17:25,439 --> 00:17:28,799
just to limit the amount of data that we

485
00:17:28,799 --> 00:17:31,280
extract

486
00:17:31,760 --> 00:17:33,039
the next one

487
00:17:33,039 --> 00:17:34,559
covers kind of a

488
00:17:34,559 --> 00:17:35,840
niche

489
00:17:35,840 --> 00:17:36,640
so

490
00:17:36,640 --> 00:17:37,760
net

491
00:17:37,760 --> 00:17:40,160
is tricky and

492
00:17:40,160 --> 00:17:43,600
especially the reflective load which is

493
00:17:43,600 --> 00:17:46,400
part of the system reflection happy is

494
00:17:46,400 --> 00:17:48,799
hard to detect and the other triggers

495
00:17:48,799 --> 00:17:50,240
might not work

496
00:17:50,240 --> 00:17:52,799
so well for it

497
00:17:52,799 --> 00:17:55,840
just due to the overhead that dotnet

498
00:17:55,840 --> 00:17:58,960
performs so the api calls basically

499
00:17:58,960 --> 00:18:01,440
don't translate well to the low level

500
00:18:01,440 --> 00:18:05,760
ones so in the kernel 32 dll or the ntdl

501
00:18:05,760 --> 00:18:08,000
and

502
00:18:08,320 --> 00:18:10,480
it's also very powerful so it's often

503
00:18:10,480 --> 00:18:12,559
used by

504
00:18:12,559 --> 00:18:15,360
net based packers where the payload is

505
00:18:15,360 --> 00:18:17,200
stored somewhere and

506
00:18:17,200 --> 00:18:19,120
it's kind of a self-injection

507
00:18:19,120 --> 00:18:21,120
so you can load it from memory or from

508
00:18:21,120 --> 00:18:23,280
from file into

509
00:18:23,280 --> 00:18:25,120
your own process space

510
00:18:25,120 --> 00:18:27,200
and start executing it

511
00:18:27,200 --> 00:18:31,120
it's also used as the fileless attack so

512
00:18:31,120 --> 00:18:33,039
it can be downloaded directly from from

513
00:18:33,039 --> 00:18:35,039
some server and

514
00:18:35,039 --> 00:18:37,200
basically load it into memory without

515
00:18:37,200 --> 00:18:39,520
dropping into disk and we want to detect

516
00:18:39,520 --> 00:18:41,360
that

517
00:18:41,360 --> 00:18:43,840
so as i said it does not translate well

518
00:18:43,840 --> 00:18:46,400
to the low level apis but there is a

519
00:18:46,400 --> 00:18:47,440
pattern

520
00:18:47,440 --> 00:18:49,520
so basically depending on what you are

521
00:18:49,520 --> 00:18:51,840
monitoring you can detect this

522
00:18:51,840 --> 00:18:54,080
and at that point we want to

523
00:18:54,080 --> 00:18:57,840
to dump the buffer which often contains

524
00:18:57,840 --> 00:19:01,760
the already unpacked payload

525
00:19:03,440 --> 00:19:04,960
finally the

526
00:19:04,960 --> 00:19:07,280
the next one is

527
00:19:07,280 --> 00:19:09,120
kind of an extension to existing

528
00:19:09,120 --> 00:19:10,400
triggers

529
00:19:10,400 --> 00:19:11,360
so

530
00:19:11,360 --> 00:19:12,559
that we can

531
00:19:12,559 --> 00:19:15,120
rapidly

532
00:19:15,120 --> 00:19:16,480
add changes

533
00:19:16,480 --> 00:19:18,640
so if if we detect that

534
00:19:18,640 --> 00:19:21,520
the memory dumping is not working well

535
00:19:21,520 --> 00:19:23,039
and

536
00:19:23,039 --> 00:19:25,360
basically maybe there's a new technique

537
00:19:25,360 --> 00:19:27,440
being used and the other triggers don't

538
00:19:27,440 --> 00:19:30,000
work well we have the additional option

539
00:19:30,000 --> 00:19:30,799
to

540
00:19:30,799 --> 00:19:33,200
create signatures um

541
00:19:33,200 --> 00:19:35,919
those shouldn't be family specific by

542
00:19:35,919 --> 00:19:37,840
the way so there's nothing

543
00:19:37,840 --> 00:19:41,039
that identifies the family

544
00:19:41,039 --> 00:19:43,760
as a simple example

545
00:19:43,760 --> 00:19:46,400
many male or families store a set of

546
00:19:46,400 --> 00:19:49,039
urls somewhere in the

547
00:19:49,039 --> 00:19:51,360
in the file in an encrypted form

548
00:19:51,360 --> 00:19:54,559
and those can be perhaps separated

549
00:19:54,559 --> 00:19:56,400
by some file separator

550
00:19:56,400 --> 00:19:59,360
and that's it so if we create a

551
00:19:59,360 --> 00:20:01,600
a regular expression maybe we could

552
00:20:01,600 --> 00:20:03,520
detect that but that doesn't tell us

553
00:20:03,520 --> 00:20:07,039
what kind of malware it is and so we

554
00:20:07,039 --> 00:20:09,520
want to create simple simple rules and

555
00:20:09,520 --> 00:20:12,000
then scan the memory uh we do not want

556
00:20:12,000 --> 00:20:13,919
to scan in continuously

557
00:20:13,919 --> 00:20:15,840
because that's too time consuming so we

558
00:20:15,840 --> 00:20:19,679
only want to scan it on certain events

559
00:20:19,679 --> 00:20:22,320
basically like when the memory is freed

560
00:20:22,320 --> 00:20:24,559
overwritten when the process terminates

561
00:20:24,559 --> 00:20:27,679
and so on and if we have a match we

562
00:20:27,679 --> 00:20:29,919
basically extract the memory if we don't

563
00:20:29,919 --> 00:20:31,360
have a match

564
00:20:31,360 --> 00:20:35,320
then we continue with the execution

565
00:20:35,520 --> 00:20:39,039
now let's talk about some some issues

566
00:20:39,039 --> 00:20:42,000
because the memory dumping still

567
00:20:42,000 --> 00:20:46,240
will produce a lot a lot of data so

568
00:20:46,240 --> 00:20:48,480
a lot of data will obviously slow down

569
00:20:48,480 --> 00:20:50,400
the execution so the execution has to be

570
00:20:50,400 --> 00:20:51,520
paused the

571
00:20:51,520 --> 00:20:54,480
memory has to be copied out of the vm

572
00:20:54,480 --> 00:20:55,440
which

573
00:20:55,440 --> 00:20:56,720
takes always

574
00:20:56,720 --> 00:20:57,760
some time

575
00:20:57,760 --> 00:21:00,640
it also consumes this space and

576
00:21:00,640 --> 00:21:02,640
if you have a post-processing step

577
00:21:02,640 --> 00:21:06,559
this will also be very time consuming

578
00:21:06,559 --> 00:21:09,039
so one idea is to

579
00:21:09,039 --> 00:21:12,000
prioritize the memory dumps basically so

580
00:21:12,000 --> 00:21:14,559
some triggers are more important than

581
00:21:14,559 --> 00:21:16,240
others

582
00:21:16,240 --> 00:21:19,120
for example we always want to prioritize

583
00:21:19,120 --> 00:21:21,440
final dumps we want to prioritize the

584
00:21:21,440 --> 00:21:23,919
first network behavior dumps because

585
00:21:23,919 --> 00:21:24,960
those are

586
00:21:24,960 --> 00:21:26,240
useful

587
00:21:26,240 --> 00:21:27,280
and

588
00:21:27,280 --> 00:21:29,280
we want to de-prioritize for example

589
00:21:29,280 --> 00:21:31,840
content change which i'll talk about

590
00:21:31,840 --> 00:21:34,158
soon

591
00:21:34,799 --> 00:21:36,799
and we also are

592
00:21:36,799 --> 00:21:39,360
usually interested in memory dumps of

593
00:21:39,360 --> 00:21:41,280
the same region

594
00:21:41,280 --> 00:21:44,799
that were taken at a later time so

595
00:21:44,799 --> 00:21:49,440
basically discard the earlier regions

596
00:21:49,440 --> 00:21:51,360
of the same memory

597
00:21:51,360 --> 00:21:53,600
the second issue is

598
00:21:53,600 --> 00:21:55,039
basically some

599
00:21:55,039 --> 00:21:57,039
size thresholds that we need to

600
00:21:57,039 --> 00:21:58,880
establish

601
00:21:58,880 --> 00:22:01,280
so we don't want to dump memory that's

602
00:22:01,280 --> 00:22:02,400
too little

603
00:22:02,400 --> 00:22:04,240
a lot of string manipulation functions

604
00:22:04,240 --> 00:22:05,200
will

605
00:22:05,200 --> 00:22:07,120
allocate some buffers that are a couple

606
00:22:07,120 --> 00:22:09,360
bytes long we are not really interested

607
00:22:09,360 --> 00:22:11,919
in those so we have to set some some

608
00:22:11,919 --> 00:22:15,039
limits we also don't want to dump

609
00:22:15,039 --> 00:22:16,880
memory regions that are hundreds of

610
00:22:16,880 --> 00:22:19,120
bytes big uh that will again slow down

611
00:22:19,120 --> 00:22:20,960
the execution um

612
00:22:20,960 --> 00:22:23,440
and the post processing steps

613
00:22:23,440 --> 00:22:24,400
so

614
00:22:24,400 --> 00:22:26,159
they shouldn't be too small and they

615
00:22:26,159 --> 00:22:28,240
shouldn't be too large basically and

616
00:22:28,240 --> 00:22:30,559
additionally we want to have a global

617
00:22:30,559 --> 00:22:31,760
limit

618
00:22:31,760 --> 00:22:32,559
um

619
00:22:32,559 --> 00:22:35,200
so let's say during an analysis we only

620
00:22:35,200 --> 00:22:36,559
extract

621
00:22:36,559 --> 00:22:39,039
100 megabytes of memory dumps and if we

622
00:22:39,039 --> 00:22:42,159
reach that we don't take any new memory

623
00:22:42,159 --> 00:22:44,880
dumps that's obviously not

624
00:22:44,880 --> 00:22:46,960
not really good so we have to combine

625
00:22:46,960 --> 00:22:48,000
with

626
00:22:48,000 --> 00:22:50,960
the prioritization and basically if a at

627
00:22:50,960 --> 00:22:53,360
certain point in time

628
00:22:53,360 --> 00:22:55,200
we know that a first network behavior

629
00:22:55,200 --> 00:22:57,360
occurred and there will be coming memory

630
00:22:57,360 --> 00:22:59,200
dumps but we filled the quota so we

631
00:22:59,200 --> 00:23:01,360
discard the for example the low priority

632
00:23:01,360 --> 00:23:04,080
memory dumps

633
00:23:04,080 --> 00:23:06,640
um now let's uh

634
00:23:06,640 --> 00:23:08,480
look at some some

635
00:23:08,480 --> 00:23:09,520
families

636
00:23:09,520 --> 00:23:12,400
some real world examples i guess uh

637
00:23:12,400 --> 00:23:14,159
so basically those are

638
00:23:14,159 --> 00:23:17,520
um the collected agent tesla payloads so

639
00:23:17,520 --> 00:23:19,440
our internal collection

640
00:23:19,440 --> 00:23:22,799
and the chart um shows the division

641
00:23:22,799 --> 00:23:24,080
between the

642
00:23:24,080 --> 00:23:25,760
memory triggers

643
00:23:25,760 --> 00:23:26,640
so

644
00:23:26,640 --> 00:23:29,039
at the the memory dump

645
00:23:29,039 --> 00:23:32,880
basically can be correlated to a memory

646
00:23:32,880 --> 00:23:36,240
trigger like the first network behavior

647
00:23:36,240 --> 00:23:37,280
and

648
00:23:37,280 --> 00:23:39,679
at this point we actually have the the

649
00:23:39,679 --> 00:23:41,440
payload um

650
00:23:41,440 --> 00:23:44,960
so as we see 46 percent of the

651
00:23:44,960 --> 00:23:47,039
of all the agent tesla payloads can be

652
00:23:47,039 --> 00:23:48,960
detected just with the first network

653
00:23:48,960 --> 00:23:50,799
behavior

654
00:23:50,799 --> 00:23:53,760
if we add the content change

655
00:23:53,760 --> 00:23:56,400
trigger we are over 70 percent shortly

656
00:23:56,400 --> 00:23:58,400
about the content change so

657
00:23:58,400 --> 00:24:01,120
if we monitor a memory region

658
00:24:01,120 --> 00:24:03,200
and there is a change in the region we

659
00:24:03,200 --> 00:24:05,039
want to perform a dump

660
00:24:05,039 --> 00:24:08,640
this has to be um

661
00:24:08,640 --> 00:24:10,400
with the set of rules that we talked

662
00:24:10,400 --> 00:24:12,159
about previously

663
00:24:12,159 --> 00:24:14,240
so used together because otherwise we'll

664
00:24:14,240 --> 00:24:16,320
produce too many memory dumps

665
00:24:16,320 --> 00:24:19,679
we also want to probably specify some

666
00:24:19,679 --> 00:24:21,440
some size and minimal size of the

667
00:24:21,440 --> 00:24:24,640
content changed um instead of just

668
00:24:24,640 --> 00:24:26,480
having like a byte change and then a

669
00:24:26,480 --> 00:24:28,880
memory dump that's not very useful

670
00:24:28,880 --> 00:24:30,720
um

671
00:24:30,720 --> 00:24:33,440
the next one is for example agent emoted

672
00:24:33,440 --> 00:24:34,640
sorry

673
00:24:34,640 --> 00:24:37,840
so a big one here and um just the first

674
00:24:37,840 --> 00:24:40,000
network behavior um

675
00:24:40,000 --> 00:24:41,919
covers 84

676
00:24:41,919 --> 00:24:44,559
of um of all the samples so the

677
00:24:44,559 --> 00:24:46,480
the trigger produces a memory dump that

678
00:24:46,480 --> 00:24:49,760
lets us identify um this

679
00:24:49,760 --> 00:24:52,400
region as or this file as a mod

680
00:24:52,400 --> 00:24:53,919
basically

681
00:24:53,919 --> 00:24:56,000
and with the addition of first execution

682
00:24:56,000 --> 00:25:00,240
we cover 99 of of all the samples so

683
00:25:00,240 --> 00:25:02,240
there's usually a network connection for

684
00:25:02,240 --> 00:25:05,440
emoted if we get it there is already the

685
00:25:05,440 --> 00:25:07,840
unpacked payload the other is covered

686
00:25:07,840 --> 00:25:09,840
with first execution so first execution

687
00:25:09,840 --> 00:25:12,159
we have a memory region that maybe was

688
00:25:12,159 --> 00:25:14,080
only readable writable and now it

689
00:25:14,080 --> 00:25:16,960
changed to executable and the actual

690
00:25:16,960 --> 00:25:18,880
execution flow was redirected to that

691
00:25:18,880 --> 00:25:23,679
region then we performed the memory done

692
00:25:24,320 --> 00:25:26,960
here we see luckybot and

693
00:25:26,960 --> 00:25:29,360
again the first network behavior tops

694
00:25:29,360 --> 00:25:31,760
the chart with 76

695
00:25:31,760 --> 00:25:34,080
and together with the first execution

696
00:25:34,080 --> 00:25:36,640
with just two triggers we are at over 90

697
00:25:36,640 --> 00:25:38,000
percent

698
00:25:38,000 --> 00:25:38,960
um

699
00:25:38,960 --> 00:25:41,760
we also have nano core

700
00:25:41,760 --> 00:25:43,760
also very popular

701
00:25:43,760 --> 00:25:44,960
family

702
00:25:44,960 --> 00:25:46,720
widely used

703
00:25:46,720 --> 00:25:47,840
and

704
00:25:47,840 --> 00:25:50,400
here again the importance of the first

705
00:25:50,400 --> 00:25:52,559
network behavior trigger with some

706
00:25:52,559 --> 00:25:54,000
content change

707
00:25:54,000 --> 00:25:56,880
applied the rules we cover again

708
00:25:56,880 --> 00:26:00,000
over 90 percent of the

709
00:26:00,000 --> 00:26:01,520
of the family

710
00:26:01,520 --> 00:26:03,200
so um

711
00:26:03,200 --> 00:26:05,279
yeah we are basically at the end of our

712
00:26:05,279 --> 00:26:07,520
presentation

713
00:26:07,520 --> 00:26:11,840
we see that some of the triggers can

714
00:26:12,159 --> 00:26:14,240
cover the majority of

715
00:26:14,240 --> 00:26:16,480
families so especially first network

716
00:26:16,480 --> 00:26:19,360
behavior that's also my favorite one

717
00:26:19,360 --> 00:26:22,080
it's very useful and if we have

718
00:26:22,080 --> 00:26:24,320
just a few triggers we hopefully won't

719
00:26:24,320 --> 00:26:27,360
produce too many memory dumps in total

720
00:26:27,360 --> 00:26:29,360
and can cover um

721
00:26:29,360 --> 00:26:33,600
many families malware families at once

722
00:26:33,600 --> 00:26:36,840
fewer triggers fewer maintenance

723
00:26:36,840 --> 00:26:41,360
so i hope that that works and um yeah

724
00:26:41,360 --> 00:26:44,000
hope that you uh got something out of it

725
00:26:44,000 --> 00:26:47,760
and uh yeah thank you for listening

726
00:26:47,760 --> 00:26:51,200
and uh here i would also like to um give

727
00:26:51,200 --> 00:26:53,440
special thanks to alexanderbetz and

728
00:26:53,440 --> 00:26:56,000
thomas watson which are not here but

729
00:26:56,000 --> 00:26:58,240
were also part of this

730
00:26:58,240 --> 00:27:00,000
this topic and

731
00:27:00,000 --> 00:27:02,080
were greatly involved with us

732
00:27:02,080 --> 00:27:04,320
yeah if there are any questions then i

733
00:27:04,320 --> 00:27:06,960
guess now is the time if not

734
00:27:06,960 --> 00:27:09,520
you can find us probably in the forum

735
00:27:09,520 --> 00:27:12,480
later preferably after 5pm when this

736
00:27:12,480 --> 00:27:15,279
when we win this httf

737
00:27:15,279 --> 00:27:17,530
and yeah thank you

738
00:27:17,530 --> 00:27:25,109
[Applause]

739
00:27:25,600 --> 00:27:26,880
thank you guys

740
00:27:26,880 --> 00:27:27,840
uh

741
00:27:27,840 --> 00:27:29,600
we have time for some questions if there

742
00:27:29,600 --> 00:27:31,600
are any

743
00:27:31,600 --> 00:27:35,279
um and if not uh i know that you guys

744
00:27:35,279 --> 00:27:37,840
have sacrificed uh important ctf time to

745
00:27:37,840 --> 00:27:40,480
be with us uh here

746
00:27:40,480 --> 00:27:42,640
so we'll let you get uh

747
00:27:42,640 --> 00:27:44,159
get back to that

748
00:27:44,159 --> 00:27:47,039
uh thank you again guys for uh

749
00:27:47,039 --> 00:27:49,440
for joining us and sharing knowledge

750
00:27:49,440 --> 00:27:53,200
thank you thank you nice to be here bye

751
00:27:55,840 --> 00:27:56,559
so

752
00:27:56,559 --> 00:27:58,720
next presentation will be at quarter

753
00:27:58,720 --> 00:28:02,559
past 10 please use the app to rate the

754
00:28:02,559 --> 00:28:07,240
different sessions here thank you

