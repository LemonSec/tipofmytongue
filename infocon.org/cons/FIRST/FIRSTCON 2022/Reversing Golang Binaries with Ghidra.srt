1
00:00:03,000 --> 00:00:05,870
foreign

2
00:00:05,870 --> 00:00:08,929
[Music]

3
00:00:09,240 --> 00:00:11,340
good morning

4
00:00:11,340 --> 00:00:14,580
I'm Leonel ferret and I will be your

5
00:00:14,580 --> 00:00:17,240
session chair for this morning

6
00:00:17,240 --> 00:00:22,220
author speaker this morning is

7
00:00:22,220 --> 00:00:27,680
and she is a senior cyber threat

8
00:00:27,680 --> 00:00:32,279
investigator for Cujo Ai and she will

9
00:00:32,279 --> 00:00:34,340
talk about

10
00:00:34,340 --> 00:00:36,719
interesting topic

11
00:00:36,719 --> 00:00:40,739
of reverse engineering golang code using

12
00:00:40,739 --> 00:00:43,219
gitra so

13
00:00:43,219 --> 00:00:45,780
you will have

14
00:00:45,780 --> 00:00:48,120
five minutes for questions using the

15
00:00:48,120 --> 00:00:50,460
mics please remember to turn your phones

16
00:00:50,460 --> 00:00:53,160
back on when you leave the room

17
00:00:53,160 --> 00:00:57,739
um and I will leave the floor to dock up

18
00:01:00,960 --> 00:01:03,600
hi good morning thank you very much so

19
00:01:03,600 --> 00:01:05,659
my name is

20
00:01:05,659 --> 00:01:09,240
and I will talk about how to reverse

21
00:01:09,240 --> 00:01:11,820
golang binaries with gitra at least I

22
00:01:11,820 --> 00:01:14,280
will just give a short interact

23
00:01:14,280 --> 00:01:16,320
introduction a sneak peek into the word

24
00:01:16,320 --> 00:01:19,080
of rivers and going binaries and as I'm

25
00:01:19,080 --> 00:01:21,000
wearing right in the Next Room there are

26
00:01:21,000 --> 00:01:23,580
like a whole day training about it so if

27
00:01:23,580 --> 00:01:25,740
you feel like it was something

28
00:01:25,740 --> 00:01:27,479
interesting maybe you can still join I

29
00:01:27,479 --> 00:01:30,479
don't know I will definitely look into

30
00:01:30,479 --> 00:01:33,780
that room so just a few words about

31
00:01:33,780 --> 00:01:37,880
myself I'm working at the Cujo Ai and

32
00:01:37,880 --> 00:01:40,560
previously I was studying mainly

33
00:01:40,560 --> 00:01:43,680
mathematics and cryptography and by an

34
00:01:43,680 --> 00:01:46,860
accident during my internship I started

35
00:01:46,860 --> 00:01:49,020
to learn about reverse engineering and

36
00:01:49,020 --> 00:01:51,119
mother analysis so I was starting

37
00:01:51,119 --> 00:01:53,820
basically with dissecting ransomware and

38
00:01:53,820 --> 00:01:55,619
understanding the cryptography within

39
00:01:55,619 --> 00:01:58,860
ransomware but it was super interesting

40
00:01:58,860 --> 00:02:01,560
it's reverse engineering it's like doing

41
00:02:01,560 --> 00:02:03,600
some kind of

42
00:02:03,600 --> 00:02:05,820
fun investigation where you have to

43
00:02:05,820 --> 00:02:09,000
solve challenges and I really enjoyed it

44
00:02:09,000 --> 00:02:11,220
so I started and learned reverse

45
00:02:11,220 --> 00:02:12,260
engineering

46
00:02:12,260 --> 00:02:16,379
and so I'm I don't really play CTF but

47
00:02:16,379 --> 00:02:18,720
but I think this is the right place to

48
00:02:18,720 --> 00:02:21,180
brag about it that our team in the last

49
00:02:21,180 --> 00:02:24,540
two years we two years ago we won it and

50
00:02:24,540 --> 00:02:27,420
last year we were in the second place uh

51
00:02:27,420 --> 00:02:30,120
actually these were my first CTF games

52
00:02:30,120 --> 00:02:32,879
and it was super fun so I don't know if

53
00:02:32,879 --> 00:02:35,459
you still can join this year that I I

54
00:02:35,459 --> 00:02:38,340
highly recommend this year I'm not

55
00:02:38,340 --> 00:02:40,739
playing but my team will so I hope that

56
00:02:40,739 --> 00:02:45,180
they will win this time as well and just

57
00:02:45,180 --> 00:02:49,560
briefly what I will talk about today uh

58
00:02:49,560 --> 00:02:51,480
so and why we started to do this

59
00:02:51,480 --> 00:02:53,519
research in the first place so basically

60
00:02:53,519 --> 00:02:58,080
in our company our team is doing mostly

61
00:02:58,080 --> 00:03:00,599
iot model research not just iot Linux

62
00:03:00,599 --> 00:03:02,000
related mother

63
00:03:02,000 --> 00:03:04,800
research and we have seen more and more

64
00:03:04,800 --> 00:03:07,379
more mother written in gold and we

65
00:03:07,379 --> 00:03:09,959
realized that we need some tools to be

66
00:03:09,959 --> 00:03:12,000
able to reverse engineer this by

67
00:03:12,000 --> 00:03:15,720
binaries in easier so there were a lot

68
00:03:15,720 --> 00:03:17,760
of challenges and I will show a couple

69
00:03:17,760 --> 00:03:20,720
of these during this presentation like

70
00:03:20,720 --> 00:03:23,760
reverse go binaries are huge so reverse

71
00:03:23,760 --> 00:03:25,860
engineering them is more time consuming

72
00:03:25,860 --> 00:03:26,819
it's

73
00:03:26,819 --> 00:03:29,340
not the these binaries are very

74
00:03:29,340 --> 00:03:31,019
different from the binaries that we were

75
00:03:31,019 --> 00:03:33,799
used to written in C or other languages

76
00:03:33,799 --> 00:03:38,340
so we started to think about how can we

77
00:03:38,340 --> 00:03:40,319
make our lives easier and we basically

78
00:03:40,319 --> 00:03:44,099
we mainly use gidra for static model

79
00:03:44,099 --> 00:03:47,640
analysis it's an open source tool it's

80
00:03:47,640 --> 00:03:50,959
uh and it had very few

81
00:03:50,959 --> 00:03:53,459
plugins or scripts when we started to

82
00:03:53,459 --> 00:03:54,959
work with this compared to for example

83
00:03:54,959 --> 00:03:57,000
Ida which already has a huge history

84
00:03:57,000 --> 00:03:59,220
with a lot of plug-in scripts available

85
00:03:59,220 --> 00:04:03,000
already and this is how this whole thing

86
00:04:03,000 --> 00:04:04,799
started we realized that we would like

87
00:04:04,799 --> 00:04:05,900
to

88
00:04:05,900 --> 00:04:09,060
analyze better easier goal line binaries

89
00:04:09,060 --> 00:04:11,159
and we have to create our own tools for

90
00:04:11,159 --> 00:04:14,939
this so I I will talk a little bit about

91
00:04:14,939 --> 00:04:17,339
what challenges we face and what

92
00:04:17,339 --> 00:04:20,759
Solutions we have found and also we

93
00:04:20,759 --> 00:04:22,860
created our own scripts which are all

94
00:04:22,860 --> 00:04:24,360
available

95
00:04:24,360 --> 00:04:27,000
on GitHub so if someone is interested or

96
00:04:27,000 --> 00:04:29,400
someone needs those then feel free to

97
00:04:29,400 --> 00:04:32,160
use it or even improve it and on every

98
00:04:32,160 --> 00:04:34,620
slide where I will talk about the

99
00:04:34,620 --> 00:04:38,940
examples then in the and I will share

100
00:04:38,940 --> 00:04:40,620
also the hashes of the file so if

101
00:04:40,620 --> 00:04:42,060
someone wants to play with these and

102
00:04:42,060 --> 00:04:44,699
look at the examples line by line then

103
00:04:44,699 --> 00:04:47,360
you can do that as well

104
00:04:47,360 --> 00:04:51,300
so just very briefly about golang it's

105
00:04:51,300 --> 00:04:52,800
an open source programming language

106
00:04:52,800 --> 00:04:55,080
designed by Google the current version

107
00:04:55,080 --> 00:04:59,340
is go 1.18 it's very important changing

108
00:04:59,340 --> 00:05:02,280
the changes over versions are just crazy

109
00:05:02,280 --> 00:05:03,960
and I will talk about it how it makes

110
00:05:03,960 --> 00:05:08,039
our lives uh difficult but at least to

111
00:05:08,039 --> 00:05:11,580
be still have some things to do which is

112
00:05:11,580 --> 00:05:15,060
also interesting so that's fine and go

113
00:05:15,060 --> 00:05:18,000
is becoming more and more popular not

114
00:05:18,000 --> 00:05:20,720
just among developers but also among

115
00:05:20,720 --> 00:05:24,479
mother writers so that's why we really

116
00:05:24,479 --> 00:05:28,139
have to deal with it and understand a

117
00:05:28,139 --> 00:05:29,759
little bit better

118
00:05:29,759 --> 00:05:34,080
so in the last couple of years there we

119
00:05:34,080 --> 00:05:38,100
have seen new and new uh go malware

120
00:05:38,100 --> 00:05:42,419
families emerging like every month we

121
00:05:42,419 --> 00:05:46,320
can almost see a new new one and they

122
00:05:46,320 --> 00:05:50,100
they are attacking also windows and

123
00:05:50,100 --> 00:05:52,020
Linux this is one of the big advantage

124
00:05:52,020 --> 00:05:54,539
of go that you can just discount the

125
00:05:54,539 --> 00:05:57,120
cross compiling functionality so you can

126
00:05:57,120 --> 00:05:58,919
just write one code base and then you

127
00:05:58,919 --> 00:06:00,960
can compile it for different

128
00:06:00,960 --> 00:06:03,600
architectures you can simply get a

129
00:06:03,600 --> 00:06:06,360
binary which can attack windows or a

130
00:06:06,360 --> 00:06:08,699
binder which can attack Linux machine or

131
00:06:08,699 --> 00:06:12,060
Mac or whatever and this is why it is

132
00:06:12,060 --> 00:06:13,800
becoming more and more popular you don't

133
00:06:13,800 --> 00:06:17,520
have to write a different borders for

134
00:06:17,520 --> 00:06:20,460
different architectures and we have seen

135
00:06:20,460 --> 00:06:23,039
a lot of different uh malware families

136
00:06:23,039 --> 00:06:25,199
attacking for example ransomware

137
00:06:25,199 --> 00:06:28,440
attacking Nest devices or botnets

138
00:06:28,440 --> 00:06:32,220
written from scratch p2b button botnet

139
00:06:32,220 --> 00:06:36,600
and and really almost everything so for

140
00:06:36,600 --> 00:06:39,479
example the latest one was the csrv uh

141
00:06:39,479 --> 00:06:43,800
which is a crypto Miner using various

142
00:06:43,800 --> 00:06:47,280
exploits to attack different devices

143
00:06:47,280 --> 00:06:50,220
Microsoft just released recently a

144
00:06:50,220 --> 00:06:54,800
report about a new version of it so

145
00:06:54,800 --> 00:06:57,960
definitely there is a need to look

146
00:06:57,960 --> 00:07:01,080
deeper into this kind of malware

147
00:07:01,080 --> 00:07:04,080
families so let's turn back a little bit

148
00:07:04,080 --> 00:07:06,900
to go and what some of the interesting

149
00:07:06,900 --> 00:07:10,199
features and of course the first one is

150
00:07:10,199 --> 00:07:13,319
the static linking so go binaries are

151
00:07:13,319 --> 00:07:15,840
statically linked by default which means

152
00:07:15,840 --> 00:07:19,020
that everything that is needed to

153
00:07:19,020 --> 00:07:22,500
necessary to run for this executable

154
00:07:22,500 --> 00:07:24,720
image it's included within the binary

155
00:07:24,720 --> 00:07:27,720
which has a lot of different results

156
00:07:27,720 --> 00:07:30,060
first of all there won't be any

157
00:07:30,060 --> 00:07:32,759
dependency issues but the size became

158
00:07:32,759 --> 00:07:36,300
become enormous so if we look at this

159
00:07:36,300 --> 00:07:39,419
simple hello bird examples then you can

160
00:07:39,419 --> 00:07:41,940
see that the first one which was written

161
00:07:41,940 --> 00:07:44,520
in C and then compiled the size is about

162
00:07:44,520 --> 00:07:47,340
16 kilobytes while the same in go is

163
00:07:47,340 --> 00:07:50,220
like two megabytes like it's it's huge

164
00:07:50,220 --> 00:07:53,099
and if let's look at it how it looks in

165
00:07:53,099 --> 00:07:55,319
ghidra when you look at the function

166
00:07:55,319 --> 00:07:57,660
view where you analyze the binary and

167
00:07:57,660 --> 00:07:59,220
you would like to understand what kind

168
00:07:59,220 --> 00:08:03,060
of functions are within the binary in in

169
00:08:03,060 --> 00:08:05,400
C there are 19 functions versus single

170
00:08:05,400 --> 00:08:08,000
we see

171
00:08:08,000 --> 00:08:10,800
1790 functions so that's a huge

172
00:08:10,800 --> 00:08:12,780
difference and it's only a simple hello

173
00:08:12,780 --> 00:08:16,740
word and we also have to consider the

174
00:08:16,740 --> 00:08:19,379
strip binaries which means that the

175
00:08:19,379 --> 00:08:21,680
debugging symbols are discarded

176
00:08:21,680 --> 00:08:24,720
usually there are the one goal is to

177
00:08:24,720 --> 00:08:26,940
reduce the size of the binary the other

178
00:08:26,940 --> 00:08:29,940
one is to get rid of the names of

179
00:08:29,940 --> 00:08:32,279
routines and variables make Liberty

180
00:08:32,279 --> 00:08:34,740
engineering more more difficult and

181
00:08:34,740 --> 00:08:37,080
mother files are generally usually

182
00:08:37,080 --> 00:08:40,200
stripped and if we do the stripping with

183
00:08:40,200 --> 00:08:43,799
the previous hello bird examples you can

184
00:08:43,799 --> 00:08:45,720
see that the size was reused but it's

185
00:08:45,720 --> 00:08:49,260
still 1.3 megabytes so it's a still a

186
00:08:49,260 --> 00:08:54,300
huge binary and what is verse we still

187
00:08:54,300 --> 00:08:56,100
have a lot of functions but now we don't

188
00:08:56,100 --> 00:08:58,500
have the function names so previously at

189
00:08:58,500 --> 00:09:00,720
least we could okay no one really wants

190
00:09:00,720 --> 00:09:03,480
to Loop through 1800 functions and find

191
00:09:03,480 --> 00:09:05,459
interesting ones but maybe with Clues

192
00:09:05,459 --> 00:09:07,500
like me in something you can find what

193
00:09:07,500 --> 00:09:09,600
is interesting for you but here you

194
00:09:09,600 --> 00:09:11,580
don't see any meaningful function names

195
00:09:11,580 --> 00:09:14,519
so it really makes reverse engineering

196
00:09:14,519 --> 00:09:15,920
more difficult

197
00:09:15,920 --> 00:09:18,620
so how can we

198
00:09:18,620 --> 00:09:23,279
we did some digging into the binaries

199
00:09:23,279 --> 00:09:25,200
itself can we do something to recover

200
00:09:25,200 --> 00:09:29,459
the function names and uh what is a very

201
00:09:29,459 --> 00:09:32,760
very interesting with the with goal so

202
00:09:32,760 --> 00:09:34,740
in the first two image what you can see

203
00:09:34,740 --> 00:09:39,779
is the C example and when we simply look

204
00:09:39,779 --> 00:09:41,700
at the hello world example where we look

205
00:09:41,700 --> 00:09:44,640
for the main function in C after

206
00:09:44,640 --> 00:09:47,399
stripping this is on the right side the

207
00:09:47,399 --> 00:09:49,380
main string is not visible within the

208
00:09:49,380 --> 00:09:52,740
binary but with go if we search for the

209
00:09:52,740 --> 00:09:54,839
main dot main string just this string

210
00:09:54,839 --> 00:09:57,300
even after stripping this string is

211
00:09:57,300 --> 00:09:59,940
within within the binary so it's it's

212
00:09:59,940 --> 00:10:02,820
somehow promising that maybe even when

213
00:10:02,820 --> 00:10:04,920
the binary was stripped we can still

214
00:10:04,920 --> 00:10:07,380
find the function names and then it can

215
00:10:07,380 --> 00:10:10,560
help us to do the reverse engineering

216
00:10:10,560 --> 00:10:14,279
and uh what we did we looked into the

217
00:10:14,279 --> 00:10:17,279
binary with gidra and we found domain

218
00:10:17,279 --> 00:10:18,779
dot Main

219
00:10:18,779 --> 00:10:22,380
a string and in a in case of this

220
00:10:22,380 --> 00:10:25,260
example the hello bird example we found

221
00:10:25,260 --> 00:10:27,180
that it was in the memory in the

222
00:10:27,180 --> 00:10:29,480
structure in a

223
00:10:29,480 --> 00:10:34,440
place which called uh Go pclm tab so

224
00:10:34,440 --> 00:10:37,620
uh basically in this section we could

225
00:10:37,620 --> 00:10:39,300
find and go pixel and top section we

226
00:10:39,300 --> 00:10:42,240
could find the main dot main string so

227
00:10:42,240 --> 00:10:45,779
the idea was to understand what is going

228
00:10:45,779 --> 00:10:49,200
on in this section and there is luckily

229
00:10:49,200 --> 00:10:53,180
a very nice documentation of the

230
00:10:53,180 --> 00:10:56,640
PCL and tab structure which is available

231
00:10:56,640 --> 00:10:59,660
in go from Go 1.2

232
00:10:59,660 --> 00:11:03,480
and there and as you can see here we can

233
00:11:03,480 --> 00:11:06,839
find the function addresses followed by

234
00:11:06,839 --> 00:11:10,079
a function metadata pointers

235
00:11:10,079 --> 00:11:12,660
and the with the deeper look we found

236
00:11:12,660 --> 00:11:14,760
that this functional metadata contains

237
00:11:14,760 --> 00:11:17,399
the function name of set itself

238
00:11:17,399 --> 00:11:20,100
so in this structure actually it's

239
00:11:20,100 --> 00:11:22,920
stored the function addresses stored and

240
00:11:22,920 --> 00:11:25,500
also the names of the functions are

241
00:11:25,500 --> 00:11:30,240
stalled stored so uh so it's possible to

242
00:11:30,240 --> 00:11:33,360
recover this and just a very very quick

243
00:11:33,360 --> 00:11:35,820
side note that this structure for

244
00:11:35,820 --> 00:11:40,399
example changed in will go 1.16 and go

245
00:11:40,399 --> 00:11:43,500
1.18 so

246
00:11:43,500 --> 00:11:46,740
so we had to make some adjustments and

247
00:11:46,740 --> 00:11:48,360
we really have to keep looking for the

248
00:11:48,360 --> 00:11:50,579
version changes of go because then it

249
00:11:50,579 --> 00:11:52,079
can happen that something do you find

250
00:11:52,079 --> 00:11:53,940
previously somewhere and then you have

251
00:11:53,940 --> 00:11:56,220
to just switch and look for somewhere

252
00:11:56,220 --> 00:11:57,560
else

253
00:11:57,560 --> 00:12:01,139
and another notice that in the in

254
00:12:01,139 --> 00:12:04,579
Windows binaries there is no such uh

255
00:12:04,579 --> 00:12:07,440
Go pcln tab

256
00:12:07,440 --> 00:12:09,959
section but the structure is still there

257
00:12:09,959 --> 00:12:12,180
so the only thing is that you have to

258
00:12:12,180 --> 00:12:15,260
look for exactly those

259
00:12:15,260 --> 00:12:19,440
different uh like in the here if I go

260
00:12:19,440 --> 00:12:21,540
back to the beginning the magic value

261
00:12:21,540 --> 00:12:24,779
and then the instruction size pointer

262
00:12:24,779 --> 00:12:27,120
size so if you search for these bytes

263
00:12:27,120 --> 00:12:30,000
then you can locate this uh this

264
00:12:30,000 --> 00:12:31,760
structure and easily

265
00:12:31,760 --> 00:12:34,740
recover function names so if someone is

266
00:12:34,740 --> 00:12:36,720
interested and he would like to go step

267
00:12:36,720 --> 00:12:40,320
by step how it works then here is a like

268
00:12:40,320 --> 00:12:43,800
really a step-by-step example with one

269
00:12:43,800 --> 00:12:46,500
binary with the hello world binary which

270
00:12:46,500 --> 00:12:48,180
is available on our GitHub so if you

271
00:12:48,180 --> 00:12:49,920
want to play with it you can just check

272
00:12:49,920 --> 00:12:52,139
how it works you find this PCL and tab

273
00:12:52,139 --> 00:12:54,300
structure you find the function

274
00:12:54,300 --> 00:12:57,600
addresses and then you can find the

275
00:12:57,600 --> 00:12:59,180
function name

276
00:12:59,180 --> 00:13:02,040
addresses as well and then this way you

277
00:13:02,040 --> 00:13:04,200
can basically even in strip the binaries

278
00:13:04,200 --> 00:13:06,420
you can recover the function names so

279
00:13:06,420 --> 00:13:09,200
for example in case of

280
00:13:09,200 --> 00:13:12,000
and this hello world example after we

281
00:13:12,000 --> 00:13:14,519
run this R script it will be able to

282
00:13:14,519 --> 00:13:16,680
recover the function names and we can

283
00:13:16,680 --> 00:13:18,839
find the main function even in a strip

284
00:13:18,839 --> 00:13:20,339
to go binary

285
00:13:20,339 --> 00:13:24,000
and just to see a real word example this

286
00:13:24,000 --> 00:13:25,279
is a

287
00:13:25,279 --> 00:13:29,700
ransomware written in go here on the

288
00:13:29,700 --> 00:13:31,800
left side there are no function names

289
00:13:31,800 --> 00:13:33,560
and then on the right side after

290
00:13:33,560 --> 00:13:35,880
executing the script you can find the

291
00:13:35,880 --> 00:13:37,620
function names and as you can see here

292
00:13:37,620 --> 00:13:40,079
it's for example it's very very useful

293
00:13:40,079 --> 00:13:42,000
like just looking at the function names

294
00:13:42,000 --> 00:13:43,860
you will understand that you are dealing

295
00:13:43,860 --> 00:13:46,260
with a ransomware so there is like main

296
00:13:46,260 --> 00:13:49,260
dot encrypt main.write message main dot

297
00:13:49,260 --> 00:13:51,420
make secret this kind of function so

298
00:13:51,420 --> 00:13:53,459
it's much easier to reverse engineer a

299
00:13:53,459 --> 00:13:54,899
binary when you actually see this

300
00:13:54,899 --> 00:13:58,199
function is when compared to the example

301
00:13:58,199 --> 00:13:59,519
where you don't

302
00:13:59,519 --> 00:14:02,120
uh and one

303
00:14:02,120 --> 00:14:06,240
issue with the functioning recovery like

304
00:14:06,240 --> 00:14:09,240
we had a lot of challenges of course but

305
00:14:09,240 --> 00:14:12,360
uh during our script when we wanted to

306
00:14:12,360 --> 00:14:15,800
grab the function names uh in some some

307
00:14:15,800 --> 00:14:18,480
sometimes these function names tricks

308
00:14:18,480 --> 00:14:21,899
streams are not recognized by guidra so

309
00:14:21,899 --> 00:14:23,220
there is a string

310
00:14:23,220 --> 00:14:26,399
but like this log dot new but there is

311
00:14:26,399 --> 00:14:31,139
no strong string created which uh which

312
00:14:31,139 --> 00:14:34,220
will basically lead us to the second

313
00:14:34,220 --> 00:14:37,800
interesting thing about guidra

314
00:14:37,800 --> 00:14:42,420
uh is how how go sorry interesting thing

315
00:14:42,420 --> 00:14:46,560
about go is how go handles strings

316
00:14:46,560 --> 00:14:49,740
so uh for example let's turn back to the

317
00:14:49,740 --> 00:14:53,100
hello bird binaries on the left side the

318
00:14:53,100 --> 00:14:55,079
binary written in C on the right side

319
00:14:55,079 --> 00:14:57,720
the binary written in goal and if we

320
00:14:57,720 --> 00:14:59,820
check this the defined strings window

321
00:14:59,820 --> 00:15:01,940
these are the strings that givera can

322
00:15:01,940 --> 00:15:04,800
recognize within the binary

323
00:15:04,800 --> 00:15:07,380
on the left side you see that there are

324
00:15:07,380 --> 00:15:10,320
like 70 strings found by the draw in the

325
00:15:10,320 --> 00:15:12,600
C version on the right side there are

326
00:15:12,600 --> 00:15:16,560
more than 6 000 strings found by gide

327
00:15:16,560 --> 00:15:18,899
rabbit in the gold binary so it's again

328
00:15:18,899 --> 00:15:22,019
it's an issue that you how will you find

329
00:15:22,019 --> 00:15:24,120
these interesting ones you want to like

330
00:15:24,120 --> 00:15:26,699
basically just scroll through 6000 and

331
00:15:26,699 --> 00:15:29,279
try to find something interesting but

332
00:15:29,279 --> 00:15:31,380
what is even worse we are looking for

333
00:15:31,380 --> 00:15:34,380
hello bird here and this is there in the

334
00:15:34,380 --> 00:15:37,440
C binary but in go there are more than 6

335
00:15:37,440 --> 00:15:39,899
000 strings and we still cannot find the

336
00:15:39,899 --> 00:15:41,940
one that we know it should be there the

337
00:15:41,940 --> 00:15:43,740
hello world because this is what we were

338
00:15:43,740 --> 00:15:45,839
dealing with and all the other strings

339
00:15:45,839 --> 00:15:47,639
are not interesting only this hello bird

340
00:15:47,639 --> 00:15:49,800
and it's not there we have 6 000 strings

341
00:15:49,800 --> 00:15:55,019
and no hello word so when you just look

342
00:15:55,019 --> 00:15:58,019
at this and use the strings utility and

343
00:15:58,019 --> 00:16:01,800
just grab for hello what we see is in C

344
00:16:01,800 --> 00:16:04,079
we simply get in the nice hello word

345
00:16:04,079 --> 00:16:07,680
string while in Google version there is

346
00:16:07,680 --> 00:16:10,860
like a huge huge huge string blob in

347
00:16:10,860 --> 00:16:12,600
somewhere in the middle there is hello

348
00:16:12,600 --> 00:16:14,519
world so it's actually within the binary

349
00:16:14,519 --> 00:16:16,680
but it's pretty ugly

350
00:16:16,680 --> 00:16:18,199
and

351
00:16:18,199 --> 00:16:22,440
the reason for this is how guidra handle

352
00:16:22,440 --> 00:16:25,860
how gold handles uh strings or defines

353
00:16:25,860 --> 00:16:27,660
strings what are the strings within go

354
00:16:27,660 --> 00:16:30,540
in in C we know these are sequence of

355
00:16:30,540 --> 00:16:32,040
characters terminated with another

356
00:16:32,040 --> 00:16:34,620
character that's clear that's okay in

357
00:16:34,620 --> 00:16:36,600
Google these are

358
00:16:36,600 --> 00:16:39,660
sequence of bytes with fixed length so

359
00:16:39,660 --> 00:16:43,139
we have uh it's basically a string

360
00:16:43,139 --> 00:16:45,300
structure where we have a pointer to the

361
00:16:45,300 --> 00:16:47,220
address which to tell us where to look

362
00:16:47,220 --> 00:16:48,959
for the string and then there is an

363
00:16:48,959 --> 00:16:51,300
integer which which tells us how long

364
00:16:51,300 --> 00:16:54,540
this string string is supposed to be and

365
00:16:54,540 --> 00:16:57,000
then within the binary these strings are

366
00:16:57,000 --> 00:17:00,000
many times concatenated together into a

367
00:17:00,000 --> 00:17:01,800
large string blob there is no new

368
00:17:01,800 --> 00:17:04,559
termination and no new character between

369
00:17:04,559 --> 00:17:06,959
the different strings so gidra either

370
00:17:06,959 --> 00:17:10,699
cannot recognize it or they already will

371
00:17:10,699 --> 00:17:14,520
see as a huge huge big string I will

372
00:17:14,520 --> 00:17:18,539
show an example of that later so our

373
00:17:18,539 --> 00:17:21,119
idea was to somehow find help givera to

374
00:17:21,119 --> 00:17:23,520
find these string structures but there

375
00:17:23,520 --> 00:17:25,380
are many different ways how they can be

376
00:17:25,380 --> 00:17:27,740
created this this can be allocated

377
00:17:27,740 --> 00:17:30,780
statically or dynamically and this is

378
00:17:30,780 --> 00:17:33,660
very different per architecture and even

379
00:17:33,660 --> 00:17:36,120
again as Google versions are changing

380
00:17:36,120 --> 00:17:40,020
their can be changes so I will show a

381
00:17:40,020 --> 00:17:42,419
few examples and the first one is the

382
00:17:42,419 --> 00:17:44,640
dynamically allocated string structure

383
00:17:44,640 --> 00:17:47,460
so it basically creates these string

384
00:17:47,460 --> 00:17:51,179
structures runtime and there are several

385
00:17:51,179 --> 00:17:53,000
different scenarios

386
00:17:53,000 --> 00:17:55,320
in this case for example it's different

387
00:17:55,320 --> 00:17:57,960
per architecture and if we look at the

388
00:17:57,960 --> 00:17:59,880
hello bird examples again

389
00:17:59,880 --> 00:18:02,940
we can see that in this first example

390
00:18:02,940 --> 00:18:05,220
the C version this is how the function

391
00:18:05,220 --> 00:18:08,700
main looks looks like in gidra this is

392
00:18:08,700 --> 00:18:10,919
very nice only a few lines you can see

393
00:18:10,919 --> 00:18:13,799
Hello word and what is going on that

394
00:18:13,799 --> 00:18:15,780
that's that's perfectly clear clear

395
00:18:15,780 --> 00:18:18,600
compared to the one in goal so we have

396
00:18:18,600 --> 00:18:21,860
already a lot of lines no hello around

397
00:18:21,860 --> 00:18:25,320
it's it's it's pretty different and but

398
00:18:25,320 --> 00:18:28,260
if we look harder we will see that there

399
00:18:28,260 --> 00:18:30,960
are these sequence of instructions where

400
00:18:30,960 --> 00:18:34,620
the first one is looking for a memory

401
00:18:34,620 --> 00:18:36,539
address which will be placed into a

402
00:18:36,539 --> 00:18:39,360
register and then this will be moved on

403
00:18:39,360 --> 00:18:42,059
to the stack within with the along with

404
00:18:42,059 --> 00:18:44,280
an integer and if you follow this memory

405
00:18:44,280 --> 00:18:45,539
address you will see that there is

406
00:18:45,539 --> 00:18:48,059
actually hello word it's not defined so

407
00:18:48,059 --> 00:18:49,760
I couldn't

408
00:18:49,760 --> 00:18:54,120
find it but otherwise it's it's there so

409
00:18:54,120 --> 00:18:57,480
the idea is to search for these

410
00:18:57,480 --> 00:19:00,740
instructions and Define the strings

411
00:19:00,740 --> 00:19:04,919
and um and in these these are just a few

412
00:19:04,919 --> 00:19:09,660
examples like uh uh here x 86 and a

413
00:19:09,660 --> 00:19:11,580
64-bit version It's these are very

414
00:19:11,580 --> 00:19:13,919
similar what instruction sequences we

415
00:19:13,919 --> 00:19:16,320
are looking for in our script and once

416
00:19:16,320 --> 00:19:20,039
uh we execute the script then the it

417
00:19:20,039 --> 00:19:22,500
will be nicely defined and we can find

418
00:19:22,500 --> 00:19:24,480
the string the problem is still there so

419
00:19:24,480 --> 00:19:27,360
now we have more than uh seven thousand

420
00:19:27,360 --> 00:19:29,400
strings if we know what we are looking

421
00:19:29,400 --> 00:19:31,320
for that's good because now finally we

422
00:19:31,320 --> 00:19:33,240
have the string there if we don't it's

423
00:19:33,240 --> 00:19:35,039
still a lot of strings but with that we

424
00:19:35,039 --> 00:19:36,679
cannot really do much

425
00:19:36,679 --> 00:19:38,299
and

426
00:19:38,299 --> 00:19:41,580
also in case of the ransomware example I

427
00:19:41,580 --> 00:19:44,640
just wanted to I hope it's visible to

428
00:19:44,640 --> 00:19:46,799
show something why is it useful during

429
00:19:46,799 --> 00:19:49,500
reverse engineering so for example here

430
00:19:49,500 --> 00:19:52,559
when the string was recognized the

431
00:19:52,559 --> 00:19:56,120
memory address is renamed to read

432
00:19:56,120 --> 00:19:58,500
midicrypt.txt so when you read the code

433
00:19:58,500 --> 00:20:00,539
it's much easier to understand what is

434
00:20:00,539 --> 00:20:02,760
actually going on because you already

435
00:20:02,760 --> 00:20:06,120
have some visible strings

436
00:20:06,120 --> 00:20:08,340
and

437
00:20:08,340 --> 00:20:11,820
and the other example it's it's I I

438
00:20:11,820 --> 00:20:13,799
don't want to go into the details I just

439
00:20:13,799 --> 00:20:15,840
wanted to show that there are different

440
00:20:15,840 --> 00:20:18,360
instruction sequences for different uh

441
00:20:18,360 --> 00:20:20,700
architectures so for example our movie

442
00:20:20,700 --> 00:20:22,440
can do the same we just need to find

443
00:20:22,440 --> 00:20:25,559
what are these uh sequences so this can

444
00:20:25,559 --> 00:20:28,260
also be found in our script and it can

445
00:20:28,260 --> 00:20:31,200
recover in arm binaries also

446
00:20:31,200 --> 00:20:33,600
and uh

447
00:20:33,600 --> 00:20:36,480
and the the biggest issue with this one

448
00:20:36,480 --> 00:20:39,600
is uh the of course the different

449
00:20:39,600 --> 00:20:42,419
instruction sets and in can be in

450
00:20:42,419 --> 00:20:45,140
implemented in many many different ways

451
00:20:45,140 --> 00:20:48,000
uh and it if there was a huge change in

452
00:20:48,000 --> 00:20:51,000
goal 1.17 so since then it works a

453
00:20:51,000 --> 00:20:54,659
little bit uh differently but uh in most

454
00:20:54,659 --> 00:20:56,640
of the cases most of the mother that we

455
00:20:56,640 --> 00:20:59,340
have analyzed it was very uh it was in

456
00:20:59,340 --> 00:21:01,200
the same way so we can use for most of

457
00:21:01,200 --> 00:21:02,659
the strings

458
00:21:02,659 --> 00:21:05,220
another example is the statically

459
00:21:05,220 --> 00:21:07,860
allocated string structure

460
00:21:07,860 --> 00:21:11,400
where we where the idea is to where

461
00:21:11,400 --> 00:21:13,320
there are the addresses followed by

462
00:21:13,320 --> 00:21:15,299
integer integers so there is a memory

463
00:21:15,299 --> 00:21:18,659
space where you can find these uh

464
00:21:18,659 --> 00:21:21,080
different uh

465
00:21:21,080 --> 00:21:23,760
values so just an address and then the

466
00:21:23,760 --> 00:21:25,200
length of the string address of the

467
00:21:25,200 --> 00:21:27,960
string length of the string so we just

468
00:21:27,960 --> 00:21:31,860
basically search for these uh values

469
00:21:31,860 --> 00:21:34,020
through the binary and once we find them

470
00:21:34,020 --> 00:21:36,780
we can easily recover the strings and

471
00:21:36,780 --> 00:21:39,419
here is an example where you can see

472
00:21:39,419 --> 00:21:41,640
that there is an address and then what

473
00:21:41,640 --> 00:21:43,620
the length we should look for this is

474
00:21:43,620 --> 00:21:45,600
also from the ransomware these are the

475
00:21:45,600 --> 00:21:47,960
extensions that the ransomware is

476
00:21:47,960 --> 00:21:51,600
encrypting so after executing the script

477
00:21:51,600 --> 00:21:54,539
we will see where these addresses are

478
00:21:54,539 --> 00:21:57,960
pointing at and what kind of string can

479
00:21:57,960 --> 00:22:00,780
be found there so this is basically an

480
00:22:00,780 --> 00:22:04,220
easier way to recover functions and

481
00:22:04,220 --> 00:22:07,140
with recover strings and what is really

482
00:22:07,140 --> 00:22:09,840
good about this one that it's not

483
00:22:09,840 --> 00:22:13,500
architecture specific there are many

484
00:22:13,500 --> 00:22:17,820
issues with this part as well like the

485
00:22:17,820 --> 00:22:21,480
the static string recovery challenges

486
00:22:21,480 --> 00:22:24,360
also like for example when some of these

487
00:22:24,360 --> 00:22:26,940
data already defined by dittra so I

488
00:22:26,940 --> 00:22:28,860
would like to create a I don't know

489
00:22:28,860 --> 00:22:30,720
integer there but there is already some

490
00:22:30,720 --> 00:22:32,940
data and it happens quite often that

491
00:22:32,940 --> 00:22:36,120
gidra defines these data as undefined

492
00:22:36,120 --> 00:22:39,360
this this is also like a defined data

493
00:22:39,360 --> 00:22:41,700
type and what we have to do is get rid

494
00:22:41,700 --> 00:22:45,059
of these falsely identified data types

495
00:22:45,059 --> 00:22:49,559
and the one example of this and I will

496
00:22:49,559 --> 00:22:50,820
go to the next one because that's more

497
00:22:50,820 --> 00:22:52,440
interesting what I was already talking

498
00:22:52,440 --> 00:22:54,720
about is they like these large string

499
00:22:54,720 --> 00:22:59,220
blobs so here uh gidra already created a

500
00:22:59,220 --> 00:23:01,380
huge huge strings because there were uh

501
00:23:01,380 --> 00:23:03,419
concatenated the smaller ones within the

502
00:23:03,419 --> 00:23:06,480
binary and it handles as one uh big

503
00:23:06,480 --> 00:23:07,919
string

504
00:23:07,919 --> 00:23:12,179
so what we can do here is before we

505
00:23:12,179 --> 00:23:14,640
execute our script we have to undefine

506
00:23:14,640 --> 00:23:18,299
these huge strings and we can find these

507
00:23:18,299 --> 00:23:20,880
by looking for offcut references so

508
00:23:20,880 --> 00:23:23,100
those strings were have a lot of

509
00:23:23,100 --> 00:23:25,320
references not to the beginning of the

510
00:23:25,320 --> 00:23:28,559
string rather somewhere inside those

511
00:23:28,559 --> 00:23:30,659
those are very suspicious that they

512
00:23:30,659 --> 00:23:33,240
shouldn't be one huge string rather more

513
00:23:33,240 --> 00:23:35,760
smaller one so what we should do here is

514
00:23:35,760 --> 00:23:37,919
undefine it and then we can create our

515
00:23:37,919 --> 00:23:40,159
own streams

516
00:23:40,159 --> 00:23:44,279
and the last topic which I would like to

517
00:23:44,279 --> 00:23:49,100
shortly introduce is the type extraction

518
00:23:49,100 --> 00:23:52,620
so this is something we worked on

519
00:23:52,620 --> 00:23:55,140
recently there are descriptions of four

520
00:23:55,140 --> 00:23:57,419
types which are available within the

521
00:23:57,419 --> 00:23:59,340
binary there are very simple types like

522
00:23:59,340 --> 00:24:01,799
strings integers that we all know and

523
00:24:01,799 --> 00:24:05,100
some like composite types not too

524
00:24:05,100 --> 00:24:07,980
complicated but function structures and

525
00:24:07,980 --> 00:24:11,340
these kind of things and we can also

526
00:24:11,340 --> 00:24:13,740
recover these and get a lot of lot of

527
00:24:13,740 --> 00:24:18,120
useful uh information about the uh

528
00:24:18,120 --> 00:24:22,020
binary so let's look at the example of

529
00:24:22,020 --> 00:24:25,320
csrv binary where we have the miner.new

530
00:24:25,320 --> 00:24:28,559
process for function and there is the

531
00:24:28,559 --> 00:24:31,620
runtime that new object function call we

532
00:24:31,620 --> 00:24:34,440
see a lot of these in go binaries and if

533
00:24:34,440 --> 00:24:37,679
we check the memory address just before

534
00:24:37,679 --> 00:24:39,779
this function call we see that there is

535
00:24:39,779 --> 00:24:41,760
something but we don't really understand

536
00:24:41,760 --> 00:24:45,059
what is going on uh there and we see we

537
00:24:45,059 --> 00:24:46,740
have seen a lot of these within the

538
00:24:46,740 --> 00:24:48,240
binaries and we really want you to

539
00:24:48,240 --> 00:24:51,539
understand what is going on there and we

540
00:24:51,539 --> 00:24:53,159
realize that these this is where

541
00:24:53,159 --> 00:24:55,500
actually the type description is

542
00:24:55,500 --> 00:24:58,679
happening so there is a so-called r-type

543
00:24:58,679 --> 00:25:00,799
structure which tells you what kind of

544
00:25:00,799 --> 00:25:05,299
type the goal is

545
00:25:05,299 --> 00:25:08,520
using there so first of all you can find

546
00:25:08,520 --> 00:25:11,039
a kind of the type in this case it's a

547
00:25:11,039 --> 00:25:14,580
struct type and then there is a string

548
00:25:14,580 --> 00:25:17,220
which tells you the name of this type if

549
00:25:17,220 --> 00:25:19,200
I I know it's a little bit too much but

550
00:25:19,200 --> 00:25:21,720
I will show in the end example and you

551
00:25:21,720 --> 00:25:23,820
will see why why it can be useful during

552
00:25:23,820 --> 00:25:25,320
reverse engineering

553
00:25:25,320 --> 00:25:28,400
so here we can find that this

554
00:25:28,400 --> 00:25:31,220
structure this type

555
00:25:31,220 --> 00:25:35,039
structure will describe the minor dot

556
00:25:35,039 --> 00:25:39,360
process and there are many different

557
00:25:39,360 --> 00:25:42,260
parts of the binary that we have to

558
00:25:42,260 --> 00:25:46,220
consider and look into uh

559
00:25:46,220 --> 00:25:49,500
like we need to build up these

560
00:25:49,500 --> 00:25:53,039
structures and we use these in our

561
00:25:53,039 --> 00:25:55,320
script I just put it here if someone is

562
00:25:55,320 --> 00:25:57,299
more interested and someone really wants

563
00:25:57,299 --> 00:25:59,700
to understand what is going on here what

564
00:25:59,700 --> 00:26:03,299
structures we need to look for but uh

565
00:26:03,299 --> 00:26:06,419
but it's uh it's basically in our script

566
00:26:06,419 --> 00:26:08,279
we are looking for these different

567
00:26:08,279 --> 00:26:10,679
structures and this helps us to build up

568
00:26:10,679 --> 00:26:13,940
these types this is a recursive

569
00:26:13,940 --> 00:26:16,980
process and you can get all the types

570
00:26:16,980 --> 00:26:20,100
easily so what happens here in in our

571
00:26:20,100 --> 00:26:22,679
example that when the runtime to the new

572
00:26:22,679 --> 00:26:26,580
object function was called we understood

573
00:26:26,580 --> 00:26:29,039
that there is a type description before

574
00:26:29,039 --> 00:26:30,779
that that's a specific memory address

575
00:26:30,779 --> 00:26:33,360
which is called minor dot process and

576
00:26:33,360 --> 00:26:36,120
now we could build up the structure if

577
00:26:36,120 --> 00:26:39,059
you see in like the top right this is

578
00:26:39,059 --> 00:26:42,299
where you can find how this structure is

579
00:26:42,299 --> 00:26:44,640
built up so it can help a lot when you

580
00:26:44,640 --> 00:26:47,220
try to understand what is going on

581
00:26:47,220 --> 00:26:51,179
within a binary and this is another

582
00:26:51,179 --> 00:26:55,080
example very shortly with the ransomware

583
00:26:55,080 --> 00:26:58,679
so here this is the main.get info

584
00:26:58,679 --> 00:27:01,799
function and then when you look into the

585
00:27:01,799 --> 00:27:04,860
structure and understand that it's there

586
00:27:04,860 --> 00:27:06,659
is something going on some communication

587
00:27:06,659 --> 00:27:08,520
and you would understand that the main

588
00:27:08,520 --> 00:27:10,980
dot infrastructure is looking for an RSA

589
00:27:10,980 --> 00:27:12,779
public key and the readme string so for

590
00:27:12,779 --> 00:27:14,360
example this can help you to understand

591
00:27:14,360 --> 00:27:16,980
what is going on when there is a C2

592
00:27:16,980 --> 00:27:19,380
communication what data is transferred

593
00:27:19,380 --> 00:27:21,360
just with static analysis without

594
00:27:21,360 --> 00:27:22,460
actually

595
00:27:22,460 --> 00:27:25,220
grabbing the communication and

596
00:27:25,220 --> 00:27:27,539
decrypting it or something just with

597
00:27:27,539 --> 00:27:29,580
this information you can find what they

598
00:27:29,580 --> 00:27:31,260
exactly looking what are they exactly

599
00:27:31,260 --> 00:27:32,340
looking for

600
00:27:32,340 --> 00:27:35,820
and just one last note here is as I

601
00:27:35,820 --> 00:27:37,080
already mentioned a couple of times

602
00:27:37,080 --> 00:27:39,720
during this presentation uh the

603
00:27:39,720 --> 00:27:41,220
challenge the biggest challenge is that

604
00:27:41,220 --> 00:27:43,320
Google versions are constantly changing

605
00:27:43,320 --> 00:27:46,020
and also at the moment our script is

606
00:27:46,020 --> 00:27:50,640
looking for uh strings to understand

607
00:27:50,640 --> 00:27:54,240
which conversion is actually used by the

608
00:27:54,240 --> 00:27:56,340
specific binary this is not the best

609
00:27:56,340 --> 00:27:58,620
Solutions it's a little bit slow it

610
00:27:58,620 --> 00:28:01,679
works yeah in every case it worked where

611
00:28:01,679 --> 00:28:03,840
I tried and I was analyzing mother but

612
00:28:03,840 --> 00:28:06,179
it's still not perfect so we try to

613
00:28:06,179 --> 00:28:09,659
update this in a smarter way but

614
00:28:09,659 --> 00:28:12,059
it's kind of funny that also how the

615
00:28:12,059 --> 00:28:13,559
versions are changing it makes it more

616
00:28:13,559 --> 00:28:15,120
difficult to figure out which version we

617
00:28:15,120 --> 00:28:16,080
are at

618
00:28:16,080 --> 00:28:19,380
so this this is the the one of the

619
00:28:19,380 --> 00:28:21,480
biggest challenges we have to have to

620
00:28:21,480 --> 00:28:25,740
solve now and uh just before I uh close

621
00:28:25,740 --> 00:28:28,980
my talk there are many many work on this

622
00:28:28,980 --> 00:28:31,200
topic and I really want to mention the

623
00:28:31,200 --> 00:28:33,480
other researchers who worked mostly in

624
00:28:33,480 --> 00:28:36,960
Ida Pro but if you use radar or gidra

625
00:28:36,960 --> 00:28:39,059
there are others also and of course

626
00:28:39,059 --> 00:28:42,539
redress is one of the best tools that

627
00:28:42,539 --> 00:28:44,940
you can use for uh go binary analysis

628
00:28:44,940 --> 00:28:46,980
and I'm sure right in the Next Room you

629
00:28:46,980 --> 00:28:51,860
can even hear more tips what you can use

630
00:28:51,860 --> 00:28:56,640
so so there is an extensive work around

631
00:28:56,640 --> 00:28:57,919
this topic

632
00:28:57,919 --> 00:29:01,200
and these are the files used during the

633
00:29:01,200 --> 00:29:04,260
presentation all the Hello bird files

634
00:29:04,260 --> 00:29:06,059
are available on our GitHub so if you

635
00:29:06,059 --> 00:29:07,980
would like to go through I'd like to

636
00:29:07,980 --> 00:29:10,799
play with it or understand in a slower

637
00:29:10,799 --> 00:29:13,260
Pace what was happening here then you

638
00:29:13,260 --> 00:29:15,419
can find this on GitHub all the others

639
00:29:15,419 --> 00:29:17,779
are available on virus total for example

640
00:29:17,779 --> 00:29:21,360
some references other presentations or

641
00:29:21,360 --> 00:29:24,179
like a very nice blog post where you can

642
00:29:24,179 --> 00:29:26,399
read about it by the way all of these

643
00:29:26,399 --> 00:29:28,919
will be available on our blog so you can

644
00:29:28,919 --> 00:29:30,539
read through

645
00:29:30,539 --> 00:29:33,539
and yeah that's that's uh it's from me

646
00:29:33,539 --> 00:29:36,659
today and uh if you have any questions

647
00:29:36,659 --> 00:29:39,600
later on or or any ideas or you want to

648
00:29:39,600 --> 00:29:41,700
contribute it's very I would be very

649
00:29:41,700 --> 00:29:44,700
happy uh to talk about it and also you

650
00:29:44,700 --> 00:29:47,640
can find everything on our GitHub uh so

651
00:29:47,640 --> 00:29:50,100
you can use our scripts and

652
00:29:50,100 --> 00:29:53,279
update it or whatever you would like so

653
00:29:53,279 --> 00:29:57,080
thank you very much for your attention

654
00:29:57,470 --> 00:30:02,049
[Applause]

655
00:30:02,220 --> 00:30:04,679
thank you very much Dorca uh we have a

656
00:30:04,679 --> 00:30:07,799
couple minutes for questions uh are

657
00:30:07,799 --> 00:30:10,820
there questions in the room

658
00:30:11,279 --> 00:30:13,799
no okay

659
00:30:13,799 --> 00:30:15,960
I'll jump

660
00:30:15,960 --> 00:30:17,880
um is there

661
00:30:17,880 --> 00:30:22,020
anything in guidra that makes it much

662
00:30:22,020 --> 00:30:23,640
better than the other tools that you

663
00:30:23,640 --> 00:30:24,539
mentioned

664
00:30:24,539 --> 00:30:27,000
it's free

665
00:30:27,000 --> 00:30:30,080
compared to either this is the biggest

666
00:30:30,080 --> 00:30:34,380
benefit but yeah it's um

667
00:30:34,380 --> 00:30:37,380
no I I also like to use radar so that's

668
00:30:37,380 --> 00:30:40,380
also nice but it already had a lot of

669
00:30:40,380 --> 00:30:43,320
support for that and we use guitar many

670
00:30:43,320 --> 00:30:46,500
times usually I have started with Ida

671
00:30:46,500 --> 00:30:49,380
but then we moved into gidra and yeah I

672
00:30:49,380 --> 00:30:51,840
think all of them are pretty good to

673
00:30:51,840 --> 00:30:54,000
tell the truth but yeah it's open source

674
00:30:54,000 --> 00:30:56,220
and free so make it the biggest

675
00:30:56,220 --> 00:30:57,779
advantage

676
00:30:57,779 --> 00:31:02,779
okay thank you are there other questions

677
00:31:04,080 --> 00:31:06,600
I don't think so oh yes right over there

678
00:31:06,600 --> 00:31:11,299
yes you please use the mics on the side

679
00:31:20,220 --> 00:31:22,019
sorry I saw about as far away from the

680
00:31:22,019 --> 00:31:23,399
microphone as I could

681
00:31:23,399 --> 00:31:25,860
um have you ever come across

682
00:31:25,860 --> 00:31:28,559
um any kind of like golang obfuscators

683
00:31:28,559 --> 00:31:30,360
or Packers in the kind of research that

684
00:31:30,360 --> 00:31:32,399
you've been doing and uh if so what kind

685
00:31:32,399 --> 00:31:33,659
of approaches would you want to take

686
00:31:33,659 --> 00:31:36,120
with your kind of tooling to help you

687
00:31:36,120 --> 00:31:38,340
unpack and analyze those kind of samples

688
00:31:38,340 --> 00:31:40,320
yeah that's a very good question so

689
00:31:40,320 --> 00:31:42,120
there are obfuscators where they

690
00:31:42,120 --> 00:31:45,120
actually change the function names and

691
00:31:45,120 --> 00:31:45,840
then

692
00:31:45,840 --> 00:31:47,640
even if you recover them it doesn't

693
00:31:47,640 --> 00:31:49,260
really help much

694
00:31:49,260 --> 00:31:52,260
and to tell the truth I didn't look into

695
00:31:52,260 --> 00:31:55,140
that that's it's called GoPro skater or

696
00:31:55,140 --> 00:31:56,700
something like that and I didn't go into

697
00:31:56,700 --> 00:32:00,059
details if you can like undo it I I

698
00:32:00,059 --> 00:32:02,840
doubt that it would be that easy and uh

699
00:32:02,840 --> 00:32:05,700
just yesterday I got a message that

700
00:32:05,700 --> 00:32:08,279
something new was coming up it's

701
00:32:08,279 --> 00:32:12,120
supposed to get rid of the uh like so

702
00:32:12,120 --> 00:32:14,100
what is interesting in the go binary is

703
00:32:14,100 --> 00:32:16,320
that even in striped version you can

704
00:32:16,320 --> 00:32:18,299
still find all this information like the

705
00:32:18,299 --> 00:32:19,679
type information the function name

706
00:32:19,679 --> 00:32:22,220
information because it's needed for

707
00:32:22,220 --> 00:32:25,200
these binaries to operate correctly but

708
00:32:25,200 --> 00:32:28,620
there is some new project in GitHub I

709
00:32:28,620 --> 00:32:30,539
don't remember the name I heard about it

710
00:32:30,539 --> 00:32:32,880
yesterday and it says that they somehow

711
00:32:32,880 --> 00:32:36,360
get rid of these important I I suspect

712
00:32:36,360 --> 00:32:38,159
that they also just change the strings

713
00:32:38,159 --> 00:32:40,919
not actually get rid of it but yeah so I

714
00:32:40,919 --> 00:32:42,480
don't I don't really know how to recover

715
00:32:42,480 --> 00:32:44,220
those that wouldn't take much more

716
00:32:44,220 --> 00:32:47,000
research

717
00:32:49,919 --> 00:32:54,480
no one else okay then thanks again for

718
00:32:54,480 --> 00:32:57,860
the last time tolka

