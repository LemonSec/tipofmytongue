1
00:00:02,639 --> 00:00:04,480
hello everyone and welcome to our

2
00:00:04,480 --> 00:00:06,080
breaking drydex mower talk

3
00:00:06,080 --> 00:00:09,280
at the first conference 2021. my name is

4
00:00:09,280 --> 00:00:11,599
gustavo i'm a security researcher and

5
00:00:11,599 --> 00:00:12,320
manager at

6
00:00:12,320 --> 00:00:14,880
immunity which is part of appgates and

7
00:00:14,880 --> 00:00:18,320
we also have felipe in the call

8
00:00:20,000 --> 00:00:22,320
hello everyone i'm felipe dominguez

9
00:00:22,320 --> 00:00:24,560
security researcher at community

10
00:00:24,560 --> 00:00:26,080
in this presentation we have two

11
00:00:26,080 --> 00:00:27,840
different goals first

12
00:00:27,840 --> 00:00:30,240
showing how our analysis can be used to

13
00:00:30,240 --> 00:00:32,399
identify a threat capabilities

14
00:00:32,399 --> 00:00:35,200
extract iocs and automate detection and

15
00:00:35,200 --> 00:00:35,680
second

16
00:00:35,680 --> 00:00:37,840
showing how a full knowledge on a threat

17
00:00:37,840 --> 00:00:39,760
can help us building tools to fight

18
00:00:39,760 --> 00:00:40,399
against it

19
00:00:40,399 --> 00:00:43,040
for that we'll analyze tridex one of the

20
00:00:43,040 --> 00:00:45,280
most popular malware families currently

21
00:00:45,280 --> 00:00:46,079
active

22
00:00:46,079 --> 00:00:48,320
and then develop a vaccine that can be

23
00:00:48,320 --> 00:00:50,640
deployed on systems to protect against

24
00:00:50,640 --> 00:00:51,840
it

25
00:00:51,840 --> 00:00:54,480
all right thank you very much let me go

26
00:00:54,480 --> 00:00:56,239
over really quick over the presentations

27
00:00:56,239 --> 00:00:57,199
agenda

28
00:00:57,199 --> 00:00:59,120
we will start by a brief introduction

29
00:00:59,120 --> 00:01:02,000
about drydex showing its anatomy and how

30
00:01:02,000 --> 00:01:03,520
it usually works

31
00:01:03,520 --> 00:01:05,920
then we will demonstrate how the payload

32
00:01:05,920 --> 00:01:07,119
could be obtained

33
00:01:07,119 --> 00:01:09,520
when you have the packet file and once

34
00:01:09,520 --> 00:01:11,360
we have the payload we will then cover

35
00:01:11,360 --> 00:01:12,880
some of the main features about this

36
00:01:12,880 --> 00:01:14,640
malware such as the encrypted strings

37
00:01:14,640 --> 00:01:16,000
the c2 communication

38
00:01:16,000 --> 00:01:18,240
and also what we did to automate the

39
00:01:18,240 --> 00:01:22,479
actionable data extraction with a python

40
00:01:24,840 --> 00:01:26,320
script

41
00:01:26,320 --> 00:01:28,640
later we will demonstrate how drydex

42
00:01:28,640 --> 00:01:30,720
works when it comes to the windows api

43
00:01:30,720 --> 00:01:31,759
resolution

44
00:01:31,759 --> 00:01:33,840
and how we exploited that to create the

45
00:01:33,840 --> 00:01:35,360
vaccine

46
00:01:35,360 --> 00:01:37,280
all right so first things first uh

47
00:01:37,280 --> 00:01:38,400
drydex is

48
00:01:38,400 --> 00:01:40,640
one of the most relevant banking trojans

49
00:01:40,640 --> 00:01:42,079
in the wild

50
00:01:42,079 --> 00:01:45,040
it has first appeared about 10 years ago

51
00:01:45,040 --> 00:01:45,280
as

52
00:01:45,280 --> 00:01:48,079
crydex sharing a lot of features with

53
00:01:48,079 --> 00:01:49,439
the game over zeus

54
00:01:49,439 --> 00:01:51,840
which was another major threat across

55
00:01:51,840 --> 00:01:52,720
the years

56
00:01:52,720 --> 00:01:55,759
drydex has launched a few versions

57
00:01:55,759 --> 00:01:58,159
with many specific features some of

58
00:01:58,159 --> 00:01:59,200
which we will show

59
00:01:59,200 --> 00:02:01,759
in this presentation all right so let's

60
00:02:01,759 --> 00:02:03,759
take a look in the infection chain

61
00:02:03,759 --> 00:02:06,399
uh drydex is usually delivered through

62
00:02:06,399 --> 00:02:08,239
an infected microsoft office

63
00:02:08,239 --> 00:02:11,280
file which downloads or drops the dridex

64
00:02:11,280 --> 00:02:12,319
loader

65
00:02:12,319 --> 00:02:14,560
the loader is responsible for contacting

66
00:02:14,560 --> 00:02:15,840
the c2 server

67
00:02:15,840 --> 00:02:18,160
and to download additional files such as

68
00:02:18,160 --> 00:02:20,560
the main bots and other modules

69
00:02:20,560 --> 00:02:23,040
so the bot contains most of the drydex

70
00:02:23,040 --> 00:02:24,080
functionalities

71
00:02:24,080 --> 00:02:25,599
such as the keylogger and the web

72
00:02:25,599 --> 00:02:28,160
injections and as just mentioned

73
00:02:28,160 --> 00:02:30,400
drydex is modular which means that it

74
00:02:30,400 --> 00:02:31,280
can download

75
00:02:31,280 --> 00:02:33,680
and execute additional payloads such as

76
00:02:33,680 --> 00:02:34,560
a vnc

77
00:02:34,560 --> 00:02:37,200
file which allows remote access and a

78
00:02:37,200 --> 00:02:40,239
socks prox module

79
00:02:40,239 --> 00:02:42,560
this research is mainly focused on the

80
00:02:42,560 --> 00:02:43,519
dridex loader

81
00:02:43,519 --> 00:02:45,040
and that's because we wanted to make

82
00:02:45,040 --> 00:02:47,200
sure that we can extract the situ server

83
00:02:47,200 --> 00:02:49,840
addresses which are stored in the loader

84
00:02:49,840 --> 00:02:51,680
also we believe that the loader is the

85
00:02:51,680 --> 00:02:53,680
best layer to implement the vaccine

86
00:02:53,680 --> 00:02:56,720
as the downloader can vary a lot and

87
00:02:56,720 --> 00:02:58,480
many of the features implemented by the

88
00:02:58,480 --> 00:03:00,480
loader is also present in the other

89
00:03:00,480 --> 00:03:02,400
layers so we can use most of our

90
00:03:02,400 --> 00:03:03,280
research

91
00:03:03,280 --> 00:03:06,239
in the bots and the modules as well so

92
00:03:06,239 --> 00:03:07,920
the first thing we need to do

93
00:03:07,920 --> 00:03:09,760
when we have a drydex loader is to

94
00:03:09,760 --> 00:03:11,280
unpack the file

95
00:03:11,280 --> 00:03:13,519
almost every loader we have analyzer

96
00:03:13,519 --> 00:03:15,280
contained a custom packer

97
00:03:15,280 --> 00:03:17,280
and the payload is never written into

98
00:03:17,280 --> 00:03:19,280
disk which means that we have to unpack

99
00:03:19,280 --> 00:03:20,080
the file

100
00:03:20,080 --> 00:03:22,959
and dump it so we can analyze the

101
00:03:22,959 --> 00:03:24,560
process is pretty straightforward

102
00:03:24,560 --> 00:03:27,120
once the file is running it decrypts and

103
00:03:27,120 --> 00:03:27,840
executes

104
00:03:27,840 --> 00:03:30,480
a small dll in memory which is

105
00:03:30,480 --> 00:03:31,440
responsible for

106
00:03:31,440 --> 00:03:34,640
unpacking the payload so here we can see

107
00:03:34,640 --> 00:03:36,560
the same process in the immunity

108
00:03:36,560 --> 00:03:39,280
debugger so first the encrypted dll

109
00:03:39,280 --> 00:03:42,640
is copied to a recently allocated memory

110
00:03:42,640 --> 00:03:45,200
then after the printing the bytes the

111
00:03:45,200 --> 00:03:46,080
dll is

112
00:03:46,080 --> 00:03:48,400
executed and the payload isn't packaged

113
00:03:48,400 --> 00:03:50,080
to another memory location

114
00:03:50,080 --> 00:03:52,879
which is eventually executed the dridex

115
00:03:52,879 --> 00:03:54,640
loader could be easily unpacked by

116
00:03:54,640 --> 00:03:56,640
monitoring the calls to virtual lock and

117
00:03:56,640 --> 00:03:58,000
virtual protect

118
00:03:58,000 --> 00:04:00,080
or by using a tool such as a hollows

119
00:04:00,080 --> 00:04:02,400
hunter

120
00:04:02,400 --> 00:04:04,480
once we have the unpacked loader we can

121
00:04:04,480 --> 00:04:06,400
start the analysis on the real file

122
00:04:06,400 --> 00:04:08,319
one of the most important things is that

123
00:04:08,319 --> 00:04:10,480
all the drydex strings are encrypted in

124
00:04:10,480 --> 00:04:11,360
the binary

125
00:04:11,360 --> 00:04:13,360
probably to evade detection and make the

126
00:04:13,360 --> 00:04:15,120
analysis more difficult

127
00:04:15,120 --> 00:04:18,000
fortunately is not a complicated process

128
00:04:18,000 --> 00:04:19,918
all these strings are located in the r

129
00:04:19,918 --> 00:04:21,918
data section of the pe file

130
00:04:21,918 --> 00:04:23,919
and you could identify them by checking

131
00:04:23,919 --> 00:04:25,440
the either cross reference to the

132
00:04:25,440 --> 00:04:26,960
location or using another

133
00:04:26,960 --> 00:04:29,360
disassembly of your preference so here

134
00:04:29,360 --> 00:04:31,280
we have an example showing the reference

135
00:04:31,280 --> 00:04:31,919
to these

136
00:04:31,919 --> 00:04:34,960
our data offsets and we can see that it

137
00:04:34,960 --> 00:04:36,720
is some nonsense bytes

138
00:04:36,720 --> 00:04:39,600
not showing any clear text the structure

139
00:04:39,600 --> 00:04:41,680
is pretty simple the algorithm used by

140
00:04:41,680 --> 00:04:43,440
drydex is rc4

141
00:04:43,440 --> 00:04:45,919
and the first 40 bytes is the key

142
00:04:45,919 --> 00:04:47,440
meaning that the rest of the blob is

143
00:04:47,440 --> 00:04:48,960
just encrypted data

144
00:04:48,960 --> 00:04:50,639
by using a small python script as

145
00:04:50,639 --> 00:04:52,479
demonstrated in the second image we

146
00:04:52,479 --> 00:04:54,160
could easily decrypt those bytes and

147
00:04:54,160 --> 00:04:57,600
review the real stream

148
00:04:57,600 --> 00:05:00,000
so another very important parts is the

149
00:05:00,000 --> 00:05:01,520
c2 communication

150
00:05:01,520 --> 00:05:04,000
as mentioned before the drydex loader is

151
00:05:04,000 --> 00:05:04,560
the one

152
00:05:04,560 --> 00:05:06,720
responsible for contacting the c2

153
00:05:06,720 --> 00:05:08,800
servers to download the bots and the

154
00:05:08,800 --> 00:05:10,320
additional files

155
00:05:10,320 --> 00:05:12,880
the first thing is how the c2 commands

156
00:05:12,880 --> 00:05:14,560
are stored in the file

157
00:05:14,560 --> 00:05:16,880
so drydex uses a very simple process it

158
00:05:16,880 --> 00:05:19,360
calculates the crc32 hash

159
00:05:19,360 --> 00:05:22,240
of the string that represents the commas

160
00:05:22,240 --> 00:05:22,560
so

161
00:05:22,560 --> 00:05:25,440
in this example the string bots which is

162
00:05:25,440 --> 00:05:27,039
the command to download the drydex

163
00:05:27,039 --> 00:05:27,919
magnifier

164
00:05:27,919 --> 00:05:30,560
is represented with this extra decimal

165
00:05:30,560 --> 00:05:31,280
number

166
00:05:31,280 --> 00:05:34,240
which is the crc32 hash of the string

167
00:05:34,240 --> 00:05:36,000
and the mower does that for all the

168
00:05:36,000 --> 00:05:38,639
other strings slash commands

169
00:05:38,639 --> 00:05:40,960
so the way the situ server address is

170
00:05:40,960 --> 00:05:42,080
stored in the binary

171
00:05:42,080 --> 00:05:44,400
depends on the dridex version in the

172
00:05:44,400 --> 00:05:46,080
latest which is the one that we are

173
00:05:46,080 --> 00:05:47,919
showing in this presentation

174
00:05:47,919 --> 00:05:50,639
all the addresses are stored as bytes in

175
00:05:50,639 --> 00:05:51,280
dpe

176
00:05:51,280 --> 00:05:53,919
data section as demonstrated in the

177
00:05:53,919 --> 00:05:54,880
first image

178
00:05:54,880 --> 00:05:56,479
uh we have first two bytes that

179
00:05:56,479 --> 00:05:58,639
represents the botnet id

180
00:05:58,639 --> 00:06:01,199
then one bytes that contains the amount

181
00:06:01,199 --> 00:06:02,479
of ip addresses

182
00:06:02,479 --> 00:06:05,280
that this loader can connect and finally

183
00:06:05,280 --> 00:06:06,880
we have the ap addresses that

184
00:06:06,880 --> 00:06:09,759
are for in this case here on the right

185
00:06:09,759 --> 00:06:10,720
we can see in

186
00:06:10,720 --> 00:06:13,120
immune debugger the exact function that

187
00:06:13,120 --> 00:06:15,039
loads the data on the left

188
00:06:15,039 --> 00:06:17,600
by parsing those bytes and building dip

189
00:06:17,600 --> 00:06:18,319
string

190
00:06:18,319 --> 00:06:20,160
so after parsing the addresses the

191
00:06:20,160 --> 00:06:22,240
loader sends an initial request to the

192
00:06:22,240 --> 00:06:24,319
c2 server with a few information about

193
00:06:24,319 --> 00:06:25,919
the infected machine

194
00:06:25,919 --> 00:06:28,000
so in the left we can see that the data

195
00:06:28,000 --> 00:06:29,280
is properly encrypted

196
00:06:29,280 --> 00:06:31,039
since we can't understand what was

197
00:06:31,039 --> 00:06:33,759
submitted so after reversing a couple of

198
00:06:33,759 --> 00:06:34,560
samples

199
00:06:34,560 --> 00:06:36,400
we saw that this information is

200
00:06:36,400 --> 00:06:38,800
encrypted with rc4

201
00:06:38,800 --> 00:06:41,199
and the key is among tridex encrypted

202
00:06:41,199 --> 00:06:41,840
strings

203
00:06:41,840 --> 00:06:43,759
which we already demonstrated how to

204
00:06:43,759 --> 00:06:46,479
extract so by decrypting the data

205
00:06:46,479 --> 00:06:48,319
we can see some of the information that

206
00:06:48,319 --> 00:06:49,840
is being uploaded to the server

207
00:06:49,840 --> 00:06:52,160
such as the computer name the botnet id

208
00:06:52,160 --> 00:06:53,199
the command strings

209
00:06:53,199 --> 00:06:55,360
as well as the list of the installed

210
00:06:55,360 --> 00:06:58,400
software in the machine

211
00:07:01,280 --> 00:07:03,039
all right so once you know how all of

212
00:07:03,039 --> 00:07:05,039
this works uh what we can do

213
00:07:05,039 --> 00:07:07,039
to make our life easier when it comes to

214
00:07:07,039 --> 00:07:08,240
the analysis

215
00:07:08,240 --> 00:07:11,120
so at this point using python or another

216
00:07:11,120 --> 00:07:12,639
language of a preference

217
00:07:12,639 --> 00:07:14,639
we can automate the extraction of the

218
00:07:14,639 --> 00:07:17,039
botnet id and the c2 server list

219
00:07:17,039 --> 00:07:19,039
which could be very useful for socks or

220
00:07:19,039 --> 00:07:21,039
any black list you may need to feed

221
00:07:21,039 --> 00:07:22,800
we can also decrypt these strings which

222
00:07:22,800 --> 00:07:24,800
contains many useful data such as the

223
00:07:24,800 --> 00:07:26,160
key to decrypt the c2 server

224
00:07:26,160 --> 00:07:27,120
communication

225
00:07:27,120 --> 00:07:29,919
that we can also automate one point that

226
00:07:29,919 --> 00:07:31,280
we need to make clear is that the

227
00:07:31,280 --> 00:07:33,680
automation will not work in 100 of the

228
00:07:33,680 --> 00:07:34,400
cases

229
00:07:34,400 --> 00:07:36,479
since you can have different versions or

230
00:07:36,479 --> 00:07:37,919
variants of the malware

231
00:07:37,919 --> 00:07:40,240
but according to our experience a lot of

232
00:07:40,240 --> 00:07:42,560
code is shared across modern versions

233
00:07:42,560 --> 00:07:44,400
so you could easily track the changes

234
00:07:44,400 --> 00:07:46,240
and update your scripts to keep them

235
00:07:46,240 --> 00:07:48,319
working normally

236
00:07:48,319 --> 00:07:50,400
thinking about that we have compiled

237
00:07:50,400 --> 00:07:52,240
everything we could in what we call it

238
00:07:52,240 --> 00:07:54,240
the drydex analysis toolkit

239
00:07:54,240 --> 00:07:56,160
it was everything done with python and

240
00:07:56,160 --> 00:07:57,680
the script can do pretty much what we

241
00:07:57,680 --> 00:07:59,440
just described it without the need of

242
00:07:59,440 --> 00:08:01,039
analyzing the file manually or

243
00:08:01,039 --> 00:08:03,759
executing it in the github page you can

244
00:08:03,759 --> 00:08:05,360
find all the options provided by the

245
00:08:05,360 --> 00:08:06,000
script

246
00:08:06,000 --> 00:08:12,080
as demonstrated in the second image

247
00:08:12,080 --> 00:08:14,479
so here is an example uh we have

248
00:08:14,479 --> 00:08:16,479
unpacked a drydexloader and then

249
00:08:16,479 --> 00:08:18,720
executed the script with the verbos

250
00:08:18,720 --> 00:08:21,680
and the dash c option which extracts the

251
00:08:21,680 --> 00:08:23,120
situ server list

252
00:08:23,120 --> 00:08:25,440
first the script outputs the binary

253
00:08:25,440 --> 00:08:26,240
information

254
00:08:26,240 --> 00:08:27,919
such as the hashes and the compiled

255
00:08:27,919 --> 00:08:30,400
dates that we read from the pe header

256
00:08:30,400 --> 00:08:32,958
and then in case the file was dumped

257
00:08:32,958 --> 00:08:34,958
from memory and the de file was not

258
00:08:34,958 --> 00:08:36,399
unmapped to disk

259
00:08:36,399 --> 00:08:38,559
the script can do this automatically for

260
00:08:38,559 --> 00:08:40,479
you just save you some time

261
00:08:40,479 --> 00:08:42,719
then it will try to locate the c2 server

262
00:08:42,719 --> 00:08:44,159
list inside the binary

263
00:08:44,159 --> 00:08:46,160
any case it founds it will parse the

264
00:08:46,160 --> 00:08:47,360
data and displays

265
00:08:47,360 --> 00:08:50,160
all the addresses in the screen for you

266
00:08:50,160 --> 00:08:51,360
also if you use

267
00:08:51,360 --> 00:08:54,800
a dash a or the dash s option the two

268
00:08:54,800 --> 00:08:55,680
will decrypt

269
00:08:55,680 --> 00:08:58,000
all the strings it can find also

270
00:08:58,000 --> 00:08:59,360
printing on the screen

271
00:08:59,360 --> 00:09:02,160
the possible rc4 keys use it to encrypt

272
00:09:02,160 --> 00:09:04,399
and decrypt the network communication

273
00:09:04,399 --> 00:09:06,560
and finally all the results are written

274
00:09:06,560 --> 00:09:08,000
into disk so you can have

275
00:09:08,000 --> 00:09:10,800
a full report

276
00:09:12,000 --> 00:09:14,560
alright so what next i will now give the

277
00:09:14,560 --> 00:09:16,800
floor to felipe which will show the main

278
00:09:16,800 --> 00:09:20,719
discovery we did about drydex

279
00:09:20,800 --> 00:09:23,120
after understanding drydex we would like

280
00:09:23,120 --> 00:09:25,279
to cover one more drydex feature

281
00:09:25,279 --> 00:09:29,360
dynamic api call resolution

282
00:09:29,519 --> 00:09:31,440
but first to understand it let's

283
00:09:31,440 --> 00:09:33,519
consider the default way programs make

284
00:09:33,519 --> 00:09:36,080
api calls let's say in the program you

285
00:09:36,080 --> 00:09:37,760
are developing you want to generate

286
00:09:37,760 --> 00:09:40,080
a message box in this case you would

287
00:09:40,080 --> 00:09:42,080
import the windows library and call the

288
00:09:42,080 --> 00:09:43,920
messagebox function

289
00:09:43,920 --> 00:09:45,920
in the compiled program this translates

290
00:09:45,920 --> 00:09:47,360
to an entry on the pe

291
00:09:47,360 --> 00:09:50,160
imports directory table referencing the

292
00:09:50,160 --> 00:09:51,279
dynamic library

293
00:09:51,279 --> 00:09:53,040
and a lookup table containing all the

294
00:09:53,040 --> 00:09:55,200
functions available when the execution

295
00:09:55,200 --> 00:09:56,000
starts

296
00:09:56,000 --> 00:09:58,160
the operation system will allocate to

297
00:09:58,160 --> 00:09:59,440
the library in the memory

298
00:09:59,440 --> 00:10:01,440
if it's not already there and will

299
00:10:01,440 --> 00:10:03,360
provide the address so the binary can

300
00:10:03,360 --> 00:10:05,519
execute the api calls

301
00:10:05,519 --> 00:10:08,240
in a similar way one can build dlls with

302
00:10:08,240 --> 00:10:10,399
functions it would like to contribute as

303
00:10:10,399 --> 00:10:11,440
a library

304
00:10:11,440 --> 00:10:14,000
or equipped outside the main executable

305
00:10:14,000 --> 00:10:16,000
in that case the binary will contain an

306
00:10:16,000 --> 00:10:17,200
export table

307
00:10:17,200 --> 00:10:18,880
addressing the function names and its

308
00:10:18,880 --> 00:10:22,399
addresses inside the binary

309
00:10:23,200 --> 00:10:25,440
let's get a little more deep into that i

310
00:10:25,440 --> 00:10:27,120
promise this will be important

311
00:10:27,120 --> 00:10:29,200
in the windows nt operational system

312
00:10:29,200 --> 00:10:31,519
family we have what is called a process

313
00:10:31,519 --> 00:10:32,160
environment

314
00:10:32,160 --> 00:10:34,560
block this is a structure heavily used

315
00:10:34,560 --> 00:10:35,760
by the so

316
00:10:35,760 --> 00:10:38,000
we can find references into the pad in

317
00:10:38,000 --> 00:10:40,079
the windows internals documentation

318
00:10:40,079 --> 00:10:41,680
but a lot of the fields are not

319
00:10:41,680 --> 00:10:43,120
documented at all

320
00:10:43,120 --> 00:10:45,120
as they should only be manipulated by

321
00:10:45,120 --> 00:10:46,720
this operational system during the

322
00:10:46,720 --> 00:10:48,480
binary load and execution

323
00:10:48,480 --> 00:10:50,480
every process has its own process

324
00:10:50,480 --> 00:10:51,600
environment block

325
00:10:51,600 --> 00:10:53,360
and in one of its fields we have a

326
00:10:53,360 --> 00:10:55,839
pointer to the ldr data structure

327
00:10:55,839 --> 00:10:58,160
which holds the list used to store all

328
00:10:58,160 --> 00:11:00,560
the dialogs loaded in the process

329
00:11:00,560 --> 00:11:03,040
it contains among other things the dll

330
00:11:03,040 --> 00:11:05,040
name and the basic address pointing

331
00:11:05,040 --> 00:11:07,040
to where it's stored in the memory so

332
00:11:07,040 --> 00:11:08,800
when you code an api call in your

333
00:11:08,800 --> 00:11:09,440
program

334
00:11:09,440 --> 00:11:13,040
that's what happens as one can imagine

335
00:11:13,040 --> 00:11:15,200
analyzing a binary import stable can

336
00:11:15,200 --> 00:11:17,120
provide a lot of information on its

337
00:11:17,120 --> 00:11:17,760
usage

338
00:11:17,760 --> 00:11:19,519
and can even use it to identify

339
00:11:19,519 --> 00:11:21,519
potential malicious behavior

340
00:11:21,519 --> 00:11:24,079
that's why as an nt analysis technique

341
00:11:24,079 --> 00:11:26,240
somehower employs strategies to hide

342
00:11:26,240 --> 00:11:27,279
their imports

343
00:11:27,279 --> 00:11:29,600
some uses windows functions like load

344
00:11:29,600 --> 00:11:30,399
library

345
00:11:30,399 --> 00:11:33,120
to load dll inside the code but for

346
00:11:33,120 --> 00:11:33,519
those

347
00:11:33,519 --> 00:11:36,640
that use this feature alone we can find

348
00:11:36,640 --> 00:11:38,720
the loaded dlls and the executed

349
00:11:38,720 --> 00:11:39,279
function

350
00:11:39,279 --> 00:11:41,920
just by extracting the malware strings

351
00:11:41,920 --> 00:11:44,160
in the left here we can see the imports

352
00:11:44,160 --> 00:11:46,880
table of a malware that loads the hd api

353
00:11:46,880 --> 00:11:48,240
to retrieve the allow

354
00:11:48,240 --> 00:11:49,839
this contains functions regarding

355
00:11:49,839 --> 00:11:51,519
registry manipulation

356
00:11:51,519 --> 00:11:53,760
so as an analyst i know i need to

357
00:11:53,760 --> 00:11:55,519
monitor the registries to see

358
00:11:55,519 --> 00:11:58,160
if the malware is loading or reading or

359
00:11:58,160 --> 00:12:00,240
storing anything there

360
00:12:00,240 --> 00:12:02,560
on the right we have a couple of samples

361
00:12:02,560 --> 00:12:04,160
from the drydex loader

362
00:12:04,160 --> 00:12:06,240
the top one being the m packet sample

363
00:12:06,240 --> 00:12:07,760
and the bottom one being the packet

364
00:12:07,760 --> 00:12:08,240
sample

365
00:12:08,240 --> 00:12:09,920
we can see that it doesn't reveal

366
00:12:09,920 --> 00:12:11,440
anything relevant on the malware

367
00:12:11,440 --> 00:12:14,079
capabilities

368
00:12:22,079 --> 00:12:24,800
if drydex api calls are not available in

369
00:12:24,800 --> 00:12:26,800
the binary and extracting the mower

370
00:12:26,800 --> 00:12:28,079
strings we can't find

371
00:12:28,079 --> 00:12:30,399
any references to them either how does

372
00:12:30,399 --> 00:12:31,600
it call them

373
00:12:31,600 --> 00:12:33,839
reverse engineering the binary we found

374
00:12:33,839 --> 00:12:36,079
that the malware executes windows api

375
00:12:36,079 --> 00:12:38,399
calls just like that instead of calling

376
00:12:38,399 --> 00:12:40,560
a function imported from a library it

377
00:12:40,560 --> 00:12:40,959
calls

378
00:12:40,959 --> 00:12:42,800
this function that we name it the

379
00:12:42,800 --> 00:12:44,720
malware ati resolver

380
00:12:44,720 --> 00:12:46,320
this function receives a couple

381
00:12:46,320 --> 00:12:50,800
arguments both crc32 hashes

382
00:12:51,440 --> 00:12:53,279
now the malware access the process

383
00:12:53,279 --> 00:12:54,800
environment block table

384
00:12:54,800 --> 00:12:57,360
and run these functions on each dll name

385
00:12:57,360 --> 00:12:59,600
generating a crc32

386
00:12:59,600 --> 00:13:02,399
if the crc32 matches the one passet as

387
00:13:02,399 --> 00:13:03,279
an argument

388
00:13:03,279 --> 00:13:05,200
it repeats the same with the library

389
00:13:05,200 --> 00:13:06,560
functions and voila

390
00:13:06,560 --> 00:13:09,120
it resolved the api call it just returns

391
00:13:09,120 --> 00:13:10,800
the function address to the program so

392
00:13:10,800 --> 00:13:13,839
the execution can continue

393
00:13:13,839 --> 00:13:16,480
now what happens when a dll is not found

394
00:13:16,480 --> 00:13:18,240
in the process environment block

395
00:13:18,240 --> 00:13:20,000
in other words what happens when the

396
00:13:20,000 --> 00:13:21,680
operational system haven't loaded that

397
00:13:21,680 --> 00:13:23,279
dll in the process yet

398
00:13:23,279 --> 00:13:25,839
well the malware loads it itself it will

399
00:13:25,839 --> 00:13:27,600
search the system directory

400
00:13:27,600 --> 00:13:29,680
and make the same process with the dll

401
00:13:29,680 --> 00:13:31,959
names until it find one that matches the

402
00:13:31,959 --> 00:13:33,360
crc32

403
00:13:33,360 --> 00:13:35,279
and it will load it into the memory

404
00:13:35,279 --> 00:13:36,720
using the

405
00:13:36,720 --> 00:13:41,040
ntdll ldr load dll method

406
00:13:41,040 --> 00:13:43,199
for analysts interested in analyzing

407
00:13:43,199 --> 00:13:45,360
dridex in our github we also

408
00:13:45,360 --> 00:13:48,079
uploaded a 9d script you just need to

409
00:13:48,079 --> 00:13:50,320
add the malware api resolver offset

410
00:13:50,320 --> 00:13:52,240
and it will comment in the decompiler

411
00:13:52,240 --> 00:13:54,160
every code with the real dll

412
00:13:54,160 --> 00:13:55,760
and function the mower is trying to

413
00:13:55,760 --> 00:13:58,160
execute summarizing

414
00:13:58,160 --> 00:14:01,199
that's how drydex hides its api calls

415
00:14:01,199 --> 00:14:03,199
it will first check on a table that

416
00:14:03,199 --> 00:14:04,480
builds in memory

417
00:14:04,480 --> 00:14:06,480
for the api hash passed it as an

418
00:14:06,480 --> 00:14:08,800
argument if not found it will check the

419
00:14:08,800 --> 00:14:10,880
process environment block for the loaded

420
00:14:10,880 --> 00:14:13,120
dll to populate the same table

421
00:14:13,120 --> 00:14:15,279
if it's still not found it will search

422
00:14:15,279 --> 00:14:17,360
the system directory for the dll

423
00:14:17,360 --> 00:14:19,440
by the file name should then load it on

424
00:14:19,440 --> 00:14:21,760
the same table and populate it

425
00:14:21,760 --> 00:14:23,839
now let's go to the interesting part we

426
00:14:23,839 --> 00:14:25,600
left this functionality to present

427
00:14:25,600 --> 00:14:27,519
last as this is the one that we will

428
00:14:27,519 --> 00:14:30,399
exploit to create a vaccine for drydex

429
00:14:30,399 --> 00:14:32,320
as some of you may have noticed it the

430
00:14:32,320 --> 00:14:34,480
malware does not have a way to validate

431
00:14:34,480 --> 00:14:37,120
exactly what dll is loaded on its memory

432
00:14:37,120 --> 00:14:38,959
the only verification it have is the

433
00:14:38,959 --> 00:14:40,560
calculated hash

434
00:14:40,560 --> 00:14:42,480
from the previous diagram we can see how

435
00:14:42,480 --> 00:14:43,600
the malware behaves

436
00:14:43,600 --> 00:14:46,399
loading a dll from the disk simplifying

437
00:14:46,399 --> 00:14:48,720
it will call the malware api resolve

438
00:14:48,720 --> 00:14:52,079
search the dll in the csvo64 directory

439
00:14:52,079 --> 00:14:53,120
in our case

440
00:14:53,120 --> 00:14:55,440
loads the dll that matches the condition

441
00:14:55,440 --> 00:14:59,839
and executes the exported function

442
00:15:05,079 --> 00:15:08,639
crc32 is a very small hash using only 32

443
00:15:08,639 --> 00:15:09,279
bits

444
00:15:09,279 --> 00:15:11,680
it's very prone to hash collisions so

445
00:15:11,680 --> 00:15:13,519
what we're going to do is to create

446
00:15:13,519 --> 00:15:15,680
another dll with a different name

447
00:15:15,680 --> 00:15:17,680
with the same hash so when the mower

448
00:15:17,680 --> 00:15:19,839
tries to load the system dll it will

449
00:15:19,839 --> 00:15:21,360
load hours instead

450
00:15:21,360 --> 00:15:23,120
and when it tries to execute any

451
00:15:23,120 --> 00:15:25,519
function on it our vaccine code will be

452
00:15:25,519 --> 00:15:26,320
triggered

453
00:15:26,320 --> 00:15:28,800
we can use that to sabotage drudex

454
00:15:28,800 --> 00:15:30,240
stopping the process or

455
00:15:30,240 --> 00:15:33,600
generating an alert adding a breakpoint

456
00:15:33,600 --> 00:15:35,680
to the function that loads dll from the

457
00:15:35,680 --> 00:15:36,160
disk

458
00:15:36,160 --> 00:15:38,399
we can see that the first one loaded in

459
00:15:38,399 --> 00:15:40,880
this sample is the sheltery two dialogue

460
00:15:40,880 --> 00:15:42,800
now that we have a candidate for our

461
00:15:42,800 --> 00:15:45,040
collision we can just brute force a

462
00:15:45,040 --> 00:15:47,199
bunch of strings to generate compatible

463
00:15:47,199 --> 00:15:47,839
names

464
00:15:47,839 --> 00:15:50,160
let's just not forget it will be a dll

465
00:15:50,160 --> 00:15:52,560
so it needs to end on dot dll

466
00:15:52,560 --> 00:15:54,079
and that the brute force name is

467
00:15:54,079 --> 00:15:56,000
compared in upper case

468
00:15:56,000 --> 00:15:57,920
we won't show how to build a brute force

469
00:15:57,920 --> 00:15:59,839
script for this as you can just

470
00:15:59,839 --> 00:16:01,920
iterate through hex decimal characters

471
00:16:01,920 --> 00:16:03,279
and test one by one

472
00:16:03,279 --> 00:16:06,839
it's that easy to create a crc32

473
00:16:06,839 --> 00:16:09,839
collision

474
00:16:12,079 --> 00:16:14,160
now with the name of our candidates we

475
00:16:14,160 --> 00:16:16,480
will build a simple dll to generate an

476
00:16:16,480 --> 00:16:17,040
alert

477
00:16:17,040 --> 00:16:19,519
pausing the thread and then it will exit

478
00:16:19,519 --> 00:16:20,560
the process

479
00:16:20,560 --> 00:16:23,360
effectively stopping the malware our dll

480
00:16:23,360 --> 00:16:25,759
needs to have the same export as shelter

481
00:16:25,759 --> 00:16:26,880
e2dl

482
00:16:26,880 --> 00:16:29,360
so let's add the same api names to the

483
00:16:29,360 --> 00:16:30,480
exports.dev

484
00:16:30,480 --> 00:16:33,440
file now with the compiled dll we just

485
00:16:33,440 --> 00:16:35,279
need to edit on the same directory

486
00:16:35,279 --> 00:16:37,120
dradex will look for the dlls

487
00:16:37,120 --> 00:16:40,399
in our case the cisvo 64 directory

488
00:16:40,399 --> 00:16:42,720
as we can see in the same step as before

489
00:16:42,720 --> 00:16:45,279
when we detected sheltery2.tll being

490
00:16:45,279 --> 00:16:46,000
loaded

491
00:16:46,000 --> 00:16:47,759
now the malware is loading our

492
00:16:47,759 --> 00:16:49,199
custom-made dll

493
00:16:49,199 --> 00:16:51,519
let's execute dradex on a vaccinated

494
00:16:51,519 --> 00:16:54,959
environment to see what happens

495
00:16:59,519 --> 00:17:01,759
so here we have our custom-made dll and

496
00:17:01,759 --> 00:17:02,959
the drydex loader

497
00:17:02,959 --> 00:17:06,000
we will open the sysvol 64 directory

498
00:17:06,000 --> 00:17:08,720
drop the dll there and execute the

499
00:17:08,720 --> 00:17:10,959
malware to see how it behaves

500
00:17:10,959 --> 00:17:13,439
so right after its execution it will

501
00:17:13,439 --> 00:17:14,079
show or

502
00:17:14,079 --> 00:17:16,880
alert and after clicking ok the process

503
00:17:16,880 --> 00:17:19,119
will exit effectively stopping the

504
00:17:19,119 --> 00:17:22,239
drydex infection

505
00:17:24,480 --> 00:17:26,400
and voila we are protected against

506
00:17:26,400 --> 00:17:28,720
drydex at least from the sample

507
00:17:28,720 --> 00:17:30,640
we showed here a very simple vaccine

508
00:17:30,640 --> 00:17:33,280
implant that only exits the process

509
00:17:33,280 --> 00:17:35,440
but one might modify our hook stub to

510
00:17:35,440 --> 00:17:36,799
add more functionality

511
00:17:36,799 --> 00:17:38,480
you can create a memory dump of the

512
00:17:38,480 --> 00:17:40,320
process before stopping it

513
00:17:40,320 --> 00:17:43,200
or even signaling the company endpoint

514
00:17:43,200 --> 00:17:44,840
alerting that the system might be

515
00:17:44,840 --> 00:17:46,480
compromised

516
00:17:46,480 --> 00:17:48,160
now let's keep in mind that this is not

517
00:17:48,160 --> 00:17:50,080
a silver bullet against rydex

518
00:17:50,080 --> 00:17:52,400
new versions can employ different dlls

519
00:17:52,400 --> 00:17:54,320
or a shelter into the allow might be a

520
00:17:54,320 --> 00:17:55,280
reading memory

521
00:17:55,280 --> 00:17:57,200
but this process can be replicated for

522
00:17:57,200 --> 00:17:59,120
any dll drydex loads

523
00:17:59,120 --> 00:18:01,120
so if the technique remains the same you

524
00:18:01,120 --> 00:18:02,799
just need to map new candidates and

525
00:18:02,799 --> 00:18:05,918
build your own vaccine

526
00:18:09,039 --> 00:18:11,120
it seems a bit odd to build a vaccine

527
00:18:11,120 --> 00:18:12,559
for one strain of malware

528
00:18:12,559 --> 00:18:14,640
but let's consider a scenario where one

529
00:18:14,640 --> 00:18:16,320
of your clients was infected and you

530
00:18:16,320 --> 00:18:18,080
found the druidic sample in one of the

531
00:18:18,080 --> 00:18:18,880
machines

532
00:18:18,880 --> 00:18:20,559
you could then deploy the vaccine as

533
00:18:20,559 --> 00:18:22,400
part of your incident response

534
00:18:22,400 --> 00:18:24,320
helping in the containment phase

535
00:18:24,320 --> 00:18:26,240
stopping the infection from spreading to

536
00:18:26,240 --> 00:18:26,960
others

537
00:18:26,960 --> 00:18:28,960
and in the remediation phase avoiding

538
00:18:28,960 --> 00:18:30,720
ring faction of the machine you just

539
00:18:30,720 --> 00:18:31,360
found

540
00:18:31,360 --> 00:18:33,440
you can also use that to detect other

541
00:18:33,440 --> 00:18:35,440
machines infected with the mower

542
00:18:35,440 --> 00:18:37,360
as the next time the mower will load it

543
00:18:37,360 --> 00:18:39,520
will load the vaccine instead

544
00:18:39,520 --> 00:18:41,200
building the vaccines is not a

545
00:18:41,200 --> 00:18:43,600
replacement for any security solution

546
00:18:43,600 --> 00:18:45,360
but it can be very useful on

547
00:18:45,360 --> 00:18:47,360
investigating or protecting against a

548
00:18:47,360 --> 00:18:50,159
specific threat

549
00:18:51,440 --> 00:18:53,600
all right thank you very much felipe

550
00:18:53,600 --> 00:18:55,520
here are some of the references and the

551
00:18:55,520 --> 00:18:57,360
resources that we use it across our

552
00:18:57,360 --> 00:18:59,360
research in case anyone needs

553
00:18:59,360 --> 00:19:02,559
further details and that was pretty much

554
00:19:02,559 --> 00:19:04,320
it thank you very much for attending the

555
00:19:04,320 --> 00:19:04,799
talk

556
00:19:04,799 --> 00:19:07,280
and this is the end at least until

557
00:19:07,280 --> 00:19:09,280
drydex updates your new version right so

558
00:19:09,280 --> 00:19:10,799
thank you very much

559
00:19:10,799 --> 00:19:18,400
thank you very much everyone

