1
00:00:00,299 --> 00:00:03,299
foreign

2
00:00:07,400 --> 00:00:10,740
so I I came up with the talk title a

3
00:00:10,740 --> 00:00:13,200
while ago because I was um writing some

4
00:00:13,200 --> 00:00:15,360
programmable logic in my basement as we

5
00:00:15,360 --> 00:00:16,260
do

6
00:00:16,260 --> 00:00:18,060
um and found some new vulnerabilities so

7
00:00:18,060 --> 00:00:20,039
this is a shout out to Joe slovick and

8
00:00:20,039 --> 00:00:22,619
maybe a diss on all of us here but I am

9
00:00:22,619 --> 00:00:23,939
going to be talking about a couple of

10
00:00:23,939 --> 00:00:26,760
vulnerabilities in some widely used PLC

11
00:00:26,760 --> 00:00:29,400
Frameworks used for running programmable

12
00:00:29,400 --> 00:00:32,940
logic so the story so far as far as

13
00:00:32,940 --> 00:00:34,860
programmable logic is concerned is we

14
00:00:34,860 --> 00:00:37,380
really have two classes of logic we have

15
00:00:37,380 --> 00:00:39,899
emulated and interpreted logic and we

16
00:00:39,899 --> 00:00:42,000
have compiled logic and this is like you

17
00:00:42,000 --> 00:00:43,620
fire up this engineering workstation

18
00:00:43,620 --> 00:00:46,260
software you write your logic your

19
00:00:46,260 --> 00:00:48,180
control logic in one of the languages

20
00:00:48,180 --> 00:00:51,360
that's defined in 61131 and under the

21
00:00:51,360 --> 00:00:53,219
sea or under the hood behind the scenes

22
00:00:53,219 --> 00:00:56,579
one of these two classes of of output is

23
00:00:56,579 --> 00:00:58,440
being emitted by your compiler and

24
00:00:58,440 --> 00:01:00,420
loaded into the actual controller there

25
00:01:00,420 --> 00:01:02,940
was a really great talk on emulated and

26
00:01:02,940 --> 00:01:06,299
interpreted hacking last year given by

27
00:01:06,299 --> 00:01:08,520
Shoreline brisnoff at Clarity I would

28
00:01:08,520 --> 00:01:09,840
definitely recommend checking that out

29
00:01:09,840 --> 00:01:13,320
on the S4 22 feed he went after Siemens

30
00:01:13,320 --> 00:01:16,020
super tech relays it's not a contest but

31
00:01:16,020 --> 00:01:17,760
I think that that was probably more

32
00:01:17,760 --> 00:01:19,200
technically challenging than what I'm

33
00:01:19,200 --> 00:01:22,020
going to show today but so go check that

34
00:01:22,020 --> 00:01:25,080
out if you can but the story so far or

35
00:01:25,080 --> 00:01:27,060
or why do we keep looking at these run

36
00:01:27,060 --> 00:01:28,140
times so I'm actually going to be

37
00:01:28,140 --> 00:01:30,560
looking at two really common run times

38
00:01:30,560 --> 00:01:33,360
there's this code assist which is a

39
00:01:33,360 --> 00:01:35,159
third-party logic runtime that like

40
00:01:35,159 --> 00:01:36,420
three or four hundred different

41
00:01:36,420 --> 00:01:38,460
industrial manufacturers run on their

42
00:01:38,460 --> 00:01:40,380
plcs and then there's this other one

43
00:01:40,380 --> 00:01:43,560
called proconos and these have kind of

44
00:01:43,560 --> 00:01:45,420
come up in the news again over the last

45
00:01:45,420 --> 00:01:48,060
year code assist because there was a

46
00:01:48,060 --> 00:01:49,380
suite of attack tools that were

47
00:01:49,380 --> 00:01:51,720
uncovered they were covered by Drago

48
00:01:51,720 --> 00:01:53,159
says pipedream and they were covered by

49
00:01:53,159 --> 00:01:54,899
mandiant under the name in controller

50
00:01:54,899 --> 00:01:57,119
and one of that Suite of attack tools

51
00:01:57,119 --> 00:01:59,820
goes after Schneider Electric plc's but

52
00:01:59,820 --> 00:02:01,799
really it's going after the code assist

53
00:02:01,799 --> 00:02:03,600
runtime which happens to be the thing

54
00:02:03,600 --> 00:02:04,920
that runs under the hood on the

55
00:02:04,920 --> 00:02:08,098
Schneider Electric plcs and also in 2022

56
00:02:08,098 --> 00:02:10,679
there was a research paper by vidir Labs

57
00:02:10,679 --> 00:02:12,360
called OT icefall I'm sure we're all

58
00:02:12,360 --> 00:02:14,400
familiar with this they showed another

59
00:02:14,400 --> 00:02:16,560
procono remote code execution

60
00:02:16,560 --> 00:02:18,360
vulnerability so I was like well let's

61
00:02:18,360 --> 00:02:19,980
take a look at these run times again and

62
00:02:19,980 --> 00:02:22,020
see like what else is lurking under the

63
00:02:22,020 --> 00:02:23,879
scenes so we have talked about this

64
00:02:23,879 --> 00:02:25,500
stuff in the past we actually covered

65
00:02:25,500 --> 00:02:28,200
codis's version 2 as part of project

66
00:02:28,200 --> 00:02:30,180
base camp and we looked at version three

67
00:02:30,180 --> 00:02:32,099
we've looked at proconos a couple of

68
00:02:32,099 --> 00:02:33,420
different people have looked at these

69
00:02:33,420 --> 00:02:35,520
these runtimes before but really in

70
00:02:35,520 --> 00:02:37,319
principle they're like the same thing I

71
00:02:37,319 --> 00:02:38,879
almost like I get confused about which

72
00:02:38,879 --> 00:02:40,319
one I'm even looking at sometimes

73
00:02:40,319 --> 00:02:42,959
because these engineering workstations

74
00:02:42,959 --> 00:02:45,500
software applications look very similar

75
00:02:45,500 --> 00:02:48,959
under the hood they are just compiling a

76
00:02:48,959 --> 00:02:51,300
binary file I like to think of it as a

77
00:02:51,300 --> 00:02:52,980
shared library and I'll come back to

78
00:02:52,980 --> 00:02:55,680
that point later on in the talk but they

79
00:02:55,680 --> 00:02:57,900
you know they admit this this file which

80
00:02:57,900 --> 00:02:59,760
then gets loaded onto the controller and

81
00:02:59,760 --> 00:03:01,920
executed and the file basically says you

82
00:03:01,920 --> 00:03:04,620
know read input zero compare it to this

83
00:03:04,620 --> 00:03:07,560
value you you know set output one if

84
00:03:07,560 --> 00:03:09,360
input 0 matches this and these other

85
00:03:09,360 --> 00:03:12,540
parameters match so this is kind of the

86
00:03:12,540 --> 00:03:14,340
very incomplete timeline of

87
00:03:14,340 --> 00:03:15,959
vulnerabilities in these two run times

88
00:03:15,959 --> 00:03:18,180
like I said CODIS version 2 was covered

89
00:03:18,180 --> 00:03:20,760
as part of project base camp we looked

90
00:03:20,760 --> 00:03:22,980
at uh or at least I looked at Pro konos

91
00:03:22,980 --> 00:03:26,900
like the Legacy version back in 2014

92
00:03:26,900 --> 00:03:30,180
we did some initial look at version

93
00:03:30,180 --> 00:03:32,040
three but it was pretty Incomplete Back

94
00:03:32,040 --> 00:03:34,739
in 2015 talked about that at defcon's

95
00:03:34,739 --> 00:03:37,080
ICS Village and then things really

96
00:03:37,080 --> 00:03:38,519
started picking up in the last couple of

97
00:03:38,519 --> 00:03:40,920
years Kaspersky Labs published a really

98
00:03:40,920 --> 00:03:43,080
good white paper on code assist version

99
00:03:43,080 --> 00:03:45,239
three it goes into a lot of depth it

100
00:03:45,239 --> 00:03:46,799
does have a lot of redacted material

101
00:03:46,799 --> 00:03:48,780
because they found some of the code

102
00:03:48,780 --> 00:03:50,940
assist developer documents that maybe

103
00:03:50,940 --> 00:03:52,560
they weren't supposed to have access to

104
00:03:52,560 --> 00:03:53,940
but you could actually find these things

105
00:03:53,940 --> 00:03:57,239
on Google that kind of related the

106
00:03:57,239 --> 00:03:59,220
internals of the code assist runtime

107
00:03:59,220 --> 00:04:01,019
that really you would only need to know

108
00:04:01,019 --> 00:04:04,500
if you were a PLC maker Cisco Talos also

109
00:04:04,500 --> 00:04:06,180
had a couple of cool vulnerabilities

110
00:04:06,180 --> 00:04:08,940
back in 2019 covering code assist

111
00:04:08,940 --> 00:04:11,939
version three in 2019 at the CS3

112
00:04:11,939 --> 00:04:14,420
Stockholm conference I showed uh

113
00:04:14,420 --> 00:04:16,738
procono's embedded common language

114
00:04:16,738 --> 00:04:19,139
runtime exploit demonstration which

115
00:04:19,139 --> 00:04:21,120
basically said this other version of

116
00:04:21,120 --> 00:04:23,639
proconos has this vulnerability where I

117
00:04:23,639 --> 00:04:25,680
can execute Shell Code basically on the

118
00:04:25,680 --> 00:04:29,580
PLC and get root access and then in 2022

119
00:04:29,580 --> 00:04:31,199
of course we had the independent tooling

120
00:04:31,199 --> 00:04:33,300
for code assist that was discovered as

121
00:04:33,300 --> 00:04:36,660
well as the vadir labs paper so the big

122
00:04:36,660 --> 00:04:38,820
thing that we've always talked about as

123
00:04:38,820 --> 00:04:41,580
far as this remote code execution is we

124
00:04:41,580 --> 00:04:43,259
talk about root kits or at least I do

125
00:04:43,259 --> 00:04:45,419
and we always say like all right this

126
00:04:45,419 --> 00:04:47,880
logic is running with uh you know ring

127
00:04:47,880 --> 00:04:50,419
zero equivalent privileges on the PLC

128
00:04:50,419 --> 00:04:53,520
and because of that I can tamper with

129
00:04:53,520 --> 00:04:55,380
the firmware you know I have high

130
00:04:55,380 --> 00:04:57,840
Privileges and you know I can start

131
00:04:57,840 --> 00:05:00,120
overwriting the basic functionality of

132
00:05:00,120 --> 00:05:03,060
the PLC and I can maintain access and we

133
00:05:03,060 --> 00:05:04,740
keep using that term rootkit in the end

134
00:05:04,740 --> 00:05:07,440
history and I got to thinking like can

135
00:05:07,440 --> 00:05:10,620
we do any anything to these plcs to kind

136
00:05:10,620 --> 00:05:12,900
of maintain access but without actually

137
00:05:12,900 --> 00:05:14,580
having root privileges right let's

138
00:05:14,580 --> 00:05:16,860
assume you know this logic is actually

139
00:05:16,860 --> 00:05:19,259
running in some kind of confined user

140
00:05:19,259 --> 00:05:22,919
space and go from there and the question

141
00:05:22,919 --> 00:05:24,539
you know is can we have root kits

142
00:05:24,539 --> 00:05:26,520
without roots uh or without root access

143
00:05:26,520 --> 00:05:29,160
this talk exists so I guess we can kind

144
00:05:29,160 --> 00:05:30,360
of guess what the answer is going to be

145
00:05:30,360 --> 00:05:32,460
let's try not to admire it too much but

146
00:05:32,460 --> 00:05:34,380
let's kind of talk through you know how

147
00:05:34,380 --> 00:05:36,780
this all works so let's again let's

148
00:05:36,780 --> 00:05:38,520
let's start with the premise that code

149
00:05:38,520 --> 00:05:40,320
assist and proconos are no longer

150
00:05:40,320 --> 00:05:42,000
running on their plcs with high

151
00:05:42,000 --> 00:05:43,680
privileges that is they are running in

152
00:05:43,680 --> 00:05:45,680
some unprivileged

153
00:05:45,680 --> 00:05:48,360
some sort of like CH root jail where

154
00:05:48,360 --> 00:05:50,699
they don't have access to any of the

155
00:05:50,699 --> 00:05:53,220
base firmware on the PLC so what do we

156
00:05:53,220 --> 00:05:55,919
go after next well this is a block

157
00:05:55,919 --> 00:05:58,199
diagram of the code assist version 3

158
00:05:58,199 --> 00:06:00,060
runtime and this is available from their

159
00:06:00,060 --> 00:06:02,100
user manuals that you can find on the

160
00:06:02,100 --> 00:06:04,080
internet this is like meant to be read

161
00:06:04,080 --> 00:06:07,020
by uh just ho-hum Engineers that are

162
00:06:07,020 --> 00:06:09,060
writing ladder logic it's just a kind of

163
00:06:09,060 --> 00:06:11,759
a description of the runtime and what I

164
00:06:11,759 --> 00:06:13,680
noticed right away is we have all of

165
00:06:13,680 --> 00:06:15,900
these kind of blocks uh you know we have

166
00:06:15,900 --> 00:06:17,699
compartments basically where we say okay

167
00:06:17,699 --> 00:06:20,100
there's all this communication code over

168
00:06:20,100 --> 00:06:21,900
here in this segment we have the actual

169
00:06:21,900 --> 00:06:24,539
user application uh in this segment here

170
00:06:24,539 --> 00:06:27,720
we have the core components uh that you

171
00:06:27,720 --> 00:06:30,539
know provide services that applications

172
00:06:30,539 --> 00:06:32,639
might actually use and then we have

173
00:06:32,639 --> 00:06:34,440
these kind of system components at the

174
00:06:34,440 --> 00:06:36,660
bottom that provide kind of like an

175
00:06:36,660 --> 00:06:38,280
interface between the code assist

176
00:06:38,280 --> 00:06:40,259
runtime and the actual operating system

177
00:06:40,259 --> 00:06:42,600
that the PLC runs so a couple of

178
00:06:42,600 --> 00:06:45,360
observations one they allow you to have

179
00:06:45,360 --> 00:06:47,639
multiple applications running on the PLC

180
00:06:47,639 --> 00:06:50,699
at once and codices version 3 has user

181
00:06:50,699 --> 00:06:52,259
management as well so you can actually

182
00:06:52,259 --> 00:06:54,840
have different users on the systems and

183
00:06:54,840 --> 00:06:56,580
one of the weird things that I got to

184
00:06:56,580 --> 00:06:58,919
thinking about was like all right

185
00:06:58,919 --> 00:07:01,259
say I have two Engineers Alice and Bob

186
00:07:01,259 --> 00:07:03,780
can I define them on the PLC so that

187
00:07:03,780 --> 00:07:07,020
Alice has access to i o points in one

188
00:07:07,020 --> 00:07:09,660
group Bob has access to i o points in a

189
00:07:09,660 --> 00:07:11,400
mutually exclusive group and they

190
00:07:11,400 --> 00:07:13,560
basically are two Engineers sharing one

191
00:07:13,560 --> 00:07:16,199
piece of Hardware where they you know

192
00:07:16,199 --> 00:07:18,840
can't really mess with each other they

193
00:07:18,840 --> 00:07:20,460
can both load their applications on the

194
00:07:20,460 --> 00:07:22,500
PLC and not interfere with each other

195
00:07:22,500 --> 00:07:25,020
and in the engineering software you can

196
00:07:25,020 --> 00:07:28,440
do that but what's the problem is that

197
00:07:28,440 --> 00:07:30,599
applications end up having right access

198
00:07:30,599 --> 00:07:33,060
to almost all of the memory inside of

199
00:07:33,060 --> 00:07:34,380
the runtime it's best to think of the

200
00:07:34,380 --> 00:07:37,280
runtime as like one Big Blob of data

201
00:07:37,280 --> 00:07:41,639
that we can overwrite so when I first

202
00:07:41,639 --> 00:07:43,680
was kind of playing with this idea I was

203
00:07:43,680 --> 00:07:46,319
like all right I see that my project

204
00:07:46,319 --> 00:07:49,380
file gets loaded onto Heap memory I see

205
00:07:49,380 --> 00:07:51,780
that Heap memory is writable can I write

206
00:07:51,780 --> 00:07:53,639
a program that actually modifies itself

207
00:07:53,639 --> 00:07:55,800
that is load the current instruction

208
00:07:55,800 --> 00:07:59,340
pointer into a register dereference it

209
00:07:59,340 --> 00:08:01,319
and then like right back out and kind of

210
00:08:01,319 --> 00:08:02,699
overwrite the instruction that just

211
00:08:02,699 --> 00:08:04,560
executed and it turns out you can do

212
00:08:04,560 --> 00:08:06,720
that and it's really weird because these

213
00:08:06,720 --> 00:08:08,639
runtimes have a debugger that lets you

214
00:08:08,639 --> 00:08:10,440
single step through code and you get

215
00:08:10,440 --> 00:08:12,120
weird Behavior like you know a

216
00:08:12,120 --> 00:08:15,180
comparison is five greater than zero and

217
00:08:15,180 --> 00:08:16,860
it says no it's not you know it follows

218
00:08:16,860 --> 00:08:18,780
the branch of execution that says no

219
00:08:18,780 --> 00:08:22,080
that doesn't equate to true because uh

220
00:08:22,080 --> 00:08:24,720
we've changed the operand for that

221
00:08:24,720 --> 00:08:26,460
actual machine instruction under the

222
00:08:26,460 --> 00:08:28,860
hood and of course that cascaded into a

223
00:08:28,860 --> 00:08:32,520
bigger problem so the proconos eclr used

224
00:08:32,520 --> 00:08:34,559
to have a demo version available that

225
00:08:34,559 --> 00:08:35,880
you could download and that's what I

226
00:08:35,880 --> 00:08:37,380
tested against that's why you're seeing

227
00:08:37,380 --> 00:08:40,020
some Raspberry Pi shells here so they

228
00:08:40,020 --> 00:08:41,760
they used to release this version of the

229
00:08:41,760 --> 00:08:45,300
eclr it was version 2.2 that runs on

230
00:08:45,300 --> 00:08:47,339
Raspberry Pi's and so I'm looking and

231
00:08:47,339 --> 00:08:48,899
I'm like all right I see you know the

232
00:08:48,899 --> 00:08:50,700
Heap is readable writable executable

233
00:08:50,700 --> 00:08:52,080
this actually sort of makes sense

234
00:08:52,080 --> 00:08:53,700
because what they're doing is they're

235
00:08:53,700 --> 00:08:56,339
loading this dll into memory using their

236
00:08:56,339 --> 00:08:57,839
own custom loader and then they're

237
00:08:57,839 --> 00:08:59,880
executing code with it and again you

238
00:08:59,880 --> 00:09:01,260
know this is why I kind of get confused

239
00:09:01,260 --> 00:09:02,820
by these two runtimes they're basically

240
00:09:02,820 --> 00:09:04,680
behaving the exact same way they both

241
00:09:04,680 --> 00:09:06,899
have this Heap memory that behaves the

242
00:09:06,899 --> 00:09:09,480
same way and to kind of compound the

243
00:09:09,480 --> 00:09:11,700
problem here is we have the way of

244
00:09:11,700 --> 00:09:14,160
communicating with the PLC is we have

245
00:09:14,160 --> 00:09:16,380
the engineering workstation is usually

246
00:09:16,380 --> 00:09:19,080
communicating via a proprietary protocol

247
00:09:19,080 --> 00:09:20,640
and this is true of both code assist and

248
00:09:20,640 --> 00:09:21,899
proconos and you're going to find this

249
00:09:21,899 --> 00:09:24,540
in a lot of different plc's where the

250
00:09:24,540 --> 00:09:26,760
engineering workstation communicates via

251
00:09:26,760 --> 00:09:29,160
this protocol with a protocol Handler

252
00:09:29,160 --> 00:09:31,080
that is inside of the logic runtime

253
00:09:31,080 --> 00:09:33,240
container so we're starting to get a

254
00:09:33,240 --> 00:09:35,339
hint of what the big problem is that is

255
00:09:35,339 --> 00:09:38,519
the logic runtime is basically the sole

256
00:09:38,519 --> 00:09:41,120
mechanism of interfacing with the PLC

257
00:09:41,120 --> 00:09:44,339
and the logic runtime has the ability to

258
00:09:44,339 --> 00:09:46,080
have all kinds of data tampered with

259
00:09:46,080 --> 00:09:50,100
from the programmed logic so the the bad

260
00:09:50,100 --> 00:09:51,899
things here to kind of summarize is that

261
00:09:51,899 --> 00:09:53,580
we have logic code running from Heap

262
00:09:53,580 --> 00:09:56,120
Heap is readable writable and executable

263
00:09:56,120 --> 00:10:00,000
the runtime is relying on data we'll go

264
00:10:00,000 --> 00:10:01,620
into some details about this in the next

265
00:10:01,620 --> 00:10:04,560
couple of slides for important data like

266
00:10:04,560 --> 00:10:06,480
these protocol callbacks so basically

267
00:10:06,480 --> 00:10:08,880
when I issue a command to the PLC the

268
00:10:08,880 --> 00:10:10,920
runtime is looking up a function pointer

269
00:10:10,920 --> 00:10:13,740
from the Heap saying all right you know

270
00:10:13,740 --> 00:10:15,420
I've seen this packet I need to call

271
00:10:15,420 --> 00:10:17,760
this function over here but now that

272
00:10:17,760 --> 00:10:18,899
function point there maybe can be

273
00:10:18,899 --> 00:10:21,540
overwritten and one of the ugly things

274
00:10:21,540 --> 00:10:23,580
that I found through like just pure

275
00:10:23,580 --> 00:10:25,200
experimentation was that we can actually

276
00:10:25,200 --> 00:10:28,680
get the runtime to execute portions of

277
00:10:28,680 --> 00:10:31,680
the binary logic file the user provided

278
00:10:31,680 --> 00:10:33,540
potentially malicious binary logic file

279
00:10:33,540 --> 00:10:36,000
before the PLC is ever switched into run

280
00:10:36,000 --> 00:10:39,600
mode and we'll talk about that

281
00:10:39,600 --> 00:10:42,060
so why do I think that these handle or

282
00:10:42,060 --> 00:10:43,980
these runtimes have overrideable

283
00:10:43,980 --> 00:10:46,860
protocol handlers in a word components

284
00:10:46,860 --> 00:10:48,180
and we'll have an example of this for

285
00:10:48,180 --> 00:10:52,019
the procona cclr2 the code assist user

286
00:10:52,019 --> 00:10:54,899
manual specifies to PLC vendors like hey

287
00:10:54,899 --> 00:10:57,959
if you have like a proprietary i o

288
00:10:57,959 --> 00:11:01,380
module or you have some proprietary like

289
00:11:01,380 --> 00:11:03,240
logging Handler that you want to

290
00:11:03,240 --> 00:11:05,579
incorporate into the PLC we have a

291
00:11:05,579 --> 00:11:07,620
method for that you know you can call

292
00:11:07,620 --> 00:11:10,140
this register function which registers

293
00:11:10,140 --> 00:11:13,380
your Handler with uh the the Callback

294
00:11:13,380 --> 00:11:15,839
and basically says your code can now be

295
00:11:15,839 --> 00:11:18,060
executed as a basic part of the

296
00:11:18,060 --> 00:11:20,279
functionality of the PLC so because

297
00:11:20,279 --> 00:11:22,040
you're designing the system that way

298
00:11:22,040 --> 00:11:24,420
that's you know everything is going to

299
00:11:24,420 --> 00:11:26,339
be a module even the base functionality

300
00:11:26,339 --> 00:11:27,779
and in fact you'll find some code assist

301
00:11:27,779 --> 00:11:30,360
plcs that have some of these basic

302
00:11:30,360 --> 00:11:32,459
features kind of removed I remember

303
00:11:32,459 --> 00:11:34,920
looking at like a Hitachi PLC years ago

304
00:11:34,920 --> 00:11:36,959
that runs code assist version three and

305
00:11:36,959 --> 00:11:38,820
it just was missing a lot of components

306
00:11:38,820 --> 00:11:40,500
you know there was like no there's no

307
00:11:40,500 --> 00:11:42,300
command shell component that's really

308
00:11:42,300 --> 00:11:43,980
common on plc's and a bunch of other

309
00:11:43,980 --> 00:11:46,160
like Common Core components

310
00:11:46,160 --> 00:11:49,920
and same thing with procono's eclr they

311
00:11:49,920 --> 00:11:51,600
publish a document and I know the font's

312
00:11:51,600 --> 00:11:52,920
going to be totally unreadable it's a

313
00:11:52,920 --> 00:11:56,100
screenshot of their their PLC next API

314
00:11:56,100 --> 00:11:58,200
documentation which says you know hey

315
00:11:58,200 --> 00:12:02,100
this is uh you know meant to be used and

316
00:12:02,100 --> 00:12:04,019
updated by Third parties that are

317
00:12:04,019 --> 00:12:06,480
designing a PLC and want to use this

318
00:12:06,480 --> 00:12:10,940
eclr into their device

319
00:12:11,220 --> 00:12:12,839
um the really cool thing about doing

320
00:12:12,839 --> 00:12:14,700
this research was looking through code

321
00:12:14,700 --> 00:12:16,920
assist and all of its capabilities so I

322
00:12:16,920 --> 00:12:18,600
mentioned that you know I was messing

323
00:12:18,600 --> 00:12:20,700
around with Heap messing around with

324
00:12:20,700 --> 00:12:22,920
function pointers and you kind of get

325
00:12:22,920 --> 00:12:25,019
sick and tired of handwriting assembler

326
00:12:25,019 --> 00:12:26,399
code when you're doing this because

327
00:12:26,399 --> 00:12:27,959
you're like you know you screw up and

328
00:12:27,959 --> 00:12:30,420
something crashes and you know you have

329
00:12:30,420 --> 00:12:31,920
to figure out all right what did I mess

330
00:12:31,920 --> 00:12:33,959
up oh I moved it into register R2 I

331
00:12:33,959 --> 00:12:35,700
meant to put this into register R3 when

332
00:12:35,700 --> 00:12:37,620
I dereferenced it you know I overwrote

333
00:12:37,620 --> 00:12:39,600
the wrong data and it caused the PLC to

334
00:12:39,600 --> 00:12:42,000
crash on a Raspberry Pi that's not such

335
00:12:42,000 --> 00:12:43,440
a big deal but if you're researching

336
00:12:43,440 --> 00:12:46,019
like a real PLC you might actually cause

337
00:12:46,019 --> 00:12:48,600
irreparable harm that's really bad but

338
00:12:48,600 --> 00:12:50,100
code assist has a couple of cool

339
00:12:50,100 --> 00:12:52,620
features for us one is they actually

340
00:12:52,620 --> 00:12:54,899
have memory pointers which behave just

341
00:12:54,899 --> 00:12:57,000
like C memory pointers via this built-in

342
00:12:57,000 --> 00:12:59,639
ADR function you can literally tell the

343
00:12:59,639 --> 00:13:02,100
codices runtime like give me the address

344
00:13:02,100 --> 00:13:05,160
in memory of a variable and it will put

345
00:13:05,160 --> 00:13:07,320
that into an integer which you can then

346
00:13:07,320 --> 00:13:10,139
use as a pointer for the next really

347
00:13:10,139 --> 00:13:12,420
cool function which is a memory copy

348
00:13:12,420 --> 00:13:15,720
instruction called memove they also have

349
00:13:15,720 --> 00:13:17,880
file system commands in code assist and

350
00:13:17,880 --> 00:13:19,320
I think they may have already released

351
00:13:19,320 --> 00:13:21,779
an update to restrict the file system

352
00:13:21,779 --> 00:13:24,720
commands a little bit but you know the

353
00:13:24,720 --> 00:13:26,459
only thing I found you couldn't do is

354
00:13:26,459 --> 00:13:28,620
directly access CPU registers so you can

355
00:13:28,620 --> 00:13:30,120
get pretty much everything else and so

356
00:13:30,120 --> 00:13:32,279
basically I would write a big block of

357
00:13:32,279 --> 00:13:35,160
code in structured text compile it open

358
00:13:35,160 --> 00:13:37,440
it up and if I had to hand edit one or

359
00:13:37,440 --> 00:13:39,360
two lines of assembler that's fine I can

360
00:13:39,360 --> 00:13:42,300
deal with that and supposedly this ADR

361
00:13:42,300 --> 00:13:43,860
function is kind of a final point it's

362
00:13:43,860 --> 00:13:45,120
supposed to let us actually access

363
00:13:45,120 --> 00:13:46,620
function pointers although I could never

364
00:13:46,620 --> 00:13:48,120
actually get it to work the compiler

365
00:13:48,120 --> 00:13:49,980
would always complain about disparate

366
00:13:49,980 --> 00:13:51,959
types for some reason even if I was like

367
00:13:51,959 --> 00:13:54,180
trying to assign sign a pointer to a

368
00:13:54,180 --> 00:13:56,579
variable it would let me do it but if I

369
00:13:56,579 --> 00:13:58,980
tried to assign the same Val the same

370
00:13:58,980 --> 00:14:01,500
variable as a pointer to a function or a

371
00:14:01,500 --> 00:14:03,480
program it would not I need to look into

372
00:14:03,480 --> 00:14:06,600
that some more so the first thing that I

373
00:14:06,600 --> 00:14:08,519
really wanted to do was to dump process

374
00:14:08,519 --> 00:14:10,380
Heap and if you read the Kaspersky Labs

375
00:14:10,380 --> 00:14:12,779
paper highly recommend it one of the

376
00:14:12,779 --> 00:14:14,339
things they noticed was that the run

377
00:14:14,339 --> 00:14:17,100
time for Raspberry Pi has kind of like

378
00:14:17,100 --> 00:14:19,440
an anti-debugging anti-reverse

379
00:14:19,440 --> 00:14:21,300
engineering technique in it and that

380
00:14:21,300 --> 00:14:24,180
technique is they start the main code

381
00:14:24,180 --> 00:14:25,920
assist process and then they actually

382
00:14:25,920 --> 00:14:29,220
decrypt a sub-process connect that to

383
00:14:29,220 --> 00:14:31,620
that sub process as a debugger and then

384
00:14:31,620 --> 00:14:33,680
that sub process is where all of your

385
00:14:33,680 --> 00:14:36,600
lovely ladder logic is executing and

386
00:14:36,600 --> 00:14:38,399
because they are attached to that sub

387
00:14:38,399 --> 00:14:40,680
process as a debugger you can't attach

388
00:14:40,680 --> 00:14:43,139
to it with a debugger in order to dump

389
00:14:43,139 --> 00:14:45,360
the memory so I did what any silly

390
00:14:45,360 --> 00:14:47,040
person would do and wrote some

391
00:14:47,040 --> 00:14:49,740
structured text program to open the file

392
00:14:49,740 --> 00:14:52,079
slash proc self slash Maps which on

393
00:14:52,079 --> 00:14:54,120
Linux systems has a memory map for the

394
00:14:54,120 --> 00:14:54,920
process

395
00:14:54,920 --> 00:14:58,079
parsed that file looking for the word

396
00:14:58,079 --> 00:15:02,279
Heap and then note the start address and

397
00:15:02,279 --> 00:15:04,440
end address of the Heap memory and dump

398
00:15:04,440 --> 00:15:06,959
it out to a binary file 100 pure

399
00:15:06,959 --> 00:15:10,320
structured text and it is a little

400
00:15:10,320 --> 00:15:11,880
little bit ugly it's kind of a different

401
00:15:11,880 --> 00:15:14,279
way of thinking about program code if

402
00:15:14,279 --> 00:15:16,320
you're used to like writing file I O and

403
00:15:16,320 --> 00:15:18,779
C this is asynchronous meaning like you

404
00:15:18,779 --> 00:15:20,940
issue the file open command and then you

405
00:15:20,940 --> 00:15:23,519
have to pull a status check each each

406
00:15:23,519 --> 00:15:26,399
PLC execution cycle to wait for the file

407
00:15:26,399 --> 00:15:27,959
to actually open and then you issue a

408
00:15:27,959 --> 00:15:29,220
read command and then you have to like

409
00:15:29,220 --> 00:15:31,320
so you have to do this big state mapping

410
00:15:31,320 --> 00:15:33,540
where you have to say what state am I in

411
00:15:33,540 --> 00:15:35,639
what was the last operation that I just

412
00:15:35,639 --> 00:15:38,279
committed to that sort of thing and the

413
00:15:38,279 --> 00:15:39,779
final block of code which again is way

414
00:15:39,779 --> 00:15:41,639
too small for anybody to see I'm

415
00:15:41,639 --> 00:15:43,680
actually overwriting a portion of the

416
00:15:43,680 --> 00:15:45,779
Heap which contains user data so I'm

417
00:15:45,779 --> 00:15:48,899
overwriting a username and password and

418
00:15:48,899 --> 00:15:50,820
the result of overwriting a username and

419
00:15:50,820 --> 00:15:53,100
password is I overwrote my own user ID

420
00:15:53,100 --> 00:15:57,360
and password hash with one Samwise so I

421
00:15:57,360 --> 00:15:59,160
basically you know wrote this ladder

422
00:15:59,160 --> 00:16:01,320
logic I had it execute it dumped all the

423
00:16:01,320 --> 00:16:03,680
Heap memory and then at this particular

424
00:16:03,680 --> 00:16:07,440
relative offset of the Heap memory it

425
00:16:07,440 --> 00:16:09,060
overwrote some data and that actually

426
00:16:09,060 --> 00:16:10,260
gets reflected in the engineer

427
00:16:10,260 --> 00:16:12,959
workstation software pretty cool I

428
00:16:12,959 --> 00:16:14,699
thought all right what what else can I

429
00:16:14,699 --> 00:16:16,620
do with this well I started looking

430
00:16:16,620 --> 00:16:18,540
around what else lives in Heap and this

431
00:16:18,540 --> 00:16:20,100
is where I started realizing that there

432
00:16:20,100 --> 00:16:21,779
are function pointers all over the place

433
00:16:21,779 --> 00:16:24,360
so we can overwrite basic functionality

434
00:16:24,360 --> 00:16:26,760
of the code assist runtime from within

435
00:16:26,760 --> 00:16:29,880
this logic application so here we are

436
00:16:29,880 --> 00:16:31,920
changing the behavior of the PLC shell

437
00:16:31,920 --> 00:16:34,620
to print out some different misspellings

438
00:16:34,620 --> 00:16:37,019
or different English misspellings of

439
00:16:37,019 --> 00:16:39,060
German words but we can actually

440
00:16:39,060 --> 00:16:42,240
overwrite the command handlers for these

441
00:16:42,240 --> 00:16:44,160
two don't recommend it it gets really

442
00:16:44,160 --> 00:16:45,600
ugly really fast and you end up crashing

443
00:16:45,600 --> 00:16:48,000
the PLC a thousand times before you get

444
00:16:48,000 --> 00:16:50,820
things to work and in proconos there was

445
00:16:50,820 --> 00:16:52,800
actually a really just eerily similar

446
00:16:52,800 --> 00:16:56,339
thing so the proconos protocol is like a

447
00:16:56,339 --> 00:16:58,320
lot easier to understand in the sense

448
00:16:58,320 --> 00:17:00,300
that like code assist read the Kaspersky

449
00:17:00,300 --> 00:17:02,639
paper again it is ugly like they have

450
00:17:02,639 --> 00:17:05,280
it's like 18 layers of protocol nested

451
00:17:05,280 --> 00:17:06,599
on top of each other with different

452
00:17:06,599 --> 00:17:09,000
address fields in different ndnises and

453
00:17:09,000 --> 00:17:11,699
different layers uh gets ugly quick the

454
00:17:11,699 --> 00:17:13,619
proconus one at least at first glance is

455
00:17:13,619 --> 00:17:16,140
very easy to understand because they

456
00:17:16,140 --> 00:17:18,000
have a lot of ASCII strings so when they

457
00:17:18,000 --> 00:17:20,099
do a procedure call for example if the

458
00:17:20,099 --> 00:17:22,260
engineering workstation wants to tell

459
00:17:22,260 --> 00:17:24,959
the PLC to start or stop there's a nice

460
00:17:24,959 --> 00:17:27,179
ASCII string that says ipro konos

461
00:17:27,179 --> 00:17:28,919
control service and then it has an

462
00:17:28,919 --> 00:17:31,220
argument that means either start or stop

463
00:17:31,220 --> 00:17:34,140
and the cool thing about this is that

464
00:17:34,140 --> 00:17:36,480
you can find in proconus's Heap memory

465
00:17:36,480 --> 00:17:39,179
where this function table lives so

466
00:17:39,179 --> 00:17:41,039
there's a table that has it's basically

467
00:17:41,039 --> 00:17:43,919
a linked list it says here is a pointer

468
00:17:43,919 --> 00:17:47,220
to the string for the command here is a

469
00:17:47,220 --> 00:17:48,780
pointer to the function for the command

470
00:17:48,780 --> 00:17:50,700
Handler and here is a pointer to the

471
00:17:50,700 --> 00:17:52,440
next thing in the linked list again it's

472
00:17:52,440 --> 00:17:54,660
meant to be extensible for a PLC maker

473
00:17:54,660 --> 00:17:58,140
to add some of their own functions so we

474
00:17:58,140 --> 00:18:00,059
can actually figure out exactly where

475
00:18:00,059 --> 00:18:01,799
these pointers are going to live in

476
00:18:01,799 --> 00:18:04,500
memory by just okay we have our we have

477
00:18:04,500 --> 00:18:07,440
our program counter we know that the the

478
00:18:07,440 --> 00:18:09,360
this function pointer table lives in

479
00:18:09,360 --> 00:18:11,280
memory at the the current program

480
00:18:11,280 --> 00:18:14,220
counter plus some offset and then we can

481
00:18:14,220 --> 00:18:15,919
start overwriting pointers

482
00:18:15,919 --> 00:18:19,020
and what one of the weird things about

483
00:18:19,020 --> 00:18:21,539
this so This actually does work and I

484
00:18:21,539 --> 00:18:22,980
did share a proof of concept with the

485
00:18:22,980 --> 00:18:25,740
vendor it took a while but they finally

486
00:18:25,740 --> 00:18:29,160
were willing to accept that the really

487
00:18:29,160 --> 00:18:30,660
weird thing that I had mentioned before

488
00:18:30,660 --> 00:18:32,480
was about

489
00:18:32,480 --> 00:18:35,039
initialization so you're like all right

490
00:18:35,039 --> 00:18:37,740
cool you can write this function and uh

491
00:18:37,740 --> 00:18:40,380
it's part of your kind of main PLC block

492
00:18:40,380 --> 00:18:43,020
that means it gets executed when the PLC

493
00:18:43,020 --> 00:18:45,539
is in run mode how can I execute code

494
00:18:45,539 --> 00:18:47,880
before the PLC is in run mode and I kind

495
00:18:47,880 --> 00:18:49,620
of stumbled Upon This by accident just

496
00:18:49,620 --> 00:18:51,480
by messing around and I was like well

497
00:18:51,480 --> 00:18:53,640
all right I'm you know my my first

498
00:18:53,640 --> 00:18:55,200
ladder logic program just to get

499
00:18:55,200 --> 00:18:56,280
familiar with the engineering

500
00:18:56,280 --> 00:18:58,320
workstation I say all right I'm going to

501
00:18:58,320 --> 00:19:00,720
create this variable and one of the nice

502
00:19:00,720 --> 00:19:02,520
things is we can give the variable an

503
00:19:02,520 --> 00:19:04,559
initial value so in this case I have a

504
00:19:04,559 --> 00:19:07,799
dragos VAR which is a string my main

505
00:19:07,799 --> 00:19:10,080
function is going to write the string

506
00:19:10,080 --> 00:19:12,539
hello variable contents into the string

507
00:19:12,539 --> 00:19:15,000
data but the initial value we'll say

508
00:19:15,000 --> 00:19:18,240
dragos was here and what I was curious

509
00:19:18,240 --> 00:19:20,280
about was to see if there is a different

510
00:19:20,280 --> 00:19:22,799
init block of code from the main block

511
00:19:22,799 --> 00:19:25,020
of code and to see like where those are

512
00:19:25,020 --> 00:19:27,840
laid out in the file and what I found

513
00:19:27,840 --> 00:19:29,880
was as soon as I transferred this file

514
00:19:29,880 --> 00:19:33,539
to the PLC the initialization value was

515
00:19:33,539 --> 00:19:36,179
set in the variable and that was kind of

516
00:19:36,179 --> 00:19:38,039
unexpected because I'm like well I

517
00:19:38,039 --> 00:19:40,200
transferred this file to the PLC the PLC

518
00:19:40,200 --> 00:19:42,360
is still in stop mode I haven't told it

519
00:19:42,360 --> 00:19:43,919
to execute anything yet and yet it

520
00:19:43,919 --> 00:19:45,960
executed it so I remember earlier I was

521
00:19:45,960 --> 00:19:47,400
talking about how I like to think of

522
00:19:47,400 --> 00:19:49,860
these things as dlls well this is kind

523
00:19:49,860 --> 00:19:52,919
of like the dll main I guess and what it

524
00:19:52,919 --> 00:19:55,020
is is it's setting up all of the

525
00:19:55,020 --> 00:19:57,360
variables sorry there's assembler we

526
00:19:57,360 --> 00:19:59,600
have to have that to teach two

527
00:19:59,600 --> 00:20:02,220
it's basically like a function that gets

528
00:20:02,220 --> 00:20:04,860
executed as soon as this binary file

529
00:20:04,860 --> 00:20:07,559
gets loaded by the runtime so it gets

530
00:20:07,559 --> 00:20:09,780
kind of ugly and this is where it gets

531
00:20:09,780 --> 00:20:10,500
really

532
00:20:10,500 --> 00:20:12,840
ugly is that you know if I load

533
00:20:12,840 --> 00:20:14,880
something on the PLC which hooks the

534
00:20:14,880 --> 00:20:17,820
base functionality of the PLC it may be

535
00:20:17,820 --> 00:20:20,580
impossible to remove because I can have

536
00:20:20,580 --> 00:20:23,580
a malicious program a ladder logic

537
00:20:23,580 --> 00:20:25,980
program that is which gets loaded which

538
00:20:25,980 --> 00:20:28,799
overwrites the actual like file receive

539
00:20:28,799 --> 00:20:30,720
Handler for the PLC as well as the

540
00:20:30,720 --> 00:20:34,140
factory reset for the PLC and says all

541
00:20:34,140 --> 00:20:35,760
right I'm going to accept this new

542
00:20:35,760 --> 00:20:37,620
program from the engineer but I'm going

543
00:20:37,620 --> 00:20:39,960
to reinsert the backdoor code into this

544
00:20:39,960 --> 00:20:42,240
new program because I'm a big logic

545
00:20:42,240 --> 00:20:43,980
thing that has a whole bunch of code in

546
00:20:43,980 --> 00:20:44,940
it that I really don't feel like

547
00:20:44,940 --> 00:20:46,919
handwriting by assembly or an assembler

548
00:20:46,919 --> 00:20:50,760
but in theory any way I can do it so you

549
00:20:50,760 --> 00:20:52,380
know kind of what should vendors be

550
00:20:52,380 --> 00:20:54,720
doing well this this is where things get

551
00:20:54,720 --> 00:20:57,120
kind of painful you know Dale had been

552
00:20:57,120 --> 00:20:59,280
talking about like we propose all these

553
00:20:59,280 --> 00:21:01,140
security fixes and we really need to

554
00:21:01,140 --> 00:21:02,520
have better metrics and I'm kind of

555
00:21:02,520 --> 00:21:03,780
guilty of that I kind of wish I had

556
00:21:03,780 --> 00:21:06,059
heard him talk before I talked or before

557
00:21:06,059 --> 00:21:09,360
I made these slides so first off like I

558
00:21:09,360 --> 00:21:11,039
don't want to be picking on codices and

559
00:21:11,039 --> 00:21:13,140
Phoenix contact here right they are

560
00:21:13,140 --> 00:21:14,760
definitely not the only run times that

561
00:21:14,760 --> 00:21:17,400
have these issues but we really need to

562
00:21:17,400 --> 00:21:19,500
think of these logic programs as

563
00:21:19,500 --> 00:21:21,780
potentially malicious we've seen it in

564
00:21:21,780 --> 00:21:23,280
the past we're probably going to see it

565
00:21:23,280 --> 00:21:24,780
in the future you know we saw it in the

566
00:21:24,780 --> 00:21:27,660
case of the crisis Triton malware we've

567
00:21:27,660 --> 00:21:29,220
now seen attack tools that are

568
00:21:29,220 --> 00:21:30,780
specifically going after the codices

569
00:21:30,780 --> 00:21:33,780
runtime it should be a little bit you

570
00:21:33,780 --> 00:21:36,000
know make us think all right we may have

571
00:21:36,000 --> 00:21:38,400
malicious logic loaded onto the PLC like

572
00:21:38,400 --> 00:21:41,280
how can we contain it and my favorite

573
00:21:41,280 --> 00:21:44,100
proposal so far has been like let's run

574
00:21:44,100 --> 00:21:46,020
it in a separate process kind of address

575
00:21:46,020 --> 00:21:48,299
space and Implement inter-process

576
00:21:48,299 --> 00:21:50,640
communication between the runtime

577
00:21:50,640 --> 00:21:53,340
container and the kind of logic process

578
00:21:53,340 --> 00:21:55,559
there's a really big downside to this

579
00:21:55,559 --> 00:21:58,200
though which is performance because if

580
00:21:58,200 --> 00:22:00,480
you have like two processes that really

581
00:22:00,480 --> 00:22:02,700
need to have access to each other's data

582
00:22:02,700 --> 00:22:04,440
they're going to be doing a lot of

583
00:22:04,440 --> 00:22:06,720
communicating via some IPC mechanisms

584
00:22:06,720 --> 00:22:09,299
and it may end up not being worth it I

585
00:22:09,299 --> 00:22:10,620
don't know

586
00:22:10,620 --> 00:22:12,360
um there's a kind of a stop Gap solution

587
00:22:12,360 --> 00:22:15,000
that you can do though um which is you

588
00:22:15,000 --> 00:22:17,880
know at least provide a way to do

589
00:22:17,880 --> 00:22:20,880
out-of-band project management that is

590
00:22:20,880 --> 00:22:24,240
don't rely on the runtime to be the sole

591
00:22:24,240 --> 00:22:26,159
outbound source of communication with

592
00:22:26,159 --> 00:22:28,740
the engineering workstation uh I I hate

593
00:22:28,740 --> 00:22:30,780
to say it but provide something like FTP

594
00:22:30,780 --> 00:22:34,380
or SFTP or or some you know known

595
00:22:34,380 --> 00:22:37,500
protocol where a user can log in out of

596
00:22:37,500 --> 00:22:39,600
band using a process that probably

597
00:22:39,600 --> 00:22:41,460
hasn't hopefully hasn't been tampered

598
00:22:41,460 --> 00:22:45,780
with to remove a project file and then

599
00:22:45,780 --> 00:22:47,700
reboot the PLC and then hopefully

600
00:22:47,700 --> 00:22:50,400
everything can be hunky-dory bonus

601
00:22:50,400 --> 00:22:52,260
points though of course if you make it a

602
00:22:52,260 --> 00:22:54,000
monitorable protocol because you know

603
00:22:54,000 --> 00:22:56,700
we're all loving of detection

604
00:22:56,700 --> 00:22:57,299
um

605
00:22:57,299 --> 00:22:59,580
for end users the solutions are a lot

606
00:22:59,580 --> 00:23:02,580
simpler right code assists uses pretty

607
00:23:02,580 --> 00:23:04,740
well known at this point protocol ports

608
00:23:04,740 --> 00:23:08,039
for communications these are ports that

609
00:23:08,039 --> 00:23:09,659
really only your engineering workstation

610
00:23:09,659 --> 00:23:12,299
should have access to I know some OPC

611
00:23:12,299 --> 00:23:14,460
servers actually speak the code assist

612
00:23:14,460 --> 00:23:17,880
protocol and may actually you might

613
00:23:17,880 --> 00:23:20,400
configure them to like do i o read and

614
00:23:20,400 --> 00:23:23,520
write operations via the protocol

615
00:23:23,520 --> 00:23:25,559
but just lock it down as much as you can

616
00:23:25,559 --> 00:23:28,919
and those are UDP 1740 is the normal one

617
00:23:28,919 --> 00:23:32,700
and TCP 11740 is the normal one for code

618
00:23:32,700 --> 00:23:34,559
assist version two which I'm not

619
00:23:34,559 --> 00:23:36,900
explicitly talking about in this talk uh

620
00:23:36,900 --> 00:23:38,880
it definitely will have the same

621
00:23:38,880 --> 00:23:41,220
problems though because it's like 20

622
00:23:41,220 --> 00:23:42,900
years older or something

623
00:23:42,900 --> 00:23:46,080
um you know that uses usually TCP 2700

624
00:23:46,080 --> 00:23:48,480
for proconos you know the the Legacy

625
00:23:48,480 --> 00:23:51,740
version of proconos uses this TCP 20547

626
00:23:51,740 --> 00:23:55,919
the newer version uses 41100 for

627
00:23:55,919 --> 00:23:57,120
engineering access and I don't even

628
00:23:57,120 --> 00:24:00,480
remember what 1962 is used for there are

629
00:24:00,480 --> 00:24:02,520
also security features in these plcs

630
00:24:02,520 --> 00:24:04,020
I've kind of proven that the security

631
00:24:04,020 --> 00:24:06,840
features aren't 100 effective you know

632
00:24:06,840 --> 00:24:08,820
you can enable users of course the

633
00:24:08,820 --> 00:24:10,860
application can modify users or add

634
00:24:10,860 --> 00:24:13,020
users or delete users see if you have a

635
00:24:13,020 --> 00:24:14,760
malicious engineer you're still kind of

636
00:24:14,760 --> 00:24:17,940
in a bad place they also have code

637
00:24:17,940 --> 00:24:20,760
signing so code assist lets you load a

638
00:24:20,760 --> 00:24:23,460
certificate into the PLC you then can

639
00:24:23,460 --> 00:24:24,900
design code with the engineering

640
00:24:24,900 --> 00:24:27,419
workstation and the PLC will allegedly

641
00:24:27,419 --> 00:24:30,960
verify the the code was signed but again

642
00:24:30,960 --> 00:24:33,659
if a malicious engineer loads malicious

643
00:24:33,659 --> 00:24:35,760
logic into the PLC they may override

644
00:24:35,760 --> 00:24:38,100
that behavior for proconos it kind of

645
00:24:38,100 --> 00:24:39,659
depends more on the PLC there aren't as

646
00:24:39,659 --> 00:24:41,280
many of these plcs to generalize

647
00:24:41,280 --> 00:24:44,520
especially regarding eclr the only one

648
00:24:44,520 --> 00:24:46,559
that I actually know of is the PLC next

649
00:24:46,559 --> 00:24:49,320
which runs the eclr and I have no like I

650
00:24:49,320 --> 00:24:51,179
said I did not actually test this attack

651
00:24:51,179 --> 00:24:54,720
on a PLC next I only tested on the eclr

652
00:24:54,720 --> 00:24:57,720
for Raspberry Pi Linux so I have no idea

653
00:24:57,720 --> 00:24:59,880
you know maybe they fixed everything I

654
00:24:59,880 --> 00:25:02,400
kind of doubt it but maybe they did so

655
00:25:02,400 --> 00:25:04,620
the PLC next though at least has some

656
00:25:04,620 --> 00:25:06,600
nice features one of them is you can

657
00:25:06,600 --> 00:25:09,179
verify the Integrity the firmware you

658
00:25:09,179 --> 00:25:11,760
can also do like basically code signing

659
00:25:11,760 --> 00:25:13,980
they also have user management available

660
00:25:13,980 --> 00:25:17,460
for it and finally an end user thing

661
00:25:17,460 --> 00:25:20,340
that you can do is you can implement

662
00:25:20,340 --> 00:25:23,460
this PLC top 20 practice which is for

663
00:25:23,460 --> 00:25:26,520
cycle time monitoring where it's

664
00:25:26,520 --> 00:25:28,620
basically you measure how long it takes

665
00:25:28,620 --> 00:25:32,820
the PLC to execute your logic over time

666
00:25:32,820 --> 00:25:35,400
and if you notice aberrations well that

667
00:25:35,400 --> 00:25:37,620
suggests that something is wrong again

668
00:25:37,620 --> 00:25:40,140
this can be circumvented I think in

669
00:25:40,140 --> 00:25:42,900
theory but why make things easy for

670
00:25:42,900 --> 00:25:45,059
attackers if you can implement this I

671
00:25:45,059 --> 00:25:48,000
would go for it because you know you

672
00:25:48,000 --> 00:25:49,679
just need the attacker to slip up once

673
00:25:49,679 --> 00:25:51,059
and get caught then you can get them off

674
00:25:51,059 --> 00:25:52,740
your network

675
00:25:52,740 --> 00:25:55,080
um I was told there would be cves so uh

676
00:25:55,080 --> 00:25:57,240
there are there are actually probably

677
00:25:57,240 --> 00:25:59,039
going to end up being five total cves

678
00:25:59,039 --> 00:26:00,960
but we're really only talking about two

679
00:26:00,960 --> 00:26:04,260
of them today so 2022 40 46 for code

680
00:26:04,260 --> 00:26:07,140
assist out of bounds right 2023 I think

681
00:26:07,140 --> 00:26:10,320
I wrote down the numbers they have uh we

682
00:26:10,320 --> 00:26:13,140
have two different numbers for that 0757

683
00:26:13,140 --> 00:26:15,960
and two five six one two uh we had some

684
00:26:15,960 --> 00:26:18,240
miscommunication with the the pcert team

685
00:26:18,240 --> 00:26:21,000
and actually reserved our own uh so we

686
00:26:21,000 --> 00:26:22,740
need to figure that out and again I'm

687
00:26:22,740 --> 00:26:25,919
not really sure if the 2023 phone for uh

688
00:26:25,919 --> 00:26:28,919
for Kronos eclr effects PLC next but uh

689
00:26:28,919 --> 00:26:30,900
hey if you have one lying around and you

690
00:26:30,900 --> 00:26:32,520
want to give me some files off of it I

691
00:26:32,520 --> 00:26:33,960
can tell you

692
00:26:33,960 --> 00:26:35,820
um and that's it uh we have uh

693
00:26:35,820 --> 00:26:38,159
microphones if anybody has questions

694
00:26:38,159 --> 00:26:39,480
um and if not we'll get the next talk

695
00:26:39,480 --> 00:26:40,980
out but there's microphones at either

696
00:26:40,980 --> 00:26:42,480
side of the room so if you have

697
00:26:42,480 --> 00:26:43,740
something you want to ask

698
00:26:43,740 --> 00:26:45,840
up

699
00:26:45,840 --> 00:26:48,360
uh Hey Reed great talk

700
00:26:48,360 --> 00:26:51,299
um the file format of the firmware logic

701
00:26:51,299 --> 00:26:53,940
that you're talking about do these hint

702
00:26:53,940 --> 00:26:55,740
routines you know the main routine that

703
00:26:55,740 --> 00:26:57,659
you were talking about is this like a

704
00:26:57,659 --> 00:26:59,700
standard place in that file format is

705
00:26:59,700 --> 00:27:01,080
this something we could look for in the

706
00:27:01,080 --> 00:27:03,299
files themselves I have never actually

707
00:27:03,299 --> 00:27:05,460
figured out how the runtime like

708
00:27:05,460 --> 00:27:07,980
determines where the the init function

709
00:27:07,980 --> 00:27:10,740
lives I assume that there's like in the

710
00:27:10,740 --> 00:27:12,900
file header there is there is some

711
00:27:12,900 --> 00:27:14,760
pointer to say like hey the init

712
00:27:14,760 --> 00:27:16,440
function is located here this is the

713
00:27:16,440 --> 00:27:17,880
thing you want to run when you load and

714
00:27:17,880 --> 00:27:20,039
then the main function is down here this

715
00:27:20,039 --> 00:27:21,600
is the thing you want to run repeatedly

716
00:27:21,600 --> 00:27:24,240
every time the uh you know the process

717
00:27:24,240 --> 00:27:26,880
comes up for running on the PLC but I I

718
00:27:26,880 --> 00:27:28,500
honestly haven't looked you know I

719
00:27:28,500 --> 00:27:31,620
compiled a project and edit The Code by

720
00:27:31,620 --> 00:27:33,720
hand you know going in with a hex editor

721
00:27:33,720 --> 00:27:36,600
the the

722
00:27:36,600 --> 00:27:39,539
yeah okay cool

723
00:27:39,539 --> 00:27:41,220
anything else

724
00:27:41,220 --> 00:27:43,919
hey uh we actually use scan cycle time

725
00:27:43,919 --> 00:27:46,080
for anomaly detection as well so if you

726
00:27:46,080 --> 00:27:48,240
could uh clarify but more about your

727
00:27:48,240 --> 00:27:50,640
limitations that you saw for detecting

728
00:27:50,640 --> 00:27:52,080
the scan cycle

729
00:27:52,080 --> 00:27:52,980
um

730
00:27:52,980 --> 00:27:56,039
uh modifications I guess sure yeah I

731
00:27:56,039 --> 00:27:58,080
mean as far as I know you know the the

732
00:27:58,080 --> 00:28:00,480
top 20 PLC practices they're basically

733
00:28:00,480 --> 00:28:02,520
monitoring to see you know how long does

734
00:28:02,520 --> 00:28:05,100
the main Loop take to execute and what I

735
00:28:05,100 --> 00:28:07,860
would look for is just to see like is

736
00:28:07,860 --> 00:28:10,679
there Jitter in this um because

737
00:28:10,679 --> 00:28:12,480
um if we are overwriting base

738
00:28:12,480 --> 00:28:14,760
functionality of the PLC that may

739
00:28:14,760 --> 00:28:16,919
manifest itself I I honestly don't know

740
00:28:16,919 --> 00:28:18,659
though yeah yeah that's great that's

741
00:28:18,659 --> 00:28:21,059
kind of getting us that's what we focus

742
00:28:21,059 --> 00:28:24,179
in on and doing monitoring how long um

743
00:28:24,179 --> 00:28:25,559
is there any Jitter is there any

744
00:28:25,559 --> 00:28:27,960
deviations in behavior and that it seems

745
00:28:27,960 --> 00:28:29,940
like that would still work based on what

746
00:28:29,940 --> 00:28:31,919
we've been doing but yeah I think it

747
00:28:31,919 --> 00:28:33,600
would yeah I think if you're if you're

748
00:28:33,600 --> 00:28:36,299
noticing Jitter from modified logic you

749
00:28:36,299 --> 00:28:38,159
would probably notice Jitter yeah yeah

750
00:28:38,159 --> 00:28:39,960
in just about any kind of modification

751
00:28:39,960 --> 00:28:42,720
right right and even but if you if you

752
00:28:42,720 --> 00:28:44,520
have the ability to monitor like Jitter

753
00:28:44,520 --> 00:28:46,919
in response time from a function like

754
00:28:46,919 --> 00:28:49,380
that would certainly be good network

755
00:28:49,380 --> 00:28:51,419
network Jitter essentially because it

756
00:28:51,419 --> 00:28:53,640
would be all right we have the you know

757
00:28:53,640 --> 00:28:55,740
I debug service being called well now

758
00:28:55,740 --> 00:28:57,659
it's hooked so it's executing the

759
00:28:57,659 --> 00:28:59,940
malicious code first to modify things

760
00:28:59,940 --> 00:29:01,559
and make everything look right and then

761
00:29:01,559 --> 00:29:03,179
you know then building the response

762
00:29:03,179 --> 00:29:05,640
packet uh you know you should notice

763
00:29:05,640 --> 00:29:07,919
some aberration and timing there yeah

764
00:29:07,919 --> 00:29:10,380
yeah thanks so much yeah you bet

765
00:29:10,380 --> 00:29:12,120
and looks like that's it so thank you

766
00:29:12,120 --> 00:29:12,840
very much

767
00:29:12,840 --> 00:29:15,990
[Applause]

768
00:29:16,799 --> 00:29:19,799
foreign

