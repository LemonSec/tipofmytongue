1
00:00:00,350 --> 00:00:09,170
[Music]

2
00:00:09,170 --> 00:00:12,750
Stage two our first presenter is dr.

3
00:00:12,750 --> 00:00:17,699
andrew zona Berg he is with ioactive

4
00:00:17,699 --> 00:00:20,279
he's a senior security consultant and he

5
00:00:20,279 --> 00:00:22,529
will be presenting the anti kernel

6
00:00:22,529 --> 00:00:24,779
hardware and unprivileged software

7
00:00:24,779 --> 00:00:36,660
please welcome Andrew hello everyone we

8
00:00:36,660 --> 00:00:40,469
good okay so I am going to be presenting

9
00:00:40,469 --> 00:00:42,480
on the anti kernel which is a

10
00:00:42,480 --> 00:00:44,670
decentralized hardware and software

11
00:00:44,670 --> 00:00:46,050
operating system

12
00:00:46,050 --> 00:00:49,440
this was joint work with dr. Jenner at

13
00:00:49,440 --> 00:00:52,020
RPI who was my PhD advisor a couple of

14
00:00:52,020 --> 00:00:53,850
years ago this work grew out of my

15
00:00:53,850 --> 00:00:56,730
dissertation so fundamentally why are we

16
00:00:56,730 --> 00:00:58,410
here this gate os's

17
00:00:58,410 --> 00:01:00,930
have problems everybody knows this this

18
00:01:00,930 --> 00:01:03,480
is why we're here the OSS job is to

19
00:01:03,480 --> 00:01:05,220
protect the system we don't want the OS

20
00:01:05,220 --> 00:01:06,689
to be a liability we don't want it to be

21
00:01:06,689 --> 00:01:08,189
a point of attack we don't want it to

22
00:01:08,189 --> 00:01:10,530
provide the attacker with opportunities

23
00:01:10,530 --> 00:01:12,570
to go and make whatever they're doing

24
00:01:12,570 --> 00:01:15,270
even worse so starting with the

25
00:01:15,270 --> 00:01:17,490
unpleasant facts that kernel mode means

26
00:01:17,490 --> 00:01:20,159
you have access to everything and what

27
00:01:20,159 --> 00:01:22,650
level of code what piece of code in a

28
00:01:22,650 --> 00:01:24,360
modern OS actually needs access to

29
00:01:24,360 --> 00:01:27,390
everything you've got the internal state

30
00:01:27,390 --> 00:01:29,759
of the memory manager you've got the

31
00:01:29,759 --> 00:01:33,259
buffers of memory mapped i/o you have

32
00:01:33,259 --> 00:01:36,090
the private heap dataview space process

33
00:01:36,090 --> 00:01:38,159
no one part of the system needs access

34
00:01:38,159 --> 00:01:40,439
to everything so why do we have any

35
00:01:40,439 --> 00:01:42,329
software whatsoever that has access to

36
00:01:42,329 --> 00:01:43,799
all of this it just seems like a bad

37
00:01:43,799 --> 00:01:44,840
idea

38
00:01:44,840 --> 00:01:47,009
fundamentally what this tells me is that

39
00:01:47,009 --> 00:01:49,470
any system that has any code whatsoever

40
00:01:49,470 --> 00:01:51,750
running in ring zero is violating the

41
00:01:51,750 --> 00:01:55,140
principle of least required privilege so

42
00:01:55,140 --> 00:01:56,880
here's the question we can conclude

43
00:01:56,880 --> 00:01:58,350
based on this that it should be possible

44
00:01:58,350 --> 00:02:01,890
to build a OS in which we don't have any

45
00:02:01,890 --> 00:02:04,500
code running in ring zero but this just

46
00:02:04,500 --> 00:02:05,909
tells us it seems like it should be

47
00:02:05,909 --> 00:02:07,170
possible if doesn't tell us anything

48
00:02:07,170 --> 00:02:10,318
about how we actually build it so we're

49
00:02:10,318 --> 00:02:11,790
gonna look at some existing kernel

50
00:02:11,790 --> 00:02:13,569
architectures the first is

51
00:02:13,569 --> 00:02:14,680
monolithic kernel everybody's familiar

52
00:02:14,680 --> 00:02:16,780
with you've got one big block of code

53
00:02:16,780 --> 00:02:18,370
running with full privileges it does

54
00:02:18,370 --> 00:02:20,590
everything any code anywhere and there

55
00:02:20,590 --> 00:02:23,019
can corrupt any state anywhere then we

56
00:02:23,019 --> 00:02:25,870
move down to the microkernel where you

57
00:02:25,870 --> 00:02:27,760
move drivers and a lot of stuff it

58
00:02:27,760 --> 00:02:29,019
doesn't really have to be done in

59
00:02:29,019 --> 00:02:31,359
privilege mode out to use base server

60
00:02:31,359 --> 00:02:34,599
and you have the kernel handle a smaller

61
00:02:34,599 --> 00:02:36,790
amount of stuff then the separation

62
00:02:36,790 --> 00:02:38,409
kernel is kind of taking this to the

63
00:02:38,409 --> 00:02:41,590
logical conclusion in which the job of

64
00:02:41,590 --> 00:02:43,749
the kernel is simply to take the various

65
00:02:43,749 --> 00:02:45,700
secure domains in your system you've got

66
00:02:45,700 --> 00:02:47,319
different applications that don't trust

67
00:02:47,319 --> 00:02:49,269
each other the separation kernels job is

68
00:02:49,269 --> 00:02:50,530
just to separate these from each other

69
00:02:50,530 --> 00:02:52,030
allows them to talk to each other and

70
00:02:52,030 --> 00:02:54,430
control access so certain applications

71
00:02:54,430 --> 00:02:55,599
are not allowed to talk to certain other

72
00:02:55,599 --> 00:02:58,989
ones and now we're gonna get on to a few

73
00:02:58,989 --> 00:03:00,549
lesser-known architectures in particular

74
00:03:00,549 --> 00:03:02,530
the extra kernel this was developed by a

75
00:03:02,530 --> 00:03:04,900
group at the MIT laboratory for computer

76
00:03:04,900 --> 00:03:07,840
science in the mid 90s and they weren't

77
00:03:07,840 --> 00:03:09,370
even thinking about security the focus

78
00:03:09,370 --> 00:03:11,519
of the extra kernel was performance and

79
00:03:11,519 --> 00:03:14,709
what they saw is that OS abstractions

80
00:03:14,709 --> 00:03:16,659
often are bad for performance if you're

81
00:03:16,659 --> 00:03:18,370
just trying to store some temporary data

82
00:03:18,370 --> 00:03:19,900
on disk if it's too big to fit in Ram

83
00:03:19,900 --> 00:03:22,000
why do you need a directory tree and

84
00:03:22,000 --> 00:03:23,799
named file system it's just getting in

85
00:03:23,799 --> 00:03:26,470
the way and so the extra kernel

86
00:03:26,470 --> 00:03:28,449
philosophy is to split the protection

87
00:03:28,449 --> 00:03:30,310
and segmentation of resources from the

88
00:03:30,310 --> 00:03:33,310
abstraction the drivers job is simply to

89
00:03:33,310 --> 00:03:35,199
take a resource divide it up into chunks

90
00:03:35,199 --> 00:03:37,919
and control access to those chunks and

91
00:03:37,919 --> 00:03:40,659
from there everything else is done and

92
00:03:40,659 --> 00:03:42,879
either a nun privileges based service or

93
00:03:42,879 --> 00:03:44,769
a user space library that you link with

94
00:03:44,769 --> 00:03:50,319
your application etc and so this gives

95
00:03:50,319 --> 00:03:51,970
an example of what an actual kernel

96
00:03:51,970 --> 00:03:54,009
could look like we have a database

97
00:03:54,009 --> 00:03:55,810
application that is able to talk

98
00:03:55,810 --> 00:03:57,669
directly to the disk cache and then the

99
00:03:57,669 --> 00:03:59,769
disk driver we can have a DHCP server

100
00:03:59,769 --> 00:04:02,379
that just it just C realises Lisa's desk

101
00:04:02,379 --> 00:04:04,269
so that if you restart the server it

102
00:04:04,269 --> 00:04:06,099
knows who had what IP address there's no

103
00:04:06,099 --> 00:04:07,780
reason for an app name file to do this

104
00:04:07,780 --> 00:04:09,579
it just needs some block of disk and or

105
00:04:09,579 --> 00:04:11,079
stuffing so you just write stuff

106
00:04:11,079 --> 00:04:12,819
straight to the block device driver and

107
00:04:12,819 --> 00:04:14,680
then your word processor might actually

108
00:04:14,680 --> 00:04:16,060
want to go through a file systems you

109
00:04:16,060 --> 00:04:18,820
could have name documents and each of

110
00:04:18,820 --> 00:04:20,589
these individual resources are protected

111
00:04:20,589 --> 00:04:22,180
from each other if the word processor

112
00:04:22,180 --> 00:04:24,250
tries to open the raw disk block that's

113
00:04:24,250 --> 00:04:26,620
owned by the DHCP servers not allowed to

114
00:04:26,620 --> 00:04:29,650
so on and so now we can plot the extra

115
00:04:29,650 --> 00:04:31,210
kernel on our graph all the way down

116
00:04:31,210 --> 00:04:35,020
here it's small and fast so one of the

117
00:04:35,020 --> 00:04:37,090
key insights that the original MIT paper

118
00:04:37,090 --> 00:04:40,479
missed is that it's not just a

119
00:04:40,479 --> 00:04:42,490
performance benefit if you switch to an

120
00:04:42,490 --> 00:04:43,930
external architecture if you're moving

121
00:04:43,930 --> 00:04:46,240
these non security-related abstractions

122
00:04:46,240 --> 00:04:48,220
out of ring zero now you're shrinking

123
00:04:48,220 --> 00:04:49,930
the trusted computing base and shrinking

124
00:04:49,930 --> 00:04:52,150
the attack surface and the original

125
00:04:52,150 --> 00:04:53,560
paper didn't even touch on this I don't

126
00:04:53,560 --> 00:04:55,270
think they understood the true

127
00:04:55,270 --> 00:04:56,979
implications of our architecture it is

128
00:04:56,979 --> 00:04:58,270
great work but just didn't realize how

129
00:04:58,270 --> 00:05:01,510
good it was and so let's think about

130
00:05:01,510 --> 00:05:04,060
what the kernel actually has to do you

131
00:05:04,060 --> 00:05:05,770
obviously need some way of sharing CPU

132
00:05:05,770 --> 00:05:07,750
time between multiple processes if you

133
00:05:07,750 --> 00:05:10,180
have one CPU per security domain and

134
00:05:10,180 --> 00:05:12,100
some papers have reposed yeah it's

135
00:05:12,100 --> 00:05:13,930
pretty easy isolate them but your system

136
00:05:13,930 --> 00:05:17,169
also scales ridiculously partly now once

137
00:05:17,169 --> 00:05:18,430
we have these multiple applications

138
00:05:18,430 --> 00:05:19,960
running of the CPU we need some way of

139
00:05:19,960 --> 00:05:22,780
allowing them to talk to each other we

140
00:05:22,780 --> 00:05:24,100
need some way of allowing them to talk

141
00:05:24,100 --> 00:05:27,669
to hardware and we need some way of

142
00:05:27,669 --> 00:05:28,990
managing memory at the page level

143
00:05:28,990 --> 00:05:31,770
everything below pages can be done by

144
00:05:31,770 --> 00:05:34,630
unprivileged applications in your Lipsy

145
00:05:34,630 --> 00:05:37,030
heap or something like that the OSS job

146
00:05:37,030 --> 00:05:38,680
is just to separate the pages from each

147
00:05:38,680 --> 00:05:42,490
other so now let's think about if we

148
00:05:42,490 --> 00:05:44,080
really need each of these things to be

149
00:05:44,080 --> 00:05:45,820
running ring 0 or if it's just an OS

150
00:05:45,820 --> 00:05:47,110
service that can be provided at some

151
00:05:47,110 --> 00:05:47,740
other level

152
00:05:47,740 --> 00:05:50,590
so barrel processors and hyper threading

153
00:05:50,590 --> 00:05:52,660
already exist how much of a stretch is

154
00:05:52,660 --> 00:05:54,099
it if we have a CPU that's already able

155
00:05:54,099 --> 00:05:55,419
to context switch without software

156
00:05:55,419 --> 00:05:57,639
intervention how much more work is it to

157
00:05:57,639 --> 00:05:59,139
have that CPU also schedule these

158
00:05:59,139 --> 00:06:02,800
threads it's not that much so what if we

159
00:06:02,800 --> 00:06:04,470
move the whole run queue at the CP oh

160
00:06:04,470 --> 00:06:07,210
now if we're doing a simple round-robin

161
00:06:07,210 --> 00:06:09,370
thread scheduler which is perfectly fine

162
00:06:09,370 --> 00:06:10,990
for a lot of embedded systems it gives

163
00:06:10,990 --> 00:06:12,970
you deterministic performance it gives

164
00:06:12,970 --> 00:06:15,729
you simplicity it's easy to verify that

165
00:06:15,729 --> 00:06:18,610
it does what it's supposed to do and the

166
00:06:18,610 --> 00:06:20,979
amount of logic you actually have to add

167
00:06:20,979 --> 00:06:23,139
for CPU to do this is next to nothing

168
00:06:23,139 --> 00:06:25,510
you need one FIFO where if you have say

169
00:06:25,510 --> 00:06:28,030
32 threads you need a 5 bit wide 32

170
00:06:28,030 --> 00:06:31,150
entry FIFO that's nothing compared to

171
00:06:31,150 --> 00:06:34,479
the size of modern CPU and all you have

172
00:06:34,479 --> 00:06:36,669
to do then is provide an api to this

173
00:06:36,669 --> 00:06:39,139
FIFO that allows applications to

174
00:06:39,139 --> 00:06:41,419
create new processes to terminate

175
00:06:41,419 --> 00:06:45,139
themselves etc and the other nice thing

176
00:06:45,139 --> 00:06:46,699
about this is that if you have it it's

177
00:06:46,699 --> 00:06:48,199
this isolated subsystem there's no

178
00:06:48,199 --> 00:06:49,610
possibility of you messing with any

179
00:06:49,610 --> 00:06:51,789
state that's outside of this you have a

180
00:06:51,789 --> 00:06:54,199
physical piece of memory somewhere you

181
00:06:54,199 --> 00:06:56,659
have a read and a write pointer and you

182
00:06:56,659 --> 00:06:59,120
have a block that allows you to

183
00:06:59,120 --> 00:07:01,340
introduce a new entry in this list you

184
00:07:01,340 --> 00:07:02,960
have an option to delete an entry if

185
00:07:02,960 --> 00:07:05,960
you're terminating a process and so it's

186
00:07:05,960 --> 00:07:07,879
a little hard to read on this screen but

187
00:07:07,879 --> 00:07:10,819
this is the feral log module signature

188
00:07:10,819 --> 00:07:12,740
of the thread scheduler on our prototype

189
00:07:12,740 --> 00:07:13,849
you can see we just have a teach

190
00:07:13,849 --> 00:07:15,800
pipeline stage we have the thread ID we

191
00:07:15,800 --> 00:07:17,719
have a boolean thread active value and

192
00:07:17,719 --> 00:07:19,279
then we have a control bus that has

193
00:07:19,279 --> 00:07:22,699
opcode thread ID in and okay and done

194
00:07:22,699 --> 00:07:25,520
result so this is the sum total of our

195
00:07:25,520 --> 00:07:27,710
API and since this is running in

196
00:07:27,710 --> 00:07:30,110
hardware these are physical wires it is

197
00:07:30,110 --> 00:07:32,270
very easy to just go look at the netlist

198
00:07:32,270 --> 00:07:35,569
of the system and see these are the only

199
00:07:35,569 --> 00:07:37,639
wires between block ay and Block B

200
00:07:37,639 --> 00:07:39,110
therefore this is the sum total of our

201
00:07:39,110 --> 00:07:42,050
data flow and so this provides

202
00:07:42,050 --> 00:07:43,460
properties you would expect from an

203
00:07:43,460 --> 00:07:45,770
extra kernel and a separation kernel we

204
00:07:45,770 --> 00:07:47,930
have very minimal abstraction one of

205
00:07:47,930 --> 00:07:49,729
these price i d--'s corresponds to some

206
00:07:49,729 --> 00:07:52,250
unit of CPU time we have an API for it

207
00:07:52,250 --> 00:07:53,779
in which we can create and destroy

208
00:07:53,779 --> 00:07:55,669
processes and it is an isolated

209
00:07:55,669 --> 00:07:57,199
subsystem it has a well-defined

210
00:07:57,199 --> 00:08:00,110
interface so now let's think we've got

211
00:08:00,110 --> 00:08:01,969
these applications we can share CPU time

212
00:08:01,969 --> 00:08:03,589
between them now how do we have them

213
00:08:03,589 --> 00:08:06,319
talk to Hardware so what if instead of

214
00:08:06,319 --> 00:08:08,509
using a shared bus we use a packet

215
00:08:08,509 --> 00:08:10,520
switch network in the prototype I have

216
00:08:10,520 --> 00:08:12,649
right now it's 16-bit addresses that

217
00:08:12,649 --> 00:08:14,870
identify nodes in the system there's no

218
00:08:14,870 --> 00:08:16,370
reason you couldn't do large or smaller

219
00:08:16,370 --> 00:08:18,080
if your application needs called for it

220
00:08:18,080 --> 00:08:20,930
and so what if we instead of allocating

221
00:08:20,930 --> 00:08:22,849
one address the CPU what if we had a

222
00:08:22,849 --> 00:08:25,699
whole subnet for the CPU so in our

223
00:08:25,699 --> 00:08:28,849
diagram up here the CPU is something

224
00:08:28,849 --> 00:08:32,659
that hex 804 o / 10 now we have 804 o is

225
00:08:32,659 --> 00:08:34,969
the management address now we could say

226
00:08:34,969 --> 00:08:37,219
806 o 806 one of different applications

227
00:08:37,219 --> 00:08:39,198
and then we have our RAM and flash

228
00:08:39,198 --> 00:08:41,809
controller up there so what this means

229
00:08:41,809 --> 00:08:44,810
is that external entities elsewhere on

230
00:08:44,810 --> 00:08:46,160
the network are able to distinguish

231
00:08:46,160 --> 00:08:48,170
where messages are coming from based on

232
00:08:48,170 --> 00:08:51,430
the source address of that packet

233
00:08:51,680 --> 00:08:54,290
so as a little bit of aside the design

234
00:08:54,290 --> 00:08:56,149
is not actually one network I'm using

235
00:08:56,149 --> 00:08:58,460
two networks just to separate control

236
00:08:58,460 --> 00:09:01,700
and data the RPC network is used for

237
00:09:01,700 --> 00:09:02,930
remote procedure calls as the name

238
00:09:02,930 --> 00:09:06,080
implies as well as interrupts and small

239
00:09:06,080 --> 00:09:08,209
control related messages like that

240
00:09:08,209 --> 00:09:11,029
this is 128-bit datagrams it's typically

241
00:09:11,029 --> 00:09:13,130
register mapped in a cpu and then the

242
00:09:13,130 --> 00:09:15,080
DMA network is used for you guessed it

243
00:09:15,080 --> 00:09:18,020
DMA and bulk data transfer and the main

244
00:09:18,020 --> 00:09:19,670
properties these networks both provide

245
00:09:19,670 --> 00:09:21,649
they are reliable datagrams you have in

246
00:09:21,649 --> 00:09:23,899
order delivery of messages between any

247
00:09:23,899 --> 00:09:26,089
set of n points if I send two

248
00:09:26,089 --> 00:09:27,470
consecutive messages to two different

249
00:09:27,470 --> 00:09:29,360
entities there's no guarantee what order

250
00:09:29,360 --> 00:09:30,230
they'll arrive and there could be

251
00:09:30,230 --> 00:09:32,000
congested further on down the network if

252
00:09:32,000 --> 00:09:34,040
I send two messages in a row to the same

253
00:09:34,040 --> 00:09:35,540
place they're guaranteed to arrive in

254
00:09:35,540 --> 00:09:39,140
order and the network also provides a

255
00:09:39,140 --> 00:09:40,850
guaranteed minimum quality of service

256
00:09:40,850 --> 00:09:42,500
the current prototype network is a

257
00:09:42,500 --> 00:09:44,029
quadtree I'm probably gonna be switching

258
00:09:44,029 --> 00:09:45,500
to a 2d mesh for performance reasons

259
00:09:45,500 --> 00:09:47,959
down the road but the quadtree was

260
00:09:47,959 --> 00:09:50,720
easier to do in a prototype and at each

261
00:09:50,720 --> 00:09:53,060
hop in the routing I guarantee of the

262
00:09:53,060 --> 00:09:55,339
five available interfaces each one will

263
00:09:55,339 --> 00:09:57,320
get a chance to send every five packet

264
00:09:57,320 --> 00:09:57,770
times

265
00:09:57,770 --> 00:10:00,920
so worst case a t-top you get 1/5 of the

266
00:10:00,920 --> 00:10:03,740
available bandwidth and if you want more

267
00:10:03,740 --> 00:10:05,900
you can burst there's a fixed priority

268
00:10:05,900 --> 00:10:08,180
table built in right now the lowest

269
00:10:08,180 --> 00:10:10,010
numbered port always gets priority

270
00:10:10,010 --> 00:10:12,709
unless the round-robin selector wants us

271
00:10:12,709 --> 00:10:14,870
in and beyond their breaks ties Milo's

272
00:10:14,870 --> 00:10:18,560
part number and so this allows us to do

273
00:10:18,560 --> 00:10:20,420
network based access control we have a

274
00:10:20,420 --> 00:10:21,980
cpu instruction to Sennett receive

275
00:10:21,980 --> 00:10:24,020
messages in this system since you no

276
00:10:24,020 --> 00:10:26,870
longer are trying to run a sis call

277
00:10:26,870 --> 00:10:28,760
dispatcher and so on in ring 0 you don't

278
00:10:28,760 --> 00:10:30,740
need the Cisco instruction and trap to a

279
00:10:30,740 --> 00:10:33,200
Cisco handler so we can repurpose the

280
00:10:33,200 --> 00:10:34,640
system call instruction in order to send

281
00:10:34,640 --> 00:10:37,339
and receive messages then at the

282
00:10:37,339 --> 00:10:38,779
hardware level we can access the network

283
00:10:38,779 --> 00:10:41,180
via a formally verified transceiver

284
00:10:41,180 --> 00:10:43,070
module so think of it like plugging an

285
00:10:43,070 --> 00:10:44,180
SMP into a switch

286
00:10:44,180 --> 00:10:46,220
you've got your module you write it to

287
00:10:46,220 --> 00:10:48,020
use this transceiver you drop the

288
00:10:48,020 --> 00:10:50,209
transceiver in and since we've verified

289
00:10:50,209 --> 00:10:51,980
correctness of the transceiver it

290
00:10:51,980 --> 00:10:53,870
doesn't matter what this block of code

291
00:10:53,870 --> 00:10:56,390
that's talking to that transceiver is we

292
00:10:56,390 --> 00:10:58,040
can guarantee the packets coming out of

293
00:10:58,040 --> 00:10:59,930
it are well-formed and they're not gonna

294
00:10:59,930 --> 00:11:00,770
lie about where they're coming from

295
00:11:00,770 --> 00:11:02,660
because the transceiver has a source

296
00:11:02,660 --> 00:11:03,890
address

297
00:11:03,890 --> 00:11:05,960
and then since the network itself is all

298
00:11:05,960 --> 00:11:09,140
on chip and unavailable for any software

299
00:11:09,140 --> 00:11:10,340
to tamper with there is no software

300
00:11:10,340 --> 00:11:11,930
making routing decisions anywhere it's

301
00:11:11,930 --> 00:11:14,240
just a hardwired routing table basically

302
00:11:14,240 --> 00:11:16,820
take two bits of the address and that

303
00:11:16,820 --> 00:11:18,110
defines which of the four parts are

304
00:11:18,110 --> 00:11:19,940
going out of so there's not any

305
00:11:19,940 --> 00:11:21,260
opportunity for us offered interfere

306
00:11:21,260 --> 00:11:23,240
with routing decisions and this means we

307
00:11:23,240 --> 00:11:25,550
can fairly easily do a machine check the

308
00:11:25,550 --> 00:11:27,950
correctness proof showing messages goers

309
00:11:27,950 --> 00:11:30,290
as opposed to a nowhere else and you

310
00:11:30,290 --> 00:11:31,970
cannot observe or tamper with messages

311
00:11:31,970 --> 00:11:34,970
on the wire this means we can use packet

312
00:11:34,970 --> 00:11:37,370
headers for actual control a note of the

313
00:11:37,370 --> 00:11:38,960
system is able to determine where an

314
00:11:38,960 --> 00:11:40,490
incoming request is coming from and

315
00:11:40,490 --> 00:11:42,440
based on those headers they're able to

316
00:11:42,440 --> 00:11:44,000
decide whether to allow or deny that

317
00:11:44,000 --> 00:11:47,270
request so at this point of course

318
00:11:47,270 --> 00:11:48,740
inter-process communication is pretty

319
00:11:48,740 --> 00:11:50,390
trivial each application already has

320
00:11:50,390 --> 00:11:52,190
unique address in the network you have

321
00:11:52,190 --> 00:11:53,600
the ability to send messages to any one

322
00:11:53,600 --> 00:11:55,340
of these addresses so if you want to

323
00:11:55,340 --> 00:11:56,810
send a message to another application

324
00:11:56,810 --> 00:11:58,220
versus a hardware device it doesn't

325
00:11:58,220 --> 00:12:01,070
matter it's exactly the same and this

326
00:12:01,070 --> 00:12:03,410
actually means you can move a resource

327
00:12:03,410 --> 00:12:06,110
between a software application and a

328
00:12:06,110 --> 00:12:09,260
hardware service without even having to

329
00:12:09,260 --> 00:12:11,810
recompile the client code as long as the

330
00:12:11,810 --> 00:12:14,960
API stays the same so in our example

331
00:12:14,960 --> 00:12:17,180
here we have application 1 sending a

332
00:12:17,180 --> 00:12:18,770
message out to application two it just

333
00:12:18,770 --> 00:12:20,330
goes out onto the network and then back

334
00:12:20,330 --> 00:12:25,310
into the same CPU so this provides the

335
00:12:25,310 --> 00:12:26,690
same properties you would expect from an

336
00:12:26,690 --> 00:12:28,700
extra current or separation kernel we

337
00:12:28,700 --> 00:12:30,770
have obviously this requirement for

338
00:12:30,770 --> 00:12:32,090
component to the OS to be able to talk

339
00:12:32,090 --> 00:12:34,070
to each other there's minimal

340
00:12:34,070 --> 00:12:36,500
abstraction it's just blackbox datagrams

341
00:12:36,500 --> 00:12:38,960
and what goes on in those packets is up

342
00:12:38,960 --> 00:12:41,330
to the applications and we also have

343
00:12:41,330 --> 00:12:43,400
added a separation kernel we have strong

344
00:12:43,400 --> 00:12:45,620
authentication of the origins of message

345
00:12:45,620 --> 00:12:48,590
and we can grant our deny access to a

346
00:12:48,590 --> 00:12:50,750
specific resource based on the origin of

347
00:12:50,750 --> 00:12:53,120
the message this allows us to function

348
00:12:53,120 --> 00:12:55,070
like a separation kernel and provides

349
00:12:55,070 --> 00:12:56,540
drawing protection so that one

350
00:12:56,540 --> 00:12:58,310
application or service is not able to

351
00:12:58,310 --> 00:13:02,090
talk to another and so of course the

352
00:13:02,090 --> 00:13:03,140
obvious question a lot of you are

353
00:13:03,140 --> 00:13:05,270
wondering about is what about things

354
00:13:05,270 --> 00:13:06,920
like malloc or s break or whatever the

355
00:13:06,920 --> 00:13:08,540
equivalent isn't your system how can you

356
00:13:08,540 --> 00:13:11,990
possibly not run that in ring 0 so the

357
00:13:11,990 --> 00:13:14,060
way that can avoid this is if we push

358
00:13:14,060 --> 00:13:16,010
the protection of resources out to the

359
00:13:16,010 --> 00:13:17,360
endpoint which again is what the extra

360
00:13:17,360 --> 00:13:17,630
car

361
00:13:17,630 --> 00:13:20,180
Architects already calls for when you

362
00:13:20,180 --> 00:13:22,160
create a handle and give that handle to

363
00:13:22,160 --> 00:13:24,259
someone you as the creator of that

364
00:13:24,259 --> 00:13:25,519
handle are responsible for deciding

365
00:13:25,519 --> 00:13:27,139
who's allowed to access that handle the

366
00:13:27,139 --> 00:13:29,930
future and so we can do this all the way

367
00:13:29,930 --> 00:13:33,829
down to the memory control wire if we

368
00:13:33,829 --> 00:13:36,019
have the memory controller aware of

369
00:13:36,019 --> 00:13:37,790
which pages are free and which page

370
00:13:37,790 --> 00:13:40,610
they're allocated and at the page level

371
00:13:40,610 --> 00:13:41,810
mind you there's not really that much

372
00:13:41,810 --> 00:13:44,990
that has to be done this means we don't

373
00:13:44,990 --> 00:13:46,490
have to worry about protection in the

374
00:13:46,490 --> 00:13:47,810
process or MMU anymore

375
00:13:47,810 --> 00:13:50,720
you can nmap anything you want and if

376
00:13:50,720 --> 00:13:52,519
you try to a map a page that you don't

377
00:13:52,519 --> 00:13:54,079
have permissions to nothing happens

378
00:13:54,079 --> 00:13:55,699
you've just got a new entry in your page

379
00:13:55,699 --> 00:13:57,500
table you're not using it as soon as you

380
00:13:57,500 --> 00:13:58,730
dereference that pointer

381
00:13:58,730 --> 00:14:00,889
you said fault if the peripheral says

382
00:14:00,889 --> 00:14:05,000
I'm sorry Dave I can't do that and the

383
00:14:05,000 --> 00:14:06,589
way it does this it just sends a message

384
00:14:06,589 --> 00:14:08,180
back on the RPC network of sins

385
00:14:08,180 --> 00:14:10,790
essentially an interrupt that says the

386
00:14:10,790 --> 00:14:13,930
DMA read you requested was not approved

387
00:14:13,930 --> 00:14:15,949
pretty much the equipment of an ICMP

388
00:14:15,949 --> 00:14:18,470
host prohibited message and so this

389
00:14:18,470 --> 00:14:20,569
means that in order to allocate a page

390
00:14:20,569 --> 00:14:22,399
all we have to do is we send a message

391
00:14:22,399 --> 00:14:25,069
from say in our case the application is

392
00:14:25,069 --> 00:14:27,290
executable echo fw which is echo

393
00:14:27,290 --> 00:14:30,470
firmware sends a message to ram allocate

394
00:14:30,470 --> 00:14:33,079
ram responds about 30 clocks later

395
00:14:33,079 --> 00:14:35,899
saying ok this is successful we

396
00:14:35,899 --> 00:14:38,089
successfully allocated a page memory and

397
00:14:38,089 --> 00:14:40,220
the address is physical address 0 within

398
00:14:40,220 --> 00:14:41,779
Ram because this is the first page of

399
00:14:41,779 --> 00:14:44,600
ever allocated then the next thing we do

400
00:14:44,600 --> 00:14:47,750
is the application sends a message to

401
00:14:47,750 --> 00:14:51,439
the CPU if we back up a slide you can

402
00:14:51,439 --> 00:14:53,689
see that the CPU has an out-of-band

403
00:14:53,689 --> 00:14:56,959
management address so in order to create

404
00:14:56,959 --> 00:14:58,430
a new entry the page table you're not

405
00:14:58,430 --> 00:15:00,019
poking random data structure somewhere

406
00:15:00,019 --> 00:15:01,550
in memory that are entirely prostitute

407
00:15:01,550 --> 00:15:04,189
handed you sent a message to the CPU

408
00:15:04,189 --> 00:15:07,759
using the CPUs defined API for creating

409
00:15:07,759 --> 00:15:10,310
a new page table entry and that page

410
00:15:10,310 --> 00:15:12,949
table entry simply says I'm requesting a

411
00:15:12,949 --> 00:15:15,500
new entry at physical address 0 virtual

412
00:15:15,500 --> 00:15:19,790
address 400 800 and the CPU then says

413
00:15:19,790 --> 00:15:21,680
alright fine you've got a valid page

414
00:15:21,680 --> 00:15:23,240
entry there we're gonna go create a new

415
00:15:23,240 --> 00:15:26,209
TLB entry and then after that's done we

416
00:15:26,209 --> 00:15:27,889
allocate another page memory I believe

417
00:15:27,889 --> 00:15:28,810
this is stack

418
00:15:28,810 --> 00:15:31,930
is BSS then we do what DMA write which

419
00:15:31,930 --> 00:15:33,190
doesn't show this capture because I'm

420
00:15:33,190 --> 00:15:34,420
only looking at control playing traffic

421
00:15:34,420 --> 00:15:37,120
and we get a message back from RAM

422
00:15:37,120 --> 00:15:38,980
saying hey successful write to this page

423
00:15:38,980 --> 00:15:42,820
so the data structures required for

424
00:15:42,820 --> 00:15:45,160
doing this are trivially simple you have

425
00:15:45,160 --> 00:15:48,040
a FIFO of free pages you have an

426
00:15:48,040 --> 00:15:49,740
arranged during an order for each page

427
00:15:49,740 --> 00:15:52,270
the control state machine for this is

428
00:15:52,270 --> 00:15:54,520
microscopic it's a couple hundred lines

429
00:15:54,520 --> 00:15:57,040
and that's in a hardware description

430
00:15:57,040 --> 00:15:58,510
language it pretends to be a lot more

431
00:15:58,510 --> 00:16:00,040
for both than something like C if you

432
00:16:00,040 --> 00:16:01,839
were writing this and C did probably 20

433
00:16:01,839 --> 00:16:04,930
lines of code and it is also fairly easy

434
00:16:04,930 --> 00:16:06,580
to test and verify this as a result

435
00:16:06,580 --> 00:16:09,520
because the logic is so simple so we

436
00:16:09,520 --> 00:16:11,050
currently have a thorough thorough

437
00:16:11,050 --> 00:16:13,180
automated test suite it is not formally

438
00:16:13,180 --> 00:16:14,890
verified yet that is on the agenda for

439
00:16:14,890 --> 00:16:18,130
the fairly near future we're a little

440
00:16:18,130 --> 00:16:19,690
bit short on time so I'm gonna skip over

441
00:16:19,690 --> 00:16:22,210
showing the extensive details of what

442
00:16:22,210 --> 00:16:24,490
the allocator does but this is the sum

443
00:16:24,490 --> 00:16:25,570
total of what it takes to implement

444
00:16:25,570 --> 00:16:29,589
malloc in this architecture and freeze

445
00:16:29,589 --> 00:16:31,150
pretty simple as well there's a tiny bit

446
00:16:31,150 --> 00:16:32,440
more than it's shown in these slides

447
00:16:32,440 --> 00:16:34,540
this is the logic to take a page that

448
00:16:34,540 --> 00:16:37,839
we've successfully confirmed okay you do

449
00:16:37,839 --> 00:16:39,370
own this page you're allowed to free it

450
00:16:39,370 --> 00:16:41,440
push it back on the free list it also 0

451
00:16:41,440 --> 00:16:42,820
wise to the content of the page to

452
00:16:42,820 --> 00:16:44,500
prevent state leakage that logic isn't

453
00:16:44,500 --> 00:16:46,330
shown on this screen but there's again

454
00:16:46,330 --> 00:16:49,330
not a lot of code involved and so this

455
00:16:49,330 --> 00:16:50,710
provides the properties we would expect

456
00:16:50,710 --> 00:16:52,330
from an external or a separation kernel

457
00:16:52,330 --> 00:16:54,460
as well the memory is managed at a very

458
00:16:54,460 --> 00:16:56,170
low level we don't have any complicated

459
00:16:56,170 --> 00:16:58,750
heaps or arbitrarily sized blocks and

460
00:16:58,750 --> 00:17:01,150
Eve that is done in your application the

461
00:17:01,150 --> 00:17:04,209
OS only takes these pages protect

462
00:17:04,209 --> 00:17:05,410
applications from mess with each other

463
00:17:05,410 --> 00:17:07,839
state and doesn't even do anything like

464
00:17:07,839 --> 00:17:09,970
virtual memory or paging if you want

465
00:17:09,970 --> 00:17:11,349
anything fancy like that you have to do

466
00:17:11,349 --> 00:17:11,949
it yourself

467
00:17:11,949 --> 00:17:13,810
address translation for that matter is

468
00:17:13,810 --> 00:17:15,069
not provided by the ramp control it's

469
00:17:15,069 --> 00:17:17,319
provided by the CPU you can have a CPU

470
00:17:17,319 --> 00:17:19,780
that uses raw physical addresses if you

471
00:17:19,780 --> 00:17:22,209
wanted to and sure you have to deal with

472
00:17:22,209 --> 00:17:23,770
the fact that you're gonna go get a page

473
00:17:23,770 --> 00:17:25,329
and it might come back at any physical

474
00:17:25,329 --> 00:17:26,079
address you want

475
00:17:26,079 --> 00:17:28,449
so translation is probably going to be

476
00:17:28,449 --> 00:17:29,650
convenient if you want to be able to

477
00:17:29,650 --> 00:17:31,720
ever allocate a virtual buffer more than

478
00:17:31,720 --> 00:17:33,940
one page in size but the architecture

479
00:17:33,940 --> 00:17:36,460
does not inherently require and it is

480
00:17:36,460 --> 00:17:38,080
specifically not required for security

481
00:17:38,080 --> 00:17:39,460
writing to page tables and unprivileged

482
00:17:39,460 --> 00:17:42,190
operation and of course we have the

483
00:17:42,190 --> 00:17:42,850
separation

484
00:17:42,850 --> 00:17:44,230
property that no dataflow is allowed

485
00:17:44,230 --> 00:17:47,559
between pages with different owners so

486
00:17:47,559 --> 00:17:49,110
at this point what's left at ring zero

487
00:17:49,110 --> 00:17:50,980
there isn't anything left

488
00:17:50,980 --> 00:17:52,960
now all the privileged instructions in

489
00:17:52,960 --> 00:17:55,030
the I say are unnecessary delete all of

490
00:17:55,030 --> 00:17:57,330
them run use a space in bare metal and

491
00:17:57,330 --> 00:17:59,740
you're not left with what I've termed an

492
00:17:59,740 --> 00:18:01,870
anti carnal because there isn't a kernel

493
00:18:01,870 --> 00:18:05,559
anymore there is no software whatsoever

494
00:18:05,559 --> 00:18:07,900
running in raid zero the CPU does not

495
00:18:07,900 --> 00:18:10,900
even have the concept of privileged

496
00:18:10,900 --> 00:18:11,410
ranks

497
00:18:11,410 --> 00:18:15,190
everything is unprivileged so now we can

498
00:18:15,190 --> 00:18:17,890
plot an anti kernel on our graph here it

499
00:18:17,890 --> 00:18:20,470
is microscopic even smaller than an

500
00:18:20,470 --> 00:18:21,850
extra kernel because we don't have any

501
00:18:21,850 --> 00:18:25,690
software in ring zero whatsoever on the

502
00:18:25,690 --> 00:18:28,990
speed side high speed access I did dry

503
00:18:28,990 --> 00:18:30,789
for a large box this is intentional

504
00:18:30,789 --> 00:18:33,100
because since the architecture is

505
00:18:33,100 --> 00:18:35,710
currently in prototype phase we haven't

506
00:18:35,710 --> 00:18:37,419
really put any effort into optimizing it

507
00:18:37,419 --> 00:18:38,830
so we don't really know how fast it can

508
00:18:38,830 --> 00:18:41,620
get the current prototype isn't all that

509
00:18:41,620 --> 00:18:43,900
fast but that's because the cpu that I

510
00:18:43,900 --> 00:18:46,990
built was designed by a grad student in

511
00:18:46,990 --> 00:18:48,880
a couple of months and I wanted to

512
00:18:48,880 --> 00:18:52,000
graduate so the o1 cache has a Miss

513
00:18:52,000 --> 00:18:54,250
latency if around 50 or 60 clock cycles

514
00:18:54,250 --> 00:18:55,960
nothing in the architecture requires

515
00:18:55,960 --> 00:18:58,870
this it's more it was it's more

516
00:18:58,870 --> 00:19:00,520
important that the system be functional

517
00:19:00,520 --> 00:19:02,230
and that I'd be able to show yes it

518
00:19:02,230 --> 00:19:06,130
works then it be fast so it is unknown

519
00:19:06,130 --> 00:19:07,840
at this point just how fast it can be

520
00:19:07,840 --> 00:19:09,880
the conjecture is that since pretty much

521
00:19:09,880 --> 00:19:11,200
is an extra kernel with hardware

522
00:19:11,200 --> 00:19:13,150
acceleration it can be at least as fast

523
00:19:13,150 --> 00:19:15,549
as an extra kernel maybe even faster but

524
00:19:15,549 --> 00:19:16,750
that remains a question for future

525
00:19:16,750 --> 00:19:20,980
research this time and so this is not

526
00:19:20,980 --> 00:19:22,690
just a hardware microkernel a harder

527
00:19:22,690 --> 00:19:24,309
microkernel would imply that you have

528
00:19:24,309 --> 00:19:26,770
some component in hardware that still

529
00:19:26,770 --> 00:19:28,600
has the ability to modify all system

530
00:19:28,600 --> 00:19:31,480
State but in an anti kernel instead you

531
00:19:31,480 --> 00:19:33,100
have a series of independent state

532
00:19:33,100 --> 00:19:34,960
machines that collectively provide the

533
00:19:34,960 --> 00:19:36,580
properties you would expect from a

534
00:19:36,580 --> 00:19:39,010
modern operating system but these

535
00:19:39,010 --> 00:19:42,010
subsystems are isolated from each other

536
00:19:42,010 --> 00:19:43,960
and they communicate in a limited and

537
00:19:43,960 --> 00:19:46,150
well-defined fashion like a separation

538
00:19:46,150 --> 00:19:48,460
kernel you can almost think of it as an

539
00:19:48,460 --> 00:19:50,260
object-oriented operating system each of

540
00:19:50,260 --> 00:19:53,260
these nodes in the network is separated

541
00:19:53,260 --> 00:19:54,230
from the rest and

542
00:19:54,230 --> 00:19:56,030
absolute it and simply provides an API

543
00:19:56,030 --> 00:19:58,100
for the remainder of a system to talk to

544
00:19:58,100 --> 00:20:02,990
it and this means that since each node

545
00:20:02,990 --> 00:20:04,940
manages its own security state your TCB

546
00:20:04,940 --> 00:20:07,460
is what you make it if you have a crypto

547
00:20:07,460 --> 00:20:10,010
module for example that chooses not to

548
00:20:10,010 --> 00:20:12,830
ever allocate any memory in the off chip

549
00:20:12,830 --> 00:20:15,230
ramp controller and only uses internal

550
00:20:15,230 --> 00:20:18,169
memory resources then a bug in the

551
00:20:18,169 --> 00:20:20,510
external memory controller has zero

552
00:20:20,510 --> 00:20:22,070
impact on the security of your module

553
00:20:22,070 --> 00:20:24,500
your TCB is what you make it if you

554
00:20:24,500 --> 00:20:26,299
choose not to depend on a given resource

555
00:20:26,299 --> 00:20:30,110
then it doesn't matter and of course we

556
00:20:30,110 --> 00:20:32,150
also have the separation I'm sorry we

557
00:20:32,150 --> 00:20:34,040
also have the extra kernel property that

558
00:20:34,040 --> 00:20:36,559
by bypassing these unwanted abstractions

559
00:20:36,559 --> 00:20:40,669
you can get better performance so I'm

560
00:20:40,669 --> 00:20:42,890
gonna briefly mention with a couple of

561
00:20:42,890 --> 00:20:44,299
the other components the architecture

562
00:20:44,299 --> 00:20:47,150
for example the name servers job is just

563
00:20:47,150 --> 00:20:50,330
to map these addresses the 16-bit node

564
00:20:50,330 --> 00:20:53,809
IDs back to a character in the prototype

565
00:20:53,809 --> 00:20:54,830
there's no reason they couldn't be

566
00:20:54,830 --> 00:20:57,830
longer host names this allows you to

567
00:20:57,830 --> 00:20:58,910
abstract away

568
00:20:58,910 --> 00:21:00,770
system architecture details so you could

569
00:21:00,770 --> 00:21:02,809
have the RAM katar at one address in one

570
00:21:02,809 --> 00:21:04,160
stock at a different address in another

571
00:21:04,160 --> 00:21:06,620
one and actually in my current prototype

572
00:21:06,620 --> 00:21:08,330
I have a unit test for the RAM

573
00:21:08,330 --> 00:21:11,030
controller that uses two completely

574
00:21:11,030 --> 00:21:13,370
different addressing schemes one of them

575
00:21:13,370 --> 00:21:14,929
is backed by own ship Ram the other is

576
00:21:14,929 --> 00:21:17,600
backed by external ddr2 the same binary

577
00:21:17,600 --> 00:21:21,290
runs on both systems and there's not

578
00:21:21,290 --> 00:21:22,640
even any additional abstraction this is

579
00:21:22,640 --> 00:21:25,760
the hardware API is the same and then

580
00:21:25,760 --> 00:21:27,530
obviously applications are able to

581
00:21:27,530 --> 00:21:29,059
register themselves with the name server

582
00:21:29,059 --> 00:21:31,280
to say hey I'm web server I'm database

583
00:21:31,280 --> 00:21:34,640
server or whatever we are a little short

584
00:21:34,640 --> 00:21:35,840
on time so I'm not gonna go into too

585
00:21:35,840 --> 00:21:37,640
much detail on the architecture of the

586
00:21:37,640 --> 00:21:40,070
CPU but it's it's a fairly standard

587
00:21:40,070 --> 00:21:42,530
eight stage pipeline superscalar CP o

588
00:21:42,530 --> 00:21:44,900
the one thing that is unique about it is

589
00:21:44,900 --> 00:21:47,210
there's a hardware elf loader if you

590
00:21:47,210 --> 00:21:48,740
look at what it takes to run a static

591
00:21:48,740 --> 00:21:50,630
length elf there's not that much parsing

592
00:21:50,630 --> 00:21:52,520
to the headers required basically you

593
00:21:52,520 --> 00:21:53,840
just find the program header table loop

594
00:21:53,840 --> 00:21:55,190
over the program headers and create a

595
00:21:55,190 --> 00:21:56,870
page table entry for each one of these

596
00:21:56,870 --> 00:22:00,020
blocks so it wasn't that much work to do

597
00:22:00,020 --> 00:22:01,940
a signature check on the contents of

598
00:22:01,940 --> 00:22:03,110
these program headers before loading

599
00:22:03,110 --> 00:22:06,080
them so now we can have a CPU itself

600
00:22:06,080 --> 00:22:07,429
enforcing code signing good luck

601
00:22:07,429 --> 00:22:09,909
patching that

602
00:22:10,270 --> 00:22:12,740
and this is an example of how we create

603
00:22:12,740 --> 00:22:14,810
processes if anybody wants more details

604
00:22:14,810 --> 00:22:16,690
on this you can talk to me afterwards

605
00:22:16,690 --> 00:22:20,300
the prototype as of now is just shy of

606
00:22:20,300 --> 00:22:22,310
two hundred thousand lines that includes

607
00:22:22,310 --> 00:22:24,320
test cases and build tools and all kinds

608
00:22:24,320 --> 00:22:26,690
of infrastructure and lots of yaks for

609
00:22:26,690 --> 00:22:28,640
saving during the development the actual

610
00:22:28,640 --> 00:22:30,170
critical components are quite small

611
00:22:30,170 --> 00:22:31,760
we're looking at under ten thousand

612
00:22:31,760 --> 00:22:33,560
Smith CPU the nameservers about a

613
00:22:33,560 --> 00:22:37,640
thousand the other networks combined are

614
00:22:37,640 --> 00:22:40,700
a couple thousand lines the code is all

615
00:22:40,700 --> 00:22:42,650
open source it's released under a three

616
00:22:42,650 --> 00:22:44,480
closed BSD license specifically to

617
00:22:44,480 --> 00:22:46,670
encourage commercial use free production

618
00:22:46,670 --> 00:22:51,980
of results etc and the network as of now

619
00:22:51,980 --> 00:22:54,290
as well as the name server in a subset

620
00:22:54,290 --> 00:22:56,540
of its functionality has complete formal

621
00:22:56,540 --> 00:22:59,480
correctness proofs so what goes in the

622
00:22:59,480 --> 00:23:01,250
transceiver comes out the other end

623
00:23:01,250 --> 00:23:02,750
packets are out at the work as opposed

624
00:23:02,750 --> 00:23:06,380
to and so on and so the code is

625
00:23:06,380 --> 00:23:09,560
available on our github the system is

626
00:23:09,560 --> 00:23:11,270
currently being refactored quite a bad

627
00:23:11,270 --> 00:23:13,220
we're in the process of trying to reduce

628
00:23:13,220 --> 00:23:16,190
fpga gate usage improve performance and

629
00:23:16,190 --> 00:23:18,500
so on so a lot of the code in the legacy

630
00:23:18,500 --> 00:23:19,970
directory but it is there if anybody

631
00:23:19,970 --> 00:23:23,570
wants to see it as far as future work

632
00:23:23,570 --> 00:23:25,100
it's basically just optimizing

633
00:23:25,100 --> 00:23:27,470
performance I'd like to move to risk

634
00:23:27,470 --> 00:23:30,320
five instead of MIPS just for that seems

635
00:23:30,320 --> 00:23:32,660
to be the way that the architectures are

636
00:23:32,660 --> 00:23:35,210
going no patents to worry about etcetera

637
00:23:35,210 --> 00:23:37,960
I'd like to do more for verification

638
00:23:37,960 --> 00:23:39,830
obviously we're looking to get a

639
00:23:39,830 --> 00:23:42,740
developer SDK documentation and so on

640
00:23:42,740 --> 00:23:45,740
more peripherals and pretty much bring

641
00:23:45,740 --> 00:23:47,540
it from a research prototype or

642
00:23:47,540 --> 00:23:48,650
something that's actually practical to

643
00:23:48,650 --> 00:23:51,590
use so at this point we've got 30

644
00:23:51,590 --> 00:23:53,000
seconds left so perfect time to take

645
00:23:53,000 --> 00:23:55,120
questions

646
00:23:59,350 --> 00:24:01,500
[Music]

647
00:24:01,500 --> 00:24:04,870
is rich Corrigan with St Jeannie what

648
00:24:04,870 --> 00:24:06,400
tools would you use for developing an

649
00:24:06,400 --> 00:24:09,580
application for this so the CPU as if

650
00:24:09,580 --> 00:24:11,530
now is MIPS like I said the next

651
00:24:11,530 --> 00:24:13,330
generation one is probably gonna be risk

652
00:24:13,330 --> 00:24:16,780
five in both cases just be using GCC to

653
00:24:16,780 --> 00:24:19,090
compile applications running on it if

654
00:24:19,090 --> 00:24:21,070
you're creating new hardware peripherals

655
00:24:21,070 --> 00:24:23,680
that will be done in parallel using the

656
00:24:23,680 --> 00:24:25,510
compilers for whatever FPGA you're

657
00:24:25,510 --> 00:24:27,520
targeting down the road I would like to

658
00:24:27,520 --> 00:24:30,310
go a sake eventually obviously that's

659
00:24:30,310 --> 00:24:32,080
quite a bit further down the pipeline so

660
00:24:32,080 --> 00:24:33,700
for the time being everything is FPGA

661
00:24:33,700 --> 00:24:35,350
and therefore you're looking at the

662
00:24:35,350 --> 00:24:37,300
normal FPGA development tools plus just

663
00:24:37,300 --> 00:24:38,830
a C compiler for your architecture

664
00:24:38,830 --> 00:24:40,960
there's been some discussion of moving

665
00:24:40,960 --> 00:24:42,640
the usual and to rust in the longer

666
00:24:42,640 --> 00:24:44,260
terms that you can have memory safety

667
00:24:44,260 --> 00:24:46,840
that's an open question at this point it

668
00:24:46,840 --> 00:24:48,340
seems promising but we haven't really

669
00:24:48,340 --> 00:24:50,430
put any time into it yet

670
00:24:50,430 --> 00:24:56,110
other questions I I don't have a real

671
00:24:56,110 --> 00:24:57,700
technical question for you but I'm

672
00:24:57,700 --> 00:25:00,370
curious who is showing interest in this

673
00:25:00,370 --> 00:25:02,650
and who do you think should show

674
00:25:02,650 --> 00:25:05,950
interest in this so this system is this

675
00:25:05,950 --> 00:25:07,120
architecture is really meant for

676
00:25:07,120 --> 00:25:08,890
critical systems where they're willing

677
00:25:08,890 --> 00:25:10,270
to take a little more time to do it

678
00:25:10,270 --> 00:25:13,060
right it's not meant to replace Android

679
00:25:13,060 --> 00:25:14,950
or iOS or something like that now

680
00:25:14,950 --> 00:25:17,140
possibly the other iOS is the type of

681
00:25:17,140 --> 00:25:18,280
application that could benefit from this

682
00:25:18,280 --> 00:25:21,490
I just ate a gear or general life safety

683
00:25:21,490 --> 00:25:24,280
system is medical avionics anything like

684
00:25:24,280 --> 00:25:25,840
that is really what we're targeting here

685
00:25:25,840 --> 00:25:28,660
where reliability and stability and that

686
00:25:28,660 --> 00:25:30,370
level of isolation and fault tolerance

687
00:25:30,370 --> 00:25:33,790
it's actually a pardon okay we have one

688
00:25:33,790 --> 00:25:38,890
more question Chris black with the

689
00:25:38,890 --> 00:25:40,840
underwriters labs so I hear that you're

690
00:25:40,840 --> 00:25:42,790
talking more embedded systems but one of

691
00:25:42,790 --> 00:25:44,290
the major problems with cloud especially

692
00:25:44,290 --> 00:25:46,360
containers is the Oasis are so

693
00:25:46,360 --> 00:25:47,680
vulnerable because the shared resources

694
00:25:47,680 --> 00:25:51,130
is there any plan for using this in a

695
00:25:51,130 --> 00:25:53,320
container space it's not really

696
00:25:53,320 --> 00:25:55,150
something that's occurred to us so far

697
00:25:55,150 --> 00:25:56,560
simply because we haven't really looked

698
00:25:56,560 --> 00:25:58,240
into what it would take to implement the

699
00:25:58,240 --> 00:26:00,610
fault a Linux kernel virtualization API

700
00:26:00,610 --> 00:26:03,310
on top of it it certainly is a potential

701
00:26:03,310 --> 00:26:04,930
use case and I'd be interested in

702
00:26:04,930 --> 00:26:07,120
hearing more about somebody who is

703
00:26:07,120 --> 00:26:10,000
interested in doing that our primary

704
00:26:10,000 --> 00:26:11,830
target has been about its system simply

705
00:26:11,830 --> 00:26:12,670
because

706
00:26:12,670 --> 00:26:15,190
the current version does require fairly

707
00:26:15,190 --> 00:26:17,620
custom hardware one of our open research

708
00:26:17,620 --> 00:26:20,440
questions is how much we can extend this

709
00:26:20,440 --> 00:26:22,059
into existing hardware for example

710
00:26:22,059 --> 00:26:24,220
Xilinx is zinc system on chip is an FPGA

711
00:26:24,220 --> 00:26:26,950
glued to a cortex a9 are taking a 15 in

712
00:26:26,950 --> 00:26:29,320
the next generation so we'd like to

713
00:26:29,320 --> 00:26:32,410
explore what it takes and can we can we

714
00:26:32,410 --> 00:26:34,450
both this onto an existing CPU and still

715
00:26:34,450 --> 00:26:35,770
get some of this level of security and

716
00:26:35,770 --> 00:26:36,880
that remains an open question at this

717
00:26:36,880 --> 00:26:46,540
point okay oh one more question what

718
00:26:46,540 --> 00:26:48,880
sort of tools do you use to do formal

719
00:26:48,880 --> 00:26:52,480
verification on the software so as of

720
00:26:52,480 --> 00:26:54,460
now we're writing the assertions in

721
00:26:54,460 --> 00:26:57,160
Verilog compiling with ptosis and then

722
00:26:57,160 --> 00:27:00,640
using a SMT solver in order to the older

723
00:27:00,640 --> 00:27:02,410
proofs are Sat based the newer ones are

724
00:27:02,410 --> 00:27:04,299
SMT because it scales better performance

725
00:27:04,299 --> 00:27:06,040
wise since we don't have to prove one

726
00:27:06,040 --> 00:27:08,010
plus two equals two plus one every time

727
00:27:08,010 --> 00:27:10,419
so the older ones were using I believe

728
00:27:10,419 --> 00:27:12,820
mini sadda the solver the new ones are

729
00:27:12,820 --> 00:27:16,120
using I believe C 3 but the framework is

730
00:27:16,120 --> 00:27:17,410
flexible so you could swap another

731
00:27:17,410 --> 00:27:19,450
solver and if you wanted to yo sis is

732
00:27:19,450 --> 00:27:21,220
being used top of there for both front

733
00:27:21,220 --> 00:27:23,140
end vera logs emphasis and to run the

734
00:27:23,140 --> 00:27:25,830
temporal action

