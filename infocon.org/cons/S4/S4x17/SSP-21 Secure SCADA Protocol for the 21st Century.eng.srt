1
00:00:07,099 --> 00:00:09,840
if you're new to the room

2
00:00:09,840 --> 00:00:12,660
welcome to the s4 stage to technical

3
00:00:12,660 --> 00:00:15,960
deep dives track the next speech excuse

4
00:00:15,960 --> 00:00:18,090
me the next speakers are rich Corrigan

5
00:00:18,090 --> 00:00:20,760
the lead engineer for the California

6
00:00:20,760 --> 00:00:22,949
energy systems for the 21st century and

7
00:00:22,949 --> 00:00:25,800
Adam crane the founder and CEO of

8
00:00:25,800 --> 00:00:28,920
automatic they will be presenting secure

9
00:00:28,920 --> 00:00:31,189
SCADA protocol for the 21st century

10
00:00:31,189 --> 00:00:48,930
let's please welcome rich and Adam so

11
00:00:48,930 --> 00:00:51,059
this is something that our lawyers have

12
00:00:51,059 --> 00:00:53,699
us put up basically saying that you know

13
00:00:53,699 --> 00:00:56,390
this is research that was funded by the

14
00:00:56,390 --> 00:00:59,699
rate payers of California and so it

15
00:00:59,699 --> 00:01:01,440
shouldn't be disclosed but this has been

16
00:01:01,440 --> 00:01:03,270
vetted so this is all approved to be

17
00:01:03,270 --> 00:01:08,460
shared publicly so California energy

18
00:01:08,460 --> 00:01:11,510
systems for the 21st century it's

19
00:01:11,510 --> 00:01:13,530
supported by our California Public

20
00:01:13,530 --> 00:01:15,930
Utility Commission it was approved to

21
00:01:15,930 --> 00:01:18,540
use rate payer funding for this research

22
00:01:18,540 --> 00:01:21,869
and it's focused on ICS cybersecurity to

23
00:01:21,869 --> 00:01:23,729
protect the grid from a worst-case

24
00:01:23,729 --> 00:01:26,520
cybersecurity attack so it's a

25
00:01:26,520 --> 00:01:28,229
collaborative research and development

26
00:01:28,229 --> 00:01:30,630
effort between San Diego Gas and

27
00:01:30,630 --> 00:01:32,939
Electric Pacific gas electric and

28
00:01:32,939 --> 00:01:35,250
Southern California Edison we work with

29
00:01:35,250 --> 00:01:38,250
the Department of Energy National Labs

30
00:01:38,250 --> 00:01:42,960
led by Lawrence Livermore we also engage

31
00:01:42,960 --> 00:01:46,020
industry like automatic universities

32
00:01:46,020 --> 00:01:49,530
like Georgia Tech Research Institute as

33
00:01:49,530 --> 00:01:51,810
well as you know other national labs

34
00:01:51,810 --> 00:01:56,159
like Idaho National Labs so how did we

35
00:01:56,159 --> 00:01:59,729
get here so we as a utility we're asking

36
00:01:59,729 --> 00:02:01,920
our suppliers like why aren't you

37
00:02:01,920 --> 00:02:04,829
building things like dnp3 essay into

38
00:02:04,829 --> 00:02:06,840
your products and they said well they it

39
00:02:06,840 --> 00:02:09,179
solves one protocol but our products

40
00:02:09,179 --> 00:02:12,330
support multiple protocols and so they

41
00:02:12,330 --> 00:02:13,350
want they

42
00:02:13,350 --> 00:02:16,590
sigelei TLS for skater but TLS doesn't

43
00:02:16,590 --> 00:02:18,720
really apply to skater because it's too

44
00:02:18,720 --> 00:02:19,710
heavy

45
00:02:19,710 --> 00:02:21,960
requires too much processing and it's

46
00:02:21,960 --> 00:02:24,510
doesn't work over serial so we took a

47
00:02:24,510 --> 00:02:25,800
look at what was out there and we

48
00:02:25,800 --> 00:02:27,900
obviously took a look at the mp3s a

49
00:02:27,900 --> 00:02:30,960
there was also a legacy protocol which

50
00:02:30,960 --> 00:02:34,500
was the SS CP which really goes back to

51
00:02:34,500 --> 00:02:39,270
AGA 12 and the it was called SSP p but

52
00:02:39,270 --> 00:02:42,690
it was basically a symmetrical security

53
00:02:42,690 --> 00:02:47,130
protocol using pre-shared keys there was

54
00:02:47,130 --> 00:02:49,290
no ability to do key management or

55
00:02:49,290 --> 00:02:52,770
rollover and so and we also found that a

56
00:02:52,770 --> 00:02:54,360
lot of the vendors are kind of

57
00:02:54,360 --> 00:02:55,800
frustrated and so they've all been

58
00:02:55,800 --> 00:02:58,920
implementing their own proprietary SCADA

59
00:02:58,920 --> 00:03:04,560
protocol schemes so here I'll let this

60
00:03:04,560 --> 00:03:06,090
is where I requirement stick over I let

61
00:03:06,090 --> 00:03:07,550
Adam take over from here

62
00:03:07,550 --> 00:03:11,670
okay thanks rich so the first thing that

63
00:03:11,670 --> 00:03:14,610
we did I guess starting back in is in

64
00:03:14,610 --> 00:03:16,350
March of this year starting coming up

65
00:03:16,350 --> 00:03:17,670
with a list of requirements for the

66
00:03:17,670 --> 00:03:19,290
protocol you know and a lot of these

67
00:03:19,290 --> 00:03:21,090
things aren't stuff that's going to

68
00:03:21,090 --> 00:03:22,710
surprise anyone I mean it's got to be

69
00:03:22,710 --> 00:03:25,320
able to provide a strong authentication

70
00:03:25,320 --> 00:03:26,850
it has to protect from things like

71
00:03:26,850 --> 00:03:28,590
man-in-the-middle attacks it has to

72
00:03:28,590 --> 00:03:30,090
protect from replay attacks all those

73
00:03:30,090 --> 00:03:32,190
sorts of standard things you see in

74
00:03:32,190 --> 00:03:34,710
every cryptographic protocol but there

75
00:03:34,710 --> 00:03:37,110
are a number of ways where the

76
00:03:37,110 --> 00:03:38,790
requirements differed pretty strongly

77
00:03:38,790 --> 00:03:42,360
from capabilities provided by things

78
00:03:42,360 --> 00:03:46,290
like TLS the legacy schemes well it's

79
00:03:46,290 --> 00:03:48,420
not quite fair to call the mp3s a legacy

80
00:03:48,420 --> 00:03:50,190
but some of the protocols that are

81
00:03:50,190 --> 00:03:52,050
already in the industry one big way that

82
00:03:52,050 --> 00:03:53,910
it differs is that we wanted our basis

83
00:03:53,910 --> 00:03:57,960
to be on public key cryptography to ease

84
00:03:57,960 --> 00:04:00,210
the burden of key management that we can

85
00:04:00,210 --> 00:04:03,210
never fully get away from anyway so all

86
00:04:03,210 --> 00:04:05,880
the schemes where you only have support

87
00:04:05,880 --> 00:04:07,830
for pre-shared symmetric schemes those

88
00:04:07,830 --> 00:04:10,410
were you know couldn't use those out of

89
00:04:10,410 --> 00:04:13,020
the gate but at the same time we wanted

90
00:04:13,020 --> 00:04:15,330
lower overhead and public key

91
00:04:15,330 --> 00:04:17,579
cryptography and lower overhead don't

92
00:04:17,579 --> 00:04:18,810
always go hand in hand

93
00:04:18,810 --> 00:04:21,390
now so we had to look for sort of more

94
00:04:21,390 --> 00:04:22,830
state-of-the-art solutions using things

95
00:04:22,830 --> 00:04:25,160
like elliptic curves

96
00:04:25,160 --> 00:04:27,419
initially we wanted the implementation

97
00:04:27,419 --> 00:04:29,400
to be an authentication only protocol we

98
00:04:29,400 --> 00:04:33,090
see that is being where most of the user

99
00:04:33,090 --> 00:04:35,039
base will want the protocol to operate

100
00:04:35,039 --> 00:04:36,120
we see this is something that would

101
00:04:36,120 --> 00:04:38,310
operate alongside things like network

102
00:04:38,310 --> 00:04:40,349
security monitoring we don't want to

103
00:04:40,349 --> 00:04:42,449
have to pass private keys all over the

104
00:04:42,449 --> 00:04:44,520
infrastructure just to NSM can look into

105
00:04:44,520 --> 00:04:46,470
the packets but we do want to provide

106
00:04:46,470 --> 00:04:48,300
the option later down the road to be

107
00:04:48,300 --> 00:04:50,190
able to add encryption for applications

108
00:04:50,190 --> 00:04:53,699
where he makes sense we're hoping by I

109
00:04:53,699 --> 00:04:55,949
think the end of this month early next

110
00:04:55,949 --> 00:04:57,419
month to be testing bump in the wire

111
00:04:57,419 --> 00:05:00,150
input implementations and we wanted that

112
00:05:00,150 --> 00:05:02,759
to be possible for at least remote

113
00:05:02,759 --> 00:05:06,599
outstation side of systems where you

114
00:05:06,599 --> 00:05:09,180
would have scalability issues with

115
00:05:09,180 --> 00:05:10,830
changing everything out at once we

116
00:05:10,830 --> 00:05:12,210
wanted to be able to kind of retro

117
00:05:12,210 --> 00:05:14,970
retrofit things and stages but it's

118
00:05:14,970 --> 00:05:16,800
interesting that we aren't actually

119
00:05:16,800 --> 00:05:18,150
providing a bump in the wire solution

120
00:05:18,150 --> 00:05:20,190
that works for master stations but for

121
00:05:20,190 --> 00:05:22,289
those systems you it's more amenable to

122
00:05:22,289 --> 00:05:24,479
changing out the software all at once

123
00:05:24,479 --> 00:05:25,590
versus having to do it

124
00:05:25,590 --> 00:05:28,080
incremental and I think the biggest

125
00:05:28,080 --> 00:05:30,389
thing was that the requirement that this

126
00:05:30,389 --> 00:05:31,919
has to work over a multitude of

127
00:05:31,919 --> 00:05:33,539
transport layers so it had to work over

128
00:05:33,539 --> 00:05:37,020
serial and IP UDP and any kind of stream

129
00:05:37,020 --> 00:05:41,099
or packet oriented transport between

130
00:05:41,099 --> 00:05:43,020
tatoos requirements slide so it there we

131
00:05:43,020 --> 00:05:45,840
go or skip to burst from the run I'll

132
00:05:45,840 --> 00:05:47,909
let you take a peek of this the first

133
00:05:47,909 --> 00:05:49,199
slide I think it accidentally got

134
00:05:49,199 --> 00:05:51,599
skipped but one of the key features

135
00:05:51,599 --> 00:05:52,949
there at the bottom and I mentioned most

136
00:05:52,949 --> 00:05:54,840
of these already is that the protocol

137
00:05:54,840 --> 00:05:56,580
also needed to provide one feature that

138
00:05:56,580 --> 00:05:59,699
TLS doesn't and that's a TTL on messages

139
00:05:59,699 --> 00:06:01,349
so in a lot of timing critical

140
00:06:01,349 --> 00:06:02,639
environments you might not want an

141
00:06:02,639 --> 00:06:03,930
attacker to be able to hold back a

142
00:06:03,930 --> 00:06:06,120
series of packets and then replay them

143
00:06:06,120 --> 00:06:08,099
in rapid succession that's a feature

144
00:06:08,099 --> 00:06:10,500
that we actually borrowed from AJ 12 and

145
00:06:10,500 --> 00:06:14,849
17 11 so you know at this point in the

146
00:06:14,849 --> 00:06:18,389
project we have it's about a 40 page

147
00:06:18,389 --> 00:06:21,240
protocol specification it's been seen by

148
00:06:21,240 --> 00:06:22,710
all the project members a number of

149
00:06:22,710 --> 00:06:25,590
vendors and we're really trying to work

150
00:06:25,590 --> 00:06:27,960
hard to make this an open project and

151
00:06:27,960 --> 00:06:28,940
it's kind of starting to go through

152
00:06:28,940 --> 00:06:31,830
those gates with our project partners

153
00:06:31,830 --> 00:06:35,190
and with legal but I'm hoping that

154
00:06:35,190 --> 00:06:37,560
trying to get lawyers from three

155
00:06:37,560 --> 00:06:37,860
different

156
00:06:37,860 --> 00:06:40,800
utilities to agree as a challenge so I'm

157
00:06:40,800 --> 00:06:42,870
hoping in a not so distant future that's

158
00:06:42,870 --> 00:06:45,420
where the protocol specification will be

159
00:06:45,420 --> 00:06:47,820
and in that same sort of github

160
00:06:47,820 --> 00:06:50,250
organization SS p21 will also have a

161
00:06:50,250 --> 00:06:53,550
repository called SS p21 CP P which

162
00:06:53,550 --> 00:06:55,200
stands for C++ where reference

163
00:06:55,200 --> 00:06:56,970
implementation of the specification will

164
00:06:56,970 --> 00:07:00,600
also live doing some clapping they're

165
00:07:00,600 --> 00:07:04,380
already great so I'm not gonna be able

166
00:07:04,380 --> 00:07:05,970
to cover all the technical details of

167
00:07:05,970 --> 00:07:07,650
the protocol in this session can some

168
00:07:07,650 --> 00:07:10,710
parts are not sabore boring and not so

169
00:07:10,710 --> 00:07:13,110
interesting it's not surprising since

170
00:07:13,110 --> 00:07:14,880
this works over serial that we need some

171
00:07:14,880 --> 00:07:18,360
kind of frame type here not going to

172
00:07:18,360 --> 00:07:19,530
cover that really at all other than to

173
00:07:19,530 --> 00:07:21,330
say that it provides the sort of

174
00:07:21,330 --> 00:07:23,760
features that just about any other skata

175
00:07:23,760 --> 00:07:25,890
protocol would provide there's

176
00:07:25,890 --> 00:07:27,510
destination and source addresses so you

177
00:07:27,510 --> 00:07:29,460
can do things like multi drop it has

178
00:07:29,460 --> 00:07:32,610
some CRC detection using some pretty

179
00:07:32,610 --> 00:07:35,130
modern well vetted CRC algorithms so

180
00:07:35,130 --> 00:07:36,960
that we can distinguish random data

181
00:07:36,960 --> 00:07:38,940
corruption from false positives at the

182
00:07:38,940 --> 00:07:41,250
cryptographic layer so what we're going

183
00:07:41,250 --> 00:07:44,100
to focus on on this presentation is the

184
00:07:44,100 --> 00:07:46,200
cryptographic layer itself and since

185
00:07:46,200 --> 00:07:47,340
there are two completely separate

186
00:07:47,340 --> 00:07:50,190
entities in this sort of two layer

187
00:07:50,190 --> 00:07:52,680
architecture you could do things like

188
00:07:52,680 --> 00:07:54,570
you know not use the link layer at all

189
00:07:54,570 --> 00:07:55,950
and then pass cryptographic layer

190
00:07:55,950 --> 00:07:58,080
messages over some kind of message

191
00:07:58,080 --> 00:07:59,970
oriented transport whether there's UDP

192
00:07:59,970 --> 00:08:02,400
or a message bus or whatever we're

193
00:08:02,400 --> 00:08:03,570
trying to leave that as open and

194
00:08:03,570 --> 00:08:05,730
flexible as possible for people to take

195
00:08:05,730 --> 00:08:08,910
the pieces of ss p21 and use them in

196
00:08:08,910 --> 00:08:11,100
different applications one example would

197
00:08:11,100 --> 00:08:13,380
be that you know we could retrofit dnp3

198
00:08:13,380 --> 00:08:15,990
for instance by inserting the

199
00:08:15,990 --> 00:08:18,180
cryptographic layer between the

200
00:08:18,180 --> 00:08:19,650
transport application layers of the

201
00:08:19,650 --> 00:08:21,480
current dnp3 stack and have a security

202
00:08:21,480 --> 00:08:24,480
nv3 so I think that people I'm hoping

203
00:08:24,480 --> 00:08:25,500
that people will come up with creative

204
00:08:25,500 --> 00:08:31,220
ways to use SSP 121 in existing systems

205
00:08:31,220 --> 00:08:33,630
one of the first things that we decided

206
00:08:33,630 --> 00:08:35,159
when we were looking at how to build a

207
00:08:35,159 --> 00:08:38,850
new protocol well let me back up and say

208
00:08:38,850 --> 00:08:40,590
that I'm all too familiar with input

209
00:08:40,590 --> 00:08:43,950
validation bugs if we wanted to have

210
00:08:43,950 --> 00:08:46,470
very very simple to encode

211
00:08:46,470 --> 00:08:49,770
and to encode messages and we chose to

212
00:08:49,770 --> 00:08:55,050
use a sort of asm1 light light syntax to

213
00:08:55,050 --> 00:08:58,080
define our message formats and the

214
00:08:58,080 --> 00:08:59,880
importance of that is that it makes it

215
00:08:59,880 --> 00:09:02,610
easy for people to generate parsers and

216
00:09:02,610 --> 00:09:05,610
formatters in a very automated way so

217
00:09:05,610 --> 00:09:07,440
instead of hand coding parses and for

218
00:09:07,440 --> 00:09:08,760
matters

219
00:09:08,760 --> 00:09:10,710
we're actually automating that with the

220
00:09:10,710 --> 00:09:13,440
reference implementation but we want

221
00:09:13,440 --> 00:09:15,630
didn't want to use a scheme as complex

222
00:09:15,630 --> 00:09:17,040
as asn.1

223
00:09:17,040 --> 00:09:19,710
so it's been a hotbed of security issues

224
00:09:19,710 --> 00:09:23,250
asn.1 ber dr over the years so none of

225
00:09:23,250 --> 00:09:25,140
that cruft that you people traditionally

226
00:09:25,140 --> 00:09:27,060
hate about asn.1 is in there there's no

227
00:09:27,060 --> 00:09:29,970
embedded length fields only fixed with

228
00:09:29,970 --> 00:09:33,270
integer types no string types at all no

229
00:09:33,270 --> 00:09:36,390
optional types it's very very simple to

230
00:09:36,390 --> 00:09:39,990
write parser for this going to downsizes

231
00:09:39,990 --> 00:09:42,510
is not self describing but I really have

232
00:09:42,510 --> 00:09:44,310
yet to see very many people that

233
00:09:44,310 --> 00:09:46,020
actually use the self describing parts

234
00:09:46,020 --> 00:09:48,150
about asn.1 but without the context of

235
00:09:48,150 --> 00:09:50,280
what fields mean it's not very useful

236
00:09:50,280 --> 00:09:53,070
anyway so on the right there you can see

237
00:09:53,070 --> 00:09:55,170
that's just a definition of an

238
00:09:55,170 --> 00:09:56,790
enumeration and the protocols those are

239
00:09:56,790 --> 00:09:59,190
the different function codes so you know

240
00:09:59,190 --> 00:10:00,540
you should be able to guess that there

241
00:10:00,540 --> 00:10:02,400
are you know six functions in the

242
00:10:02,400 --> 00:10:03,570
cryptographically are six different

243
00:10:03,570 --> 00:10:06,840
message types so here's a message

244
00:10:06,840 --> 00:10:09,750
definition for the first message that

245
00:10:09,750 --> 00:10:12,840
gets sent when what we call an initiator

246
00:10:12,840 --> 00:10:14,670
which would typically be the master in a

247
00:10:14,670 --> 00:10:17,430
system starts a session talking to the

248
00:10:17,430 --> 00:10:18,810
responder which would normally be an

249
00:10:18,810 --> 00:10:21,900
outstation so there's always it starts

250
00:10:21,900 --> 00:10:25,290
with a fixed you know a fixed by request

251
00:10:25,290 --> 00:10:28,970
handshake begin enumeration there's a

252
00:10:28,970 --> 00:10:31,980
16-bit version number for the protocol

253
00:10:31,980 --> 00:10:33,600
so that very early on you can tell the

254
00:10:33,600 --> 00:10:35,670
two sides are speaking the same language

255
00:10:35,670 --> 00:10:38,070
and then there's a number of

256
00:10:38,070 --> 00:10:41,400
enumerations that collectively define we

257
00:10:41,400 --> 00:10:42,870
don't call it a cipher suite because it

258
00:10:42,870 --> 00:10:44,790
might not even use encryption we call it

259
00:10:44,790 --> 00:10:47,190
a crypto suite specification so this is

260
00:10:47,190 --> 00:10:49,410
one area where SS p21 is already

261
00:10:49,410 --> 00:10:52,290
starting to differ from something like

262
00:10:52,290 --> 00:10:55,590
TLS is that we don't do negotiation the

263
00:10:55,590 --> 00:10:58,440
initiator tells the responder these are

264
00:10:58,440 --> 00:10:59,490
the algorithms that you're

265
00:10:59,490 --> 00:11:01,230
going to use and the responder can

266
00:11:01,230 --> 00:11:02,550
always say back you know I don't support

267
00:11:02,550 --> 00:11:04,770
that but you know we're not designing

268
00:11:04,770 --> 00:11:07,410
this for the World Wide Web where you

269
00:11:07,410 --> 00:11:09,360
have you know diverse components from

270
00:11:09,360 --> 00:11:10,830
many many different people and they

271
00:11:10,830 --> 00:11:13,200
might you know want to do negotiation

272
00:11:13,200 --> 00:11:14,690
this is more for private automation

273
00:11:14,690 --> 00:11:17,250
networks where you know the capabilities

274
00:11:17,250 --> 00:11:18,630
of all your components so we're already

275
00:11:18,630 --> 00:11:20,130
starting to remove some of that crust

276
00:11:20,130 --> 00:11:22,980
out of TLS and keep things simple and

277
00:11:22,980 --> 00:11:25,260
then at the bottom the most complex

278
00:11:25,260 --> 00:11:27,240
types that we have in this sort of

279
00:11:27,240 --> 00:11:30,360
grammar so far just opaque sequences or

280
00:11:30,360 --> 00:11:32,970
blobs of things right so that next item

281
00:11:32,970 --> 00:11:36,110
there is the ephemeral public key

282
00:11:36,110 --> 00:11:38,970
sequence eight means that it's prefixed

283
00:11:38,970 --> 00:11:41,220
with an 8-bit count so there can only be

284
00:11:41,220 --> 00:11:44,040
up to 255 bytes in there and then

285
00:11:44,040 --> 00:11:46,380
although we're not supporting PKI yet

286
00:11:46,380 --> 00:11:47,910
and I'll talk about that in a second

287
00:11:47,910 --> 00:11:50,700
there's a placeholder for a sequence of

288
00:11:50,700 --> 00:11:53,040
sequences of those so a certificate

289
00:11:53,040 --> 00:11:55,709
chain so in there are some things

290
00:11:55,709 --> 00:11:57,440
provisions in the grammar there to limit

291
00:11:57,440 --> 00:12:00,029
counts and things because the objectives

292
00:12:00,029 --> 00:12:03,600
are that you can do you can do all of

293
00:12:03,600 --> 00:12:06,390
this without any heap allocation so we

294
00:12:06,390 --> 00:12:08,940
want our parsers and our message for

295
00:12:08,940 --> 00:12:11,220
matters to be able to operate very very

296
00:12:11,220 --> 00:12:12,930
simply not even have to nine have to

297
00:12:12,930 --> 00:12:17,520
malloc four for real-time systems so I

298
00:12:17,520 --> 00:12:19,380
know this is the session right before

299
00:12:19,380 --> 00:12:20,550
lunch now we're gonna do some

300
00:12:20,550 --> 00:12:22,320
cryptography should get everybody really

301
00:12:22,320 --> 00:12:24,630
hungry I know not everybody the crypto

302
00:12:24,630 --> 00:12:27,060
expert or uses cryptography on a daily

303
00:12:27,060 --> 00:12:29,970
basis I'm not a crypto expert so we're

304
00:12:29,970 --> 00:12:31,380
going to go through just some what some

305
00:12:31,380 --> 00:12:34,350
of what these primitives are just so

306
00:12:34,350 --> 00:12:35,579
then we get into some of the more heavy

307
00:12:35,579 --> 00:12:36,720
slides people or know what we're talking

308
00:12:36,720 --> 00:12:38,820
about I think everybody is familiar with

309
00:12:38,820 --> 00:12:40,740
what a hash is right you see houses all

310
00:12:40,740 --> 00:12:42,720
the time and websites it's just a digest

311
00:12:42,720 --> 00:12:45,450
that takes some some input a LeMay ssin

312
00:12:45,450 --> 00:12:48,180
and produces a tag most of you have also

313
00:12:48,180 --> 00:12:50,399
heard what a message authentication code

314
00:12:50,399 --> 00:12:52,410
is or a Mac that's a function that takes

315
00:12:52,410 --> 00:12:55,920
a secret key that you keep private and a

316
00:12:55,920 --> 00:12:57,720
message and produces a digest so that's

317
00:12:57,720 --> 00:12:59,130
one of the fundamental primitives we

318
00:12:59,130 --> 00:13:01,680
used to you know authenticate messages

319
00:13:01,680 --> 00:13:05,010
to go back and forth we also use a key

320
00:13:05,010 --> 00:13:06,480
derivation function key derivation

321
00:13:06,480 --> 00:13:09,120
functions take a salt which can be

322
00:13:09,120 --> 00:13:11,279
publicly known and some input key

323
00:13:11,279 --> 00:13:12,920
material which you want to keep

324
00:13:12,920 --> 00:13:15,379
and they produce some output key data

325
00:13:15,379 --> 00:13:17,569
okay so we use this for our session key

326
00:13:17,569 --> 00:13:21,589
derivation and then last but not least a

327
00:13:21,589 --> 00:13:23,389
diffie-hellman function so

328
00:13:23,389 --> 00:13:25,220
diffie-hellman function takes a private

329
00:13:25,220 --> 00:13:27,109
secret that you know public secret from

330
00:13:27,109 --> 00:13:29,359
somebody else and allows the two parties

331
00:13:29,359 --> 00:13:32,359
to derive a shared secret I talked about

332
00:13:32,359 --> 00:13:34,549
the noise protocol real quick yeah good

333
00:13:34,549 --> 00:13:34,879
point

334
00:13:34,879 --> 00:13:36,889
we borrowed heavily from the noise

335
00:13:36,889 --> 00:13:39,519
protocol which is a framework for

336
00:13:39,519 --> 00:13:42,649
designing security protocols yep

337
00:13:42,649 --> 00:13:45,529
so noise is an effort by Trevor parent

338
00:13:45,529 --> 00:13:47,480
who works a lot with Moxie Marlinspike

339
00:13:47,480 --> 00:13:51,559
and the whisper systems guys and noise

340
00:13:51,559 --> 00:13:53,629
had a ton of features and they were all

341
00:13:53,629 --> 00:13:55,160
really well reviewed but we didn't want

342
00:13:55,160 --> 00:13:56,869
we couldn't use it directly because of a

343
00:13:56,869 --> 00:13:59,299
number of things noise has this neat

344
00:13:59,299 --> 00:14:01,879
feature where it hides metadata like you

345
00:14:01,879 --> 00:14:03,319
don't even know the party is encrypt

346
00:14:03,319 --> 00:14:04,970
first before they exchange certificates

347
00:14:04,970 --> 00:14:06,859
and those kind of things like it's great

348
00:14:06,859 --> 00:14:08,179
if you know if you're journalists in

349
00:14:08,179 --> 00:14:09,649
some like repress country trying to

350
00:14:09,649 --> 00:14:11,749
communicate a vat or exit node right but

351
00:14:11,749 --> 00:14:14,809
not so applicable necessarily for ICS so

352
00:14:14,809 --> 00:14:16,160
you know we tune down some of those

353
00:14:16,160 --> 00:14:18,019
things that were more like super privacy

354
00:14:18,019 --> 00:14:20,779
oriented an encryption oriented but we

355
00:14:20,779 --> 00:14:23,600
are reusing a lot of the same primitives

356
00:14:23,600 --> 00:14:28,399
and compositions so those are the

357
00:14:28,399 --> 00:14:30,619
abstract crypto functions right I do

358
00:14:30,619 --> 00:14:32,720
want to mention some of the actual

359
00:14:32,720 --> 00:14:34,309
concrete primitives that we're using

360
00:14:34,309 --> 00:14:36,290
shouldn't be surprising that one of the

361
00:14:36,290 --> 00:14:38,989
options is shot to we're also looking at

362
00:14:38,989 --> 00:14:40,970
the Blake family of hash functions -

363
00:14:40,970 --> 00:14:42,739
they're really fast and software we can

364
00:14:42,739 --> 00:14:44,419
get latency down during the session when

365
00:14:44,419 --> 00:14:48,169
our authenticating tags obviously if

366
00:14:48,169 --> 00:14:50,179
we're using sha we're using H max sha

367
00:14:50,179 --> 00:14:52,189
we're looking at keyed Blake - as an

368
00:14:52,189 --> 00:14:54,769
option for a Mac the KDF that we

369
00:14:54,769 --> 00:14:59,470
inherited from noise is a HKD F hash

370
00:14:59,470 --> 00:15:01,699
HMAC derivation function you can go look

371
00:15:01,699 --> 00:15:04,039
at the RFC we're also looking at having

372
00:15:04,039 --> 00:15:05,869
a secondary option is we want multiple

373
00:15:05,869 --> 00:15:07,819
options so there's no one you know

374
00:15:07,819 --> 00:15:09,139
crypto component that can be found

375
00:15:09,139 --> 00:15:10,459
vulnerable and suddenly we have a

376
00:15:10,459 --> 00:15:12,470
useless protocol and then to the

377
00:15:12,470 --> 00:15:14,779
diffie-hellman function our first option

378
00:15:14,779 --> 00:15:16,480
there they were implementing his curve

379
00:15:16,480 --> 00:15:20,059
two to five and one nine which is a it's

380
00:15:20,059 --> 00:15:21,739
a dippy Hellman scheme and a digital

381
00:15:21,739 --> 00:15:23,569
signature scheme that Daniel Bernstein

382
00:15:23,569 --> 00:15:26,220
and his team have put out and one of the

383
00:15:26,220 --> 00:15:28,190
Isis things about it is it's really fast

384
00:15:28,190 --> 00:15:32,610
one and two it's really easy to write

385
00:15:32,610 --> 00:15:34,640
implementations that are constant time

386
00:15:34,640 --> 00:15:39,330
that don't have easy side channels there

387
00:15:39,330 --> 00:15:41,100
are a number of good implementations of

388
00:15:41,100 --> 00:15:44,820
that and number of languages okay so now

389
00:15:44,820 --> 00:15:47,970
we get to get into the meat of power key

390
00:15:47,970 --> 00:15:50,850
agreement and things work we have a four

391
00:15:50,850 --> 00:15:53,460
message handshake so that's two back and

392
00:15:53,460 --> 00:15:56,040
forth round trips in some systems that

393
00:15:56,040 --> 00:15:59,400
second back-and-forth round trip could

394
00:15:59,400 --> 00:16:01,560
be optional okay so what happens in the

395
00:16:01,560 --> 00:16:03,990
first message is the initiator sends an

396
00:16:03,990 --> 00:16:06,390
ephemeral public key and some metadata

397
00:16:06,390 --> 00:16:08,130
for the cryptography seeds is I'd like

398
00:16:08,130 --> 00:16:10,500
to start a session okay then the

399
00:16:10,500 --> 00:16:12,390
responder sends back yes let's do this

400
00:16:12,390 --> 00:16:14,370
here's my ephemeral public key you know

401
00:16:14,370 --> 00:16:17,010
I support all those algorithms and then

402
00:16:17,010 --> 00:16:19,200
they derive some keys together and then

403
00:16:19,200 --> 00:16:20,610
the second two messages are all about

404
00:16:20,610 --> 00:16:22,950
the authentication step noise didn't

405
00:16:22,950 --> 00:16:24,480
have that second authentication step

406
00:16:24,480 --> 00:16:25,950
noise would then just start transmitting

407
00:16:25,950 --> 00:16:28,140
and if the message tags failed you

408
00:16:28,140 --> 00:16:30,300
weren't authenticated but for session

409
00:16:30,300 --> 00:16:32,220
'less environments we didn't want you

410
00:16:32,220 --> 00:16:35,970
know one party on a bus and I think

411
00:16:35,970 --> 00:16:38,490
about rs45 or multi-channel radio just

412
00:16:38,490 --> 00:16:39,930
to be able to blow wave sessions with a

413
00:16:39,930 --> 00:16:42,450
single message so we have this secondary

414
00:16:42,450 --> 00:16:44,460
authentication step with the second two

415
00:16:44,460 --> 00:16:46,070
messages there

416
00:16:46,070 --> 00:16:49,290
so quick review of diffie-hellman with

417
00:16:49,290 --> 00:16:52,560
some graphics to parties we'll have to

418
00:16:52,560 --> 00:16:54,750
keep airs right key pair public key a

419
00:16:54,750 --> 00:16:58,530
private key they send each other their

420
00:16:58,530 --> 00:17:02,520
public keys and then each party is able

421
00:17:02,520 --> 00:17:03,990
to use the diffie-hellman function to

422
00:17:03,990 --> 00:17:06,839
derive a shared secret okay so this is

423
00:17:06,839 --> 00:17:07,980
going to become important on the next

424
00:17:07,980 --> 00:17:11,430
slide in our key agreement scheme we

425
00:17:11,430 --> 00:17:14,220
root our trust in long term static

426
00:17:14,220 --> 00:17:16,560
diffie-hellman key so that's a little

427
00:17:16,560 --> 00:17:18,720
different than a lot of public key

428
00:17:18,720 --> 00:17:21,000
protocols that might route it in say

429
00:17:21,000 --> 00:17:23,280
like an RSA key which would be more of a

430
00:17:23,280 --> 00:17:26,280
public signing key for digital signature

431
00:17:26,280 --> 00:17:27,900
not at a dippy Hellman piece that's one

432
00:17:27,900 --> 00:17:30,120
area where we've used some concepts from

433
00:17:30,120 --> 00:17:33,000
noise so the first thing that happens is

434
00:17:33,000 --> 00:17:37,170
the initiator derives a ephemeral dizzi

435
00:17:37,170 --> 00:17:38,670
Hellman key then that's denoted with

436
00:17:38,670 --> 00:17:39,480
this

437
00:17:39,480 --> 00:17:41,340
ISA buys that static key for the

438
00:17:41,340 --> 00:17:42,840
initiator ephemeral key for the

439
00:17:42,840 --> 00:17:44,970
initiator static key for the responder

440
00:17:44,970 --> 00:17:46,639
and ephemeral key for the responder and

441
00:17:46,639 --> 00:17:49,740
the initiator sends this first message

442
00:17:49,740 --> 00:17:52,980
that contains his ephemeral public key

443
00:17:52,980 --> 00:17:56,970
and Static public key which might later

444
00:17:56,970 --> 00:17:59,190
be embedded into some certificates in

445
00:17:59,190 --> 00:18:01,409
the mode where we have only pre-shared

446
00:18:01,409 --> 00:18:03,149
keys where you use the protocol like you

447
00:18:03,149 --> 00:18:04,889
would use PGP mail where people sort of

448
00:18:04,889 --> 00:18:07,320
share their public keys out-of-band that

449
00:18:07,320 --> 00:18:08,850
static key might not actually be in that

450
00:18:08,850 --> 00:18:11,970
message and then both parties before

451
00:18:11,970 --> 00:18:12,840
they do any other cryptographic

452
00:18:12,840 --> 00:18:15,210
operations initialize this variable

453
00:18:15,210 --> 00:18:18,299
called ck that we call a chaining key so

454
00:18:18,299 --> 00:18:20,100
they just hash the entire message and

455
00:18:20,100 --> 00:18:21,870
this whole point of this chaining key

456
00:18:21,870 --> 00:18:23,130
that you're going to see in the next few

457
00:18:23,130 --> 00:18:26,279
steps is foreign handshake integrity so

458
00:18:26,279 --> 00:18:28,289
we keep a running hash of everything

459
00:18:28,289 --> 00:18:29,820
that both sides sent for the whole

460
00:18:29,820 --> 00:18:31,889
message and that's the sort of

461
00:18:31,889 --> 00:18:33,539
protection that's designed to protect

462
00:18:33,539 --> 00:18:35,490
against things like downgrade attacks to

463
00:18:35,490 --> 00:18:37,350
make the protocol future-proof so that

464
00:18:37,350 --> 00:18:38,700
man in the middle can't manipulate

465
00:18:38,700 --> 00:18:42,960
handshake values so the responder

466
00:18:42,960 --> 00:18:44,820
receives that message produces the same

467
00:18:44,820 --> 00:18:47,639
chaining key and responds with his

468
00:18:47,639 --> 00:18:50,130
ephemeral public key possibly it's

469
00:18:50,130 --> 00:18:51,870
staticky embedded in some certificates

470
00:18:51,870 --> 00:18:54,299
passes the message the initiator

471
00:18:54,299 --> 00:18:57,149
receives the response and hashes the

472
00:18:57,149 --> 00:18:59,760
message so at this point both parties

473
00:18:59,760 --> 00:19:01,289
had exchanged their ephemeral key data

474
00:19:01,289 --> 00:19:03,929
and they both should agree on the ck if

475
00:19:03,929 --> 00:19:05,299
somebody in the middle hasn't

476
00:19:05,299 --> 00:19:07,880
manipulated the messages in someone

477
00:19:07,880 --> 00:19:09,990
now we're here's where things get

478
00:19:09,990 --> 00:19:13,019
interesting both parties do a key

479
00:19:13,019 --> 00:19:15,990
derivation ok so they use the chaining

480
00:19:15,990 --> 00:19:17,669
key which is completely public

481
00:19:17,669 --> 00:19:19,529
information right at this point any man

482
00:19:19,529 --> 00:19:20,610
in the middle could see those messages

483
00:19:20,610 --> 00:19:23,130
that are exchanged he uses that in the

484
00:19:23,130 --> 00:19:26,100
KDF as the salt and then he performed

485
00:19:26,100 --> 00:19:27,870
each side performs three diffie-hellman

486
00:19:27,870 --> 00:19:30,659
operations and if you look carefully at

487
00:19:30,659 --> 00:19:32,190
what these VP Hellman operations are

488
00:19:32,190 --> 00:19:35,159
doing is they're doing this

489
00:19:35,159 --> 00:19:37,289
diffie-hellman operation would be just

490
00:19:37,289 --> 00:19:39,870
like in TLS it's between the ephemeral

491
00:19:39,870 --> 00:19:42,269
private and public keys and the second

492
00:19:42,269 --> 00:19:45,210
two are permutations between the static

493
00:19:45,210 --> 00:19:47,940
and the public keys so that's basically

494
00:19:47,940 --> 00:19:51,210
how we accomplish where we're going to

495
00:19:51,210 --> 00:19:53,090
accomplish authentication with public

496
00:19:53,090 --> 00:19:54,620
photography without using digital

497
00:19:54,620 --> 00:19:57,620
signatures so we're mixing in these

498
00:19:57,620 --> 00:20:00,830
permutations between the static and

499
00:20:00,830 --> 00:20:03,790
ephemeral keys as the input into the KDF

500
00:20:03,790 --> 00:20:06,350
so we concatenate these three different

501
00:20:06,350 --> 00:20:08,810
results and that is the second argument

502
00:20:08,810 --> 00:20:11,930
into the key DF KDF and then we actually

503
00:20:11,930 --> 00:20:14,600
derive two keys from that we derive a

504
00:20:14,600 --> 00:20:17,030
new chaining key value and a key that we

505
00:20:17,030 --> 00:20:18,800
call the authentication key that we're

506
00:20:18,800 --> 00:20:20,270
going to use it to authenticate and the

507
00:20:20,270 --> 00:20:23,690
second two messages of a handshake so

508
00:20:23,690 --> 00:20:26,420
each side now has a chaining key in an

509
00:20:26,420 --> 00:20:29,150
authentication key and the initiator

510
00:20:29,150 --> 00:20:31,190
sends a message that's a pure

511
00:20:31,190 --> 00:20:32,930
authentication message in fact the Mac

512
00:20:32,930 --> 00:20:35,060
is calculated just over the fixed

513
00:20:35,060 --> 00:20:38,540
pattern oxo 1 the other side receives it

514
00:20:38,540 --> 00:20:40,970
you know rehashes it we're keeping that

515
00:20:40,970 --> 00:20:42,800
running hash going of the conversation

516
00:20:42,800 --> 00:20:44,690
and then the same thing in the other

517
00:20:44,690 --> 00:20:45,920
direction of except for the max

518
00:20:45,920 --> 00:20:48,230
calculated of a new value so at this

519
00:20:48,230 --> 00:20:50,630
point both parties you know know that

520
00:20:50,630 --> 00:20:51,950
they're talking to somebody that was

521
00:20:51,950 --> 00:20:56,270
able to derive the correct keys so

522
00:20:56,270 --> 00:20:59,750
they've been Takei today now the last

523
00:20:59,750 --> 00:21:01,760
step is to drive the actual session keys

524
00:21:01,760 --> 00:21:05,750
and to do that we just basically just

525
00:21:05,750 --> 00:21:07,220
split the chaining key so the

526
00:21:07,220 --> 00:21:08,740
authentication key that we use is

527
00:21:08,740 --> 00:21:10,790
cryptographically independent from the

528
00:21:10,790 --> 00:21:13,010
chaining key which came out of KDF and

529
00:21:13,010 --> 00:21:17,080
we split that ck using the KDF into

530
00:21:17,080 --> 00:21:20,270
transmit session keys and receive

531
00:21:20,270 --> 00:21:22,310
session keys so you can see that these

532
00:21:22,310 --> 00:21:23,960
are flipped here because the two sides

533
00:21:23,960 --> 00:21:25,880
are going to use the keys one for

534
00:21:25,880 --> 00:21:27,770
receive one for transmit in the opposite

535
00:21:27,770 --> 00:21:30,860
direction ok great so we have a session

536
00:21:30,860 --> 00:21:33,230
now right we have session keys that we

537
00:21:33,230 --> 00:21:34,490
can use so what are the limits to those

538
00:21:34,490 --> 00:21:38,570
session keys right now we have a nonce

539
00:21:38,570 --> 00:21:40,280
defined on the messages just to be a

540
00:21:40,280 --> 00:21:42,560
16-bit value which writer the gate

541
00:21:42,560 --> 00:21:44,630
that's going to limit you this 65,000 or

542
00:21:44,630 --> 00:21:47,960
so messages per session before you have

543
00:21:47,960 --> 00:21:50,060
to renegotiate or do something we

544
00:21:50,060 --> 00:21:51,800
haven't really decided on defaults for

545
00:21:51,800 --> 00:21:53,780
what that might be it could be part of

546
00:21:53,780 --> 00:21:55,640
what the initiator sends in the

547
00:21:55,640 --> 00:21:57,320
handshake message you know thou shalt

548
00:21:57,320 --> 00:21:59,450
not use your knots for more than these

549
00:21:59,450 --> 00:22:02,630
values or so forth and then the other

550
00:22:02,630 --> 00:22:04,640
limit will be sort of the classical

551
00:22:04,640 --> 00:22:07,330
time-based timeout

552
00:22:07,330 --> 00:22:11,810
we have a 32-bit field on the session

553
00:22:11,810 --> 00:22:12,500
messages

554
00:22:12,500 --> 00:22:14,600
that's millisecond since the session

555
00:22:14,600 --> 00:22:17,720
began that we use is that TTL so that

556
00:22:17,720 --> 00:22:20,000
limits us to sessions not lasting longer

557
00:22:20,000 --> 00:22:22,130
than 49 days I think most people going

558
00:22:22,130 --> 00:22:23,780
to want to renegotiate sessions faster

559
00:22:23,780 --> 00:22:26,060
than me 49 days so that's that's not a

560
00:22:26,060 --> 00:22:29,300
limit there so here's what the actual

561
00:22:29,300 --> 00:22:31,420
session messages look like once again

562
00:22:31,420 --> 00:22:36,280
reusing our our grammar the auth

563
00:22:36,280 --> 00:22:39,320
metadata has been pulled out of the

564
00:22:39,320 --> 00:22:40,940
session message so that's just a struct

565
00:22:40,940 --> 00:22:44,170
in here and in fact if these values were

566
00:22:44,170 --> 00:22:46,700
directly inside this definition it would

567
00:22:46,700 --> 00:22:49,340
produce the same serialization this is

568
00:22:49,340 --> 00:22:53,950
just so that we can define the data very

569
00:22:53,950 --> 00:22:56,690
explicitly that also needs to be covered

570
00:22:56,690 --> 00:22:59,090
by the authentication tag so this data

571
00:22:59,090 --> 00:23:01,400
the knots and the validity are never

572
00:23:01,400 --> 00:23:03,410
encrypted under any of the session

573
00:23:03,410 --> 00:23:06,740
session suites are always clear text but

574
00:23:06,740 --> 00:23:08,540
they always need to be covered by

575
00:23:08,540 --> 00:23:10,700
whatever the authentication tag happens

576
00:23:10,700 --> 00:23:13,040
to be whether that's a Mac or whether

577
00:23:13,040 --> 00:23:15,200
that's the tag in a authenticated

578
00:23:15,200 --> 00:23:17,690
encryption mode and then in the session

579
00:23:17,690 --> 00:23:21,110
data message all we really have are that

580
00:23:21,110 --> 00:23:24,020
metadata that needs to be signed a clear

581
00:23:24,020 --> 00:23:26,780
text or encrypted payload for the actual

582
00:23:26,780 --> 00:23:29,000
you know application layer protocol that

583
00:23:29,000 --> 00:23:31,610
we're protecting and the authentication

584
00:23:31,610 --> 00:23:34,760
tag itself which might be a Mac or it

585
00:23:34,760 --> 00:23:37,310
might be an AE AE tags or something like

586
00:23:37,310 --> 00:23:42,350
a AES GCM so that's the basics of the

587
00:23:42,350 --> 00:23:46,880
protocol that's kind of what our first

588
00:23:46,880 --> 00:23:50,570
version of the spec defines it defines

589
00:23:50,570 --> 00:23:52,610
basically using pre shared public keys

590
00:23:52,610 --> 00:23:54,140
the next phase is down the road are

591
00:23:54,140 --> 00:23:55,870
going to be add PKI

592
00:23:55,870 --> 00:23:58,670
ok is we're calling it because yeah we

593
00:23:58,670 --> 00:24:01,240
really want a much lightweight simple

594
00:24:01,240 --> 00:24:04,220
and the way that you know devices get

595
00:24:04,220 --> 00:24:06,080
authenticated in an ICS environment is

596
00:24:06,080 --> 00:24:08,960
very different than you know in an IP

597
00:24:08,960 --> 00:24:11,420
world you know why don't you tell us

598
00:24:11,420 --> 00:24:14,060
about the intent for the reference

599
00:24:14,060 --> 00:24:17,330
implementation so this is basically -

600
00:24:17,330 --> 00:24:19,520
it's going to be open source a BSD

601
00:24:19,520 --> 00:24:20,570
license

602
00:24:20,570 --> 00:24:23,179
to beat there'll be no intellectual

603
00:24:23,179 --> 00:24:26,299
property associated with it so we really

604
00:24:26,299 --> 00:24:28,549
want vendors to implement this in the

605
00:24:28,549 --> 00:24:31,759
products and as utilities right we don't

606
00:24:31,759 --> 00:24:34,039
need to make money off of off of a

607
00:24:34,039 --> 00:24:36,529
protocol we really want to reduce the

608
00:24:36,529 --> 00:24:38,870
barriers to implementation so with a

609
00:24:38,870 --> 00:24:40,789
reference implementation you know they

610
00:24:40,789 --> 00:24:42,679
can start with with running code and

611
00:24:42,679 --> 00:24:47,110
then adapt it to their product and I

612
00:24:47,110 --> 00:24:50,389
have the bsd 3 license and we are having

613
00:24:50,389 --> 00:24:53,330
the lawrence livermore do the validation

614
00:24:53,330 --> 00:24:55,940
and verification of the protocol as a

615
00:24:55,940 --> 00:24:58,460
chime we we do an enhancement to it to

616
00:24:58,460 --> 00:25:02,509
provide like an independent analysis of

617
00:25:02,509 --> 00:25:05,269
it I think reference implementations are

618
00:25:05,269 --> 00:25:06,889
something we really fall down on this in

619
00:25:06,889 --> 00:25:09,049
this industry we pay armies of

620
00:25:09,049 --> 00:25:11,000
consultants many years to construct

621
00:25:11,000 --> 00:25:14,059
thousand-page IEC and I Triple E specs

622
00:25:14,059 --> 00:25:16,610
and by the time they get the plugfest

623
00:25:16,610 --> 00:25:18,830
things are so inherently complicated

624
00:25:18,830 --> 00:25:21,019
that people can't talk to each other so

625
00:25:21,019 --> 00:25:22,309
this is something I think that we're

626
00:25:22,309 --> 00:25:24,799
hoping to put out as a working prototype

627
00:25:24,799 --> 00:25:27,500
with with production you know quality

628
00:25:27,500 --> 00:25:28,940
code we're going to take it some real

629
00:25:28,940 --> 00:25:31,549
efforts to make sure that the code is is

630
00:25:31,549 --> 00:25:36,350
very sound but I'm hoping that that

631
00:25:36,350 --> 00:25:39,289
label us to accelerate our period until

632
00:25:39,289 --> 00:25:41,809
until adoption yeah we're having by

633
00:25:41,809 --> 00:25:42,529
actually having a reference

634
00:25:42,529 --> 00:25:44,629
implementation we're also looking at

635
00:25:44,629 --> 00:25:47,509
doing a bug bounty as well so to you

636
00:25:47,509 --> 00:25:49,279
know try to hire you and that reference

637
00:25:49,279 --> 00:25:50,509
implementation one of the greatest

638
00:25:50,509 --> 00:25:52,220
things about reference implementations

639
00:25:52,220 --> 00:25:54,529
and doing them in combination with the

640
00:25:54,529 --> 00:25:56,019
spec is you get to do this iteratively

641
00:25:56,019 --> 00:25:57,980
right I mean we're already making

642
00:25:57,980 --> 00:25:59,509
changes to the specification because

643
00:25:59,509 --> 00:26:00,889
it's like you find something that's

644
00:26:00,889 --> 00:26:02,600
really hard to implement it's really

645
00:26:02,600 --> 00:26:03,889
hard to implement well we can change the

646
00:26:03,889 --> 00:26:06,289
spec at this point and that's the

647
00:26:06,289 --> 00:26:07,759
approach that we're trying to trying to

648
00:26:07,759 --> 00:26:10,519
follow so I'm going to give you some

649
00:26:10,519 --> 00:26:11,840
technical highlights of what we're doing

650
00:26:11,840 --> 00:26:14,139
with the reference implementation

651
00:26:14,139 --> 00:26:17,120
because we are looking to deploy this in

652
00:26:17,120 --> 00:26:19,190
embedded products we are using a native

653
00:26:19,190 --> 00:26:20,659
language so it's a really lightweight

654
00:26:20,659 --> 00:26:23,690
subset of C++ it's a subset that I've

655
00:26:23,690 --> 00:26:25,309
used and even embedded on things like

656
00:26:25,309 --> 00:26:29,809
microcontrollers before so some of the

657
00:26:29,809 --> 00:26:31,519
things you'd expect from embedded code

658
00:26:31,519 --> 00:26:33,350
no heap allocation after initialization

659
00:26:33,350 --> 00:26:34,279
as a general rule

660
00:26:34,279 --> 00:26:36,019
we're not using a lot of advanced C++

661
00:26:36,019 --> 00:26:38,029
features like exceptions all those

662
00:26:38,029 --> 00:26:39,349
things that you would normally turn off

663
00:26:39,349 --> 00:26:41,269
anyway if you're trying to get C++

664
00:26:41,269 --> 00:26:46,429
running basically as a C without the C++

665
00:26:46,429 --> 00:26:49,070
runtime library I think I already

666
00:26:49,070 --> 00:26:50,479
mentioned this all the parsers and

667
00:26:50,479 --> 00:26:52,190
formatters are being generated from a

668
00:26:52,190 --> 00:26:54,499
model of the grammar so we don't have a

669
00:26:54,499 --> 00:26:56,029
compiler that takes those message

670
00:26:56,029 --> 00:26:58,609
definitions but we are modeling the

671
00:26:58,609 --> 00:27:00,019
messages and I'll show you actually a

672
00:27:00,019 --> 00:27:01,609
screenshot here in a second and spitting

673
00:27:01,609 --> 00:27:03,679
out our parses and grammars and the

674
00:27:03,679 --> 00:27:06,320
cryptographic plug-in is the

675
00:27:06,320 --> 00:27:07,580
cryptographic back-end is fully

676
00:27:07,580 --> 00:27:09,080
pluggable so we're doing everything

677
00:27:09,080 --> 00:27:11,450
right now with Lib sodium but if people

678
00:27:11,450 --> 00:27:13,609
have like hardware accelerators for some

679
00:27:13,609 --> 00:27:15,619
the primitives that we have you can swap

680
00:27:15,619 --> 00:27:17,719
all that out very easily or use a

681
00:27:17,719 --> 00:27:21,169
different library entirely so I don't

682
00:27:21,169 --> 00:27:23,089
know how well people are going to be

683
00:27:23,089 --> 00:27:25,339
able to read that but I think you can

684
00:27:25,339 --> 00:27:26,779
read this right I mean this is our

685
00:27:26,779 --> 00:27:28,219
number one goal with the reference

686
00:27:28,219 --> 00:27:29,570
implementation is to create code that

687
00:27:29,570 --> 00:27:31,729
looks like the specification I think if

688
00:27:31,729 --> 00:27:33,080
I point to some things on here you'll

689
00:27:33,080 --> 00:27:34,700
probably be able to tell what this is

690
00:27:34,700 --> 00:27:36,950
it just says derive authentication key

691
00:27:36,950 --> 00:27:39,169
and here are the three deputy Hellman

692
00:27:39,169 --> 00:27:42,049
operations and there's the KDF being

693
00:27:42,049 --> 00:27:44,299
called so I mean this is just one

694
00:27:44,299 --> 00:27:46,070
example cherry picked out of the code

695
00:27:46,070 --> 00:27:47,779
base to show that you know we're really

696
00:27:47,779 --> 00:27:49,099
trying to make the code look like the

697
00:27:49,099 --> 00:27:54,080
spec here's a screenshot of the DSL for

698
00:27:54,080 --> 00:27:55,609
the messages so this is the same

699
00:27:55,609 --> 00:27:58,789
initiate handshake message modeled in

700
00:27:58,789 --> 00:28:00,799
skaila just because I happen to like

701
00:28:00,799 --> 00:28:02,029
that as a language for doing code

702
00:28:02,029 --> 00:28:03,950
generation so you can see the message

703
00:28:03,950 --> 00:28:05,989
fields here to find you know a human

704
00:28:05,989 --> 00:28:07,580
readable name for logging and pretty

705
00:28:07,580 --> 00:28:09,710
printing purposes and the function code

706
00:28:09,710 --> 00:28:12,799
defined so this line is all we need to

707
00:28:12,799 --> 00:28:14,809
do to spit out a new message type for

708
00:28:14,809 --> 00:28:17,299
manipulated message type and it's not

709
00:28:17,299 --> 00:28:19,099
just for security purposes it's also for

710
00:28:19,099 --> 00:28:21,080
just productivity purposes as we change

711
00:28:21,080 --> 00:28:22,669
the messages now it's fields as this

712
00:28:22,669 --> 00:28:24,769
early version of the spec evolves it's

713
00:28:24,769 --> 00:28:26,239
already beginning to save a lot of time

714
00:28:26,239 --> 00:28:27,830
to kind of generate a lot of this stuff

715
00:28:27,830 --> 00:28:30,139
and there you can see the header file

716
00:28:30,139 --> 00:28:33,469
that that model actually spits out and

717
00:28:33,469 --> 00:28:34,729
the implementation file would probably

718
00:28:34,729 --> 00:28:36,200
be more interesting to folks to see what

719
00:28:36,200 --> 00:28:37,549
we're actually doing with the parsers

720
00:28:37,549 --> 00:28:40,700
and stuff to make them safe but this

721
00:28:40,700 --> 00:28:45,139
message is doing basically zero copy

722
00:28:45,139 --> 00:28:47,490
parsing so we

723
00:28:47,490 --> 00:28:49,170
you when you parse things that are

724
00:28:49,170 --> 00:28:50,910
variable-length it'll return like a

725
00:28:50,910 --> 00:28:53,100
slice of that buffer so it doesn't even

726
00:28:53,100 --> 00:28:57,600
have to do copying and so forth I've got

727
00:28:57,600 --> 00:28:58,500
a little bit of experience with

728
00:28:58,500 --> 00:29:00,450
community building from running open

729
00:29:00,450 --> 00:29:03,170
dnp3 so I know that things that

730
00:29:03,170 --> 00:29:05,700
developers and companies that are

731
00:29:05,700 --> 00:29:08,520
looking at open source look for in terms

732
00:29:08,520 --> 00:29:11,880
of quality so we've already got a CI

733
00:29:11,880 --> 00:29:14,940
server stood up right now it's private

734
00:29:14,940 --> 00:29:16,350
to members of the group but we're hoping

735
00:29:16,350 --> 00:29:18,390
to make that public you know we're doing

736
00:29:18,390 --> 00:29:20,940
things like on every build pulling down

737
00:29:20,940 --> 00:29:24,030
the code running unit tests running some

738
00:29:24,030 --> 00:29:27,090
static analysis when the code goes

739
00:29:27,090 --> 00:29:28,740
open-source I'm hoping that we'll be

740
00:29:28,740 --> 00:29:30,600
able to use some of the more capable

741
00:29:30,600 --> 00:29:33,030
commercial static analysis programs like

742
00:29:33,030 --> 00:29:34,980
Coverity that you know offer free

743
00:29:34,980 --> 00:29:36,390
licenses and stuff for open source

744
00:29:36,390 --> 00:29:40,320
projects and I'd like to also start

745
00:29:40,320 --> 00:29:42,179
doing some fuzzing with you know

746
00:29:42,179 --> 00:29:44,610
programs like AFL and so forth although

747
00:29:44,610 --> 00:29:46,620
I'm pretty confident that our parsers

748
00:29:46,620 --> 00:29:49,320
are pretty solid so that will be

749
00:29:49,320 --> 00:29:52,500
available to community members as well

750
00:29:52,500 --> 00:29:55,590
and this is the timeline for the things

751
00:29:55,590 --> 00:29:56,760
that we have coming and I think I'll let

752
00:29:56,760 --> 00:29:59,790
rich talk about this so this is for the

753
00:29:59,790 --> 00:30:02,010
next phase when we're going to be adding

754
00:30:02,010 --> 00:30:05,940
in the utility key infrastructure and

755
00:30:05,940 --> 00:30:07,860
this just kind of shows the iterations

756
00:30:07,860 --> 00:30:10,440
of you know putting in a specification

757
00:30:10,440 --> 00:30:12,960
and upgrading the reference

758
00:30:12,960 --> 00:30:15,870
implementation as we get into the

759
00:30:15,870 --> 00:30:17,370
utility key infrastructure we're

760
00:30:17,370 --> 00:30:19,860
actually what we're looking at some

761
00:30:19,860 --> 00:30:22,140
things where we could use something like

762
00:30:22,140 --> 00:30:24,809
a security automation orchestration

763
00:30:24,809 --> 00:30:27,420
platform where you know the messaging

764
00:30:27,420 --> 00:30:30,090
between the master and the proxy if you

765
00:30:30,090 --> 00:30:33,179
will would be would be simple but then

766
00:30:33,179 --> 00:30:36,240
how utilities or how any company wants

767
00:30:36,240 --> 00:30:37,620
to go and actually implement the way

768
00:30:37,620 --> 00:30:39,120
they validate their devices can be

769
00:30:39,120 --> 00:30:41,880
flexible and and designed as a playbook

770
00:30:41,880 --> 00:30:47,160
the other thing to bring up here is as

771
00:30:47,160 --> 00:30:50,059
we the the protocol and the

772
00:30:50,059 --> 00:30:52,800
specification get hardened we are going

773
00:30:52,800 --> 00:30:54,410
to go and work with a standards body

774
00:30:54,410 --> 00:30:57,660
most likely Oasis because we have

775
00:30:57,660 --> 00:30:59,669
experience with them you heard my

776
00:30:59,669 --> 00:31:01,170
colleague Dan talking about

777
00:31:01,170 --> 00:31:04,110
so sticks is being standardized by Oasis

778
00:31:04,110 --> 00:31:06,570
and they do a really good job not a lot

779
00:31:06,570 --> 00:31:08,700
of the bureaucracy that there is and

780
00:31:08,700 --> 00:31:11,490
like I Tripoli and so so this will

781
00:31:11,490 --> 00:31:14,450
become a standard based implementation

782
00:31:14,450 --> 00:31:18,150
and I think I think there's a lot of

783
00:31:18,150 --> 00:31:21,530
other applications besides ICS for a

784
00:31:21,530 --> 00:31:24,440
machine to machine security protocol

785
00:31:24,440 --> 00:31:26,850
purpose-built for machine machine

786
00:31:26,850 --> 00:31:29,700
communications low bandwidth low CPU are

787
00:31:29,700 --> 00:31:31,500
applicable right think Internet of

788
00:31:31,500 --> 00:31:34,800
Things and so forth so you know I think

789
00:31:34,800 --> 00:31:36,330
working with a standards body will help

790
00:31:36,330 --> 00:31:38,340
expose us to other verticals and so

791
00:31:38,340 --> 00:31:42,780
forth so kind of closing on a couple

792
00:31:42,780 --> 00:31:45,360
other things for our next phases I I

793
00:31:45,360 --> 00:31:49,170
think that there's a need for things

794
00:31:49,170 --> 00:31:52,260
lighter weight than TLS and x.509 okay

795
00:31:52,260 --> 00:31:55,230
you know x.509 certificates with RSA are

796
00:31:55,230 --> 00:31:57,060
multiple kilobytes you're not going to

797
00:31:57,060 --> 00:31:59,610
be pushing that down a 1,200 baud Radio

798
00:31:59,610 --> 00:32:02,070
linker or so forth so you know we've

799
00:32:02,070 --> 00:32:04,950
been looking to see you know there are

800
00:32:04,950 --> 00:32:06,600
other standards and stuff out there and

801
00:32:06,600 --> 00:32:09,390
there really aren't a lot of stuff you

802
00:32:09,390 --> 00:32:10,800
would think that there were for embedded

803
00:32:10,800 --> 00:32:12,570
systems or near field communications we

804
00:32:12,570 --> 00:32:13,980
found one called machine to machine

805
00:32:13,980 --> 00:32:18,180
format but it's really to x.509 like I

806
00:32:18,180 --> 00:32:19,800
mean they're still using asn.1 it's

807
00:32:19,800 --> 00:32:21,870
still pretty heavy they've reduced the

808
00:32:21,870 --> 00:32:23,820
size of fair bit but it's still carrying

809
00:32:23,820 --> 00:32:28,110
a lot of baggage from from x.509 and we

810
00:32:28,110 --> 00:32:29,700
really want to stay away from that term

811
00:32:29,700 --> 00:32:32,250
for our embedded systems yeah you know

812
00:32:32,250 --> 00:32:34,860
another feature there is the is the fast

813
00:32:34,860 --> 00:32:37,080
revocation sort of the implied we're

814
00:32:37,080 --> 00:32:38,820
trying we'd like to get away from having

815
00:32:38,820 --> 00:32:40,680
to send certificate revocation list out

816
00:32:40,680 --> 00:32:43,230
all the out stations though the master

817
00:32:43,230 --> 00:32:46,010
certificate will will have a very fast

818
00:32:46,010 --> 00:32:49,440
expiration period and reduce you know

819
00:32:49,440 --> 00:32:51,510
how often we have to revoke those from

820
00:32:51,510 --> 00:32:53,280
out stations so well you know we'll

821
00:32:53,280 --> 00:32:54,870
recommend a number of schemes that

822
00:32:54,870 --> 00:32:56,460
people can use to address things like

823
00:32:56,460 --> 00:32:58,800
revocation that that'll be one tool are

824
00:32:58,800 --> 00:33:03,990
in our toolbox yep so you know one

825
00:33:03,990 --> 00:33:05,310
thought I've had is that you know for

826
00:33:05,310 --> 00:33:07,080
certificates we could possibly reuse our

827
00:33:07,080 --> 00:33:08,280
message grammar to define as

828
00:33:08,280 --> 00:33:10,460
certificates themselves you know our

829
00:33:10,460 --> 00:33:13,650
grammar and our in our message dialect

830
00:33:13,650 --> 00:33:14,710
is

831
00:33:14,710 --> 00:33:16,060
there's only one way to encode things

832
00:33:16,060 --> 00:33:17,740
there's the canonical representation so

833
00:33:17,740 --> 00:33:18,820
it's pretty good for things like

834
00:33:18,820 --> 00:33:21,070
certificates so you can imagine defining

835
00:33:21,070 --> 00:33:22,960
a certificate envelope like this you

836
00:33:22,960 --> 00:33:25,000
know you have some opaque certificate

837
00:33:25,000 --> 00:33:27,670
data an issuer ID that you know might be

838
00:33:27,670 --> 00:33:30,100
a 64-bit value you know this is a

839
00:33:30,100 --> 00:33:31,240
signature algorithm and then the

840
00:33:31,240 --> 00:33:33,610
signature okay so one nice thing about

841
00:33:33,610 --> 00:33:36,940
255 1/9 is it comes with what they call

842
00:33:36,940 --> 00:33:39,550
an Edwards curve digital signature

843
00:33:39,550 --> 00:33:40,480
algorithm so there's a there's a

844
00:33:40,480 --> 00:33:41,980
companion digital signature algorithm

845
00:33:41,980 --> 00:33:44,790
also with that so we can produce

846
00:33:44,790 --> 00:33:48,220
signatures as well and there's so much

847
00:33:48,220 --> 00:33:50,620
cruft an x.509 that's just not relevant

848
00:33:50,620 --> 00:33:52,570
to utilities I mean a lot of people

849
00:33:52,570 --> 00:33:54,370
don't even use things like domain names

850
00:33:54,370 --> 00:33:56,020
I've heard a lot from manufacturers at

851
00:33:56,020 --> 00:33:57,790
Cost what are we going to do like x.509

852
00:33:57,790 --> 00:33:59,530
wants us to know the IP address of this

853
00:33:59,530 --> 00:34:01,630
before it's you know even defined and

854
00:34:01,630 --> 00:34:02,710
put in the vise so they're real

855
00:34:02,710 --> 00:34:05,440
provisioning issues with x.509 because

856
00:34:05,440 --> 00:34:08,139
it just was not designed for these kinds

857
00:34:08,139 --> 00:34:10,449
of systems so this is a chance for us to

858
00:34:10,449 --> 00:34:11,679
go back to the drawing board and say

859
00:34:11,679 --> 00:34:13,540
well what is the metadata that we think

860
00:34:13,540 --> 00:34:15,400
people need in these kind of

861
00:34:15,400 --> 00:34:18,760
certificates so you know just a stab I

862
00:34:18,760 --> 00:34:20,500
did this just last week I mean you could

863
00:34:20,500 --> 00:34:21,699
just say well it's got to have an ID

864
00:34:21,699 --> 00:34:24,639
right you got to know what the entity is

865
00:34:24,639 --> 00:34:27,670
you want to be able to time box the

866
00:34:27,670 --> 00:34:30,489
validity of certificates we're not going

867
00:34:30,489 --> 00:34:32,230
to use some crazy string format like

868
00:34:32,230 --> 00:34:34,150
x.509 has just you know UNIX epoch

869
00:34:34,150 --> 00:34:36,580
millisecond since 1970 or something like

870
00:34:36,580 --> 00:34:40,389
that a type of certificate and that

871
00:34:40,389 --> 00:34:41,500
could be a bit field saying what the

872
00:34:41,500 --> 00:34:43,630
permissions are is this an intermediate

873
00:34:43,630 --> 00:34:46,239
signing certificate in a chain is it a

874
00:34:46,239 --> 00:34:49,389
node certificate I'm sure that scheme

875
00:34:49,389 --> 00:34:50,500
will become more complicated

876
00:34:50,500 --> 00:34:52,210
well-defined as we go along over the

877
00:34:52,210 --> 00:34:54,040
other that's next phase it's going to

878
00:34:54,040 --> 00:34:56,260
have a public key embedded in it and the

879
00:34:56,260 --> 00:34:57,580
public key might have a different type

880
00:34:57,580 --> 00:35:00,610
you know depending on to tell people

881
00:35:00,610 --> 00:35:02,740
what it is and I think it will be

882
00:35:02,740 --> 00:35:05,290
important to have some support for

883
00:35:05,290 --> 00:35:07,720
extensions so now you heard Daniel Clark

884
00:35:07,720 --> 00:35:08,860
talk about that

885
00:35:08,860 --> 00:35:10,900
Modbus toad org was looking at betting

886
00:35:10,900 --> 00:35:13,750
things like permissions into

887
00:35:13,750 --> 00:35:15,340
certificates so you could do role based

888
00:35:15,340 --> 00:35:17,410
authorization but that's where that

889
00:35:17,410 --> 00:35:18,670
would come into play because I think

890
00:35:18,670 --> 00:35:20,380
that would be really really valuable

891
00:35:20,380 --> 00:35:21,730
what he was talking about on Tuesday

892
00:35:21,730 --> 00:35:24,040
being able to install a certificate on a

893
00:35:24,040 --> 00:35:26,170
device and that advice basically be able

894
00:35:26,170 --> 00:35:28,120
to enforce things like a read-only

895
00:35:28,120 --> 00:35:31,420
for that particular session so I started

896
00:35:31,420 --> 00:35:32,860
playing with this and then you know with

897
00:35:32,860 --> 00:35:36,160
those assumptions 64-bit ID is a a

898
00:35:36,160 --> 00:35:39,940
64-bit signature 32 byte keys and no

899
00:35:39,940 --> 00:35:43,360
extensions we can encode that 129 bytes

900
00:35:43,360 --> 00:35:45,340
with this scheme they can get really

901
00:35:45,340 --> 00:35:47,200
small and you could use that for

902
00:35:47,200 --> 00:35:49,360
near-field communications you can

903
00:35:49,360 --> 00:35:51,550
definitely do it over you know existing

904
00:35:51,550 --> 00:35:53,500
serial networks that people don't want

905
00:35:53,500 --> 00:35:54,880
to employ us we can send this to all

906
00:35:54,880 --> 00:35:58,060
kinds of places that x.509 won't go so

907
00:35:58,060 --> 00:35:59,680
that's pretty exciting we have a lot of

908
00:35:59,680 --> 00:36:01,360
work to the to define what the

909
00:36:01,360 --> 00:36:04,240
certificate format will be and then

910
00:36:04,240 --> 00:36:05,830
actually figure out how that fits in

911
00:36:05,830 --> 00:36:07,570
yeah these key management is a really

912
00:36:07,570 --> 00:36:09,220
hard problem so one of the things we are

913
00:36:09,220 --> 00:36:12,370
doing is working with our OT subject

914
00:36:12,370 --> 00:36:13,900
matter experts to understand the

915
00:36:13,900 --> 00:36:15,970
workflow for how the devices are

916
00:36:15,970 --> 00:36:18,000
provisioned and maintained so that we

917
00:36:18,000 --> 00:36:20,590
dovetail the certificate management

918
00:36:20,590 --> 00:36:23,050
piece into their normal workflow so this

919
00:36:23,050 --> 00:36:25,750
doesn't become an impact to the early

920
00:36:25,750 --> 00:36:33,190
operations these are so hopefully

921
00:36:33,190 --> 00:36:34,630
they're giving slides but we have a

922
00:36:34,630 --> 00:36:37,030
slack set up today you can send me an

923
00:36:37,030 --> 00:36:39,100
email and we can get you get people

924
00:36:39,100 --> 00:36:42,370
added into that right away we are going

925
00:36:42,370 --> 00:36:44,020
to be you know you Adam setting up the

926
00:36:44,020 --> 00:36:46,750
github to take it from automatic and put

927
00:36:46,750 --> 00:36:49,270
it into an SSP 21 github that will be

928
00:36:49,270 --> 00:36:52,600
public and we also have a Google Groups

929
00:36:52,600 --> 00:36:54,130
that we've set up to that you can send

930
00:36:54,130 --> 00:36:56,200
an email to you know to start

931
00:36:56,200 --> 00:36:58,540
collaborating through there as well but

932
00:36:58,540 --> 00:37:00,760
I wasn't saying that well I believe we

933
00:37:00,760 --> 00:37:02,620
don't have a sign off yet to publicly

934
00:37:02,620 --> 00:37:05,410
release anything we are willing to bring

935
00:37:05,410 --> 00:37:08,230
on board vetted partners and people from

936
00:37:08,230 --> 00:37:09,640
this community that are interested in

937
00:37:09,640 --> 00:37:11,890
participating like you know right now so

938
00:37:11,890 --> 00:37:13,330
you can but I'm gonna become a market

939
00:37:13,330 --> 00:37:15,010
public people will still have to ask for

940
00:37:15,010 --> 00:37:17,020
permission to get into these groups you

941
00:37:17,020 --> 00:37:19,330
know but there certainly won't be any

942
00:37:19,330 --> 00:37:21,540
restrictions from somebody who you know

943
00:37:21,540 --> 00:37:23,700
obviously you know would be a

944
00:37:23,700 --> 00:37:26,680
contributor yep so if you know if you

945
00:37:26,680 --> 00:37:28,180
want to see this backer play with the

946
00:37:28,180 --> 00:37:29,950
reference see where we are the reference

947
00:37:29,950 --> 00:37:31,750
implementation just you know email us

948
00:37:31,750 --> 00:37:35,520
and we can we can work with you

949
00:37:36,109 --> 00:37:48,140
that's what we have okay do we have any

950
00:37:48,140 --> 00:37:55,849
questions for Rick or Adam yes one of my

951
00:37:55,849 --> 00:37:57,079
questions is I've been doing

952
00:37:57,079 --> 00:37:58,459
vulnerability assessments on a lot of

953
00:37:58,459 --> 00:37:59,719
these systems for a while and I'm

954
00:37:59,719 --> 00:38:02,180
starting to see a trend of FPGA based

955
00:38:02,180 --> 00:38:06,200
development how friendly are some of

956
00:38:06,200 --> 00:38:09,349
these codes and and schemes that you're

957
00:38:09,349 --> 00:38:11,509
looking into as far as FPGAs go you know

958
00:38:11,509 --> 00:38:14,140
I had this exact khandhas cushon with

959
00:38:14,140 --> 00:38:17,839
Andrew it was talking about you know

960
00:38:17,839 --> 00:38:19,609
hardware based I'm getting all the code

961
00:38:19,609 --> 00:38:23,779
out of ring zero and I think that the

962
00:38:23,779 --> 00:38:25,400
two five five one nine the public key

963
00:38:25,400 --> 00:38:26,839
stuff would be the challenge but he

964
00:38:26,839 --> 00:38:28,160
seemed to think that it was quite doable

965
00:38:28,160 --> 00:38:31,160
and was rather excited about it so that

966
00:38:31,160 --> 00:38:32,509
would be very exciting I mean certainly

967
00:38:32,509 --> 00:38:34,729
AES the hash algorithms all those are

968
00:38:34,729 --> 00:38:36,430
hardware I mean those are commodity

969
00:38:36,430 --> 00:38:38,269
primitives that you can buy an

970
00:38:38,269 --> 00:38:40,190
accelerator chip for people have you

971
00:38:40,190 --> 00:38:43,099
know very log definitions for hardware

972
00:38:43,099 --> 00:38:44,719
acceleration but that's a question

973
00:38:44,719 --> 00:38:46,009
people that work with hardware lock

974
00:38:46,009 --> 00:38:47,959
could probably answer better you know we

975
00:38:47,959 --> 00:38:49,459
actually have had conversations with

976
00:38:49,459 --> 00:38:52,489
Intel about they want to take this one

977
00:38:52,489 --> 00:38:54,979
fits a stable reference implementation

978
00:38:54,979 --> 00:38:57,979
and implemented it in Altera right you

979
00:38:57,979 --> 00:38:59,269
know because that's what company they

980
00:38:59,269 --> 00:39:00,949
bought but I think that you know the

981
00:39:00,949 --> 00:39:03,140
fact that we're even our certificates

982
00:39:03,140 --> 00:39:04,219
and things the fact that they don't

983
00:39:04,219 --> 00:39:05,569
require a heap allocation that they're

984
00:39:05,569 --> 00:39:09,019
very very simple amends itself much more

985
00:39:09,019 --> 00:39:11,089
to hardware implementations and some

986
00:39:11,089 --> 00:39:13,609
other things and the reason why I ask is

987
00:39:13,609 --> 00:39:15,140
because you're building it for this for

988
00:39:15,140 --> 00:39:16,519
Skater your building is for long term

989
00:39:16,519 --> 00:39:17,959
communication communication over

990
00:39:17,959 --> 00:39:19,369
whatever transport you'd particularly

991
00:39:19,369 --> 00:39:21,109
like alright you're trying to make it

992
00:39:21,109 --> 00:39:22,400
light weight etc and I'm already looking

993
00:39:22,400 --> 00:39:26,239
towards GCS so you know one of the

994
00:39:26,239 --> 00:39:27,680
things there of course is multicast

995
00:39:27,680 --> 00:39:30,859
broadcast so any potential for multicast

996
00:39:30,859 --> 00:39:32,959
broadcast type commands and then for

997
00:39:32,959 --> 00:39:34,369
multicast is tough because then you have

998
00:39:34,369 --> 00:39:36,049
to have a lot of people sharing the same

999
00:39:36,049 --> 00:39:39,319
secrets and that becomes a risk we're

1000
00:39:39,319 --> 00:39:41,180
not really designing this for multicast

1001
00:39:41,180 --> 00:39:45,259
and that washed it yeah the question the

1002
00:39:45,259 --> 00:39:47,680
back there

1003
00:39:51,390 --> 00:39:53,980
thank you very much great presentation

1004
00:39:53,980 --> 00:39:55,540
by the way I do want to get involved

1005
00:39:55,540 --> 00:39:56,800
okay

1006
00:39:56,800 --> 00:39:58,690
my question for you the diffie-hellman

1007
00:39:58,690 --> 00:40:00,760
algorithm is great easy to implement

1008
00:40:00,760 --> 00:40:03,010
it's fast and stuff like that but to

1009
00:40:03,010 --> 00:40:04,330
eliminate them out in the middle we're

1010
00:40:04,330 --> 00:40:06,130
having to add station station on top of

1011
00:40:06,130 --> 00:40:07,840
that and we're getting a big performance

1012
00:40:07,840 --> 00:40:10,420
impact so what are you numbers are you

1013
00:40:10,420 --> 00:40:11,710
seeing with this particular

1014
00:40:11,710 --> 00:40:14,050
implementation we haven't tried it yet

1015
00:40:14,050 --> 00:40:15,640
on embedded hardware it's been mostly

1016
00:40:15,640 --> 00:40:17,320
from things we've read in the literature

1017
00:40:17,320 --> 00:40:19,210
of how it performs an ARM based systems

1018
00:40:19,210 --> 00:40:22,630
I mean I am it's from what I've read

1019
00:40:22,630 --> 00:40:24,550
we're going to be you know a couple

1020
00:40:24,550 --> 00:40:26,620
order magnitudes better than RSA schemes

1021
00:40:26,620 --> 00:40:29,890
with software implementations but I just

1022
00:40:29,890 --> 00:40:31,270
don't know I mean we're going to start

1023
00:40:31,270 --> 00:40:33,420
prototyping this with a bump in the wire

1024
00:40:33,420 --> 00:40:36,250
on some commodity moxa stuff I mean I

1025
00:40:36,250 --> 00:40:38,200
think like a 200 megahertz arm starting

1026
00:40:38,200 --> 00:40:39,550
at the end of the month so I think

1027
00:40:39,550 --> 00:40:41,380
producing those performance numbers

1028
00:40:41,380 --> 00:40:44,040
impacts will be part of the next phase

1029
00:40:44,040 --> 00:40:50,920
yep any other questions yeah great work

1030
00:40:50,920 --> 00:40:54,040
guys on your implementation plan are you

1031
00:40:54,040 --> 00:40:56,650
thinking about standing up public

1032
00:40:56,650 --> 00:40:59,260
endpoints that represents an outstation

1033
00:40:59,260 --> 00:41:02,410
or something like that yeah Schweitzer

1034
00:41:02,410 --> 00:41:05,470
is a vendor of ours and and so it's

1035
00:41:05,470 --> 00:41:08,470
Eaton and they have discussed doing a

1036
00:41:08,470 --> 00:41:11,080
proof of concept where for example they

1037
00:41:11,080 --> 00:41:14,830
have a port server they're 3610 that

1038
00:41:14,830 --> 00:41:16,270
they could you know do a reference

1039
00:41:16,270 --> 00:41:19,840
implementation on talking to a you know

1040
00:41:19,840 --> 00:41:22,660
eaton SP that you know that would look

1041
00:41:22,660 --> 00:41:25,210
like a SCADA Master and doing sort of a

1042
00:41:25,210 --> 00:41:27,040
proof of concept implementation for a

1043
00:41:27,040 --> 00:41:29,830
bump in the stack did you actually mean

1044
00:41:29,830 --> 00:41:31,330
like you know like standing up a cloud

1045
00:41:31,330 --> 00:41:34,690
service that people could talk to okay

1046
00:41:34,690 --> 00:41:38,260
that's important stuff to something not

1047
00:41:38,260 --> 00:41:39,580
something I considered but I don't see

1048
00:41:39,580 --> 00:41:40,290
why not

1049
00:41:40,290 --> 00:41:43,270
like a simulator yeah

1050
00:41:43,270 --> 00:41:45,940
like a master that talks I definitely

1051
00:41:45,940 --> 00:41:47,230
thought about putting together like you

1052
00:41:47,230 --> 00:41:48,910
know protocol decoders and things like

1053
00:41:48,910 --> 00:41:50,530
that or writing Wireshark plug-ins

1054
00:41:50,530 --> 00:41:53,800
things that kind of ease you know people

1055
00:41:53,800 --> 00:41:55,000
in implementing this that's another good

1056
00:41:55,000 --> 00:41:56,950
idea also it'd kind of be like a test

1057
00:41:56,950 --> 00:41:59,320
TARDIS in the cloud yeah that's a great

1058
00:41:59,320 --> 00:42:00,480
suggestion

1059
00:42:00,480 --> 00:42:05,290
um yeah I had one as well about okay so

1060
00:42:05,290 --> 00:42:07,030
you talked about asn.1 and that you were

1061
00:42:07,030 --> 00:42:08,740
eliminating all the croft or least

1062
00:42:08,740 --> 00:42:09,819
pieces that you didn't feel we're

1063
00:42:09,819 --> 00:42:12,880
necessary or that you felt were dumb do

1064
00:42:12,880 --> 00:42:14,319
you have a list of those that you could

1065
00:42:14,319 --> 00:42:18,520
put out it's easier just a list of

1066
00:42:18,520 --> 00:42:21,089
things that were using it yeah probably

1067
00:42:21,089 --> 00:42:30,940
just curiosity there some baja fungi net

1068
00:42:30,940 --> 00:42:33,339
comes out in germany so any chance that

1069
00:42:33,339 --> 00:42:36,400
that that can become an international

1070
00:42:36,400 --> 00:42:39,819
standard like an icy standard mmm

1071
00:42:39,819 --> 00:42:42,190
I think Oasis is a Dutch to

1072
00:42:42,190 --> 00:42:47,079
international standards yeah but um ISE

1073
00:42:47,079 --> 00:42:50,710
is a bit more yeah well known among them

1074
00:42:50,710 --> 00:42:53,500
does I'm asking because you see blenders

1075
00:42:53,500 --> 00:42:56,109
and in in your group but obvious like

1076
00:42:56,109 --> 00:42:58,240
you know an american-based and there

1077
00:42:58,240 --> 00:43:00,520
haven't been any final decisions on and

1078
00:43:00,520 --> 00:43:02,890
what standards body to work with so yeah

1079
00:43:02,890 --> 00:43:05,500
we'll definitely take your you know your

1080
00:43:05,500 --> 00:43:09,430
feedback on a European perspective you

1081
00:43:09,430 --> 00:43:12,130
have a lot of small vendors and we are

1082
00:43:12,130 --> 00:43:16,480
always looking at icy and kind of what

1083
00:43:16,480 --> 00:43:19,599
they want to implement and so it would

1084
00:43:19,599 --> 00:43:21,880
be probably good for co-op this would be

1085
00:43:21,880 --> 00:43:23,440
okay I would say that there would have

1086
00:43:23,440 --> 00:43:26,650
to be a compelling reason to work with

1087
00:43:26,650 --> 00:43:28,060
standards bodies that have a lot more

1088
00:43:28,060 --> 00:43:30,310
bureaucratic overhead like I Triple E

1089
00:43:30,310 --> 00:43:34,089
and I see but that would be very painful

1090
00:43:34,089 --> 00:43:36,030
personally to me Oh

1091
00:43:36,030 --> 00:43:38,380
original originally originally we were

1092
00:43:38,380 --> 00:43:39,849
just going to do this as through the

1093
00:43:39,849 --> 00:43:42,579
IETF and just you know put the running

1094
00:43:42,579 --> 00:43:44,680
code out there and see what happens but

1095
00:43:44,680 --> 00:43:50,859
I lost that argument there are pros and

1096
00:43:50,859 --> 00:43:56,910
cons right yeah got one more

1097
00:43:59,190 --> 00:44:01,660
so I mean I like what you're doing but I

1098
00:44:01,660 --> 00:44:04,060
also know doing like good crypto right

1099
00:44:04,060 --> 00:44:06,370
is hard which is why lots of the world

1100
00:44:06,370 --> 00:44:08,110
just says well we'll just use TLS

1101
00:44:08,110 --> 00:44:10,360
because people beat on it for years and

1102
00:44:10,360 --> 00:44:13,090
figured it all out so I guess my kind of

1103
00:44:13,090 --> 00:44:15,250
I have two questions one is it sounds

1104
00:44:15,250 --> 00:44:16,840
like ever gotten performance data yet

1105
00:44:16,840 --> 00:44:19,300
but do you at least have a sense of code

1106
00:44:19,300 --> 00:44:21,340
size savings right here how much your

1107
00:44:21,340 --> 00:44:23,920
implementation takes X number K versus a

1108
00:44:23,920 --> 00:44:26,710
TLS stack is I mean how much well I

1109
00:44:26,710 --> 00:44:29,500
could see you this way I mean what is

1110
00:44:29,500 --> 00:44:31,540
the open SSL code base with Lib crypto

1111
00:44:31,540 --> 00:44:34,750
and SSL's like I think it's a 150

1112
00:44:34,750 --> 00:44:36,450
thousand lines of code or something and

1113
00:44:36,450 --> 00:44:40,390
we're sitting at 4,000 okay and that

1114
00:44:40,390 --> 00:44:42,460
doesn't that does not count pulling in

1115
00:44:42,460 --> 00:44:44,020
the primitives from Lib sodium but the

1116
00:44:44,020 --> 00:44:45,340
code base is going to be very small

1117
00:44:45,340 --> 00:44:47,920
compared to at least open SSL and

1118
00:44:47,920 --> 00:44:49,870
there's lots of specialized TLS stacks

1119
00:44:49,870 --> 00:44:51,250
for embedded systems I don't have the

1120
00:44:51,250 --> 00:44:52,690
numbers in those but I think they'd be

1121
00:44:52,690 --> 00:44:55,980
very useful to do is to compare their

1122
00:44:55,980 --> 00:44:58,270
support denote the number that matters

1123
00:44:58,270 --> 00:45:00,220
is the performance numbers yeah but

1124
00:45:00,220 --> 00:45:02,500
that's at least some metric of oh how

1125
00:45:02,500 --> 00:45:04,270
much smaller is it well it's important

1126
00:45:04,270 --> 00:45:05,920
to manufacturers too because no one

1127
00:45:05,920 --> 00:45:07,540
wants to blindly especially put

1128
00:45:07,540 --> 00:45:09,280
something new into a system and you can

1129
00:45:09,280 --> 00:45:11,110
say hey there's there's only four

1130
00:45:11,110 --> 00:45:12,460
thousand lines of code here you guys can

1131
00:45:12,460 --> 00:45:14,800
have a really in-depth look at it you

1132
00:45:14,800 --> 00:45:17,560
know without on what you have yeah with

1133
00:45:17,560 --> 00:45:20,050
a small team I ain't done it the other

1134
00:45:20,050 --> 00:45:22,360
question was war on the crypto like you

1135
00:45:22,360 --> 00:45:24,370
need that was Soviet you know I'm not a

1136
00:45:24,370 --> 00:45:26,290
cryptologist didn't sound like you are

1137
00:45:26,290 --> 00:45:28,330
but it sounds like if somebody in

1138
00:45:28,330 --> 00:45:29,860
lawrence livermore is that the people

1139
00:45:29,860 --> 00:45:31,480
the mathematician yeah we've got a guy

1140
00:45:31,480 --> 00:45:33,460
named her crypto boy that's his handle

1141
00:45:33,460 --> 00:45:35,860
who's lifting it that he's part of you

1142
00:45:35,860 --> 00:45:38,950
really that's that's hard and typically

1143
00:45:38,950 --> 00:45:41,920
that's like peer-reviewed and it just

1144
00:45:41,920 --> 00:45:43,450
there's a difference here between I

1145
00:45:43,450 --> 00:45:44,920
think between primitives and

1146
00:45:44,920 --> 00:45:46,180
compositions certainly we're not

1147
00:45:46,180 --> 00:45:48,430
tackling primitives and to a certain

1148
00:45:48,430 --> 00:45:49,600
degree we're not even tackling

1149
00:45:49,600 --> 00:45:51,490
composition because we've we borrowed

1150
00:45:51,490 --> 00:45:53,290
composition from protocols that have

1151
00:45:53,290 --> 00:45:55,780
gotten extensive review and then on top

1152
00:45:55,780 --> 00:45:58,320
of that we are bringing in third-party

1153
00:45:58,320 --> 00:46:00,790
experts like the folks said at Livermore

1154
00:46:00,790 --> 00:46:03,460
but I mean that's a very very valid

1155
00:46:03,460 --> 00:46:05,110
concern but those are the things that I

1156
00:46:05,110 --> 00:46:09,540
can say to to address that

1157
00:46:12,410 --> 00:46:14,819
well actually we have them to say

1158
00:46:14,819 --> 00:46:16,289
represented here we'd be happy to

1159
00:46:16,289 --> 00:46:30,150
disclose everything to them yep that's

1160
00:46:30,150 --> 00:46:31,349
one of the reasons why we're doing a

1161
00:46:31,349 --> 00:46:33,269
reference implementation as well because

1162
00:46:33,269 --> 00:46:35,819
it could be vetted by the the community

1163
00:46:35,819 --> 00:46:38,660
and and verified that you know it's

1164
00:46:38,660 --> 00:46:45,510
effective and it really awesome

1165
00:46:45,510 --> 00:46:48,690
presentation and I can see Dee you've

1166
00:46:48,690 --> 00:46:51,539
really managed to optimize the security

1167
00:46:51,539 --> 00:46:54,660
transport for that use case but you're

1168
00:46:54,660 --> 00:46:56,250
also thinking about in the future you

1169
00:46:56,250 --> 00:46:58,769
might need more complex key management

1170
00:46:58,769 --> 00:47:02,010
and support for certificates and are you

1171
00:47:02,010 --> 00:47:05,400
worried at all that the the advantage is

1172
00:47:05,400 --> 00:47:09,119
you guess by avoiding TLS you might have

1173
00:47:09,119 --> 00:47:10,799
to trade them off in the future when you

1174
00:47:10,799 --> 00:47:13,039
bring in key management and certificates

1175
00:47:13,039 --> 00:47:15,180
to extent yes

1176
00:47:15,180 --> 00:47:17,190
I mean adding certificates or adds

1177
00:47:17,190 --> 00:47:19,920
things like a lot of pre authentication

1178
00:47:19,920 --> 00:47:21,900
parsing and so forth

1179
00:47:21,900 --> 00:47:24,750
but there's a lot of parts of TLS for

1180
00:47:24,750 --> 00:47:28,140
instance that exists they really don't

1181
00:47:28,140 --> 00:47:29,700
have to do with the PKI part that we're

1182
00:47:29,700 --> 00:47:31,200
not using to like you know one example

1183
00:47:31,200 --> 00:47:34,289
is the fact that TLS has all these

1184
00:47:34,289 --> 00:47:36,569
different modes for just authenticating

1185
00:47:36,569 --> 00:47:37,890
the server or doing mutual

1186
00:47:37,890 --> 00:47:39,599
authentication and it was funny I was

1187
00:47:39,599 --> 00:47:41,400
talking to somebody I camera who was

1188
00:47:41,400 --> 00:47:43,410
earlier this week they were talking to

1189
00:47:43,410 --> 00:47:45,059
how a vendor had deployed a product that

1190
00:47:45,059 --> 00:47:48,000
misconfigured their TLS stacked only

1191
00:47:48,000 --> 00:47:50,940
authenticate the surfer so you know it's

1192
00:47:50,940 --> 00:47:52,500
things like that all the bells and

1193
00:47:52,500 --> 00:47:54,450
whistles where we really only want

1194
00:47:54,450 --> 00:47:57,180
mutual authentication and so forth I

1195
00:47:57,180 --> 00:47:59,640
think simplifies things certainly

1196
00:47:59,640 --> 00:48:03,630
certificate chains are not simple and

1197
00:48:03,630 --> 00:48:08,640
that will add overhead yeah okay okay I

1198
00:48:08,640 --> 00:48:10,259
think this is going to be the last

1199
00:48:10,259 --> 00:48:12,440
question

1200
00:48:12,500 --> 00:48:14,840
and it may be a quick one but I know San

1201
00:48:14,840 --> 00:48:17,150
Diego utilities are experimenting using

1202
00:48:17,150 --> 00:48:19,580
quantum encryption techniques yeah with

1203
00:48:19,580 --> 00:48:21,440
photon Vickery are you looking at that

1204
00:48:21,440 --> 00:48:24,740
at all oh yeah so this is probably going

1205
00:48:24,740 --> 00:48:26,510
to be the talk next year I'll bring dr.

1206
00:48:26,510 --> 00:48:28,880
Duncan Earl with me because to get me to

1207
00:48:28,880 --> 00:48:30,770
answer the quantum cryptography stuff he

1208
00:48:30,770 --> 00:48:33,320
but he explains it very well so as Adam

1209
00:48:33,320 --> 00:48:35,720
mentioned we have an option in there for

1210
00:48:35,720 --> 00:48:38,930
encryption and so the third phase after

1211
00:48:38,930 --> 00:48:40,940
we get the utility key infrastructure in

1212
00:48:40,940 --> 00:48:44,440
place is to provide a way to deliver a

1213
00:48:44,440 --> 00:48:47,599
one-time pad which is a quantum

1214
00:48:47,599 --> 00:48:49,820
cryptography key yeah it can then be

1215
00:48:49,820 --> 00:48:51,619
used for encryption we're looking at an

1216
00:48:51,619 --> 00:48:53,359
integration point so that you could

1217
00:48:53,359 --> 00:48:54,830
distribute the quantum keys and then mix

1218
00:48:54,830 --> 00:48:57,020
them into kdf and then you basically

1219
00:48:57,020 --> 00:48:59,540
have a mix of classical public key which

1220
00:48:59,540 --> 00:49:01,250
can be broken by quantum computers and

1221
00:49:01,250 --> 00:49:03,580
then the symmetric stuff which is only

1222
00:49:03,580 --> 00:49:06,290
halved by quantum computers in

1223
00:49:06,290 --> 00:49:09,800
effectiveness so so we actually have the

1224
00:49:09,800 --> 00:49:12,160
works really not quantum computing

1225
00:49:12,160 --> 00:49:15,290
capability is quantum encryption which

1226
00:49:15,290 --> 00:49:18,380
is developed by entangled photons right

1227
00:49:18,380 --> 00:49:20,660
which really isn't a computing right

1228
00:49:20,660 --> 00:49:23,690
right no I was just but lately I was

1229
00:49:23,690 --> 00:49:24,890
just speaking of the fact that we would

1230
00:49:24,890 --> 00:49:27,470
use the quantum key distribution

1231
00:49:27,470 --> 00:49:30,260
mechanism to distribute the keys and

1232
00:49:30,260 --> 00:49:32,570
that would that would bolster the part

1233
00:49:32,570 --> 00:49:33,890
of our system that would be vulnerable

1234
00:49:33,890 --> 00:49:36,260
to quantum computing got it yeah okay

1235
00:49:36,260 --> 00:49:38,920
thank you okay

1236
00:49:38,920 --> 00:49:50,679
[Music]

