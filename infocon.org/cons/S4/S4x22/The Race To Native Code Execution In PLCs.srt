1
00:00:04,880 --> 00:00:06,560
hi everyone

2
00:00:06,560 --> 00:00:08,160
uh can you hear me one two one two yeah

3
00:00:08,160 --> 00:00:10,800
it looks good uh hi everyone uh my name

4
00:00:10,800 --> 00:00:12,400
is uh charon brizzino as you know and

5
00:00:12,400 --> 00:00:14,240
today i have a great story to tell you

6
00:00:14,240 --> 00:00:17,119
uh so let's get started now

7
00:00:17,119 --> 00:00:18,960
you all know that the main functionality

8
00:00:18,960 --> 00:00:23,199
of a plc is to execute logic code so we

9
00:00:23,199 --> 00:00:25,519
as engineers writing

10
00:00:25,519 --> 00:00:28,080
programs in ides engineering working

11
00:00:28,080 --> 00:00:30,800
stations and we're uploading or actually

12
00:00:30,800 --> 00:00:32,800
the correct terminology and ics is

13
00:00:32,800 --> 00:00:35,280
downloading and transferring this data

14
00:00:35,280 --> 00:00:38,399
to the pc the plc will execute our code

15
00:00:38,399 --> 00:00:40,640
and it will control the automation

16
00:00:40,640 --> 00:00:42,640
process so eventually our goal is to

17
00:00:42,640 --> 00:00:44,719
control the automation process

18
00:00:44,719 --> 00:00:47,840
the problem is however is that our code

19
00:00:47,840 --> 00:00:50,480
is being executed in a simulated

20
00:00:50,480 --> 00:00:53,039
world so our code is very limited to

21
00:00:53,039 --> 00:00:55,520
what the vendor decided and the dear to

22
00:00:55,520 --> 00:00:58,160
mind that our code can do we cannot

23
00:00:58,160 --> 00:00:59,920
control the operating system we cannot

24
00:00:59,920 --> 00:01:02,239
modify anything that we want on the plc

25
00:01:02,239 --> 00:01:04,479
we're limited to the api and the

26
00:01:04,479 --> 00:01:08,000
functionality that the vendor decided so

27
00:01:08,000 --> 00:01:10,479
my question to you is how can we break

28
00:01:10,479 --> 00:01:12,960
out of the madrix and

29
00:01:12,960 --> 00:01:15,280
with that we had this question in mind

30
00:01:15,280 --> 00:01:18,000
and that's why we decided to compete in

31
00:01:18,000 --> 00:01:19,119
a race

32
00:01:19,119 --> 00:01:22,159
and we call this race the race to native

33
00:01:22,159 --> 00:01:25,280
code execution so actually we were not

34
00:01:25,280 --> 00:01:27,119
the ones who started this race the race

35
00:01:27,119 --> 00:01:30,240
was started many years ago with stuxnet

36
00:01:30,240 --> 00:01:33,119
so the reason the race was

37
00:01:33,119 --> 00:01:35,759
the imaginary race was

38
00:01:35,759 --> 00:01:37,920
created is because

39
00:01:37,920 --> 00:01:43,040
hackers wanted to hide code on plcs and

40
00:01:43,040 --> 00:01:46,000
hackers and attackers cannot hide code

41
00:01:46,000 --> 00:01:48,560
logic code when it's run in a simulated

42
00:01:48,560 --> 00:01:51,439
world because this code can be analyzed

43
00:01:51,439 --> 00:01:52,840
and diagnosed

44
00:01:52,840 --> 00:01:55,280
because engineering working station can

45
00:01:55,280 --> 00:01:58,399
extract this code and view it so that's

46
00:01:58,399 --> 00:01:59,360
why

47
00:01:59,360 --> 00:02:01,600
different attempts along the years were

48
00:02:01,600 --> 00:02:05,280
made in order to create a very stealthy

49
00:02:05,280 --> 00:02:07,439
situation in which hidden code is

50
00:02:07,439 --> 00:02:08,959
running on the plc it started with

51
00:02:08,959 --> 00:02:11,920
stuxnet stuxnet did

52
00:02:11,920 --> 00:02:13,920
something very sophisticated but on the

53
00:02:13,920 --> 00:02:15,920
engineering working station side it

54
00:02:15,920 --> 00:02:18,160
intercepted the transfer of the bytecode

55
00:02:18,160 --> 00:02:21,520
to the plc and modified it later we had

56
00:02:21,520 --> 00:02:24,000
rock 7 rock 7 did something

57
00:02:24,000 --> 00:02:26,959
uh very cool they decoupled the byte

58
00:02:26,959 --> 00:02:29,599
code and the text code and they modified

59
00:02:29,599 --> 00:02:31,680
one and not the other so

60
00:02:31,680 --> 00:02:34,239
in some in some sense

61
00:02:34,239 --> 00:02:37,120
there was hidden code on the plc

62
00:02:37,120 --> 00:02:40,160
later we had an hardware exploit

63
00:02:40,160 --> 00:02:42,640
which really exploited the kernel

64
00:02:42,640 --> 00:02:45,440
the firmware of the plc but it was

65
00:02:45,440 --> 00:02:49,360
limited to a physical access and then we

66
00:02:49,360 --> 00:02:51,760
demonstrated our cve

67
00:02:51,760 --> 00:02:53,840
and we actually found a vulnerability

68
00:02:53,840 --> 00:02:56,160
that allowed us to execute remote code

69
00:02:56,160 --> 00:02:59,200
on siemens plcs and we actually were

70
00:02:59,200 --> 00:03:01,840
able to execute native bytecode on the

71
00:03:01,840 --> 00:03:03,920
plc and this is exactly the story we

72
00:03:03,920 --> 00:03:05,760
will tell you today

73
00:03:05,760 --> 00:03:07,200
now

74
00:03:07,200 --> 00:03:09,840
uh this is the agenda it's a quick one

75
00:03:09,840 --> 00:03:11,519
we'll do a short overview on siemens

76
00:03:11,519 --> 00:03:13,519
plc's we'll go over

77
00:03:13,519 --> 00:03:15,360
firmware and the tia portal which is the

78
00:03:15,360 --> 00:03:17,440
engineering working station after that

79
00:03:17,440 --> 00:03:19,680
we'll talk a little bit about mc7 plus

80
00:03:19,680 --> 00:03:22,080
byte code and then hopefully i will show

81
00:03:22,080 --> 00:03:23,519
you how we were able to escape the

82
00:03:23,519 --> 00:03:26,000
sandbox and execute native code

83
00:03:26,000 --> 00:03:27,040
now

84
00:03:27,040 --> 00:03:31,040
our targets are siemens s7 1200 and 1500

85
00:03:31,040 --> 00:03:33,840
these are siemens flagship plc's from

86
00:03:33,840 --> 00:03:36,720
the cinematic product line amazing plc's

87
00:03:36,720 --> 00:03:39,599
they have tons of functionality and

88
00:03:39,599 --> 00:03:41,680
they're super fast and they have

89
00:03:41,680 --> 00:03:44,480
also tons of security features including

90
00:03:44,480 --> 00:03:46,720
acls and very

91
00:03:46,720 --> 00:03:49,440
protected kernel i know this because i

92
00:03:49,440 --> 00:03:52,159
researched the kernel deep

93
00:03:52,159 --> 00:03:54,080
so these are going to be our main

94
00:03:54,080 --> 00:03:55,680
players for today

95
00:03:55,680 --> 00:03:57,760
now

96
00:03:57,760 --> 00:04:00,400
the ecosystem that we're talking about

97
00:04:00,400 --> 00:04:02,000
is

98
00:04:02,000 --> 00:04:04,239
has three parts we have the engineer

99
00:04:04,239 --> 00:04:06,480
working station where we're writing our

100
00:04:06,480 --> 00:04:09,040
ladder diagram or the engineering code

101
00:04:09,040 --> 00:04:10,959
the logic code that we want to transfer

102
00:04:10,959 --> 00:04:12,640
to the plc

103
00:04:12,640 --> 00:04:16,399
the transfer is through a network access

104
00:04:16,399 --> 00:04:18,798
specifically in this case it's s7 com

105
00:04:18,798 --> 00:04:20,639
plus protocol

106
00:04:20,639 --> 00:04:22,079
and the byte code that we're

107
00:04:22,079 --> 00:04:24,400
transferring to the plc is not a ladder

108
00:04:24,400 --> 00:04:26,720
diagram byte code but it's an

109
00:04:26,720 --> 00:04:29,440
intermediate language that we call in

110
00:04:29,440 --> 00:04:32,800
siemens ecosystem mc7 plus this byte

111
00:04:32,800 --> 00:04:34,960
code is transferred to the plc and then

112
00:04:34,960 --> 00:04:38,240
the plc executes it and by that we can

113
00:04:38,240 --> 00:04:39,759
control

114
00:04:39,759 --> 00:04:42,639
sorry we can control the automation

115
00:04:42,639 --> 00:04:44,560
process now

116
00:04:44,560 --> 00:04:46,800
if we look at the code compilation from

117
00:04:46,800 --> 00:04:49,280
a high level perspective we will see

118
00:04:49,280 --> 00:04:50,960
that first of all we are writing our

119
00:04:50,960 --> 00:04:53,680
code in a high level language so we have

120
00:04:53,680 --> 00:04:55,759
a lighter

121
00:04:55,759 --> 00:04:58,479
and other similar languages that we

122
00:04:58,479 --> 00:05:00,479
refer as user

123
00:05:00,479 --> 00:05:02,880
user code or high-level code these

124
00:05:02,880 --> 00:05:04,960
languages are very familiar to most of

125
00:05:04,960 --> 00:05:06,720
you because i'm sure you have seen

126
00:05:06,720 --> 00:05:08,639
ladder diagram or

127
00:05:08,639 --> 00:05:11,039
structured text code this is where we're

128
00:05:11,039 --> 00:05:13,360
right on the engineering working station

129
00:05:13,360 --> 00:05:16,160
this code is not compiled directly to

130
00:05:16,160 --> 00:05:20,160
the native uh cpu architecture code but

131
00:05:20,160 --> 00:05:21,039
it's

132
00:05:21,039 --> 00:05:22,800
first it has been compiled to an

133
00:05:22,800 --> 00:05:26,000
intermediate language the mc7 plus byte

134
00:05:26,000 --> 00:05:28,960
code this code is actually

135
00:05:28,960 --> 00:05:32,160
consists of instructions that will later

136
00:05:32,160 --> 00:05:34,880
be transferred to the plc and be

137
00:05:34,880 --> 00:05:37,600
executed by the cplc itself through a

138
00:05:37,600 --> 00:05:41,600
very complex virtual machine state

139
00:05:41,600 --> 00:05:45,360
eventually these instructions will be

140
00:05:45,360 --> 00:05:47,360
executed through

141
00:05:47,360 --> 00:05:49,600
arm or meeps or any

142
00:05:49,600 --> 00:05:52,880
other cpu architecture code and this is

143
00:05:52,880 --> 00:05:55,440
where the real code is being executed on

144
00:05:55,440 --> 00:05:57,280
the plc itself

145
00:05:57,280 --> 00:05:59,360
so i'm sure you all this is arm for

146
00:05:59,360 --> 00:06:02,000
example and i'm sure you'll know or saw

147
00:06:02,000 --> 00:06:03,280
some similar

148
00:06:03,280 --> 00:06:04,560
assembly code

149
00:06:04,560 --> 00:06:07,199
and this process is what

150
00:06:07,199 --> 00:06:10,800
uh we refer as the transfer the the

151
00:06:10,800 --> 00:06:13,919
complete transfer of uh bytecode from

152
00:06:13,919 --> 00:06:15,840
starting from a high level language like

153
00:06:15,840 --> 00:06:19,600
slider diagram to a native uh byte code

154
00:06:19,600 --> 00:06:21,600
and when we say we want to execute

155
00:06:21,600 --> 00:06:24,160
native bytecode we actually mean that we

156
00:06:24,160 --> 00:06:27,039
want to write our shell code in the arm

157
00:06:27,039 --> 00:06:30,160
or mips architecture

158
00:06:30,160 --> 00:06:32,000
now when we looked at this from a

159
00:06:32,000 --> 00:06:33,840
high-level perspective we ask ourselves

160
00:06:33,840 --> 00:06:36,080
a couple of questions like

161
00:06:36,080 --> 00:06:37,919
how does this compilation process

162
00:06:37,919 --> 00:06:39,759
actually work

163
00:06:39,759 --> 00:06:41,120
how the

164
00:06:41,120 --> 00:06:43,280
transfer of the byte code actually works

165
00:06:43,280 --> 00:06:46,240
what do we need to transfer or compile

166
00:06:46,240 --> 00:06:48,960
the code ourselves but the most

167
00:06:48,960 --> 00:06:51,599
important question we had as a security

168
00:06:51,599 --> 00:06:55,120
researchers is how can we find the one

169
00:06:55,120 --> 00:06:57,520
to break out of the metrics and i'm

170
00:06:57,520 --> 00:06:59,759
sorry for all the matrix references i

171
00:06:59,759 --> 00:07:00,880
wrote this

172
00:07:00,880 --> 00:07:03,440
presentation before i saw matrix four

173
00:07:03,440 --> 00:07:04,800
but uh

174
00:07:04,800 --> 00:07:07,759
it's gonna be funny enough uh so we

175
00:07:07,759 --> 00:07:09,280
asked ourselves how can we break out of

176
00:07:09,280 --> 00:07:11,280
the matrix how can we break out of out

177
00:07:11,280 --> 00:07:13,759
of the simulated world and execute our

178
00:07:13,759 --> 00:07:16,639
own byte code can we find the one

179
00:07:16,639 --> 00:07:18,400
instruction that

180
00:07:18,400 --> 00:07:22,800
we could abuse and use it to escape

181
00:07:22,800 --> 00:07:25,520
our simulated

182
00:07:25,520 --> 00:07:27,440
sandbox

183
00:07:27,440 --> 00:07:29,599
okay so let's dive in first of all i

184
00:07:29,599 --> 00:07:32,080
want to tell you how we

185
00:07:32,080 --> 00:07:34,720
started the research and what are

186
00:07:34,720 --> 00:07:37,599
what kind of platforms we researched

187
00:07:37,599 --> 00:07:39,680
we will start with the firmware and then

188
00:07:39,680 --> 00:07:42,560
generic station as i told you we have

189
00:07:42,560 --> 00:07:45,520
three parts and we will skim through

190
00:07:45,520 --> 00:07:47,599
them the first one that we want to start

191
00:07:47,599 --> 00:07:50,080
with is the plc itself and when we're

192
00:07:50,080 --> 00:07:52,479
saying that we want to research a plc

193
00:07:52,479 --> 00:07:54,080
usually it means

194
00:07:54,080 --> 00:07:55,120
we will

195
00:07:55,120 --> 00:07:58,479
try to obtain the firmware and analyze

196
00:07:58,479 --> 00:08:00,960
it and this is exactly what we did so we

197
00:08:00,960 --> 00:08:04,319
started with the s7 1200 this is a kind

198
00:08:04,319 --> 00:08:07,360
of a normal computer which has cpu in

199
00:08:07,360 --> 00:08:11,759
this case arm cortext r4 it has a rom

200
00:08:11,759 --> 00:08:15,440
and also nand flash to hold the firmware

201
00:08:15,440 --> 00:08:18,400
now we obtained the firmware file from

202
00:08:18,400 --> 00:08:21,120
siemens this is a dot upd firmware file

203
00:08:21,120 --> 00:08:23,919
and we analyzed it we noticed there is a

204
00:08:23,919 --> 00:08:26,720
header and also different sections

205
00:08:26,720 --> 00:08:29,039
and one of the sections points to a

206
00:08:29,039 --> 00:08:31,599
specific offset in the firmware file

207
00:08:31,599 --> 00:08:35,519
and this offset is compressed using lzp3

208
00:08:35,519 --> 00:08:38,320
one and once decompressed and a bit

209
00:08:38,320 --> 00:08:42,159
reconstructed we got the firmware the

210
00:08:42,159 --> 00:08:43,919
the firmware that actually runs the

211
00:08:43,919 --> 00:08:45,839
operating system that actually runs on

212
00:08:45,839 --> 00:08:48,320
the siemens plc this is an amazing

213
00:08:48,320 --> 00:08:50,720
operating system and we're starting to

214
00:08:50,720 --> 00:08:53,600
navigate our way inside and look at

215
00:08:53,600 --> 00:08:55,839
different strings so one of the strings

216
00:08:55,839 --> 00:09:00,000
we noticed is adonis so we actually

217
00:09:00,000 --> 00:09:02,560
realized at the time that adonis is the

218
00:09:02,560 --> 00:09:04,640
internal name that siemens

219
00:09:04,640 --> 00:09:08,880
refer to the kernel so just like you say

220
00:09:08,880 --> 00:09:11,600
i would win those operating systems so

221
00:09:11,600 --> 00:09:13,680
we could say that don is operating

222
00:09:13,680 --> 00:09:15,600
system where they are done is firmware

223
00:09:15,600 --> 00:09:17,200
or kernel

224
00:09:17,200 --> 00:09:18,000
now

225
00:09:18,000 --> 00:09:20,000
we

226
00:09:20,000 --> 00:09:22,640
deeply researched this firmware we

227
00:09:22,640 --> 00:09:24,640
deeply researched how the adonis kernel

228
00:09:24,640 --> 00:09:25,839
actually work

229
00:09:25,839 --> 00:09:28,000
and we discovered that just like every

230
00:09:28,000 --> 00:09:29,920
other operating system it has different

231
00:09:29,920 --> 00:09:32,080
layers so there are the deepest layers

232
00:09:32,080 --> 00:09:33,680
of the operating system

233
00:09:33,680 --> 00:09:36,240
themselves where all the threads memory

234
00:09:36,240 --> 00:09:39,200
allocations messages events etc are

235
00:09:39,200 --> 00:09:42,240
being created initialized and handled

236
00:09:42,240 --> 00:09:44,800
and above this there are the siemens

237
00:09:44,800 --> 00:09:46,480
specific services

238
00:09:46,480 --> 00:09:48,880
to handle the siemens communication to

239
00:09:48,880 --> 00:09:52,240
handle uh the the mc7 plus bytecode to

240
00:09:52,240 --> 00:09:55,360
handle the automation services etc and

241
00:09:55,360 --> 00:09:57,600
all of this to support the most

242
00:09:57,600 --> 00:10:00,160
important layer for us which is the

243
00:10:00,160 --> 00:10:02,959
automation application layer so if we

244
00:10:02,959 --> 00:10:04,959
are writing as engineers if we are

245
00:10:04,959 --> 00:10:07,839
writing programs in ladder diagram

246
00:10:07,839 --> 00:10:10,399
eventually they will get executed in the

247
00:10:10,399 --> 00:10:13,200
highest layer of this car hierarchy

248
00:10:13,200 --> 00:10:15,279
where all the lower layers should

249
00:10:15,279 --> 00:10:17,600
support this entire operation and

250
00:10:17,600 --> 00:10:20,240
eventually our programs will be get

251
00:10:20,240 --> 00:10:22,800
executed on the top layer in a kind of a

252
00:10:22,800 --> 00:10:25,600
simulated mode because they can could

253
00:10:25,600 --> 00:10:28,240
control only specific features that the

254
00:10:28,240 --> 00:10:30,640
adonis kernel allowed them

255
00:10:30,640 --> 00:10:33,200
and our goal obviously we can interact

256
00:10:33,200 --> 00:10:35,040
with the highest level

257
00:10:35,040 --> 00:10:38,079
is to escape out of it so basically we

258
00:10:38,079 --> 00:10:39,839
would want to

259
00:10:39,839 --> 00:10:43,120
somehow break out of this matrix or

260
00:10:43,120 --> 00:10:45,839
sandbox and write our shell code into

261
00:10:45,839 --> 00:10:47,519
the kernel so

262
00:10:47,519 --> 00:10:51,680
our plan was something like rewire the

263
00:10:51,680 --> 00:10:53,760
brain of the plc

264
00:10:53,760 --> 00:10:56,720
because if we could re rewrite the brain

265
00:10:56,720 --> 00:10:58,399
of the pc

266
00:10:58,399 --> 00:11:00,880
the plc would not even know about this

267
00:11:00,880 --> 00:11:04,240
because it's part of its spray now

268
00:11:04,240 --> 00:11:05,040
okay

269
00:11:05,040 --> 00:11:06,800
so we

270
00:11:06,800 --> 00:11:09,120
investigated the firmware side we also

271
00:11:09,120 --> 00:11:11,600
wanted to investigate the engineering

272
00:11:11,600 --> 00:11:13,839
work inside engineering working station

273
00:11:13,839 --> 00:11:16,720
side i'm sure you have all

274
00:11:16,720 --> 00:11:18,480
yeah

275
00:11:18,480 --> 00:11:20,560
great

276
00:11:20,560 --> 00:11:22,800
okay thank you

277
00:11:22,800 --> 00:11:25,120
no i'll wait

278
00:11:25,120 --> 00:11:26,959
okay so

279
00:11:26,959 --> 00:11:29,279
we wanted to investigate the engineer

280
00:11:29,279 --> 00:11:31,760
engineering working station side never

281
00:11:31,760 --> 00:11:33,040
mind i'll just speak

282
00:11:33,040 --> 00:11:34,399
um

283
00:11:34,399 --> 00:11:35,440
and

284
00:11:35,440 --> 00:11:37,200
i'm sure you're all familiar with the

285
00:11:37,200 --> 00:11:39,040
tia portal screen that you don't see

286
00:11:39,040 --> 00:11:42,199
right now

287
00:11:43,200 --> 00:11:44,959
okay

288
00:11:44,959 --> 00:11:48,240
i'll try to continue without the screen

289
00:11:48,240 --> 00:11:50,480
so we investigated the engineering

290
00:11:50,480 --> 00:11:52,959
working station side um

291
00:11:52,959 --> 00:11:57,920
and realized it's a huge beast it has

292
00:11:57,920 --> 00:12:00,959
tens of thousands of files and thousands

293
00:12:00,959 --> 00:12:03,440
of dlls that we had to navigate our way

294
00:12:03,440 --> 00:12:07,440
through most of it is written in c-sharp

295
00:12:07,440 --> 00:12:09,680
it's also

296
00:12:09,680 --> 00:12:11,920
a language we needed to reverse engineer

297
00:12:11,920 --> 00:12:13,120
and

298
00:12:13,120 --> 00:12:15,440
on top of it some of the dlls are

299
00:12:15,440 --> 00:12:18,880
written in and managed c plus plus

300
00:12:18,880 --> 00:12:21,279
code and there is kind of a

301
00:12:21,279 --> 00:12:23,519
interaction between the c plus and the c

302
00:12:23,519 --> 00:12:25,920
sharp code so we hand a lot of code to

303
00:12:25,920 --> 00:12:28,720
reverse engineer but we focused on two

304
00:12:28,720 --> 00:12:33,519
dlls the first one is mc7 code generator

305
00:12:33,519 --> 00:12:37,200
dll which holds all the logic to create

306
00:12:37,200 --> 00:12:40,320
the mc7 plus byte code so it creates the

307
00:12:40,320 --> 00:12:42,160
bytecode that will be transferred to the

308
00:12:42,160 --> 00:12:43,519
plc

309
00:12:43,519 --> 00:12:46,639
and we also researched the omsp which is

310
00:12:46,639 --> 00:12:48,959
the internal siemens name for s7 com

311
00:12:48,959 --> 00:12:51,760
plus protocol and this dll actually

312
00:12:51,760 --> 00:12:53,200
handles most of the network

313
00:12:53,200 --> 00:12:54,959
communication and we needed to

314
00:12:54,959 --> 00:12:57,600
understand both in order to create our

315
00:12:57,600 --> 00:13:01,600
own bytecode and transfer it to the plc

316
00:13:01,600 --> 00:13:03,839
now if we'll dive in a little bit into

317
00:13:03,839 --> 00:13:06,560
the mc7 plus byte code

318
00:13:06,560 --> 00:13:07,839
then

319
00:13:07,839 --> 00:13:10,560
we're actually getting to the third part

320
00:13:10,560 --> 00:13:13,120
which is transferring the data that we

321
00:13:13,120 --> 00:13:15,760
write in the engineering station to the

322
00:13:15,760 --> 00:13:17,200
plc

323
00:13:17,200 --> 00:13:19,519
now siemens programs

324
00:13:19,519 --> 00:13:22,240
from a very high level perspective

325
00:13:22,240 --> 00:13:24,480
are quite simple we have the main

326
00:13:24,480 --> 00:13:27,040
program that we write and this main

327
00:13:27,040 --> 00:13:29,839
program runs in loops but it can also

328
00:13:29,839 --> 00:13:32,560
call different functions that we write

329
00:13:32,560 --> 00:13:35,040
our functions that we are writing can

330
00:13:35,040 --> 00:13:38,000
make the use of different databases

331
00:13:38,000 --> 00:13:40,480
global databases or local databases

332
00:13:40,480 --> 00:13:42,639
where we can read and write from so we

333
00:13:42,639 --> 00:13:44,639
can store values over there and we can

334
00:13:44,639 --> 00:13:46,839
use those values in our in our

335
00:13:46,839 --> 00:13:49,760
applications and

336
00:13:49,760 --> 00:13:51,920
just to give you a very

337
00:13:51,920 --> 00:13:53,680
simple understanding of what doesn't

338
00:13:53,680 --> 00:13:56,800
mean a function and a global database

339
00:13:56,800 --> 00:13:59,519
let's focus on those two for a moment

340
00:13:59,519 --> 00:14:01,600
so i want to give here a very simple

341
00:14:01,600 --> 00:14:04,320
example let's say we want to create the

342
00:14:04,320 --> 00:14:06,720
move instruction so the move instruction

343
00:14:06,720 --> 00:14:08,240
in assembly

344
00:14:08,240 --> 00:14:10,399
copies data from source to destination

345
00:14:10,399 --> 00:14:11,920
so we have a source and we have a

346
00:14:11,920 --> 00:14:14,399
destination and we're moving data from

347
00:14:14,399 --> 00:14:15,839
the source to the destination and now

348
00:14:15,839 --> 00:14:18,639
the destination holds the value that our

349
00:14:18,639 --> 00:14:20,399
source had now

350
00:14:20,399 --> 00:14:22,480
if we're looking at

351
00:14:22,480 --> 00:14:25,279
a little bit more complex function in

352
00:14:25,279 --> 00:14:27,519
siemens then we have this block in

353
00:14:27,519 --> 00:14:30,720
lighter diagram which does a bulk moving

354
00:14:30,720 --> 00:14:33,680
so it moves variants

355
00:14:33,680 --> 00:14:35,839
from a source as you can see

356
00:14:35,839 --> 00:14:38,480
here in the input operand to the dust

357
00:14:38,480 --> 00:14:41,440
outward operand and it's a bug so there

358
00:14:41,440 --> 00:14:44,959
is a count so we can for example copy

359
00:14:44,959 --> 00:14:48,000
five uh different values uh from source

360
00:14:48,000 --> 00:14:49,360
to destination

361
00:14:49,360 --> 00:14:52,880
and if we look at it from a compilation

362
00:14:52,880 --> 00:14:55,760
process uh perspective then we have this

363
00:14:55,760 --> 00:14:58,720
layer that ladder diagram block and in

364
00:14:58,720 --> 00:15:00,800
the compilation process we're

365
00:15:00,800 --> 00:15:03,760
transferring this graphical block

366
00:15:03,760 --> 00:15:06,560
into an intermediate language which are

367
00:15:06,560 --> 00:15:10,560
the mc7 plus byte code and eventually

368
00:15:10,560 --> 00:15:13,120
this byte code is actually being encoded

369
00:15:13,120 --> 00:15:15,440
on the network line and being sent to

370
00:15:15,440 --> 00:15:18,639
the plc and the plc will execute this

371
00:15:18,639 --> 00:15:21,120
mc7 plus byte code

372
00:15:21,120 --> 00:15:22,800
so this is a very high level uh

373
00:15:22,800 --> 00:15:24,720
perspective of the entire compilation

374
00:15:24,720 --> 00:15:26,399
process and

375
00:15:26,399 --> 00:15:29,040
we used this to do something very cool

376
00:15:29,040 --> 00:15:30,639
because

377
00:15:30,639 --> 00:15:33,360
we wanted to fully control this entire

378
00:15:33,360 --> 00:15:34,399
process

379
00:15:34,399 --> 00:15:35,519
so

380
00:15:35,519 --> 00:15:37,120
we actually

381
00:15:37,120 --> 00:15:41,440
created our own mc7 plus compiler so not

382
00:15:41,440 --> 00:15:44,000
only we created our own our

383
00:15:44,000 --> 00:15:46,639
our own mc7 plus compiler and decompiler

384
00:15:46,639 --> 00:15:49,120
we actually used it to do something very

385
00:15:49,120 --> 00:15:51,519
cool so our compiler and the compiler

386
00:15:51,519 --> 00:15:53,519
works like this as you can see here we

387
00:15:53,519 --> 00:15:54,639
have

388
00:15:54,639 --> 00:15:56,800
the graphical block and on the right

389
00:15:56,800 --> 00:15:59,519
side of the screen there is our compiler

390
00:15:59,519 --> 00:16:02,720
so we actually can take the graphical

391
00:16:02,720 --> 00:16:05,680
blocks and compile it ourselves and also

392
00:16:05,680 --> 00:16:09,120
decompile it later if you want to mc7

393
00:16:09,120 --> 00:16:11,279
plus byte code that we can transfer on

394
00:16:11,279 --> 00:16:13,839
the line to send to the plc so we're not

395
00:16:13,839 --> 00:16:15,680
dependent on the engineering working

396
00:16:15,680 --> 00:16:18,399
station anymore and we can use it

397
00:16:18,399 --> 00:16:20,240
to make our

398
00:16:20,240 --> 00:16:23,839
attack vector or our exploit attempts uh

399
00:16:23,839 --> 00:16:25,600
very easy for us because we're not

400
00:16:25,600 --> 00:16:27,199
dependent on what the engineering

401
00:16:27,199 --> 00:16:29,600
station offers us so as you can see here

402
00:16:29,600 --> 00:16:31,199
this is the add

403
00:16:31,199 --> 00:16:34,000
in ed block and we have all the

404
00:16:34,000 --> 00:16:35,920
different operands the input operands

405
00:16:35,920 --> 00:16:38,480
and the output operands obviously

406
00:16:38,480 --> 00:16:39,680
everything

407
00:16:39,680 --> 00:16:42,079
our compiler can handle

408
00:16:42,079 --> 00:16:43,040
now

409
00:16:43,040 --> 00:16:44,240
we had

410
00:16:44,240 --> 00:16:47,519
this ability in our hands so we can

411
00:16:47,519 --> 00:16:50,800
generate mc7 plus byte code

412
00:16:50,800 --> 00:16:53,040
and we needed to come with up with a

413
00:16:53,040 --> 00:16:55,759
plan on how to exploit them

414
00:16:55,759 --> 00:16:58,160
siemens plcs

415
00:16:58,160 --> 00:17:00,240
we had to come up with an exploitation

416
00:17:00,240 --> 00:17:02,480
plan from a high level perspective so we

417
00:17:02,480 --> 00:17:04,959
could research deep inside how to

418
00:17:04,959 --> 00:17:07,919
execute it and the way we did this is as

419
00:17:07,919 --> 00:17:10,880
follows we understood that as on the

420
00:17:10,880 --> 00:17:13,039
right side of the screen this is uh

421
00:17:13,039 --> 00:17:15,679
schematics of the memory of the pc we

422
00:17:15,679 --> 00:17:17,359
understood that

423
00:17:17,359 --> 00:17:20,640
siemens did something very smart they

424
00:17:20,640 --> 00:17:24,079
created a protected memory area and only

425
00:17:24,079 --> 00:17:26,319
in this protected memory area we can

426
00:17:26,319 --> 00:17:29,440
create pointers so we cannot create our

427
00:17:29,440 --> 00:17:31,520
own pointers we need to ask the

428
00:17:31,520 --> 00:17:33,520
operating system to create a pointer for

429
00:17:33,520 --> 00:17:35,760
us and the the operating system that

430
00:17:35,760 --> 00:17:38,559
donnie's kernel will perform a lot of

431
00:17:38,559 --> 00:17:40,480
checks before creating this pointer to

432
00:17:40,480 --> 00:17:42,240
make sure we're not doing anything

433
00:17:42,240 --> 00:17:43,520
malicious

434
00:17:43,520 --> 00:17:47,440
so our plan was and yeah these pointers

435
00:17:47,440 --> 00:17:49,120
point at uh

436
00:17:49,120 --> 00:17:51,679
normal values for example in the global

437
00:17:51,679 --> 00:17:54,559
database that we can read and write from

438
00:17:54,559 --> 00:17:55,600
now

439
00:17:55,600 --> 00:17:57,679
and they are protected of course

440
00:17:57,679 --> 00:18:01,200
now our plan was to modify somehow we

441
00:18:01,200 --> 00:18:03,760
didn't know at the time but to modify

442
00:18:03,760 --> 00:18:06,400
one of the pointers to point not on a

443
00:18:06,400 --> 00:18:08,880
normal value in the global databases

444
00:18:08,880 --> 00:18:11,200
that we can read and write from but to a

445
00:18:11,200 --> 00:18:13,760
different place that if we will write

446
00:18:13,760 --> 00:18:16,720
data into we will gain code execution so

447
00:18:16,720 --> 00:18:19,440
obviously i'm talking about the kernel

448
00:18:19,440 --> 00:18:22,160
now the way to do this

449
00:18:22,160 --> 00:18:24,880
is not that straightforward but what we

450
00:18:24,880 --> 00:18:26,240
did

451
00:18:26,240 --> 00:18:27,760
was

452
00:18:27,760 --> 00:18:29,280
to find

453
00:18:29,280 --> 00:18:31,760
a bug somewhere in the system that will

454
00:18:31,760 --> 00:18:34,640
allow us to do this and the way to do

455
00:18:34,640 --> 00:18:36,720
this is to find

456
00:18:36,720 --> 00:18:38,240
an instruction

457
00:18:38,240 --> 00:18:41,600
or some kind of a function that will not

458
00:18:41,600 --> 00:18:42,640
check

459
00:18:42,640 --> 00:18:45,679
where we're copying data from into i'll

460
00:18:45,679 --> 00:18:47,840
give an example in just one minute what

461
00:18:47,840 --> 00:18:49,919
you can see here is our reverse

462
00:18:49,919 --> 00:18:51,440
engineering attempts to understand

463
00:18:51,440 --> 00:18:53,760
what's going on so as you can see here

464
00:18:53,760 --> 00:18:56,640
we have an instruction that tries to

465
00:18:56,640 --> 00:18:58,080
check

466
00:18:58,080 --> 00:19:00,640
where are we trying to copy data from

467
00:19:00,640 --> 00:19:03,600
and to so what it will do actually it

468
00:19:03,600 --> 00:19:04,799
will

469
00:19:04,799 --> 00:19:05,840
do all the

470
00:19:05,840 --> 00:19:08,400
verification of the data that we're

471
00:19:08,400 --> 00:19:10,160
trying to copy so it will try to

472
00:19:10,160 --> 00:19:13,200
understand if we're copying data from a

473
00:19:13,200 --> 00:19:15,679
protected memory area or not and if if

474
00:19:15,679 --> 00:19:17,600
we will try to copy data from a

475
00:19:17,600 --> 00:19:20,320
productive memory area it will not allow

476
00:19:20,320 --> 00:19:22,960
us it will block us so

477
00:19:22,960 --> 00:19:25,200
we actually tried to find the

478
00:19:25,200 --> 00:19:26,400
instruction

479
00:19:26,400 --> 00:19:27,440
that

480
00:19:27,440 --> 00:19:30,320
is missing this check so we will try to

481
00:19:30,320 --> 00:19:32,720
find the mc7 plus instruction

482
00:19:32,720 --> 00:19:35,200
that will not check if we're trying to

483
00:19:35,200 --> 00:19:37,840
to copy data from or to a protected

484
00:19:37,840 --> 00:19:41,280
memory area and we will abuse it

485
00:19:41,280 --> 00:19:44,720
to copy data to a protected memory area

486
00:19:44,720 --> 00:19:47,360
and i'll give you in a moment the the

487
00:19:47,360 --> 00:19:49,840
full flow so it will be easier to fl to

488
00:19:49,840 --> 00:19:52,480
follow now obviously we were able to

489
00:19:52,480 --> 00:19:53,679
find

490
00:19:53,679 --> 00:19:56,080
uh such an instruction uh

491
00:19:56,080 --> 00:19:58,640
let's call it a special move and this

492
00:19:58,640 --> 00:20:01,280
special move is actually and it's one of

493
00:20:01,280 --> 00:20:05,440
the mc7 plus instructions that forgot

494
00:20:05,440 --> 00:20:07,039
to check

495
00:20:07,039 --> 00:20:09,840
where are we copying our data to and

496
00:20:09,840 --> 00:20:13,120
from so what did we do with it we have a

497
00:20:13,120 --> 00:20:15,200
special move that we can

498
00:20:15,200 --> 00:20:17,679
copy data from anywhere we want to

499
00:20:17,679 --> 00:20:19,600
anywhere we want so we are not limited

500
00:20:19,600 --> 00:20:20,480
anymore

501
00:20:20,480 --> 00:20:22,799
to copying data

502
00:20:22,799 --> 00:20:25,200
from our global database that we can

503
00:20:25,200 --> 00:20:28,080
read and write but we can copy data

504
00:20:28,080 --> 00:20:30,799
to and from kernel addresses as well

505
00:20:30,799 --> 00:20:32,720
so what we did with it

506
00:20:32,720 --> 00:20:34,480
is as follows

507
00:20:34,480 --> 00:20:36,159
do you remember the

508
00:20:36,159 --> 00:20:38,640
schematics from earlier we have a source

509
00:20:38,640 --> 00:20:40,159
and we have a test and we can use the

510
00:20:40,159 --> 00:20:44,559
normal move so what we did is we set the

511
00:20:44,559 --> 00:20:47,280
source to be a place we can

512
00:20:47,280 --> 00:20:49,120
write to and this is obviously the

513
00:20:49,120 --> 00:20:50,559
global database

514
00:20:50,559 --> 00:20:52,960
and we set the destination to the

515
00:20:52,960 --> 00:20:54,799
protected memory area

516
00:20:54,799 --> 00:20:55,760
so

517
00:20:55,760 --> 00:20:56,799
our

518
00:20:56,799 --> 00:20:58,880
schematics right now looks like this we

519
00:20:58,880 --> 00:21:01,120
have the global database and we have the

520
00:21:01,120 --> 00:21:02,960
protected pointers

521
00:21:02,960 --> 00:21:06,000
memory area we want to write into the

522
00:21:06,000 --> 00:21:08,720
protected memory area and what do we

523
00:21:08,720 --> 00:21:10,880
want to write we want to write pointers

524
00:21:10,880 --> 00:21:13,039
so how do we do this

525
00:21:13,039 --> 00:21:15,679
first we're creating a fake pointer on

526
00:21:15,679 --> 00:21:18,799
the global database this pointer

527
00:21:18,799 --> 00:21:21,919
is fake because the system does not even

528
00:21:21,919 --> 00:21:24,240
think of it as a pointer it's just

529
00:21:24,240 --> 00:21:27,200
random data on the database

530
00:21:27,200 --> 00:21:30,640
now we will make this pointer malicious

531
00:21:30,640 --> 00:21:33,200
why malicious because we will point it

532
00:21:33,200 --> 00:21:35,600
to a kernel address

533
00:21:35,600 --> 00:21:37,760
again right now this is a fake pointer

534
00:21:37,760 --> 00:21:40,880
it has no effect but we can use our

535
00:21:40,880 --> 00:21:44,080
special move to copy this fake pointer

536
00:21:44,080 --> 00:21:45,840
into the protected

537
00:21:45,840 --> 00:21:47,360
pointers pool

538
00:21:47,360 --> 00:21:50,400
and now we have a fake pointer in the

539
00:21:50,400 --> 00:21:52,000
protected pool

540
00:21:52,000 --> 00:21:54,159
and it becomes valid because it's a

541
00:21:54,159 --> 00:21:56,880
pointer it has the struct of a pointer

542
00:21:56,880 --> 00:22:00,080
but it is found within the protected

543
00:22:00,080 --> 00:22:03,039
pointers pool so it's a valid pointer

544
00:22:03,039 --> 00:22:05,120
and what do we do with a valid pointer

545
00:22:05,120 --> 00:22:06,960
that points to the column and we can

546
00:22:06,960 --> 00:22:09,919
interact with it we obviously

547
00:22:09,919 --> 00:22:12,720
uh write shell code to the kernel and

548
00:22:12,720 --> 00:22:15,440
this is exactly what we did we

549
00:22:15,440 --> 00:22:17,840
wrote our shell code to the kernel by

550
00:22:17,840 --> 00:22:20,559
abusing the special move instruction

551
00:22:20,559 --> 00:22:23,280
that we were able to exploit and we

552
00:22:23,280 --> 00:22:25,120
wrote our shell code

553
00:22:25,120 --> 00:22:26,960
into the kernel into the brain of the

554
00:22:26,960 --> 00:22:30,240
plc and by doing so we were able to

555
00:22:30,240 --> 00:22:32,880
achieve many things first of all we

556
00:22:32,880 --> 00:22:33,919
could

557
00:22:33,919 --> 00:22:36,880
execute our code with kernel level

558
00:22:36,880 --> 00:22:39,280
permissions so we were part of the

559
00:22:39,280 --> 00:22:42,400
kernel it's like rewiring your brain and

560
00:22:42,400 --> 00:22:45,600
now the new brain we're part of it

561
00:22:45,600 --> 00:22:48,720
the brain cannot even know that we're

562
00:22:48,720 --> 00:22:50,559
inside the brain

563
00:22:50,559 --> 00:22:52,240
we also

564
00:22:52,240 --> 00:22:53,360
could

565
00:22:53,360 --> 00:22:55,919
besides reading from anywhere we want in

566
00:22:55,919 --> 00:22:58,159
the plc in the memory we could also

567
00:22:58,159 --> 00:23:00,880
write to anywhere we want in the plc and

568
00:23:00,880 --> 00:23:03,440
we could execute code with the highest

569
00:23:03,440 --> 00:23:05,760
privileges the kernel privileges so

570
00:23:05,760 --> 00:23:09,520
basically we can hide code in a way that

571
00:23:09,520 --> 00:23:11,760
no one can find it because we are part

572
00:23:11,760 --> 00:23:14,960
of the plc we are part of the kernel

573
00:23:14,960 --> 00:23:17,440
now i do have a demo to show you how it

574
00:23:17,440 --> 00:23:20,480
works in our demo we're dumping the

575
00:23:20,480 --> 00:23:22,559
siemens plc firmware

576
00:23:22,559 --> 00:23:24,640
but before i'll start the demo uh i'll

577
00:23:24,640 --> 00:23:26,080
explain it a little bit so what we're

578
00:23:26,080 --> 00:23:29,360
doing is we exploited the ms the

579
00:23:29,360 --> 00:23:31,120
siemens device

580
00:23:31,120 --> 00:23:31,919
and

581
00:23:31,919 --> 00:23:34,080
injected our shell code into one of the

582
00:23:34,080 --> 00:23:35,520
siemens

583
00:23:35,520 --> 00:23:38,880
normal functions so for example here

584
00:23:38,880 --> 00:23:40,320
here we

585
00:23:40,320 --> 00:23:42,240
injected our shell code into the sinus

586
00:23:42,240 --> 00:23:45,039
function and we also prepared

587
00:23:45,039 --> 00:23:46,480
a

588
00:23:46,480 --> 00:23:50,080
code a normal code to activate the sinus

589
00:23:50,080 --> 00:23:52,320
function so whenever

590
00:23:52,320 --> 00:23:55,360
our code uses the sinus function we're

591
00:23:55,360 --> 00:23:58,240
actually activating our shell code and

592
00:23:58,240 --> 00:24:00,320
our shell code supports three

593
00:24:00,320 --> 00:24:02,559
functionality it supports a read it

594
00:24:02,559 --> 00:24:04,720
supports write and supports execute so

595
00:24:04,720 --> 00:24:06,960
basically we can tell our shell code

596
00:24:06,960 --> 00:24:09,520
read from this address or write to this

597
00:24:09,520 --> 00:24:12,799
address or execute starting from this

598
00:24:12,799 --> 00:24:14,460
address so let's see the demo

599
00:24:14,460 --> 00:24:17,549
[Music]

600
00:24:17,600 --> 00:24:19,120
should start

601
00:24:19,120 --> 00:24:22,080
yeah okay so

602
00:24:22,240 --> 00:24:24,559
this is the the program that we created

603
00:24:24,559 --> 00:24:26,240
i'm not sure if you can see but there is

604
00:24:26,240 --> 00:24:29,039
a read section right section and execute

605
00:24:29,039 --> 00:24:30,159
section

606
00:24:30,159 --> 00:24:32,320
in this demo we're presenting the read

607
00:24:32,320 --> 00:24:34,320
section so we're activating only the

608
00:24:34,320 --> 00:24:37,039
read and what we're doing is we're

609
00:24:37,039 --> 00:24:38,880
preparing

610
00:24:38,880 --> 00:24:41,039
kind of the fake pointers

611
00:24:41,039 --> 00:24:44,000
with specific addresses that we want to

612
00:24:44,000 --> 00:24:47,840
read from so what we're doing

613
00:24:47,840 --> 00:24:49,600
is we will set

614
00:24:49,600 --> 00:24:51,760
the address that we want to read from

615
00:24:51,760 --> 00:24:55,039
and the count how many

616
00:24:55,039 --> 00:24:57,120
values we want to read how many bytes we

617
00:24:57,120 --> 00:24:58,880
want to read so right now it's set to

618
00:24:58,880 --> 00:25:00,960
1000 and

619
00:25:00,960 --> 00:25:03,039
right now we're setting the address that

620
00:25:03,039 --> 00:25:04,640
we want to read from

621
00:25:04,640 --> 00:25:07,279
and our shell code will execute it and

622
00:25:07,279 --> 00:25:09,840
we'll get the result into another byte

623
00:25:09,840 --> 00:25:13,120
array so now we actually read from

624
00:25:13,120 --> 00:25:16,880
internal kernel memory which is not

625
00:25:16,880 --> 00:25:19,600
possible in any other way

626
00:25:19,600 --> 00:25:21,200
we can play with it a little bit so we

627
00:25:21,200 --> 00:25:22,960
can change how many bytes we want to

628
00:25:22,960 --> 00:25:25,520
read and we will get immediately our

629
00:25:25,520 --> 00:25:29,679
result because our shell code runs in

630
00:25:29,679 --> 00:25:31,120
in loops

631
00:25:31,120 --> 00:25:33,919
and basically what we did with it is

632
00:25:33,919 --> 00:25:36,960
we wrote an automation over it to dump

633
00:25:36,960 --> 00:25:39,679
the entire firmware how did we do it we

634
00:25:39,679 --> 00:25:43,039
just set the count to let's say 10 and

635
00:25:43,039 --> 00:25:46,159
then we read the first 10 bytes change

636
00:25:46,159 --> 00:25:48,559
change the address to 10 and then read

637
00:25:48,559 --> 00:25:50,960
another 10 bytes and so on and so on

638
00:25:50,960 --> 00:25:53,360
until we were able to dump the entire

639
00:25:53,360 --> 00:25:55,679
firmware so

640
00:25:55,679 --> 00:25:58,480
by doing so we were able to gain

641
00:25:58,480 --> 00:26:01,760
uh all of the frameworks that we wanted

642
00:26:01,760 --> 00:26:04,320
at the time before siemens fixed the bug

643
00:26:04,320 --> 00:26:05,679
of course

644
00:26:05,679 --> 00:26:08,400
but we were able to do this and

645
00:26:08,400 --> 00:26:09,440
dump

646
00:26:09,440 --> 00:26:11,840
all of the firmware uh just by writing

647
00:26:11,840 --> 00:26:13,760
an automation

648
00:26:13,760 --> 00:26:16,080
on top of our shell code

649
00:26:16,080 --> 00:26:18,159
now obviously we can also

650
00:26:18,159 --> 00:26:19,760
use this

651
00:26:19,760 --> 00:26:22,159
capability to create denial of service

652
00:26:22,159 --> 00:26:24,240
condition because if we'll try to read

653
00:26:24,240 --> 00:26:27,039
from illegal address we will get access

654
00:26:27,039 --> 00:26:31,200
denied and the plc will crash

655
00:26:31,200 --> 00:26:33,120
and the way to do this is is fairly

656
00:26:33,120 --> 00:26:34,080
simple

657
00:26:34,080 --> 00:26:38,559
all we need to do is read from

658
00:26:39,200 --> 00:26:41,360
address that is zero so we're doing this

659
00:26:41,360 --> 00:26:42,960
right now actually we're trying to read

660
00:26:42,960 --> 00:26:45,679
from address zero and then the plc

661
00:26:45,679 --> 00:26:46,720
crashes

662
00:26:46,720 --> 00:26:48,720
a funny story

663
00:26:48,720 --> 00:26:49,840
uh

664
00:26:49,840 --> 00:26:52,480
throw throughout our research we had to

665
00:26:52,480 --> 00:26:54,400
turn off and turn on the policy tons of

666
00:26:54,400 --> 00:26:56,559
times because we kept on crashing it so

667
00:26:56,559 --> 00:26:58,720
we actually bought a smart relay to do

668
00:26:58,720 --> 00:27:01,600
this remotely but yeah that's the demo

669
00:27:01,600 --> 00:27:03,600
this is how we were able to dump

670
00:27:03,600 --> 00:27:08,158
and execute code on siemens plc's

671
00:27:08,640 --> 00:27:11,919
okay so the

672
00:27:11,919 --> 00:27:13,840
the fun part was the disclosure we

673
00:27:13,840 --> 00:27:14,799
actually

674
00:27:14,799 --> 00:27:17,200
worked with the siemens very closely

675
00:27:17,200 --> 00:27:20,000
so first of all siemens has tons of

676
00:27:20,000 --> 00:27:22,880
protections and security mechanisms

677
00:27:22,880 --> 00:27:26,799
one of them is acl so we can actually as

678
00:27:26,799 --> 00:27:29,120
users we can actually limit the access

679
00:27:29,120 --> 00:27:31,520
to the plc we can limit it to read

680
00:27:31,520 --> 00:27:34,720
access write access or

681
00:27:34,720 --> 00:27:36,559
full access so

682
00:27:36,559 --> 00:27:40,480
our exploit is not pre-authenticated if

683
00:27:40,480 --> 00:27:42,880
the users are activating this feature

684
00:27:42,880 --> 00:27:44,799
and

685
00:27:44,799 --> 00:27:47,760
basically this feature mitigates

686
00:27:47,760 --> 00:27:50,320
our exploit in a way that's

687
00:27:50,320 --> 00:27:52,880
turned off again

688
00:27:52,880 --> 00:27:55,200
mitigate our exploits in a way that

689
00:27:55,200 --> 00:27:57,039
attackers would need to get the password

690
00:27:57,039 --> 00:27:58,240
first

691
00:27:58,240 --> 00:28:00,000
so as i said we worked with siemens very

692
00:28:00,000 --> 00:28:02,960
closely they fixed the bugs

693
00:28:02,960 --> 00:28:03,919
and

694
00:28:03,919 --> 00:28:05,919
we actually had a lot of sessions with

695
00:28:05,919 --> 00:28:06,799
them

696
00:28:06,799 --> 00:28:07,919
where we

697
00:28:07,919 --> 00:28:08,880
did some

698
00:28:08,880 --> 00:28:11,120
brainstorming how to handle this and

699
00:28:11,120 --> 00:28:14,240
what should we do next and obviously

700
00:28:14,240 --> 00:28:18,320
both the 7 7 1200 and the s7 1500

701
00:28:18,320 --> 00:28:21,120
firmwares were fixed and advisories were

702
00:28:21,120 --> 00:28:24,640
created and shared with the public

703
00:28:24,640 --> 00:28:26,399
so to sum up

704
00:28:26,399 --> 00:28:28,960
we did the full research on the siemens

705
00:28:28,960 --> 00:28:33,440
plc is s7 1200 and 1500 uh we kind of

706
00:28:33,440 --> 00:28:35,440
understood the entire mechanism of

707
00:28:35,440 --> 00:28:38,320
download and upload of bytecode to the

708
00:28:38,320 --> 00:28:42,080
plcs and we created our own mc7 plus

709
00:28:42,080 --> 00:28:45,360
bytecode compiler and the compiler and

710
00:28:45,360 --> 00:28:47,279
researched all of the instructions to

711
00:28:47,279 --> 00:28:50,720
find an instruction that did not

712
00:28:50,720 --> 00:28:53,440
that had a missing check and we abused

713
00:28:53,440 --> 00:28:55,520
it to inject our

714
00:28:55,520 --> 00:28:58,880
our shell code to the kernel to achieve

715
00:28:58,880 --> 00:29:00,970
native code execution thank you

716
00:29:00,970 --> 00:29:04,269
[Music]

717
00:29:08,559 --> 00:29:11,340
questions

718
00:29:11,340 --> 00:29:12,960
[Music]

719
00:29:12,960 --> 00:29:15,520
we have one

720
00:29:18,960 --> 00:29:20,480
hey there great presentation can you

721
00:29:20,480 --> 00:29:22,559
elaborate on what additional

722
00:29:22,559 --> 00:29:24,960
capabilities this gives an attacker

723
00:29:24,960 --> 00:29:27,200
relative to just having access to the

724
00:29:27,200 --> 00:29:29,840
workstation and uploading arbitrary

725
00:29:29,840 --> 00:29:30,720
uh

726
00:29:30,720 --> 00:29:33,600
logic to the siemens plc yeah so you're

727
00:29:33,600 --> 00:29:36,880
right when you're saying that attackers

728
00:29:36,880 --> 00:29:39,279
especially in the scada

729
00:29:39,279 --> 00:29:42,159
world would want

730
00:29:42,159 --> 00:29:44,880
to execute logic on the plc that will

731
00:29:44,880 --> 00:29:47,360
control the automation process

732
00:29:47,360 --> 00:29:51,520
but what this gives you is a way to hide

733
00:29:51,520 --> 00:29:54,799
your code on the plc so it's

734
00:29:54,799 --> 00:29:57,919
since we're part of the kernel we can

735
00:29:57,919 --> 00:30:01,200
change the simulated world in a way that

736
00:30:01,200 --> 00:30:03,520
if anyone will try to do an upload and

737
00:30:03,520 --> 00:30:06,320
get what's currently running on the plc

738
00:30:06,320 --> 00:30:07,840
they will see something completely

739
00:30:07,840 --> 00:30:10,720
different so that's the main difference

740
00:30:10,720 --> 00:30:13,520
in the perspective of scada or ics

741
00:30:13,520 --> 00:30:16,000
attacker

742
00:30:18,240 --> 00:30:20,080
thank you for the explanation my name is

743
00:30:20,080 --> 00:30:23,039
k amount of mitsubishi director so as

744
00:30:23,039 --> 00:30:26,320
are one of the plc vendor i'm very

745
00:30:26,320 --> 00:30:29,120
impressed and i'm also feeling scary

746
00:30:29,120 --> 00:30:31,520
about it

747
00:30:31,520 --> 00:30:34,880
so my question do you have any advice

748
00:30:34,880 --> 00:30:38,559
for the siemens or peace vendor

749
00:30:38,559 --> 00:30:40,880
from your experience

750
00:30:40,880 --> 00:30:42,000
yeah so

751
00:30:42,000 --> 00:30:43,600
it's a tough one

752
00:30:43,600 --> 00:30:45,360
i think first of all i think siemens did

753
00:30:45,360 --> 00:30:47,200
an amazing job

754
00:30:47,200 --> 00:30:50,640
their colonel is highly secured and you

755
00:30:50,640 --> 00:30:52,320
know there

756
00:30:52,320 --> 00:30:54,880
i showed it earlier but there are

757
00:30:54,880 --> 00:30:57,200
hundreds of thousands of functions it's

758
00:30:57,200 --> 00:30:59,120
super difficult to control all of them

759
00:30:59,120 --> 00:31:01,840
and make sure all the security or

760
00:31:01,840 --> 00:31:03,760
features are enforced in all of the

761
00:31:03,760 --> 00:31:05,360
functions but

762
00:31:05,360 --> 00:31:07,760
the advice the general advice that i can

763
00:31:07,760 --> 00:31:10,720
give you is to do a lot of pen testings

764
00:31:10,720 --> 00:31:13,440
both internally and externally because

765
00:31:13,440 --> 00:31:16,840
eventually working with researchers with

766
00:31:16,840 --> 00:31:19,840
incentives is very similar to

767
00:31:19,840 --> 00:31:20,960
uh

768
00:31:20,960 --> 00:31:23,279
attack the real life attackers that want

769
00:31:23,279 --> 00:31:26,000
to gain uh remote code execution on the

770
00:31:26,000 --> 00:31:28,399
plc so if you'll do this in a controlled

771
00:31:28,399 --> 00:31:30,399
manner i think you'll find a lot of

772
00:31:30,399 --> 00:31:32,559
stuff

773
00:31:32,559 --> 00:31:34,879
thank you

774
00:31:37,120 --> 00:31:39,760
sorry something confused me very early

775
00:31:39,760 --> 00:31:43,200
on that confuses me but um

776
00:31:43,200 --> 00:31:46,320
you you said you used your exploit to

777
00:31:46,320 --> 00:31:48,240
download a bunch of the encrypted

778
00:31:48,240 --> 00:31:50,240
firmwares but at the very beginning you

779
00:31:50,240 --> 00:31:51,679
were analyzing the whole operating

780
00:31:51,679 --> 00:31:53,840
system with with i have to assume an

781
00:31:53,840 --> 00:31:55,919
unencrypted firmware true

782
00:31:55,919 --> 00:31:56,799
okay

783
00:31:56,799 --> 00:31:58,559
so some of them are encrypted and some

784
00:31:58,559 --> 00:32:01,679
of them are not encrypted is that

785
00:32:01,679 --> 00:32:04,799
getting close true okay we actually used

786
00:32:04,799 --> 00:32:08,080
our exploit to gain access to encrypted

787
00:32:08,080 --> 00:32:10,080
firmwares okay

788
00:32:10,080 --> 00:32:11,360
cool thank you

789
00:32:11,360 --> 00:32:14,360
okay

790
00:32:17,279 --> 00:32:21,399
looks like it thank you

