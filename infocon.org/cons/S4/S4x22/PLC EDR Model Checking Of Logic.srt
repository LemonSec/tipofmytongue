1
00:00:05,120 --> 00:00:08,639
so uh the topic of this talk is the

2
00:00:08,639 --> 00:00:10,960
following to make sure that the code

3
00:00:10,960 --> 00:00:14,639
that runs on a plc behaves correctly so

4
00:00:14,639 --> 00:00:17,119
um i'm not gonna focus on the hardware

5
00:00:17,119 --> 00:00:19,119
or the firmware that's on the plc but

6
00:00:19,119 --> 00:00:21,359
just on the logic that runs on top of

7
00:00:21,359 --> 00:00:22,400
that

8
00:00:22,400 --> 00:00:24,320
and uh so

9
00:00:24,320 --> 00:00:26,960
when is the code correct

10
00:00:26,960 --> 00:00:27,680
uh

11
00:00:27,680 --> 00:00:29,359
we have to give a definition for that

12
00:00:29,359 --> 00:00:31,439
because depending on the people you are

13
00:00:31,439 --> 00:00:33,120
talking to you may get a different

14
00:00:33,120 --> 00:00:35,520
understanding of the word correctness so

15
00:00:35,520 --> 00:00:37,600
for instance if you talk to an end user

16
00:00:37,600 --> 00:00:39,840
of the program he might tell you yeah

17
00:00:39,840 --> 00:00:41,600
the code you gave me is correct because

18
00:00:41,600 --> 00:00:43,360
i i run it for several weeks on my

19
00:00:43,360 --> 00:00:45,520
scenarios and it never failed if you

20
00:00:45,520 --> 00:00:47,920
talk to a programmer he might have a

21
00:00:47,920 --> 00:00:50,000
slightly more precise understanding of

22
00:00:50,000 --> 00:00:52,079
the word correctness it might tell you

23
00:00:52,079 --> 00:00:53,840
the code is correct because it has

24
00:00:53,840 --> 00:00:55,760
passed all the tests

25
00:00:55,760 --> 00:00:59,039
here we go for another definition of

26
00:00:59,039 --> 00:01:00,879
correctness which is

27
00:01:00,879 --> 00:01:03,120
in our opinion more precise which is the

28
00:01:03,120 --> 00:01:04,640
following

29
00:01:04,640 --> 00:01:06,880
if the code is correct if it is

30
00:01:06,880 --> 00:01:09,280
mathematically proven to adhere to them

31
00:01:09,280 --> 00:01:11,360
to some requirements so we take the

32
00:01:11,360 --> 00:01:13,520
requirements of the code we take the

33
00:01:13,520 --> 00:01:16,080
code itself and we use a tool to check

34
00:01:16,080 --> 00:01:18,240
that the requirements are satisfied by

35
00:01:18,240 --> 00:01:20,560
the code

36
00:01:20,560 --> 00:01:22,880
so why are we interested in this well

37
00:01:22,880 --> 00:01:25,040
because there are several actors that

38
00:01:25,040 --> 00:01:27,759
might impair the correctness of the code

39
00:01:27,759 --> 00:01:29,119
one of them you know

40
00:01:29,119 --> 00:01:31,439
very well it's uh attackers from

41
00:01:31,439 --> 00:01:33,280
malicious entities so

42
00:01:33,280 --> 00:01:36,000
like ladder logic bombs so the injection

43
00:01:36,000 --> 00:01:37,439
of some

44
00:01:37,439 --> 00:01:39,920
malicious code and the concealment of

45
00:01:39,920 --> 00:01:41,920
that in such a way that at some point it

46
00:01:41,920 --> 00:01:44,479
will trigger and cause an inconsistency

47
00:01:44,479 --> 00:01:46,880
or the vulnerability exploitation but we

48
00:01:46,880 --> 00:01:48,399
also have to

49
00:01:48,399 --> 00:01:51,280
take care of our own problems so

50
00:01:51,280 --> 00:01:53,759
mistakes that we inflict ourselves which

51
00:01:53,759 --> 00:01:55,840
are essentially bugs

52
00:01:55,840 --> 00:01:57,200
bugs can be

53
00:01:57,200 --> 00:02:00,399
uh you know caused by incompetence a

54
00:02:00,399 --> 00:02:01,920
lack of training

55
00:02:01,920 --> 00:02:03,920
the fact that we work under pressure so

56
00:02:03,920 --> 00:02:06,560
we have to do some urgent quick fix or

57
00:02:06,560 --> 00:02:10,720
outsourcing or many other

58
00:02:10,720 --> 00:02:12,480
sources of bugs

59
00:02:12,480 --> 00:02:14,480
and so what are the counter measures

60
00:02:14,480 --> 00:02:16,319
that we can apply

61
00:02:16,319 --> 00:02:18,080
in order to

62
00:02:18,080 --> 00:02:20,800
preserve the correctness of our program

63
00:02:20,800 --> 00:02:23,360
i'm going to enumerate some of

64
00:02:23,360 --> 00:02:25,599
counter measures that are meaningful

65
00:02:25,599 --> 00:02:26,800
from the point of view of software

66
00:02:26,800 --> 00:02:29,040
engineering so for instance we can do

67
00:02:29,040 --> 00:02:31,040
code review

68
00:02:31,040 --> 00:02:34,319
but code review is a human effort and as

69
00:02:34,319 --> 00:02:37,120
any human effort is error subjected to

70
00:02:37,120 --> 00:02:38,560
to an error

71
00:02:38,560 --> 00:02:40,640
and when you do a code review you have

72
00:02:40,640 --> 00:02:43,040
to enter the mind of the person who has

73
00:02:43,040 --> 00:02:45,280
developed the code and

74
00:02:45,280 --> 00:02:46,800
this is not

75
00:02:46,800 --> 00:02:49,920
easy and to support this thesis i will

76
00:02:49,920 --> 00:02:52,800
uh someone a giant of computer science

77
00:02:52,800 --> 00:02:56,400
kem thompson co-inventor of unix

78
00:02:56,400 --> 00:02:58,480
that once said you can't trust code that

79
00:02:58,480 --> 00:03:01,519
you did not totally create yourself

80
00:03:01,519 --> 00:03:04,159
okay so you can also write tests but

81
00:03:04,159 --> 00:03:05,840
tests depend on the coverage you may

82
00:03:05,840 --> 00:03:08,319
have a lot of tests that cover only a

83
00:03:08,319 --> 00:03:10,319
small portion of your code

84
00:03:10,319 --> 00:03:12,239
and that would be ineffective

85
00:03:12,239 --> 00:03:13,920
and there is another problem with

86
00:03:13,920 --> 00:03:16,480
testing that test can only show the

87
00:03:16,480 --> 00:03:19,760
presence of bugs but not their absence

88
00:03:19,760 --> 00:03:21,519
this is a quote from

89
00:03:21,519 --> 00:03:24,640
another giant giastra

90
00:03:24,640 --> 00:03:28,640
okay so you might also apply some plc

91
00:03:28,640 --> 00:03:30,720
secure coding practices

92
00:03:30,720 --> 00:03:32,080
fine

93
00:03:32,080 --> 00:03:34,319
but again this is a manual effort so you

94
00:03:34,319 --> 00:03:37,200
have to convince people to use them

95
00:03:37,200 --> 00:03:38,640
this is not

96
00:03:38,640 --> 00:03:40,959
always easy to enforce

97
00:03:40,959 --> 00:03:43,599
what we go for in this talk is another

98
00:03:43,599 --> 00:03:45,760
approach which is model checking which i

99
00:03:45,760 --> 00:03:47,040
will explain

100
00:03:47,040 --> 00:03:48,640
uh in the next

101
00:03:48,640 --> 00:03:50,959
few slides and well i i like to think

102
00:03:50,959 --> 00:03:52,400
that these two

103
00:03:52,400 --> 00:03:54,720
people would love to see

104
00:03:54,720 --> 00:03:56,720
this approach listed in a possible

105
00:03:56,720 --> 00:03:58,959
countermeasure for maintaining the

106
00:03:58,959 --> 00:04:00,959
correctness of a program

107
00:04:00,959 --> 00:04:03,200
so what is model checking at least in

108
00:04:03,200 --> 00:04:05,599
the way we apply in in our

109
00:04:05,599 --> 00:04:08,400
experimentation we take a program in our

110
00:04:08,400 --> 00:04:11,760
case a rockwell l5x file

111
00:04:11,760 --> 00:04:15,840
and a query a query is an expression

112
00:04:15,840 --> 00:04:19,120
that is made up on signals that are

113
00:04:19,120 --> 00:04:21,358
inside the program that we would like to

114
00:04:21,358 --> 00:04:23,040
verify

115
00:04:23,040 --> 00:04:25,280
and the outcome of model checking can be

116
00:04:25,280 --> 00:04:26,479
either

117
00:04:26,479 --> 00:04:29,680
that he has found a trace so a trace is

118
00:04:29,680 --> 00:04:32,080
a sequence of input values that if we

119
00:04:32,080 --> 00:04:34,880
were to replay on the original program

120
00:04:34,880 --> 00:04:37,199
would get the program to satisfy the

121
00:04:37,199 --> 00:04:38,880
query so it would get a problem the

122
00:04:38,880 --> 00:04:41,280
program to a state where the query is

123
00:04:41,280 --> 00:04:42,479
satisfied

124
00:04:42,479 --> 00:04:44,560
or model checking can say no trace

125
00:04:44,560 --> 00:04:45,919
exists

126
00:04:45,919 --> 00:04:48,000
and when it says so it means that

127
00:04:48,000 --> 00:04:50,240
internally he has developed a proof a

128
00:04:50,240 --> 00:04:51,759
mathematical proof

129
00:04:51,759 --> 00:04:53,120
that

130
00:04:53,120 --> 00:04:55,440
you know can make sure that

131
00:04:55,440 --> 00:04:58,080
no possible trace can be ever found on

132
00:04:58,080 --> 00:05:00,240
the program in such a way that the query

133
00:05:00,240 --> 00:05:02,639
would would be satisfied

134
00:05:02,639 --> 00:05:06,479
and how is this magic going to work

135
00:05:06,479 --> 00:05:08,400
i cannot go

136
00:05:08,400 --> 00:05:10,320
in the details of the technique because

137
00:05:10,320 --> 00:05:12,800
it requires a lot of background uh in

138
00:05:12,800 --> 00:05:14,560
mathematical logic and

139
00:05:14,560 --> 00:05:16,800
algorithms so i will try to explain it

140
00:05:16,800 --> 00:05:18,800
with an analogy an analogy with a

141
00:05:18,800 --> 00:05:20,800
scientific method which is something

142
00:05:20,800 --> 00:05:23,919
that everybody should be familiar with

143
00:05:23,919 --> 00:05:25,840
so in the scientific method you have a

144
00:05:25,840 --> 00:05:27,759
system that you want to study for

145
00:05:27,759 --> 00:05:29,120
instance

146
00:05:29,120 --> 00:05:31,600
two kids running down a slide

147
00:05:31,600 --> 00:05:34,160
and you observe this phenomenon you make

148
00:05:34,160 --> 00:05:35,600
some

149
00:05:35,600 --> 00:05:37,680
work with your brain and you come up

150
00:05:37,680 --> 00:05:39,360
with the mathematical model the

151
00:05:39,360 --> 00:05:40,960
mathematical model will capture

152
00:05:40,960 --> 00:05:43,759
completely the system under your study

153
00:05:43,759 --> 00:05:45,600
and once you have that you don't even

154
00:05:45,600 --> 00:05:47,759
have to repeat the experiment to

155
00:05:47,759 --> 00:05:49,039
understand

156
00:05:49,039 --> 00:05:51,120
the system the original system it is

157
00:05:51,120 --> 00:05:52,800
completely captured by the mathematical

158
00:05:52,800 --> 00:05:55,919
model so you can take a calculator and

159
00:05:55,919 --> 00:05:57,919
without you know having the kids run

160
00:05:57,919 --> 00:06:00,160
down the slide compute the velocity the

161
00:06:00,160 --> 00:06:02,400
acceleration at any at any point in the

162
00:06:02,400 --> 00:06:03,680
slide

163
00:06:03,680 --> 00:06:05,039
with model checking we do something

164
00:06:05,039 --> 00:06:08,400
similar but with plc code so in our case

165
00:06:08,400 --> 00:06:10,800
the system under study will be the plc

166
00:06:10,800 --> 00:06:11,840
code

167
00:06:11,840 --> 00:06:14,400
and we do some automatic translation by

168
00:06:14,400 --> 00:06:16,960
means of a computer algorithm

169
00:06:16,960 --> 00:06:18,479
into a mathematical model which i

170
00:06:18,479 --> 00:06:20,560
explained in the next slide

171
00:06:20,560 --> 00:06:23,199
and again with the help of a tool we

172
00:06:23,199 --> 00:06:24,880
will be able to do predictions and

173
00:06:24,880 --> 00:06:27,280
calculation on the original program

174
00:06:27,280 --> 00:06:30,000
without actually running it

175
00:06:30,000 --> 00:06:32,160
so what is this

176
00:06:32,160 --> 00:06:34,080
mathematical

177
00:06:34,080 --> 00:06:36,880
model that we will use

178
00:06:36,880 --> 00:06:38,960
it can be explained by this screenshot

179
00:06:38,960 --> 00:06:41,039
this is an actual screenshot taken from

180
00:06:41,039 --> 00:06:44,240
the master thesis of claude shannon in

181
00:06:44,240 --> 00:06:45,840
1940

182
00:06:45,840 --> 00:06:47,919
it looks like a ladder logic program but

183
00:06:47,919 --> 00:06:49,120
it's not it's actually an

184
00:06:49,120 --> 00:06:50,720
electromechanical circuit because at

185
00:06:50,720 --> 00:06:53,599
that time ladder lodge did not exist

186
00:06:53,599 --> 00:06:54,639
and

187
00:06:54,639 --> 00:06:56,560
the observation of shannon is the

188
00:06:56,560 --> 00:06:59,039
following is that that circuit can be

189
00:06:59,039 --> 00:07:00,960
actually translated

190
00:07:00,960 --> 00:07:03,520
or maybe captured by the formula that

191
00:07:03,520 --> 00:07:05,520
you see at the bottom

192
00:07:05,520 --> 00:07:06,880
so

193
00:07:06,880 --> 00:07:08,800
there is a one-to-one correspondence

194
00:07:08,800 --> 00:07:11,039
between the behavior of the circuit and

195
00:07:11,039 --> 00:07:13,120
the mathematical formula at the bottom

196
00:07:13,120 --> 00:07:14,960
once you have translated that into the

197
00:07:14,960 --> 00:07:17,440
formula you can apply all the

198
00:07:17,440 --> 00:07:21,120
mathematical tricks that are available

199
00:07:21,120 --> 00:07:22,319
theorems

200
00:07:22,319 --> 00:07:25,599
formula rewriting synthesis and so on

201
00:07:25,599 --> 00:07:27,599
and therefore

202
00:07:27,599 --> 00:07:29,759
this is really a great contribution it

203
00:07:29,759 --> 00:07:30,560
is

204
00:07:30,560 --> 00:07:33,360
turning the art of writing a circuit

205
00:07:33,360 --> 00:07:35,199
into the science the science of

206
00:07:35,199 --> 00:07:37,360
analyzing the circuit by means of

207
00:07:37,360 --> 00:07:40,160
mathematical formula

208
00:07:40,160 --> 00:07:42,720
so let me just recap our method we take

209
00:07:42,720 --> 00:07:45,199
a ladder logic program

210
00:07:45,199 --> 00:07:48,160
in l5x format

211
00:07:48,160 --> 00:07:50,160
we translate it into a mathematical

212
00:07:50,160 --> 00:07:52,160
model following the

213
00:07:52,160 --> 00:07:54,400
translation that i showed in the

214
00:07:54,400 --> 00:07:56,000
previous slide

215
00:07:56,000 --> 00:07:58,080
and by the way we are submitting a

216
00:07:58,080 --> 00:08:01,360
patent on this translator then we take a

217
00:08:01,360 --> 00:08:02,319
query

218
00:08:02,319 --> 00:08:04,080
we combine the query and the

219
00:08:04,080 --> 00:08:06,400
mathematical model and we give it into a

220
00:08:06,400 --> 00:08:08,319
tool that is called the model checker

221
00:08:08,319 --> 00:08:10,160
and the model check will either produce

222
00:08:10,160 --> 00:08:11,680
a trace so

223
00:08:11,680 --> 00:08:13,520
a set of

224
00:08:13,520 --> 00:08:15,520
you know input values that have to be

225
00:08:15,520 --> 00:08:18,960
given to the original

226
00:08:19,199 --> 00:08:21,520
ladder logic program in order to satisfy

227
00:08:21,520 --> 00:08:24,240
the query or it will say that no trace

228
00:08:24,240 --> 00:08:26,720
can be possibly found

229
00:08:26,720 --> 00:08:29,120
and you won't see all these details in

230
00:08:29,120 --> 00:08:31,039
the next slides but

231
00:08:31,039 --> 00:08:34,000
everything is wrapped by our own

232
00:08:34,000 --> 00:08:36,080
sdk

233
00:08:36,080 --> 00:08:38,719
which looks like this

234
00:08:38,719 --> 00:08:40,559
um

235
00:08:40,559 --> 00:08:42,479
some of you might be familiar with this

236
00:08:42,479 --> 00:08:43,200
uh

237
00:08:43,200 --> 00:08:44,880
you fighter

238
00:08:44,880 --> 00:08:47,200
programming environment essentially it

239
00:08:47,200 --> 00:08:50,000
allows you to write python code and

240
00:08:50,000 --> 00:08:52,480
also produce some nice graphics if you

241
00:08:52,480 --> 00:08:53,279
like

242
00:08:53,279 --> 00:08:56,160
so um here i'm loading

243
00:08:56,160 --> 00:08:57,200
um

244
00:08:57,200 --> 00:08:59,440
the program that you see in the co in

245
00:08:59,440 --> 00:09:04,240
the upper right corner it's essentially

246
00:09:04,399 --> 00:09:06,560
a very stupid program it's a

247
00:09:06,560 --> 00:09:09,839
it's a counter a handmade counter

248
00:09:09,839 --> 00:09:13,200
okay that it increases at every cycle of

249
00:09:13,200 --> 00:09:16,720
the plc if the input x is evaluated to

250
00:09:16,720 --> 00:09:18,399
true

251
00:09:18,399 --> 00:09:20,800
when the uh

252
00:09:20,800 --> 00:09:22,480
the value of the counter reaches the

253
00:09:22,480 --> 00:09:26,080
value 10 the coil flag is turned to

254
00:09:26,080 --> 00:09:28,000
is set to true as well

255
00:09:28,000 --> 00:09:32,240
so let me now run this program

256
00:09:33,360 --> 00:09:36,480
so i have recorded it

257
00:09:36,480 --> 00:09:38,320
and this is what

258
00:09:38,320 --> 00:09:40,560
the tool is able to produce

259
00:09:40,560 --> 00:09:43,440
it is able to synthesize a trace

260
00:09:43,440 --> 00:09:45,600
where it says essentially that you have

261
00:09:45,600 --> 00:09:48,160
to set the variable x

262
00:09:48,160 --> 00:09:51,440
every time to true in such a way that

263
00:09:51,440 --> 00:09:54,480
the counter in 10 steps will reach

264
00:09:54,480 --> 00:09:57,120
the value 10 and therefore the flag can

265
00:09:57,120 --> 00:10:00,160
get to the value true as well

266
00:10:00,160 --> 00:10:03,040
okay so this is a very simple example to

267
00:10:03,040 --> 00:10:04,720
show something

268
00:10:04,720 --> 00:10:06,480
more

269
00:10:06,480 --> 00:10:08,959
involved i will introduce now

270
00:10:08,959 --> 00:10:11,120
another example it's a simple

271
00:10:11,120 --> 00:10:13,120
example of an elevator it's a classical

272
00:10:13,120 --> 00:10:15,680
elevator

273
00:10:15,680 --> 00:10:17,760
where the cabin can go up and down in

274
00:10:17,760 --> 00:10:19,040
three stories

275
00:10:19,040 --> 00:10:20,160
there is a

276
00:10:20,160 --> 00:10:21,839
motor that can

277
00:10:21,839 --> 00:10:24,399
move the elevator up and down so we have

278
00:10:24,399 --> 00:10:26,959
two output signals up motor and down

279
00:10:26,959 --> 00:10:29,760
motor that are able to move the elevator

280
00:10:29,760 --> 00:10:31,360
and there are some

281
00:10:31,360 --> 00:10:34,000
buttons the pink buttons are the buttons

282
00:10:34,000 --> 00:10:36,160
that can be used to call the elevator at

283
00:10:36,160 --> 00:10:37,839
a particular level

284
00:10:37,839 --> 00:10:42,160
and the yellow boxes are sensors

285
00:10:42,160 --> 00:10:44,560
so the sensor detects

286
00:10:44,560 --> 00:10:47,440
whether the elevator is at a particular

287
00:10:47,440 --> 00:10:48,800
floor

288
00:10:48,800 --> 00:10:49,600
and

289
00:10:49,600 --> 00:10:51,920
we also have some logic to control the

290
00:10:51,920 --> 00:10:54,880
cabin doors so there is a motor to open

291
00:10:54,880 --> 00:10:56,399
and close the doors

292
00:10:56,399 --> 00:10:58,800
and there are again two sensors that are

293
00:10:58,800 --> 00:11:00,720
able to understand if the door is open

294
00:11:00,720 --> 00:11:03,279
or closed

295
00:11:03,680 --> 00:11:06,240
uh i have coded this example and it

296
00:11:06,240 --> 00:11:09,440
turns out to have 16 runs 10 inputs for

297
00:11:09,440 --> 00:11:12,560
outputs two timers and nine variables i

298
00:11:12,560 --> 00:11:15,440
have adapted from the website that it's

299
00:11:15,440 --> 00:11:17,839
listed at the bottom

300
00:11:17,839 --> 00:11:19,279
okay so

301
00:11:19,279 --> 00:11:21,680
let me show the first application

302
00:11:21,680 --> 00:11:23,839
of model checking

303
00:11:23,839 --> 00:11:26,640
to this running example

304
00:11:26,640 --> 00:11:29,120
so let's write some requirements that

305
00:11:29,120 --> 00:11:31,200
this example should satisfy in order to

306
00:11:31,200 --> 00:11:32,800
be correct

307
00:11:32,800 --> 00:11:34,320
so if we really

308
00:11:34,320 --> 00:11:36,240
run out of uh

309
00:11:36,240 --> 00:11:39,279
you know of ideas we can

310
00:11:39,279 --> 00:11:42,320
for instance apply try to apply the plc

311
00:11:42,320 --> 00:11:44,959
secure plc coding guideline number seven

312
00:11:44,959 --> 00:11:46,720
which says

313
00:11:46,720 --> 00:11:49,279
make sure that paired signals are not

314
00:11:49,279 --> 00:11:51,040
inserted together

315
00:11:51,040 --> 00:11:53,839
in our example we do have paired signals

316
00:11:53,839 --> 00:11:56,399
we have up motor and down motor so we

317
00:11:56,399 --> 00:11:58,079
for instance we can say

318
00:11:58,079 --> 00:12:00,880
at motor and down motor must not be true

319
00:12:00,880 --> 00:12:02,880
at the same time this will be our first

320
00:12:02,880 --> 00:12:04,560
requirement

321
00:12:04,560 --> 00:12:07,440
then we also have the requirement for

322
00:12:07,440 --> 00:12:10,560
the door so we don't want the door uh to

323
00:12:10,560 --> 00:12:12,800
be you know opening and closing at the

324
00:12:12,800 --> 00:12:14,720
same time that will be our second

325
00:12:14,720 --> 00:12:16,079
requirement

326
00:12:16,079 --> 00:12:17,839
uh then we can add some safety

327
00:12:17,839 --> 00:12:20,160
requirement like while the elevator is

328
00:12:20,160 --> 00:12:22,399
moving up i don't want the door to be

329
00:12:22,399 --> 00:12:24,560
opened because otherwise i will

330
00:12:24,560 --> 00:12:27,519
scratch my face against the moving wall

331
00:12:27,519 --> 00:12:29,839
and i don't want the same when the

332
00:12:29,839 --> 00:12:32,000
elevator is going down

333
00:12:32,000 --> 00:12:33,920
so these first requirements they find

334
00:12:33,920 --> 00:12:36,000
something that the elevator

335
00:12:36,000 --> 00:12:39,200
must not be doing we can also define

336
00:12:39,200 --> 00:12:41,600
some requirements that say the elevator

337
00:12:41,600 --> 00:12:44,160
must be doing something so we can for

338
00:12:44,160 --> 00:12:46,399
instance say that eventually the door

339
00:12:46,399 --> 00:12:48,399
must be opening

340
00:12:48,399 --> 00:12:50,399
okay that eventually the door must be

341
00:12:50,399 --> 00:12:51,600
closing

342
00:12:51,600 --> 00:12:52,560
that

343
00:12:52,560 --> 00:12:55,440
at some point it is possible to

344
00:12:55,440 --> 00:12:57,120
start the motor

345
00:12:57,120 --> 00:12:59,519
in the up direction and in the

346
00:12:59,519 --> 00:13:01,839
down direction

347
00:13:01,839 --> 00:13:03,920
so we have defined two kinds of

348
00:13:03,920 --> 00:13:05,120
requirements

349
00:13:05,120 --> 00:13:07,920
the red requirements are those for which

350
00:13:07,920 --> 00:13:10,399
a trace is not expected out of our

351
00:13:10,399 --> 00:13:12,800
system because if we were to find the

352
00:13:12,800 --> 00:13:15,279
trace that it would mean that the query

353
00:13:15,279 --> 00:13:17,839
would be satisfied instead we are we

354
00:13:17,839 --> 00:13:19,920
don't want the query to be satisfied we

355
00:13:19,920 --> 00:13:21,760
just don't want to find any possible

356
00:13:21,760 --> 00:13:24,399
example that would make up motor and

357
00:13:24,399 --> 00:13:27,600
down motor asserted at the same time

358
00:13:27,600 --> 00:13:30,720
the blue requirements instead are

359
00:13:30,720 --> 00:13:32,480
requirements for which a trace is

360
00:13:32,480 --> 00:13:35,279
expected we want to see an example

361
00:13:35,279 --> 00:13:36,800
that would lead to the door to be

362
00:13:36,800 --> 00:13:39,600
opening or closing or the motor going up

363
00:13:39,600 --> 00:13:41,600
or down

364
00:13:41,600 --> 00:13:44,240
so again i have loaded all these

365
00:13:44,240 --> 00:13:47,360
requirements into our sdk

366
00:13:47,360 --> 00:13:49,839
and for the first four

367
00:13:49,839 --> 00:13:52,560
we won't see

368
00:13:52,560 --> 00:13:54,639
much it will say that no trace is

369
00:13:54,639 --> 00:13:57,199
expected

370
00:13:57,680 --> 00:14:00,160
and for the other ones instead it will

371
00:14:00,160 --> 00:14:02,560
produce some counter example now i will

372
00:14:02,560 --> 00:14:04,079
stop on

373
00:14:04,079 --> 00:14:05,600
to example i

374
00:14:05,600 --> 00:14:09,600
just have the video run until the end

375
00:14:09,600 --> 00:14:12,399
and then i will

376
00:14:13,600 --> 00:14:16,399
okay i can just advance

377
00:14:16,399 --> 00:14:17,519
um

378
00:14:17,519 --> 00:14:18,240
so

379
00:14:18,240 --> 00:14:20,160
this is an example where

380
00:14:20,160 --> 00:14:21,279
um

381
00:14:21,279 --> 00:14:23,760
the requirement is satisfied

382
00:14:23,760 --> 00:14:25,920
and it doesn't produce a trace so our

383
00:14:25,920 --> 00:14:28,399
system is correct because it is never

384
00:14:28,399 --> 00:14:31,279
the case that up motor and down motor

385
00:14:31,279 --> 00:14:33,600
can be asserted at the same time

386
00:14:33,600 --> 00:14:36,000
if you remember we have taken

387
00:14:36,000 --> 00:14:38,000
this requirement for

388
00:14:38,000 --> 00:14:41,120
the plc coding guideline number seven so

389
00:14:41,120 --> 00:14:43,279
effectively effectively what we have

390
00:14:43,279 --> 00:14:45,680
done we have proven

391
00:14:45,680 --> 00:14:48,399
we have we have found a way to automate

392
00:14:48,399 --> 00:14:51,440
the checking of rule number seven in our

393
00:14:51,440 --> 00:14:53,839
system

394
00:14:54,160 --> 00:14:57,120
this is another example where instead

395
00:14:57,120 --> 00:14:58,720
we were

396
00:14:58,720 --> 00:15:02,399
producing a counter a trace for for the

397
00:15:02,399 --> 00:15:04,480
for the requirement so this is an

398
00:15:04,480 --> 00:15:06,399
example where down motor

399
00:15:06,399 --> 00:15:07,199
is

400
00:15:07,199 --> 00:15:10,000
supposed to be activated and

401
00:15:10,000 --> 00:15:13,760
i can readily take this trace and

402
00:15:13,760 --> 00:15:16,079
understand what's going on in my system

403
00:15:16,079 --> 00:15:19,120
so in this case i have the elevator that

404
00:15:19,120 --> 00:15:21,600
is at the second floor because variable

405
00:15:21,600 --> 00:15:24,320
at second floor is set to true

406
00:15:24,320 --> 00:15:27,040
and somebody has pushed the button for

407
00:15:27,040 --> 00:15:28,399
the first floor

408
00:15:28,399 --> 00:15:33,440
and as an effect the motor is going down

409
00:15:34,560 --> 00:15:35,839
so how can

410
00:15:35,839 --> 00:15:39,040
this requirement and the tool be used

411
00:15:39,040 --> 00:15:42,320
one way is to do

412
00:15:42,320 --> 00:15:43,360
one

413
00:15:43,360 --> 00:15:44,959
development process that we call

414
00:15:44,959 --> 00:15:47,120
requirement driven development maybe

415
00:15:47,120 --> 00:15:49,120
some of you will be familiar with the

416
00:15:49,120 --> 00:15:51,440
notion of test driven

417
00:15:51,440 --> 00:15:54,480
development it is a software engineering

418
00:15:54,480 --> 00:15:56,240
method where you first develop your

419
00:15:56,240 --> 00:15:58,560
tests and then you develop your program

420
00:15:58,560 --> 00:16:00,959
until your tests are satisfied and here

421
00:16:00,959 --> 00:16:03,120
we can do something similar we can write

422
00:16:03,120 --> 00:16:06,399
our requirements first and iterate in

423
00:16:06,399 --> 00:16:08,880
the making of the program until all the

424
00:16:08,880 --> 00:16:12,240
requirements are satisfied

425
00:16:12,240 --> 00:16:14,000
another usage for

426
00:16:14,000 --> 00:16:15,519
checking the requirements is the

427
00:16:15,519 --> 00:16:18,320
classical no regression so we have the

428
00:16:18,320 --> 00:16:20,639
version the first version of the program

429
00:16:20,639 --> 00:16:22,639
which satisfies all the requirements and

430
00:16:22,639 --> 00:16:24,079
now i have to

431
00:16:24,079 --> 00:16:26,800
produce another version of the program

432
00:16:26,800 --> 00:16:27,600
and

433
00:16:27,600 --> 00:16:29,600
if it's not correct some requirements

434
00:16:29,600 --> 00:16:33,199
will not be satisfied

435
00:16:33,199 --> 00:16:35,440
so now i'm showing and showing you the

436
00:16:35,440 --> 00:16:36,959
uh this second approach this no

437
00:16:36,959 --> 00:16:39,600
regression to defend from from an attack

438
00:16:39,600 --> 00:16:42,240
it is a it is a toy attack for a toy

439
00:16:42,240 --> 00:16:45,279
example so nothing very uh probably

440
00:16:45,279 --> 00:16:47,759
interesting in practice but

441
00:16:47,759 --> 00:16:50,240
here it is so i have taken

442
00:16:50,240 --> 00:16:53,120
a rung here that controls the

443
00:16:53,120 --> 00:16:54,959
um the opening

444
00:16:54,959 --> 00:16:56,720
of the of the door

445
00:16:56,720 --> 00:16:59,279
and i have added some more opportunity

446
00:16:59,279 --> 00:17:02,959
for the door to get open

447
00:17:03,279 --> 00:17:06,240
and uh okay so maybe this is uh the

448
00:17:06,240 --> 00:17:08,880
result of some development

449
00:17:08,880 --> 00:17:09,919
and

450
00:17:09,919 --> 00:17:12,079
you know now i didn't make any

451
00:17:12,079 --> 00:17:14,079
uh particular

452
00:17:14,079 --> 00:17:16,799
effort in concealing this logic but you

453
00:17:16,799 --> 00:17:19,520
know maybe mixed up with a lot of other

454
00:17:19,520 --> 00:17:20,959
other

455
00:17:20,959 --> 00:17:24,480
commits for the same

456
00:17:24,799 --> 00:17:26,720
for for the same uh you know

457
00:17:26,720 --> 00:17:29,120
implementation

458
00:17:29,120 --> 00:17:31,760
it can be passed unnoticed

459
00:17:31,760 --> 00:17:34,160
but what happens when i run my

460
00:17:34,160 --> 00:17:35,760
my tool

461
00:17:35,760 --> 00:17:37,679
so the result is the following

462
00:17:37,679 --> 00:17:40,559
this requirement was initially

463
00:17:40,559 --> 00:17:43,600
producing no counter example no trace

464
00:17:43,600 --> 00:17:44,840
okay

465
00:17:44,840 --> 00:17:46,559
because

466
00:17:46,559 --> 00:17:48,720
it was not supposed to happen it is not

467
00:17:48,720 --> 00:17:51,280
supposed to happen that the door gets

468
00:17:51,280 --> 00:17:53,919
open while the elevator is moving up but

469
00:17:53,919 --> 00:17:55,360
now

470
00:17:55,360 --> 00:17:57,360
in the new version of the program

471
00:17:57,360 --> 00:17:59,760
we have gotten a trace

472
00:17:59,760 --> 00:18:02,480
so if we analyze the trace

473
00:18:02,480 --> 00:18:05,679
we can observe the following that

474
00:18:05,679 --> 00:18:07,760
the elevator is initially at the ground

475
00:18:07,760 --> 00:18:09,520
floor

476
00:18:09,520 --> 00:18:12,080
and somebody pushes the button to

477
00:18:12,080 --> 00:18:15,520
activate the motor to go up

478
00:18:15,520 --> 00:18:18,480
immediately after

479
00:18:18,480 --> 00:18:20,880
the next execution of the cycle of the

480
00:18:20,880 --> 00:18:21,919
plc

481
00:18:21,919 --> 00:18:25,280
we get into the following state that

482
00:18:25,280 --> 00:18:27,840
the upper motor is still going up that

483
00:18:27,840 --> 00:18:29,840
the door is opening

484
00:18:29,840 --> 00:18:31,919
but there is also this strange thing

485
00:18:31,919 --> 00:18:33,600
that you know

486
00:18:33,600 --> 00:18:35,760
the cabin is supposed to be at the

487
00:18:35,760 --> 00:18:38,320
second floor which is something that is

488
00:18:38,320 --> 00:18:40,080
physically not possible in the original

489
00:18:40,080 --> 00:18:41,200
problem

490
00:18:41,200 --> 00:18:43,200
in the original program but now it's

491
00:18:43,200 --> 00:18:44,559
kind of possible

492
00:18:44,559 --> 00:18:47,120
uh because of the little modification

493
00:18:47,120 --> 00:18:49,440
that we have done

494
00:18:49,440 --> 00:18:50,880
to the program

495
00:18:50,880 --> 00:18:53,440
and uh this suggests an opportunity for

496
00:18:53,440 --> 00:18:57,200
an attacker to actually

497
00:18:57,200 --> 00:19:00,799
violate this property here so if we put

498
00:19:00,799 --> 00:19:04,400
something here some device or some other

499
00:19:04,400 --> 00:19:07,039
thing that is able to tamper with the

500
00:19:07,039 --> 00:19:09,760
sensor at the second floor then we could

501
00:19:09,760 --> 00:19:12,480
get the violation of the of the original

502
00:19:12,480 --> 00:19:13,919
requirement so

503
00:19:13,919 --> 00:19:16,240
by means of running this algorithm i am

504
00:19:16,240 --> 00:19:18,160
able to discover some potential

505
00:19:18,160 --> 00:19:21,760
opportunity for an attacker to violate

506
00:19:21,760 --> 00:19:24,480
the requirements of my

507
00:19:24,480 --> 00:19:27,120
of my program

508
00:19:27,120 --> 00:19:29,760
so another application that we can have

509
00:19:29,760 --> 00:19:31,760
for these techniques is the so-called

510
00:19:31,760 --> 00:19:33,520
equivalence checking

511
00:19:33,520 --> 00:19:35,520
in equivalence checking

512
00:19:35,520 --> 00:19:38,480
we don't actually write the requirements

513
00:19:38,480 --> 00:19:39,520
for

514
00:19:39,520 --> 00:19:42,720
our program but rather we focus on

515
00:19:42,720 --> 00:19:45,039
a version of the program that we call

516
00:19:45,039 --> 00:19:47,200
the golden version so maybe it is a

517
00:19:47,200 --> 00:19:48,799
program that it's run it has been

518
00:19:48,799 --> 00:19:51,679
running for years and it is running fine

519
00:19:51,679 --> 00:19:53,280
and we are very confident that it is

520
00:19:53,280 --> 00:19:55,280
correct

521
00:19:55,280 --> 00:19:57,200
and we want to make sure

522
00:19:57,200 --> 00:19:59,840
that the new version of the program is

523
00:19:59,840 --> 00:20:02,640
actually equivalent to the first one

524
00:20:02,640 --> 00:20:05,280
so how can we do that well instead of

525
00:20:05,280 --> 00:20:06,960
defining the requirements and

526
00:20:06,960 --> 00:20:10,400
translating the model of the programs we

527
00:20:10,400 --> 00:20:12,880
actually translate both models of the

528
00:20:12,880 --> 00:20:14,000
program

529
00:20:14,000 --> 00:20:17,600
and inside the translation we

530
00:20:17,600 --> 00:20:20,240
actually connect the input values the

531
00:20:20,240 --> 00:20:23,440
input signals to both the

532
00:20:23,440 --> 00:20:26,559
the golden and the new ladder

533
00:20:26,559 --> 00:20:29,679
and we ask the tool whether these are

534
00:20:29,679 --> 00:20:32,320
different or not so if the two models

535
00:20:32,320 --> 00:20:35,200
are the same then given the same input

536
00:20:35,200 --> 00:20:37,039
you will get the same output but if the

537
00:20:37,039 --> 00:20:39,440
tool is able to find a value for the

538
00:20:39,440 --> 00:20:43,039
inputs that will get the output

539
00:20:43,039 --> 00:20:45,200
to not agree anymore then it means that

540
00:20:45,200 --> 00:20:47,679
there is a difference in behavior

541
00:20:47,679 --> 00:20:49,520
between the previous and the new version

542
00:20:49,520 --> 00:20:51,760
of the program and

543
00:20:51,760 --> 00:20:54,159
if we run our tool again

544
00:20:54,159 --> 00:20:56,799
this time instead of defining some

545
00:20:56,799 --> 00:20:58,720
requirements i actually

546
00:20:58,720 --> 00:21:01,280
give as input both the original and the

547
00:21:01,280 --> 00:21:04,480
modified program then we get again to

548
00:21:04,480 --> 00:21:06,960
find a difference so now the difference

549
00:21:06,960 --> 00:21:07,919
is

550
00:21:07,919 --> 00:21:10,000
um on the

551
00:21:10,000 --> 00:21:11,039
output

552
00:21:11,039 --> 00:21:13,520
open door motor and

553
00:21:13,520 --> 00:21:16,559
from from the design a and the design b

554
00:21:16,559 --> 00:21:19,039
and it is exactly the same the counter

555
00:21:19,039 --> 00:21:21,840
example that we would find

556
00:21:21,840 --> 00:21:24,720
that we found before with the modified

557
00:21:24,720 --> 00:21:28,640
attack for the ladder logic

558
00:21:29,039 --> 00:21:32,320
okay so what i have shown you is

559
00:21:32,320 --> 00:21:34,240
two potential applications of model

560
00:21:34,240 --> 00:21:35,360
checking

561
00:21:35,360 --> 00:21:36,480
to uh

562
00:21:36,480 --> 00:21:37,280
some

563
00:21:37,280 --> 00:21:39,200
logic from

564
00:21:39,200 --> 00:21:41,679
ladder logic from the rockwell

565
00:21:41,679 --> 00:21:44,000
environment and we have shown the

566
00:21:44,000 --> 00:21:45,760
requirement checking where we define

567
00:21:45,760 --> 00:21:47,440
some requirements and we check if they

568
00:21:47,440 --> 00:21:49,440
are correct or equivalence checking

569
00:21:49,440 --> 00:21:51,679
whether we compare to designs for

570
00:21:51,679 --> 00:21:53,520
equivalence

571
00:21:53,520 --> 00:21:56,080
what i've done here i have focused on

572
00:21:56,080 --> 00:21:58,240
the ladder logic but the method can be

573
00:21:58,240 --> 00:22:00,559
applied also to the other languages that

574
00:22:00,559 --> 00:22:03,360
are available from from the standard

575
00:22:03,360 --> 00:22:05,760
you just need to have to provide a

576
00:22:05,760 --> 00:22:07,919
translator i just did the ladder because

577
00:22:07,919 --> 00:22:09,840
it's the easiest

578
00:22:09,840 --> 00:22:12,559
language to be translated

579
00:22:12,559 --> 00:22:14,720
and

580
00:22:14,720 --> 00:22:17,200
from what i've shown here it's something

581
00:22:17,200 --> 00:22:19,520
very easy to do but it might not be the

582
00:22:19,520 --> 00:22:20,799
case because

583
00:22:20,799 --> 00:22:25,280
normally programs are not designed to be

584
00:22:25,280 --> 00:22:27,200
you know

585
00:22:27,200 --> 00:22:30,960
to be modular enough to be analyzed and

586
00:22:30,960 --> 00:22:32,960
sometimes there is no separation between

587
00:22:32,960 --> 00:22:35,520
the logic from the rest of the program

588
00:22:35,520 --> 00:22:37,840
and essentially we need to in order to

589
00:22:37,840 --> 00:22:39,760
apply these techniques in an effective

590
00:22:39,760 --> 00:22:42,400
way we need to define a sort of design

591
00:22:42,400 --> 00:22:45,039
for checking paradigms

592
00:22:45,039 --> 00:22:45,840
and

593
00:22:45,840 --> 00:22:48,400
this is perfectly in line with the

594
00:22:48,400 --> 00:22:51,440
plc secure coding guideline number one

595
00:22:51,440 --> 00:22:54,080
where that it suggests to split the code

596
00:22:54,080 --> 00:22:56,000
into modules

597
00:22:56,000 --> 00:22:58,000
and uh yeah i

598
00:22:58,000 --> 00:23:00,400
myself i'm not a plc programmer i know

599
00:23:00,400 --> 00:23:02,640
how to program plc's but i don't do it

600
00:23:02,640 --> 00:23:04,240
professionally so

601
00:23:04,240 --> 00:23:06,400
i wish that i could talk to somebody who

602
00:23:06,400 --> 00:23:09,919
is more expert than me and maybe have a

603
00:23:09,919 --> 00:23:12,159
discussion on what is useful and what is

604
00:23:12,159 --> 00:23:15,120
not about the methods i have shown

605
00:23:15,120 --> 00:23:18,240
and perhaps one way to have these

606
00:23:18,240 --> 00:23:19,679
techniques

607
00:23:19,679 --> 00:23:22,159
applied in practice is to squeeze them

608
00:23:22,159 --> 00:23:23,760
inside

609
00:23:23,760 --> 00:23:25,919
the available ids in such a way that

610
00:23:25,919 --> 00:23:28,480
could be applied

611
00:23:28,480 --> 00:23:30,400
transparently by the user without

612
00:23:30,400 --> 00:23:32,320
knowing the internals

613
00:23:32,320 --> 00:23:34,320
of the various

614
00:23:34,320 --> 00:23:36,480
mechanisms that are

615
00:23:36,480 --> 00:23:39,840
to be applied under the hood

616
00:23:39,840 --> 00:23:42,080
and

617
00:23:43,120 --> 00:23:45,440
okay it was blocked

618
00:23:45,440 --> 00:23:47,679
and uh so at the zombie networks we are

619
00:23:47,679 --> 00:23:49,039
working to

620
00:23:49,039 --> 00:23:51,440
integrate these techniques inside our

621
00:23:51,440 --> 00:23:53,200
tool chains to

622
00:23:53,200 --> 00:23:54,720
in order to have

623
00:23:54,720 --> 00:23:55,600
you know

624
00:23:55,600 --> 00:23:57,679
an even higher level of protection for

625
00:23:57,679 --> 00:24:00,159
our customers and

626
00:24:00,159 --> 00:24:02,559
that is my last glide so if there is any

627
00:24:02,559 --> 00:24:04,559
question i'm

628
00:24:04,559 --> 00:24:07,360
ready to take them

629
00:24:08,400 --> 00:24:11,440
there is a mic there

630
00:24:14,159 --> 00:24:16,320
functional block

631
00:24:16,320 --> 00:24:18,960
yeah so as i was mentioning in the slide

632
00:24:18,960 --> 00:24:21,600
uh you need to have a translation from

633
00:24:21,600 --> 00:24:23,840
that language to

634
00:24:23,840 --> 00:24:25,919
the framework that i made i made just a

635
00:24:25,919 --> 00:24:28,080
translation from ladder but it is also

636
00:24:28,080 --> 00:24:30,080
possible to do with the fbd language as

637
00:24:30,080 --> 00:24:33,080
well

638
00:24:39,840 --> 00:24:40,720
okay

639
00:24:40,720 --> 00:24:42,000
i don't see

640
00:24:42,000 --> 00:24:45,600
any other raised hand oh yeah

641
00:24:45,600 --> 00:24:47,840
yes

642
00:25:01,520 --> 00:25:04,520
um

643
00:25:18,320 --> 00:25:21,320
uh

644
00:25:34,880 --> 00:25:37,039
thank you

645
00:25:37,039 --> 00:25:40,200
thank you

646
00:25:42,080 --> 00:25:43,760
okay

647
00:25:43,760 --> 00:25:46,080
it is also possible to you know tackle

648
00:25:46,080 --> 00:25:48,000
other vendors uh with the with the

649
00:25:48,000 --> 00:25:49,840
rockwell format it's very easy because

650
00:25:49,840 --> 00:25:52,320
it's essentially an xml so it's easy to

651
00:25:52,320 --> 00:25:53,919
parse and to

652
00:25:53,919 --> 00:25:57,120
modify other vendors doesn't have

653
00:25:57,120 --> 00:25:58,880
such an easy way to

654
00:25:58,880 --> 00:26:01,039
parse the programs that you write in the

655
00:26:01,039 --> 00:26:03,760
their ids

656
00:26:07,760 --> 00:26:10,880
so how do you kind of see this fitting

657
00:26:10,880 --> 00:26:12,559
together besides you talked about an ide

658
00:26:12,559 --> 00:26:14,320
but as you know zomi kind of fits into a

659
00:26:14,320 --> 00:26:15,520
different space in the marketplace so

660
00:26:15,520 --> 00:26:17,279
kind of how do you see this fitting

661
00:26:17,279 --> 00:26:18,720
together with kind of what nozomi's

662
00:26:18,720 --> 00:26:20,400
doing overall

663
00:26:20,400 --> 00:26:21,520
yeah this is something that we are

664
00:26:21,520 --> 00:26:22,840
working

665
00:26:22,840 --> 00:26:27,200
on especially the method that i okay now

666
00:26:27,200 --> 00:26:30,000
the slides are no longer visible

667
00:26:30,000 --> 00:26:32,240
but the equivalence checking okay thank

668
00:26:32,240 --> 00:26:33,440
you

669
00:26:33,440 --> 00:26:35,279
the

670
00:26:35,279 --> 00:26:37,600
equivalence checking here

671
00:26:37,600 --> 00:26:40,000
can be really useful when you

672
00:26:40,000 --> 00:26:43,039
notice that on the network there is some

673
00:26:43,039 --> 00:26:45,440
you know upload of a new program

674
00:26:45,440 --> 00:26:47,440
you can run this kind of algorithm and

675
00:26:47,440 --> 00:26:49,840
see if you really get the expected

676
00:26:49,840 --> 00:26:52,320
result so if you were intended to modify

677
00:26:52,320 --> 00:26:54,960
the logic or if it was just you know an

678
00:26:54,960 --> 00:26:56,960
accidental

679
00:26:56,960 --> 00:26:59,200
or malicious kind of program

680
00:26:59,200 --> 00:27:01,679
modification

681
00:27:01,679 --> 00:27:03,600
so out of curiosity is spinning from

682
00:27:03,600 --> 00:27:05,760
that

683
00:27:05,760 --> 00:27:07,200
you've been talking mostly focusing on

684
00:27:07,200 --> 00:27:08,240
the actual code but i was kind of

685
00:27:08,240 --> 00:27:09,840
curious to do you guys look into all

686
00:27:09,840 --> 00:27:10,880
that kind of applying kind of

687
00:27:10,880 --> 00:27:12,000
traditional

688
00:27:12,000 --> 00:27:13,679
you know binary analysis approaches to

689
00:27:13,679 --> 00:27:14,799
you know maybe

690
00:27:14,799 --> 00:27:16,320
actual binaries that are being uploaded

691
00:27:16,320 --> 00:27:17,520
with uh

692
00:27:17,520 --> 00:27:18,720
you know the plc as opposed to the

693
00:27:18,720 --> 00:27:22,960
actual as opposed to the written logic

694
00:27:22,960 --> 00:27:25,440
uh sorry i didn't get exactly because

695
00:27:25,440 --> 00:27:27,520
there is a fun up here and

696
00:27:27,520 --> 00:27:29,360
sorry i was curious

697
00:27:29,360 --> 00:27:30,240
have you guys played around with the

698
00:27:30,240 --> 00:27:31,679
idea of looking at the binary files that

699
00:27:31,679 --> 00:27:33,120
are uploaded themselves rather than the

700
00:27:33,120 --> 00:27:35,039
actual you know structured text so

701
00:27:35,039 --> 00:27:37,279
binary files is another matter of course

702
00:27:37,279 --> 00:27:39,120
you would need to reverse engineer them

703
00:27:39,120 --> 00:27:41,600
and reconstruct the actual logic but

704
00:27:41,600 --> 00:27:43,440
yeah that is something also interesting

705
00:27:43,440 --> 00:27:46,399
to to think about yeah

706
00:27:46,399 --> 00:27:49,559
thank you

707
00:27:50,000 --> 00:27:51,840
real briefly does your tool support

708
00:27:51,840 --> 00:27:54,000
analysis of custom written aois or is

709
00:27:54,000 --> 00:27:56,240
that a feature that needs to be added

710
00:27:56,240 --> 00:27:59,120
no this is not actually a tool that we

711
00:27:59,120 --> 00:28:01,279
can sell or provide to the user this is

712
00:28:01,279 --> 00:28:03,679
an investigation that we have done

713
00:28:03,679 --> 00:28:06,399
so we have taken our own toy examples

714
00:28:06,399 --> 00:28:08,240
and what we have in house

715
00:28:08,240 --> 00:28:10,880
and uh you know it is just a way to

716
00:28:10,880 --> 00:28:12,399
prove that these techniques have a

717
00:28:12,399 --> 00:28:15,279
future that can be used and then from

718
00:28:15,279 --> 00:28:16,880
from this point on this is a starting

719
00:28:16,880 --> 00:28:19,039
point we will move on and perhaps

720
00:28:19,039 --> 00:28:21,360
capture more and more logic from

721
00:28:21,360 --> 00:28:23,039
uh you know

722
00:28:23,039 --> 00:28:26,720
more plcs more vendors and more features

723
00:28:26,720 --> 00:28:29,440
thank you thank you

724
00:28:29,440 --> 00:28:32,799
yes yeah can you deal with uh analog

725
00:28:32,799 --> 00:28:35,200
values analog inputs and outputs like

726
00:28:35,200 --> 00:28:36,880
can you do some kind of constraint

727
00:28:36,880 --> 00:28:38,799
checking yeah it is possible to deal

728
00:28:38,799 --> 00:28:41,440
with them yes because the tool supports

729
00:28:41,440 --> 00:28:44,080
a floating point logic and also it has

730
00:28:44,080 --> 00:28:46,559
some abstraction to deal with real

731
00:28:46,559 --> 00:28:49,760
arithmetic so this is difficult to do

732
00:28:49,760 --> 00:28:51,760
but it can be done and uh well it's

733
00:28:51,760 --> 00:28:53,520
already supported actually i just don't

734
00:28:53,520 --> 00:28:55,360
have examples i was gonna ask if you had

735
00:28:55,360 --> 00:28:57,679
like timing examples how long that takes

736
00:28:57,679 --> 00:28:58,799
usually

737
00:28:58,799 --> 00:29:00,399
yeah so in that case you would have to

738
00:29:00,399 --> 00:29:03,120
do some sort of obstruction and say you

739
00:29:03,120 --> 00:29:03,840
know

740
00:29:03,840 --> 00:29:06,720
my timer you know take a slices of this

741
00:29:06,720 --> 00:29:10,080
timer and say you know 100 iterations

742
00:29:10,080 --> 00:29:13,760
are actually compacted to some unit and

743
00:29:13,760 --> 00:29:15,279
you know some

744
00:29:15,279 --> 00:29:16,880
one-time stamp or something like that

745
00:29:16,880 --> 00:29:19,120
but yeah it's something difficult but it

746
00:29:19,120 --> 00:29:22,639
can be worked out thank you

747
00:29:25,279 --> 00:29:27,600
okay i guess the time is over

748
00:29:27,600 --> 00:29:30,399
thank you very much for your attention

749
00:29:30,399 --> 00:29:31,360
and

750
00:29:31,360 --> 00:29:34,678
see you again

