1
00:00:04,720 --> 00:00:06,560
uh hello everyone i'm really happy to

2
00:00:06,560 --> 00:00:08,240
see all of you in this beautiful city of

3
00:00:08,240 --> 00:00:10,880
miami so my name is alexi and i'm going

4
00:00:10,880 --> 00:00:13,280
to represent a new network's company

5
00:00:13,280 --> 00:00:16,800
today one of leaders in ot and iot

6
00:00:16,800 --> 00:00:19,039
space and

7
00:00:19,039 --> 00:00:20,880
my role is threatened english manners so

8
00:00:20,880 --> 00:00:23,199
i'm a

9
00:00:23,199 --> 00:00:24,800
leading the

10
00:00:24,800 --> 00:00:27,199
ti team who is responsible for all types

11
00:00:27,199 --> 00:00:30,160
of malware related operations including

12
00:00:30,160 --> 00:00:32,000
detections research

13
00:00:32,000 --> 00:00:34,160
extending our own infrastructure and

14
00:00:34,160 --> 00:00:36,399
today i'm here to present something a

15
00:00:36,399 --> 00:00:38,480
little bit more technical just to show

16
00:00:38,480 --> 00:00:42,079
the capabilities of our team and

17
00:00:42,079 --> 00:00:43,600
i would in the end i would be happy to

18
00:00:43,600 --> 00:00:44,399
answer

19
00:00:44,399 --> 00:00:46,399
all the questions related to

20
00:00:46,399 --> 00:00:48,879
this particular operations if you have

21
00:00:48,879 --> 00:00:50,879
any more questions we will be available

22
00:00:50,879 --> 00:00:52,800
at the company sessions later where you

23
00:00:52,800 --> 00:00:54,879
can get more insights into our rich

24
00:00:54,879 --> 00:00:58,800
products portfolio so uh first of all

25
00:00:58,800 --> 00:00:59,600
when

26
00:00:59,600 --> 00:01:02,000
i started my career everything was

27
00:01:02,000 --> 00:01:03,680
focused around windows yeah windows

28
00:01:03,680 --> 00:01:05,600
windows windows this is a great very

29
00:01:05,600 --> 00:01:07,840
versatile system which

30
00:01:07,840 --> 00:01:10,080
all of us are very well aware of

31
00:01:10,080 --> 00:01:11,920
it's great for everyone for teenagers

32
00:01:11,920 --> 00:01:16,000
playing video games for uh financial

33
00:01:16,000 --> 00:01:17,520
specialists

34
00:01:17,520 --> 00:01:19,600
doing banking transactions and of course

35
00:01:19,600 --> 00:01:22,159
it's widely used in ot space as well

36
00:01:22,159 --> 00:01:24,720
for example as hmi

37
00:01:24,720 --> 00:01:25,600
so

38
00:01:25,600 --> 00:01:28,159
and uh when we are talking about uh ot

39
00:01:28,159 --> 00:01:31,439
id and iot uh particularly in terms of

40
00:01:31,439 --> 00:01:33,680
detections the

41
00:01:33,680 --> 00:01:35,119
border between them becomes really

42
00:01:35,119 --> 00:01:37,840
blurry so let's think about hmi yeah

43
00:01:37,840 --> 00:01:39,520
it's a windows based machine

44
00:01:39,520 --> 00:01:42,000
it can be affected by stuxnet which is

45
00:01:42,000 --> 00:01:43,680
perfectly aware of

46
00:01:43,680 --> 00:01:45,759
what ot is and

47
00:01:45,759 --> 00:01:47,680
how to take advantage of it and it can

48
00:01:47,680 --> 00:01:49,200
also be affected by some banking

49
00:01:49,200 --> 00:01:50,920
software which is completely unrelated

50
00:01:50,920 --> 00:01:54,560
to ot and may not actually possess a

51
00:01:54,560 --> 00:01:56,399
real threat to the

52
00:01:56,399 --> 00:01:59,040
company where it may end up in hmi

53
00:01:59,040 --> 00:02:00,880
device for example

54
00:02:00,880 --> 00:02:02,560
so um

55
00:02:02,560 --> 00:02:04,880
same applies to iot yeah

56
00:02:04,880 --> 00:02:07,439
some cameras may be used to monitor the

57
00:02:07,439 --> 00:02:10,000
operational manufacturing process and uh

58
00:02:10,000 --> 00:02:12,160
whether they're affected by

59
00:02:12,160 --> 00:02:15,760
iot threat or not it's up to reverse

60
00:02:15,760 --> 00:02:17,520
engineers to tell exactly what our

61
00:02:17,520 --> 00:02:18,720
capabilities

62
00:02:18,720 --> 00:02:20,879
what attackers can achieve and what is

63
00:02:20,879 --> 00:02:24,000
their motivation so and

64
00:02:24,000 --> 00:02:26,560
when you talk about iot malware they

65
00:02:26,560 --> 00:02:29,840
share lots of counterparts with their

66
00:02:29,840 --> 00:02:32,400
windows based uh

67
00:02:32,400 --> 00:02:35,120
colleagues so um when you talk about

68
00:02:35,120 --> 00:02:37,680
ultimatewear most of them are based on

69
00:02:37,680 --> 00:02:39,920
linux operating system

70
00:02:39,920 --> 00:02:43,040
mirai keyboard and many many many others

71
00:02:43,040 --> 00:02:44,319
so and

72
00:02:44,319 --> 00:02:45,680
one of

73
00:02:45,680 --> 00:02:46,959
the

74
00:02:46,959 --> 00:02:50,080
things that they share is attempting to

75
00:02:50,080 --> 00:02:52,000
evade detection

76
00:02:52,000 --> 00:02:53,840
there are multiple names how this

77
00:02:53,840 --> 00:02:54,959
process can

78
00:02:54,959 --> 00:02:57,120
be known under it can be anti-reverse

79
00:02:57,120 --> 00:02:58,959
engineering it can be anti-debugging

80
00:02:58,959 --> 00:03:01,360
which is actually a subset of it so but

81
00:03:01,360 --> 00:03:04,400
basically the idea is the same they are

82
00:03:04,400 --> 00:03:06,720
going to prolongate the infection

83
00:03:06,720 --> 00:03:08,720
process as long as possible in order to

84
00:03:08,720 --> 00:03:11,920
maximize the gains for some of malware

85
00:03:11,920 --> 00:03:13,599
categories it's less applicable so for

86
00:03:13,599 --> 00:03:15,840
example for ransomware as long as they

87
00:03:15,840 --> 00:03:19,760
hit the system and they affect the file

88
00:03:19,760 --> 00:03:21,920
it's done they don't care anymore how

89
00:03:21,920 --> 00:03:24,000
long they can be

90
00:03:24,000 --> 00:03:26,319
there it may be more important for

91
00:03:26,319 --> 00:03:27,840
example during the lateral movement when

92
00:03:27,840 --> 00:03:29,519
they propagate across the network and

93
00:03:29,519 --> 00:03:31,840
try to get as many systems as possible

94
00:03:31,840 --> 00:03:33,200
whether it's

95
00:03:33,200 --> 00:03:36,239
it ot or any other

96
00:03:36,239 --> 00:03:38,000
sector for attackers it may not

97
00:03:38,000 --> 00:03:40,239
necessarily be matter as long as enough

98
00:03:40,239 --> 00:03:42,959
systems is being affected so today i'm

99
00:03:42,959 --> 00:03:44,239
going to present

100
00:03:44,239 --> 00:03:46,159
research done by our threatened elders

101
00:03:46,159 --> 00:03:48,959
team again just to show some of our

102
00:03:48,959 --> 00:03:52,080
capabilities and insights into iot space

103
00:03:52,080 --> 00:03:53,120
so

104
00:03:53,120 --> 00:03:55,040
here in particular we are going to focus

105
00:03:55,040 --> 00:03:56,480
on

106
00:03:56,480 --> 00:03:58,640
parking techniques what is packing so

107
00:03:58,640 --> 00:04:00,560
for some of you who may not necessarily

108
00:04:00,560 --> 00:04:02,640
have a reverse engineering background

109
00:04:02,640 --> 00:04:04,879
there are various ways how malware can

110
00:04:04,879 --> 00:04:06,879
try to evade the detection they may

111
00:04:06,879 --> 00:04:09,519
encrypt certain important pieces of data

112
00:04:09,519 --> 00:04:11,519
strings configurations

113
00:04:11,519 --> 00:04:14,080
pieces of code they may apply techniques

114
00:04:14,080 --> 00:04:15,840
like application anti-debugging to

115
00:04:15,840 --> 00:04:17,680
interfere with the

116
00:04:17,680 --> 00:04:19,680
debugger attached

117
00:04:19,680 --> 00:04:21,519
packing it's a

118
00:04:21,519 --> 00:04:22,560
more

119
00:04:22,560 --> 00:04:25,120
universal term generally it is being

120
00:04:25,120 --> 00:04:27,360
used when we're talking about big blocks

121
00:04:27,360 --> 00:04:29,840
of code and data being

122
00:04:29,840 --> 00:04:32,800
compressed in most cases but sometimes

123
00:04:32,800 --> 00:04:35,840
it can be only encrypted and this is how

124
00:04:35,840 --> 00:04:38,080
malware protects itself so

125
00:04:38,080 --> 00:04:40,720
your existing signature based solutions

126
00:04:40,720 --> 00:04:42,479
may fail to

127
00:04:42,479 --> 00:04:44,960
detect it as long as the sample is new

128
00:04:44,960 --> 00:04:47,120
so existing iocs

129
00:04:47,120 --> 00:04:49,280
don't work for them and the actual code

130
00:04:49,280 --> 00:04:51,280
and data are not available and you can't

131
00:04:51,280 --> 00:04:54,240
detect a threat by detecting packed code

132
00:04:54,240 --> 00:04:56,880
it's just a high entropy random looking

133
00:04:56,880 --> 00:04:57,759
block

134
00:04:57,759 --> 00:05:00,800
the unpacking code is standard if

135
00:05:00,800 --> 00:05:02,639
well-known legitimate product is being

136
00:05:02,639 --> 00:05:04,160
used to

137
00:05:04,160 --> 00:05:06,479
perform it so you have a problem unless

138
00:05:06,479 --> 00:05:08,720
you are able to unpack it and see

139
00:05:08,720 --> 00:05:10,479
exactly what's going on what is the

140
00:05:10,479 --> 00:05:12,560
actual functionality of the thread

141
00:05:12,560 --> 00:05:14,320
so here in this research we are going to

142
00:05:14,320 --> 00:05:16,400
explore the current status of packers

143
00:05:16,400 --> 00:05:19,280
used in the wild by iot malware

144
00:05:19,280 --> 00:05:21,520
uh what was what the landscape what

145
00:05:21,520 --> 00:05:23,039
attackers have been used where we are

146
00:05:23,039 --> 00:05:25,120
now basically

147
00:05:25,120 --> 00:05:27,440
the research has been done using the

148
00:05:27,440 --> 00:05:29,759
chain of nasal networks iot honeypots

149
00:05:29,759 --> 00:05:31,680
which are spread around the groups

150
00:05:31,680 --> 00:05:33,919
various sensors

151
00:05:33,919 --> 00:05:35,600
from where we are collecting data from

152
00:05:35,600 --> 00:05:37,840
and we also have a dedicated system to

153
00:05:37,840 --> 00:05:41,039
aggregate it and reach the data and

154
00:05:41,039 --> 00:05:42,800
use it for research for generating

155
00:05:42,800 --> 00:05:44,720
automatic detection for sharing with

156
00:05:44,720 --> 00:05:47,039
partners for all

157
00:05:47,039 --> 00:05:49,759
possible needs basically and in the end

158
00:05:49,759 --> 00:05:52,320
i'm going to cover a few techniques of

159
00:05:52,320 --> 00:05:55,440
how packers for iot space can be

160
00:05:55,440 --> 00:05:57,120
approached in general there are lots of

161
00:05:57,120 --> 00:05:58,960
resources how to do it for windows based

162
00:05:58,960 --> 00:06:01,199
threats but there are very little to

163
00:06:01,199 --> 00:06:04,160
know universal approaches for iot space

164
00:06:04,160 --> 00:06:05,440
so this is what i'm going to present

165
00:06:05,440 --> 00:06:06,720
today to you

166
00:06:06,720 --> 00:06:08,160
so um

167
00:06:08,160 --> 00:06:10,400
honeypot basically as

168
00:06:10,400 --> 00:06:12,400
i'm sure most of you know honeypots are

169
00:06:12,400 --> 00:06:14,880
just vulnerable systems that

170
00:06:14,880 --> 00:06:19,120
aim at being hacked they aim at

171
00:06:19,120 --> 00:06:20,639
emulate certain functionality which

172
00:06:20,639 --> 00:06:23,120
attackers may be interested in and the

173
00:06:23,120 --> 00:06:25,600
data which we collect there can be used

174
00:06:25,600 --> 00:06:28,560
for all types of cyber security purposes

175
00:06:28,560 --> 00:06:30,479
including detections research and

176
00:06:30,479 --> 00:06:34,400
creating new defenses so um

177
00:06:34,400 --> 00:06:36,800
what we did is over a particular period

178
00:06:36,800 --> 00:06:38,479
of time we

179
00:06:38,479 --> 00:06:40,800
collected data across

180
00:06:40,800 --> 00:06:42,720
all different sensors emulating various

181
00:06:42,720 --> 00:06:44,960
vulnerable protocols the top ones in iot

182
00:06:44,960 --> 00:06:47,759
are still ssh and telnet we will popular

183
00:06:47,759 --> 00:06:49,360
which were popularized

184
00:06:49,360 --> 00:06:51,680
by mirai obviously but we also

185
00:06:51,680 --> 00:06:53,840
maintained a few others obviously

186
00:06:53,840 --> 00:06:54,720
and

187
00:06:54,720 --> 00:06:57,360
over the course of seven days period we

188
00:06:57,360 --> 00:07:01,120
collected more than 200 unique samples

189
00:07:01,120 --> 00:07:02,960
from various attacking attempts as you

190
00:07:02,960 --> 00:07:04,960
can see on this diagram most of them

191
00:07:04,960 --> 00:07:07,440
were actually elf binaries alph is the

192
00:07:07,440 --> 00:07:10,800
most common format for in the unix and

193
00:07:10,800 --> 00:07:12,479
linux world

194
00:07:12,479 --> 00:07:14,960
and 32-bit operating system is still the

195
00:07:14,960 --> 00:07:17,120
most widely used the actual architecture

196
00:07:17,120 --> 00:07:19,199
varies so

197
00:07:19,199 --> 00:07:22,639
l files can be used for x86 both 32 and

198
00:07:22,639 --> 00:07:27,759
64 bits for arm mips spark power pc

199
00:07:27,759 --> 00:07:28,840
motorola

200
00:07:28,840 --> 00:07:31,840
68k the actual architecture doesn't

201
00:07:31,840 --> 00:07:33,280
matter

202
00:07:33,280 --> 00:07:36,400
it will affect the instruction set used

203
00:07:36,400 --> 00:07:37,520
by

204
00:07:37,520 --> 00:07:40,080
kind of produced by compiler but the

205
00:07:40,080 --> 00:07:42,319
actual format will be the same elf

206
00:07:42,319 --> 00:07:44,479
so and as you can see the vast majority

207
00:07:44,479 --> 00:07:47,599
was actually for elf 32-bit

208
00:07:47,599 --> 00:07:48,960
uh

209
00:07:48,960 --> 00:07:51,120
when we started looking at packing

210
00:07:51,120 --> 00:07:52,160
methods

211
00:07:52,160 --> 00:07:54,400
uh approximately one-third of them was

212
00:07:54,400 --> 00:07:57,199
packed with upx there is no surprise uh

213
00:07:57,199 --> 00:08:00,800
upx is a most widely known open source

214
00:08:00,800 --> 00:08:02,639
packer which is widely used by most

215
00:08:02,639 --> 00:08:04,639
legitimate companies just to reduce the

216
00:08:04,639 --> 00:08:06,720
size of distributed binaries and

217
00:08:06,720 --> 00:08:10,160
malicious actors as well so and actually

218
00:08:10,160 --> 00:08:12,479
still after all these years upx was the

219
00:08:12,479 --> 00:08:15,120
only one known that has been used

220
00:08:15,120 --> 00:08:17,599
by all types of actors

221
00:08:17,599 --> 00:08:19,039
um

222
00:08:19,039 --> 00:08:20,479
when we're talking about mirai for

223
00:08:20,479 --> 00:08:21,520
example

224
00:08:21,520 --> 00:08:22,720
uh

225
00:08:22,720 --> 00:08:25,120
they not necessarily the attackers

226
00:08:25,120 --> 00:08:26,639
the people who distribute it will not

227
00:08:26,639 --> 00:08:28,879
necessarily apply packing techniques in

228
00:08:28,879 --> 00:08:31,039
general to protect their brain children

229
00:08:31,039 --> 00:08:34,159
so for example in case of

230
00:08:34,159 --> 00:08:36,080
original mirai the

231
00:08:36,080 --> 00:08:38,159
simple xor

232
00:08:38,159 --> 00:08:39,839
encryption was applied against

233
00:08:39,839 --> 00:08:42,000
credentials which were very easy to spot

234
00:08:42,000 --> 00:08:43,919
and detect the threat

235
00:08:43,919 --> 00:08:45,440
apart from that there were a few other

236
00:08:45,440 --> 00:08:46,800
techniques like

237
00:08:46,800 --> 00:08:49,920
using ptrace to interfere with debugging

238
00:08:49,920 --> 00:08:51,839
we don't call it packing when we talk

239
00:08:51,839 --> 00:08:53,920
about pakin it's a particular term and

240
00:08:53,920 --> 00:08:56,560
here upx was there only one kind of

241
00:08:56,560 --> 00:08:59,600
actor it makes sense because

242
00:08:59,600 --> 00:09:00,880
the

243
00:09:00,880 --> 00:09:03,279
market of open source bikers is

244
00:09:03,279 --> 00:09:05,040
unfortunately still very limited and

245
00:09:05,040 --> 00:09:06,160
upex

246
00:09:06,160 --> 00:09:09,279
is probably one of very few solutions

247
00:09:09,279 --> 00:09:11,440
available to general public

248
00:09:11,440 --> 00:09:12,560
to

249
00:09:12,560 --> 00:09:14,640
protect their programs another reason is

250
00:09:14,640 --> 00:09:15,440
the

251
00:09:15,440 --> 00:09:17,040
purpose of original protectors they were

252
00:09:17,040 --> 00:09:18,399
created to

253
00:09:18,399 --> 00:09:21,839
for copyright reasons so that

254
00:09:21,839 --> 00:09:24,000
game developers have to

255
00:09:24,000 --> 00:09:26,560
pay the fluid developers can protect

256
00:09:26,560 --> 00:09:28,640
their products against piracy in open

257
00:09:28,640 --> 00:09:30,399
source it doesn't make much sense in

258
00:09:30,399 --> 00:09:32,240
many many cases

259
00:09:32,240 --> 00:09:34,000
open source is distributed for free so

260
00:09:34,000 --> 00:09:36,640
there is nothing to protect

261
00:09:36,640 --> 00:09:37,760
in this case

262
00:09:37,760 --> 00:09:39,839
um

263
00:09:39,839 --> 00:09:43,200
what we did after that we looked at the

264
00:09:43,200 --> 00:09:44,959
set of samples we collected and we

265
00:09:44,959 --> 00:09:47,760
looked at all the samples which were not

266
00:09:47,760 --> 00:09:49,680
present and not detected on various

267
00:09:49,680 --> 00:09:52,399
total aristotle is a

268
00:09:52,399 --> 00:09:55,279
shared website where everybody can see

269
00:09:55,279 --> 00:09:57,120
how many various detection engines

270
00:09:57,120 --> 00:09:59,040
detected a particular sample we were

271
00:09:59,040 --> 00:10:01,600
interested in something which

272
00:10:01,600 --> 00:10:04,560
the community didn't know about before

273
00:10:04,560 --> 00:10:05,279
or

274
00:10:05,279 --> 00:10:06,959
they knew about but they didn't think

275
00:10:06,959 --> 00:10:08,959
it's a threat until we started looking

276
00:10:08,959 --> 00:10:11,279
at it and in this case the subset of

277
00:10:11,279 --> 00:10:13,600
file shared very similar distribution

278
00:10:13,600 --> 00:10:15,519
slightly less not one third but one

279
00:10:15,519 --> 00:10:18,480
fourth of them was again packed with the

280
00:10:18,480 --> 00:10:20,959
upx

281
00:10:21,279 --> 00:10:23,519
um

282
00:10:23,519 --> 00:10:26,720
upx is well known it's open source and

283
00:10:26,720 --> 00:10:28,880
it provides actually tool to both and

284
00:10:28,880 --> 00:10:31,600
compress and decompress the payloads

285
00:10:31,600 --> 00:10:33,600
and obviously for attackers it's far

286
00:10:33,600 --> 00:10:35,600
from ideal if everybody can immediately

287
00:10:35,600 --> 00:10:38,640
decompress the payload

288
00:10:38,640 --> 00:10:40,480
there is no point in actually putting an

289
00:10:40,480 --> 00:10:42,000
extra effort that's why attackers

290
00:10:42,000 --> 00:10:43,760
generally apply certain additional

291
00:10:43,760 --> 00:10:45,680
techniques in order to complicate the

292
00:10:45,680 --> 00:10:47,279
analysis complicate the unpacking and

293
00:10:47,279 --> 00:10:49,440
usually what they do they apply certain

294
00:10:49,440 --> 00:10:51,200
modifications to their

295
00:10:51,200 --> 00:10:53,600
result sample structure in order to

296
00:10:53,600 --> 00:10:56,560
prevent their original epx tool from

297
00:10:56,560 --> 00:11:00,040
unpacking it

298
00:11:00,320 --> 00:11:02,800
in most cases iot sample apply very

299
00:11:02,800 --> 00:11:05,440
particular modifications which will make

300
00:11:05,440 --> 00:11:08,079
the sample executable still it will not

301
00:11:08,079 --> 00:11:11,120
affect the actual functionality but the

302
00:11:11,120 --> 00:11:13,680
upx itself will treat it as a foreign

303
00:11:13,680 --> 00:11:16,079
sample and will refuse to unpack it

304
00:11:16,079 --> 00:11:19,200
there are two particular structures that

305
00:11:19,200 --> 00:11:22,079
have been used so far which is p info

306
00:11:22,079 --> 00:11:24,320
and l info

307
00:11:24,320 --> 00:11:27,600
both of them are can be found in the

308
00:11:27,600 --> 00:11:31,200
source code of upx for l-files

309
00:11:31,200 --> 00:11:34,320
and different families tend to apply

310
00:11:34,320 --> 00:11:36,000
different modifications for these

311
00:11:36,000 --> 00:11:37,760
structures in the result samples in

312
00:11:37,760 --> 00:11:39,760
order to prevent samples from being

313
00:11:39,760 --> 00:11:42,720
unpacked the classic one is the changing

314
00:11:42,720 --> 00:11:45,519
the l magic value of l infrastructure

315
00:11:45,519 --> 00:11:46,560
it's a

316
00:11:46,560 --> 00:11:48,800
hard coded signature upx exclamation

317
00:11:48,800 --> 00:11:50,800
mark if you overwrite it with anything

318
00:11:50,800 --> 00:11:53,040
your pxx will stop recognizing it but

319
00:11:53,040 --> 00:11:55,440
the sample remains perfectly executable

320
00:11:55,440 --> 00:11:57,440
this is what most attackers

321
00:11:57,440 --> 00:12:00,240
do for example sb diet which is the one

322
00:12:00,240 --> 00:12:01,279
that we

323
00:12:01,279 --> 00:12:03,680
analyzed a few months ago

324
00:12:03,680 --> 00:12:05,760
is famous for using this technique

325
00:12:05,760 --> 00:12:09,600
mozi another example of iot threats

326
00:12:09,600 --> 00:12:12,720
fully different strategy so it targets

327
00:12:12,720 --> 00:12:16,079
the p info structure and it changes the

328
00:12:16,079 --> 00:12:18,560
file size and block size of the values

329
00:12:18,560 --> 00:12:21,279
it changes to zero upx

330
00:12:21,279 --> 00:12:22,240
thinks it doesn't have enough

331
00:12:22,240 --> 00:12:23,760
information to unpack it which is not

332
00:12:23,760 --> 00:12:24,959
exactly true

333
00:12:24,959 --> 00:12:26,639
even though it refuses to unpack it the

334
00:12:26,639 --> 00:12:28,160
sample remains perfectly executable and

335
00:12:28,160 --> 00:12:30,320
the unpacking code which now comprises

336
00:12:30,320 --> 00:12:32,720
part of their packed sample

337
00:12:32,720 --> 00:12:34,399
works perfectly fine

338
00:12:34,399 --> 00:12:37,920
which also means that researchers can

339
00:12:37,920 --> 00:12:39,519
follow the steps that unpacking code

340
00:12:39,519 --> 00:12:40,639
follows and

341
00:12:40,639 --> 00:12:43,680
unpack the sample manually

342
00:12:43,680 --> 00:12:44,720
but

343
00:12:44,720 --> 00:12:47,760
they need to know how to do it

344
00:12:48,000 --> 00:12:50,240
during this research we

345
00:12:50,240 --> 00:12:52,320
accidentally encountered a new challenge

346
00:12:52,320 --> 00:12:55,440
basically when we applied uh upx minus d

347
00:12:55,440 --> 00:12:57,839
in order to see if it's a problem with l

348
00:12:57,839 --> 00:12:58,880
info or

349
00:12:58,880 --> 00:13:02,639
p info file upex suddenly told us oh

350
00:13:02,639 --> 00:13:04,399
i have a new problem now the problem is

351
00:13:04,399 --> 00:13:06,959
with b infrastructure which is very

352
00:13:06,959 --> 00:13:08,480
uncommon

353
00:13:08,480 --> 00:13:10,800
b info structure it's placed before each

354
00:13:10,800 --> 00:13:12,560
compress blocked and

355
00:13:12,560 --> 00:13:13,760
similar to our directions can place

356
00:13:13,760 --> 00:13:15,120
additional information for unpacking

357
00:13:15,120 --> 00:13:17,519
code how to handle it in this particular

358
00:13:17,519 --> 00:13:19,519
case it contains information about

359
00:13:19,519 --> 00:13:22,160
unpacked size the algorithms

360
00:13:22,160 --> 00:13:24,880
which was used for compression and

361
00:13:24,880 --> 00:13:26,560
diffuse parameters

362
00:13:26,560 --> 00:13:28,560
parameters are generally used to achieve

363
00:13:28,560 --> 00:13:30,399
a particular balance between performance

364
00:13:30,399 --> 00:13:32,839
and the size of the result

365
00:13:32,839 --> 00:13:35,120
payload we took a look at the

366
00:13:35,120 --> 00:13:36,959
infrastructure and there was nothing

367
00:13:36,959 --> 00:13:38,959
obvious it wasn't just

368
00:13:38,959 --> 00:13:42,240
nullified or modified in some

369
00:13:42,240 --> 00:13:45,519
clear way so

370
00:13:45,519 --> 00:13:47,600
first theory that we had is that the

371
00:13:47,600 --> 00:13:49,279
difference between compressed size and

372
00:13:49,279 --> 00:13:52,240
uncompressed size is something that

373
00:13:52,240 --> 00:13:53,920
interferes with the unpacking process

374
00:13:53,920 --> 00:13:58,079
and prevents us from easily unpacking

375
00:13:58,079 --> 00:14:00,480
we checked the values were coherent so

376
00:14:00,480 --> 00:14:02,000
nothing

377
00:14:02,000 --> 00:14:02,880
clear

378
00:14:02,880 --> 00:14:04,480
in this case

379
00:14:04,480 --> 00:14:06,240
so we moved on

380
00:14:06,240 --> 00:14:08,480
another challenge was the checksum

381
00:14:08,480 --> 00:14:10,079
so

382
00:14:10,079 --> 00:14:12,480
checksum obviously is being used to

383
00:14:12,480 --> 00:14:13,600
prevent

384
00:14:13,600 --> 00:14:17,680
very obvious small accidental changes in

385
00:14:17,680 --> 00:14:19,680
the code or data

386
00:14:19,680 --> 00:14:20,560
which

387
00:14:20,560 --> 00:14:21,600
would be

388
00:14:21,600 --> 00:14:23,120
noticed with a high probability the

389
00:14:23,120 --> 00:14:24,560
smaller the checksum high probability of

390
00:14:24,560 --> 00:14:27,120
collision so it may not necessarily

391
00:14:27,120 --> 00:14:29,279
be 100

392
00:14:29,279 --> 00:14:32,160
bulletproof but in many cases it works

393
00:14:32,160 --> 00:14:34,639
and in our case the algorithm was there

394
00:14:34,639 --> 00:14:37,360
it's open source so we could calculate

395
00:14:37,360 --> 00:14:39,120
it and check if it's valid or not but it

396
00:14:39,120 --> 00:14:40,800
will require additional work so we

397
00:14:40,800 --> 00:14:42,399
temporarily stop following this

398
00:14:42,399 --> 00:14:45,120
direction and decided to explore

399
00:14:45,120 --> 00:14:46,560
other ways how

400
00:14:46,560 --> 00:14:48,240
this can be

401
00:14:48,240 --> 00:14:50,160
approached what we decided to do we

402
00:14:50,160 --> 00:14:53,360
decided to take a look at what

403
00:14:53,360 --> 00:14:54,959
parameters were used to generate this

404
00:14:54,959 --> 00:14:56,800
particular sample

405
00:14:56,800 --> 00:15:00,000
try to simulate them and generate simple

406
00:15:00,000 --> 00:15:01,600
as much simple as

407
00:15:01,600 --> 00:15:03,279
possible but

408
00:15:03,279 --> 00:15:06,480
which will follow exactly the same

409
00:15:06,480 --> 00:15:08,560
kind of logic it will follow the same

410
00:15:08,560 --> 00:15:10,959
structure and compare the results

411
00:15:10,959 --> 00:15:13,040
sample which

412
00:15:13,040 --> 00:15:15,279
we're trying to unpack and uh the new

413
00:15:15,279 --> 00:15:18,079
one upex provides a kind of common line

414
00:15:18,079 --> 00:15:19,600
arguments that

415
00:15:19,600 --> 00:15:21,120
allowed us to

416
00:15:21,120 --> 00:15:21,920
see

417
00:15:21,920 --> 00:15:25,120
with a more or less

418
00:15:25,120 --> 00:15:27,440
higher kind of uh

419
00:15:27,440 --> 00:15:29,440
accuracy

420
00:15:29,440 --> 00:15:31,680
what were the arguments used to create

421
00:15:31,680 --> 00:15:35,120
the packed sample and we generated the

422
00:15:35,120 --> 00:15:37,199
similar one compared them we neatly

423
00:15:37,199 --> 00:15:41,120
spotted something which uh we didn't see

424
00:15:41,120 --> 00:15:43,920
very often before the version of upx

425
00:15:43,920 --> 00:15:46,519
uh the latest version of epx has been

426
00:15:46,519 --> 00:15:49,440
3.96 for more than two years now this is

427
00:15:49,440 --> 00:15:51,040
the latest production build all the

428
00:15:51,040 --> 00:15:54,079
researchers in the world okay 99 percent

429
00:15:54,079 --> 00:15:55,519
of researchers in the world are using

430
00:15:55,519 --> 00:15:56,959
the latest

431
00:15:56,959 --> 00:15:58,720
build because it's backward compatible

432
00:15:58,720 --> 00:16:00,560
everything that was packed with all

433
00:16:00,560 --> 00:16:02,320
previous versions of upx could be

434
00:16:02,320 --> 00:16:04,160
unpacked with the latest one

435
00:16:04,160 --> 00:16:06,240
however for this sample it wasn't the

436
00:16:06,240 --> 00:16:09,120
case so as you see here on the

437
00:16:09,120 --> 00:16:11,759
screenshot this sample was packed with a

438
00:16:11,759 --> 00:16:13,600
version upx

439
00:16:13,600 --> 00:16:15,839
of 4.0

440
00:16:15,839 --> 00:16:17,680
which is still under development it's

441
00:16:17,680 --> 00:16:19,519
not available in the

442
00:16:19,519 --> 00:16:21,600
release it's unstable when i tried to

443
00:16:21,600 --> 00:16:23,040
use it one year ago for example it

444
00:16:23,040 --> 00:16:24,480
failed to

445
00:16:24,480 --> 00:16:26,480
produce a valid binary even though it

446
00:16:26,480 --> 00:16:28,560
told me it's perfectly fine so it's

447
00:16:28,560 --> 00:16:29,519
still in

448
00:16:29,519 --> 00:16:31,519
early stages of development and

449
00:16:31,519 --> 00:16:33,839
apparently for attackers it worked so

450
00:16:33,839 --> 00:16:34,839
they took

451
00:16:34,839 --> 00:16:36,480
their

452
00:16:36,480 --> 00:16:37,519
test

453
00:16:37,519 --> 00:16:39,279
build which is not ready

454
00:16:39,279 --> 00:16:42,560
for production they used it to protect

455
00:16:42,560 --> 00:16:45,279
their brainchild and

456
00:16:45,279 --> 00:16:48,079
likely to them not for us it remained

457
00:16:48,079 --> 00:16:52,320
executable so and in this case once we

458
00:16:52,320 --> 00:16:55,360
figure out the logic we explored the

459
00:16:55,360 --> 00:16:57,839
kind of situation was going on and

460
00:16:57,839 --> 00:16:59,600
actually the problem was again with

461
00:16:59,600 --> 00:17:01,199
well-known

462
00:17:01,199 --> 00:17:03,839
l infrastructure so after fixing their

463
00:17:03,839 --> 00:17:06,240
existing magic which we

464
00:17:06,240 --> 00:17:07,679
knew before

465
00:17:07,679 --> 00:17:09,119
everything worked perfectly and the

466
00:17:09,119 --> 00:17:11,520
sample was unpacked

467
00:17:11,520 --> 00:17:13,599
which led us to a

468
00:17:13,599 --> 00:17:16,719
new kind of

469
00:17:16,880 --> 00:17:19,439
a new kind of area

470
00:17:19,439 --> 00:17:20,799
for many people

471
00:17:20,799 --> 00:17:24,640
how to manually unpack ultimate wear

472
00:17:24,640 --> 00:17:26,640
doing such research is fun

473
00:17:26,640 --> 00:17:27,679
if you have

474
00:17:27,679 --> 00:17:29,520
plenty of time which we might not always

475
00:17:29,520 --> 00:17:32,080
have some new threads hit the news we

476
00:17:32,080 --> 00:17:34,640
need the results uh now preferably

477
00:17:34,640 --> 00:17:37,440
yesterday so we need to unpack sample

478
00:17:37,440 --> 00:17:39,600
quickly and get answers what it does

479
00:17:39,600 --> 00:17:41,919
what are the capabilities uh

480
00:17:41,919 --> 00:17:44,080
what will be the impact how to remediate

481
00:17:44,080 --> 00:17:47,120
it who was behind the attack and so on

482
00:17:47,120 --> 00:17:48,320
and so forth

483
00:17:48,320 --> 00:17:50,480
and uh regardless of

484
00:17:50,480 --> 00:17:53,360
what packers uh iot malware developers

485
00:17:53,360 --> 00:17:55,120
use whether it's upx whether it's

486
00:17:55,120 --> 00:17:56,559
something custom well it will be

487
00:17:56,559 --> 00:17:58,640
something that will appear in the future

488
00:17:58,640 --> 00:18:00,480
tomorrow one year

489
00:18:00,480 --> 00:18:01,520
later

490
00:18:01,520 --> 00:18:02,799
it's always possible to unpack it in the

491
00:18:02,799 --> 00:18:05,120
debugger just because

492
00:18:05,120 --> 00:18:06,000
the

493
00:18:06,000 --> 00:18:07,280
unpacking

494
00:18:07,280 --> 00:18:08,640
should happen before the action

495
00:18:08,640 --> 00:18:11,360
functionality will be executed

496
00:18:11,360 --> 00:18:14,480
basically in most cases

497
00:18:14,480 --> 00:18:15,679
it doesn't matter

498
00:18:15,679 --> 00:18:17,280
what you unpack whether it's windows

499
00:18:17,280 --> 00:18:19,039
samples mzp

500
00:18:19,039 --> 00:18:22,080
file structure or linux ones

501
00:18:22,080 --> 00:18:24,160
exactly the same steps

502
00:18:24,160 --> 00:18:26,840
should be followed by the unpacking code

503
00:18:26,840 --> 00:18:30,160
and this is something that we can

504
00:18:30,160 --> 00:18:32,799
exploit our goal is to stop at the

505
00:18:32,799 --> 00:18:35,200
moment when the sample is already

506
00:18:35,200 --> 00:18:37,600
unpacked but hasn't been executed

507
00:18:37,600 --> 00:18:40,400
why because obviously at this moment all

508
00:18:40,400 --> 00:18:42,160
code all data is already present in

509
00:18:42,160 --> 00:18:44,240
memory but it hasn't been modified

510
00:18:44,240 --> 00:18:46,960
during the actual operation so

511
00:18:46,960 --> 00:18:49,440
this is a perfect spot to

512
00:18:49,440 --> 00:18:50,799
dump it on the disk and continue the

513
00:18:50,799 --> 00:18:51,840
analysis

514
00:18:51,840 --> 00:18:53,760
reverse engineers call this spot the

515
00:18:53,760 --> 00:18:55,280
first instruction which is going to be

516
00:18:55,280 --> 00:18:57,600
executed is original entry point so

517
00:18:57,600 --> 00:18:59,280
entry point is something where the

518
00:18:59,280 --> 00:19:01,200
execution generally starts

519
00:19:01,200 --> 00:19:03,200
in absolute majority of cases

520
00:19:03,200 --> 00:19:04,880
with certain exceptions and this is

521
00:19:04,880 --> 00:19:06,640
original entry point the entry point of

522
00:19:06,640 --> 00:19:08,840
the original sample before it was

523
00:19:08,840 --> 00:19:12,000
packed so

524
00:19:12,000 --> 00:19:15,120
technique number one

525
00:19:15,120 --> 00:19:17,039
all these techniques are based on the

526
00:19:17,039 --> 00:19:19,360
workflow of unpacking code which it has

527
00:19:19,360 --> 00:19:21,840
to follow in order to unpack the sample

528
00:19:21,840 --> 00:19:23,280
and again this is something that we are

529
00:19:23,280 --> 00:19:24,720
going to exploit

530
00:19:24,720 --> 00:19:27,840
first step that it has to do is that

531
00:19:27,840 --> 00:19:30,080
packed code and data should be read in

532
00:19:30,080 --> 00:19:31,840
order to be unpacked so the sample

533
00:19:31,840 --> 00:19:34,799
should read its own body to

534
00:19:34,799 --> 00:19:37,600
read the compressed or encrypted

535
00:19:37,600 --> 00:19:40,240
or both code and data before it can be

536
00:19:40,240 --> 00:19:41,760
processed and

537
00:19:41,760 --> 00:19:44,000
this packed code and data is

538
00:19:44,000 --> 00:19:46,720
visible it's visible with naked eye with

539
00:19:46,720 --> 00:19:48,480
proper tools i've been used so here for

540
00:19:48,480 --> 00:19:50,840
example in the screenshot you can

541
00:19:50,840 --> 00:19:53,440
see representation of

542
00:19:53,440 --> 00:19:55,360
packed code and data in

543
00:19:55,360 --> 00:19:57,280
my favorite tool it's called hue

544
00:19:57,280 --> 00:19:59,520
hacker's view so here you can

545
00:19:59,520 --> 00:20:02,159
immediately spot the high entropy what

546
00:20:02,159 --> 00:20:04,480
does it mean generally in

547
00:20:04,480 --> 00:20:07,919
code and data zero is the most prevalent

548
00:20:07,919 --> 00:20:10,960
symbol same as in various

549
00:20:10,960 --> 00:20:13,200
human alphabets like in english for

550
00:20:13,200 --> 00:20:14,960
example certain letters are more

551
00:20:14,960 --> 00:20:17,440
prevalent than others yeah

552
00:20:17,440 --> 00:20:18,799
same applies to

553
00:20:18,799 --> 00:20:21,440
binary code and data in this case zero

554
00:20:21,440 --> 00:20:23,679
byte is the most obvious one the most

555
00:20:23,679 --> 00:20:25,360
commonly used and

556
00:20:25,360 --> 00:20:27,679
this particular tool is representing it

557
00:20:27,679 --> 00:20:30,240
with a particular symbol which is a

558
00:20:30,240 --> 00:20:32,400
lack of anything it's a dark spot here

559
00:20:32,400 --> 00:20:35,360
you can see the number of dark spots is

560
00:20:35,360 --> 00:20:38,480
very little which means that the

561
00:20:38,480 --> 00:20:42,000
randomness the entropy level of the this

562
00:20:42,000 --> 00:20:45,360
particular area is uh very high which is

563
00:20:45,360 --> 00:20:49,039
a perfect kind of indicator that this

564
00:20:49,039 --> 00:20:51,360
coded data are packed

565
00:20:51,360 --> 00:20:53,039
what we can do after this we can just

566
00:20:53,039 --> 00:20:55,200
follow cross references we can search

567
00:20:55,200 --> 00:20:57,679
for all places within the code where

568
00:20:57,679 --> 00:20:59,760
this block has been accessed and follow

569
00:20:59,760 --> 00:21:01,280
them to find the unpacking routine as

570
00:21:01,280 --> 00:21:03,200
long as we found it we just need to go

571
00:21:03,200 --> 00:21:04,799
to the end of it and the sample is

572
00:21:04,799 --> 00:21:06,320
unpacked

573
00:21:06,320 --> 00:21:08,400
second step

574
00:21:08,400 --> 00:21:10,159
big memory block should be allocated for

575
00:21:10,159 --> 00:21:12,799
the result once this code and data are

576
00:21:12,799 --> 00:21:14,159
unpacked this should be placed somewhere

577
00:21:14,159 --> 00:21:16,159
there should be space

578
00:21:16,159 --> 00:21:18,640
for it prepared and

579
00:21:18,640 --> 00:21:20,240
memory allocation is

580
00:21:20,240 --> 00:21:21,919
one of the most common

581
00:21:21,919 --> 00:21:24,000
ways how additional memory can be

582
00:21:24,000 --> 00:21:25,120
dynamically

583
00:21:25,120 --> 00:21:29,280
achieved on a windows platform usually

584
00:21:29,280 --> 00:21:30,720
virtual analog

585
00:21:30,720 --> 00:21:33,360
virtual lock x and so on

586
00:21:33,360 --> 00:21:35,679
are used for this purposes apart from

587
00:21:35,679 --> 00:21:38,480
heap on linux systems

588
00:21:38,480 --> 00:21:40,720
cisco mm map

589
00:21:40,720 --> 00:21:43,039
is used to allocate memory

590
00:21:43,039 --> 00:21:44,480
there are other ways how it can be

591
00:21:44,480 --> 00:21:46,320
achieved for example

592
00:21:46,320 --> 00:21:48,880
with a upx when we talk about qpx on

593
00:21:48,880 --> 00:21:51,039
windows there is different strategy they

594
00:21:51,039 --> 00:21:51,760
are

595
00:21:51,760 --> 00:21:53,600
creating an empty section which is not

596
00:21:53,600 --> 00:21:55,520
physically present on a disk it's only

597
00:21:55,520 --> 00:21:57,840
it will be only present in memory but it

598
00:21:57,840 --> 00:21:59,600
will have no virtual physical

599
00:21:59,600 --> 00:22:02,400
representation and later this area in

600
00:22:02,400 --> 00:22:04,240
memory will be populated with code and

601
00:22:04,240 --> 00:22:06,000
data the result is the same as long as

602
00:22:06,000 --> 00:22:08,400
we found this big block we can put a

603
00:22:08,400 --> 00:22:09,840
breakpoint when something will be

604
00:22:09,840 --> 00:22:11,280
written there

605
00:22:11,280 --> 00:22:13,520
and as long as the data unpacked when

606
00:22:13,520 --> 00:22:15,280
the data starts being written we just

607
00:22:15,280 --> 00:22:17,120
need to wait until it finishes we will

608
00:22:17,120 --> 00:22:18,080
get

609
00:22:18,080 --> 00:22:20,640
both of them available

610
00:22:20,640 --> 00:22:22,880
third step result of the unpacking code

611
00:22:22,880 --> 00:22:25,120
should be written there and here where

612
00:22:25,120 --> 00:22:27,120
different types of breakpoints become

613
00:22:27,120 --> 00:22:28,000
handy

614
00:22:28,000 --> 00:22:30,159
so

615
00:22:31,039 --> 00:22:33,280
to give

616
00:22:33,280 --> 00:22:35,520
you some idea about what

617
00:22:35,520 --> 00:22:38,480
breakpoints is breakpoint is a term used

618
00:22:38,480 --> 00:22:41,200
in the debugging where we put a marker

619
00:22:41,200 --> 00:22:43,280
and we want to stop at this particular

620
00:22:43,280 --> 00:22:44,159
place

621
00:22:44,159 --> 00:22:46,400
in the code in most cases

622
00:22:46,400 --> 00:22:47,760
whether this instruction has been

623
00:22:47,760 --> 00:22:50,000
executed it's the most common case it's

624
00:22:50,000 --> 00:22:52,000
they're called software breakpoints

625
00:22:52,000 --> 00:22:55,520
or some data is being modified usually

626
00:22:55,520 --> 00:22:57,360
for this purpose memory breakpoints are

627
00:22:57,360 --> 00:22:58,799
being used and there is a separate

628
00:22:58,799 --> 00:23:00,400
category of breakpoints called hardware

629
00:23:00,400 --> 00:23:02,159
breakpoints they are implemented

630
00:23:02,159 --> 00:23:04,720
differently behind kind of

631
00:23:04,720 --> 00:23:06,480
behind the scenes they

632
00:23:06,480 --> 00:23:07,360
use

633
00:23:07,360 --> 00:23:10,080
particular registers of the cpu but the

634
00:23:10,080 --> 00:23:11,360
result will be the same they can be used

635
00:23:11,360 --> 00:23:13,440
to stop either when a particular

636
00:23:13,440 --> 00:23:15,039
instruction is being executed or when

637
00:23:15,039 --> 00:23:17,520
particular data is being accessed or

638
00:23:17,520 --> 00:23:20,480
modified somehow and again

639
00:23:20,480 --> 00:23:22,320
same story as long as we know that in

640
00:23:22,320 --> 00:23:23,840
this particular place something will be

641
00:23:23,840 --> 00:23:25,600
written in our case unpacked code and

642
00:23:25,600 --> 00:23:27,840
data we can put these types of

643
00:23:27,840 --> 00:23:30,400
breakpoints intercept the moment when it

644
00:23:30,400 --> 00:23:32,960
has been it starts to be unpacked

645
00:23:32,960 --> 00:23:35,120
go to the end of this process

646
00:23:35,120 --> 00:23:37,440
and we are fully set

647
00:23:37,440 --> 00:23:38,720
one more

648
00:23:38,720 --> 00:23:40,799
step execution

649
00:23:40,799 --> 00:23:42,240
protection flux

650
00:23:42,240 --> 00:23:44,320
so um

651
00:23:44,320 --> 00:23:45,279
memory

652
00:23:45,279 --> 00:23:46,880
when i talk about memory i'm talking

653
00:23:46,880 --> 00:23:47,919
about

654
00:23:47,919 --> 00:23:49,600
render max memory ram

655
00:23:49,600 --> 00:23:51,760
so

656
00:23:51,760 --> 00:23:53,279
right now we

657
00:23:53,279 --> 00:23:56,000
say we went away from using segments in

658
00:23:56,000 --> 00:23:58,559
memory in most cases for x86 for example

659
00:23:58,559 --> 00:24:00,799
the memory is flat and we have

660
00:24:00,799 --> 00:24:02,559
particular memory ranges in order to

661
00:24:02,559 --> 00:24:07,440
store code and data resources everything

662
00:24:07,440 --> 00:24:08,960
to differentiate between them because

663
00:24:08,960 --> 00:24:10,799
for cpu there is no difference between

664
00:24:10,799 --> 00:24:14,000
code and data it's just number of bytes

665
00:24:14,000 --> 00:24:16,480
the bytes are the same from 0 0 to

666
00:24:16,480 --> 00:24:20,559
255 or ff in hexadecimal

667
00:24:20,559 --> 00:24:21,840
to add some additional layer of

668
00:24:21,840 --> 00:24:24,480
protection the memory

669
00:24:24,480 --> 00:24:26,640
protection slugs have been invented what

670
00:24:26,640 --> 00:24:28,320
it is it's a particular marker which

671
00:24:28,320 --> 00:24:29,120
says

672
00:24:29,120 --> 00:24:31,360
whether this particular memory range is

673
00:24:31,360 --> 00:24:34,080
readable executable or writable or some

674
00:24:34,080 --> 00:24:36,159
combination of them

675
00:24:36,159 --> 00:24:36,960
and

676
00:24:36,960 --> 00:24:39,360
unpacker needs to

677
00:24:39,360 --> 00:24:41,360
change them occasionally for example

678
00:24:41,360 --> 00:24:44,000
when the code is unpacked to a newly

679
00:24:44,000 --> 00:24:46,000
allocated memory it needs to be marked

680
00:24:46,000 --> 00:24:48,000
as executable otherwise

681
00:24:48,000 --> 00:24:50,559
in idea in the ideal world in most cases

682
00:24:50,559 --> 00:24:52,960
the system is supposed to refuse to do

683
00:24:52,960 --> 00:24:54,720
it it hasn't been enforced for example

684
00:24:54,720 --> 00:24:56,880
in windows for many years

685
00:24:56,880 --> 00:24:59,200
only later they introduced dep that

686
00:24:59,200 --> 00:25:02,480
execution protection or prevention

687
00:25:02,480 --> 00:25:04,559
to protect only a particular kind of

688
00:25:04,559 --> 00:25:06,080
process but for backward compatibility

689
00:25:06,080 --> 00:25:08,080
it couldn't be done straight away and

690
00:25:08,080 --> 00:25:10,000
here the logic is exactly the same when

691
00:25:10,000 --> 00:25:11,360
monitoring the syscall which is

692
00:25:11,360 --> 00:25:13,279
responsible for changing memory flux and

693
00:25:13,279 --> 00:25:14,960
protect

694
00:25:14,960 --> 00:25:17,440
and as long as it has been executed we

695
00:25:17,440 --> 00:25:18,960
can check what exactly has changed

696
00:25:18,960 --> 00:25:20,720
whether some particular memory range

697
00:25:20,720 --> 00:25:22,480
became executable or whether the

698
00:25:22,480 --> 00:25:23,679
modified

699
00:25:23,679 --> 00:25:28,159
elf header was became non-writable again

700
00:25:28,159 --> 00:25:30,159
all these steps are something

701
00:25:30,159 --> 00:25:32,240
worse monitoring in order to intercept

702
00:25:32,240 --> 00:25:34,080
the moment when code and data are

703
00:25:34,080 --> 00:25:36,159
already unpacked to stop at the entry

704
00:25:36,159 --> 00:25:39,440
point finally um the control should be

705
00:25:39,440 --> 00:25:42,080
transferred so once unpacking is done

706
00:25:42,080 --> 00:25:45,360
the cpu should start executing their

707
00:25:45,360 --> 00:25:47,360
newly fresh unpacked malware from the

708
00:25:47,360 --> 00:25:50,000
original entry point and

709
00:25:50,000 --> 00:25:51,760
usually

710
00:25:51,760 --> 00:25:53,120
it's not

711
00:25:53,120 --> 00:25:55,279
very easy for unpacker to know exactly

712
00:25:55,279 --> 00:25:57,600
where it will end up so in many cases

713
00:25:57,600 --> 00:25:59,600
there will be particular instructions

714
00:25:59,600 --> 00:26:01,520
which provide certain flexibility for

715
00:26:01,520 --> 00:26:03,919
example the final address where the

716
00:26:03,919 --> 00:26:05,279
code should go

717
00:26:05,279 --> 00:26:08,159
will be stored not in the hardcoded form

718
00:26:08,159 --> 00:26:10,720
but in a register the register is a

719
00:26:10,720 --> 00:26:13,360
particular special unit of cpu which can

720
00:26:13,360 --> 00:26:14,240
store

721
00:26:14,240 --> 00:26:16,159
various types of information depending

722
00:26:16,159 --> 00:26:18,960
on the business usually it's either 32

723
00:26:18,960 --> 00:26:21,440
bit or 64 bit on modern

724
00:26:21,440 --> 00:26:24,000
cpus and here as you can see in the last

725
00:26:24,000 --> 00:26:26,080
instruction is jump to a particular

726
00:26:26,080 --> 00:26:28,480
address which is not known the address

727
00:26:28,480 --> 00:26:30,880
is encoded using a register and this is

728
00:26:30,880 --> 00:26:32,960
a strong indicator that

729
00:26:32,960 --> 00:26:35,679
this may be a transient control to the

730
00:26:35,679 --> 00:26:37,360
original entry point there will be very

731
00:26:37,360 --> 00:26:39,679
few of them in the unpacked code and

732
00:26:39,679 --> 00:26:42,000
finding all of them

733
00:26:42,000 --> 00:26:44,240
in most cases guarantees the

734
00:26:44,240 --> 00:26:45,679
moment when the code and data are

735
00:26:45,679 --> 00:26:47,200
unpacked

736
00:26:47,200 --> 00:26:49,600
and finally bonus tip for upx in

737
00:26:49,600 --> 00:26:51,279
particular

738
00:26:51,279 --> 00:26:52,720
there is a syscall

739
00:26:52,720 --> 00:26:53,600
uh

740
00:26:53,600 --> 00:26:55,600
memory and map and map which has been

741
00:26:55,600 --> 00:26:58,240
executed just a few steps before passing

742
00:26:58,240 --> 00:26:59,919
control to the original entry point

743
00:26:59,919 --> 00:27:02,640
again this is a very low hanging fruit

744
00:27:02,640 --> 00:27:05,279
which researchers can use in order to

745
00:27:05,279 --> 00:27:06,960
stop at this particular moment execute a

746
00:27:06,960 --> 00:27:08,480
few instructions and you are stopping at

747
00:27:08,480 --> 00:27:10,320
the original entry point where unpacked

748
00:27:10,320 --> 00:27:11,760
code data are available for your

749
00:27:11,760 --> 00:27:13,679
analysis to understand malware

750
00:27:13,679 --> 00:27:16,080
functionality and

751
00:27:16,080 --> 00:27:18,399
perform any type of security kind of

752
00:27:18,399 --> 00:27:20,559
activity which

753
00:27:20,559 --> 00:27:23,120
you may be interested in

754
00:27:23,120 --> 00:27:26,880
and that was basically it so thank you

755
00:27:26,880 --> 00:27:29,360
very much again

756
00:27:29,360 --> 00:27:31,279
these are some of the capabilities of

757
00:27:31,279 --> 00:27:35,039
our intelligence team which

758
00:27:35,039 --> 00:27:36,640
is one of the products that nozomi

759
00:27:36,640 --> 00:27:38,240
networks provides so if you are

760
00:27:38,240 --> 00:27:39,840
interested in getting more information

761
00:27:39,840 --> 00:27:41,760
please contact me or if you're

762
00:27:41,760 --> 00:27:43,600
interested in nozomi network products in

763
00:27:43,600 --> 00:27:45,520
general please

764
00:27:45,520 --> 00:27:48,640
join us at the cabana session today

765
00:27:48,640 --> 00:27:52,679
so thank you very much

