1
00:00:00,600 --> 00:00:02,802
(Synth music)

2
00:00:10,377 --> 00:00:13,113
(crowd applause)

3
00:00:15,315 --> 00:00:17,784
- So, this is our
general marching orders.

4
00:00:17,784 --> 00:00:20,720
We're going to talk very
briefly because of the room.

5
00:00:20,720 --> 00:00:21,988
Our building blocks...

6
00:00:21,988 --> 00:00:23,390
What are the things
we have to deal with

7
00:00:23,390 --> 00:00:24,924
that make a registry hive?

8
00:00:24,924 --> 00:00:26,726
If you've never looked at
it from like a hex level.

9
00:00:26,726 --> 00:00:28,328
And then from there
we're going to dive into

10
00:00:28,328 --> 00:00:30,964
what's in those building
blocks a little bit deeper,

11
00:00:30,964 --> 00:00:32,464
just at a high level,

12
00:00:32,465 --> 00:00:34,334
and just because of the
nature of the time frame,

13
00:00:34,334 --> 00:00:36,569
we can't get into
super low-level

14
00:00:36,569 --> 00:00:38,304
with each of the record types.

15
00:00:38,304 --> 00:00:39,606
I want to spend the
majority of the time

16
00:00:39,606 --> 00:00:41,875
getting into deleted recovery,

17
00:00:41,875 --> 00:00:43,877
because that's the most
important part out of this,

18
00:00:43,877 --> 00:00:47,580
so people that have seen
any of my stuff on the

19
00:00:47,580 --> 00:00:49,149
forensic launcher
or my blog posts,

20
00:00:49,149 --> 00:00:51,284
this is kind of how
I like to explain

21
00:00:51,284 --> 00:00:52,786
what a registry hive looks like.

22
00:00:52,786 --> 00:00:54,621
It's basically we have our file,

23
00:00:54,621 --> 00:00:56,923
and then inside that we
have of course our header

24
00:00:56,923 --> 00:01:00,293
and then hbins are buckets
that you put other things in.

25
00:01:00,293 --> 00:01:03,897
So, it's very straightforward
from a high level

26
00:01:03,897 --> 00:01:08,401
and you can see we've got
our header chunk, 40 96 bytes

27
00:01:08,401 --> 00:01:10,637
and then these hbins are
going to be different sizes

28
00:01:10,637 --> 00:01:12,906
typically 40 96 bytes as well,

29
00:01:12,906 --> 00:01:15,041
and then you have
cells, lists, and data,

30
00:01:15,041 --> 00:01:18,078
that live in there and are
related based on pointers

31
00:01:18,078 --> 00:01:21,815
to offsets, relative
offsets, to other structures.

32
00:01:23,283 --> 00:01:25,418
And so here's the important
stuff that's in the header.

33
00:01:25,418 --> 00:01:27,320
This isn't everything,
but these are the things

34
00:01:27,320 --> 00:01:28,755
that we're typically
going to look for.

35
00:01:28,755 --> 00:01:31,191
So where the signature
is, why do we want that?

36
00:01:31,191 --> 00:01:33,960
We can do file analysis to
determine if something's

37
00:01:33,960 --> 00:01:35,728
a registry hive or not.

38
00:01:35,728 --> 00:01:39,499
Last write timestamp, the
major and minor versions.

39
00:01:39,499 --> 00:01:41,768
Those will become
important if you are going

40
00:01:41,768 --> 00:01:44,170
to get into parsing
because of big data

41
00:01:44,170 --> 00:01:46,539
and some other
structures only are...

42
00:01:46,539 --> 00:01:47,907
They work differently depending

43
00:01:47,907 --> 00:01:49,741
on what version of
a hive you have.

44
00:01:49,742 --> 00:01:52,879
So if you just assume, "oh,
I'll just do it the old way

45
00:01:52,879 --> 00:01:54,347
in a new hive.", it's
not going to work,

46
00:01:54,347 --> 00:01:56,082
so you have to take into account

47
00:01:56,082 --> 00:01:58,851
the major and the minor version
numbers for some things.

48
00:01:58,852 --> 00:02:00,620
Root cell offset,
that is going to be

49
00:02:00,620 --> 00:02:02,856
basically where we
start at the top.

50
00:02:02,856 --> 00:02:06,059
So if you've ever opened
up a hive in any tool,

51
00:02:06,059 --> 00:02:09,062
the very first key,
that's our root cell,

52
00:02:09,062 --> 00:02:10,797
so it's basically
the header points us

53
00:02:10,797 --> 00:02:13,266
to where we need to
go to get started.

54
00:02:13,266 --> 00:02:15,635
The length of course,
that's going to be how long

55
00:02:15,635 --> 00:02:18,771
the hive should be, how
long the header thinks

56
00:02:18,771 --> 00:02:21,006
it is anyway, but
you cannot trust it.

57
00:02:21,007 --> 00:02:23,143
If you just always assume
that the length is valid,

58
00:02:23,143 --> 00:02:24,644
you will miss stuff.

59
00:02:24,644 --> 00:02:26,513
It's not always accurate,
so take that in mind.

60
00:02:26,513 --> 00:02:28,047
You basically just have
to run out the whole

61
00:02:28,047 --> 00:02:30,416
file and look for
your hbin headers

62
00:02:30,416 --> 00:02:32,719
to see where things
actually stop, okay?

63
00:02:32,719 --> 00:02:36,022
And then internal file
name, that can be changed,

64
00:02:36,022 --> 00:02:38,625
but typically that is
going to allow us to know

65
00:02:38,625 --> 00:02:41,461
if we have a system
hive, or an NT User hive,

66
00:02:41,461 --> 00:02:42,962
or a user class hive.

67
00:02:42,962 --> 00:02:45,498
Now a better way would be
to go look for the presence

68
00:02:45,498 --> 00:02:48,567
of keys in there just in
case the name got changed

69
00:02:48,568 --> 00:02:51,004
and if you mount a hive
it can change in Regedit

70
00:02:51,004 --> 00:02:52,471
and things like that.

71
00:02:52,472 --> 00:02:54,240
But those are all
important things.

72
00:02:54,240 --> 00:02:58,244
This is what those key fields
look like, and where they are.

73
00:02:58,244 --> 00:03:00,146
So I've got it color-coded here,

74
00:03:00,146 --> 00:03:02,415
and throughout this
presentation there will be

75
00:03:02,415 --> 00:03:04,384
a lot of references
to other resources

76
00:03:04,384 --> 00:03:07,186
throughout the slide deck
and you can really dive down

77
00:03:07,187 --> 00:03:09,989
into any of these beginning
parts here as well.

78
00:03:09,989 --> 00:03:12,158
So there's just where our
important things are here

79
00:03:12,158 --> 00:03:15,561
and color-coded so we
can see our file name

80
00:03:15,562 --> 00:03:16,996
and all the different pieces.

81
00:03:18,398 --> 00:03:20,533
This is what registry
explorer takes the header,

82
00:03:20,533 --> 00:03:23,570
this thing, and
pulls everything out

83
00:03:23,570 --> 00:03:26,172
so that it's actually in
a much more usable format,

84
00:03:26,172 --> 00:03:28,908
so we have our sequence
numbers, we have our check sums,

85
00:03:28,908 --> 00:03:31,143
you can see the version,
our embedded file name,

86
00:03:31,144 --> 00:03:33,479
all of that gets extracted
out in a nice format

87
00:03:33,479 --> 00:03:35,882
so that we can make sense
of it without having to

88
00:03:35,882 --> 00:03:39,018
do a bunch of
manual, conversion.

89
00:03:39,018 --> 00:03:40,920
As far as how we
want to parse a hive,

90
00:03:40,920 --> 00:03:43,655
for people that are
interested in this.

91
00:03:43,656 --> 00:03:45,225
There's some
programmers in here,

92
00:03:45,225 --> 00:03:48,828
I know Willy's tool is going
to take a similar approach,

93
00:03:48,828 --> 00:03:51,264
but anything like this,
this is just the general way

94
00:03:51,264 --> 00:03:52,465
that you would
want to look at it.

95
00:03:52,465 --> 00:03:53,866
At least the way
when I designed it,

96
00:03:53,866 --> 00:03:55,368
I wanted to do it this way.

97
00:03:55,368 --> 00:03:57,269
We open it up, we find
the header, is it a hive?

98
00:03:57,270 --> 00:03:58,771
Yes.
We know where the root

99
00:03:58,771 --> 00:04:02,041
cell is now, then we
start looking for hbins.

100
00:04:02,041 --> 00:04:05,311
Those are our buckets, and
we're only going to find records

101
00:04:05,311 --> 00:04:08,348
that we want to try
and use in those hbins,

102
00:04:08,348 --> 00:04:12,085
and so once we find an
hbin, now we can start...

103
00:04:12,085 --> 00:04:13,920
We can get the length,
and then we can start

104
00:04:13,920 --> 00:04:16,421
pulling these
different records out,

105
00:04:16,422 --> 00:04:18,057
and then we do stuff, right?

106
00:04:18,057 --> 00:04:19,592
The magic, that's where
the magic happens.

107
00:04:19,591 --> 00:04:23,329
As far as building
our tree, our key,

108
00:04:23,329 --> 00:04:24,931
relationships, keys and sub-keys

109
00:04:24,931 --> 00:04:28,401
and then sticking the values
inside each of the keys,

110
00:04:28,401 --> 00:04:30,303
and then once we've
finished with that hbin

111
00:04:30,303 --> 00:04:32,905
we just go back up and do
it until we run out of 'em.

112
00:04:32,905 --> 00:04:34,140
So and that's it
and when you're done

113
00:04:34,140 --> 00:04:36,609
you close it and
you're good to go.

114
00:04:36,609 --> 00:04:39,111
Now one thing to note here
if you have a root cell,

115
00:04:39,112 --> 00:04:42,248
typically it'll be
hex20, that's the

116
00:04:42,248 --> 00:04:43,783
relative offsets
so you have to..

117
00:04:43,783 --> 00:04:45,385
If you're going to look at
something in a hex editor

118
00:04:45,385 --> 00:04:46,853
you have to add the
size of the header

119
00:04:46,853 --> 00:04:48,921
or everything will
not work, right?

120
00:04:48,921 --> 00:04:52,292
So you have to add 4096 bites
which is going to be this.

121
00:04:52,292 --> 00:04:54,727
So throughout you'll
hear the relative

122
00:04:54,727 --> 00:04:56,962
offset or absolute offset...

123
00:04:56,963 --> 00:04:59,732
Keep that in mind if it's
relative you have to add in the

124
00:04:59,732 --> 00:05:02,368
size of the header or things
will not line up right.

125
00:05:02,368 --> 00:05:04,270
So basically this
is a little bit

126
00:05:04,270 --> 00:05:06,572
more information about hbin.

127
00:05:06,572 --> 00:05:09,842
So we've got, our buckets
and some more size stuff,

128
00:05:09,842 --> 00:05:12,044
most of them are 40 96
but the thing to take in

129
00:05:12,045 --> 00:05:13,279
you can't just say,

130
00:05:13,279 --> 00:05:16,482
"I'm just gonna read 40
96 every single time."

131
00:05:16,482 --> 00:05:21,287
In part of the header
of an hbin is the size.

132
00:05:21,287 --> 00:05:24,890
So you take that and then
you multiply it by 40 96

133
00:05:24,891 --> 00:05:26,726
and that's the size of the hbin,

134
00:05:26,726 --> 00:05:29,228
and again if you don't do
that, if you just assume 40 96

135
00:05:29,228 --> 00:05:34,233
and you get a 8mg or an 8k hbin,

136
00:05:35,401 --> 00:05:36,669
when you jump down to
that second section

137
00:05:36,669 --> 00:05:37,904
you're not gonna find
what you're expecting,

138
00:05:37,904 --> 00:05:39,272
things are gonna
go sideways, okay?

139
00:05:39,272 --> 00:05:42,141
So offset, again that's
going to be relative.

140
00:05:42,141 --> 00:05:45,778
So the first one would be zero,
one, two, things like that,

141
00:05:45,778 --> 00:05:48,014
and then our records
are gonna start

142
00:05:48,014 --> 00:05:49,716
at that relative offset.

143
00:05:49,716 --> 00:05:51,718
Okay, again, we
have to add that...

144
00:05:52,885 --> 00:05:54,320
Header size or things
aren't gonna work right.

145
00:05:54,320 --> 00:05:56,089
So this is what an
hbin would look like.

146
00:05:56,089 --> 00:06:00,626
So of the four properties
that we just talked about,

147
00:06:00,626 --> 00:06:02,328
you can see we've
got out signature,

148
00:06:02,328 --> 00:06:04,597
our relative offset,
our size and then

149
00:06:04,597 --> 00:06:07,133
where actual data starts, okay?

150
00:06:07,133 --> 00:06:08,967
And on that particular
one it's and NK,

151
00:06:08,968 --> 00:06:10,903
that would be our root, right?

152
00:06:10,903 --> 00:06:14,407
And this should look familiar
if you've seen enough hives,

153
00:06:14,407 --> 00:06:17,176
that's pretty common
for certain things.

154
00:06:17,176 --> 00:06:19,979
Inside our hbins now we can
start actually pulling things

155
00:06:19,979 --> 00:06:22,681
out that make up our
hives, the things

156
00:06:22,682 --> 00:06:24,150
that we're actually
interested in.

157
00:06:24,150 --> 00:06:27,387
So we've got our NKs,
which are our keys,

158
00:06:27,387 --> 00:06:31,257
VKs, values and then SK which
is our security key stuff.

159
00:06:31,257 --> 00:06:34,260
Okay, general concepts.

160
00:06:34,260 --> 00:06:36,896
In use records have a negative
size, so when you're going

161
00:06:36,896 --> 00:06:40,099
through it and you read
the front part of a record

162
00:06:40,099 --> 00:06:43,202
and you convert it
a sign imager, it's
going to be negative

163
00:06:43,202 --> 00:06:45,638
if it's in use, which
is a bit strange, right?

164
00:06:45,638 --> 00:06:48,573
Why not do it the other way?
So when a record gets deleted

165
00:06:48,574 --> 00:06:52,078
or freed in the registry, the
size just becomes positive.

166
00:06:52,078 --> 00:06:55,580
So keep that in mind when
we get to the second part.

167
00:06:55,581 --> 00:06:58,584
That's how we can
identify things that are,

168
00:06:58,584 --> 00:07:00,119
not being actively used.

169
00:07:00,119 --> 00:07:03,589
Set them aside as far as
where they live and the size,

170
00:07:03,589 --> 00:07:05,758
and then go back and
start carving out

171
00:07:05,758 --> 00:07:08,361
the details that we're
interested in, 'kay?

172
00:07:08,361 --> 00:07:10,462
So you never wanna trust,
the last point there

173
00:07:10,463 --> 00:07:12,331
is really important,
you wanna never trust

174
00:07:12,331 --> 00:07:13,833
the side of free records.

175
00:07:13,833 --> 00:07:16,736
You can from the point of

176
00:07:16,736 --> 00:07:18,604
"I know that there's
this much data"

177
00:07:18,604 --> 00:07:21,741
but you don't wanna just assume
if you see an NK signature

178
00:07:21,741 --> 00:07:24,877
that that's going to be
one NK and that's it,

179
00:07:24,877 --> 00:07:27,013
and tools have run
into this problem,

180
00:07:27,013 --> 00:07:29,382
commercial tools have run
into this problem where,

181
00:07:29,382 --> 00:07:31,417
they have this big blob
of data, they see one NK

182
00:07:31,417 --> 00:07:36,255
and then they just extract
one key, and they move on,

183
00:07:36,255 --> 00:07:37,757
and things don't work.

184
00:07:37,757 --> 00:07:40,693
You have to take the padding
and you have to take the slack

185
00:07:40,693 --> 00:07:42,895
into account when you're
dealing with that.

186
00:07:42,895 --> 00:07:45,931
So NK records.
These are our keys, right?

187
00:07:45,932 --> 00:07:48,301
We have our last write
timestamp, a name,

188
00:07:48,301 --> 00:07:50,670
a subkey and a value
count and some flags,

189
00:07:50,670 --> 00:07:53,606
and the pointers that we are
going to be interested in

190
00:07:53,606 --> 00:07:57,109
is basically where
are our subkeys?

191
00:07:57,109 --> 00:08:00,378
It points to a list,
that points to other NKs.

192
00:08:00,379 --> 00:08:03,416
How many values do we have?
And then our value pointer

193
00:08:03,416 --> 00:08:05,084
would be where is
the list that points

194
00:08:05,084 --> 00:08:06,619
to the other VK structures.

195
00:08:06,619 --> 00:08:10,056
And then we have a pointer
to our security key. Okay?

196
00:08:10,056 --> 00:08:11,289
So those are the things that we

197
00:08:11,290 --> 00:08:13,192
would wanna extract
from an NK record.

198
00:08:13,192 --> 00:08:15,728
This is what an NK record would
look like if you went into

199
00:08:15,728 --> 00:08:18,197
the technical details
of registry explorer,

200
00:08:18,197 --> 00:08:20,199
and if you go in here and
you click on any of these

201
00:08:20,199 --> 00:08:23,202
properties, the bites that
correspond to that property,

202
00:08:23,202 --> 00:08:26,239
will be highlighted down here,
and you could use the tool to

203
00:08:27,640 --> 00:08:29,741
validate itself, or other
tools, or just to do research

204
00:08:29,742 --> 00:08:33,145
and get a better understanding
of what we're talking about.

205
00:08:33,145 --> 00:08:35,414
So our values.
If you're thinking of it

206
00:08:35,414 --> 00:08:37,383
like a file system
perspective, our keys are our

207
00:08:37,383 --> 00:08:40,052
directory structure, values
are files that live inside

208
00:08:40,052 --> 00:08:43,422
of a folder, so we've
got, things of interest

209
00:08:43,422 --> 00:08:46,592
and this certainly isn't
all of 'em, but our name...

210
00:08:46,592 --> 00:08:48,394
And one thing I'll ask
you guys at the end,

211
00:08:48,394 --> 00:08:50,129
what if the name length is zero?

212
00:08:50,129 --> 00:08:53,132
What happens then?
We have a type.

213
00:08:53,132 --> 00:08:57,136
D word, Reg binary,
string, multistring,

214
00:08:57,136 --> 00:08:59,639
those kind of things, a
length and then different

215
00:08:59,639 --> 00:09:02,742
flags that control
stuff about the values.

216
00:09:02,742 --> 00:09:04,776
And then again,
we have pointers.

217
00:09:04,777 --> 00:09:06,779
So if, depending on
the size of the data

218
00:09:06,779 --> 00:09:10,983
that the value represents,
it may point to another

219
00:09:10,983 --> 00:09:14,920
data structure or a list of
pointers in the case of big data

220
00:09:16,589 --> 00:09:17,957
for you to be able to go out

221
00:09:17,957 --> 00:09:20,492
and then build the
contents of that VK record.

222
00:09:22,061 --> 00:09:23,563
Okay, so this is just
what one looks like,

223
00:09:23,563 --> 00:09:27,366
now similar to how the MFT
works you can have data

224
00:09:27,366 --> 00:09:31,670
that's resident in a VK, if
it's equal to or smaller than

225
00:09:31,671 --> 00:09:34,106
four bites, because
our pointer to where

226
00:09:34,106 --> 00:09:36,375
our data would normally
live is four bites long.

227
00:09:36,375 --> 00:09:38,678
So I'll finally have a
number, a small number too.

228
00:09:38,678 --> 00:09:42,348
I could just save space
and stick that value

229
00:09:42,348 --> 00:09:44,883
right inside the
VK record itself.

230
00:09:44,884 --> 00:09:46,385
Okay, and if I have a...

231
00:09:46,385 --> 00:09:47,954
And you can just
see examples here.

232
00:09:47,954 --> 00:09:50,089
It says it's resident because
it knows what the size is,

233
00:09:50,089 --> 00:09:53,059
and here's an example where
we would have one isn't.

234
00:09:53,059 --> 00:09:54,560
So we have bites.

235
00:09:54,560 --> 00:09:57,329
It's pointing to where our
data is, and then you can see

236
00:09:57,330 --> 00:09:59,966
the length is going to match
here, and then that's how many

237
00:09:59,966 --> 00:10:01,534
bites we have and the
range down there so...

238
00:10:01,534 --> 00:10:03,869
The tool will go out and
do all that stuff for you

239
00:10:03,869 --> 00:10:07,440
to show you what it's
actually sitting at on disk.

240
00:10:07,440 --> 00:10:09,575
But you can then
validate it with those

241
00:10:09,575 --> 00:10:11,544
different properties
that are in there.

242
00:10:11,544 --> 00:10:14,413
The SK record is by far the
most complicated and dense

243
00:10:14,413 --> 00:10:16,449
so, we're not gonna spend
a ton of time on here

244
00:10:16,449 --> 00:10:18,718
but you can see on the screen
a lot of the different pieces

245
00:10:18,718 --> 00:10:21,954
that exist in there, and that
bottom link will be really

246
00:10:21,954 --> 00:10:24,656
important and it's a rather
long post if you're interested

247
00:10:24,657 --> 00:10:27,426
to really get an understanding
of how all the bits

248
00:10:27,426 --> 00:10:30,296
work as we break things down.

249
00:10:30,296 --> 00:10:31,464
This is what one
would look like.

250
00:10:31,464 --> 00:10:33,633
There's the bites at the bottom,

251
00:10:33,633 --> 00:10:36,702
and then this is the beginning
part of the property, so

252
00:10:36,702 --> 00:10:38,704
I just break down a
couple of these things.

253
00:10:38,704 --> 00:10:41,507
We have our descriptors
for the Sacls and the Dacls

254
00:10:41,507 --> 00:10:43,675
and all the different things
that would control auditing

255
00:10:43,676 --> 00:10:46,579
and who can access it.
So it just basically explains

256
00:10:46,579 --> 00:10:48,447
all of those and then
we get into things like

257
00:10:48,447 --> 00:10:52,818
how big each sub component is
and then how many ACE records

258
00:10:52,818 --> 00:10:56,822
which, that would define,
who can access it,

259
00:10:56,822 --> 00:11:00,726
and you can see, we have
our identifiers down here,

260
00:11:00,726 --> 00:11:03,129
and then the tool
also reverse back

261
00:11:03,129 --> 00:11:05,998
to the common keys, what it is.

262
00:11:05,998 --> 00:11:07,967
So you don't have to go
Google and look at MSDN,

263
00:11:07,967 --> 00:11:10,603
like what is this key?
What is this identifier?

264
00:11:10,603 --> 00:11:12,238
The security identifier.
Oh that's the built in

265
00:11:12,238 --> 00:11:13,706
administrator.
That's the this.

266
00:11:13,706 --> 00:11:15,741
And if you get one
that it doesn't know,

267
00:11:15,741 --> 00:11:17,910
it'll point you to that as well.

268
00:11:17,910 --> 00:11:19,245
The next part we
wanna talk about

269
00:11:19,245 --> 00:11:21,080
which is our glue, is lists.

270
00:11:21,080 --> 00:11:23,416
And I've mentioned lists as
far as keys pointed to keys

271
00:11:23,416 --> 00:11:27,119
or keys pointing to values.
They're all held together

272
00:11:27,119 --> 00:11:28,821
by these list structures, okay?

273
00:11:28,821 --> 00:11:32,458
And again there's a
very long post down here

274
00:11:32,458 --> 00:11:34,593
about what we wanna do
when it comes to lists.

275
00:11:34,593 --> 00:11:36,194
So I would suggest that
you go look at that

276
00:11:36,195 --> 00:11:38,264
if you're interested in
the mechanics of these

277
00:11:38,264 --> 00:11:41,801
but basically they're just
pointers to other things.

278
00:11:41,801 --> 00:11:44,603
Okay and our data, that's
kind of everything else.

279
00:11:44,603 --> 00:11:48,406
It's just a blob with a
size, and then stuff in it.

280
00:11:48,407 --> 00:11:51,210
And this is typically
where our values will live.

281
00:11:51,210 --> 00:11:53,312
The data that makes
up our values.

282
00:11:53,312 --> 00:11:55,381
We've got the normal
and I mentioned before

283
00:11:55,381 --> 00:11:59,485
the big data case if it's over
a certain size 16344 bites.

284
00:11:59,485 --> 00:12:01,954
And again, that's where
our version number

285
00:12:01,954 --> 00:12:03,488
starts to come into play.

286
00:12:03,489 --> 00:12:04,690
So you have to
treat it differently

287
00:12:04,690 --> 00:12:06,892
if it's greater
than one dot three.

288
00:12:06,892 --> 00:12:08,394
All that stuff we
just talked about,

289
00:12:08,394 --> 00:12:10,696
can get summarized
in this slide.

290
00:12:10,696 --> 00:12:13,799
So we have our root
and then we go here

291
00:12:13,799 --> 00:12:17,837
and you can see we've got our
sub-key list it's a pointer.

292
00:12:17,837 --> 00:12:20,740
We get a list, it points to NKs.

293
00:12:20,740 --> 00:12:21,974
Same thing with our values.

294
00:12:21,974 --> 00:12:23,642
So theses are all the
different types of ways

295
00:12:23,642 --> 00:12:26,445
that you can navigate
through, a hive.

296
00:12:26,445 --> 00:12:28,848
And if you get to the
NK and their sub-keys,

297
00:12:28,848 --> 00:12:30,616
you just would go
back to the beginning,

298
00:12:30,616 --> 00:12:32,151
and then walk down
again until you

299
00:12:32,151 --> 00:12:34,920
have no sub-keys or no values.

300
00:12:34,920 --> 00:12:37,990
So this is just a general
high level overview

301
00:12:37,990 --> 00:12:41,160
of all of these structures
that we just talked about.

302
00:12:41,160 --> 00:12:43,829
Okay, so the real thing I
wanted to talk about today,

303
00:12:43,829 --> 00:12:45,430
we have to have a
little bit of framework

304
00:12:45,431 --> 00:12:48,434
which is what we just talked
about, is how can we recover

305
00:12:48,434 --> 00:12:50,870
deleted keys and values
from the registry?

306
00:12:50,870 --> 00:12:52,938
And this is what we're going
to do with the remaining time.

307
00:12:52,938 --> 00:12:56,008
So basic way we wanna do is,
I talked about we look for

308
00:12:56,008 --> 00:12:58,477
those free records, the
free chunks of data,

309
00:12:58,477 --> 00:13:02,515
once we find that we wanna
look for signatures NK, VK,

310
00:13:02,515 --> 00:13:05,985
those signatures for those
two critical components,

311
00:13:05,985 --> 00:13:07,620
and then once we find
those signatures,

312
00:13:07,620 --> 00:13:09,889
we can start extracting
chunks of data,

313
00:13:09,889 --> 00:13:11,857
and then applying rules
to see if they're valid

314
00:13:11,857 --> 00:13:15,661
and then relating them back
to other keys and values.

315
00:13:15,661 --> 00:13:18,329
Okay and that's this
last point here.

316
00:13:18,330 --> 00:13:20,032
This is what a free
record would look like,

317
00:13:20,032 --> 00:13:22,434
I know it's small, but I
wanted to pick a big one

318
00:13:22,434 --> 00:13:24,804
so we had a lot of
offsets to work with.

319
00:13:24,804 --> 00:13:29,641
So here you can see you have
a size that's a positive size.

320
00:13:29,642 --> 00:13:34,180
And because of that now we
can say this entire page,

321
00:13:34,180 --> 00:13:36,214
this chunk of data, is not being

322
00:13:36,215 --> 00:13:37,683
referenced by anything else.

323
00:13:37,683 --> 00:13:41,187
So we can basically now
start walking bite by bite,

324
00:13:41,187 --> 00:13:44,557
looking for, and the way I
implemented it was I lookfor K.

325
00:13:44,557 --> 00:13:46,559
And I'm going down the list
and list and if I see a K

326
00:13:46,559 --> 00:13:49,995
I look at the bite before
it, and if it's a V or an N,

327
00:13:51,030 --> 00:13:52,731
I record that offset, okay?

328
00:13:52,731 --> 00:13:56,135
And a the end of that process,
I get a list of offsets

329
00:13:56,135 --> 00:13:58,270
that would look something
like this, okay?

330
00:13:58,270 --> 00:14:01,073
So the next thing we would
do is then go to that offset

331
00:14:01,073 --> 00:14:03,242
and you can see it's
highlighted here.

332
00:14:03,242 --> 00:14:06,978
We would have a VK record.
And we can look at the size

333
00:14:06,979 --> 00:14:09,148
and all that stuff so you
have to take where we started,

334
00:14:09,148 --> 00:14:12,718
where did we start this whole
process with the free record?

335
00:14:12,718 --> 00:14:15,654
Then we have our offset and
when we add 'em together we get

336
00:14:15,654 --> 00:14:19,124
the relative offset of
our recoverable record.

337
00:14:19,124 --> 00:14:21,193
Once we have that we
can take those bites

338
00:14:21,193 --> 00:14:23,194
'cause we know the
offset that we're at.

339
00:14:23,195 --> 00:14:24,830
We know where the
next offset is,

340
00:14:24,830 --> 00:14:26,232
where the next signature was.

341
00:14:26,232 --> 00:14:28,834
So now we have a range
that we can take,

342
00:14:28,834 --> 00:14:32,704
and then based on that,
we can recover it,

343
00:14:32,705 --> 00:14:34,273
if it meets certain
critera, right?

344
00:14:34,273 --> 00:14:36,108
We have to have at least
the minimum amount of bites

345
00:14:36,108 --> 00:14:38,544
to do certain things
with an NK or a VK

346
00:14:38,544 --> 00:14:41,814
or there's just not
enough data to recover.

347
00:14:41,814 --> 00:14:44,016
So once we do that,
this is the example

348
00:14:44,016 --> 00:14:45,784
that we have highlighted here.

349
00:14:45,784 --> 00:14:48,187
You can see this is
some of our properties.

350
00:14:48,187 --> 00:14:51,023
We can see the name.
We can see the length,

351
00:14:51,023 --> 00:14:53,392
and those things are all going
to match up to what we saw

352
00:14:53,392 --> 00:14:56,228
when we recovered things
on the previous slide;

353
00:14:56,228 --> 00:14:57,596
the range of data and all that.

354
00:14:57,596 --> 00:14:59,665
So, we would
automate that through

355
00:14:59,665 --> 00:15:01,033
all the free
records in the hive.

356
00:15:01,033 --> 00:15:03,068
Everywhere that's not in use.
We would go through

357
00:15:03,068 --> 00:15:05,371
and carve out all
these NKs and VKs

358
00:15:05,371 --> 00:15:08,807
and then to re-associate
them, we basically want to now

359
00:15:08,807 --> 00:15:10,976
look at that parent
cell in the NK record.

360
00:15:10,976 --> 00:15:14,346
There's a parent cell index.
It points to who owns

361
00:15:14,346 --> 00:15:17,149
this particular key.
So we go through

362
00:15:17,149 --> 00:15:21,287
all of our deleted, and we
can say, "is there any other

363
00:15:21,287 --> 00:15:24,723
deleted keys that
have that offset of a

364
00:15:24,723 --> 00:15:26,157
deleted key that points to it?"

365
00:15:26,158 --> 00:15:28,994
And if they do, we can associate
it to say this deleted key

366
00:15:28,994 --> 00:15:30,930
lives underneath
this deleted key,

367
00:15:30,930 --> 00:15:34,132
and then we can keep doing that
and build up an entire tree,

368
00:15:34,133 --> 00:15:36,135
until the point where
we get to the top part,

369
00:15:36,135 --> 00:15:38,537
the top of the deleted stuff,

370
00:15:38,537 --> 00:15:42,241
that would point back maybe
to a key that's active.

371
00:15:42,241 --> 00:15:43,742
Okay, we look at
the parent offset,

372
00:15:43,742 --> 00:15:46,612
we go to that parent offset.
Now we know is it in use?

373
00:15:46,612 --> 00:15:48,314
Yes or no?
And if it is,

374
00:15:48,314 --> 00:15:51,416
we know that we can
reattatch it to that parent

375
00:15:51,417 --> 00:15:54,119
and we've recovered that
particular NK record

376
00:15:54,119 --> 00:15:56,355
to where it belonged
before it was deleted.

377
00:15:56,355 --> 00:16:00,993
Okay, similarly, we would
start with our NK record

378
00:16:00,993 --> 00:16:02,661
and then go down
through our lists

379
00:16:02,661 --> 00:16:05,964
to pull all the values in, but
you have to take into account

380
00:16:05,965 --> 00:16:09,268
checking of where
those values...

381
00:16:09,268 --> 00:16:11,804
Where those things point
to, because you don't wanna

382
00:16:11,804 --> 00:16:13,872
take a list from an
NK record that says,

383
00:16:13,872 --> 00:16:16,641
"Here's where my
values are", and just

384
00:16:16,642 --> 00:16:18,477
blindly associate them
with the deleted key.

385
00:16:18,477 --> 00:16:20,646
You have to check whether
or not they're in use.

386
00:16:20,646 --> 00:16:24,717
You'll never have, it's not
valid, rather, for an NK record

387
00:16:24,717 --> 00:16:28,687
to point to an in use value.
You just wouldn't have that.

388
00:16:28,687 --> 00:16:32,758
So you have to check, of
the deleted key values,

389
00:16:32,758 --> 00:16:35,594
each of those offsets.
Are they in use or not?

390
00:16:35,594 --> 00:16:38,263
And if they're not in use,
if they're not active,

391
00:16:38,263 --> 00:16:40,232
they you can associate
that value to that key,

392
00:16:40,232 --> 00:16:42,434
and if not, throw a warning.

393
00:16:42,434 --> 00:16:44,103
This is not, "I
can't associate this

394
00:16:44,103 --> 00:16:47,072
because that offset's being
used by something else."

395
00:16:47,072 --> 00:16:49,008
Okay?
So, if you wanna get

396
00:16:49,008 --> 00:16:51,877
into the code, as to the part
that actually does this part

397
00:16:51,877 --> 00:16:55,113
it's a multi step process,
there's a reference there to

398
00:16:55,114 --> 00:16:57,282
get help on how to do
that, and then again,

399
00:16:57,282 --> 00:17:00,519
once we're all done, we're
going to have two groups,

400
00:17:00,519 --> 00:17:02,855
we have ones that we were
able to associate back

401
00:17:02,855 --> 00:17:06,992
to an active record into our
stuff that's not deleted,

402
00:17:06,992 --> 00:17:09,828
and if we...
Once we have that list

403
00:17:09,828 --> 00:17:12,431
established, anything that
falls outside of that,

404
00:17:12,431 --> 00:17:15,067
anything that doesn't
have a valid parent index,

405
00:17:16,468 --> 00:17:18,704
it's unassociated, but it's
still going to have potentially

406
00:17:18,704 --> 00:17:21,706
structure, keys and
sub-keys with values

407
00:17:21,707 --> 00:17:24,143
and things like that, there's
just not any way to relate it

408
00:17:24,143 --> 00:17:27,146
back to where it came from
because that particular offset

409
00:17:27,146 --> 00:17:28,947
has been re-used
for something else

410
00:17:28,947 --> 00:17:31,750
other than an NK record, okay?

411
00:17:31,750 --> 00:17:33,919
So you do all that really,
really fast and then you get

412
00:17:33,919 --> 00:17:37,389
all this stuff basically
out and we can use it,

413
00:17:37,389 --> 00:17:39,257
and then there's
also another one,

414
00:17:39,258 --> 00:17:42,694
would be unassociated
values, and there's nothing

415
00:17:42,694 --> 00:17:45,697
in a VK record that tells
you what key it came from.

416
00:17:45,697 --> 00:17:48,600
So unassociated values
while we have access to them

417
00:17:48,600 --> 00:17:52,471
are less than helpful because
we can't say with certainty

418
00:17:52,471 --> 00:17:53,705
where they came
from, you may find

419
00:17:53,705 --> 00:17:55,874
some interesting
string in there,

420
00:17:55,874 --> 00:17:58,410
but you wouldn't be able
to say where it came from.

421
00:17:59,878 --> 00:18:01,379
We've talked a little bit
about some of these things

422
00:18:01,380 --> 00:18:04,450
when just going through
the process here.

423
00:18:04,450 --> 00:18:07,186
You can't stop processing
after the first signature

424
00:18:07,186 --> 00:18:09,955
and this is where I mentioned,
"don't trust the size",

425
00:18:09,955 --> 00:18:13,391
because if we go through and
I look at a free chunk of data

426
00:18:13,392 --> 00:18:16,695
and I see an NK record
and it's 12000 bites long,

427
00:18:16,695 --> 00:18:19,298
I can't treat that as one NK
record or I'm going to miss

428
00:18:19,298 --> 00:18:21,366
potentially hundreds of values

429
00:18:21,366 --> 00:18:22,901
and keys that I could recover.

430
00:18:22,901 --> 00:18:25,504
Now some tools will do that
and go, "Oh, well this whole

431
00:18:25,504 --> 00:18:26,938
free structure must
only point to one thing

432
00:18:26,939 --> 00:18:29,475
and everything else
is slack or padding."

433
00:18:29,475 --> 00:18:30,775
You can't do it that
way or you're going

434
00:18:30,776 --> 00:18:32,945
to miss a significant
amount of stuff.

435
00:18:32,945 --> 00:18:36,148
And commercial tools, this
is where they've fallen over.

436
00:18:36,148 --> 00:18:39,685
They're fixed now, but that's
where the second part is.

437
00:18:39,685 --> 00:18:41,486
You have to look for signatures

438
00:18:41,487 --> 00:18:45,190
and then, follow the rules
to build these out like

439
00:18:45,190 --> 00:18:48,594
you would if it was in use,
and then contruct the ones

440
00:18:48,594 --> 00:18:50,562
that you successfully
recovered, okay?

441
00:18:50,562 --> 00:18:52,430
And then that bottom
part is the one

442
00:18:52,431 --> 00:18:54,933
I just was talking about.
You can't just assume,

443
00:18:54,933 --> 00:18:57,402
"Oh I'm always just going to
associate up reguardless."

444
00:18:57,402 --> 00:18:59,505
You have to check whether
the things that are being

445
00:18:59,505 --> 00:19:04,042
referenced in a deleted record,
point to an active record.

446
00:19:04,042 --> 00:19:06,678
There's only one valid exception
to that and that's when

447
00:19:06,678 --> 00:19:09,815
we're taking an NK key and
trying to associate it back

448
00:19:09,815 --> 00:19:11,683
to the active parent,
that's the only time

449
00:19:11,683 --> 00:19:13,085
you would violate that rule.

450
00:19:14,186 --> 00:19:17,856
Here's some other
resources, that outline

451
00:19:17,856 --> 00:19:19,758
a lot of the process
just as I went through

452
00:19:19,758 --> 00:19:22,361
and did this,
basically from scratch.

453
00:19:23,962 --> 00:19:26,798
My philosophy on how to do
it, a lot of these basics...

454
00:19:26,798 --> 00:19:29,301
My basics series on the hives
are really going to unpack

455
00:19:29,301 --> 00:19:32,571
a lot of the sub-levels
that we talked about.

456
00:19:32,571 --> 00:19:33,906
The NKs and the VKs.

457
00:19:35,807 --> 00:19:37,276
Oh, okay.

458
00:19:38,644 --> 00:19:40,112
So if you want more
information on this the...

459
00:19:40,112 --> 00:19:43,048
My primary source
when I built my tool

460
00:19:43,048 --> 00:19:46,084
and validated what
we were dealing with
was this bottom one,

461
00:19:46,084 --> 00:19:49,588
Matt's documentation, which
he seems to have figure out

462
00:19:49,588 --> 00:19:51,056
and written stuff
for every single

463
00:19:51,056 --> 00:19:53,192
conceivable artifact everywhere.

464
00:19:53,192 --> 00:19:57,129
So that was my starting point,
this second list here is

465
00:19:57,129 --> 00:20:01,699
a newer one, and it's very
good and it goes even a lot

466
00:20:01,700 --> 00:20:05,537
further than Matt's stuff
does so just another list

467
00:20:05,537 --> 00:20:07,973
of resources to dive
further into these things

468
00:20:07,973 --> 00:20:11,777
and start pulling stuff apart
and I think, right about,

469
00:20:11,777 --> 00:20:14,179
a little, what five
or 10 minutes left?

470
00:20:14,179 --> 00:20:15,147
We'll do questions?

471
00:20:16,982 --> 00:20:18,483
- [Man In Audience] Alright.

472
00:20:18,483 --> 00:20:22,120
My question is, I get a
lot of questions in class,

473
00:20:22,120 --> 00:20:23,589
specifically about
anti-forensics

474
00:20:23,589 --> 00:20:25,256
when it comes to the registry.

475
00:20:25,257 --> 00:20:27,659
Based on what you've discovered
during your research,

476
00:20:27,659 --> 00:20:30,929
with deleted records and you
know, the overall structure.

477
00:20:32,297 --> 00:20:36,101
Question one is: Are you
currently aware of any actual

478
00:20:36,101 --> 00:20:38,870
anti-forensics tool that's
useful against the registry

479
00:20:38,870 --> 00:20:43,175
and two is: With this
information you know here,

480
00:20:45,677 --> 00:20:46,812
could one be built?

481
00:20:48,247 --> 00:20:51,817
- I think there's registry
de-fragmenters, I haven't like

482
00:20:51,817 --> 00:20:53,218
actually run them
against the hive

483
00:20:53,218 --> 00:20:56,555
to see if they're basically
wiping free space.

484
00:20:56,555 --> 00:20:59,625
That would be the way
to really mess it up,

485
00:20:59,625 --> 00:21:01,793
is to go through and
look through things

486
00:21:01,793 --> 00:21:05,030
and look for those
positive size records

487
00:21:05,030 --> 00:21:06,764
and then just zero 'em out.
- [Troy] I think

488
00:21:06,765 --> 00:21:08,700
what they do is, I think
they re-write the hive.

489
00:21:08,700 --> 00:21:10,836
So they'll re-write
the hive compressed,

490
00:21:10,836 --> 00:21:12,738
- Okay.
- [Troy] Basically

491
00:21:12,738 --> 00:21:15,741
get rid of the (mumbles)
- So Troy's saying

492
00:21:15,741 --> 00:21:17,776
one technique that
the de-fragmenters
will do is basically

493
00:21:17,776 --> 00:21:20,245
go through the hive, read
all the valid stuff out

494
00:21:21,213 --> 00:21:23,849
and basically make a copy of it.

495
00:21:23,849 --> 00:21:25,650
So that would be one
technique, another one would be

496
00:21:25,651 --> 00:21:27,319
if you could open up
that hive is to just look

497
00:21:27,319 --> 00:21:29,454
for the free records, you'd
have to leave the size,

498
00:21:29,454 --> 00:21:32,424
when windows tries to
look for the free space,

499
00:21:32,424 --> 00:21:34,960
it wouldn't know what to do.

500
00:21:34,960 --> 00:21:36,295
So if you just
left the size alone

501
00:21:36,295 --> 00:21:38,297
and zeroed out all the
bites of that length.

502
00:21:38,297 --> 00:21:39,965
I'm not aware of anything
that's doing that,

503
00:21:39,965 --> 00:21:42,934
it would not be terribly
difficult to write,

504
00:21:42,934 --> 00:21:44,870
you just would need to be
able to open a locked file,

505
00:21:44,870 --> 00:21:47,773
but that's not,
difficult to implement.

506
00:21:47,773 --> 00:21:51,376
But I'm not aware of any tool
out there doing it write now.

507
00:21:51,376 --> 00:21:54,613
The other thing that makes
it easier for that technique

508
00:21:54,613 --> 00:21:56,281
is there's not
gonna be any holes.

509
00:21:56,281 --> 00:21:59,818
So if we have an hbin,
you're not going to have,

510
00:21:59,818 --> 00:22:03,221
like active, active,
deleted, deleted, active.

511
00:22:03,221 --> 00:22:05,490
Windows when it
frees things, copies

512
00:22:05,490 --> 00:22:08,093
and shoves everything
to the left so to speak.

513
00:22:08,093 --> 00:22:11,196
So all of our free stuff will
be more toward the right side

514
00:22:11,196 --> 00:22:13,799
for lack of a
better illustration.

515
00:22:13,799 --> 00:22:15,434
So just go out there until you

516
00:22:15,434 --> 00:22:16,935
start seeing those free areas.

517
00:22:16,935 --> 00:22:19,870
Padding's gonna be different
of course like slack,

518
00:22:19,871 --> 00:22:21,773
but for the free stuff
it's typically going

519
00:22:21,773 --> 00:22:26,043
to be out at the end
of the structures.

520
00:22:28,647 --> 00:22:30,248
One over here and one over here.

521
00:22:32,351 --> 00:22:34,319
- [Troy] Go.
- [Audience Member] Yes.

522
00:22:35,754 --> 00:22:38,622
Have you used any tools or
found any way to utilize the

523
00:22:38,623 --> 00:22:41,193
anti-user that log files or any

524
00:22:41,193 --> 00:22:42,694
of the registry that log files?

525
00:22:42,694 --> 00:22:45,697
I haven't ever really seen
a great methodology to parts

526
00:22:45,697 --> 00:22:48,367
to them or figure out what's
in there and if so do you know

527
00:22:48,367 --> 00:22:50,268
if they have useful
information of, you know,

528
00:22:50,268 --> 00:22:52,871
maybe registry keys where
deleted and you could help,

529
00:22:52,871 --> 00:22:54,139
- Right
- [Audience Member] Validate,

530
00:22:54,139 --> 00:22:55,607
you know your findings
and find other evidence?

531
00:22:55,607 --> 00:22:56,808
- Those are like the transaction

532
00:22:56,808 --> 00:22:58,877
laws while things are happening.

533
00:22:58,877 --> 00:23:01,879
I've discussed this
with Dave and with Willy

534
00:23:01,880 --> 00:23:05,517
and the length of
time that the stuff

535
00:23:05,517 --> 00:23:07,853
sits in the logs is
relatively short.

536
00:23:07,853 --> 00:23:12,290
So, while it's possible, we
know what the format looks like

537
00:23:12,290 --> 00:23:14,693
I could come up with something
but the chances of you

538
00:23:14,693 --> 00:23:16,728
running into something
where it's like within

539
00:23:16,728 --> 00:23:19,798
that very short window, to
actually need the log files

540
00:23:19,798 --> 00:23:23,435
to overlay on top of the
original hive, it's pretty rare

541
00:23:23,435 --> 00:23:25,437
and I think from
talkin' to Dave...

542
00:23:25,437 --> 00:23:26,871
Have you guys ever
run into that?

543
00:23:26,872 --> 00:23:30,142
Where you actually have
needed it or seen it, useful?

544
00:23:30,142 --> 00:23:32,511
- [Dave] You could definitely
use Registry Recon.

545
00:23:32,511 --> 00:23:34,980
- Registry Recon, like,
a more specialized tool

546
00:23:34,980 --> 00:23:38,283
to pull those things in and
recover those individual items.

547
00:23:38,283 --> 00:23:39,717
So Registry Recon'll do that.

548
00:23:39,718 --> 00:23:42,387
I mean it'll carve a
completely formatted disk

549
00:23:42,387 --> 00:23:44,255
and find all kind
of crazy stuff.

550
00:23:44,256 --> 00:23:46,024
Think there's one over here?

551
00:23:46,024 --> 00:23:49,194
- [Man] So you've been talking
about recovering deleted

552
00:23:49,194 --> 00:23:53,331
registry values and keys
from unallocated portions

553
00:23:53,331 --> 00:23:57,401
of an actual registry hive.
What about chunks of random

554
00:23:57,402 --> 00:24:00,739
registry hives that you
find in unallocated space?

555
00:24:00,739 --> 00:24:02,574
Have you worked on
trying to actually

556
00:24:02,574 --> 00:24:04,676
recover pieces of
structure from that?

557
00:24:04,676 --> 00:24:07,111
- Not with my tools.
That would be more like...

558
00:24:07,112 --> 00:24:09,614
Registry Recon does that.
X-Ways would do that,

559
00:24:09,614 --> 00:24:11,716
where is would find, "Oh
I see a regeff header.

560
00:24:11,716 --> 00:24:13,418
I see the header
length, I can read

561
00:24:13,418 --> 00:24:16,053
that out and potentially
recover some stuff."

562
00:24:16,054 --> 00:24:18,490
Registry recon you point
it at an EZR one or a DD

563
00:24:18,490 --> 00:24:21,660
and it's going to find every
single sliver of everything

564
00:24:21,660 --> 00:24:23,195
and attempt to put
it back together

565
00:24:23,195 --> 00:24:24,896
and it does a very
good job at it.

566
00:24:24,896 --> 00:24:27,365
- [Man] I'm thinking more of
situations where you don't have

567
00:24:27,365 --> 00:24:30,001
the header, you've just got
random chunks of registry

568
00:24:30,001 --> 00:24:32,103
(voice gets drowned out)
- You certainly could find

569
00:24:32,103 --> 00:24:36,174
the NKs and the VKs.
It would be rather difficult

570
00:24:36,174 --> 00:24:39,010
unless they were
relatively close together

571
00:24:39,010 --> 00:24:40,812
and even then you may be...

572
00:24:40,812 --> 00:24:44,416
If you're missing the
first 20% of the hive,

573
00:24:44,416 --> 00:24:47,418
all you relative offsets
are useless at that point.

574
00:24:47,419 --> 00:24:50,088
So really if you have the header
and then down at that point

575
00:24:50,088 --> 00:24:52,791
you'd be much better off than
if you found stuff toward

576
00:24:52,791 --> 00:24:55,460
the middle of the tail, just
because of the nature of...

577
00:24:55,460 --> 00:24:57,362
I don't know how much
stuff came before

578
00:24:57,362 --> 00:24:59,030
and you could figure it
out maybe to a degree

579
00:24:59,030 --> 00:25:02,167
if you have an hbin because
you're gonna have a position

580
00:25:02,167 --> 00:25:04,202
but you don't know how big
all the other sizes were,

581
00:25:04,202 --> 00:25:06,571
it would be very complicated.
You'd have to do it

582
00:25:06,571 --> 00:25:08,639
individually and then try
to just glean something out

583
00:25:08,640 --> 00:25:11,610
of key names or value names,
time stamps, things like that.

584
00:25:12,477 --> 00:25:13,812
Is there one over here too?

585
00:25:14,813 --> 00:25:16,481
- [Troy] Anybody else?
Questions.

586
00:25:18,383 --> 00:25:19,518
Okay.
- Alright

587
00:25:20,619 --> 00:25:21,852
- [Troy] Former special

588
00:25:21,853 --> 00:25:23,088
agent Zimmerman
(audience applaud)

589
00:25:23,088 --> 00:25:24,255
thank you very much!
That was outstanding.

590
00:25:24,256 --> 00:25:29,261
Well done.
(synth music)

