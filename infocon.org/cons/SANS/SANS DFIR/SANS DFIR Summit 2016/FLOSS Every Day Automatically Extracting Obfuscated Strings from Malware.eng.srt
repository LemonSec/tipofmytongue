1
00:00:00,734 --> 00:00:03,536
(undulating music)

2
00:00:11,778 --> 00:00:13,179
(audience applauds)
- [Willi] Hey Jake.

3
00:00:13,179 --> 00:00:14,714
- [Jake] Hi.

4
00:00:14,714 --> 00:00:15,648
- I actually have a,

5
00:00:15,648 --> 00:00:16,883
I have a question for you.

6
00:00:16,883 --> 00:00:20,520
What did the dentist
say to the golfer?

7
00:00:20,520 --> 00:00:22,956
- [Jake] What did the
dentist say to the golfer?

8
00:00:22,956 --> 00:00:23,890
I'm betting this has something

9
00:00:23,890 --> 00:00:25,458
to do with my foot in my mouth.

10
00:00:25,458 --> 00:00:27,360
Let's see, no, I don't know.

11
00:00:27,360 --> 00:00:28,828
- You got a hole in one.

12
00:00:28,828 --> 00:00:30,563
- [Jake] I got a hole in one?

13
00:00:30,563 --> 00:00:33,033
- Yeah, one of these guys.
Alright.

14
00:00:33,033 --> 00:00:35,702
- [Jake] Okay, well
played, well played.

15
00:00:39,639 --> 00:00:40,440
- That's right.

16
00:00:41,908 --> 00:00:43,243
Alright, Well thanks for
coming by this afternoon.

17
00:00:43,243 --> 00:00:44,644
I am excited to announce that

18
00:00:44,644 --> 00:00:45,644
we brought presents
for all you guys.

19
00:00:45,645 --> 00:00:46,913
If you check under your seats,

20
00:00:46,913 --> 00:00:48,181
we got a piece of
malware for you all

21
00:00:48,181 --> 00:00:50,650
so go ahead and take out
that piece of malware

22
00:00:50,650 --> 00:00:52,184
and I want you to tell me,
just based on this hash,

23
00:00:52,185 --> 00:00:53,753
is this file, is it good or bad?

24
00:00:54,954 --> 00:00:55,855
Let's do some malware
analysis together here.

25
00:00:55,855 --> 00:00:56,955
Anyone who can tell me?

26
00:00:58,191 --> 00:00:59,559
Alright, so some people
actually caught me here,

27
00:00:59,559 --> 00:01:00,760
this is the empty file,

28
00:01:00,760 --> 00:01:01,693
there's nothing going
on with this hash,

29
00:01:01,694 --> 00:01:03,730
but how about this one here?

30
00:01:03,730 --> 00:01:05,732
You're out doing an
investigation, you
found this file,

31
00:01:05,732 --> 00:01:08,868
maybe some guy sent it to you,
you know, what's going on?

32
00:01:08,868 --> 00:01:11,538
Do we need to worry
about this? I don't know.

33
00:01:11,538 --> 00:01:12,639
What's our first step?

34
00:01:12,639 --> 00:01:14,107
My first step is usually,

35
00:01:14,107 --> 00:01:15,675
throw it on Google,
throw it on Virus Total.

36
00:01:15,675 --> 00:01:16,910
Let's see if we
find any results.

37
00:01:16,910 --> 00:01:18,945
I don't wanna
duplicate my analysis.

38
00:01:18,945 --> 00:01:20,512
I wanna rely on the
shoulders of giants,

39
00:01:20,513 --> 00:01:22,048
stand on the
shoulders of giants.

40
00:01:22,048 --> 00:01:24,017
So let's throw it
up on Virus Total.

41
00:01:24,017 --> 00:01:27,286
Oh, but unfortunately this
thing hasn't yet been seen yet.

42
00:01:27,287 --> 00:01:28,421
Yeah, right? Definitely bad.

43
00:01:28,421 --> 00:01:29,789
This is probably
malware maybe targeting

44
00:01:29,789 --> 00:01:32,592
my specific organization
or it's Patch Tuesday,

45
00:01:32,592 --> 00:01:34,360
it's Microsoft Binary,

46
00:01:34,360 --> 00:01:36,129
nobody's uploaded it yet
and I haven't yet learned

47
00:01:36,129 --> 00:01:38,031
to check digital signatures.

48
00:01:38,031 --> 00:01:39,499
Alright, so the
next step, right,

49
00:01:39,499 --> 00:01:41,533
is open it in IDA Pro, who
brought their license to kill?

50
00:01:41,534 --> 00:01:45,238
I mean, license for IDA Pro,
who's got that with them?

51
00:01:45,238 --> 00:01:46,873
Alright, is this our next step?

52
00:01:48,308 --> 00:01:50,810
Although I love using IDA
Pro, this is not my next step.

53
00:01:50,810 --> 00:01:53,580
Makes my eyes bleed,
alright I like using it.

54
00:01:53,580 --> 00:01:54,948
Not too much fun
to use, alright,

55
00:01:54,948 --> 00:01:56,482
So my next step is usually,

56
00:01:56,483 --> 00:01:58,885
maybe go and look at the
PE features of this file,

57
00:01:58,885 --> 00:02:00,553
look at its imports,

58
00:02:00,553 --> 00:02:02,422
make hypotheses about
what the file may do.

59
00:02:02,422 --> 00:02:04,224
And maybe they'll
drive my analysis.

60
00:02:05,558 --> 00:02:07,527
I might wonder if I'm
starting to think this is bad,

61
00:02:07,527 --> 00:02:10,163
well how do I find this
file in my enterprise?

62
00:02:10,163 --> 00:02:11,865
I got 100,000 systems to scan,

63
00:02:11,865 --> 00:02:13,199
I'm not compromised.

64
00:02:13,199 --> 00:02:15,935
Next thing I might
do, run strings on it.

65
00:02:15,935 --> 00:02:17,203
Just hoping to pull
out some artifacts

66
00:02:17,203 --> 00:02:19,139
that might be sitting
there in plain text.

67
00:02:19,139 --> 00:02:22,475
So we'll go ahead and do that,
and this is what we get out.

68
00:02:23,343 --> 00:02:24,878
Some things I'm happy about.

69
00:02:24,878 --> 00:02:27,412
I definitely see that DOS
program up front there.

70
00:02:27,413 --> 00:02:30,183
The string there, it definitely
tells me this is a PE file.

71
00:02:30,183 --> 00:02:32,519
I see some names of some
sections right up front.

72
00:02:32,519 --> 00:02:34,087
But subsequently, it just
kind of looks like junk to me.

73
00:02:34,087 --> 00:02:35,888
I don't really know
how to interpret this.

74
00:02:37,056 --> 00:02:38,324
Now what actually
ends up tricking me,

75
00:02:38,324 --> 00:02:39,592
is that this file is malicious.

76
00:02:39,592 --> 00:02:41,094
It's been obfuscated
in some way,

77
00:02:41,094 --> 00:02:43,630
and yet I can't tell just
based on the PE features

78
00:02:43,630 --> 00:02:45,665
or the strings of this fact.

79
00:02:45,665 --> 00:02:48,201
So it'd be nice if we had
some tool to tell us this

80
00:02:48,201 --> 00:02:50,370
that sure enough there are
obfuscated strings in there

81
00:02:50,370 --> 00:02:52,305
and allow us to extract them.

82
00:02:52,305 --> 00:02:54,807
Except I jumped ahead
a couple slides.

83
00:02:54,807 --> 00:02:59,112
So my next step, not
knowing that information,

84
00:03:00,280 --> 00:03:01,581
is if I'm a Reverse Engineer,

85
00:03:01,581 --> 00:03:03,882
yeah okay it might
be time for me to use

86
00:03:03,883 --> 00:03:06,419
IDA Pro, WinDbg, OllyDbg.

87
00:03:06,419 --> 00:03:07,921
These are tools,

88
00:03:07,921 --> 00:03:09,489
very finicky or require
lot of advanced knowledge,

89
00:03:09,489 --> 00:03:10,890
but are very powerful.

90
00:03:11,858 --> 00:03:13,359
Takes a long time though.

91
00:03:13,359 --> 00:03:16,229
I may not have time during
the incident response

92
00:03:16,229 --> 00:03:19,465
to focus all my attention on
this one sample of malware.

93
00:03:19,465 --> 00:03:20,867
If I'm not a Reverse Engineer,

94
00:03:20,867 --> 00:03:22,167
I mean I know we have
some Reverse Engineers

95
00:03:22,168 --> 00:03:23,369
in the audience here,

96
00:03:23,369 --> 00:03:26,172
but is everyone here
comfortable in IDA Pro?

97
00:03:26,172 --> 00:03:29,375
I don't see too many
hands here, It's fine.

98
00:03:29,375 --> 00:03:31,044
So what do I have to do?

99
00:03:31,044 --> 00:03:32,312
I have to call up
a Reverse Engineer

100
00:03:32,312 --> 00:03:34,347
and Moritz here, he looks nice.

101
00:03:34,347 --> 00:03:35,848
He's a pain to work with.

102
00:03:35,848 --> 00:03:38,685
He's not always on time,
he listens to weird music.

103
00:03:38,685 --> 00:03:40,086
Sometimes he smells.

104
00:03:40,086 --> 00:03:42,322
Reverse Engineers can
be kinda weird people.

105
00:03:42,322 --> 00:03:43,990
We don't really want
to deal with them.

106
00:03:43,990 --> 00:03:45,358
Sometimes they also
cost a lot of money

107
00:03:45,358 --> 00:03:46,960
if we don't have one on staff

108
00:03:46,960 --> 00:03:51,130
so we wanna kind of avoid this.

109
00:03:51,130 --> 00:03:54,500
So we have basically built
a technique and a tool

110
00:03:54,500 --> 00:03:56,636
That allows you to
very easily extract

111
00:03:56,636 --> 00:03:58,504
obfuscated strings from malware,

112
00:03:58,504 --> 00:04:01,073
and that's what we're here
to talk to you about today.

113
00:04:01,074 --> 00:04:02,408
We already got a great
introduction here

114
00:04:02,408 --> 00:04:04,077
about who the two of us are.

115
00:04:04,077 --> 00:04:05,845
As mentioned I'm
Willi Ballenthin.

116
00:04:05,845 --> 00:04:08,281
I joined Mandate
about six years ago.

117
00:04:08,281 --> 00:04:10,149
I basically learned by doing,

118
00:04:10,149 --> 00:04:12,285
and so overtime I've
written a bunch of scripts

119
00:04:12,285 --> 00:04:13,585
and kinda shared them back.

120
00:04:13,586 --> 00:04:14,821
Got a lot of good feedback,

121
00:04:14,821 --> 00:04:16,154
and interacted with
many of you before

122
00:04:16,154 --> 00:04:19,024
so it's exciting to be
up here in front of you.

123
00:04:19,024 --> 00:04:21,327
These days I work on the
Flare team which is a

124
00:04:21,327 --> 00:04:24,030
FireEye Labs Advanced
Reverse Engineering Team.

125
00:04:24,030 --> 00:04:26,899
And this is basically a
backend service within FireEye

126
00:04:26,899 --> 00:04:29,235
that does most of the Reverse
Engineering at FireEye.

127
00:04:29,235 --> 00:04:31,571
So we're looking at
malware, exploits.

128
00:04:31,571 --> 00:04:33,706
We're located all around
the United States.

129
00:04:35,041 --> 00:04:36,175
It's a fun place to work.

130
00:04:37,577 --> 00:04:42,348
- Yeah, and I'm Moritz,
pretty new to the community,

131
00:04:43,783 --> 00:04:46,019
I started working at Mandiant,
or FireEye about a year ago,

132
00:04:47,787 --> 00:04:49,822
I did some incident
response at the beginning,

133
00:04:49,822 --> 00:04:51,090
and then got pretty sucked into

134
00:04:51,090 --> 00:04:53,325
this Reverse Engineering field,

135
00:04:53,326 --> 00:04:55,862
and that's what we've
been focusing on now,

136
00:04:55,862 --> 00:04:58,231
and FLOSS is just
a great example

137
00:04:58,231 --> 00:05:00,832
of the cool work
we were able to do,

138
00:05:03,069 --> 00:05:04,170
let's get right at it.

139
00:05:05,305 --> 00:05:08,508
I'm happy to provide
some background for us,

140
00:05:08,508 --> 00:05:11,344
for malware, it's
nothing new to you,

141
00:05:11,344 --> 00:05:15,381
but it gives a good feedback
of why string obfuscation

142
00:05:15,381 --> 00:05:18,518
is pretty common in malware,
and why we see it a lot,

143
00:05:18,518 --> 00:05:20,852
and why we figured we'd
do something about it,

144
00:05:20,853 --> 00:05:22,055
to make our life easier.

145
00:05:23,222 --> 00:05:26,392
So packing, I'm sure
everyone here has seen

146
00:05:26,392 --> 00:05:31,397
a UPX packed file, or
similar packed executables.

147
00:05:32,865 --> 00:05:35,902
Everything that we look at
in the, on this executable

148
00:05:35,902 --> 00:05:40,873
is compressed, obfuscated,
and the malware does

149
00:05:44,477 --> 00:05:48,780
uncompressing of that data
in memory before executing.

150
00:05:49,649 --> 00:05:51,017
Can we go to the next slide?

151
00:05:52,518 --> 00:05:55,121
- [Willi] To the right.

152
00:05:55,121 --> 00:05:56,121
Point it back there.

153
00:05:57,457 --> 00:05:58,758
I don't know.

154
00:05:58,758 --> 00:06:00,525
- It's not like a
Wii remote, right?

155
00:06:03,563 --> 00:06:04,897
Yeah, so nothing new.

156
00:06:06,299 --> 00:06:07,866
There's a little unpacking stub

157
00:06:07,867 --> 00:06:10,370
that uncompresses the data

158
00:06:10,370 --> 00:06:12,071
and puts it back into memory.

159
00:06:12,071 --> 00:06:14,941
So when we look statically
and with other tools

160
00:06:14,941 --> 00:06:17,342
at the, on this
executable, we won't

161
00:06:17,343 --> 00:06:19,445
get anything useful
out of there,

162
00:06:19,445 --> 00:06:21,314
strings are hidden.

163
00:06:24,417 --> 00:06:27,953
It's just not very useful
for our static analysis.

164
00:06:29,088 --> 00:06:31,157
On the other hand, it's
pretty good for us,

165
00:06:31,157 --> 00:06:33,993
as the good guys, when
we look at this file,

166
00:06:33,993 --> 00:06:36,028
it's pretty obvious to
tell that this is packed,

167
00:06:36,028 --> 00:06:39,632
and we can easily
flag it as malicious,

168
00:06:39,632 --> 00:06:42,635
'cause there might be a
high entropy of the file,

169
00:06:42,635 --> 00:06:44,637
the section headers
might look off,

170
00:06:44,637 --> 00:06:46,305
it's just not like
the general file

171
00:06:46,305 --> 00:06:49,575
we would've expect
if it's benign.

172
00:06:49,575 --> 00:06:54,280
So, pretty easy to
tell this is evil.

173
00:06:54,280 --> 00:06:58,017
So instead, malware
authors then hide their

174
00:06:58,017 --> 00:07:00,253
most valuable information only,

175
00:07:00,253 --> 00:07:02,188
which is often done in strings

176
00:07:02,188 --> 00:07:05,390
that get passed to Windows
API calls for example,

177
00:07:06,559 --> 00:07:10,229
the names of C2
server addresses,

178
00:07:10,229 --> 00:07:13,265
file names created,
files dropped,

179
00:07:13,266 --> 00:07:14,867
host based, network
based indicators

180
00:07:14,867 --> 00:07:17,470
all over the place are
encoded in strings.

181
00:07:17,470 --> 00:07:21,574
So, those get obfuscated
in the malware,

182
00:07:21,574 --> 00:07:25,845
and before using it
in the code, decoded.

183
00:07:28,681 --> 00:07:32,618
So, again, all we see
when we run strings

184
00:07:32,618 --> 00:07:35,288
on this malware is
bunch of garbage,

185
00:07:35,288 --> 00:07:38,191
and when I look at,
some of these strings

186
00:07:38,191 --> 00:07:40,126
actually look like
obfuscated strings,

187
00:07:40,126 --> 00:07:42,128
but there's no
way to tell for us

188
00:07:42,128 --> 00:07:43,863
what obfuscation was used.

189
00:07:45,331 --> 00:07:50,336
Could be simple XOR of the
bytes, could be RC4 encryption,

190
00:07:51,537 --> 00:07:53,840
and this technique
is commonly used,

191
00:07:53,840 --> 00:07:55,808
it's used in commodity malware,

192
00:07:55,808 --> 00:07:59,312
seen it in Zeus,
banking trojans,

193
00:07:59,312 --> 00:08:01,280
I've seen it in
some of the samples

194
00:08:01,280 --> 00:08:04,049
I looked at last week,
which were related,

195
00:08:04,050 --> 00:08:09,055
or attributed to
APT28, 29, they use it,

196
00:08:10,456 --> 00:08:14,427
so it goes from commodity stuff
up to very targeted attacks,

197
00:08:16,062 --> 00:08:19,065
and when I look at this,
then, as a Reverse Engineer,

198
00:08:19,065 --> 00:08:21,834
in IDA Pro, the yellow
highlighted function

199
00:08:21,834 --> 00:08:24,237
here is actually a
decoding routine,

200
00:08:24,237 --> 00:08:27,206
and the gray data there
is an obfuscated string

201
00:08:27,206 --> 00:08:29,308
that gets passed
to that function,

202
00:08:29,308 --> 00:08:32,511
and right before the
malware needs that string,

203
00:08:32,511 --> 00:08:35,013
or uses it, it decodes it,

204
00:08:36,448 --> 00:08:40,051
and there's no way for us to
tell just by running strings,

205
00:08:40,052 --> 00:08:42,622
and static analysis
what we get here.

206
00:08:43,990 --> 00:08:47,727
So, very annoying, hence
there's some common techniques

207
00:08:47,727 --> 00:08:50,963
Reverse Engineers use
to get this data back,

208
00:08:50,963 --> 00:08:53,766
first one being, you need
your Reverse Engineer,

209
00:08:53,766 --> 00:08:57,236
and a debugger, for example,

210
00:08:57,236 --> 00:08:59,972
and it's basically just
doing memory forensics.

211
00:08:59,972 --> 00:09:03,276
You execute the malware,
set a specific break point,

212
00:09:03,276 --> 00:09:05,645
dump all the memory, and extract

213
00:09:05,645 --> 00:09:08,948
the strings out of
that processed memory.

214
00:09:08,948 --> 00:09:10,415
So it's very easy to do,

215
00:09:10,416 --> 00:09:12,351
unfortunately doesn't
work very often,

216
00:09:12,351 --> 00:09:15,788
'cause strings might get
de-obfuscated after using them,

217
00:09:19,692 --> 00:09:22,028
it's easy to do but
doesn't work very often.

218
00:09:22,028 --> 00:09:24,564
Second technique,
then you could do,

219
00:09:24,564 --> 00:09:27,967
once you've put in some time,

220
00:09:27,967 --> 00:09:29,769
reverse engineered
some of the code,

221
00:09:29,769 --> 00:09:31,504
identified a decoding routine,

222
00:09:32,872 --> 00:09:35,641
you again use the debugger
to force the malware

223
00:09:35,641 --> 00:09:37,343
down a specific code path that

224
00:09:37,343 --> 00:09:42,348
you want it to take to
obfuscate the strings for you,

225
00:09:43,716 --> 00:09:45,785
So use the code of the
malware, that's pretty cool,

226
00:09:45,785 --> 00:09:47,486
you make the malware
work for you,

227
00:09:50,856 --> 00:09:54,026
it's the easy way
for you to do it,

228
00:09:54,026 --> 00:09:56,295
but imagine doing that 50 times

229
00:09:56,295 --> 00:09:59,098
for that one string decoding
routine that is in there,

230
00:09:59,098 --> 00:10:01,534
it's a very tedious process,
takes a lot of time.

231
00:10:02,969 --> 00:10:04,470
Third approach
you could take is,

232
00:10:04,470 --> 00:10:07,373
you could re-implement the
code you've identified,

233
00:10:07,373 --> 00:10:11,344
in the decoding routines
in your own code,

234
00:10:11,344 --> 00:10:15,982
scripting, piping code,
see whatever you prefer.

235
00:10:17,350 --> 00:10:19,719
This is an error prone
process, also very tedious,

236
00:10:21,153 --> 00:10:24,657
might be good to apply this
flexibly to all the data

237
00:10:24,657 --> 00:10:26,659
that you then also
have to extract,

238
00:10:26,659 --> 00:10:29,128
so again takes a lot of time.

239
00:10:29,128 --> 00:10:30,830
Whole message of this is

240
00:10:34,500 --> 00:10:38,971
at least I would say if
there's a fairly sophisticated

241
00:10:38,971 --> 00:10:42,808
string decoding routine,
you spend two to three hours

242
00:10:42,808 --> 00:10:46,212
reversing and getting
those strings back,

243
00:10:46,212 --> 00:10:48,146
which you much rather
could focus on,

244
00:10:49,348 --> 00:10:51,383
figuring out what
does the malware do,

245
00:10:51,384 --> 00:10:53,753
what interesting
capabilities does it have,

246
00:10:53,753 --> 00:10:57,556
and the forensic analyst
breathing down my neck

247
00:10:58,624 --> 00:11:00,259
will be also happy that

248
00:11:02,361 --> 00:11:04,797
I wouldn't spend
much time on this,

249
00:11:04,797 --> 00:11:08,768
so that's why we came
up with the FLOSS tool,

250
00:11:08,768 --> 00:11:10,936
the FireLabs Obfuscated
String Solver.

251
00:11:13,973 --> 00:11:15,274
- Yeah just to
emphasize what he said,

252
00:11:15,274 --> 00:11:16,809
when I first started
reverse engineering,

253
00:11:16,809 --> 00:11:18,978
I loved decoding strings, I
felt like I was doing a lot.

254
00:11:18,978 --> 00:11:20,112
I would write these
automated things

255
00:11:20,112 --> 00:11:21,847
to like extract, whatnot.

256
00:11:21,847 --> 00:11:24,016
That was fun for like
the first two weeks,

257
00:11:24,016 --> 00:11:25,950
and then I realized I had to
do this every single week,

258
00:11:25,951 --> 00:11:28,621
multiple times per
week, in each session,

259
00:11:28,621 --> 00:11:31,490
with like two or three
hours of doing this,

260
00:11:31,490 --> 00:11:34,093
crossed a whole year,
52 weeks of the year,

261
00:11:34,093 --> 00:11:35,560
we have 30 people on our team,

262
00:11:35,561 --> 00:11:37,196
you can imagine how
much time we're wasting,

263
00:11:37,196 --> 00:11:38,597
doing the same thing
over and over again,

264
00:11:38,597 --> 00:11:40,232
and there's just so
many ways you can

265
00:11:40,232 --> 00:11:41,901
encode and decode strings,

266
00:11:41,901 --> 00:11:43,202
that we might be
able to build up

267
00:11:43,202 --> 00:11:45,871
a database of some
existing decoders,

268
00:11:45,871 --> 00:11:48,908
but the attacker only
has to change one bit,

269
00:11:48,908 --> 00:11:50,943
or one little tweak,

270
00:11:50,943 --> 00:11:52,343
it's an asymmetric warfare here,

271
00:11:52,344 --> 00:11:54,180
the attacker has
such an easier time,

272
00:11:54,180 --> 00:11:55,448
generating these binaries

273
00:11:55,448 --> 00:11:56,982
than we have reverse
engineering them,

274
00:11:56,982 --> 00:11:59,318
so that's kind of
our motivation here.

275
00:11:59,318 --> 00:12:00,819
So, FLOSS, what is this guy?

276
00:12:00,820 --> 00:12:03,189
This is our FireEye Labs
Obfuscated String Solver,

277
00:12:03,189 --> 00:12:05,891
it's the solution to, well
just one of your problems,

278
00:12:05,891 --> 00:12:07,459
but hopefully a big one, right?

279
00:12:09,295 --> 00:12:11,097
Right off the bat, how
do we use this thing?

280
00:12:11,097 --> 00:12:12,798
We use it just like Strings.exe,

281
00:12:13,933 --> 00:12:15,634
it just gives us
more data, okay,

282
00:12:15,634 --> 00:12:16,902
this is a key point here.

283
00:12:16,902 --> 00:12:20,773
We're gonna use FLOSS to
view strings and more.

284
00:12:20,773 --> 00:12:24,076
Strings plus plus, we invoke it,

285
00:12:24,076 --> 00:12:27,213
FLOSS, file name, it gives
us the data that we want,

286
00:12:27,213 --> 00:12:30,049
it's that easy, there's
nothing more to it, alright.

287
00:12:30,049 --> 00:12:31,717
It's very user friendly.

288
00:12:31,717 --> 00:12:33,718
How many of you guys have
been to Black Hat, or RSA,

289
00:12:33,719 --> 00:12:35,154
or these great
technical conferences,

290
00:12:35,154 --> 00:12:37,022
and you see a really
interesting presentation,

291
00:12:37,022 --> 00:12:38,557
and you go home and you try it,

292
00:12:38,557 --> 00:12:39,892
you try to set up Elasticsearch

293
00:12:39,892 --> 00:12:41,227
in Kibana and all
these different things,

294
00:12:41,227 --> 00:12:43,329
and it takes like two weeks,

295
00:12:43,329 --> 00:12:45,598
and you still don't
get it figured out?

296
00:12:45,598 --> 00:12:47,132
And you're kinda like,

297
00:12:47,133 --> 00:12:49,168
these guys are smart,
but I can't live up

298
00:12:49,168 --> 00:12:50,536
to what they're doing, right?

299
00:12:50,536 --> 00:12:52,670
We recognize this.

300
00:12:52,671 --> 00:12:56,275
Although FLOSS is implemented
pure Python, easy to hack on,

301
00:12:56,275 --> 00:12:58,810
we give you a single
standalone executable file

302
00:12:58,811 --> 00:13:00,446
that you can use
like Strings.exe,

303
00:13:00,446 --> 00:13:02,915
you can download it
today off Github,

304
00:13:02,915 --> 00:13:05,251
so it's easy to get started,
as we're talking here on stage,

305
00:13:05,251 --> 00:13:06,584
with this tool, you
already know how to use it.

306
00:13:06,585 --> 00:13:08,354
It's all opensource on Github,

307
00:13:08,354 --> 00:13:09,989
it's free for everyone to use,

308
00:13:09,989 --> 00:13:11,924
we wanna share this
technique with you.

309
00:13:12,992 --> 00:13:14,627
What is it, how does it work?

310
00:13:14,627 --> 00:13:16,862
Basically we took Moritz,
we scanned in his brain,

311
00:13:16,862 --> 00:13:18,731
and we turned into Python.

312
00:13:18,731 --> 00:13:20,466
- 'Cause you don't wanna
deal with me in person.

313
00:13:20,466 --> 00:13:22,201
- And we're sharing
it with you, alright,

314
00:13:22,201 --> 00:13:24,236
we took the Flare
team's expertise,

315
00:13:24,236 --> 00:13:25,538
their expertise in
doing things like

316
00:13:25,538 --> 00:13:28,440
reconstructing
control flow graphs,

317
00:13:28,440 --> 00:13:31,076
emulating code,
extracting functions,

318
00:13:31,076 --> 00:13:32,878
doing all this crazy stuff,

319
00:13:32,878 --> 00:13:35,314
and we make it easy
for you to use, okay?

320
00:13:35,314 --> 00:13:36,682
So let me tell you
a little bit about

321
00:13:36,682 --> 00:13:38,517
how it's using these
techniques and these processes

322
00:13:38,517 --> 00:13:40,119
to make your job easier.

323
00:13:41,587 --> 00:13:43,789
This is the algorithm
right here, six steps.

324
00:13:45,491 --> 00:13:47,560
Let's walk through
it point by point.

325
00:13:47,560 --> 00:13:50,795
First thing we do, we've
got this PE file, right?

326
00:13:50,796 --> 00:13:52,531
We analyze it, we say,

327
00:13:52,531 --> 00:13:54,532
it's made up of functions,
made up of code.

328
00:13:54,533 --> 00:13:56,168
What functions do we have here?

329
00:13:56,168 --> 00:13:58,704
How are these functions
related with one another?

330
00:13:58,704 --> 00:13:59,972
This is similar to
when you open up

331
00:13:59,972 --> 00:14:01,207
in IDA pro, a new binary,

332
00:14:01,207 --> 00:14:02,842
and you see it do all
these crazy things,

333
00:14:02,842 --> 00:14:04,610
if you don't know what
you're doing with IDA Pro,

334
00:14:04,610 --> 00:14:06,111
you look over your friends
shoulder and you're like,

335
00:14:06,111 --> 00:14:08,047
he really knows what
he's doing, right?

336
00:14:08,047 --> 00:14:10,082
We do a bunch of
upfront analysis

337
00:14:10,082 --> 00:14:13,018
to have a good sense for what
the binary might be doing.

338
00:14:13,018 --> 00:14:16,488
We then use heuristics
to inspect each function,

339
00:14:16,488 --> 00:14:18,090
to say whether or not
we think this function

340
00:14:18,090 --> 00:14:20,292
could be an encoding
or decoding routine.

341
00:14:20,292 --> 00:14:21,894
That sounds kind of hard.

342
00:14:21,894 --> 00:14:25,698
How do we identify RC4 and
Base64 and XOR all together?

343
00:14:25,698 --> 00:14:26,632
Here's the insight,

344
00:14:30,202 --> 00:14:33,906
we have a set of heuristics
that inspect for each function,

345
00:14:33,906 --> 00:14:35,940
the heuristic says, I think
this is encoding routine,

346
00:14:35,941 --> 00:14:37,710
I don't think this
is encoding routine.

347
00:14:37,710 --> 00:14:38,978
Now, how do we encode this?

348
00:14:38,978 --> 00:14:40,813
I wanna give you an
example, alright?

349
00:14:42,281 --> 00:14:44,483
Here's a quick
screenshot from IDA Pro.

350
00:14:44,483 --> 00:14:46,919
As a reverse engineer,
what I see here,

351
00:14:46,919 --> 00:14:48,754
basic blocks, some
assembly code,

352
00:14:48,754 --> 00:14:51,457
zooming in specifically
right in the middle,

353
00:14:51,457 --> 00:14:54,793
I see this arithmetic
instruction, this
XOR instruction,

354
00:14:54,793 --> 00:14:57,196
that's manipulating
a single byte of data

355
00:14:57,196 --> 00:15:00,499
right in the middle here,
we see XOR A-L with 7,

356
00:15:00,499 --> 00:15:03,602
we're doing a single
byte XOR on some data.

357
00:15:03,602 --> 00:15:06,238
We then have some other
arithmetic instructions,

358
00:15:06,238 --> 00:15:07,539
don't need to go
into their details,

359
00:15:07,539 --> 00:15:08,908
whenever I see this,
I immediately think

360
00:15:08,908 --> 00:15:12,244
encoding, decoding,
encryption, compression, okay?

361
00:15:12,244 --> 00:15:14,179
This is easy for me to program,

362
00:15:14,179 --> 00:15:16,749
I can say, just look for
these set of instructions,

363
00:15:16,749 --> 00:15:18,484
the couple parameters
that they may have,

364
00:15:18,484 --> 00:15:20,586
and do some
reasoning about that.

365
00:15:20,586 --> 00:15:22,087
The next thing I identify

366
00:15:24,523 --> 00:15:27,493
is that this basic block
is in a tight loop.

367
00:15:27,493 --> 00:15:28,961
At the bottom of
this basic block,

368
00:15:28,961 --> 00:15:32,464
which is a discrete unit
of code within a binary,

369
00:15:32,464 --> 00:15:35,301
I see a conditional
jump, one branch,

370
00:15:35,301 --> 00:15:36,735
that's kind of right
at the bottom there,

371
00:15:36,735 --> 00:15:37,970
allows the CPU to continue

372
00:15:37,970 --> 00:15:40,406
executing the next
set of instructions.

373
00:15:40,406 --> 00:15:42,174
But the other branch
of this conditional

374
00:15:42,174 --> 00:15:44,709
is back to the start of
the same basic block,

375
00:15:44,710 --> 00:15:45,911
so these instructions
get repeated

376
00:15:45,911 --> 00:15:47,813
over and over and over again.

377
00:15:47,813 --> 00:15:50,049
In my experience as
a reverse engineer,

378
00:15:50,049 --> 00:15:51,583
this indicates to me that

379
00:15:51,583 --> 00:15:54,319
we're probably looping over
a buffer going byte by byte,

380
00:15:54,320 --> 00:15:57,589
applying those arithmetic
instructions to each byte.

381
00:15:57,589 --> 00:16:00,359
Again, this is easy for
me to do programmatically,

382
00:16:00,359 --> 00:16:02,661
I can say, give me
all the basic blocks,

383
00:16:02,661 --> 00:16:04,762
find all the ones that
loop to themselves,

384
00:16:04,763 --> 00:16:06,332
boom, I have a great
detection routine

385
00:16:06,332 --> 00:16:09,568
for finding Base64, RC4,

386
00:16:09,568 --> 00:16:11,837
single-byte, multibyte
XOR routines,

387
00:16:11,837 --> 00:16:13,572
all the things that we
commonly see in malware,

388
00:16:13,572 --> 00:16:15,574
easily captured by this.

389
00:16:16,608 --> 00:16:18,010
Once I've identified the things

390
00:16:18,010 --> 00:16:20,579
that I think might be
encoding or decoding routines,

391
00:16:20,579 --> 00:16:21,680
my next challenge
is to figure out

392
00:16:21,680 --> 00:16:24,516
what data might be decoded,

393
00:16:24,516 --> 00:16:26,551
and so I continue to
analyze the binary,

394
00:16:26,552 --> 00:16:27,753
I do some emulation,

395
00:16:27,753 --> 00:16:30,022
I basically virtualize
some of the code,

396
00:16:30,022 --> 00:16:32,124
see how it behaves,
to see what data's

397
00:16:32,124 --> 00:16:34,159
being passed into our
decoding routines.

398
00:16:37,262 --> 00:16:38,664
When I see data being passed in,

399
00:16:38,664 --> 00:16:41,100
I can take note of
what data this is,

400
00:16:41,100 --> 00:16:42,634
and here's the trick,

401
00:16:42,634 --> 00:16:45,838
we can use a virtual CPU
implemented in Python,

402
00:16:45,838 --> 00:16:47,573
we use this library
called vivisect

403
00:16:48,507 --> 00:16:50,641
to emulate the decoding routine

404
00:16:50,642 --> 00:16:52,644
as the malware author
implemented it.

405
00:16:52,644 --> 00:16:54,713
Instruction by
instruction, loop by loop,

406
00:16:54,713 --> 00:16:58,050
to operate on this data that
we think is the ciphertext,

407
00:16:59,218 --> 00:17:01,987
and if we emulate
this code correctly,

408
00:17:01,987 --> 00:17:04,089
we'll end up with
the plain text.

409
00:17:04,089 --> 00:17:05,323
Now one thing to
note here is that

410
00:17:05,324 --> 00:17:07,092
this is purely a
static technique,

411
00:17:07,092 --> 00:17:08,727
although we're kind
of virtualizing code,

412
00:17:08,727 --> 00:17:10,596
we're not doing anything
directly on the CPU,

413
00:17:10,596 --> 00:17:12,164
it's all pure Python,

414
00:17:12,164 --> 00:17:13,932
so unless you have
some vulnerability

415
00:17:13,932 --> 00:17:15,166
in your Python interpreter,

416
00:17:15,166 --> 00:17:17,403
in which case you
have a big problem,

417
00:17:17,403 --> 00:17:20,406
you don't have to worry about
this taking over your system.

418
00:17:20,406 --> 00:17:22,640
FLOSS is a tool you can
run on your analysis system

419
00:17:22,641 --> 00:17:24,643
'cause it's totally static.

420
00:17:24,643 --> 00:17:26,178
You don't need a big sandbox

421
00:17:26,178 --> 00:17:28,680
or bare metal system to run
it, this is pretty awesome.

422
00:17:30,582 --> 00:17:33,252
Finally, once we've emulated
the decoding routine,

423
00:17:33,252 --> 00:17:36,120
and we've seen how the CPU and
memory states have changed,

424
00:17:36,121 --> 00:17:37,723
we can just do a
different memory.

425
00:17:37,723 --> 00:17:39,491
What would the memory
look like beforehand?

426
00:17:39,491 --> 00:17:41,326
What does it look like after?

427
00:17:41,326 --> 00:17:43,262
Any bytes that are
different are places

428
00:17:43,262 --> 00:17:47,733
that we might have written
the decoded plain text,

429
00:17:47,733 --> 00:17:50,536
and so we scan through that
for strings, that's it.

430
00:17:50,536 --> 00:17:52,438
Was that pretty intuitive,
was that pretty simple?

431
00:17:52,438 --> 00:17:54,506
I hope so, it is.

432
00:17:54,506 --> 00:17:57,242
It was surprising to me when
it actually worked so well.

433
00:18:00,579 --> 00:18:04,550
- Yes, so we get all these
cool decoded strings,

434
00:18:06,718 --> 00:18:08,620
we really thought about it,

435
00:18:08,620 --> 00:18:13,625
and had this idea that we could
take this to the next level,

436
00:18:14,760 --> 00:18:17,162
as Willi already said,
strings plus plus,

437
00:18:17,162 --> 00:18:20,165
so FLOSS was also able to
extract all the strings

438
00:18:20,165 --> 00:18:22,234
that you get with
the strings tool,

439
00:18:22,234 --> 00:18:26,105
so you get all ASCII and
UTF strings using FLOSS,

440
00:18:28,674 --> 00:18:31,477
and a third category,
which was also

441
00:18:31,477 --> 00:18:33,812
commonly seen in malware
to obfuscate strings,

442
00:18:33,812 --> 00:18:38,649
Stackstrings, which are strings

443
00:18:38,650 --> 00:18:41,186
dynamically created at run time

444
00:18:41,186 --> 00:18:44,223
intermixed with
instructions in the binary,

445
00:18:44,223 --> 00:18:48,260
so the regular strings algorithm
doesn't get those strings.

446
00:18:48,260 --> 00:18:51,663
So you get three types of
strings with the FLOSS tool,

447
00:18:51,663 --> 00:18:55,033
and we really hope
that you can use it

448
00:18:55,033 --> 00:18:58,770
and replace the strings tool
in your analyst workflow,

449
00:18:58,770 --> 00:19:01,607
because you get all the strings
that you would get anyway,

450
00:19:03,008 --> 00:19:06,678
in addition to decoded
strings and Stackstrings.

451
00:19:08,714 --> 00:19:11,850
Also, we wanna mention here,

452
00:19:11,850 --> 00:19:15,254
while there might be string
decoding in A malware,

453
00:19:15,254 --> 00:19:18,389
it's not guaranteed
that FLOSS always works,

454
00:19:18,390 --> 00:19:22,394
we won't get it right all the
time, it's a hard problem,

455
00:19:22,394 --> 00:19:27,132
but it takes like five
seconds for you to run FLOSS,

456
00:19:28,767 --> 00:19:29,768
which you're wanting to see

457
00:19:29,768 --> 00:19:33,472
in the demo in a
short time here.

458
00:19:33,472 --> 00:19:38,477
So you don't lose
anything by running FLOSS,

459
00:19:39,811 --> 00:19:42,548
but you can win a lot,
as we're gonna see.

460
00:19:43,916 --> 00:19:45,350
- As we set up the video here.

461
00:19:45,350 --> 00:19:47,351
Can we go ahead and
play the first demo?

462
00:19:48,921 --> 00:19:50,556
What we found internally is our

463
00:19:50,556 --> 00:19:52,758
automated systems for
analyzing malware,

464
00:19:52,758 --> 00:19:55,794
what our instant responders
submit to the system,

465
00:19:55,794 --> 00:19:58,063
they submitted
like 45,000 samples

466
00:19:58,063 --> 00:19:59,932
since we started
developing this tool.

467
00:19:59,932 --> 00:20:01,500
About 30% of those actually have

468
00:20:01,500 --> 00:20:02,701
obfuscated strings
somewhere in them,

469
00:20:02,701 --> 00:20:05,170
and that we've been able
to extract, alright?

470
00:20:05,170 --> 00:20:06,605
So we're not guaranteeing
that every sample

471
00:20:06,605 --> 00:20:07,606
that you throw at
FLOSS you're actually

472
00:20:07,606 --> 00:20:08,907
gonna get some results,

473
00:20:08,907 --> 00:20:10,274
but actually a good
number of them,

474
00:20:10,275 --> 00:20:12,010
once you have a suspicion
about this file,

475
00:20:12,010 --> 00:20:13,278
there's a good chance
you'll actually extract

476
00:20:13,278 --> 00:20:15,314
useful information using FLOSS,

477
00:20:16,315 --> 00:20:17,883
so let's do that demo.

478
00:20:32,497 --> 00:20:34,533
- FLOSS demos always work.

479
00:20:34,533 --> 00:20:35,967
(chuckles) Normally.

480
00:20:41,707 --> 00:20:43,508
Let's rather wait for
the video. (laughs)

481
00:20:43,508 --> 00:20:46,478
- [Willi] Oh, alright, you
don't wanna share your jokes.

482
00:20:46,478 --> 00:20:48,046
We had a whole list
of dentist jokes,

483
00:20:48,046 --> 00:20:51,483
but you guys gave us bad
feedback on the first one,

484
00:20:51,483 --> 00:20:55,419
we're not gonna do that again.

485
00:20:55,420 --> 00:20:59,625
- [Moritz] Okay, so here we
go, no need for bad jokes.

486
00:20:59,625 --> 00:21:02,961
So, just gonna show
the strings output

487
00:21:02,961 --> 00:21:05,964
of this executable
here real quick,

488
00:21:05,964 --> 00:21:10,202
so we create the
ASCII and UTF strings,

489
00:21:10,202 --> 00:21:12,471
and just gonna look at
this file real quick,

490
00:21:12,471 --> 00:21:15,440
just to see the comparison
that the strings

491
00:21:15,440 --> 00:21:18,443
we get later on the FLOSS
actually are different.

492
00:21:18,443 --> 00:21:21,980
So we see our DOS header,
section headers in there,

493
00:21:23,448 --> 00:21:26,885
then text section, probably
just a bunch of code,

494
00:21:26,885 --> 00:21:28,520
there's a high like chance

495
00:21:28,520 --> 00:21:32,758
that the code actually looks
like some kind of strings,

496
00:21:32,758 --> 00:21:37,763
here we see those little four
character type of strings,

497
00:21:39,197 --> 00:21:40,899
we're gonna see
those later again,

498
00:21:42,034 --> 00:21:43,769
take a mental note here,

499
00:21:43,769 --> 00:21:46,538
scrolling through,
nothing really useful,

500
00:21:47,973 --> 00:21:49,608
there's some format strings,

501
00:21:51,476 --> 00:21:53,745
start of our import table,

502
00:21:57,816 --> 00:22:01,420
so there's, yeah,
nothing really useful.

503
00:22:01,420 --> 00:22:02,487
- [Willi] My suspicion
at this point,

504
00:22:02,487 --> 00:22:03,689
it's probably malicious,

505
00:22:03,689 --> 00:22:05,190
I saw some weird strings
formatted in there,

506
00:22:05,190 --> 00:22:07,392
but I don't really know
what the indicators are,

507
00:22:07,392 --> 00:22:10,295
so I wanna extract these
indicators really quickly,

508
00:22:10,295 --> 00:22:12,497
so I can get back
to my investigation.

509
00:22:12,497 --> 00:22:15,334
- Yeah. So now we just run
FLOSS invocation, super easy.

510
00:22:15,334 --> 00:22:19,905
FLOSS, malware, and then
pipe it to whatever you want.

511
00:22:23,108 --> 00:22:27,145
Takes like, on average, I would
say 10 seconds, for example,

512
00:22:27,145 --> 00:22:30,349
to do the identification
of decoding routines

513
00:22:30,349 --> 00:22:32,384
and emulation of those,

514
00:22:32,384 --> 00:22:36,388
and here we see, by default
it outputs all the strings,

515
00:22:37,522 --> 00:22:39,424
all three strings types
that I talked about,

516
00:22:39,424 --> 00:22:42,928
static strings at the top,
can see a little header,

517
00:22:42,928 --> 00:22:44,663
here we see those
are the same strings

518
00:22:44,663 --> 00:22:49,000
we saw with the
strings output earlier,

519
00:22:50,001 --> 00:22:50,936
import table,

520
00:22:55,374 --> 00:22:56,641
same kind of strings here,

521
00:22:59,478 --> 00:23:03,582
then we get to our
UTF-16 strings,

522
00:23:04,950 --> 00:23:09,187
the bottom, nothing useful
or indicators to us,

523
00:23:09,187 --> 00:23:11,188
and then we get
to the good stuff,

524
00:23:11,189 --> 00:23:14,359
so those are actually
FLOSS decoded strings

525
00:23:14,359 --> 00:23:16,794
by decoding routines,

526
00:23:16,795 --> 00:23:20,699
so there's commands
in there, file paths,

527
00:23:20,699 --> 00:23:25,270
you can see there's
some registry keys

528
00:23:25,270 --> 00:23:27,939
that we can go look for
now, another import,

529
00:23:27,939 --> 00:23:29,274
so this malware might be doing

530
00:23:29,274 --> 00:23:33,178
some process injection
kind of thing,

531
00:23:33,178 --> 00:23:35,313
and then we also
see stackstrings,

532
00:23:35,313 --> 00:23:36,815
and those were
actually constructed

533
00:23:36,815 --> 00:23:39,651
of those little four byte
characters that we saw,

534
00:23:39,651 --> 00:23:42,020
that's one approach
the malware can take,

535
00:23:42,020 --> 00:23:44,723
and here we can see
it's probably targeting

536
00:23:44,723 --> 00:23:49,293
Mozilla Firefox profiles
and doing some extracting

537
00:23:50,695 --> 00:23:55,533
the proxy configuration
from Mozilla Firefox setup,

538
00:23:58,637 --> 00:24:00,205
- [Willi] Just about five
minutes to go, just keep going.

539
00:24:00,205 --> 00:24:02,240
- [Moritz] Five
minutes? Okay, yeah,

540
00:24:02,240 --> 00:24:04,009
so can we do the second video?

541
00:24:06,645 --> 00:24:07,879
- [Willi] Let's
move onto slides,

542
00:24:07,879 --> 00:24:09,848
we have a little time
for extra questions.

543
00:24:14,186 --> 00:24:15,187
- [Mortiz] What do we do?

544
00:24:16,621 --> 00:24:17,589
- [Willi] Alright, so here
we are, working through

545
00:24:17,589 --> 00:24:18,790
a second malware sample,

546
00:24:18,790 --> 00:24:20,459
just demonstrating that
it wasn't dumb luck

547
00:24:20,459 --> 00:24:23,795
when we ran our first malware
sample through FLOSS there.

548
00:24:25,197 --> 00:24:26,831
- [Moritz] And this time
we're just running FLOSS

549
00:24:26,832 --> 00:24:30,068
because we don't need to run
strings any more, basically,

550
00:24:30,068 --> 00:24:31,002
we need that tool.

551
00:24:31,002 --> 00:24:32,204
- We've run FLOSS against

552
00:24:32,204 --> 00:24:33,839
something like 250,000
samples right now,

553
00:24:33,839 --> 00:24:36,875
basically every sample
that comes into FireEye,

554
00:24:36,875 --> 00:24:39,344
as an exe, we're extracting
obfuscated strings,

555
00:24:39,344 --> 00:24:40,445
this is worth turning around

556
00:24:40,445 --> 00:24:41,947
right into the
intelligence life cycle,

557
00:24:41,947 --> 00:24:43,215
turning these into indicators

558
00:24:43,215 --> 00:24:44,149
and figuring out
what's happening

559
00:24:44,149 --> 00:24:46,217
in our client environments,

560
00:24:46,218 --> 00:24:48,453
and so I think the big
thing to take away here is

561
00:24:48,453 --> 00:24:49,721
one, this tool is
already out there,

562
00:24:49,721 --> 00:24:52,657
it's free for you to
use, to contribute to,

563
00:24:52,657 --> 00:24:54,759
we have a lot of people already
contributing back to us,

564
00:24:54,759 --> 00:24:57,128
it's a standalone binary
that you can be running

565
00:24:57,128 --> 00:24:58,629
with us right now,
in the same amount

566
00:24:58,630 --> 00:25:00,065
of time that we're running it.

567
00:25:00,065 --> 00:25:02,634
You can be doing in your system,
single standalone binary.

568
00:25:03,802 --> 00:25:05,070
It's like, why wouldn't you run

569
00:25:05,070 --> 00:25:07,272
this in the place of strings?

570
00:25:07,272 --> 00:25:08,572
That's our thought
process behind it,

571
00:25:08,573 --> 00:25:10,976
so I hope we've
convinced you of this,

572
00:25:10,976 --> 00:25:13,311
if not, ask us some
hard questions now,

573
00:25:13,311 --> 00:25:17,482
try to show a crack
in our fortress here,

574
00:25:17,482 --> 00:25:18,583
and we'll convince
you that I think FLOSS

575
00:25:18,583 --> 00:25:20,151
is a really neat tool, so yeah.

576
00:25:21,319 --> 00:25:22,854
What can we do for you
guys, any questions?

577
00:25:22,854 --> 00:25:27,359
- [Moritz] While we look at
some of the decoded strings.

578
00:25:27,359 --> 00:25:30,428
- No? Okay?
- Over here?

579
00:25:30,428 --> 00:25:31,530
- Waiting for the mic.

580
00:25:32,731 --> 00:25:35,166
- [Audience Member] So,
hey, so aside from like,

581
00:25:35,166 --> 00:25:37,569
just spitting out the
strings out decoded,

582
00:25:37,569 --> 00:25:41,206
is there a possibility
to show which function

583
00:25:41,206 --> 00:25:42,206
those strings were decoded from?

584
00:25:42,207 --> 00:25:44,776
So say like, a single-byte XOR.

585
00:25:44,776 --> 00:25:47,212
- Absolutely, so this
tool is useful both

586
00:25:47,212 --> 00:25:48,980
as a reverse engineer,

587
00:25:48,980 --> 00:25:50,815
I would use kind of
an expert mode here,

588
00:25:50,815 --> 00:25:52,417
if you're familiar with
reverse engineering,

589
00:25:52,417 --> 00:25:54,485
that piece of information
is useful to you.

590
00:25:54,486 --> 00:25:57,088
But we also wanted this
tool to be very digestible

591
00:25:57,088 --> 00:25:58,255
by a wide audience.

592
00:25:58,256 --> 00:25:59,724
You know how to use strings?

593
00:25:59,724 --> 00:26:02,460
You don't know about function
offsets within a PE file?

594
00:26:02,460 --> 00:26:03,995
We're gonna output
that you expect,

595
00:26:03,995 --> 00:26:05,764
now we can use on
an investigation,

596
00:26:07,198 --> 00:26:08,733
and so by default we don't
get those function offsets.

597
00:26:08,733 --> 00:26:12,236
But I think if you pass the
flag dash X for expert mode,

598
00:26:12,237 --> 00:26:14,039
it'll give you all the
functions it's identified,

599
00:26:14,039 --> 00:26:16,608
it'll group the strings
by which function

600
00:26:16,608 --> 00:26:18,476
actually did the decoding,

601
00:26:18,476 --> 00:26:20,812
it'll show you where
in the stack delta

602
00:26:20,812 --> 00:26:22,080
the stackstrings were found,

603
00:26:22,080 --> 00:26:24,049
you can markup your radare

604
00:26:24,049 --> 00:26:26,618
or IDA Pro databases
with these strings.

605
00:26:26,618 --> 00:26:28,553
There's a lot you can
already do with this tool.

606
00:26:29,688 --> 00:26:30,522
Yep, we got him.

607
00:26:31,723 --> 00:26:32,890
Up front here, if
you ask it to me,

608
00:26:32,891 --> 00:26:33,892
I'll repeat it to the audience.

609
00:26:33,892 --> 00:26:35,493
- Let's do him.
- Oh, I'm sorry.

610
00:26:36,361 --> 00:26:37,596
I'll cut you off, he can--

611
00:26:37,596 --> 00:26:39,931
- Yeah he, wait for
the microphone and...

612
00:26:39,931 --> 00:26:41,399
- [Audience Member]
Have you made any effort

613
00:26:41,399 --> 00:26:44,636
to either categorize or
catalog any of the encoding

614
00:26:44,636 --> 00:26:46,671
and decoding routines
you've been seeing?

615
00:26:49,941 --> 00:26:52,210
- I thought about
that, doing that first,

616
00:26:52,210 --> 00:26:54,312
but then, as we
already mentioned,

617
00:26:54,312 --> 00:26:56,313
there's so many
things you could do

618
00:26:57,949 --> 00:27:01,353
with this emulation
process we figured out,

619
00:27:01,353 --> 00:27:04,055
I think it's much
more, yeah, yeah,

620
00:27:04,055 --> 00:27:05,423
it's much, like, yeah.

621
00:27:06,591 --> 00:27:08,059
- And one thing that's
kinda neat about the way

622
00:27:08,059 --> 00:27:09,961
we approached this, is
using these heuristics,

623
00:27:09,961 --> 00:27:12,564
we actually have
exactly zero signatures

624
00:27:12,564 --> 00:27:15,967
for known routines
like RC4, or Base64,

625
00:27:15,967 --> 00:27:18,336
like the Base64 alphabet
is nowhere in our binary.

626
00:27:18,336 --> 00:27:20,805
We don't depend on
specific implementations.

627
00:27:20,805 --> 00:27:22,340
We're just able to
guess which function

628
00:27:22,340 --> 00:27:25,677
is most interesting and kind
of reason about it from there.

629
00:27:25,677 --> 00:27:27,411
Alright, let's
come back this way.

630
00:27:27,412 --> 00:27:29,614
- [Audience Member] If the
strings that are in the binary

631
00:27:29,614 --> 00:27:32,350
contain things like Chinese
characters and whatnot,

632
00:27:32,350 --> 00:27:34,084
does it render those properly?

633
00:27:34,085 --> 00:27:35,720
- We would have a hard
time differentiating that,

634
00:27:35,720 --> 00:27:40,558
from binary data, I
think that strings.exe

635
00:27:40,558 --> 00:27:42,827
also probably has
that same issue.

636
00:27:42,827 --> 00:27:45,597
So without more outside context,

637
00:27:45,597 --> 00:27:47,532
to configure the tool
in the right way,

638
00:27:47,532 --> 00:27:49,668
we would have a hard time
extracting that information.

639
00:27:49,668 --> 00:27:50,968
Good question though, thanks.

640
00:27:52,137 --> 00:27:53,038
- I think that's
about all the time

641
00:27:53,038 --> 00:27:54,272
we've got for questions,

642
00:27:54,272 --> 00:27:55,807
guys I really really
appreciate you coming

643
00:27:55,807 --> 00:27:57,175
out and presenting here.

644
00:27:57,175 --> 00:27:59,043
Awesome tool, great
contribution to the community.

645
00:27:59,044 --> 00:28:00,545
- Thank you.
- Thank you sir.

646
00:28:00,545 --> 00:28:02,681
(applause)

647
00:28:02,681 --> 00:28:05,583
(undulating music)

