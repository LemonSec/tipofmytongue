1
00:00:00,867 --> 00:00:03,570
(bright musical flourish)

2
00:00:10,010 --> 00:00:12,445
(audience applauds)

3
00:00:12,445 --> 00:00:13,380
- As indicated, we're
gonna be talking

4
00:00:13,380 --> 00:00:14,647
a little bit about signatures.

5
00:00:14,647 --> 00:00:16,750
So there's been a lot of
talk for a lot of years

6
00:00:16,750 --> 00:00:18,184
about how signatures are dead.

7
00:00:18,184 --> 00:00:19,719
It seems like every year,
I hear somebody else

8
00:00:19,719 --> 00:00:21,488
coming out and saying,
you know, this is dead.

9
00:00:21,488 --> 00:00:22,956
We need these other things.

10
00:00:22,956 --> 00:00:25,825
And they're kind of right,
but at the same time,

11
00:00:25,825 --> 00:00:28,395
I don't think we should be
abandoning all of these concepts

12
00:00:28,395 --> 00:00:30,195
altogether, so we're
gonna talk a little bit

13
00:00:30,196 --> 00:00:31,931
about how we think
about these concepts

14
00:00:31,931 --> 00:00:36,936
and where, and how we approach
creating some of these

15
00:00:38,405 --> 00:00:41,174
detections in ways that we
think are still very useful.

16
00:00:41,174 --> 00:00:42,475
So I'm Matthew Dunwoody.

17
00:00:42,475 --> 00:00:44,577
I've been with Mandiant
and subsequently FireEye

18
00:00:44,577 --> 00:00:46,111
for about six years now.

19
00:00:46,112 --> 00:00:47,814
I spend most of that time
doing incident response,

20
00:00:47,814 --> 00:00:50,650
and more recently, doing
applied security research

21
00:00:50,650 --> 00:00:52,751
and some other things
around the company.

22
00:00:52,752 --> 00:00:54,320
- My name is Daniel Bohannon.

23
00:00:54,320 --> 00:00:56,456
This is actually, today is
my third year anniversary

24
00:00:56,456 --> 00:00:58,992
with Mandiant, so, pretty
excited about that.

25
00:00:58,992 --> 00:01:02,327
I'm an applied security
researcher there now.

26
00:01:02,328 --> 00:01:04,464
I previously did
some IR with them,

27
00:01:04,464 --> 00:01:06,099
and I'm obsessed
with obfuscation,

28
00:01:06,099 --> 00:01:09,269
which is fueled by curiosity
and high-octane coffee.

29
00:01:10,403 --> 00:01:12,172
So, what we're gonna
be talking about today,

30
00:01:12,172 --> 00:01:13,807
we're gonna look at
a brief background

31
00:01:13,807 --> 00:01:15,942
in just kind of the
world of detections

32
00:01:15,942 --> 00:01:18,143
in this deeper community,
and then we're gonna go

33
00:01:18,144 --> 00:01:20,547
through three case studies,
and then we're gonna talk

34
00:01:20,547 --> 00:01:22,715
about hunting, some
proactive versus reactive

35
00:01:22,715 --> 00:01:25,752
detection development, and
then some key takeaways.

36
00:01:25,752 --> 00:01:27,119
So first, the background.

37
00:01:28,488 --> 00:01:30,056
In this community, there's
a lot of buzz words.

38
00:01:30,056 --> 00:01:32,358
There's a lot of DFIR speak
that we kind of throw around,

39
00:01:32,358 --> 00:01:36,162
like IoC, signature,
trigger, rule, hunting,

40
00:01:36,162 --> 00:01:37,664
but we have to recognize

41
00:01:37,664 --> 00:01:39,933
that these also contain some
baggage, some good, some bad.

42
00:01:39,933 --> 00:01:42,035
If someone says
signature, then they may

43
00:01:42,035 --> 00:01:44,670
only think A/V signature
versus something else,

44
00:01:44,671 --> 00:01:45,939
or when someone says IoC,

45
00:01:45,939 --> 00:01:48,975
they may think it's only
for historical events.

46
00:01:48,975 --> 00:01:51,811
However, we write IoCs every
day for realtime as well.

47
00:01:51,811 --> 00:01:55,448
And so, I think a really
helpful world is detection,

48
00:01:55,448 --> 00:01:57,550
and I think it's helpful
because it covers

49
00:01:57,550 --> 00:02:00,086
both historical and realtime.

50
00:02:00,086 --> 00:02:01,888
It covers host and
network-based detection,

51
00:02:01,888 --> 00:02:04,524
and it's language agnostic
and tool agnostic.

52
00:02:04,524 --> 00:02:06,493
So the techniques that
we'll be talking about,

53
00:02:06,493 --> 00:02:08,293
you can translate
into whatever tool set

54
00:02:08,294 --> 00:02:11,431
and capabilities that you
have in your organization.

55
00:02:11,431 --> 00:02:13,967
So, what, what is a
signature or a detection,

56
00:02:13,967 --> 00:02:16,469
and more importantly,
what is it not?

57
00:02:16,469 --> 00:02:19,339
Is it MD5s, the file
names, IP addresses,

58
00:02:19,339 --> 00:02:21,508
someone's Twitter handle
in the source code?

59
00:02:21,508 --> 00:02:23,076
Maybe we can do a
little exercise.

60
00:02:23,076 --> 00:02:24,811
Can you spot the bad IoC?

61
00:02:24,811 --> 00:02:26,779
Can you spot the bad signature?

62
00:02:26,779 --> 00:02:28,948
On the left, we
have several MD5's.

63
00:02:28,948 --> 00:02:31,818
On the right, IP
address domain names.

64
00:02:31,818 --> 00:02:33,086
Well, actually, both
of these are horrible,

65
00:02:33,086 --> 00:02:34,654
because they're just
randomly generated.

66
00:02:34,654 --> 00:02:36,789
But I say that to make a point.

67
00:02:36,789 --> 00:02:39,058
Who gets to define what
a good signature is?

68
00:02:39,058 --> 00:02:41,027
Who gets to define
what a bad one is?

69
00:02:41,027 --> 00:02:41,994
Is it a salesperson?

70
00:02:41,995 --> 00:02:43,329
Is it a threat intel feed?

71
00:02:43,329 --> 00:02:44,931
When you receive
information, how do you know

72
00:02:44,931 --> 00:02:47,634
if it's good or bad, and how
do you know where to apply it

73
00:02:47,634 --> 00:02:49,802
and what confidence
to put into it.

74
00:02:49,802 --> 00:02:52,438
So, good signatures
are resilient,

75
00:02:52,438 --> 00:02:53,972
and they're not rigid.

76
00:02:53,973 --> 00:02:56,009
Rigid signatures will break
as soon as the attacker

77
00:02:56,009 --> 00:02:58,945
changes some element
of their TTP.

78
00:02:58,945 --> 00:03:00,914
There are also different
kinds of signatures.

79
00:03:00,914 --> 00:03:02,315
There are very
targeted signatures

80
00:03:02,315 --> 00:03:03,750
from specific toolkits,

81
00:03:03,750 --> 00:03:05,985
but then there's more
methodology-based signatures.

82
00:03:05,985 --> 00:03:09,155
Just as the last talk
was talking about,

83
00:03:09,155 --> 00:03:11,858
the methodology of
a token manipulation

84
00:03:11,858 --> 00:03:14,694
instead of just focusing
on Empire as a framework,

85
00:03:14,694 --> 00:03:17,463
and you can catch that
in many different places.

86
00:03:17,463 --> 00:03:20,366
And also, signatures
and IoCs we use a lot

87
00:03:20,366 --> 00:03:23,903
just simply as data
filters, to just filter down

88
00:03:23,903 --> 00:03:26,406
all this data into a
smaller dataset to then

89
00:03:26,406 --> 00:03:28,575
do additional analysis
like stacking,

90
00:03:28,575 --> 00:03:31,143
least frequency of
occurrence, et cetera.

91
00:03:31,144 --> 00:03:33,346
So, don't learn
from bad signatures,

92
00:03:33,346 --> 00:03:36,115
and the problem is, most
people in our industry

93
00:03:36,115 --> 00:03:38,484
have only received IoCs
or signatures from certain

94
00:03:38,484 --> 00:03:41,020
data sources, and that then
forms their opinion of,

95
00:03:41,020 --> 00:03:42,722
well, this is all
that these things are.

96
00:03:42,722 --> 00:03:44,591
So when people say
signatures are dead

97
00:03:44,591 --> 00:03:47,427
or IoCs are naive, I really
think that's a myopic view,

98
00:03:47,427 --> 00:03:49,362
because maybe they've
only seen bad ones.

99
00:03:49,362 --> 00:03:50,863
And really, we're just limited

100
00:03:50,863 --> 00:03:53,600
by the creativity of
ourselves as defenders.

101
00:03:55,335 --> 00:03:58,605
So, this talk will be
leveraging our experience

102
00:03:58,605 --> 00:04:01,608
at Mandiant and FireEye
of hunting at scale.

103
00:04:01,608 --> 00:04:04,310
A lot of times, we have,
we see really good talks

104
00:04:04,310 --> 00:04:05,845
by really well-respected
researchers,

105
00:04:05,845 --> 00:04:07,780
but sometimes, people will
make statements that just

106
00:04:07,780 --> 00:04:10,717
simply aren't true when you
try to apply it at scale.

107
00:04:10,717 --> 00:04:12,952
However, probably most of
the people in this room

108
00:04:12,952 --> 00:04:15,221
don't have to make signatures
work across hundreds

109
00:04:15,221 --> 00:04:17,724
of client environments like
we do, and so what I would say

110
00:04:17,724 --> 00:04:20,192
is take everything you
hear with a grain of salt

111
00:04:20,192 --> 00:04:21,760
regarding any kind of detection,

112
00:04:21,761 --> 00:04:23,296
ad try it in your environment.

113
00:04:23,296 --> 00:04:25,632
It may be great, it may be
super quiet, or it may be

114
00:04:25,632 --> 00:04:27,700
really noisy, and you
just have to try and see

115
00:04:27,700 --> 00:04:30,370
what works for you and your
team and your environment.

116
00:04:32,105 --> 00:04:34,907
So, detection
walkthrough number one.

117
00:04:34,907 --> 00:04:37,676
Regsvr32, also
known as SquiblyDoo.

118
00:04:37,677 --> 00:04:40,079
Researcher Casey Smith,
who's @subTee on Twitter,

119
00:04:40,079 --> 00:04:42,148
discovered this in 2016
that's a really awesome

120
00:04:42,148 --> 00:04:43,916
application at
whitelisting bypass,

121
00:04:43,916 --> 00:04:46,819
and basically, Regsvr32 is a
native signed Windows binary

122
00:04:46,819 --> 00:04:48,655
that can execute
scriptlet content

123
00:04:48,655 --> 00:04:51,524
out of a remotely-hosted
.SCT file.

124
00:04:51,524 --> 00:04:53,426
And detection
opportunities around this

125
00:04:53,426 --> 00:04:54,961
are kind of in two parts.

126
00:04:54,961 --> 00:04:56,629
So the first case study is
looking at the first part,

127
00:04:56,629 --> 00:04:58,931
which is the execution of
this binary and looking

128
00:04:58,931 --> 00:05:01,567
at command line arguments,
DLL or image load events

129
00:05:01,567 --> 00:05:04,904
as well as network connections
based from this binary,

130
00:05:04,904 --> 00:05:08,274
and then also, you can look
at the .SCT contents itself,

131
00:05:08,274 --> 00:05:10,276
both on the wire
as well as on disk,

132
00:05:10,276 --> 00:05:12,712
and that'll be the second
walkthrough that we'll cover.

133
00:05:12,712 --> 00:05:14,781
But basically, this is
kind of the plain Jane

134
00:05:14,781 --> 00:05:18,017
proof of concept that, that
Casey originally released.

135
00:05:18,017 --> 00:05:20,520
We have the .SCT
scriptlet file on the left

136
00:05:20,520 --> 00:05:22,287
and then the Regsvr
command on the right.

137
00:05:22,288 --> 00:05:27,293
So, as a defender, we may have
a sample detection like this.

138
00:05:28,695 --> 00:05:30,195
Now, this is the most
basic example, and I think

139
00:05:30,196 --> 00:05:32,031
it's really important to
challenge our assumptions

140
00:05:32,031 --> 00:05:34,400
of what you can do when
you're writing detections.

141
00:05:34,400 --> 00:05:37,070
There's been a lot of, a
ton of work in the past year

142
00:05:37,070 --> 00:05:39,205
with like, automated,
like, Red Team frameworks

143
00:05:39,205 --> 00:05:40,772
and atomic testing
and stuff like that,

144
00:05:40,773 --> 00:05:42,542
and I think it's really
important to recognize

145
00:05:42,542 --> 00:05:45,277
what that can tell you and
what it cannot tell you,

146
00:05:45,278 --> 00:05:48,548
because typically, they're
using very simplified examples.

147
00:05:48,548 --> 00:05:50,616
So, if you feel like
the simplified example

148
00:05:50,616 --> 00:05:53,453
in a testing framework says
you can detect SquiblyDoo,

149
00:05:54,754 --> 00:05:56,356
well, would that
actually possibly give us

150
00:05:56,356 --> 00:05:58,558
as defenders a false
sense of confidence,

151
00:05:58,558 --> 00:06:00,727
if it's a very
simplistic detection?

152
00:06:00,727 --> 00:06:02,128
So that's why it's important
to go deeper and say,

153
00:06:02,128 --> 00:06:04,364
can I break this
detection, and if I can,

154
00:06:04,364 --> 00:06:06,566
then I need to make the
detection more resilient

155
00:06:06,566 --> 00:06:09,568
so it can catch when an attacker
is modifying the command.

156
00:06:09,569 --> 00:06:10,803
So, let's do that.

157
00:06:10,803 --> 00:06:14,107
The attacker command is
on the top in the box,

158
00:06:14,107 --> 00:06:15,541
and on the bottom,
we have four strings

159
00:06:15,541 --> 00:06:17,009
that, if these are
in the arguments,

160
00:06:17,009 --> 00:06:19,479
then this will catch this
sample of SquiblyDoo.

161
00:06:19,479 --> 00:06:20,712
However, we can
start to change it.

162
00:06:20,713 --> 00:06:22,782
As an attacker, we could
change forward slashes

163
00:06:22,782 --> 00:06:25,618
to backward slashes,
or we could use HTTPS

164
00:06:25,618 --> 00:06:30,056
instead of HTTP or FTP or
UNC path or local file,

165
00:06:30,056 --> 00:06:33,693
and so when we do that
/i:http, maybe we need

166
00:06:33,693 --> 00:06:35,260
to actually make that
a little more robust,

167
00:06:35,261 --> 00:06:37,063
either with or
logic, you know, IoC,

168
00:06:37,063 --> 00:06:38,598
or the more complicated regex.

169
00:06:40,032 --> 00:06:41,933
/s /n /u.

170
00:06:41,934 --> 00:06:43,636
What are these arguments?

171
00:06:43,636 --> 00:06:45,104
Do they have to
be in that order?

172
00:06:45,104 --> 00:06:47,272
No, you can swap 'em around.

173
00:06:47,273 --> 00:06:48,808
So maybe we should look
for those individually,

174
00:06:48,808 --> 00:06:50,543
not collectively together.

175
00:06:50,543 --> 00:06:52,612
You can also move the
order all over the command,

176
00:06:52,612 --> 00:06:53,546
and it still works.

177
00:06:53,546 --> 00:06:54,781
So if you're doing regexes,

178
00:06:54,781 --> 00:06:56,682
then the order really
doesn't matter.

179
00:06:56,682 --> 00:06:59,619
And it's important to know,
what are these arguments anyway?

180
00:06:59,619 --> 00:07:01,220
If the POC says it's here,

181
00:07:01,220 --> 00:07:04,557
then surely, it has to
be there to work, right?

182
00:07:04,557 --> 00:07:05,758
Maybe not.

183
00:07:05,758 --> 00:07:07,159
So why don't we look
at the man page?

184
00:07:07,160 --> 00:07:10,730
Well, it says that /n
actually must be used with /i.

185
00:07:10,730 --> 00:07:12,965
Lies; remove it,
and it still works.

186
00:07:12,965 --> 00:07:15,234
All right, if /n doesn't
have to be there,

187
00:07:15,234 --> 00:07:17,637
then I don't want my detection
to assume it has to be there,

188
00:07:17,637 --> 00:07:20,072
so I'm pulling that
out of my detection.

189
00:07:20,072 --> 00:07:23,676
Now, if we keep going,
also, a lot of detections

190
00:07:23,676 --> 00:07:28,681
look for /u, /s, /i; however,
any time you see a slash,

191
00:07:28,681 --> 00:07:30,349
you should try
changing it to a dash,

192
00:07:30,349 --> 00:07:31,818
and you know what,
it still works.

193
00:07:31,818 --> 00:07:33,619
The inverse is
typically always true.

194
00:07:33,619 --> 00:07:36,088
PowerShell and TAC
EncodedCommand can be swapped

195
00:07:36,088 --> 00:07:37,590
with a slash and coded command.

196
00:07:37,590 --> 00:07:38,857
So whenever I'm
writing detections

197
00:07:38,858 --> 00:07:40,092
and I see these characters,

198
00:07:40,092 --> 00:07:41,693
I'll swap the out and
see, does it still work?

199
00:07:41,694 --> 00:07:44,664
Okay, I need to factor
that into my detection.

200
00:07:46,098 --> 00:07:47,467
There's also a lot of
file extensions here,

201
00:07:47,467 --> 00:07:49,534
.exe, .sct, .dll.

202
00:07:49,535 --> 00:07:52,004
You can remove every single one
of those and it still works.

203
00:07:52,004 --> 00:07:56,108
So how many detections say
scrobj.dll has to be there?

204
00:07:56,108 --> 00:07:58,010
Well, this would evade that.

205
00:07:58,010 --> 00:07:58,844
Let's keep going.

206
00:07:58,845 --> 00:08:00,780
Regsvr and scrobj.

207
00:08:00,780 --> 00:08:03,049
Attackers really love to
copy things and rename them.

208
00:08:03,049 --> 00:08:05,183
So what if they rename
Regsvr32 to casey.exe

209
00:08:05,184 --> 00:08:08,287
and scrobj.dll to smith.dll?

210
00:08:08,287 --> 00:08:10,989
And then they could call
casey smith, SquiblyDoo.

211
00:08:10,990 --> 00:08:12,258
Would you detect that?

212
00:08:12,258 --> 00:08:14,060
Does your detection
say the process name

213
00:08:14,060 --> 00:08:17,296
has to be a Regsvr32, and if so,

214
00:08:17,296 --> 00:08:18,498
this will be evaded.

215
00:08:18,498 --> 00:08:21,067
So is your, is your
detection strong enough

216
00:08:21,067 --> 00:08:22,535
that it can stand
only on the arguments

217
00:08:22,535 --> 00:08:25,238
and not care what
the process name is?

218
00:08:26,806 --> 00:08:29,207
If we keep going, /u, /s.

219
00:08:29,208 --> 00:08:30,543
I actually discovered
this last week

220
00:08:30,543 --> 00:08:32,578
as I was finalizing
these slides.

221
00:08:32,578 --> 00:08:35,448
After tac/u, you can put
anything you want almost,

222
00:08:35,448 --> 00:08:38,183
and it still works;
/s, same thing.

223
00:08:38,183 --> 00:08:39,784
So, whenever you
see an argument,

224
00:08:39,784 --> 00:08:41,687
does the white space
have to follow it?

225
00:08:41,687 --> 00:08:43,121
Maybe not.

226
00:08:43,121 --> 00:08:45,358
Maybe you can put almost
anything else in front of it.

227
00:08:45,358 --> 00:08:47,660
In addition, you can
start to put double quotes

228
00:08:47,660 --> 00:08:49,161
or sometimes carets.

229
00:08:49,161 --> 00:08:50,595
Regsvr doesn't like carets,
but you can use double quotes

230
00:08:50,596 --> 00:08:52,899
and pass them down
from parent processes

231
00:08:52,899 --> 00:08:55,434
and start to break
up the /u or the -u.

232
00:08:55,434 --> 00:08:56,968
So now there's a
double quote in there,

233
00:08:56,969 --> 00:08:58,571
and this persists into the
live process command line

234
00:08:58,571 --> 00:09:01,040
arguments as well as
evidence like 4688

235
00:09:01,040 --> 00:09:03,910
in the security
log or SysMon logs.

236
00:09:04,877 --> 00:09:07,146
So, when will the madness stop?

237
00:09:07,146 --> 00:09:09,814
This is horrifying from
a defender's perspective.

238
00:09:09,815 --> 00:09:11,784
How in the world are
you supposed to like,

239
00:09:11,784 --> 00:09:13,553
there's gotta be some
magic regex or something

240
00:09:13,553 --> 00:09:14,487
that'll catch all this stuff.

241
00:09:14,487 --> 00:09:16,255
So how do we deal with this?

242
00:09:16,255 --> 00:09:18,858
Well, there's not
really a magic regex,

243
00:09:18,858 --> 00:09:21,060
and honestly, this is how
we approach these problems,

244
00:09:21,060 --> 00:09:22,661
from several different angles.

245
00:09:22,662 --> 00:09:25,064
We have one detection that
is looking for arguments

246
00:09:25,064 --> 00:09:28,199
without file rename,
without obfuscation.

247
00:09:28,200 --> 00:09:30,169
Then we have a completely
separate angle that is looking

248
00:09:30,169 --> 00:09:32,471
for these arguments that
are potentially obfuscated.

249
00:09:32,471 --> 00:09:35,107
And then file renames
or DLL renames

250
00:09:35,107 --> 00:09:38,077
handle that in a completely
separate detection.

251
00:09:38,077 --> 00:09:40,012
Other things you can also
factor in are saying,

252
00:09:40,012 --> 00:09:41,881
okay, maybe there's some
way that the arguments

253
00:09:41,881 --> 00:09:43,683
can be obfuscated that
I don't know about,

254
00:09:43,683 --> 00:09:47,319
so let me just look for Regsvr
making network connections,

255
00:09:47,320 --> 00:09:51,424
or loading JScript or a
VBScript DLL or wshom.ocx,

256
00:09:51,424 --> 00:09:53,893
or maybe also, for all
these things, we also look

257
00:09:53,893 --> 00:09:56,429
for these command line arguments
being passed over the wire.

258
00:09:56,429 --> 00:09:57,829
A Snort signature
looking for this stuff

259
00:09:57,830 --> 00:10:00,533
will catch this like a
payload being downloaded

260
00:10:00,533 --> 00:10:02,602
over HTTP that will
then launch Regsvr,

261
00:10:02,602 --> 00:10:04,337
or maybe an attacker
is moving laterally

262
00:10:04,337 --> 00:10:07,872
by pushing this argument
over SNB, over as an app job,

263
00:10:07,873 --> 00:10:09,675
or maybe wmic
process call create.

264
00:10:09,675 --> 00:10:11,644
There's tons of
things you can catch.

265
00:10:11,644 --> 00:10:13,546
There's tons of host-based
artifacts you can catch

266
00:10:13,546 --> 00:10:14,947
being pushed over the wire.

267
00:10:16,349 --> 00:10:18,217
So, walk through number two.

268
00:10:18,217 --> 00:10:20,519
We covered the process
execution part,

269
00:10:20,519 --> 00:10:22,254
but what about the scriptlet?

270
00:10:22,254 --> 00:10:23,723
Well, when we see
things like this,

271
00:10:23,723 --> 00:10:26,891
I always like to ask myself,
what's there by default?

272
00:10:26,892 --> 00:10:28,928
Like, when someone just
copies and pastes something

273
00:10:28,928 --> 00:10:32,965
off of Casey Smith's
Gist, then what,

274
00:10:32,965 --> 00:10:36,068
what might they not
change, the lazy hacker?

275
00:10:36,068 --> 00:10:38,404
Well, there's a lot of
things in here that people

276
00:10:38,404 --> 00:10:40,840
don't change, and I like
to look for those things,

277
00:10:40,840 --> 00:10:43,743
because if they don't change
that class ID, then I wanna

278
00:10:43,743 --> 00:10:47,813
know about it, 'cause
0000FEEDACDC is
not a normal thing,

279
00:10:47,813 --> 00:10:50,783
and if someone doesn't change
that, I still wanna find it.

280
00:10:50,783 --> 00:10:52,818
The next thing I'll do
is say, what is required?

281
00:10:52,818 --> 00:10:55,788
What's the ground truth, the
lowest common denominator,

282
00:10:55,788 --> 00:10:59,492
in this payload that you
need to have for it to work?

283
00:10:59,492 --> 00:11:01,861
So, all these things
highlighted in yellow,

284
00:11:01,861 --> 00:11:04,497
you can just remove
them, and it still works.

285
00:11:04,497 --> 00:11:07,400
So, keep systematically
removing things and seeing,

286
00:11:07,400 --> 00:11:09,268
is this required,
and if it's not,

287
00:11:09,268 --> 00:11:10,970
I don't want it in my detection.

288
00:11:12,505 --> 00:11:14,006
What can you change?

289
00:11:14,006 --> 00:11:15,741
How can I finagle
some things here?

290
00:11:15,741 --> 00:11:18,044
Well, double quotes can be
changed to single quotes.

291
00:11:18,044 --> 00:11:20,312
As I said earlier, this
class ID can be changed,

292
00:11:20,312 --> 00:11:22,915
so you can systematically
change it to FDBO, FDBO,

293
00:11:22,915 --> 00:11:25,016
a lot of those, and then
EFFFFFFFFDBO, like that,

294
00:11:25,017 --> 00:11:26,719
and ACDC's not there anymore.

295
00:11:26,719 --> 00:11:30,056
So, does that mean we should
never look for FEEDACDC?

296
00:11:30,056 --> 00:11:30,990
Not necessarily.

297
00:11:30,990 --> 00:11:32,224
It just means we shouldn't put

298
00:11:32,224 --> 00:11:33,959
all of our eggs in
that one basket.

299
00:11:33,959 --> 00:11:35,994
If we keep going,
the scriptlet tags

300
00:11:35,995 --> 00:11:38,297
can actually be changed
to component tags,

301
00:11:38,297 --> 00:11:39,932
and the language, JScript.

302
00:11:39,932 --> 00:11:42,301
Well, you could also
define that to be VBScript,

303
00:11:42,301 --> 00:11:45,771
or JScript.Encode or
VBScript.Encode with
an example there,

304
00:11:45,771 --> 00:11:47,973
and fun fact, the .Encodes
actually start and end

305
00:11:47,973 --> 00:11:50,209
with those highlighted
green portions.

306
00:11:50,209 --> 00:11:53,045
So maybe that's interesting
to look for being downloaded

307
00:11:53,045 --> 00:11:55,580
or being stored in registry
or something like that.

308
00:11:55,581 --> 00:11:56,916
And if you don't like
any of these options,

309
00:11:56,916 --> 00:11:58,751
you can just completely
not define a language,

310
00:11:58,751 --> 00:12:00,619
because the default
is gonna be JScript.

311
00:12:00,619 --> 00:12:02,455
How cool is that?

312
00:12:02,455 --> 00:12:03,656
So let's remove that.

313
00:12:03,656 --> 00:12:04,857
You can also add
tons of white space

314
00:12:04,857 --> 00:12:07,026
before the closing bracket.

315
00:12:07,026 --> 00:12:09,829
Then if you want to, you can
actually do language-specific

316
00:12:09,829 --> 00:12:13,132
obfuscation inside of
.SCT-specific obfuscation

317
00:12:13,132 --> 00:12:14,800
and put white space
into a lot of places.

318
00:12:14,800 --> 00:12:17,303
So if you have detections
that look for like, (.run),

319
00:12:18,671 --> 00:12:20,473
you can totally shove white
space in between every

320
00:12:20,473 --> 00:12:22,907
single one of those pieces,
and it'll still work.

321
00:12:24,610 --> 00:12:26,112
Then you can also
remove new lines

322
00:12:26,112 --> 00:12:27,613
and just smash the whole
thing together like this,

323
00:12:27,613 --> 00:12:29,915
and this is still a
valid scriptlet file.

324
00:12:31,250 --> 00:12:33,319
So, what is our
approach to this?

325
00:12:33,319 --> 00:12:35,020
Well, it's important to
think about detecting this

326
00:12:35,020 --> 00:12:37,256
as it's being transferred
over the wire,

327
00:12:37,256 --> 00:12:38,757
as well as on the endpoint.

328
00:12:38,758 --> 00:12:40,626
So Yara rules are really
great for finding examples

329
00:12:40,626 --> 00:12:43,395
of .SCT files in public
repositories, but also,

330
00:12:43,395 --> 00:12:46,598
if it's being downloaded with
Regsvr32, it's gonna land

331
00:12:46,599 --> 00:12:49,168
on this in Temporary
Internet Files or INetCache.

332
00:12:49,168 --> 00:12:50,636
So are we looking
for it there as well?

333
00:12:50,636 --> 00:12:53,572
It's a super awesome data
source for a lot of these files

334
00:12:53,572 --> 00:12:55,307
downloaders that
actually hit disk.

335
00:12:57,810 --> 00:13:01,113
So, again, the magic
regex, I mean, maybe,

336
00:13:01,113 --> 00:13:03,616
but we like to have several
different pieces of detection

337
00:13:03,616 --> 00:13:06,685
so we can see it being detected
in several different ways

338
00:13:06,685 --> 00:13:09,622
to have a more resilient
overall approach.

339
00:13:09,622 --> 00:13:12,391
So, we tackle this by
looking at .SCT files

340
00:13:12,391 --> 00:13:14,392
without any
obfuscation considered.

341
00:13:14,393 --> 00:13:17,630
We looked at it then with
obfuscation considered.

342
00:13:17,630 --> 00:13:19,064
We have the default string one.

343
00:13:19,064 --> 00:13:21,901
Again, if FEEDACDC is there,
I wanna know about it,

344
00:13:21,901 --> 00:13:23,835
'cause it's likely a pen tester,

345
00:13:23,836 --> 00:13:26,605
but some hackers
leave it in there.

346
00:13:26,605 --> 00:13:29,241
Also, I'll do kind of the
inverse and say, okay,

347
00:13:29,241 --> 00:13:32,111
what's the thing that has
to be in a scriptlet file?

348
00:13:32,111 --> 00:13:34,847
If I make the assumption
that registration string has

349
00:13:34,847 --> 00:13:37,917
to be there, maybe I'll look
for a registration string,

350
00:13:37,917 --> 00:13:40,953
but the absence of any other
thing that I know about.

351
00:13:40,953 --> 00:13:43,122
And this kind of reverse
approach is a really great way

352
00:13:43,122 --> 00:13:46,192
to start to find, like,
crazy obfuscation innovation

353
00:13:46,192 --> 00:13:47,827
that we didn't even know
was possible, by looking

354
00:13:47,827 --> 00:13:51,096
for the absence of things
that you think would be there.

355
00:13:51,096 --> 00:13:53,732
And then also, we'll write
completely separate detections

356
00:13:53,732 --> 00:13:56,068
based just on the
content of the .SCT file.

357
00:13:56,068 --> 00:13:57,569
Now, this is a little
more targeted approach.

358
00:13:57,570 --> 00:13:59,672
So if you look at things
like .NET to JScript,

359
00:13:59,672 --> 00:14:01,507
lemme go and search through
GitHub and find examples

360
00:14:01,507 --> 00:14:04,476
of projects that pump this
code out, and let me look

361
00:14:04,476 --> 00:14:06,512
just for that syntax,
regardless of if it's wrapped

362
00:14:06,512 --> 00:14:09,714
in an .SCT or a scriptlet
file or anything else.

363
00:14:12,685 --> 00:14:14,152
- Okay.

364
00:14:14,153 --> 00:14:15,888
So if you thought that
was an unnecessary amount

365
00:14:15,888 --> 00:14:18,324
of manipulating those
things, go check out like,

366
00:14:18,324 --> 00:14:20,626
Nick Carr's daily scriptlets
and see all the variations

367
00:14:20,626 --> 00:14:22,093
we're actually
seeing in the wild.

368
00:14:22,094 --> 00:14:24,396
These are absolutely things
that attackers figure out, too.

369
00:14:24,396 --> 00:14:27,165
So if your solutions aren't
addressing these things,

370
00:14:27,166 --> 00:14:28,467
that's gonna be a
problem in the future.

371
00:14:28,467 --> 00:14:30,236
So I'm gonna go through
and talk a little bit

372
00:14:30,236 --> 00:14:32,338
about how to do this same kind
of approach with binaries.

373
00:14:32,338 --> 00:14:34,772
Unfortunately, we don't
have enough time for me

374
00:14:34,773 --> 00:14:36,041
to do the same
level of walkthrough

375
00:14:36,041 --> 00:14:38,377
that Bohannon did for
that, but we're gonna

376
00:14:38,377 --> 00:14:40,411
talk through some of kind
of the methodology here.

377
00:14:40,412 --> 00:14:41,714
So why binaries?

378
00:14:41,714 --> 00:14:43,249
As much conversation
as there's been

379
00:14:43,249 --> 00:14:45,417
about in-memory attacks, and
that is absolutely a thing,

380
00:14:45,417 --> 00:14:48,020
attackers are still
absolutely using binaries,

381
00:14:48,020 --> 00:14:50,322
large numbers of binaries,
including top-tier attackers

382
00:14:50,322 --> 00:14:52,458
like Turla and APT29 and others.

383
00:14:52,458 --> 00:14:55,427
So, you know, knowing that
there's a lot of binaries

384
00:14:55,427 --> 00:14:57,029
out there, it's important to
be able to deal with them,

385
00:14:57,029 --> 00:14:59,231
and malware changes frequently.

386
00:14:59,231 --> 00:15:01,367
You know, as indicated
earlier, you know,

387
00:15:01,367 --> 00:15:03,301
if a cron job's changing your
malware every 10 minutes,

388
00:15:03,302 --> 00:15:04,870
I mean, that's
gonna be a problem.

389
00:15:04,870 --> 00:15:05,905
There's a lot of polymorphism.

390
00:15:05,905 --> 00:15:07,439
There's a lot of builders.

391
00:15:07,439 --> 00:15:10,041
You know, I can count on one
hand the number of MD5 hits

392
00:15:10,042 --> 00:15:13,178
I've seen in live investigations
in the past three years.

393
00:15:13,178 --> 00:15:15,547
I mean, it's just
not a thing anymore.

394
00:15:15,547 --> 00:15:17,016
You can't always rely on AV.

395
00:15:17,016 --> 00:15:19,517
AV's a great thing, but a
lot of times, it lags behind,

396
00:15:19,518 --> 00:15:21,287
and it's also very
easy to test against.

397
00:15:21,287 --> 00:15:23,088
We see attackers all the
time uploading binaries

398
00:15:23,088 --> 00:15:24,924
and checking them against
VirusTotal to see,

399
00:15:24,924 --> 00:15:26,891
you know, are there
sigs out there for this,

400
00:15:26,892 --> 00:15:28,227
and if there aren't, they'll
just keep tweaking it

401
00:15:28,227 --> 00:15:30,396
until they don't get detections.

402
00:15:30,396 --> 00:15:32,497
And you can't always
submit malware to vendors.

403
00:15:32,498 --> 00:15:34,733
I mean, this is definitely
true as an IR consultant.

404
00:15:34,733 --> 00:15:36,367
I can't always just
take stuff that I find

405
00:15:36,368 --> 00:15:37,970
in some customers' environments
and start giving it

406
00:15:37,970 --> 00:15:39,438
to people, 'cause it
could contain sensitive

407
00:15:39,438 --> 00:15:43,074
information that we don't
necessarily want to give out.

408
00:15:43,075 --> 00:15:45,544
ML is great, but it does
depend on the models,

409
00:15:45,544 --> 00:15:47,713
and it depends on the dataset
that it's trained against.

410
00:15:47,713 --> 00:15:49,048
Generally speaking,
there's gonna be a lag

411
00:15:49,048 --> 00:15:50,883
between when those
models are trained

412
00:15:50,883 --> 00:15:52,918
and when they're retrained,
and there's going to be things

413
00:15:52,918 --> 00:15:54,186
that pop up during
that timeframe

414
00:15:54,186 --> 00:15:56,121
that that ML's just
not going to detect,

415
00:15:56,121 --> 00:15:59,625
because it hasn't seen anything
close enough to that before.

416
00:15:59,625 --> 00:16:01,327
It's also great for
validating the effectiveness

417
00:16:01,327 --> 00:16:02,828
of our existing detection.

418
00:16:02,828 --> 00:16:04,029
So, from going through and
collecting up these samples

419
00:16:04,029 --> 00:16:06,031
that I'm gonna talk
about, we can validate,

420
00:16:06,031 --> 00:16:09,267
do my detection
engines that exist now

421
00:16:09,268 --> 00:16:11,170
at least detect the
things that I know about?

422
00:16:11,170 --> 00:16:13,271
And also, intelligence
gathering, for example,

423
00:16:13,272 --> 00:16:14,540
running through VT retrohunt

424
00:16:14,540 --> 00:16:16,074
and doing other things like that

425
00:16:16,075 --> 00:16:18,077
to collect samples and see
where they're coming from.

426
00:16:18,077 --> 00:16:19,912
So, when am I gonna do this?

427
00:16:19,912 --> 00:16:22,815
I'm gonna do this when existing
detections and protections

428
00:16:22,815 --> 00:16:26,652
are ineffective, and when
there's an active intrusion,

429
00:16:26,652 --> 00:16:29,521
a high-priority threat, or a
prolific or publicly-available

430
00:16:29,521 --> 00:16:31,357
malware that I know
is going to pop up.

431
00:16:31,357 --> 00:16:32,658
I don't wanna do
this for every piece

432
00:16:32,658 --> 00:16:33,592
of malware that's out there.

433
00:16:33,592 --> 00:16:34,526
I wanna let the commodity

434
00:16:34,526 --> 00:16:36,428
kind of get handled by that AV.

435
00:16:36,428 --> 00:16:38,497
If it's not a high priority,
I'm not gonna invest the time.

436
00:16:38,497 --> 00:16:40,866
But there are certain things
where I need to make sure

437
00:16:40,866 --> 00:16:43,002
that I'm getting
effective detection.

438
00:16:43,002 --> 00:16:44,936
Also, when I need additional
context beyond it's bad.

439
00:16:44,937 --> 00:16:46,472
So one of the biggest
challenges with ML

440
00:16:46,472 --> 00:16:48,007
is it's gonna give you a score.

441
00:16:48,007 --> 00:16:49,742
It's gonna tell you,
this is a bad binary,

442
00:16:49,742 --> 00:16:51,175
but it's not gonna give
you any more context

443
00:16:51,176 --> 00:16:54,947
as to what it is or
how bad it really is.

444
00:16:54,947 --> 00:16:56,448
Like, is it targeted?

445
00:16:56,448 --> 00:16:58,183
Is this something that a
human operator is running?

446
00:16:58,183 --> 00:17:00,319
You're not generally gonna
get that kind of context

447
00:17:00,319 --> 00:17:01,819
out of something like ML.

448
00:17:01,820 --> 00:17:03,989
And also, for the intelligence
gathering and tagging

449
00:17:03,989 --> 00:17:06,892
capabilities you can get via
having actual signatures.

450
00:17:07,760 --> 00:17:09,194
So, first thing I'm gonna define

451
00:17:09,194 --> 00:17:10,995
is what I even want to find.

452
00:17:10,996 --> 00:17:14,066
So, you know, for instance,
all Chopstick malware variants,

453
00:17:14,066 --> 00:17:17,603
or all, you know, samples of
this new publicly-available

454
00:17:17,603 --> 00:17:21,106
backdoor that, you know,
is up on GitHub today.

455
00:17:21,973 --> 00:17:23,442
Where do I wanna find it?

456
00:17:23,442 --> 00:17:26,078
You know, on the endpoint,
on the network, in sandboxes,

457
00:17:26,078 --> 00:17:29,381
you know, where do I actually
want to acquire this data?

458
00:17:29,381 --> 00:17:31,050
What signature
formats are supported?

459
00:17:31,050 --> 00:17:32,251
You know, do you have OpenIOC?

460
00:17:32,251 --> 00:17:33,452
Do you have Yara?

461
00:17:33,452 --> 00:17:34,720
If you have Yara, do
you have the PE module?

462
00:17:34,720 --> 00:17:36,688
I really like the PE
module, personally.

463
00:17:36,688 --> 00:17:38,290
And what's your false
positive tolerance?

464
00:17:38,290 --> 00:17:39,758
So it's really
important to always,

465
00:17:39,758 --> 00:17:41,226
with any of these kind
of detection development,

466
00:17:41,226 --> 00:17:42,795
is to know what your false
positive tolerance is.

467
00:17:42,795 --> 00:17:45,097
So on an IR, I'm
much more tolerant

468
00:17:45,097 --> 00:17:46,899
of false positives than
I am of false negatives.

469
00:17:46,899 --> 00:17:49,501
I will accept a large
number of false positives.

470
00:17:49,501 --> 00:17:52,204
In a static monitoring
environment, I'm less tolerant.

471
00:17:54,106 --> 00:17:56,909
So, the first step I'm gonna
do is just collect data.

472
00:17:56,909 --> 00:17:59,378
So I have the unfair advantage
of working at FireEye

473
00:17:59,378 --> 00:18:01,647
where we have a ton of
original source data

474
00:18:01,647 --> 00:18:03,115
that we get off of intrusions,

475
00:18:03,115 --> 00:18:05,851
that we get off of tools,
but even without that,

476
00:18:05,851 --> 00:18:09,221
it's still very possible to
go out there and get samples

477
00:18:09,221 --> 00:18:10,656
from high-confidence
data sources.

478
00:18:10,656 --> 00:18:13,792
So going out and finding
threat intel feeds,

479
00:18:13,792 --> 00:18:16,562
blogs, public malware repos,
malware analysis reports

480
00:18:16,562 --> 00:18:19,430
for the specific type of
malware that you're looking for,

481
00:18:19,431 --> 00:18:21,467
collect up those hashes.

482
00:18:21,467 --> 00:18:24,903
The attack framework references
can be really good for this.

483
00:18:24,903 --> 00:18:26,505
Go back and see the
original reports

484
00:18:26,505 --> 00:18:28,507
and collect data up out of them.

485
00:18:28,507 --> 00:18:29,975
Go back to VT Intelligence.

486
00:18:29,975 --> 00:18:31,376
If you have a VT
Intelligence account,

487
00:18:31,376 --> 00:18:32,845
this is extremely handy.

488
00:18:32,845 --> 00:18:34,780
You can search for things like
the actual signature name.

489
00:18:34,780 --> 00:18:37,883
So, if a specific AV engine
that you trust more than others

490
00:18:37,883 --> 00:18:39,585
is detecting it as a
given signature name,

491
00:18:39,585 --> 00:18:41,987
you can pivot around and
find other samples that way.

492
00:18:41,987 --> 00:18:45,057
You can also pull down the
actual binaries from there.

493
00:18:45,057 --> 00:18:47,292
Implant builders, so, for
any of your public available

494
00:18:47,292 --> 00:18:49,660
malware or if you're able
to find an implant builder

495
00:18:49,661 --> 00:18:51,497
that somebody scooped up
off of a server somewhere,

496
00:18:51,497 --> 00:18:52,898
then you can build your own.

497
00:18:55,134 --> 00:18:57,636
If you do have public malware,
get multiple versions,

498
00:18:57,636 --> 00:18:58,870
get updates.

499
00:18:58,871 --> 00:19:00,038
So, Cobalt Strike
is a great example.

500
00:19:00,038 --> 00:19:01,640
They release updates
all the time.

501
00:19:01,640 --> 00:19:03,041
If you wanna be
able to effectively
detect Cobalt Strike,

502
00:19:03,041 --> 00:19:04,576
you need to be able to
handle more than one

503
00:19:04,576 --> 00:19:06,879
update and variant of
it, and this is true

504
00:19:06,879 --> 00:19:09,947
for basically any
publicly-available framework.

505
00:19:09,948 --> 00:19:12,251
Also, as you're
generating those,

506
00:19:12,251 --> 00:19:13,719
generate multiple samples.

507
00:19:13,719 --> 00:19:15,120
Make sure that you're
hitting all of the options

508
00:19:15,120 --> 00:19:16,522
that are gonna significantly
change the behavior

509
00:19:16,522 --> 00:19:18,689
and structure of the malware,
and use common packers

510
00:19:18,690 --> 00:19:20,492
and obfuscators, because
those are going to affect

511
00:19:20,492 --> 00:19:22,928
how your detections are gonna
work, and if you can find

512
00:19:22,928 --> 00:19:25,464
something both when it's
obfuscated and when it isn't,

513
00:19:25,464 --> 00:19:28,767
I mean, that's a great bonus,
UPX being the kind of most

514
00:19:28,767 --> 00:19:32,070
prolific and easiest to work
with example of packers.

515
00:19:32,070 --> 00:19:34,572
So, first thing I'm gonna do
once I have this kind of corpus

516
00:19:34,573 --> 00:19:36,475
of malware collected up,
'cause I'm gonna test it

517
00:19:36,475 --> 00:19:38,010
against what I already have.

518
00:19:38,010 --> 00:19:40,546
So, you know, using whatever
security tools are available

519
00:19:40,546 --> 00:19:42,681
in a given instance, what
alerts are generated?

520
00:19:42,681 --> 00:19:44,183
What data is provided?

521
00:19:44,183 --> 00:19:46,051
Based on what I'm seeing
out of that, do I even need

522
00:19:46,051 --> 00:19:48,720
to proceed with trying
to build a new detection,

523
00:19:48,720 --> 00:19:51,023
or can I kind of lean on the
stuff that I'm getting for free

524
00:19:51,023 --> 00:19:54,193
based on what's already
available in my environment?

525
00:19:54,193 --> 00:19:55,527
Assuming that I do
need to continue,

526
00:19:55,527 --> 00:19:57,529
I'm going to start
by enumerating data.

527
00:19:57,529 --> 00:20:00,265
So, probably the
easiest way to do this

528
00:20:00,265 --> 00:20:02,034
is collecting dynamic
execution details.

529
00:20:02,034 --> 00:20:04,236
So sandbox reports
are great for this.

530
00:20:04,236 --> 00:20:06,305
You know, Cuckoo
Sandbox is free.

531
00:20:06,305 --> 00:20:08,840
It's not horribly
difficult to set up,

532
00:20:08,840 --> 00:20:11,143
and there's a lot of guidance
out there on how to do that.

533
00:20:11,143 --> 00:20:12,711
So I'm gonna collect
up all these details.

534
00:20:12,711 --> 00:20:14,680
There's a lot of these out there
that are publicly available

535
00:20:14,680 --> 00:20:17,883
as well from some of these
different online sandboxes.

536
00:20:17,883 --> 00:20:21,587
Grab malware reports and
blogs, manual dynamic analysis,

537
00:20:21,587 --> 00:20:25,123
just running my own VMs and
kind of playing with things,

538
00:20:25,123 --> 00:20:26,892
process memory and
strings, pulling those,

539
00:20:26,892 --> 00:20:29,094
that kind of context down.

540
00:20:29,094 --> 00:20:31,964
I'm also gonna parse these
binaries using tools,

541
00:20:31,964 --> 00:20:34,332
parse out the PE details
for Windows binaries,

542
00:20:34,333 --> 00:20:36,668
SigCheck, get all the
digital signatures,

543
00:20:36,668 --> 00:20:38,536
FLOSS or Strings to
get the actual strings

544
00:20:38,537 --> 00:20:42,007
out of the binaries, and also
the vendor analysis engine.

545
00:20:42,007 --> 00:20:44,276
So, one of the things I
really like about the tools

546
00:20:44,276 --> 00:20:46,712
that we use is that I
can actually get them

547
00:20:46,712 --> 00:20:49,348
to parse out the full
data from a sample

548
00:20:49,348 --> 00:20:51,683
that I could potentially
match against and just give me

549
00:20:51,683 --> 00:20:55,687
that data, and then I have the
kind of source ground truth

550
00:20:55,687 --> 00:20:57,389
of what I'm going to be
trying to match against.

551
00:20:57,389 --> 00:20:58,689
So that's very valuable.

552
00:20:58,690 --> 00:21:00,792
If your tool sets will
allow you to do that,

553
00:21:00,792 --> 00:21:03,794
that should definitely be
a kind of core touchpoint.

554
00:21:03,795 --> 00:21:06,498
So, once I have this data
kind of collected up,

555
00:21:06,498 --> 00:21:08,033
a lot of times, what I've
found is if I'm trying

556
00:21:08,033 --> 00:21:10,002
to detect an entire
malware family that maybe

557
00:21:10,002 --> 00:21:11,235
has been out there for
years, there's gonna be

558
00:21:11,236 --> 00:21:12,871
a lot of different
variants in it.

559
00:21:12,871 --> 00:21:14,906
Sometimes there's
actually multi-platforms,

560
00:21:14,906 --> 00:21:16,408
so then now, you know, the
first thing I'm gonna do

561
00:21:16,408 --> 00:21:18,043
is kind of split it out
by what platform it's on,

562
00:21:18,043 --> 00:21:19,777
'cause obviously,
I'm not gonna detect,

563
00:21:19,778 --> 00:21:22,080
well, I might be able to
detect the same sample

564
00:21:22,080 --> 00:21:23,849
across multiple
operating systems,

565
00:21:23,849 --> 00:21:25,550
but that's something that I'm
definitely gonna consider.

566
00:21:25,550 --> 00:21:29,788
EXE and DLL versions tend
to look a little different.

567
00:21:29,788 --> 00:21:32,391
I also tend to split it
up based on import hashes.

568
00:21:32,391 --> 00:21:34,359
Import hashes tend
to indicate versions,

569
00:21:34,359 --> 00:21:37,095
so if I can kind of split
it out based on that,

570
00:21:37,095 --> 00:21:39,865
I find that that's
particularly valuable.

571
00:21:39,865 --> 00:21:41,600
I'm gonna look for outliers
that may not belong.

572
00:21:41,600 --> 00:21:43,168
You can't always trust
your threat intel feeds,

573
00:21:43,168 --> 00:21:44,436
right, or even the blogs.

574
00:21:44,436 --> 00:21:46,471
I'm sure that a lot of
you have seen that empty

575
00:21:46,471 --> 00:21:50,876
file hash pop up in some
disclosure or flash alert,

576
00:21:50,876 --> 00:21:53,378
so, you know, you can't
always trust that what you're

577
00:21:53,378 --> 00:21:55,514
getting from these different
sources is going to align

578
00:21:55,514 --> 00:21:57,683
and necessarily be
exactly the same thing.

579
00:21:57,683 --> 00:22:00,118
So, looking for those
outliers that may not be

580
00:22:00,118 --> 00:22:03,088
the right family at all and
getting those out of the way.

581
00:22:03,088 --> 00:22:06,091
Looking for commonalities
across those remaining samples

582
00:22:06,091 --> 00:22:07,859
and dividing down
further as much as I need

583
00:22:07,859 --> 00:22:10,294
to until I get them into
kind of discrete groups.

584
00:22:10,295 --> 00:22:12,364
This whole process does
take a little bit of time,

585
00:22:12,364 --> 00:22:14,666
but once I get it down to
there, I can start looking

586
00:22:14,666 --> 00:22:17,135
for the common elements
amongst those groups.

587
00:22:17,135 --> 00:22:19,538
So this is kind of the core
of the approach I'm gonna

588
00:22:19,538 --> 00:22:21,306
take here, is I'm gonna look
for these common elements.

589
00:22:21,306 --> 00:22:25,010
The most, you know, prolific,
I think, examples of this

590
00:22:25,010 --> 00:22:26,812
that I see are strings
and binary sequences,

591
00:22:26,812 --> 00:22:29,214
you know, the
classic kind of Yara,

592
00:22:29,214 --> 00:22:30,782
but there's a lot of
other data there as well

593
00:22:30,782 --> 00:22:32,984
that I'll tend to like to
use, especially if I have

594
00:22:32,984 --> 00:22:36,053
like, Open IoC or the
PE module in Yara,

595
00:22:36,054 --> 00:22:38,223
so things like
imports and exports.

596
00:22:38,223 --> 00:22:39,591
Import hashes are
really valuable,

597
00:22:39,591 --> 00:22:41,360
but I've seen some
attackers that I think

598
00:22:41,360 --> 00:22:43,728
are deliberately changing
the imports on their samples

599
00:22:43,729 --> 00:22:46,832
in order to throw off import
hashing and binary similarity.

600
00:22:46,832 --> 00:22:49,434
So, if you, if I can go
down and actually look

601
00:22:49,434 --> 00:22:51,570
at what the imports it's
bringing in that are,

602
00:22:51,570 --> 00:22:54,773
are common across all of
those different instances

603
00:22:54,773 --> 00:22:56,875
that I'm seeing, I've found
that that's a lot more useful

604
00:22:56,875 --> 00:22:59,945
than relying on those
automated processes.

605
00:22:59,945 --> 00:23:01,480
Same with exports as well.

606
00:23:01,480 --> 00:23:03,682
You know, not every attacker's
going to change their export,

607
00:23:03,682 --> 00:23:05,784
even if they're
repackaging their malware.

608
00:23:06,885 --> 00:23:08,387
Version info is
another great example

609
00:23:08,387 --> 00:23:10,288
where, you know, maybe there's
a typo in the version info,

610
00:23:10,288 --> 00:23:13,125
or they use the wrong Unicode
character for the registered

611
00:23:13,125 --> 00:23:15,460
trademark symbol after
that Microsoft Windows.

612
00:23:15,460 --> 00:23:16,595
That's a hint.

613
00:23:16,595 --> 00:23:18,130
There's a lot of
malware that does that.

614
00:23:18,130 --> 00:23:19,664
So, you know, you can find
a lot of different things

615
00:23:19,664 --> 00:23:21,366
based on these
different elements,

616
00:23:21,366 --> 00:23:24,469
and the core if this is really
to look across these samples

617
00:23:24,469 --> 00:23:26,171
and see where those
similarities exist.

618
00:23:26,171 --> 00:23:28,573
Same with Authenticode
signatures.

619
00:23:28,573 --> 00:23:30,308
Looking at dynamic
execution items as well.

620
00:23:30,308 --> 00:23:33,044
If you have access to
inspect memory with Yara

621
00:23:33,044 --> 00:23:35,313
or some other system, being
able to look for things

622
00:23:35,313 --> 00:23:38,383
like handles to named
pipes, to mutexes,

623
00:23:38,383 --> 00:23:40,685
to config files or registry.

624
00:23:40,685 --> 00:23:44,156
Very valuable for finding
those more memory-oriented

625
00:23:44,156 --> 00:23:48,126
samples or malware that
maybe got loaded by,

626
00:23:48,126 --> 00:23:49,594
you know, an initial dropper.

627
00:23:51,396 --> 00:23:54,433
Literally anything else
that I can parse out

628
00:23:54,433 --> 00:23:57,502
across my dataset is what I'm
really going to look for here.

629
00:23:57,502 --> 00:23:59,504
The idea is to find
those common threads

630
00:23:59,504 --> 00:24:02,006
across the samples within
this malware family.

631
00:24:02,007 --> 00:24:04,075
And the reason for that
is because if I can detect

632
00:24:04,075 --> 00:24:06,611
all of the known versions
based on common elements,

633
00:24:06,611 --> 00:24:08,680
I've found that it
dramatically increases the odds

634
00:24:08,680 --> 00:24:11,116
of me finding the next version.

635
00:24:11,116 --> 00:24:12,884
So there are certain
things that probably aren't

636
00:24:12,884 --> 00:24:14,853
going to change that quickly.

637
00:24:14,853 --> 00:24:17,155
If they haven't changed in
the last three versions,

638
00:24:17,155 --> 00:24:18,322
there's a reasonable chance

639
00:24:18,323 --> 00:24:19,524
that they won't
change in the fourth.

640
00:24:19,524 --> 00:24:21,126
And, you know,
these are binaries.

641
00:24:21,126 --> 00:24:22,828
You can literally do
anything you want with them.

642
00:24:22,828 --> 00:24:26,164
It's not possible to
confine this problem space,

643
00:24:26,164 --> 00:24:28,700
but it is possible
to increase my chance

644
00:24:28,700 --> 00:24:31,203
of success based on
looking at what's been done

645
00:24:31,203 --> 00:24:33,705
up to this point and
what's consistent.

646
00:24:33,705 --> 00:24:35,106
And of course, I'm
also going to continue

647
00:24:35,106 --> 00:24:36,875
to use those
behavioral-based detections.

648
00:24:36,875 --> 00:24:39,778
I'm gonna incorporate
not just the structure

649
00:24:39,778 --> 00:24:41,313
of the malware,
but also the TTPs.

650
00:24:41,313 --> 00:24:43,782
I wanna be able to see, if
an attacker is deploying this

651
00:24:43,782 --> 00:24:46,451
in a certain way, I wanna be
able to see if they change

652
00:24:46,451 --> 00:24:48,153
the malware they're
deploying using that method

653
00:24:48,153 --> 00:24:49,888
just as much as I
wanna be able to see

654
00:24:49,888 --> 00:24:51,956
the malware if they change
their deployment method.

655
00:24:51,957 --> 00:24:54,392
So, you know, we've kind
of emphasized detecting

656
00:24:54,392 --> 00:24:57,028
as much as you can across
the attack life cycle,

657
00:24:57,028 --> 00:24:58,930
and make the signature
as broad as possible

658
00:24:58,930 --> 00:25:01,466
within that acceptable
false positive range.

659
00:25:01,466 --> 00:25:05,203
I always emphasize,
too narrow signatures

660
00:25:05,203 --> 00:25:06,571
immediately become brittle.

661
00:25:06,571 --> 00:25:08,406
Keep it as broad as
you can tolerate.

662
00:25:10,308 --> 00:25:11,510
Other things to keep in mind.

663
00:25:11,510 --> 00:25:13,345
If malware is imitating
a legitimate binary,

664
00:25:13,345 --> 00:25:14,579
which we see a lot.

665
00:25:14,579 --> 00:25:15,847
So maybe the internal
version info claims

666
00:25:15,847 --> 00:25:18,183
that it's some Microsoft
binary, what's different

667
00:25:18,183 --> 00:25:19,951
between that and the
legitimate binary?

668
00:25:19,951 --> 00:25:21,186
Start looking for that.

669
00:25:21,186 --> 00:25:22,888
Is it not signed when
it should be signed?

670
00:25:22,888 --> 00:25:26,124
Is it three times the size
of the legitimate binary?

671
00:25:26,124 --> 00:25:27,592
Going through and
looking at those things

672
00:25:27,592 --> 00:25:30,695
can also be another kind of
easy way to get some quick wins.

673
00:25:31,863 --> 00:25:33,131
Do keep track of all
those weaker IoCs,

674
00:25:33,131 --> 00:25:36,601
the file hashes, file
paths, import hashes,

675
00:25:36,601 --> 00:25:39,237
fuzzy hashes, IPs,
all those things.

676
00:25:39,237 --> 00:25:41,206
The odds of us getting
hits on them are lower,

677
00:25:41,206 --> 00:25:43,308
but frankly, I'll take a
freebie if I can get one.

678
00:25:43,308 --> 00:25:45,944
So it's important to still
track and look for those things,

679
00:25:45,944 --> 00:25:48,647
even if they don't always
return a lot of useful data.

680
00:25:50,715 --> 00:25:51,917
And then run it.

681
00:25:51,917 --> 00:25:53,184
You know, you have
to test these things.

682
00:25:53,184 --> 00:25:54,519
Test it against the
samples to make sure

683
00:25:54,519 --> 00:25:55,921
that you detect
everything, that, you know,

684
00:25:55,921 --> 00:25:58,023
I didn't overlook
something in the process,

685
00:25:58,023 --> 00:26:01,525
against clean systems,
against, I love running these

686
00:26:01,526 --> 00:26:03,862
if I have Yara rules, even
if I'm writing in other

687
00:26:03,862 --> 00:26:05,764
languages, I'll translate
them into Yara rules

688
00:26:05,764 --> 00:26:07,933
and then run it against VT
retrohunt, 'cause I wanna see,

689
00:26:07,933 --> 00:26:10,135
you know, are there any
other samples out there?

690
00:26:10,135 --> 00:26:12,237
And then as I'm getting
hits back, true positives

691
00:26:12,237 --> 00:26:14,539
or false positives, I'm
gonna update the rule again.

692
00:26:14,539 --> 00:26:16,274
So if I start finding
true positives,

693
00:26:16,274 --> 00:26:18,243
things that are matching
that I didn't have in my

694
00:26:18,243 --> 00:26:20,445
original dataset, I'm still
gonna take a look at those

695
00:26:20,445 --> 00:26:22,080
and see if there's other
things that maybe I should add

696
00:26:22,080 --> 00:26:24,316
into this rule that I
haven't accounted for yet.

697
00:26:26,685 --> 00:26:28,386
Of course, the more
you know, the better.

698
00:26:28,386 --> 00:26:31,822
If you can do full IDA, you
know, reverse engineering,

699
00:26:31,823 --> 00:26:34,192
that's always going to
provide the best data,

700
00:26:34,192 --> 00:26:36,661
but what I'm trying to get
across is that you can still

701
00:26:36,661 --> 00:26:39,698
make effective signatures
for these things, even if you

702
00:26:39,698 --> 00:26:43,835
aren't the best
reverse engineer, you
know, in the world.

703
00:26:46,037 --> 00:26:47,238
So, talking a little
bit about hunting

704
00:26:47,238 --> 00:26:49,374
and proactive
detection development.

705
00:26:49,374 --> 00:26:51,710
So, you know, how do we
think about detection?

706
00:26:51,710 --> 00:26:52,811
Where do we spend our time?

707
00:26:52,811 --> 00:26:54,012
How do we prioritize?

708
00:26:54,012 --> 00:26:56,014
So, the target
attack life cycle.

709
00:26:56,014 --> 00:26:57,616
So this is basically
how Mandiant

710
00:26:57,616 --> 00:27:00,118
has thought about
incidents for a long time.

711
00:27:00,118 --> 00:27:02,253
This is, really focuses
on post-compromise.

712
00:27:02,253 --> 00:27:03,989
So a lot of the detections,
and even the things

713
00:27:03,989 --> 00:27:05,757
that we've talked about
here today, tend to focus

714
00:27:05,757 --> 00:27:08,360
on the first two stages
of this attack life cycle,

715
00:27:08,360 --> 00:27:10,861
the initial compromise and
the establish foothold.

716
00:27:10,862 --> 00:27:13,932
And it's very important to be
able to detect those reliably,

717
00:27:13,932 --> 00:27:16,267
because that's the initial
step into the environment.

718
00:27:16,267 --> 00:27:18,036
You wanna catch this
as soon as possible.

719
00:27:18,036 --> 00:27:21,473
But you can't always catch
those, those two pieces, right?

720
00:27:21,473 --> 00:27:23,375
There's always going
to be some next attack

721
00:27:23,375 --> 00:27:24,909
that you don't know about,

722
00:27:24,909 --> 00:27:27,579
EternalBlue before we knew
about EternalBlue, right?

723
00:27:27,579 --> 00:27:30,348
So, we need to be able to detect

724
00:27:30,348 --> 00:27:32,484
across the full
attack life cycle.

725
00:27:32,484 --> 00:27:34,252
'Cause each of these steps
is like a choke point

726
00:27:34,252 --> 00:27:35,754
for an attacker.

727
00:27:35,754 --> 00:27:37,187
An attacker needs to get
through all of these steps

728
00:27:37,188 --> 00:27:38,690
in order to complete
their mission.

729
00:27:38,690 --> 00:27:41,426
So if I can find all of
the ways that an attacker

730
00:27:41,426 --> 00:27:44,495
can do lateral movement
or maintain presence

731
00:27:44,496 --> 00:27:46,731
or escalate privileges,
and if I can develop

732
00:27:46,731 --> 00:27:49,334
protections for each of those,
then I've set a position

733
00:27:49,334 --> 00:27:51,670
where an attacker has
to find a novel way

734
00:27:51,670 --> 00:27:54,806
to get past that step in the
attack without being detected.

735
00:27:58,376 --> 00:27:59,978
From a hunting
perspective, you know,

736
00:27:59,978 --> 00:28:01,246
there's been a lot of
talk about hunting.

737
00:28:01,246 --> 00:28:02,681
I really don't need to
explain what that is,

738
00:28:02,681 --> 00:28:07,252
especially after the
talk we just had.

739
00:28:07,252 --> 00:28:09,521
But one output of your hunting
should be new detections.

740
00:28:09,521 --> 00:28:11,656
And if you're finding
that you're hunting
for the same thing

741
00:28:11,656 --> 00:28:13,658
over and over and over
again, consider making

742
00:28:13,658 --> 00:28:16,127
new detection, whether that's
blacklisting or whitelisting.

743
00:28:16,127 --> 00:28:18,062
You know, if you're seeing
that the only thing,

744
00:28:18,063 --> 00:28:20,365
the only things that are
coming back from this hunt

745
00:28:20,365 --> 00:28:23,034
are these five items, then
maybe whitelist that out,

746
00:28:23,034 --> 00:28:24,569
build that into an
automated detection

747
00:28:24,569 --> 00:28:26,504
so you're not doing the same
hunts over and over again.

748
00:28:26,504 --> 00:28:28,106
That should always be an output.

749
00:28:29,474 --> 00:28:31,710
So where else do our
detection ideas come from?

750
00:28:31,710 --> 00:28:33,978
So, active and historic
attacker activity.

751
00:28:33,978 --> 00:28:36,214
We're they're lucky to
have access to a lot

752
00:28:36,214 --> 00:28:37,948
of live investigations
that are going on

753
00:28:37,949 --> 00:28:39,784
and be able to see what's
happening in those incidents,

754
00:28:39,784 --> 00:28:41,619
and being able to pull that data

755
00:28:41,619 --> 00:28:43,888
into our detection
development process.

756
00:28:45,090 --> 00:28:47,324
Also, intel, you know,
the good kind of intel,

757
00:28:47,325 --> 00:28:49,627
the kind of intel
that gives you TTPs

758
00:28:49,627 --> 00:28:52,297
and actionable, useful
information that's derived

759
00:28:52,297 --> 00:28:55,033
directly from the source,
not second- and third-hand,

760
00:28:55,033 --> 00:28:59,204
like aggregated commentary,
you know, TMZ of threat intel

761
00:28:59,204 --> 00:29:02,540
type data, but like, the
really, the good kind.

762
00:29:02,540 --> 00:29:04,442
And here, again, we're a
little spoiled by that.

763
00:29:04,442 --> 00:29:08,179
But that data is out
there if you look for it.

764
00:29:08,179 --> 00:29:09,414
Open-source research.

765
00:29:09,414 --> 00:29:12,283
Twitter is like, the
best resource for this

766
00:29:12,283 --> 00:29:13,450
that I could even imagine.

767
00:29:13,451 --> 00:29:15,553
I mean, if you
wanna get into this,

768
00:29:15,553 --> 00:29:18,056
Twitter is definitely
the best place to get

769
00:29:18,056 --> 00:29:19,624
the latest info on
what people are doing

770
00:29:19,624 --> 00:29:21,760
and what publicly-available
tools are coming out,

771
00:29:21,760 --> 00:29:23,128
and when those tools
come out, we know

772
00:29:23,128 --> 00:29:24,763
we're gonna see them in
the next couple of days.

773
00:29:24,763 --> 00:29:26,598
So, you know, we can
just start getting,

774
00:29:26,598 --> 00:29:28,233
getting working on that.

775
00:29:28,233 --> 00:29:30,368
And crazy whims, I
wonder how often.

776
00:29:30,368 --> 00:29:32,570
You know, I wonder
how often Certutil

777
00:29:32,570 --> 00:29:34,906
writes PE files onto
disk in Windows.

778
00:29:34,906 --> 00:29:38,676
Well, you know, there may be
a couple of tools out there

779
00:29:38,676 --> 00:29:40,779
that actually do
that legitimately,

780
00:29:40,779 --> 00:29:42,680
but most of the
time, that's bad.

781
00:29:44,516 --> 00:29:46,951
- All right, so we
covered a lot pretty fast,

782
00:29:46,951 --> 00:29:48,219
and so, just what
are the takeaways,

783
00:29:48,219 --> 00:29:50,889
what are the main points
we wanna come away with?

784
00:29:50,889 --> 00:29:53,491
So, it's important to kind of
assess and reassess yourself

785
00:29:53,491 --> 00:29:55,126
and your team,
your organization.

786
00:29:55,126 --> 00:29:57,195
What are we detecting today,
and how are we doing it,

787
00:29:57,195 --> 00:30:00,331
and how might changes in the
TTP that we see coming in

788
00:30:00,331 --> 00:30:02,300
actually maybe lead
us to say, you know,

789
00:30:02,300 --> 00:30:03,868
we're actually, we
could do so much better

790
00:30:03,868 --> 00:30:05,303
if we had this
additional visibility

791
00:30:05,303 --> 00:30:07,605
or this additional capability,
and it's just important

792
00:30:07,605 --> 00:30:09,641
to be honest with yourself
about what you're lacking

793
00:30:09,641 --> 00:30:12,410
and what you might need
going forward in the future.

794
00:30:12,410 --> 00:30:13,845
What data sources?

795
00:30:13,845 --> 00:30:15,780
Like, do you need to
push out additional tools

796
00:30:15,780 --> 00:30:19,551
for getting additional
data to start with

797
00:30:19,551 --> 00:30:21,820
before you even overlay
the tools on top of that?

798
00:30:21,820 --> 00:30:24,322
And then what timeframe
are you shooting for?

799
00:30:24,322 --> 00:30:27,625
Like, are you shooting for
like, split second alert as soon

800
00:30:27,625 --> 00:30:30,461
as something happens, or is
a five-minute delay fine?

801
00:30:30,461 --> 00:30:31,963
Is a day delay fine?

802
00:30:31,963 --> 00:30:35,133
It really depends on your
threshold and your tolerance

803
00:30:35,133 --> 00:30:37,302
for kind of the unknown
and how long it can go

804
00:30:37,302 --> 00:30:39,169
without you knowing about it.

805
00:30:39,170 --> 00:30:41,272
But definitely, if you're
shooting for realtime

806
00:30:41,272 --> 00:30:43,608
and you can't get it, then
don't throw away the idea.

807
00:30:43,608 --> 00:30:46,177
Step back and say, maybe I'm
okay with a five-minute delay,

808
00:30:46,177 --> 00:30:48,745
and it's way better
than having nothing.

809
00:30:48,746 --> 00:30:50,548
It's also important to
know your own assumptions

810
00:30:50,548 --> 00:30:52,350
about your knowledge
of attacker TTPs

811
00:30:52,350 --> 00:30:53,885
and your visibility into that.

812
00:30:53,885 --> 00:30:57,055
Again, if you're not really,
it's important not to try

813
00:30:57,055 --> 00:30:58,523
to fool your team into thinking

814
00:30:58,523 --> 00:30:59,823
that you're better
off than you are.

815
00:30:59,824 --> 00:31:01,259
Like, just be honest.

816
00:31:01,259 --> 00:31:02,760
Like, we all miss things,
and we should share

817
00:31:02,760 --> 00:31:04,896
those failures together and
share the successes together,

818
00:31:04,896 --> 00:31:06,831
and in forums like
this, be able to learn

819
00:31:06,831 --> 00:31:08,733
from one another
as practitioners

820
00:31:08,733 --> 00:31:11,369
in the industry and all
get better together.

821
00:31:11,369 --> 00:31:13,437
And then as Dunwoody mentioned,

822
00:31:13,438 --> 00:31:15,707
it's really important
that, as you're doing

823
00:31:15,707 --> 00:31:17,475
your day-to-day job, that
you're setting up hunts.

824
00:31:17,475 --> 00:31:18,909
Like, don't just
throw away the data

825
00:31:18,910 --> 00:31:20,111
when you're done with
it; like, keep it.

826
00:31:20,111 --> 00:31:22,146
Like, you may have a
new person on your team

827
00:31:22,146 --> 00:31:24,148
that is really into
math and data science,

828
00:31:24,148 --> 00:31:25,750
and they can actually do
some really cool stuff

829
00:31:25,750 --> 00:31:27,785
with that data that you
thought was useless.

830
00:31:27,785 --> 00:31:30,288
And so, not to be a
pack rat, but just like,

831
00:31:30,288 --> 00:31:32,624
kind of talk amongst
peers and say, hey,

832
00:31:32,624 --> 00:31:35,894
given this data, could you do
something interesting with it?

833
00:31:35,894 --> 00:31:38,129
It's important to know
and validate your tools

834
00:31:38,129 --> 00:31:40,430
as well as to know and
validate your data sources.

835
00:31:40,431 --> 00:31:42,800
If you're relying on
command line arguments

836
00:31:42,800 --> 00:31:46,671
from 4688 or from SysMon, like,
why don't you test the tools

837
00:31:46,671 --> 00:31:48,206
you're using to read that,
and maybe there's some

838
00:31:48,206 --> 00:31:50,541
interesting bugs in there
that you wanna make sure

839
00:31:50,541 --> 00:31:52,076
that you're, you
know if you can trust

840
00:31:52,076 --> 00:31:53,478
the data that you're getting.

841
00:31:54,846 --> 00:31:56,447
And it's important to
validate with multiple tools.

842
00:31:56,447 --> 00:31:58,983
Sometimes tools handle
output differently

843
00:31:58,983 --> 00:32:01,152
and give you invalid results.

844
00:32:01,152 --> 00:32:04,088
And again, like, know what
your tool's limitations are,

845
00:32:04,088 --> 00:32:07,058
and don't try to push past
that if it's not going to work

846
00:32:07,058 --> 00:32:09,260
and then figure out,
do we need new tools,

847
00:32:09,260 --> 00:32:10,895
or do we just kind of
set this to the side,

848
00:32:10,895 --> 00:32:13,231
because maybe we're
spending 99% of our time

849
00:32:13,231 --> 00:32:15,433
focusing just on
initial compromise

850
00:32:15,433 --> 00:32:17,468
and zero time on
lateral movement.

851
00:32:17,468 --> 00:32:19,137
Like, maybe we have tools
that are really good

852
00:32:19,137 --> 00:32:22,273
at lateral movement, so let's
focus on that for a while.

853
00:32:22,273 --> 00:32:24,775
And automate repetitive
tasks wherever possible.

854
00:32:24,776 --> 00:32:27,211
Not only does this save you
time to let you hunt more,

855
00:32:27,211 --> 00:32:28,746
but the way I think about it is,

856
00:32:28,746 --> 00:32:30,615
if I can automate whether
my detection worked or not

857
00:32:30,615 --> 00:32:32,617
or automate these hunt
things, then I'm actually

858
00:32:32,617 --> 00:32:35,119
freeing up creative brain
cycles to think about new

859
00:32:35,119 --> 00:32:37,422
detections and to look
at data differently.

860
00:32:37,422 --> 00:32:38,957
So, wherever you can automate,

861
00:32:38,957 --> 00:32:40,692
and the people on your team
that are good at automating,

862
00:32:40,692 --> 00:32:42,994
like, man, like, the highest
praise to those people,

863
00:32:42,994 --> 00:32:44,629
because they really
allow the whole team

864
00:32:44,629 --> 00:32:46,831
to get better together
and really use your minds

865
00:32:46,831 --> 00:32:49,600
in new, creative, interesting
problems as opposed

866
00:32:49,600 --> 00:32:53,004
to just droning on the same
data and the same processes.

867
00:32:54,439 --> 00:32:55,974
So, with all that being
said, I know that was a lot

868
00:32:55,974 --> 00:32:57,774
of information, but we just
wanna say to all of you,

869
00:32:57,775 --> 00:32:59,510
thank you so much for your time,

870
00:32:59,510 --> 00:33:00,712
and we'll take
questions in a second.

871
00:33:00,712 --> 00:33:01,412
But we're really
honored to be here.

872
00:33:01,412 --> 00:33:02,613
So, thank you.

873
00:33:02,613 --> 00:33:05,616
(audience applauds)

874
00:33:06,884 --> 00:33:10,488
(brisk instrumental music)

