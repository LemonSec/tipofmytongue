1
00:00:08,875 --> 00:00:10,844
(audience applauds)

2
00:00:10,844 --> 00:00:13,346
- I'm not 100% sure
of what all Rob said

3
00:00:13,346 --> 00:00:14,981
because I was running
around trying to figure out

4
00:00:14,981 --> 00:00:17,717
how to get a HDMI
to USB adapter.

5
00:00:20,086 --> 00:00:22,188
Or HDMI to USB-C.

6
00:00:22,188 --> 00:00:23,990
But Joe and I are going
to be talking about

7
00:00:23,990 --> 00:00:25,325
Hunting in Memory.

8
00:00:25,325 --> 00:00:27,127
So, basically being
able to use PowerShell

9
00:00:27,127 --> 00:00:29,695
to look for
injection and memory,

10
00:00:29,696 --> 00:00:32,165
and so a kind of
quick introduction.

11
00:00:32,165 --> 00:00:35,869
Jared Atkinson on the Defensive
Service Technical Director

12
00:00:35,869 --> 00:00:37,971
at Specter Ops
which is a startup.

13
00:00:37,971 --> 00:00:40,205
There is about 13 of us.

14
00:00:40,206 --> 00:00:43,877
And we do hunting,
we do red teaming,

15
00:00:43,877 --> 00:00:45,178
those types of services.

16
00:00:45,178 --> 00:00:46,678
I'm also a Microsoft
Cloud and Datacenter

17
00:00:46,679 --> 00:00:49,115
Management MVP and so,

18
00:00:49,115 --> 00:00:50,383
are we good on this?

19
00:00:50,383 --> 00:00:53,987
Okay, and so I don't
know a lot about Cloud

20
00:00:53,987 --> 00:00:55,321
and I don't know a
lot about Datacenters,

21
00:00:55,321 --> 00:00:56,589
but that is what
they decided to put

22
00:00:56,589 --> 00:00:57,957
Powershell MVP's
under at Microsoft

23
00:00:57,957 --> 00:00:59,659
and so that's what I am.

24
00:00:59,659 --> 00:01:01,861
I also developed a project
called Power Forensics.

25
00:01:01,861 --> 00:01:06,066
Which is a PowerShell C-Sharp
based forensic tool set.

26
00:01:06,066 --> 00:01:07,000
And then, Joe.

27
00:01:07,000 --> 00:01:08,401
- So, I'm Joe Desimone.

28
00:01:08,401 --> 00:01:10,369
So I work for a
company called Endgame,

29
00:01:10,370 --> 00:01:11,571
some of you probably heard of,

30
00:01:11,571 --> 00:01:13,339
maybe don't know
exactly what we do.

31
00:01:13,339 --> 00:01:15,341
But we have a EDR
product to help

32
00:01:15,341 --> 00:01:16,809
people secure their endpoints,

33
00:01:16,810 --> 00:01:18,378
hunt their endpoints.

34
00:01:18,378 --> 00:01:20,547
So technically yeah,
Malware Researcher,

35
00:01:20,547 --> 00:01:22,449
because that's
originally my background.

36
00:01:22,449 --> 00:01:24,651
I came from a Malware
RE background.

37
00:01:24,651 --> 00:01:25,884
But since I've come to Endgame,

38
00:01:25,885 --> 00:01:27,454
I do development, I
do a little bit of RE,

39
00:01:27,454 --> 00:01:29,655
I do a little bit
of threat hunting.

40
00:01:29,656 --> 00:01:33,159
And also do this kind of
hunting and memory stuff

41
00:01:33,159 --> 00:01:35,795
in Endgame so it's fun.

42
00:01:35,795 --> 00:01:37,030
So just to give an overview of

43
00:01:37,030 --> 00:01:37,964
what we're gonna
talk about today.

44
00:01:37,964 --> 00:01:39,232
First, just briefly talk about

45
00:01:39,232 --> 00:01:41,601
why hunting in memory
is actually important.

46
00:01:41,601 --> 00:01:43,470
We're gonna then dig into

47
00:01:43,470 --> 00:01:45,405
some of the common
attacker techniques.

48
00:01:45,405 --> 00:01:46,973
So really if you want
to be able to find stuff

49
00:01:46,973 --> 00:01:51,678
that's living in memory
that's evading from you,

50
00:01:51,678 --> 00:01:52,878
then you kind of
have to at least have

51
00:01:52,879 --> 00:01:53,847
some understanding of what the

52
00:01:53,847 --> 00:01:55,315
common techniques out there are.

53
00:01:55,315 --> 00:01:56,416
So we're gonna just walk through

54
00:01:56,416 --> 00:01:58,151
some different malware samples

55
00:01:58,151 --> 00:01:59,586
and some common
techniques and show you

56
00:01:59,586 --> 00:02:00,920
kind of what they're doing.

57
00:02:00,920 --> 00:02:02,388
And that'll help
you when we go to

58
00:02:02,388 --> 00:02:03,923
how do we protect this.

59
00:02:03,923 --> 00:02:06,092
You can kind of keep that
in the back of your mind.

60
00:02:06,092 --> 00:02:07,861
We'll talk about
some existing tools

61
00:02:07,861 --> 00:02:09,362
and approaches that you can use

62
00:02:09,362 --> 00:02:11,597
for hunting and memory.

63
00:02:11,598 --> 00:02:13,299
And then we're
gonna be releasing

64
00:02:13,299 --> 00:02:14,501
a PowerShell tool today

65
00:02:14,501 --> 00:02:17,270
that can rapidly scale
out and be able to

66
00:02:17,270 --> 00:02:19,372
find some of these techniques

67
00:02:19,372 --> 00:02:22,642
that malware's using
to hide in memory.

68
00:02:23,843 --> 00:02:26,446
So the importance
of memory hunting.

69
00:02:26,446 --> 00:02:27,981
It's not new,

70
00:02:27,981 --> 00:02:31,851
I mean you hear like the buzz
of filest and stuff like that.

71
00:02:31,851 --> 00:02:34,754
Malware using in
memory techniques

72
00:02:34,754 --> 00:02:35,989
is not really new,

73
00:02:35,989 --> 00:02:37,757
it's been around
for over a decade.

74
00:02:37,757 --> 00:02:41,694
If you think back like
Poison Ivy in the mid-2000's,

75
00:02:41,694 --> 00:02:43,863
a lot of APT groups using that.

76
00:02:43,863 --> 00:02:45,865
Which had some
filest techniques,

77
00:02:45,865 --> 00:02:48,201
some injection techniques.

78
00:02:48,201 --> 00:02:51,070
But now it's really what
changed in the last few years,

79
00:02:51,070 --> 00:02:52,739
it's just become
a lot more common.

80
00:02:52,739 --> 00:02:56,075
Really those APT techniques have

81
00:02:56,075 --> 00:03:00,245
migrated to being a
commodity malware and stuff.

82
00:03:00,246 --> 00:03:01,748
It's really easy to
just go and get hub

83
00:03:01,748 --> 00:03:03,950
and grab some libraries are
already there for your malware

84
00:03:03,950 --> 00:03:07,085
and build it in and
use those techniques.

85
00:03:07,086 --> 00:03:09,722
And specifically,
it's designed to evade

86
00:03:09,722 --> 00:03:10,990
PSP products but also you guys.

87
00:03:10,990 --> 00:03:11,925
You guys are hunting,

88
00:03:11,925 --> 00:03:13,126
you're trying to find stuff.

89
00:03:13,126 --> 00:03:14,894
The actors are using
these techniques

90
00:03:14,894 --> 00:03:16,629
to hide from you guys so
you need to be aware of them

91
00:03:16,629 --> 00:03:18,898
and specifically use that
through your thought process

92
00:03:18,898 --> 00:03:20,099
as you're doing hunting.

93
00:03:20,099 --> 00:03:23,469
But also, hunting in
memory is great because

94
00:03:23,469 --> 00:03:24,637
it really, if you
do it correctly,

95
00:03:24,637 --> 00:03:26,272
it has a great signal
to noise ratio.

96
00:03:26,272 --> 00:03:29,209
There's so many files
and your processes

97
00:03:29,209 --> 00:03:30,777
and deal is loaded
and all the stuff,

98
00:03:30,777 --> 00:03:31,977
and there's so much date.

99
00:03:31,978 --> 00:03:33,713
But really when you're
looking in memory,

100
00:03:33,713 --> 00:03:35,648
there are some legitimate things

101
00:03:35,648 --> 00:03:37,250
that are using in
memory techniques

102
00:03:37,250 --> 00:03:39,018
but it's just a lot
smaller so it's,

103
00:03:39,018 --> 00:03:40,320
if you do it correctly,

104
00:03:40,320 --> 00:03:41,988
it's easy but hunting.

105
00:03:41,988 --> 00:03:43,656
You can find the advance stuff

106
00:03:43,656 --> 00:03:45,992
because they're being stealthy.

107
00:03:45,992 --> 00:03:47,827
You can find them easily.

108
00:03:47,827 --> 00:03:50,363
So here are the
attacker techniques
we're gonna go through.

109
00:03:50,363 --> 00:03:53,233
We're gonna talk about classic
memory shellcode injection.

110
00:03:53,233 --> 00:03:55,068
We'll touch on
reflective DLL loading

111
00:03:55,068 --> 00:03:56,803
which I'm sure a lot of
people have heard of.

112
00:03:56,803 --> 00:03:58,504
Memory module which
is sort of newer

113
00:03:58,504 --> 00:04:02,375
but it's kind of a twist
on reflective DLL loading.

114
00:04:02,375 --> 00:04:04,978
Process and module
hollowing we'll talk about.

115
00:04:04,978 --> 00:04:06,879
And PEB unlinking and finally,

116
00:04:06,879 --> 00:04:08,548
we'll talk about
this new technique

117
00:04:08,548 --> 00:04:10,516
that was within
the last few weeks

118
00:04:10,516 --> 00:04:13,987
had come out known as Gargoyle
which is kind of cool.

119
00:04:13,987 --> 00:04:15,688
So classic injection.

120
00:04:15,688 --> 00:04:18,591
This is like Poison
Ivy, bread and butter,

121
00:04:18,591 --> 00:04:19,926
you know you're gonna,

122
00:04:19,926 --> 00:04:21,594
first you need to get a
handle to a processor.

123
00:04:21,594 --> 00:04:23,096
You're going to open process.

124
00:04:23,096 --> 00:04:25,932
You're gonna allocate some
memory in that process.

125
00:04:25,932 --> 00:04:27,800
So this is going
to be on back code.

126
00:04:27,800 --> 00:04:29,469
Some people call
it floating code.

127
00:04:29,469 --> 00:04:32,171
And then you're gonna write
your shellcode to that

128
00:04:32,171 --> 00:04:35,207
and eventually you're
gonna create a new thread

129
00:04:35,208 --> 00:04:36,576
of execution on that shellcode.

130
00:04:36,576 --> 00:04:37,977
So this is kind of
like the original,

131
00:04:37,977 --> 00:04:41,013
this is the old school
Poison Ivy approach.

132
00:04:41,014 --> 00:04:43,549
It's pretty, I would say
it's not really stealthy

133
00:04:43,549 --> 00:04:45,751
but it's just good
to know as a base.

134
00:04:45,752 --> 00:04:47,687
So just some screen shots
with all of the above

135
00:04:47,687 --> 00:04:49,522
you can see Poison Ivy.

136
00:04:49,522 --> 00:04:51,190
40 at the top of the screen,

137
00:04:51,190 --> 00:04:52,892
that's something that you can

138
00:04:52,892 --> 00:04:53,860
just have in the
back of your mind.

139
00:04:53,860 --> 00:04:55,328
It's rewrite execute.

140
00:04:55,328 --> 00:04:56,863
So if you ever see push 40

141
00:04:56,863 --> 00:04:58,064
before virtual alloc,

142
00:04:58,064 --> 00:05:00,166
you know it's going
through rewrite execute.

143
00:05:00,166 --> 00:05:01,367
And then you can
see at the bottom

144
00:05:01,367 --> 00:05:02,902
the write process
memory that it's using

145
00:05:02,902 --> 00:05:04,437
with create remote
threading close handle.

146
00:05:04,437 --> 00:05:05,838
So that's kind of
like the recipe

147
00:05:05,838 --> 00:05:09,275
for doing classic
injection with Poison Ivy.

148
00:05:09,275 --> 00:05:10,443
I'm gonna show a lot of
screenshots to Process Hacker.

149
00:05:10,443 --> 00:05:13,712
I love Process Hacker,
I use it a lot.

150
00:05:13,713 --> 00:05:14,647
So this is actually,

151
00:05:14,647 --> 00:05:16,748
if you look at the memory layout

152
00:05:16,749 --> 00:05:18,084
of the process I injected to,

153
00:05:18,084 --> 00:05:20,253
the cool thing about Poison Ivy

154
00:05:20,253 --> 00:05:22,121
is the way it does
its injection.

155
00:05:22,121 --> 00:05:24,022
It's not all in one
chunk of memory.

156
00:05:24,023 --> 00:05:25,625
It actually kind
of spaces it out

157
00:05:25,625 --> 00:05:27,260
and it'll jump from
region to region

158
00:05:27,260 --> 00:05:28,928
as that code is executing.

159
00:05:28,928 --> 00:05:30,163
So you're gonna,

160
00:05:30,163 --> 00:05:31,631
if you look at it
with proccesor,

161
00:05:31,631 --> 00:05:33,066
you can see a whole bunch
of different sections

162
00:05:33,066 --> 00:05:36,335
all consecutive but
all laid out there.

163
00:05:38,371 --> 00:05:39,438
Process Hacker is also cool
because it will show you

164
00:05:39,439 --> 00:05:41,574
call stacks for what's actually

165
00:05:41,574 --> 00:05:43,810
running in that process.

166
00:05:43,810 --> 00:05:46,579
If you try and do this with

167
00:05:46,579 --> 00:05:48,715
the process explorer,

168
00:05:48,715 --> 00:05:50,116
they'll actually,

169
00:05:50,116 --> 00:05:52,352
really what you're
trying to get to is those

170
00:05:52,352 --> 00:05:53,753
elements on the stack that the

171
00:05:53,753 --> 00:05:56,589
big arrow is pointing
to that don't actually

172
00:05:56,589 --> 00:05:58,391
point back to a code on disk.

173
00:05:58,391 --> 00:05:59,325
So it just says no unwind info.

174
00:05:59,325 --> 00:06:01,661
File name process explorer

175
00:06:01,661 --> 00:06:03,496
just thinks those are wrong
and deletes them I think.

176
00:06:03,496 --> 00:06:07,667
From biotesting but Process
Hacker will actually show you.

177
00:06:07,667 --> 00:06:09,635
And that's really what
you're looking for

178
00:06:09,635 --> 00:06:10,670
because those are the addresses

179
00:06:10,670 --> 00:06:12,171
that are unbacked.

180
00:06:12,171 --> 00:06:13,639
The floating shellcode is
actually executing too.

181
00:06:13,639 --> 00:06:15,074
Like that's abnormal.

182
00:06:15,074 --> 00:06:18,478
You can see you know it's
calling Winsock functions there.

183
00:06:18,478 --> 00:06:21,080
Yeah, that's Poison Ivy.

184
00:06:21,080 --> 00:06:23,950
And we'll move on to
Reflective DLL Injection.

185
00:06:23,950 --> 00:06:25,485
So this is kind of,

186
00:06:25,485 --> 00:06:27,653
this is a better
approach because

187
00:06:27,653 --> 00:06:28,888
when you think of Poison Ivy,

188
00:06:28,888 --> 00:06:30,222
you have to write
your own shellcode.

189
00:06:30,223 --> 00:06:31,858
A lot of the
adversaries out there,

190
00:06:31,858 --> 00:06:33,092
it's a pain in the butt

191
00:06:33,092 --> 00:06:34,327
to write your own
custom assembly.

192
00:06:34,327 --> 00:06:35,261
All you'd really want to do

193
00:06:35,261 --> 00:06:36,629
is take your CC++ application,

194
00:06:36,629 --> 00:06:38,931
build it and you
want that to load.

195
00:06:38,931 --> 00:06:40,400
Well, reflective DLL injection

196
00:06:40,400 --> 00:06:41,967
makes it a lot easier
and the original research

197
00:06:41,968 --> 00:06:45,338
by Steven Fewer he
kind of published this

198
00:06:45,338 --> 00:06:47,607
and it's really handy for
the attacker's perspective.

199
00:06:47,607 --> 00:06:49,575
That's why you see it
all over the place.

200
00:06:49,575 --> 00:06:53,546
And it kind of makes
for a dumb injector

201
00:06:53,546 --> 00:06:55,815
because basically
the target payload

202
00:06:55,815 --> 00:06:57,082
maps itself in a memory.

203
00:06:57,083 --> 00:06:58,751
All you got to do
is start a thread,

204
00:06:58,751 --> 00:07:00,719
or redirect the thread
to the entry point

205
00:07:00,720 --> 00:07:02,755
of that reflective DLL

206
00:07:02,755 --> 00:07:04,390
and it kind of takes
care of mapping itself.

207
00:07:04,390 --> 00:07:07,226
So it'll allocate
memory, map section,

208
00:07:07,226 --> 00:07:09,562
resolve the imports,
fix up relocations.

209
00:07:09,562 --> 00:07:10,797
It kind of does everything.

210
00:07:10,797 --> 00:07:12,698
You don't really have
to know about that.

211
00:07:12,698 --> 00:07:16,034
But there's just basically
header that you would include.

212
00:07:16,035 --> 00:07:17,470
Meterpreter's been using this.

213
00:07:17,470 --> 00:07:19,005
I would say they
were one of the first

214
00:07:19,005 --> 00:07:22,341
to fully weaponize and
make it a robust solution.

215
00:07:22,341 --> 00:07:23,810
So Meterpreter's using
that under the hood.

216
00:07:23,810 --> 00:07:25,578
Even PowerShell Empire
uses that under the hood

217
00:07:25,578 --> 00:07:27,046
when you want to do a migration

218
00:07:27,046 --> 00:07:29,081
from your initial PowerShell

219
00:07:29,081 --> 00:07:30,850
then you don't want to
live in PowerShell exc,

220
00:07:30,850 --> 00:07:32,752
you want to migrate
to some service.

221
00:07:32,752 --> 00:07:34,587
Well they're actually using
Reflective DLL injection

222
00:07:34,587 --> 00:07:39,091
in order to bootstrap.net
into that target process.

223
00:07:39,091 --> 00:07:41,694
So this is kind of what
Meterpreter looks like

224
00:07:41,694 --> 00:07:43,029
with Process Hacker in memory.

225
00:07:43,029 --> 00:07:44,230
You can see there's
a whole bunch

226
00:07:44,230 --> 00:07:45,731
of rewrite execute sections.

227
00:07:45,731 --> 00:07:50,102
That's really anomalous I
would say, to say the least.

228
00:07:50,102 --> 00:07:52,604
There's also some
sections that are,

229
00:07:52,605 --> 00:07:53,539
they're close in size.

230
00:07:53,539 --> 00:07:54,640
Because what happens is there's

231
00:07:54,640 --> 00:07:55,875
an initial allocation
that happens

232
00:07:55,875 --> 00:07:58,177
and then it reallocates itself.

233
00:07:58,177 --> 00:08:00,780
Like with the correct
page alignment.

234
00:08:00,780 --> 00:08:02,347
That's why you can
see there's like

235
00:08:02,348 --> 00:08:04,884
kind of multiple sections
that are similar in size.

236
00:08:04,884 --> 00:08:06,385
But even more obvious,

237
00:08:06,385 --> 00:08:07,353
if you actually dump out
those sections in memory,

238
00:08:07,353 --> 00:08:08,788
open up with Init you see

239
00:08:08,788 --> 00:08:11,557
it literally has the
reflective loader export.

240
00:08:11,557 --> 00:08:13,860
So it's, you know you can even
look for that in the strain

241
00:08:13,860 --> 00:08:16,496
as like a super high
confidence thing.

242
00:08:16,496 --> 00:08:19,565
But if you actually click on
one of those memory sections,

243
00:08:19,565 --> 00:08:21,400
even the main header is there.

244
00:08:21,400 --> 00:08:23,669
So it's really basic level.

245
00:08:23,669 --> 00:08:25,770
Super easy to find.

246
00:08:25,771 --> 00:08:27,440
It has the full MZ
header sitting there

247
00:08:27,440 --> 00:08:29,609
at the start of the section.

248
00:08:29,609 --> 00:08:32,578
Memory module is similar
to Reflective Injection.

249
00:08:32,578 --> 00:08:34,380
This is another one.

250
00:08:34,380 --> 00:08:35,948
So this is also you
can go to get hub,

251
00:08:35,948 --> 00:08:37,516
download code to do it

252
00:08:37,517 --> 00:08:39,919
and basically it's similar
to Reflective DLL Injection

253
00:08:39,919 --> 00:08:42,755
but instead of including a
library with your Payload,

254
00:08:42,755 --> 00:08:45,658
the Injector actually
does the mapping for you.

255
00:08:45,658 --> 00:08:47,827
So you can just have
your regular DLL,

256
00:08:47,827 --> 00:08:49,462
it doesn't have to know
about being in memory.

257
00:08:49,462 --> 00:08:50,795
It doesn't have to care,

258
00:08:50,796 --> 00:08:53,266
but the actual, the main loader

259
00:08:53,266 --> 00:08:54,766
will take care of doing
the same processes.

260
00:08:54,767 --> 00:08:57,003
You know resolving imports,

261
00:08:57,003 --> 00:08:59,405
fixing relocations and
that sort of thing.

262
00:08:59,405 --> 00:09:01,406
It's kind of like just
calling LoadLibrary

263
00:09:01,407 --> 00:09:02,909
from the attachers's perspective

264
00:09:02,909 --> 00:09:05,278
except instead of giving a
DLL path to something in disk,

265
00:09:05,278 --> 00:09:06,946
you just give it
a chunk of memory.

266
00:09:06,946 --> 00:09:08,581
And usually that memory
comes from something

267
00:09:08,581 --> 00:09:10,316
that they've downloaded
over the network,

268
00:09:10,316 --> 00:09:12,084
or something they
just decrypted.

269
00:09:12,084 --> 00:09:14,119
So it can live on
disk encrypted,

270
00:09:14,120 --> 00:09:16,455
decrypted and then load
it directly into memory.

271
00:09:16,455 --> 00:09:20,326
The original
implementation avoided RWX

272
00:09:20,326 --> 00:09:22,828
and most the
implementations I've seen

273
00:09:22,828 --> 00:09:23,896
avoid RWX which is nice.

274
00:09:23,896 --> 00:09:25,264
So it's just going,

275
00:09:25,264 --> 00:09:27,800
well nice from the
attacker's perspective.

276
00:09:27,800 --> 00:09:30,670
So you're gonna have
a read on the header

277
00:09:30,670 --> 00:09:32,604
and we'll show some
screenshots of that.

278
00:09:32,605 --> 00:09:36,375
And the original
was a local process,

279
00:09:36,375 --> 00:09:37,843
but there's new implementations

280
00:09:37,843 --> 00:09:39,545
that'll allow you
to memory module

281
00:09:39,545 --> 00:09:42,180
into a remote process.

282
00:09:42,181 --> 00:09:43,349
So NetTraveler is one example

283
00:09:43,349 --> 00:09:45,818
of a APT implant that did a

284
00:09:45,818 --> 00:09:48,554
memory module style
injection technique.

285
00:09:48,554 --> 00:09:50,055
So you can see they've,

286
00:09:50,056 --> 00:09:51,490
if you look at the
actual permissions,

287
00:09:51,490 --> 00:09:53,426
they're not super anomalous.

288
00:09:53,426 --> 00:09:54,427
Rewrite on the header,

289
00:09:54,427 --> 00:09:56,529
read execute for
the code section

290
00:09:56,529 --> 00:09:58,197
and read on the data

291
00:10:00,066 --> 00:10:01,701
and rewrite on the,

292
00:10:01,701 --> 00:10:04,637
whatever the other
data section is.

293
00:10:06,372 --> 00:10:08,107
So if you're just looking
for read write execute,

294
00:10:08,107 --> 00:10:10,810
you're not going to find
something like NetTraveler.

295
00:10:10,810 --> 00:10:13,646
So that's something
to be aware of.

296
00:10:13,646 --> 00:10:15,146
You can also look
at the threads.

297
00:10:15,147 --> 00:10:17,083
Similar to Poison Ivy.

298
00:10:17,083 --> 00:10:18,317
Even though they're
using memory module,

299
00:10:18,317 --> 00:10:19,518
you're still gonna
see that there's

300
00:10:19,518 --> 00:10:21,520
that floating code
unbacked memory there

301
00:10:21,520 --> 00:10:25,257
which is trying to
do HTTP requests.

302
00:10:25,257 --> 00:10:28,526
Winnti is another example
that uses memory module.

303
00:10:28,527 --> 00:10:30,329
They got a little sloppy
on their permission.

304
00:10:30,329 --> 00:10:32,231
So you can see the header
has read write execute.

305
00:10:32,231 --> 00:10:34,634
There's no reason for that

306
00:10:34,634 --> 00:10:36,602
for the functionality
perspective.

307
00:10:36,602 --> 00:10:39,805
But you'll see in a second why

308
00:10:39,805 --> 00:10:41,439
for Winnti they were
smart enough to actually

309
00:10:41,440 --> 00:10:42,408
wipe out the header.

310
00:10:42,408 --> 00:10:44,043
So I think what they did was,

311
00:10:44,043 --> 00:10:44,877
you know they had
allocated correctly

312
00:10:44,877 --> 00:10:46,145
and then they just did,

313
00:10:46,145 --> 00:10:47,446
hey I'm just going to
read write execute this

314
00:10:47,446 --> 00:10:48,714
so I can write to it and
then they zeroed it out.

315
00:10:48,714 --> 00:10:51,450
So it's more difficult
to find for Winnti,

316
00:10:52,852 --> 00:10:57,356
but it's still gonna be unbacked
code that's living there.

317
00:10:57,356 --> 00:10:58,591
Process Hollowing, I'm
sure a lot of people

318
00:10:58,591 --> 00:11:01,727
talked about even
has some new research

319
00:11:01,727 --> 00:11:03,663
for doing more advance
Process Hollowing protection.

320
00:11:03,663 --> 00:11:05,865
Basically this is the formula

321
00:11:05,865 --> 00:11:07,700
for doing Process
Hollowing detection.

322
00:11:07,700 --> 00:11:09,702
Instead of injecting
into existing process,

323
00:11:09,702 --> 00:11:11,604
you're gonna create a
new one that's suspended,

324
00:11:11,604 --> 00:11:14,306
then you do the
allocation writing too.

325
00:11:14,306 --> 00:11:16,742
And then instead of
creating a new thread,

326
00:11:16,742 --> 00:11:18,243
you're just hijacking
that existing thread

327
00:11:18,244 --> 00:11:20,046
that's starts up
with that process.

328
00:11:20,046 --> 00:11:21,280
So you basically,

329
00:11:21,280 --> 00:11:22,714
the thread starts
up as suspended,

330
00:11:22,715 --> 00:11:24,950
you can say SetThreadContext
go over here

331
00:11:24,950 --> 00:11:27,987
start executing with the
Payload that I loaded in there.

332
00:11:27,987 --> 00:11:30,423
And then resume the execution.

333
00:11:30,423 --> 00:11:31,957
And really where the
hollow comes from is,

334
00:11:31,957 --> 00:11:33,426
some typical implementations,

335
00:11:33,426 --> 00:11:35,461
they'll free the memory of
the original EXE that loaded.

336
00:11:35,461 --> 00:11:38,698
There's actually no reason
they have to do that,

337
00:11:38,698 --> 00:11:41,534
it's just done typically.

338
00:11:41,534 --> 00:11:43,102
And then kind of a
more stealthy variance,

339
00:11:43,102 --> 00:11:45,938
I think like Stuxnet was one
of the first that I've seen

340
00:11:45,938 --> 00:11:49,308
that used the crate
section, map section.

341
00:11:49,308 --> 00:11:52,011
So instead of having to actually
call write process memory,

342
00:11:52,011 --> 00:11:53,746
they can avoid that and they
can just map a shared view

343
00:11:53,746 --> 00:11:56,549
of a chunk of memory
between their process,

344
00:11:56,549 --> 00:11:58,050
the remote process.

345
00:11:58,050 --> 00:12:00,252
They're writing to it locally
like they normally would,

346
00:12:00,252 --> 00:12:02,688
but it's kind of
mirrored in both places.

347
00:12:02,688 --> 00:12:06,125
So that's a good way to
avoid detection from PSP,

348
00:12:06,125 --> 00:12:09,061
and also instead of
calling SetThreadContext,

349
00:12:09,061 --> 00:12:10,730
they can just write
like a jump or something

350
00:12:10,730 --> 00:12:13,566
at the starting point
at the original module

351
00:12:13,566 --> 00:12:14,834
it'll jump to the
new code instead

352
00:12:14,834 --> 00:12:17,569
of calling that suspicious API.

353
00:12:17,570 --> 00:12:20,940
DarkComet is kind
of a good example

354
00:12:20,940 --> 00:12:22,608
of piece of malware
that uses hollowing.

355
00:12:22,608 --> 00:12:23,876
And really what you're,

356
00:12:23,876 --> 00:12:25,211
the key to seeing
Process Hollowing,

357
00:12:25,211 --> 00:12:27,046
if you see a CreateProcess
there with the

358
00:12:27,046 --> 00:12:29,348
CreationFlags of
create suspended,

359
00:12:29,348 --> 00:12:31,317
you're probably going
to be looking at

360
00:12:31,317 --> 00:12:33,652
Process Hollowing technique.

361
00:12:35,087 --> 00:12:36,555
The interesting part is
if you look at DarkComet

362
00:12:36,555 --> 00:12:38,556
after it's loaded up,

363
00:12:38,557 --> 00:12:40,059
you can see the base address,

364
00:12:40,059 --> 00:12:44,163
that main module dark.exe
is at that hex address.

365
00:12:44,163 --> 00:12:46,265
But if you actually go look
at the permissions of it

366
00:12:46,265 --> 00:12:48,834
and the type of memory
that's allocated there,

367
00:12:48,834 --> 00:12:51,337
it's private commit
which is to never happen.

368
00:12:51,337 --> 00:12:56,075
A module either dl.exe is
always going to in image.

369
00:12:56,075 --> 00:12:58,110
So just the fact
that that's pointing

370
00:12:58,110 --> 00:13:02,548
to a private section
memory is very anomalous.

371
00:13:02,548 --> 00:13:04,250
Module Overwriting is kind of,

372
00:13:04,250 --> 00:13:05,417
we're starting to get into

373
00:13:05,417 --> 00:13:06,919
a little more
advanced territory.

374
00:13:06,919 --> 00:13:08,187
So up until now,

375
00:13:08,187 --> 00:13:09,288
all of the examples
that we talked about

376
00:13:09,288 --> 00:13:11,557
really end up with unbacked code

377
00:13:11,557 --> 00:13:14,026
or floating code
executing in memory.

378
00:13:14,026 --> 00:13:16,262
But some more advanced APTs

379
00:13:17,429 --> 00:13:18,930
can avoid this so even if its,

380
00:13:18,931 --> 00:13:21,967
they can actually live in
that image type memory.

381
00:13:21,967 --> 00:13:24,303
So this is something
you should be aware of.

382
00:13:24,303 --> 00:13:26,672
But basically, I don't know if

383
00:13:26,672 --> 00:13:27,973
there's an official
term for this,

384
00:13:27,973 --> 00:13:30,008
I refer to it as
Module Overwriting.

385
00:13:30,009 --> 00:13:31,477
But basically, so Flame
what it would do is,

386
00:13:31,477 --> 00:13:34,646
it would load Shell 32
into a target process.

387
00:13:34,647 --> 00:13:36,248
And the reason
they chose Shell 32

388
00:13:36,248 --> 00:13:37,516
is because it's huge,

389
00:13:37,516 --> 00:13:39,050
one of the biggest
DLLs in system 32.

390
00:13:39,051 --> 00:13:40,619
And the Flame implant
itself was huge.

391
00:13:40,619 --> 00:13:42,588
So they didn't really have
a whole lot of options.

392
00:13:42,588 --> 00:13:47,226
And Careto, they would choose
from random list of DLLs.

393
00:13:47,226 --> 00:13:49,395
Because first you actually had
a great paper out on Careto

394
00:13:49,395 --> 00:13:51,497
that you can read about.

395
00:13:51,497 --> 00:13:53,998
But basically
instead of creating a

396
00:13:53,999 --> 00:13:55,467
new suspended process,

397
00:13:55,467 --> 00:13:56,468
what they would do is they
would have their target process,

398
00:13:56,468 --> 00:13:57,803
and they would map a new DLL

399
00:13:57,803 --> 00:13:59,905
that wasn't being used
into that target process

400
00:13:59,905 --> 00:14:03,007
and then they would overwrite
that with their actual,

401
00:14:03,008 --> 00:14:05,244
their implant in memory.

402
00:14:05,244 --> 00:14:06,912
So it's not floating,

403
00:14:06,912 --> 00:14:10,316
but it's living off
on top of what was

404
00:14:10,316 --> 00:14:13,919
a legitimate Shell 32
Microsoft application

405
00:14:13,919 --> 00:14:15,420
or some other DLL.

406
00:14:16,622 --> 00:14:18,424
So Odinaff actually
had a similar trick,

407
00:14:18,424 --> 00:14:20,559
but instead of overwriting DLL,

408
00:14:20,559 --> 00:14:23,562
they actually overrode
their own exe space

409
00:14:23,562 --> 00:14:26,131
which was kind of different.

410
00:14:26,131 --> 00:14:27,565
And they way you
would detect this

411
00:14:27,566 --> 00:14:29,802
was doing in memory versus
on disk comparisons.

412
00:14:29,802 --> 00:14:32,605
So this is just a
dump of the P headers

413
00:14:32,605 --> 00:14:34,373
of on disk Odinaff
versus in memory Odinaff.

414
00:14:34,373 --> 00:14:37,376
And if you look at
the Linker version

415
00:14:37,376 --> 00:14:39,879
and address the entry
points size of the code,

416
00:14:39,879 --> 00:14:41,714
it all differs between
what's in memory

417
00:14:41,714 --> 00:14:43,716
versus what's on disk.

418
00:14:43,716 --> 00:14:44,850
And actually what it does is,

419
00:14:44,850 --> 00:14:46,085
when it first starts up,

420
00:14:46,085 --> 00:14:47,853
in the Odinaff exe
first starts up,

421
00:14:47,853 --> 00:14:49,822
it'll allocate a little
chunk of shellcode

422
00:14:49,822 --> 00:14:51,457
that basically
goes and when that

423
00:14:51,457 --> 00:14:52,858
shellcode starts executing,

424
00:14:52,858 --> 00:14:54,425
it'll read back from
the original file,

425
00:14:54,426 --> 00:14:57,129
decrypt that and then
overwrite your original code

426
00:14:57,129 --> 00:14:58,297
in memory and then jump to it.

427
00:14:58,297 --> 00:15:01,267
So it's a way for them to avoid

428
00:15:01,267 --> 00:15:02,334
being detected in signatures.

429
00:15:02,334 --> 00:15:03,669
It's not totally fileless,

430
00:15:03,669 --> 00:15:05,137
but it's still an
in memory technique.

431
00:15:05,137 --> 00:15:07,039
You know the true
code that's executing

432
00:15:07,039 --> 00:15:09,074
is only living in memory.

433
00:15:09,074 --> 00:15:10,209
And the way you can find it

434
00:15:10,209 --> 00:15:11,410
is by looking at that between

435
00:15:11,410 --> 00:15:13,379
what's on disk versus
what's in memory.

436
00:15:13,379 --> 00:15:14,613
I would say PEB Unlinking

437
00:15:14,613 --> 00:15:16,782
just deserves kind
of a quick mention.

438
00:15:16,782 --> 00:15:20,019
You're almost getting into
root kit type of techniques,

439
00:15:20,019 --> 00:15:21,220
but it's still fairly common.

440
00:15:21,220 --> 00:15:23,789
So like HackingTeam
uses this in their RAT.

441
00:15:23,789 --> 00:15:25,491
Flame actually unlinked shell32.

442
00:15:25,491 --> 00:15:27,660
So if you're just
looking for shell32

443
00:15:27,660 --> 00:15:28,794
loaded in the processes,

444
00:15:28,794 --> 00:15:30,062
you might miss this.

445
00:15:30,062 --> 00:15:31,063
So it's something
to be aware of.

446
00:15:31,063 --> 00:15:32,665
It's something to look for.

447
00:15:32,665 --> 00:15:34,065
And basically the
way you find it is,

448
00:15:34,066 --> 00:15:37,336
you can ask the
higher-level APIs

449
00:15:37,336 --> 00:15:39,338
that basically walk through
the process environment block

450
00:15:39,338 --> 00:15:40,906
and give you the list
of DLLs and you say,

451
00:15:40,906 --> 00:15:42,373
hey what's loading this process.

452
00:15:42,374 --> 00:15:44,476
Then you go ask the kernel
with a different API and say,

453
00:15:44,476 --> 00:15:46,178
hey what's actually
loading this process?

454
00:15:46,178 --> 00:15:47,880
When you do a diff of the two,

455
00:15:47,880 --> 00:15:49,415
if there's something that the
kernel's telling you is there,

456
00:15:49,415 --> 00:15:51,617
that the higher-level
API is not telling you,

457
00:15:51,617 --> 00:15:55,087
then you know that you got
some PEB unlinking going on.

458
00:15:55,087 --> 00:15:59,124
And then last I'll
talk about Gargoyle.

459
00:15:59,124 --> 00:16:00,059
So this is actually
a cool technique.

460
00:16:00,059 --> 00:16:02,861
This was out pretty recently.

461
00:16:02,861 --> 00:16:04,295
So up until now,

462
00:16:04,296 --> 00:16:08,434
even with the image like
module overwriting type stuff,

463
00:16:08,434 --> 00:16:12,338
you always have some plus x
section of memory that's running

464
00:16:12,338 --> 00:16:16,208
and this is security researcher
just proof of concept code.

465
00:16:16,208 --> 00:16:17,776
Basically what he wanted
to prove was that,

466
00:16:17,776 --> 00:16:21,546
even if you're a PSP
product or a hunter,

467
00:16:21,547 --> 00:16:24,450
you can't just rely on
looking for plus x memory

468
00:16:24,450 --> 00:16:26,352
because what he
actually proved is

469
00:16:26,352 --> 00:16:29,788
you can basically make the
Payload lie dormant in memory.

470
00:16:29,788 --> 00:16:34,026
And then he used like an
exploitation style technique

471
00:16:34,026 --> 00:16:36,027
in order to market as
executable on demand.

472
00:16:36,028 --> 00:16:38,197
So he's got like this
asynchronous procedure

473
00:16:38,197 --> 00:16:39,732
called Timer that
basically triggers

474
00:16:39,732 --> 00:16:41,433
on whatever basis you want.

475
00:16:41,433 --> 00:16:42,601
You can set it for 10 seconds,

476
00:16:42,601 --> 00:16:44,870
20 seconds, 20
minutes, hour, days,

477
00:16:44,870 --> 00:16:46,538
whatever you want and basically

478
00:16:46,538 --> 00:16:47,906
when that timer triggers,

479
00:16:47,906 --> 00:16:49,808
it actually starts
executing a ROP chain.

480
00:16:49,808 --> 00:16:53,379
And that ROP chain
will basically set the

481
00:16:53,379 --> 00:16:55,881
permissions of your
Payload as executable

482
00:16:55,881 --> 00:16:57,850
just for a brief point in time.

483
00:16:57,850 --> 00:17:00,319
So executing it and then set
some calls at the end of it

484
00:17:00,319 --> 00:17:02,420
and basically sets
it back to read only

485
00:17:02,421 --> 00:17:03,522
and then goes back to sleep.

486
00:17:03,522 --> 00:17:04,823
So it's really cool.

487
00:17:04,823 --> 00:17:06,759
So you got this piece
of code that you know,

488
00:17:06,759 --> 00:17:08,293
if you were just
doing a quick sweep,

489
00:17:08,292 --> 00:17:10,661
yeah just show me
what's executable memory

490
00:17:10,662 --> 00:17:13,132
you might completely
miss this technique.

491
00:17:13,132 --> 00:17:15,334
So it's something
to be aware of.

492
00:17:15,334 --> 00:17:16,769
It's kind of new.

493
00:17:16,769 --> 00:17:18,737
I've never seen an actual
implant use it yet.

494
00:17:18,737 --> 00:17:19,972
That doesn't mean
it's not out there.

495
00:17:19,972 --> 00:17:21,006
If anyone knows of an
actual implant that

496
00:17:21,006 --> 00:17:22,541
uses a similar technique,

497
00:17:22,540 --> 00:17:24,842
come talk to me because I
would love to look at it.

498
00:17:24,843 --> 00:17:27,246
But you definitely
want to keep your eyes

499
00:17:27,246 --> 00:17:28,680
on stuff like this because

500
00:17:28,680 --> 00:17:29,681
it's only a matter
of time before

501
00:17:29,681 --> 00:17:32,217
you start seeing
stuff like this.

502
00:17:32,217 --> 00:17:35,587
Because it's a great evasion
from security products.

503
00:17:35,587 --> 00:17:37,289
Alright so that's kind
of like the run through

504
00:17:37,289 --> 00:17:40,826
of what the attacker
techniques are.

505
00:17:40,826 --> 00:17:42,561
So how do you go
and how do you find

506
00:17:42,561 --> 00:17:45,030
these attacker techniques?

507
00:17:45,030 --> 00:17:48,533
Well, I think an
important tenant is to be

508
00:17:50,035 --> 00:17:51,370
not say short based at all,

509
00:17:51,370 --> 00:17:52,638
it has to be based
on the behavior.

510
00:17:52,638 --> 00:17:53,871
There's always going
to be a new implant.

511
00:17:53,872 --> 00:17:55,074
There's always going
to be new signatures.

512
00:17:55,074 --> 00:17:56,642
But you know, there's
only a limited set

513
00:17:56,642 --> 00:17:57,810
of the techniques they use.

514
00:17:57,810 --> 00:17:59,778
I like Volatility
malfind for this reason

515
00:17:59,778 --> 00:18:02,014
because it looks
more on the behaviors

516
00:18:02,014 --> 00:18:03,615
of what it's doing.

517
00:18:05,050 --> 00:18:06,918
The only downside to doing
a full memory forensics

518
00:18:06,919 --> 00:18:08,754
is obviously like the scale.

519
00:18:08,754 --> 00:18:09,921
So it's good if you know.

520
00:18:09,922 --> 00:18:11,457
If you have like a
suspicious workstation.

521
00:18:11,457 --> 00:18:14,193
You want to do a typical
forensic process,

522
00:18:14,193 --> 00:18:15,860
then that'll work great.

523
00:18:15,861 --> 00:18:18,530
But really these types
of questions like,

524
00:18:18,530 --> 00:18:20,165
hey what's running in
memory across my network?

525
00:18:20,165 --> 00:18:21,767
Like that's something you
want to be able to ask

526
00:18:21,767 --> 00:18:24,670
and have an answer back
pretty quick and be able,

527
00:18:24,670 --> 00:18:26,638
you know you if you got
50 thousand points doing

528
00:18:26,638 --> 00:18:29,541
full memory forensics
across those endpoints

529
00:18:29,541 --> 00:18:31,577
are very difficult.

530
00:18:31,577 --> 00:18:32,778
So that's the only drawback from

531
00:18:32,778 --> 00:18:34,880
the full forensic approach.

532
00:18:34,880 --> 00:18:38,083
GRR and Rekall they're
kind of similar.

533
00:18:38,083 --> 00:18:40,886
They're built on
similar code bases.

534
00:18:40,886 --> 00:18:42,354
I think it's pretty cool that

535
00:18:42,354 --> 00:18:44,389
some of the scaling I've seen
in GRR looks kind of cool.

536
00:18:44,389 --> 00:18:45,724
Like you can do,

537
00:18:45,724 --> 00:18:47,326
if you have the rule you
can go search in memory

538
00:18:47,326 --> 00:18:49,595
for certain techniques.

539
00:18:49,595 --> 00:18:50,863
And that would work for,

540
00:18:50,863 --> 00:18:52,364
let's say like the
reflective loader.

541
00:18:52,364 --> 00:18:53,765
You can search for
that strain for any,

542
00:18:53,765 --> 00:18:55,834
you'll find some
stuff with that.

543
00:18:55,834 --> 00:18:59,171
But it's not necessarily
technique based.

544
00:18:59,171 --> 00:19:01,673
That's the only downfall.

545
00:19:01,673 --> 00:19:03,542
inVtero was something new to me.

546
00:19:03,542 --> 00:19:05,744
It was actually
just presented at

547
00:19:05,744 --> 00:19:07,980
CanSecWest not too long ago

548
00:19:07,980 --> 00:19:10,182
and I think it's Cloud
focused from what I can tell.

549
00:19:10,182 --> 00:19:11,450
But looking through the code,

550
00:19:11,450 --> 00:19:13,519
you actually had some
pretty cool detections

551
00:19:13,519 --> 00:19:15,354
that he had built in like some

552
00:19:15,354 --> 00:19:19,491
doing like call stack
analysis and ROP checks

553
00:19:19,491 --> 00:19:20,993
built into the tool.

554
00:19:20,993 --> 00:19:22,160
So I would say keep
your eye on that.

555
00:19:22,161 --> 00:19:24,930
That could be something
that's interesting

556
00:19:24,930 --> 00:19:26,298
as it progresses and matures,

557
00:19:26,298 --> 00:19:28,333
but I don't know if that's still

558
00:19:28,333 --> 00:19:29,902
more Cloud focused
or something that

559
00:19:29,902 --> 00:19:34,206
would be more applicable
for work stations and stuff.

560
00:19:34,206 --> 00:19:38,443
I think our approach
is not going to replace

561
00:19:38,443 --> 00:19:39,945
full memory forensics,

562
00:19:39,945 --> 00:19:43,849
but you'll see that it's
better for different ways,

563
00:19:43,849 --> 00:19:46,185
particularly for the
scale and the fact that

564
00:19:46,185 --> 00:19:49,488
it doesn't use any type
of signatures and stuff.

565
00:19:49,488 --> 00:19:51,223
It's more based on the behavior.

566
00:19:51,223 --> 00:19:52,591
So take it over
Jared and finish.

567
00:19:52,591 --> 00:19:55,194
- Yeah so if anybody's followed

568
00:19:55,194 --> 00:19:56,595
any of my work over
the past few years,

569
00:19:56,595 --> 00:19:57,996
you'd know that I'm basically

570
00:19:57,996 --> 00:19:59,765
one of the biggest
PowerShell fanboys and so

571
00:19:59,765 --> 00:20:01,767
kind of a little
background about that is,

572
00:20:01,767 --> 00:20:03,602
I previously was in
the Air Force and

573
00:20:03,602 --> 00:20:05,170
Air Force just
like any big entity

574
00:20:05,170 --> 00:20:08,473
has certification and
accreditation procedures

575
00:20:08,473 --> 00:20:09,675
and a really long timeline.

576
00:20:09,675 --> 00:20:11,577
So if you want to
introduce a new tool,

577
00:20:11,577 --> 00:20:12,644
you have to say,

578
00:20:12,644 --> 00:20:13,879
okay here's the new tool.

579
00:20:13,879 --> 00:20:15,813
It has to go through
months and months

580
00:20:15,814 --> 00:20:17,182
of certification
and accreditation

581
00:20:17,182 --> 00:20:19,084
before you could
actually use it.

582
00:20:19,084 --> 00:20:20,085
But I was told that,

583
00:20:20,085 --> 00:20:21,587
hey if it's a script,

584
00:20:21,587 --> 00:20:23,254
scripts don't need to be
certified and accredited,

585
00:20:23,255 --> 00:20:25,557
so you can just run scripts
kind of willy nilly.

586
00:20:25,557 --> 00:20:29,294
Well, PowerShell has
access to the Windows API

587
00:20:29,294 --> 00:20:31,330
just like a C program
would have, right?

588
00:20:31,330 --> 00:20:34,633
And so it's a little
bit harder, I guess,

589
00:20:34,633 --> 00:20:36,902
or less direct to be
able to call those APIs

590
00:20:36,902 --> 00:20:39,338
but you can literally script
anything in PowerShell.

591
00:20:39,338 --> 00:20:40,639
Anything that you would do in C,

592
00:20:40,639 --> 00:20:43,375
you can do in
PowerShell on Windows.

593
00:20:43,375 --> 00:20:45,644
And so I decided to kind
of go down that path

594
00:20:45,644 --> 00:20:47,813
and everything I
do is a script now.

595
00:20:47,813 --> 00:20:49,414
Although it's doing
similar things

596
00:20:49,414 --> 00:20:52,317
to what those compiled
binaries would be doing.

597
00:20:52,317 --> 00:20:54,119
So we're gonna look at
how we would detect that

598
00:20:54,119 --> 00:20:57,656
floating injection that
Joe was discussing.

599
00:20:57,656 --> 00:21:01,592
One of the projects that
this script is built around

600
00:21:01,593 --> 00:21:04,062
is called PSReflect and so this
was written by Matt Graeber,

601
00:21:04,062 --> 00:21:05,930
a former colleague of mine.

602
00:21:05,931 --> 00:21:07,366
You can check it out on GitHub.

603
00:21:07,366 --> 00:21:08,600
What he did is,

604
00:21:08,600 --> 00:21:10,135
he allows you to use reflection

605
00:21:10,135 --> 00:21:12,037
and he's kind of written
a domain specific language

606
00:21:12,037 --> 00:21:13,639
that allows you to
call these Windows APIs

607
00:21:13,639 --> 00:21:17,842
from PowerShell without
knowing all the background

608
00:21:17,843 --> 00:21:21,146
that you would need to
do to do it on your own.

609
00:21:21,146 --> 00:21:23,615
There's a couple other
methods or techniques

610
00:21:23,615 --> 00:21:24,850
that you could use
from PowerShell

611
00:21:24,850 --> 00:21:26,083
to call Windows APIs.

612
00:21:26,084 --> 00:21:27,419
One is called Platform
Invoke, or P Invoke.

613
00:21:27,419 --> 00:21:29,821
If you're familiar with it.

614
00:21:29,821 --> 00:21:32,791
Platform Invoke is
not super clean.

615
00:21:32,791 --> 00:21:36,962
It actually does just in time
compilation of C Shark code

616
00:21:38,797 --> 00:21:40,065
to be able to access those APIs.

617
00:21:40,065 --> 00:21:41,566
And so there's
compilation artifacts

618
00:21:41,566 --> 00:21:43,535
that are strewn
about the file system

619
00:21:43,535 --> 00:21:45,937
and so kind of from a responder

620
00:21:45,937 --> 00:21:47,606
or forensic type perspective.

621
00:21:47,606 --> 00:21:49,107
Or even a red
teamer's perspective,

622
00:21:49,107 --> 00:21:51,410
Platform Invoke is probably
not the best way to go.

623
00:21:51,410 --> 00:21:53,145
And so that's why
Reflection is really cool

624
00:21:53,145 --> 00:21:55,914
because it all
happens in memory.

625
00:21:57,616 --> 00:22:00,118
So the script that we wrote

626
00:22:00,118 --> 00:22:01,620
is called Get-Injected Thread.

627
00:22:01,620 --> 00:22:02,987
Like I said, built on PSReflect

628
00:22:02,988 --> 00:22:05,924
and so kind of the
methadology that we use is,

629
00:22:05,924 --> 00:22:07,859
is we use Windows Toolhelp API

630
00:22:07,859 --> 00:22:09,860
to get every thread
on the system.

631
00:22:09,861 --> 00:22:11,630
Then we kind of iterate
through those threads

632
00:22:11,630 --> 00:22:13,065
and then check,

633
00:22:13,065 --> 00:22:13,999
basically ask the thread,

634
00:22:13,999 --> 00:22:15,233
hey what's your base address?

635
00:22:15,233 --> 00:22:17,135
What's the starting
point in memory

636
00:22:17,135 --> 00:22:19,971
where the code for
this thread lives?

637
00:22:19,971 --> 00:22:23,375
Then we query the memory
page for that base address

638
00:22:23,375 --> 00:22:24,810
and check a couple of things.

639
00:22:24,810 --> 00:22:26,043
One is we check to see if that

640
00:22:26,044 --> 00:22:28,180
base address memory
page is committed.

641
00:22:28,180 --> 00:22:31,516
Meaning it's allocated
or it's being used.

642
00:22:31,516 --> 00:22:34,453
And then we check and see
if the memory page type

643
00:22:34,453 --> 00:22:36,687
is not memory image.

644
00:22:36,688 --> 00:22:40,359
So meaning that
there's a file backing

645
00:22:40,359 --> 00:22:41,193
that memory page.

646
00:22:41,193 --> 00:22:42,860
If a memory page,

647
00:22:42,861 --> 00:22:46,365
or if a thread's base
address is committed

648
00:22:46,365 --> 00:22:47,632
and not backed by a file,

649
00:22:47,632 --> 00:22:49,201
then that's what
we discover a hit,

650
00:22:49,201 --> 00:22:52,637
or something that we
should look into it.

651
00:22:52,637 --> 00:22:54,806
Form that point, we
go in and look at

652
00:22:54,806 --> 00:22:57,042
a few different
pieces of information

653
00:22:57,042 --> 00:22:59,244
and we might want to check
the memory page permissions.

654
00:22:59,244 --> 00:23:01,379
So is this page
read write execute?

655
00:23:01,380 --> 00:23:04,182
Is is read write, what
are the permissions?

656
00:23:04,182 --> 00:23:06,952
I would look at unnecessary
privileges or integrity levels.

657
00:23:06,952 --> 00:23:10,922
So like does this thread
has SED bug privilege?

658
00:23:10,922 --> 00:23:13,959
Does it have high
integrity lever,

659
00:23:13,959 --> 00:23:16,795
meaning it's bypassed the UAC,

660
00:23:16,795 --> 00:23:18,163
the user access control prompt.

661
00:23:18,163 --> 00:23:20,399
You can also look for
abnormal user tokens.

662
00:23:20,399 --> 00:23:23,301
Is this the process that
this thread belongs to?

663
00:23:23,301 --> 00:23:25,771
Is it running under normal user

664
00:23:25,771 --> 00:23:29,541
but has a system
token associated with
this specific thread.

665
00:23:29,541 --> 00:23:32,610
You know that might be something
that's worth looking into.

666
00:23:32,611 --> 00:23:33,545
And so here's some of the things

667
00:23:33,545 --> 00:23:34,780
that we get in the output.

668
00:23:34,780 --> 00:23:36,281
We get things like
Process Information.

669
00:23:36,281 --> 00:23:38,716
Process ID, name, the file path

670
00:23:38,717 --> 00:23:40,585
and we query that in
two different ways.

671
00:23:40,585 --> 00:23:43,221
So he talked about
PEB unlinking.

672
00:23:43,221 --> 00:23:45,190
But the process
environment block

673
00:23:45,190 --> 00:23:46,925
is something that an
attacker can change

674
00:23:46,925 --> 00:23:49,261
and so you can't necessarily
trust the information

675
00:23:49,261 --> 00:23:50,896
that you get back from the
process environment block.

676
00:23:50,896 --> 00:23:53,264
And so we can do is
use different APIs

677
00:23:53,265 --> 00:23:55,400
to query the process
environment block

678
00:23:55,400 --> 00:23:57,035
and the Eprocess structure

679
00:23:57,035 --> 00:23:59,004
which would allow us to compare

680
00:23:59,004 --> 00:24:01,973
to see if there's been any
changes to the file path.

681
00:24:01,973 --> 00:24:03,841
We can also check
the command line.

682
00:24:03,842 --> 00:24:05,710
We can then look at
the thread information.

683
00:24:05,710 --> 00:24:08,413
The thread ID, whether or
not there's a unique token,

684
00:24:08,413 --> 00:24:10,715
user token for the thread.

685
00:24:10,715 --> 00:24:12,082
Check the base priority so

686
00:24:12,083 --> 00:24:15,220
has somebody made
this thread more

687
00:24:15,220 --> 00:24:17,222
important than other threads.

688
00:24:17,222 --> 00:24:18,256
Does this thread
have a unique token.

689
00:24:18,256 --> 00:24:19,491
I kind of already said that.

690
00:24:19,491 --> 00:24:20,759
And then the memory segment.

691
00:24:20,759 --> 00:24:22,127
So we can look at
the base address,

692
00:24:22,127 --> 00:24:24,696
the size, protections,
states, type,

693
00:24:24,696 --> 00:24:26,497
and then I give you
the first 100 bytes

694
00:24:26,498 --> 00:24:28,366
of the memory segment
so that you kind of

695
00:24:28,366 --> 00:24:30,602
do a little manual analysis.

696
00:24:30,602 --> 00:24:32,204
And then kind of
token information,

697
00:24:32,204 --> 00:24:36,374
integrity level has this
thread or token bypass the UAC.

698
00:24:37,642 --> 00:24:38,877
What privileges are enabled?

699
00:24:38,877 --> 00:24:41,646
Like SED bug, SE
impersonate token,

700
00:24:41,646 --> 00:24:44,616
the SID or user
name of the token,

701
00:24:44,616 --> 00:24:46,084
Login session start time,

702
00:24:46,084 --> 00:24:48,653
logon type and then the
authentication package used.

703
00:24:48,653 --> 00:24:50,121
So logon type might
be interesting because

704
00:24:50,121 --> 00:24:51,656
you can check to
see if it's been

705
00:24:51,656 --> 00:24:55,527
a network logon or a
local logon for example.

706
00:24:55,527 --> 00:24:57,896
Alright so here's the
first kind of demo

707
00:24:57,896 --> 00:24:58,897
that we're going to do.

708
00:24:58,897 --> 00:25:00,398
This is a really
simplistic demo.

709
00:25:00,398 --> 00:25:02,367
Joe wrote a program
called Thread Start

710
00:25:02,367 --> 00:25:04,970
which is going to literally
start an application

711
00:25:04,970 --> 00:25:09,608
and inject a thread that's
not backed by a file on disk.

712
00:25:09,608 --> 00:25:12,110
And then we'll just show kind
of generically detecting that.

713
00:25:12,110 --> 00:25:15,379
Alright just running
Get Injected Thread once

714
00:25:15,380 --> 00:25:17,449
showing that nothing came back.

715
00:25:17,449 --> 00:25:19,851
This is a clean system for now.

716
00:25:19,851 --> 00:25:21,086
Kind of clearing that out.

717
00:25:21,086 --> 00:25:22,821
Now we're going to go
over and click on this.

718
00:25:22,821 --> 00:25:25,657
We see that we've
started a threadstart.exe

719
00:25:25,657 --> 00:25:26,824
it's malicious thread test.

720
00:25:26,825 --> 00:25:29,461
The thread ID is 2756.

721
00:25:29,461 --> 00:25:33,431
So now if we run Get
Injected Thread again,

722
00:25:33,431 --> 00:25:35,567
we now see that
we found a thread

723
00:25:35,567 --> 00:25:38,003
which is thread ID 2756.

724
00:25:38,003 --> 00:25:39,737
We see that it's
threadstart.exe is the program

725
00:25:39,738 --> 00:25:41,773
that it has been injected into.

726
00:25:41,773 --> 00:25:43,908
And then we're able to actually
check the base address.

727
00:25:43,909 --> 00:25:45,911
So here you see 0XD0000.

728
00:25:47,345 --> 00:25:52,050
Which if we translate that
from hexadecimal to decimal,

729
00:25:52,050 --> 00:25:55,954
then we see it's 851968 which
is what the base address is.

730
00:25:55,954 --> 00:25:57,489
So we see that this is detecting

731
00:25:57,489 --> 00:25:59,057
what we expected it to detect.

732
00:25:59,057 --> 00:26:01,226
This is kind of our unit test,

733
00:26:01,226 --> 00:26:04,696
for lack of a
better explanation.

734
00:26:04,696 --> 00:26:05,964
Alright so that's great.

735
00:26:05,964 --> 00:26:07,131
We detected our own
thing that we wrote.

736
00:26:07,132 --> 00:26:09,234
And it's super
basic but what about

737
00:26:09,234 --> 00:26:11,636
looking at some real
malware that uses injection.

738
00:26:11,636 --> 00:26:14,773
Alright so there's
this Palo Alto network

739
00:26:14,773 --> 00:26:17,408
that did a writeup on
this Trojan they called

740
00:26:17,409 --> 00:26:18,743
the 9002 Trojan.

741
00:26:20,178 --> 00:26:23,048
It was delivered via a zip
file from Google drive.

742
00:26:23,048 --> 00:26:24,549
And then the zip file
contained one file,

743
00:26:24,549 --> 00:26:27,118
so it was an executable that was

744
00:26:27,118 --> 00:26:29,921
masquerading as a PowerPoint
presentation, right?

745
00:26:29,921 --> 00:26:32,123
And so it had the
PowerPoint icon

746
00:26:32,123 --> 00:26:33,191
and so you would
double click on it,

747
00:26:33,191 --> 00:26:35,594
it would drop a PowerPoint file,

748
00:26:35,594 --> 00:26:38,530
open that file up but also
execute the executable.

749
00:26:38,530 --> 00:26:42,167
A couple files that
have then drops are

750
00:26:42,167 --> 00:26:46,137
realnetwork.exe,
main.dll, mpamedia.dll,

751
00:26:46,137 --> 00:26:49,841
mpamedia, realnetwork.exe
is a real, actual file.

752
00:26:49,841 --> 00:26:52,744
It's digitally signed
by a legitimate company.

753
00:26:52,744 --> 00:26:54,846
But it's vulnerable
to DLL side loading,

754
00:26:54,846 --> 00:26:58,783
and so they drop a
malicious mpamedia.dll file.

755
00:26:58,783 --> 00:27:01,919
That thing gets loaded
up into realnetwork.exe

756
00:27:01,920 --> 00:27:04,656
and then loads up main.dll

757
00:27:04,656 --> 00:27:06,291
which is the malicious thread

758
00:27:06,291 --> 00:27:08,126
that's going to be created.

759
00:27:08,126 --> 00:27:11,596
Alright, so let's check
out what that looks like.

760
00:27:11,596 --> 00:27:14,165
Alright so you see here,

761
00:27:14,165 --> 00:27:16,334
my Get Injected Thread
just to kind of show

762
00:27:16,334 --> 00:27:17,902
that nothing came back.

763
00:27:17,902 --> 00:27:19,170
And then you see
there's a PowerPoint

764
00:27:19,170 --> 00:27:21,706
presentation over on the
left side of the desktop

765
00:27:21,706 --> 00:27:22,640
and double-click on it.

766
00:27:22,641 --> 00:27:23,808
It's really inexecutable.

767
00:27:23,808 --> 00:27:26,277
It just looks, is masquerading.

768
00:27:26,277 --> 00:27:27,512
It opens up PowerPoint.

769
00:27:27,512 --> 00:27:29,714
You see that there's a
file dropped down below.

770
00:27:29,714 --> 00:27:32,716
Here's that PowerPoint
presentation.

771
00:27:33,585 --> 00:27:34,819
And so hey it looks like it did

772
00:27:34,819 --> 00:27:37,322
exactly what we
expected it to do.

773
00:27:37,322 --> 00:27:38,322
If we go back,

774
00:27:38,323 --> 00:27:41,126
there's a new presentation.

775
00:27:41,126 --> 00:27:45,129
If we go back and we check
the injected threads,

776
00:27:46,631 --> 00:27:48,633
we see that there's
three injected threads

777
00:27:48,633 --> 00:27:52,203
and realnetwork.exe
is the victim process.

778
00:27:55,573 --> 00:27:57,075
So then we're able to see

779
00:27:57,075 --> 00:28:00,779
for instance the page is
allocated execute read write

780
00:28:00,779 --> 00:28:02,313
which is RWX.

781
00:28:02,313 --> 00:28:04,616
We also see that
under the user folder,

782
00:28:04,616 --> 00:28:06,918
there is a directory
that was created

783
00:28:06,918 --> 00:28:09,087
that is arbitrarily named.

784
00:28:10,655 --> 00:28:11,656
Alright and so,

785
00:28:11,656 --> 00:28:12,823
if we look inside of that,

786
00:28:12,824 --> 00:28:13,892
we see realnetwork.exe,

787
00:28:13,892 --> 00:28:15,660
main.dll mpaplugins

788
00:28:15,660 --> 00:28:17,295
and that mpamedia.dll

789
00:28:17,295 --> 00:28:21,466
which is that maliciously
loaded DLL side loaded DLL.

790
00:28:24,069 --> 00:28:26,337
One of the interesting
things is that,

791
00:28:26,337 --> 00:28:28,873
what is it bxqls,
l-e-s directory

792
00:28:28,873 --> 00:28:30,442
is a hidden directory.

793
00:28:30,442 --> 00:28:32,377
So just kind of an extra thing

794
00:28:32,377 --> 00:28:35,413
that we wouldn't be able to
necessarily see as easily

795
00:28:35,413 --> 00:28:37,749
without the injected thread.

796
00:28:38,917 --> 00:28:40,718
Alright so what are
some of the responses

797
00:28:40,719 --> 00:28:42,120
that we could take to
this type of situation?

798
00:28:42,120 --> 00:28:45,657
So let's say an attacker
injects in the lstats

799
00:28:45,657 --> 00:28:48,993
or some service that's necessary

800
00:28:48,993 --> 00:28:50,695
for the computer to run, right?

801
00:28:50,695 --> 00:28:52,030
So you can't just kill lstats

802
00:28:52,030 --> 00:28:54,331
because that will blue
screen your computer.

803
00:28:54,332 --> 00:28:56,401
How do you kind of get rid

804
00:28:56,401 --> 00:28:57,736
of this injected thread.

805
00:28:57,736 --> 00:28:58,670
Well you can actually,

806
00:28:58,670 --> 00:28:59,771
because we know the thread ID

807
00:28:59,771 --> 00:29:01,272
and the process that it's in,

808
00:29:01,272 --> 00:29:03,006
we can actually on in and
kill that individual thread,

809
00:29:03,007 --> 00:29:06,244
and so I also wrote a
PowerShell script that allows us

810
00:29:06,244 --> 00:29:08,012
to stop an individual thread.

811
00:29:08,012 --> 00:29:10,081
And that's built on Windows
terminate thread API.

812
00:29:10,081 --> 00:29:13,318
You can also do
process mini dumps.

813
00:29:13,318 --> 00:29:16,254
So, Matt Graeber also
wrote a script called

814
00:29:16,254 --> 00:29:18,956
Out-minidump which allows you to

815
00:29:18,957 --> 00:29:23,061
create a mini dump which
is like a crash report

816
00:29:23,061 --> 00:29:25,764
dump and then you can use WinDbg

817
00:29:25,764 --> 00:29:27,799
or another debugger to
kind of look through that

818
00:29:27,799 --> 00:29:29,868
crash dump to see
what's going on.

819
00:29:29,868 --> 00:29:32,337
You could also something
like dump that thread.

820
00:29:32,337 --> 00:29:34,973
So that's another concept
that you will be able to do.

821
00:29:34,973 --> 00:29:38,443
So just dump that
thread's memory address

822
00:29:38,443 --> 00:29:42,046
so you can use Process Hacker
or PowerShell to do that.

823
00:29:42,046 --> 00:29:46,217
And so, here's another
continuing on from
where we started.

824
00:29:46,217 --> 00:29:49,621
We're gonna go ahead
and kill the thread.

825
00:29:51,856 --> 00:29:53,091
Got Process Hacker
on the side here.

826
00:29:53,091 --> 00:29:55,226
So we see there's
four injected threads.

827
00:29:55,226 --> 00:29:56,694
We realnetwork.exe.

828
00:29:56,694 --> 00:29:58,463
We see Thread 920.

829
00:29:58,463 --> 00:30:00,130
1664, 1644,and 3244.

830
00:30:02,433 --> 00:30:07,272
Those are all malicious
threads in realnetwork.exe

831
00:30:07,272 --> 00:30:09,674
So we go in look at the threads.

832
00:30:09,674 --> 00:30:11,576
Thread's here there's number of

833
00:30:11,576 --> 00:30:12,811
legitimate threads,

834
00:30:12,811 --> 00:30:15,813
but there's also the
malicious ones so.

835
00:30:16,648 --> 00:30:17,782
You go in.

836
00:30:17,782 --> 00:30:19,184
So we have Thread 920.

837
00:30:19,184 --> 00:30:21,586
Just say stop that thread.

838
00:30:21,586 --> 00:30:25,256
Push enter C it turns
red and disappears.

839
00:30:25,256 --> 00:30:26,891
Kind of go through
the whole thing

840
00:30:26,891 --> 00:30:29,828
and kill all the
malicious threads.

841
00:30:31,262 --> 00:30:32,096
Let's see.

842
00:30:33,131 --> 00:30:35,133
This on was hard to do because

843
00:30:35,133 --> 00:30:37,969
one was 1644 and one was 1664.

844
00:30:37,969 --> 00:30:40,405
(Joe laughs)

845
00:30:40,405 --> 00:30:41,773
- [Joe] Alright the
dyslexic kicking in.

846
00:30:41,773 --> 00:30:44,842
- [Jared] A little
dyslexia going on.

847
00:30:48,680 --> 00:30:50,014
Yeah and then...

848
00:30:52,350 --> 00:30:53,618
3244.

849
00:30:53,618 --> 00:30:55,453
So this situation is
a little bit contrived

850
00:30:55,453 --> 00:30:58,156
just because
realnetwork.exe was used

851
00:30:58,156 --> 00:30:59,858
specifically in
this case to launch

852
00:30:59,858 --> 00:31:03,528
the malicious threads
or malicious code.

853
00:31:03,528 --> 00:31:05,363
But in a situation
where an attacker

854
00:31:05,363 --> 00:31:08,900
has injected into
something that is actually

855
00:31:08,900 --> 00:31:10,301
a legitimate process that is

856
00:31:10,301 --> 00:31:12,102
critical to the system,

857
00:31:12,103 --> 00:31:13,872
you would want to
be able to possibly

858
00:31:13,872 --> 00:31:15,373
get rid of the attacker
from the system

859
00:31:15,373 --> 00:31:17,775
without crashing the system.

