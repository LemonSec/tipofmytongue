1
00:00:00,867 --> 00:00:04,337
(futuristic electronic music)

2
00:00:07,407 --> 00:00:10,510
(audience applauding)

3
00:00:10,510 --> 00:00:11,544
- Hi, everybody.

4
00:00:11,544 --> 00:00:13,646
I am Forest Monsen,

5
00:00:13,646 --> 00:00:16,649
and next to me is the
lustrous Alex Maestretti.

6
00:00:16,649 --> 00:00:18,952
Alex directs the
security intelligence

7
00:00:18,952 --> 00:00:20,920
and response team at Netflix,

8
00:00:20,920 --> 00:00:24,290
and I'm a senior security
engineer on his team.

9
00:00:24,290 --> 00:00:26,291
We're going to be talking
to you this afternoon

10
00:00:26,292 --> 00:00:30,296
about threat hunting on
AWS, Amazon Web Services.

11
00:00:30,296 --> 00:00:32,399
So we do this at Netflix.

12
00:00:32,399 --> 00:00:36,002
And given Netflix's scale, and
Cloud, and DevOps maturity,

13
00:00:36,002 --> 00:00:40,440
we find the challenges we face
to be incredibly interesting,

14
00:00:40,440 --> 00:00:43,610
but also given that
scale, that maturity,

15
00:00:43,610 --> 00:00:45,412
we find the things
we're able to do,

16
00:00:45,412 --> 00:00:49,249
the ways we're able to hunt to
be very interesting as well,

17
00:00:49,249 --> 00:00:51,051
so that's why we're sharing.

18
00:00:51,051 --> 00:00:53,019
Because if you're not there yet,

19
00:00:53,019 --> 00:00:55,221
we want you to get
excited about it too.

20
00:00:55,221 --> 00:00:57,589
And we think when
you've seen here

21
00:00:57,590 --> 00:00:59,926
about some of these
things, you will.

22
00:00:59,926 --> 00:01:03,363
So we're going to talk
about a pretty broad range

23
00:01:03,363 --> 00:01:06,132
of tools and tactics that
our environment enables,

24
00:01:06,132 --> 00:01:07,801
most of which we're using now.

25
00:01:07,801 --> 00:01:09,602
We hope you'll be able
to take inspiration

26
00:01:09,602 --> 00:01:11,104
from what we're currently doing

27
00:01:11,104 --> 00:01:13,206
and get some ideas
from what you might do

28
00:01:13,206 --> 00:01:14,908
in this environment too.

29
00:01:14,908 --> 00:01:17,410
Our goal is to make you
better threat hunters

30
00:01:17,410 --> 00:01:20,113
no matter your current level.

31
00:01:20,113 --> 00:01:23,483
We're going to do this by
presenting three scenarios

32
00:01:23,483 --> 00:01:26,853
that go progressively
higher into the AWS Cloud,

33
00:01:26,853 --> 00:01:29,655
increasing the scale and
speed at which you can perform

34
00:01:29,656 --> 00:01:31,558
threat hunting operations.

35
00:01:31,558 --> 00:01:33,093
So in the first,

36
00:01:33,093 --> 00:01:36,963
there's a series of
unfortunate events that occurs,

37
00:01:36,963 --> 00:01:39,631
and you're going to hear
me talking about familiar

38
00:01:39,632 --> 00:01:42,602
Linux live response tools
and scripts on an instance.

39
00:01:42,602 --> 00:01:45,105
However, if you're not
already taking advantage

40
00:01:45,105 --> 00:01:48,141
of the AWS orchestration
layers and APIs

41
00:01:48,141 --> 00:01:51,978
to supercharge your threat
hunting and live response,

42
00:01:51,978 --> 00:01:54,780
it's a good time to
start looking into it.

43
00:01:54,781 --> 00:01:56,649
I'll discuss some of
the work that I'm doing

44
00:01:56,649 --> 00:01:58,151
with EC2 systems manager.

45
00:01:58,151 --> 00:02:01,387
In the second scenario when
stranger things start happening,

46
00:02:01,387 --> 00:02:02,922
you'll have to up your game

47
00:02:02,922 --> 00:02:05,258
and go a little
higher into the Cloud.

48
00:02:05,258 --> 00:02:06,493
You'll hear from Alex about ways

49
00:02:06,493 --> 00:02:08,894
to use AWS specific capabilities

50
00:02:08,895 --> 00:02:13,032
to execute strong control
over your attackers.

51
00:02:13,032 --> 00:02:15,702
And finally, the
third scenario's going
to be full-Cloud.

52
00:02:15,702 --> 00:02:19,005
So in this scenario, your
attackers are completely aware

53
00:02:19,005 --> 00:02:20,507
of your AWS setup,

54
00:02:20,507 --> 00:02:22,976
they're a highly capable
and as sound as possible,

55
00:02:22,976 --> 00:02:24,811
and you're being
specifically targeted.

56
00:02:24,811 --> 00:02:28,781
That is, they're directly
attacking your AWS capabilities,

57
00:02:28,781 --> 00:02:30,316
not just your instances.

58
00:02:30,316 --> 00:02:35,288
So you're going to have to go
ultimate beastmaster on them.

59
00:02:35,288 --> 00:02:38,091
So, conventional
hunting in the Cloud.

60
00:02:38,091 --> 00:02:39,492
First scenario.

61
00:02:39,492 --> 00:02:42,762
It is conventional
hunting and live response,

62
00:02:42,762 --> 00:02:44,364
but it is in the Cloud.

63
00:02:44,364 --> 00:02:46,099
So here you are on
a weekday afternoon,

64
00:02:46,099 --> 00:02:47,600
you've got some time set aside

65
00:02:47,600 --> 00:02:51,171
and you decide to check
common persistence locations

66
00:02:51,171 --> 00:02:53,305
on your webfront end

67
00:02:53,306 --> 00:02:55,842
since it represents
a significant risk
to your business

68
00:02:55,842 --> 00:02:57,644
if it were compromised.

69
00:02:57,644 --> 00:02:59,312
You're going to query the ELB,

70
00:02:59,312 --> 00:03:01,114
that's the elastic load balancer

71
00:03:01,114 --> 00:03:03,349
for a list of all
of the instances

72
00:03:03,349 --> 00:03:05,885
associated with
this application.

73
00:03:05,885 --> 00:03:07,654
It's because it's
horizontally scaled,

74
00:03:07,654 --> 00:03:10,957
and the ELB is going to
tell you what it's fronting.

75
00:03:10,957 --> 00:03:13,025
Remember, we're still building
off this conventional model

76
00:03:13,026 --> 00:03:14,761
where you have
live response tools

77
00:03:14,761 --> 00:03:17,964
such as a script or statically
compiled safe binaries.

78
00:03:17,964 --> 00:03:19,999
You're already
aware of the issues

79
00:03:19,999 --> 00:03:22,234
with evidence
dynamics, et cetera.

80
00:03:22,235 --> 00:03:24,037
And you're interacting
with these instances

81
00:03:24,037 --> 00:03:27,307
simply to search for
signs of compromise.

82
00:03:27,307 --> 00:03:30,709
A little aside, if you're not
already familiar with SSM,

83
00:03:30,710 --> 00:03:33,680
that's the EC2 simple
systems manager.

84
00:03:33,680 --> 00:03:35,882
It was launched in late 2015,

85
00:03:35,882 --> 00:03:39,052
so it's been around not
quite a year and a half.

86
00:03:39,052 --> 00:03:42,355
An SSM agent is going to run
on any instance you specify

87
00:03:42,355 --> 00:03:45,959
and execute scripted
commands remotely,

88
00:03:45,959 --> 00:03:48,528
or take other actions
on your behalf.

89
00:03:48,528 --> 00:03:50,429
It does a heck of
a lot on Windows.

90
00:03:50,430 --> 00:03:53,132
You can run updates,
install powershell modules,

91
00:03:53,132 --> 00:03:55,602
run powershell scripts, set
up Cloud watch, et cetera.

92
00:03:55,602 --> 00:03:58,871
We're going to focus on
Linux here, as I said.

93
00:03:58,871 --> 00:04:01,474
On Linux, if you use
the run command action

94
00:04:01,474 --> 00:04:06,012
and the canned AWS run shell
script template, for example,

95
00:04:06,012 --> 00:04:10,116
it's going to log all command's
run, their standout out,

96
00:04:10,116 --> 00:04:11,484
their standard error,

97
00:04:11,484 --> 00:04:12,752
and it's going to
optionally dump your results

98
00:04:12,752 --> 00:04:14,754
into the S3 bucket
of your choosing.

99
00:04:14,754 --> 00:04:17,322
You could, for example,
name these with the instance

100
00:04:17,322 --> 00:04:19,692
or the incident number of
something you're working.

101
00:04:19,692 --> 00:04:22,929
If it can't execute commands,
it's going to queue them,

102
00:04:22,929 --> 00:04:25,364
and it's going to wait
until the agent is ready

103
00:04:25,365 --> 00:04:26,633
to execute those.

104
00:04:26,633 --> 00:04:28,967
So you don't have
to log in via SSH

105
00:04:28,968 --> 00:04:31,137
or RDP to administer
this machine.

106
00:04:31,137 --> 00:04:32,438
It gives you the ability

107
00:04:32,438 --> 00:04:34,941
to manage a fleet of
instances at scale.

108
00:04:34,941 --> 00:04:37,577
So you can probably see this
is a great potential tool

109
00:04:37,577 --> 00:04:39,946
for hunting and live response.

110
00:04:39,946 --> 00:04:42,582
It's a capability that Alex and
I are developing at Netflix,

111
00:04:42,582 --> 00:04:45,084
and we hope to be able
to share more later.

112
00:04:45,084 --> 00:04:47,754
I should add that when
using AC2 systems manager,

113
00:04:47,754 --> 00:04:48,955
or SSM for short,

114
00:04:48,955 --> 00:04:51,890
you're using the
binaries on the system

115
00:04:51,891 --> 00:04:54,460
and that might raise
a red flag for you,

116
00:04:54,460 --> 00:04:55,995
but you don't actually
have to trust those,

117
00:04:55,995 --> 00:04:58,831
you can write a straight forward
python script, for example,

118
00:04:58,831 --> 00:05:00,600
and you sign on to
statically compile it

119
00:05:00,600 --> 00:05:03,736
and get it on your instance
by pulling it from S3

120
00:05:03,736 --> 00:05:05,271
at response time.

121
00:05:05,271 --> 00:05:09,375
So in this example, back to a
series of unfortunate events.

122
00:05:10,910 --> 00:05:12,945
You're running Linux
on your web front end

123
00:05:12,945 --> 00:05:15,948
and you pull the list of
instances from your ELB,

124
00:05:15,948 --> 00:05:17,517
your elastic load balancer.

125
00:05:17,517 --> 00:05:19,252
You don't log into any
of these instances.

126
00:05:19,252 --> 00:05:21,754
You run an SSM command
to run your script

127
00:05:21,754 --> 00:05:24,090
which is pulled back
persistence locations

128
00:05:24,090 --> 00:05:26,125
generated from, say,

129
00:05:26,125 --> 00:05:28,795
the forensic artifacts
repository on GitHub.

130
00:05:28,795 --> 00:05:32,532
Shout out here to Greg Castle
and Wakim Mets for that.

131
00:05:32,532 --> 00:05:35,234
Your script is gonna
compare the files you found

132
00:05:35,234 --> 00:05:38,938
to your golden master AMI,
your Amazon machine image,

133
00:05:38,938 --> 00:05:41,707
and that's your reference image.

134
00:05:41,708 --> 00:05:44,811
You're familiar with that in
a conventional environment,

135
00:05:44,811 --> 00:05:46,546
I'm sure.

136
00:05:46,546 --> 00:05:49,147
And something sticks
out, something that
shouldn't be there.

137
00:05:49,148 --> 00:05:50,550
It's a startup script.

138
00:05:50,550 --> 00:05:53,386
It's an etsy slash (mumbling)
slash DB security SPT.

139
00:05:53,386 --> 00:05:57,690
As it turns out, that is
a match for a file name

140
00:05:57,690 --> 00:06:02,128
that the Bill Gates trogan
variant generator will produce

141
00:06:02,128 --> 00:06:04,997
and drop on your system,
on a compromised system.

142
00:06:04,997 --> 00:06:06,199
And it turns out,

143
00:06:06,199 --> 00:06:08,801
it's on six of your web
front end instances.

144
00:06:08,801 --> 00:06:10,837
So are you going
to have to log in

145
00:06:10,837 --> 00:06:13,005
to conduct live response here?

146
00:06:13,005 --> 00:06:15,241
No, you're not, you have SSM.

147
00:06:15,241 --> 00:06:16,776
So at this point,

148
00:06:16,776 --> 00:06:19,445
you snapshot all of
your running instances.

149
00:06:19,445 --> 00:06:20,913
That's the root EBS volume,

150
00:06:20,913 --> 00:06:23,549
the elastic block
store of each of those

151
00:06:23,549 --> 00:06:24,883
using the AWS console

152
00:06:24,884 --> 00:06:28,755
or a script that uses
the AWS EPI, right?

153
00:06:28,755 --> 00:06:31,991
You're going to work only on
your snapshots, of course.

154
00:06:31,991 --> 00:06:34,327
You could easily share
any of these snapshots

155
00:06:34,327 --> 00:06:36,329
with anybody else
if you wanted to,

156
00:06:36,329 --> 00:06:37,830
maybe have them analyze it.

157
00:06:37,830 --> 00:06:40,500
But in this case, you're
going to be moving forward

158
00:06:40,500 --> 00:06:41,501
on your own.

159
00:06:41,501 --> 00:06:44,070
So here you're going to use SSM

160
00:06:48,007 --> 00:06:52,178
to pull your statically
compiled safe binary from S3.

161
00:06:54,447 --> 00:06:56,916
We're going to pull it this way.

162
00:06:56,916 --> 00:06:58,818
And then run your commands.

163
00:06:58,818 --> 00:07:01,421
And send the results back to S3.

164
00:07:02,989 --> 00:07:05,457
It's timestamped and logged,
that happened in seconds.

165
00:07:05,458 --> 00:07:07,260
You're going to collect
system information,

166
00:07:07,260 --> 00:07:09,594
mounted file systems, users,
interfaces, the routing table,

167
00:07:09,595 --> 00:07:12,598
open file handles,
everything of value,

168
00:07:12,598 --> 00:07:14,934
and you're familiar with that.

169
00:07:14,934 --> 00:07:17,503
This is live response in action.

170
00:07:17,503 --> 00:07:19,906
And now you're going to
grab volatile memory.

171
00:07:19,906 --> 00:07:22,542
So you've already compiled
the lime kernel module

172
00:07:22,542 --> 00:07:25,077
and left it on S3 here.

173
00:07:25,077 --> 00:07:27,914
Lime allows you to
grab system memory.

174
00:07:27,914 --> 00:07:30,116
You may already be
familiar with that.

175
00:07:30,116 --> 00:07:32,852
So again, you send
the SSM agent commands

176
00:07:32,852 --> 00:07:35,054
to download and
insert the module

177
00:07:35,054 --> 00:07:36,522
and acquire system memory.

178
00:07:36,522 --> 00:07:39,025
And then drop it back on S3.

179
00:07:39,025 --> 00:07:40,859
So I'm not going to
be going into it,

180
00:07:40,860 --> 00:07:43,629
but a great option here
is margarita shotgun

181
00:07:43,629 --> 00:07:47,233
by Joel Ferrier of the threat
response dot Cloud guys,

182
00:07:47,233 --> 00:07:48,734
and that is bigly.

183
00:07:50,203 --> 00:07:52,772
So you should go check it out.

184
00:07:52,772 --> 00:07:55,908
You can stream your
memory capture to S3.

185
00:07:55,908 --> 00:07:59,812
And they've done great stuff
with AWS underscore IR as well.

186
00:07:59,812 --> 00:08:02,482
Next, you're going to
add these instances

187
00:08:02,482 --> 00:08:04,951
to a lockdown
security group or SG

188
00:08:04,951 --> 00:08:07,954
that only allows
access from SSM or S3

189
00:08:07,954 --> 00:08:10,122
and your forensics instance,

190
00:08:10,122 --> 00:08:12,391
you're going to have one
of those in the Cloud.

191
00:08:12,391 --> 00:08:13,626
That's scriptable, too.

192
00:08:13,626 --> 00:08:16,061
So your afternoon's running,

193
00:08:16,062 --> 00:08:18,264
that hasn't been that much time.

194
00:08:18,264 --> 00:08:19,732
Maybe 10, 15 minutes.

195
00:08:19,732 --> 00:08:22,568
The memory capture
might still be running,

196
00:08:22,568 --> 00:08:24,270
but when you take a break,

197
00:08:24,270 --> 00:08:26,639
you're going to inform
the web team via chat

198
00:08:26,639 --> 00:08:28,608
about the suspected compromise,

199
00:08:28,608 --> 00:08:30,409
and they're going to respond.

200
00:08:30,409 --> 00:08:32,912
In this scenario,
they respond and say

201
00:08:32,912 --> 00:08:35,715
that they happen to be using
some old WordPress plugins

202
00:08:35,715 --> 00:08:38,718
and they didn't
keep them updated.

203
00:08:38,717 --> 00:08:41,887
I'm not sure if that's ever
happened to any of you.

204
00:08:41,888 --> 00:08:45,224
But now, what you can
tell them is go ahead,

205
00:08:45,224 --> 00:08:48,661
I've already set aside snapshots
of all these instances.

206
00:08:48,661 --> 00:08:50,930
Go ahead and roll a new cluster,

207
00:08:50,930 --> 00:08:52,464
a new auto-scaling group,

208
00:08:52,465 --> 00:08:56,536
and have a plan to keep these
updated in the future, please.

209
00:08:56,536 --> 00:08:58,905
So you've got
those all set aside

210
00:08:58,905 --> 00:09:00,673
for your further examination

211
00:09:00,673 --> 00:09:02,341
or another team, perhaps.

212
00:09:02,341 --> 00:09:03,809
So here's the thing.

213
00:09:03,809 --> 00:09:05,444
In the next scenario, you're
going to turn up logging

214
00:09:05,444 --> 00:09:07,146
if you haven't
already done that.

215
00:09:07,146 --> 00:09:09,814
So by rolling that cluster
or auto-scaling group

216
00:09:09,815 --> 00:09:11,250
and turning up logging,

217
00:09:11,250 --> 00:09:12,785
you're forcing your
adversary to come back in

218
00:09:12,785 --> 00:09:15,721
through your gates
under greater scrutiny,

219
00:09:15,721 --> 00:09:17,957
so bear that in mind.

220
00:09:17,957 --> 00:09:21,227
So that was a series
of unfortunate events.

221
00:09:21,227 --> 00:09:24,163
And by getting familiar
with these though,

222
00:09:24,163 --> 00:09:25,698
you're going to be
much more prepared

223
00:09:25,698 --> 00:09:28,300
when stranger things
start occurring.

224
00:09:28,301 --> 00:09:31,037
So let's, OK,
let's advance here.

225
00:09:32,204 --> 00:09:33,772
And I want to turn
it over to Alex.

226
00:09:33,773 --> 00:09:36,375
He's going to describe
the next two scenarios.

227
00:09:36,375 --> 00:09:37,376
- Thanks, Forest.

228
00:09:37,376 --> 00:09:38,578
Cool.

229
00:09:38,578 --> 00:09:39,812
So I think what
was really powerful

230
00:09:39,812 --> 00:09:40,746
about some of the
stuff Forest shared

231
00:09:40,746 --> 00:09:42,615
is the low upfront overhead

232
00:09:42,615 --> 00:09:44,283
of developing that
system, right?

233
00:09:44,283 --> 00:09:46,619
We talked about a few
times this morning

234
00:09:46,619 --> 00:09:47,920
trying to lower the
barrier to entry

235
00:09:47,920 --> 00:09:49,722
to get more folks in
the fight in hunting,

236
00:09:49,722 --> 00:09:51,189
and this is a great way
to do just that, right?

237
00:09:51,190 --> 00:09:53,259
Rather than having to
build a large deployment

238
00:09:53,259 --> 00:09:55,428
of end point monitoring
or a login pipeline,

239
00:09:55,428 --> 00:09:57,897
you can use the things that
AWS has given you for free

240
00:09:57,897 --> 00:10:02,034
and go ahead and push our a
live response script using SSM.

241
00:10:02,034 --> 00:10:04,270
And it does all the
queuing, all the scaling,

242
00:10:04,270 --> 00:10:06,405
so you take the skills
that you could use

243
00:10:06,405 --> 00:10:09,007
to investigate one or
two boxes using SSH,

244
00:10:09,008 --> 00:10:11,310
and all of a sudden you're doing
that at Cloud scale, right?

245
00:10:11,310 --> 00:10:13,012
So I think that's very cool.

246
00:10:13,012 --> 00:10:15,513
I think the other thing
that he sort of lead into

247
00:10:15,514 --> 00:10:17,817
was the idea that you can
be much more aggressive

248
00:10:17,817 --> 00:10:19,385
in your hunts in the Cloud.

249
00:10:19,385 --> 00:10:20,953
And it's partly
being in the Cloud,

250
00:10:20,953 --> 00:10:23,021
and it's partly being on
a more modern text stack.

251
00:10:23,022 --> 00:10:25,391
So I just want to
divert a little bit here

252
00:10:25,391 --> 00:10:27,560
and talk about sort
of microservices

253
00:10:27,560 --> 00:10:29,194
and modern DevOps practices.

254
00:10:29,195 --> 00:10:31,397
So that's what really
makes hunting a lot of fun

255
00:10:31,397 --> 00:10:32,798
in our environment is
that if you've decomposed

256
00:10:32,798 --> 00:10:36,435
your (mumbling) applications
into microservices,

257
00:10:36,435 --> 00:10:40,539
each individual unit
is operating on a
smaller set of data,

258
00:10:40,539 --> 00:10:43,376
and so you get a better
signal to noise ratio.

259
00:10:43,376 --> 00:10:45,177
You kind of figure out
what things are going on.

260
00:10:45,177 --> 00:10:46,679
And then on the DevOps side,

261
00:10:46,679 --> 00:10:49,482
you've got ideally immutable
and ephemeral instances

262
00:10:49,482 --> 00:10:51,951
that are being deployed
through a CIC pipeline,

263
00:10:51,951 --> 00:10:53,953
a continuous integration,
continuous deployment pipeline.

264
00:10:53,953 --> 00:10:55,821
So in that case, if
they're immutable,

265
00:10:55,821 --> 00:10:57,623
then they're very close
to that gold image

266
00:10:57,623 --> 00:10:59,091
that Forest mentioned, right?

267
00:10:59,091 --> 00:11:00,459
So again, you're signal to
noise ratio is greatly improved.

268
00:11:00,459 --> 00:11:02,194
And if they are ephemeral,

269
00:11:02,194 --> 00:11:03,896
it means they don't
last very long,

270
00:11:03,896 --> 00:11:05,363
so they're meant to come and go,

271
00:11:05,364 --> 00:11:06,899
which means you can be very
aggressive as a defender

272
00:11:06,899 --> 00:11:08,668
in knocking in those off.

273
00:11:08,668 --> 00:11:10,636
And as he mentioned, you know,
roll an entire new cluster

274
00:11:10,636 --> 00:11:12,704
to try and see what that
does to the adversary.

275
00:11:12,705 --> 00:11:14,740
And that's how I want
to tie it kind of back

276
00:11:14,740 --> 00:11:16,609
to the abstract,
what we talked out,

277
00:11:16,609 --> 00:11:18,044
our definition of hunting.

278
00:11:18,044 --> 00:11:21,414
I think there's a range
of security operations

279
00:11:21,414 --> 00:11:22,682
that you could consider hunting.

280
00:11:22,682 --> 00:11:24,050
And on one end,

281
00:11:24,050 --> 00:11:25,550
you have more of a continuous
monitoring operation

282
00:11:25,551 --> 00:11:27,787
where you're looking
for known (mumbling),

283
00:11:27,787 --> 00:11:29,855
anomaly detection, that's
going on all the time.

284
00:11:29,855 --> 00:11:31,457
And then at the other
end of the spectrum,

285
00:11:31,457 --> 00:11:32,891
you have what I
consider true hunting

286
00:11:32,892 --> 00:11:34,226
which is bounded operations

287
00:11:34,226 --> 00:11:36,262
that are bounded both in time,

288
00:11:36,262 --> 00:11:37,863
so you're only going to do
it for whatever I think,

289
00:11:37,863 --> 00:11:39,131
there was two hours this morning

290
00:11:39,131 --> 00:11:40,966
and four hours
maybe a couple days.

291
00:11:40,966 --> 00:11:42,201
If it stretches into weeks,

292
00:11:42,201 --> 00:11:43,469
I might want to decompose that

293
00:11:43,469 --> 00:11:44,770
into multiple
hunting operations.

294
00:11:44,770 --> 00:11:46,305
But also, bounded
in terms of focus.

295
00:11:46,305 --> 00:11:47,673
So we heard this morning about
knowing your terrain, right?

296
00:11:47,673 --> 00:11:49,375
Knowing what the weather
is in you environment.

297
00:11:49,375 --> 00:11:51,410
So if you're going to
set up a hunting op,

298
00:11:51,410 --> 00:11:53,679
you want to really focus
in on a microservice

299
00:11:53,679 --> 00:11:55,613
or a piece of data you
know will be valuable.

300
00:11:55,614 --> 00:11:57,249
So you need to
know your terrain,

301
00:11:57,249 --> 00:11:58,918
you need to know what the
adversaries are after,

302
00:11:58,918 --> 00:12:00,319
how they move through
an environment,

303
00:12:00,319 --> 00:12:02,188
and then you can identify
those choke points

304
00:12:02,188 --> 00:12:03,656
that you want to monitor,

305
00:12:03,656 --> 00:12:05,257
the essential data that
they're going to come after,

306
00:12:05,257 --> 00:12:08,393
and that really sort of
ups your hunting game.

307
00:12:08,394 --> 00:12:09,528
And that final piece

308
00:12:09,528 --> 00:12:11,097
is being able to
change the environment,

309
00:12:11,097 --> 00:12:12,665
to create those choke points,
to create those opportunities.

310
00:12:12,665 --> 00:12:14,934
And (mumbling) to do that,

311
00:12:14,934 --> 00:12:17,969
it really helps to be in
a Cloud in a modern stack

312
00:12:17,970 --> 00:12:19,872
because you can change
things around on the fly

313
00:12:19,872 --> 00:12:20,939
through an API.

314
00:12:20,940 --> 00:12:22,475
All of your
infrastructure is code.

315
00:12:22,475 --> 00:12:24,210
You don't have to rack
boxes, and things like that.

316
00:12:24,210 --> 00:12:26,645
So we'll talk a little more
about that going forward.

317
00:12:26,645 --> 00:12:27,913
That works.

318
00:12:27,913 --> 00:12:29,648
So yeah, so here we're
into stranger things.

319
00:12:29,648 --> 00:12:31,817
Forest had talked about
using live response scripts,

320
00:12:31,817 --> 00:12:33,285
fairly traditional.

321
00:12:33,285 --> 00:12:34,954
We're going to talk a bit
more now about using logging,

322
00:12:34,954 --> 00:12:36,789
which I think is really
what we'll all be doing

323
00:12:36,789 --> 00:12:37,790
more and more of, right?

324
00:12:37,790 --> 00:12:39,058
We'll always have logs,

325
00:12:39,058 --> 00:12:40,326
even if we start to
lose some visibility

326
00:12:40,326 --> 00:12:42,128
on other sections of
our infrastructure.

327
00:12:42,128 --> 00:12:43,629
And the great thing
about being AWS

328
00:12:43,629 --> 00:12:45,030
is there's lots
of logging sources

329
00:12:45,030 --> 00:12:46,398
that you get, again, for free,

330
00:12:46,398 --> 00:12:47,800
for no engineering
upfront, right?

331
00:12:47,800 --> 00:12:49,168
You might not want to
build a logging pipeline

332
00:12:49,168 --> 00:12:50,970
to capture all of
your patchy logs,

333
00:12:50,970 --> 00:12:52,671
but you don't need
to if you're an AWS.

334
00:12:52,671 --> 00:12:54,240
You can get that
from other sources.

335
00:12:54,240 --> 00:12:55,975
So here, we've got a picture

336
00:12:55,975 --> 00:12:58,677
of a generalized
microservices unit, right?

337
00:12:58,677 --> 00:13:01,714
You've got some sort of
discovery on the front end,

338
00:13:01,714 --> 00:13:02,948
in this case, DNS.

339
00:13:02,948 --> 00:13:04,717
You've got that load
balancer we mentioned

340
00:13:04,717 --> 00:13:05,951
that's serving traffic

341
00:13:05,951 --> 00:13:07,586
across an auto-scaling
group of instances.

342
00:13:07,586 --> 00:13:09,188
Again, these instances
are built from source

343
00:13:09,188 --> 00:13:10,456
through a CIC pipeline.

344
00:13:10,456 --> 00:13:12,258
They're deployed
multiple times a day.

345
00:13:12,258 --> 00:13:13,526
They don't live
more than 24 hours.

346
00:13:13,526 --> 00:13:14,827
So they come and
go as they please.

347
00:13:14,827 --> 00:13:17,263
If they need more
scale, they scale up.

348
00:13:17,263 --> 00:13:18,631
If they all need
less, they scale down.

349
00:13:18,631 --> 00:13:19,732
If you want to terminate one

350
00:13:19,732 --> 00:13:20,966
or move it to quarantine,

351
00:13:20,966 --> 00:13:22,334
the customer never
knows the difference.

352
00:13:22,334 --> 00:13:23,935
There's no hit to up time.

353
00:13:23,936 --> 00:13:25,971
None of your DevOps
guys come after you.

354
00:13:25,971 --> 00:13:28,941
So you can be very free in
your response activities.

355
00:13:28,941 --> 00:13:31,610
And they basically take
some simple information,

356
00:13:31,610 --> 00:13:32,978
they reach out to
other microservices

357
00:13:32,978 --> 00:13:34,313
that can pose a response,

358
00:13:34,313 --> 00:13:35,848
and they send that
back up the pipe.

359
00:13:35,848 --> 00:13:39,218
So that's, again, a
microservice sort of subunit.

360
00:13:39,218 --> 00:13:40,786
So if we look at this

361
00:13:40,786 --> 00:13:42,720
and say we've already
identified as microservice

362
00:13:42,721 --> 00:13:43,956
as being valuable,

363
00:13:43,956 --> 00:13:45,424
it processes something
an adversary would want,

364
00:13:45,424 --> 00:13:48,327
(mumbles) recipe, you know,
CCM, something of value.

365
00:13:48,327 --> 00:13:51,397
You could say, OK, I'm going
to hunt on this microservice.

366
00:13:51,397 --> 00:13:53,432
And then we look at it

367
00:13:53,432 --> 00:13:55,467
and we see an obvious
choke point at the CLB.

368
00:13:55,467 --> 00:13:57,603
And fortunately, with a
couple clicks in the console,

369
00:13:57,603 --> 00:13:59,537
you can turn logging
on on that ELB

370
00:13:59,538 --> 00:14:01,540
and send those logs
right to an S3 bucket.

371
00:14:01,540 --> 00:14:04,142
And S3 for those who aren't
familiar is just a block store,

372
00:14:04,143 --> 00:14:07,513
so you're basically storing
text files in this S3 bucket.

373
00:14:07,513 --> 00:14:09,415
Very inexpensive,
very high performance,

374
00:14:09,415 --> 00:14:10,583
good backup characteristics.

375
00:14:10,583 --> 00:14:12,117
Really, a wonderful technology.

376
00:14:12,117 --> 00:14:14,185
So you could then take those

377
00:14:14,186 --> 00:14:16,956
and ETL them into some
sort of data pipeline.

378
00:14:16,956 --> 00:14:18,657
But again, if you don't
want to spend any money

379
00:14:18,657 --> 00:14:20,159
on engineering upfront,

380
00:14:20,159 --> 00:14:21,961
then you can point this
thing called Athena at it.

381
00:14:21,961 --> 00:14:24,296
And Athena will go ahead and
give you big data capabilities

382
00:14:24,296 --> 00:14:26,298
sort of on the fly, on demand.

383
00:14:26,298 --> 00:14:27,666
So you pay per megabyte scanned.

384
00:14:27,666 --> 00:14:29,168
You have to spend a
little bit of time

385
00:14:29,168 --> 00:14:31,270
creating an ingest
algorithm for it,

386
00:14:31,270 --> 00:14:32,771
or ingest schema, essentially.

387
00:14:32,771 --> 00:14:34,339
But those are available online

388
00:14:34,340 --> 00:14:35,708
for all of the
common log formats.

389
00:14:35,708 --> 00:14:37,343
And then when you
want to search it,

390
00:14:37,343 --> 00:14:38,544
you write sequel-like queries,

391
00:14:38,544 --> 00:14:40,145
kind of like you would for Hive,

392
00:14:40,145 --> 00:14:41,079
and it just goes ahead,

393
00:14:41,080 --> 00:14:42,882
and it will process this data

394
00:14:42,882 --> 00:14:44,415
in a massively parallel fashion.

395
00:14:44,416 --> 00:14:46,018
So if you have a
large deployment,

396
00:14:46,018 --> 00:14:47,853
you got a lot of logs you
want to crunch through,

397
00:14:47,853 --> 00:14:49,188
Athena will do that very quickly

398
00:14:49,188 --> 00:14:50,689
with no upfront overhead.

399
00:14:50,689 --> 00:14:54,059
So let's dive a little more
into that example, right?

400
00:14:54,059 --> 00:14:56,462
So we found a
persistence location,

401
00:14:56,462 --> 00:14:58,396
we rolled the whole
scaling group.

402
00:14:58,397 --> 00:15:00,833
Our assumption is that
they're going to come back in.

403
00:15:00,833 --> 00:15:03,002
So, you know, we found
their persistence location,

404
00:15:03,002 --> 00:15:04,435
but we don't really
know how they got there.

405
00:15:04,436 --> 00:15:05,871
We might theorize.

406
00:15:05,871 --> 00:15:07,606
They probably came in
through the front end.

407
00:15:07,606 --> 00:15:09,842
Maybe there's a
vulnerability on our web app.

408
00:15:09,842 --> 00:15:11,210
We've got these WordPress things

409
00:15:11,210 --> 00:15:12,845
that aren't updated very often.

410
00:15:12,845 --> 00:15:14,446
So we probably want to look

411
00:15:14,446 --> 00:15:16,081
or hunt for their
attempt to reacquire,

412
00:15:16,081 --> 00:15:18,117
and we'll do that with ELB logs.

413
00:15:18,117 --> 00:15:20,452
So the ELB log
format you see here

414
00:15:20,452 --> 00:15:22,021
from the Amazon documentation

415
00:15:22,021 --> 00:15:23,689
is very similar to a weblog.

416
00:15:23,689 --> 00:15:26,125
You've got, you
know, a timestamp,

417
00:15:26,125 --> 00:15:27,459
and you've got a request,

418
00:15:27,459 --> 00:15:28,893
and some of these
other objects here.

419
00:15:28,894 --> 00:15:30,262
I don't know if you can really,

420
00:15:30,262 --> 00:15:31,729
oh good, you can see up there.

421
00:15:31,730 --> 00:15:32,898
So up there, you can see
I've highlighted some fields

422
00:15:32,898 --> 00:15:34,199
that might be
viable for hunting.

423
00:15:34,199 --> 00:15:36,101
When you consider hunting,

424
00:15:36,101 --> 00:15:38,304
there's sort of two
general categories.

425
00:15:38,304 --> 00:15:39,805
Either you have an IOC,

426
00:15:39,805 --> 00:15:42,141
you've got an indicator of
compromise you want to find,

427
00:15:42,141 --> 00:15:43,742
or you're just looking
for weird, right?

428
00:15:43,742 --> 00:15:46,312
So in this case, we don't really
know how they're coming on,

429
00:15:46,312 --> 00:15:47,346
we're just looking for weird.

430
00:15:47,346 --> 00:15:48,847
But if we did have an IOC,

431
00:15:48,847 --> 00:15:50,281
that'd probably be some
sort of a sub-string match

432
00:15:50,282 --> 00:15:51,817
on the request.

433
00:15:51,817 --> 00:15:53,218
You know, say they had a PHP
backdoor they were hitting,

434
00:15:53,218 --> 00:15:54,553
that would be in the request,

435
00:15:54,553 --> 00:15:55,587
it would pop right out.

436
00:15:55,587 --> 00:15:57,122
It was mentioned this morning,

437
00:15:57,122 --> 00:15:58,891
a lot of these guys will
roll their own tools

438
00:15:58,891 --> 00:16:00,526
and they'll misspell
the user agent

439
00:16:00,526 --> 00:16:01,894
or they'll mis-capitalize it.

440
00:16:01,894 --> 00:16:03,395
You'll see that especially
if they're doing

441
00:16:03,395 --> 00:16:04,829
sort of volumetric
attacks, right?

442
00:16:04,830 --> 00:16:06,432
They'll precompute the
headers, they'll mess it up.

443
00:16:06,432 --> 00:16:08,100
So you can find those,
that's a good IOC.

444
00:16:08,100 --> 00:16:10,402
Or you could also use
that like these other ones

445
00:16:10,402 --> 00:16:11,804
to try and do frequency counts,

446
00:16:11,804 --> 00:16:14,372
or to serve another
standard hunting procedure.

447
00:16:14,373 --> 00:16:16,542
So, you know, you could
look at any of these fields.

448
00:16:16,542 --> 00:16:18,344
Received bytes
might be a good one.

449
00:16:18,344 --> 00:16:19,812
Again, if this is
a microservice,

450
00:16:19,812 --> 00:16:21,981
these fields shouldn't
vary all that much, right?

451
00:16:21,981 --> 00:16:24,415
If it's a microservice
that does weather updates,

452
00:16:24,416 --> 00:16:26,218
it gets a zip code, it
sends a temperature,

453
00:16:26,218 --> 00:16:27,685
it gets a zip code, it
sends a temperature.

454
00:16:27,686 --> 00:16:29,288
If all of a sudden it gets
a megabyte of request,

455
00:16:29,288 --> 00:16:31,190
that's worth looking at, right?

456
00:16:31,190 --> 00:16:33,025
Maybe they're trying
to overflow a buffer,

457
00:16:33,025 --> 00:16:34,827
maybe they're trying to drop
an exploit of some sort.

458
00:16:34,827 --> 00:16:36,795
Similarly, if it responds
with a huge chunk,

459
00:16:36,795 --> 00:16:39,064
maybe that's some sort of
memory (mumbling) issue

460
00:16:39,064 --> 00:16:40,531
like we've seen recently, right?

461
00:16:40,532 --> 00:16:42,001
It's returning more
memory than it should.

462
00:16:42,001 --> 00:16:43,235
So both of those instances

463
00:16:43,235 --> 00:16:44,603
might be things you want
to delve in deeper on.

464
00:16:44,603 --> 00:16:46,372
Other things, same.

465
00:16:46,372 --> 00:16:48,207
Backend status codes, right?

466
00:16:48,207 --> 00:16:49,942
Those struts thing
that happened recently.

467
00:16:49,942 --> 00:16:51,543
If that exploit landed,
it gave a response code

468
00:16:51,543 --> 00:16:53,112
so you could find
those pretty easily.

469
00:16:53,112 --> 00:16:54,747
Backend processing time.

470
00:16:54,747 --> 00:16:56,147
If it takes a much longer time,

471
00:16:56,148 --> 00:16:58,717
it probably went down a
different code path to execute.

472
00:16:58,717 --> 00:17:00,419
Maybe they're trying
to find something

473
00:17:00,419 --> 00:17:01,754
hinky on the edges there.

474
00:17:01,754 --> 00:17:03,455
So any of those
things could lead to

475
00:17:03,455 --> 00:17:04,923
follow an investigation.

476
00:17:04,923 --> 00:17:06,858
You're probably not sure
that it's something bad yet,

477
00:17:06,858 --> 00:17:08,493
but it's something that's
worth checking into.

478
00:17:08,493 --> 00:17:09,762
So in order to do that,

479
00:17:09,762 --> 00:17:11,129
you need to then pivot
back to the instance,

480
00:17:11,130 --> 00:17:12,464
and essentially run SSM again,

481
00:17:12,464 --> 00:17:14,399
or however you want to
respond to it, right?

482
00:17:14,400 --> 00:17:16,268
You can do the quarantine
thing or the snapshots.

483
00:17:16,268 --> 00:17:18,871
So to do that, you've
got the backend here

484
00:17:18,871 --> 00:17:20,973
highlighted in green,
and that's the IP address

485
00:17:20,973 --> 00:17:23,308
of the instance that served
that particular request

486
00:17:23,308 --> 00:17:24,576
within the auto-scaling group.

487
00:17:24,576 --> 00:17:26,912
That is very likely
a private IP space,

488
00:17:26,912 --> 00:17:29,515
so usually I'll pivot through
the described load balancers

489
00:17:29,515 --> 00:17:31,550
one more time, get
the list of instances,

490
00:17:31,550 --> 00:17:33,619
filter on that IP address,
then I know where I'm at

491
00:17:33,619 --> 00:17:35,754
and I can continue
my investigation.

492
00:17:35,754 --> 00:17:38,890
So quick digressions,
I think we have time.

493
00:17:38,891 --> 00:17:40,793
Some of the ideas that we have

494
00:17:40,793 --> 00:17:43,695
around what that
response might look like,

495
00:17:43,695 --> 00:17:46,532
and this is kind of where
hunting bleeds into IR

496
00:17:46,532 --> 00:17:48,167
and bleeds into deception,

497
00:17:48,167 --> 00:17:51,837
is you could try and then
control your environment, right?

498
00:17:51,837 --> 00:17:53,906
If you know the directions
that they're coming through.

499
00:17:53,906 --> 00:17:56,908
And that might be looking
through these log files

500
00:17:56,909 --> 00:17:59,178
and detecting the
event that you found,

501
00:17:59,178 --> 00:18:01,547
and then using a Lambda script
to automate your response.

502
00:18:01,547 --> 00:18:03,615
So we already use
scripts, right,

503
00:18:03,615 --> 00:18:05,484
to improve our
automation process.

504
00:18:05,484 --> 00:18:06,918
With Lambdas,

505
00:18:06,919 --> 00:18:08,520
you can basically push
these scripts into the Cloud

506
00:18:08,520 --> 00:18:10,022
and they're hosted there

507
00:18:10,022 --> 00:18:11,756
so you can either trigger them
manually during a response,

508
00:18:11,757 --> 00:18:14,259
or you could have an
event like this trigger

509
00:18:14,259 --> 00:18:16,228
and then take some action.

510
00:18:16,228 --> 00:18:17,930
So one easy one, again,

511
00:18:17,930 --> 00:18:20,299
because we're able to take
out these instances at will,

512
00:18:20,299 --> 00:18:22,401
is you simply pause that one.

513
00:18:22,401 --> 00:18:25,137
So that freezes memory, it
takes it off the network,

514
00:18:25,137 --> 00:18:27,206
and it makes it sort of, yeah,

515
00:18:27,206 --> 00:18:28,774
I wouldn't say it's
fully forensically sound,

516
00:18:28,774 --> 00:18:30,441
but it's in a good state
for you to come back

517
00:18:30,442 --> 00:18:31,710
and look at it later.

518
00:18:31,710 --> 00:18:33,212
You can move it off.

519
00:18:33,212 --> 00:18:34,279
It's now safe, it's not
going to be able to access

520
00:18:34,279 --> 00:18:35,447
any of your information,

521
00:18:35,447 --> 00:18:37,116
but you can come
back at a later time.

522
00:18:37,116 --> 00:18:38,617
Maybe you carve that
responsibility off
to a team member.

523
00:18:38,617 --> 00:18:40,219
Maybe you could
use a third party

524
00:18:40,219 --> 00:18:42,821
and just ship them that
paused instance to play with.

525
00:18:42,821 --> 00:18:44,356
Other things you could do.

526
00:18:44,356 --> 00:18:45,991
This is an ELB example,

527
00:18:45,991 --> 00:18:48,961
but there's also an ALB, an
application load balancer.

528
00:18:48,961 --> 00:18:50,796
So that one is
actually aware of URLs

529
00:18:50,796 --> 00:18:52,498
'cause it's able to load balance

530
00:18:52,498 --> 00:18:53,999
across different API endpoints.

531
00:18:53,999 --> 00:18:56,535
So in that case, say you had
that same PHP example, right?

532
00:18:56,535 --> 00:18:59,605
And you wanted to play a little
deception game with them.

533
00:18:59,605 --> 00:19:01,273
You could say, alright,
if I see the URL

534
00:19:01,273 --> 00:19:03,108
for the PHP backdoor,
I'm going to shunt that

535
00:19:03,108 --> 00:19:05,409
to a decoy instance and just
sort of see what they do.

536
00:19:05,410 --> 00:19:07,513
You know, maybe I can get
some more LCs out of that

537
00:19:07,513 --> 00:19:08,780
I can look elsewhere for,

538
00:19:08,780 --> 00:19:10,415
maybe I can get them to
drop secondary tools.

539
00:19:10,415 --> 00:19:13,252
But you can control the
flow of the adversary

540
00:19:13,252 --> 00:19:14,753
with some of these functions.

541
00:19:14,753 --> 00:19:17,356
And add an ALB, or you
could add a WAF, right?

542
00:19:17,356 --> 00:19:18,657
You could add a web
application firewall

543
00:19:18,657 --> 00:19:20,225
and simply block that
at certain places

544
00:19:20,225 --> 00:19:21,726
to try and funnel them
into your choke point.

545
00:19:21,727 --> 00:19:23,495
And the great thing about

546
00:19:23,495 --> 00:19:26,098
having this sort of
infrastructure as code idea,

547
00:19:26,098 --> 00:19:28,066
is that you can deploy
that in front of your,

548
00:19:28,066 --> 00:19:29,635
let me go back one,

549
00:19:29,635 --> 00:19:31,470
in front of your load
balancer quite easily, right?

550
00:19:31,470 --> 00:19:33,172
It's a few clicks on the console

551
00:19:33,172 --> 00:19:34,473
or some code in the API,

552
00:19:34,473 --> 00:19:36,207
and you've spun up a WAF.

553
00:19:36,208 --> 00:19:38,310
You don't have to go rack
a box and program it,

554
00:19:38,310 --> 00:19:40,212
and do regression
testing, all these things.

555
00:19:40,212 --> 00:19:42,514
You know, you probably have
multiple clusters running.

556
00:19:42,514 --> 00:19:44,917
You throw up a WAF, use
some red-black testing,

557
00:19:44,917 --> 00:19:46,385
and you're off and running.

558
00:19:46,385 --> 00:19:47,719
You're able to be much more
flexible in your control

559
00:19:47,719 --> 00:19:50,189
of where you're
sending your adversary.

560
00:19:50,189 --> 00:19:53,959
So that's an example of
using sort of logging

561
00:19:55,194 --> 00:19:58,497
from AWS about more
traditional vectors.

562
00:19:58,497 --> 00:20:00,265
In this case, you
know, webservers.

563
00:20:00,265 --> 00:20:02,701
The next one I'd like to talk
about is Cloud native threats

564
00:20:02,701 --> 00:20:03,902
and Cloud native hunting.

565
00:20:03,902 --> 00:20:05,871
So in this case, you know,

566
00:20:05,871 --> 00:20:09,508
we've got these great Amazon
APIs I just described, right?

567
00:20:09,508 --> 00:20:11,677
They're great tools
for defenders,

568
00:20:11,677 --> 00:20:13,544
but they're also great
tools for attackers.

569
00:20:13,545 --> 00:20:15,247
So you have this whole
new attack service

570
00:20:15,247 --> 00:20:18,083
on the AWS API that's not
super well understood,

571
00:20:18,083 --> 00:20:20,419
but is a lot fun to try and
figure out how to abuse.

572
00:20:20,419 --> 00:20:23,655
So if you are an attacker
and you are aware of AWS,

573
00:20:23,655 --> 00:20:26,892
you might use it to
facilitate any sort of spot

574
00:20:26,892 --> 00:20:28,160
on your attack chain.

575
00:20:28,160 --> 00:20:30,996
In this case, we'll
focus on ex-filtration

576
00:20:30,996 --> 00:20:33,966
'cause that's a pretty one
to wrap your head around.

577
00:20:33,966 --> 00:20:38,035
The advantage of using
AWS to ex-filtrate data

578
00:20:38,036 --> 00:20:40,072
as opposed to shutting
out of the network,

579
00:20:40,072 --> 00:20:42,040
is that you'll avoid
any of the controls

580
00:20:42,040 --> 00:20:43,976
that traditional defenders
might have in place, right?

581
00:20:43,976 --> 00:20:46,578
You're not going to see a
bigger R file going outbound

582
00:20:46,578 --> 00:20:48,747
or a big disimbalance
in your netflow.

583
00:20:48,747 --> 00:20:51,383
It's just going to happen
through the Amazon API

584
00:20:51,383 --> 00:20:54,453
and you're going to have
to be sort of Cloud aware

585
00:20:54,453 --> 00:20:56,154
to figure out how to catch that.

586
00:20:56,154 --> 00:20:58,957
So fortunately, there's
a really good feature

587
00:20:58,957 --> 00:21:00,926
that you're going to have
to get to know really well

588
00:21:00,926 --> 00:21:02,394
which is CloudTrail,

589
00:21:02,394 --> 00:21:04,263
and that is the logging
functionality of Amazon API.

590
00:21:04,263 --> 00:21:07,632
So CloudTrail produces
very verbose JSON documents

591
00:21:07,633 --> 00:21:10,102
about all the activities
that things are taking

592
00:21:10,102 --> 00:21:11,570
within your environment.

593
00:21:11,570 --> 00:21:15,506
In this case, we'll talk
about a particular technique

594
00:21:15,507 --> 00:21:18,243
that has been theorized about.

595
00:21:18,243 --> 00:21:22,214
And that's, again, sort of
talking about the snapshots.

596
00:21:22,214 --> 00:21:23,915
Forest mentioned them,
I mentioned them.

597
00:21:23,915 --> 00:21:25,082
Excuse me.

598
00:21:25,083 --> 00:21:26,385
They're super useful
for forensics.

599
00:21:26,385 --> 00:21:28,086
They're super useful in ops.

600
00:21:28,086 --> 00:21:29,321
You can use them to backup.

601
00:21:29,321 --> 00:21:31,356
So it tends to be a permission

602
00:21:31,356 --> 00:21:33,458
that's fairly widely
granted to instances, right?

603
00:21:33,458 --> 00:21:35,327
You want people to be able
to back up their instances.

604
00:21:35,327 --> 00:21:37,029
You also want to be able
to share those instances,

605
00:21:37,029 --> 00:21:38,930
maybe with a disaster recovery
account, move them around.

606
00:21:38,930 --> 00:21:41,900
That ability is sort of a key
value proposition of Amazon,

607
00:21:41,900 --> 00:21:44,336
so it's something that
they make possible.

608
00:21:44,336 --> 00:21:46,571
But as an attacker, that's
also a pretty juicy way

609
00:21:46,571 --> 00:21:48,473
to get some of your good data.

610
00:21:48,473 --> 00:21:49,774
So, you know, we
mentioned earlier

611
00:21:49,775 --> 00:21:52,411
that the really high
end threats, you know,

612
00:21:52,411 --> 00:21:54,980
they prefer credentials
over dropping tools, right?

613
00:21:54,980 --> 00:21:57,316
There's no reason to go to
disk on an ephemeral instance.

614
00:21:57,316 --> 00:21:58,850
It's going to be
gone in 24 hours.

615
00:21:58,850 --> 00:22:00,351
So you're not going to see

616
00:22:00,352 --> 00:22:02,187
as many persistence
locations most likely.

617
00:22:02,187 --> 00:22:03,955
They'd rather not
even dwell on memory

618
00:22:03,955 --> 00:22:05,189
if they don't have to.

619
00:22:05,190 --> 00:22:07,392
If they can get creds
and act as a legit user,

620
00:22:07,392 --> 00:22:09,561
that's a much quieter way to
move around your environment.

621
00:22:09,561 --> 00:22:12,297
So a great target for them
then is a build server.

622
00:22:12,297 --> 00:22:14,299
So that's, I guess, the
downside of the CICD pipeline

623
00:22:14,299 --> 00:22:16,802
is you're going to put probably
a fair mount of credential

624
00:22:16,802 --> 00:22:19,204
and power into
your build server.

625
00:22:19,204 --> 00:22:21,340
And so in this instance,
let's say they identify that,

626
00:22:21,340 --> 00:22:25,209
they popped onto your edge,
that instance had permissions.

627
00:22:25,210 --> 00:22:26,912
And we'll talk a little bit

628
00:22:26,912 --> 00:22:28,447
about what an
instance profile is.

629
00:22:28,447 --> 00:22:30,782
To take a snapshot, and they
snapshot your build server,

630
00:22:30,782 --> 00:22:33,552
and they share that snapshot
with their attacker account.

631
00:22:33,552 --> 00:22:35,353
The way they would do that

632
00:22:35,354 --> 00:22:38,757
is they would assume the
role of that instance.

633
00:22:38,757 --> 00:22:41,026
And instances, virtual
machines in AWS,

634
00:22:41,026 --> 00:22:43,061
have this idea of
instance profile.

635
00:22:43,061 --> 00:22:44,663
You can think of it somewhat
like a service account,

636
00:22:44,663 --> 00:22:47,032
but it's basically its identity
within the Amazon world.

637
00:22:47,032 --> 00:22:48,500
And it's a very useful function,

638
00:22:48,500 --> 00:22:49,868
it's a great way to lock down

639
00:22:49,868 --> 00:22:51,102
these privilege on these things.

640
00:22:51,103 --> 00:22:52,371
But it's also, as an attacker,

641
00:22:52,371 --> 00:22:53,839
you can hit this AWS
metadata endpoint

642
00:22:53,839 --> 00:22:55,005
and pull those creds.

643
00:22:55,006 --> 00:22:56,341
And then you act as if

644
00:22:56,341 --> 00:22:58,310
you have the capability
of that endpoint.

645
00:22:58,310 --> 00:23:00,579
So in this instance, you know,
you would take those creds,

646
00:23:00,579 --> 00:23:02,647
you do the snapshot, and
then you'd move it out.

647
00:23:02,647 --> 00:23:05,183
So fortunately again,
CloudTrail sees all this.

648
00:23:05,183 --> 00:23:06,351
They've all been logged.

649
00:23:06,351 --> 00:23:07,886
So while you can't
necessarily prevent it,

650
00:23:07,886 --> 00:23:09,553
you can detect it
and remedial actions.

651
00:23:09,554 --> 00:23:13,225
So here is an example
of a CloudTrail entry.

652
00:23:15,727 --> 00:23:19,231
Again, CloudTrail produces
very very verbose JSONS,

653
00:23:19,231 --> 00:23:21,199
so I couldn't fill up
my slide with that.

654
00:23:21,199 --> 00:23:24,436
So this actually seems
to have, no, yeah,

655
00:23:24,436 --> 00:23:26,605
it seems to have wrapped at
a different rate as well.

656
00:23:26,605 --> 00:23:30,509
In this instance, we are
sending our CloudTrail

657
00:23:31,877 --> 00:23:33,412
into an elastic search cluster.

658
00:23:33,412 --> 00:23:36,148
And it allows you to sort of
poke through it in (mumbling),

659
00:23:36,148 --> 00:23:37,783
which is a pretty good
way to see things.

660
00:23:37,783 --> 00:23:38,783
So to do that, you need to write

661
00:23:38,784 --> 00:23:40,252
a little bit of an ATL layer

662
00:23:40,252 --> 00:23:41,919
to pull it out S3 and
drop it into the cluster.

663
00:23:41,920 --> 00:23:43,722
But you could do the same
kind of thing in Athena

664
00:23:43,722 --> 00:23:46,324
if you knew the
fields really well.

665
00:23:46,324 --> 00:23:47,726
So you gotta get comfortable

666
00:23:47,726 --> 00:23:49,594
with the (mumbling)
documentation on CloudTrail.

667
00:23:49,594 --> 00:23:50,929
But in this instance, right,

668
00:23:50,929 --> 00:23:52,564
I've pulled out a couple
of the relevant fields.

669
00:23:52,564 --> 00:23:55,333
So this is some
mass data from me

670
00:23:55,333 --> 00:23:57,135
sort of performing that attack

671
00:23:57,135 --> 00:23:58,937
from one of our
production accounts,

672
00:23:58,937 --> 00:24:01,339
and moving a snapshot
into my friend's account.

673
00:24:01,339 --> 00:24:02,908
So I did it two
different ways here.

674
00:24:02,908 --> 00:24:06,244
So you'll see, there's
the timestamp obviously.

675
00:24:06,244 --> 00:24:09,981
The event name is modified
snapshot attribute.

676
00:24:09,981 --> 00:24:13,485
That was the API call I
chose to sort of search for

677
00:24:13,485 --> 00:24:16,053
'cause it's one
that you, you know,

678
00:24:16,054 --> 00:24:17,456
that gives you the right data.

679
00:24:17,456 --> 00:24:18,689
So I pulled up all of those.

680
00:24:18,690 --> 00:24:20,459
You'll see the field
that I extracted here

681
00:24:20,459 --> 00:24:21,827
is called request parameters

682
00:24:21,827 --> 00:24:24,029
great volume
permissions at items.

683
00:24:24,029 --> 00:24:25,697
And then there's
this key value pair.

684
00:24:25,697 --> 00:24:26,864
Excuse me.

685
00:24:26,865 --> 00:24:28,900
The user ID is a
little bit misleading,

686
00:24:28,900 --> 00:24:30,101
it's actually an account ID.

687
00:24:30,101 --> 00:24:32,871
And then the value there
is a mast account ID

688
00:24:32,871 --> 00:24:34,072
that you would see.

689
00:24:34,072 --> 00:24:35,873
And so you would look
through this list

690
00:24:35,874 --> 00:24:38,009
if you're running a
single account deployment,

691
00:24:38,009 --> 00:24:39,878
and you'd look for any ones

692
00:24:39,878 --> 00:24:41,745
that weren't your
account number.

693
00:24:41,746 --> 00:24:43,315
If you're like us and you
run multiple accounts,

694
00:24:43,315 --> 00:24:45,317
you would probably
automate that comparison

695
00:24:45,317 --> 00:24:47,085
against a table of
accounts that you have.

696
00:24:47,085 --> 00:24:48,587
And if it's not one
of your accounts,

697
00:24:48,587 --> 00:24:50,222
then you need to do some
follow and investigation.

698
00:24:50,222 --> 00:24:51,423
The first thing you do

699
00:24:51,423 --> 00:24:52,958
is you probably
reach out to Amazon.

700
00:24:52,958 --> 00:24:54,426
There's this idea

701
00:24:54,426 --> 00:24:55,894
of the shared responsibility
model with them, right?

702
00:24:55,894 --> 00:24:56,995
They handle everything
sort of kernel and below,

703
00:24:56,995 --> 00:24:58,229
and all of their API stuff.

704
00:24:58,230 --> 00:24:59,698
So you'd reach out
to them and say hey,

705
00:24:59,698 --> 00:25:00,966
this account's not mine,

706
00:25:00,966 --> 00:25:02,700
you know, what's going
on with it, thank you.

707
00:25:02,701 --> 00:25:05,537
And often times, they'll
come back and say

708
00:25:05,537 --> 00:25:06,805
oh yeah, it's one of ours.

709
00:25:06,805 --> 00:25:08,373
So they actually will
jump into your account

710
00:25:08,373 --> 00:25:09,975
at certain times to clean things
up and move things around.

711
00:25:09,975 --> 00:25:12,310
So we keep sort of a running
list of known Amazon accounts.

712
00:25:12,310 --> 00:25:15,013
But if they say no,
that's not ours,

713
00:25:15,013 --> 00:25:16,514
then you file an abuse complaint

714
00:25:16,515 --> 00:25:17,916
and they'll go try
and action that

715
00:25:17,916 --> 00:25:20,685
to figure out if this attacker's
compromised an account,

716
00:25:20,685 --> 00:25:22,921
spun it up, whatever it
is, and help you remediate.

717
00:25:22,921 --> 00:25:24,422
But on your end,

718
00:25:24,422 --> 00:25:25,957
you still want to chase down
how this happened, right?

719
00:25:25,957 --> 00:25:28,159
And that's where you're going
to use this user identity ARN,

720
00:25:28,159 --> 00:25:29,427
Amazon resource number.

721
00:25:29,427 --> 00:25:33,098
So on the top line,
you'll see this ARN here

722
00:25:33,965 --> 00:25:35,567
is an instance profile.

723
00:25:35,567 --> 00:25:37,269
So we have discussed
these before.

724
00:25:37,269 --> 00:25:39,037
This was a case where I sort of

725
00:25:39,037 --> 00:25:40,639
simulated an attack
from the edge,

726
00:25:40,639 --> 00:25:42,873
and that's where I would have
exploded onto an instance,

727
00:25:42,874 --> 00:25:45,410
I'd have grabbed creds from
the Amazon metadata service,

728
00:25:45,410 --> 00:25:48,179
and then I would have
pretended to be that instance

729
00:25:48,179 --> 00:25:49,347
and done the snapshot.

730
00:25:49,347 --> 00:25:50,782
Your following activity here

731
00:25:50,782 --> 00:25:53,018
would be to go do some
forensics on this instance,

732
00:25:53,018 --> 00:25:56,087
figure out who had been on
there, what had happened,

733
00:25:56,087 --> 00:25:57,088
how that got compromised.

734
00:25:57,088 --> 00:25:58,757
The other way to
do it is a user.

735
00:25:58,757 --> 00:26:00,492
So if I did it as a user,

736
00:26:00,492 --> 00:26:02,793
you would see something
along these lines

737
00:26:02,794 --> 00:26:04,829
over the user ID.

738
00:26:04,829 --> 00:26:06,364
So then, you could, you know,

739
00:26:06,364 --> 00:26:07,766
you could reach out to that user

740
00:26:07,766 --> 00:26:09,134
and ask them if they did this.

741
00:26:09,134 --> 00:26:10,535
If they said no,
probably roll their creds

742
00:26:10,535 --> 00:26:11,870
and move on through that.

743
00:26:11,870 --> 00:26:14,606
So this one example of
many, many, many ways

744
00:26:14,606 --> 00:26:16,608
to abuse the AWS API.

745
00:26:16,608 --> 00:26:18,109
It's why I love my job,

746
00:26:18,109 --> 00:26:20,044
'cause I get to keep
figuring these new ways out.

747
00:26:20,045 --> 00:26:21,513
And also, it's a lot of fun

748
00:26:21,513 --> 00:26:23,048
'cause Amazon is
constantly innovating

749
00:26:23,048 --> 00:26:24,716
and releasing new services
that are both super useful

750
00:26:24,716 --> 00:26:27,385
and probably, you
know, ripe for abuse.

751
00:26:27,385 --> 00:26:29,054
So here's another quick one.

752
00:26:29,054 --> 00:26:31,623
You could also share
a machine image

753
00:26:31,623 --> 00:26:33,258
instead of just a snapshot.

754
00:26:33,258 --> 00:26:35,694
You could set up
cross-account sharing

755
00:26:35,694 --> 00:26:39,264
for various data queues, for
S3 buckets, for you name it.

756
00:26:39,264 --> 00:26:43,467
So yeah, it's an evolving
landscape on which to hunt.

757
00:26:43,468 --> 00:26:46,104
It's just a lot of
fun to work with.

758
00:26:46,104 --> 00:26:48,773
(intense music)

