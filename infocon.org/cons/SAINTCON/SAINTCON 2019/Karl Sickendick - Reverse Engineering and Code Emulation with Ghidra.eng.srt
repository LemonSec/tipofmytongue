1
00:00:00,979 --> 00:00:06,629
cool alright well thanks for coming to

2
00:00:04,230 --> 00:00:08,010
my talk today my name is Karl sickand

3
00:00:06,629 --> 00:00:11,879
dick and we're going to talk about

4
00:00:08,010 --> 00:00:17,100
deidre reverse engineering and p-code

5
00:00:11,880 --> 00:00:19,680
emulation so first we've got a little

6
00:00:17,100 --> 00:00:21,210
description of what Dedra is then we're

7
00:00:19,680 --> 00:00:23,009
going to talk about P code annulation

8
00:00:21,210 --> 00:00:25,220
and a tool that I built specifically for

9
00:00:23,010 --> 00:00:28,050
that and then we're going to talk about

10
00:00:25,220 --> 00:00:30,990
more generally how to do giedrius get to

11
00:00:28,050 --> 00:00:34,890
Dedra scripting with the Python

12
00:00:30,990 --> 00:00:37,559
programming language so first of all

13
00:00:34,890 --> 00:00:40,020
though Who am I who the heck is this guy

14
00:00:37,559 --> 00:00:41,419
in front of you my name is Carl second

15
00:00:40,020 --> 00:00:45,390
dick and if you'd like to follow along

16
00:00:41,420 --> 00:00:47,700
my Twitter handles up there I posted a

17
00:00:45,390 --> 00:00:50,879
link to a github repo that's got all

18
00:00:47,700 --> 00:00:53,250
this information so feel free to check

19
00:00:50,879 --> 00:00:56,629
in there follow the slides download the

20
00:00:53,250 --> 00:00:59,489
code whatever you want my day job is I'm

21
00:00:56,629 --> 00:01:01,108
active duty in the Air Force they've got

22
00:00:59,489 --> 00:01:02,669
me stationed up at Idaho National Labs

23
00:01:01,109 --> 00:01:05,600
for a year which is a pretty sweet gig

24
00:01:02,670 --> 00:01:08,369
I'm a fellow and that means that I

25
00:01:05,600 --> 00:01:11,460
talked to the researchers talked to the

26
00:01:08,369 --> 00:01:14,570
Air Force participate in some research

27
00:01:11,460 --> 00:01:17,729
do whatever seems fun it's a great gig

28
00:01:14,570 --> 00:01:20,039
but my background is some keep cyber

29
00:01:17,729 --> 00:01:21,298
capability and tactics development I'm

30
00:01:20,040 --> 00:01:23,670
pretty happy to be here this is my first

31
00:01:21,299 --> 00:01:25,320
year at st. Conn it seems awesome so far

32
00:01:23,670 --> 00:01:27,990
those are some great keynotes this

33
00:01:25,320 --> 00:01:31,740
morning and thanks thanks for showing up

34
00:01:27,990 --> 00:01:36,479
to my talk it's awesome all right so

35
00:01:31,740 --> 00:01:37,110
who's used deidre before few who is good

36
00:01:36,479 --> 00:01:40,590
at giedrius

37
00:01:37,110 --> 00:01:44,729
or good enough okay awesome

38
00:01:40,590 --> 00:01:47,430
cool so I'm not like a Ghidorah guru or

39
00:01:44,729 --> 00:01:48,990
anything but I've I've used it at least

40
00:01:47,430 --> 00:01:52,170
since it came out it's pretty great I

41
00:01:48,990 --> 00:01:55,470
think and it's fun so we're gonna go

42
00:01:52,170 --> 00:01:57,299
over first what it is and a little bit

43
00:01:55,470 --> 00:02:00,630
of how to use it so it's an open-source

44
00:01:57,299 --> 00:02:03,719
tool it was released by the NSA it's

45
00:02:00,630 --> 00:02:07,289
your tax dollars at work so other than

46
00:02:03,719 --> 00:02:10,169
that it's free it's got a lot of great

47
00:02:07,290 --> 00:02:11,130
features the biggest one in my opinion

48
00:02:10,169 --> 00:02:14,880
is the deacon

49
00:02:11,130 --> 00:02:18,060
Tyler so the way that works Deidre's got

50
00:02:14,880 --> 00:02:19,890
sleigh modules in it that understand the

51
00:02:18,060 --> 00:02:21,990
binary data for a bunch of different

52
00:02:19,890 --> 00:02:26,220
architectures each sleigh module is for

53
00:02:21,990 --> 00:02:29,400
an architecture a sleigh module can pull

54
00:02:26,220 --> 00:02:31,950
that code up into P code which is an

55
00:02:29,400 --> 00:02:35,000
architecture agnostic intermediate

56
00:02:31,950 --> 00:02:37,649
language for goodra and then giedrius

57
00:02:35,000 --> 00:02:39,470
decompiler understands P code to pull

58
00:02:37,650 --> 00:02:42,270
out program flow and figure out

59
00:02:39,470 --> 00:02:44,640
essentially what the C code was that

60
00:02:42,270 --> 00:02:46,680
went into this program so that's a

61
00:02:44,640 --> 00:02:49,950
feature in Ida that you get to pay for

62
00:02:46,680 --> 00:02:53,750
and frankly I'm partial to this one

63
00:02:49,950 --> 00:02:57,329
regardless excuse me

64
00:02:53,750 --> 00:03:01,260
so how do you set it up download it

65
00:02:57,330 --> 00:03:04,560
install open JDK 11 unzip giedrius

66
00:03:01,260 --> 00:03:07,260
wherever you want and go in there and

67
00:03:04,560 --> 00:03:09,360
execute deidre run or guitro run dot dot

68
00:03:07,260 --> 00:03:14,220
if you're on Windows it's a java

69
00:03:09,360 --> 00:03:17,490
application so it works everywhere dual

70
00:03:14,220 --> 00:03:19,830
monitors is strongly suggested so if you

71
00:03:17,490 --> 00:03:22,560
need a reason for your boss to buy you a

72
00:03:19,830 --> 00:03:25,140
second monitor you can parrot that and

73
00:03:22,560 --> 00:03:28,920
I'm sure the the funding will just fly

74
00:03:25,140 --> 00:03:30,929
off the shelf so how is Gator organized

75
00:03:28,920 --> 00:03:33,149
once you open it up you're going to

76
00:03:30,930 --> 00:03:35,970
create a project and you can create a

77
00:03:33,150 --> 00:03:37,530
local or a shared project so if you

78
00:03:35,970 --> 00:03:39,720
create a shared project and you've got a

79
00:03:37,530 --> 00:03:41,940
giedrius server then your whole team can

80
00:03:39,720 --> 00:03:43,620
work together and contribute to the

81
00:03:41,940 --> 00:03:46,320
reverse engineering store in this

82
00:03:43,620 --> 00:03:49,740
project so you can add new binaries you

83
00:03:46,320 --> 00:03:51,870
can track even the version of your D

84
00:03:49,740 --> 00:03:53,730
compilation as you go along so if

85
00:03:51,870 --> 00:03:55,470
somebody makes a stupid change you can

86
00:03:53,730 --> 00:03:59,070
go and figure out who that was and and

87
00:03:55,470 --> 00:04:00,630
get blame them it also shares the data

88
00:03:59,070 --> 00:04:03,480
structures between all the different

89
00:04:00,630 --> 00:04:06,150
users and there's even some some change

90
00:04:03,480 --> 00:04:09,450
emerging merging that's built into that

91
00:04:06,150 --> 00:04:11,190
a Juris server so you don't accidentally

92
00:04:09,450 --> 00:04:12,958
stop on each other's commits and if

93
00:04:11,190 --> 00:04:14,609
you're doing this just by yourself you

94
00:04:12,959 --> 00:04:16,410
don't need a giedrius server you just

95
00:04:14,610 --> 00:04:18,750
have a local project a non-shared

96
00:04:16,410 --> 00:04:21,900
project and it works great still guiter

97
00:04:18,750 --> 00:04:24,150
also can open some file systems so you

98
00:04:21,899 --> 00:04:24,989
can if you've got a file system binary

99
00:04:24,150 --> 00:04:27,270
you can

100
00:04:24,990 --> 00:04:29,490
the binaries on there that you might be

101
00:04:27,270 --> 00:04:33,210
interested out right into Deidre import

102
00:04:29,490 --> 00:04:34,860
them that way some of the architectures

103
00:04:33,210 --> 00:04:39,960
that are supported are listed here you

104
00:04:34,860 --> 00:04:43,710
get a lot of typical ones arm x86 32 and

105
00:04:39,960 --> 00:04:46,080
64-bit you've also got some weird ones a

106
00:04:43,710 --> 00:04:48,388
bunch of micro processors are supported

107
00:04:46,080 --> 00:04:50,370
some older architectures and so again

108
00:04:48,389 --> 00:04:53,400
because there's a sleigh module for each

109
00:04:50,370 --> 00:04:55,590
of these architectures you can you can

110
00:04:53,400 --> 00:05:00,630
disassemble and then you can D compile

111
00:04:55,590 --> 00:05:02,070
them using deidre so how does that look

112
00:05:00,630 --> 00:05:05,419
what does that look like you open up

113
00:05:02,070 --> 00:05:08,729
gira deidre run you create a new project

114
00:05:05,419 --> 00:05:11,039
under the file menu then you import a

115
00:05:08,729 --> 00:05:12,270
file under the file menu and now you've

116
00:05:11,039 --> 00:05:14,580
got exact you're going to be in the

117
00:05:12,270 --> 00:05:17,070
state that you see here you can organize

118
00:05:14,580 --> 00:05:19,080
these into folders and such but then if

119
00:05:17,070 --> 00:05:22,169
you double-click on that file that

120
00:05:19,080 --> 00:05:28,080
you've imported now you get to the main

121
00:05:22,169 --> 00:05:32,430
window so in the center of the screen

122
00:05:28,080 --> 00:05:34,979
there's the program listing and this

123
00:05:32,430 --> 00:05:38,130
shows the assembly instructions the data

124
00:05:34,979 --> 00:05:40,020
that's all in this file that's kind of

125
00:05:38,130 --> 00:05:42,690
the main window for most people that are

126
00:05:40,020 --> 00:05:43,979
used to static analysis we're going to

127
00:05:42,690 --> 00:05:46,770
talk about the other parts of the screen

128
00:05:43,979 --> 00:05:48,570
as we go on but really the first thing

129
00:05:46,770 --> 00:05:51,030
that'll pop up when you open a new

130
00:05:48,570 --> 00:05:52,530
binaries this analysis window before

131
00:05:51,030 --> 00:05:54,419
giedrius can understand where all the

132
00:05:52,530 --> 00:05:56,520
functions and the data are it's got to

133
00:05:54,419 --> 00:05:58,139
analyze it so when you're doing this

134
00:05:56,520 --> 00:06:00,630
yourself you can scroll through and see

135
00:05:58,139 --> 00:06:02,550
the massive list of different analyses

136
00:06:00,630 --> 00:06:05,130
that you can turn on and off but just

137
00:06:02,550 --> 00:06:05,820
start with the default hit analyzed it

138
00:06:05,130 --> 00:06:07,650
works quite well

139
00:06:05,820 --> 00:06:09,270
once you've done that deidre all know

140
00:06:07,650 --> 00:06:10,650
the list of functions or at least the

141
00:06:09,270 --> 00:06:13,139
ones that it was able to find and

142
00:06:10,650 --> 00:06:15,409
they'll be available in this symbol tree

143
00:06:13,139 --> 00:06:18,090
window on the left center of your screen

144
00:06:15,409 --> 00:06:20,729
so you can use that to find the specific

145
00:06:18,090 --> 00:06:24,750
functions you're interested in starting

146
00:06:20,729 --> 00:06:27,570
your analysis with on Linux a great one

147
00:06:24,750 --> 00:06:30,870
to start with is main so here we see a

148
00:06:27,570 --> 00:06:35,010
program listing for a main the main

149
00:06:30,870 --> 00:06:38,370
function in a binary this was a x86 64

150
00:06:35,010 --> 00:06:38,729
binary at the top or in the in the

151
00:06:38,370 --> 00:06:40,620
middle this

152
00:06:38,729 --> 00:06:42,479
you'll notice there's no assembly that's

153
00:06:40,620 --> 00:06:44,759
because the first at the top of each

154
00:06:42,479 --> 00:06:47,219
function the first thing the program

155
00:06:44,759 --> 00:06:51,089
list is going to show you is giedrius

156
00:06:47,219 --> 00:06:55,979
mapping of nice English variable names

157
00:06:51,089 --> 00:06:58,020
to stack locations and registers so if

158
00:06:55,979 --> 00:06:59,400
you need that mapping it's at the top of

159
00:06:58,020 --> 00:07:01,438
the function just scroll down a little

160
00:06:59,400 --> 00:07:04,080
bit and you'll hit the the code that

161
00:07:01,439 --> 00:07:06,960
you're expecting so we're looking at the

162
00:07:04,080 --> 00:07:11,219
main function Prolog here the first

163
00:07:06,960 --> 00:07:14,839
instruction is push rbp so save off that

164
00:07:11,219 --> 00:07:14,839
base pointer before you do the function

165
00:07:15,710 --> 00:07:21,180
how do we see the P code this icon is in

166
00:07:19,740 --> 00:07:23,490
the top right of the program listing

167
00:07:21,180 --> 00:07:25,800
screen so if you click on it you'll get

168
00:07:23,490 --> 00:07:27,449
this drop down they'll show all of the

169
00:07:25,800 --> 00:07:29,430
different types of data

170
00:07:27,449 --> 00:07:31,649
deidre can show you in that program

171
00:07:29,430 --> 00:07:33,749
listing window about the function that

172
00:07:31,649 --> 00:07:35,490
you're on one of them is P code it's the

173
00:07:33,749 --> 00:07:37,439
highlighted one if you right-click on

174
00:07:35,490 --> 00:07:39,330
that if you're on this instructions and

175
00:07:37,439 --> 00:07:41,879
data tab there's multiple tabs of

176
00:07:39,330 --> 00:07:43,770
potential data if you're on that tab you

177
00:07:41,879 --> 00:07:46,800
right-click on P code you can click

178
00:07:43,770 --> 00:07:49,139
enable and you'll see now the program

179
00:07:46,800 --> 00:07:51,719
listing has got not only the assembly

180
00:07:49,139 --> 00:07:53,610
but also the the P code down to the side

181
00:07:51,719 --> 00:07:57,330
of it let's let's look at that a little

182
00:07:53,610 --> 00:08:01,469
bit more closely so push RB p who knows

183
00:07:57,330 --> 00:08:04,258
who gets what that does push take the

184
00:08:01,469 --> 00:08:07,099
base pointer put it onto the stack on

185
00:08:04,259 --> 00:08:11,370
x64 a lot of us are familiar with with

186
00:08:07,099 --> 00:08:13,830
x86 programming so the P code is not

187
00:08:11,370 --> 00:08:16,020
going to come as any surprise to you the

188
00:08:13,830 --> 00:08:17,520
first thing you've got to do is take it

189
00:08:16,020 --> 00:08:20,039
for some reason it takes that register

190
00:08:17,520 --> 00:08:23,248
it saves off a copy of it in a temporary

191
00:08:20,039 --> 00:08:25,169
state space which is that you 2 5 10

192
00:08:23,249 --> 00:08:28,319
that'll never get written to again

193
00:08:25,169 --> 00:08:31,198
that's kind of a cool fact but it saves

194
00:08:28,319 --> 00:08:33,630
off a copy of the the base pointer at

195
00:08:31,199 --> 00:08:35,699
the end you can see it takes that copy

196
00:08:33,630 --> 00:08:37,559
and puts it into memory

197
00:08:35,698 --> 00:08:39,838
wherever the stack pointer is at that

198
00:08:37,559 --> 00:08:42,448
point but before that in the middle it's

199
00:08:39,839 --> 00:08:43,919
got a decrement the stack pointer so

200
00:08:42,448 --> 00:08:47,670
it's got to grow the stack pointer down

201
00:08:43,919 --> 00:08:50,010
and then you store rbp at the location

202
00:08:47,670 --> 00:08:52,560
on the stack that the stack pointer

203
00:08:50,010 --> 00:08:54,420
currently points to

204
00:08:52,560 --> 00:08:56,790
everybody knew that a lot of people knew

205
00:08:54,420 --> 00:08:59,400
that the RVP got pushed onto the stack

206
00:08:56,790 --> 00:09:03,199
but the exact semantics of how this

207
00:08:59,400 --> 00:09:05,310
works in x86 you may or may not remember

208
00:09:03,200 --> 00:09:07,140
especially if you move between different

209
00:09:05,310 --> 00:09:08,310
architectures so and here we've got a

210
00:09:07,140 --> 00:09:12,990
different architecture we've got an a

211
00:09:08,310 --> 00:09:15,119
arch an arm 64 binary it's again it's

212
00:09:12,990 --> 00:09:18,360
the prologue for that main function and

213
00:09:15,120 --> 00:09:20,510
right here we've got the STP instruction

214
00:09:18,360 --> 00:09:23,490
it's the first instruction in a in the

215
00:09:20,510 --> 00:09:26,100
function it's probably gonna do this the

216
00:09:23,490 --> 00:09:28,950
same thing as the x64 version is

217
00:09:26,100 --> 00:09:32,580
probably gonna push some state onto the

218
00:09:28,950 --> 00:09:35,730
stack but I don't usually remember what

219
00:09:32,580 --> 00:09:38,100
STP does you can look at the P code and

220
00:09:35,730 --> 00:09:41,490
you can see pretty quickly exactly what

221
00:09:38,100 --> 00:09:42,900
that instruction is doing you can see it

222
00:09:41,490 --> 00:09:44,310
so if you read through this you can see

223
00:09:42,900 --> 00:09:46,199
exactly what the semantics of that

224
00:09:44,310 --> 00:09:48,510
instruction are another great feature of

225
00:09:46,200 --> 00:09:51,360
deidre if you right-click on STP and

226
00:09:48,510 --> 00:09:53,580
then click on processor manual it'll

227
00:09:51,360 --> 00:09:55,050
either pop up the manual right to that

228
00:09:53,580 --> 00:09:56,940
spot or it'll tell you where to download

229
00:09:55,050 --> 00:10:00,120
that manual if that's protected by

230
00:09:56,940 --> 00:10:03,089
copyright so moving between

231
00:10:00,120 --> 00:10:05,250
architectures is is quite easy to do on

232
00:10:03,089 --> 00:10:09,870
Ghidorah it's easier than a lot of other

233
00:10:05,250 --> 00:10:11,910
tools that I've seen alright so we've

234
00:10:09,870 --> 00:10:14,610
seen the P code we've seen the assembly

235
00:10:11,910 --> 00:10:18,810
let's see the D copulation that's what

236
00:10:14,610 --> 00:10:21,300
we're here for Carl on the right side is

237
00:10:18,810 --> 00:10:22,949
the D compilation window and again G

238
00:10:21,300 --> 00:10:25,620
drew does this by taking that processor

239
00:10:22,950 --> 00:10:28,050
agnostic P code and figuring out the

240
00:10:25,620 --> 00:10:30,540
code flow we're gonna zoom in on that in

241
00:10:28,050 --> 00:10:32,640
a little bit but now we're going to talk

242
00:10:30,540 --> 00:10:34,980
about a couple strategies to improve the

243
00:10:32,640 --> 00:10:37,350
D compilation by default there's only so

244
00:10:34,980 --> 00:10:40,080
much that geezer can learn can figure

245
00:10:37,350 --> 00:10:42,690
out about how that C code worked so you

246
00:10:40,080 --> 00:10:44,900
can improve it by right-clicking on the

247
00:10:42,690 --> 00:10:47,760
function name in the D compilation and

248
00:10:44,900 --> 00:10:49,620
editing the function signature so here

249
00:10:47,760 --> 00:10:51,660
we knew pretty quickly what the main

250
00:10:49,620 --> 00:10:55,230
function was you can you can set the

251
00:10:51,660 --> 00:10:57,510
name properly we know the typical way a

252
00:10:55,230 --> 00:11:00,300
main function is called so you can set

253
00:10:57,510 --> 00:11:02,700
the data types and the names of each of

254
00:11:00,300 --> 00:11:04,829
the parameters and if you commit that in

255
00:11:02,700 --> 00:11:06,150
Ghidorah it's going to propagate that

256
00:11:04,830 --> 00:11:09,150
information as far as

257
00:11:06,150 --> 00:11:11,880
can through your code so it's going to

258
00:11:09,150 --> 00:11:13,170
save off the the names and the types

259
00:11:11,880 --> 00:11:15,540
it's going to propagate them to other

260
00:11:13,170 --> 00:11:18,599
spots another way to improve your D

261
00:11:15,540 --> 00:11:21,000
compilation is to build and assign data

262
00:11:18,600 --> 00:11:23,730
structures wherever they are in the code

263
00:11:21,000 --> 00:11:25,290
so if it's in the data of the binary you

264
00:11:23,730 --> 00:11:27,839
would do that in the program listing if

265
00:11:25,290 --> 00:11:29,969
it's two parameters in a function you do

266
00:11:27,839 --> 00:11:32,850
that in the D compilation window you can

267
00:11:29,970 --> 00:11:35,910
build custom structures and and assign

268
00:11:32,850 --> 00:11:39,860
them and build build custom data types

269
00:11:35,910 --> 00:11:42,150
data type aliases function types that

270
00:11:39,860 --> 00:11:43,620
would that work for function pointers

271
00:11:42,150 --> 00:11:45,779
that are being passed around you can

272
00:11:43,620 --> 00:11:47,100
build all that using that box in the

273
00:11:45,779 --> 00:11:50,790
bottom left hand corner of the main

274
00:11:47,100 --> 00:11:53,160
window so let's zoom in on some d

275
00:11:50,790 --> 00:11:55,199
compilation and specifically here we see

276
00:11:53,160 --> 00:11:58,920
how B drew has automatically propagated

277
00:11:55,200 --> 00:12:00,870
the types for the Nano sleep function to

278
00:11:58,920 --> 00:12:04,339
other parts of this function that uses

279
00:12:00,870 --> 00:12:06,870
Nano sleep so deidre knows about G Lipsy

280
00:12:04,339 --> 00:12:09,390
it knows that Nano sleep takes two

281
00:12:06,870 --> 00:12:11,760
pointers to time stat as time spec

282
00:12:09,390 --> 00:12:14,279
structures excuse me and so it's

283
00:12:11,760 --> 00:12:16,380
automatically kind of back propagated to

284
00:12:14,279 --> 00:12:18,209
figure out where those things are

285
00:12:16,380 --> 00:12:22,680
assigned and it's even filled in the

286
00:12:18,209 --> 00:12:24,630
function the function definition with

287
00:12:22,680 --> 00:12:26,579
the correct types up there for the data

288
00:12:24,630 --> 00:12:28,290
that's being passed in so now you've got

289
00:12:26,580 --> 00:12:32,790
to commit this by right clicking and

290
00:12:28,290 --> 00:12:34,529
clicking commit params returns but after

291
00:12:32,790 --> 00:12:36,959
you commit it D juror will propagate

292
00:12:34,529 --> 00:12:41,910
that information throughout the code as

293
00:12:36,959 --> 00:12:44,279
far as it can go if you're if you love

294
00:12:41,910 --> 00:12:46,410
the function graph function within Ida

295
00:12:44,279 --> 00:12:49,500
then Geeta also does function graphs

296
00:12:46,410 --> 00:12:50,579
it's up under the window menu then of

297
00:12:49,500 --> 00:12:52,890
course there's a bunch of other cool

298
00:12:50,580 --> 00:12:55,560
features that we don't have time to talk

299
00:12:52,890 --> 00:12:56,850
about middle clicking on entities to

300
00:12:55,560 --> 00:12:59,670
highlight them throughout your code it's

301
00:12:56,850 --> 00:13:02,880
really handy so I recommend trying that

302
00:12:59,670 --> 00:13:07,319
and it's got undo which is a really nice

303
00:13:02,880 --> 00:13:09,000
feature it's in Ida now too but we we

304
00:13:07,320 --> 00:13:10,529
came to talk about scripts and scripting

305
00:13:09,000 --> 00:13:12,300
so under the window menu there's the

306
00:13:10,529 --> 00:13:14,700
script manager if you click on that

307
00:13:12,300 --> 00:13:17,729
you'll get a whole list of scripts and

308
00:13:14,700 --> 00:13:19,649
most of these are Java scripts not Java

309
00:13:17,730 --> 00:13:24,990
scripts but Java space

310
00:13:19,649 --> 00:13:27,420
scripts and their I mean I'm not a huge

311
00:13:24,990 --> 00:13:29,699
fan of Java it works pretty well but

312
00:13:27,420 --> 00:13:32,878
they are great examples for how to use

313
00:13:29,699 --> 00:13:35,069
the Geiger API to interact with all of

314
00:13:32,879 --> 00:13:38,730
the all of your d compilation and

315
00:13:35,069 --> 00:13:41,128
disassembly and my if you if you

316
00:13:38,730 --> 00:13:42,389
download and install my script then it

317
00:13:41,129 --> 00:13:45,480
will show up under the P code category

318
00:13:42,389 --> 00:13:45,839
and you just double-click on it to run

319
00:13:45,480 --> 00:13:47,399
it

320
00:13:45,839 --> 00:13:49,529
and once you're in the function that you

321
00:13:47,399 --> 00:13:52,110
want to emulate so let's talk about P

322
00:13:49,529 --> 00:13:54,689
code emulation first of all why would

323
00:13:52,110 --> 00:13:56,670
you want to do this it's kind of a

324
00:13:54,689 --> 00:13:59,610
middle ground between static and dynamic

325
00:13:56,670 --> 00:14:02,509
analysis when you're when you're doing

326
00:13:59,610 --> 00:14:05,970
static analysis as you do in Ghidorah

327
00:14:02,509 --> 00:14:07,740
then perhaps you have a function and you

328
00:14:05,970 --> 00:14:09,959
want to investigate you know if I

329
00:14:07,740 --> 00:14:12,089
provide these parameters what kind of

330
00:14:09,959 --> 00:14:14,099
outputs do I get normally you could fire

331
00:14:12,089 --> 00:14:16,439
up a debugger and find this out but if

332
00:14:14,100 --> 00:14:18,269
the function call is way down within the

333
00:14:16,439 --> 00:14:20,610
middle of the program it might be really

334
00:14:18,269 --> 00:14:23,220
hard to do that bit of dynamic analysis

335
00:14:20,610 --> 00:14:25,439
so this simplifies that but also

336
00:14:23,220 --> 00:14:27,179
simplifies the case where the code is

337
00:14:25,439 --> 00:14:29,339
malicious or the code is for an

338
00:14:27,179 --> 00:14:31,529
architecture you don't have an emulator

339
00:14:29,339 --> 00:14:33,389
or hardware for or maybe you've got the

340
00:14:31,529 --> 00:14:36,120
hardware but how do you hook up a

341
00:14:33,389 --> 00:14:38,399
debugger on this this microchip it's

342
00:14:36,120 --> 00:14:41,490
pretty tough so that's that's why you

343
00:14:38,399 --> 00:14:43,249
might want to use this software and the

344
00:14:41,490 --> 00:14:46,829
demo code that we're gonna do is

345
00:14:43,249 --> 00:14:50,399
relevant to this week there's a NSA

346
00:14:46,829 --> 00:14:54,209
released a Python excuse me yeah Python

347
00:14:50,399 --> 00:14:57,240
version of an enigma simulator and so I

348
00:14:54,209 --> 00:15:00,569
poured that to see real quick and threw

349
00:14:57,240 --> 00:15:03,179
it into gira for analysis let's get that

350
00:15:00,569 --> 00:15:05,309
started because it takes a couple

351
00:15:03,179 --> 00:15:07,230
minutes to run so I've got Ghidorah

352
00:15:05,309 --> 00:15:12,990
running over here already I've got a

353
00:15:07,230 --> 00:15:16,110
project and the Enigma code imported the

354
00:15:12,990 --> 00:15:17,819
function that we want to analyze is

355
00:15:16,110 --> 00:15:20,249
called run alga

356
00:15:17,819 --> 00:15:23,819
I wrote this myself to play to the

357
00:15:20,249 --> 00:15:26,759
strengths of my terrible code but we'll

358
00:15:23,819 --> 00:15:28,199
pull up run algo over here and it's

359
00:15:26,759 --> 00:15:29,639
already got the function signature up

360
00:15:28,199 --> 00:15:32,370
here we'll talk about this more in just

361
00:15:29,639 --> 00:15:33,030
a second but it takes five character

362
00:15:32,370 --> 00:15:36,030
pointers

363
00:15:33,030 --> 00:15:40,199
five pointers to strings as the

364
00:15:36,030 --> 00:15:43,589
arguments and now we'll pull up the P

365
00:15:40,200 --> 00:15:47,490
code emulation script decode interpreter

366
00:15:43,590 --> 00:15:48,810
and we'll start it running so the first

367
00:15:47,490 --> 00:15:50,940
thing it's gonna do is ask for those

368
00:15:48,810 --> 00:15:53,069
parameters to pass in and we're going to

369
00:15:50,940 --> 00:15:54,720
pass in these are pointers that it needs

370
00:15:53,070 --> 00:15:56,970
so we're gonna pass in memory locations

371
00:15:54,720 --> 00:16:04,140
it already knows what I've done before

372
00:15:56,970 --> 00:16:06,660
so it's 0 8 16 24 and 32 and it's gonna

373
00:16:04,140 --> 00:16:09,750
start munching on that it's got this

374
00:16:06,660 --> 00:16:11,939
awesome dragon I love it

375
00:16:09,750 --> 00:16:13,710
but we'll go back over here so so the

376
00:16:11,940 --> 00:16:15,810
specific parameters that it takes are

377
00:16:13,710 --> 00:16:17,730
listed there on the top in order the

378
00:16:15,810 --> 00:16:22,050
first parameter is the output location

379
00:16:17,730 --> 00:16:24,870
for the encoded or decoded enigma output

380
00:16:22,050 --> 00:16:26,400
the next is the key 3 letters the

381
00:16:24,870 --> 00:16:28,550
starting positions for the enigma rotors

382
00:16:26,400 --> 00:16:31,890
we've got three rotors in this

383
00:16:28,550 --> 00:16:33,540
simulation the next is the rotors that

384
00:16:31,890 --> 00:16:35,699
are selected so I think there's about

385
00:16:33,540 --> 00:16:37,560
eight rotors that we know about for

386
00:16:35,700 --> 00:16:38,780
enigma so we're gonna use rotors one two

387
00:16:37,560 --> 00:16:42,959
and three in that order

388
00:16:38,780 --> 00:16:44,579
next are the plugboard swaps here we're

389
00:16:42,960 --> 00:16:46,740
just going to simplify and and not put

390
00:16:44,580 --> 00:16:50,070
in any swaps and then there's the input

391
00:16:46,740 --> 00:16:54,470
text so just seven a's we'll see what we

392
00:16:50,070 --> 00:16:57,270
get out in order to set up this state

393
00:16:54,470 --> 00:17:00,780
those things have to be in memory so

394
00:16:57,270 --> 00:17:04,079
that we can pass their memory locations

395
00:17:00,780 --> 00:17:06,300
as the function parameters so in the

396
00:17:04,079 --> 00:17:08,220
middle we've got what the RAM is going

397
00:17:06,300 --> 00:17:11,099
to look like after we do the setup on

398
00:17:08,220 --> 00:17:14,910
the bottom and then those four lines at

399
00:17:11,099 --> 00:17:17,609
the bottom set up those items in memory

400
00:17:14,910 --> 00:17:19,620
so right now unfortunately I don't have

401
00:17:17,609 --> 00:17:23,069
a great interface for setting up the

402
00:17:19,619 --> 00:17:26,489
memory before you go in and execute some

403
00:17:23,069 --> 00:17:28,260
P code as a function but that's just you

404
00:17:26,490 --> 00:17:29,970
can edit the Python code and put those

405
00:17:28,260 --> 00:17:34,920
lines in and that's exactly what I did

406
00:17:29,970 --> 00:17:39,750
to set up memory initially see still

407
00:17:34,920 --> 00:17:41,490
crunching should be almost done running

408
00:17:39,750 --> 00:17:43,980
running about two and a quarter minutes

409
00:17:41,490 --> 00:17:46,150
later you get the output so the output

410
00:17:43,980 --> 00:17:47,890
is the return value from the function

411
00:17:46,150 --> 00:17:50,380
that's normally what you want but here

412
00:17:47,890 --> 00:17:52,360
it's just an error code right so it's

413
00:17:50,380 --> 00:17:55,360
going to return zero it's not going to

414
00:17:52,360 --> 00:17:57,820
have any errors during execution but you

415
00:17:55,360 --> 00:17:59,679
also get as output of this Python script

416
00:17:57,820 --> 00:18:02,290
the state of the registers at the end

417
00:17:59,680 --> 00:18:06,220
and the state of the RAM at the end so

418
00:18:02,290 --> 00:18:09,220
from that at address zero if we copy out

419
00:18:06,220 --> 00:18:12,220
the bytes we can reconstruct the string

420
00:18:09,220 --> 00:18:16,480
from memory and the letters that we get

421
00:18:12,220 --> 00:18:19,059
on the output our ft zmg is Oh awesome

422
00:18:16,480 --> 00:18:22,450
so this is finished over here output

423
00:18:19,059 --> 00:18:24,610
value is 0 we'll scroll up

424
00:18:22,450 --> 00:18:27,400
we've got the registers listed with

425
00:18:24,610 --> 00:18:30,040
their names quite nicely and then we've

426
00:18:27,400 --> 00:18:31,630
got the RAM as just an ugly dump right

427
00:18:30,040 --> 00:18:37,928
here but you can see some of those same

428
00:18:31,630 --> 00:18:40,179
values 46:54 5 a 4d 46:54 or five a 4d

429
00:18:37,929 --> 00:18:42,429
so it's its output the same thing as

430
00:18:40,179 --> 00:18:47,020
before now the test is does the original

431
00:18:42,429 --> 00:18:49,120
C code produce the same output it's on a

432
00:18:47,020 --> 00:18:52,510
slide so it's not much of a drumroll

433
00:18:49,120 --> 00:18:54,520
required it does so the the P code

434
00:18:52,510 --> 00:18:56,410
emulation produced the same result as

435
00:18:54,520 --> 00:18:58,150
the original binary and that's exactly

436
00:18:56,410 --> 00:19:00,670
what we want to see let's talk about

437
00:18:58,150 --> 00:19:04,330
some shortcomings and limitations the

438
00:19:00,670 --> 00:19:06,940
biggest one is that sis calls are part

439
00:19:04,330 --> 00:19:09,100
of the operating system where these

440
00:19:06,940 --> 00:19:11,679
binaries run so when the P code

441
00:19:09,100 --> 00:19:13,149
emulation is chugging along it's adding

442
00:19:11,679 --> 00:19:16,690
it's moving memory around it hits a sis

443
00:19:13,150 --> 00:19:20,170
call it doesn't have that OS code to

444
00:19:16,690 --> 00:19:22,780
execute it to emulate to do that sis

445
00:19:20,170 --> 00:19:26,590
call so right now they aren't handled

446
00:19:22,780 --> 00:19:28,540
hardly at all the anger framework has

447
00:19:26,590 --> 00:19:30,280
implemented some of those syscalls so

448
00:19:28,540 --> 00:19:32,879
I'm hoping to kind of marry those two

449
00:19:30,280 --> 00:19:36,010
together and get some sis call emulation

450
00:19:32,880 --> 00:19:37,780
but right now it's not handled the other

451
00:19:36,010 --> 00:19:39,340
main thing is right now the interface is

452
00:19:37,780 --> 00:19:43,960
really ugly that's something that we can

453
00:19:39,340 --> 00:19:46,570
fix anyway this is a this is a personal

454
00:19:43,960 --> 00:19:50,080
project this is not reflecting anything

455
00:19:46,570 --> 00:19:52,360
on my official work but eventually I

456
00:19:50,080 --> 00:19:54,129
love doing this so all that stuff will

457
00:19:52,360 --> 00:19:57,490
get fixed let's talk about giedrius

458
00:19:54,130 --> 00:19:59,500
scripting with python more broadly why

459
00:19:57,490 --> 00:20:00,070
would you want to do that well the

460
00:19:59,500 --> 00:20:03,880
alternative

461
00:20:00,070 --> 00:20:06,610
is to use Java and and Python pythons

462
00:20:03,880 --> 00:20:08,590
got a ton of great stuff that's built in

463
00:20:06,610 --> 00:20:11,229
to the standard library and there's a

464
00:20:08,590 --> 00:20:13,899
ton of other projects out there on the

465
00:20:11,230 --> 00:20:16,270
internet that you can import and employ

466
00:20:13,900 --> 00:20:17,880
alongside your script so those are some

467
00:20:16,270 --> 00:20:21,310
great reasons to use it

468
00:20:17,880 --> 00:20:23,410
deidre uses JSON which is a java

469
00:20:21,310 --> 00:20:25,270
implementation of Python that hasn't

470
00:20:23,410 --> 00:20:28,150
been updated recently so it's still back

471
00:20:25,270 --> 00:20:31,680
on 271 so that is a limitation if you

472
00:20:28,150 --> 00:20:34,810
try and use other people's Python code

473
00:20:31,680 --> 00:20:36,760
in order to create a script for Diedre

474
00:20:34,810 --> 00:20:39,490
in Python you're just going to create a

475
00:20:36,760 --> 00:20:42,220
normal Python script you can see this is

476
00:20:39,490 --> 00:20:44,350
this is just a totally stock Python

477
00:20:42,220 --> 00:20:48,820
script at the bottom there's even the if

478
00:20:44,350 --> 00:20:52,419
name equals main guard to prevent

479
00:20:48,820 --> 00:20:54,399
importation running this code elsewhere

480
00:20:52,420 --> 00:20:58,900
and that that works exactly the same

481
00:20:54,400 --> 00:21:02,050
when you run this scripting in G draw so

482
00:20:58,900 --> 00:21:04,300
one recommendation I've got if you're

483
00:21:02,050 --> 00:21:07,659
going to try and program next we're

484
00:21:04,300 --> 00:21:09,940
going to talk quickly about the API in

485
00:21:07,660 --> 00:21:11,890
Ghidorah but there's a bunch of javadoc

486
00:21:09,940 --> 00:21:15,160
documentation under help guiter

487
00:21:11,890 --> 00:21:17,440
api help and it looks just like the

488
00:21:15,160 --> 00:21:19,920
javadoc documentation you're used to but

489
00:21:17,440 --> 00:21:24,280
those functions work in Python as well

490
00:21:19,920 --> 00:21:28,060
so deidre has some specific types some

491
00:21:24,280 --> 00:21:30,310
objects address program and language are

492
00:21:28,060 --> 00:21:32,560
some of those and you can get instances

493
00:21:30,310 --> 00:21:35,110
of those by asking the user with these

494
00:21:32,560 --> 00:21:38,710
ask functions it will pop up a box on

495
00:21:35,110 --> 00:21:40,870
screen and the user can enter data also

496
00:21:38,710 --> 00:21:43,960
if you want to introspect about the

497
00:21:40,870 --> 00:21:46,120
current program or the current selection

498
00:21:43,960 --> 00:21:49,120
that the user has made on the screen get

499
00:21:46,120 --> 00:21:51,489
program and get a dress or Global's that

500
00:21:49,120 --> 00:21:54,219
will give you the current binary that's

501
00:21:51,490 --> 00:21:55,990
open and information about it and the

502
00:21:54,220 --> 00:22:00,160
current address selected on the screen

503
00:21:55,990 --> 00:22:02,130
and then for your perusal later if

504
00:22:00,160 --> 00:22:04,360
you're trying to use this some

505
00:22:02,130 --> 00:22:07,060
documentation I haven't seen too clearly

506
00:22:04,360 --> 00:22:08,949
elsewhere if you want to get information

507
00:22:07,060 --> 00:22:10,840
what Deidre knows about the program

508
00:22:08,950 --> 00:22:13,440
counter for this architecture you can

509
00:22:10,840 --> 00:22:16,230
use this get program counter function

510
00:22:13,440 --> 00:22:18,690
the endianness the processor name and

511
00:22:16,230 --> 00:22:20,460
register size and then if you want to

512
00:22:18,690 --> 00:22:22,710
find information that Gager knows about

513
00:22:20,460 --> 00:22:25,020
the stack pointer on this architecture

514
00:22:22,710 --> 00:22:27,090
and with this given compiler the get

515
00:22:25,020 --> 00:22:28,920
stack pointer and and some of these

516
00:22:27,090 --> 00:22:31,740
other functions are really useful then

517
00:22:28,920 --> 00:22:32,970
so you don't have to pre program

518
00:22:31,740 --> 00:22:35,670
information about some of these

519
00:22:32,970 --> 00:22:38,340
architectures deidre knows them for you

520
00:22:35,670 --> 00:22:40,350
and you can learn them at runtime so

521
00:22:38,340 --> 00:22:45,179
we're just going to close with some

522
00:22:40,350 --> 00:22:47,790
links again at KC 0 b FV is my twitter

523
00:22:45,180 --> 00:22:49,590
handle posted a link to this if you want

524
00:22:47,790 --> 00:22:52,560
to get more info about the links but

525
00:22:49,590 --> 00:22:55,709
just to shout to that second walkthrough

526
00:22:52,560 --> 00:22:57,570
I was given it infiltrate 2019 and it

527
00:22:55,710 --> 00:23:02,130
was kind of a great little gauge or walk

528
00:22:57,570 --> 00:23:03,990
through at a medium level and then at

529
00:23:02,130 --> 00:23:06,900
the bottom I've listed where some of the

530
00:23:03,990 --> 00:23:08,730
Deidre documentation is both online and

531
00:23:06,900 --> 00:23:11,370
after you've unzipped key drop where

532
00:23:08,730 --> 00:23:14,550
it's located so I'd be happy to take

533
00:23:11,370 --> 00:23:15,870
questions after this are there in the

534
00:23:14,550 --> 00:23:21,240
end and I can answer real quick right

535
00:23:15,870 --> 00:23:23,550
now shoot so the question was can you

536
00:23:21,240 --> 00:23:27,000
run deidre under java 8 I haven't tried

537
00:23:23,550 --> 00:23:29,250
it's not listed on their website as

538
00:23:27,000 --> 00:23:33,480
supported they say you should use JDK 11

539
00:23:29,250 --> 00:23:35,310
but open JDK works and they actually

540
00:23:33,480 --> 00:23:38,010
recommend it so that's that's really

541
00:23:35,310 --> 00:23:39,389
nice I thought yeah I'm sorry I don't

542
00:23:38,010 --> 00:23:42,840
have a better answer for that any other

543
00:23:39,390 --> 00:23:44,340
questions awesome hey thank you so much

544
00:23:42,840 --> 00:23:47,570
for your time I hope you enjoy the rest

545
00:23:44,340 --> 00:23:47,570
of the con thanks for coming to my talk

546
00:23:47,630 --> 00:23:50,719
[Applause]

