1
00:00:00,060 --> 00:00:07,619
well thank you all for joining us would

2
00:00:03,179 --> 00:00:12,809
like to thank route we're good to talk

3
00:00:07,620 --> 00:00:15,420
about memory and syphilis did you think

4
00:00:12,809 --> 00:00:17,279
it was the name of a tool syphilis no no

5
00:00:15,420 --> 00:00:20,789
we're going to talk about their disease

6
00:00:17,279 --> 00:00:23,609
and it she died out of the disease this

7
00:00:20,789 --> 00:00:25,710
is a disclaimer of presentation the

8
00:00:23,609 --> 00:00:30,570
motivation for those knowing me well

9
00:00:25,710 --> 00:00:35,120
what I did love when I still live as web

10
00:00:30,570 --> 00:00:40,850
security navigators I'm back in 2016 I

11
00:00:35,120 --> 00:00:45,140
read this paper how to attack the CPU

12
00:00:40,850 --> 00:00:48,690
the cache memory and using the Java

13
00:00:45,140 --> 00:00:51,629
environment and I was missing many

14
00:00:48,690 --> 00:00:54,269
things because I thought that to control

15
00:00:51,629 --> 00:00:55,169
what happened and the CPU level was

16
00:00:54,270 --> 00:00:59,340
impossible

17
00:00:55,170 --> 00:01:01,859
here we treat this we try to shed some

18
00:00:59,340 --> 00:01:04,710
lights some things we take for granted

19
00:01:01,859 --> 00:01:09,060
and let's see when we come to it start

20
00:01:04,709 --> 00:01:13,020
now that's done into the core subject

21
00:01:09,060 --> 00:01:16,140
you see this is a processor is intel

22
00:01:13,020 --> 00:01:19,380
core fourth-generation it's an actual

23
00:01:16,140 --> 00:01:22,860
family and basically it shows that my

24
00:01:19,380 --> 00:01:26,250
cache memories casual agencies are

25
00:01:22,860 --> 00:01:30,180
important and it takes a lot of surface

26
00:01:26,250 --> 00:01:33,689
space and you know what is a memory

27
00:01:30,180 --> 00:01:36,329
cache but to say it's in simple mode the

28
00:01:33,689 --> 00:01:38,630
problem is that we have CPUs working at

29
00:01:36,329 --> 00:01:43,470
very high frequencies and that means

30
00:01:38,630 --> 00:01:46,679
that there is a problem CPUs they have

31
00:01:43,470 --> 00:01:50,039
instructions and we forget about memory

32
00:01:46,680 --> 00:01:54,780
instructions and when you have high

33
00:01:50,040 --> 00:01:57,479
speed the CPU should wait 200 cycles

34
00:01:54,780 --> 00:01:59,820
waiting for they order the memory

35
00:01:57,479 --> 00:02:02,299
instruction to do whatsoever and to

36
00:01:59,820 --> 00:02:04,860
solve this they introduced a

37
00:02:02,299 --> 00:02:05,990
hierarchical approach regarding cache

38
00:02:04,860 --> 00:02:09,050
memory

39
00:02:05,990 --> 00:02:12,040
they have smaller memories small cache

40
00:02:09,050 --> 00:02:15,620
memories closer to the CPU and very

41
00:02:12,040 --> 00:02:19,579
faster and more expensive in most of the

42
00:02:15,620 --> 00:02:21,290
CPUs of the high level we have this

43
00:02:19,580 --> 00:02:23,870
hierarchical structure what I am going

44
00:02:21,290 --> 00:02:26,810
to say is based in a case of Intel

45
00:02:23,870 --> 00:02:29,420
environment I could use other processors

46
00:02:26,810 --> 00:02:31,640
then we're going to talk about Intel we

47
00:02:29,420 --> 00:02:34,519
have cache memory I heard you call

48
00:02:31,640 --> 00:02:37,160
approach inside its core we have a first

49
00:02:34,520 --> 00:02:40,130
the second and the third one is shared

50
00:02:37,160 --> 00:02:47,840
among the three cores and that allows us

51
00:02:40,130 --> 00:02:49,819
to the CPU would need to get some

52
00:02:47,840 --> 00:02:52,130
information we get to enhance

53
00:02:49,819 --> 00:02:56,048
performance we don't have to wait that

54
00:02:52,130 --> 00:02:59,840
long so it is hardware that is

55
00:02:56,049 --> 00:03:02,450
controlling the memory and to have the

56
00:02:59,840 --> 00:03:05,450
necessary things inside the cache memory

57
00:03:02,450 --> 00:03:07,100
that as an introduction anyway my

58
00:03:05,450 --> 00:03:09,530
presentation will have three parts

59
00:03:07,100 --> 00:03:12,079
firstly and I'm going to be very fast

60
00:03:09,530 --> 00:03:15,470
we're going to talk about some attacks

61
00:03:12,079 --> 00:03:21,769
to multi-rate what I'm about to say have

62
00:03:15,470 --> 00:03:27,440
you heard about spectra this is the

63
00:03:21,769 --> 00:03:30,140
first part of a presentation second

64
00:03:27,440 --> 00:03:32,900
thing or else we're going to focus on a

65
00:03:30,140 --> 00:03:35,208
common problem we have and to say the

66
00:03:32,900 --> 00:03:38,030
relation with the syphilis we will see

67
00:03:35,209 --> 00:03:40,489
the diseases related to the attacks and

68
00:03:38,030 --> 00:03:43,400
then we're going to talk about how can

69
00:03:40,489 --> 00:03:47,239
we do it with JavaScript I'm going to

70
00:03:43,400 --> 00:03:49,459
skip row harbor to stick to the time

71
00:03:47,239 --> 00:03:53,260
allocated and we're going to talk about

72
00:03:49,459 --> 00:03:55,640
SPECT and this is a very ambitious and

73
00:03:53,260 --> 00:03:59,358
vicious slide but let's see what happens

74
00:03:55,640 --> 00:04:03,018
what you see here is the pipeline of a

75
00:03:59,359 --> 00:04:05,630
modern processor and then basically when

76
00:04:03,019 --> 00:04:08,299
we want to execute whatsoever we need to

77
00:04:05,630 --> 00:04:10,980
fetch the instruction and the CPU should

78
00:04:08,299 --> 00:04:13,200
wait 200 cycles more or less

79
00:04:10,980 --> 00:04:15,630
so what we do is trying to have

80
00:04:13,200 --> 00:04:18,779
instructions there and the cash level

81
00:04:15,630 --> 00:04:22,139
one cache memory every I have to have

82
00:04:18,779 --> 00:04:25,349
instead of 200 we have five cycles of

83
00:04:22,139 --> 00:04:29,730
latency and we do not need to wait so

84
00:04:25,350 --> 00:04:32,700
much we have here certain ports of

85
00:04:29,730 --> 00:04:35,430
execution and it's port with access to

86
00:04:32,700 --> 00:04:38,789
certain execution units one execution

87
00:04:35,430 --> 00:04:42,330
unit is able to compete whatsoever there

88
00:04:38,790 --> 00:04:44,880
are executions for arithmetic operations

89
00:04:42,330 --> 00:04:48,060
floating points of big data whatever

90
00:04:44,880 --> 00:04:50,340
memory access nothing so in each memory

91
00:04:48,060 --> 00:04:52,979
circle we can operate in parallel at

92
00:04:50,340 --> 00:04:54,900
each port who want to maximize they use

93
00:04:52,979 --> 00:04:57,300
the throughput of the CPU the number of

94
00:04:54,900 --> 00:05:01,289
instructions that could be taken by

95
00:04:57,300 --> 00:05:04,200
cycle we need to give or take all the

96
00:05:01,290 --> 00:05:06,990
ports if you execute this one by one

97
00:05:04,200 --> 00:05:10,650
that couldn't be possible mostly because

98
00:05:06,990 --> 00:05:13,250
in general in one instruction we can

99
00:05:10,650 --> 00:05:18,060
occupy more than one port both

100
00:05:13,250 --> 00:05:20,070
instructions instructions in general

101
00:05:18,060 --> 00:05:22,440
they go through this they are decoding

102
00:05:20,070 --> 00:05:24,419
some micro instructions and this is what

103
00:05:22,440 --> 00:05:27,810
will execute a micro instruction

104
00:05:24,419 --> 00:05:30,479
instruction of a senator up up to

105
00:05:27,810 --> 00:05:33,930
instruction one is memory load another

106
00:05:30,479 --> 00:05:36,330
one is updating their start thing so

107
00:05:33,930 --> 00:05:38,669
what we are interested in is to maximize

108
00:05:36,330 --> 00:05:41,580
the number of things number of parallel

109
00:05:38,669 --> 00:05:43,950
ports we use and to optimize this they

110
00:05:41,580 --> 00:05:46,260
said same thing civil instruction by

111
00:05:43,950 --> 00:05:48,750
instruction we can instruct who can

112
00:05:46,260 --> 00:05:51,810
execute them in whatever order randomly

113
00:05:48,750 --> 00:05:53,940
we decode we fetch as many instructions

114
00:05:51,810 --> 00:05:56,460
as possible a bunch of instructions and

115
00:05:53,940 --> 00:05:59,460
we have a buffer here and we have the

116
00:05:56,460 --> 00:06:01,650
reorder buffer 224 entries as you see

117
00:05:59,460 --> 00:06:03,419
here turning 24 and the hardware is

118
00:06:01,650 --> 00:06:05,909
going to try to look the four

119
00:06:03,419 --> 00:06:08,430
instructions if they can be randomly

120
00:06:05,910 --> 00:06:10,710
executed whatever order the only

121
00:06:08,430 --> 00:06:12,870
instruction is that resource are

122
00:06:10,710 --> 00:06:13,438
committed results will be validated

123
00:06:12,870 --> 00:06:16,099
coming

124
00:06:13,439 --> 00:06:19,379
modified an architectural structure of

125
00:06:16,099 --> 00:06:22,259
an order of the execution of a program

126
00:06:19,379 --> 00:06:25,709
when we run the program so hardware will

127
00:06:22,259 --> 00:06:27,419
check this every structure has an upper

128
00:06:25,709 --> 00:06:29,339
and that depends and the previous

129
00:06:27,419 --> 00:06:32,068
instruction we cannot execute the

130
00:06:29,339 --> 00:06:34,309
instruction because we have to wait for

131
00:06:32,069 --> 00:06:38,369
the previous instruction to be executed

132
00:06:34,309 --> 00:06:41,339
but if two instructions are not related

133
00:06:38,369 --> 00:06:45,659
it's irrelevant who can do it out of a

134
00:06:41,339 --> 00:06:48,059
program order and then in the reorder

135
00:06:45,659 --> 00:06:50,938
buffer they wait till they are retrieved

136
00:06:48,059 --> 00:06:56,669
in order then we maximize the throughput

137
00:06:50,939 --> 00:06:59,189
of a system the state in which one

138
00:06:56,669 --> 00:07:04,079
execution and one instructions been

139
00:06:59,189 --> 00:07:06,809
executed but haven't been retrieved so

140
00:07:04,079 --> 00:07:09,509
the state is not manufactured manifested

141
00:07:06,809 --> 00:07:12,289
to the architectural world to the

142
00:07:09,509 --> 00:07:16,169
registries of a system it's a transient

143
00:07:12,289 --> 00:07:18,479
execution transient mode transient but

144
00:07:16,169 --> 00:07:22,318
our problems are not only instructions

145
00:07:18,479 --> 00:07:27,839
we have the branches branches is with

146
00:07:22,319 --> 00:07:31,469
which we implement loops whatever and we

147
00:07:27,839 --> 00:07:33,530
have comparison where one of the

148
00:07:31,469 --> 00:07:35,630
elements

149
00:07:33,530 --> 00:07:39,710
the memory axis if you want to know

150
00:07:35,630 --> 00:07:41,210
which to be executed every way 200

151
00:07:39,710 --> 00:07:43,849
cycles and we get the memory information

152
00:07:41,210 --> 00:07:46,580
then we solve for comparison that is

153
00:07:43,850 --> 00:07:49,220
once again another bottleneck because

154
00:07:46,580 --> 00:07:52,039
we're having a CPU that's extremely poor

155
00:07:49,220 --> 00:07:54,730
hunter and it's their latent they said

156
00:07:52,040 --> 00:08:00,110
let's predict it's try to predict

157
00:07:54,730 --> 00:08:02,660
Wow branch how this is going to take

158
00:08:00,110 --> 00:08:05,300
place and where the branch predictors

159
00:08:02,660 --> 00:08:09,290
the branch predictors when you have a

160
00:08:05,300 --> 00:08:13,010
branch branching the CPU will and you

161
00:08:09,290 --> 00:08:16,130
have a branch prediction unit then they

162
00:08:13,010 --> 00:08:21,260
will ask the prediction unit to see ever

163
00:08:16,130 --> 00:08:24,080
going to be first jump or not asleep or

164
00:08:21,260 --> 00:08:27,289
not and we take we speculate we take

165
00:08:24,080 --> 00:08:30,289
instructions in sort of an order now the

166
00:08:27,290 --> 00:08:33,560
X the instructions are executed and they

167
00:08:30,290 --> 00:08:35,300
are waiting at the reordering buffer and

168
00:08:33,559 --> 00:08:37,909
then two things might happen the

169
00:08:35,299 --> 00:08:39,770
predictor might be right in that case we

170
00:08:37,909 --> 00:08:41,809
retrieve the instructions from the

171
00:08:39,770 --> 00:08:45,020
buffer and we've enhanced the throughput

172
00:08:41,809 --> 00:08:46,819
or it could be wrong if it's wrong what

173
00:08:45,020 --> 00:08:48,770
we lose we discard instructions that

174
00:08:46,820 --> 00:08:51,230
were executed but they are useless

175
00:08:48,770 --> 00:08:54,260
because the prediction was not correct

176
00:08:51,230 --> 00:08:56,510
and we go back to where we should go

177
00:08:54,260 --> 00:08:59,930
there is a small penalty so to speak

178
00:08:56,510 --> 00:09:04,310
part in the end the branch predictor has

179
00:08:59,930 --> 00:09:06,920
rate of success that's high and as we

180
00:09:04,310 --> 00:09:13,719
program a branch predictors are easy to

181
00:09:06,920 --> 00:09:17,360
implement you always always consider the

182
00:09:13,720 --> 00:09:20,120
it's a branch predictor saying you take

183
00:09:17,360 --> 00:09:23,150
this jump it's better than not having

184
00:09:20,120 --> 00:09:26,390
any branch predictor that's more or less

185
00:09:23,150 --> 00:09:29,620
an idea on speculative prediction what

186
00:09:26,390 --> 00:09:32,030
happened with the spectra and all the

187
00:09:29,620 --> 00:09:34,940
things they were talking about end of

188
00:09:32,030 --> 00:09:35,770
the world during the executions that

189
00:09:34,940 --> 00:09:38,530
Richards

190
00:09:35,770 --> 00:09:41,380
you should if it was not correct even

191
00:09:38,530 --> 00:09:44,620
though would Mike discard instructions

192
00:09:41,380 --> 00:09:46,870
executed the thing is that there might

193
00:09:44,620 --> 00:09:49,180
be traces in the microarchitecture

194
00:09:46,870 --> 00:09:51,640
what about rises in the micro

195
00:09:49,180 --> 00:09:53,800
architecture normally their simplest

196
00:09:51,640 --> 00:09:55,960
example is that the stability of an

197
00:09:53,800 --> 00:09:59,199
execution even if not correct might

198
00:09:55,960 --> 00:10:02,620
modify the status of the cache memory

199
00:09:59,200 --> 00:10:04,900
and the attacker might see the cache

200
00:10:02,620 --> 00:10:07,120
memory and know things learn about

201
00:10:04,900 --> 00:10:09,850
things so let's take a look about the

202
00:10:07,120 --> 00:10:12,850
variant one of the spectra the simpler a

203
00:10:09,850 --> 00:10:17,500
variant of a spectra but we have here a

204
00:10:12,850 --> 00:10:20,620
function this is symbol and assembler

205
00:10:17,500 --> 00:10:25,180
and we have the offset would compare

206
00:10:20,620 --> 00:10:28,810
with this array size and if it is within

207
00:10:25,180 --> 00:10:31,239
the range we Excel have access to this

208
00:10:28,810 --> 00:10:35,500
position the value is used as an index

209
00:10:31,240 --> 00:10:40,780
for the second array this 64 it's just

210
00:10:35,500 --> 00:10:43,180
because the convenient thing what the

211
00:10:40,780 --> 00:10:46,890
attacker will do it will invoke the

212
00:10:43,180 --> 00:10:49,540
victim function and what happens the

213
00:10:46,890 --> 00:10:53,920
branch predictor and then will be

214
00:10:49,540 --> 00:10:56,770
trained to say this is not to be taken

215
00:10:53,920 --> 00:11:02,860
if you look at the assembler if we take

216
00:10:56,770 --> 00:11:05,079
this jump we say it is out of range so

217
00:11:02,860 --> 00:11:09,250
we're not going to take this branch and

218
00:11:05,080 --> 00:11:11,230
we train the branch predictor and what

219
00:11:09,250 --> 00:11:14,170
happens is that the attacker will get

220
00:11:11,230 --> 00:11:15,910
make sure that the array contents are

221
00:11:14,170 --> 00:11:18,280
outside the cache memory with

222
00:11:15,910 --> 00:11:21,550
instructions special instructions and

223
00:11:18,280 --> 00:11:23,829
what happens is to invoke the victim

224
00:11:21,550 --> 00:11:26,530
function with enough set that is out of

225
00:11:23,830 --> 00:11:29,320
range what will happen now when we're

226
00:11:26,530 --> 00:11:30,850
executing this well we're going to

227
00:11:29,320 --> 00:11:33,700
compare we're going to establish a

228
00:11:30,850 --> 00:11:34,660
comparison and here what happens is that

229
00:11:33,700 --> 00:11:37,389
the

230
00:11:34,660 --> 00:11:39,459
one size that might be inside the cache

231
00:11:37,389 --> 00:11:41,740
memory or not the comparison will take

232
00:11:39,459 --> 00:11:44,050
place soon and then this calculation

233
00:11:41,740 --> 00:11:46,480
window will be very narrow nothing will

234
00:11:44,050 --> 00:11:49,769
happen but the attacker made sure that

235
00:11:46,480 --> 00:11:53,800
the array one is out of the cache memory

236
00:11:49,769 --> 00:11:57,160
when the CPU gets there it will take 200

237
00:11:53,800 --> 00:11:59,410
cycles to solve if the branch is going

238
00:11:57,160 --> 00:12:01,959
to be taken or not during that time we

239
00:11:59,410 --> 00:12:05,110
have to execute the whole code while

240
00:12:01,959 --> 00:12:07,508
speculatively and when we're based on

241
00:12:05,110 --> 00:12:10,899
that we'll have access to the array wall

242
00:12:07,509 --> 00:12:13,959
with a nut set that is out of range and

243
00:12:10,899 --> 00:12:16,509
we will have a value to which we

244
00:12:13,959 --> 00:12:18,670
shouldn't have access we access to the

245
00:12:16,509 --> 00:12:20,709
array tooth and then with us access to

246
00:12:18,670 --> 00:12:22,689
their rate so even though it's good to

247
00:12:20,709 --> 00:12:25,560
be discarded it's going to be too late

248
00:12:22,689 --> 00:12:28,540
because this axis has provoked that

249
00:12:25,560 --> 00:12:31,180
memory block was introduced into the

250
00:12:28,540 --> 00:12:33,399
cache memory so the prediction was not

251
00:12:31,180 --> 00:12:35,829
correct we discard an instruction but

252
00:12:33,399 --> 00:12:38,800
the cache memory was modified and the

253
00:12:35,829 --> 00:12:43,359
attacker is going to measure the access

254
00:12:38,800 --> 00:12:48,040
time to array to offset zero offset 64

255
00:12:43,360 --> 00:12:51,790
offset 128 well he detects the time is

256
00:12:48,040 --> 00:12:55,930
short it is inside device by 64 and see

257
00:12:51,790 --> 00:12:58,689
the out of rage value of this array 1 it

258
00:12:55,930 --> 00:13:01,660
looks like artificial but there are

259
00:12:58,689 --> 00:13:06,160
gadgets were the patterns in whatever

260
00:13:01,660 --> 00:13:08,139
code and the attacker could if the

261
00:13:06,160 --> 00:13:10,930
attacker identifies the function this

262
00:13:08,139 --> 00:13:14,259
way the attacker can read all the

263
00:13:10,930 --> 00:13:15,819
virtual memory space and in JavaScript

264
00:13:14,259 --> 00:13:17,920
where the attacker could have a

265
00:13:15,819 --> 00:13:19,930
JavaScript that will trigger those

266
00:13:17,920 --> 00:13:24,279
patterns will be a big problem

267
00:13:19,930 --> 00:13:27,219
in JavaScript so that is spectra and you

268
00:13:24,279 --> 00:13:30,069
have seen the cache memory plays an

269
00:13:27,220 --> 00:13:30,970
important role and here we're going to

270
00:13:30,069 --> 00:13:33,389
see

271
00:13:30,970 --> 00:13:36,129
detail the way of caches been organized

272
00:13:33,389 --> 00:13:39,850
regard the cache memory the cache

273
00:13:36,129 --> 00:13:42,220
belongs in different blocks instead of

274
00:13:39,850 --> 00:13:44,889
having a bytes memory we have blocks

275
00:13:42,220 --> 00:13:47,769
each block system four bytes and this

276
00:13:44,889 --> 00:13:50,500
example since it's like 16 bytes the

277
00:13:47,769 --> 00:13:53,649
cache memory is divided in cash and sets

278
00:13:50,500 --> 00:13:56,319
you can see here for passion' sets and

279
00:13:53,649 --> 00:13:59,189
each cache saved will have the capacity

280
00:13:56,319 --> 00:14:03,300
of storing the number of blocks

281
00:13:59,189 --> 00:14:07,089
Association where for - sets worth

282
00:14:03,300 --> 00:14:09,670
Association - if we have 4 - sets that

283
00:14:07,089 --> 00:14:13,779
means you need two bits to direct to

284
00:14:09,670 --> 00:14:17,019
identify - no because memory blocks

285
00:14:13,779 --> 00:14:20,649
well belong to one guy said so you need

286
00:14:17,019 --> 00:14:22,959
two bits from the memory address to know

287
00:14:20,649 --> 00:14:27,129
where to know where the block should go

288
00:14:22,959 --> 00:14:31,000
into which - a set in some cases will

289
00:14:27,129 --> 00:14:32,980
have virtual address in some other cases

290
00:14:31,000 --> 00:14:35,800
physical address and we're going to be

291
00:14:32,980 --> 00:14:39,250
based on them the physical address was

292
00:14:35,800 --> 00:14:42,008
used to mark a memory block until I got

293
00:14:39,250 --> 00:14:44,319
she said what happened subtly the Arthur

294
00:14:42,009 --> 00:14:47,139
made more blocks in the memory then you

295
00:14:44,319 --> 00:14:49,839
have another cache set or in the cache

296
00:14:47,139 --> 00:14:52,959
many blocks will compete to be stored

297
00:14:49,839 --> 00:14:58,899
there here we have block 0 block 4 block

298
00:14:52,959 --> 00:15:00,790
8 and mapping - 0 and at the moment when

299
00:14:58,899 --> 00:15:03,250
we have two of those and we have to try

300
00:15:00,790 --> 00:15:05,439
to access to a third cache memory should

301
00:15:03,250 --> 00:15:08,290
have to decide which is going to be

302
00:15:05,439 --> 00:15:11,259
written on or replaced we have the

303
00:15:08,290 --> 00:15:14,500
replacement policy replacement policy is

304
00:15:11,259 --> 00:15:20,829
trying to exploit its going to use rules

305
00:15:14,500 --> 00:15:24,309
at our LRU its least recently you must

306
00:15:20,829 --> 00:15:27,910
the least recently used

307
00:15:24,309 --> 00:15:28,980
least recently used loss blockers that

308
00:15:27,910 --> 00:15:35,610
means

309
00:15:28,980 --> 00:15:37,950
that ah have been used recently in the

310
00:15:35,610 --> 00:15:40,910
least way so have to maximize the

311
00:15:37,950 --> 00:15:43,410
efficiency another way to look at real

312
00:15:40,910 --> 00:15:48,300
examples we have this cache memory six

313
00:15:43,410 --> 00:15:51,480
megabytes and how many two-way cache how

314
00:15:48,300 --> 00:15:55,109
many we have we have six megabytes and

315
00:15:51,480 --> 00:15:57,899
then the capacity per cache set is 64

316
00:15:55,110 --> 00:16:00,149
bytes multiplied by 12 blocks per cache

317
00:15:57,899 --> 00:16:02,250
set that means we will have eight

318
00:16:00,149 --> 00:16:05,100
thousand one hundred ninety-eight cache

319
00:16:02,250 --> 00:16:08,370
says that means we're going to use 13

320
00:16:05,100 --> 00:16:13,459
beats from the physical address to map a

321
00:16:08,370 --> 00:16:17,579
memory block on to one of those elements

322
00:16:13,459 --> 00:16:19,410
firstly the six are they those are the

323
00:16:17,579 --> 00:16:22,649
offset within the block were going to

324
00:16:19,410 --> 00:16:26,189
discard because they are those having a

325
00:16:22,649 --> 00:16:32,070
lower specific weight and then we decide

326
00:16:26,190 --> 00:16:34,140
about index of set in the modern cache

327
00:16:32,070 --> 00:16:37,290
the last level there is an additional

328
00:16:34,140 --> 00:16:42,360
partition that is slicing this for

329
00:16:37,290 --> 00:16:46,319
having one cache of 8,192 cache sets is

330
00:16:42,360 --> 00:16:49,050
best to have four or eight slices to

331
00:16:46,320 --> 00:16:53,329
partition this to splice to have

332
00:16:49,050 --> 00:16:55,750
parallel axis and to enhance the

333
00:16:53,329 --> 00:16:58,779
broadband

334
00:16:55,750 --> 00:17:02,519
we have instead of one of eight thousand

335
00:16:58,779 --> 00:17:02,519
one hundred eighty two twelve

336
00:17:02,910 --> 00:17:09,158
8,192 each so it's easier and we need

337
00:17:07,089 --> 00:17:12,579
less information to have an indication

338
00:17:09,159 --> 00:17:15,610
we have six bits as an offset ten for

339
00:17:12,579 --> 00:17:17,799
the set index I know to which slice this

340
00:17:15,609 --> 00:17:20,408
will go is to be decided by hash

341
00:17:17,799 --> 00:17:23,859
function that will use all the bits of

342
00:17:20,409 --> 00:17:25,689
memory and basically there are some

343
00:17:23,859 --> 00:17:28,208
people having reversed engineering

344
00:17:25,689 --> 00:17:30,100
processes when to go to the send cash

345
00:17:28,209 --> 00:17:35,380
said you have to have the same slice and

346
00:17:30,100 --> 00:17:38,439
the same bit and with this of this we

347
00:17:35,380 --> 00:17:41,500
know already the way the cache memory is

348
00:17:38,440 --> 00:17:44,409
organized an example of the attacker is

349
00:17:41,500 --> 00:17:46,960
a prime and probe and the firm a

350
00:17:44,409 --> 00:17:49,140
variance but the idea is the same in

351
00:17:46,960 --> 00:17:52,750
this case what we're going to have is

352
00:17:49,140 --> 00:17:55,720
the attacker the attacker that will

353
00:17:52,750 --> 00:17:59,230
start with a priming it is put in the

354
00:17:55,720 --> 00:18:01,799
cache at a known state how can you use

355
00:17:59,230 --> 00:18:04,750
the priming the attacker has to identify

356
00:18:01,799 --> 00:18:07,840
memory blocks that goes into the

357
00:18:04,750 --> 00:18:10,539
different cache sets let's imagine you

358
00:18:07,840 --> 00:18:12,039
have a cache set with two sites you can

359
00:18:10,539 --> 00:18:14,230
more than two but the attacker is

360
00:18:12,039 --> 00:18:17,350
interested in those two and the

361
00:18:14,230 --> 00:18:20,530
association is for one so we have four

362
00:18:17,350 --> 00:18:23,590
addresses going to the first set and for

363
00:18:20,530 --> 00:18:27,450
going into the second set once he

364
00:18:23,590 --> 00:18:30,549
finishes this the cash will content only

365
00:18:27,450 --> 00:18:33,700
blocks introduced by the attacker then

366
00:18:30,549 --> 00:18:36,730
the victim the victim if the victim is

367
00:18:33,700 --> 00:18:40,090
executed as sensitive code of the sort

368
00:18:36,730 --> 00:18:43,990
where the pattern of access to memory

369
00:18:40,090 --> 00:18:45,899
will depend on some secret in this case

370
00:18:43,990 --> 00:18:49,470
ever key

371
00:18:45,900 --> 00:18:51,960
but I as one it's an access to the

372
00:18:49,470 --> 00:18:53,909
memory access means we have a memory

373
00:18:51,960 --> 00:18:56,520
block that's going to introduced into

374
00:18:53,909 --> 00:18:58,529
the cache memory after the execution the

375
00:18:56,520 --> 00:19:01,049
attacker will prove we're gonna try to

376
00:18:58,529 --> 00:19:03,809
see the changes that are taking place

377
00:19:01,049 --> 00:19:06,450
here attack that will measure time I

378
00:19:03,809 --> 00:19:08,190
have an access to the same blocks if

379
00:19:06,450 --> 00:19:10,169
there's a short time the block still

380
00:19:08,190 --> 00:19:12,710
there if it takes a long time you have

381
00:19:10,169 --> 00:19:17,309
to go to the memory the execution of the

382
00:19:12,710 --> 00:19:20,270
victim system system has replaced well

383
00:19:17,309 --> 00:19:23,158
the blocks and you get a trace it is

384
00:19:20,270 --> 00:19:26,158
detailed you don't know a specific

385
00:19:23,159 --> 00:19:28,950
access to the memory but if you have

386
00:19:26,159 --> 00:19:31,950
enough cash assets you will know which

387
00:19:28,950 --> 00:19:34,080
is a relative access that has been

388
00:19:31,950 --> 00:19:36,960
conducted and you have to differentiate

389
00:19:34,080 --> 00:19:40,939
among two types of execution even though

390
00:19:36,960 --> 00:19:48,179
that looks crazy and the truth is that

391
00:19:40,940 --> 00:19:50,520
it is used to breach to breach even

392
00:19:48,179 --> 00:19:54,080
elliptic curves and it's been

393
00:19:50,520 --> 00:19:58,529
implemented to see the number of bosses

394
00:19:54,080 --> 00:20:00,658
the number of requests been used for

395
00:19:58,529 --> 00:20:02,730
couple channels it was very interesting

396
00:20:00,659 --> 00:20:04,320
conference two years ago for the covered

397
00:20:02,730 --> 00:20:07,470
channel instead of one victim you have

398
00:20:04,320 --> 00:20:09,809
two attackers that are cooperating one

399
00:20:07,470 --> 00:20:13,549
with another and the cache memory is

400
00:20:09,809 --> 00:20:16,760
used to communicate and send information

401
00:20:13,549 --> 00:20:19,200
there was a conference where there was a

402
00:20:16,760 --> 00:20:20,970
protocol correcting code and so on

403
00:20:19,200 --> 00:20:23,159
because there is a background now is

404
00:20:20,970 --> 00:20:25,590
there there were a protocol is a very

405
00:20:23,159 --> 00:20:27,990
effective protocol allowing two machines

406
00:20:25,590 --> 00:20:30,230
virtual machines sharing the same hard

407
00:20:27,990 --> 00:20:34,230
world to communicate among themselves

408
00:20:30,230 --> 00:20:38,309
throughout SCH it was a transport layer

409
00:20:34,230 --> 00:20:41,519
on cache memory another SCH and

410
00:20:38,309 --> 00:20:43,109
they had streaming on sch you see the

411
00:20:41,519 --> 00:20:46,799
capacity of information that can be

412
00:20:43,109 --> 00:20:49,139
coded and the practical environment so

413
00:20:46,799 --> 00:20:53,279
that's it there's a first part of it and

414
00:20:49,139 --> 00:20:56,340
I know you don't understand but we want

415
00:20:53,279 --> 00:20:58,499
to motivate you telling you the type of

416
00:20:56,340 --> 00:20:59,218
attack that might take place that's

417
00:20:58,499 --> 00:21:01,679
enough

418
00:20:59,219 --> 00:21:04,429
it is quite clear that if we have access

419
00:21:01,679 --> 00:21:06,960
to the virtual address and you have

420
00:21:04,429 --> 00:21:08,759
special instructions where you have to

421
00:21:06,960 --> 00:21:10,649
learn whatever you want from the cache

422
00:21:08,759 --> 00:21:12,899
memory our life is easy

423
00:21:10,649 --> 00:21:16,609
you also have a special talks to measure

424
00:21:12,899 --> 00:21:19,439
time accurately so you have to determine

425
00:21:16,609 --> 00:21:22,728
access to the cache memory in other

426
00:21:19,440 --> 00:21:26,809
environments it doesn't happen in a

427
00:21:22,729 --> 00:21:30,119
script we didn't have the idea of

428
00:21:26,809 --> 00:21:32,219
pointers of virtual address and you

429
00:21:30,119 --> 00:21:35,399
don't have information to find the

430
00:21:32,219 --> 00:21:38,359
blocks going into each cache set how can

431
00:21:35,399 --> 00:21:40,619
we use raw hammer the row hammer is

432
00:21:38,359 --> 00:21:44,879
retrieving content from the cache memory

433
00:21:40,619 --> 00:21:47,849
how can we arrange length and how can we

434
00:21:44,879 --> 00:21:50,488
destroy this to open the window and to

435
00:21:47,849 --> 00:21:54,029
use spectra how can we put to the cache

436
00:21:50,489 --> 00:21:55,200
memory into a controlled state of

437
00:21:54,029 --> 00:21:58,529
pervert

438
00:21:55,200 --> 00:22:00,929
the solution is eviction sense eviction

439
00:21:58,529 --> 00:22:03,749
sets we're going to talk about eviction

440
00:22:00,929 --> 00:22:07,649
sets a couple of definitions and one

441
00:22:03,749 --> 00:22:11,190
formula that we're not going to explain

442
00:22:07,649 --> 00:22:15,238
two addresses are I will see here

443
00:22:11,190 --> 00:22:19,710
congruent if they map into the same

444
00:22:15,239 --> 00:22:23,519
slice set and the same cache set the

445
00:22:19,710 --> 00:22:26,519
slice if this is a physical address we

446
00:22:23,519 --> 00:22:29,539
have two numbers and the set it is part

447
00:22:26,519 --> 00:22:32,609
of the bits we said to discard they

448
00:22:29,539 --> 00:22:36,479
sequence bits

449
00:22:32,609 --> 00:22:41,129
that lighter and you determined as we

450
00:22:36,479 --> 00:22:44,239
see here the rest one eviction set is

451
00:22:41,129 --> 00:22:50,359
just a set of addresses containing

452
00:22:44,239 --> 00:22:53,279
associations of completely consistent

453
00:22:50,359 --> 00:22:56,549
addresses consistent it's written into

454
00:22:53,279 --> 00:23:00,450
that system languages so you make sure

455
00:22:56,549 --> 00:23:03,749
that B is not part of the cache set it

456
00:23:00,450 --> 00:23:07,919
has been evicted kicked out that's why

457
00:23:03,749 --> 00:23:12,239
it's called eviction set and we have put

458
00:23:07,919 --> 00:23:15,599
this who have used inverted commas you

459
00:23:12,239 --> 00:23:18,509
make sure that the V is not inside the

460
00:23:15,599 --> 00:23:21,239
cache set even though we haven't got any

461
00:23:18,509 --> 00:23:24,769
information on the physical address and

462
00:23:21,239 --> 00:23:29,009
we do not know if to our assistant two

463
00:23:24,769 --> 00:23:31,169
addresses are consistent we have the

464
00:23:29,009 --> 00:23:34,139
experiment which is a following if we

465
00:23:31,169 --> 00:23:37,709
have the victim address what we do is we

466
00:23:34,139 --> 00:23:40,529
have access to this victim address we

467
00:23:37,709 --> 00:23:43,619
take the eviction set by candidate to

468
00:23:40,529 --> 00:23:46,589
set and we have access to all addresses

469
00:23:43,619 --> 00:23:50,939
and we measure the time we take to

470
00:23:46,589 --> 00:23:55,019
access the victim address so it's still

471
00:23:50,940 --> 00:23:56,820
there so our candidate said it's not an

472
00:23:55,019 --> 00:23:59,309
eviction set if it takes a long time

473
00:23:56,820 --> 00:24:02,609
that means we have kicked out to the

474
00:23:59,309 --> 00:24:07,440
victim we have then as we see here and

475
00:24:02,609 --> 00:24:11,449
can you follow me we have then then with

476
00:24:07,440 --> 00:24:11,450
this idea it is obvious that

477
00:24:11,760 --> 00:24:20,240
any sufficiently large said is an

478
00:24:15,900 --> 00:24:28,320
eviction set if you have an 8 Omega cash

479
00:24:20,240 --> 00:24:30,060
well you have random addresses but there

480
00:24:28,320 --> 00:24:33,080
is no control you will need a small

481
00:24:30,060 --> 00:24:36,570
eviction set that means containing

482
00:24:33,080 --> 00:24:38,520
directing associations with the

483
00:24:36,570 --> 00:24:41,639
addresses how can we find one minimum

484
00:24:38,520 --> 00:24:46,740
size of eviction sets how can we do it

485
00:24:41,640 --> 00:24:48,210
how can we get this will depend on the

486
00:24:46,740 --> 00:24:50,820
amount of information we had under

487
00:24:48,210 --> 00:24:54,240
physical address and we're going to see

488
00:24:50,820 --> 00:24:58,169
it with an example the formula is simply

489
00:24:54,240 --> 00:25:03,780
for trying to give an idea let's imagine

490
00:24:58,170 --> 00:25:10,860
something so we have an attacker with 8

491
00:25:03,780 --> 00:25:14,340
slices cage a 1892 cassettes and this

492
00:25:10,860 --> 00:25:16,500
means and associativity of 12 so we have

493
00:25:14,340 --> 00:25:19,290
a 40 beasts are paid better pages so

494
00:25:16,500 --> 00:25:23,940
this system uses four keep a kick

495
00:25:19,290 --> 00:25:26,070
TV key beep I'm sorry our system so for

496
00:25:23,940 --> 00:25:27,150
K pages is interesting for us because

497
00:25:26,070 --> 00:25:29,520
when you

498
00:25:27,150 --> 00:25:33,900
translates from virtual address to

499
00:25:29,520 --> 00:25:39,629
physical the payoff set will be

500
00:25:33,900 --> 00:25:43,320
identical of the twelve bits that are

501
00:25:39,630 --> 00:25:45,360
heavier so most of them are going to be

502
00:25:43,320 --> 00:25:48,179
random at all so one attacker that can

503
00:25:45,360 --> 00:25:52,520
control be twelve of the virtual address

504
00:25:48,180 --> 00:25:56,100
will have control on the C bit of

505
00:25:52,520 --> 00:25:58,800
sitting and the block offset will not be

506
00:25:56,100 --> 00:26:03,209
interesting for us so to find congruent

507
00:25:58,800 --> 00:26:05,399
addresses we will need this four bytes

508
00:26:03,210 --> 00:26:07,680
of fit bits our physical and across the

509
00:26:05,400 --> 00:26:11,130
three of the virtual one so if one

510
00:26:07,680 --> 00:26:14,010
attacker tech takes a to random address

511
00:26:11,130 --> 00:26:16,740
with the time offset the probability of

512
00:26:14,010 --> 00:26:17,900
having congruence will be two minus

513
00:26:16,740 --> 00:26:20,120
seven

514
00:26:17,900 --> 00:26:22,309
in this case how if we use this

515
00:26:20,120 --> 00:26:25,669
probability to have an estimate of how

516
00:26:22,309 --> 00:26:29,570
many addresses we need to get randomly

517
00:26:25,670 --> 00:26:32,420
to find one wish eviction set meaning 12

518
00:26:29,570 --> 00:26:35,750
congruent ones we will get to this chart

519
00:26:32,420 --> 00:26:38,450
which means that if we get one thousand

520
00:26:35,750 --> 00:26:40,640
addresses with the same payoff set

521
00:26:38,450 --> 00:26:46,520
without any kind of information about

522
00:26:40,640 --> 00:26:50,890
heavier bits this one thousand addresses

523
00:26:46,520 --> 00:26:53,660
the probability of them being for the

524
00:26:50,890 --> 00:26:55,850
offset we will the probability will be

525
00:26:53,660 --> 00:26:58,990
low if we do the other way or the other

526
00:26:55,850 --> 00:27:02,030
way the probability will be higher

527
00:26:58,990 --> 00:27:05,000
having said this it is more difficult to

528
00:27:02,030 --> 00:27:06,860
find smaller the eviction set and bigger

529
00:27:05,000 --> 00:27:09,350
eviction sets but we didn't see anything

530
00:27:06,860 --> 00:27:11,540
about how we can find the smaller ones

531
00:27:09,350 --> 00:27:16,129
the first idea could be therefore well

532
00:27:11,540 --> 00:27:19,610
we simply get directly after

533
00:27:16,130 --> 00:27:22,670
associativity twelve until we find a

534
00:27:19,610 --> 00:27:25,699
minimum size eviction set but the

535
00:27:22,670 --> 00:27:27,710
probability is two minus seven to minus

536
00:27:25,700 --> 00:27:30,880
12 so it is never gonna happen or if

537
00:27:27,710 --> 00:27:33,650
you're lucky enough you will probably

538
00:27:30,880 --> 00:27:36,559
come across it very rarely so what the

539
00:27:33,650 --> 00:27:40,100
problem is is that we you can find it so

540
00:27:36,559 --> 00:27:42,080
people uses an algorithm as follows so

541
00:27:40,100 --> 00:27:45,500
we cannot find congruent address but we

542
00:27:42,080 --> 00:27:49,280
have our T so what we do is we get a big

543
00:27:45,500 --> 00:27:52,550
eviction set and then we use this test

544
00:27:49,280 --> 00:27:54,530
in order to reduce it so the algorithm

545
00:27:52,550 --> 00:27:57,110
is very simple so you start by an

546
00:27:54,530 --> 00:27:59,649
eviction set you get an address and then

547
00:27:57,110 --> 00:28:02,120
you test and you see whether or not this

548
00:27:59,650 --> 00:28:05,000
remains as an eviction so if it is not

549
00:28:02,120 --> 00:28:08,149
you discard and you get one more so you

550
00:28:05,000 --> 00:28:10,790
get addresses you reduce the size until

551
00:28:08,150 --> 00:28:13,670
you don't have an eviction set so you

552
00:28:10,790 --> 00:28:16,639
learn is that the address you got is

553
00:28:13,670 --> 00:28:18,800
part of the minimum of action set so you

554
00:28:16,640 --> 00:28:21,920
use it and you repeat it so you repeat

555
00:28:18,800 --> 00:28:24,180
the process until you find acitivity of

556
00:28:21,920 --> 00:28:29,130
address and you have a

557
00:28:24,180 --> 00:28:35,070
sighs the vixen said but if you look at

558
00:28:29,130 --> 00:28:41,700
the cost of this algorithm you see bad

559
00:28:35,070 --> 00:28:44,460
because it's very difficult to 4k pages

560
00:28:41,700 --> 00:28:48,810
with 3000 you will get an eviction set

561
00:28:44,460 --> 00:28:50,550
so through 3000 quadrupled can be

562
00:28:48,810 --> 00:28:54,120
possible but if we look at an

563
00:28:50,550 --> 00:28:56,879
environment instead of having 4b pages

564
00:28:54,120 --> 00:28:59,550
we have information of pay offset so the

565
00:28:56,880 --> 00:29:02,160
size of addresses you need in order to

566
00:28:59,550 --> 00:29:05,490
have a reasonable possibility of having

567
00:29:02,160 --> 00:29:08,460
an eviction set is 30,000 or 90,000

568
00:29:05,490 --> 00:29:11,610
rather so and this is going to be very

569
00:29:08,460 --> 00:29:13,950
difficult especially if you want to do

570
00:29:11,610 --> 00:29:19,439
things fastly in order to avoid attacks

571
00:29:13,950 --> 00:29:24,420
so we need to improve this so we need to

572
00:29:19,440 --> 00:29:27,840
solve optimization problem which would

573
00:29:24,420 --> 00:29:31,470
be as follows it is very easy to find a

574
00:29:27,840 --> 00:29:35,220
big eviction set but this is quadratic

575
00:29:31,470 --> 00:29:37,830
to reduce it it is right yeah quadratic

576
00:29:35,220 --> 00:29:39,930
to reduce it to its minimum core so we

577
00:29:37,830 --> 00:29:42,210
have a prediction

578
00:29:39,930 --> 00:29:43,980
how many efforts you need to find a

579
00:29:42,210 --> 00:29:46,530
smaller fiction table will be costly but

580
00:29:43,980 --> 00:29:49,260
the quadratic reduction will be will be

581
00:29:46,530 --> 00:29:51,720
faster so the first approach would be to

582
00:29:49,260 --> 00:29:54,270
solve this optimization problem and in

583
00:29:51,720 --> 00:29:55,950
find that the optimal the optimum mums

584
00:29:54,270 --> 00:29:59,340
are a science in order to minimize

585
00:29:55,950 --> 00:30:02,310
efforts the other possibilities instead

586
00:29:59,340 --> 00:30:05,879
of getting one by one address you take

587
00:30:02,310 --> 00:30:09,240
groups of address so in addresses so the

588
00:30:05,880 --> 00:30:11,850
algorithm is going to be faster but the

589
00:30:09,240 --> 00:30:14,940
cost is still quadratic in order to

590
00:30:11,850 --> 00:30:21,030
improve this therefore there is when we

591
00:30:14,940 --> 00:30:24,059
use syphilis so as it turns out

592
00:30:21,030 --> 00:30:28,700
the history of syphilis is as follows

593
00:30:24,059 --> 00:30:31,860
during the war the army wanted to see

594
00:30:28,700 --> 00:30:35,549
what soldiers suffered from syphilis to

595
00:30:31,860 --> 00:30:38,820
treat them and not to not to die

596
00:30:35,549 --> 00:30:45,030
meaning not to die from syphilis but I a

597
00:30:38,820 --> 00:30:49,799
war but the idea was you get blood from

598
00:30:45,030 --> 00:30:52,200
a sample blood from each salt soldier

599
00:30:49,799 --> 00:30:55,020
and you analyzed the sample the problem

600
00:30:52,200 --> 00:30:57,990
is that if most of soldiers are infected

601
00:30:55,020 --> 00:31:03,570
this becomes an efficient process but if

602
00:30:57,990 --> 00:31:06,030
most of them are okay you're spending a

603
00:31:03,570 --> 00:31:08,639
lot on Europe just not efficient so at

604
00:31:06,030 --> 00:31:12,570
that time testing was we're very very

605
00:31:08,640 --> 00:31:16,110
expensive so he wasn't okay so Robert

606
00:31:12,570 --> 00:31:18,658
Norma Norman decided to group tests so

607
00:31:16,110 --> 00:31:21,479
for syphilis the test is sensitive

608
00:31:18,659 --> 00:31:27,559
enough if you group many blood tests and

609
00:31:21,480 --> 00:31:27,559
blood samples if even if there's one

610
00:31:27,799 --> 00:31:31,320
affected the result is can be positive

611
00:31:30,390 --> 00:31:33,960
and the other way around

612
00:31:31,320 --> 00:31:36,418
so you test the group if the result is

613
00:31:33,960 --> 00:31:38,340
positive you learn you don't learn

614
00:31:36,419 --> 00:31:40,590
anything and you will have to split and

615
00:31:38,340 --> 00:31:45,030
in smaller group but if it is negative

616
00:31:40,590 --> 00:31:48,209
you can discard many of them so what

617
00:31:45,030 --> 00:31:52,918
doorman said who's a mathematician was

618
00:31:48,210 --> 00:31:56,610
to find the optimum size groups in order

619
00:31:52,919 --> 00:32:01,080
to identify the infected members of this

620
00:31:56,610 --> 00:32:03,350
population or cohort and to have to get

621
00:32:01,080 --> 00:32:06,780
a positive thing so as a result of that

622
00:32:03,350 --> 00:32:11,459
branch of mathematical combination was

623
00:32:06,780 --> 00:32:14,039
created called group testing group

624
00:32:11,460 --> 00:32:16,380
testing can be applied for many things

625
00:32:14,039 --> 00:32:18,960
and I have no idea about this up until

626
00:32:16,380 --> 00:32:21,600
now last year so this is used by

627
00:32:18,960 --> 00:32:25,289
pharmaceutical companies for industrial

628
00:32:21,600 --> 00:32:30,030
companies for cryptography issues and I

629
00:32:25,289 --> 00:32:32,460
was not aware of this at all so they

630
00:32:30,030 --> 00:32:34,649
could be used for this so if you want to

631
00:32:32,460 --> 00:32:39,100
identify false

632
00:32:34,650 --> 00:32:40,360
light bulbs you take the test and up

633
00:32:39,100 --> 00:32:43,600
until the bulb

634
00:32:40,360 --> 00:32:48,129
none of the bulbs is is okay so the test

635
00:32:43,600 --> 00:32:50,500
is positive so in the case of basic

636
00:32:48,130 --> 00:32:54,160
grouping if you want to identify an

637
00:32:50,500 --> 00:32:56,290
element within the population majority

638
00:32:54,160 --> 00:33:00,220
of minority this is logarithmic cost if

639
00:32:56,290 --> 00:33:03,730
you want to identify the element in a

640
00:33:00,220 --> 00:33:07,240
population you make a logarithm search

641
00:33:03,730 --> 00:33:16,480
multiplied by D so what you get at the

642
00:33:07,240 --> 00:33:18,990
end is log in D by 4/4 so based on this

643
00:33:16,480 --> 00:33:22,690
very simple group testing definition

644
00:33:18,990 --> 00:33:25,300
time went on the problem and the

645
00:33:22,690 --> 00:33:27,040
variants have been generalized and I

646
00:33:25,300 --> 00:33:27,879
came across something very interesting

647
00:33:27,040 --> 00:33:30,310
called

648
00:33:27,880 --> 00:33:33,700
three grouping threshold group testing

649
00:33:30,310 --> 00:33:35,590
so this definition was used to the same

650
00:33:33,700 --> 00:33:37,720
thing so we have a cohort a population

651
00:33:35,590 --> 00:33:41,199
we want to identify faulty elements with

652
00:33:37,720 --> 00:33:42,910
a smaller number of tests possible but

653
00:33:41,200 --> 00:33:45,940
the difference is that this test will be

654
00:33:42,910 --> 00:33:48,370
positive a the number of faulty elements

655
00:33:45,940 --> 00:33:49,960
is higher than X value and the test will

656
00:33:48,370 --> 00:33:54,189
be negative of the number of faulty

657
00:33:49,960 --> 00:33:56,650
element is lower so if the number is in

658
00:33:54,190 --> 00:33:58,810
the middle there the response is

659
00:33:56,650 --> 00:34:04,300
arbitrary and we know nothing about it

660
00:33:58,810 --> 00:34:08,370
so this is was used by us to see if a

661
00:34:04,300 --> 00:34:11,279
test was an eviction test if we have

662
00:34:08,370 --> 00:34:14,199
congruent addresses positive

663
00:34:11,280 --> 00:34:17,140
associativity the test will be positive

664
00:34:14,199 --> 00:34:19,418
and if it is lower the test will the

665
00:34:17,139 --> 00:34:21,790
result will be negative so the test is

666
00:34:19,418 --> 00:34:25,389
called threshold a group testing without

667
00:34:21,790 --> 00:34:32,009
gap because there's like a midterm thing

668
00:34:25,389 --> 00:34:36,370
where with no result so we have OD log

669
00:34:32,010 --> 00:34:38,560
it can be used for n number of tests so

670
00:34:36,370 --> 00:34:40,909
it is not a binary search the

671
00:34:38,560 --> 00:34:44,779
particularity of group testing is

672
00:34:40,909 --> 00:34:48,200
the faulty element could be deluded

673
00:34:44,780 --> 00:34:50,419
enough so that the two test result in

674
00:34:48,199 --> 00:34:56,629
negative result so you cannot use either

675
00:34:50,418 --> 00:35:00,220
or so this is more complicated so l

676
00:34:56,629 --> 00:35:02,420
equals u minus L is okay for that so I

677
00:35:00,220 --> 00:35:08,509
found out that the problem I wanted to

678
00:35:02,420 --> 00:35:11,270
sort out to find Direction set was done

679
00:35:08,510 --> 00:35:15,200
by a branch of mathematics that has been

680
00:35:11,270 --> 00:35:17,599
used for 50 years so I try to find an

681
00:35:15,200 --> 00:35:20,180
algorithms to reduce a fiction said in

682
00:35:17,599 --> 00:35:22,369
an efficient way so the difference is

683
00:35:20,180 --> 00:35:24,410
that group testing tries to minimize the

684
00:35:22,369 --> 00:35:27,500
number of tests but I wanted to minimize

685
00:35:24,410 --> 00:35:29,960
the number of memory access so number

686
00:35:27,500 --> 00:35:34,250
test by the size of each test basically

687
00:35:29,960 --> 00:35:36,520
because our test is allows us to access

688
00:35:34,250 --> 00:35:39,079
all the elements of the group of

689
00:35:36,520 --> 00:35:42,740
addresses so with this there is simple

690
00:35:39,079 --> 00:35:45,799
algorithm we will have linear constant

691
00:35:42,740 --> 00:35:50,058
set of quadratic cost so we have a big

692
00:35:45,799 --> 00:35:54,349
election set and we split associative

693
00:35:50,059 --> 00:35:58,970
'ti - divided sub groups so with this

694
00:35:54,349 --> 00:36:04,180
partition division we have associativity

695
00:35:58,970 --> 00:36:09,828
in tumbles which will result in Vixens

696
00:36:04,180 --> 00:36:12,879
so and divided by associativity plus 1

697
00:36:09,829 --> 00:36:16,520
association so imagine we have 12 200

698
00:36:12,880 --> 00:36:20,359
addresses and we want and we have

699
00:36:16,520 --> 00:36:22,190
associativity 4 so we want to find an

700
00:36:20,359 --> 00:36:27,799
eviction set a minimum of action set of

701
00:36:22,190 --> 00:36:31,250
4 if we divide this in five sub so these

702
00:36:27,799 --> 00:36:33,920
four elements will be united somehow and

703
00:36:31,250 --> 00:36:35,329
the 4 will be contained will be included

704
00:36:33,920 --> 00:36:36,950
so this is a little bit of the

705
00:36:35,329 --> 00:36:43,609
definition of this algorithm

706
00:36:36,950 --> 00:36:46,669
so I created a small tool on T to allow

707
00:36:43,609 --> 00:36:48,230
you to test different algorithms and

708
00:36:46,670 --> 00:36:51,619
different strategies different permit

709
00:36:48,230 --> 00:36:52,840
parameters etc so three thousand random

710
00:36:51,619 --> 00:36:56,380
blocks were the

711
00:36:52,840 --> 00:36:58,870
case number six so using group testing

712
00:36:56,380 --> 00:37:01,510
an algorithm this is by just that

713
00:36:58,870 --> 00:37:03,580
strategy also activated twelve offset

714
00:37:01,510 --> 00:37:05,740
number of repetitions for each measure

715
00:37:03,580 --> 00:37:08,350
time threshold to make the difference

716
00:37:05,740 --> 00:37:10,569
between cache hit catch mix if it is in

717
00:37:08,350 --> 00:37:13,540
the case or not so many things so you

718
00:37:10,570 --> 00:37:19,030
executed your ticket all the things you

719
00:37:13,540 --> 00:37:21,130
find an eviction set use u is used to

720
00:37:19,030 --> 00:37:22,930
know whether average if an eviction set

721
00:37:21,130 --> 00:37:25,690
is an eviction set so you do translate

722
00:37:22,930 --> 00:37:29,410
little eviction twos virtual election to

723
00:37:25,690 --> 00:37:33,330
a physical fiction I'm sorry and then

724
00:37:29,410 --> 00:37:38,890
you find all the different caches so

725
00:37:33,330 --> 00:37:42,250
everything is okay it is okay because

726
00:37:38,890 --> 00:37:44,830
when we can run this faster you can

727
00:37:42,250 --> 00:37:52,740
solve with this algorithm you can reduce

728
00:37:44,830 --> 00:37:56,500
actually groups of nine or one 120,000

729
00:37:52,740 --> 00:38:00,459
addresses in few seconds and before it

730
00:37:56,500 --> 00:38:04,660
took us minute so what happens with TS

731
00:38:00,460 --> 00:38:09,640
you can use it by using a navigator

732
00:38:04,660 --> 00:38:12,700
where attacks are more harder to deal

733
00:38:09,640 --> 00:38:17,620
with so what can we do all this thing

734
00:38:12,700 --> 00:38:19,060
with JavaScript when I'll be based on

735
00:38:17,620 --> 00:38:21,580
Chrome but the ideas could be

736
00:38:19,060 --> 00:38:26,310
generalized so Chrome there's a

737
00:38:21,580 --> 00:38:29,470
multi-process thing each tag each

738
00:38:26,310 --> 00:38:32,170
security domain will be running its own

739
00:38:29,470 --> 00:38:34,990
process in the operating system isolated

740
00:38:32,170 --> 00:38:39,160
in isolation so the distance will be v8

741
00:38:34,990 --> 00:38:42,870
v8 is the engine of a chrome javascript

742
00:38:39,160 --> 00:38:45,940
know very et cetera so at an engine or

743
00:38:42,870 --> 00:38:50,200
JavaScript module eight or whatever you

744
00:38:45,940 --> 00:38:53,500
can call it so the v8 has been

745
00:38:50,200 --> 00:38:56,410
simplified before there were more

746
00:38:53,500 --> 00:38:59,020
compensators so depending on how you

747
00:38:56,410 --> 00:39:00,399
were using it was completing when one

748
00:38:59,020 --> 00:39:02,890
things are one thing

749
00:39:00,400 --> 00:39:07,599
so you take text that navigator will

750
00:39:02,890 --> 00:39:10,450
have a JavaScript text sent to v8 so the

751
00:39:07,599 --> 00:39:14,079
text will be sent to many places and

752
00:39:10,450 --> 00:39:16,930
there will be two processes ignition on

753
00:39:14,079 --> 00:39:19,150
the first one that generates a bytecode

754
00:39:16,930 --> 00:39:21,848
in a very fast way very efficient and

755
00:39:19,150 --> 00:39:25,869
then it interprets it dia is when you

756
00:39:21,849 --> 00:39:28,059
uploaded a page you will not spend time

757
00:39:25,869 --> 00:39:29,799
to complete JavaScript but you start

758
00:39:28,059 --> 00:39:33,609
completing as soon as you can

759
00:39:29,799 --> 00:39:38,049
so in turbofan is the computer which is

760
00:39:33,609 --> 00:39:40,900
the chassis make compiler which will be

761
00:39:38,049 --> 00:39:44,880
the optimized compilation so on

762
00:39:40,900 --> 00:39:49,990
JavaScript one one function start

763
00:39:44,880 --> 00:39:53,910
heating as we call it the computer will

764
00:39:49,990 --> 00:39:58,078
start optimizing it but how does it do

765
00:39:53,910 --> 00:40:02,078
javascript is a an encrypted language

766
00:39:58,079 --> 00:40:05,710
meaning each type with each function

767
00:40:02,079 --> 00:40:10,049
operation the variables can be of many

768
00:40:05,710 --> 00:40:12,640
science stream object networks etc so

769
00:40:10,049 --> 00:40:15,819
it's easy to think about this at a high

770
00:40:12,640 --> 00:40:19,328
level so operator ma must know if it is

771
00:40:15,819 --> 00:40:21,220
streamed Catina or a number you have or

772
00:40:19,329 --> 00:40:23,980
you create something else but when you

773
00:40:21,220 --> 00:40:26,618
generate a specific code for that you

774
00:40:23,980 --> 00:40:28,720
should run checks on runtime in order to

775
00:40:26,619 --> 00:40:30,579
see what kind of data you're using to

776
00:40:28,720 --> 00:40:33,578
come up with it with one function or the

777
00:40:30,579 --> 00:40:37,210
other so when X 85-86 will generate very

778
00:40:33,579 --> 00:40:39,309
simple JavaScript codes you will have a

779
00:40:37,210 --> 00:40:43,269
lot of things that will make the

780
00:40:39,309 --> 00:40:48,749
function to run very slow so we so it

781
00:40:43,269 --> 00:40:52,839
optimizes the computer so we use hints

782
00:40:48,749 --> 00:40:55,180
meaning the type of data used by

783
00:40:52,839 --> 00:40:57,640
function and the other part which is

784
00:40:55,180 --> 00:41:00,730
basic for me to understand what chance

785
00:40:57,640 --> 00:41:02,470
accumulates are do the letters do is as

786
00:41:00,730 --> 00:41:05,349
follow when you're compiling the

787
00:41:02,470 --> 00:41:08,078
computer will come up with the static

788
00:41:05,349 --> 00:41:10,329
analysis of the code and come up with

789
00:41:08,079 --> 00:41:12,680
the following you have an operator or a

790
00:41:10,329 --> 00:41:16,190
function that makes me always

791
00:41:12,680 --> 00:41:18,589
at the same time operator per on Chavez

792
00:41:16,190 --> 00:41:21,020
period different kind of access that

793
00:41:18,589 --> 00:41:23,000
will always be an enter so the computer

794
00:41:21,020 --> 00:41:25,970
will be searching this kind of thing and

795
00:41:23,000 --> 00:41:28,789
it will decide that this variable at

796
00:41:25,970 --> 00:41:31,368
this point in the execution flux it will

797
00:41:28,789 --> 00:41:34,460
have an entire so when you identify

798
00:41:31,369 --> 00:41:37,099
these things you cannot identify a great

799
00:41:34,460 --> 00:41:39,200
number of runtime checks you will

800
00:41:37,099 --> 00:41:41,180
generate one thing for an entire process

801
00:41:39,200 --> 00:41:43,730
because you can decide that for a

802
00:41:41,180 --> 00:41:45,680
variable from this point on something

803
00:41:43,730 --> 00:41:50,480
else will happen otherwise you will have

804
00:41:45,680 --> 00:41:53,598
a security failure so this is the idea

805
00:41:50,480 --> 00:41:57,289
this is the main idea to optimize

806
00:41:53,599 --> 00:42:00,859
JavaScript code have you ever heard of

807
00:41:57,289 --> 00:42:04,579
same lehigh JavaScript this syntax that

808
00:42:00,859 --> 00:42:07,279
is the Bhoots operator or with a zero

809
00:42:04,579 --> 00:42:13,210
and then all the variables well

810
00:42:07,279 --> 00:42:18,470
basically this is to explicitly make

811
00:42:13,210 --> 00:42:20,420
after the different computers static

812
00:42:18,470 --> 00:42:23,808
analysis you can have all the variables

813
00:42:20,420 --> 00:42:25,549
as entire elements the computer will be

814
00:42:23,809 --> 00:42:28,940
using all these entire elements which

815
00:42:25,549 --> 00:42:32,390
will make things very easier so this is

816
00:42:28,940 --> 00:42:35,029
a great idea and everything went well up

817
00:42:32,390 --> 00:42:38,598
until came up with another kind of

818
00:42:35,029 --> 00:42:40,490
comparator giotto's JavaScript and

819
00:42:38,599 --> 00:42:43,599
things became more compliment and

820
00:42:40,490 --> 00:42:46,490
complicated bar it is better to come

821
00:42:43,599 --> 00:42:52,250
compile different things it's still a

822
00:42:46,490 --> 00:42:55,009
hack it works but if you if you can do

823
00:42:52,250 --> 00:42:57,380
things in a cleaner way much better the

824
00:42:55,010 --> 00:43:02,089
thing is that we have webassembly

825
00:42:57,380 --> 00:43:04,430
currently so hackers started to think

826
00:43:02,089 --> 00:43:08,450
about this seriously and they said ok

827
00:43:04,430 --> 00:43:12,140
it's ok to have a static kind of

828
00:43:08,450 --> 00:43:14,710
compensator to execute things with and

829
00:43:12,140 --> 00:43:17,509
with negative performances so they

830
00:43:14,710 --> 00:43:21,440
created web assembly which is a language

831
00:43:17,510 --> 00:43:25,090
that seems to be an assembler but it's

832
00:43:21,440 --> 00:43:28,270
integrated in all JavaScript engines

833
00:43:25,090 --> 00:43:29,050
and you have to know that it uses tack

834
00:43:28,270 --> 00:43:31,420
machine

835
00:43:29,050 --> 00:43:33,370
it's a Harvard architecture meaning the

836
00:43:31,420 --> 00:43:36,460
code is separated from the memory which

837
00:43:33,370 --> 00:43:38,950
makes things very more simple so it's

838
00:43:36,460 --> 00:43:43,900
statistically statically I'm sorry typed

839
00:43:38,950 --> 00:43:46,660
languages sixty to sixty 86 mm bit so no

840
00:43:43,900 --> 00:43:50,230
route should be inserted by the compiler

841
00:43:46,660 --> 00:43:54,160
so X expressions we are going to see

842
00:43:50,230 --> 00:43:56,440
syntax afterwards but it seems simple at

843
00:43:54,160 --> 00:44:00,640
the beginning when you have a stack

844
00:43:56,440 --> 00:44:04,090
machine and if you read instruction in M

845
00:44:00,640 --> 00:44:06,790
that way it's very difficult because one

846
00:44:04,090 --> 00:44:09,160
the stack is full operation starts a

847
00:44:06,790 --> 00:44:11,830
separate so with that expressions you

848
00:44:09,160 --> 00:44:14,200
can animate these operations and make

849
00:44:11,830 --> 00:44:17,830
your life simpler but the most important

850
00:44:14,200 --> 00:44:21,069
thing for me at least and I guess for

851
00:44:17,830 --> 00:44:23,560
other people with the word assembly you

852
00:44:21,070 --> 00:44:25,540
get performant more performance and

853
00:44:23,560 --> 00:44:28,270
practical predictability of the

854
00:44:25,540 --> 00:44:31,029
execution the execution time will not

855
00:44:28,270 --> 00:44:33,310
depend on the other things Java scripts

856
00:44:31,030 --> 00:44:35,080
who's using compiling this action GABA

857
00:44:33,310 --> 00:44:37,720
collection on the other part or

858
00:44:35,080 --> 00:44:41,080
optimizing a function because harvest

859
00:44:37,720 --> 00:44:43,930
channel script is using up to do i

860
00:44:41,080 --> 00:44:45,730
optimize or not in order to memory a

861
00:44:43,930 --> 00:44:47,410
little bit so with the web assembly you

862
00:44:45,730 --> 00:44:50,020
generate the goat and the code is

863
00:44:47,410 --> 00:44:52,870
already optimized so it seems simple and

864
00:44:50,020 --> 00:44:55,980
then lift up vs turbofan is the same

865
00:44:52,870 --> 00:45:00,730
thing that we have a technician just

866
00:44:55,980 --> 00:45:03,760
keep out of curiosity ignition generates

867
00:45:00,730 --> 00:45:05,740
byte codes very fastly but it's not

868
00:45:03,760 --> 00:45:08,770
efficient less lift off and same thing

869
00:45:05,740 --> 00:45:11,919
you compile a web a passive webassembly

870
00:45:08,770 --> 00:45:13,630
a code that could be executed swiftly if

871
00:45:11,920 --> 00:45:15,370
you're interested and and then on the

872
00:45:13,630 --> 00:45:17,550
background when you generate where the

873
00:45:15,370 --> 00:45:21,040
assembly code you will start using

874
00:45:17,550 --> 00:45:24,370
turbofan so once you get to go find you

875
00:45:21,040 --> 00:45:27,340
will not use lift up lift off but if you

876
00:45:24,370 --> 00:45:31,620
want to optimize things you use v off

877
00:45:27,340 --> 00:45:31,620
lift off so

878
00:45:31,680 --> 00:45:38,970
this is JavaScript so and how it wait

879
00:45:35,400 --> 00:45:41,970
works to generate codes we are really

880
00:45:38,970 --> 00:45:46,620
interested in knowing how to the memory

881
00:45:41,970 --> 00:45:51,839
works I'm not going to explain all this

882
00:45:46,620 --> 00:45:54,810
and to all the details because I don't

883
00:45:51,840 --> 00:45:57,270
know much about this actually but you

884
00:45:54,810 --> 00:46:01,500
have a lot of alligators and they are

885
00:45:57,270 --> 00:46:04,980
constantly being changed before we use

886
00:46:01,500 --> 00:46:09,170
the partition and then oil pan and parts

887
00:46:04,980 --> 00:46:13,290
depending on the object here working

888
00:46:09,170 --> 00:46:16,050
garbage or not garbage collection and

889
00:46:13,290 --> 00:46:21,330
other one and the others are not in the

890
00:46:16,050 --> 00:46:22,530
case of v8 to my knowledge it uses the

891
00:46:21,330 --> 00:46:25,740
memory by itself

892
00:46:22,530 --> 00:46:28,970
and the last thing is they included our

893
00:46:25,740 --> 00:46:31,709
knuckle which is a garbage collector

894
00:46:28,970 --> 00:46:34,580
again what what is interesting about

895
00:46:31,710 --> 00:46:38,150
what we have before is that it is

896
00:46:34,580 --> 00:46:41,490
concurrent before you have to stop

897
00:46:38,150 --> 00:46:43,860
JavaScript and leave the garbage

898
00:46:41,490 --> 00:46:46,740
collector to stop whatever it wanted

899
00:46:43,860 --> 00:46:48,660
with our anak oh you have a GC which is

900
00:46:46,740 --> 00:46:50,879
the cap a collector so you're blocking

901
00:46:48,660 --> 00:46:54,899
things because you need to introduce

902
00:46:50,880 --> 00:46:58,080
block button blocks but not like in the

903
00:46:54,900 --> 00:47:01,050
past so v8 has different regions

904
00:46:58,080 --> 00:47:04,080
depending on the types you use depending

905
00:47:01,050 --> 00:47:07,560
on the objects you want you want so

906
00:47:04,080 --> 00:47:10,319
we're going to focused on large object

907
00:47:07,560 --> 00:47:12,180
space this region and the interesting

908
00:47:10,320 --> 00:47:14,670
the interesting thing is that when you

909
00:47:12,180 --> 00:47:16,950
try to reserve in the memory with what

910
00:47:14,670 --> 00:47:18,120
buffer or something that is bigger than

911
00:47:16,950 --> 00:47:21,779
the region itself

912
00:47:18,120 --> 00:47:24,770
so this large object space will delegate

913
00:47:21,780 --> 00:47:28,800
their response in the operating center

914
00:47:24,770 --> 00:47:32,460
operating system and sorry so you get

915
00:47:28,800 --> 00:47:35,040
strays with v8 and you try to get this

916
00:47:32,460 --> 00:47:40,620
kind of buffers up until the moment will

917
00:47:35,040 --> 00:47:43,920
it will be using map directly so it's a

918
00:47:40,620 --> 00:47:45,500
virtual map so the page on the operating

919
00:47:43,920 --> 00:47:49,369
system will be aligned

920
00:47:45,500 --> 00:47:53,750
the offset zero of this page will have

921
00:47:49,369 --> 00:47:58,430
the 12 element zero so you can control

922
00:47:53,750 --> 00:48:02,480
pay off pay page offset if you have a

923
00:47:58,430 --> 00:48:05,649
location which is big enough so you get

924
00:48:02,480 --> 00:48:10,790
the virtual memory you will have the 12

925
00:48:05,650 --> 00:48:15,830
page of it of the physical so what do we

926
00:48:10,790 --> 00:48:20,890
mean now what is lacking to close the

927
00:48:15,830 --> 00:48:24,770
loop on JavaScript high resolution clock

928
00:48:20,890 --> 00:48:28,430
so that we can differentiate me between

929
00:48:24,770 --> 00:48:35,090
between I'm sorry I'm sorry Kate or

930
00:48:28,430 --> 00:48:38,089
memory counters so high resolution of

931
00:48:35,090 --> 00:48:43,849
time we had before but as a result of

932
00:48:38,090 --> 00:48:45,859
this kind of packages so we have been

933
00:48:43,849 --> 00:48:48,470
reduced this instead of that

934
00:48:45,859 --> 00:48:53,509
there are simplification techniques so

935
00:48:48,470 --> 00:48:56,149
you have a counter or clock to amplify

936
00:48:53,510 --> 00:48:59,119
the precision of the clock and you can

937
00:48:56,150 --> 00:49:01,940
make tricks to get to the difference but

938
00:48:59,119 --> 00:49:04,010
the best thing is to use sheer array

939
00:49:01,940 --> 00:49:08,510
buffer I don't know if you know about it

940
00:49:04,010 --> 00:49:11,450
when t3 were created navigators said to

941
00:49:08,510 --> 00:49:13,730
enable this by default but this is an

942
00:49:11,450 --> 00:49:15,740
easy way to have a high resolution clock

943
00:49:13,730 --> 00:49:19,130
on JavaScript you have a shared memory

944
00:49:15,740 --> 00:49:22,910
you use the thread and the thread will

945
00:49:19,130 --> 00:49:27,470
have will run a counter that emulates

946
00:49:22,910 --> 00:49:31,029
the clock so it is a loop to increase

947
00:49:27,470 --> 00:49:35,450
things you will have a cycle so each

948
00:49:31,030 --> 00:49:38,119
augmentation means a cycle is the same

949
00:49:35,450 --> 00:49:40,790
thing so last version AK we activated

950
00:49:38,119 --> 00:49:45,980
this because most of developers wanted

951
00:49:40,790 --> 00:49:48,290
this and because deleted this make life

952
00:49:45,980 --> 00:49:51,920
of the attackers very difficult but not

953
00:49:48,290 --> 00:49:54,980
as much as needed so this is an example

954
00:49:51,920 --> 00:49:57,829
of the code on JavaScript so like

955
00:49:54,980 --> 00:50:03,650
worker so we have the worker and when he

956
00:49:57,829 --> 00:50:06,920
gets a message it will start wide and

957
00:50:03,650 --> 00:50:10,220
true and increase the counter and this

958
00:50:06,920 --> 00:50:13,369
will left a run the main code here the

959
00:50:10,220 --> 00:50:17,598
worker here the allocation of shared

960
00:50:13,369 --> 00:50:20,510
memory and the reference is passed on to

961
00:50:17,599 --> 00:50:25,849
the memory and this increases and here

962
00:50:20,510 --> 00:50:28,520
this is how to measure time so so we

963
00:50:25,849 --> 00:50:30,470
execute the function to measure time we

964
00:50:28,520 --> 00:50:33,560
access again and we get the difference

965
00:50:30,470 --> 00:50:38,419
of the counter words will produce the

966
00:50:33,560 --> 00:50:41,660
difference let's talk about a little bit

967
00:50:38,420 --> 00:50:45,730
of codes to conclude for those of you

968
00:50:41,660 --> 00:50:45,730
who are not aware of the lock this is

969
00:50:45,910 --> 00:50:51,828
something probably new so these are

970
00:50:48,859 --> 00:50:57,049
modules so the idea is to import a

971
00:50:51,829 --> 00:50:59,420
shared memory shared memory here we

972
00:50:57,050 --> 00:51:04,930
export the access function and this

973
00:50:59,420 --> 00:51:08,300
access function will get a parameter

974
00:51:04,930 --> 00:51:11,390
entires and then it would say it yields

975
00:51:08,300 --> 00:51:15,079
an entire so we have a load using the

976
00:51:11,390 --> 00:51:17,029
memory we import it and then return so

977
00:51:15,079 --> 00:51:21,050
how do we something I forgot before

978
00:51:17,030 --> 00:51:24,859
where assembly has a binary method which

979
00:51:21,050 --> 00:51:28,790
is good because you don't have to text

980
00:51:24,859 --> 00:51:33,799
to send text but this by Namur binary

981
00:51:28,790 --> 00:51:37,700
system is been thought for being used on

982
00:51:33,800 --> 00:51:39,650
streaming only one pass so you use web

983
00:51:37,700 --> 00:51:41,930
assembly and the Navigator will generate

984
00:51:39,650 --> 00:51:46,520
things automatically so we accelerate

985
00:51:41,930 --> 00:51:49,310
things so we with what to where the

986
00:51:46,520 --> 00:51:52,190
assembly which is to love well assembly

987
00:51:49,310 --> 00:51:56,660
we compile this little software this

988
00:51:52,190 --> 00:51:59,960
little program and then the the shared

989
00:51:56,660 --> 00:52:03,259
memory in that version I was using is

990
00:51:59,960 --> 00:52:05,270
not by default so we test in the web

991
00:52:03,260 --> 00:52:07,089
assembly module and we execute the

992
00:52:05,270 --> 00:52:09,339
function we exported

993
00:52:07,089 --> 00:52:15,400
access and we can have access to zero

994
00:52:09,339 --> 00:52:17,619
offset zero so for v8 this is a VHL with

995
00:52:15,400 --> 00:52:21,160
a small environment

996
00:52:17,619 --> 00:52:23,619
same thing with OD e and crumb that's

997
00:52:21,160 --> 00:52:25,719
the same thing I did this this way

998
00:52:23,619 --> 00:52:30,640
because it's more comfortable for me so

999
00:52:25,719 --> 00:52:33,729
we have this slab of print code and code

1000
00:52:30,640 --> 00:52:39,430
comments so when we execute this

1001
00:52:33,729 --> 00:52:44,169
function the screen will show as the

1002
00:52:39,430 --> 00:52:46,660
code created by turbo flap because the

1003
00:52:44,170 --> 00:52:49,180
it generates native codes that looks

1004
00:52:46,660 --> 00:52:53,890
like that this little function here will

1005
00:52:49,180 --> 00:52:58,899
be translated into this code here so R

1006
00:52:53,890 --> 00:53:01,089
as I has always was an instance so the

1007
00:52:58,900 --> 00:53:06,700
offset of memory offset of the external

1008
00:53:01,089 --> 00:53:11,499
functions we imported returned by rax

1009
00:53:06,700 --> 00:53:14,649
this is the Prolog the RSI RSI is

1010
00:53:11,499 --> 00:53:18,788
included in RDX this is the memory

1011
00:53:14,650 --> 00:53:22,150
officer object offset I'm sorry so we

1012
00:53:18,789 --> 00:53:24,460
have comparisons here rax is our offset

1013
00:53:22,150 --> 00:53:29,289
for this function here so we have a

1014
00:53:24,460 --> 00:53:31,150
comparison of signs here now the one

1015
00:53:29,289 --> 00:53:34,329
that is highlighted here is access to

1016
00:53:31,150 --> 00:53:39,640
memory so our Peaks which was the memory

1017
00:53:34,329 --> 00:53:43,089
offset plus the RDX of our ranks that

1018
00:53:39,640 --> 00:53:45,940
was our offset before so we returned

1019
00:53:43,089 --> 00:53:50,558
which is a little strange here but we

1020
00:53:45,940 --> 00:53:53,009
know the compiler works so this is how

1021
00:53:50,559 --> 00:53:57,130
to set off set up the JavaScript

1022
00:53:53,009 --> 00:54:01,150
comparators and we use this website web

1023
00:53:57,130 --> 00:54:06,190
asset to clean a little bit so if you

1024
00:54:01,150 --> 00:54:10,400
include the I 62 of the I 32 you delete

1025
00:54:06,190 --> 00:54:14,369
this comparison I wanted to

1026
00:54:10,400 --> 00:54:18,869
deliver this to avoid noise so if you

1027
00:54:14,369 --> 00:54:21,540
include a one a series of one masks

1028
00:54:18,869 --> 00:54:24,350
there will be no sign comparison because

1029
00:54:21,540 --> 00:54:29,040
the sign is determined by the heaviest

1030
00:54:24,350 --> 00:54:32,549
beep so when you use the application the

1031
00:54:29,040 --> 00:54:34,920
machine is smart enough saying that this

1032
00:54:32,550 --> 00:54:37,020
number after applying masks will never

1033
00:54:34,920 --> 00:54:37,560
be negative so why sound check over

1034
00:54:37,020 --> 00:54:41,730
there

1035
00:54:37,560 --> 00:54:49,560
so the idea is that we can play with

1036
00:54:41,730 --> 00:55:05,820
webassembly to generate a x86 clean that

1037
00:54:49,560 --> 00:55:09,509
is that is clean zero contains the

1038
00:55:05,820 --> 00:55:13,260
counter so load of zero plus one and

1039
00:55:09,510 --> 00:55:17,190
this story of zero and that's it when we

1040
00:55:13,260 --> 00:55:20,570
get a code this is quite short shorter

1041
00:55:17,190 --> 00:55:24,600
than what we had javascript another

1042
00:55:20,570 --> 00:55:27,180
alternative is James extensions as it is

1043
00:55:24,600 --> 00:55:30,960
a shared memory we could use this for

1044
00:55:27,180 --> 00:55:38,040
item instructions of assembly I tried it

1045
00:55:30,960 --> 00:55:42,180
because it was better but in my case

1046
00:55:38,040 --> 00:55:45,070
that was not valid so I always used the

1047
00:55:42,180 --> 00:55:48,169
version that's not the atomic version

1048
00:55:45,070 --> 00:55:48,169
[Music]

1049
00:55:56,390 --> 00:56:09,730
tests conducted I use we have access

1050
00:56:08,310 --> 00:56:13,119
only to those

1051
00:56:09,730 --> 00:56:19,680
that I want to test I'm using here for

1052
00:56:13,119 --> 00:56:22,450
instance things to clean the thing and

1053
00:56:19,680 --> 00:56:29,490
interesting thing is that to waste of

1054
00:56:22,450 --> 00:56:29,490
access to the eviction set linked list

1055
00:56:30,000 --> 00:56:40,690
it is the logic goes upward to test

1056
00:56:34,660 --> 00:56:43,210
things memory well it depends once you

1057
00:56:40,690 --> 00:56:45,190
have access and you know which axis you

1058
00:56:43,210 --> 00:56:49,150
will have to which direction absolutes

1059
00:56:45,190 --> 00:56:52,240
if you have a thousand you have me

1060
00:56:49,150 --> 00:56:57,210
thousand times access to the memory a

1061
00:56:52,240 --> 00:56:59,589
and if you talk about then you will the

1062
00:56:57,210 --> 00:57:01,630
execution we mentioned before out of

1063
00:56:59,590 --> 00:57:04,090
order execution where you could have

1064
00:57:01,630 --> 00:57:07,810
several in parallel in my case in my

1065
00:57:04,090 --> 00:57:13,780
implementation I prefer the slow option

1066
00:57:07,810 --> 00:57:31,150
but where I introduce another option is

1067
00:57:13,780 --> 00:57:34,480
to deploy two axes will use a trick and

1068
00:57:31,150 --> 00:57:37,119
we will divide by 3 or by for exhibition

1069
00:57:34,480 --> 00:57:40,210
time we will save time or speed it up

1070
00:57:37,119 --> 00:57:42,910
and here we have to measure the time to

1071
00:57:40,210 --> 00:57:46,000
access in this case we have the web

1072
00:57:42,910 --> 00:57:48,040
assembly module and we're going to try

1073
00:57:46,000 --> 00:57:51,670
to have an access to the victim address

1074
00:57:48,040 --> 00:57:54,160
we're going to have access to clock or

1075
00:57:51,670 --> 00:57:57,640
to the counter we will go back to the

1076
00:57:54,160 --> 00:58:00,430
victim would measure the clock and we

1077
00:57:57,640 --> 00:58:04,990
will see the difference in to those two

1078
00:58:00,430 --> 00:58:07,089
clocks have we have we do it the way we

1079
00:58:04,990 --> 00:58:10,229
saw at the beginning and we will have a

1080
00:58:07,090 --> 00:58:14,080
goal as you see in blue it seems quite

1081
00:58:10,230 --> 00:58:17,200
well clear the mask

1082
00:58:14,080 --> 00:58:20,200
before memory access here we have the

1083
00:58:17,200 --> 00:58:22,870
time to start memory access to see the

1084
00:58:20,200 --> 00:58:29,560
hit time and here at the end time and

1085
00:58:22,870 --> 00:58:33,910
the final and we see any correlation of

1086
00:58:29,560 --> 00:58:36,100
data those notes won't be in the order

1087
00:58:33,910 --> 00:58:37,899
you would like them to pass those

1088
00:58:36,100 --> 00:58:39,940
instructions could be executed in

1089
00:58:37,900 --> 00:58:41,680
parallel mode it could be that the

1090
00:58:39,940 --> 00:58:45,250
buffer was of the request of the same

1091
00:58:41,680 --> 00:58:48,370
address and you where's twice they will

1092
00:58:45,250 --> 00:58:50,650
say do I give it the same twice so it is

1093
00:58:48,370 --> 00:58:52,240
up to the hard work won't say why shall

1094
00:58:50,650 --> 00:58:54,640
I do it twice I'll give you the same

1095
00:58:52,240 --> 00:58:56,740
value you have zeros all the time

1096
00:58:54,640 --> 00:58:59,140
because of controlling differences and

1097
00:58:56,740 --> 00:59:01,270
when you establish the difference you

1098
00:58:59,140 --> 00:59:04,330
will get zero you won't see anything you

1099
00:59:01,270 --> 00:59:06,730
won't learn anything about it we add

1100
00:59:04,330 --> 00:59:10,120
differences artificially this is what I

1101
00:59:06,730 --> 00:59:12,190
did here what I did here is that value

1102
00:59:10,120 --> 00:59:15,490
that I take from the first node I will

1103
00:59:12,190 --> 00:59:19,060
be using this when is an operation that

1104
00:59:15,490 --> 00:59:22,359
won't to be affecting the offset of the

1105
00:59:19,060 --> 00:59:24,490
second node but this is interlinked and

1106
00:59:22,360 --> 00:59:32,650
this is going to be executed in the

1107
00:59:24,490 --> 00:59:38,649
order we want to have measure the hit to

1108
00:59:32,650 --> 00:59:41,260
see which we add the function mentioned

1109
00:59:38,650 --> 00:59:44,860
before and we have access to victim but

1110
00:59:41,260 --> 00:59:50,380
is in the cache memory we haven't yeah

1111
00:59:44,860 --> 00:59:52,570
that's well well effect victim or not

1112
00:59:50,380 --> 00:59:54,610
and we have to measure access to the

1113
00:59:52,570 --> 00:59:57,640
victim and the base at the time and

1114
00:59:54,610 --> 01:00:01,780
that's it I have time for demonstration

1115
00:59:57,640 --> 01:00:03,910
and as we have time demo on now I'm

1116
01:00:01,780 --> 01:00:06,580
going to play some music the music is

1117
01:00:03,910 --> 01:00:09,790
not because I love music no it is just

1118
01:00:06,580 --> 01:00:13,090
to stress the CPU because what you want

1119
01:00:09,790 --> 01:00:16,180
is to have a proximal attack so you

1120
01:00:13,090 --> 01:00:18,250
have background noise at the same time

1121
01:00:16,180 --> 01:00:22,839
and trying to have an access to the

1122
01:00:18,250 --> 01:00:25,660
browser I'm going to do it on another

1123
01:00:22,840 --> 01:00:29,380
one I'm going to have minimum changes

1124
01:00:25,660 --> 01:00:49,450
and then I have several browsers on so

1125
01:00:29,380 --> 01:00:55,150
I'm going to do it now basically this is

1126
01:00:49,450 --> 01:00:59,859
the code JavaScript I was mentioning

1127
01:00:55,150 --> 01:01:07,330
before and you prefer to turn you back

1128
01:00:59,860 --> 01:01:09,820
while reading this innocent module of

1129
01:01:07,330 --> 01:01:12,029
the assembly is the web by simply going

1130
01:01:09,820 --> 01:01:15,970
to oh this is what I said bubble test

1131
01:01:12,030 --> 01:01:18,880
you know have what we have access to be

1132
01:01:15,970 --> 01:01:21,270
address many better the time afterwards

1133
01:01:18,880 --> 01:01:21,270
and

1134
01:01:24,750 --> 01:01:32,559
[Music]

1135
01:01:27,789 --> 01:01:38,979
how difficult I'm going to start

1136
01:01:32,559 --> 01:01:43,299
retrieving sorry I'm going to take only

1137
01:01:38,979 --> 01:01:47,499
one eviction set first going to take out

1138
01:01:43,299 --> 01:01:49,419
only one let's see what happens and what

1139
01:01:47,499 --> 01:01:51,609
I'm going to try to do if I have a

1140
01:01:49,419 --> 01:02:07,388
command here let's see if I can find it

1141
01:01:51,609 --> 01:02:10,989
is I use it for debugging purposes I

1142
01:02:07,389 --> 01:02:13,749
have a friend of the power of the web

1143
01:02:10,989 --> 01:02:15,639
assembly instance and what's interesting

1144
01:02:13,749 --> 01:02:19,198
is let's see what happens

1145
01:02:15,639 --> 01:02:27,459
I have here the CPUC memory story

1146
01:02:19,199 --> 01:02:30,579
opposite the virtual address and you see

1147
01:02:27,459 --> 01:02:33,819
that the offset I've found is fiction

1148
01:02:30,579 --> 01:02:39,549
set and those are offsets my cache

1149
01:02:33,819 --> 01:02:42,009
memory is 1818 addresses 18 associations

1150
01:02:39,549 --> 01:02:44,499
and we have to see the offsets with an

1151
01:02:42,009 --> 01:02:48,609
array well small script here this small

1152
01:02:44,499 --> 01:02:53,428
script that I'm showing you now let's

1153
01:02:48,609 --> 01:02:53,429
see have a small script

1154
01:02:53,690 --> 01:03:00,059
and the only thing is that we're going

1155
01:02:56,640 --> 01:03:02,640
to see their output we will calculate

1156
01:03:00,059 --> 01:03:05,970
the memories talking we will add up

1157
01:03:02,640 --> 01:03:09,660
upset and have a C program where I have

1158
01:03:05,970 --> 01:03:12,480
the closest ID I give a virtual memory

1159
01:03:09,660 --> 01:03:15,720
as an input and I get the virtual the

1160
01:03:12,480 --> 01:03:19,650
physical address and although physical

1161
01:03:15,720 --> 01:03:24,029
address I can calculate a slice and I

1162
01:03:19,650 --> 01:03:29,099
can get my answer of a cache here

1163
01:03:24,029 --> 01:03:33,539
so I versus this has been checked

1164
01:03:29,099 --> 01:03:38,250
verified all the addresses go to the

1165
01:03:33,539 --> 01:03:40,559
same eviction set of the same slides and

1166
01:03:38,250 --> 01:03:44,460
now we're going to perform the same

1167
01:03:40,559 --> 01:03:47,940
thing but now instead of finding only

1168
01:03:44,460 --> 01:03:53,269
one eviction set now we're going to find

1169
01:03:47,940 --> 01:03:53,269
all almost all of them

1170
01:03:59,330 --> 01:04:01,420
and

1171
01:04:02,060 --> 01:04:04,870
okay

1172
01:04:11,690 --> 01:04:17,990
basically this is what we found here

1173
01:04:14,930 --> 01:04:20,960
in 15 seconds only those eviction sets

1174
01:04:17,990 --> 01:04:22,430
different eviction sets in 11 and 28 in

1175
01:04:20,960 --> 01:04:26,059
cash we have eight thousand one hundred

1176
01:04:22,430 --> 01:04:28,848
twenty 92 but if you take 128 you can

1177
01:04:26,059 --> 01:04:33,349
offline cut away to the proper offset

1178
01:04:28,849 --> 01:04:34,670
for the 8,192 you get 128 eviction sets

1179
01:04:33,349 --> 01:04:37,039
you have evidences for all the cache

1180
01:04:34,670 --> 01:04:39,619
memory and that's it and that's it

1181
01:04:37,039 --> 01:04:40,860
that's it folks that's a thank you very

1182
01:04:39,619 --> 01:04:43,379
much

1183
01:04:40,860 --> 01:04:43,379
[Applause]

