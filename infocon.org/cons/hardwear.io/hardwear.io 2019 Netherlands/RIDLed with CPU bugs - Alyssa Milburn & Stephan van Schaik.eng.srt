1
00:00:02,179 --> 00:00:08,280
okay so hi I'm Alyssa this is Stefan

2
00:00:05,700 --> 00:00:10,140
we're from the view in Amsterdam it's

3
00:00:08,280 --> 00:00:12,480
actually so last year during hot weather

4
00:00:10,140 --> 00:00:13,860
I oh I was kind of torn because we were

5
00:00:12,480 --> 00:00:15,930
actually looking at the books we

6
00:00:13,860 --> 00:00:17,849
couldn't discuss at the time but this

7
00:00:15,930 --> 00:00:19,919
also like the hardware CTF one of the

8
00:00:17,849 --> 00:00:21,929
talks and stuff and I was really torn

9
00:00:19,919 --> 00:00:24,599
you know do I work on these proof of

10
00:00:21,929 --> 00:00:25,979
concept exploits or do I actually go and

11
00:00:24,599 --> 00:00:27,269
interact with the conference and I

12
00:00:25,980 --> 00:00:29,159
decided to interact with the conference

13
00:00:27,269 --> 00:00:31,109
and I don't regret it even though I

14
00:00:29,159 --> 00:00:33,000
didn't get much sleep that week but yeah

15
00:00:31,109 --> 00:00:34,440
we're gonna talk about some bugs we

16
00:00:33,000 --> 00:00:36,750
found and we're gonna but also we're

17
00:00:34,440 --> 00:00:38,849
gonna put them in the context of how

18
00:00:36,750 --> 00:00:43,500
basically everything is broken doom and

19
00:00:38,850 --> 00:00:44,940
despair so we're going to kind of start

20
00:00:43,500 --> 00:00:46,440
by saying we're going to be talking

21
00:00:44,940 --> 00:00:48,540
about CPUs today we're going to be

22
00:00:46,440 --> 00:00:51,420
talking about the fancy complicated CPUs

23
00:00:48,540 --> 00:00:53,310
but we're gonna pretend that they look

24
00:00:51,420 --> 00:00:55,440
something like this we have a bunch of

25
00:00:53,310 --> 00:00:56,940
CPU cores there's some other stuff maybe

26
00:00:55,440 --> 00:00:58,919
there's some RAM which you can go hammer

27
00:00:56,940 --> 00:01:00,150
maybe there's lots of buses

28
00:00:58,920 --> 00:01:01,740
interconnects which are completely

29
00:01:00,150 --> 00:01:03,660
broken we're gonna pretend those don't

30
00:01:01,740 --> 00:01:05,670
exist for today so or at least that

31
00:01:03,660 --> 00:01:09,869
they're super functional and they work

32
00:01:05,670 --> 00:01:11,700
and there were no bugs and we're going

33
00:01:09,869 --> 00:01:13,380
to be talking about the cloud because

34
00:01:11,700 --> 00:01:15,960
that's kind of the threat model here

35
00:01:13,380 --> 00:01:18,479
we've done something kind of crazy which

36
00:01:15,960 --> 00:01:19,890
is that we kind of decided that the CPS

37
00:01:18,479 --> 00:01:21,240
are amazing they're everywhere we have

38
00:01:19,890 --> 00:01:23,909
them in our phones and computers and

39
00:01:21,240 --> 00:01:26,850
stuff and that's kind of okay but then

40
00:01:23,909 --> 00:01:30,569
we started thinking well we can just put

41
00:01:26,850 --> 00:01:33,928
you know the CPUs in servers and then we

42
00:01:30,569 --> 00:01:36,079
can share these surface and that's fine

43
00:01:33,929 --> 00:01:38,340
right I mean shared resources

44
00:01:36,079 --> 00:01:41,490
this couldn't cause any problems because

45
00:01:38,340 --> 00:01:43,740
we have these isolation mechanisms so we

46
00:01:41,490 --> 00:01:45,839
started that with these processes and we

47
00:01:43,740 --> 00:01:47,219
have containers but you know to make us

48
00:01:45,840 --> 00:01:49,679
feel safe at night

49
00:01:47,219 --> 00:01:51,839
we have these virtual machines and these

50
00:01:49,679 --> 00:01:53,100
virtual machines make us pretend you

51
00:01:51,840 --> 00:01:55,590
know we have all kind of our own

52
00:01:53,100 --> 00:01:57,419
computer or if you know we don't quite

53
00:01:55,590 --> 00:01:59,850
have a whole computer at least we're

54
00:01:57,420 --> 00:02:03,149
separated sufficiently from our

55
00:01:59,850 --> 00:02:05,609
neighbors and basically we've trusted

56
00:02:03,149 --> 00:02:08,340
these CP years to isolate these virtual

57
00:02:05,609 --> 00:02:10,978
machines we just pretend we get our own

58
00:02:08,340 --> 00:02:13,799
computers and this is a actually a

59
00:02:10,979 --> 00:02:14,490
really really bad idea not just because

60
00:02:13,799 --> 00:02:17,010
of the

61
00:02:14,490 --> 00:02:23,820
but we found but because CPUs are just

62
00:02:17,010 --> 00:02:26,130
not that perfect they're just full of a

63
00:02:23,820 --> 00:02:27,660
Vata full of these bugs and it's like

64
00:02:26,130 --> 00:02:29,100
okay you know we've been picking on

65
00:02:27,660 --> 00:02:31,320
Intel we're gonna be picking on Intel

66
00:02:29,100 --> 00:02:32,730
it's gonna be fun but you know what

67
00:02:31,320 --> 00:02:34,350
about the offeror manufacturers well you

68
00:02:32,730 --> 00:02:36,030
can look at these errata sheets that say

69
00:02:34,350 --> 00:02:38,250
you know what kind of bugs do you see in

70
00:02:36,030 --> 00:02:40,620
these CPUs do you have like one or two

71
00:02:38,250 --> 00:02:43,110
minor bugs and your CP is so I picked a

72
00:02:40,620 --> 00:02:45,870
completely random ARM processor and it's

73
00:02:43,110 --> 00:02:47,580
like okay this is one page of the table

74
00:02:45,870 --> 00:02:49,770
of contents of the bug list there are a

75
00:02:47,580 --> 00:02:51,180
lot of pages of the table of contents

76
00:02:49,770 --> 00:02:54,390
never mind the bugs themselves

77
00:02:51,180 --> 00:02:57,120
it's like what about AMD well it turns

78
00:02:54,390 --> 00:02:59,339
out they have lots of bugs too for

79
00:02:57,120 --> 00:03:01,590
instance you might recently I've heard

80
00:02:59,340 --> 00:03:02,490
about the are deer and bug where I think

81
00:03:01,590 --> 00:03:04,740
after asleep

82
00:03:02,490 --> 00:03:06,110
AMD zadir and would just always return

83
00:03:04,740 --> 00:03:09,180
zeros it just wouldn't work anymore

84
00:03:06,110 --> 00:03:10,560
these things are really complicated it's

85
00:03:09,180 --> 00:03:12,420
like but these are all fixed right I

86
00:03:10,560 --> 00:03:14,760
mean these get fixed really quickly so I

87
00:03:12,420 --> 00:03:16,500
took a few days ago Intel updated one of

88
00:03:14,760 --> 00:03:18,600
the errata for their latest CPU and

89
00:03:16,500 --> 00:03:20,520
their table of contents is really nice

90
00:03:18,600 --> 00:03:21,960
because you can't quite pretty card

91
00:03:20,520 --> 00:03:24,000
quite see it here but on the left side

92
00:03:21,960 --> 00:03:28,740
here there's a column is it fixed or not

93
00:03:24,000 --> 00:03:30,830
this is all no fix there was so

94
00:03:28,740 --> 00:03:35,880
apparently not so good at making PDFs

95
00:03:30,830 --> 00:03:38,670
anyway so what we've actually going to

96
00:03:35,880 --> 00:03:39,990
talk about today is CPU pipelines so as

97
00:03:38,670 --> 00:03:42,359
I saying we're going to ignore the rest

98
00:03:39,990 --> 00:03:46,740
of these CPUs but we're going to talk

99
00:03:42,360 --> 00:03:48,060
about how even if you don't care about

100
00:03:46,740 --> 00:03:49,680
all the bugs in the rest of the chip

101
00:03:48,060 --> 00:03:52,080
we're still blindly trusting the CPU

102
00:03:49,680 --> 00:03:54,660
pipelines because these pipelines are

103
00:03:52,080 --> 00:03:59,220
actually on the bus they have access to

104
00:03:54,660 --> 00:04:02,100
everything and we're just kind of saying

105
00:03:59,220 --> 00:04:03,870
okay we're gonna imagine these isolation

106
00:04:02,100 --> 00:04:06,060
sexists that the CPU pipeline this is

107
00:04:03,870 --> 00:04:08,400
home.how going to isolate us from the

108
00:04:06,060 --> 00:04:10,170
thing even though there's really nothing

109
00:04:08,400 --> 00:04:12,660
actually enforcing that isolation other

110
00:04:10,170 --> 00:04:16,979
than the hopes of the CPU designers and

111
00:04:12,660 --> 00:04:19,409
of everyone using the cloud and this is

112
00:04:16,980 --> 00:04:21,270
think of speculative execution which

113
00:04:19,410 --> 00:04:23,400
broke everyone's fret bottles a few

114
00:04:21,269 --> 00:04:24,719
years ago so I don't know how many of

115
00:04:23,400 --> 00:04:27,030
you familiar with respect to the vets

116
00:04:24,720 --> 00:04:28,500
execution I imagine most of you but I'm

117
00:04:27,030 --> 00:04:29,549
just gonna go through this very quickly

118
00:04:28,500 --> 00:04:32,580
so you understand what we're talking

119
00:04:29,550 --> 00:04:35,220
about later so have a simple example

120
00:04:32,580 --> 00:04:38,609
program and it does some computation and

121
00:04:35,220 --> 00:04:39,900
then we have a branch which says okay

122
00:04:38,610 --> 00:04:42,000
they just compute a with this

123
00:04:39,900 --> 00:04:43,200
computation actually finished if it was

124
00:04:42,000 --> 00:04:44,820
we're gonna do something with this

125
00:04:43,200 --> 00:04:47,820
otherwise we're gonna throw an error

126
00:04:44,820 --> 00:04:49,349
this is kind of very typical code and it

127
00:04:47,820 --> 00:04:51,060
turns out that we want our computers to

128
00:04:49,350 --> 00:04:52,170
run really quickly so what we're

129
00:04:51,060 --> 00:04:53,910
actually gonna do we're going to do the

130
00:04:52,170 --> 00:04:55,920
computation and then we're just gonna

131
00:04:53,910 --> 00:04:57,570
assume it was fine so this if statement

132
00:04:55,920 --> 00:04:58,920
we're just gonna use a branch predictor

133
00:04:57,570 --> 00:05:01,770
and we're gonna say let's assume we

134
00:04:58,920 --> 00:05:04,020
always go down this okay path we do the

135
00:05:01,770 --> 00:05:06,299
do X thing because it always happens

136
00:05:04,020 --> 00:05:11,880
that way it means we can already get to

137
00:05:06,300 --> 00:05:13,350
started executing this code before we

138
00:05:11,880 --> 00:05:15,870
need to worry about it did the

139
00:05:13,350 --> 00:05:17,790
computation actually finish so kind of

140
00:05:15,870 --> 00:05:19,350
the timeline looks like this so we did a

141
00:05:17,790 --> 00:05:21,750
computation but at the same time as the

142
00:05:19,350 --> 00:05:25,500
computation we already get started on

143
00:05:21,750 --> 00:05:26,730
the code after the computation and well

144
00:05:25,500 --> 00:05:28,500
this is speculative

145
00:05:26,730 --> 00:05:30,210
that's why speculative execution we just

146
00:05:28,500 --> 00:05:32,010
hope that it works out and if it doesn't

147
00:05:30,210 --> 00:05:34,919
work out that's absolutely fine because

148
00:05:32,010 --> 00:05:37,979
we just throw away the results and go

149
00:05:34,919 --> 00:05:39,810
back to the other error path the problem

150
00:05:37,979 --> 00:05:42,240
as Stephan will discuss in a minute is

151
00:05:39,810 --> 00:05:44,760
that actually there are side effects to

152
00:05:42,240 --> 00:05:46,440
these paths using the cache using other

153
00:05:44,760 --> 00:05:48,300
mechanisms and we can actually see

154
00:05:46,440 --> 00:05:50,790
what's going on here and this is a real

155
00:05:48,300 --> 00:05:52,740
problem in some cases and meltdown

156
00:05:50,790 --> 00:05:53,850
really brought this home because it

157
00:05:52,740 --> 00:05:55,440
turns out you can do this trick which is

158
00:05:53,850 --> 00:05:57,770
just instead of the computation you do

159
00:05:55,440 --> 00:05:59,850
let's read to memory and then the CPU

160
00:05:57,770 --> 00:06:01,169
internally just says well we're just

161
00:05:59,850 --> 00:06:04,020
going to assume you were allowed to read

162
00:06:01,169 --> 00:06:05,549
that memory and that's fine but it turns

163
00:06:04,020 --> 00:06:08,010
out if that memory is kernel memory it

164
00:06:05,550 --> 00:06:09,810
will still do this and that lets us the

165
00:06:08,010 --> 00:06:12,120
kernel memory and then we had the for

166
00:06:09,810 --> 00:06:14,910
childhood shadow attack which let us do

167
00:06:12,120 --> 00:06:16,890
this with arbitrary physical memory and

168
00:06:14,910 --> 00:06:19,320
what we're going to talk about is how in

169
00:06:16,890 --> 00:06:21,060
turn in particular has been just kind of

170
00:06:19,320 --> 00:06:22,860
piling patch on top of patch on top of

171
00:06:21,060 --> 00:06:27,060
patch but it turns out these issues are

172
00:06:22,860 --> 00:06:29,010
absolutely everywhere and this issue in

173
00:06:27,060 --> 00:06:30,419
general we call exception deferral

174
00:06:29,010 --> 00:06:32,310
because what did

175
00:06:30,419 --> 00:06:35,760
what's even more serious about this is

176
00:06:32,310 --> 00:06:38,130
that when I say you know it flows it

177
00:06:35,760 --> 00:06:40,020
away this bit it turns out in the case

178
00:06:38,130 --> 00:06:42,420
of exceptions actually this code just is

179
00:06:40,020 --> 00:06:43,830
allowed to kind of finish

180
00:06:42,420 --> 00:06:45,870
but we'll talk about that more in a bit

181
00:06:43,830 --> 00:06:47,729
as I said we're going to pick on Intel

182
00:06:45,870 --> 00:06:49,920
and the reason we're doing this is

183
00:06:47,730 --> 00:06:53,100
because they're super popular and they

184
00:06:49,920 --> 00:06:54,890
have a bounty program we're not doing

185
00:06:53,100 --> 00:06:57,990
this just because Intel CPUs are

186
00:06:54,890 --> 00:07:01,740
necessarily the most broken they

187
00:06:57,990 --> 00:07:03,960
certainly seem pretty broken but the

188
00:07:01,740 --> 00:07:07,320
real worry is these bugs are probably

189
00:07:03,960 --> 00:07:08,609
everywhere and I'm hoping to encourage

190
00:07:07,320 --> 00:07:11,010
more people to look at these issues

191
00:07:08,610 --> 00:07:12,930
because I think the stuff we found it's

192
00:07:11,010 --> 00:07:14,849
not that hard to find it's just people

193
00:07:12,930 --> 00:07:17,640
are not looking we just really have

194
00:07:14,850 --> 00:07:20,310
blind faith in these pipelines painter

195
00:07:17,640 --> 00:07:22,380
CPUs I took a diagram from a modern

196
00:07:20,310 --> 00:07:23,640
chart it kind of looks like this but it

197
00:07:22,380 --> 00:07:25,620
turns out this is just a more

198
00:07:23,640 --> 00:07:27,990
complicated way of doing this kind of

199
00:07:25,620 --> 00:07:30,630
diagram you have the CPU cores it's

200
00:07:27,990 --> 00:07:32,460
connected by a mesh rather than a ring

201
00:07:30,630 --> 00:07:34,290
what we're going to pretend it looks

202
00:07:32,460 --> 00:07:36,750
something like this so this is gonna be

203
00:07:34,290 --> 00:07:38,910
super simple right but then if you open

204
00:07:36,750 --> 00:07:40,890
up one of these CPU cores there's a

205
00:07:38,910 --> 00:07:43,080
pipeline inside and this pipeline is

206
00:07:40,890 --> 00:07:45,419
super complicated and we're gonna look

207
00:07:43,080 --> 00:07:46,770
at a few bits of this we'll get some

208
00:07:45,420 --> 00:07:50,070
zoomed in verses later that you can

209
00:07:46,770 --> 00:07:52,020
actually see the details are and we're

210
00:07:50,070 --> 00:07:54,750
going to talk about all class of bugs

211
00:07:52,020 --> 00:07:56,520
the like or architectural data sampling

212
00:07:54,750 --> 00:07:59,310
attacks which is a very nice name to say

213
00:07:56,520 --> 00:08:01,830
micro architectural data means your data

214
00:07:59,310 --> 00:08:04,110
in the pipeline and sampling means

215
00:08:01,830 --> 00:08:06,950
reading you know if you can sample

216
00:08:04,110 --> 00:08:09,540
something then we have your data and

217
00:08:06,950 --> 00:08:11,820
these were in the news recently so grid

218
00:08:09,540 --> 00:08:14,070
or and zombie load and fallout because

219
00:08:11,820 --> 00:08:16,530
everyone loves these fancy names there

220
00:08:14,070 --> 00:08:21,620
was a lot of news coverage oh hell what

221
00:08:16,530 --> 00:08:21,619
do they press hey

222
00:08:22,290 --> 00:08:27,030
but first Stefan is going to talk a bit

223
00:08:24,270 --> 00:08:28,710
about cache attacks and then we'll go

224
00:08:27,030 --> 00:08:34,679
into some technical details about how it

225
00:08:28,710 --> 00:08:38,100
all actually works great so let's first

226
00:08:34,679 --> 00:08:41,669
talk about some cache attacks so as you

227
00:08:38,100 --> 00:08:43,800
may know so and twenty years ago or

228
00:08:41,669 --> 00:08:45,660
something we just use stuff like CPU

229
00:08:43,799 --> 00:08:47,670
registers and main memory and disk

230
00:08:45,660 --> 00:08:50,180
storage and one of the issues is that

231
00:08:47,670 --> 00:08:52,920
well CPU advances quite quickly so we

232
00:08:50,180 --> 00:08:55,020
eventually we broke the gigahertz

233
00:08:52,920 --> 00:08:56,250
barrier for that well main memory is

234
00:08:55,020 --> 00:08:58,870
usually selecting the

235
00:08:56,250 --> 00:09:00,519
so how do we solve this so we put like

236
00:08:58,870 --> 00:09:01,899
three caches in between so level one

237
00:09:00,519 --> 00:09:03,579
cache level two cache level three cache

238
00:09:01,899 --> 00:09:06,670
that are basically smaller memory

239
00:09:03,579 --> 00:09:09,279
components that are much faster so as

240
00:09:06,670 --> 00:09:11,050
you can see here so the lower you get so

241
00:09:09,279 --> 00:09:13,480
closer to the discourage the larger this

242
00:09:11,050 --> 00:09:15,430
but it's also slower the higher you get

243
00:09:13,480 --> 00:09:19,120
so up to the CPU registers the smaller

244
00:09:15,430 --> 00:09:22,000
it is but also the much falsehood is and

245
00:09:19,120 --> 00:09:24,910
one of the noticeable things is like now

246
00:09:22,000 --> 00:09:26,440
if you we talk about loading data it

247
00:09:24,910 --> 00:09:28,149
means it can come from main memory or

248
00:09:26,440 --> 00:09:31,050
from the cache and preferably the cache

249
00:09:28,149 --> 00:09:33,490
and one of the issues so one of the

250
00:09:31,050 --> 00:09:35,139
terminologies we use for this is like if

251
00:09:33,490 --> 00:09:37,709
it's not in the cache it's called the

252
00:09:35,139 --> 00:09:40,000
cache miss and it's slow and if it's

253
00:09:37,709 --> 00:09:42,130
well if it is actually in the cache then

254
00:09:40,000 --> 00:09:43,660
we call it a cache hit and it's fast and

255
00:09:42,130 --> 00:09:45,820
this is something we actually use for

256
00:09:43,660 --> 00:09:48,279
cache attacks because if we now reverse

257
00:09:45,820 --> 00:09:50,440
his idea of like you you can actually

258
00:09:48,279 --> 00:09:52,060
time your load so you can actually time

259
00:09:50,440 --> 00:09:53,769
your load and then you can see if it's

260
00:09:52,060 --> 00:09:57,790
in a cache or not so like if the loads

261
00:09:53,769 --> 00:09:59,829
if you time the load and it takes like

262
00:09:57,790 --> 00:10:01,750
ten cycles for instance then you know

263
00:09:59,829 --> 00:10:03,729
it's in the cache if it takes about 300

264
00:10:01,750 --> 00:10:06,449
cycles for instance you know it's in

265
00:10:03,730 --> 00:10:08,410
main memory and using this we can infer

266
00:10:06,449 --> 00:10:10,630
Infirmary if you're from for instance

267
00:10:08,410 --> 00:10:13,029
other programs what they're doing okay

268
00:10:10,630 --> 00:10:14,890
so I have some code here on the top you

269
00:10:13,029 --> 00:10:17,439
see so its consists of three parts on

270
00:10:14,890 --> 00:10:18,819
the top you see a flush on the in the

271
00:10:17,440 --> 00:10:20,470
second part you see the victim that's

272
00:10:18,820 --> 00:10:22,839
trying to do something within a way and

273
00:10:20,470 --> 00:10:24,430
in the third part you see the reloads

274
00:10:22,839 --> 00:10:26,769
and this is actually the timing part I

275
00:10:24,430 --> 00:10:28,510
was talking about earlier where it tries

276
00:10:26,769 --> 00:10:30,459
to actually do the load and time the

277
00:10:28,510 --> 00:10:33,610
load to see if it's in the cache or not

278
00:10:30,459 --> 00:10:35,768
and then the attack also has this nice

279
00:10:33,610 --> 00:10:38,949
purple rate it's also shirts happens to

280
00:10:35,769 --> 00:10:40,269
be shared a bit with the victim and what

281
00:10:38,949 --> 00:10:41,859
you're going to do in the first step is

282
00:10:40,269 --> 00:10:44,649
actually quite easy we start flushing

283
00:10:41,860 --> 00:10:46,660
this entire way to make sure that it all

284
00:10:44,649 --> 00:10:49,240
is out of the cache and actually has to

285
00:10:46,660 --> 00:10:51,219
be loaded from dy now the victim starts

286
00:10:49,240 --> 00:10:53,620
doing some computation preferably some

287
00:10:51,220 --> 00:10:56,250
table which uses the secret as an index

288
00:10:53,620 --> 00:10:59,740
and what it means is that well it loads

289
00:10:56,250 --> 00:11:02,260
some index which is a secret and you can

290
00:10:59,740 --> 00:11:04,660
actually enter the cache so that next

291
00:11:02,260 --> 00:11:06,610
time if it tries to load the same secret

292
00:11:04,660 --> 00:11:09,250
again it's fast of course and then in

293
00:11:06,610 --> 00:11:11,050
the third step we actually are back

294
00:11:09,250 --> 00:11:13,240
Tucker and yet Tucker starts timing

295
00:11:11,050 --> 00:11:15,849
every entry in the proper way so the

296
00:11:13,240 --> 00:11:18,040
first one access its from D where I'm so

297
00:11:15,850 --> 00:11:20,590
it's slow the second one access its from

298
00:11:18,040 --> 00:11:22,870
D um it's low the third one access hey

299
00:11:20,590 --> 00:11:24,700
it's fast so it's in the cache so now

300
00:11:22,870 --> 00:11:26,920
the attacker knows something about what

301
00:11:24,700 --> 00:11:30,730
the victim did it actually knows which

302
00:11:26,920 --> 00:11:32,500
seek what the secret indexes so previous

303
00:11:30,730 --> 00:11:34,150
attacks you might have seen over the

304
00:11:32,500 --> 00:11:37,300
years or melt down inspector and

305
00:11:34,150 --> 00:11:39,340
foreshadow and for this talk I'm just

306
00:11:37,300 --> 00:11:42,790
going to focus a bit more on meltdown

307
00:11:39,340 --> 00:11:45,970
and but also talk a bit sometimes it's

308
00:11:42,790 --> 00:11:49,240
bites back turn for shadow so if we go

309
00:11:45,970 --> 00:11:52,420
back to a usual cache attack with

310
00:11:49,240 --> 00:11:54,160
meltdown we have an additional bit so we

311
00:11:52,420 --> 00:11:55,630
have to have four components and the

312
00:11:54,160 --> 00:11:58,719
flush and reload should be similar and

313
00:11:55,630 --> 00:11:59,530
new parts here like the victim and the

314
00:11:58,720 --> 00:12:02,410
meltdown step

315
00:11:59,530 --> 00:12:05,650
so the first step what happens is that

316
00:12:02,410 --> 00:12:07,810
you have some kernel and it's you can

317
00:12:05,650 --> 00:12:10,480
convince it to load some kernel address

318
00:12:07,810 --> 00:12:13,660
and what will happen is well it will

319
00:12:10,480 --> 00:12:15,520
load it into the l1d catch so then as an

320
00:12:13,660 --> 00:12:16,900
attacker we flush the proper way so we

321
00:12:15,520 --> 00:12:19,180
start flushing all these entries again

322
00:12:16,900 --> 00:12:21,189
they're not all in all away from the

323
00:12:19,180 --> 00:12:23,260
cache and then we have the meltdown part

324
00:12:21,190 --> 00:12:24,850
and this what happens here is it once in

325
00:12:23,260 --> 00:12:26,980
a transaction so as Alissa mentioned

326
00:12:24,850 --> 00:12:29,260
before this one speculatively so what

327
00:12:26,980 --> 00:12:32,110
happens here is speculatively we will

328
00:12:29,260 --> 00:12:34,240
try to read this kernel address and then

329
00:12:32,110 --> 00:12:36,070
we actually leak the kernel data from

330
00:12:34,240 --> 00:12:38,170
the level and d cache because well the

331
00:12:36,070 --> 00:12:41,920
permission check hasn't happened yet so

332
00:12:38,170 --> 00:12:44,740
I'll just do that and then what we do is

333
00:12:41,920 --> 00:12:47,319
like we do some calculation to use this

334
00:12:44,740 --> 00:12:49,390
value that we found as an index into the

335
00:12:47,320 --> 00:12:51,850
proper way and then we simply load an

336
00:12:49,390 --> 00:12:54,130
entry and appropriate so now we have to

337
00:12:51,850 --> 00:12:56,650
see the the the secret well not the

338
00:12:54,130 --> 00:12:58,180
secret itself loaded but the the secret

339
00:12:56,650 --> 00:12:59,980
is used as an index or this entry got

340
00:12:58,180 --> 00:13:01,989
loaded and now what we can do is an

341
00:12:59,980 --> 00:13:03,610
attacker we can start timeing all of

342
00:13:01,990 --> 00:13:07,000
these entries in the proper way again so

343
00:13:03,610 --> 00:13:09,640
we tried the first one well do um second

344
00:13:07,000 --> 00:13:11,560
one the UM but the third one is fast

345
00:13:09,640 --> 00:13:14,199
because it's in the cache and now we

346
00:13:11,560 --> 00:13:16,060
actually know what the index is and

347
00:13:14,200 --> 00:13:18,640
hence we know the value that we lease

348
00:13:16,060 --> 00:13:21,250
from the kernel so we have some

349
00:13:18,640 --> 00:13:23,240
mitigations against these things one of

350
00:13:21,250 --> 00:13:25,069
them is kernel page table isolation

351
00:13:23,240 --> 00:13:28,939
and that's the primary one against

352
00:13:25,069 --> 00:13:30,949
Melton so what's the idea behind Colonel

353
00:13:28,939 --> 00:13:31,730
page table isolation well the problem is

354
00:13:30,949 --> 00:13:34,368
of course

355
00:13:31,730 --> 00:13:34,850
well weekly colonel data from virtual

356
00:13:34,369 --> 00:13:37,399
addresses

357
00:13:34,850 --> 00:13:40,009
so what do you do well we introduce to

358
00:13:37,399 --> 00:13:41,269
address spaces one for the colonel where

359
00:13:40,009 --> 00:13:43,160
the Colonel's mapped in and the user

360
00:13:41,269 --> 00:13:44,959
space is mapped in and want for user

361
00:13:43,160 --> 00:13:46,490
mode where you have like just user space

362
00:13:44,959 --> 00:13:48,768
and a few colonel pages to switch

363
00:13:46,490 --> 00:13:50,230
between these two so now the colonel

364
00:13:48,769 --> 00:13:54,350
addresses our map so you can ops

365
00:13:50,230 --> 00:13:58,129
speculatively reduce anymore so now we

366
00:13:54,350 --> 00:13:59,660
assume we have a system like about a

367
00:13:58,129 --> 00:14:01,189
year ago with all the mitigations in

368
00:13:59,660 --> 00:14:05,240
place after meltdown inspector

369
00:14:01,189 --> 00:14:07,910
foreshadow so we have this system in our

370
00:14:05,240 --> 00:14:10,670
office it has like a Intel Core i7 7 x

371
00:14:07,910 --> 00:14:13,100
800 X CPU and then if we look at the box

372
00:14:10,670 --> 00:14:15,349
you see it is furnivall from Melda

373
00:14:13,100 --> 00:14:17,389
inspector of variant 1 going to the sole

374
00:14:15,350 --> 00:14:19,639
bypass l1 TF which is also known as

375
00:14:17,389 --> 00:14:21,709
foreshadow and then what we do is like

376
00:14:19,639 --> 00:14:24,230
ok we look a bit at CPU info and we see

377
00:14:21,709 --> 00:14:25,779
like ok we have the latest microcode

378
00:14:24,230 --> 00:14:28,249
it's up to date we have all the

379
00:14:25,779 --> 00:14:32,149
mitigations installed so what can we

380
00:14:28,249 --> 00:14:35,269
still do as an attacker well so here's

381
00:14:32,149 --> 00:14:36,980
our little program so in the first line

382
00:14:35,269 --> 00:14:39,049
you see like you have this etc shadow

383
00:14:36,980 --> 00:14:41,769
file and what it contains are like the

384
00:14:39,049 --> 00:14:44,929
UNIX users you have on your system with

385
00:14:41,769 --> 00:14:46,639
with the password hashes and as a normal

386
00:14:44,929 --> 00:14:48,439
user you cannot access this file because

387
00:14:46,639 --> 00:14:50,420
why you would get permission denied if

388
00:14:48,439 --> 00:14:52,339
you use root you can actually see the

389
00:14:50,420 --> 00:14:54,559
file and then you'll see that the first

390
00:14:52,339 --> 00:14:56,480
line is usually the password hash for

391
00:14:54,559 --> 00:14:58,639
the root account and what you see and

392
00:14:56,480 --> 00:15:01,309
the third line is basically or one of a

393
00:14:58,639 --> 00:15:04,579
proof of concepts where we actually use

394
00:15:01,309 --> 00:15:06,829
riddle to leak and the the third the

395
00:15:04,579 --> 00:15:10,368
password hash that is correspond to a

396
00:15:06,829 --> 00:15:12,649
two verticals so me trouble flight data

397
00:15:10,369 --> 00:15:14,869
load or riddle and what I'm going to

398
00:15:12,649 --> 00:15:16,429
show you today is that riddle is really

399
00:15:14,869 --> 00:15:19,490
a new class of speculative execution

400
00:15:16,429 --> 00:15:19,910
attacks that knows no boundaries so what

401
00:15:19,490 --> 00:15:21,529
do I mean

402
00:15:19,910 --> 00:15:23,420
knows no boundaries well privilege

403
00:15:21,529 --> 00:15:25,309
levels as we have discussed before so

404
00:15:23,420 --> 00:15:27,589
kernel virtual machine blah blah blah

405
00:15:25,309 --> 00:15:28,819
they're just a social construct so what

406
00:15:27,589 --> 00:15:31,100
I've shown you and with this proof of

407
00:15:28,819 --> 00:15:33,079
concept here says well you can just leak

408
00:15:31,100 --> 00:15:35,629
between hardware threats also known as

409
00:15:33,079 --> 00:15:36,430
Intel hyper-threading but the question

410
00:15:35,629 --> 00:15:38,170
is of course going

411
00:15:36,430 --> 00:15:40,060
because any of the other security domain

412
00:15:38,170 --> 00:15:42,670
so like in a typical CP you now have

413
00:15:40,060 --> 00:15:44,709
like on the kernel you have the user

414
00:15:42,670 --> 00:15:46,360
space you might have met many more fears

415
00:15:44,710 --> 00:15:48,370
you have hypervisor managing these VMs

416
00:15:46,360 --> 00:15:50,350
and you might have some secure enclaves

417
00:15:48,370 --> 00:15:53,800
that just don't trust anything in the

418
00:15:50,350 --> 00:15:55,690
system so the answer turns out to be yes

419
00:15:53,800 --> 00:15:58,149
we can so we can leak from the kernel

420
00:15:55,690 --> 00:16:01,839
we leak across VMs even from the

421
00:15:58,149 --> 00:16:03,459
hypervisor and also from SGX enclaves we

422
00:16:01,839 --> 00:16:05,830
actually leave across all the security

423
00:16:03,459 --> 00:16:07,390
domains so another question you might

424
00:16:05,830 --> 00:16:09,250
have done it's like okay nice you have

425
00:16:07,390 --> 00:16:10,480
this nice security domain to find

426
00:16:09,250 --> 00:16:12,070
whatever you can leak from a virtual

427
00:16:10,480 --> 00:16:14,830
machine but it may actually leak in the

428
00:16:12,070 --> 00:16:16,630
web browser turns out we can so we

429
00:16:14,830 --> 00:16:17,290
actually produce real all in Mozilla

430
00:16:16,630 --> 00:16:19,089
Firefox

431
00:16:17,290 --> 00:16:20,649
and what this means is that there's no

432
00:16:19,089 --> 00:16:23,320
need for any special CPU instructions

433
00:16:20,649 --> 00:16:25,899
and that you would typically find for

434
00:16:23,320 --> 00:16:28,470
these cache attacks so we leak across

435
00:16:25,899 --> 00:16:30,790
security domains and in the browser

436
00:16:28,470 --> 00:16:33,070
another social construct I want to talk

437
00:16:30,790 --> 00:16:36,490
to to you to buy today on memory

438
00:16:33,070 --> 00:16:38,200
addresses so we've seen these previous

439
00:16:36,490 --> 00:16:40,360
attack a bit and what they show is that

440
00:16:38,200 --> 00:16:44,110
we can speculatively leak from addresses

441
00:16:40,360 --> 00:16:45,730
and what this means is that what we what

442
00:16:44,110 --> 00:16:47,800
happens with the mitigation side for it

443
00:16:45,730 --> 00:16:50,110
is that we actually focus on these

444
00:16:47,800 --> 00:16:53,229
addresses so we try isolating or masking

445
00:16:50,110 --> 00:16:54,940
addresses to prevent people from using

446
00:16:53,230 --> 00:16:55,990
speculative execution to read these

447
00:16:54,940 --> 00:16:58,060
addresses because if they're not

448
00:16:55,990 --> 00:17:02,170
available well there's nothing you could

449
00:16:58,060 --> 00:17:04,208
do right so to give some examples here

450
00:17:02,170 --> 00:17:06,459
so specter accesses outbound addresses

451
00:17:04,209 --> 00:17:08,589
meltdown is able to lead kernel data

452
00:17:06,459 --> 00:17:11,319
from virtual addresses and foreshadow

453
00:17:08,589 --> 00:17:13,389
leaks data from physical addresses and

454
00:17:11,319 --> 00:17:15,159
what you see is that the mitigations

455
00:17:13,390 --> 00:17:16,870
what do they do well perspective they

456
00:17:15,160 --> 00:17:18,640
just try to mask their way index to

457
00:17:16,869 --> 00:17:20,770
limit the address range such that you

458
00:17:18,640 --> 00:17:22,900
cannot access all our out of bound

459
00:17:20,770 --> 00:17:24,369
addresses with Belden which is unmapped

460
00:17:22,900 --> 00:17:26,589
the curl addresses from the user space

461
00:17:24,369 --> 00:17:30,370
and at foreshadow we actually invalidate

462
00:17:26,589 --> 00:17:32,889
the physical addresses so previous

463
00:17:30,370 --> 00:17:35,409
attacks they exploit addressing and this

464
00:17:32,890 --> 00:17:37,620
means that our mitigation mostly focuses

465
00:17:35,410 --> 00:17:39,910
on isolating or masking these addresses

466
00:17:37,620 --> 00:17:42,760
riddle on the other hand does not depend

467
00:17:39,910 --> 00:17:44,890
on everything so what this means is that

468
00:17:42,760 --> 00:17:46,840
it bypasses all address based security

469
00:17:44,890 --> 00:17:48,880
checks that we have been placed now and

470
00:17:46,840 --> 00:17:50,169
this means that it also makes Riddle

471
00:17:48,880 --> 00:17:52,420
hard to mitigate

472
00:17:50,170 --> 00:17:55,060
so one of the questions is of course

473
00:17:52,420 --> 00:17:56,950
what CPUs does will affect well so what

474
00:17:55,060 --> 00:17:59,010
we did is we bought Intel and endi CPUs

475
00:17:56,950 --> 00:18:01,180
from almost every generation since 2008

476
00:17:59,010 --> 00:18:03,580
and we send the invoices through a

477
00:18:01,180 --> 00:18:05,980
professor Herbert boss was fortunately

478
00:18:03,580 --> 00:18:08,169
enough for him not in the room and we

479
00:18:05,980 --> 00:18:10,110
built this nice ikea rack with all the

480
00:18:08,170 --> 00:18:12,580
architectures and a nice cable mess here

481
00:18:10,110 --> 00:18:15,820
that we sometimes call the fire hazard

482
00:18:12,580 --> 00:18:17,530
in our building and what we found is

483
00:18:15,820 --> 00:18:20,980
that will actually works on all

484
00:18:17,530 --> 00:18:22,540
mainstream until CPUs since 2008 so here

485
00:18:20,980 --> 00:18:27,220
is the list of CPUs that we tested his

486
00:18:22,540 --> 00:18:29,110
own and then at some point we looked at

487
00:18:27,220 --> 00:18:31,720
the Intel website and they announced a

488
00:18:29,110 --> 00:18:34,479
new generation so what Intel announced

489
00:18:31,720 --> 00:18:36,670
here is coffee like refresh and what I

490
00:18:34,480 --> 00:18:38,230
promised is in silicon mitigations

491
00:18:36,670 --> 00:18:40,180
against meltdown unfortunate and this

492
00:18:38,230 --> 00:18:42,010
super interesting for us because we just

493
00:18:40,180 --> 00:18:44,020
found this new vulnerability so let's

494
00:18:42,010 --> 00:18:46,570
see how does it actually work on one of

495
00:18:44,020 --> 00:18:48,430
these so we decided like ok let's buy

496
00:18:46,570 --> 00:18:51,189
the core I nine nine thousand nine

497
00:18:48,430 --> 00:18:54,160
hundred K and we sent another invoice

498
00:18:51,190 --> 00:18:55,840
through professor Herbert's and we got

499
00:18:54,160 --> 00:18:59,440
it today basically after we submitted

500
00:18:55,840 --> 00:19:02,340
the paper to S&P Oakland and what we

501
00:18:59,440 --> 00:19:04,540
found is that the CPU is also burnable

502
00:19:02,340 --> 00:19:07,689
then we also tried to reproduce it on

503
00:19:04,540 --> 00:19:09,670
AMD well apparently AMD didn't make the

504
00:19:07,690 --> 00:19:11,380
same mistake here they made something

505
00:19:09,670 --> 00:19:14,200
they probably made some modern mistakes

506
00:19:11,380 --> 00:19:15,670
who knows but what we found us we test

507
00:19:14,200 --> 00:19:19,420
on three CPUs but couldn't reproduce

508
00:19:15,670 --> 00:19:21,720
Riddle and this is also the covered in a

509
00:19:19,420 --> 00:19:24,960
major corporate press release back then

510
00:19:21,720 --> 00:19:27,760
so Ritalin site it runs great on Intel

511
00:19:24,960 --> 00:19:30,250
and the question is where are we

512
00:19:27,760 --> 00:19:32,080
actually leaking for so remember the

513
00:19:30,250 --> 00:19:34,420
diagram at the beginning again very calm

514
00:19:32,080 --> 00:19:36,070
CPUs are very complex and what you see

515
00:19:34,420 --> 00:19:38,680
here is a part of the pipeline that's

516
00:19:36,070 --> 00:19:41,679
mostly responsible for like all the

517
00:19:38,680 --> 00:19:43,540
memory requests and we we've seen the

518
00:19:41,680 --> 00:19:45,670
previous attacks a DS either like cache

519
00:19:43,540 --> 00:19:48,070
the cache attack so they just focus on

520
00:19:45,670 --> 00:19:49,480
leaking from caches so the level 2 cache

521
00:19:48,070 --> 00:19:53,500
here and the level 1 DK here are

522
00:19:49,480 --> 00:19:55,030
highlighted and well they're easy to do

523
00:19:53,500 --> 00:19:57,910
because caches are generally well

524
00:19:55,030 --> 00:19:59,710
documented and well understood the

525
00:19:57,910 --> 00:20:02,950
problem we had is that real does not

526
00:19:59,710 --> 00:20:04,059
lead from caches at all so what else is

527
00:20:02,950 --> 00:20:06,279
start to leak from

528
00:20:04,059 --> 00:20:08,168
so there were these other internal CPU

529
00:20:06,279 --> 00:20:10,809
buffers so we got the line filled

530
00:20:08,169 --> 00:20:13,899
buffers at the top on the right you have

531
00:20:10,809 --> 00:20:14,979
the load ports and then and on the

532
00:20:13,899 --> 00:20:17,080
bottom you have the store and forward

533
00:20:14,979 --> 00:20:18,999
buffer for instance and there's more

534
00:20:17,080 --> 00:20:22,090
there's also the memory control so if

535
00:20:18,999 --> 00:20:24,969
you map and cache memory then you can

536
00:20:22,090 --> 00:20:27,658
also lead that so we find that we can

537
00:20:24,969 --> 00:20:31,299
leave from various internal CPU buffers

538
00:20:27,659 --> 00:20:33,309
and then what this shows is that we'll

539
00:20:31,299 --> 00:20:35,979
is actually a class of speculative

540
00:20:33,309 --> 00:20:37,839
execution attacks and that until we

541
00:20:35,979 --> 00:20:41,049
first you SMDs my cross-sectional data

542
00:20:37,839 --> 00:20:42,489
sampler and for this talk I'm just going

543
00:20:41,049 --> 00:20:45,609
to focus on one particular instance

544
00:20:42,489 --> 00:20:47,950
which are delightful buffers so well

545
00:20:45,609 --> 00:20:50,228
where do we find information about this

546
00:20:47,950 --> 00:20:52,389
thing so like like I said before caches

547
00:20:50,229 --> 00:20:54,759
are well understood and well documented

548
00:20:52,389 --> 00:20:56,228
and we first tried to get reading

549
00:20:54,759 --> 00:20:59,169
manuals to find more information about

550
00:20:56,229 --> 00:21:01,179
these internal buffers turns out there

551
00:20:59,169 --> 00:21:03,009
are some references to them but no

552
00:21:01,179 --> 00:21:04,719
further explanation served this is an

553
00:21:03,009 --> 00:21:06,190
excerpt from the Intel manual and this

554
00:21:04,719 --> 00:21:09,099
is one of the very few ones you'll find

555
00:21:06,190 --> 00:21:11,859
talking about the actual line fill

556
00:21:09,099 --> 00:21:14,499
buffers so no further explanation where

557
00:21:11,859 --> 00:21:16,299
which actually starts so that's why we

558
00:21:14,499 --> 00:21:18,669
started this reading patterns in stat

559
00:21:16,299 --> 00:21:21,460
and these are all the patterns we read

560
00:21:18,669 --> 00:21:24,389
for this paper and we survived so I'm

561
00:21:21,460 --> 00:21:26,440
here to talk a bit more about this and

562
00:21:24,389 --> 00:21:27,609
of course you're still wondering what

563
00:21:26,440 --> 00:21:30,279
are these like line field buffers

564
00:21:27,609 --> 00:21:32,859
exactly so these line belt buffers they

565
00:21:30,279 --> 00:21:35,190
sit very central here so we have to

566
00:21:32,859 --> 00:21:37,718
catch this and the execution unit and

567
00:21:35,190 --> 00:21:40,269
the line fold buffer is right here in

568
00:21:37,719 --> 00:21:42,429
the middle and it actually exists and to

569
00:21:40,269 --> 00:21:44,229
improve memory throughput so how does it

570
00:21:42,429 --> 00:21:46,389
do that well it has multiple

571
00:21:44,229 --> 00:21:48,429
responsibilities so it can does a

572
00:21:46,389 --> 00:21:50,199
synchronous memory request it does slow

573
00:21:48,429 --> 00:21:52,019
squashing where multiple loads are

574
00:21:50,200 --> 00:21:53,979
combined if it can be done

575
00:21:52,019 --> 00:21:55,899
optional white combining where it does

576
00:21:53,979 --> 00:21:57,309
the same for stores and also n cache

577
00:21:55,899 --> 00:21:58,539
memory where you don't want to use the

578
00:21:57,309 --> 00:22:01,239
cache but you have to keep the data

579
00:21:58,539 --> 00:22:03,429
somewhere and what we're going to focus

580
00:22:01,239 --> 00:22:06,070
on here is just the synchronous memory

581
00:22:03,429 --> 00:22:08,859
request so so let's say you're the CPU

582
00:22:06,070 --> 00:22:10,479
designer one issue you have is like okay

583
00:22:08,859 --> 00:22:11,859
what should i do on the catchment so one

584
00:22:10,479 --> 00:22:14,259
thing you can do is you can send out a

585
00:22:11,859 --> 00:22:15,639
memory request you can wait for the d1

586
00:22:14,259 --> 00:22:17,400
to come back but it takes like two

587
00:22:15,639 --> 00:22:18,570
hundred three hundred cycles and

588
00:22:17,400 --> 00:22:20,190
this means you're basically blocking

589
00:22:18,570 --> 00:22:21,960
other loads and source here you're

590
00:22:20,190 --> 00:22:24,720
preventing the cpu from receiving

591
00:22:21,960 --> 00:22:27,210
execution so what's the solution

592
00:22:24,720 --> 00:22:28,770
well you introduce a lav you keep track

593
00:22:27,210 --> 00:22:30,870
of the address so you send out a memory

594
00:22:28,770 --> 00:22:33,120
request you allocate an entry in your L

595
00:22:30,870 --> 00:22:35,580
of V you store the address in the line

596
00:22:33,120 --> 00:22:38,669
for buffers and then in the meanwhile

597
00:22:35,580 --> 00:22:40,949
well this DRAM request is still and

598
00:22:38,670 --> 00:22:42,300
being processed you can do all the work

599
00:22:40,950 --> 00:22:44,970
so you can serve the auto loads and

600
00:22:42,300 --> 00:22:46,770
source in your pipeline even from the

601
00:22:44,970 --> 00:22:48,540
cache if you have that available in the

602
00:22:46,770 --> 00:22:50,160
cache and then at some point your

603
00:22:48,540 --> 00:22:53,100
pending memory requests eventually

604
00:22:50,160 --> 00:22:55,050
completes what the problem really is

605
00:22:53,100 --> 00:22:59,270
here is to allocate all of the entry

606
00:22:55,050 --> 00:23:02,070
part so what's the problem here is that

607
00:22:59,270 --> 00:23:03,960
allocate I love the entry it means that

608
00:23:02,070 --> 00:23:06,060
if you don't zero it out it may still

609
00:23:03,960 --> 00:23:07,440
contain data from a previous load and

610
00:23:06,060 --> 00:23:11,760
this is exactly the part that will

611
00:23:07,440 --> 00:23:13,830
exports so we so in our paper we have

612
00:23:11,760 --> 00:23:15,629
some experiments that show this and the

613
00:23:13,830 --> 00:23:18,480
conclusion from these experiments what

614
00:23:15,630 --> 00:23:19,950
we found is that riddle and this I will

615
00:23:18,480 --> 00:23:23,820
instance actually leaks from the line

616
00:23:19,950 --> 00:23:25,860
for purpose so now this is going to talk

617
00:23:23,820 --> 00:23:27,629
to you more about how to do higher level

618
00:23:25,860 --> 00:23:33,689
stuff so how to actually Mart a rittle

619
00:23:27,630 --> 00:23:36,030
attack thank you so I hope you have some

620
00:23:33,690 --> 00:23:38,520
idea already uh-oh this is not great

621
00:23:36,030 --> 00:23:39,990
you can leak the shadow file it's really

622
00:23:38,520 --> 00:23:42,330
not great a bunch of you may have

623
00:23:39,990 --> 00:23:43,620
already understood this because you've

624
00:23:42,330 --> 00:23:45,360
got these micro code updates or the

625
00:23:43,620 --> 00:23:49,110
operating system patches and you notice

626
00:23:45,360 --> 00:23:50,820
the performance here but you know what

627
00:23:49,110 --> 00:23:53,550
are we actually doing here you know I

628
00:23:50,820 --> 00:23:54,929
mean it is attacks realistic so to do

629
00:23:53,550 --> 00:23:57,210
these attacks you know what we're doing

630
00:23:54,930 --> 00:23:58,530
is we're leaking in-flight data so what

631
00:23:57,210 --> 00:24:00,630
do we want to do what we want some kind

632
00:23:58,530 --> 00:24:01,830
of sensitive data right you know and

633
00:24:00,630 --> 00:24:03,330
we're not gonna start digging into the

634
00:24:01,830 --> 00:24:05,610
corners much fun as soon as that would

635
00:24:03,330 --> 00:24:07,590
be I'd much rather be doing that so

636
00:24:05,610 --> 00:24:09,750
we're gonna start by thinking okay you

637
00:24:07,590 --> 00:24:10,679
have this local attacker threat model so

638
00:24:09,750 --> 00:24:12,480
you have some code

639
00:24:10,680 --> 00:24:13,920
you know maybe budding in a web browser

640
00:24:12,480 --> 00:24:15,600
but we're gonna say okay someone's

641
00:24:13,920 --> 00:24:18,000
foolishly giving you a log into their

642
00:24:15,600 --> 00:24:20,040
p.m. to their home computer or you have

643
00:24:18,000 --> 00:24:21,990
some kind of exploit what can we do if

644
00:24:20,040 --> 00:24:25,379
we really get to run code locally as a

645
00:24:21,990 --> 00:24:27,030
normal user so we're gonna try to grab

646
00:24:25,380 --> 00:24:28,590
the contents from earlier of this

647
00:24:27,030 --> 00:24:30,668
Shadowfall with all of the password

648
00:24:28,590 --> 00:24:32,289
hashes we want that root password hash

649
00:24:30,669 --> 00:24:33,639
do you actually go about that it's like

650
00:24:32,289 --> 00:24:36,220
how do you actually get this into memory

651
00:24:33,639 --> 00:24:38,529
well if you want ask trace on password

652
00:24:36,220 --> 00:24:40,119
you just run the password utility you

653
00:24:38,529 --> 00:24:42,279
discover that even before it asks you

654
00:24:40,119 --> 00:24:43,928
for a password or it needs it it opens

655
00:24:42,279 --> 00:24:46,679
the shadow file and starts reading from

656
00:24:43,929 --> 00:24:49,090
it which is great for our purposes so

657
00:24:46,679 --> 00:24:50,440
we're gonna do a confused deputy attack

658
00:24:49,090 --> 00:24:52,809
we should say we're gonna use the

659
00:24:50,440 --> 00:24:55,379
password utility to read shadow for us

660
00:24:52,809 --> 00:24:58,389
you know thanks so much first set you ID

661
00:24:55,379 --> 00:25:00,309
password opens this file so what do we

662
00:24:58,389 --> 00:25:02,289
need to do you know what can we somehow

663
00:25:00,309 --> 00:25:04,359
get this to do it on another hyper Fred

664
00:25:02,289 --> 00:25:06,369
so we can grab stuff from its line fill

665
00:25:04,359 --> 00:25:08,320
buffer and it turns out yep we can just

666
00:25:06,369 --> 00:25:10,238
set the process affinity we just run a

667
00:25:08,320 --> 00:25:12,908
shell script with tasks set and we can

668
00:25:10,239 --> 00:25:14,230
put it to any court we want and what do

669
00:25:12,909 --> 00:25:16,090
we put in the script we literally just

670
00:25:14,230 --> 00:25:17,889
do this you know while true one pass

671
00:25:16,090 --> 00:25:19,889
well it's a shell script you know this

672
00:25:17,889 --> 00:25:22,090
is not the most super efficient approach

673
00:25:19,889 --> 00:25:24,248
you know you could probably optimize

674
00:25:22,090 --> 00:25:25,720
this run and see something the calls it

675
00:25:24,249 --> 00:25:26,889
repeatedly tries to make sure there's a

676
00:25:25,720 --> 00:25:30,399
bunch of them running but we don't care

677
00:25:26,889 --> 00:25:33,459
so we have three challenges we're gonna

678
00:25:30,399 --> 00:25:35,320
look into here and the first one well we

679
00:25:33,460 --> 00:25:37,119
have the password utility shadow is

680
00:25:35,320 --> 00:25:39,309
right there in flight that's absolutely

681
00:25:37,119 --> 00:25:40,238
great so the next thing is leaking data

682
00:25:39,309 --> 00:25:41,799
it's like wait a minute

683
00:25:40,239 --> 00:25:42,999
you know how does this little thing

684
00:25:41,799 --> 00:25:43,629
actually work you know what does this

685
00:25:42,999 --> 00:25:45,700
look like

686
00:25:43,629 --> 00:25:48,039
well I hopefully it's a bit for video

687
00:25:45,700 --> 00:25:50,259
now we have this we're gonna do this

688
00:25:48,039 --> 00:25:51,809
flush we're gonna have a riddle step and

689
00:25:50,259 --> 00:25:53,710
then we're going to do the reload so

690
00:25:51,809 --> 00:25:55,059
hopefully you know what the flush looks

691
00:25:53,710 --> 00:25:57,999
like we're just gonna get rid of all the

692
00:25:55,059 --> 00:25:59,499
cache entries for our probe array then

693
00:25:57,999 --> 00:26:01,480
we have this riddle step and what we're

694
00:25:59,499 --> 00:26:03,070
gonna do a bit magic we're gonna just

695
00:26:01,480 --> 00:26:04,179
read from a null pointer we're just

696
00:26:03,070 --> 00:26:05,379
going to be from an invalid pointer

697
00:26:04,179 --> 00:26:07,269
there were actually a whole bunch of

698
00:26:05,379 --> 00:26:09,908
ways to do this you just have to confuse

699
00:26:07,269 --> 00:26:11,769
the CPU in a way where it tries to do a

700
00:26:09,909 --> 00:26:13,659
load that it can't satisfy us for the

701
00:26:11,769 --> 00:26:17,039
cache and then something goes wrong you

702
00:26:13,659 --> 00:26:19,419
have this exception thing going on you

703
00:26:17,039 --> 00:26:20,739
could also do it with demand page Inc

704
00:26:19,419 --> 00:26:22,779
which we'll get back to a little bit

705
00:26:20,739 --> 00:26:25,230
later so this is actually the normal

706
00:26:22,779 --> 00:26:27,489
kind of thing which happens a lot and

707
00:26:25,230 --> 00:26:31,090
we're just gonna do the access to the

708
00:26:27,489 --> 00:26:32,409
pope array as an index and then we're

709
00:26:31,090 --> 00:26:34,539
just gonna do this we'd load step so

710
00:26:32,409 --> 00:26:38,139
it's like yeah slow slow slow but it's

711
00:26:34,539 --> 00:26:40,690
fast so this is byte three it's like oh

712
00:26:38,139 --> 00:26:44,409
wait a minute quite free what is that an

713
00:26:40,690 --> 00:26:45,880
ASCII nope so the problem is yeah weird

714
00:26:44,410 --> 00:26:48,130
it's like drinking from a firehose you

715
00:26:45,880 --> 00:26:49,810
get everything everything is going

716
00:26:48,130 --> 00:26:51,640
through these internal buffers these

717
00:26:49,810 --> 00:26:53,620
line filled buffers these load supports

718
00:26:51,640 --> 00:26:55,480
these store buffers you get absolutely

719
00:26:53,620 --> 00:26:56,649
everything there's way too much you know

720
00:26:55,480 --> 00:26:58,840
by the time we've actually finished

721
00:26:56,650 --> 00:27:00,580
running this whole loop there's been

722
00:26:58,840 --> 00:27:04,870
huge amounts of other data that have

723
00:27:00,580 --> 00:27:06,550
gone through these buffers but the great

724
00:27:04,870 --> 00:27:08,500
thing is yeah we get whatever data is

725
00:27:06,550 --> 00:27:10,090
reapplied but as long as we can do it

726
00:27:08,500 --> 00:27:11,830
repeatedly like running the pass you

727
00:27:10,090 --> 00:27:13,209
either say that is he in a loop all of

728
00:27:11,830 --> 00:27:15,340
that data is going to come past at some

729
00:27:13,210 --> 00:27:17,320
point the question is you know how do we

730
00:27:15,340 --> 00:27:18,760
get the right data we get a free that's

731
00:27:17,320 --> 00:27:19,689
definitely not a fan of ASCII character

732
00:27:18,760 --> 00:27:22,390
that's not the kind of thing we're

733
00:27:19,690 --> 00:27:24,190
expecting to see so what can we do so

734
00:27:22,390 --> 00:27:26,860
there are two things you can do so one

735
00:27:24,190 --> 00:27:28,600
of which is synchronizing so you can do

736
00:27:26,860 --> 00:27:30,459
all these fancy cache attacks to say

737
00:27:28,600 --> 00:27:32,679
okay we want this code to run really

738
00:27:30,460 --> 00:27:34,690
slowly in the passive UTC when it's

739
00:27:32,680 --> 00:27:37,390
reading this file so we're going to do

740
00:27:34,690 --> 00:27:38,620
we're going to evict the code of the

741
00:27:37,390 --> 00:27:40,810
passive alerted is he from the cache

742
00:27:38,620 --> 00:27:43,540
okay this is way too complicated already

743
00:27:40,810 --> 00:27:45,070
we're lazy nowadays there's actually a

744
00:27:43,540 --> 00:27:47,440
great library to do this but at the time

745
00:27:45,070 --> 00:27:50,950
there wasn't so instead we're just gonna

746
00:27:47,440 --> 00:27:53,050
say okay can we do a hack so instead

747
00:27:50,950 --> 00:27:54,640
post-processing so okay we just repeat

748
00:27:53,050 --> 00:27:56,919
measurements a lot can we kind of

749
00:27:54,640 --> 00:27:58,390
somehow take a lot of measurements and

750
00:27:56,920 --> 00:28:00,010
just stitch together the wardens we want

751
00:27:58,390 --> 00:28:04,810
because that would be absolutely great

752
00:28:00,010 --> 00:28:06,490
and you know the third option apparently

753
00:28:04,810 --> 00:28:08,950
is to do kind of advanced statistical

754
00:28:06,490 --> 00:28:10,780
analysis using machine learning and this

755
00:28:08,950 --> 00:28:12,580
was Intel sir perspective what they were

756
00:28:10,780 --> 00:28:14,350
telling all the vendors if you look at

757
00:28:12,580 --> 00:28:16,090
the official press releases you need to

758
00:28:14,350 --> 00:28:16,810
do all these advanced statistics turns

759
00:28:16,090 --> 00:28:18,850
out you don't need the advanced

760
00:28:16,810 --> 00:28:21,250
statistics how are we going to actually

761
00:28:18,850 --> 00:28:22,929
do the filter the filtering well we want

762
00:28:21,250 --> 00:28:25,210
to leak for the shadow file and we know

763
00:28:22,930 --> 00:28:26,770
the first line is for boot its cache

764
00:28:25,210 --> 00:28:29,140
lined which is absolutely perfect and

765
00:28:26,770 --> 00:28:31,210
actually it starts with we call them so

766
00:28:29,140 --> 00:28:33,070
we're just gonna say okay every time the

767
00:28:31,210 --> 00:28:35,470
light pool buffer comes by if it starts

768
00:28:33,070 --> 00:28:37,570
with recall on that sounds exactly what

769
00:28:35,470 --> 00:28:39,520
we want and you can do this once we

770
00:28:37,570 --> 00:28:42,040
learn the next byte so we're grabbing

771
00:28:39,520 --> 00:28:43,510
byte by byte in this flush reload every

772
00:28:42,040 --> 00:28:45,280
time we learn a new byte and that gives

773
00:28:43,510 --> 00:28:48,129
us more and more of a prefix to match on

774
00:28:45,280 --> 00:28:50,470
so we have this recall on so let's look

775
00:28:48,130 --> 00:28:52,780
at the life fill buffer it says HTTP

776
00:28:50,470 --> 00:28:54,910
nope no match it says we call on

777
00:28:52,780 --> 00:28:57,820
something oh we have another bite we're

778
00:28:54,910 --> 00:28:58,059
just gonna do one by the time because I

779
00:28:57,820 --> 00:28:59,710
mean

780
00:28:58,059 --> 00:29:01,899
this data is coming by again and again

781
00:28:59,710 --> 00:29:04,809
and again and we want to be fast and

782
00:29:01,899 --> 00:29:06,609
efficient we'd be no match you can

783
00:29:04,809 --> 00:29:08,529
another bite another bite another bite

784
00:29:06,609 --> 00:29:10,418
so you and you build this stuff up so it

785
00:29:08,529 --> 00:29:13,570
turns out actually this problem is

786
00:29:10,419 --> 00:29:15,309
really easily solvable and it turns out

787
00:29:13,570 --> 00:29:17,080
that you can leak the vid house with

788
00:29:15,309 --> 00:29:20,139
hash from an oompa the juicer you know

789
00:29:17,080 --> 00:29:23,830
paper we wrote 24 hours to do this we

790
00:29:20,139 --> 00:29:25,418
were way over complicating this we were

791
00:29:23,830 --> 00:29:27,639
too lazy to reburn the experiment we

792
00:29:25,419 --> 00:29:29,649
gave it to a master student recently and

793
00:29:27,639 --> 00:29:32,439
it's like yeah it takes like 10 seconds

794
00:29:29,649 --> 00:29:34,539
in my experiment turns out yep you can

795
00:29:32,440 --> 00:29:38,019
leak this in 10 seconds you could

796
00:29:34,539 --> 00:29:39,669
probably get even faster but okay let's

797
00:29:38,019 --> 00:29:42,639
try extending this a bit what can we do

798
00:29:39,669 --> 00:29:44,080
with this well you the local attacker

799
00:29:42,639 --> 00:29:45,519
model is not very realistic if you're

800
00:29:44,080 --> 00:29:47,468
running code on my machine I put in have

801
00:29:45,519 --> 00:29:48,909
bigger problems but this is this whole

802
00:29:47,469 --> 00:29:51,879
cloud thing which I mentioned in the

803
00:29:48,909 --> 00:29:53,229
first place and it turns out that ok the

804
00:29:51,879 --> 00:29:55,178
big cloud providers certainly at this

805
00:29:53,229 --> 00:29:56,349
point hyper-threading you're not gonna

806
00:29:55,179 --> 00:29:58,059
get shared hyper threads

807
00:29:56,349 --> 00:29:59,918
unless you don't want to pay that much

808
00:29:58,059 --> 00:30:02,999
if you want to cheap you know to run

809
00:29:59,919 --> 00:30:05,109
stuff cheaply then you still get these

810
00:30:02,999 --> 00:30:06,580
these shared hyper threads if you were

811
00:30:05,109 --> 00:30:08,070
to achieve clarify that they still do

812
00:30:06,580 --> 00:30:10,418
this

813
00:30:08,070 --> 00:30:11,799
so the thread model is going to be we

814
00:30:10,419 --> 00:30:14,529
have a victim VM in the cloud and

815
00:30:11,799 --> 00:30:18,009
somehow we co-locate on the same server

816
00:30:14,529 --> 00:30:19,899
an attacker vm and it doesn't always

817
00:30:18,009 --> 00:30:21,219
have to be on the opposite hyper thread

818
00:30:19,899 --> 00:30:22,959
as long as it's sometimes on the

819
00:30:21,219 --> 00:30:26,469
opposite hyper friend because all we

820
00:30:22,960 --> 00:30:28,210
actually want is for it for this data to

821
00:30:26,469 --> 00:30:31,299
sometimes be the lipo buffer I mean we

822
00:30:28,210 --> 00:30:32,889
can be patient we have to make sure it's

823
00:30:31,299 --> 00:30:34,389
- ok located sometimes as I was saying

824
00:30:32,889 --> 00:30:35,649
so we get these shared line fill buffers

825
00:30:34,389 --> 00:30:37,869
and then what do we do

826
00:30:35,649 --> 00:30:39,639
well the 15 free end is running an SSH

827
00:30:37,869 --> 00:30:41,738
server this turns out to have the same

828
00:30:39,639 --> 00:30:43,238
problem you can add to SSH and what does

829
00:30:41,739 --> 00:30:44,499
it do it optimistic says well this

830
00:30:43,239 --> 00:30:47,589
process is pretty good and login with a

831
00:30:44,499 --> 00:30:49,839
password so let's read the shadow file

832
00:30:47,589 --> 00:30:52,299
how do we get the data in flight we just

833
00:30:49,839 --> 00:30:54,549
run an ssh client and connect a lot in a

834
00:30:52,299 --> 00:30:55,779
loop exactly the same trick so again we

835
00:30:54,549 --> 00:30:57,580
were doing this with a script that just

836
00:30:55,779 --> 00:30:59,289
actually associated it to the server

837
00:30:57,580 --> 00:31:00,718
kills the client process because we

838
00:30:59,289 --> 00:31:04,149
don't actually want to try logging in

839
00:31:00,719 --> 00:31:06,070
and that SSH sure is gonna go put this

840
00:31:04,149 --> 00:31:08,349
data in the light-filled buffer it then

841
00:31:06,070 --> 00:31:10,359
it's in flight and we leak it with the

842
00:31:08,349 --> 00:31:11,500
same attack we were doing before I know

843
00:31:10,359 --> 00:31:14,830
we have your shadow file

844
00:31:11,500 --> 00:31:16,630
and this in practice it's fiddly right

845
00:31:14,830 --> 00:31:19,629
it's just I have this feeling if I give

846
00:31:16,630 --> 00:31:22,179
this to enough master students this will

847
00:31:19,630 --> 00:31:25,240
just magically happen in a second but

848
00:31:22,179 --> 00:31:27,970
you know I'm kind of hoping you don't

849
00:31:25,240 --> 00:31:29,169
allow remote logins using root so the

850
00:31:27,970 --> 00:31:30,669
root password may not be useful

851
00:31:29,169 --> 00:31:32,530
hopefully you don't even have a root

852
00:31:30,669 --> 00:31:34,539
password but there's probably plenty of

853
00:31:32,530 --> 00:31:36,970
other confidential data on your surface

854
00:31:34,539 --> 00:31:40,120
like your login keys that you probably

855
00:31:36,970 --> 00:31:42,370
don't want to have in my hands okay but

856
00:31:40,120 --> 00:31:43,658
fine what else can we do you know do we

857
00:31:42,370 --> 00:31:46,449
have more cool tricks it turns out yes

858
00:31:43,659 --> 00:31:47,710
we have more cool checks so this we

859
00:31:46,450 --> 00:31:49,720
discussed already there's this thing

860
00:31:47,710 --> 00:31:51,820
called spectre and Spectre it basically

861
00:31:49,720 --> 00:31:54,280
just relies on tricking this branch

862
00:31:51,820 --> 00:31:55,629
predictor just can we kind of combine

863
00:31:54,280 --> 00:31:57,158
these techniques somehow can we do

864
00:31:55,630 --> 00:31:59,799
something clever so one of our

865
00:31:57,159 --> 00:32:02,230
co-authors discovered yes you can so we

866
00:31:59,799 --> 00:32:03,820
combined riddle and Specter what we're

867
00:32:02,230 --> 00:32:05,590
going to do we're gonna somehow change

868
00:32:03,820 --> 00:32:08,590
this train the branch predictor to trust

869
00:32:05,590 --> 00:32:10,389
us to take the right path and then we're

870
00:32:08,590 --> 00:32:12,280
gonna surprise Oh

871
00:32:10,390 --> 00:32:14,530
surprise the branch predictor I want to

872
00:32:12,280 --> 00:32:15,879
say an unexpected branch but an

873
00:32:14,530 --> 00:32:18,070
unexpected pointer you'll see why in a

874
00:32:15,880 --> 00:32:19,090
second what were actually gonna do is

875
00:32:18,070 --> 00:32:21,428
we're going to start calling system

876
00:32:19,090 --> 00:32:23,230
calls and we're going to call a system

877
00:32:21,429 --> 00:32:26,200
call that loads some memory from user

878
00:32:23,230 --> 00:32:27,940
space and it kind of optimistically

879
00:32:26,200 --> 00:32:30,039
assumes that yes the pointer you

880
00:32:27,940 --> 00:32:31,659
provided to me is a legitimate warden

881
00:32:30,039 --> 00:32:33,129
who you use a space program that you're

882
00:32:31,659 --> 00:32:34,630
allowed to read and then we're going to

883
00:32:33,130 --> 00:32:36,400
say haha we're gonna give you an

884
00:32:34,630 --> 00:32:38,470
arbitrary pointer to some random piece

885
00:32:36,400 --> 00:32:39,669
of kernel memory and the branch

886
00:32:38,470 --> 00:32:42,850
predictor will just say yeah that's

887
00:32:39,669 --> 00:32:44,650
probably good and it will load it this

888
00:32:42,850 --> 00:32:46,000
isn't mitigated by Specter defenses

889
00:32:44,650 --> 00:32:47,980
because all you're doing is loading

890
00:32:46,000 --> 00:32:49,780
memory you're not indexing in every or

891
00:32:47,980 --> 00:32:52,299
anything but it does end up in the line

892
00:32:49,780 --> 00:32:54,100
fill buffers and so Widow lets us

893
00:32:52,299 --> 00:32:57,129
actually leak this value so the way it

894
00:32:54,100 --> 00:32:59,350
works in practice is in the kernel you

895
00:32:57,130 --> 00:33:01,330
have this in the Linux kernel I should

896
00:32:59,350 --> 00:33:03,879
say in this case you have a function

897
00:33:01,330 --> 00:33:05,439
called copy from user and it accesses an

898
00:33:03,880 --> 00:33:06,700
opportunity user supply pointer we don't

899
00:33:05,440 --> 00:33:09,280
care what it does with it all we want to

900
00:33:06,700 --> 00:33:11,860
do is make sure it gets read we repeat

901
00:33:09,280 --> 00:33:13,450
we call a fast system call to train the

902
00:33:11,860 --> 00:33:14,830
branch predictor you can trust us this

903
00:33:13,450 --> 00:33:16,990
is always going to be valid we're never

904
00:33:14,830 --> 00:33:18,250
going to take the error case and then we

905
00:33:16,990 --> 00:33:20,620
give it a chronic points we want to leak

906
00:33:18,250 --> 00:33:22,090
which can be actually a pointer into the

907
00:33:20,620 --> 00:33:24,219
face map so we can grab arbitrary

908
00:33:22,090 --> 00:33:25,209
physical memory and it gets actually

909
00:33:24,220 --> 00:33:28,690
expensive to despair

910
00:33:25,210 --> 00:33:31,659
the enemy League and in practice it

911
00:33:28,690 --> 00:33:33,940
looks like this just we train it we give

912
00:33:31,659 --> 00:33:36,640
ok let's call the system call with a

913
00:33:33,940 --> 00:33:38,169
valid pointer and it happily says okay

914
00:33:36,640 --> 00:33:41,320
we're gonna take this branch it's gonna

915
00:33:38,169 --> 00:33:43,720
be fine and then we say okay you know

916
00:33:41,320 --> 00:33:45,250
call it with a kernel pointer and it

917
00:33:43,720 --> 00:33:48,419
says well it's probably gonna be fine

918
00:33:45,250 --> 00:33:50,860
let's load it into the lipo buffer so

919
00:33:48,419 --> 00:33:52,659
there are medications against this they

920
00:33:50,860 --> 00:33:57,039
are in place they're even in place on

921
00:33:52,659 --> 00:34:00,059
all operating systems at nowadays but it

922
00:33:57,039 --> 00:34:02,590
gives an idea of the real risks

923
00:34:00,059 --> 00:34:05,200
depending on your CPU to do the right

924
00:34:02,590 --> 00:34:06,520
thing here every one port okay Spectre

925
00:34:05,200 --> 00:34:08,440
we patched all the stuff that's

926
00:34:06,520 --> 00:34:10,179
important you don't have any every index

927
00:34:08,440 --> 00:34:11,560
is left but it turns out no you just

928
00:34:10,179 --> 00:34:15,369
can't touch memory if you want to be

929
00:34:11,560 --> 00:34:17,109
safe but so we still need a local

930
00:34:15,369 --> 00:34:20,740
account on the target for these kind of

931
00:34:17,109 --> 00:34:23,020
tricks so what else can we do can we get

932
00:34:20,739 --> 00:34:25,118
you know all of your personal details as

933
00:34:23,020 --> 00:34:26,469
we're discussing earlier can we do is

934
00:34:25,119 --> 00:34:29,230
from the browser it was a real question

935
00:34:26,469 --> 00:34:30,848
for a long time actually because we kind

936
00:34:29,230 --> 00:34:33,310
of depend on several things in our

937
00:34:30,849 --> 00:34:35,290
exploits so ideally we have these

938
00:34:33,310 --> 00:34:37,690
transactions or some of a speculation

939
00:34:35,290 --> 00:34:39,820
mechanism such as tricking the branch

940
00:34:37,690 --> 00:34:42,280
predictor using return address patching

941
00:34:39,820 --> 00:34:44,169
and you can't do that in JavaScript it's

942
00:34:42,280 --> 00:34:45,639
super annoying and you can't use

943
00:34:44,168 --> 00:34:49,239
impacted pointers from JavaScript either

944
00:34:45,639 --> 00:34:51,339
so what is this and it turns out you are

945
00:34:49,239 --> 00:34:53,080
so conscious co-ceo flush which is the

946
00:34:51,339 --> 00:34:55,359
efficient way to flush cash lines out of

947
00:34:53,080 --> 00:34:57,040
the cache because well the browser

948
00:34:55,359 --> 00:34:59,250
vendors realize actually a long time ago

949
00:34:57,040 --> 00:35:02,200
this is a bad idea so what we can lead

950
00:34:59,250 --> 00:35:04,210
well we have no CL plush but we can just

951
00:35:02,200 --> 00:35:06,339
construct eviction sets and manually

952
00:35:04,210 --> 00:35:08,170
just pushed off out of the cache because

953
00:35:06,339 --> 00:35:10,869
there's no more space left and we don't

954
00:35:08,170 --> 00:35:12,250
have tsx or invalid pointers but it

955
00:35:10,869 --> 00:35:14,859
turns out if you just allocate a huge

956
00:35:12,250 --> 00:35:16,000
amount of memory then it does it the

957
00:35:14,859 --> 00:35:17,230
operating system assumes you're not

958
00:35:16,000 --> 00:35:20,050
actually gonna use all of that memory

959
00:35:17,230 --> 00:35:22,630
it's for example I think in a chrome

960
00:35:20,050 --> 00:35:24,970
sandbox you still get several gigabytes

961
00:35:22,630 --> 00:35:27,700
eight gigabytes or so of memory you just

962
00:35:24,970 --> 00:35:29,200
allocate all of this and then it doesn't

963
00:35:27,700 --> 00:35:31,029
actually generate page tables so

964
00:35:29,200 --> 00:35:33,040
actually every time you access this

965
00:35:31,030 --> 00:35:34,990
memory you get a page fault and the

966
00:35:33,040 --> 00:35:37,359
operating system goes out that's an okay

967
00:35:34,990 --> 00:35:38,859
page fault this is not a problem we're

968
00:35:37,359 --> 00:35:40,630
gonna give you some backing memory

969
00:35:38,859 --> 00:35:41,680
but it turns out that from the pipeline

970
00:35:40,630 --> 00:35:43,450
it's a point of view it's like no no

971
00:35:41,680 --> 00:35:45,969
this is a fault this is just as bad as a

972
00:35:43,450 --> 00:35:47,229
Seguin no no pointer we're gonna abort

973
00:35:45,969 --> 00:35:49,509
we're not gonna give you the old data

974
00:35:47,229 --> 00:35:51,218
and it fills it for the line filler for

975
00:35:49,509 --> 00:35:53,680
a speculatively it's exactly what we

976
00:35:51,219 --> 00:35:56,190
want it's absolutely perfect so we wrote

977
00:35:53,680 --> 00:35:58,390
some code and looks like this it's just

978
00:35:56,190 --> 00:35:59,769
you might think okay but we're talking

979
00:35:58,390 --> 00:36:02,170
about web browsers right this doesn't

980
00:35:59,769 --> 00:36:04,299
look like much like JavaScript well the

981
00:36:02,170 --> 00:36:06,729
great news is the browser vendors have

982
00:36:04,299 --> 00:36:08,079
this thing called web assembly and it's

983
00:36:06,729 --> 00:36:09,879
also we don't even have to learn how to

984
00:36:08,079 --> 00:36:11,950
do this in JavaScript it turns out we

985
00:36:09,880 --> 00:36:15,459
can just take the C code generate it in

986
00:36:11,950 --> 00:36:16,808
whoever assembly it's perfect so what

987
00:36:15,459 --> 00:36:18,910
does it look like I wish I had a

988
00:36:16,809 --> 00:36:22,599
beautiful life demo to show you we don't

989
00:36:18,910 --> 00:36:24,160
have it working again but I can show you

990
00:36:22,599 --> 00:36:27,519
the point command line version I can

991
00:36:24,160 --> 00:36:30,549
even show it live so we actually do this

992
00:36:27,519 --> 00:36:33,669
using the the Firefox JavaScript shell

993
00:36:30,549 --> 00:36:35,109
and it literally just leaks you know

994
00:36:33,670 --> 00:36:38,619
it's not the fastest thing in the world

995
00:36:35,109 --> 00:36:39,940
but we can show you a toy example so

996
00:36:38,619 --> 00:36:42,609
what we're doing here is just a warm

997
00:36:39,940 --> 00:36:44,410
thread we have our own program that was

998
00:36:42,609 --> 00:36:46,299
a mess that displays a message and on

999
00:36:44,410 --> 00:36:50,170
the other thread we leaked from

1000
00:36:46,299 --> 00:36:51,729
JavaScript honestly in the real world

1001
00:36:50,170 --> 00:36:53,380
it's not very clear if you can do

1002
00:36:51,729 --> 00:36:56,529
anything super useful with the browser

1003
00:36:53,380 --> 00:36:57,999
trick if you can run SSH repeatedly then

1004
00:36:56,529 --> 00:36:59,680
yes you can do something but you

1005
00:36:57,999 --> 00:37:01,749
probably don't have SSH open on your

1006
00:36:59,680 --> 00:37:03,879
machine we tried some games with cookies

1007
00:37:01,749 --> 00:37:06,038
but it turns out we only have so much

1008
00:37:03,880 --> 00:37:08,289
patience so I'm still hoping that

1009
00:37:06,039 --> 00:37:10,449
someone will go and actually give this a

1010
00:37:08,289 --> 00:37:12,670
go and see is this does this really have

1011
00:37:10,449 --> 00:37:15,099
serious security impact but it was kind

1012
00:37:12,670 --> 00:37:17,199
of fun to do there's a bunch more

1013
00:37:15,099 --> 00:37:19,359
examples in our paper you can leak from

1014
00:37:17,199 --> 00:37:21,549
load ports which is stay old data in the

1015
00:37:19,359 --> 00:37:23,979
pipeline which actually doesn't even

1016
00:37:21,549 --> 00:37:25,930
have to be in any of these buffers you

1017
00:37:23,979 --> 00:37:28,149
can leak from these SGX registers which

1018
00:37:25,930 --> 00:37:30,160
is Intel's kind of secure Enclave system

1019
00:37:28,150 --> 00:37:33,009
but this is already honestly completely

1020
00:37:30,160 --> 00:37:34,479
broken and you can leak intern or CPU

1021
00:37:33,009 --> 00:37:36,069
data because the great thing about being

1022
00:37:34,479 --> 00:37:37,899
able to leak from these buffers is

1023
00:37:36,069 --> 00:37:39,969
unique anything the CPU pipeline is

1024
00:37:37,900 --> 00:37:42,069
reading and it leaked it reads page

1025
00:37:39,969 --> 00:37:44,890
tables it reads virtual machine status

1026
00:37:42,069 --> 00:37:48,279
pages it reads all kinds of stuff so you

1027
00:37:44,890 --> 00:37:49,479
can see everything going by but okay

1028
00:37:48,279 --> 00:37:50,769
there are these mitigation so you all

1029
00:37:49,479 --> 00:37:52,779
have these mitigations on your computers

1030
00:37:50,769 --> 00:37:55,660
now you know you're all safe

1031
00:37:52,780 --> 00:37:57,790
well so before me before these

1032
00:37:55,660 --> 00:37:58,930
disclosure we had three mechanisms one

1033
00:37:57,790 --> 00:38:00,910
of which is you can just stop

1034
00:37:58,930 --> 00:38:03,310
speculation but you can only do that at

1035
00:38:00,910 --> 00:38:04,569
certain points and what if which is you

1036
00:38:03,310 --> 00:38:06,549
can hide the secret you see things like

1037
00:38:04,570 --> 00:38:08,320
kpti discussed earlier or you can

1038
00:38:06,550 --> 00:38:10,600
disable timers when I say the disable

1039
00:38:08,320 --> 00:38:12,580
timers thing does not last you can

1040
00:38:10,600 --> 00:38:15,100
construct these timers so our JavaScript

1041
00:38:12,580 --> 00:38:16,870
demo actually does this using shared

1042
00:38:15,100 --> 00:38:18,580
memory and it turns out like for things

1043
00:38:16,870 --> 00:38:20,920
like games and stuff you really need

1044
00:38:18,580 --> 00:38:22,480
this high performance counters but the

1045
00:38:20,920 --> 00:38:24,370
opportunities are in place in a lot of

1046
00:38:22,480 --> 00:38:28,110
systems but the bad news is these don't

1047
00:38:24,370 --> 00:38:30,400
make any sense in the face of new

1048
00:38:28,110 --> 00:38:32,320
vulnerabilities such as with or in MDS

1049
00:38:30,400 --> 00:38:34,210
so in May they introduced two new

1050
00:38:32,320 --> 00:38:36,460
mitigations in toted and all the

1051
00:38:34,210 --> 00:38:39,130
operating system vendors so one of which

1052
00:38:36,460 --> 00:38:40,570
is kind of the simplest approach you can

1053
00:38:39,130 --> 00:38:42,520
think of your leaking for these buffers

1054
00:38:40,570 --> 00:38:44,230
so we just overwrite the buffers you

1055
00:38:42,520 --> 00:38:46,090
just stomp servos all over these buffers

1056
00:38:44,230 --> 00:38:48,310
and as long as you're in the same thread

1057
00:38:46,090 --> 00:38:50,440
this is fine you have beautiful pieces

1058
00:38:48,310 --> 00:38:52,509
of assembly code like this yeah I mean

1059
00:38:50,440 --> 00:38:54,490
it hits your performance a lid or having

1060
00:38:52,510 --> 00:38:58,480
to do this all over the place but it's

1061
00:38:54,490 --> 00:39:00,279
for security but the really bad news is

1062
00:38:58,480 --> 00:39:01,690
that it doesn't matter if you're

1063
00:39:00,280 --> 00:39:03,790
clearing the buffers if we're in the

1064
00:39:01,690 --> 00:39:06,220
other hyper thread grabbing the buffers

1065
00:39:03,790 --> 00:39:07,720
before you can clear them and this means

1066
00:39:06,220 --> 00:39:09,490
that you have two options one of which

1067
00:39:07,720 --> 00:39:11,049
is you can just have really complicate

1068
00:39:09,490 --> 00:39:13,450
scheduling you can make sure that kind

1069
00:39:11,050 --> 00:39:14,620
of the kernel when it's in one friend in

1070
00:39:13,450 --> 00:39:16,930
the kernel the other thread is not in

1071
00:39:14,620 --> 00:39:18,250
the kernel it turns out in to have a

1072
00:39:16,930 --> 00:39:20,049
beautiful document that looks like this

1073
00:39:18,250 --> 00:39:22,840
it's like yeah you can kind of make the

1074
00:39:20,050 --> 00:39:24,100
scheduling work right no this is this is

1075
00:39:22,840 --> 00:39:25,930
never going to be implemented correctly

1076
00:39:24,100 --> 00:39:27,790
it's too complicated it comes to too

1077
00:39:25,930 --> 00:39:30,700
much of performance hit so if you want

1078
00:39:27,790 --> 00:39:33,460
to be secure the only real thing to do

1079
00:39:30,700 --> 00:39:35,379
is the disable hyper threading you know

1080
00:39:33,460 --> 00:39:37,630
okay on your desktop machines you know

1081
00:39:35,380 --> 00:39:39,520
this is maybe not so important but on

1082
00:39:37,630 --> 00:39:40,420
servers this is still a risk everyone's

1083
00:39:39,520 --> 00:39:43,030
running with hyper threading for

1084
00:39:40,420 --> 00:39:44,800
performance but you know this is this is

1085
00:39:43,030 --> 00:39:46,570
kind of a crazy idea everyone's been

1086
00:39:44,800 --> 00:39:48,970
very careful like your hypervisor

1087
00:39:46,570 --> 00:39:51,070
doesn't load stuff from another virtual

1088
00:39:48,970 --> 00:39:53,080
machine while your virtual machine is

1089
00:39:51,070 --> 00:39:57,910
one of the hyper threads if you're

1090
00:39:53,080 --> 00:39:59,470
Amazon or Google or Microsoft then yeah

1091
00:39:57,910 --> 00:40:00,879
sure you can kind of implement this and

1092
00:39:59,470 --> 00:40:03,220
they all have implementations which

1093
00:40:00,880 --> 00:40:05,620
might work who knows we're not sure but

1094
00:40:03,220 --> 00:40:07,149
how the other cloud vendors this is a

1095
00:40:05,620 --> 00:40:09,578
big problem

1096
00:40:07,150 --> 00:40:11,589
so and this is another example of what

1097
00:40:09,579 --> 00:40:14,380
we like to call sport mitigations so

1098
00:40:11,589 --> 00:40:16,058
it's just a medication which just

1099
00:40:14,380 --> 00:40:18,249
patches over bone problem this literally

1100
00:40:16,059 --> 00:40:19,720
just clearing the buffers here and it

1101
00:40:18,249 --> 00:40:21,669
clears all three kinds of buffers that

1102
00:40:19,720 --> 00:40:23,259
we found if there are more buffers in

1103
00:40:21,670 --> 00:40:25,749
there that you can leave form then this

1104
00:40:23,259 --> 00:40:27,730
is not going to be effects and we can

1105
00:40:25,749 --> 00:40:29,828
already see that also until tried

1106
00:40:27,730 --> 00:40:31,599
patching these issues in silicon right

1107
00:40:29,829 --> 00:40:32,950
they actually patched the meltdown

1108
00:40:31,599 --> 00:40:36,099
issues so page faults are no longer

1109
00:40:32,950 --> 00:40:37,480
valid and it didn't work and yeah look

1110
00:40:36,099 --> 00:40:39,519
at our diagram look at how complicated

1111
00:40:37,480 --> 00:40:40,990
these things are it's actually you can

1112
00:40:39,519 --> 00:40:43,328
zoom in to any of these things there's a

1113
00:40:40,990 --> 00:40:44,979
whole bunch of other things in and a lot

1114
00:40:43,329 --> 00:40:46,569
of these units they were putting away

1115
00:40:44,980 --> 00:40:49,839
problems and it's not just Intel right

1116
00:40:46,569 --> 00:40:52,150
this is you know a lot of modern CPUs

1117
00:40:49,839 --> 00:40:55,240
look like this more complicated than

1118
00:40:52,150 --> 00:40:57,160
this so my take-home message today is

1119
00:40:55,240 --> 00:41:00,008
this issues need to be fixed which means

1120
00:40:57,160 --> 00:41:01,440
these issues need to be understood and I

1121
00:41:00,009 --> 00:41:04,029
really don't get the impression that

1122
00:41:01,440 --> 00:41:07,240
many people at Intel understand these

1123
00:41:04,029 --> 00:41:09,369
issues certainly very few people outside

1124
00:41:07,240 --> 00:41:13,779
Intel have any idea I mean I have no

1125
00:41:09,369 --> 00:41:15,609
idea how some of this works and if you

1126
00:41:13,779 --> 00:41:17,980
are more interested in this whole CPU

1127
00:41:15,609 --> 00:41:20,348
but this whole is your cpu bugs in

1128
00:41:17,980 --> 00:41:23,559
general it's a very serious one there is

1129
00:41:20,349 --> 00:41:25,390
a great paper at least explore people

1130
00:41:23,559 --> 00:41:28,239
before some of the authors were from

1131
00:41:25,390 --> 00:41:29,920
Intel it's called hard fails and I

1132
00:41:28,239 --> 00:41:31,480
recommend take a look at this this gives

1133
00:41:29,920 --> 00:41:33,099
an idea not these kind of

1134
00:41:31,480 --> 00:41:35,019
vulnerabilities but all the other kind

1135
00:41:33,099 --> 00:41:37,390
of vulnerabilities that you run into

1136
00:41:35,019 --> 00:41:39,098
when you're trying to make CPUs and it

1137
00:41:37,390 --> 00:41:41,440
turns out oh gosh this is really hard

1138
00:41:39,099 --> 00:41:43,749
and our verification tools don't support

1139
00:41:41,440 --> 00:41:45,609
this stuff and our engineers don't spot

1140
00:41:43,749 --> 00:41:49,808
this stuff and this stuff ends up left

1141
00:41:45,609 --> 00:41:51,940
in CPS it's a really good paper and the

1142
00:41:49,809 --> 00:41:54,640
disclosure process just to give an idea

1143
00:41:51,940 --> 00:41:57,400
of how much fun this is we're still

1144
00:41:54,640 --> 00:41:59,739
talking to Peter so we reported this

1145
00:41:57,400 --> 00:42:02,380
last year just before Hardware IO

1146
00:41:59,739 --> 00:42:03,430
September the 12th and they were like

1147
00:42:02,380 --> 00:42:04,869
yeah that's great you're the first

1148
00:42:03,430 --> 00:42:07,239
academic finders this is really serious

1149
00:42:04,869 --> 00:42:09,039
we'll definitely look at it and then

1150
00:42:07,239 --> 00:42:10,119
okay we're fine we submit a paper to an

1151
00:42:09,039 --> 00:42:12,069
academic conference under

1152
00:42:10,119 --> 00:42:13,690
confidentiality and then they come back

1153
00:42:12,069 --> 00:42:15,220
in December and say wait there were

1154
00:42:13,690 --> 00:42:16,720
already three people who actually found

1155
00:42:15,220 --> 00:42:19,328
this before you and we just forgot about

1156
00:42:16,720 --> 00:42:21,100
them and then

1157
00:42:19,329 --> 00:42:23,620
Georgie who's a co-author on our paper

1158
00:42:21,100 --> 00:42:26,049
Volo and Dan it turns out that Dan

1159
00:42:23,620 --> 00:42:28,569
didn't find this and he actually found

1160
00:42:26,050 --> 00:42:32,470
the spoke G GG s thing which was in the

1161
00:42:28,570 --> 00:42:35,380
news very recently and then yeah I mean

1162
00:42:32,470 --> 00:42:36,700
unsurprisingly Intel in May said

1163
00:42:35,380 --> 00:42:38,230
although more finders it turns out

1164
00:42:36,700 --> 00:42:39,910
people are actively looking at this not

1165
00:42:38,230 --> 00:42:41,530
that many people but there were more

1166
00:42:39,910 --> 00:42:45,339
finders for example the zombie load

1167
00:42:41,530 --> 00:42:49,540
offers founder largely overlapping

1168
00:42:45,340 --> 00:42:51,100
issues in April I think you know there

1169
00:42:49,540 --> 00:42:53,110
are lots of people involved I'm sure

1170
00:42:51,100 --> 00:42:55,299
there were also people who did were not

1171
00:42:53,110 --> 00:42:56,620
nice enough to disclose to Intel who

1172
00:42:55,300 --> 00:42:58,930
have been taking advantage of these

1173
00:42:56,620 --> 00:43:01,029
things you can find more information on

1174
00:42:58,930 --> 00:43:02,589
our website if you haven't already

1175
00:43:01,030 --> 00:43:05,560
looked at this there's also a tool you

1176
00:43:02,590 --> 00:43:08,410
can download that checks whether Intel's

1177
00:43:05,560 --> 00:43:10,029
mitigation to in place and what Intel

1178
00:43:08,410 --> 00:43:14,560
says about if your CPU is vulnerable or

1179
00:43:10,030 --> 00:43:17,470
not and just to conclude so we kind of

1180
00:43:14,560 --> 00:43:19,299
fought ok Specter and certainly meltdown

1181
00:43:17,470 --> 00:43:21,640
this is just bugs it was just one issue

1182
00:43:19,300 --> 00:43:23,170
okay for shadow you know this is not

1183
00:43:21,640 --> 00:43:26,230
going to be a whole thing which keeps on

1184
00:43:23,170 --> 00:43:26,770
giving for decades right turns out yeah

1185
00:43:26,230 --> 00:43:28,750
it is

1186
00:43:26,770 --> 00:43:30,340
we found a new class of speculative

1187
00:43:28,750 --> 00:43:33,970
attacks here leaking from a whole bunch

1188
00:43:30,340 --> 00:43:35,500
of buffers and the question is how many

1189
00:43:33,970 --> 00:43:37,299
bugs are left you know it's not the

1190
00:43:35,500 --> 00:43:39,220
question is are there more bugs I think

1191
00:43:37,300 --> 00:43:40,600
the real question is just how many of

1192
00:43:39,220 --> 00:43:42,730
these things are left how many of these

1193
00:43:40,600 --> 00:43:45,040
things I could be found over the next

1194
00:43:42,730 --> 00:43:47,620
few years and I'm hoping from some of

1195
00:43:45,040 --> 00:43:49,330
you so you can pick us on Twitter and we

1196
00:43:47,620 --> 00:43:51,850
have a website and I'd love to take

1197
00:43:49,330 --> 00:43:58,869
questions thank you

1198
00:43:51,850 --> 00:43:58,868
[Applause]

1199
00:43:59,549 --> 00:44:04,859
have you tried these also on arms abused

1200
00:44:05,729 --> 00:44:10,239
okay so the question was have we also

1201
00:44:08,380 --> 00:44:12,130
tried these on offensive use so the

1202
00:44:10,239 --> 00:44:16,089
problem with arm is that we have some

1203
00:44:12,130 --> 00:44:19,209
armed laptops at our office I play

1204
00:44:16,089 --> 00:44:20,709
around a lot with them in the past but

1205
00:44:19,209 --> 00:44:22,989
the problem most of my arm hardware is

1206
00:44:20,709 --> 00:44:24,788
still 32-bit and I think one of the

1207
00:44:22,989 --> 00:44:26,169
biggest issues arm has at this point is

1208
00:44:24,789 --> 00:44:28,179
that it's completely fragmented it's

1209
00:44:26,169 --> 00:44:30,279
super hard to get any of the modern

1210
00:44:28,179 --> 00:44:32,619
processors and most of the modern

1211
00:44:30,279 --> 00:44:36,549
processes of like that exclaiming your

1212
00:44:32,619 --> 00:44:38,829
arm just support eisah just to decode

1213
00:44:36,549 --> 00:44:40,479
instructions but the internal

1214
00:44:38,829 --> 00:44:42,309
architecture is not from arm itself it's

1215
00:44:40,479 --> 00:44:44,259
something customary and it's very hard

1216
00:44:42,309 --> 00:44:46,119
to get these service points and so it's

1217
00:44:44,259 --> 00:44:49,499
like you start at a point of 10 K so we

1218
00:44:46,119 --> 00:44:49,499
haven't been able to look at these yet

1219
00:44:52,409 --> 00:44:58,890
okay thanks would be very helpful okay

1220
00:45:03,299 --> 00:45:09,009
any other questions I can experiment so

1221
00:45:07,059 --> 00:45:10,899
what an interesting thing is that so

1222
00:45:09,009 --> 00:45:13,179
these class of bugs arm has been

1223
00:45:10,899 --> 00:45:15,159
vulnerable to at least the rogue system

1224
00:45:13,179 --> 00:45:16,659
register load bugs where they were

1225
00:45:15,159 --> 00:45:19,749
speculated the allowing access to

1226
00:45:16,659 --> 00:45:22,089
confidential registers in some CPUs you

1227
00:45:19,749 --> 00:45:25,269
have some power systems which were

1228
00:45:22,089 --> 00:45:27,249
vulnerable to meltdown stall the tax you

1229
00:45:25,269 --> 00:45:28,538
have AMD systems which apparently don't

1230
00:45:27,249 --> 00:45:30,218
check the segment registers very

1231
00:45:28,539 --> 00:45:32,589
carefully thankfully for AMD

1232
00:45:30,219 --> 00:45:34,479
no one uses registers for this side kind

1233
00:45:32,589 --> 00:45:36,399
of security anymore but these bugs are

1234
00:45:34,479 --> 00:45:37,749
definitely everywhere it's just a

1235
00:45:36,399 --> 00:45:40,499
question of people are really looking

1236
00:45:37,749 --> 00:45:40,499
for them on Intel

1237
00:45:48,210 --> 00:45:52,810
so it looks like we don't have any other

1238
00:45:50,260 --> 00:45:55,840
questions you can talk to the speakers

1239
00:45:52,810 --> 00:45:57,440
during the break Thank You Stefan Thank

1240
00:45:55,840 --> 00:46:01,079
You Alyssa

1241
00:45:57,440 --> 00:46:01,079
[Applause]

