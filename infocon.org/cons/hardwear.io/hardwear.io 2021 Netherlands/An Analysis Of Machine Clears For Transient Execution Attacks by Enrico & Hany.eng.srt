1
00:00:03,280 --> 00:00:05,279
uh welcome to our presentation rage

2
00:00:05,279 --> 00:00:06,879
against the machine clear

3
00:00:06,879 --> 00:00:09,120
systematic analysis of machine clears

4
00:00:09,120 --> 00:00:10,719
and their implication for transcendent

5
00:00:10,719 --> 00:00:13,040
execution attacks

6
00:00:13,040 --> 00:00:15,280
this was a co-joint work between honey

7
00:00:15,280 --> 00:00:17,520
and me and also with the help of the

8
00:00:17,520 --> 00:00:20,720
professor of albert and cristiano and

9
00:00:20,720 --> 00:00:22,800
you saw albert yesterday on the keynote

10
00:00:22,800 --> 00:00:24,960
and all of us are coming from the vusek

11
00:00:24,960 --> 00:00:27,680
security group in view university

12
00:00:27,680 --> 00:00:30,640
amsterdam

13
00:00:30,640 --> 00:00:33,200
the outline for today will be four main

14
00:00:33,200 --> 00:00:35,440
steps we start with a small background

15
00:00:35,440 --> 00:00:37,120
section to catch up with the main

16
00:00:37,120 --> 00:00:38,239
concept

17
00:00:38,239 --> 00:00:40,239
then we'll explain the core of the

18
00:00:40,239 --> 00:00:41,760
slides at our main

19
00:00:41,760 --> 00:00:44,879
that are about machine clears later we

20
00:00:44,879 --> 00:00:46,719
also will show a full length and exploit

21
00:00:46,719 --> 00:00:48,000
on firefox

22
00:00:48,000 --> 00:00:50,320
and finally some conclusion and

23
00:00:50,320 --> 00:00:53,120
some recap and results

24
00:00:53,120 --> 00:00:55,680
okay let's break a bit the eyes

25
00:00:55,680 --> 00:00:56,879
who knows

26
00:00:56,879 --> 00:00:58,960
this image or

27
00:00:58,960 --> 00:01:01,280
okay

28
00:01:05,840 --> 00:01:07,360
exactly

29
00:01:07,360 --> 00:01:09,520
so the dutch policeman is to find people

30
00:01:09,520 --> 00:01:12,799
growing legally with in their apartment

31
00:01:12,799 --> 00:01:14,640
just by observing the methods now on the

32
00:01:14,640 --> 00:01:15,520
roof

33
00:01:15,520 --> 00:01:18,000
and why we brought this slide is

34
00:01:18,000 --> 00:01:20,479
this is a perfect example of a side

35
00:01:20,479 --> 00:01:21,439
channel

36
00:01:21,439 --> 00:01:22,479
so

37
00:01:22,479 --> 00:01:24,240
you don't see the guys actually growing

38
00:01:24,240 --> 00:01:26,880
weed but with a side effect of let's say

39
00:01:26,880 --> 00:01:28,560
a secret information

40
00:01:28,560 --> 00:01:31,360
you still manage to infer

41
00:01:31,360 --> 00:01:32,799
information

42
00:01:32,799 --> 00:01:36,320
but obviously cpus doesn't grow weed so

43
00:01:36,320 --> 00:01:38,000
how does it work on modern

44
00:01:38,000 --> 00:01:40,560
processor

45
00:01:40,560 --> 00:01:43,040
switch to let's see a thermos a channel

46
00:01:43,040 --> 00:01:45,840
to a timing side channel

47
00:01:45,840 --> 00:01:48,640
that is usually the most common one is a

48
00:01:48,640 --> 00:01:50,240
flash and reload

49
00:01:50,240 --> 00:01:53,040
let's uh quickly explain it so we have

50
00:01:53,040 --> 00:01:54,960
an attacker and a victim let's say two

51
00:01:54,960 --> 00:01:55,840
different

52
00:01:55,840 --> 00:01:56,880
process

53
00:01:56,880 --> 00:01:59,920
that they share a common resource the

54
00:01:59,920 --> 00:02:02,799
data cache in this case

55
00:02:02,799 --> 00:02:05,280
the first step is to bring this array in

56
00:02:05,280 --> 00:02:08,318
a known state by flashing entirely the

57
00:02:08,318 --> 00:02:10,560
array from the cache

58
00:02:10,560 --> 00:02:12,239
then the next step

59
00:02:12,239 --> 00:02:14,720
is to trigger the victim execution

60
00:02:14,720 --> 00:02:17,200
and let's suppose that depending on a

61
00:02:17,200 --> 00:02:18,879
secret bit

62
00:02:18,879 --> 00:02:20,879
of a cryptographic key you're going to

63
00:02:20,879 --> 00:02:23,520
access either the entry 0 or 1 of the

64
00:02:23,520 --> 00:02:24,480
array

65
00:02:24,480 --> 00:02:26,720
and for simplicity in this example

66
00:02:26,720 --> 00:02:30,800
let's say we access entry one

67
00:02:31,840 --> 00:02:33,920
okay and as you can see the array at

68
00:02:33,920 --> 00:02:36,400
entry one was brought into the data

69
00:02:36,400 --> 00:02:38,160
cache

70
00:02:38,160 --> 00:02:40,239
finally the attacker by performing the

71
00:02:40,239 --> 00:02:42,879
reload step it will measure the time of

72
00:02:42,879 --> 00:02:45,519
accessing every entry of the array

73
00:02:45,519 --> 00:02:47,360
the first one will be slow because it's

74
00:02:47,360 --> 00:02:49,360
coming from dram and it will be

75
00:02:49,360 --> 00:02:51,440
miserably slow

76
00:02:51,440 --> 00:02:53,360
while array at entry position one it

77
00:02:53,360 --> 00:02:54,959
will be much faster

78
00:02:54,959 --> 00:02:57,360
and the attacker by measuring this

79
00:02:57,360 --> 00:02:59,280
timing difference can infer what the

80
00:02:59,280 --> 00:03:01,680
victim actually executed

81
00:03:01,680 --> 00:03:04,080
so again this is a a channel looking at

82
00:03:04,080 --> 00:03:06,480
the time of execution you can infer

83
00:03:06,480 --> 00:03:09,200
secret information

84
00:03:09,200 --> 00:03:10,879
things get really interesting when

85
00:03:10,879 --> 00:03:12,959
combining say channel with transit

86
00:03:12,959 --> 00:03:15,519
execution that is a new fancy term for

87
00:03:15,519 --> 00:03:19,360
speculative execution same stuff

88
00:03:19,360 --> 00:03:21,280
again let's have a quick look at an

89
00:03:21,280 --> 00:03:22,560
example

90
00:03:22,560 --> 00:03:24,480
standard bound check

91
00:03:24,480 --> 00:03:26,480
array access

92
00:03:26,480 --> 00:03:31,040
let's say that the array size is

93
00:03:31,040 --> 00:03:33,599
it is low to get is coming from from

94
00:03:33,599 --> 00:03:35,200
memory or a complex mathematical

95
00:03:35,200 --> 00:03:36,400
operation

96
00:03:36,400 --> 00:03:38,560
so the processor will not stop there you

97
00:03:38,560 --> 00:03:40,640
will try to speculatively

98
00:03:40,640 --> 00:03:42,959
uh guess the outcome of this branch

99
00:03:42,959 --> 00:03:45,760
and let's say that you guess on

100
00:03:45,760 --> 00:03:48,640
taken branch and you will execute the

101
00:03:48,640 --> 00:03:51,120
inner volume of the branch

102
00:03:51,120 --> 00:03:52,000
again

103
00:03:52,000 --> 00:03:54,159
the inner body of the branch is a simple

104
00:03:54,159 --> 00:03:56,720
load that will bring array x into the

105
00:03:56,720 --> 00:03:57,920
cache

106
00:03:57,920 --> 00:03:59,519
and let's say that also later the

107
00:03:59,519 --> 00:04:01,840
processors cover all them this was a bad

108
00:04:01,840 --> 00:04:03,280
speculation

109
00:04:03,280 --> 00:04:05,360
we need to squash everything

110
00:04:05,360 --> 00:04:08,159
and revert the execution from the

111
00:04:08,159 --> 00:04:10,799
latest instruction

112
00:04:10,799 --> 00:04:11,599
here

113
00:04:11,599 --> 00:04:14,159
as you can see the arrax is still in

114
00:04:14,159 --> 00:04:15,040
cash

115
00:04:15,040 --> 00:04:17,358
so even if the processor never committed

116
00:04:17,358 --> 00:04:18,880
this instruction

117
00:04:18,880 --> 00:04:21,839
there is still a trace in the cache so a

118
00:04:21,839 --> 00:04:24,080
micro architectural trace that an

119
00:04:24,080 --> 00:04:25,759
attacker can observe

120
00:04:25,759 --> 00:04:27,520
again by measuring the access time of

121
00:04:27,520 --> 00:04:29,199
every array entry

122
00:04:29,199 --> 00:04:30,720
so you can even observe what the

123
00:04:30,720 --> 00:04:33,440
processor did speculatively

124
00:04:33,440 --> 00:04:34,960
and

125
00:04:34,960 --> 00:04:36,720
thanks to this

126
00:04:36,720 --> 00:04:38,400
many attacks were published in the past

127
00:04:38,400 --> 00:04:39,440
years

128
00:04:39,440 --> 00:04:41,600
we started with all the huge family of

129
00:04:41,600 --> 00:04:43,600
spectre on the left

130
00:04:43,600 --> 00:04:47,440
meltdown then all the big class of mds

131
00:04:47,440 --> 00:04:49,759
micro architectural data sampling

132
00:04:49,759 --> 00:04:52,400
came in with many buffers to

133
00:04:52,400 --> 00:04:55,440
exploit we have blood very injection

134
00:04:55,440 --> 00:04:56,720
we even go

135
00:04:56,720 --> 00:04:59,919
beyond a single core there is crosstalk

136
00:04:59,919 --> 00:05:01,840
an attacking works on a

137
00:05:01,840 --> 00:05:04,639
different physical course we can still

138
00:05:04,639 --> 00:05:05,360
do

139
00:05:05,360 --> 00:05:06,800
attacks

140
00:05:06,800 --> 00:05:08,720
and now since we are in 2021 we are

141
00:05:08,720 --> 00:05:11,440
presenting our two new vulnerabilities

142
00:05:11,440 --> 00:05:13,280
that are floating point with injection

143
00:05:13,280 --> 00:05:14,160
and

144
00:05:14,160 --> 00:05:16,240
speculative called store bypass

145
00:05:16,240 --> 00:05:18,960
and today we are going to present

146
00:05:18,960 --> 00:05:21,199
these vulnerabilities together with

147
00:05:21,199 --> 00:05:25,160
other type of machine clear

148
00:05:25,600 --> 00:05:27,680
all right

149
00:05:27,680 --> 00:05:30,560
so let's take a step back first and

150
00:05:30,560 --> 00:05:33,120
think about what is the definition or

151
00:05:33,120 --> 00:05:35,440
what is the umbrella that under which we

152
00:05:35,440 --> 00:05:36,639
have

153
00:05:36,639 --> 00:05:38,320
branched prediction and all these types

154
00:05:38,320 --> 00:05:40,320
of trans execution attacks and in this

155
00:05:40,320 --> 00:05:43,039
case intel defines this sort of umbrella

156
00:05:43,039 --> 00:05:45,919
as bad speculation and defines it as the

157
00:05:45,919 --> 00:05:48,800
root cause of discarding uh issued micro

158
00:05:48,800 --> 00:05:51,759
operations on x86 processors and it

159
00:05:51,759 --> 00:05:54,639
defines two main classes under this term

160
00:05:54,639 --> 00:05:55,680
the first one is branch missed

161
00:05:55,680 --> 00:05:57,600
prediction as we saw earlier so

162
00:05:57,600 --> 00:05:59,680
basically we have a branch predictor

163
00:05:59,680 --> 00:06:01,840
which mispredicts either the direction

164
00:06:01,840 --> 00:06:04,000
or the target of our branch

165
00:06:04,000 --> 00:06:07,199
and the second class is machine clear

166
00:06:07,199 --> 00:06:08,720
indeed which is the one that we're going

167
00:06:08,720 --> 00:06:11,280
to explain today

168
00:06:11,280 --> 00:06:12,639
and

169
00:06:12,639 --> 00:06:14,960
previously all previous attacks uh

170
00:06:14,960 --> 00:06:17,039
including answering from spectre were

171
00:06:17,039 --> 00:06:19,520
using branch misprediction along with

172
00:06:19,520 --> 00:06:22,160
false or intel tsx which is the

173
00:06:22,160 --> 00:06:23,919
transactional memory implementation of

174
00:06:23,919 --> 00:06:25,039
intel

175
00:06:25,039 --> 00:06:26,560
to create new

176
00:06:26,560 --> 00:06:28,880
transit execution paths

177
00:06:28,880 --> 00:06:31,600
and they were also continuing to rely on

178
00:06:31,600 --> 00:06:32,560
these

179
00:06:32,560 --> 00:06:35,520
three uh basically causes and with

180
00:06:35,520 --> 00:06:38,160
different variations but still say still

181
00:06:38,160 --> 00:06:40,240
mistraining a predictor creating another

182
00:06:40,240 --> 00:06:43,039
type of fault or aborting an intel tsx

183
00:06:43,039 --> 00:06:45,520
transaction in a different way

184
00:06:45,520 --> 00:06:47,520
but the same cannot be said about

185
00:06:47,520 --> 00:06:48,210
machine clear

186
00:06:48,210 --> 00:06:49,360
[Music]

187
00:06:49,360 --> 00:06:51,360
until our work remained a widely

188
00:06:51,360 --> 00:06:54,400
unexplored class of how we can create

189
00:06:54,400 --> 00:06:56,319
new trends execution path without having

190
00:06:56,319 --> 00:06:58,400
to minister in a predictor let's say

191
00:06:58,400 --> 00:06:59,759
and this is what we're going to explain

192
00:06:59,759 --> 00:07:01,599
today

193
00:07:01,599 --> 00:07:04,240
so in this work we

194
00:07:04,240 --> 00:07:05,919
performed the security analysis and the

195
00:07:05,919 --> 00:07:07,360
reverse engineering of the four main

196
00:07:07,360 --> 00:07:09,360
types of machine clear the first one is

197
00:07:09,360 --> 00:07:10,880
self-modifying code then we have

198
00:07:10,880 --> 00:07:12,880
floating point memory ordering and

199
00:07:12,880 --> 00:07:14,560
members of the migration machine clear

200
00:07:14,560 --> 00:07:16,479
these are four different

201
00:07:16,479 --> 00:07:19,759
causes of transit execution on motor

202
00:07:19,759 --> 00:07:21,360
cpus

203
00:07:21,360 --> 00:07:24,319
two of which actually led us to have two

204
00:07:24,319 --> 00:07:27,120
uh new uh trans exclusion attack based

205
00:07:27,120 --> 00:07:28,880
attack primitives the first one is

206
00:07:28,880 --> 00:07:30,720
speculative code store bypass which is

207
00:07:30,720 --> 00:07:33,360
based on a transient window created

208
00:07:33,360 --> 00:07:35,199
because of a self-modifying code and

209
00:07:35,199 --> 00:07:36,639
then the second one is floating point

210
00:07:36,639 --> 00:07:39,919
value injection which is created uh is a

211
00:07:39,919 --> 00:07:42,880
based on a transient window rated by a

212
00:07:42,880 --> 00:07:45,199
floating point machine clear

213
00:07:45,199 --> 00:07:46,960
then from floating point value injection

214
00:07:46,960 --> 00:07:48,479
we were able to mount an end-to-end

215
00:07:48,479 --> 00:07:50,080
attack on

216
00:07:50,080 --> 00:07:52,240
the firefox web browser which allows an

217
00:07:52,240 --> 00:07:54,319
attacker to leak arbitrary memory

218
00:07:54,319 --> 00:07:55,360
addresses

219
00:07:55,360 --> 00:07:57,120
with a leakage rate which can reach up

220
00:07:57,120 --> 00:08:00,560
to 13 kilobytes per second

221
00:08:00,560 --> 00:08:03,039
so um here we're going to explain how we

222
00:08:03,039 --> 00:08:04,800
actually approach all the these

223
00:08:04,800 --> 00:08:06,879
different types of machine clear in

224
00:08:06,879 --> 00:08:09,039
during our reverse engineering and sql

225
00:08:09,039 --> 00:08:10,400
analysis and what are the main points

226
00:08:10,400 --> 00:08:12,000
that we actually focus on in order to

227
00:08:12,000 --> 00:08:13,680
understand the

228
00:08:13,680 --> 00:08:15,840
root causes of these events

229
00:08:15,840 --> 00:08:18,560
first we started to look at what is the

230
00:08:18,560 --> 00:08:20,400
architectural invariant

231
00:08:20,400 --> 00:08:22,960
at the core of each event at each type

232
00:08:22,960 --> 00:08:24,800
of machine clear and then how this

233
00:08:24,800 --> 00:08:27,120
invariant can be violated and therefore

234
00:08:27,120 --> 00:08:30,319
creating a machine clear

235
00:08:30,319 --> 00:08:32,479
then what are the security implications

236
00:08:32,479 --> 00:08:34,559
of this environment violation and

237
00:08:34,559 --> 00:08:36,000
finally how this

238
00:08:36,000 --> 00:08:38,399
violation can be exploited

239
00:08:38,399 --> 00:08:40,320
in a nutshell here before we dive into

240
00:08:40,320 --> 00:08:42,320
the different types a machine clear is

241
00:08:42,320 --> 00:08:45,040
basically uh a condition that

242
00:08:45,040 --> 00:08:48,080
unconditionally flushes the pipeline and

243
00:08:48,080 --> 00:08:49,839
causes the uh

244
00:08:49,839 --> 00:08:51,440
to restart the execution from the last

245
00:08:51,440 --> 00:08:54,160
returning instruction so it's not uh

246
00:08:54,160 --> 00:08:56,399
like for example uh the misprediction of

247
00:08:56,399 --> 00:08:59,360
a branch where you uh basically revert

248
00:08:59,360 --> 00:09:01,600
the uh instructions executed inside the

249
00:09:01,600 --> 00:09:04,240
mispredicted branch but it's

250
00:09:04,240 --> 00:09:05,920
anything that was in the pipeline from

251
00:09:05,920 --> 00:09:07,360
the moment that the machine clear event

252
00:09:07,360 --> 00:09:09,839
occurred

253
00:09:09,839 --> 00:09:11,519
so the first type that we're presenting

254
00:09:11,519 --> 00:09:13,440
today is self-modifying code machine

255
00:09:13,440 --> 00:09:15,200
clear which is based on a

256
00:09:15,200 --> 00:09:16,880
self-monitoring code so a self-modifying

257
00:09:16,880 --> 00:09:19,200
code is a program that stores

258
00:09:19,200 --> 00:09:21,279
instruction as data modifying its own

259
00:09:21,279 --> 00:09:22,399
code

260
00:09:22,399 --> 00:09:24,080
while it's being executed

261
00:09:24,080 --> 00:09:27,279
it's been widely used in malwares to

262
00:09:27,279 --> 00:09:28,959
unpack themselves when it's time to get

263
00:09:28,959 --> 00:09:30,399
executed

264
00:09:30,399 --> 00:09:31,680
but now we're going to see them in a

265
00:09:31,680 --> 00:09:32,720
different

266
00:09:32,720 --> 00:09:34,959
way and different use case

267
00:09:34,959 --> 00:09:37,120
so let's take a look at this snippet of

268
00:09:37,120 --> 00:09:38,560
code where we have two instructions the

269
00:09:38,560 --> 00:09:41,680
first one is during an operation at the

270
00:09:41,680 --> 00:09:43,040
address of the following instruction

271
00:09:43,040 --> 00:09:45,120
transforming the load from load secret

272
00:09:45,120 --> 00:09:47,120
to a no operation

273
00:09:47,120 --> 00:09:49,440
in modern processors

274
00:09:49,440 --> 00:09:51,279
uh processors try to in order to

275
00:09:51,279 --> 00:09:53,839
maximize uh the execution throughput

276
00:09:53,839 --> 00:09:54,640
they

277
00:09:54,640 --> 00:09:56,240
fetch the code and execute well out of

278
00:09:56,240 --> 00:09:57,920
retirement to maintain the front end

279
00:09:57,920 --> 00:10:00,080
always filled with instructions and

280
00:10:00,080 --> 00:10:03,120
whenever uh the case of an sm uh cell

281
00:10:03,120 --> 00:10:04,959
phone reference code program occurs in

282
00:10:04,959 --> 00:10:07,040
this case the store that tries to modify

283
00:10:07,040 --> 00:10:09,120
the following instruction the pla the

284
00:10:09,120 --> 00:10:11,920
cpu is forced to flush its pipeline from

285
00:10:11,920 --> 00:10:13,760
the previously fetched decoded and

286
00:10:13,760 --> 00:10:15,279
executed instruction in this case the

287
00:10:15,279 --> 00:10:17,680
load secret and consider the new

288
00:10:17,680 --> 00:10:19,600
instruction that is being stored in this

289
00:10:19,600 --> 00:10:21,760
case the operation so it has to fetch

290
00:10:21,760 --> 00:10:23,640
the code and execute the new operation

291
00:10:23,640 --> 00:10:25,040
[Music]

292
00:10:25,040 --> 00:10:27,680
but since this detection of the fact

293
00:10:27,680 --> 00:10:30,399
that there has been an instruction that

294
00:10:30,399 --> 00:10:31,519
was

295
00:10:31,519 --> 00:10:33,519
and executed already in the pipeline and

296
00:10:33,519 --> 00:10:35,279
now i have to replace it with a new

297
00:10:35,279 --> 00:10:38,000
instruction uh this gives a window

298
00:10:38,000 --> 00:10:41,120
creates a transient window where code

299
00:10:41,120 --> 00:10:42,959
is executed my correct actually an

300
00:10:42,959 --> 00:10:45,360
internal the processor and as we saw

301
00:10:45,360 --> 00:10:46,800
earlier can leave tracer that could be

302
00:10:46,800 --> 00:10:49,279
observable so in this case even if i

303
00:10:49,279 --> 00:10:51,279
will never the cpu will never commit the

304
00:10:51,279 --> 00:10:53,839
load secret due to the new instruction

305
00:10:53,839 --> 00:10:55,760
that has to be executed in this case an

306
00:10:55,760 --> 00:10:57,680
operation we can still

307
00:10:57,680 --> 00:11:00,000
observe the microcontractual traces left

308
00:11:00,000 --> 00:11:01,920
by the trend execution of the load

309
00:11:01,920 --> 00:11:04,319
secret

310
00:11:04,560 --> 00:11:06,480
so here the architectural invariant of

311
00:11:06,480 --> 00:11:08,079
this type of machine clear is that store

312
00:11:08,079 --> 00:11:10,000
instructions always target data

313
00:11:10,000 --> 00:11:11,839
addresses

314
00:11:11,839 --> 00:11:14,000
and this invariant is violated in the

315
00:11:14,000 --> 00:11:15,920
case of self-modifying code which does

316
00:11:15,920 --> 00:11:17,839
exactly the opposite targets code

317
00:11:17,839 --> 00:11:19,279
address instead

318
00:11:19,279 --> 00:11:21,760
and this creates the allows an attacker

319
00:11:21,760 --> 00:11:24,000
to translate execute still code uh

320
00:11:24,000 --> 00:11:25,760
potentially under the control of the

321
00:11:25,760 --> 00:11:28,079
attacker and in order to understand how

322
00:11:28,079 --> 00:11:30,959
we can exploit this in a more realistic

323
00:11:30,959 --> 00:11:32,720
use case scenario we need to understand

324
00:11:32,720 --> 00:11:34,240
the attack primitive that this type of

325
00:11:34,240 --> 00:11:36,720
machine clear is actually providing us

326
00:11:36,720 --> 00:11:37,519
so

327
00:11:37,519 --> 00:11:39,200
the attack primitive is called

328
00:11:39,200 --> 00:11:42,000
speculative code store bypass and it's

329
00:11:42,000 --> 00:11:43,519
basically an

330
00:11:43,519 --> 00:11:45,120
attack primitive that allows an attacker

331
00:11:45,120 --> 00:11:45,839
to

332
00:11:45,839 --> 00:11:47,600
execute a

333
00:11:47,600 --> 00:11:49,519
control code in a transient window

334
00:11:49,519 --> 00:11:51,920
originated by a self-modifying code as

335
00:11:51,920 --> 00:11:53,360
we saw earlier

336
00:11:53,360 --> 00:11:55,519
this primitive can be broken down in

337
00:11:55,519 --> 00:11:57,680
three main steps but first

338
00:11:57,680 --> 00:11:59,600
let's keep in mind that code and data

339
00:11:59,600 --> 00:12:01,279
views are

340
00:12:01,279 --> 00:12:02,800
two different views of the same exact

341
00:12:02,800 --> 00:12:04,639
memory and they're always kept coherent

342
00:12:04,639 --> 00:12:07,279
between each other on modern processors

343
00:12:07,279 --> 00:12:08,560
so the first step of our attack

344
00:12:08,560 --> 00:12:11,279
primitive is basically we try to get the

345
00:12:11,279 --> 00:12:12,720
code of function f

346
00:12:12,720 --> 00:12:16,000
at the address of a function where the

347
00:12:16,000 --> 00:12:18,000
the code of a function g is residing in

348
00:12:18,000 --> 00:12:19,360
memory in this case

349
00:12:19,360 --> 00:12:21,279
as data as we saw because this is part

350
00:12:21,279 --> 00:12:23,519
of self-referring code program

351
00:12:23,519 --> 00:12:26,399
and this uh store of the function f will

352
00:12:26,399 --> 00:12:27,279
cause the temperature the

353
00:12:27,279 --> 00:12:28,800
synchronization between

354
00:12:28,800 --> 00:12:31,440
uh the code view and data view where in

355
00:12:31,440 --> 00:12:33,680
the code view will continue to have the

356
00:12:33,680 --> 00:12:35,120
code of function g that was already

357
00:12:35,120 --> 00:12:36,959
there and in the data view we'll have

358
00:12:36,959 --> 00:12:39,360
the new code that we just stored

359
00:12:39,360 --> 00:12:42,480
then imagine if we now try to call

360
00:12:42,480 --> 00:12:45,120
function f which we just stored

361
00:12:45,120 --> 00:12:47,440
the processor will fetch the code that

362
00:12:47,440 --> 00:12:50,240
is residing at that exact address from

363
00:12:50,240 --> 00:12:52,480
the code view from the front end so it

364
00:12:52,480 --> 00:12:53,519
will fetch

365
00:12:53,519 --> 00:12:55,260
in this case the code of function g

366
00:12:55,260 --> 00:12:57,440
[Music]

367
00:12:57,440 --> 00:13:00,560
along this transit execution of the code

368
00:13:00,560 --> 00:13:02,639
which was already running on those

369
00:13:02,639 --> 00:13:04,240
addresses in

370
00:13:04,240 --> 00:13:07,279
the code view at some point later and

371
00:13:07,279 --> 00:13:09,440
during the execution the processor will

372
00:13:09,440 --> 00:13:10,720
detect that there has been a

373
00:13:10,720 --> 00:13:13,120
self-modifying code and that it actually

374
00:13:13,120 --> 00:13:15,600
executed transiently state code and will

375
00:13:15,600 --> 00:13:17,519
eventually issue the machine clear

376
00:13:17,519 --> 00:13:19,839
flashing its pipeline from the cell code

377
00:13:19,839 --> 00:13:21,600
which is the in this case is the code of

378
00:13:21,600 --> 00:13:24,880
function g and will re-synchronize or

379
00:13:24,880 --> 00:13:26,880
restore the coherence between code view

380
00:13:26,880 --> 00:13:28,880
and data view resuming the execution

381
00:13:28,880 --> 00:13:31,279
from uh the new code that we actually

382
00:13:31,279 --> 00:13:32,560
intended to call

383
00:13:32,560 --> 00:13:36,160
in the first place which is function f

384
00:13:37,360 --> 00:13:39,760
we looked uh during our reverse

385
00:13:39,760 --> 00:13:41,760
engineering at different males one of

386
00:13:41,760 --> 00:13:44,000
them is the intel developer manual which

387
00:13:44,000 --> 00:13:46,240
is suggesting two options to handle

388
00:13:46,240 --> 00:13:48,079
self-modifying code and cross-modifying

389
00:13:48,079 --> 00:13:50,720
code and interestingly if we look at

390
00:13:50,720 --> 00:13:53,279
option one it's describing the same

391
00:13:53,279 --> 00:13:56,880
exact steps of our attack primitives so

392
00:13:56,880 --> 00:13:59,199
any software relying on option one to

393
00:13:59,199 --> 00:14:00,560
handle self-modifying code or

394
00:14:00,560 --> 00:14:02,720
cross-modifying code under the hood is

395
00:14:02,720 --> 00:14:04,639
basically creating an attack or

396
00:14:04,639 --> 00:14:07,680
performing an attack without knowing it

397
00:14:07,680 --> 00:14:10,399
in fact the two major web browsers

398
00:14:10,399 --> 00:14:13,760
firefox and chrome rely exactly on this

399
00:14:13,760 --> 00:14:16,320
option which is there is no need to

400
00:14:16,320 --> 00:14:18,240
flush the instruction cache after we

401
00:14:18,240 --> 00:14:20,079
store new code

402
00:14:20,079 --> 00:14:22,240
because they assume that the coherence

403
00:14:22,240 --> 00:14:24,639
between code view and data view is

404
00:14:24,639 --> 00:14:26,800
always maintained also on the micro

405
00:14:26,800 --> 00:14:28,320
intellectual level which is not true as

406
00:14:28,320 --> 00:14:31,199
we saw in this case so whenever chrome

407
00:14:31,199 --> 00:14:34,160
or firefox store new code

408
00:14:34,160 --> 00:14:36,959
they are actually and try to call it

409
00:14:36,959 --> 00:14:38,800
right after the store they're actually

410
00:14:38,800 --> 00:14:42,560
executing still code in the background

411
00:14:42,560 --> 00:14:45,120
in fact the use case uh like jit engines

412
00:14:45,120 --> 00:14:46,720
or web browsers in general are not the

413
00:14:46,720 --> 00:14:47,600
only

414
00:14:47,600 --> 00:14:50,240
point where we can actually uh use uh

415
00:14:50,240 --> 00:14:52,240
cell phone specialist code server bypass

416
00:14:52,240 --> 00:14:54,000
in fact um

417
00:14:54,000 --> 00:14:57,519
we can do this we can exploit this in

418
00:14:57,519 --> 00:14:59,360
web browsers operating systems

419
00:14:59,360 --> 00:15:02,639
hypervisors or generally any program

420
00:15:02,639 --> 00:15:04,959
that stores instructions or store codes

421
00:15:04,959 --> 00:15:05,920
and allows

422
00:15:05,920 --> 00:15:08,800
its execution before issuing a

423
00:15:08,800 --> 00:15:10,800
serializing instruction that will

424
00:15:10,800 --> 00:15:12,720
guarantee that there is the coherence

425
00:15:12,720 --> 00:15:15,600
between the data view and cone view is

426
00:15:15,600 --> 00:15:16,100
maintained

427
00:15:16,100 --> 00:15:18,560
[Music]

428
00:15:18,560 --> 00:15:21,360
so this is the how we can exploit an smc

429
00:15:21,360 --> 00:15:24,399
machine clear and this is the first type

430
00:15:24,399 --> 00:15:26,160
the second tab we're presenting there is

431
00:15:26,160 --> 00:15:28,880
memory ordering and it's based on a

432
00:15:28,880 --> 00:15:31,120
total store order memory model which is

433
00:15:31,120 --> 00:15:33,759
the one adopted by modern processors

434
00:15:33,759 --> 00:15:36,399
which guarantees that all cpu cores see

435
00:15:36,399 --> 00:15:38,320
all memory operations

436
00:15:38,320 --> 00:15:41,839
as the program order except in one case

437
00:15:41,839 --> 00:15:44,079
if we have a store instruction followed

438
00:15:44,079 --> 00:15:46,639
by a load instruction operating on two

439
00:15:46,639 --> 00:15:48,079
different addresses

440
00:15:48,079 --> 00:15:49,920
these two instructions might be

441
00:15:49,920 --> 00:15:52,479
reordered

442
00:15:52,720 --> 00:15:54,720
let's take a look

443
00:15:54,720 --> 00:15:56,880
um at a snippet of code that would

444
00:15:56,880 --> 00:15:59,360
clarify this so we have two processors

445
00:15:59,360 --> 00:16:02,160
two cores on a processor a we have two

446
00:16:02,160 --> 00:16:04,639
load instructions then followed by a

447
00:16:04,639 --> 00:16:07,279
function called and then on processor b

448
00:16:07,279 --> 00:16:09,600
we have two store instructions so

449
00:16:09,600 --> 00:16:11,360
following the definition of a total

450
00:16:11,360 --> 00:16:13,600
order the two loads on processor a

451
00:16:13,600 --> 00:16:15,519
cannot be reordered they have to commit

452
00:16:15,519 --> 00:16:17,759
in that specific order and processor b

453
00:16:17,759 --> 00:16:19,279
the two store instructions cannot be

454
00:16:19,279 --> 00:16:20,560
reordered between each other they have

455
00:16:20,560 --> 00:16:23,440
to commit in that specific order

456
00:16:23,440 --> 00:16:25,199
over time let's assume that the first

457
00:16:25,199 --> 00:16:27,040
load in processor a

458
00:16:27,040 --> 00:16:29,920
is low there is a cache miss it needs to

459
00:16:29,920 --> 00:16:31,920
fetch that data at address x from the

460
00:16:31,920 --> 00:16:34,800
dram again that takes time processor a

461
00:16:34,800 --> 00:16:37,120
though does not want to wait till we

462
00:16:37,120 --> 00:16:39,279
actually fetch the data from dram so

463
00:16:39,279 --> 00:16:42,000
what we will do internally it will

464
00:16:42,000 --> 00:16:44,880
execute out of order the second load on

465
00:16:44,880 --> 00:16:47,680
address y and all dependent uh

466
00:16:47,680 --> 00:16:49,839
instructions and we'll keep them in a

467
00:16:49,839 --> 00:16:51,839
state that is called ready to commit

468
00:16:51,839 --> 00:16:54,480
once the data at address x is fetched

469
00:16:54,480 --> 00:16:56,720
from memory it will execute that load

470
00:16:56,720 --> 00:16:58,560
and commit all the instructions that it

471
00:16:58,560 --> 00:17:00,720
actually executed out of order

472
00:17:00,720 --> 00:17:03,680
internally and then following which is

473
00:17:03,680 --> 00:17:06,319
following the total sort order

474
00:17:06,319 --> 00:17:08,720
but let's assume that at some point

475
00:17:08,720 --> 00:17:10,480
after the radio commit instruction have

476
00:17:10,480 --> 00:17:12,880
been executed internally on processor a

477
00:17:12,880 --> 00:17:15,839
processor b issues the exp the two store

478
00:17:15,839 --> 00:17:18,959
instructions so it's updating the value

479
00:17:18,959 --> 00:17:21,359
of x and the value of y

480
00:17:21,359 --> 00:17:23,119
at this point these

481
00:17:23,119 --> 00:17:25,280
the new values will be forwarded to the

482
00:17:25,280 --> 00:17:26,880
memory subsystem which

483
00:17:26,880 --> 00:17:29,280
again will forward these

484
00:17:29,280 --> 00:17:31,440
new values to processor a

485
00:17:31,440 --> 00:17:34,160
processor a at this point will

486
00:17:34,160 --> 00:17:36,720
cannot commit the ready

487
00:17:36,720 --> 00:17:38,160
to commit instruction that it actually

488
00:17:38,160 --> 00:17:39,919
executed previously because those

489
00:17:39,919 --> 00:17:41,919
instructions are operating on the old

490
00:17:41,919 --> 00:17:44,799
value of y it cannot commit them as is

491
00:17:44,799 --> 00:17:46,960
because otherwise it would be approved

492
00:17:46,960 --> 00:17:51,280
that it actually executed out of order

493
00:17:51,280 --> 00:17:54,000
the second load

494
00:17:54,000 --> 00:17:55,679
compared to the first load and then

495
00:17:55,679 --> 00:17:58,080
violating the memory ordering

496
00:17:58,080 --> 00:18:00,080
so internally the processor can do all

497
00:18:00,080 --> 00:18:02,720
sort of tricks to optimize execution but

498
00:18:02,720 --> 00:18:05,120
architecturally it cannot commit

499
00:18:05,120 --> 00:18:06,720
uh the rate the

500
00:18:06,720 --> 00:18:08,320
the the instructions executed out of

501
00:18:08,320 --> 00:18:10,400
order which in this case the load on y

502
00:18:10,400 --> 00:18:13,200
in all dependent operations um

503
00:18:13,200 --> 00:18:14,960
otherwise it would be violating so it

504
00:18:14,960 --> 00:18:17,039
has to flush them consider the new value

505
00:18:17,039 --> 00:18:20,000
of y re-execute them and then commit

506
00:18:20,000 --> 00:18:21,919
still following the program's order

507
00:18:21,919 --> 00:18:26,799
otherwise uh in order to follow the tso

508
00:18:27,120 --> 00:18:28,960
so as we can see here the architectural

509
00:18:28,960 --> 00:18:30,640
environment is that out of order

510
00:18:30,640 --> 00:18:33,200
execution always complies with the total

511
00:18:33,200 --> 00:18:36,000
soul order memory model and this can be

512
00:18:36,000 --> 00:18:38,080
violated in the case of a memory or the

513
00:18:38,080 --> 00:18:40,400
memory ordering machine clear

514
00:18:40,400 --> 00:18:42,640
and this creates again allows an

515
00:18:42,640 --> 00:18:44,880
attacker to transiently leak style data

516
00:18:44,880 --> 00:18:47,039
which in this case was the old value

517
00:18:47,039 --> 00:18:49,280
contained at the address y that was

518
00:18:49,280 --> 00:18:51,200
loaded out of order

519
00:18:51,200 --> 00:18:52,720
um in order to exploit this type of

520
00:18:52,720 --> 00:18:55,120
machine clear there is

521
00:18:55,120 --> 00:18:57,360
a very strict synchronization

522
00:18:57,360 --> 00:18:59,520
requirement here between the two cores

523
00:18:59,520 --> 00:19:01,200
which makes exploitation not very

524
00:19:01,200 --> 00:19:03,679
trivial

525
00:19:03,840 --> 00:19:05,440
now we'll see the other types of machine

526
00:19:05,440 --> 00:19:08,799
clear that we're presenting

527
00:19:09,120 --> 00:19:12,080
thank you so now things get uh i will

528
00:19:12,080 --> 00:19:14,320
say strange i mean speculation using

529
00:19:14,320 --> 00:19:15,760
floating points

530
00:19:15,760 --> 00:19:17,919
let's see why

531
00:19:17,919 --> 00:19:19,840
again um

532
00:19:19,840 --> 00:19:21,600
so in the i3 police standard for

533
00:19:21,600 --> 00:19:23,039
floating points

534
00:19:23,039 --> 00:19:25,200
they decided to add a special

535
00:19:25,200 --> 00:19:26,559
representation for floating point

536
00:19:26,559 --> 00:19:29,760
numbers that are called subnormal

537
00:19:29,760 --> 00:19:31,760
and they are used to represent very

538
00:19:31,760 --> 00:19:34,160
small numbers below

539
00:19:34,160 --> 00:19:36,080
that number there for the double

540
00:19:36,080 --> 00:19:39,039
representation

541
00:19:39,039 --> 00:19:41,520
again to better explain this let's have

542
00:19:41,520 --> 00:19:43,280
a look an example

543
00:19:43,280 --> 00:19:45,520
a simple floating point division

544
00:19:45,520 --> 00:19:49,200
followed by a floating point addition

545
00:19:49,200 --> 00:19:50,720
and

546
00:19:50,720 --> 00:19:52,799
here the issue is that the hardware the

547
00:19:52,799 --> 00:19:54,640
floating point unit

548
00:19:54,640 --> 00:19:56,559
is not capable of handling such a

549
00:19:56,559 --> 00:19:58,400
strange representation

550
00:19:58,400 --> 00:20:00,480
so whenever you perform a 14-point

551
00:20:00,480 --> 00:20:04,080
operation the processor will blindly

552
00:20:04,080 --> 00:20:06,880
believe that operands and the results

553
00:20:06,880 --> 00:20:09,280
will reside in the normal floating point

554
00:20:09,280 --> 00:20:11,600
representation

555
00:20:11,600 --> 00:20:12,559
so

556
00:20:12,559 --> 00:20:15,440
the processor again here the fpu will

557
00:20:15,440 --> 00:20:17,520
blindly compute the division results and

558
00:20:17,520 --> 00:20:21,200
send it to the subsequent operation

559
00:20:21,200 --> 00:20:23,039
but let's say that actually the floating

560
00:20:23,039 --> 00:20:25,600
point division result is a sub normal

561
00:20:25,600 --> 00:20:26,799
number

562
00:20:26,799 --> 00:20:29,919
the fpu will detect this later and must

563
00:20:29,919 --> 00:20:31,039
warn the

564
00:20:31,039 --> 00:20:34,320
cpu pipeline to stop the execution

565
00:20:34,320 --> 00:20:38,080
because the fpu provided a wrong result

566
00:20:38,080 --> 00:20:39,440
so

567
00:20:39,440 --> 00:20:41,280
here for example instruction in red will

568
00:20:41,280 --> 00:20:43,840
be removed from the pipeline

569
00:20:43,840 --> 00:20:46,400
the processor will compute the floating

570
00:20:46,400 --> 00:20:48,400
point division

571
00:20:48,400 --> 00:20:50,080
interestingly in software not in

572
00:20:50,080 --> 00:20:51,520
hardware because again

573
00:20:51,520 --> 00:20:53,919
the arduino is capable so the there is a

574
00:20:53,919 --> 00:20:56,400
microcode assist injecting microbes to

575
00:20:56,400 --> 00:20:59,039
perform the division in software

576
00:20:59,039 --> 00:21:01,360
and then only after that the correct

577
00:21:01,360 --> 00:21:03,600
result will be provided to subsequent

578
00:21:03,600 --> 00:21:04,799
instruction

579
00:21:04,799 --> 00:21:06,159
that's also why this floating point

580
00:21:06,159 --> 00:21:07,440
operation are

581
00:21:07,440 --> 00:21:11,280
way longer compared to the standard ones

582
00:21:11,280 --> 00:21:13,120
so here we saw that the floating point

583
00:21:13,120 --> 00:21:14,799
units

584
00:21:14,799 --> 00:21:16,559
let's say blindly operates on normal

585
00:21:16,559 --> 00:21:18,320
numbers this makes sense because

586
00:21:18,320 --> 00:21:20,799
implementing in order of uh let's say a

587
00:21:20,799 --> 00:21:22,159
floating point you need that angles

588
00:21:22,159 --> 00:21:23,520
abnormal would be

589
00:21:23,520 --> 00:21:25,600
way more complex

590
00:21:25,600 --> 00:21:27,520
and to violate this environment is super

591
00:21:27,520 --> 00:21:29,760
simple you just need to perform a

592
00:21:29,760 --> 00:21:31,679
floating point division or a place a

593
00:21:31,679 --> 00:21:33,440
floating point operation

594
00:21:33,440 --> 00:21:36,720
that uses subnormal numbers

595
00:21:36,720 --> 00:21:38,400
and the security implication as you're

596
00:21:38,400 --> 00:21:39,520
going to see

597
00:21:39,520 --> 00:21:42,159
is that an attacker can transitly inject

598
00:21:42,159 --> 00:21:44,559
arbitrary values

599
00:21:44,559 --> 00:21:46,559
here on the red instructions on the

600
00:21:46,559 --> 00:21:48,640
subsequent instruction

601
00:21:48,640 --> 00:21:51,520
and how can we exploit this

602
00:21:51,520 --> 00:21:52,240
so

603
00:21:52,240 --> 00:21:54,320
here we managed to build an intent

604
00:21:54,320 --> 00:21:57,840
exploit on firefox

605
00:21:57,840 --> 00:21:59,760
okay here we start by showing just the

606
00:21:59,760 --> 00:22:01,919
setup of the of the attack

607
00:22:01,919 --> 00:22:04,240
on the left we have the victim page on a

608
00:22:04,240 --> 00:22:06,720
different origin compared to an attacker

609
00:22:06,720 --> 00:22:08,880
a frame so suppose that the right part

610
00:22:08,880 --> 00:22:13,640
is a advertisement something like that

611
00:22:13,919 --> 00:22:16,720
so before i said an attacker can inject

612
00:22:16,720 --> 00:22:19,520
transiently arbitrary values

613
00:22:19,520 --> 00:22:20,480
so

614
00:22:20,480 --> 00:22:22,400
with a bit of brute forcing

615
00:22:22,400 --> 00:22:24,880
we managed to find well to create a tool

616
00:22:24,880 --> 00:22:27,120
that we named the find operands where

617
00:22:27,120 --> 00:22:29,840
you provide a value that you want to see

618
00:22:29,840 --> 00:22:31,280
on the speculative results of the

619
00:22:31,280 --> 00:22:32,799
floating point unit

620
00:22:32,799 --> 00:22:35,440
and the tool will magically give you

621
00:22:35,440 --> 00:22:37,360
the results

622
00:22:37,360 --> 00:22:39,760
also we built a test operand tool where

623
00:22:39,760 --> 00:22:41,919
basically provide x and y

624
00:22:41,919 --> 00:22:43,360
is going to perform the division which

625
00:22:43,360 --> 00:22:45,600
is these two numbers for example

626
00:22:45,600 --> 00:22:48,880
by dividing uh minus 1.6

627
00:22:48,880 --> 00:22:50,320
uh by

628
00:22:50,320 --> 00:22:51,840
4.9

629
00:22:51,840 --> 00:22:55,679
to the power of minus three four

630
00:22:55,679 --> 00:22:57,280
so the orchestral results the one that

631
00:22:57,280 --> 00:22:58,720
you actually see let's say on your

632
00:22:58,720 --> 00:23:01,120
calculator will be minus infinity that

633
00:23:01,120 --> 00:23:02,240
makes sense

634
00:23:02,240 --> 00:23:04,720
but transiently speculatively the

635
00:23:04,720 --> 00:23:06,960
results will be completely different and

636
00:23:06,960 --> 00:23:10,159
as you can see the that beef value that

637
00:23:10,159 --> 00:23:11,840
we wanted is exactly

638
00:23:11,840 --> 00:23:14,400
there on the speculative result so an

639
00:23:14,400 --> 00:23:16,480
attacker can control

640
00:23:16,480 --> 00:23:19,120
what will be the speculative result

641
00:23:19,120 --> 00:23:21,360
also notice that the upper bits are set

642
00:23:21,360 --> 00:23:23,280
to fffb

643
00:23:23,280 --> 00:23:24,960
why

644
00:23:24,960 --> 00:23:27,760
because uh dynamically typed languages

645
00:23:27,760 --> 00:23:30,080
like javascript in firefox use an

646
00:23:30,080 --> 00:23:31,440
unboxing

647
00:23:31,440 --> 00:23:33,200
an unboxing in a nutshell is

648
00:23:33,200 --> 00:23:34,960
representing every variable as a

649
00:23:34,960 --> 00:23:36,640
floating point numbers

650
00:23:36,640 --> 00:23:38,000
it sounds strange but actually it makes

651
00:23:38,000 --> 00:23:39,280
sense so

652
00:23:39,280 --> 00:23:40,799
the upper bits

653
00:23:40,799 --> 00:23:43,039
are used for the type of the variable

654
00:23:43,039 --> 00:23:46,559
indeed in this case fffb means

655
00:23:46,559 --> 00:23:48,960
this is a string variable

656
00:23:48,960 --> 00:23:52,159
while the bottom beats the that bf000 is

657
00:23:52,159 --> 00:23:54,559
the payload pointer so

658
00:23:54,559 --> 00:23:55,360
uh

659
00:23:55,360 --> 00:23:58,080
this single 64-bit means you have a

660
00:23:58,080 --> 00:24:01,279
string at this address okay

661
00:24:01,279 --> 00:24:03,120
and now i think you start to see where

662
00:24:03,120 --> 00:24:04,400
the exploits

663
00:24:04,400 --> 00:24:05,679
is coming up

664
00:24:05,679 --> 00:24:08,000
so if we use the

665
00:24:08,000 --> 00:24:10,080
x and y parameters that we generated

666
00:24:10,080 --> 00:24:11,279
before

667
00:24:11,279 --> 00:24:14,080
and we ask the javascript engine look

668
00:24:14,080 --> 00:24:16,559
is the output of the division a string

669
00:24:16,559 --> 00:24:19,120
specifically the processor will say yes

670
00:24:19,120 --> 00:24:20,960
it is a string indeed

671
00:24:20,960 --> 00:24:23,679
and it will execute the red branch but

672
00:24:23,679 --> 00:24:26,559
obviously the division of a result sorry

673
00:24:26,559 --> 00:24:28,640
the result of a division is always a

674
00:24:28,640 --> 00:24:31,279
number uh floating point numbers okay so

675
00:24:31,279 --> 00:24:33,279
architecturally we'll execute the s

676
00:24:33,279 --> 00:24:34,480
branch

677
00:24:34,480 --> 00:24:36,960
but again speculatively it's too late we

678
00:24:36,960 --> 00:24:39,520
convinced javascript the division result

679
00:24:39,520 --> 00:24:41,520
is a

680
00:24:41,520 --> 00:24:42,400
string

681
00:24:42,400 --> 00:24:44,240
we control the pointer

682
00:24:44,240 --> 00:24:47,600
so game over uh by accessing for example

683
00:24:47,600 --> 00:24:49,520
delaying attributes of the string we are

684
00:24:49,520 --> 00:24:52,640
actually reading arbitrary memory

685
00:24:52,640 --> 00:24:54,799
and again using the flasher also a

686
00:24:54,799 --> 00:24:56,960
standard site channel we can leak

687
00:24:56,960 --> 00:25:00,159
arbitrary memory

688
00:25:00,159 --> 00:25:02,880
one last step for completing the attack

689
00:25:02,880 --> 00:25:04,960
is to break e to break xlr because okay

690
00:25:04,960 --> 00:25:06,559
we have a nice primitive we can leak

691
00:25:06,559 --> 00:25:08,080
arbitrary memory

692
00:25:08,080 --> 00:25:10,000
but what are we going to leak we don't

693
00:25:10,000 --> 00:25:12,720
know the address and here again a good

694
00:25:12,720 --> 00:25:14,480
it's a superpower of

695
00:25:14,480 --> 00:25:16,799
transit attacks that you cannot crush

696
00:25:16,799 --> 00:25:19,200
firefox you simply start

697
00:25:19,200 --> 00:25:21,360
reading all the addresses until you see

698
00:25:21,360 --> 00:25:24,000
something that you recognize so

699
00:25:24,000 --> 00:25:26,480
we spray the firefox process memory with

700
00:25:26,480 --> 00:25:29,440
one gigabyte of known variables and

701
00:25:29,440 --> 00:25:31,200
sorry a fixed value

702
00:25:31,200 --> 00:25:33,200
and then we scan all the member until we

703
00:25:33,200 --> 00:25:35,200
see our constant value

704
00:25:35,200 --> 00:25:38,159
and then by slowly going up we are going

705
00:25:38,159 --> 00:25:39,360
to

706
00:25:39,360 --> 00:25:42,559
find the address of the secret that we

707
00:25:42,559 --> 00:25:44,240
are looking for

708
00:25:44,240 --> 00:25:45,919
so we also made a

709
00:25:45,919 --> 00:25:48,880
video to show the poc solid exploit

710
00:25:48,880 --> 00:25:50,559
going on

711
00:25:50,559 --> 00:25:52,720
again we start by spraying the memory

712
00:25:52,720 --> 00:25:55,200
because we need to break slr

713
00:25:55,200 --> 00:25:56,960
if i remember quality was one gigabyte

714
00:25:56,960 --> 00:25:58,159
of

715
00:25:58,159 --> 00:25:59,520
a

716
00:25:59,520 --> 00:26:01,840
allocated in javascript

717
00:26:01,840 --> 00:26:03,679
then we start a coarse grained patent

718
00:26:03,679 --> 00:26:05,760
search so we lick every address after

719
00:26:05,760 --> 00:26:08,400
one gigabyte one gigabyte one gigabyte

720
00:26:08,400 --> 00:26:10,400
after a bit we find our constant

721
00:26:10,400 --> 00:26:11,360
pattern

722
00:26:11,360 --> 00:26:14,640
then we do the fine grained

723
00:26:14,640 --> 00:26:17,039
search to find the end of this

724
00:26:17,039 --> 00:26:19,360
spread memory

725
00:26:19,360 --> 00:26:22,000
and after that we break a slr

726
00:26:22,000 --> 00:26:24,240
and now we are leaking all the process

727
00:26:24,240 --> 00:26:26,720
sorry the process memory of firefox and

728
00:26:26,720 --> 00:26:28,240
here we are just printing let's say

729
00:26:28,240 --> 00:26:29,840
meaningful text

730
00:26:29,840 --> 00:26:33,200
and after a bit you will exactly

731
00:26:33,200 --> 00:26:35,440
here you see we are linking the victim

732
00:26:35,440 --> 00:26:37,200
page memory

733
00:26:37,200 --> 00:26:38,880
and here please

734
00:26:38,880 --> 00:26:39,760
uh

735
00:26:39,760 --> 00:26:42,240
think about it so

736
00:26:42,240 --> 00:26:44,240
from a floating point division

737
00:26:44,240 --> 00:26:46,000
we confused javascript there was a

738
00:26:46,000 --> 00:26:46,880
string

739
00:26:46,880 --> 00:26:49,440
and finally leaky memory this is kind of

740
00:26:49,440 --> 00:26:52,799
my blowing to to me at least

741
00:26:52,799 --> 00:26:55,440
and also if you run exploit uh for a bit

742
00:26:55,440 --> 00:26:56,799
more

743
00:26:56,799 --> 00:26:59,039
you are going to leak also

744
00:26:59,039 --> 00:27:00,960
javascript code that we didn't ride i

745
00:27:00,960 --> 00:27:02,480
don't know is uh

746
00:27:02,480 --> 00:27:04,400
is clearly javascript called but yeah

747
00:27:04,400 --> 00:27:06,159
you leak basically you can lick all the

748
00:27:06,159 --> 00:27:07,520
firefox memory

749
00:27:07,520 --> 00:27:10,960
cookies or whatsoever

750
00:27:11,360 --> 00:27:13,200
okay let's go

751
00:27:13,200 --> 00:27:14,240
okay

752
00:27:14,240 --> 00:27:17,679
to conclude on fbi fpvi so the exploit

753
00:27:17,679 --> 00:27:20,080
that you saw at a leak rate of around 13

754
00:27:20,080 --> 00:27:22,000
kilobytes per second that is a quite

755
00:27:22,000 --> 00:27:25,200
high for this kind of attacks

756
00:27:27,039 --> 00:27:29,679
wait a second

757
00:27:31,760 --> 00:27:35,559
yes lights are hard

758
00:27:38,000 --> 00:27:40,399
not from the beginning

759
00:27:40,399 --> 00:27:43,840
ah sorry just one second

760
00:27:43,840 --> 00:27:45,360
this will help you refreshing all the

761
00:27:45,360 --> 00:27:48,360
contents

762
00:27:48,640 --> 00:27:50,480
i know wait if i start the video again

763
00:27:50,480 --> 00:27:53,520
maybe it will be an issue

764
00:27:55,200 --> 00:27:57,120
we were

765
00:27:57,120 --> 00:27:59,919
here nice

766
00:27:59,919 --> 00:28:03,440
okay so uh what about the mitigation so

767
00:28:03,440 --> 00:28:05,520
the obvious one is to disable this

768
00:28:05,520 --> 00:28:07,840
abnormal representation

769
00:28:07,840 --> 00:28:09,600
but people don't like this solution

770
00:28:09,600 --> 00:28:11,600
because there are actually software

771
00:28:11,600 --> 00:28:15,039
relying on this special representation

772
00:28:15,039 --> 00:28:17,200
of floating point numbers

773
00:28:17,200 --> 00:28:20,080
we also implemented a compiler pass to

774
00:28:20,080 --> 00:28:22,480
kill the speculative window when we

775
00:28:22,480 --> 00:28:24,399
detect this type of gadgets

776
00:28:24,399 --> 00:28:28,480
and we get a 53 percent override

777
00:28:28,480 --> 00:28:30,799
well actually the let's say concrete

778
00:28:30,799 --> 00:28:33,279
solution that browser vendors used are

779
00:28:33,279 --> 00:28:35,679
either a set isolation so you cannot

780
00:28:35,679 --> 00:28:38,000
leak outside your process memory

781
00:28:38,000 --> 00:28:40,640
and firefox actually implemented um

782
00:28:40,640 --> 00:28:42,399
mitigation where whenever you do a

783
00:28:42,399 --> 00:28:43,760
floating point

784
00:28:43,760 --> 00:28:44,960
operation

785
00:28:44,960 --> 00:28:46,159
they are

786
00:28:46,159 --> 00:28:47,520
masking

787
00:28:47,520 --> 00:28:50,000
the upper bits so they ensure that even

788
00:28:50,000 --> 00:28:52,159
transmitter you cannot generate a

789
00:28:52,159 --> 00:28:53,600
non-box at the

790
00:28:53,600 --> 00:28:56,158
variables

791
00:28:56,320 --> 00:28:58,480
okay now the last type of machine clear

792
00:28:58,480 --> 00:29:01,440
i i promise it will be short

793
00:29:01,440 --> 00:29:02,720
um

794
00:29:02,720 --> 00:29:04,799
so when our instruction is following a

795
00:29:04,799 --> 00:29:06,559
story instruction which destination

796
00:29:06,559 --> 00:29:08,960
address is not ready yet

797
00:29:08,960 --> 00:29:10,720
the memory is navigation unit predicts

798
00:29:10,720 --> 00:29:13,600
whether the instruction are aliasing

799
00:29:13,600 --> 00:29:14,799
or not

800
00:29:14,799 --> 00:29:17,679
again an example to better clarify this

801
00:29:17,679 --> 00:29:20,480
we have a store and then a load

802
00:29:20,480 --> 00:29:22,080
let's say that for some reason the store

803
00:29:22,080 --> 00:29:24,240
address is unknown it's coming from a

804
00:29:24,240 --> 00:29:26,399
complex mathematical operation from dram

805
00:29:26,399 --> 00:29:28,799
who knows

806
00:29:28,799 --> 00:29:29,679
so

807
00:29:29,679 --> 00:29:32,480
the processor would ask to a predictor

808
00:29:32,480 --> 00:29:34,720
look i would like starting performing

809
00:29:34,720 --> 00:29:36,399
the load but i don't know the others for

810
00:29:36,399 --> 00:29:38,399
the previous store so

811
00:29:38,399 --> 00:29:40,399
i don't know what to do

812
00:29:40,399 --> 00:29:41,840
what should i do like uh are you

813
00:29:41,840 --> 00:29:43,200
predicting that the addresses are

814
00:29:43,200 --> 00:29:44,480
different

815
00:29:44,480 --> 00:29:46,240
oh so that they can

816
00:29:46,240 --> 00:29:48,399
perform them out of order

817
00:29:48,399 --> 00:29:50,159
let's say that the predictor is called

818
00:29:50,159 --> 00:29:52,640
memories immigration uh unit

819
00:29:52,640 --> 00:29:54,960
they predict uh you can go ahead let's

820
00:29:54,960 --> 00:29:56,799
perform the load even before the store

821
00:29:56,799 --> 00:29:58,559
the the other cities are not allowing

822
00:29:58,559 --> 00:30:00,640
are different

823
00:30:00,640 --> 00:30:02,320
and then the cpu will be quite happy and

824
00:30:02,320 --> 00:30:04,320
it will uh perform the proportion of the

825
00:30:04,320 --> 00:30:05,919
folder

826
00:30:05,919 --> 00:30:08,320
uh but let's say that actually the

827
00:30:08,320 --> 00:30:10,320
addresses were the same there was a

828
00:30:10,320 --> 00:30:11,600
misprediction

829
00:30:11,600 --> 00:30:14,799
so the processor loaded the stale data

830
00:30:14,799 --> 00:30:17,039
so obviously now must load the hello

831
00:30:17,039 --> 00:30:20,480
value the freshly new written value

832
00:30:20,480 --> 00:30:21,360
so

833
00:30:21,360 --> 00:30:24,320
here the attacker can

834
00:30:24,320 --> 00:30:25,279
let's say

835
00:30:25,279 --> 00:30:27,919
perform a transient load where it reads

836
00:30:27,919 --> 00:30:30,640
stale data

837
00:30:30,640 --> 00:30:32,880
here in variant is that the predictor

838
00:30:32,880 --> 00:30:35,279
unit never make a mistake so always

839
00:30:35,279 --> 00:30:37,840
disambiguate correctly

840
00:30:37,840 --> 00:30:39,919
to relate this you need to

841
00:30:39,919 --> 00:30:42,640
mess up a bit with the predictor to

842
00:30:42,640 --> 00:30:45,200
induce a misprediction

843
00:30:45,200 --> 00:30:46,799
the implication is that

844
00:30:46,799 --> 00:30:50,480
the processor leak still data and for

845
00:30:50,480 --> 00:30:52,799
exploitation

846
00:30:52,799 --> 00:30:54,720
this was known as a spectral variant for

847
00:30:54,720 --> 00:30:57,360
speculative strawberry pass

848
00:30:57,360 --> 00:30:59,519
so some exploits are already available

849
00:30:59,519 --> 00:31:00,240
and

850
00:31:00,240 --> 00:31:02,159
here we are categorizing as intel

851
00:31:02,159 --> 00:31:04,640
suggesting the manual as a machine clear

852
00:31:04,640 --> 00:31:07,519
rather than a spectra

853
00:31:07,519 --> 00:31:10,240
attack variant

854
00:31:10,720 --> 00:31:12,480
today we presented for machine clear but

855
00:31:12,480 --> 00:31:14,559
obviously there are many more

856
00:31:14,559 --> 00:31:17,679
like a conditionally masked move some

857
00:31:17,679 --> 00:31:20,080
exception the interrupts other micro

858
00:31:20,080 --> 00:31:21,600
could assist

859
00:31:21,600 --> 00:31:22,960
but for that we are not bothering you

860
00:31:22,960 --> 00:31:24,640
too much today if you want you can

861
00:31:24,640 --> 00:31:26,799
bother yourself by reading our paper

862
00:31:26,799 --> 00:31:28,000
so

863
00:31:28,000 --> 00:31:29,279
if you want more information please have

864
00:31:29,279 --> 00:31:30,720
a look

865
00:31:30,720 --> 00:31:32,399
and now

866
00:31:32,399 --> 00:31:35,039
let's look at the results okay

867
00:31:35,039 --> 00:31:37,360
so we've seen very many types of machine

868
00:31:37,360 --> 00:31:39,440
clear so let's take a look of what we

869
00:31:39,440 --> 00:31:42,320
saw so far so a self-modifying code

870
00:31:42,320 --> 00:31:44,640
modifying instructions and therefore

871
00:31:44,640 --> 00:31:46,559
executing still code

872
00:31:46,559 --> 00:31:48,799
memory ordering violation of the memory

873
00:31:48,799 --> 00:31:51,679
model and therefore leaking stereo

874
00:31:51,679 --> 00:31:53,519
stable data

875
00:31:53,519 --> 00:31:55,440
performing a floating point

876
00:31:55,440 --> 00:31:59,039
operation injecting wrong results and

877
00:31:59,039 --> 00:32:02,320
manipulating the control flow

878
00:32:02,320 --> 00:32:05,039
and the last one is mary's ambiguation

879
00:32:05,039 --> 00:32:06,080
which is

880
00:32:06,080 --> 00:32:09,440
leaking still data by mistraining a

881
00:32:09,440 --> 00:32:11,840
predictor

882
00:32:11,840 --> 00:32:13,760
let's see how these types of machine

883
00:32:13,760 --> 00:32:16,000
clear perform compared to all previous

884
00:32:16,000 --> 00:32:18,080
known root causes of trans execution

885
00:32:18,080 --> 00:32:19,120
that have been

886
00:32:19,120 --> 00:32:22,240
widely used in previous attacks

887
00:32:22,240 --> 00:32:24,960
so here are some numbers

888
00:32:24,960 --> 00:32:26,880
in short on the x-axis we have the

889
00:32:26,880 --> 00:32:28,399
different

890
00:32:28,399 --> 00:32:31,360
mechanisms to create transit execution

891
00:32:31,360 --> 00:32:32,480
paths

892
00:32:32,480 --> 00:32:34,880
and on the y-axis we have two

893
00:32:34,880 --> 00:32:37,440
metrics the top plot is representing the

894
00:32:37,440 --> 00:32:38,720
number of

895
00:32:38,720 --> 00:32:41,840
loads that fit inside a single transient

896
00:32:41,840 --> 00:32:44,480
window created by the different

897
00:32:44,480 --> 00:32:46,799
mechanisms and the bottom plot is

898
00:32:46,799 --> 00:32:48,480
showing how can we leak what is the

899
00:32:48,480 --> 00:32:51,840
leakage rate with a specific mechanism

900
00:32:51,840 --> 00:32:53,279
here we're using the flush and reload

901
00:32:53,279 --> 00:32:55,600
attack as the architectural upper limit

902
00:32:55,600 --> 00:32:58,960
for a leakage rate which is the attack

903
00:32:58,960 --> 00:33:01,120
that we saw in the first slide as a site

904
00:33:01,120 --> 00:33:03,200
channel

905
00:33:03,200 --> 00:33:06,159
here we have tsx phd and false those are

906
00:33:06,159 --> 00:33:08,799
the the three main

907
00:33:08,799 --> 00:33:11,039
mechanisms that were used before this

908
00:33:11,039 --> 00:33:13,519
work to create a transient uh execution

909
00:33:13,519 --> 00:33:14,320
path

910
00:33:14,320 --> 00:33:18,000
and uh now uh i mean tsx is only

911
00:33:18,000 --> 00:33:20,240
available on intel and it's not

912
00:33:20,240 --> 00:33:24,320
supported anymore uh on recent cpus and

913
00:33:24,320 --> 00:33:25,679
therefore

914
00:33:25,679 --> 00:33:27,919
until this work everyone was left with

915
00:33:27,919 --> 00:33:30,240
mistraining and branching suitable so

916
00:33:30,240 --> 00:33:32,080
another type of

917
00:33:32,080 --> 00:33:34,320
predictor or causing a fault those were

918
00:33:34,320 --> 00:33:36,399
the two ways of creating stranded

919
00:33:36,399 --> 00:33:38,960
execution paths but now with this work

920
00:33:38,960 --> 00:33:41,919
we have uh many more and they're also

921
00:33:41,919 --> 00:33:43,760
available on amd

922
00:33:43,760 --> 00:33:45,440
so it gives

923
00:33:45,440 --> 00:33:49,360
it widens the attack surface with this

924
00:33:49,360 --> 00:33:52,399
with these new discoveries

925
00:33:52,399 --> 00:33:54,399
sorry to interrupt uh just before you

926
00:33:54,399 --> 00:33:55,679
carry on i just want to make a quick

927
00:33:55,679 --> 00:33:57,679
announcement there's the

928
00:33:57,679 --> 00:33:59,279
because we're running late

929
00:33:59,279 --> 00:34:01,200
the next talk in the room if you want to

930
00:34:01,200 --> 00:34:04,159
watch the atm talk after this one is

931
00:34:04,159 --> 00:34:05,760
going to be delayed until this is

932
00:34:05,760 --> 00:34:07,519
finished so we don't anyone who wants to

933
00:34:07,519 --> 00:34:10,239
do that doesn't have to rush off now so

934
00:34:10,239 --> 00:34:12,079
sorry to interrupt you

935
00:34:12,079 --> 00:34:15,440
so as we can see here we have uh in

936
00:34:15,440 --> 00:34:18,000
we have the a transient window created

937
00:34:18,000 --> 00:34:20,399
by a self-modifying code inside that

938
00:34:20,399 --> 00:34:22,800
window we we were able to measure more

939
00:34:22,800 --> 00:34:24,800
than 160

940
00:34:24,800 --> 00:34:28,000
loads executed inside a single window

941
00:34:28,000 --> 00:34:30,960
these are 160 loads that will not will

942
00:34:30,960 --> 00:34:34,879
never commit will not be seen at an

943
00:34:34,879 --> 00:34:36,719
architectural program execution so we

944
00:34:36,719 --> 00:34:39,280
have 160 loads doing something in the

945
00:34:39,280 --> 00:34:42,320
background that will not be observed um

946
00:34:42,320 --> 00:34:45,760
if not through a side channel

947
00:34:45,760 --> 00:34:47,520
and the other thing is when it comes to

948
00:34:47,520 --> 00:34:50,239
a leakage rate with a floating point uh

949
00:34:50,239 --> 00:34:53,280
machine clear we're able to reach

950
00:34:53,280 --> 00:34:56,079
more than 4 megabits per second and this

951
00:34:56,079 --> 00:34:59,599
is thanks to the determinism of this

952
00:34:59,599 --> 00:35:01,200
type of machine clear which does not

953
00:35:01,200 --> 00:35:03,280
require to mistrain a predictor and try

954
00:35:03,280 --> 00:35:05,280
again it's

955
00:35:05,280 --> 00:35:07,359
defined like once you have x and y you

956
00:35:07,359 --> 00:35:09,280
perform whatever flowing point operation

957
00:35:09,280 --> 00:35:11,359
you want you're good to go and you're

958
00:35:11,359 --> 00:35:12,560
sure that

959
00:35:12,560 --> 00:35:17,640
you will create a transit execution path

960
00:35:17,760 --> 00:35:20,079
finally and is the last thing is that we

961
00:35:20,079 --> 00:35:23,040
try to classify all these types of root

962
00:35:23,040 --> 00:35:25,839
causes that we could use to

963
00:35:25,839 --> 00:35:28,240
create a transient execution path and we

964
00:35:28,240 --> 00:35:31,119
start from the definition that we found

965
00:35:31,119 --> 00:35:33,119
in different patents and manuals which

966
00:35:33,119 --> 00:35:35,760
is from bad speculation which is again

967
00:35:35,760 --> 00:35:36,560
the

968
00:35:36,560 --> 00:35:38,720
highest hierarchy defining this behavior

969
00:35:38,720 --> 00:35:40,800
we have two classes control flows

970
00:35:40,800 --> 00:35:42,480
prediction and database prediction which

971
00:35:42,480 --> 00:35:45,040
basically highlight are we mispredicting

972
00:35:45,040 --> 00:35:47,760
or speculating over code or are we

973
00:35:47,760 --> 00:35:49,680
speculating over data

974
00:35:49,680 --> 00:35:51,359
and

975
00:35:51,359 --> 00:35:53,200
under each class we have the

976
00:35:53,200 --> 00:35:54,560
corresponding

977
00:35:54,560 --> 00:35:56,320
subclasses with the corresponding

978
00:35:56,320 --> 00:35:58,320
predictors while control forms

979
00:35:58,320 --> 00:36:01,119
predictions are filled attempts to

980
00:36:01,119 --> 00:36:03,520
operate or fail attempts to guess what

981
00:36:03,520 --> 00:36:04,720
are the next instructions that we're

982
00:36:04,720 --> 00:36:07,520
going to execute through the different

983
00:36:07,520 --> 00:36:09,920
predictors data misprediction are failed

984
00:36:09,920 --> 00:36:12,800
attempts to operate on data that has not

985
00:36:12,800 --> 00:36:15,839
validated yet has not been validated yet

986
00:36:15,839 --> 00:36:17,680
and then we have another subclass

987
00:36:17,680 --> 00:36:19,119
belonging to database prediction which

988
00:36:19,119 --> 00:36:21,520
is called exception which represents all

989
00:36:21,520 --> 00:36:23,359
the architectural exceptions that has

990
00:36:23,359 --> 00:36:26,320
been widely used in previous trans

991
00:36:26,320 --> 00:36:28,960
execution attacks and then we created a

992
00:36:28,960 --> 00:36:31,040
new subclass which is called likely

993
00:36:31,040 --> 00:36:33,200
invariant violations which represents

994
00:36:33,200 --> 00:36:35,359
all those architectural environment that

995
00:36:35,359 --> 00:36:37,680
usually hold about occasionally fail as

996
00:36:37,680 --> 00:36:39,680
we saw earlier in the case of floating

997
00:36:39,680 --> 00:36:41,359
point or an smc for example in the

998
00:36:41,359 --> 00:36:42,720
floating point as long as you're

999
00:36:42,720 --> 00:36:45,040
providing normal numbers everything goes

1000
00:36:45,040 --> 00:36:47,359
well but as as soon as you provide the

1001
00:36:47,359 --> 00:36:49,040
normal numbers or subnormal numbers

1002
00:36:49,040 --> 00:36:50,800
things break and that's when the invent

1003
00:36:50,800 --> 00:36:52,240
is violated

1004
00:36:52,240 --> 00:36:54,160
finally we have the last last class

1005
00:36:54,160 --> 00:36:55,680
which represents interrupts and more

1006
00:36:55,680 --> 00:36:57,599
specifically hardware interprets that we

1007
00:36:57,599 --> 00:36:59,359
observed also creating trends in the

1008
00:36:59,359 --> 00:37:01,119
execution path you can read more about

1009
00:37:01,119 --> 00:37:04,000
this in in the paper

1010
00:37:04,000 --> 00:37:06,560
so we disclosed fpvi and csb to all

1011
00:37:06,560 --> 00:37:08,240
major cpu browser operating system

1012
00:37:08,240 --> 00:37:11,839
vendors in earlier this year and

1013
00:37:11,839 --> 00:37:14,160
we were informed that on intel for

1014
00:37:14,160 --> 00:37:17,280
example both fpvi and csb are affecting

1015
00:37:17,280 --> 00:37:20,560
all intel cores and intel processors

1016
00:37:20,560 --> 00:37:22,800
same thing is valid also for amd except

1017
00:37:22,800 --> 00:37:25,280
that in the case of fbi uh we couldn't

1018
00:37:25,280 --> 00:37:27,200
find an x and y that were actually

1019
00:37:27,200 --> 00:37:28,560
exploitable

1020
00:37:28,560 --> 00:37:30,960
but we were able still to inject an

1021
00:37:30,960 --> 00:37:33,119
arbitrary floating point result in

1022
00:37:33,119 --> 00:37:35,359
subsequent instructions in the case of

1023
00:37:35,359 --> 00:37:39,040
arm and specifically about a csb

1024
00:37:39,040 --> 00:37:41,440
this is this can couldn't work because

1025
00:37:41,440 --> 00:37:42,800
uh the

1026
00:37:42,800 --> 00:37:44,640
synchronization or the coherence between

1027
00:37:44,640 --> 00:37:46,560
data and code

1028
00:37:46,560 --> 00:37:48,079
are not

1029
00:37:48,079 --> 00:37:51,280
is not built in as for example amd and

1030
00:37:51,280 --> 00:37:53,680
uh intel but it's left explicitly to the

1031
00:37:53,680 --> 00:37:56,480
user so whoever is running writing code

1032
00:37:56,480 --> 00:37:56,960
for arm

1033
00:37:56,960 --> 00:37:58,240
[Music]

1034
00:37:58,240 --> 00:38:00,240
processors has to maintain this

1035
00:38:00,240 --> 00:38:03,680
coherence between the t and the two um

1036
00:38:03,680 --> 00:38:05,760
caches

1037
00:38:05,760 --> 00:38:08,000
but later we also informed from arm that

1038
00:38:08,000 --> 00:38:10,160
some floating point implementations are

1039
00:38:10,160 --> 00:38:13,040
vulnerable to floating point

1040
00:38:13,040 --> 00:38:14,720
injection

1041
00:38:14,720 --> 00:38:16,480
mozilla confirmed the vulnerability and

1042
00:38:16,480 --> 00:38:18,480
released mitigation

1043
00:38:18,480 --> 00:38:21,119
with conditionally masking the nan boxed

1044
00:38:21,119 --> 00:38:23,440
floating point results from firefox 87

1045
00:38:23,440 --> 00:38:26,400
and on and the zen hypervisor

1046
00:38:26,400 --> 00:38:28,880
mitigated ssb as we're suggesting by

1047
00:38:28,880 --> 00:38:30,320
issuing a sterilizing instruction after

1048
00:38:30,320 --> 00:38:33,280
we store new code to to make sure that

1049
00:38:33,280 --> 00:38:36,000
code and data views are uh coherent and

1050
00:38:36,000 --> 00:38:37,440
when are we executing the new code we

1051
00:38:37,440 --> 00:38:39,119
actually executed that and not the state

1052
00:38:39,119 --> 00:38:41,119
code that was uh

1053
00:38:41,119 --> 00:38:43,520
that was in memory before

1054
00:38:43,520 --> 00:38:45,839
to conclude bad speculation is not only

1055
00:38:45,839 --> 00:38:47,680
caused by classic mispredictions and

1056
00:38:47,680 --> 00:38:48,880
mistraining

1057
00:38:48,880 --> 00:38:51,520
predictors but also by

1058
00:38:51,520 --> 00:38:53,760
architectural invariance violations as

1059
00:38:53,760 --> 00:38:55,760
we saw in all different types of machine

1060
00:38:55,760 --> 00:38:57,119
clear

1061
00:38:57,119 --> 00:38:58,400
architectural environments can be

1062
00:38:58,400 --> 00:39:00,720
exploited creating new security threats

1063
00:39:00,720 --> 00:39:03,839
like fpvii and csb and we think that

1064
00:39:03,839 --> 00:39:06,720
defenses must focus on the wider class

1065
00:39:06,720 --> 00:39:09,280
of root causes and the wider meaning of

1066
00:39:09,280 --> 00:39:11,040
bad speculation

1067
00:39:11,040 --> 00:39:13,359
with this i can conclude and you can

1068
00:39:13,359 --> 00:39:15,119
find all the rest engineering code the

1069
00:39:15,119 --> 00:39:16,160
exploit

1070
00:39:16,160 --> 00:39:19,200
code and the paper and more information

1071
00:39:19,200 --> 00:39:20,960
on our project page and you can reach

1072
00:39:20,960 --> 00:39:22,560
out to twitter if you want thanks for

1073
00:39:22,560 --> 00:39:25,640
your attention

1074
00:39:29,440 --> 00:39:32,079
excellent really uh mind-blowing and if

1075
00:39:32,079 --> 00:39:33,920
anyone's managed to follow that enough

1076
00:39:33,920 --> 00:39:37,280
to have any questions

1077
00:39:38,240 --> 00:39:39,920
no i think you've broken the entire

1078
00:39:39,920 --> 00:39:43,839
audience oh we have one here

1079
00:39:48,640 --> 00:39:50,480
so you said that zen

1080
00:39:50,480 --> 00:39:53,440
issued an advisory and you said their

1081
00:39:53,440 --> 00:39:55,920
fix was to issue a serializing

1082
00:39:55,920 --> 00:39:58,400
instruction after things how do they

1083
00:39:58,400 --> 00:40:00,640
know if someone's making self-modifying

1084
00:40:00,640 --> 00:40:02,720
code inside of a vm

1085
00:40:02,720 --> 00:40:03,520
if

1086
00:40:03,520 --> 00:40:05,599
like without monitoring every single

1087
00:40:05,599 --> 00:40:07,200
memory right how would they even know to

1088
00:40:07,200 --> 00:40:08,319
issue that

1089
00:40:08,319 --> 00:40:11,280
serializing instruction

1090
00:40:11,280 --> 00:40:13,200
yeah if i remember correctly it's not

1091
00:40:13,200 --> 00:40:16,319
about what the user is doing if i'm

1092
00:40:16,319 --> 00:40:18,400
accuracy was something about the startup

1093
00:40:18,400 --> 00:40:19,760
of the vm

1094
00:40:19,760 --> 00:40:22,079
where the user was able to provide some

1095
00:40:22,079 --> 00:40:26,000
piece of code maybe was uh executed in a

1096
00:40:26,000 --> 00:40:27,440
state way

1097
00:40:27,440 --> 00:40:30,160
uh but yeah is let's say on the

1098
00:40:30,160 --> 00:40:32,000
hypervisor level rather than the

1099
00:40:32,000 --> 00:40:34,640
distinction between a guest and uh

1100
00:40:34,640 --> 00:40:36,480
so they're they're mitigating it for

1101
00:40:36,480 --> 00:40:38,560
their own code specifically not that it

1102
00:40:38,560 --> 00:40:40,240
would stop anyone from doing this kind

1103
00:40:40,240 --> 00:40:41,839
of thing inside of the virtualization

1104
00:40:41,839 --> 00:40:44,319
system exactly okay

1105
00:40:44,319 --> 00:40:46,720
yeah for me out here um it's just uh

1106
00:40:46,720 --> 00:40:48,880
whenever they are managing all the

1107
00:40:48,880 --> 00:40:51,040
virtual machines and for example after

1108
00:40:51,040 --> 00:40:52,400
some time you have virtual machines

1109
00:40:52,400 --> 00:40:55,200
leaving code somewhere and then you are

1110
00:40:55,200 --> 00:40:57,119
trying to reuse that

1111
00:40:57,119 --> 00:40:59,680
code memory again you are

1112
00:40:59,680 --> 00:41:02,079
risking to actually executing whatever

1113
00:41:02,079 --> 00:41:04,720
was left from other machines so it's

1114
00:41:04,720 --> 00:41:06,640
more to prevent that there is complete

1115
00:41:06,640 --> 00:41:08,880
isolation between what was left state

1116
00:41:08,880 --> 00:41:10,640
code provided by other virtual machines

1117
00:41:10,640 --> 00:41:11,920
and the new code that they're actually

1118
00:41:11,920 --> 00:41:14,930
trying to execute in that moment

1119
00:41:14,930 --> 00:41:17,989
[Music]

1120
00:41:18,480 --> 00:41:21,359
any other questions

1121
00:41:21,359 --> 00:41:23,040
excellent well thank you that was a

1122
00:41:23,040 --> 00:41:27,240
really great tool thanks

