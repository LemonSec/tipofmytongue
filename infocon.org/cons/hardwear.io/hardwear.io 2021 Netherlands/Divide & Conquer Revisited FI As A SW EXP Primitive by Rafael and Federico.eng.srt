1
00:00:03,840 --> 00:00:05,920
oh uh welcome everybody to this talk i

2
00:00:05,920 --> 00:00:08,400
will try to compress a bit to catch up

3
00:00:08,400 --> 00:00:09,760
with the time i don't want to keep you

4
00:00:09,760 --> 00:00:11,759
from the coffee break but hopefully you

5
00:00:11,759 --> 00:00:12,960
will forget about it if this is

6
00:00:12,960 --> 00:00:14,240
interesting enough

7
00:00:14,240 --> 00:00:16,960
so my name is rafael boscarpi and i will

8
00:00:16,960 --> 00:00:18,960
be together with my colleague federico

9
00:00:18,960 --> 00:00:21,119
we will be presenting this talk about

10
00:00:21,119 --> 00:00:23,680
fault injection and combined attacks we

11
00:00:23,680 --> 00:00:26,000
called it divide and conquer revisited

12
00:00:26,000 --> 00:00:27,840
because we will not talk too much about

13
00:00:27,840 --> 00:00:29,199
fault injection we're going to actually

14
00:00:29,199 --> 00:00:31,359
talk about software exploits so we are

15
00:00:31,359 --> 00:00:32,479
talking about software not so much

16
00:00:32,479 --> 00:00:34,480
hardware but you will see how these

17
00:00:34,480 --> 00:00:36,160
worlds meet together

18
00:00:36,160 --> 00:00:38,160
so in this presentation we will walk you

19
00:00:38,160 --> 00:00:40,320
through our message of the presentation

20
00:00:40,320 --> 00:00:44,160
through some case study so here uh well

21
00:00:44,160 --> 00:00:46,800
we try to pray to democrats and we have

22
00:00:46,800 --> 00:00:49,360
some some setup here we will show what

23
00:00:49,360 --> 00:00:51,039
it is we will talk about it and we will

24
00:00:51,039 --> 00:00:53,440
talk about how we did an attack that was

25
00:00:53,440 --> 00:00:56,000
reported and then also how is patched

26
00:00:56,000 --> 00:00:58,079
and what can you do

27
00:00:58,079 --> 00:00:59,440
let's start

28
00:00:59,440 --> 00:01:00,239
so

29
00:01:00,239 --> 00:01:01,520
the case study

30
00:01:01,520 --> 00:01:03,600
we have a microcontroller so this is one

31
00:01:03,600 --> 00:01:05,280
of the newest microcontrollers in this

32
00:01:05,280 --> 00:01:07,799
case it's from st it's the

33
00:01:07,799 --> 00:01:11,040
stm32wb55 so this microcontroller it's

34
00:01:11,040 --> 00:01:13,119
an iot chip which has a ton of features

35
00:01:13,119 --> 00:01:15,119
it does almost everything so it's dual

36
00:01:15,119 --> 00:01:18,320
core it has a cortex m4 for general

37
00:01:18,320 --> 00:01:20,960
purpose operations but it also has a

38
00:01:20,960 --> 00:01:23,920
cortex m0 chip which is in charge of all

39
00:01:23,920 --> 00:01:25,920
the wireless communications like wi-fi

40
00:01:25,920 --> 00:01:28,400
bluetooth and whatnot but also is in

41
00:01:28,400 --> 00:01:30,640
charge of the security domain

42
00:01:30,640 --> 00:01:32,880
so this chip has two partitions security

43
00:01:32,880 --> 00:01:35,840
domain and the general purpose

44
00:01:35,840 --> 00:01:37,040
important

45
00:01:37,040 --> 00:01:39,200
interesting this chip has something that

46
00:01:39,200 --> 00:01:41,200
we will refer to several times it's

47
00:01:41,200 --> 00:01:43,360
called these option bytes it is stored

48
00:01:43,360 --> 00:01:45,360
in flash and it defines a bit of the

49
00:01:45,360 --> 00:01:47,600
properties of the chip

50
00:01:47,600 --> 00:01:50,000
so when we looked at this chip basically

51
00:01:50,000 --> 00:01:51,520
we had some research

52
00:01:51,520 --> 00:01:53,439
goals and our research basically

53
00:01:53,439 --> 00:01:55,040
targeted typical goals what do we want

54
00:01:55,040 --> 00:01:56,799
to do with this chip

55
00:01:56,799 --> 00:01:58,560
so in this case we actually wanted to

56
00:01:58,560 --> 00:02:00,399
set ourselves in the most realistic

57
00:02:00,399 --> 00:02:02,880
scenario which is we get a device of the

58
00:02:02,880 --> 00:02:06,000
shelf from production fully locked

59
00:02:06,000 --> 00:02:08,318
like nothing readable nothing debuggable

60
00:02:08,318 --> 00:02:10,639
what can we do with it

61
00:02:10,639 --> 00:02:12,879
so here we have the typical assets that

62
00:02:12,879 --> 00:02:14,239
you might have for example for the

63
00:02:14,239 --> 00:02:16,879
secure core we would target the runtime

64
00:02:16,879 --> 00:02:20,319
control debug privileges can we run

65
00:02:20,319 --> 00:02:22,959
arbitrary code there also we have secret

66
00:02:22,959 --> 00:02:25,680
keys like a script and whatnot quantity

67
00:02:25,680 --> 00:02:28,640
dump this aes secret keys can we dump

68
00:02:28,640 --> 00:02:30,640
the secure area maybe the wireless

69
00:02:30,640 --> 00:02:31,760
framework

70
00:02:31,760 --> 00:02:34,000
the same also for the non-secure code so

71
00:02:34,000 --> 00:02:36,720
can we dump the contents of that thing

72
00:02:36,720 --> 00:02:39,200
or this debug log out maybe i just want

73
00:02:39,200 --> 00:02:41,200
to copy the devices i just want to steal

74
00:02:41,200 --> 00:02:42,640
the intellectual property so can we

75
00:02:42,640 --> 00:02:45,680
bypass this debug logout

76
00:02:45,680 --> 00:02:47,519
in this case we just followed the

77
00:02:47,519 --> 00:02:49,360
typical approach to reverse engineer

78
00:02:49,360 --> 00:02:52,239
embedded systems so this process

79
00:02:52,239 --> 00:02:53,680
actually you have maybe seen from

80
00:02:53,680 --> 00:02:55,120
previous presentation from my colleagues

81
00:02:55,120 --> 00:02:56,239
at risk here

82
00:02:56,239 --> 00:02:57,040
so

83
00:02:57,040 --> 00:02:58,959
first we want to understand the target

84
00:02:58,959 --> 00:03:00,480
how does this work

85
00:03:00,480 --> 00:03:02,560
then we will try to look for issues

86
00:03:02,560 --> 00:03:04,640
vulnerabilities and eventually if we

87
00:03:04,640 --> 00:03:06,800
find something we can try to exploit it

88
00:03:06,800 --> 00:03:09,120
okay so first things first to understand

89
00:03:09,120 --> 00:03:12,080
the target we need to have something and

90
00:03:12,080 --> 00:03:13,440
that's something usually means the

91
00:03:13,440 --> 00:03:16,000
firmware and data sheets basically

92
00:03:16,000 --> 00:03:17,599
everything available to the general

93
00:03:17,599 --> 00:03:19,280
public

94
00:03:19,280 --> 00:03:21,760
let's start so we took the data sheets

95
00:03:21,760 --> 00:03:23,120
of this device

96
00:03:23,120 --> 00:03:24,720
and then from the chip data sheet what

97
00:03:24,720 --> 00:03:26,480
you would see is that the readout

98
00:03:26,480 --> 00:03:29,040
protection it has three settings

99
00:03:29,040 --> 00:03:31,440
the rdp or readout protection levels

100
00:03:31,440 --> 00:03:34,400
they can be level 0 which is denoted by

101
00:03:34,400 --> 00:03:36,640
this option byte aa

102
00:03:36,640 --> 00:03:38,480
and that means full access you can read

103
00:03:38,480 --> 00:03:41,599
write debug basically developer sample

104
00:03:41,599 --> 00:03:44,640
the other extreme rtp2 it's denoted by

105
00:03:44,640 --> 00:03:47,519
this flag cc the option bytes this means

106
00:03:47,519 --> 00:03:50,239
you have zero access so jtag access is

107
00:03:50,239 --> 00:03:52,560
disabled you cannot debug anything and

108
00:03:52,560 --> 00:03:54,159
on top of that it's an irreversible

109
00:03:54,159 --> 00:03:55,120
state

110
00:03:55,120 --> 00:03:57,840
if you ever transition the chip to that

111
00:03:57,840 --> 00:03:59,599
you cannot go back there is just

112
00:03:59,599 --> 00:04:01,120
basically everything is slot and you

113
00:04:01,120 --> 00:04:03,120
cannot go back

114
00:04:03,120 --> 00:04:06,159
then there is the third state rtp1 which

115
00:04:06,159 --> 00:04:07,360
is basically

116
00:04:07,360 --> 00:04:10,560
denoted by not a a or not cc in this

117
00:04:10,560 --> 00:04:12,720
option byte and this is a partially

118
00:04:12,720 --> 00:04:15,439
locked state so in this state

119
00:04:15,439 --> 00:04:18,079
you cannot debug stuff but the debug

120
00:04:18,079 --> 00:04:20,880
setting is open okay so you can connect

121
00:04:20,880 --> 00:04:23,040
a debugger you can debug part of the ram

122
00:04:23,040 --> 00:04:24,639
and some registers but you cannot read

123
00:04:24,639 --> 00:04:25,840
the flash

124
00:04:25,840 --> 00:04:27,600
or you cannot do single stepping to

125
00:04:27,600 --> 00:04:30,720
start stepping structure by instruction

126
00:04:30,720 --> 00:04:32,800
if you want this is a reversible state

127
00:04:32,800 --> 00:04:34,720
you could transition back to fully debug

128
00:04:34,720 --> 00:04:38,000
but doing so erases the chip okay so

129
00:04:38,000 --> 00:04:39,919
this might be interesting in some

130
00:04:39,919 --> 00:04:41,199
production

131
00:04:41,199 --> 00:04:42,400
modes

132
00:04:42,400 --> 00:04:44,720
interesting to know that the secure core

133
00:04:44,720 --> 00:04:46,160
the m0

134
00:04:46,160 --> 00:04:48,240
it is always blocked you cannot debug it

135
00:04:48,240 --> 00:04:50,000
even if you in the full access the

136
00:04:50,000 --> 00:04:51,919
security core security domain is

137
00:04:51,919 --> 00:04:54,720
actually locked you cannot see anything

138
00:04:54,720 --> 00:04:55,680
okay

139
00:04:55,680 --> 00:04:57,199
we keep breathing

140
00:04:57,199 --> 00:04:59,280
then we see that the sram and the flash

141
00:04:59,280 --> 00:05:00,560
of this microcontroller they are

142
00:05:00,560 --> 00:05:01,759
partitioned

143
00:05:01,759 --> 00:05:05,520
and the m0 can see everything but the m4

144
00:05:05,520 --> 00:05:07,440
the non-secure core can only see the

145
00:05:07,440 --> 00:05:10,000
non-secure domain we cannot touch at all

146
00:05:10,000 --> 00:05:11,919
the m0 resources

147
00:05:11,919 --> 00:05:14,000
this is in a way similar like t e

148
00:05:14,000 --> 00:05:15,600
concepts that we cannot see the secure

149
00:05:15,600 --> 00:05:17,199
domain

150
00:05:17,199 --> 00:05:19,120
also the secure core the firmware the

151
00:05:19,120 --> 00:05:21,360
code execution this is only reserved to

152
00:05:21,360 --> 00:05:22,479
st

153
00:05:22,479 --> 00:05:24,479
if you download updates for that or if

154
00:05:24,479 --> 00:05:26,320
you try to find code there the images

155
00:05:26,320 --> 00:05:28,479
are encrypted unsigned

156
00:05:28,479 --> 00:05:30,800
so we don't really see the vinegar we

157
00:05:30,800 --> 00:05:32,320
don't really know what is running there

158
00:05:32,320 --> 00:05:35,120
other than some api functions okay

159
00:05:35,120 --> 00:05:37,039
if you want to update this is done

160
00:05:37,039 --> 00:05:38,960
through some programmer tool that you

161
00:05:38,960 --> 00:05:40,720
load into non-secure core you could put

162
00:05:40,720 --> 00:05:42,639
this firmware and then the secure core

163
00:05:42,639 --> 00:05:43,919
does the things but you don't see

164
00:05:43,919 --> 00:05:46,240
anything

165
00:05:46,240 --> 00:05:48,000
a bit more details about the m0 the

166
00:05:48,000 --> 00:05:49,520
security domain

167
00:05:49,520 --> 00:05:50,960
security can be configured through this

168
00:05:50,960 --> 00:05:52,960
option bytes that we mentioned okay so

169
00:05:52,960 --> 00:05:55,280
in production modes you would just have

170
00:05:55,280 --> 00:05:56,639
everything locked down

171
00:05:56,639 --> 00:06:00,240
and the m0 is something that is only

172
00:06:00,240 --> 00:06:03,360
written by the ac the m0 domain in other

173
00:06:03,360 --> 00:06:06,080
words you can never touch the security

174
00:06:06,080 --> 00:06:07,520
option bytes of the secure domain this

175
00:06:07,520 --> 00:06:09,919
is not available to people

176
00:06:09,919 --> 00:06:13,120
then most codes in this secure core does

177
00:06:13,120 --> 00:06:15,759
wireless stuff but it also does some

178
00:06:15,759 --> 00:06:17,840
things which are critical to security

179
00:06:17,840 --> 00:06:20,479
for example security storage if as a

180
00:06:20,479 --> 00:06:22,400
user you want to use this security

181
00:06:22,400 --> 00:06:24,319
enclave let's call it like that then you

182
00:06:24,319 --> 00:06:25,520
can install

183
00:06:25,520 --> 00:06:27,759
keys or ask even keys to be installed

184
00:06:27,759 --> 00:06:29,680
and from this non-secure world you can

185
00:06:29,680 --> 00:06:30,639
use it

186
00:06:30,639 --> 00:06:33,120
you can say i want to use key slot

187
00:06:33,120 --> 00:06:33,919
3

188
00:06:33,919 --> 00:06:36,319
the secure core will load the key from

189
00:06:36,319 --> 00:06:38,560
key slot 3 and then the non-secure world

190
00:06:38,560 --> 00:06:40,560
can use it but doesn't see the key at

191
00:06:40,560 --> 00:06:42,720
all

192
00:06:43,600 --> 00:06:44,560
okay

193
00:06:44,560 --> 00:06:45,520
so

194
00:06:45,520 --> 00:06:46,880
this was the code

195
00:06:46,880 --> 00:06:49,280
then basically what we wanted is okay

196
00:06:49,280 --> 00:06:50,960
let's look at

197
00:06:50,960 --> 00:06:53,120
what is running in this chip

198
00:06:53,120 --> 00:06:54,880
for this we wanted to look at the boot

199
00:06:54,880 --> 00:06:57,360
rom and according to the boot rom sorry

200
00:06:57,360 --> 00:06:58,400
according to the data sheet the boot

201
00:06:58,400 --> 00:06:59,840
room is mapped that doesn't address one

202
00:06:59,840 --> 00:07:03,120
fff coco so we did a super complicated

203
00:07:03,120 --> 00:07:05,199
attack which basically means you plug

204
00:07:05,199 --> 00:07:07,840
the debugger you say can i read

205
00:07:07,840 --> 00:07:12,240
address one f f c or c zero and yes sure

206
00:07:12,240 --> 00:07:13,840
okay so you can dump the boot rom and

207
00:07:13,840 --> 00:07:15,520
then yeah you get the code i'm not going

208
00:07:15,520 --> 00:07:16,800
to show it but if you have one of these

209
00:07:16,800 --> 00:07:18,000
devices just block a debugger and you

210
00:07:18,000 --> 00:07:19,759
can dump it

211
00:07:19,759 --> 00:07:23,440
so cool okay we have now some more stuff

212
00:07:23,440 --> 00:07:27,039
so we connected debugger we see it and a

213
00:07:27,039 --> 00:07:28,639
quick analysis

214
00:07:28,639 --> 00:07:30,160
actually was very interesting because

215
00:07:30,160 --> 00:07:33,039
what we saw in the code actually mapped

216
00:07:33,039 --> 00:07:34,720
almost one to one what the public

217
00:07:34,720 --> 00:07:37,360
documentation says okay so the behavior

218
00:07:37,360 --> 00:07:39,680
seems to match the public documentation

219
00:07:39,680 --> 00:07:42,160
there is no hidden functionality no

220
00:07:42,160 --> 00:07:45,120
magical stuff backdoor secret what not

221
00:07:45,120 --> 00:07:47,199
and also there were no obvious software

222
00:07:47,199 --> 00:07:49,520
flaws it was very simple code but simple

223
00:07:49,520 --> 00:07:51,599
sometimes means secure

224
00:07:51,599 --> 00:07:53,520
and something interesting here is that

225
00:07:53,520 --> 00:07:55,199
there is no check actually for these

226
00:07:55,199 --> 00:07:57,199
riddle protection bytes so if you look

227
00:07:57,199 --> 00:08:00,160
at the room then this is not there so

228
00:08:00,160 --> 00:08:02,160
this means that probably this happens in

229
00:08:02,160 --> 00:08:03,680
hardware you don't even see it in the

230
00:08:03,680 --> 00:08:05,520
software part

231
00:08:05,520 --> 00:08:07,840
so the boot rom here from attack point

232
00:08:07,840 --> 00:08:10,319
of view then looks very simple but quite

233
00:08:10,319 --> 00:08:12,879
robust so nothing to do here

234
00:08:12,879 --> 00:08:14,639
nice

235
00:08:14,639 --> 00:08:16,160
so we look at the boot drum we look at

236
00:08:16,160 --> 00:08:18,639
the data sheets let's also try to do a

237
00:08:18,639 --> 00:08:21,280
bit more analysis on the secure core

238
00:08:21,280 --> 00:08:23,680
so from the secure core what we try to

239
00:08:23,680 --> 00:08:26,240
do is let's interact from the non-secure

240
00:08:26,240 --> 00:08:28,960
domain to the secure domain

241
00:08:28,960 --> 00:08:30,879
and basically we cannot access anything

242
00:08:30,879 --> 00:08:33,200
we try the classical things let's try to

243
00:08:33,200 --> 00:08:34,958
access through a peripheral decrypt the

244
00:08:34,958 --> 00:08:36,958
memory from the secure code oh

245
00:08:36,958 --> 00:08:38,559
let's try connect the debugger and let's

246
00:08:38,559 --> 00:08:40,399
try to do something nope

247
00:08:40,399 --> 00:08:43,039
so basically it's actually quite decent

248
00:08:43,039 --> 00:08:44,560
you cannot really interact from

249
00:08:44,560 --> 00:08:46,959
non-secure world with secure world

250
00:08:46,959 --> 00:08:48,080
nice

251
00:08:48,080 --> 00:08:50,320
the way to interact the way to say for

252
00:08:50,320 --> 00:08:52,080
example to wireless i want to send

253
00:08:52,080 --> 00:08:55,120
something is via a mailbox you have some

254
00:08:55,120 --> 00:08:58,000
interface where you upon you put there i

255
00:08:58,000 --> 00:08:59,519
want to write a message or i want to do

256
00:08:59,519 --> 00:09:00,800
some activity

257
00:09:00,800 --> 00:09:03,120
secure code will see this and then

258
00:09:03,120 --> 00:09:05,279
starts doing its own stuff very much

259
00:09:05,279 --> 00:09:07,200
like te is

260
00:09:07,200 --> 00:09:08,959
the wireless stack is also executed by

261
00:09:08,959 --> 00:09:10,080
this core

262
00:09:10,080 --> 00:09:11,760
so this is like

263
00:09:11,760 --> 00:09:14,959
wireless stack lots of code facts fun

264
00:09:14,959 --> 00:09:16,720
but we don't have the firmware

265
00:09:16,720 --> 00:09:19,680
and the frameworks are encrypted so

266
00:09:19,680 --> 00:09:21,440
we don't have nothing to work with no

267
00:09:21,440 --> 00:09:23,680
reverse engineering possible no debug

268
00:09:23,680 --> 00:09:27,680
access security domain is all isolated

269
00:09:27,680 --> 00:09:30,080
so when we collect our thoughts this is

270
00:09:30,080 --> 00:09:32,959
like a challenge fully locked device i

271
00:09:32,959 --> 00:09:35,040
don't have any knowledge of the binaries

272
00:09:35,040 --> 00:09:36,480
that are running there we just know a

273
00:09:36,480 --> 00:09:38,240
bit of the functionality

274
00:09:38,240 --> 00:09:40,000
challenge accepted let's try to do

275
00:09:40,000 --> 00:09:41,920
something

276
00:09:41,920 --> 00:09:43,839
so next step

277
00:09:43,839 --> 00:09:46,000
once we have this

278
00:09:46,000 --> 00:09:47,760
what can we do how can we identify

279
00:09:47,760 --> 00:09:50,399
vulnerabilities okay so let's see our

280
00:09:50,399 --> 00:09:51,920
options

281
00:09:51,920 --> 00:09:53,600
we want to do a software exploit this

282
00:09:53,600 --> 00:09:55,680
talk was about software exploits and how

283
00:09:55,680 --> 00:09:56,800
do we do it

284
00:09:56,800 --> 00:09:58,800
for our software exploits to run some

285
00:09:58,800 --> 00:10:00,720
exploits you need three properties in

286
00:10:00,720 --> 00:10:02,079
general

287
00:10:02,079 --> 00:10:04,240
we will need to have some runtime

288
00:10:04,240 --> 00:10:06,240
control some ways of doing this or

289
00:10:06,240 --> 00:10:08,720
diverting to this but in this case we

290
00:10:08,720 --> 00:10:10,880
don't want to do blind exploitation so

291
00:10:10,880 --> 00:10:12,560
this m core

292
00:10:12,560 --> 00:10:14,640
the m0 core is hidden to us we don't

293
00:10:14,640 --> 00:10:16,399
know what's going on there

294
00:10:16,399 --> 00:10:18,640
usually also if we want to do a simple

295
00:10:18,640 --> 00:10:20,640
exploit we need to have a place to put

296
00:10:20,640 --> 00:10:21,760
this code

297
00:10:21,760 --> 00:10:24,640
but the m core cannot modify the m4

298
00:10:24,640 --> 00:10:26,480
memory and the chip also is going to be

299
00:10:26,480 --> 00:10:28,240
locked so

300
00:10:28,240 --> 00:10:29,920
even if i try to do something with the

301
00:10:29,920 --> 00:10:32,160
secure core it doesn't work but even if

302
00:10:32,160 --> 00:10:33,519
i try to do also with the non-secure

303
00:10:33,519 --> 00:10:36,880
core it's not i'm not do really anything

304
00:10:36,880 --> 00:10:38,560
nice

305
00:10:38,560 --> 00:10:40,800
third we need something that can execute

306
00:10:40,800 --> 00:10:42,880
code okay so in this case the flash

307
00:10:42,880 --> 00:10:44,800
memory is executable

308
00:10:44,800 --> 00:10:46,959
but if we want to interact across course

309
00:10:46,959 --> 00:10:48,640
or if we want to full compromise the

310
00:10:48,640 --> 00:10:50,720
chip we can only have this mailbox

311
00:10:50,720 --> 00:10:52,399
interface this is the only part that it

312
00:10:52,399 --> 00:10:55,600
has shared instructions

313
00:10:55,600 --> 00:10:56,560
okay

314
00:10:56,560 --> 00:10:59,360
so approaches how can we go about this

315
00:10:59,360 --> 00:11:01,440
we can go the full software approach

316
00:11:01,440 --> 00:11:04,160
okay so we call it like fasting return

317
00:11:04,160 --> 00:11:06,320
oriented programming blind exploits this

318
00:11:06,320 --> 00:11:09,120
is no secret for me

319
00:11:09,120 --> 00:11:10,240
this is

320
00:11:10,240 --> 00:11:12,000
a challenge in this setting but okay

321
00:11:12,000 --> 00:11:13,360
let's think that we would like to go

322
00:11:13,360 --> 00:11:15,839
this way so a typical approach would be

323
00:11:15,839 --> 00:11:17,760
wireless stack lots of codes let's try

324
00:11:17,760 --> 00:11:19,360
to find something there

325
00:11:19,360 --> 00:11:21,440
and if you are jedi master level on

326
00:11:21,440 --> 00:11:23,839
software exploitation then you might

327
00:11:23,839 --> 00:11:26,560
think blind exploitation with something

328
00:11:26,560 --> 00:11:29,519
here and then we just do it good

329
00:11:29,519 --> 00:11:31,519
federico and i were a bit more lazy and

330
00:11:31,519 --> 00:11:33,519
we just wanted to try something simple

331
00:11:33,519 --> 00:11:34,240
so

332
00:11:34,240 --> 00:11:36,320
the longer way might be let's try to

333
00:11:36,320 --> 00:11:38,320
find some leakage of information through

334
00:11:38,320 --> 00:11:40,320
some vulnerability let's try to reverse

335
00:11:40,320 --> 00:11:42,800
engineer with the behavior once we see

336
00:11:42,800 --> 00:11:44,959
what is going on let's try to craft some

337
00:11:44,959 --> 00:11:48,160
exploit chain to run some code and then

338
00:11:48,160 --> 00:11:49,920
we trigger the whole process and we hope

339
00:11:49,920 --> 00:11:52,240
that it goes kaboom

340
00:11:52,240 --> 00:11:53,839
profit well

341
00:11:53,839 --> 00:11:56,399
might be but as you can see this is not

342
00:11:56,399 --> 00:11:58,639
a simple thing

343
00:11:58,639 --> 00:12:00,959
we at risk here we try usually a lot of

344
00:12:00,959 --> 00:12:03,600
f5 things so we can also think of okay

345
00:12:03,600 --> 00:12:06,560
let's if i reach our way

346
00:12:06,560 --> 00:12:08,000
and if you glitch your way through

347
00:12:08,000 --> 00:12:11,279
everything in this setting first we will

348
00:12:11,279 --> 00:12:13,519
need to glitch this readout protection

349
00:12:13,519 --> 00:12:15,440
level in order to unlock the chip and at

350
00:12:15,440 --> 00:12:18,720
least put some data on top of it

351
00:12:18,720 --> 00:12:19,600
and

352
00:12:19,600 --> 00:12:21,360
if we want to put data what do we want

353
00:12:21,360 --> 00:12:23,760
to do maybe a classical glitching way

354
00:12:23,760 --> 00:12:26,240
for glitching codes would be we load

355
00:12:26,240 --> 00:12:28,959
some exploit codes we load pointers to

356
00:12:28,959 --> 00:12:32,000
this code and then we start glitching

357
00:12:32,000 --> 00:12:33,360
praying that

358
00:12:33,360 --> 00:12:36,160
these pointers they get corrupted into

359
00:12:36,160 --> 00:12:38,399
the program counter of the machine

360
00:12:38,399 --> 00:12:40,480
and then what we do is we jump to our

361
00:12:40,480 --> 00:12:42,720
payload okay so you just played some

362
00:12:42,720 --> 00:12:43,760
codes

363
00:12:43,760 --> 00:12:46,240
you just put some pointers you start

364
00:12:46,240 --> 00:12:48,560
glitching and you hope that this pointer

365
00:12:48,560 --> 00:12:50,720
ends up as the current address you jump

366
00:12:50,720 --> 00:12:52,160
to your codes

367
00:12:52,160 --> 00:12:53,600
kaboom

368
00:12:53,600 --> 00:12:55,680
this actually you have a paper there

369
00:12:55,680 --> 00:12:57,839
that yeah it was from some years ago but

370
00:12:57,839 --> 00:12:59,040
it's very interesting if you have our

371
00:12:59,040 --> 00:13:01,279
32-bit architectures because it's a very

372
00:13:01,279 --> 00:13:03,200
powerful attack

373
00:13:03,200 --> 00:13:05,360
maybe profit maybe not

374
00:13:05,360 --> 00:13:08,240
so this was the scenarios and then we

375
00:13:08,240 --> 00:13:11,519
will see how to go about this

376
00:13:11,519 --> 00:13:12,480
then

377
00:13:12,480 --> 00:13:13,920
uh whoops

378
00:13:13,920 --> 00:13:16,720
okay so let's talk about glitching

379
00:13:16,720 --> 00:13:18,639
briefly before starting to explain the

380
00:13:18,639 --> 00:13:21,120
attack and how this works

381
00:13:21,120 --> 00:13:23,120
about fault injection you have had

382
00:13:23,120 --> 00:13:24,959
several talks that talk about it but

383
00:13:24,959 --> 00:13:26,959
from a software point of view if i try

384
00:13:26,959 --> 00:13:28,560
to describe glitching to software

385
00:13:28,560 --> 00:13:29,920
developers

386
00:13:29,920 --> 00:13:31,519
a glitch is basically something that

387
00:13:31,519 --> 00:13:33,680
usually leads to some data or control

388
00:13:33,680 --> 00:13:36,240
flow corruption okay typically can be

389
00:13:36,240 --> 00:13:38,079
triggered by physical faults

390
00:13:38,079 --> 00:13:40,639
nowadays this can also be triggered by

391
00:13:40,639 --> 00:13:42,639
software means under certain conditions

392
00:13:42,639 --> 00:13:44,079
so for example there is this beautiful

393
00:13:44,079 --> 00:13:45,920
attack thunderbolts if you want to later

394
00:13:45,920 --> 00:13:48,560
ask alisa how it works great

395
00:13:48,560 --> 00:13:51,440
it's super cool but glitching from a

396
00:13:51,440 --> 00:13:53,040
software point of view you can think of

397
00:13:53,040 --> 00:13:55,680
it initially as physical fashion okay

398
00:13:55,680 --> 00:13:58,079
maybe if you are as old as me like the

399
00:13:58,079 --> 00:13:59,680
old nintendo video games they had these

400
00:13:59,680 --> 00:14:01,120
cartridges that when you plug it and it

401
00:14:01,120 --> 00:14:03,279
was a bit dirty or shaky and then you

402
00:14:03,279 --> 00:14:04,880
start to get the garbage data on the

403
00:14:04,880 --> 00:14:06,079
screen

404
00:14:06,079 --> 00:14:07,360
it's something like that when the

405
00:14:07,360 --> 00:14:09,600
software has something corrupted it

406
00:14:09,600 --> 00:14:13,279
sometimes works but a bit funky

407
00:14:13,279 --> 00:14:16,000
okay so when we have glitching as a

408
00:14:16,000 --> 00:14:18,160
developer as a software exploiter what

409
00:14:18,160 --> 00:14:20,560
does it do does it do for me

410
00:14:20,560 --> 00:14:22,720
so the first thing about glitching is

411
00:14:22,720 --> 00:14:24,880
fault injection it can corrupt almost

412
00:14:24,880 --> 00:14:27,120
any data value for example you can

413
00:14:27,120 --> 00:14:29,360
corrupt things like registers in the cpu

414
00:14:29,360 --> 00:14:31,360
and if you corrupt their program counter

415
00:14:31,360 --> 00:14:34,160
then you get suddenly arbitrary runtime

416
00:14:34,160 --> 00:14:36,399
not addressed but arbitrary jumping

417
00:14:36,399 --> 00:14:39,760
to a position you might control or not

418
00:14:39,760 --> 00:14:41,440
you can also try to glitch configuration

419
00:14:41,440 --> 00:14:44,079
registers and if this is for example a

420
00:14:44,079 --> 00:14:46,160
copy of the otp the security

421
00:14:46,160 --> 00:14:48,240
configuration of a chip you can unlock

422
00:14:48,240 --> 00:14:51,279
things you can skip secure boots you can

423
00:14:51,279 --> 00:14:53,600
mess up configuration of te environments

424
00:14:53,600 --> 00:14:55,360
for a lot of stuff

425
00:14:55,360 --> 00:14:57,519
but not only these two examples so this

426
00:14:57,519 --> 00:15:00,320
happens in registers but also in on

427
00:15:00,320 --> 00:15:01,920
flights data when you're doing memory

428
00:15:01,920 --> 00:15:04,079
copies transfers also in different

429
00:15:04,079 --> 00:15:06,399
technologies memory which is volatile

430
00:15:06,399 --> 00:15:08,240
non-volatile memory so it happens in all

431
00:15:08,240 --> 00:15:10,320
sorts of places okay so don't think that

432
00:15:10,320 --> 00:15:12,079
it's just some part it can happen sort

433
00:15:12,079 --> 00:15:13,680
of anywhere

434
00:15:13,680 --> 00:15:15,600
even further

435
00:15:15,600 --> 00:15:17,920
fault injection glitches the hardware

436
00:15:17,920 --> 00:15:19,199
itself

437
00:15:19,199 --> 00:15:22,000
so this is one step below software

438
00:15:22,000 --> 00:15:23,519
abstraction

439
00:15:23,519 --> 00:15:25,199
actually i have a bit of a background in

440
00:15:25,199 --> 00:15:26,959
hardware so i sometimes would express

441
00:15:26,959 --> 00:15:28,720
that software is just a hardware

442
00:15:28,720 --> 00:15:30,959
configuration so it's an abstraction

443
00:15:30,959 --> 00:15:32,800
basically it's just the hardware does

444
00:15:32,800 --> 00:15:34,639
what the software tells but it's just

445
00:15:34,639 --> 00:15:36,000
everything hardware it's a physical

446
00:15:36,000 --> 00:15:38,240
means when you have a machine

447
00:15:38,240 --> 00:15:40,480
so with glitching we can trigger also

448
00:15:40,480 --> 00:15:43,440
things which are unreachable by software

449
00:15:43,440 --> 00:15:45,199
okay this is what the santa is called

450
00:15:45,199 --> 00:15:47,360
the magical behavior unicorns like

451
00:15:47,360 --> 00:15:49,360
instructions keeping skipping structure

452
00:15:49,360 --> 00:15:50,560
corruption

453
00:15:50,560 --> 00:15:52,480
creating new instructions because you

454
00:15:52,480 --> 00:15:54,480
glitch the logic some transistors become

455
00:15:54,480 --> 00:15:56,399
meta stable or blow up and then you have

456
00:15:56,399 --> 00:15:58,240
instead of another you have something

457
00:15:58,240 --> 00:16:00,240
that does half an other and adds plus

458
00:16:00,240 --> 00:16:01,199
three

459
00:16:01,199 --> 00:16:02,399
i don't know

460
00:16:02,399 --> 00:16:04,639
so given the proper conditions

461
00:16:04,639 --> 00:16:06,800
glitching from a software point of view

462
00:16:06,800 --> 00:16:09,199
can introduce software vulnerabilities

463
00:16:09,199 --> 00:16:12,800
can do a lot of interesting things

464
00:16:12,800 --> 00:16:15,440
so with this context

465
00:16:15,440 --> 00:16:18,959
now how can we exploit this

466
00:16:18,959 --> 00:16:21,600
if we try a classical approach a pure

467
00:16:21,600 --> 00:16:22,480
approach

468
00:16:22,480 --> 00:16:25,040
then we will have several issues

469
00:16:25,040 --> 00:16:27,120
if we glitch our way through everything

470
00:16:27,120 --> 00:16:29,199
the approach as we described

471
00:16:29,199 --> 00:16:31,519
require two glitches

472
00:16:31,519 --> 00:16:34,320
and we are also implicitly assuming that

473
00:16:34,320 --> 00:16:36,079
the device is glitchable what if it

474
00:16:36,079 --> 00:16:38,399
isn't what if for example i tried this

475
00:16:38,399 --> 00:16:40,240
glitching things into the program hunter

476
00:16:40,240 --> 00:16:42,720
of the m0 and it doesn't work

477
00:16:42,720 --> 00:16:45,120
then it would be tricky to get the m0 to

478
00:16:45,120 --> 00:16:47,440
jump to my code

479
00:16:47,440 --> 00:16:49,279
the other extreme software exploiting

480
00:16:49,279 --> 00:16:52,079
only you know how to do fusing rope and

481
00:16:52,079 --> 00:16:53,680
blind exploits

482
00:16:53,680 --> 00:16:56,399
however the chip will be fully locked we

483
00:16:56,399 --> 00:16:58,160
cannot do anything with it other than

484
00:16:58,160 --> 00:17:00,480
just using it whatever is there

485
00:17:00,480 --> 00:17:03,120
also the attack path only works if there

486
00:17:03,120 --> 00:17:04,720
are vulnerabilities

487
00:17:04,720 --> 00:17:06,240
if the chip is fully locked and you

488
00:17:06,240 --> 00:17:08,079
don't have any back

489
00:17:08,079 --> 00:17:10,160
this will not work

490
00:17:10,160 --> 00:17:12,240
but let's say that we found something

491
00:17:12,240 --> 00:17:14,240
okay in this case this setting because

492
00:17:14,240 --> 00:17:16,319
it's blind exploitation it's not trivial

493
00:17:16,319 --> 00:17:18,640
it's not your first exploit that you

494
00:17:18,640 --> 00:17:19,839
would write

495
00:17:19,839 --> 00:17:22,240
and if we get an over-the-air update

496
00:17:22,240 --> 00:17:24,160
this thing supports wireless so if you

497
00:17:24,160 --> 00:17:25,839
update it wirelessly for example then

498
00:17:25,839 --> 00:17:28,640
you will break the exploit okay so

499
00:17:28,640 --> 00:17:31,520
you have quite some caveats

500
00:17:31,520 --> 00:17:32,480
so

501
00:17:32,480 --> 00:17:34,000
this is the moment that if you remember

502
00:17:34,000 --> 00:17:37,280
the keynote that we had on yesterday

503
00:17:37,280 --> 00:17:39,919
from herbert i start to see that many

504
00:17:39,919 --> 00:17:42,400
talks go to this convergence of

505
00:17:42,400 --> 00:17:43,760
different domains

506
00:17:43,760 --> 00:17:46,080
this synergy of attacks

507
00:17:46,080 --> 00:17:48,160
so if we look at glitching and software

508
00:17:48,160 --> 00:17:51,280
exploiting hardware and software attacks

509
00:17:51,280 --> 00:17:52,880
performing for example a single glitch

510
00:17:52,880 --> 00:17:55,280
is very easy this is something that you

511
00:17:55,280 --> 00:17:57,120
have seen with a stupid mosfet you can

512
00:17:57,120 --> 00:17:59,440
glitch things yeah it's really like that

513
00:17:59,440 --> 00:18:01,200
but multiple glitches this is much more

514
00:18:01,200 --> 00:18:03,200
difficult because you're hammering the

515
00:18:03,200 --> 00:18:05,120
device and if you hammer it too much

516
00:18:05,120 --> 00:18:06,720
instead of it doing something

517
00:18:06,720 --> 00:18:09,039
interesting it breaks

518
00:18:09,039 --> 00:18:11,440
so if you want to move multiple glitches

519
00:18:11,440 --> 00:18:13,840
it's difficult and this is especially so

520
00:18:13,840 --> 00:18:15,760
if the software running there is no time

521
00:18:15,760 --> 00:18:19,200
constant you have moving targets

522
00:18:19,360 --> 00:18:21,360
exploiting several version activities

523
00:18:21,360 --> 00:18:23,200
and software is also very difficult

524
00:18:23,200 --> 00:18:26,320
exploit chain exploits are not not easy

525
00:18:26,320 --> 00:18:30,559
but many simple stupid exploits are easy

526
00:18:30,559 --> 00:18:32,480
okay so maybe you can do just a single

527
00:18:32,480 --> 00:18:35,520
exploits and then it's much easier

528
00:18:35,520 --> 00:18:36,480
so

529
00:18:36,480 --> 00:18:39,520
we painted as a summary a very complex

530
00:18:39,520 --> 00:18:41,679
situation for software exploitation

531
00:18:41,679 --> 00:18:45,520
fully locked blind exploitation what not

532
00:18:45,520 --> 00:18:48,400
what if we use what we know from all the

533
00:18:48,400 --> 00:18:51,360
talks and our experience from

534
00:18:51,360 --> 00:18:54,799
exploitation and from glitching

535
00:18:54,799 --> 00:18:56,880
and what we do is the following what if

536
00:18:56,880 --> 00:18:58,240
we change

537
00:18:58,240 --> 00:19:00,640
the scenario we make our life easier

538
00:19:00,640 --> 00:19:03,760
by using a simple glitch a stupid glitch

539
00:19:03,760 --> 00:19:06,400
a simple exploit a rather not

540
00:19:06,400 --> 00:19:09,600
complicated exploit and we combine both

541
00:19:09,600 --> 00:19:10,720
okay so

542
00:19:10,720 --> 00:19:12,480
i like to think of it like a bit of this

543
00:19:12,480 --> 00:19:15,360
matrix like some rules we can exploit

544
00:19:15,360 --> 00:19:17,760
and some others we can glitch

545
00:19:17,760 --> 00:19:20,559
so this is a classical divide and

546
00:19:20,559 --> 00:19:22,480
conquer approach we have a complicated

547
00:19:22,480 --> 00:19:23,280
thing

548
00:19:23,280 --> 00:19:25,679
and then we can divide it in chunks

549
00:19:25,679 --> 00:19:28,240
which by themselves they don't work but

550
00:19:28,240 --> 00:19:31,039
the combination is much more powerful

551
00:19:31,039 --> 00:19:33,840
so if we can divide a complex fault

552
00:19:33,840 --> 00:19:36,000
injection attack or a software attack

553
00:19:36,000 --> 00:19:37,600
into chunks

554
00:19:37,600 --> 00:19:39,760
so that we can have a simple glitching

555
00:19:39,760 --> 00:19:41,919
attack and a simple software express

556
00:19:41,919 --> 00:19:44,160
scenario we can achieve very powerful

557
00:19:44,160 --> 00:19:45,440
things

558
00:19:45,440 --> 00:19:47,200
as an attacker especially if you're

559
00:19:47,200 --> 00:19:48,720
doing software exploits what does it

560
00:19:48,720 --> 00:19:49,520
mean

561
00:19:49,520 --> 00:19:51,360
i have many challenges for software

562
00:19:51,360 --> 00:19:52,400
exploitation

563
00:19:52,400 --> 00:19:54,320
which one is the nastiest what is the

564
00:19:54,320 --> 00:19:56,640
thing that is really bothering me

565
00:19:56,640 --> 00:19:58,880
and if we have this thing that bothers

566
00:19:58,880 --> 00:20:01,280
me can we glitch it can we modify it or

567
00:20:01,280 --> 00:20:03,440
alter it or remove it even by this

568
00:20:03,440 --> 00:20:05,520
glitching

569
00:20:05,520 --> 00:20:07,520
we're going to see how it works we have

570
00:20:07,520 --> 00:20:09,120
even a demo

571
00:20:09,120 --> 00:20:10,720
in my backpack maybe i can show you

572
00:20:10,720 --> 00:20:12,400
later i have quite some boards that we

573
00:20:12,400 --> 00:20:14,240
glitched and we destroyed so hopefully

574
00:20:14,240 --> 00:20:16,080
the democrats will be nice but i don't

575
00:20:16,080 --> 00:20:17,039
know

576
00:20:17,039 --> 00:20:19,520
a disclaimer before we show this

577
00:20:19,520 --> 00:20:21,919
so this is an old disclaimer we will see

578
00:20:21,919 --> 00:20:23,760
a combined fi attack on a specific

579
00:20:23,760 --> 00:20:25,360
microcontroller but this is a general

580
00:20:25,360 --> 00:20:26,640
problem for general purpose

581
00:20:26,640 --> 00:20:29,039
microcontrollers from all vendors

582
00:20:29,039 --> 00:20:32,000
unless explicitly stated the chip is

583
00:20:32,000 --> 00:20:34,640
resilient or secured against security

584
00:20:34,640 --> 00:20:36,080
fault injection

585
00:20:36,080 --> 00:20:38,240
you can assume that many of them if not

586
00:20:38,240 --> 00:20:40,000
all of them will be vulnerable to some

587
00:20:40,000 --> 00:20:43,120
extent i put as many manufacturers as we

588
00:20:43,120 --> 00:20:43,840
can

589
00:20:43,840 --> 00:20:46,559
this all of them have one paper that

590
00:20:46,559 --> 00:20:49,520
shows an attack with fault injection

591
00:20:49,520 --> 00:20:52,960
this is not new 2015 this was in ccc

592
00:20:52,960 --> 00:20:55,360
camp in summer i was with ramiro we were

593
00:20:55,360 --> 00:20:57,200
explaining how it works there i was

594
00:20:57,200 --> 00:20:59,520
taking pictures showing this life we

595
00:20:59,520 --> 00:21:01,200
said the same thing

596
00:21:01,200 --> 00:21:04,080
2018 here hardware io one of my

597
00:21:04,080 --> 00:21:05,679
colleagues santiago cordova was

598
00:21:05,679 --> 00:21:07,280
explaining how fault injection works in

599
00:21:07,280 --> 00:21:10,400
automotive we also put it there

600
00:21:10,400 --> 00:21:13,039
so this is something that is known and

601
00:21:13,039 --> 00:21:14,880
this is something you should be aware if

602
00:21:14,880 --> 00:21:16,400
you're making systems

603
00:21:16,400 --> 00:21:19,360
that chips are clichable

604
00:21:19,360 --> 00:21:22,400
back to our attack okay so let's see how

605
00:21:22,400 --> 00:21:24,559
this divide and conquer approach this

606
00:21:24,559 --> 00:21:26,960
bad and conquer attack approach works

607
00:21:26,960 --> 00:21:29,919
and as i said we want to see how can i

608
00:21:29,919 --> 00:21:31,120
we

609
00:21:31,120 --> 00:21:33,600
abuse these glitching features for our

610
00:21:33,600 --> 00:21:35,760
software exploit attack

611
00:21:35,760 --> 00:21:38,000
so if we look at all the restrictions we

612
00:21:38,000 --> 00:21:39,919
have from a software point of view the

613
00:21:39,919 --> 00:21:41,440
one that i find the worst is blind

614
00:21:41,440 --> 00:21:43,120
exploitation i'm lazy i want to see at

615
00:21:43,120 --> 00:21:44,880
least i want to put some code and see

616
00:21:44,880 --> 00:21:46,240
what happens

617
00:21:46,240 --> 00:21:48,080
so if we cannot load code or we cannot

618
00:21:48,080 --> 00:21:50,720
debug what do we do well we start

619
00:21:50,720 --> 00:21:52,640
glitching and glitching

620
00:21:52,640 --> 00:21:55,200
and we will craft an attack

621
00:21:55,200 --> 00:21:57,840
the stack steps are the following

622
00:21:57,840 --> 00:22:00,159
first we're going to glitch the chip and

623
00:22:00,159 --> 00:22:02,400
hopefully unlock it okay so we will spam

624
00:22:02,400 --> 00:22:04,320
a single glitch a simple attack and see

625
00:22:04,320 --> 00:22:05,840
if this works

626
00:22:05,840 --> 00:22:09,039
if this works step two we can now load

627
00:22:09,039 --> 00:22:10,880
code and debug from the non-secure

628
00:22:10,880 --> 00:22:13,280
domain so let's put there some exploit

629
00:22:13,280 --> 00:22:15,120
and see if we can now compromise the

630
00:22:15,120 --> 00:22:17,760
chip or the rest of the chip okay

631
00:22:17,760 --> 00:22:20,159
so we will try to abuse this secure

632
00:22:20,159 --> 00:22:21,840
non-secure interface which seems the

633
00:22:21,840 --> 00:22:24,320
only gate from the not secure domain and

634
00:22:24,320 --> 00:22:26,799
see what happens okay

635
00:22:26,799 --> 00:22:28,159
so

636
00:22:28,159 --> 00:22:30,640
now any questions so far

637
00:22:30,640 --> 00:22:32,320
no

638
00:22:32,320 --> 00:22:33,280
okay

639
00:22:33,280 --> 00:22:36,000
now the settings if you remember recap

640
00:22:36,000 --> 00:22:38,400
we have this option byte that says the

641
00:22:38,400 --> 00:22:40,960
chip is unlocked or the chip is fully

642
00:22:40,960 --> 00:22:43,760
locked anything else is the chip

643
00:22:43,760 --> 00:22:46,080
has the debug enabled but you cannot

644
00:22:46,080 --> 00:22:48,240
really read the code or do many things

645
00:22:48,240 --> 00:22:49,760
so our plan

646
00:22:49,760 --> 00:22:51,280
we are going to try to corrupt these

647
00:22:51,280 --> 00:22:53,280
configuration bytes then we get into a

648
00:22:53,280 --> 00:22:55,200
partial lock and then at least we can

649
00:22:55,200 --> 00:22:57,120
load code or do something with it

650
00:22:57,120 --> 00:22:58,159
okay

651
00:22:58,159 --> 00:22:58,960
so

652
00:22:58,960 --> 00:23:01,200
this how we're going to go about it

653
00:23:01,200 --> 00:23:03,039
we're going to boot the chip many times

654
00:23:03,039 --> 00:23:05,120
we're going to try to force loading this

655
00:23:05,120 --> 00:23:06,320
option bytes

656
00:23:06,320 --> 00:23:08,159
c with a power measurement if we can

657
00:23:08,159 --> 00:23:11,919
spot where it is and then glitch there

658
00:23:11,919 --> 00:23:14,400
so this is how the chip looks

659
00:23:14,400 --> 00:23:17,679
if you put it from power off then we get

660
00:23:17,679 --> 00:23:20,000
this over here this is

661
00:23:20,000 --> 00:23:21,919
well the laser pointer you'll see but

662
00:23:21,919 --> 00:23:23,520
where the arrow is you see that there is

663
00:23:23,520 --> 00:23:25,120
a spike and then we have a certain

664
00:23:25,120 --> 00:23:26,559
pattern

665
00:23:26,559 --> 00:23:28,559
and if we just press it press the reset

666
00:23:28,559 --> 00:23:30,960
button then that spike at the beginning

667
00:23:30,960 --> 00:23:33,360
doesn't happen on the chip boot faster

668
00:23:33,360 --> 00:23:34,960
actually if you read the data sheet it

669
00:23:34,960 --> 00:23:35,760
says

670
00:23:35,760 --> 00:23:37,760
the readout of the option bytes only

671
00:23:37,760 --> 00:23:40,240
happens from power off or when you force

672
00:23:40,240 --> 00:23:42,640
the reloading of it

673
00:23:42,640 --> 00:23:44,640
so this pattern happens only when we

674
00:23:44,640 --> 00:23:47,600
power up and doesn't happen else so this

675
00:23:47,600 --> 00:23:49,360
is our candidate for option bytes

676
00:23:49,360 --> 00:23:52,000
loading let's feature

677
00:23:52,000 --> 00:23:54,080
so we try it

678
00:23:54,080 --> 00:23:55,600
and then we start glitching there like

679
00:23:55,600 --> 00:23:58,159
literally jiggly okay

680
00:23:58,159 --> 00:24:00,400
in this case we modify slightly the

681
00:24:00,400 --> 00:24:01,520
board we remove the decoupling

682
00:24:01,520 --> 00:24:03,360
capacitors sometimes this is not needed

683
00:24:03,360 --> 00:24:04,720
in this case we did

684
00:24:04,720 --> 00:24:07,039
and then we did some f5 profiling rounds

685
00:24:07,039 --> 00:24:09,440
and then we start glitching a lot

686
00:24:09,440 --> 00:24:11,200
and we start even with

687
00:24:11,200 --> 00:24:12,480
really

688
00:24:12,480 --> 00:24:14,880
i would say crazy glitches like dropping

689
00:24:14,880 --> 00:24:16,799
the voltage to minus four volts for one

690
00:24:16,799 --> 00:24:19,600
microseconds you could see here there is

691
00:24:19,600 --> 00:24:21,520
a spike there usually when you have

692
00:24:21,520 --> 00:24:22,960
glitches that big

693
00:24:22,960 --> 00:24:24,640
either you have the device doing

694
00:24:24,640 --> 00:24:26,480
something or you have smoke

695
00:24:26,480 --> 00:24:29,679
but this device was sort of okay

696
00:24:29,679 --> 00:24:31,679
what's going on well what's going on is

697
00:24:31,679 --> 00:24:33,039
nothing

698
00:24:33,039 --> 00:24:34,159
interesting

699
00:24:34,159 --> 00:24:36,159
so in this case this jeep has an

700
00:24:36,159 --> 00:24:37,760
internal power supply it's called

701
00:24:37,760 --> 00:24:39,440
switching mode power supply and that

702
00:24:39,440 --> 00:24:40,720
thing seems to eat glitches for

703
00:24:40,720 --> 00:24:42,159
breakfast

704
00:24:42,159 --> 00:24:43,039
so

705
00:24:43,039 --> 00:24:44,240
cool

706
00:24:44,240 --> 00:24:46,080
as a developer if you can please use

707
00:24:46,080 --> 00:24:47,600
this you can disable it if you want by

708
00:24:47,600 --> 00:24:49,120
software but please use it this thing

709
00:24:49,120 --> 00:24:52,720
makes voltage glitching a lot harder

710
00:24:52,720 --> 00:24:56,240
but of course we don't give up easily so

711
00:24:56,240 --> 00:24:57,840
this doesn't work this is the moment

712
00:24:57,840 --> 00:24:59,279
that when things don't work as you

713
00:24:59,279 --> 00:25:01,360
expect you go back to the books and okay

714
00:25:01,360 --> 00:25:02,799
let's study further

715
00:25:02,799 --> 00:25:05,200
study further means data sheets you

716
00:25:05,200 --> 00:25:07,360
start reading further and then you see

717
00:25:07,360 --> 00:25:09,600
when the voltage supply drops below the

718
00:25:09,600 --> 00:25:12,240
selected brown out region then this

719
00:25:12,240 --> 00:25:15,760
thing this snps that you found

720
00:25:15,760 --> 00:25:18,240
is actually bypassed so basically we

721
00:25:18,240 --> 00:25:20,559
don't have this now we just connect the

722
00:25:20,559 --> 00:25:23,120
input and output of this snps so we

723
00:25:23,120 --> 00:25:24,720
bypass it

724
00:25:24,720 --> 00:25:27,200
so what we did is okay cool so let's

725
00:25:27,200 --> 00:25:29,360
lower the voltage to the minimum so that

726
00:25:29,360 --> 00:25:30,880
this happens

727
00:25:30,880 --> 00:25:33,600
and what happens when we start reaching

728
00:25:33,600 --> 00:25:36,080
hey we start getting glitches

729
00:25:36,080 --> 00:25:37,600
cool

730
00:25:37,600 --> 00:25:40,080
also the datasheet says if you do these

731
00:25:40,080 --> 00:25:41,679
connections and you do this you

732
00:25:41,679 --> 00:25:43,360
physically bypass the snp and the

733
00:25:43,360 --> 00:25:45,200
switching mode power supply

734
00:25:45,200 --> 00:25:47,039
so we did that and see what happens what

735
00:25:47,039 --> 00:25:49,440
do you get more glitches

736
00:25:49,440 --> 00:25:51,440
for experimenting this was just for fun

737
00:25:51,440 --> 00:25:52,320
but

738
00:25:52,320 --> 00:25:54,400
what happens if we do emfi electronic

739
00:25:54,400 --> 00:25:57,360
default injection also glitches okay so

740
00:25:57,360 --> 00:25:59,600
glitches is something that if you try a

741
00:25:59,600 --> 00:26:01,760
bit you will always get a simple glitch

742
00:26:01,760 --> 00:26:02,880
happens

743
00:26:02,880 --> 00:26:04,480
and this is interesting because now for

744
00:26:04,480 --> 00:26:06,000
this first step

745
00:26:06,000 --> 00:26:08,080
as the attack results in the conclusion

746
00:26:08,080 --> 00:26:10,720
basically we have the data sheet saying

747
00:26:10,720 --> 00:26:13,200
if you go to level two then this

748
00:26:13,200 --> 00:26:15,200
basically is irreversible and you cannot

749
00:26:15,200 --> 00:26:17,520
debug anything and whatnot

750
00:26:17,520 --> 00:26:19,120
might be there should be some uh

751
00:26:19,120 --> 00:26:21,919
asterisk that says except if you try f5

752
00:26:21,919 --> 00:26:23,600
because then this is not irreversible

753
00:26:23,600 --> 00:26:25,440
anymore

754
00:26:25,440 --> 00:26:28,080
so yeah basically you can start opening

755
00:26:28,080 --> 00:26:29,760
jtag but this is

756
00:26:29,760 --> 00:26:32,480
yeah what can we do with this okay so

757
00:26:32,480 --> 00:26:34,320
this is something that well it happened

758
00:26:34,320 --> 00:26:36,159
that we took this sdg but if we tried

759
00:26:36,159 --> 00:26:37,600
other renders we probably can do the

760
00:26:37,600 --> 00:26:38,799
same

761
00:26:38,799 --> 00:26:40,080
so

762
00:26:40,080 --> 00:26:42,320
yeah what we can do is at least we can

763
00:26:42,320 --> 00:26:44,240
load code we can even go to this fully

764
00:26:44,240 --> 00:26:46,559
debug mode but we will erase the secure

765
00:26:46,559 --> 00:26:48,720
the non-secure flash the user data the

766
00:26:48,720 --> 00:26:50,400
security domain is still intact that

767
00:26:50,400 --> 00:26:53,120
thing is untouchable okay but we cannot

768
00:26:53,120 --> 00:26:54,559
do anything

769
00:26:54,559 --> 00:26:57,600
so in this case what we will do is okay

770
00:26:57,600 --> 00:27:00,159
at least now i can load code my first

771
00:27:00,159 --> 00:27:02,000
stage my first limitation that i can't

772
00:27:02,000 --> 00:27:04,320
do anything with a glitch now we

773
00:27:04,320 --> 00:27:08,159
bypassed it so what next well now this

774
00:27:08,159 --> 00:27:09,679
is the moment that we will go to a

775
00:27:09,679 --> 00:27:11,120
software exploit

776
00:27:11,120 --> 00:27:12,159
okay

777
00:27:12,159 --> 00:27:13,919
so in this case i'm going to give the

778
00:27:13,919 --> 00:27:17,200
word fulfilling to federico

779
00:27:19,600 --> 00:27:22,080
okay thank you rafa

780
00:27:22,080 --> 00:27:24,399
so indeed now we are in a situation

781
00:27:24,399 --> 00:27:26,320
where we can control all the code that

782
00:27:26,320 --> 00:27:28,720
is being run in the non-secure core

783
00:27:28,720 --> 00:27:29,919
and we want to

784
00:27:29,919 --> 00:27:31,919
try to attack the secure core

785
00:27:31,919 --> 00:27:34,159
and the way the communication works

786
00:27:34,159 --> 00:27:36,480
between the two cores is very simple

787
00:27:36,480 --> 00:27:38,880
it has a mailbox system called ipcc it's

788
00:27:38,880 --> 00:27:40,960
the usual mailbox system you set up it

789
00:27:40,960 --> 00:27:42,799
in a register user or an interrupt on

790
00:27:42,799 --> 00:27:44,240
the other side

791
00:27:44,240 --> 00:27:45,440
and then the other side can start

792
00:27:45,440 --> 00:27:47,120
passing the command

793
00:27:47,120 --> 00:27:48,720
and there is a shared buffer between the

794
00:27:48,720 --> 00:27:50,960
two cores in sram and the offset within

795
00:27:50,960 --> 00:27:53,760
this sr memory is set in one of the

796
00:27:53,760 --> 00:27:56,159
option bytes

797
00:27:56,159 --> 00:27:57,200
now

798
00:27:57,200 --> 00:27:59,840
the messages within

799
00:27:59,840 --> 00:28:02,960
this command buffer are not just simple

800
00:28:02,960 --> 00:28:04,720
command response but actually they are

801
00:28:04,720 --> 00:28:06,159
quite complex messages they have

802
00:28:06,159 --> 00:28:08,640
pointers to pointers etc

803
00:28:08,640 --> 00:28:10,320
and the secure core will have to parse

804
00:28:10,320 --> 00:28:11,039
them

805
00:28:11,039 --> 00:28:12,799
process them and write

806
00:28:12,799 --> 00:28:14,840
their answer back to the same shared

807
00:28:14,840 --> 00:28:17,760
memory uh one thing important to notice

808
00:28:17,760 --> 00:28:19,279
is also that

809
00:28:19,279 --> 00:28:20,799
there are many different firmwares you

810
00:28:20,799 --> 00:28:24,320
can load in your secure code core

811
00:28:24,320 --> 00:28:25,760
depending on the functionality you want

812
00:28:25,760 --> 00:28:27,360
to implement for instance you can load a

813
00:28:27,360 --> 00:28:29,200
zigbee firmware or you can load a

814
00:28:29,200 --> 00:28:31,279
bluetooth firmware but the flash update

815
00:28:31,279 --> 00:28:33,120
firmware which is used to update the

816
00:28:33,120 --> 00:28:35,679
firmware of the m0 is always present so

817
00:28:35,679 --> 00:28:37,919
we decided to focus on this specific

818
00:28:37,919 --> 00:28:39,360
firmware

819
00:28:39,360 --> 00:28:42,000
and sd documentation is very open about

820
00:28:42,000 --> 00:28:43,120
this and it contains a lot of

821
00:28:43,120 --> 00:28:44,799
information on how to talk to the secure

822
00:28:44,799 --> 00:28:45,919
firmware

823
00:28:45,919 --> 00:28:47,760
and the first thing you need to do to

824
00:28:47,760 --> 00:28:50,320
talk to it is set up this table

825
00:28:50,320 --> 00:28:51,679
where each

826
00:28:51,679 --> 00:28:53,600
of these entries is a pointer to another

827
00:28:53,600 --> 00:28:54,799
table

828
00:28:54,799 --> 00:28:56,559
and for our attack we would like to

829
00:28:56,559 --> 00:28:58,159
focus on the system table that is the

830
00:28:58,159 --> 00:29:00,240
main one used to communicate with the

831
00:29:00,240 --> 00:29:02,720
firmware update service

832
00:29:02,720 --> 00:29:04,480
it's the fourth entry here as

833
00:29:04,480 --> 00:29:06,960
highlighted by the arrow

834
00:29:06,960 --> 00:29:07,919
now

835
00:29:07,919 --> 00:29:09,840
if we look at sd's documentation we see

836
00:29:09,840 --> 00:29:10,720
that

837
00:29:10,720 --> 00:29:13,760
within the system table

838
00:29:13,760 --> 00:29:15,919
there is at offset zero

839
00:29:15,919 --> 00:29:19,039
another pointer to a buffer and this is

840
00:29:19,039 --> 00:29:22,158
our command buffer

841
00:29:22,399 --> 00:29:24,320
we will put our command there and the

842
00:29:24,320 --> 00:29:26,399
secure core will put its answer back in

843
00:29:26,399 --> 00:29:29,039
the same location

844
00:29:29,039 --> 00:29:32,399
um so fortunately we don't have to set

845
00:29:32,399 --> 00:29:34,640
up all these tables ourselves

846
00:29:34,640 --> 00:29:36,880
because the rom code implements some

847
00:29:36,880 --> 00:29:39,360
functionality to update the firmware in

848
00:29:39,360 --> 00:29:41,120
the secure core

849
00:29:41,120 --> 00:29:43,039
which means we can

850
00:29:43,039 --> 00:29:45,440
simply connect the jtag as we mentioned

851
00:29:45,440 --> 00:29:48,080
earlier jtag access is open we can read

852
00:29:48,080 --> 00:29:50,080
out the wrong we can also read out these

853
00:29:50,080 --> 00:29:52,399
sram tables which have been set up by

854
00:29:52,399 --> 00:29:54,080
the wrong code so we don't have to

855
00:29:54,080 --> 00:29:56,080
compute them ourselves

856
00:29:56,080 --> 00:29:58,559
and this is how they look like i hope

857
00:29:58,559 --> 00:29:59,760
everybody can read them maybe they're a

858
00:29:59,760 --> 00:30:01,679
bit small but i'll try to go through

859
00:30:01,679 --> 00:30:03,440
them

860
00:30:03,440 --> 00:30:04,320
this

861
00:30:04,320 --> 00:30:05,440
is

862
00:30:05,440 --> 00:30:09,600
the beginning of a shared sram

863
00:30:09,600 --> 00:30:11,520
and if you remember earlier i said we

864
00:30:11,520 --> 00:30:13,200
will focus on the system table which is

865
00:30:13,200 --> 00:30:14,960
the fourth pointer

866
00:30:14,960 --> 00:30:16,880
and you can see there it's highlighted

867
00:30:16,880 --> 00:30:20,000
there one two three four

868
00:30:20,000 --> 00:30:21,520
now

869
00:30:21,520 --> 00:30:24,919
the base address of the sram is

870
00:30:24,919 --> 00:30:28,080
203000 and this is in little engine

871
00:30:28,080 --> 00:30:30,480
so basically what this says is that

872
00:30:30,480 --> 00:30:32,559
it will point to the next table which is

873
00:30:32,559 --> 00:30:34,880
at offset 5c within this

874
00:30:34,880 --> 00:30:38,000
view and there is offset 5c

875
00:30:38,000 --> 00:30:39,679
and here is exactly the same thing there

876
00:30:39,679 --> 00:30:42,399
is another pointer to offset 64.

877
00:30:42,399 --> 00:30:46,559
where is offset 64 there

878
00:30:46,559 --> 00:30:49,440
so that's where we will have to put our

879
00:30:49,440 --> 00:30:51,120
command and that's where the secure core

880
00:30:51,120 --> 00:30:54,000
will put its answer

881
00:30:54,480 --> 00:30:55,360
so

882
00:30:55,360 --> 00:30:56,559
there are two pointers to be

883
00:30:56,559 --> 00:30:58,399
de-referenced

884
00:30:58,399 --> 00:30:59,919
is it done right

885
00:30:59,919 --> 00:31:02,159
and of course if i ask the question you

886
00:31:02,159 --> 00:31:04,880
probably guess the answer

887
00:31:04,880 --> 00:31:05,760
but

888
00:31:05,760 --> 00:31:08,399
what should the secure card check

889
00:31:08,399 --> 00:31:10,559
it should check that both buffers should

890
00:31:10,559 --> 00:31:12,799
be fully within the shared sram

891
00:31:12,799 --> 00:31:14,720
and you should check this both when

892
00:31:14,720 --> 00:31:16,320
reading from the buffers and when

893
00:31:16,320 --> 00:31:19,840
writing back its answer

894
00:31:20,080 --> 00:31:22,559
so we started thinking let's try to do a

895
00:31:22,559 --> 00:31:25,519
sort of time of check time of use attack

896
00:31:25,519 --> 00:31:27,279
we set up correct table we already have

897
00:31:27,279 --> 00:31:28,799
it there

898
00:31:28,799 --> 00:31:30,720
we send a command put it in the buffer

899
00:31:30,720 --> 00:31:32,399
as it was shown

900
00:31:32,399 --> 00:31:34,080
and then we wait some time for the

901
00:31:34,080 --> 00:31:35,840
secure car to be able to read this

902
00:31:35,840 --> 00:31:36,880
command

903
00:31:36,880 --> 00:31:39,679
and then we change the tables to point

904
00:31:39,679 --> 00:31:43,840
the response buffer somewhere else

905
00:31:44,399 --> 00:31:47,760
so we hope that the secure car will read

906
00:31:47,760 --> 00:31:49,440
our message from the share sram but

907
00:31:49,440 --> 00:31:50,880
because we change the pointers in the

908
00:31:50,880 --> 00:31:53,600
meanwhile it will write

909
00:31:53,600 --> 00:31:56,799
its answer in interior memory

910
00:31:56,799 --> 00:31:59,120
hope that something nice for us happens

911
00:31:59,120 --> 00:32:01,200
and we can get something out of it this

912
00:32:01,200 --> 00:32:02,559
step is still a bit unclear at the

913
00:32:02,559 --> 00:32:04,640
moment

914
00:32:04,640 --> 00:32:06,480
and we try the approach and indeed it

915
00:32:06,480 --> 00:32:09,440
seemed to work so for instance we could

916
00:32:09,440 --> 00:32:10,799
point this

917
00:32:10,799 --> 00:32:12,640
shared buffer after sending our command

918
00:32:12,640 --> 00:32:14,640
to a physical address that does not

919
00:32:14,640 --> 00:32:16,720
exist nothing is met there the secure

920
00:32:16,720 --> 00:32:18,000
card will crash

921
00:32:18,000 --> 00:32:19,519
and this gives us indication it was

922
00:32:19,519 --> 00:32:22,399
trying to write to a map memory

923
00:32:22,399 --> 00:32:24,399
so what do we want to override now and

924
00:32:24,399 --> 00:32:26,159
with what

925
00:32:26,159 --> 00:32:29,120
this is not very simple

926
00:32:29,120 --> 00:32:30,720
because the set of answers that the

927
00:32:30,720 --> 00:32:34,240
secure core can return is very limited

928
00:32:34,240 --> 00:32:35,840
it's always five bytes that it will

929
00:32:35,840 --> 00:32:38,240
write back two bytes are fixed header we

930
00:32:38,240 --> 00:32:40,480
do not control at all an acknowledgement

931
00:32:40,480 --> 00:32:42,320
of the command id that we fully control

932
00:32:42,320 --> 00:32:44,320
and one status byte that says whether

933
00:32:44,320 --> 00:32:46,799
the processing was successful or not so

934
00:32:46,799 --> 00:32:50,000
it's usually either zero or ff

935
00:32:50,000 --> 00:32:51,840
we do not have access to the firmware

936
00:32:51,840 --> 00:32:54,480
running on the secure core

937
00:32:54,480 --> 00:32:56,240
the secure car is also configured so

938
00:32:56,240 --> 00:32:58,000
that only the flash is executable we

939
00:32:58,000 --> 00:32:59,600
cannot somehow

940
00:32:59,600 --> 00:33:01,919
corrupt this value on the stack and have

941
00:33:01,919 --> 00:33:03,600
it jump to our code

942
00:33:03,600 --> 00:33:05,120
this is a very difficult primitive to

943
00:33:05,120 --> 00:33:07,918
use blindly

944
00:33:09,200 --> 00:33:12,159
so since we couldn't come up with

945
00:33:12,159 --> 00:33:14,159
anything smart we decided to try

946
00:33:14,159 --> 00:33:16,399
something simple if you remember earlier

947
00:33:16,399 --> 00:33:18,320
uh rafa explained

948
00:33:18,320 --> 00:33:21,039
that there are some secure option bytes

949
00:33:21,039 --> 00:33:24,240
that define the security of a secure

950
00:33:24,240 --> 00:33:25,279
card

951
00:33:25,279 --> 00:33:26,320
so

952
00:33:26,320 --> 00:33:28,799
this option bytes are memory mapped we

953
00:33:28,799 --> 00:33:31,039
know where they are mapped because the

954
00:33:31,039 --> 00:33:33,760
view of the physical address is the same

955
00:33:33,760 --> 00:33:35,919
between the two cores

956
00:33:35,919 --> 00:33:37,200
and

957
00:33:37,200 --> 00:33:39,120
we decided

958
00:33:39,120 --> 00:33:40,640
let's maybe

959
00:33:40,640 --> 00:33:42,399
just point

960
00:33:42,399 --> 00:33:44,640
the response buffer on top of these

961
00:33:44,640 --> 00:33:46,320
option bytes

962
00:33:46,320 --> 00:33:48,720
see what happens

963
00:33:48,720 --> 00:33:51,760
to make things even more unpredictable

964
00:33:51,760 --> 00:33:53,760
because these are 32-bit register but

965
00:33:53,760 --> 00:33:56,720
the answer is copied by twice with a mem

966
00:33:56,720 --> 00:33:59,440
copy that does it by twice

967
00:33:59,440 --> 00:34:01,279
it will not actually write there what

968
00:34:01,279 --> 00:34:03,440
you think is going to right there

969
00:34:03,440 --> 00:34:05,679
because if you write eight bits into a

970
00:34:05,679 --> 00:34:07,600
30 bit register

971
00:34:07,600 --> 00:34:10,800
and offset within this registers

972
00:34:10,800 --> 00:34:12,800
the hardware might do strange things

973
00:34:12,800 --> 00:34:14,560
depending on how the

974
00:34:14,560 --> 00:34:16,639
register is implemented

975
00:34:16,639 --> 00:34:18,719
so let's say

976
00:34:18,719 --> 00:34:20,719
let's just try to point it there let's

977
00:34:20,719 --> 00:34:22,079
try to be lucky

978
00:34:22,079 --> 00:34:23,119
what

979
00:34:23,119 --> 00:34:25,040
do we need to be lucky

980
00:34:25,040 --> 00:34:27,520
well if we look at the documentation of

981
00:34:27,520 --> 00:34:30,800
st there are actually a lot of ways

982
00:34:30,800 --> 00:34:32,960
to completely disable

983
00:34:32,960 --> 00:34:34,480
the security there

984
00:34:34,480 --> 00:34:37,280
just by simply flipping one bit

985
00:34:37,280 --> 00:34:39,119
so there is

986
00:34:39,119 --> 00:34:40,879
this which disables

987
00:34:40,879 --> 00:34:43,440
cpu2 cpu is another name for the secure

988
00:34:43,440 --> 00:34:45,040
core or m0

989
00:34:45,040 --> 00:34:47,520
debug access so if we set that to zero

990
00:34:47,520 --> 00:34:49,440
for instance we will enable jtag access

991
00:34:49,440 --> 00:34:50,960
to cpu2

992
00:34:50,960 --> 00:34:53,280
we can completely disable uh flash

993
00:34:53,280 --> 00:34:55,040
security so the whole flash will be

994
00:34:55,040 --> 00:34:58,240
access to all to the non-secure car

995
00:34:58,240 --> 00:34:59,760
you can modify the start address of a

996
00:34:59,760 --> 00:35:01,599
secure flash

997
00:35:01,599 --> 00:35:04,320
you can also change the reset vector of

998
00:35:04,320 --> 00:35:08,800
the secure car which means even though

999
00:35:09,119 --> 00:35:11,520
there is a configured secure flash you

1000
00:35:11,520 --> 00:35:13,520
can make the reset vector point to

1001
00:35:13,520 --> 00:35:16,000
non-secure flash and have a secure car

1002
00:35:16,000 --> 00:35:18,560
boot from there which we can control

1003
00:35:18,560 --> 00:35:21,119
so we decided whatever let's not think

1004
00:35:21,119 --> 00:35:23,599
about it let's just run the attack uh

1005
00:35:23,599 --> 00:35:25,119
slam something on top of the secure

1006
00:35:25,119 --> 00:35:27,280
option bytes and see what happens

1007
00:35:27,280 --> 00:35:29,599
and actually we were successful

1008
00:35:29,599 --> 00:35:32,800
so we managed to get lucky

1009
00:35:32,800 --> 00:35:33,760
and

1010
00:35:33,760 --> 00:35:35,520
by pointing it

1011
00:35:35,520 --> 00:35:37,839
pointing the answer on top of

1012
00:35:37,839 --> 00:35:38,640
the

1013
00:35:38,640 --> 00:35:40,640
secure option by that configures the

1014
00:35:40,640 --> 00:35:45,839
start address so the reset vector of m0

1015
00:35:45,839 --> 00:35:47,680
this preset vector will point to

1016
00:35:47,680 --> 00:35:49,200
non-secure flash

1017
00:35:49,200 --> 00:35:50,960
and we can

1018
00:35:50,960 --> 00:35:52,880
simply control the contents of a

1019
00:35:52,880 --> 00:35:54,640
non-secure flash we can program there

1020
00:35:54,640 --> 00:35:56,560
some small shell code that disable all

1021
00:35:56,560 --> 00:35:59,760
the security enabled shata etc

1022
00:35:59,760 --> 00:36:01,920
and then we can read the secure the full

1023
00:36:01,920 --> 00:36:04,240
secure flash both from non-secure core

1024
00:36:04,240 --> 00:36:05,920
and the flash

1025
00:36:05,920 --> 00:36:08,640
and the jtag

1026
00:36:10,839 --> 00:36:14,079
so uh for a full attack

1027
00:36:14,079 --> 00:36:16,880
uh what do we need to do

1028
00:36:16,880 --> 00:36:18,720
well we would simply need to get a

1029
00:36:18,720 --> 00:36:20,160
device just

1030
00:36:20,160 --> 00:36:22,560
from the shell fully locked one use

1031
00:36:22,560 --> 00:36:24,000
fault injection

1032
00:36:24,000 --> 00:36:26,560
to downgrade the security that's what uh

1033
00:36:26,560 --> 00:36:28,640
rafa just presented

1034
00:36:28,640 --> 00:36:31,440
we can erase the non-secure flash only

1035
00:36:31,440 --> 00:36:33,440
and go to unlock mode and load our

1036
00:36:33,440 --> 00:36:36,160
software exploit and then we can also

1037
00:36:36,160 --> 00:36:38,079
compromise the secure core

1038
00:36:38,079 --> 00:36:40,960
and run our code from there and

1039
00:36:40,960 --> 00:36:41,839
uh

1040
00:36:41,839 --> 00:36:43,359
yeah maybe something interesting to

1041
00:36:43,359 --> 00:36:46,240
notice is that uh earlier we mentioned

1042
00:36:46,240 --> 00:36:48,400
secure core has some

1043
00:36:48,400 --> 00:36:50,480
secure key storage and these keys are

1044
00:36:50,480 --> 00:36:52,880
hidden from the non-secure core but

1045
00:36:52,880 --> 00:36:55,040
because of this attack even though we

1046
00:36:55,040 --> 00:36:57,040
erase a non-secure flash the secure

1047
00:36:57,040 --> 00:37:00,000
flash is still preserved which means

1048
00:37:00,000 --> 00:37:02,000
we would lose any key that is stored in

1049
00:37:02,000 --> 00:37:04,240
the non-secure flash but we can recover

1050
00:37:04,240 --> 00:37:05,760
all the keys that are stored in the

1051
00:37:05,760 --> 00:37:07,359
secure flash which is sort of

1052
00:37:07,359 --> 00:37:11,279
counter-intuitive if you think about it

1053
00:37:11,440 --> 00:37:13,119
anyway

1054
00:37:13,119 --> 00:37:15,680
now it's demo time and rafa believes in

1055
00:37:15,680 --> 00:37:19,280
the demo gods so he can do the demo

1056
00:37:19,280 --> 00:37:23,599
so i will try my best let's see

1057
00:37:23,599 --> 00:37:25,359
so

1058
00:37:25,359 --> 00:37:27,280
one of the things that i should mention

1059
00:37:27,280 --> 00:37:29,280
is uh well

1060
00:37:29,280 --> 00:37:31,680
i have i can show you later a stack of

1061
00:37:31,680 --> 00:37:33,440
boards actually

1062
00:37:33,440 --> 00:37:37,200
i got only this board yesterday so

1063
00:37:37,200 --> 00:37:39,680
we cannot really reproduce all the steps

1064
00:37:39,680 --> 00:37:41,520
because i cannot now be fiddling with

1065
00:37:41,520 --> 00:37:43,200
setting the jumpers and this is a bit

1066
00:37:43,200 --> 00:37:45,040
shaky but at least hopefully the

1067
00:37:45,040 --> 00:37:47,520
glitching part i can show

1068
00:37:47,520 --> 00:37:48,480
okay

1069
00:37:48,480 --> 00:37:53,280
so let's minimize all these things

1070
00:37:53,680 --> 00:37:55,920
minimize more

1071
00:37:55,920 --> 00:37:58,640
so what happens is the following here i

1072
00:37:58,640 --> 00:38:00,720
have now the device and the device is

1073
00:38:00,720 --> 00:38:01,839
fully locked

1074
00:38:01,839 --> 00:38:03,680
and what we did is we connected the

1075
00:38:03,680 --> 00:38:06,160
power supply to this device which allows

1076
00:38:06,160 --> 00:38:07,839
now to inject glitches

1077
00:38:07,839 --> 00:38:10,000
and basically what's going to happen is

1078
00:38:10,000 --> 00:38:13,200
we power off the device power it up wait

1079
00:38:13,200 --> 00:38:14,880
for some time and this time that we

1080
00:38:14,880 --> 00:38:16,560
found this where the option bites is

1081
00:38:16,560 --> 00:38:17,839
glitch

1082
00:38:17,839 --> 00:38:19,280
okay it's a very

1083
00:38:19,280 --> 00:38:21,280
naive approach

1084
00:38:21,280 --> 00:38:23,280
then here hopefully you can see my

1085
00:38:23,280 --> 00:38:25,760
screen yes you can so we did some

1086
00:38:25,760 --> 00:38:28,320
initial campaign to try and then here we

1087
00:38:28,320 --> 00:38:30,640
have different settings that we were

1088
00:38:30,640 --> 00:38:33,280
finding this seems to work in our case

1089
00:38:33,280 --> 00:38:35,359
okay and in around that timing over

1090
00:38:35,359 --> 00:38:37,760
there that time window is where we guess

1091
00:38:37,760 --> 00:38:40,160
that this is happening

1092
00:38:40,160 --> 00:38:41,040
so

1093
00:38:41,040 --> 00:38:43,280
now demo gods please don't fail me too

1094
00:38:43,280 --> 00:38:46,079
hard

1095
00:38:46,079 --> 00:38:48,640
start this

1096
00:38:49,359 --> 00:38:50,800
okay

1097
00:38:50,800 --> 00:38:54,320
my computer is thinking about life

1098
00:38:55,440 --> 00:38:58,640
okay come on

1099
00:38:59,520 --> 00:39:00,720
yeah i think there were too many

1100
00:39:00,720 --> 00:39:02,640
successful demos in the previous one so

1101
00:39:02,640 --> 00:39:04,870
now we have a bit of bad karma

1102
00:39:04,870 --> 00:39:07,760
[Music]

1103
00:39:07,760 --> 00:39:10,079
come on

1104
00:39:10,079 --> 00:39:11,839
is this on

1105
00:39:11,839 --> 00:39:12,839
yes this

1106
00:39:12,839 --> 00:39:18,160
is if i click on the wrong button maybe

1107
00:39:19,280 --> 00:39:21,119
okay i think i might have clicked on the

1108
00:39:21,119 --> 00:39:25,480
wrong button so let me try once more

1109
00:39:30,160 --> 00:39:32,160
and

1110
00:39:32,160 --> 00:39:33,680
yeah as i said

1111
00:39:33,680 --> 00:39:36,799
connecting things now

1112
00:39:39,520 --> 00:39:42,520
okay

1113
00:39:43,200 --> 00:39:44,880
and

1114
00:39:44,880 --> 00:39:48,560
let me quickly check one more thing

1115
00:39:57,280 --> 00:39:59,760
okay the demo effect yeah this is i

1116
00:39:59,760 --> 00:40:01,280
guess the coffee time is now just

1117
00:40:01,280 --> 00:40:02,800
pressing

1118
00:40:02,800 --> 00:40:05,280
so well then i'm going to do one thing

1119
00:40:05,280 --> 00:40:09,040
i'm going to restart the tool just

1120
00:40:09,359 --> 00:40:11,359
because the solution of it for

1121
00:40:11,359 --> 00:40:13,200
everything often works which is just

1122
00:40:13,200 --> 00:40:15,760
power off and power up everything

1123
00:40:15,760 --> 00:40:19,119
okay so i have this is resets this is

1124
00:40:19,119 --> 00:40:21,520
done let's restart the software in the

1125
00:40:21,520 --> 00:40:23,200
meantime now what i'm going to i can't

1126
00:40:23,200 --> 00:40:24,480
explain what's going to happen so

1127
00:40:24,480 --> 00:40:26,880
basically here we have an application

1128
00:40:26,880 --> 00:40:29,520
which is telling us the option bytes and

1129
00:40:29,520 --> 00:40:30,960
then you will see that we're going to

1130
00:40:30,960 --> 00:40:33,040
try glitch glitch glitch glitch glitch

1131
00:40:33,040 --> 00:40:35,760
and hopefully we will manage to trigger

1132
00:40:35,760 --> 00:40:37,760
that this option byte that is the

1133
00:40:37,760 --> 00:40:40,000
lockdown glitch sorry the lockdown

1134
00:40:40,000 --> 00:40:41,839
option byte we will reach it back to

1135
00:40:41,839 --> 00:40:44,160
something random because this is

1136
00:40:44,160 --> 00:40:46,160
basically this mode where we have

1137
00:40:46,160 --> 00:40:47,760
partial access

1138
00:40:47,760 --> 00:40:50,160
and if we get to do that then we should

1139
00:40:50,160 --> 00:40:50,839
see

1140
00:40:50,839 --> 00:40:53,200
something okay

1141
00:40:53,200 --> 00:40:54,319
so

1142
00:40:54,319 --> 00:40:58,960
let me also disconnect this just in case

1143
00:41:00,030 --> 00:41:02,240
[Music]

1144
00:41:02,240 --> 00:41:04,319
the demo effect

1145
00:41:04,319 --> 00:41:06,160
yeah i don't have any good joke to tell

1146
00:41:06,160 --> 00:41:08,960
now so

1147
00:41:09,040 --> 00:41:11,359
okay

1148
00:41:11,520 --> 00:41:13,599
so do you want to take some questions

1149
00:41:13,599 --> 00:41:16,319
while we're waiting uh

1150
00:41:16,319 --> 00:41:18,480
yeah if you have any questions we

1151
00:41:18,480 --> 00:41:20,079
haven't taken one question in the

1152
00:41:20,079 --> 00:41:22,880
meantime yes

1153
00:41:26,240 --> 00:41:27,680
okay thank you very much for your

1154
00:41:27,680 --> 00:41:30,879
presentation uh

1155
00:41:31,200 --> 00:41:33,839
glitches are very efficient but they are

1156
00:41:33,839 --> 00:41:36,640
also very dangerous i don't know

1157
00:41:36,640 --> 00:41:39,680
if you encounter the enemy erase

1158
00:41:39,680 --> 00:41:42,079
or you already damaged the chip while

1159
00:41:42,079 --> 00:41:43,760
you are doing this kind of glitch for

1160
00:41:43,760 --> 00:41:45,920
the moment sorry i i could not hear

1161
00:41:45,920 --> 00:41:47,040
correctly

1162
00:41:47,040 --> 00:41:49,520
well my question is just did you

1163
00:41:49,520 --> 00:41:51,920
encounter any memory erase

1164
00:41:51,920 --> 00:41:53,680
while you are doing the glitch during

1165
00:41:53,680 --> 00:41:55,359
the boot of the trip

1166
00:41:55,359 --> 00:41:57,359
so it's a question did we encounter any

1167
00:41:57,359 --> 00:42:00,960
memory range there is a race yes it it

1168
00:42:00,960 --> 00:42:03,359
yeah it's a good question so the default

1169
00:42:03,359 --> 00:42:05,760
uh firmware so

1170
00:42:05,760 --> 00:42:07,920
when you get the chip from stock

1171
00:42:07,920 --> 00:42:10,000
what we found is sometimes we corrupted

1172
00:42:10,000 --> 00:42:12,079
this option bytes and then we didn't

1173
00:42:12,079 --> 00:42:13,839
erase the flash but we corrupted this

1174
00:42:13,839 --> 00:42:15,920
option bytes in a place that it got

1175
00:42:15,920 --> 00:42:17,200
bricked

1176
00:42:17,200 --> 00:42:19,440
the newer updates of the firmware

1177
00:42:19,440 --> 00:42:20,960
actually prevents this from happening

1178
00:42:20,960 --> 00:42:22,079
because which is also happening in

1179
00:42:22,079 --> 00:42:22,960
nature

1180
00:42:22,960 --> 00:42:24,720
physical destruction of the chip it was

1181
00:42:24,720 --> 00:42:26,800
really hard so we did not actually erase

1182
00:42:26,800 --> 00:42:28,839
the flash we just corrupted

1183
00:42:28,839 --> 00:42:32,079
things okay and what you can do

1184
00:42:32,079 --> 00:42:32,800
to

1185
00:42:32,800 --> 00:42:34,800
to to achieve the attack if you already

1186
00:42:34,800 --> 00:42:37,359
corrupted the option bytes in this case

1187
00:42:37,359 --> 00:42:39,280
if we corrupt the option bytes then we

1188
00:42:39,280 --> 00:42:42,560
can later now go back to these

1189
00:42:42,560 --> 00:42:44,560
partial locked status and then we can

1190
00:42:44,560 --> 00:42:46,240
have some access we can just start

1191
00:42:46,240 --> 00:42:47,920
debugging and doing something from there

1192
00:42:47,920 --> 00:42:49,440
which was from blind exploitation to

1193
00:42:49,440 --> 00:42:51,280
something that's a change

1194
00:42:51,280 --> 00:42:52,480
okay

1195
00:42:52,480 --> 00:42:53,280
so

1196
00:42:53,280 --> 00:42:55,760
unfortunately i don't know what's uh

1197
00:42:55,760 --> 00:42:58,800
going on but then

1198
00:42:58,800 --> 00:43:00,560
yeah thanks for the question so i don't

1199
00:43:00,560 --> 00:43:02,160
know what's going on so what i'm going

1200
00:43:02,160 --> 00:43:04,560
to do is i'm going to just wrap up the

1201
00:43:04,560 --> 00:43:06,560
presentation so that you can see what

1202
00:43:06,560 --> 00:43:08,960
happens but later if you want we can

1203
00:43:08,960 --> 00:43:10,640
show this in the coffee break or you can

1204
00:43:10,640 --> 00:43:14,400
see it so basically i have this in just

1205
00:43:14,400 --> 00:43:16,800
in case the demo was failed so we have

1206
00:43:16,800 --> 00:43:18,720
this is what happens that then you read

1207
00:43:18,720 --> 00:43:21,359
the readout protection by can be 0 1 or

1208
00:43:21,359 --> 00:43:25,359
2 or a b b or cc but then we get ff then

1209
00:43:25,359 --> 00:43:27,760
we can go back to this aa

1210
00:43:27,760 --> 00:43:30,240
this would trigger a flash erase

1211
00:43:30,240 --> 00:43:31,839
but then when you connect the debugger

1212
00:43:31,839 --> 00:43:33,920
you have several options

1213
00:43:33,920 --> 00:43:37,440
and for example this dds this debuggable

1214
00:43:37,440 --> 00:43:39,839
service of this secure core now it will

1215
00:43:39,839 --> 00:43:41,359
not be there

1216
00:43:41,359 --> 00:43:43,680
okay so this is something that we don't

1217
00:43:43,680 --> 00:43:46,079
do with a file this

1218
00:43:46,079 --> 00:43:47,839
part

1219
00:43:47,839 --> 00:43:49,839
we will do by

1220
00:43:49,839 --> 00:43:52,720
one second again

1221
00:43:52,720 --> 00:43:54,880
we will do by doing a very simple

1222
00:43:54,880 --> 00:43:57,119
exploits

1223
00:43:57,119 --> 00:43:59,040
which is basically what fedeco explained

1224
00:43:59,040 --> 00:44:01,760
we wrote a payload in the non-secure

1225
00:44:01,760 --> 00:44:02,720
area

1226
00:44:02,720 --> 00:44:06,400
then we would just first try to corrupt

1227
00:44:06,400 --> 00:44:09,599
the secured core its own configuration

1228
00:44:09,599 --> 00:44:12,400
so we grab the boots the start address

1229
00:44:12,400 --> 00:44:13,920
and then we will make this program to

1230
00:44:13,920 --> 00:44:16,319
run again but instead of

1231
00:44:16,319 --> 00:44:18,319
corrupting the option bytes what we

1232
00:44:18,319 --> 00:44:21,119
would do is we would just store them we

1233
00:44:21,119 --> 00:44:23,280
would just store them with an option

1234
00:44:23,280 --> 00:44:25,520
which says unprotect everything

1235
00:44:25,520 --> 00:44:26,640
okay so

1236
00:44:26,640 --> 00:44:29,359
first fi then once we have access to the

1237
00:44:29,359 --> 00:44:31,520
chip we would run this exploit in

1238
00:44:31,520 --> 00:44:34,160
software which is yeah 10 lines 20 lines

1239
00:44:34,160 --> 00:44:35,760
not very big

1240
00:44:35,760 --> 00:44:39,839
and then we would manage to get control

1241
00:44:39,839 --> 00:44:40,640
okay

1242
00:44:40,640 --> 00:44:42,879
so

1243
00:44:44,160 --> 00:44:46,480
everybody is with attention and silence

1244
00:44:46,480 --> 00:44:48,240
this is also very scary as an app

1245
00:44:48,240 --> 00:44:49,520
presenter

1246
00:44:49,520 --> 00:44:50,480
okay

1247
00:44:50,480 --> 00:44:51,440
so

1248
00:44:51,440 --> 00:44:54,079
conclusions wrapping up

1249
00:44:54,079 --> 00:44:55,200
though

1250
00:44:55,200 --> 00:44:56,640
basically with this divide and conquer

1251
00:44:56,640 --> 00:44:58,560
approach as you can see we didn't try

1252
00:44:58,560 --> 00:45:00,079
anything sophisticated this was just a

1253
00:45:00,079 --> 00:45:02,400
simple glitch and this was just a simple

1254
00:45:02,400 --> 00:45:05,200
exploit not super complicated

1255
00:45:05,200 --> 00:45:08,160
and what we did is basically glitch this

1256
00:45:08,160 --> 00:45:10,240
readout protection mechanism we have now

1257
00:45:10,240 --> 00:45:11,760
access to secure

1258
00:45:11,760 --> 00:45:13,280
non-secure domain

1259
00:45:13,280 --> 00:45:15,920
then we found an exploit we just wrote a

1260
00:45:15,920 --> 00:45:17,520
scene so we find out the vulnerability

1261
00:45:17,520 --> 00:45:19,520
we wrote a simple exploit and as a

1262
00:45:19,520 --> 00:45:21,440
result we achieved a full compromise of

1263
00:45:21,440 --> 00:45:23,440
the security domain okay

1264
00:45:23,440 --> 00:45:25,520
something that we didn't we didn't get

1265
00:45:25,520 --> 00:45:27,760
due to our simple approach is that our

1266
00:45:27,760 --> 00:45:30,480
strategy erases the non-secure domain

1267
00:45:30,480 --> 00:45:32,480
okay so we delete the data there and as

1268
00:45:32,480 --> 00:45:34,480
fedex explained if you put secrets there

1269
00:45:34,480 --> 00:45:36,240
it's counterintuitive but actually this

1270
00:45:36,240 --> 00:45:37,680
would be deleted

1271
00:45:37,680 --> 00:45:39,680
it might be possible to avoid this

1272
00:45:39,680 --> 00:45:42,079
downgrade state we didn't try okay this

1273
00:45:42,079 --> 00:45:43,680
is just for you to see that simple

1274
00:45:43,680 --> 00:45:46,960
glitch simple exploit powerful attack

1275
00:45:46,960 --> 00:45:50,400
mitigations so as a developer this is

1276
00:45:50,400 --> 00:45:52,480
important to now you have not just the

1277
00:45:52,480 --> 00:45:55,200
pure software exploits fi if you

1278
00:45:55,200 --> 00:45:57,200
consider as a software exploitation

1279
00:45:57,200 --> 00:45:59,839
primitive is actually quite powerful and

1280
00:45:59,839 --> 00:46:01,760
this was very naive so this was just my

1281
00:46:01,760 --> 00:46:03,040
first glitch

1282
00:46:03,040 --> 00:46:04,079
day

1283
00:46:04,079 --> 00:46:06,560
attack so this is for example i don't

1284
00:46:06,560 --> 00:46:08,000
know how to call it

1285
00:46:08,000 --> 00:46:09,040
multi

1286
00:46:09,040 --> 00:46:11,280
entry level attacker multi-noob attack

1287
00:46:11,280 --> 00:46:13,040
this is not considered in threat models

1288
00:46:13,040 --> 00:46:16,240
you have entry level attacker or expert

1289
00:46:16,240 --> 00:46:18,079
what happens if you have a couple naive

1290
00:46:18,079 --> 00:46:19,680
attacks and then suddenly it's like

1291
00:46:19,680 --> 00:46:21,359
multi-expert level

1292
00:46:21,359 --> 00:46:23,359
so this is interesting to think as a

1293
00:46:23,359 --> 00:46:26,319
first step including f5 as a threat

1294
00:46:26,319 --> 00:46:28,800
model in your third model is useful

1295
00:46:28,800 --> 00:46:30,319
second thing if you use this specific

1296
00:46:30,319 --> 00:46:32,560
chip please use the switching mode power

1297
00:46:32,560 --> 00:46:34,400
supply this thing is switched for

1298
00:46:34,400 --> 00:46:36,240
breakfast so it's actually quite nice

1299
00:46:36,240 --> 00:46:38,560
for developers and also it's useful to

1300
00:46:38,560 --> 00:46:41,200
add secrets art barriers in every single

1301
00:46:41,200 --> 00:46:44,560
part our attack if you had some secret

1302
00:46:44,560 --> 00:46:47,040
also in this non-secure area this would

1303
00:46:47,040 --> 00:46:49,119
have been blocked

1304
00:46:49,119 --> 00:46:52,079
finally software updates so this is

1305
00:46:52,079 --> 00:46:53,520
something that at least the software

1306
00:46:53,520 --> 00:46:56,000
exploit can be patched by an update and

1307
00:46:56,000 --> 00:46:57,920
actually this was packed so this we did

1308
00:46:57,920 --> 00:47:00,000
coordinated disclosure to st and they

1309
00:47:00,000 --> 00:47:02,480
patched it in the version 1.10.1 of the

1310
00:47:02,480 --> 00:47:05,040
firmware okay so here this is just we

1311
00:47:05,040 --> 00:47:06,960
need coordinated disclosure there is

1312
00:47:06,960 --> 00:47:08,240
some dates later you can check the

1313
00:47:08,240 --> 00:47:10,160
slides but basically it's nice to see

1314
00:47:10,160 --> 00:47:12,000
that developers sometimes care about

1315
00:47:12,000 --> 00:47:14,240
security and they actually patch things

1316
00:47:14,240 --> 00:47:16,400
and well in the end we all use these

1317
00:47:16,400 --> 00:47:18,160
devices so at least it makes me happy

1318
00:47:18,160 --> 00:47:18,960
that

1319
00:47:18,960 --> 00:47:21,440
things are getting better

1320
00:47:21,440 --> 00:47:23,440
as a conclusion from my attacker point

1321
00:47:23,440 --> 00:47:24,559
of view

1322
00:47:24,559 --> 00:47:27,359
then dividing complex exploits into

1323
00:47:27,359 --> 00:47:30,480
simple attacks it might look difficult

1324
00:47:30,480 --> 00:47:34,160
like hardware software but actually we

1325
00:47:34,160 --> 00:47:35,920
are using simple things this is like my

1326
00:47:35,920 --> 00:47:38,400
first exploit my first glitch

1327
00:47:38,400 --> 00:47:40,000
and as a result

1328
00:47:40,000 --> 00:47:41,839
the result is much more powerful than

1329
00:47:41,839 --> 00:47:43,520
the individual things

1330
00:47:43,520 --> 00:47:46,319
okay so in this case a simple fi attack

1331
00:47:46,319 --> 00:47:48,319
maybe to learn is that it can change

1332
00:47:48,319 --> 00:47:49,680
completely the software exploiting

1333
00:47:49,680 --> 00:47:50,800
scenario

1334
00:47:50,800 --> 00:47:52,800
and photo injection resilience is just

1335
00:47:52,800 --> 00:47:54,960
hard to implement it right okay so if

1336
00:47:54,960 --> 00:47:56,720
you see a data sheet and there is no fi

1337
00:47:56,720 --> 00:47:57,920
protection

1338
00:47:57,920 --> 00:47:59,839
divide and conquer glitch something and

1339
00:47:59,839 --> 00:48:02,240
this just make your life easier

1340
00:48:02,240 --> 00:48:04,640
and yeah this kind of techniques you

1341
00:48:04,640 --> 00:48:06,400
will see more and more often in the

1342
00:48:06,400 --> 00:48:08,559
infosec news that glitches are there you

1343
00:48:08,559 --> 00:48:10,480
saw that most of the talks this year on

1344
00:48:10,480 --> 00:48:12,160
hardware io had something to do with

1345
00:48:12,160 --> 00:48:14,640
reaching but not much but a lot of them

1346
00:48:14,640 --> 00:48:16,640
so something that happens

1347
00:48:16,640 --> 00:48:18,800
if you're a developer then

1348
00:48:18,800 --> 00:48:20,559
be aware this is something that is

1349
00:48:20,559 --> 00:48:22,400
happening more and more if you put

1350
00:48:22,400 --> 00:48:25,040
barriers then it's better how to do that

1351
00:48:25,040 --> 00:48:26,800
include a fine your thread model think

1352
00:48:26,800 --> 00:48:28,880
that people can try stupid glitches

1353
00:48:28,880 --> 00:48:31,200
patch the firmware okay so this will

1354
00:48:31,200 --> 00:48:34,160
mitigate at least the impact of a file

1355
00:48:34,160 --> 00:48:35,599
also use the security features on

1356
00:48:35,599 --> 00:48:37,359
properties of the platform

1357
00:48:37,359 --> 00:48:39,440
so you saw the presentation from dr

1358
00:48:39,440 --> 00:48:41,520
sergey kolovrakatov we have security

1359
00:48:41,520 --> 00:48:43,680
features not used if you have it there

1360
00:48:43,680 --> 00:48:45,760
use it it's useful

1361
00:48:45,760 --> 00:48:48,880
and also it's important to put secrets

1362
00:48:48,880 --> 00:48:50,480
scattered because

1363
00:48:50,480 --> 00:48:51,839
then it makes it more difficult the

1364
00:48:51,839 --> 00:48:53,599
attacker needs to now succeed in all

1365
00:48:53,599 --> 00:48:56,079
fronts instead of one and then you have

1366
00:48:56,079 --> 00:48:58,960
all the eggs in the same basket

1367
00:48:58,960 --> 00:49:00,000
so

1368
00:49:00,000 --> 00:49:03,150
this is the end of the presentation

1369
00:49:03,150 --> 00:49:03,920
[Music]

1370
00:49:03,920 --> 00:49:08,400
[Applause]

1371
00:49:08,400 --> 00:49:10,559
thank you and yeah i'm sorry your demo

1372
00:49:10,559 --> 00:49:12,000
didn't work

1373
00:49:12,000 --> 00:49:13,839
next time i recommend you satisfy

1374
00:49:13,839 --> 00:49:15,680
unicorn before you start and then they

1375
00:49:15,680 --> 00:49:17,760
always work so

1376
00:49:17,760 --> 00:49:19,760
we have a long coffee break

1377
00:49:19,760 --> 00:49:21,520
so we actually have another 15 minutes

1378
00:49:21,520 --> 00:49:23,119
so if anyone has a really burning

1379
00:49:23,119 --> 00:49:25,520
question

1380
00:49:28,160 --> 00:49:30,160
so i think i might have just missed this

1381
00:49:30,160 --> 00:49:31,040
the

1382
00:49:31,040 --> 00:49:32,720
software that was actually handling the

1383
00:49:32,720 --> 00:49:34,720
mailbox interface were you saying that

1384
00:49:34,720 --> 00:49:35,680
was a

1385
00:49:35,680 --> 00:49:39,119
firmware update firmware on the m0 side

1386
00:49:39,119 --> 00:49:40,400
and then you listed there were like

1387
00:49:40,400 --> 00:49:43,280
multiple other potential things did each

1388
00:49:43,280 --> 00:49:45,680
of those other things use a similar sort

1389
00:49:45,680 --> 00:49:47,760
of mailbox interface from the m0 to the

1390
00:49:47,760 --> 00:49:50,160
m4

1391
00:49:50,960 --> 00:49:53,200
so yes they do

1392
00:49:53,200 --> 00:49:56,480
and we didn't really look in depth

1393
00:49:56,480 --> 00:49:57,760
on whether they have similar

1394
00:49:57,760 --> 00:50:00,160
vulnerabilities i quickly tried with one

1395
00:50:00,160 --> 00:50:02,240
firmware i think it was a bluetooth and

1396
00:50:02,240 --> 00:50:03,280
it was

1397
00:50:03,280 --> 00:50:05,040
at least not vulnerable to the exactly

1398
00:50:05,040 --> 00:50:07,280
the same attack but it's not something

1399
00:50:07,280 --> 00:50:09,119
we researched thoroughly okay that was

1400
00:50:09,119 --> 00:50:10,480
going to be one question is whether you

1401
00:50:10,480 --> 00:50:13,200
check the others the other question was

1402
00:50:13,200 --> 00:50:15,440
um you were treating the m0 like it was

1403
00:50:15,440 --> 00:50:17,280
a complete black box and that you had no

1404
00:50:17,280 --> 00:50:19,680
visibility whatsoever into it do you

1405
00:50:19,680 --> 00:50:21,839
know whether that firmware updater

1406
00:50:21,839 --> 00:50:25,520
firmware component was used in like

1407
00:50:25,520 --> 00:50:28,079
reference implementations for

1408
00:50:28,079 --> 00:50:30,480
stm like basically if you had bought

1409
00:50:30,480 --> 00:50:32,400
like a developer's board would you have

1410
00:50:32,400 --> 00:50:34,000
seen that same firmware there and

1411
00:50:34,000 --> 00:50:35,920
therefore you could have just you know

1412
00:50:35,920 --> 00:50:38,160
made some assumptions about well this is

1413
00:50:38,160 --> 00:50:40,559
what sd uses over here so maybe it'll be

1414
00:50:40,559 --> 00:50:41,920
on this other system that i want to

1415
00:50:41,920 --> 00:50:43,040
explain

1416
00:50:43,040 --> 00:50:45,440
so actually this firmware has to be

1417
00:50:45,440 --> 00:50:47,040
there

1418
00:50:47,040 --> 00:50:49,280
st makes it and they sign it so they are

1419
00:50:49,280 --> 00:50:50,800
the only people that

1420
00:50:50,800 --> 00:50:53,119
can load code into the m0

1421
00:50:53,119 --> 00:50:54,800
and if you don't have this firmware

1422
00:50:54,800 --> 00:50:56,720
updated service running it means you

1423
00:50:56,720 --> 00:50:58,160
will never be able to update the

1424
00:50:58,160 --> 00:51:00,640
firmware of the m0 again so my

1425
00:51:00,640 --> 00:51:02,319
understanding is that this m0 will

1426
00:51:02,319 --> 00:51:04,400
always be there this firmware date

1427
00:51:04,400 --> 00:51:06,720
service will always be there on the m0

1428
00:51:06,720 --> 00:51:08,400
maybe different versions but it has to

1429
00:51:08,400 --> 00:51:09,520
be there

1430
00:51:09,520 --> 00:51:11,839
thank you

1431
00:51:21,119 --> 00:51:23,520
since all of the m0s are running the

1432
00:51:23,520 --> 00:51:25,760
same firmware that means that there is a

1433
00:51:25,760 --> 00:51:27,040
secret key

1434
00:51:27,040 --> 00:51:29,359
in the uh chip itself were you able to

1435
00:51:29,359 --> 00:51:31,040
extract that or

1436
00:51:31,040 --> 00:51:32,400
dig through the firmware to try to

1437
00:51:32,400 --> 00:51:34,839
figure out where that uh decryption is

1438
00:51:34,839 --> 00:51:38,240
done we would never do that

1439
00:51:38,240 --> 00:51:40,480
but yes okay so but when somebody

1440
00:51:40,480 --> 00:51:42,480
extracts it it's a class break against

1441
00:51:42,480 --> 00:51:45,359
all of these chips yes yes

1442
00:51:45,359 --> 00:51:46,960
there is of course also a public key to

1443
00:51:46,960 --> 00:51:50,720
verify the signature of the firmware so

1444
00:51:50,720 --> 00:51:51,440
that

1445
00:51:51,440 --> 00:51:54,720
that still protects something

1446
00:52:00,640 --> 00:52:03,380
so thank you very much

1447
00:52:03,380 --> 00:52:05,040
[Applause]

1448
00:52:05,040 --> 00:52:07,119
you

