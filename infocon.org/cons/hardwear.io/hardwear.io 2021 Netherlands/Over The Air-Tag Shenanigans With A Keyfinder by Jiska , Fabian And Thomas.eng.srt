1
00:00:02,879 --> 00:00:05,920
what yeah um good morning welcome to our

2
00:00:05,920 --> 00:00:07,839
talk over the ad tech shenanigans with

3
00:00:07,839 --> 00:00:10,320
the most over-engineered key finder in

4
00:00:10,320 --> 00:00:12,400
theory we are three presenters but one

5
00:00:12,400 --> 00:00:14,880
got lost and so my name is thomas roth

6
00:00:14,880 --> 00:00:16,640
aka stack smashing

7
00:00:16,640 --> 00:00:19,039
over here we have yes clarsen of

8
00:00:19,039 --> 00:00:21,840
wireless security fame and fabian who

9
00:00:21,840 --> 00:00:23,840
hopefully will be back soon who is an

10
00:00:23,840 --> 00:00:26,080
independent security researcher

11
00:00:26,080 --> 00:00:29,039
and yeah we basically looked at the

12
00:00:29,039 --> 00:00:31,679
attacks now before we start there are a

13
00:00:31,679 --> 00:00:33,200
couple of people that we need to thank

14
00:00:33,200 --> 00:00:35,360
so first of colin of flynn who for me

15
00:00:35,360 --> 00:00:36,960
was the person that not snapped me with

16
00:00:36,960 --> 00:00:39,200
the attacks in the first place leonard

17
00:00:39,200 --> 00:00:41,280
waters with whom we did a lot of reverse

18
00:00:41,280 --> 00:00:44,000
engineering david halton who as you see

19
00:00:44,000 --> 00:00:46,800
did some awesome pcb layer stuff

20
00:00:46,800 --> 00:00:49,360
limited results because we are using one

21
00:00:49,360 --> 00:00:51,440
of his vulnerabilities and also doc

22
00:00:51,440 --> 00:00:54,559
cruiser who helped out and so check out

23
00:00:54,559 --> 00:00:56,320
these awesome people

24
00:00:56,320 --> 00:00:58,559
they are really great

25
00:00:58,559 --> 00:01:01,120
now let's talk about the attack now the

26
00:01:01,120 --> 00:01:03,280
attack is on the surface a simple key

27
00:01:03,280 --> 00:01:06,000
finder and so really not interesting but

28
00:01:06,000 --> 00:01:07,280
the reason we are saying it's over

29
00:01:07,280 --> 00:01:09,280
engineered is because it's like if you

30
00:01:09,280 --> 00:01:11,439
give an engineer unlimited budget and

31
00:01:11,439 --> 00:01:13,119
tell him to design the key finder this

32
00:01:13,119 --> 00:01:15,119
is probably what he will come up with

33
00:01:15,119 --> 00:01:17,759
and so the attack contains the u1 chip

34
00:01:17,759 --> 00:01:19,680
which is an ultra white band chip and so

35
00:01:19,680 --> 00:01:23,040
you can precisely locate it using a

36
00:01:23,040 --> 00:01:25,360
modern iphone and it also instead of

37
00:01:25,360 --> 00:01:27,840
just using you know bluetooth with one

38
00:01:27,840 --> 00:01:30,720
device or so it uses defined my network

39
00:01:30,720 --> 00:01:32,479
and so each iphone that walks past the

40
00:01:32,479 --> 00:01:34,640
attack will transmit the location of the

41
00:01:34,640 --> 00:01:36,240
air tech

42
00:01:36,240 --> 00:01:38,400
up into the cloud so that you can track

43
00:01:38,400 --> 00:01:41,439
it via any iphone basically

44
00:01:41,439 --> 00:01:43,360
also kind of funny it doesn't actually

45
00:01:43,360 --> 00:01:45,040
it's a key finder but it doesn't

46
00:01:45,040 --> 00:01:48,000
actually attach to a key without versa

47
00:01:48,000 --> 00:01:50,159
accessories

48
00:01:50,159 --> 00:01:52,720
anyway um so i when i heard about the

49
00:01:52,720 --> 00:01:54,640
attacks i wasn't interested in them at

50
00:01:54,640 --> 00:01:56,159
all because you know it's a key finder

51
00:01:56,159 --> 00:01:58,079
so why bother

52
00:01:58,079 --> 00:02:00,000
and then i woke up and i got a message

53
00:02:00,000 --> 00:02:02,159
on twitter saying hey

54
00:02:02,159 --> 00:02:03,600
here are the flash contents of the

55
00:02:03,600 --> 00:02:07,200
attacks and so somebody dumped the spy

56
00:02:07,200 --> 00:02:09,758
flash of the attacks and obviously being

57
00:02:09,758 --> 00:02:11,360
a hardware hacker if i find a firmware

58
00:02:11,360 --> 00:02:13,760
dump i have to look into it and so i hex

59
00:02:13,760 --> 00:02:16,560
dumped it and immediately recognized

60
00:02:16,560 --> 00:02:19,440
these patterns so this is the basic

61
00:02:19,440 --> 00:02:21,599
pattern of an rt kit firmware which and

62
00:02:21,599 --> 00:02:23,599
rt kit is the embedded real-time

63
00:02:23,599 --> 00:02:26,160
operating system that apple uses on

64
00:02:26,160 --> 00:02:29,680
all their tiny devices basically

65
00:02:29,680 --> 00:02:31,440
and this turned out later on to be the

66
00:02:31,440 --> 00:02:33,440
firmware of the u1 so the firmware of

67
00:02:33,440 --> 00:02:35,200
the ultra whiteband chip which so far

68
00:02:35,200 --> 00:02:37,040
was only in like the iphone and other

69
00:02:37,040 --> 00:02:39,200
expensive devices but now we have it in

70
00:02:39,200 --> 00:02:41,200
a very cheap device which is interesting

71
00:02:41,200 --> 00:02:42,640
to us

72
00:02:42,640 --> 00:02:44,160
given that

73
00:02:44,160 --> 00:02:45,840
ultra whiteband is still a pretty new

74
00:02:45,840 --> 00:02:46,959
technology

75
00:02:46,959 --> 00:02:48,879
furthermore we also see if we just run

76
00:02:48,879 --> 00:02:50,319
strings on this that there are

77
00:02:50,319 --> 00:02:53,440
references to the nif 52 sdk and so in

78
00:02:53,440 --> 00:02:55,120
the attack they apparently use the

79
00:02:55,120 --> 00:02:57,360
standard nf sdk

80
00:02:57,360 --> 00:03:00,000
your ipad just died

81
00:03:00,000 --> 00:03:02,319
and yeah so if you open up an airtag

82
00:03:02,319 --> 00:03:04,640
which by the way is not as simple as it

83
00:03:04,640 --> 00:03:06,319
should be so you have to be really

84
00:03:06,319 --> 00:03:08,000
careful it breaks very easily it has a

85
00:03:08,000 --> 00:03:09,920
very thin pcb

86
00:03:09,920 --> 00:03:12,239
if you go into an airtech you will see

87
00:03:12,239 --> 00:03:14,560
this which basically

88
00:03:14,560 --> 00:03:16,239
is just the back side and there's not

89
00:03:16,239 --> 00:03:18,720
much intra not much of interest here but

90
00:03:18,720 --> 00:03:20,879
what you might notice is that apple was

91
00:03:20,879 --> 00:03:22,800
nice enough to give us a ton of test

92
00:03:22,800 --> 00:03:25,120
pins and so if you open it up there's a

93
00:03:25,120 --> 00:03:27,680
ton of stuff to probe and that's really

94
00:03:27,680 --> 00:03:29,680
nice

95
00:03:29,680 --> 00:03:31,599
interestingly enough colin was the first

96
00:03:31,599 --> 00:03:33,680
one who really looked into this and he

97
00:03:33,680 --> 00:03:36,400
created what's basically the default air

98
00:03:36,400 --> 00:03:38,640
tech pin out and so now if you see any

99
00:03:38,640 --> 00:03:40,799
publication on the attacks we use this

100
00:03:40,799 --> 00:03:43,200
numbering scheme and so if you ever see

101
00:03:43,200 --> 00:03:46,080
hey spyflash is connected on pin 29 or

102
00:03:46,080 --> 00:03:48,480
so this is what they refer to so it's

103
00:03:48,480 --> 00:03:50,480
basically the standard attack numbering

104
00:03:50,480 --> 00:03:52,720
system

105
00:03:52,720 --> 00:03:54,560
otherwise on the back side there's not

106
00:03:54,560 --> 00:03:56,000
really anything interesting there are

107
00:03:56,000 --> 00:03:58,400
only passives except that on the bottom

108
00:03:58,400 --> 00:04:02,159
right we have a small accelerometer

109
00:04:02,159 --> 00:04:04,159
and that's basically it otherwise it's

110
00:04:04,159 --> 00:04:06,799
pretty boring let's say

111
00:04:06,799 --> 00:04:09,680
now um if we managed to remove the pcb

112
00:04:09,680 --> 00:04:11,599
which by the way is really difficult

113
00:04:11,599 --> 00:04:13,280
because it's glued in it's super thin

114
00:04:13,280 --> 00:04:14,879
you will break it

115
00:04:14,879 --> 00:04:16,478
it's best to just not do it because

116
00:04:16,478 --> 00:04:18,320
there's nothing interesting

117
00:04:18,320 --> 00:04:19,918
from the hacker side on there but it's

118
00:04:19,918 --> 00:04:21,839
interesting from the hardware side and

119
00:04:21,839 --> 00:04:24,400
so what we see here is first of this big

120
00:04:24,400 --> 00:04:26,479
silver chip this is the u1 chip the

121
00:04:26,479 --> 00:04:28,960
ultra white band chip

122
00:04:28,960 --> 00:04:30,880
of the attack and what's really cool is

123
00:04:30,880 --> 00:04:32,880
that they actually populated an antenna

124
00:04:32,880 --> 00:04:35,199
connector and so you can directly

125
00:04:35,199 --> 00:04:37,440
feed into the attack from your sdr and

126
00:04:37,440 --> 00:04:38,639
so it's really

127
00:04:38,639 --> 00:04:40,000
really really nice if you want to do a

128
00:04:40,000 --> 00:04:42,960
couple of experiments

129
00:04:42,960 --> 00:04:45,600
otherwise we have a small spy flash

130
00:04:45,600 --> 00:04:48,000
which as you will see is not really

131
00:04:48,000 --> 00:04:50,400
interesting and then we have the nif

132
00:04:50,400 --> 00:04:52,240
52832

133
00:04:52,240 --> 00:04:54,560
this chip is basically found on any key

134
00:04:54,560 --> 00:04:56,479
finder on the planet like if you open up

135
00:04:56,479 --> 00:04:57,840
a samsung key finder it probably

136
00:04:57,840 --> 00:05:00,479
contains more or less the same chip

137
00:05:00,479 --> 00:05:02,639
now the nf52

138
00:05:02,639 --> 00:05:04,240
on the attack handles the bluetooth

139
00:05:04,240 --> 00:05:05,600
communication

140
00:05:05,600 --> 00:05:08,080
the iphone communication

141
00:05:08,080 --> 00:05:11,039
it handles nfc and so if you touch the

142
00:05:11,039 --> 00:05:12,880
attack with an nfc capable phone it

143
00:05:12,880 --> 00:05:14,479
would bring up a ul

144
00:05:14,479 --> 00:05:16,880
and it's also known to be vulnerable and

145
00:05:16,880 --> 00:05:18,639
so

146
00:05:18,639 --> 00:05:20,960
basically um

147
00:05:20,960 --> 00:05:23,440
on the back side of the attack we have

148
00:05:23,440 --> 00:05:26,000
the programming interface exposed

149
00:05:26,000 --> 00:05:27,759
and if we connect a programmer to it

150
00:05:27,759 --> 00:05:29,840
unfortunately it's

151
00:05:29,840 --> 00:05:31,360
it's locked

152
00:05:31,360 --> 00:05:33,199
and so this locking mechanism on the

153
00:05:33,199 --> 00:05:35,840
nf52 is called app protect basically it

154
00:05:35,840 --> 00:05:37,680
allows you to when you ship a device you

155
00:05:37,680 --> 00:05:39,759
lock down the debugging interfaces and

156
00:05:39,759 --> 00:05:42,080
this will ensure that you that nobody

157
00:05:42,080 --> 00:05:45,120
can dump your firmware in theory

158
00:05:45,120 --> 00:05:46,960
you can still erase the firmware you can

159
00:05:46,960 --> 00:05:48,800
still flash a new one but you can't dump

160
00:05:48,800 --> 00:05:50,400
the current one

161
00:05:50,400 --> 00:05:53,360
luckily for us there's a way to bypass

162
00:05:53,360 --> 00:05:55,199
this app protect and so last year

163
00:05:55,199 --> 00:05:58,400
limited results published an nf52 debug

164
00:05:58,400 --> 00:06:00,800
resurrection and so he basically managed

165
00:06:00,800 --> 00:06:02,560
to use fault injection

166
00:06:02,560 --> 00:06:05,120
to re-enable the the debug port which

167
00:06:05,120 --> 00:06:07,440
then allows us to dump the firmware and

168
00:06:07,440 --> 00:06:09,680
so the plan for me having just acquired

169
00:06:09,680 --> 00:06:11,440
a couple of air tags and already broken

170
00:06:11,440 --> 00:06:13,039
too but that doesn't matter

171
00:06:13,039 --> 00:06:14,800
was to basically

172
00:06:14,800 --> 00:06:16,560
find the test pins for the swd

173
00:06:16,560 --> 00:06:18,240
programmer find

174
00:06:18,240 --> 00:06:20,319
whatever power supplies we need glitch

175
00:06:20,319 --> 00:06:23,520
it and then hopefully dump the firmware

176
00:06:23,520 --> 00:06:25,840
now glitching is for a lot of people

177
00:06:25,840 --> 00:06:27,919
very magic but it's really very easy all

178
00:06:27,919 --> 00:06:29,680
we are doing is basically we interrupt

179
00:06:29,680 --> 00:06:31,680
the voltage towards the chip for a

180
00:06:31,680 --> 00:06:34,319
couple of nanoseconds maybe microseconds

181
00:06:34,319 --> 00:06:35,759
and this will cause different

182
00:06:35,759 --> 00:06:38,080
corruptions in the chip and so if you

183
00:06:38,080 --> 00:06:40,000
time it very precisely you might be able

184
00:06:40,000 --> 00:06:41,680
to skip instructions you might be able

185
00:06:41,680 --> 00:06:44,080
to corrupt register contents and so on

186
00:06:44,080 --> 00:06:46,319
and so forth and if you think about the

187
00:06:46,319 --> 00:06:49,199
boot process of this this processor at

188
00:06:49,199 --> 00:06:51,280
one point the chip will check whether

189
00:06:51,280 --> 00:06:53,199
the debugging hardware has been disabled

190
00:06:53,199 --> 00:06:55,280
or not and if it's been disabled it will

191
00:06:55,280 --> 00:06:57,599
skip the step of enabling the debug

192
00:06:57,599 --> 00:07:00,080
hardware however if we manage to find

193
00:07:00,080 --> 00:07:01,360
the time

194
00:07:01,360 --> 00:07:03,599
of this check and we glitch

195
00:07:03,599 --> 00:07:06,000
interrupt the power supply at just the

196
00:07:06,000 --> 00:07:08,319
right time we might be able to trick the

197
00:07:08,319 --> 00:07:10,800
chip into skipping the check and jumping

198
00:07:10,800 --> 00:07:12,160
into the

199
00:07:12,160 --> 00:07:14,840
enable debug hardware

200
00:07:14,840 --> 00:07:17,680
procedure now this is

201
00:07:17,680 --> 00:07:20,080
not as easy always as it sounds because

202
00:07:20,080 --> 00:07:21,759
a big issue is that basically a

203
00:07:21,759 --> 00:07:24,160
processor on the outside mostly

204
00:07:24,160 --> 00:07:26,319
for microcontrollers has a single power

205
00:07:26,319 --> 00:07:29,039
supply so for example the ni 52 runs on

206
00:07:29,039 --> 00:07:30,639
1.8 volts

207
00:07:30,639 --> 00:07:33,039
however inside of the chip we generate

208
00:07:33,039 --> 00:07:34,479
different voltages for different

209
00:07:34,479 --> 00:07:36,560
peripherals and so for example the cpu

210
00:07:36,560 --> 00:07:39,199
core will run at a much lower voltage

211
00:07:39,199 --> 00:07:41,199
than your bluetooth core and so on and

212
00:07:41,199 --> 00:07:44,160
so forth and the issue is we really want

213
00:07:44,160 --> 00:07:46,080
to target the cpu core we don't really

214
00:07:46,080 --> 00:07:48,319
want to glitch anything else and so how

215
00:07:48,319 --> 00:07:50,960
do we get access to that voltage rail

216
00:07:50,960 --> 00:07:53,440
without decaping the chip

217
00:07:53,440 --> 00:07:55,120
well it turns out that regulators are

218
00:07:55,120 --> 00:07:58,639
very noisy and to make them less noisy

219
00:07:58,639 --> 00:08:00,319
chip designers

220
00:08:00,319 --> 00:08:02,800
give you a pin to add an external bypass

221
00:08:02,800 --> 00:08:05,199
capacitor to basically smooth out the

222
00:08:05,199 --> 00:08:06,319
ripples

223
00:08:06,319 --> 00:08:08,400
and this gives us direct access to the

224
00:08:08,400 --> 00:08:11,360
internal cpu rail of the cpu core

225
00:08:11,360 --> 00:08:13,360
and so if we attach a switch to ground

226
00:08:13,360 --> 00:08:15,759
to this and we close the switch we will

227
00:08:15,759 --> 00:08:17,360
interrupt the power

228
00:08:17,360 --> 00:08:20,720
to the the cpu core and if we open it it

229
00:08:20,720 --> 00:08:23,039
will be restored now obviously it's very

230
00:08:23,039 --> 00:08:25,919
difficult to you know press a button for

231
00:08:25,919 --> 00:08:28,000
100 nanoseconds at exactly the right

232
00:08:28,000 --> 00:08:30,319
time so instead of a switch we just use

233
00:08:30,319 --> 00:08:32,080
a regular mosfet

234
00:08:32,080 --> 00:08:34,479
and instead of you know our fingers we

235
00:08:34,479 --> 00:08:36,320
simply use

236
00:08:36,320 --> 00:08:38,159
a device that does very precise timings

237
00:08:38,159 --> 00:08:39,919
now normally you would use like a chip

238
00:08:39,919 --> 00:08:42,719
whisperer or an fpga or so but i always

239
00:08:42,719 --> 00:08:44,480
like to hack things the cheapest way

240
00:08:44,480 --> 00:08:46,720
possible and so with the raspberry pi

241
00:08:46,720 --> 00:08:48,880
pico you can glitch the attack with like

242
00:08:48,880 --> 00:08:50,640
four dollars of equipment and i think

243
00:08:50,640 --> 00:08:52,720
that's pretty neat

244
00:08:52,720 --> 00:08:55,120
and so basically if we toggle this i o

245
00:08:55,120 --> 00:08:57,760
high we will enable the mosfet cut the

246
00:08:57,760 --> 00:09:00,080
power to the cpu and if we toggle it low

247
00:09:00,080 --> 00:09:01,920
it will go back again

248
00:09:01,920 --> 00:09:04,240
sounds simple enough but how do we do

249
00:09:04,240 --> 00:09:06,720
this on the attack so first off we are

250
00:09:06,720 --> 00:09:09,600
very lucky that the bypass capacitor is

251
00:09:09,600 --> 00:09:11,839
on the easily accessible back side of

252
00:09:11,839 --> 00:09:13,440
the attack

253
00:09:13,440 --> 00:09:15,120
and even nicer

254
00:09:15,120 --> 00:09:17,839
apple gave us a glitching test pin and

255
00:09:17,839 --> 00:09:19,680
so all we have to do is solder a wire

256
00:09:19,680 --> 00:09:21,279
onto this and we get direct access to

257
00:09:21,279 --> 00:09:24,320
the cpu core voltage yay

258
00:09:24,320 --> 00:09:25,920
and so we hook this up using a very

259
00:09:25,920 --> 00:09:28,399
cheap mosfet like literally 20 cents of

260
00:09:28,399 --> 00:09:30,080
equipment um

261
00:09:30,080 --> 00:09:33,120
and then we basically we want to measure

262
00:09:33,120 --> 00:09:35,360
when we turn on the rtc when does it

263
00:09:35,360 --> 00:09:37,680
start booting because we want a glitch

264
00:09:37,680 --> 00:09:40,000
at the time offset to the time of boot

265
00:09:40,000 --> 00:09:41,839
and so to measure that we basically

266
00:09:41,839 --> 00:09:42,800
measure

267
00:09:42,800 --> 00:09:45,360
the regulated power supply of the nf52

268
00:09:45,360 --> 00:09:47,279
so as soon as that goes high that's our

269
00:09:47,279 --> 00:09:49,839
trigger signal we wait a couple of

270
00:09:49,839 --> 00:09:52,399
microseconds glitch and then hopefully

271
00:09:52,399 --> 00:09:54,720
uh re-enable debugging

272
00:09:54,720 --> 00:09:57,279
to power cycle the attack we simply this

273
00:09:57,279 --> 00:09:59,200
is probably not spec compliant but we

274
00:09:59,200 --> 00:10:01,040
simply can power it from a random i o

275
00:10:01,040 --> 00:10:03,519
like this works totally fine

276
00:10:03,519 --> 00:10:05,680
and then we just hook up an swd

277
00:10:05,680 --> 00:10:07,760
programmer and so that's basically all

278
00:10:07,760 --> 00:10:09,920
our setup and the way this works is if

279
00:10:09,920 --> 00:10:12,240
we start from scratch

280
00:10:12,240 --> 00:10:14,399
we turn on the attack by giving it power

281
00:10:14,399 --> 00:10:16,880
then we wait for the nf-52 power supply

282
00:10:16,880 --> 00:10:19,600
to come up then we wait whatever our

283
00:10:19,600 --> 00:10:21,040
delay is

284
00:10:21,040 --> 00:10:23,600
we enable the mosfet for a couple of

285
00:10:23,600 --> 00:10:24,959
microseconds

286
00:10:24,959 --> 00:10:26,320
and that will interrupt the power and

287
00:10:26,320 --> 00:10:28,240
then we restore it and then we check

288
00:10:28,240 --> 00:10:30,480
with our swd programmer whether we can

289
00:10:30,480 --> 00:10:32,480
access the chip or not that's literally

290
00:10:32,480 --> 00:10:33,200
it

291
00:10:33,200 --> 00:10:34,000
and

292
00:10:34,000 --> 00:10:35,839
in real life it looks somewhat like this

293
00:10:35,839 --> 00:10:38,480
so we have our air tag um this is really

294
00:10:38,480 --> 00:10:39,839
messy but i

295
00:10:39,839 --> 00:10:41,279
this is the the first one that i

296
00:10:41,279 --> 00:10:42,480
actually glitched and i thought it would

297
00:10:42,480 --> 00:10:44,240
be more honest to you know show the real

298
00:10:44,240 --> 00:10:44,959
thing

299
00:10:44,959 --> 00:10:46,560
then we have a j-link debugger that i

300
00:10:46,560 --> 00:10:49,040
use as the programmer and then a small

301
00:10:49,040 --> 00:10:51,519
break-up board that i built for the pico

302
00:10:51,519 --> 00:10:53,600
that basically has the mosfet and so on

303
00:10:53,600 --> 00:10:55,440
on board

304
00:10:55,440 --> 00:10:57,440
and once this is running we can see on

305
00:10:57,440 --> 00:10:59,200
oscilloscope we have a lot of differing

306
00:10:59,200 --> 00:11:01,120
our timing is not very good but we only

307
00:11:01,120 --> 00:11:02,720
have to get lucky once so we just let

308
00:11:02,720 --> 00:11:04,720
this run for like 20 minutes and

309
00:11:04,720 --> 00:11:07,760
eventually hopefully we get lucky and we

310
00:11:07,760 --> 00:11:09,440
control this via small python script

311
00:11:09,440 --> 00:11:11,360
this is all open source you can find it

312
00:11:11,360 --> 00:11:13,600
at the links at the end and eventually

313
00:11:13,600 --> 00:11:16,720
it will say success and then we have the

314
00:11:16,720 --> 00:11:18,480
firmware we have the flash contents we

315
00:11:18,480 --> 00:11:20,560
have all the internal cpu registers and

316
00:11:20,560 --> 00:11:22,560
so on and so forth and we can start

317
00:11:22,560 --> 00:11:24,959
analyzing it now what i always like to

318
00:11:24,959 --> 00:11:26,640
do is to just run strings on any

319
00:11:26,640 --> 00:11:28,320
firmware that i get like just to see

320
00:11:28,320 --> 00:11:30,160
what's inside what can i immediately

321
00:11:30,160 --> 00:11:32,079
tell in this case there are a lot of

322
00:11:32,079 --> 00:11:33,920
interesting things there's for example a

323
00:11:33,920 --> 00:11:36,000
core crypto reference which is the apple

324
00:11:36,000 --> 00:11:37,680
cryptography framework

325
00:11:37,680 --> 00:11:38,800
there's

326
00:11:38,800 --> 00:11:40,800
an interesting link and this link looks

327
00:11:40,800 --> 00:11:42,560
very similar to the one that when you

328
00:11:42,560 --> 00:11:46,000
touch the um the attack with nfc

329
00:11:46,000 --> 00:11:47,519
this is the link that you will get back

330
00:11:47,519 --> 00:11:50,320
so that's apparently in the nf firmware

331
00:11:50,320 --> 00:11:52,240
and so that means we can fiddle with it

332
00:11:52,240 --> 00:11:53,279
and

333
00:11:53,279 --> 00:11:55,200
having something very easy that we can

334
00:11:55,200 --> 00:11:57,200
fiddle with and test whether we modified

335
00:11:57,200 --> 00:11:58,399
something is really cool because it

336
00:11:58,399 --> 00:12:00,160
allows us to check whether we can modify

337
00:12:00,160 --> 00:12:02,320
the firmware and so i basically changed

338
00:12:02,320 --> 00:12:04,000
the url

339
00:12:04,000 --> 00:12:07,680
flashed the rtc and now if you

340
00:12:07,680 --> 00:12:10,160
scan the rtc

341
00:12:10,160 --> 00:12:13,439
what else are you gonna do right

342
00:12:13,519 --> 00:12:15,600
um other cool things in the firmware the

343
00:12:15,600 --> 00:12:17,360
serial number is in the firmware and you

344
00:12:17,360 --> 00:12:18,959
can actually adjust this it's not

345
00:12:18,959 --> 00:12:21,279
checked and so you can literally pair

346
00:12:21,279 --> 00:12:23,839
any serial with icloud and so my serial

347
00:12:23,839 --> 00:12:26,000
number is text meshing

348
00:12:26,000 --> 00:12:26,800
and

349
00:12:26,800 --> 00:12:28,240
there's a couple of other interesting

350
00:12:28,240 --> 00:12:30,000
things in there such as your sensory

351
00:12:30,000 --> 00:12:32,240
email address and so on now um what was

352
00:12:32,240 --> 00:12:34,000
curious to us is can we clone an air

353
00:12:34,000 --> 00:12:35,920
tech is there anything that prevents us

354
00:12:35,920 --> 00:12:38,160
from you know is the u1 may be used as a

355
00:12:38,160 --> 00:12:39,920
secret element or is it really just the

356
00:12:39,920 --> 00:12:43,120
nf-52 and so what we did is uh i dumped

357
00:12:43,120 --> 00:12:45,680
my attack sent my firmware over to

358
00:12:45,680 --> 00:12:48,079
leonard leonard flashed his air tech and

359
00:12:48,079 --> 00:12:49,760
we checked what would happen if we have

360
00:12:49,760 --> 00:12:52,880
two clones at the same time online

361
00:12:52,880 --> 00:12:54,800
and so my

362
00:12:54,800 --> 00:12:57,680
air tag was nicely located at my home

363
00:12:57,680 --> 00:13:00,399
and then leonard enabled his flash test

364
00:13:00,399 --> 00:13:02,240
and suddenly my attack was somewhere in

365
00:13:02,240 --> 00:13:04,079
belgium a couple of hundred kilometers

366
00:13:04,079 --> 00:13:06,560
away and so we can trivially

367
00:13:06,560 --> 00:13:08,320
clone the attack

368
00:13:08,320 --> 00:13:10,079
and even what's interesting is that if

369
00:13:10,079 --> 00:13:12,000
you let's say you you find a stone air

370
00:13:12,000 --> 00:13:13,600
tag you can

371
00:13:13,600 --> 00:13:16,240
refresh it and reuse it as your own like

372
00:13:16,240 --> 00:13:17,519
there's nothing that prevents you from

373
00:13:17,519 --> 00:13:19,040
doing this

374
00:13:19,040 --> 00:13:21,279
also on the hardware side david halton

375
00:13:21,279 --> 00:13:23,600
has this awesome very precise polishing

376
00:13:23,600 --> 00:13:25,920
machine and he basically de-layered the

377
00:13:25,920 --> 00:13:27,360
entire pcb

378
00:13:27,360 --> 00:13:30,000
and then i went ahead and combined all

379
00:13:30,000 --> 00:13:31,680
those pictures in and so we now

380
00:13:31,680 --> 00:13:34,160
have like full high very high resolution

381
00:13:34,160 --> 00:13:36,560
pictures of the entire pcb and so we can

382
00:13:36,560 --> 00:13:38,320
just trace any connection and this is

383
00:13:38,320 --> 00:13:40,160
all online so if you want to you know

384
00:13:40,160 --> 00:13:42,399
draw a couple of traces feel free to do

385
00:13:42,399 --> 00:13:43,680
so

386
00:13:43,680 --> 00:13:45,519
and yeah that's basically the hardware

387
00:13:45,519 --> 00:13:47,600
side we built and with the hardware side

388
00:13:47,600 --> 00:13:48,639
all done

389
00:13:48,639 --> 00:13:50,800
it was time to team up with some people

390
00:13:50,800 --> 00:13:53,040
who do software

391
00:13:53,040 --> 00:13:56,719
and yeah let's talk about firmware

392
00:13:58,880 --> 00:14:00,959
so

393
00:14:00,959 --> 00:14:02,959
so what are we actually

394
00:14:02,959 --> 00:14:05,360
actually looking for in the firmware so

395
00:14:05,360 --> 00:14:07,440
first of all there is a lot of stuff

396
00:14:07,440 --> 00:14:09,839
that's bluetooth specification compliant

397
00:14:09,839 --> 00:14:12,160
so handlers for pairing

398
00:14:12,160 --> 00:14:14,480
and just handling packet data there's

399
00:14:14,480 --> 00:14:16,639
nothing airspec air tech specific in

400
00:14:16,639 --> 00:14:19,040
there but the cool part here is that we

401
00:14:19,040 --> 00:14:20,720
can look it up in the specifications so

402
00:14:20,720 --> 00:14:22,240
it's easier to find

403
00:14:22,240 --> 00:14:23,600
and then there is the part that we are

404
00:14:23,600 --> 00:14:25,600
really interested in which is everything

405
00:14:25,600 --> 00:14:28,000
that apple built for the air tech so for

406
00:14:28,000 --> 00:14:30,240
example playing sounds updating the

407
00:14:30,240 --> 00:14:33,120
firmware and so on

408
00:14:33,120 --> 00:14:34,880
to understand the following slides you

409
00:14:34,880 --> 00:14:37,440
need to know that a bluetooth packet has

410
00:14:37,440 --> 00:14:39,120
first of all some physical layer stuff

411
00:14:39,120 --> 00:14:42,240
so acl or leu is just a physical

412
00:14:42,240 --> 00:14:44,160
transport layer so to say so the lowest

413
00:14:44,160 --> 00:14:48,480
layer then we have l2 cup and l2 cup is

414
00:14:48,480 --> 00:14:50,959
for fragmentation and raw data transfer

415
00:14:50,959 --> 00:14:53,360
so apple is using this and optionally

416
00:14:53,360 --> 00:14:55,600
you can have gut on top apple is also

417
00:14:55,600 --> 00:14:58,000
using this one so we are dealing with l2

418
00:14:58,000 --> 00:15:01,279
cup and gut in the following

419
00:15:01,600 --> 00:15:03,199
so let's talk about what this looks like

420
00:15:03,199 --> 00:15:05,519
in firmware um

421
00:15:05,519 --> 00:15:08,560
in the nrf 52 we have something called

422
00:15:08,560 --> 00:15:10,320
the soft device it's basically something

423
00:15:10,320 --> 00:15:12,560
like a small kernel

424
00:15:12,560 --> 00:15:13,519
the

425
00:15:13,519 --> 00:15:15,199
the software that's implemented on top

426
00:15:15,199 --> 00:15:17,600
of that talks to the soft device

427
00:15:17,600 --> 00:15:19,600
using supervisor calls and gets

428
00:15:19,600 --> 00:15:22,560
notifications through iqs and events

429
00:15:22,560 --> 00:15:24,720
and that's how you implement

430
00:15:24,720 --> 00:15:26,790
custom bluetooth firmware on top of it

431
00:15:26,790 --> 00:15:29,040
[Music]

432
00:15:29,040 --> 00:15:31,040
this is the memory map or somewhat like

433
00:15:31,040 --> 00:15:33,600
the memory map for the nr52 the soft

434
00:15:33,600 --> 00:15:35,680
device is a big binary blob that is

435
00:15:35,680 --> 00:15:38,959
located right at the beginning of memory

436
00:15:38,959 --> 00:15:40,720
this is the big binary blob that's

437
00:15:40,720 --> 00:15:42,800
shipped by nordic

438
00:15:42,800 --> 00:15:45,040
you flash it there and then you put your

439
00:15:45,040 --> 00:15:48,480
custom code underneath it

440
00:15:48,880 --> 00:15:51,120
then further up in the memory map we

441
00:15:51,120 --> 00:15:54,399
have ram and then similar to other arm

442
00:15:54,399 --> 00:15:58,560
chips there's some mml peripherals

443
00:15:58,560 --> 00:15:59,839
so when

444
00:15:59,839 --> 00:16:01,600
we're starting at reversing something

445
00:16:01,600 --> 00:16:03,839
like this it's really useful to

446
00:16:03,839 --> 00:16:06,240
understand what well-defined interfaces

447
00:16:06,240 --> 00:16:08,000
they are because these are things that

448
00:16:08,000 --> 00:16:09,440
you can cross-reference that you can

449
00:16:09,440 --> 00:16:11,440
understand and that you can start out

450
00:16:11,440 --> 00:16:13,920
with in this case it's the interface

451
00:16:13,920 --> 00:16:16,480
between the soft device

452
00:16:16,480 --> 00:16:18,320
and the custom app firmware and the

453
00:16:18,320 --> 00:16:21,120
interface between the mmio and the

454
00:16:21,120 --> 00:16:24,240
also the custom code

455
00:16:24,720 --> 00:16:26,720
so let's start looking at the supervisor

456
00:16:26,720 --> 00:16:27,839
calls

457
00:16:27,839 --> 00:16:29,360
we can find a list of all of the

458
00:16:29,360 --> 00:16:32,959
supervisor calls in the firmware

459
00:16:32,959 --> 00:16:34,560
here i've already given a few of those

460
00:16:34,560 --> 00:16:36,639
names when you're starting out they will

461
00:16:36,639 --> 00:16:38,639
not have games yet so this is what we're

462
00:16:38,639 --> 00:16:41,040
trying to do

463
00:16:41,040 --> 00:16:42,639
let's for example take

464
00:16:42,639 --> 00:16:44,959
this one here which is supervisor called

465
00:16:44,959 --> 00:16:46,560
a8

466
00:16:46,560 --> 00:16:49,360
turns out if you check in the sdk which

467
00:16:49,360 --> 00:16:51,360
is a

468
00:16:51,360 --> 00:16:53,920
library of header files and custom code

469
00:16:53,920 --> 00:16:55,920
provided by nordic to talk to this soft

470
00:16:55,920 --> 00:16:57,279
device

471
00:16:57,279 --> 00:16:59,519
we can find some contents that say which

472
00:16:59,519 --> 00:17:01,759
what is what basically

473
00:17:01,759 --> 00:17:04,480
we can see that a8 here is the get

474
00:17:04,480 --> 00:17:06,799
service ad supervisor call

475
00:17:06,799 --> 00:17:09,439
and then farther down we also find

476
00:17:09,439 --> 00:17:11,919
some documentation what it does

477
00:17:11,919 --> 00:17:13,919
and type information that we can use to

478
00:17:13,919 --> 00:17:15,119
understand

479
00:17:15,119 --> 00:17:16,959
how data is shipped across the boundary

480
00:17:16,959 --> 00:17:19,919
between the app and the soft device

481
00:17:19,919 --> 00:17:22,079
we can propagate that into the

482
00:17:22,079 --> 00:17:24,400
into our disassembler here and add some

483
00:17:24,400 --> 00:17:25,679
type information that will help us

484
00:17:25,679 --> 00:17:28,960
reverse engineer it and go from there

485
00:17:28,960 --> 00:17:30,880
so there's not just the supervisor calls

486
00:17:30,880 --> 00:17:33,600
but there's also events that happen

487
00:17:33,600 --> 00:17:35,360
that's a bit more complicated we have to

488
00:17:35,360 --> 00:17:37,280
find a function called nrf section

489
00:17:37,280 --> 00:17:39,280
iterator in it

490
00:17:39,280 --> 00:17:41,600
this is also part of the soft device or

491
00:17:41,600 --> 00:17:44,400
of the sdk not of the soft device sorry

492
00:17:44,400 --> 00:17:46,480
then we find calls to that

493
00:17:46,480 --> 00:17:48,480
and that gets passed a pointer to a big

494
00:17:48,480 --> 00:17:49,360
list

495
00:17:49,360 --> 00:17:52,240
of handlers and these handlers are will

496
00:17:52,240 --> 00:17:54,720
get invoked when there's an event passed

497
00:17:54,720 --> 00:17:56,240
by the soft device to the bluetooth

498
00:17:56,240 --> 00:17:57,919
application so this is the other entry

499
00:17:57,919 --> 00:17:59,440
point that's really

500
00:17:59,440 --> 00:18:03,919
interesting to start reversing at

501
00:18:05,919 --> 00:18:07,919
so on top of those

502
00:18:07,919 --> 00:18:10,559
basic entry points we can start figuring

503
00:18:10,559 --> 00:18:13,360
out what higher level sdk functions are

504
00:18:13,360 --> 00:18:16,799
that are in the nordic sdk we can

505
00:18:16,799 --> 00:18:18,160
figure out

506
00:18:18,160 --> 00:18:20,559
accesses to the mmio region cross

507
00:18:20,559 --> 00:18:22,799
reference those and figure out other

508
00:18:22,799 --> 00:18:26,640
peripherals such as uart rtwi

509
00:18:26,640 --> 00:18:28,720
and there's also some functions that

510
00:18:28,720 --> 00:18:30,240
don't use the soft device or any

511
00:18:30,240 --> 00:18:31,520
external

512
00:18:31,520 --> 00:18:33,120
surfaces these are the most difficult

513
00:18:33,120 --> 00:18:35,039
ones to identify but

514
00:18:35,039 --> 00:18:36,559
things like function id or other

515
00:18:36,559 --> 00:18:41,080
signature based approaches can help here

516
00:18:43,520 --> 00:18:45,360
so the next part that we are interested

517
00:18:45,360 --> 00:18:47,679
in is everything that's apple specific

518
00:18:47,679 --> 00:18:50,000
what you can find in every ble device or

519
00:18:50,000 --> 00:18:52,720
almost all ble devices is a gut service

520
00:18:52,720 --> 00:18:55,200
or get services with characteristic that

521
00:18:55,200 --> 00:18:58,080
you can write to or read from and some

522
00:18:58,080 --> 00:18:59,760
of them can be protected so only

523
00:18:59,760 --> 00:19:01,440
available after pairing and the

524
00:19:01,440 --> 00:19:02,480
important part about those

525
00:19:02,480 --> 00:19:04,080
characteristics is there are some that

526
00:19:04,080 --> 00:19:05,360
are not that interesting just like

527
00:19:05,360 --> 00:19:07,840
reading a name of the device but there

528
00:19:07,840 --> 00:19:09,440
are also some that apple defined for

529
00:19:09,440 --> 00:19:12,080
example for the firmware update or that

530
00:19:12,080 --> 00:19:14,559
i used during a special pairing process

531
00:19:14,559 --> 00:19:16,880
and you can just use this tool that i

532
00:19:16,880 --> 00:19:19,520
show here the nrf connect to scroll

533
00:19:19,520 --> 00:19:21,600
through them and see what they do at

534
00:19:21,600 --> 00:19:24,240
least like what values they return and

535
00:19:24,240 --> 00:19:28,080
we will now analyze them in detail

536
00:19:28,080 --> 00:19:30,240
so here's one example if you have the

537
00:19:30,240 --> 00:19:32,400
initial pairing you have a normal ble

538
00:19:32,400 --> 00:19:34,720
pairing but then on top you have a gut

539
00:19:34,720 --> 00:19:37,360
read and i got right so the read is to

540
00:19:37,360 --> 00:19:39,600
get information from the attack like the

541
00:19:39,600 --> 00:19:41,840
serial number and so on and then there

542
00:19:41,840 --> 00:19:43,919
is a pairing that involves the icloud

543
00:19:43,919 --> 00:19:45,039
and that

544
00:19:45,039 --> 00:19:46,640
creates a certificate that is then

545
00:19:46,640 --> 00:19:49,200
written to the air tech and this is all

546
00:19:49,200 --> 00:19:52,600
done by gut

547
00:19:54,160 --> 00:19:55,840
so let's look at what this looks like on

548
00:19:55,840 --> 00:19:57,679
the firmware side again

549
00:19:57,679 --> 00:19:59,919
here you can see part of a very big

550
00:19:59,919 --> 00:20:01,600
function

551
00:20:01,600 --> 00:20:04,639
in fact i can show you

552
00:20:04,960 --> 00:20:08,640
i can show it to you very very quickly

553
00:20:12,240 --> 00:20:15,039
here so zooming out you can see there's

554
00:20:15,039 --> 00:20:16,880
a long list of basic blocks each of

555
00:20:16,880 --> 00:20:18,640
these basic blocks here

556
00:20:18,640 --> 00:20:22,159
sets up one specific gut service

557
00:20:22,159 --> 00:20:24,159
here in the beginning for example we

558
00:20:24,159 --> 00:20:27,200
have get service 8004

559
00:20:27,200 --> 00:20:28,159
which

560
00:20:28,159 --> 00:20:31,440
is set here they all have ids

561
00:20:31,440 --> 00:20:33,600
and then there's a global variable that

562
00:20:33,600 --> 00:20:35,440
says this is basically what's read by

563
00:20:35,440 --> 00:20:37,360
the soft device when when it's shipping

564
00:20:37,360 --> 00:20:38,559
out the data

565
00:20:38,559 --> 00:20:40,240
and there's also

566
00:20:40,240 --> 00:20:44,640
some some other handlers that can be set

567
00:20:45,760 --> 00:20:48,159
these handlers are invoked on in the

568
00:20:48,159 --> 00:20:49,919
notify it's further down in the call

569
00:20:49,919 --> 00:20:51,280
stack from

570
00:20:51,280 --> 00:20:52,080
the

571
00:20:52,080 --> 00:20:54,080
list of observers earlier that i showed

572
00:20:54,080 --> 00:20:54,880
you

573
00:20:54,880 --> 00:20:57,360
and these handlers will get dispatched

574
00:20:57,360 --> 00:20:59,039
depending on which characteristic is

575
00:20:59,039 --> 00:21:01,200
written to so we can

576
00:21:01,200 --> 00:21:02,799
by finding these and reverse engineering

577
00:21:02,799 --> 00:21:04,159
these we can figure out what what's

578
00:21:04,159 --> 00:21:06,159
happening when we write to a specific

579
00:21:06,159 --> 00:21:09,039
gut characteristic

580
00:21:12,480 --> 00:21:14,240
now you need to know this is apple so

581
00:21:14,240 --> 00:21:16,480
they define everything twice they have

582
00:21:16,480 --> 00:21:19,360
gut services which are on top of l2 cup

583
00:21:19,360 --> 00:21:22,480
but they also use plain l2 cup and some

584
00:21:22,480 --> 00:21:24,720
stuff is implemented in both of these

585
00:21:24,720 --> 00:21:26,480
and it just depends a bit on the context

586
00:21:26,480 --> 00:21:28,480
which of the two they are using

587
00:21:28,480 --> 00:21:30,799
so for example there are certain airtec

588
00:21:30,799 --> 00:21:33,360
commands you need a secure connection to

589
00:21:33,360 --> 00:21:35,679
the air tech to use them and then you

590
00:21:35,679 --> 00:21:37,840
can issue a command like let's play a

591
00:21:37,840 --> 00:21:40,159
sound these commands are then even

592
00:21:40,159 --> 00:21:42,000
acknowledged and so on but this is all

593
00:21:42,000 --> 00:21:44,400
not specification compliance so this is

594
00:21:44,400 --> 00:21:46,640
proprietary stuff on top you can see it

595
00:21:46,640 --> 00:21:48,320
is like an altooka packet starting with

596
00:21:48,320 --> 00:21:51,280
hex 91 indicating it's an airtec command

597
00:21:51,280 --> 00:21:53,919
then it has a length field an operator

598
00:21:53,919 --> 00:21:56,000
field we don't know what these operators

599
00:21:56,000 --> 00:21:56,880
are

600
00:21:56,880 --> 00:21:58,799
and then it's followed by data and we

601
00:21:58,799 --> 00:22:00,799
just want to find out what it means and

602
00:22:00,799 --> 00:22:04,159
how we can issue them to an air tech

603
00:22:04,159 --> 00:22:05,760
so the typical approach would be you

604
00:22:05,760 --> 00:22:07,679
pair an iphone and an airtag you extract

605
00:22:07,679 --> 00:22:09,919
the keys you sniff all the communication

606
00:22:09,919 --> 00:22:11,679
with apple's packet logger and then

607
00:22:11,679 --> 00:22:13,760
re-implement all of this by hand so i

608
00:22:13,760 --> 00:22:16,720
use my attic i press play sound and then

609
00:22:16,720 --> 00:22:18,640
i check all the

610
00:22:18,640 --> 00:22:20,640
commands that are sent and try to send

611
00:22:20,640 --> 00:22:22,480
the same commands to the air tech and

612
00:22:22,480 --> 00:22:24,480
see if it also plays a sound but it

613
00:22:24,480 --> 00:22:26,400
still needs the pairing with the icloud

614
00:22:26,400 --> 00:22:28,320
so you still have some apple

615
00:22:28,320 --> 00:22:30,240
dependencies and you also don't know the

616
00:22:30,240 --> 00:22:32,320
full command list so if there are like

617
00:22:32,320 --> 00:22:35,120
hidden commands never used during the

618
00:22:35,120 --> 00:22:38,240
normal air tech usage

619
00:22:38,240 --> 00:22:40,320
so instead if you want to get a full

620
00:22:40,320 --> 00:22:41,360
list we need to look into the

621
00:22:41,360 --> 00:22:42,960
implementation

622
00:22:42,960 --> 00:22:44,480
on ios you have the bluetooth daemon

623
00:22:44,480 --> 00:22:46,320
which communicates with a bluetooth chip

624
00:22:46,320 --> 00:22:48,159
and this is where you have to support

625
00:22:48,159 --> 00:22:50,480
for example with the packet logger and

626
00:22:50,480 --> 00:22:52,320
can sniff the packets or even modify the

627
00:22:52,320 --> 00:22:53,840
packets if you hook into this with

628
00:22:53,840 --> 00:22:55,280
freida

629
00:22:55,280 --> 00:22:58,400
then the location daemon is a client at

630
00:22:58,400 --> 00:23:00,400
it registers for the airtax as a

631
00:23:00,400 --> 00:23:02,240
peripheral so the location daemon has

632
00:23:02,240 --> 00:23:04,400
the actual implementation for the air

633
00:23:04,400 --> 00:23:06,320
tech and the attack protocol

634
00:23:06,320 --> 00:23:07,600
and this is the one that we are now

635
00:23:07,600 --> 00:23:10,640
going to look into

636
00:23:10,640 --> 00:23:12,880
the location daemon at least the part we

637
00:23:12,880 --> 00:23:13,919
are interested in is written in

638
00:23:13,919 --> 00:23:16,480
objective c and objective c

639
00:23:16,480 --> 00:23:18,960
and static reverse engineering is not so

640
00:23:18,960 --> 00:23:21,120
great because often there are objects

641
00:23:21,120 --> 00:23:23,440
defined in different libraries and this

642
00:23:23,440 --> 00:23:25,360
is not fully resolved

643
00:23:25,360 --> 00:23:27,440
if you don't also include them and so on

644
00:23:27,440 --> 00:23:29,760
so it's not so nice for static reverse

645
00:23:29,760 --> 00:23:31,440
engineering but dynamic reverse

646
00:23:31,440 --> 00:23:35,760
engineering works very very very nice

647
00:23:35,760 --> 00:23:36,640
so

648
00:23:36,640 --> 00:23:38,960
let's say if we want to play a sound

649
00:23:38,960 --> 00:23:41,039
then the stuff that's invoked is there's

650
00:23:41,039 --> 00:23:43,520
a durian service so the code name for

651
00:23:43,520 --> 00:23:46,080
the air tag is durian and cl is for

652
00:23:46,080 --> 00:23:48,799
collocation because we are in location d

653
00:23:48,799 --> 00:23:50,720
this is then invoking a task this is

654
00:23:50,720 --> 00:23:52,320
then

655
00:23:52,320 --> 00:23:53,919
issuing a command to the air tech and

656
00:23:53,919 --> 00:23:55,760
the commands also have the first field

657
00:23:55,760 --> 00:23:57,279
which is the op code and we can even

658
00:23:57,279 --> 00:23:59,039
resolve this up code

659
00:23:59,039 --> 00:24:01,279
and we can use freda trace to just look

660
00:24:01,279 --> 00:24:03,440
a bit into this so here you can see i

661
00:24:03,440 --> 00:24:05,200
just play a sound so here we have the

662
00:24:05,200 --> 00:24:07,360
durian service which plays a sound

663
00:24:07,360 --> 00:24:10,480
sequence and then we also see at the

664
00:24:10,480 --> 00:24:12,400
last step this command

665
00:24:12,400 --> 00:24:15,440
that is created

666
00:24:16,799 --> 00:24:18,960
so we now know what we want to hook it's

667
00:24:18,960 --> 00:24:21,679
time for frida and creating our own

668
00:24:21,679 --> 00:24:25,360
hooks and modifying commands

669
00:24:25,679 --> 00:24:27,600
so what you can see here for example is

670
00:24:27,600 --> 00:24:29,600
there is the command

671
00:24:29,600 --> 00:24:32,240
that can also have a description and

672
00:24:32,240 --> 00:24:34,960
with frida for example i can now

673
00:24:34,960 --> 00:24:37,679
print all the command names and just

674
00:24:37,679 --> 00:24:39,840
hook the debug print function iterate

675
00:24:39,840 --> 00:24:42,080
over all up codes and print them this

676
00:24:42,080 --> 00:24:44,240
print is created on an iphone 8 it does

677
00:24:44,240 --> 00:24:47,279
not have the u1 chip but you can still

678
00:24:47,279 --> 00:24:48,880
see here

679
00:24:48,880 --> 00:24:50,559
that we have the

680
00:24:50,559 --> 00:24:53,200
rows commands for the u1 chip present so

681
00:24:53,200 --> 00:24:55,200
we get the full list of stuff that's

682
00:24:55,200 --> 00:24:56,400
supported

683
00:24:56,400 --> 00:24:58,159
on the air tech

684
00:24:58,159 --> 00:25:01,840
and we can also issue them

685
00:25:04,799 --> 00:25:06,320
so in the firmware there's a receive

686
00:25:06,320 --> 00:25:08,000
handler for this stuff

687
00:25:08,000 --> 00:25:10,720
um this is the function that has all the

688
00:25:10,720 --> 00:25:13,440
decision making process depending on

689
00:25:13,440 --> 00:25:15,520
what

690
00:25:15,520 --> 00:25:17,440
what the op code is that is being sent

691
00:25:17,440 --> 00:25:19,919
over l2 cup here for example we can see

692
00:25:19,919 --> 00:25:23,440
opcode ox2a which happens to be 42 and

693
00:25:23,440 --> 00:25:26,080
that is a specific op code that

694
00:25:26,080 --> 00:25:28,720
represents an operation called set wild

695
00:25:28,720 --> 00:25:30,320
mode config that's just something that

696
00:25:30,320 --> 00:25:34,320
the phone does to the air tech sometimes

697
00:25:34,320 --> 00:25:35,760
but it's actually more interesting at

698
00:25:35,760 --> 00:25:36,880
the end

699
00:25:36,880 --> 00:25:38,720
at the end of the function there's two

700
00:25:38,720 --> 00:25:41,279
basic blocks that caught our eyes

701
00:25:41,279 --> 00:25:42,880
there's one that calls a function which

702
00:25:42,880 --> 00:25:45,360
i've named task q and q

703
00:25:45,360 --> 00:25:48,240
and one that says invoke state machine

704
00:25:48,240 --> 00:25:50,320
they sound pretty weird but so let's

705
00:25:50,320 --> 00:25:53,200
figure out what they are

706
00:25:53,840 --> 00:25:55,760
apple implemented something that is

707
00:25:55,760 --> 00:25:58,159
basically a mini operating system and

708
00:25:58,159 --> 00:25:59,840
there's some custom

709
00:25:59,840 --> 00:26:02,320
implementations of primitives that are

710
00:26:02,320 --> 00:26:04,400
quite useful here

711
00:26:04,400 --> 00:26:07,279
for example there's a global task queue

712
00:26:07,279 --> 00:26:09,679
you can put work into the task queue and

713
00:26:09,679 --> 00:26:12,720
it will be done in a main loop

714
00:26:12,720 --> 00:26:14,640
as soon as possible but

715
00:26:14,640 --> 00:26:16,640
but pretty much immediately

716
00:26:16,640 --> 00:26:18,320
when there's nothing to do the air tech

717
00:26:18,320 --> 00:26:20,480
will go to sleep and that's what allows

718
00:26:20,480 --> 00:26:21,440
it to

719
00:26:21,440 --> 00:26:23,520
save a lot of energy and have a long

720
00:26:23,520 --> 00:26:26,240
battery life

721
00:26:27,200 --> 00:26:30,240
so let's look at this

722
00:26:31,520 --> 00:26:33,039
for example here in one of the

723
00:26:33,039 --> 00:26:35,279
characteristic right handlers which

724
00:26:35,279 --> 00:26:37,360
plays a sound when something is written

725
00:26:37,360 --> 00:26:40,080
to it we can see that there is an invoke

726
00:26:40,080 --> 00:26:41,919
state machine command that's being

727
00:26:41,919 --> 00:26:44,080
enqueued into the task queue

728
00:26:44,080 --> 00:26:46,159
further up and this will be

729
00:26:46,159 --> 00:26:48,320
interesting in a moment later we can see

730
00:26:48,320 --> 00:26:50,000
that there is a sound sequence that's

731
00:26:50,000 --> 00:26:51,840
being copied here and the sound sequence

732
00:26:51,840 --> 00:26:56,080
is ox104 and ox205 and they're each

733
00:26:56,080 --> 00:26:59,199
four byte words

734
00:26:59,600 --> 00:27:01,760
then later in the task in the main

735
00:27:01,760 --> 00:27:05,200
function we can see that there's a

736
00:27:05,200 --> 00:27:06,960
task you do work function that's being

737
00:27:06,960 --> 00:27:08,880
called inside the main loop and when

738
00:27:08,880 --> 00:27:10,960
nothing is happening

739
00:27:10,960 --> 00:27:15,120
then the airtech will go to sleep

740
00:27:17,840 --> 00:27:19,760
here this is this on idle function down

741
00:27:19,760 --> 00:27:21,840
here

742
00:27:22,559 --> 00:27:24,880
so this is one form of nonlinear

743
00:27:24,880 --> 00:27:26,880
contract control flow that we'll need to

744
00:27:26,880 --> 00:27:29,679
follow along as as we look at things

745
00:27:29,679 --> 00:27:31,440
it's the most simple one it's clear

746
00:27:31,440 --> 00:27:33,039
what's being enqueued and it's clear

747
00:27:33,039 --> 00:27:34,720
when things are happening but there's

748
00:27:34,720 --> 00:27:36,480
more nonlinear control flow everywhere

749
00:27:36,480 --> 00:27:38,960
around the place here so figuring out

750
00:27:38,960 --> 00:27:40,559
our understanding how to follow the

751
00:27:40,559 --> 00:27:41,919
along these things

752
00:27:41,919 --> 00:27:43,679
is really important to understanding how

753
00:27:43,679 --> 00:27:45,919
the air track works inside

754
00:27:45,919 --> 00:27:46,960
another

755
00:27:46,960 --> 00:27:48,799
piece of nonlinear controls though are

756
00:27:48,799 --> 00:27:50,480
timers

757
00:27:50,480 --> 00:27:52,799
the airtec uses the timers that are

758
00:27:52,799 --> 00:27:55,200
taken pretty much exactly from the nrf

759
00:27:55,200 --> 00:27:58,480
sdk's example code

760
00:27:58,960 --> 00:28:00,880
so let's look at some timers

761
00:28:00,880 --> 00:28:02,720
and again i'll take the playing a sound

762
00:28:02,720 --> 00:28:05,360
as an example here

763
00:28:05,360 --> 00:28:07,440
timers are created using a call to app

764
00:28:07,440 --> 00:28:09,919
timer create which is a function that's

765
00:28:09,919 --> 00:28:12,720
in the example code for the nrf

766
00:28:12,720 --> 00:28:14,799
and there's a pointer to a timer

767
00:28:14,799 --> 00:28:18,080
structure that's then used when

768
00:28:18,080 --> 00:28:20,000
starting a timer or ending a timer so

769
00:28:20,000 --> 00:28:21,360
looking at the cross references we can

770
00:28:21,360 --> 00:28:23,600
see a call to app timer start we can

771
00:28:23,600 --> 00:28:24,880
also see a

772
00:28:24,880 --> 00:28:26,960
call to app timer stop

773
00:28:26,960 --> 00:28:29,120
when starting a timer we also add what

774
00:28:29,120 --> 00:28:30,960
the callback handler is that's being

775
00:28:30,960 --> 00:28:33,200
called

776
00:28:35,520 --> 00:28:37,440
now that we know how to follow timers

777
00:28:37,440 --> 00:28:39,520
and so on let's get to the interesting

778
00:28:39,520 --> 00:28:41,520
part what's the state machine thing that

779
00:28:41,520 --> 00:28:43,600
we've seen a few times already

780
00:28:43,600 --> 00:28:45,200
so the nrf can do different things at

781
00:28:45,200 --> 00:28:48,080
different in different states it's in

782
00:28:48,080 --> 00:28:49,520
and it needs to keep stack of what's

783
00:28:49,520 --> 00:28:51,840
allowed at what point

784
00:28:51,840 --> 00:28:53,679
and it does this by implementing a big

785
00:28:53,679 --> 00:28:55,760
state machine

786
00:28:55,760 --> 00:28:56,880
so

787
00:28:56,880 --> 00:28:59,840
in the state machine

788
00:29:00,720 --> 00:29:02,880
where we have different cases for

789
00:29:02,880 --> 00:29:05,440
successful tasks and non-successful

790
00:29:05,440 --> 00:29:06,559
tasks

791
00:29:06,559 --> 00:29:09,600
and there's a big dispatch handler

792
00:29:09,600 --> 00:29:11,760
which contains all of the different

793
00:29:11,760 --> 00:29:14,640
states that we can be in and that also

794
00:29:14,640 --> 00:29:16,399
contains the handlers for these states

795
00:29:16,399 --> 00:29:18,000
so let's for example take the set date

796
00:29:18,000 --> 00:29:19,679
of playing a sound

797
00:29:19,679 --> 00:29:22,480
there's a list of handlers here and each

798
00:29:22,480 --> 00:29:24,000
command that can be sent to the state

799
00:29:24,000 --> 00:29:25,200
machine

800
00:29:25,200 --> 00:29:28,000
invokes the specific handler

801
00:29:28,000 --> 00:29:30,960
this is pretty complicated to

802
00:29:30,960 --> 00:29:32,720
understand when you're looking at this

803
00:29:32,720 --> 00:29:34,720
it's difficult to see

804
00:29:34,720 --> 00:29:36,159
what's happening where and how things

805
00:29:36,159 --> 00:29:38,000
fit together

806
00:29:38,000 --> 00:29:40,159
so we needed to figure out a way to

807
00:29:40,159 --> 00:29:41,919
understand this better and i've written

808
00:29:41,919 --> 00:29:44,000
a small script that will

809
00:29:44,000 --> 00:29:47,120
parse the state handler table and then

810
00:29:47,120 --> 00:29:49,200
print out some graphics.representation

811
00:29:49,200 --> 00:29:50,559
of it

812
00:29:50,559 --> 00:29:52,960
then running this we get a somewhat

813
00:29:52,960 --> 00:29:56,000
complicated graph of what's happening

814
00:29:56,000 --> 00:29:56,880
but

815
00:29:56,880 --> 00:29:59,039
and then using the method of intense

816
00:29:59,039 --> 00:30:00,399
staring at things

817
00:30:00,399 --> 00:30:02,720
we can start adding labels to things and

818
00:30:02,720 --> 00:30:04,320
understand what they are

819
00:30:04,320 --> 00:30:06,240
for example here we can see this there's

820
00:30:06,240 --> 00:30:08,080
a one state that's associated with

821
00:30:08,080 --> 00:30:10,480
playing a sound and other states that

822
00:30:10,480 --> 00:30:12,320
other transitions that can happen and we

823
00:30:12,320 --> 00:30:14,559
can see from which states we can go to

824
00:30:14,559 --> 00:30:16,640
playing a sound and not

825
00:30:16,640 --> 00:30:18,399
or when when the air tech for example

826
00:30:18,399 --> 00:30:21,639
will unpair

827
00:30:23,679 --> 00:30:25,679
so now we have two parts of research

828
00:30:25,679 --> 00:30:28,080
that we can put together there is my

829
00:30:28,080 --> 00:30:29,919
part with all the dynamic friday

830
00:30:29,919 --> 00:30:32,640
instrumentation from an iphone and i can

831
00:30:32,640 --> 00:30:34,960
run tasks and commands and then there is

832
00:30:34,960 --> 00:30:37,200
ferbian spirit with the static analysis

833
00:30:37,200 --> 00:30:39,200
to figure out implementation details so

834
00:30:39,200 --> 00:30:41,760
i can run commands and he can figure out

835
00:30:41,760 --> 00:30:45,360
what the parameters are exactly

836
00:30:45,360 --> 00:30:47,360
and here is one example so this is some

837
00:30:47,360 --> 00:30:48,960
instrumentation for the airtag that i

838
00:30:48,960 --> 00:30:51,840
also put on github like half an hour ago

839
00:30:51,840 --> 00:30:52,880
and

840
00:30:52,880 --> 00:30:55,279
there is the up codes that you can see

841
00:30:55,279 --> 00:30:57,279
there's also the task initialization

842
00:30:57,279 --> 00:31:00,159
that you can see and in the bottom i

843
00:31:00,159 --> 00:31:02,480
have the play sound sequence command

844
00:31:02,480 --> 00:31:04,399
and you can see there is multiple sound

845
00:31:04,399 --> 00:31:07,360
sequences so like the 205 that you saw

846
00:31:07,360 --> 00:31:09,760
the one is selecting the first sound

847
00:31:09,760 --> 00:31:11,679
sequence the three means i repeated

848
00:31:11,679 --> 00:31:14,640
three times the 23 is just an offset

849
00:31:14,640 --> 00:31:18,399
into the sound and d1 is the length of a

850
00:31:18,399 --> 00:31:20,720
pause and then the next four bytes are

851
00:31:20,720 --> 00:31:23,039
the next part of the sound sequence

852
00:31:23,039 --> 00:31:25,519
so i hope that you can hear this a bit

853
00:31:25,519 --> 00:31:29,159
when it plays

854
00:31:33,919 --> 00:31:35,600
so this is just the instrumentation that

855
00:31:35,600 --> 00:31:37,679
we can do but of course also for all the

856
00:31:37,679 --> 00:31:41,120
other commands and up codes

857
00:31:42,240 --> 00:31:44,080
the next part is the firmware downgrade

858
00:31:44,080 --> 00:31:44,799
so

859
00:31:44,799 --> 00:31:47,519
it's not just about having fun with d1

860
00:31:47,519 --> 00:31:49,039
or the other upcode and playing sound

861
00:31:49,039 --> 00:31:51,440
but really do something useful with the

862
00:31:51,440 --> 00:31:54,720
firmware for experimentation

863
00:31:54,720 --> 00:31:56,559
usually the

864
00:31:56,559 --> 00:31:58,720
iphone checks for updates every two

865
00:31:58,720 --> 00:32:00,799
hours and 30 minutes that's a bit long

866
00:32:00,799 --> 00:32:03,039
to wait so i want to trigger

867
00:32:03,039 --> 00:32:04,880
an update manually and then also

868
00:32:04,880 --> 00:32:07,120
re-instrument it for a down trade so i

869
00:32:07,120 --> 00:32:08,720
just pair my eye tag again and then

870
00:32:08,720 --> 00:32:10,559
after exactly five minutes there is a

871
00:32:10,559 --> 00:32:13,279
check if there is an update available so

872
00:32:13,279 --> 00:32:15,200
the search party demand just tells the

873
00:32:15,200 --> 00:32:17,120
firmware update daemon hey

874
00:32:17,120 --> 00:32:18,559
try to update

875
00:32:18,559 --> 00:32:20,399
then the firmware update daemon just

876
00:32:20,399 --> 00:32:22,640
invokes the durian updater service and

877
00:32:22,640 --> 00:32:23,519
says

878
00:32:23,519 --> 00:32:26,399
hey do an update for airtax

879
00:32:26,399 --> 00:32:28,159
this is then querying the search party

880
00:32:28,159 --> 00:32:30,640
demon and here i have to fake the beacon

881
00:32:30,640 --> 00:32:32,480
list so i have to fake the information

882
00:32:32,480 --> 00:32:35,039
of my air tech and just say with frida

883
00:32:35,039 --> 00:32:37,120
yes this air tech is outdated no matter

884
00:32:37,120 --> 00:32:40,880
what so that we can trigger an update

885
00:32:40,880 --> 00:32:42,960
then the durian update service contacts

886
00:32:42,960 --> 00:32:44,960
the mobile asset daemon and says hey

887
00:32:44,960 --> 00:32:46,559
download the firmware

888
00:32:46,559 --> 00:32:48,720
it just downloads it or if it's already

889
00:32:48,720 --> 00:32:50,720
downloaded it's also okay and then it's

890
00:32:50,720 --> 00:32:54,799
unpacking and validating it locally

891
00:32:54,799 --> 00:32:56,559
now there's an interesting part because

892
00:32:56,559 --> 00:32:59,200
now the u1 chip is involved the u1 chip

893
00:32:59,200 --> 00:33:02,399
in each air tag has a unique ecid

894
00:33:02,399 --> 00:33:04,640
and during the update process the air

895
00:33:04,640 --> 00:33:06,799
tag you want to even create some nonce

896
00:33:06,799 --> 00:33:08,159
and this nonce

897
00:33:08,159 --> 00:33:09,600
is only

898
00:33:09,600 --> 00:33:11,919
used once so the update will only be

899
00:33:11,919 --> 00:33:13,840
accepted if the signature that's then

900
00:33:13,840 --> 00:33:16,480
created later on matches the nonce this

901
00:33:16,480 --> 00:33:18,000
is called personalization information

902
00:33:18,000 --> 00:33:19,840
but it's really just for the u1 chip

903
00:33:19,840 --> 00:33:21,679
it's nothing linked to your icloud

904
00:33:21,679 --> 00:33:23,919
account this takes 15 seconds which

905
00:33:23,919 --> 00:33:25,760
makes it a bit easier so this whole

906
00:33:25,760 --> 00:33:28,559
timing here enables us to replace files

907
00:33:28,559 --> 00:33:30,799
on the file system of the unpacked

908
00:33:30,799 --> 00:33:32,799
update

909
00:33:32,799 --> 00:33:35,279
then this personalization information

910
00:33:35,279 --> 00:33:37,679
along with the

911
00:33:37,679 --> 00:33:40,960
check sum of the u1 firmware is sent to

912
00:33:40,960 --> 00:33:44,399
apple's tatsu signing server so this one

913
00:33:44,399 --> 00:33:46,480
checks if this is

914
00:33:46,480 --> 00:33:48,720
your one firmware that's allowed to be

915
00:33:48,720 --> 00:33:50,399
signed and flashed to where you want

916
00:33:50,399 --> 00:33:52,720
ship and also adds the personalization

917
00:33:52,720 --> 00:33:54,720
information to a signature and then the

918
00:33:54,720 --> 00:33:57,440
u1 firmware is repacked with this ticket

919
00:33:57,440 --> 00:34:00,559
from the tss server

920
00:34:01,039 --> 00:34:02,960
and then finally the firmware update is

921
00:34:02,960 --> 00:34:05,679
invoked including the stuff of the nrf

922
00:34:05,679 --> 00:34:06,880
firmware

923
00:34:06,880 --> 00:34:09,520
and this is then being sent over ble

924
00:34:09,520 --> 00:34:12,000
which takes another two or three minutes

925
00:34:12,000 --> 00:34:13,918
so this is the really interesting part

926
00:34:13,918 --> 00:34:16,079
of how to either do an update or also a

927
00:34:16,079 --> 00:34:19,119
downgrade if we replace this

928
00:34:19,119 --> 00:34:22,239
we can always downgrade the u1 firmware

929
00:34:22,239 --> 00:34:24,399
to a version that is still tss signed so

930
00:34:24,399 --> 00:34:26,480
if apple signs it we can downgrade q1

931
00:34:26,480 --> 00:34:28,800
even to a non-matching nrf firmware and

932
00:34:28,800 --> 00:34:31,199
the nrf firmware itself is not tied to

933
00:34:31,199 --> 00:34:33,839
anything special on the air tech so we

934
00:34:33,839 --> 00:34:36,639
can always downgrade to any nrf firmware

935
00:34:36,639 --> 00:34:40,000
that has been released

936
00:34:40,719 --> 00:34:42,480
the firmware format is interesting to

937
00:34:42,480 --> 00:34:43,918
understand i also have a script for

938
00:34:43,918 --> 00:34:45,280
unpacking this

939
00:34:45,280 --> 00:34:47,280
because it has three parts for the nrf

940
00:34:47,280 --> 00:34:48,800
the bluetooth application the soft

941
00:34:48,800 --> 00:34:50,800
device and the bootloader including

942
00:34:50,800 --> 00:34:52,800
their signatures and then we have a

943
00:34:52,800 --> 00:34:55,359
special ftab file with the u1 firmware

944
00:34:55,359 --> 00:34:57,359
which is not yet signed so this is the

945
00:34:57,359 --> 00:35:01,319
unsigned version of it

946
00:35:03,280 --> 00:35:05,359
so again let's look at how this is

947
00:35:05,359 --> 00:35:08,560
implemented in the firmware

948
00:35:13,760 --> 00:35:15,040
there's

949
00:35:15,040 --> 00:35:17,200
a get receive handler

950
00:35:17,200 --> 00:35:19,520
we refer the characteristic number

951
00:35:19,520 --> 00:35:21,119
6001

952
00:35:21,119 --> 00:35:23,119
which is the one that receives all of

953
00:35:23,119 --> 00:35:24,800
the data that's being pushed over

954
00:35:24,800 --> 00:35:27,440
bluetooth le with all the firmware

955
00:35:27,440 --> 00:35:29,359
packets and we can see that there is a

956
00:35:29,359 --> 00:35:31,440
big switch case here

957
00:35:31,440 --> 00:35:32,800
for the different

958
00:35:32,800 --> 00:35:34,960
images that we've seen earlier for

959
00:35:34,960 --> 00:35:36,640
example the soft device the bluetooth

960
00:35:36,640 --> 00:35:38,720
app and so on

961
00:35:38,720 --> 00:35:40,320
the interesting part here is that

962
00:35:40,320 --> 00:35:42,560
there's a signature check that's being

963
00:35:42,560 --> 00:35:46,240
done on most of these images

964
00:35:46,240 --> 00:35:48,720
especially well the nrf ones

965
00:35:48,720 --> 00:35:49,920
and this

966
00:35:49,920 --> 00:35:51,599
signature check is implemented using

967
00:35:51,599 --> 00:35:57,800
sha256 and ecc with group p256

968
00:35:58,400 --> 00:36:01,440
then for example for the u1

969
00:36:01,440 --> 00:36:03,599
there is no such check because the u1

970
00:36:03,599 --> 00:36:08,160
verifies its signature on on itself

971
00:36:08,160 --> 00:36:10,839
there's also a handler that

972
00:36:10,839 --> 00:36:14,320
handles the end of the transmission

973
00:36:14,320 --> 00:36:17,359
and that's a handler 6003

974
00:36:17,359 --> 00:36:18,560
and that has different handlers

975
00:36:18,560 --> 00:36:20,240
depending what's what the chip should do

976
00:36:20,240 --> 00:36:22,640
after receiving this specific image

977
00:36:22,640 --> 00:36:25,040
whether it for example should reboot

978
00:36:25,040 --> 00:36:26,720
into the firmware and into the

979
00:36:26,720 --> 00:36:28,960
bootloader and and start a new

980
00:36:28,960 --> 00:36:31,200
and start the new firmware

981
00:36:31,200 --> 00:36:33,200
which ends up happening here so you can

982
00:36:33,200 --> 00:36:34,320
see

983
00:36:34,320 --> 00:36:36,079
these characteristic right handlers are

984
00:36:36,079 --> 00:36:38,320
really crucial at understanding the

985
00:36:38,320 --> 00:36:42,480
interface to to the rest

986
00:36:47,599 --> 00:36:49,839
yeah so um

987
00:36:49,839 --> 00:36:51,680
what does this all matter well first off

988
00:36:51,680 --> 00:36:53,200
attacks are really fun target they are

989
00:36:53,200 --> 00:36:55,040
relatively cheap they have a lot of very

990
00:36:55,040 --> 00:36:58,079
modern features you have the u1 uw

991
00:36:58,079 --> 00:37:00,240
b you have all the

992
00:37:00,240 --> 00:37:02,880
interfacing with the iphone and so on

993
00:37:02,880 --> 00:37:04,640
and i mean it's an it's an apple iot

994
00:37:04,640 --> 00:37:06,240
device so it's interesting from the get

995
00:37:06,240 --> 00:37:07,680
go for me at least

996
00:37:07,680 --> 00:37:09,359
what was really interesting to me was

997
00:37:09,359 --> 00:37:11,520
like the the requirement of almost

998
00:37:11,520 --> 00:37:14,000
having full stack researchers for this

999
00:37:14,000 --> 00:37:15,680
because you have the ios side you have

1000
00:37:15,680 --> 00:37:16,400
the

1001
00:37:16,400 --> 00:37:18,079
uh the bluetooth side which i have no

1002
00:37:18,079 --> 00:37:19,599
clue about you have all the static

1003
00:37:19,599 --> 00:37:22,079
analysis that you need to do

1004
00:37:22,079 --> 00:37:24,560
and so then the hardware side obviously

1005
00:37:24,560 --> 00:37:27,359
and so yeah in the end we we are able to

1006
00:37:27,359 --> 00:37:29,680
you know glitch open any attack we are

1007
00:37:29,680 --> 00:37:31,040
able to play

1008
00:37:31,040 --> 00:37:33,599
uh sounds on any attack not well we can

1009
00:37:33,599 --> 00:37:35,359
play the unauthorized sound i guess on

1010
00:37:35,359 --> 00:37:37,440
any attack so if you

1011
00:37:37,440 --> 00:37:38,960
want to troll a room full of people with

1012
00:37:38,960 --> 00:37:41,280
attacks you could do that

1013
00:37:41,280 --> 00:37:43,760
and yes it's just also a great base for

1014
00:37:43,760 --> 00:37:44,720
u1

1015
00:37:44,720 --> 00:37:46,400
and ultra wideband research because i

1016
00:37:46,400 --> 00:37:49,119
said so far any ultra whiteband device

1017
00:37:49,119 --> 00:37:51,280
cost a couple of hundred dollars now it

1018
00:37:51,280 --> 00:37:54,079
costs i think 30 or 40 bucks also

1019
00:37:54,079 --> 00:37:55,680
glitching is fun it's really not

1020
00:37:55,680 --> 00:37:56,880
difficult

1021
00:37:56,880 --> 00:37:58,320
you can find all the

1022
00:37:58,320 --> 00:38:00,079
source code documentation and so on and

1023
00:38:00,079 --> 00:38:02,240
so forth on these github links that

1024
00:38:02,240 --> 00:38:04,240
we'll also post on twitter and so if you

1025
00:38:04,240 --> 00:38:06,079
want to glitch it just buy a pico and a

1026
00:38:06,079 --> 00:38:08,320
mosfet um if you want to take a look at

1027
00:38:08,320 --> 00:38:10,160
the hardware we have that online we have

1028
00:38:10,160 --> 00:38:10,960
all the

1029
00:38:10,960 --> 00:38:13,359
the scripts for frida and so on online

1030
00:38:13,359 --> 00:38:15,520
and yeah with that thank you for coming

1031
00:38:15,520 --> 00:38:17,040
and hope you enjoyed this and if there

1032
00:38:17,040 --> 00:38:18,960
are any questions please

1033
00:38:18,960 --> 00:38:22,119
go ahead

