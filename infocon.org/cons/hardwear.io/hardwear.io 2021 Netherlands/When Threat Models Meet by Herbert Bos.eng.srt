1
00:00:03,600 --> 00:00:06,879
okay so thank you and um uh so my name

2
00:00:06,879 --> 00:00:09,519
is herbert balsam from the vusac systems

3
00:00:09,519 --> 00:00:11,200
security research group at frye

4
00:00:11,200 --> 00:00:13,120
university amsterdam i want to start

5
00:00:13,120 --> 00:00:15,200
with the the most important information

6
00:00:15,200 --> 00:00:17,680
of this talk today which is that today's

7
00:00:17,680 --> 00:00:19,439
my birthday

8
00:00:19,439 --> 00:00:20,640
yes

9
00:00:20,640 --> 00:00:22,800
thank you and i would like to thank you

10
00:00:22,800 --> 00:00:25,039
all for coming to my birthday and thank

11
00:00:25,039 --> 00:00:26,560
you in advance for all the great

12
00:00:26,560 --> 00:00:28,320
presents that you're going to give me

13
00:00:28,320 --> 00:00:30,080
afterwards i don't see them on you so

14
00:00:30,080 --> 00:00:32,079
they must be in the corridor somewhere

15
00:00:32,079 --> 00:00:33,680
thank you

16
00:00:33,680 --> 00:00:35,920
um in this talk though i want to talk

17
00:00:35,920 --> 00:00:37,920
about threat models

18
00:00:37,920 --> 00:00:38,960
and

19
00:00:38,960 --> 00:00:41,360
i want to start with a story that

20
00:00:41,360 --> 00:00:43,840
occurred a couple of years ago when we

21
00:00:43,840 --> 00:00:45,920
disclosed the vulnerability in android

22
00:00:45,920 --> 00:00:48,160
that allowed attackers

23
00:00:48,160 --> 00:00:50,719
that compromised your pc to also

24
00:00:50,719 --> 00:00:52,559
compromise your

25
00:00:52,559 --> 00:00:54,160
smartphone and we thought that's really

26
00:00:54,160 --> 00:00:56,800
stupid but but some of the the google

27
00:00:56,800 --> 00:00:58,719
engineers disagreed so here's a reaction

28
00:00:58,719 --> 00:01:00,399
by one of the google engineers and he

29
00:01:00,399 --> 00:01:02,960
said look guys your threat model is bad

30
00:01:02,960 --> 00:01:05,280
and you should feel bad and then some of

31
00:01:05,280 --> 00:01:07,439
the other researchers in the world you

32
00:01:07,439 --> 00:01:09,760
know responded to that and said you know

33
00:01:09,760 --> 00:01:11,520
dude seriously i think their threat

34
00:01:11,520 --> 00:01:13,360
model is valid and maybe you should feel

35
00:01:13,360 --> 00:01:15,360
bad and i would agree with that but i

36
00:01:15,360 --> 00:01:17,119
don't want to talk about that particular

37
00:01:17,119 --> 00:01:19,200
vulnerability i want to talk about what

38
00:01:19,200 --> 00:01:21,200
the google engineer said and what it

39
00:01:21,200 --> 00:01:23,600
means to have a bad threat model and to

40
00:01:23,600 --> 00:01:25,920
have a good threat model because i think

41
00:01:25,920 --> 00:01:28,320
that threat models are amongst the most

42
00:01:28,320 --> 00:01:30,320
important things in security engineering

43
00:01:30,320 --> 00:01:32,240
because they determine

44
00:01:32,240 --> 00:01:33,759
um what an attacker is trying to

45
00:01:33,759 --> 00:01:36,079
accomplish what an attacker is able to

46
00:01:36,079 --> 00:01:37,840
do and therefore what we should defend

47
00:01:37,840 --> 00:01:39,280
against and what we should not defend

48
00:01:39,280 --> 00:01:41,680
against and we frequently get it wrong

49
00:01:41,680 --> 00:01:44,000
because we make assumptions about the

50
00:01:44,000 --> 00:01:46,640
attackers and the attackers disagree

51
00:01:46,640 --> 00:01:48,320
with our assumptions

52
00:01:48,320 --> 00:01:49,439
for instance

53
00:01:49,439 --> 00:01:51,119
we may assume that an attacker will

54
00:01:51,119 --> 00:01:53,840
never be able to break randomization or

55
00:01:53,840 --> 00:01:56,079
will never be able to in fact a phone

56
00:01:56,079 --> 00:01:58,399
after compromising the pc which is the

57
00:01:58,399 --> 00:02:00,479
android issue that i talked about or

58
00:02:00,479 --> 00:02:01,759
we'll be able to use side channels to

59
00:02:01,759 --> 00:02:03,280
break a cryptographic key or tamper with

60
00:02:03,280 --> 00:02:05,680
the hardware all sorts of other things

61
00:02:05,680 --> 00:02:07,680
or conversely we may think that an

62
00:02:07,680 --> 00:02:10,160
attacker always has to do certain things

63
00:02:10,160 --> 00:02:13,520
right an attacker in order to

64
00:02:13,520 --> 00:02:15,520
do software exploitation always has to

65
00:02:15,520 --> 00:02:18,160
inject their own shell code or always

66
00:02:18,160 --> 00:02:20,160
has to divert the control flow of the

67
00:02:20,160 --> 00:02:22,000
program use some particular form of

68
00:02:22,000 --> 00:02:24,560
analysis and so on and all of these

69
00:02:24,560 --> 00:02:26,959
assumptions were true at some point

70
00:02:26,959 --> 00:02:28,959
until they weren't right more advanced

71
00:02:28,959 --> 00:02:31,760
and more knowledge um emerged and then

72
00:02:31,760 --> 00:02:33,599
we realized that all of these things

73
00:02:33,599 --> 00:02:36,160
don't need to hold at all so we got the

74
00:02:36,160 --> 00:02:38,319
threat model wrong so let's talk about

75
00:02:38,319 --> 00:02:39,840
threat models and i think there is

76
00:02:39,840 --> 00:02:43,040
perhaps a fundamental problem here

77
00:02:43,040 --> 00:02:46,080
and in this talk i will uh

78
00:02:46,080 --> 00:02:47,920
i will start with you know a very

79
00:02:47,920 --> 00:02:49,840
accessible part right so let's say the

80
00:02:49,840 --> 00:02:51,920
first half of the talk and i'll go to

81
00:02:51,920 --> 00:02:54,480
some complete gibberish at the end which

82
00:02:54,480 --> 00:02:56,879
which may be much more technical

83
00:02:56,879 --> 00:02:59,760
and i i hope this is still going to be

84
00:02:59,760 --> 00:03:02,480
understandable to at least most of you

85
00:03:02,480 --> 00:03:05,519
so um but to help you along regardless

86
00:03:05,519 --> 00:03:07,280
um i will mark all of these slides that

87
00:03:07,280 --> 00:03:09,120
are actually important with an explicit

88
00:03:09,120 --> 00:03:11,360
exclamation mark so if you doze off

89
00:03:11,360 --> 00:03:12,959
during the talk it's fine as long as you

90
00:03:12,959 --> 00:03:14,720
wake up for these slides

91
00:03:14,720 --> 00:03:15,599
um

92
00:03:15,599 --> 00:03:17,599
so let's talk about threat models and

93
00:03:17,599 --> 00:03:18,640
you

94
00:03:18,640 --> 00:03:20,560
for thousands of years this is the

95
00:03:20,560 --> 00:03:22,959
accessible part for thousands of years

96
00:03:22,959 --> 00:03:25,599
human beings have tried to make sense of

97
00:03:25,599 --> 00:03:28,400
the world by means of classification

98
00:03:28,400 --> 00:03:30,400
and separation of concern and when i say

99
00:03:30,400 --> 00:03:32,319
classification i simply mean that we

100
00:03:32,319 --> 00:03:34,640
distinguish between me and you

101
00:03:34,640 --> 00:03:38,239
day and night you know rain and sunshine

102
00:03:38,239 --> 00:03:40,959
and so that if you know some

103
00:03:40,959 --> 00:03:43,519
quarrelsome youth in ancient greece

104
00:03:43,519 --> 00:03:45,840
would come along and say oh wait a

105
00:03:45,840 --> 00:03:47,360
minute wait a minute it's all you know

106
00:03:47,360 --> 00:03:49,280
it's all the same let's you know

107
00:03:49,280 --> 00:03:52,000
it's all this a lot of stuff aristotle

108
00:03:52,000 --> 00:03:54,239
would step in and say oh no that's not

109
00:03:54,239 --> 00:03:55,200
true

110
00:03:55,200 --> 00:03:57,519
it's all different stuff for instance we

111
00:03:57,519 --> 00:04:00,080
have plants and we have animals and the

112
00:04:00,080 --> 00:04:02,480
the plants can be subdivided into small

113
00:04:02,480 --> 00:04:04,400
plants medium plants and large plants

114
00:04:04,400 --> 00:04:06,400
and the animals can be subdivided in

115
00:04:06,400 --> 00:04:07,680
those with red blood and those with

116
00:04:07,680 --> 00:04:09,439
white blood and the red-blooded ones can

117
00:04:09,439 --> 00:04:11,200
be divided into

118
00:04:11,200 --> 00:04:12,720
those that lay eggs and those that give

119
00:04:12,720 --> 00:04:14,720
live birth and they're all different and

120
00:04:14,720 --> 00:04:16,160
of course the quarrelsome youth and

121
00:04:16,160 --> 00:04:18,079
ancient greece would go

122
00:04:18,079 --> 00:04:21,600
oh because in those days

123
00:04:21,600 --> 00:04:23,440
there was nothing to put a quarrelsome

124
00:04:23,440 --> 00:04:25,759
youth straight like hard signs and

125
00:04:25,759 --> 00:04:29,040
undiluted truth nowadays of course

126
00:04:29,040 --> 00:04:31,440
our quarrelsome youth knows that signs

127
00:04:31,440 --> 00:04:32,880
cannot be trusted and it's just an

128
00:04:32,880 --> 00:04:34,960
opinion and you can do your own research

129
00:04:34,960 --> 00:04:36,320
by watching youtube movies but there

130
00:04:36,320 --> 00:04:38,560
were no youtube movies in those days

131
00:04:38,560 --> 00:04:42,160
and therefore taxonomy could emerge as a

132
00:04:42,160 --> 00:04:44,080
scientific method and we still use that

133
00:04:44,080 --> 00:04:45,840
method today for instance when we talk

134
00:04:45,840 --> 00:04:47,680
about different kinds of vulnerabilities

135
00:04:47,680 --> 00:04:49,520
and exploitation we have software bugs

136
00:04:49,520 --> 00:04:51,280
with software exploitation hardware bugs

137
00:04:51,280 --> 00:04:53,280
with hardware exploitation and we can

138
00:04:53,280 --> 00:04:55,600
subdivide the software bugs for instance

139
00:04:55,600 --> 00:04:58,400
even talk about memory errors in

140
00:04:58,400 --> 00:05:00,240
spatial memory errors and temporal

141
00:05:00,240 --> 00:05:02,080
memory errors and the hardware bugs and

142
00:05:02,080 --> 00:05:03,680
hardware vulnerabilities

143
00:05:03,680 --> 00:05:05,199
and either as

144
00:05:05,199 --> 00:05:07,680
speculative execution bugs and row

145
00:05:07,680 --> 00:05:09,680
hammer and memory and so on

146
00:05:09,680 --> 00:05:12,240
and that's really handy because now we

147
00:05:12,240 --> 00:05:15,520
can focus our mitigation efforts on one

148
00:05:15,520 --> 00:05:17,840
particular class of vulnerabilities

149
00:05:17,840 --> 00:05:21,039
right so we can try to solve the problem

150
00:05:21,039 --> 00:05:22,800
of spatial memory errors buffer

151
00:05:22,800 --> 00:05:25,600
overflows without having to worry about

152
00:05:25,600 --> 00:05:27,440
all the complexity of either a

153
00:05:27,440 --> 00:05:29,120
speculative execution or row hammer or

154
00:05:29,120 --> 00:05:30,560
so on

155
00:05:30,560 --> 00:05:34,080
likewise we can try to solve at least to

156
00:05:34,080 --> 00:05:36,479
the best of our abilities the problem of

157
00:05:36,479 --> 00:05:38,080
speculative execution or transient

158
00:05:38,080 --> 00:05:39,840
execution attacks

159
00:05:39,840 --> 00:05:41,520
without having to worry about i don't

160
00:05:41,520 --> 00:05:42,560
know

161
00:05:42,560 --> 00:05:44,320
temporal memory errors or something so

162
00:05:44,320 --> 00:05:46,400
that's good and this um

163
00:05:46,400 --> 00:05:48,479
the separation of concern is also

164
00:05:48,479 --> 00:05:49,680
something that we've been doing for

165
00:05:49,680 --> 00:05:52,000
hundreds of years already for instance

166
00:05:52,000 --> 00:05:55,039
if we look at the divine comedy

167
00:05:55,039 --> 00:05:58,479
dante imagined hal to consist of nine

168
00:05:58,479 --> 00:05:59,600
layers

169
00:05:59,600 --> 00:06:00,639
and it's

170
00:06:00,639 --> 00:06:03,280
a little bit complicated as you can see

171
00:06:03,280 --> 00:06:05,039
so they later simplified that and it

172
00:06:05,039 --> 00:06:07,039
became the seven layer oc reference

173
00:06:07,039 --> 00:06:08,160
model

174
00:06:08,160 --> 00:06:10,800
where in for instance you know every

175
00:06:10,800 --> 00:06:12,479
layer

176
00:06:12,479 --> 00:06:14,720
the functionality could concentrate on

177
00:06:14,720 --> 00:06:16,960
the task at hand without having to worry

178
00:06:16,960 --> 00:06:19,520
about the hell below them or indeed the

179
00:06:19,520 --> 00:06:21,360
hell above them for instance if we look

180
00:06:21,360 --> 00:06:23,440
at the fourth layer of hell also known

181
00:06:23,440 --> 00:06:25,840
as the transport layer

182
00:06:25,840 --> 00:06:28,639
dante imagines sinners pushing really

183
00:06:28,639 --> 00:06:31,280
big boulders towards the center of hell

184
00:06:31,280 --> 00:06:33,360
or away from the center of hell

185
00:06:33,360 --> 00:06:35,680
and this is known as tcp

186
00:06:35,680 --> 00:06:36,720
and

187
00:06:36,720 --> 00:06:38,160
and they didn't have to worry about what

188
00:06:38,160 --> 00:06:40,240
was going on below them or indeed what

189
00:06:40,240 --> 00:06:42,160
was going on above them and in fact they

190
00:06:42,160 --> 00:06:43,600
could

191
00:06:43,600 --> 00:06:46,639
present boulder pushing as a service to

192
00:06:46,639 --> 00:06:49,759
the layer above them so that's all very

193
00:06:49,759 --> 00:06:50,880
good

194
00:06:50,880 --> 00:06:53,120
and i would argue that the

195
00:06:53,120 --> 00:06:56,319
abstractions that we have this layering

196
00:06:56,319 --> 00:06:58,560
is are actually

197
00:06:58,560 --> 00:07:02,240
fundamental they're crucial for our um

198
00:07:02,240 --> 00:07:04,560
our need to understand the world and be

199
00:07:04,560 --> 00:07:06,000
able to work with the world right

200
00:07:06,000 --> 00:07:07,759
because all of the systems that we build

201
00:07:07,759 --> 00:07:09,680
are so complex that if we don't abstract

202
00:07:09,680 --> 00:07:11,680
away all the details we wouldn't be able

203
00:07:11,680 --> 00:07:13,680
to make any sense of this or make any

204
00:07:13,680 --> 00:07:15,280
use of it so we need them the

205
00:07:15,280 --> 00:07:17,120
fundamental concept but if you go and

206
00:07:17,120 --> 00:07:20,479
talk to eric bossman our phd student

207
00:07:20,479 --> 00:07:22,880
he will tell you that is also exactly

208
00:07:22,880 --> 00:07:23,680
these

209
00:07:23,680 --> 00:07:24,800
um

210
00:07:24,800 --> 00:07:26,800
abstractions that are

211
00:07:26,800 --> 00:07:28,479
the cause of the problem so there are

212
00:07:28,479 --> 00:07:30,560
cracks in the abstraction there are

213
00:07:30,560 --> 00:07:32,960
leaks in the abstraction that actually

214
00:07:32,960 --> 00:07:34,800
hide the vulnerabilities that's where

215
00:07:34,800 --> 00:07:37,280
the vulnerabilities emerge

216
00:07:37,280 --> 00:07:39,280
and that's one of the important slides i

217
00:07:39,280 --> 00:07:42,400
think so eric has a point

218
00:07:42,400 --> 00:07:45,680
if we apply that to our um seven layer

219
00:07:45,680 --> 00:07:47,919
oc reference model of hell

220
00:07:47,919 --> 00:07:51,120
we see that in the transport layer

221
00:07:51,120 --> 00:07:52,639
these guys are pushing really heavy

222
00:07:52,639 --> 00:07:55,120
boulders that's not a great job and it's

223
00:07:55,120 --> 00:07:58,479
you know it's also hot it's hot as hell

224
00:07:58,479 --> 00:07:59,919
and you know maybe there's demons

225
00:07:59,919 --> 00:08:01,360
flogging you and it's not pleasant so

226
00:08:01,360 --> 00:08:03,440
what these guys may be doing is turn on

227
00:08:03,440 --> 00:08:05,680
some music because they um it's much

228
00:08:05,680 --> 00:08:06,960
easier to push boulders when you're

229
00:08:06,960 --> 00:08:08,240
listening to the beatles but then of

230
00:08:08,240 --> 00:08:10,000
course immediately some neighbors start

231
00:08:10,000 --> 00:08:11,199
complaining because they don't like the

232
00:08:11,199 --> 00:08:12,639
beetles and they will ask you to turn it

233
00:08:12,639 --> 00:08:15,039
down and what we see here is that

234
00:08:15,039 --> 00:08:16,960
something that you thought was confined

235
00:08:16,960 --> 00:08:20,160
to one layer is actually leaking into

236
00:08:20,160 --> 00:08:22,400
and disturbing some other layer and this

237
00:08:22,400 --> 00:08:24,240
is exactly what is happening in computer

238
00:08:24,240 --> 00:08:26,240
systems for instance when we talk about

239
00:08:26,240 --> 00:08:28,080
side channels

240
00:08:28,080 --> 00:08:30,560
assume that we have two processes let's

241
00:08:30,560 --> 00:08:31,280
see

242
00:08:31,280 --> 00:08:33,519
two processors here running on top of

243
00:08:33,519 --> 00:08:35,200
some kernel and maybe one of the

244
00:08:35,200 --> 00:08:37,279
processes the one on the left is doing

245
00:08:37,279 --> 00:08:39,279
some super secretive

246
00:08:39,279 --> 00:08:41,279
processing right encryption or so with a

247
00:08:41,279 --> 00:08:43,360
super secret key

248
00:08:43,360 --> 00:08:45,440
and that is all fine because these

249
00:08:45,440 --> 00:08:48,080
processes are isolated none of this

250
00:08:48,080 --> 00:08:50,640
super secret key will leak to the

251
00:08:50,640 --> 00:08:53,279
neighboring process or

252
00:08:53,279 --> 00:08:54,560
anything that happens in the kernel

253
00:08:54,560 --> 00:08:56,480
leaks to any of the processes because

254
00:08:56,480 --> 00:08:59,360
there are impenetrable barriers between

255
00:08:59,360 --> 00:09:01,600
them there's a user kernel boundary and

256
00:09:01,600 --> 00:09:03,200
there's memory protection between the

257
00:09:03,200 --> 00:09:05,040
processes so it's fine if you do

258
00:09:05,040 --> 00:09:07,040
something super secretive it will not

259
00:09:07,040 --> 00:09:08,399
leak to the other

260
00:09:08,399 --> 00:09:10,800
process at least that is the theory but

261
00:09:10,800 --> 00:09:13,440
in reality of course there's a lot of

262
00:09:13,440 --> 00:09:16,160
stuff a lot of resources that are shared

263
00:09:16,160 --> 00:09:18,640
between all of these parties

264
00:09:18,640 --> 00:09:20,640
for instance one of the best known

265
00:09:20,640 --> 00:09:22,880
resource that is being shared by all

266
00:09:22,880 --> 00:09:25,839
three parties here is the cache some

267
00:09:25,839 --> 00:09:27,519
really fast memory

268
00:09:27,519 --> 00:09:29,839
that is used to um to speed up

269
00:09:29,839 --> 00:09:31,519
processing okay

270
00:09:31,519 --> 00:09:32,399
and

271
00:09:32,399 --> 00:09:33,839
let's assume that

272
00:09:33,839 --> 00:09:36,000
the process on the left here is doing

273
00:09:36,000 --> 00:09:38,800
some super secret cryptography

274
00:09:38,800 --> 00:09:41,279
by what is you know frequently done

275
00:09:41,279 --> 00:09:44,399
iterating over this super secret key

276
00:09:44,399 --> 00:09:47,600
and depending on the value of a bit in

277
00:09:47,600 --> 00:09:49,440
the key it will do

278
00:09:49,440 --> 00:09:50,640
something

279
00:09:50,640 --> 00:09:53,200
if it's uh the value zero and it will do

280
00:09:53,200 --> 00:09:56,160
something else if it is value one

281
00:09:56,160 --> 00:09:59,839
okay and what that means is that um

282
00:09:59,839 --> 00:10:03,120
if the the bit in the key is zero do

283
00:10:03,120 --> 00:10:04,640
something else will be executed and

284
00:10:04,640 --> 00:10:07,200
because of that it will be loaded in the

285
00:10:07,200 --> 00:10:09,920
cache right so let's talk about the last

286
00:10:09,920 --> 00:10:12,399
level cache which is shared between

287
00:10:12,399 --> 00:10:13,920
code and data

288
00:10:13,920 --> 00:10:16,320
okay and we have an attacker that that

289
00:10:16,320 --> 00:10:18,800
wants to

290
00:10:20,320 --> 00:10:22,079
steal the secret key

291
00:10:22,079 --> 00:10:23,680
okay so

292
00:10:23,680 --> 00:10:27,200
if the bit of the key is a zero the

293
00:10:27,200 --> 00:10:29,279
code that corresponds to do something

294
00:10:29,279 --> 00:10:31,680
will be loaded in the cache add a

295
00:10:31,680 --> 00:10:34,079
location in the cache at the cache line

296
00:10:34,079 --> 00:10:36,720
that is determined by the address of

297
00:10:36,720 --> 00:10:38,160
this function

298
00:10:38,160 --> 00:10:40,959
okay and if the bit is one the code for

299
00:10:40,959 --> 00:10:42,399
do something else will be loaded in the

300
00:10:42,399 --> 00:10:45,040
cache also at a location that is sorry

301
00:10:45,040 --> 00:10:47,040
at a cache line that is determined by

302
00:10:47,040 --> 00:10:49,040
the location by the address of the do

303
00:10:49,040 --> 00:10:51,120
something else code

304
00:10:51,120 --> 00:10:53,519
okay and meanwhile this attacker is also

305
00:10:53,519 --> 00:10:55,680
accessing memory okay so that is also

306
00:10:55,680 --> 00:10:58,720
loaded in the cache in fact the attacker

307
00:10:58,720 --> 00:11:00,880
we assume to be accessing memory

308
00:11:00,880 --> 00:11:03,040
constantly so maybe a whole pile of

309
00:11:03,040 --> 00:11:04,000
memory

310
00:11:04,000 --> 00:11:06,079
and it tramples all over the cache so

311
00:11:06,079 --> 00:11:08,640
that all of the things that were in the

312
00:11:08,640 --> 00:11:11,839
cache on behalf of this process are will

313
00:11:11,839 --> 00:11:13,440
be evicted

314
00:11:13,440 --> 00:11:15,360
okay and what the attacker is doing is

315
00:11:15,360 --> 00:11:17,279
simply iterate over each of these cache

316
00:11:17,279 --> 00:11:19,600
lines and timing how long it takes to

317
00:11:19,600 --> 00:11:22,000
read that memory okay and it will be

318
00:11:22,000 --> 00:11:23,920
super fast because it's it's in the

319
00:11:23,920 --> 00:11:25,040
cache

320
00:11:25,040 --> 00:11:27,519
okay and then at some point this process

321
00:11:27,519 --> 00:11:28,880
starts doing the encryption or

322
00:11:28,880 --> 00:11:30,320
decryption

323
00:11:30,320 --> 00:11:34,079
and it accesses the first bit of the key

324
00:11:34,079 --> 00:11:36,720
and let's say that that first bit is a

325
00:11:36,720 --> 00:11:39,440
one so it will execute do something else

326
00:11:39,440 --> 00:11:40,800
and because of that do something else

327
00:11:40,800 --> 00:11:43,680
will be loaded into the cache

328
00:11:43,680 --> 00:11:46,720
throwing out some of the attackers data

329
00:11:46,720 --> 00:11:49,040
so now the attacker is still iterating

330
00:11:49,040 --> 00:11:50,800
over all of the

331
00:11:50,800 --> 00:11:51,600
its

332
00:11:51,600 --> 00:11:54,800
entries in the cache and it will dis in

333
00:11:54,800 --> 00:11:56,320
some chunk of memory and it will

334
00:11:56,320 --> 00:11:59,040
discover that you know these first three

335
00:11:59,040 --> 00:12:01,200
are loaded super fast because they're in

336
00:12:01,200 --> 00:12:03,440
the cache and then the next one guess

337
00:12:03,440 --> 00:12:05,279
what it's slow because it was chucked

338
00:12:05,279 --> 00:12:07,040
out of the cache it has to be

339
00:12:07,040 --> 00:12:09,360
fetched from main memory takes a long

340
00:12:09,360 --> 00:12:12,160
time so this is measurably slower

341
00:12:12,160 --> 00:12:15,839
so now the attacker knows that this code

342
00:12:15,839 --> 00:12:18,160
must have been accessed by the victim in

343
00:12:18,160 --> 00:12:20,800
other words the attacker can

344
00:12:20,800 --> 00:12:23,200
decide that this first

345
00:12:23,200 --> 00:12:25,360
bit of the key must have been a one

346
00:12:25,360 --> 00:12:28,079
maybe later on it will find that uh the

347
00:12:28,079 --> 00:12:30,720
next thing that uh that is slow is the

348
00:12:30,720 --> 00:12:32,720
the other entry the red entry and then

349
00:12:32,720 --> 00:12:34,880
it determines that the next bit is zero

350
00:12:34,880 --> 00:12:36,399
and so on so it will keep doing this

351
00:12:36,399 --> 00:12:38,800
until it leaks the entire key

352
00:12:38,800 --> 00:12:40,639
now this is

353
00:12:40,639 --> 00:12:42,800
a problem because what i would consider

354
00:12:42,800 --> 00:12:45,680
the first law of software engineering

355
00:12:45,680 --> 00:12:47,200
um

356
00:12:47,200 --> 00:12:49,120
is that you don't have to worry about

357
00:12:49,120 --> 00:12:50,720
these things we have struc we abstract

358
00:12:50,720 --> 00:12:53,760
abstracted away all of this complexity

359
00:12:53,760 --> 00:12:55,680
as a software engineer just someone who

360
00:12:55,680 --> 00:12:58,240
writes an application you don't worry

361
00:12:58,240 --> 00:13:00,800
about what is going on at the

362
00:13:00,800 --> 00:13:02,560
much lower levels at the micro

363
00:13:02,560 --> 00:13:04,240
architectural level in this particular

364
00:13:04,240 --> 00:13:05,120
case

365
00:13:05,120 --> 00:13:07,440
okay and now all of a sudden the um the

366
00:13:07,440 --> 00:13:09,600
software engineer does have to worry

367
00:13:09,600 --> 00:13:10,720
about that

368
00:13:10,720 --> 00:13:14,240
okay we hide this behind an api and it's

369
00:13:14,240 --> 00:13:17,600
problematic for the for the

370
00:13:17,600 --> 00:13:19,040
software developer because now the

371
00:13:19,040 --> 00:13:20,639
software developer has to think about

372
00:13:20,639 --> 00:13:23,440
you know how you how does this interact

373
00:13:23,440 --> 00:13:25,600
with you know some micro architectural

374
00:13:25,600 --> 00:13:27,600
stuff there that i don't really fully

375
00:13:27,600 --> 00:13:28,800
understand

376
00:13:28,800 --> 00:13:31,120
and how can i make my code constant time

377
00:13:31,120 --> 00:13:32,639
and do all sorts of all sorts of other

378
00:13:32,639 --> 00:13:34,959
things and it's not just this particular

379
00:13:34,959 --> 00:13:37,040
issue the cache it may also be i don't

380
00:13:37,040 --> 00:13:41,199
know main memory which is vulnerable to

381
00:13:41,279 --> 00:13:43,600
bit flip attacks by means of the row

382
00:13:43,600 --> 00:13:45,360
hammer vulnerability

383
00:13:45,360 --> 00:13:47,279
okay and you have to worry about all

384
00:13:47,279 --> 00:13:48,880
sorts of speculative and you know or

385
00:13:48,880 --> 00:13:50,959
slash transient execution uh

386
00:13:50,959 --> 00:13:53,839
vulnerabilities such as meltdowns factor

387
00:13:53,839 --> 00:13:56,639
mds and so on you have to worry about

388
00:13:56,639 --> 00:13:58,639
functionality in the operating system

389
00:13:58,639 --> 00:14:00,320
where you know some operating system

390
00:14:00,320 --> 00:14:01,680
functionality such as memory

391
00:14:01,680 --> 00:14:04,480
deduplication is really handy to reduce

392
00:14:04,480 --> 00:14:07,279
the footprint of

393
00:14:07,279 --> 00:14:09,760
your system the memory footprint of your

394
00:14:09,760 --> 00:14:12,320
system but it can actually be used as a

395
00:14:12,320 --> 00:14:14,000
side channel to leak information i'll

396
00:14:14,000 --> 00:14:16,160
talk about that later on and you have to

397
00:14:16,160 --> 00:14:18,720
worry about traditional software bugs

398
00:14:18,720 --> 00:14:20,800
buffer overflows use after freeze and

399
00:14:20,800 --> 00:14:22,000
all of these things and you have to

400
00:14:22,000 --> 00:14:23,839
worry about physical attacks where

401
00:14:23,839 --> 00:14:26,160
people start you know measuring stuff at

402
00:14:26,160 --> 00:14:28,560
the pins of chips or you know doing em

403
00:14:28,560 --> 00:14:29,760
measurements

404
00:14:29,760 --> 00:14:32,000
all of these things are now a concern

405
00:14:32,000 --> 00:14:34,399
for our poor

406
00:14:34,399 --> 00:14:36,480
software developers so here we have our

407
00:14:36,480 --> 00:14:38,160
software developer aristotle in this

408
00:14:38,160 --> 00:14:40,160
particular case you know being a little

409
00:14:40,160 --> 00:14:42,720
bit stressed pondering the futility of

410
00:14:42,720 --> 00:14:45,519
life and losing the will to live

411
00:14:45,519 --> 00:14:48,000
and i would argue that what we're doing

412
00:14:48,000 --> 00:14:48,959
in

413
00:14:48,959 --> 00:14:52,079
security research is try to

414
00:14:52,079 --> 00:14:54,880
re-establish these barriers try and

415
00:14:54,880 --> 00:14:58,000
re-establish the boundaries that that

416
00:14:58,000 --> 00:14:59,040
were

417
00:14:59,040 --> 00:15:00,639
unfortunately

418
00:15:00,639 --> 00:15:03,279
not entire a little bit leaky so we we

419
00:15:03,279 --> 00:15:05,040
try to reassemble them this is what we

420
00:15:05,040 --> 00:15:06,959
we try to do in security research and

421
00:15:06,959 --> 00:15:09,199
the problem is that it may not be

422
00:15:09,199 --> 00:15:10,240
possible

423
00:15:10,240 --> 00:15:11,519
because

424
00:15:11,519 --> 00:15:13,760
what you do

425
00:15:13,760 --> 00:15:17,199
is interacting with all sorts of stuff

426
00:15:17,199 --> 00:15:20,000
at the outer layer here

427
00:15:20,000 --> 00:15:21,040
and

428
00:15:21,040 --> 00:15:22,800
whether or not something is safe like

429
00:15:22,800 --> 00:15:24,560
you know your interaction with the the

430
00:15:24,560 --> 00:15:27,360
cache is determined by

431
00:15:27,360 --> 00:15:30,399
the exact thing that you're doing inside

432
00:15:30,399 --> 00:15:32,320
of your application okay and the

433
00:15:32,320 --> 00:15:34,000
interaction is super complicated you

434
00:15:34,000 --> 00:15:36,800
need to know what it means at the the

435
00:15:36,800 --> 00:15:39,759
other levels okay as the the quarrelsome

436
00:15:39,759 --> 00:15:42,000
youth that said it's all a bunch of

437
00:15:42,000 --> 00:15:44,079
stuff and you have to kind of know

438
00:15:44,079 --> 00:15:45,759
everything about that in order to make

439
00:15:45,759 --> 00:15:48,240
this safe

440
00:15:49,199 --> 00:15:52,160
so so this is another important view

441
00:15:52,160 --> 00:15:54,399
graph i think so

442
00:15:54,399 --> 00:15:57,360
i think that the security depends on not

443
00:15:57,360 --> 00:16:00,399
just on your code being secure but on

444
00:16:00,399 --> 00:16:02,079
all the possible interactions with all

445
00:16:02,079 --> 00:16:03,600
the other stuff that is out there and

446
00:16:03,600 --> 00:16:07,120
that is way too much and way too complex

447
00:16:07,120 --> 00:16:09,279
to really

448
00:16:09,279 --> 00:16:10,800
grok

449
00:16:10,800 --> 00:16:12,720
deeply so the security depends on your

450
00:16:12,720 --> 00:16:14,240
code and everything else and to write

451
00:16:14,240 --> 00:16:16,000
secure programs you kind of have to know

452
00:16:16,000 --> 00:16:17,199
about all of the other things you have

453
00:16:17,199 --> 00:16:18,560
to know that there is you know this

454
00:16:18,560 --> 00:16:20,720
potential cache effect that the attacker

455
00:16:20,720 --> 00:16:23,199
can abuse and that is

456
00:16:23,199 --> 00:16:26,800
difficult and uh so the the conclusion

457
00:16:26,800 --> 00:16:28,560
there is that these abstractions that

458
00:16:28,560 --> 00:16:30,320
are on the one hand essential

459
00:16:30,320 --> 00:16:32,240
fundamental right so we cannot do

460
00:16:32,240 --> 00:16:34,160
without them because life becomes too

461
00:16:34,160 --> 00:16:36,000
complex without them

462
00:16:36,000 --> 00:16:38,480
are also in themselves harmful they're

463
00:16:38,480 --> 00:16:40,320
hiding some of the things that you are

464
00:16:40,320 --> 00:16:43,120
actually interacting with

465
00:16:43,120 --> 00:16:46,079
okay and it gets even worse

466
00:16:46,079 --> 00:16:48,160
because what we're doing in security

467
00:16:48,160 --> 00:16:50,959
research is exactly what aristotle

468
00:16:50,959 --> 00:16:53,360
prescribed which is to treat some of

469
00:16:53,360 --> 00:16:55,839
these things in isolation treat

470
00:16:55,839 --> 00:16:57,600
different threat models completely in

471
00:16:57,600 --> 00:16:59,519
isolation pretending that there are

472
00:16:59,519 --> 00:17:02,560
boundaries between these things right we

473
00:17:02,560 --> 00:17:05,199
focus on solutions for i don't know

474
00:17:05,199 --> 00:17:07,359
traditional software exploitation for

475
00:17:07,359 --> 00:17:09,679
instance by either randomizing the

476
00:17:09,679 --> 00:17:11,839
memory layout of programs physical

477
00:17:11,839 --> 00:17:15,199
attacks by locking things down

478
00:17:15,199 --> 00:17:17,039
turning off some operating system

479
00:17:17,039 --> 00:17:19,280
functionality such as deduplication

480
00:17:19,280 --> 00:17:22,559
maybe making it difficult to abuse

481
00:17:22,559 --> 00:17:24,799
indirect branches to stop speculative

482
00:17:24,799 --> 00:17:28,960
execution attacks and maybe we separate

483
00:17:28,960 --> 00:17:31,679
the so we partition the cache so that

484
00:17:31,679 --> 00:17:34,320
you don't share cache space anymore and

485
00:17:34,320 --> 00:17:37,679
maybe we do some tricks for the

486
00:17:37,679 --> 00:17:39,760
memory by refreshing

487
00:17:39,760 --> 00:17:41,679
memory so that row hammer becomes more

488
00:17:41,679 --> 00:17:45,360
difficult we focus our defenses on these

489
00:17:45,360 --> 00:17:47,760
partitioned regions as if there is a

490
00:17:47,760 --> 00:17:49,760
boundary between them but of course

491
00:17:49,760 --> 00:17:51,440
there isn't

492
00:17:51,440 --> 00:17:54,720
okay in reality

493
00:17:55,600 --> 00:17:56,720
and here my

494
00:17:56,720 --> 00:17:59,200
slides stop oh in reality it's it's all

495
00:17:59,200 --> 00:18:01,120
just one thing and the attackers will

496
00:18:01,120 --> 00:18:04,160
basically use anything from anywhere so

497
00:18:04,160 --> 00:18:07,039
any aspect of um of the the space that

498
00:18:07,039 --> 00:18:09,520
surrounds this program can be used to

499
00:18:09,520 --> 00:18:12,240
exploit your code

500
00:18:12,240 --> 00:18:13,120
okay

501
00:18:13,120 --> 00:18:15,200
so

502
00:18:15,200 --> 00:18:17,840
the conclusion here is that

503
00:18:17,840 --> 00:18:19,280
thinking about threat models in

504
00:18:19,280 --> 00:18:22,160
isolation is you know although also very

505
00:18:22,160 --> 00:18:24,000
helpful and and maybe essential because

506
00:18:24,000 --> 00:18:25,440
otherwise it becomes way too complex

507
00:18:25,440 --> 00:18:27,039
it's also a bit of a mistake because the

508
00:18:27,039 --> 00:18:30,240
attacker is not bound to your

509
00:18:30,240 --> 00:18:32,320
partitioning okay the attackers will not

510
00:18:32,320 --> 00:18:33,440
follow your rule and they will just

511
00:18:33,440 --> 00:18:36,400
basically mess with everything

512
00:18:36,400 --> 00:18:39,520
okay and in what way do they do that

513
00:18:39,520 --> 00:18:41,760
well they do it in different ways so you

514
00:18:41,760 --> 00:18:44,720
can combine different kinds of attacks

515
00:18:44,720 --> 00:18:47,280
different threat models

516
00:18:47,280 --> 00:18:48,400
in

517
00:18:48,400 --> 00:18:52,160
what i you know arbitrarily

518
00:18:52,320 --> 00:18:55,039
called three different ways sequential

519
00:18:55,039 --> 00:18:57,200
concurrent and symbiotic ways of

520
00:18:57,200 --> 00:18:59,679
combining different attack vectors

521
00:18:59,679 --> 00:19:00,960
different

522
00:19:00,960 --> 00:19:03,039
um threat models

523
00:19:03,039 --> 00:19:05,760
so and some of this is well known right

524
00:19:05,760 --> 00:19:08,640
so sequential combination of

525
00:19:08,640 --> 00:19:10,960
threat models attack factors is a

526
00:19:10,960 --> 00:19:12,559
well-known thing for instance what we

527
00:19:12,559 --> 00:19:15,200
can do is use

528
00:19:15,200 --> 00:19:18,480
one particular attack vector

529
00:19:18,480 --> 00:19:20,240
threat model such as

530
00:19:20,240 --> 00:19:22,480
the mds vulnerability which is one of

531
00:19:22,480 --> 00:19:24,400
these transient execution

532
00:19:24,400 --> 00:19:27,600
vulnerabilities to i don't know leak

533
00:19:27,600 --> 00:19:30,080
address space layout randomization

534
00:19:30,080 --> 00:19:32,000
okay and once we've leaked the

535
00:19:32,000 --> 00:19:34,160
address-based layout randomization we

536
00:19:34,160 --> 00:19:36,640
can actually continue with

537
00:19:36,640 --> 00:19:38,960
another type of attack factor

538
00:19:38,960 --> 00:19:41,679
which is for instance a traditional

539
00:19:41,679 --> 00:19:45,760
software exploit right so in a we have a

540
00:19:45,760 --> 00:19:47,520
buffer overflow vulnerability and now

541
00:19:47,520 --> 00:19:49,280
that we've broken address space layout

542
00:19:49,280 --> 00:19:52,640
randomization we can use the

543
00:19:52,640 --> 00:19:54,880
manipulation of a return address or code

544
00:19:54,880 --> 00:19:57,440
pointer in general to divert the control

545
00:19:57,440 --> 00:20:00,080
flow to some code that is already in the

546
00:20:00,080 --> 00:20:02,000
program and then we have an end to end

547
00:20:02,000 --> 00:20:03,039
exploit

548
00:20:03,039 --> 00:20:05,679
okay so we combine two

549
00:20:05,679 --> 00:20:07,840
very different threat models in a

550
00:20:07,840 --> 00:20:10,879
sequential manner

551
00:20:11,919 --> 00:20:14,400
another example is something that we did

552
00:20:14,400 --> 00:20:17,520
a couple of years ago where we use

553
00:20:17,520 --> 00:20:19,120
a threat model

554
00:20:19,120 --> 00:20:21,600
of the operating system where the

555
00:20:21,600 --> 00:20:24,960
operating system functionality does

556
00:20:24,960 --> 00:20:26,960
memory deduplication

557
00:20:26,960 --> 00:20:29,520
to reduce the overall

558
00:20:29,520 --> 00:20:31,840
memory footprint of the system so memory

559
00:20:31,840 --> 00:20:34,000
deduplication is a neat trick it

560
00:20:34,000 --> 00:20:35,440
basically means that

561
00:20:35,440 --> 00:20:36,880
this was

562
00:20:36,880 --> 00:20:39,520
on by default in windows 10 and windows

563
00:20:39,520 --> 00:20:42,080
8.1

564
00:20:42,080 --> 00:20:45,360
so what it would do is if two processes

565
00:20:45,360 --> 00:20:48,799
have exactly the same page in memory

566
00:20:48,799 --> 00:20:50,559
with the same content

567
00:20:50,559 --> 00:20:52,320
windows would you know periodically

568
00:20:52,320 --> 00:20:54,720
cycle through the memory and decide hey

569
00:20:54,720 --> 00:20:56,480
these are exactly the same there is no

570
00:20:56,480 --> 00:20:59,600
need for me to store this twice in

571
00:20:59,600 --> 00:21:02,320
physical memory so it would merge these

572
00:21:02,320 --> 00:21:04,559
pages stored only once in physical

573
00:21:04,559 --> 00:21:07,440
memory and give both of these processors

574
00:21:07,440 --> 00:21:09,840
a reference to that physical page

575
00:21:09,840 --> 00:21:12,400
so this page would be shared copy on

576
00:21:12,400 --> 00:21:13,840
right of course it has to be copy on

577
00:21:13,840 --> 00:21:15,600
right because if one of the processes

578
00:21:15,600 --> 00:21:17,760
decides to write to its page you don't

579
00:21:17,760 --> 00:21:20,240
want those changes to also affect the

580
00:21:20,240 --> 00:21:21,760
other processes it still has to be

581
00:21:21,760 --> 00:21:23,039
isolated

582
00:21:23,039 --> 00:21:26,159
okay that's a very good trick to reduce

583
00:21:26,159 --> 00:21:28,000
the memory footprint

584
00:21:28,000 --> 00:21:30,720
however it has unfortunate side effects

585
00:21:30,720 --> 00:21:33,360
namely that there is a potential

586
00:21:33,360 --> 00:21:35,440
information leak possibility there's a

587
00:21:35,440 --> 00:21:38,480
side channel right because

588
00:21:38,480 --> 00:21:40,559
a process an attacker process for

589
00:21:40,559 --> 00:21:44,960
instance is able to detect that one of

590
00:21:44,960 --> 00:21:46,480
these pages

591
00:21:46,480 --> 00:21:49,039
has been deduplicated okay and the

592
00:21:49,039 --> 00:21:50,880
reason why you can detect that is that

593
00:21:50,880 --> 00:21:52,240
it simply takes

594
00:21:52,240 --> 00:21:55,120
much longer to write to a copy on write

595
00:21:55,120 --> 00:21:58,480
page a page that has been deduplicated

596
00:21:58,480 --> 00:22:00,640
than it is to write to a regular page if

597
00:22:00,640 --> 00:22:02,159
you write a regular page you just write

598
00:22:02,159 --> 00:22:03,760
to the page and you're done

599
00:22:03,760 --> 00:22:05,919
but if you want to write to

600
00:22:05,919 --> 00:22:08,880
a page that is shared copy on write well

601
00:22:08,880 --> 00:22:10,559
you have to trap into the kernel the

602
00:22:10,559 --> 00:22:13,360
kernel has to say oh wait this is a copy

603
00:22:13,360 --> 00:22:16,240
on write page i need to change the page

604
00:22:16,240 --> 00:22:18,480
tables make a new copy of the page you

605
00:22:18,480 --> 00:22:20,720
know copy the data over then return to

606
00:22:20,720 --> 00:22:23,280
user space and then you can write to it

607
00:22:23,280 --> 00:22:26,080
okay that's a very lengthy procedure and

608
00:22:26,080 --> 00:22:27,840
you can measure this

609
00:22:27,840 --> 00:22:29,520
as a user process

610
00:22:29,520 --> 00:22:31,600
so then you know that your page has been

611
00:22:31,600 --> 00:22:33,840
deduplicated that it's there's another

612
00:22:33,840 --> 00:22:36,240
copy of that same page in another

613
00:22:36,240 --> 00:22:37,360
process

614
00:22:37,360 --> 00:22:39,520
right and that leaks in other words that

615
00:22:39,520 --> 00:22:42,400
leaks something about the content

616
00:22:42,400 --> 00:22:45,200
of the memory content of another process

617
00:22:45,200 --> 00:22:46,559
that's a side channel it's a very coarse

618
00:22:46,559 --> 00:22:49,120
grained side channel because it's a

619
00:22:49,120 --> 00:22:53,280
at the granularity of four kilobytes

620
00:22:53,280 --> 00:22:55,039
but you know what we've shown in the uh

621
00:22:55,039 --> 00:22:56,960
the attack in the dwest machine attack

622
00:22:56,960 --> 00:22:59,440
is that you can make this much more

623
00:22:59,440 --> 00:23:02,000
fine-grained and leak even high entropy

624
00:23:02,000 --> 00:23:03,520
data such as

625
00:23:03,520 --> 00:23:07,120
i don't know addresses of code or data

626
00:23:07,120 --> 00:23:09,440
okay so pointers in other words and you

627
00:23:09,440 --> 00:23:11,520
do that by making sure that you know

628
00:23:11,520 --> 00:23:13,679
much of the page is known and only a

629
00:23:13,679 --> 00:23:15,360
little bit of the the

630
00:23:15,360 --> 00:23:17,360
the information is missing and then you

631
00:23:17,360 --> 00:23:19,600
do guesses for those those pages and if

632
00:23:19,600 --> 00:23:21,919
you see it gets duplicated at some point

633
00:23:21,919 --> 00:23:24,240
you know hey that must have been a

634
00:23:24,240 --> 00:23:27,120
correct pointer now

635
00:23:27,120 --> 00:23:29,600
once you've broken address-based layout

636
00:23:29,600 --> 00:23:31,360
randomization because you now have

637
00:23:31,360 --> 00:23:33,679
pointers to code and pointers to data

638
00:23:33,679 --> 00:23:34,960
you've broken address space layout

639
00:23:34,960 --> 00:23:37,039
randomization you can combine that with

640
00:23:37,039 --> 00:23:39,520
traditional software exploitation

641
00:23:39,520 --> 00:23:41,200
different kind of

642
00:23:41,200 --> 00:23:43,440
threat model or in this particular case

643
00:23:43,440 --> 00:23:45,440
we've combined it with the rowhammer

644
00:23:45,440 --> 00:23:48,559
vulnerability so we've made sure that

645
00:23:48,559 --> 00:23:51,600
there is a fake javascript object

646
00:23:51,600 --> 00:23:53,279
somewhere in memory

647
00:23:53,279 --> 00:23:56,320
with pointers to a method right so that

648
00:23:56,320 --> 00:23:58,960
we've constructed as an attacker

649
00:23:58,960 --> 00:24:01,039
by by finding out where there are

650
00:24:01,039 --> 00:24:03,360
interesting code we now have broken

651
00:24:03,360 --> 00:24:04,880
address space layout organization so we

652
00:24:04,880 --> 00:24:07,440
know there's code and interesting data

653
00:24:07,440 --> 00:24:09,919
pointers and we make sure that there's a

654
00:24:09,919 --> 00:24:11,760
pointer that points to a regular

655
00:24:11,760 --> 00:24:14,559
javascript object

656
00:24:14,559 --> 00:24:17,039
mapped exactly at a location that's

657
00:24:17,039 --> 00:24:19,440
vulnerable to bit flips using this row

658
00:24:19,440 --> 00:24:23,200
hammer vulnerability so once you start

659
00:24:23,200 --> 00:24:25,760
hammering the the memory a bit will flip

660
00:24:25,760 --> 00:24:27,600
and that pointer to the legitimate

661
00:24:27,600 --> 00:24:29,600
javascript object will point somewhere

662
00:24:29,600 --> 00:24:32,080
else and we make sure that it points to

663
00:24:32,080 --> 00:24:34,720
our fake object so that we can execute

664
00:24:34,720 --> 00:24:36,880
whatever we want anyway details perhaps

665
00:24:36,880 --> 00:24:38,720
are not even that important but here we

666
00:24:38,720 --> 00:24:40,080
see that

667
00:24:40,080 --> 00:24:41,360
we combine

668
00:24:41,360 --> 00:24:42,960
operating system functionality some

669
00:24:42,960 --> 00:24:45,440
vulnerability there with

670
00:24:45,440 --> 00:24:47,840
a hardware vulnerability row hammer and

671
00:24:47,840 --> 00:24:50,000
we get an end-to-end exploit

672
00:24:50,000 --> 00:24:53,600
and that actually won one of the ponies

673
00:24:53,679 --> 00:24:56,400
another thing that we can do sometimes

674
00:24:56,400 --> 00:24:59,360
is not apply this sequentially because

675
00:24:59,360 --> 00:25:02,080
maybe we cannot do

676
00:25:02,080 --> 00:25:04,720
exactly what we want to do with one of

677
00:25:04,720 --> 00:25:06,400
the um

678
00:25:06,400 --> 00:25:08,000
the attack vectors with one of the the

679
00:25:08,000 --> 00:25:09,360
threat models

680
00:25:09,360 --> 00:25:10,880
so

681
00:25:10,880 --> 00:25:12,559
i don't have many maybe it's not even a

682
00:25:12,559 --> 00:25:14,400
very good category but this we have this

683
00:25:14,400 --> 00:25:17,120
uh this attack called tag bleed where we

684
00:25:17,120 --> 00:25:18,720
we also break

685
00:25:18,720 --> 00:25:20,080
kernel address space layout

686
00:25:20,080 --> 00:25:21,840
randomization

687
00:25:21,840 --> 00:25:22,799
using

688
00:25:22,799 --> 00:25:24,799
two tricks and the reason is that we

689
00:25:24,799 --> 00:25:25,760
cannot

690
00:25:25,760 --> 00:25:28,240
use a single trick to break kernel's

691
00:25:28,240 --> 00:25:30,880
address space layout randomization so

692
00:25:30,880 --> 00:25:34,000
what we do is we use

693
00:25:34,000 --> 00:25:36,000
tagged tlbs

694
00:25:36,000 --> 00:25:37,279
and

695
00:25:37,279 --> 00:25:40,080
the fact that the mmu

696
00:25:40,080 --> 00:25:43,919
and your um your regular code all use

697
00:25:43,919 --> 00:25:45,440
the same cache

698
00:25:45,440 --> 00:25:47,919
both of them have to be combined to

699
00:25:47,919 --> 00:25:50,880
break the full entropy of kernel address

700
00:25:50,880 --> 00:25:52,720
space layer randomization

701
00:25:52,720 --> 00:25:53,520
so

702
00:25:53,520 --> 00:25:55,039
maybe i should not

703
00:25:55,039 --> 00:25:57,279
explain this in detail but kernel

704
00:25:57,279 --> 00:25:59,919
address space

705
00:26:00,320 --> 00:26:02,720
layout randomization has nine bits of

706
00:26:02,720 --> 00:26:04,960
entropies and nine bits of uncertainty

707
00:26:04,960 --> 00:26:07,200
and with each of these tricks we can

708
00:26:07,200 --> 00:26:08,480
only

709
00:26:08,480 --> 00:26:11,760
leak a small number of those bits so the

710
00:26:11,760 --> 00:26:14,080
the tlb trick here

711
00:26:14,080 --> 00:26:16,880
um uses the fact that you have a tlb

712
00:26:16,880 --> 00:26:19,919
consisting of 128

713
00:26:19,919 --> 00:26:21,120
sets

714
00:26:21,120 --> 00:26:23,600
in the tlb so it's a 12-way set

715
00:26:23,600 --> 00:26:25,200
associative cache

716
00:26:25,200 --> 00:26:26,480
and that means

717
00:26:26,480 --> 00:26:29,600
and there are 128 sets and you can very

718
00:26:29,600 --> 00:26:31,520
easily determine

719
00:26:31,520 --> 00:26:32,720
in what

720
00:26:32,720 --> 00:26:35,520
set your particular virtual address is

721
00:26:35,520 --> 00:26:36,720
mapped

722
00:26:36,720 --> 00:26:37,760
because

723
00:26:37,760 --> 00:26:40,799
the access will be um faster if that is

724
00:26:40,799 --> 00:26:42,880
in the tlb so it's a similar trick to

725
00:26:42,880 --> 00:26:44,640
the cache side channels anyway

726
00:26:44,640 --> 00:26:47,200
once you have uh the set determined you

727
00:26:47,200 --> 00:26:48,080
have

728
00:26:48,080 --> 00:26:50,640
one of 128 in other words

729
00:26:50,640 --> 00:26:52,880
seven bits of entropy that you leak and

730
00:26:52,880 --> 00:26:55,279
then you just leak the remaining two

731
00:26:55,279 --> 00:26:58,000
bits with the other side channel now

732
00:26:58,000 --> 00:26:59,919
no need to uh to discuss this in detail

733
00:26:59,919 --> 00:27:01,760
but it's sort of this has to be applied

734
00:27:01,760 --> 00:27:04,159
concurrently uh to break kernel address

735
00:27:04,159 --> 00:27:05,600
space layer randomization and then you

736
00:27:05,600 --> 00:27:07,679
can combine it with a software exploit

737
00:27:07,679 --> 00:27:10,400
again to compromise the kernel

738
00:27:10,400 --> 00:27:13,039
okay so it's two things at once

739
00:27:13,039 --> 00:27:14,480
what is really interesting though and

740
00:27:14,480 --> 00:27:16,240
this is really what i want to talk about

741
00:27:16,240 --> 00:27:17,120
is the

742
00:27:17,120 --> 00:27:19,039
the last category it's an interesting

743
00:27:19,039 --> 00:27:21,520
category and

744
00:27:21,520 --> 00:27:23,760
it i'm not sure how many of these cases

745
00:27:23,760 --> 00:27:26,320
occur but i'd like to see people look

746
00:27:26,320 --> 00:27:28,640
for these things and it's what i refer

747
00:27:28,640 --> 00:27:31,520
to as symbiotic combination of of threat

748
00:27:31,520 --> 00:27:33,200
models of different

749
00:27:33,200 --> 00:27:36,000
you know ways of attacking a system

750
00:27:36,000 --> 00:27:39,440
and the key thing here is that

751
00:27:39,440 --> 00:27:43,440
by combining these two different threats

752
00:27:43,440 --> 00:27:46,000
you make both of them stronger

753
00:27:46,000 --> 00:27:48,720
right so by combining in this case

754
00:27:48,720 --> 00:27:51,279
speculative execution attacks with

755
00:27:51,279 --> 00:27:53,840
traditional software exploitation

756
00:27:53,840 --> 00:27:56,080
both of them become better so they

757
00:27:56,080 --> 00:27:58,240
reinforce each other

758
00:27:58,240 --> 00:27:59,520
and that is

759
00:27:59,520 --> 00:28:01,919
unusual right so the the combination of

760
00:28:01,919 --> 00:28:05,440
the two is greater than the sum of its

761
00:28:05,440 --> 00:28:06,880
parts

762
00:28:06,880 --> 00:28:09,440
okay and if you want to know the details

763
00:28:09,440 --> 00:28:10,960
about this attack you know maybe you

764
00:28:10,960 --> 00:28:12,880
should look at the the paper the ccs

765
00:28:12,880 --> 00:28:15,279
paper this is also one that that won a

766
00:28:15,279 --> 00:28:18,960
pony award this year

767
00:28:18,960 --> 00:28:20,960
so let's have a look what i said is

768
00:28:20,960 --> 00:28:23,360
we're going to oh and i should give

769
00:28:23,360 --> 00:28:25,520
credit to the uh the phd student who

770
00:28:25,520 --> 00:28:27,200
actually did all the hard work which is

771
00:28:27,200 --> 00:28:28,640
anna's got us

772
00:28:28,640 --> 00:28:31,440
who's still to submit his phd thesis but

773
00:28:31,440 --> 00:28:34,159
uh but this is fantastic work at least

774
00:28:34,159 --> 00:28:35,679
all right um

775
00:28:35,679 --> 00:28:38,240
so so i said that we're going to combine

776
00:28:38,240 --> 00:28:40,480
two completely different thread models

777
00:28:40,480 --> 00:28:42,080
and one of the threat models is the

778
00:28:42,080 --> 00:28:44,240
threat model of speculative execution

779
00:28:44,240 --> 00:28:46,240
attacks so spectre attacks which burst

780
00:28:46,240 --> 00:28:48,960
onto the scene in 2018 i'm sure you all

781
00:28:48,960 --> 00:28:50,480
remember because it was all over the

782
00:28:50,480 --> 00:28:52,399
news there was a lot of commotion about

783
00:28:52,399 --> 00:28:55,120
this and there was even you know uh

784
00:28:55,120 --> 00:28:57,039
logos for these these vulnerabilities

785
00:28:57,039 --> 00:28:59,200
spectre and meltdown which i never

786
00:28:59,200 --> 00:29:00,799
understood why there had to be logos for

787
00:29:00,799 --> 00:29:03,360
vulnerabilities but it's there right so

788
00:29:03,360 --> 00:29:05,520
and it's a serious issue

789
00:29:05,520 --> 00:29:07,600
um and it's an issue that still to this

790
00:29:07,600 --> 00:29:10,559
day has not been fully solved right it's

791
00:29:10,559 --> 00:29:13,840
a complex vulnerability to solve

792
00:29:13,840 --> 00:29:16,159
okay and there are many different

793
00:29:16,159 --> 00:29:18,559
variants of this spectre attack of this

794
00:29:18,559 --> 00:29:20,559
speculative execution attacks but only

795
00:29:20,559 --> 00:29:22,480
two of them are relevant for the talk

796
00:29:22,480 --> 00:29:24,000
today so i'll talk about two of them and

797
00:29:24,000 --> 00:29:26,559
one of them is essentially based on what

798
00:29:26,559 --> 00:29:28,720
you see on the slide here there's an

799
00:29:28,720 --> 00:29:30,640
indirect branch a jump in this

800
00:29:30,640 --> 00:29:33,520
particular case to an address that needs

801
00:29:33,520 --> 00:29:35,840
to be calculated first

802
00:29:35,840 --> 00:29:38,640
so the cpu has to calculate the address

803
00:29:38,640 --> 00:29:41,039
and then you jump to that now it may be

804
00:29:41,039 --> 00:29:43,200
the case that it takes a bit of time to

805
00:29:43,200 --> 00:29:45,520
calculate the address right so the cpu

806
00:29:45,520 --> 00:29:47,600
doesn't really know

807
00:29:47,600 --> 00:29:48,480
what

808
00:29:48,480 --> 00:29:50,799
the target address will be where it

809
00:29:50,799 --> 00:29:53,200
should continue processing

810
00:29:53,200 --> 00:29:55,279
and

811
00:29:55,279 --> 00:29:57,520
it has all of these execution units

812
00:29:57,520 --> 00:29:59,840
ready to go but it doesn't know where to

813
00:29:59,840 --> 00:30:02,559
how where to continue so rather than

814
00:30:02,559 --> 00:30:04,000
waiting which is of course super

815
00:30:04,000 --> 00:30:06,720
inefficient it decides to

816
00:30:06,720 --> 00:30:09,120
you know speculate it

817
00:30:09,120 --> 00:30:11,520
tries to predict where to continue

818
00:30:11,520 --> 00:30:12,960
execution

819
00:30:12,960 --> 00:30:15,440
okay and it does that by looking at the

820
00:30:15,440 --> 00:30:18,480
uh the past and say that the last 100

821
00:30:18,480 --> 00:30:21,360
times the um the indirect brands

822
00:30:21,360 --> 00:30:24,320
targeted some address axe well you know

823
00:30:24,320 --> 00:30:26,399
the cpu is going to say it's probably

824
00:30:26,399 --> 00:30:28,880
going to target address acts again let

825
00:30:28,880 --> 00:30:31,440
me continue speculatively let me

826
00:30:31,440 --> 00:30:33,919
continue at this address and execute

827
00:30:33,919 --> 00:30:36,480
instructions speculatively add that

828
00:30:36,480 --> 00:30:37,600
address

829
00:30:37,600 --> 00:30:40,880
okay and if i was right if the the the

830
00:30:40,880 --> 00:30:42,880
guess or the prediction was right

831
00:30:42,880 --> 00:30:45,279
fantastic we have all of this

832
00:30:45,279 --> 00:30:46,960
computation of these instructions that

833
00:30:46,960 --> 00:30:48,720
we've already executed and now we can

834
00:30:48,720 --> 00:30:51,039
use the results immediately right so we

835
00:30:51,039 --> 00:30:53,279
can commit the result

836
00:30:53,279 --> 00:30:55,440
if i was wrong which is of course

837
00:30:55,440 --> 00:30:58,159
possible then i have to revert all of

838
00:30:58,159 --> 00:31:00,960
this and i have to undo all of the

839
00:31:00,960 --> 00:31:03,519
architecturally visible effects but

840
00:31:03,519 --> 00:31:05,440
other than that there's no harm done

841
00:31:05,440 --> 00:31:08,320
because i haven't committed these

842
00:31:08,320 --> 00:31:10,720
results yet i just executed them kept

843
00:31:10,720 --> 00:31:13,440
them apart and then you know waited for

844
00:31:13,440 --> 00:31:16,720
this brand's outcome to be resolved

845
00:31:16,720 --> 00:31:20,320
okay so that's backload of execution and

846
00:31:20,320 --> 00:31:21,200
it's

847
00:31:21,200 --> 00:31:23,200
responsible for a lot of the performance

848
00:31:23,200 --> 00:31:25,840
of modern cpu so it's really important

849
00:31:25,840 --> 00:31:28,480
okay another interesting aspect of this

850
00:31:28,480 --> 00:31:31,039
is that the attacker can influence this

851
00:31:31,039 --> 00:31:32,320
prediction certainly in the older

852
00:31:32,320 --> 00:31:34,799
processors you could from user space

853
00:31:34,799 --> 00:31:36,799
simply say

854
00:31:36,799 --> 00:31:38,000
let me

855
00:31:38,000 --> 00:31:40,559
do an indirect branch myself

856
00:31:40,559 --> 00:31:42,799
and you know execute this for a thousand

857
00:31:42,799 --> 00:31:44,960
times and make it jump to some target

858
00:31:44,960 --> 00:31:46,320
address axe

859
00:31:46,320 --> 00:31:48,159
right and then

860
00:31:48,159 --> 00:31:50,080
call the kernel do something in the

861
00:31:50,080 --> 00:31:51,679
kernel where there's also an indirect

862
00:31:51,679 --> 00:31:52,640
branch

863
00:31:52,640 --> 00:31:56,000
that maps onto the same slot in the

864
00:31:56,000 --> 00:31:58,480
branch predictor data structure so the

865
00:31:58,480 --> 00:32:00,960
the buffers that we have there and if it

866
00:32:00,960 --> 00:32:04,399
if it's in the same slot it will predict

867
00:32:04,399 --> 00:32:07,200
on the basis of what i trained the

868
00:32:07,200 --> 00:32:10,399
predictor to be the right answer so the

869
00:32:10,399 --> 00:32:12,480
user process

870
00:32:12,480 --> 00:32:14,480
trained the predictor to jump to some

871
00:32:14,480 --> 00:32:17,120
address x and then you go to the kernel

872
00:32:17,120 --> 00:32:19,279
and the colonel will also think well

873
00:32:19,279 --> 00:32:21,120
it's probably going to be that target

874
00:32:21,120 --> 00:32:22,159
address

875
00:32:22,159 --> 00:32:24,720
which in itself would not be a problem

876
00:32:24,720 --> 00:32:26,559
right because it's only executing this

877
00:32:26,559 --> 00:32:29,200
speculatively and it's undoing all of

878
00:32:29,200 --> 00:32:31,279
these

879
00:32:31,279 --> 00:32:34,640
architecturally visible effects

880
00:32:34,640 --> 00:32:35,679
okay

881
00:32:35,679 --> 00:32:37,600
now this is one of the

882
00:32:37,600 --> 00:32:40,240
spectre vulnerabilities so it's the one

883
00:32:40,240 --> 00:32:42,720
that we see here it's also you know

884
00:32:42,720 --> 00:32:45,519
popularly known as spectre variant 2 or

885
00:32:45,519 --> 00:32:47,519
brands target injection

886
00:32:47,519 --> 00:32:49,279
and it can be a jump or it can be a call

887
00:32:49,279 --> 00:32:51,120
doesn't actually matter the key thing

888
00:32:51,120 --> 00:32:53,919
here is that we cause a misprediction

889
00:32:53,919 --> 00:32:56,159
right this is what we do we train the

890
00:32:56,159 --> 00:32:58,559
predictor and we cause a misprediction

891
00:32:58,559 --> 00:33:01,360
and then we make the kernel jump to

892
00:33:01,360 --> 00:33:03,440
a trained target

893
00:33:03,440 --> 00:33:04,799
okay

894
00:33:04,799 --> 00:33:07,600
another variant of spectre is known as

895
00:33:07,600 --> 00:33:11,279
spectre variant 1 or bounce check by

896
00:33:11,279 --> 00:33:12,640
bypass

897
00:33:12,640 --> 00:33:14,720
and i want to mention this

898
00:33:14,720 --> 00:33:16,720
first and then we'll talk about how we

899
00:33:16,720 --> 00:33:18,960
can even use that you know the

900
00:33:18,960 --> 00:33:21,200
speculatively executed instructions that

901
00:33:21,200 --> 00:33:24,799
are going to be thrown away anyway okay

902
00:33:24,799 --> 00:33:27,440
so bounce check bypass is doing exactly

903
00:33:27,440 --> 00:33:29,120
that there is a little bit of code

904
00:33:29,120 --> 00:33:31,440
that's trying to be secure so it's doing

905
00:33:31,440 --> 00:33:32,880
a bounce check

906
00:33:32,880 --> 00:33:36,880
it makes sure that some untrusted input

907
00:33:36,880 --> 00:33:40,399
here doesn't access an array out of

908
00:33:40,399 --> 00:33:41,679
bounds

909
00:33:41,679 --> 00:33:43,919
okay so it checks whether this untrusted

910
00:33:43,919 --> 00:33:47,279
input is within the array bounds and

911
00:33:47,279 --> 00:33:48,960
only then

912
00:33:48,960 --> 00:33:50,640
it will do an

913
00:33:50,640 --> 00:33:54,399
um access of an array element with that

914
00:33:54,399 --> 00:33:57,200
index okay

915
00:33:57,200 --> 00:33:58,159
and

916
00:33:58,159 --> 00:34:00,799
it stores that in a variable data which

917
00:34:00,799 --> 00:34:03,360
it then uses in turn as an index in a

918
00:34:03,360 --> 00:34:05,600
second array

919
00:34:05,600 --> 00:34:08,399
now the key thing here is that the cpu

920
00:34:08,399 --> 00:34:11,839
doesn't just predict the outcome of this

921
00:34:11,839 --> 00:34:14,960
indirect branch it will also

922
00:34:14,960 --> 00:34:18,719
speculate predict the outcome of a

923
00:34:18,719 --> 00:34:20,960
condition right a conditional statement

924
00:34:20,960 --> 00:34:22,719
a conditional instruction

925
00:34:22,719 --> 00:34:23,599
so

926
00:34:23,599 --> 00:34:25,839
it will try to predict

927
00:34:25,839 --> 00:34:29,040
what the most likely outcome of this

928
00:34:29,040 --> 00:34:30,639
condition will be

929
00:34:30,639 --> 00:34:33,199
and if the last 100 times

930
00:34:33,199 --> 00:34:36,800
the if condition yielded true it's going

931
00:34:36,800 --> 00:34:39,679
to assume that the 101st time is going

932
00:34:39,679 --> 00:34:42,159
to be exactly the same and it will start

933
00:34:42,159 --> 00:34:45,040
executing these instructions

934
00:34:45,040 --> 00:34:46,800
speculatively

935
00:34:46,800 --> 00:34:48,879
but it may get it wrong right it may be

936
00:34:48,879 --> 00:34:51,839
that the 101st time you provided it with

937
00:34:51,839 --> 00:34:54,879
an index that was way out of bounds and

938
00:34:54,879 --> 00:34:56,320
in that case

939
00:34:56,320 --> 00:34:57,280
the

940
00:34:57,280 --> 00:35:00,160
program will access some memory

941
00:35:00,160 --> 00:35:02,000
outside of the array boundaries some

942
00:35:02,000 --> 00:35:04,400
memory that you shouldn't be allowed to

943
00:35:04,400 --> 00:35:05,520
access

944
00:35:05,520 --> 00:35:08,880
okay um and of course this is you know

945
00:35:08,880 --> 00:35:11,119
only executed speculatively so the

946
00:35:11,119 --> 00:35:12,720
architecturally visible effects will be

947
00:35:12,720 --> 00:35:14,320
thrown away

948
00:35:14,320 --> 00:35:17,599
but there is a trace so that does leave

949
00:35:17,599 --> 00:35:20,400
a trace at the micro architectural level

950
00:35:20,400 --> 00:35:22,560
so at the level

951
00:35:22,560 --> 00:35:24,880
that implements the architecture

952
00:35:24,880 --> 00:35:26,480
and to illustrate that

953
00:35:26,480 --> 00:35:29,200
let us assume that

954
00:35:29,200 --> 00:35:31,200
this only for simplicity is not

955
00:35:31,200 --> 00:35:32,800
fundamental let us assume that this

956
00:35:32,800 --> 00:35:34,960
second array array 2

957
00:35:34,960 --> 00:35:37,839
is shared between the attacker and the

958
00:35:37,839 --> 00:35:40,320
victim say the user process and the

959
00:35:40,320 --> 00:35:41,440
kernel

960
00:35:41,440 --> 00:35:43,119
okay

961
00:35:43,119 --> 00:35:45,760
and like i said this is not fundamental

962
00:35:45,760 --> 00:35:48,079
and the attacker is going to make sure

963
00:35:48,079 --> 00:35:50,240
that all of this data all of the

964
00:35:50,240 --> 00:35:52,320
elements of this array

965
00:35:52,320 --> 00:35:54,240
are removed from the cache they're

966
00:35:54,240 --> 00:35:55,599
flushed from the cache nothing is in the

967
00:35:55,599 --> 00:35:57,440
cast by you know and it's this is easy

968
00:35:57,440 --> 00:35:59,119
to do by just accessing lots of other

969
00:35:59,119 --> 00:36:01,200
memory you make sure that you know none

970
00:36:01,200 --> 00:36:03,040
of these elements are in the cache this

971
00:36:03,040 --> 00:36:04,000
is all

972
00:36:04,000 --> 00:36:06,160
not in the cache

973
00:36:06,160 --> 00:36:07,920
okay

974
00:36:07,920 --> 00:36:09,520
and then

975
00:36:09,520 --> 00:36:13,280
you train the predictor to mispredict so

976
00:36:13,280 --> 00:36:16,240
you execute to do the system call many

977
00:36:16,240 --> 00:36:19,040
many many times uh making sure that the

978
00:36:19,040 --> 00:36:21,520
uh the victims thinks that you know it's

979
00:36:21,520 --> 00:36:23,839
probably going to be true

980
00:36:23,839 --> 00:36:26,480
um the next time so you're a thousand

981
00:36:26,480 --> 00:36:29,119
times you execute this with an index at

982
00:36:29,119 --> 00:36:32,000
untrusted index that is inbounds so the

983
00:36:32,000 --> 00:36:34,000
cpu is going to think well next time

984
00:36:34,000 --> 00:36:35,440
it's going to be in bounce again but

985
00:36:35,440 --> 00:36:37,200
then of course it's not you provide it

986
00:36:37,200 --> 00:36:40,400
with an index that is out of bounds okay

987
00:36:40,400 --> 00:36:42,720
what will happen is that

988
00:36:42,720 --> 00:36:45,760
speculatively the code here will be

989
00:36:45,760 --> 00:36:48,480
executed now why is this relevant well

990
00:36:48,480 --> 00:36:50,160
if the attacker

991
00:36:50,160 --> 00:36:53,680
were to access any of the array elements

992
00:36:53,680 --> 00:36:54,960
initially

993
00:36:54,960 --> 00:36:56,960
all of them will be slow right because

994
00:36:56,960 --> 00:36:58,480
they're not in the cache we flush them

995
00:36:58,480 --> 00:37:00,240
from the cache so they have to be fats

996
00:37:00,240 --> 00:37:02,240
from main memory it takes forever

997
00:37:02,240 --> 00:37:04,560
and this is measurable okay

998
00:37:04,560 --> 00:37:06,880
but now when we execute these

999
00:37:06,880 --> 00:37:09,520
instructions speculatively

1000
00:37:09,520 --> 00:37:11,359
it will access

1001
00:37:11,359 --> 00:37:14,640
this element with an out of bounds index

1002
00:37:14,640 --> 00:37:15,599
and

1003
00:37:15,599 --> 00:37:18,560
it will load some

1004
00:37:18,560 --> 00:37:20,800
data that we're not supposed to access

1005
00:37:20,800 --> 00:37:23,680
speculatively into this this variable

1006
00:37:23,680 --> 00:37:25,359
and then use that as

1007
00:37:25,359 --> 00:37:28,000
an index in a secondary so

1008
00:37:28,000 --> 00:37:30,640
let's say oh so all of them are slow

1009
00:37:30,640 --> 00:37:33,920
so let's say that it finds some secret

1010
00:37:33,920 --> 00:37:34,880
data

1011
00:37:34,880 --> 00:37:37,839
that has the value two

1012
00:37:37,839 --> 00:37:40,800
okay so you access some

1013
00:37:40,800 --> 00:37:42,320
byte in memory

1014
00:37:42,320 --> 00:37:44,160
and it turns out that the value was two

1015
00:37:44,160 --> 00:37:46,160
and now we use this

1016
00:37:46,160 --> 00:37:47,440
data

1017
00:37:47,440 --> 00:37:51,040
this value of two as an index in a

1018
00:37:51,040 --> 00:37:52,800
second array that was shared with the

1019
00:37:52,800 --> 00:37:55,200
attacker what will happen well not much

1020
00:37:55,200 --> 00:37:57,119
right because all of this code that was

1021
00:37:57,119 --> 00:37:58,720
executed speculatively will be thrown

1022
00:37:58,720 --> 00:38:00,160
away but

1023
00:38:00,160 --> 00:38:01,119
the

1024
00:38:01,119 --> 00:38:04,160
memory access did take place so we did

1025
00:38:04,160 --> 00:38:05,920
have an array

1026
00:38:05,920 --> 00:38:07,520
to access

1027
00:38:07,520 --> 00:38:10,320
with the index two and that means that

1028
00:38:10,320 --> 00:38:13,200
that array element is loaded into the

1029
00:38:13,200 --> 00:38:15,599
cache okay

1030
00:38:15,599 --> 00:38:17,359
and that means that if the attacker now

1031
00:38:17,359 --> 00:38:20,160
starts accessing all the elements in the

1032
00:38:20,160 --> 00:38:23,040
array the attacker will find that all of

1033
00:38:23,040 --> 00:38:25,280
them are you know the first is slow and

1034
00:38:25,280 --> 00:38:26,960
the second is slow

1035
00:38:26,960 --> 00:38:30,640
and the third one right at index two

1036
00:38:30,640 --> 00:38:32,480
will be fast because this is in the

1037
00:38:32,480 --> 00:38:34,720
cache okay all the others will be slow

1038
00:38:34,720 --> 00:38:35,599
again

1039
00:38:35,599 --> 00:38:36,720
in other words

1040
00:38:36,720 --> 00:38:39,359
by looking at which element in the array

1041
00:38:39,359 --> 00:38:42,480
which index is fast the attacker is now

1042
00:38:42,480 --> 00:38:46,160
able to conclude that the value that was

1043
00:38:46,160 --> 00:38:47,599
read

1044
00:38:47,599 --> 00:38:49,920
at this

1045
00:38:49,920 --> 00:38:51,920
um memory location

1046
00:38:51,920 --> 00:38:55,200
must have been the value two okay so in

1047
00:38:55,200 --> 00:38:57,839
an indirect way you still are able to

1048
00:38:57,839 --> 00:38:59,760
deduce what the

1049
00:38:59,760 --> 00:39:02,079
code was doing during speculative

1050
00:39:02,079 --> 00:39:04,480
execution the value that it read during

1051
00:39:04,480 --> 00:39:06,720
speculative execution

1052
00:39:06,720 --> 00:39:08,800
okay is that clear

1053
00:39:08,800 --> 00:39:11,119
speculative execution good okay so

1054
00:39:11,119 --> 00:39:12,720
unfortunately you know it's really hard

1055
00:39:12,720 --> 00:39:14,480
to exploit this nowadays and there's all

1056
00:39:14,480 --> 00:39:16,560
sorts of mitigations you have uh

1057
00:39:16,560 --> 00:39:18,400
software mitigations in the form of rat

1058
00:39:18,400 --> 00:39:19,760
pulling for instance and you have

1059
00:39:19,760 --> 00:39:21,359
hardware mitigations and all sorts of

1060
00:39:21,359 --> 00:39:24,079
other things and because of this

1061
00:39:24,079 --> 00:39:25,440
spectre

1062
00:39:25,440 --> 00:39:28,560
attacks are nowadays super difficult

1063
00:39:28,560 --> 00:39:29,359
okay

1064
00:39:29,359 --> 00:39:32,400
um what about the other uh

1065
00:39:32,400 --> 00:39:35,040
uh threat model so the regular software

1066
00:39:35,040 --> 00:39:38,000
exploitation well this is all you know

1067
00:39:38,000 --> 00:39:39,680
really well known we've been doing this

1068
00:39:39,680 --> 00:39:41,760
since the 1980s right so buffer

1069
00:39:41,760 --> 00:39:43,680
overflows and similar attacks have been

1070
00:39:43,680 --> 00:39:46,320
around since the 1980s we

1071
00:39:46,320 --> 00:39:48,640
have some code perhaps that doesn't

1072
00:39:48,640 --> 00:39:50,880
check whether the bytes that are you

1073
00:39:50,880 --> 00:39:53,280
know arriving from an untrusted source

1074
00:39:53,280 --> 00:39:55,200
fit in the memory that's allocated for

1075
00:39:55,200 --> 00:39:57,119
it and because of that

1076
00:39:57,119 --> 00:40:00,079
the program overrides some crucial value

1077
00:40:00,079 --> 00:40:02,079
a code pointer say a return address or a

1078
00:40:02,079 --> 00:40:03,520
function pointer

1079
00:40:03,520 --> 00:40:06,160
and that means that the attacker is able

1080
00:40:06,160 --> 00:40:07,839
to control where

1081
00:40:07,839 --> 00:40:08,560
the

1082
00:40:08,560 --> 00:40:11,040
program will continue execution right so

1083
00:40:11,040 --> 00:40:13,119
you can make this jump to some other

1084
00:40:13,119 --> 00:40:14,319
address

1085
00:40:14,319 --> 00:40:16,560
now

1086
00:40:16,880 --> 00:40:20,319
unfortunately here also it is difficult

1087
00:40:20,319 --> 00:40:22,480
to exploit this certainly for targets

1088
00:40:22,480 --> 00:40:24,560
such as the linux kernel

1089
00:40:24,560 --> 00:40:26,480
and the reason for that is that you

1090
00:40:26,480 --> 00:40:28,880
cannot

1091
00:40:28,880 --> 00:40:31,200
make the program jump to

1092
00:40:31,200 --> 00:40:34,319
the kernel jump to for instance your own

1093
00:40:34,319 --> 00:40:36,240
injected code code injection no longer

1094
00:40:36,240 --> 00:40:38,480
works because of the anax bit or

1095
00:40:38,480 --> 00:40:40,160
you know whatever terminology you want

1096
00:40:40,160 --> 00:40:42,079
to use there data execution prevention

1097
00:40:42,079 --> 00:40:44,560
or write exclusive or read anyway you

1098
00:40:44,560 --> 00:40:45,839
cannot

1099
00:40:45,839 --> 00:40:48,800
jump to code that you've to

1100
00:40:48,800 --> 00:40:50,640
data that you've written yourself okay

1101
00:40:50,640 --> 00:40:53,839
so code injection is no longer possible

1102
00:40:53,839 --> 00:40:56,079
so what you have to do you're forced to

1103
00:40:56,079 --> 00:40:59,280
reuse code that is already present in

1104
00:40:59,280 --> 00:41:01,520
this case code is already in the linux

1105
00:41:01,520 --> 00:41:03,119
kernel you have to reuse that you have

1106
00:41:03,119 --> 00:41:05,839
to divert the control flow to the um the

1107
00:41:05,839 --> 00:41:07,760
code that is already there it's a code

1108
00:41:07,760 --> 00:41:10,400
reuse attack such as return oriented

1109
00:41:10,400 --> 00:41:11,680
programming

1110
00:41:11,680 --> 00:41:13,680
okay but that's also difficult because

1111
00:41:13,680 --> 00:41:16,240
of randomization you don't know where

1112
00:41:16,240 --> 00:41:17,920
these code snippets that you would like

1113
00:41:17,920 --> 00:41:20,319
to have executed to do your malicious

1114
00:41:20,319 --> 00:41:22,800
things where they reside because the

1115
00:41:22,800 --> 00:41:25,040
memory layout is completely randomized

1116
00:41:25,040 --> 00:41:27,440
and if you're unlucky it's even using

1117
00:41:27,440 --> 00:41:29,839
fine-grained randomization so for

1118
00:41:29,839 --> 00:41:31,280
instance if you're attacking something

1119
00:41:31,280 --> 00:41:33,040
over the network this would be really

1120
00:41:33,040 --> 00:41:35,440
difficult to determine

1121
00:41:35,440 --> 00:41:36,880
okay

1122
00:41:36,880 --> 00:41:39,440
and moreover if you're trying to do this

1123
00:41:39,440 --> 00:41:41,839
on the kernel if you guess wrong it's

1124
00:41:41,839 --> 00:41:43,839
game over right so it's it will actually

1125
00:41:43,839 --> 00:41:45,680
crash your system

1126
00:41:45,680 --> 00:41:48,240
so in other words blind attacks on the

1127
00:41:48,240 --> 00:41:51,520
kernel are exceedingly hard

1128
00:41:51,520 --> 00:41:54,079
blind attacks are possible on some other

1129
00:41:54,079 --> 00:41:56,560
types of software and it's really cool

1130
00:41:56,560 --> 00:41:57,359
work

1131
00:41:57,359 --> 00:41:59,359
that was uh pioneered by uh by andrea

1132
00:41:59,359 --> 00:42:01,839
bitau and some some of his colleagues

1133
00:42:01,839 --> 00:42:04,000
and i just want to very briefly mention

1134
00:42:04,000 --> 00:42:04,880
this

1135
00:42:04,880 --> 00:42:07,040
because i think it's it's super cool

1136
00:42:07,040 --> 00:42:09,119
the idea here is that you can attack

1137
00:42:09,119 --> 00:42:11,599
software with you know arbitrary

1138
00:42:11,599 --> 00:42:14,000
randomization you may not even

1139
00:42:14,000 --> 00:42:17,040
have the uh the the source you may not

1140
00:42:17,040 --> 00:42:19,119
even have the binary you may not know

1141
00:42:19,119 --> 00:42:20,880
the binary right you have no idea this

1142
00:42:20,880 --> 00:42:22,480
may be completely

1143
00:42:22,480 --> 00:42:25,599
unknown code with unknown randomization

1144
00:42:25,599 --> 00:42:28,480
and what they do is they um attack this

1145
00:42:28,480 --> 00:42:31,280
the assumption is that they find some

1146
00:42:31,280 --> 00:42:34,960
memory corruption that allows them to

1147
00:42:34,960 --> 00:42:37,920
corrupt a function pointer or a return

1148
00:42:37,920 --> 00:42:39,119
address

1149
00:42:39,119 --> 00:42:40,880
or actually the paper talks about the

1150
00:42:40,880 --> 00:42:43,839
return address and so they they can jump

1151
00:42:43,839 --> 00:42:47,520
to arbitrary locations now almost

1152
00:42:47,520 --> 00:42:49,760
always this will be

1153
00:42:49,760 --> 00:42:52,400
an invalid location right some memory

1154
00:42:52,400 --> 00:42:54,400
that is not mapped or is that is not

1155
00:42:54,400 --> 00:42:57,599
executable and it will lead to a crash

1156
00:42:57,599 --> 00:42:59,760
okay but they keep trying they keep

1157
00:42:59,760 --> 00:43:02,480
trying until at some point they get

1158
00:43:02,480 --> 00:43:05,200
in that sense lucky that it's not a

1159
00:43:05,200 --> 00:43:06,240
crash

1160
00:43:06,240 --> 00:43:07,760
but it's a hang

1161
00:43:07,760 --> 00:43:09,839
and you can distinguish between the two

1162
00:43:09,839 --> 00:43:11,680
if you're talking about say a remote web

1163
00:43:11,680 --> 00:43:12,560
server

1164
00:43:12,560 --> 00:43:14,240
by seeing your

1165
00:43:14,240 --> 00:43:16,720
if it's a crash your connection will

1166
00:43:16,720 --> 00:43:18,880
close and if it's a hang your connection

1167
00:43:18,880 --> 00:43:22,160
will hang okay and just these two

1168
00:43:22,160 --> 00:43:25,040
effects a crash versus a hang

1169
00:43:25,040 --> 00:43:28,880
is sufficient to infer something about

1170
00:43:28,880 --> 00:43:32,160
code that you're executing on the remote

1171
00:43:32,160 --> 00:43:36,160
side so they can determine for instance

1172
00:43:36,160 --> 00:43:38,000
that the code that

1173
00:43:38,000 --> 00:43:41,119
was executing on the server side was

1174
00:43:41,119 --> 00:43:42,640
doing a lot of

1175
00:43:42,640 --> 00:43:44,720
pops from the stack a lot of pop

1176
00:43:44,720 --> 00:43:47,040
instructions from the stack

1177
00:43:47,040 --> 00:43:49,040
okay and that is useful because you can

1178
00:43:49,040 --> 00:43:51,040
construct gadgets for a code reuse

1179
00:43:51,040 --> 00:43:53,200
attack out of that okay

1180
00:43:53,200 --> 00:43:55,119
um i don't want to

1181
00:43:55,119 --> 00:43:57,040
talk about the details if you want to if

1182
00:43:57,040 --> 00:43:58,480
you if you're curious about this talk to

1183
00:43:58,480 --> 00:43:59,680
me afterwards

1184
00:43:59,680 --> 00:44:02,319
um but it's super cool except that it

1185
00:44:02,319 --> 00:44:04,560
works only on a very limited set of

1186
00:44:04,560 --> 00:44:06,079
software namely the software that is

1187
00:44:06,079 --> 00:44:08,079
completely crash resistant such as

1188
00:44:08,079 --> 00:44:10,319
certain web servers that have child

1189
00:44:10,319 --> 00:44:12,000
processors and if the child process

1190
00:44:12,000 --> 00:44:14,480
crashes it will automatically fork a new

1191
00:44:14,480 --> 00:44:16,480
child process with exactly the same

1192
00:44:16,480 --> 00:44:18,640
memory layout so you can try again so

1193
00:44:18,640 --> 00:44:20,560
you can actually afford to crash this

1194
00:44:20,560 --> 00:44:23,359
web server the the processors in the web

1195
00:44:23,359 --> 00:44:27,520
server thousands of times okay now

1196
00:44:27,520 --> 00:44:30,319
that is true for very few processes for

1197
00:44:30,319 --> 00:44:32,000
very few programs out there in the real

1198
00:44:32,000 --> 00:44:34,079
world and moreover you're also banking

1199
00:44:34,079 --> 00:44:36,160
on the fact that nobody's actually

1200
00:44:36,160 --> 00:44:38,160
checking the web servers to see you know

1201
00:44:38,160 --> 00:44:40,160
a thousand crashes that's a bit much

1202
00:44:40,160 --> 00:44:43,040
maybe we should investigate right and it

1203
00:44:43,040 --> 00:44:45,280
finally it doesn't apply to really high

1204
00:44:45,280 --> 00:44:48,240
value targets such as the linux kernel

1205
00:44:48,240 --> 00:44:50,720
you cannot do blind attacks like this on

1206
00:44:50,720 --> 00:44:52,880
the linux kernel

1207
00:44:52,880 --> 00:44:55,920
so what happens if we combine these two

1208
00:44:55,920 --> 00:44:58,400
threat models so the threat model of

1209
00:44:58,400 --> 00:45:00,640
regular software exploitation with that

1210
00:45:00,640 --> 00:45:02,960
of speculative execution

1211
00:45:02,960 --> 00:45:05,280
well now

1212
00:45:05,280 --> 00:45:07,359
we show that we can do these blind

1213
00:45:07,359 --> 00:45:08,560
attacks

1214
00:45:08,560 --> 00:45:10,480
even on high value targets such as the

1215
00:45:10,480 --> 00:45:14,079
linux kernel that cannot afford to crash

1216
00:45:14,079 --> 00:45:17,200
okay the idea is as follows we use a

1217
00:45:17,200 --> 00:45:19,200
regular software bug for instance a

1218
00:45:19,200 --> 00:45:20,640
buffer overflow

1219
00:45:20,640 --> 00:45:23,280
to corrupt a function pointer a code

1220
00:45:23,280 --> 00:45:24,720
pointer in general but a function

1221
00:45:24,720 --> 00:45:26,800
pointer

1222
00:45:26,800 --> 00:45:29,839
which will be used as a jump target

1223
00:45:29,839 --> 00:45:33,280
okay so an indirect branch will be using

1224
00:45:33,280 --> 00:45:36,000
this code pointer

1225
00:45:36,000 --> 00:45:38,560
but we make sure that the code pointer

1226
00:45:38,560 --> 00:45:41,119
is used during speculative execution

1227
00:45:41,119 --> 00:45:43,520
which has a fantastic advantage namely

1228
00:45:43,520 --> 00:45:45,680
that if we jump somewhere where there is

1229
00:45:45,680 --> 00:45:48,480
no code right where uh we would normally

1230
00:45:48,480 --> 00:45:50,240
crash we don't crash

1231
00:45:50,240 --> 00:45:51,280
it's

1232
00:45:51,280 --> 00:45:53,359
speculatively executed so it doesn't

1233
00:45:53,359 --> 00:45:56,000
matter right so you may get it wrong and

1234
00:45:56,000 --> 00:45:57,920
it's uh it's not gonna affect anything

1235
00:45:57,920 --> 00:45:59,280
okay

1236
00:45:59,280 --> 00:46:03,680
moreover we don't use the fact that

1237
00:46:03,680 --> 00:46:06,640
we can train this predictor to target a

1238
00:46:06,640 --> 00:46:09,200
particular address right that by you

1239
00:46:09,200 --> 00:46:12,400
know training training training we can

1240
00:46:12,400 --> 00:46:14,560
set the target address to some value

1241
00:46:14,560 --> 00:46:16,880
which no longer works right modern

1242
00:46:16,880 --> 00:46:19,920
mitigations make this impossible but now

1243
00:46:19,920 --> 00:46:22,640
instead we corrupt the

1244
00:46:22,640 --> 00:46:24,160
address that the

1245
00:46:24,160 --> 00:46:26,640
the indirect branch has to target by

1246
00:46:26,640 --> 00:46:29,520
means of memory corruption so as far as

1247
00:46:29,520 --> 00:46:32,160
the cpu is concerned it's as far as the

1248
00:46:32,160 --> 00:46:33,680
predictor is concerned it's actually a

1249
00:46:33,680 --> 00:46:36,400
valid address right it's just you know

1250
00:46:36,400 --> 00:46:39,280
um obtained in an illegal manner by

1251
00:46:39,280 --> 00:46:41,280
means of software corruption but the cpu

1252
00:46:41,280 --> 00:46:42,800
doesn't know that so the spectrum

1253
00:46:42,800 --> 00:46:45,680
mitigations no longer work

1254
00:46:45,680 --> 00:46:47,839
okay and under this speculative

1255
00:46:47,839 --> 00:46:50,160
execution we can just jump around again

1256
00:46:50,160 --> 00:46:52,319
so jump around as much as we want

1257
00:46:52,319 --> 00:46:54,319
without crashing okay

1258
00:46:54,319 --> 00:46:56,400
and while we're doing this we can look

1259
00:46:56,400 --> 00:46:58,240
for side effects

1260
00:46:58,240 --> 00:47:00,720
okay look for side effects that indicate

1261
00:47:00,720 --> 00:47:02,800
for instance that this is a code page

1262
00:47:02,800 --> 00:47:05,680
and this is a data page and perhaps we

1263
00:47:05,680 --> 00:47:08,079
can look for very specific code fragment

1264
00:47:08,079 --> 00:47:11,119
specific gadgets such as a regular

1265
00:47:11,119 --> 00:47:13,680
spectral gadgets that we can then use to

1266
00:47:13,680 --> 00:47:16,240
leak everything there is in the linux

1267
00:47:16,240 --> 00:47:18,560
kernel

1268
00:47:20,000 --> 00:47:22,640
specifically if we have our two

1269
00:47:22,640 --> 00:47:24,160
spectre

1270
00:47:24,160 --> 00:47:26,400
variants here and i've grayed out the

1271
00:47:26,400 --> 00:47:29,119
part that we don't use we have our

1272
00:47:29,119 --> 00:47:31,680
you know what was originally our brands

1273
00:47:31,680 --> 00:47:35,680
our bounce check bypass and our um

1274
00:47:35,680 --> 00:47:36,839
indirect

1275
00:47:36,839 --> 00:47:39,839
branch pollution misprediction

1276
00:47:39,839 --> 00:47:41,359
so we're going to use

1277
00:47:41,359 --> 00:47:44,000
variants of this as a part of this

1278
00:47:44,000 --> 00:47:47,040
with this one to create something new so

1279
00:47:47,040 --> 00:47:48,559
we're not going to use the gray part but

1280
00:47:48,559 --> 00:47:51,200
we will use this misprediction on a

1281
00:47:51,200 --> 00:47:52,559
condition

1282
00:47:52,559 --> 00:47:54,880
okay and we're going to use this

1283
00:47:54,880 --> 00:47:56,720
indirect branch also

1284
00:47:56,720 --> 00:47:59,280
so instead of the above two we're going

1285
00:47:59,280 --> 00:48:00,480
to use

1286
00:48:00,480 --> 00:48:02,800
this little snippet of code

1287
00:48:02,800 --> 00:48:05,200
if we can find it somewhere where

1288
00:48:05,200 --> 00:48:06,480
if there is

1289
00:48:06,480 --> 00:48:07,680
some

1290
00:48:07,680 --> 00:48:09,440
condition true

1291
00:48:09,440 --> 00:48:11,200
right so if some condition is true that

1292
00:48:11,200 --> 00:48:15,040
takes a while to evaluate

1293
00:48:15,040 --> 00:48:18,400
this code will be executed speculatively

1294
00:48:18,400 --> 00:48:22,000
okay but this code will itself contain

1295
00:48:22,000 --> 00:48:23,280
an indirect

1296
00:48:23,280 --> 00:48:26,240
call in this particular case so the

1297
00:48:26,240 --> 00:48:28,640
um indirect call

1298
00:48:28,640 --> 00:48:30,559
will be

1299
00:48:30,559 --> 00:48:33,119
executed speculatively but the target of

1300
00:48:33,119 --> 00:48:36,000
the indirect call is something that we

1301
00:48:36,000 --> 00:48:38,720
set by means of memory corruption by a

1302
00:48:38,720 --> 00:48:41,040
buffer overflow for instance

1303
00:48:41,040 --> 00:48:42,000
okay

1304
00:48:42,000 --> 00:48:43,680
and that means that we can just jump

1305
00:48:43,680 --> 00:48:46,880
around with this because the

1306
00:48:46,880 --> 00:48:49,040
mitigations don't stop it

1307
00:48:49,040 --> 00:48:52,000
before i i look at what we do with that

1308
00:48:52,000 --> 00:48:54,640
i want to point out that this is a very

1309
00:48:54,640 --> 00:48:58,160
common bit of code right so the uh

1310
00:48:58,160 --> 00:48:59,040
50

1311
00:48:59,040 --> 00:49:01,359
of the indirect branches

1312
00:49:01,359 --> 00:49:04,480
are dependent on a conditional

1313
00:49:04,480 --> 00:49:07,599
branch within the 50 instructions and

1314
00:49:07,599 --> 00:49:09,599
you know 37 of the indirect branches are

1315
00:49:09,599 --> 00:49:13,440
within in a distance of

1316
00:49:13,599 --> 00:49:16,319
five instructions from a condition so

1317
00:49:16,319 --> 00:49:18,160
that means that the probability of you

1318
00:49:18,160 --> 00:49:19,920
know there being something

1319
00:49:19,920 --> 00:49:21,960
an indirect branch executed

1320
00:49:21,960 --> 00:49:26,880
speculatively is very high okay

1321
00:49:27,119 --> 00:49:28,000
all right

1322
00:49:28,000 --> 00:49:29,680
what i said is that we were going to

1323
00:49:29,680 --> 00:49:32,800
look for side effects that allow us to

1324
00:49:32,800 --> 00:49:35,440
help in our exploitation we have again a

1325
00:49:35,440 --> 00:49:38,160
memory corruption that allows us to

1326
00:49:38,160 --> 00:49:40,319
override some memory for instance on the

1327
00:49:40,319 --> 00:49:42,160
stack or on the heap

1328
00:49:42,160 --> 00:49:43,359
okay

1329
00:49:43,359 --> 00:49:45,119
and let's have an example of the kind of

1330
00:49:45,119 --> 00:49:47,359
things that we can do let's say you know

1331
00:49:47,359 --> 00:49:48,319
the

1332
00:49:48,319 --> 00:49:50,160
page that we see here on the right is

1333
00:49:50,160 --> 00:49:52,720
something that contains a vulnerability

1334
00:49:52,720 --> 00:49:55,920
we can override stuff on this page for

1335
00:49:55,920 --> 00:49:57,520
instance we can override a function

1336
00:49:57,520 --> 00:49:58,720
pointer

1337
00:49:58,720 --> 00:50:01,119
what we do is we overwrite the function

1338
00:50:01,119 --> 00:50:03,200
pointer with a value

1339
00:50:03,200 --> 00:50:06,000
and we then go and look whether or not

1340
00:50:06,000 --> 00:50:08,480
there's cache activity

1341
00:50:08,480 --> 00:50:09,680
with

1342
00:50:09,680 --> 00:50:12,240
this address that we override so it's

1343
00:50:12,240 --> 00:50:14,960
trying to jump to some address that we

1344
00:50:14,960 --> 00:50:16,880
determine as an attacker

1345
00:50:16,880 --> 00:50:18,640
and then we go and see

1346
00:50:18,640 --> 00:50:20,800
whether or not this

1347
00:50:20,800 --> 00:50:23,760
cash set became active the cash at that

1348
00:50:23,760 --> 00:50:26,480
corresponds to this target pointer

1349
00:50:26,480 --> 00:50:28,160
address

1350
00:50:28,160 --> 00:50:29,680
okay

1351
00:50:29,680 --> 00:50:30,400
so

1352
00:50:30,400 --> 00:50:32,400
how do we do this well so we make it

1353
00:50:32,400 --> 00:50:35,280
jump there and we simply see

1354
00:50:35,280 --> 00:50:37,920
by doing our cash side channels whether

1355
00:50:37,920 --> 00:50:41,760
or not this cache set became an active

1356
00:50:41,760 --> 00:50:44,079
cache set right whether something that

1357
00:50:44,079 --> 00:50:46,240
we put in there was now flushed from the

1358
00:50:46,240 --> 00:50:49,760
cache so the access became slow

1359
00:50:49,760 --> 00:50:51,760
if this is not the case it jumped

1360
00:50:51,760 --> 00:50:54,880
somewhere where there was no code but if

1361
00:50:54,880 --> 00:50:57,200
this was a valid code page

1362
00:50:57,200 --> 00:51:01,359
that cache chat will be active

1363
00:51:01,839 --> 00:51:03,599
is that clear

1364
00:51:03,599 --> 00:51:05,760
kind of yes maybe

1365
00:51:05,760 --> 00:51:08,480
okay so let me i see some people

1366
00:51:08,480 --> 00:51:10,800
looking uncertain here so what we do is

1367
00:51:10,800 --> 00:51:12,720
we're overflowing some buffer or doing

1368
00:51:12,720 --> 00:51:14,640
some other memory corruption that allows

1369
00:51:14,640 --> 00:51:17,520
us to you know target a function pointer

1370
00:51:17,520 --> 00:51:19,520
that is what we're doing okay and we set

1371
00:51:19,520 --> 00:51:22,160
a value in that um

1372
00:51:22,160 --> 00:51:25,599
that function pointer of you know some

1373
00:51:25,599 --> 00:51:27,680
random address in memory

1374
00:51:27,680 --> 00:51:30,880
okay in most cases this will lead to an

1375
00:51:30,880 --> 00:51:32,800
immediate crash right because there's no

1376
00:51:32,800 --> 00:51:34,400
code page there

1377
00:51:34,400 --> 00:51:36,960
and that's you know nothing will happen

1378
00:51:36,960 --> 00:51:40,160
however if there was a code page there

1379
00:51:40,160 --> 00:51:42,400
this code will be

1380
00:51:42,400 --> 00:51:44,640
speculatively executed

1381
00:51:44,640 --> 00:51:47,040
okay whatever code was there

1382
00:51:47,040 --> 00:51:49,520
and if it's speculatively executed this

1383
00:51:49,520 --> 00:51:52,559
code will be loaded in the cache

1384
00:51:52,559 --> 00:51:53,440
and

1385
00:51:53,440 --> 00:51:55,200
where will it be loaded well it will be

1386
00:51:55,200 --> 00:51:57,520
loaded and at a cache ad that

1387
00:51:57,520 --> 00:51:59,599
corresponds to the address that we just

1388
00:51:59,599 --> 00:52:00,800
provided

1389
00:52:00,800 --> 00:52:02,720
right because that is the the code that

1390
00:52:02,720 --> 00:52:04,240
we're trying to execute that is the

1391
00:52:04,240 --> 00:52:06,800
location of that code

1392
00:52:06,800 --> 00:52:09,920
now how do we determine whether that

1393
00:52:09,920 --> 00:52:11,200
cachett

1394
00:52:11,200 --> 00:52:12,160
was

1395
00:52:12,160 --> 00:52:14,559
became active we know the address there

1396
00:52:14,559 --> 00:52:16,000
right so we know

1397
00:52:16,000 --> 00:52:18,480
exactly which cache set this is so we

1398
00:52:18,480 --> 00:52:20,880
make sure in advance that we

1399
00:52:20,880 --> 00:52:22,960
put our own stuff

1400
00:52:22,960 --> 00:52:26,240
in those uh cache lines that cache set

1401
00:52:26,240 --> 00:52:29,119
and then we make the kernel jump to that

1402
00:52:29,119 --> 00:52:31,040
address and we see if our stuff is still

1403
00:52:31,040 --> 00:52:33,200
in the cache by reading it

1404
00:52:33,200 --> 00:52:34,400
and if it's

1405
00:52:34,400 --> 00:52:37,520
really fast it means that our code

1406
00:52:37,520 --> 00:52:39,680
the data that we put there is still in

1407
00:52:39,680 --> 00:52:42,800
that cache set and clearly no code was

1408
00:52:42,800 --> 00:52:44,480
executed

1409
00:52:44,480 --> 00:52:46,559
if it's slow however

1410
00:52:46,559 --> 00:52:48,240
it mean if one of the cache lines in

1411
00:52:48,240 --> 00:52:51,280
that cache set is slow it means that the

1412
00:52:51,280 --> 00:52:53,599
kernel did jump to that instruction so

1413
00:52:53,599 --> 00:52:56,160
there was some code there and that's now

1414
00:52:56,160 --> 00:52:58,079
in that cache line

1415
00:52:58,079 --> 00:53:01,040
okay so now we know this must have been

1416
00:53:01,040 --> 00:53:04,559
a code page we guessed the right address

1417
00:53:04,559 --> 00:53:06,160
is that clear

1418
00:53:06,160 --> 00:53:09,119
yep okay so we can do the same thing

1419
00:53:09,119 --> 00:53:11,280
for data pages

1420
00:53:11,280 --> 00:53:14,240
okay oh and i have to hurry up i see so

1421
00:53:14,240 --> 00:53:16,640
um so we can do the same thing for um

1422
00:53:16,640 --> 00:53:18,319
and this is enough by the way to break

1423
00:53:18,319 --> 00:53:19,359
kernel address space layout

1424
00:53:19,359 --> 00:53:21,200
randomization after we have it today we

1425
00:53:21,200 --> 00:53:23,440
can just you know map out all of the uh

1426
00:53:23,440 --> 00:53:24,800
code pages in the kernel and we've

1427
00:53:24,800 --> 00:53:26,400
broken kernel address page layout

1428
00:53:26,400 --> 00:53:29,920
randomization we can also do this for

1429
00:53:29,920 --> 00:53:32,319
data pages so for data pages we have to

1430
00:53:32,319 --> 00:53:34,240
do a little bit more effort we have to

1431
00:53:34,240 --> 00:53:35,359
use

1432
00:53:35,359 --> 00:53:38,319
we have to look for some code that

1433
00:53:38,319 --> 00:53:40,800
uses

1434
00:53:40,880 --> 00:53:43,440
some data that we corrupt so now we

1435
00:53:43,440 --> 00:53:45,920
overflow more than just the function

1436
00:53:45,920 --> 00:53:47,760
pointer we also corrupt

1437
00:53:47,760 --> 00:53:50,800
besides the function pointer some other

1438
00:53:50,800 --> 00:53:53,440
memory location and we hope that there

1439
00:53:53,440 --> 00:53:54,720
is

1440
00:53:54,720 --> 00:53:56,800
stuff that you know when we uh we

1441
00:53:56,800 --> 00:53:58,640
execute this uh this function pointer it

1442
00:53:58,640 --> 00:54:00,960
will execute some code that looks like

1443
00:54:00,960 --> 00:54:03,520
this something that uses

1444
00:54:03,520 --> 00:54:04,319
our

1445
00:54:04,319 --> 00:54:05,200
um

1446
00:54:05,200 --> 00:54:06,400
data

1447
00:54:06,400 --> 00:54:07,520
as

1448
00:54:07,520 --> 00:54:09,040
a pointer

1449
00:54:09,040 --> 00:54:12,960
okay so we again

1450
00:54:12,960 --> 00:54:16,000
aim to check this particular cache set

1451
00:54:16,000 --> 00:54:19,520
and if that cassette was indeed

1452
00:54:19,520 --> 00:54:22,559
active in the same way as we saw earlier

1453
00:54:22,559 --> 00:54:25,920
it means that some code similar to this

1454
00:54:25,920 --> 00:54:28,160
must have executed

1455
00:54:28,160 --> 00:54:31,760
okay because it's used the value

1456
00:54:31,760 --> 00:54:34,400
that we put in here that we corrupted

1457
00:54:34,400 --> 00:54:38,960
as a reference in the second um

1458
00:54:38,960 --> 00:54:40,079
uh

1459
00:54:40,079 --> 00:54:42,799
in in this uh this instruction and moved

1460
00:54:42,799 --> 00:54:44,880
it uh moved some value to

1461
00:54:44,880 --> 00:54:46,880
the register y in this particular case

1462
00:54:46,880 --> 00:54:51,200
so it should again lead to some

1463
00:54:51,440 --> 00:54:53,359
activation in the

1464
00:54:53,359 --> 00:54:55,680
uh appropriate cache chat

1465
00:54:55,680 --> 00:54:58,799
now i don't have time anymore to

1466
00:54:58,799 --> 00:55:00,799
talk about the the most complicated one

1467
00:55:00,799 --> 00:55:02,640
maybe that's a good thing

1468
00:55:02,640 --> 00:55:03,920
so we can

1469
00:55:03,920 --> 00:55:07,359
even find super complex gadgets in this

1470
00:55:07,359 --> 00:55:09,040
way by

1471
00:55:09,040 --> 00:55:11,359
corrupting data and

1472
00:55:11,359 --> 00:55:13,839
and looking at this one cache set that

1473
00:55:13,839 --> 00:55:14,640
we

1474
00:55:14,640 --> 00:55:15,839
use to

1475
00:55:15,839 --> 00:55:17,839
find an indication that that some things

1476
00:55:17,839 --> 00:55:20,400
happen so for all of these things we

1477
00:55:20,400 --> 00:55:21,440
use the

1478
00:55:21,440 --> 00:55:23,440
signal that we get on a particular cache

1479
00:55:23,440 --> 00:55:26,000
as an indication that some code like

1480
00:55:26,000 --> 00:55:28,319
this must have executed okay in this

1481
00:55:28,319 --> 00:55:30,480
case it's a spectre gadget and the

1482
00:55:30,480 --> 00:55:33,040
spectre gadgets can be used to

1483
00:55:33,040 --> 00:55:35,599
in subsequent

1484
00:55:35,599 --> 00:55:37,760
iterations to leak everything that we

1485
00:55:37,760 --> 00:55:39,760
want from the kernel

1486
00:55:39,760 --> 00:55:42,079
all right

1487
00:55:42,640 --> 00:55:43,680
so

1488
00:55:43,680 --> 00:55:45,359
even just finding the code and data

1489
00:55:45,359 --> 00:55:47,680
pages is sufficient for um for many of

1490
00:55:47,680 --> 00:55:49,200
the attacks

1491
00:55:49,200 --> 00:55:51,520
this is even even worse

1492
00:55:51,520 --> 00:55:54,000
okay so what we're seeing here is that

1493
00:55:54,000 --> 00:55:55,440
we combine

1494
00:55:55,440 --> 00:55:57,440
the corruption of

1495
00:55:57,440 --> 00:55:59,599
traditional software exploitation

1496
00:55:59,599 --> 00:56:02,000
with speculative execution transient

1497
00:56:02,000 --> 00:56:04,799
execution which prevents crashes

1498
00:56:04,799 --> 00:56:07,119
right to come to

1499
00:56:07,119 --> 00:56:08,319
a better

1500
00:56:08,319 --> 00:56:10,640
software exploitation and also the

1501
00:56:10,640 --> 00:56:12,799
application of transient execution

1502
00:56:12,799 --> 00:56:15,680
speculative execution attacks in cases

1503
00:56:15,680 --> 00:56:18,319
that would otherwise be mitigation may

1504
00:56:18,319 --> 00:56:20,160
be mitigated in other words the

1505
00:56:20,160 --> 00:56:22,400
combination of these two threat models

1506
00:56:22,400 --> 00:56:24,559
is indeed greater than the sum of its

1507
00:56:24,559 --> 00:56:25,680
parts

1508
00:56:25,680 --> 00:56:29,280
and i want to very briefly

1509
00:56:29,280 --> 00:56:32,400
show you the demo of that

1510
00:56:32,400 --> 00:56:35,359
so here we see anessa's computer and

1511
00:56:35,359 --> 00:56:37,440
annas's

1512
00:56:37,440 --> 00:56:40,400
user id is anus and he has a proof of

1513
00:56:40,400 --> 00:56:41,599
concept

1514
00:56:41,599 --> 00:56:44,720
code i hope this is readable by the way

1515
00:56:44,720 --> 00:56:46,799
which he executes and the first thing

1516
00:56:46,799 --> 00:56:49,200
it's going to do is look for

1517
00:56:49,200 --> 00:56:51,520
the eviction sets of the last level

1518
00:56:51,520 --> 00:56:55,839
cache okay because we use eviction based

1519
00:56:55,839 --> 00:56:58,240
sampling of this cache side channel that

1520
00:56:58,240 --> 00:57:00,480
the activation of the uh

1521
00:57:00,480 --> 00:57:02,720
um

1522
00:57:02,720 --> 00:57:04,559
of the the cache set

1523
00:57:04,559 --> 00:57:07,520
okay so it looks for uh

1524
00:57:07,520 --> 00:57:09,839
the the eviction sets and then it's

1525
00:57:09,839 --> 00:57:12,880
going to

1526
00:57:12,880 --> 00:57:14,400
oh wait

1527
00:57:14,400 --> 00:57:17,799
what did i do

1528
00:57:34,799 --> 00:57:37,359
okay so this takes a while

1529
00:57:37,359 --> 00:57:39,280
and then at some point it's going to

1530
00:57:39,280 --> 00:57:40,720
look for

1531
00:57:40,720 --> 00:57:42,960
the kernel

1532
00:57:42,960 --> 00:57:44,000
code

1533
00:57:44,000 --> 00:57:46,240
so

1534
00:57:47,280 --> 00:57:48,559
there we go

1535
00:57:48,559 --> 00:57:50,559
so it's looking for the kernel base

1536
00:57:50,559 --> 00:57:52,720
address which it finds after a while so

1537
00:57:52,720 --> 00:57:55,119
now we know where the kernel code is the

1538
00:57:55,119 --> 00:57:57,520
next thing is going to look for is

1539
00:57:57,520 --> 00:58:01,040
some page where we store our

1540
00:58:01,040 --> 00:58:04,240
code reuse our rob payload

1541
00:58:04,240 --> 00:58:06,400
okay and that takes some time because we

1542
00:58:06,400 --> 00:58:08,079
have to go through all of these pages we

1543
00:58:08,079 --> 00:58:10,480
have to look for data pages and then see

1544
00:58:10,480 --> 00:58:12,400
which of the data pages are the right

1545
00:58:12,400 --> 00:58:16,480
pages with where we store our

1546
00:58:16,799 --> 00:58:19,200
rob payload so let's see if we move on a

1547
00:58:19,200 --> 00:58:22,439
little bit

1548
00:58:27,520 --> 00:58:29,520
still looking for the vulnerable

1549
00:58:29,520 --> 00:58:32,000
buffer

1550
00:58:32,720 --> 00:58:35,839
let me move on a little bit more

1551
00:58:35,839 --> 00:58:38,640
a little bit more

1552
00:58:40,079 --> 00:58:42,799
and here we go

1553
00:58:44,640 --> 00:58:47,359
so after what is it uh

1554
00:58:47,359 --> 00:58:50,160
where's the time

1555
00:58:50,280 --> 00:58:52,720
137 seconds

1556
00:58:52,720 --> 00:58:54,079
it found the

1557
00:58:54,079 --> 00:58:56,319
uh the appropriate

1558
00:58:56,319 --> 00:58:59,200
uh buffer in the kernel and that we

1559
00:58:59,200 --> 00:59:00,799
actually also control for our rope

1560
00:59:00,799 --> 00:59:02,079
payload

1561
00:59:02,079 --> 00:59:03,119
and then

1562
00:59:03,119 --> 00:59:05,359
we are doing some other tricks with the

1563
00:59:05,359 --> 00:59:08,160
the rope uh the code reuse attack and

1564
00:59:08,160 --> 00:59:10,480
finally we got root

1565
00:59:10,480 --> 00:59:12,480
okay great

1566
00:59:12,480 --> 00:59:14,799
and

1567
00:59:17,599 --> 00:59:19,200
so again

1568
00:59:19,200 --> 00:59:21,119
what we've seen is that we look for the

1569
00:59:21,119 --> 00:59:23,040
kernel code pages

1570
00:59:23,040 --> 00:59:25,839
then we look for the kernel data pages

1571
00:59:25,839 --> 00:59:28,319
so the kernel heap then we probe around

1572
00:59:28,319 --> 00:59:30,319
a bit to look for the appropriate page

1573
00:59:30,319 --> 00:59:32,640
that contains our raw payload

1574
00:59:32,640 --> 00:59:35,359
then we find some gadgets that we need

1575
00:59:35,359 --> 00:59:37,200
and then we

1576
00:59:37,200 --> 00:59:40,240
execute our raw payload and

1577
00:59:40,240 --> 00:59:42,720
get root

1578
00:59:42,720 --> 00:59:45,359
access to our to our program

1579
00:59:45,359 --> 00:59:47,520
okay conclusions

1580
00:59:47,520 --> 00:59:49,599
what i've tried to explain is that the

1581
00:59:49,599 --> 00:59:52,160
abstractions that we use and that are

1582
00:59:52,160 --> 00:59:54,880
necessary that are fundamental are also

1583
00:59:54,880 --> 00:59:57,040
harmful because they leak

1584
00:59:57,040 --> 01:00:00,160
and they are not as solid as we would

1585
01:00:00,160 --> 01:00:01,599
like to think

1586
01:00:01,599 --> 01:00:04,079
and to write secure code you kind of

1587
01:00:04,079 --> 01:00:05,599
need to know everything about your code

1588
01:00:05,599 --> 01:00:08,240
but also everything about what is

1589
01:00:08,240 --> 01:00:10,960
happening in the layers below you

1590
01:00:10,960 --> 01:00:13,040
okay so these abstractions are not

1591
01:00:13,040 --> 01:00:15,280
actually shielding you from the details

1592
01:00:15,280 --> 01:00:17,119
if you talk if you're talking about

1593
01:00:17,119 --> 01:00:20,240
security it's exactly these abstractions

1594
01:00:20,240 --> 01:00:21,040
that

1595
01:00:21,040 --> 01:00:22,640
hide some of the things that you should

1596
01:00:22,640 --> 01:00:24,079
be aware of

1597
01:00:24,079 --> 01:00:24,880
okay

1598
01:00:24,880 --> 01:00:26,799
and the attackers will combine these

1599
01:00:26,799 --> 01:00:29,359
threat models and what i think is an

1600
01:00:29,359 --> 01:00:32,079
interesting new combination is the

1601
01:00:32,079 --> 01:00:34,079
symbiotic combination where two

1602
01:00:34,079 --> 01:00:35,760
different threatments two different

1603
01:00:35,760 --> 01:00:37,680
classes of attack

1604
01:00:37,680 --> 01:00:40,880
make each other stronger okay and the

1605
01:00:40,880 --> 01:00:42,720
combination in this particular case

1606
01:00:42,720 --> 01:00:45,200
becomes greater than the sum of its

1607
01:00:45,200 --> 01:00:46,160
parts

1608
01:00:46,160 --> 01:00:48,640
okay and that is exactly one hour so i

1609
01:00:48,640 --> 01:00:50,960
should just stop by concluding that uh

1610
01:00:50,960 --> 01:00:53,359
the the quarrelsome youth from the

1611
01:00:53,359 --> 01:00:55,200
beginning of the talk was actually right

1612
01:00:55,200 --> 01:00:56,319
it's all just a lot of stuff and the

1613
01:00:56,319 --> 01:01:01,160
attackers will use all of that thank you

