1
00:00:03,280 --> 00:00:06,399
um so hello everyone and good afternoon

2
00:00:06,399 --> 00:00:08,400
and welcome to my talk

3
00:00:08,400 --> 00:00:11,440
about automated vulnerability hunting in

4
00:00:11,440 --> 00:00:12,719
smm

5
00:00:12,719 --> 00:00:15,360
so first let me just introduce myself so

6
00:00:15,360 --> 00:00:17,920
my name is saf

7
00:00:17,920 --> 00:00:19,840
currently i'm a security researcher at

8
00:00:19,840 --> 00:00:22,400
the sentinel one

9
00:00:22,400 --> 00:00:24,400
also worked with me on this project is

10
00:00:24,400 --> 00:00:27,519
my good friend and colleague italia

11
00:00:27,519 --> 00:00:29,599
who unfortunately couldn't be here today

12
00:00:29,599 --> 00:00:30,720
due to

13
00:00:30,720 --> 00:00:33,360
some prior commitments so

14
00:00:33,360 --> 00:00:35,200
he want to be with us physically but i

15
00:00:35,200 --> 00:00:39,760
do hope he will be with us in his spirit

16
00:00:40,239 --> 00:00:41,040
so

17
00:00:41,040 --> 00:00:43,360
the talk is basically divided into three

18
00:00:43,360 --> 00:00:45,360
parts in the first one we will do a

19
00:00:45,360 --> 00:00:48,320
quick recap of what smm is and how it

20
00:00:48,320 --> 00:00:50,160
operates under the hood

21
00:00:50,160 --> 00:00:52,000
and then we will move on to the second

22
00:00:52,000 --> 00:00:55,039
part when where we describe some common

23
00:00:55,039 --> 00:00:57,840
bug classes and attacks against smm code

24
00:00:57,840 --> 00:01:00,000
and we will conclude by presenting a

25
00:01:00,000 --> 00:01:02,960
small tool we wrote that helps you

26
00:01:02,960 --> 00:01:05,360
automatically detect some of these bug

27
00:01:05,360 --> 00:01:07,760
classes

28
00:01:07,760 --> 00:01:08,479
so

29
00:01:08,479 --> 00:01:10,640
let's start with smm

30
00:01:10,640 --> 00:01:12,960
smm stands for system management mode

31
00:01:12,960 --> 00:01:15,200
it's one of the operating modes found in

32
00:01:15,200 --> 00:01:18,320
every intel compatible cpu alongside the

33
00:01:18,320 --> 00:01:20,400
more familiar modes such as real mode

34
00:01:20,400 --> 00:01:23,200
protected mode long mode and so on

35
00:01:23,200 --> 00:01:25,360
and smm was designed

36
00:01:25,360 --> 00:01:27,360
to be used exclusively by the firmware

37
00:01:27,360 --> 00:01:30,240
to handle some low-level operations

38
00:01:30,240 --> 00:01:33,520
so typical examples would include things

39
00:01:33,520 --> 00:01:35,840
such as power management

40
00:01:35,840 --> 00:01:39,119
thermal control emulating legacy devices

41
00:01:39,119 --> 00:01:41,119
or basically any other piece of code

42
00:01:41,119 --> 00:01:45,200
that oem wants to put into the box

43
00:01:45,600 --> 00:01:48,079
smm has been with us for over than 30

44
00:01:48,079 --> 00:01:50,000
years so it's definitely not a new piece

45
00:01:50,000 --> 00:01:51,439
of technology

46
00:01:51,439 --> 00:01:53,200
and at the beginning it was pretty

47
00:01:53,200 --> 00:01:55,759
modest but over time it has grown in

48
00:01:55,759 --> 00:01:56,960
significance

49
00:01:56,960 --> 00:01:59,119
simply because oem started shifting more

50
00:01:59,119 --> 00:02:01,439
and more functionality into it and so

51
00:02:01,439 --> 00:02:03,520
the end result is that a typical thermal

52
00:02:03,520 --> 00:02:05,840
image nowadays on a modern laptop for

53
00:02:05,840 --> 00:02:06,799
example

54
00:02:06,799 --> 00:02:09,280
contains a magnitude of dozens of

55
00:02:09,280 --> 00:02:11,760
different executable images that all

56
00:02:11,760 --> 00:02:15,280
execute in this mode

57
00:02:15,520 --> 00:02:18,720
now smm code runs from its own isolated

58
00:02:18,720 --> 00:02:20,959
adder space known as system management

59
00:02:20,959 --> 00:02:23,520
drum or smram for short

60
00:02:23,520 --> 00:02:25,599
this is just a region of physical memory

61
00:02:25,599 --> 00:02:28,400
where the smm code and data lives

62
00:02:28,400 --> 00:02:29,920
and if you want to know the exact

63
00:02:29,920 --> 00:02:32,480
address range smram spans you can do it

64
00:02:32,480 --> 00:02:34,560
quite easily simply by reading a bunch

65
00:02:34,560 --> 00:02:36,400
of registers called

66
00:02:36,400 --> 00:02:40,080
smm range registers or smalls for short

67
00:02:40,080 --> 00:02:43,120
and alternatively you can use a

68
00:02:43,120 --> 00:02:46,080
tool called chipset that lets you

69
00:02:46,080 --> 00:02:48,160
read and validate certain firmware level

70
00:02:48,160 --> 00:02:50,640
settings on your machine that also gives

71
00:02:50,640 --> 00:02:53,760
you the same information

72
00:02:53,840 --> 00:02:56,720
now one of the main features of smr is

73
00:02:56,720 --> 00:02:59,120
that it can be closed and locked by the

74
00:02:59,120 --> 00:03:01,840
hardware in order to isolate smm from

75
00:03:01,840 --> 00:03:03,360
the outside world

76
00:03:03,360 --> 00:03:06,319
so when smram is

77
00:03:06,319 --> 00:03:08,159
closed and locked

78
00:03:08,159 --> 00:03:10,480
only code already running in smm can

79
00:03:10,480 --> 00:03:11,519
access

80
00:03:11,519 --> 00:03:13,440
smram contents so

81
00:03:13,440 --> 00:03:16,239
put it into other words any attempt to

82
00:03:16,239 --> 00:03:20,159
access smram from a non-smm context

83
00:03:20,159 --> 00:03:22,319
would fail or be remapped by the

84
00:03:22,319 --> 00:03:24,480
hardware or something like that and that

85
00:03:24,480 --> 00:03:26,879
restriction even applies to some highly

86
00:03:26,879 --> 00:03:29,360
privileged components including the os

87
00:03:29,360 --> 00:03:32,640
kernel the hypervisor or even io devices

88
00:03:32,640 --> 00:03:36,559
that are capable of doing dma

89
00:03:37,040 --> 00:03:39,440
now smm code is triggered in response to

90
00:03:39,440 --> 00:03:41,200
what is known as a system management

91
00:03:41,200 --> 00:03:43,840
interrupt or smi for short

92
00:03:43,840 --> 00:03:45,920
these are high priority interrupts so

93
00:03:45,920 --> 00:03:48,400
they can preempt basically almost any

94
00:03:48,400 --> 00:03:50,480
code that runs on the system

95
00:03:50,480 --> 00:03:53,120
and when such an smi is fired control is

96
00:03:53,120 --> 00:03:55,599
transferred into a dedicated routine

97
00:03:55,599 --> 00:03:57,760
called the smi handler

98
00:03:57,760 --> 00:03:59,840
so generally speaking there is only one

99
00:03:59,840 --> 00:04:03,280
such handler but during boot time the

100
00:04:03,280 --> 00:04:05,439
firmware can register additional sub

101
00:04:05,439 --> 00:04:07,280
handlers in order to handle particular

102
00:04:07,280 --> 00:04:09,680
events

103
00:04:09,680 --> 00:04:12,640
now smi's come in several flavors first

104
00:04:12,640 --> 00:04:14,640
we have the distinction between hardware

105
00:04:14,640 --> 00:04:17,199
semis and software smiles so how do

106
00:04:17,199 --> 00:04:19,680
smiths are mostly asynchronous events

107
00:04:19,680 --> 00:04:21,759
that are generated

108
00:04:21,759 --> 00:04:24,240
by a plethora of devices all connected

109
00:04:24,240 --> 00:04:26,560
to the system so typical examples would

110
00:04:26,560 --> 00:04:30,160
be things like the usb bus power buttons

111
00:04:30,160 --> 00:04:32,720
or basically any other other device that

112
00:04:32,720 --> 00:04:34,400
is transitioning between different sleep

113
00:04:34,400 --> 00:04:35,759
states

114
00:04:35,759 --> 00:04:38,240
and software smis on the other hand

115
00:04:38,240 --> 00:04:41,040
are mostly synchronous events that are

116
00:04:41,040 --> 00:04:43,919
generated intentionally by software

117
00:04:43,919 --> 00:04:47,040
and the most common use case is for a

118
00:04:47,040 --> 00:04:48,720
non-smm code

119
00:04:48,720 --> 00:04:51,759
to request certain services form code

120
00:04:51,759 --> 00:04:54,320
already running in smm so basically we

121
00:04:54,320 --> 00:04:56,960
can think of this as the smm equivalent

122
00:04:56,960 --> 00:04:59,120
of a system call

123
00:04:59,120 --> 00:05:02,080
now in the uefi specification software

124
00:05:02,080 --> 00:05:04,080
sms can be again divided into two

125
00:05:04,080 --> 00:05:05,280
subtypes

126
00:05:05,280 --> 00:05:07,680
first we have the legacy software smis

127
00:05:07,680 --> 00:05:09,199
that i won't

128
00:05:09,199 --> 00:05:11,280
talk a lot about them and then we have

129
00:05:11,280 --> 00:05:14,000
the other subtype which i chose to call

130
00:05:14,000 --> 00:05:17,120
a com buffer semis and this will be the

131
00:05:17,120 --> 00:05:20,479
focal point of this talk

132
00:05:20,479 --> 00:05:24,000
now in order to register comba for smi's

133
00:05:24,000 --> 00:05:27,280
uefi code can call a service called smi

134
00:05:27,280 --> 00:05:28,880
handler register

135
00:05:28,880 --> 00:05:31,520
and each handler gets assigned a unique

136
00:05:31,520 --> 00:05:34,160
gui that lets us easily reference it and

137
00:05:34,160 --> 00:05:37,440
locate it afterwards

138
00:05:37,600 --> 00:05:38,639
now

139
00:05:38,639 --> 00:05:41,120
let's talk a bit about how these smis

140
00:05:41,120 --> 00:05:44,000
are invoked so in uefi all the

141
00:05:44,000 --> 00:05:46,080
communication all the interaction

142
00:05:46,080 --> 00:05:49,199
between non-smm code and smm code is

143
00:05:49,199 --> 00:05:50,560
mediated

144
00:05:50,560 --> 00:05:53,120
via dedicated protocol called the efi

145
00:05:53,120 --> 00:05:55,440
smm communication protocol

146
00:05:55,440 --> 00:05:57,600
so that means any code that wants to

147
00:05:57,600 --> 00:06:00,319
trigger these sms must first retrieve an

148
00:06:00,319 --> 00:06:02,080
instance of that protocol

149
00:06:02,080 --> 00:06:04,560
afterwards the code is allocating what

150
00:06:04,560 --> 00:06:07,039
is known as a communication buffer or

151
00:06:07,039 --> 00:06:09,680
combat for short and this is just a

152
00:06:09,680 --> 00:06:11,840
region of physical memory that will be

153
00:06:11,840 --> 00:06:13,840
used in order to pass arguments to the

154
00:06:13,840 --> 00:06:16,160
smi handler and get back some some of

155
00:06:16,160 --> 00:06:18,720
the results

156
00:06:19,039 --> 00:06:20,880
now the contents of the communication

157
00:06:20,880 --> 00:06:25,520
buffer can be broadly divided into uh

158
00:06:25,520 --> 00:06:28,800
two categories so first we have a fixed

159
00:06:28,800 --> 00:06:31,600
size header that specifies the good of

160
00:06:31,600 --> 00:06:33,440
the handler we want to invoke as well as

161
00:06:33,440 --> 00:06:35,520
the length of the data that follows

162
00:06:35,520 --> 00:06:38,000
and afterwards there is a variable size

163
00:06:38,000 --> 00:06:40,880
structure which holds the arguments that

164
00:06:40,880 --> 00:06:43,600
are tied to the particular type of smi

165
00:06:43,600 --> 00:06:46,240
we're invoking

166
00:06:46,240 --> 00:06:47,600
so after the

167
00:06:47,600 --> 00:06:49,199
contents of the communication buffer

168
00:06:49,199 --> 00:06:50,880
were prepared this way

169
00:06:50,880 --> 00:06:53,440
um the code called the communicate

170
00:06:53,440 --> 00:06:56,479
method of the smm communication protocol

171
00:06:56,479 --> 00:06:58,319
and this method call is eventually

172
00:06:58,319 --> 00:07:00,880
resolved into a function called smm

173
00:07:00,880 --> 00:07:03,599
communication communicate

174
00:07:03,599 --> 00:07:05,680
smm communication communicate basically

175
00:07:05,680 --> 00:07:08,880
does two things so first it places the

176
00:07:08,880 --> 00:07:11,840
pointer to the com buffer as well as its

177
00:07:11,840 --> 00:07:14,240
size in their respective

178
00:07:14,240 --> 00:07:17,440
fields in a global structure called gsm

179
00:07:17,440 --> 00:07:19,840
core private this structure is shared

180
00:07:19,840 --> 00:07:22,400
between smm code and non-smm code and

181
00:07:22,400 --> 00:07:24,800
therefore we can use it in order to

182
00:07:24,800 --> 00:07:26,960
pass information between the two modes

183
00:07:26,960 --> 00:07:29,120
and afterwards it calls the trigger

184
00:07:29,120 --> 00:07:31,840
method of the smm control protocol in

185
00:07:31,840 --> 00:07:36,400
order to actually generate the smi

186
00:07:36,400 --> 00:07:38,720
so under the hood the trigger method

187
00:07:38,720 --> 00:07:40,800
does little more than simply write to

188
00:07:40,800 --> 00:07:44,319
the two io ports b3 and b2 so that begs

189
00:07:44,319 --> 00:07:46,639
the question what is so magical about

190
00:07:46,639 --> 00:07:48,160
these two io ports

191
00:07:48,160 --> 00:07:50,800
and as it turns out these two io ports

192
00:07:50,800 --> 00:07:52,800
belong to the

193
00:07:52,800 --> 00:07:55,440
i o range of a small

194
00:07:55,440 --> 00:07:58,479
component called the apm controller or

195
00:07:58,479 --> 00:08:00,160
apmc for short

196
00:08:00,160 --> 00:08:02,879
port b2 is actually a

197
00:08:02,879 --> 00:08:04,400
control register

198
00:08:04,400 --> 00:08:05,360
that

199
00:08:05,360 --> 00:08:08,479
when written by software

200
00:08:08,479 --> 00:08:11,120
is also going to assert the smi pin of

201
00:08:11,120 --> 00:08:14,000
the cpu so basically this is the

202
00:08:14,000 --> 00:08:15,919
basic building block software uses in

203
00:08:15,919 --> 00:08:18,240
order to trigger sms in a controlled

204
00:08:18,240 --> 00:08:20,319
manner

205
00:08:20,319 --> 00:08:22,479
so after the transition to smm takes

206
00:08:22,479 --> 00:08:24,879
place a function called the smm entry

207
00:08:24,879 --> 00:08:27,840
point is called and this function

208
00:08:27,840 --> 00:08:29,919
takes the pointer to the com buffer and

209
00:08:29,919 --> 00:08:32,080
its size from the gsm core private

210
00:08:32,080 --> 00:08:34,719
structure and then it uses the guide

211
00:08:34,719 --> 00:08:36,640
found at the beginning of the com buffer

212
00:08:36,640 --> 00:08:38,880
in order to locate the handler we wish

213
00:08:38,880 --> 00:08:41,200
to invoke

214
00:08:41,200 --> 00:08:43,760
in the last phase the smi handle finally

215
00:08:43,760 --> 00:08:45,920
gets called and now it can freely access

216
00:08:45,920 --> 00:08:48,560
the contents of the communication buffer

217
00:08:48,560 --> 00:08:50,800
now an important thing to notice is that

218
00:08:50,800 --> 00:08:52,560
while the handler itself

219
00:08:52,560 --> 00:08:55,839
runs in smm and located in smram the

220
00:08:55,839 --> 00:08:57,360
contents of the communication buffer

221
00:08:57,360 --> 00:08:59,600
themselves are outside of smr so that's

222
00:08:59,600 --> 00:09:02,880
the point we will get back to

223
00:09:02,880 --> 00:09:04,560
okay so now let's move on to the second

224
00:09:04,560 --> 00:09:06,640
part where we describe some practical

225
00:09:06,640 --> 00:09:08,800
attacks against smm

226
00:09:08,800 --> 00:09:10,880
but first let's give some motivation for

227
00:09:10,880 --> 00:09:13,040
doing this in the first place

228
00:09:13,040 --> 00:09:15,920
so the main reason of attacking smm is

229
00:09:15,920 --> 00:09:18,080
that it's considered to be a highly

230
00:09:18,080 --> 00:09:20,800
privileged operating mode of the cpu

231
00:09:20,800 --> 00:09:22,560
so in the intel realm we like to think

232
00:09:22,560 --> 00:09:25,200
of privileges in terms of numbered rings

233
00:09:25,200 --> 00:09:27,360
where a lower ring number indicates

234
00:09:27,360 --> 00:09:29,839
higher privileges and according to this

235
00:09:29,839 --> 00:09:32,399
convention you can think of smm as ring

236
00:09:32,399 --> 00:09:35,200
minus two so that makes it more powerful

237
00:09:35,200 --> 00:09:37,120
than the os kernel or even the

238
00:09:37,120 --> 00:09:38,800
hypervisor

239
00:09:38,800 --> 00:09:41,600
now when you run in smm you

240
00:09:41,600 --> 00:09:42,800
have some

241
00:09:42,800 --> 00:09:44,720
special superpowers

242
00:09:44,720 --> 00:09:47,040
so for example you have full access to

243
00:09:47,040 --> 00:09:49,279
all the physical memory of the machine

244
00:09:49,279 --> 00:09:51,680
but the other way around is is not true

245
00:09:51,680 --> 00:09:54,160
meaning code running outside of smm

246
00:09:54,160 --> 00:09:56,640
can't read write your data

247
00:09:56,640 --> 00:09:58,560
other such superpowers include the

248
00:09:58,560 --> 00:10:01,040
ability to read and write all the msl

249
00:10:01,040 --> 00:10:03,519
supported by the platform and also the

250
00:10:03,519 --> 00:10:04,959
ability to

251
00:10:04,959 --> 00:10:07,440
write the bios region found on the spi

252
00:10:07,440 --> 00:10:09,360
flash memory which

253
00:10:09,360 --> 00:10:11,279
basically means you can do a firmware

254
00:10:11,279 --> 00:10:14,399
update using this mode

255
00:10:14,399 --> 00:10:17,279
so in a typical attack scenario our goal

256
00:10:17,279 --> 00:10:19,279
would be to elevate our privileges to

257
00:10:19,279 --> 00:10:22,000
ring -2 that is smm

258
00:10:22,000 --> 00:10:23,680
one assumption we are going to make is

259
00:10:23,680 --> 00:10:25,440
that we are already running with ring

260
00:10:25,440 --> 00:10:28,160
zero privileges so that is kernel mode

261
00:10:28,160 --> 00:10:30,000
and the reason we make this assumption

262
00:10:30,000 --> 00:10:32,560
is that it lets us freely issue software

263
00:10:32,560 --> 00:10:34,959
smi's and that's going to make our life

264
00:10:34,959 --> 00:10:37,040
a bit easier

265
00:10:37,040 --> 00:10:38,320
so the

266
00:10:38,320 --> 00:10:40,320
attack vector we are going to use is

267
00:10:40,320 --> 00:10:43,120
what is known as a confused deputy

268
00:10:43,120 --> 00:10:44,640
attack against

269
00:10:44,640 --> 00:10:47,440
smm so basically we're going to trick

270
00:10:47,440 --> 00:10:50,079
the privileged smi handler in order to

271
00:10:50,079 --> 00:10:52,720
corrupt or otherwise modify the contents

272
00:10:52,720 --> 00:10:55,600
of smr in unexpected ways

273
00:10:55,600 --> 00:10:58,240
combined into a full attack

274
00:10:58,240 --> 00:11:00,240
we will begin by first hunting down

275
00:11:00,240 --> 00:11:03,279
these smrum corruption vulnerabilities

276
00:11:03,279 --> 00:11:05,120
exploit them in order to actually

277
00:11:05,120 --> 00:11:06,720
corrupt memory

278
00:11:06,720 --> 00:11:08,959
using the memory corruption we will

279
00:11:08,959 --> 00:11:10,560
slowly build stronger and stronger

280
00:11:10,560 --> 00:11:12,720
primitives until we eventually manage to

281
00:11:12,720 --> 00:11:16,720
hijack a control flow and finally we can

282
00:11:16,720 --> 00:11:19,440
run our payload which can be anything

283
00:11:19,440 --> 00:11:20,640
from

284
00:11:20,640 --> 00:11:24,000
installing a very stealthy smm backdoor

285
00:11:24,000 --> 00:11:25,920
maybe refreshing the bios in order to

286
00:11:25,920 --> 00:11:27,440
gain persistence

287
00:11:27,440 --> 00:11:29,600
or maybe just

288
00:11:29,600 --> 00:11:32,640
infecting the hypervisor or any nested

289
00:11:32,640 --> 00:11:36,240
or any vm it currently hosts

290
00:11:36,240 --> 00:11:38,240
still for the duration of this talk

291
00:11:38,240 --> 00:11:40,480
we're only going to focus on the first

292
00:11:40,480 --> 00:11:42,480
part that is hunting down the

293
00:11:42,480 --> 00:11:44,399
vulnerabilities

294
00:11:44,399 --> 00:11:46,399
so to effectively hunt down the

295
00:11:46,399 --> 00:11:48,480
vulnerabilities we have to analyze the

296
00:11:48,480 --> 00:11:50,320
potential attack surface

297
00:11:50,320 --> 00:11:52,399
so if you remember in the first part we

298
00:11:52,399 --> 00:11:54,240
went through the process of invoking an

299
00:11:54,240 --> 00:11:57,760
smi from a uefi environment

300
00:11:57,760 --> 00:12:00,639
but the truth is we can simply replicate

301
00:12:00,639 --> 00:12:02,480
all these steps from

302
00:12:02,480 --> 00:12:04,959
a live operating system long after the

303
00:12:04,959 --> 00:12:07,680
boot process has finished

304
00:12:07,680 --> 00:12:09,519
and luckily for us we don't even have to

305
00:12:09,519 --> 00:12:12,639
do all these steps ourselves because

306
00:12:12,639 --> 00:12:14,880
chipset already has a built-in command

307
00:12:14,880 --> 00:12:16,079
for it

308
00:12:16,079 --> 00:12:17,440
so this command receives a lot of

309
00:12:17,440 --> 00:12:20,079
parameters the most important ones for

310
00:12:20,079 --> 00:12:21,519
our discussion

311
00:12:21,519 --> 00:12:24,399
are the good identifying the handler we

312
00:12:24,399 --> 00:12:26,160
want to call

313
00:12:26,160 --> 00:12:28,880
the address of the communication buffer

314
00:12:28,880 --> 00:12:31,519
in physical memory and the contents of

315
00:12:31,519 --> 00:12:33,279
the communication buffer so these three

316
00:12:33,279 --> 00:12:35,600
parameters together form the basis of

317
00:12:35,600 --> 00:12:39,760
what would be our attack surface

318
00:12:39,760 --> 00:12:41,920
now since the filmer wants to protect

319
00:12:41,920 --> 00:12:43,839
sm1 against corruption there are

320
00:12:43,839 --> 00:12:46,480
obviously some restrictions to that so

321
00:12:46,480 --> 00:12:48,639
one obvious restriction is that the

322
00:12:48,639 --> 00:12:50,800
communication buffer cannot overlap with

323
00:12:50,800 --> 00:12:53,040
smram because if that wasn't the case

324
00:12:53,040 --> 00:12:55,200
co-opting sm memory would be

325
00:12:55,200 --> 00:12:57,200
a trivially

326
00:12:57,200 --> 00:12:59,519
a trivial task

327
00:12:59,519 --> 00:13:02,399
now in order to enforce this the smm

328
00:13:02,399 --> 00:13:05,279
entry point calls a function called

329
00:13:05,279 --> 00:13:08,079
is buffer outside smm valid to make sure

330
00:13:08,079 --> 00:13:10,320
that chrome buffer does not overlap with

331
00:13:10,320 --> 00:13:13,760
smram in any way and if this check fails

332
00:13:13,760 --> 00:13:15,040
the

333
00:13:15,040 --> 00:13:17,440
smi simply returns an access denied

334
00:13:17,440 --> 00:13:20,079
status to the caller

335
00:13:20,079 --> 00:13:21,040
now

336
00:13:21,040 --> 00:13:24,959
some fully written smi handlers

337
00:13:24,959 --> 00:13:26,880
may allow you to

338
00:13:26,880 --> 00:13:29,120
sometimes bypass this restriction and

339
00:13:29,120 --> 00:13:31,440
with that in mind let's go on to the

340
00:13:31,440 --> 00:13:34,920
first backlash

341
00:13:35,519 --> 00:13:36,320
so

342
00:13:36,320 --> 00:13:38,959
here i have a really simple smi handler

343
00:13:38,959 --> 00:13:42,079
you can see that all it does is reading

344
00:13:42,079 --> 00:13:45,199
some msr computing a 64-bit value out of

345
00:13:45,199 --> 00:13:47,600
it and then writing the result into the

346
00:13:47,600 --> 00:13:50,240
into the communication buffer now notice

347
00:13:50,240 --> 00:13:52,160
that while doing so the handler

348
00:13:52,160 --> 00:13:54,079
implicitly assumes that the

349
00:13:54,079 --> 00:13:56,079
communication buffer is at least eight

350
00:13:56,079 --> 00:13:59,199
bytes long but unfortunately this check

351
00:13:59,199 --> 00:14:01,600
is not enforced explicitly anywhere in

352
00:14:01,600 --> 00:14:02,880
the code

353
00:14:02,880 --> 00:14:05,199
so let's see how an attacker

354
00:14:05,199 --> 00:14:07,279
can exploit

355
00:14:07,279 --> 00:14:08,720
this condition

356
00:14:08,720 --> 00:14:10,560
so in order to exploit this condition

357
00:14:10,560 --> 00:14:12,079
the attacker would like to place the

358
00:14:12,079 --> 00:14:14,399
communication buffer in a memory

359
00:14:14,399 --> 00:14:16,639
location as adjacent as possible to the

360
00:14:16,639 --> 00:14:19,680
base of smram so in this particular case

361
00:14:19,680 --> 00:14:22,639
we set it to be sm1 base -1 and set the

362
00:14:22,639 --> 00:14:25,760
respective size to be just one byte

363
00:14:25,760 --> 00:14:28,000
now the attacker will move on to trigger

364
00:14:28,000 --> 00:14:31,199
the vulnerable smi but first the smm

365
00:14:31,199 --> 00:14:33,279
entry point will be called

366
00:14:33,279 --> 00:14:34,800
it will validate

367
00:14:34,800 --> 00:14:37,199
using smm's buffer outside the smn valid

368
00:14:37,199 --> 00:14:38,959
that the com buffer does not overlap

369
00:14:38,959 --> 00:14:40,480
with smr

370
00:14:40,480 --> 00:14:42,959
and since technically it doesn't

371
00:14:42,959 --> 00:14:45,839
this check will be successful and the

372
00:14:45,839 --> 00:14:47,839
actual handler will be called

373
00:14:47,839 --> 00:14:50,079
now even though the size of the

374
00:14:50,079 --> 00:14:52,639
communication buffer is just one byte

375
00:14:52,639 --> 00:14:54,639
the handler will completely ignore this

376
00:14:54,639 --> 00:14:56,800
and just blindly write a keyword value

377
00:14:56,800 --> 00:14:59,760
into it and by doing so it will also

378
00:14:59,760 --> 00:15:01,760
going to corrupt the lower seven bytes

379
00:15:01,760 --> 00:15:06,480
of smart which is definitely a bad thing

380
00:15:06,560 --> 00:15:07,440
so

381
00:15:07,440 --> 00:15:09,839
the mitigation for this is pretty simple

382
00:15:09,839 --> 00:15:11,760
basically the handler should always

383
00:15:11,760 --> 00:15:13,360
explicitly

384
00:15:13,360 --> 00:15:14,800
check the size of the communication

385
00:15:14,800 --> 00:15:16,800
buffer and not make any implicit

386
00:15:16,800 --> 00:15:19,680
assumptions about it if the size of the

387
00:15:19,680 --> 00:15:22,560
header size of the buffer

388
00:15:22,560 --> 00:15:24,160
if the actual size differs from the

389
00:15:24,160 --> 00:15:26,720
expected size the handle should just

390
00:15:26,720 --> 00:15:30,000
bail out without doing anything

391
00:15:30,000 --> 00:15:31,519
so

392
00:15:31,519 --> 00:15:33,199
the

393
00:15:33,199 --> 00:15:35,360
bug that i just showed you has some

394
00:15:35,360 --> 00:15:38,079
obvious limitations the most important

395
00:15:38,079 --> 00:15:39,360
one is that we

396
00:15:39,360 --> 00:15:41,360
don't control where the corruption takes

397
00:15:41,360 --> 00:15:43,759
place well pretty limited with that and

398
00:15:43,759 --> 00:15:45,199
if we want to

399
00:15:45,199 --> 00:15:46,959
find a stronger primitive we should be

400
00:15:46,959 --> 00:15:48,399
looking for other types of

401
00:15:48,399 --> 00:15:50,800
vulnerabilities so here i have the

402
00:15:50,800 --> 00:15:53,920
second smi handler and this one begins

403
00:15:53,920 --> 00:15:56,800
by taking the first field of out of the

404
00:15:56,800 --> 00:16:00,079
communication buffer and treating it as

405
00:16:00,079 --> 00:16:02,160
some kind of an operation code that

406
00:16:02,160 --> 00:16:05,120
tells the handler what it should do next

407
00:16:05,120 --> 00:16:07,199
and we can see that the valid values for

408
00:16:07,199 --> 00:16:11,040
this op code field are either zero two

409
00:16:11,040 --> 00:16:12,160
or three

410
00:16:12,160 --> 00:16:14,639
and if the actual value differs in some

411
00:16:14,639 --> 00:16:16,720
way then the default clause will be

412
00:16:16,720 --> 00:16:18,399
executed and the default clause is

413
00:16:18,399 --> 00:16:20,240
pretty interesting

414
00:16:20,240 --> 00:16:21,199
because

415
00:16:21,199 --> 00:16:22,800
it takes the second field out of the

416
00:16:22,800 --> 00:16:25,279
comm buffer interprets it

417
00:16:25,279 --> 00:16:27,440
as a pointer and then writes the status

418
00:16:27,440 --> 00:16:30,639
variable to the pointed memory location

419
00:16:30,639 --> 00:16:33,360
so in order to exploit this condition

420
00:16:33,360 --> 00:16:35,360
the attacker would first craft a

421
00:16:35,360 --> 00:16:38,800
communication buffer write it to a

422
00:16:38,800 --> 00:16:40,639
location in physical memory accessible

423
00:16:40,639 --> 00:16:43,839
to him that is outside of smram and then

424
00:16:43,839 --> 00:16:45,279
just like before

425
00:16:45,279 --> 00:16:46,880
we'll move on to trigger the vulnerable

426
00:16:46,880 --> 00:16:48,480
smi

427
00:16:48,480 --> 00:16:50,800
the smi will first inspect the operation

428
00:16:50,800 --> 00:16:52,480
code field to determine what it should

429
00:16:52,480 --> 00:16:53,600
do next

430
00:16:53,600 --> 00:16:55,120
but since this field is under the

431
00:16:55,120 --> 00:16:57,360
attacker's control he can choose an

432
00:16:57,360 --> 00:16:59,600
invalid value and therefore force the

433
00:16:59,600 --> 00:17:02,079
handler to go into the default clause

434
00:17:02,079 --> 00:17:04,160
in the default clause the handler will

435
00:17:04,160 --> 00:17:06,400
fetch an address out of the com buffer

436
00:17:06,400 --> 00:17:08,720
and write to the pointed memory and

437
00:17:08,720 --> 00:17:10,559
since this address field is also under

438
00:17:10,559 --> 00:17:12,559
the attacker's control he can choose an

439
00:17:12,559 --> 00:17:14,319
address that resides in smram and

440
00:17:14,319 --> 00:17:17,280
therefore cause corruption

441
00:17:17,280 --> 00:17:19,839
so the moral of this story is that smi

442
00:17:19,839 --> 00:17:21,599
handlers must always

443
00:17:21,599 --> 00:17:23,839
validate pointers that are nested within

444
00:17:23,839 --> 00:17:26,319
the communication buffer and to do so

445
00:17:26,319 --> 00:17:28,400
they can just call the smms buffer

446
00:17:28,400 --> 00:17:30,080
outside the smm valid function that we

447
00:17:30,080 --> 00:17:33,440
are already familiar with

448
00:17:33,440 --> 00:17:34,640
sometimes

449
00:17:34,640 --> 00:17:36,720
even calling smm's buffer outside smm

450
00:17:36,720 --> 00:17:38,720
valley the nested pointers is not enough

451
00:17:38,720 --> 00:17:40,960
to make the handler fully secure

452
00:17:40,960 --> 00:17:43,360
so this is a snippet from the further

453
00:17:43,360 --> 00:17:46,880
semi handler and this one begins by uh

454
00:17:46,880 --> 00:17:48,880
copying a certain field from the

455
00:17:48,880 --> 00:17:51,520
combustor into a local variable

456
00:17:51,520 --> 00:17:52,960
in smm

457
00:17:52,960 --> 00:17:55,440
and since the developers were security

458
00:17:55,440 --> 00:17:58,640
aware they validate this pointer using

459
00:17:58,640 --> 00:18:01,600
smm's buffer outside smm valid and if

460
00:18:01,600 --> 00:18:03,760
this check passes

461
00:18:03,760 --> 00:18:05,919
and they feel confident enough to copy

462
00:18:05,919 --> 00:18:08,480
some memory to the pointed

463
00:18:08,480 --> 00:18:09,679
location

464
00:18:09,679 --> 00:18:11,600
now the cracks in identifying this

465
00:18:11,600 --> 00:18:14,240
vulnerability is to notice that while

466
00:18:14,240 --> 00:18:16,559
the call to smm is buffer outside smm

467
00:18:16,559 --> 00:18:19,840
valid is done using the local variable

468
00:18:19,840 --> 00:18:21,200
in smm

469
00:18:21,200 --> 00:18:24,320
the call to copy mem is done using the

470
00:18:24,320 --> 00:18:26,480
field value which is fetched again from

471
00:18:26,480 --> 00:18:28,720
the com buffer so there is actually a

472
00:18:28,720 --> 00:18:30,640
double fetch issue here

473
00:18:30,640 --> 00:18:32,400
that might be subject to a time of check

474
00:18:32,400 --> 00:18:34,880
time of use attack

475
00:18:34,880 --> 00:18:35,840
so

476
00:18:35,840 --> 00:18:38,080
in order to exploit this condition the

477
00:18:38,080 --> 00:18:39,840
attacker would first write the

478
00:18:39,840 --> 00:18:41,840
communication buffer to memory and at

479
00:18:41,840 --> 00:18:44,090
this point the point of field

480
00:18:44,090 --> 00:18:45,200
[Applause]

481
00:18:45,200 --> 00:18:47,840
is safe meaning that it points to an

482
00:18:47,840 --> 00:18:50,160
object outside of smram

483
00:18:50,160 --> 00:18:52,320
and then just like before the smi

484
00:18:52,320 --> 00:18:54,480
handler will be invoked one of the first

485
00:18:54,480 --> 00:18:57,520
thing it's going to do is copy the field

486
00:18:57,520 --> 00:19:00,400
from the comm buffer into smram and at

487
00:19:00,400 --> 00:19:02,000
this point both pointers are

488
00:19:02,000 --> 00:19:04,080
synchronized meaning they point to the

489
00:19:04,080 --> 00:19:07,600
exact same object in memory

490
00:19:07,600 --> 00:19:10,240
now the call to smm is buffer outside

491
00:19:10,240 --> 00:19:13,039
smm valid is made and since the pointed

492
00:19:13,039 --> 00:19:15,520
object resides outside of smram it will

493
00:19:15,520 --> 00:19:18,559
be completed successfully

494
00:19:18,559 --> 00:19:20,640
now an important thing to understand is

495
00:19:20,640 --> 00:19:21,440
that

496
00:19:21,440 --> 00:19:23,679
smm wasn't designed with concurrency in

497
00:19:23,679 --> 00:19:27,120
mind so that means that while one cpu is

498
00:19:27,120 --> 00:19:30,880
busy servicing the smi interrupts

499
00:19:30,880 --> 00:19:32,799
all the other cpus are going to enter

500
00:19:32,799 --> 00:19:35,280
smm and wait for the first one to to

501
00:19:35,280 --> 00:19:36,160
finish

502
00:19:36,160 --> 00:19:38,480
so that means the attacker can't utilize

503
00:19:38,480 --> 00:19:40,320
any of the other cpus present in the

504
00:19:40,320 --> 00:19:42,640
system in order to modify the contents

505
00:19:42,640 --> 00:19:44,480
of the combat film

506
00:19:44,480 --> 00:19:47,120
but it is still possible for an i o

507
00:19:47,120 --> 00:19:48,320
device

508
00:19:48,320 --> 00:19:51,840
to perform dma operations on main memory

509
00:19:51,840 --> 00:19:54,320
so that means a dma attack

510
00:19:54,320 --> 00:19:55,679
can

511
00:19:55,679 --> 00:19:56,720
simply

512
00:19:56,720 --> 00:19:58,320
change the contents of the communication

513
00:19:58,320 --> 00:20:00,960
buffer while the handler is executing

514
00:20:00,960 --> 00:20:03,039
and more specifically we can make the

515
00:20:03,039 --> 00:20:05,600
pointer field point somewhere else

516
00:20:05,600 --> 00:20:06,640
inside smrm

517
00:20:06,640 --> 00:20:07,919
[Music]

518
00:20:07,919 --> 00:20:11,039
now the handler will continue executing

519
00:20:11,039 --> 00:20:13,360
it will fetch again the pointer from the

520
00:20:13,360 --> 00:20:14,960
combat file and pass it as the

521
00:20:14,960 --> 00:20:16,880
destination argument to a copy mm

522
00:20:16,880 --> 00:20:19,760
operation and by doing so it is going to

523
00:20:19,760 --> 00:20:23,919
corrupt some smr memory as well

524
00:20:24,080 --> 00:20:25,919
so um

525
00:20:25,919 --> 00:20:27,120
in order to

526
00:20:27,120 --> 00:20:29,039
prevent these issues

527
00:20:29,039 --> 00:20:31,360
um we should follow some simple

528
00:20:31,360 --> 00:20:32,480
guidelines

529
00:20:32,480 --> 00:20:34,880
um basically double fetches from the com

530
00:20:34,880 --> 00:20:36,880
buffer are considered to be dangerous

531
00:20:36,880 --> 00:20:39,200
and if the chrome buffer contains any

532
00:20:39,200 --> 00:20:41,679
sensitive field such as pointers they

533
00:20:41,679 --> 00:20:44,320
must be copied into local variables in

534
00:20:44,320 --> 00:20:47,039
smram and from that point onwards only

535
00:20:47,039 --> 00:20:50,640
the smm local copies should be used

536
00:20:50,640 --> 00:20:52,559
so now let's move on to the third and

537
00:20:52,559 --> 00:20:54,320
final part of the talk

538
00:20:54,320 --> 00:20:55,200
well

539
00:20:55,200 --> 00:20:58,159
we will talk about a small tool we wrote

540
00:20:58,159 --> 00:21:00,159
called the brick

541
00:21:00,159 --> 00:21:00,880
so

542
00:21:00,880 --> 00:21:03,679
simply put brick is a static

543
00:21:03,679 --> 00:21:06,640
automated analysis tool that lets you

544
00:21:06,640 --> 00:21:08,720
easily hunt down some of the smm

545
00:21:08,720 --> 00:21:10,640
vulnerabilities that we just talked

546
00:21:10,640 --> 00:21:13,360
about this tool is primarily based on

547
00:21:13,360 --> 00:21:16,559
ida and basing it on idea gives us two

548
00:21:16,559 --> 00:21:18,320
significant advantages

549
00:21:18,320 --> 00:21:20,159
so the first one

550
00:21:20,159 --> 00:21:21,039
is

551
00:21:21,039 --> 00:21:24,000
that we gain access to a really

552
00:21:24,000 --> 00:21:26,799
vast and rich ecosystem of different

553
00:21:26,799 --> 00:21:29,520
tools scripts plugins and so on so we

554
00:21:29,520 --> 00:21:32,080
can leverage these

555
00:21:32,080 --> 00:21:34,159
third-party tools in order to solve a

556
00:21:34,159 --> 00:21:36,559
lot of the challenges we are facing and

557
00:21:36,559 --> 00:21:39,200
the second one is that we gain access to

558
00:21:39,200 --> 00:21:41,520
the x-rays the compiler which means we

559
00:21:41,520 --> 00:21:44,880
can do all our analysis in a much higher

560
00:21:44,880 --> 00:21:46,400
level so instead of searching for

561
00:21:46,400 --> 00:21:47,760
vulnerabilities

562
00:21:47,760 --> 00:21:49,360
by

563
00:21:49,360 --> 00:21:52,400
analyzing assembly instructions we

564
00:21:52,400 --> 00:21:55,120
analyze the decompiled pseudo code and

565
00:21:55,120 --> 00:21:58,480
its associated st and so on and now

566
00:21:58,480 --> 00:22:02,960
let's move on to a quick demo i prepared

567
00:22:05,360 --> 00:22:07,840
okay

568
00:22:10,840 --> 00:22:14,720
so um here i have a directory with four

569
00:22:14,720 --> 00:22:15,760
smm

570
00:22:15,760 --> 00:22:16,880
binaries

571
00:22:16,880 --> 00:22:19,200
so of course if i want to scan them for

572
00:22:19,200 --> 00:22:22,480
vulnerabilities i can do it manually

573
00:22:22,480 --> 00:22:23,840
but

574
00:22:23,840 --> 00:22:26,240
the problem with a manual approach is

575
00:22:26,240 --> 00:22:28,559
that it's not scalable in any way and

576
00:22:28,559 --> 00:22:30,000
that wouldn't be feasible if the

577
00:22:30,000 --> 00:22:31,919
directory contained for example 40

578
00:22:31,919 --> 00:22:34,880
models and that's exactly where brick

579
00:22:34,880 --> 00:22:36,640
comes into play

580
00:22:36,640 --> 00:22:37,840
so

581
00:22:37,840 --> 00:22:40,240
instructing brick to scan the directory

582
00:22:40,240 --> 00:22:42,000
is just a matter of running this really

583
00:22:42,000 --> 00:22:43,039
simple

584
00:22:43,039 --> 00:22:44,640
python command line

585
00:22:44,640 --> 00:22:46,240
so let's

586
00:22:46,240 --> 00:22:47,360
run it and

587
00:22:47,360 --> 00:22:50,678
see what happens

588
00:22:51,560 --> 00:22:54,700
[Music]

589
00:23:12,559 --> 00:23:14,880
so basically right now

590
00:23:14,880 --> 00:23:17,840
all the images were opened up in ida and

591
00:23:17,840 --> 00:23:19,600
after the initial auto analysis is

592
00:23:19,600 --> 00:23:20,640
complete

593
00:23:20,640 --> 00:23:22,640
we move on to the second phase where we

594
00:23:22,640 --> 00:23:24,880
run a bunch of heuristics in order to

595
00:23:24,880 --> 00:23:27,520
pinpoint the potential vulnerabilities

596
00:23:27,520 --> 00:23:28,640
and

597
00:23:28,640 --> 00:23:29,919
we should be

598
00:23:29,919 --> 00:23:31,840
done in a couple of

599
00:23:31,840 --> 00:23:35,320
seconds hopefully

600
00:23:46,159 --> 00:23:47,039
um

601
00:23:47,039 --> 00:23:49,360
we're already done so

602
00:23:49,360 --> 00:23:52,080
sorry for that

603
00:23:52,480 --> 00:23:54,720
um okay so

604
00:23:54,720 --> 00:23:57,520
yeah once brick finishes scanning the

605
00:23:57,520 --> 00:24:00,000
directory it is going to output all its

606
00:24:00,000 --> 00:24:03,120
findings in an html report so let's open

607
00:24:03,120 --> 00:24:05,039
up this one and see what the findings

608
00:24:05,039 --> 00:24:07,200
are

609
00:24:15,200 --> 00:24:18,919
can everyone see the font

610
00:24:20,640 --> 00:24:23,760
okay so the output of this tool is a bit

611
00:24:23,760 --> 00:24:25,919
dense and it does take some time to be

612
00:24:25,919 --> 00:24:27,919
able to interpret it

613
00:24:27,919 --> 00:24:30,320
efficiently but the general rule of

614
00:24:30,320 --> 00:24:32,320
thumb is that you should always start by

615
00:24:32,320 --> 00:24:34,000
looking at the lines highlighted in red

616
00:24:34,000 --> 00:24:36,000
because these are the

617
00:24:36,000 --> 00:24:37,600
potential vulnerabilities that were

618
00:24:37,600 --> 00:24:39,200
spotted with the

619
00:24:39,200 --> 00:24:40,559
um

620
00:24:40,559 --> 00:24:42,640
with the most accuracy

621
00:24:42,640 --> 00:24:45,760
so in the first

622
00:24:45,760 --> 00:24:48,880
smm image we can see a brick managed to

623
00:24:48,880 --> 00:24:51,039
spot an smi handler that does not check

624
00:24:51,039 --> 00:24:53,279
the size of the com buffer and therefore

625
00:24:53,279 --> 00:24:54,480
it suggests

626
00:24:54,480 --> 00:24:56,320
we will check it to see if we can make

627
00:24:56,320 --> 00:24:59,039
it somehow overlap with smram

628
00:24:59,039 --> 00:25:04,080
so let's open up the associated idb

629
00:25:13,520 --> 00:25:16,080
okay so here we have a really simple smi

630
00:25:16,080 --> 00:25:17,120
handler

631
00:25:17,120 --> 00:25:18,960
we can see that

632
00:25:18,960 --> 00:25:20,480
all it does

633
00:25:20,480 --> 00:25:22,080
is comparing the first field of the

634
00:25:22,080 --> 00:25:23,840
combustor against some

635
00:25:23,840 --> 00:25:25,919
magic signature and if the signature

636
00:25:25,919 --> 00:25:27,200
matches

637
00:25:27,200 --> 00:25:29,440
some function gets called and the result

638
00:25:29,440 --> 00:25:31,679
is immediately written into another

639
00:25:31,679 --> 00:25:34,000
field in the combustion now notice that

640
00:25:34,000 --> 00:25:36,320
indeed the size of the com buffer is not

641
00:25:36,320 --> 00:25:38,960
referenced in any meaningful way and

642
00:25:38,960 --> 00:25:40,880
that means that if we manage to place

643
00:25:40,880 --> 00:25:44,559
the comb buffer just below smram this

644
00:25:44,559 --> 00:25:46,559
field access here will actually corrupt

645
00:25:46,559 --> 00:25:48,400
smr memory so that's actually a pretty

646
00:25:48,400 --> 00:25:49,360
good

647
00:25:49,360 --> 00:25:52,399
corruption primitive

648
00:25:52,799 --> 00:25:53,840
now

649
00:25:53,840 --> 00:25:56,640
the second smi smm image suffers from

650
00:25:56,640 --> 00:25:59,120
another issue we can see

651
00:25:59,120 --> 00:26:03,039
there is a certain handler that

652
00:26:03,039 --> 00:26:05,200
fetches the same field twice and

653
00:26:05,200 --> 00:26:07,279
therefore brick tells us that this might

654
00:26:07,279 --> 00:26:08,799
be subject to a time of check time of

655
00:26:08,799 --> 00:26:11,120
fuse attack so let's validate this

656
00:26:11,120 --> 00:26:14,600
finding also

657
00:26:30,960 --> 00:26:33,520
okay so indeed we can see field 18 is

658
00:26:33,520 --> 00:26:35,919
being fetched twice and now just to make

659
00:26:35,919 --> 00:26:39,039
analysis a bit easier let's rename this

660
00:26:39,039 --> 00:26:42,320
one here to be field 18

661
00:26:42,320 --> 00:26:45,440
a and let's rename this one to be

662
00:26:45,440 --> 00:26:47,279
smm field

663
00:26:47,279 --> 00:26:49,200
18 b

664
00:26:49,200 --> 00:26:52,000
and notice that while the validation

665
00:26:52,000 --> 00:26:55,360
using smm is buffer outside smm valid is

666
00:26:55,360 --> 00:26:58,400
done using smm field 18 b

667
00:26:58,400 --> 00:27:00,559
the call to the following function at 9

668
00:27:00,559 --> 00:27:04,240
fc is done using field 18a

669
00:27:04,240 --> 00:27:08,000
so that means that in a potential attack

670
00:27:08,000 --> 00:27:10,640
we can issue this smi with field 18

671
00:27:10,640 --> 00:27:13,679
pointing to smr memory this value will

672
00:27:13,679 --> 00:27:16,480
be saved into field 18a

673
00:27:16,480 --> 00:27:18,399
and just before it is being fetched

674
00:27:18,399 --> 00:27:22,000
again into smm field 18b a dma attack

675
00:27:22,000 --> 00:27:24,640
can modify the original field in the

676
00:27:24,640 --> 00:27:27,200
comm buffer to point to a

677
00:27:27,200 --> 00:27:30,240
supposedly safe location outside of sm1

678
00:27:30,240 --> 00:27:32,640
so that will make the validation at

679
00:27:32,640 --> 00:27:34,799
smm's buffer outside smm value to be

680
00:27:34,799 --> 00:27:35,919
successful

681
00:27:35,919 --> 00:27:38,320
and function9fc will be called with a

682
00:27:38,320 --> 00:27:40,720
pointer argument pointing to smart which

683
00:27:40,720 --> 00:27:43,120
is unexpected so under the hood we can

684
00:27:43,120 --> 00:27:44,799
see this function is basically a wrapper

685
00:27:44,799 --> 00:27:46,880
around copy mems so once again we

686
00:27:46,880 --> 00:27:49,440
managed to find a cool memory corruption

687
00:27:49,440 --> 00:27:51,919
primitive

688
00:27:53,679 --> 00:27:55,120
so

689
00:27:55,120 --> 00:27:57,760
the third image has an smi handler that

690
00:27:57,760 --> 00:28:00,640
suffers from two distinct issues

691
00:28:00,640 --> 00:28:02,880
one of them we already saw the handle

692
00:28:02,880 --> 00:28:04,880
that does not validate the size of the

693
00:28:04,880 --> 00:28:07,200
comb buffer but this one

694
00:28:07,200 --> 00:28:09,679
also does not validate pointers that are

695
00:28:09,679 --> 00:28:12,159
nested within the communication buffer

696
00:28:12,159 --> 00:28:13,919
so

697
00:28:13,919 --> 00:28:17,840
let's open up the idb

698
00:28:25,600 --> 00:28:27,440
so once again a really simple smi

699
00:28:27,440 --> 00:28:29,200
handler

700
00:28:29,200 --> 00:28:32,320
the the logic here is really minimal

701
00:28:32,320 --> 00:28:35,679
what this smi handler does is taking the

702
00:28:35,679 --> 00:28:37,200
first field out of the communication

703
00:28:37,200 --> 00:28:40,720
buffer and simply copying it into a

704
00:28:40,720 --> 00:28:43,200
local variable called baffle notice that

705
00:28:43,200 --> 00:28:45,279
indeed no validation over this field

706
00:28:45,279 --> 00:28:48,080
takes place which means we can set

707
00:28:48,080 --> 00:28:50,720
the global variable to any address we

708
00:28:50,720 --> 00:28:54,320
would like including addresses in smram

709
00:28:54,320 --> 00:28:55,280
to

710
00:28:55,280 --> 00:28:56,399
[Applause]

711
00:28:56,399 --> 00:28:58,399
determine whether or not we can actually

712
00:28:58,399 --> 00:29:00,720
exploit this we should be looking at the

713
00:29:00,720 --> 00:29:03,200
places where this buffer variable is

714
00:29:03,200 --> 00:29:05,760
consumed so let's very briefly go to one

715
00:29:05,760 --> 00:29:06,640
of the

716
00:29:06,640 --> 00:29:07,919
xrefs

717
00:29:07,919 --> 00:29:09,360
um

718
00:29:09,360 --> 00:29:12,000
so in this function we see a buffer is

719
00:29:12,000 --> 00:29:14,480
being forwarded into yet another

720
00:29:14,480 --> 00:29:17,520
function with some constant integer

721
00:29:17,520 --> 00:29:19,760
and this function

722
00:29:19,760 --> 00:29:21,919
under the hood will basically just zero

723
00:29:21,919 --> 00:29:25,039
down the entire memory range so

724
00:29:25,039 --> 00:29:27,120
also a pretty powerful memory corruption

725
00:29:27,120 --> 00:29:29,600
primitive

726
00:29:30,559 --> 00:29:32,000
now the

727
00:29:32,000 --> 00:29:34,240
fourth and last module

728
00:29:34,240 --> 00:29:36,480
we get some a different result this one

729
00:29:36,480 --> 00:29:38,880
seems to be completely resilient to all

730
00:29:38,880 --> 00:29:41,360
the attacks we just described and

731
00:29:41,360 --> 00:29:42,640
actually that shouldn't come as a

732
00:29:42,640 --> 00:29:45,520
surprise because if you see here

733
00:29:45,520 --> 00:29:48,159
brick tells us that this module actually

734
00:29:48,159 --> 00:29:49,600
comes from

735
00:29:49,600 --> 00:29:51,279
edk2 which is the reference

736
00:29:51,279 --> 00:29:53,760
implementation of uefi and generally

737
00:29:53,760 --> 00:29:55,919
speaking the code quality of the

738
00:29:55,919 --> 00:29:58,000
reference code is much higher compared

739
00:29:58,000 --> 00:30:00,240
to the code written by the bios vendors

740
00:30:00,240 --> 00:30:03,720
and oems

741
00:30:09,200 --> 00:30:12,200
sorry

742
00:30:27,120 --> 00:30:32,039
yeah i accidentally closed the slider

743
00:30:37,520 --> 00:30:40,520
uh

744
00:31:07,360 --> 00:31:09,760
okay so after we saw breaking action

745
00:31:09,760 --> 00:31:11,760
let's talk a bit about how the tool

746
00:31:11,760 --> 00:31:14,159
works under the hood so when running

747
00:31:14,159 --> 00:31:16,720
brick we have three different phases

748
00:31:16,720 --> 00:31:19,200
first we have the harvest phase followed

749
00:31:19,200 --> 00:31:21,200
by the analysis phase and finally we

750
00:31:21,200 --> 00:31:25,200
conclude with a summary phase

751
00:31:25,679 --> 00:31:28,880
so in the harvest phase we basically

752
00:31:28,880 --> 00:31:30,960
give brick some input object that

753
00:31:30,960 --> 00:31:33,360
somehow encapsulates the smm binaries we

754
00:31:33,360 --> 00:31:35,840
want to scan so in the demo that was

755
00:31:35,840 --> 00:31:38,080
just a plain directory but that can also

756
00:31:38,080 --> 00:31:39,760
be a more

757
00:31:39,760 --> 00:31:42,799
natural object such as an spi dump a

758
00:31:42,799 --> 00:31:45,600
uefi capsule update and maybe an entire

759
00:31:45,600 --> 00:31:47,440
bios image you downloaded from the

760
00:31:47,440 --> 00:31:50,480
vendor's website and so on and so on

761
00:31:50,480 --> 00:31:51,760
then brick will leverage some

762
00:31:51,760 --> 00:31:54,559
third-party tools such as a uefi extract

763
00:31:54,559 --> 00:31:57,279
or a library known as the uefi thermo

764
00:31:57,279 --> 00:32:00,640
parser in order to extract all the smm

765
00:32:00,640 --> 00:32:03,360
images and then it will just dump them

766
00:32:03,360 --> 00:32:06,159
to a dedicated directory

767
00:32:06,159 --> 00:32:08,559
next comes the analysis phase so in this

768
00:32:08,559 --> 00:32:09,519
phase

769
00:32:09,519 --> 00:32:12,720
each smm image is opened up in ida and

770
00:32:12,720 --> 00:32:14,399
after the initial auto analysis is

771
00:32:14,399 --> 00:32:16,000
complete

772
00:32:16,000 --> 00:32:18,000
each image goes through a set of

773
00:32:18,000 --> 00:32:19,440
different

774
00:32:19,440 --> 00:32:20,480
modules

775
00:32:20,480 --> 00:32:22,960
so these models are basically divided

776
00:32:22,960 --> 00:32:25,519
into three categories first we have the

777
00:32:25,519 --> 00:32:27,919
processing modules which merely do some

778
00:32:27,919 --> 00:32:29,840
processing over the idb

779
00:32:29,840 --> 00:32:32,159
then we have the analysis modules which

780
00:32:32,159 --> 00:32:34,320
are responsible for

781
00:32:34,320 --> 00:32:36,399
detecting and pinpointing potential

782
00:32:36,399 --> 00:32:39,279
vulnerabilities and finally we have

783
00:32:39,279 --> 00:32:41,600
informational models that

784
00:32:41,600 --> 00:32:43,519
emit some valuable information which

785
00:32:43,519 --> 00:32:45,440
isn't necessarily related to

786
00:32:45,440 --> 00:32:47,360
vulnerabilities

787
00:32:47,360 --> 00:32:49,039
now doing this entire process

788
00:32:49,039 --> 00:32:51,200
sequentially would obviously take

789
00:32:51,200 --> 00:32:53,200
a large amount of time

790
00:32:53,200 --> 00:32:55,679
and therefore in order to spin to speed

791
00:32:55,679 --> 00:32:58,000
things up we use a cool a tool called

792
00:32:58,000 --> 00:33:00,640
either hunt and either hand lets us

793
00:33:00,640 --> 00:33:01,679
spawn

794
00:33:01,679 --> 00:33:05,120
a number of concurrent either instances

795
00:33:05,120 --> 00:33:07,200
and therefore by parallelizing the

796
00:33:07,200 --> 00:33:09,840
entire process we make it much more much

797
00:33:09,840 --> 00:33:12,158
shorter

798
00:33:12,320 --> 00:33:15,440
um so each brick module is under the

799
00:33:15,440 --> 00:33:17,840
hood implemented just as an id python

800
00:33:17,840 --> 00:33:20,960
script but since the api of ida python

801
00:33:20,960 --> 00:33:23,679
can be a bit rough at times we don't use

802
00:33:23,679 --> 00:33:25,760
it directly but rather use a higher

803
00:33:25,760 --> 00:33:28,159
level framework called the beep

804
00:33:28,159 --> 00:33:30,000
and now like i said the models

805
00:33:30,000 --> 00:33:31,840
themselves can be divided into three

806
00:33:31,840 --> 00:33:34,480
categories the processing modules are

807
00:33:34,480 --> 00:33:37,200
mostly in charge of resolving

808
00:33:37,200 --> 00:33:40,559
some of the shenanigans of uefi such as

809
00:33:40,559 --> 00:33:42,320
the different service calls locating

810
00:33:42,320 --> 00:33:44,559
some of the global variables and so on

811
00:33:44,559 --> 00:33:46,240
and this

812
00:33:46,240 --> 00:33:48,480
these modules are mostly based on a

813
00:33:48,480 --> 00:33:50,880
plugin called efi explorer

814
00:33:50,880 --> 00:33:52,960
the informational models

815
00:33:52,960 --> 00:33:56,720
let you determine if the module if the

816
00:33:56,720 --> 00:33:59,760
image uses a uefi legacy protocol or

817
00:33:59,760 --> 00:34:01,519
whether or not it comes from reference

818
00:34:01,519 --> 00:34:04,559
implementation such as edk and finally

819
00:34:04,559 --> 00:34:06,399
the detection models are

820
00:34:06,399 --> 00:34:07,760
actually in charge of locating the

821
00:34:07,760 --> 00:34:10,480
vulnerabilities so we have one module

822
00:34:10,480 --> 00:34:12,639
per vulnerability class

823
00:34:12,639 --> 00:34:15,599
and all of these modules are implemented

824
00:34:15,599 --> 00:34:18,399
using pretty simple heuristics so just

825
00:34:18,399 --> 00:34:20,159
to get you a glimpse of what a heuristic

826
00:34:20,159 --> 00:34:22,320
look like let's take a look at the code

827
00:34:22,320 --> 00:34:24,000
responsible for

828
00:34:24,000 --> 00:34:25,918
detecting the usage of unsanitized

829
00:34:25,918 --> 00:34:27,839
nested pointers

830
00:34:27,839 --> 00:34:30,320
and basically we iterate over all the

831
00:34:30,320 --> 00:34:32,879
smi handlers installed by the image and

832
00:34:32,879 --> 00:34:35,918
then for each smi handler we check to

833
00:34:35,918 --> 00:34:38,079
see whether or not the communication

834
00:34:38,079 --> 00:34:40,560
buffer is consumed in any way if it is

835
00:34:40,560 --> 00:34:42,159
not we can assume the handle is

836
00:34:42,159 --> 00:34:44,000
implicitly safe and just move on to the

837
00:34:44,000 --> 00:34:45,280
next one

838
00:34:45,280 --> 00:34:47,839
if on the other hand the com buffer is

839
00:34:47,839 --> 00:34:52,000
being utilized we start to recursively

840
00:34:52,000 --> 00:34:54,159
scan the ast associated with the

841
00:34:54,159 --> 00:34:56,480
function and we are only interested in

842
00:34:56,480 --> 00:34:58,800
nodes that represents calls to other

843
00:34:58,800 --> 00:35:01,920
function and for each such node we ask

844
00:35:01,920 --> 00:35:03,440
to see

845
00:35:03,440 --> 00:35:05,280
whether the destination

846
00:35:05,280 --> 00:35:07,280
function is smm is buffer outside the

847
00:35:07,280 --> 00:35:09,920
smm valid so if we manage to find such

848
00:35:09,920 --> 00:35:12,880
call such node sorry

849
00:35:12,880 --> 00:35:14,960
we assume the handler is

850
00:35:14,960 --> 00:35:16,720
knows what

851
00:35:16,720 --> 00:35:20,000
what it is doing and we mark it to safe

852
00:35:20,000 --> 00:35:22,400
but if on the other hand no such node is

853
00:35:22,400 --> 00:35:23,440
found

854
00:35:23,440 --> 00:35:25,839
we conclude that

855
00:35:25,839 --> 00:35:28,960
the handler simply misses some critical

856
00:35:28,960 --> 00:35:31,040
validation and therefore we flag it as

857
00:35:31,040 --> 00:35:32,960
potentially vulnerable

858
00:35:32,960 --> 00:35:35,760
um but the heuristic i described so far

859
00:35:35,760 --> 00:35:37,040
is a bit too

860
00:35:37,040 --> 00:35:39,440
is a bit over simplistic and the reason

861
00:35:39,440 --> 00:35:41,599
for it is that a particular handler

862
00:35:41,599 --> 00:35:44,079
might not call smm's buffer outside some

863
00:35:44,079 --> 00:35:46,800
invalid simply because the communication

864
00:35:46,800 --> 00:35:49,200
buffer does not hold any nested pointers

865
00:35:49,200 --> 00:35:49,920
but

866
00:35:49,920 --> 00:35:52,160
rather other data types such as

867
00:35:52,160 --> 00:35:54,960
integers or boolean flags and so on

868
00:35:54,960 --> 00:35:56,480
so if we want to make detection more

869
00:35:56,480 --> 00:35:58,640
accurate we have to figure out the

870
00:35:58,640 --> 00:36:00,240
internal layout of the communication

871
00:36:00,240 --> 00:36:03,280
buffer and in order to do so we use yet

872
00:36:03,280 --> 00:36:05,440
another plug-in called the hex-rays code

873
00:36:05,440 --> 00:36:08,720
explorer that lets us reconstruct the

874
00:36:08,720 --> 00:36:11,280
structure of the comb buffer and if we

875
00:36:11,280 --> 00:36:13,359
see that the reconstructed structure

876
00:36:13,359 --> 00:36:15,680
holds members which are pointers by

877
00:36:15,680 --> 00:36:17,839
themselves that greatly boosts the

878
00:36:17,839 --> 00:36:19,440
confidence we have

879
00:36:19,440 --> 00:36:20,960
in the detection

880
00:36:20,960 --> 00:36:22,880
so the modified heuristic basically

881
00:36:22,880 --> 00:36:24,800
remains the same only takes this

882
00:36:24,800 --> 00:36:26,320
structural reconstruction thing into

883
00:36:26,320 --> 00:36:28,640
account

884
00:36:29,200 --> 00:36:31,920
so having really simple heuristics

885
00:36:31,920 --> 00:36:34,400
has a lot of advantages so they are easy

886
00:36:34,400 --> 00:36:36,800
to read to write to maintain and so on

887
00:36:36,800 --> 00:36:38,400
but that also means we are going to

888
00:36:38,400 --> 00:36:40,960
suffer from some false positives and

889
00:36:40,960 --> 00:36:42,960
false negatives as well because the

890
00:36:42,960 --> 00:36:45,200
world is more complicated than we have

891
00:36:45,200 --> 00:36:47,760
been than how we usually describe it

892
00:36:47,760 --> 00:36:51,520
and so when it comes to false positives

893
00:36:51,520 --> 00:36:53,680
um so it's important to understand that

894
00:36:53,680 --> 00:36:55,119
brick is

895
00:36:55,119 --> 00:36:57,280
mostly a helper tool it's not going to

896
00:36:57,280 --> 00:36:59,520
replace a human analyst and eventually a

897
00:36:59,520 --> 00:37:02,720
human analysis is required to determine

898
00:37:02,720 --> 00:37:06,079
if a particular result is is true or not

899
00:37:06,079 --> 00:37:07,920
and that means that as long as we keep

900
00:37:07,920 --> 00:37:10,079
the rate of the false positives below a

901
00:37:10,079 --> 00:37:12,000
certain pressure that is manageable by a

902
00:37:12,000 --> 00:37:14,880
human being that might be good enough

903
00:37:14,880 --> 00:37:17,200
and when it comes to false negatives uh

904
00:37:17,200 --> 00:37:19,119
it's important to note that the main use

905
00:37:19,119 --> 00:37:21,599
case of running brick

906
00:37:21,599 --> 00:37:22,960
is not scanning

907
00:37:22,960 --> 00:37:25,040
individual smm images like we did in the

908
00:37:25,040 --> 00:37:27,599
demo but rather scan

909
00:37:27,599 --> 00:37:30,480
an entire bios image with the intention

910
00:37:30,480 --> 00:37:32,000
of

911
00:37:32,000 --> 00:37:34,880
ultimately being able to compromise smm

912
00:37:34,880 --> 00:37:37,119
and for that the entire machine and in

913
00:37:37,119 --> 00:37:39,200
order to do so we don't necessarily have

914
00:37:39,200 --> 00:37:41,359
to find each and every vulnerability

915
00:37:41,359 --> 00:37:43,839
present in the bios but just finding a

916
00:37:43,839 --> 00:37:47,119
handful of them might be enough

917
00:37:47,119 --> 00:37:48,960
and so a bit about the results we got

918
00:37:48,960 --> 00:37:51,040
from this tool so far and so actually

919
00:37:51,040 --> 00:37:53,760
this uh slide is already

920
00:37:53,760 --> 00:37:56,079
out of date it's not a two cvs we

921
00:37:56,079 --> 00:37:59,040
already have free cvs using this tool so

922
00:37:59,040 --> 00:38:02,720
two are from lenovo and one from asus

923
00:38:02,720 --> 00:38:04,960
we also have about a dozen of other

924
00:38:04,960 --> 00:38:07,760
vulnerabilities that are

925
00:38:07,760 --> 00:38:09,440
stuck somewhere in the responsible

926
00:38:09,440 --> 00:38:11,760
disclosure pipeline so that means i

927
00:38:11,760 --> 00:38:12,640
can't

928
00:38:12,640 --> 00:38:14,880
say the names of the affected vendors

929
00:38:14,880 --> 00:38:17,119
but i can say that the list basically

930
00:38:17,119 --> 00:38:20,320
includes almost all the well-known names

931
00:38:20,320 --> 00:38:22,800
and oems you're familiar with and some

932
00:38:22,800 --> 00:38:24,160
of these bugs

933
00:38:24,160 --> 00:38:25,440
also

934
00:38:25,440 --> 00:38:26,800
affect

935
00:38:26,800 --> 00:38:29,040
parts of the reference code which is

936
00:38:29,040 --> 00:38:30,880
shared between multiple vendors so that

937
00:38:30,880 --> 00:38:35,520
means some of them have a broader impact

938
00:38:35,520 --> 00:38:36,880
so

939
00:38:36,880 --> 00:38:38,400
to summarize

940
00:38:38,400 --> 00:38:41,520
i'll say that in my humble opinion brick

941
00:38:41,520 --> 00:38:44,240
is a very promising tool but it's also

942
00:38:44,240 --> 00:38:45,119
really

943
00:38:45,119 --> 00:38:47,839
a young project so that means there is

944
00:38:47,839 --> 00:38:50,640
definitely a lot of room for improvement

945
00:38:50,640 --> 00:38:52,800
so here i wrote down the

946
00:38:52,800 --> 00:38:57,280
some critical areas for future revisions

947
00:38:57,280 --> 00:38:58,160
so

948
00:38:58,160 --> 00:38:59,359
one thing

949
00:38:59,359 --> 00:39:01,920
would be adding more detection models to

950
00:39:01,920 --> 00:39:04,800
help pinpoint uh bar classes that

951
00:39:04,800 --> 00:39:07,359
currently just go below our radar

952
00:39:07,359 --> 00:39:08,720
and also we need to improve the

953
00:39:08,720 --> 00:39:10,720
reliability of the existing detection so

954
00:39:10,720 --> 00:39:13,280
that means slowing down both the false

955
00:39:13,280 --> 00:39:14,800
positive slate as well as the false

956
00:39:14,800 --> 00:39:16,800
negatives rate

957
00:39:16,800 --> 00:39:19,760
the third critical issue has to do with

958
00:39:19,760 --> 00:39:22,079
the performance of the tool so like you

959
00:39:22,079 --> 00:39:24,800
saw in the demo scanning four smm images

960
00:39:24,800 --> 00:39:27,280
might take about a minute and a half

961
00:39:27,280 --> 00:39:29,200
but scanning an entire bios image can

962
00:39:29,200 --> 00:39:31,119
take up to an hour so there's definitely

963
00:39:31,119 --> 00:39:33,280
some room for optimizations there

964
00:39:33,280 --> 00:39:34,400
and

965
00:39:34,400 --> 00:39:36,079
that's exactly where you can make an

966
00:39:36,079 --> 00:39:38,560
impact because brick is already an open

967
00:39:38,560 --> 00:39:40,800
source tool available on github so if

968
00:39:40,800 --> 00:39:42,720
you're interested in smm or thermal

969
00:39:42,720 --> 00:39:44,480
security in general

970
00:39:44,480 --> 00:39:46,400
feel free to contribute in any way you

971
00:39:46,400 --> 00:39:49,520
see fit either by opening up issues

972
00:39:49,520 --> 00:39:52,640
submitting pull requests and so on um

973
00:39:52,640 --> 00:39:54,960
and with that in mind i want to thank

974
00:39:54,960 --> 00:39:57,280
you very much for your attention and i

975
00:39:57,280 --> 00:39:59,119
wish you an interesting and fruitful

976
00:39:59,119 --> 00:40:01,599
conference

977
00:40:05,119 --> 00:40:08,240
so do we have any questions

978
00:40:08,240 --> 00:40:11,240
several

979
00:40:17,839 --> 00:40:19,359
uh thanks for the very interesting

980
00:40:19,359 --> 00:40:21,280
presentation it was very useful

981
00:40:21,280 --> 00:40:23,200
i had a question regarding one of the

982
00:40:23,200 --> 00:40:26,640
checks which checked if a node had

983
00:40:26,640 --> 00:40:29,280
access to a function called is outside

984
00:40:29,280 --> 00:40:30,240
smm

985
00:40:30,240 --> 00:40:32,400
comb buffer i think

986
00:40:32,400 --> 00:40:34,960
we were talking about this one yes

987
00:40:34,960 --> 00:40:38,079
so from what i understand you decide

988
00:40:38,079 --> 00:40:41,920
that a function is okay if it calls that

989
00:40:41,920 --> 00:40:43,920
other function right or that node is

990
00:40:43,920 --> 00:40:46,240
okay if it calls the other function yes

991
00:40:46,240 --> 00:40:48,400
so so an smi handler is assumed to be

992
00:40:48,400 --> 00:40:51,280
safe if it calls smm out

993
00:40:51,280 --> 00:40:53,920
is buffer outside the cement valid and

994
00:40:53,920 --> 00:40:55,599
if the

995
00:40:55,599 --> 00:40:57,359
the first argument passed to this

996
00:40:57,359 --> 00:41:00,560
function is not the com buffer itself so

997
00:41:00,560 --> 00:41:02,160
there is basically a distinction between

998
00:41:02,160 --> 00:41:03,839
two things you can verify that the com

999
00:41:03,839 --> 00:41:06,400
buffer itself does not reside in smram

1000
00:41:06,400 --> 00:41:07,280
and

1001
00:41:07,280 --> 00:41:08,960
any other

1002
00:41:08,960 --> 00:41:10,880
value that you pass to this function is

1003
00:41:10,880 --> 00:41:12,560
assumed to be like a nested pointer or

1004
00:41:12,560 --> 00:41:14,319
something like that

1005
00:41:14,319 --> 00:41:17,280
okay but if there is for example

1006
00:41:17,280 --> 00:41:19,119
an off by one

1007
00:41:19,119 --> 00:41:20,400
issue there

1008
00:41:20,400 --> 00:41:23,200
this would not catch it right

1009
00:41:23,200 --> 00:41:25,839
so so like i said so most of these

1010
00:41:25,839 --> 00:41:27,839
heuristics are quite simple

1011
00:41:27,839 --> 00:41:31,359
and there are um

1012
00:41:31,359 --> 00:41:32,880
probably there are some you know false

1013
00:41:32,880 --> 00:41:35,280
positives and false negatives alike

1014
00:41:35,280 --> 00:41:36,240
um

1015
00:41:36,240 --> 00:41:38,319
so these heuristics basically you know

1016
00:41:38,319 --> 00:41:41,280
they detect the most uh

1017
00:41:41,280 --> 00:41:45,920
common uh misuses or uh bad practices uh

1018
00:41:45,920 --> 00:41:47,599
that

1019
00:41:47,599 --> 00:41:49,040
are present in

1020
00:41:49,040 --> 00:41:51,200
smm images but they don't cover all the

1021
00:41:51,200 --> 00:41:52,240
cases

1022
00:41:52,240 --> 00:41:54,799
yeah thank you

1023
00:41:56,880 --> 00:41:59,280
so you said brick is public and a bunch

1024
00:41:59,280 --> 00:42:01,119
of vulnerabilities are still going

1025
00:42:01,119 --> 00:42:03,200
through disclosure so if i download this

1026
00:42:03,200 --> 00:42:05,680
today and run it on some oem i'm going

1027
00:42:05,680 --> 00:42:08,319
to get zero day vulnerabilities right i

1028
00:42:08,319 --> 00:42:10,160
don't think i heard a question

1029
00:42:10,160 --> 00:42:12,000
so brick is public

1030
00:42:12,000 --> 00:42:13,440
and you said you have a bunch of other

1031
00:42:13,440 --> 00:42:15,280
vulnerabilities that you haven't listed

1032
00:42:15,280 --> 00:42:17,839
the cves for because they're still going

1033
00:42:17,839 --> 00:42:19,200
through the vulnerability disclosure

1034
00:42:19,200 --> 00:42:20,400
pipeline

1035
00:42:20,400 --> 00:42:22,880
so if i download brick today and i run

1036
00:42:22,880 --> 00:42:24,480
it on an oem

1037
00:42:24,480 --> 00:42:26,640
i'll probably find some zero volt zero

1038
00:42:26,640 --> 00:42:28,400
day vulnerabilities correct

1039
00:42:28,400 --> 00:42:29,280
um

1040
00:42:29,280 --> 00:42:33,680
yeah so for from our experience um

1041
00:42:33,680 --> 00:42:36,000
almost any firmware image that we

1042
00:42:36,000 --> 00:42:40,079
downloaded and scanned had some issues

1043
00:42:40,079 --> 00:42:43,520
um very few vendors manage like to pass

1044
00:42:43,520 --> 00:42:47,440
all the tests without any major finding

1045
00:42:47,440 --> 00:42:50,640
i will say that not necessarily all

1046
00:42:50,640 --> 00:42:52,640
vulnerabilities are exploitable for

1047
00:42:52,640 --> 00:42:54,160
example

1048
00:42:54,160 --> 00:42:56,400
in the first bar class you are very

1049
00:42:56,400 --> 00:42:58,319
limited in where the corruption takes

1050
00:42:58,319 --> 00:42:59,359
place

1051
00:42:59,359 --> 00:43:01,839
and i think that

1052
00:43:01,839 --> 00:43:05,040
it would be really rare to be able to

1053
00:43:05,040 --> 00:43:07,760
perform a full attack cycle using just

1054
00:43:07,760 --> 00:43:09,839
this vulnerability you might be able you

1055
00:43:09,839 --> 00:43:12,160
know to get a denial of service or

1056
00:43:12,160 --> 00:43:14,640
something like that but probably

1057
00:43:14,640 --> 00:43:16,560
it won't be enough to get

1058
00:43:16,560 --> 00:43:19,799
code execution

1059
00:43:20,990 --> 00:43:24,040
[Music]

1060
00:43:28,319 --> 00:43:30,319
yeah so i had a question regarding time

1061
00:43:30,319 --> 00:43:32,079
of check time of use

1062
00:43:32,079 --> 00:43:34,960
so you said like um you could use dma in

1063
00:43:34,960 --> 00:43:38,839
order to change uh the value in between

1064
00:43:38,839 --> 00:43:42,160
readouts um so my question is uh have

1065
00:43:42,160 --> 00:43:43,520
you have you actually tried this in

1066
00:43:43,520 --> 00:43:44,880
practice because

1067
00:43:44,880 --> 00:43:46,800
my logic tells me that this this value

1068
00:43:46,800 --> 00:43:48,960
is then cached in the cpu

1069
00:43:48,960 --> 00:43:51,440
so so i'll be honest and i

1070
00:43:51,440 --> 00:43:53,680
tell you that i haven't tried this

1071
00:43:53,680 --> 00:43:54,800
myself

1072
00:43:54,800 --> 00:43:56,480
um so

1073
00:43:56,480 --> 00:43:59,200
this was you know mostly things that

1074
00:43:59,200 --> 00:44:00,960
i i read about

1075
00:44:00,960 --> 00:44:02,400
um

1076
00:44:02,400 --> 00:44:03,599
so

1077
00:44:03,599 --> 00:44:05,599
i i don't i don't know if that's you

1078
00:44:05,599 --> 00:44:08,400
know actually exploitable so maybe

1079
00:44:08,400 --> 00:44:10,079
there are you know some

1080
00:44:10,079 --> 00:44:11,760
i don't know issues with the cache or

1081
00:44:11,760 --> 00:44:13,440
something like that that prevents you

1082
00:44:13,440 --> 00:44:15,040
from doing it

1083
00:44:15,040 --> 00:44:16,560
but if you go

1084
00:44:16,560 --> 00:44:18,000
through the

1085
00:44:18,000 --> 00:44:20,079
edk documentation

1086
00:44:20,079 --> 00:44:22,480
they will specifically mention that

1087
00:44:22,480 --> 00:44:25,280
doing double fetches from the com buffer

1088
00:44:25,280 --> 00:44:28,079
um is something dangerous and might lead

1089
00:44:28,079 --> 00:44:29,839
to a time of check time of use attack so

1090
00:44:29,839 --> 00:44:31,920
i mostly based my work on reading the

1091
00:44:31,920 --> 00:44:36,680
edk documentation okay thank you

1092
00:44:38,640 --> 00:44:39,760
any other questions

1093
00:44:39,760 --> 00:44:41,839
[Music]

1094
00:44:41,839 --> 00:44:44,450
okay so thank you

1095
00:44:44,450 --> 00:44:49,109
[Applause]

