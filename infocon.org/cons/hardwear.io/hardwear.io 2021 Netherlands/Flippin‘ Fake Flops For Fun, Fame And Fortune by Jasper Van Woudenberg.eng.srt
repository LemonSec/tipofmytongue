1
00:00:04,080 --> 00:00:05,920
cool thanks thanks welcome everybody

2
00:00:05,920 --> 00:00:07,839
hurry up thanks for coming

3
00:00:07,839 --> 00:00:10,800
so um unlike herbert i'm not it's not my

4
00:00:10,800 --> 00:00:12,080
birthday today

5
00:00:12,080 --> 00:00:14,559
um but i did officially turn this year

6
00:00:14,559 --> 00:00:17,199
old years old so i've been hacking stuff

7
00:00:17,199 --> 00:00:20,480
now for about 20 25 years

8
00:00:20,480 --> 00:00:22,400
so i've been thinking a lot about you

9
00:00:22,400 --> 00:00:23,680
know how can we

10
00:00:23,680 --> 00:00:25,680
get rid of classes of

11
00:00:25,680 --> 00:00:28,000
of issues in terms of security instead

12
00:00:28,000 --> 00:00:31,199
of just poking holes and new things so

13
00:00:31,199 --> 00:00:33,040
one of the things that we i've been uh

14
00:00:33,040 --> 00:00:35,360
working on more recently

15
00:00:35,360 --> 00:00:37,040
is what we like to call pre-silicon

16
00:00:37,040 --> 00:00:38,559
fault injection

17
00:00:38,559 --> 00:00:40,800
which is actually doing fault injection

18
00:00:40,800 --> 00:00:42,719
before the silicon exists so before the

19
00:00:42,719 --> 00:00:44,399
chip has actually been made because if

20
00:00:44,399 --> 00:00:45,680
you can figure out at that point what

21
00:00:45,680 --> 00:00:47,840
your vulnerabilities are you still are

22
00:00:47,840 --> 00:00:50,160
in a place where you can fix them

23
00:00:50,160 --> 00:00:51,120
so

24
00:00:51,120 --> 00:00:53,440
the way to do that is to do

25
00:00:53,440 --> 00:00:56,719
simulations of the of the chip and also

26
00:00:56,719 --> 00:00:58,399
simulations of default

27
00:00:58,399 --> 00:01:00,079
and then investigate what the effects

28
00:01:00,079 --> 00:01:01,760
are and see if you can actually uh come

29
00:01:01,760 --> 00:01:03,520
up with some countermeasures so let's

30
00:01:03,520 --> 00:01:05,119
try to um

31
00:01:05,119 --> 00:01:06,880
get into that so

32
00:01:06,880 --> 00:01:08,960
first for the um you know we've heard

33
00:01:08,960 --> 00:01:10,799
the term fault injection a couple times

34
00:01:10,799 --> 00:01:13,680
already today

35
00:01:13,680 --> 00:01:15,840
i just want to give you a just a quick

36
00:01:15,840 --> 00:01:16,940
overview

37
00:01:16,940 --> 00:01:18,000
[Music]

38
00:01:18,000 --> 00:01:20,560
of kinds or types of faults that you

39
00:01:20,560 --> 00:01:22,640
could inject

40
00:01:22,640 --> 00:01:23,920
[Music]

41
00:01:23,920 --> 00:01:24,960
i'm going to start really with the

42
00:01:24,960 --> 00:01:27,360
basics so this is um

43
00:01:27,360 --> 00:01:28,880
in the top right what you actually see

44
00:01:28,880 --> 00:01:31,680
is a is part of a barbecue lighter

45
00:01:31,680 --> 00:01:33,360
and as soon as you click it you actually

46
00:01:33,360 --> 00:01:35,680
create a spark which is normally used to

47
00:01:35,680 --> 00:01:38,079
light the gas inside of your barbecue

48
00:01:38,079 --> 00:01:39,920
but if you're careful you can also use

49
00:01:39,920 --> 00:01:41,520
it to

50
00:01:41,520 --> 00:01:42,880
change

51
00:01:42,880 --> 00:01:45,119
bits on a chip through an electric 3d

52
00:01:45,119 --> 00:01:46,640
electromagnetic pulse that actually

53
00:01:46,640 --> 00:01:48,960
occurs when you when you do this

54
00:01:48,960 --> 00:01:50,479
um

55
00:01:50,479 --> 00:01:51,520
do

56
00:01:51,520 --> 00:01:52,880
make sure that you put some of that

57
00:01:52,880 --> 00:01:55,040
captain tape over your device because

58
00:01:55,040 --> 00:01:56,320
otherwise you're going to fry the whole

59
00:01:56,320 --> 00:01:57,439
thing

60
00:01:57,439 --> 00:01:59,119
but this is like a

61
00:01:59,119 --> 00:02:00,960
you know a two dollar

62
00:02:00,960 --> 00:02:03,110
fault attack

63
00:02:03,110 --> 00:02:04,560
[Music]

64
00:02:04,560 --> 00:02:06,399
if you want to spend a little bit more

65
00:02:06,399 --> 00:02:08,239
more money then you can get devices like

66
00:02:08,239 --> 00:02:09,280
a

67
00:02:09,280 --> 00:02:10,800
chip whisperer

68
00:02:10,800 --> 00:02:11,680
um

69
00:02:11,680 --> 00:02:13,599
and if you're you know

70
00:02:13,599 --> 00:02:15,760
want to apply your kindergarten skills

71
00:02:15,760 --> 00:02:16,959
of gluing

72
00:02:16,959 --> 00:02:19,840
you use that to attach the uh the wires

73
00:02:19,840 --> 00:02:21,760
to your other soldering underneath there

74
00:02:21,760 --> 00:02:22,959
but then you want to fix it with some

75
00:02:22,959 --> 00:02:25,280
glue

76
00:02:25,440 --> 00:02:26,640
so you can use this for voltage

77
00:02:26,640 --> 00:02:29,760
glitching so um you know playing with

78
00:02:29,760 --> 00:02:32,000
this power supply onto a chip

79
00:02:32,000 --> 00:02:32,800
and

80
00:02:32,800 --> 00:02:36,560
injecting faults that way

81
00:02:36,560 --> 00:02:38,000
if you want to get a little bit fancier

82
00:02:38,000 --> 00:02:40,400
you can use things like

83
00:02:40,400 --> 00:02:43,120
bbi stands for body biased injection but

84
00:02:43,120 --> 00:02:46,000
basically what you're seeing there is a

85
00:02:46,000 --> 00:02:47,200
chip

86
00:02:47,200 --> 00:02:48,640
and we're touching a needle on the

87
00:02:48,640 --> 00:02:50,959
substrate of the chip which is let's say

88
00:02:50,959 --> 00:02:52,800
the ground plane of the chip

89
00:02:52,800 --> 00:02:54,560
and if you play with the potential of

90
00:02:54,560 --> 00:02:56,160
the ground plane you're actually also

91
00:02:56,160 --> 00:03:00,159
injecting faults in a chip as well

92
00:03:00,159 --> 00:03:01,599
i think we have a

93
00:03:01,599 --> 00:03:03,280
maybe not a demo set up but we have some

94
00:03:03,280 --> 00:03:05,120
of these needles out there in our booth

95
00:03:05,120 --> 00:03:07,040
you can go and check out

96
00:03:07,040 --> 00:03:10,799
they're sharp don't pinch yourself

97
00:03:11,599 --> 00:03:13,120
and then you can go even further you can

98
00:03:13,120 --> 00:03:15,519
do things like a laser fault injection

99
00:03:15,519 --> 00:03:18,400
where you have this this laser setup

100
00:03:18,400 --> 00:03:20,720
and what it does it shines a

101
00:03:20,720 --> 00:03:23,280
well a very bright beam of photons on a

102
00:03:23,280 --> 00:03:25,760
chip which actually causes transistors

103
00:03:25,760 --> 00:03:27,440
to open up

104
00:03:27,440 --> 00:03:29,200
maybe transistor that shouldn't be open

105
00:03:29,200 --> 00:03:30,720
at a particular point in time which

106
00:03:30,720 --> 00:03:34,080
means that you've also injected a fault

107
00:03:34,080 --> 00:03:35,760
and if you want to get really precise

108
00:03:35,760 --> 00:03:37,920
you can do things like this

109
00:03:37,920 --> 00:03:39,760
i stole this actually from a paper from

110
00:03:39,760 --> 00:03:41,280
sergey which i think is also in the

111
00:03:41,280 --> 00:03:43,040
audience

112
00:03:43,040 --> 00:03:44,879
that's basically microprobing so if you

113
00:03:44,879 --> 00:03:46,799
open up a chip you can put these

114
00:03:46,799 --> 00:03:49,120
microprobes on the metal wires that are

115
00:03:49,120 --> 00:03:51,519
on the chipping you can basically inject

116
00:03:51,519 --> 00:03:53,650
single bit faults

117
00:03:53,650 --> 00:03:55,040
[Music]

118
00:03:55,040 --> 00:03:56,799
so

119
00:03:56,799 --> 00:03:59,680
all very cool very visual but

120
00:03:59,680 --> 00:04:02,720
why am i bringing this up so

121
00:04:02,720 --> 00:04:04,480
really the mental model that we should

122
00:04:04,480 --> 00:04:06,480
be having when we're doing simulation as

123
00:04:06,480 --> 00:04:07,760
well is that we

124
00:04:07,760 --> 00:04:09,519
we have some sort of physical

125
00:04:09,519 --> 00:04:11,120
disturbance

126
00:04:11,120 --> 00:04:14,560
and this causes bits to flip inside a

127
00:04:14,560 --> 00:04:16,959
chip that's really what all there is to

128
00:04:16,959 --> 00:04:17,839
it

129
00:04:17,839 --> 00:04:19,440
and then of course we want to try to

130
00:04:19,440 --> 00:04:21,519
flip bits that that have some sort of

131
00:04:21,519 --> 00:04:25,040
meaning with with security

132
00:04:27,040 --> 00:04:30,160
so how are we going to simulate this

133
00:04:30,160 --> 00:04:31,840
i'll first talk a little bit about how

134
00:04:31,840 --> 00:04:34,800
actually chips work because we have some

135
00:04:34,800 --> 00:04:36,400
physical disturbances that we're doing

136
00:04:36,400 --> 00:04:37,919
so let's just look at the physics of the

137
00:04:37,919 --> 00:04:39,680
chip and then we'll see if we can go

138
00:04:39,680 --> 00:04:42,479
back to the logic level so how does a

139
00:04:42,479 --> 00:04:44,960
chip work

140
00:04:46,400 --> 00:04:48,320
these are some

141
00:04:48,320 --> 00:04:50,800
pictures of an actual chip on the top

142
00:04:50,800 --> 00:04:54,400
basically different layers of

143
00:04:55,040 --> 00:04:56,560
of the of the chip

144
00:04:56,560 --> 00:04:57,759
and

145
00:04:57,759 --> 00:05:00,320
what you see in um well let's start on

146
00:05:00,320 --> 00:05:03,520
the right hand side are basically uh the

147
00:05:03,520 --> 00:05:05,600
the transistors and

148
00:05:05,600 --> 00:05:06,479
um

149
00:05:06,479 --> 00:05:08,639
if you add metal one you get things that

150
00:05:08,639 --> 00:05:10,560
are called standard cells the standard

151
00:05:10,560 --> 00:05:12,720
cells are basically just if you don't

152
00:05:12,720 --> 00:05:14,240
know what it is think of it as like the

153
00:05:14,240 --> 00:05:16,320
or gates and the and gates and eggs or

154
00:05:16,320 --> 00:05:18,240
gates and the flip-flops and sort of

155
00:05:18,240 --> 00:05:19,280
those

156
00:05:19,280 --> 00:05:22,000
digital elements that um

157
00:05:22,000 --> 00:05:23,600
that the chip is made up

158
00:05:23,600 --> 00:05:24,560
out of

159
00:05:24,560 --> 00:05:26,000
and then we need to connect these

160
00:05:26,000 --> 00:05:27,520
together to actually form a circuit and

161
00:05:27,520 --> 00:05:29,039
that's what the other

162
00:05:29,039 --> 00:05:30,880
metal layers basically do

163
00:05:30,880 --> 00:05:33,199
i'm waiting for olivier to correct me

164
00:05:33,199 --> 00:05:35,470
so far so good

165
00:05:35,470 --> 00:05:38,629
[Music]

166
00:05:38,720 --> 00:05:40,240
um

167
00:05:40,240 --> 00:05:42,160
but this is the sort of the physical

168
00:05:42,160 --> 00:05:44,080
view of that so when you design these

169
00:05:44,080 --> 00:05:45,360
things you're actually not looking at

170
00:05:45,360 --> 00:05:48,000
this you're um

171
00:05:48,000 --> 00:05:49,440
you're maybe actually even looking at

172
00:05:49,440 --> 00:05:52,800
higher level higher level

173
00:05:52,800 --> 00:05:55,120
design languages but in the end it's

174
00:05:55,120 --> 00:05:57,199
basically gates and wires so we're going

175
00:05:57,199 --> 00:05:59,039
to use this as the logical view of

176
00:05:59,039 --> 00:06:01,680
what's actually happening on a chip

177
00:06:01,680 --> 00:06:03,199
so now

178
00:06:03,199 --> 00:06:04,800
what happens if we actually inject a

179
00:06:04,800 --> 00:06:07,199
fault here so let's say we have a chip

180
00:06:07,199 --> 00:06:08,319
and we

181
00:06:08,319 --> 00:06:10,960
shoot a laser at it or an em pulse or

182
00:06:10,960 --> 00:06:13,759
what what not

183
00:06:13,759 --> 00:06:15,440
there's various things that can happen

184
00:06:15,440 --> 00:06:18,160
and it will really depend on the kind of

185
00:06:18,160 --> 00:06:20,880
fault injector that you're using

186
00:06:20,880 --> 00:06:23,919
what's actually going to happen

187
00:06:23,919 --> 00:06:25,759
so

188
00:06:25,759 --> 00:06:28,800
in the extreme case let's say the

189
00:06:28,800 --> 00:06:31,199
microprobing example we had

190
00:06:31,199 --> 00:06:32,720
we can actually

191
00:06:32,720 --> 00:06:34,880
pick a particular wire

192
00:06:34,880 --> 00:06:36,880
and we can pick a particular time and we

193
00:06:36,880 --> 00:06:39,520
can inject a single bit fault

194
00:06:39,520 --> 00:06:42,319
that's about as precise as it can get

195
00:06:42,319 --> 00:06:44,080
now if you think about the other

196
00:06:44,080 --> 00:06:47,280
examples like the bbq lighter i have

197
00:06:47,280 --> 00:06:49,680
nowhere near that precision right i

198
00:06:49,680 --> 00:06:51,199
don't have precision in time i don't

199
00:06:51,199 --> 00:06:53,840
have precision space

200
00:06:53,840 --> 00:06:54,880
and

201
00:06:54,880 --> 00:06:56,880
i will probably be corrupting a whole

202
00:06:56,880 --> 00:06:59,360
bunch of things on the chip

203
00:06:59,360 --> 00:07:01,199
and i always think the magic magical

204
00:07:01,199 --> 00:07:03,199
fault injection is that the chip

205
00:07:03,199 --> 00:07:04,720
will still usually work and you can

206
00:07:04,720 --> 00:07:06,400
actually bypass security with these kind

207
00:07:06,400 --> 00:07:07,360
of things

208
00:07:07,360 --> 00:07:09,680
but if you start thinking about it it

209
00:07:09,680 --> 00:07:10,960
probably has to do with the fact that a

210
00:07:10,960 --> 00:07:13,360
lot of the chip is actually not

211
00:07:13,360 --> 00:07:15,759
relevant at a particular point in time

212
00:07:15,759 --> 00:07:17,120
so you're just hitting it with a hammer

213
00:07:17,120 --> 00:07:19,039
until you you know accidentally flip the

214
00:07:19,039 --> 00:07:21,440
bits that that do matter and then then

215
00:07:21,440 --> 00:07:24,080
you can continue

216
00:07:24,960 --> 00:07:26,960
for the purpose of

217
00:07:26,960 --> 00:07:28,479
today's discussion i'm going to just be

218
00:07:28,479 --> 00:07:30,720
talking about single bit flips

219
00:07:30,720 --> 00:07:31,840
because they're a little bit easier to

220
00:07:31,840 --> 00:07:33,520
simulate but you can ask me complex

221
00:07:33,520 --> 00:07:35,280
questions about this this later if you

222
00:07:35,280 --> 00:07:37,520
want

223
00:07:40,319 --> 00:07:44,280
so let's talk about simulation

224
00:07:47,520 --> 00:07:49,680
so let's say that we have this

225
00:07:49,680 --> 00:07:51,599
this particular circuit

226
00:07:51,599 --> 00:07:54,240
so really what it is i have two values

227
00:07:54,240 --> 00:07:57,759
a1 and a2 i invert them i take the or of

228
00:07:57,759 --> 00:07:59,759
the two i store them in a flip-flop and

229
00:07:59,759 --> 00:08:01,120
out comes a value

230
00:08:01,120 --> 00:08:03,039
just a random circuit it doesn't really

231
00:08:03,039 --> 00:08:04,879
matter but that's how you represent it

232
00:08:04,879 --> 00:08:05,840
there

233
00:08:05,840 --> 00:08:08,560
now if you write this in code to

234
00:08:08,560 --> 00:08:09,840
simulate it

235
00:08:09,840 --> 00:08:11,360
it's basically a couple statements so

236
00:08:11,360 --> 00:08:13,919
you take this wire zero one which is

237
00:08:13,919 --> 00:08:15,360
represented there which is the inverse

238
00:08:15,360 --> 00:08:17,840
of a1 same for zero two which is the

239
00:08:17,840 --> 00:08:19,440
inverse of

240
00:08:19,440 --> 00:08:20,400
a2

241
00:08:20,400 --> 00:08:23,280
then you take the or of those two and

242
00:08:23,280 --> 00:08:25,280
that eventually becomes flip flop value

243
00:08:25,280 --> 00:08:27,520
x

244
00:08:27,520 --> 00:08:29,840
now this we don't have to invent luckily

245
00:08:29,840 --> 00:08:30,879
there's

246
00:08:30,879 --> 00:08:33,279
a tool called verilater

247
00:08:33,279 --> 00:08:35,360
which basically takes a verilog

248
00:08:35,360 --> 00:08:37,679
description of such a netlist and turns

249
00:08:37,679 --> 00:08:40,719
it into a c code simulator

250
00:08:40,719 --> 00:08:42,399
now it turns out that verilator does

251
00:08:42,399 --> 00:08:45,600
this um sort of like this

252
00:08:45,600 --> 00:08:47,600
so it sees that it's

253
00:08:47,600 --> 00:08:49,440
a network all these wires are the single

254
00:08:49,440 --> 00:08:50,320
bits

255
00:08:50,320 --> 00:08:51,200
so

256
00:08:51,200 --> 00:08:53,120
to make this correct it just basically

257
00:08:53,120 --> 00:08:55,600
puts an and with one which masks off all

258
00:08:55,600 --> 00:08:57,680
the higher order bits off

259
00:08:57,680 --> 00:09:01,120
but it stores everything as a byte still

260
00:09:01,120 --> 00:09:02,020
for some reason

261
00:09:02,020 --> 00:09:04,880
[Music]

262
00:09:04,880 --> 00:09:06,800
so now that we have that code we can

263
00:09:06,800 --> 00:09:09,600
give it arbitrary values for a1 and a2

264
00:09:09,600 --> 00:09:11,760
and outcome the values for x and we're

265
00:09:11,760 --> 00:09:13,920
all happy with our simulation

266
00:09:13,920 --> 00:09:16,480
so how can we start injecting faults in

267
00:09:16,480 --> 00:09:18,640
this

268
00:09:18,640 --> 00:09:20,000
so

269
00:09:20,000 --> 00:09:21,519
there's a few ways you can do this we

270
00:09:21,519 --> 00:09:23,360
actually chose to do it at the verilog

271
00:09:23,360 --> 00:09:25,600
level so if you have

272
00:09:25,600 --> 00:09:26,800
some circuit this is a little bit

273
00:09:26,800 --> 00:09:28,640
different one than i just showed before

274
00:09:28,640 --> 00:09:30,880
but the concept is the same we basically

275
00:09:30,880 --> 00:09:34,000
introduce a thing we call a glitch bus

276
00:09:34,000 --> 00:09:36,000
and that glitch bus we can at arbitrary

277
00:09:36,000 --> 00:09:38,560
points in time we can basically flip the

278
00:09:38,560 --> 00:09:41,600
output of um of arbitrary gates

279
00:09:41,600 --> 00:09:43,360
so this gives us

280
00:09:43,360 --> 00:09:44,959
well

281
00:09:44,959 --> 00:09:46,959
i guess if i say infinite possibilities

282
00:09:46,959 --> 00:09:48,720
some somebody's going to correct me

283
00:09:48,720 --> 00:09:50,880
because it's not infinite but it's a lot

284
00:09:50,880 --> 00:09:53,920
a lot of possibilities here for false

285
00:09:53,920 --> 00:09:55,760
so we have to make some choices right

286
00:09:55,760 --> 00:09:57,760
and like i mentioned before

287
00:09:57,760 --> 00:09:58,880
for now we're just going to make the

288
00:09:58,880 --> 00:10:01,200
choice to do a single

289
00:10:01,200 --> 00:10:02,640
bit fault

290
00:10:02,640 --> 00:10:05,279
which means that the um on this glitch

291
00:10:05,279 --> 00:10:07,360
bus i'm just going to have a single bit

292
00:10:07,360 --> 00:10:09,279
set to one at a particular point in time

293
00:10:09,279 --> 00:10:10,800
and i'm going to put it to zero all the

294
00:10:10,800 --> 00:10:12,160
rest of the time

295
00:10:12,160 --> 00:10:14,320
so now the complexity is basically the

296
00:10:14,320 --> 00:10:16,880
number of gates i want to flip

297
00:10:16,880 --> 00:10:19,839
times the number of clock cycles that i

298
00:10:19,839 --> 00:10:20,800
want to

299
00:10:20,800 --> 00:10:23,519
try to do this

300
00:10:23,839 --> 00:10:26,480
which can be manageable but it's still

301
00:10:26,480 --> 00:10:27,920
fairly slow

302
00:10:27,920 --> 00:10:30,319
so one

303
00:10:30,720 --> 00:10:32,720
one trick at least that we are

304
00:10:32,720 --> 00:10:35,120
exploiting in verilater is the fact that

305
00:10:35,120 --> 00:10:36,959
it uses that um

306
00:10:36,959 --> 00:10:38,399
and one there

307
00:10:38,399 --> 00:10:40,240
so it's actually using

308
00:10:40,240 --> 00:10:42,800
only one bit out of an um you know out

309
00:10:42,800 --> 00:10:44,079
of a byte

310
00:10:44,079 --> 00:10:45,040
so

311
00:10:45,040 --> 00:10:48,079
if you actually drop all those and ones

312
00:10:48,079 --> 00:10:49,519
what you're basically doing is you're

313
00:10:49,519 --> 00:10:50,720
simulating

314
00:10:50,720 --> 00:10:53,120
eight circuits in parallel

315
00:10:53,120 --> 00:10:55,279
so you can still write the same code

316
00:10:55,279 --> 00:10:57,279
but now you can just use every bit in

317
00:10:57,279 --> 00:10:59,279
the buy to uh to simulate and you can do

318
00:10:59,279 --> 00:11:01,600
this for arbitrary widths if you change

319
00:11:01,600 --> 00:11:04,079
byte into word or whatever your favorite

320
00:11:04,079 --> 00:11:05,200
uh

321
00:11:05,200 --> 00:11:07,279
you know integer size is you can run

322
00:11:07,279 --> 00:11:09,360
that many machines in parallel so this

323
00:11:09,360 --> 00:11:11,720
actually speeds things up quite quite a

324
00:11:11,720 --> 00:11:15,800
bit um

325
00:11:16,800 --> 00:11:19,760
one of the things we've seen is that um

326
00:11:19,760 --> 00:11:20,880
the speed of this actually really

327
00:11:20,880 --> 00:11:23,360
depends on your eye cache size

328
00:11:23,360 --> 00:11:26,320
because this is very instruction heavy

329
00:11:26,320 --> 00:11:27,760
so you know i'm putting in an

330
00:11:27,760 --> 00:11:30,079
instruction for every gate so i if i

331
00:11:30,079 --> 00:11:32,399
have tens of thousands of gates

332
00:11:32,399 --> 00:11:33,839
or you know hundreds of thousands of

333
00:11:33,839 --> 00:11:36,240
gates it's basically a very long list of

334
00:11:36,240 --> 00:11:38,480
these kind of equations uh without any

335
00:11:38,480 --> 00:11:39,920
loops or anything like that so that

336
00:11:39,920 --> 00:11:42,640
really bogs down your eye cast so um

337
00:11:42,640 --> 00:11:44,240
using these kind of optimizations really

338
00:11:44,240 --> 00:11:45,620
helps

339
00:11:45,620 --> 00:11:47,360
[Music]

340
00:11:47,360 --> 00:11:48,399
okay

341
00:11:48,399 --> 00:11:51,200
so far so good

342
00:11:51,360 --> 00:11:55,800
i see a thumbs up even awesome

343
00:11:57,279 --> 00:11:59,519
so

344
00:11:59,760 --> 00:12:01,760
um

345
00:12:01,760 --> 00:12:03,120
demo

346
00:12:03,120 --> 00:12:04,399
this is where i have to say something

347
00:12:04,399 --> 00:12:06,160
about what kind of sacrifices i did to

348
00:12:06,160 --> 00:12:08,560
make this demo work

349
00:12:08,560 --> 00:12:10,800
actually i did none it's my wife she's

350
00:12:10,800 --> 00:12:12,720
at home with a three and a six-year-old

351
00:12:12,720 --> 00:12:14,000
without me

352
00:12:14,000 --> 00:12:17,360
so i wish her the best of luck

353
00:12:17,440 --> 00:12:18,639
um

354
00:12:18,639 --> 00:12:21,839
so let's see if we can i will actually

355
00:12:21,839 --> 00:12:24,959
put this back in here

356
00:12:24,959 --> 00:12:28,560
so i can use my demo fingers

357
00:12:31,839 --> 00:12:36,040
do i need to change the thing here

358
00:12:39,920 --> 00:12:42,160
the screen i'll try to blow this up for

359
00:12:42,160 --> 00:12:44,319
you

360
00:12:47,120 --> 00:12:51,480
what's the hotkey for making this bigger

361
00:12:52,480 --> 00:12:54,240
say that again

362
00:12:54,240 --> 00:12:57,200
control w not control plus no control

363
00:12:57,200 --> 00:12:59,760
shift plus

364
00:12:59,920 --> 00:13:01,120
oh

365
00:13:01,120 --> 00:13:02,880
use the mouse

366
00:13:02,880 --> 00:13:05,880
okay

367
00:13:08,160 --> 00:13:09,519
better

368
00:13:09,519 --> 00:13:11,839
i'm asking people in the back i guess

369
00:13:11,839 --> 00:13:14,959
i get a thumbs up again

370
00:13:15,680 --> 00:13:17,440
so um

371
00:13:17,440 --> 00:13:18,959
i said i was going to do a demo on a

372
00:13:18,959 --> 00:13:20,800
pico rv 32 core so maybe i should

373
00:13:20,800 --> 00:13:22,959
explain what that is first so

374
00:13:22,959 --> 00:13:24,959
fika rv2 is a

375
00:13:24,959 --> 00:13:27,680
risk 5 core that's actually open source

376
00:13:27,680 --> 00:13:29,680
the fair log is available it's written

377
00:13:29,680 --> 00:13:31,200
by claire wolf

378
00:13:31,200 --> 00:13:32,160
and

379
00:13:32,160 --> 00:13:34,880
it's a very simple cpu which basically

380
00:13:34,880 --> 00:13:36,560
takes risk five instructions and

381
00:13:36,560 --> 00:13:38,959
executes them it doesn't deal with

382
00:13:38,959 --> 00:13:41,120
caches it doesn't deal with parallelism

383
00:13:41,120 --> 00:13:42,880
it's nice and small and it's really

384
00:13:42,880 --> 00:13:45,680
great for sort of research purposes

385
00:13:45,680 --> 00:13:46,800
um

386
00:13:46,800 --> 00:13:48,399
so that's where we're that's where we're

387
00:13:48,399 --> 00:13:49,760
sort of starting

388
00:13:49,760 --> 00:13:51,519
and what i want to show is

389
00:13:51,519 --> 00:13:53,680
injecting a fault in a piece of code

390
00:13:53,680 --> 00:13:54,720
that that

391
00:13:54,720 --> 00:13:57,519
risk five core actually executes

392
00:13:57,519 --> 00:13:59,120
so

393
00:13:59,120 --> 00:14:00,959
the sort of interesting bits of the code

394
00:14:00,959 --> 00:14:05,040
are here and really all it does is

395
00:14:05,040 --> 00:14:07,279
it prints something basically branch

396
00:14:07,279 --> 00:14:08,880
test

397
00:14:08,880 --> 00:14:10,399
then

398
00:14:10,399 --> 00:14:12,079
it reads a

399
00:14:12,079 --> 00:14:14,000
single byte from

400
00:14:14,000 --> 00:14:15,760
a simulated uart

401
00:14:15,760 --> 00:14:18,480
the simulated uart always says zero

402
00:14:18,480 --> 00:14:20,240
which means that this

403
00:14:20,240 --> 00:14:22,240
if success condition will always return

404
00:14:22,240 --> 00:14:24,240
zero which means it should always print

405
00:14:24,240 --> 00:14:24,960
failure

406
00:14:24,960 --> 00:14:26,480
[Music]

407
00:14:26,480 --> 00:14:28,480
now we're gonna start fiddling with this

408
00:14:28,480 --> 00:14:29,920
glitch bus we're going to start fiddling

409
00:14:29,920 --> 00:14:32,000
with basically all the internal state of

410
00:14:32,000 --> 00:14:33,760
this pico core and we're going to

411
00:14:33,760 --> 00:14:36,240
monitor whether it prints success

412
00:14:36,240 --> 00:14:38,000
because if we if it's print success that

413
00:14:38,000 --> 00:14:40,399
means we've somehow successfully

414
00:14:40,399 --> 00:14:44,000
bypassed this this branching condition

415
00:14:44,000 --> 00:14:45,120
and this is

416
00:14:45,120 --> 00:14:47,440
a toy example but you can imagine this

417
00:14:47,440 --> 00:14:49,440
is a password check or you know any kind

418
00:14:49,440 --> 00:14:51,680
of authentication check that you

419
00:14:51,680 --> 00:14:54,719
can bypass this way

420
00:14:55,279 --> 00:14:57,600
so i want to

421
00:14:57,600 --> 00:15:00,320
maybe do a little pull of the audience

422
00:15:00,320 --> 00:15:02,240
so we have this if success condition

423
00:15:02,240 --> 00:15:04,800
right then we have about

424
00:15:04,800 --> 00:15:07,839
what is this like

425
00:15:07,839 --> 00:15:12,320
15 lines of code with a couple of braces

426
00:15:12,320 --> 00:15:14,959
in how many different ways do you think

427
00:15:14,959 --> 00:15:17,600
i can cause with a single bit flip

428
00:15:17,600 --> 00:15:21,199
this thing to to print success

429
00:15:21,199 --> 00:15:24,560
any hands from one to 10

430
00:15:25,120 --> 00:15:27,839
20 to 50

431
00:15:27,839 --> 00:15:29,759
a couple hands

432
00:15:29,759 --> 00:15:32,720
50 to 100

433
00:15:32,959 --> 00:15:36,239
100 to 250

434
00:15:36,959 --> 00:15:41,359
250 to 100 thousand

435
00:15:41,839 --> 00:15:44,800
alyssa's gonna win

436
00:15:45,600 --> 00:15:46,959
all right

437
00:15:46,959 --> 00:15:49,279
um

438
00:15:50,079 --> 00:15:51,759
i was gonna challenge you for something

439
00:15:51,759 --> 00:15:54,160
else but now i forgot

440
00:15:54,160 --> 00:15:55,680
you can do presenter notes when you're

441
00:15:55,680 --> 00:15:58,480
live live doing a demo

442
00:15:58,480 --> 00:16:00,240
anyhow let's let's let's see what

443
00:16:00,240 --> 00:16:02,000
happens so

444
00:16:02,000 --> 00:16:04,399
um

445
00:16:04,399 --> 00:16:06,160
let's just start it

446
00:16:06,160 --> 00:16:08,000
so this is just running the simulation

447
00:16:08,000 --> 00:16:10,079
so it's actually running for

448
00:16:10,079 --> 00:16:12,320
800 clock cycles

449
00:16:12,320 --> 00:16:14,800
i time the whole code you know from

450
00:16:14,800 --> 00:16:17,600
start to finish at about 700 clock

451
00:16:17,600 --> 00:16:19,519
cycles i think

452
00:16:19,519 --> 00:16:21,920
and it's going over

453
00:16:21,920 --> 00:16:25,360
can i see that here

454
00:16:25,519 --> 00:16:28,240
i can't see that here yet

455
00:16:28,240 --> 00:16:30,399
it's going over some number of

456
00:16:30,399 --> 00:16:31,680
flip flops so

457
00:16:31,680 --> 00:16:33,519
what i'm actually doing is even made the

458
00:16:33,519 --> 00:16:36,079
problem smaller already so but i was

459
00:16:36,079 --> 00:16:38,399
talking earlier about flipping

460
00:16:38,399 --> 00:16:40,079
all the gates actually i'm only flipping

461
00:16:40,079 --> 00:16:42,160
the flip-flops which is where the tongue

462
00:16:42,160 --> 00:16:45,199
twister comes from by the way

463
00:16:45,199 --> 00:16:46,079
because it's a little bit more

464
00:16:46,079 --> 00:16:48,959
manageable for this demo

465
00:16:48,959 --> 00:16:51,120
so this takes on my laptop about 80

466
00:16:51,120 --> 00:16:53,759
seconds or so so i'm coming up with

467
00:16:53,759 --> 00:16:55,759
stuff to fill this void for you so we're

468
00:16:55,759 --> 00:16:57,839
not just staring at each other

469
00:16:57,839 --> 00:17:00,480
um but after this 80 seconds we'll see

470
00:17:00,480 --> 00:17:02,560
like how many different ways this this

471
00:17:02,560 --> 00:17:04,640
code can actually be glitched and

472
00:17:04,640 --> 00:17:05,439
it

473
00:17:05,439 --> 00:17:07,839
it always blows my mind um it's almost

474
00:17:07,839 --> 00:17:09,599
done this is sort of a

475
00:17:09,599 --> 00:17:11,119
in between

476
00:17:11,119 --> 00:17:12,640
print but see you've seen it's already

477
00:17:12,640 --> 00:17:14,880
simulated about a million faults of

478
00:17:14,880 --> 00:17:18,000
which we're already up to 514 different

479
00:17:18,000 --> 00:17:20,319
ways

480
00:17:20,640 --> 00:17:24,000
it should be almost done

481
00:17:24,799 --> 00:17:26,000
um

482
00:17:26,000 --> 00:17:27,599
there we go

483
00:17:27,599 --> 00:17:30,720
i have to go up a little bit to

484
00:17:30,720 --> 00:17:33,039
go to the final number

485
00:17:33,039 --> 00:17:34,559
so here

486
00:17:34,559 --> 00:17:36,600
now if you can see it there's actually

487
00:17:36,600 --> 00:17:39,039
519 different ways

488
00:17:39,039 --> 00:17:41,120
i can glitch this piece of code with

489
00:17:41,120 --> 00:17:43,120
like 13 lines to get it into success

490
00:17:43,120 --> 00:17:47,280
condition and this kind of goes back um

491
00:17:47,280 --> 00:17:48,559
to my earlier statement like we're

492
00:17:48,559 --> 00:17:50,480
hitting this thing with a hammer right

493
00:17:50,480 --> 00:17:52,320
so we might not actually be doing single

494
00:17:52,320 --> 00:17:54,400
bit flips but there's a lot of different

495
00:17:54,400 --> 00:17:56,240
ways we can get this thing to do what we

496
00:17:56,240 --> 00:17:58,400
want anyway so this aligns with what we

497
00:17:58,400 --> 00:18:01,039
see in practice but for me what always

498
00:18:01,039 --> 00:18:03,440
blows my mind is like just

499
00:18:03,440 --> 00:18:05,039
how many different ways it's possible to

500
00:18:05,039 --> 00:18:07,440
do that

501
00:18:07,520 --> 00:18:09,440
what i'm doing here

502
00:18:09,440 --> 00:18:12,960
is i'm printing the clock cycle at which

503
00:18:12,960 --> 00:18:15,520
point i get false so here you see clock

504
00:18:15,520 --> 00:18:17,679
cycle 423

505
00:18:17,679 --> 00:18:20,160
there's actually 98 different ways of

506
00:18:20,160 --> 00:18:22,000
glitching it at that particular point in

507
00:18:22,000 --> 00:18:24,799
time which is about 20 of the faults in

508
00:18:24,799 --> 00:18:26,640
total that we detected so

509
00:18:26,640 --> 00:18:28,000
let's just have a look at that clock

510
00:18:28,000 --> 00:18:30,400
cycle actually if you look

511
00:18:30,400 --> 00:18:33,520
down it's 424 which is just half at 422

512
00:18:33,520 --> 00:18:35,840
it's just browned up 421 it's all around

513
00:18:35,840 --> 00:18:39,760
that 420 something clock cycle

514
00:18:39,760 --> 00:18:43,200
so what happens there

515
00:18:43,200 --> 00:18:44,960
anybody wants a warranty guess before i

516
00:18:44,960 --> 00:18:47,679
show the answer

517
00:18:49,039 --> 00:18:52,240
it's the conditional brand jasper yes

518
00:18:52,240 --> 00:18:54,480
it is

519
00:18:54,480 --> 00:18:57,480
um

520
00:18:59,360 --> 00:19:01,600
oh yeah this was just a i haven't done

521
00:19:01,600 --> 00:19:04,080
this but this is just to um

522
00:19:04,080 --> 00:19:05,919
show you a trace of what happens if you

523
00:19:05,919 --> 00:19:08,960
re uh inject one of the faulty ones that

524
00:19:08,960 --> 00:19:10,799
actually does end up printing success

525
00:19:10,799 --> 00:19:13,679
which is what you what you would expect

526
00:19:13,679 --> 00:19:16,880
this is um a chart of what i just showed

527
00:19:16,880 --> 00:19:20,880
so you can see clock cycle 423 424 422

528
00:19:20,880 --> 00:19:23,360
421 for 18 they're all sort of clustered

529
00:19:23,360 --> 00:19:25,120
around a particular area you see there's

530
00:19:25,120 --> 00:19:26,480
just a ton of

531
00:19:26,480 --> 00:19:28,880
ways that you can glitch it

532
00:19:28,880 --> 00:19:30,320
um

533
00:19:30,320 --> 00:19:32,240
which is good news because maybe that

534
00:19:32,240 --> 00:19:34,080
means that we can apply a really local

535
00:19:34,080 --> 00:19:36,000
fix to actually get a lot of these

536
00:19:36,000 --> 00:19:39,679
faults out of our out of our system

537
00:19:39,679 --> 00:19:40,640
and

538
00:19:40,640 --> 00:19:42,400
yes you guessed correctly so around

539
00:19:42,400 --> 00:19:44,880
clock cycle 423

540
00:19:44,880 --> 00:19:46,880
well we're simulating a core so we know

541
00:19:46,880 --> 00:19:49,120
exactly of what program counter it is

542
00:19:49,120 --> 00:19:50,720
and because we also know the firmware we

543
00:19:50,720 --> 00:19:52,799
can look in the firmware at my program

544
00:19:52,799 --> 00:19:54,720
counter was at x88

545
00:19:54,720 --> 00:19:57,520
i can look at hex 88 and it's indeed at

546
00:19:57,520 --> 00:20:00,080
the you know if success condition

547
00:20:00,080 --> 00:20:00,880
this

548
00:20:00,880 --> 00:20:02,720
conditional branch here

549
00:20:02,720 --> 00:20:04,720
so there's all kinds of way to get this

550
00:20:04,720 --> 00:20:06,880
conditional branch to flip

551
00:20:06,880 --> 00:20:10,080
flip the condition around

552
00:20:10,400 --> 00:20:14,159
so let's see if we can actually fix it

553
00:20:16,720 --> 00:20:18,880
so let's hope that my wife's sacrifices

554
00:20:18,880 --> 00:20:21,679
have been successful because i'm live

555
00:20:21,679 --> 00:20:23,280
going to fix the code that's going to be

556
00:20:23,280 --> 00:20:25,600
trouble

557
00:20:25,840 --> 00:20:27,600
so i'm just doing a really dumb fix

558
00:20:27,600 --> 00:20:29,760
which is basically to do the

559
00:20:29,760 --> 00:20:32,640
the check twice

560
00:20:32,640 --> 00:20:35,760
so i'm again going to

561
00:20:35,760 --> 00:20:37,520
read from the serial port it's going to

562
00:20:37,520 --> 00:20:38,960
give me zero

563
00:20:38,960 --> 00:20:39,919
so

564
00:20:39,919 --> 00:20:41,600
even if for some weird reason it has

565
00:20:41,600 --> 00:20:43,440
passed the success then it needs to read

566
00:20:43,440 --> 00:20:45,120
it out again and pass a second time as

567
00:20:45,120 --> 00:20:49,239
well and then print success

568
00:20:50,640 --> 00:20:53,200
so let's save this and recompile and

569
00:20:53,200 --> 00:20:56,000
rerun it again

570
00:20:59,039 --> 00:21:00,799
so we can play some more bets now so now

571
00:21:00,799 --> 00:21:02,960
that i've it's actually compiled

572
00:21:02,960 --> 00:21:03,919
um

573
00:21:03,919 --> 00:21:06,240
we can play some more bets now how many

574
00:21:06,240 --> 00:21:09,600
faults are we going to go down to now

575
00:21:09,600 --> 00:21:12,559
100 less than 100

576
00:21:12,559 --> 00:21:14,840
some hands less than

577
00:21:14,840 --> 00:21:17,360
100. 100 and

578
00:21:17,360 --> 00:21:20,559
between 100 and 200

579
00:21:21,520 --> 00:21:24,639
200 to infinity

580
00:21:24,880 --> 00:21:26,960
okay well let's see

581
00:21:26,960 --> 00:21:29,600
um so again this takes about 80 seconds

582
00:21:29,600 --> 00:21:31,039
so

583
00:21:31,039 --> 00:21:32,799
it's really pushing my creativity here

584
00:21:32,799 --> 00:21:35,360
and filling this void as well

585
00:21:35,360 --> 00:21:37,678
um

586
00:21:38,480 --> 00:21:39,760
yeah maybe to talk a little bit about

587
00:21:39,760 --> 00:21:41,919
this countermeasure itself so

588
00:21:41,919 --> 00:21:43,360
double checking is this is a common

589
00:21:43,360 --> 00:21:44,720
count measure account

590
00:21:44,720 --> 00:21:45,760
really

591
00:21:45,760 --> 00:21:47,600
any kind of false injection it's it

592
00:21:47,600 --> 00:21:49,280
boils down to detecting that there's a

593
00:21:49,280 --> 00:21:50,799
fault and one of the ways you can do

594
00:21:50,799 --> 00:21:53,679
that is redundancy so you just do

595
00:21:53,679 --> 00:21:55,679
you do things twice or three times and

596
00:21:55,679 --> 00:21:56,799
then

597
00:21:56,799 --> 00:21:59,679
an attacker can get lucky one time but

598
00:21:59,679 --> 00:22:01,520
the idea is that they might not get luck

599
00:22:01,520 --> 00:22:05,039
as lucky uh two times

600
00:22:05,039 --> 00:22:07,360
um

601
00:22:08,559 --> 00:22:11,679
we are already at 393 volts after one

602
00:22:11,679 --> 00:22:12,799
minute

603
00:22:12,799 --> 00:22:13,760
all right

604
00:22:13,760 --> 00:22:17,039
let's see who the winners are

605
00:22:17,360 --> 00:22:20,880
so we went down to 393.

606
00:22:20,880 --> 00:22:22,720
so it's still a lot but it's

607
00:22:22,720 --> 00:22:24,960
you know are you glad class have four

608
00:22:24,960 --> 00:22:27,280
half empty person we actually did knock

609
00:22:27,280 --> 00:22:28,960
out a lot of them with you know a few

610
00:22:28,960 --> 00:22:30,080
lines

611
00:22:30,080 --> 00:22:31,520
code chain so

612
00:22:31,520 --> 00:22:33,679
in that sense it was a fairly good

613
00:22:33,679 --> 00:22:35,120
roi

614
00:22:35,120 --> 00:22:37,200
um

615
00:22:37,200 --> 00:22:39,039
if you plot this what you'll actually

616
00:22:39,039 --> 00:22:41,200
see

617
00:22:41,200 --> 00:22:44,480
is that um there's still

618
00:22:44,480 --> 00:22:46,400
quite a few points in time where you can

619
00:22:46,400 --> 00:22:48,080
inject the fault

620
00:22:48,080 --> 00:22:50,960
but we've went down to like you know at

621
00:22:50,960 --> 00:22:54,880
a particular clock cycle only two or one

622
00:22:54,880 --> 00:22:56,480
so

623
00:22:56,480 --> 00:22:58,240
where is this coming from

624
00:22:58,240 --> 00:22:59,760
well

625
00:22:59,760 --> 00:23:01,280
turns out with false injection there's a

626
00:23:01,280 --> 00:23:04,639
lot of weird things that can happen

627
00:23:05,840 --> 00:23:07,600
one of the things that we regularly see

628
00:23:07,600 --> 00:23:08,720
is that

629
00:23:08,720 --> 00:23:11,280
that you jump into

630
00:23:11,280 --> 00:23:13,120
let's say random looking parts of the

631
00:23:13,120 --> 00:23:14,559
code

632
00:23:14,559 --> 00:23:16,640
um obviously this isn't there's nothing

633
00:23:16,640 --> 00:23:18,720
random what's going on here that's what

634
00:23:18,720 --> 00:23:20,720
we see when we're doing this in practice

635
00:23:20,720 --> 00:23:21,919
but when we're simulating we can

636
00:23:21,919 --> 00:23:24,240
actually see exactly what happens

637
00:23:24,240 --> 00:23:25,440
um

638
00:23:25,440 --> 00:23:27,919
one of the examples um i don't have a

639
00:23:27,919 --> 00:23:29,440
slide on it but one of one of the

640
00:23:29,440 --> 00:23:32,559
examples that i've seen is where

641
00:23:32,559 --> 00:23:36,559
um it actually went into the

642
00:23:36,559 --> 00:23:39,120
to call

643
00:23:39,919 --> 00:23:42,400
into this call the branch test call

644
00:23:42,400 --> 00:23:44,559
right so it's jumping in there

645
00:23:44,559 --> 00:23:48,559
and there was a fall just before that

646
00:23:48,559 --> 00:23:50,240
but it still went into the call it

647
00:23:50,240 --> 00:23:51,919
completed the call a printed brand's

648
00:23:51,919 --> 00:23:54,559
test and then when it returned

649
00:23:54,559 --> 00:23:56,720
it printed success

650
00:23:56,720 --> 00:23:59,600
i'm like that's weird like like

651
00:23:59,600 --> 00:24:01,919
i'm reading out success way later so why

652
00:24:01,919 --> 00:24:04,640
would a fault at this point

653
00:24:04,640 --> 00:24:07,360
actually caused me to print success

654
00:24:07,360 --> 00:24:10,559
and what it turned out is that we were

655
00:24:10,559 --> 00:24:13,760
flipping a bit a single bit again

656
00:24:13,760 --> 00:24:16,159
which affected the return address that

657
00:24:16,159 --> 00:24:19,360
was being saved by that call

658
00:24:19,360 --> 00:24:21,919
so it made call but because the return

659
00:24:21,919 --> 00:24:24,320
address was was flipped it returned to

660
00:24:24,320 --> 00:24:26,320
some other part of the code and it turns

661
00:24:26,320 --> 00:24:28,000
out that there's a one bit difference

662
00:24:28,000 --> 00:24:29,760
between returning to this part in the

663
00:24:29,760 --> 00:24:32,320
code and returning to the debug print in

664
00:24:32,320 --> 00:24:34,720
the code

665
00:24:35,039 --> 00:24:35,840
now

666
00:24:35,840 --> 00:24:37,279
making countermeasures for that is going

667
00:24:37,279 --> 00:24:38,480
to be a little bit harder at the

668
00:24:38,480 --> 00:24:40,000
software level

669
00:24:40,000 --> 00:24:41,440
because there's actually a lot of these

670
00:24:41,440 --> 00:24:43,520
kind of combinations so

671
00:24:43,520 --> 00:24:45,760
um yeah then you're thinking more about

672
00:24:45,760 --> 00:24:47,279
like generic countermeasures like

673
00:24:47,279 --> 00:24:49,679
detection circuitries or canaries or

674
00:24:49,679 --> 00:24:51,039
other kinds of

675
00:24:51,039 --> 00:24:53,600
um code flow checks like you for

676
00:24:53,600 --> 00:24:55,120
instance one of the things when you're

677
00:24:55,120 --> 00:24:56,720
looking at control flow integrity not

678
00:24:56,720 --> 00:24:58,159
sort of in the

679
00:24:58,159 --> 00:25:00,080
um a lot of people know control flow

680
00:25:00,080 --> 00:25:02,400
integrity from exploitation world where

681
00:25:02,400 --> 00:25:03,600
you know you're playing around with

682
00:25:03,600 --> 00:25:04,880
function pointers you're going where

683
00:25:04,880 --> 00:25:06,400
you're not supposed to go

684
00:25:06,400 --> 00:25:08,559
you can also do that within a function

685
00:25:08,559 --> 00:25:10,880
for instance i could

686
00:25:10,880 --> 00:25:12,960
have a few checkpoints in this code and

687
00:25:12,960 --> 00:25:15,440
i know that if i get to this success

688
00:25:15,440 --> 00:25:16,720
play

689
00:25:16,720 --> 00:25:18,880
condition i must have had all these

690
00:25:18,880 --> 00:25:20,720
checkpoints so you can store those in

691
00:25:20,720 --> 00:25:22,080
memory and that makes it harder to

692
00:25:22,080 --> 00:25:23,120
glitch again so there's all kinds of

693
00:25:23,120 --> 00:25:24,559
things you can do but you have to be

694
00:25:24,559 --> 00:25:28,120
aware of them first

695
00:25:29,039 --> 00:25:31,360
so

696
00:25:31,600 --> 00:25:34,159
let's move on to what you can do at the

697
00:25:34,159 --> 00:25:36,960
hardware level

698
00:25:39,200 --> 00:25:41,279
so when we started um

699
00:25:41,279 --> 00:25:42,799
playing around with the simulation we of

700
00:25:42,799 --> 00:25:44,080
course wanted to have some hardware

701
00:25:44,080 --> 00:25:47,279
targets to uh to play around with

702
00:25:47,279 --> 00:25:48,640
and there's this cool project called

703
00:25:48,640 --> 00:25:51,840
open titan which is not titan m it's not

704
00:25:51,840 --> 00:25:53,200
the security key you were looking at

705
00:25:53,200 --> 00:25:55,440
earlier this is actually a full open

706
00:25:55,440 --> 00:25:58,799
source design of uh of a security core

707
00:25:58,799 --> 00:25:59,760
and

708
00:25:59,760 --> 00:26:01,600
we were looking into

709
00:26:01,600 --> 00:26:03,840
um the aes engine specifically and we

710
00:26:03,840 --> 00:26:06,400
were just as a trial what we wanted to

711
00:26:06,400 --> 00:26:09,360
do is see if we can run as for one round

712
00:26:09,360 --> 00:26:11,600
which is really bad from a cryptographic

713
00:26:11,600 --> 00:26:13,919
perspective if you run as for one round

714
00:26:13,919 --> 00:26:15,919
you can basically calculate the key just

715
00:26:15,919 --> 00:26:18,159
from uh from the output

716
00:26:18,159 --> 00:26:19,600
um

717
00:26:19,600 --> 00:26:21,360
so what we did is we

718
00:26:21,360 --> 00:26:22,320
we took

719
00:26:22,320 --> 00:26:24,240
the verilater code which you can just

720
00:26:24,240 --> 00:26:26,320
sorry verilog code which you can just

721
00:26:26,320 --> 00:26:27,760
download off github this is an open

722
00:26:27,760 --> 00:26:29,200
source project

723
00:26:29,200 --> 00:26:30,240
and

724
00:26:30,240 --> 00:26:33,440
we calculated what the output would be

725
00:26:33,440 --> 00:26:36,000
of an aes given a certain key and a

726
00:26:36,000 --> 00:26:37,360
certain input

727
00:26:37,360 --> 00:26:39,440
if we would truncate it after you know

728
00:26:39,440 --> 00:26:41,279
round one two three four five six seven

729
00:26:41,279 --> 00:26:42,799
eight and now we're just running these

730
00:26:42,799 --> 00:26:44,320
simulations and we're running and we're

731
00:26:44,320 --> 00:26:46,799
matching them against this table of sort

732
00:26:46,799 --> 00:26:48,000
of

733
00:26:48,000 --> 00:26:51,520
corrupted aes executions

734
00:26:51,520 --> 00:26:53,520
and then once you once you get a hit you

735
00:26:53,520 --> 00:26:56,159
can again go and look back and say oh i

736
00:26:56,159 --> 00:26:58,400
got this hit because i flipped this bit

737
00:26:58,400 --> 00:27:00,640
at this point in time and you can map

738
00:27:00,640 --> 00:27:04,080
that again back to your uh to your rtl

739
00:27:04,080 --> 00:27:06,400
so this is just um it's a bit of a

740
00:27:06,400 --> 00:27:08,400
truncated list of the

741
00:27:08,400 --> 00:27:10,240
uh the places that we

742
00:27:10,240 --> 00:27:12,000
saw that were vulnerable

743
00:27:12,000 --> 00:27:14,400
and now we're talking about um hardware

744
00:27:14,400 --> 00:27:16,640
designs we're using these registers here

745
00:27:16,640 --> 00:27:18,080
but there's a couple of ones that sort

746
00:27:18,080 --> 00:27:20,480
of stand out like num rounds

747
00:27:20,480 --> 00:27:23,279
around q a couple bits so we probably

748
00:27:23,279 --> 00:27:25,120
hit the round counter somewhere that

749
00:27:25,120 --> 00:27:28,479
caused it to uh to stop

750
00:27:28,960 --> 00:27:31,039
what's interesting about this example is

751
00:27:31,039 --> 00:27:32,840
that we did it

752
00:27:32,840 --> 00:27:34,559
um

753
00:27:34,559 --> 00:27:37,039
so one of one of the things we saw in

754
00:27:37,039 --> 00:27:38,000
the code

755
00:27:38,000 --> 00:27:39,679
was this

756
00:27:39,679 --> 00:27:41,279
so if you look at an older version of

757
00:27:41,279 --> 00:27:42,720
open titan which you can do because you

758
00:27:42,720 --> 00:27:44,399
have a github history

759
00:27:44,399 --> 00:27:46,320
um and you diff it with a newer version

760
00:27:46,320 --> 00:27:48,240
we actually saw at some point around

761
00:27:48,240 --> 00:27:51,279
counter protection had been introduced

762
00:27:51,279 --> 00:27:53,120
so they were actually aware of this this

763
00:27:53,120 --> 00:27:56,000
problem so what they did is they

764
00:27:56,000 --> 00:27:58,559
had a normal round counter

765
00:27:58,559 --> 00:28:00,480
and they also had a

766
00:28:00,480 --> 00:28:03,200
remaining round counter so one counts up

767
00:28:03,200 --> 00:28:04,799
from one to ten and the other one counts

768
00:28:04,799 --> 00:28:06,559
from ten to one and what they're

769
00:28:06,559 --> 00:28:07,760
actually doing is they're summing them

770
00:28:07,760 --> 00:28:10,000
up and checking that that sum is some

771
00:28:10,000 --> 00:28:11,520
constant number namely the number of

772
00:28:11,520 --> 00:28:15,440
rounds that you're supposed to execute

773
00:28:15,440 --> 00:28:17,440
then on top of that they also had some

774
00:28:17,440 --> 00:28:19,520
parity on these things so there's sort

775
00:28:19,520 --> 00:28:20,720
of a double

776
00:28:20,720 --> 00:28:22,880
protection going on there

777
00:28:22,880 --> 00:28:24,399
and then finally somewhere in the state

778
00:28:24,399 --> 00:28:27,120
machine so yeah there's this

779
00:28:27,120 --> 00:28:29,679
for the people that read verilog

780
00:28:29,679 --> 00:28:31,039
for the people that don't read valor

781
00:28:31,039 --> 00:28:32,799
verilog

782
00:28:32,799 --> 00:28:35,919
this is an error flag which once that

783
00:28:35,919 --> 00:28:38,720
error sum becomes one which means that

784
00:28:38,720 --> 00:28:40,320
the counter plus the remaining counter

785
00:28:40,320 --> 00:28:42,880
doesn't equal the number of rounds

786
00:28:42,880 --> 00:28:44,640
this flag goes up and then somewhere in

787
00:28:44,640 --> 00:28:47,120
the aes state machine it causes an alert

788
00:28:47,120 --> 00:28:48,720
and it goes into some error condition

789
00:28:48,720 --> 00:28:53,200
and should never output any results

790
00:28:53,200 --> 00:28:55,200
um

791
00:28:55,200 --> 00:28:57,360
so

792
00:28:57,600 --> 00:28:59,760
time for another audience poll

793
00:28:59,760 --> 00:29:00,880
if we

794
00:29:00,880 --> 00:29:03,679
we had these two github commits

795
00:29:03,679 --> 00:29:05,520
so one before the countermeasure and one

796
00:29:05,520 --> 00:29:08,639
after the consummation

797
00:29:08,720 --> 00:29:10,559
how

798
00:29:10,559 --> 00:29:12,960
let's do percentages this time

799
00:29:12,960 --> 00:29:14,000
so

800
00:29:14,000 --> 00:29:16,080
how many fewer

801
00:29:16,080 --> 00:29:18,559
um fault injection possibilities do you

802
00:29:18,559 --> 00:29:20,559
do you think there were after the

803
00:29:20,559 --> 00:29:22,640
counter measure was introduced

804
00:29:22,640 --> 00:29:23,760
say

805
00:29:23,760 --> 00:29:25,600
10 less

806
00:29:25,600 --> 00:29:28,240
zero to 10 percent less

807
00:29:28,240 --> 00:29:31,600
10 to 50 percent less

808
00:29:31,760 --> 00:29:35,120
50 to 100 less

809
00:29:35,120 --> 00:29:36,799
i can't go over 100 sorry that's how

810
00:29:36,799 --> 00:29:39,440
percentages work

811
00:29:39,440 --> 00:29:41,520
sorry

812
00:29:41,520 --> 00:29:45,918
more than 100 less vulnerabilities

813
00:29:47,520 --> 00:29:50,158
yeah you're right

814
00:29:50,640 --> 00:29:55,720
um it actually went from 16 to 17.

815
00:29:56,480 --> 00:29:59,440
so what happened here um this was really

816
00:29:59,440 --> 00:30:01,440
weird right all this stuff introduced to

817
00:30:01,440 --> 00:30:03,760
actually like bolt it down

818
00:30:03,760 --> 00:30:05,120
um

819
00:30:05,120 --> 00:30:06,320
and it

820
00:30:06,320 --> 00:30:09,440
it actually made things slightly worse

821
00:30:09,440 --> 00:30:11,600
and i should say slightly because

822
00:30:11,600 --> 00:30:14,080
um you know we're talking about 16 or 17

823
00:30:14,080 --> 00:30:15,799
faults out of the

824
00:30:15,799 --> 00:30:18,799
27 almost 28 million

825
00:30:18,799 --> 00:30:20,799
things that we tried

826
00:30:20,799 --> 00:30:22,399
um

827
00:30:22,399 --> 00:30:24,399
in which case we we had a lot of no

828
00:30:24,399 --> 00:30:26,720
faults um and other faults are basically

829
00:30:26,720 --> 00:30:29,440
ones that that we saw a corruption on

830
00:30:29,440 --> 00:30:30,799
the output

831
00:30:30,799 --> 00:30:33,360
but we couldn't explain it with the the

832
00:30:33,360 --> 00:30:35,120
round cutting model

833
00:30:35,120 --> 00:30:37,120
there might be other models that could

834
00:30:37,120 --> 00:30:38,640
still be exploitable we just hadn't

835
00:30:38,640 --> 00:30:41,919
implemented it at that point yet

836
00:30:42,320 --> 00:30:44,000
so it turns out that

837
00:30:44,000 --> 00:30:45,520
you may notice from the software world

838
00:30:45,520 --> 00:30:46,799
that if you

839
00:30:46,799 --> 00:30:48,960
implement a if statement twice you have

840
00:30:48,960 --> 00:30:50,000
to be really careful because the

841
00:30:50,000 --> 00:30:52,559
compiler might optimize it away

842
00:30:52,559 --> 00:30:54,320
in the code that i showed before i was

843
00:30:54,320 --> 00:30:56,240
careful

844
00:30:56,240 --> 00:30:57,919
and

845
00:30:57,919 --> 00:31:00,559
let's go back to the slide

846
00:31:00,559 --> 00:31:02,480
i was careful because it says volatile

847
00:31:02,480 --> 00:31:03,279
here

848
00:31:03,279 --> 00:31:05,600
the volatile tells it tells the compiler

849
00:31:05,600 --> 00:31:06,399
hey

850
00:31:06,399 --> 00:31:07,760
you're going to read it this address i

851
00:31:07,760 --> 00:31:09,440
know you've done it before but just do

852
00:31:09,440 --> 00:31:12,320
it again because it might have changed

853
00:31:12,320 --> 00:31:14,000
so the compiler cannot

854
00:31:14,000 --> 00:31:17,279
optimize this second check away

855
00:31:17,279 --> 00:31:19,360
same stuff happens in um so-called

856
00:31:19,360 --> 00:31:21,039
synthesis tools so synthesis tools are

857
00:31:21,039 --> 00:31:22,799
the ones that take this rtl and turn it

858
00:31:22,799 --> 00:31:24,799
into net lists

859
00:31:24,799 --> 00:31:26,159
you know you want to make your chip as

860
00:31:26,159 --> 00:31:27,919
small and as fast as possible so any

861
00:31:27,919 --> 00:31:29,840
duplication that's in there

862
00:31:29,840 --> 00:31:33,200
better better get rid of it and you know

863
00:31:33,200 --> 00:31:35,279
counting the round counter twice in

864
00:31:35,279 --> 00:31:36,320
which

865
00:31:36,320 --> 00:31:38,000
the developer surely must have made a

866
00:31:38,000 --> 00:31:40,480
mistake so let's optimize all that stuff

867
00:31:40,480 --> 00:31:41,760
away

868
00:31:41,760 --> 00:31:43,440
and for some reason it

869
00:31:43,440 --> 00:31:44,720
yeah i

870
00:31:44,720 --> 00:31:47,120
don't know why it actually got worse but

871
00:31:47,120 --> 00:31:48,399
um

872
00:31:48,399 --> 00:31:50,000
it for sure didn't get better because

873
00:31:50,000 --> 00:31:52,880
that stuff was just all optimized out

874
00:31:52,880 --> 00:31:55,120
um anyway we disclosed this to the open

875
00:31:55,120 --> 00:31:56,799
titan team they have a countermeasure

876
00:31:56,799 --> 00:31:58,880
now that i mean we haven't tested it but

877
00:31:58,880 --> 00:31:59,840
they

878
00:31:59,840 --> 00:32:02,799
they have a countermeasure

879
00:32:03,360 --> 00:32:05,200
so

880
00:32:05,200 --> 00:32:07,279
let me go to some some final thoughts

881
00:32:07,279 --> 00:32:08,240
here

882
00:32:08,240 --> 00:32:10,799
so get your questions ready

883
00:32:10,799 --> 00:32:12,320
um

884
00:32:12,320 --> 00:32:16,399
how can you learn about these things so

885
00:32:16,399 --> 00:32:18,480
one of the things it's kind of

886
00:32:18,480 --> 00:32:19,919
i think it's a cool open source project

887
00:32:19,919 --> 00:32:21,840
by by one of our colleagues you can

888
00:32:21,840 --> 00:32:23,279
download and load it off the risk your

889
00:32:23,279 --> 00:32:24,320
github

890
00:32:24,320 --> 00:32:26,240
is a fault injection simulator that sort

891
00:32:26,240 --> 00:32:28,799
of only works at the cpu level not at

892
00:32:28,799 --> 00:32:30,240
the hardware level

893
00:32:30,240 --> 00:32:32,240
but you can play around with you know

894
00:32:32,240 --> 00:32:33,840
trying different countermeasures and

895
00:32:33,840 --> 00:32:35,840
seeing why it doesn't work and

896
00:32:35,840 --> 00:32:37,120
um

897
00:32:37,120 --> 00:32:39,039
it comes with an example sort of a full

898
00:32:39,039 --> 00:32:41,679
secure boot implementation you can play

899
00:32:41,679 --> 00:32:43,200
and try to implement your own counter

900
00:32:43,200 --> 00:32:45,120
measures and see if you can get the

901
00:32:45,120 --> 00:32:47,440
number of faults down to zero

902
00:32:47,440 --> 00:32:49,760
um

903
00:32:50,159 --> 00:32:51,840
i hope antrex isn't going to kick me out

904
00:32:51,840 --> 00:32:52,960
of the conference for this but i'm going

905
00:32:52,960 --> 00:32:55,279
to do a shameless plug

906
00:32:55,279 --> 00:32:57,039
i get a thumbs up again that's the third

907
00:32:57,039 --> 00:32:58,399
one this uh

908
00:32:58,399 --> 00:32:59,519
this talk

909
00:32:59,519 --> 00:33:01,919
so um colin flynn and i wrote a book for

910
00:33:01,919 --> 00:33:04,960
the past six years unbelievably so i

911
00:33:04,960 --> 00:33:08,000
started when i was young

912
00:33:08,240 --> 00:33:10,320
which covers some of these things uh we

913
00:33:10,320 --> 00:33:12,720
have a section on countermeasures um but

914
00:33:12,720 --> 00:33:15,120
it's mostly about like how do i get into

915
00:33:15,120 --> 00:33:17,519
like the field of hardware hacking um

916
00:33:17,519 --> 00:33:18,960
all the way from

917
00:33:18,960 --> 00:33:19,840
you know

918
00:33:19,840 --> 00:33:22,720
how does uh

919
00:33:22,720 --> 00:33:25,120
firmware extraction work to side channel

920
00:33:25,120 --> 00:33:26,640
analysis and fault injection and those

921
00:33:26,640 --> 00:33:27,840
kind of things

922
00:33:27,840 --> 00:33:30,880
um i also want to do another plug for

923
00:33:30,880 --> 00:33:32,559
matt's fence course i think he's also in

924
00:33:32,559 --> 00:33:34,000
the audience here go talk to him about

925
00:33:34,000 --> 00:33:35,919
the zero to ac course

926
00:33:35,919 --> 00:33:38,159
um taught me a lot about you know

927
00:33:38,159 --> 00:33:40,480
everything from verilog all the way to

928
00:33:40,480 --> 00:33:42,320
how a chip is actually made

929
00:33:42,320 --> 00:33:46,159
um so i highly recommend that

930
00:33:46,159 --> 00:33:47,440
um

931
00:33:47,440 --> 00:33:51,120
so some really final thoughts i promise

932
00:33:51,120 --> 00:33:52,559
so there's some open questions in the

933
00:33:52,559 --> 00:33:55,519
work that i've uh shown you um

934
00:33:55,519 --> 00:33:58,640
i guess it it it does show like hey

935
00:33:58,640 --> 00:34:00,559
we can simulate some

936
00:34:00,559 --> 00:34:03,039
issues before a chip is actually made

937
00:34:03,039 --> 00:34:05,200
we can find both in software and

938
00:34:05,200 --> 00:34:07,360
hardware ways to

939
00:34:07,360 --> 00:34:08,960
identify issues

940
00:34:08,960 --> 00:34:12,159
you know fix them and then retry

941
00:34:12,159 --> 00:34:14,320
but it does really still

942
00:34:14,320 --> 00:34:15,760
have the open question of how well does

943
00:34:15,760 --> 00:34:17,760
this work on actual silicon you know

944
00:34:17,760 --> 00:34:18,839
we're still using

945
00:34:18,839 --> 00:34:21,918
models i've taken the single bit flip

946
00:34:21,918 --> 00:34:22,879
model

947
00:34:22,879 --> 00:34:25,440
and definitely a lot of the

948
00:34:25,440 --> 00:34:27,040
fault injections are not single bit

949
00:34:27,040 --> 00:34:29,679
flips so how do you simulate those we

950
00:34:29,679 --> 00:34:31,679
have lots of thoughts on this but

951
00:34:31,679 --> 00:34:33,280
eventually you're gonna have to put it

952
00:34:33,280 --> 00:34:35,520
in silicon and test so

953
00:34:35,520 --> 00:34:36,399
um

954
00:34:36,399 --> 00:34:38,079
we're still looking into ways to get uh

955
00:34:38,079 --> 00:34:40,000
get chips manufactured actually do this

956
00:34:40,000 --> 00:34:40,879
test

957
00:34:40,879 --> 00:34:43,520
um there's performance questions

958
00:34:43,520 --> 00:34:45,119
so you saw on a pico core i can do it on

959
00:34:45,119 --> 00:34:48,079
my laptop live in front of you

960
00:34:48,079 --> 00:34:50,159
but i cannot do this on a billion

961
00:34:50,159 --> 00:34:53,119
transistor chip right so so where what

962
00:34:53,119 --> 00:34:55,839
size can we actually still reasonably

963
00:34:55,839 --> 00:34:57,839
simulate as a question and

964
00:34:57,839 --> 00:34:59,839
in principle this stuff scales

965
00:34:59,839 --> 00:35:02,160
infinitely like you just throw x times

966
00:35:02,160 --> 00:35:04,400
more compute power at it it goes x times

967
00:35:04,400 --> 00:35:05,599
faster because i can do all these

968
00:35:05,599 --> 00:35:07,680
simulations in parallel

969
00:35:07,680 --> 00:35:09,920
um but still it's interesting to figure

970
00:35:09,920 --> 00:35:11,760
out where the sort of limits are within

971
00:35:11,760 --> 00:35:13,599
within reason

972
00:35:13,599 --> 00:35:14,800
um

973
00:35:14,800 --> 00:35:17,359
yeah finally and i guess that's more

974
00:35:17,359 --> 00:35:19,119
if i zoom out a little bit further is

975
00:35:19,119 --> 00:35:20,960
that this whole shift left so really

976
00:35:20,960 --> 00:35:22,320
going into

977
00:35:22,320 --> 00:35:25,119
like the um development space and trying

978
00:35:25,119 --> 00:35:26,960
to fix issues there is really important

979
00:35:26,960 --> 00:35:28,800
for security and it's where you can make

980
00:35:28,800 --> 00:35:31,359
the most impact it might not be the most

981
00:35:31,359 --> 00:35:33,680
sexy demo um

982
00:35:33,680 --> 00:35:35,680
but you know this is this is what i

983
00:35:35,680 --> 00:35:37,280
think we need to do more as an industry

984
00:35:37,280 --> 00:35:39,520
as well to get really to the root of a

985
00:35:39,520 --> 00:35:41,200
lot of problems so

986
00:35:41,200 --> 00:35:43,040
yeah if you want to

987
00:35:43,040 --> 00:35:44,400
do this kind of stuff

988
00:35:44,400 --> 00:35:46,240
um there's lots of ways to get into the

989
00:35:46,240 --> 00:35:47,119
field

990
00:35:47,119 --> 00:35:49,440
either as an amateur or professionally

991
00:35:49,440 --> 00:35:51,359
we always have jobs open so come talk to

992
00:35:51,359 --> 00:35:53,119
me if you're interested in working in

993
00:35:53,119 --> 00:35:55,040
this uh this field

994
00:35:55,040 --> 00:35:56,640
and i'll be around

995
00:35:56,640 --> 00:35:58,720
today and tomorrow for for any questions

996
00:35:58,720 --> 00:36:00,160
you have

997
00:36:00,160 --> 00:36:01,119
and

998
00:36:01,119 --> 00:36:02,880
that was my really final thought thank

999
00:36:02,880 --> 00:36:05,040
you

1000
00:36:06,680 --> 00:36:09,779
[Applause]

1001
00:36:10,320 --> 00:36:14,320
so do we have any questions

1002
00:36:17,590 --> 00:36:19,359
[Music]

1003
00:36:19,359 --> 00:36:22,000
hi jasper thank you for this nice uh

1004
00:36:22,000 --> 00:36:24,160
simulation and tooling it's really

1005
00:36:24,160 --> 00:36:27,280
nice to see that we are able to

1006
00:36:27,280 --> 00:36:28,160
model

1007
00:36:28,160 --> 00:36:29,359
and practice

1008
00:36:29,359 --> 00:36:32,000
how how things can go wrong

1009
00:36:32,000 --> 00:36:33,520
well i've been doing this for quite a

1010
00:36:33,520 --> 00:36:35,599
while as you know so

1011
00:36:35,599 --> 00:36:36,960
i think that one of the limitations that

1012
00:36:36,960 --> 00:36:37,920
we have

1013
00:36:37,920 --> 00:36:41,040
is a imagining and defining success

1014
00:36:41,040 --> 00:36:42,960
for example in the example we provided

1015
00:36:42,960 --> 00:36:44,880
the success was

1016
00:36:44,880 --> 00:36:47,760
being able to print let's say

1017
00:36:47,760 --> 00:36:48,960
or not

1018
00:36:48,960 --> 00:36:51,599
so use boot is successful or not

1019
00:36:51,599 --> 00:36:53,040
well i can think already at least of

1020
00:36:53,040 --> 00:36:54,880
another way that doesn't fall in this

1021
00:36:54,880 --> 00:36:56,960
definition but would brexit your boot

1022
00:36:56,960 --> 00:36:57,920
for example you know that with

1023
00:36:57,920 --> 00:37:00,160
instruction corruption we actually can

1024
00:37:00,160 --> 00:37:03,200
move the input data to a register so if

1025
00:37:03,200 --> 00:37:04,880
you move that to the link register or

1026
00:37:04,880 --> 00:37:07,040
the equivalent there as soon as you exit

1027
00:37:07,040 --> 00:37:09,280
from that function you would take uh

1028
00:37:09,280 --> 00:37:12,160
runtime control yeah that will not be

1029
00:37:12,160 --> 00:37:14,000
caught by your model so i think that the

1030
00:37:14,000 --> 00:37:16,160
tool is great

1031
00:37:16,160 --> 00:37:17,359
but maybe

1032
00:37:17,359 --> 00:37:18,800
our imagination

1033
00:37:18,800 --> 00:37:20,240
maybe should improve

1034
00:37:20,240 --> 00:37:21,119
yeah

1035
00:37:21,119 --> 00:37:24,079
no it's absolutely correct so um

1036
00:37:24,079 --> 00:37:26,320
things where the

1037
00:37:26,320 --> 00:37:28,240
sort of the only thing i'm doing here is

1038
00:37:28,240 --> 00:37:30,160
is run the normal code and inject the

1039
00:37:30,160 --> 00:37:31,119
fault

1040
00:37:31,119 --> 00:37:33,599
so what you're saying is yeah maybe if

1041
00:37:33,599 --> 00:37:34,560
we're talking about the secure boot

1042
00:37:34,560 --> 00:37:36,640
scenario you know we've actually given

1043
00:37:36,640 --> 00:37:39,760
it a corrupted firmware as well and then

1044
00:37:39,760 --> 00:37:41,599
we try to you know jump into that

1045
00:37:41,599 --> 00:37:43,359
firmware but

1046
00:37:43,359 --> 00:37:45,920
in principle this could be simulated um

1047
00:37:45,920 --> 00:37:48,000
but you need to prepare that firmware

1048
00:37:48,000 --> 00:37:51,839
and it it's more work um

1049
00:38:03,119 --> 00:38:04,000
yeah

1050
00:38:04,000 --> 00:38:05,680
thanks

1051
00:38:05,680 --> 00:38:08,480
any other questions

1052
00:38:11,280 --> 00:38:13,839
i'm just curious if you try to prevent

1053
00:38:13,839 --> 00:38:16,880
the optimization to actually measure how

1054
00:38:16,880 --> 00:38:18,880
how much

1055
00:38:18,880 --> 00:38:20,240
protection the

1056
00:38:20,240 --> 00:38:23,200
the double counter is provided

1057
00:38:23,200 --> 00:38:25,599
so um you mean in the

1058
00:38:25,599 --> 00:38:27,760
hardware side or on the software side

1059
00:38:27,760 --> 00:38:29,839
yeah on the hardware yeah preventing the

1060
00:38:29,839 --> 00:38:32,480
rtl uh optimization yeah

1061
00:38:32,480 --> 00:38:34,240
so

1062
00:38:34,240 --> 00:38:35,920
um

1063
00:38:35,920 --> 00:38:38,160
these synthesis tools they have various

1064
00:38:38,160 --> 00:38:40,800
ways where you can indicate like i don't

1065
00:38:40,800 --> 00:38:42,640
i think it's like don't don't touch and

1066
00:38:42,640 --> 00:38:44,240
keep flags it then depends a bit on the

1067
00:38:44,240 --> 00:38:48,479
dialect that the synthesis engine speaks

1068
00:38:48,760 --> 00:38:50,079
[Music]

1069
00:38:50,079 --> 00:38:53,280
it doesn't always do what you think

1070
00:38:53,280 --> 00:38:55,119
what we've seen i was talking earlier as

1071
00:38:55,119 --> 00:38:56,970
well about an example where we saw

1072
00:38:56,970 --> 00:38:58,320
[Music]

1073
00:38:58,320 --> 00:39:00,560
double flip-flops being implemented

1074
00:39:00,560 --> 00:39:03,359
so it was actually a redundancy case

1075
00:39:03,359 --> 00:39:04,640
where normally you know those should

1076
00:39:04,640 --> 00:39:06,560
always be the same and the idea is that

1077
00:39:06,560 --> 00:39:07,839
if you flip

1078
00:39:07,839 --> 00:39:09,920
one of the two then an error is raised

1079
00:39:09,920 --> 00:39:11,760
and you know that you're in a bad state

1080
00:39:11,760 --> 00:39:12,839
and that's a good

1081
00:39:12,839 --> 00:39:14,560
idea and

1082
00:39:14,560 --> 00:39:16,720
we really try to keep the second set of

1083
00:39:16,720 --> 00:39:18,320
flip-flops in because if you don't do

1084
00:39:18,320 --> 00:39:20,960
anything they're just optimized away

1085
00:39:20,960 --> 00:39:23,280
and it turns out that yes indeed it was

1086
00:39:23,280 --> 00:39:25,359
keeping this so we said you know keep

1087
00:39:25,359 --> 00:39:27,119
the second set and it did keep the

1088
00:39:27,119 --> 00:39:28,480
second set

1089
00:39:28,480 --> 00:39:29,839
but

1090
00:39:29,839 --> 00:39:32,079
the values were fed from the first set

1091
00:39:32,079 --> 00:39:33,680
of flip-flops

1092
00:39:33,680 --> 00:39:36,320
so if i glitch this side i automatically

1093
00:39:36,320 --> 00:39:38,960
get a glitch in my detection as well

1094
00:39:38,960 --> 00:39:40,560
so

1095
00:39:40,560 --> 00:39:41,920
i'm not a

1096
00:39:41,920 --> 00:39:44,000
verilog expert or a synthesis engine

1097
00:39:44,000 --> 00:39:46,079
expert but we've seen this sort of game

1098
00:39:46,079 --> 00:39:48,720
of whack-a-mole where um

1099
00:39:48,720 --> 00:39:50,400
um

1100
00:39:50,400 --> 00:39:52,320
yeah you think that you're

1101
00:39:52,320 --> 00:39:53,680
implementing accounts measuring you're

1102
00:39:53,680 --> 00:39:54,960
even thinking that you're doing the

1103
00:39:54,960 --> 00:39:56,800
right thing in your synthesis engine and

1104
00:39:56,800 --> 00:39:58,240
then you go and check and it's still not

1105
00:39:58,240 --> 00:40:00,240
doing what you want

1106
00:40:00,240 --> 00:40:02,480
so you really have to

1107
00:40:02,480 --> 00:40:04,240
i think again i'm not an expert on that

1108
00:40:04,240 --> 00:40:05,520
part but i think you really have to go

1109
00:40:05,520 --> 00:40:08,160
post synthesis and sort of manually

1110
00:40:08,160 --> 00:40:09,599
make sure everything's there or maybe

1111
00:40:09,599 --> 00:40:10,960
there's some magic you can do in very

1112
00:40:10,960 --> 00:40:13,520
long to to still you know wrestle the

1113
00:40:13,520 --> 00:40:16,319
synthesis engine to do do what you will

1114
00:40:16,319 --> 00:40:19,440
um but yeah it's it's um it's

1115
00:40:19,440 --> 00:40:21,040
i don't think there's a bullet proof

1116
00:40:21,040 --> 00:40:24,839
answer to that right now

1117
00:40:25,680 --> 00:40:27,440
um maybe to expand on that previous

1118
00:40:27,440 --> 00:40:29,119
question is this a signal to the

1119
00:40:29,119 --> 00:40:30,880
synthesis tools makers that i need to

1120
00:40:30,880 --> 00:40:31,760
add

1121
00:40:31,760 --> 00:40:33,440
better support for

1122
00:40:33,440 --> 00:40:36,000
this stuff not getting optimized out

1123
00:40:36,000 --> 00:40:37,760
and the second question is you mentioned

1124
00:40:37,760 --> 00:40:39,839
simulating more complex systems might

1125
00:40:39,839 --> 00:40:42,000
not be feasible can you still take the

1126
00:40:42,000 --> 00:40:43,920
learnings from a simpler example and

1127
00:40:43,920 --> 00:40:47,119
apply those to more complex systems yep

1128
00:40:47,119 --> 00:40:49,040
so the first question yeah

1129
00:40:49,040 --> 00:40:50,800
and this is sort of the

1130
00:40:50,800 --> 00:40:53,280
um the direction i think we are heading

1131
00:40:53,280 --> 00:40:54,319
so

1132
00:40:54,319 --> 00:40:55,920
um

1133
00:40:55,920 --> 00:40:58,319
we work with agencies like darpa

1134
00:40:58,319 --> 00:41:00,319
the us

1135
00:41:00,319 --> 00:41:03,280
defense advanced research project agency

1136
00:41:03,280 --> 00:41:04,640
and there you can already see

1137
00:41:04,640 --> 00:41:07,839
discussions around

1138
00:41:07,839 --> 00:41:10,960
these eda tools they optimize for ppa

1139
00:41:10,960 --> 00:41:13,040
what they say power performance area

1140
00:41:13,040 --> 00:41:14,160
those have been things that are

1141
00:41:14,160 --> 00:41:15,599
optimized for

1142
00:41:15,599 --> 00:41:17,040
and

1143
00:41:17,040 --> 00:41:20,079
none of those like redundancy

1144
00:41:20,079 --> 00:41:22,079
right so redundancy must go

1145
00:41:22,079 --> 00:41:23,440
so we're actually talking now about

1146
00:41:23,440 --> 00:41:26,319
adding a fourth leg to that ppas to add

1147
00:41:26,319 --> 00:41:28,720
security to that as well

1148
00:41:28,720 --> 00:41:30,720
and these tools just don't have that

1149
00:41:30,720 --> 00:41:31,680
right now

1150
00:41:31,680 --> 00:41:35,839
but ideally yes i think you want to

1151
00:41:35,920 --> 00:41:37,200
start having

1152
00:41:37,200 --> 00:41:39,200
some sort of levers in your process to

1153
00:41:39,200 --> 00:41:42,160
add that security part as well

1154
00:41:42,160 --> 00:41:45,520
and then to your second question

1155
00:41:45,760 --> 00:41:47,839
so can you do small

1156
00:41:47,839 --> 00:41:49,760
experiments and that will cover you for

1157
00:41:49,760 --> 00:41:52,480
the for the greater soc i guess

1158
00:41:52,480 --> 00:41:54,079
the way we're looking at it right now is

1159
00:41:54,079 --> 00:41:55,440
that a lot of

1160
00:41:55,440 --> 00:41:57,920
faults

1161
00:41:59,440 --> 00:42:02,160
you know occur at one subsystem or maybe

1162
00:42:02,160 --> 00:42:04,160
between two subsystems

1163
00:42:04,160 --> 00:42:06,240
so you can just pick and choose sort of

1164
00:42:06,240 --> 00:42:08,480
the subsystem that you want to

1165
00:42:08,480 --> 00:42:09,599
default

1166
00:42:09,599 --> 00:42:11,839
and then use that as a proxy of how

1167
00:42:11,839 --> 00:42:14,319
things would be on the on the full soc

1168
00:42:14,319 --> 00:42:15,839
it's definitely not perfect we're going

1169
00:42:15,839 --> 00:42:17,599
to miss things but

1170
00:42:17,599 --> 00:42:19,920
it's better than not being able to sit

1171
00:42:19,920 --> 00:42:21,359
late

1172
00:42:21,359 --> 00:42:22,960
so nothing complicated going on there

1173
00:42:22,960 --> 00:42:24,240
but

1174
00:42:24,240 --> 00:42:26,700
open to thoughts

1175
00:42:26,700 --> 00:42:29,799
[Music]

1176
00:42:31,860 --> 00:42:33,520
[Music]

1177
00:42:33,520 --> 00:42:36,480
cern gave a talk about designing cpus

1178
00:42:36,480 --> 00:42:38,400
and asics for their high radiation

1179
00:42:38,400 --> 00:42:40,079
environments which are basically

1180
00:42:40,079 --> 00:42:42,800
operating in constant fault injection

1181
00:42:42,800 --> 00:42:44,960
type worlds and

1182
00:42:44,960 --> 00:42:46,560
they also mentioned that they had triple

1183
00:42:46,560 --> 00:42:48,400
redundant designs where the optimizer

1184
00:42:48,400 --> 00:42:50,560
had removed two of them and things has

1185
00:42:50,560 --> 00:42:52,240
there been any overlap between the fault

1186
00:42:52,240 --> 00:42:54,960
ejection community and the sort of the

1187
00:42:54,960 --> 00:42:56,720
high power

1188
00:42:56,720 --> 00:42:58,480
high energy physics community in

1189
00:42:58,480 --> 00:43:00,720
designing these sorts of tools

1190
00:43:00,720 --> 00:43:02,000
yeah

1191
00:43:02,000 --> 00:43:04,560
so there's definitely overlap um

1192
00:43:04,560 --> 00:43:07,040
actually if you look at historically

1193
00:43:07,040 --> 00:43:08,480
where sort of all the fault injection

1194
00:43:08,480 --> 00:43:11,040
tools come from are all

1195
00:43:11,040 --> 00:43:12,800
sort of from the same space of fault

1196
00:43:12,800 --> 00:43:14,960
tolerance and failure analysis

1197
00:43:14,960 --> 00:43:17,599
so once you start shooting ships in this

1198
00:43:17,599 --> 00:43:20,240
chips into space high radiation

1199
00:43:20,240 --> 00:43:22,079
um actually your chip is basically

1200
00:43:22,079 --> 00:43:25,040
constantly being fault injected

1201
00:43:25,040 --> 00:43:27,760
so there's things like you know mod tmr

1202
00:43:27,760 --> 00:43:29,680
uh try modular redundancy which is

1203
00:43:29,680 --> 00:43:31,599
basically like let's say you make from

1204
00:43:31,599 --> 00:43:33,440
one flip-flop you make three and you

1205
00:43:33,440 --> 00:43:36,400
have some voting logic that if one flips

1206
00:43:36,400 --> 00:43:38,160
um the other two are still saving the

1207
00:43:38,160 --> 00:43:40,880
day if you will um

1208
00:43:40,880 --> 00:43:42,000
the

1209
00:43:42,000 --> 00:43:46,480
the main difference is that with them

1210
00:43:46,480 --> 00:43:48,800
in space um it's sort of mother nature

1211
00:43:48,800 --> 00:43:50,000
is the enemy

1212
00:43:50,000 --> 00:43:51,760
and monetary are just like small

1213
00:43:51,760 --> 00:43:54,480
particles that cause relatively small

1214
00:43:54,480 --> 00:43:56,160
faults

1215
00:43:56,160 --> 00:43:57,599
when you look at what fault injection

1216
00:43:57,599 --> 00:43:59,359
doing it's actually blasting a lot more

1217
00:43:59,359 --> 00:44:00,800
energy at a chip

1218
00:44:00,800 --> 00:44:04,400
and also it's doing this

1219
00:44:04,400 --> 00:44:07,200
in a more or less controlled way

1220
00:44:07,200 --> 00:44:09,119
so

1221
00:44:09,119 --> 00:44:11,520
the more energy actually causes

1222
00:44:11,520 --> 00:44:13,599
you know more than one bit flip so if i

1223
00:44:13,599 --> 00:44:16,960
flip two bits in a tmr i still you know

1224
00:44:16,960 --> 00:44:19,359
effectively glitched that thing

1225
00:44:19,359 --> 00:44:22,319
so what we see in practice is

1226
00:44:22,319 --> 00:44:23,839
with any of these kind of redundancy

1227
00:44:23,839 --> 00:44:25,520
mechanisms that might be borrowed from

1228
00:44:25,520 --> 00:44:27,680
the

1229
00:44:27,920 --> 00:44:29,680
you know radiation heart

1230
00:44:29,680 --> 00:44:31,359
community

1231
00:44:31,359 --> 00:44:33,119
the success rate goes down a fault

1232
00:44:33,119 --> 00:44:34,480
injection

1233
00:44:34,480 --> 00:44:36,560
but generally not to zero because of

1234
00:44:36,560 --> 00:44:38,319
that effect that you might still be

1235
00:44:38,319 --> 00:44:40,480
lucky enough that you glitch two instead

1236
00:44:40,480 --> 00:44:42,240
of one uh one

1237
00:44:42,240 --> 00:44:43,440
gate

1238
00:44:43,440 --> 00:44:44,640
um

1239
00:44:44,640 --> 00:44:47,440
so yes there's a lot to learn um

1240
00:44:47,440 --> 00:44:49,599
but the fact that it's not or the fact

1241
00:44:49,599 --> 00:44:50,560
that it's

1242
00:44:50,560 --> 00:44:52,160
you know an attacker actually blasting a

1243
00:44:52,160 --> 00:44:53,920
lot more directed energy

1244
00:44:53,920 --> 00:44:57,839
makes it not the final solution

1245
00:45:00,079 --> 00:45:03,560
see another question

1246
00:45:05,680 --> 00:45:08,480
great talk thank you jasper um

1247
00:45:08,480 --> 00:45:10,720
i was just interested because

1248
00:45:10,720 --> 00:45:12,880
verily there's a simulator that's

1249
00:45:12,880 --> 00:45:14,880
optimized for doing things extremely

1250
00:45:14,880 --> 00:45:16,079
quickly

1251
00:45:16,079 --> 00:45:18,640
um but we don't actually do synthesis

1252
00:45:18,640 --> 00:45:19,760
there

1253
00:45:19,760 --> 00:45:21,920
so

1254
00:45:22,079 --> 00:45:24,079
um it seems like an interesting thing

1255
00:45:24,079 --> 00:45:25,200
that could be

1256
00:45:25,200 --> 00:45:27,440
cool to explore later would be

1257
00:45:27,440 --> 00:45:30,720
use a synthesis tool like yosis

1258
00:45:30,720 --> 00:45:32,880
get the gate level net list and then

1259
00:45:32,880 --> 00:45:36,640
simulate the real gates because you may

1260
00:45:36,640 --> 00:45:39,599
find a totally different set of

1261
00:45:39,599 --> 00:45:41,839
um vulnerabilities there and i'd be

1262
00:45:41,839 --> 00:45:44,000
interested to know what the

1263
00:45:44,000 --> 00:45:45,520
the differences or the commonalities

1264
00:45:45,520 --> 00:45:47,680
between the verilator and the gate level

1265
00:45:47,680 --> 00:45:49,920
simulation will be i can i can give

1266
00:45:49,920 --> 00:45:52,160
those to you

1267
00:45:52,160 --> 00:45:54,480
so actually and i skimmed over this but

1268
00:45:54,480 --> 00:45:56,240
what you've seen here is actually a gate

1269
00:45:56,240 --> 00:45:58,000
level uh sim that i've done so i've done

1270
00:45:58,000 --> 00:45:59,839
yo we've done yosas we've done the

1271
00:45:59,839 --> 00:46:02,000
synthesis and then we run it through

1272
00:46:02,000 --> 00:46:03,359
through verilator

1273
00:46:03,359 --> 00:46:04,560
um

1274
00:46:04,560 --> 00:46:05,440
but

1275
00:46:05,440 --> 00:46:07,200
as you know that's a lot slower than

1276
00:46:07,200 --> 00:46:10,000
doing uh simulations at the rtl level

1277
00:46:10,000 --> 00:46:10,960
so

1278
00:46:10,960 --> 00:46:12,560
we've done sort of an in between where

1279
00:46:12,560 --> 00:46:15,760
we did an elaboration of the net list

1280
00:46:15,760 --> 00:46:17,200
and then

1281
00:46:17,200 --> 00:46:20,800
adding again a glitch bus to that

1282
00:46:20,800 --> 00:46:22,480
which runs a lot faster than like the

1283
00:46:22,480 --> 00:46:25,200
final net list and we see on and i have

1284
00:46:25,200 --> 00:46:27,119
to say this was on a small example a one

1285
00:46:27,119 --> 00:46:29,599
time thing but we saw about

1286
00:46:29,599 --> 00:46:33,200
a 90 overlap in the results that we saw

1287
00:46:33,200 --> 00:46:33,920
from

1288
00:46:33,920 --> 00:46:36,160
pure rtl simulation versus the gate

1289
00:46:36,160 --> 00:46:37,760
level simulation

1290
00:46:37,760 --> 00:46:39,520
so there's a bit of a performance

1291
00:46:39,520 --> 00:46:41,359
accuracy trade-off there

1292
00:46:41,359 --> 00:46:42,400
but it's definitely

1293
00:46:42,400 --> 00:46:46,480
a good thought i would say yeah

1294
00:46:47,280 --> 00:46:48,720
okay i think we've pretty much run out

1295
00:46:48,720 --> 00:46:50,800
of time sorry uh we're going into the

1296
00:46:50,800 --> 00:46:52,640
coffee break now

1297
00:46:52,640 --> 00:46:55,200
but yeah if you want to hook up and chat

1298
00:46:55,200 --> 00:46:57,440
don't forget we've got the uh speed

1299
00:46:57,440 --> 00:47:00,000
networking not dating thing going on at

1300
00:47:00,000 --> 00:47:02,480
the moment that's my fault

1301
00:47:02,480 --> 00:47:07,720
so uh yeah thank you

