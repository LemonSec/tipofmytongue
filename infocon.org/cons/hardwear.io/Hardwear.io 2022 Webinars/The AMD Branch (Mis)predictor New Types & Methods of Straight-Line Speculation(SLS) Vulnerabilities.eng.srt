1
00:00:12,480 --> 00:00:13,599
[Music]

2
00:00:13,599 --> 00:00:15,200
welcome everyone and thank you for

3
00:00:15,200 --> 00:00:17,440
joining us this afternoon i'm andrea and

4
00:00:17,440 --> 00:00:19,760
i will be your host for today's session

5
00:00:19,760 --> 00:00:22,640
i'm glad to welcome today pavel pavel is

6
00:00:22,640 --> 00:00:25,039
a security researcher at open source

7
00:00:25,039 --> 00:00:27,359
security and his research focuses on

8
00:00:27,359 --> 00:00:29,599
offensive security aspects of transient

9
00:00:29,599 --> 00:00:31,119
and speculative execution

10
00:00:31,119 --> 00:00:33,760
vulnerabilities side channels and the

11
00:00:33,760 --> 00:00:35,280
effectiveness of the defensive

12
00:00:35,280 --> 00:00:38,879
mitigations in oss and hypervisors

13
00:00:38,879 --> 00:00:41,200
today pavel will discuss a flaw recently

14
00:00:41,200 --> 00:00:44,399
discovered in amd x86 processors of

15
00:00:44,399 --> 00:00:46,879
various micro architectures

16
00:00:46,879 --> 00:00:49,200
then one then three and then three then

17
00:00:49,200 --> 00:00:51,199
two ends and three and its role in a

18
00:00:51,199 --> 00:00:53,680
speculative execution vulnerability type

19
00:00:53,680 --> 00:00:56,160
called straight line speculation

20
00:00:56,160 --> 00:00:59,280
sls the presentation uh today will

21
00:00:59,280 --> 00:01:01,440
consist of a 30-minute presentation

22
00:01:01,440 --> 00:01:04,000
followed by a 10-minute q a session if

23
00:01:04,000 --> 00:01:06,240
you have any questions please feel free

24
00:01:06,240 --> 00:01:07,920
to share them in the chat and we will

25
00:01:07,920 --> 00:01:09,680
answer them once the presentation is

26
00:01:09,680 --> 00:01:10,560
over

27
00:01:10,560 --> 00:01:12,400
pavel now i would like to invite you to

28
00:01:12,400 --> 00:01:14,560
start your presentation

29
00:01:14,560 --> 00:01:17,360
all right um let me share the screen

30
00:01:17,360 --> 00:01:19,680
okay um i hope you can see it

31
00:01:19,680 --> 00:01:21,600
yes it's perfect

32
00:01:21,600 --> 00:01:24,320
all right so um hi everyone um today we

33
00:01:24,320 --> 00:01:26,720
will talk about the amd branch

34
00:01:26,720 --> 00:01:28,320
miss predictor

35
00:01:28,320 --> 00:01:30,880
and new types and methods of straight

36
00:01:30,880 --> 00:01:34,240
line speculation called sls

37
00:01:34,240 --> 00:01:37,360
which are essentially enabled by

38
00:01:37,360 --> 00:01:41,840
the infamous amd branch miss predictor

39
00:01:41,920 --> 00:01:44,240
whoops

40
00:01:44,960 --> 00:01:48,479
yep so my name is pablo viejorkevic i

41
00:01:48,479 --> 00:01:51,119
work as a security researcher at open

42
00:01:51,119 --> 00:01:54,240
source security the creators of gr

43
00:01:54,240 --> 00:01:55,680
security

44
00:01:55,680 --> 00:01:58,640
my focus is on low-level security

45
00:01:58,640 --> 00:02:01,119
research of system software and hardware

46
00:02:01,119 --> 00:02:03,200
as well as reverse engineering and

47
00:02:03,200 --> 00:02:06,159
binary analysis

48
00:02:06,159 --> 00:02:09,280
um today talk um i divided into two

49
00:02:09,280 --> 00:02:12,800
parts theory and practice and in the

50
00:02:12,800 --> 00:02:14,720
theory part we will

51
00:02:14,720 --> 00:02:17,599
start by quickly skimming over the amd

52
00:02:17,599 --> 00:02:19,599
micro architecture

53
00:02:19,599 --> 00:02:21,120
then we will talk about branch

54
00:02:21,120 --> 00:02:23,200
predictors what they are

55
00:02:23,200 --> 00:02:25,040
what's their purpose

56
00:02:25,040 --> 00:02:28,000
their building blocks and functionality

57
00:02:28,000 --> 00:02:29,280
and next

58
00:02:29,280 --> 00:02:31,040
i will try to describe the straight line

59
00:02:31,040 --> 00:02:32,959
speculation

60
00:02:32,959 --> 00:02:35,840
it's root cause mechanics and various

61
00:02:35,840 --> 00:02:37,599
types

62
00:02:37,599 --> 00:02:39,680
finally in the practice

63
00:02:39,680 --> 00:02:43,680
section i will talk about one of the

64
00:02:43,680 --> 00:02:46,640
discoveries of mine a kind of unexpected

65
00:02:46,640 --> 00:02:49,280
type of sls

66
00:02:49,280 --> 00:02:52,480
and after introduction of of the

67
00:02:52,480 --> 00:02:53,519
um

68
00:02:53,519 --> 00:02:56,319
vulnerability i will um speak about

69
00:02:56,319 --> 00:02:58,959
details like speculation window and the

70
00:02:58,959 --> 00:03:00,319
limitation

71
00:03:00,319 --> 00:03:02,400
limitations of it

72
00:03:02,400 --> 00:03:03,760
and we will

73
00:03:03,760 --> 00:03:06,640
i will also show what um successful sls

74
00:03:06,640 --> 00:03:08,640
gadget

75
00:03:08,640 --> 00:03:10,720
must contain in order to leak some

76
00:03:10,720 --> 00:03:11,920
information

77
00:03:11,920 --> 00:03:14,879
and why store to load forwarding feature

78
00:03:14,879 --> 00:03:16,080
might be

79
00:03:16,080 --> 00:03:17,360
useful there

80
00:03:17,360 --> 00:03:18,480
finally

81
00:03:18,480 --> 00:03:21,599
um i will talk about the sls mitigations

82
00:03:21,599 --> 00:03:23,680
especially the direct and indirect

83
00:03:23,680 --> 00:03:25,840
unconditional jumps

84
00:03:25,840 --> 00:03:28,799
and um i will also highlight why

85
00:03:28,799 --> 00:03:30,959
indirect and indirect unconditional

86
00:03:30,959 --> 00:03:33,760
calls are problematic

87
00:03:33,760 --> 00:03:36,000
to mitigate

88
00:03:36,000 --> 00:03:38,560
all right so let's start

89
00:03:38,560 --> 00:03:41,920
this is a diagram of amd's and to

90
00:03:41,920 --> 00:03:44,640
microarchitecture i found online

91
00:03:44,640 --> 00:03:47,440
and for the sake of this presentation

92
00:03:47,440 --> 00:03:50,159
let's just focus on two parts um the

93
00:03:50,159 --> 00:03:52,560
front end yellow color

94
00:03:52,560 --> 00:03:57,360
and back end on the green and red color

95
00:03:57,360 --> 00:03:59,280
so let's begin by

96
00:03:59,280 --> 00:04:01,120
talking about the front

97
00:04:01,120 --> 00:04:02,799
so what does the

98
00:04:02,799 --> 00:04:05,360
front end really do

99
00:04:05,360 --> 00:04:07,840
first of all it fetches instructions for

100
00:04:07,840 --> 00:04:09,200
execution

101
00:04:09,200 --> 00:04:10,080
and

102
00:04:10,080 --> 00:04:13,040
it contains various sub-components

103
00:04:13,040 --> 00:04:14,959
helping it to achieve this goal for

104
00:04:14,959 --> 00:04:18,160
example instruction cache itlb next

105
00:04:18,160 --> 00:04:21,759
address logic etc

106
00:04:21,759 --> 00:04:22,639
next

107
00:04:22,639 --> 00:04:24,000
frontend

108
00:04:24,000 --> 00:04:26,000
needs to decode the fetch to

109
00:04:26,000 --> 00:04:29,360
instructions as you know the x86 is a

110
00:04:29,360 --> 00:04:32,400
complex instruction set architecture

111
00:04:32,400 --> 00:04:36,080
the x86 instructions could be of

112
00:04:36,080 --> 00:04:39,040
variable lengths various lengths

113
00:04:39,040 --> 00:04:40,080
so the

114
00:04:40,080 --> 00:04:41,600
drop of the front end is to find the

115
00:04:41,600 --> 00:04:43,840
beginning and end of instruction and

116
00:04:43,840 --> 00:04:45,040
instructions

117
00:04:45,040 --> 00:04:48,320
and translate them into

118
00:04:48,320 --> 00:04:50,240
sub instructions called

119
00:04:50,240 --> 00:04:52,479
micro hubs

120
00:04:52,479 --> 00:04:55,520
finally front end dispatches the decoded

121
00:04:55,520 --> 00:04:58,880
microbes to the back end for execution

122
00:04:58,880 --> 00:05:01,680
and what can we say about the back end

123
00:05:01,680 --> 00:05:03,280
so beckon is a completely different

124
00:05:03,280 --> 00:05:04,240
beast

125
00:05:04,240 --> 00:05:06,160
this is the place where the microbes are

126
00:05:06,160 --> 00:05:07,199
actually

127
00:05:07,199 --> 00:05:08,880
executed

128
00:05:08,880 --> 00:05:11,759
um one of its

129
00:05:11,759 --> 00:05:15,680
most important properties is superscalar

130
00:05:15,680 --> 00:05:18,000
which means the backend is able to

131
00:05:18,000 --> 00:05:20,880
execute multiple microbes in parallel at

132
00:05:20,880 --> 00:05:23,440
every given cycle

133
00:05:23,440 --> 00:05:26,800
to do so um it uses a multiple of

134
00:05:26,800 --> 00:05:29,280
execution units now you can see the

135
00:05:29,280 --> 00:05:32,479
various alus and agus on the diagram the

136
00:05:32,479 --> 00:05:35,759
ll alu stands for arithmetic logic

137
00:05:35,759 --> 00:05:40,160
unique and agu address generation unit

138
00:05:40,160 --> 00:05:41,680
second of all

139
00:05:41,680 --> 00:05:44,720
the backend employs concept of out of

140
00:05:44,720 --> 00:05:46,479
order execution

141
00:05:46,479 --> 00:05:47,520
which means

142
00:05:47,520 --> 00:05:48,520
that the

143
00:05:48,520 --> 00:05:50,960
instructions or microbes arriving to the

144
00:05:50,960 --> 00:05:54,560
back end in program order

145
00:05:54,560 --> 00:05:57,120
doesn't necessarily execute in in this

146
00:05:57,120 --> 00:06:00,639
order which means microbes that are

147
00:06:00,639 --> 00:06:03,280
ready which means they have unavailable

148
00:06:03,280 --> 00:06:05,520
execution units and their dependencies

149
00:06:05,520 --> 00:06:09,520
are fulfilled are executed first

150
00:06:09,520 --> 00:06:12,160
that means that

151
00:06:12,160 --> 00:06:13,919
microbes are

152
00:06:13,919 --> 00:06:16,080
arriving later

153
00:06:16,080 --> 00:06:17,840
with respect to the program order may

154
00:06:17,840 --> 00:06:20,319
get executed ahead of earlier

155
00:06:20,319 --> 00:06:22,560
instructions

156
00:06:22,560 --> 00:06:24,960
and finally back-end

157
00:06:24,960 --> 00:06:28,560
performs the in-order retire and commit

158
00:06:28,560 --> 00:06:30,479
of the executed

159
00:06:30,479 --> 00:06:31,680
micro-ops

160
00:06:31,680 --> 00:06:34,400
which means it tries to pretend that the

161
00:06:34,400 --> 00:06:37,280
actual execution happened

162
00:06:37,280 --> 00:06:38,400
in order

163
00:06:38,400 --> 00:06:40,319
it makes sure that all dependencies

164
00:06:40,319 --> 00:06:42,080
between microbes are

165
00:06:42,080 --> 00:06:44,800
fulfilled and as a whole the program

166
00:06:44,800 --> 00:06:46,240
executes as

167
00:06:46,240 --> 00:06:47,199
the

168
00:06:47,199 --> 00:06:50,240
instruction set defines

169
00:06:50,240 --> 00:06:52,240
so we have those two uh

170
00:06:52,240 --> 00:06:54,160
blocks front-end and back-end

171
00:06:54,160 --> 00:06:56,639
and to summarize front-end is

172
00:06:56,639 --> 00:06:58,960
front-end's main job is to

173
00:06:58,960 --> 00:07:01,440
feed the the hungry beast which is

174
00:07:01,440 --> 00:07:02,560
backend

175
00:07:02,560 --> 00:07:06,319
and sometimes based on the outcome of

176
00:07:06,319 --> 00:07:07,039
the

177
00:07:07,039 --> 00:07:10,080
executed uh instructions in the back end

178
00:07:10,080 --> 00:07:12,160
becca needs to inform

179
00:07:12,160 --> 00:07:13,520
front end

180
00:07:13,520 --> 00:07:16,400
about the state of execution so

181
00:07:16,400 --> 00:07:18,800
the question now is why do we need the

182
00:07:18,800 --> 00:07:20,560
branch prediction units in the first

183
00:07:20,560 --> 00:07:21,759
place

184
00:07:21,759 --> 00:07:23,599
well frontend needs to know where to

185
00:07:23,599 --> 00:07:25,280
find next instructions to fetch and

186
00:07:25,280 --> 00:07:26,720
decode

187
00:07:26,720 --> 00:07:29,840
and on the task is easy for sequential

188
00:07:29,840 --> 00:07:32,479
execution because frontend can just

189
00:07:32,479 --> 00:07:35,680
fetch next instruction and that's it

190
00:07:35,680 --> 00:07:37,759
however

191
00:07:37,759 --> 00:07:39,759
it becomes problematic upon a control

192
00:07:39,759 --> 00:07:41,840
flow change

193
00:07:41,840 --> 00:07:44,960
or a branch instruction so the front end

194
00:07:44,960 --> 00:07:46,240
needs to know

195
00:07:46,240 --> 00:07:48,240
if the branch is taken or not and he

196
00:07:48,240 --> 00:07:51,360
needs to know what is the address of the

197
00:07:51,360 --> 00:07:54,240
next instruction to fetch

198
00:07:54,240 --> 00:07:55,759
so um

199
00:07:55,759 --> 00:07:58,000
reckoned has already mentioned is

200
00:07:58,000 --> 00:08:01,039
superscalar out of order and

201
00:08:01,039 --> 00:08:04,240
fast it can have multiple in-flight

202
00:08:04,240 --> 00:08:05,919
instructions at every given moment and

203
00:08:05,919 --> 00:08:08,400
it's always hungry for more

204
00:08:08,400 --> 00:08:10,319
so prompted needs to

205
00:08:10,319 --> 00:08:12,000
keep up supplying instructions to the

206
00:08:12,000 --> 00:08:13,120
back end

207
00:08:13,120 --> 00:08:16,080
it cannot wait for the back end to get

208
00:08:16,080 --> 00:08:19,039
back to it with the result of evaluated

209
00:08:19,039 --> 00:08:20,000
branch

210
00:08:20,000 --> 00:08:22,720
it has to predict what is the outcome of

211
00:08:22,720 --> 00:08:24,840
the branch and its target address up

212
00:08:24,840 --> 00:08:26,400
front

213
00:08:26,400 --> 00:08:28,479
otherwise it won't be able to

214
00:08:28,479 --> 00:08:30,800
keep up supplying

215
00:08:30,800 --> 00:08:33,279
micro ups for to the back

216
00:08:33,279 --> 00:08:35,360
if frontend predicts correctly then

217
00:08:35,360 --> 00:08:37,120
everything is fine and the performance

218
00:08:37,120 --> 00:08:40,320
is preserved if it mispredicts however

219
00:08:40,320 --> 00:08:43,279
then there is a penalty because backhand

220
00:08:43,279 --> 00:08:45,680
detects the misprediction and risk tears

221
00:08:45,680 --> 00:08:48,480
front and to the right target address so

222
00:08:48,480 --> 00:08:50,720
let's let's talk quickly about uh some

223
00:08:50,720 --> 00:08:52,160
designs of

224
00:08:52,160 --> 00:08:55,040
the branch predictors

225
00:08:55,040 --> 00:08:57,600
the simplest one is called static branch

226
00:08:57,600 --> 00:09:00,160
predictor and it's essential and its

227
00:09:00,160 --> 00:09:02,240
prediction is based on the actual branch

228
00:09:02,240 --> 00:09:04,399
instruction and some sort of predefined

229
00:09:04,399 --> 00:09:07,600
heuristic for example backward branches

230
00:09:07,600 --> 00:09:09,920
can be always considered taken

231
00:09:09,920 --> 00:09:11,600
which

232
00:09:11,600 --> 00:09:13,279
may work well

233
00:09:13,279 --> 00:09:15,120
for predicting loops

234
00:09:15,120 --> 00:09:17,040
and conversely the forward branches

235
00:09:17,040 --> 00:09:19,440
might be considered not taken a slightly

236
00:09:19,440 --> 00:09:20,959
more advanced

237
00:09:20,959 --> 00:09:22,800
branch predictor is called dynamic

238
00:09:22,800 --> 00:09:26,480
branch predictor and here the prediction

239
00:09:26,480 --> 00:09:28,240
is based

240
00:09:28,240 --> 00:09:31,680
on the previous results or previous

241
00:09:31,680 --> 00:09:34,160
outcomes of the executed branches

242
00:09:34,160 --> 00:09:36,560
the idea here is that if a branch was

243
00:09:36,560 --> 00:09:38,800
taken before it's likely to be taken

244
00:09:38,800 --> 00:09:41,519
again and this kind of branch predictors

245
00:09:41,519 --> 00:09:43,279
could be implemented using a single bit

246
00:09:43,279 --> 00:09:45,360
saturation counter which just

247
00:09:45,360 --> 00:09:47,760
stores one bit of information previously

248
00:09:47,760 --> 00:09:50,720
taken or not taken or a two bit

249
00:09:50,720 --> 00:09:53,200
saturation counter which implements a

250
00:09:53,200 --> 00:09:55,360
four state state machine

251
00:09:55,360 --> 00:09:57,920
here and the previous branches

252
00:09:57,920 --> 00:10:01,120
could have uh four states strongly not

253
00:10:01,120 --> 00:10:03,440
taken weekly not taken will be taken and

254
00:10:03,440 --> 00:10:04,959
strongly taken

255
00:10:04,959 --> 00:10:07,440
and in order to change the overall

256
00:10:07,440 --> 00:10:10,720
branch predictor prediction um a given

257
00:10:10,720 --> 00:10:12,800
branch needs to be taken or not taken

258
00:10:12,800 --> 00:10:14,320
twice in a row

259
00:10:14,320 --> 00:10:16,320
slightly more advanced

260
00:10:16,320 --> 00:10:18,000
branch predictor type is called two

261
00:10:18,000 --> 00:10:20,880
level adaptive branch predictor um and

262
00:10:20,880 --> 00:10:23,680
various variants of of this design is

263
00:10:23,680 --> 00:10:25,760
used in the modern cpus

264
00:10:25,760 --> 00:10:28,320
it essentially contains two elements

265
00:10:28,320 --> 00:10:30,720
branch history table also called pattern

266
00:10:30,720 --> 00:10:33,040
history table

267
00:10:33,040 --> 00:10:35,519
which is a two dimensional table

268
00:10:35,519 --> 00:10:37,839
whose entries are the

269
00:10:37,839 --> 00:10:40,399
two beat saturation counters

270
00:10:40,399 --> 00:10:42,000
described before

271
00:10:42,000 --> 00:10:44,000
and another element is branch history

272
00:10:44,000 --> 00:10:46,800
register which is an n-bit shift

273
00:10:46,800 --> 00:10:48,399
register

274
00:10:48,399 --> 00:10:50,640
storing history of

275
00:10:50,640 --> 00:10:52,720
executions of previous branches so

276
00:10:52,720 --> 00:10:55,279
essentially it remembers and n

277
00:10:55,279 --> 00:10:57,120
executions of previous branches taken

278
00:10:57,120 --> 00:11:00,560
not taken and this register is on the

279
00:11:00,560 --> 00:11:03,279
value of this register is used to index

280
00:11:03,279 --> 00:11:05,200
the branch history table

281
00:11:05,200 --> 00:11:06,079
and

282
00:11:06,079 --> 00:11:07,440
the prediction

283
00:11:07,440 --> 00:11:09,200
final predictions and outcome of the

284
00:11:09,200 --> 00:11:11,600
state machine from the indexed entry now

285
00:11:11,600 --> 00:11:12,320
the

286
00:11:12,320 --> 00:11:13,920
two level adaptive branch predictors

287
00:11:13,920 --> 00:11:16,399
could be local or global in case of

288
00:11:16,399 --> 00:11:18,160
local the branch history table is

289
00:11:18,160 --> 00:11:21,040
indexed using a distinct branch history

290
00:11:21,040 --> 00:11:23,360
register for each encounter conditional

291
00:11:23,360 --> 00:11:25,760
branch so each branch has its own

292
00:11:25,760 --> 00:11:28,880
register that remembers its state

293
00:11:28,880 --> 00:11:31,040
in case of a global

294
00:11:31,040 --> 00:11:33,120
two-level adaptive branch prediction

295
00:11:33,120 --> 00:11:34,160
predictor

296
00:11:34,160 --> 00:11:36,800
the branch history table is indexed

297
00:11:36,800 --> 00:11:39,360
using a shared global branch history

298
00:11:39,360 --> 00:11:41,920
register which remembers information for

299
00:11:41,920 --> 00:11:45,040
all encountered conditional branches

300
00:11:45,040 --> 00:11:48,160
and this design might be beneficial for

301
00:11:48,160 --> 00:11:50,959
executing programs with many branches

302
00:11:50,959 --> 00:11:51,839
that

303
00:11:51,839 --> 00:11:54,880
have the states correlated somehow an

304
00:11:54,880 --> 00:11:57,920
example of the two-level adaptive global

305
00:11:57,920 --> 00:12:00,639
branch predictor is a very very popular

306
00:12:00,639 --> 00:12:02,959
g-share

307
00:12:02,959 --> 00:12:05,600
and idea here is the global global

308
00:12:05,600 --> 00:12:08,720
history register value is exhorted with

309
00:12:08,720 --> 00:12:12,000
the branches program counter value so

310
00:12:12,000 --> 00:12:15,200
address of the branch and the outcome

311
00:12:15,200 --> 00:12:17,040
value is used to index the branch

312
00:12:17,040 --> 00:12:18,480
history table

313
00:12:18,480 --> 00:12:20,000
this kind of

314
00:12:20,000 --> 00:12:21,279
involves

315
00:12:21,279 --> 00:12:23,839
the the address of a branch within the

316
00:12:23,839 --> 00:12:27,440
global history of the branch execution

317
00:12:27,440 --> 00:12:30,800
and in the modern cpus the

318
00:12:30,800 --> 00:12:32,880
branch predictor unit of course employs

319
00:12:32,880 --> 00:12:35,200
many different designs and

320
00:12:35,200 --> 00:12:36,800
branch predictors

321
00:12:36,800 --> 00:12:39,440
using more than one

322
00:12:39,440 --> 00:12:41,920
design category are called

323
00:12:41,920 --> 00:12:44,639
hybrid branch predictors so um

324
00:12:44,639 --> 00:12:47,040
so far the branch predictors we

325
00:12:47,040 --> 00:12:48,240
described

326
00:12:48,240 --> 00:12:50,720
have been kind of implicitly focusing on

327
00:12:50,720 --> 00:12:53,519
direct conditional branches so

328
00:12:53,519 --> 00:12:54,720
essentially the

329
00:12:54,720 --> 00:12:56,800
predictors were trying to answer the

330
00:12:56,800 --> 00:13:00,560
question if branch is taken or not taken

331
00:13:00,560 --> 00:13:01,440
but

332
00:13:01,440 --> 00:13:03,920
we know that this is not the only

333
00:13:03,920 --> 00:13:07,279
kind of branches supported on x86 so

334
00:13:07,279 --> 00:13:09,680
what about the other branches

335
00:13:09,680 --> 00:13:12,560
and do they need a branch predictor at

336
00:13:12,560 --> 00:13:15,360
all and the answer is of course they do

337
00:13:15,360 --> 00:13:17,040
because another job of the branch

338
00:13:17,040 --> 00:13:20,639
prediction unit is to predict the target

339
00:13:20,639 --> 00:13:23,760
address of of the branch

340
00:13:23,760 --> 00:13:26,399
and this particular

341
00:13:26,399 --> 00:13:28,880
job is done by another subcomponent of

342
00:13:28,880 --> 00:13:32,079
gpus called branch target buffer

343
00:13:32,079 --> 00:13:35,920
in a very simple view um

344
00:13:35,920 --> 00:13:39,040
the branch target buffer is an array

345
00:13:39,040 --> 00:13:41,040
containing entries

346
00:13:41,040 --> 00:13:42,399
uh of

347
00:13:42,399 --> 00:13:43,440
containing

348
00:13:43,440 --> 00:13:45,120
entries with target addresses of

349
00:13:45,120 --> 00:13:46,720
encountered branches important

350
00:13:46,720 --> 00:13:48,560
information is the branch target buffer

351
00:13:48,560 --> 00:13:49,680
need is

352
00:13:49,680 --> 00:13:53,040
needed for all kinds of branches

353
00:13:53,040 --> 00:13:55,199
because frontend fetches and decodes

354
00:13:55,199 --> 00:13:58,160
instructions but doesn't execute them

355
00:13:58,160 --> 00:13:59,920
it has to know

356
00:13:59,920 --> 00:14:01,760
what's where to fetch the next

357
00:14:01,760 --> 00:14:03,440
instructions from

358
00:14:03,440 --> 00:14:06,079
and of course as we already uh

359
00:14:06,079 --> 00:14:07,279
discussed the

360
00:14:07,279 --> 00:14:09,040
it cannot wait for back and forth it's

361
00:14:09,040 --> 00:14:10,560
feedback

362
00:14:10,560 --> 00:14:13,440
um that's why the branch target buffer

363
00:14:13,440 --> 00:14:15,519
has a component of bpu and bpu is a

364
00:14:15,519 --> 00:14:18,240
component of of the front end now let's

365
00:14:18,240 --> 00:14:19,920
let's look why

366
00:14:19,920 --> 00:14:22,240
ptp is needed for all the

367
00:14:22,240 --> 00:14:24,240
branches so in case of direct

368
00:14:24,240 --> 00:14:26,240
conditional branches a branch can be

369
00:14:26,240 --> 00:14:27,839
taken or not taken

370
00:14:27,839 --> 00:14:29,680
if it's taken then

371
00:14:29,680 --> 00:14:30,399
the

372
00:14:30,399 --> 00:14:32,639
front-end job is easy it can just

373
00:14:32,639 --> 00:14:34,720
continue with next instruction

374
00:14:34,720 --> 00:14:35,839
block

375
00:14:35,839 --> 00:14:38,480
but when it's taken

376
00:14:38,480 --> 00:14:40,000
we need to

377
00:14:40,000 --> 00:14:42,639
answer the question where to

378
00:14:42,639 --> 00:14:45,519
the branch can be backward forward um to

379
00:14:45,519 --> 00:14:48,000
essentially any arbitrary

380
00:14:48,000 --> 00:14:50,399
address

381
00:14:50,639 --> 00:14:52,959
and um in case of direct unconditional

382
00:14:52,959 --> 00:14:55,360
branches the situation is a bit simpler

383
00:14:55,360 --> 00:14:56,720
because

384
00:14:56,720 --> 00:14:59,199
the branches are always taken however

385
00:14:59,199 --> 00:15:02,160
their target still needs to be predicted

386
00:15:02,160 --> 00:15:04,240
and finally for the indirect

387
00:15:04,240 --> 00:15:06,000
unconditional branches

388
00:15:06,000 --> 00:15:08,399
which are also always taken

389
00:15:08,399 --> 00:15:11,440
the target address needs to be predicted

390
00:15:11,440 --> 00:15:13,680
especially because it can change at

391
00:15:13,680 --> 00:15:16,480
runtime so it's not static and any sort

392
00:15:16,480 --> 00:15:19,600
of static predictions will simply not do

393
00:15:19,600 --> 00:15:21,360
and to implement

394
00:15:21,360 --> 00:15:22,880
efficiently the

395
00:15:22,880 --> 00:15:25,680
indirect unconditional branches the ptb

396
00:15:25,680 --> 00:15:27,519
becomes really crucial right so on this

397
00:15:27,519 --> 00:15:30,399
slide um you can see a simple

398
00:15:30,399 --> 00:15:32,399
artificial example of

399
00:15:32,399 --> 00:15:35,839
transfer the hybrid branch predictor

400
00:15:35,839 --> 00:15:38,240
now there's a section responsible for

401
00:15:38,240 --> 00:15:40,639
answering with branches taken or not

402
00:15:40,639 --> 00:15:44,720
taken and there is the btb which

403
00:15:44,720 --> 00:15:47,839
predicts the target address of a branch

404
00:15:47,839 --> 00:15:50,000
that's enough about the branch

405
00:15:50,000 --> 00:15:52,000
predictors let's

406
00:15:52,000 --> 00:15:53,519
talk a little bit about the straight

407
00:15:53,519 --> 00:15:56,399
line speculation in short sls so the

408
00:15:56,399 --> 00:15:58,320
straight line speculation term was going

409
00:15:58,320 --> 00:16:00,800
by arm and it was a result of a google

410
00:16:00,800 --> 00:16:03,040
safe side project research

411
00:16:03,040 --> 00:16:06,320
which was cv you can see on the screen

412
00:16:06,320 --> 00:16:08,560
and the initial release arm described as

413
00:16:08,560 --> 00:16:11,199
less as a speculative execution passed

414
00:16:11,199 --> 00:16:13,199
an unconditional change in the control

415
00:16:13,199 --> 00:16:14,399
flow

416
00:16:14,399 --> 00:16:17,279
and quoting the arms white paper on the

417
00:16:17,279 --> 00:16:20,160
topic straight line speculation would

418
00:16:20,160 --> 00:16:22,720
involve the processor speculatively

419
00:16:22,720 --> 00:16:26,240
executing the next instructions linearly

420
00:16:26,240 --> 00:16:28,480
in memory past the unconditional change

421
00:16:28,480 --> 00:16:30,399
in the control flow

422
00:16:30,399 --> 00:16:33,199
moreover arms stated that they were only

423
00:16:33,199 --> 00:16:35,199
able to see the

424
00:16:35,199 --> 00:16:36,959
sls

425
00:16:36,959 --> 00:16:40,000
in the context of indirect unconditional

426
00:16:40,000 --> 00:16:42,720
branches on their arm cpus and they

427
00:16:42,720 --> 00:16:44,880
weren't able to reproduce the same

428
00:16:44,880 --> 00:16:46,399
effect on

429
00:16:46,399 --> 00:16:48,880
direct branches

430
00:16:48,880 --> 00:16:51,519
shortly after the sls was also observed

431
00:16:51,519 --> 00:16:54,720
on some x86 cpus

432
00:16:54,720 --> 00:16:56,639
and also in the context of indirect

433
00:16:56,639 --> 00:16:58,959
unconditional branches so indirect

434
00:16:58,959 --> 00:17:01,759
colors jumps and of course red return

435
00:17:01,759 --> 00:17:03,279
instructions

436
00:17:03,279 --> 00:17:04,880
however

437
00:17:04,880 --> 00:17:07,359
very likely sls has

438
00:17:07,359 --> 00:17:09,359
to have been observed on

439
00:17:09,359 --> 00:17:12,079
x86 cpus a bit earlier than

440
00:17:12,079 --> 00:17:14,720
on the arm publication

441
00:17:14,720 --> 00:17:17,839
mainly because trapped instructions

442
00:17:17,839 --> 00:17:20,799
blocking the sls speculation

443
00:17:20,799 --> 00:17:24,079
appeared after red instructions circa

444
00:17:24,079 --> 00:17:26,959
2018 in microsoft windows operating

445
00:17:26,959 --> 00:17:28,079
system

446
00:17:28,079 --> 00:17:31,200
and as a result also appeared in 2019 in

447
00:17:31,200 --> 00:17:33,840
our gr security product all right okay

448
00:17:33,840 --> 00:17:36,720
um so so far we know that sls can occur

449
00:17:36,720 --> 00:17:38,960
on indirect unconditional

450
00:17:38,960 --> 00:17:42,320
jumps calls and red instructions on the

451
00:17:42,320 --> 00:17:44,480
screen you can see free diagrams

452
00:17:44,480 --> 00:17:46,559
describing the situation

453
00:17:46,559 --> 00:17:48,320
and the

454
00:17:48,320 --> 00:17:51,280
big rectangle is simply

455
00:17:51,280 --> 00:17:53,280
the coded instruction block which

456
00:17:53,280 --> 00:17:56,000
consists of some x86 instructions the

457
00:17:56,000 --> 00:17:59,679
frontend is front end is operating on

458
00:17:59,679 --> 00:18:02,559
and each of the diagrams has one

459
00:18:02,559 --> 00:18:04,720
indirect unconditional branch in some

460
00:18:04,720 --> 00:18:07,360
place and according to the sls

461
00:18:07,360 --> 00:18:08,640
definition

462
00:18:08,640 --> 00:18:10,559
the following

463
00:18:10,559 --> 00:18:12,799
the instructions following the branch

464
00:18:12,799 --> 00:18:18,240
can be executed speculatively under sls

465
00:18:18,720 --> 00:18:21,679
but one may wonder what about direct

466
00:18:21,679 --> 00:18:23,120
branches

467
00:18:23,120 --> 00:18:25,760
we were talking about indirect ones for

468
00:18:25,760 --> 00:18:27,200
a while

469
00:18:27,200 --> 00:18:28,880
so let's see

470
00:18:28,880 --> 00:18:30,799
this is basically where my little

471
00:18:30,799 --> 00:18:32,000
discovery

472
00:18:32,000 --> 00:18:34,160
comes into play

473
00:18:34,160 --> 00:18:37,440
basically it turns out that on some amd

474
00:18:37,440 --> 00:18:41,039
x86 cpus um zen one and sent to

475
00:18:41,039 --> 00:18:43,280
microarchitecture specifically

476
00:18:43,280 --> 00:18:45,600
all direct unconditional branch

477
00:18:45,600 --> 00:18:47,600
instructions experience sls

478
00:18:47,600 --> 00:18:50,080
vulnerability as well

479
00:18:50,080 --> 00:18:52,720
so the jumps and calls with encoded

480
00:18:52,720 --> 00:18:54,400
target address

481
00:18:54,400 --> 00:18:56,240
still can be speculated over and the

482
00:18:56,240 --> 00:18:57,600
following

483
00:18:57,600 --> 00:18:59,840
instructions could get speculatively

484
00:18:59,840 --> 00:19:01,280
executed

485
00:19:01,280 --> 00:19:03,280
furthermore branch direction doesn't

486
00:19:03,280 --> 00:19:05,520
really matter forward and backward

487
00:19:05,520 --> 00:19:08,320
branches suffer from the sls the same

488
00:19:08,320 --> 00:19:09,360
way

489
00:19:09,360 --> 00:19:11,840
and what's surprising and interesting

490
00:19:11,840 --> 00:19:14,400
it's even possible to trigger the sls

491
00:19:14,400 --> 00:19:16,559
between two co-located hyper threads

492
00:19:16,559 --> 00:19:18,799
running on the same core

493
00:19:18,799 --> 00:19:22,880
and interestingly uh the amd x86 zenfree

494
00:19:22,880 --> 00:19:25,039
micro microarchitecture doesn't seem to

495
00:19:25,039 --> 00:19:26,480
be affected by

496
00:19:26,480 --> 00:19:30,160
the sls on direct unconditional branches

497
00:19:30,160 --> 00:19:32,640
we know that zenfriar micro architecture

498
00:19:32,640 --> 00:19:35,520
receives a relatively big design upgrade

499
00:19:35,520 --> 00:19:36,640
of their

500
00:19:36,640 --> 00:19:38,480
branch predictor unit

501
00:19:38,480 --> 00:19:41,600
and apparently the sls

502
00:19:41,600 --> 00:19:43,840
problem has been fixed there

503
00:19:43,840 --> 00:19:46,240
one may wonder if it was intentional or

504
00:19:46,240 --> 00:19:48,960
accidental i don't know my money is

505
00:19:48,960 --> 00:19:51,120
however on a happy coincidence all right

506
00:19:51,120 --> 00:19:54,240
so now the the most interesting question

507
00:19:54,240 --> 00:19:57,600
why on earth would a sane modern cpu

508
00:19:57,600 --> 00:19:59,919
speculate as a direct unconditional

509
00:19:59,919 --> 00:20:01,440
branch right

510
00:20:01,440 --> 00:20:02,799
after all

511
00:20:02,799 --> 00:20:05,679
the target is encoded target address of

512
00:20:05,679 --> 00:20:08,559
the branch is encoded into the ins as

513
00:20:08,559 --> 00:20:10,400
part of the instruction

514
00:20:10,400 --> 00:20:12,480
so everything seems to be given on a

515
00:20:12,480 --> 00:20:13,919
golden plate

516
00:20:13,919 --> 00:20:16,159
there is also no latency involved

517
00:20:16,159 --> 00:20:18,320
because the branch is unconditional so

518
00:20:18,320 --> 00:20:20,880
there are no conditions to be evaluated

519
00:20:20,880 --> 00:20:23,039
that could contribute to

520
00:20:23,039 --> 00:20:25,840
to the latency

521
00:20:26,080 --> 00:20:27,200
so now

522
00:20:27,200 --> 00:20:28,480
let's see

523
00:20:28,480 --> 00:20:30,799
why

524
00:20:30,960 --> 00:20:33,840
so on this diagram you can again see at

525
00:20:33,840 --> 00:20:36,640
the coded instruction block which on amd

526
00:20:36,640 --> 00:20:38,320
is 16

527
00:20:38,320 --> 00:20:41,440
buys worth of x86 instruction

528
00:20:41,440 --> 00:20:43,200
and the arrow indicates that there is a

529
00:20:43,200 --> 00:20:46,159
branch uh instruction in it and i

530
00:20:46,159 --> 00:20:48,960
explicitly didn't uh state what kind of

531
00:20:48,960 --> 00:20:50,320
branch this is

532
00:20:50,320 --> 00:20:52,159
direct or indirect

533
00:20:52,159 --> 00:20:53,600
uh all we know

534
00:20:53,600 --> 00:20:54,640
for now

535
00:20:54,640 --> 00:20:55,760
that it's

536
00:20:55,760 --> 00:20:59,200
unconditional but and it turns out that

537
00:20:59,200 --> 00:21:00,720
it doesn't matter if it's direct or

538
00:21:00,720 --> 00:21:02,799
entire

539
00:21:02,799 --> 00:21:05,200
so the front end operating on the stick

540
00:21:05,200 --> 00:21:06,720
of the instruction block at some point

541
00:21:06,720 --> 00:21:09,120
realizes that there is a branch so it

542
00:21:09,120 --> 00:21:10,240
needs to

543
00:21:10,240 --> 00:21:12,320
predict what's the target address so it

544
00:21:12,320 --> 00:21:14,720
could continue

545
00:21:14,720 --> 00:21:17,280
and to do so it asks

546
00:21:17,280 --> 00:21:20,000
bpu and specifically branch target

547
00:21:20,000 --> 00:21:21,440
buffer

548
00:21:21,440 --> 00:21:23,760
for the target address prediction and

549
00:21:23,760 --> 00:21:27,360
now it could go two ways

550
00:21:27,360 --> 00:21:28,840
now happy

551
00:21:28,840 --> 00:21:30,480
um

552
00:21:30,480 --> 00:21:33,520
in a happy situation the btb is able to

553
00:21:33,520 --> 00:21:36,159
predict the target address correctly and

554
00:21:36,159 --> 00:21:40,720
front end can resume execution of the

555
00:21:40,720 --> 00:21:44,080
target address and fetch the new the

556
00:21:44,080 --> 00:21:46,960
coded instruction block and and start

557
00:21:46,960 --> 00:21:48,640
processing it

558
00:21:48,640 --> 00:21:51,440
however in case of misprediction when

559
00:21:51,440 --> 00:21:55,679
bpu cannot answer the question about the

560
00:21:55,679 --> 00:21:58,559
target about the target address

561
00:21:58,559 --> 00:22:01,120
the uh frontend is in some sort of

562
00:22:01,120 --> 00:22:02,080
optical

563
00:22:02,080 --> 00:22:04,000
because it knows there's a branch but it

564
00:22:04,000 --> 00:22:06,320
doesn't know where the branch goes to

565
00:22:06,320 --> 00:22:08,320
and there is also a bunch of other

566
00:22:08,320 --> 00:22:11,280
instructions uh following the branch

567
00:22:11,280 --> 00:22:12,640
so

568
00:22:12,640 --> 00:22:15,840
apparently the amd cpus

569
00:22:15,840 --> 00:22:18,400
decided to simply

570
00:22:18,400 --> 00:22:20,799
process the code and dispatch all of the

571
00:22:20,799 --> 00:22:22,799
instructions including the ones

572
00:22:22,799 --> 00:22:24,640
following the

573
00:22:24,640 --> 00:22:28,559
the branch instruction as well

574
00:22:28,559 --> 00:22:30,960
and some of these um

575
00:22:30,960 --> 00:22:33,600
instructions dispatched for execution to

576
00:22:33,600 --> 00:22:36,000
the backend may actually

577
00:22:36,000 --> 00:22:39,039
become speculatively executed by the bug

578
00:22:39,039 --> 00:22:40,720
and remember that

579
00:22:40,720 --> 00:22:43,919
second is out of order

580
00:22:44,159 --> 00:22:45,280
so

581
00:22:45,280 --> 00:22:47,919
in such a case um

582
00:22:47,919 --> 00:22:49,039
backhand

583
00:22:49,039 --> 00:22:52,400
in the meantime backhand is still a busy

584
00:22:52,400 --> 00:22:54,960
processing the jump instruction but at

585
00:22:54,960 --> 00:22:56,880
some point it realized

586
00:22:56,880 --> 00:22:58,960
it realizes that

587
00:22:58,960 --> 00:23:00,880
their front-end

588
00:23:00,880 --> 00:23:03,280
committed a misprediction

589
00:23:03,280 --> 00:23:06,880
so it will first of all

590
00:23:06,880 --> 00:23:09,280
inform front-end about the misprediction

591
00:23:09,280 --> 00:23:11,679
update the branch target buffer address

592
00:23:11,679 --> 00:23:13,600
for for a given branch

593
00:23:13,600 --> 00:23:17,280
and rest your front-end to the correct

594
00:23:17,280 --> 00:23:20,559
address for the branch and

595
00:23:20,559 --> 00:23:24,159
also it will trigger the pipeline flash

596
00:23:24,159 --> 00:23:27,120
which will discard all the um

597
00:23:27,120 --> 00:23:29,520
speculatively executed instructions

598
00:23:29,520 --> 00:23:33,200
under sls as well as the pending escape

599
00:23:33,200 --> 00:23:34,400
instructions

600
00:23:34,400 --> 00:23:36,159
however

601
00:23:36,159 --> 00:23:39,600
if the speculative uh instructions have

602
00:23:39,600 --> 00:23:42,640
architecturally observable uh side

603
00:23:42,640 --> 00:23:45,679
effects like for example the memory load

604
00:23:45,679 --> 00:23:48,720
you know we can see here on the diagram

605
00:23:48,720 --> 00:23:51,760
then and though the effects the side

606
00:23:51,760 --> 00:23:54,159
effects could be later sensed using some

607
00:23:54,159 --> 00:23:55,840
sort of side channel

608
00:23:55,840 --> 00:24:00,720
and that could potentially lead to some

609
00:24:00,720 --> 00:24:03,679
secret information leak

610
00:24:03,679 --> 00:24:06,159
and in a nutshell this is how

611
00:24:06,159 --> 00:24:08,400
and why the straight line speculation

612
00:24:08,400 --> 00:24:10,240
happens

613
00:24:10,240 --> 00:24:13,520
okay so um what do we know we know

614
00:24:13,520 --> 00:24:16,080
that if there is no entry into in the

615
00:24:16,080 --> 00:24:18,320
btb uh the given branch can be

616
00:24:18,320 --> 00:24:19,760
mispredicted

617
00:24:19,760 --> 00:24:20,559
and

618
00:24:20,559 --> 00:24:22,320
sls might occur

619
00:24:22,320 --> 00:24:25,120
and that's true for any kind of branch

620
00:24:25,120 --> 00:24:27,039
and in practice it means that we can

621
00:24:27,039 --> 00:24:29,919
easily and reliably

622
00:24:29,919 --> 00:24:33,120
make affected amd cpus mispredict any

623
00:24:33,120 --> 00:24:35,440
branch regardless if it's directly

624
00:24:35,440 --> 00:24:38,720
direct conditional or unconditional

625
00:24:38,720 --> 00:24:40,480
and you can have the

626
00:24:40,480 --> 00:24:42,559
branch following instructions executed

627
00:24:42,559 --> 00:24:45,200
speculatively

628
00:24:45,200 --> 00:24:47,840
um how do we do that we essentially just

629
00:24:47,840 --> 00:24:49,679
need to make sure that btb doesn't have

630
00:24:49,679 --> 00:24:51,600
an entry for a given branch and the

631
00:24:51,600 --> 00:24:53,919
simplest way of course is to flash

632
00:24:53,919 --> 00:24:57,039
entire btb

633
00:24:57,120 --> 00:24:58,840
now what does

634
00:24:58,840 --> 00:25:00,400
the

635
00:25:00,400 --> 00:25:02,320
so how to do that um

636
00:25:02,320 --> 00:25:04,320
on the screen you can see the macro i

637
00:25:04,320 --> 00:25:07,120
used in my experiment for flashing the

638
00:25:07,120 --> 00:25:10,320
wtv and it looks scary but it's actually

639
00:25:10,320 --> 00:25:12,000
quite simple

640
00:25:12,000 --> 00:25:14,400
the idea is that if we

641
00:25:14,400 --> 00:25:16,960
upfront execute enough

642
00:25:16,960 --> 00:25:18,080
uh

643
00:25:18,080 --> 00:25:19,279
enough

644
00:25:19,279 --> 00:25:21,279
unconditional branches

645
00:25:21,279 --> 00:25:24,720
to basically consume every entry of uh

646
00:25:24,720 --> 00:25:29,760
btb with um target dollars of our branch

647
00:25:29,760 --> 00:25:31,200
then um

648
00:25:31,200 --> 00:25:34,480
the previous state of of the btb will be

649
00:25:34,480 --> 00:25:37,039
flashed out and btb will

650
00:25:37,039 --> 00:25:38,880
be unable to

651
00:25:38,880 --> 00:25:43,440
predict any new branches

652
00:25:43,440 --> 00:25:44,400
okay

653
00:25:44,400 --> 00:25:47,440
now let's talk what can be achieved

654
00:25:47,440 --> 00:25:50,240
during the sls speculation window

655
00:25:50,240 --> 00:25:51,679
so in theory

656
00:25:51,679 --> 00:25:54,240
up to eight simple and short x86

657
00:25:54,240 --> 00:25:56,000
instructions can be speculatively

658
00:25:56,000 --> 00:25:59,440
executed but in practice i only managed

659
00:25:59,440 --> 00:26:02,720
to execute four or five short x86

660
00:26:02,720 --> 00:26:05,600
instructions that additionally

661
00:26:05,600 --> 00:26:07,039
do not compete

662
00:26:07,039 --> 00:26:09,200
for execution units

663
00:26:09,200 --> 00:26:11,200
and as part of those four or five

664
00:26:11,200 --> 00:26:12,799
instructions

665
00:26:12,799 --> 00:26:15,760
two of them could be memory loads

666
00:26:15,760 --> 00:26:18,400
that also get executed speculatively

667
00:26:18,400 --> 00:26:20,159
however

668
00:26:20,159 --> 00:26:23,440
the loads even if precache

669
00:26:23,440 --> 00:26:24,640
cannot

670
00:26:24,640 --> 00:26:25,919
finish

671
00:26:25,919 --> 00:26:28,320
on time before back and realizes that

672
00:26:28,320 --> 00:26:32,640
there has been a misprediction and

673
00:26:32,640 --> 00:26:34,720
flashes the pipeline

674
00:26:34,720 --> 00:26:35,760
that means

675
00:26:35,760 --> 00:26:37,760
that the memory loads cannot provide

676
00:26:37,760 --> 00:26:39,120
data to

677
00:26:39,120 --> 00:26:40,720
their dependent

678
00:26:40,720 --> 00:26:42,559
microbes

679
00:26:42,559 --> 00:26:44,000
however

680
00:26:44,000 --> 00:26:46,080
the loads get scheduled and at some

681
00:26:46,080 --> 00:26:47,039
point

682
00:26:47,039 --> 00:26:48,880
they will

683
00:26:48,880 --> 00:26:51,279
leave the architecturally observable

684
00:26:51,279 --> 00:26:54,240
traces for example by filling the

685
00:26:54,240 --> 00:26:56,720
cache hierarchy with a memory cache line

686
00:26:56,720 --> 00:27:00,720
changing the observable state that way

687
00:27:00,720 --> 00:27:01,919
and

688
00:27:01,919 --> 00:27:04,400
when it comes to limitations it means

689
00:27:04,400 --> 00:27:07,279
that with this kind of sls

690
00:27:07,279 --> 00:27:08,720
um

691
00:27:08,720 --> 00:27:12,240
speculation we cannot construct a full

692
00:27:12,240 --> 00:27:14,000
spectrum v1 gadget

693
00:27:14,000 --> 00:27:17,120
mainly because the loads do not finish

694
00:27:17,120 --> 00:27:18,320
on time

695
00:27:18,320 --> 00:27:20,000
however if

696
00:27:20,000 --> 00:27:22,640
secret data is already available in

697
00:27:22,640 --> 00:27:24,000
registers

698
00:27:24,000 --> 00:27:27,279
before the sls speculation window begins

699
00:27:27,279 --> 00:27:28,159
and

700
00:27:28,159 --> 00:27:29,440
the window

701
00:27:29,440 --> 00:27:31,279
the instructions in the window do use

702
00:27:31,279 --> 00:27:33,039
those registers

703
00:27:33,039 --> 00:27:35,840
there is a potential for an sls gadget

704
00:27:35,840 --> 00:27:37,919
that could leak

705
00:27:37,919 --> 00:27:41,440
information bits about the secret data

706
00:27:41,440 --> 00:27:43,200
alternatively

707
00:27:43,200 --> 00:27:45,679
i realized that

708
00:27:45,679 --> 00:27:46,720
loads

709
00:27:46,720 --> 00:27:50,080
memory loads executing under sls

710
00:27:50,080 --> 00:27:52,240
receive data

711
00:27:52,240 --> 00:27:53,840
from earlier

712
00:27:53,840 --> 00:27:56,399
stores via store to load forwarding

713
00:27:56,399 --> 00:28:00,559
mechanism are fast enough and do finish

714
00:28:00,559 --> 00:28:03,360
before the speculation window

715
00:28:03,360 --> 00:28:04,880
is terminated

716
00:28:04,880 --> 00:28:07,840
and thereby those loads can

717
00:28:07,840 --> 00:28:10,320
and do provide data to the dependent

718
00:28:10,320 --> 00:28:11,840
micros

719
00:28:11,840 --> 00:28:12,559
and

720
00:28:12,559 --> 00:28:15,520
start to load forwarding is a feature of

721
00:28:15,520 --> 00:28:17,679
modern pipelines

722
00:28:17,679 --> 00:28:19,919
which essentially forwards data for

723
00:28:19,919 --> 00:28:23,200
completed but not yet retired stores to

724
00:28:23,200 --> 00:28:25,200
the later loads

725
00:28:25,200 --> 00:28:26,559
and

726
00:28:26,559 --> 00:28:28,640
they do so because

727
00:28:28,640 --> 00:28:30,559
in order to defeat the

728
00:28:30,559 --> 00:28:32,320
right of the right or

729
00:28:32,320 --> 00:28:34,640
right after read dependencies uh the

730
00:28:34,640 --> 00:28:36,880
other pump lines employ a structure

731
00:28:36,880 --> 00:28:39,919
called store q which

732
00:28:39,919 --> 00:28:42,640
buffers the depending stores and

733
00:28:42,640 --> 00:28:44,880
whenever later load to the same memory

734
00:28:44,880 --> 00:28:46,799
address occurs it

735
00:28:46,799 --> 00:28:49,120
must receive of course the fresh data so

736
00:28:49,120 --> 00:28:52,559
it receives it either from stroke you or

737
00:28:52,559 --> 00:28:54,320
from memory okay

738
00:28:54,320 --> 00:28:55,840
so

739
00:28:55,840 --> 00:28:56,720
um

740
00:28:56,720 --> 00:28:58,559
now um

741
00:28:58,559 --> 00:29:00,480
let's talk about the

742
00:29:00,480 --> 00:29:02,399
sls mitigations

743
00:29:02,399 --> 00:29:04,880
we know that uh well it's it's easy to

744
00:29:04,880 --> 00:29:07,919
see that direct indirect unconditional

745
00:29:07,919 --> 00:29:10,240
jump instructions as well as function

746
00:29:10,240 --> 00:29:12,880
return instructions are somewhat easier

747
00:29:12,880 --> 00:29:16,399
to mitigate than for instance calls

748
00:29:16,399 --> 00:29:18,000
and why is that

749
00:29:18,000 --> 00:29:19,840
mainly because the

750
00:29:19,840 --> 00:29:22,080
execution flow

751
00:29:22,080 --> 00:29:24,720
doesn't continue

752
00:29:24,720 --> 00:29:27,120
past the branch instruction at least not

753
00:29:27,120 --> 00:29:29,840
sequentially that means uh we can easily

754
00:29:29,840 --> 00:29:32,399
put a speculative execution barrier um

755
00:29:32,399 --> 00:29:34,159
that is some sort of serializing

756
00:29:34,159 --> 00:29:35,840
instruction for instance

757
00:29:35,840 --> 00:29:37,279
that would uh

758
00:29:37,279 --> 00:29:40,880
immediately terminate uh

759
00:29:40,880 --> 00:29:43,440
the speculation window there

760
00:29:43,440 --> 00:29:46,880
however for for calls the sls mitigation

761
00:29:46,880 --> 00:29:49,760
is a bit more complicated because

762
00:29:49,760 --> 00:29:51,279
naturally

763
00:29:51,279 --> 00:29:54,159
the control flow resumes directly after

764
00:29:54,159 --> 00:29:55,840
the call instruction

765
00:29:55,840 --> 00:29:57,919
basically at some point the called

766
00:29:57,919 --> 00:29:58,960
function

767
00:29:58,960 --> 00:30:01,039
returns and

768
00:30:01,039 --> 00:30:04,640
execution architectural execution

769
00:30:04,640 --> 00:30:06,080
resumes

770
00:30:06,080 --> 00:30:06,799
so

771
00:30:06,799 --> 00:30:08,720
that means the speculative execution

772
00:30:08,720 --> 00:30:10,159
barrier will get executed

773
00:30:10,159 --> 00:30:12,480
architecturally as well

774
00:30:12,480 --> 00:30:15,360
and because of that it must not have any

775
00:30:15,360 --> 00:30:18,799
architectural side effects so the uh

776
00:30:18,799 --> 00:30:20,320
it's harder to find a suitable

777
00:30:20,320 --> 00:30:23,039
instruction uh so getting back to the

778
00:30:23,039 --> 00:30:25,039
jumps and reds um

779
00:30:25,039 --> 00:30:28,399
so the these ones are ideally mitigated

780
00:30:28,399 --> 00:30:31,840
using an int free instruction which is

781
00:30:31,840 --> 00:30:34,399
conveniently a single byte op code

782
00:30:34,399 --> 00:30:37,679
and um it it simply is a software

783
00:30:37,679 --> 00:30:39,679
invocation of

784
00:30:39,679 --> 00:30:42,240
of a breakpoint uh exception

785
00:30:42,240 --> 00:30:44,399
and uh which uh

786
00:30:44,399 --> 00:30:46,559
changes the control flow uh to the

787
00:30:46,559 --> 00:30:48,559
breakpoint exception handler placing

788
00:30:48,559 --> 00:30:51,120
such instruction after a branch is

789
00:30:51,120 --> 00:30:53,120
supposed to

790
00:30:53,120 --> 00:30:54,960
terminate the speculation

791
00:30:54,960 --> 00:30:56,720
so here we have again the coded

792
00:30:56,720 --> 00:30:58,080
instruction block

793
00:30:58,080 --> 00:31:00,480
with a jump in it followed by the end

794
00:31:00,480 --> 00:31:02,880
free instruction i denoted the

795
00:31:02,880 --> 00:31:05,440
serializing or instruction ordering

796
00:31:05,440 --> 00:31:07,519
capabilities of the end free by this

797
00:31:07,519 --> 00:31:10,159
extra bars now this essentially means

798
00:31:10,159 --> 00:31:12,720
the only escaped and potentially sls

799
00:31:12,720 --> 00:31:15,200
executed instruction after the branch is

800
00:31:15,200 --> 00:31:18,080
the in-free itself

801
00:31:18,080 --> 00:31:19,600
the back end

802
00:31:19,600 --> 00:31:21,760
is busy processing the the jump

803
00:31:21,760 --> 00:31:25,039
instruction as well as the escape in

804
00:31:25,039 --> 00:31:27,679
free instruction with its

805
00:31:27,679 --> 00:31:29,840
serializing nature

806
00:31:29,840 --> 00:31:32,570
and either because of the um

807
00:31:32,570 --> 00:31:33,679
[Music]

808
00:31:33,679 --> 00:31:35,840
either it's done processing the branch

809
00:31:35,840 --> 00:31:37,039
instruction and detects the

810
00:31:37,039 --> 00:31:38,320
misprediction

811
00:31:38,320 --> 00:31:40,159
or

812
00:31:40,159 --> 00:31:40,880
the

813
00:31:40,880 --> 00:31:43,679
int free instruction um

814
00:31:43,679 --> 00:31:46,240
triggers the pipeline flash in the back

815
00:31:46,240 --> 00:31:47,039
end

816
00:31:47,039 --> 00:31:48,159
however

817
00:31:48,159 --> 00:31:50,159
the the

818
00:31:50,159 --> 00:31:52,480
regardless of the the actual root cause

819
00:31:52,480 --> 00:31:54,159
the reminder of the instructions

820
00:31:54,159 --> 00:31:56,960
following the in free instruction cannot

821
00:31:56,960 --> 00:32:00,320
possibly get executed

822
00:32:00,320 --> 00:32:02,640
so um this is

823
00:32:02,640 --> 00:32:04,960
in a very short

824
00:32:04,960 --> 00:32:07,440
in a natural why uh the in-free

825
00:32:07,440 --> 00:32:11,120
mitigation is successful

826
00:32:11,120 --> 00:32:13,519
okay so now let's quickly talk about

827
00:32:13,519 --> 00:32:15,360
calls

828
00:32:15,360 --> 00:32:18,320
so calls as we already said um have to

829
00:32:18,320 --> 00:32:20,799
execute the the following speculation

830
00:32:20,799 --> 00:32:23,039
barrier instruction so obviously the in

831
00:32:23,039 --> 00:32:25,840
free with its control

832
00:32:25,840 --> 00:32:27,519
exception handler call

833
00:32:27,519 --> 00:32:29,440
would not do

834
00:32:29,440 --> 00:32:32,080
imd in this case recommend using

835
00:32:32,080 --> 00:32:33,279
elephants

836
00:32:33,279 --> 00:32:35,440
instruction

837
00:32:35,440 --> 00:32:37,279
which is which can also be made

838
00:32:37,279 --> 00:32:39,200
serializing on amd

839
00:32:39,200 --> 00:32:41,919
this is however not a very good idea for

840
00:32:41,919 --> 00:32:44,480
performance because in modern software

841
00:32:44,480 --> 00:32:46,480
calls are everywhere there's plenty of

842
00:32:46,480 --> 00:32:47,360
them

843
00:32:47,360 --> 00:32:48,320
and

844
00:32:48,320 --> 00:32:50,080
guarding each of the call sites with an

845
00:32:50,080 --> 00:32:52,080
elephants

846
00:32:52,080 --> 00:32:55,120
will be detrimental the tremendous to

847
00:32:55,120 --> 00:32:57,120
performance

848
00:32:57,120 --> 00:32:58,000
why

849
00:32:58,000 --> 00:32:59,679
mainly because

850
00:32:59,679 --> 00:33:02,080
serializing instructions deliberately

851
00:33:02,080 --> 00:33:04,480
slow down backhand to to wait for the

852
00:33:04,480 --> 00:33:06,640
prior instructions to finish so a

853
00:33:06,640 --> 00:33:09,360
constant slow down of the back end will

854
00:33:09,360 --> 00:33:11,200
obviously

855
00:33:11,200 --> 00:33:12,799
slow down the

856
00:33:12,799 --> 00:33:15,039
remove the the performance decrease the

857
00:33:15,039 --> 00:33:16,559
performance

858
00:33:16,559 --> 00:33:19,120
another interesting mitigation however

859
00:33:19,120 --> 00:33:20,399
is

860
00:33:20,399 --> 00:33:21,760
the

861
00:33:21,760 --> 00:33:25,519
xor eax eax which essentially zeros out

862
00:33:25,519 --> 00:33:27,120
the eax

863
00:33:27,120 --> 00:33:29,200
it's both complicated and kind of

864
00:33:29,200 --> 00:33:31,519
counterintuitive so um you might wonder

865
00:33:31,519 --> 00:33:34,880
why would the zorin eax work in the

866
00:33:34,880 --> 00:33:36,240
first place

867
00:33:36,240 --> 00:33:38,480
well it's the idea is based on a

868
00:33:38,480 --> 00:33:40,320
compiler post called behavior

869
00:33:40,320 --> 00:33:41,600
assumptions

870
00:33:41,600 --> 00:33:43,360
um the way

871
00:33:43,360 --> 00:33:47,360
the the compiler lies uh decode uh after

872
00:33:47,360 --> 00:33:49,600
the call instruction

873
00:33:49,600 --> 00:33:51,840
so in the for example the colic robot

874
00:33:51,840 --> 00:33:53,039
registers

875
00:33:53,039 --> 00:33:55,840
will not be used by the compiler after

876
00:33:55,840 --> 00:33:58,960
the call without a prior rewrite which

877
00:33:58,960 --> 00:34:00,080
means

878
00:34:00,080 --> 00:34:03,120
that the called function modifies

879
00:34:03,120 --> 00:34:05,120
some registers that the club art wants

880
00:34:05,120 --> 00:34:07,600
and the compiler is unable to reason

881
00:34:07,600 --> 00:34:10,879
about their state so it has to reload it

882
00:34:10,879 --> 00:34:13,599
before using it and this reload will

883
00:34:13,599 --> 00:34:16,079
essentially

884
00:34:16,159 --> 00:34:18,079
render those registers rather

885
00:34:18,079 --> 00:34:19,839
uninteresting for

886
00:34:19,839 --> 00:34:21,520
the sls gadget

887
00:34:21,520 --> 00:34:22,879
exploitation

888
00:34:22,879 --> 00:34:25,760
because um they cannot execute

889
00:34:25,760 --> 00:34:27,760
percolatively with the previously

890
00:34:27,760 --> 00:34:30,399
undefined value

891
00:34:30,399 --> 00:34:32,000
on the other hand

892
00:34:32,000 --> 00:34:34,719
the koli preserved registers

893
00:34:34,719 --> 00:34:37,280
are preserved which means um the

894
00:34:37,280 --> 00:34:39,839
value doesn't change before and after

895
00:34:39,839 --> 00:34:41,199
the call

896
00:34:41,199 --> 00:34:42,639
and as such

897
00:34:42,639 --> 00:34:46,480
if there is no um other software backs

898
00:34:46,480 --> 00:34:48,800
that they their usefulness for sls

899
00:34:48,800 --> 00:34:50,639
gadget exploitation is also fairly

900
00:34:50,639 --> 00:34:51,760
limited

901
00:34:51,760 --> 00:34:55,119
so what is left is the uh return value

902
00:34:55,119 --> 00:34:57,760
register the eax on

903
00:34:57,760 --> 00:34:59,200
x86

904
00:34:59,200 --> 00:35:01,359
this one um

905
00:35:01,359 --> 00:35:04,880
might be abused um because this

906
00:35:04,880 --> 00:35:07,760
speculative execution under the sls

907
00:35:07,760 --> 00:35:09,040
may

908
00:35:09,040 --> 00:35:11,520
run and execute instructions with the

909
00:35:11,520 --> 00:35:14,560
value of the ex before the call

910
00:35:14,560 --> 00:35:17,920
however if we clear the ex register

911
00:35:17,920 --> 00:35:20,160
before the call setting it to some an

912
00:35:20,160 --> 00:35:22,720
interesting value like 0

913
00:35:22,720 --> 00:35:26,240
the usefulness of this registers in

914
00:35:26,240 --> 00:35:28,160
sls

915
00:35:28,160 --> 00:35:31,119
gadget will also be reduced to

916
00:35:31,119 --> 00:35:32,400
zero and

917
00:35:32,400 --> 00:35:36,079
why this mitigation is complicated um

918
00:35:36,079 --> 00:35:37,599
basically it's based on compiler

919
00:35:37,599 --> 00:35:39,440
assumptions and the assumptions might

920
00:35:39,440 --> 00:35:41,520
not always hold there are kind of

921
00:35:41,520 --> 00:35:44,079
compile implementation dependent

922
00:35:44,079 --> 00:35:45,200
furthermore

923
00:35:45,200 --> 00:35:49,119
some calling convention apis use eax as

924
00:35:49,119 --> 00:35:51,440
function input parameter like fast call

925
00:35:51,440 --> 00:35:54,320
for example or regparm3

926
00:35:54,320 --> 00:35:57,520
also bariatic functions may use eax as

927
00:35:57,520 --> 00:36:00,480
an input parameter and of course if ax

928
00:36:00,480 --> 00:36:02,640
is used as input parameter we cannot

929
00:36:02,640 --> 00:36:06,079
zero it out will nearly before calls

930
00:36:06,079 --> 00:36:08,240
in addition to that

931
00:36:08,240 --> 00:36:10,640
some small structures

932
00:36:10,640 --> 00:36:13,599
tend to be returned from functions using

933
00:36:13,599 --> 00:36:17,040
a combo of eax and edx registers

934
00:36:17,040 --> 00:36:18,960
which means we have to also take care of

935
00:36:18,960 --> 00:36:20,079
edx

936
00:36:20,079 --> 00:36:22,160
register sometimes and

937
00:36:22,160 --> 00:36:24,240
we cannot do that for the same reason as

938
00:36:24,240 --> 00:36:26,960
before because edx might be

939
00:36:26,960 --> 00:36:28,800
and usually is a function input

940
00:36:28,800 --> 00:36:30,240
parameter

941
00:36:30,240 --> 00:36:33,680
and last but not least there is a

942
00:36:33,680 --> 00:36:37,040
indirect call using eax register as its

943
00:36:37,040 --> 00:36:39,599
operand specifying the target address

944
00:36:39,599 --> 00:36:42,640
and obviously we cannot zero out the ex

945
00:36:42,640 --> 00:36:44,880
register before on this instruction as

946
00:36:44,880 --> 00:36:46,240
well

947
00:36:46,240 --> 00:36:49,680
so i hope now you understand why this

948
00:36:49,680 --> 00:36:52,079
mitigation is

949
00:36:52,079 --> 00:36:54,560
kind of complicated to apply in practice

950
00:36:54,560 --> 00:36:56,720
however it definitely

951
00:36:56,720 --> 00:36:58,160
provides better

952
00:36:58,160 --> 00:37:00,320
performance it has better performance

953
00:37:00,320 --> 00:37:02,640
over the elephants instruction

954
00:37:02,640 --> 00:37:04,880
and because of this reason this is what

955
00:37:04,880 --> 00:37:07,760
we used in our gr security product all

956
00:37:07,760 --> 00:37:08,880
right

957
00:37:08,880 --> 00:37:10,720
thank you very much

958
00:37:10,720 --> 00:37:12,079
for listening to me if you are

959
00:37:12,079 --> 00:37:14,560
interested in more details about

960
00:37:14,560 --> 00:37:17,440
this topic feel free to read the two

961
00:37:17,440 --> 00:37:20,160
blog posts i i wrote about this and in

962
00:37:20,160 --> 00:37:22,480
case of any questions feel free to shoot

963
00:37:22,480 --> 00:37:24,880
me an email thanks thank you very much

964
00:37:24,880 --> 00:37:27,040
pavel for the presentation

965
00:37:27,040 --> 00:37:29,440
um are there any questions if you have

966
00:37:29,440 --> 00:37:31,599
any questions please share them in the

967
00:37:31,599 --> 00:37:33,359
chat box and

968
00:37:33,359 --> 00:37:34,560
pavel will

969
00:37:34,560 --> 00:37:36,560
answer them shortly and the question is

970
00:37:36,560 --> 00:37:39,040
the gadget must be in the 16 bytes fetch

971
00:37:39,040 --> 00:37:40,560
block

972
00:37:40,560 --> 00:37:42,640
that's correct yes

973
00:37:42,640 --> 00:37:45,200
that's correct and ideally it has to be

974
00:37:45,200 --> 00:37:47,280
within this sub

975
00:37:47,280 --> 00:37:50,240
part of the sls executed instructions

976
00:37:50,240 --> 00:37:51,440
all right

977
00:37:51,440 --> 00:37:52,960
thank you thank you for answering the

978
00:37:52,960 --> 00:37:53,920
question

979
00:37:53,920 --> 00:37:56,079
thank you pavel again for

980
00:37:56,079 --> 00:37:58,079
doing this presentation for us thank you

981
00:37:58,079 --> 00:38:01,720
very much bye-bye

