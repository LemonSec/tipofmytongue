1
00:00:12,480 --> 00:00:13,840
[Music]

2
00:00:13,840 --> 00:00:15,440
welcome everyone and thank you for

3
00:00:15,440 --> 00:00:17,760
joining us this afternoon i'm andrea and

4
00:00:17,760 --> 00:00:20,080
i will be your host for today's session

5
00:00:20,080 --> 00:00:22,160
i'm glad to welcome today gregor who is

6
00:00:22,160 --> 00:00:24,160
currently an embedded software engineer

7
00:00:24,160 --> 00:00:27,760
at ksc kcf technologies where he works

8
00:00:27,760 --> 00:00:29,760
on secure boot and embedded platform

9
00:00:29,760 --> 00:00:32,238
security during his master's degree he

10
00:00:32,238 --> 00:00:34,239
researched porting a variety of common

11
00:00:34,239 --> 00:00:36,480
side channel attacks to iphone hardware

12
00:00:36,480 --> 00:00:38,559
and in today's presentation gregol will

13
00:00:38,559 --> 00:00:41,200
present his work apple versus ema

14
00:00:41,200 --> 00:00:43,120
electromagnetic side channel attacks on

15
00:00:43,120 --> 00:00:45,680
apple core crypto now i would like to

16
00:00:45,680 --> 00:00:48,559
invite you to start your presentation

17
00:00:48,559 --> 00:00:50,640
sounds good thank you andrea

18
00:00:50,640 --> 00:00:53,840
let me share my screen

19
00:00:56,719 --> 00:00:58,480
and okay

20
00:00:58,480 --> 00:01:00,559
so thank you everybody for joining this

21
00:01:00,559 --> 00:01:02,719
is as you can see from the title apple

22
00:01:02,719 --> 00:01:04,879
versus ema electromagnetic side channel

23
00:01:04,879 --> 00:01:07,040
attacks and apple core crypto

24
00:01:07,040 --> 00:01:08,400
i'll get started with a little bit of an

25
00:01:08,400 --> 00:01:09,680
introduction about myself although

26
00:01:09,680 --> 00:01:11,520
andrea already gave one

27
00:01:11,520 --> 00:01:13,200
i'm a recent graduate of nc state

28
00:01:13,200 --> 00:01:14,960
university and

29
00:01:14,960 --> 00:01:16,799
as part of my master's thesis there i

30
00:01:16,799 --> 00:01:18,479
essentially worked on porting a variety

31
00:01:18,479 --> 00:01:20,960
of common side channel attacks to run on

32
00:01:20,960 --> 00:01:22,799
iphones which is not a very common

33
00:01:22,799 --> 00:01:24,960
target for these side channel attacks

34
00:01:24,960 --> 00:01:26,400
as part of this work i published two

35
00:01:26,400 --> 00:01:28,720
papers one called i timed which was

36
00:01:28,720 --> 00:01:31,600
about digital cash attacks on an apple

37
00:01:31,600 --> 00:01:33,520
chip and then i also published very

38
00:01:33,520 --> 00:01:35,600
recently apple versus ema which is the

39
00:01:35,600 --> 00:01:37,520
subject of this talk both of these

40
00:01:37,520 --> 00:01:39,920
papers were co-authored with iodine isu

41
00:01:39,920 --> 00:01:41,280
assistant professor of electrical

42
00:01:41,280 --> 00:01:42,640
engineering at north carolina state

43
00:01:42,640 --> 00:01:44,159
university

44
00:01:44,159 --> 00:01:45,759
as part of this work i've done a decent

45
00:01:45,759 --> 00:01:47,119
amount of hardware security research as

46
00:01:47,119 --> 00:01:49,840
well as open source work we released a

47
00:01:49,840 --> 00:01:51,439
open source research toolkit for

48
00:01:51,439 --> 00:01:53,360
hardware security research on iphones

49
00:01:53,360 --> 00:01:55,200
i'll talk about a little bit

50
00:01:55,200 --> 00:01:57,600
of this in the presentation itself

51
00:01:57,600 --> 00:01:59,200
uh currently as andrea mentioned i'm

52
00:01:59,200 --> 00:02:00,719
working as an embedded software engineer

53
00:02:00,719 --> 00:02:02,560
at kcf technologies where i work on

54
00:02:02,560 --> 00:02:05,600
secure boots and firmware security

55
00:02:05,600 --> 00:02:07,360
this is a brief outline of kind of the

56
00:02:07,360 --> 00:02:08,959
broad topics i'll be covering in this

57
00:02:08,959 --> 00:02:10,080
talk i'll kind of start with some

58
00:02:10,080 --> 00:02:12,640
background information about aes typical

59
00:02:12,640 --> 00:02:14,319
side channel attacks on this crypto

60
00:02:14,319 --> 00:02:15,840
system as well as a couple of the

61
00:02:15,840 --> 00:02:18,000
statistical techniques that are common

62
00:02:18,000 --> 00:02:19,440
after that i'll go into the work that we

63
00:02:19,440 --> 00:02:21,120
have to do for the attack infrastructure

64
00:02:21,120 --> 00:02:23,120
including what we had to do to

65
00:02:23,120 --> 00:02:24,959
physically change the iphone to make it

66
00:02:24,959 --> 00:02:26,560
attackable as well as kind of the

67
00:02:26,560 --> 00:02:28,640
experiment flow the data pre-processing

68
00:02:28,640 --> 00:02:31,200
pipeline all these things

69
00:02:31,200 --> 00:02:32,959
then i'll go into attack development

70
00:02:32,959 --> 00:02:34,160
which is how we actually use the

71
00:02:34,160 --> 00:02:36,720
primitives that we built earlier to find

72
00:02:36,720 --> 00:02:38,400
vulnerable points in apple cipher

73
00:02:38,400 --> 00:02:40,239
implementation and talk about a few of

74
00:02:40,239 --> 00:02:42,000
the techniques as well

75
00:02:42,000 --> 00:02:44,080
finally i'll talk about the results uh

76
00:02:44,080 --> 00:02:46,080
analyze how well this attack performs

77
00:02:46,080 --> 00:02:47,680
and point out some conclusions and then

78
00:02:47,680 --> 00:02:50,400
we'll have the q a at the end so let's

79
00:02:50,400 --> 00:02:51,360
get started with the background

80
00:02:51,360 --> 00:02:52,879
information kind of the motivation for

81
00:02:52,879 --> 00:02:54,080
attacking

82
00:02:54,080 --> 00:02:55,840
apple's crypto libraries in the first

83
00:02:55,840 --> 00:02:57,200
place and some of the algorithms and

84
00:02:57,200 --> 00:02:59,599
techniques we'll use to do so

85
00:02:59,599 --> 00:03:00,800
as

86
00:03:00,800 --> 00:03:02,560
this is a hardware security conference

87
00:03:02,560 --> 00:03:03,599
i'm sure most of you guys are very

88
00:03:03,599 --> 00:03:05,680
familiar with aes it's one of the most

89
00:03:05,680 --> 00:03:07,840
popular symmetric crypto systems that's

90
00:03:07,840 --> 00:03:09,360
in use today in a variety of

91
00:03:09,360 --> 00:03:10,800
applications

92
00:03:10,800 --> 00:03:13,440
and aes is essentially

93
00:03:13,440 --> 00:03:16,480
built on these two inputs in this output

94
00:03:16,480 --> 00:03:19,280
so for 128 bits or 16 byte plain text

95
00:03:19,280 --> 00:03:21,200
and a key of the same size

96
00:03:21,200 --> 00:03:23,840
what aes does is it entangles these two

97
00:03:23,840 --> 00:03:26,000
into a cipher text and this has some

98
00:03:26,000 --> 00:03:28,159
important security properties mainly if

99
00:03:28,159 --> 00:03:29,680
you have the cipher text but don't know

100
00:03:29,680 --> 00:03:31,680
the key you can't decrypt back to the

101
00:03:31,680 --> 00:03:33,599
plain text and even if you have both the

102
00:03:33,599 --> 00:03:35,440
plain text and the cipher text you still

103
00:03:35,440 --> 00:03:36,799
don't learn any information about the

104
00:03:36,799 --> 00:03:38,000
key

105
00:03:38,000 --> 00:03:39,840
this is a mathematically very secure

106
00:03:39,840 --> 00:03:41,680
algorithm over

107
00:03:41,680 --> 00:03:43,360
30 or 40 years of research have gone

108
00:03:43,360 --> 00:03:44,560
into breaking it and we haven't made

109
00:03:44,560 --> 00:03:47,599
much progress but the issue with crypto

110
00:03:47,599 --> 00:03:49,760
systems generally is that

111
00:03:49,760 --> 00:03:51,680
to take these from a mathematical model

112
00:03:51,680 --> 00:03:53,840
to a real implementation you eventually

113
00:03:53,840 --> 00:03:55,760
have to run them on real hardware and

114
00:03:55,760 --> 00:03:57,519
that means that sometimes this crypto

115
00:03:57,519 --> 00:03:59,439
system inherits security properties from

116
00:03:59,439 --> 00:04:00,480
that hardware

117
00:04:00,480 --> 00:04:02,159
so to that extent i've kind of broken

118
00:04:02,159 --> 00:04:05,439
out the internals of aes in this diagram

119
00:04:05,439 --> 00:04:06,799
to explain this a little bit better you

120
00:04:06,799 --> 00:04:08,879
can see that there's four operations add

121
00:04:08,879 --> 00:04:10,879
round keys sub bytes shift rows and mix

122
00:04:10,879 --> 00:04:12,239
columns

123
00:04:12,239 --> 00:04:14,480
and we essentially do these over and

124
00:04:14,480 --> 00:04:16,238
over again in rounds until we get to the

125
00:04:16,238 --> 00:04:18,320
last round we replace mixed columns with

126
00:04:18,320 --> 00:04:19,839
another add round key

127
00:04:19,839 --> 00:04:21,759
there's also key expansion phase where

128
00:04:21,759 --> 00:04:23,840
the key is transformed into round keys

129
00:04:23,840 --> 00:04:27,280
but this isn't relevant to this research

130
00:04:27,280 --> 00:04:29,440
so if we want to attack aes and actually

131
00:04:29,440 --> 00:04:30,639
try to figure out the value of the

132
00:04:30,639 --> 00:04:31,840
secret key in a way that the

133
00:04:31,840 --> 00:04:33,759
mathematical model says we shouldn't be

134
00:04:33,759 --> 00:04:36,160
able to how do we do this

135
00:04:36,160 --> 00:04:37,840
the most common vector to actually

136
00:04:37,840 --> 00:04:39,759
correlate out the secret key

137
00:04:39,759 --> 00:04:42,639
for software aes implementations is

138
00:04:42,639 --> 00:04:44,160
through cache attacks

139
00:04:44,160 --> 00:04:45,520
and the way that this works is that the

140
00:04:45,520 --> 00:04:47,600
sub bytes operation here is typically

141
00:04:47,600 --> 00:04:49,440
implemented as a lookup table

142
00:04:49,440 --> 00:04:51,280
essentially you take the output of add

143
00:04:51,280 --> 00:04:53,600
round key use it into an as an index

144
00:04:53,600 --> 00:04:56,080
into this table and then take the output

145
00:04:56,080 --> 00:04:57,360
of that and that becomes the new

146
00:04:57,360 --> 00:04:59,440
cryptographic state

147
00:04:59,440 --> 00:05:00,400
um

148
00:05:00,400 --> 00:05:02,320
these tables though the sub bytes and

149
00:05:02,320 --> 00:05:04,720
sometimes these larger t tables which

150
00:05:04,720 --> 00:05:06,639
are sometimes used instead

151
00:05:06,639 --> 00:05:09,120
are accessed at secret dependent indices

152
00:05:09,120 --> 00:05:10,880
so you see we actually combine the key

153
00:05:10,880 --> 00:05:13,840
and the plain text and then this is used

154
00:05:13,840 --> 00:05:16,479
to index into this lookup table so if

155
00:05:16,479 --> 00:05:18,720
you can do certain clever things with

156
00:05:18,720 --> 00:05:21,520
the cpus cache you can actually measure

157
00:05:21,520 --> 00:05:23,919
what index we indexed into in this

158
00:05:23,919 --> 00:05:25,680
lookup table and then learn some

159
00:05:25,680 --> 00:05:27,600
information about the secret key if you

160
00:05:27,600 --> 00:05:29,360
know the plain text

161
00:05:29,360 --> 00:05:30,560
there's a variety of techniques for

162
00:05:30,560 --> 00:05:32,560
these i won't cover them in detail but

163
00:05:32,560 --> 00:05:34,320
you can see for example prime plus probe

164
00:05:34,320 --> 00:05:36,479
flush plus reload there's a whole host

165
00:05:36,479 --> 00:05:39,120
of these cache side channel attacks

166
00:05:39,120 --> 00:05:40,560
so the way that this is typically

167
00:05:40,560 --> 00:05:43,520
mitigated at the cpu level nowadays

168
00:05:43,520 --> 00:05:45,280
is that we actually implement these

169
00:05:45,280 --> 00:05:48,160
ciphers fully in hardware right if you

170
00:05:48,160 --> 00:05:49,840
don't have this lookup table sitting in

171
00:05:49,840 --> 00:05:50,880
memory

172
00:05:50,880 --> 00:05:51,840
then

173
00:05:51,840 --> 00:05:53,680
you can't do a cache attack on it if you

174
00:05:53,680 --> 00:05:55,120
have circuitry that implements it

175
00:05:55,120 --> 00:05:57,120
instead it never touches the memory and

176
00:05:57,120 --> 00:05:59,280
then those attacks don't work

177
00:05:59,280 --> 00:06:00,160
and

178
00:06:00,160 --> 00:06:02,960
for a while now both x86 and arm have

179
00:06:02,960 --> 00:06:04,319
instruction set extensions that

180
00:06:04,319 --> 00:06:05,840
implement aes without these kind of

181
00:06:05,840 --> 00:06:09,199
auxiliary memory accesses intel has aes9

182
00:06:09,199 --> 00:06:10,800
arm has arm ce

183
00:06:10,800 --> 00:06:12,319
and these implementations are typically

184
00:06:12,319 --> 00:06:14,319
regarded as pretty resistant to these

185
00:06:14,319 --> 00:06:17,120
digital cache attacks but at some level

186
00:06:17,120 --> 00:06:19,039
right these are still physical circuits

187
00:06:19,039 --> 00:06:20,560
inside of the cpu

188
00:06:20,560 --> 00:06:22,560
so the question that i was interested in

189
00:06:22,560 --> 00:06:24,160
and a lot of other people are as well is

190
00:06:24,160 --> 00:06:25,520
are they actually resistant to more

191
00:06:25,520 --> 00:06:26,800
analog

192
00:06:26,800 --> 00:06:29,919
physical attacks on the hardware itself

193
00:06:29,919 --> 00:06:31,440
in our literature review that we did for

194
00:06:31,440 --> 00:06:33,440
this paper we did find you know that

195
00:06:33,440 --> 00:06:35,440
asni has been shown as vulnerable to

196
00:06:35,440 --> 00:06:37,680
power analysis and some intel chips but

197
00:06:37,680 --> 00:06:40,240
we haven't found any attacks on arm ce

198
00:06:40,240 --> 00:06:41,680
um

199
00:06:41,680 --> 00:06:43,440
and hasn't previously been shown to have

200
00:06:43,440 --> 00:06:44,880
physical vulnerabilities so we were

201
00:06:44,880 --> 00:06:46,639
interested in this

202
00:06:46,639 --> 00:06:49,599
so if you want to attack hardware right

203
00:06:49,599 --> 00:06:51,120
we have to define what that actually

204
00:06:51,120 --> 00:06:52,720
means and

205
00:06:52,720 --> 00:06:54,240
sort of the statistical techniques that

206
00:06:54,240 --> 00:06:56,560
we do use to do so

207
00:06:56,560 --> 00:06:58,080
uh the most common technique for this is

208
00:06:58,080 --> 00:07:00,479
called correlation power analysis and

209
00:07:00,479 --> 00:07:02,720
this is a technique for determining

210
00:07:02,720 --> 00:07:03,759
secret

211
00:07:03,759 --> 00:07:06,319
intermediate to the cipher information

212
00:07:06,319 --> 00:07:08,479
from physical side channel traces which

213
00:07:08,479 --> 00:07:10,240
is often power consumption or em

214
00:07:10,240 --> 00:07:12,319
radiation but it can also be weird

215
00:07:12,319 --> 00:07:14,240
exotic things like vibration or

216
00:07:14,240 --> 00:07:15,680
temperature

217
00:07:15,680 --> 00:07:17,360
all of these are valid vectors for side

218
00:07:17,360 --> 00:07:18,800
channels

219
00:07:18,800 --> 00:07:21,520
to do a cpa attack you need two core

220
00:07:21,520 --> 00:07:23,599
pieces of information the first thing

221
00:07:23,599 --> 00:07:25,759
that you need is actually a side channel

222
00:07:25,759 --> 00:07:27,840
trace right a physical measurement of

223
00:07:27,840 --> 00:07:29,520
what you're trying to attack

224
00:07:29,520 --> 00:07:31,280
this is actually a trace from our tech

225
00:07:31,280 --> 00:07:32,479
this shows

226
00:07:32,479 --> 00:07:34,240
an implementation of aes running in

227
00:07:34,240 --> 00:07:36,400
hardware over time

228
00:07:36,400 --> 00:07:38,160
and for a cpa attack you need to gather

229
00:07:38,160 --> 00:07:40,160
a lot of these i'll talk about this more

230
00:07:40,160 --> 00:07:42,400
in detail later but we needed about 5 to

231
00:07:42,400 --> 00:07:44,400
30 million of these to run a successful

232
00:07:44,400 --> 00:07:45,360
attack

233
00:07:45,360 --> 00:07:47,520
what's also very important is that for

234
00:07:47,520 --> 00:07:49,440
each encryption trace

235
00:07:49,440 --> 00:07:52,720
you actually also capture

236
00:07:52,720 --> 00:07:54,960
the data that's being operated on so the

237
00:07:54,960 --> 00:07:56,479
specific plain text that's being

238
00:07:56,479 --> 00:07:59,599
encrypted the cipher text that

239
00:07:59,599 --> 00:08:01,520
you know is the result of that

240
00:08:01,520 --> 00:08:03,360
encryption process

241
00:08:03,360 --> 00:08:05,039
and you actually use this associated

242
00:08:05,039 --> 00:08:08,560
data to define a so-called leakage model

243
00:08:08,560 --> 00:08:10,080
uh these are also often called power

244
00:08:10,080 --> 00:08:13,039
models um but this word wasn't super

245
00:08:13,039 --> 00:08:14,479
applicable to us because ours is

246
00:08:14,479 --> 00:08:16,879
actually an em attack not power

247
00:08:16,879 --> 00:08:18,080
but essentially what these leakage

248
00:08:18,080 --> 00:08:19,840
models do

249
00:08:19,840 --> 00:08:22,240
is they return a guess of what the

250
00:08:22,240 --> 00:08:24,800
physical activity inside the circuits

251
00:08:24,800 --> 00:08:27,599
might be for some given internal state

252
00:08:27,599 --> 00:08:29,440
derived inter entirely in terms of the

253
00:08:29,440 --> 00:08:32,080
plain text or ciphertext and then also

254
00:08:32,080 --> 00:08:34,000
some key guesses

255
00:08:34,000 --> 00:08:36,159
um i'll give some more concrete details

256
00:08:36,159 --> 00:08:38,080
of how this works later in the talk so

257
00:08:38,080 --> 00:08:39,440
no worries if this doesn't make too much

258
00:08:39,440 --> 00:08:41,039
sense this one

259
00:08:41,039 --> 00:08:43,200
with these physical side channel traces

260
00:08:43,200 --> 00:08:44,800
and the leakage models you can then

261
00:08:44,800 --> 00:08:46,480
essentially cross correlate them

262
00:08:46,480 --> 00:08:48,480
together so this here is the equation

263
00:08:48,480 --> 00:08:50,160
for pearson's correlation coefficient

264
00:08:50,160 --> 00:08:51,920
which is the most typical measure used

265
00:08:51,920 --> 00:08:53,200
for this

266
00:08:53,200 --> 00:08:54,320
and what we essentially do is we

267
00:08:54,320 --> 00:08:56,320
calculate the covariance

268
00:08:56,320 --> 00:08:59,200
between the leakage model and each index

269
00:08:59,200 --> 00:09:01,040
of the sample trace i'll give a more

270
00:09:01,040 --> 00:09:02,880
concrete example of this

271
00:09:02,880 --> 00:09:04,399
but then dividing by the standard

272
00:09:04,399 --> 00:09:05,920
deviation of both this essentially

273
00:09:05,920 --> 00:09:08,160
normalizes the correlation coefficient

274
00:09:08,160 --> 00:09:10,640
into the range from negative one to one

275
00:09:10,640 --> 00:09:11,680
so

276
00:09:11,680 --> 00:09:13,680
it's a more normalized way to kind of

277
00:09:13,680 --> 00:09:15,920
look at correlation

278
00:09:15,920 --> 00:09:17,440
let's give a concrete example of what

279
00:09:17,440 --> 00:09:19,040
this actually typically looks like let's

280
00:09:19,040 --> 00:09:21,279
say we just have one trace

281
00:09:21,279 --> 00:09:23,519
one side channel trace with n samples in

282
00:09:23,519 --> 00:09:25,920
it and let's say we also defined four

283
00:09:25,920 --> 00:09:28,640
leakage models right which return

284
00:09:28,640 --> 00:09:30,560
different guesses of what the internal

285
00:09:30,560 --> 00:09:33,040
state might be if the key has a certain

286
00:09:33,040 --> 00:09:36,160
value if we have just one trace we can't

287
00:09:36,160 --> 00:09:38,160
calculate cpa yet right because these

288
00:09:38,160 --> 00:09:40,240
standard deviation terms will be zero

289
00:09:40,240 --> 00:09:42,240
and it's not valid but let's say we keep

290
00:09:42,240 --> 00:09:44,080
collecting more and more of these traces

291
00:09:44,080 --> 00:09:45,519
and updating this correlation

292
00:09:45,519 --> 00:09:46,800
coefficient

293
00:09:46,800 --> 00:09:48,880
you can see that eventually we get some

294
00:09:48,880 --> 00:09:51,040
low correlation values

295
00:09:51,040 --> 00:09:52,720
for these specific leakage models and

296
00:09:52,720 --> 00:09:54,800
the sample indices and these don't tell

297
00:09:54,800 --> 00:09:56,480
us much yet right these are all very

298
00:09:56,480 --> 00:09:58,000
close to each other

299
00:09:58,000 --> 00:09:58,959
they

300
00:09:58,959 --> 00:10:01,360
don't give us much valuable information

301
00:10:01,360 --> 00:10:02,399
but if we

302
00:10:02,399 --> 00:10:04,800
capture even more side channel traces

303
00:10:04,800 --> 00:10:06,560
correlation values will essentially keep

304
00:10:06,560 --> 00:10:08,320
going down and down

305
00:10:08,320 --> 00:10:10,000
but at some point we'll actually see

306
00:10:10,000 --> 00:10:11,519
some correlation values which have

307
00:10:11,519 --> 00:10:14,079
higher magnitudes than any other ones by

308
00:10:14,079 --> 00:10:17,200
no means high correlation but higher you

309
00:10:17,200 --> 00:10:18,720
can see for example here for leakage

310
00:10:18,720 --> 00:10:21,760
model 2 at these sample indices

311
00:10:21,760 --> 00:10:23,839
these correlations are about an order of

312
00:10:23,839 --> 00:10:25,920
magnitude higher than all of the other

313
00:10:25,920 --> 00:10:28,720
ones and what this tells us

314
00:10:28,720 --> 00:10:30,720
is that there's a good chance that the

315
00:10:30,720 --> 00:10:33,279
internal state which is guessed by this

316
00:10:33,279 --> 00:10:34,959
leakage model

317
00:10:34,959 --> 00:10:37,200
is actually observed in the real data

318
00:10:37,200 --> 00:10:38,720
and that it's specifically happening at

319
00:10:38,720 --> 00:10:41,040
this point in the time domain

320
00:10:41,040 --> 00:10:42,959
and so we can use cpa attacks like this

321
00:10:42,959 --> 00:10:45,200
to identify both what the internal state

322
00:10:45,200 --> 00:10:47,519
of some cipher might be and also where

323
00:10:47,519 --> 00:10:50,399
in the time domain this happens

324
00:10:50,399 --> 00:10:51,760
so now that i've kind of gone over some

325
00:10:51,760 --> 00:10:54,160
of the preliminaries we can talk about

326
00:10:54,160 --> 00:10:56,240
how we actually apply these to attacking

327
00:10:56,240 --> 00:10:57,519
iphones

328
00:10:57,519 --> 00:10:59,519
which is not a trivial problem in and of

329
00:10:59,519 --> 00:11:00,880
itself

330
00:11:00,880 --> 00:11:01,839
um

331
00:11:01,839 --> 00:11:03,440
as part of this research we wanted to

332
00:11:03,440 --> 00:11:05,440
attack arm ce but we actually decided

333
00:11:05,440 --> 00:11:06,959
specifically to attack apple's

334
00:11:06,959 --> 00:11:08,399
implementation of this and there's a

335
00:11:08,399 --> 00:11:10,320
couple reasons for this

336
00:11:10,320 --> 00:11:11,120
um

337
00:11:11,120 --> 00:11:12,640
first being that pretty much all modern

338
00:11:12,640 --> 00:11:14,640
apple chips are custom arm cores right

339
00:11:14,640 --> 00:11:16,079
there's a huge market share out there

340
00:11:16,079 --> 00:11:18,880
that's actually these apple design cpus

341
00:11:18,880 --> 00:11:20,480
and yet

342
00:11:20,480 --> 00:11:22,640
not much hardware security research has

343
00:11:22,640 --> 00:11:24,800
been done on these apple socs and this

344
00:11:24,800 --> 00:11:26,399
is changing you know as platforms are

345
00:11:26,399 --> 00:11:29,040
becoming more and more accessible but

346
00:11:29,040 --> 00:11:31,120
even further than that very few actually

347
00:11:31,120 --> 00:11:32,800
focus on apple's implementations of

348
00:11:32,800 --> 00:11:34,480
symmetric ciphers

349
00:11:34,480 --> 00:11:36,320
and we thought this would be a good

350
00:11:36,320 --> 00:11:37,839
thing to look at you know

351
00:11:37,839 --> 00:11:41,120
trust their implementation but verify

352
00:11:41,120 --> 00:11:42,480
another reason for this is that we

353
00:11:42,480 --> 00:11:43,920
actually already had a pretty good set

354
00:11:43,920 --> 00:11:46,640
of capabilities for attacking iphone 7

355
00:11:46,640 --> 00:11:48,880
which kind of stemmed out of our earlier

356
00:11:48,880 --> 00:11:50,079
time

357
00:11:50,079 --> 00:11:52,560
so here on the side you can see

358
00:11:52,560 --> 00:11:55,279
a close view of our acquisition setup we

359
00:11:55,279 --> 00:11:57,040
of course have an electromagnetic probe

360
00:11:57,040 --> 00:11:58,240
which was

361
00:11:58,240 --> 00:11:59,839
um

362
00:11:59,839 --> 00:12:01,760
manufactured by riskier very good

363
00:12:01,760 --> 00:12:03,680
equipment

364
00:12:03,680 --> 00:12:05,760
and then we have our victim iphone which

365
00:12:05,760 --> 00:12:07,279
has been kind of disassembled here in

366
00:12:07,279 --> 00:12:09,440
this figure you can see that in

367
00:12:09,440 --> 00:12:11,760
highlighted in orange here we actually

368
00:12:11,760 --> 00:12:14,399
expose the actual the soc on the logic

369
00:12:14,399 --> 00:12:16,240
board itself so that we can probe very

370
00:12:16,240 --> 00:12:18,240
closely to what's happening here

371
00:12:18,240 --> 00:12:20,639
we also attach these needle probes to

372
00:12:20,639 --> 00:12:23,519
various points on the logic board itself

373
00:12:23,519 --> 00:12:25,760
uh for re reasons which i'll talk about

374
00:12:25,760 --> 00:12:27,519
in a second

375
00:12:27,519 --> 00:12:29,519
this is a little bit of a higher level

376
00:12:29,519 --> 00:12:31,519
view of our experimental infrastructure

377
00:12:31,519 --> 00:12:33,440
we have of course the em probe which is

378
00:12:33,440 --> 00:12:34,880
connected to the oscilloscope to

379
00:12:34,880 --> 00:12:37,040
actually measure em information but then

380
00:12:37,040 --> 00:12:39,200
we've also connected these needle probes

381
00:12:39,200 --> 00:12:41,519
into the oscilloscope's triggering input

382
00:12:41,519 --> 00:12:43,279
and what this lets us do

383
00:12:43,279 --> 00:12:45,920
is if we can write to one of these test

384
00:12:45,920 --> 00:12:46,959
pads

385
00:12:46,959 --> 00:12:48,959
on the iphone logic board with software

386
00:12:48,959 --> 00:12:50,959
and set a signal high then we can

387
00:12:50,959 --> 00:12:54,000
actually isolate in the time domain

388
00:12:54,000 --> 00:12:56,399
where the encryption might be happening

389
00:12:56,399 --> 00:12:57,920
um and it turns out some of these test

390
00:12:57,920 --> 00:13:00,320
pads are externally routed gpio pins and

391
00:13:00,320 --> 00:13:02,880
we were very directly able to

392
00:13:02,880 --> 00:13:04,839
set this gpio pin high trigger and

393
00:13:04,839 --> 00:13:07,360
acquisition and then find the correct

394
00:13:07,360 --> 00:13:08,959
spot in the time domain where encryption

395
00:13:08,959 --> 00:13:10,800
is occurring

396
00:13:10,800 --> 00:13:12,399
we also have

397
00:13:12,399 --> 00:13:14,399
a power adapter connected to a power

398
00:13:14,399 --> 00:13:15,600
supply here because some of these

399
00:13:15,600 --> 00:13:17,519
experiments took a while and we didn't

400
00:13:17,519 --> 00:13:19,440
want the iphone's battery to die halfway

401
00:13:19,440 --> 00:13:21,279
through for example we also have an

402
00:13:21,279 --> 00:13:22,959
experiment controller over here which is

403
00:13:22,959 --> 00:13:24,320
a raspberry pi

404
00:13:24,320 --> 00:13:25,839
and this kind of coordinates all of this

405
00:13:25,839 --> 00:13:27,360
equipment and make sure things happen in

406
00:13:27,360 --> 00:13:29,279
the correct order

407
00:13:29,279 --> 00:13:30,079
so

408
00:13:30,079 --> 00:13:32,160
our first attempt at an experiment flow

409
00:13:32,160 --> 00:13:34,240
looked roughly like this essentially we

410
00:13:34,240 --> 00:13:35,920
use our previously created itimed

411
00:13:35,920 --> 00:13:39,040
toolkit and exploit the iphone and boots

412
00:13:39,040 --> 00:13:41,519
to a full linux kernel due to some very

413
00:13:41,519 --> 00:13:43,360
nice contributions from

414
00:13:43,360 --> 00:13:45,199
i believe corellium there's a fully

415
00:13:45,199 --> 00:13:48,320
functioning linux kernel for iphone socs

416
00:13:48,320 --> 00:13:50,079
we then took apple's implementation of

417
00:13:50,079 --> 00:13:52,320
arm ce from the core crypto library

418
00:13:52,320 --> 00:13:53,279
which

419
00:13:53,279 --> 00:13:54,800
they release under a license for

420
00:13:54,800 --> 00:13:56,959
security research purposes

421
00:13:56,959 --> 00:13:59,040
and implement this

422
00:13:59,040 --> 00:14:01,040
uh implementation

423
00:14:01,040 --> 00:14:03,920
into linux's crypto api verbatim without

424
00:14:03,920 --> 00:14:06,079
making any code changes

425
00:14:06,079 --> 00:14:08,240
we then connected the needle probes as i

426
00:14:08,240 --> 00:14:10,399
talked about previously and loaded the

427
00:14:10,399 --> 00:14:12,480
iphone with our experimental program and

428
00:14:12,480 --> 00:14:14,160
this experimental program

429
00:14:14,160 --> 00:14:15,839
essentially listens in a loop for

430
00:14:15,839 --> 00:14:18,720
incoming plain texts raises the gpio pin

431
00:14:18,720 --> 00:14:20,560
when it receives one

432
00:14:20,560 --> 00:14:22,639
encrypts whatever the plaintext was and

433
00:14:22,639 --> 00:14:24,320
then sends the corresponding ciphertext

434
00:14:24,320 --> 00:14:26,240
back to the experiment controller in

435
00:14:26,240 --> 00:14:28,079
this way we can

436
00:14:28,079 --> 00:14:30,079
acquire traces and side channel

437
00:14:30,079 --> 00:14:31,680
information

438
00:14:31,680 --> 00:14:34,079
for specified plain texts

439
00:14:34,079 --> 00:14:36,079
in a coordinated way and then at the end

440
00:14:36,079 --> 00:14:38,000
we save of course these electromagnetic

441
00:14:38,000 --> 00:14:39,519
traces along with the plain text and the

442
00:14:39,519 --> 00:14:42,480
ciphertext for offline analysis

443
00:14:42,480 --> 00:14:44,480
now this works but it has the major

444
00:14:44,480 --> 00:14:46,880
disadvantage that this is extremely slow

445
00:14:46,880 --> 00:14:48,320
of a setup

446
00:14:48,320 --> 00:14:49,600
and essentially there's a lot of

447
00:14:49,600 --> 00:14:51,839
overheads to encrypt any single one

448
00:14:51,839 --> 00:14:54,079
plain text to only get one single trace

449
00:14:54,079 --> 00:14:56,079
out like this right

450
00:14:56,079 --> 00:14:58,480
so what we did is we actually modified

451
00:14:58,480 --> 00:15:00,480
this somewhat instead of listening to

452
00:15:00,480 --> 00:15:02,240
incoming plain texts

453
00:15:02,240 --> 00:15:04,480
we actually send random seeds to the

454
00:15:04,480 --> 00:15:05,519
iphone

455
00:15:05,519 --> 00:15:08,079
we then derive plain texts from this

456
00:15:08,079 --> 00:15:10,480
random seed and very rapidly and

457
00:15:10,480 --> 00:15:12,800
sequentially encrypt these in a row and

458
00:15:12,800 --> 00:15:14,720
we only trigger the oscilloscope once we

459
00:15:14,720 --> 00:15:16,480
collect much longer traces from the

460
00:15:16,480 --> 00:15:18,399
oscilloscope like this

461
00:15:18,399 --> 00:15:20,079
on the host side or on the experiment

462
00:15:20,079 --> 00:15:21,440
controller side we can then use this

463
00:15:21,440 --> 00:15:23,120
random seed to derive the same plain

464
00:15:23,120 --> 00:15:25,279
texts we listen to the ciphertext that

465
00:15:25,279 --> 00:15:27,199
the device is sending back and then we

466
00:15:27,199 --> 00:15:29,279
have a long trace with much less

467
00:15:29,279 --> 00:15:31,199
overhead per encryption

468
00:15:31,199 --> 00:15:33,040
with the same associated plaintext

469
00:15:33,040 --> 00:15:35,199
ciphertext data

470
00:15:35,199 --> 00:15:37,279
these traces look about like this this

471
00:15:37,279 --> 00:15:38,160
is

472
00:15:38,160 --> 00:15:39,120
kind of

473
00:15:39,120 --> 00:15:41,519
high level i'll zoom into this in a bit

474
00:15:41,519 --> 00:15:42,639
but the key idea here is that our

475
00:15:42,639 --> 00:15:44,480
oscilloscope had enough sample memory to

476
00:15:44,480 --> 00:15:47,519
capture approximately 26 000 encryptions

477
00:15:47,519 --> 00:15:49,920
in one trace which made our acquisition

478
00:15:49,920 --> 00:15:52,399
set up about 16 000 times faster than it

479
00:15:52,399 --> 00:15:55,519
was before if we zoom in here

480
00:15:55,519 --> 00:15:57,040
though a problem

481
00:15:57,040 --> 00:15:59,199
quickly becomes clear sometimes there's

482
00:15:59,199 --> 00:16:00,880
high noise regions which kind of

483
00:16:00,880 --> 00:16:03,199
interrupts the encryption process right

484
00:16:03,199 --> 00:16:05,040
any encryptions that might happen in

485
00:16:05,040 --> 00:16:07,120
this noisy region

486
00:16:07,120 --> 00:16:10,000
probably aren't too useful for our cpa

487
00:16:10,000 --> 00:16:11,839
attack that we want to define so we need

488
00:16:11,839 --> 00:16:13,440
to do some kind of pre-processing to

489
00:16:13,440 --> 00:16:14,959
pick out the correct traces that'll

490
00:16:14,959 --> 00:16:17,199
actually be useful for us

491
00:16:17,199 --> 00:16:19,519
if we zoom in even further here

492
00:16:19,519 --> 00:16:21,600
you can see

493
00:16:21,600 --> 00:16:23,600
individual encryptions each of these

494
00:16:23,600 --> 00:16:26,240
spikes is one encryption on 128-bit

495
00:16:26,240 --> 00:16:27,120
block

496
00:16:27,120 --> 00:16:29,360
and the key

497
00:16:29,360 --> 00:16:30,880
problem here

498
00:16:30,880 --> 00:16:32,959
is that we actually need to take each of

499
00:16:32,959 --> 00:16:35,600
these individual encryptions and spikes

500
00:16:35,600 --> 00:16:38,399
and figure out exactly which c derived

501
00:16:38,399 --> 00:16:40,399
plain text was the input to this

502
00:16:40,399 --> 00:16:42,800
encryption because remember cpa is very

503
00:16:42,800 --> 00:16:44,720
sensitive to having this

504
00:16:44,720 --> 00:16:48,320
trace and associated data combination

505
00:16:48,320 --> 00:16:50,079
and if we don't have this or if it's

506
00:16:50,079 --> 00:16:51,839
wrong it actually negatively affects the

507
00:16:51,839 --> 00:16:54,240
cpa attack by introducing noise and

508
00:16:54,240 --> 00:16:57,199
potentially leading to a failed attack

509
00:16:57,199 --> 00:16:59,440
so what we came up with is an approach

510
00:16:59,440 --> 00:17:01,759
to kind of split these we call them

511
00:17:01,759 --> 00:17:04,559
subtraces out of the bigger trace

512
00:17:04,559 --> 00:17:05,439
and

513
00:17:05,439 --> 00:17:07,039
we originally tried to use pattern

514
00:17:07,039 --> 00:17:08,880
matching for this right

515
00:17:08,880 --> 00:17:11,119
if you look at these spikes they all

516
00:17:11,119 --> 00:17:12,480
have kind of a predictable pattern and

517
00:17:12,480 --> 00:17:14,480
we can use pattern matching to try to

518
00:17:14,480 --> 00:17:16,480
say at these points in the time domain

519
00:17:16,480 --> 00:17:18,400
is when encryptions happen

520
00:17:18,400 --> 00:17:20,160
but if there's noise this doesn't work

521
00:17:20,160 --> 00:17:21,599
right then we don't have good pattern

522
00:17:21,599 --> 00:17:23,760
matches anymore in all these regions for

523
00:17:23,760 --> 00:17:26,079
example we don't see this and even if we

524
00:17:26,079 --> 00:17:27,839
don't know

525
00:17:27,839 --> 00:17:29,280
uh where

526
00:17:29,280 --> 00:17:31,120
these noisy traces are in the time

527
00:17:31,120 --> 00:17:33,039
domain we still need to know how many of

528
00:17:33,039 --> 00:17:34,640
them we missed so we can find the

529
00:17:34,640 --> 00:17:35,919
correct

530
00:17:35,919 --> 00:17:38,720
plain text after the noisy region that

531
00:17:38,720 --> 00:17:41,440
the cryptosystem is operating on

532
00:17:41,440 --> 00:17:43,360
so what we did is we also used timing

533
00:17:43,360 --> 00:17:44,640
measurements at the start of each

534
00:17:44,640 --> 00:17:47,039
encryption block our experimental

535
00:17:47,039 --> 00:17:49,200
program saves the timestamp of when the

536
00:17:49,200 --> 00:17:51,120
encryption occurs we can actually use

537
00:17:51,120 --> 00:17:53,679
this then count how many plaintexts we

538
00:17:53,679 --> 00:17:56,080
miss in these high noise regions

539
00:17:56,080 --> 00:17:58,160
so in this graph over here you can see

540
00:17:58,160 --> 00:18:00,799
traces in red where we have the timing

541
00:18:00,799 --> 00:18:02,559
measurement only where the pattern match

542
00:18:02,559 --> 00:18:04,799
fails due to noise and in the green

543
00:18:04,799 --> 00:18:06,960
traces these are actually traces where

544
00:18:06,960 --> 00:18:08,720
we have the timing measurement as well

545
00:18:08,720 --> 00:18:10,960
as a reliable pattern match you can see

546
00:18:10,960 --> 00:18:12,799
in the high noise regions we only have

547
00:18:12,799 --> 00:18:14,240
the timing measurements to tell us how

548
00:18:14,240 --> 00:18:16,160
many we missed you can see even some

549
00:18:16,160 --> 00:18:18,080
regions like right here where there's no

550
00:18:18,080 --> 00:18:19,679
encryptions happening at all so some

551
00:18:19,679 --> 00:18:21,280
kind of interrupt happened here to

552
00:18:21,280 --> 00:18:24,160
interrupt our experimental program

553
00:18:24,160 --> 00:18:26,240
so now that we have these primitives we

554
00:18:26,240 --> 00:18:28,320
have the ability to quickly gather long

555
00:18:28,320 --> 00:18:30,320
traces and split them apart into useful

556
00:18:30,320 --> 00:18:32,400
traces for a cpa attack

557
00:18:32,400 --> 00:18:34,720
we need to figure out enough about the

558
00:18:34,720 --> 00:18:37,360
implementation to actually attack it

559
00:18:37,360 --> 00:18:39,039
and to do so we first started with a

560
00:18:39,039 --> 00:18:41,280
known key analysis

561
00:18:41,280 --> 00:18:43,280
what enunci analysis essentially lets us

562
00:18:43,280 --> 00:18:45,600
do is it lets us reverse engineer the

563
00:18:45,600 --> 00:18:47,360
underlying hardware

564
00:18:47,360 --> 00:18:49,039
uh through the idea of kind of making

565
00:18:49,039 --> 00:18:50,640
some guesses of how things might be

566
00:18:50,640 --> 00:18:52,160
implemented

567
00:18:52,160 --> 00:18:53,679
and you know

568
00:18:53,679 --> 00:18:55,120
from an implementation perspective we

569
00:18:55,120 --> 00:18:56,480
don't know much about what the

570
00:18:56,480 --> 00:18:58,000
underlying hardware is doing we know

571
00:18:58,000 --> 00:19:00,160
it's aes we know it uses these

572
00:19:00,160 --> 00:19:01,440
instructions and we know those

573
00:19:01,440 --> 00:19:02,480
instructions

574
00:19:02,480 --> 00:19:04,640
execute in the floating point pipeline

575
00:19:04,640 --> 00:19:05,840
but now we need to find these good

576
00:19:05,840 --> 00:19:07,520
leakage models that will actually let us

577
00:19:07,520 --> 00:19:10,240
correlate out secret information

578
00:19:10,240 --> 00:19:12,320
if we pretend that we know the secret

579
00:19:12,320 --> 00:19:13,520
key

580
00:19:13,520 --> 00:19:16,000
at an algorithm level we can derive each

581
00:19:16,000 --> 00:19:18,799
intermediate state of each operation

582
00:19:18,799 --> 00:19:20,480
we can then define leakage models that

583
00:19:20,480 --> 00:19:23,039
correlate with those em traces and tell

584
00:19:23,039 --> 00:19:25,600
us is this intermediate state of the

585
00:19:25,600 --> 00:19:27,520
cipher even visible in the data because

586
00:19:27,520 --> 00:19:28,880
if not then we shouldn't even try to

587
00:19:28,880 --> 00:19:30,880
attack this i'll give a concrete example

588
00:19:30,880 --> 00:19:33,039
of how this works on the next slide

589
00:19:33,039 --> 00:19:35,200
but the key idea is that any leakage

590
00:19:35,200 --> 00:19:37,120
model that stands out in this known key

591
00:19:37,120 --> 00:19:39,280
attack could also work for an unknown

592
00:19:39,280 --> 00:19:40,720
key attack where we try to correlate

593
00:19:40,720 --> 00:19:42,080
that out

594
00:19:42,080 --> 00:19:44,240
so here's kind of an overview of how

595
00:19:44,240 --> 00:19:46,240
this known key analysis works we derive

596
00:19:46,240 --> 00:19:49,200
these known key leakage models

597
00:19:49,200 --> 00:19:51,919
and correlate with them at this point we

598
00:19:51,919 --> 00:19:53,760
assume we know all of this intermediate

599
00:19:53,760 --> 00:19:55,600
information and we can directly

600
00:19:55,600 --> 00:19:58,160
calculate all of its intermediate state

601
00:19:58,160 --> 00:20:00,640
we start with just the leakage model for

602
00:20:00,640 --> 00:20:02,480
the plane tech strength

603
00:20:02,480 --> 00:20:04,320
uh given any plaintext byte we can

604
00:20:04,320 --> 00:20:06,080
calculate its hamming weight which is

605
00:20:06,080 --> 00:20:08,240
the number of bits that are set

606
00:20:08,240 --> 00:20:10,480
and then correlate this with the trace

607
00:20:10,480 --> 00:20:12,320
in a straightforward way we can then

608
00:20:12,320 --> 00:20:14,559
proceed since we know the key we can add

609
00:20:14,559 --> 00:20:15,280
it

610
00:20:15,280 --> 00:20:17,360
and then get the output of the add round

611
00:20:17,360 --> 00:20:19,760
key operation we can then substitute the

612
00:20:19,760 --> 00:20:22,559
bytes shift the rows kind of proceed

613
00:20:22,559 --> 00:20:25,600
step by step algorithmically through

614
00:20:25,600 --> 00:20:27,679
this crypto system and we know each

615
00:20:27,679 --> 00:20:29,280
intermediate states we can correlate

616
00:20:29,280 --> 00:20:30,640
with it

617
00:20:30,640 --> 00:20:32,799
eventually we finish round zero do some

618
00:20:32,799 --> 00:20:34,880
more rounds and get to round eight

619
00:20:34,880 --> 00:20:37,360
we proceed through the last steps here

620
00:20:37,360 --> 00:20:38,960
and then we take the branch to the last

621
00:20:38,960 --> 00:20:41,679
add round key instead and now we can

622
00:20:41,679 --> 00:20:44,159
also look at the cipher text in total we

623
00:20:44,159 --> 00:20:47,520
have 656 of these known q leakage models

624
00:20:47,520 --> 00:20:50,400
uh 16 byte positions

625
00:20:50,400 --> 00:20:52,960
uh and then four operations per round

626
00:20:52,960 --> 00:20:54,640
times 10 rounds and you also include the

627
00:20:54,640 --> 00:20:56,080
plain text state

628
00:20:56,080 --> 00:20:58,640
so we have 656 power models that were

629
00:20:58,640 --> 00:21:00,559
correlating with each trace and we're

630
00:21:00,559 --> 00:21:02,880
trying to see which internal state is

631
00:21:02,880 --> 00:21:04,960
visible in the data

632
00:21:04,960 --> 00:21:07,120
when we look at our results here we have

633
00:21:07,120 --> 00:21:09,600
some correlation plots that show

634
00:21:09,600 --> 00:21:11,520
time on the x-axis and the absolute

635
00:21:11,520 --> 00:21:14,080
correlation magnitude on the y-axis

636
00:21:14,080 --> 00:21:15,600
and you can see that for many of these

637
00:21:15,600 --> 00:21:18,640
operations there's actually no

638
00:21:18,640 --> 00:21:20,799
activity or correlation visible even if

639
00:21:20,799 --> 00:21:22,480
we know the secret key even if we know

640
00:21:22,480 --> 00:21:24,799
exactly what the intermediate state is

641
00:21:24,799 --> 00:21:27,039
but a big exception to this is actually

642
00:21:27,039 --> 00:21:28,720
the output of the mixed columns

643
00:21:28,720 --> 00:21:29,760
operation

644
00:21:29,760 --> 00:21:31,600
for the output of this operation we see

645
00:21:31,600 --> 00:21:34,000
strong correlation plots at each of the

646
00:21:34,000 --> 00:21:35,840
rounds and we actually see that the

647
00:21:35,840 --> 00:21:38,880
peaks of these correlations advance

648
00:21:38,880 --> 00:21:40,880
further in time domain as the round

649
00:21:40,880 --> 00:21:43,200
increases so we can see

650
00:21:43,200 --> 00:21:45,280
the output of any mixed columns in the

651
00:21:45,280 --> 00:21:47,039
cipher

652
00:21:47,039 --> 00:21:48,880
this is obviously a good hook

653
00:21:48,880 --> 00:21:50,960
potentially into an attack right

654
00:21:50,960 --> 00:21:53,440
and we can somehow calculate the output

655
00:21:53,440 --> 00:21:55,919
of a mixed columns operation from only

656
00:21:55,919 --> 00:21:58,159
the plain text or ciphertext and some

657
00:21:58,159 --> 00:21:59,360
key guesses

658
00:21:59,360 --> 00:22:01,440
then we might be able

659
00:22:01,440 --> 00:22:03,600
to find support for certain key guesses

660
00:22:03,600 --> 00:22:05,039
and figure out which might be correct

661
00:22:05,039 --> 00:22:06,640
and which might not be

662
00:22:06,640 --> 00:22:08,480
and that's exactly what we do so next we

663
00:22:08,480 --> 00:22:10,080
have to define these specific leakage

664
00:22:10,080 --> 00:22:11,760
models we know the output of mixed

665
00:22:11,760 --> 00:22:13,679
columns is leaky so how can we get to

666
00:22:13,679 --> 00:22:15,600
the output of mixed columns from only

667
00:22:15,600 --> 00:22:18,000
the plain text or the ciphertext

668
00:22:18,000 --> 00:22:20,080
the first option that we have available

669
00:22:20,080 --> 00:22:22,080
is attacking the first rounds mixed

670
00:22:22,080 --> 00:22:23,840
columns

671
00:22:23,840 --> 00:22:26,080
if we go back to our known key attack

672
00:22:26,080 --> 00:22:28,320
this happens right here

673
00:22:28,320 --> 00:22:29,120
and

674
00:22:29,120 --> 00:22:31,280
the core issue with this

675
00:22:31,280 --> 00:22:32,000
is

676
00:22:32,000 --> 00:22:34,640
that in order to guess the output of one

677
00:22:34,640 --> 00:22:35,679
byte

678
00:22:35,679 --> 00:22:38,080
of this intermediate first round mixed

679
00:22:38,080 --> 00:22:39,440
column state

680
00:22:39,440 --> 00:22:42,000
we actually need to make guesses at four

681
00:22:42,000 --> 00:22:43,600
bytes of the key because these are

682
00:22:43,600 --> 00:22:45,280
combined in the specific way with the

683
00:22:45,280 --> 00:22:46,799
plain text

684
00:22:46,799 --> 00:22:48,880
which means that in order to fully

685
00:22:48,880 --> 00:22:50,880
explore all of the potential leakage

686
00:22:50,880 --> 00:22:53,600
models you need to define two to the 32

687
00:22:53,600 --> 00:22:54,720
of them

688
00:22:54,720 --> 00:22:57,520
which is a large number and this is most

689
00:22:57,520 --> 00:22:59,520
likely a computationally infeasible

690
00:22:59,520 --> 00:23:00,720
approach

691
00:23:00,720 --> 00:23:02,320
because in order to guess any single

692
00:23:02,320 --> 00:23:04,400
internal byte and correlate to it we

693
00:23:04,400 --> 00:23:07,679
need to actually guess 4 bytes of key

694
00:23:07,679 --> 00:23:09,600
the second option that we have

695
00:23:09,600 --> 00:23:11,520
is to actually look at the last rounds

696
00:23:11,520 --> 00:23:14,000
mixed columns operation right if i go

697
00:23:14,000 --> 00:23:16,480
back to the nokia analysis we see this

698
00:23:16,480 --> 00:23:17,840
right here

699
00:23:17,840 --> 00:23:20,640
and the key idea here is in order to get

700
00:23:20,640 --> 00:23:23,039
back to this we only need to invert this

701
00:23:23,039 --> 00:23:25,280
add round key shift rows sub bytes and

702
00:23:25,280 --> 00:23:27,039
another add round key and then we're

703
00:23:27,039 --> 00:23:29,120
back to the output of our mixed columns

704
00:23:29,120 --> 00:23:30,799
we don't actually need to pass through a

705
00:23:30,799 --> 00:23:32,720
mixed columns

706
00:23:32,720 --> 00:23:33,760
and

707
00:23:33,760 --> 00:23:35,520
what this actually turns out is that for

708
00:23:35,520 --> 00:23:36,480
this

709
00:23:36,480 --> 00:23:38,240
power model we only need to guess two

710
00:23:38,240 --> 00:23:40,559
bytes for the key rather than four which

711
00:23:40,559 --> 00:23:43,039
is two to the sixteen power models this

712
00:23:43,039 --> 00:23:44,799
is much more than two times speed up

713
00:23:44,799 --> 00:23:47,520
this is a square root speed up even

714
00:23:47,520 --> 00:23:49,919
this is a much more efficient attack if

715
00:23:49,919 --> 00:23:51,440
we actually try to

716
00:23:51,440 --> 00:23:53,919
correlate out the last mixed columns

717
00:23:53,919 --> 00:23:55,360
and this means that our final power

718
00:23:55,360 --> 00:23:56,799
model looks like this we essentially

719
00:23:56,799 --> 00:23:58,799
guess two bytes of key

720
00:23:58,799 --> 00:24:01,840
we invert it into a specific

721
00:24:01,840 --> 00:24:04,000
internal states that we suspect might be

722
00:24:04,000 --> 00:24:06,240
due to that key and we need to do so for

723
00:24:06,240 --> 00:24:08,320
each possible combination of these

724
00:24:08,320 --> 00:24:09,840
values

725
00:24:09,840 --> 00:24:12,640
so now that we have these results or

726
00:24:12,640 --> 00:24:13,520
these

727
00:24:13,520 --> 00:24:15,039
leakage models how does our attack

728
00:24:15,039 --> 00:24:16,640
actually perform

729
00:24:16,640 --> 00:24:18,240
our type process looks approximately

730
00:24:18,240 --> 00:24:20,240
like this we acquire a large amount of

731
00:24:20,240 --> 00:24:23,279
side channel subtraces using the sort of

732
00:24:23,279 --> 00:24:25,360
denoising post-processing approach that

733
00:24:25,360 --> 00:24:26,799
i described earlier

734
00:24:26,799 --> 00:24:28,880
and then for each of these traces we use

735
00:24:28,880 --> 00:24:32,240
the associated data and all 65 000 key

736
00:24:32,240 --> 00:24:34,640
guesses to calculate the values of the

737
00:24:34,640 --> 00:24:37,120
leakage models for that trace

738
00:24:37,120 --> 00:24:38,960
we then cross correlate those leakage

739
00:24:38,960 --> 00:24:40,799
model values of each sample index of

740
00:24:40,799 --> 00:24:42,880
data which is

741
00:24:42,880 --> 00:24:44,640
computationally expensive to say the

742
00:24:44,640 --> 00:24:45,520
least

743
00:24:45,520 --> 00:24:47,279
and we update our running pearson

744
00:24:47,279 --> 00:24:49,360
correlation values and then what we can

745
00:24:49,360 --> 00:24:51,679
also do is optionally every n traces

746
00:24:51,679 --> 00:24:53,760
that we aggregate this way we can save

747
00:24:53,760 --> 00:24:55,440
this intermediate correlation state and

748
00:24:55,440 --> 00:24:57,200
this kind of helps for the visualization

749
00:24:57,200 --> 00:24:59,679
purposes

750
00:24:59,679 --> 00:25:01,919
once we've aggregated a high enough

751
00:25:01,919 --> 00:25:04,320
number of traces calculated correlation

752
00:25:04,320 --> 00:25:05,279
to

753
00:25:05,279 --> 00:25:06,080
a

754
00:25:06,080 --> 00:25:07,520
high enough degree

755
00:25:07,520 --> 00:25:08,640
what we can do

756
00:25:08,640 --> 00:25:11,120
is we can take the trace

757
00:25:11,120 --> 00:25:12,960
we can take the correlation values for

758
00:25:12,960 --> 00:25:14,640
each leakage model across the time

759
00:25:14,640 --> 00:25:16,880
domain and find the maximum value in

760
00:25:16,880 --> 00:25:19,200
that time domain and then actually sort

761
00:25:19,200 --> 00:25:21,279
by that right and the

762
00:25:21,279 --> 00:25:22,880
thinking here being

763
00:25:22,880 --> 00:25:24,240
if a leakage model has a high

764
00:25:24,240 --> 00:25:27,279
correlation value this might be evidence

765
00:25:27,279 --> 00:25:30,080
that those key guesses associated to

766
00:25:30,080 --> 00:25:32,000
that model are correct

767
00:25:32,000 --> 00:25:33,840
and then that we actually see leakage at

768
00:25:33,840 --> 00:25:35,360
that point in time

769
00:25:35,360 --> 00:25:37,440
if we then also know the key we can take

770
00:25:37,440 --> 00:25:39,440
the log of the correct guesses sorted

771
00:25:39,440 --> 00:25:42,080
index as about a measurement of how hard

772
00:25:42,080 --> 00:25:44,320
it would be to break that byte position

773
00:25:44,320 --> 00:25:45,760
i'll give an example of this in a bit

774
00:25:45,760 --> 00:25:47,520
here too

775
00:25:47,520 --> 00:25:48,880
so here's some of the results actually

776
00:25:48,880 --> 00:25:50,640
that we see these plots

777
00:25:50,640 --> 00:25:51,760
first

778
00:25:51,760 --> 00:25:54,400
show correlation magnitude versus the

779
00:25:54,400 --> 00:25:57,440
time domain uh blue lines are the

780
00:25:57,440 --> 00:25:58,960
correct key guess

781
00:25:58,960 --> 00:26:00,400
red lines are the inverse guess which

782
00:26:00,400 --> 00:26:01,760
i'll talk about in a second and all of

783
00:26:01,760 --> 00:26:03,440
the gray lines are the raw leakage

784
00:26:03,440 --> 00:26:05,760
models and you can see after aggregating

785
00:26:05,760 --> 00:26:07,120
enough traces

786
00:26:07,120 --> 00:26:09,440
it's actually very clear the correct

787
00:26:09,440 --> 00:26:12,240
model stands out from any of the other

788
00:26:12,240 --> 00:26:13,120
ones

789
00:26:13,120 --> 00:26:14,320
if we instead look at how this

790
00:26:14,320 --> 00:26:16,640
correlation coefficient evolves as the

791
00:26:16,640 --> 00:26:18,000
number of sub traces that we've

792
00:26:18,000 --> 00:26:19,760
aggregated increases

793
00:26:19,760 --> 00:26:22,159
you can see that starting at about 10

794
00:26:22,159 --> 00:26:24,000
million traces for this bike position

795
00:26:24,000 --> 00:26:24,799
even

796
00:26:24,799 --> 00:26:27,200
the correct model is very clearly

797
00:26:27,200 --> 00:26:28,960
discernible from all of the incorrect

798
00:26:28,960 --> 00:26:30,400
models

799
00:26:30,400 --> 00:26:32,480
so this is actually our attack working

800
00:26:32,480 --> 00:26:34,880
this is our attack pulling out the key

801
00:26:34,880 --> 00:26:37,520
from this electromagnetic radiation

802
00:26:37,520 --> 00:26:39,600
just through correlation with our

803
00:26:39,600 --> 00:26:41,360
leakage models and attacking the output

804
00:26:41,360 --> 00:26:43,760
of the mixed columns operation

805
00:26:43,760 --> 00:26:46,000
about this inverse guess we found that

806
00:26:46,000 --> 00:26:46,720
this

807
00:26:46,720 --> 00:26:48,080
actually has a similarly high

808
00:26:48,080 --> 00:26:50,240
correlation magnitude it also stands out

809
00:26:50,240 --> 00:26:52,159
from any of the other traces and this

810
00:26:52,159 --> 00:26:53,840
actually corresponds to the specific

811
00:26:53,840 --> 00:26:56,400
model where the last key guess is

812
00:26:56,400 --> 00:26:58,400
correct but the second to last key yes

813
00:26:58,400 --> 00:27:01,520
is the bitwise knot of the correct one

814
00:27:01,520 --> 00:27:02,559
so

815
00:27:02,559 --> 00:27:04,559
it's actually very tightly related to

816
00:27:04,559 --> 00:27:07,200
what the correct guess is

817
00:27:07,200 --> 00:27:08,960
if we now take

818
00:27:08,960 --> 00:27:10,960
these results and break it down per byte

819
00:27:10,960 --> 00:27:13,919
position and actually what try to see

820
00:27:13,919 --> 00:27:16,240
how easy this it is for us to break a

821
00:27:16,240 --> 00:27:18,720
certain bite of the key you can see that

822
00:27:18,720 --> 00:27:21,279
on average it takes between five to 30

823
00:27:21,279 --> 00:27:23,120
million traces only to actually

824
00:27:23,120 --> 00:27:24,960
correlate out what the secret key at

825
00:27:24,960 --> 00:27:26,880
that position is

826
00:27:26,880 --> 00:27:28,080
um

827
00:27:28,080 --> 00:27:29,679
these plots show the number of

828
00:27:29,679 --> 00:27:31,760
sub-traces that we've aggregated

829
00:27:31,760 --> 00:27:32,799
versus

830
00:27:32,799 --> 00:27:35,279
this security level measurement that i

831
00:27:35,279 --> 00:27:36,880
talked about earlier we would take the

832
00:27:36,880 --> 00:27:37,760
log

833
00:27:37,760 --> 00:27:40,399
of this correct guesses

834
00:27:40,399 --> 00:27:42,240
sort of index

835
00:27:42,240 --> 00:27:44,159
and you can see this initially starts at

836
00:27:44,159 --> 00:27:46,159
about 16 which makes sense because we

837
00:27:46,159 --> 00:27:48,399
have to guess two bytes of key for every

838
00:27:48,399 --> 00:27:49,840
one byte

839
00:27:49,840 --> 00:27:51,600
to actually correlate with

840
00:27:51,600 --> 00:27:53,520
but quickly this actually goes

841
00:27:53,520 --> 00:27:55,840
below eight bytes so it's just as good

842
00:27:55,840 --> 00:27:57,600
as a brute force on aes

843
00:27:57,600 --> 00:27:59,360
and then in pretty much every case

844
00:27:59,360 --> 00:28:00,640
actually

845
00:28:00,640 --> 00:28:03,120
the correct key model becomes the first

846
00:28:03,120 --> 00:28:04,880
one in the sorted list so it has the

847
00:28:04,880 --> 00:28:06,559
highest correlation magnitude so we can

848
00:28:06,559 --> 00:28:09,760
discern it from all of the other ones

849
00:28:09,760 --> 00:28:10,720
um

850
00:28:10,720 --> 00:28:12,080
at some of these byte positions you can

851
00:28:12,080 --> 00:28:13,600
even see the effects from the inverse

852
00:28:13,600 --> 00:28:15,279
guess which is a very similar absolute

853
00:28:15,279 --> 00:28:17,520
magnitude so it quickly flips back and

854
00:28:17,520 --> 00:28:19,200
forth between the correct guess and the

855
00:28:19,200 --> 00:28:21,200
inverse guess

856
00:28:21,200 --> 00:28:23,600
so in conclusion what we wanted to do

857
00:28:23,600 --> 00:28:26,559
was break arm ce and try to show that

858
00:28:26,559 --> 00:28:28,159
these implementations might still have

859
00:28:28,159 --> 00:28:29,840
physical vulnerabilities even if they're

860
00:28:29,840 --> 00:28:32,640
digitally secure we will use standard em

861
00:28:32,640 --> 00:28:33,760
acquisition

862
00:28:33,760 --> 00:28:35,760
from

863
00:28:35,760 --> 00:28:38,000
acquisition equipment from riskier an

864
00:28:38,000 --> 00:28:40,000
existing open source toolkit and some

865
00:28:40,000 --> 00:28:41,919
optimized analysis code and we were

866
00:28:41,919 --> 00:28:43,520
actually able to break apple's hardware

867
00:28:43,520 --> 00:28:46,320
implementation of aes

868
00:28:46,320 --> 00:28:49,039
with about 5 to 30 million subtraces

869
00:28:49,039 --> 00:28:50,880
per key position this is actually enough

870
00:28:50,880 --> 00:28:53,360
to correlate at the secret key

871
00:28:53,360 --> 00:28:56,000
and if we do some quick math

872
00:28:56,000 --> 00:28:58,080
this actually is not that high of a

873
00:28:58,080 --> 00:28:59,360
requirement

874
00:28:59,360 --> 00:29:01,279
with 128 bit blocks that means we must

875
00:29:01,279 --> 00:29:03,279
only observe encryption on about 80 to

876
00:29:03,279 --> 00:29:06,640
480 megabytes of data and at 62.5

877
00:29:06,640 --> 00:29:08,720
nanoseconds per encryption you could

878
00:29:08,720 --> 00:29:09,919
theoretically

879
00:29:09,919 --> 00:29:11,760
acquire all of the data that you need to

880
00:29:11,760 --> 00:29:14,000
break the aes key in less than two

881
00:29:14,000 --> 00:29:16,640
seconds with enough advanced acquisition

882
00:29:16,640 --> 00:29:18,960
equipment with enough sample memory

883
00:29:18,960 --> 00:29:20,399
and our argument in our paper is

884
00:29:20,399 --> 00:29:21,760
actually that these requirements fit

885
00:29:21,760 --> 00:29:24,080
realistic mobile application behaviors

886
00:29:24,080 --> 00:29:25,760
think maybe in terms of cloud backup

887
00:29:25,760 --> 00:29:28,240
solutions right these are

888
00:29:28,240 --> 00:29:30,000
files that are zipped together encrypted

889
00:29:30,000 --> 00:29:31,760
and then sent out over the network if

890
00:29:31,760 --> 00:29:33,360
the attacker controls the network they

891
00:29:33,360 --> 00:29:35,279
can observe the ciphertext and if they

892
00:29:35,279 --> 00:29:37,120
can also find some way to gather em

893
00:29:37,120 --> 00:29:38,880
traces from the encryption process of

894
00:29:38,880 --> 00:29:41,360
the backup then they can decrypt all of

895
00:29:41,360 --> 00:29:42,960
your files as they get sent out over the

896
00:29:42,960 --> 00:29:44,240
network

897
00:29:44,240 --> 00:29:46,000
this is also applicable to software

898
00:29:46,000 --> 00:29:47,760
updates decryption for reverse

899
00:29:47,760 --> 00:29:49,760
engineering purposes

900
00:29:49,760 --> 00:29:51,200
and others

901
00:29:51,200 --> 00:29:52,559
but kind of the main point that we

902
00:29:52,559 --> 00:29:54,720
wanted to make with this work is

903
00:29:54,720 --> 00:29:56,399
a lot of these side channel attacks are

904
00:29:56,399 --> 00:29:58,960
done in laboratory settings right

905
00:29:58,960 --> 00:30:00,960
and actually they're not always

906
00:30:00,960 --> 00:30:02,720
applicable to the real world either in

907
00:30:02,720 --> 00:30:04,640
terms of computational complexity or the

908
00:30:04,640 --> 00:30:07,039
amount of time needed to acquire traces

909
00:30:07,039 --> 00:30:08,240
so what we believe is that there's

910
00:30:08,240 --> 00:30:10,640
actually more work needed to determine

911
00:30:10,640 --> 00:30:12,960
what the real life threat is from these

912
00:30:12,960 --> 00:30:14,720
side channel attacks and that was the

913
00:30:14,720 --> 00:30:17,039
goal kind of with attacking an iphone

914
00:30:17,039 --> 00:30:18,960
very ubiquitous device a lot of people

915
00:30:18,960 --> 00:30:20,000
know it

916
00:30:20,000 --> 00:30:21,760
and the fact that we succeeded

917
00:30:21,760 --> 00:30:23,360
might

918
00:30:23,360 --> 00:30:25,039
might should show that we need to do

919
00:30:25,039 --> 00:30:27,200
some things different

920
00:30:27,200 --> 00:30:29,520
with that that's my talk and i'd be able

921
00:30:29,520 --> 00:30:31,279
to take any questions if anybody has

922
00:30:31,279 --> 00:30:33,360
them

923
00:30:33,840 --> 00:30:37,039
thank you very much for the presentation

924
00:30:37,039 --> 00:30:39,039
i would like to invite everyone to share

925
00:30:39,039 --> 00:30:40,960
your questions in the chat box if you

926
00:30:40,960 --> 00:30:42,399
have any

927
00:30:42,399 --> 00:30:45,200
and let's wait a little bit

928
00:30:45,200 --> 00:30:48,200
something

929
00:30:51,360 --> 00:30:54,399
there is a question already um did you

930
00:30:54,399 --> 00:30:56,320
try other leakage models except

931
00:30:56,320 --> 00:30:58,399
hemmingway

932
00:30:58,399 --> 00:31:00,000
uh

933
00:31:00,000 --> 00:31:01,919
we did not although we did kind of

934
00:31:01,919 --> 00:31:03,679
speculate on some ways that this might

935
00:31:03,679 --> 00:31:04,720
look

936
00:31:04,720 --> 00:31:07,039
uh the other common

937
00:31:07,039 --> 00:31:09,279
leakage model is hamming distance right

938
00:31:09,279 --> 00:31:11,360
which kind of

939
00:31:11,360 --> 00:31:12,799
measures the

940
00:31:12,799 --> 00:31:15,120
activity that might occur due to some

941
00:31:15,120 --> 00:31:18,480
states registers changing states and the

942
00:31:18,480 --> 00:31:20,720
main issue there was that these

943
00:31:20,720 --> 00:31:22,320
instructions actually executed the

944
00:31:22,320 --> 00:31:24,559
floating point pipeline so if we could

945
00:31:24,559 --> 00:31:26,080
calculate the hamming distance between

946
00:31:26,080 --> 00:31:28,399
one register state and another after

947
00:31:28,399 --> 00:31:30,000
executing one of these arm ce

948
00:31:30,000 --> 00:31:31,679
instructions then we could potentially

949
00:31:31,679 --> 00:31:33,360
break the key

950
00:31:33,360 --> 00:31:35,279
but this is an advanced processor it has

951
00:31:35,279 --> 00:31:38,320
out of order execution it has

952
00:31:38,320 --> 00:31:40,000
you know a bunch of physical registers

953
00:31:40,000 --> 00:31:41,760
backing the logical registers so we

954
00:31:41,760 --> 00:31:43,600
actually had no way to ensure that the

955
00:31:43,600 --> 00:31:46,240
output of some rmce instruction would go

956
00:31:46,240 --> 00:31:48,080
back to the same physical register as

957
00:31:48,080 --> 00:31:49,279
before

958
00:31:49,279 --> 00:31:50,880
of course we can then spray register

959
00:31:50,880 --> 00:31:53,039
values into the physical registers and

960
00:31:53,039 --> 00:31:55,200
try to correlate that way but

961
00:31:55,200 --> 00:31:56,799
it seemed a little bit more complicated

962
00:31:56,799 --> 00:31:58,799
to try to do this than the hamming

963
00:31:58,799 --> 00:32:00,159
weight-based attack that we ended up

964
00:32:00,159 --> 00:32:02,399
doing

965
00:32:03,440 --> 00:32:05,279
thank you for answering this question in

966
00:32:05,279 --> 00:32:07,760
the meanwhile some people said thank you

967
00:32:07,760 --> 00:32:09,760
and that is a great presentation but we

968
00:32:09,760 --> 00:32:12,559
also got two other questions

969
00:32:12,559 --> 00:32:14,640
one is would you expect other arm

970
00:32:14,640 --> 00:32:16,960
processors implementing rmc to be

971
00:32:16,960 --> 00:32:18,960
vulnerable as well in other words does

972
00:32:18,960 --> 00:32:21,679
the rmc on apple cores differ from other

973
00:32:21,679 --> 00:32:24,399
arm cores

974
00:32:25,279 --> 00:32:27,840
yeah that's a great question knowing

975
00:32:27,840 --> 00:32:29,279
apple and their sort of corporate

976
00:32:29,279 --> 00:32:31,200
philosophy i'm sure they did something

977
00:32:31,200 --> 00:32:32,960
weird for their specific rmce

978
00:32:32,960 --> 00:32:34,559
implementation

979
00:32:34,559 --> 00:32:37,120
and we can't really claim also that

980
00:32:37,120 --> 00:32:39,039
other rmc implementations would be

981
00:32:39,039 --> 00:32:40,159
vulnerable

982
00:32:40,159 --> 00:32:41,760
but kind of from an architectural

983
00:32:41,760 --> 00:32:42,960
standpoint right the way these

984
00:32:42,960 --> 00:32:44,640
instructions are implemented how this

985
00:32:44,640 --> 00:32:45,760
works

986
00:32:45,760 --> 00:32:48,320
it almost shows

987
00:32:48,320 --> 00:32:50,240
that there could be a vulnerability of

988
00:32:50,240 --> 00:32:51,840
course somebody needs to do a concrete

989
00:32:51,840 --> 00:32:53,279
attack

990
00:32:53,279 --> 00:32:55,279
although the

991
00:32:55,279 --> 00:32:56,880
i guess generic

992
00:32:56,880 --> 00:32:59,840
execution model and how instructions are

993
00:32:59,840 --> 00:33:02,159
executed in these processors

994
00:33:02,159 --> 00:33:03,679
would be similar so i would expect that

995
00:33:03,679 --> 00:33:06,559
there might be leakage but

996
00:33:06,559 --> 00:33:10,519
someone needs to double check

997
00:33:10,559 --> 00:33:12,080
thank you

998
00:33:12,080 --> 00:33:15,200
um another question is any ideas why the

999
00:33:15,200 --> 00:33:17,279
mixed columns instruction is more leaky

1000
00:33:17,279 --> 00:33:18,880
than the other one

1001
00:33:18,880 --> 00:33:21,360
i have some guesses if

1002
00:33:21,360 --> 00:33:25,000
you look specifically

1003
00:33:25,200 --> 00:33:27,840
where is it

1004
00:33:29,200 --> 00:33:31,360
what the mixed columns instruction

1005
00:33:31,360 --> 00:33:32,960
actually involves right it's a lot of

1006
00:33:32,960 --> 00:33:34,960
multiplications and then it's a lot of

1007
00:33:34,960 --> 00:33:36,080
additions

1008
00:33:36,080 --> 00:33:37,840
so i imagine in the background actually

1009
00:33:37,840 --> 00:33:38,960
this is a very

1010
00:33:38,960 --> 00:33:42,320
arithmetically intense operation

1011
00:33:42,320 --> 00:33:44,720
and the output of that

1012
00:33:44,720 --> 00:33:46,799
seems to leak in some way so i imagine

1013
00:33:46,799 --> 00:33:49,840
that mixed columns just

1014
00:33:49,840 --> 00:33:51,840
you know it's more than just a simple

1015
00:33:51,840 --> 00:33:53,760
exclusive or it's more than just a table

1016
00:33:53,760 --> 00:33:56,480
look up or just changing indices

1017
00:33:56,480 --> 00:33:58,000
it's actually a lot of

1018
00:33:58,000 --> 00:34:00,240
adding and multiplying so my guess is

1019
00:34:00,240 --> 00:34:01,840
the higher activity from that makes it

1020
00:34:01,840 --> 00:34:03,679
more visible for a side channel attack

1021
00:34:03,679 --> 00:34:06,919
and more exploitable

1022
00:34:10,079 --> 00:34:12,000
all right thank you

1023
00:34:12,000 --> 00:34:15,440
are there any more questions

1024
00:34:17,679 --> 00:34:18,399
i

1025
00:34:18,399 --> 00:34:21,839
don't see any

1026
00:34:23,130 --> 00:34:25,440
[Music]

1027
00:34:25,440 --> 00:34:29,040
oh we do we do have

1028
00:34:30,079 --> 00:34:32,159
how many samples are in a single

1029
00:34:32,159 --> 00:34:34,079
encryption trace at the frequency you

1030
00:34:34,079 --> 00:34:36,239
are recording the trace what sampling

1031
00:34:36,239 --> 00:34:39,199
frequency are you using for the traces

1032
00:34:39,199 --> 00:34:41,599
yeah great question so

1033
00:34:41,599 --> 00:34:43,679
in a trace that looks approximately like

1034
00:34:43,679 --> 00:34:45,359
this one of these subtraces this is

1035
00:34:45,359 --> 00:34:49,199
about 10 000 samples um

1036
00:34:49,199 --> 00:34:53,918
for these bigger traces uh like i showed

1037
00:34:53,918 --> 00:34:55,040
here

1038
00:34:55,040 --> 00:34:59,280
this is 32 million traces acquired at

1039
00:34:59,280 --> 00:35:01,440
a 10 gigahertz sampling rate with a one

1040
00:35:01,440 --> 00:35:05,440
gigahertz bandwidth on the oscilloscope

1041
00:35:11,200 --> 00:35:12,560
thank you

1042
00:35:12,560 --> 00:35:15,040
thank you

1043
00:35:15,200 --> 00:35:18,160
all right i think that we don't have any

1044
00:35:18,160 --> 00:35:20,800
other questions

1045
00:35:20,800 --> 00:35:22,320
i would like

1046
00:35:22,320 --> 00:35:24,800
oh there is another one

1047
00:35:24,800 --> 00:35:26,079
um

1048
00:35:26,079 --> 00:35:27,920
my understanding is that side channel

1049
00:35:27,920 --> 00:35:30,079
attack typically requires sophisticated

1050
00:35:30,079 --> 00:35:32,480
lab setup to execute can side channel

1051
00:35:32,480 --> 00:35:36,400
attack happen outside the lab

1052
00:35:36,400 --> 00:35:39,200
this specific one probably not as easily

1053
00:35:39,200 --> 00:35:40,880
no because it does require this close

1054
00:35:40,880 --> 00:35:43,280
physical access and

1055
00:35:43,280 --> 00:35:45,119
you know this kind of

1056
00:35:45,119 --> 00:35:47,280
bigger acquisition setup there are other

1057
00:35:47,280 --> 00:35:48,800
kinds of side channel attacks that are

1058
00:35:48,800 --> 00:35:51,520
much more easy to do outside of a lab

1059
00:35:51,520 --> 00:35:53,680
setting for example cache attacks right

1060
00:35:53,680 --> 00:35:55,680
that's software attacking software

1061
00:35:55,680 --> 00:35:57,359
across boundaries

1062
00:35:57,359 --> 00:35:59,040
or across privileged boundaries which

1063
00:35:59,040 --> 00:36:00,880
means you don't necessarily have the

1064
00:36:00,880 --> 00:36:03,040
same lab requirements there's also a

1065
00:36:03,040 --> 00:36:04,560
couple of really fascinating attacks

1066
00:36:04,560 --> 00:36:05,839
that use

1067
00:36:05,839 --> 00:36:08,400
soc internal power monitoring

1068
00:36:08,400 --> 00:36:09,760
systems

1069
00:36:09,760 --> 00:36:11,839
uh to actually do remote physical

1070
00:36:11,839 --> 00:36:14,560
attacks so this paper that i

1071
00:36:14,560 --> 00:36:16,560
that i referred to which attacked aes

1072
00:36:16,560 --> 00:36:18,880
and i these actually use an intel power

1073
00:36:18,880 --> 00:36:20,960
monitoring interface which they can have

1074
00:36:20,960 --> 00:36:22,560
software monitor and they can run a

1075
00:36:22,560 --> 00:36:24,160
physical side channel attack through

1076
00:36:24,160 --> 00:36:25,520
that

1077
00:36:25,520 --> 00:36:28,560
so this attack probably

1078
00:36:28,560 --> 00:36:30,400
cannot succeed outside of a lab but

1079
00:36:30,400 --> 00:36:34,079
others definitely can and have

1080
00:36:37,839 --> 00:36:39,599
thank you

1081
00:36:39,599 --> 00:36:40,560
and

1082
00:36:40,560 --> 00:36:42,320
i think we got another question in the

1083
00:36:42,320 --> 00:36:45,040
meanwhile uh interesting topic made with

1084
00:36:45,040 --> 00:36:47,680
many questions in the correlation traces

1085
00:36:47,680 --> 00:36:49,520
correct and inverse the highlighted

1086
00:36:49,520 --> 00:36:51,920
region is it the time when encryption is

1087
00:36:51,920 --> 00:36:54,079
taking place hence the leak is seen or

1088
00:36:54,079 --> 00:36:56,160
is there any reason for only that time

1089
00:36:56,160 --> 00:36:58,800
region being the leaky temporal region

1090
00:36:58,800 --> 00:37:01,839
so this specific leaky region

1091
00:37:01,839 --> 00:37:04,320
in the time domain would correspond to

1092
00:37:04,320 --> 00:37:06,079
about when the last mixed columns

1093
00:37:06,079 --> 00:37:08,320
operation is happening

1094
00:37:08,320 --> 00:37:10,640
um

1095
00:37:10,720 --> 00:37:12,079
sorry wait let me look at the question

1096
00:37:12,079 --> 00:37:14,000
again

1097
00:37:14,000 --> 00:37:16,240
yes so this is the time when

1098
00:37:16,240 --> 00:37:18,240
the specific sub operation of the

1099
00:37:18,240 --> 00:37:20,800
encryption process is taking place and

1100
00:37:20,800 --> 00:37:22,720
as you can see in this known key plots

1101
00:37:22,720 --> 00:37:24,720
actually the specific time location can

1102
00:37:24,720 --> 00:37:26,640
vary as well depend depending on if

1103
00:37:26,640 --> 00:37:28,320
you're targeting the first mixed columns

1104
00:37:28,320 --> 00:37:29,920
or the last one

1105
00:37:29,920 --> 00:37:30,880
so

1106
00:37:30,880 --> 00:37:32,560
yes yeah the leakage model essentially

1107
00:37:32,560 --> 00:37:34,480
returns the time when the specified

1108
00:37:34,480 --> 00:37:37,839
operation is taking place

1109
00:37:40,320 --> 00:37:43,119
thank you very much

1110
00:37:44,240 --> 00:37:47,279
no more questions

1111
00:37:47,599 --> 00:37:49,680
people sharing saying good work and

1112
00:37:49,680 --> 00:37:51,040
thank you

1113
00:37:51,040 --> 00:37:53,599
i would also like to thank you uh for

1114
00:37:53,599 --> 00:37:55,359
coming and doing this presentation for

1115
00:37:55,359 --> 00:37:56,880
us

1116
00:37:56,880 --> 00:37:59,520
and uh i think that we can conclude with

1117
00:37:59,520 --> 00:38:02,079
this the webinar thank you once again

1118
00:38:02,079 --> 00:38:03,520
sounds good thank you for having me

1119
00:38:03,520 --> 00:38:04,400
andrea

1120
00:38:04,400 --> 00:38:08,920
have a nice day everyone bye bye

