1
00:00:12,480 --> 00:00:14,559
[Music]

2
00:00:14,559 --> 00:00:16,560
hey everyone thank you for joining us

3
00:00:16,560 --> 00:00:18,800
today wish you a very happy new year and

4
00:00:18,800 --> 00:00:21,199
i hope you all are safe and healthy

5
00:00:21,199 --> 00:00:23,119
i would like to also give a shout out to

6
00:00:23,119 --> 00:00:25,519
all our speakers from the conference and

7
00:00:25,519 --> 00:00:27,680
webinar and the trainers in the year

8
00:00:27,680 --> 00:00:30,640
2021 for sharing their knowledge and

9
00:00:30,640 --> 00:00:32,558
learning experience with all of us with

10
00:00:32,558 --> 00:00:34,800
the hardware entire community

11
00:00:34,800 --> 00:00:36,960
friends if you also would like to start

12
00:00:36,960 --> 00:00:39,440
meeting people in person and hardware

13
00:00:39,440 --> 00:00:41,040
specifically hardware security

14
00:00:41,040 --> 00:00:43,040
researchers we have announced our

15
00:00:43,040 --> 00:00:45,760
hardware usa conference in june in santa

16
00:00:45,760 --> 00:00:48,960
clara our cfp has just opened so if you

17
00:00:48,960 --> 00:00:50,399
would like to send in your research

18
00:00:50,399 --> 00:00:51,280
paper

19
00:00:51,280 --> 00:00:53,760
we would be more than happy to uh view

20
00:00:53,760 --> 00:00:55,680
it score them and let you know if your

21
00:00:55,680 --> 00:00:57,280
talk has been selected for the

22
00:00:57,280 --> 00:00:58,559
conference

23
00:00:58,559 --> 00:01:01,280
today i'm glad to invite michael who

24
00:01:01,280 --> 00:01:03,039
needs no introduction to the hardware

25
00:01:03,039 --> 00:01:06,240
security community he has been part of

26
00:01:06,240 --> 00:01:08,119
the popular and the most famous

27
00:01:08,119 --> 00:01:10,240
microarchitectural side channel attacks

28
00:01:10,240 --> 00:01:13,680
like meltdown spectre fallout and so on

29
00:01:13,680 --> 00:01:17,840
he is currently a faculty at sis sispa

30
00:01:17,840 --> 00:01:20,640
helm hot center for information security

31
00:01:20,640 --> 00:01:21,920
in germany

32
00:01:21,920 --> 00:01:23,840
today michael will share with us his

33
00:01:23,840 --> 00:01:26,320
results and research on automated

34
00:01:26,320 --> 00:01:28,799
discovery of micro architectural attack

35
00:01:28,799 --> 00:01:32,560
specters using cpu fuzzing he will also

36
00:01:32,560 --> 00:01:35,280
discuss the the uh

37
00:01:35,280 --> 00:01:37,280
discuss the development and case studies

38
00:01:37,280 --> 00:01:41,200
of oss and trister framework

39
00:01:41,200 --> 00:01:42,799
a little bit of a house loots for

40
00:01:42,799 --> 00:01:45,200
today's webinar the presentation will be

41
00:01:45,200 --> 00:01:47,439
for 30 minutes followed by 10 minutes

42
00:01:47,439 --> 00:01:48,880
for q a

43
00:01:48,880 --> 00:01:50,880
if any of you have any questions please

44
00:01:50,880 --> 00:01:53,360
send them across via the zoom chat i

45
00:01:53,360 --> 00:01:55,119
will read the questions out after

46
00:01:55,119 --> 00:01:57,119
presentation is complete

47
00:01:57,119 --> 00:01:59,200
also this session will be recorded and

48
00:01:59,200 --> 00:02:01,280
uploaded on our youtube channel for

49
00:02:01,280 --> 00:02:02,560
later view

50
00:02:02,560 --> 00:02:04,719
and friends uh it would be nice if you

51
00:02:04,719 --> 00:02:06,560
switch on your cameras as well to show

52
00:02:06,560 --> 00:02:08,239
us your smiley faces and let us know

53
00:02:08,239 --> 00:02:10,800
from where you have joined in

54
00:02:10,800 --> 00:02:13,360
so without any further delay michael i

55
00:02:13,360 --> 00:02:16,879
invite you to begin your presentation

56
00:02:16,879 --> 00:02:19,120
thanks a lot for this nice introduction

57
00:02:19,120 --> 00:02:20,000
here

58
00:02:20,000 --> 00:02:20,959
let me

59
00:02:20,959 --> 00:02:23,599
quickly share my screen

60
00:02:23,599 --> 00:02:25,520
yeah i think that works

61
00:02:25,520 --> 00:02:26,800
perfect all right

62
00:02:26,800 --> 00:02:29,200
yes as already said

63
00:02:29,200 --> 00:02:31,519
you already had the best introduction i

64
00:02:31,519 --> 00:02:34,720
could ask for and i didn't ask for that

65
00:02:34,720 --> 00:02:37,040
so my name is michael schwarz i'm a

66
00:02:37,040 --> 00:02:39,840
faculty currently at cispa helmet center

67
00:02:39,840 --> 00:02:42,400
and i'm working i'm i worked for quite

68
00:02:42,400 --> 00:02:44,319
some time and i'm still working

69
00:02:44,319 --> 00:02:47,120
on researching cpu security and side

70
00:02:47,120 --> 00:02:49,599
channels in cpus so you can always reach

71
00:02:49,599 --> 00:02:50,480
me

72
00:02:50,480 --> 00:02:52,160
my email address is here i'm also on

73
00:02:52,160 --> 00:02:54,560
twitter so if you have any questions i

74
00:02:54,560 --> 00:02:56,400
know i can't talk about all the things

75
00:02:56,400 --> 00:02:58,720
in these 30 minutes here feel free to

76
00:02:58,720 --> 00:03:00,239
write me and we can have a nice

77
00:03:00,239 --> 00:03:02,000
discussion

78
00:03:02,000 --> 00:03:05,440
so you might have seen things like uh

79
00:03:05,440 --> 00:03:07,599
new things like uh these like intel

80
00:03:07,599 --> 00:03:09,360
zombie load bug fixed to slow data

81
00:03:09,360 --> 00:03:12,319
center computers only new cpus can truly

82
00:03:12,319 --> 00:03:14,560
fix zombie load and spectre

83
00:03:14,560 --> 00:03:17,519
so these headlines that you had or even

84
00:03:17,519 --> 00:03:20,239
you might have seen it on tv where there

85
00:03:20,239 --> 00:03:23,200
was like a cnn back in 2018 computer

86
00:03:23,200 --> 00:03:26,319
chip flaws impact billions of devices

87
00:03:26,319 --> 00:03:28,080
developing story

88
00:03:28,080 --> 00:03:30,640
so what is this all about

89
00:03:30,640 --> 00:03:32,239
and all these things that we have seen

90
00:03:32,239 --> 00:03:33,200
there

91
00:03:33,200 --> 00:03:36,159
are talking about micro architectural

92
00:03:36,159 --> 00:03:38,000
side channels micro architectural

93
00:03:38,000 --> 00:03:40,959
attacks these are some really powerful

94
00:03:40,959 --> 00:03:43,840
and quite novel attack techniques

95
00:03:43,840 --> 00:03:45,920
and we have seen such microarchitectural

96
00:03:45,920 --> 00:03:47,920
attacks attacking cryptographic

97
00:03:47,920 --> 00:03:49,599
implementations so stealing

98
00:03:49,599 --> 00:03:51,360
cryptographic keys

99
00:03:51,360 --> 00:03:53,360
without using any vulnerabilities in the

100
00:03:53,360 --> 00:03:55,920
crypto libraries we have seen them use

101
00:03:55,920 --> 00:03:58,959
being used to spy on user behavior so

102
00:03:58,959 --> 00:04:01,040
seeing what the user is currently typing

103
00:04:01,040 --> 00:04:03,840
which websites the user is opening

104
00:04:03,840 --> 00:04:06,319
and we've also seen them as augmentation

105
00:04:06,319 --> 00:04:08,720
for traditional software exploits

106
00:04:08,720 --> 00:04:10,799
software exploits are still like the

107
00:04:10,799 --> 00:04:13,519
number one thing to exploit the system

108
00:04:13,519 --> 00:04:15,439
but side channels micro architectural

109
00:04:15,439 --> 00:04:19,120
attacks can help a bit there for example

110
00:04:19,120 --> 00:04:20,880
if you mount an attack on the kernel

111
00:04:20,880 --> 00:04:23,840
we'll also see that today as an example

112
00:04:23,840 --> 00:04:25,919
you first need to find the location of

113
00:04:25,919 --> 00:04:27,600
the crown because we have this kernel

114
00:04:27,600 --> 00:04:29,759
address-based layout randomization and

115
00:04:29,759 --> 00:04:32,320
side channels can be super effective in

116
00:04:32,320 --> 00:04:34,479
finding the kernel and then helping

117
00:04:34,479 --> 00:04:36,479
traditional exports

118
00:04:36,479 --> 00:04:39,280
and also these side channels

119
00:04:39,280 --> 00:04:42,400
in particular are an important building

120
00:04:42,400 --> 00:04:44,400
block for transient execution attacks

121
00:04:44,400 --> 00:04:47,199
and you've also seen them in these news

122
00:04:47,199 --> 00:04:49,520
headlines here with zombie load spectrum

123
00:04:49,520 --> 00:04:51,280
meltdown these are all transient

124
00:04:51,280 --> 00:04:53,520
execution attacks they are not side

125
00:04:53,520 --> 00:04:54,479
channels

126
00:04:54,479 --> 00:04:56,639
oh there are micro architectural attacks

127
00:04:56,639 --> 00:04:59,919
and they rely on side channels

128
00:04:59,919 --> 00:05:01,680
but if i'm talking about side channels

129
00:05:01,680 --> 00:05:03,360
and side channel text what do they even

130
00:05:03,360 --> 00:05:04,320
mean

131
00:05:04,320 --> 00:05:06,479
so let's take a simple example

132
00:05:06,479 --> 00:05:08,479
this is a well-known

133
00:05:08,479 --> 00:05:11,199
equation here that's the rsa

134
00:05:11,199 --> 00:05:12,720
decryption

135
00:05:12,720 --> 00:05:15,199
and that's mathematically sound that's

136
00:05:15,199 --> 00:05:17,680
super secure in a mathematical way but

137
00:05:17,680 --> 00:05:19,600
the mathematic is just an abstraction we

138
00:05:19,600 --> 00:05:21,680
have to implement that in software at

139
00:05:21,680 --> 00:05:23,440
some point and if you write that in

140
00:05:23,440 --> 00:05:25,680
software we can already see

141
00:05:25,680 --> 00:05:28,000
how we get difference in execution times

142
00:05:28,000 --> 00:05:30,720
depending on the secret values that are

143
00:05:30,720 --> 00:05:33,120
used if we implement it in a naive way

144
00:05:33,120 --> 00:05:35,759
with different execution flows depending

145
00:05:35,759 --> 00:05:38,800
on some secret bits but also software is

146
00:05:38,800 --> 00:05:40,639
just an abstraction layer

147
00:05:40,639 --> 00:05:43,120
on top of the hardware and hardware also

148
00:05:43,120 --> 00:05:45,120
does different stuff depending on the

149
00:05:45,120 --> 00:05:48,320
bits it uses zero bits one bits have

150
00:05:48,320 --> 00:05:51,039
different power consumptions so again an

151
00:05:51,039 --> 00:05:53,360
abstraction layer where things behave

152
00:05:53,360 --> 00:05:56,479
differently and might leak something

153
00:05:56,479 --> 00:05:59,039
and then we have something in between

154
00:05:59,039 --> 00:06:01,120
software and hardware

155
00:06:01,120 --> 00:06:02,240
where we have

156
00:06:02,240 --> 00:06:03,520
the micro architecture the

157
00:06:03,520 --> 00:06:05,680
implementation of the cpu and this

158
00:06:05,680 --> 00:06:07,360
consists of a lot of things a lot of

159
00:06:07,360 --> 00:06:09,199
elements there for example

160
00:06:09,199 --> 00:06:12,240
well-known things like cpu caches

161
00:06:12,240 --> 00:06:14,400
and they also introduce some side

162
00:06:14,400 --> 00:06:15,759
effects

163
00:06:15,759 --> 00:06:17,360
so for example

164
00:06:17,360 --> 00:06:20,080
as a quite simple side channel attack

165
00:06:20,080 --> 00:06:22,000
that relies on caches that is called

166
00:06:22,000 --> 00:06:24,400
flush and reload and in flash and reload

167
00:06:24,400 --> 00:06:26,800
we have some cpu with a cache we have

168
00:06:26,800 --> 00:06:28,400
some shared memory between two

169
00:06:28,400 --> 00:06:31,400
applications

170
00:06:43,919 --> 00:06:45,600
there's only one copy in the cache as

171
00:06:45,600 --> 00:06:47,759
well and so if it's cached it's cached

172
00:06:47,759 --> 00:06:50,000
for all the applications using it now an

173
00:06:50,000 --> 00:06:52,160
attacker can use unprivileged

174
00:06:52,160 --> 00:06:54,560
instructions assembly instructions to

175
00:06:54,560 --> 00:06:56,319
get rid of data from the cache remove it

176
00:06:56,319 --> 00:06:58,560
from the entire cache hierarchy flush it

177
00:06:58,560 --> 00:06:59,759
from the cache

178
00:06:59,759 --> 00:07:01,759
and then if the victim accesses the

179
00:07:01,759 --> 00:07:04,240
shared data it's transparently put into

180
00:07:04,240 --> 00:07:06,400
the cache copy will be stored there that

181
00:07:06,400 --> 00:07:10,000
happens in the cpu fully automated

182
00:07:10,000 --> 00:07:12,960
now an attacker can then later on

183
00:07:12,960 --> 00:07:14,960
access the shared memory

184
00:07:14,960 --> 00:07:16,960
and measure how long it takes to access

185
00:07:16,960 --> 00:07:17,840
it

186
00:07:17,840 --> 00:07:20,240
and from that an attacker can learn

187
00:07:20,240 --> 00:07:22,000
whether the thing is in the cache

188
00:07:22,000 --> 00:07:24,160
because if this access is fast then it's

189
00:07:24,160 --> 00:07:25,759
served from the cache

190
00:07:25,759 --> 00:07:27,120
and then the attacker knows that the

191
00:07:27,120 --> 00:07:29,039
victim accessed this part of the shared

192
00:07:29,039 --> 00:07:31,840
memory if the victim is slow it was not

193
00:07:31,840 --> 00:07:33,520
in the cache it had to be fetched from

194
00:07:33,520 --> 00:07:34,800
main memory

195
00:07:34,800 --> 00:07:36,800
slow and the attacker knows that the

196
00:07:36,800 --> 00:07:39,440
victim did not access that part of the

197
00:07:39,440 --> 00:07:41,599
shared memory in between

198
00:07:41,599 --> 00:07:43,919
and this is actually a timing difference

199
00:07:43,919 --> 00:07:46,240
that we can easily see

200
00:07:46,240 --> 00:07:48,479
so if we use our measurement primitives

201
00:07:48,479 --> 00:07:50,639
that we have for modern cpus we get

202
00:07:50,639 --> 00:07:52,560
timestamp counters from the hardware

203
00:07:52,560 --> 00:07:54,319
from the cpu

204
00:07:54,319 --> 00:07:56,479
and if you measure a cache hit then this

205
00:07:56,479 --> 00:07:58,879
was on my laptop here we see something

206
00:07:58,879 --> 00:08:01,680
like okay around 60 something cyclists

207
00:08:01,680 --> 00:08:03,280
including all that the measurement

208
00:08:03,280 --> 00:08:05,759
overhead so like fencing

209
00:08:05,759 --> 00:08:08,000
and storing the values to really catch a

210
00:08:08,000 --> 00:08:10,000
little bit faster but we see they are

211
00:08:10,000 --> 00:08:12,560
all in this order of magnitude here and

212
00:08:12,560 --> 00:08:14,720
if things are not in the cache

213
00:08:14,720 --> 00:08:17,599
then we suffer a cache miss things have

214
00:08:17,599 --> 00:08:19,599
to be loaded from memory my memory is

215
00:08:19,599 --> 00:08:22,080
quite slow here and all these things

216
00:08:22,080 --> 00:08:25,199
take at least 320 psyches

217
00:08:25,199 --> 00:08:27,280
to get them from main memory back to the

218
00:08:27,280 --> 00:08:30,240
cpu so we can clearly distinguish these

219
00:08:30,240 --> 00:08:32,719
two cases and with that see if data

220
00:08:32,719 --> 00:08:35,519
comes from the cache so it was recently

221
00:08:35,519 --> 00:08:37,839
used or if it has to be fetched from the

222
00:08:37,839 --> 00:08:40,880
main memory it was not used

223
00:08:40,880 --> 00:08:42,958
and this is a nice observation that's

224
00:08:42,958 --> 00:08:45,440
already a side channel it provides some

225
00:08:45,440 --> 00:08:46,720
information

226
00:08:46,720 --> 00:08:49,279
but no data leakage it

227
00:08:49,279 --> 00:08:50,720
but depending

228
00:08:50,720 --> 00:08:53,279
on the implementation of a victim

229
00:08:53,279 --> 00:08:55,680
this could lead to side channel

230
00:08:55,680 --> 00:08:56,880
information to

231
00:08:56,880 --> 00:08:59,040
actual data leakage

232
00:08:59,040 --> 00:09:01,680
if we go back to our example of rsa

233
00:09:01,680 --> 00:09:03,360
deprivation

234
00:09:03,360 --> 00:09:05,200
then we have this mathematical

235
00:09:05,200 --> 00:09:07,600
description and yes we have to implement

236
00:09:07,600 --> 00:09:10,000
that in software at some point

237
00:09:10,000 --> 00:09:12,320
and a naive implementation of that that

238
00:09:12,320 --> 00:09:14,880
was used a lot in the past is called

239
00:09:14,880 --> 00:09:16,959
square and multiply

240
00:09:16,959 --> 00:09:18,640
and in this approach we look at the

241
00:09:18,640 --> 00:09:22,560
exponent at the secret exponent d in a

242
00:09:22,560 --> 00:09:24,720
bit stream representation

243
00:09:24,720 --> 00:09:27,120
and then we start with our result we set

244
00:09:27,120 --> 00:09:28,640
our results to c

245
00:09:28,640 --> 00:09:30,560
and then we go bit by bit through the

246
00:09:30,560 --> 00:09:32,640
exponent and every time we find a one

247
00:09:32,640 --> 00:09:34,560
bit in the exponent

248
00:09:34,560 --> 00:09:37,360
we square our current result and then

249
00:09:37,360 --> 00:09:39,440
multiply it by c

250
00:09:39,440 --> 00:09:41,440
if there's a zero between the exponent

251
00:09:41,440 --> 00:09:44,640
we only square our result zero bit only

252
00:09:44,640 --> 00:09:47,519
square one bit square and multiply

253
00:09:47,519 --> 00:09:50,080
square multiply for one bit zero bit

254
00:09:50,080 --> 00:09:52,720
just square

255
00:09:52,720 --> 00:09:54,000
and from that

256
00:09:54,000 --> 00:09:56,800
we can already see that it's sufficient

257
00:09:56,800 --> 00:09:58,480
to observe

258
00:09:58,480 --> 00:10:00,720
the state of the square and the multiply

259
00:10:00,720 --> 00:10:01,680
function

260
00:10:01,680 --> 00:10:02,800
so if we

261
00:10:02,800 --> 00:10:04,399
mount this flush and reload attack from

262
00:10:04,399 --> 00:10:05,360
before

263
00:10:05,360 --> 00:10:07,760
then we can see like is both the re the

264
00:10:07,760 --> 00:10:09,920
result so that the square and the

265
00:10:09,920 --> 00:10:12,240
multiply function in the cache were both

266
00:10:12,240 --> 00:10:13,519
of them accessed

267
00:10:13,519 --> 00:10:16,399
then we know that the victim just

268
00:10:16,399 --> 00:10:18,959
processed a one bit in the exponent

269
00:10:18,959 --> 00:10:20,399
if we only see

270
00:10:20,399 --> 00:10:22,240
the square function in the cache then we

271
00:10:22,240 --> 00:10:24,640
know that was just a square no multiply

272
00:10:24,640 --> 00:10:26,880
and a zero bit in the exponent and that

273
00:10:26,880 --> 00:10:30,320
actually gives us the entire private key

274
00:10:30,320 --> 00:10:32,720
of this rsa encryption with this

275
00:10:32,720 --> 00:10:34,880
vulnerable implementation

276
00:10:34,880 --> 00:10:36,000
of course

277
00:10:36,000 --> 00:10:37,360
we don't want to use vulnerable

278
00:10:37,360 --> 00:10:39,519
implementation so there are also secure

279
00:10:39,519 --> 00:10:41,040
implementations that can't be attached

280
00:10:41,040 --> 00:10:42,880
to side channels

281
00:10:42,880 --> 00:10:45,040
but even in that case

282
00:10:45,040 --> 00:10:47,519
we can go one step further so now we

283
00:10:47,519 --> 00:10:50,560
have metadata so we only

284
00:10:50,560 --> 00:10:52,240
leaked information about something

285
00:10:52,240 --> 00:10:54,959
happening like some memory address was

286
00:10:54,959 --> 00:10:57,040
accessed or was not accessed that's what

287
00:10:57,040 --> 00:10:59,360
we get with a side channel

288
00:10:59,360 --> 00:11:01,600
now we want to have real data like what

289
00:11:01,600 --> 00:11:04,000
is stored at this memory location if we

290
00:11:04,000 --> 00:11:06,880
can achieve that we directly get the

291
00:11:06,880 --> 00:11:08,959
crypto key for example

292
00:11:08,959 --> 00:11:10,720
and this is also something that we can

293
00:11:10,720 --> 00:11:11,600
do

294
00:11:11,600 --> 00:11:14,399
and these things are called transient

295
00:11:14,399 --> 00:11:16,320
execution attacks

296
00:11:16,320 --> 00:11:18,640
they kind of evolved from side channel

297
00:11:18,640 --> 00:11:20,959
attacks they still use a side channel as

298
00:11:20,959 --> 00:11:22,640
one of the main building blocks or

299
00:11:22,640 --> 00:11:25,279
sections still very important

300
00:11:25,279 --> 00:11:26,959
and they use that in a kind of

301
00:11:26,959 --> 00:11:30,399
indirection because they leak data

302
00:11:30,399 --> 00:11:32,720
in a state that we cannot observe an out

303
00:11:32,720 --> 00:11:34,800
of order execution in speculative

304
00:11:34,800 --> 00:11:36,240
execution

305
00:11:36,240 --> 00:11:38,079
we can both prove them together to

306
00:11:38,079 --> 00:11:40,240
transient execution so things we never

307
00:11:40,240 --> 00:11:42,560
see on the architectural level

308
00:11:42,560 --> 00:11:45,600
but which we then can make visible using

309
00:11:45,600 --> 00:11:47,680
side channel attacks so we leak the data

310
00:11:47,680 --> 00:11:50,160
in this invisible domain and then

311
00:11:50,160 --> 00:11:52,240
transfer them to the visible domain

312
00:11:52,240 --> 00:11:54,639
using a side channel and we know such

313
00:11:54,639 --> 00:11:57,200
attacks as meltdown spectre zombie load

314
00:11:57,200 --> 00:12:00,240
for shadow fallout lvi crosstalk you

315
00:12:00,240 --> 00:12:02,560
name them there nowadays quite a lot of

316
00:12:02,560 --> 00:12:04,880
them although the first one was only

317
00:12:04,880 --> 00:12:08,839
discovered in 2017 not that long ago

318
00:12:08,839 --> 00:12:12,399
ago so we have all of them

319
00:12:12,399 --> 00:12:13,200
but

320
00:12:13,200 --> 00:12:15,360
we didn't talk about like finding them

321
00:12:15,360 --> 00:12:16,880
how does that work

322
00:12:16,880 --> 00:12:20,000
and this is actually a huge problem

323
00:12:20,000 --> 00:12:21,680
finding side channels

324
00:12:21,680 --> 00:12:23,920
and vulnerabilities that are then

325
00:12:23,920 --> 00:12:26,160
explored in trends and execution attacks

326
00:12:26,160 --> 00:12:28,320
is a really complex and time consuming

327
00:12:28,320 --> 00:12:29,360
process

328
00:12:29,360 --> 00:12:32,160
requires a lot of manpower trying a lot

329
00:12:32,160 --> 00:12:35,200
of stupid stuff investing a lot of time

330
00:12:35,200 --> 00:12:37,600
and also being lucky

331
00:12:37,600 --> 00:12:39,360
so this is not something

332
00:12:39,360 --> 00:12:41,120
that scales

333
00:12:41,120 --> 00:12:42,800
so the idea is

334
00:12:42,800 --> 00:12:45,279
we want to automate that

335
00:12:45,279 --> 00:12:47,760
but how can we automate like a complex

336
00:12:47,760 --> 00:12:51,120
process for finding vulnerabilities

337
00:12:51,120 --> 00:12:54,560
one of the ideas is to apply techniques

338
00:12:54,560 --> 00:12:56,480
that we know from software to the

339
00:12:56,480 --> 00:12:57,519
hardware

340
00:12:57,519 --> 00:12:59,440
so we know if you have complex software

341
00:12:59,440 --> 00:13:01,760
systems that contain some bugs that we

342
00:13:01,760 --> 00:13:03,200
want to find

343
00:13:03,200 --> 00:13:04,720
it doesn't scale if we do manual

344
00:13:04,720 --> 00:13:08,000
analysis so we have techniques like

345
00:13:08,000 --> 00:13:10,079
fuzzing that try to automatically

346
00:13:10,079 --> 00:13:12,959
generate things to trigger bugs trigger

347
00:13:12,959 --> 00:13:15,040
vulnerabilities that we can then later

348
00:13:15,040 --> 00:13:17,040
on fix

349
00:13:17,040 --> 00:13:20,320
and we can apply these techniques also

350
00:13:20,320 --> 00:13:22,000
to the cpu

351
00:13:22,000 --> 00:13:24,320
so on the cpu we don't really have data

352
00:13:24,320 --> 00:13:26,000
inputs that trigger something and we

353
00:13:26,000 --> 00:13:28,240
don't have bugs that crash

354
00:13:28,240 --> 00:13:30,399
but we can see like the input are

355
00:13:30,399 --> 00:13:32,880
basically code sequences that we put

356
00:13:32,880 --> 00:13:34,399
into the cpu

357
00:13:34,399 --> 00:13:37,279
and we get timing differences for some

358
00:13:37,279 --> 00:13:39,440
of the code sequences and we can

359
00:13:39,440 --> 00:13:41,279
consider them like vulnerabilities like

360
00:13:41,279 --> 00:13:44,560
bugs for software fuzzy

361
00:13:44,560 --> 00:13:46,320
of course fuzz can be

362
00:13:46,320 --> 00:13:48,160
incredibly complex and most software

363
00:13:48,160 --> 00:13:50,720
fuzzers are but you can also start with

364
00:13:50,720 --> 00:13:55,199
super dumb fuzzing with random inputs

365
00:13:55,199 --> 00:13:57,839
so we define a model of what we want to

366
00:13:57,839 --> 00:13:59,920
fuss because we can't just

367
00:13:59,920 --> 00:14:02,720
randomly do something we want to define

368
00:14:02,720 --> 00:14:05,040
certain things that we can then use as a

369
00:14:05,040 --> 00:14:06,720
model for our fuzz

370
00:14:06,720 --> 00:14:08,720
so we define microarchitectural states

371
00:14:08,720 --> 00:14:11,600
state 0 state 1 and then instruction

372
00:14:11,600 --> 00:14:13,360
sequences

373
00:14:13,360 --> 00:14:15,680
that go to these states we want a reset

374
00:14:15,680 --> 00:14:17,839
sequence to always get our micro

375
00:14:17,839 --> 00:14:20,240
architectural element like our cache

376
00:14:20,240 --> 00:14:23,760
in this known state s0

377
00:14:23,760 --> 00:14:25,199
no matter where we are if you're already

378
00:14:25,199 --> 00:14:27,600
in the state or not in a different state

379
00:14:27,600 --> 00:14:28,959
and then we want to find a trigger

380
00:14:28,959 --> 00:14:31,760
sequence that moves to the different

381
00:14:31,760 --> 00:14:33,600
sequence to s1

382
00:14:33,600 --> 00:14:34,959
in any case doesn't matter where we

383
00:14:34,959 --> 00:14:36,720
currently are

384
00:14:36,720 --> 00:14:39,040
and then additionally we want to have

385
00:14:39,040 --> 00:14:41,120
some measure sequence that tells us

386
00:14:41,120 --> 00:14:44,880
whether we are currently in s0 or s1

387
00:14:44,880 --> 00:14:46,959
and then we can start

388
00:14:46,959 --> 00:14:48,800
testing that and you will quickly see

389
00:14:48,800 --> 00:14:51,120
why this is a smart idea to do it like

390
00:14:51,120 --> 00:14:52,639
that

391
00:14:52,639 --> 00:14:55,440
so we have this reset sequence and then

392
00:14:55,440 --> 00:14:58,000
we measure we see in which state we are

393
00:14:58,000 --> 00:15:00,000
and we call this the cold path because

394
00:15:00,000 --> 00:15:02,399
nothing happens we reset the state we

395
00:15:02,399 --> 00:15:06,240
measure we expect to be in state 0.

396
00:15:06,240 --> 00:15:08,240
and on the other side we also have this

397
00:15:08,240 --> 00:15:11,120
reset then we have this trigger sequence

398
00:15:11,120 --> 00:15:13,360
that should get us to s1 and then we

399
00:15:13,360 --> 00:15:15,360
measure and then we have our hot bath

400
00:15:15,360 --> 00:15:17,600
because we did something in between

401
00:15:17,600 --> 00:15:19,600
and we should be in state one

402
00:15:19,600 --> 00:15:22,160
and if they have different timings in

403
00:15:22,160 --> 00:15:24,079
the measurement sequence

404
00:15:24,079 --> 00:15:26,800
then we know okay that's an interesting

405
00:15:26,800 --> 00:15:28,079
interference

406
00:15:28,079 --> 00:15:30,480
where some instruction sequences lead to

407
00:15:30,480 --> 00:15:32,880
timing differences and that might be a

408
00:15:32,880 --> 00:15:34,079
side channel

409
00:15:34,079 --> 00:15:36,399
and it might even be exploitable so we

410
00:15:36,399 --> 00:15:38,959
might be able to build an attack on top

411
00:15:38,959 --> 00:15:42,720
of that so to make it a bit more clear

412
00:15:42,720 --> 00:15:45,120
i brought two examples

413
00:15:45,120 --> 00:15:47,199
so we stay in this scenario

414
00:15:47,199 --> 00:15:50,480
and we take for these sequences we make

415
00:15:50,480 --> 00:15:52,560
it super simple we always use one

416
00:15:52,560 --> 00:15:54,160
instruction for the sequence and all the

417
00:15:54,160 --> 00:15:56,800
sequences use the same instruction so we

418
00:15:56,800 --> 00:15:59,839
use an increment on a memory address

419
00:15:59,839 --> 00:16:02,720
so basically we touch a memory address

420
00:16:02,720 --> 00:16:04,320
and we use that for the reset sequence

421
00:16:04,320 --> 00:16:05,920
for the trigger sequence and for the

422
00:16:05,920 --> 00:16:06,839
measurement

423
00:16:06,839 --> 00:16:08,399
sequence

424
00:16:08,399 --> 00:16:10,800
so if we look at the cold path

425
00:16:10,800 --> 00:16:12,639
the reset sequence

426
00:16:12,639 --> 00:16:14,639
is an increment of a memory location

427
00:16:14,639 --> 00:16:17,120
what happens there it will be put into

428
00:16:17,120 --> 00:16:19,120
the cache we access this data

429
00:16:19,120 --> 00:16:21,360
it also gets dirty it's a modified cache

430
00:16:21,360 --> 00:16:23,279
line it's in the cache

431
00:16:23,279 --> 00:16:25,360
the measurement sequence does the same

432
00:16:25,360 --> 00:16:27,680
thing it increments a memory location

433
00:16:27,680 --> 00:16:29,600
that is already in the cache so that

434
00:16:29,600 --> 00:16:32,399
will be fast

435
00:16:32,399 --> 00:16:33,759
on the other side with the trigger

436
00:16:33,759 --> 00:16:36,399
sequence we also do the reset the

437
00:16:36,399 --> 00:16:39,199
increment as before puts the modified

438
00:16:39,199 --> 00:16:40,959
state in the cache then we have the

439
00:16:40,959 --> 00:16:43,279
trigger sequence that also increments

440
00:16:43,279 --> 00:16:44,720
this memory location which is in the

441
00:16:44,720 --> 00:16:46,880
cache so that's fast but we don't care

442
00:16:46,880 --> 00:16:48,839
about the timing here so it stays in the

443
00:16:48,839 --> 00:16:51,839
cache and then the measure sequence also

444
00:16:51,839 --> 00:16:54,240
increments this memory location which is

445
00:16:54,240 --> 00:16:57,920
in the cache which is also fast

446
00:16:57,920 --> 00:16:58,959
so

447
00:16:58,959 --> 00:17:01,680
both cases show the same timing so this

448
00:17:01,680 --> 00:17:02,320
is

449
00:17:02,320 --> 00:17:04,240
not a new section that's that's nothing

450
00:17:04,240 --> 00:17:05,199
interesting

451
00:17:05,199 --> 00:17:07,359
and that makes sense some increments

452
00:17:07,359 --> 00:17:10,079
don't interfere with each other

453
00:17:10,079 --> 00:17:11,919
but now let's

454
00:17:11,919 --> 00:17:14,400
replace the reset sequence

455
00:17:14,400 --> 00:17:15,839
with a flash

456
00:17:15,839 --> 00:17:17,439
so we notice flush from the flashing

457
00:17:17,439 --> 00:17:20,160
reload attack before it removes data

458
00:17:20,160 --> 00:17:22,319
from the entire cache hierarchy

459
00:17:22,319 --> 00:17:24,959
so our reset sequence is now a flush of

460
00:17:24,959 --> 00:17:26,959
the memory address and the other

461
00:17:26,959 --> 00:17:29,200
sequences stay the increment of this

462
00:17:29,200 --> 00:17:30,720
address

463
00:17:30,720 --> 00:17:32,480
what happens now

464
00:17:32,480 --> 00:17:34,640
in the cold path we flush the memory

465
00:17:34,640 --> 00:17:36,400
address from the cache

466
00:17:36,400 --> 00:17:39,360
and then this address is not cached

467
00:17:39,360 --> 00:17:40,720
and when we increment that in the

468
00:17:40,720 --> 00:17:43,440
measurement sequence that takes a long

469
00:17:43,440 --> 00:17:45,200
time because it has to be fetched from

470
00:17:45,200 --> 00:17:47,120
main memory

471
00:17:47,120 --> 00:17:48,640
in the hot path

472
00:17:48,640 --> 00:17:50,640
we also reset it we flush it it's not in

473
00:17:50,640 --> 00:17:52,080
the cache

474
00:17:52,080 --> 00:17:53,280
when we

475
00:17:53,280 --> 00:17:55,280
execute the trigger sequence

476
00:17:55,280 --> 00:17:57,520
it will be put into the cache

477
00:17:57,520 --> 00:17:59,120
and in a measurement sequence it's

478
00:17:59,120 --> 00:18:00,400
already in the cache

479
00:18:00,400 --> 00:18:03,280
so when measuring it it will be fast

480
00:18:03,280 --> 00:18:05,760
and now we have timing differences

481
00:18:05,760 --> 00:18:07,679
and now we know this is something

482
00:18:07,679 --> 00:18:10,320
interesting and yes it turns out this is

483
00:18:10,320 --> 00:18:12,400
basically flush and reload so we have

484
00:18:12,400 --> 00:18:13,760
the flush

485
00:18:13,760 --> 00:18:15,919
and then we measure by reloading the

486
00:18:15,919 --> 00:18:18,080
memory in our case it's an increment but

487
00:18:18,080 --> 00:18:20,160
it's still a memory access

488
00:18:20,160 --> 00:18:21,919
and if nothing happened by the victim in

489
00:18:21,919 --> 00:18:24,240
between it's slow but if the victim

490
00:18:24,240 --> 00:18:26,000
executed the trigger sequence like

491
00:18:26,000 --> 00:18:28,799
another memory access then it's fast and

492
00:18:28,799 --> 00:18:30,799
we can see that

493
00:18:30,799 --> 00:18:33,360
so that all already rediscovers the

494
00:18:33,360 --> 00:18:35,840
flush and reload side channel in our

495
00:18:35,840 --> 00:18:38,320
nice sequence triple model

496
00:18:38,320 --> 00:18:39,600
now we can do that for all the

497
00:18:39,600 --> 00:18:42,080
applications so we simply take an iso

498
00:18:42,080 --> 00:18:44,240
description of a cpu extract all the

499
00:18:44,240 --> 00:18:46,720
instructions there are and then start

500
00:18:46,720 --> 00:18:48,880
generating triples

501
00:18:48,880 --> 00:18:50,080
for triggers

502
00:18:50,080 --> 00:18:51,919
for reset sequences and for measurement

503
00:18:51,919 --> 00:18:53,120
sequences

504
00:18:53,120 --> 00:18:56,000
and we execute random combinations of

505
00:18:56,000 --> 00:18:58,720
these instruction triples and always see

506
00:18:58,720 --> 00:19:01,280
with the hotbed bath and the cold path

507
00:19:01,280 --> 00:19:04,000
if we see timing differences

508
00:19:04,000 --> 00:19:06,080
if we do we still try to confirm that a

509
00:19:06,080 --> 00:19:07,200
bit

510
00:19:07,200 --> 00:19:09,360
randomize that execute that multiple

511
00:19:09,360 --> 00:19:11,600
times because there could be some

512
00:19:11,600 --> 00:19:13,840
interference from somewhere else could

513
00:19:13,840 --> 00:19:16,559
be rescheduling some interrupts some

514
00:19:16,559 --> 00:19:18,880
unrelated application so we do that

515
00:19:18,880 --> 00:19:21,120
multiple times and if you always see the

516
00:19:21,120 --> 00:19:22,880
timing difference

517
00:19:22,880 --> 00:19:25,120
that's a good sign that we actually

518
00:19:25,120 --> 00:19:27,600
found some interference between

519
00:19:27,600 --> 00:19:30,000
instructions

520
00:19:30,000 --> 00:19:32,240
in the end we will have a lot of them

521
00:19:32,240 --> 00:19:34,320
just think about the flush and reload

522
00:19:34,320 --> 00:19:36,559
the reset sequence is a flush

523
00:19:36,559 --> 00:19:39,360
and trigger and measures everything that

524
00:19:39,360 --> 00:19:42,000
accesses the memory either a store or a

525
00:19:42,000 --> 00:19:44,320
load so we'll find like hundreds of

526
00:19:44,320 --> 00:19:46,400
variants of flushing preload

527
00:19:46,400 --> 00:19:48,480
where we always have the flush and then

528
00:19:48,480 --> 00:19:50,640
something that accesses the memory so we

529
00:19:50,640 --> 00:19:53,039
also clustered it a bit to make it

530
00:19:53,039 --> 00:19:55,679
easier to manually analyze in the end

531
00:19:55,679 --> 00:19:57,760
so we look at for example performance

532
00:19:57,760 --> 00:20:00,400
counters to see which elements are

533
00:20:00,400 --> 00:20:02,400
involved in the cpu

534
00:20:02,400 --> 00:20:04,400
we also look at the instruction itself

535
00:20:04,400 --> 00:20:06,799
and see which category of instruction it

536
00:20:06,799 --> 00:20:10,000
is and then create some clusters

537
00:20:10,000 --> 00:20:11,120
and

538
00:20:11,120 --> 00:20:13,760
this gives us in the end a report

539
00:20:13,760 --> 00:20:16,000
telling us what to look at what could be

540
00:20:16,000 --> 00:20:18,840
interesting as a new source for a

541
00:20:18,840 --> 00:20:22,159
cycle we did that on five different cpus

542
00:20:22,159 --> 00:20:24,640
from amd and from intel

543
00:20:24,640 --> 00:20:26,640
and we let that run

544
00:20:26,640 --> 00:20:29,360
around four days per cpu

545
00:20:29,360 --> 00:20:31,440
and that already restarted in some nice

546
00:20:31,440 --> 00:20:33,280
discoveries

547
00:20:33,280 --> 00:20:35,039
so we rediscovered

548
00:20:35,039 --> 00:20:37,679
two already known side channels

549
00:20:37,679 --> 00:20:39,840
which is not that interesting but it's

550
00:20:39,840 --> 00:20:41,520
still nice because it confirms that the

551
00:20:41,520 --> 00:20:43,760
approach works and also finds things

552
00:20:43,760 --> 00:20:45,440
that have been discovered manually

553
00:20:45,440 --> 00:20:46,799
before

554
00:20:46,799 --> 00:20:48,400
but in addition to that

555
00:20:48,400 --> 00:20:50,880
we also discovered four new side

556
00:20:50,880 --> 00:20:53,679
channels they haven't been known before

557
00:20:53,679 --> 00:20:56,000
and these are not some obscure side

558
00:20:56,000 --> 00:20:58,720
channels that are completely useless no

559
00:20:58,720 --> 00:21:01,600
we showed that we can also build attacks

560
00:21:01,600 --> 00:21:03,200
on top of that

561
00:21:03,200 --> 00:21:06,480
so we also showed two new attacks

562
00:21:06,480 --> 00:21:07,919
one of them

563
00:21:07,919 --> 00:21:10,480
is quite an interesting observation it's

564
00:21:10,480 --> 00:21:12,240
about the hardware random number

565
00:21:12,240 --> 00:21:14,159
generator that can be accessed using the

566
00:21:14,159 --> 00:21:17,840
rgrand instruction and it turns out that

567
00:21:17,840 --> 00:21:19,679
this instruction has cross-core

568
00:21:19,679 --> 00:21:23,360
interference so if some cpu core uses

569
00:21:23,360 --> 00:21:26,320
currently rd-rand to get random numbers

570
00:21:26,320 --> 00:21:28,720
then the latency for other cores

571
00:21:28,720 --> 00:21:30,320
increases

572
00:21:30,320 --> 00:21:32,320
and that works cross core

573
00:21:32,320 --> 00:21:34,960
and also across vm

574
00:21:34,960 --> 00:21:37,760
and it doesn't require any memory

575
00:21:37,760 --> 00:21:39,840
no shared memory nothing just this

576
00:21:39,840 --> 00:21:41,120
instruction

577
00:21:41,120 --> 00:21:43,280
and we showed that it actually works

578
00:21:43,280 --> 00:21:45,120
on the cloud as well we tested that on

579
00:21:45,120 --> 00:21:48,080
the aws cloud and we're able to

580
00:21:48,080 --> 00:21:51,760
stealthily transmit data between two vms

581
00:21:51,760 --> 00:21:54,720
without using any documented

582
00:21:54,720 --> 00:21:56,240
interface without using the network

583
00:21:56,240 --> 00:21:58,640
anything just relying on this hardware

584
00:21:58,640 --> 00:22:00,400
instruction

585
00:22:00,400 --> 00:22:01,360
and

586
00:22:01,360 --> 00:22:03,440
this channel is like not the first cover

587
00:22:03,440 --> 00:22:05,039
channel in the cloud

588
00:22:05,039 --> 00:22:07,200
but has some really nice properties

589
00:22:07,200 --> 00:22:09,840
it works on amd and intel cpus

590
00:22:09,840 --> 00:22:11,679
which is really fascinating

591
00:22:11,679 --> 00:22:14,400
it works inside virtual machines and of

592
00:22:14,400 --> 00:22:16,480
course then also native code

593
00:22:16,480 --> 00:22:18,480
it's not that slow so we managed to do

594
00:22:18,480 --> 00:22:20,799
one kilobit per second of transmission

595
00:22:20,799 --> 00:22:23,039
without optimizing that

596
00:22:23,039 --> 00:22:25,440
it does not require any memory

597
00:22:25,440 --> 00:22:27,280
so that's also something that is quite

598
00:22:27,280 --> 00:22:28,240
new

599
00:22:28,240 --> 00:22:30,240
that also means

600
00:22:30,240 --> 00:22:32,000
current approaches can't detect that

601
00:22:32,000 --> 00:22:33,440
there are no performance counters

602
00:22:33,440 --> 00:22:36,320
nothing that could detect this kind of

603
00:22:36,320 --> 00:22:38,400
covert trans transmission

604
00:22:38,400 --> 00:22:40,799
and there's also no mitigation

605
00:22:40,799 --> 00:22:43,039
this instruction is always available you

606
00:22:43,039 --> 00:22:45,520
can't disable it and you can't monitor

607
00:22:45,520 --> 00:22:47,840
it you can't trap it so this is

608
00:22:47,840 --> 00:22:50,480
something that cannot be prevented on

609
00:22:50,480 --> 00:22:52,960
current hardware which makes it quite

610
00:22:52,960 --> 00:22:54,960
powerful and interesting

611
00:22:54,960 --> 00:22:57,760
side channel and collection

612
00:22:57,760 --> 00:22:59,760
another observation that we had that was

613
00:22:59,760 --> 00:23:02,240
also not known before that

614
00:23:02,240 --> 00:23:03,679
we know flush and reload we know that

615
00:23:03,679 --> 00:23:05,679
with cl flush we can flush something

616
00:23:05,679 --> 00:23:06,880
from the cache

617
00:23:06,880 --> 00:23:09,440
but we also figured out with osiris with

618
00:23:09,440 --> 00:23:11,840
the fuzzing that the cl flush can be

619
00:23:11,840 --> 00:23:14,400
replaced by a non-temporal move

620
00:23:14,400 --> 00:23:16,159
and a non-temporal move is a store

621
00:23:16,159 --> 00:23:17,360
instruction

622
00:23:17,360 --> 00:23:20,080
that also flushes things from the cache

623
00:23:20,080 --> 00:23:21,760
because it's a hint to the cpu that the

624
00:23:21,760 --> 00:23:23,919
cache is not needed for that data it

625
00:23:23,919 --> 00:23:26,080
turns out it flushes the data then if

626
00:23:26,080 --> 00:23:28,000
it's in the cache

627
00:23:28,000 --> 00:23:29,200
and

628
00:23:29,200 --> 00:23:30,960
it's like okay you say like that's not

629
00:23:30,960 --> 00:23:33,039
so interesting but it turns out it also

630
00:23:33,039 --> 00:23:35,520
has some nice properties compared to cl

631
00:23:35,520 --> 00:23:37,200
flush

632
00:23:37,200 --> 00:23:39,200
it is a bit faster

633
00:23:39,200 --> 00:23:40,960
so we attribute that to the cash

634
00:23:40,960 --> 00:23:43,279
coherency protocol involved there

635
00:23:43,279 --> 00:23:45,120
it's super stealthy

636
00:23:45,120 --> 00:23:47,600
if somebody scans binaries for cl flush

637
00:23:47,600 --> 00:23:49,919
because still flash is mostly used for

638
00:23:49,919 --> 00:23:52,000
microarchitectural attacks

639
00:23:52,000 --> 00:23:54,000
this application won't find it super

640
00:23:54,000 --> 00:23:55,279
stealthy

641
00:23:55,279 --> 00:23:57,919
and also new cache designs

642
00:23:57,919 --> 00:23:59,520
they don't consider that they consider

643
00:23:59,520 --> 00:24:00,640
flush

644
00:24:00,640 --> 00:24:03,279
but who considers a non-temporal move so

645
00:24:03,279 --> 00:24:05,360
that might also circumvent some

646
00:24:05,360 --> 00:24:08,880
mitigations put into new cache designs

647
00:24:08,880 --> 00:24:12,080
so if you also use that it's also useful

648
00:24:12,080 --> 00:24:13,919
for meltdown attacks

649
00:24:13,919 --> 00:24:16,799
so previously melton attacks only leaked

650
00:24:16,799 --> 00:24:19,440
like up to three bytes at once for one

651
00:24:19,440 --> 00:24:21,039
illegal access

652
00:24:21,039 --> 00:24:23,279
so you can leak like 24

653
00:24:23,279 --> 00:24:24,880
bits at once

654
00:24:24,880 --> 00:24:27,520
and if you replace the seal flush with

655
00:24:27,520 --> 00:24:29,200
this moth nt

656
00:24:29,200 --> 00:24:31,440
then it's faster and we were able to

657
00:24:31,440 --> 00:24:33,600
leak nearly eight bytes at once you can

658
00:24:33,600 --> 00:24:37,200
leak 64-bit secrets most of the time at

659
00:24:37,200 --> 00:24:39,840
once which is also pretty nice

660
00:24:39,840 --> 00:24:41,840
improvement there making these attacks

661
00:24:41,840 --> 00:24:43,760
even more powerful

662
00:24:43,760 --> 00:24:46,480
and as mentioned in the beginning we can

663
00:24:46,480 --> 00:24:48,400
also use that

664
00:24:48,400 --> 00:24:49,360
for

665
00:24:49,360 --> 00:24:51,200
kslr breaks to

666
00:24:51,200 --> 00:24:54,159
figure out where the kernel is stored in

667
00:24:54,159 --> 00:24:56,400
our virtual address space which is quite

668
00:24:56,400 --> 00:25:00,000
useful for traditional software exploits

669
00:25:00,000 --> 00:25:02,320
and we came up with a setup like that we

670
00:25:02,320 --> 00:25:05,279
tried them off empty on kernel addresses

671
00:25:05,279 --> 00:25:06,720
see if something happens if something

672
00:25:06,720 --> 00:25:08,799
interesting happens on the kernel as

673
00:25:08,799 --> 00:25:09,840
well

674
00:25:09,840 --> 00:25:11,200
and it turned out

675
00:25:11,200 --> 00:25:14,640
moth nt on call addresses

676
00:25:14,640 --> 00:25:16,880
influences conflicts between flush and

677
00:25:16,880 --> 00:25:19,039
loads in user space

678
00:25:19,039 --> 00:25:21,120
and so if you if you flush an address in

679
00:25:21,120 --> 00:25:23,440
user space and load it again like doing

680
00:25:23,440 --> 00:25:25,600
a flush and reload attack

681
00:25:25,600 --> 00:25:27,120
then

682
00:25:27,120 --> 00:25:29,120
the cache state of the load whether it's

683
00:25:29,120 --> 00:25:30,640
a cache hit or a miss

684
00:25:30,640 --> 00:25:32,159
depends

685
00:25:32,159 --> 00:25:32,960
on

686
00:25:32,960 --> 00:25:35,679
the kernel address that we dereference

687
00:25:35,679 --> 00:25:38,960
in between using the mov nt

688
00:25:38,960 --> 00:25:41,200
so that also gives us information about

689
00:25:41,200 --> 00:25:43,200
the kernel it tells us which kernel

690
00:25:43,200 --> 00:25:46,480
address is mapped or not mapped

691
00:25:46,480 --> 00:25:49,120
so this is also a nice new attack

692
00:25:49,120 --> 00:25:51,279
that works on modern cpus where all the

693
00:25:51,279 --> 00:25:55,039
other ksl outbreaks don't work anymore

694
00:25:55,039 --> 00:25:57,919
so we see this bit of fasting for a few

695
00:25:57,919 --> 00:26:00,480
hours already resulted in quite some

696
00:26:00,480 --> 00:26:01,919
interesting things

697
00:26:01,919 --> 00:26:03,679
it improved the implementation of trends

698
00:26:03,679 --> 00:26:06,080
and execution attacks

699
00:26:06,080 --> 00:26:08,240
but you might now say like can we also

700
00:26:08,240 --> 00:26:10,640
find them like not only improve them can

701
00:26:10,640 --> 00:26:13,120
we also find them

702
00:26:13,120 --> 00:26:16,640
turns out spoiler yes we can

703
00:26:16,640 --> 00:26:17,760
so for that

704
00:26:17,760 --> 00:26:21,039
we focused on a subset of these attacks

705
00:26:21,039 --> 00:26:22,559
we focused on the microarchitectural

706
00:26:22,559 --> 00:26:25,200
data sampling attacks that contain like

707
00:26:25,200 --> 00:26:27,360
zombie load riddle fallout and meltdown

708
00:26:27,360 --> 00:26:29,120
uncachable

709
00:26:29,120 --> 00:26:32,240
and these are just like base names and

710
00:26:32,240 --> 00:26:34,240
all of them have different variants with

711
00:26:34,240 --> 00:26:36,799
different leakage targets and different

712
00:26:36,799 --> 00:26:38,799
ways to trigger them so it's quite

713
00:26:38,799 --> 00:26:41,520
complex to reproduce all of them also

714
00:26:41,520 --> 00:26:43,679
find all of them there are probably many

715
00:26:43,679 --> 00:26:46,480
more out there many more variants

716
00:26:46,480 --> 00:26:47,200
but

717
00:26:47,200 --> 00:26:48,799
they all have something in common that

718
00:26:48,799 --> 00:26:51,600
we again can use for fussing they all

719
00:26:51,600 --> 00:26:52,400
require

720
00:26:52,400 --> 00:26:53,840
a fault

721
00:26:53,840 --> 00:26:54,720
like a

722
00:26:54,720 --> 00:26:56,000
page fault

723
00:26:56,000 --> 00:26:58,720
or a microcode assist which is kind of

724
00:26:58,720 --> 00:27:00,720
an internal fault in the cpu where it

725
00:27:00,720 --> 00:27:04,799
has to handle some really complex case

726
00:27:04,799 --> 00:27:07,279
and so for all these mds attacks for

727
00:27:07,279 --> 00:27:08,880
this microarchitectural data sampling

728
00:27:08,880 --> 00:27:10,000
attacks

729
00:27:10,000 --> 00:27:12,320
they are on high level quite similar and

730
00:27:12,320 --> 00:27:13,600
quite easy

731
00:27:13,600 --> 00:27:16,080
you try to read from a memory location

732
00:27:16,080 --> 00:27:18,320
that leads to a fault

733
00:27:18,320 --> 00:27:20,799
then your architecturally stop

734
00:27:20,799 --> 00:27:22,480
transiently in the out of order

735
00:27:22,480 --> 00:27:25,279
execution you still get value back and

736
00:27:25,279 --> 00:27:27,279
it is some value typically something

737
00:27:27,279 --> 00:27:30,080
that's close by from a different buffer

738
00:27:30,080 --> 00:27:32,080
stale values something that was used on

739
00:27:32,080 --> 00:27:33,600
the hyper thread

740
00:27:33,600 --> 00:27:35,279
you transiently get this value in the

741
00:27:35,279 --> 00:27:37,279
out of order execution

742
00:27:37,279 --> 00:27:39,200
then you encode it in the micro

743
00:27:39,200 --> 00:27:41,760
architecture for example by accessing a

744
00:27:41,760 --> 00:27:43,679
memory location that depends on the

745
00:27:43,679 --> 00:27:46,399
value you read so if you get value k we

746
00:27:46,399 --> 00:27:48,480
access page number k

747
00:27:48,480 --> 00:27:50,240
on in some array

748
00:27:50,240 --> 00:27:52,480
this will be cached and then afterwards

749
00:27:52,480 --> 00:27:54,559
if we resolve default

750
00:27:54,559 --> 00:27:57,279
we go through this user memory see which

751
00:27:57,279 --> 00:27:59,679
part is cached and from that

752
00:27:59,679 --> 00:28:02,080
see here for example part k is cached we

753
00:28:02,080 --> 00:28:04,880
infer that the value we got was a k

754
00:28:04,880 --> 00:28:07,120
with that we get actual data just by

755
00:28:07,120 --> 00:28:09,360
using this fold encoding it in the micro

756
00:28:09,360 --> 00:28:11,760
architecture and using a side channel to

757
00:28:11,760 --> 00:28:14,080
recover it there

758
00:28:14,080 --> 00:28:16,799
and it turns out faulting when we talk

759
00:28:16,799 --> 00:28:19,200
about faulting most people think

760
00:28:19,200 --> 00:28:21,120
about page faults

761
00:28:21,120 --> 00:28:22,880
but actually there are many many

762
00:28:22,880 --> 00:28:26,000
possibilities for faults on modern cpus

763
00:28:26,000 --> 00:28:28,480
so we tried to have like a

764
00:28:28,480 --> 00:28:30,880
short sequence here what could go wrong

765
00:28:30,880 --> 00:28:32,080
and turns out

766
00:28:32,080 --> 00:28:33,840
quite a lot of things can go wrong if we

767
00:28:33,840 --> 00:28:35,760
do a simple memory access

768
00:28:35,760 --> 00:28:38,720
the cpu has to check whether the virtual

769
00:28:38,720 --> 00:28:42,080
address is in a correct form

770
00:28:42,080 --> 00:28:44,480
it's canonical if not it falls if yes

771
00:28:44,480 --> 00:28:46,799
has to check is it in the tlb not in the

772
00:28:46,799 --> 00:28:49,039
tlb has to trigger page miss handle if

773
00:28:49,039 --> 00:28:50,559
it's not there then check the

774
00:28:50,559 --> 00:28:52,159
permissions

775
00:28:52,159 --> 00:28:54,399
then check if this page is actually

776
00:28:54,399 --> 00:28:56,960
present if it can be accessed

777
00:28:56,960 --> 00:28:59,039
if the page was not accessed before it

778
00:28:59,039 --> 00:29:00,960
has to trigger some internal code to set

779
00:29:00,960 --> 00:29:02,640
the axis bit

780
00:29:02,640 --> 00:29:04,880
then for a vector instruction has to

781
00:29:04,880 --> 00:29:06,320
check whether this memory access is

782
00:29:06,320 --> 00:29:07,679
actually aligned

783
00:29:07,679 --> 00:29:09,120
then has to check

784
00:29:09,120 --> 00:29:11,279
is it within one cache line or does it

785
00:29:11,279 --> 00:29:14,080
spun span over two cache lines is it

786
00:29:14,080 --> 00:29:16,159
cached or not cached was there a

787
00:29:16,159 --> 00:29:18,640
dependency on a previous store

788
00:29:18,640 --> 00:29:21,440
and are we in a transaction that could

789
00:29:21,440 --> 00:29:23,600
abort so there are quite a lot of points

790
00:29:23,600 --> 00:29:25,679
in the memory access where things can go

791
00:29:25,679 --> 00:29:27,919
wrong and throw an exception

792
00:29:27,919 --> 00:29:30,159
and this graph is not complete

793
00:29:30,159 --> 00:29:33,200
so will be many more cases as well

794
00:29:33,200 --> 00:29:36,080
the idea is now to mutate existing

795
00:29:36,080 --> 00:29:38,399
variants trigger different faults here

796
00:29:38,399 --> 00:29:40,480
and see what happens

797
00:29:40,480 --> 00:29:42,159
so in trend center

798
00:29:42,159 --> 00:29:44,480
we used building blocks from meltdown

799
00:29:44,480 --> 00:29:46,399
from riddle from fallout from zombie

800
00:29:46,399 --> 00:29:49,679
load and some other random instructions

801
00:29:49,679 --> 00:29:50,480
and

802
00:29:50,480 --> 00:29:52,799
let this application mute data

803
00:29:52,799 --> 00:29:54,960
so take part from here from here add

804
00:29:54,960 --> 00:29:56,480
some instructions here remove some

805
00:29:56,480 --> 00:29:58,000
instructions there

806
00:29:58,000 --> 00:30:01,279
mutate it and generate new potential

807
00:30:01,279 --> 00:30:04,080
meltdown code sequences

808
00:30:04,080 --> 00:30:06,320
then we execute these code sequences

809
00:30:06,320 --> 00:30:08,480
and see if you get data out of that

810
00:30:08,480 --> 00:30:10,880
if there's no leakage well that's in

811
00:30:10,880 --> 00:30:13,360
most cases then we continue mutating

812
00:30:13,360 --> 00:30:16,080
randomly mutating building our weird

813
00:30:16,080 --> 00:30:17,279
code

814
00:30:17,279 --> 00:30:20,159
but if we get some values out of that

815
00:30:20,159 --> 00:30:22,000
then we send it to the classification

816
00:30:22,000 --> 00:30:24,320
step where we again look at performance

817
00:30:24,320 --> 00:30:26,640
counters seeing like which elements are

818
00:30:26,640 --> 00:30:28,399
involved like oh there's a store buffer

819
00:30:28,399 --> 00:30:30,480
involved this is active all the time

820
00:30:30,480 --> 00:30:32,720
might be a variant of fallout or maybe

821
00:30:32,720 --> 00:30:34,480
something new

822
00:30:34,480 --> 00:30:35,520
and then

823
00:30:35,520 --> 00:30:37,600
give that classification again to an

824
00:30:37,600 --> 00:30:38,880
expert

825
00:30:38,880 --> 00:30:42,159
and check what this transcender tool

826
00:30:42,159 --> 00:30:43,760
found

827
00:30:43,760 --> 00:30:44,960
to also

828
00:30:44,960 --> 00:30:46,799
get a bit more information of what we

829
00:30:46,799 --> 00:30:48,960
actually leaked we before fill all the

830
00:30:48,960 --> 00:30:50,960
micro architectural buffers with known

831
00:30:50,960 --> 00:30:52,480
values

832
00:30:52,480 --> 00:30:54,399
so we fill the cache with known values

833
00:30:54,399 --> 00:30:55,919
store buffers

834
00:30:55,919 --> 00:30:58,080
fill buffers and so on so that if we

835
00:30:58,080 --> 00:31:00,320
leak then values we know from where we

836
00:31:00,320 --> 00:31:02,799
leaked them

837
00:31:02,799 --> 00:31:05,440
and we only let that run for 26 hours

838
00:31:05,440 --> 00:31:07,440
and in that time we already

839
00:31:07,440 --> 00:31:10,320
saw 100 unique leakage patterns seven

840
00:31:10,320 --> 00:31:12,000
attacks that were reproduced that were

841
00:31:12,000 --> 00:31:14,320
not in the initial set for the fusser

842
00:31:14,320 --> 00:31:17,519
one completely new vulnerability and one

843
00:31:17,519 --> 00:31:19,519
regression

844
00:31:19,519 --> 00:31:21,200
so this new vulnerability was then

845
00:31:21,200 --> 00:31:22,799
dubbed medusa

846
00:31:22,799 --> 00:31:26,080
is a variant of zombie load that focuses

847
00:31:26,080 --> 00:31:28,159
on the right combining buffer

848
00:31:28,159 --> 00:31:31,360
a buffer that is used for this fast

849
00:31:31,360 --> 00:31:33,919
string operations on interest views they

850
00:31:33,919 --> 00:31:36,240
are for example used for memory copy in

851
00:31:36,240 --> 00:31:38,960
the open ssl crypto library or in the

852
00:31:38,960 --> 00:31:40,000
kernel

853
00:31:40,000 --> 00:31:41,200
and we showed

854
00:31:41,200 --> 00:31:43,360
that we can directly leak then the

855
00:31:43,360 --> 00:31:44,960
strings that were copied using these

856
00:31:44,960 --> 00:31:48,080
instructions and with that leaked an rsa

857
00:31:48,080 --> 00:31:52,320
key from opemssl with a new nice attack

858
00:31:52,320 --> 00:31:55,919
without any unrelated values

859
00:31:55,919 --> 00:31:58,399
you also discovered this regression in

860
00:31:58,399 --> 00:32:00,799
the ice lake micro architecture this

861
00:32:00,799 --> 00:32:02,240
micro architecture reported no

862
00:32:02,240 --> 00:32:03,840
vulnerabilities

863
00:32:03,840 --> 00:32:06,240
but transcender still found

864
00:32:06,240 --> 00:32:09,840
a slightly mutated variant of fallout

865
00:32:09,840 --> 00:32:11,919
that again worked so it was not

866
00:32:11,919 --> 00:32:13,679
completely fixed

867
00:32:13,679 --> 00:32:16,240
luckily intel was able to provide a

868
00:32:16,240 --> 00:32:19,440
microcode update there so now it's again

869
00:32:19,440 --> 00:32:20,720
fixed

870
00:32:20,720 --> 00:32:24,240
so that's the good news here

871
00:32:24,240 --> 00:32:27,120
so we have seen from these examples that

872
00:32:27,120 --> 00:32:28,880
we have like these small specialized

873
00:32:28,880 --> 00:32:30,000
fuzzers

874
00:32:30,000 --> 00:32:32,320
so far we only covered small fields of

875
00:32:32,320 --> 00:32:34,799
possible vulnerabilities the fuzzers are

876
00:32:34,799 --> 00:32:37,279
extremely simple and dumb have a narrow

877
00:32:37,279 --> 00:32:39,440
scope they don't consider complex

878
00:32:39,440 --> 00:32:41,200
sequences they don't have any guidance

879
00:32:41,200 --> 00:32:44,159
function like software fastest do

880
00:32:44,159 --> 00:32:46,320
super specialized

881
00:32:46,320 --> 00:32:48,320
they're not the only specialized fuzzes

882
00:32:48,320 --> 00:32:51,120
so we have more specialized cpu fuzzers

883
00:32:51,120 --> 00:32:53,600
there's like sand sifter finding

884
00:32:53,600 --> 00:32:56,720
undocumented x86 instruction absinthe

885
00:32:56,720 --> 00:32:59,840
finding contention on the same core

886
00:32:59,840 --> 00:33:02,000
both authors of these fuzzers now work

887
00:33:02,000 --> 00:33:05,279
for intel there is fast spec that tries

888
00:33:05,279 --> 00:33:07,519
to find spectre variants with neural

889
00:33:07,519 --> 00:33:09,919
networks or crosstalk that tries to find

890
00:33:09,919 --> 00:33:12,399
cross-court transient execution attacks

891
00:33:12,399 --> 00:33:14,080
and all of these fuzzers are quite

892
00:33:14,080 --> 00:33:14,960
simple

893
00:33:14,960 --> 00:33:18,559
and still they found a lot of things

894
00:33:18,559 --> 00:33:21,039
mostly low hanging fruit

895
00:33:21,039 --> 00:33:23,760
but still they find things and if these

896
00:33:23,760 --> 00:33:25,760
simple fusses already find

897
00:33:25,760 --> 00:33:28,240
vulnerabilities and problems

898
00:33:28,240 --> 00:33:30,240
yeah well then we can imagine

899
00:33:30,240 --> 00:33:31,919
that we need a bit of more research and

900
00:33:31,919 --> 00:33:34,480
i can find more complex things because

901
00:33:34,480 --> 00:33:35,440
now

902
00:33:35,440 --> 00:33:37,360
they are as sophisticated as software

903
00:33:37,360 --> 00:33:40,320
fuzzes in the year 1990

904
00:33:40,320 --> 00:33:43,200
so this is really really bad but it

905
00:33:43,200 --> 00:33:46,159
showed that even these bad fuzzers are

906
00:33:46,159 --> 00:33:49,200
good enough to find things within hours

907
00:33:49,200 --> 00:33:51,760
on multiple cpus from side channel to

908
00:33:51,760 --> 00:33:54,640
vulnerabilities in my prediction

909
00:33:54,640 --> 00:33:56,880
they will get smarter and then they will

910
00:33:56,880 --> 00:33:59,600
find a lot more vulnerabilities in our

911
00:33:59,600 --> 00:34:01,279
hardware

912
00:34:01,279 --> 00:34:03,519
so if you want to play around with that

913
00:34:03,519 --> 00:34:05,840
our fuzzes are open source you find them

914
00:34:05,840 --> 00:34:08,800
on github they also have papers with

915
00:34:08,800 --> 00:34:11,040
them that explain the concepts

916
00:34:11,040 --> 00:34:12,960
so check them out if you want to have

917
00:34:12,960 --> 00:34:14,639
some more information or write me an

918
00:34:14,639 --> 00:34:15,520
email

919
00:34:15,520 --> 00:34:17,679
and with that i can only say

920
00:34:17,679 --> 00:34:20,800
yes fuss all the things and trying to

921
00:34:20,800 --> 00:34:23,520
find some new vulnerabilities to make

922
00:34:23,520 --> 00:34:27,359
our systems in the end a lot more secure

923
00:34:27,359 --> 00:34:29,760
and that's from my side

924
00:34:29,760 --> 00:34:34,800
so thanks for your attention here

925
00:34:34,800 --> 00:34:37,520
thank you michael it was amazing uh and

926
00:34:37,520 --> 00:34:40,879
yes fuzz all things guys uh

927
00:34:40,879 --> 00:34:43,280
time for questions friends if you have

928
00:34:43,280 --> 00:34:45,199
any questions please send them across

929
00:34:45,199 --> 00:34:48,000
the zoom chat uh i will read them out

930
00:34:48,000 --> 00:34:50,560
for michael

931
00:35:00,960 --> 00:35:02,480
either michael you have fuzzed

932
00:35:02,480 --> 00:35:04,880
everybody's brains out or they are still

933
00:35:04,880 --> 00:35:07,680
confused or to question you

934
00:35:07,680 --> 00:35:08,800
yes

935
00:35:08,800 --> 00:35:10,720
uh could you okay uh could you share the

936
00:35:10,720 --> 00:35:13,839
guitar links um let me

937
00:35:13,839 --> 00:35:17,839
sorry i ended up too early here

938
00:35:18,400 --> 00:35:19,920
um

939
00:35:19,920 --> 00:35:20,960
yes

940
00:35:20,960 --> 00:35:22,000
that

941
00:35:22,000 --> 00:35:25,040
i know it was quite a lot of content

942
00:35:25,040 --> 00:35:28,480
to compress that into 30 minutes

943
00:35:28,480 --> 00:35:31,200
but i hope that the

944
00:35:31,200 --> 00:35:33,680
papers are helpful and also the software

945
00:35:33,680 --> 00:35:35,520
some of the things can basically run out

946
00:35:35,520 --> 00:35:37,200
of the box

947
00:35:37,200 --> 00:35:38,960
and you will see

948
00:35:38,960 --> 00:35:42,320
quite some nice results then

949
00:35:42,320 --> 00:35:44,720
so uh i have a question in the meantime

950
00:35:44,720 --> 00:35:47,040
uh michael you know you've listed i

951
00:35:47,040 --> 00:35:50,480
think four fuzzers uh which are used for

952
00:35:50,480 --> 00:35:52,480
cpu uh fuzzing

953
00:35:52,480 --> 00:35:53,839
uh

954
00:35:53,839 --> 00:35:56,160
i'm sure these open source tools have

955
00:35:56,160 --> 00:36:00,160
been also used by uh oems uh and

956
00:36:00,160 --> 00:36:02,160
hardware vendors right

957
00:36:02,160 --> 00:36:03,359
but still

958
00:36:03,359 --> 00:36:05,200
we still uh

959
00:36:05,200 --> 00:36:07,680
they miss some bugs what is the reason

960
00:36:07,680 --> 00:36:09,599
do you do you think it's lack of

961
00:36:09,599 --> 00:36:12,000
knowledge or you know what is the reason

962
00:36:12,000 --> 00:36:13,680
it could be

963
00:36:13,680 --> 00:36:16,320
so right now so for these fuzzers the

964
00:36:16,320 --> 00:36:19,119
problem is that they are quite simple

965
00:36:19,119 --> 00:36:20,640
and they

966
00:36:20,640 --> 00:36:21,920
they don't really have this this

967
00:36:21,920 --> 00:36:24,079
guidance there so in software fastest we

968
00:36:24,079 --> 00:36:26,720
instrument the software and then the

969
00:36:26,720 --> 00:36:28,720
father sees like okay i've explored this

970
00:36:28,720 --> 00:36:31,200
part of the software this part here and

971
00:36:31,200 --> 00:36:33,359
it can optimize

972
00:36:33,359 --> 00:36:35,440
the input generation

973
00:36:35,440 --> 00:36:36,960
for hardware we don't really have that

974
00:36:36,960 --> 00:36:39,599
so we are basically

975
00:36:39,599 --> 00:36:40,560
looking

976
00:36:40,560 --> 00:36:43,920
at the like box there and then trying to

977
00:36:43,920 --> 00:36:45,520
figure out

978
00:36:45,520 --> 00:36:47,520
what's going on there and then just

979
00:36:47,520 --> 00:36:50,240
randomly generating code hoping that we

980
00:36:50,240 --> 00:36:52,079
trigger something

981
00:36:52,079 --> 00:36:54,400
that we haven't seen before uh so that

982
00:36:54,400 --> 00:36:57,359
makes it a lot slower and there's also

983
00:36:57,359 --> 00:36:59,599
quite a complex interaction of all these

984
00:36:59,599 --> 00:37:01,440
elements involved

985
00:37:01,440 --> 00:37:04,960
so we can consider a cpu as a super

986
00:37:04,960 --> 00:37:07,119
complex software project

987
00:37:07,119 --> 00:37:09,280
because true i understand

988
00:37:09,280 --> 00:37:11,200
cpus are written in in hardware

989
00:37:11,200 --> 00:37:12,800
description languages

990
00:37:12,800 --> 00:37:15,200
so it's also software yeah it makes

991
00:37:15,200 --> 00:37:17,200
sense that we have like the same

992
00:37:17,200 --> 00:37:19,760
marks as when we write other software

993
00:37:19,760 --> 00:37:21,599
of course they manifest itself in a

994
00:37:21,599 --> 00:37:23,119
different way

995
00:37:23,119 --> 00:37:23,920
and

996
00:37:23,920 --> 00:37:25,920
easy bugs will be prevented with

997
00:37:25,920 --> 00:37:28,240
verification tools and a lot of testing

998
00:37:28,240 --> 00:37:31,040
during development already

999
00:37:31,040 --> 00:37:33,040
but some complex bugs caused by

1000
00:37:33,040 --> 00:37:36,400
interactions as we see in cpus this is

1001
00:37:36,400 --> 00:37:37,680
really hard

1002
00:37:37,680 --> 00:37:41,040
to to find them and and search for them

1003
00:37:41,040 --> 00:37:44,400
and also fuzzing yes it takes a while we

1004
00:37:44,400 --> 00:37:46,320
also see that in software

1005
00:37:46,320 --> 00:37:50,079
google is fuzzing chrome 24 7 on i don't

1006
00:37:50,079 --> 00:37:51,839
know how many machines on their entire

1007
00:37:51,839 --> 00:37:53,359
key out

1008
00:37:53,359 --> 00:37:55,760
and yes they find bugs and still there

1009
00:37:55,760 --> 00:37:58,079
are bugs left in the browsers and

1010
00:37:58,079 --> 00:37:58,880
the

1011
00:37:58,880 --> 00:38:01,680
all the time people find bugs with

1012
00:38:01,680 --> 00:38:04,079
different approaches smarter fuzzes

1013
00:38:04,079 --> 00:38:06,480
so yes it's it looks a bit like a cat

1014
00:38:06,480 --> 00:38:09,359
and mouse game so we improve the methods

1015
00:38:09,359 --> 00:38:11,200
for finding vulnerabilities then we fix

1016
00:38:11,200 --> 00:38:13,440
all of them the vendors use them fix

1017
00:38:13,440 --> 00:38:15,200
most of them then researchers come up

1018
00:38:15,200 --> 00:38:16,800
with new

1019
00:38:16,800 --> 00:38:18,960
variants for finding bugs

1020
00:38:18,960 --> 00:38:21,520
it looks like a never-ending circle

1021
00:38:21,520 --> 00:38:24,079
it's actually more like a spiral so we

1022
00:38:24,079 --> 00:38:26,400
get more secure systems we find more

1023
00:38:26,400 --> 00:38:29,440
bugs we get rid of the low-hanging fruit

1024
00:38:29,440 --> 00:38:30,320
and

1025
00:38:30,320 --> 00:38:33,040
yes it just will take

1026
00:38:33,040 --> 00:38:35,520
more years more research to

1027
00:38:35,520 --> 00:38:37,280
actually have that also

1028
00:38:37,280 --> 00:38:39,200
in the entire process

1029
00:38:39,200 --> 00:38:42,079
and and find more bugs before we deploy

1030
00:38:42,079 --> 00:38:44,640
uh cpus and then hopefully they're more

1031
00:38:44,640 --> 00:38:46,800
secure and it's not that easy to find

1032
00:38:46,800 --> 00:38:49,520
such vulnerabilities again

1033
00:38:49,520 --> 00:38:51,280
yeah i guess we have to innovate our

1034
00:38:51,280 --> 00:38:53,920
fuzzers okay we have a question uh

1035
00:38:53,920 --> 00:38:55,280
michael for you

1036
00:38:55,280 --> 00:38:57,440
uh

1037
00:38:57,440 --> 00:38:59,599
can you think of any incremental

1038
00:38:59,599 --> 00:39:02,960
feedback for cpu fuzzers that is not

1039
00:39:02,960 --> 00:39:05,280
leak no uh

1040
00:39:05,280 --> 00:39:07,359
and then i think he has a statement

1041
00:39:07,359 --> 00:39:09,599
maybe leveraging performance counters or

1042
00:39:09,599 --> 00:39:11,520
something similar

1043
00:39:11,520 --> 00:39:13,040
yes um

1044
00:39:13,040 --> 00:39:15,599
so this uh this is something

1045
00:39:15,599 --> 00:39:18,079
that looks quite promising performance

1046
00:39:18,079 --> 00:39:20,320
counters can already provide some sort

1047
00:39:20,320 --> 00:39:21,760
of guidance

1048
00:39:21,760 --> 00:39:23,760
when you see which elements of the cpu

1049
00:39:23,760 --> 00:39:26,240
are involved when we execute codes

1050
00:39:26,240 --> 00:39:28,960
but it could also be more invasive

1051
00:39:28,960 --> 00:39:32,000
i can think of like debug interfaces

1052
00:39:32,000 --> 00:39:33,920
uh if you have access to them maybe

1053
00:39:33,920 --> 00:39:36,400
because we are a vendor or work together

1054
00:39:36,400 --> 00:39:37,760
with a vendor or

1055
00:39:37,760 --> 00:39:40,880
someone exploited like a cpu interface

1056
00:39:40,880 --> 00:39:43,040
i've also seen that

1057
00:39:43,040 --> 00:39:45,839
then this can also help to see better

1058
00:39:45,839 --> 00:39:47,680
what is going on in the cpu use these

1059
00:39:47,680 --> 00:39:50,480
debug interfaces to get some kind of

1060
00:39:50,480 --> 00:39:51,839
guidance

1061
00:39:51,839 --> 00:39:53,920
all the other side channel attacks could

1062
00:39:53,920 --> 00:39:56,000
be used as guidance so we can see like

1063
00:39:56,000 --> 00:39:58,079
is the cache currently active

1064
00:39:58,079 --> 00:40:00,640
is the tlb active so we can again then

1065
00:40:00,640 --> 00:40:02,560
use side channel attacks or transient

1066
00:40:02,560 --> 00:40:04,720
execution attacks to see what is going

1067
00:40:04,720 --> 00:40:07,599
on in the cpu and use that as guidance

1068
00:40:07,599 --> 00:40:09,760
but this is all still

1069
00:40:09,760 --> 00:40:11,200
open research

1070
00:40:11,200 --> 00:40:14,160
and yes if you have ideas about that

1071
00:40:14,160 --> 00:40:17,839
feel free to contact me

1072
00:40:18,000 --> 00:40:19,839
all right thank you

1073
00:40:19,839 --> 00:40:22,079
michael there's one more question

1074
00:40:22,079 --> 00:40:24,160
do you use any special list of

1075
00:40:24,160 --> 00:40:26,079
instructions for the fuzzer

1076
00:40:26,079 --> 00:40:29,359
i mean you mentioned stan sifter

1077
00:40:29,359 --> 00:40:30,079
and

1078
00:40:30,079 --> 00:40:31,839
uh san they provide a list of

1079
00:40:31,839 --> 00:40:34,160
instructions is there any other way

1080
00:40:34,160 --> 00:40:36,079
you find probably undocumented

1081
00:40:36,079 --> 00:40:38,160
instructions and create a list of valid

1082
00:40:38,160 --> 00:40:40,079
instructions

1083
00:40:40,079 --> 00:40:41,119
so

1084
00:40:41,119 --> 00:40:44,079
what we did is we only relied on

1085
00:40:44,079 --> 00:40:46,400
documented instructions

1086
00:40:46,400 --> 00:40:47,839
so there's like an

1087
00:40:47,839 --> 00:40:50,160
either description for example europe's

1088
00:40:50,160 --> 00:40:52,079
info that contains all the instruction

1089
00:40:52,079 --> 00:40:54,480
with all possible

1090
00:40:54,480 --> 00:40:55,920
parameters like

1091
00:40:55,920 --> 00:40:57,920
register register register memory and so

1092
00:40:57,920 --> 00:41:01,680
on and we write rela we sorry we relied

1093
00:41:01,680 --> 00:41:03,760
on such a list with all the documented

1094
00:41:03,760 --> 00:41:06,640
instructions and only use them of course

1095
00:41:06,640 --> 00:41:08,800
undocumented instructions would also be

1096
00:41:08,800 --> 00:41:11,119
super interesting and as you mentioned

1097
00:41:11,119 --> 00:41:12,480
since if them

1098
00:41:12,480 --> 00:41:14,800
there are undocumented instructions so

1099
00:41:14,800 --> 00:41:17,280
it could also be interesting to add them

1100
00:41:17,280 --> 00:41:20,240
to the fuzzer and see if they have some

1101
00:41:20,240 --> 00:41:21,599
interference

1102
00:41:21,599 --> 00:41:22,560
with

1103
00:41:22,560 --> 00:41:24,880
documented instruction with each other

1104
00:41:24,880 --> 00:41:26,319
or also

1105
00:41:26,319 --> 00:41:29,119
allows them transient execution variants

1106
00:41:29,119 --> 00:41:30,560
that rely on these undocumented

1107
00:41:30,560 --> 00:41:32,880
instructions but we have not done that

1108
00:41:32,880 --> 00:41:36,880
that's interesting future work

1109
00:41:41,040 --> 00:41:42,400
okay

1110
00:41:42,400 --> 00:41:45,040
uh i think that's it for the questions

1111
00:41:45,040 --> 00:41:47,200
friends thank you so much and thank you

1112
00:41:47,200 --> 00:41:49,760
michael for sharing uh this presentation

1113
00:41:49,760 --> 00:41:50,960
with us

1114
00:41:50,960 --> 00:41:52,880
once again thank you michael and let's

1115
00:41:52,880 --> 00:41:54,400
fuzz all things

1116
00:41:54,400 --> 00:41:56,000
thanks for the invitation thanks for all

1117
00:41:56,000 --> 00:41:58,079
the interesting questions you also asked

1118
00:41:58,079 --> 00:41:59,040
them

1119
00:41:59,040 --> 00:42:01,359
thanks have a nice day thank you guys

1120
00:42:01,359 --> 00:42:04,359
bye

