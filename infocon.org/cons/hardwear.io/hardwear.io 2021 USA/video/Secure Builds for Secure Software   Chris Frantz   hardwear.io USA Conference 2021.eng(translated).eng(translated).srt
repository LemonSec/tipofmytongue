1
00:00:03,410 --> 00:00:05,200
[Music]

2
00:00:05,200 --> 00:00:06,770
[Applause]

3
00:00:06,770 --> 00:00:08,029
[Music]

4
00:00:08,029 --> 00:00:11,179
[Applause]

5
00:00:12,719 --> 00:00:14,480
the second talk of the day by chris

6
00:00:14,480 --> 00:00:16,960
franz who is a site reliability engineer

7
00:00:16,960 --> 00:00:19,760
at google open title project chris will

8
00:00:19,760 --> 00:00:21,840
be revealing exclusive technical details

9
00:00:21,840 --> 00:00:24,320
about the google open titan a project

10
00:00:24,320 --> 00:00:26,480
used by millions around the globe his

11
00:00:26,480 --> 00:00:29,199
talk title is secure bills for secure

12
00:00:29,199 --> 00:00:31,599
software i believe this project was also

13
00:00:31,599 --> 00:00:33,840
recently mentioned by colin in the his

14
00:00:33,840 --> 00:00:39,320
keynote today so yeah over to you chris

15
00:00:57,440 --> 00:00:59,510
all right

16
00:00:59,510 --> 00:01:02,699
[Music]

17
00:01:02,879 --> 00:01:04,879
oops

18
00:01:04,879 --> 00:01:07,680
i am yes we can see your screen

19
00:01:07,680 --> 00:01:09,760
okay can you hear me

20
00:01:09,760 --> 00:01:12,479
absolutely we can hear you as well okay

21
00:01:12,479 --> 00:01:13,520
good

22
00:01:13,520 --> 00:01:16,080
i am chris franz i'm the software lead

23
00:01:16,080 --> 00:01:18,000
for the open titan project

24
00:01:18,000 --> 00:01:20,000
and

25
00:01:20,000 --> 00:01:22,320
my talk is about how to build

26
00:01:22,320 --> 00:01:25,840
uh how to securely build software for

27
00:01:25,840 --> 00:01:29,360
your secure devices

28
00:01:29,840 --> 00:01:33,119
so i'll give a brief introduction to the

29
00:01:33,119 --> 00:01:35,200
open titan project

30
00:01:35,200 --> 00:01:37,360
and kind of what what the problem

31
00:01:37,360 --> 00:01:40,320
is that we're trying to solve with with

32
00:01:40,320 --> 00:01:42,399
our software builds

33
00:01:42,399 --> 00:01:45,840
why specifically open titan cares

34
00:01:45,840 --> 00:01:47,439
and how

35
00:01:47,439 --> 00:01:51,200
open titan is going to get to a solution

36
00:01:51,200 --> 00:01:52,880
that solves the problems that will be

37
00:01:52,880 --> 00:01:55,840
laid out in the problem statement

38
00:01:55,840 --> 00:01:58,000
so

39
00:01:58,079 --> 00:02:00,560
let's start with the introduction to

40
00:02:00,560 --> 00:02:03,200
open titan

41
00:02:04,079 --> 00:02:06,880
so the open titan project is a open

42
00:02:06,880 --> 00:02:09,360
source hardware project that is focused

43
00:02:09,360 --> 00:02:10,720
on building

44
00:02:10,720 --> 00:02:13,360
a high quality transparent and vendor

45
00:02:13,360 --> 00:02:17,840
agnostic secure silicon root of trust

46
00:02:18,080 --> 00:02:19,680
open source nature

47
00:02:19,680 --> 00:02:22,480
of this project

48
00:02:22,480 --> 00:02:24,160
allows anyone

49
00:02:24,160 --> 00:02:26,959
in the larger community and i think

50
00:02:26,959 --> 00:02:28,640
that really means anyone

51
00:02:28,640 --> 00:02:31,040
to evaluate and audit the security

52
00:02:31,040 --> 00:02:34,480
properties of the design

53
00:02:34,480 --> 00:02:35,280
so

54
00:02:35,280 --> 00:02:37,519
just as a quick inventory of what's in

55
00:02:37,519 --> 00:02:40,080
the chip there's a cpu

56
00:02:40,080 --> 00:02:42,560
rom flash ram

57
00:02:42,560 --> 00:02:45,200
and a bunch of internal peripherals that

58
00:02:45,200 --> 00:02:46,239
assist

59
00:02:46,239 --> 00:02:48,080
with the operations that a typical root

60
00:02:48,080 --> 00:02:49,599
of trust chip

61
00:02:49,599 --> 00:02:51,120
would do such as

62
00:02:51,120 --> 00:02:53,120
key derivation or hashing or

63
00:02:53,120 --> 00:02:56,080
cryptography and as colin alluded to in

64
00:02:56,080 --> 00:02:58,319
his his presentation there there are

65
00:02:58,319 --> 00:03:00,239
quite a few interesting blocks inside

66
00:03:00,239 --> 00:03:01,599
like a you know

67
00:03:01,599 --> 00:03:05,839
our aes accelerator and so forth

68
00:03:06,080 --> 00:03:08,560
the design of the open titan chip is

69
00:03:08,560 --> 00:03:10,720
compatible with fips

70
00:03:10,720 --> 00:03:13,360
and common criteria certification

71
00:03:13,360 --> 00:03:14,319
so

72
00:03:14,319 --> 00:03:16,959
part of the focus on

73
00:03:16,959 --> 00:03:19,440
being able to fill the software

74
00:03:19,440 --> 00:03:21,200
is uh

75
00:03:21,200 --> 00:03:24,000
is sort of centered around what do we

76
00:03:24,000 --> 00:03:26,319
need to do to make uh certification

77
00:03:26,319 --> 00:03:28,720
easier

78
00:03:29,680 --> 00:03:30,560
so

79
00:03:30,560 --> 00:03:33,120
a little bit more background um

80
00:03:33,120 --> 00:03:35,200
although the you know the design is for

81
00:03:35,200 --> 00:03:37,760
hardware um the trust rooted in the

82
00:03:37,760 --> 00:03:38,959
hardware

83
00:03:38,959 --> 00:03:40,879
it's really only valuable

84
00:03:40,879 --> 00:03:43,360
if the chip can securely boot

85
00:03:43,360 --> 00:03:45,599
uh the software stack

86
00:03:45,599 --> 00:03:46,879
so

87
00:03:46,879 --> 00:03:48,799
in open titan's terminology there's

88
00:03:48,799 --> 00:03:50,799
there are two kinds of code that run in

89
00:03:50,799 --> 00:03:52,560
the chip there's something called

90
00:03:52,560 --> 00:03:55,840
creator code and owner code

91
00:03:55,840 --> 00:03:58,480
the creator code is effectively the rom

92
00:03:58,480 --> 00:04:01,280
and so this is this is the code that

93
00:04:01,280 --> 00:04:03,200
is responsible for securely booting the

94
00:04:03,200 --> 00:04:04,000
chip

95
00:04:04,000 --> 00:04:06,560
um initializing the internal hardware ip

96
00:04:06,560 --> 00:04:08,239
blocks

97
00:04:08,239 --> 00:04:11,120
managing owner secrets and then securely

98
00:04:11,120 --> 00:04:14,480
handing off execution to a validated

99
00:04:14,480 --> 00:04:15,599
owner

100
00:04:15,599 --> 00:04:17,920
code

101
00:04:18,320 --> 00:04:20,959
the creator code consists both of the

102
00:04:20,959 --> 00:04:22,800
mask rom and then something that we

103
00:04:22,800 --> 00:04:24,720
refer to as the rom extension which is

104
00:04:24,720 --> 00:04:27,360
located in flash

105
00:04:27,360 --> 00:04:29,919
both of these artifacts are built

106
00:04:29,919 --> 00:04:32,800
um solely from open code that's in our

107
00:04:32,800 --> 00:04:34,400
repository

108
00:04:34,400 --> 00:04:36,320
and their their transparency and

109
00:04:36,320 --> 00:04:38,479
auditability are what guarantee the boot

110
00:04:38,479 --> 00:04:40,800
time security properties of the chip

111
00:04:40,800 --> 00:04:43,520
or guarantee them to the owner

112
00:04:43,520 --> 00:04:44,800
so

113
00:04:44,800 --> 00:04:46,560
to recapitulate what was on the last

114
00:04:46,560 --> 00:04:48,000
slide um

115
00:04:48,000 --> 00:04:50,000
as an owner of a chip

116
00:04:50,000 --> 00:04:52,400
you can examine that creator code and be

117
00:04:52,400 --> 00:04:54,800
confident that you really are the owner

118
00:04:54,800 --> 00:04:57,120
of the chip that the chip is delivering

119
00:04:57,120 --> 00:04:59,280
to you the security properties as

120
00:04:59,280 --> 00:05:00,880
advertised

121
00:05:00,880 --> 00:05:02,960
that you know there's no

122
00:05:02,960 --> 00:05:05,520
there's no leap of faith you can you can

123
00:05:05,520 --> 00:05:07,759
see everything that runs

124
00:05:07,759 --> 00:05:10,479
before your owner code and you can be

125
00:05:10,479 --> 00:05:13,120
confident that it's initialize the chip

126
00:05:13,120 --> 00:05:15,759
as we said

127
00:05:16,880 --> 00:05:18,080
so

128
00:05:18,080 --> 00:05:18,880
um

129
00:05:18,880 --> 00:05:21,199
why don't we then focus on you know what

130
00:05:21,199 --> 00:05:24,160
what exactly is is the problem and the

131
00:05:24,160 --> 00:05:25,199
problem is

132
00:05:25,199 --> 00:05:27,039
what actually happens when you when you

133
00:05:27,039 --> 00:05:29,759
build the project and

134
00:05:29,759 --> 00:05:31,440
in particular here like what happens

135
00:05:31,440 --> 00:05:32,800
when you build the software for your

136
00:05:32,800 --> 00:05:34,400
project and the

137
00:05:34,400 --> 00:05:36,400
the first order answer is that you type

138
00:05:36,400 --> 00:05:38,720
make all or you know

139
00:05:38,720 --> 00:05:40,639
name your your build system you you know

140
00:05:40,639 --> 00:05:42,560
you invoke this command

141
00:05:42,560 --> 00:05:44,320
and build system

142
00:05:44,320 --> 00:05:45,759
compiles all the code and links it

143
00:05:45,759 --> 00:05:46,880
together

144
00:05:46,880 --> 00:05:48,000
um but

145
00:05:48,000 --> 00:05:49,280
there's a whole bunch of questions you

146
00:05:49,280 --> 00:05:50,880
need to ask yourself

147
00:05:50,880 --> 00:05:55,120
um you know when you build but you know

148
00:05:55,120 --> 00:05:57,759
first of which is which compiler runs

149
00:05:57,759 --> 00:05:59,840
which version of that compiler where did

150
00:05:59,840 --> 00:06:01,440
it come from

151
00:06:01,440 --> 00:06:03,919
what are the tools run

152
00:06:03,919 --> 00:06:06,479
where did they come from within the

153
00:06:06,479 --> 00:06:07,759
project

154
00:06:07,759 --> 00:06:09,280
what are you know what are the

155
00:06:09,280 --> 00:06:11,039
dependency relationships between your

156
00:06:11,039 --> 00:06:13,280
modules properly maintained and can you

157
00:06:13,280 --> 00:06:15,840
even tell

158
00:06:16,000 --> 00:06:17,919
does your code depend on any system

159
00:06:17,919 --> 00:06:20,400
libraries headers or other resources

160
00:06:20,400 --> 00:06:22,080
and how did those get installed does

161
00:06:22,080 --> 00:06:23,600
every developer have the exact same

162
00:06:23,600 --> 00:06:25,520
version installed

163
00:06:25,520 --> 00:06:27,280
what third-party libraries do you depend

164
00:06:27,280 --> 00:06:29,840
on where did those come from how do you

165
00:06:29,840 --> 00:06:30,880
know

166
00:06:30,880 --> 00:06:32,800
or how do you know that they're

167
00:06:32,800 --> 00:06:34,160
precisely the version that you've

168
00:06:34,160 --> 00:06:35,520
intended

169
00:06:35,520 --> 00:06:37,120
does any information about your

170
00:06:37,120 --> 00:06:39,199
environment leak into the build you know

171
00:06:39,199 --> 00:06:40,560
we've we've

172
00:06:40,560 --> 00:06:42,880
we've all seen you know linux kernel

173
00:06:42,880 --> 00:06:44,880
boots and that it names the person who

174
00:06:44,880 --> 00:06:46,240
built it and

175
00:06:46,240 --> 00:06:47,680
occasionally it's a funny name and we

176
00:06:47,680 --> 00:06:51,360
all snicker at it but um

177
00:06:51,680 --> 00:06:53,120
this is really kind of important you

178
00:06:53,120 --> 00:06:54,880
know does does this information leak

179
00:06:54,880 --> 00:06:56,160
into the build

180
00:06:56,160 --> 00:06:58,639
um and did you intend it to

181
00:06:58,639 --> 00:07:00,240
and lastly

182
00:07:00,240 --> 00:07:02,880
is your build reproducible um you know

183
00:07:02,880 --> 00:07:04,800
can can two developers working on the

184
00:07:04,800 --> 00:07:05,840
project

185
00:07:05,840 --> 00:07:08,000
check out the same version

186
00:07:08,000 --> 00:07:10,639
run the build and get binary identical

187
00:07:10,639 --> 00:07:12,479
artifacts um

188
00:07:12,479 --> 00:07:13,199
and

189
00:07:13,199 --> 00:07:14,160
really

190
00:07:14,160 --> 00:07:16,240
for the purpose of open titan i i think

191
00:07:16,240 --> 00:07:18,800
that this this last bit is kind of the

192
00:07:18,800 --> 00:07:21,039
the most important bit is

193
00:07:21,039 --> 00:07:23,120
you know because we're making these

194
00:07:23,120 --> 00:07:25,199
guarantees about about the security of

195
00:07:25,199 --> 00:07:26,639
the chip

196
00:07:26,639 --> 00:07:28,880
and there's uh you know the rom and rom

197
00:07:28,880 --> 00:07:31,120
extension are built from

198
00:07:31,120 --> 00:07:34,639
uh purely from code in our repository

199
00:07:34,639 --> 00:07:36,319
anybody ought to check at be able to

200
00:07:36,319 --> 00:07:38,479
check out a particular version and run

201
00:07:38,479 --> 00:07:41,120
the build and get the binary artifacts

202
00:07:41,120 --> 00:07:42,080
that

203
00:07:42,080 --> 00:07:43,440
that we

204
00:07:43,440 --> 00:07:47,120
as creators uh produced

205
00:07:47,120 --> 00:07:48,080
so

206
00:07:48,080 --> 00:07:50,240
um

207
00:07:50,240 --> 00:07:52,319
you know this sort of why does open

208
00:07:52,319 --> 00:07:54,319
titan care and i may have

209
00:07:54,319 --> 00:07:55,120
maybe

210
00:07:55,120 --> 00:07:57,280
jumped ahead a bit in my

211
00:07:57,280 --> 00:08:00,639
uh bit on the last slide but we want to

212
00:08:00,639 --> 00:08:03,599
basically hermetically build

213
00:08:03,599 --> 00:08:05,199
uh

214
00:08:05,199 --> 00:08:06,879
uh reproducible

215
00:08:06,879 --> 00:08:08,960
build artifacts

216
00:08:08,960 --> 00:08:11,199
i'm sorry i stumbled over this is the

217
00:08:11,199 --> 00:08:12,400
wording on the slide

218
00:08:12,400 --> 00:08:14,560
we want her medically built reproducible

219
00:08:14,560 --> 00:08:17,199
build artifacts precisely because we're

220
00:08:17,199 --> 00:08:18,879
building an open source silicon root of

221
00:08:18,879 --> 00:08:19,919
trust

222
00:08:19,919 --> 00:08:21,520
we want to be confident that we know

223
00:08:21,520 --> 00:08:23,680
exactly what went into the construction

224
00:08:23,680 --> 00:08:26,319
of the mass crown and the rom extension

225
00:08:26,319 --> 00:08:28,479
we want auditors to be able to inspect

226
00:08:28,479 --> 00:08:30,400
and audit the code in the mask rom and

227
00:08:30,400 --> 00:08:32,080
the rom extension

228
00:08:32,080 --> 00:08:33,679
we want them to be able to exactly

229
00:08:33,679 --> 00:08:36,159
reproduce the same artifacts that we as

230
00:08:36,159 --> 00:08:37,760
part of the silicon creator group

231
00:08:37,760 --> 00:08:39,440
produce

232
00:08:39,440 --> 00:08:41,599
and

233
00:08:41,599 --> 00:08:43,519
as an open source project you know that

234
00:08:43,519 --> 00:08:45,600
this

235
00:08:45,600 --> 00:08:47,760
these bits of code are the guarantee

236
00:08:47,760 --> 00:08:50,160
that the chip has the properties that we

237
00:08:50,160 --> 00:08:51,360
say

238
00:08:51,360 --> 00:08:52,320
um

239
00:08:52,320 --> 00:08:54,480
so and just to be clear in this context

240
00:08:54,480 --> 00:08:56,480
when i refer to auditors

241
00:08:56,480 --> 00:08:58,480
um

242
00:08:58,480 --> 00:09:01,440
i mean professional auditors like folks

243
00:09:01,440 --> 00:09:02,560
that would help you through the

244
00:09:02,560 --> 00:09:04,880
certification process

245
00:09:04,880 --> 00:09:07,519
customers of the chip itself

246
00:09:07,519 --> 00:09:10,399
so silicon owners to use the terminology

247
00:09:10,399 --> 00:09:12,560
in one of the prior slides

248
00:09:12,560 --> 00:09:15,360
and members of the open source community

249
00:09:15,360 --> 00:09:16,240
so

250
00:09:16,240 --> 00:09:17,279
really

251
00:09:17,279 --> 00:09:18,240
anyone

252
00:09:18,240 --> 00:09:20,800
who cares or is interested ought to be

253
00:09:20,800 --> 00:09:23,680
able to get the same artifacts that we

254
00:09:23,680 --> 00:09:26,160
produce

255
00:09:26,959 --> 00:09:29,040
so let's let's look at an example of an

256
00:09:29,040 --> 00:09:32,080
actual build failure that we experienced

257
00:09:32,080 --> 00:09:34,959
in in the project

258
00:09:34,959 --> 00:09:37,200
there's a there's an issue that's part

259
00:09:37,200 --> 00:09:39,200
of our our github

260
00:09:39,200 --> 00:09:42,640
that uh was a real bill failure and uh

261
00:09:42,640 --> 00:09:44,480
the person who discovered this uh

262
00:09:44,480 --> 00:09:47,360
reported in the bug quote i suspect this

263
00:09:47,360 --> 00:09:49,200
is a build system dependency error

264
00:09:49,200 --> 00:09:51,120
because if i run

265
00:09:51,120 --> 00:09:54,320
the command ninja dash c etc enough

266
00:09:54,320 --> 00:09:56,480
times that eventually

267
00:09:56,480 --> 00:09:58,880
the build converges and from there

268
00:09:58,880 --> 00:10:02,000
it can run the test command successfully

269
00:10:02,000 --> 00:10:03,360
and

270
00:10:03,360 --> 00:10:04,560
the the

271
00:10:04,560 --> 00:10:06,480
investigation showed that this in fact

272
00:10:06,480 --> 00:10:09,440
was an error in the build configuration

273
00:10:09,440 --> 00:10:11,120
where uh

274
00:10:11,120 --> 00:10:13,839
we accidentally admitted uh a reference

275
00:10:13,839 --> 00:10:16,320
to an auto-generated header file

276
00:10:16,320 --> 00:10:19,760
um that is a dependency to one of the

277
00:10:19,760 --> 00:10:23,040
the mask round unit um modules

278
00:10:23,040 --> 00:10:24,880
so

279
00:10:24,880 --> 00:10:27,279
this is

280
00:10:27,760 --> 00:10:30,240
this is kind of a you know it's a simple

281
00:10:30,240 --> 00:10:32,720
but i think effective demonstrator of

282
00:10:32,720 --> 00:10:35,600
something that that can go wrong um

283
00:10:35,600 --> 00:10:36,399
and

284
00:10:36,399 --> 00:10:38,800
you know eventual consistency is not

285
00:10:38,800 --> 00:10:40,399
really a desirable property in your

286
00:10:40,399 --> 00:10:42,240
build system um

287
00:10:42,240 --> 00:10:44,000
and you know to paraphrase the green

288
00:10:44,000 --> 00:10:47,839
puppet from a famous film franchise um

289
00:10:47,839 --> 00:10:50,240
either you should build or do not build

290
00:10:50,240 --> 00:10:53,360
there's no try again

291
00:10:53,360 --> 00:10:55,519
although we all know everyone

292
00:10:55,519 --> 00:10:57,440
will try again after they i think

293
00:10:57,440 --> 00:11:01,519
they've worked out the error um but

294
00:11:01,519 --> 00:11:04,000
really this is this is kind of uh

295
00:11:04,000 --> 00:11:06,000
this isn't a simple but effective

296
00:11:06,000 --> 00:11:07,279
demonstration

297
00:11:07,279 --> 00:11:08,720
um

298
00:11:08,720 --> 00:11:11,200
so let's let's revisit our our problem

299
00:11:11,200 --> 00:11:12,800
statement you know what what should

300
00:11:12,800 --> 00:11:15,360
happen when you build your project

301
00:11:15,360 --> 00:11:16,640
um

302
00:11:16,640 --> 00:11:18,640
the build system should calculate the

303
00:11:18,640 --> 00:11:20,959
dependency relationships needed to build

304
00:11:20,959 --> 00:11:23,600
whatever it is that you requested um

305
00:11:23,600 --> 00:11:24,399
so

306
00:11:24,399 --> 00:11:25,920
in this case we're talking about the the

307
00:11:25,920 --> 00:11:28,240
monastery on the rom extension when you

308
00:11:28,240 --> 00:11:29,600
ask it to build the rom it should

309
00:11:29,600 --> 00:11:30,800
calculate all the dependency

310
00:11:30,800 --> 00:11:32,640
relationships and and figure out how to

311
00:11:32,640 --> 00:11:35,519
build the thing that you asked for

312
00:11:35,519 --> 00:11:36,959
the build system should know about your

313
00:11:36,959 --> 00:11:39,760
project's third-party dependencies and

314
00:11:39,760 --> 00:11:41,440
you know optionally should be able to go

315
00:11:41,440 --> 00:11:45,920
retrieve them on your behalf um this is

316
00:11:45,920 --> 00:11:48,079
a bit of philosophy on on how you prefer

317
00:11:48,079 --> 00:11:49,839
to configure a project you can also

318
00:11:49,839 --> 00:11:52,000
vendor in your third-party dependencies

319
00:11:52,000 --> 00:11:54,839
you know check them into your project

320
00:11:54,839 --> 00:11:56,160
um uh

321
00:11:56,160 --> 00:11:57,519
in my opinion

322
00:11:57,519 --> 00:12:00,160
um upgrading the vendor dependencies

323
00:12:00,160 --> 00:12:02,000
within your project just kind of creates

324
00:12:02,000 --> 00:12:04,000
churn um and

325
00:12:04,000 --> 00:12:05,920
if there's a better mechanism you should

326
00:12:05,920 --> 00:12:08,240
use that

327
00:12:08,240 --> 00:12:09,600
the build system should know about the

328
00:12:09,600 --> 00:12:11,200
tool chain that's needed to build your

329
00:12:11,200 --> 00:12:12,959
project and understand how to run the

330
00:12:12,959 --> 00:12:15,200
various components of the tool chain so

331
00:12:15,200 --> 00:12:16,959
you know classically this is compiler

332
00:12:16,959 --> 00:12:19,680
configuration um you know how you set up

333
00:12:19,680 --> 00:12:23,839
cc and ld in a make file for example

334
00:12:23,839 --> 00:12:25,279
the build system

335
00:12:25,279 --> 00:12:27,120
should know how to run any miscellaneous

336
00:12:27,120 --> 00:12:29,519
tools that are required by your build

337
00:12:29,519 --> 00:12:31,360
the build system should isolate and

338
00:12:31,360 --> 00:12:33,200
redact the peculiarities of your

339
00:12:33,200 --> 00:12:34,800
development environment from the build

340
00:12:34,800 --> 00:12:36,560
so like

341
00:12:36,560 --> 00:12:38,639
the name of your home directory or where

342
00:12:38,639 --> 00:12:40,399
you've you've put the source code as an

343
00:12:40,399 --> 00:12:42,959
example um you know it's pretty typical

344
00:12:42,959 --> 00:12:43,920
for

345
00:12:43,920 --> 00:12:45,600
um

346
00:12:45,600 --> 00:12:47,120
strings like that end up in the

347
00:12:47,120 --> 00:12:50,160
artifacts because uh they end up like in

348
00:12:50,160 --> 00:12:52,399
a debug section or

349
00:12:52,399 --> 00:12:54,959
or author uses you know

350
00:12:54,959 --> 00:12:58,320
the file macro in c for example um

351
00:12:58,320 --> 00:13:00,240
and given the same set of inputs the

352
00:13:00,240 --> 00:13:01,680
build system

353
00:13:01,680 --> 00:13:04,000
should reproduce the same outputs every

354
00:13:04,000 --> 00:13:05,680
single time

355
00:13:05,680 --> 00:13:07,200
so

356
00:13:07,200 --> 00:13:09,440
um

357
00:13:09,839 --> 00:13:12,800
this is kind of what we want um

358
00:13:12,800 --> 00:13:15,839
and i think just to clarify on

359
00:13:15,839 --> 00:13:18,399
what i mean by additional tooling if you

360
00:13:18,399 --> 00:13:22,480
think about uh you know scripts that uh

361
00:13:22,480 --> 00:13:26,639
maybe convert a bin file into a c hex

362
00:13:26,639 --> 00:13:28,560
dump that you can include

363
00:13:28,560 --> 00:13:29,680
or

364
00:13:29,680 --> 00:13:31,920
something that produces a version.h that

365
00:13:31,920 --> 00:13:34,959
has you know your git hash

366
00:13:34,959 --> 00:13:36,720
as part of your version

367
00:13:36,720 --> 00:13:38,959
or if you're if you're running some

368
00:13:38,959 --> 00:13:40,880
higher level code than something that's

369
00:13:40,880 --> 00:13:43,040
say strictly embedded and you need to

370
00:13:43,040 --> 00:13:44,240
use uh

371
00:13:44,240 --> 00:13:46,160
like the protobuf compiler or any other

372
00:13:46,160 --> 00:13:47,920
kind of idl compiler that that's an

373
00:13:47,920 --> 00:13:49,760
additional tool

374
00:13:49,760 --> 00:13:51,360
and your build system should know how to

375
00:13:51,360 --> 00:13:54,160
deal with those tools

376
00:13:54,160 --> 00:13:56,959
so how do we how do we get there

377
00:13:56,959 --> 00:13:58,959
um

378
00:13:58,959 --> 00:14:00,399
well let's

379
00:14:00,399 --> 00:14:02,160
you know decide you know what what

380
00:14:02,160 --> 00:14:05,120
exactly we want um we want an expressive

381
00:14:05,120 --> 00:14:06,800
representation of the build rules and

382
00:14:06,800 --> 00:14:08,320
the relationships between all the

383
00:14:08,320 --> 00:14:09,600
targets

384
00:14:09,600 --> 00:14:11,839
we want dependency management as a

385
00:14:11,839 --> 00:14:14,000
directed acyclic graph

386
00:14:14,000 --> 00:14:15,600
you should not have cycles in your

387
00:14:15,600 --> 00:14:17,839
dependencies if you do

388
00:14:17,839 --> 00:14:19,199
um

389
00:14:19,199 --> 00:14:20,480
there's something

390
00:14:20,480 --> 00:14:22,480
there's probably something wrong

391
00:14:22,480 --> 00:14:24,720
um

392
00:14:24,720 --> 00:14:26,880
you should have a mechanism

393
00:14:26,880 --> 00:14:28,880
to query the dependency relationships

394
00:14:28,880 --> 00:14:31,360
between your targets so you can know you

395
00:14:31,360 --> 00:14:33,680
know what depends on what and

396
00:14:33,680 --> 00:14:35,360
you know whether or not that those

397
00:14:35,360 --> 00:14:37,760
relationships actually make sense

398
00:14:37,760 --> 00:14:39,760
um we want the build system to be able

399
00:14:39,760 --> 00:14:41,199
to support multiple programming

400
00:14:41,199 --> 00:14:44,480
languages and target architectures

401
00:14:44,480 --> 00:14:47,279
easy integration of additional tools so

402
00:14:47,279 --> 00:14:49,440
you know the either your your custom

403
00:14:49,440 --> 00:14:51,760
scripts or like things like the protobuf

404
00:14:51,760 --> 00:14:54,240
compiler

405
00:14:54,240 --> 00:14:55,760
easy management of third-party

406
00:14:55,760 --> 00:14:57,279
dependencies

407
00:14:57,279 --> 00:14:59,120
um

408
00:14:59,120 --> 00:15:00,160
there's

409
00:15:00,160 --> 00:15:02,720
hermetic builds which are

410
00:15:02,720 --> 00:15:04,399
you know the the

411
00:15:04,399 --> 00:15:05,920
the build system

412
00:15:05,920 --> 00:15:08,320
arranges to invoke whatever tool whether

413
00:15:08,320 --> 00:15:10,399
that's the compiler or even a custom

414
00:15:10,399 --> 00:15:13,279
tool to prevent inclusion of unspecified

415
00:15:13,279 --> 00:15:16,480
resources into the target

416
00:15:16,480 --> 00:15:18,800
and reproducible builds so

417
00:15:18,800 --> 00:15:20,800
given the same set of inputs binary

418
00:15:20,800 --> 00:15:24,639
identical artifacts should get produced

419
00:15:25,440 --> 00:15:26,639
so

420
00:15:26,639 --> 00:15:28,079
um

421
00:15:28,079 --> 00:15:29,920
for open titan

422
00:15:29,920 --> 00:15:32,240
we spent a good great deal of time

423
00:15:32,240 --> 00:15:33,920
examining different build systems that

424
00:15:33,920 --> 00:15:36,320
we could possibly use and

425
00:15:36,320 --> 00:15:38,880
we settled on the build system called

426
00:15:38,880 --> 00:15:41,839
bazel

427
00:15:41,920 --> 00:15:43,519
bazel is

428
00:15:43,519 --> 00:15:46,000
the open source version

429
00:15:46,000 --> 00:15:48,160
of google's industrial strength build

430
00:15:48,160 --> 00:15:50,480
system

431
00:15:50,959 --> 00:15:52,560
some of you probably have seen the

432
00:15:52,560 --> 00:15:54,079
literature that internally google

433
00:15:54,079 --> 00:15:55,839
maintains its own

434
00:15:55,839 --> 00:15:57,040
um

435
00:15:57,040 --> 00:16:00,639
internal source base as a monorepo

436
00:16:00,639 --> 00:16:03,199
and the version of

437
00:16:03,199 --> 00:16:05,600
bazel that runs there built is capable

438
00:16:05,600 --> 00:16:07,279
of

439
00:16:07,279 --> 00:16:08,959
dealing with a dependency relationship

440
00:16:08,959 --> 00:16:11,120
between millions of files and hundreds

441
00:16:11,120 --> 00:16:13,279
of millions of lines of code

442
00:16:13,279 --> 00:16:15,759
it's um

443
00:16:15,759 --> 00:16:17,600
when i started at google i was utterly

444
00:16:17,600 --> 00:16:19,920
shocked at how how big the source base

445
00:16:19,920 --> 00:16:22,480
was

446
00:16:22,480 --> 00:16:23,199
so

447
00:16:23,199 --> 00:16:26,000
basil conceptualizes your project

448
00:16:26,000 --> 00:16:29,040
as a directed acyclic graph of targets

449
00:16:29,040 --> 00:16:32,399
and dependencies between them

450
00:16:32,399 --> 00:16:34,160
bazel expresses the

451
00:16:34,160 --> 00:16:35,199
build

452
00:16:35,199 --> 00:16:37,440
in something called starlark which is a

453
00:16:37,440 --> 00:16:40,160
python-like language for writing rules

454
00:16:40,160 --> 00:16:41,920
that express the relationship between

455
00:16:41,920 --> 00:16:43,279
the targets

456
00:16:43,279 --> 00:16:45,600
um starlark is actually quite a bit more

457
00:16:45,600 --> 00:16:48,399
than that um

458
00:16:48,399 --> 00:16:51,199
it allows you to define macros which can

459
00:16:51,199 --> 00:16:53,440
help you automate um

460
00:16:53,440 --> 00:16:55,440
configuration of targets

461
00:16:55,440 --> 00:16:56,800
um

462
00:16:56,800 --> 00:16:58,800
it also allows you to instantiate your

463
00:16:58,800 --> 00:17:01,279
own rules so if you if you have a custom

464
00:17:01,279 --> 00:17:02,240
tool

465
00:17:02,240 --> 00:17:04,640
you can write a rule that

466
00:17:04,640 --> 00:17:07,359
um can express the relationship between

467
00:17:07,359 --> 00:17:09,199
the inputs and outputs of that rule of

468
00:17:09,199 --> 00:17:10,319
of

469
00:17:10,319 --> 00:17:11,599
what it is that you're trying to build

470
00:17:11,599 --> 00:17:13,520
and then encode that into

471
00:17:13,520 --> 00:17:15,919
uh the rule um

472
00:17:15,919 --> 00:17:17,199
and uh

473
00:17:17,199 --> 00:17:20,160
starlark is sort of designed

474
00:17:20,160 --> 00:17:22,000
um

475
00:17:22,000 --> 00:17:23,919
so that it can be easily parallelized so

476
00:17:23,919 --> 00:17:27,199
a lot of a lot of starlark is is um

477
00:17:27,199 --> 00:17:29,120
construction of of what you might call

478
00:17:29,120 --> 00:17:32,640
immutable data structures

479
00:17:32,640 --> 00:17:35,440
so basil understands multiple tool

480
00:17:35,440 --> 00:17:36,400
chains

481
00:17:36,400 --> 00:17:39,520
um and the rules that talk about you

482
00:17:39,520 --> 00:17:41,120
know building different targets can

483
00:17:41,120 --> 00:17:42,160
express

484
00:17:42,160 --> 00:17:43,919
which tool chains or target

485
00:17:43,919 --> 00:17:46,559
architectures if you wish are valid for

486
00:17:46,559 --> 00:17:50,320
a specific set of targets

487
00:17:50,320 --> 00:17:52,240
there's a rich set of extensions to

488
00:17:52,240 --> 00:17:54,559
support additional tooling such as

489
00:17:54,559 --> 00:17:57,440
protobuf compiler

490
00:17:57,440 --> 00:17:59,360
writing support for your own

491
00:17:59,360 --> 00:18:01,440
extensions is relatively easy once

492
00:18:01,440 --> 00:18:02,240
you've

493
00:18:02,240 --> 00:18:06,320
internalized a bit of of starlark

494
00:18:07,600 --> 00:18:09,600
basil can be told about your third-party

495
00:18:09,600 --> 00:18:12,559
dependencies and it can download them

496
00:18:12,559 --> 00:18:14,960
over the over the net and validate them

497
00:18:14,960 --> 00:18:17,200
on your behalf so

498
00:18:17,200 --> 00:18:18,480
um

499
00:18:18,480 --> 00:18:20,640
this this is kind of what i said earlier

500
00:18:20,640 --> 00:18:22,160
about you know not necessarily wanting

501
00:18:22,160 --> 00:18:24,240
to check those things into your project

502
00:18:24,240 --> 00:18:25,200
um

503
00:18:25,200 --> 00:18:27,440
and basil sandbox is all tool

504
00:18:27,440 --> 00:18:29,280
invitations whether that's the compiler

505
00:18:29,280 --> 00:18:31,039
or a custom tool so

506
00:18:31,039 --> 00:18:33,600
when you when you build a target

507
00:18:33,600 --> 00:18:34,960
um

508
00:18:34,960 --> 00:18:36,960
basil effectively constructs something

509
00:18:36,960 --> 00:18:39,360
like a root that

510
00:18:39,360 --> 00:18:42,320
and it puts into the file system only

511
00:18:42,320 --> 00:18:43,600
the inputs

512
00:18:43,600 --> 00:18:46,400
that are are listed as dependencies and

513
00:18:46,400 --> 00:18:48,720
the tool itself you know to actually do

514
00:18:48,720 --> 00:18:50,559
the build so you know that might be like

515
00:18:50,559 --> 00:18:52,880
the c compiler and it's its associated

516
00:18:52,880 --> 00:18:54,160
binaries

517
00:18:54,160 --> 00:18:55,679
um

518
00:18:55,679 --> 00:18:57,440
there's a bunch of other things to note

519
00:18:57,440 --> 00:19:00,320
about bazel it it by default it

520
00:19:00,320 --> 00:19:02,640
discovers your local compiler tool chain

521
00:19:02,640 --> 00:19:04,640
and python installation but you can

522
00:19:04,640 --> 00:19:07,120
override these so that you can force

523
00:19:07,120 --> 00:19:09,520
the the build to use a specific tool

524
00:19:09,520 --> 00:19:10,799
chain

525
00:19:10,799 --> 00:19:12,559
or you can configure additional tool

526
00:19:12,559 --> 00:19:13,440
chains

527
00:19:13,440 --> 00:19:14,480
um

528
00:19:14,480 --> 00:19:16,799
this tool chain configuration to be fair

529
00:19:16,799 --> 00:19:18,880
is is not

530
00:19:18,880 --> 00:19:20,799
exactly trivial but

531
00:19:20,799 --> 00:19:22,080
i think that

532
00:19:22,080 --> 00:19:23,919
at least for me the difficulties worth

533
00:19:23,919 --> 00:19:25,120
the effort

534
00:19:25,120 --> 00:19:27,120
um and then there are several different

535
00:19:27,120 --> 00:19:30,400
sandboxing mechanisms within basel so

536
00:19:30,400 --> 00:19:32,320
um

537
00:19:32,320 --> 00:19:34,320
this this is most important when it when

538
00:19:34,320 --> 00:19:36,640
it comes to executing tests and you know

539
00:19:36,640 --> 00:19:40,400
your test may depend on a a local

540
00:19:40,400 --> 00:19:43,919
resource like a an fpga board or

541
00:19:43,919 --> 00:19:46,480
or so forth so

542
00:19:46,480 --> 00:19:48,080
um

543
00:19:48,080 --> 00:19:49,360
why don't we uh

544
00:19:49,360 --> 00:19:52,720
take a quick look at like what what the

545
00:19:52,720 --> 00:19:55,280
the build rules look like so

546
00:19:55,280 --> 00:19:57,520
um

547
00:19:58,240 --> 00:20:01,200
if you're familiar with make

548
00:20:01,200 --> 00:20:03,280
the you know a rule and make is

549
00:20:03,280 --> 00:20:06,159
typically a you know an output it's

550
00:20:06,159 --> 00:20:08,480
inputs and then a a

551
00:20:08,480 --> 00:20:10,080
a command line that

552
00:20:10,080 --> 00:20:12,080
describes you know what tool to invoke

553
00:20:12,080 --> 00:20:14,400
and how to invoke it um

554
00:20:14,400 --> 00:20:16,480
bazel abstracts a lot of that into the

555
00:20:16,480 --> 00:20:18,320
tool chain configuration although you

556
00:20:18,320 --> 00:20:20,480
can exert fine-grained control over that

557
00:20:20,480 --> 00:20:22,240
when you need to so

558
00:20:22,240 --> 00:20:24,880
um in this example i'm showing on the

559
00:20:24,880 --> 00:20:27,520
left um

560
00:20:27,520 --> 00:20:29,760
the uh

561
00:20:29,760 --> 00:20:32,880
a cc library which is a either c or c

562
00:20:32,880 --> 00:20:36,400
plus library for the uart driver that's

563
00:20:36,400 --> 00:20:38,559
part of our mask rom

564
00:20:38,559 --> 00:20:39,440
i

565
00:20:39,440 --> 00:20:41,360
enumerate what headers

566
00:20:41,360 --> 00:20:43,200
are required what sources are required

567
00:20:43,200 --> 00:20:45,120
and what dependencies

568
00:20:45,120 --> 00:20:48,080
this particular target needs

569
00:20:48,080 --> 00:20:49,600
there's a there's a

570
00:20:49,600 --> 00:20:52,080
dependency here called uart regs

571
00:20:52,080 --> 00:20:53,840
i'll speak about that in a minute and

572
00:20:53,840 --> 00:20:55,679
then there's this other dependency

573
00:20:55,679 --> 00:20:57,679
called you know

574
00:20:57,679 --> 00:21:00,480
software device lid base and i'm have a

575
00:21:00,480 --> 00:21:02,320
reference here as to you know what that

576
00:21:02,320 --> 00:21:05,439
refers to which is a

577
00:21:05,760 --> 00:21:07,039
in a different part of the project

578
00:21:07,039 --> 00:21:08,960
there's a base library that has a bunch

579
00:21:08,960 --> 00:21:10,080
of

580
00:21:10,080 --> 00:21:11,600
useful headers and

581
00:21:11,600 --> 00:21:13,280
and

582
00:21:13,280 --> 00:21:14,840
let's call

583
00:21:14,840 --> 00:21:17,919
them not precisely the c standard

584
00:21:17,919 --> 00:21:19,280
library but let's say it's power

585
00:21:19,280 --> 00:21:22,240
standard library of functions so

586
00:21:22,240 --> 00:21:23,520
um

587
00:21:23,520 --> 00:21:25,919
when the when the compiler is building

588
00:21:25,919 --> 00:21:28,720
the the uart library it can

589
00:21:28,720 --> 00:21:31,520
it can access any of these header files

590
00:21:31,520 --> 00:21:33,760
that uh

591
00:21:33,760 --> 00:21:35,919
that are referred to in the base library

592
00:21:35,919 --> 00:21:38,640
panic and it can access the built

593
00:21:38,640 --> 00:21:41,679
output of of the sources so the

594
00:21:41,679 --> 00:21:43,200
this

595
00:21:43,200 --> 00:21:43,919
when

596
00:21:43,919 --> 00:21:45,200
when

597
00:21:45,200 --> 00:21:46,799
the project is built

598
00:21:46,799 --> 00:21:48,400
the dependency relationships will be

599
00:21:48,400 --> 00:21:49,520
examined

600
00:21:49,520 --> 00:21:51,520
the base library will be built first

601
00:21:51,520 --> 00:21:53,840
because it's needed by the uart library

602
00:21:53,840 --> 00:21:55,039
um

603
00:21:55,039 --> 00:21:56,640
these sources will be compiled and

604
00:21:56,640 --> 00:21:58,559
archived into a sub library and then

605
00:21:58,559 --> 00:22:00,400
that will you know get further linked

606
00:22:00,400 --> 00:22:03,120
when the uart library gets built

607
00:22:03,120 --> 00:22:05,919
so um this is kind of the you know the

608
00:22:05,919 --> 00:22:08,960
feel of of what this looks like it's

609
00:22:08,960 --> 00:22:12,400
it's kind of like a

610
00:22:12,400 --> 00:22:14,799
i think of it as as these

611
00:22:14,799 --> 00:22:16,320
these rules are a little bit like

612
00:22:16,320 --> 00:22:18,720
functions that describe the

613
00:22:18,720 --> 00:22:20,640
the target in question

614
00:22:20,640 --> 00:22:23,280
and then uh

615
00:22:23,280 --> 00:22:24,640
let's see i was going to speak about

616
00:22:24,640 --> 00:22:27,360
this uart regs

617
00:22:27,360 --> 00:22:30,240
thing so this is a label

618
00:22:30,240 --> 00:22:32,000
it happens to be you know kind of down

619
00:22:32,000 --> 00:22:34,240
in the root of the project which is

620
00:22:34,240 --> 00:22:36,080
not precisely the best location for it

621
00:22:36,080 --> 00:22:37,679
but this is an auto-generated header

622
00:22:37,679 --> 00:22:41,039
file um and

623
00:22:41,039 --> 00:22:42,480
you wouldn't necessarily know that from

624
00:22:42,480 --> 00:22:43,840
the rule but

625
00:22:43,840 --> 00:22:45,679
or from the label

626
00:22:45,679 --> 00:22:47,919
but basically what this is just to

627
00:22:47,919 --> 00:22:50,480
explain it is we have a

628
00:22:50,480 --> 00:22:51,840
within the open titan project the

629
00:22:51,840 --> 00:22:54,320
peripherals all describe their their

630
00:22:54,320 --> 00:22:57,679
register interfaces in uh json files

631
00:22:57,679 --> 00:22:59,200
and then there's a

632
00:22:59,200 --> 00:23:01,440
tool in the project that

633
00:23:01,440 --> 00:23:03,600
consumes those json files and emits

634
00:23:03,600 --> 00:23:06,240
header files that have all the the pound

635
00:23:06,240 --> 00:23:08,159
defines that you would ever deem

636
00:23:08,159 --> 00:23:09,840
necessary to interact with that piece of

637
00:23:09,840 --> 00:23:11,280
hardware so

638
00:23:11,280 --> 00:23:12,720
this

639
00:23:12,720 --> 00:23:14,720
within the project this this actually

640
00:23:14,720 --> 00:23:17,360
refers to an auto generated file um

641
00:23:17,360 --> 00:23:18,960
the reason it's in the root is because

642
00:23:18,960 --> 00:23:20,799
this is from an experiment where i was

643
00:23:20,799 --> 00:23:24,159
doing the evaluation basel and

644
00:23:24,159 --> 00:23:26,480
i'm sorry bazel

645
00:23:26,480 --> 00:23:27,919
and uh

646
00:23:27,919 --> 00:23:29,840
i just put that put it in the root out

647
00:23:29,840 --> 00:23:32,640
of expediency um that's not long term

648
00:23:32,640 --> 00:23:35,679
where it's going to end up

649
00:23:35,679 --> 00:23:37,120
so

650
00:23:37,120 --> 00:23:39,280
this is i think kind of gives a feel

651
00:23:39,280 --> 00:23:41,120
about what the what the build rules look

652
00:23:41,120 --> 00:23:44,639
like within bazel

653
00:23:46,080 --> 00:23:46,960
so

654
00:23:46,960 --> 00:23:48,960
i also talked about external or

655
00:23:48,960 --> 00:23:51,360
third-party dependency management

656
00:23:51,360 --> 00:23:53,840
so a lot of modern open source projects

657
00:23:53,840 --> 00:23:55,279
have a lot of third-party package

658
00:23:55,279 --> 00:23:56,640
dependencies

659
00:23:56,640 --> 00:23:58,080
and if you think about whatever your

660
00:23:58,080 --> 00:24:00,320
favorite language is you know they all

661
00:24:00,320 --> 00:24:02,080
have package management systems these

662
00:24:02,080 --> 00:24:04,320
days whether that's pip for python or

663
00:24:04,320 --> 00:24:06,400
npm for node

664
00:24:06,400 --> 00:24:08,400
or cargo for rust

665
00:24:08,400 --> 00:24:09,600
um

666
00:24:09,600 --> 00:24:12,559
and it's pretty typical to just you know

667
00:24:12,559 --> 00:24:15,120
list list your requirements in a file of

668
00:24:15,120 --> 00:24:16,880
some sort that the package manager knows

669
00:24:16,880 --> 00:24:19,919
how to deal with um and

670
00:24:19,919 --> 00:24:21,919
those dependencies

671
00:24:21,919 --> 00:24:24,640
you know will go download

672
00:24:24,640 --> 00:24:26,880
or that i'm sorry the

673
00:24:26,880 --> 00:24:28,400
the package manager will go download the

674
00:24:28,400 --> 00:24:30,080
thing that you asked for but

675
00:24:30,080 --> 00:24:31,279
how do you how do you know what you're

676
00:24:31,279 --> 00:24:32,480
really getting

677
00:24:32,480 --> 00:24:33,840
and how do you know that the contents

678
00:24:33,840 --> 00:24:35,919
are good i mean there's been

679
00:24:35,919 --> 00:24:36,799
uh

680
00:24:36,799 --> 00:24:38,559
there's been attacks on package

681
00:24:38,559 --> 00:24:40,880
management systems such as the the pipe

682
00:24:40,880 --> 00:24:43,279
dependency confusion attack

683
00:24:43,279 --> 00:24:44,840
um

684
00:24:44,840 --> 00:24:47,360
so um

685
00:24:47,360 --> 00:24:49,200
and if you if you have a

686
00:24:49,200 --> 00:24:52,480
um a multi-language repository

687
00:24:52,480 --> 00:24:54,480
now you you may have sort of a

688
00:24:54,480 --> 00:24:56,799
intersection of different dependency

689
00:24:56,799 --> 00:24:58,400
management systems

690
00:24:58,400 --> 00:24:59,279
um

691
00:24:59,279 --> 00:25:01,520
and if you have uh artifacts that are c

692
00:25:01,520 --> 00:25:04,240
or c plus there is no package manager

693
00:25:04,240 --> 00:25:06,559
for c and c plus plus that's kind of

694
00:25:06,559 --> 00:25:08,400
manual mode

695
00:25:08,400 --> 00:25:10,640
so um

696
00:25:10,640 --> 00:25:13,520
bazel has a concept called the workspace

697
00:25:13,520 --> 00:25:14,960
which

698
00:25:14,960 --> 00:25:16,480
really is the

699
00:25:16,480 --> 00:25:17,840
the root

700
00:25:17,840 --> 00:25:21,200
and configuration of your entire project

701
00:25:21,200 --> 00:25:23,360
and the workspace unifies all this

702
00:25:23,360 --> 00:25:26,080
third-party package management

703
00:25:26,080 --> 00:25:28,799
into a single system within your project

704
00:25:28,799 --> 00:25:30,320
so

705
00:25:30,320 --> 00:25:32,080
all of your third-party dependencies can

706
00:25:32,080 --> 00:25:34,640
be specified in in the workspace

707
00:25:34,640 --> 00:25:36,000
configuration

708
00:25:36,000 --> 00:25:39,600
you can specify them as a git repo with

709
00:25:39,600 --> 00:25:41,600
a label or a hash

710
00:25:41,600 --> 00:25:44,240
a downloadable uri or or even a local

711
00:25:44,240 --> 00:25:46,559
file system path so you might have

712
00:25:46,559 --> 00:25:48,159
you know some code elsewhere on your

713
00:25:48,159 --> 00:25:50,240
local file system um

714
00:25:50,240 --> 00:25:52,480
that last bit the local file system path

715
00:25:52,480 --> 00:25:54,080
is not exactly

716
00:25:54,080 --> 00:25:55,679
you know reproducible

717
00:25:55,679 --> 00:25:57,679
by others but if you're working on the

718
00:25:57,679 --> 00:26:00,720
interactions between two uh packages

719
00:26:00,720 --> 00:26:03,360
it might be convenient to use it um

720
00:26:03,360 --> 00:26:05,760
so when when bazel downloads uh a

721
00:26:05,760 --> 00:26:06,960
package

722
00:26:06,960 --> 00:26:08,240
um

723
00:26:08,240 --> 00:26:10,559
it it will download an archive like a

724
00:26:10,559 --> 00:26:12,640
guitar file or a zip file and it will

725
00:26:12,640 --> 00:26:15,679
check that archive against a shot 256

726
00:26:15,679 --> 00:26:18,159
zone before unpacking and that that shot

727
00:26:18,159 --> 00:26:21,200
256 sum is usually something that's

728
00:26:21,200 --> 00:26:23,520
deliberately configured by the person

729
00:26:23,520 --> 00:26:25,120
managing the project

730
00:26:25,120 --> 00:26:27,200
rather than

731
00:26:27,200 --> 00:26:29,679
say taking it on faith that a package

732
00:26:29,679 --> 00:26:31,840
manager retrieved the correct shot 256

733
00:26:31,840 --> 00:26:34,000
sum so it puts a little bit more work on

734
00:26:34,000 --> 00:26:36,080
you as as somebody maintaining the code

735
00:26:36,080 --> 00:26:38,240
for a project but i again i think this

736
00:26:38,240 --> 00:26:39,120
is

737
00:26:39,120 --> 00:26:41,440
worthwhile because you

738
00:26:41,440 --> 00:26:43,520
if you're managing a project you you

739
00:26:43,520 --> 00:26:45,360
really need to know and be responsible

740
00:26:45,360 --> 00:26:46,799
for those things

741
00:26:46,799 --> 00:26:48,960
um

742
00:26:48,960 --> 00:26:50,840
so

743
00:26:50,840 --> 00:26:54,159
um bazel rules might exist in a in a

744
00:26:54,159 --> 00:26:56,799
third-party package or maybe not um it's

745
00:26:56,799 --> 00:26:58,799
pretty easy to write rules for projects

746
00:26:58,799 --> 00:27:01,120
that or or dependencies that don't have

747
00:27:01,120 --> 00:27:02,240
them

748
00:27:02,240 --> 00:27:04,799
especially if they're small

749
00:27:04,799 --> 00:27:06,640
and if you need a patch version of a

750
00:27:06,640 --> 00:27:09,440
package you can also apply patch it

751
00:27:09,440 --> 00:27:12,000
package it sorry apply patches to a

752
00:27:12,000 --> 00:27:12,960
package

753
00:27:12,960 --> 00:27:16,320
during your workspace initialization so

754
00:27:16,320 --> 00:27:17,520
i think we've

755
00:27:17,520 --> 00:27:19,840
all had the experience of oh i need this

756
00:27:19,840 --> 00:27:21,440
dependency but i need you know i need

757
00:27:21,440 --> 00:27:23,440
one extra feature or

758
00:27:23,440 --> 00:27:25,760
and you know

759
00:27:25,760 --> 00:27:28,240
you either get in the in the

760
00:27:28,240 --> 00:27:30,480
kind of problem of having to apply a

761
00:27:30,480 --> 00:27:32,960
patch or work out how to

762
00:27:32,960 --> 00:27:35,919
have a you know a local copy or a clone

763
00:27:35,919 --> 00:27:38,559
in your github that has the patch in it

764
00:27:38,559 --> 00:27:42,480
um bazel can do that for you

765
00:27:43,039 --> 00:27:44,640
um so

766
00:27:44,640 --> 00:27:47,120
moving on one of the things i mentioned

767
00:27:47,120 --> 00:27:48,960
in a set of requirements is to be able

768
00:27:48,960 --> 00:27:50,480
to understand

769
00:27:50,480 --> 00:27:53,360
the dependency relationships between

770
00:27:53,360 --> 00:27:55,600
um the various targets in your project

771
00:27:55,600 --> 00:27:58,159
and bazel provides

772
00:27:58,159 --> 00:28:00,480
what is effectively a query language to

773
00:28:00,480 --> 00:28:02,799
allow you to discover this so

774
00:28:02,799 --> 00:28:04,960
here is the the the graph of

775
00:28:04,960 --> 00:28:06,880
dependencies for

776
00:28:06,880 --> 00:28:09,679
the uart driver that is part of the the

777
00:28:09,679 --> 00:28:12,640
silicon creator code within our project

778
00:28:12,640 --> 00:28:13,600
so

779
00:28:13,600 --> 00:28:14,640
um

780
00:28:14,640 --> 00:28:16,559
you know it depends on this this thing

781
00:28:16,559 --> 00:28:18,559
called york reggs which we talked about

782
00:28:18,559 --> 00:28:19,679
earlier

783
00:28:19,679 --> 00:28:21,919
and i i can then see that that depends

784
00:28:21,919 --> 00:28:24,480
on this python script called reg tool

785
00:28:24,480 --> 00:28:25,279
which

786
00:28:25,279 --> 00:28:28,159
and then an input file which is the the

787
00:28:28,159 --> 00:28:31,120
json or in our case hjson file that

788
00:28:31,120 --> 00:28:33,919
contains the register description so

789
00:28:33,919 --> 00:28:35,440
um

790
00:28:35,440 --> 00:28:37,200
this this will get executed during the

791
00:28:37,200 --> 00:28:38,960
build to produce the header file that is

792
00:28:38,960 --> 00:28:42,080
ultimately needed by the uart

793
00:28:42,080 --> 00:28:43,279
package

794
00:28:43,279 --> 00:28:46,240
or um module

795
00:28:46,240 --> 00:28:48,080
we depend on the base library which

796
00:28:48,080 --> 00:28:50,080
again we can see the file level

797
00:28:50,080 --> 00:28:52,960
dependencies here um

798
00:28:52,960 --> 00:28:55,840
we def depend on this thing called arch

799
00:28:55,840 --> 00:28:58,399
device which is

800
00:28:58,399 --> 00:29:01,039
architectural constants things like

801
00:29:01,039 --> 00:29:02,480
clock rates

802
00:29:02,480 --> 00:29:05,039
of the various internal

803
00:29:05,039 --> 00:29:07,600
blocks inside the project

804
00:29:07,600 --> 00:29:09,440
there's an error library which contains

805
00:29:09,440 --> 00:29:12,960
a unified set of error return codes and

806
00:29:12,960 --> 00:29:15,520
then of course there's the the files

807
00:29:15,520 --> 00:29:17,279
themselves for

808
00:29:17,279 --> 00:29:19,360
the uart driver

809
00:29:19,360 --> 00:29:20,720
and then

810
00:29:20,720 --> 00:29:22,399
you know all of these things ultimately

811
00:29:22,399 --> 00:29:26,640
depend on the c plus tool chain um

812
00:29:26,640 --> 00:29:28,640
so this is this is the kind of thing

813
00:29:28,640 --> 00:29:30,480
where you can you can really easily

814
00:29:30,480 --> 00:29:33,039
figure out exactly what does

815
00:29:33,039 --> 00:29:35,279
does your project depend on without

816
00:29:35,279 --> 00:29:36,880
having to like go dig through all the

817
00:29:36,880 --> 00:29:41,840
source code and figure that all out

818
00:29:43,360 --> 00:29:45,279
you can also understand the the

819
00:29:45,279 --> 00:29:48,640
relationship between targets so

820
00:29:48,640 --> 00:29:51,600
you you might want to know

821
00:29:51,600 --> 00:29:53,520
in this case

822
00:29:53,520 --> 00:29:56,159
how does the the mask rom library which

823
00:29:56,159 --> 00:29:57,440
is

824
00:29:57,440 --> 00:29:59,039
all of the code for the mask on before

825
00:29:59,039 --> 00:30:01,360
we actually link it at its destination

826
00:30:01,360 --> 00:30:02,480
address

827
00:30:02,480 --> 00:30:03,840
um

828
00:30:03,840 --> 00:30:05,520
how does that how does that mask ground

829
00:30:05,520 --> 00:30:08,159
code depend on this this error module

830
00:30:08,159 --> 00:30:09,919
that i alluded to earlier which contains

831
00:30:09,919 --> 00:30:12,159
the unified set of error codes

832
00:30:12,159 --> 00:30:15,679
well um it depends on that by way of the

833
00:30:15,679 --> 00:30:19,360
hmac driver and the uart driver who um

834
00:30:19,360 --> 00:30:21,360
both independently depend on on the

835
00:30:21,360 --> 00:30:23,440
error module so you can you can

836
00:30:23,440 --> 00:30:26,559
in addition to just getting a graph of

837
00:30:26,559 --> 00:30:28,080
you know what your dependencies are you

838
00:30:28,080 --> 00:30:29,919
can you can track down how do those

839
00:30:29,919 --> 00:30:31,279
dependencies

840
00:30:31,279 --> 00:30:33,039
uh relate to different targets in your

841
00:30:33,039 --> 00:30:34,480
build

842
00:30:34,480 --> 00:30:38,000
i have found this um incredibly useful

843
00:30:38,000 --> 00:30:39,279
in

844
00:30:39,279 --> 00:30:42,320
um my time

845
00:30:42,320 --> 00:30:44,640
both at google in general and and

846
00:30:44,640 --> 00:30:46,559
specifically within with an open titan

847
00:30:46,559 --> 00:30:47,919
to

848
00:30:47,919 --> 00:30:51,840
understand how things are put together

849
00:30:53,600 --> 00:30:57,279
let's talk about testing for a moment

850
00:30:57,279 --> 00:30:59,200
basil includes test rules that are

851
00:30:59,200 --> 00:31:00,960
first-class citizens within the built

852
00:31:00,960 --> 00:31:02,080
graph

853
00:31:02,080 --> 00:31:04,159
these rules can be designated test only

854
00:31:04,159 --> 00:31:05,440
which

855
00:31:05,440 --> 00:31:06,559
means you can

856
00:31:06,559 --> 00:31:08,960
you can disqualify test only artifacts

857
00:31:08,960 --> 00:31:12,320
from anything used in production so

858
00:31:12,320 --> 00:31:14,320
you can you can avoid accidental

859
00:31:14,320 --> 00:31:16,960
inclusion of test artifacts

860
00:31:16,960 --> 00:31:20,480
the test execution itself is sandbox so

861
00:31:20,480 --> 00:31:21,919
you can make sure your tests only have

862
00:31:21,919 --> 00:31:24,000
access to you know to their specified

863
00:31:24,000 --> 00:31:25,200
resources

864
00:31:25,200 --> 00:31:27,360
as i alluded to earlier you can relax

865
00:31:27,360 --> 00:31:29,360
this if you need to

866
00:31:29,360 --> 00:31:31,360
the test can be categorized with tags

867
00:31:31,360 --> 00:31:33,120
and then the query mechanism can be used

868
00:31:33,120 --> 00:31:35,600
to select test categories so you can

869
00:31:35,600 --> 00:31:37,679
select lightweight tests for a fast

870
00:31:37,679 --> 00:31:39,679
continuous integration cycle

871
00:31:39,679 --> 00:31:42,399
and heavyweight tests for say a nightly

872
00:31:42,399 --> 00:31:43,760
just as an example of something you

873
00:31:43,760 --> 00:31:44,880
could do

874
00:31:44,880 --> 00:31:47,919
and um

875
00:31:47,919 --> 00:31:49,760
the

876
00:31:49,760 --> 00:31:52,399
this is kind of one of my favorite

877
00:31:52,399 --> 00:31:55,039
features um the the dependency

878
00:31:55,039 --> 00:31:57,360
query mechanism can use to find

879
00:31:57,360 --> 00:31:58,960
all tests that have a dependency

880
00:31:58,960 --> 00:32:01,440
relationship with the files in a changed

881
00:32:01,440 --> 00:32:02,320
list

882
00:32:02,320 --> 00:32:04,159
which can then be used to select the

883
00:32:04,159 --> 00:32:05,840
relevant set of tests to run for a

884
00:32:05,840 --> 00:32:08,080
pre-submit so rather than running all

885
00:32:08,080 --> 00:32:10,000
the tests everywhere in the project

886
00:32:10,000 --> 00:32:11,600
you can use this query mechanism to

887
00:32:11,600 --> 00:32:14,720
select only the relevant tests

888
00:32:14,720 --> 00:32:16,240
um

889
00:32:16,240 --> 00:32:18,480
i think i'm a little bit over time

890
00:32:18,480 --> 00:32:20,240
should i continue or

891
00:32:20,240 --> 00:32:25,640
or go faster or what what should i do

892
00:32:29,039 --> 00:32:31,600
i think uh i'll

893
00:32:31,600 --> 00:32:33,919
continue quickly you have uh almost

894
00:32:33,919 --> 00:32:36,320
eight minutes still yeah

895
00:32:36,320 --> 00:32:37,200
okay

896
00:32:37,200 --> 00:32:38,080
um

897
00:32:38,080 --> 00:32:40,240
so one of the things that that

898
00:32:40,240 --> 00:32:42,399
bazel supports is something referred to

899
00:32:42,399 --> 00:32:44,720
as air gap execution and

900
00:32:44,720 --> 00:32:46,399
this means that bazel can actually build

901
00:32:46,399 --> 00:32:47,919
your project within an air gap

902
00:32:47,919 --> 00:32:50,480
environment um so on on a computer that

903
00:32:50,480 --> 00:32:53,440
has no network access at all

904
00:32:53,440 --> 00:32:55,279
normally bazel wants to retrieve all of

905
00:32:55,279 --> 00:32:57,200
your dependencies and some of its own

906
00:32:57,200 --> 00:33:00,240
dependencies via the the network

907
00:33:00,240 --> 00:33:01,279
but

908
00:33:01,279 --> 00:33:02,559
um

909
00:33:02,559 --> 00:33:04,480
your project like that might not be

910
00:33:04,480 --> 00:33:06,000
appropriate for your project and in

911
00:33:06,000 --> 00:33:07,760
particular for open titan

912
00:33:07,760 --> 00:33:10,159
because we're seeking certification

913
00:33:10,159 --> 00:33:12,000
there's certain portions of the project

914
00:33:12,000 --> 00:33:13,760
that need to be built in an offline

915
00:33:13,760 --> 00:33:15,279
secure environment

916
00:33:15,279 --> 00:33:17,679
so basil can facilitate this by allowing

917
00:33:17,679 --> 00:33:18,480
you to

918
00:33:18,480 --> 00:33:21,360
perform a preparation step in which it

919
00:33:21,360 --> 00:33:22,880
will download and verify all the

920
00:33:22,880 --> 00:33:24,960
external dependencies first

921
00:33:24,960 --> 00:33:27,679
and then you can transport your

922
00:33:27,679 --> 00:33:29,679
project repo and all these prepared

923
00:33:29,679 --> 00:33:32,640
archives into the secure environment

924
00:33:32,640 --> 00:33:35,039
and then within the secure environment

925
00:33:35,039 --> 00:33:36,720
bazel can be instructed to use the

926
00:33:36,720 --> 00:33:38,799
pre-prepared archives instead of

927
00:33:38,799 --> 00:33:40,080
attempting to download them from the

928
00:33:40,080 --> 00:33:41,120
network

929
00:33:41,120 --> 00:33:42,960
so this is a really convenient feature

930
00:33:42,960 --> 00:33:45,279
to have

931
00:33:46,480 --> 00:33:48,240
and there are things within

932
00:33:48,240 --> 00:33:50,159
that we're still learning about um you

933
00:33:50,159 --> 00:33:52,240
know basil is a it's a as i said an

934
00:33:52,240 --> 00:33:54,480
industrial strength tool and

935
00:33:54,480 --> 00:33:55,600
even

936
00:33:55,600 --> 00:33:58,000
even i am not an expert

937
00:33:58,000 --> 00:34:00,320
in all of the things that it can do

938
00:34:00,320 --> 00:34:02,559
um so a couple things that we're still

939
00:34:02,559 --> 00:34:05,760
learning about is that basil can

940
00:34:05,760 --> 00:34:07,679
generate coverage reports over your code

941
00:34:07,679 --> 00:34:09,839
base by executing your tests and and

942
00:34:09,839 --> 00:34:11,520
measure and using the compiler to

943
00:34:11,520 --> 00:34:13,040
measure coverage

944
00:34:13,040 --> 00:34:13,918
um

945
00:34:13,918 --> 00:34:15,520
bazel can execute your test with the

946
00:34:15,520 --> 00:34:17,599
various sanitizers enabled so if you

947
00:34:17,599 --> 00:34:19,679
want to run your your code with asan and

948
00:34:19,679 --> 00:34:22,480
santisan enabled you can do that

949
00:34:22,480 --> 00:34:24,159
um

950
00:34:24,159 --> 00:34:26,159
there's uh you know we're

951
00:34:26,159 --> 00:34:27,520
learning about additional language

952
00:34:27,520 --> 00:34:30,239
support so most of the low level open

953
00:34:30,239 --> 00:34:33,199
titan firmware and tests are in c and c

954
00:34:33,199 --> 00:34:34,879
plus and there's a lot of utility scopes

955
00:34:34,879 --> 00:34:36,159
in python

956
00:34:36,159 --> 00:34:38,239
there's some parts of the code base that

957
00:34:38,239 --> 00:34:40,800
are written in rust this is mostly host

958
00:34:40,800 --> 00:34:42,079
side tooling

959
00:34:42,079 --> 00:34:43,119
um

960
00:34:43,119 --> 00:34:45,199
long-term we actually want to write big

961
00:34:45,199 --> 00:34:47,280
parts of the firmware and rust but

962
00:34:47,280 --> 00:34:48,879
we aren't

963
00:34:48,879 --> 00:34:50,800
there yet at this stage of the project

964
00:34:50,800 --> 00:34:52,000
um

965
00:34:52,000 --> 00:34:53,520
so for rust

966
00:34:53,520 --> 00:34:55,359
cargo is the de facto method for

967
00:34:55,359 --> 00:34:58,560
specifying dependencies but

968
00:34:58,560 --> 00:35:01,119
as i alluded to earlier it's

969
00:35:01,119 --> 00:35:02,800
we really want all of the dependency

970
00:35:02,800 --> 00:35:05,520
management under

971
00:35:05,520 --> 00:35:07,680
under basil supervision and we want the

972
00:35:07,680 --> 00:35:11,440
build of of code under basils

973
00:35:11,440 --> 00:35:13,760
sorry bazel's supervision i say basil

974
00:35:13,760 --> 00:35:15,280
because uh

975
00:35:15,280 --> 00:35:17,040
i'm a fan of monty python and john

976
00:35:17,040 --> 00:35:19,520
cleese and i kind of feel like an

977
00:35:19,520 --> 00:35:21,440
opportunity was missed

978
00:35:21,440 --> 00:35:22,480
to

979
00:35:22,480 --> 00:35:25,760
to not call it basil but

980
00:35:27,680 --> 00:35:30,880
with that aside um so there's there's an

981
00:35:30,880 --> 00:35:33,280
extension for bazel called cargo raids

982
00:35:33,280 --> 00:35:35,839
which can consume a cargo

983
00:35:35,839 --> 00:35:38,560
configuration and emit bazel rules for

984
00:35:38,560 --> 00:35:40,960
all of your dependencies

985
00:35:40,960 --> 00:35:41,839
and

986
00:35:41,839 --> 00:35:45,040
long term we would like the build of the

987
00:35:45,040 --> 00:35:48,079
verilog hardware descriptions

988
00:35:48,079 --> 00:35:49,119
um

989
00:35:49,119 --> 00:35:50,880
to be

990
00:35:50,880 --> 00:35:53,200
brought under basil's umbrella and this

991
00:35:53,200 --> 00:35:55,520
is kind of still unsolved there's

992
00:35:55,520 --> 00:35:56,800
there's been

993
00:35:56,800 --> 00:36:00,400
a lot of work uh internal at google at

994
00:36:00,400 --> 00:36:02,400
doing this um

995
00:36:02,400 --> 00:36:05,839
and i myself have done a bit of this um

996
00:36:05,839 --> 00:36:07,680
i've

997
00:36:07,680 --> 00:36:09,119
spent some time a couple years ago

998
00:36:09,119 --> 00:36:10,240
learning about

999
00:36:10,240 --> 00:36:12,560
verilog and fpga development using uh

1000
00:36:12,560 --> 00:36:16,079
project ice storm project trellis and uh

1001
00:36:16,079 --> 00:36:17,839
i i

1002
00:36:17,839 --> 00:36:20,400
find make to be so distasteful now that

1003
00:36:20,400 --> 00:36:22,800
i i spent the time to write my own toy

1004
00:36:22,800 --> 00:36:25,359
rules for my toy project

1005
00:36:25,359 --> 00:36:27,520
so i'm confident that long term we can

1006
00:36:27,520 --> 00:36:30,079
solve this problem in open time and get

1007
00:36:30,079 --> 00:36:31,599
the whole project

1008
00:36:31,599 --> 00:36:35,760
brought under the supervision of bazel

1009
00:36:36,880 --> 00:36:38,079
so

1010
00:36:38,079 --> 00:36:40,640
to conclude

1011
00:36:40,640 --> 00:36:43,040
the open titan projects we're building

1012
00:36:43,040 --> 00:36:45,599
an open source silicon root of trust

1013
00:36:45,599 --> 00:36:47,680
our design is compatible with the

1014
00:36:47,680 --> 00:36:49,440
rigorous requirements for fips and

1015
00:36:49,440 --> 00:36:52,480
common criteria certification

1016
00:36:52,480 --> 00:36:54,480
our code base is public and we want

1017
00:36:54,480 --> 00:36:56,160
anyone to be able to build and audit the

1018
00:36:56,160 --> 00:36:57,920
code

1019
00:36:57,920 --> 00:37:00,560
we have many third-party dependencies

1020
00:37:00,560 --> 00:37:02,560
and a complex build

1021
00:37:02,560 --> 00:37:04,400
and we need a build system that is up to

1022
00:37:04,400 --> 00:37:06,960
the task of expressing

1023
00:37:06,960 --> 00:37:10,320
the build accurately and exactly

1024
00:37:10,320 --> 00:37:11,920
we need that to be able to assist in

1025
00:37:11,920 --> 00:37:12,960
auditing

1026
00:37:12,960 --> 00:37:14,079
we need

1027
00:37:14,079 --> 00:37:16,240
um we need to build artifacts to be

1028
00:37:16,240 --> 00:37:17,760
reproducible

1029
00:37:17,760 --> 00:37:19,920
we need multi-language support

1030
00:37:19,920 --> 00:37:21,760
multi-target support and support for

1031
00:37:21,760 --> 00:37:23,359
custom tools

1032
00:37:23,359 --> 00:37:25,440
and we need a build system that

1033
00:37:25,440 --> 00:37:27,359
comprehends testing as part of the

1034
00:37:27,359 --> 00:37:28,400
overall

1035
00:37:28,400 --> 00:37:30,960
build or project process

1036
00:37:30,960 --> 00:37:32,800
so for us

1037
00:37:32,800 --> 00:37:35,119
bazel fits the

1038
00:37:35,119 --> 00:37:36,599
um bill

1039
00:37:36,800 --> 00:37:39,440
that's all i had i can uh i can take

1040
00:37:39,440 --> 00:37:41,920
questions

1041
00:37:42,000 --> 00:37:44,400
thank you chris uh there are actually

1042
00:37:44,400 --> 00:37:46,640
three questions uh but maybe we could

1043
00:37:46,640 --> 00:37:48,560
take one in the breakout room because of

1044
00:37:48,560 --> 00:37:50,400
the time but let me read the first

1045
00:37:50,400 --> 00:37:54,280
question to you chris uh it's from dave

1046
00:37:54,280 --> 00:37:57,040
j3101 a hardware protected secure

1047
00:37:57,040 --> 00:38:00,480
environment is it compliant

1048
00:38:00,880 --> 00:38:02,800
i am afraid that i

1049
00:38:02,800 --> 00:38:06,480
don't know the answer to that

1050
00:38:07,200 --> 00:38:08,079
okay

1051
00:38:08,079 --> 00:38:10,160
uh i think this is also this is not a

1052
00:38:10,160 --> 00:38:12,720
question but it's a statement by dave

1053
00:38:12,720 --> 00:38:14,640
that the problem statement is also

1054
00:38:14,640 --> 00:38:16,640
configure configuration management

1055
00:38:16,640 --> 00:38:19,119
statement

1056
00:38:19,119 --> 00:38:20,640
i would say that that's effectively

1057
00:38:20,640 --> 00:38:23,920
correct that um

1058
00:38:24,560 --> 00:38:26,640
the

1059
00:38:26,640 --> 00:38:28,480
getting the build system set up properly

1060
00:38:28,480 --> 00:38:30,160
and correctly is

1061
00:38:30,160 --> 00:38:33,680
is a configuration management problem um

1062
00:38:33,680 --> 00:38:36,320
i think that uh

1063
00:38:36,320 --> 00:38:39,200
at least in my experience um

1064
00:38:39,200 --> 00:38:41,040
basil seems to

1065
00:38:41,040 --> 00:38:42,960
be one of the better tools in this

1066
00:38:42,960 --> 00:38:44,640
regard i've

1067
00:38:44,640 --> 00:38:47,359
i've really in my career have spent a

1068
00:38:47,359 --> 00:38:49,040
lot of time staring at make files and

1069
00:38:49,040 --> 00:38:50,079
wondering

1070
00:38:50,079 --> 00:38:51,599
um

1071
00:38:51,599 --> 00:38:53,359
how the heck things got into a certain

1072
00:38:53,359 --> 00:38:55,680
state and you know where where different

1073
00:38:55,680 --> 00:38:58,560
make variables have come from and um

1074
00:38:58,560 --> 00:39:02,000
it's it's something that i think is

1075
00:39:02,000 --> 00:39:05,040
expressed better in in bazel and as

1076
00:39:05,040 --> 00:39:08,000
easier to to kind of figure out why

1077
00:39:08,000 --> 00:39:09,359
um

1078
00:39:09,359 --> 00:39:11,680
things happen and what how things depend

1079
00:39:11,680 --> 00:39:13,440
on each other than in other build

1080
00:39:13,440 --> 00:39:15,839
systems

1081
00:39:17,680 --> 00:39:18,880
okay

1082
00:39:18,880 --> 00:39:20,160
uh

1083
00:39:20,160 --> 00:39:22,240
there's one question from rob but i

1084
00:39:22,240 --> 00:39:24,720
would request uh rob to take it with you

1085
00:39:24,720 --> 00:39:26,640
in the breakout room uh so that we could

1086
00:39:26,640 --> 00:39:28,560
uh not delay the next speaker but thank

1087
00:39:28,560 --> 00:39:31,200
you chris so much for sharing uh the

1088
00:39:31,200 --> 00:39:33,920
insights on open title project uh i

1089
00:39:33,920 --> 00:39:36,320
really appreciate it and uh thank you

1090
00:39:36,320 --> 00:39:38,720
for being part of hardware.io as well

1091
00:39:38,720 --> 00:39:40,320
friends if you have questions and you

1092
00:39:40,320 --> 00:39:42,960
would like to talk to chris uh please

1093
00:39:42,960 --> 00:39:44,640
join the breakout room there will be a

1094
00:39:44,640 --> 00:39:46,960
pop-up onto your screen right now

1095
00:39:46,960 --> 00:39:48,960
to interact with our speaker and talk

1096
00:39:48,960 --> 00:39:50,700
more about his project

1097
00:39:50,700 --> 00:39:52,800
[Music]

1098
00:39:52,800 --> 00:39:54,280
thank you

1099
00:39:54,280 --> 00:39:55,840
[Applause]

1100
00:39:55,840 --> 00:39:57,110
[Music]

1101
00:39:57,110 --> 00:40:00,160
[Applause]

1102
00:40:00,160 --> 00:40:02,240
you

