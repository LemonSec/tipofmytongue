1
00:00:03,410 --> 00:00:05,200
[Music]

2
00:00:05,200 --> 00:00:06,770
[Applause]

3
00:00:06,770 --> 00:00:08,029
[Music]

4
00:00:08,029 --> 00:00:11,179
[Applause]

5
00:00:12,719 --> 00:00:15,360
our next speaker

6
00:00:15,360 --> 00:00:18,560
is talu

7
00:00:18,560 --> 00:00:21,119
from trend micro on enabling dynamic

8
00:00:21,119 --> 00:00:21,840
analysis

9
00:00:21,840 --> 00:00:23,840
of legacy embedded systems in a fully

10
00:00:23,840 --> 00:00:25,519
emulated environment

11
00:00:25,519 --> 00:00:27,039
his talk will be stressing the

12
00:00:27,039 --> 00:00:29,119
significance of emulation tools

13
00:00:29,119 --> 00:00:31,119
by showing how the emulation methods

14
00:00:31,119 --> 00:00:32,399
allow to transplant

15
00:00:32,399 --> 00:00:34,800
any given kernel mode binaries into a

16
00:00:34,800 --> 00:00:36,800
control environment

17
00:00:36,800 --> 00:00:39,200
so without any further delay talu i will

18
00:00:39,200 --> 00:00:39,840
let you

19
00:00:39,840 --> 00:00:41,840
begin your presentation and thank you so

20
00:00:41,840 --> 00:00:45,840
much for joining us

21
00:00:47,600 --> 00:00:50,399
okay thanks thank you for the up net

22
00:00:50,399 --> 00:00:51,760
opportunity

23
00:00:51,760 --> 00:00:56,160
so uh hello everyone

24
00:00:56,160 --> 00:01:00,000
welcome to my talk the talk

25
00:01:00,000 --> 00:01:02,559
apparently will be named enabling

26
00:01:02,559 --> 00:01:04,640
dynamic analysis of legacy embedded

27
00:01:04,640 --> 00:01:05,760
systems

28
00:01:05,760 --> 00:01:09,680
in fully emulated environment

29
00:01:10,000 --> 00:01:13,680
let me introduce myself first uh so i

30
00:01:13,680 --> 00:01:17,680
go by handle eventsify on elsewhere

31
00:01:17,680 --> 00:01:19,680
i'm currently a researcher at tx1

32
00:01:19,680 --> 00:01:20,720
networks

33
00:01:20,720 --> 00:01:24,000
which is a subsidiary of trend micro

34
00:01:24,000 --> 00:01:26,720
i have i mainly focus on vulnerability

35
00:01:26,720 --> 00:01:28,320
research in my job

36
00:01:28,320 --> 00:01:31,439
but i also have focus on other fields

37
00:01:31,439 --> 00:01:35,600
including protocol analysis and hardware

38
00:01:37,520 --> 00:01:40,159
so today we're going to talk about our

39
00:01:40,159 --> 00:01:41,280
little project

40
00:01:41,280 --> 00:01:44,560
which we will go through it like this

41
00:01:44,560 --> 00:01:46,960
we will talk about how we ended up with

42
00:01:46,960 --> 00:01:48,799
researching c6

43
00:01:48,799 --> 00:01:50,799
our goals and our background in this

44
00:01:50,799 --> 00:01:52,240
project

45
00:01:52,240 --> 00:01:55,439
how c6 internal looks like how its

46
00:01:55,439 --> 00:01:57,439
bootloader and parallel initialization

47
00:01:57,439 --> 00:01:59,040
goes

48
00:01:59,040 --> 00:02:01,280
how its application loader looks like

49
00:02:01,280 --> 00:02:05,600
and how the c6 does memory management

50
00:02:05,600 --> 00:02:08,800
and then we will talk about our proposal

51
00:02:08,800 --> 00:02:12,560
to do a kind of emulation on c binaries

52
00:02:12,560 --> 00:02:15,760
by using our method and then we will

53
00:02:15,760 --> 00:02:19,280
conclude our talk with a demo

54
00:02:21,200 --> 00:02:26,000
so our original goal in this research

55
00:02:26,000 --> 00:02:29,200
we only wanted to study a particular

56
00:02:29,200 --> 00:02:33,359
device based on windows c6

57
00:02:33,760 --> 00:02:36,319
and then we found out that despite c6 is

58
00:02:36,319 --> 00:02:37,200
very old

59
00:02:37,200 --> 00:02:39,519
but it is still being used by a variety

60
00:02:39,519 --> 00:02:42,239
of devices which are might being sold

61
00:02:42,239 --> 00:02:45,840
or still deployed in the field

62
00:02:46,000 --> 00:02:49,760
also as we as we manage do vulnerability

63
00:02:49,760 --> 00:02:51,360
research

64
00:02:51,360 --> 00:02:53,440
it is natural for us to study many

65
00:02:53,440 --> 00:02:54,800
devices

66
00:02:54,800 --> 00:02:57,599
but it it is actually quite impossible

67
00:02:57,599 --> 00:03:00,080
to buy every devices

68
00:03:00,080 --> 00:03:03,360
athlete as that will cost a lot of money

69
00:03:03,360 --> 00:03:05,840
and space here is quite expensive in

70
00:03:05,840 --> 00:03:07,440
taiwan

71
00:03:07,440 --> 00:03:10,480
however we ended up buying one of the

72
00:03:10,480 --> 00:03:11,840
devices actually

73
00:03:11,840 --> 00:03:15,519
for comparison to our project

74
00:03:16,400 --> 00:03:19,920
also there are a couple of pros

75
00:03:19,920 --> 00:03:22,800
with emulation you have fully access to

76
00:03:22,800 --> 00:03:25,120
hardware debugger serial ports

77
00:03:25,120 --> 00:03:29,519
which might not even be present on every

78
00:03:30,840 --> 00:03:32,000
hardware

79
00:03:32,000 --> 00:03:34,239
now let's talk about the background of

80
00:03:34,239 --> 00:03:36,100
windows c6

81
00:03:36,100 --> 00:03:39,180
[Music]

82
00:03:40,239 --> 00:03:43,040
basically windows c6 you can say that it

83
00:03:43,040 --> 00:03:46,640
is horror from the ancient well

84
00:03:46,640 --> 00:03:48,959
as it is a very old operating system

85
00:03:48,959 --> 00:03:51,599
still in use everywhere

86
00:03:51,599 --> 00:03:55,360
but it hasn't been actively exported in

87
00:03:55,360 --> 00:03:57,760
the field yet

88
00:03:57,760 --> 00:04:00,239
it runs everywhere like in your car

89
00:04:00,239 --> 00:04:00,959
maybe in

90
00:04:00,959 --> 00:04:03,599
any parking meters in some aircraft

91
00:04:03,599 --> 00:04:05,519
entertainment systems

92
00:04:05,519 --> 00:04:08,640
in subways maybe trains medical devices

93
00:04:08,640 --> 00:04:14,239
or even power plants

94
00:04:14,239 --> 00:04:16,478
and the main difference between nt and

95
00:04:16,478 --> 00:04:17,358
ce

96
00:04:17,358 --> 00:04:20,720
well microsoft has a plan

97
00:04:20,720 --> 00:04:23,520
called shared source initiative which

98
00:04:23,520 --> 00:04:24,880
you only have to

99
00:04:24,880 --> 00:04:27,280
complete a checkbox while installing

100
00:04:27,280 --> 00:04:28,800
csdk

101
00:04:28,800 --> 00:04:30,880
you check the checkbox and you'll get

102
00:04:30,880 --> 00:04:34,159
some private source code

103
00:04:34,240 --> 00:04:38,720
window c is loosely based on anti-kernel

104
00:04:38,720 --> 00:04:40,960
but somehow behaviors are not quite the

105
00:04:40,960 --> 00:04:42,479
same

106
00:04:42,479 --> 00:04:45,040
so you will see similar api names in

107
00:04:45,040 --> 00:04:46,400
windows ce

108
00:04:46,400 --> 00:04:48,320
and it will turn out to be not what

109
00:04:48,320 --> 00:04:51,520
exactly you would expect

110
00:04:51,520 --> 00:04:54,160
and according to microsoft windows ce is

111
00:04:54,160 --> 00:04:57,840
a real-time os

112
00:05:00,240 --> 00:05:03,199
so despite the differences we mentioned

113
00:05:03,199 --> 00:05:06,240
between windows c and windows nt

114
00:05:06,240 --> 00:05:08,320
it is possible to power some of our

115
00:05:08,320 --> 00:05:10,479
programs or attack methods

116
00:05:10,479 --> 00:05:12,800
originally used for anti-base systems

117
00:05:12,800 --> 00:05:15,120
under windows ce

118
00:05:15,120 --> 00:05:19,440
let's take an example so back in 2017

119
00:05:19,440 --> 00:05:23,199
there's an attempt to port internal blue

120
00:05:23,199 --> 00:05:25,600
until window ce and attempt actually

121
00:05:25,600 --> 00:05:28,639
work on ce

122
00:05:31,280 --> 00:05:33,600
and here are some current methods should

123
00:05:33,600 --> 00:05:37,039
you try to study in c6 firmware

124
00:05:37,039 --> 00:05:38,880
before i researched there was a few

125
00:05:38,880 --> 00:05:40,160
limited options

126
00:05:40,160 --> 00:05:42,240
should you attempt to do research on any

127
00:05:42,240 --> 00:05:44,800
given c6 images

128
00:05:44,800 --> 00:05:48,320
there's a tool called e-imgfs which have

129
00:05:48,320 --> 00:05:50,240
very deep roots back in the days of

130
00:05:50,240 --> 00:05:52,560
windows phone modding to extract the

131
00:05:52,560 --> 00:05:53,520
files but

132
00:05:53,520 --> 00:05:56,000
from the image but you cannot use them

133
00:05:56,000 --> 00:05:57,280
directly

134
00:05:57,280 --> 00:06:00,080
as the tool will extract the file as is

135
00:06:00,080 --> 00:06:02,720
we will try to explain the reason why

136
00:06:02,720 --> 00:06:06,160
behind this later on for dynamic

137
00:06:06,160 --> 00:06:07,280
debugger

138
00:06:07,280 --> 00:06:10,240
there is a wonderful project called cgcc

139
00:06:10,240 --> 00:06:12,400
which ports a very old version of

140
00:06:12,400 --> 00:06:15,919
gcc onto windows ce it is possible to

141
00:06:15,919 --> 00:06:16,800
use the gdp

142
00:06:16,800 --> 00:06:19,280
included in that project to debug

143
00:06:19,280 --> 00:06:20,240
programs

144
00:06:20,240 --> 00:06:22,720
even if the program was not compiled

145
00:06:22,720 --> 00:06:25,440
with gcc

146
00:06:25,440 --> 00:06:27,759
in some of the devices you can just

147
00:06:27,759 --> 00:06:28,720
simply plug

148
00:06:28,720 --> 00:06:31,360
in your usb drive and try to extract the

149
00:06:31,360 --> 00:06:32,840
files

150
00:06:32,840 --> 00:06:36,080
however the files you can extract using

151
00:06:36,080 --> 00:06:37,120
this way

152
00:06:37,120 --> 00:06:40,319
is very limited you are unlikely to

153
00:06:40,319 --> 00:06:43,120
able to extract drivers and libraries

154
00:06:43,120 --> 00:06:46,000
using this method

155
00:06:47,280 --> 00:06:50,319
and even if you extract them in most of

156
00:06:50,319 --> 00:06:52,240
the time you cannot run them inside your

157
00:06:52,240 --> 00:06:53,680
environment

158
00:06:53,680 --> 00:06:55,840
with emulator from microsoft or just

159
00:06:55,840 --> 00:06:57,759
with qmu

160
00:06:57,759 --> 00:07:03,120
until we propose our method

161
00:07:03,120 --> 00:07:06,720
so our research

162
00:07:06,720 --> 00:07:11,360
actually met with a very big failure

163
00:07:11,360 --> 00:07:14,160
during the start

164
00:07:15,120 --> 00:07:17,919
so in the beginning we started how c6

165
00:07:17,919 --> 00:07:19,520
boots

166
00:07:19,520 --> 00:07:22,319
we assume that it is just like ordinary

167
00:07:22,319 --> 00:07:24,160
x86 machines

168
00:07:24,160 --> 00:07:26,800
goes to operating system after power on

169
00:07:26,800 --> 00:07:29,280
self-test is done

170
00:07:29,280 --> 00:07:31,919
in c6 there are two methods you can boot

171
00:07:31,919 --> 00:07:33,520
into the os

172
00:07:33,520 --> 00:07:36,240
one is what microsoft called bios loader

173
00:07:36,240 --> 00:07:40,400
it is much like you boot in modern days

174
00:07:40,400 --> 00:07:42,880
another method is using any ms dot

175
00:07:42,880 --> 00:07:45,120
ms-dos compatible dos

176
00:07:45,120 --> 00:07:48,080
and use included tools from the sdk to

177
00:07:48,080 --> 00:07:50,479
load your operating system image

178
00:07:50,479 --> 00:07:52,879
like what people did back in windows 98

179
00:07:52,879 --> 00:07:55,840
or 95 era

180
00:07:56,080 --> 00:07:59,599
after the os kernel loads peripherals

181
00:07:59,599 --> 00:08:01,919
and devices will be initialized

182
00:08:01,919 --> 00:08:05,599
then it will go to loading programs

183
00:08:05,599 --> 00:08:09,199
so according to those points

184
00:08:09,199 --> 00:08:12,400
we just assume c is like any other x86

185
00:08:12,400 --> 00:08:13,039
os

186
00:08:13,039 --> 00:08:16,800
and it is trivial to emulate

187
00:08:18,560 --> 00:08:22,240
so c6 firmware format

188
00:08:22,240 --> 00:08:25,120
the c6 image builder allows two kinds of

189
00:08:25,120 --> 00:08:26,080
output

190
00:08:26,080 --> 00:08:28,400
one is called dot bin which has a tidy

191
00:08:28,400 --> 00:08:30,560
format adheres to the struct

192
00:08:30,560 --> 00:08:33,200
pasted on the right side of the slide

193
00:08:33,200 --> 00:08:34,799
another one is mb0

194
00:08:34,799 --> 00:08:37,360
is a one by one representation of the

195
00:08:37,360 --> 00:08:38,399
ram

196
00:08:38,399 --> 00:08:41,519
as some flash memories can employ

197
00:08:41,519 --> 00:08:45,200
execute execute in place

198
00:08:45,200 --> 00:08:47,120
which means their storage area allows

199
00:08:47,120 --> 00:08:49,279
execution and that saves time from

200
00:08:49,279 --> 00:08:52,160
copying entire os into the ram

201
00:08:52,160 --> 00:08:55,200
our target uses the dot mb0 format

202
00:08:55,200 --> 00:08:57,839
and contrary to common assumption it is

203
00:08:57,839 --> 00:08:59,600
totally possible to convert it

204
00:08:59,600 --> 00:09:02,320
into a dot bin file and we can use load

205
00:09:02,320 --> 00:09:04,720
cpc tool to load the file

206
00:09:04,720 --> 00:09:06,800
by pointing start address to start of

207
00:09:06,800 --> 00:09:08,000
flash with a context

208
00:09:08,000 --> 00:09:12,959
of mb0 we can pack it into a dock bin

209
00:09:14,720 --> 00:09:17,600
and then with our naive approach we are

210
00:09:17,600 --> 00:09:19,760
met with our first failure

211
00:09:19,760 --> 00:09:22,160
this is roughly as far as we can go

212
00:09:22,160 --> 00:09:24,800
before we went without another method

213
00:09:24,800 --> 00:09:27,120
as the firmware requires some checks to

214
00:09:27,120 --> 00:09:29,760
special flash and io devices

215
00:09:29,760 --> 00:09:32,560
this approach will naturally fail

216
00:09:32,560 --> 00:09:33,360
however

217
00:09:33,360 --> 00:09:35,600
we have done our attempt we tried to

218
00:09:35,600 --> 00:09:37,200
binary patch a great amount

219
00:09:37,200 --> 00:09:40,640
of part of this image and did made

220
00:09:40,640 --> 00:09:43,200
more progress into booting process but

221
00:09:43,200 --> 00:09:47,519
then we decided to go against this world

222
00:09:48,560 --> 00:09:50,880
moreover there are much differences

223
00:09:50,880 --> 00:09:53,440
between actual devices and qmil

224
00:09:53,440 --> 00:09:56,640
for example our device uses an

225
00:09:56,640 --> 00:09:59,760
avid md drill chipset

226
00:09:59,760 --> 00:10:03,040
and in qmu we have either iphone 440fx

227
00:10:03,040 --> 00:10:04,399
or q35

228
00:10:04,399 --> 00:10:07,440
and they are quite much different

229
00:10:07,440 --> 00:10:08,880
we also thought about creating

230
00:10:08,880 --> 00:10:10,959
corresponding chipsets and devices in

231
00:10:10,959 --> 00:10:11,839
qmil

232
00:10:11,839 --> 00:10:13,920
but that will take a great amount of

233
00:10:13,920 --> 00:10:16,079
resources to do so

234
00:10:16,079 --> 00:10:17,839
and it will require a very deep

235
00:10:17,839 --> 00:10:21,760
understanding of the target platform

236
00:10:21,920 --> 00:10:24,399
as we mentioned before we even tried to

237
00:10:24,399 --> 00:10:25,200
binary patch

238
00:10:25,200 --> 00:10:29,519
an entire graphics driver into the image

239
00:10:29,519 --> 00:10:32,640
however that took too much effort and we

240
00:10:32,640 --> 00:10:36,079
did not succeed by the end

241
00:10:37,680 --> 00:10:40,480
so from our first failed attempt we

242
00:10:40,480 --> 00:10:42,399
learned that assuming we can accumulate

243
00:10:42,399 --> 00:10:45,440
any image is a very naive approach

244
00:10:45,440 --> 00:10:47,360
and we will met with failure most of the

245
00:10:47,360 --> 00:10:49,519
time

246
00:10:49,519 --> 00:10:51,040
so we came to the conclusion

247
00:10:51,040 --> 00:10:52,560
accumulating an image as

248
00:10:52,560 --> 00:10:56,479
is could be proven difficult

249
00:10:56,640 --> 00:10:58,720
should you go through go with binary

250
00:10:58,720 --> 00:10:59,839
patching path

251
00:10:59,839 --> 00:11:02,560
you will need to have some deep

252
00:11:02,560 --> 00:11:03,120
knowledge

253
00:11:03,120 --> 00:11:06,240
about the target platform and

254
00:11:06,240 --> 00:11:09,360
at this point the amount of binary

255
00:11:09,360 --> 00:11:11,760
patching we have done to the image

256
00:11:11,760 --> 00:11:15,839
had made us very very uncomfortable

257
00:11:15,920 --> 00:11:17,920
so we cannot quite tell the difference

258
00:11:17,920 --> 00:11:19,920
between we are working hard or it is

259
00:11:19,920 --> 00:11:22,959
currently working

260
00:11:24,720 --> 00:11:27,279
then we have a round two apparently the

261
00:11:27,279 --> 00:11:28,399
method worked

262
00:11:28,399 --> 00:11:33,360
but not in a way we we was aiming for

263
00:11:34,800 --> 00:11:37,120
what we have learned from iran 1 is that

264
00:11:37,120 --> 00:11:38,959
we cannot go straight from firmware to

265
00:11:38,959 --> 00:11:41,360
accumulating

266
00:11:41,360 --> 00:11:43,440
however as we go deeper into this

267
00:11:43,440 --> 00:11:45,360
research we thought about if

268
00:11:45,360 --> 00:11:47,920
it's possible to port binaries from

269
00:11:47,920 --> 00:11:50,959
another image to our own image

270
00:11:50,959 --> 00:11:52,959
like we just pulled off the drivers and

271
00:11:52,959 --> 00:11:54,880
libraries and bundle them with our own

272
00:11:54,880 --> 00:11:57,120
image

273
00:11:57,120 --> 00:11:59,760
before this research the method actually

274
00:11:59,760 --> 00:12:01,680
worked for another device

275
00:12:01,680 --> 00:12:05,760
based on c6 but for this device

276
00:12:05,760 --> 00:12:08,800
it employed architectures in c correctly

277
00:12:08,800 --> 00:12:10,800
and the binaries are integrated deeply

278
00:12:10,800 --> 00:12:11,839
with the image

279
00:12:11,839 --> 00:12:16,800
so the method did not authorize work

280
00:12:17,519 --> 00:12:20,639
precisely said the vendor actually

281
00:12:20,639 --> 00:12:22,399
involves system and kernel flags

282
00:12:22,399 --> 00:12:25,839
on other files

283
00:12:25,839 --> 00:12:28,959
so in achieve to in order to achieve our

284
00:12:28,959 --> 00:12:29,680
method

285
00:12:29,680 --> 00:12:31,760
we need to figure out that if we can

286
00:12:31,760 --> 00:12:33,839
extract drivers and files from

287
00:12:33,839 --> 00:12:37,279
c image bundle them into our own image

288
00:12:37,279 --> 00:12:40,000
and make the files actually run in our

289
00:12:40,000 --> 00:12:42,560
own image

290
00:12:43,440 --> 00:12:46,079
fortunately for extraction we can use

291
00:12:46,079 --> 00:12:49,360
eiei image fs

292
00:12:49,360 --> 00:12:51,839
for building our own image we have c6

293
00:12:51,839 --> 00:12:52,560
xdk

294
00:12:52,560 --> 00:12:55,040
which is based on microsoft studio and

295
00:12:55,040 --> 00:12:57,680
it is available to us

296
00:12:57,680 --> 00:13:00,480
however as we try to build our own image

297
00:13:00,480 --> 00:13:02,399
with those extracted files

298
00:13:02,399 --> 00:13:05,200
the build actually succeed but ce

299
00:13:05,200 --> 00:13:06,000
crashed it right

300
00:13:06,000 --> 00:13:09,600
away as we booted it up

301
00:13:11,360 --> 00:13:14,639
so we were very confused we wonder why

302
00:13:14,639 --> 00:13:16,160
it crashes so hard

303
00:13:16,160 --> 00:13:19,120
and it crashes on a very early stage of

304
00:13:19,120 --> 00:13:21,600
booting process

305
00:13:21,600 --> 00:13:24,000
then we take a deeper look into source

306
00:13:24,000 --> 00:13:25,360
code of c kernel

307
00:13:25,360 --> 00:13:30,160
and its application loader at this point

308
00:13:30,160 --> 00:13:33,680
we were we were thinking about if ce

309
00:13:33,680 --> 00:13:35,839
should look like an nd kernel it turns

310
00:13:35,839 --> 00:13:36,800
out turns out

311
00:13:36,800 --> 00:13:39,040
not

312
00:13:39,920 --> 00:13:43,199
the application loader in c6 is like

313
00:13:43,199 --> 00:13:43,920
what is it

314
00:13:43,920 --> 00:13:46,959
what it is on empty will parse p header

315
00:13:46,959 --> 00:13:48,320
loading libraries

316
00:13:48,320 --> 00:13:50,880
allocate a size of memory and jump to

317
00:13:50,880 --> 00:13:51,600
binary's

318
00:13:51,600 --> 00:13:54,959
start address however there is a major

319
00:13:54,959 --> 00:13:57,120
difference in ce that makes our image

320
00:13:57,120 --> 00:13:58,800
approach crash

321
00:13:58,800 --> 00:14:03,199
in nte if a pe image a pe has its image

322
00:14:03,199 --> 00:14:03,760
space

323
00:14:03,760 --> 00:14:06,560
fixed and the address it asks for has

324
00:14:06,560 --> 00:14:07,839
been occupied

325
00:14:07,839 --> 00:14:09,920
the kernel should check if the pe does

326
00:14:09,920 --> 00:14:12,000
have a relocation directory

327
00:14:12,000 --> 00:14:15,120
if it doesn't exist it should not load

328
00:14:15,120 --> 00:14:18,160
the pe and should go to fail

329
00:14:18,160 --> 00:14:20,639
if a directory exists then the kernel

330
00:14:20,639 --> 00:14:21,920
will assign a free

331
00:14:21,920 --> 00:14:25,199
address then do relocation

332
00:14:25,199 --> 00:14:27,680
in windows c the behavior is very

333
00:14:27,680 --> 00:14:28,800
bizarre

334
00:14:28,800 --> 00:14:30,560
if a pe does not have relocation

335
00:14:30,560 --> 00:14:32,880
directory it will still load the binary

336
00:14:32,880 --> 00:14:36,000
in a free address and run it

337
00:14:36,000 --> 00:14:38,639
this will outright crash the system in

338
00:14:38,639 --> 00:14:39,440
most cases

339
00:14:39,440 --> 00:14:42,839
as it could imply tons of segmentation

340
00:14:42,839 --> 00:14:45,839
violation

341
00:14:46,720 --> 00:14:48,959
so we have a wonderful graphical

342
00:14:48,959 --> 00:14:51,040
representation of what will happen

343
00:14:51,040 --> 00:14:52,880
should we automatically move a fixed

344
00:14:52,880 --> 00:14:56,000
address binary function image to another

345
00:14:56,000 --> 00:14:58,320
in most cases our custom image will not

346
00:14:58,320 --> 00:15:00,720
have the same address as our target

347
00:15:00,720 --> 00:15:02,800
and will likely have tools for debugging

348
00:15:02,800 --> 00:15:05,359
purposes

349
00:15:05,680 --> 00:15:08,320
if we just move binary from one image to

350
00:15:08,320 --> 00:15:09,120
another

351
00:15:09,120 --> 00:15:11,040
most likely an address conflict will

352
00:15:11,040 --> 00:15:13,839
occur

353
00:15:13,839 --> 00:15:16,560
and everything will explode yes most of

354
00:15:16,560 --> 00:15:18,160
the time it will outright crash the

355
00:15:18,160 --> 00:15:19,040
system

356
00:15:19,040 --> 00:15:22,320
if it just works in your case there are

357
00:15:22,320 --> 00:15:24,079
two possibilities

358
00:15:24,079 --> 00:15:25,920
either the binary does not have its

359
00:15:25,920 --> 00:15:27,680
address fixed and it does have a

360
00:15:27,680 --> 00:15:28,800
relocation

361
00:15:28,800 --> 00:15:32,079
directory or you are having a very good

362
00:15:32,079 --> 00:15:32,720
luck

363
00:15:32,720 --> 00:15:36,800
of not having an address conflict

364
00:15:39,199 --> 00:15:41,360
and let's take a quick look about c6

365
00:15:41,360 --> 00:15:42,320
memory

366
00:15:42,320 --> 00:15:45,680
management in c6 unlike c5

367
00:15:45,680 --> 00:15:49,120
it does not use a concept of slots

368
00:15:49,120 --> 00:15:52,639
in c6 any process has a one gigabyte of

369
00:15:52,639 --> 00:15:54,800
virtual memories

370
00:15:54,800 --> 00:15:57,279
also the flashes are usually executed in

371
00:15:57,279 --> 00:15:59,600
place to save loading loading times

372
00:15:59,600 --> 00:16:01,759
that would imply most drivers and

373
00:16:01,759 --> 00:16:03,360
frequently used pe

374
00:16:03,360 --> 00:16:05,839
will have fixed addresses in the memory

375
00:16:05,839 --> 00:16:09,839
and also in the image

376
00:16:11,839 --> 00:16:14,639
and we should talk about how c6 image is

377
00:16:14,639 --> 00:16:16,480
bundled

378
00:16:16,480 --> 00:16:19,199
in c6 when an image is built with visual

379
00:16:19,199 --> 00:16:20,079
studio

380
00:16:20,079 --> 00:16:22,320
any essential segments from the binary

381
00:16:22,320 --> 00:16:24,320
is stripped just before it's bundled in

382
00:16:24,320 --> 00:16:27,279
into the image as the image builder

383
00:16:27,279 --> 00:16:29,040
already figured out a proper address

384
00:16:29,040 --> 00:16:29,680
layout

385
00:16:29,680 --> 00:16:31,839
and a relocation directory is no longer

386
00:16:31,839 --> 00:16:34,560
needed at that point

387
00:16:34,560 --> 00:16:37,199
however in a step before bundling

388
00:16:37,199 --> 00:16:38,800
linking happens

389
00:16:38,800 --> 00:16:41,440
and we need a relocation directory to

390
00:16:41,440 --> 00:16:42,079
link it

391
00:16:42,079 --> 00:16:45,439
against other libraries

392
00:16:47,199 --> 00:16:50,480
so to achieve what we want to do

393
00:16:50,480 --> 00:16:54,240
we came to some conclusions

394
00:16:54,240 --> 00:16:56,240
we must reconstruct the relocation

395
00:16:56,240 --> 00:16:57,519
directory as

396
00:16:57,519 --> 00:16:59,920
it is required for us to bundle the

397
00:16:59,920 --> 00:17:05,839
image into our custom image

398
00:17:07,199 --> 00:17:09,520
we then came up with how to actually

399
00:17:09,520 --> 00:17:11,119
implement our approach

400
00:17:11,119 --> 00:17:13,439
we call this static reconstruction of

401
00:17:13,439 --> 00:17:14,959
relocation information

402
00:17:14,959 --> 00:17:19,520
in pe

403
00:17:19,520 --> 00:17:21,520
this kind of approach actually has a

404
00:17:21,520 --> 00:17:23,280
prior art

405
00:17:23,280 --> 00:17:26,639
which the link is below

406
00:17:26,799 --> 00:17:29,520
but it's for dynamic dynamic analysis

407
00:17:29,520 --> 00:17:30,000
only

408
00:17:30,000 --> 00:17:32,320
apparently we cannot run the binaries at

409
00:17:32,320 --> 00:17:33,039
this point

410
00:17:33,039 --> 00:17:36,080
so our approach must be done by static

411
00:17:36,080 --> 00:17:39,120
analysis only

412
00:17:41,039 --> 00:17:43,600
in our approach we actually know start

413
00:17:43,600 --> 00:17:44,320
and edge

414
00:17:44,320 --> 00:17:46,720
and address of each pe by looking into

415
00:17:46,720 --> 00:17:48,400
layer headers

416
00:17:48,400 --> 00:17:50,799
we theorize by scanning through entire

417
00:17:50,799 --> 00:17:52,320
binary

418
00:17:52,320 --> 00:17:54,080
and we look for references to the

419
00:17:54,080 --> 00:17:55,840
address into the range

420
00:17:55,840 --> 00:17:58,559
between start and end we can collect all

421
00:17:58,559 --> 00:18:00,240
of the addresses that needs to be

422
00:18:00,240 --> 00:18:02,720
relocated

423
00:18:02,720 --> 00:18:05,440
however for code and non-code segments

424
00:18:05,440 --> 00:18:07,360
they must be handled differently as

425
00:18:07,360 --> 00:18:08,160
their layout

426
00:18:08,160 --> 00:18:14,400
isn't quite the same

427
00:18:14,400 --> 00:18:17,200
for code segments we will try to locate

428
00:18:17,200 --> 00:18:19,360
all function epilog and prolog

429
00:18:19,360 --> 00:18:22,480
let it read through every function

430
00:18:22,480 --> 00:18:25,039
then we check for every instruction

431
00:18:25,039 --> 00:18:26,400
should the operand

432
00:18:26,400 --> 00:18:28,320
makes reference to the range between

433
00:18:28,320 --> 00:18:31,120
start and the end ended and address

434
00:18:31,120 --> 00:18:32,720
we will place that address into

435
00:18:32,720 --> 00:18:35,919
relocation directory

436
00:18:36,880 --> 00:18:39,280
for non-code segments it will be quite

437
00:18:39,280 --> 00:18:40,960
simple

438
00:18:40,960 --> 00:18:42,799
these kind of segments will contain

439
00:18:42,799 --> 00:18:46,080
things like v table and string tables

440
00:18:46,080 --> 00:18:49,919
and in the case of both microsoft visual

441
00:18:49,919 --> 00:18:51,919
visual studio compiler and volume

442
00:18:51,919 --> 00:18:54,400
compilers they are both convenient

443
00:18:54,400 --> 00:18:57,200
conveniently aligned so we can just scan

444
00:18:57,200 --> 00:18:58,080
through the scan

445
00:18:58,080 --> 00:19:01,280
segments with a four byte interval and

446
00:19:01,280 --> 00:19:05,120
check if any bytes matches the range

447
00:19:05,120 --> 00:19:07,360
this could be a very poor approach but

448
00:19:07,360 --> 00:19:08,160
it actually

449
00:19:08,160 --> 00:19:11,840
worked quite well

450
00:19:14,320 --> 00:19:19,039
and after our couple approaches

451
00:19:19,039 --> 00:19:21,360
we figured out that something is still

452
00:19:21,360 --> 00:19:22,160
not right

453
00:19:22,160 --> 00:19:24,480
because we're still having crashes while

454
00:19:24,480 --> 00:19:27,840
booting up the binaries

455
00:19:27,919 --> 00:19:31,039
so we take a quick compare compare

456
00:19:31,039 --> 00:19:34,160
against normal normal binaries and

457
00:19:34,160 --> 00:19:35,760
figure out that we're still missing a

458
00:19:35,760 --> 00:19:36,080
ton

459
00:19:36,080 --> 00:19:40,640
of entries so the devil

460
00:19:40,640 --> 00:19:43,679
is in import address table it is

461
00:19:43,679 --> 00:19:45,039
possible to reference an

462
00:19:45,039 --> 00:19:48,320
import by a name or by ordinal if

463
00:19:48,320 --> 00:19:52,320
it's referencing an import by the name

464
00:19:52,320 --> 00:19:54,640
then it will store a pointer to

465
00:19:54,640 --> 00:19:55,919
character array

466
00:19:55,919 --> 00:19:58,240
and that address must be put into

467
00:19:58,240 --> 00:20:01,360
relocation directory

468
00:20:03,280 --> 00:20:06,400
after we have harvested most if not all

469
00:20:06,400 --> 00:20:09,120
of the address we can now finally

470
00:20:09,120 --> 00:20:10,799
rebuild the location directory

471
00:20:10,799 --> 00:20:13,600
according to this struct and write it

472
00:20:13,600 --> 00:20:14,000
back

473
00:20:14,000 --> 00:20:16,960
into the binary

474
00:20:18,000 --> 00:20:21,840
so here we here we will go to our demo

475
00:20:21,840 --> 00:20:23,760
we will call this rerun your device

476
00:20:23,760 --> 00:20:26,720
without your hardware

477
00:20:26,720 --> 00:20:35,360
so let me try to locate the window

478
00:20:35,360 --> 00:20:37,360
hello and welcome to your demo for

479
00:20:37,360 --> 00:20:39,440
reconstructing your location information

480
00:20:39,440 --> 00:20:41,200
in pe

481
00:20:41,200 --> 00:20:43,440
here we have a list of files extracted

482
00:20:43,440 --> 00:20:44,480
from the phone where you

483
00:20:44,480 --> 00:20:46,960
are emulating the files has been

484
00:20:46,960 --> 00:20:49,039
pre-processed to remove unnecessary

485
00:20:49,039 --> 00:20:49,760
segments

486
00:20:49,760 --> 00:20:52,400
and being extracted from a ce image they

487
00:20:52,400 --> 00:20:54,000
naturally don't have a relocation

488
00:20:54,000 --> 00:20:56,720
directory

489
00:20:56,960 --> 00:21:00,799
here we can prove this from the cff

490
00:21:00,840 --> 00:21:03,280
explorer

491
00:21:03,280 --> 00:21:05,840
the relocation directory is required for

492
00:21:05,840 --> 00:21:07,440
us to put these files back

493
00:21:07,440 --> 00:21:09,600
into visual studio and bundle it with

494
00:21:09,600 --> 00:21:16,320
our own image

495
00:21:16,320 --> 00:21:19,440
here we will run a script which

496
00:21:19,440 --> 00:21:21,600
basically iterates through the files

497
00:21:21,600 --> 00:21:23,679
running either piper script with our own

498
00:21:23,679 --> 00:21:25,039
search algorithm

499
00:21:25,039 --> 00:21:26,880
against the files to determine the

500
00:21:26,880 --> 00:21:28,320
addresses need to put

501
00:21:28,320 --> 00:21:31,360
into relocation directory

502
00:21:31,360 --> 00:21:33,679
as the process goes the list of

503
00:21:33,679 --> 00:21:34,640
addresses

504
00:21:34,640 --> 00:21:39,440
looped into relocation will be generated

505
00:21:41,679 --> 00:21:44,240
this process is very slow so we'll fast

506
00:21:44,240 --> 00:21:46,080
forward to recreating relocation

507
00:21:46,080 --> 00:21:48,559
directory in the binaries with this list

508
00:21:48,559 --> 00:21:52,320
of addresses now we are going to

509
00:21:52,320 --> 00:21:54,159
recreate relocation directory

510
00:21:54,159 --> 00:21:56,840
and write them into the files using pe

511
00:21:56,840 --> 00:21:59,840
file

512
00:22:04,799 --> 00:22:06,720
appear resolver writing will fail as

513
00:22:06,720 --> 00:22:09,120
this is a very early version of the poc

514
00:22:09,120 --> 00:22:11,440
but it still allows us to run some of

515
00:22:11,440 --> 00:22:12,720
our song firmware

516
00:22:12,720 --> 00:22:14,240
some other files will still have

517
00:22:14,240 --> 00:22:16,159
relocation information attached

518
00:22:16,159 --> 00:22:18,080
as they are not in compiled with

519
00:22:18,080 --> 00:22:19,600
specific facts

520
00:22:19,600 --> 00:22:21,520
hence their relocation is not stripped

521
00:22:21,520 --> 00:22:23,520
in the original image

522
00:22:23,520 --> 00:22:25,440
once the writing is done we will rebuild

523
00:22:25,440 --> 00:22:27,440
the image with visual studio and run

524
00:22:27,440 --> 00:22:30,320
image afterwards

525
00:22:31,520 --> 00:22:33,600
in visual studio we attach our auto

526
00:22:33,600 --> 00:22:35,039
files into the manifest

527
00:22:35,039 --> 00:22:37,120
so image builder will include the files

528
00:22:37,120 --> 00:22:38,240
which our target is

529
00:22:38,240 --> 00:22:41,280
required to use later in our research

530
00:22:41,280 --> 00:22:43,120
we figured out that we don't have to

531
00:22:43,120 --> 00:22:45,280
attach all of the reconstructor files to

532
00:22:45,280 --> 00:22:47,360
achieve our target

533
00:22:47,360 --> 00:22:50,399
let's start building

534
00:22:50,480 --> 00:22:52,720
the building process is very slow so

535
00:22:52,720 --> 00:22:56,480
we'll fast forward to emulation

536
00:22:58,080 --> 00:23:00,000
now we will try around the target in our

537
00:23:00,000 --> 00:23:03,200
own blue image using qmu

538
00:23:03,200 --> 00:23:05,120
as the target requires some auxiliary

539
00:23:05,120 --> 00:23:06,400
files such as

540
00:23:06,400 --> 00:23:08,960
resources will copy them from elsewhere

541
00:23:08,960 --> 00:23:12,080
to its destination

542
00:23:20,799 --> 00:23:22,640
now we have the working side as you can

543
00:23:22,640 --> 00:23:24,799
see we are succeeded

544
00:23:24,799 --> 00:23:27,440
in emulating a binary from our target

545
00:23:27,440 --> 00:23:29,840
device

546
00:23:29,840 --> 00:23:32,480
however however in in this case we

547
00:23:32,480 --> 00:23:33,840
haven't

548
00:23:33,840 --> 00:23:36,000
there are some restrictions on the

549
00:23:36,000 --> 00:23:37,760
target devices binary

550
00:23:37,760 --> 00:23:40,960
that we haven't got through it yet so

551
00:23:40,960 --> 00:23:42,799
the binary actually checks for some type

552
00:23:42,799 --> 00:23:43,919
of license files

553
00:23:43,919 --> 00:23:47,679
and we still haven't binary page files

554
00:23:47,679 --> 00:23:51,360
and in the case if the demo video

555
00:23:51,360 --> 00:23:52,320
doesn't go quite

556
00:23:52,320 --> 00:23:55,039
smooth through zoom calls i will just

557
00:23:55,039 --> 00:23:55,520
paste

558
00:23:55,520 --> 00:23:59,039
the demo video onto youtube after the

559
00:23:59,039 --> 00:23:59,440
talk

560
00:23:59,440 --> 00:24:01,840
finished

561
00:24:03,200 --> 00:24:06,480
and here here will be a much clearer

562
00:24:06,480 --> 00:24:07,679
image

563
00:24:07,679 --> 00:24:10,880
to show everyone that we can actually do

564
00:24:10,880 --> 00:24:19,840
a firmware simulation in qmu

565
00:24:21,200 --> 00:24:24,720
so without method you can totally run

566
00:24:24,720 --> 00:24:26,480
bundle c6 binaries

567
00:24:26,480 --> 00:24:29,520
without hardware

568
00:24:30,640 --> 00:24:32,320
by using this method you will have

569
00:24:32,320 --> 00:24:34,640
access to tons of debug tools

570
00:24:34,640 --> 00:24:37,760
such as ktl you will have 0 outputs

571
00:24:37,760 --> 00:24:41,039
which is very quite useful and you have

572
00:24:41,039 --> 00:24:45,760
you can use windpg in our method

573
00:24:45,760 --> 00:24:48,799
it is around 98 accuracy

574
00:24:48,799 --> 00:24:51,679
which is good enough to run most of the

575
00:24:51,679 --> 00:24:54,320
binaries

576
00:24:54,400 --> 00:24:58,159
we we know it's 98 because we compared

577
00:24:58,159 --> 00:24:58,480
it

578
00:24:58,480 --> 00:25:00,799
with original binary let's drift the

579
00:25:00,799 --> 00:25:02,720
binary of relocation directory

580
00:25:02,720 --> 00:25:05,440
and ring construct those binaries

581
00:25:05,440 --> 00:25:06,240
relocation

582
00:25:06,240 --> 00:25:09,440
directory and compare the counts

583
00:25:09,440 --> 00:25:12,320
inside relock

584
00:25:12,480 --> 00:25:15,600
we plan to open source the tools we use

585
00:25:15,600 --> 00:25:19,919
later on because the code is written in

586
00:25:19,919 --> 00:25:21,279
a poc style

587
00:25:21,279 --> 00:25:23,200
it is essentially a pile of spaghetti

588
00:25:23,200 --> 00:25:25,360
right now

589
00:25:25,360 --> 00:25:27,679
hence we will publish it after we clean

590
00:25:27,679 --> 00:25:31,919
it up while making our accuracy higher

591
00:25:34,080 --> 00:25:36,720
and we will come to some suggestions for

592
00:25:36,720 --> 00:25:40,000
vendors and remarks

593
00:25:40,000 --> 00:25:42,320
for this particular vendor a proprietary

594
00:25:42,320 --> 00:25:43,600
format is used

595
00:25:43,600 --> 00:25:46,320
to pack firmware it is quite difficult

596
00:25:46,320 --> 00:25:47,520
to dissect

597
00:25:47,520 --> 00:25:50,640
however we did prevail and we did right

598
00:25:50,640 --> 00:25:52,720
that we did wrote a dissector to

599
00:25:52,720 --> 00:25:56,159
extract files and see image

600
00:25:56,159 --> 00:25:58,640
so anything bundled within firmware will

601
00:25:58,640 --> 00:26:02,080
be extracted and being looked at

602
00:26:02,080 --> 00:26:04,400
and we have proven many times any

603
00:26:04,400 --> 00:26:05,679
proprietary format

604
00:26:05,679 --> 00:26:07,919
does not preventing anyone from breaking

605
00:26:07,919 --> 00:26:10,960
into your system

606
00:26:10,960 --> 00:26:13,120
and we encourage vendors to have a

607
00:26:13,120 --> 00:26:15,520
friendly community and research outreach

608
00:26:15,520 --> 00:26:19,440
we think this approach is very noble

609
00:26:20,880 --> 00:26:24,159
and for our future work in this project

610
00:26:24,159 --> 00:26:27,679
yes we will try to combine this research

611
00:26:27,679 --> 00:26:30,320
with any father should the father runs

612
00:26:30,320 --> 00:26:31,120
on ce

613
00:26:31,120 --> 00:26:33,520
or we have figured out a way to not port

614
00:26:33,520 --> 00:26:36,320
it to c but still make it work

615
00:26:36,320 --> 00:26:38,960
for simple programs there's a project

616
00:26:38,960 --> 00:26:41,120
called wc compat which is like

617
00:26:41,120 --> 00:26:43,120
using wine on linux to run windows

618
00:26:43,120 --> 00:26:45,360
programs it is a

619
00:26:45,360 --> 00:26:49,200
windows c compatibility layer

620
00:26:49,200 --> 00:26:52,320
and during our research we have

621
00:26:52,320 --> 00:26:54,640
came across a book which helps us very

622
00:26:54,640 --> 00:26:55,360
much

623
00:26:55,360 --> 00:26:57,679
so we have we have to say a very big

624
00:26:57,679 --> 00:26:58,400
thanks

625
00:26:58,400 --> 00:27:02,720
to pavlok and biolevski

626
00:27:02,720 --> 00:27:04,960
and also thanks to microsoft for shared

627
00:27:04,960 --> 00:27:06,400
source initiative

628
00:27:06,400 --> 00:27:09,120
although we might prefer open source but

629
00:27:09,120 --> 00:27:10,960
for this project it will be next to

630
00:27:10,960 --> 00:27:12,320
impossible to achieve

631
00:27:12,320 --> 00:27:15,600
a research with update

632
00:27:16,320 --> 00:27:19,760
so that will conclude most of my talk

633
00:27:19,760 --> 00:27:20,720
and for

634
00:27:20,720 --> 00:27:23,200
questions you can actually send them to

635
00:27:23,200 --> 00:27:25,279
my work email and i will try my best to

636
00:27:25,279 --> 00:27:35,840
reply to the questions

637
00:27:41,200 --> 00:27:43,440
friends if you have any questions please

638
00:27:43,440 --> 00:27:44,640
send them across via

639
00:27:44,640 --> 00:27:49,120
zoom chat uh so

640
00:27:49,120 --> 00:27:52,959
are the questions in the chat right now

641
00:27:53,360 --> 00:27:56,080
uh no i don't see any questions right

642
00:27:56,080 --> 00:27:56,559
now

643
00:27:56,559 --> 00:27:59,760
in the zoom chat yeah i

644
00:27:59,760 --> 00:28:04,320
i was worried about if my demo video did

645
00:28:04,320 --> 00:28:08,399
have audio inside your zoom call

646
00:28:13,200 --> 00:28:15,279
yeah it did at least for me i do not

647
00:28:15,279 --> 00:28:16,720
know about the rest

648
00:28:16,720 --> 00:28:19,279
ah nice if if you would like to play it

649
00:28:19,279 --> 00:28:20,080
again you can

650
00:28:20,080 --> 00:28:24,000
uh there's an option uh in the

651
00:28:24,000 --> 00:28:26,000
when you share your screen uh to enable

652
00:28:26,000 --> 00:28:27,840
uh audio video

653
00:28:27,840 --> 00:28:29,600
optimization if you would like to play

654
00:28:29,600 --> 00:28:30,960
it again

655
00:28:30,960 --> 00:28:32,480
i would just paste the video onto

656
00:28:32,480 --> 00:28:35,440
youtube after the talk is over

657
00:28:35,440 --> 00:28:39,520
that's that's also fine with us

658
00:28:40,480 --> 00:28:44,320
okay uh friends uh any questions

659
00:28:44,320 --> 00:28:47,120
uh time is kick kicking otherwise we

660
00:28:47,120 --> 00:28:48,080
could open

661
00:28:48,080 --> 00:28:51,918
for the coffee break now

662
00:28:55,279 --> 00:28:58,720
all right talu there are no questions uh

663
00:28:58,720 --> 00:29:00,799
as of now but friends this talk will be

664
00:29:00,799 --> 00:29:01,760
recorded and

665
00:29:01,760 --> 00:29:03,360
is going to be uploaded on our youtube

666
00:29:03,360 --> 00:29:05,840
channel so you could also refer to it

667
00:29:05,840 --> 00:29:06,559
later

668
00:29:06,559 --> 00:29:09,520
uh the video uh of the demo will be also

669
00:29:09,520 --> 00:29:10,080
posted

670
00:29:10,080 --> 00:29:12,559
on the youtube channel so y'all can view

671
00:29:12,559 --> 00:29:13,200
it and

672
00:29:13,200 --> 00:29:15,279
if you have any questions uh talu has

673
00:29:15,279 --> 00:29:17,200
mentioned his email address as well

674
00:29:17,200 --> 00:29:18,880
uh so you can talk to him and contact

675
00:29:18,880 --> 00:29:20,799
him directly as well

676
00:29:20,799 --> 00:29:22,880
thank you so much talu for sharing your

677
00:29:22,880 --> 00:29:24,320
experience and learning with us

678
00:29:24,320 --> 00:29:38,000
at hardware.org usa 2021 edition

