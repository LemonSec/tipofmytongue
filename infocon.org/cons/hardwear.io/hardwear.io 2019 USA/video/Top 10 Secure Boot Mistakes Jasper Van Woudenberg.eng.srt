1
00:00:04,420 --> 00:00:09,520
yes the things everyone and also things

2
00:00:06,250 --> 00:00:13,629
for the conference to invite me to give

3
00:00:09,520 --> 00:00:16,270
this talk so my name is Jasper I've been

4
00:00:13,630 --> 00:00:19,779
doing security work for about 20 or so

5
00:00:16,270 --> 00:00:20,920
years now professionally seeing lots of

6
00:00:19,779 --> 00:00:25,630
different things from software to

7
00:00:20,920 --> 00:00:27,420
hardware for the last since about 2006

8
00:00:25,630 --> 00:00:29,799
seven I've been working with risk here

9
00:00:27,420 --> 00:00:32,140
where we focus a lot on embedded

10
00:00:29,800 --> 00:00:35,710
security and in that space we see a lot

11
00:00:32,140 --> 00:00:37,180
of secure boot roms specifically we see

12
00:00:35,710 --> 00:00:37,809
the code and we see everything that goes

13
00:00:37,180 --> 00:00:40,450
wrong there

14
00:00:37,809 --> 00:00:43,780
now just like Olivier I have a stack of

15
00:00:40,450 --> 00:00:46,420
NDA's on my desk so I'm going to take

16
00:00:43,780 --> 00:00:49,690
the things that we see but I'm giving

17
00:00:46,420 --> 00:00:51,520
you the public examples of what way you

18
00:00:49,690 --> 00:00:55,480
can look up high where other people have

19
00:00:51,520 --> 00:00:58,989
found things and publish these things so

20
00:00:55,480 --> 00:01:00,489
I'll first go a little bit but I won't

21
00:00:58,989 --> 00:01:02,379
bore you too long with it but go a

22
00:01:00,489 --> 00:01:03,760
little bit on the theory behind secure

23
00:01:02,379 --> 00:01:06,460
booth and what does it do and what it

24
00:01:03,760 --> 00:01:12,720
should it do and then I'll go into sort

25
00:01:06,460 --> 00:01:17,380
of the top ten things that we've seen so

26
00:01:12,720 --> 00:01:19,119
the idea behind secure boot is that we

27
00:01:17,380 --> 00:01:21,100
try to make sure that all the code

28
00:01:19,119 --> 00:01:24,130
that's running on a platform has

29
00:01:21,100 --> 00:01:26,589
actually been signed and authenticated

30
00:01:24,130 --> 00:01:28,780
in other words a manufacturer is trying

31
00:01:26,590 --> 00:01:31,299
to make sure that it's just their code

32
00:01:28,780 --> 00:01:32,860
that's running on the platform and the

33
00:01:31,299 --> 00:01:35,290
way that this is done is we start with

34
00:01:32,860 --> 00:01:37,840
an internal boot ROM and we've seen from

35
00:01:35,290 --> 00:01:40,930
krisis roughly what that means in

36
00:01:37,840 --> 00:01:43,990
silicon but the internal boot ROM will

37
00:01:40,930 --> 00:01:46,899
have a part of the program there does a

38
00:01:43,990 --> 00:01:50,079
digital signature verification over some

39
00:01:46,899 --> 00:01:53,649
usually flash image let's go to boot

40
00:01:50,079 --> 00:01:56,139
next that move do other initialization

41
00:01:53,649 --> 00:01:58,149
and then check the signature for the

42
00:01:56,140 --> 00:02:00,130
next stage and so it goes all the way

43
00:01:58,149 --> 00:02:04,110
down to like an operating system and

44
00:02:00,130 --> 00:02:04,110
then sometimes even applications and

45
00:02:04,259 --> 00:02:08,619
when you're going through this chain the

46
00:02:06,670 --> 00:02:11,230
privileges that that code has on the

47
00:02:08,619 --> 00:02:13,239
platform usually go down so one of the

48
00:02:11,230 --> 00:02:15,700
tasks of each of these phases tools to

49
00:02:13,239 --> 00:02:17,500
further lock down a fir to configure

50
00:02:15,700 --> 00:02:19,660
the device until it sort of ends up in

51
00:02:17,500 --> 00:02:25,110
the end state where the applications are

52
00:02:19,660 --> 00:02:27,880
safely sandboxed yeah so some common

53
00:02:25,110 --> 00:02:30,880
steps that you see here is there's

54
00:02:27,880 --> 00:02:32,859
always some sort of internal boot rom if

55
00:02:30,880 --> 00:02:35,470
you're talking about mobile phones for

56
00:02:32,860 --> 00:02:36,700
instance typically in the first stages

57
00:02:35,470 --> 00:02:40,630
you'll have the trusted execution

58
00:02:36,700 --> 00:02:42,790
environment being set up no later comes

59
00:02:40,630 --> 00:02:47,170
Linux and applications for instance in

60
00:02:42,790 --> 00:02:49,209
the Android space but besides secure

61
00:02:47,170 --> 00:02:53,019
boots a lot of other things happen

62
00:02:49,209 --> 00:02:55,300
during platform initialization so we are

63
00:02:53,020 --> 00:02:57,910
doing things like locking down memory so

64
00:02:55,300 --> 00:03:01,090
configuring in an Ambu or in an MMU

65
00:02:57,910 --> 00:03:05,320
which ranges can be can be used for code

66
00:03:01,090 --> 00:03:09,340
data what peripherals can access what

67
00:03:05,320 --> 00:03:11,350
parts etc so usually when the platform

68
00:03:09,340 --> 00:03:13,989
comes up in the initial State everything

69
00:03:11,350 --> 00:03:16,120
can access everything so it needs to be

70
00:03:13,989 --> 00:03:18,840
locked down so that's one other thing

71
00:03:16,120 --> 00:03:20,860
that's happening another thing is that

72
00:03:18,840 --> 00:03:24,130
there's usually a lot of configuration

73
00:03:20,860 --> 00:03:27,250
data so these these roms they're not

74
00:03:24,130 --> 00:03:28,720
unique for one product they make one ROM

75
00:03:27,250 --> 00:03:33,010
and it's used in a lot of different

76
00:03:28,720 --> 00:03:36,010
products so the ROM will read out these

77
00:03:33,010 --> 00:03:40,200
OTP is one-time programmable bits and it

78
00:03:36,010 --> 00:03:42,989
will do things depending on that OTP so

79
00:03:40,200 --> 00:03:45,820
in other cases there might also be like

80
00:03:42,989 --> 00:03:50,650
embedded files that have a configuration

81
00:03:45,820 --> 00:03:53,829
and it will act according to that roms

82
00:03:50,650 --> 00:03:56,670
are also used typically in manufacturing

83
00:03:53,829 --> 00:03:59,230
so imagine you're manufacturing a device

84
00:03:56,670 --> 00:04:00,850
once the silicon wafer is made you have

85
00:03:59,230 --> 00:04:02,828
the ROM in there but you have nothing in

86
00:04:00,850 --> 00:04:04,690
your flash or your EEPROM or eating in

87
00:04:02,829 --> 00:04:07,090
your fuses so that all needs to be

88
00:04:04,690 --> 00:04:08,890
initialized during manufacturing so with

89
00:04:07,090 --> 00:04:11,049
in ROM there's usually different modes

90
00:04:08,890 --> 00:04:13,899
that are only used during manufacturing

91
00:04:11,049 --> 00:04:15,640
to initialize all these bits so for

92
00:04:13,900 --> 00:04:17,649
instance it will download the firmware

93
00:04:15,640 --> 00:04:20,079
that comes from manufacturing line which

94
00:04:17,649 --> 00:04:24,460
will program the final firmware program

95
00:04:20,079 --> 00:04:26,860
the OTP etc then there's a bunch of

96
00:04:24,460 --> 00:04:30,650
debugging

97
00:04:26,860 --> 00:04:33,260
facilities in somewhere Noguchi so that

98
00:04:30,650 --> 00:04:35,239
in the field you can debug what's going

99
00:04:33,260 --> 00:04:36,469
on like my device crash you send it back

100
00:04:35,240 --> 00:04:39,800
to the manufacturer they want to know

101
00:04:36,470 --> 00:04:42,650
what's what's what's up and also for

102
00:04:39,800 --> 00:04:46,760
infield servicing sometimes for firmware

103
00:04:42,650 --> 00:04:50,239
upgrades then decides that there's also

104
00:04:46,760 --> 00:04:51,980
different power modes so when you you

105
00:04:50,240 --> 00:04:53,780
know when you cold boot to your laptop

106
00:04:51,980 --> 00:04:56,720
but then later on you close it and it

107
00:04:53,780 --> 00:04:58,489
falls asleep they open it back up it

108
00:04:56,720 --> 00:05:00,500
goes through a different execution pass

109
00:04:58,490 --> 00:05:04,520
that wrong so it's actually trying to

110
00:05:00,500 --> 00:05:06,290
speed up that execution so a lot of sort

111
00:05:04,520 --> 00:05:08,539
of shortcuts need to be taken and if

112
00:05:06,290 --> 00:05:12,070
those shortcuts are badly implemented

113
00:05:08,540 --> 00:05:15,140
you might affect security as well so

114
00:05:12,070 --> 00:05:17,240
these boot codes that have to support

115
00:05:15,140 --> 00:05:19,940
many different use cases they're

116
00:05:17,240 --> 00:05:21,200
constrained in power and time it's

117
00:05:19,940 --> 00:05:24,350
actually quite an engineering challenge

118
00:05:21,200 --> 00:05:26,860
to get it right so that's sort of the

119
00:05:24,350 --> 00:05:32,210
prelude to why why these things go wrong

120
00:05:26,860 --> 00:05:33,910
so let me now take ten different themes

121
00:05:32,210 --> 00:05:40,370
that we've seen over the years and

122
00:05:33,910 --> 00:05:44,270
explain them to you so this is this is

123
00:05:40,370 --> 00:05:47,810
actually the the chain of trust in an

124
00:05:44,270 --> 00:05:49,669
Android boot platform and what you see

125
00:05:47,810 --> 00:05:51,530
here is something called the PBL the

126
00:05:49,669 --> 00:05:55,640
primary bootloader which is ROM code

127
00:05:51,530 --> 00:05:58,280
that then checks the second stage which

128
00:05:55,640 --> 00:06:00,229
is the secondary bootloader which ticks

129
00:05:58,280 --> 00:06:03,739
Android boot which takes the trust zone

130
00:06:00,229 --> 00:06:05,330
kernel and the resource power manager

131
00:06:03,740 --> 00:06:08,810
and the power management I see all these

132
00:06:05,330 --> 00:06:11,200
different things gets get checked but in

133
00:06:08,810 --> 00:06:13,460
this case what went wrong is that

134
00:06:11,200 --> 00:06:17,300
somehow for some reason and they never

135
00:06:13,460 --> 00:06:19,729
figured out exactly why but the SVL was

136
00:06:17,300 --> 00:06:23,570
signed but that sacred service is never

137
00:06:19,729 --> 00:06:28,150
checked so you could replace the SBL and

138
00:06:23,570 --> 00:06:32,000
just boot boot your own code here so

139
00:06:28,150 --> 00:06:34,969
this is a theme that we see and such we

140
00:06:32,000 --> 00:06:37,849
call it verification mistakes so if

141
00:06:34,970 --> 00:06:40,479
something is not signed what is it

142
00:06:37,849 --> 00:06:43,599
actually used for

143
00:06:40,479 --> 00:06:45,938
and you start seeing problems for

144
00:06:43,599 --> 00:06:48,128
instance when there are firmer firmer so

145
00:06:45,939 --> 00:06:50,500
that might be signed but for instance

146
00:06:48,129 --> 00:06:52,389
they forgot to sign the header like the

147
00:06:50,500 --> 00:06:56,080
load address or something is wrong or

148
00:06:52,389 --> 00:06:58,270
the side is wrong at that point you

149
00:06:56,080 --> 00:07:00,909
might be able to get into the system

150
00:06:58,270 --> 00:07:03,240
just by manipulating those those fields

151
00:07:00,909 --> 00:07:05,650
so the failures really to start

152
00:07:03,240 --> 00:07:07,419
interpreting information that you get

153
00:07:05,650 --> 00:07:11,080
that's the tacker controlled before

154
00:07:07,419 --> 00:07:13,030
you've properly verified it there's a

155
00:07:11,080 --> 00:07:15,758
bunch of examples so now all these I'll

156
00:07:13,030 --> 00:07:16,989
publish the slides later I'll guess

157
00:07:15,759 --> 00:07:19,719
they'll end up on the website for

158
00:07:16,990 --> 00:07:22,629
Hardware die oh I'm not sure I hear yes

159
00:07:19,719 --> 00:07:25,030
somewhere yes so you can click on these

160
00:07:22,629 --> 00:07:30,849
links and read up on and all of these

161
00:07:25,030 --> 00:07:35,289
examples but really just sign everything

162
00:07:30,849 --> 00:07:37,840
that you can if you can and don't use

163
00:07:35,289 --> 00:07:40,180
any data before you've actually checked

164
00:07:37,840 --> 00:07:42,279
it and that specifically goes into

165
00:07:40,180 --> 00:07:45,849
headers and addresses or pointers and

166
00:07:42,279 --> 00:07:48,879
things of that nature now I know that

167
00:07:45,849 --> 00:07:50,680
you can't always sign everything but if

168
00:07:48,879 --> 00:07:52,719
you're looking at pointers and addresses

169
00:07:50,680 --> 00:07:54,909
just make sure that fall within exactly

170
00:07:52,719 --> 00:07:57,389
the ranges that you have in your

171
00:07:54,909 --> 00:08:00,190
destination buffer does these kind of

172
00:07:57,389 --> 00:08:03,190
checks to make sure that if you're not

173
00:08:00,190 --> 00:08:09,099
overriding anything so that was number

174
00:08:03,190 --> 00:08:10,839
10 not the number nine so this is a nice

175
00:08:09,099 --> 00:08:13,779
except I don't think Kate is in the

176
00:08:10,839 --> 00:08:16,599
audience today but yeah I know she was

177
00:08:13,779 --> 00:08:19,060
here yesterday so she may have shown you

178
00:08:16,599 --> 00:08:23,139
a lot more detail about this then then I

179
00:08:19,060 --> 00:08:24,819
have but the problem here is that

180
00:08:23,139 --> 00:08:28,680
there's a there's actually a firmware

181
00:08:24,819 --> 00:08:31,659
upgrade path on the on the nintendo that

182
00:08:28,680 --> 00:08:34,419
goes through USB and what it does at

183
00:08:31,659 --> 00:08:36,399
some point there is a buffer overflow so

184
00:08:34,419 --> 00:08:40,899
an attacker can actually override a

185
00:08:36,399 --> 00:08:45,029
bunch of data on the in memory but not

186
00:08:40,899 --> 00:08:47,829
necessarily in stack and then the second

187
00:08:45,029 --> 00:08:50,079
vulnerability actually is a mem copy

188
00:08:47,829 --> 00:08:53,459
that copies all of that attacker control

189
00:08:50,079 --> 00:08:56,439
data right into the DMA buffer but all

190
00:08:53,460 --> 00:09:01,300
overrides the attacker stack so that's

191
00:08:56,440 --> 00:09:04,270
instant code execution so there's

192
00:09:01,300 --> 00:09:06,790
obviously many problems here but well

193
00:09:04,270 --> 00:09:09,150
I've taken this example to show that the

194
00:09:06,790 --> 00:09:11,890
firmware update mechanism themselves

195
00:09:09,150 --> 00:09:13,959
also need to be protected and not just

196
00:09:11,890 --> 00:09:16,930
the image itself needs to be signed but

197
00:09:13,960 --> 00:09:19,270
you also have to make sure that the the

198
00:09:16,930 --> 00:09:21,459
mechanism around eating such an image

199
00:09:19,270 --> 00:09:26,439
and then burying it on the system that

200
00:09:21,460 --> 00:09:29,470
also needs to be looked at now

201
00:09:26,440 --> 00:09:31,240
I'm not arguing against firmware

202
00:09:29,470 --> 00:09:32,920
upgrades mechanisms at all because I

203
00:09:31,240 --> 00:09:34,870
think they're very important you need it

204
00:09:32,920 --> 00:09:37,870
in order to be able to fix bugs while

205
00:09:34,870 --> 00:09:41,740
you're in the field but you really must

206
00:09:37,870 --> 00:09:46,300
harden the mechanism itself and things

207
00:09:41,740 --> 00:09:49,330
where we see difficult today or you know

208
00:09:46,300 --> 00:09:52,329
regularly is that often these firmware

209
00:09:49,330 --> 00:09:54,280
images they don't all always fit into

210
00:09:52,330 --> 00:09:56,860
the memory at boot time or into like a

211
00:09:54,280 --> 00:09:59,199
little som that you're using so what you

212
00:09:56,860 --> 00:10:01,450
get is that these images gets chunked

213
00:09:59,200 --> 00:10:04,150
and chunks gets individually verified

214
00:10:01,450 --> 00:10:07,300
hurt like they're a Mac or something

215
00:10:04,150 --> 00:10:09,280
like that but you need to make sure that

216
00:10:07,300 --> 00:10:11,939
you stitch all this chunk together

217
00:10:09,280 --> 00:10:14,770
properly in the final binary as well

218
00:10:11,940 --> 00:10:16,930
because if you can like get rearranged

219
00:10:14,770 --> 00:10:19,420
blocks or you can write them in places

220
00:10:16,930 --> 00:10:24,839
where it's not expected you can also use

221
00:10:19,420 --> 00:10:24,839
that to basically hack yourself in

222
00:10:24,990 --> 00:10:31,420
sometimes what we also see is that the

223
00:10:28,740 --> 00:10:34,180
the updated firmware for the image that

224
00:10:31,420 --> 00:10:36,130
you're actually going to burn you should

225
00:10:34,180 --> 00:10:38,829
do the same kind of security checks as

226
00:10:36,130 --> 00:10:40,780
you would do on a boot just make sure

227
00:10:38,830 --> 00:10:42,610
you just duplicate all those things they

228
00:10:40,780 --> 00:10:55,720
give the same thing should we do

229
00:10:42,610 --> 00:10:57,370
questions at the end ok thanks so what a

230
00:10:55,720 --> 00:11:00,460
mitigation here is really limit the

231
00:10:57,370 --> 00:11:03,970
functionality to just purely the flash

232
00:11:00,460 --> 00:11:06,440
image burning if you can so things like

233
00:11:03,970 --> 00:11:08,089
partial upgrades individual

234
00:11:06,440 --> 00:11:12,379
blocks I know that sometimes you have

235
00:11:08,089 --> 00:11:16,449
engineering limitations but but really

236
00:11:12,379 --> 00:11:19,639
try to make keep it as simple as you can

237
00:11:16,449 --> 00:11:21,019
because the more you exposed to an

238
00:11:19,639 --> 00:11:22,490
attacker in terms of functionality the

239
00:11:21,019 --> 00:11:25,970
more that there could eventually go

240
00:11:22,490 --> 00:11:27,829
wrong and all this see if you can if

241
00:11:25,970 --> 00:11:29,990
your platform supports it use anti

242
00:11:27,829 --> 00:11:34,910
rollback so anti rollback is a feature

243
00:11:29,990 --> 00:11:36,740
where in your firmware you put a version

244
00:11:34,910 --> 00:11:40,639
number like a security version number

245
00:11:36,740 --> 00:11:42,500
and every time you during boots the

246
00:11:40,639 --> 00:11:44,240
platform sees that security number and

247
00:11:42,500 --> 00:11:46,399
it's higher than the last time it's

248
00:11:44,240 --> 00:11:50,569
booted it will actually update some

249
00:11:46,399 --> 00:11:53,089
fuses and by updating those fuses it

250
00:11:50,569 --> 00:11:55,339
makes sure that you can check whether a

251
00:11:53,089 --> 00:11:58,490
previous version of me booted and then

252
00:11:55,339 --> 00:12:01,790
just deny boot so you make sure that the

253
00:11:58,490 --> 00:12:03,500
version can only go up and never down so

254
00:12:01,790 --> 00:12:04,939
this prevents downgrades attacks where

255
00:12:03,500 --> 00:12:12,079
you where an attacker would put a

256
00:12:04,939 --> 00:12:16,069
vulnerable version back in place this is

257
00:12:12,079 --> 00:12:19,638
a fun one too so actually a lot of the

258
00:12:16,069 --> 00:12:23,660
times big parts of boot code is actually

259
00:12:19,639 --> 00:12:29,029
drivers then parsers and these things

260
00:12:23,660 --> 00:12:31,339
are notoriously complex so if you have a

261
00:12:29,029 --> 00:12:34,339
recovery mechanism that goes through USB

262
00:12:31,339 --> 00:12:36,199
or SD cards or MMC or your name it that

263
00:12:34,339 --> 00:12:40,759
means you have to implement a driver for

264
00:12:36,199 --> 00:12:43,430
that in the boot code and you know these

265
00:12:40,759 --> 00:12:45,380
drivers are not trivial drivers like

266
00:12:43,430 --> 00:12:47,989
there's quite a bit of code involved and

267
00:12:45,380 --> 00:12:49,910
by definition almost by definition

268
00:12:47,990 --> 00:12:51,250
they're taking data from the outside

269
00:12:49,910 --> 00:12:54,319
world and have to do something with it

270
00:12:51,250 --> 00:12:57,589
so this is sort of the the area where we

271
00:12:54,319 --> 00:13:00,949
see a lot of bugs and they're necessary

272
00:12:57,589 --> 00:13:05,180
because you want to be able to boot your

273
00:13:00,949 --> 00:13:07,189
system in case there's a failure but

274
00:13:05,180 --> 00:13:09,410
yeah there's a lot of potential there

275
00:13:07,189 --> 00:13:11,300
for just your traditional software bugs

276
00:13:09,410 --> 00:13:17,240
like a integer overflows and buffer

277
00:13:11,300 --> 00:13:19,790
overflows and you name it again a bunch

278
00:13:17,240 --> 00:13:21,770
of examples from this from iPhones and

279
00:13:19,790 --> 00:13:24,349
in ten

280
00:13:21,770 --> 00:13:26,660
and really what you want to do here is

281
00:13:24,350 --> 00:13:29,180
you want to make sure that you review

282
00:13:26,660 --> 00:13:31,100
your code do fuzzing these are software

283
00:13:29,180 --> 00:13:32,839
vulnerabilities so you can just do the

284
00:13:31,100 --> 00:13:34,610
typical software things except that now

285
00:13:32,839 --> 00:13:42,440
you need to come in through a hardware

286
00:13:34,610 --> 00:13:45,260
interface this is one of my one of the

287
00:13:42,440 --> 00:13:47,029
more low level low level in the sense

288
00:13:45,260 --> 00:13:49,310
that it's really easy hacks I've done in

289
00:13:47,029 --> 00:13:51,709
the warm-up personally but that we as it

290
00:13:49,310 --> 00:13:54,469
as a company is kind of a test so

291
00:13:51,709 --> 00:13:58,339
imagine you have a device with with a

292
00:13:54,470 --> 00:14:01,160
big firm rail and they oversized the

293
00:13:58,339 --> 00:14:02,839
firmware a bit so that the actual proper

294
00:14:01,160 --> 00:14:06,500
booth code was sort of sitting in the

295
00:14:02,839 --> 00:14:08,779
top block and this was not used so the

296
00:14:06,500 --> 00:14:10,970
signature verification went over the

297
00:14:08,779 --> 00:14:13,430
code that was here so this isn't

298
00:14:10,970 --> 00:14:17,060
principle all attacker controlled now

299
00:14:13,430 --> 00:14:19,310
that's not necessarily useful because as

300
00:14:17,060 --> 00:14:24,650
soon as this started executing it was

301
00:14:19,310 --> 00:14:27,050
executing from here but this was when

302
00:14:24,650 --> 00:14:29,329
this is a bit of an older system so it

303
00:14:27,050 --> 00:14:31,760
actually it was executing code from the

304
00:14:29,330 --> 00:14:36,500
external flash so this is an external

305
00:14:31,760 --> 00:14:40,130
flash now what happens is that while

306
00:14:36,500 --> 00:14:44,770
it's running this code we are

307
00:14:40,130 --> 00:14:44,770
controlling all the address lines

308
00:14:46,690 --> 00:14:51,950
specifically we're controlling the

309
00:14:48,770 --> 00:14:53,329
address line which tells whether you

310
00:14:51,950 --> 00:14:57,110
should look in the upper or the lower

311
00:14:53,330 --> 00:14:59,690
page this is one bit somewhere so we

312
00:14:57,110 --> 00:15:01,670
soldered a wire onto that address bus

313
00:14:59,690 --> 00:15:04,930
and we put a little button on it's the

314
00:15:01,670 --> 00:15:07,729
physical button so while this thing is

315
00:15:04,930 --> 00:15:09,770
executing and booting if you press the

316
00:15:07,730 --> 00:15:13,370
button we would actually pull that line

317
00:15:09,770 --> 00:15:15,980
high and we would instead be loading

318
00:15:13,370 --> 00:15:18,230
code from this page so even though this

319
00:15:15,980 --> 00:15:20,810
was all properly signed and and and

320
00:15:18,230 --> 00:15:25,940
verified during execution we just popped

321
00:15:20,810 --> 00:15:28,310
it over and since there's like there's

322
00:15:25,940 --> 00:15:30,380
no timing require or constraints almost

323
00:15:28,310 --> 00:15:34,130
here because at any point in time during

324
00:15:30,380 --> 00:15:35,240
the boots this code will be there

325
00:15:34,130 --> 00:15:37,760
the instruction pointer will be

326
00:15:35,240 --> 00:15:39,800
somewhere here so once we pull that

327
00:15:37,760 --> 00:15:41,720
address line we're somewhere here but

328
00:15:39,800 --> 00:15:43,370
you just build a ginormous nope sled on

329
00:15:41,720 --> 00:15:46,550
your attacker code at the bottom and you

330
00:15:43,370 --> 00:15:48,110
you got it so this was cool because it

331
00:15:46,550 --> 00:15:50,120
you know normally we're dealing with

332
00:15:48,110 --> 00:15:51,140
tech PGA's for all this precise timing

333
00:15:50,120 --> 00:15:53,900
and everything but this one you could

334
00:15:51,140 --> 00:15:56,960
literally this with a button corrupt the

335
00:15:53,900 --> 00:15:59,120
corrupted boots so this is a race

336
00:15:56,960 --> 00:16:02,990
condition or a time of check time use

337
00:15:59,120 --> 00:16:04,910
issue yeah between the verification of

338
00:16:02,990 --> 00:16:06,380
something and the use of something you

339
00:16:04,910 --> 00:16:09,650
got to make sure that an attacker cannot

340
00:16:06,380 --> 00:16:12,230
get in between it and that can happen

341
00:16:09,650 --> 00:16:14,949
because friends is a flash is external

342
00:16:12,230 --> 00:16:19,850
but you can also think about DMA attacks

343
00:16:14,950 --> 00:16:22,880
right so if if the code that you're

344
00:16:19,850 --> 00:16:24,410
executing is in memory and for some

345
00:16:22,880 --> 00:16:27,050
reason and Thacker has been able to get

346
00:16:24,410 --> 00:16:28,730
DMA access after the signature

347
00:16:27,050 --> 00:16:31,729
verification over that memory he can

348
00:16:28,730 --> 00:16:35,330
just copy any data in there and control

349
00:16:31,730 --> 00:16:37,160
the system that way so let's again

350
00:16:35,330 --> 00:16:42,340
there's there's many examples is from

351
00:16:37,160 --> 00:16:45,740
both the PC world and an embedded world

352
00:16:42,340 --> 00:16:48,170
so really the I mean you really try to

353
00:16:45,740 --> 00:16:50,510
prevent any of that access and typically

354
00:16:48,170 --> 00:16:53,410
this is done by first copying something

355
00:16:50,510 --> 00:16:58,670
to internal memory and then doing the

356
00:16:53,410 --> 00:17:01,280
verification now the more astute

357
00:16:58,670 --> 00:17:03,410
listeners will say but yes were you said

358
00:17:01,280 --> 00:17:05,990
earlier don't do anything before you

359
00:17:03,410 --> 00:17:09,649
verify it well this is sort of an

360
00:17:05,990 --> 00:17:11,750
exception so really try to copy you know

361
00:17:09,650 --> 00:17:13,760
verify all the pointers and the sizes

362
00:17:11,750 --> 00:17:16,010
make sure that it sort of doesn't

363
00:17:13,760 --> 00:17:17,900
overwrite anything in your ass Ram but

364
00:17:16,010 --> 00:17:19,520
only then you can do a secret a digital

365
00:17:17,900 --> 00:17:21,589
signature verification because doing it

366
00:17:19,520 --> 00:17:27,709
on the external side just doesn't make

367
00:17:21,589 --> 00:17:31,270
sense because of this issue this is one

368
00:17:27,709 --> 00:17:34,640
of the all-time favorites I guess from

369
00:17:31,270 --> 00:17:39,020
something gaming world so this is a

370
00:17:34,640 --> 00:17:42,740
timing attack and what's happening here

371
00:17:39,020 --> 00:17:44,840
is that we are at least in in Xbox world

372
00:17:42,740 --> 00:17:49,520
we want to load our own code

373
00:17:44,840 --> 00:17:51,590
during boot and in this case the the

374
00:17:49,520 --> 00:17:54,590
boot code itself was signed with an H

375
00:17:51,590 --> 00:17:57,620
mag now the way an H Mack works is that

376
00:17:54,590 --> 00:18:00,230
it takes a symmetric key and it's sizes

377
00:17:57,620 --> 00:18:02,059
and it signs a blob of data and then you

378
00:18:00,230 --> 00:18:04,669
can verify the signature if you have

379
00:18:02,059 --> 00:18:09,529
verify or create a signature if you have

380
00:18:04,669 --> 00:18:12,950
the key so any of the proper firmers

381
00:18:09,529 --> 00:18:15,500
have been signed using this key and the

382
00:18:12,950 --> 00:18:20,059
same key is in the Xbox it can verify

383
00:18:15,500 --> 00:18:26,110
any image that it receives now they make

384
00:18:20,059 --> 00:18:29,418
one big mistake what happens is that

385
00:18:26,110 --> 00:18:31,668
when you provide your attacker based

386
00:18:29,419 --> 00:18:35,480
image you cannot give it a proper H back

387
00:18:31,669 --> 00:18:37,100
because you don't know the key but the

388
00:18:35,480 --> 00:18:40,279
way that the verification works is that

389
00:18:37,100 --> 00:18:44,000
the Xbox will calculate the H the proper

390
00:18:40,279 --> 00:18:46,549
H Mak over the over the firm emerge that

391
00:18:44,000 --> 00:18:48,470
you've given it and then it will compare

392
00:18:46,549 --> 00:18:51,350
the signature that it is calculated to

393
00:18:48,470 --> 00:18:52,480
the signature that you have given it now

394
00:18:51,350 --> 00:18:56,449
so far so good

395
00:18:52,480 --> 00:18:59,570
but the comparison was done by by byte

396
00:18:56,450 --> 00:19:01,909
and as soon as they found a byte that's

397
00:18:59,570 --> 00:19:06,350
incorrect in the signature they would

398
00:19:01,909 --> 00:19:09,760
return so this is a classical timing

399
00:19:06,350 --> 00:19:15,770
attack so you can actually by timing how

400
00:19:09,760 --> 00:19:18,679
long it takes to verify this this flash

401
00:19:15,770 --> 00:19:22,639
image you could identify which byte in

402
00:19:18,679 --> 00:19:28,669
your signature was wrong meaning that I

403
00:19:22,640 --> 00:19:31,460
can just provide it with 256 signatures

404
00:19:28,669 --> 00:19:34,899
where I just increase the first byte

405
00:19:31,460 --> 00:19:38,179
every time and for one out of those 256

406
00:19:34,899 --> 00:19:40,370
the execution should take just slightly

407
00:19:38,179 --> 00:19:41,809
longer because that was the correct byte

408
00:19:40,370 --> 00:19:44,418
and it has gone through comparing the

409
00:19:41,809 --> 00:19:50,210
second byte now I know the first byte

410
00:19:44,419 --> 00:19:53,990
and I just rinse and repeat so this is

411
00:19:50,210 --> 00:19:56,570
actually a nice example of sort of

412
00:19:53,990 --> 00:19:57,670
operationalizing iraq is commercializing

413
00:19:56,570 --> 00:20:00,879
that attack

414
00:19:57,670 --> 00:20:01,450
and so you could make these boards out

415
00:20:00,880 --> 00:20:03,040
of it

416
00:20:01,450 --> 00:20:04,720
you solder it to the system and it does

417
00:20:03,040 --> 00:20:08,950
the timing and it does the brute-forcing

418
00:20:04,720 --> 00:20:11,260
for you and on this one I was talking to

419
00:20:08,950 --> 00:20:13,360
my colleague over over lines of improved

420
00:20:11,260 --> 00:20:15,820
versions of this but at this point it

421
00:20:13,360 --> 00:20:18,340
took about two hours to load your your

422
00:20:15,820 --> 00:20:24,970
own firmware so it was pretty good

423
00:20:18,340 --> 00:20:27,060
pretty cool so that's what I just talked

424
00:20:24,970 --> 00:20:27,060
about

425
00:20:28,230 --> 00:20:33,940
yeah the mitigation is actually quite

426
00:20:30,760 --> 00:20:36,850
simple it is a time constant comparison

427
00:20:33,940 --> 00:20:38,950
so instead of quitting after the first

428
00:20:36,850 --> 00:20:41,679
byte that you see you just keep

429
00:20:38,950 --> 00:20:44,230
comparing each of the device and menu

430
00:20:41,680 --> 00:20:46,450
exits just make sure you don't put any

431
00:20:44,230 --> 00:20:49,360
like if conditions in that loop like if

432
00:20:46,450 --> 00:20:52,420
this bike doesn't equal that that's

433
00:20:49,360 --> 00:20:55,659
could also be a timing leak leak so the

434
00:20:52,420 --> 00:20:57,340
trick is to actually from the to erase

435
00:20:55,660 --> 00:21:00,730
if you're comparing you just X or two

436
00:20:57,340 --> 00:21:03,129
bytes and the result you or logical or

437
00:21:00,730 --> 00:21:04,960
on to a state variable so if they're all

438
00:21:03,130 --> 00:21:08,770
the same then the XOR will all be all

439
00:21:04,960 --> 00:21:10,720
zeros and my or will be zero and if any

440
00:21:08,770 --> 00:21:12,879
of the bits are different then the or

441
00:21:10,720 --> 00:21:15,550
will be non zero so that's the way to

442
00:21:12,880 --> 00:21:19,230
sort of in a branchless way implement

443
00:21:15,550 --> 00:21:19,230
this and that should have no timing leak

444
00:21:19,860 --> 00:21:25,209
also here I put a put a link to a paper

445
00:21:23,050 --> 00:21:27,250
where we explain a lot of things about

446
00:21:25,210 --> 00:21:33,070
how to present timing attacks but also

447
00:21:27,250 --> 00:21:35,590
other side channel attacks so this is

448
00:21:33,070 --> 00:21:39,429
some let me start the video while I'm

449
00:21:35,590 --> 00:21:42,070
talking and I'm going to turn off this

450
00:21:39,430 --> 00:21:44,920
up is it's horrible so this is a video

451
00:21:42,070 --> 00:21:46,360
where they're actually demonstrating a

452
00:21:44,920 --> 00:21:48,850
glitching device

453
00:21:46,360 --> 00:21:51,100
it's inserted in a slot machine and as

454
00:21:48,850 --> 00:21:54,790
you can see here the credits are just

455
00:21:51,100 --> 00:21:56,730
all of the sudden rolling up so what's

456
00:21:54,790 --> 00:21:59,908
going on here

457
00:21:56,730 --> 00:22:02,980
so the way that these machines are built

458
00:21:59,909 --> 00:22:05,169
is that they have this is an older like

459
00:22:02,980 --> 00:22:08,289
unprotected one they have a machine

460
00:22:05,169 --> 00:22:09,580
where to take in dollar bills and sort

461
00:22:08,289 --> 00:22:11,860
of the reader for those dollar bills

462
00:22:09,580 --> 00:22:14,559
sends a signal to the main see the main

463
00:22:11,860 --> 00:22:17,668
core of the machine like hey you know

464
00:22:14,559 --> 00:22:21,389
one dollar a ten dollar bill is inserted

465
00:22:17,669 --> 00:22:25,990
now when you generate large

466
00:22:21,390 --> 00:22:27,820
electromagnetic impulses that

467
00:22:25,990 --> 00:22:29,950
communication could get disturbed and

468
00:22:27,820 --> 00:22:35,500
may be interpreted as Oh somebody's

469
00:22:29,950 --> 00:22:37,840
insert its X amount of money so this is

470
00:22:35,500 --> 00:22:40,480
really yeah it's a really visual example

471
00:22:37,840 --> 00:22:45,490
of glitching so how is this relevant to

472
00:22:40,480 --> 00:22:47,200
the booth well it turns out that fault

473
00:22:45,490 --> 00:22:50,740
injection is actually quite an effective

474
00:22:47,200 --> 00:22:53,350
way to subvert execution flow so we do a

475
00:22:50,740 --> 00:22:57,370
lot of fault injection in our lab but

476
00:22:53,350 --> 00:22:59,918
more typically aiming for is conditional

477
00:22:57,370 --> 00:23:02,559
branches remember that initial picture

478
00:22:59,919 --> 00:23:04,360
that I showed like I verified the boots

479
00:23:02,559 --> 00:23:06,428
and then if it's correct I jump into the

480
00:23:04,360 --> 00:23:12,189
next one that's the conditional branch

481
00:23:06,429 --> 00:23:14,289
so somewhere in that boot flow the the

482
00:23:12,190 --> 00:23:16,330
processor decides this image is correct

483
00:23:14,289 --> 00:23:18,190
or it's incorrect and it does that

484
00:23:16,330 --> 00:23:21,340
typically with with a conditional branch

485
00:23:18,190 --> 00:23:24,429
instruction so if you're able to flip

486
00:23:21,340 --> 00:23:27,010
that decision by doing a glitch at the

487
00:23:24,429 --> 00:23:29,169
right time you might be able to load

488
00:23:27,010 --> 00:23:33,908
code which actually didn't have a proper

489
00:23:29,169 --> 00:23:35,289
signature and some people always say

490
00:23:33,909 --> 00:23:38,530
like how do you how do you figure out

491
00:23:35,289 --> 00:23:40,210
where that instruction is right you do

492
00:23:38,530 --> 00:23:42,340
you do the linear code extraction that

493
00:23:40,210 --> 00:23:43,929
the Chris's we're talking about and no

494
00:23:42,340 --> 00:23:48,070
it's actually much more blackbox than

495
00:23:43,929 --> 00:23:50,440
that so our typical processes will boot

496
00:23:48,070 --> 00:23:52,689
the system once we take what's called a

497
00:23:50,440 --> 00:23:55,000
power trace so we actually look at the

498
00:23:52,690 --> 00:23:59,440
the power consumption over time of the

499
00:23:55,000 --> 00:24:02,950
device which shows you electrically sort

500
00:23:59,440 --> 00:24:05,169
of what's going on at a very high level

501
00:24:02,950 --> 00:24:07,899
you just see different waveforms that

502
00:24:05,169 --> 00:24:10,740
correspond to different processes now

503
00:24:07,899 --> 00:24:13,739
next we load a firmware image where we

504
00:24:10,740 --> 00:24:15,450
flip one bit in a string or something

505
00:24:13,740 --> 00:24:17,370
somewhere so we don't change the code

506
00:24:15,450 --> 00:24:20,490
but we do make sure that the signature

507
00:24:17,370 --> 00:24:22,949
is invalid we load that as well and we

508
00:24:20,490 --> 00:24:26,520
also take up our trades now what happens

509
00:24:22,950 --> 00:24:28,050
is those power traces will be roughly

510
00:24:26,520 --> 00:24:31,830
the same all the way up to the point

511
00:24:28,050 --> 00:24:34,379
where on the one hand the CPU has

512
00:24:31,830 --> 00:24:36,360
decided to accept the firmware or in the

513
00:24:34,380 --> 00:24:37,860
other trace to reject it and they

514
00:24:36,360 --> 00:24:39,659
actually go into different execution

515
00:24:37,860 --> 00:24:42,270
paths and you see that the traces will

516
00:24:39,660 --> 00:24:44,700
start different so there give me sort of

517
00:24:42,270 --> 00:24:48,120
a perfect not a perfect but it gives me

518
00:24:44,700 --> 00:24:50,610
a very narrow window of time where I can

519
00:24:48,120 --> 00:24:52,530
where I should be glitching so I don't

520
00:24:50,610 --> 00:24:54,270
need to really know like that that's

521
00:24:52,530 --> 00:24:56,428
exactly where particular branch

522
00:24:54,270 --> 00:25:00,840
instruction happens I can just take it

523
00:24:56,429 --> 00:25:02,790
from the from the power traces one good

524
00:25:00,840 --> 00:25:05,970
thing to remember is that this is seldom

525
00:25:02,790 --> 00:25:07,860
a persistent attack so there are more

526
00:25:05,970 --> 00:25:10,200
chips that things are doing fault

527
00:25:07,860 --> 00:25:12,840
injection but typically these are more

528
00:25:10,200 --> 00:25:15,540
like stepping-stone attacks so I'll use

529
00:25:12,840 --> 00:25:17,340
it once to in order to load my attacker

530
00:25:15,540 --> 00:25:19,080
firmware and then I dump the boot ROM

531
00:25:17,340 --> 00:25:20,760
and then I go find a vulnerability and

532
00:25:19,080 --> 00:25:24,740
then that can exploit that later on so I

533
00:25:20,760 --> 00:25:24,740
don't always have to like glitch things

534
00:25:25,250 --> 00:25:33,150
so a bunch of examples yeah really

535
00:25:29,570 --> 00:25:36,689
you need to there's there's the hard way

536
00:25:33,150 --> 00:25:40,320
Hardware approach here which is building

537
00:25:36,690 --> 00:25:42,929
in countermeasures against faults which

538
00:25:40,320 --> 00:25:45,030
is rather expensive typically on the

539
00:25:42,929 --> 00:25:46,920
hardware side there's also some things

540
00:25:45,030 --> 00:25:49,230
you can do in software to mitigate these

541
00:25:46,920 --> 00:25:51,960
things so there's certain programming

542
00:25:49,230 --> 00:25:55,500
styles things like you know instead of

543
00:25:51,960 --> 00:25:58,170
checking the boot code ones check it

544
00:25:55,500 --> 00:26:00,570
twice and check it three times and see

545
00:25:58,170 --> 00:26:03,870
the signature the signature still

546
00:26:00,570 --> 00:26:05,220
succeeds because doing a single fault is

547
00:26:03,870 --> 00:26:07,379
sort of a you have a probabilistic

548
00:26:05,220 --> 00:26:10,650
effect there I may have a 10% or 1%

549
00:26:07,380 --> 00:26:13,350
chance of bypassing it but if I need to

550
00:26:10,650 --> 00:26:16,050
delete something three times its 1% of

551
00:26:13,350 --> 00:26:17,969
1% of 1% if it's done correctly so

552
00:26:16,050 --> 00:26:19,800
there's these kind of patterns that you

553
00:26:17,970 --> 00:26:22,250
can do to make make me attacker slight

554
00:26:19,800 --> 00:26:22,250
hard

555
00:26:24,539 --> 00:26:31,129
so I'm gonna take one more steak errors

556
00:26:34,789 --> 00:26:42,179
so sometimes especially in these like

557
00:26:38,429 --> 00:26:44,429
suspend resume cycles you need to store

558
00:26:42,179 --> 00:26:46,049
your state somewhere and this is done

559
00:26:44,429 --> 00:26:48,389
because you want to speed up the boot

560
00:26:46,049 --> 00:26:50,039
when you when you resume a platform

561
00:26:48,389 --> 00:26:51,809
which means you don't want to do all the

562
00:26:50,039 --> 00:26:54,089
computations again you don't want to

563
00:26:51,809 --> 00:26:56,969
read verify all those images but you

564
00:26:54,089 --> 00:26:58,769
somehow want to lock them in such a min

565
00:26:56,969 --> 00:27:02,519
into memory in such a way that an

566
00:26:58,769 --> 00:27:06,409
attacker cannot tamper with them if you

567
00:27:02,519 --> 00:27:10,559
do this in securely you might be able to

568
00:27:06,409 --> 00:27:13,469
exploit the fact that you can change the

569
00:27:10,559 --> 00:27:17,279
state just before system goes to sleep

570
00:27:13,469 --> 00:27:19,259
or just after it wakes up and this is

571
00:27:17,279 --> 00:27:20,549
really leads sort of to maximum

572
00:27:19,259 --> 00:27:24,619
privilege escalation because you're

573
00:27:20,549 --> 00:27:27,019
there it's very early on it's at boots

574
00:27:24,619 --> 00:27:29,009
so that's yeah there's there's

575
00:27:27,019 --> 00:27:31,289
especially in the PC world because

576
00:27:29,009 --> 00:27:33,839
they're sleeping and waking up is quite

577
00:27:31,289 --> 00:27:38,699
an elaborate process there's been a

578
00:27:33,839 --> 00:27:40,109
various attacks over the years some of

579
00:27:38,699 --> 00:27:42,089
the mitigations here would be to

580
00:27:40,109 --> 00:27:47,489
actually cryptographically sign and

581
00:27:42,089 --> 00:27:49,408
verify your state so instead of just

582
00:27:47,489 --> 00:27:51,599
trusting at a certain memory location

583
00:27:49,409 --> 00:27:53,519
where you store these things hasn't been

584
00:27:51,599 --> 00:27:57,029
tampered with you sign it sign it and

585
00:27:53,519 --> 00:28:00,569
you're verified on boot or you just

586
00:27:57,029 --> 00:28:03,690
reanalyze all the variables but yeah I

587
00:28:00,569 --> 00:28:06,539
realize these things have a performance

588
00:28:03,690 --> 00:28:08,219
overhead so that's something that's yeah

589
00:28:06,539 --> 00:28:12,839
we're performance and security aren't

590
00:28:08,219 --> 00:28:15,239
always friends also here you should

591
00:28:12,839 --> 00:28:16,918
consider both logical at fault injection

592
00:28:15,239 --> 00:28:19,889
attacks and logical meaning I can just

593
00:28:16,919 --> 00:28:22,289
flip memory bits or maybe I can load

594
00:28:19,889 --> 00:28:25,049
some code that flips things before you

595
00:28:22,289 --> 00:28:27,119
go to sleep but also during Falls

596
00:28:25,049 --> 00:28:30,619
injection or during sleep you might be

597
00:28:27,119 --> 00:28:30,619
able to fault certain states

598
00:28:34,470 --> 00:28:39,270
that Fed ISM is actually cool example

599
00:28:37,320 --> 00:28:42,629
also blitzing but it's not the category

600
00:28:39,270 --> 00:28:45,480
that I'm alluding to here what bad fat

601
00:28:42,630 --> 00:28:48,450
death did was on a embedded device that

602
00:28:45,480 --> 00:28:52,400
was booting up you corrupted the memory

603
00:28:48,450 --> 00:28:55,980
by just sending a big EMP pulse so

604
00:28:52,400 --> 00:28:59,100
inside the memory you flipped a couple

605
00:28:55,980 --> 00:29:02,669
of bits this way and what actually

606
00:28:59,100 --> 00:29:06,530
happened was that you boots in all of

607
00:29:02,669 --> 00:29:09,090
its wisdom during the boot face would

608
00:29:06,530 --> 00:29:10,889
see that the memory was corrupted the

609
00:29:09,090 --> 00:29:15,270
image was corrupted and it would fall

610
00:29:10,890 --> 00:29:16,650
back to a debug mode and it falls back

611
00:29:15,270 --> 00:29:20,720
into the debug mode where you have

612
00:29:16,650 --> 00:29:23,580
commands like this memory right

613
00:29:20,720 --> 00:29:25,880
so you basically had during boot

614
00:29:23,580 --> 00:29:27,870
arbitrary control over this system and

615
00:29:25,880 --> 00:29:29,820
this is not something that you would

616
00:29:27,870 --> 00:29:31,739
normally be able to fall into you really

617
00:29:29,820 --> 00:29:33,889
have to disrupt something that normally

618
00:29:31,740 --> 00:29:36,990
you logically wouldn't have access to

619
00:29:33,890 --> 00:29:40,470
but this was a yeah really nice example

620
00:29:36,990 --> 00:29:43,500
of falling back to an insecure mode and

621
00:29:40,470 --> 00:29:44,280
this debug yeah and I mean you boot is

622
00:29:43,500 --> 00:29:45,900
there too

623
00:29:44,280 --> 00:29:47,428
normally to verify these kind of

624
00:29:45,900 --> 00:29:49,380
signatures but at the same time it

625
00:29:47,429 --> 00:29:53,010
offers this type of functionality as

626
00:29:49,380 --> 00:29:54,870
well you might consider if you're using

627
00:29:53,010 --> 00:29:59,309
you boot compiling these things out in

628
00:29:54,870 --> 00:30:01,559
your your production systems yeah but

629
00:29:59,309 --> 00:30:04,918
it's an example of things that can go

630
00:30:01,559 --> 00:30:07,918
wrong with debugging so debugging is a

631
00:30:04,919 --> 00:30:09,990
rather large topic you will find

632
00:30:07,919 --> 00:30:12,419
debugging interfaces on every device out

633
00:30:09,990 --> 00:30:15,870
there just because developers need to

634
00:30:12,419 --> 00:30:19,110
debug their stuff and it's usually you

635
00:30:15,870 --> 00:30:22,110
will find geotag and/or you arts with

636
00:30:19,110 --> 00:30:25,918
debugging consoles sometimes something a

637
00:30:22,110 --> 00:30:27,539
bit more proprietary and in automotive

638
00:30:25,919 --> 00:30:31,710
what you also see a lot is that there's

639
00:30:27,539 --> 00:30:34,140
like these sort of service backdoor

640
00:30:31,710 --> 00:30:39,660
slash you know special readers available

641
00:30:34,140 --> 00:30:42,789
for for modifying behavior on devices

642
00:30:39,660 --> 00:30:42,789
[Music]

643
00:30:42,860 --> 00:30:47,549
now yeah one of the things that he

644
00:30:45,390 --> 00:30:48,169
typically sees everybody understands on

645
00:30:47,549 --> 00:30:51,529
the backdoor so

646
00:30:48,169 --> 00:30:53,899
bad but often you'll see like yeah we

647
00:30:51,529 --> 00:30:56,679
know it's bad but in my particular

648
00:30:53,899 --> 00:30:59,869
situation it's okay because of XYZ and

649
00:30:56,679 --> 00:31:01,309
then you know the situation changes

650
00:30:59,869 --> 00:31:06,609
requirements change and all of a sudden

651
00:31:01,309 --> 00:31:06,609
that doesn't become a huge back door

652
00:31:07,960 --> 00:31:12,559
yeah so the examples here yeah you see

653
00:31:11,600 --> 00:31:15,230
it a lot like I made something

654
00:31:12,559 --> 00:31:16,029
cartooning ECU's and cables there

655
00:31:15,230 --> 00:31:18,200
there's some kind of magic

656
00:31:16,029 --> 00:31:20,239
authentication and this isn't always

657
00:31:18,200 --> 00:31:22,789
like a cryptographically hard sellers

658
00:31:20,239 --> 00:31:24,919
responses using more like a path you

659
00:31:22,789 --> 00:31:30,289
know a master password that's being sent

660
00:31:24,919 --> 00:31:32,029
in order to open something up yeah a lot

661
00:31:30,289 --> 00:31:34,879
of the more secure chips you can

662
00:31:32,029 --> 00:31:37,340
actually disable or a log to a tag maybe

663
00:31:34,879 --> 00:31:39,199
not from the krisis but you can do it

664
00:31:37,340 --> 00:31:43,309
from people who are not invasively

665
00:31:39,200 --> 00:31:44,749
attacking your chip although we

666
00:31:43,309 --> 00:31:49,789
sometimes bypass that with fault

667
00:31:44,749 --> 00:31:52,159
injection as well so these log bits are

668
00:31:49,789 --> 00:31:56,029
some somewhere on the silicon of the

669
00:31:52,159 --> 00:31:58,009
chip we've done things with voltage

670
00:31:56,029 --> 00:32:00,649
glitching but also with laser glitching

671
00:31:58,009 --> 00:32:03,529
so you hope you sort of you open up the

672
00:32:00,649 --> 00:32:05,658
packet so you see the chip and then you

673
00:32:03,529 --> 00:32:07,940
just start scanning the chip so you say

674
00:32:05,659 --> 00:32:09,799
unlock and you shoot it with a laser at

675
00:32:07,940 --> 00:32:11,600
one position they say unlock again you

676
00:32:09,799 --> 00:32:13,039
did at the next position you just scan

677
00:32:11,600 --> 00:32:15,439
the entire chip until the unlock

678
00:32:13,039 --> 00:32:17,480
succeeds and then you know you've sort

679
00:32:15,440 --> 00:32:23,929
of hit the area where that order where

680
00:32:17,480 --> 00:32:28,779
the long bits are yeah definitely used

681
00:32:23,929 --> 00:32:31,039
in device unique debugging facilities

682
00:32:28,779 --> 00:32:32,869
because if somebody breaks one of the

683
00:32:31,039 --> 00:32:37,639
chips you don't want that to translate

684
00:32:32,869 --> 00:32:39,799
to all of the tips and also if it's

685
00:32:37,639 --> 00:32:43,219
possible you don't need to always build

686
00:32:39,799 --> 00:32:45,668
in all of the debug functionality in

687
00:32:43,220 --> 00:32:48,259
your you know in the production

688
00:32:45,669 --> 00:32:53,149
production chain you could also imagine

689
00:32:48,259 --> 00:32:55,220
that in that chain of trust you you hold

690
00:32:53,149 --> 00:32:56,928
in your manufacturing facility all the

691
00:32:55,220 --> 00:32:58,940
special debugging image which is also

692
00:32:56,929 --> 00:33:00,659
signed but that's where you put all the

693
00:32:58,940 --> 00:33:04,019
debugging functionality and you don't

694
00:33:00,659 --> 00:33:06,950
put it all into production eventually

695
00:33:04,019 --> 00:33:12,629
these things tend to leak but it's it

696
00:33:06,950 --> 00:33:16,249
mitigates it somewhat this was also a

697
00:33:12,629 --> 00:33:19,259
cool attack and so this one the 3ds and

698
00:33:16,249 --> 00:33:22,789
what they had here is they had a table

699
00:33:19,259 --> 00:33:25,799
with a bunch of keys and each of these

700
00:33:22,789 --> 00:33:28,830
these keys were encrypted so you can

701
00:33:25,799 --> 00:33:32,489
like read out the keys directly but you

702
00:33:28,830 --> 00:33:34,559
could shuffle the keys so you could

703
00:33:32,489 --> 00:33:37,830
arbitrarily move these keys around to

704
00:33:34,559 --> 00:33:40,799
different key slots then there were also

705
00:33:37,830 --> 00:33:45,899
a bunch of firmer binaries that were

706
00:33:40,799 --> 00:33:47,279
signed with all their P's so there are

707
00:33:45,899 --> 00:33:48,988
actually two things that you could play

708
00:33:47,279 --> 00:33:52,440
with an attacker you could you could

709
00:33:48,989 --> 00:33:54,570
give it signed but you know encrypt its

710
00:33:52,440 --> 00:33:57,539
images now you could pick different ones

711
00:33:54,570 --> 00:34:01,229
and you could flip around keys and it

712
00:33:57,539 --> 00:34:02,669
turns out if you have enough of these

713
00:34:01,229 --> 00:34:06,289
keys and you have enough of these

714
00:34:02,669 --> 00:34:09,210
versions you could find a combination

715
00:34:06,289 --> 00:34:11,009
where the decrypted version which you

716
00:34:09,210 --> 00:34:12,179
don't know but the decrypted version

717
00:34:11,010 --> 00:34:14,490
actually had a jump instruction

718
00:34:12,179 --> 00:34:18,210
somewhere that would jump into attacker

719
00:34:14,489 --> 00:34:22,408
controlled code so this is this all it

720
00:34:18,210 --> 00:34:26,429
makes in these kind of things but yeah

721
00:34:22,409 --> 00:34:29,490
it's it's it's really important here to

722
00:34:26,429 --> 00:34:33,569
make sure that you don't allow arbitrary

723
00:34:29,489 --> 00:34:36,479
key combinations to our sorry arbitrary

724
00:34:33,569 --> 00:34:38,489
keys to decrypt arbitrary data basically

725
00:34:36,480 --> 00:34:43,168
so you have to check what this key is

726
00:34:38,489 --> 00:34:45,239
used for other things that we've seen is

727
00:34:43,168 --> 00:34:46,408
if you sign development boot loaders

728
00:34:45,239 --> 00:34:48,779
with production keys

729
00:34:46,409 --> 00:34:50,460
so once the development boot loader at

730
00:34:48,779 --> 00:34:53,039
the time of the production key leaks out

731
00:34:50,460 --> 00:34:55,770
you can use this on all the devices with

732
00:34:53,039 --> 00:34:59,510
in the field so that's also a problem

733
00:34:55,770 --> 00:35:03,299
and then finally make sure that you

734
00:34:59,510 --> 00:35:06,240
sanitize your crypto engines before you

735
00:35:03,299 --> 00:35:07,920
go to the next boot stages so often

736
00:35:06,240 --> 00:35:10,049
these things work you have a crypto

737
00:35:07,920 --> 00:35:12,450
engine and it has a number of key slots

738
00:35:10,049 --> 00:35:13,710
you program these slots and you say go

739
00:35:12,450 --> 00:35:16,859
decrypt in this part

740
00:35:13,710 --> 00:35:19,140
memory or that part of memory you want

741
00:35:16,859 --> 00:35:21,180
to wipe those key slots before you go

742
00:35:19,140 --> 00:35:22,890
into the next stages of boot because if

743
00:35:21,180 --> 00:35:25,710
the next if somewhere down the line

744
00:35:22,890 --> 00:35:28,839
something gets compromised and they can

745
00:35:25,710 --> 00:35:31,899
still use these keys you have a problem

746
00:35:28,840 --> 00:35:31,899
[Music]

747
00:35:32,990 --> 00:35:38,580
so yeah this is really a question of

748
00:35:36,390 --> 00:35:42,240
reviewing this understanding the value

749
00:35:38,580 --> 00:35:45,029
of all these keys and acting accordingly

750
00:35:42,240 --> 00:35:47,399
I would say and make sure that you clear

751
00:35:45,030 --> 00:35:52,260
any sensitive data out of crypto engines

752
00:35:47,400 --> 00:35:54,450
before you before you proceed now then

753
00:35:52,260 --> 00:35:58,410
the the final on number one how many

754
00:35:54,450 --> 00:36:01,859
minutes is app five-mile speak

755
00:35:58,410 --> 00:36:05,759
I'll speak fast and I won't go into all

756
00:36:01,859 --> 00:36:07,230
the details of each CDSA but you can

757
00:36:05,760 --> 00:36:09,030
also use crypto the wrong write the

758
00:36:07,230 --> 00:36:10,440
previous one was just key material how

759
00:36:09,030 --> 00:36:12,960
the ears keys but you can also use

760
00:36:10,440 --> 00:36:14,700
crypto the wrong way one of the classic

761
00:36:12,960 --> 00:36:18,270
ones is the decryption is not the same

762
00:36:14,700 --> 00:36:21,480
as authentication so I've done attacks

763
00:36:18,270 --> 00:36:24,119
where I had an AS CBC and the way that a

764
00:36:21,480 --> 00:36:28,320
ES CBC works is that I can I can pick a

765
00:36:24,119 --> 00:36:33,300
bit that I want to flip in the plaintext

766
00:36:28,320 --> 00:36:35,040
and that will corrupt the next block but

767
00:36:33,300 --> 00:36:37,320
that might not be a problem depending on

768
00:36:35,040 --> 00:36:39,330
where I am so you always want to do a

769
00:36:37,320 --> 00:36:45,900
signature verification it's different

770
00:36:39,330 --> 00:36:48,480
than then encryption my mother never

771
00:36:45,900 --> 00:36:51,210
always told me to never put math on

772
00:36:48,480 --> 00:36:55,109
slides but here we go

773
00:36:51,210 --> 00:36:56,790
so ECDSA is a signature scheme and it

774
00:36:55,109 --> 00:36:59,130
has a bunch of input parameters but the

775
00:36:56,790 --> 00:37:02,070
main one to remember is that da is the

776
00:36:59,130 --> 00:37:05,400
private key M is the message and K is

777
00:37:02,070 --> 00:37:08,970
the nonce and we control and usually as

778
00:37:05,400 --> 00:37:13,440
the attacker now the way that this is

779
00:37:08,970 --> 00:37:17,490
supposed to work is that the norms nan

780
00:37:13,440 --> 00:37:21,420
stands for number used ones that a

781
00:37:17,490 --> 00:37:25,979
number is used once this is just how you

782
00:37:21,420 --> 00:37:27,500
calculate a ECDSA you can generally step

783
00:37:25,980 --> 00:37:32,090
five and six the rest is wrong

784
00:37:27,500 --> 00:37:35,270
pedia this K is the number used once and

785
00:37:32,090 --> 00:37:36,890
this is the private key right here so

786
00:37:35,270 --> 00:37:41,180
you don't see those as an attacker but

787
00:37:36,890 --> 00:37:45,440
you do see R and s now what happens if

788
00:37:41,180 --> 00:37:47,450
you reuse K for multiple messages you

789
00:37:45,440 --> 00:37:49,760
can actually calculate the private key

790
00:37:47,450 --> 00:37:51,549
based on those two messages and based on

791
00:37:49,760 --> 00:37:53,750
the signatures of those two messages

792
00:37:51,550 --> 00:37:59,980
instantly like this is not hard math

793
00:37:53,750 --> 00:38:03,470
right this is some basic algebra so

794
00:37:59,980 --> 00:38:06,020
that's why we never reuse this and I

795
00:38:03,470 --> 00:38:12,529
will repeat this one more time a nonce

796
00:38:06,020 --> 00:38:21,590
is a number we only use once so this is

797
00:38:12,530 --> 00:38:24,860
what Sony did in their ECDSA code so

798
00:38:21,590 --> 00:38:30,110
this is a classic in my my opinion by

799
00:38:24,860 --> 00:38:32,660
now so really they in their in their in

800
00:38:30,110 --> 00:38:34,760
the signing algorithm for their or it's

801
00:38:32,660 --> 00:38:40,339
the other signing elder and for some

802
00:38:34,760 --> 00:38:41,960
reason they just use a static number so

803
00:38:40,340 --> 00:38:47,000
you could just calculate the private key

804
00:38:41,960 --> 00:38:50,960
and create your own signatures so now

805
00:38:47,000 --> 00:38:52,700
what so I hope you understand now that's

806
00:38:50,960 --> 00:38:54,170
securely booting a system or just

807
00:38:52,700 --> 00:38:56,270
booting a system is a very complex

808
00:38:54,170 --> 00:38:59,840
operation there's a lot of things that

809
00:38:56,270 --> 00:39:01,880
go on during boots and in the field

810
00:38:59,840 --> 00:39:06,410
patching of booth components is actually

811
00:39:01,880 --> 00:39:08,690
really hard to impossible so there are

812
00:39:06,410 --> 00:39:11,720
things like boot ROM patches things like

813
00:39:08,690 --> 00:39:14,540
that but yeah you know you're not always

814
00:39:11,720 --> 00:39:16,419
able to also apply those sometimes you

815
00:39:14,540 --> 00:39:19,700
can only apply them during manufacturing

816
00:39:16,420 --> 00:39:20,990
so three things that I want to leave you

817
00:39:19,700 --> 00:39:23,419
with so if you're a security researcher

818
00:39:20,990 --> 00:39:25,220
go learn about hardware attacks and

819
00:39:23,420 --> 00:39:27,200
start exploring the exact servers on

820
00:39:25,220 --> 00:39:30,560
these secure boot there's a lot to see

821
00:39:27,200 --> 00:39:33,549
there a lot to do and it's it's a really

822
00:39:30,560 --> 00:39:37,040
fun exercise for developers

823
00:39:33,550 --> 00:39:39,050
nothing rocket science here secure

824
00:39:37,040 --> 00:39:40,880
development practices make sure that you

825
00:39:39,050 --> 00:39:42,680
limit the attack service of

826
00:39:40,880 --> 00:39:45,019
things that you don't really need in

827
00:39:42,680 --> 00:39:47,930
practice being practice and verified of

828
00:39:45,019 --> 00:39:51,049
what you're doing is actually secure and

829
00:39:47,930 --> 00:39:52,848
if your integrator if you're selecting

830
00:39:51,049 --> 00:39:55,009
components just make sure that you ask

831
00:39:52,849 --> 00:39:57,109
the developers or a third party to

832
00:39:55,009 --> 00:39:59,119
provide some assurance on what the

833
00:39:57,109 --> 00:40:00,769
security that's in there

834
00:39:59,119 --> 00:40:04,460
the more questions they get the more

835
00:40:00,769 --> 00:40:07,700
security will go to the top of mind so

836
00:40:04,460 --> 00:40:11,660
with that I guess I have how many

837
00:40:07,700 --> 00:40:14,240
minutes for questions we have still five

838
00:40:11,660 --> 00:40:16,250
minutes of questions all right I saw

839
00:40:14,240 --> 00:40:19,910
yeah you were first you were halfway

840
00:40:16,250 --> 00:40:21,740
from my talk oh I don't control the mic

841
00:40:19,910 --> 00:40:26,440
sorry we'll get to you

842
00:40:21,740 --> 00:40:31,430
sorry legit so you mentioned you use

843
00:40:26,440 --> 00:40:33,170
power simple power analysis to choose

844
00:40:31,430 --> 00:40:37,180
the proper timing interval for fault

845
00:40:33,170 --> 00:40:39,589
injection yeah do you also use it to

846
00:40:37,180 --> 00:40:42,769
target other types of attacks for

847
00:40:39,589 --> 00:40:46,099
example in your example six where the

848
00:40:42,769 --> 00:40:48,979
mech comparison even after that's fixed

849
00:40:46,099 --> 00:40:50,869
the way you described the XOR of two

850
00:40:48,980 --> 00:40:53,569
values of match will produce a very

851
00:40:50,869 --> 00:40:55,549
different or a more powerful signature

852
00:40:53,569 --> 00:40:57,049
so if you could see that even with

853
00:40:55,549 --> 00:41:00,619
constant time you might be able to

854
00:40:57,049 --> 00:41:05,059
execute the same attack by marching yeah

855
00:41:00,619 --> 00:41:08,839
correct so that is a fairly big if

856
00:41:05,059 --> 00:41:10,789
they'll have the same so the secure boot

857
00:41:08,839 --> 00:41:12,710
example we're talking about a very high

858
00:41:10,789 --> 00:41:15,700
level processes right accepting or not

859
00:41:12,710 --> 00:41:18,440
accepting you see a big difference

860
00:41:15,700 --> 00:41:20,990
seeing the difference in like individual

861
00:41:18,440 --> 00:41:22,849
bits will typically require more like

862
00:41:20,990 --> 00:41:26,689
differential analysis which means that I

863
00:41:22,849 --> 00:41:31,970
have to take many many traces at that

864
00:41:26,690 --> 00:41:33,650
point it might be possible but it's it's

865
00:41:31,970 --> 00:41:38,750
kind of the next in the next level up

866
00:41:33,650 --> 00:41:43,880
now okay so two questions one is related

867
00:41:38,750 --> 00:41:46,490
to the firmware update you know if you

868
00:41:43,880 --> 00:41:48,740
don't have a boot secure boot process

869
00:41:46,490 --> 00:41:51,439
that covers the entire kernel which is

870
00:41:48,740 --> 00:41:53,240
the situation that I had how do you

871
00:41:51,440 --> 00:41:57,170
protect that forever

872
00:41:53,240 --> 00:41:58,970
upgrade module itself where do you put

873
00:41:57,170 --> 00:42:00,980
it you know what do you do is so that

874
00:41:58,970 --> 00:42:03,799
you make sure the firmware update comes

875
00:42:00,980 --> 00:42:06,050
and you verify Utah trust that

876
00:42:03,800 --> 00:42:09,440
verification that's the first question

877
00:42:06,050 --> 00:42:12,350
and the second one is as far as role

878
00:42:09,440 --> 00:42:14,630
anti rollback attack how do you protect

879
00:42:12,350 --> 00:42:17,360
the previous version what do you do with

880
00:42:14,630 --> 00:42:20,960
that informations they make sure when

881
00:42:17,360 --> 00:42:24,290
the next one comes you know your Meritor

882
00:42:20,960 --> 00:42:26,420
holding back okay so first question let

883
00:42:24,290 --> 00:42:28,730
me first make sure that I understand

884
00:42:26,420 --> 00:42:31,190
your questions correctly so in the first

885
00:42:28,730 --> 00:42:34,730
case we have a firmware update mechanism

886
00:42:31,190 --> 00:42:37,730
but you're unable to verify the

887
00:42:34,730 --> 00:42:39,619
mechanism itself digitally during boot

888
00:42:37,730 --> 00:43:03,260
because it's in a non protected part is

889
00:42:39,619 --> 00:43:04,850
that is that correct yeah yeah so the

890
00:43:03,260 --> 00:43:06,380
tricky thing with chain of trust is if

891
00:43:04,850 --> 00:43:08,660
you break it somewhere if you don't

892
00:43:06,380 --> 00:43:11,390
verify something all bets are sort of

893
00:43:08,660 --> 00:43:13,100
off at that point so I think for your

894
00:43:11,390 --> 00:43:16,910
firmware mechanism that's not covered in

895
00:43:13,100 --> 00:43:19,250
there it's gonna be hard to actually

896
00:43:16,910 --> 00:43:23,240
verify the mechanism itself so you have

897
00:43:19,250 --> 00:43:27,080
to make sure that at least whatever that

898
00:43:23,240 --> 00:43:30,649
mechanism is burning into the flash gets

899
00:43:27,080 --> 00:43:31,759
checked upon boot again so then at least

900
00:43:30,650 --> 00:43:36,020
you have coverage of what's being

901
00:43:31,760 --> 00:43:37,850
written and you catch the any changes at

902
00:43:36,020 --> 00:43:40,369
that point but yeah it's going to be

903
00:43:37,850 --> 00:43:46,069
hard to catch it during the deflection

904
00:43:40,369 --> 00:44:06,740
process itself yeah where it writes to

905
00:43:46,070 --> 00:44:09,680
yeah and your second question yeah so

906
00:44:06,740 --> 00:44:11,240
the question is on the anti rollback how

907
00:44:09,680 --> 00:44:13,190
do you trust that the version is

908
00:44:11,240 --> 00:44:15,200
actually the correct version so yes you

909
00:44:13,190 --> 00:44:17,300
make that part of the signature so you

910
00:44:15,200 --> 00:44:20,540
first signature verify that the version

911
00:44:17,300 --> 00:44:23,690
is correct then if the version is higher

912
00:44:20,540 --> 00:44:25,850
than what I have in my OTP Goulburn OTP

913
00:44:23,690 --> 00:44:27,800
to the to the next version and then

914
00:44:25,850 --> 00:44:35,170
you've sort of blocked that that version

915
00:44:27,800 --> 00:44:38,270
in yes yes because that sort of ground

916
00:44:35,170 --> 00:44:39,560
grounds the anti rollback version it's

917
00:44:38,270 --> 00:44:43,390
something that's really hard to change

918
00:44:39,560 --> 00:44:45,109
for an attacker who isn't going invasive

919
00:44:43,390 --> 00:44:49,868
any other questions

920
00:44:45,109 --> 00:44:52,700
hi I'm curious about your opinion

921
00:44:49,869 --> 00:44:56,960
regarding the fault injection attacks

922
00:44:52,700 --> 00:45:00,200
that are targeting system on chips that

923
00:44:56,960 --> 00:45:02,480
involves DRAM the cat pink from the

924
00:45:00,200 --> 00:45:06,589
offensive and defensive perspective and

925
00:45:02,480 --> 00:45:08,960
have you ever done similar work with no

926
00:45:06,590 --> 00:45:12,200
are you talking about SOC s that have a

927
00:45:08,960 --> 00:45:13,490
DRM integrated in the package yeah so

928
00:45:12,200 --> 00:45:17,540
that definitely has effects on fault

929
00:45:13,490 --> 00:45:18,859
injection depending on what mechanism

930
00:45:17,540 --> 00:45:20,390
fault injection were talking to if we're

931
00:45:18,859 --> 00:45:24,049
talking about VC C glitching it

932
00:45:20,390 --> 00:45:28,990
shouldn't be a difference for Francis II

933
00:45:24,050 --> 00:45:32,960
M glitching you now have a layer of DRAM

934
00:45:28,990 --> 00:45:35,868
sort of in between your sorry DRM is on

935
00:45:32,960 --> 00:45:37,880
top of your core silicon so it's much

936
00:45:35,869 --> 00:45:39,530
harder to glitch and we've seen that in

937
00:45:37,880 --> 00:45:42,380
practice that it's really hard to get to

938
00:45:39,530 --> 00:45:45,740
the to the CPU we haven't studied in

939
00:45:42,380 --> 00:45:47,780
depth yet if you can glitch the DRAM in

940
00:45:45,740 --> 00:45:49,520
such a way that it's nicely exploitable

941
00:45:47,780 --> 00:45:53,680
so that would be sort of an area of

942
00:45:49,520 --> 00:45:56,509
research similar argumentation holds for

943
00:45:53,680 --> 00:45:59,690
for laser fault injection right so you

944
00:45:56,510 --> 00:46:03,580
cannot get to the DRAM now one thing

945
00:45:59,690 --> 00:46:06,090
that you should take in mind is that

946
00:46:03,580 --> 00:46:09,360
DRAM is not active

947
00:46:06,090 --> 00:46:12,060
sort of the first cycle of boots so you

948
00:46:09,360 --> 00:46:13,800
can get that way into boot while you

949
00:46:12,060 --> 00:46:16,560
have to be around taken off as well so

950
00:46:13,800 --> 00:46:18,090
depending on your goal you may or may

951
00:46:16,560 --> 00:46:21,240
not be able to achieve that goal even

952
00:46:18,090 --> 00:46:23,880
when you take the drm off in the package

953
00:46:21,240 --> 00:46:27,450
it's a bit of invasive work but you

954
00:46:23,880 --> 00:46:29,520
might get some steps in okay all right

955
00:46:27,450 --> 00:46:30,279
so thank you thank you this yeah thank

956
00:46:29,520 --> 00:46:33,359
you very much

957
00:46:30,280 --> 00:46:33,359
[Applause]

