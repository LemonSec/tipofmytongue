1
00:00:02,560 --> 00:00:07,660
hi morning well welcome back I'm

2
00:00:06,010 --> 00:00:12,040
probably the third Chris on the stage

3
00:00:07,660 --> 00:00:14,200
basically well in a in a row nice to be

4
00:00:12,040 --> 00:00:17,099
here for the first time in the US will

5
00:00:14,200 --> 00:00:19,560
have great you I've been presenting on

6
00:00:17,100 --> 00:00:21,970
previously in the Netherlands up radio

7
00:00:19,560 --> 00:00:24,790
open fault injection attacks and

8
00:00:21,970 --> 00:00:27,759
blackhat on white post photography I've

9
00:00:24,790 --> 00:00:31,299
been exploring a number of our maps

10
00:00:27,760 --> 00:00:32,950
based devices and recently also blue hat

11
00:00:31,300 --> 00:00:35,410
will be passed into your boot and

12
00:00:32,950 --> 00:00:37,149
encrypted one without naming a key so

13
00:00:35,410 --> 00:00:38,769
more or less this describes in brief

14
00:00:37,149 --> 00:00:41,559
what I've been doing the last few years

15
00:00:38,769 --> 00:00:44,320
a bit of tease which have been given to

16
00:00:41,559 --> 00:00:47,949
training recently but one of my interest

17
00:00:44,320 --> 00:00:51,399
is also having applying all the tax or

18
00:00:47,949 --> 00:00:53,409
something which may be in corners or

19
00:00:51,399 --> 00:00:56,620
what seems to be as a practical

20
00:00:53,409 --> 00:00:59,559
applicable in general to to new context

21
00:00:56,620 --> 00:01:01,809
so for example I found extremely

22
00:00:59,559 --> 00:01:04,120
interesting the fact that we do have a

23
00:01:01,809 --> 00:01:06,190
trends of new devices of course in the

24
00:01:04,120 --> 00:01:08,710
last few years that I have heavily

25
00:01:06,190 --> 00:01:13,539
connected which I am to be low-power

26
00:01:08,710 --> 00:01:15,820
which aim to be portable and so they

27
00:01:13,540 --> 00:01:18,399
don't have so much say requirements in

28
00:01:15,820 --> 00:01:21,639
terms of performance in terms of CPU

29
00:01:18,399 --> 00:01:25,180
requirements so basically there may be a

30
00:01:21,640 --> 00:01:27,399
new kind of scenarios where all the tax

31
00:01:25,180 --> 00:01:30,030
may apply to in your context and I

32
00:01:27,399 --> 00:01:32,710
wanted to explore the timing attack here

33
00:01:30,030 --> 00:01:36,000
so I am sure that everybody's familiar a

34
00:01:32,710 --> 00:01:40,298
bit with the timing attacks who is not

35
00:01:36,000 --> 00:01:41,710
Wow impressive good that's great so

36
00:01:40,299 --> 00:01:42,820
that's a string compare plucks

37
00:01:41,710 --> 00:01:45,640
implementation

38
00:01:42,820 --> 00:01:47,740
this is surviving is taken from an open

39
00:01:45,640 --> 00:01:50,530
source project you see Lipsy so

40
00:01:47,740 --> 00:01:52,630
basically is the latest version it is

41
00:01:50,530 --> 00:01:55,869
available on million devices at the

42
00:01:52,630 --> 00:02:00,369
moment okay so nothing really strange

43
00:01:55,869 --> 00:02:02,170
your of fancy the food source code

44
00:02:00,369 --> 00:02:06,969
available so you can actually check what

45
00:02:02,170 --> 00:02:09,670
I'm whatever I'm saying here well first

46
00:02:06,969 --> 00:02:15,240
let's check do see any burner ability

47
00:02:09,669 --> 00:02:22,440
over here is it vulnerable No

48
00:02:15,240 --> 00:02:24,390
timing a limit to something else if you

49
00:02:22,440 --> 00:02:25,980
if you find something please file a CV

50
00:02:24,390 --> 00:02:27,869
are you even not being able to find

51
00:02:25,980 --> 00:02:31,019
anything soft revised or logical wise

52
00:02:27,870 --> 00:02:33,870
okay but as soon as we put in scope the

53
00:02:31,020 --> 00:02:36,420
number of situation where well I think

54
00:02:33,870 --> 00:02:39,330
that everybody is a is familiar with

55
00:02:36,420 --> 00:02:41,040
here we will probably here with the

56
00:02:39,330 --> 00:02:42,780
early termination of course and then you

57
00:02:41,040 --> 00:02:44,790
have a timing attack I'm going to

58
00:02:42,780 --> 00:02:47,730
explain that a bit earlier so this means

59
00:02:44,790 --> 00:02:49,410
basically that's this sling compare

60
00:02:47,730 --> 00:02:51,600
function by the way the mem compare

61
00:02:49,410 --> 00:02:54,750
function is the same the strings do not

62
00:02:51,600 --> 00:02:57,079
have anything special over here so

63
00:02:54,750 --> 00:03:01,340
basically the comparison is done

64
00:02:57,080 --> 00:03:04,830
character by character is here basically

65
00:03:01,340 --> 00:03:06,990
one by one and it actually stops as soon

66
00:03:04,830 --> 00:03:08,700
there is a brown one okay this is a

67
00:03:06,990 --> 00:03:10,620
typical normal implementation for

68
00:03:08,700 --> 00:03:12,839
performance and you don't need to

69
00:03:10,620 --> 00:03:16,200
compare the full strings so what is the

70
00:03:12,840 --> 00:03:18,210
the problem over here of course that if

71
00:03:16,200 --> 00:03:21,989
I send a wrong character which I don't

72
00:03:18,210 --> 00:03:25,010
know what it is basically what happens

73
00:03:21,990 --> 00:03:27,600
is that the loop is done in this way I

74
00:03:25,010 --> 00:03:31,500
just go through and through the wire

75
00:03:27,600 --> 00:03:33,329
just exit directly okay so I don't know

76
00:03:31,500 --> 00:03:36,960
if this is a wrong character I just send

77
00:03:33,330 --> 00:03:40,050
one okay then I send by chance a good

78
00:03:36,960 --> 00:03:41,670
one and then if I send send by chance a

79
00:03:40,050 --> 00:03:44,100
good one the loop that you actually see

80
00:03:41,670 --> 00:03:47,010
there is that you check the first one

81
00:03:44,100 --> 00:03:48,960
the while actually says it's a good one

82
00:03:47,010 --> 00:03:51,660
so basically you actually do the loop

83
00:03:48,960 --> 00:03:54,090
again and then because the second one

84
00:03:51,660 --> 00:03:57,270
that I sent is likely incorrect

85
00:03:54,090 --> 00:04:01,110
it's just exit so basically I have a

86
00:03:57,270 --> 00:04:05,010
distinguish in behavior so the device or

87
00:04:01,110 --> 00:04:06,840
the target behaves differently if I send

88
00:04:05,010 --> 00:04:08,399
a good character or a wrong one

89
00:04:06,840 --> 00:04:13,050
basically even if I don't know if it's

90
00:04:08,400 --> 00:04:15,570
good or one so in principle I am in

91
00:04:13,050 --> 00:04:17,730
facing what is called the non time cost

92
00:04:15,570 --> 00:04:19,529
and software it's a general problem it's

93
00:04:17,730 --> 00:04:22,620
not only for this string compare it's

94
00:04:19,529 --> 00:04:25,619
available many other parts of software

95
00:04:22,620 --> 00:04:27,620
and usually this is taken care of only

96
00:04:25,620 --> 00:04:32,520
in situation

97
00:04:27,620 --> 00:04:34,230
the side-channel attacks or the the kind

98
00:04:32,520 --> 00:04:37,710
of attacks of the threat model you are

99
00:04:34,230 --> 00:04:39,780
facing is actually included okay so this

100
00:04:37,710 --> 00:04:41,580
code is presented now on millions of

101
00:04:39,780 --> 00:04:43,830
devices and no one is complaining about

102
00:04:41,580 --> 00:04:46,229
anything about so let's let's just make

103
00:04:43,830 --> 00:04:48,870
this clear and I don't think they

104
00:04:46,230 --> 00:04:51,180
generally it should be a concern in any

105
00:04:48,870 --> 00:04:53,490
places but let's see when this can be a

106
00:04:51,180 --> 00:04:56,100
bouncer the problem the point is that

107
00:04:53,490 --> 00:04:58,470
the timing differences that happen when

108
00:04:56,100 --> 00:05:00,260
I give a stimulus to a device actually

109
00:04:58,470 --> 00:05:02,790
can tell me something in general

110
00:05:00,260 --> 00:05:04,860
basically give an input to the device

111
00:05:02,790 --> 00:05:06,870
and I just see the behavior even if in a

112
00:05:04,860 --> 00:05:08,490
Fiat I don't know anything basically in

113
00:05:06,870 --> 00:05:11,730
this case I can actually measure measure

114
00:05:08,490 --> 00:05:13,200
the time the response time because I can

115
00:05:11,730 --> 00:05:16,140
send the character and it takes one

116
00:05:13,200 --> 00:05:18,659
second it's a wrong one if I get a

117
00:05:16,140 --> 00:05:20,729
response of after two seconds was

118
00:05:18,660 --> 00:05:23,100
actually isn't much less of course but

119
00:05:20,730 --> 00:05:24,630
the idea is that that I sent the right

120
00:05:23,100 --> 00:05:26,640
character okay so okay

121
00:05:24,630 --> 00:05:28,920
I've found the right one so basically I

122
00:05:26,640 --> 00:05:31,409
can go to the next one but in general

123
00:05:28,920 --> 00:05:33,420
the time indifference medic information

124
00:05:31,410 --> 00:05:36,890
on what is not directly observable

125
00:05:33,420 --> 00:05:41,220
basically on what is available happening

126
00:05:36,890 --> 00:05:43,380
in a device or even in HSM even in a in

127
00:05:41,220 --> 00:05:46,590
a smart card so I'm talking about a

128
00:05:43,380 --> 00:05:48,570
general problem here it can be used also

129
00:05:46,590 --> 00:05:51,270
as a notable for testing assumptions

130
00:05:48,570 --> 00:05:54,930
model like for example I think that the

131
00:05:51,270 --> 00:05:56,909
software may behave in this way maybe if

132
00:05:54,930 --> 00:05:58,950
it behaves in this way it has this time

133
00:05:56,910 --> 00:06:01,350
incorrect textus instead if it is

134
00:05:58,950 --> 00:06:03,420
another way I can actually use it as an

135
00:06:01,350 --> 00:06:05,730
information for reversing what I don't

136
00:06:03,420 --> 00:06:09,030
know offer up the information or what I

137
00:06:05,730 --> 00:06:12,690
don't know so the requirement is that

138
00:06:09,030 --> 00:06:14,400
the time leak needs to be present on an

139
00:06:12,690 --> 00:06:16,020
observable channel of course if you

140
00:06:14,400 --> 00:06:18,030
cannot observe the channel you cannot

141
00:06:16,020 --> 00:06:19,409
make the measurement so if you will not

142
00:06:18,030 --> 00:06:22,380
make the measurement you cannot take

143
00:06:19,410 --> 00:06:24,210
that information out and of course the

144
00:06:22,380 --> 00:06:26,270
measurement needs to happen with

145
00:06:24,210 --> 00:06:28,200
sufficient precision and accuracy

146
00:06:26,270 --> 00:06:32,460
everybody's familiar with the difference

147
00:06:28,200 --> 00:06:34,920
between precision accuracy right just to

148
00:06:32,460 --> 00:06:37,169
make a bit of make clear you have

149
00:06:34,920 --> 00:06:39,840
precision when basically you have a very

150
00:06:37,170 --> 00:06:41,370
scale which is very precise and defined

151
00:06:39,840 --> 00:06:43,310
for example you have a nanosec

152
00:06:41,370 --> 00:06:45,389
precision when I can tell something

153
00:06:43,310 --> 00:06:47,310
distinguish one process from another

154
00:06:45,389 --> 00:06:49,320
from with a one man on second position

155
00:06:47,310 --> 00:06:51,750
it doesn't mean that the measurement

156
00:06:49,320 --> 00:06:53,070
that I'm taking is accurate so it

157
00:06:51,750 --> 00:06:55,020
doesn't mean that the value that they

158
00:06:53,070 --> 00:06:56,960
are measuring at the moment is actually

159
00:06:55,020 --> 00:06:58,650
the real value of that measurement so

160
00:06:56,960 --> 00:07:00,120
depending where you take the

161
00:06:58,650 --> 00:07:02,429
measurements you might have different

162
00:07:00,120 --> 00:07:05,690
degrees of precision so because you have

163
00:07:02,430 --> 00:07:09,000
better counters or a different degree of

164
00:07:05,690 --> 00:07:11,940
sorry or accuracy depending on where you

165
00:07:09,000 --> 00:07:14,130
take to give you a small example if I

166
00:07:11,940 --> 00:07:18,330
take the measurement with an FPGA

167
00:07:14,130 --> 00:07:21,180
on the network basically I have quite a

168
00:07:18,330 --> 00:07:23,969
high degree of precision or accuracy

169
00:07:21,180 --> 00:07:25,530
sorry because I don't have do now is on

170
00:07:23,970 --> 00:07:27,060
the host because it's directly on the

171
00:07:25,530 --> 00:07:29,179
network I don't have scheduling on the

172
00:07:27,060 --> 00:07:31,800
colonel I don't have any other things

173
00:07:29,180 --> 00:07:34,770
but the position depends basically on

174
00:07:31,800 --> 00:07:37,620
the speedo FPGA vice versa if I take a

175
00:07:34,770 --> 00:07:39,539
user space measurement I have the real

176
00:07:37,620 --> 00:07:42,740
time personal performance counters of

177
00:07:39,539 --> 00:07:46,680
the CPU we had four biggest they give me

178
00:07:42,740 --> 00:07:48,720
250 Pico seconds precision but you have

179
00:07:46,680 --> 00:07:50,280
so much noise from the kernel scheduling

180
00:07:48,720 --> 00:07:52,919
from the interrupts and so on that the

181
00:07:50,280 --> 00:07:55,830
measurement is inaccurate okay this is

182
00:07:52,919 --> 00:07:59,280
just so make think 3 or what I mean by

183
00:07:55,830 --> 00:08:02,250
precision accuracy so the basic idea in

184
00:07:59,280 --> 00:08:05,010
general is that you send a request it

185
00:08:02,250 --> 00:08:07,200
might be any kind of probe try to fit

186
00:08:05,010 --> 00:08:10,380
this in a general way maybe an SPI

187
00:08:07,200 --> 00:08:12,270
requests or an SPI Channel okay maybe

188
00:08:10,380 --> 00:08:15,240
anything on any channel where you can

189
00:08:12,270 --> 00:08:16,859
actually excerpt and send a request and

190
00:08:15,240 --> 00:08:18,349
you measure the time phone response

191
00:08:16,860 --> 00:08:20,820
towards do it directly

192
00:08:18,349 --> 00:08:23,340
this is always a body where is always a

193
00:08:20,820 --> 00:08:25,020
very good exercises regardless of what

194
00:08:23,340 --> 00:08:28,229
you're doing for example people are

195
00:08:25,020 --> 00:08:30,419
using timing correlation between SPI

196
00:08:28,229 --> 00:08:32,338
accesses a civil boot in order to make

197
00:08:30,419 --> 00:08:34,319
have a good insight what's happening

198
00:08:32,339 --> 00:08:36,270
during the seizure boot by measuring the

199
00:08:34,320 --> 00:08:39,180
timing for accessing the SPI

200
00:08:36,270 --> 00:08:43,409
so time gives you much more than just

201
00:08:39,179 --> 00:08:44,849
what time is it now so basically to

202
00:08:43,409 --> 00:08:46,920
collect time measurement for the first

203
00:08:44,850 --> 00:08:48,540
character you need to collect multiple

204
00:08:46,920 --> 00:08:50,660
requests for each candidate that's

205
00:08:48,540 --> 00:08:54,209
obvious

206
00:08:50,660 --> 00:08:56,520
basically you need to group the request

207
00:08:54,210 --> 00:09:00,180
you need to choose an estimators and set

208
00:08:56,520 --> 00:09:03,270
establish a show like for example I'm

209
00:09:00,180 --> 00:09:05,729
counting let's say the average of this

210
00:09:03,270 --> 00:09:07,860
population okay and let's say that these

211
00:09:05,730 --> 00:09:10,649
two characters are distinguished when

212
00:09:07,860 --> 00:09:13,230
they differ by or not 10 micro second I

213
00:09:10,649 --> 00:09:15,110
have set an estimate of the average you

214
00:09:13,230 --> 00:09:17,399
have set a difference for the trash shot

215
00:09:15,110 --> 00:09:19,050
this is a general process it doesn't

216
00:09:17,399 --> 00:09:21,149
change if you bring their own network

217
00:09:19,050 --> 00:09:24,479
remotely locally it will happen

218
00:09:21,149 --> 00:09:26,670
regardless unless you are in a very

219
00:09:24,480 --> 00:09:28,800
lucky situation where one measurement is

220
00:09:26,670 --> 00:09:29,610
already sufficient for telling the good

221
00:09:28,800 --> 00:09:33,089
from the bad

222
00:09:29,610 --> 00:09:34,170
basically the point is that telling the

223
00:09:33,089 --> 00:09:36,420
good from the bad unfortunately

224
00:09:34,170 --> 00:09:38,339
something which is a bit underestimated

225
00:09:36,420 --> 00:09:40,110
when you actually look at blog post and

226
00:09:38,339 --> 00:09:42,209
all these things people say yeah I can

227
00:09:40,110 --> 00:09:44,550
distinguish a one character guru from

228
00:09:42,209 --> 00:09:46,560
one character bad well that's a very

229
00:09:44,550 --> 00:09:50,790
good start now house a distinguished in

230
00:09:46,560 --> 00:09:53,579
one current good from 255 454 character

231
00:09:50,790 --> 00:09:55,140
bed with all the noise without the

232
00:09:53,580 --> 00:09:57,810
measure and then if you are able to do

233
00:09:55,140 --> 00:10:00,839
that then we are on to something so the

234
00:09:57,810 --> 00:10:04,020
ability to distinguish that and only the

235
00:10:00,839 --> 00:10:06,900
good and bad does not help you you need

236
00:10:04,020 --> 00:10:09,660
to distinguish the route at among the

237
00:10:06,900 --> 00:10:11,279
entire population or the other beds so

238
00:10:09,660 --> 00:10:14,699
this means that your statistics needs to

239
00:10:11,279 --> 00:10:17,070
be quite relevant and strong and this is

240
00:10:14,700 --> 00:10:19,709
a bit that is often as I underestimated

241
00:10:17,070 --> 00:10:22,339
I think in 70 80 percent or damning

242
00:10:19,709 --> 00:10:25,010
attack articles that you see outside

243
00:10:22,339 --> 00:10:29,160
then you go to the next one basically

244
00:10:25,010 --> 00:10:31,260
what's been done until now well relevant

245
00:10:29,160 --> 00:10:33,680
application been the extraction of

246
00:10:31,260 --> 00:10:36,540
cryptographic keys SQL injection

247
00:10:33,680 --> 00:10:38,459
basically remote possible guessing

248
00:10:36,540 --> 00:10:40,199
although not so much for a reason which

249
00:10:38,459 --> 00:10:42,150
we are going to discuss in a moment and

250
00:10:40,200 --> 00:10:44,160
even net spectra with page timing

251
00:10:42,150 --> 00:10:46,680
attacks some are quite exotic some are

252
00:10:44,160 --> 00:10:49,800
they are quite practical the SQL

253
00:10:46,680 --> 00:10:51,779
injection is do is actually used in the

254
00:10:49,800 --> 00:10:54,229
case of blind SQL injection when you

255
00:10:51,779 --> 00:10:59,090
need to extract elects a table a name

256
00:10:54,230 --> 00:11:00,710
and other field names and so on I'm not

257
00:10:59,090 --> 00:11:03,680
an expert on this part to leave these to

258
00:11:00,710 --> 00:11:06,050
other people but what I'm expert about

259
00:11:03,680 --> 00:11:07,880
is that for sugar the time difference is

260
00:11:06,050 --> 00:11:10,790
that you need to measure go between 1

261
00:11:07,880 --> 00:11:14,710
milliseconds and one second so these are

262
00:11:10,790 --> 00:11:18,819
things which are 10 to the power of 6

263
00:11:14,710 --> 00:11:21,470
slower than one CPU going at 1 gigahertz

264
00:11:18,820 --> 00:11:24,380
so this is what we are discussing about

265
00:11:21,470 --> 00:11:26,420
and these things are measurable over the

266
00:11:24,380 --> 00:11:30,189
network what can we do now on the

267
00:11:26,420 --> 00:11:32,199
network nowadays we can perform

268
00:11:30,190 --> 00:11:34,880
measurement we can distinguish

269
00:11:32,200 --> 00:11:37,490
differences for 100 honest icons over

270
00:11:34,880 --> 00:11:39,620
the LAN locally so if you are not on the

271
00:11:37,490 --> 00:11:42,650
same LAN we can take enough measurement

272
00:11:39,620 --> 00:11:46,190
for distinguishing processes of 100 nano

273
00:11:42,650 --> 00:11:48,699
second difference while remotely we can

274
00:11:46,190 --> 00:11:52,160
actually do with the most 1 microsecond

275
00:11:48,700 --> 00:11:54,410
do you have an idea why do one not want

276
00:11:52,160 --> 00:11:57,500
a nanosecond is the limit at the moment

277
00:11:54,410 --> 00:12:04,189
I have found guess but I would like to

278
00:11:57,500 --> 00:12:06,320
also utopia please I display would be

279
00:12:04,190 --> 00:12:09,040
the one under the one gigas probably but

280
00:12:06,320 --> 00:12:09,040
I think you are onto something

281
00:12:09,880 --> 00:12:16,760
yeah the so the unfortunate part at this

282
00:12:13,610 --> 00:12:18,350
paper this didn't specify the set up so

283
00:12:16,760 --> 00:12:20,480
we don't know how they detect the

284
00:12:18,350 --> 00:12:24,830
measurement but there is one thing if

285
00:12:20,480 --> 00:12:26,810
you work on with the gigabit network

286
00:12:24,830 --> 00:12:28,070
basically the there is something which

287
00:12:26,810 --> 00:12:30,979
is called with an internet something

288
00:12:28,070 --> 00:12:32,900
would cause a interframe gap this means

289
00:12:30,980 --> 00:12:36,260
that you cannot put something on the

290
00:12:32,900 --> 00:12:38,209
network faster that mean the finger so

291
00:12:36,260 --> 00:12:41,120
this means that if I remember correctly

292
00:12:38,210 --> 00:12:43,940
should be something like 916 nanoseconds

293
00:12:41,120 --> 00:12:47,210
when I am 240 bear with me whether we

294
00:12:43,940 --> 00:12:52,060
run there it's almost 1 microsecond for

295
00:12:47,210 --> 00:12:55,400
100 megabit and goes down to 96 or 94

296
00:12:52,060 --> 00:12:58,339
nanosecond for one gigabit so my

297
00:12:55,400 --> 00:13:01,670
impression my expectations that we reach

298
00:12:58,340 --> 00:13:04,460
that those pops I'm sorry those levels

299
00:13:01,670 --> 00:13:06,260
here just because we are working a

300
00:13:04,460 --> 00:13:07,220
maximum with one gigabit because you're

301
00:13:06,260 --> 00:13:10,790
simply

302
00:13:07,220 --> 00:13:12,110
precision is not high enough is that the

303
00:13:10,790 --> 00:13:14,990
limit of what you can actually measure

304
00:13:12,110 --> 00:13:19,610
and then you can go up basically and

305
00:13:14,990 --> 00:13:21,470
this actually also explains a few things

306
00:13:19,610 --> 00:13:23,810
which I'm going to say after so I'm glad

307
00:13:21,470 --> 00:13:25,610
that I'm not the only one thinking and

308
00:13:23,810 --> 00:13:27,949
if you have other ideas of why this is

309
00:13:25,610 --> 00:13:31,490
the limit at the moment I would be glad

310
00:13:27,950 --> 00:13:35,150
to hear so the point is the following

311
00:13:31,490 --> 00:13:37,550
that you're working with a widow fast PC

312
00:13:35,150 --> 00:13:39,800
which is over the network which is a

313
00:13:37,550 --> 00:13:41,689
four biggest clock for example now it's

314
00:13:39,800 --> 00:13:43,010
not that rare I mean nowadays you will

315
00:13:41,690 --> 00:13:46,100
expect something like that from an

316
00:13:43,010 --> 00:13:50,030
internet server so this means that one

317
00:13:46,100 --> 00:13:54,590
clock tick is a 250 picoseconds to give

318
00:13:50,030 --> 00:13:57,530
you an idea we already almost 7

319
00:13:54,590 --> 00:13:59,630
magnitude orders slower for faster that

320
00:13:57,530 --> 00:14:02,240
that's SQL injection so this means that

321
00:13:59,630 --> 00:14:04,220
even if you are measuring something of

322
00:14:02,240 --> 00:14:06,950
the network on a browser basically you

323
00:14:04,220 --> 00:14:08,960
have a millisecond precision and if on

324
00:14:06,950 --> 00:14:11,360
the other side the answer within half a

325
00:14:08,960 --> 00:14:12,920
second you have enough precision for

326
00:14:11,360 --> 00:14:15,110
getting data so this why is fuel

327
00:14:12,920 --> 00:14:18,110
injection blind and timing it is

328
00:14:15,110 --> 00:14:20,000
possible at the moment but we are birthd

329
00:14:18,110 --> 00:14:21,770
us better stuff for the more the moment

330
00:14:20,000 --> 00:14:23,810
so this means that if you take one

331
00:14:21,770 --> 00:14:25,610
single string compare loop the one with

332
00:14:23,810 --> 00:14:29,780
actually that and you compile that on

333
00:14:25,610 --> 00:14:32,990
x86 I know because I did it you get 13

334
00:14:29,780 --> 00:14:35,600
instruction more or less that at that

335
00:14:32,990 --> 00:14:38,930
speed it takes more or less 3

336
00:14:35,600 --> 00:14:40,970
nanoseconds assuming that you can do one

337
00:14:38,930 --> 00:14:43,280
instruction per clock cycle which is a

338
00:14:40,970 --> 00:14:47,030
very weary assumption nowadays so it's

339
00:14:43,280 --> 00:14:48,620
probably even faster than that so

340
00:14:47,030 --> 00:14:51,170
basically we are in this situation that

341
00:14:48,620 --> 00:14:56,860
the state of the art oh the state of the

342
00:14:51,170 --> 00:15:00,229
art remote can measure 1007 so a microbe

343
00:14:56,860 --> 00:15:05,750
locally you and Ashley do that and the

344
00:15:00,230 --> 00:15:09,100
PC is more or less like this so no I

345
00:15:05,750 --> 00:15:13,070
don't think we have enough precision I

346
00:15:09,100 --> 00:15:16,150
would say that in environment where we

347
00:15:13,070 --> 00:15:18,259
might have 10 gigabit to 100 gigabit

348
00:15:16,150 --> 00:15:20,569
environment you might have the right

349
00:15:18,259 --> 00:15:23,799
position or even for do attacking that

350
00:15:20,569 --> 00:15:26,358
string compare locally between server

351
00:15:23,799 --> 00:15:30,679
keep in mind that I've done this attack

352
00:15:26,359 --> 00:15:33,259
instead between on the same host two

353
00:15:30,679 --> 00:15:35,629
processes and woody piece of it facially

354
00:15:33,259 --> 00:15:38,419
and it does not go through the internet

355
00:15:35,629 --> 00:15:40,729
so this means that I don't have they

356
00:15:38,419 --> 00:15:44,959
didn't offend gap at the moment I was

357
00:15:40,729 --> 00:15:49,339
able to break this with a timing attack

358
00:15:44,959 --> 00:15:52,518
a password on a four big eight as CPU

359
00:15:49,339 --> 00:15:54,470
between two processes as this gives me

360
00:15:52,519 --> 00:15:56,539
confidence it is actually the ethernet

361
00:15:54,470 --> 00:15:58,160
channel that is possible maybe we can

362
00:15:56,539 --> 00:16:00,049
actually discuss that a bit later

363
00:15:58,160 --> 00:16:02,419
it's not in this presentation but maybe

364
00:16:00,049 --> 00:16:04,879
interesting if you have a cross vm's

365
00:16:02,419 --> 00:16:07,009
processes that talks or socket and where

366
00:16:04,879 --> 00:16:09,619
you have adjust anything which is

367
00:16:07,009 --> 00:16:12,259
compared by a string compare or a mem

368
00:16:09,619 --> 00:16:15,220
compare which is also by the way and let

369
00:16:12,259 --> 00:16:18,049
me add here is not a good design

370
00:16:15,220 --> 00:16:19,429
practice of course if you are actually

371
00:16:18,049 --> 00:16:21,679
doing it on the integration should never

372
00:16:19,429 --> 00:16:25,009
use your password directly in your

373
00:16:21,679 --> 00:16:28,249
comparison you should use much much

374
00:16:25,009 --> 00:16:31,939
better than that so if I would be

375
00:16:28,249 --> 00:16:33,829
attacking probably I don't know clouds

376
00:16:31,939 --> 00:16:36,079
and VMs over clouds probabilities would

377
00:16:33,829 --> 00:16:39,049
not be so much applicable because I hope

378
00:16:36,079 --> 00:16:40,729
that people actually do design this this

379
00:16:39,049 --> 00:16:45,529
feels nicely although you never know

380
00:16:40,730 --> 00:16:47,869
course so basically I would say that I

381
00:16:45,529 --> 00:16:49,579
agree that with people with Morgan and

382
00:16:47,869 --> 00:16:51,259
Morgan they have two different Morgan to

383
00:16:49,579 --> 00:16:54,039
the black hats that says that it's

384
00:16:51,259 --> 00:16:57,109
impractical in vast majority of cases in

385
00:16:54,039 --> 00:16:58,669
2015 but the case that they were

386
00:16:57,109 --> 00:17:01,100
considering and that the literature

387
00:16:58,669 --> 00:17:03,889
until now was considered our remote

388
00:17:01,100 --> 00:17:06,139
servers with fast CPUs or network

389
00:17:03,889 --> 00:17:08,179
connection and on that part I fully

390
00:17:06,138 --> 00:17:12,138
agree that would not even spend five

391
00:17:08,179 --> 00:17:14,029
seconds on thinking of that but we have

392
00:17:12,138 --> 00:17:16,250
another thing nowadays which is was not

393
00:17:14,029 --> 00:17:22,789
even there like for four or five years

394
00:17:16,250 --> 00:17:24,859
ago and still people in 2014 operator

395
00:17:22,789 --> 00:17:28,010
said yes this indicates the timing

396
00:17:24,859 --> 00:17:29,330
attacks on regular stream comparison

397
00:17:28,010 --> 00:17:31,790
to be a soon physical to for any

398
00:17:29,330 --> 00:17:32,870
embedded system or a in 2014 and that's

399
00:17:31,790 --> 00:17:35,240
where the search stopped

400
00:17:32,870 --> 00:17:38,389
nobody even looked at that even anymore

401
00:17:35,240 --> 00:17:40,220
on this stuff really keep in mind that's

402
00:17:38,390 --> 00:17:42,830
being able to attack the stream compare

403
00:17:40,220 --> 00:17:46,400
means to need means to be able to attack

404
00:17:42,830 --> 00:17:49,250
any other situation where you are

405
00:17:46,400 --> 00:17:51,370
leaking times any because that's the

406
00:17:49,250 --> 00:17:54,200
fastest situation that you can have

407
00:17:51,370 --> 00:17:57,199
unless you do basically a comparison on

408
00:17:54,200 --> 00:17:58,730
an FPGA with an X or in parallel and all

409
00:17:57,200 --> 00:18:00,169
the spins and then it's another point

410
00:17:58,730 --> 00:18:02,419
but software-wise

411
00:18:00,169 --> 00:18:04,220
if you're able to attack that then all

412
00:18:02,419 --> 00:18:06,740
the other situation which are time

413
00:18:04,220 --> 00:18:09,020
dependent becomes immediately feasible

414
00:18:06,740 --> 00:18:11,630
okay so that's why for me it's a

415
00:18:09,020 --> 00:18:13,549
distinguisher see if I can do that now

416
00:18:11,630 --> 00:18:16,790
and embed the device on an IOT device

417
00:18:13,549 --> 00:18:21,350
then all the other things become

418
00:18:16,790 --> 00:18:23,178
immediately available okay so that was

419
00:18:21,350 --> 00:18:26,540
my interest basically what you see here

420
00:18:23,179 --> 00:18:27,980
instead are a number of measurement that

421
00:18:26,540 --> 00:18:32,870
is that I've done the same thing

422
00:18:27,980 --> 00:18:34,970
compared on a different systems okay so

423
00:18:32,870 --> 00:18:39,649
this is the status of the state of the

424
00:18:34,970 --> 00:18:41,470
art for local this is the line if you

425
00:18:39,650 --> 00:18:46,510
are above this line I can actually

426
00:18:41,470 --> 00:18:49,299
likely attack you with a 1 gigabit

427
00:18:46,510 --> 00:18:53,240
connection in the local LAN

428
00:18:49,299 --> 00:18:57,799
ok so basically what you see here is

429
00:18:53,240 --> 00:19:00,740
that Netgear at seven eight zero zero is

430
00:18:57,799 --> 00:19:02,450
one point seven giggles it's like this

431
00:19:00,740 --> 00:19:05,210
keep in mind though that this guy is

432
00:19:02,450 --> 00:19:08,929
frequency scaling so this plane go down

433
00:19:05,210 --> 00:19:12,590
to 800 megahertz so it goes up of course

434
00:19:08,929 --> 00:19:17,600
it was lower the raspberry pi here is

435
00:19:12,590 --> 00:19:20,899
one point two we are right I think is

436
00:19:17,600 --> 00:19:25,219
about 50 nanoseconds one single loop I

437
00:19:20,900 --> 00:19:27,320
still can not do that although I would

438
00:19:25,220 --> 00:19:29,179
be curious to do that if Raspberry Pi

439
00:19:27,320 --> 00:19:32,750
had one gigabit interface they don't

440
00:19:29,179 --> 00:19:34,860
have for showing that they have only 100

441
00:19:32,750 --> 00:19:40,779
megabit and that's the limiting factor

442
00:19:34,860 --> 00:19:46,748
basically but there is another one here

443
00:19:40,779 --> 00:19:48,100
let me check this one is a DSP 32 at 240

444
00:19:46,749 --> 00:19:51,929
meters which is one of the widest

445
00:19:48,100 --> 00:19:54,309
microcontroller widely available and in

446
00:19:51,929 --> 00:19:59,289
nowadays in the world it is nice because

447
00:19:54,309 --> 00:20:04,779
it has Wi-Fi which can go up to 160

448
00:19:59,289 --> 00:20:08,860
- megabit per second sorry mistake and

449
00:20:04,779 --> 00:20:11,799
this one can go to from 240 maggots to

450
00:20:08,860 --> 00:20:16,029
160 to ad so the value that you actually

451
00:20:11,799 --> 00:20:18,220
see here becomes twice and three times

452
00:20:16,029 --> 00:20:19,840
the value if you actually go down and

453
00:20:18,220 --> 00:20:21,820
most people actually want to clock it

454
00:20:19,840 --> 00:20:23,678
down just because in order to save

455
00:20:21,820 --> 00:20:25,539
battery so what happens for this device

456
00:20:23,679 --> 00:20:26,919
that normally they are not available

457
00:20:25,539 --> 00:20:29,470
just because they are in low-power mode

458
00:20:26,919 --> 00:20:32,919
but as soon as they are up basically

459
00:20:29,470 --> 00:20:36,960
they become this low at 80 meters with

460
00:20:32,919 --> 00:20:39,909
an interface that can go up to 160

461
00:20:36,960 --> 00:20:42,820
megabit per second so this becomes

462
00:20:39,909 --> 00:20:45,879
interesting the Arduino maker of ready

463
00:20:42,820 --> 00:20:48,129
is around the 600 nano second forty

464
00:20:45,879 --> 00:20:52,389
eight megahertz and the Arduino Uno

465
00:20:48,129 --> 00:20:56,049
which is the widest available platform

466
00:20:52,389 --> 00:20:58,119
on mega watt solar in the world for

467
00:20:56,049 --> 00:21:02,320
doing projects makers fairs and all

468
00:20:58,119 --> 00:21:04,299
small things it runs at 16 megahertz so

469
00:21:02,320 --> 00:21:06,668
this means that we even is it'll be even

470
00:21:04,299 --> 00:21:09,759
above the remote threshold so I should

471
00:21:06,669 --> 00:21:12,309
be able to attack it there is one caveat

472
00:21:09,759 --> 00:21:17,679
here it's actually this is a bit less

473
00:21:12,309 --> 00:21:21,340
than 1200 is the resolution of the graph

474
00:21:17,679 --> 00:21:25,210
that was not that high it is a slightly

475
00:21:21,340 --> 00:21:29,408
above 1000 basically and it has a 100

476
00:21:25,210 --> 00:21:32,049
megabit shield so it really had boundary

477
00:21:29,409 --> 00:21:35,980
of what I can do let's see what can be

478
00:21:32,049 --> 00:21:38,460
done so the point is that there are

479
00:21:35,980 --> 00:21:42,340
devices which are much slower than this

480
00:21:38,460 --> 00:21:45,309
much slower the point is that you have a

481
00:21:42,340 --> 00:21:47,649
combination of a slower clock and fast

482
00:21:45,309 --> 00:21:48,668
network interfaces the reason is that if

483
00:21:47,649 --> 00:21:51,100
you want to connect

484
00:21:48,669 --> 00:21:52,359
an older device to the network nowadays

485
00:21:51,100 --> 00:21:55,988
so you have an old design

486
00:21:52,359 --> 00:21:58,928
you cannot buy anything cheaper than 100

487
00:21:55,989 --> 00:22:01,960
megabit so if you want to connect an ICS

488
00:21:58,929 --> 00:22:04,059
controller the dead project that design

489
00:22:01,960 --> 00:22:06,669
want to reuse that connected to the

490
00:22:04,059 --> 00:22:09,428
network you are going to use minimum a

491
00:22:06,669 --> 00:22:13,690
100 megabit so this means you are

492
00:22:09,429 --> 00:22:17,769
connecting or for maggots CPU with a 100

493
00:22:13,690 --> 00:22:19,989
megabit Ethernet and we are back to

494
00:22:17,769 --> 00:22:22,960
square 0 because those devices have

495
00:22:19,989 --> 00:22:25,869
authentication for for the coils form

496
00:22:22,960 --> 00:22:31,090
sensors for accessing a number of

497
00:22:25,869 --> 00:22:33,730
interfaces which not probably that solid

498
00:22:31,090 --> 00:22:38,428
in terms of design ok so this is

499
00:22:33,730 --> 00:22:40,720
basically the vision of my research

500
00:22:38,429 --> 00:22:43,090
because our firsts on this device the

501
00:22:40,720 --> 00:22:45,159
single string compare loop and even more

502
00:22:43,090 --> 00:22:47,799
of course is within the range of remote

503
00:22:45,159 --> 00:22:51,730
miserable ax T for sure even that's that

504
00:22:47,799 --> 00:22:55,749
something that can be done the point is

505
00:22:51,730 --> 00:23:00,759
that there is so much around in other

506
00:22:55,749 --> 00:23:03,279
contexts like this like this like this

507
00:23:00,759 --> 00:23:06,009
where there are all the infrastructure

508
00:23:03,279 --> 00:23:10,899
that get connected to the network only

509
00:23:06,009 --> 00:23:12,730
in some cases you have the the password

510
00:23:10,899 --> 00:23:15,629
protection the authentication but when

511
00:23:12,730 --> 00:23:18,070
you have it is usually not that solid ok

512
00:23:15,629 --> 00:23:21,730
we are coming now to attack nice device

513
00:23:18,070 --> 00:23:23,678
probably now in the next few slides the

514
00:23:21,730 --> 00:23:25,899
refuge challenge though the problem is

515
00:23:23,679 --> 00:23:28,239
that the target connectivity may not be

516
00:23:25,899 --> 00:23:31,090
sufficiently fast for reasonable attacks

517
00:23:28,239 --> 00:23:34,659
were sufficiently fast means in in ratio

518
00:23:31,090 --> 00:23:38,139
to your clock of course because that's

519
00:23:34,659 --> 00:23:41,320
exactly what we are talking about there

520
00:23:38,139 --> 00:23:43,418
is a position noise Network you change

521
00:23:41,320 --> 00:23:46,960
routes there is buffering buffer bloat

522
00:23:43,419 --> 00:23:48,759
in us other delays the targeted problem

523
00:23:46,960 --> 00:23:50,950
with scheduling bandwidth saturation

524
00:23:48,759 --> 00:23:55,840
frequency scaling crop drifts and the

525
00:23:50,950 --> 00:23:58,720
same on the off side and also once you

526
00:23:55,840 --> 00:24:00,668
collected the data you start to process

527
00:23:58,720 --> 00:24:02,230
the data do statistic analysis you might

528
00:24:00,669 --> 00:24:05,169
be able you might be introducing

529
00:24:02,230 --> 00:24:07,059
some biases and your machine learning

530
00:24:05,169 --> 00:24:09,190
models you might have brahms estimators

531
00:24:07,059 --> 00:24:11,230
you might have pre-processing using the

532
00:24:09,190 --> 00:24:12,880
artifacts just because you eliminate

533
00:24:11,230 --> 00:24:15,850
some data so there's also noise over

534
00:24:12,880 --> 00:24:19,169
there the research has not focused so

535
00:24:15,850 --> 00:24:22,809
much on anybody did this part of noise

536
00:24:19,169 --> 00:24:26,740
research has focus it a bit on reducing

537
00:24:22,809 --> 00:24:28,240
the noise on the network mostly if you

538
00:24:26,740 --> 00:24:30,669
look at this picture basically you see

539
00:24:28,240 --> 00:24:33,840
that even if you only said send the

540
00:24:30,669 --> 00:24:36,100
command for measuring you have some

541
00:24:33,840 --> 00:24:38,250
measurements and goes from user space

542
00:24:36,100 --> 00:24:41,230
already on the host so you have some

543
00:24:38,250 --> 00:24:43,929
noise even when the pockets actually

544
00:24:41,230 --> 00:24:46,809
exit and this is what you actually see

545
00:24:43,929 --> 00:24:49,660
here it's no it's host forward going up

546
00:24:46,809 --> 00:24:52,059
going out it's on the network we just

547
00:24:49,660 --> 00:24:54,640
discussed it by even the victim I mean

548
00:24:52,059 --> 00:24:56,799
might have concurrent execution of

549
00:24:54,640 --> 00:24:58,330
processes and all these things so there

550
00:24:56,799 --> 00:25:02,080
might be even there the challenge of

551
00:24:58,330 --> 00:25:04,120
doing that okay same on the response

552
00:25:02,080 --> 00:25:08,918
what you want to measure is only this

553
00:25:04,120 --> 00:25:14,439
part well not this side is a there is a

554
00:25:08,919 --> 00:25:17,530
even much noise the point that if you

555
00:25:14,440 --> 00:25:20,440
take only small time frames very short

556
00:25:17,530 --> 00:25:22,870
you may have show that the noise of the

557
00:25:20,440 --> 00:25:24,970
delay under the short time frames are

558
00:25:22,870 --> 00:25:26,709
constant you can actually make the

559
00:25:24,970 --> 00:25:33,160
assumption in this play it's going to be

560
00:25:26,710 --> 00:25:36,790
very useful in a moment so basically my

561
00:25:33,160 --> 00:25:39,850
test setup I used an Arduino no with 16

562
00:25:36,790 --> 00:25:42,159
megahertz 100 mega megabit Ethernet

563
00:25:39,850 --> 00:25:44,168
shield and the direct connection toast

564
00:25:42,160 --> 00:25:46,929
because I didn't want to focus on

565
00:25:44,169 --> 00:25:48,520
network for a moment people already

566
00:25:46,929 --> 00:25:51,309
worked on that there already a bit of

567
00:25:48,520 --> 00:25:54,220
solution we are going to discuss ie

568
00:25:51,309 --> 00:25:56,080
took that implementation put that in a

569
00:25:54,220 --> 00:26:01,150
UDP server and the does APIs for

570
00:25:56,080 --> 00:26:03,340
integration anymore and the measurement

571
00:26:01,150 --> 00:26:05,740
that I take are taking a multiple path

572
00:26:03,340 --> 00:26:07,750
points within the host we are going to

573
00:26:05,740 --> 00:26:10,030
discuss the moment in easily from user

574
00:26:07,750 --> 00:26:12,700
space like us in the packet before

575
00:26:10,030 --> 00:26:13,889
sending before it exit the space I

576
00:26:12,700 --> 00:26:16,110
stuffed my timer

577
00:26:13,890 --> 00:26:18,690
as soon as I see feedback I stop my time

578
00:26:16,110 --> 00:26:22,620
as simply as that nothing nothing more

579
00:26:18,690 --> 00:26:25,730
and this is what you see in terms of

580
00:26:22,620 --> 00:26:25,729
timing distribution

581
00:26:26,960 --> 00:26:30,450
what do you see it which for which

582
00:26:29,039 --> 00:26:34,049
character so basically what a dieter

583
00:26:30,450 --> 00:26:36,929
sent ten thousand probes for each

584
00:26:34,049 --> 00:26:42,658
character number three four and five and

585
00:26:36,929 --> 00:26:45,380
so on and I just plotted down the time

586
00:26:42,659 --> 00:26:48,590
that it took to come back nothing more

587
00:26:45,380 --> 00:26:52,230
so five hundred packets took this much

588
00:26:48,590 --> 00:26:56,459
other 500 pallet talks this much only a

589
00:26:52,230 --> 00:26:59,760
few tubes live much so the ready point

590
00:26:56,460 --> 00:27:05,399
over there which one do you think it is

591
00:26:59,760 --> 00:27:09,539
the right character over there it should

592
00:27:05,399 --> 00:27:12,479
be easy the record records when it takes

593
00:27:09,539 --> 00:27:14,279
more basically so this means that the

594
00:27:12,480 --> 00:27:17,100
distribution is a bit skewed on this

595
00:27:14,279 --> 00:27:21,570
side basically so you see that the

596
00:27:17,100 --> 00:27:23,908
yellow here is a bit on this side so if

597
00:27:21,570 --> 00:27:26,908
I had to choose one character it should

598
00:27:23,909 --> 00:27:29,399
be probably the sorry the orange one the

599
00:27:26,909 --> 00:27:31,590
orange one which is indeed number three

600
00:27:29,399 --> 00:27:34,559
this is the right one this is basically

601
00:27:31,590 --> 00:27:37,740
out it works in situation where your

602
00:27:34,559 --> 00:27:39,600
delay is a more or less than microsecond

603
00:27:37,740 --> 00:27:42,360
difference so that every loop take take

604
00:27:39,600 --> 00:27:44,370
10 microseconds and this is the

605
00:27:42,360 --> 00:27:48,620
situation for example two megahertz

606
00:27:44,370 --> 00:27:52,260
device which may be a SCADA controller

607
00:27:48,620 --> 00:27:53,959
somewhere or a sensor somewhere okay so

608
00:27:52,260 --> 00:27:56,580
if I'm able to measure that difference

609
00:27:53,960 --> 00:27:59,250
but then we come to the remotely in a

610
00:27:56,580 --> 00:28:02,010
moment but we arrived at the remote part

611
00:27:59,250 --> 00:28:04,679
in a presentation with talking about

612
00:28:02,010 --> 00:28:06,539
remote at the moment so here this is

613
00:28:04,679 --> 00:28:08,880
actually visible and is visible

614
00:28:06,539 --> 00:28:10,679
statistically and is visible because one

615
00:28:08,880 --> 00:28:13,350
character can be distinguished from all

616
00:28:10,679 --> 00:28:18,299
the other ones so it's not one to one is

617
00:28:13,350 --> 00:28:20,090
one to all the others if we go to do one

618
00:28:18,299 --> 00:28:23,100
microsecond difference I would challenge

619
00:28:20,090 --> 00:28:26,549
everybody to recognize which is the good

620
00:28:23,100 --> 00:28:27,449
one honestly it's not visible I usually

621
00:28:26,549 --> 00:28:30,029
need to before

622
00:28:27,450 --> 00:28:33,269
some analysis basically so one

623
00:28:30,029 --> 00:28:36,059
microsecond difference is in one single

624
00:28:33,269 --> 00:28:38,419
loop it's not or any other process is

625
00:28:36,059 --> 00:28:41,129
not really distinguishable at this level

626
00:28:38,419 --> 00:28:42,779
you're probably the different analogy so

627
00:28:41,130 --> 00:28:45,269
many more measurement in order to see a

628
00:28:42,779 --> 00:28:48,269
clear cut but the more tell measurement

629
00:28:45,269 --> 00:28:50,429
you take the more time it takes the more

630
00:28:48,269 --> 00:28:52,620
are the chances that your network tunnel

631
00:28:50,429 --> 00:28:55,710
is not stable and you get noise so you

632
00:28:52,620 --> 00:28:59,959
need to be you want to be quick sharp

633
00:28:55,710 --> 00:29:02,370
and fast as much as possible so

634
00:28:59,960 --> 00:29:06,179
basically the results on our probable

635
00:29:02,370 --> 00:29:07,649
distribution are no motion they are

636
00:29:06,179 --> 00:29:10,399
known actually they're usually

637
00:29:07,649 --> 00:29:12,299
multimodal they were quite skewed and on

638
00:29:10,399 --> 00:29:14,279
so basically they are genetic

639
00:29:12,299 --> 00:29:17,340
distribution that have this kind of long

640
00:29:14,279 --> 00:29:19,769
lobes which we don't know we are not

641
00:29:17,340 --> 00:29:21,510
able to model at this moment and there

642
00:29:19,769 --> 00:29:23,279
are very few estimators that we can

643
00:29:21,510 --> 00:29:25,799
apply to such distribution so how do you

644
00:29:23,279 --> 00:29:27,600
compare these two strange things the

645
00:29:25,799 --> 00:29:30,029
concept the concept of average does not

646
00:29:27,600 --> 00:29:31,740
really help because for some reason I

647
00:29:30,029 --> 00:29:33,990
mean they would not have even the same

648
00:29:31,740 --> 00:29:34,440
shape the variance doesn't even make

649
00:29:33,990 --> 00:29:36,990
sense

650
00:29:34,440 --> 00:29:39,929
there are many other estimators that are

651
00:29:36,990 --> 00:29:41,610
bound to the fact that you know your

652
00:29:39,929 --> 00:29:44,940
distribution order you can assume that

653
00:29:41,610 --> 00:29:47,189
in this case it's not there are very few

654
00:29:44,940 --> 00:29:49,320
statistic estimators that that can be

655
00:29:47,190 --> 00:29:52,380
applied so this is not such an easy

656
00:29:49,320 --> 00:29:55,649
problem to deal with one interesting one

657
00:29:52,380 --> 00:29:57,929
is the box test in 2009 um close with

658
00:29:55,649 --> 00:30:00,719
others so basically this is a very

659
00:29:57,929 --> 00:30:02,580
generic estimator may be useful also for

660
00:30:00,720 --> 00:30:04,320
other projects so this one especially

661
00:30:02,580 --> 00:30:07,439
mention is so as it's true that you have

662
00:30:04,320 --> 00:30:09,059
two distributions sorry two population

663
00:30:07,440 --> 00:30:13,260
of the same distribution that you don't

664
00:30:09,059 --> 00:30:15,090
know okay for any given population you

665
00:30:13,260 --> 00:30:20,220
can always calculate what is called the

666
00:30:15,090 --> 00:30:21,959
percentile so where stands the five

667
00:30:20,220 --> 00:30:24,090
percent this is the line you see this

668
00:30:21,960 --> 00:30:26,460
line is the five percent of your

669
00:30:24,090 --> 00:30:27,178
population stands on this side for the

670
00:30:26,460 --> 00:30:31,139
blue one

671
00:30:27,179 --> 00:30:32,460
let me say here maybe it's better so on

672
00:30:31,139 --> 00:30:34,769
this side is means this is the line

673
00:30:32,460 --> 00:30:36,330
where the 5% of your probation stays

674
00:30:34,769 --> 00:30:37,919
here and this is a concept can be

675
00:30:36,330 --> 00:30:40,199
applied to anything even if you don't

676
00:30:37,919 --> 00:30:42,870
know the distribution as well okay

677
00:30:40,200 --> 00:30:45,390
this is the line where the 7% of your

678
00:30:42,870 --> 00:30:47,580
population is on this side so basically

679
00:30:45,390 --> 00:30:51,360
for any given population if you get to

680
00:30:47,580 --> 00:30:52,740
these numbers you get a box okay so this

681
00:30:51,360 --> 00:30:56,490
means you can create for every

682
00:30:52,740 --> 00:30:58,590
population these two boxes and this is

683
00:30:56,490 --> 00:31:01,980
your estimator then you need to set your

684
00:30:58,590 --> 00:31:03,990
threshold the threshold is that given

685
00:31:01,980 --> 00:31:05,910
those number that i fix which are

686
00:31:03,990 --> 00:31:07,920
arbitrary by experience in all these

687
00:31:05,910 --> 00:31:09,470
things which may work or may not but

688
00:31:07,920 --> 00:31:13,350
let's assume that they have chosen them

689
00:31:09,470 --> 00:31:15,540
the distinguisher is if the box do not

690
00:31:13,350 --> 00:31:18,030
overlap then I say that they are

691
00:31:15,540 --> 00:31:20,120
different if the boxes do overlap I'm

692
00:31:18,030 --> 00:31:22,410
not able to distinguish them

693
00:31:20,120 --> 00:31:24,479
interestingly this has been the

694
00:31:22,410 --> 00:31:26,610
estimator worked best in the research of

695
00:31:24,480 --> 00:31:29,970
these guys and these are they are the

696
00:31:26,610 --> 00:31:32,310
one that we are able to measure the 100

697
00:31:29,970 --> 00:31:34,320
nanoseconds the limit so they establish

698
00:31:32,310 --> 00:31:36,810
the limit and they uses this so do not

699
00:31:34,320 --> 00:31:38,250
dismiss this just because it's it

700
00:31:36,810 --> 00:31:40,399
doesn't really work of course we have

701
00:31:38,250 --> 00:31:43,290
progressed it quite a bit

702
00:31:40,400 --> 00:31:44,730
well basically it would be nice if we

703
00:31:43,290 --> 00:31:46,560
can go back to a Gaussian distribution

704
00:31:44,730 --> 00:31:48,990
it would be really nice because we can

705
00:31:46,560 --> 00:31:51,540
actually apply even Marshall and me you

706
00:31:48,990 --> 00:31:53,970
can apply a lot of things and improve

707
00:31:51,540 --> 00:31:56,690
the quality of what we can do so this

708
00:31:53,970 --> 00:31:59,160
means that we are in a situation where

709
00:31:56,690 --> 00:32:01,410
technology you may need I don't know 1

710
00:31:59,160 --> 00:32:03,990
million measurements for example but

711
00:32:01,410 --> 00:32:06,120
because of the behavior funniest edgiest

712
00:32:03,990 --> 00:32:10,290
musician you can go down to ten thousand

713
00:32:06,120 --> 00:32:14,219
maybe by processing so you can actually

714
00:32:10,290 --> 00:32:17,070
use a differential pairs it's a measure

715
00:32:14,220 --> 00:32:19,440
of doing one measurement you send a

716
00:32:17,070 --> 00:32:21,330
reference which can be anything can be

717
00:32:19,440 --> 00:32:23,370
wrong or bad would be you just send the

718
00:32:21,330 --> 00:32:26,520
reference at you take that measurement

719
00:32:23,370 --> 00:32:28,260
okay this is called ref then you

720
00:32:26,520 --> 00:32:30,330
actually do the measurement do you

721
00:32:28,260 --> 00:32:32,190
really want to take if they are close

722
00:32:30,330 --> 00:32:34,860
enough you know that they are under the

723
00:32:32,190 --> 00:32:38,010
same condition this means that if you

724
00:32:34,860 --> 00:32:40,350
subtract them the Delta will be the

725
00:32:38,010 --> 00:32:43,140
difference and the Delta will build the

726
00:32:40,350 --> 00:32:44,669
noise will not cancel out so if you

727
00:32:43,140 --> 00:32:48,060
actually do this kind of differential

728
00:32:44,670 --> 00:32:49,860
approach which is now quite clear and if

729
00:32:48,060 --> 00:32:51,540
you don't see that in any timing of take

730
00:32:49,860 --> 00:32:52,969
article there is not mentioned probably

731
00:32:51,540 --> 00:32:56,000
there is some work

732
00:32:52,970 --> 00:32:59,210
is to be done the constant noise is

733
00:32:56,000 --> 00:33:01,730
canceled out and we are going to that in

734
00:32:59,210 --> 00:33:03,710
a moment and under some assumption can

735
00:33:01,730 --> 00:33:05,720
be Goshen basically let me show that

736
00:33:03,710 --> 00:33:10,310
first how it looks like you see that now

737
00:33:05,720 --> 00:33:12,980
it's centered at zero so basically it is

738
00:33:10,310 --> 00:33:14,570
symmetric it is not really a Goshen

739
00:33:12,980 --> 00:33:16,400
because there might be some additional

740
00:33:14,570 --> 00:33:18,530
mime in userspace so it's quite normal

741
00:33:16,400 --> 00:33:21,440
and number of things but even the noise

742
00:33:18,530 --> 00:33:24,620
here is symmetric so this means that

743
00:33:21,440 --> 00:33:27,890
under some cleaning I'm infusing of some

744
00:33:24,620 --> 00:33:32,330
cases I can reduce this to a bush to the

745
00:33:27,890 --> 00:33:34,600
point that first removed some noise just

746
00:33:32,330 --> 00:33:38,540
by doing this approaching measurement I

747
00:33:34,600 --> 00:33:40,100
have now estimators and there is a nice

748
00:33:38,540 --> 00:33:42,080
very nice article from a goddess

749
00:33:40,100 --> 00:33:45,260
applying machine learning just because

750
00:33:42,080 --> 00:33:48,159
this is a Goshen now so it's it's model

751
00:33:45,260 --> 00:33:51,110
learn by distinguishing the different

752
00:33:48,160 --> 00:33:53,360
questions that he could find the it

753
00:33:51,110 --> 00:33:54,830
learns the Goshen of the bad ones for a

754
00:33:53,360 --> 00:33:58,639
Goshen version of the good ones

755
00:33:54,830 --> 00:34:01,790
and by reinforcing these learning is

756
00:33:58,640 --> 00:34:03,920
able to improve in time how many traces

757
00:34:01,790 --> 00:34:06,379
and measurement in needs in order to do

758
00:34:03,920 --> 00:34:07,220
that so this is basically the

759
00:34:06,380 --> 00:34:09,800
state-of-the-art

760
00:34:07,220 --> 00:34:12,350
these we have some limitation on the on

761
00:34:09,800 --> 00:34:14,630
the what we can measure technically so

762
00:34:12,350 --> 00:34:16,429
because we need many but we can reduce

763
00:34:14,630 --> 00:34:17,840
this measurement by canceling noise and

764
00:34:16,429 --> 00:34:22,669
improving techniques from the analysis

765
00:34:17,840 --> 00:34:26,210
side I actually invite you to read the

766
00:34:22,670 --> 00:34:29,120
articles really nice so the results you

767
00:34:26,210 --> 00:34:33,080
actually as mostly focusing on reducing

768
00:34:29,120 --> 00:34:36,529
the network noise differential pairs and

769
00:34:33,080 --> 00:34:39,049
network analysis there are a feat which

770
00:34:36,530 --> 00:34:41,360
have been nice because which time sauce

771
00:34:39,050 --> 00:34:44,290
do you actually use I mean I start my

772
00:34:41,360 --> 00:34:48,470
clock sure which clock there are many

773
00:34:44,290 --> 00:34:50,840
this is also relevant someone actually

774
00:34:48,469 --> 00:34:53,389
said okay I would like to use the DCP

775
00:34:50,840 --> 00:34:55,370
timestamp as a as a measurement source

776
00:34:53,389 --> 00:34:57,170
because every packet in TCP has a

777
00:34:55,370 --> 00:34:59,330
timestamp let me see if this works

778
00:34:57,170 --> 00:35:02,000
because the timestamp is put on the

779
00:34:59,330 --> 00:35:03,740
victims side so wherever it actually

780
00:35:02,000 --> 00:35:06,440
goes the part at or not the world the

781
00:35:03,740 --> 00:35:06,979
timestamp stays the same so maybe I can

782
00:35:06,440 --> 00:35:09,570
actually

783
00:35:06,980 --> 00:35:13,110
do a number of measurement which are

784
00:35:09,570 --> 00:35:17,580
very close to the host and also drug

785
00:35:13,110 --> 00:35:19,410
defense repairs but unfortunately no one

786
00:35:17,580 --> 00:35:22,680
actually focuses on reducing the noise

787
00:35:19,410 --> 00:35:24,600
on the host who so most of the

788
00:35:22,680 --> 00:35:27,060
measurement that you see in papers and

789
00:35:24,600 --> 00:35:29,850
in attacks in blogs are taken from your

790
00:35:27,060 --> 00:35:32,820
space or even within a browser with him

791
00:35:29,850 --> 00:35:35,279
but in order to do this fuel injection

792
00:35:32,820 --> 00:35:38,190
and I'm not sure that so that is

793
00:35:35,280 --> 00:35:39,840
sufficient for answering the need of the

794
00:35:38,190 --> 00:35:42,330
moment maybe is not sufficient to

795
00:35:39,840 --> 00:35:44,970
answering assessing some risk that we

796
00:35:42,330 --> 00:35:48,060
actually going to see so actually

797
00:35:44,970 --> 00:35:51,359
focusing on trying to reduce this noise

798
00:35:48,060 --> 00:35:53,790
in my measure so what is the best croc

799
00:35:51,360 --> 00:35:56,600
time source and approach they can do I

800
00:35:53,790 --> 00:36:00,080
think I've done something interesting I

801
00:35:56,600 --> 00:36:02,339
bet you shouldn't tell you this posture

802
00:36:00,080 --> 00:36:04,770
the measurement can be taking multiple

803
00:36:02,340 --> 00:36:08,520
different passed points you are

804
00:36:04,770 --> 00:36:12,120
basically here at this point while the

805
00:36:08,520 --> 00:36:14,370
packet travels your network card then

806
00:36:12,120 --> 00:36:17,279
this process set is given in yo your

807
00:36:14,370 --> 00:36:19,170
true net Devon you Escobar fiend occur

808
00:36:17,280 --> 00:36:21,620
no that's the first part of the

809
00:36:19,170 --> 00:36:24,270
interface if you look at net dev dot C

810
00:36:21,620 --> 00:36:26,819
in your kernel this is where basically

811
00:36:24,270 --> 00:36:29,310
the interface is where from the hardware

812
00:36:26,820 --> 00:36:31,860
the kernel the packet goes to the kernel

813
00:36:29,310 --> 00:36:34,259
sorry to the device driver which is

814
00:36:31,860 --> 00:36:37,110
still particle then from the device

815
00:36:34,260 --> 00:36:39,840
driver which lands here is handed to the

816
00:36:37,110 --> 00:36:41,850
actual stack of the kernel which is

817
00:36:39,840 --> 00:36:43,080
handed back to user space and this is

818
00:36:41,850 --> 00:36:46,350
where you like your measurement of

819
00:36:43,080 --> 00:36:47,819
course so in principle you might have in

820
00:36:46,350 --> 00:36:49,799
different point in time different

821
00:36:47,820 --> 00:36:52,860
opportunities and different kind of time

822
00:36:49,800 --> 00:36:56,880
sources that you have different position

823
00:36:52,860 --> 00:36:59,640
and accuracy of course the closer you

824
00:36:56,880 --> 00:37:03,210
are to the hardware the less noise you

825
00:36:59,640 --> 00:37:05,549
have and the more accurate you are of

826
00:37:03,210 --> 00:37:07,770
course you might not have on the

827
00:37:05,550 --> 00:37:10,230
hardware clock which would forgivers

828
00:37:07,770 --> 00:37:12,450
like your cpu keep in mind that your

829
00:37:10,230 --> 00:37:17,070
network card at least the one have which

830
00:37:12,450 --> 00:37:18,470
is an Intel e1000 II as a network okay

831
00:37:17,070 --> 00:37:20,569
24 maggots

832
00:37:18,470 --> 00:37:23,990
I think I can activate our clock that at

833
00:37:20,569 --> 00:37:26,960
96 I still need to find a way looks into

834
00:37:23,990 --> 00:37:30,020
some register but I think I can do that

835
00:37:26,960 --> 00:37:32,319
why linear you have a CPU clock at 4

836
00:37:30,020 --> 00:37:34,940
pillars which is completely different

837
00:37:32,319 --> 00:37:36,710
precision the point is the amount of

838
00:37:34,940 --> 00:37:40,690
noise introduced these actually make

839
00:37:36,710 --> 00:37:45,559
your measurement go to the moon and back

840
00:37:40,690 --> 00:37:46,910
from a cpu perspective so basically all

841
00:37:45,559 --> 00:37:48,890
the researchers we see own timing

842
00:37:46,910 --> 00:37:50,680
attacks happens here and it is something

843
00:37:48,890 --> 00:37:52,460
which is really puzzled me for a while

844
00:37:50,680 --> 00:37:55,308
especially because now I have this

845
00:37:52,460 --> 00:37:59,630
opportunity with with IOT devices so I

846
00:37:55,309 --> 00:38:01,940
want to get to best out of it user space

847
00:37:59,630 --> 00:38:04,160
management this is one largest number of

848
00:38:01,940 --> 00:38:05,690
research they are start as soon as

849
00:38:04,160 --> 00:38:09,799
packets sent and stopped as soon as

850
00:38:05,690 --> 00:38:11,900
police received question what do you

851
00:38:09,799 --> 00:38:27,109
think is the best precision that you can

852
00:38:11,900 --> 00:38:29,029
get here precision mean net yeah

853
00:38:27,109 --> 00:38:30,380
but from a time source point of view

854
00:38:29,029 --> 00:38:33,020
apart from that no not talking about

855
00:38:30,380 --> 00:38:35,930
curation talk about precision so ok do

856
00:38:33,020 --> 00:38:40,329
you get a microsecond or nanosecond or

857
00:38:35,930 --> 00:38:43,098
sub nano what do you get you think

858
00:38:40,329 --> 00:38:45,890
you'll actually get all the three

859
00:38:43,099 --> 00:38:49,670
possibilities if you actually read the

860
00:38:45,890 --> 00:38:51,529
clock normally from your user space and

861
00:38:49,670 --> 00:38:53,599
some talking about the Linux kernel the

862
00:38:51,529 --> 00:38:56,569
clock actually gives you back answers in

863
00:38:53,599 --> 00:38:58,369
microsecond so basically if you look at

864
00:38:56,569 --> 00:39:01,130
the time spec structure that you get

865
00:38:58,369 --> 00:39:04,160
it's micro isn't you don't so even if

866
00:39:01,130 --> 00:39:07,099
your clock can go faster or your CPU can

867
00:39:04,160 --> 00:39:09,170
go faster this is what you get recently

868
00:39:07,099 --> 00:39:11,720
in the kernel they've been introduced

869
00:39:09,170 --> 00:39:14,420
also nanoseconds position for the clock

870
00:39:11,720 --> 00:39:16,819
but unfortunately the clocks are not

871
00:39:14,420 --> 00:39:19,640
intended to provide this precision

872
00:39:16,819 --> 00:39:21,890
estable stable way they there is no

873
00:39:19,640 --> 00:39:24,740
guarantee that they don't drift there is

874
00:39:21,890 --> 00:39:27,740
no guarantee that that basically they

875
00:39:24,740 --> 00:39:29,720
will be stable for for a short amount of

876
00:39:27,740 --> 00:39:31,910
time so another important thing that you

877
00:39:29,720 --> 00:39:33,740
can actually use or not the clocks

878
00:39:31,910 --> 00:39:36,620
which are provided you just start using

879
00:39:33,740 --> 00:39:39,259
CPU performance counter and they go at

880
00:39:36,620 --> 00:39:41,569
the speed of course the CPU so in

881
00:39:39,260 --> 00:39:43,250
principle if you start using the per sec

882
00:39:41,570 --> 00:39:45,380
exactly the same Perth County that

883
00:39:43,250 --> 00:39:47,420
that's of course I mean people like

884
00:39:45,380 --> 00:39:49,490
Daniel gross and a large and other

885
00:39:47,420 --> 00:39:51,890
people are using for are doing cache

886
00:39:49,490 --> 00:39:54,620
timing attack I had the same kind of

887
00:39:51,890 --> 00:39:58,460
resolution why shouldn't I be you able

888
00:39:54,620 --> 00:40:02,810
to use that in fact I can do that so

889
00:39:58,460 --> 00:40:05,450
basically I have both the micro the nano

890
00:40:02,810 --> 00:40:07,100
with the new structures and the sub nano

891
00:40:05,450 --> 00:40:10,580
with the performance counter so I can

892
00:40:07,100 --> 00:40:11,860
actually choose one someone might think

893
00:40:10,580 --> 00:40:16,480
that this may make a difference

894
00:40:11,860 --> 00:40:18,740
sometimes it does but sometimes may not

895
00:40:16,480 --> 00:40:20,990
the point is that the accuracy may be

896
00:40:18,740 --> 00:40:22,790
low and that's a good suggestion doing

897
00:40:20,990 --> 00:40:24,890
an interrupt collection you can actually

898
00:40:22,790 --> 00:40:27,230
but it's not much that you can do from

899
00:40:24,890 --> 00:40:29,230
user space still you're still subject to

900
00:40:27,230 --> 00:40:33,740
the scheduling your sis objecting to

901
00:40:29,230 --> 00:40:35,720
preemptive say being preempted by other

902
00:40:33,740 --> 00:40:39,770
processes it's not as much actually than

903
00:40:35,720 --> 00:40:42,259
you can do but still still did this in

904
00:40:39,770 --> 00:40:46,310
very easy way of getting the performance

905
00:40:42,260 --> 00:40:49,670
counter nanosecond from Python this is

906
00:40:46,310 --> 00:40:52,220
really really convenient and took me a

907
00:40:49,670 --> 00:40:54,800
while to find an easy way of doing this

908
00:40:52,220 --> 00:40:58,459
because it's supported in Python 3.7

909
00:40:54,800 --> 00:41:00,980
only because all the time that clock are

910
00:40:58,460 --> 00:41:03,410
duplicated from because they are not

911
00:41:00,980 --> 00:41:05,840
good enough was about about time I would

912
00:41:03,410 --> 00:41:07,339
say in a way but you can access that

913
00:41:05,840 --> 00:41:10,640
from Python and this is what I actually

914
00:41:07,340 --> 00:41:12,500
use in my tool so I'm because I'm taking

915
00:41:10,640 --> 00:41:14,299
measurement if friend situation and I'm

916
00:41:12,500 --> 00:41:17,690
perfectly fine and understanding the

917
00:41:14,300 --> 00:41:20,300
limitation before before choosing you

918
00:41:17,690 --> 00:41:22,250
need to understand so basically I get

919
00:41:20,300 --> 00:41:25,040
nano second position and I have the

920
00:41:22,250 --> 00:41:28,520
performance counter of course there are

921
00:41:25,040 --> 00:41:29,750
caveats here because the Nabi addition

922
00:41:28,520 --> 00:41:33,860
delay because of the Python interpreter

923
00:41:29,750 --> 00:41:35,510
of course before the packets arrived to

924
00:41:33,860 --> 00:41:39,350
use a space and it goes through the

925
00:41:35,510 --> 00:41:41,780
socket and it goes through my Python

926
00:41:39,350 --> 00:41:44,210
user space and interpreter and then I

927
00:41:41,780 --> 00:41:45,890
get yes you receive the packet there is

928
00:41:44,210 --> 00:41:48,540
an additional time

929
00:41:45,890 --> 00:41:50,520
but if it's constant if it's more or

930
00:41:48,540 --> 00:41:54,660
less constant which is a big assumption

931
00:41:50,520 --> 00:41:56,400
as well should be fine in a short amount

932
00:41:54,660 --> 00:41:59,339
of time because in doing differential

933
00:41:56,400 --> 00:42:02,430
pairs analysis and this message cancels

934
00:41:59,340 --> 00:42:03,990
out so this solves me a very nice part

935
00:42:02,430 --> 00:42:05,580
of the problem this is this approach

936
00:42:03,990 --> 00:42:08,839
because it does not cancel only on the

937
00:42:05,580 --> 00:42:12,720
network cancels all the constant noise

938
00:42:08,840 --> 00:42:16,170
everywhere so this is a very big change

939
00:42:12,720 --> 00:42:17,790
in maybe in the way we do it so you see

940
00:42:16,170 --> 00:42:21,240
this is actually really look quite

941
00:42:17,790 --> 00:42:23,490
nicely I mean it's quite sharp the

942
00:42:21,240 --> 00:42:27,330
average deviation that you have in this

943
00:42:23,490 --> 00:42:30,000
case is 80 mm now seconds already to

944
00:42:27,330 --> 00:42:33,080
microsecond keep in mind we are trying

945
00:42:30,000 --> 00:42:35,730
to measure a difference of one

946
00:42:33,080 --> 00:42:39,330
microsecond with a standard deviation of

947
00:42:35,730 --> 00:42:41,910
82 still is not that far that might be

948
00:42:39,330 --> 00:42:44,670
much worse situation which we have seen

949
00:42:41,910 --> 00:42:46,410
before basically it wasn't even a Goshen

950
00:42:44,670 --> 00:42:47,970
before now we have something symmetric

951
00:42:46,410 --> 00:42:51,029
something that we may be able to

952
00:42:47,970 --> 00:42:55,350
statistically analyze so he says use of

953
00:42:51,030 --> 00:42:56,700
space I worked also with kernel

954
00:42:55,350 --> 00:42:58,589
measurement I didn't spend too much time

955
00:42:56,700 --> 00:43:00,210
because of course I mean you have a

956
00:42:58,590 --> 00:43:03,420
limited time for representation I will

957
00:43:00,210 --> 00:43:05,970
be able to even show because I ever that

958
00:43:03,420 --> 00:43:08,250
innocent demo I can actually show how it

959
00:43:05,970 --> 00:43:09,600
works so I will you take kernel

960
00:43:08,250 --> 00:43:11,370
measurement I'm interested in your

961
00:43:09,600 --> 00:43:14,130
solution now so busy I'm sending a

962
00:43:11,370 --> 00:43:17,069
packet I would like to know when it's

963
00:43:14,130 --> 00:43:18,990
sent or received when the kernel C is

964
00:43:17,070 --> 00:43:28,470
there to receive that oh how would you

965
00:43:18,990 --> 00:43:31,339
do that please sure

966
00:43:28,470 --> 00:43:34,560
that's test one involves quite some

967
00:43:31,340 --> 00:43:36,960
kernel coding a chic and you know in the

968
00:43:34,560 --> 00:43:39,930
in the recent module IE

969
00:43:36,960 --> 00:43:44,640
I think that sometimes I mean the right

970
00:43:39,930 --> 00:43:45,069
questions is also important because you

971
00:43:44,640 --> 00:43:47,680
would like

972
00:43:45,070 --> 00:43:49,330
says the time source in Katniss face so

973
00:43:47,680 --> 00:43:49,950
my question is that how does Wireshark

974
00:43:49,330 --> 00:43:53,040
do

975
00:43:49,950 --> 00:43:55,750
how does wire shadow runs in userspace

976
00:43:53,040 --> 00:43:56,920
take the kernel timestamp the timestamp

977
00:43:55,750 --> 00:43:59,320
the government level of the packet

978
00:43:56,920 --> 00:44:03,880
because if it does it I can also do it

979
00:43:59,320 --> 00:44:07,120
right make sense the time Samba

980
00:44:03,880 --> 00:44:08,680
Wireshark are not done in user space we

981
00:44:07,120 --> 00:44:10,950
are we every rights whether under in

982
00:44:08,680 --> 00:44:14,549
kernel but it should work should see it

983
00:44:10,950 --> 00:44:17,649
so if you actually dig a bit sleep cup

984
00:44:14,550 --> 00:44:19,480
you find out that the packets which have

985
00:44:17,650 --> 00:44:22,480
time stabbed by the kernel

986
00:44:19,480 --> 00:44:24,430
you can still also assess it and the

987
00:44:22,480 --> 00:44:27,040
nice thing is that in your library even

988
00:44:24,430 --> 00:44:29,290
set some callbacks it says when you see

989
00:44:27,040 --> 00:44:31,570
this pocket please accept this structure

990
00:44:29,290 --> 00:44:34,120
and get out this timestamp the

991
00:44:31,570 --> 00:44:38,110
determinant has seen if you do if you do

992
00:44:34,120 --> 00:44:41,049
like TCP dump you also see the the the

993
00:44:38,110 --> 00:44:44,140
timing back and forth and they are given

994
00:44:41,050 --> 00:44:46,360
by the Guv'nor I just that's why most of

995
00:44:44,140 --> 00:44:49,629
the research before actually does this

996
00:44:46,360 --> 00:44:51,790
test start a sniffer and then correlates

997
00:44:49,630 --> 00:44:54,280
all the stuff I said this is not for me

998
00:44:51,790 --> 00:44:57,970
I don't like it so basically what I did

999
00:44:54,280 --> 00:45:00,730
is that I started the different server

1000
00:44:57,970 --> 00:45:02,830
so a different thread different process

1001
00:45:00,730 --> 00:45:04,480
that was actually listening in in real

1002
00:45:02,830 --> 00:45:06,430
time to what I wanted to see in

1003
00:45:04,480 --> 00:45:08,440
capturing all the information and

1004
00:45:06,430 --> 00:45:10,270
correlating directly so basically now I

1005
00:45:08,440 --> 00:45:13,330
have a situation where and this is

1006
00:45:10,270 --> 00:45:15,970
important part I think the analysis part

1007
00:45:13,330 --> 00:45:18,069
in the collection sits on my host while

1008
00:45:15,970 --> 00:45:21,450
the measuring part consists anywhere in

1009
00:45:18,070 --> 00:45:25,840
the world because they communicate over

1010
00:45:21,450 --> 00:45:28,270
socket so think about that ICS network

1011
00:45:25,840 --> 00:45:30,850
that has been compromised and I can

1012
00:45:28,270 --> 00:45:33,790
inject once in something like that then

1013
00:45:30,850 --> 00:45:37,210
immediately I go bypassing two

1014
00:45:33,790 --> 00:45:39,930
continents in this way and then the

1015
00:45:37,210 --> 00:45:43,640
measurement is done locally again and

1016
00:45:39,930 --> 00:45:46,700
not remote because if I inject this

1017
00:45:43,640 --> 00:45:49,100
server which takes the measurement in

1018
00:45:46,700 --> 00:45:52,250
this way even user space will be fine

1019
00:45:49,100 --> 00:45:55,210
with that I will be able to take the

1020
00:45:52,250 --> 00:45:58,100
measurement locally and the processing

1021
00:45:55,210 --> 00:46:00,230
remotely and it has not even been

1022
00:45:58,100 --> 00:46:02,029
considered yet at the moment but you do

1023
00:46:00,230 --> 00:46:04,780
have a working solution for that so I

1024
00:46:02,030 --> 00:46:07,130
can show you that

1025
00:46:04,780 --> 00:46:09,130
so basically get installed callbacks on

1026
00:46:07,130 --> 00:46:12,830
puppy's reception sending what do I need

1027
00:46:09,130 --> 00:46:14,900
root privilege nothing more on the

1028
00:46:12,830 --> 00:46:16,190
remote host and I'm pretty sure that

1029
00:46:14,900 --> 00:46:20,810
everybody in this room thinks that this

1030
00:46:16,190 --> 00:46:23,780
is not so rare the Lewis versus of ports

1031
00:46:20,810 --> 00:46:25,220
nanoseconds position let me show you the

1032
00:46:23,780 --> 00:46:28,240
code because it's better to show the

1033
00:46:25,220 --> 00:46:32,029
code when we are talking you do this

1034
00:46:28,240 --> 00:46:35,029
uses system Aust this means you are

1035
00:46:32,030 --> 00:46:37,880
asking the timestamp from the kernel

1036
00:46:35,030 --> 00:46:41,500
given by the kernel I should taken by

1037
00:46:37,880 --> 00:46:44,150
the girl and the position s key is no no

1038
00:46:41,500 --> 00:46:45,920
this is fine I have to say that I don't

1039
00:46:44,150 --> 00:46:47,720
have the picture I can show you real

1040
00:46:45,920 --> 00:46:49,630
time but the other distribution is still

1041
00:46:47,720 --> 00:46:52,279
the same unless I do something tuning

1042
00:46:49,630 --> 00:46:54,710
I'm using a real-time kernel by the way

1043
00:46:52,280 --> 00:46:57,770
so just to make sure that's our ground

1044
00:46:54,710 --> 00:47:00,710
is set but it's not thing which I was

1045
00:46:57,770 --> 00:47:03,200
interesting for a long time we have now

1046
00:47:00,710 --> 00:47:04,580
ethan cards that have hardware

1047
00:47:03,200 --> 00:47:07,279
timestamps and they are starting to

1048
00:47:04,580 --> 00:47:11,270
appear in laptops my dell laptop is this

1049
00:47:07,280 --> 00:47:14,960
color as this card so if you do actually

1050
00:47:11,270 --> 00:47:18,950
that command you see that is a poor time

1051
00:47:14,960 --> 00:47:21,230
stamping in our door of sending throwing

1052
00:47:18,950 --> 00:47:22,839
optics and raised born in our brand

1053
00:47:21,230 --> 00:47:25,580
social i should have a lightly this tool

1054
00:47:22,840 --> 00:47:29,360
so i can time stamp the packet wind sent

1055
00:47:25,580 --> 00:47:32,630
and this is impressive because usually

1056
00:47:29,360 --> 00:47:34,550
you can do that when it we receive it so

1057
00:47:32,630 --> 00:47:37,100
there are structural a bit complicated

1058
00:47:34,550 --> 00:47:41,090
that you can access in order to get this

1059
00:47:37,100 --> 00:47:45,920
time of course I mean we also look

1060
00:47:41,090 --> 00:47:48,410
always look for the point of the weakest

1061
00:47:45,920 --> 00:47:50,840
point and I wondered does this time thus

1062
00:47:48,410 --> 00:47:54,649
is this supported by any user space too

1063
00:47:50,840 --> 00:47:57,080
sure TCP dump already suppose that so if

1064
00:47:54,650 --> 00:47:57,680
your card suppose this you can pass per

1065
00:47:57,080 --> 00:47:59,299
me

1066
00:47:57,680 --> 00:48:03,410
to say I want to have an honest em

1067
00:47:59,300 --> 00:48:05,600
position on the harbor timestamp this

1068
00:48:03,410 --> 00:48:08,890
means that basically my curtain and

1069
00:48:05,600 --> 00:48:11,990
scheduling becomes completely irrelevant

1070
00:48:08,890 --> 00:48:19,129
completely you space your relevant let

1071
00:48:11,990 --> 00:48:20,660
me show you what how can that be done is

1072
00:48:19,130 --> 00:48:24,410
the same way it's actually the same

1073
00:48:20,660 --> 00:48:29,080
structurally - I need to just change a

1074
00:48:24,410 --> 00:48:31,549
few lines unto one line one macro and

1075
00:48:29,080 --> 00:48:33,380
this timestamp our product directly by

1076
00:48:31,550 --> 00:48:36,560
the network card as I said there are a

1077
00:48:33,380 --> 00:48:39,350
few crackers here the view but with

1078
00:48:36,560 --> 00:48:40,670
nanosecond position as far as I know

1079
00:48:39,350 --> 00:48:42,710
this is the first time which has been

1080
00:48:40,670 --> 00:48:45,050
applied to timing attack I just need to

1081
00:48:42,710 --> 00:48:50,630
change this parameters and if my cars

1082
00:48:45,050 --> 00:48:52,790
are posted again let me show this it was

1083
00:48:50,630 --> 00:48:55,700
80,000 before and now it's six times

1084
00:48:52,790 --> 00:48:57,230
more precise I don't get it this has

1085
00:48:55,700 --> 00:48:59,089
been done while I was using a browser

1086
00:48:57,230 --> 00:49:00,620
what I was doing all this thing is much

1087
00:48:59,090 --> 00:49:03,530
better than the current measurement

1088
00:49:00,620 --> 00:49:07,100
already how I did Skype active only see

1089
00:49:03,530 --> 00:49:09,560
I was actually doing stuff nicely so

1090
00:49:07,100 --> 00:49:12,970
what are the problems here at the moment

1091
00:49:09,560 --> 00:49:16,670
they need to prop up as I've been told

1092
00:49:12,970 --> 00:49:19,069
demo I'm going to show you that in if

1093
00:49:16,670 --> 00:49:23,120
you want to see that in a in hardware in

1094
00:49:19,070 --> 00:49:25,670
the CTF that you can join is the same

1095
00:49:23,120 --> 00:49:28,670
time again you just described I have 8

1096
00:49:25,670 --> 00:49:31,310
digits open and this is what I got

1097
00:49:28,670 --> 00:49:33,200
instead of having 8 digit pin that needs

1098
00:49:31,310 --> 00:49:37,160
to be found in 100 million attempts I

1099
00:49:33,200 --> 00:49:38,960
can do that into one in two million with

1100
00:49:37,160 --> 00:49:41,120
the differential pair counted okay which

1101
00:49:38,960 --> 00:49:46,280
means basically 1 million atoms which is

1102
00:49:41,120 --> 00:49:48,440
a percent of the space that is needed

1103
00:49:46,280 --> 00:49:50,360
for brute force that I can actually show

1104
00:49:48,440 --> 00:49:53,120
that real time for a slower clock

1105
00:49:50,360 --> 00:49:57,170
because it is one microsecond difference

1106
00:49:53,120 --> 00:49:59,750
if we go to tenth like in ICS device I

1107
00:49:57,170 --> 00:50:02,900
take that in probably 100 attempts and

1108
00:49:59,750 --> 00:50:10,020
then show that field is if you come to

1109
00:50:02,900 --> 00:50:12,030
our CTF questions done ok

1110
00:50:10,020 --> 00:50:14,490
you see at the hardware CDA flagship

1111
00:50:12,030 --> 00:50:18,230
area people can probably any questions

1112
00:50:14,490 --> 00:50:18,229
you can thank you much thank you

