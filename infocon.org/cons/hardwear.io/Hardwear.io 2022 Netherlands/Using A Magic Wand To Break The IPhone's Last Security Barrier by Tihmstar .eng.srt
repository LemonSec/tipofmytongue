1
00:00:03,840 --> 00:00:06,359
right thank you very much I'm very

2
00:00:06,359 --> 00:00:10,980
excited to talk about my research today

3
00:00:10,980 --> 00:00:14,940
um yeah so the time the title is using a

4
00:00:14,940 --> 00:00:18,119
magic wand to break the iPhone's last

5
00:00:18,119 --> 00:00:20,699
security barrier you can see this is the

6
00:00:20,699 --> 00:00:22,260
magic wand I used

7
00:00:22,260 --> 00:00:24,600
actually if you try to Google magic one

8
00:00:24,600 --> 00:00:26,340
the first 20 results it's not what you

9
00:00:26,340 --> 00:00:27,900
expect so it took me quite some effort

10
00:00:27,900 --> 00:00:29,880
to fight this one

11
00:00:29,880 --> 00:00:31,140
um well

12
00:00:31,140 --> 00:00:35,100
let's get started so my target device is

13
00:00:35,100 --> 00:00:39,360
the iPhone 4 which has the A4 CPU it was

14
00:00:39,360 --> 00:00:42,239
released in June 2010 and if you're

15
00:00:42,239 --> 00:00:44,100
wondering hey why are you talking about

16
00:00:44,100 --> 00:00:46,500
like such an old device This research

17
00:00:46,500 --> 00:00:49,680
actually dates back to 2019 where this

18
00:00:49,680 --> 00:00:52,379
was the latest device with a boot from

19
00:00:52,379 --> 00:00:54,360
vulnerability which was lime range so

20
00:00:54,360 --> 00:00:56,820
this is pre-checkmate

21
00:00:56,820 --> 00:00:58,500
yeah and gives you the highest possible

22
00:00:58,500 --> 00:01:01,739
privileges uh which we will need

23
00:01:01,739 --> 00:01:03,660
it has no dedicated security code

24
00:01:03,660 --> 00:01:06,500
processor it has a hardware as engine

25
00:01:06,500 --> 00:01:10,140
and it has Hopper piece keys and the

26
00:01:10,140 --> 00:01:12,479
engine also allows you running

27
00:01:12,479 --> 00:01:15,600
encryptions and decryption with AES with

28
00:01:15,600 --> 00:01:18,000
your own keys this is not necessarily

29
00:01:18,000 --> 00:01:19,860
required but you kind of want to have

30
00:01:19,860 --> 00:01:22,200
this if you're targeting an unknown

31
00:01:22,200 --> 00:01:24,540
implementation so you do need Oracle

32
00:01:24,540 --> 00:01:27,479
access to encryption it gives you Oracle

33
00:01:27,479 --> 00:01:30,360
access uh to encrypting and decrypting

34
00:01:30,360 --> 00:01:33,420
AES and CPC mode

35
00:01:33,420 --> 00:01:36,420
motivation well you can extract the

36
00:01:36,420 --> 00:01:38,880
model specific GID key this is shared

37
00:01:38,880 --> 00:01:41,820
across all iPhone 4S that allows you

38
00:01:41,820 --> 00:01:43,860
decrypting the firmware without actually

39
00:01:43,860 --> 00:01:46,320
having the physical device on you it

40
00:01:46,320 --> 00:01:48,299
doesn't really have any bad benefits for

41
00:01:48,299 --> 00:01:51,119
devices with the bootron exploits but

42
00:01:51,119 --> 00:01:52,860
assuming you do that on a new device

43
00:01:52,860 --> 00:01:56,220
once through glitching and you get code

44
00:01:56,220 --> 00:01:58,200
execution then you extract the key then

45
00:01:58,200 --> 00:02:00,240
you can always encrypt the firmware so

46
00:02:00,240 --> 00:02:03,780
may be useful for other targets

47
00:02:03,780 --> 00:02:07,700
there is the device specific uid key

48
00:02:07,700 --> 00:02:10,380
which allow if you extract that that

49
00:02:10,380 --> 00:02:12,840
allows scalable offline cracking of

50
00:02:12,840 --> 00:02:15,780
passcodes and the passcode the past the

51
00:02:15,780 --> 00:02:18,540
password he decrypts the user data but

52
00:02:18,540 --> 00:02:21,420
to spoiler this whole attack that I'm

53
00:02:21,420 --> 00:02:24,900
presenting here only benefits the effort

54
00:02:24,900 --> 00:02:27,540
like attack benefits only outweight the

55
00:02:27,540 --> 00:02:29,160
effort for passport which are more

56
00:02:29,160 --> 00:02:31,800
complex than eight digit numeric if your

57
00:02:31,800 --> 00:02:34,080
passcode is less complex than a digit

58
00:02:34,080 --> 00:02:35,700
numeric you might as well just crack it

59
00:02:35,700 --> 00:02:37,200
on device because you do need the same

60
00:02:37,200 --> 00:02:39,480
Primitives to get started

61
00:02:39,480 --> 00:02:41,640
so the requirements for the EM attack

62
00:02:41,640 --> 00:02:44,400
are well code execution on the target we

63
00:02:44,400 --> 00:02:46,620
want to have Oracle access to the AES

64
00:02:46,620 --> 00:02:49,379
Engine with the target key obviously you

65
00:02:49,379 --> 00:02:51,360
also want to have Oracle access with the

66
00:02:51,360 --> 00:02:53,519
known key this is technically not

67
00:02:53,519 --> 00:02:55,200
required but you really want to have

68
00:02:55,200 --> 00:02:56,640
this if you're targeting an unknown

69
00:02:56,640 --> 00:02:59,220
implementation you want to have a low

70
00:02:59,220 --> 00:03:02,760
latency trigger for your oscilloscope

71
00:03:02,760 --> 00:03:05,400
measurements and well you'll need an em

72
00:03:05,400 --> 00:03:07,319
probe you need a oscilloscope you need

73
00:03:07,319 --> 00:03:10,500
computational resources and so on

74
00:03:10,500 --> 00:03:12,720
so let's take a look at the Target setup

75
00:03:12,720 --> 00:03:15,720
software side I do use the lime range

76
00:03:15,720 --> 00:03:18,300
boot from exploit to gain early code

77
00:03:18,300 --> 00:03:20,879
execution I put a patch State one

78
00:03:20,879 --> 00:03:23,099
bootloader which does low level

79
00:03:23,099 --> 00:03:25,860
initialization like dram for example uh

80
00:03:25,860 --> 00:03:28,080
I put the patch second stage loader for

81
00:03:28,080 --> 00:03:30,120
just the more convenient environment to

82
00:03:30,120 --> 00:03:31,440
work with because

83
00:03:31,440 --> 00:03:32,040
um

84
00:03:32,040 --> 00:03:35,220
iboot actually has a custom shell so if

85
00:03:35,220 --> 00:03:36,959
you do a little patching you can run

86
00:03:36,959 --> 00:03:39,599
your own payload player bare metal but

87
00:03:39,599 --> 00:03:41,700
still with like some functionality

88
00:03:41,700 --> 00:03:43,920
already available like printf uart and

89
00:03:43,920 --> 00:03:46,019
stuff like that it doesn't have a

90
00:03:46,019 --> 00:03:49,980
propriety USB interface and it has uart

91
00:03:49,980 --> 00:03:53,459
you have all access to RAM and mmio and

92
00:03:53,459 --> 00:03:55,379
it's kind of the best noise free

93
00:03:55,379 --> 00:03:56,879
environment you can get because there's

94
00:03:56,879 --> 00:03:59,220
only one CPU or active it has a

95
00:03:59,220 --> 00:04:01,980
Cooperative scheduler and it usually has

96
00:04:01,980 --> 00:04:04,739
no unexpected interrupts

97
00:04:04,739 --> 00:04:07,080
on the hardware side while I'm using the

98
00:04:07,080 --> 00:04:10,560
USB and the uart so in order to get view

99
00:04:10,560 --> 00:04:13,260
art on this old 30 pin connector devices

100
00:04:13,260 --> 00:04:15,060
you need to build the yard cable like

101
00:04:15,060 --> 00:04:17,100
this basically this is just a breakout

102
00:04:17,100 --> 00:04:19,440
board your soul and the USB wires you

103
00:04:19,440 --> 00:04:22,019
use solder in a resistor empty solder

104
00:04:22,019 --> 00:04:24,180
and you are that that's pretty much it

105
00:04:24,180 --> 00:04:28,440
using like an ft23i board uh You Get Ur

106
00:04:28,440 --> 00:04:30,960
to USB so if you two USB connectors one

107
00:04:30,960 --> 00:04:34,199
for actually sv1

108
00:04:34,199 --> 00:04:36,780
uh well how about triggering our scope

109
00:04:36,780 --> 00:04:38,880
measurements with the uart

110
00:04:38,880 --> 00:04:42,660
um well no uart stands for universal

111
00:04:42,660 --> 00:04:44,520
asynchronous receiver and transmitter

112
00:04:44,520 --> 00:04:46,380
and the asynchronous is a bit problem

113
00:04:46,380 --> 00:04:49,500
because it's also possibly buffered on

114
00:04:49,500 --> 00:04:51,419
sender and receiver side and it's

115
00:04:51,419 --> 00:04:53,820
definitely not real time furthermore if

116
00:04:53,820 --> 00:04:56,880
you use a standard bitrate of 11 5 200

117
00:04:56,880 --> 00:04:59,780
bits per second which is

118
00:04:59,780 --> 00:05:05,220
8.68 uh picoseconds uh per bit

119
00:05:05,220 --> 00:05:08,900
um one byte takes about

120
00:05:08,900 --> 00:05:11,520
9 95

121
00:05:11,520 --> 00:05:14,520
um micro 20 seconds

122
00:05:14,520 --> 00:05:17,160
anyways the so if you send immediate

123
00:05:17,160 --> 00:05:20,280
start stop signal which is like 190

124
00:05:20,280 --> 00:05:21,720
microseconds assuming there's no

125
00:05:21,720 --> 00:05:24,720
buffering in between but which there is

126
00:05:24,720 --> 00:05:29,039
um it's too slow our as it's long done

127
00:05:29,039 --> 00:05:32,460
by that so that's way too slow

128
00:05:32,460 --> 00:05:33,960
but

129
00:05:33,960 --> 00:05:35,580
um there are peripherals on the phone

130
00:05:35,580 --> 00:05:38,039
well arm peripherals are connected over

131
00:05:38,039 --> 00:05:39,259
gpio

132
00:05:39,259 --> 00:05:41,820
uh so what peripherals are there well

133
00:05:41,820 --> 00:05:43,620
there's buttons there's modules like

134
00:05:43,620 --> 00:05:46,440
Wi-Fi Bluetooth GPS Euro Compass control

135
00:05:46,440 --> 00:05:50,940
signals lce camera but most importantly

136
00:05:50,940 --> 00:05:53,039
there's buttons which are connected to

137
00:05:53,039 --> 00:05:54,539
gpio

138
00:05:54,539 --> 00:05:58,139
so what exactly is gpio gpio is

139
00:05:58,139 --> 00:06:01,139
um general purpose input output

140
00:06:01,139 --> 00:06:03,960
and those pins are configured at boot

141
00:06:03,960 --> 00:06:06,419
actually by the system so since we have

142
00:06:06,419 --> 00:06:09,419
code execution we can reconfigure those

143
00:06:09,419 --> 00:06:13,860
GPI opens right so if we reconfigure the

144
00:06:13,860 --> 00:06:17,039
volume buttons we can actually use them

145
00:06:17,039 --> 00:06:19,500
as an output instead of an input

146
00:06:19,500 --> 00:06:22,979
so gpio is memory mapped IO so we write

147
00:06:22,979 --> 00:06:25,319
to this address in Ram to set the pin

148
00:06:25,319 --> 00:06:27,479
high or low and Bam we have a perfect

149
00:06:27,479 --> 00:06:30,600
trigger for measurements this is much

150
00:06:30,600 --> 00:06:32,460
faster than you are and it is

151
00:06:32,460 --> 00:06:34,199
synchronous

152
00:06:34,199 --> 00:06:36,539
how does that look like in practice well

153
00:06:36,539 --> 00:06:39,479
you can just disassemble the boards just

154
00:06:39,479 --> 00:06:41,940
take out that these volume buttons just

155
00:06:41,940 --> 00:06:44,940
solder wires directly to them and then

156
00:06:44,940 --> 00:06:47,460
right to the address and RAM and then

157
00:06:47,460 --> 00:06:49,139
you get like the high signal and low

158
00:06:49,139 --> 00:06:51,560
signal you

159
00:06:52,020 --> 00:06:54,720
this is the payload I used

160
00:06:54,720 --> 00:06:57,300
um so basically the iPhone already has a

161
00:06:57,300 --> 00:06:59,639
function which you can call which which

162
00:06:59,639 --> 00:07:02,699
runs AES on the hardware engine

163
00:07:02,699 --> 00:07:06,419
and I put this hook in there so at some

164
00:07:06,419 --> 00:07:08,280
point it jumps to that code and then

165
00:07:08,280 --> 00:07:11,520
that takes over basically uh the

166
00:07:11,520 --> 00:07:13,919
important thing here is that I have one

167
00:07:13,919 --> 00:07:16,380
assembly instruction which is one store

168
00:07:16,380 --> 00:07:19,199
byte instruction which sets the trigger

169
00:07:19,199 --> 00:07:21,900
High the next assembly instructions

170
00:07:21,900 --> 00:07:24,060
starts the actual as then I have a

171
00:07:24,060 --> 00:07:27,360
little Loop which checks if the AES is

172
00:07:27,360 --> 00:07:29,520
done and then I have yet another

173
00:07:29,520 --> 00:07:31,620
assembly instructions which sets the

174
00:07:31,620 --> 00:07:34,080
trigger low so this is as good as it

175
00:07:34,080 --> 00:07:35,340
gets

176
00:07:35,340 --> 00:07:39,419
and by that we can have like python Eis

177
00:07:39,419 --> 00:07:41,220
and open and we already know where to

178
00:07:41,220 --> 00:07:44,160
look in between for the is

179
00:07:44,160 --> 00:07:45,539
German setup

180
00:07:45,539 --> 00:07:47,460
um well running AIS in the loop uses

181
00:07:47,460 --> 00:07:49,500
more power than USB device which

182
00:07:49,500 --> 00:07:51,599
discharges battery and you have limited

183
00:07:51,599 --> 00:07:54,060
measuring time which kind of sucks so

184
00:07:54,060 --> 00:07:56,880
just remove the battery and use the

185
00:07:56,880 --> 00:07:59,099
custom lab power supply

186
00:07:59,099 --> 00:08:01,380
easy

187
00:08:01,380 --> 00:08:04,199
uh obligatory slide for the equipment I

188
00:08:04,199 --> 00:08:05,400
used

189
00:08:05,400 --> 00:08:06,199
um

190
00:08:06,199 --> 00:08:09,419
I'm not really side Channel guys so I

191
00:08:09,419 --> 00:08:11,280
just went up to the university it was

192
00:08:11,280 --> 00:08:13,440
like hey give me your best equipment and

193
00:08:13,440 --> 00:08:15,660
this is what I got I I guess the

194
00:08:15,660 --> 00:08:18,240
important part here is uh the 40 Giga

195
00:08:18,240 --> 00:08:20,580
samples per second sampling rate which I

196
00:08:20,580 --> 00:08:23,280
believe I really needed uh other than

197
00:08:23,280 --> 00:08:25,379
that it's just a slide for you looking

198
00:08:25,379 --> 00:08:27,660
up later uh by the way I will release

199
00:08:27,660 --> 00:08:30,199
these slides

200
00:08:30,419 --> 00:08:32,039
slides so for the analysis what you do

201
00:08:32,039 --> 00:08:34,020
first well you gather information

202
00:08:34,020 --> 00:08:36,059
um you search online uh manual reverse

203
00:08:36,059 --> 00:08:38,099
engineering of developer luckily for

204
00:08:38,099 --> 00:08:40,080
that device a lot of public work has

205
00:08:40,080 --> 00:08:42,419
been done already so from that we know

206
00:08:42,419 --> 00:08:46,740
we have a as engine which supports as128

207
00:08:46,740 --> 00:08:51,779
um 192 and 250 six with as we have the

208
00:08:51,779 --> 00:08:54,540
uid key the GID key and we can supply

209
00:08:54,540 --> 00:08:57,120
custom user keys

210
00:08:57,120 --> 00:09:00,060
we can use it in CBC mode and in ecd

211
00:09:00,060 --> 00:09:01,380
mode

212
00:09:01,380 --> 00:09:03,839
okay so also good let's do some more

213
00:09:03,839 --> 00:09:05,940
basic analysis time analysis we have the

214
00:09:05,940 --> 00:09:09,540
start and the amp Gio signal we can just

215
00:09:09,540 --> 00:09:11,940
study the traces and we can run multiple

216
00:09:11,940 --> 00:09:13,920
blocks of is instead of one block while

217
00:09:13,920 --> 00:09:15,180
encrypt like eight blocks or something

218
00:09:15,180 --> 00:09:18,720
that okay I done that so basically we

219
00:09:18,720 --> 00:09:20,160
get something like this in the top left

220
00:09:20,160 --> 00:09:24,779
we have two blocks encrypting then 4 8

221
00:09:24,779 --> 00:09:27,240
and 16. so what do we see we have

222
00:09:27,240 --> 00:09:28,740
something at the beginning and something

223
00:09:28,740 --> 00:09:30,839
at the end which kind of looks constant

224
00:09:30,839 --> 00:09:33,300
and then in the middle something which

225
00:09:33,300 --> 00:09:35,339
seems to grow the more blocks we encrypt

226
00:09:35,339 --> 00:09:38,279
so okay so this is probably where some

227
00:09:38,279 --> 00:09:41,220
of the encryption is happening right so

228
00:09:41,220 --> 00:09:43,740
the blue line is the gpio trigger signal

229
00:09:43,740 --> 00:09:45,480
and the red line is actually the AM

230
00:09:45,480 --> 00:09:47,399
signal

231
00:09:47,399 --> 00:09:50,160
it gets even more clear if you plot them

232
00:09:50,160 --> 00:09:52,140
on top of each other so at the beginning

233
00:09:52,140 --> 00:09:54,240
you see the constant Parts which are

234
00:09:54,240 --> 00:09:56,279
probably not interesting for us and then

235
00:09:56,279 --> 00:09:58,740
the variable Parts is which we where we

236
00:09:58,740 --> 00:10:01,880
expect to see some as

237
00:10:02,519 --> 00:10:05,279
so from doing this timing analysis one

238
00:10:05,279 --> 00:10:08,640
block of AES so if you take the trigger

239
00:10:08,640 --> 00:10:12,660
starts to stop the gpios like 3000

240
00:10:12,660 --> 00:10:14,040
nanoseconds

241
00:10:14,040 --> 00:10:15,899
if you

242
00:10:15,899 --> 00:10:18,420
um go to these Peaks the lower green

243
00:10:18,420 --> 00:10:20,459
line which I think to be the interesting

244
00:10:20,459 --> 00:10:22,320
piece and I guess should be somewhere in

245
00:10:22,320 --> 00:10:26,940
between we have uh 755 nanoseconds in

246
00:10:26,940 --> 00:10:30,060
each if you instead of one block encrypt

247
00:10:30,060 --> 00:10:33,600
uh 16 blocks and then do like longer

248
00:10:33,600 --> 00:10:35,940
measurement and divide by 60 you get for

249
00:10:35,940 --> 00:10:40,200
the gpio 205 nanoseconds and or the uh

250
00:10:40,200 --> 00:10:42,060
Peaks 120

251
00:10:42,060 --> 00:10:46,320
um or 25 nanoseconds so we know okay one

252
00:10:46,320 --> 00:10:50,519
as is probably faster than 124

253
00:10:50,519 --> 00:10:53,820
nanoseconds so we already can get some

254
00:10:53,820 --> 00:10:56,959
very basic information

255
00:10:57,240 --> 00:11:00,480
after that we can do some actual side

256
00:11:00,480 --> 00:11:03,120
Channel analysis um which is first we do

257
00:11:03,120 --> 00:11:05,160
leakage assessment so I use the

258
00:11:05,160 --> 00:11:08,820
non-specific t-test basically which you

259
00:11:08,820 --> 00:11:12,540
feed the IES either random inputs or a

260
00:11:12,540 --> 00:11:13,560
fixed

261
00:11:13,560 --> 00:11:16,380
and you collect thousands of traces so

262
00:11:16,380 --> 00:11:18,959
for the fixed input you have all sort of

263
00:11:18,959 --> 00:11:21,839
fixed the same intermediate values in

264
00:11:21,839 --> 00:11:23,640
the internal AES state

265
00:11:23,640 --> 00:11:27,620
so for non-mask implementations

266
00:11:27,779 --> 00:11:31,980
and we expect like to have the same

267
00:11:31,980 --> 00:11:33,180
power consumption

268
00:11:33,180 --> 00:11:36,180
so if the groups are distinguishable

269
00:11:36,180 --> 00:11:38,940
just by the EM traces then an attack

270
00:11:38,940 --> 00:11:41,459
might be possible

271
00:11:41,459 --> 00:11:43,800
um if that doesn't succeed we can try

272
00:11:43,800 --> 00:11:46,380
other things like higher order t-tests

273
00:11:46,380 --> 00:11:49,680
and there's lots of fun math and

274
00:11:49,680 --> 00:11:51,720
statistics which I have no idea about

275
00:11:51,720 --> 00:11:54,480
but I know it exists

276
00:11:54,480 --> 00:11:57,720
so what is the t-test in case you never

277
00:11:57,720 --> 00:12:00,120
heard of it t-test is a statistical

278
00:12:00,120 --> 00:12:03,839
hypothesis test which confirms or

279
00:12:03,839 --> 00:12:06,600
rejects how policies with a certain

280
00:12:06,600 --> 00:12:09,060
likelihood so the hypothesis that we

281
00:12:09,060 --> 00:12:10,800
have is the null hypothesis which

282
00:12:10,800 --> 00:12:13,920
assumes that two sets are drawn from the

283
00:12:13,920 --> 00:12:16,260
same distribution rather than two

284
00:12:16,260 --> 00:12:18,420
separate distributions I have images to

285
00:12:18,420 --> 00:12:20,279
visualize that element

286
00:12:20,279 --> 00:12:23,279
s basically the G test gives you a

287
00:12:23,279 --> 00:12:25,800
statistical value for determining the

288
00:12:25,800 --> 00:12:30,000
likelihood that two given sets are drawn

289
00:12:30,000 --> 00:12:33,060
from two distinct distributions

290
00:12:33,060 --> 00:12:35,160
so what does that mean

291
00:12:35,160 --> 00:12:36,959
assume you have

292
00:12:36,959 --> 00:12:41,519
um set a and set B and the top two

293
00:12:41,519 --> 00:12:45,959
pictures we have uh the fixed and a

294
00:12:45,959 --> 00:12:47,579
random

295
00:12:47,579 --> 00:12:50,100
from like from a fixed this sentence

296
00:12:50,100 --> 00:12:51,720
from a random so these are actually two

297
00:12:51,720 --> 00:12:53,880
different sets which gives us a high

298
00:12:53,880 --> 00:12:56,459
absolute T value and in the lower two

299
00:12:56,459 --> 00:13:00,120
ones we draw them from the same

300
00:13:00,120 --> 00:13:02,639
distribution which you can see all the

301
00:13:02,639 --> 00:13:04,500
colors and that will give us a value

302
00:13:04,500 --> 00:13:06,779
close to zero

303
00:13:06,779 --> 00:13:09,120
so if the value is high we think it's

304
00:13:09,120 --> 00:13:10,380
two different

305
00:13:10,380 --> 00:13:12,360
um sets and we can potentially

306
00:13:12,360 --> 00:13:14,160
distinguish that

307
00:13:14,160 --> 00:13:16,380
by collecting

308
00:13:16,380 --> 00:13:18,899
um 10 million traces

309
00:13:18,899 --> 00:13:21,120
um we can see we have a very nice T

310
00:13:21,120 --> 00:13:23,579
value so usually the threshold is if

311
00:13:23,579 --> 00:13:26,940
it's above 4.5 then we have some kind of

312
00:13:26,940 --> 00:13:28,620
leakage and we assume okay we have

313
00:13:28,620 --> 00:13:31,620
leakage and here the value is much much

314
00:13:31,620 --> 00:13:34,160
larger

315
00:13:34,500 --> 00:13:37,740
um although the very large Peaks are

316
00:13:37,740 --> 00:13:40,019
probably not interesting is actually you

317
00:13:40,019 --> 00:13:42,060
know when we talk to the is engine we

318
00:13:42,060 --> 00:13:44,579
transfer data to the is engine and then

319
00:13:44,579 --> 00:13:47,579
we transfer the data back and these are

320
00:13:47,579 --> 00:13:49,980
very like loud and leaky and we're not

321
00:13:49,980 --> 00:13:52,019
actually interested in this so I think

322
00:13:52,019 --> 00:13:53,820
these are the yellow transfers

323
00:13:53,820 --> 00:13:56,459
which in turn means the is probably

324
00:13:56,459 --> 00:13:59,519
between so let's Zoom a bit in but even

325
00:13:59,519 --> 00:14:02,160
if we zoom in the values are huge you

326
00:14:02,160 --> 00:14:04,320
can see they go up to like 200 and we

327
00:14:04,320 --> 00:14:07,139
only want them to be higher than 4.5 or

328
00:14:07,139 --> 00:14:10,320
lower than minus 4.5 so something is

329
00:14:10,320 --> 00:14:12,180
leaking

330
00:14:12,180 --> 00:14:15,660
if we also plot them the T value on top

331
00:14:15,660 --> 00:14:17,579
of the EM traces

332
00:14:17,579 --> 00:14:18,120
um

333
00:14:18,120 --> 00:14:19,980
which we deemed like the interesting

334
00:14:19,980 --> 00:14:22,680
Peaks we can see okay even in the

335
00:14:22,680 --> 00:14:25,260
interesting part we have good T values

336
00:14:25,260 --> 00:14:27,720
okay good something is leaking let's

337
00:14:27,720 --> 00:14:30,600
move on to the next step

338
00:14:30,600 --> 00:14:33,720
so the next thing I did is I used the

339
00:14:33,720 --> 00:14:35,760
signal to noise ratio so what is that

340
00:14:35,760 --> 00:14:38,579
well signature noise ratio uses a power

341
00:14:38,579 --> 00:14:39,660
model

342
00:14:39,660 --> 00:14:43,260
to sort traces into different groups

343
00:14:43,260 --> 00:14:47,160
based on a Model value right and

344
00:14:47,160 --> 00:14:49,740
accurate power model of the inner set of

345
00:14:49,740 --> 00:14:52,680
the S will have distinct groups

346
00:14:52,680 --> 00:14:55,560
uh like this thing sorting and other Pro

347
00:14:55,560 --> 00:14:58,680
Models will have random groups

348
00:14:58,680 --> 00:15:01,800
um so the SNR does two things uh first

349
00:15:01,800 --> 00:15:05,639
it gets a value on how different are

350
00:15:05,639 --> 00:15:08,639
these groups from each other

351
00:15:08,639 --> 00:15:09,959
um

352
00:15:09,959 --> 00:15:11,880
and it gives you information about the

353
00:15:11,880 --> 00:15:14,160
accuracy of the power model which you

354
00:15:14,160 --> 00:15:15,480
can use for an attack

355
00:15:15,480 --> 00:15:17,040
so the other thing is since we're not

356
00:15:17,040 --> 00:15:19,019
doing this at one point in time but on

357
00:15:19,019 --> 00:15:21,540
all many points of time we also get the

358
00:15:21,540 --> 00:15:26,699
info on when in time the model fits very

359
00:15:26,699 --> 00:15:29,399
well so we also get like timing

360
00:15:29,399 --> 00:15:31,079
information

361
00:15:31,079 --> 00:15:34,139
so explaining the signal to noise ratio

362
00:15:34,139 --> 00:15:36,420
basically here as an example you sort

363
00:15:36,420 --> 00:15:38,160
these

364
00:15:38,160 --> 00:15:41,040
bricks I call them by model

365
00:15:41,040 --> 00:15:43,860
um and then computer SNR how good the

366
00:15:43,860 --> 00:15:45,420
groups are

367
00:15:45,420 --> 00:15:48,120
sword is judging by needs for example in

368
00:15:48,120 --> 00:15:51,000
the top ones we sort them by edges and

369
00:15:51,000 --> 00:15:52,620
we can see okay this is a very good

370
00:15:52,620 --> 00:15:58,079
sorting so the S and R values line 0.92

371
00:15:58,079 --> 00:16:00,000
spending the lower we sold them by color

372
00:16:00,000 --> 00:16:01,440
and you can see the colors don't

373
00:16:01,440 --> 00:16:03,600
actually quite match the grooves so we

374
00:16:03,600 --> 00:16:06,480
have like lower value so high value

375
00:16:06,480 --> 00:16:10,699
means this thing so we want to see

376
00:16:11,459 --> 00:16:14,100
right so as a model

377
00:16:14,100 --> 00:16:17,519
um I use next the input or and the

378
00:16:17,519 --> 00:16:18,959
output

379
00:16:18,959 --> 00:16:21,480
um all the Hamming weight of the input

380
00:16:21,480 --> 00:16:24,420
plain text of one input point x y and

381
00:16:24,420 --> 00:16:25,680
Vary that and try that for different

382
00:16:25,680 --> 00:16:28,199
heights and also the output of what we

383
00:16:28,199 --> 00:16:30,360
get out and the Hemingway of that I use

384
00:16:30,360 --> 00:16:32,820
as the model so we have nine groups in

385
00:16:32,820 --> 00:16:34,079
total

386
00:16:34,079 --> 00:16:36,240
and then we can check where the signal

387
00:16:36,240 --> 00:16:39,720
is seen so if we repeat that for several

388
00:16:39,720 --> 00:16:42,899
bytes uh here I do encryption of eight

389
00:16:42,899 --> 00:16:45,540
blocks of as and let's take our input

390
00:16:45,540 --> 00:16:48,000
pipe and Hemingway then use this as a

391
00:16:48,000 --> 00:16:50,820
model for all for all of the eight

392
00:16:50,820 --> 00:16:54,420
blocks we can see okay we have a good

393
00:16:54,420 --> 00:16:57,600
signal here and then using the output

394
00:16:57,600 --> 00:16:59,279
bytes doing the same and we have

395
00:16:59,279 --> 00:17:02,100
different signals there other bytes

396
00:17:02,100 --> 00:17:05,040
yield similar values and

397
00:17:05,040 --> 00:17:08,099
this also interesting to see that from

398
00:17:08,099 --> 00:17:11,040
that we can learn that the input seems

399
00:17:11,040 --> 00:17:14,699
to be or probably is transferred at once

400
00:17:14,699 --> 00:17:17,280
while the output is first we get four

401
00:17:17,280 --> 00:17:20,160
blocks and then two and then again two

402
00:17:20,160 --> 00:17:23,339
so this is already interesting to see if

403
00:17:23,339 --> 00:17:27,720
we overlap that with our em signal this

404
00:17:27,720 --> 00:17:29,700
kind of confirms the hypothesis that

405
00:17:29,700 --> 00:17:32,160
loud Peaks are the AO transfer because

406
00:17:32,160 --> 00:17:34,740
this is exactly where we see uh leaking

407
00:17:34,740 --> 00:17:37,980
of the um output right so this is like

408
00:17:37,980 --> 00:17:39,660
not the interesting thing

409
00:17:39,660 --> 00:17:43,200
uh it's like IO transfer not yes so but

410
00:17:43,200 --> 00:17:47,400
we also know that in this time span

411
00:17:47,400 --> 00:17:50,100
definitely at least four encryptions

412
00:17:50,100 --> 00:17:52,559
happen because CB

413
00:17:52,559 --> 00:17:54,480
um input leaking and then we see the

414
00:17:54,480 --> 00:17:56,280
output leaking so we know somewhere in

415
00:17:56,280 --> 00:18:00,539
between has the is to take a place right

416
00:18:00,539 --> 00:18:04,340
so great this is more informations

417
00:18:04,980 --> 00:18:07,919
um now I actually want to go a step back

418
00:18:07,919 --> 00:18:11,039
um where do you put your probe right

419
00:18:11,039 --> 00:18:13,620
because this already I put the probe

420
00:18:13,620 --> 00:18:15,840
somewhere obviously but way where should

421
00:18:15,840 --> 00:18:18,299
you actually put the problem well uh I

422
00:18:18,299 --> 00:18:20,160
had like lecture University which tells

423
00:18:20,160 --> 00:18:22,140
me uh so you take the probe you move it

424
00:18:22,140 --> 00:18:24,360
around you look at the end traces and

425
00:18:24,360 --> 00:18:27,360
they'll try to identify the signal

426
00:18:27,360 --> 00:18:30,299
um find just a spot with the

427
00:18:30,299 --> 00:18:34,140
strongest signal easy enough right

428
00:18:34,140 --> 00:18:36,000
well

429
00:18:36,000 --> 00:18:39,240
reality is much different

430
00:18:39,240 --> 00:18:42,419
no visible signal whatsoever

431
00:18:42,419 --> 00:18:44,900
there is lots of jitters

432
00:18:44,900 --> 00:18:48,179
scaring too much at traces makes you go

433
00:18:48,179 --> 00:18:50,520
crazy it's like if you stare for them

434
00:18:50,520 --> 00:18:53,220
for like six months we'll find the goals

435
00:18:53,220 --> 00:18:55,200
of the past the present and the future

436
00:18:55,200 --> 00:18:59,160
Christmas so don't over interpret

437
00:18:59,160 --> 00:19:02,220
um random noise Peaks or whatever I'll

438
00:19:02,220 --> 00:19:03,900
show you what I mean

439
00:19:03,900 --> 00:19:07,080
this is like 500 traces put on top of

440
00:19:07,080 --> 00:19:09,600
each other already filtered already

441
00:19:09,600 --> 00:19:11,280
aligned

442
00:19:11,280 --> 00:19:13,980
you don't see anything in there but

443
00:19:13,980 --> 00:19:16,559
there is 5asa in place

444
00:19:16,559 --> 00:19:18,600
we'll come back to similar image like

445
00:19:18,600 --> 00:19:21,179
that and you'll see what I mean but for

446
00:19:21,179 --> 00:19:23,760
now just assume like even if you think

447
00:19:23,760 --> 00:19:25,440
oh yeah that at the back is yes no

448
00:19:25,440 --> 00:19:27,179
that's not it

449
00:19:27,179 --> 00:19:30,740
you cannot see the Asm

450
00:19:31,020 --> 00:19:34,200
well best strategy is you just put it

451
00:19:34,200 --> 00:19:36,539
somewhere and hope it's good what else

452
00:19:36,539 --> 00:19:39,080
you're gonna do

453
00:19:39,179 --> 00:19:41,340
um so what you want to do then is you

454
00:19:41,340 --> 00:19:43,500
want to search for leaking power model

455
00:19:43,500 --> 00:19:45,299
because sure the hemming white of the

456
00:19:45,299 --> 00:19:47,880
inputs or the output works fine but it

457
00:19:47,880 --> 00:19:49,500
doesn't really help you you want to

458
00:19:49,500 --> 00:19:52,860
model AES intermediate state

459
00:19:52,860 --> 00:19:55,200
and then if you do that and you find an

460
00:19:55,200 --> 00:19:56,700
accurate model you can actually use that

461
00:19:56,700 --> 00:19:59,299
for an attack

462
00:19:59,580 --> 00:20:03,240
um I tested all of these models for

463
00:20:03,240 --> 00:20:05,640
various implementations like literally

464
00:20:05,640 --> 00:20:07,860
everything I could think of I had a

465
00:20:07,860 --> 00:20:09,059
different course describing different

466
00:20:09,059 --> 00:20:10,799
Hardware implementations so that came in

467
00:20:10,799 --> 00:20:12,960
handy key table and Plantation

468
00:20:12,960 --> 00:20:15,240
round-based and rotation register after

469
00:20:15,240 --> 00:20:17,940
certain steps after each steps after one

470
00:20:17,940 --> 00:20:20,880
round trade many many models uh for

471
00:20:20,880 --> 00:20:22,919
different bytes for different rounds for

472
00:20:22,919 --> 00:20:25,380
encryption or decryption like

473
00:20:25,380 --> 00:20:28,380
value Hemingway zero value all of that

474
00:20:28,380 --> 00:20:32,220
it took forever to compute that and the

475
00:20:32,220 --> 00:20:34,620
worst part is you don't know which model

476
00:20:34,620 --> 00:20:36,960
is the correct one and how many Traders

477
00:20:36,960 --> 00:20:38,280
you need to actually get something

478
00:20:38,280 --> 00:20:40,980
leading so

479
00:20:40,980 --> 00:20:45,059
I eventually gave up on that because SNR

480
00:20:45,059 --> 00:20:47,039
has actually some problems for practical

481
00:20:47,039 --> 00:20:47,880
attack

482
00:20:47,880 --> 00:20:51,299
SNR divides traces into groups and

483
00:20:51,299 --> 00:20:53,280
resources are always tight especially

484
00:20:53,280 --> 00:20:56,840
Ram or vram I was using a custom

485
00:20:56,840 --> 00:21:00,419
limitation so I was doing that on gpus

486
00:21:00,419 --> 00:21:03,120
you speed it up even more I processed

487
00:21:03,120 --> 00:21:06,179
more than 50 million traces with

488
00:21:06,179 --> 00:21:09,900
um 80 000 points per Trace

489
00:21:09,900 --> 00:21:12,179
um and yeah more grooves require more

490
00:21:12,179 --> 00:21:14,160
Computing resources so if I take like

491
00:21:14,160 --> 00:21:15,960
eight bit Heming weights I get nine

492
00:21:15,960 --> 00:21:18,299
groups that's okayish but if I try

493
00:21:18,299 --> 00:21:21,660
larger models 128 uh but Hemingway I get

494
00:21:21,660 --> 00:21:24,000
too many groups and this is not

495
00:21:24,000 --> 00:21:28,860
efficient to actually compute a so I had

496
00:21:28,860 --> 00:21:30,539
to try something else

497
00:21:30,539 --> 00:21:34,440
which got me to the CPA which is

498
00:21:34,440 --> 00:21:37,140
correlation power analysis um

499
00:21:37,140 --> 00:21:39,299
different statistical tools

500
00:21:39,299 --> 00:21:42,659
basically it works to use a power model

501
00:21:42,659 --> 00:21:44,520
to create

502
00:21:44,520 --> 00:21:46,860
a um

503
00:21:46,860 --> 00:21:51,539
models our Trace based on a value

504
00:21:51,539 --> 00:21:56,360
and then CPA tells you how similar your

505
00:21:56,360 --> 00:22:01,080
hypothetical model is to the real press

506
00:22:01,080 --> 00:22:02,820
um and it has a much lower footprint

507
00:22:02,820 --> 00:22:04,679
than SNR because you have just one

508
00:22:04,679 --> 00:22:07,860
single model Trace rather than x groups

509
00:22:07,860 --> 00:22:11,039
of real traces

510
00:22:11,039 --> 00:22:14,039
so CPA explained imagine you have the

511
00:22:14,039 --> 00:22:16,919
real trace on the left and you have

512
00:22:16,919 --> 00:22:20,760
Model A which is n model B

513
00:22:20,760 --> 00:22:23,940
and then you can get C then Model A the

514
00:22:23,940 --> 00:22:27,240
horse is uh much better correlating than

515
00:22:27,240 --> 00:22:30,380
the graph on the right

516
00:22:30,539 --> 00:22:34,380
so this is what we use for bi

517
00:22:34,380 --> 00:22:39,480
anyways so I tested several models with

518
00:22:39,480 --> 00:22:43,020
CPA with CPI could actually test 128

519
00:22:43,020 --> 00:22:45,659
bits models so I could uh basically do

520
00:22:45,659 --> 00:22:47,820
the hemming weight of the full stage

521
00:22:47,820 --> 00:22:50,159
because the full 128-bit register might

522
00:22:50,159 --> 00:22:52,140
be updated every round who knows and if

523
00:22:52,140 --> 00:22:54,960
so larger models will actually be better

524
00:22:54,960 --> 00:22:57,659
so I it has lots of things again for

525
00:22:57,659 --> 00:23:00,320
every round and eventually I was lucky

526
00:23:00,320 --> 00:23:03,000
and I found the leaking model

527
00:23:03,000 --> 00:23:05,400
so this is the model that I found

528
00:23:05,400 --> 00:23:09,000
and um I guess quick side note I was

529
00:23:09,000 --> 00:23:11,700
targeting a decryption but I will

530
00:23:11,700 --> 00:23:13,500
explain the model

531
00:23:13,500 --> 00:23:15,299
um on encryption so I was actually

532
00:23:15,299 --> 00:23:18,120
giving it some data and after I decrypt

533
00:23:18,120 --> 00:23:20,100
this and this is what I was measuring

534
00:23:20,100 --> 00:23:22,080
but I will for the sake of Simplicity

535
00:23:22,080 --> 00:23:25,919
this model is modeled on anchor machine

536
00:23:25,919 --> 00:23:29,280
so the leaking model is the Hamming

537
00:23:29,280 --> 00:23:32,159
distance between one state and the next

538
00:23:32,159 --> 00:23:35,880
stage like the full 128 bit distance

539
00:23:35,880 --> 00:23:38,880
so if we were to attack the first round

540
00:23:38,880 --> 00:23:42,000
of encryption or which I actually did as

541
00:23:42,000 --> 00:23:43,799
the last from decryption

542
00:23:43,799 --> 00:23:46,679
we take in the plain text you sir the

543
00:23:46,679 --> 00:23:49,740
key and then you exert that with the

544
00:23:49,740 --> 00:23:51,720
plain text with the key through the S

545
00:23:51,720 --> 00:23:54,900
Corps through the permutation layer

546
00:23:54,900 --> 00:23:57,179
and from that you take the orange and

547
00:23:57,179 --> 00:23:58,500
the eighth and Hemingway then this is

548
00:23:58,500 --> 00:24:00,360
what I used as a model and that actually

549
00:24:00,360 --> 00:24:02,340
worked

550
00:24:02,340 --> 00:24:04,440
by doing so

551
00:24:04,440 --> 00:24:05,159
um

552
00:24:05,159 --> 00:24:07,559
I could distinguish and we can see one

553
00:24:07,559 --> 00:24:09,960
peak in each round distinguishes

554
00:24:09,960 --> 00:24:11,340
significantly

555
00:24:11,340 --> 00:24:13,620
and this actually gives us even more

556
00:24:13,620 --> 00:24:15,900
information about this black box

557
00:24:15,900 --> 00:24:17,940
Hardware limitations that we didn't know

558
00:24:17,940 --> 00:24:19,020
anything about

559
00:24:19,020 --> 00:24:22,980
right so we know one round takes five

560
00:24:22,980 --> 00:24:25,200
nanoseconds we'll just take the distance

561
00:24:25,200 --> 00:24:27,179
between the two peaks

562
00:24:27,179 --> 00:24:32,220
14 Round of as takes uh 70 nanoseconds

563
00:24:32,220 --> 00:24:35,820
to process a full block of bias you need

564
00:24:35,820 --> 00:24:38,700
95 nanoseconds including also

565
00:24:38,700 --> 00:24:41,340
reprocessing whatever that is which I

566
00:24:41,340 --> 00:24:43,740
basically took by measuring round one or

567
00:24:43,740 --> 00:24:47,340
what the distance to block uh round one

568
00:24:47,340 --> 00:24:50,000
of block two

569
00:24:50,159 --> 00:24:53,340
so from here we can say okay let's

570
00:24:53,340 --> 00:24:54,780
assume

571
00:24:54,780 --> 00:24:58,140
um one round is computed in each clock

572
00:24:58,140 --> 00:25:00,059
cycle

573
00:25:00,059 --> 00:25:01,679
um which I do for the sake of Simplicity

574
00:25:01,679 --> 00:25:03,480
not that it really matters but that

575
00:25:03,480 --> 00:25:06,240
would uh um tell us that we have an as

576
00:25:06,240 --> 00:25:09,179
which is clocked at 200 megahertz

577
00:25:09,179 --> 00:25:12,179
okay nice

578
00:25:12,179 --> 00:25:14,820
and yeah we can even distinguish like

579
00:25:14,820 --> 00:25:17,220
full blocks here I um

580
00:25:17,220 --> 00:25:19,500
lots of the

581
00:25:19,500 --> 00:25:22,980
um leakage of each round in the same

582
00:25:22,980 --> 00:25:26,100
block and in the same color and then you

583
00:25:26,100 --> 00:25:28,020
can see you can also clearly distinguish

584
00:25:28,020 --> 00:25:32,220
the as blocks

585
00:25:32,340 --> 00:25:34,020
um and remember the the earlier picture

586
00:25:34,020 --> 00:25:35,820
where I said you can see the goals of

587
00:25:35,820 --> 00:25:38,760
the Christmas so if you put it on top

588
00:25:38,760 --> 00:25:41,279
this is actually where the AES actually

589
00:25:41,279 --> 00:25:44,580
is and if you see okay what signal do I

590
00:25:44,580 --> 00:25:46,679
actually see from the trace you don't

591
00:25:46,679 --> 00:25:48,600
see anything it's not like you can see

592
00:25:48,600 --> 00:25:50,640
Peaks or anything but there's just

593
00:25:50,640 --> 00:25:52,740
nothing

594
00:25:52,740 --> 00:25:56,340
so yeah but knowing like from that

595
00:25:56,340 --> 00:25:59,159
picture we can actually see so okay if I

596
00:25:59,159 --> 00:26:01,440
see that on my computer I just look for

597
00:26:01,440 --> 00:26:05,159
that peak in the scope for and then I

598
00:26:05,159 --> 00:26:07,260
know okay a little bit earlier and a

599
00:26:07,260 --> 00:26:09,779
little bit later there is a block of as

600
00:26:09,779 --> 00:26:11,520
which

601
00:26:11,520 --> 00:26:14,400
um is clearly like we estimate the

602
00:26:14,400 --> 00:26:17,580
locations of these based on the peak

603
00:26:17,580 --> 00:26:20,418
that we have

604
00:26:21,659 --> 00:26:23,400
next

605
00:26:23,400 --> 00:26:25,679
um well remember I said I put the probe

606
00:26:25,679 --> 00:26:27,720
just randomly by educated guessing right

607
00:26:27,720 --> 00:26:29,460
which doesn't really yield any good

608
00:26:29,460 --> 00:26:30,779
results but now that we have a leaking

609
00:26:30,779 --> 00:26:33,059
model we can actually do a full chip

610
00:26:33,059 --> 00:26:35,520
scan so I divided the chip in a grid of

611
00:26:35,520 --> 00:26:39,659
24 times 24 squares recorded traces on

612
00:26:39,659 --> 00:26:42,659
each position do the correlation which

613
00:26:42,659 --> 00:26:44,580
does require the working model this is

614
00:26:44,580 --> 00:26:46,620
why I couldn't do it earlier and then we

615
00:26:46,620 --> 00:26:51,120
find the optimal spot uh for the attack

616
00:26:51,120 --> 00:26:54,059
although I did run a few problems well

617
00:26:54,059 --> 00:26:56,760
very few traces can actually be recorded

618
00:26:56,760 --> 00:26:59,159
my major limitation was this space okay

619
00:26:59,159 --> 00:27:02,340
I said Okay I want the chips can to not

620
00:27:02,340 --> 00:27:04,740
contain more than that six terabytes of

621
00:27:04,740 --> 00:27:06,659
compressed Traces by the way this is

622
00:27:06,659 --> 00:27:09,659
about 80 compression rate

623
00:27:09,659 --> 00:27:14,220
which means I only could uh record 150

624
00:27:14,220 --> 00:27:17,279
000 traces with 40 000 Points each and

625
00:27:17,279 --> 00:27:19,200
only four blocks of as

626
00:27:19,200 --> 00:27:21,360
in contrast what I was doing before this

627
00:27:21,360 --> 00:27:24,299
100 million traces with 8 000 points and

628
00:27:24,299 --> 00:27:25,320
eight foreign

629
00:27:25,320 --> 00:27:28,500
so take these results with the with the

630
00:27:28,500 --> 00:27:30,659
grain of salt because it's only very

631
00:27:30,659 --> 00:27:32,400
orientation

632
00:27:32,400 --> 00:27:36,000
um so this is not too reliable but for

633
00:27:36,000 --> 00:27:37,860
me it was good enough

634
00:27:37,860 --> 00:27:40,380
um I could make this heat map of the

635
00:27:40,380 --> 00:27:43,080
actual how good it correlates

636
00:27:43,080 --> 00:27:44,880
um so we have two spots which seem

637
00:27:44,880 --> 00:27:47,400
really nice just randomly pick the one I

638
00:27:47,400 --> 00:27:49,740
marked in green which results to this

639
00:27:49,740 --> 00:27:51,980
exact position of the probe

640
00:27:51,980 --> 00:27:55,020
and this is what I used for my attack

641
00:27:55,020 --> 00:27:57,360
because remember so far we were working

642
00:27:57,360 --> 00:28:00,659
with a known custom Supply key but we

643
00:28:00,659 --> 00:28:02,220
actually want to

644
00:28:02,220 --> 00:28:04,380
um like the whole goal is to get the

645
00:28:04,380 --> 00:28:06,840
unknown key right

646
00:28:06,840 --> 00:28:09,240
also at this point we're working with

647
00:28:09,240 --> 00:28:11,940
the 128 with Hemingways which is not

648
00:28:11,940 --> 00:28:13,500
really practical for attack which

649
00:28:13,500 --> 00:28:15,240
because that will require you guessing a

650
00:28:15,240 --> 00:28:16,919
full stage

651
00:28:16,919 --> 00:28:18,120
okay yes

652
00:28:18,120 --> 00:28:19,860
so we actually need to test smaller

653
00:28:19,860 --> 00:28:21,659
models

654
00:28:21,659 --> 00:28:24,480
um which I did and luckily it worked

655
00:28:24,480 --> 00:28:27,419
um it leaks less well it still works so

656
00:28:27,419 --> 00:28:30,779
the one art um yeah test eight Hemingway

657
00:28:30,779 --> 00:28:33,480
eight core model record the decryption

658
00:28:33,480 --> 00:28:36,059
and then attack the last round of

659
00:28:36,059 --> 00:28:37,380
encryption

660
00:28:37,380 --> 00:28:39,480
um yeah here model the encryption this

661
00:28:39,480 --> 00:28:42,000
is the model that I use for the actual

662
00:28:42,000 --> 00:28:43,260
attack

663
00:28:43,260 --> 00:28:46,140
so basically uh I give the engine

664
00:28:46,140 --> 00:28:48,659
something it decrypts it I need that

665
00:28:48,659 --> 00:28:53,299
encryption on that decrypted value

666
00:28:54,000 --> 00:28:57,059
or the actual attack I record eight

667
00:28:57,059 --> 00:29:02,340
blocks of as 256 CBC decryption with

668
00:29:02,340 --> 00:29:06,240
random ciphertext I record 500 million

669
00:29:06,240 --> 00:29:11,820
traces which took me about a week

670
00:29:11,820 --> 00:29:14,880
um so transferring everything to uart is

671
00:29:14,880 --> 00:29:18,059
kind of slow so instead I would transfer

672
00:29:18,059 --> 00:29:19,679
and by the way I use the word for

673
00:29:19,679 --> 00:29:21,539
communication because the scope was a

674
00:29:21,539 --> 00:29:23,100
Windows machine and getting Uber to work

675
00:29:23,100 --> 00:29:25,260
was easier than the proprietary USB

676
00:29:25,260 --> 00:29:28,380
protocol and it had other advantages

677
00:29:28,380 --> 00:29:30,539
but basically

678
00:29:30,539 --> 00:29:34,559
um I sent over a seat which would then

679
00:29:34,559 --> 00:29:37,340
using a solid random number generator

680
00:29:37,340 --> 00:29:41,039
generates a batch of cyber text on the

681
00:29:41,039 --> 00:29:43,020
device which it would run through the

682
00:29:43,020 --> 00:29:45,240
AES engine where I could record the tray

683
00:29:45,240 --> 00:29:47,039
system because I have the seat and the

684
00:29:47,039 --> 00:29:50,340
same prng I could recreate those on the

685
00:29:50,340 --> 00:29:52,740
PC without having them to transfer

686
00:29:52,740 --> 00:29:55,919
although because I need for the attack

687
00:29:55,919 --> 00:29:58,080
um the actual decrypted values the

688
00:29:58,080 --> 00:30:00,419
processed values and the Second Step I

689
00:30:00,419 --> 00:30:03,000
needed to send them over all again and

690
00:30:03,000 --> 00:30:04,860
then have the device actually decrypt

691
00:30:04,860 --> 00:30:07,440
them and then store them to use them for

692
00:30:07,440 --> 00:30:08,360
the attack

693
00:30:08,360 --> 00:30:11,399
which then I used USB which is faster

694
00:30:11,399 --> 00:30:13,679
than you are but still encrypting

695
00:30:13,679 --> 00:30:16,200
everything also took me a week

696
00:30:16,200 --> 00:30:17,940
and then running the actual correlation

697
00:30:17,940 --> 00:30:20,520
on my custom GPU implementation also

698
00:30:20,520 --> 00:30:22,260
took me a week so this is about like

699
00:30:22,260 --> 00:30:25,520
three weeks for the full attack

700
00:30:25,860 --> 00:30:29,220
Okay so

701
00:30:29,220 --> 00:30:32,220
known key correlation we test with the

702
00:30:32,220 --> 00:30:34,620
known key with the 8-Bit handling

703
00:30:34,620 --> 00:30:36,600
um we estimate

704
00:30:36,600 --> 00:30:39,240
leaking point in time or the correct key

705
00:30:39,240 --> 00:30:40,380
bias

706
00:30:40,380 --> 00:30:44,340
and compare that with wrong key bytes

707
00:30:44,340 --> 00:30:47,159
right so for this is like over time with

708
00:30:47,159 --> 00:30:49,620
the correct key bytes and if we take

709
00:30:49,620 --> 00:30:53,940
that point in time and instead do other

710
00:30:53,940 --> 00:30:57,240
key bytes correlate over other keys you

711
00:30:57,240 --> 00:30:58,919
can see

712
00:30:58,919 --> 00:31:03,240
Target p is clearly visible so we do get

713
00:31:03,240 --> 00:31:06,899
a good correlation and we can

714
00:31:06,899 --> 00:31:10,620
successfully recover the key

715
00:31:10,620 --> 00:31:14,220
so the big question is how many key how

716
00:31:14,220 --> 00:31:17,159
many traces are actually needed because

717
00:31:17,159 --> 00:31:20,520
I said okay we 10 million traces 100

718
00:31:20,520 --> 00:31:23,159
million trades is 500 militarizes

719
00:31:23,159 --> 00:31:25,020
the truth is

720
00:31:25,020 --> 00:31:27,659
um it varies a lot

721
00:31:27,659 --> 00:31:30,360
if you get lucky then you can recover

722
00:31:30,360 --> 00:31:33,659
some key bites with as little as 30

723
00:31:33,659 --> 00:31:36,419
million traces so you can see this is

724
00:31:36,419 --> 00:31:39,779
like extremely good leakage

725
00:31:39,779 --> 00:31:42,720
um if you're not so lucky some bites

726
00:31:42,720 --> 00:31:46,559
will need 300 million traces

727
00:31:46,559 --> 00:31:49,260
um to be recovered

728
00:31:49,260 --> 00:31:52,200
here are two more examples and you can

729
00:31:52,200 --> 00:31:54,419
see okay the top one we got lucky again

730
00:31:54,419 --> 00:31:57,600
we don't need a lot and the bottom one

731
00:31:57,600 --> 00:31:59,520
we need like

732
00:31:59,520 --> 00:32:02,279
uh 300 million again to get that

733
00:32:02,279 --> 00:32:04,320
reliably

734
00:32:04,320 --> 00:32:07,740
although there are other strategies than

735
00:32:07,740 --> 00:32:10,860
just recording um more traces because

736
00:32:10,860 --> 00:32:13,620
well storage is a problem eventually

737
00:32:13,620 --> 00:32:16,140
like even if you have a large mass like

738
00:32:16,140 --> 00:32:18,659
one of that recordings takes me like six

739
00:32:18,659 --> 00:32:21,659
terabytes and for testing I had to do

740
00:32:21,659 --> 00:32:23,880
multiple recordings then delete some and

741
00:32:23,880 --> 00:32:26,039
then try again and so on so storage is a

742
00:32:26,039 --> 00:32:27,539
big issue

743
00:32:27,539 --> 00:32:29,820
well what else you can do is you can

744
00:32:29,820 --> 00:32:33,020
check uh nearby points in time

745
00:32:33,020 --> 00:32:36,240
basically if you look at this and then I

746
00:32:36,240 --> 00:32:39,679
go forward a Time

747
00:32:43,200 --> 00:32:45,480
so you can see it's likely this one and

748
00:32:45,480 --> 00:32:47,659
not the one which was highest first

749
00:32:47,659 --> 00:32:52,080
right so if we won like a

750
00:32:52,080 --> 00:32:55,140
time step before and after is also very

751
00:32:55,140 --> 00:32:57,899
good leaking then it's likely that one

752
00:32:57,899 --> 00:33:00,179
rather than like a random noise which is

753
00:33:00,179 --> 00:33:02,039
there in one frame but it's gone in the

754
00:33:02,039 --> 00:33:03,720
other fret

755
00:33:03,720 --> 00:33:05,700
well the other obvious thing to do is

756
00:33:05,700 --> 00:33:08,039
well remember I was

757
00:33:08,039 --> 00:33:08,580
um

758
00:33:08,580 --> 00:33:11,279
using eight blocks of CBC or you can

759
00:33:11,279 --> 00:33:13,740
just use a different block right so if

760
00:33:13,740 --> 00:33:16,740
one key by it on a specific block isn't

761
00:33:16,740 --> 00:33:19,320
leaking very well uh you have still the

762
00:33:19,320 --> 00:33:22,679
traces and just targets that key byte on

763
00:33:22,679 --> 00:33:24,299
a different encryption block and that

764
00:33:24,299 --> 00:33:26,220
might work better and since I recorded

765
00:33:26,220 --> 00:33:28,080
eight blocks anyway

766
00:33:28,080 --> 00:33:31,440
um this was uh viable strategy and

767
00:33:31,440 --> 00:33:33,360
actually the one that we see before here

768
00:33:33,360 --> 00:33:36,299
which is very noisy on the different

769
00:33:36,299 --> 00:33:38,519
block that key byte actually had a very

770
00:33:38,519 --> 00:33:39,779
good leakage

771
00:33:39,779 --> 00:33:41,880
is extractable

772
00:33:41,880 --> 00:33:46,860
so now the fun part do we actually get

773
00:33:46,860 --> 00:33:48,659
the key

774
00:33:48,659 --> 00:33:51,799
no but you can get the hash

775
00:33:51,799 --> 00:33:55,019
so if you get the key and hash it this

776
00:33:55,019 --> 00:33:57,140
is

777
00:33:59,940 --> 00:34:03,539
what can we do with the the

778
00:34:03,539 --> 00:34:07,380
um extracted git Key Well we can decrypt

779
00:34:07,380 --> 00:34:10,020
firmware without the actual device I

780
00:34:10,020 --> 00:34:11,899
tested that by downloading the firmware

781
00:34:11,899 --> 00:34:16,379
and scripting the key back which is uh

782
00:34:16,379 --> 00:34:20,460
Keys encrypted by the git key

783
00:34:20,460 --> 00:34:23,940
and compare that to what is written on

784
00:34:23,940 --> 00:34:26,040
the iPhone we can see okay that's the

785
00:34:26,040 --> 00:34:28,080
same result I get with my open SSL

786
00:34:28,080 --> 00:34:29,639
script

787
00:34:29,639 --> 00:34:32,219
um and yeah so we can see it works well

788
00:34:32,219 --> 00:34:35,000
what else can we do we can recover the

789
00:34:35,000 --> 00:34:37,560
uid key

790
00:34:37,560 --> 00:34:40,739
I actually wrote a custom implementation

791
00:34:40,739 --> 00:34:45,179
to cracking the user passcode on the um

792
00:34:45,179 --> 00:34:49,080
on gpus now that we have the uid we can

793
00:34:49,080 --> 00:34:51,060
do that but

794
00:34:51,060 --> 00:34:54,418
um I suck at GPU programming so instead

795
00:34:54,418 --> 00:34:56,940
of taking my implementation actually a

796
00:34:56,940 --> 00:34:59,760
friend over at hashcad implemented that

797
00:34:59,760 --> 00:35:03,180
so you can use hashcat to crack iPhone

798
00:35:03,180 --> 00:35:06,780
pins well even you have extracted

799
00:35:06,780 --> 00:35:10,680
and we can see that a 12 digit numeric

800
00:35:10,680 --> 00:35:13,079
passcode according to the Apple white

801
00:35:13,079 --> 00:35:16,200
paper where we assume that one attempt

802
00:35:16,200 --> 00:35:20,220
takes 80 milliseconds that would take

803
00:35:20,220 --> 00:35:21,440
um

804
00:35:21,440 --> 00:35:23,339
2536 years

805
00:35:23,339 --> 00:35:25,800
while if you take three weeks to extract

806
00:35:25,800 --> 00:35:29,940
the uid key and then throw in AIDS Vega

807
00:35:29,940 --> 00:35:33,900
64 gpus uh you can get that as fast as

808
00:35:33,900 --> 00:35:36,800
23 days

809
00:35:36,800 --> 00:35:39,240
so yeah

810
00:35:39,240 --> 00:35:40,320
well

811
00:35:40,320 --> 00:35:42,180
that was it

812
00:35:42,180 --> 00:35:45,618
now it's time for some questions

813
00:35:49,020 --> 00:35:51,300
thanks teamstar

814
00:35:51,300 --> 00:35:52,740
so

815
00:35:52,740 --> 00:35:55,800
we will have yes of course just one

816
00:35:55,800 --> 00:35:59,359
second coming to you

817
00:36:01,800 --> 00:36:04,280
all right

818
00:36:04,280 --> 00:36:08,119
thank you for our presentations

819
00:36:08,880 --> 00:36:11,339
the question is that do you find the

820
00:36:11,339 --> 00:36:12,720
power linkage

821
00:36:12,720 --> 00:36:15,020
is

822
00:36:16,980 --> 00:36:20,820
so actually a colleague tried that a BG

823
00:36:20,820 --> 00:36:22,820
student at University tried that

824
00:36:22,820 --> 00:36:27,300
the problem was that I could do good

825
00:36:27,300 --> 00:36:30,300
alignments on the EM traces while on the

826
00:36:30,300 --> 00:36:32,460
power traces you couldn't like realign

827
00:36:32,460 --> 00:36:36,060
them so you had to run the attack on

828
00:36:36,060 --> 00:36:39,180
underlying traces which again are very

829
00:36:39,180 --> 00:36:43,140
jittery and because of that he needed to

830
00:36:43,140 --> 00:36:43,920
use

831
00:36:43,920 --> 00:36:46,380
roughly the same amount of traces so

832
00:36:46,380 --> 00:36:48,839
it's possible with both em and power

833
00:36:48,839 --> 00:36:52,020
traces but due to the alignment problem

834
00:36:52,020 --> 00:36:55,380
the power isn't better than the

835
00:36:55,380 --> 00:36:57,380
um

836
00:37:01,370 --> 00:37:04,449
[Music]

837
00:37:08,579 --> 00:37:11,040
it's a black box nobody knows it's just

838
00:37:11,040 --> 00:37:12,960
it's not something that's documented

839
00:37:12,960 --> 00:37:15,300
like none of this is documented you can

840
00:37:15,300 --> 00:37:18,000
reverse engineer the bootloader to

841
00:37:18,000 --> 00:37:20,060
figure out how to talk to the hardware

842
00:37:20,060 --> 00:37:22,500
but no idea how it's actually

843
00:37:22,500 --> 00:37:25,079
implemented so from the side Channel I

844
00:37:25,079 --> 00:37:29,820
like build a model which I think is how

845
00:37:29,820 --> 00:37:31,980
it works but no idea if it actually

846
00:37:31,980 --> 00:37:34,700
works like that

847
00:37:35,220 --> 00:37:37,560
thank you any other questions from the

848
00:37:37,560 --> 00:37:39,740
audience

849
00:37:40,140 --> 00:37:42,859
yes

850
00:37:53,579 --> 00:37:56,520
thank you for presentation and I have a

851
00:37:56,520 --> 00:37:59,099
question suggestions uh have you tried

852
00:37:59,099 --> 00:38:00,980
to use another

853
00:38:00,980 --> 00:38:04,079
statistical distinguisher rather than

854
00:38:04,079 --> 00:38:07,020
correlation for instance a linear

855
00:38:07,020 --> 00:38:08,640
regression analysis

856
00:38:08,640 --> 00:38:10,800
where you could you know

857
00:38:10,800 --> 00:38:12,960
um consider that the leaking model is

858
00:38:12,960 --> 00:38:14,280
not I mean white but it's something

859
00:38:14,280 --> 00:38:17,280
where the bits leak kind of differently

860
00:38:17,280 --> 00:38:19,859
uh each others and then perhaps decrease

861
00:38:19,859 --> 00:38:22,520
the number of total traces you need

862
00:38:22,520 --> 00:38:27,000
no for two reasons a

863
00:38:27,000 --> 00:38:29,640
um I have actually no clue about how

864
00:38:29,640 --> 00:38:32,880
these statistical things work and B this

865
00:38:32,880 --> 00:38:36,480
was a project for my Master's thesis and

866
00:38:36,480 --> 00:38:38,820
I had a limited time once I got the

867
00:38:38,820 --> 00:38:41,700
leaking model I just used that so it's

868
00:38:41,700 --> 00:38:44,160
not like I had unlimited time with the

869
00:38:44,160 --> 00:38:46,260
university lab equipment where I could

870
00:38:46,260 --> 00:38:48,780
just like do what I want like if I had

871
00:38:48,780 --> 00:38:50,579
still access I'd probably try to do the

872
00:38:50,579 --> 00:38:54,320
newer phones but I don't have access

873
00:38:54,960 --> 00:38:56,460
thanks

874
00:38:56,460 --> 00:39:01,200
and the last question anyone

875
00:39:04,260 --> 00:39:07,680
okay then uh a round of applause to team

876
00:39:07,680 --> 00:39:09,420
star

877
00:39:09,420 --> 00:39:11,900
thanks

