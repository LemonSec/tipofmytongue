1
00:00:02,879 --> 00:00:04,880
all right thanks very much i know it's

2
00:00:04,880 --> 00:00:06,560
right before lunch but i promise this

3
00:00:06,560 --> 00:00:08,000
one's gonna be exciting

4
00:00:08,000 --> 00:00:09,679
uh this is

5
00:00:09,679 --> 00:00:11,280
kind of a project i've been working on

6
00:00:11,280 --> 00:00:13,599
for a little while about sort of fun

7
00:00:13,599 --> 00:00:17,440
with caches and side channel stuff

8
00:00:17,440 --> 00:00:18,960
and i've been kind of taking my time

9
00:00:18,960 --> 00:00:20,880
with it and you know what happens when

10
00:00:20,880 --> 00:00:22,720
you do that is you know turns out other

11
00:00:22,720 --> 00:00:24,240
people have the same great idea that you

12
00:00:24,240 --> 00:00:25,199
do

13
00:00:25,199 --> 00:00:26,960
and so i actually found out fairly

14
00:00:26,960 --> 00:00:30,560
recently that a team out of uh tel aviv

15
00:00:30,560 --> 00:00:31,920
university and the university of

16
00:00:31,920 --> 00:00:34,480
adelaide uh came up with a very similar

17
00:00:34,480 --> 00:00:36,399
technique that what i'm presenting here

18
00:00:36,399 --> 00:00:38,160
but they had a much better name for it

19
00:00:38,160 --> 00:00:40,000
than i did

20
00:00:40,000 --> 00:00:42,160
their paper is under submission i'm in

21
00:00:42,160 --> 00:00:44,320
contact with them we're working together

22
00:00:44,320 --> 00:00:45,280
now

23
00:00:45,280 --> 00:00:47,840
so if you like what you see here keep an

24
00:00:47,840 --> 00:00:49,520
eye out for their paper

25
00:00:49,520 --> 00:00:52,399
they're a better writer than i am

26
00:00:52,399 --> 00:00:53,600
all right so

27
00:00:53,600 --> 00:00:55,680
today i'm going to be talking about

28
00:00:55,680 --> 00:00:57,840
cash side channels but kind of a

29
00:00:57,840 --> 00:00:59,680
different aspect than

30
00:00:59,680 --> 00:01:01,199
is usually presented at these type of

31
00:01:01,199 --> 00:01:02,320
things

32
00:01:02,320 --> 00:01:03,920
if we think about

33
00:01:03,920 --> 00:01:06,240
basically any cash side channel at a 10

34
00:01:06,240 --> 00:01:08,640
000 foot level it has three general

35
00:01:08,640 --> 00:01:11,119
phases so first off there's a setup

36
00:01:11,119 --> 00:01:13,920
phase where the attacker is going to put

37
00:01:13,920 --> 00:01:15,840
some parts of the cache into a known

38
00:01:15,840 --> 00:01:17,920
state either evicting some lines or

39
00:01:17,920 --> 00:01:19,520
bringing in some lines

40
00:01:19,520 --> 00:01:21,600
it's then you're then going to let the

41
00:01:21,600 --> 00:01:23,439
victim code run which is going to

42
00:01:23,439 --> 00:01:25,920
perturb the cache in some way and then

43
00:01:25,920 --> 00:01:28,479
there's this recovery phase where you're

44
00:01:28,479 --> 00:01:30,400
trying to figure out what happened to

45
00:01:30,400 --> 00:01:31,759
the cash

46
00:01:31,759 --> 00:01:33,520
and for this talk we're going to be

47
00:01:33,520 --> 00:01:35,119
focusing on that recovery phase

48
00:01:35,119 --> 00:01:37,200
exclusively which also means that the

49
00:01:37,200 --> 00:01:39,439
stuff here kind of applies to pretty

50
00:01:39,439 --> 00:01:41,280
much any

51
00:01:41,280 --> 00:01:44,560
cache side channel tech you want to do

52
00:01:44,560 --> 00:01:45,280
so

53
00:01:45,280 --> 00:01:48,000
when it comes to the recovery phase

54
00:01:48,000 --> 00:01:49,600
i call this reading the signal because

55
00:01:49,600 --> 00:01:51,840
the idea is you've got a cache line that

56
00:01:51,840 --> 00:01:53,439
may be present or not present and you

57
00:01:53,439 --> 00:01:54,960
want to figure out

58
00:01:54,960 --> 00:01:56,399
what the state is

59
00:01:56,399 --> 00:01:58,159
and typically this is pretty

60
00:01:58,159 --> 00:01:59,920
straightforward you use a high precision

61
00:01:59,920 --> 00:02:02,320
timer which in x86 we like the cpu

62
00:02:02,320 --> 00:02:04,240
timestamp counter

63
00:02:04,240 --> 00:02:05,840
and we just time how long it takes to

64
00:02:05,840 --> 00:02:07,439
access the line if the line's in the

65
00:02:07,439 --> 00:02:09,679
cache cpu gets the data quickly if

66
00:02:09,679 --> 00:02:11,120
line's not in the cache it takes a while

67
00:02:11,120 --> 00:02:13,440
going out to dram and then what that

68
00:02:13,440 --> 00:02:15,520
means the state of that cache line

69
00:02:15,520 --> 00:02:16,720
that's going to be dependent on your

70
00:02:16,720 --> 00:02:18,480
specific attack so if you're doing a

71
00:02:18,480 --> 00:02:20,080
flush and reload attack you're looking

72
00:02:20,080 --> 00:02:22,000
to see if a line is present if you're

73
00:02:22,000 --> 00:02:23,200
doing a prime and probe you're looking

74
00:02:23,200 --> 00:02:25,040
to see a line is not present and then

75
00:02:25,040 --> 00:02:26,640
you'll interpret that in the context of

76
00:02:26,640 --> 00:02:29,200
your overall attack

77
00:02:29,200 --> 00:02:30,800
so

78
00:02:30,800 --> 00:02:32,720
some questions to pose

79
00:02:32,720 --> 00:02:34,239
you know do we really need a high

80
00:02:34,239 --> 00:02:36,480
precision timer to check the status of a

81
00:02:36,480 --> 00:02:39,120
cache line or do we at least need a

82
00:02:39,120 --> 00:02:42,000
somewhat high precision timer

83
00:02:42,000 --> 00:02:44,160
and then my favorite is if we've got a

84
00:02:44,160 --> 00:02:45,680
bunch of cache lines do we actually have

85
00:02:45,680 --> 00:02:47,760
to check each of them in order to

86
00:02:47,760 --> 00:02:49,840
determine their state and of course the

87
00:02:49,840 --> 00:02:51,360
answer all these is no because that's

88
00:02:51,360 --> 00:02:54,480
why i'm up here talking

89
00:02:54,560 --> 00:02:56,720
so before i go into exactly how we're

90
00:02:56,720 --> 00:02:58,480
going to do this let me first start with

91
00:02:58,480 --> 00:03:02,159
some basic primitives and

92
00:03:02,159 --> 00:03:03,519
we're going to look at the code here

93
00:03:03,519 --> 00:03:04,879
which is very simple code but we're

94
00:03:04,879 --> 00:03:06,159
going to look at it under a very

95
00:03:06,159 --> 00:03:08,560
specific set of circumstances

96
00:03:08,560 --> 00:03:10,000
so in particular we've got these two

97
00:03:10,000 --> 00:03:12,080
cache lines and we're going to assume

98
00:03:12,080 --> 00:03:14,000
that the state of the first cache line a

99
00:03:14,000 --> 00:03:15,200
is unknown

100
00:03:15,200 --> 00:03:16,879
but we know the cache line b is not

101
00:03:16,879 --> 00:03:18,480
present

102
00:03:18,480 --> 00:03:20,560
we also know that the memory

103
00:03:20,560 --> 00:03:22,800
at address a is zero meaning that this

104
00:03:22,800 --> 00:03:26,480
branch is not going to be taken

105
00:03:26,560 --> 00:03:27,760
however

106
00:03:27,760 --> 00:03:29,200
we're going to assume that the cpu

107
00:03:29,200 --> 00:03:30,720
mispredicts the branch and thinks that

108
00:03:30,720 --> 00:03:32,720
it is taken

109
00:03:32,720 --> 00:03:35,680
and the key insight behind this work is

110
00:03:35,680 --> 00:03:37,840
the fact that the amount of time that it

111
00:03:37,840 --> 00:03:39,920
takes the cpu to correct itself when it

112
00:03:39,920 --> 00:03:42,159
mispredicted the branch depends on how

113
00:03:42,159 --> 00:03:45,280
long it took to access that cache line a

114
00:03:45,280 --> 00:03:47,519
if it took a short amount of time

115
00:03:47,519 --> 00:03:49,200
because the line was present

116
00:03:49,200 --> 00:03:50,159
then

117
00:03:50,159 --> 00:03:51,760
it is not going to have time to fetch

118
00:03:51,760 --> 00:03:53,280
cache line b

119
00:03:53,280 --> 00:03:55,040
if initially the cache line was not

120
00:03:55,040 --> 00:03:57,280
present speculation goes on for a long

121
00:03:57,280 --> 00:04:00,799
time we do fetch cache line b

122
00:04:00,799 --> 00:04:03,760
and the result here is that the state of

123
00:04:03,760 --> 00:04:06,080
cache line b is set to the inverse of

124
00:04:06,080 --> 00:04:08,159
the state of cache line a even though we

125
00:04:08,159 --> 00:04:09,680
didn't actually have to do a timing

126
00:04:09,680 --> 00:04:13,040
measurement on cache line a

127
00:04:13,040 --> 00:04:14,400
so that's the basic thing then we're

128
00:04:14,400 --> 00:04:16,079
going to go from there

129
00:04:16,079 --> 00:04:18,160
so first off how do we build this

130
00:04:18,160 --> 00:04:19,358
reliably

131
00:04:19,358 --> 00:04:21,358
uh and i'm a hardware guy so i tend to

132
00:04:21,358 --> 00:04:23,040
go towards assembly and you get to do

133
00:04:23,040 --> 00:04:24,560
some tricks with assembly that you might

134
00:04:24,560 --> 00:04:27,120
not get to do and see

135
00:04:27,120 --> 00:04:28,960
and this is one of my favorite which is

136
00:04:28,960 --> 00:04:31,440
a forced misprediction

137
00:04:31,440 --> 00:04:33,280
so the way this code works and don't

138
00:04:33,280 --> 00:04:34,960
worry if you're not big into x86

139
00:04:34,960 --> 00:04:36,320
assembly

140
00:04:36,320 --> 00:04:37,280
is that

141
00:04:37,280 --> 00:04:39,520
we are going to do a call instruction to

142
00:04:39,520 --> 00:04:41,040
label three

143
00:04:41,040 --> 00:04:42,880
and then we're going to overwrite the

144
00:04:42,880 --> 00:04:44,960
return address on the stack and this

145
00:04:44,960 --> 00:04:46,560
takes advantage of the fact that in

146
00:04:46,560 --> 00:04:49,440
pretty much every modern cpu regardless

147
00:04:49,440 --> 00:04:50,720
of vendor

148
00:04:50,720 --> 00:04:52,400
return instructions are always predicted

149
00:04:52,400 --> 00:04:54,840
to where your previous call instruction

150
00:04:54,840 --> 00:04:57,840
was and so we're going to leverage that

151
00:04:57,840 --> 00:04:59,440
so we're going to overwrite the return

152
00:04:59,440 --> 00:05:01,680
address on the stack to be labeled 4 so

153
00:05:01,680 --> 00:05:03,840
we will in fact architecturally go to

154
00:05:03,840 --> 00:05:05,440
label 4

155
00:05:05,440 --> 00:05:07,840
but when we speculate we actually are

156
00:05:07,840 --> 00:05:10,320
going to go back up here to label two

157
00:05:10,320 --> 00:05:13,440
and execute the instructions there

158
00:05:13,440 --> 00:05:15,759
the great thing is that this works every

159
00:05:15,759 --> 00:05:19,039
single time the cpu never learns that

160
00:05:19,039 --> 00:05:20,479
this thing is always getting

161
00:05:20,479 --> 00:05:24,919
mispredicted so it's great

162
00:05:24,960 --> 00:05:26,240
all right so

163
00:05:26,240 --> 00:05:28,560
let's look at the full code for the

164
00:05:28,560 --> 00:05:30,000
inverter

165
00:05:30,000 --> 00:05:31,680
we're going to use that gadget we just

166
00:05:31,680 --> 00:05:32,880
showed

167
00:05:32,880 --> 00:05:35,680
and overwrite that return address

168
00:05:35,680 --> 00:05:37,440
and then

169
00:05:37,440 --> 00:05:39,759
we are going to read cache line a which

170
00:05:39,759 --> 00:05:43,120
we're going to assume is an rsi

171
00:05:43,280 --> 00:05:44,960
we take the result of that which we said

172
00:05:44,960 --> 00:05:46,320
was zero

173
00:05:46,320 --> 00:05:47,840
result the values on the cache lines

174
00:05:47,840 --> 00:05:50,320
don't really matter for this top

175
00:05:50,320 --> 00:05:52,560
we're going to add that value

176
00:05:52,560 --> 00:05:54,080
to the address that's at the top of the

177
00:05:54,080 --> 00:05:55,840
stack it doesn't change it but it

178
00:05:55,840 --> 00:05:59,198
creates a data dependency

179
00:06:00,319 --> 00:06:02,160
when that return instruction

180
00:06:02,160 --> 00:06:03,919
misspeculates we're going to go up to

181
00:06:03,919 --> 00:06:05,440
the red code here which is in red

182
00:06:05,440 --> 00:06:07,600
because it's never actually executed for

183
00:06:07,600 --> 00:06:09,680
real

184
00:06:09,680 --> 00:06:11,840
the first thing is there are some delay

185
00:06:11,840 --> 00:06:14,000
ops in here and this gives the cpu

186
00:06:14,000 --> 00:06:17,199
pipeline time to correct itself

187
00:06:17,199 --> 00:06:21,840
if that initial cache line a was present

188
00:06:22,080 --> 00:06:23,919
if that cache line was not present the

189
00:06:23,919 --> 00:06:25,600
return instruction's taken a long time

190
00:06:25,600 --> 00:06:26,880
to execute

191
00:06:26,880 --> 00:06:28,880
we're going to eventually get to this

192
00:06:28,880 --> 00:06:33,120
load here and we'll read cache line b

193
00:06:33,919 --> 00:06:35,600
another way of looking at is with this

194
00:06:35,600 --> 00:06:38,400
grossly oversimplified pipeline diagram

195
00:06:38,400 --> 00:06:39,199
so

196
00:06:39,199 --> 00:06:42,080
the top case is where the

197
00:06:42,080 --> 00:06:44,639
cache line a was present

198
00:06:44,639 --> 00:06:46,319
and as you see the ops are able to

199
00:06:46,319 --> 00:06:48,160
execute back to back as soon as the

200
00:06:48,160 --> 00:06:50,479
return instruction executes we flush the

201
00:06:50,479 --> 00:06:52,319
pipeline and we never get to the fetch

202
00:06:52,319 --> 00:06:54,319
of instruction b

203
00:06:54,319 --> 00:06:56,479
in the bottom case

204
00:06:56,479 --> 00:06:58,319
as you notice there is a data dependency

205
00:06:58,319 --> 00:07:01,280
so the load takes a long time the ad has

206
00:07:01,280 --> 00:07:03,280
to wait the return has to wait

207
00:07:03,280 --> 00:07:05,120
but the fetch of the delay ops and cache

208
00:07:05,120 --> 00:07:07,680
line b is independent of that and so we

209
00:07:07,680 --> 00:07:09,039
take advantage of the out of order

210
00:07:09,039 --> 00:07:12,720
execution of cpu and it's able to fetch

211
00:07:12,720 --> 00:07:14,319
cache line b

212
00:07:14,319 --> 00:07:16,800
so hopefully that's making sense good

213
00:07:16,800 --> 00:07:19,039
all right

214
00:07:19,680 --> 00:07:21,759
so now i'm going to take that same code

215
00:07:21,759 --> 00:07:23,360
i'm going to add one more instruction

216
00:07:23,360 --> 00:07:24,960
which is what's shown in green right

217
00:07:24,960 --> 00:07:26,000
here

218
00:07:26,000 --> 00:07:27,680
and this this time we got two cache

219
00:07:27,680 --> 00:07:29,599
lines so we got the one on rsi we got

220
00:07:29,599 --> 00:07:31,039
one in rdx

221
00:07:31,039 --> 00:07:33,120
and notice that there's a dependency

222
00:07:33,120 --> 00:07:34,400
here so

223
00:07:34,400 --> 00:07:36,000
we are taking the result of the second

224
00:07:36,000 --> 00:07:38,160
cache line and we are adding it to the

225
00:07:38,160 --> 00:07:41,520
result we got from the first

226
00:07:41,520 --> 00:07:43,280
if both of these cache lines are not

227
00:07:43,280 --> 00:07:44,400
present

228
00:07:44,400 --> 00:07:45,919
then the speculation is going to go on

229
00:07:45,919 --> 00:07:47,039
for a while

230
00:07:47,039 --> 00:07:48,720
we bring cache line b

231
00:07:48,720 --> 00:07:50,720
the same happens if either one of the

232
00:07:50,720 --> 00:07:52,240
the cache lines is not present because

233
00:07:52,240 --> 00:07:54,240
we got to wait for both

234
00:07:54,240 --> 00:07:56,160
if they're both present

235
00:07:56,160 --> 00:07:58,400
then we execute the return quickly

236
00:07:58,400 --> 00:07:59,360
and

237
00:07:59,360 --> 00:08:02,319
we don't have cache line b

238
00:08:02,319 --> 00:08:03,759
so we've kind of just created a nand

239
00:08:03,759 --> 00:08:04,720
gate

240
00:08:04,720 --> 00:08:07,039
so that's kind of fun

241
00:08:07,039 --> 00:08:09,440
so what else can we do

242
00:08:09,440 --> 00:08:11,680
uh quite a number of things

243
00:08:11,680 --> 00:08:13,120
one of the

244
00:08:13,120 --> 00:08:14,240
gadgets that we're going to use quite a

245
00:08:14,240 --> 00:08:15,759
bit in this talk is what i call

246
00:08:15,759 --> 00:08:18,639
replicator this is basically an inverter

247
00:08:18,639 --> 00:08:20,720
with multiple outputs so instead of

248
00:08:20,720 --> 00:08:22,720
having one cache line b we could have b

249
00:08:22,720 --> 00:08:24,720
c and d et cetera

250
00:08:24,720 --> 00:08:26,400
so this is great for copying the state

251
00:08:26,400 --> 00:08:28,400
of cache lines

252
00:08:28,400 --> 00:08:30,479
you can build a nor gadget it's a little

253
00:08:30,479 --> 00:08:31,840
bit trickier

254
00:08:31,840 --> 00:08:33,039
i would encourage anyone who's

255
00:08:33,039 --> 00:08:35,120
interested to try and unavailable for

256
00:08:35,120 --> 00:08:36,799
questions

257
00:08:36,799 --> 00:08:38,640
you can also kind of trivially just

258
00:08:38,640 --> 00:08:40,240
expand these out to more inputs right we

259
00:08:40,240 --> 00:08:41,760
just showed it to input nand you can do

260
00:08:41,760 --> 00:08:43,279
a four input nand whatever you need to

261
00:08:43,279 --> 00:08:45,040
do

262
00:08:45,040 --> 00:08:46,640
you may ask about why i'm always

263
00:08:46,640 --> 00:08:48,399
assuming things have a value of zero

264
00:08:48,399 --> 00:08:50,240
that's because when you're doing a cache

265
00:08:50,240 --> 00:08:53,120
side channel you control the data

266
00:08:53,120 --> 00:08:54,399
right you're just looking to see what

267
00:08:54,399 --> 00:08:56,880
the victim has done to the cache whether

268
00:08:56,880 --> 00:08:58,240
they have

269
00:08:58,240 --> 00:09:00,080
you know touch cache lines or evicted

270
00:09:00,080 --> 00:09:01,200
cache lines

271
00:09:01,200 --> 00:09:02,959
so just a simplifier thing we can assume

272
00:09:02,959 --> 00:09:07,399
that everything has a value of zero

273
00:09:08,320 --> 00:09:09,600
all right so let's talk about

274
00:09:09,600 --> 00:09:12,399
amplification

275
00:09:12,720 --> 00:09:13,440
so

276
00:09:13,440 --> 00:09:14,959
the problem statement here is we've got

277
00:09:14,959 --> 00:09:16,720
this one cache line we want to know the

278
00:09:16,720 --> 00:09:17,760
state of it

279
00:09:17,760 --> 00:09:20,080
but we don't have a high precision timer

280
00:09:20,080 --> 00:09:22,880
so how are we going to figure it out

281
00:09:22,880 --> 00:09:23,760
and

282
00:09:23,760 --> 00:09:25,680
in all the techniques i'm going to show

283
00:09:25,680 --> 00:09:27,440
the idea is that we're start with that

284
00:09:27,440 --> 00:09:29,600
cache line we're going to run some code

285
00:09:29,600 --> 00:09:30,640
and we're going to do a timing

286
00:09:30,640 --> 00:09:31,760
measurement

287
00:09:31,760 --> 00:09:33,920
and if the cache line was present we're

288
00:09:33,920 --> 00:09:35,519
going to get one result which was not

289
00:09:35,519 --> 00:09:36,959
present we get a second result we want

290
00:09:36,959 --> 00:09:40,080
the difference to be as big as possible

291
00:09:40,080 --> 00:09:41,200
in the

292
00:09:41,200 --> 00:09:43,200
kind of naive straightforward code i

293
00:09:43,200 --> 00:09:44,720
showed before

294
00:09:44,720 --> 00:09:46,000
we have a signal strength of a little

295
00:09:46,000 --> 00:09:51,080
over 200 cycles not not great

296
00:09:52,160 --> 00:09:53,040
so

297
00:09:53,040 --> 00:09:55,279
the first building block here

298
00:09:55,279 --> 00:09:57,920
is the single stage amplifier

299
00:09:57,920 --> 00:10:01,440
and this has two parts the first is that

300
00:10:01,440 --> 00:10:03,279
replicator gadget i mentioned earlier

301
00:10:03,279 --> 00:10:04,399
where we're going to take the first

302
00:10:04,399 --> 00:10:05,680
cache line we're going to make a bunch

303
00:10:05,680 --> 00:10:07,519
of copies of the inverse

304
00:10:07,519 --> 00:10:09,920
of that cache line

305
00:10:09,920 --> 00:10:10,720
and

306
00:10:10,720 --> 00:10:12,240
because of the way that works those are

307
00:10:12,240 --> 00:10:14,720
all we fetched in parallel

308
00:10:14,720 --> 00:10:15,839
and then we're going to do a timing

309
00:10:15,839 --> 00:10:17,680
measurement where we access all them

310
00:10:17,680 --> 00:10:19,600
sequentially and we

311
00:10:19,600 --> 00:10:21,120
do this by just exporting data

312
00:10:21,120 --> 00:10:23,360
dependencies right the processor

313
00:10:23,360 --> 00:10:25,040
can fetch things out of order if they're

314
00:10:25,040 --> 00:10:26,800
independent but if we force the result

315
00:10:26,800 --> 00:10:28,079
of one to be

316
00:10:28,079 --> 00:10:30,640
dependent on the previous result

317
00:10:30,640 --> 00:10:32,240
then we can force it to execute

318
00:10:32,240 --> 00:10:34,880
sequentially

319
00:10:35,120 --> 00:10:37,920
so uh in the part that i did for testing

320
00:10:37,920 --> 00:10:39,760
on this which was an amd part

321
00:10:39,760 --> 00:10:41,920
i could actually fetch about 23 cache

322
00:10:41,920 --> 00:10:43,120
lines

323
00:10:43,120 --> 00:10:45,760
during speculation based on a single

324
00:10:45,760 --> 00:10:47,279
cache line

325
00:10:47,279 --> 00:10:49,200
for the picture here i just shown three

326
00:10:49,200 --> 00:10:51,839
for example

327
00:10:51,839 --> 00:10:54,000
so the idea here is that we're going to

328
00:10:54,000 --> 00:10:55,519
run this gadget and we're going to be in

329
00:10:55,519 --> 00:10:57,200
one of these two conditions right either

330
00:10:57,200 --> 00:10:58,720
bc and d are going to be all present or

331
00:10:58,720 --> 00:11:00,640
they're going gonna be all not present

332
00:11:00,640 --> 00:11:02,959
and when we do our timing measurement

333
00:11:02,959 --> 00:11:04,640
we've now increased our signal strength

334
00:11:04,640 --> 00:11:06,959
to about 700 cycles so

335
00:11:06,959 --> 00:11:09,359
not bad

336
00:11:09,920 --> 00:11:11,920
so how do we go beyond this well the

337
00:11:11,920 --> 00:11:13,519
naive thing and the thing that i first

338
00:11:13,519 --> 00:11:14,399
tried

339
00:11:14,399 --> 00:11:16,320
was to just

340
00:11:16,320 --> 00:11:19,040
like repeat it like to you know bring in

341
00:11:19,040 --> 00:11:21,360
23 cash lines then each of those brings

342
00:11:21,360 --> 00:11:23,120
another 23 cash lines

343
00:11:23,120 --> 00:11:25,040
problem is you run out of cash

344
00:11:25,040 --> 00:11:27,360
really fast and

345
00:11:27,360 --> 00:11:28,800
there's a limit and then you run the

346
00:11:28,800 --> 00:11:31,200
system noise and it doesn't really work

347
00:11:31,200 --> 00:11:33,440
well

348
00:11:33,760 --> 00:11:35,200
so

349
00:11:35,200 --> 00:11:37,440
the better technique is

350
00:11:37,440 --> 00:11:39,200
this thing i call self-reinforcing

351
00:11:39,200 --> 00:11:40,720
amplifier and in this case we're going

352
00:11:40,720 --> 00:11:42,399
to do that single stage amplifier we're

353
00:11:42,399 --> 00:11:45,040
going to keep one cache line behind

354
00:11:45,040 --> 00:11:47,680
so we're going to bring in 23

355
00:11:47,680 --> 00:11:50,079
we're going to time the axis or i should

356
00:11:50,079 --> 00:11:51,440
say actually we're just going to access

357
00:11:51,440 --> 00:11:53,440
22 because we're timing the whole thing

358
00:11:53,440 --> 00:11:55,279
we're going to access 22 of them and

359
00:11:55,279 --> 00:11:56,399
then we're going to take the one that's

360
00:11:56,399 --> 00:11:58,000
left we're going to invert it and we're

361
00:11:58,000 --> 00:12:00,240
going to restore the original signal

362
00:12:00,240 --> 00:12:01,120
and

363
00:12:01,120 --> 00:12:02,880
this is important because this stuff is

364
00:12:02,880 --> 00:12:04,880
kind of like schrodinger's cat right any

365
00:12:04,880 --> 00:12:07,279
time that you use it you bring the thing

366
00:12:07,279 --> 00:12:10,079
in and you can't use it anymore so we

367
00:12:10,079 --> 00:12:12,800
create 23 copies we use one to restore

368
00:12:12,800 --> 00:12:13,519
it

369
00:12:13,519 --> 00:12:16,079
access the rest

370
00:12:16,079 --> 00:12:19,600
and we repeat this a lot

371
00:12:19,600 --> 00:12:21,680
we can repeat it

372
00:12:21,680 --> 00:12:24,800
up to a point and then the data kind of

373
00:12:24,800 --> 00:12:26,880
gets noisier

374
00:12:26,880 --> 00:12:28,240
you know every time that we do this

375
00:12:28,240 --> 00:12:30,160
there is a risk of system interrupts

376
00:12:30,160 --> 00:12:33,040
other kinds of system noise and so

377
00:12:33,040 --> 00:12:35,600
that's why the results kind of trail off

378
00:12:35,600 --> 00:12:37,519
but you know we can do about seven

379
00:12:37,519 --> 00:12:41,040
hundred thousand that's pretty good

380
00:12:41,839 --> 00:12:44,000
so if we do seven hundred thousand and

381
00:12:44,000 --> 00:12:46,800
we run it a thousand times um this is

382
00:12:46,800 --> 00:12:49,279
the results that i saw and so what i'm

383
00:12:49,279 --> 00:12:50,800
showing here is signal strength so again

384
00:12:50,800 --> 00:12:52,480
that's the difference between

385
00:12:52,480 --> 00:12:53,839
the timing

386
00:12:53,839 --> 00:12:55,440
when the cache line was present versus

387
00:12:55,440 --> 00:12:56,800
not present

388
00:12:56,800 --> 00:12:59,440
in some cases it's over a second so this

389
00:12:59,440 --> 00:13:02,160
code ran for a second of wall clock time

390
00:13:02,160 --> 00:13:03,920
difference based on that one initial

391
00:13:03,920 --> 00:13:06,320
cache line

392
00:13:06,320 --> 00:13:08,240
and so even if you have a pretty bad

393
00:13:08,240 --> 00:13:10,320
timer you can still figure out what the

394
00:13:10,320 --> 00:13:12,959
state of that cache line was with a 500

395
00:13:12,959 --> 00:13:14,880
millisecond timer you get it right about

396
00:13:14,880 --> 00:13:16,320
50 percent of time you get it wrong

397
00:13:16,320 --> 00:13:18,560
about 10 percent of the time

398
00:13:18,560 --> 00:13:20,160
if you have a slightly better timer

399
00:13:20,160 --> 00:13:23,200
though the results are much better um if

400
00:13:23,200 --> 00:13:25,040
we don't go quite as aggressive and we

401
00:13:25,040 --> 00:13:26,160
go with like a hundred thousand

402
00:13:26,160 --> 00:13:27,920
amplifier

403
00:13:27,920 --> 00:13:29,760
meaning we repeated that loop a hundred

404
00:13:29,760 --> 00:13:31,279
thousand times

405
00:13:31,279 --> 00:13:33,360
uh we get a signal average signal

406
00:13:33,360 --> 00:13:34,399
strength about

407
00:13:34,399 --> 00:13:36,880
180 milliseconds

408
00:13:36,880 --> 00:13:39,360
with a 100 millisecond timer that's over

409
00:13:39,360 --> 00:13:41,360
80 percent chance recovery

410
00:13:41,360 --> 00:13:44,320
10 millisecond timer 95 chance that's

411
00:13:44,320 --> 00:13:46,240
over 2 million

412
00:13:46,240 --> 00:13:48,720
amplification from the base signal

413
00:13:48,720 --> 00:13:50,800
so

414
00:13:50,800 --> 00:13:52,720
that's pretty good we don't need a good

415
00:13:52,720 --> 00:13:56,959
timer to do a cache slide channel attack

416
00:13:58,720 --> 00:13:59,760
all right

417
00:13:59,760 --> 00:14:02,160
now what else can we do this is the fun

418
00:14:02,160 --> 00:14:03,519
part

419
00:14:03,519 --> 00:14:04,320
so

420
00:14:04,320 --> 00:14:06,800
i'm going to present two problems

421
00:14:06,800 --> 00:14:09,120
uh here first one is

422
00:14:09,120 --> 00:14:11,199
binary search right we have an array of

423
00:14:11,199 --> 00:14:13,199
cache lines one of them is present we

424
00:14:13,199 --> 00:14:15,120
don't know which we want to find which

425
00:14:15,120 --> 00:14:17,120
one is present doing the fewest timing

426
00:14:17,120 --> 00:14:19,040
measurements possible

427
00:14:19,040 --> 00:14:21,199
uh in real life this would be a case

428
00:14:21,199 --> 00:14:22,880
where perhaps you're doing a flush and

429
00:14:22,880 --> 00:14:26,160
reload attack and the victim has indexed

430
00:14:26,160 --> 00:14:28,399
some array and has brought in a cache

431
00:14:28,399 --> 00:14:31,040
line that's dependent on a secret value

432
00:14:31,040 --> 00:14:35,199
and maybe there's 64 different values

433
00:14:35,199 --> 00:14:37,600
so we want to do a binary search

434
00:14:37,600 --> 00:14:38,720
but

435
00:14:38,720 --> 00:14:40,320
we have this problem of losing state

436
00:14:40,320 --> 00:14:41,920
right every time we touch the cache line

437
00:14:41,920 --> 00:14:45,279
we bring it in

438
00:14:45,279 --> 00:14:47,040
so the way we're going to do this is in

439
00:14:47,040 --> 00:14:48,399
three steps

440
00:14:48,399 --> 00:14:49,760
we're going to start with the signal

441
00:14:49,760 --> 00:14:51,199
array

442
00:14:51,199 --> 00:14:52,880
at the bottom here and in this picture

443
00:14:52,880 --> 00:14:54,800
i'm showing eight

444
00:14:54,800 --> 00:14:56,079
cache lines

445
00:14:56,079 --> 00:14:57,760
one of those is present

446
00:14:57,760 --> 00:14:59,600
we're going to

447
00:14:59,600 --> 00:15:01,120
create this working array with a

448
00:15:01,120 --> 00:15:03,120
replicator so we're going to take each

449
00:15:03,120 --> 00:15:04,800
line and create two copies of the

450
00:15:04,800 --> 00:15:06,800
inverse of that so in this array we've

451
00:15:06,800 --> 00:15:10,880
got 16 lines two of them are not present

452
00:15:10,880 --> 00:15:12,639
we're then going to use our nan gadget

453
00:15:12,639 --> 00:15:16,399
to check the status of half the array

454
00:15:16,399 --> 00:15:18,399
so in this case we're checking the lower

455
00:15:18,399 --> 00:15:20,800
half of the array and then we just do

456
00:15:20,800 --> 00:15:22,320
one timing measurement on the result of

457
00:15:22,320 --> 00:15:24,800
the nand and that's going to tell us

458
00:15:24,800 --> 00:15:26,959
if the cache line's in that half and

459
00:15:26,959 --> 00:15:28,639
then all we have to do is restore the

460
00:15:28,639 --> 00:15:31,360
original state of the signal array which

461
00:15:31,360 --> 00:15:33,680
we do using the copy that we didn't use

462
00:15:33,680 --> 00:15:35,120
for the nand so that's why we had to

463
00:15:35,120 --> 00:15:37,519
create two copies one to use one to

464
00:15:37,519 --> 00:15:40,920
restore back

465
00:15:41,440 --> 00:15:42,320
so

466
00:15:42,320 --> 00:15:45,120
i tested this out it works pretty well

467
00:15:45,120 --> 00:15:47,440
up to a point

468
00:15:47,440 --> 00:15:48,399
the

469
00:15:48,399 --> 00:15:50,560
the up to a point is because of the fact

470
00:15:50,560 --> 00:15:52,800
that we're using larger and larger nand

471
00:15:52,800 --> 00:15:54,560
gates as we have larger and larger

472
00:15:54,560 --> 00:15:56,079
arrays and

473
00:15:56,079 --> 00:15:58,560
speculation is only like we only have so

474
00:15:58,560 --> 00:16:00,240
much out of order window

475
00:16:00,240 --> 00:16:02,480
in these cpus so it works really well up

476
00:16:02,480 --> 00:16:06,240
to about 128 then it kind of falls off

477
00:16:06,240 --> 00:16:08,160
it is worth pointing out this is not

478
00:16:08,160 --> 00:16:09,279
fast

479
00:16:09,279 --> 00:16:12,000
we're not trying to optimize

480
00:16:12,000 --> 00:16:13,279
um

481
00:16:13,279 --> 00:16:15,680
necessarily for performance we're trying

482
00:16:15,680 --> 00:16:17,360
to optimize for timing measurements so

483
00:16:17,360 --> 00:16:18,800
the idea is that

484
00:16:18,800 --> 00:16:19,839
if you

485
00:16:19,839 --> 00:16:22,480
don't have that high precision timer

486
00:16:22,480 --> 00:16:23,519
and it's you have to do the

487
00:16:23,519 --> 00:16:24,800
amplification it's going to take you a

488
00:16:24,800 --> 00:16:26,560
while to do the amplification then you

489
00:16:26,560 --> 00:16:27,839
do want to

490
00:16:27,839 --> 00:16:29,199
reduce the amount of timing you have to

491
00:16:29,199 --> 00:16:30,880
do in order to improve the performance

492
00:16:30,880 --> 00:16:32,639
of your attack so that's where i could

493
00:16:32,639 --> 00:16:36,920
see this sort of technique being useful

494
00:16:38,880 --> 00:16:42,079
the other problem that i want to present

495
00:16:42,079 --> 00:16:45,600
here is a cache line counter and this is

496
00:16:45,600 --> 00:16:47,040
sort of the opposite problem so in this

497
00:16:47,040 --> 00:16:49,120
case we have an array of cache lines

498
00:16:49,120 --> 00:16:50,720
some of them are present we don't know

499
00:16:50,720 --> 00:16:52,480
how many we want to find out how many

500
00:16:52,480 --> 00:16:54,639
are present

501
00:16:54,639 --> 00:16:55,600
and

502
00:16:55,600 --> 00:16:57,759
you know this could be useful if you're

503
00:16:57,759 --> 00:16:59,920
doing especially a prime and probe type

504
00:16:59,920 --> 00:17:02,399
attack where the victim is going to

505
00:17:02,399 --> 00:17:04,079
access a different number of cache lines

506
00:17:04,079 --> 00:17:06,160
depending on the code path that they did

507
00:17:06,160 --> 00:17:07,839
and maybe that code path is dependent on

508
00:17:07,839 --> 00:17:09,760
a secret value

509
00:17:09,760 --> 00:17:11,199
so in that case you're just looking to

510
00:17:11,199 --> 00:17:13,199
see how many lines they touched

511
00:17:13,199 --> 00:17:16,799
and so we're going to use a counter

512
00:17:16,799 --> 00:17:19,039
but not a normal like register based

513
00:17:19,039 --> 00:17:20,160
counter

514
00:17:20,160 --> 00:17:22,240
what we're going to do is we're going to

515
00:17:22,240 --> 00:17:24,400
create a counter where the state of the

516
00:17:24,400 --> 00:17:26,799
counter is stored in the state of a set

517
00:17:26,799 --> 00:17:28,240
of cache lines

518
00:17:28,240 --> 00:17:30,880
so we'll have say six cache lines we

519
00:17:30,880 --> 00:17:33,440
allocate and if all those cache lines

520
00:17:33,440 --> 00:17:34,799
are not present that means the counter

521
00:17:34,799 --> 00:17:36,960
has a value of zero

522
00:17:36,960 --> 00:17:38,960
and each cache line that is present

523
00:17:38,960 --> 00:17:40,480
represents

524
00:17:40,480 --> 00:17:43,440
a certain bit in the counter

525
00:17:43,440 --> 00:17:44,480
and

526
00:17:44,480 --> 00:17:46,880
then we're going to use a adder circuit

527
00:17:46,880 --> 00:17:48,559
which is this is just your standard half

528
00:17:48,559 --> 00:17:49,840
adder except

529
00:17:49,840 --> 00:17:51,760
we have some limitations you know

530
00:17:51,760 --> 00:17:54,400
because we have limited gadgets

531
00:17:54,400 --> 00:17:56,960
and we can only use each value once

532
00:17:56,960 --> 00:17:58,799
we had to make some modifications but i

533
00:17:58,799 --> 00:18:00,640
promise you can you know figure it out

534
00:18:00,640 --> 00:18:02,720
it's it's equivalent to a standard half

535
00:18:02,720 --> 00:18:04,480
adder

536
00:18:04,480 --> 00:18:05,200
so

537
00:18:05,200 --> 00:18:08,080
we're just going to add each

538
00:18:08,080 --> 00:18:10,400
cache line in our input array

539
00:18:10,400 --> 00:18:12,160
to the counter

540
00:18:12,160 --> 00:18:13,919
by doing these things that manipulate

541
00:18:13,919 --> 00:18:16,720
cache line state

542
00:18:16,720 --> 00:18:17,520
so

543
00:18:17,520 --> 00:18:19,280
uh just to kind of walk through what

544
00:18:19,280 --> 00:18:22,400
that looks like initially they say we we

545
00:18:22,400 --> 00:18:24,720
flush the

546
00:18:24,720 --> 00:18:25,919
cache lines that correspond to the

547
00:18:25,919 --> 00:18:27,440
counter from the cache so they're not

548
00:18:27,440 --> 00:18:29,919
present meaning that the counter is zero

549
00:18:29,919 --> 00:18:32,320
and we'll assume that the left there

550
00:18:32,320 --> 00:18:35,039
happens to be our initial array

551
00:18:35,039 --> 00:18:36,880
we'll process the first input which

552
00:18:36,880 --> 00:18:38,960
effectively brings in the cache line

553
00:18:38,960 --> 00:18:40,640
corresponding to the first bit of the

554
00:18:40,640 --> 00:18:42,240
counter

555
00:18:42,240 --> 00:18:44,400
when we process the second input

556
00:18:44,400 --> 00:18:46,640
that will result in the second cache

557
00:18:46,640 --> 00:18:47,440
line

558
00:18:47,440 --> 00:18:48,799
corresponding account to be brought in

559
00:18:48,799 --> 00:18:52,639
while the first one will become evicted

560
00:18:53,440 --> 00:18:56,240
the third input nothing changes except

561
00:18:56,240 --> 00:18:58,240
of course it gets brought in part of the

562
00:18:58,240 --> 00:18:59,280
processing

563
00:18:59,280 --> 00:19:01,280
and then at the end of course we have

564
00:19:01,280 --> 00:19:03,440
two cache lines that are present

565
00:19:03,440 --> 00:19:06,080
and we just then have to time the access

566
00:19:06,080 --> 00:19:07,280
to

567
00:19:07,280 --> 00:19:08,799
these three cache lines here on the

568
00:19:08,799 --> 00:19:12,400
right we get our counter value

569
00:19:13,679 --> 00:19:16,080
and this one works even better than the

570
00:19:16,080 --> 00:19:19,039
other one mainly because the gadgets

571
00:19:19,039 --> 00:19:21,200
here don't have really big fan in or fan

572
00:19:21,200 --> 00:19:22,320
outs

573
00:19:22,320 --> 00:19:24,320
you know everything is just kind of a

574
00:19:24,320 --> 00:19:26,240
between one and three inputs

575
00:19:26,240 --> 00:19:27,919
so uh

576
00:19:27,919 --> 00:19:29,600
yeah this this worked really well in

577
00:19:29,600 --> 00:19:30,720
testing

578
00:19:30,720 --> 00:19:33,360
and um

579
00:19:33,360 --> 00:19:35,600
yeah

580
00:19:36,559 --> 00:19:39,039
all right so

581
00:19:39,039 --> 00:19:41,440
a few takeaways that i want to

582
00:19:41,440 --> 00:19:43,120
provide from this first off i i hope

583
00:19:43,120 --> 00:19:46,000
that this sort of is interesting i think

584
00:19:46,000 --> 00:19:47,600
it's a different way of thinking about

585
00:19:47,600 --> 00:19:49,840
caches and and speculation and kind of

586
00:19:49,840 --> 00:19:51,200
it brings two

587
00:19:51,200 --> 00:19:54,960
big areas of security research together

588
00:19:54,960 --> 00:19:57,520
where we're using cpu speculation but

589
00:19:57,520 --> 00:20:00,960
not actually to leak data but to

590
00:20:00,960 --> 00:20:04,080
actually optimize how we recover data

591
00:20:04,080 --> 00:20:05,919
so the first thing is disabling high

592
00:20:05,919 --> 00:20:07,840
precision timers is not a very good

593
00:20:07,840 --> 00:20:10,480
security mitigation that's probably

594
00:20:10,480 --> 00:20:13,280
obvious at this point

595
00:20:13,280 --> 00:20:15,440
you know the amplification techniques

596
00:20:15,440 --> 00:20:18,080
aren't that hard to do

597
00:20:18,080 --> 00:20:20,159
also the results i showed that was from

598
00:20:20,159 --> 00:20:22,000
a single run so that's where i had one

599
00:20:22,000 --> 00:20:25,039
cache line and i only process it once

600
00:20:25,039 --> 00:20:26,320
right that's assuming that sort of you

601
00:20:26,320 --> 00:20:28,080
invoke the victim and you get one shot

602
00:20:28,080 --> 00:20:29,520
at and that's it

603
00:20:29,520 --> 00:20:31,360
a lot of times in these attacks you can

604
00:20:31,360 --> 00:20:33,440
actually invoke the victim many times

605
00:20:33,440 --> 00:20:34,720
you know just by calling it again with

606
00:20:34,720 --> 00:20:36,000
the same inputs

607
00:20:36,000 --> 00:20:37,679
and you can improve your results that

608
00:20:37,679 --> 00:20:39,440
way if you can call the victim multiple

609
00:20:39,440 --> 00:20:40,640
times and the accuracy is going to

610
00:20:40,640 --> 00:20:41,919
skyrocket

611
00:20:41,919 --> 00:20:43,039
quickly

612
00:20:43,039 --> 00:20:46,000
i didn't even try that

613
00:20:46,720 --> 00:20:48,799
monitoring access to timers is a weak

614
00:20:48,799 --> 00:20:50,320
mitigation right sometimes there have

615
00:20:50,320 --> 00:20:52,240
been techniques proposed to say well if

616
00:20:52,240 --> 00:20:54,240
you're calling you know read tsc too

617
00:20:54,240 --> 00:20:55,760
many times and you're probably doing

618
00:20:55,760 --> 00:20:57,440
side channel attack

619
00:20:57,440 --> 00:20:58,720
we just showed how you don't have to

620
00:20:58,720 --> 00:21:00,799
call read tsc and yet you can still do

621
00:21:00,799 --> 00:21:03,840
stuff with cache line state

622
00:21:04,320 --> 00:21:06,320
and then finally you know we have this

623
00:21:06,320 --> 00:21:07,520
ability to do

624
00:21:07,520 --> 00:21:10,640
universal logic gadgets so we can do

625
00:21:10,640 --> 00:21:13,919
things like you know binary search

626
00:21:13,919 --> 00:21:15,039
or

627
00:21:15,039 --> 00:21:16,880
other kinds of computation that we want

628
00:21:16,880 --> 00:21:18,080
to do

629
00:21:18,080 --> 00:21:22,399
before we actually need to do any timing

630
00:21:24,559 --> 00:21:26,000
as far as mitigations i mean i think

631
00:21:26,000 --> 00:21:27,280
it's always important to have a

632
00:21:27,280 --> 00:21:29,280
discussion about mitigations and

633
00:21:29,280 --> 00:21:32,400
anything related to side channels uh you

634
00:21:32,400 --> 00:21:34,320
know as far as i'm aware there hasn't

635
00:21:34,320 --> 00:21:36,000
been a lot of focus in this recovery

636
00:21:36,000 --> 00:21:37,120
aspect

637
00:21:37,120 --> 00:21:39,520
of side channels and so i think this is

638
00:21:39,520 --> 00:21:41,600
you know interesting

639
00:21:41,600 --> 00:21:43,440
however if the attacker is able to get

640
00:21:43,440 --> 00:21:45,600
to the recovery stage then you've

641
00:21:45,600 --> 00:21:47,760
already lost right that that's not the

642
00:21:47,760 --> 00:21:49,200
place where you want to be focusing on

643
00:21:49,200 --> 00:21:51,840
mitigations uh effective mitigations are

644
00:21:51,840 --> 00:21:52,880
going to

645
00:21:52,880 --> 00:21:53,840
prevent

646
00:21:53,840 --> 00:21:55,600
that execution phase from actually

647
00:21:55,600 --> 00:21:57,280
happening right using

648
00:21:57,280 --> 00:21:59,200
code that is side channel aware so that

649
00:21:59,200 --> 00:22:01,200
it accesses the same number of cache

650
00:22:01,200 --> 00:22:03,600
lines in every code path or

651
00:22:03,600 --> 00:22:05,760
you know limiting cpu speculation so

652
00:22:05,760 --> 00:22:08,159
that you don't access secret dependent

653
00:22:08,159 --> 00:22:10,880
values under speculation

654
00:22:10,880 --> 00:22:13,520
those are good

655
00:22:13,520 --> 00:22:15,919
recovery stuff not so much

656
00:22:15,919 --> 00:22:17,440
and then i'm going to contradict what i

657
00:22:17,440 --> 00:22:18,799
just said on the previous slide a little

658
00:22:18,799 --> 00:22:21,840
bit which is that even though disabling

659
00:22:21,840 --> 00:22:23,679
access to high precision timers doesn't

660
00:22:23,679 --> 00:22:24,799
work

661
00:22:24,799 --> 00:22:26,559
it doesn't hurt

662
00:22:26,559 --> 00:22:28,799
if you don't need them

663
00:22:28,799 --> 00:22:30,000
you know it's another hoop that the

664
00:22:30,000 --> 00:22:31,840
attacker has to jump through and there

665
00:22:31,840 --> 00:22:35,280
is arguably value in that

666
00:22:37,919 --> 00:22:40,000
so uh you know just some ideas for

667
00:22:40,000 --> 00:22:43,039
future work here uh

668
00:22:43,039 --> 00:22:44,640
yeah i i started doing this kind of just

669
00:22:44,640 --> 00:22:46,960
for fun i think there's probably more

670
00:22:46,960 --> 00:22:50,320
here you know there's maybe ways to even

671
00:22:50,320 --> 00:22:52,159
amplify stuff further

672
00:22:52,159 --> 00:22:54,320
uh you know i kind of ran into a limit

673
00:22:54,320 --> 00:22:56,240
where just after about

674
00:22:56,240 --> 00:22:57,760
700 000

675
00:22:57,760 --> 00:23:00,080
uh iterations then things kind of

676
00:23:00,080 --> 00:23:01,520
degraded

677
00:23:01,520 --> 00:23:02,960
there might be ways of getting around

678
00:23:02,960 --> 00:23:05,039
that um you know i think some more

679
00:23:05,039 --> 00:23:06,480
investigation into

680
00:23:06,480 --> 00:23:08,640
what caused the signal to get degraded

681
00:23:08,640 --> 00:23:11,840
at that point would be interesting

682
00:23:11,840 --> 00:23:14,559
you know are there other use cases for

683
00:23:14,559 --> 00:23:16,400
some of these things

684
00:23:16,400 --> 00:23:17,600
you know if you want to go off the deep

685
00:23:17,600 --> 00:23:19,360
end you can even think about what other

686
00:23:19,360 --> 00:23:21,280
kinds of computation does it make sense

687
00:23:21,280 --> 00:23:22,880
to do with this model where you're not

688
00:23:22,880 --> 00:23:24,480
storing values in registers you're

689
00:23:24,480 --> 00:23:26,720
storing them in cache line state right

690
00:23:26,720 --> 00:23:28,880
which has this weird phenomenon of if

691
00:23:28,880 --> 00:23:30,720
someone touches it then they effectively

692
00:23:30,720 --> 00:23:31,919
destroy the data right it's like

693
00:23:31,919 --> 00:23:34,720
schrodinger's cache lines

694
00:23:34,720 --> 00:23:35,440
so

695
00:23:35,440 --> 00:23:36,640
you know could you use this to maybe

696
00:23:36,640 --> 00:23:38,559
detect side channel attacks

697
00:23:38,559 --> 00:23:40,159
uh i don't know i've tried to think

698
00:23:40,159 --> 00:23:41,679
about if this makes sense and i haven't

699
00:23:41,679 --> 00:23:44,559
come with a great story around it but

700
00:23:44,559 --> 00:23:46,559
you know i think it's it's kind of an

701
00:23:46,559 --> 00:23:48,240
interesting way of hiding what you're

702
00:23:48,240 --> 00:23:50,960
doing in your code because it's very

703
00:23:50,960 --> 00:23:52,559
non-obvious

704
00:23:52,559 --> 00:23:54,240
and in fact the data

705
00:23:54,240 --> 00:23:56,400
is nowhere in your code it's all in the

706
00:23:56,400 --> 00:23:58,960
state of the cache

707
00:23:58,960 --> 00:24:00,320
so

708
00:24:00,320 --> 00:24:02,799
hopefully this was interesting please

709
00:24:02,799 --> 00:24:05,440
keep an eye out for the paper from from

710
00:24:05,440 --> 00:24:07,600
katzman and their team

711
00:24:07,600 --> 00:24:10,240
if you like this stuff

712
00:24:10,240 --> 00:24:12,320
if there are any questions on this i'd

713
00:24:12,320 --> 00:24:14,240
be happy to take some i think lunch is

714
00:24:14,240 --> 00:24:15,840
in like 15 minutes so i think we have a

715
00:24:15,840 --> 00:24:16,880
few

716
00:24:16,880 --> 00:24:19,840
okay

717
00:24:19,919 --> 00:24:22,080
questions

718
00:24:22,080 --> 00:24:23,490
maybe have enough time

719
00:24:23,490 --> 00:24:24,880
[Music]

720
00:24:24,880 --> 00:24:28,720
you'll get to lunch early but yeah

721
00:24:28,880 --> 00:24:30,720
all right assigning date will still be

722
00:24:30,720 --> 00:24:31,600
around

723
00:24:31,600 --> 00:24:33,200
so yeah feel free to catch him for a

724
00:24:33,200 --> 00:24:35,840
chat and as promised the lunch is early

725
00:24:35,840 --> 00:24:37,200
so we'll be

726
00:24:37,200 --> 00:24:39,200
back at 2pm and thank you so much david

727
00:24:39,200 --> 00:24:40,880
for the amazing talk

728
00:24:40,880 --> 00:24:44,120
thank you

