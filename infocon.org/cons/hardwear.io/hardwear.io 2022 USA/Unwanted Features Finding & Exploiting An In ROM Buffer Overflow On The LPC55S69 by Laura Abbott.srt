1
00:00:04,560 --> 00:00:06,480
uh hi everyone thanks for having me here

2
00:00:06,480 --> 00:00:07,600
today

3
00:00:07,600 --> 00:00:11,200
um as i said uh i'm laura and i work for

4
00:00:11,200 --> 00:00:12,880
oxide computer for those who haven't

5
00:00:12,880 --> 00:00:14,880
heard the pitch of oxide oxide is

6
00:00:14,880 --> 00:00:16,880
rethinking the server from the ground up

7
00:00:16,880 --> 00:00:18,960
servers haven't fundamentally changed in

8
00:00:18,960 --> 00:00:20,960
many years and oxide is looking to

9
00:00:20,960 --> 00:00:22,000
change that

10
00:00:22,000 --> 00:00:23,600
i promise this isn't just a sales pitch

11
00:00:23,600 --> 00:00:26,000
for oxide but the context for what oxide

12
00:00:26,000 --> 00:00:28,080
is building is important for the issue

13
00:00:28,080 --> 00:00:30,320
we found and what exactly we need to do

14
00:00:30,320 --> 00:00:32,640
to mitigate it

15
00:00:32,640 --> 00:00:34,399
one of the ways oxide is rethinking the

16
00:00:34,399 --> 00:00:38,480
server is with a hardware route of trust

17
00:00:38,480 --> 00:00:40,160
when i say hardware route of trust this

18
00:00:40,160 --> 00:00:44,559
can mean many things to many people and

19
00:00:44,559 --> 00:00:46,079
in this case what i'm when i say harbor

20
00:00:46,079 --> 00:00:47,280
road of trust i'm talking about a

21
00:00:47,280 --> 00:00:49,280
hardware route of trust for measurement

22
00:00:49,280 --> 00:00:51,360
and this is answering the question about

23
00:00:51,360 --> 00:00:54,800
what software is running on the system

24
00:00:54,800 --> 00:00:56,800
the theory here with the root of trust

25
00:00:56,800 --> 00:00:59,359
is that okay we're going to say have our

26
00:00:59,359 --> 00:01:01,039
little hardware root of trust it's got a

27
00:01:01,039 --> 00:01:03,199
rom it's got some software on it we are

28
00:01:03,199 --> 00:01:04,959
going to trust that root of trust

29
00:01:04,959 --> 00:01:06,320
unconditionally

30
00:01:06,320 --> 00:01:08,320
and then that is going to measure

31
00:01:08,320 --> 00:01:10,560
another part of the system and then that

32
00:01:10,560 --> 00:01:12,080
part of the system is going to measure

33
00:01:12,080 --> 00:01:13,840
another part of the system until we've

34
00:01:13,840 --> 00:01:14,880
measured

35
00:01:14,880 --> 00:01:17,280
everything we want and you get up an

36
00:01:17,280 --> 00:01:19,759
entire measurement about what's going on

37
00:01:19,759 --> 00:01:20,799
this is done with a series of

38
00:01:20,799 --> 00:01:22,720
cryptographic hashes this could be an

39
00:01:22,720 --> 00:01:25,119
entire talk all of its own but the

40
00:01:25,119 --> 00:01:26,479
important thing for what i'm going to be

41
00:01:26,479 --> 00:01:28,560
talking about today is that you must

42
00:01:28,560 --> 00:01:30,720
trust your root of trust otherwise

43
00:01:30,720 --> 00:01:33,920
everything falls apart

44
00:01:34,000 --> 00:01:35,759
when it came time to select hardware for

45
00:01:35,759 --> 00:01:37,600
a root of trust we had some pretty

46
00:01:37,600 --> 00:01:39,280
specific requirements

47
00:01:39,280 --> 00:01:40,799
we need to make a

48
00:01:40,799 --> 00:01:42,640
strong assertion about the integrity and

49
00:01:42,640 --> 00:01:44,720
authenticity about what code is going to

50
00:01:44,720 --> 00:01:46,799
be running on our root of trust

51
00:01:46,799 --> 00:01:49,920
there needs to be a unique id to be able

52
00:01:49,920 --> 00:01:51,759
to do our measurement

53
00:01:51,759 --> 00:01:53,119
and then we need a way to be able to

54
00:01:53,119 --> 00:01:54,720
extend the trust

55
00:01:54,720 --> 00:01:56,880
across all parts of the system and then

56
00:01:56,880 --> 00:01:58,960
be able to re-establish trust if other

57
00:01:58,960 --> 00:02:01,600
parts of the system become compromised

58
00:02:01,600 --> 00:02:02,719
other parts

59
00:02:02,719 --> 00:02:03,920
other features you might think of such

60
00:02:03,920 --> 00:02:05,680
as cryptographic accelerators were

61
00:02:05,680 --> 00:02:07,840
considered nice to have but not strictly

62
00:02:07,840 --> 00:02:10,479
necessary

63
00:02:10,720 --> 00:02:12,560
our requirements for the hardware reader

64
00:02:12,560 --> 00:02:13,959
trust led us to this

65
00:02:13,959 --> 00:02:18,000
lpc55 s69 from nxp

66
00:02:18,000 --> 00:02:20,400
this is a dual core arm v8m

67
00:02:20,400 --> 00:02:23,599
microcontroller with has trustzone m and

68
00:02:23,599 --> 00:02:25,520
mpu support if you're familiar with

69
00:02:25,520 --> 00:02:27,680
trustzone and cortex a it's kind of

70
00:02:27,680 --> 00:02:30,160
familiar it's simp similar there um the

71
00:02:30,160 --> 00:02:32,319
lp55 has common

72
00:02:32,319 --> 00:02:34,959
cryptographic accelerators for shaw aes

73
00:02:34,959 --> 00:02:36,400
and doing field math

74
00:02:36,400 --> 00:02:38,480
and the chip supports you secure boot

75
00:02:38,480 --> 00:02:40,560
using rsa signatures

76
00:02:40,560 --> 00:02:41,760
a couple features that i'll talk about

77
00:02:41,760 --> 00:02:44,239
later are there's a puff physically

78
00:02:44,239 --> 00:02:46,239
unclonable function and a feature called

79
00:02:46,239 --> 00:02:48,959
dice which is used to generate a crypto

80
00:02:48,959 --> 00:02:51,040
cryptographically secure identity based

81
00:02:51,040 --> 00:02:53,280
on the secret and the running code

82
00:02:53,280 --> 00:02:55,440
and dice is a feature that

83
00:02:55,440 --> 00:02:56,720
really helps us to be able to say we

84
00:02:56,720 --> 00:02:58,000
trust what's running on our root of

85
00:02:58,000 --> 00:03:00,080
trust

86
00:03:00,080 --> 00:03:01,920
so that's the hardware we selected but

87
00:03:01,920 --> 00:03:03,599
of course we need software to run on

88
00:03:03,599 --> 00:03:04,959
this chip

89
00:03:04,959 --> 00:03:06,720
and part of oxide's philosophy is that

90
00:03:06,720 --> 00:03:08,879
you need to deliver software updates for

91
00:03:08,879 --> 00:03:10,720
all parts of the system and this

92
00:03:10,720 --> 00:03:12,959
includes writing soft rights updates for

93
00:03:12,959 --> 00:03:15,120
all of our microcontrollers

94
00:03:15,120 --> 00:03:16,239
for those of you who haven't done this

95
00:03:16,239 --> 00:03:17,599
before writing updates from

96
00:03:17,599 --> 00:03:19,040
microcontrollers is sometimes seen as a

97
00:03:19,040 --> 00:03:21,120
rite of passage because it's code

98
00:03:21,120 --> 00:03:22,560
somehow everyone seems to end up meeting

99
00:03:22,560 --> 00:03:24,560
to write

100
00:03:24,560 --> 00:03:26,640
okay so this is the memory layout of a

101
00:03:26,640 --> 00:03:28,480
theoretical microcontroller you have

102
00:03:28,480 --> 00:03:30,720
your code running in flash somewhere and

103
00:03:30,720 --> 00:03:32,640
of course it needs to be updated

104
00:03:32,640 --> 00:03:34,480
um in this system this microcontroller

105
00:03:34,480 --> 00:03:36,000
is often running out somewhere in the

106
00:03:36,000 --> 00:03:38,319
universe uh maybe no way to physically

107
00:03:38,319 --> 00:03:39,680
access it

108
00:03:39,680 --> 00:03:41,440
and what will happen is this device will

109
00:03:41,440 --> 00:03:42,720
receive an update over some sort of

110
00:03:42,720 --> 00:03:45,120
protocol and then uh rent to flash

111
00:03:45,120 --> 00:03:46,720
hopefully after checking that the

112
00:03:46,720 --> 00:03:49,200
signature is valid and everything

113
00:03:49,200 --> 00:03:50,159
and so

114
00:03:50,159 --> 00:03:51,440
this also ends up meaning that the

115
00:03:51,440 --> 00:03:53,120
update code ends up running alongside

116
00:03:53,120 --> 00:03:56,159
whatever other code is running out there

117
00:03:56,159 --> 00:03:59,280
a very common design for microcontroller

118
00:03:59,280 --> 00:04:01,200
updates is to split the flash in half

119
00:04:01,200 --> 00:04:02,799
and has one part designated for the

120
00:04:02,799 --> 00:04:05,120
running code and the other part running

121
00:04:05,120 --> 00:04:07,680
as a secondary image so when your update

122
00:04:07,680 --> 00:04:10,239
comes in you're going to

123
00:04:10,239 --> 00:04:11,840
write write the update to your not

124
00:04:11,840 --> 00:04:13,120
running

125
00:04:13,120 --> 00:04:15,439
space and then jump into that

126
00:04:15,439 --> 00:04:17,440
this is also drastically oversimplifying

127
00:04:17,440 --> 00:04:19,519
how this update works there's a lot of

128
00:04:19,519 --> 00:04:21,120
choices to be made about how exactly you

129
00:04:21,120 --> 00:04:23,199
do image versioning what exactly going

130
00:04:23,199 --> 00:04:24,240
to be check

131
00:04:24,240 --> 00:04:25,759
if you're doing

132
00:04:25,759 --> 00:04:27,280
encryption or anything like that that's

133
00:04:27,280 --> 00:04:28,880
another layer of

134
00:04:28,880 --> 00:04:31,440
commentary and so many ways this can go

135
00:04:31,440 --> 00:04:32,639
wrong and end up with a nightmare

136
00:04:32,639 --> 00:04:34,720
scenario of a brick device

137
00:04:34,720 --> 00:04:37,919
so in conclusion updates are a huge pain

138
00:04:37,919 --> 00:04:39,600
and flash is frequently the most

139
00:04:39,600 --> 00:04:41,040
resource constrained system in a

140
00:04:41,040 --> 00:04:43,360
microcontroller and so any code you have

141
00:04:43,360 --> 00:04:45,759
for handling updates is something uh

142
00:04:45,759 --> 00:04:47,680
that you could be using for like actual

143
00:04:47,680 --> 00:04:50,880
features people are willing to pay for

144
00:04:50,880 --> 00:04:53,040
and this is where hardware manufacturers

145
00:04:53,040 --> 00:04:54,720
go hey

146
00:04:54,720 --> 00:04:56,160
what if we could solve this problem for

147
00:04:56,160 --> 00:04:58,160
you software writer what if we gave you

148
00:04:58,160 --> 00:05:00,400
code to do updates so that you can use

149
00:05:00,400 --> 00:05:02,160
your flash for other things would you do

150
00:05:02,160 --> 00:05:05,039
more of our chip buy more of our chips

151
00:05:05,039 --> 00:05:07,120
and this is where manufacturers like nxp

152
00:05:07,120 --> 00:05:09,759
offer exactly something like this

153
00:05:09,759 --> 00:05:12,000
nxp has rom code to be able to handle

154
00:05:12,000 --> 00:05:13,840
all these updates

155
00:05:13,840 --> 00:05:15,600
it the update code takes care of

156
00:05:15,600 --> 00:05:18,240
encryption signing erasing all those

157
00:05:18,240 --> 00:05:19,680
hard things so

158
00:05:19,680 --> 00:05:21,680
you as a software update don't software

159
00:05:21,680 --> 00:05:24,639
writer don't have to think about them

160
00:05:24,639 --> 00:05:26,160
i went back and forth with my colleague

161
00:05:26,160 --> 00:05:27,840
when we were evaluating what to do for

162
00:05:27,840 --> 00:05:29,280
update story about whether we should

163
00:05:29,280 --> 00:05:31,520
actually use this code because some of

164
00:05:31,520 --> 00:05:34,000
my colleagues had bad experiences

165
00:05:34,000 --> 00:05:36,160
and eventually we came to the conclusion

166
00:05:36,160 --> 00:05:37,199
that

167
00:05:37,199 --> 00:05:38,560
given we had so many other things to be

168
00:05:38,560 --> 00:05:40,320
able to writing in our system

169
00:05:40,320 --> 00:05:42,160
um it made sense to try and use this

170
00:05:42,160 --> 00:05:44,240
update mechanism so the hardware

171
00:05:44,240 --> 00:05:47,199
manufacturer value add worn one out and

172
00:05:47,199 --> 00:05:49,680
i didn't have to write update code

173
00:05:49,680 --> 00:05:50,560
okay

174
00:05:50,560 --> 00:05:53,039
so let's talk about nxp's update format

175
00:05:53,039 --> 00:05:55,680
this format is called sb2 which seems to

176
00:05:55,680 --> 00:05:58,880
stand for secub version two um there's

177
00:05:58,880 --> 00:06:00,800
references to version one in this code

178
00:06:00,800 --> 00:06:02,800
but i didn't look at it too closely just

179
00:06:02,800 --> 00:06:04,080
because it doesn't actually run on the

180
00:06:04,080 --> 00:06:05,280
chip

181
00:06:05,280 --> 00:06:07,360
all updates are encrypted and version

182
00:06:07,360 --> 00:06:11,759
2.1 is both signed and encrypted

183
00:06:11,840 --> 00:06:14,479
the unit of work on this block

184
00:06:14,479 --> 00:06:15,520
is

185
00:06:15,520 --> 00:06:17,759
16 bytes and this corresponds to

186
00:06:17,759 --> 00:06:19,840
encryption block size on a resource

187
00:06:19,840 --> 00:06:20,800
constraint system such as a

188
00:06:20,800 --> 00:06:22,400
microcontroller

189
00:06:22,400 --> 00:06:23,680
you're not going to have enough space to

190
00:06:23,680 --> 00:06:25,520
be able to stage an entire update so

191
00:06:25,520 --> 00:06:27,120
it's nice to be able to say request 16

192
00:06:27,120 --> 00:06:29,520
bytes decrypt it process it and then go

193
00:06:29,520 --> 00:06:31,919
on to the next bytes okay this update

194
00:06:31,919 --> 00:06:34,560
format has a 96 byte unencrypted header

195
00:06:34,560 --> 00:06:36,319
at the start of every update this is

196
00:06:36,319 --> 00:06:39,120
followed by some hmax for verification a

197
00:06:39,120 --> 00:06:41,360
key blob for decryption and then

198
00:06:41,360 --> 00:06:44,319
a certificate if it's signed and then

199
00:06:44,319 --> 00:06:45,759
a series of data and commands to

200
00:06:45,759 --> 00:06:47,520
actually do the erasing and write the

201
00:06:47,520 --> 00:06:49,680
data for afterwards

202
00:06:49,680 --> 00:06:52,240
okay this talk is mostly concerned with

203
00:06:52,240 --> 00:06:54,080
the header which you're going to see

204
00:06:54,080 --> 00:06:55,280
here

205
00:06:55,280 --> 00:06:57,360
this is 96 bytes there's certainly a lot

206
00:06:57,360 --> 00:07:00,080
of fields here but i want to highlight

207
00:07:00,080 --> 00:07:02,639
two of the fields which ended up acting

208
00:07:02,639 --> 00:07:04,880
as a magic numbers of sorts there's this

209
00:07:04,880 --> 00:07:07,440
field one which listed is supposed to be

210
00:07:07,440 --> 00:07:12,720
stmp and signature two which is sgtl

211
00:07:12,720 --> 00:07:13,919
when i first started looking at this

212
00:07:13,919 --> 00:07:16,160
format i was really confused about what

213
00:07:16,160 --> 00:07:18,880
these meant they felt kind of random

214
00:07:18,880 --> 00:07:20,560
and i ended up finding the clue to what

215
00:07:20,560 --> 00:07:22,240
i think was the answer on a 12 year old

216
00:07:22,240 --> 00:07:24,080
wiki for running custom firmware on

217
00:07:24,080 --> 00:07:25,440
media players

218
00:07:25,440 --> 00:07:28,000
okay this doesn't have a definitive

219
00:07:28,000 --> 00:07:30,160
answer but i think this format seemed to

220
00:07:30,160 --> 00:07:32,240
come out of sigmatel who made chips for

221
00:07:32,240 --> 00:07:34,000
media processing

222
00:07:34,000 --> 00:07:36,319
stmp was a product line of a particular

223
00:07:36,319 --> 00:07:39,360
set of chips and sg sgtl seemed to

224
00:07:39,360 --> 00:07:41,759
stands for sigmatel

225
00:07:41,759 --> 00:07:44,400
freescale bought sigmatill in 2008 and

226
00:07:44,400 --> 00:07:46,879
then freescale itself was merged to nxp

227
00:07:46,879 --> 00:07:48,400
in 2015

228
00:07:48,400 --> 00:07:50,240
and nxp itself was a spin-off from

229
00:07:50,240 --> 00:07:53,280
philips in 2006. so this format has been

230
00:07:53,280 --> 00:07:56,400
around for a number of years and the

231
00:07:56,400 --> 00:07:57,840
answer to why exactly we seem to be

232
00:07:57,840 --> 00:07:59,919
using this format is silicon vendor

233
00:07:59,919 --> 00:08:02,160
consolidation and by the way if anyone

234
00:08:02,160 --> 00:08:03,680
happens to know anything more definitive

235
00:08:03,680 --> 00:08:05,280
about the history of this format i would

236
00:08:05,280 --> 00:08:07,440
actually really love to know

237
00:08:07,440 --> 00:08:08,479
okay

238
00:08:08,479 --> 00:08:10,400
i mentioned that sb2 updates are signed

239
00:08:10,400 --> 00:08:11,680
and encrypted

240
00:08:11,680 --> 00:08:12,960
which also leads to the question about

241
00:08:12,960 --> 00:08:14,560
where are these keys coming from and how

242
00:08:14,560 --> 00:08:16,639
exactly are you trusting them

243
00:08:16,639 --> 00:08:19,120
the lp65 splits its flash into two parts

244
00:08:19,120 --> 00:08:20,720
there's user flash for your user

245
00:08:20,720 --> 00:08:23,680
programs and the protected flash region

246
00:08:23,680 --> 00:08:27,039
for various configuration data

247
00:08:27,039 --> 00:08:28,639
there's a dedicated region for storing

248
00:08:28,639 --> 00:08:29,599
keys

249
00:08:29,599 --> 00:08:31,680
and all the keys are puff encoded which

250
00:08:31,680 --> 00:08:33,679
means they can be safely stored in

251
00:08:33,679 --> 00:08:35,120
readable flash

252
00:08:35,120 --> 00:08:36,719
the keystore stores several different

253
00:08:36,719 --> 00:08:38,080
keys

254
00:08:38,080 --> 00:08:40,000
the important ones for this talk are the

255
00:08:40,000 --> 00:08:42,799
sb keck secure boot key encryption key

256
00:08:42,799 --> 00:08:44,720
which is used for decrypting updates and

257
00:08:44,720 --> 00:08:47,360
the uds unique device secret which is

258
00:08:47,360 --> 00:08:48,720
used with dice to generate the unique

259
00:08:48,720 --> 00:08:50,080
identifier

260
00:08:50,080 --> 00:08:53,120
the cmpa customer customer manufacturing

261
00:08:53,120 --> 00:08:54,640
programming area

262
00:08:54,640 --> 00:08:56,480
holds things like secure boot settings

263
00:08:56,480 --> 00:08:58,480
and the hashes of keys for

264
00:08:58,480 --> 00:09:00,240
verification

265
00:09:00,240 --> 00:09:01,760
the cmpa can be sealed to prevent

266
00:09:01,760 --> 00:09:04,320
further modification and once the cnpa

267
00:09:04,320 --> 00:09:06,399
is sealed you can't change any of the

268
00:09:06,399 --> 00:09:08,160
values of the generated key you can't

269
00:09:08,160 --> 00:09:09,680
turn off secure boot and you can't

270
00:09:09,680 --> 00:09:12,320
change the hashes of the keys

271
00:09:12,320 --> 00:09:13,600
okay so

272
00:09:13,600 --> 00:09:15,760
this update format looks reasonable it

273
00:09:15,760 --> 00:09:18,320
seems like it's secure uh but it turned

274
00:09:18,320 --> 00:09:20,560
out when i started to try and actually

275
00:09:20,560 --> 00:09:22,720
look and do something about this um

276
00:09:22,720 --> 00:09:24,240
it really honestly seemed kind of

277
00:09:24,240 --> 00:09:26,080
complicated there are a lot of different

278
00:09:26,080 --> 00:09:29,120
fields there and things to get right

279
00:09:29,120 --> 00:09:31,360
and i i'm not saying this entire talk is

280
00:09:31,360 --> 00:09:33,120
the result of me not wanting to try and

281
00:09:33,120 --> 00:09:35,040
figure out how to parse this update but

282
00:09:35,040 --> 00:09:37,519
it's kind of close

283
00:09:37,519 --> 00:09:39,519
more seriously this format is used on

284
00:09:39,519 --> 00:09:41,040
our root of trust and i'll say this

285
00:09:41,040 --> 00:09:42,880
several times if the root of trust is

286
00:09:42,880 --> 00:09:44,480
broken everything else about our

287
00:09:44,480 --> 00:09:46,880
measurement is broken and i think if

288
00:09:46,880 --> 00:09:48,000
you've looked at software at all you

289
00:09:48,000 --> 00:09:50,080
know parsing is one of those places

290
00:09:50,080 --> 00:09:52,560
where bugs are absolutely abundant and

291
00:09:52,560 --> 00:09:54,640
the question here becomes how much do we

292
00:09:54,640 --> 00:09:56,240
trust the rom to actually parse this

293
00:09:56,240 --> 00:09:58,640
update format correctly

294
00:09:58,640 --> 00:10:00,880
and honestly we had very good reason not

295
00:10:00,880 --> 00:10:03,519
to want to trust the lpc55 rom

296
00:10:03,519 --> 00:10:05,600
uh i found an undocumented hardware

297
00:10:05,600 --> 00:10:07,920
block in this same chip that could be

298
00:10:07,920 --> 00:10:09,519
used to be able to violate privilege

299
00:10:09,519 --> 00:10:11,760
boundaries um i spoke about this with my

300
00:10:11,760 --> 00:10:14,720
colleague rick last year at defcon

301
00:10:14,720 --> 00:10:16,320
and after we found this issue with the

302
00:10:16,320 --> 00:10:17,839
rom patcher

303
00:10:17,839 --> 00:10:19,360
we went back and forth about whether it

304
00:10:19,360 --> 00:10:22,399
made sense to continue using this in-rom

305
00:10:22,399 --> 00:10:23,839
update mechanism

306
00:10:23,839 --> 00:10:25,680
and we came to the conclusion that yeah

307
00:10:25,680 --> 00:10:27,519
it did make sense just because we

308
00:10:27,519 --> 00:10:28,880
thought we understood how the rom

309
00:10:28,880 --> 00:10:29,920
patcher worked enough that we could

310
00:10:29,920 --> 00:10:31,600
successfully mitigate it

311
00:10:31,600 --> 00:10:33,440
but of course that doesn't mean i wasn't

312
00:10:33,440 --> 00:10:35,680
still curious and i still had this rom

313
00:10:35,680 --> 00:10:38,000
dump lying around to be able to continue

314
00:10:38,000 --> 00:10:39,760
looking at exactly how this rod was

315
00:10:39,760 --> 00:10:41,600
parsed

316
00:10:41,600 --> 00:10:42,880
okay

317
00:10:42,880 --> 00:10:45,760
so i've mentioned nxp's boot rom uh nxps

318
00:10:45,760 --> 00:10:47,519
rom is the very first code that gets run

319
00:10:47,519 --> 00:10:49,120
on powerup

320
00:10:49,120 --> 00:10:50,959
it's responsible for things like power

321
00:10:50,959 --> 00:10:53,279
settings verifying signed images and

322
00:10:53,279 --> 00:10:54,480
everything like that

323
00:10:54,480 --> 00:10:56,000
i could probably give a full talk on

324
00:10:56,000 --> 00:10:57,839
nxpetrom at this point

325
00:10:57,839 --> 00:10:59,920
it also has entry points for things that

326
00:10:59,920 --> 00:11:02,240
can be called at run time like flash

327
00:11:02,240 --> 00:11:04,399
writing to flash and calling update code

328
00:11:04,399 --> 00:11:05,680
from user code

329
00:11:05,680 --> 00:11:07,680
the rom uses sram for holding all of

330
00:11:07,680 --> 00:11:08,560
this global state which will be

331
00:11:08,560 --> 00:11:10,959
important in a bit

332
00:11:10,959 --> 00:11:13,519
the rom also has a mode called isp or in

333
00:11:13,519 --> 00:11:15,200
system programming mode this is a

334
00:11:15,200 --> 00:11:16,959
protocol that can run over various

335
00:11:16,959 --> 00:11:19,040
hardware interfaces to be able to run a

336
00:11:19,040 --> 00:11:20,720
fixed set of commands to do things like

337
00:11:20,720 --> 00:11:23,600
write to flash or configure fuses

338
00:11:23,600 --> 00:11:26,480
importantly when in isp mode the uh the

339
00:11:26,480 --> 00:11:29,760
lp65 is responding to what's being sent

340
00:11:29,760 --> 00:11:31,839
it's a packet protocol that can send up

341
00:11:31,839 --> 00:11:34,880
to 512 bytes at a time uh you can sell

342
00:11:34,880 --> 00:11:38,160
sand less but 512 is the maximum

343
00:11:38,160 --> 00:11:40,240
this isp mode is is designed to be

344
00:11:40,240 --> 00:11:42,399
orthogonal to be improved to being a

345
00:11:42,399 --> 00:11:44,640
program be a debugger and when you're in

346
00:11:44,640 --> 00:11:46,320
isp mode you are not supposed to have

347
00:11:46,320 --> 00:11:49,360
access to either jtag or swd

348
00:11:49,360 --> 00:11:52,320
and also importantly when the cmpa mode

349
00:11:52,320 --> 00:11:54,240
is sealed i.e you're not supposed to be

350
00:11:54,240 --> 00:11:56,399
able to change any of those settings

351
00:11:56,399 --> 00:11:57,920
the only way you're supposed to be able

352
00:11:57,920 --> 00:12:00,959
to um make changes to isp mode is via a

353
00:12:00,959 --> 00:12:02,560
signed sb2

354
00:12:02,560 --> 00:12:04,480
update mechanism definitely not ominous

355
00:12:04,480 --> 00:12:05,839
there

356
00:12:05,839 --> 00:12:08,560
okay so this is a you know pretty boring

357
00:12:08,560 --> 00:12:10,720
diagram about uh what it looks like when

358
00:12:10,720 --> 00:12:13,600
the lpc is in isp mode it's sitting

359
00:12:13,600 --> 00:12:15,920
there executing commands in rom

360
00:12:15,920 --> 00:12:17,440
if we want to do an update we'd send the

361
00:12:17,440 --> 00:12:19,040
command to be able to

362
00:12:19,040 --> 00:12:20,880
start an update and then send the update

363
00:12:20,880 --> 00:12:24,079
500 bytes at a time until it's complete

364
00:12:24,079 --> 00:12:25,710
okay

365
00:12:25,710 --> 00:12:28,960
[Music]

366
00:12:32,639 --> 00:12:34,240
so let's look at how the update is

367
00:12:34,240 --> 00:12:36,399
actually parsed

368
00:12:36,399 --> 00:12:39,200
all the parsing state is stored in a 752

369
00:12:39,200 --> 00:12:41,440
byte global variable in sram

370
00:12:41,440 --> 00:12:43,360
okay there's sometimes two bytes worth

371
00:12:43,360 --> 00:12:45,440
of fields i'm just going to focus on

372
00:12:45,440 --> 00:12:47,920
some of the more interesting ones

373
00:12:47,920 --> 00:12:51,920
the first here is the 16 byte array um

374
00:12:51,920 --> 00:12:55,120
the parsing loop which i'll show shortly

375
00:12:55,120 --> 00:12:57,360
will copy 16 bytes at a time into this

376
00:12:57,360 --> 00:12:58,480
global state

377
00:12:58,480 --> 00:13:00,000
the second interesting function here is

378
00:13:00,000 --> 00:13:02,399
this callback function the parsing state

379
00:13:02,399 --> 00:13:04,000
machine works by calling this callback

380
00:13:04,000 --> 00:13:06,399
function on each of the 16 bytes

381
00:13:06,399 --> 00:13:08,720
and each function is responsible for for

382
00:13:08,720 --> 00:13:10,000
updating the global state to set the

383
00:13:10,000 --> 00:13:11,839
next function to be called

384
00:13:11,839 --> 00:13:13,680
if the global state does not get updated

385
00:13:13,680 --> 00:13:15,200
the same function will get called on the

386
00:13:15,200 --> 00:13:18,079
next 16 bytes

387
00:13:18,079 --> 00:13:19,360
here's a sample of what the

388
00:13:19,360 --> 00:13:21,120
initialization looks like

389
00:13:21,120 --> 00:13:23,279
nothing terribly interesting of mem zero

390
00:13:23,279 --> 00:13:25,519
and then setting the first function

391
00:13:25,519 --> 00:13:26,880
and then here's what an example of what

392
00:13:26,880 --> 00:13:29,360
the main update loop looks like

393
00:13:29,360 --> 00:13:31,519
we're going to copy the 16 bytes of data

394
00:13:31,519 --> 00:13:33,839
from the our input and then put it in

395
00:13:33,839 --> 00:13:36,079
the global array um again this is this

396
00:13:36,079 --> 00:13:38,000
is pseudocode there is in fact more

397
00:13:38,000 --> 00:13:39,440
actual error handling in the rom but

398
00:13:39,440 --> 00:13:40,639
this just gives you an idea about what

399
00:13:40,639 --> 00:13:42,720
this is doing at the high level

400
00:13:42,720 --> 00:13:43,680
okay

401
00:13:43,680 --> 00:13:45,600
and okay this is a screenshot from my

402
00:13:45,600 --> 00:13:48,160
annotated disassembly in guidra and this

403
00:13:48,160 --> 00:13:49,680
is the very first function to start

404
00:13:49,680 --> 00:13:52,320
parsing the header on the first 16 bytes

405
00:13:52,320 --> 00:13:54,079
bear with me on any of the names and

406
00:13:54,079 --> 00:13:55,600
other things like that this is a little

407
00:13:55,600 --> 00:13:57,440
bit like looking in a lab notebook at

408
00:13:57,440 --> 00:13:59,440
all my scribbles

409
00:13:59,440 --> 00:14:02,399
each each callback function takes

410
00:14:02,399 --> 00:14:04,720
an argument to this uh 752 by global

411
00:14:04,720 --> 00:14:06,320
header as an argument

412
00:14:06,320 --> 00:14:07,920
and so when we look at this we find

413
00:14:07,920 --> 00:14:09,920
another field in this header

414
00:14:09,920 --> 00:14:10,639
is

415
00:14:10,639 --> 00:14:11,920
another field in our global state is

416
00:14:11,920 --> 00:14:14,240
this 96 byte header

417
00:14:14,240 --> 00:14:16,399
and so what this function is doing is

418
00:14:16,399 --> 00:14:17,600
setting up a pointer to the start of

419
00:14:17,600 --> 00:14:19,120
this header

420
00:14:19,120 --> 00:14:20,880
copying over the 16 bytes we previously

421
00:14:20,880 --> 00:14:24,480
did then incrementing it then setting a

422
00:14:24,480 --> 00:14:26,639
setting callback to the next function

423
00:14:26,639 --> 00:14:28,480
and this pattern of copying bytes and

424
00:14:28,480 --> 00:14:29,680
incrementing the pointer is going to be

425
00:14:29,680 --> 00:14:32,800
common to all the functions we see

426
00:14:32,800 --> 00:14:34,959
and this is just a sample about what our

427
00:14:34,959 --> 00:14:36,399
header actually looks like global state

428
00:14:36,399 --> 00:14:37,839
actually looks like now we still have

429
00:14:37,839 --> 00:14:40,720
the callback our copy data and our 96

430
00:14:40,720 --> 00:14:43,040
byte header

431
00:14:43,040 --> 00:14:44,959
and this is a part of the second

432
00:14:44,959 --> 00:14:47,199
function you can see there's the same

433
00:14:47,199 --> 00:14:49,360
mem copy and increment pattern but this

434
00:14:49,360 --> 00:14:51,760
is also an example of where things uh

435
00:14:51,760 --> 00:14:53,519
start to go wrong

436
00:14:53,519 --> 00:14:54,959
i mentioned that this update is signed

437
00:14:54,959 --> 00:14:58,160
and encrypted but this header is not

438
00:14:58,160 --> 00:15:00,160
signed or encrypted and at this point in

439
00:15:00,160 --> 00:15:01,920
time it's literally just saving

440
00:15:01,920 --> 00:15:04,560
receiving whatever bytes we receive and

441
00:15:04,560 --> 00:15:07,120
this is completely untrusted input

442
00:15:07,120 --> 00:15:09,519
and here we see the parsing code uh just

443
00:15:09,519 --> 00:15:11,839
subtracting two from whatever we put in

444
00:15:11,839 --> 00:15:13,920
which can result in an integer underflow

445
00:15:13,920 --> 00:15:16,560
if you give the wrong value um i should

446
00:15:16,560 --> 00:15:17,760
note this was one of the first things i

447
00:15:17,760 --> 00:15:18,880
found when i started looking at this

448
00:15:18,880 --> 00:15:20,959
header but it didn't really get me

449
00:15:20,959 --> 00:15:22,720
anywhere except for

450
00:15:22,720 --> 00:15:24,240
later triggering some errors in the

451
00:15:24,240 --> 00:15:27,360
error handling code but again if you see

452
00:15:27,360 --> 00:15:28,720
one inch in your underflow it's a good

453
00:15:28,720 --> 00:15:29,839
sign that there are problems looking

454
00:15:29,839 --> 00:15:31,680
elsewhere

455
00:15:31,680 --> 00:15:33,920
and we do the third floor and oh yeah

456
00:15:33,920 --> 00:15:35,279
there's another intergenerative flow

457
00:15:35,279 --> 00:15:36,880
whoops

458
00:15:36,880 --> 00:15:38,959
and we get to the fourth flow

459
00:15:38,959 --> 00:15:41,120
fourth function and okay there's an

460
00:15:41,120 --> 00:15:43,440
integer underflow but also importantly

461
00:15:43,440 --> 00:15:45,519
here is that this value that's being

462
00:15:45,519 --> 00:15:47,120
stored is again coming straight from the

463
00:15:47,120 --> 00:15:50,240
header and is untrusted input

464
00:15:50,240 --> 00:15:51,120
okay

465
00:15:51,120 --> 00:15:53,360
and we get to this fifth function

466
00:15:53,360 --> 00:15:55,519
and if you look at this function again

467
00:15:55,519 --> 00:15:57,920
you'll see our usual pattern of uh doing

468
00:15:57,920 --> 00:16:00,240
the mem copy doing the increment

469
00:16:00,240 --> 00:16:02,639
but if you also may notice that we're

470
00:16:02,639 --> 00:16:04,959
only updating the callback in this if

471
00:16:04,959 --> 00:16:07,040
function and so this means that until we

472
00:16:07,040 --> 00:16:08,959
actually get to this if function we're

473
00:16:08,959 --> 00:16:10,720
going to continue just doing this

474
00:16:10,720 --> 00:16:13,199
increment in mem copy

475
00:16:13,199 --> 00:16:15,839
uh but you may also notice carefully

476
00:16:15,839 --> 00:16:17,040
that the value in the if condition is

477
00:16:17,040 --> 00:16:18,800
the value that came from the header

478
00:16:18,800 --> 00:16:20,959
which is untrusted input and you'll

479
00:16:20,959 --> 00:16:22,480
probably see where this is going this

480
00:16:22,480 --> 00:16:24,399
ends up being a buffer overflow if we

481
00:16:24,399 --> 00:16:26,320
set that to a sufficiently large value

482
00:16:26,320 --> 00:16:27,600
we'll just continue copying bytes

483
00:16:27,600 --> 00:16:29,199
outside of our buffer which is supposed

484
00:16:29,199 --> 00:16:31,519
to be our 96 byte header

485
00:16:31,519 --> 00:16:32,560
okay

486
00:16:32,560 --> 00:16:34,560
buffer overflows are cool but ultimately

487
00:16:34,560 --> 00:16:36,079
the question is what exactly we're going

488
00:16:36,079 --> 00:16:37,519
to do with this

489
00:16:37,519 --> 00:16:39,199
if i'm an attacker i want to get code

490
00:16:39,199 --> 00:16:41,920
execution and so we start looking around

491
00:16:41,920 --> 00:16:44,160
about okay what else is outside that we

492
00:16:44,160 --> 00:16:45,759
can overflow into

493
00:16:45,759 --> 00:16:47,759
and in outs after a global state there

494
00:16:47,759 --> 00:16:48,800
are a couple of infinite global

495
00:16:48,800 --> 00:16:50,800
variables related to heap allocation

496
00:16:50,800 --> 00:16:53,839
that turn out to be pretty handy

497
00:16:53,839 --> 00:16:54,800
okay

498
00:16:54,800 --> 00:16:57,440
the rom generally doesn't make use of

499
00:16:57,440 --> 00:16:59,279
dynamic memory allocation it's

500
00:16:59,279 --> 00:17:02,079
everything's pretty much stack allocated

501
00:17:02,079 --> 00:17:04,640
the places where there are dynamic

502
00:17:04,640 --> 00:17:07,359
memory allocation is mostly related to

503
00:17:07,359 --> 00:17:09,760
keys and uh cryptography where things

504
00:17:09,760 --> 00:17:12,160
may not be a thick no not a fixed size

505
00:17:12,160 --> 00:17:13,520
and i think also some of this is a

506
00:17:13,520 --> 00:17:16,000
fallout from the library used for

507
00:17:16,000 --> 00:17:18,079
cryptography in the rom seems to be a

508
00:17:18,079 --> 00:17:20,720
fork of embed tls as well

509
00:17:20,720 --> 00:17:22,319
so to be able to accommodate this the

510
00:17:22,319 --> 00:17:23,839
rom includes a very simple bump

511
00:17:23,839 --> 00:17:26,400
allocator that starts right this that

512
00:17:26,400 --> 00:17:27,839
allocates from the stratifical variable

513
00:17:27,839 --> 00:17:30,400
that exists literally right after our uh

514
00:17:30,400 --> 00:17:34,400
752 bike global parsing state

515
00:17:34,400 --> 00:17:36,880
and also incredibly conveniently right

516
00:17:36,880 --> 00:17:38,799
after we complete our buffer overflow uh

517
00:17:38,799 --> 00:17:42,480
there's this heat ballot called as well

518
00:17:42,480 --> 00:17:44,240
and in the very nest function next

519
00:17:44,240 --> 00:17:46,480
function after our heat palette call

520
00:17:46,480 --> 00:17:47,919
we're going to do a mem copy of our

521
00:17:47,919 --> 00:17:50,480
header into this new allocated um

522
00:17:50,480 --> 00:17:52,080
buffer

523
00:17:52,080 --> 00:17:54,080
some people may be wondering okay why is

524
00:17:54,080 --> 00:17:55,360
the code bothering to do all this

525
00:17:55,360 --> 00:17:57,840
copying and alking at all and

526
00:17:57,840 --> 00:18:00,640
this is because this is related to the

527
00:18:00,640 --> 00:18:02,400
signature verification and the code for

528
00:18:02,400 --> 00:18:04,080
signature verification

529
00:18:04,080 --> 00:18:06,320
on on updates is the same as the code

530
00:18:06,320 --> 00:18:08,960
for a signature verification on boot

531
00:18:08,960 --> 00:18:10,640
images and this requires everything

532
00:18:10,640 --> 00:18:13,360
being one contiguous block

533
00:18:13,360 --> 00:18:15,280
and signature verification also relies

534
00:18:15,280 --> 00:18:17,520
on an x509 certificate for holding the

535
00:18:17,520 --> 00:18:20,400
public key and uh x59 certificates are

536
00:18:20,400 --> 00:18:22,559
not going to be a known size so heap

537
00:18:22,559 --> 00:18:23,840
allocation is the only way to be able to

538
00:18:23,840 --> 00:18:25,760
get enough space

539
00:18:25,760 --> 00:18:26,720
okay

540
00:18:26,720 --> 00:18:28,640
uh but back to breaking things well okay

541
00:18:28,640 --> 00:18:30,080
so what do we have so far we know that

542
00:18:30,080 --> 00:18:31,600
we can overwrite the address of where

543
00:18:31,600 --> 00:18:32,880
the heap starts we know that there's a

544
00:18:32,880 --> 00:18:35,919
heap out call right afterwards um so how

545
00:18:35,919 --> 00:18:37,440
do we combine this to actually get code

546
00:18:37,440 --> 00:18:39,760
execution

547
00:18:39,760 --> 00:18:41,120
and uh

548
00:18:41,120 --> 00:18:42,880
we've we actually already have a clue

549
00:18:42,880 --> 00:18:44,480
already and it turns out to be this

550
00:18:44,480 --> 00:18:46,160
callback function that i've mentioned

551
00:18:46,160 --> 00:18:47,919
for all the parsing

552
00:18:47,919 --> 00:18:49,440
um this this

553
00:18:49,440 --> 00:18:51,840
the offset for the excuse me the

554
00:18:51,840 --> 00:18:53,760
callback function lives at offset four

555
00:18:53,760 --> 00:18:55,440
from the start of our global parsing

556
00:18:55,440 --> 00:18:56,480
state

557
00:18:56,480 --> 00:18:58,320
and if we happen to look at the

558
00:18:58,320 --> 00:19:00,480
same offset from the start of our header

559
00:19:00,480 --> 00:19:02,960
it's supposed to be used for the nonce

560
00:19:02,960 --> 00:19:04,960
but it turns out that because we found

561
00:19:04,960 --> 00:19:06,320
this issue before we've gotten to any

562
00:19:06,320 --> 00:19:08,960
kind of decryption we can go ahead and

563
00:19:08,960 --> 00:19:10,960
just put whatever we want there like say

564
00:19:10,960 --> 00:19:13,600
an address

565
00:19:14,320 --> 00:19:16,400
okay so putting all these pieces

566
00:19:16,400 --> 00:19:17,840
together um here's how we're going to

567
00:19:17,840 --> 00:19:20,080
get code execution we're going to craft

568
00:19:20,080 --> 00:19:22,799
a custom header with this key blob lock

569
00:19:22,799 --> 00:19:24,799
calculated to how much we want to copy

570
00:19:24,799 --> 00:19:26,320
outside of our bounds

571
00:19:26,320 --> 00:19:27,760
at offset 4 in this header we're going

572
00:19:27,760 --> 00:19:29,840
to put what address we want to jump to

573
00:19:29,840 --> 00:19:30,880
we're going to pad out our header to

574
00:19:30,880 --> 00:19:32,000
what we want to write to the start of

575
00:19:32,000 --> 00:19:33,360
the global structure

576
00:19:33,360 --> 00:19:35,280
and after we finish writing our

577
00:19:35,280 --> 00:19:37,760
structure it's going to do the mem copy

578
00:19:37,760 --> 00:19:41,280
which is then going to trigger uh

579
00:19:41,280 --> 00:19:42,320
the next time the loop is going to

580
00:19:42,320 --> 00:19:44,559
execute the function okay and for a

581
00:19:44,559 --> 00:19:46,559
little bit of a different visualization

582
00:19:46,559 --> 00:19:48,720
this is our global parsing state and

583
00:19:48,720 --> 00:19:51,520
right after it is it's our heap state

584
00:19:51,520 --> 00:19:53,360
we're going to do a buffer overflow

585
00:19:53,360 --> 00:19:55,840
overrider heap state for that address

586
00:19:55,840 --> 00:19:57,280
which matches with the start of our

587
00:19:57,280 --> 00:19:59,280
global parsing state so when we do our

588
00:19:59,280 --> 00:20:00,640
mem copy

589
00:20:00,640 --> 00:20:02,480
we're going to copy our sb2 header which

590
00:20:02,480 --> 00:20:04,720
has our carefully calculated address and

591
00:20:04,720 --> 00:20:06,320
it's going to execute whatever value we

592
00:20:06,320 --> 00:20:07,840
want from the header

593
00:20:07,840 --> 00:20:10,799
and this does give us code execution but

594
00:20:10,799 --> 00:20:13,280
not full execution this lets you

595
00:20:13,280 --> 00:20:16,080
redirect the pc to code in the rom

596
00:20:16,080 --> 00:20:17,679
because one of the very first things the

597
00:20:17,679 --> 00:20:20,880
rom actually does is enable mpu and seo

598
00:20:20,880 --> 00:20:23,440
protection and this restricts execution

599
00:20:23,440 --> 00:20:25,679
to only specified region of memories and

600
00:20:25,679 --> 00:20:27,600
i should be clear here i think this is a

601
00:20:27,600 --> 00:20:30,000
very good thing uh this is a fantastic

602
00:20:30,000 --> 00:20:31,679
defensive measure measure to have

603
00:20:31,679 --> 00:20:33,360
enabled

604
00:20:33,360 --> 00:20:34,559
i mean at least this is what i tell

605
00:20:34,559 --> 00:20:35,919
myself when i'm not the one trying to

606
00:20:35,919 --> 00:20:37,520
get code execution

607
00:20:37,520 --> 00:20:39,360
um but of course nobody ever you know

608
00:20:39,360 --> 00:20:42,000
got code execution by giving up

609
00:20:42,000 --> 00:20:43,600
the mpe restricts

610
00:20:43,600 --> 00:20:45,919
restricts execution to specific regions

611
00:20:45,919 --> 00:20:47,840
of memory so it's always worth asking if

612
00:20:47,840 --> 00:20:49,600
there are other readable parts of memory

613
00:20:49,600 --> 00:20:51,200
that are also executable that we could

614
00:20:51,200 --> 00:20:53,440
perhaps leverage

615
00:20:53,440 --> 00:20:54,960
and it turns out the answer to this

616
00:20:54,960 --> 00:20:57,360
question is related to the previous work

617
00:20:57,360 --> 00:20:59,440
i did with the wrong patcher

618
00:20:59,440 --> 00:21:01,039
the actual purpose of the ron patcher

619
00:21:01,039 --> 00:21:02,320
when it's not being used to violate

620
00:21:02,320 --> 00:21:04,640
security boundaries is to be able to fix

621
00:21:04,640 --> 00:21:07,280
bugs in the rom it does this by either

622
00:21:07,280 --> 00:21:08,799
doing a straight word replacement of the

623
00:21:08,799 --> 00:21:12,159
rom or by inserting an svc instruction

624
00:21:12,159 --> 00:21:14,240
typically the svc instruction is used to

625
00:21:14,240 --> 00:21:15,600
be able to go from a less privileged

626
00:21:15,600 --> 00:21:18,320
mode to a more privileged mode but it

627
00:21:18,320 --> 00:21:19,760
also turns out that it's a pretty

628
00:21:19,760 --> 00:21:22,080
convenient way to be able to go

629
00:21:22,080 --> 00:21:23,760
and inject a series of

630
00:21:23,760 --> 00:21:25,679
code that you want to put at a specific

631
00:21:25,679 --> 00:21:28,080
address

632
00:21:28,080 --> 00:21:29,679
and since the points of the wrong

633
00:21:29,679 --> 00:21:31,360
patcher is that this patch code does not

634
00:21:31,360 --> 00:21:32,559
live in rom

635
00:21:32,559 --> 00:21:34,240
uh it must be that there must be some

636
00:21:34,240 --> 00:21:36,159
point in writable memory that's also

637
00:21:36,159 --> 00:21:37,600
executable

638
00:21:37,600 --> 00:21:39,679
and it turns out that the area of memory

639
00:21:39,679 --> 00:21:41,600
where the executable lives is right at

640
00:21:41,600 --> 00:21:43,039
the end of sram where we're going to be

641
00:21:43,039 --> 00:21:44,559
buffer overflowing

642
00:21:44,559 --> 00:21:46,720
okay

643
00:21:46,720 --> 00:21:48,000
so this means that the solution to our

644
00:21:48,000 --> 00:21:50,799
problem is to do a very long write

645
00:21:50,799 --> 00:21:52,559
across the global state so instead of

646
00:21:52,559 --> 00:21:54,240
stopping when we get to the heap state

647
00:21:54,240 --> 00:21:55,840
we're going to keep writing until we

648
00:21:55,840 --> 00:21:57,360
actually get to the executable rom patch

649
00:21:57,360 --> 00:21:59,520
area um yeah we're going to be writing

650
00:21:59,520 --> 00:22:01,440
over an awful lot of our global states

651
00:22:01,440 --> 00:22:02,960
but it turns out that there most of the

652
00:22:02,960 --> 00:22:04,640
stuff there we don't care about and

653
00:22:04,640 --> 00:22:06,640
because we can control the data we can

654
00:22:06,640 --> 00:22:07,600
also

655
00:22:07,600 --> 00:22:09,200
be able to select what actually gets

656
00:22:09,200 --> 00:22:10,320
written there

657
00:22:10,320 --> 00:22:12,480
and as i was working through this um

658
00:22:12,480 --> 00:22:13,760
issue you know trying to get this to

659
00:22:13,760 --> 00:22:16,559
work uh this was working pretty well

660
00:22:16,559 --> 00:22:20,320
until i got 232 bytes from the end and i

661
00:22:20,320 --> 00:22:22,480
basically ran into a wall and uh it

662
00:22:22,480 --> 00:22:23,600
stopped

663
00:22:23,600 --> 00:22:26,480
and this is because uh the lp65 rom has

664
00:22:26,480 --> 00:22:28,720
stack canaries

665
00:22:28,720 --> 00:22:29,760
for those who haven't seen this

666
00:22:29,760 --> 00:22:31,679
defensive attack before the idea with a

667
00:22:31,679 --> 00:22:33,919
stat canary is to be able to catch stack

668
00:22:33,919 --> 00:22:36,159
overflows so at the start of your

669
00:22:36,159 --> 00:22:38,240
function you're going to write a random

670
00:22:38,240 --> 00:22:41,039
known value to the stack and then at the

671
00:22:41,039 --> 00:22:42,400
end you check if this value is still the

672
00:22:42,400 --> 00:22:44,400
same if it is you're good if not you

673
00:22:44,400 --> 00:22:46,640
panic or do some sort of other or error

674
00:22:46,640 --> 00:22:48,559
handling

675
00:22:48,559 --> 00:22:50,640
okay i should reiterate again uh i think

676
00:22:50,640 --> 00:22:52,000
seeing stat canaries is a great

677
00:22:52,000 --> 00:22:53,360
defensive measure

678
00:22:53,360 --> 00:22:54,799
um always make it harder for everybody

679
00:22:54,799 --> 00:22:57,200
to be able to do exploits but again as

680
00:22:57,200 --> 00:22:59,679
an attacker it's certainly a pain

681
00:22:59,679 --> 00:23:00,480
and

682
00:23:00,480 --> 00:23:02,960
some of you may be wondering okay this

683
00:23:02,960 --> 00:23:04,400
the buffer overflow you showed before is

684
00:23:04,400 --> 00:23:06,080
a global buffer overflow not a stack

685
00:23:06,080 --> 00:23:08,960
buffer overflow what's going on here

686
00:23:08,960 --> 00:23:10,799
and this is related to the particular

687
00:23:10,799 --> 00:23:13,520
implementation of stack canaries

688
00:23:13,520 --> 00:23:15,039
if you've seen second areas on a larger

689
00:23:15,039 --> 00:23:18,159
system such as x86 or arm64 they will

690
00:23:18,159 --> 00:23:20,080
frequently store the stack canary in a

691
00:23:20,080 --> 00:23:22,000
dedicated register just because there's

692
00:23:22,000 --> 00:23:23,600
enough register space

693
00:23:23,600 --> 00:23:25,360
but on a smaller system such as this

694
00:23:25,360 --> 00:23:27,120
microcontroller there's not enough

695
00:23:27,120 --> 00:23:28,400
registers so

696
00:23:28,400 --> 00:23:30,400
the compiler ends up putting the stack

697
00:23:30,400 --> 00:23:32,720
canary in global space so what's

698
00:23:32,720 --> 00:23:34,880
actually happening is that we are

699
00:23:34,880 --> 00:23:36,320
overriding the secondary in the global

700
00:23:36,320 --> 00:23:37,919
space and then when it goes to check it

701
00:23:37,919 --> 00:23:40,080
again later uh it's that that's when

702
00:23:40,080 --> 00:23:41,840
it's detecting um

703
00:23:41,840 --> 00:23:43,120
again i don't think the stacking area

704
00:23:43,120 --> 00:23:44,480
was intended to be this way but this

705
00:23:44,480 --> 00:23:46,159
turns out to be a pretty good way to be

706
00:23:46,159 --> 00:23:47,919
able to detect uh global smashing as

707
00:23:47,919 --> 00:23:50,320
well

708
00:23:50,320 --> 00:23:52,799
okay but uh this there turns out to be a

709
00:23:52,799 --> 00:23:55,279
workaround for this as well it turns out

710
00:23:55,279 --> 00:23:58,240
that the snek canary itself is not

711
00:23:58,240 --> 00:24:00,799
detected in the update parsing mechanism

712
00:24:00,799 --> 00:24:04,640
it's only in detected in the isp

713
00:24:04,640 --> 00:24:06,960
parsing mechanism and so what it is is

714
00:24:06,960 --> 00:24:08,720
that it's only when we go to get more

715
00:24:08,720 --> 00:24:10,640
bytes from isp mode

716
00:24:10,640 --> 00:24:13,600
that we actually detect this issue

717
00:24:13,600 --> 00:24:15,919
so the workaround here ends up being we

718
00:24:15,919 --> 00:24:17,919
do a write up it right up into the stack

719
00:24:17,919 --> 00:24:20,000
canary and then we overwrite the stack

720
00:24:20,000 --> 00:24:23,039
canary and get the executable rom area

721
00:24:23,039 --> 00:24:26,000
in one 512 byte right and this ends up

722
00:24:26,000 --> 00:24:27,600
being really lucky for us because these

723
00:24:27,600 --> 00:24:30,080
two happen to be close enough together

724
00:24:30,080 --> 00:24:31,279
okay

725
00:24:31,279 --> 00:24:33,919
so putting all of this together um we're

726
00:24:33,919 --> 00:24:35,360
going to have our custom header with an

727
00:24:35,360 --> 00:24:37,279
out of bounds field saying how much

728
00:24:37,279 --> 00:24:38,799
overflow we're going to do

729
00:24:38,799 --> 00:24:40,000
one of the fields is going to be the

730
00:24:40,000 --> 00:24:41,520
address we're going to execute that's

731
00:24:41,520 --> 00:24:44,640
going to be our executable sram area

732
00:24:44,640 --> 00:24:46,400
we're going to do our buffer overflow

733
00:24:46,400 --> 00:24:47,840
and we're going to be sending all these

734
00:24:47,840 --> 00:24:50,880
bytes over isp mode um 504 bytes at a

735
00:24:50,880 --> 00:24:52,400
time until we get right up to the stack

736
00:24:52,400 --> 00:24:53,440
canary

737
00:24:53,440 --> 00:24:55,760
and then we get to these last 512 bytes

738
00:24:55,760 --> 00:24:57,120
we're going to overwrite the stack

739
00:24:57,120 --> 00:25:00,159
canary and get the executable area in

740
00:25:00,159 --> 00:25:02,320
our executable area we're going to put

741
00:25:02,320 --> 00:25:04,240
um just a small payload to be able to

742
00:25:04,240 --> 00:25:06,480
turn off the mpu and sau and this will

743
00:25:06,480 --> 00:25:07,840
enable us to be able to jump wherever we

744
00:25:07,840 --> 00:25:08,799
want

745
00:25:08,799 --> 00:25:10,799
okay that's a lot of things and now i'm

746
00:25:10,799 --> 00:25:15,799
going to attempt to do a live demo

747
00:25:30,880 --> 00:25:33,880
um

748
00:25:43,919 --> 00:25:47,039
wow that's actually too big

749
00:25:54,799 --> 00:25:56,799
i bumped up the size anticipating it was

750
00:25:56,799 --> 00:25:58,320
going to need to do that but apparently

751
00:25:58,320 --> 00:26:01,320
not

752
00:26:30,960 --> 00:26:33,960
uh

753
00:26:38,159 --> 00:26:38,630
well

754
00:26:38,630 --> 00:26:49,760
[Music]

755
00:26:49,760 --> 00:26:52,970
i love software

756
00:26:52,970 --> 00:26:56,259
[Music]

757
00:26:59,050 --> 00:27:02,230
[Music]

758
00:27:02,880 --> 00:27:04,400
okay i'm going to skip the demo sorry

759
00:27:04,400 --> 00:27:06,480
about that but i will be around

760
00:27:06,480 --> 00:27:08,799
afterwards to be a potentially

761
00:27:08,799 --> 00:27:12,279
show this afterwards

762
00:27:34,880 --> 00:27:37,200
okay

763
00:27:38,990 --> 00:27:40,720
[Music]

764
00:27:40,720 --> 00:27:42,640
my previous job was working on fedora

765
00:27:42,640 --> 00:27:44,640
desktop so this is a little embarrassing

766
00:27:44,640 --> 00:27:47,919
as well but okay um i promise what i was

767
00:27:47,919 --> 00:27:49,360
going to demonstrate was just a little

768
00:27:49,360 --> 00:27:51,840
show about being able to go into um isp

769
00:27:51,840 --> 00:27:53,840
mode being able to access that and what

770
00:27:53,840 --> 00:27:56,159
exactly that looks like um mostly to be

771
00:27:56,159 --> 00:27:57,279
able to show exactly what the header

772
00:27:57,279 --> 00:27:58,960
looks like and be able to dump a couple

773
00:27:58,960 --> 00:28:00,960
of key registers to be able to show so

774
00:28:00,960 --> 00:28:02,320
it looks different when you have

775
00:28:02,320 --> 00:28:04,559
something on there versus not in there

776
00:28:04,559 --> 00:28:05,679
but

777
00:28:05,679 --> 00:28:06,480
okay

778
00:28:06,480 --> 00:28:08,799
but uh there's definitely an exploit um

779
00:28:08,799 --> 00:28:10,080
and the question is what exactly can

780
00:28:10,080 --> 00:28:11,600
this get you

781
00:28:11,600 --> 00:28:13,200
um when you get can get code execution

782
00:28:13,200 --> 00:28:15,360
when you shouldn't be able to um you can

783
00:28:15,360 --> 00:28:17,200
read out of the flash if you want i

784
00:28:17,200 --> 00:28:19,520
should emphasize that as far as reading

785
00:28:19,520 --> 00:28:21,440
as far as writing um

786
00:28:21,440 --> 00:28:22,720
i also like to start with what this

787
00:28:22,720 --> 00:28:24,240
can't actually get you

788
00:28:24,240 --> 00:28:26,240
you can't actually unseal the cnpa or

789
00:28:26,240 --> 00:28:27,360
npa

790
00:28:27,360 --> 00:28:30,880
this means that if you've uh sealed and

791
00:28:30,880 --> 00:28:32,480
if you sealed you can't actually change

792
00:28:32,480 --> 00:28:34,240
um what the security is enabled you

793
00:28:34,240 --> 00:28:35,600
can't change the keys that are used for

794
00:28:35,600 --> 00:28:38,080
secure boot verification

795
00:28:38,080 --> 00:28:39,279
and this also means that anything

796
00:28:39,279 --> 00:28:41,279
covered by secure boot uh can't be

797
00:28:41,279 --> 00:28:42,799
changed

798
00:28:42,799 --> 00:28:44,880
so again what can you do um definitely

799
00:28:44,880 --> 00:28:46,640
read everything out you can execute

800
00:28:46,640 --> 00:28:47,760
changes

801
00:28:47,760 --> 00:28:50,399
execute code as far as persistence um

802
00:28:50,399 --> 00:28:51,919
any flash pages that aren't covered by a

803
00:28:51,919 --> 00:28:54,159
secure boot region are failed gamed

804
00:28:54,159 --> 00:28:56,320
you can do a roll back to

805
00:28:56,320 --> 00:28:59,039
a known good signed image

806
00:28:59,039 --> 00:29:00,799
uh there's also some potential denial of

807
00:29:00,799 --> 00:29:03,679
service vectors um certainly more if you

808
00:29:03,679 --> 00:29:05,360
want to get creative

809
00:29:05,360 --> 00:29:07,360
and i should also emphasize that if

810
00:29:07,360 --> 00:29:09,440
you're running with an unsealed device

811
00:29:09,440 --> 00:29:11,679
uh basically you're pretty much out of

812
00:29:11,679 --> 00:29:13,200
luck and the device device should be

813
00:29:13,200 --> 00:29:16,240
considered completely compromised

814
00:29:16,240 --> 00:29:18,320
as far as what um oxide is concerned

815
00:29:18,320 --> 00:29:20,399
about um the most concerning for us is

816
00:29:20,399 --> 00:29:21,919
related to dice

817
00:29:21,919 --> 00:29:23,360
i've mentioned this before as a feature

818
00:29:23,360 --> 00:29:26,480
for generating ident an id dice stands

819
00:29:26,480 --> 00:29:28,960
for device identifier composition engine

820
00:29:28,960 --> 00:29:31,600
um this was a feature designed

821
00:29:31,600 --> 00:29:33,279
uh that originally came out of microsoft

822
00:29:33,279 --> 00:29:35,039
that is uh now part of the trusting

823
00:29:35,039 --> 00:29:38,000
computing group as a specification

824
00:29:38,000 --> 00:29:39,679
it's designed to be able to tie a

825
00:29:39,679 --> 00:29:42,559
device's identity to both uh a secret

826
00:29:42,559 --> 00:29:44,159
and the running code on the on the

827
00:29:44,159 --> 00:29:46,159
device and this ends up getting giving

828
00:29:46,159 --> 00:29:47,679
us some really nice properties for being

829
00:29:47,679 --> 00:29:49,760
able to do measurements

830
00:29:49,760 --> 00:29:51,760
very importantly the device secret must

831
00:29:51,760 --> 00:29:53,760
be kept secret

832
00:29:53,760 --> 00:29:55,679
exposing this secret could allow another

833
00:29:55,679 --> 00:29:57,279
device to pretend to be or root of

834
00:29:57,279 --> 00:29:59,120
thrust which again would be pretty bad

835
00:29:59,120 --> 00:30:00,000
for what we're trying to do with

836
00:30:00,000 --> 00:30:02,720
subtrusted measurements

837
00:30:02,720 --> 00:30:05,440
and to make sure the uds stays secret

838
00:30:05,440 --> 00:30:07,120
it's encoded by the puff

839
00:30:07,120 --> 00:30:09,120
puffs stands for physically unclonable

840
00:30:09,120 --> 00:30:10,720
function and takes advantage of

841
00:30:10,720 --> 00:30:12,240
randomness

842
00:30:12,240 --> 00:30:14,559
in the sram cells on the chip to create

843
00:30:14,559 --> 00:30:16,159
a fingerprint unique to a particular

844
00:30:16,159 --> 00:30:17,600
chip

845
00:30:17,600 --> 00:30:19,679
we can take data that we want to encode

846
00:30:19,679 --> 00:30:21,440
such as the device secret and combine

847
00:30:21,440 --> 00:30:22,880
that with a chip fingerprint and an

848
00:30:22,880 --> 00:30:24,080
index

849
00:30:24,080 --> 00:30:25,600
to get a value that can be safely stored

850
00:30:25,600 --> 00:30:26,880
in flash

851
00:30:26,880 --> 00:30:28,559
this means that even if you read out the

852
00:30:28,559 --> 00:30:31,039
a value that's been puff encoded you

853
00:30:31,039 --> 00:30:32,640
need to feed that device back through

854
00:30:32,640 --> 00:30:35,039
the puff on that particular device to be

855
00:30:35,039 --> 00:30:37,360
able to get back the value

856
00:30:37,360 --> 00:30:39,279
okay and to make sure you really can't

857
00:30:39,279 --> 00:30:41,840
get access to the uds the rom locks

858
00:30:41,840 --> 00:30:43,840
access to the key index used to encode

859
00:30:43,840 --> 00:30:46,159
the uds this is what i was going to dump

860
00:30:46,159 --> 00:30:48,000
with a demo um

861
00:30:48,000 --> 00:30:50,640
but this is a this is the key block

862
00:30:50,640 --> 00:30:53,679
register um for the puff uh there's a

863
00:30:53,679 --> 00:30:55,039
lot of different fields here what's

864
00:30:55,039 --> 00:30:56,799
important here with this value is that

865
00:30:56,799 --> 00:30:58,320
the topics are saying this entire

866
00:30:58,320 --> 00:31:00,080
register is locked and can't be changed

867
00:31:00,080 --> 00:31:02,399
until the next power up and the six

868
00:31:02,399 --> 00:31:04,960
there indicates that key index 15

869
00:31:04,960 --> 00:31:07,919
correspond to the uds is locked

870
00:31:07,919 --> 00:31:09,519
but it turns out at this time we do the

871
00:31:09,519 --> 00:31:10,720
exploit

872
00:31:10,720 --> 00:31:12,480
the uds itself has not actually been

873
00:31:12,480 --> 00:31:14,000
locked and which means that we could

874
00:31:14,000 --> 00:31:16,240
potentially read it out and uh read out

875
00:31:16,240 --> 00:31:18,559
this unique device secret

876
00:31:18,559 --> 00:31:19,360
um

877
00:31:19,360 --> 00:31:21,120
not but i and i should also note that

878
00:31:21,120 --> 00:31:22,880
not having this locked at the point

879
00:31:22,880 --> 00:31:24,559
we're doing this exploit isn't

880
00:31:24,559 --> 00:31:26,799
necessarily a bug with the uds itself or

881
00:31:26,799 --> 00:31:28,880
dice it's really a consequence of how

882
00:31:28,880 --> 00:31:30,159
dice works

883
00:31:30,159 --> 00:31:31,760
we need the hash of the running image in

884
00:31:31,760 --> 00:31:34,880
order to calculate our final dice value

885
00:31:34,880 --> 00:31:36,159
but of course the time we're doing this

886
00:31:36,159 --> 00:31:39,039
we don't actually have the um

887
00:31:39,039 --> 00:31:40,880
image value because we're doing an image

888
00:31:40,880 --> 00:31:41,919
update

889
00:31:41,919 --> 00:31:42,960
um

890
00:31:42,960 --> 00:31:44,399
i could think of some ways you could

891
00:31:44,399 --> 00:31:46,080
potentially work around this such as

892
00:31:46,080 --> 00:31:47,760
locking access to the uds before you

893
00:31:47,760 --> 00:31:49,679
actually do a software update but that

894
00:31:49,679 --> 00:31:51,760
also has some other implications

895
00:31:51,760 --> 00:31:54,720
for how isp mobile potentially works and

896
00:31:54,720 --> 00:31:55,840
there's a lot of things you may need to

897
00:31:55,840 --> 00:31:58,480
sequence there but okay

898
00:31:58,480 --> 00:32:01,039
so this fix is uh kind of bad so the

899
00:32:01,039 --> 00:32:02,720
question is what exactly we do to try

900
00:32:02,720 --> 00:32:04,000
and fix this

901
00:32:04,000 --> 00:32:06,080
all this code is in rom so any actual

902
00:32:06,080 --> 00:32:07,360
fixtures is going to involve new

903
00:32:07,360 --> 00:32:08,399
hardware

904
00:32:08,399 --> 00:32:10,000
but thankfully we find ourselves living

905
00:32:10,000 --> 00:32:12,080
in a time with plentiful silicon and

906
00:32:12,080 --> 00:32:14,640
definitely not 100 week lead times

907
00:32:14,640 --> 00:32:15,440
um

908
00:32:15,440 --> 00:32:17,120
okay less sarcastically i should make it

909
00:32:17,120 --> 00:32:19,039
clear that uh nxp did agree with our

910
00:32:19,039 --> 00:32:22,320
findings and agreed to deliver a fix but

911
00:32:22,320 --> 00:32:24,000
even in the best of circumstances

912
00:32:24,000 --> 00:32:25,519
delivering a hardware effects will is

913
00:32:25,519 --> 00:32:27,120
going to take time

914
00:32:27,120 --> 00:32:29,039
and oxide is still trying to ship a

915
00:32:29,039 --> 00:32:30,000
product

916
00:32:30,000 --> 00:32:32,399
my actual job is writing firmware not

917
00:32:32,399 --> 00:32:34,480
just finding bugs and chips i am

918
00:32:34,480 --> 00:32:36,240
grateful that oxide does see this work

919
00:32:36,240 --> 00:32:37,600
as valuable

920
00:32:37,600 --> 00:32:39,039
i think everybody should feel confident

921
00:32:39,039 --> 00:32:40,159
telling their boss they got code

922
00:32:40,159 --> 00:32:41,840
execution instead of working on anything

923
00:32:41,840 --> 00:32:43,760
else that will actually bring in revenue

924
00:32:43,760 --> 00:32:46,240
um but i will also say that the novelty

925
00:32:46,240 --> 00:32:48,159
of finding bugs in this particular chip

926
00:32:48,159 --> 00:32:50,480
has really worn off uh this is the

927
00:32:50,480 --> 00:32:53,360
second issue we found with this chip and

928
00:32:53,360 --> 00:32:54,880
this is very important work but it

929
00:32:54,880 --> 00:32:56,960
really does take time away from shipping

930
00:32:56,960 --> 00:32:59,120
a product

931
00:32:59,120 --> 00:33:00,480
and usually at this point someone goes

932
00:33:00,480 --> 00:33:03,519
okay you found two cves why are you

933
00:33:03,519 --> 00:33:05,600
still using this ship at all which is a

934
00:33:05,600 --> 00:33:07,919
very fair question

935
00:33:07,919 --> 00:33:09,840
we selected this ship back in spring

936
00:33:09,840 --> 00:33:12,480
2020 and we still have all our internal

937
00:33:12,480 --> 00:33:14,559
notes about what we did this is why we

938
00:33:14,559 --> 00:33:15,919
selected it

939
00:33:15,919 --> 00:33:18,000
and it turns out even back then there

940
00:33:18,000 --> 00:33:19,840
were a fairly limited number of chips

941
00:33:19,840 --> 00:33:21,840
that met our requirements

942
00:33:21,840 --> 00:33:24,000
and even before we ran into the silicon

943
00:33:24,000 --> 00:33:26,320
rods we ruled out a non-zero number of

944
00:33:26,320 --> 00:33:27,840
them simply because we couldn't get

945
00:33:27,840 --> 00:33:29,200
hands on hardware the only thing we

946
00:33:29,200 --> 00:33:31,440
could get were data sheets

947
00:33:31,440 --> 00:33:33,440
okay uh after we found this buffer

948
00:33:33,440 --> 00:33:35,440
overflow we did seriously consider

949
00:33:35,440 --> 00:33:37,360
trying to switch to a new chip but at

950
00:33:37,360 --> 00:33:40,080
least for now we've decided against it

951
00:33:40,080 --> 00:33:40,960
um

952
00:33:40,960 --> 00:33:43,279
at least for among other reasons because

953
00:33:43,279 --> 00:33:45,440
we know the lpc55

954
00:33:45,440 --> 00:33:47,440
all too well at this point

955
00:33:47,440 --> 00:33:49,519
introducing a new chip at um at any

956
00:33:49,519 --> 00:33:51,039
point of product cycle always brings in

957
00:33:51,039 --> 00:33:53,360
risk and that would involve new chip

958
00:33:53,360 --> 00:33:55,440
involved having to redo all of our

959
00:33:55,440 --> 00:33:57,120
software work and all of our hardware

960
00:33:57,120 --> 00:33:59,200
integration work we've already done

961
00:33:59,200 --> 00:34:00,720
and there's no guarantee that any ship

962
00:34:00,720 --> 00:34:02,720
we chose would actually be better it

963
00:34:02,720 --> 00:34:05,679
could have even worse bugs or flaws and

964
00:34:05,679 --> 00:34:07,039
this is of course assuming we'd even get

965
00:34:07,039 --> 00:34:08,480
our hands on silicon that we actually

966
00:34:08,480 --> 00:34:10,480
wanted

967
00:34:10,480 --> 00:34:12,239
so until we actually get fixed chips

968
00:34:12,239 --> 00:34:14,879
we're stuck mitigating these issues

969
00:34:14,879 --> 00:34:16,159
when it came time for mitigations a

970
00:34:16,159 --> 00:34:17,359
couple of different issues got thrown

971
00:34:17,359 --> 00:34:18,560
around

972
00:34:18,560 --> 00:34:21,119
if the issue is just that the header

973
00:34:21,119 --> 00:34:22,800
isn't being validated could we validate

974
00:34:22,800 --> 00:34:24,399
the header ourselves

975
00:34:24,399 --> 00:34:26,399
and the answer there is theoretically

976
00:34:26,399 --> 00:34:27,599
yes

977
00:34:27,599 --> 00:34:29,199
uh if you treat the sb2 update

978
00:34:29,199 --> 00:34:31,119
functionality like a function such as

979
00:34:31,119 --> 00:34:32,560
memcopy that we need to get all the

980
00:34:32,560 --> 00:34:34,800
arguments right

981
00:34:34,800 --> 00:34:36,399
you could catch issues with the sb2

982
00:34:36,399 --> 00:34:38,639
update but the question then becomes

983
00:34:38,639 --> 00:34:41,679
what exactly is doing the validation

984
00:34:41,679 --> 00:34:43,679
and this isp mode involves having

985
00:34:43,679 --> 00:34:45,679
another target send data and so that

986
00:34:45,679 --> 00:34:47,040
would involve having another target do

987
00:34:47,040 --> 00:34:48,800
our validation which is the opposite of

988
00:34:48,800 --> 00:34:50,079
what we want for a root of trust where

989
00:34:50,079 --> 00:34:51,520
we want to say okay we want to trust

990
00:34:51,520 --> 00:34:54,000
this small amount of code and hardware

991
00:34:54,000 --> 00:34:56,239
as possible

992
00:34:56,239 --> 00:34:57,920
it is possible to invoke the update code

993
00:34:57,920 --> 00:34:59,920
from the chip itself without actually

994
00:34:59,920 --> 00:35:01,760
using isp mode

995
00:35:01,760 --> 00:35:02,880
this can potentially allow us to

996
00:35:02,880 --> 00:35:04,240
validate the header

997
00:35:04,240 --> 00:35:05,920
and check the and and also check the

998
00:35:05,920 --> 00:35:07,440
signature

999
00:35:07,440 --> 00:35:09,040
checking the signature is something that

1000
00:35:09,040 --> 00:35:11,680
nxp recommends for a workaround for this

1001
00:35:11,680 --> 00:35:12,400
but

1002
00:35:12,400 --> 00:35:14,079
i think it's also important to remember

1003
00:35:14,079 --> 00:35:15,760
what signature checking actually tells

1004
00:35:15,760 --> 00:35:16,560
you

1005
00:35:16,560 --> 00:35:18,720
a public key signature verification will

1006
00:35:18,720 --> 00:35:20,960
give you authenticity guarantees but

1007
00:35:20,960 --> 00:35:22,320
will not tell you anything about whether

1008
00:35:22,320 --> 00:35:24,720
that data is actually correct

1009
00:35:24,720 --> 00:35:26,560
i've certainly signed some bogus code

1010
00:35:26,560 --> 00:35:28,480
for testing when i've been doing my

1011
00:35:28,480 --> 00:35:30,480
development

1012
00:35:30,480 --> 00:35:32,240
and i realize what if someone signs some

1013
00:35:32,240 --> 00:35:34,560
bogus code is a fairly specific threat

1014
00:35:34,560 --> 00:35:36,240
but oxide is building something fairly

1015
00:35:36,240 --> 00:35:37,839
specific and there's something that was

1016
00:35:37,839 --> 00:35:39,920
worth considering from our perspective

1017
00:35:39,920 --> 00:35:40,800
okay

1018
00:35:40,800 --> 00:35:42,640
but let's say that oxide just did decide

1019
00:35:42,640 --> 00:35:44,560
that we want to check the signature uh

1020
00:35:44,560 --> 00:35:47,040
i'm ruled out using isp mode which means

1021
00:35:47,040 --> 00:35:48,400
that we're going to invoke the update

1022
00:35:48,400 --> 00:35:51,599
code from our own flash

1023
00:35:51,599 --> 00:35:53,599
okay this means since we're now doing in

1024
00:35:53,599 --> 00:35:54,640
flash we're probably going to do

1025
00:35:54,640 --> 00:35:56,640
something like say splitting our own

1026
00:35:56,640 --> 00:35:59,280
flash in half and we're going to come up

1027
00:35:59,280 --> 00:36:00,480
with a way to be able to send the data

1028
00:36:00,480 --> 00:36:02,960
back and forth and then do with version

1029
00:36:02,960 --> 00:36:05,359
image versioning and wait a minute why

1030
00:36:05,359 --> 00:36:06,720
exactly are we doing all this work to be

1031
00:36:06,720 --> 00:36:09,440
able to use a potentially buggy api

1032
00:36:09,440 --> 00:36:11,599
and this brought us to

1033
00:36:11,599 --> 00:36:13,440
our final conclusion that while the

1034
00:36:13,440 --> 00:36:14,640
update feature would have been really

1035
00:36:14,640 --> 00:36:17,359
nice to use it loses a lot of its value

1036
00:36:17,359 --> 00:36:18,640
if we have to do all this validation

1037
00:36:18,640 --> 00:36:20,880
ourselves it turned out to be much

1038
00:36:20,880 --> 00:36:22,480
easier for us to be able to write our

1039
00:36:22,480 --> 00:36:24,560
own update mechanism

1040
00:36:24,560 --> 00:36:26,000
rather than try and force an existing

1041
00:36:26,000 --> 00:36:27,280
one

1042
00:36:27,280 --> 00:36:29,280
and this is where the title of this talk

1043
00:36:29,280 --> 00:36:31,680
uh unwanted features comes from if your

1044
00:36:31,680 --> 00:36:33,760
update mechanism can be used to uh get

1045
00:36:33,760 --> 00:36:35,760
code execution it's not a feature your

1046
00:36:35,760 --> 00:36:37,119
customers are going to want to run which

1047
00:36:37,119 --> 00:36:39,280
is kind of unfortunate

1048
00:36:39,280 --> 00:36:41,599
okay um some takeaways here

1049
00:36:41,599 --> 00:36:43,520
validate your input

1050
00:36:43,520 --> 00:36:45,440
this is kind of obvious but it's really

1051
00:36:45,440 --> 00:36:46,720
worth reiterating that you need to

1052
00:36:46,720 --> 00:36:48,000
carefully consider your security

1053
00:36:48,000 --> 00:36:51,280
boundaries and even especially for code

1054
00:36:51,280 --> 00:36:52,720
which has been around for perhaps you

1055
00:36:52,720 --> 00:36:54,960
know ten tens of years like uh this

1056
00:36:54,960 --> 00:36:57,119
format is um you really gotta think

1057
00:36:57,119 --> 00:36:59,520
about what else might be there

1058
00:36:59,520 --> 00:37:01,760
and fixing roms is even harder than

1059
00:37:01,760 --> 00:37:03,920
fixing software so you need to be doubly

1060
00:37:03,920 --> 00:37:05,680
careful about how exactly your rom is

1061
00:37:05,680 --> 00:37:07,440
validating input

1062
00:37:07,440 --> 00:37:09,920
there's an argument to be made that the

1063
00:37:09,920 --> 00:37:11,280
correct amount of code to have in your

1064
00:37:11,280 --> 00:37:13,839
rom is zero uh because you can't have

1065
00:37:13,839 --> 00:37:15,839
bugs if there's no code

1066
00:37:15,839 --> 00:37:17,760
um and i realize this may be an

1067
00:37:17,760 --> 00:37:20,000
unrealistic proposition so i go for

1068
00:37:20,000 --> 00:37:22,000
something a little bit different and say

1069
00:37:22,000 --> 00:37:23,520
that if you're going to be delivering

1070
00:37:23,520 --> 00:37:25,200
ram in your code you should also be

1071
00:37:25,200 --> 00:37:26,960
delivering a source code that can be

1072
00:37:26,960 --> 00:37:30,000
audited by anyone

1073
00:37:31,760 --> 00:37:33,520
chip makers like nxp come up with these

1074
00:37:33,520 --> 00:37:35,520
hardware features because customers are

1075
00:37:35,520 --> 00:37:37,040
asking for them i don't want the

1076
00:37:37,040 --> 00:37:38,560
takeaway from the talk to be that all

1077
00:37:38,560 --> 00:37:40,960
rom use rom feature features everywhere

1078
00:37:40,960 --> 00:37:42,480
are completely useless i don't think

1079
00:37:42,480 --> 00:37:43,599
that's true

1080
00:37:43,599 --> 00:37:45,040
but the thing is is that a lot of people

1081
00:37:45,040 --> 00:37:46,720
are reluctant to use them just because

1082
00:37:46,720 --> 00:37:48,320
they've had bad experiences with them

1083
00:37:48,320 --> 00:37:50,720
being buggy and delivering source code

1084
00:37:50,720 --> 00:37:52,000
for your rom there's no guarantee of

1085
00:37:52,000 --> 00:37:53,839
correctness but it's a good way to help

1086
00:37:53,839 --> 00:37:55,119
your customer convince your customers

1087
00:37:55,119 --> 00:37:56,880
that it is correct and they will want to

1088
00:37:56,880 --> 00:37:59,200
use it

1089
00:37:59,200 --> 00:38:01,520
uh several things needs to go right or

1090
00:38:01,520 --> 00:38:03,040
wrong depending on your perspective to

1091
00:38:03,040 --> 00:38:05,119
be able to turn this buffer overflow

1092
00:38:05,119 --> 00:38:06,800
into execution

1093
00:38:06,800 --> 00:38:08,960
having the npu on was a very good thing

1094
00:38:08,960 --> 00:38:10,800
uh having the stat canary is also a very

1095
00:38:10,800 --> 00:38:12,240
good defensive measure

1096
00:38:12,240 --> 00:38:13,599
i think i got really lucky with the

1097
00:38:13,599 --> 00:38:14,800
layout of the global space you might

1098
00:38:14,800 --> 00:38:16,400
have had to get more creative to be able

1099
00:38:16,400 --> 00:38:18,480
to work around that

1100
00:38:18,480 --> 00:38:19,920
you should always come up with assume

1101
00:38:19,920 --> 00:38:21,040
that someone is going to be able to find

1102
00:38:21,040 --> 00:38:22,960
a bug and make it hard to be able to do

1103
00:38:22,960 --> 00:38:25,599
anything with it

1104
00:38:25,680 --> 00:38:28,640
and there's not one single approach for

1105
00:38:28,640 --> 00:38:30,560
mitigating an issue you found

1106
00:38:30,560 --> 00:38:32,079
like i said oxide is building something

1107
00:38:32,079 --> 00:38:34,240
very specific it made sense for us to be

1108
00:38:34,240 --> 00:38:36,400
able to take the most cautious approach

1109
00:38:36,400 --> 00:38:38,320
if our entire product product was based

1110
00:38:38,320 --> 00:38:40,000
around the lpc55 we might have made a

1111
00:38:40,000 --> 00:38:41,680
different choice

1112
00:38:41,680 --> 00:38:42,960
in an alternate universe i could

1113
00:38:42,960 --> 00:38:44,240
actually imagine that we may have run

1114
00:38:44,240 --> 00:38:45,200
into

1115
00:38:45,200 --> 00:38:47,440
other unfortunate delays and it might

1116
00:38:47,440 --> 00:38:49,119
have given us enough time to be able to

1117
00:38:49,119 --> 00:38:52,400
swap out the lp65 for another chip and

1118
00:38:52,400 --> 00:38:54,160
um be able to integrate it that way

1119
00:38:54,160 --> 00:38:55,280
again there's so many different

1120
00:38:55,280 --> 00:38:56,640
possibilities

1121
00:38:56,640 --> 00:38:58,240
um ultimately it comes down to thinking

1122
00:38:58,240 --> 00:39:00,560
about what are your what's your product

1123
00:39:00,560 --> 00:39:02,240
and uh what is it trying to accomplish

1124
00:39:02,240 --> 00:39:03,200
and what's going to be best for your

1125
00:39:03,200 --> 00:39:04,400
customers

1126
00:39:04,400 --> 00:39:06,400
i don't wish chip bugs on anyone

1127
00:39:06,400 --> 00:39:07,920
building a product but i hope this has

1128
00:39:07,920 --> 00:39:09,200
been some food for thought on my

1129
00:39:09,200 --> 00:39:10,400
experience

1130
00:39:10,400 --> 00:39:12,820
so thank you

1131
00:39:12,820 --> 00:39:17,760
[Applause]

1132
00:39:17,760 --> 00:39:18,990
do we have any questions

1133
00:39:18,990 --> 00:39:20,960
[Applause]

1134
00:39:20,960 --> 00:39:23,280
you can bring the mic

1135
00:39:23,280 --> 00:39:26,280
okay

1136
00:39:29,680 --> 00:39:30,640
hello

1137
00:39:30,640 --> 00:39:34,240
was the stack canary value uh chosen

1138
00:39:34,240 --> 00:39:36,800
randomly at runtime or is it fixed

1139
00:39:36,800 --> 00:39:38,960
uh that's an a good question the stack

1140
00:39:38,960 --> 00:39:41,359
canary itself is

1141
00:39:41,359 --> 00:39:43,359
randomized at runtime and it is the

1142
00:39:43,359 --> 00:39:45,520
secondary is actually implemented as a

1143
00:39:45,520 --> 00:39:47,440
rom patch feature as well

1144
00:39:47,440 --> 00:39:50,079
okay thank you

1145
00:39:50,320 --> 00:39:51,850
any last question

1146
00:39:51,850 --> 00:39:53,520
[Music]

1147
00:39:53,520 --> 00:39:57,839
okay thank you laura thank you

