1
00:00:03,280 --> 00:00:05,200
yeah so hey everyone welcome to my

2
00:00:05,200 --> 00:00:07,600
presentation about bdjb

3
00:00:07,600 --> 00:00:09,840
my name is andy nguyen also known as the

4
00:00:09,840 --> 00:00:11,440
flow in social media

5
00:00:11,440 --> 00:00:13,200
and today i'm going to talk about the

6
00:00:13,200 --> 00:00:15,599
very first blu-ray disc java sandbox

7
00:00:15,599 --> 00:00:16,960
escape

8
00:00:16,960 --> 00:00:18,560
different from other talks at this

9
00:00:18,560 --> 00:00:20,480
conference mine will be about higher

10
00:00:20,480 --> 00:00:23,119
level vulnerabilities

11
00:00:23,119 --> 00:00:25,439
the content is the following first i

12
00:00:25,439 --> 00:00:27,680
will give an introduction about myself

13
00:00:27,680 --> 00:00:30,480
and the motivation behind this work then

14
00:00:30,480 --> 00:00:32,479
i will briefly cover the java security

15
00:00:32,479 --> 00:00:34,880
model and i will present vulnerabilities

16
00:00:34,880 --> 00:00:36,800
that i have discovered which allowed me

17
00:00:36,800 --> 00:00:39,040
to escape the sandbox

18
00:00:39,040 --> 00:00:41,280
next i will explain how i got native

19
00:00:41,280 --> 00:00:42,640
code execution

20
00:00:42,640 --> 00:00:44,960
and how i even managed to get arbitrary

21
00:00:44,960 --> 00:00:46,640
code execution

22
00:00:46,640 --> 00:00:48,879
and finally there will be a recap and

23
00:00:48,879 --> 00:00:51,120
even a live demo

24
00:00:51,120 --> 00:00:52,879
all right about myself

25
00:00:52,879 --> 00:00:54,879
i'm an information security engineer at

26
00:00:54,879 --> 00:00:55,760
google

27
00:00:55,760 --> 00:00:58,079
doing cloud vulnerability research we

28
00:00:58,079 --> 00:01:01,039
focus on low level security

29
00:01:01,039 --> 00:01:02,879
we actually have open head count in our

30
00:01:02,879 --> 00:01:05,040
team so if you are interested feel free

31
00:01:05,040 --> 00:01:06,159
to reach out

32
00:01:06,159 --> 00:01:08,000
after the talk

33
00:01:08,000 --> 00:01:10,400
i'm also a playstation hacker and have

34
00:01:10,400 --> 00:01:13,520
been in the scene for over 10 years

35
00:01:13,520 --> 00:01:15,920
for the psvita i have released multiple

36
00:01:15,920 --> 00:01:17,759
jailbreaks which allow people to run

37
00:01:17,759 --> 00:01:20,240
homebrews on their devices

38
00:01:20,240 --> 00:01:22,720
and the latest work is the gta san

39
00:01:22,720 --> 00:01:24,080
andreas port

40
00:01:24,080 --> 00:01:25,840
where i managed to load the android

41
00:01:25,840 --> 00:01:28,240
binary on the ps vita

42
00:01:28,240 --> 00:01:31,200
and made the game fully playable

43
00:01:31,200 --> 00:01:32,640
for the ps4

44
00:01:32,640 --> 00:01:34,799
i have mainly focused on freebsd kernel

45
00:01:34,799 --> 00:01:36,079
exploitation

46
00:01:36,079 --> 00:01:37,439
and for example the last three

47
00:01:37,439 --> 00:01:39,600
jailbreaks are abusing kernel blocks

48
00:01:39,600 --> 00:01:41,920
found by me

49
00:01:41,920 --> 00:01:44,159
what was the motivation behind this work

50
00:01:44,159 --> 00:01:46,159
of course as a playstation hacker i

51
00:01:46,159 --> 00:01:48,479
wanted to hack the ps5

52
00:01:48,479 --> 00:01:51,360
all public user land exploits so far

53
00:01:51,360 --> 00:01:55,200
were using webkit as the entry point

54
00:01:55,200 --> 00:01:58,560
however the ps5 amd cpu now supports

55
00:01:58,560 --> 00:02:00,479
execute only memory

56
00:02:00,479 --> 00:02:02,719
and it is enabled for the text segments

57
00:02:02,719 --> 00:02:04,799
of all modules

58
00:02:04,799 --> 00:02:06,880
this mitigation makes

59
00:02:06,880 --> 00:02:08,720
a webkit exploit much more difficult to

60
00:02:08,720 --> 00:02:10,000
pull off

61
00:02:10,000 --> 00:02:12,400
the main reason is that jit is not

62
00:02:12,400 --> 00:02:14,800
enabled in the render process

63
00:02:14,800 --> 00:02:16,800
so so we need a rock chain in order to

64
00:02:16,800 --> 00:02:17,840
get

65
00:02:17,840 --> 00:02:20,160
native code execution

66
00:02:20,160 --> 00:02:22,239
however since we are blinds we cannot

67
00:02:22,239 --> 00:02:24,879
read any executable pages and hence

68
00:02:24,879 --> 00:02:28,160
cannot identify rob gadgets

69
00:02:28,160 --> 00:02:31,280
the other reason is that the webkit

70
00:02:31,280 --> 00:02:34,800
sandbox has improved lately for example

71
00:02:34,800 --> 00:02:38,080
access to dev files has been restricted

72
00:02:38,080 --> 00:02:40,239
and apparently some syscalls like io

73
00:02:40,239 --> 00:02:43,599
control are now blocked

74
00:02:43,599 --> 00:02:45,599
however the main motivation was to

75
00:02:45,599 --> 00:02:47,360
explore different attack vectors on the

76
00:02:47,360 --> 00:02:48,720
ps4

77
00:02:48,720 --> 00:02:50,879
i wanted to work on a novel technique

78
00:02:50,879 --> 00:02:53,120
one involving physical access using a

79
00:02:53,120 --> 00:02:55,680
usb device or a disk

80
00:02:55,680 --> 00:02:56,959
and for these

81
00:02:56,959 --> 00:02:58,400
exploiting the file system is a

82
00:02:58,400 --> 00:03:00,159
possibility

83
00:03:00,159 --> 00:03:01,760
as their implementations are in the

84
00:03:01,760 --> 00:03:03,920
kernel a successful attack there

85
00:03:03,920 --> 00:03:07,200
immediately grants you kernel privileges

86
00:03:07,200 --> 00:03:09,360
however that is quite difficult

87
00:03:09,360 --> 00:03:11,040
especially blindly

88
00:03:11,040 --> 00:03:13,200
because we somehow need to determine

89
00:03:13,200 --> 00:03:15,519
addresses make calculations and in

90
00:03:15,519 --> 00:03:18,400
particular to bypass aslr

91
00:03:18,400 --> 00:03:20,560
for that having scripting capabilities

92
00:03:20,560 --> 00:03:21,599
would be

93
00:03:21,599 --> 00:03:24,000
of desire

94
00:03:24,000 --> 00:03:26,319
it turns out that blu-ray discs can run

95
00:03:26,319 --> 00:03:28,879
java codes which is a very interesting

96
00:03:28,879 --> 00:03:32,000
attack service

97
00:03:32,000 --> 00:03:34,319
what is blu-ray disc java or in short

98
00:03:34,319 --> 00:03:35,840
bdj

99
00:03:35,840 --> 00:03:38,720
it is supported on the ps3 to ps5 on the

100
00:03:38,720 --> 00:03:41,760
xbox one xbox series x and other blu-ray

101
00:03:41,760 --> 00:03:43,360
players

102
00:03:43,360 --> 00:03:45,680
it is used for advanced content such as

103
00:03:45,680 --> 00:03:47,120
games menus

104
00:03:47,120 --> 00:03:50,000
and interactive videos

105
00:03:50,000 --> 00:03:52,239
and there are tools publicly available

106
00:03:52,239 --> 00:03:56,239
for compiling and signing such jar files

107
00:03:56,239 --> 00:03:57,840
where the jar files

108
00:03:57,840 --> 00:03:59,840
when you sign jar files simply have a

109
00:03:59,840 --> 00:04:02,000
bit more permissions and for example can

110
00:04:02,000 --> 00:04:04,239
access the persistent storage or the

111
00:04:04,239 --> 00:04:06,159
network

112
00:04:06,159 --> 00:04:07,840
more details can be found at

113
00:04:07,840 --> 00:04:10,720
blueplay.com

114
00:04:10,720 --> 00:04:13,439
what is the attack surface of bdj

115
00:04:13,439 --> 00:04:15,439
we have three main attack vectors we

116
00:04:15,439 --> 00:04:17,839
have the jvm which parses and executes

117
00:04:17,839 --> 00:04:20,798
the java byte code we have tni functions

118
00:04:20,798 --> 00:04:22,800
with which are native methods

119
00:04:22,800 --> 00:04:25,680
and we have java classes

120
00:04:25,680 --> 00:04:29,440
for jvm we can search for open jdk cves

121
00:04:29,440 --> 00:04:31,440
and look for look out for type

122
00:04:31,440 --> 00:04:33,919
confusions memory corruption bugs

123
00:04:33,919 --> 00:04:35,440
however there are not many proof of

124
00:04:35,440 --> 00:04:38,160
concepts available for these

125
00:04:38,160 --> 00:04:40,400
for gni functions we can search for

126
00:04:40,400 --> 00:04:42,560
memory corruption box in the c plus

127
00:04:42,560 --> 00:04:44,000
implementations

128
00:04:44,000 --> 00:04:46,320
namely the bdj stack

129
00:04:46,320 --> 00:04:48,880
has a lot of native functions

130
00:04:48,880 --> 00:04:51,199
however that requires a lot of reverse

131
00:04:51,199 --> 00:04:53,120
engineering

132
00:04:53,120 --> 00:04:55,280
and finally for java classes we can

133
00:04:55,280 --> 00:04:57,440
search for java privilege escalation

134
00:04:57,440 --> 00:04:58,560
bugs

135
00:04:58,560 --> 00:05:00,800
while it's only a small attack service

136
00:05:00,800 --> 00:05:03,680
it is obvious what to look for

137
00:05:03,680 --> 00:05:05,520
and that is the attack vector that i

138
00:05:05,520 --> 00:05:07,199
focused on for two months

139
00:05:07,199 --> 00:05:11,280
and found multiple vulnerabilities for

140
00:05:11,280 --> 00:05:13,360
as a setup for the for this research i

141
00:05:13,360 --> 00:05:16,720
ordered a bd burner and some bdre disks

142
00:05:16,720 --> 00:05:19,440
note that bdr disks are only writable

143
00:05:19,440 --> 00:05:21,039
ones so

144
00:05:21,039 --> 00:05:23,039
especially since you cannot load classes

145
00:05:23,039 --> 00:05:25,120
remotely you have to burn the disk again

146
00:05:25,120 --> 00:05:28,960
and again for every single test

147
00:05:29,120 --> 00:05:31,520
now let me briefly introduce you to the

148
00:05:31,520 --> 00:05:34,320
core concepts of the java security model

149
00:05:34,320 --> 00:05:36,240
for that i will paraphrase a few

150
00:05:36,240 --> 00:05:39,759
sentences from the java documentation

151
00:05:39,759 --> 00:05:41,759
the java security model is based on

152
00:05:41,759 --> 00:05:43,440
controlling the operations that the

153
00:05:43,440 --> 00:05:46,240
class can perform when it is loaded into

154
00:05:46,240 --> 00:05:47,840
a running environment

155
00:05:47,840 --> 00:05:49,840
for this reason this model is called

156
00:05:49,840 --> 00:05:52,400
code centric or code based

157
00:05:52,400 --> 00:05:54,720
a security model policy defines the

158
00:05:54,720 --> 00:05:57,759
protection domains of an environment

159
00:05:57,759 --> 00:05:59,840
and a protection domain associates

160
00:05:59,840 --> 00:06:02,319
permissions with code source

161
00:06:02,319 --> 00:06:04,880
the tldr is every class file is

162
00:06:04,880 --> 00:06:07,600
associated with certain permissions

163
00:06:07,600 --> 00:06:10,000
for example bootstrap classes have full

164
00:06:10,000 --> 00:06:12,800
permissions while untrusted classes like

165
00:06:12,800 --> 00:06:16,800
ours on the blu-ray disk have a few only

166
00:06:16,800 --> 00:06:18,880
an important component of the java

167
00:06:18,880 --> 00:06:22,800
sandbox is the access controller

168
00:06:22,960 --> 00:06:24,400
which is used for access control

169
00:06:24,400 --> 00:06:27,199
operations and decisions

170
00:06:27,199 --> 00:06:29,199
there are two main functions

171
00:06:29,199 --> 00:06:31,680
first check permission which checks that

172
00:06:31,680 --> 00:06:33,600
the intersection of all permissions of

173
00:06:33,600 --> 00:06:36,160
each protection domain on the call stack

174
00:06:36,160 --> 00:06:39,360
implies the requested permission

175
00:06:39,360 --> 00:06:40,160
then

176
00:06:40,160 --> 00:06:42,240
there is due privileged

177
00:06:42,240 --> 00:06:44,240
which is used to run a method in

178
00:06:44,240 --> 00:06:46,080
privileged context

179
00:06:46,080 --> 00:06:48,639
how it works is it marks the caller as

180
00:06:48,639 --> 00:06:50,800
privileged in order to ignore permission

181
00:06:50,800 --> 00:06:51,759
checks

182
00:06:51,759 --> 00:06:54,319
before the caller

183
00:06:54,319 --> 00:06:57,440
and finally there's the security manager

184
00:06:57,440 --> 00:06:58,960
which is a clause that allows an

185
00:06:58,960 --> 00:07:01,120
application to implement a security

186
00:07:01,120 --> 00:07:02,560
policy

187
00:07:02,560 --> 00:07:04,960
it also contains a check permission

188
00:07:04,960 --> 00:07:07,199
method which essentially calls the

189
00:07:07,199 --> 00:07:08,800
access controller check permission

190
00:07:08,800 --> 00:07:10,960
underneath

191
00:07:10,960 --> 00:07:13,280
to show you an example of a security

192
00:07:13,280 --> 00:07:14,160
check

193
00:07:14,160 --> 00:07:16,479
consider the following codes

194
00:07:16,479 --> 00:07:18,720
get property from the system class

195
00:07:18,720 --> 00:07:21,440
gets a property based on a key

196
00:07:21,440 --> 00:07:23,840
however before doing so it checks

197
00:07:23,840 --> 00:07:25,599
whether the user has the necessary

198
00:07:25,599 --> 00:07:27,440
permission

199
00:07:27,440 --> 00:07:30,080
if a code source without the necessary

200
00:07:30,080 --> 00:07:31,919
permission calls this method

201
00:07:31,919 --> 00:07:35,120
then a security exception will be drawn

202
00:07:35,120 --> 00:07:37,039
if a trusted class wants to call this

203
00:07:37,039 --> 00:07:39,599
method but untrusted functions are on

204
00:07:39,599 --> 00:07:42,319
the call stack then the intersection of

205
00:07:42,319 --> 00:07:45,039
all the permissions will be empty

206
00:07:45,039 --> 00:07:47,280
so in order to avoid this the trusted

207
00:07:47,280 --> 00:07:50,000
method needs to use do privileged

208
00:07:50,000 --> 00:07:52,000
in order to ignore earlier functions on

209
00:07:52,000 --> 00:07:53,520
the call stack

210
00:07:53,520 --> 00:07:55,599
so that the permission check can always

211
00:07:55,599 --> 00:07:57,840
pass for example to get the property of

212
00:07:57,840 --> 00:08:01,039
the package access

213
00:08:01,599 --> 00:08:02,960
now that we know a bit about the

214
00:08:02,960 --> 00:08:04,800
security model let's see how we can

215
00:08:04,800 --> 00:08:06,800
break it

216
00:08:06,800 --> 00:08:08,639
when the java application is executed

217
00:08:08,639 --> 00:08:11,440
from the blu-ray disk jvm is launched

218
00:08:11,440 --> 00:08:14,080
with the following flag

219
00:08:14,080 --> 00:08:15,840
these are bootstrap clauses which are

220
00:08:15,840 --> 00:08:17,919
fully trusted and hence have full

221
00:08:17,919 --> 00:08:19,280
permissions

222
00:08:19,280 --> 00:08:20,520
for example

223
00:08:20,520 --> 00:08:22,879
bdjstac.jar contains many interesting

224
00:08:22,879 --> 00:08:24,800
classes

225
00:08:24,800 --> 00:08:26,800
as mentioned earlier finding privileged

226
00:08:26,800 --> 00:08:29,599
escalation box is straightforward

227
00:08:29,599 --> 00:08:31,680
you basically search for do privileged

228
00:08:31,680 --> 00:08:34,080
calls and see if malicious stuff can be

229
00:08:34,080 --> 00:08:35,440
done

230
00:08:35,440 --> 00:08:38,000
for example creating objects or invoking

231
00:08:38,000 --> 00:08:41,839
methods in privileged context

232
00:08:42,000 --> 00:08:42,958
the first

233
00:08:42,958 --> 00:08:45,279
vulnerability is in the user preference

234
00:08:45,279 --> 00:08:46,399
manager

235
00:08:46,399 --> 00:08:49,040
where they call do privileged

236
00:08:49,040 --> 00:08:51,360
and underneath a file is read from hard

237
00:08:51,360 --> 00:08:52,839
disk and

238
00:08:52,839 --> 00:08:55,200
deserialized you're probably familiar

239
00:08:55,200 --> 00:08:57,600
with java decentralization box they

240
00:08:57,600 --> 00:08:59,839
often allow remote code execution but

241
00:08:59,839 --> 00:09:02,160
they may also allow privilege escalation

242
00:09:02,160 --> 00:09:04,480
let's see how

243
00:09:04,480 --> 00:09:06,880
the user prefs file is located in a

244
00:09:06,880 --> 00:09:08,480
folder in which the user has right

245
00:09:08,480 --> 00:09:10,800
access to and hence the file can be

246
00:09:10,800 --> 00:09:13,040
overwritten with a malicious serialist

247
00:09:13,040 --> 00:09:15,440
serialized file

248
00:09:15,440 --> 00:09:17,120
and during decentralization the

249
00:09:17,120 --> 00:09:19,680
accessible default constructor is called

250
00:09:19,680 --> 00:09:21,519
for the first class in the inheritance

251
00:09:21,519 --> 00:09:22,480
hierarchy

252
00:09:22,480 --> 00:09:26,240
that does not implement serializable

253
00:09:26,240 --> 00:09:27,760
and since the invocation is in

254
00:09:27,760 --> 00:09:29,920
privileged context permission checks in

255
00:09:29,920 --> 00:09:34,080
the constructor can thus be bypassed

256
00:09:34,080 --> 00:09:35,839
what class would be interesting to

257
00:09:35,839 --> 00:09:37,120
instantiate

258
00:09:37,120 --> 00:09:38,880
the class loader is an interesting

259
00:09:38,880 --> 00:09:40,080
target

260
00:09:40,080 --> 00:09:42,560
we create a subclass which extends the

261
00:09:42,560 --> 00:09:46,560
class loader and implements serializable

262
00:09:46,560 --> 00:09:48,160
as mentioned before

263
00:09:48,160 --> 00:09:50,160
the first constructor whose class does

264
00:09:50,160 --> 00:09:53,440
not implement serializable is called

265
00:09:53,440 --> 00:09:55,519
and since the payload class loader

266
00:09:55,519 --> 00:09:57,200
implements a serializable its

267
00:09:57,200 --> 00:09:59,760
constructor is not called but

268
00:09:59,760 --> 00:10:01,760
the constructor of the super class which

269
00:10:01,760 --> 00:10:03,760
is the class loader

270
00:10:03,760 --> 00:10:06,000
and hence our payload class loader will

271
00:10:06,000 --> 00:10:08,079
not be on the call stack and permission

272
00:10:08,079 --> 00:10:10,160
checks in the class loader constructor

273
00:10:10,160 --> 00:10:12,560
will pass

274
00:10:12,560 --> 00:10:14,959
when read object is called we can assign

275
00:10:14,959 --> 00:10:18,160
instance to a public static variable and

276
00:10:18,160 --> 00:10:20,240
once we have that instance we can call

277
00:10:20,240 --> 00:10:22,240
new payloads on it

278
00:10:22,240 --> 00:10:23,839
the interesting part is

279
00:10:23,839 --> 00:10:25,920
we can now call the protected method

280
00:10:25,920 --> 00:10:28,880
define class to load the payload class

281
00:10:28,880 --> 00:10:31,519
with an arbitrary protection domain

282
00:10:31,519 --> 00:10:35,920
in our case one with full permissions

283
00:10:36,800 --> 00:10:38,480
unfortunately this has been mitigated

284
00:10:38,480 --> 00:10:40,480
upstream and exploiting java t

285
00:10:40,480 --> 00:10:42,800
serialization for privilege escalation

286
00:10:42,800 --> 00:10:46,000
is no longer possible

287
00:10:46,000 --> 00:10:48,480
the second vulnerability is in the ixc

288
00:10:48,480 --> 00:10:49,760
proxy

289
00:10:49,760 --> 00:10:51,760
where a method of an object can be

290
00:10:51,760 --> 00:10:52,800
invoked

291
00:10:52,800 --> 00:10:55,600
based on its name and signature

292
00:10:55,600 --> 00:10:58,399
it calls do privileged where underneath

293
00:10:58,399 --> 00:11:01,839
it locates and invokes a method

294
00:11:01,839 --> 00:11:04,959
what kind of methods can be located

295
00:11:04,959 --> 00:11:07,120
it can only locate methods which are

296
00:11:07,120 --> 00:11:09,440
public and non-static

297
00:11:09,440 --> 00:11:12,480
whose classes implement an interface

298
00:11:12,480 --> 00:11:14,480
and where the interfaces methods show

299
00:11:14,480 --> 00:11:16,959
remote exception

300
00:11:16,959 --> 00:11:18,959
on the right hand side you can find such

301
00:11:18,959 --> 00:11:20,399
an example

302
00:11:20,399 --> 00:11:22,640
we have my interface which declares my

303
00:11:22,640 --> 00:11:23,680
method

304
00:11:23,680 --> 00:11:25,519
and we have my implementation which

305
00:11:25,519 --> 00:11:29,760
implements the my method of my interface

306
00:11:29,760 --> 00:11:31,600
how is this useful though if we just

307
00:11:31,600 --> 00:11:33,519
call an untrusted method

308
00:11:33,519 --> 00:11:35,519
in the do privilege block then we won't

309
00:11:35,519 --> 00:11:37,120
be able to gain any additional

310
00:11:37,120 --> 00:11:38,640
privileges

311
00:11:38,640 --> 00:11:40,959
what we need to do is to call a trusted

312
00:11:40,959 --> 00:11:43,760
method with it

313
00:11:43,760 --> 00:11:45,920
consider a target method which is public

314
00:11:45,920 --> 00:11:48,160
and non-static and where the target's

315
00:11:48,160 --> 00:11:50,320
method's class is inheritable and

316
00:11:50,320 --> 00:11:52,320
instantiatable

317
00:11:52,320 --> 00:11:54,720
for example consider the target method

318
00:11:54,720 --> 00:11:56,880
in target class

319
00:11:56,880 --> 00:11:58,959
we can invoke this method in privileged

320
00:11:58,959 --> 00:12:00,720
context as follows

321
00:12:00,720 --> 00:12:02,399
we create an

322
00:12:02,399 --> 00:12:04,560
attacker interface which declares the

323
00:12:04,560 --> 00:12:06,320
same target method

324
00:12:06,320 --> 00:12:08,839
however which draws remote exception in

325
00:12:08,839 --> 00:12:10,399
addition

326
00:12:10,399 --> 00:12:12,800
and we create an attacker class which

327
00:12:12,800 --> 00:12:15,440
extends the attack the target class and

328
00:12:15,440 --> 00:12:18,639
implements the attacker interface

329
00:12:18,639 --> 00:12:20,399
what is important here is that the

330
00:12:20,399 --> 00:12:22,800
attacker class does not override the

331
00:12:22,800 --> 00:12:24,560
target methods

332
00:12:24,560 --> 00:12:27,360
namely target method is inherited from

333
00:12:27,360 --> 00:12:29,839
the target class

334
00:12:29,839 --> 00:12:32,000
when locating and invoking this method

335
00:12:32,000 --> 00:12:34,240
the unjust attacker class will not be on

336
00:12:34,240 --> 00:12:35,680
the call stack

337
00:12:35,680 --> 00:12:37,519
meaning that everything within the do

338
00:12:37,519 --> 00:12:39,680
privileged block will come from trusted

339
00:12:39,680 --> 00:12:42,000
code only

340
00:12:42,000 --> 00:12:43,920
for a real example consider the file

341
00:12:43,920 --> 00:12:45,920
class as a target

342
00:12:45,920 --> 00:12:47,360
permission checks are in the file

343
00:12:47,360 --> 00:12:50,560
constructor but for example

344
00:12:50,560 --> 00:12:52,320
sorry permission checks are not in the

345
00:12:52,320 --> 00:12:54,160
file constructor but for example in the

346
00:12:54,160 --> 00:12:55,760
list methods

347
00:12:55,760 --> 00:12:57,440
we create a file interface which

348
00:12:57,440 --> 00:12:58,800
declares list

349
00:12:58,800 --> 00:13:00,880
and we create a file implementation

350
00:13:00,880 --> 00:13:03,200
which extends the file class and

351
00:13:03,200 --> 00:13:06,000
implements the file interface

352
00:13:06,000 --> 00:13:08,240
with our primitive we can now call lists

353
00:13:08,240 --> 00:13:09,760
with all permissions

354
00:13:09,760 --> 00:13:10,880
and therefore

355
00:13:10,880 --> 00:13:13,040
we are able to list arbitrary paths and

356
00:13:13,040 --> 00:13:15,440
can use that to dump the application

357
00:13:15,440 --> 00:13:18,079
directory and obtain jar files on the

358
00:13:18,079 --> 00:13:21,079
ps5

359
00:13:21,200 --> 00:13:23,279
with the ability to call methods in

360
00:13:23,279 --> 00:13:25,360
privileged context we can invoke a few

361
00:13:25,360 --> 00:13:26,880
interesting methods but there are

362
00:13:26,880 --> 00:13:30,959
certain limitations as described earlier

363
00:13:30,959 --> 00:13:33,040
and with the following gadget which is

364
00:13:33,040 --> 00:13:35,600
only available on the ps4 we can

365
00:13:35,600 --> 00:13:38,320
instantiate a class with one argument

366
00:13:38,320 --> 00:13:40,320
and chaining that with the privileged

367
00:13:40,320 --> 00:13:43,120
method invocation we can now also invoke

368
00:13:43,120 --> 00:13:47,120
constructors in privileged context

369
00:13:47,120 --> 00:13:50,160
the bdj stack contains its own security

370
00:13:50,160 --> 00:13:52,720
policy implementation

371
00:13:52,720 --> 00:13:54,959
in the get permissions method there's an

372
00:13:54,959 --> 00:13:57,199
interesting condition

373
00:13:57,199 --> 00:13:58,959
if the location of the code source

374
00:13:58,959 --> 00:14:01,120
begins with a certain prefix

375
00:14:01,120 --> 00:14:03,680
all permissions are granted

376
00:14:03,680 --> 00:14:05,760
and that is the number one mistake when

377
00:14:05,760 --> 00:14:08,160
handling and checking file paths

378
00:14:08,160 --> 00:14:10,639
if path drive also is possible then this

379
00:14:10,639 --> 00:14:12,880
condition can be triggered to gain all

380
00:14:12,880 --> 00:14:14,959
permissions

381
00:14:14,959 --> 00:14:16,639
and that's what we do plugging all

382
00:14:16,639 --> 00:14:19,040
together with our privileged construct

383
00:14:19,040 --> 00:14:21,360
constructor invocation we instantiate a

384
00:14:21,360 --> 00:14:24,480
url class loader with a manager's path

385
00:14:24,480 --> 00:14:26,959
we namely point it to our jar file but

386
00:14:26,959 --> 00:14:29,199
with a prefix that fools the security

387
00:14:29,199 --> 00:14:30,880
policy

388
00:14:30,880 --> 00:14:32,560
the path traversal is per se not a

389
00:14:32,560 --> 00:14:34,880
vulnerability because creating new class

390
00:14:34,880 --> 00:14:37,120
loader instances is not permitted in the

391
00:14:37,120 --> 00:14:39,040
first place

392
00:14:39,040 --> 00:14:40,800
this method only works on the ps4

393
00:14:40,800 --> 00:14:42,399
because the service class mentioned

394
00:14:42,399 --> 00:14:44,800
earlier is available there only

395
00:14:44,800 --> 00:14:47,519
how to escape the sandbox on the ps5

396
00:14:47,519 --> 00:14:49,120
with this vulnerability will not be

397
00:14:49,120 --> 00:14:53,279
disclosed and is left as an exercise

398
00:14:53,519 --> 00:14:54,800
what shall we do with all the

399
00:14:54,800 --> 00:14:55,839
permissions

400
00:14:55,839 --> 00:14:58,160
the payload class has one purpose only

401
00:14:58,160 --> 00:15:01,760
which is to disable the security manager

402
00:15:01,760 --> 00:15:03,760
with the security manager disabled we

403
00:15:03,760 --> 00:15:07,920
can namely access all internal classes

404
00:15:08,000 --> 00:15:10,079
the most interesting class to access is

405
00:15:10,079 --> 00:15:13,360
the sun misc unsafe which gets

406
00:15:13,360 --> 00:15:15,839
which we can get an instance from using

407
00:15:15,839 --> 00:15:17,839
reflection

408
00:15:17,839 --> 00:15:19,920
what this class allows you to do we you

409
00:15:19,920 --> 00:15:21,920
will learn next

410
00:15:21,920 --> 00:15:24,240
namely once you get access to the unsafe

411
00:15:24,240 --> 00:15:27,600
class you get native code execution

412
00:15:27,600 --> 00:15:28,800
and for that

413
00:15:28,800 --> 00:15:31,279
we want to have three primitives

414
00:15:31,279 --> 00:15:33,360
we from java we want to

415
00:15:33,360 --> 00:15:36,079
access native memory we want to find

416
00:15:36,079 --> 00:15:37,440
native methods

417
00:15:37,440 --> 00:15:39,279
and we also want to call these native

418
00:15:39,279 --> 00:15:41,839
functions

419
00:15:42,000 --> 00:15:44,079
for native memory access

420
00:15:44,079 --> 00:15:46,480
we get it for free because that is what

421
00:15:46,480 --> 00:15:49,759
the sun misc unsafe class is for

422
00:15:49,759 --> 00:15:51,920
they are namely native methods like get

423
00:15:51,920 --> 00:15:54,320
long put long allocate memory and free

424
00:15:54,320 --> 00:15:56,800
memory which allow you to read write

425
00:15:56,800 --> 00:16:00,079
allocate and free native memory

426
00:16:00,079 --> 00:16:02,320
using that we can also construct an

427
00:16:02,320 --> 00:16:04,160
address of primitive

428
00:16:04,160 --> 00:16:05,600
to return the

429
00:16:05,600 --> 00:16:08,639
native pointer of any object

430
00:16:08,639 --> 00:16:10,720
we do so by putting the object's pointer

431
00:16:10,720 --> 00:16:12,320
into the value field

432
00:16:12,320 --> 00:16:13,920
of the long object

433
00:16:13,920 --> 00:16:16,079
and then we can simply retrieve that

434
00:16:16,079 --> 00:16:18,560
pointer

435
00:16:19,680 --> 00:16:21,600
as mentioned at the beginning the ps5

436
00:16:21,600 --> 00:16:24,720
amd cpu supports execute-only memory and

437
00:16:24,720 --> 00:16:26,800
enables it for all the text segments in

438
00:16:26,800 --> 00:16:29,920
both kernel and userland

439
00:16:29,920 --> 00:16:31,839
with this mitigation we are not able to

440
00:16:31,839 --> 00:16:34,320
read executable pages and for example

441
00:16:34,320 --> 00:16:35,600
identify

442
00:16:35,600 --> 00:16:38,399
functions based on opcodes

443
00:16:38,399 --> 00:16:41,040
we can read the set data segment though

444
00:16:41,040 --> 00:16:43,120
which is useful to infer

445
00:16:43,120 --> 00:16:45,279
addresses of certain functions

446
00:16:45,279 --> 00:16:47,519
but that is quite cumbersome and only

447
00:16:47,519 --> 00:16:50,480
works for a few functions

448
00:16:50,480 --> 00:16:52,000
it turns out that

449
00:16:52,000 --> 00:16:55,199
the class loader native library contains

450
00:16:55,199 --> 00:16:58,480
a find entry function which calls dl sim

451
00:16:58,480 --> 00:16:59,759
underneath

452
00:16:59,759 --> 00:17:01,600
and that is the perfect gadget which we

453
00:17:01,600 --> 00:17:03,120
can use to

454
00:17:03,120 --> 00:17:05,359
identify addresses of all exported

455
00:17:05,359 --> 00:17:08,079
functions from java

456
00:17:08,079 --> 00:17:10,640
it is also firmware agnostic as we only

457
00:17:10,640 --> 00:17:14,160
need to provide symbol names

458
00:17:14,160 --> 00:17:16,240
the last primitive we need

459
00:17:16,240 --> 00:17:18,559
is a way to invoke these functions from

460
00:17:18,559 --> 00:17:20,240
java codes

461
00:17:20,240 --> 00:17:22,480
in particular we want to invoke them

462
00:17:22,480 --> 00:17:24,799
with arbitrary arguments and we also

463
00:17:24,799 --> 00:17:28,240
want to get the return value from it

464
00:17:28,240 --> 00:17:30,240
for this purpose there exists an

465
00:17:30,240 --> 00:17:33,840
interesting function called setcontext

466
00:17:33,840 --> 00:17:37,760
where the function is from lip unwinds

467
00:17:37,760 --> 00:17:40,000
it is similar to long jump but it also

468
00:17:40,000 --> 00:17:42,960
restores all the argument registers

469
00:17:42,960 --> 00:17:44,880
which is a perfect gadget for function

470
00:17:44,880 --> 00:17:46,400
invocation

471
00:17:46,400 --> 00:17:48,720
however to make that work we also need

472
00:17:48,720 --> 00:17:51,679
to get other registers such as rbp or

473
00:17:51,679 --> 00:17:53,039
rsp

474
00:17:53,039 --> 00:17:55,520
so that we can restore them safely

475
00:17:55,520 --> 00:17:57,919
for that we can use setjump

476
00:17:57,919 --> 00:17:59,840
which works under the assumption that

477
00:17:59,840 --> 00:18:02,160
the registers remain the same between

478
00:18:02,160 --> 00:18:06,320
the set jump and the set context calls

479
00:18:07,120 --> 00:18:09,200
how can we trigger that gadget

480
00:18:09,200 --> 00:18:12,000
for that we need a rip control

481
00:18:12,000 --> 00:18:13,919
we need to find an interesting object

482
00:18:13,919 --> 00:18:16,720
which we can fake or corrupt

483
00:18:16,720 --> 00:18:19,440
whose class contains a virtual table

484
00:18:19,440 --> 00:18:22,080
that is virtual function pointers

485
00:18:22,080 --> 00:18:24,559
and where the return value is sent back

486
00:18:24,559 --> 00:18:26,799
to the java code

487
00:18:26,799 --> 00:18:29,120
we don't need to control any arguments

488
00:18:29,120 --> 00:18:32,000
except the buffer of the first argument

489
00:18:32,000 --> 00:18:35,919
which is essentially that this object

490
00:18:36,160 --> 00:18:38,559
the array clause contains an interesting

491
00:18:38,559 --> 00:18:40,160
virtual function

492
00:18:40,160 --> 00:18:42,320
it is called by the native function

493
00:18:42,320 --> 00:18:44,000
multi-new array

494
00:18:44,000 --> 00:18:46,480
and with where the object comes from the

495
00:18:46,480 --> 00:18:50,160
first argument the component type

496
00:18:50,160 --> 00:18:52,320
the interesting property is

497
00:18:52,320 --> 00:18:54,799
that the return value is the object that

498
00:18:54,799 --> 00:18:57,600
is returned by the multi-new array

499
00:18:57,600 --> 00:18:59,840
in other words the return value is sent

500
00:18:59,840 --> 00:19:04,000
back to the java code as we desire

501
00:19:04,080 --> 00:19:06,799
we declare a native method in our api

502
00:19:06,799 --> 00:19:07,919
class

503
00:19:07,919 --> 00:19:10,160
and resolve it to the native function of

504
00:19:10,160 --> 00:19:13,360
using our dlcm primitive

505
00:19:13,360 --> 00:19:14,880
we do so because we want to have

506
00:19:14,880 --> 00:19:16,480
different types

507
00:19:16,480 --> 00:19:18,640
instead of returning an object we want

508
00:19:18,640 --> 00:19:20,400
to return along

509
00:19:20,400 --> 00:19:22,640
and instead of using a class as the

510
00:19:22,640 --> 00:19:26,559
first argument we also want to use along

511
00:19:26,559 --> 00:19:29,919
then we call it with our fake object as

512
00:19:29,919 --> 00:19:31,440
component type

513
00:19:31,440 --> 00:19:33,440
this fake object we can simply allocate

514
00:19:33,440 --> 00:19:35,200
on the heap

515
00:19:35,200 --> 00:19:37,039
and after some dereferences

516
00:19:37,039 --> 00:19:39,280
multi-allocate will be called with the

517
00:19:39,280 --> 00:19:41,919
fake array class object as the first

518
00:19:41,919 --> 00:19:44,400
argument

519
00:19:45,039 --> 00:19:46,320
as the function pointer of

520
00:19:46,320 --> 00:19:49,200
multi-allocate we first use setjump to

521
00:19:49,200 --> 00:19:51,280
save all the registers

522
00:19:51,280 --> 00:19:53,520
and then we use set context to restore

523
00:19:53,520 --> 00:19:54,400
them

524
00:19:54,400 --> 00:19:57,440
and to provide our desired arguments and

525
00:19:57,440 --> 00:19:59,360
function pointers

526
00:19:59,360 --> 00:20:01,600
and we basically have achieved robles

527
00:20:01,600 --> 00:20:04,559
code execution

528
00:20:05,039 --> 00:20:07,600
there was one problem on the ps4

529
00:20:07,600 --> 00:20:09,520
after a lot of function calls in which

530
00:20:09,520 --> 00:20:11,600
is crash

531
00:20:11,600 --> 00:20:13,600
for some reason the stack pointer might

532
00:20:13,600 --> 00:20:14,880
be different

533
00:20:14,880 --> 00:20:17,280
between the two multi multi-allocate

534
00:20:17,280 --> 00:20:18,240
calls

535
00:20:18,240 --> 00:20:20,400
remember the first call is to set jump

536
00:20:20,400 --> 00:20:23,440
and the second to set object

537
00:20:23,440 --> 00:20:25,840
it turned out that cheat optimization

538
00:20:25,840 --> 00:20:28,480
would kick in

539
00:20:28,480 --> 00:20:29,919
after

540
00:20:29,919 --> 00:20:33,679
bookkicking after a few function calls

541
00:20:33,679 --> 00:20:36,080
the solution for that was easy

542
00:20:36,080 --> 00:20:38,720
i used a for loop for the two function

543
00:20:38,720 --> 00:20:39,840
calls

544
00:20:39,840 --> 00:20:42,080
and then i trained the java function by

545
00:20:42,080 --> 00:20:44,240
calling it more than ten thousand times

546
00:20:44,240 --> 00:20:46,640
with one iteration only

547
00:20:46,640 --> 00:20:48,960
and that trick was enough to trigger the

548
00:20:48,960 --> 00:20:52,240
cheat optimization at an earlier stage

549
00:20:52,240 --> 00:20:53,840
and that way the stack pointer would

550
00:20:53,840 --> 00:20:57,360
remain the same afterwards

551
00:20:57,360 --> 00:21:00,320
after all the hard work we finally have

552
00:21:00,320 --> 00:21:02,320
a native api with all the desired

553
00:21:02,320 --> 00:21:03,440
primitives

554
00:21:03,440 --> 00:21:05,919
we can allocate free and access native

555
00:21:05,919 --> 00:21:06,880
memory

556
00:21:06,880 --> 00:21:09,360
we can find native functions and we can

557
00:21:09,360 --> 00:21:11,200
also invoke them with arbitrary

558
00:21:11,200 --> 00:21:12,480
arguments

559
00:21:12,480 --> 00:21:14,559
the exciting thing is it can even be

560
00:21:14,559 --> 00:21:16,720
used in java threads

561
00:21:16,720 --> 00:21:18,720
which means that we can do native

562
00:21:18,720 --> 00:21:21,200
function calls in parallel

563
00:21:21,200 --> 00:21:23,520
which is useful for example to exploit

564
00:21:23,520 --> 00:21:25,200
race condition vulnerabilities in the

565
00:21:25,200 --> 00:21:27,520
kernel

566
00:21:27,520 --> 00:21:29,600
with the ability to

567
00:21:29,600 --> 00:21:30,400
call

568
00:21:30,400 --> 00:21:33,120
to get native code execution we we can

569
00:21:33,120 --> 00:21:35,600
call some native functions but we cannot

570
00:21:35,600 --> 00:21:38,640
yet execute arbitrary code

571
00:21:38,640 --> 00:21:41,360
we can't simply call mmap for example

572
00:21:41,360 --> 00:21:43,679
because cheat capabilities are granted

573
00:21:43,679 --> 00:21:46,320
to certain processes only

574
00:21:46,320 --> 00:21:48,400
in particular no process

575
00:21:48,400 --> 00:21:51,039
is allowed to call mmap with write

576
00:21:51,039 --> 00:21:53,760
executable permissions

577
00:21:53,760 --> 00:21:54,799
instead

578
00:21:54,799 --> 00:21:57,039
one needs to set up a shared page

579
00:21:57,039 --> 00:21:59,280
which is mapped as read executable in

580
00:21:59,280 --> 00:22:00,559
one process

581
00:22:00,559 --> 00:22:03,919
and read writeable in another process

582
00:22:03,919 --> 00:22:07,280
that's what sony did with the ps4 they

583
00:22:07,280 --> 00:22:09,520
moved all the jit functionalities of the

584
00:22:09,520 --> 00:22:12,480
jvm runtime to a different process and

585
00:22:12,480 --> 00:22:14,559
communicate with it using unix domain

586
00:22:14,559 --> 00:22:16,480
sockets

587
00:22:16,480 --> 00:22:19,840
on the ps5 jvm jit is unfortunately not

588
00:22:19,840 --> 00:22:22,320
supported

589
00:22:22,640 --> 00:22:25,600
to show the concept visually

590
00:22:25,600 --> 00:22:27,760
consider the runtime process which maps

591
00:22:27,760 --> 00:22:30,480
the cheat page as read executable

592
00:22:30,480 --> 00:22:32,559
and the compiler process which maps the

593
00:22:32,559 --> 00:22:35,440
cheat page as read writable

594
00:22:35,440 --> 00:22:38,000
via unix domain sockets the runtime

595
00:22:38,000 --> 00:22:39,840
process can now request the compiler

596
00:22:39,840 --> 00:22:42,799
process to do cheat optimization

597
00:22:42,799 --> 00:22:46,159
which is to write to the cheat page

598
00:22:46,159 --> 00:22:48,640
if we manage to com to exploit the

599
00:22:48,640 --> 00:22:50,080
compiler process

600
00:22:50,080 --> 00:22:52,240
then we can write arbitrary payloads

601
00:22:52,240 --> 00:22:54,720
into the cheat page which the runtime

602
00:22:54,720 --> 00:22:58,480
process can then just execute

603
00:22:58,880 --> 00:23:00,559
the third vulnerability is in the

604
00:23:00,559 --> 00:23:03,520
protocol between the two processes

605
00:23:03,520 --> 00:23:04,720
namely

606
00:23:04,720 --> 00:23:06,880
the runtime process can provide an

607
00:23:06,880 --> 00:23:09,600
untrusted pointer in the structure

608
00:23:09,600 --> 00:23:11,440
and the compiler process will simply

609
00:23:11,440 --> 00:23:13,919
make a backup of the request at that

610
00:23:13,919 --> 00:23:15,440
location

611
00:23:15,440 --> 00:23:18,080
in other words we have a write whatswear

612
00:23:18,080 --> 00:23:20,240
primitive

613
00:23:20,240 --> 00:23:23,120
exploiting the bug is quite easy

614
00:23:23,120 --> 00:23:24,720
we don't really need to get code

615
00:23:24,720 --> 00:23:26,960
execution in the compiler process

616
00:23:26,960 --> 00:23:29,039
we can simply use the primitive to write

617
00:23:29,039 --> 00:23:30,799
our payload

618
00:23:30,799 --> 00:23:33,440
and that works because the cheat page

619
00:23:33,440 --> 00:23:35,280
has the same address in both the runtime

620
00:23:35,280 --> 00:23:37,679
process and the compiler process

621
00:23:37,679 --> 00:23:38,480
so

622
00:23:38,480 --> 00:23:40,400
we let the compiler process write the

623
00:23:40,400 --> 00:23:42,640
payload and then we can simply execute

624
00:23:42,640 --> 00:23:45,039
it in the runtime process

625
00:23:45,039 --> 00:23:47,440
and that allows us to write c code as

626
00:23:47,440 --> 00:23:50,400
the next stage of the exploit chain

627
00:23:50,400 --> 00:23:52,960
as said before the ps5 does not support

628
00:23:52,960 --> 00:23:54,640
jvm chat

629
00:23:54,640 --> 00:23:56,880
otherwise that would have been useful

630
00:23:56,880 --> 00:23:59,600
to run homebrews already

631
00:23:59,600 --> 00:24:02,080
but on the ps4 this capability is quite

632
00:24:02,080 --> 00:24:03,279
practical

633
00:24:03,279 --> 00:24:05,440
for kernel exploitation because there's

634
00:24:05,440 --> 00:24:08,320
no supervisor mode

635
00:24:08,320 --> 00:24:10,240
execution prevention

636
00:24:10,240 --> 00:24:12,720
so one can simply get rid control in the

637
00:24:12,720 --> 00:24:16,720
kernel and return to the c payload

638
00:24:17,440 --> 00:24:20,559
that was the whole exploit chain so to

639
00:24:20,559 --> 00:24:21,840
recap

640
00:24:21,840 --> 00:24:24,480
to get from sandbox java code execution

641
00:24:24,480 --> 00:24:26,640
to arbitrary code execution

642
00:24:26,640 --> 00:24:29,360
we first need to escalate privileges

643
00:24:29,360 --> 00:24:30,960
and we do so

644
00:24:30,960 --> 00:24:33,440
by looking for do privileged course

645
00:24:33,440 --> 00:24:35,440
where we can trick bootstrap classes

646
00:24:35,440 --> 00:24:37,919
into loading our payload class with full

647
00:24:37,919 --> 00:24:39,679
permissions

648
00:24:39,679 --> 00:24:40,559
then

649
00:24:40,559 --> 00:24:42,559
we can install our native api which

650
00:24:42,559 --> 00:24:45,279
should have three primitives ah sorry

651
00:24:45,279 --> 00:24:46,720
before that we need to disable the

652
00:24:46,720 --> 00:24:50,080
security manager by setting it to null

653
00:24:50,080 --> 00:24:52,320
and then we installed the native api

654
00:24:52,320 --> 00:24:54,880
which should have the three primitives

655
00:24:54,880 --> 00:24:56,000
we should

656
00:24:56,000 --> 00:24:57,760
access native memory which we can

657
00:24:57,760 --> 00:24:59,840
achieve using this is the sun mist

658
00:24:59,840 --> 00:25:01,760
unsafe class

659
00:25:01,760 --> 00:25:04,400
we want to find native functions which

660
00:25:04,400 --> 00:25:06,240
we can find using the

661
00:25:06,240 --> 00:25:08,559
find entry from the native library

662
00:25:08,559 --> 00:25:11,360
and finally we can we want to call this

663
00:25:11,360 --> 00:25:12,880
native functions

664
00:25:12,880 --> 00:25:15,360
which we can do using setjump and set

665
00:25:15,360 --> 00:25:18,320
context via the multi-allocate

666
00:25:18,320 --> 00:25:19,919
and finally

667
00:25:19,919 --> 00:25:22,159
in order to execute arbitrary code

668
00:25:22,159 --> 00:25:24,240
we just send malicious requests

669
00:25:24,240 --> 00:25:26,240
to the compiler process to write our

670
00:25:26,240 --> 00:25:28,559
payload

671
00:25:28,559 --> 00:25:30,640
and the end result is we have user land

672
00:25:30,640 --> 00:25:32,080
code execution

673
00:25:32,080 --> 00:25:34,720
using the blu-ray disk which is 100

674
00:25:34,720 --> 00:25:36,159
reliable

675
00:25:36,159 --> 00:25:38,080
because because it does not rely on race

676
00:25:38,080 --> 00:25:40,840
conditions on heap spraying or other

677
00:25:40,840 --> 00:25:43,760
techniques it is also firmware agnostic

678
00:25:43,760 --> 00:25:45,679
because it only relies on a few

679
00:25:45,679 --> 00:25:47,760
structure offsets

680
00:25:47,760 --> 00:25:50,320
and with a single disk we can hack any

681
00:25:50,320 --> 00:25:51,600
firmware

682
00:25:51,600 --> 00:25:54,799
the exploit works on the ps4 up below

683
00:25:54,799 --> 00:25:58,799
firmware 9.5 and on the ps5 below

684
00:25:58,799 --> 00:26:01,200
firmware 5.

685
00:26:01,200 --> 00:26:03,600
very likely the ps3 is exploitable as

686
00:26:03,600 --> 00:26:05,840
well because they all share the same pdj

687
00:26:05,840 --> 00:26:08,158
stack

688
00:26:08,640 --> 00:26:11,760
and i used that entry point and to to

689
00:26:11,760 --> 00:26:13,760
chain with the kernel exploits and was

690
00:26:13,760 --> 00:26:16,080
able to enable the debug settings on the

691
00:26:16,080 --> 00:26:18,720
ps5

692
00:26:19,200 --> 00:26:24,120
all right now there will be a live demo

693
00:26:24,960 --> 00:26:27,960
okay

694
00:26:39,120 --> 00:26:41,360
so take a look on this monitor here

695
00:26:41,360 --> 00:26:42,960
which is quite small

696
00:26:42,960 --> 00:26:46,080
i hope you can see something

697
00:26:46,080 --> 00:26:50,240
and then we insert our blu-ray disc

698
00:26:50,240 --> 00:26:52,159
which even has a

699
00:26:52,159 --> 00:26:53,840
unique icon

700
00:26:53,840 --> 00:26:57,039
and we can simply launch it

701
00:27:02,480 --> 00:27:05,440
and now we got a notification

702
00:27:05,440 --> 00:27:08,080
on the system

703
00:27:08,159 --> 00:27:09,919
and we would exploit the curl in 10

704
00:27:09,919 --> 00:27:12,320
seconds

705
00:27:14,000 --> 00:27:14,799
so

706
00:27:14,799 --> 00:27:17,520
so the whole part here is 100

707
00:27:17,520 --> 00:27:19,600
reliable as mentioned before

708
00:27:19,600 --> 00:27:21,440
the kernel exploit might not be as

709
00:27:21,440 --> 00:27:22,799
reliable

710
00:27:22,799 --> 00:27:25,840
let's hope it will work

711
00:27:27,200 --> 00:27:31,039
or maybe we'll just panic

712
00:27:31,919 --> 00:27:35,840
yeah likely it's just panicking

713
00:27:40,159 --> 00:27:43,799
let's try it again

714
00:27:58,320 --> 00:27:59,440
see the

715
00:27:59,440 --> 00:28:01,600
notification again we also say hacked

716
00:28:01,600 --> 00:28:05,360
planets at hardware dot io

717
00:28:11,200 --> 00:28:13,200
ah yes so

718
00:28:13,200 --> 00:28:16,159
we were able to win i read the race so

719
00:28:16,159 --> 00:28:17,679
as a spoiler that's a race condition

720
00:28:17,679 --> 00:28:20,480
vulnerability that we exploited

721
00:28:20,480 --> 00:28:22,159
and we were able to get read write

722
00:28:22,159 --> 00:28:24,559
primitives in the kernel

723
00:28:24,559 --> 00:28:28,320
and there are some nice kernel pointers

724
00:28:28,320 --> 00:28:33,039
that's it that's the ddj exploit

725
00:28:38,480 --> 00:28:40,640
yeah um thanks sonny for approving this

726
00:28:40,640 --> 00:28:42,080
talk and for resolving the

727
00:28:42,080 --> 00:28:43,440
vulnerabilities

728
00:28:43,440 --> 00:28:45,440
and for the hacker one bounce at buck

729
00:28:45,440 --> 00:28:46,480
bounty

730
00:28:46,480 --> 00:28:49,840
and thank you for your attention

731
00:28:50,390 --> 00:28:54,599
[Applause]

732
00:28:55,440 --> 00:28:57,830
do we have questions

733
00:28:57,830 --> 00:29:04,309
[Music]

734
00:29:05,600 --> 00:29:07,918
hello

735
00:29:08,159 --> 00:29:10,159
so first awesome talk thank you very

736
00:29:10,159 --> 00:29:12,080
much

737
00:29:12,080 --> 00:29:12,960
so

738
00:29:12,960 --> 00:29:14,960
at least two questions so

739
00:29:14,960 --> 00:29:17,200
i didn't know about anything about java

740
00:29:17,200 --> 00:29:18,960
privilege escalation works like this

741
00:29:18,960 --> 00:29:20,159
especially

742
00:29:20,159 --> 00:29:23,200
based on java classes

743
00:29:23,200 --> 00:29:25,679
so this is fun i guess so did you look

744
00:29:25,679 --> 00:29:30,080
into the bootstrap classes of uh

745
00:29:30,080 --> 00:29:32,480
jd case itself so the in your class path

746
00:29:32,480 --> 00:29:34,480
the first bootstrap classes for things

747
00:29:34,480 --> 00:29:35,919
like that for

748
00:29:35,919 --> 00:29:38,840
i don't know oracle hotspot or

749
00:29:38,840 --> 00:29:42,000
yeah that's a good question um so

750
00:29:42,000 --> 00:29:45,120
x is the runtime um java file

751
00:29:45,120 --> 00:29:46,080
um

752
00:29:46,080 --> 00:29:48,880
but it is super new like from 2019 or so

753
00:29:48,880 --> 00:29:51,120
um so i didn't expect to find any zero

754
00:29:51,120 --> 00:29:52,320
days in

755
00:29:52,320 --> 00:29:55,120
the jdk itself um

756
00:29:55,120 --> 00:29:58,799
but i said that dex is the pdjsdac.jar

757
00:29:58,799 --> 00:30:01,760
which contains a lot of java files and

758
00:30:01,760 --> 00:30:03,039
they all have

759
00:30:03,039 --> 00:30:05,760
full permissions so i was mainly looking

760
00:30:05,760 --> 00:30:06,799
there

761
00:30:06,799 --> 00:30:08,640
yeah makes sense okay

762
00:30:08,640 --> 00:30:11,200
so may i ask something because maybe i

763
00:30:11,200 --> 00:30:13,440
just didn't understand it um

764
00:30:13,440 --> 00:30:16,159
uh highly probable

765
00:30:16,159 --> 00:30:17,679
um

766
00:30:17,679 --> 00:30:21,360
you use the uh so a reflection gadget to

767
00:30:21,360 --> 00:30:25,360
get to the native world so to say

768
00:30:25,360 --> 00:30:28,399
so i was just not sure

769
00:30:28,399 --> 00:30:31,200
i i know that you can load uh native

770
00:30:31,200 --> 00:30:33,360
libraries with jaina

771
00:30:33,360 --> 00:30:34,559
is about

772
00:30:34,559 --> 00:30:37,360
is the sun misc unsafe namespace is this

773
00:30:37,360 --> 00:30:40,240
already jni or could you

774
00:30:40,240 --> 00:30:42,320
use jni to load a

775
00:30:42,320 --> 00:30:43,760
shared

776
00:30:43,760 --> 00:30:46,000
native library as well for your exploit

777
00:30:46,000 --> 00:30:47,679
chain

778
00:30:47,679 --> 00:30:50,880
that's a good question um

779
00:30:50,880 --> 00:30:52,159
because i was not sure that the name

780
00:30:52,159 --> 00:30:54,880
space is the same so actually if

781
00:30:54,880 --> 00:30:58,159
it is jni or you could so

782
00:30:58,159 --> 00:30:59,519
there is the

783
00:30:59,519 --> 00:31:02,320
unsafe implementation in the gni yes

784
00:31:02,320 --> 00:31:05,840
um that also lives in the jdk yeah

785
00:31:05,840 --> 00:31:08,480
um whether you are able to load or the

786
00:31:08,480 --> 00:31:11,360
libraries i'm not sure maybe yeah yeah

787
00:31:11,360 --> 00:31:13,039
i'm pretty sure for the ps4 you wouldn't

788
00:31:13,039 --> 00:31:13,840
need

789
00:31:13,840 --> 00:31:15,760
you are only allowed to like load signed

790
00:31:15,760 --> 00:31:17,519
modules anyway so

791
00:31:17,519 --> 00:31:20,880
i didn't look into this method okay okay

792
00:31:20,880 --> 00:31:24,039
thank you

