1
00:00:03,280 --> 00:00:04,720
thank you for the introduction and

2
00:00:04,720 --> 00:00:06,399
welcome to this presentation i'm really

3
00:00:06,399 --> 00:00:08,639
excited of being here uh sharing with

4
00:00:08,639 --> 00:00:11,360
you what i've done during my phd about

5
00:00:11,360 --> 00:00:13,440
um on-chip communication and threat that

6
00:00:13,440 --> 00:00:15,040
we found on

7
00:00:15,040 --> 00:00:17,199
modern platforms

8
00:00:17,199 --> 00:00:20,080
so first of all who am i well i'm an

9
00:00:20,080 --> 00:00:22,400
academic i work at the university of

10
00:00:22,400 --> 00:00:24,000
california san diego

11
00:00:24,000 --> 00:00:25,599
and i did my phd

12
00:00:25,599 --> 00:00:28,560
uh in italy at the ritz lab pizza in an

13
00:00:28,560 --> 00:00:30,640
embedded system real in an embedded

14
00:00:30,640 --> 00:00:32,800
real-time system lab

15
00:00:32,800 --> 00:00:34,480
i've been working mainly in the previous

16
00:00:34,480 --> 00:00:35,920
four years on other security and we

17
00:00:35,920 --> 00:00:38,320
focused a lot on uh access control

18
00:00:38,320 --> 00:00:40,239
systems for hardware in the previous two

19
00:00:40,239 --> 00:00:41,360
years

20
00:00:41,360 --> 00:00:42,960
but my thesis was million times

21
00:00:42,960 --> 00:00:44,640
predictability safety and security

22
00:00:44,640 --> 00:00:47,680
mechanism for fpga soc platforms we've

23
00:00:47,680 --> 00:00:48,879
also done some work on timing

24
00:00:48,879 --> 00:00:51,440
predictable dna acceleration on fpgas

25
00:00:51,440 --> 00:00:52,800
that at the end there are references we

26
00:00:52,800 --> 00:00:54,879
are interested

27
00:00:54,879 --> 00:00:57,760
okay this talk basically what are what

28
00:00:57,760 --> 00:01:00,399
i'm trying to introduce you it's how we

29
00:01:00,399 --> 00:01:02,399
explore analyze and address

30
00:01:02,399 --> 00:01:05,280
security and safety concerns that we

31
00:01:05,280 --> 00:01:07,119
found in a popular communication

32
00:01:07,119 --> 00:01:09,119
standard implemented in

33
00:01:09,119 --> 00:01:10,880
heterogeneous platforms

34
00:01:10,880 --> 00:01:13,840
and we detected a couple of threads that

35
00:01:13,840 --> 00:01:15,600
are able actually to create the

36
00:01:15,600 --> 00:01:17,759
dependencies among multiple models that

37
00:01:17,759 --> 00:01:19,200
it's something that is very critical in

38
00:01:19,200 --> 00:01:21,520
safety and safety systems

39
00:01:21,520 --> 00:01:22,400
and

40
00:01:22,400 --> 00:01:24,560
deals to embedded bandwidth distribution

41
00:01:24,560 --> 00:01:26,799
and then i a service of resources such

42
00:01:26,799 --> 00:01:29,040
memories shared memories

43
00:01:29,040 --> 00:01:31,360
also the lesson i learned and the

44
00:01:31,360 --> 00:01:33,600
solution we propose and some guidelines

45
00:01:33,600 --> 00:01:36,400
at the end of this talk

46
00:01:36,400 --> 00:01:38,479
okay just to get all of us on the same

47
00:01:38,479 --> 00:01:40,560
page basically we work on safety

48
00:01:40,560 --> 00:01:43,439
critical systems and these systems are a

49
00:01:43,439 --> 00:01:45,439
system that they cannot they can never

50
00:01:45,439 --> 00:01:47,280
fail actually so because a failure of

51
00:01:47,280 --> 00:01:49,280
this system would create

52
00:01:49,280 --> 00:01:51,680
a threat to life or

53
00:01:51,680 --> 00:01:53,600
even worse condition

54
00:01:53,600 --> 00:01:56,479
so avionics space applications or

55
00:01:56,479 --> 00:01:58,960
autonomous cars also like regular cars

56
00:01:58,960 --> 00:02:01,280
are examples of this system we we take

57
00:02:01,280 --> 00:02:03,360
care of mainly

58
00:02:03,360 --> 00:02:05,920
and the requirements of these systems

59
00:02:05,920 --> 00:02:07,680
modern currently

60
00:02:07,680 --> 00:02:09,038
are really

61
00:02:09,038 --> 00:02:11,440
really strictly because this system

62
00:02:11,440 --> 00:02:13,200
requires many times to accelerate deep

63
00:02:13,200 --> 00:02:15,599
neural networks for their requirements

64
00:02:15,599 --> 00:02:17,120
on

65
00:02:17,120 --> 00:02:18,959
image detection for instance so they

66
00:02:18,959 --> 00:02:21,200
have they need high throughput but also

67
00:02:21,200 --> 00:02:22,720
high power efficiency because they are

68
00:02:22,720 --> 00:02:23,760
embedded

69
00:02:23,760 --> 00:02:24,720
plus

70
00:02:24,720 --> 00:02:27,120
security uh requirements of course i'm

71
00:02:27,120 --> 00:02:28,560
not gonna go through that you are more

72
00:02:28,560 --> 00:02:30,400
expert than i am in that

73
00:02:30,400 --> 00:02:32,720
but also very important is safety so

74
00:02:32,720 --> 00:02:34,720
timing predictability so you want data

75
00:02:34,720 --> 00:02:37,760
critical task execute within a deadline

76
00:02:37,760 --> 00:02:40,080
and isolation among multiple models that

77
00:02:40,080 --> 00:02:43,440
execute on the same system

78
00:02:43,519 --> 00:02:45,200
among the heterogeneous platforms that

79
00:02:45,200 --> 00:02:46,560
are available

80
00:02:46,560 --> 00:02:49,120
there are gpus associates and fpga

81
00:02:49,120 --> 00:02:50,640
associates that and customer services

82
00:02:50,640 --> 00:02:51,680
that are

83
00:02:51,680 --> 00:02:53,200
very common right now for implementing

84
00:02:53,200 --> 00:02:55,519
disguise on new generation uh safety

85
00:02:55,519 --> 00:02:57,840
critical and security critical systems

86
00:02:57,840 --> 00:03:01,040
gpu series are great they are the common

87
00:03:01,040 --> 00:03:02,560
choice let's say

88
00:03:02,560 --> 00:03:04,319
but for some application unfortunately

89
00:03:04,319 --> 00:03:07,040
they cannot be applied like for avionics

90
00:03:07,040 --> 00:03:08,239
in particular

91
00:03:08,239 --> 00:03:10,159
or also some other critical applications

92
00:03:10,159 --> 00:03:12,720
so we focus a lot on fpga socs and on

93
00:03:12,720 --> 00:03:15,519
gpus to provide hard

94
00:03:15,519 --> 00:03:17,200
constraints on

95
00:03:17,200 --> 00:03:18,480
what we would like

96
00:03:18,480 --> 00:03:22,399
to propose hard timing constraints

97
00:03:22,959 --> 00:03:24,400
if you look inside the nitrogenous

98
00:03:24,400 --> 00:03:25,680
platform what you're going to find

99
00:03:25,680 --> 00:03:28,480
basically is a set of controllers in the

100
00:03:28,480 --> 00:03:31,120
set of peripherals the controllers are

101
00:03:31,120 --> 00:03:32,959
the active guys on the on the bus

102
00:03:32,959 --> 00:03:34,640
basically that

103
00:03:34,640 --> 00:03:37,760
uh request the um send request to the

104
00:03:37,760 --> 00:03:40,080
peripherals and these are processor dma

105
00:03:40,080 --> 00:03:42,480
server accelerators etc the peripherals

106
00:03:42,480 --> 00:03:44,720
are just in charge of responding to this

107
00:03:44,720 --> 00:03:46,480
kind of request

108
00:03:46,480 --> 00:03:48,080
providing data or accepting the data in

109
00:03:48,080 --> 00:03:50,239
case of right they are interconnected

110
00:03:50,239 --> 00:03:52,080
with an interconnect in this case this

111
00:03:52,080 --> 00:03:54,480
is an axa interconnect which is

112
00:03:54,480 --> 00:03:56,400
the de facto standard for communication

113
00:03:56,400 --> 00:03:58,840
in the most of the platforms that we've

114
00:03:58,840 --> 00:04:00,480
seen

115
00:04:00,480 --> 00:04:02,480
the peripherals are shared among the

116
00:04:02,480 --> 00:04:04,319
controllers typically think of a shared

117
00:04:04,319 --> 00:04:05,599
dram memory

118
00:04:05,599 --> 00:04:07,200
and interconnect so is in charge also

119
00:04:07,200 --> 00:04:08,560
arbitrating the access of the

120
00:04:08,560 --> 00:04:10,640
controllers to a single peripherals or

121
00:04:10,640 --> 00:04:12,480
to a multi peripherals

122
00:04:12,480 --> 00:04:14,000
multiple controllers however can

123
00:04:14,000 --> 00:04:16,079
generate heterogeneous interference and

124
00:04:16,079 --> 00:04:17,279
we've seen that

125
00:04:17,279 --> 00:04:18,959
the protocol itself leave a lot of

126
00:04:18,959 --> 00:04:21,199
freedom on how the transactions the

127
00:04:21,199 --> 00:04:23,520
requests for transactions are issued on

128
00:04:23,520 --> 00:04:24,639
the bus

129
00:04:24,639 --> 00:04:26,639
and this can create some issues that i'm

130
00:04:26,639 --> 00:04:29,120
going to introduce you later

131
00:04:29,120 --> 00:04:30,400
so the standard itself i've already

132
00:04:30,400 --> 00:04:32,240
introduced you so it's a standard form

133
00:04:32,240 --> 00:04:33,840
armor and

134
00:04:33,840 --> 00:04:35,680
it's a great standard very popular

135
00:04:35,680 --> 00:04:38,080
because it allows great flexibility

136
00:04:38,080 --> 00:04:41,199
and in this case each controller edge

137
00:04:41,199 --> 00:04:43,280
and each peripheral as a separated

138
00:04:43,280 --> 00:04:45,600
access to the system interconnect and

139
00:04:45,600 --> 00:04:47,040
this is something that we really like

140
00:04:47,040 --> 00:04:48,800
because it provides uh isolation

141
00:04:48,800 --> 00:04:50,639
electrical isolation among the

142
00:04:50,639 --> 00:04:52,080
controllers

143
00:04:52,080 --> 00:04:54,560
and this is something that

144
00:04:54,560 --> 00:04:56,960
interests us because it allows any

145
00:04:56,960 --> 00:04:58,560
controller to communicate directly

146
00:04:58,560 --> 00:05:00,080
without interference from the other with

147
00:05:00,080 --> 00:05:02,000
the system interconnected list however

148
00:05:02,000 --> 00:05:03,360
we found that there are dependencies

149
00:05:03,360 --> 00:05:05,759
inside that i'm gonna show you later

150
00:05:05,759 --> 00:05:07,840
the definition of axi defines basically

151
00:05:07,840 --> 00:05:10,160
a manager and peripheral interface with

152
00:05:10,160 --> 00:05:11,840
five different channels that are handled

153
00:05:11,840 --> 00:05:13,600
independently and this is the

154
00:05:13,600 --> 00:05:16,000
representation

155
00:05:16,000 --> 00:05:18,320
okay this is the platform our target

156
00:05:18,320 --> 00:05:20,720
platform basically that is a zinc ultra

157
00:05:20,720 --> 00:05:23,360
scale plus from xilinx we also target

158
00:05:23,360 --> 00:05:25,919
the zinc 7000 platform all of the work

159
00:05:25,919 --> 00:05:27,440
presented here is applicable to both of

160
00:05:27,440 --> 00:05:28,320
them

161
00:05:28,320 --> 00:05:30,639
and basically this kind of platform is

162
00:05:30,639 --> 00:05:32,320
uh it can be seen

163
00:05:32,320 --> 00:05:34,960
it can be simplified as in that um in

164
00:05:34,960 --> 00:05:36,800
that simplified representation as

165
00:05:36,800 --> 00:05:38,400
composed of a

166
00:05:38,400 --> 00:05:40,800
processing system that is this purple

167
00:05:40,800 --> 00:05:42,400
one here that includes multiple

168
00:05:42,400 --> 00:05:45,039
processors like cortex a53 and the

169
00:05:45,039 --> 00:05:46,720
real-time processors and the

170
00:05:46,720 --> 00:05:49,199
programmable logic where you place a

171
00:05:49,199 --> 00:05:51,600
custom hardware accelerators or custom

172
00:05:51,600 --> 00:05:55,199
processor whatever you want to implement

173
00:05:55,199 --> 00:05:57,520
into inside of the custom logic

174
00:05:57,520 --> 00:05:58,880
so we're going to use

175
00:05:58,880 --> 00:06:01,280
the part the programmable logic to

176
00:06:01,280 --> 00:06:04,160
deploy controller managers and to

177
00:06:04,160 --> 00:06:05,520
analyze

178
00:06:05,520 --> 00:06:07,680
what happens in the bus interaction

179
00:06:07,680 --> 00:06:08,960
whenever they

180
00:06:08,960 --> 00:06:11,919
interfere among each other

181
00:06:11,919 --> 00:06:14,080
our threat model assumes that the

182
00:06:14,080 --> 00:06:18,080
controllers are untrusted and

183
00:06:18,080 --> 00:06:19,840
we assume that are untrusted because

184
00:06:19,840 --> 00:06:21,360
they can be actually

185
00:06:21,360 --> 00:06:22,319
uh

186
00:06:22,319 --> 00:06:24,720
get from third party ipc it's very it's

187
00:06:24,720 --> 00:06:26,400
very common actually but they can also

188
00:06:26,400 --> 00:06:27,759
be affected by bugs because of

189
00:06:27,759 --> 00:06:31,280
superficial uh verification or they can

190
00:06:31,280 --> 00:06:33,280
be malicious also

191
00:06:33,280 --> 00:06:34,880
we trust the interconnected peripheral

192
00:06:34,880 --> 00:06:36,400
we don't get

193
00:06:36,400 --> 00:06:38,799
inside

194
00:06:39,520 --> 00:06:41,039
looking for the bugs

195
00:06:41,039 --> 00:06:43,039
inside of that kind of

196
00:06:43,039 --> 00:06:44,639
modules

197
00:06:44,639 --> 00:06:47,440
and we focus on the availability of the

198
00:06:47,440 --> 00:06:49,440
controllers to the peripherals so we

199
00:06:49,440 --> 00:06:51,280
would like that in any time the

200
00:06:51,280 --> 00:06:53,360
controllers can access the peripherals

201
00:06:53,360 --> 00:06:56,880
they they're entitled to of course

202
00:06:56,960 --> 00:07:00,479
so how we started our journey well

203
00:07:00,479 --> 00:07:03,759
fpgas is where we were becoming very

204
00:07:03,759 --> 00:07:05,919
interesting for the implementation on

205
00:07:05,919 --> 00:07:08,319
next generation system embedded systems

206
00:07:08,319 --> 00:07:09,680
because of the reason i was telling you

207
00:07:09,680 --> 00:07:11,840
before and the challenge we wanted to

208
00:07:11,840 --> 00:07:13,840
face is the timing predictability on the

209
00:07:13,840 --> 00:07:15,919
bus and memory interactions and at that

210
00:07:15,919 --> 00:07:17,840
time there was nothing like there were

211
00:07:17,840 --> 00:07:20,319
there was no academic work on that

212
00:07:20,319 --> 00:07:22,960
so our main aim was to bound response

213
00:07:22,960 --> 00:07:25,440
time of the bus and memory interactions

214
00:07:25,440 --> 00:07:26,560
however

215
00:07:26,560 --> 00:07:29,280
we ended up at first facing some

216
00:07:29,280 --> 00:07:31,360
security and safety issues that we had

217
00:07:31,360 --> 00:07:34,000
to solve and after that

218
00:07:34,000 --> 00:07:36,000
we proposed some some work a couple of

219
00:07:36,000 --> 00:07:39,039
work on timing predictability

220
00:07:39,039 --> 00:07:41,120
so the test architecture i'm going to

221
00:07:41,120 --> 00:07:43,280
start with is

222
00:07:43,280 --> 00:07:44,400
this one here

223
00:07:44,400 --> 00:07:46,080
that this is a generic one but in

224
00:07:46,080 --> 00:07:48,319
general we got here three harder

225
00:07:48,319 --> 00:07:50,720
accelerators that are we use dmas from

226
00:07:50,720 --> 00:07:53,039
styling so commercial accelerators we

227
00:07:53,039 --> 00:07:55,280
use the stock interconnect also from the

228
00:07:55,280 --> 00:07:59,360
vendor and we create this architecture

229
00:07:59,360 --> 00:08:01,520
what we wanted to do at first is test

230
00:08:01,520 --> 00:08:03,360
how the assigned bandwidth of the

231
00:08:03,360 --> 00:08:05,039
hardware accelerator

232
00:08:05,039 --> 00:08:06,080
can

233
00:08:06,080 --> 00:08:08,400
varies according to how you configure

234
00:08:08,400 --> 00:08:10,000
the models itself so to see whether

235
00:08:10,000 --> 00:08:12,879
there were dependencies on that

236
00:08:12,879 --> 00:08:14,560
so what was implemented here what is

237
00:08:14,560 --> 00:08:16,400
implemented here we check the data sheet

238
00:08:16,400 --> 00:08:18,479
it's around robin arbitration so what we

239
00:08:18,479 --> 00:08:20,479
expected from around robin arbitration

240
00:08:20,479 --> 00:08:21,840
is that

241
00:08:21,840 --> 00:08:22,720
the

242
00:08:22,720 --> 00:08:24,560
bandwidth that is

243
00:08:24,560 --> 00:08:28,800
given to each of the model is fair

244
00:08:28,800 --> 00:08:31,520
so we did this with this architecture we

245
00:08:31,520 --> 00:08:33,440
take one of the guys under as the guy

246
00:08:33,440 --> 00:08:35,599
under analysis the one in red here and

247
00:08:35,599 --> 00:08:37,519
the other two we make them generating

248
00:08:37,519 --> 00:08:39,120
the most of the traffic they could so

249
00:08:39,120 --> 00:08:41,039
accessing the bus in the most greedy way

250
00:08:41,039 --> 00:08:43,679
that they could and we we wanted to

251
00:08:43,679 --> 00:08:45,760
measure what is the bandwidth associated

252
00:08:45,760 --> 00:08:47,680
to this guy

253
00:08:47,680 --> 00:08:50,000
so and the bandwidth is this one

254
00:08:50,000 --> 00:08:52,320
so what we saw is that here this is

255
00:08:52,320 --> 00:08:53,680
configuration of the interfering order

256
00:08:53,680 --> 00:08:55,440
accelerator i'll show you later what do

257
00:08:55,440 --> 00:08:57,440
i mean with that the bandwidth of this

258
00:08:57,440 --> 00:08:59,680
guy under analysis associated with him

259
00:08:59,680 --> 00:09:01,680
goes down from the 33 percent which is

260
00:09:01,680 --> 00:09:03,040
the one expected the fair bandwidth

261
00:09:03,040 --> 00:09:05,760
distribution to something like

262
00:09:05,760 --> 00:09:08,640
three percent something like this

263
00:09:08,640 --> 00:09:09,519
so

264
00:09:09,519 --> 00:09:11,440
instead of being a property of defined

265
00:09:11,440 --> 00:09:13,680
by interconnect itself the configuration

266
00:09:13,680 --> 00:09:17,279
of the interfering models was able to

267
00:09:17,279 --> 00:09:20,480
endanger the access to the bandwidth of

268
00:09:20,480 --> 00:09:22,240
the hardware model under analysis and

269
00:09:22,240 --> 00:09:23,839
decrease the access to the bandwidth of

270
00:09:23,839 --> 00:09:27,839
more than 10 percent than 10 times sorry

271
00:09:27,839 --> 00:09:30,000
so we did investigation on that we did

272
00:09:30,000 --> 00:09:32,320
it on both of the platform the zinc 7000

273
00:09:32,320 --> 00:09:34,720
and the ultrascale plus here i've got a

274
00:09:34,720 --> 00:09:36,399
short them we put

275
00:09:36,399 --> 00:09:38,399
a integrated logic analyzer probe and we

276
00:09:38,399 --> 00:09:40,160
would like to plot to what happens

277
00:09:40,160 --> 00:09:42,880
actually on the bus so why this happens

278
00:09:42,880 --> 00:09:45,760
i've got to share them on that

279
00:09:45,760 --> 00:09:48,160
so let me stop here

280
00:09:48,160 --> 00:09:51,839
i want to i went to the end

281
00:09:51,920 --> 00:09:53,279
okay

282
00:09:53,279 --> 00:09:56,480
so this is the architecture for the fpga

283
00:09:56,480 --> 00:09:58,399
and we got 3dmas that

284
00:09:58,399 --> 00:10:00,640
generate traffic and this can be

285
00:10:00,640 --> 00:10:02,640
whatever kind of

286
00:10:02,640 --> 00:10:04,399
controller you would like to

287
00:10:04,399 --> 00:10:07,120
simulate the system interconnect is just

288
00:10:07,120 --> 00:10:09,040
a standard system interconnect that is

289
00:10:09,040 --> 00:10:10,800
connected to the processing system to

290
00:10:10,800 --> 00:10:13,040
access the memory in our case so the

291
00:10:13,040 --> 00:10:15,040
shared memory there is other logic for

292
00:10:15,040 --> 00:10:16,640
configuration we don't go into that and

293
00:10:16,640 --> 00:10:18,160
this is the integrated logic analyzer

294
00:10:18,160 --> 00:10:21,839
that we do to probe all of the

295
00:10:21,839 --> 00:10:24,000
that we use to probe all of the

296
00:10:24,000 --> 00:10:25,680
interfaces the x interfaces and see

297
00:10:25,680 --> 00:10:28,160
what's going on

298
00:10:28,160 --> 00:10:30,079
so here i've already synthesized the

299
00:10:30,079 --> 00:10:32,000
design what i'm doing is writing this

300
00:10:32,000 --> 00:10:33,839
design inside of the board so in the

301
00:10:33,839 --> 00:10:35,600
programmable logic i'm uploading it to

302
00:10:35,600 --> 00:10:37,680
the programmable logic

303
00:10:37,680 --> 00:10:40,640
and after that i launched the sdk from

304
00:10:40,640 --> 00:10:42,720
silence and here there is some code that

305
00:10:42,720 --> 00:10:44,720
we use to set up all of the models

306
00:10:44,720 --> 00:10:47,680
inside of the system the dmas

307
00:10:47,680 --> 00:10:48,640
and

308
00:10:48,640 --> 00:10:51,040
yeah we connect the uber to the terminal

309
00:10:51,040 --> 00:10:53,440
to get like some results from that

310
00:10:53,440 --> 00:10:54,800
after initialization we can see the

311
00:10:54,800 --> 00:10:56,160
track

312
00:10:56,160 --> 00:10:57,920
from

313
00:10:57,920 --> 00:10:59,519
coming from the system integrated logic

314
00:10:59,519 --> 00:11:01,120
analyzer

315
00:11:01,120 --> 00:11:02,800
so it is uploading

316
00:11:02,800 --> 00:11:04,800
we set up the trigger to get a specific

317
00:11:04,800 --> 00:11:07,680
moment in time

318
00:11:10,480 --> 00:11:12,720
okay

319
00:11:13,440 --> 00:11:16,320
and now with the software we configure

320
00:11:16,320 --> 00:11:18,399
the traffic generators in the fpga and

321
00:11:18,399 --> 00:11:19,600
make them

322
00:11:19,600 --> 00:11:22,600
executing

323
00:11:30,640 --> 00:11:33,120
should be fast

324
00:11:33,120 --> 00:11:34,560
okay here we go

325
00:11:34,560 --> 00:11:36,560
we got the track

326
00:11:36,560 --> 00:11:38,240
so this is the track the actual track

327
00:11:38,240 --> 00:11:40,640
collected on the fpga what you see here

328
00:11:40,640 --> 00:11:43,360
there are four interfaces axe interfaces

329
00:11:43,360 --> 00:11:45,440
these first three are the interfaces

330
00:11:45,440 --> 00:11:47,519
that are connected directly to the

331
00:11:47,519 --> 00:11:50,000
hardware module why this guy here this

332
00:11:50,000 --> 00:11:52,320
interface here is the interface that

333
00:11:52,320 --> 00:11:54,160
comes from the processing system so it

334
00:11:54,160 --> 00:11:56,160
provides you data and accept the data

335
00:11:56,160 --> 00:11:58,000
from the fpga

336
00:11:58,000 --> 00:12:00,800
so this one and this one are the two

337
00:12:00,800 --> 00:12:02,880
interfering hardware model while this

338
00:12:02,880 --> 00:12:05,279
one is the module under analysis

339
00:12:05,279 --> 00:12:07,600
this yellow one are the data that comes

340
00:12:07,600 --> 00:12:10,240
from the memory and this blue one are

341
00:12:10,240 --> 00:12:12,320
the right data provided to the memory

342
00:12:12,320 --> 00:12:14,959
okay so they're all accessing the bus in

343
00:12:14,959 --> 00:12:16,880
the most really way that they can

344
00:12:16,880 --> 00:12:19,279
however you see that how the data that

345
00:12:19,279 --> 00:12:22,240
comes from the two interfering they get

346
00:12:22,240 --> 00:12:24,639
the two interfering get most of the data

347
00:12:24,639 --> 00:12:27,279
while the guy under analysis the other

348
00:12:27,279 --> 00:12:28,959
model under analysis just get a small

349
00:12:28,959 --> 00:12:31,680
chunk of data so like here they are like

350
00:12:31,680 --> 00:12:34,560
maybe 12 words of data while here 250 or

351
00:12:34,560 --> 00:12:35,680
something

352
00:12:35,680 --> 00:12:36,399
so

353
00:12:36,399 --> 00:12:38,639
most of the data are going to the

354
00:12:38,639 --> 00:12:41,200
interfering one

355
00:12:41,200 --> 00:12:44,079
sorry about that

356
00:12:46,720 --> 00:12:48,959
okay

357
00:12:51,279 --> 00:12:53,040
should be good yeah

358
00:12:53,040 --> 00:12:54,880
okay so we analyzed the issue

359
00:12:54,880 --> 00:12:56,639
and to try to understand what was going

360
00:12:56,639 --> 00:12:59,120
on and basically what we did what we saw

361
00:12:59,120 --> 00:13:00,720
is that actually the interconnect was

362
00:13:00,720 --> 00:13:02,959
serving the hardware module following an

363
00:13:02,959 --> 00:13:05,040
actual round-robin schema as expected

364
00:13:05,040 --> 00:13:07,200
from the data sheet

365
00:13:07,200 --> 00:13:09,600
but the granularity on data it actually

366
00:13:09,600 --> 00:13:11,440
depends on

367
00:13:11,440 --> 00:13:14,480
how the model requests the data so the

368
00:13:14,480 --> 00:13:17,440
model can submit a request and request

369
00:13:17,440 --> 00:13:20,480
more data with respect to the others

370
00:13:20,480 --> 00:13:22,000
and in this case

371
00:13:22,000 --> 00:13:23,519
you serve the transaction with round

372
00:13:23,519 --> 00:13:25,279
robin but when the data come back and

373
00:13:25,279 --> 00:13:26,560
you have the equivalent round rubbing

374
00:13:26,560 --> 00:13:28,560
from for the data there are more data

375
00:13:28,560 --> 00:13:30,560
going to some other models with respect

376
00:13:30,560 --> 00:13:32,639
to the other and this cause

377
00:13:32,639 --> 00:13:33,360
an

378
00:13:33,360 --> 00:13:36,480
unexpected bandwidth

379
00:13:36,480 --> 00:13:38,880
bandwidth loss with respect to the guy

380
00:13:38,880 --> 00:13:41,199
under analysis

381
00:13:41,199 --> 00:13:42,399
so

382
00:13:42,399 --> 00:13:44,480
we did a mathematical very simple

383
00:13:44,480 --> 00:13:46,000
mathematical analysis on that to

384
00:13:46,000 --> 00:13:48,000
understand what how was the entity of

385
00:13:48,000 --> 00:13:49,120
the issue

386
00:13:49,120 --> 00:13:50,639
and what

387
00:13:50,639 --> 00:13:53,040
considering one single model that has

388
00:13:53,040 --> 00:13:54,240
the burst length which is the

389
00:13:54,240 --> 00:13:57,760
configuration we actually uh check

390
00:13:57,760 --> 00:14:00,639
to 16 words which means you ask for a

391
00:14:00,639 --> 00:14:02,800
single transaction you got the 16 words

392
00:14:02,800 --> 00:14:05,279
of data for each single transaction

393
00:14:05,279 --> 00:14:07,920
and you got one single this is the this

394
00:14:07,920 --> 00:14:09,600
is a table where you got the number of

395
00:14:09,600 --> 00:14:12,320
interfering order accelerators and is

396
00:14:12,320 --> 00:14:13,839
the burst length of the interfering

397
00:14:13,839 --> 00:14:15,440
order accelerators

398
00:14:15,440 --> 00:14:17,279
so very briefly what we see is that just

399
00:14:17,279 --> 00:14:20,079
with one single interfering model that

400
00:14:20,079 --> 00:14:22,560
make can do transaction longer with

401
00:14:22,560 --> 00:14:25,360
respect to what we can do as guy under

402
00:14:25,360 --> 00:14:28,399
analysis i will show you later why

403
00:14:28,399 --> 00:14:30,399
the drop is the 88

404
00:14:30,399 --> 00:14:33,279
percent so you pass from a 50 of uh

405
00:14:33,279 --> 00:14:35,440
bandwidth assigned to something like six

406
00:14:35,440 --> 00:14:38,480
percent or something like this

407
00:14:38,720 --> 00:14:39,760
okay so

408
00:14:39,760 --> 00:14:41,839
you're guessing now if

409
00:14:41,839 --> 00:14:43,199
this is a real issue should we care

410
00:14:43,199 --> 00:14:45,040
about that

411
00:14:45,040 --> 00:14:47,440
how likely is that to happen

412
00:14:47,440 --> 00:14:49,440
well consider that controllers can come

413
00:14:49,440 --> 00:14:51,040
from different sources

414
00:14:51,040 --> 00:14:52,399
and

415
00:14:52,399 --> 00:14:54,160
you can develop more of your controllers

416
00:14:54,160 --> 00:14:56,399
inside of your system if you want but

417
00:14:56,399 --> 00:14:58,399
it's expensive so if you want to develop

418
00:14:58,399 --> 00:14:59,920
a processor for instance and integrate

419
00:14:59,920 --> 00:15:01,440
it inside of your system you may need

420
00:15:01,440 --> 00:15:02,240
time

421
00:15:02,240 --> 00:15:04,720
so what is very popular is getting

422
00:15:04,720 --> 00:15:06,800
controllers from third party right you

423
00:15:06,800 --> 00:15:09,600
get them from outside so

424
00:15:09,600 --> 00:15:11,199
you can verify them sometimes yes

425
00:15:11,199 --> 00:15:13,440
sometimes you can't so it depends also

426
00:15:13,440 --> 00:15:16,480
there are different development

427
00:15:16,480 --> 00:15:18,320
methods for these controllers they can

428
00:15:18,320 --> 00:15:21,920
be developed using standard rtl or also

429
00:15:21,920 --> 00:15:23,199
high level synthesis that is something

430
00:15:23,199 --> 00:15:24,959
that fpgas vendors are

431
00:15:24,959 --> 00:15:26,720
pushing a lot right now because it

432
00:15:26,720 --> 00:15:29,199
allows people that doesn't have like a

433
00:15:29,199 --> 00:15:31,040
strong background in hardware to develop

434
00:15:31,040 --> 00:15:32,639
accelerators

435
00:15:32,639 --> 00:15:34,639
but also other construction language of

436
00:15:34,639 --> 00:15:35,759
course

437
00:15:35,759 --> 00:15:38,160
so this can create challenges first of

438
00:15:38,160 --> 00:15:40,160
all for verification because the model

439
00:15:40,160 --> 00:15:42,959
can be very complex and if you are able

440
00:15:42,959 --> 00:15:44,399
to get the code of the model you have to

441
00:15:44,399 --> 00:15:46,000
verificate that

442
00:15:46,000 --> 00:15:47,920
most of the application many time is

443
00:15:47,920 --> 00:15:50,880
done through manual inspection so

444
00:15:50,880 --> 00:15:52,959
it's server prone right

445
00:15:52,959 --> 00:15:55,279
if you have hls generated code so from

446
00:15:55,279 --> 00:15:56,880
high level synthesis compiler you go to

447
00:15:56,880 --> 00:15:59,199
an rtl that code can be very very

448
00:15:59,199 --> 00:16:01,360
difficult to analyze because it's not

449
00:16:01,360 --> 00:16:02,800
done to be

450
00:16:02,800 --> 00:16:04,959
read by humans actually but also you can

451
00:16:04,959 --> 00:16:06,399
have third party modules that are

452
00:16:06,399 --> 00:16:08,480
encrypted and you can actually verify

453
00:16:08,480 --> 00:16:09,600
them

454
00:16:09,600 --> 00:16:11,360
so create dependencies and also consider

455
00:16:11,360 --> 00:16:13,440
that these models many most of the times

456
00:16:13,440 --> 00:16:16,639
many times are software configurable so

457
00:16:16,639 --> 00:16:18,959
if you leave also these this degree of

458
00:16:18,959 --> 00:16:21,120
freedom of configured through software

459
00:16:21,120 --> 00:16:24,639
it create it can create other issues

460
00:16:24,639 --> 00:16:25,759
there are different version of the

461
00:16:25,759 --> 00:16:27,920
standard also that they can be combined

462
00:16:27,920 --> 00:16:30,399
together and in the case before we got

463
00:16:30,399 --> 00:16:34,160
an xi3 and an xi4 combined and the xi3

464
00:16:34,160 --> 00:16:36,480
guy was able to issue transaction for 16

465
00:16:36,480 --> 00:16:38,079
words at most because the standard was

466
00:16:38,079 --> 00:16:38,880
that

467
00:16:38,880 --> 00:16:42,240
and exci 4 was able to ask for 256 word

468
00:16:42,240 --> 00:16:44,880
transactions so it was actually

469
00:16:44,880 --> 00:16:46,560
it's actually impacting the bandits of

470
00:16:46,560 --> 00:16:49,120
that and also with hls

471
00:16:49,120 --> 00:16:52,000
they're pushing a lot on hls but these

472
00:16:52,000 --> 00:16:54,560
abstract a lot what you are doing with

473
00:16:54,560 --> 00:16:56,240
your hardware so these are low level

474
00:16:56,240 --> 00:16:57,680
details that

475
00:16:57,680 --> 00:16:59,120
if you develop

476
00:16:59,120 --> 00:17:00,639
if you know about that you can set up

477
00:17:00,639 --> 00:17:02,959
some pragmas on that of course but they

478
00:17:02,959 --> 00:17:04,720
can be hidden from some people that they

479
00:17:04,720 --> 00:17:08,640
want just to develop some hardware model

480
00:17:08,640 --> 00:17:10,319
so what i learned from here symbol

481
00:17:10,319 --> 00:17:12,079
summarizing is that leaving the

482
00:17:12,079 --> 00:17:13,679
controller defining the structure of the

483
00:17:13,679 --> 00:17:16,400
transaction can create a problem in the

484
00:17:16,400 --> 00:17:18,880
bandwidth distribution and it can affect

485
00:17:18,880 --> 00:17:20,559
the availability of the share the

486
00:17:20,559 --> 00:17:22,559
resources in particular on the memory

487
00:17:22,559 --> 00:17:24,079
that's what we are

488
00:17:24,079 --> 00:17:26,240
we were focusing more actually

489
00:17:26,240 --> 00:17:27,760
we have a proposed solution experimental

490
00:17:27,760 --> 00:17:29,919
results later in this presentation i

491
00:17:29,919 --> 00:17:32,000
will go now into another problem we've

492
00:17:32,000 --> 00:17:33,840
seen that to me is even more interesting

493
00:17:33,840 --> 00:17:36,559
that this one that i showed

494
00:17:36,559 --> 00:17:39,919
so after using dms from science we

495
00:17:39,919 --> 00:17:42,080
started developing our own axi-compliant

496
00:17:42,080 --> 00:17:44,880
models because we we needed a sick um a

497
00:17:44,880 --> 00:17:47,840
model that we could be able to

498
00:17:47,840 --> 00:17:50,080
monitor for this from the cycle so we've

499
00:17:50,080 --> 00:17:52,960
been able to to generate traffic at the

500
00:17:52,960 --> 00:17:54,880
cycle accurate level

501
00:17:54,880 --> 00:17:56,400
and we find a very interesting behavior

502
00:17:56,400 --> 00:17:58,160
here this is the architecture scenes

503
00:17:58,160 --> 00:17:59,520
that we're gonna see

504
00:17:59,520 --> 00:18:02,000
and still we are operating on both of

505
00:18:02,000 --> 00:18:04,720
this platform

506
00:18:06,160 --> 00:18:08,000
okay let me stop here to present

507
00:18:08,000 --> 00:18:09,440
architecture

508
00:18:09,440 --> 00:18:10,880
three hardware models these are the

509
00:18:10,880 --> 00:18:12,960
models that i develop these are custom

510
00:18:12,960 --> 00:18:14,880
fully compliant taxi models

511
00:18:14,880 --> 00:18:16,960
we got an interconnect plus some other

512
00:18:16,960 --> 00:18:18,960
logic here that don't consider that is a

513
00:18:18,960 --> 00:18:20,080
solution that i'm going to propose you

514
00:18:20,080 --> 00:18:23,440
later some configuration um logic here

515
00:18:23,440 --> 00:18:24,880
and system interconnect and the system

516
00:18:24,880 --> 00:18:29,840
ela and we're accessing here the memory

517
00:18:31,760 --> 00:18:33,280
okay we're doing the same thing i can

518
00:18:33,280 --> 00:18:35,280
skip some parts eventually so we are we

519
00:18:35,280 --> 00:18:37,600
are actually writing the bit stream we

520
00:18:37,600 --> 00:18:40,639
have some code running

521
00:18:41,360 --> 00:18:43,280
okay

522
00:18:43,280 --> 00:18:44,880
so we configure one of the three models

523
00:18:44,880 --> 00:18:47,520
to in to

524
00:18:47,520 --> 00:18:49,200
inject

525
00:18:49,200 --> 00:18:51,280
a specific behavior that is compliant

526
00:18:51,280 --> 00:18:52,799
with the standard

527
00:18:52,799 --> 00:18:54,240
but

528
00:18:54,240 --> 00:18:56,720
it creates a problem and right now i'm

529
00:18:56,720 --> 00:18:57,679
gonna show you when we're gonna

530
00:18:57,679 --> 00:18:58,799
collecting

531
00:18:58,799 --> 00:19:01,440
the waveform

532
00:19:03,520 --> 00:19:04,559
okay

533
00:19:04,559 --> 00:19:07,678
setup is running

534
00:19:08,000 --> 00:19:08,840
here we

535
00:19:08,840 --> 00:19:10,559
go

536
00:19:10,559 --> 00:19:13,678
let's zoom the track a bit

537
00:19:14,720 --> 00:19:17,760
okay here we go

538
00:19:17,840 --> 00:19:21,039
sorry i'm not very good with this

539
00:19:21,039 --> 00:19:22,799
keynote

540
00:19:22,799 --> 00:19:24,720
video integration

541
00:19:24,720 --> 00:19:27,360
okay let's mess up the okay

542
00:19:27,360 --> 00:19:30,000
so three hardware models here

543
00:19:30,000 --> 00:19:32,720
fpgaps interface data where we accept

544
00:19:32,720 --> 00:19:34,160
the data in this case we are issuing

545
00:19:34,160 --> 00:19:35,679
right transactions

546
00:19:35,679 --> 00:19:38,559
so the first guy here the top one is

547
00:19:38,559 --> 00:19:40,240
issuing for request for transaction for

548
00:19:40,240 --> 00:19:43,600
right for some length is not important

549
00:19:43,600 --> 00:19:45,760
and the other two

550
00:19:45,760 --> 00:19:47,760
modules in the system are doing the same

551
00:19:47,760 --> 00:19:50,000
so the requests are eventually

552
00:19:50,000 --> 00:19:52,559
granted at the fpgas interface to reach

553
00:19:52,559 --> 00:19:55,679
the memory and here are the requests

554
00:19:55,679 --> 00:19:57,360
these two guys here this guy here and

555
00:19:57,360 --> 00:19:59,039
this guy here are already ready to pro

556
00:19:59,039 --> 00:20:01,039
to give the data the right data these

557
00:20:01,039 --> 00:20:02,640
are the right data provided to the

558
00:20:02,640 --> 00:20:04,320
system interconnect

559
00:20:04,320 --> 00:20:06,640
by these two hardware models

560
00:20:06,640 --> 00:20:08,320
but this guy here didn't start providing

561
00:20:08,320 --> 00:20:10,159
the data yet so what is the problem is

562
00:20:10,159 --> 00:20:12,559
that the round-robin arbiter here

563
00:20:12,559 --> 00:20:14,640
submitted this first request the request

564
00:20:14,640 --> 00:20:16,640
of this guy here so this is the first in

565
00:20:16,640 --> 00:20:17,600
line

566
00:20:17,600 --> 00:20:20,000
and as long as this guy here does not

567
00:20:20,000 --> 00:20:22,320
provide all of the world of data on

568
00:20:22,320 --> 00:20:24,159
another channel by the way it's another

569
00:20:24,159 --> 00:20:27,600
channel that is handled independently

570
00:20:27,600 --> 00:20:30,240
the bus the right bus to the memory is

571
00:20:30,240 --> 00:20:31,120
stuck

572
00:20:31,120 --> 00:20:32,720
and the other two guys even if they are

573
00:20:32,720 --> 00:20:34,640
already provided all of the data they

574
00:20:34,640 --> 00:20:37,840
cannot access it anymore

575
00:20:38,159 --> 00:20:40,880
we analyze that so this is the same way

576
00:20:40,880 --> 00:20:42,960
for track but it's a simplified one just

577
00:20:42,960 --> 00:20:45,280
with one transaction and two other model

578
00:20:45,280 --> 00:20:47,280
here's the summary of what's going on

579
00:20:47,280 --> 00:20:50,000
but basically what happens and with what

580
00:20:50,000 --> 00:20:52,000
it comes from the standard is that as

581
00:20:52,000 --> 00:20:54,159
long as one other module

582
00:20:54,159 --> 00:20:56,960
book the bus submitting a transaction

583
00:20:56,960 --> 00:20:58,640
it the other guys in the system they

584
00:20:58,640 --> 00:21:01,760
cannot provide any word of data to the

585
00:21:01,760 --> 00:21:03,919
memory as long as it does not complete

586
00:21:03,919 --> 00:21:06,000
the old transaction

587
00:21:06,000 --> 00:21:08,559
so this is from the the protocol itself

588
00:21:08,559 --> 00:21:10,880
and it says that the interconnect that

589
00:21:10,880 --> 00:21:11,919
combines

590
00:21:11,919 --> 00:21:12,960
right transactions from different

591
00:21:12,960 --> 00:21:15,919
managers so our our case must ensure

592
00:21:15,919 --> 00:21:18,080
that it forwards the right data in the

593
00:21:18,080 --> 00:21:19,679
address order in the same address or

594
00:21:19,679 --> 00:21:20,960
these are different channels by the way

595
00:21:20,960 --> 00:21:22,640
they are independent but they they

596
00:21:22,640 --> 00:21:24,640
create a dependency here

597
00:21:24,640 --> 00:21:26,240
this is something that

598
00:21:26,240 --> 00:21:30,240
inaxia 3 was kind of solvable you know

599
00:21:30,240 --> 00:21:31,679
maybe in a bad way but it was kind of

600
00:21:31,679 --> 00:21:33,039
solvable but

601
00:21:33,039 --> 00:21:34,960
in exci four the inter level of

602
00:21:34,960 --> 00:21:36,480
transaction has been deprecated and they

603
00:21:36,480 --> 00:21:38,720
generate this problem

604
00:21:38,720 --> 00:21:41,120
so we analyze it and

605
00:21:41,120 --> 00:21:42,320
basically

606
00:21:42,320 --> 00:21:45,120
what we saw is that the bottom line that

607
00:21:45,120 --> 00:21:47,039
the intercontinent itself is trusting

608
00:21:47,039 --> 00:21:50,000
one other model like this guy here that

609
00:21:50,000 --> 00:21:51,600
after submitting his request for

610
00:21:51,600 --> 00:21:54,000
transaction is gonna provide all of the

611
00:21:54,000 --> 00:21:56,400
data for the transaction and it's gonna

612
00:21:56,400 --> 00:21:58,480
provide them rapidly and it's going to

613
00:21:58,480 --> 00:22:00,080
complete the transaction as soon as

614
00:22:00,080 --> 00:22:01,600
possible and leave the bus to the other

615
00:22:01,600 --> 00:22:04,400
guys in the system of course

616
00:22:04,400 --> 00:22:06,000
however

617
00:22:06,000 --> 00:22:07,360
in this way

618
00:22:07,360 --> 00:22:08,799
a single module can deny the access to

619
00:22:08,799 --> 00:22:10,640
the other guys in the system but what is

620
00:22:10,640 --> 00:22:11,840
more interesting is that the protocol

621
00:22:11,840 --> 00:22:14,159
itself is not broken so there is nothing

622
00:22:14,159 --> 00:22:15,360
in the protocol that says that you

623
00:22:15,360 --> 00:22:16,640
should provide the right data

624
00:22:16,640 --> 00:22:20,000
immediately after you submit the request

625
00:22:20,000 --> 00:22:22,559
so the consequences is that that

626
00:22:22,559 --> 00:22:24,880
i mean this is just a summary as long as

627
00:22:24,880 --> 00:22:26,799
a transaction is kept pending by another

628
00:22:26,799 --> 00:22:28,559
module the other guys in the system

629
00:22:28,559 --> 00:22:30,000
cannot access

630
00:22:30,000 --> 00:22:32,400
the shared bus cannot access all of the

631
00:22:32,400 --> 00:22:33,919
peripherals not just one peripherals all

632
00:22:33,919 --> 00:22:35,280
of them

633
00:22:35,280 --> 00:22:36,880
so the availability of shared resources

634
00:22:36,880 --> 00:22:39,120
is compromised but also the network is

635
00:22:39,120 --> 00:22:41,039
left in an inconsistent state so you may

636
00:22:41,039 --> 00:22:42,880
require a system resetting that in here

637
00:22:42,880 --> 00:22:44,640
to restore a safe condition it's

638
00:22:44,640 --> 00:22:46,240
something that in safety critical system

639
00:22:46,240 --> 00:22:48,720
we don't want

640
00:22:48,720 --> 00:22:50,880
okay we already say that

641
00:22:50,880 --> 00:22:52,000
again

642
00:22:52,000 --> 00:22:54,880
should we care about this

643
00:22:54,880 --> 00:22:56,400
so first of all what are the potential

644
00:22:56,400 --> 00:22:58,640
source of this problem of bastille

645
00:22:58,640 --> 00:22:59,760
problem

646
00:22:59,760 --> 00:23:01,120
you can have malicious behavior you can

647
00:23:01,120 --> 00:23:02,960
exploit this i'm going to show you later

648
00:23:02,960 --> 00:23:05,520
also that there are i've got some ideas

649
00:23:05,520 --> 00:23:07,679
that i mean there are some behavior that

650
00:23:07,679 --> 00:23:09,280
are kind of

651
00:23:09,280 --> 00:23:12,080
borderline that you you could exploit

652
00:23:12,080 --> 00:23:14,480
this be this behavior

653
00:23:14,480 --> 00:23:16,400
it can be also most probably a

654
00:23:16,400 --> 00:23:18,080
misbehavior or a faulty model because

655
00:23:18,080 --> 00:23:20,400
bugs in the system are very frequent and

656
00:23:20,400 --> 00:23:22,480
they're very difficult to verify but

657
00:23:22,480 --> 00:23:24,320
also caused by optimizations and in

658
00:23:24,320 --> 00:23:25,760
particular speculative bus access that

659
00:23:25,760 --> 00:23:28,080
i'm going to introduce you later

660
00:23:28,080 --> 00:23:30,880
so how you exploit this well basically

661
00:23:30,880 --> 00:23:32,320
it's pretty simple from the hardware

662
00:23:32,320 --> 00:23:34,320
point of view you just have to act on

663
00:23:34,320 --> 00:23:37,039
this signal that is the w valid signal

664
00:23:37,039 --> 00:23:39,600
that it says whenever there is a data a

665
00:23:39,600 --> 00:23:42,080
data word available to the to the common

666
00:23:42,080 --> 00:23:43,760
bus basically

667
00:23:43,760 --> 00:23:46,240
and you can directly acting on of that

668
00:23:46,240 --> 00:23:47,919
on that line on the w terminal

669
00:23:47,919 --> 00:23:50,320
eventually if you're able for instance

670
00:23:50,320 --> 00:23:53,039
to write something on the fpga

671
00:23:53,039 --> 00:23:55,440
or you can also delay the right data

672
00:23:55,440 --> 00:23:57,679
production inside of a model if you want

673
00:23:57,679 --> 00:23:59,919
and you can be creative on that after

674
00:23:59,919 --> 00:24:02,080
having issued the request

675
00:24:02,080 --> 00:24:03,919
but there are also some interesting

676
00:24:03,919 --> 00:24:06,400
behavior we've seen that um

677
00:24:06,400 --> 00:24:08,480
create dependencies with read the

678
00:24:08,480 --> 00:24:11,039
operations for instance in dmas so when

679
00:24:11,039 --> 00:24:12,880
you have to move data from one source

680
00:24:12,880 --> 00:24:14,320
buffer to a destination buffer i'm going

681
00:24:14,320 --> 00:24:17,200
to show you later two examples

682
00:24:17,200 --> 00:24:19,120
actually now

683
00:24:19,120 --> 00:24:20,320
so

684
00:24:20,320 --> 00:24:22,000
here i would like to show you how this

685
00:24:22,000 --> 00:24:24,240
phenomenal is common

686
00:24:24,240 --> 00:24:25,919
and

687
00:24:25,919 --> 00:24:27,200
we take

688
00:24:27,200 --> 00:24:29,520
this first hardware module that is the

689
00:24:29,520 --> 00:24:31,520
exciting steep learning

690
00:24:31,520 --> 00:24:34,080
processing unit dpu that is the most

691
00:24:34,080 --> 00:24:35,919
recent dnr order accelerator proposed by

692
00:24:35,919 --> 00:24:37,039
excelling is something that we really

693
00:24:37,039 --> 00:24:38,960
like and we like to play with

694
00:24:38,960 --> 00:24:40,799
so it's part of the exciting vtci

695
00:24:40,799 --> 00:24:42,080
framework and

696
00:24:42,080 --> 00:24:44,880
this is the actual

697
00:24:44,880 --> 00:24:46,559
design of the guy

698
00:24:46,559 --> 00:24:49,600
we customize we get actually the

699
00:24:49,600 --> 00:24:52,240
stock hardware from the btc ai and we

700
00:24:52,240 --> 00:24:54,720
customize it to add some profilers and

701
00:24:54,720 --> 00:24:56,960
to add some integrated logic analyzer to

702
00:24:56,960 --> 00:24:59,200
see what this guy was was doing

703
00:24:59,200 --> 00:25:01,360
and this is a track for a minute actual

704
00:25:01,360 --> 00:25:03,919
execution of the model executing a plate

705
00:25:03,919 --> 00:25:05,520
number detection if i remember correctly

706
00:25:05,520 --> 00:25:07,520
as the network

707
00:25:07,520 --> 00:25:09,039
so basically what you see here is that

708
00:25:09,039 --> 00:25:12,159
the model is asking for a write request

709
00:25:12,159 --> 00:25:15,200
it delays this is for 108

710
00:25:15,200 --> 00:25:17,200
words of data so it means that i want to

711
00:25:17,200 --> 00:25:19,600
provide 108 words of data

712
00:25:19,600 --> 00:25:21,760
for 300 cycles more than 300 cycle is

713
00:25:21,760 --> 00:25:24,000
not providing anything

714
00:25:24,000 --> 00:25:25,840
this guy here already booked the bus if

715
00:25:25,840 --> 00:25:27,600
he's going to share the architecture as

716
00:25:27,600 --> 00:25:29,840
i saw you before then it provides 12

717
00:25:29,840 --> 00:25:31,360
words of data

718
00:25:31,360 --> 00:25:33,200
and then it's stall again

719
00:25:33,200 --> 00:25:37,039
so at this point this is like 540 like

720
00:25:37,039 --> 00:25:39,200
in 600 cycle it did not complete the

721
00:25:39,200 --> 00:25:40,400
transaction yet it should have been

722
00:25:40,400 --> 00:25:43,279
completed in 108 words in the best case

723
00:25:43,279 --> 00:25:45,120
scenario let's say right but in this

724
00:25:45,120 --> 00:25:46,960
case here you block the access to the

725
00:25:46,960 --> 00:25:48,720
others to the memory to write to the

726
00:25:48,720 --> 00:25:50,799
memory

727
00:25:50,799 --> 00:25:52,720
another example is

728
00:25:52,720 --> 00:25:54,080
on the

729
00:25:54,080 --> 00:25:55,919
direct memory access that is from

730
00:25:55,919 --> 00:25:57,279
silence

731
00:25:57,279 --> 00:25:58,720
the cdma

732
00:25:58,720 --> 00:26:00,159
and here there is an interesting

733
00:26:00,159 --> 00:26:02,559
behavior that we have seen we did the

734
00:26:02,559 --> 00:26:04,080
same design actually but a similar

735
00:26:04,080 --> 00:26:05,840
design to with probes

736
00:26:05,840 --> 00:26:07,440
what we see here is that whenever you

737
00:26:07,440 --> 00:26:09,120
set up a search buffer in a destination

738
00:26:09,120 --> 00:26:12,400
buffer and you trigger the execution

739
00:26:12,400 --> 00:26:14,640
the read and write are issued at the

740
00:26:14,640 --> 00:26:16,880
same time in the same clock cycle what

741
00:26:16,880 --> 00:26:18,640
does it mean it means that here you're

742
00:26:18,640 --> 00:26:20,480
booking the right bus

743
00:26:20,480 --> 00:26:22,960
even though you didn't receive the read

744
00:26:22,960 --> 00:26:26,000
data yet so if you are able to affect

745
00:26:26,000 --> 00:26:26,960
the

746
00:26:26,960 --> 00:26:29,200
provisioning of the read data if you're

747
00:26:29,200 --> 00:26:31,600
able to inject here an address that goes

748
00:26:31,600 --> 00:26:33,520
somewhere that is a peripheral that is

749
00:26:33,520 --> 00:26:35,760
misconfigured or something like this

750
00:26:35,760 --> 00:26:38,640
you are affecting also the access to all

751
00:26:38,640 --> 00:26:40,159
the right bus from all the other guys in

752
00:26:40,159 --> 00:26:42,000
the system

753
00:26:42,000 --> 00:26:43,840
okay i'm not going to stress that

754
00:26:43,840 --> 00:26:46,400
that much on that the impact

755
00:26:46,400 --> 00:26:48,240
it's on security of course because here

756
00:26:48,240 --> 00:26:49,919
we are able to endanger the availability

757
00:26:49,919 --> 00:26:51,679
of the peripherals

758
00:26:51,679 --> 00:26:53,679
also in safety because we create

759
00:26:53,679 --> 00:26:55,679
circular dependencies again

760
00:26:55,679 --> 00:26:57,679
in models and we break the isolation

761
00:26:57,679 --> 00:26:59,279
that is something that we don't want but

762
00:26:59,279 --> 00:27:00,799
it creates also problems on the average

763
00:27:00,799 --> 00:27:03,360
performance

764
00:27:03,360 --> 00:27:05,360
we were not happy with that so we did a

765
00:27:05,360 --> 00:27:07,679
realistic test on a mixed critical

766
00:27:07,679 --> 00:27:10,640
scenario that we is inspired by a common

767
00:27:10,640 --> 00:27:12,240
function some common functionalities

768
00:27:12,240 --> 00:27:14,080
that are required in a modern autonomous

769
00:27:14,080 --> 00:27:16,880
vehicle so in this case we split the

770
00:27:16,880 --> 00:27:19,440
computation on two different levels high

771
00:27:19,440 --> 00:27:21,440
critical domain and low critical domain

772
00:27:21,440 --> 00:27:23,360
in the eye critical domain we got deep

773
00:27:23,360 --> 00:27:24,960
learning accelerator in this case the

774
00:27:24,960 --> 00:27:27,279
schedule and still from science and a

775
00:27:27,279 --> 00:27:30,159
critical sensor actually or actuator

776
00:27:30,159 --> 00:27:31,840
in the low critical domain we just got a

777
00:27:31,840 --> 00:27:34,159
generic data mover that is just

778
00:27:34,159 --> 00:27:35,840
generating

779
00:27:35,840 --> 00:27:39,679
traffic and eventually injecting faults

780
00:27:39,679 --> 00:27:40,399
so

781
00:27:40,399 --> 00:27:42,399
this is the hidden anode accelerator we

782
00:27:42,399 --> 00:27:44,480
modified it we take the standard

783
00:27:44,480 --> 00:27:47,360
hardware and we modify it to

784
00:27:47,360 --> 00:27:48,399
inject

785
00:27:48,399 --> 00:27:50,960
a critical accelerator and a malicious

786
00:27:50,960 --> 00:27:53,440
misbehaving model

787
00:27:53,440 --> 00:27:56,559
so what we did is using the stock

788
00:27:56,559 --> 00:27:59,279
metal linux image from

789
00:27:59,279 --> 00:28:01,440
from science for the child dnn

790
00:28:01,440 --> 00:28:04,399
and we put the fpga our uh our setup

791
00:28:04,399 --> 00:28:07,039
and we would like as a requirements that

792
00:28:07,039 --> 00:28:09,039
the child union itself can execute with

793
00:28:09,039 --> 00:28:11,440
a minimum fps so in a

794
00:28:11,440 --> 00:28:14,320
in a safety in a safe way let's say well

795
00:28:14,320 --> 00:28:16,559
the critical model we put some hard

796
00:28:16,559 --> 00:28:18,159
real-time constraints so we put a

797
00:28:18,159 --> 00:28:19,919
deadline for them and this is the

798
00:28:19,919 --> 00:28:22,399
execution whenever the the performance

799
00:28:22,399 --> 00:28:23,919
of the execution whenever the

800
00:28:23,919 --> 00:28:26,080
misbehavior guy does not introduce any

801
00:28:26,080 --> 00:28:27,840
fault in the system

802
00:28:27,840 --> 00:28:30,799
however whenever we trigger any movement

803
00:28:30,799 --> 00:28:31,840
from

804
00:28:31,840 --> 00:28:34,320
the the guy that got a fault

805
00:28:34,320 --> 00:28:36,720
we could access anymore the bus itself

806
00:28:36,720 --> 00:28:38,720
from all of the system and what we got

807
00:28:38,720 --> 00:28:41,120
is that the response times of

808
00:28:41,120 --> 00:28:44,159
the critical hardware model is unbounded

809
00:28:44,159 --> 00:28:45,120
and

810
00:28:45,120 --> 00:28:47,760
the accelerator for dnn cannot compute

811
00:28:47,760 --> 00:28:50,559
any frame

812
00:28:51,120 --> 00:28:53,039
okay that's just a summary

813
00:28:53,039 --> 00:28:55,200
we already already said that

814
00:28:55,200 --> 00:28:57,120
so what i learned from that is that

815
00:28:57,120 --> 00:28:58,640
leaving the controllers the freedom of

816
00:28:58,640 --> 00:29:00,559
delaying their data provisioning can

817
00:29:00,559 --> 00:29:02,480
affect the availability of the resources

818
00:29:02,480 --> 00:29:04,159
and it can be exploited actually and we

819
00:29:04,159 --> 00:29:05,840
have seen how

820
00:29:05,840 --> 00:29:08,320
we propose multiple solutions on that

821
00:29:08,320 --> 00:29:10,080
and i'm gonna be fast on that because we

822
00:29:10,080 --> 00:29:11,279
don't have time

823
00:29:11,279 --> 00:29:12,880
so basically

824
00:29:12,880 --> 00:29:14,720
the first problem is unfair bandwidth

825
00:29:14,720 --> 00:29:16,880
distribution so here the source of the

826
00:29:16,880 --> 00:29:18,559
issue is that the data structure of

827
00:29:18,559 --> 00:29:20,240
transaction is left to be decided by

828
00:29:20,240 --> 00:29:21,440
controllers so you don't have any

829
00:29:21,440 --> 00:29:22,640
control on that

830
00:29:22,640 --> 00:29:24,320
and this can even change the dynamically

831
00:29:24,320 --> 00:29:26,480
execution so we need something to

832
00:29:26,480 --> 00:29:27,600
equalize the structure of the

833
00:29:27,600 --> 00:29:28,880
transaction that goes to the

834
00:29:28,880 --> 00:29:30,080
interconnect

835
00:29:30,080 --> 00:29:32,000
unfortunately we cannot just take a

836
00:29:32,000 --> 00:29:34,080
constant for the burst length signal but

837
00:29:34,080 --> 00:29:36,000
we need something more complex

838
00:29:36,000 --> 00:29:38,080
so what we propose is the axia iburst

839
00:29:38,080 --> 00:29:39,440
equalizer which is a very essential

840
00:29:39,440 --> 00:29:41,039
model that use a concept that is very

841
00:29:41,039 --> 00:29:42,799
common actually splitting merging

842
00:29:42,799 --> 00:29:44,159
actually

843
00:29:44,159 --> 00:29:47,200
and this guy is is put between the

844
00:29:47,200 --> 00:29:49,760
controller and the interconnect and you

845
00:29:49,760 --> 00:29:51,840
can configure it with a nominal size and

846
00:29:51,840 --> 00:29:54,320
we got also a response time analysis for

847
00:29:54,320 --> 00:29:56,399
real-time systems in that if you want to

848
00:29:56,399 --> 00:29:58,320
decide how to configure it it makes

849
00:29:58,320 --> 00:30:00,399
transactions homogeneous

850
00:30:00,399 --> 00:30:01,760
and they keep the transparency in the

851
00:30:01,760 --> 00:30:03,679
compliancy with the access standard from

852
00:30:03,679 --> 00:30:06,159
one side to the others so

853
00:30:06,159 --> 00:30:07,520
anything for

854
00:30:07,520 --> 00:30:09,120
per manager granularity of data that's

855
00:30:09,120 --> 00:30:11,679
the most important thing so what is all

856
00:30:11,679 --> 00:30:13,520
of the transactions the rich the

857
00:30:13,520 --> 00:30:15,840
interconnect are homogeneous in this

858
00:30:15,840 --> 00:30:17,279
case so there are there is no

859
00:30:17,279 --> 00:30:19,279
heterogeneity anymore in transactions

860
00:30:19,279 --> 00:30:21,600
and so what you when you reach back when

861
00:30:21,600 --> 00:30:24,240
you when you get back the data also the

862
00:30:24,240 --> 00:30:26,880
round-robin cycle on data is

863
00:30:26,880 --> 00:30:29,279
equivalent for um

864
00:30:29,279 --> 00:30:31,279
it's fair for also for the data beside

865
00:30:31,279 --> 00:30:32,799
the transaction

866
00:30:32,799 --> 00:30:34,480
these are just experiments i'm going

867
00:30:34,480 --> 00:30:36,240
fast on that basically what we've saw is

868
00:30:36,240 --> 00:30:39,120
that with our solution we've been able

869
00:30:39,120 --> 00:30:41,279
to keep the bandwidth

870
00:30:41,279 --> 00:30:43,840
uh fair and predictable

871
00:30:43,840 --> 00:30:47,760
and keep us a safe access to the bus

872
00:30:47,760 --> 00:30:49,600
independently on how the other models

873
00:30:49,600 --> 00:30:51,600
behave on the bus

874
00:30:51,600 --> 00:30:53,440
preventing the denial of service on the

875
00:30:53,440 --> 00:30:54,960
bus so in this case the source of the

876
00:30:54,960 --> 00:30:57,120
issues are that controllers are trusted

877
00:30:57,120 --> 00:30:59,120
to complete eventually rapidly the

878
00:30:59,120 --> 00:31:00,320
transaction

879
00:31:00,320 --> 00:31:02,080
so our solution should be able to

880
00:31:02,080 --> 00:31:04,399
recognize when a stall endangering the

881
00:31:04,399 --> 00:31:06,399
system in this key in our case we call

882
00:31:06,399 --> 00:31:07,919
it system schedulability orientated

883
00:31:07,919 --> 00:31:08,960
systems

884
00:31:08,960 --> 00:31:10,960
and restore a safe condition of the bus

885
00:31:10,960 --> 00:31:13,279
so guarantee re-guarantee the access to

886
00:31:13,279 --> 00:31:15,039
the other hardware accelerators other

887
00:31:15,039 --> 00:31:16,720
models in general

888
00:31:16,720 --> 00:31:18,559
so how do we know when a stall is

889
00:31:18,559 --> 00:31:20,559
dangerous because we saw that many

890
00:31:20,559 --> 00:31:22,240
models introduced all in the system so

891
00:31:22,240 --> 00:31:23,760
we don't we want to leave some

892
00:31:23,760 --> 00:31:25,519
flexibility

893
00:31:25,519 --> 00:31:26,799
so

894
00:31:26,799 --> 00:31:29,039
we defined the model on that

895
00:31:29,039 --> 00:31:30,799
i was in a real-time system lab so we

896
00:31:30,799 --> 00:31:33,760
like models and word case analysis so we

897
00:31:33,760 --> 00:31:35,760
define the model for hardware models

898
00:31:35,760 --> 00:31:38,320
interconnect and peripherals and we

899
00:31:38,320 --> 00:31:40,399
propose always has analysis that is able

900
00:31:40,399 --> 00:31:42,000
to understand

901
00:31:42,000 --> 00:31:44,399
how much time you can install the bus

902
00:31:44,399 --> 00:31:46,480
before you create a condition of

903
00:31:46,480 --> 00:31:47,840
threatening for the system that is

904
00:31:47,840 --> 00:31:50,480
correlated to this lack of the models

905
00:31:50,480 --> 00:31:51,919
we have for mathematical analysis in the

906
00:31:51,919 --> 00:31:53,519
paper i'm not going into details of that

907
00:31:53,519 --> 00:31:54,720
please ask me later if you are

908
00:31:54,720 --> 00:31:56,480
interested

909
00:31:56,480 --> 00:31:57,679
and then

910
00:31:57,679 --> 00:31:59,200
however we need something to take back

911
00:31:59,200 --> 00:32:00,320
the control of the bus because when you

912
00:32:00,320 --> 00:32:03,120
inject a fault you can't actually access

913
00:32:03,120 --> 00:32:04,240
the bus if you don't complete the

914
00:32:04,240 --> 00:32:05,360
transaction you cannot afford the

915
00:32:05,360 --> 00:32:06,799
transaction

916
00:32:06,799 --> 00:32:08,480
so we define

917
00:32:08,480 --> 00:32:10,880
the accessor monitor which is a very

918
00:32:10,880 --> 00:32:13,120
simple

919
00:32:13,120 --> 00:32:15,120
module that you you put between the

920
00:32:15,120 --> 00:32:17,360
hardware module and the interconnect and

921
00:32:17,360 --> 00:32:19,519
this guy is configured with this tool

922
00:32:19,519 --> 00:32:20,799
that you find using the worst case

923
00:32:20,799 --> 00:32:22,320
analysis

924
00:32:22,320 --> 00:32:24,720
and it takes back the control of the bus

925
00:32:24,720 --> 00:32:27,120
whenever

926
00:32:27,120 --> 00:32:29,120
it finds that

927
00:32:29,120 --> 00:32:30,960
a stall isn't dangerous this could the

928
00:32:30,960 --> 00:32:33,360
schedulability of the system and after

929
00:32:33,360 --> 00:32:34,720
taking better control it leaves the

930
00:32:34,720 --> 00:32:36,960
control again to the other harder model

931
00:32:36,960 --> 00:32:38,720
in the system

932
00:32:38,720 --> 00:32:40,720
this is just how it works but

933
00:32:40,720 --> 00:32:43,279
i don't go into details now

934
00:32:43,279 --> 00:32:44,559
this solution unfortunately has

935
00:32:44,559 --> 00:32:45,840
limitations

936
00:32:45,840 --> 00:32:47,600
uh it's a solution that is great for

937
00:32:47,600 --> 00:32:50,559
real-time systems um but you need to

938
00:32:50,559 --> 00:32:52,559
know the password generated is something

939
00:32:52,559 --> 00:32:54,559
that you can do real-time systems but

940
00:32:54,559 --> 00:32:56,640
not in mixed critical for instance the

941
00:32:56,640 --> 00:32:59,440
system that we've seen before

942
00:32:59,440 --> 00:33:02,080
with the hidden accelerator and

943
00:33:02,080 --> 00:33:03,840
the critical accelerator which is a

944
00:33:03,840 --> 00:33:06,000
mixed critical application so we develop

945
00:33:06,000 --> 00:33:08,000
a more versatile and elegant solution

946
00:33:08,000 --> 00:33:10,480
that is based on smart buffering

947
00:33:10,480 --> 00:33:12,640
basically we got a paper currently under

948
00:33:12,640 --> 00:33:14,480
preview on that stay tuned check it out

949
00:33:14,480 --> 00:33:18,159
because i think it's very nice

950
00:33:18,399 --> 00:33:21,039
okay besides the two problems that i saw

951
00:33:21,039 --> 00:33:22,799
that i was introducing before also

952
00:33:22,799 --> 00:33:24,080
another thing that we were focusing a

953
00:33:24,080 --> 00:33:26,080
lot is on the criticality of the access

954
00:33:26,080 --> 00:33:28,559
control system because

955
00:33:28,559 --> 00:33:31,760
the access control system defines uh

956
00:33:31,760 --> 00:33:34,080
critical functionalities that gives you

957
00:33:34,080 --> 00:33:36,080
the access to the peripherals it defines

958
00:33:36,080 --> 00:33:37,600
which controllers can access which

959
00:33:37,600 --> 00:33:39,600
peripheral unfortunately there are

960
00:33:39,600 --> 00:33:40,880
challenges here because the access

961
00:33:40,880 --> 00:33:42,559
control system deployed in commercial

962
00:33:42,559 --> 00:33:43,600
platforms

963
00:33:43,600 --> 00:33:46,320
are quite limited we've seen

964
00:33:46,320 --> 00:33:48,320
and we would like to give minimum access

965
00:33:48,320 --> 00:33:50,000
to the controllers

966
00:33:50,000 --> 00:33:52,240
basically from to the peripherals but we

967
00:33:52,240 --> 00:33:54,720
couldn't do anything fancy

968
00:33:54,720 --> 00:33:56,080
and those success control systems are

969
00:33:56,080 --> 00:33:57,519
certainly known to be common source of

970
00:33:57,519 --> 00:34:00,720
weaknesses and this is the top 12 cwes

971
00:34:00,720 --> 00:34:03,919
for 2021 from mitre consortium the

972
00:34:03,919 --> 00:34:06,320
common weakness enumeration from for

973
00:34:06,320 --> 00:34:09,760
hardware and basically out of 12 5 are

974
00:34:09,760 --> 00:34:12,480
related to access control system

975
00:34:12,480 --> 00:34:14,560
so what we did is proposing a framework

976
00:34:14,560 --> 00:34:17,679
it's called acre acre

977
00:34:17,679 --> 00:34:20,239
in the egyptian methodology is the god

978
00:34:20,239 --> 00:34:22,800
of the underworld that basically uh

979
00:34:22,800 --> 00:34:24,639
check who is going in and out inside of

980
00:34:24,639 --> 00:34:26,159
the underworld basically

981
00:34:26,159 --> 00:34:28,399
so for building safe and secure access

982
00:34:28,399 --> 00:34:30,320
control system and we build this on two

983
00:34:30,320 --> 00:34:32,239
pillars we provide a model as we did

984
00:34:32,239 --> 00:34:34,480
before for access control system

985
00:34:34,480 --> 00:34:36,560
but also what we did is providing

986
00:34:36,560 --> 00:34:38,399
security verification a strong security

987
00:34:38,399 --> 00:34:41,119
verification that is something that

988
00:34:41,119 --> 00:34:43,760
we really focused on and we think that

989
00:34:43,760 --> 00:34:45,760
is a great way to provide security

990
00:34:45,760 --> 00:34:46,839
inside of a

991
00:34:46,839 --> 00:34:49,280
system concluding

992
00:34:49,280 --> 00:34:50,079
well

993
00:34:50,079 --> 00:34:52,480
what i would do if i had to integrate a

994
00:34:52,480 --> 00:34:54,239
system

995
00:34:54,239 --> 00:34:57,520
using third-party models or using

996
00:34:57,520 --> 00:34:58,960
complex models

997
00:34:58,960 --> 00:35:00,640
well first of all the first thing i

998
00:35:00,640 --> 00:35:03,280
would like to do is perform an extensive

999
00:35:03,280 --> 00:35:05,440
security and safety verification of the

1000
00:35:05,440 --> 00:35:07,760
bus interactions many times the security

1001
00:35:07,760 --> 00:35:11,040
verification is just focused on some

1002
00:35:11,040 --> 00:35:13,599
security very security related problems

1003
00:35:13,599 --> 00:35:15,599
like i don't want that a key goes

1004
00:35:15,599 --> 00:35:17,680
outside from my model or something like

1005
00:35:17,680 --> 00:35:19,440
this but also the bus interaction we've

1006
00:35:19,440 --> 00:35:21,680
shown here that are important whenever

1007
00:35:21,680 --> 00:35:23,280
you integrate a system at the system

1008
00:35:23,280 --> 00:35:24,240
level

1009
00:35:24,240 --> 00:35:26,640
and we propose a paper also on that it's

1010
00:35:26,640 --> 00:35:28,240
going to be presented at duck in a

1011
00:35:28,240 --> 00:35:30,160
couple of weeks at the workshop at dac

1012
00:35:30,160 --> 00:35:31,520
so check it out if you're interested in

1013
00:35:31,520 --> 00:35:33,599
this in this thing

1014
00:35:33,599 --> 00:35:36,400
and we use it for two logic tools uh

1015
00:35:36,400 --> 00:35:38,960
that implements this innovative in

1016
00:35:38,960 --> 00:35:41,599
information flow tracking to verify

1017
00:35:41,599 --> 00:35:43,280
the the bus interaction i would like to

1018
00:35:43,280 --> 00:35:44,800
thank them because they gave us very

1019
00:35:44,800 --> 00:35:47,119
great support on that

1020
00:35:47,119 --> 00:35:50,000
beside the verification um we provided

1021
00:35:50,000 --> 00:35:52,000
some solutions so maybe you don't trust

1022
00:35:52,000 --> 00:35:53,280
your verification maybe you don't trust

1023
00:35:53,280 --> 00:35:54,720
your models maybe you would like to have

1024
00:35:54,720 --> 00:35:55,599
a

1025
00:35:55,599 --> 00:35:58,560
another level of security or safety with

1026
00:35:58,560 --> 00:36:01,359
respect to just verification so what we

1027
00:36:01,359 --> 00:36:04,560
did is proposing that but these guys

1028
00:36:04,560 --> 00:36:05,599
here you have to integrate them in the

1029
00:36:05,599 --> 00:36:07,520
system you can it can be a pain right

1030
00:36:07,520 --> 00:36:09,599
integrating all of them so

1031
00:36:09,599 --> 00:36:12,000
we defined our own interconnect i

1032
00:36:12,000 --> 00:36:13,680
actually coded the mayan intercontinent

1033
00:36:13,680 --> 00:36:16,079
that we call the axia hyperconnect

1034
00:36:16,079 --> 00:36:18,079
that basically integrates all of the

1035
00:36:18,079 --> 00:36:20,079
solution that i proposed you before

1036
00:36:20,079 --> 00:36:21,839
and the acceler connect itself is a

1037
00:36:21,839 --> 00:36:23,520
research interconnect that is still

1038
00:36:23,520 --> 00:36:25,760
under development we still work on that

1039
00:36:25,760 --> 00:36:27,520
and it's able to enforce secure and safe

1040
00:36:27,520 --> 00:36:29,760
bus interaction and also predictable

1041
00:36:29,760 --> 00:36:31,680
from the point of view of the timing you

1042
00:36:31,680 --> 00:36:33,359
can use it standalone or you can

1043
00:36:33,359 --> 00:36:35,520
integrate what is more interesting with

1044
00:36:35,520 --> 00:36:37,200
an os an operating system or an

1045
00:36:37,200 --> 00:36:38,640
hypervisor that's what we did we

1046
00:36:38,640 --> 00:36:40,000
integrated with claire which is an

1047
00:36:40,000 --> 00:36:41,200
hypervisor

1048
00:36:41,200 --> 00:36:42,960
for

1049
00:36:42,960 --> 00:36:44,880
cyber physical systems uh for the

1050
00:36:44,880 --> 00:36:46,640
platform also that we are

1051
00:36:46,640 --> 00:36:48,160
we are considering

1052
00:36:48,160 --> 00:36:49,440
and basically in this case when you

1053
00:36:49,440 --> 00:36:51,200
integrate with an hypervisor the hyper

1054
00:36:51,200 --> 00:36:52,880
connect itself is just

1055
00:36:52,880 --> 00:36:54,720
an extension of the hypervisor for the

1056
00:36:54,720 --> 00:36:57,200
modules for the controllers and it

1057
00:36:57,200 --> 00:36:59,280
provides functionalities to manage the

1058
00:36:59,280 --> 00:37:01,119
controllers

1059
00:37:01,119 --> 00:37:02,960
these are just the features on the

1060
00:37:02,960 --> 00:37:05,359
hyperconnect and

1061
00:37:05,359 --> 00:37:06,560
at the end

1062
00:37:06,560 --> 00:37:08,800
the same scenario i'll show you before

1063
00:37:08,800 --> 00:37:11,040
and the mixing critical scenario we

1064
00:37:11,040 --> 00:37:13,520
integrate everything as before with the

1065
00:37:13,520 --> 00:37:16,079
guy that introduced also the faults

1066
00:37:16,079 --> 00:37:19,119
but we put the hyperconnect in here to

1067
00:37:19,119 --> 00:37:20,880
connect in place of the standard

1068
00:37:20,880 --> 00:37:23,280
interconnect to connect to the memory

1069
00:37:23,280 --> 00:37:25,359
and we pass from something like this so

1070
00:37:25,359 --> 00:37:27,839
where the whenever there were false

1071
00:37:27,839 --> 00:37:29,040
injected

1072
00:37:29,040 --> 00:37:31,040
the execution were broken

1073
00:37:31,040 --> 00:37:32,079
to

1074
00:37:32,079 --> 00:37:34,880
keeping the system operational

1075
00:37:34,880 --> 00:37:36,960
and we got a slight impact on the

1076
00:37:36,960 --> 00:37:39,119
performance that is

1077
00:37:39,119 --> 00:37:41,599
because of the solution that solves

1078
00:37:41,599 --> 00:37:43,119
the stalls

1079
00:37:43,119 --> 00:37:45,599
but still we can keep the the system

1080
00:37:45,599 --> 00:37:48,960
operational uh even whenever there are

1081
00:37:48,960 --> 00:37:52,400
fault injected in the past success

1082
00:37:52,400 --> 00:37:53,680
this is just

1083
00:37:53,680 --> 00:37:55,680
to

1084
00:37:55,680 --> 00:37:57,200
give an appreciation to all of the

1085
00:37:57,200 --> 00:37:59,599
people that collaborated with me at uc

1086
00:37:59,599 --> 00:38:01,520
san diego tortuga logic

1087
00:38:01,520 --> 00:38:03,359
the ma the written slab and accelera

1088
00:38:03,359 --> 00:38:05,440
these are i've got the great privilege

1089
00:38:05,440 --> 00:38:06,880
of collaborating with all of them and i

1090
00:38:06,880 --> 00:38:09,040
would like to thank all of them plus all

1091
00:38:09,040 --> 00:38:10,320
of the industrial collaborators that

1092
00:38:10,320 --> 00:38:11,440
gave us

1093
00:38:11,440 --> 00:38:13,440
great feedbacks on all of our projects

1094
00:38:13,440 --> 00:38:16,560
intel tortuga and lydos

1095
00:38:16,560 --> 00:38:18,240
i conclude with my contacts and

1096
00:38:18,240 --> 00:38:19,839
references for

1097
00:38:19,839 --> 00:38:22,640
the papers that we publish on the all of

1098
00:38:22,640 --> 00:38:24,400
these all of this work is published so

1099
00:38:24,400 --> 00:38:26,240
you can you can check it out here there

1100
00:38:26,240 --> 00:38:28,480
are all of the references if you are

1101
00:38:28,480 --> 00:38:30,880
interested in any of these please let me

1102
00:38:30,880 --> 00:38:32,640
know drop me a drop me an email connect

1103
00:38:32,640 --> 00:38:34,079
with me i'll link it in we can talk

1104
00:38:34,079 --> 00:38:36,640
about if you want to collaborate we're

1105
00:38:36,640 --> 00:38:38,560
very prone for collaboration i would

1106
00:38:38,560 --> 00:38:39,599
like to thank all of you and

1107
00:38:39,599 --> 00:38:41,440
organization for inviting me here for

1108
00:38:41,440 --> 00:38:43,280
this talk it has been a very very

1109
00:38:43,280 --> 00:38:45,359
exciting experience exciting experience

1110
00:38:45,359 --> 00:38:46,670
thank you all

1111
00:38:46,670 --> 00:38:53,559
[Applause]

1112
00:38:53,599 --> 00:38:56,400
have any questions

1113
00:38:56,480 --> 00:38:59,040
francis

1114
00:38:59,040 --> 00:39:01,839
anyone

1115
00:39:01,920 --> 00:39:04,400
we still have four minutes so yeah you

1116
00:39:04,400 --> 00:39:08,640
cannot think okay oh it was fast then

1117
00:39:08,720 --> 00:39:10,480
yep

1118
00:39:10,480 --> 00:39:12,560
yeah i i guess i just have two questions

1119
00:39:12,560 --> 00:39:15,920
actually so the first it wasn't clear um

1120
00:39:15,920 --> 00:39:17,920
if it's you're trying to manage to also

1121
00:39:17,920 --> 00:39:20,240
by creating another route dropping them

1122
00:39:20,240 --> 00:39:22,480
like how is this being handled how it's

1123
00:39:22,480 --> 00:39:24,079
been handled by the our solution you

1124
00:39:24,079 --> 00:39:26,160
mean yeah yeah so our solution basically

1125
00:39:26,160 --> 00:39:27,520
the standard says that whenever you

1126
00:39:27,520 --> 00:39:29,440
initiate a transaction you cannot abort

1127
00:39:29,440 --> 00:39:31,680
it right so basically you have to

1128
00:39:31,680 --> 00:39:33,760
complete the transaction so what we do

1129
00:39:33,760 --> 00:39:35,119
is like completing the transaction

1130
00:39:35,119 --> 00:39:36,880
keeping back the bus completed the

1131
00:39:36,880 --> 00:39:39,680
transaction with the fake data basically

1132
00:39:39,680 --> 00:39:41,680
just to keep back the bus

1133
00:39:41,680 --> 00:39:43,760
after completed we can get back the bus

1134
00:39:43,760 --> 00:39:45,680
to the other guys in the system okay

1135
00:39:45,680 --> 00:39:47,599
yeah that's a good workaround and i

1136
00:39:47,599 --> 00:39:49,040
guess the other part you talked a bit

1137
00:39:49,040 --> 00:39:51,599
about is this realistic okay yeah in a

1138
00:39:51,599 --> 00:39:53,440
lot of the hardware designs

1139
00:39:53,440 --> 00:39:56,960
uh you would expect

1140
00:39:56,960 --> 00:39:58,880
there wouldn't be cases where it's it's

1141
00:39:58,880 --> 00:40:00,880
going to request the bus and then wait

1142
00:40:00,880 --> 00:40:02,880
um under fault injection and other

1143
00:40:02,880 --> 00:40:05,359
attacks maybe that's going to happen

1144
00:40:05,359 --> 00:40:07,839
but if you assume no physical access

1145
00:40:07,839 --> 00:40:10,240
um

1146
00:40:10,240 --> 00:40:12,000
if something is maybe firm or software

1147
00:40:12,000 --> 00:40:14,079
driven and someone can so basically it's

1148
00:40:14,079 --> 00:40:17,119
uh it's an issue if you use fpga so if

1149
00:40:17,119 --> 00:40:19,520
pgas because fpgas are very easy to

1150
00:40:19,520 --> 00:40:23,599
reconfigure so you can put inside uh

1151
00:40:23,599 --> 00:40:25,920
custom accelerators or

1152
00:40:25,920 --> 00:40:27,200
change the functionality of the

1153
00:40:27,200 --> 00:40:29,839
accelerators even on the fly if you wish

1154
00:40:29,839 --> 00:40:32,480
so that's a big issue for fpga sources

1155
00:40:32,480 --> 00:40:35,040
also in socs itself

1156
00:40:35,040 --> 00:40:38,000
it depends it's not i mean on software

1157
00:40:38,000 --> 00:40:40,079
there are dependabilities that depend

1158
00:40:40,079 --> 00:40:41,599
for instance in the cdma you've seen

1159
00:40:41,599 --> 00:40:42,560
before

1160
00:40:42,560 --> 00:40:44,000
you got a method over there that if you

1161
00:40:44,000 --> 00:40:46,319
are able to access

1162
00:40:46,319 --> 00:40:49,119
set up a request from a source buffer

1163
00:40:49,119 --> 00:40:51,599
that is not going to respond you somehow

1164
00:40:51,599 --> 00:40:53,119
because there is a misconfigured

1165
00:40:53,119 --> 00:40:55,440
peripheral something like this and while

1166
00:40:55,440 --> 00:40:57,040
you ask for that read the you also

1167
00:40:57,040 --> 00:40:59,440
submit of right that is what the cdma is

1168
00:40:59,440 --> 00:41:00,400
doing

1169
00:41:00,400 --> 00:41:01,760
at that point you are never receiving

1170
00:41:01,760 --> 00:41:03,839
the read data so you are you are never

1171
00:41:03,839 --> 00:41:06,480
writing the data so you are actually

1172
00:41:06,480 --> 00:41:08,560
like you can do it also via software it

1173
00:41:08,560 --> 00:41:10,480
depends like on how the platform is

1174
00:41:10,480 --> 00:41:13,040
implemented but it's an open door for

1175
00:41:13,040 --> 00:41:15,440
injecting vulnerabilities yeah

1176
00:41:15,440 --> 00:41:16,880
yeah that makes sense actually when you

1177
00:41:16,880 --> 00:41:18,319
put it this way with a partial

1178
00:41:18,319 --> 00:41:20,400
reconfiguration of an fp oh so so yeah i

1179
00:41:20,400 --> 00:41:22,240
would assume then all bets are off but

1180
00:41:22,240 --> 00:41:24,319
it also depends what part is in fps i

1181
00:41:24,319 --> 00:41:26,079
mean it's just partial reconfiguration

1182
00:41:26,079 --> 00:41:28,000
it's uh dynamic also partial

1183
00:41:28,000 --> 00:41:29,760
configuration is just one of one of the

1184
00:41:29,760 --> 00:41:32,160
method that can happen but it can happen

1185
00:41:32,160 --> 00:41:33,920
also like with whenever you got model

1186
00:41:33,920 --> 00:41:34,640
that

1187
00:41:34,640 --> 00:41:36,560
does speculative by success i mean you

1188
00:41:36,560 --> 00:41:38,800
can configure them with software and

1189
00:41:38,800 --> 00:41:40,800
endanger the availability of the right

1190
00:41:40,800 --> 00:41:42,480
you don't expect that at least i did not

1191
00:41:42,480 --> 00:41:45,440
expect that before so yeah

1192
00:41:45,440 --> 00:41:47,359
thank you thank you

1193
00:41:47,359 --> 00:41:48,480
all right

1194
00:41:48,480 --> 00:41:51,040
any last questions oops okay thank you

1195
00:41:51,040 --> 00:41:53,570
francisco

1196
00:41:53,570 --> 00:41:56,979
[Applause]

