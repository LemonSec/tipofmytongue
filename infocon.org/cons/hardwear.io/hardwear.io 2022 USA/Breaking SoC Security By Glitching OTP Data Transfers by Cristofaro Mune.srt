1
00:00:03,120 --> 00:00:05,040
uh welcome everybody we are going to

2
00:00:05,040 --> 00:00:08,320
talk about uh how to break security

3
00:00:08,320 --> 00:00:10,559
features of an soc a system on ship

4
00:00:10,559 --> 00:00:12,240
which i would refer to as a sock from

5
00:00:12,240 --> 00:00:14,160
now on

6
00:00:14,160 --> 00:00:15,120
without

7
00:00:15,120 --> 00:00:17,199
having basically a vulnerability in the

8
00:00:17,199 --> 00:00:19,920
implementation like laura uh in the talk

9
00:00:19,920 --> 00:00:22,720
before presented a bit of introduction

10
00:00:22,720 --> 00:00:24,960
just to give an idea of the uh paul

11
00:00:24,960 --> 00:00:26,720
william well actually this talk these

12
00:00:26,720 --> 00:00:29,359
results have been done with my uh

13
00:00:29,359 --> 00:00:31,519
partner nick timmers and we are both

14
00:00:31,519 --> 00:00:33,280
co-founder and ceo researchers so we

15
00:00:33,280 --> 00:00:35,120
have quite some experience in the field

16
00:00:35,120 --> 00:00:35,920
now

17
00:00:35,920 --> 00:00:38,000
uh i would say that last 15 years of my

18
00:00:38,000 --> 00:00:40,399
life have been spent in tearing about

19
00:00:40,399 --> 00:00:42,559
devices breaking socks in different ways

20
00:00:42,559 --> 00:00:45,200
and say having fun along the way and so

21
00:00:45,200 --> 00:00:47,200
far so good i would say and if you want

22
00:00:47,200 --> 00:00:48,559
to know a bit more

23
00:00:48,559 --> 00:00:52,000
there is our uh blog on realize and we

24
00:00:52,000 --> 00:00:52,960
cover

25
00:00:52,960 --> 00:00:54,480
uh let's say whatever is in the in

26
00:00:54,480 --> 00:00:56,640
between hard and software we like to

27
00:00:56,640 --> 00:00:58,879
cover things which are

28
00:00:58,879 --> 00:01:01,039
about the finished devices or trust

29
00:01:01,039 --> 00:01:02,719
execution environments your boots so

30
00:01:02,719 --> 00:01:04,239
whatever is a low level software

31
00:01:04,239 --> 00:01:05,438
hardware is something that we are

32
00:01:05,438 --> 00:01:07,920
interested in general

33
00:01:07,920 --> 00:01:09,680
for soc security

34
00:01:09,680 --> 00:01:11,280
well the security feature of social

35
00:01:11,280 --> 00:01:13,439
become just increasingly relevant as we

36
00:01:13,439 --> 00:01:16,400
have seen even even in the previous talk

37
00:01:16,400 --> 00:01:19,439
they are becoming very common also on

38
00:01:19,439 --> 00:01:22,640
low cost system on chip nowadays and

39
00:01:22,640 --> 00:01:24,400
here there are a few example i mean

40
00:01:24,400 --> 00:01:26,320
there is the very well known uh chip

41
00:01:26,320 --> 00:01:28,080
from expressive which has fresh

42
00:01:28,080 --> 00:01:30,000
encryptions your boot signature

43
00:01:30,000 --> 00:01:32,960
verification then crypto engines and

44
00:01:32,960 --> 00:01:35,520
same goes also for microchip that we

45
00:01:35,520 --> 00:01:37,759
find other examples over here cetera

46
00:01:37,759 --> 00:01:41,360
processor and finally also the nxp one

47
00:01:41,360 --> 00:01:43,119
so all these

48
00:01:43,119 --> 00:01:45,920
processors all mcus are not

49
00:01:45,920 --> 00:01:48,720
overly expensive they are definitely

50
00:01:48,720 --> 00:01:51,840
accessible and that's why the oems in

51
00:01:51,840 --> 00:01:53,439
general are starting to consider the

52
00:01:53,439 --> 00:01:55,520
security feature as part of the use case

53
00:01:55,520 --> 00:01:57,439
for example for sensitive clinical

54
00:01:57,439 --> 00:02:00,000
device device based services iep

55
00:02:00,000 --> 00:02:01,840
protection in general

56
00:02:01,840 --> 00:02:03,600
these are just a few examples that come

57
00:02:03,600 --> 00:02:05,439
to mind but in general it's clear that

58
00:02:05,439 --> 00:02:07,280
the security of system and chip is

59
00:02:07,280 --> 00:02:09,280
becoming more and more important

60
00:02:09,280 --> 00:02:11,520
and same goes also for fault injection

61
00:02:11,520 --> 00:02:13,120
because the concept is becoming now

62
00:02:13,120 --> 00:02:15,440
familiar to security researcher this is

63
00:02:15,440 --> 00:02:17,680
more accessible tooling and you see here

64
00:02:17,680 --> 00:02:21,599
chip shower for and pico emp uh some fun

65
00:02:21,599 --> 00:02:23,680
tool decently to to have and to play

66
00:02:23,680 --> 00:02:25,520
with and there are advanced techniques

67
00:02:25,520 --> 00:02:27,599
which are presented at publix uni

68
00:02:27,599 --> 00:02:29,840
conferences uh higher vario and

69
00:02:29,840 --> 00:02:31,280
hopefully all through this talk we'll

70
00:02:31,280 --> 00:02:32,319
see

71
00:02:32,319 --> 00:02:34,480
what i think is missing in the field i

72
00:02:34,480 --> 00:02:36,080
think there is a bit of systematization

73
00:02:36,080 --> 00:02:37,760
on the field default injection which is

74
00:02:37,760 --> 00:02:40,640
actually missing and we mostly have

75
00:02:40,640 --> 00:02:42,720
research from security community from

76
00:02:42,720 --> 00:02:46,400
academia and from industry labs that are

77
00:02:46,400 --> 00:02:47,599
still

78
00:02:47,599 --> 00:02:49,200
saying going in parallel but not

79
00:02:49,200 --> 00:02:51,440
necessarily always merging and we at

80
00:02:51,440 --> 00:02:53,760
least we i and we had realized we try to

81
00:02:53,760 --> 00:02:55,519
make that

82
00:02:55,519 --> 00:02:57,920
happen as often as possible so the goal

83
00:02:57,920 --> 00:03:00,560
for our talk is that we want to show our

84
00:03:00,560 --> 00:03:02,319
subsidiary depends in general and otp

85
00:03:02,319 --> 00:03:05,440
data so basically we start from uh

86
00:03:05,440 --> 00:03:06,720
from from really the basic for

87
00:03:06,720 --> 00:03:09,360
understanding how it is how this works

88
00:03:09,360 --> 00:03:11,440
we want to present fault injection

89
00:03:11,440 --> 00:03:13,599
attacks in a more systematic way we

90
00:03:13,599 --> 00:03:16,879
actually target transfer of data from

91
00:03:16,879 --> 00:03:18,480
from otp

92
00:03:18,480 --> 00:03:20,800
i'd like to share our results which we

93
00:03:20,800 --> 00:03:24,000
achieved we're using emfi on esp32 i

94
00:03:24,000 --> 00:03:26,000
will see that in a moment and also

95
00:03:26,000 --> 00:03:28,159
discuss briefly possible countermeasure

96
00:03:28,159 --> 00:03:30,000
here but in general this stock is

97
00:03:30,000 --> 00:03:32,159
intended to contribute to the field we

98
00:03:32,159 --> 00:03:34,159
are not we are not here for necessarily

99
00:03:34,159 --> 00:03:37,360
for the uh well we broke a great ship

100
00:03:37,360 --> 00:03:40,159
but maybe uh we think with that this

101
00:03:40,159 --> 00:03:41,760
technique would be applicable from here

102
00:03:41,760 --> 00:03:44,239
to the next 10 years

103
00:03:44,239 --> 00:03:45,920
so to give you a bit of context here in

104
00:03:45,920 --> 00:03:48,560
2019 we presented your boot talk at blue

105
00:03:48,560 --> 00:03:51,920
blue at israel it was february 2019. we

106
00:03:51,920 --> 00:03:53,360
bypassed and clipped the euro bull on

107
00:03:53,360 --> 00:03:55,599
stage while we happen to love live demos

108
00:03:55,599 --> 00:03:58,159
in general so i mean we were really

109
00:03:58,159 --> 00:04:00,959
happy to do so but in the meantime uh

110
00:04:00,959 --> 00:04:02,400
along the lines we also described the

111
00:04:02,400 --> 00:04:03,920
fault injection attacks which were

112
00:04:03,920 --> 00:04:06,239
targeting ldp transfer it was just

113
00:04:06,239 --> 00:04:07,760
genetic it was

114
00:04:07,760 --> 00:04:09,760
mostly theoretical at the time well

115
00:04:09,760 --> 00:04:11,840
actually we knew it could work that's

116
00:04:11,840 --> 00:04:14,000
why we shared that part but we don't

117
00:04:14,000 --> 00:04:16,478
have a demo or a research ready for that

118
00:04:16,478 --> 00:04:18,399
it wasn't but the concept is not

119
00:04:18,399 --> 00:04:20,478
specific to an soc so whatever we are

120
00:04:20,478 --> 00:04:23,199
saying in the stock is not specific to

121
00:04:23,199 --> 00:04:25,919
this conceptually to this systemship we

122
00:04:25,919 --> 00:04:27,840
are going to present which is going to

123
00:04:27,840 --> 00:04:31,040
be the esp32 it's a very popular iot

124
00:04:31,040 --> 00:04:33,280
system on chip uh i mean

125
00:04:33,280 --> 00:04:34,960
when it came out i mean has been

126
00:04:34,960 --> 00:04:36,800
extremely popular in in several

127
00:04:36,800 --> 00:04:40,880
applications as an extensor electric cpu

128
00:04:40,880 --> 00:04:43,280
as internal external memory it's very

129
00:04:43,280 --> 00:04:46,240
rich feature yeah we feed rich socks in

130
00:04:46,240 --> 00:04:47,360
terms of

131
00:04:47,360 --> 00:04:49,919
support for wi-fi bluetooth and very

132
00:04:49,919 --> 00:04:52,720
rich api so it's really useful

133
00:04:52,720 --> 00:04:54,479
usable actually i would say

134
00:04:54,479 --> 00:04:56,720
so this is the module that you see and

135
00:04:56,720 --> 00:04:57,440
uh

136
00:04:57,440 --> 00:04:59,440
in in this

137
00:04:59,440 --> 00:05:01,360
module which costs around i would say

138
00:05:01,360 --> 00:05:03,759
between uh depending on seven and

139
00:05:03,759 --> 00:05:06,000
fifteen dollars you have secure boot

140
00:05:06,000 --> 00:05:08,880
flash encryption and uh support for

141
00:05:08,880 --> 00:05:11,840
disabling the jdec and even a few more

142
00:05:11,840 --> 00:05:13,280
security features but these are the ones

143
00:05:13,280 --> 00:05:14,800
that we are interested in and in

144
00:05:14,800 --> 00:05:18,479
extremely uh low uh price package so

145
00:05:18,479 --> 00:05:20,560
this is really available to i would say

146
00:05:20,560 --> 00:05:21,840
to everybody

147
00:05:21,840 --> 00:05:24,160
so this generated lots of interest also

148
00:05:24,160 --> 00:05:25,919
from a research point of view hey we

149
00:05:25,919 --> 00:05:27,759
have something nice it goes does not go

150
00:05:27,759 --> 00:05:29,360
so much so we can actually play and try

151
00:05:29,360 --> 00:05:30,560
to break

152
00:05:30,560 --> 00:05:32,639
uh we were not the only we're not alone

153
00:05:32,639 --> 00:05:34,400
of course in doing this actually limited

154
00:05:34,400 --> 00:05:36,320
results did a great research and

155
00:05:36,320 --> 00:05:38,240
performed multiple fault injection

156
00:05:38,240 --> 00:05:41,520
attacks towards this chip esp32 mostly

157
00:05:41,520 --> 00:05:44,240
based on vcc on voltage glitching

158
00:05:44,240 --> 00:05:48,240
we well they target uh the is cryptocore

159
00:05:48,240 --> 00:05:51,280
first mostly the driver so basically by

160
00:05:51,280 --> 00:05:53,840
um by glitching if i remember correctly

161
00:05:53,840 --> 00:05:56,560
they could set the key to zero or they

162
00:05:56,560 --> 00:05:58,479
would skip the encryption entirely but

163
00:05:58,479 --> 00:06:01,919
it was still targeting the uh the driver

164
00:06:01,919 --> 00:06:04,720
logic for driving the crypto engine

165
00:06:04,720 --> 00:06:06,800
there's been also a secure boot bypass

166
00:06:06,800 --> 00:06:08,800
still in terms of software being

167
00:06:08,800 --> 00:06:11,360
executed and there's been also a dump on

168
00:06:11,360 --> 00:06:14,479
otp protected keys uh basically the

169
00:06:14,479 --> 00:06:16,319
secure boot and flash encryption on this

170
00:06:16,319 --> 00:06:19,120
chip are based on secrets keys which are

171
00:06:19,120 --> 00:06:21,600
both symmetric and the secrecy of this

172
00:06:21,600 --> 00:06:23,520
key is confidentiality is extremely

173
00:06:23,520 --> 00:06:25,360
relevant in order for this security

174
00:06:25,360 --> 00:06:28,000
feature to actually make sense

175
00:06:28,000 --> 00:06:29,759
and this is actually this attack i'm not

176
00:06:29,759 --> 00:06:32,319
sure it was i think it was intended

177
00:06:32,319 --> 00:06:35,680
indeed targeted an otp data transfer and

178
00:06:35,680 --> 00:06:37,360
we are going to see that in a moment but

179
00:06:37,360 --> 00:06:40,080
basically i think it's the first uh

180
00:06:40,080 --> 00:06:42,479
public implementation of the attack that

181
00:06:42,479 --> 00:06:44,000
we were just describing a few months

182
00:06:44,000 --> 00:06:44,880
before

183
00:06:44,880 --> 00:06:47,199
uh not sure if there is any relationship

184
00:06:47,199 --> 00:06:48,639
always being done intentionally but it

185
00:06:48,639 --> 00:06:50,400
was nice to see that maybe the time were

186
00:06:50,400 --> 00:06:53,520
mature for this kind of attacks

187
00:06:53,520 --> 00:06:55,919
we actually did also some fi attacks the

188
00:06:55,919 --> 00:06:57,680
difference is that we performed all our

189
00:06:57,680 --> 00:06:59,759
attacks through emfi why because we

190
00:06:59,759 --> 00:07:01,199
don't have to solder we don't have to

191
00:07:01,199 --> 00:07:02,720
the gap we don't do anything we are

192
00:07:02,720 --> 00:07:05,520
really low with the mfi and that's why

193
00:07:05,520 --> 00:07:08,400
um we bypass your boot uh we do we do

194
00:07:08,400 --> 00:07:09,120
this

195
00:07:09,120 --> 00:07:11,039
usually with a different techniques we

196
00:07:11,039 --> 00:07:13,039
don't bypass the comp the

197
00:07:13,039 --> 00:07:14,240
demand

198
00:07:14,240 --> 00:07:16,880
compare or the signature verification we

199
00:07:16,880 --> 00:07:18,720
don't we don't care about that we

200
00:07:18,720 --> 00:07:22,880
usually take pc control via mmc py so in

201
00:07:22,880 --> 00:07:25,360
a nutshell we control the data and while

202
00:07:25,360 --> 00:07:27,520
this is being transferred we glitch and

203
00:07:27,520 --> 00:07:28,880
the data we are transferring goes to

204
00:07:28,880 --> 00:07:30,880
program counter so at that point we can

205
00:07:30,880 --> 00:07:32,240
go anywhere

206
00:07:32,240 --> 00:07:34,160
so basically we achieve a perfect pc

207
00:07:34,160 --> 00:07:36,080
control we via what is called the

208
00:07:36,080 --> 00:07:38,960
instruction modification it's a

209
00:07:38,960 --> 00:07:41,440
default model that has been well we i

210
00:07:41,440 --> 00:07:42,560
think

211
00:07:42,560 --> 00:07:45,080
mark i mean we presented that in

212
00:07:45,080 --> 00:07:48,240
2015 or 16 i think and it was the first

213
00:07:48,240 --> 00:07:49,840
time that we actually

214
00:07:49,840 --> 00:07:51,759
came out with such an idea and it works

215
00:07:51,759 --> 00:07:54,560
beautifully and is our fault model of

216
00:07:54,560 --> 00:07:56,720
preference nowadays

217
00:07:56,720 --> 00:07:58,400
with the same by using instruction

218
00:07:58,400 --> 00:08:00,800
modification we also bypassed the flash

219
00:08:00,800 --> 00:08:04,720
encryption and we do that also together

220
00:08:04,720 --> 00:08:07,759
uh with single boot basically we with pc

221
00:08:07,759 --> 00:08:10,879
control coupled with sram data

222
00:08:10,879 --> 00:08:13,280
persistence we were able to switch the

223
00:08:13,280 --> 00:08:15,440
chip to a different stage while still

224
00:08:15,440 --> 00:08:17,360
controlling program counter and this

225
00:08:17,360 --> 00:08:19,520
allows with a single glitch attack to

226
00:08:19,520 --> 00:08:21,120
bypass this reboot

227
00:08:21,120 --> 00:08:23,039
to bypass the flash encryption so accept

228
00:08:23,039 --> 00:08:25,199
access plaintext data without knowing

229
00:08:25,199 --> 00:08:27,199
the key that's the important part we

230
00:08:27,199 --> 00:08:28,400
don't need to dump the key with this

231
00:08:28,400 --> 00:08:29,759
kind of attack

232
00:08:29,759 --> 00:08:31,919
so if you need more these are links i

233
00:08:31,919 --> 00:08:34,719
mean it's an old research nowadays but

234
00:08:34,719 --> 00:08:36,958
the links are there please do that so

235
00:08:36,958 --> 00:08:39,039
let me go back to our

236
00:08:39,039 --> 00:08:40,640
guest of today which is the one-time

237
00:08:40,640 --> 00:08:42,320
program of memory or called so-called

238
00:08:42,320 --> 00:08:44,480
odp let's start from the basic from the

239
00:08:44,480 --> 00:08:46,560
memory cell and

240
00:08:46,560 --> 00:08:48,320
the basic idea is that you have memory

241
00:08:48,320 --> 00:08:50,240
where bits can be set only once and

242
00:08:50,240 --> 00:08:53,040
cannot revert to the previous state

243
00:08:53,040 --> 00:08:54,560
and this is achieved by physical

244
00:08:54,560 --> 00:08:56,640
modification of the cell for example

245
00:08:56,640 --> 00:08:59,200
what you see here is a programmable poly

246
00:08:59,200 --> 00:09:01,519
effuse so this is also called

247
00:09:01,519 --> 00:09:03,279
fuses these are called called the

248
00:09:03,279 --> 00:09:05,120
effuses memory

249
00:09:05,120 --> 00:09:07,680
there are several several

250
00:09:07,680 --> 00:09:09,920
names to this kind of memory otp and all

251
00:09:09,920 --> 00:09:11,440
these things but the basic concept is

252
00:09:11,440 --> 00:09:12,800
there is a cell

253
00:09:12,800 --> 00:09:16,320
that you physically modify in order to

254
00:09:16,320 --> 00:09:18,320
represent a bit but because it's been

255
00:09:18,320 --> 00:09:19,760
physically modified it cannot be

256
00:09:19,760 --> 00:09:21,600
reverted back

257
00:09:21,600 --> 00:09:23,600
so for example what you see is that here

258
00:09:23,600 --> 00:09:25,360
the path has been actually blown if

259
00:09:25,360 --> 00:09:27,600
that's where the name will actually blow

260
00:09:27,600 --> 00:09:30,080
a fuse

261
00:09:30,240 --> 00:09:32,640
in case of secure variance variance as

262
00:09:32,640 --> 00:09:34,560
far as we know there are no observable

263
00:09:34,560 --> 00:09:36,320
difference in programming so while this

264
00:09:36,320 --> 00:09:38,640
is visible optically or at least with a

265
00:09:38,640 --> 00:09:40,480
with a microscope

266
00:09:40,480 --> 00:09:42,000
generally at the same level of

267
00:09:42,000 --> 00:09:44,000
visibility here this is also programmed

268
00:09:44,000 --> 00:09:45,839
but you don't see actually a break this

269
00:09:45,839 --> 00:09:46,800
is called

270
00:09:46,800 --> 00:09:49,760
anti-fuse again if you need more i mean

271
00:09:49,760 --> 00:09:51,519
there are links this is just to even

272
00:09:51,519 --> 00:09:54,959
sketch the the landscape of otp so there

273
00:09:54,959 --> 00:09:56,480
are memory cells which actually

274
00:09:56,480 --> 00:09:58,000
represents bit

275
00:09:58,000 --> 00:09:59,760
typically an unprogrammed cell

276
00:09:59,760 --> 00:10:03,120
represented zero and when you

277
00:10:03,120 --> 00:10:05,519
blow it when you physically damage it it

278
00:10:05,519 --> 00:10:07,920
represents a one keep in mind that this

279
00:10:07,920 --> 00:10:09,920
is usually done like this

280
00:10:09,920 --> 00:10:12,800
sometimes you have seen situations which

281
00:10:12,800 --> 00:10:15,200
actually were broken so it's a bad idea

282
00:10:15,200 --> 00:10:18,720
to do so where one is unprogrammed and

283
00:10:18,720 --> 00:10:20,880
zero is programmed if you do this way i

284
00:10:20,880 --> 00:10:21,760
mean

285
00:10:21,760 --> 00:10:24,000
i mean this could be a pro a big

286
00:10:24,000 --> 00:10:26,800
security problem but in general otp

287
00:10:26,800 --> 00:10:29,760
contains data i should feel think about

288
00:10:29,760 --> 00:10:31,519
as non-volatile memory which is

289
00:10:31,519 --> 00:10:34,240
non-volatile forever more or less

290
00:10:34,240 --> 00:10:36,880
it contains data configurations

291
00:10:36,880 --> 00:10:38,800
confusion data or secrets in general

292
00:10:38,800 --> 00:10:40,399
keys

293
00:10:40,399 --> 00:10:42,240
this is an example which

294
00:10:42,240 --> 00:10:44,800
i likely i likely found over the

295
00:10:44,800 --> 00:10:46,720
internet that shows that actually the

296
00:10:46,720 --> 00:10:48,800
cells are organized in an array there

297
00:10:48,800 --> 00:10:50,720
are several lines of decoder in order to

298
00:10:50,720 --> 00:10:53,279
access it and also

299
00:10:53,279 --> 00:10:54,880
you're going to need a

300
00:10:54,880 --> 00:10:57,360
right line which actually provides

301
00:10:57,360 --> 00:10:59,760
higher voltage in order to break that

302
00:10:59,760 --> 00:11:02,800
physical to damage that that cell

303
00:11:02,800 --> 00:11:04,720
but you see that basically the density

304
00:11:04,720 --> 00:11:05,360
is

305
00:11:05,360 --> 00:11:08,000
a can be well pretty pretty decent i

306
00:11:08,000 --> 00:11:09,360
would say and

307
00:11:09,360 --> 00:11:11,440
this is actually the core where the data

308
00:11:11,440 --> 00:11:13,519
is stored okay

309
00:11:13,519 --> 00:11:16,079
now the data is not stored randomly

310
00:11:16,079 --> 00:11:18,399
there is a nice organization of memory

311
00:11:18,399 --> 00:11:20,320
so the otp is typically divided in

312
00:11:20,320 --> 00:11:22,560
regions you are there a region where you

313
00:11:22,560 --> 00:11:24,640
can control a single bit so basically

314
00:11:24,640 --> 00:11:26,399
you can read a single bit you can write

315
00:11:26,399 --> 00:11:28,480
a single bit and without affecting the

316
00:11:28,480 --> 00:11:29,440
rest

317
00:11:29,440 --> 00:11:31,519
uh this is typically used for security

318
00:11:31,519 --> 00:11:35,040
configuration like i want to uh set up

319
00:11:35,040 --> 00:11:37,600
disable jtag you blow just one single

320
00:11:37,600 --> 00:11:39,760
fuse one single bit and then from that

321
00:11:39,760 --> 00:11:41,040
moment

322
00:11:41,040 --> 00:11:43,360
the logic will lock jaden we'll see how

323
00:11:43,360 --> 00:11:46,560
in a moment but also there are possible

324
00:11:46,560 --> 00:11:48,320
that you have blocks where you actually

325
00:11:48,320 --> 00:11:50,320
can only write multiple bit at the same

326
00:11:50,320 --> 00:11:52,240
time and when you read you read them and

327
00:11:52,240 --> 00:11:54,320
uh at the bootable deal same time this

328
00:11:54,320 --> 00:11:56,000
this actually depends how the block is

329
00:11:56,000 --> 00:11:58,160
wired in general and this is use this

330
00:11:58,160 --> 00:12:00,720
approach using for bulk data like keys

331
00:12:00,720 --> 00:12:02,160
and so on

332
00:12:02,160 --> 00:12:03,920
important part is that regions

333
00:12:03,920 --> 00:12:05,839
themselves can be read and write

334
00:12:05,839 --> 00:12:08,160
protected so the region can be read

335
00:12:08,160 --> 00:12:10,079
locked or right locked this is actually

336
00:12:10,079 --> 00:12:12,480
the typical jargon that you hear but in

337
00:12:12,480 --> 00:12:14,959
practice is read and write protection

338
00:12:14,959 --> 00:12:16,639
so this means that somewhere else there

339
00:12:16,639 --> 00:12:19,680
is an otp bit that if you actually set

340
00:12:19,680 --> 00:12:22,560
that to 1 then the corresponding regions

341
00:12:22,560 --> 00:12:23,760
become

342
00:12:23,760 --> 00:12:24,720
read

343
00:12:24,720 --> 00:12:26,480
or write protected depending on which

344
00:12:26,480 --> 00:12:29,600
bit you actually set

345
00:12:29,680 --> 00:12:32,079
why this is needed well the main point

346
00:12:32,079 --> 00:12:34,160
is that if you have keys the keys will

347
00:12:34,160 --> 00:12:36,639
not just made of ones there are ones and

348
00:12:36,639 --> 00:12:39,600
zeros but by nature of the otp by

349
00:12:39,600 --> 00:12:41,600
technology the zero can always be

350
00:12:41,600 --> 00:12:43,680
brought to a one is only the opposite is

351
00:12:43,680 --> 00:12:46,720
not so in order to preserve a value

352
00:12:46,720 --> 00:12:49,440
of zero that you want that to be at zero

353
00:12:49,440 --> 00:12:51,360
you need to lock that region because if

354
00:12:51,360 --> 00:12:52,800
you don't do

355
00:12:52,800 --> 00:12:54,880
for example one interesting attack is

356
00:12:54,880 --> 00:12:57,760
that i could write one single bit

357
00:12:57,760 --> 00:13:00,560
in your key or one single block chances

358
00:13:00,560 --> 00:13:03,040
are is that the resulting public key

359
00:13:03,040 --> 00:13:05,279
will be much weaker to factorization i

360
00:13:05,279 --> 00:13:08,399
mean in general the strong keys are

361
00:13:08,399 --> 00:13:10,959
very rare the one strong and they're not

362
00:13:10,959 --> 00:13:13,040
close to each other so if you change one

363
00:13:13,040 --> 00:13:14,880
bit in a very strong key there is a high

364
00:13:14,880 --> 00:13:17,200
chance of mutating that in a very

365
00:13:17,200 --> 00:13:19,440
weak key which you can then factorize

366
00:13:19,440 --> 00:13:20,800
you can then create a private key and

367
00:13:20,800 --> 00:13:23,360
then buy i mean just a nutshell how you

368
00:13:23,360 --> 00:13:24,959
could use this and why it's important

369
00:13:24,959 --> 00:13:26,560
that you actually preserve those zeros

370
00:13:26,560 --> 00:13:29,519
to zeros especially for keys

371
00:13:29,519 --> 00:13:31,839
so what you've seen here here is the

372
00:13:31,839 --> 00:13:32,880
macro

373
00:13:32,880 --> 00:13:34,959
uh is the actually the cell array that

374
00:13:34,959 --> 00:13:36,639
we're discussing it can be a bit more

375
00:13:36,639 --> 00:13:39,040
complex but basically the important part

376
00:13:39,040 --> 00:13:41,279
that you see are the cell array here

377
00:13:41,279 --> 00:13:43,360
these are the access control when

378
00:13:43,360 --> 00:13:45,920
accessing the array and this is actually

379
00:13:45,920 --> 00:13:48,320
what enforces the lockable region so you

380
00:13:48,320 --> 00:13:50,320
actually send a request hey i want to

381
00:13:50,320 --> 00:13:52,880
write here or i want to read this region

382
00:13:52,880 --> 00:13:54,959
this is the block that would probably

383
00:13:54,959 --> 00:13:55,920
drop

384
00:13:55,920 --> 00:13:57,600
this is an open source implementation

385
00:13:57,600 --> 00:14:00,000
it's just a reference so it's just to

386
00:14:00,000 --> 00:14:04,240
let you uh just to share how this works

387
00:14:04,240 --> 00:14:06,399
the other important part is bus because

388
00:14:06,399 --> 00:14:08,560
in general this data needs to go up

389
00:14:08,560 --> 00:14:09,680
because it's for the external

390
00:14:09,680 --> 00:14:12,560
communication i mean because this data

391
00:14:12,560 --> 00:14:14,639
needs to be effective because at rest is

392
00:14:14,639 --> 00:14:17,199
just information it becomes as a huge

393
00:14:17,199 --> 00:14:20,560
feature when it starts being acted upon

394
00:14:20,560 --> 00:14:22,880
so for example in esp32 what you're

395
00:14:22,880 --> 00:14:24,959
going to see here this is just a summary

396
00:14:24,959 --> 00:14:26,160
of the list

397
00:14:26,160 --> 00:14:27,920
for example these are configuration you

398
00:14:27,920 --> 00:14:30,079
see that the bitstart and bit count is

399
00:14:30,079 --> 00:14:32,560
one so there is a low count of bits so

400
00:14:32,560 --> 00:14:34,399
basically you can

401
00:14:34,399 --> 00:14:36,480
disable the write on block one you

402
00:14:36,480 --> 00:14:38,480
disable the regular two disable the read

403
00:14:38,480 --> 00:14:41,600
on block one if this is needed for

404
00:14:41,600 --> 00:14:44,560
enabling flash encryption then this is

405
00:14:44,560 --> 00:14:47,519
also needed for enabling enabling cu

406
00:14:47,519 --> 00:14:49,360
boots and this is needed for disabling

407
00:14:49,360 --> 00:14:51,519
jdog so this gives you they are all in

408
00:14:51,519 --> 00:14:53,199
block zero

409
00:14:53,199 --> 00:14:55,760
but there is another thing which are the

410
00:14:55,760 --> 00:14:58,240
bulk keys are in entirely different

411
00:14:58,240 --> 00:15:00,880
block so even just looking at this we

412
00:15:00,880 --> 00:15:03,360
know that probably the the logic behind

413
00:15:03,360 --> 00:15:05,920
in the otp controller the wiring or even

414
00:15:05,920 --> 00:15:09,279
in the memory cell array is actually

415
00:15:09,279 --> 00:15:11,040
very likely different because you need

416
00:15:11,040 --> 00:15:13,199
to minimize let's say the

417
00:15:13,199 --> 00:15:15,599
the die

418
00:15:15,839 --> 00:15:18,240
the dye utilization of course

419
00:15:18,240 --> 00:15:19,760
and these are the read write protection

420
00:15:19,760 --> 00:15:21,760
we were talking about so they actually

421
00:15:21,760 --> 00:15:23,519
pretty straightforward with it should

422
00:15:23,519 --> 00:15:25,120
match what we were saying

423
00:15:25,120 --> 00:15:27,360
so the otp data transfer

424
00:15:27,360 --> 00:15:29,279
that we are talking about

425
00:15:29,279 --> 00:15:31,199
they are needed in order to act upon

426
00:15:31,199 --> 00:15:33,920
this bit but reading from otp every time

427
00:15:33,920 --> 00:15:36,639
they do need a bit can be quite slow

428
00:15:36,639 --> 00:15:38,720
so that's why the data is usually

429
00:15:38,720 --> 00:15:41,199
transferred to other register which they

430
00:15:41,199 --> 00:15:43,920
usually refer to as shadow register

431
00:15:43,920 --> 00:15:45,519
now these shadow radius can be in

432
00:15:45,519 --> 00:15:47,600
hardware logic so that you configure

433
00:15:47,600 --> 00:15:49,920
that or

434
00:15:49,920 --> 00:15:51,839
they can be used for faster access from

435
00:15:51,839 --> 00:15:53,440
software so keep in mind that for

436
00:15:53,440 --> 00:15:56,160
example if you need to know if this

437
00:15:56,160 --> 00:15:59,519
u-boot is enabled and that bit is you

438
00:15:59,519 --> 00:16:01,199
know to p if you every time you need to

439
00:16:01,199 --> 00:16:04,160
read that or a very slow bus or b

440
00:16:04,160 --> 00:16:06,000
through a serializer sequence and all

441
00:16:06,000 --> 00:16:07,839
these things it can be very complicated

442
00:16:07,839 --> 00:16:09,920
and slow so basically what you do is

443
00:16:09,920 --> 00:16:12,560
that you at boots you transfer this data

444
00:16:12,560 --> 00:16:13,920
into register

445
00:16:13,920 --> 00:16:15,759
this is usually called buffered data

446
00:16:15,759 --> 00:16:18,160
there is of course unbuffered data but

447
00:16:18,160 --> 00:16:20,000
let's focus on the buffered one which is

448
00:16:20,000 --> 00:16:22,160
always transferred

449
00:16:22,160 --> 00:16:23,680
some of the shadow register may be

450
00:16:23,680 --> 00:16:25,519
actually memory mapped because it needs

451
00:16:25,519 --> 00:16:28,880
to be consumed by software uh in general

452
00:16:28,880 --> 00:16:31,040
for example the wrong code needs to know

453
00:16:31,040 --> 00:16:33,600
if your bit needs is a

454
00:16:33,600 --> 00:16:35,759
your boot is enabled and instead of

455
00:16:35,759 --> 00:16:37,920
asking otp just freeze the dedicated

456
00:16:37,920 --> 00:16:40,160
shadow register at the specific address

457
00:16:40,160 --> 00:16:41,759
so every time in your own code you see

458
00:16:41,759 --> 00:16:44,320
hey let me see what is at this address

459
00:16:44,320 --> 00:16:47,759
it's actually usually a read-only shadow

460
00:16:47,759 --> 00:16:49,600
register which has been updated by the

461
00:16:49,600 --> 00:16:51,920
logic from otp data so that is just a

462
00:16:51,920 --> 00:16:55,279
mirror of what is not tp

463
00:16:55,279 --> 00:16:56,880
there are other register which may be

464
00:16:56,880 --> 00:16:59,279
only accessible by hardware logic for

465
00:16:59,279 --> 00:17:01,440
example the keys that we were discussing

466
00:17:01,440 --> 00:17:04,000
here before the unique keys that go into

467
00:17:04,000 --> 00:17:05,919
the hardware that are device keys which

468
00:17:05,919 --> 00:17:08,240
are not readable by software they

469
00:17:08,240 --> 00:17:10,640
actually stay usually in some of these

470
00:17:10,640 --> 00:17:13,359
registers which are transferred from the

471
00:17:13,359 --> 00:17:16,400
otp to the actual ip for example crypto

472
00:17:16,400 --> 00:17:18,559
engines will see during boots the

473
00:17:18,559 --> 00:17:19,839
population

474
00:17:19,839 --> 00:17:21,199
of these

475
00:17:21,199 --> 00:17:23,439
of these registers from from the from

476
00:17:23,439 --> 00:17:24,959
the otp side

477
00:17:24,959 --> 00:17:27,599
so basically when you start initializing

478
00:17:27,599 --> 00:17:29,840
the the system and chip you will see

479
00:17:29,840 --> 00:17:32,400
that the there is otp array the data is

480
00:17:32,400 --> 00:17:34,480
always there you know to be bank and as

481
00:17:34,480 --> 00:17:36,480
the ship starts uh

482
00:17:36,480 --> 00:17:39,039
starts coming alive the tp controller

483
00:17:39,039 --> 00:17:41,120
starts making its own operation and

484
00:17:41,120 --> 00:17:44,200
starts sequencing the data according to

485
00:17:44,200 --> 00:17:45,840
pre-logic

486
00:17:45,840 --> 00:17:47,840
common response with the actual

487
00:17:47,840 --> 00:17:50,160
otp array i mean this this may vary of

488
00:17:50,160 --> 00:17:51,919
course but this gives you an idea your

489
00:17:51,919 --> 00:17:54,000
tp data is then transferred to the otp

490
00:17:54,000 --> 00:17:56,240
controller this is the buffer data we

491
00:17:56,240 --> 00:17:57,760
were talking about

492
00:17:57,760 --> 00:18:00,240
and then transferred through the for

493
00:18:00,240 --> 00:18:02,240
example hardware crypto engine through

494
00:18:02,240 --> 00:18:05,440
the rootkey register which now contains

495
00:18:05,440 --> 00:18:07,360
the the root key of the device that

496
00:18:07,360 --> 00:18:09,280
register is not memory mapped and cannot

497
00:18:09,280 --> 00:18:11,600
be read by software okay so this is how

498
00:18:11,600 --> 00:18:14,480
you use a key without actually sharing

499
00:18:14,480 --> 00:18:15,360
the key

500
00:18:15,360 --> 00:18:16,880
in arbor

501
00:18:16,880 --> 00:18:18,480
of course there is other information

502
00:18:18,480 --> 00:18:20,880
which may go to memory mapped register

503
00:18:20,880 --> 00:18:22,720
there are several and this will be

504
00:18:22,720 --> 00:18:25,440
populated as well and this is where the

505
00:18:25,440 --> 00:18:28,400
software will actually start acting upon

506
00:18:28,400 --> 00:18:30,160
so you see that this

507
00:18:30,160 --> 00:18:31,919
data is transferred in terms of

508
00:18:31,919 --> 00:18:33,760
information so the information is

509
00:18:33,760 --> 00:18:35,840
sufficient several times to the array to

510
00:18:35,840 --> 00:18:37,919
the controller to memory of register to

511
00:18:37,919 --> 00:18:40,240
the cpu what it needs for example

512
00:18:40,240 --> 00:18:42,480
another glitch that could be possible

513
00:18:42,480 --> 00:18:44,720
is basically when the cpu checks if the

514
00:18:44,720 --> 00:18:46,559
secure boot is enabled so you're

515
00:18:46,559 --> 00:18:49,280
glitching the software not the hardware

516
00:18:49,280 --> 00:18:51,919
that says hey is this bit 1.0 and the

517
00:18:51,919 --> 00:18:54,960
software actually sampled that as a zero

518
00:18:54,960 --> 00:18:57,760
but in the register there is still a one

519
00:18:57,760 --> 00:18:59,679
what we are talking here is

520
00:18:59,679 --> 00:19:01,440
a bit different because we are

521
00:19:01,440 --> 00:19:03,520
interested in focusing on these buses

522
00:19:03,520 --> 00:19:05,679
because all this transfer will happen

523
00:19:05,679 --> 00:19:07,280
over buses

524
00:19:07,280 --> 00:19:09,200
so in general there are opportunities

525
00:19:09,200 --> 00:19:11,440
fault injection that targets hardware

526
00:19:11,440 --> 00:19:13,200
only and not software because at this

527
00:19:13,200 --> 00:19:15,440
moment there is no software being run at

528
00:19:15,440 --> 00:19:18,160
this moment because the otp transfer is

529
00:19:18,160 --> 00:19:19,600
trans is uh

530
00:19:19,600 --> 00:19:21,440
the top data is transferred multiple

531
00:19:21,440 --> 00:19:23,360
times and across multiple buses with

532
00:19:23,360 --> 00:19:24,960
different speed

533
00:19:24,960 --> 00:19:26,240
so basically

534
00:19:26,240 --> 00:19:28,799
a successful glitch of the data on of

535
00:19:28,799 --> 00:19:31,200
any of those buses may modify the

536
00:19:31,200 --> 00:19:33,679
transferred value while leaving due to

537
00:19:33,679 --> 00:19:35,760
p-cop is affected so we are talking

538
00:19:35,760 --> 00:19:38,960
about is a one boot only attack not a

539
00:19:38,960 --> 00:19:42,160
permanent but still possible without

540
00:19:42,160 --> 00:19:45,440
doing any software evaluation or any

541
00:19:45,440 --> 00:19:48,160
targeting any line of software

542
00:19:48,160 --> 00:19:50,480
but if this works actually that one in

543
00:19:50,480 --> 00:19:53,120
otp becomes a 0 in the shadow register

544
00:19:53,120 --> 00:19:55,760
and so for example the software say may

545
00:19:55,760 --> 00:19:57,919
draw incorrect conclusion hey the secure

546
00:19:57,919 --> 00:20:00,160
boot is not enabled because the cpu

547
00:20:00,160 --> 00:20:02,799
actually reads incorrect value and not

548
00:20:02,799 --> 00:20:04,559
because the readers be english but

549
00:20:04,559 --> 00:20:06,640
because the transfer has been english

550
00:20:06,640 --> 00:20:07,919
before

551
00:20:07,919 --> 00:20:09,520
the same goes for then for the

552
00:20:09,520 --> 00:20:11,760
hardware-based ud features because the

553
00:20:11,760 --> 00:20:13,600
hardware logic may be correctly

554
00:20:13,600 --> 00:20:15,919
configured when you disable a jtag you

555
00:20:15,919 --> 00:20:19,440
are basically transferring a value to a

556
00:20:19,440 --> 00:20:21,760
logic gate to a register which will set

557
00:20:21,760 --> 00:20:24,799
the logic in order to completely cut off

558
00:20:24,799 --> 00:20:27,039
the the signal of this jtag if that

559
00:20:27,039 --> 00:20:29,120
register is not populated there is no

560
00:20:29,120 --> 00:20:30,799
jtag logic

561
00:20:30,799 --> 00:20:32,559
disabled

562
00:20:32,559 --> 00:20:34,480
well this is all theory does it really

563
00:20:34,480 --> 00:20:35,600
work

564
00:20:35,600 --> 00:20:38,559
well we usually start with doing a fault

565
00:20:38,559 --> 00:20:40,559
injection characterization so we

566
00:20:40,559 --> 00:20:42,799
actually start to see our chip behave

567
00:20:42,799 --> 00:20:45,360
according to our needs in general

568
00:20:45,360 --> 00:20:47,840
so what we in our target we focus it on

569
00:20:47,840 --> 00:20:50,480
this module that we discussed and

570
00:20:50,480 --> 00:20:52,880
this is the actual system on chip which

571
00:20:52,880 --> 00:20:56,159
is inside is the sp 32 is the first cf

572
00:20:56,159 --> 00:21:00,000
no we have not tested the newer one

573
00:21:00,000 --> 00:21:01,760
although we think that the concept here

574
00:21:01,760 --> 00:21:04,480
as we've said may apply to a wide

575
00:21:04,480 --> 00:21:07,120
variety of chip and not only to a family

576
00:21:07,120 --> 00:21:09,360
obvious person so this is a more general

577
00:21:09,360 --> 00:21:12,679
talk which is demonstrated only on

578
00:21:12,679 --> 00:21:14,400
esp32

579
00:21:14,400 --> 00:21:17,360
our setup overview uh basically what we

580
00:21:17,360 --> 00:21:20,000
have is uh this is our target and this

581
00:21:20,000 --> 00:21:23,120
is our probe then we have an xyz stage

582
00:21:23,120 --> 00:21:25,520
which moves the probe around in order to

583
00:21:25,520 --> 00:21:26,640
do this

584
00:21:26,640 --> 00:21:28,400
then we have

585
00:21:28,400 --> 00:21:31,120
the let's say the brain of our

586
00:21:31,120 --> 00:21:34,159
coordination which actually move the x-y

587
00:21:34,159 --> 00:21:36,320
stage stage and also communicates to

588
00:21:36,320 --> 00:21:39,600
esp32 so the logic for glitching

589
00:21:39,600 --> 00:21:41,440
the logic for glitching actually here is

590
00:21:41,440 --> 00:21:43,919
an fpga spider

591
00:21:43,919 --> 00:21:45,039
which

592
00:21:45,039 --> 00:21:46,559
basically

593
00:21:46,559 --> 00:21:49,360
according to the configuration sets and

594
00:21:49,360 --> 00:21:51,600
release times and so on if you want to

595
00:21:51,600 --> 00:21:53,280
see this life is actually rescued

596
00:21:53,280 --> 00:21:55,440
equipment we use that because we are

597
00:21:55,440 --> 00:21:56,880
pretty

598
00:21:56,880 --> 00:21:58,559
say i would say we could call ourselves

599
00:21:58,559 --> 00:22:00,799
power user of this equipment we we know

600
00:22:00,799 --> 00:22:02,640
that pretty well

601
00:22:02,640 --> 00:22:05,120
so basically this is the spider this is

602
00:22:05,120 --> 00:22:08,080
what says that stage that moves our

603
00:22:08,080 --> 00:22:10,080
probe around this is the spider the

604
00:22:10,080 --> 00:22:11,440
logic here

605
00:22:11,440 --> 00:22:14,080
and this is our target and this is the

606
00:22:14,080 --> 00:22:15,919
brain we are talking about so if you

607
00:22:15,919 --> 00:22:19,039
actually map these to the previous uh

608
00:22:19,039 --> 00:22:21,520
picture it should be easy to see what

609
00:22:21,520 --> 00:22:23,919
what is what is doing and in order to

610
00:22:23,919 --> 00:22:25,840
see the connection that we have this is

611
00:22:25,840 --> 00:22:28,960
from the spider we do have basically two

612
00:22:28,960 --> 00:22:31,039
things uh the um

613
00:22:31,039 --> 00:22:33,039
the trigger and the reset so we control

614
00:22:33,039 --> 00:22:36,480
the reset so we can count how long it

615
00:22:36,480 --> 00:22:38,720
takes from the reset so basically the

616
00:22:38,720 --> 00:22:40,480
idea is that every time we reboot the

617
00:22:40,480 --> 00:22:43,360
chip basically we start uh glitching and

618
00:22:43,360 --> 00:22:45,440
see what happens that's the basic idea

619
00:22:45,440 --> 00:22:47,360
but more specifically the experiment

620
00:22:47,360 --> 00:22:48,480
setup

621
00:22:48,480 --> 00:22:51,280
we set we enable sigerboot by setting

622
00:22:51,280 --> 00:22:52,799
this fuse we

623
00:22:52,799 --> 00:22:55,679
set this up key and we also enable read

624
00:22:55,679 --> 00:22:57,919
protection so basically we are not able

625
00:22:57,919 --> 00:23:00,240
to read that key anymore and so your

626
00:23:00,240 --> 00:23:02,880
boot is actually really enabled

627
00:23:02,880 --> 00:23:05,039
we program a valid bootloader the valid

628
00:23:05,039 --> 00:23:07,600
bootloader is actually only printing

629
00:23:07,600 --> 00:23:08,640
fuses

630
00:23:08,640 --> 00:23:10,960
nothing more so it's just dumping the

631
00:23:10,960 --> 00:23:13,200
output of the fuses

632
00:23:13,200 --> 00:23:14,559
and that's that's what we get as a

633
00:23:14,559 --> 00:23:16,159
doubtful from our experiment we just

634
00:23:16,159 --> 00:23:18,000
need two other things

635
00:23:18,000 --> 00:23:20,159
while this is running in the reboot we

636
00:23:20,159 --> 00:23:22,799
actually scan with our probe the entire

637
00:23:22,799 --> 00:23:24,159
chip surface

638
00:23:24,159 --> 00:23:26,080
and we glisten good time

639
00:23:26,080 --> 00:23:28,720
we don't know where at this moment but

640
00:23:28,720 --> 00:23:30,640
for sure we want to glitch before the

641
00:23:30,640 --> 00:23:33,120
cpu is starting so we glitch before the

642
00:23:33,120 --> 00:23:35,760
first rom print out there are there's a

643
00:23:35,760 --> 00:23:37,919
screenshot of the technical details but

644
00:23:37,919 --> 00:23:39,600
this is a generic idea if you have an

645
00:23:39,600 --> 00:23:42,000
oscilloscope it should be very easy to

646
00:23:42,000 --> 00:23:42,720
uh

647
00:23:42,720 --> 00:23:44,720
to figure this out also because there is

648
00:23:44,720 --> 00:23:48,159
already material published on this

649
00:23:48,159 --> 00:23:50,159
the goal is for us is to find the

650
00:23:50,159 --> 00:23:51,840
vulnerable location what is a

651
00:23:51,840 --> 00:23:54,320
vulnerability a location where the dump

652
00:23:54,320 --> 00:23:58,000
for the fuses returned any changed bit

653
00:23:58,000 --> 00:24:00,080
in the configuration any we don't we

654
00:24:00,080 --> 00:24:01,840
don't care so because we know that in

655
00:24:01,840 --> 00:24:05,200
that location we can do something so we

656
00:24:05,200 --> 00:24:07,360
try to optimize out

657
00:24:07,360 --> 00:24:10,159
the the space parameters because it's

658
00:24:10,159 --> 00:24:12,960
really huge it's x y z so the first

659
00:24:12,960 --> 00:24:15,520
thing that we try to optimize out to

660
00:24:15,520 --> 00:24:17,440
take this hour away of the equation is

661
00:24:17,440 --> 00:24:19,760
the uh is the location

662
00:24:19,760 --> 00:24:21,600
so what you see here is that how we

663
00:24:21,600 --> 00:24:24,159
control in the

664
00:24:24,159 --> 00:24:27,039
the the spider in the entire system uh

665
00:24:27,039 --> 00:24:29,279
basically we use uh we use a still five

666
00:24:29,279 --> 00:24:32,320
pi uh from uh from riskier here but this

667
00:24:32,320 --> 00:24:33,600
is actually a python script that we

668
00:24:33,600 --> 00:24:35,520
create and what is important is that we

669
00:24:35,520 --> 00:24:37,919
classify the experiment based on the

670
00:24:37,919 --> 00:24:40,880
data and that's the important part for

671
00:24:40,880 --> 00:24:43,919
example in here we say that the result

672
00:24:43,919 --> 00:24:47,279
should be called as green if basically

673
00:24:47,279 --> 00:24:50,640
uh there is a proper reset uh challenge

674
00:24:50,640 --> 00:24:51,360
and

675
00:24:51,360 --> 00:24:52,960
there is a

676
00:24:52,960 --> 00:24:54,559
and this is actually the response we

677
00:24:54,559 --> 00:24:56,880
should have so if block 0 is in response

678
00:24:56,880 --> 00:24:58,799
so if we have this and block 2 is a

679
00:24:58,799 --> 00:25:01,440
response so it's zero then

680
00:25:01,440 --> 00:25:03,200
and you also get the proper boot

681
00:25:03,200 --> 00:25:04,799
sequence then it's green so means that

682
00:25:04,799 --> 00:25:07,440
we are not being able to be successful

683
00:25:07,440 --> 00:25:10,640
so we we class do classification of that

684
00:25:10,640 --> 00:25:12,400
the important part for us so meaning

685
00:25:12,400 --> 00:25:14,480
that we bypass the security feature is

686
00:25:14,480 --> 00:25:17,760
that when we have something which is not

687
00:25:17,760 --> 00:25:20,080
exactly block 0 but it's been different

688
00:25:20,080 --> 00:25:23,279
so we have a regular expression or and

689
00:25:23,279 --> 00:25:26,000
also the block 2 maybe we do see

690
00:25:26,000 --> 00:25:28,159
something different and then we see red

691
00:25:28,159 --> 00:25:30,640
so red is good for us and green green is

692
00:25:30,640 --> 00:25:32,480
actually we did nothing then there are

693
00:25:32,480 --> 00:25:34,240
another classification which allows us

694
00:25:34,240 --> 00:25:35,520
to map

695
00:25:35,520 --> 00:25:37,760
things so let's see how this looks like

696
00:25:37,760 --> 00:25:39,200
the important part is this

697
00:25:39,200 --> 00:25:41,120
classification is not done afterwards is

698
00:25:41,120 --> 00:25:42,880
that during the experiment so while the

699
00:25:42,880 --> 00:25:44,799
experiment running we can build

700
00:25:44,799 --> 00:25:46,960
something like this

701
00:25:46,960 --> 00:25:47,840
and

702
00:25:47,840 --> 00:25:51,200
basically what you see are the uh green

703
00:25:51,200 --> 00:25:53,360
and yellow over mapping overlapping

704
00:25:53,360 --> 00:25:56,000
meaning that in that location we both

705
00:25:56,000 --> 00:25:57,039
have

706
00:25:57,039 --> 00:25:59,360
nothing or we are able to just reset the

707
00:25:59,360 --> 00:26:01,760
chip and nothing interesting comes

708
00:26:01,760 --> 00:26:03,520
you know you cannot see that invisibly

709
00:26:03,520 --> 00:26:05,279
into the color of the screen but there

710
00:26:05,279 --> 00:26:08,000
are a few red here and a few red here so

711
00:26:08,000 --> 00:26:09,360
i mean if you when you take the slides

712
00:26:09,360 --> 00:26:11,279
you will probably see them a bit better

713
00:26:11,279 --> 00:26:13,919
but we see that when we plot this in

714
00:26:13,919 --> 00:26:16,640
terms of how much power we use and

715
00:26:16,640 --> 00:26:19,440
where we can actually see the reds

716
00:26:19,440 --> 00:26:21,440
then this is the time that we have so

717
00:26:21,440 --> 00:26:24,080
this means that around this time we do

718
00:26:24,080 --> 00:26:27,120
have successful glitches basically and

719
00:26:27,120 --> 00:26:29,760
the power of our probe goes from 50 to

720
00:26:29,760 --> 00:26:32,799
almost 95 so this means that we also

721
00:26:32,799 --> 00:26:34,320
have other parameters which are the

722
00:26:34,320 --> 00:26:36,320
power of the problem we are using but

723
00:26:36,320 --> 00:26:38,640
also when we glitch and for us it's

724
00:26:38,640 --> 00:26:41,520
important to confine the search space in

725
00:26:41,520 --> 00:26:42,480
general

726
00:26:42,480 --> 00:26:44,720
so this is actually we start having a

727
00:26:44,720 --> 00:26:47,760
look at where are the relevant portion

728
00:26:47,760 --> 00:26:50,159
of if you start zooming on this part you

729
00:26:50,159 --> 00:26:52,159
see there is some aggregation of result

730
00:26:52,159 --> 00:26:54,000
this is really interesting

731
00:26:54,000 --> 00:26:55,279
and you see that

732
00:26:55,279 --> 00:26:57,840
from this time to this time is actually

733
00:26:57,840 --> 00:27:00,039
between 50

734
00:27:00,039 --> 00:27:03,600
535 microseconds and 460. so this means

735
00:27:03,600 --> 00:27:05,279
that next time that we do the same

736
00:27:05,279 --> 00:27:07,360
operation we can just investigate the

737
00:27:07,360 --> 00:27:09,600
area and we don't need to investigate

738
00:27:09,600 --> 00:27:11,600
the entire space so this means we are

739
00:27:11,600 --> 00:27:13,440
much faster we are much more effective

740
00:27:13,440 --> 00:27:15,360
we know more

741
00:27:15,360 --> 00:27:17,200
nice of the results what is the data

742
00:27:17,200 --> 00:27:19,200
because apart from location and red and

743
00:27:19,200 --> 00:27:21,279
colors we also need data so this is a

744
00:27:21,279 --> 00:27:22,880
good block

745
00:27:22,880 --> 00:27:25,360
this is a block where we changed one bit

746
00:27:25,360 --> 00:27:28,240
from c28 that's a very good one

747
00:27:28,240 --> 00:27:30,080
another block where we change one bit

748
00:27:30,080 --> 00:27:31,919
one block where we change one bit block

749
00:27:31,919 --> 00:27:35,200
bit block one bit block one bit

750
00:27:35,200 --> 00:27:37,360
so this is extremely interesting so this

751
00:27:37,360 --> 00:27:40,799
means that there are locations where we

752
00:27:40,799 --> 00:27:43,600
are able to affect exactly one single

753
00:27:43,600 --> 00:27:44,480
bit

754
00:27:44,480 --> 00:27:47,039
in the block zero so we know that

755
00:27:47,039 --> 00:27:48,799
somewhere in the chip

756
00:27:48,799 --> 00:27:51,200
there is a place where this is happening

757
00:27:51,200 --> 00:27:54,320
oh this is great not only we also see

758
00:27:54,320 --> 00:27:59,360
that basically the timing between

759
00:27:59,360 --> 00:28:01,440
so this is the good one have a look at

760
00:28:01,440 --> 00:28:02,559
this

761
00:28:02,559 --> 00:28:04,880
this bit here

762
00:28:04,880 --> 00:28:07,679
is a change at round here

763
00:28:07,679 --> 00:28:10,320
this bit here is change around here

764
00:28:10,320 --> 00:28:12,240
so there is a very nice timing

765
00:28:12,240 --> 00:28:15,600
relationship between which bit you're

766
00:28:15,600 --> 00:28:17,200
affecting

767
00:28:17,200 --> 00:28:18,559
oh that's

768
00:28:18,559 --> 00:28:20,480
quite great i would say for fault

769
00:28:20,480 --> 00:28:23,200
injection right because it tells a lot

770
00:28:23,200 --> 00:28:26,399
when to shoot for hitting what

771
00:28:26,399 --> 00:28:28,559
so basically we have a successful

772
00:28:28,559 --> 00:28:31,200
glitches in a narrow time region

773
00:28:31,200 --> 00:28:33,360
they actually group a specific timing we

774
00:28:33,360 --> 00:28:35,600
have a single bit glitches that's

775
00:28:35,600 --> 00:28:38,000
beautiful in terms of block zero so

776
00:28:38,000 --> 00:28:40,240
mostly we have one which is means

777
00:28:40,240 --> 00:28:43,120
features enabled torrent to zero

778
00:28:43,120 --> 00:28:44,640
and also we have a strong timing

779
00:28:44,640 --> 00:28:46,960
dependency of the affected bits

780
00:28:46,960 --> 00:28:48,399
so basically this means that we can

781
00:28:48,399 --> 00:28:50,480
disable c2d feature because from one we

782
00:28:50,480 --> 00:28:52,559
go to zero but also we can select which

783
00:28:52,559 --> 00:28:54,320
one

784
00:28:54,320 --> 00:28:57,360
oh that's a bit more interesting than

785
00:28:57,360 --> 00:28:59,679
just a

786
00:28:59,679 --> 00:29:00,960
eggless dish

787
00:29:00,960 --> 00:29:03,360
i think it's there is more a pattern

788
00:29:03,360 --> 00:29:05,760
here which is more interesting so

789
00:29:05,760 --> 00:29:08,240
basically we can actually shoot otp bits

790
00:29:08,240 --> 00:29:11,279
while they are being transferred

791
00:29:11,279 --> 00:29:12,640
well we first need to reduce the

792
00:29:12,640 --> 00:29:14,960
parameter space so this means that we

793
00:29:14,960 --> 00:29:16,080
select

794
00:29:16,080 --> 00:29:18,080
uh the location that we actually see

795
00:29:18,080 --> 00:29:20,080
this effect and we actually move the

796
00:29:20,080 --> 00:29:22,480
probe there we don't move that anymore

797
00:29:22,480 --> 00:29:24,000
so this means that the selection

798
00:29:24,000 --> 00:29:26,480
criteria was the number of uh successful

799
00:29:26,480 --> 00:29:28,640
glitches the in the in the kind that we

800
00:29:28,640 --> 00:29:30,960
have seen before so a single bit

801
00:29:30,960 --> 00:29:33,120
and also from the next experiment on we

802
00:29:33,120 --> 00:29:34,960
just stay there we don't move it anymore

803
00:29:34,960 --> 00:29:37,679
so this means that the entire space

804
00:29:37,679 --> 00:29:39,600
parameter is gone

805
00:29:39,600 --> 00:29:42,000
three dimension we we just look now for

806
00:29:42,000 --> 00:29:43,679
power and timing

807
00:29:43,679 --> 00:29:45,200
so let's start by passing the ud

808
00:29:45,200 --> 00:29:47,360
features here we are reading sugarboot

809
00:29:47,360 --> 00:29:49,760
key basically let's try to do that the

810
00:29:49,760 --> 00:29:50,720
setup

811
00:29:50,720 --> 00:29:52,799
same as before nothing has changed but

812
00:29:52,799 --> 00:29:56,399
now we want to glitch the exact bit

813
00:29:56,399 --> 00:29:58,559
that enables read protections we want to

814
00:29:58,559 --> 00:30:00,240
shoot exactly that one

815
00:30:00,240 --> 00:30:02,159
so we program a valid bootloader that

816
00:30:02,159 --> 00:30:03,760
prints the fuses

817
00:30:03,760 --> 00:30:05,679
the cute boot key is unreadable of

818
00:30:05,679 --> 00:30:07,840
course because it's protected and now we

819
00:30:07,840 --> 00:30:10,159
want to read it out so we need to change

820
00:30:10,159 --> 00:30:13,120
this bit exactly during the transfer

821
00:30:13,120 --> 00:30:14,880
and basically we have successful

822
00:30:14,880 --> 00:30:17,679
glitches exactly at this time

823
00:30:17,679 --> 00:30:20,000
so basically you are going to see that

824
00:30:20,000 --> 00:30:22,159
if you actually shoot around the time

825
00:30:22,159 --> 00:30:24,880
with this large variety of power then

826
00:30:24,880 --> 00:30:27,440
you have quite some success and then you

827
00:30:27,440 --> 00:30:31,039
get the entire otp key out

828
00:30:31,039 --> 00:30:32,720
what you see here is also something

829
00:30:32,720 --> 00:30:34,880
interesting which is also new i mean

830
00:30:34,880 --> 00:30:37,840
with until for the results until now so

831
00:30:37,840 --> 00:30:39,440
we have block zero block one and block

832
00:30:39,440 --> 00:30:41,679
two this is the good one i expected the

833
00:30:41,679 --> 00:30:43,840
glitched one we see block zero is

834
00:30:43,840 --> 00:30:45,440
changed

835
00:30:45,440 --> 00:30:47,440
what is changed is actually this bit

836
00:30:47,440 --> 00:30:50,159
which is exactly the bits that we wanted

837
00:30:50,159 --> 00:30:50,880
to

838
00:30:50,880 --> 00:30:51,760
change

839
00:30:51,760 --> 00:30:53,360
by shooting at a time we're able to

840
00:30:53,360 --> 00:30:54,640
change that

841
00:30:54,640 --> 00:30:57,120
and that's why we get the key out

842
00:30:57,120 --> 00:30:58,960
what is important

843
00:30:58,960 --> 00:31:00,159
is that

844
00:31:00,159 --> 00:31:02,640
the success rate so basically once we

845
00:31:02,640 --> 00:31:03,519
get

846
00:31:03,519 --> 00:31:06,159
the parameters around the time around

847
00:31:06,159 --> 00:31:08,399
power we just select one and we just

848
00:31:08,399 --> 00:31:10,640
measure how effective we are

849
00:31:10,640 --> 00:31:13,200
so the success rate is after fixing this

850
00:31:13,200 --> 00:31:15,840
timing and power

851
00:31:15,840 --> 00:31:17,600
now all parameters are fixed we don't

852
00:31:17,600 --> 00:31:19,200
have anything we just measure how good

853
00:31:19,200 --> 00:31:20,080
we are

854
00:31:20,080 --> 00:31:22,799
and we get a success rate of one percent

855
00:31:22,799 --> 00:31:25,120
where fuel so your boot key is obtained

856
00:31:25,120 --> 00:31:27,279
and that's important one we don't need

857
00:31:27,279 --> 00:31:30,240
any brute force so so far the research

858
00:31:30,240 --> 00:31:33,279
published until now needed brute force

859
00:31:33,279 --> 00:31:35,279
and i think that's my personal

860
00:31:35,279 --> 00:31:37,440
interpretation is that the glitching and

861
00:31:37,440 --> 00:31:40,320
voltage was affecting also some bit of

862
00:31:40,320 --> 00:31:42,320
the key and not only the configuration

863
00:31:42,320 --> 00:31:45,039
with emfi you can be a bit more precise

864
00:31:45,039 --> 00:31:46,960
in location and so we were able to

865
00:31:46,960 --> 00:31:48,880
select a location that only affected the

866
00:31:48,880 --> 00:31:51,360
configuration and not the rest so this

867
00:31:51,360 --> 00:31:53,360
means that we we did not need any brute

868
00:31:53,360 --> 00:31:55,600
force so basically this means that the

869
00:31:55,600 --> 00:31:57,600
speed that we go we read the sbt within

870
00:31:57,600 --> 00:32:00,000
minutes that's basically the first

871
00:32:00,000 --> 00:32:02,399
result we shoot we want to improve

872
00:32:02,399 --> 00:32:04,159
because i mean we are not satisfied with

873
00:32:04,159 --> 00:32:07,279
this we want to do this uh read the keys

874
00:32:07,279 --> 00:32:10,000
but also do the secure boot by bus let's

875
00:32:10,000 --> 00:32:11,519
do something better

876
00:32:11,519 --> 00:32:14,559
uh i'm sorry this already gave away it's

877
00:32:14,559 --> 00:32:16,720
okay so basically we can glitch specific

878
00:32:16,720 --> 00:32:18,720
block zero bits

879
00:32:18,720 --> 00:32:21,039
by timing basically

880
00:32:21,039 --> 00:32:23,120
what is important is that

881
00:32:23,120 --> 00:32:26,720
basically the the read disable bit block

882
00:32:26,720 --> 00:32:30,399
two here is a bit start 17. so it's

883
00:32:30,399 --> 00:32:32,640
quite far basically

884
00:32:32,640 --> 00:32:33,679
and

885
00:32:33,679 --> 00:32:35,679
on the left and

886
00:32:35,679 --> 00:32:38,080
the encrypted figure boot is quite far

887
00:32:38,080 --> 00:32:40,159
on the right so this means that there is

888
00:32:40,159 --> 00:32:43,279
time for our logic to shoot recharge and

889
00:32:43,279 --> 00:32:44,720
reshoot

890
00:32:44,720 --> 00:32:46,399
so this means

891
00:32:46,399 --> 00:32:48,240
maybe we can glitch both so if they are

892
00:32:48,240 --> 00:32:49,840
too close we don't have time to do

893
00:32:49,840 --> 00:32:51,919
double glitch actually we will need two

894
00:32:51,919 --> 00:32:52,880
probes

895
00:32:52,880 --> 00:32:54,880
that can also be done but that's for

896
00:32:54,880 --> 00:32:58,159
another time for now i mean we just do

897
00:32:58,159 --> 00:33:00,559
shoot twice with the same probe

898
00:33:00,559 --> 00:33:02,720
double glitch is set up just the same

899
00:33:02,720 --> 00:33:04,720
and before we don't do anything

900
00:33:04,720 --> 00:33:06,480
different but this time we program an

901
00:33:06,480 --> 00:33:09,360
invalid bootloader we program an invalid

902
00:33:09,360 --> 00:33:10,960
bootloader and prints the fuses so this

903
00:33:10,960 --> 00:33:13,679
means that the bootloader will not boot

904
00:33:13,679 --> 00:33:15,200
so this means that normally we get

905
00:33:15,200 --> 00:33:17,039
nothing out

906
00:33:17,039 --> 00:33:17,840
so

907
00:33:17,840 --> 00:33:20,000
we now we want to bypass this yearbook

908
00:33:20,000 --> 00:33:21,760
and print the key and this will happen

909
00:33:21,760 --> 00:33:24,720
only when we bypass the key

910
00:33:24,720 --> 00:33:27,360
as we did before and then we also bypass

911
00:33:27,360 --> 00:33:29,360
this your boot and we see the output

912
00:33:29,360 --> 00:33:31,760
that's the only situation where we can

913
00:33:31,760 --> 00:33:34,080
actually see both basically

914
00:33:34,080 --> 00:33:36,000
so we need now to change two fuse bit

915
00:33:36,000 --> 00:33:36,840
during

916
00:33:36,840 --> 00:33:39,279
transfer so we first

917
00:33:39,279 --> 00:33:42,000
glitched the uh the read protection we

918
00:33:42,000 --> 00:33:44,320
now know where it is so we know exactly

919
00:33:44,320 --> 00:33:45,679
where to shoot because it's the previous

920
00:33:45,679 --> 00:33:47,279
experiment right

921
00:33:47,279 --> 00:33:49,279
so basically we can actually shoot there

922
00:33:49,279 --> 00:33:52,080
and then the second glitch is timed from

923
00:33:52,080 --> 00:33:54,960
this one so basically glitch more or

924
00:33:54,960 --> 00:33:56,559
less in the area we want to glitch and

925
00:33:56,559 --> 00:34:00,159
from that point on we just count

926
00:34:00,159 --> 00:34:02,159
we know how long because we know where

927
00:34:02,159 --> 00:34:04,320
block zero actually is finished being

928
00:34:04,320 --> 00:34:06,320
transferred from previous experiments so

929
00:34:06,320 --> 00:34:08,000
what you see here is a pretty

930
00:34:08,000 --> 00:34:10,719
interesting in my in my opinion

931
00:34:10,719 --> 00:34:12,079
this actually looks like the previous

932
00:34:12,079 --> 00:34:14,239
experiment so this is the first glitch

933
00:34:14,239 --> 00:34:16,639
that we actually saw the value of glitch

934
00:34:16,639 --> 00:34:19,440
delay in a successful glitch so the

935
00:34:19,440 --> 00:34:22,320
value that we use for the first one

936
00:34:22,320 --> 00:34:24,960
successful glitch also value is this to

937
00:34:24,960 --> 00:34:28,000
be glitching both one and two the second

938
00:34:28,000 --> 00:34:29,918
delay you see

939
00:34:29,918 --> 00:34:31,760
that is constant

940
00:34:31,760 --> 00:34:34,480
so by timing this over the previous one

941
00:34:34,480 --> 00:34:36,800
we just remove away all the jitter

942
00:34:36,800 --> 00:34:38,879
so this means and once we are able to do

943
00:34:38,879 --> 00:34:40,399
the first one

944
00:34:40,399 --> 00:34:42,480
we are also very likely to be able now

945
00:34:42,480 --> 00:34:44,960
to do the second one because we now know

946
00:34:44,960 --> 00:34:47,280
after this experiment where it is

947
00:34:47,280 --> 00:34:49,760
so this is becoming pretty precise in

948
00:34:49,760 --> 00:34:50,960
general

949
00:34:50,960 --> 00:34:52,239
and

950
00:34:52,239 --> 00:34:54,800
so this allows also ah there's something

951
00:34:54,800 --> 00:34:56,159
interesting here which we didn't

952
00:34:56,159 --> 00:34:57,440
anticipate

953
00:34:57,440 --> 00:34:59,440
uh basically it seems that our

954
00:34:59,440 --> 00:35:01,359
successful glitches double glitches

955
00:35:01,359 --> 00:35:03,440
occurring group so this means this is an

956
00:35:03,440 --> 00:35:04,320
id

957
00:35:04,320 --> 00:35:07,599
maybe between 100 and 200 we get a bank

958
00:35:07,599 --> 00:35:12,480
a batch of uh successful then after a 50

959
00:35:12,480 --> 00:35:15,200
000 attempt we get another batch then

960
00:35:15,200 --> 00:35:17,200
after another 50 hours we don't notice

961
00:35:17,200 --> 00:35:18,560
why

962
00:35:18,560 --> 00:35:20,000
there are

963
00:35:20,000 --> 00:35:22,079
guesses maybe the room temperature of

964
00:35:22,079 --> 00:35:23,839
the day that we actually see that

965
00:35:23,839 --> 00:35:26,160
happening or the sock status

966
00:35:26,160 --> 00:35:28,160
we don't know exactly but we see this

967
00:35:28,160 --> 00:35:29,599
interesting pattern

968
00:35:29,599 --> 00:35:31,760
in this case we are still successful we

969
00:35:31,760 --> 00:35:34,320
the success rate dropped to zero five

970
00:35:34,320 --> 00:35:36,640
percent we are still fine with that we

971
00:35:36,640 --> 00:35:38,560
don't care because we can still bypass

972
00:35:38,560 --> 00:35:40,720
that within an hour which is still

973
00:35:40,720 --> 00:35:42,640
perfectly doable so that's why we think

974
00:35:42,640 --> 00:35:44,640
the success rate for comparing fault

975
00:35:44,640 --> 00:35:45,839
injection

976
00:35:45,839 --> 00:35:49,520
experiment let me say that openly sucks

977
00:35:49,520 --> 00:35:51,839
because it is not related to how fast

978
00:35:51,839 --> 00:35:52,960
you go

979
00:35:52,960 --> 00:35:54,880
i mean if you have one percent and you

980
00:35:54,880 --> 00:35:57,520
do ten experiment per year it takes a

981
00:35:57,520 --> 00:35:58,400
long time

982
00:35:58,400 --> 00:36:00,000
but if you will one million spending per

983
00:36:00,000 --> 00:36:02,240
second one percent is nothing

984
00:36:02,240 --> 00:36:05,119
so that percentage of success rate is

985
00:36:05,119 --> 00:36:07,359
useless unfortunately is the only metric

986
00:36:07,359 --> 00:36:09,119
which is using academia

987
00:36:09,119 --> 00:36:10,079
uh

988
00:36:10,079 --> 00:36:10,960
well

989
00:36:10,960 --> 00:36:12,960
there are considerations over there now

990
00:36:12,960 --> 00:36:14,480
can we bypass your boot and flash

991
00:36:14,480 --> 00:36:16,079
encryption together

992
00:36:16,079 --> 00:36:18,400
well we did tried a lot

993
00:36:18,400 --> 00:36:20,480
unfortunately not we were not able to do

994
00:36:20,480 --> 00:36:23,760
that but we got an idea basically

995
00:36:23,760 --> 00:36:26,240
and what if we actually glitch the jdug

996
00:36:26,240 --> 00:36:27,520
i mean if you are able to glitch the

997
00:36:27,520 --> 00:36:29,760
jtag which is usually closed when you

998
00:36:29,760 --> 00:36:31,440
have seen your boot and flash encryption

999
00:36:31,440 --> 00:36:33,280
so in practice so you would reflection

1000
00:36:33,280 --> 00:36:36,560
encryption also enable close the jdug

1001
00:36:36,560 --> 00:36:38,720
but if you open the jdag you're also

1002
00:36:38,720 --> 00:36:41,280
able to run code so your boot is

1003
00:36:41,280 --> 00:36:43,520
automatically bypassed the only question

1004
00:36:43,520 --> 00:36:45,920
which is left is if you could

1005
00:36:45,920 --> 00:36:48,720
bypass also flash encryption let's see

1006
00:36:48,720 --> 00:36:49,920
so basically

1007
00:36:49,920 --> 00:36:54,880
i'm sorry it's my fault maybe

1008
00:36:54,880 --> 00:36:56,960
let's try to continue for a moment this

1009
00:36:56,960 --> 00:36:58,160
is really

1010
00:36:58,160 --> 00:37:00,880
okay so basically we do sets your boot

1011
00:37:00,880 --> 00:37:03,200
as before we do enable flash encryption

1012
00:37:03,200 --> 00:37:04,800
and we also make sure that jdug is

1013
00:37:04,800 --> 00:37:06,240
disabled

1014
00:37:06,240 --> 00:37:07,920
we program a valid bootloader that

1015
00:37:07,920 --> 00:37:10,079
imprints the fuses this time okay

1016
00:37:10,079 --> 00:37:13,200
and the idea is basically we want to see

1017
00:37:13,200 --> 00:37:15,599
when the open jdag interface is open

1018
00:37:15,599 --> 00:37:17,280
because the only thing which is left for

1019
00:37:17,280 --> 00:37:19,040
us are two things

1020
00:37:19,040 --> 00:37:21,359
one if you are able to open jdag and

1021
00:37:21,359 --> 00:37:23,520
second when the jtag is open are we able

1022
00:37:23,520 --> 00:37:26,160
to read plain text firmware

1023
00:37:26,160 --> 00:37:27,440
from the

1024
00:37:27,440 --> 00:37:29,280
flash encrypted

1025
00:37:29,280 --> 00:37:31,200
well because actually once you open it

1026
00:37:31,200 --> 00:37:33,599
actually by the secure boot

1027
00:37:33,599 --> 00:37:35,280
this is our classification our

1028
00:37:35,280 --> 00:37:39,440
classification goes set this 54 to 14

1029
00:37:39,440 --> 00:37:41,040
15.

1030
00:37:41,040 --> 00:37:43,280
thank you and

1031
00:37:43,280 --> 00:37:46,960
basically this is where we are

1032
00:37:46,960 --> 00:37:49,359
we are we know that we have disabled the

1033
00:37:49,359 --> 00:37:51,520
jtag at this point we just check if jtag

1034
00:37:51,520 --> 00:37:53,200
disable isn't set

1035
00:37:53,200 --> 00:37:54,800
and actually we do have successful

1036
00:37:54,800 --> 00:37:56,320
glitches again

1037
00:37:56,320 --> 00:37:59,040
so and we are all scattered to a nice

1038
00:37:59,040 --> 00:38:00,800
and precise

1039
00:38:00,800 --> 00:38:03,599
line and the success rate that we are

1040
00:38:03,599 --> 00:38:06,000
discussing here is still within a few

1041
00:38:06,000 --> 00:38:07,920
minutes so this means that with one

1042
00:38:07,920 --> 00:38:10,800
single glitch we are able to bypass your

1043
00:38:10,800 --> 00:38:12,800
boot and flash encryption by reaching

1044
00:38:12,800 --> 00:38:14,240
something else

1045
00:38:14,240 --> 00:38:16,000
that allows us to re-bypass this

1046
00:38:16,000 --> 00:38:17,599
yearbood and to read the plain text

1047
00:38:17,599 --> 00:38:18,480
firmware

1048
00:38:18,480 --> 00:38:20,560
so maybe when you want to bypass a jury

1049
00:38:20,560 --> 00:38:21,680
feature you don't need to target the

1050
00:38:21,680 --> 00:38:23,760
security feature so this is something

1051
00:38:23,760 --> 00:38:24,480
that

1052
00:38:24,480 --> 00:38:27,040
actually invites people to think along

1053
00:38:27,040 --> 00:38:29,280
the attack and the design

1054
00:38:29,280 --> 00:38:31,119
i would like to show you

1055
00:38:31,119 --> 00:38:33,839
because i know that i'm pretty running

1056
00:38:33,839 --> 00:38:35,760
out of time but i promise that it will

1057
00:38:35,760 --> 00:38:37,599
be quick

1058
00:38:37,599 --> 00:38:38,720
and

1059
00:38:38,720 --> 00:38:41,440
let's do that so nick is actually doing

1060
00:38:41,440 --> 00:38:42,640
this

1061
00:38:42,640 --> 00:38:44,720
he well i actually say hi to you

1062
00:38:44,720 --> 00:38:48,240
everybody and basically

1063
00:38:48,240 --> 00:38:50,640
we are going to show the demo right now

1064
00:38:50,640 --> 00:38:52,079
first we need to check if jtag is

1065
00:38:52,079 --> 00:38:54,079
actually really closed

1066
00:38:54,079 --> 00:38:55,920
and the first what do what do we do we

1067
00:38:55,920 --> 00:38:58,000
actually connect openocd and see if we

1068
00:38:58,000 --> 00:39:00,160
have any response from the tab which we

1069
00:39:00,160 --> 00:39:02,160
don't have so this means that the

1070
00:39:02,160 --> 00:39:04,640
actually is actually closed because this

1071
00:39:04,640 --> 00:39:06,800
chip has been a program which the jtag

1072
00:39:06,800 --> 00:39:08,320
disable fuse

1073
00:39:08,320 --> 00:39:10,240
so let's close it so we start glitching

1074
00:39:10,240 --> 00:39:13,520
i will start to show you a few things so

1075
00:39:13,520 --> 00:39:15,520
this is the output that we get as soon

1076
00:39:15,520 --> 00:39:18,400
as we get a successful glitch we stop

1077
00:39:18,400 --> 00:39:20,880
as soon as we stop we just check and

1078
00:39:20,880 --> 00:39:23,200
connect with the jdug interface and see

1079
00:39:23,200 --> 00:39:25,440
if you can read plain text firmware now

1080
00:39:25,440 --> 00:39:27,680
to make this a bit faster

1081
00:39:27,680 --> 00:39:32,240
let me go back because i know what it is

1082
00:39:32,240 --> 00:39:34,000
so

1083
00:39:34,000 --> 00:39:36,079
and there you go there is one glitch

1084
00:39:36,079 --> 00:39:38,560
which is red the experiment stopped

1085
00:39:38,560 --> 00:39:40,079
basically that's what we implemented in

1086
00:39:40,079 --> 00:39:41,599
the logic

1087
00:39:41,599 --> 00:39:42,880
and

1088
00:39:42,880 --> 00:39:46,880
yeah let's see and verify

1089
00:39:46,960 --> 00:39:48,720
we need to know first if it's really

1090
00:39:48,720 --> 00:39:51,599
open so the tab should connect now

1091
00:39:51,599 --> 00:39:53,839
which actually it does

1092
00:39:53,839 --> 00:39:55,920
and the second part is that we need to

1093
00:39:55,920 --> 00:39:56,800
read

1094
00:39:56,800 --> 00:39:59,440
flash the flash is now memory mapped at

1095
00:39:59,440 --> 00:40:02,320
a specific address basically which is

1096
00:40:02,320 --> 00:40:05,320
3f4000

1097
00:40:06,160 --> 00:40:08,800
now we connect to openocd so this is i

1098
00:40:08,800 --> 00:40:10,800
mean usual stuff

1099
00:40:10,800 --> 00:40:12,720
when we stop the chip

1100
00:40:12,720 --> 00:40:16,240
and we try to read the the memory

1101
00:40:16,240 --> 00:40:19,200
uh from that their address

1102
00:40:19,200 --> 00:40:21,280
we actually read a bit after because at

1103
00:40:21,280 --> 00:40:22,880
first there is header and so on this is

1104
00:40:22,880 --> 00:40:24,960
where the app is and you see that this

1105
00:40:24,960 --> 00:40:28,000
is a fully in in plain text so while the

1106
00:40:28,000 --> 00:40:30,800
flash encryption is enabled so basically

1107
00:40:30,800 --> 00:40:32,880
uh let me stop this and going back to

1108
00:40:32,880 --> 00:40:33,839
the

1109
00:40:33,839 --> 00:40:36,079
to the presentation because i mean i

1110
00:40:36,079 --> 00:40:38,400
would like to continue

1111
00:40:38,400 --> 00:40:41,280
so what we did here

1112
00:40:41,280 --> 00:40:43,599
is that this actually was in plain text

1113
00:40:43,599 --> 00:40:45,839
while it should have been encrypted

1114
00:40:45,839 --> 00:40:49,200
and what can we do in order to fix this

1115
00:40:49,200 --> 00:40:51,040
well i mean we use firm for describing

1116
00:40:51,040 --> 00:40:54,720
the attack we use the equipment emfi we

1117
00:40:54,720 --> 00:40:56,880
flip data bit and we target otp by

1118
00:40:56,880 --> 00:40:57,920
timing

1119
00:40:57,920 --> 00:40:59,760
and we use this uh

1120
00:40:59,760 --> 00:41:01,839
this framework for this describing fair

1121
00:41:01,839 --> 00:41:04,240
attack if there are more on our website

1122
00:41:04,240 --> 00:41:05,920
but we also use this for a counter

1123
00:41:05,920 --> 00:41:07,359
measure because it depending where you

1124
00:41:07,359 --> 00:41:09,920
apply the countermeasure you can

1125
00:41:09,920 --> 00:41:12,160
prevent we inject you can detect your

1126
00:41:12,160 --> 00:41:14,800
glitch you can detect your fault you can

1127
00:41:14,800 --> 00:41:17,680
prevent your exploit your kill your goal

1128
00:41:17,680 --> 00:41:19,280
so there are many things which can

1129
00:41:19,280 --> 00:41:20,400
actually apply

1130
00:41:20,400 --> 00:41:22,880
at a different point in time for example

1131
00:41:22,880 --> 00:41:25,119
if you want to prevent the injection you

1132
00:41:25,119 --> 00:41:28,000
use em shield or clock glitching you

1133
00:41:28,000 --> 00:41:30,319
need internal clocks i mean uh the

1134
00:41:30,319 --> 00:41:32,720
pegasus allowed to

1135
00:41:32,720 --> 00:41:34,960
open so packaging package may help you

1136
00:41:34,960 --> 00:41:36,400
guess the mfi

1137
00:41:36,400 --> 00:41:38,720
and these are there are things the

1138
00:41:38,720 --> 00:41:40,960
interesting part is that maybe

1139
00:41:40,960 --> 00:41:44,240
we need bus error level detection

1140
00:41:44,240 --> 00:41:46,640
bus level error detection check some do

1141
00:41:46,640 --> 00:41:48,640
a multiple transfer so there are a few

1142
00:41:48,640 --> 00:41:51,200
counter measure which can can happen

1143
00:41:51,200 --> 00:41:53,200
so in a nutshell we have seen how the

1144
00:41:53,200 --> 00:41:55,040
otp transfer can actually completely

1145
00:41:55,040 --> 00:41:57,440
compromise socks unity default injection

1146
00:41:57,440 --> 00:41:59,680
attack here is against the pure hardware

1147
00:41:59,680 --> 00:42:01,359
implementation there is no software

1148
00:42:01,359 --> 00:42:02,640
involved here

1149
00:42:02,640 --> 00:42:05,119
and we actually bypass stock security

1150
00:42:05,119 --> 00:42:07,359
feature before any software is executed

1151
00:42:07,359 --> 00:42:10,079
and before actually any cpu is released

1152
00:42:10,079 --> 00:42:11,359
from reset

1153
00:42:11,359 --> 00:42:12,960
we also found out there is strong timing

1154
00:42:12,960 --> 00:42:16,880
correlation between otp data and uh and

1155
00:42:16,880 --> 00:42:20,640
which allows to uh for powerful attacks

1156
00:42:20,640 --> 00:42:23,040
we broke the reproduction basically we

1157
00:42:23,040 --> 00:42:25,119
do a debug reach for breaking the your

1158
00:42:25,119 --> 00:42:27,760
boots in addition and we actually

1159
00:42:27,760 --> 00:42:29,920
bypassed flash encryption secure boots

1160
00:42:29,920 --> 00:42:31,359
by targeting something completely

1161
00:42:31,359 --> 00:42:34,319
different which is the jdeck so

1162
00:42:34,319 --> 00:42:35,839
in a nutshell

1163
00:42:35,839 --> 00:42:37,839
basically we think that this kind of

1164
00:42:37,839 --> 00:42:39,920
attacks are often overlooked i mean

1165
00:42:39,920 --> 00:42:41,520
fault injection are usually applied in

1166
00:42:41,520 --> 00:42:43,520
the software execution software the

1167
00:42:43,520 --> 00:42:45,200
point is that immutability at rest does

1168
00:42:45,200 --> 00:42:47,119
not imply integrity in transfer these

1169
00:42:47,119 --> 00:42:49,119
are completely different things

1170
00:42:49,119 --> 00:42:50,720
the design may not include airway

1171
00:42:50,720 --> 00:42:52,640
protection nowadays

1172
00:42:52,640 --> 00:42:54,560
because f5 is almost

1173
00:42:54,560 --> 00:42:57,119
always in use for targeting software but

1174
00:42:57,119 --> 00:42:58,880
we think that design level mitigation

1175
00:42:58,880 --> 00:43:00,480
are possible

1176
00:43:00,480 --> 00:43:02,400
i'm sorry if it took a bit a few minutes

1177
00:43:02,400 --> 00:43:04,400
more but hope it's very interesting and

1178
00:43:04,400 --> 00:43:07,119
i'm available for

1179
00:43:10,839 --> 00:43:14,160
questions okay we need to be a bit quick

1180
00:43:14,160 --> 00:43:16,319
so yeah okay

1181
00:43:16,319 --> 00:43:17,680
okay thank you very much for your

1182
00:43:17,680 --> 00:43:19,920
presentation it's very interesting

1183
00:43:19,920 --> 00:43:23,119
uh i think in 2020 espresso announced

1184
00:43:23,119 --> 00:43:25,520
the esp32 v3

1185
00:43:25,520 --> 00:43:27,680
the eco version

1186
00:43:27,680 --> 00:43:29,839
i don't know if you tried to

1187
00:43:29,839 --> 00:43:30,720
to

1188
00:43:30,720 --> 00:43:34,000
not yet not yet okay

1189
00:43:34,000 --> 00:43:37,440
okay thank you you're welcome

1190
00:43:38,000 --> 00:43:40,400
since this otp data is being transferred

1191
00:43:40,400 --> 00:43:42,880
over the bus uh how how how hard will it

1192
00:43:42,880 --> 00:43:44,319
be for somebody to

1193
00:43:44,319 --> 00:43:46,640
read the keys by probing just the buses

1194
00:43:46,640 --> 00:43:49,280
oh i think that's uh it can be done i

1195
00:43:49,280 --> 00:43:51,119
mean we expect that some buses

1196
00:43:51,119 --> 00:43:53,599
especially is not uh

1197
00:43:53,599 --> 00:43:55,839
really that fast and but i think that's

1198
00:43:55,839 --> 00:43:57,760
probably olivia is the right person to

1199
00:43:57,760 --> 00:44:00,240
better answer this question but i think

1200
00:44:00,240 --> 00:44:03,119
it could be done in practicing depending

1201
00:44:03,119 --> 00:44:05,520
on let's say cheap play out and all the

1202
00:44:05,520 --> 00:44:07,040
different things that allow you to do

1203
00:44:07,040 --> 00:44:08,880
microprogramming probing so if you can

1204
00:44:08,880 --> 00:44:11,359
do microprobing then for sure you can

1205
00:44:11,359 --> 00:44:13,680
start the key that's more or less the

1206
00:44:13,680 --> 00:44:16,240
the answer

1207
00:44:16,400 --> 00:44:17,440
thank you

1208
00:44:17,440 --> 00:44:18,880
one more quick question

1209
00:44:18,880 --> 00:44:20,839
i'm available for footer question

1210
00:44:20,839 --> 00:44:23,359
anytime yeah i will take the question

1211
00:44:23,359 --> 00:44:24,160
now

1212
00:44:24,160 --> 00:44:25,680
yeah thank you

1213
00:44:25,680 --> 00:44:29,319
thank you once again

