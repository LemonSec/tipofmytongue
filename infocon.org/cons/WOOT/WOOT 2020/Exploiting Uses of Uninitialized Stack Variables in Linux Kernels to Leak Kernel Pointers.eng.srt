1
00:00:08,559 --> 00:00:12,959
hi everyone this is heihancho

2
00:00:10,559 --> 00:00:14,639
i am a phd student of arizona state

3
00:00:12,960 --> 00:00:16,800
university

4
00:00:14,639 --> 00:00:18,720
in this talk i'm going to present how we

5
00:00:16,800 --> 00:00:21,840
can make corner pointers

6
00:00:18,720 --> 00:00:26,000
through uninitialized stack variables

7
00:00:21,840 --> 00:00:26,400
in linux corners stack variables are

8
00:00:26,000 --> 00:00:29,759
called

9
00:00:26,400 --> 00:00:32,719
automatic variables because

10
00:00:29,760 --> 00:00:33,840
those are located and they are located

11
00:00:32,719 --> 00:00:35,920
automatically

12
00:00:33,840 --> 00:00:38,200
when a program enters and leaves the

13
00:00:35,920 --> 00:00:41,360
scope of them

14
00:00:38,200 --> 00:00:44,480
uninitialized automatic variables have

15
00:00:41,360 --> 00:00:47,360
undefined values until they are assigned

16
00:00:44,480 --> 00:00:47,360
valid values

17
00:00:47,840 --> 00:00:51,199
even though we initialize stack

18
00:00:50,079 --> 00:00:54,000
variables

19
00:00:51,199 --> 00:00:55,120
the stand memory allocated for local

20
00:00:54,000 --> 00:00:58,480
variables

21
00:00:55,120 --> 00:01:00,959
can contain undefined values because of

22
00:00:58,480 --> 00:01:04,559
padding bytes inserted in a struct

23
00:01:00,960 --> 00:01:04,559
during the compilation time

24
00:01:04,879 --> 00:01:09,520
if such uninitialized data is copied to

25
00:01:08,159 --> 00:01:11,760
the user space

26
00:01:09,520 --> 00:01:14,158
sensitive corner information can be

27
00:01:11,760 --> 00:01:14,159
leaked

28
00:01:15,040 --> 00:01:18,799
here is an example of a real-world

29
00:01:17,119 --> 00:01:23,600
vulnerability that leaks

30
00:01:18,799 --> 00:01:26,400
4 bytes of corner data to the user space

31
00:01:23,600 --> 00:01:27,839
in this example for padding bytes

32
00:01:26,400 --> 00:01:31,119
inserted to the map

33
00:01:27,840 --> 00:01:34,000
struct caused an information league

34
00:01:31,119 --> 00:01:36,079
when this struct is copied to the user

35
00:01:34,000 --> 00:01:38,720
space

36
00:01:36,079 --> 00:01:40,639
this type of vulnerabilities violates

37
00:01:38,720 --> 00:01:43,759
the basic security principle

38
00:01:40,640 --> 00:01:46,159
of operating system corners

39
00:01:43,759 --> 00:01:47,280
the applications are not permitted by

40
00:01:46,159 --> 00:01:50,640
the processor

41
00:01:47,280 --> 00:01:54,159
to address corner memory for preventing

42
00:01:50,640 --> 00:01:57,520
an application from damaging the corner

43
00:01:54,159 --> 00:02:00,880
also any data inside the corner must not

44
00:01:57,520 --> 00:02:02,880
be copied to applications as well

45
00:02:00,880 --> 00:02:05,679
this fundamental partition of memory

46
00:02:02,880 --> 00:02:09,119
space has contributed to the current

47
00:02:05,680 --> 00:02:11,520
designs of operating system corners

48
00:02:09,119 --> 00:02:13,920
information leaks caused by in

49
00:02:11,520 --> 00:02:17,200
uninitialized state variables

50
00:02:13,920 --> 00:02:20,399
break this principle and

51
00:02:17,200 --> 00:02:23,440
can bring severe security problems if

52
00:02:20,400 --> 00:02:24,800
leaked information is important or can

53
00:02:23,440 --> 00:02:27,760
be used to

54
00:02:24,800 --> 00:02:27,760
attack the corner

55
00:02:28,000 --> 00:02:31,519
unfortunately information leaked

56
00:02:30,239 --> 00:02:33,360
vulnerabilities

57
00:02:31,519 --> 00:02:36,080
are the most prevalent type of

58
00:02:33,360 --> 00:02:38,640
vulnerabilities in linux kernel

59
00:02:36,080 --> 00:02:39,760
within the last two years corner memory

60
00:02:38,640 --> 00:02:41,920
sanitizer

61
00:02:39,760 --> 00:02:43,599
discovered more than a hundred

62
00:02:41,920 --> 00:02:48,640
information leak bugs

63
00:02:43,599 --> 00:02:48,640
by fuzzing usb device drivers only

64
00:02:49,120 --> 00:02:52,800
furthermore many information leaked

65
00:02:51,440 --> 00:02:57,040
vulnerabilities

66
00:02:52,800 --> 00:03:01,120
are commonly believed to be of low risk

67
00:02:57,040 --> 00:03:03,840
as results many uninitialized data users

68
00:03:01,120 --> 00:03:04,879
do not get sufficient attention from

69
00:03:03,840 --> 00:03:08,720
developers

70
00:03:04,879 --> 00:03:11,760
or security researchers some of them

71
00:03:08,720 --> 00:03:14,400
are not assigned any cv entries and

72
00:03:11,760 --> 00:03:15,359
in some cases their corresponding

73
00:03:14,400 --> 00:03:18,319
patches

74
00:03:15,360 --> 00:03:21,120
are not merged into linux corner for a

75
00:03:18,319 --> 00:03:21,119
long time

76
00:03:21,599 --> 00:03:26,959
this table shows the statistics of 87

77
00:03:25,280 --> 00:03:30,840
linux kernel cvs

78
00:03:26,959 --> 00:03:32,400
that are related to uninitialized data

79
00:03:30,840 --> 00:03:35,760
uses

80
00:03:32,400 --> 00:03:36,640
we can see that most of these cves are

81
00:03:35,760 --> 00:03:39,920
stat-based

82
00:03:36,640 --> 00:03:42,000
information leaks however evaluating the

83
00:03:39,920 --> 00:03:45,599
severity of these cves

84
00:03:42,000 --> 00:03:48,879
is extremely difficult because no public

85
00:03:45,599 --> 00:03:51,920
exploit is available for any of them

86
00:03:48,879 --> 00:03:54,720
exploiting these vulnerabilities to

87
00:03:51,920 --> 00:03:55,760
leak sensitive information usually

88
00:03:54,720 --> 00:03:58,319
requires

89
00:03:55,760 --> 00:04:00,560
manual and complicated manipulation of

90
00:03:58,319 --> 00:04:04,319
the kernel layout that is

91
00:04:00,560 --> 00:04:08,239
costly and time consuming another point

92
00:04:04,319 --> 00:04:10,159
is only one cve mentions

93
00:04:08,239 --> 00:04:11,439
about the potential of leaking corner

94
00:04:10,159 --> 00:04:14,480
pointers and

95
00:04:11,439 --> 00:04:16,959
by passing ksrr which

96
00:04:14,480 --> 00:04:18,399
leaves an impression that these

97
00:04:16,959 --> 00:04:21,840
vulnerabilities have

98
00:04:18,399 --> 00:04:21,839
low security impact

99
00:04:22,720 --> 00:04:28,720
in this work we demonstrate the actual

100
00:04:26,280 --> 00:04:31,359
exploitability and severity of

101
00:04:28,720 --> 00:04:34,720
information leak box in linux corners

102
00:04:31,360 --> 00:04:35,680
by proposing a generic and automated

103
00:04:34,720 --> 00:04:38,560
approach

104
00:04:35,680 --> 00:04:40,160
that converts stack-based information

105
00:04:38,560 --> 00:04:43,520
leaks in linux corners

106
00:04:40,160 --> 00:04:45,919
into vulnerabilities that leak corner

107
00:04:43,520 --> 00:04:48,400
pointer values

108
00:04:45,919 --> 00:04:49,120
these vulnerabilities are easier to

109
00:04:48,400 --> 00:04:51,198
exploit

110
00:04:49,120 --> 00:04:53,520
and are more severe than what is

111
00:04:51,199 --> 00:04:57,199
generally believed

112
00:04:53,520 --> 00:04:59,520
specifically we focus on making pointer

113
00:04:57,199 --> 00:05:03,199
values that are pointing to corner

114
00:04:59,520 --> 00:05:05,440
functions or the corner stack

115
00:05:03,199 --> 00:05:06,320
these little corner pointer values can

116
00:05:05,440 --> 00:05:09,680
be used to

117
00:05:06,320 --> 00:05:12,960
bypass common dependent defenses such as

118
00:05:09,680 --> 00:05:14,000
kslr which is an essential step in

119
00:05:12,960 --> 00:05:17,120
modern linux

120
00:05:14,000 --> 00:05:17,120
common exploits

121
00:05:18,639 --> 00:05:22,320
the first challenge to leak corner

122
00:05:21,120 --> 00:05:25,800
pointer values

123
00:05:22,320 --> 00:05:29,039
is identifying the distance to an

124
00:05:25,800 --> 00:05:31,600
uninitialized memory cell from the base

125
00:05:29,039 --> 00:05:34,800
address of the current stack

126
00:05:31,600 --> 00:05:37,440
which we term a league offset

127
00:05:34,800 --> 00:05:38,080
computing the league of set allows us to

128
00:05:37,440 --> 00:05:41,280
find

129
00:05:38,080 --> 00:05:43,758
the exact location where color pointer

130
00:05:41,280 --> 00:05:46,638
values should be stored

131
00:05:43,759 --> 00:05:48,000
we identify the league of set through

132
00:05:46,639 --> 00:05:51,680
applying a technique

133
00:05:48,000 --> 00:05:54,639
called stack footprinting

134
00:05:51,680 --> 00:05:56,560
the next challenge is finding a way to

135
00:05:54,639 --> 00:05:59,840
place corner pointer values

136
00:05:56,560 --> 00:06:00,639
at the specific league of set to achieve

137
00:05:59,840 --> 00:06:04,239
this goal

138
00:06:00,639 --> 00:06:08,160
we propose two techniques with half of

139
00:06:04,240 --> 00:06:10,960
the linux test project we find ciscos

140
00:06:08,160 --> 00:06:11,680
that can be used to store corner pointer

141
00:06:10,960 --> 00:06:15,039
values

142
00:06:11,680 --> 00:06:18,880
at the league of set and

143
00:06:15,039 --> 00:06:20,159
we propose a conus text training

144
00:06:18,880 --> 00:06:22,080
technique

145
00:06:20,160 --> 00:06:24,479
using the extended broccoli packet

146
00:06:22,080 --> 00:06:24,479
filter

147
00:06:24,639 --> 00:06:30,160
on a 64-bit linux corner when a corner

148
00:06:27,680 --> 00:06:32,639
data leak is larger than 8 bytes

149
00:06:30,160 --> 00:06:33,759
we can obtain the values of the whole

150
00:06:32,639 --> 00:06:37,039
pointer

151
00:06:33,759 --> 00:06:38,880
however in many in many vulnerabilities

152
00:06:37,039 --> 00:06:41,919
the size of memory leak is

153
00:06:38,880 --> 00:06:45,600
smaller than 8 bytes so we cannot

154
00:06:41,919 --> 00:06:45,599
obtain a complete pointer value

155
00:06:45,680 --> 00:06:48,800
for handling such small links we reason

156
00:06:48,560 --> 00:06:51,120
a

157
00:06:48,800 --> 00:06:53,759
possible range of the unlinked value

158
00:06:51,120 --> 00:06:56,160
through the guess and check method

159
00:06:53,759 --> 00:06:59,599
by which we can identify the base

160
00:06:56,160 --> 00:06:59,599
address of the corner stack

161
00:07:00,319 --> 00:07:06,720
our proposed approach takes povs that

162
00:07:03,520 --> 00:07:10,880
triggers a stack-based information leak

163
00:07:06,720 --> 00:07:17,680
as input and analyze them to check

164
00:07:10,880 --> 00:07:20,400
the exploitability and generate exploits

165
00:07:17,680 --> 00:07:22,720
to compute the leak of set we use the

166
00:07:20,400 --> 00:07:25,359
stack foot printing technique

167
00:07:22,720 --> 00:07:26,880
first we fill the corner stack with

168
00:07:25,360 --> 00:07:29,840
offset information

169
00:07:26,880 --> 00:07:30,880
to each byte of the stack from the base

170
00:07:29,840 --> 00:07:33,840
address

171
00:07:30,880 --> 00:07:34,159
we store one byte of send information

172
00:07:33,840 --> 00:07:37,198
which

173
00:07:34,160 --> 00:07:40,720
starts from zero to ff in hex

174
00:07:37,199 --> 00:07:44,360
in each byte for every eight bytes

175
00:07:40,720 --> 00:07:47,520
this mechanism allows us to footprint

176
00:07:44,360 --> 00:07:50,000
2024 bytes of the cornerstack

177
00:07:47,520 --> 00:07:50,960
even though we cannot print the entire

178
00:07:50,000 --> 00:07:53,840
kernel stack

179
00:07:50,960 --> 00:07:54,960
2 000 by chart enough to deal with most

180
00:07:53,840 --> 00:07:57,919
system cores

181
00:07:54,960 --> 00:07:58,479
this is because roughly 90 of the system

182
00:07:57,919 --> 00:08:01,520
cost

183
00:07:58,479 --> 00:08:05,199
only use then less than one thousand two

184
00:08:01,520 --> 00:08:08,000
hundred sixty bytes of the stack

185
00:08:05,199 --> 00:08:10,080
we then um trigger an information leak

186
00:08:08,000 --> 00:08:13,360
vulnerability

187
00:08:10,080 --> 00:08:14,878
because the offset information has been

188
00:08:13,360 --> 00:08:18,800
filled into the stack

189
00:08:14,879 --> 00:08:21,840
we can directly check the offset

190
00:08:18,800 --> 00:08:23,919
lastly we compute a league of set by

191
00:08:21,840 --> 00:08:25,280
using the offset information from the

192
00:08:23,919 --> 00:08:28,000
corner

193
00:08:25,280 --> 00:08:28,799
if the offset information copied from

194
00:08:28,000 --> 00:08:31,840
the corner

195
00:08:28,800 --> 00:08:34,399
is 4 as shown in the slide

196
00:08:31,840 --> 00:08:35,679
we need to find the pointer values that

197
00:08:34,399 --> 00:08:41,839
can be stored

198
00:08:35,679 --> 00:08:41,838
at an offset base minus 24.

199
00:08:42,240 --> 00:08:47,839
once the leak offset has been identified

200
00:08:45,519 --> 00:08:49,600
we need to find the system call with

201
00:08:47,839 --> 00:08:52,640
specific arguments

202
00:08:49,600 --> 00:08:54,560
that can store a corner pointer at the

203
00:08:52,640 --> 00:08:58,000
league of sap

204
00:08:54,560 --> 00:09:00,959
to this end we utilize the linux test

205
00:08:58,000 --> 00:09:01,839
project which provides concrete test

206
00:09:00,959 --> 00:09:05,279
cases

207
00:09:01,839 --> 00:09:07,760
for all system course

208
00:09:05,279 --> 00:09:10,000
we supplement three additional steps

209
00:09:07,760 --> 00:09:12,800
onto each cisco test case

210
00:09:10,000 --> 00:09:12,800
in the ftp

211
00:09:14,000 --> 00:09:18,800
first we fill the kernel stack with the

212
00:09:16,000 --> 00:09:18,800
mesh value

213
00:09:18,959 --> 00:09:23,119
next we execute a test case of a system

214
00:09:22,480 --> 00:09:26,320
called

215
00:09:23,120 --> 00:09:29,760
defined in the ltp and we

216
00:09:26,320 --> 00:09:31,680
inspect the corners tag to check if

217
00:09:29,760 --> 00:09:32,959
there are corner pointers that are

218
00:09:31,680 --> 00:09:37,839
pointing either

219
00:09:32,959 --> 00:09:37,839
corner function or corner stack

220
00:09:38,399 --> 00:09:41,519
if there are such corner pointers we

221
00:09:40,720 --> 00:09:45,120
record

222
00:09:41,519 --> 00:09:45,519
the context information which consists

223
00:09:45,120 --> 00:09:48,880
of

224
00:09:45,519 --> 00:09:52,560
stack of set type of a corner pointer

225
00:09:48,880 --> 00:09:55,120
cisco name and arguments

226
00:09:52,560 --> 00:09:56,640
the recorded information is used later

227
00:09:55,120 --> 00:09:59,200
to find the cisco

228
00:09:56,640 --> 00:10:00,560
that can store a corner pointer to the

229
00:09:59,200 --> 00:10:03,920
league of set

230
00:10:00,560 --> 00:10:06,079
therefore once we have lizard we can use

231
00:10:03,920 --> 00:10:07,279
the recorded context information for

232
00:10:06,079 --> 00:10:10,560
finding a cisco

233
00:10:07,279 --> 00:10:10,560
without repeating this

234
00:10:10,800 --> 00:10:15,439
another way to store corner pointer that

235
00:10:13,200 --> 00:10:18,640
are pointing to the corners tag is

236
00:10:15,440 --> 00:10:20,720
use the bpf the bpf

237
00:10:18,640 --> 00:10:22,800
is a virtual machine inside the corner

238
00:10:20,720 --> 00:10:26,079
which was designed to support

239
00:10:22,800 --> 00:10:28,479
for filtering packets requested by user

240
00:10:26,079 --> 00:10:31,920
space applications

241
00:10:28,480 --> 00:10:36,079
users can request to load and run ppf

242
00:10:31,920 --> 00:10:38,560
programs in the corner a bpf program has

243
00:10:36,079 --> 00:10:39,519
its own stack and these studies are

244
00:10:38,560 --> 00:10:43,518
located

245
00:10:39,519 --> 00:10:46,480
inside the cornerstack also a bpf

246
00:10:43,519 --> 00:10:47,680
program can use a register called the

247
00:10:46,480 --> 00:10:50,399
frame pointer

248
00:10:47,680 --> 00:10:51,040
which points to the base address of the

249
00:10:50,399 --> 00:10:54,800
bpf

250
00:10:51,040 --> 00:10:57,839
programs stack so

251
00:10:54,800 --> 00:10:58,640
by crafting the bpf instructions we can

252
00:10:57,839 --> 00:11:01,200
store

253
00:10:58,640 --> 00:11:02,000
the frame pointer value to the stack of

254
00:11:01,200 --> 00:11:05,360
a bpf

255
00:11:02,000 --> 00:11:05,920
program until the stack is full in other

256
00:11:05,360 --> 00:11:08,480
words

257
00:11:05,920 --> 00:11:09,120
we can store an address of the corner

258
00:11:08,480 --> 00:11:14,720
stack

259
00:11:09,120 --> 00:11:17,360
up to 512 bytes inside the corner stack

260
00:11:14,720 --> 00:11:18,480
therefore if we can't leak the frame

261
00:11:17,360 --> 00:11:21,600
pointer value

262
00:11:18,480 --> 00:11:22,399
we can identify the layout of the corner

263
00:11:21,600 --> 00:11:26,720
stack

264
00:11:22,399 --> 00:11:26,720
because we know the base address of it

265
00:11:27,120 --> 00:11:33,360
if an information link vulnerability

266
00:11:30,320 --> 00:11:36,079
leaks eight bytes of data and

267
00:11:33,360 --> 00:11:37,279
we can store a corners tank address at

268
00:11:36,079 --> 00:11:40,800
the league offset

269
00:11:37,279 --> 00:11:44,160
by the tax plane it is possible

270
00:11:40,800 --> 00:11:46,560
to have a complete corner stack address

271
00:11:44,160 --> 00:11:48,399
unfortunately the leak size of many

272
00:11:46,560 --> 00:11:51,199
stack-based information

273
00:11:48,399 --> 00:11:53,279
leaked vulnerabilities is smaller than 8

274
00:11:51,200 --> 00:11:55,519
bytes

275
00:11:53,279 --> 00:11:57,519
because the corners tag is aligned by

276
00:11:55,519 --> 00:12:01,120
the size of a memory page

277
00:11:57,519 --> 00:12:03,040
we need the most important 52-bits of a

278
00:12:01,120 --> 00:12:05,120
corner stack address to get the base

279
00:12:03,040 --> 00:12:08,000
address

280
00:12:05,120 --> 00:12:09,760
to handle this problem we investigated

281
00:12:08,000 --> 00:12:12,880
the static verifier

282
00:12:09,760 --> 00:12:15,439
of the bpf virtual machine to check

283
00:12:12,880 --> 00:12:16,959
if arithmetic operations on the frame

284
00:12:15,440 --> 00:12:19,920
pointer is possible

285
00:12:16,959 --> 00:12:21,199
we found that some arithmetic operations

286
00:12:19,920 --> 00:12:24,719
such as a bit

287
00:12:21,200 --> 00:12:26,800
shift are not possible but only add and

288
00:12:24,720 --> 00:12:29,760
sub operations can be used

289
00:12:26,800 --> 00:12:30,959
with arbitrary immediate values more

290
00:12:29,760 --> 00:12:34,000
importantly

291
00:12:30,959 --> 00:12:36,239
these operations can be executed even if

292
00:12:34,000 --> 00:12:39,920
the legit is beyond the range of

293
00:12:36,240 --> 00:12:43,040
bpf programs stack we also found

294
00:12:39,920 --> 00:12:44,000
that after executing these arithmetic

295
00:12:43,040 --> 00:12:46,560
operations

296
00:12:44,000 --> 00:12:49,200
the modified frame pointer value can be

297
00:12:46,560 --> 00:12:52,239
stored at the corner stack

298
00:12:49,200 --> 00:12:53,120
by leveraging this unrestricted behavior

299
00:12:52,240 --> 00:12:56,560
of a bpa

300
00:12:53,120 --> 00:12:57,040
pro bpf program we deal with such small

301
00:12:56,560 --> 00:12:59,839
links

302
00:12:57,040 --> 00:13:00,560
using the guess and check method for

303
00:12:59,839 --> 00:13:02,880
example

304
00:13:00,560 --> 00:13:03,920
if the value of the frame pointer is the

305
00:13:02,880 --> 00:13:07,279
hex value as

306
00:13:03,920 --> 00:13:11,760
shown in the slide and

307
00:13:07,279 --> 00:13:14,480
if we know only the first four bytes

308
00:13:11,760 --> 00:13:16,240
we can start guessing by subtracting an

309
00:13:14,480 --> 00:13:18,399
arbitrary value

310
00:13:16,240 --> 00:13:19,440
in the given example after the

311
00:13:18,399 --> 00:13:22,320
subtraction

312
00:13:19,440 --> 00:13:22,880
the last byte of known frame pointer

313
00:13:22,320 --> 00:13:26,240
value

314
00:13:22,880 --> 00:13:28,720
changes from 4 to 3. so

315
00:13:26,240 --> 00:13:29,680
we can know that the hidden data is

316
00:13:28,720 --> 00:13:33,120
smaller than

317
00:13:29,680 --> 00:13:35,760
the arbitrary number next

318
00:13:33,120 --> 00:13:36,240
we can subtract another arbitrary number

319
00:13:35,760 --> 00:13:39,439
that is

320
00:13:36,240 --> 00:13:41,199
smaller than the previous one we repeat

321
00:13:39,440 --> 00:13:45,440
this reasoning procedure

322
00:13:41,199 --> 00:13:45,439
until we can obtain the cornerstech base

323
00:13:46,839 --> 00:13:49,839
address

324
00:13:50,399 --> 00:13:56,320
first we evaluated the effectiveness of

325
00:13:53,440 --> 00:14:00,399
our system core testing framework

326
00:13:56,320 --> 00:14:03,839
to this end we randomly modified ltp

327
00:14:00,399 --> 00:14:07,120
on ubuntu 1804. the figure

328
00:14:03,839 --> 00:14:09,519
illustrates that how many contacts can

329
00:14:07,120 --> 00:14:13,000
store sensitive point of values

330
00:14:09,519 --> 00:14:15,040
for each stand memory of stat less than

331
00:14:13,000 --> 00:14:17,040
2298

332
00:14:15,040 --> 00:14:18,560
the experimental leaders also showed

333
00:14:17,040 --> 00:14:21,599
that our modified

334
00:14:18,560 --> 00:14:25,119
ftp framework can find ciscos

335
00:14:21,600 --> 00:14:27,839
to store corner pointer values at almost

336
00:14:25,120 --> 00:14:30,880
every stack of set when offsets are

337
00:14:27,839 --> 00:14:33,120
larger than 440.

338
00:14:30,880 --> 00:14:35,839
record that for each corner we need to

339
00:14:33,120 --> 00:14:38,399
run the ltp framework once

340
00:14:35,839 --> 00:14:40,160
to record the context information then

341
00:14:38,399 --> 00:14:42,320
we can simply pick a context

342
00:14:40,160 --> 00:14:43,839
from the recorded data for storing a

343
00:14:42,320 --> 00:14:47,839
corner pointer value

344
00:14:43,839 --> 00:14:47,839
at the identified league of set

345
00:14:48,000 --> 00:14:54,000
in this work we analyzed four cves

346
00:14:51,199 --> 00:14:56,399
and one security patch that could not

347
00:14:54,000 --> 00:14:59,040
become a cve entry

348
00:14:56,399 --> 00:15:00,079
let's see the first two cves and one

349
00:14:59,040 --> 00:15:03,439
security

350
00:15:00,079 --> 00:15:06,719
one security patch first

351
00:15:03,440 --> 00:15:07,760
we speculate that the impact of these

352
00:15:06,720 --> 00:15:10,639
vulnerabilities

353
00:15:07,760 --> 00:15:11,600
is deemed low because the size of

354
00:15:10,639 --> 00:15:14,639
information league

355
00:15:11,600 --> 00:15:17,920
is only 4 bytes and which are not

356
00:15:14,639 --> 00:15:20,399
enough to host an entire point on 64-bit

357
00:15:17,920 --> 00:15:23,040
linux systems

358
00:15:20,399 --> 00:15:25,040
and in the official common message of

359
00:15:23,040 --> 00:15:28,240
the security patch

360
00:15:25,040 --> 00:15:30,800
a corner developer mentioned that

361
00:15:28,240 --> 00:15:32,079
there should be no danger as the stack

362
00:15:30,800 --> 00:15:34,399
leak guaranteed that

363
00:15:32,079 --> 00:15:36,000
previously meaningless random data was

364
00:15:34,399 --> 00:15:39,279
being returned

365
00:15:36,000 --> 00:15:41,839
however we could bypass ksr after

366
00:15:39,279 --> 00:15:43,920
analyzing it

367
00:15:41,839 --> 00:15:45,040
this ledger demonstrates that the

368
00:15:43,920 --> 00:15:47,839
necessity

369
00:15:45,040 --> 00:15:50,319
of our approach for for providing the

370
00:15:47,839 --> 00:15:54,639
severity of information leak bugs in

371
00:15:50,320 --> 00:16:00,240
linux corners um

372
00:15:54,639 --> 00:16:03,360
with this cve of which cvss score is 2.1

373
00:16:00,240 --> 00:16:04,399
we show that how a forward leak

374
00:16:03,360 --> 00:16:07,920
vulnerability

375
00:16:04,399 --> 00:16:09,519
can be exploited to identify the

376
00:16:07,920 --> 00:16:12,240
cornerstack base

377
00:16:09,519 --> 00:16:12,880
we sprayed the cornerstone using the bpm

378
00:16:12,240 --> 00:16:16,000
program

379
00:16:12,880 --> 00:16:16,639
and we could identify the cornerstek

380
00:16:16,000 --> 00:16:20,160
base

381
00:16:16,639 --> 00:16:23,519
with the guess and chain method

382
00:16:20,160 --> 00:16:26,880
lastly we evaluated one cve

383
00:16:23,519 --> 00:16:30,160
the cvs s core of this vulnerability

384
00:16:26,880 --> 00:16:30,720
is 5.0 which is significantly higher

385
00:16:30,160 --> 00:16:34,000
than

386
00:16:30,720 --> 00:16:36,959
the other cves that we evaluated

387
00:16:34,000 --> 00:16:38,959
interestingly we found that this one

388
00:16:36,959 --> 00:16:40,719
byte league vulnerability cannot be

389
00:16:38,959 --> 00:16:44,079
exploited through

390
00:16:40,720 --> 00:16:46,959
our analysis um

391
00:16:44,079 --> 00:16:47,920
the league of set of this vulnerability

392
00:16:46,959 --> 00:16:50,638
always becomes

393
00:16:47,920 --> 00:16:51,599
zero before the volume function executes

394
00:16:50,639 --> 00:16:54,800
therefore

395
00:16:51,600 --> 00:16:56,800
the vulnerability always leaks 0

396
00:16:54,800 --> 00:16:58,880
even though we can successfully store

397
00:16:56,800 --> 00:17:02,479
the corner pointer

398
00:16:58,880 --> 00:17:05,039
at the league of set in this paper

399
00:17:02,480 --> 00:17:05,760
we proposed a generic approach to

400
00:17:05,039 --> 00:17:08,559
exploit

401
00:17:05,760 --> 00:17:10,000
uses of uninitialized stack data in

402
00:17:08,559 --> 00:17:13,039
linux corners

403
00:17:10,000 --> 00:17:13,919
to link corner pointer values that are

404
00:17:13,039 --> 00:17:16,839
pointing

405
00:17:13,919 --> 00:17:18,480
to either corner functions or corner

406
00:17:16,839 --> 00:17:20,879
stacks

407
00:17:18,480 --> 00:17:21,599
these leaked pointer values can then be

408
00:17:20,880 --> 00:17:25,120
used

409
00:17:21,599 --> 00:17:25,839
to be kslr and mount future attacks

410
00:17:25,119 --> 00:17:30,320
against

411
00:17:25,839 --> 00:17:31,120
linux corners our evaluation legit show

412
00:17:30,320 --> 00:17:33,520
that we can

413
00:17:31,120 --> 00:17:34,320
effectively analyze and exploit

414
00:17:33,520 --> 00:17:36,320
stack-based

415
00:17:34,320 --> 00:17:38,799
information leaked vulnerabilities

416
00:17:36,320 --> 00:17:41,678
through the proposed approach

417
00:17:38,799 --> 00:17:43,120
and we expect our findings will help

418
00:17:41,679 --> 00:17:45,840
adjust cvss

419
00:17:43,120 --> 00:17:48,799
scoring for information leak box inside

420
00:17:45,840 --> 00:17:48,799
the linux corners

421
00:17:49,200 --> 00:18:01,760
thanks for listening

