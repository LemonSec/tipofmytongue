1
00:00:00,560 --> 00:00:03,199
i would suggest we move on to the

2
00:00:03,199 --> 00:00:06,399
um to the next talk on the schedule

3
00:00:06,399 --> 00:00:09,760
and um that would be james talking about

4
00:00:09,760 --> 00:00:12,559
identifying valuable pointers in in heap

5
00:00:12,559 --> 00:00:14,480
data

6
00:00:14,480 --> 00:00:16,400
can you try sharing your screen awesome

7
00:00:16,400 --> 00:00:17,520
all right okay can everyone's

8
00:00:17,520 --> 00:00:20,320
in full screen looks good please take

9
00:00:20,320 --> 00:00:21,760
advantage oh it's gone

10
00:00:21,760 --> 00:00:24,720
oh it's going oh it's back okay great um

11
00:00:24,720 --> 00:00:25,199
okay

12
00:00:25,199 --> 00:00:27,840
cool fingers crossed so hi everyone uh

13
00:00:27,840 --> 00:00:29,519
my name is james roney and the title of

14
00:00:29,519 --> 00:00:31,359
my talk today is identifying valuable

15
00:00:31,359 --> 00:00:32,719
pointers in heap data

16
00:00:32,719 --> 00:00:35,200
this work was done by myself troy pritik

17
00:00:35,200 --> 00:00:36,320
and pratik

18
00:00:36,320 --> 00:00:37,920
with the fantastic guidance and advice

19
00:00:37,920 --> 00:00:40,640
of professor james mikkens

20
00:00:40,640 --> 00:00:42,160
okay so i'm going to start with a high

21
00:00:42,160 --> 00:00:44,320
level overview of my talk

22
00:00:44,320 --> 00:00:46,320
so this talk is broadly concerned with

23
00:00:46,320 --> 00:00:47,760
data oriented attacks

24
00:00:47,760 --> 00:00:49,360
which are simply software exploits that

25
00:00:49,360 --> 00:00:51,120
respect the control flow integrity of a

26
00:00:51,120 --> 00:00:52,640
victim program

27
00:00:52,640 --> 00:00:54,480
and the particular data oriented attack

28
00:00:54,480 --> 00:00:55,680
that we'll be concerned with today is

29
00:00:55,680 --> 00:00:58,160
called memory cartography

30
00:00:58,160 --> 00:01:00,559
and so in a memory cartography attack an

31
00:01:00,559 --> 00:01:02,719
attacker builds up a map of pointers

32
00:01:02,719 --> 00:01:03,359
that connect

33
00:01:03,359 --> 00:01:06,320
different regions of memory keeps stacks

34
00:01:06,320 --> 00:01:08,479
and static data sections

35
00:01:08,479 --> 00:01:11,600
and so with the setup if an attacker has

36
00:01:11,600 --> 00:01:13,119
a read vulnerability in one of these

37
00:01:13,119 --> 00:01:14,080
memory regions

38
00:01:14,080 --> 00:01:15,600
they can sort of follow this network of

39
00:01:15,600 --> 00:01:17,759
pointers between regions to leak data

40
00:01:17,759 --> 00:01:19,520
from the program's entire address space

41
00:01:19,520 --> 00:01:22,880
without triggering a segmentation fault

42
00:01:22,880 --> 00:01:25,520
and this is really useful however for

43
00:01:25,520 --> 00:01:26,640
this technique to work

44
00:01:26,640 --> 00:01:28,400
these pointers need to be located at

45
00:01:28,400 --> 00:01:30,000
constant offsets within each memory

46
00:01:30,000 --> 00:01:31,680
region so the attacker knows where to

47
00:01:31,680 --> 00:01:34,079
find them at attack time

48
00:01:34,079 --> 00:01:35,920
and this can pose a problem since

49
00:01:35,920 --> 00:01:37,840
regions like heaps and stacks often have

50
00:01:37,840 --> 00:01:39,759
non-deterministic layouts

51
00:01:39,759 --> 00:01:41,759
in this paper we'll show how an attacker

52
00:01:41,759 --> 00:01:43,439
can recognize pointers to specific

53
00:01:43,439 --> 00:01:45,040
destinations by looking for

54
00:01:45,040 --> 00:01:47,280
particular signatures in memory and this

55
00:01:47,280 --> 00:01:49,119
is going to allow for memory cartography

56
00:01:49,119 --> 00:01:50,320
approaches to work

57
00:01:50,320 --> 00:01:53,840
even in non-deterministic memory regions

58
00:01:53,840 --> 00:01:57,119
okay so with that uh here are the main

59
00:01:57,119 --> 00:01:58,479
sections of the talk

60
00:01:58,479 --> 00:01:59,840
and we'll begin by discussing data

61
00:01:59,840 --> 00:02:02,399
oriented attacks in more detail

62
00:02:02,399 --> 00:02:05,280
um okay so a lot of classic attacks

63
00:02:05,280 --> 00:02:06,960
involve using a memory bug to subvert

64
00:02:06,960 --> 00:02:09,119
the control flow of a victim program

65
00:02:09,119 --> 00:02:10,639
so for example here we have the control

66
00:02:10,639 --> 00:02:12,400
flow graph of a simple program

67
00:02:12,400 --> 00:02:14,160
that's going to authenticate a user over

68
00:02:14,160 --> 00:02:16,080
a network by reading a packet containing

69
00:02:16,080 --> 00:02:17,440
a password

70
00:02:17,440 --> 00:02:19,040
and so in a classic buffer overflow

71
00:02:19,040 --> 00:02:20,800
attack a malicious actor might use this

72
00:02:20,800 --> 00:02:22,239
password buffer here

73
00:02:22,239 --> 00:02:24,000
to overwrite a return address and open a

74
00:02:24,000 --> 00:02:25,360
shell

75
00:02:25,360 --> 00:02:27,680
and so this attack is going to involve a

76
00:02:27,680 --> 00:02:29,280
jump that isn't present in the normal

77
00:02:29,280 --> 00:02:30,959
control flow graph as you can see from

78
00:02:30,959 --> 00:02:33,040
this extra edge here

79
00:02:33,040 --> 00:02:36,080
and while that's great what's going to

80
00:02:36,080 --> 00:02:37,760
end up happening is this control flow

81
00:02:37,760 --> 00:02:39,360
violation is going to make this attack a

82
00:02:39,360 --> 00:02:40,560
lot more difficult when modern

83
00:02:40,560 --> 00:02:41,920
mitigations are present

84
00:02:41,920 --> 00:02:43,280
for example safeguards like stat

85
00:02:43,280 --> 00:02:44,720
canaries are going to detect this kind

86
00:02:44,720 --> 00:02:46,480
of control flow violation and stop it

87
00:02:46,480 --> 00:02:47,840
from happening

88
00:02:47,840 --> 00:02:51,040
um so in contrast in a data oriented

89
00:02:51,040 --> 00:02:51,840
attack

90
00:02:51,840 --> 00:02:54,319
uh instead of overwriting a return

91
00:02:54,319 --> 00:02:55,760
address the attacker can use this

92
00:02:55,760 --> 00:02:57,519
vulnerable buffer to instead overwrite

93
00:02:57,519 --> 00:02:59,519
this authentication flag

94
00:02:59,519 --> 00:03:00,959
and so this isn't going to violate the

95
00:03:00,959 --> 00:03:02,319
legitimate control flow graph of the

96
00:03:02,319 --> 00:03:03,360
program in any way

97
00:03:03,360 --> 00:03:04,879
so it won't trigger a lot of those same

98
00:03:04,879 --> 00:03:07,040
modern defenses however it's still going

99
00:03:07,040 --> 00:03:08,319
to let the attacker manipulate the

100
00:03:08,319 --> 00:03:09,599
behavior of the program

101
00:03:09,599 --> 00:03:11,360
in this case by sort of pretending to be

102
00:03:11,360 --> 00:03:12,720
authenticated despite

103
00:03:12,720 --> 00:03:16,319
never having provided a valid password

104
00:03:16,319 --> 00:03:18,000
okay um so with that simple example we

105
00:03:18,000 --> 00:03:19,360
can move on and talk about a particular

106
00:03:19,360 --> 00:03:20,879
data-oriented attack called memory

107
00:03:20,879 --> 00:03:22,640
cartography

108
00:03:22,640 --> 00:03:24,640
um so memory cartography was first

109
00:03:24,640 --> 00:03:26,799
reduced by rogowski and collaborators a

110
00:03:26,799 --> 00:03:27,760
few years ago

111
00:03:27,760 --> 00:03:29,440
and the basic setup is that an attacker

112
00:03:29,440 --> 00:03:31,040
has a vulnerability that lets them read

113
00:03:31,040 --> 00:03:32,560
arbitrary bytes from some region of

114
00:03:32,560 --> 00:03:33,440
memory

115
00:03:33,440 --> 00:03:34,959
and they want to read from the entire

116
00:03:34,959 --> 00:03:36,319
address space of the victim program

117
00:03:36,319 --> 00:03:37,120
without triggering a

118
00:03:37,120 --> 00:03:39,120
segmentation fault and this is a hard

119
00:03:39,120 --> 00:03:40,720
problem because the address space of a

120
00:03:40,720 --> 00:03:41,840
complicated program is going to be

121
00:03:41,840 --> 00:03:43,200
fragmented into a bunch of different

122
00:03:43,200 --> 00:03:44,000
allocations

123
00:03:44,000 --> 00:03:46,000
with unallocated areas in between so

124
00:03:46,000 --> 00:03:47,599
even if the attacker has an

125
00:03:47,599 --> 00:03:49,280
arbitrary read vulnerability they have

126
00:03:49,280 --> 00:03:50,799
to be careful not to read from

127
00:03:50,799 --> 00:03:53,040
unallocated areas and crash the entire

128
00:03:53,040 --> 00:03:54,319
program

129
00:03:54,319 --> 00:03:56,319
uh so this attack is designed to work

130
00:03:56,319 --> 00:03:57,920
with modern control when modern control

131
00:03:57,920 --> 00:03:59,840
flow guards like aslr

132
00:03:59,840 --> 00:04:01,920
data execution prevention etc are

133
00:04:01,920 --> 00:04:03,040
enabled

134
00:04:03,040 --> 00:04:04,640
and crucially these memory cartography

135
00:04:04,640 --> 00:04:05,680
attacks are going to depend on the

136
00:04:05,680 --> 00:04:07,360
attacker being able to run the victim

137
00:04:07,360 --> 00:04:08,239
program locally

138
00:04:08,239 --> 00:04:09,840
so for instance knows they're exploding

139
00:04:09,840 --> 00:04:11,680
firefox and they can do some

140
00:04:11,680 --> 00:04:14,400
local analysis of moving to the attack

141
00:04:14,400 --> 00:04:15,120
time

142
00:04:15,120 --> 00:04:18,160
exploit um so to get a better idea of

143
00:04:18,160 --> 00:04:19,600
how memory cryptography works

144
00:04:19,600 --> 00:04:20,880
we'll consider a simple example

145
00:04:20,880 --> 00:04:23,040
involving a web browser

146
00:04:23,040 --> 00:04:25,040
so browser has a bunch of different

147
00:04:25,040 --> 00:04:27,759
memory regions pertaining to things like

148
00:04:27,759 --> 00:04:30,639
javascript engines html parsers and sort

149
00:04:30,639 --> 00:04:33,520
of the renderer code and data itself

150
00:04:33,520 --> 00:04:35,600
and in a realistic scenario an attacker

151
00:04:35,600 --> 00:04:37,280
might be able to read arbitrary

152
00:04:37,280 --> 00:04:39,280
addresses by specifying an offset from

153
00:04:39,280 --> 00:04:40,479
some vulnerable

154
00:04:40,479 --> 00:04:42,960
object within the javascript engine heap

155
00:04:42,960 --> 00:04:44,560
however the attacker might want to steal

156
00:04:44,560 --> 00:04:46,639
cookies from this dom renderer heap

157
00:04:46,639 --> 00:04:48,560
which is in a different memory region

158
00:04:48,560 --> 00:04:50,080
and so the attacker can't simply just

159
00:04:50,080 --> 00:04:51,520
keep scanning the

160
00:04:51,520 --> 00:04:52,880
the address space until they find a

161
00:04:52,880 --> 00:04:54,240
cookie because eventually they're going

162
00:04:54,240 --> 00:04:55,040
to sort of

163
00:04:55,040 --> 00:04:56,560
go outside of one of these allocated

164
00:04:56,560 --> 00:04:58,880
regions and trigger a segmentation fault

165
00:04:58,880 --> 00:05:00,000
so the attacker is going to have to

166
00:05:00,000 --> 00:05:02,400
figure out a way around this somehow

167
00:05:02,400 --> 00:05:04,639
in a memory cartography attack the

168
00:05:04,639 --> 00:05:06,000
attacker is going to solve this problem

169
00:05:06,000 --> 00:05:08,320
by building a map of pointers between

170
00:05:08,320 --> 00:05:10,720
different memory regions and so to build

171
00:05:10,720 --> 00:05:12,160
this map of pointers the attacker is

172
00:05:12,160 --> 00:05:14,000
going to run the binary locally

173
00:05:14,000 --> 00:05:15,759
and scan the static data sections for

174
00:05:15,759 --> 00:05:17,600
pointers that connect different regions

175
00:05:17,600 --> 00:05:19,360
and so the memory scan locally can be

176
00:05:19,360 --> 00:05:21,280
done using a tool like gdb or something

177
00:05:21,280 --> 00:05:22,320
like that

178
00:05:22,320 --> 00:05:24,560
and so each pointer that the attacker is

179
00:05:24,560 --> 00:05:25,440
going to find

180
00:05:25,440 --> 00:05:27,759
is basically just um a reference in one

181
00:05:27,759 --> 00:05:29,199
of these memory regions it's going to

182
00:05:29,199 --> 00:05:30,720
connect to a different memory region so

183
00:05:30,720 --> 00:05:32,080
each pointer connects

184
00:05:32,080 --> 00:05:34,160
an offset in a source region with an

185
00:05:34,160 --> 00:05:36,560
offset and a destination region

186
00:05:36,560 --> 00:05:38,400
and so when the attacker does this

187
00:05:38,400 --> 00:05:39,600
locally they're going to look

188
00:05:39,600 --> 00:05:41,840
specifically at static data sections

189
00:05:41,840 --> 00:05:43,440
and the reason static data sections are

190
00:05:43,440 --> 00:05:45,039
going to be the focus of this attack

191
00:05:45,039 --> 00:05:47,039
is because um static data sections are

192
00:05:47,039 --> 00:05:48,720
going to have a deterministic layout

193
00:05:48,720 --> 00:05:50,800
so if the attacker sees a pointer

194
00:05:50,800 --> 00:05:53,199
linking offset 64 in this javascript

195
00:05:53,199 --> 00:05:53,680
section

196
00:05:53,680 --> 00:05:56,319
with offset 32 in this html section uh

197
00:05:56,319 --> 00:05:57,919
they can become

198
00:05:57,919 --> 00:05:59,280
that pointer is going to be they're

199
00:05:59,280 --> 00:06:01,280
linking those sets every time

200
00:06:01,280 --> 00:06:02,720
including when they move to the attack

201
00:06:02,720 --> 00:06:04,560
time um and the reason that that's going

202
00:06:04,560 --> 00:06:06,400
to happen is because like i said

203
00:06:06,400 --> 00:06:07,759
static data sections have this

204
00:06:07,759 --> 00:06:10,560
deterministic layout

205
00:06:10,560 --> 00:06:13,360
preserves relative offsets between

206
00:06:13,360 --> 00:06:15,360
pointers even if the global offsets of

207
00:06:15,360 --> 00:06:18,479
each section are changing between loads

208
00:06:18,479 --> 00:06:20,240
however there's still one more problem

209
00:06:20,240 --> 00:06:21,520
which is that some of these pointers

210
00:06:21,520 --> 00:06:23,199
might simply be pointer sized regions

211
00:06:23,199 --> 00:06:24,960
that happen to look like pointers to

212
00:06:24,960 --> 00:06:26,400
external memory regions

213
00:06:26,400 --> 00:06:28,479
for example a static data section might

214
00:06:28,479 --> 00:06:30,240
contain a constant string

215
00:06:30,240 --> 00:06:32,160
and that string for some aslr loads of

216
00:06:32,160 --> 00:06:33,600
the program happens to look like a

217
00:06:33,600 --> 00:06:34,000
pointer

218
00:06:34,000 --> 00:06:36,240
somewhere else so to filter out those

219
00:06:36,240 --> 00:06:37,680
false pointers the attacker can just

220
00:06:37,680 --> 00:06:39,199
repeat this procedure from multiple

221
00:06:39,199 --> 00:06:40,639
independent program loads

222
00:06:40,639 --> 00:06:42,240
and look for links that are consistently

223
00:06:42,240 --> 00:06:43,759
present so if

224
00:06:43,759 --> 00:06:45,600
over multiple program loads we still see

225
00:06:45,600 --> 00:06:47,600
this pointer connecting offset 64 in the

226
00:06:47,600 --> 00:06:49,440
java section in the javascript data

227
00:06:49,440 --> 00:06:49,919
section

228
00:06:49,919 --> 00:06:52,160
and offset 32 in the html data section

229
00:06:52,160 --> 00:06:53,520
we can be confident that's a real

230
00:06:53,520 --> 00:06:54,880
pointer and it's going to be there at

231
00:06:54,880 --> 00:06:56,400
attack time

232
00:06:56,400 --> 00:06:58,960
so by doing this we can filter out the

233
00:06:58,960 --> 00:06:59,840
bad pointers

234
00:06:59,840 --> 00:07:02,880
and we're left with a reliable map of

235
00:07:02,880 --> 00:07:04,400
pointers connecting different data

236
00:07:04,400 --> 00:07:05,599
sections

237
00:07:05,599 --> 00:07:06,960
and this results in the ability to

238
00:07:06,960 --> 00:07:08,400
navigate through those data sections and

239
00:07:08,400 --> 00:07:10,160
eventually reach a target heap which in

240
00:07:10,160 --> 00:07:11,440
this case is this dom render

241
00:07:11,440 --> 00:07:13,680
heap now this last pointer in the chain

242
00:07:13,680 --> 00:07:15,680
might end up at a non-deterministic

243
00:07:15,680 --> 00:07:17,039
offset within that heap because the

244
00:07:17,039 --> 00:07:18,960
heaps don't have a fixed memory layout

245
00:07:18,960 --> 00:07:20,479
and that's okay because the attacker can

246
00:07:20,479 --> 00:07:22,000
just sort of scan the neighborhood

247
00:07:22,000 --> 00:07:24,000
around that final pointer

248
00:07:24,000 --> 00:07:25,440
until they find something sensitive like

249
00:07:25,440 --> 00:07:27,360
a cookie

250
00:07:27,360 --> 00:07:30,400
so this is all well and good uh however

251
00:07:30,400 --> 00:07:31,919
one thing that we haven't talked about

252
00:07:31,919 --> 00:07:34,160
is how we actually get to this java

253
00:07:34,160 --> 00:07:34,800
section

254
00:07:34,800 --> 00:07:36,800
javascript data section to begin with or

255
00:07:36,800 --> 00:07:38,319
any uh or one of these other data

256
00:07:38,319 --> 00:07:39,759
sections

257
00:07:39,759 --> 00:07:41,120
and basically because our vulnerable

258
00:07:41,120 --> 00:07:43,280
object is in the heap we somehow need to

259
00:07:43,280 --> 00:07:44,000
find a way to

260
00:07:44,000 --> 00:07:46,319
jump from the heap to this first data

261
00:07:46,319 --> 00:07:47,599
section

262
00:07:47,599 --> 00:07:49,360
and that's a not a trivial problem

263
00:07:49,360 --> 00:07:51,120
because offsets of pointers within the

264
00:07:51,120 --> 00:07:52,479
javascript heap are not going to be

265
00:07:52,479 --> 00:07:54,319
consistent across runs because the heap

266
00:07:54,319 --> 00:07:55,280
is subject to all sorts of

267
00:07:55,280 --> 00:07:57,520
non-determinism

268
00:07:57,520 --> 00:07:59,599
so the original memory cartography paper

269
00:07:59,599 --> 00:08:00,960
of rogowski

270
00:08:00,960 --> 00:08:02,400
they accomplished this by doing a heap

271
00:08:02,400 --> 00:08:04,479
spray of easily recognizable objects

272
00:08:04,479 --> 00:08:05,599
that contained a

273
00:08:05,599 --> 00:08:07,759
known data section pointer so they could

274
00:08:07,759 --> 00:08:09,520
simply read bites off the heap and look

275
00:08:09,520 --> 00:08:11,599
for one of these recognizable objects

276
00:08:11,599 --> 00:08:13,759
find a pointer follow it and end up in a

277
00:08:13,759 --> 00:08:16,000
known offset in a data section and from

278
00:08:16,000 --> 00:08:17,120
there they could continue doing the

279
00:08:17,120 --> 00:08:18,560
memory cartography

280
00:08:18,560 --> 00:08:20,160
however this approach might not be

281
00:08:20,160 --> 00:08:21,759
viable for all applications where the

282
00:08:21,759 --> 00:08:23,199
attacker can't

283
00:08:23,199 --> 00:08:25,360
control what objects are being allocated

284
00:08:25,360 --> 00:08:27,360
on the heap

285
00:08:27,360 --> 00:08:28,479
so that's going to bring us to our

286
00:08:28,479 --> 00:08:30,080
original contribution which is a method

287
00:08:30,080 --> 00:08:31,759
to discover pointers to data sections

288
00:08:31,759 --> 00:08:33,440
within non-deterministic memory regions

289
00:08:33,440 --> 00:08:34,320
like heaps

290
00:08:34,320 --> 00:08:35,360
and this is going to allow for these

291
00:08:35,360 --> 00:08:36,958
types of memory cartography attacks to

292
00:08:36,958 --> 00:08:37,360
work

293
00:08:37,360 --> 00:08:38,799
without any sort of heap spray or

294
00:08:38,799 --> 00:08:41,760
manipulation of the heap

295
00:08:41,760 --> 00:08:44,080
okay so to get a bit more formal we're

296
00:08:44,080 --> 00:08:45,680
going to consider a scenario where the

297
00:08:45,680 --> 00:08:47,360
attacker has a local heat preed and

298
00:08:47,360 --> 00:08:49,760
wants to return the entire address space

299
00:08:49,760 --> 00:08:51,760
however unlike the original memory

300
00:08:51,760 --> 00:08:53,519
photography setup this attacker has no

301
00:08:53,519 --> 00:08:55,519
influence over the contents of the heap

302
00:08:55,519 --> 00:08:57,120
so to find a pointer to another region

303
00:08:57,120 --> 00:08:58,480
the attacker is going to have to scan

304
00:08:58,480 --> 00:08:59,920
the heap at attack time and

305
00:08:59,920 --> 00:09:02,640
recognize the pointer somehow and like

306
00:09:02,640 --> 00:09:04,000
in the original setup we're going to

307
00:09:04,000 --> 00:09:05,440
assume that modern control flow guards

308
00:09:05,440 --> 00:09:06,959
like aslr are enabled

309
00:09:06,959 --> 00:09:08,160
and that the attacker is going to be

310
00:09:08,160 --> 00:09:11,200
able to run the program locally

311
00:09:11,200 --> 00:09:13,360
so here's a high level overview of the

312
00:09:13,360 --> 00:09:15,519
method that we're proposing

313
00:09:15,519 --> 00:09:17,600
so first the attacker is going to run

314
00:09:17,600 --> 00:09:20,000
the look program locally several times

315
00:09:20,000 --> 00:09:21,839
and identify specific destinations

316
00:09:21,839 --> 00:09:23,440
within data sections that are

317
00:09:23,440 --> 00:09:25,279
pointed too often by pointers on the

318
00:09:25,279 --> 00:09:27,519
heat

319
00:09:27,600 --> 00:09:28,880
then they're going to look at the

320
00:09:28,880 --> 00:09:30,480
pointers that reference those frequently

321
00:09:30,480 --> 00:09:31,839
referenced destinations

322
00:09:31,839 --> 00:09:33,600
and look at the bytes surrounding those

323
00:09:33,600 --> 00:09:34,959
pointers of interest and use them to

324
00:09:34,959 --> 00:09:37,519
compile a signature

325
00:09:37,519 --> 00:09:39,200
then the attack time the attacker is

326
00:09:39,200 --> 00:09:40,880
going to scan the heap using their local

327
00:09:40,880 --> 00:09:41,839
heap read

328
00:09:41,839 --> 00:09:43,360
and match bytes to the pre-compiled

329
00:09:43,360 --> 00:09:45,920
signature from offline analysis

330
00:09:45,920 --> 00:09:47,680
and when they get an aligned series of

331
00:09:47,680 --> 00:09:49,839
bytes in a pointer size region that

332
00:09:49,839 --> 00:09:51,120
match that signature

333
00:09:51,120 --> 00:09:54,160
they know that they found a pointer to

334
00:09:54,160 --> 00:09:55,760
that specific offset within that

335
00:09:55,760 --> 00:09:57,680
specific data section and they can then

336
00:09:57,680 --> 00:09:59,279
follow that pointer

337
00:09:59,279 --> 00:10:01,440
to a known location and data section and

338
00:10:01,440 --> 00:10:03,040
perform further memory cartography as

339
00:10:03,040 --> 00:10:04,720
normal because the offsets from the data

340
00:10:04,720 --> 00:10:08,000
sections are going to be deterministic

341
00:10:08,160 --> 00:10:09,680
so let's get into this in a little bit

342
00:10:09,680 --> 00:10:12,160
more detail so first the attacker is

343
00:10:12,160 --> 00:10:13,680
going to run the program locally several

344
00:10:13,680 --> 00:10:15,200
times and determine the boundaries of

345
00:10:15,200 --> 00:10:16,320
the allocated regions

346
00:10:16,320 --> 00:10:17,519
on linux you can determine these

347
00:10:17,519 --> 00:10:19,279
boundaries by looking at the prop maps

348
00:10:19,279 --> 00:10:20,160
file

349
00:10:20,160 --> 00:10:21,839
um so in this example the attacker is

350
00:10:21,839 --> 00:10:24,959
running the the exploit twice

351
00:10:24,959 --> 00:10:26,560
they've identified this heap region and

352
00:10:26,560 --> 00:10:28,240
the slim c region

353
00:10:28,240 --> 00:10:29,600
and the bounds are going to change

354
00:10:29,600 --> 00:10:31,440
between runs because of aslr but that's

355
00:10:31,440 --> 00:10:32,560
okay because they can still

356
00:10:32,560 --> 00:10:34,399
you know use proc maps to figure out

357
00:10:34,399 --> 00:10:36,480
exactly what regions they're looking at

358
00:10:36,480 --> 00:10:37,920
and this is a simple example but note

359
00:10:37,920 --> 00:10:39,600
that in some more complicated examples

360
00:10:39,600 --> 00:10:40,880
the heap that the attacker is going to

361
00:10:40,880 --> 00:10:42,240
be interested in might actually be

362
00:10:42,240 --> 00:10:43,600
multiple vmas

363
00:10:43,600 --> 00:10:45,839
for instance if the the program is using

364
00:10:45,839 --> 00:10:49,680
an map based allocator like je malin

365
00:10:49,680 --> 00:10:52,240
okay um so the attacker after figuring

366
00:10:52,240 --> 00:10:53,519
out the bounds of the heap

367
00:10:53,519 --> 00:10:55,440
is then gonna scan that heap looking for

368
00:10:55,440 --> 00:10:56,880
pointers to other regions

369
00:10:56,880 --> 00:10:58,560
so basically they're gonna run over all

370
00:10:58,560 --> 00:11:00,560
the memory in these heap regions

371
00:11:00,560 --> 00:11:01,920
and look for things that look like

372
00:11:01,920 --> 00:11:03,920
pointers so addresses that reside

373
00:11:03,920 --> 00:11:05,920
in another external memory region in

374
00:11:05,920 --> 00:11:08,079
this case loop c

375
00:11:08,079 --> 00:11:09,760
so they're going to try to find the most

376
00:11:09,760 --> 00:11:11,680
frequent destinations for pointers on

377
00:11:11,680 --> 00:11:12,640
the heap

378
00:11:12,640 --> 00:11:14,000
so in this case the most frequent

379
00:11:14,000 --> 00:11:15,920
destination is this uh

380
00:11:15,920 --> 00:11:18,959
this highlighted blue region on in lipsy

381
00:11:18,959 --> 00:11:20,320
and the pointers with the green check

382
00:11:20,320 --> 00:11:22,160
mark reference that uh most frequent

383
00:11:22,160 --> 00:11:22,880
destination

384
00:11:22,880 --> 00:11:24,399
and the most frequent destination is is

385
00:11:24,399 --> 00:11:26,560
computed as the destinations that are

386
00:11:26,560 --> 00:11:27,920
referenced frequently

387
00:11:27,920 --> 00:11:29,839
across all of the heap from oh across

388
00:11:29,839 --> 00:11:31,680
all of the runs so you see that in both

389
00:11:31,680 --> 00:11:33,440
of these runs we've got lots of pointers

390
00:11:33,440 --> 00:11:34,880
pointing to this particular offset

391
00:11:34,880 --> 00:11:35,839
within blip c

392
00:11:35,839 --> 00:11:37,360
um so those green checkmark pointers are

393
00:11:37,360 --> 00:11:38,720
really pointers of interest that we want

394
00:11:38,720 --> 00:11:41,600
to dig deeper and analyze

395
00:11:41,600 --> 00:11:43,680
so uh the attacker next is going to look

396
00:11:43,680 --> 00:11:45,120
at all those pointers to the frequent

397
00:11:45,120 --> 00:11:46,160
destination

398
00:11:46,160 --> 00:11:48,560
um so that means looking at all the

399
00:11:48,560 --> 00:11:50,320
pointers with the green check marks from

400
00:11:50,320 --> 00:11:52,480
run one and round two and sort of

401
00:11:52,480 --> 00:11:55,279
looking at the bytes that surround them

402
00:11:55,279 --> 00:11:57,360
and so basically you can expand these

403
00:11:57,360 --> 00:11:58,560
pointers and look at the bytes that are

404
00:11:58,560 --> 00:11:59,920
surrounding them we have the bytes that

405
00:11:59,920 --> 00:12:01,279
proceed the pointer the byte to the

406
00:12:01,279 --> 00:12:02,959
pointer itself and the bytes that trail

407
00:12:02,959 --> 00:12:04,079
the pointer

408
00:12:04,079 --> 00:12:05,360
and these are going to change for all

409
00:12:05,360 --> 00:12:06,560
sorts of reasons the bytes of the

410
00:12:06,560 --> 00:12:07,839
pointer itself are going to be changing

411
00:12:07,839 --> 00:12:09,440
due to aslr

412
00:12:09,440 --> 00:12:11,040
and they're going to take all of those

413
00:12:11,040 --> 00:12:12,800
sort of windows of bytes around the

414
00:12:12,800 --> 00:12:14,639
region around the pointers of interest

415
00:12:14,639 --> 00:12:16,480
and compile them and use them to build a

416
00:12:16,480 --> 00:12:17,920
filter

417
00:12:17,920 --> 00:12:21,200
and so a filter is simply a sequence of

418
00:12:21,200 --> 00:12:22,800
lower bounds and upper bounds on each

419
00:12:22,800 --> 00:12:23,200
byte

420
00:12:23,200 --> 00:12:24,800
in that window surrounding the pointers

421
00:12:24,800 --> 00:12:26,480
of interest and the filter bound to

422
00:12:26,480 --> 00:12:28,240
determine by just taking the highest and

423
00:12:28,240 --> 00:12:29,839
lowest byte value observed in each

424
00:12:29,839 --> 00:12:32,720
position during those local program runs

425
00:12:32,720 --> 00:12:35,680
so for instance this position in run one

426
00:12:35,680 --> 00:12:36,880
has a really low value

427
00:12:36,880 --> 00:12:38,240
so that's going to become a lower bound

428
00:12:38,240 --> 00:12:39,920
of the eventual filter

429
00:12:39,920 --> 00:12:41,760
this position in run two has a very high

430
00:12:41,760 --> 00:12:43,360
value so that's going to become an upper

431
00:12:43,360 --> 00:12:44,320
bound in the filter

432
00:12:44,320 --> 00:12:47,200
so a really simple filter algorithm for

433
00:12:47,200 --> 00:12:49,040
constructing this filter

434
00:12:49,040 --> 00:12:50,399
and then they're going to take that

435
00:12:50,399 --> 00:12:52,240
filter and use it to do an attack time

436
00:12:52,240 --> 00:12:53,920
memory scan

437
00:12:53,920 --> 00:12:55,279
and so that's going to work like this so

438
00:12:55,279 --> 00:12:57,040
basically the attacker is going to take

439
00:12:57,040 --> 00:12:58,560
the pre-compiled filter and then start

440
00:12:58,560 --> 00:13:00,959
leaking data off the heap using that

441
00:13:00,959 --> 00:13:03,360
that local read vulnerability and then

442
00:13:03,360 --> 00:13:04,800
they're going to match up

443
00:13:04,800 --> 00:13:07,760
a aligned segments of memory with that

444
00:13:07,760 --> 00:13:08,560
filter

445
00:13:08,560 --> 00:13:10,639
and they're going to keep doing that

446
00:13:10,639 --> 00:13:11,760
until they find

447
00:13:11,760 --> 00:13:13,360
a sort of sequence of bytes from the

448
00:13:13,360 --> 00:13:15,839
heap that fall in between the bounds

449
00:13:15,839 --> 00:13:18,720
computed by the the precompiled filter

450
00:13:18,720 --> 00:13:20,880
and basically that's going to mean that

451
00:13:20,880 --> 00:13:22,800
uh in the middle there

452
00:13:22,800 --> 00:13:24,560
we think we have a pointer to that known

453
00:13:24,560 --> 00:13:26,320
destination with the libsy

454
00:13:26,320 --> 00:13:28,079
so the attacker can then take that that

455
00:13:28,079 --> 00:13:30,240
pointer follow it and end up somewhere

456
00:13:30,240 --> 00:13:32,079
end up at a known location in the data

457
00:13:32,079 --> 00:13:33,760
section and from there they can do

458
00:13:33,760 --> 00:13:36,560
memory cryptography

459
00:13:36,560 --> 00:13:37,920
and so now i'll talk about a series of

460
00:13:37,920 --> 00:13:39,360
experiments where we tested this method

461
00:13:39,360 --> 00:13:42,720
on a number of real world programs

462
00:13:42,720 --> 00:13:44,639
okay so the general our general

463
00:13:44,639 --> 00:13:45,760
methodology

464
00:13:45,760 --> 00:13:48,000
was to run the program 10 times and dump

465
00:13:48,000 --> 00:13:50,320
memory each time

466
00:13:50,320 --> 00:13:52,800
and so we use the first nine program

467
00:13:52,800 --> 00:13:54,320
runs to compute the filters as i just

468
00:13:54,320 --> 00:13:55,839
described

469
00:13:55,839 --> 00:13:57,920
we computed filters for the four most

470
00:13:57,920 --> 00:13:59,360
frequent pointer destinations that we

471
00:13:59,360 --> 00:13:59,839
saw

472
00:13:59,839 --> 00:14:01,519
just to so we could benchmark more

473
00:14:01,519 --> 00:14:02,800
pointers instead of just the most

474
00:14:02,800 --> 00:14:03,519
frequent

475
00:14:03,519 --> 00:14:05,519
um and then we used the holdout run to

476
00:14:05,519 --> 00:14:07,440
test the accuracy of the filter

477
00:14:07,440 --> 00:14:09,920
um and we basically just did standard

478
00:14:09,920 --> 00:14:11,680
10-fold cross-validation so we held out

479
00:14:11,680 --> 00:14:14,320
each run one by one

480
00:14:14,320 --> 00:14:16,639
and so here a couple of basically so to

481
00:14:16,639 --> 00:14:17,839
test the performance of the filter we

482
00:14:17,839 --> 00:14:18,160
just

483
00:14:18,160 --> 00:14:20,560
ran it over um basically all aligned

484
00:14:20,560 --> 00:14:22,480
pointer size regions in the heap that we

485
00:14:22,480 --> 00:14:23,920
dumped from the held out run

486
00:14:23,920 --> 00:14:25,600
and so this is basically simulating that

487
00:14:25,600 --> 00:14:27,199
local read vulnerability

488
00:14:27,199 --> 00:14:30,160
um and so future work should uh use this

489
00:14:30,160 --> 00:14:30,639
method

490
00:14:30,639 --> 00:14:33,519
with an actual read exploit to um sort

491
00:14:33,519 --> 00:14:33,760
of

492
00:14:33,760 --> 00:14:36,240
uh create an end-to-end attack but uh in

493
00:14:36,240 --> 00:14:37,440
this case we're just sort of

494
00:14:37,440 --> 00:14:38,800
assuming that that read is there and

495
00:14:38,800 --> 00:14:41,279
simulating it by dumping the heat

496
00:14:41,279 --> 00:14:42,800
uh and so the important performance

497
00:14:42,800 --> 00:14:43,920
measures we're going to talk about are

498
00:14:43,920 --> 00:14:44,720
precision

499
00:14:44,720 --> 00:14:47,120
which is basically the true filter

500
00:14:47,120 --> 00:14:48,079
matches over

501
00:14:48,079 --> 00:14:50,000
all of the filter matches and that's

502
00:14:50,000 --> 00:14:51,600
representative of the probability that

503
00:14:51,600 --> 00:14:53,040
the attacker is going to succeed

504
00:14:53,040 --> 00:14:54,399
recognize a pointer to the correct

505
00:14:54,399 --> 00:14:56,399
destination and get to the destination

506
00:14:56,399 --> 00:14:57,600
they're expecting

507
00:14:57,600 --> 00:15:00,160
and then we have recall which is um the

508
00:15:00,160 --> 00:15:02,240
true filter matches divided by all the

509
00:15:02,240 --> 00:15:03,519
true pointers scanned

510
00:15:03,519 --> 00:15:05,680
uh this doesn't as directly correspond

511
00:15:05,680 --> 00:15:07,440
to a success probability but it's still

512
00:15:07,440 --> 00:15:09,040
you'd want it to be one so that all of

513
00:15:09,040 --> 00:15:09,519
the uh

514
00:15:09,519 --> 00:15:11,199
all of the true pointer all of the true

515
00:15:11,199 --> 00:15:12,480
pointers to that destination that you're

516
00:15:12,480 --> 00:15:13,120
scanning

517
00:15:13,120 --> 00:15:16,480
you're going to recognize okay um so the

518
00:15:16,480 --> 00:15:18,240
first program we tested on was vim and

519
00:15:18,240 --> 00:15:19,600
we chose that because it's

520
00:15:19,600 --> 00:15:21,040
single threaded and it has a single

521
00:15:21,040 --> 00:15:22,800
well-defined heap region so it made it a

522
00:15:22,800 --> 00:15:25,120
good early testbed

523
00:15:25,120 --> 00:15:26,959
and we found that for the pointers to

524
00:15:26,959 --> 00:15:28,800
the most frequent destinations in held

525
00:15:28,800 --> 00:15:30,160
out runs we could identify those

526
00:15:30,160 --> 00:15:31,680
pointers on the heap with extremely high

527
00:15:31,680 --> 00:15:33,519
precision so for these first two we got

528
00:15:33,519 --> 00:15:35,279
over 99 precision

529
00:15:35,279 --> 00:15:36,560
which means that an attacker if an

530
00:15:36,560 --> 00:15:37,839
attacker were trying to do this they

531
00:15:37,839 --> 00:15:39,040
were going in with the pre-compiled

532
00:15:39,040 --> 00:15:40,399
filter and looking for pointers to

533
00:15:40,399 --> 00:15:42,079
specific destinations

534
00:15:42,079 --> 00:15:44,079
they would be able to do that with very

535
00:15:44,079 --> 00:15:46,160
high accuracy

536
00:15:46,160 --> 00:15:48,480
next we looked at firefox and so for

537
00:15:48,480 --> 00:15:49,440
firefox

538
00:15:49,440 --> 00:15:51,199
firefox is a bit more complicated of a

539
00:15:51,199 --> 00:15:53,040
memory allocation scheme than vim

540
00:15:53,040 --> 00:15:54,959
so it uses je malek so it has lots of

541
00:15:54,959 --> 00:15:56,800
different vmas

542
00:15:56,800 --> 00:15:58,880
in its heap and so we resolved that by

543
00:15:58,880 --> 00:16:00,639
just looking at all of the je malek

544
00:16:00,639 --> 00:16:02,320
chunks that were the right size for the

545
00:16:02,320 --> 00:16:03,279
javascript heap

546
00:16:03,279 --> 00:16:04,720
and treating those their aggregate

547
00:16:04,720 --> 00:16:07,120
contents as the effective program heap

548
00:16:07,120 --> 00:16:10,399
and once again we found that um that for

549
00:16:10,399 --> 00:16:11,519
the most frequent

550
00:16:11,519 --> 00:16:13,680
pointers which referenced this libxul

551
00:16:13,680 --> 00:16:14,639
library

552
00:16:14,639 --> 00:16:16,240
we could we could identify them with

553
00:16:16,240 --> 00:16:17,920
extremely high precision uh

554
00:16:17,920 --> 00:16:20,480
in held out runs and then as sort of a

555
00:16:20,480 --> 00:16:22,240
lower bound as our performance we also

556
00:16:22,240 --> 00:16:24,000
looked at the precision in the worst

557
00:16:24,000 --> 00:16:25,920
heap chunk which basically is like a

558
00:16:25,920 --> 00:16:27,519
worst case performance bound

559
00:16:27,519 --> 00:16:28,880
if the attacker were limited to reading

560
00:16:28,880 --> 00:16:30,720
from a single randomly chosen sort of

561
00:16:30,720 --> 00:16:32,320
chunk of the heap

562
00:16:32,320 --> 00:16:33,680
and we saw that even in that case with

563
00:16:33,680 --> 00:16:35,360
the most frequent pointers we could

564
00:16:35,360 --> 00:16:36,000
still identify

565
00:16:36,000 --> 00:16:38,079
them with very high precision and

566
00:16:38,079 --> 00:16:40,000
finally we experimented on apache

567
00:16:40,000 --> 00:16:42,240
which is a server side program uh and we

568
00:16:42,240 --> 00:16:43,360
used openssl

569
00:16:43,360 --> 00:16:45,759
1.0.1 which is vulnerable to harpley to

570
00:16:45,759 --> 00:16:47,199
increase the realism of the attack so

571
00:16:47,199 --> 00:16:48,560
we're reading from data that

572
00:16:48,560 --> 00:16:50,079
was vulnerable to an actual read

573
00:16:50,079 --> 00:16:52,240
vulnerability and once again we saw that

574
00:16:52,240 --> 00:16:53,440
we could identify pointers with

575
00:16:53,440 --> 00:16:55,759
extremely high precision

576
00:16:55,759 --> 00:16:56,800
so the take-home point from our

577
00:16:56,800 --> 00:16:58,399
experiments is that in all the programs

578
00:16:58,399 --> 00:16:59,759
we tested we were able to identify

579
00:16:59,759 --> 00:17:01,600
pointers to static data sections with a

580
00:17:01,600 --> 00:17:04,000
very high precision furthermore the data

581
00:17:04,000 --> 00:17:05,679
sections that we were able to reach

582
00:17:05,679 --> 00:17:07,359
had a lot of connectivity with the rest

583
00:17:07,359 --> 00:17:08,720
of the address space

584
00:17:08,720 --> 00:17:10,559
which makes them ideal starting points

585
00:17:10,559 --> 00:17:13,919
for real memory cartography attacks

586
00:17:13,919 --> 00:17:15,359
and so this means that powerful memory

587
00:17:15,359 --> 00:17:16,959
cartography attacks are possible even

588
00:17:16,959 --> 00:17:18,000
when the attacker doesn't

589
00:17:18,000 --> 00:17:19,439
have control of the heap layout and

590
00:17:19,439 --> 00:17:22,319
can't do something like a heap spray

591
00:17:22,319 --> 00:17:24,720
so finally some conclusions so basically

592
00:17:24,720 --> 00:17:26,160
what i just said a

593
00:17:26,160 --> 00:17:27,520
simple signature matching algorithm is

594
00:17:27,520 --> 00:17:29,120
going to facilitate a powerful memory

595
00:17:29,120 --> 00:17:30,559
cartography attacks even when the

596
00:17:30,559 --> 00:17:32,000
attacker doesn't have control over heap

597
00:17:32,000 --> 00:17:32,640
contents

598
00:17:32,640 --> 00:17:34,720
so this hopefully expands the range of

599
00:17:34,720 --> 00:17:36,480
programs that are vulnerable to

600
00:17:36,480 --> 00:17:37,919
memory cryptography attacks and really

601
00:17:37,919 --> 00:17:39,600
underscores the importance of having

602
00:17:39,600 --> 00:17:41,600
separate address spaces for content from

603
00:17:41,600 --> 00:17:44,640
like mutually distrusting origins

604
00:17:44,640 --> 00:17:46,320
and there are some caveats to our work

605
00:17:46,320 --> 00:17:48,000
um first like in the original memory

606
00:17:48,000 --> 00:17:49,440
cartography of paper this is going to

607
00:17:49,440 --> 00:17:50,799
assume that inner region pointers are

608
00:17:50,799 --> 00:17:52,559
located at the same offsets on the local

609
00:17:52,559 --> 00:17:54,559
machine versus the victim machine

610
00:17:54,559 --> 00:17:56,000
this is sort of a stability assumption

611
00:17:56,000 --> 00:17:57,280
that's essential for making sure that

612
00:17:57,280 --> 00:18:00,320
that mapping approach is going to work

613
00:18:00,320 --> 00:18:02,640
and also for our new approach time and

614
00:18:02,640 --> 00:18:03,760
bandwidth constraints

615
00:18:03,760 --> 00:18:05,679
might uh limit the attacker's ability to

616
00:18:05,679 --> 00:18:07,200
scan the entire heap and find the right

617
00:18:07,200 --> 00:18:08,000
pointers

618
00:18:08,000 --> 00:18:09,840
and so we can assess how big of a

619
00:18:09,840 --> 00:18:11,440
problem that is by uh

620
00:18:11,440 --> 00:18:13,200
sort of building end-to-end exploits

621
00:18:13,200 --> 00:18:14,640
with um with

622
00:18:14,640 --> 00:18:16,240
sort of real read vulnerabilities which

623
00:18:16,240 --> 00:18:17,840
we hope to do in future work

624
00:18:17,840 --> 00:18:21,360
and uh that's my talk thank you

625
00:18:22,799 --> 00:18:24,799
awesome that was a super cool talk thank

626
00:18:24,799 --> 00:18:26,080
you very much james

627
00:18:26,080 --> 00:18:30,160
um we do have a couple of questions here

628
00:18:30,160 --> 00:18:34,240
um let me start by paraphrasing roland's

629
00:18:34,240 --> 00:18:36,400
question because i had a similar one

630
00:18:36,400 --> 00:18:38,960
um so so what are your your underlying

631
00:18:38,960 --> 00:18:40,080
assumptions here

632
00:18:40,080 --> 00:18:43,200
the the heat may not be continuous so if

633
00:18:43,200 --> 00:18:44,559
you just scan the heap

634
00:18:44,559 --> 00:18:47,280
end to end there may be crashes and

635
00:18:47,280 --> 00:18:49,039
illegal memory accesses how do you make

636
00:18:49,039 --> 00:18:50,799
sure that you only access

637
00:18:50,799 --> 00:18:53,360
valid sections do you read proc self

638
00:18:53,360 --> 00:18:56,400
maps or what's happening here

639
00:18:56,400 --> 00:18:59,200
so um in the inline attack basically

640
00:18:59,200 --> 00:19:00,400
your right hand the heat might not be

641
00:19:00,400 --> 00:19:01,200
contiguous

642
00:19:01,200 --> 00:19:04,880
um so the uh basically however

643
00:19:04,880 --> 00:19:07,600
in most cases we're going to have uh the

644
00:19:07,600 --> 00:19:09,520
attacker can sort of just read nearby

645
00:19:09,520 --> 00:19:11,760
data and will almost certainly encounter

646
00:19:11,760 --> 00:19:13,679
sort of a match to this filter before

647
00:19:13,679 --> 00:19:15,440
running off the edge of the heap

648
00:19:15,440 --> 00:19:17,679
um so that means that like in a jib drop

649
00:19:17,679 --> 00:19:19,120
style

650
00:19:19,120 --> 00:19:22,320
um i guess sort of uh like basically

651
00:19:22,320 --> 00:19:24,240
the attacker will simply begin by

652
00:19:24,240 --> 00:19:26,160
scanning bytes off the heap um and

653
00:19:26,160 --> 00:19:26,960
eventually

654
00:19:26,960 --> 00:19:29,919
uh and waiting until sort of they get a

655
00:19:29,919 --> 00:19:31,200
match to this filter and

656
00:19:31,200 --> 00:19:33,679
in almost all cases it's like there's

657
00:19:33,679 --> 00:19:34,720
there's generally

658
00:19:34,720 --> 00:19:36,080
the pointers that we're fingerprinting

659
00:19:36,080 --> 00:19:38,000
have are occur very frequently

660
00:19:38,000 --> 00:19:39,280
so the attacker's going to probably

661
00:19:39,280 --> 00:19:41,039
encounter one before they run off the

662
00:19:41,039 --> 00:19:44,480
heap and trigger segmentation fall

663
00:19:44,960 --> 00:19:48,640
cool um roland if this did not answer

664
00:19:48,640 --> 00:19:50,480
your question please follow up

665
00:19:50,480 --> 00:19:53,840
um i had another another thought that um

666
00:19:53,840 --> 00:19:55,760
like what i wondered regarding the

667
00:19:55,760 --> 00:19:57,600
entropy to differentiate

668
00:19:57,600 --> 00:20:00,000
different uh different targets did you

669
00:20:00,000 --> 00:20:01,280
measure that

670
00:20:01,280 --> 00:20:04,159
um how many pointers at most can you

671
00:20:04,159 --> 00:20:05,919
differentiate what are the limitations

672
00:20:05,919 --> 00:20:06,720
and so on

673
00:20:06,720 --> 00:20:09,520
and also that's interesting um so

674
00:20:09,520 --> 00:20:11,200
basically our approach was to sort of

675
00:20:11,200 --> 00:20:13,679
focus on one pointer at one at a time so

676
00:20:13,679 --> 00:20:14,960
the attacker since the attacker can

677
00:20:14,960 --> 00:20:17,280
basically do the whole thing offline uh

678
00:20:17,280 --> 00:20:19,919
given given stability assumptions they

679
00:20:19,919 --> 00:20:20,960
could basically

680
00:20:20,960 --> 00:20:23,440
um try a bunch of pointers they could

681
00:20:23,440 --> 00:20:24,320
even do this whole

682
00:20:24,320 --> 00:20:26,240
level and out thing and figure out which

683
00:20:26,240 --> 00:20:27,520
one has the most satisfactory

684
00:20:27,520 --> 00:20:28,880
performance and apply that

685
00:20:28,880 --> 00:20:31,200
um we if you're trying to differentiate

686
00:20:31,200 --> 00:20:33,600
between multiple pointers at a time

687
00:20:33,600 --> 00:20:36,000
we haven't particularly looked at that

688
00:20:36,000 --> 00:20:37,760
yet although given that

689
00:20:37,760 --> 00:20:40,960
we have um we can get high precision uh

690
00:20:40,960 --> 00:20:42,799
with all of the pointers individually it

691
00:20:42,799 --> 00:20:44,480
gives me confidence that we might be

692
00:20:44,480 --> 00:20:45,200
able to do it

693
00:20:45,200 --> 00:20:46,720
differentiating between multiple

694
00:20:46,720 --> 00:20:49,520
pointers at one time so future work

695
00:20:49,520 --> 00:20:52,320
yeah cool thanks very nice work thank

696
00:20:52,320 --> 00:20:54,000
you very much for the presentation

697
00:20:54,000 --> 00:20:55,520
um there's a couple more questions in

698
00:20:55,520 --> 00:20:57,120
the chat maybe you can follow up on

699
00:20:57,120 --> 00:20:57,679
those

700
00:20:57,679 --> 00:21:01,200
for sure

