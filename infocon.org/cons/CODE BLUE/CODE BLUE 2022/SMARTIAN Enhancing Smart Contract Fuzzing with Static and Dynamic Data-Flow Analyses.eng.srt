1
00:00:01,639 --> 00:00:06,359
also thank you for introduction and as

2
00:00:06,359 --> 00:00:09,660
you already mentioned I'm toyan Kim and

3
00:00:09,660 --> 00:00:12,660
currently I'm working online

4
00:00:12,660 --> 00:00:17,160
and I started this research when I was a

5
00:00:17,160 --> 00:00:20,939
master's student and I wrote the smart

6
00:00:20,939 --> 00:00:22,920
contract floating technique with only

7
00:00:22,920 --> 00:00:26,160
Dynamic data flow analysis in my

8
00:00:26,160 --> 00:00:27,980
Master's thesis

9
00:00:27,980 --> 00:00:31,980
and I joined the line of right after

10
00:00:31,980 --> 00:00:33,980
graduation with

11
00:00:33,980 --> 00:00:37,559
master's degree and I skill still kept

12
00:00:37,559 --> 00:00:39,600
researching into smart contract funding

13
00:00:39,600 --> 00:00:41,700
with

14
00:00:41,700 --> 00:00:43,800
other resource members

15
00:00:43,800 --> 00:00:47,640
if this is Joint work with my colleagues

16
00:00:47,640 --> 00:00:51,780
Jason sumin Gustavo Alex and lastly my

17
00:00:51,780 --> 00:00:54,840
advisors on guitar and we published the

18
00:00:54,840 --> 00:00:55,980
paper

19
00:00:55,980 --> 00:00:59,460
it at automatic software engineering

20
00:00:59,460 --> 00:01:01,680
conference which is one of the top 10

21
00:01:01,680 --> 00:01:05,220
conferences in the software engineering

22
00:01:05,220 --> 00:01:09,720
field also we open sourced smartian

23
00:01:09,720 --> 00:01:12,720
which is a great path conclude folder

24
00:01:12,720 --> 00:01:14,820
with aesthetic and dynamic data flow

25
00:01:14,820 --> 00:01:17,700
analysis for finding bugs in smart

26
00:01:17,700 --> 00:01:18,840
contract

27
00:01:18,840 --> 00:01:22,979
so today topic is same with it so if you

28
00:01:22,979 --> 00:01:26,100
are more interested in the topic after

29
00:01:26,100 --> 00:01:30,080
the listening my presentation you can

30
00:01:30,080 --> 00:01:34,320
you can read our paper and see our open

31
00:01:34,320 --> 00:01:35,579
source

32
00:01:35,579 --> 00:01:39,320
project named smartia

33
00:01:39,659 --> 00:01:42,780
so I will start

34
00:01:42,780 --> 00:01:46,259
to introduce the basic concepts of smart

35
00:01:46,259 --> 00:01:48,920
contracts

36
00:01:49,040 --> 00:01:53,040
so our research specifically targets

37
00:01:53,040 --> 00:01:56,159
smart ethereum smart contract which is

38
00:01:56,159 --> 00:01:58,680
the popular smart contract platform

39
00:01:58,680 --> 00:02:02,240
based on blockchain

40
00:02:02,240 --> 00:02:04,799
with the growing popularity of

41
00:02:04,799 --> 00:02:07,619
blockchain and smartian are up and smart

42
00:02:07,619 --> 00:02:10,080
contract I think everyone knows the

43
00:02:10,080 --> 00:02:12,599
blockchain and smart contract in short

44
00:02:12,599 --> 00:02:16,739
blockchain can be thought as distributed

45
00:02:16,739 --> 00:02:20,099
computing system and a smart contract is

46
00:02:20,099 --> 00:02:21,599
a collection of

47
00:02:21,599 --> 00:02:23,879
data and code

48
00:02:23,879 --> 00:02:28,620
which is located in the blockchain

49
00:02:28,620 --> 00:02:31,800
so smart contract can perform various

50
00:02:31,800 --> 00:02:34,980
operations so one of the important

51
00:02:34,980 --> 00:02:38,040
operation of smart contract is related

52
00:02:38,040 --> 00:02:41,580
with digital cache called either

53
00:02:41,580 --> 00:02:45,599
so for example a contract May transform

54
00:02:45,599 --> 00:02:49,440
either to other contracts on the

55
00:02:49,440 --> 00:02:50,940
blockchain

56
00:02:50,940 --> 00:02:55,800
and smart contract is executed on evm it

57
00:02:55,800 --> 00:02:59,280
stands for ethereum virtual machine

58
00:02:59,280 --> 00:03:02,239
so next I'll introduce some

59
00:03:02,239 --> 00:03:06,720
characteristics of a smart contract

60
00:03:06,720 --> 00:03:10,379
in general the contract code defines a

61
00:03:10,379 --> 00:03:14,519
set of functions and provide them to the

62
00:03:14,519 --> 00:03:16,739
users

63
00:03:16,739 --> 00:03:20,780
each of the function can read or write

64
00:03:20,780 --> 00:03:25,080
State variables of the contract which is

65
00:03:25,080 --> 00:03:28,440
similar with global variable

66
00:03:28,440 --> 00:03:30,420
of a sleep program

67
00:03:30,420 --> 00:03:32,220
in other words

68
00:03:32,220 --> 00:03:35,519
this variable persists after the

69
00:03:35,519 --> 00:03:39,080
execution of function

70
00:03:39,659 --> 00:03:43,860
so when we call function f here it will

71
00:03:43,860 --> 00:03:47,659
update the state variable

72
00:03:47,959 --> 00:03:52,500
and later when we call function G we

73
00:03:52,500 --> 00:03:55,140
will use the updated value of the

74
00:03:55,140 --> 00:03:56,220
variable

75
00:03:56,220 --> 00:03:59,040
such State variables are useful for

76
00:03:59,040 --> 00:04:01,920
holding the data of the contract for

77
00:04:01,920 --> 00:04:04,860
example let's assume there is a smart

78
00:04:04,860 --> 00:04:09,720
contract that runs a bank and then this

79
00:04:09,720 --> 00:04:13,860
Bank contract can store the balance of

80
00:04:13,860 --> 00:04:17,519
each customers in a state variable

81
00:04:17,519 --> 00:04:19,680
and the customers will deposit or

82
00:04:19,680 --> 00:04:22,260
withdraw their money by calling the

83
00:04:22,260 --> 00:04:24,979
contracts function

84
00:04:26,040 --> 00:04:28,080
because smart contracts deal with

85
00:04:28,080 --> 00:04:29,880
digital assets

86
00:04:29,880 --> 00:04:33,300
a bug in smart contracts can cause a

87
00:04:33,300 --> 00:04:37,259
catastrophic loss indeed there have been

88
00:04:37,259 --> 00:04:39,360
famous exploits on ethereum Smart

89
00:04:39,360 --> 00:04:42,840
contracts such as re-entrancy attack on

90
00:04:42,840 --> 00:04:45,479
a contract called now

91
00:04:45,479 --> 00:04:50,220
this attack had a stolen a tremendous

92
00:04:50,220 --> 00:04:53,160
amount of either which was worth 70

93
00:04:53,160 --> 00:04:56,699
million dollars at the time of attack

94
00:04:56,699 --> 00:05:00,540
so this highlights the importance of

95
00:05:00,540 --> 00:05:04,040
testing smart contracts

96
00:05:04,139 --> 00:05:07,139
so there are lots of techniques for

97
00:05:07,139 --> 00:05:09,560
finding bugs one of the most popular

98
00:05:09,560 --> 00:05:13,979
techniques is static analysis

99
00:05:13,979 --> 00:05:17,580
so static analysis approximates the

100
00:05:17,580 --> 00:05:19,740
program behaviors without actual

101
00:05:19,740 --> 00:05:23,220
execution so we can guess how to execute

102
00:05:23,220 --> 00:05:27,199
the program before it runs

103
00:05:28,020 --> 00:05:31,620
through this approximation technique

104
00:05:31,620 --> 00:05:34,380
we can investigate various semantic

105
00:05:34,380 --> 00:05:36,840
properties during program execution for

106
00:05:36,840 --> 00:05:38,220
example

107
00:05:38,220 --> 00:05:41,880
we can guess whether Buffalo overflow

108
00:05:41,880 --> 00:05:45,780
bug is occurred or not more specifically

109
00:05:45,780 --> 00:05:51,240
we can predict which access to array can

110
00:05:51,240 --> 00:05:54,360
trigger buffer overflow for the program

111
00:05:54,360 --> 00:05:55,620
execution

112
00:05:55,620 --> 00:06:00,120
so static analysis is that it doesn't

113
00:06:00,120 --> 00:06:03,360
execute Target program so we can predict

114
00:06:03,360 --> 00:06:06,060
whether there is a bug or not

115
00:06:06,060 --> 00:06:08,880
on the opposite side there is boss

116
00:06:08,880 --> 00:06:12,600
testing it is usually called fuzzing

117
00:06:12,600 --> 00:06:15,960
first thing is a process to execute the

118
00:06:15,960 --> 00:06:18,960
target program repeatedly while randomly

119
00:06:18,960 --> 00:06:23,120
change the input of program so we expect

120
00:06:23,120 --> 00:06:26,160
that the program occurs some critical

121
00:06:26,160 --> 00:06:27,960
errors like crash

122
00:06:27,960 --> 00:06:33,120
so although the fundamentals are really

123
00:06:33,120 --> 00:06:36,360
simple folding is gradually advanced in

124
00:06:36,360 --> 00:06:37,979
various aspects

125
00:06:37,979 --> 00:06:41,880
it has become an effective technique for

126
00:06:41,880 --> 00:06:45,479
finding program for vulnerabilities

127
00:06:45,479 --> 00:06:48,360
and many software companies such as

128
00:06:48,360 --> 00:06:54,080
Google and Microsoft use voting a lot

129
00:06:55,139 --> 00:06:58,280
the stateful property of smart contract

130
00:06:58,280 --> 00:07:01,680
brings an interesting challenge

131
00:07:01,680 --> 00:07:04,560
in smart contract watching a test case

132
00:07:04,560 --> 00:07:07,199
is a sequence of transactions

133
00:07:07,199 --> 00:07:10,400
which is a function calls so therefore

134
00:07:10,400 --> 00:07:13,800
deciding the order of function call is a

135
00:07:13,800 --> 00:07:16,139
critical problem in smart contract

136
00:07:16,139 --> 00:07:17,639
floating

137
00:07:17,639 --> 00:07:21,960
so let's consider this example code

138
00:07:21,960 --> 00:07:24,360
where we can trigger the bug in function

139
00:07:24,360 --> 00:07:25,620
tree

140
00:07:25,620 --> 00:07:27,900
by setting the state variable into a

141
00:07:27,900 --> 00:07:32,539
specific magic value from function f

142
00:07:32,720 --> 00:07:37,259
now if we have a sequence that calls F

143
00:07:37,259 --> 00:07:40,740
before G we have a chance to trigger the

144
00:07:40,740 --> 00:07:45,620
bug by mutating the argument of f

145
00:07:45,780 --> 00:07:49,259
in contrast for a sequence that calls

146
00:07:49,259 --> 00:07:52,500
g-forced we cannot trigger the bug how

147
00:07:52,500 --> 00:07:55,740
through we mutate the argument

148
00:07:55,740 --> 00:07:58,080
here she will always

149
00:07:58,080 --> 00:08:00,599
use the initial value of the state

150
00:08:00,599 --> 00:08:03,840
variable which is zero

151
00:08:03,840 --> 00:08:06,660
because G uses the state variables

152
00:08:06,660 --> 00:08:10,080
before we update its value

153
00:08:10,080 --> 00:08:15,060
so I'd like to note that the traditional

154
00:08:15,060 --> 00:08:17,940
coverage based flossing is not effective

155
00:08:17,940 --> 00:08:20,520
in recognizing which sequence is

156
00:08:20,520 --> 00:08:23,300
Meaningful or not

157
00:08:23,300 --> 00:08:27,900
this is because these two sequence or

158
00:08:27,900 --> 00:08:31,500
the two test cases achieve the same code

159
00:08:31,500 --> 00:08:32,640
coverage

160
00:08:32,640 --> 00:08:36,240
in other words if we already have the

161
00:08:36,240 --> 00:08:39,179
second sequence in our test case pool

162
00:08:39,179 --> 00:08:41,219
then the first sequence will be

163
00:08:41,219 --> 00:08:44,760
considered as an uninteresting one

164
00:08:44,760 --> 00:08:47,760
because it does not bring any coverage

165
00:08:47,760 --> 00:08:49,560
gain

166
00:08:49,560 --> 00:08:50,839
so

167
00:08:50,839 --> 00:08:54,660
previous work has proceeded several

168
00:08:54,660 --> 00:08:57,060
techniques to handle this problem

169
00:08:57,060 --> 00:08:59,640
for example one of the previous work

170
00:08:59,640 --> 00:09:04,200
used to machine learning to decide which

171
00:09:04,200 --> 00:09:07,860
sequence order is more promising and

172
00:09:07,860 --> 00:09:10,279
meaningful

173
00:09:10,740 --> 00:09:13,380
so let's take a look closer

174
00:09:13,380 --> 00:09:17,519
this example is different with one in

175
00:09:17,519 --> 00:09:19,560
the previous slide

176
00:09:19,560 --> 00:09:24,000
if S1 that means seed 1 is an initial

177
00:09:24,000 --> 00:09:26,820
seat we can cover line three for

178
00:09:26,820 --> 00:09:29,580
function argument mutation Lobby

179
00:09:29,580 --> 00:09:31,140
S1 Prime

180
00:09:31,140 --> 00:09:35,880
and one more mutation finally makes s

181
00:09:35,880 --> 00:09:39,779
Spock which triggers a bug

182
00:09:39,779 --> 00:09:44,180
see that S1 Prime covers line three

183
00:09:44,180 --> 00:09:49,740
then let's think that there is S2 which

184
00:09:49,740 --> 00:09:51,899
is an initial seat

185
00:09:51,899 --> 00:09:56,420
that executes F and H orderly

186
00:09:56,420 --> 00:09:59,640
we can get S2 Prime

187
00:09:59,640 --> 00:10:02,459
using mutation

188
00:10:02,459 --> 00:10:07,459
and S2 Prime also covers line three

189
00:10:07,860 --> 00:10:10,980
uh and let's assume that if a seat will

190
00:10:10,980 --> 00:10:15,300
include these seeds in the dotted line

191
00:10:15,300 --> 00:10:18,000
and let's assume that S1 Prime appears

192
00:10:18,000 --> 00:10:19,019
next

193
00:10:19,019 --> 00:10:22,500
then the traditional code coverage based

194
00:10:22,500 --> 00:10:25,620
fuzzing doesn't think that S1 Prime is

195
00:10:25,620 --> 00:10:27,500
not meaningful sequence because

196
00:10:27,500 --> 00:10:32,160
it doesn't cover new line because S2

197
00:10:32,160 --> 00:10:35,640
Prime already covered line three

198
00:10:35,640 --> 00:10:38,700
but you know that S1 Prime only trigger

199
00:10:38,700 --> 00:10:39,959
the Box

200
00:10:39,959 --> 00:10:43,019
that means the traditional code coverage

201
00:10:43,019 --> 00:10:46,260
based buzzing Miss is opportunity to

202
00:10:46,260 --> 00:10:47,760
trigger the bug

203
00:10:47,760 --> 00:10:51,360
so in our paper in our paper we mainly

204
00:10:51,360 --> 00:10:54,720
do funding for finding bugs in smart

205
00:10:54,720 --> 00:10:58,019
contract but how to force efficiently

206
00:10:58,019 --> 00:11:01,079
for that we propose another approach

207
00:11:01,079 --> 00:11:03,839
based on static analysis which we

208
00:11:03,839 --> 00:11:07,140
believe to be complementary to the

209
00:11:07,140 --> 00:11:09,500
floating

210
00:11:09,779 --> 00:11:12,959
first we statically analyze the Target

211
00:11:12,959 --> 00:11:15,859
contract code

212
00:11:15,899 --> 00:11:20,640
and identify the data flows that can

213
00:11:20,640 --> 00:11:23,459
occur between the functions

214
00:11:23,459 --> 00:11:27,000
based on this we decide which function

215
00:11:27,000 --> 00:11:30,720
call sequence is expected to produce

216
00:11:30,720 --> 00:11:34,140
such data flows then we initialize the

217
00:11:34,140 --> 00:11:37,260
floating seats with those promising

218
00:11:37,260 --> 00:11:41,640
sequence and pass them to the folder

219
00:11:41,640 --> 00:11:44,640
so the summary is

220
00:11:44,640 --> 00:11:47,820
we integrated static analysis with

221
00:11:47,820 --> 00:11:51,240
funding that means static analysis

222
00:11:51,240 --> 00:11:54,720
collects program knowledge so that it

223
00:11:54,720 --> 00:11:58,700
can improve voting performance

224
00:11:59,279 --> 00:12:03,120
so before providing more technical

225
00:12:03,120 --> 00:12:07,200
details I'd like to present the overall

226
00:12:07,200 --> 00:12:10,920
architecture of our system smart team

227
00:12:10,920 --> 00:12:13,019
at a high level

228
00:12:13,019 --> 00:12:16,100
smartian takes in Target contract code

229
00:12:16,100 --> 00:12:21,000
and I'll put the bug found by fuzzing

230
00:12:21,000 --> 00:12:24,420
first the static analysis module will

231
00:12:24,420 --> 00:12:27,779
identify possible data flows and

232
00:12:27,779 --> 00:12:31,140
initialize the seeds by considering

233
00:12:31,140 --> 00:12:33,360
these data flows

234
00:12:33,360 --> 00:12:36,140
then the generated sees

235
00:12:36,140 --> 00:12:40,200
are passed to the floating module

236
00:12:40,200 --> 00:12:42,959
when the 14 module starts to run

237
00:12:42,959 --> 00:12:45,779
this time we employ Dynamic data flow

238
00:12:45,779 --> 00:12:48,959
analysis to improve the effectiveness of

239
00:12:48,959 --> 00:12:50,100
buzzing

240
00:12:50,100 --> 00:12:53,100
I will cover more technical details of

241
00:12:53,100 --> 00:12:56,399
each module one by one

242
00:12:56,399 --> 00:12:57,420
so

243
00:12:57,420 --> 00:13:00,660
first let's take a look closer at

244
00:13:00,660 --> 00:13:04,459
aesthetic analysis module

245
00:13:04,680 --> 00:13:08,639
generally the contract code is first

246
00:13:08,639 --> 00:13:13,100
written in high level language

247
00:13:13,380 --> 00:13:17,459
but it eventually has to be compiled

248
00:13:17,459 --> 00:13:18,899
into

249
00:13:18,899 --> 00:13:22,700
a low level bytecode

250
00:13:22,800 --> 00:13:24,779
and our

251
00:13:24,779 --> 00:13:28,019
system receives the contract in the form

252
00:13:28,019 --> 00:13:31,440
of bytecode therefore the aesthetic

253
00:13:31,440 --> 00:13:35,399
analysis for data flow is not trivial

254
00:13:35,399 --> 00:13:40,500
because we have to observe the low level

255
00:13:40,500 --> 00:13:43,620
by instructions

256
00:13:43,620 --> 00:13:46,800
so some people wonder

257
00:13:46,800 --> 00:13:50,700
why we use binary in a source code the

258
00:13:50,700 --> 00:13:54,240
main reason is smart contracts are

259
00:13:54,240 --> 00:13:55,560
deployed

260
00:13:55,560 --> 00:14:00,420
to the blockchain in in bytecode form

261
00:14:00,420 --> 00:14:04,920
so there is a high probability that the

262
00:14:04,920 --> 00:14:09,240
source code does not exist and someone

263
00:14:09,240 --> 00:14:13,079
may intentionally not provide the source

264
00:14:13,079 --> 00:14:14,760
code of smart contract

265
00:14:14,760 --> 00:14:18,300
due to these reasons it's easier to get

266
00:14:18,300 --> 00:14:21,779
byte code than source code so we aim to

267
00:14:21,779 --> 00:14:23,279
enable fuzzing

268
00:14:23,279 --> 00:14:26,220
even if source code is not possible

269
00:14:26,220 --> 00:14:29,240
not available

270
00:14:51,540 --> 00:14:55,380
so from now on I will present more

271
00:14:55,380 --> 00:14:59,220
details about our static analysis

272
00:14:59,220 --> 00:15:02,820
the smart contracts byte code runs in a

273
00:15:02,820 --> 00:15:05,360
virtual machine called evm

274
00:15:05,360 --> 00:15:10,500
and evm is a stick based motion and it

275
00:15:10,500 --> 00:15:13,380
comprise three components

276
00:15:13,380 --> 00:15:18,000
first the stack is used to hold the

277
00:15:18,000 --> 00:15:19,260
operands

278
00:15:19,260 --> 00:15:22,860
of every instruction second there is a

279
00:15:22,860 --> 00:15:26,220
memory which is an address to byte

280
00:15:26,220 --> 00:15:30,120
mapping lastly the persistent storage is

281
00:15:30,120 --> 00:15:33,720
used to maintain the state variables

282
00:15:33,720 --> 00:15:37,079
now let's assume we have despite code

283
00:15:37,079 --> 00:15:41,160
that assess State variables

284
00:15:41,160 --> 00:15:45,839
what we have to do is figuring out which

285
00:15:45,839 --> 00:15:50,720
operands are used by the inter

286
00:15:50,720 --> 00:15:54,060
instructions that assess the storage

287
00:15:54,060 --> 00:15:58,079
such as the s-load instructions in this

288
00:15:58,079 --> 00:16:00,680
bytecode

289
00:16:01,639 --> 00:16:05,820
for this we analyzed the semantics of

290
00:16:05,820 --> 00:16:07,279
every instruction

291
00:16:07,279 --> 00:16:11,100
and Trace how the stack and memory

292
00:16:11,100 --> 00:16:14,839
change along the execution

293
00:16:15,000 --> 00:16:19,079
in the end we can find out which operand

294
00:16:19,079 --> 00:16:22,199
is on the stack when the S load

295
00:16:22,199 --> 00:16:25,740
instruction is executed and this

296
00:16:25,740 --> 00:16:26,600
instruction

297
00:16:26,600 --> 00:16:30,240
will use its operand as the storage

298
00:16:30,240 --> 00:16:31,380
address

299
00:16:31,380 --> 00:16:34,519
to assess

300
00:16:37,320 --> 00:16:42,240
so that was the low level sketch of our

301
00:16:42,240 --> 00:16:44,579
aesthetic analysis and now let's

302
00:16:44,579 --> 00:16:46,980
summarize our static analysis at a high

303
00:16:46,980 --> 00:16:47,880
level

304
00:16:47,880 --> 00:16:51,540
for each function we run a flow

305
00:16:51,540 --> 00:16:53,899
sensitive analysis and approximate

306
00:16:53,899 --> 00:16:57,540
execution state of evm and every program

307
00:16:57,540 --> 00:16:58,759
input

308
00:16:58,759 --> 00:17:02,839
every program point

309
00:17:03,079 --> 00:17:08,280
based on this we can identify which

310
00:17:08,280 --> 00:17:12,299
state variables are loaded and stored by

311
00:17:12,299 --> 00:17:15,299
the analyzed function using a slot and

312
00:17:15,299 --> 00:17:19,619
as tour instructions

313
00:17:20,939 --> 00:17:24,419
now we have to generate the initial seed

314
00:17:24,419 --> 00:17:28,679
pool for pausing by utilizing the

315
00:17:28,679 --> 00:17:31,440
synthetic analysis research

316
00:17:31,440 --> 00:17:34,919
and I will show you the formal algorithm

317
00:17:34,919 --> 00:17:39,179
for seed initialization which is present

318
00:17:39,179 --> 00:17:42,299
in our paper but before I show you I

319
00:17:42,299 --> 00:17:44,580
will explain the high level

320
00:17:44,580 --> 00:17:47,539
idea first

321
00:17:48,600 --> 00:17:51,480
so first we identify the function call

322
00:17:51,480 --> 00:17:55,080
orders that may produce data flows

323
00:17:55,080 --> 00:17:58,440
across the functions then for each of

324
00:17:58,440 --> 00:18:02,460
the identified order

325
00:18:02,940 --> 00:18:06,539
we ensure that there is at least one

326
00:18:06,539 --> 00:18:08,940
seed that includes this order in the

327
00:18:08,940 --> 00:18:13,039
sequence yeah so this is high level

328
00:18:13,039 --> 00:18:17,340
explanation for seed initialization

329
00:18:17,340 --> 00:18:20,580
so before I explain in detail we need to

330
00:18:20,580 --> 00:18:24,120
know about the variables used in seed

331
00:18:24,120 --> 00:18:26,460
initialization algorithm

332
00:18:26,460 --> 00:18:29,160
the seed initialization algorithm takes

333
00:18:29,160 --> 00:18:32,460
three inputs one is fungus which is a

334
00:18:32,460 --> 00:18:36,919
set of identified functions next is devs

335
00:18:36,919 --> 00:18:40,740
which is a map from each identified

336
00:18:40,740 --> 00:18:43,140
function to the state variables defined

337
00:18:43,140 --> 00:18:45,500
by the function

338
00:18:45,500 --> 00:18:50,820
and the next is use which is a map from

339
00:18:50,820 --> 00:18:53,160
each identified function to the state

340
00:18:53,160 --> 00:18:57,360
variables used used by function

341
00:18:57,360 --> 00:19:01,080
so only information is obtained from

342
00:19:01,080 --> 00:19:04,500
static analysis about which I already

343
00:19:04,500 --> 00:19:05,820
talked

344
00:19:05,820 --> 00:19:08,520
so we can get steps using s-store

345
00:19:08,520 --> 00:19:11,299
instruction and use use

346
00:19:11,299 --> 00:19:14,880
using absolute also there is other

347
00:19:14,880 --> 00:19:17,340
variable used in seed initialization

348
00:19:17,340 --> 00:19:20,280
algorithm which is data flow gain

349
00:19:20,280 --> 00:19:23,640
it is a function level data flows as

350
00:19:23,640 --> 00:19:30,299
triple F1 V and F2 from a given sequence

351
00:19:30,299 --> 00:19:34,620
where F1 and F2 are functions that

352
00:19:34,620 --> 00:19:36,539
appear in the sequence

353
00:19:36,539 --> 00:19:41,580
and second F1 defines we want free and

354
00:19:41,580 --> 00:19:45,059
F2 use that free

355
00:19:45,059 --> 00:19:47,940
so this is the formal algorithm for seed

356
00:19:47,940 --> 00:19:49,500
initialization

357
00:19:49,500 --> 00:19:53,100
it takes in as input function defined

358
00:19:53,100 --> 00:19:55,580
one and used one

359
00:19:55,580 --> 00:19:59,900
in line 3 we initialize the work list

360
00:19:59,900 --> 00:20:03,240
with single Latin sequence containing

361
00:20:03,240 --> 00:20:05,580
each function in funds we ignore

362
00:20:05,580 --> 00:20:08,160
functions that do not Define any state

363
00:20:08,160 --> 00:20:12,720
variables as they cannot affect the

364
00:20:12,720 --> 00:20:15,380
persistent state

365
00:20:15,380 --> 00:20:20,820
next we pull stick ones out of the work

366
00:20:20,820 --> 00:20:24,539
list and create Duke sequences by

367
00:20:24,539 --> 00:20:27,500
appending its functions

368
00:20:27,500 --> 00:20:31,340
in fonts to s

369
00:20:32,820 --> 00:20:35,520
so we then examine each of the

370
00:20:35,520 --> 00:20:38,340
generative sequence with data flow gain

371
00:20:38,340 --> 00:20:40,700
to decide which sequence covers

372
00:20:40,700 --> 00:20:44,960
previously on scene data flow

373
00:20:45,860 --> 00:20:50,820
line nine push just sequence to the work

374
00:20:50,820 --> 00:20:53,400
list and intern internally remove

375
00:20:53,400 --> 00:20:57,059
redundant entries for greater efficiency

376
00:20:57,059 --> 00:21:01,500
we repeat it extended extend sequence in

377
00:21:01,500 --> 00:21:05,340
the work list as long as undue data flow

378
00:21:05,340 --> 00:21:08,178
is observed

379
00:21:09,539 --> 00:21:13,559
if a sequence produce no gain by

380
00:21:13,559 --> 00:21:17,340
extending it we finalize the sequence by

381
00:21:17,340 --> 00:21:21,780
adding it to the output set

382
00:21:21,780 --> 00:21:23,460
so far

383
00:21:23,460 --> 00:21:27,720
I have covered the static analysis model

384
00:21:27,720 --> 00:21:30,059
of our system

385
00:21:30,059 --> 00:21:32,280
now let's proceed to the floating model

386
00:21:32,280 --> 00:21:35,880
of smartian which starts running with

387
00:21:35,880 --> 00:21:40,760
the provided initialization seat pool

388
00:21:41,539 --> 00:21:46,799
so uh even though the Seas are

389
00:21:46,799 --> 00:21:50,000
initialized with meaningful sequence

390
00:21:50,000 --> 00:21:54,419
we still have to mutate this initial C's

391
00:21:54,419 --> 00:21:58,620
to realize the expected data flows for

392
00:21:58,620 --> 00:22:01,500
example let's consider this contract

393
00:22:01,500 --> 00:22:04,620
where a function f updates a state

394
00:22:04,620 --> 00:22:09,379
variable and function tree use it

395
00:22:09,600 --> 00:22:12,000
so we have to call

396
00:22:12,000 --> 00:22:18,659
f with 41 and 61 and 2 2 trigger the

397
00:22:18,659 --> 00:22:22,100
bulk and line seven

398
00:22:22,320 --> 00:22:24,840
and our static analysis module will

399
00:22:24,840 --> 00:22:28,020
initialize the seed with the promising

400
00:22:28,020 --> 00:22:32,600
sequence F and 3 orderly

401
00:22:33,780 --> 00:22:37,200
but the father still has to mutate this

402
00:22:37,200 --> 00:22:38,940
initial seed to obtain the bug

403
00:22:38,940 --> 00:22:41,780
triggering seat

404
00:22:41,840 --> 00:22:44,580
during this process the folder will

405
00:22:44,580 --> 00:22:48,360
first find an intermediate seat light S1

406
00:22:48,360 --> 00:22:51,299
prime it is important to recognize this

407
00:22:51,299 --> 00:22:54,299
intermediate seat as an interesting one

408
00:22:54,299 --> 00:22:58,860
and add it to the evolving seed pool

409
00:22:58,860 --> 00:23:02,340
for this we dynamically analyze the

410
00:23:02,340 --> 00:23:05,460
concrete data flows that occur at

411
00:23:05,460 --> 00:23:08,159
runtime and use them as feedback to

412
00:23:08,159 --> 00:23:10,740
evaluate each seat

413
00:23:10,740 --> 00:23:14,820
so in this example S1 Prime realized the

414
00:23:14,820 --> 00:23:18,840
data flow from line 3 to line six which

415
00:23:18,840 --> 00:23:22,080
is not present in S1 therefore we can

416
00:23:22,080 --> 00:23:26,400
consider S1 Prime as an interesting seat

417
00:23:26,400 --> 00:23:30,000
and add it to the seed pool later it

418
00:23:30,000 --> 00:23:32,520
will be selected and mutated again and

419
00:23:32,520 --> 00:23:34,559
we will have a chance to find the block

420
00:23:34,559 --> 00:23:36,539
triggering input

421
00:23:36,539 --> 00:23:38,720
foreign

422
00:23:41,539 --> 00:23:45,440
which is one of the important parts

423
00:23:45,440 --> 00:23:50,280
in traditional binary it is quite simple

424
00:23:50,280 --> 00:23:53,940
to recognize which one is bug or not but

425
00:23:53,940 --> 00:23:57,600
unlike traditional binary smart contract

426
00:23:57,600 --> 00:24:02,640
both both do not incur a crash so we

427
00:24:02,640 --> 00:24:05,760
must Implement POG Oracle that monitors

428
00:24:05,760 --> 00:24:07,980
the execution

429
00:24:07,980 --> 00:24:10,559
so

430
00:24:10,559 --> 00:24:14,100
smartian implements pogora calls for 13

431
00:24:14,100 --> 00:24:17,179
classes of bugs and we investigate

432
00:24:17,179 --> 00:24:19,980
previous works on finding both from

433
00:24:19,980 --> 00:24:22,640
Smart contract

434
00:24:22,640 --> 00:24:26,760
and first is assertion failure it occurs

435
00:24:26,760 --> 00:24:29,700
when the condition of 100 assertion a

436
00:24:29,700 --> 00:24:33,000
start statement is not satisfied so

437
00:24:33,000 --> 00:24:34,760
finding adjustable

438
00:24:34,760 --> 00:24:39,000
we check if on invalid instruction is

439
00:24:39,000 --> 00:24:40,980
executed

440
00:24:40,980 --> 00:24:47,580
and next one is arbitrary right so it is

441
00:24:47,580 --> 00:24:50,179
occurred when an attacker can overwrite

442
00:24:50,179 --> 00:24:53,100
arbitrary storage data by assessing a

443
00:24:53,100 --> 00:24:57,000
mismanaged array object

444
00:24:57,000 --> 00:25:01,740
and we checked if someone assessed

445
00:25:01,740 --> 00:25:04,740
storage data in location there is a

446
00:25:04,740 --> 00:25:07,620
larger than the length of stories and

447
00:25:07,620 --> 00:25:13,879
its Spock Oracle is theme with Harvey

448
00:25:14,940 --> 00:25:17,659
and the next one is requirement

449
00:25:17,659 --> 00:25:21,900
violation and in it incurs when the

450
00:25:21,900 --> 00:25:25,200
condition of a required statement is not

451
00:25:25,200 --> 00:25:26,760
satisfied

452
00:25:26,760 --> 00:25:30,360
and we check if our revert instruction

453
00:25:30,360 --> 00:25:33,899
is executed

454
00:25:34,020 --> 00:25:38,299
but you might think it's weird because

455
00:25:38,299 --> 00:25:41,279
obstruction failure and requirement

456
00:25:41,279 --> 00:25:44,779
violation can occur frequently

457
00:25:44,779 --> 00:25:49,080
indeed actually requirement violation is

458
00:25:49,080 --> 00:25:51,779
not kind of works so we also thought

459
00:25:51,779 --> 00:25:54,600
about that but we just followed a Subway

460
00:25:54,600 --> 00:25:57,419
Series 3 which is smart contract

461
00:25:57,419 --> 00:26:00,179
weakness classification and some tools

462
00:26:00,179 --> 00:26:03,240
already implemented just box so

463
00:26:03,240 --> 00:26:04,679
comparing with

464
00:26:04,679 --> 00:26:08,279
other tools we added search box

465
00:26:08,279 --> 00:26:12,000
so when you use smartian we turn off

466
00:26:12,000 --> 00:26:14,400
assertion failure and requirement

467
00:26:14,400 --> 00:26:17,220
violation on default mode

468
00:26:17,220 --> 00:26:18,779
and

469
00:26:18,779 --> 00:26:22,260
next one is

470
00:26:22,260 --> 00:26:24,960
block State dependency

471
00:26:24,960 --> 00:26:27,740
this occurs when

472
00:26:27,740 --> 00:26:31,679
block states such as timestamp and

473
00:26:31,679 --> 00:26:35,520
number can decide either a transfer of a

474
00:26:35,520 --> 00:26:37,799
contract so

475
00:26:37,799 --> 00:26:41,520
we check if a block state

476
00:26:41,520 --> 00:26:44,460
such as timestamp and number can affect

477
00:26:44,460 --> 00:26:49,080
on either transfer tracing both direct

478
00:26:49,080 --> 00:26:53,720
and indirect pain flows for this

479
00:26:54,840 --> 00:26:58,919
next is control flow hijacked it occurs

480
00:26:58,919 --> 00:27:01,740
when an attacker can arbitrarily control

481
00:27:01,740 --> 00:27:05,039
the destination of a jump or delegate

482
00:27:05,039 --> 00:27:08,100
call instructions so we raise an alarm

483
00:27:08,100 --> 00:27:10,260
if

484
00:27:10,260 --> 00:27:12,960
someone can set the destination contract

485
00:27:12,960 --> 00:27:16,200
of delegate call into an arbitrary user

486
00:27:16,200 --> 00:27:21,419
contract and also it reports an alarm if

487
00:27:21,419 --> 00:27:24,740
the destination of a jump instruction is

488
00:27:24,740 --> 00:27:27,360
manipulate manipulatable

489
00:27:27,360 --> 00:27:28,700
so

490
00:27:28,700 --> 00:27:33,299
uh somebody already knew that uh

491
00:27:33,299 --> 00:27:37,020
delegate call is already deprecated but

492
00:27:37,020 --> 00:27:41,279
some developers still use old compiler

493
00:27:41,279 --> 00:27:45,779
patterns which delegate call is not

494
00:27:45,779 --> 00:27:47,220
deprecated

495
00:27:47,220 --> 00:27:49,140
so we considered

496
00:27:49,140 --> 00:27:51,659
this kind of box

497
00:27:51,659 --> 00:27:53,580
so next is

498
00:27:53,580 --> 00:27:58,500
Italy it incurs when a contract allows

499
00:27:58,500 --> 00:28:01,620
an arbitrary user to freely retrieve

500
00:28:01,620 --> 00:28:04,140
either from the contract

501
00:28:04,140 --> 00:28:06,720
so we check if

502
00:28:06,720 --> 00:28:10,320
a normal user can gain either by sending

503
00:28:10,320 --> 00:28:13,020
transaction to the contract only when

504
00:28:13,020 --> 00:28:15,000
the transaction sequence does not have

505
00:28:15,000 --> 00:28:16,860
any preceding transaction from the

506
00:28:16,860 --> 00:28:19,200
deployer

507
00:28:19,200 --> 00:28:23,100
actually we solved this issue very

508
00:28:23,100 --> 00:28:24,779
heuristically

509
00:28:24,779 --> 00:28:27,659
but we still

510
00:28:27,659 --> 00:28:30,419
lots of smart contracts

511
00:28:30,419 --> 00:28:34,620
which deployer is mostly on owner of

512
00:28:34,620 --> 00:28:36,679
smart contract

513
00:28:36,679 --> 00:28:40,799
and the owner usually has a permission

514
00:28:40,799 --> 00:28:44,640
to transfer either to someone

515
00:28:44,640 --> 00:28:48,120
so if there is a case

516
00:28:48,120 --> 00:28:52,200
where the deployer sees a transition

517
00:28:52,200 --> 00:28:57,120
during ascends or transaction during a

518
00:28:57,120 --> 00:29:00,360
sequence and anyone can get either this

519
00:29:00,360 --> 00:29:03,299
situation is excluded as both because

520
00:29:03,299 --> 00:29:08,340
the deployer might allow it with a

521
00:29:08,340 --> 00:29:11,159
higher high probability

522
00:29:11,159 --> 00:29:15,299
so in this part of our tries

523
00:29:15,299 --> 00:29:20,520
there can be false positives so

524
00:29:20,520 --> 00:29:23,820
next is freezing either

525
00:29:23,820 --> 00:29:28,140
which is a contract can receive either

526
00:29:28,140 --> 00:29:32,460
but does not have any means to stand out

527
00:29:32,460 --> 00:29:34,760
either

528
00:29:34,860 --> 00:29:37,380
so we check if there is no way to

529
00:29:37,380 --> 00:29:39,720
transfer either to someone during the

530
00:29:39,720 --> 00:29:41,580
execution like contract balance is

531
00:29:41,580 --> 00:29:45,600
greater than zero and it's it is same

532
00:29:45,600 --> 00:29:49,340
vocal with contract flutter

533
00:29:49,860 --> 00:29:55,320
and next one is mishandled exception and

534
00:29:55,320 --> 00:29:58,140
it is about a contract does not check

535
00:29:58,140 --> 00:30:00,360
for an exception when calling external

536
00:30:00,360 --> 00:30:03,678
functions or sending either

537
00:30:03,720 --> 00:30:06,179
and we

538
00:30:06,179 --> 00:30:09,779
we paint the return value of call

539
00:30:09,779 --> 00:30:13,020
instruction flows into a predicate of a

540
00:30:13,020 --> 00:30:15,899
jump I instruction and if there is a

541
00:30:15,899 --> 00:30:19,260
return value that is not used by jump I

542
00:30:19,260 --> 00:30:22,200
then we report an alarm

543
00:30:22,200 --> 00:30:25,820
and next one is multiple stand so

544
00:30:25,820 --> 00:30:28,500
contract sends out either multiple times

545
00:30:28,500 --> 00:30:30,899
within one transition and this is a

546
00:30:30,899 --> 00:30:32,779
specific case of those

547
00:30:32,779 --> 00:30:34,940
according to

548
00:30:34,940 --> 00:30:38,820
swc registry it is dangerous just in

549
00:30:38,820 --> 00:30:41,899
case so we detected

550
00:30:42,659 --> 00:30:46,679
so next one is integer blog

551
00:30:46,679 --> 00:30:50,340
and everyone knows about that but yeah

552
00:30:50,340 --> 00:30:53,580
integral flows or underflows occur and

553
00:30:53,580 --> 00:30:55,860
the result pick comes on unexpected

554
00:30:55,860 --> 00:30:56,880
value

555
00:30:56,880 --> 00:31:00,120
so we check if the overall flow or

556
00:31:00,120 --> 00:31:02,880
underflow value is used to the critical

557
00:31:02,880 --> 00:31:04,559
values

558
00:31:04,559 --> 00:31:07,679
variables yeah and next one is

559
00:31:07,679 --> 00:31:09,539
re-entrancy

560
00:31:09,539 --> 00:31:14,039
it is a function in a victim it is uh

561
00:31:14,039 --> 00:31:16,440
yeah a function in a victim contract is

562
00:31:16,440 --> 00:31:19,020
re-entered and leads to a race condition

563
00:31:19,020 --> 00:31:21,899
on state variables

564
00:31:21,899 --> 00:31:26,279
so we first we monitor if there is a

565
00:31:26,279 --> 00:31:28,200
cyclical change during an either

566
00:31:28,200 --> 00:31:29,399
transfer

567
00:31:29,399 --> 00:31:32,220
then use taint analysis to identify

568
00:31:32,220 --> 00:31:34,919
State variables that affect this either

569
00:31:34,919 --> 00:31:38,220
transfer and finally we report if such

570
00:31:38,220 --> 00:31:40,799
variables are updated after the transfer

571
00:31:40,799 --> 00:31:43,320
takes place

572
00:31:43,320 --> 00:31:46,980
so next is visitor contract

573
00:31:46,980 --> 00:31:48,600
and

574
00:31:48,600 --> 00:31:51,659
it is occurred when an arbitrary user

575
00:31:51,659 --> 00:31:54,240
can destroy a victim contract by running

576
00:31:54,240 --> 00:31:57,960
a self-destruct instruction

577
00:31:57,960 --> 00:32:01,820
so we check if a normal user can execute

578
00:32:01,820 --> 00:32:04,020
self-destruct instruction and destroy

579
00:32:04,020 --> 00:32:07,080
the contract and we filter

580
00:32:07,080 --> 00:32:10,559
that have any preceding transaction from

581
00:32:10,559 --> 00:32:13,740
the deployer in the sequence it is same

582
00:32:13,740 --> 00:32:17,159
case with either leak

583
00:32:17,159 --> 00:32:18,480
and

584
00:32:18,480 --> 00:32:22,620
the last one is transaction origin news

585
00:32:22,620 --> 00:32:25,380
it is occurred when a contract relies on

586
00:32:25,380 --> 00:32:27,960
the origin of transaction

587
00:32:27,960 --> 00:32:31,080
for user Authentication

588
00:32:31,080 --> 00:32:33,240
so

589
00:32:33,240 --> 00:32:35,940
we change the return value of origin

590
00:32:35,940 --> 00:32:39,659
instruction and check if it flows into

591
00:32:39,659 --> 00:32:43,820
the predicate of jump file instruction

592
00:32:43,820 --> 00:32:48,860
also it is already deprecated as well as

593
00:32:48,860 --> 00:32:51,720
delegate call instruction

594
00:32:51,720 --> 00:32:55,260
but with same reason we implemented the

595
00:32:55,260 --> 00:32:57,360
spark Oracle

596
00:32:57,360 --> 00:32:59,700
so

597
00:32:59,700 --> 00:33:02,480
next is

598
00:33:02,480 --> 00:33:04,740
implementation and I will Briefly

599
00:33:04,740 --> 00:33:07,020
summarize the implementation of smart

600
00:33:07,020 --> 00:33:10,080
tin for the static analysis module we

601
00:33:10,080 --> 00:33:13,980
used b2r2 as a front end

602
00:33:13,980 --> 00:33:17,159
and wrote domain analysis logic in 1000

603
00:33:17,159 --> 00:33:19,620
lines of F-sharp code and for the

604
00:33:19,620 --> 00:33:22,320
plotting module we use eclipsor which

605
00:33:22,320 --> 00:33:23,640
was

606
00:33:23,640 --> 00:33:27,419
originally designed for Linux binaries

607
00:33:27,419 --> 00:33:30,179
and extended it to support smart

608
00:33:30,179 --> 00:33:35,399
contract bytecode also we used the EBA

609
00:33:35,399 --> 00:33:38,039
implementation from determined to

610
00:33:38,039 --> 00:33:42,299
emulate the execution of the byte code

611
00:33:42,299 --> 00:33:44,700
and we implemented the dynamic data flow

612
00:33:44,700 --> 00:33:48,500
analysis on the top of it

613
00:33:49,620 --> 00:33:54,360
so now I will present the evaluation

614
00:33:54,360 --> 00:33:57,360
result of Martian

615
00:33:57,360 --> 00:34:00,360
in this talk I will cover the two

616
00:34:00,360 --> 00:34:03,659
evaluation questions for the remaining

617
00:34:03,659 --> 00:34:06,419
evaluation question please refer to my

618
00:34:06,419 --> 00:34:07,440
paper

619
00:34:07,440 --> 00:34:10,679
and first we studied whether our static

620
00:34:10,679 --> 00:34:15,540
and dynamic analysis indeed improve the

621
00:34:15,540 --> 00:34:18,440
effectiveness of fuzzing and second one

622
00:34:18,440 --> 00:34:22,199
is we studied whether smart Tian can

623
00:34:22,199 --> 00:34:26,178
outperform other testing tools

624
00:34:27,599 --> 00:34:29,159
so

625
00:34:29,159 --> 00:34:33,300
uh to answer these two evaluation

626
00:34:33,300 --> 00:34:37,500
questions we used two Benchmark from

627
00:34:37,500 --> 00:34:38,940
previous work

628
00:34:38,940 --> 00:34:43,500
for the comparison purpose we chose two

629
00:34:43,500 --> 00:34:46,980
folders and two symbolic executors for

630
00:34:46,980 --> 00:34:50,659
smart contracts and we ran our

631
00:34:50,659 --> 00:34:54,540
experiments in atukar environment to

632
00:34:54,540 --> 00:34:56,099
ease their

633
00:34:56,099 --> 00:34:58,940
reproduction

634
00:34:59,099 --> 00:35:04,800
so first we used the Benchmark from very

635
00:35:04,800 --> 00:35:06,060
smart

636
00:35:06,060 --> 00:35:10,619
paper to evaluate the impact of our data

637
00:35:10,619 --> 00:35:13,320
flow analysis

638
00:35:13,320 --> 00:35:17,040
because very smart is not a testing tool

639
00:35:17,040 --> 00:35:21,240
it is not our comparison Target still we

640
00:35:21,240 --> 00:35:24,900
found this Benchmark valuable because

641
00:35:24,900 --> 00:35:26,780
it's

642
00:35:26,780 --> 00:35:30,540
composed a real world contracts that

643
00:35:30,540 --> 00:35:34,380
have non-ciewe's for integer overflow

644
00:35:34,380 --> 00:35:35,520
box

645
00:35:35,520 --> 00:35:40,020
the graph plots how many cves are found

646
00:35:40,020 --> 00:35:42,720
over time and it Compares three

647
00:35:42,720 --> 00:35:46,500
different walls of smartium

648
00:35:46,500 --> 00:35:48,420
the first mode

649
00:35:48,420 --> 00:35:51,359
runs without any data

650
00:35:51,359 --> 00:35:54,720
flow analysis and the second mode runs

651
00:35:54,720 --> 00:35:58,079
only with static data flow analysis and

652
00:35:58,079 --> 00:35:59,460
lastly

653
00:35:59,460 --> 00:36:01,339
the third one

654
00:36:01,339 --> 00:36:05,520
is runs at runs with both static and

655
00:36:05,520 --> 00:36:08,339
dynamic data flow analysis and this is

656
00:36:08,339 --> 00:36:10,560
the default mode of Samaritan

657
00:36:10,560 --> 00:36:13,200
and the graph shows that smartian can

658
00:36:13,200 --> 00:36:15,619
find books more

659
00:36:15,619 --> 00:36:19,560
effectively when both of the analysis

660
00:36:19,560 --> 00:36:22,079
are enabled

661
00:36:22,079 --> 00:36:25,079
so someone wants to know the results

662
00:36:25,079 --> 00:36:29,520
with Dynamic analysis only

663
00:36:29,520 --> 00:36:33,839
so I already experimented it compared to

664
00:36:33,839 --> 00:36:36,060
the aesthetic analysis only the

665
00:36:36,060 --> 00:36:39,420
performance was slightly lower in the

666
00:36:39,420 --> 00:36:43,020
case of only Dynamic analysis spot when

667
00:36:43,020 --> 00:36:44,880
with static and dynamic analysis it

668
00:36:44,880 --> 00:36:47,160
performs is the best

669
00:36:47,160 --> 00:36:50,400
and next we compared smartian against

670
00:36:50,400 --> 00:36:53,280
other testing tools we used the same

671
00:36:53,280 --> 00:36:56,760
Benchmark here but there were contracts

672
00:36:56,760 --> 00:36:59,640
that some of the tools failed to

673
00:36:59,640 --> 00:37:03,060
properly run those we excluded these

674
00:37:03,060 --> 00:37:06,300
contracts for fairness and then compare

675
00:37:06,300 --> 00:37:08,460
the smartian against other tools the

676
00:37:08,460 --> 00:37:11,220
result indicates the smartdown found at

677
00:37:11,220 --> 00:37:14,160
least two times more civil is than other

678
00:37:14,160 --> 00:37:15,359
tools

679
00:37:15,359 --> 00:37:18,240
we note that one of our comparison

680
00:37:18,240 --> 00:37:21,240
targets irf is missing here because it

681
00:37:21,240 --> 00:37:22,920
does not support integer overflow

682
00:37:22,920 --> 00:37:25,560
detection therefore we ran additional

683
00:37:25,560 --> 00:37:28,079
experiments for the compared

684
00:37:28,079 --> 00:37:32,420
so we constructed the second data set by

685
00:37:32,420 --> 00:37:35,579
extracting contracts from smartbox which

686
00:37:35,579 --> 00:37:38,160
is a benchmark with Label Box

687
00:37:38,160 --> 00:37:41,460
so they are various classes of box in

688
00:37:41,460 --> 00:37:44,400
the labels and we collected contracts

689
00:37:44,400 --> 00:37:47,660
that have this tribal classes because

690
00:37:47,660 --> 00:37:51,240
these bugs are supported by all of tools

691
00:37:51,240 --> 00:37:56,520
we tested again smartyan found the

692
00:37:56,520 --> 00:37:58,859
largest number of level bugs although

693
00:37:58,859 --> 00:38:01,859
the gap between smartian and B3

694
00:38:01,859 --> 00:38:05,220
is smaller this time

695
00:38:05,220 --> 00:38:08,280
one possible reason is that this

696
00:38:08,280 --> 00:38:10,920
Benchmark contains not only real world

697
00:38:10,920 --> 00:38:13,800
contracts but also artificially made Toy

698
00:38:13,800 --> 00:38:15,660
contracts where triggering bug is

699
00:38:15,660 --> 00:38:18,180
relatively easier

700
00:38:18,180 --> 00:38:21,660
so due to the limitation time I cannot

701
00:38:21,660 --> 00:38:23,280
present all the details of Martin

702
00:38:23,280 --> 00:38:27,060
therefore please refer to our paper

703
00:38:27,060 --> 00:38:29,480
if you are interested in the design

704
00:38:29,480 --> 00:38:32,940
details of our system or the result of

705
00:38:32,940 --> 00:38:34,320
War through

706
00:38:34,320 --> 00:38:36,839
evaluation

707
00:38:36,839 --> 00:38:39,900
so we believe there are

708
00:38:39,900 --> 00:38:41,700
lots of several interesting directions

709
00:38:41,700 --> 00:38:44,779
for future work

710
00:38:45,060 --> 00:38:48,839
and to support open open science and

711
00:38:48,839 --> 00:38:51,660
Foster future research we make smart and

712
00:38:51,660 --> 00:38:54,300
available at Guitar also we release the

713
00:38:54,300 --> 00:38:57,960
artifacts for evaluation so then our

714
00:38:57,960 --> 00:39:02,160
work can be reproduced easily so if you

715
00:39:02,160 --> 00:39:05,280
are interested in our work please visit

716
00:39:05,280 --> 00:39:09,480
our repository and try smartia

717
00:39:09,480 --> 00:39:13,320
so this is the end of my work and thank

718
00:39:13,320 --> 00:39:16,280
you for listening

