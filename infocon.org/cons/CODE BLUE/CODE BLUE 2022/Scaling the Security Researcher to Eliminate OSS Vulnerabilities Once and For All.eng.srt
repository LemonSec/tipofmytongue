1
00:00:00,000 --> 00:00:02,520
uh welcome to scaling the security

2
00:00:02,520 --> 00:00:04,560
researcher to eliminate open source

3
00:00:04,560 --> 00:00:06,240
security vulnerabilities once and for

4
00:00:06,240 --> 00:00:07,680
all

5
00:00:07,680 --> 00:00:10,679
um my name is Jonathan lychu I am a

6
00:00:10,679 --> 00:00:12,420
software engineer a software security

7
00:00:12,420 --> 00:00:15,059
researcher I am the first ever Dan

8
00:00:15,059 --> 00:00:16,980
Kaminsky fellow

9
00:00:16,980 --> 00:00:18,720
um I'm a GitHub star get up security

10
00:00:18,720 --> 00:00:21,119
Ambassador and you can find me on

11
00:00:21,119 --> 00:00:24,480
Twitter at jaylaichu and uh on GitHub at

12
00:00:24,480 --> 00:00:26,400
the same handle

13
00:00:26,400 --> 00:00:30,180
um so before I uh start I just want to

14
00:00:30,180 --> 00:00:32,220
put a brief disclaimer up

15
00:00:32,220 --> 00:00:34,380
um uh first off I'm sponsored by GitHub

16
00:00:34,380 --> 00:00:36,540
they give me a little bit so I just have

17
00:00:36,540 --> 00:00:38,100
to state that legally and then also we

18
00:00:38,100 --> 00:00:41,460
do discuss a SAS tool in this talk but

19
00:00:41,460 --> 00:00:43,500
it's available for free for open source

20
00:00:43,500 --> 00:00:45,120
and you can use it in your open source

21
00:00:45,120 --> 00:00:47,820
research as well

22
00:00:47,820 --> 00:00:49,500
um this work is supported by the Dan

23
00:00:49,500 --> 00:00:52,620
Kaminsky fellowship at human security

24
00:00:52,620 --> 00:00:55,440
um for those of you who don't know Dan

25
00:00:55,440 --> 00:00:58,260
um uh Dan was best known for a massive

26
00:00:58,260 --> 00:01:00,239
vulnerability that he found in DNS back

27
00:01:00,239 --> 00:01:02,579
in 2008. he was also known for his

28
00:01:02,579 --> 00:01:04,379
kindness and compassion in the

29
00:01:04,379 --> 00:01:06,420
information security Community he

30
00:01:06,420 --> 00:01:08,760
tragically passed away last year and the

31
00:01:08,760 --> 00:01:10,560
Dan Kaminsky Fellowship

32
00:01:10,560 --> 00:01:12,420
um I also never got to meet Dan

33
00:01:12,420 --> 00:01:14,760
unfortunately and the Dan Kaminsky

34
00:01:14,760 --> 00:01:16,979
Fellowship was created to celebrate uh

35
00:01:16,979 --> 00:01:19,080
dance memory and Legacy by funding open

36
00:01:19,080 --> 00:01:21,360
source work that makes the world a

37
00:01:21,360 --> 00:01:24,299
better and more secure place and so this

38
00:01:24,299 --> 00:01:25,560
is the work that I've been doing for the

39
00:01:25,560 --> 00:01:28,200
past year under this Fellowship

40
00:01:28,200 --> 00:01:30,740
spoilers

41
00:01:30,740 --> 00:01:33,360
I uh generated a bunch of pull requests

42
00:01:33,360 --> 00:01:36,000
to fix the vulnerability zip slip across

43
00:01:36,000 --> 00:01:38,460
the Java ecosystem in particular I

44
00:01:38,460 --> 00:01:41,640
generated 152 pull requests across the

45
00:01:41,640 --> 00:01:43,320
Java system

46
00:01:43,320 --> 00:01:46,020
um but there's uh there's a lot to the

47
00:01:46,020 --> 00:01:48,540
story so uh let's talk about how we got

48
00:01:48,540 --> 00:01:49,799
here

49
00:01:49,799 --> 00:01:52,259
um this story of bulk automated pull

50
00:01:52,259 --> 00:01:53,340
request generation to fix

51
00:01:53,340 --> 00:01:56,100
vulnerabilities at scale started with a

52
00:01:56,100 --> 00:01:58,320
simple vulnerability

53
00:01:58,320 --> 00:01:59,880
um and the vulnerability was this

54
00:01:59,880 --> 00:02:03,720
vulnerability it was the use of HTTP in

55
00:02:03,720 --> 00:02:06,600
my company's Gradle build to resolve

56
00:02:06,600 --> 00:02:08,758
dependencies and I found this code and

57
00:02:08,758 --> 00:02:10,560
I'm like how did this code get here and

58
00:02:10,560 --> 00:02:11,940
the reason that it got here was I'd

59
00:02:11,940 --> 00:02:13,860
copied and pasted this chunk of code

60
00:02:13,860 --> 00:02:16,560
from an open source Repository

61
00:02:16,560 --> 00:02:19,920
and the reason that HTTP is or https is

62
00:02:19,920 --> 00:02:21,959
important is because if you don't use

63
00:02:21,959 --> 00:02:24,239
https in your build infrastructure you

64
00:02:24,239 --> 00:02:25,860
can result in an attacker in the middle

65
00:02:25,860 --> 00:02:29,040
uh vulnerability and they can compromise

66
00:02:29,040 --> 00:02:31,920
the contents of your artifacts in flight

67
00:02:31,920 --> 00:02:34,440
and compromise the your supply chain

68
00:02:34,440 --> 00:02:36,900
your CI CD pipeline for your for your

69
00:02:36,900 --> 00:02:38,160
project

70
00:02:38,160 --> 00:02:39,840
and this is an example of that same

71
00:02:39,840 --> 00:02:43,860
vulnerability existing in um uh Maven uh

72
00:02:43,860 --> 00:02:46,140
where it exists in the download for your

73
00:02:46,140 --> 00:02:47,760
dependencies that are used for the

74
00:02:47,760 --> 00:02:50,040
compiler and test dependencies and so if

75
00:02:50,040 --> 00:02:52,379
that jar file is compromised mid-flight

76
00:02:52,379 --> 00:02:54,720
it can result in it being

77
00:02:54,720 --> 00:02:56,879
um uh you having malicious code executed

78
00:02:56,879 --> 00:02:58,620
in your CI CD pipeline or on your

79
00:02:58,620 --> 00:03:00,239
developer machines

80
00:03:00,239 --> 00:03:01,980
this is an example of where it exists in

81
00:03:01,980 --> 00:03:03,540
artifact upload which usually is

82
00:03:03,540 --> 00:03:05,760
associated with credentials and so an

83
00:03:05,760 --> 00:03:07,620
attacker could use those credentials to

84
00:03:07,620 --> 00:03:09,120
replace artifacts on your artifact

85
00:03:09,120 --> 00:03:11,580
server and this vulnerability was

86
00:03:11,580 --> 00:03:14,220
everywhere across the Java ecosystem

87
00:03:14,220 --> 00:03:17,959
it existed in projects like spring

88
00:03:17,959 --> 00:03:22,019
Red Hat kotlin Apache jet brains Jenkins

89
00:03:22,019 --> 00:03:26,519
Gradle groovy elastic Eclipse Foundation

90
00:03:26,519 --> 00:03:28,920
um it also impacted Oracle the NSA

91
00:03:28,920 --> 00:03:31,260
LinkedIn and stripe so organizations

92
00:03:31,260 --> 00:03:33,599
around the industry

93
00:03:33,599 --> 00:03:38,640
when I so Maven sonotype is the npm to

94
00:03:38,640 --> 00:03:40,739
the JavaScript ecosystem or the PIP to

95
00:03:40,739 --> 00:03:43,200
the python ecosystem sonotype is that to

96
00:03:43,200 --> 00:03:45,360
the Java ecosystem and when I reached

97
00:03:45,360 --> 00:03:47,819
out to them they said that 25 of their

98
00:03:47,819 --> 00:03:49,980
traffic was still using hdp to resolve

99
00:03:49,980 --> 00:03:53,280
dependencies instead of https this is in

100
00:03:53,280 --> 00:03:55,440
29 June of 2019.

101
00:03:55,440 --> 00:03:58,500
so how do we fix this vulnerability

102
00:03:58,500 --> 00:04:01,200
I reached uh pushed forward an

103
00:04:01,200 --> 00:04:04,080
initiative that on January 15 2020 all

104
00:04:04,080 --> 00:04:05,760
the major artifact servers in the Java

105
00:04:05,760 --> 00:04:07,319
ecosystem would decommission support for

106
00:04:07,319 --> 00:04:10,200
HTTP in favor of https only

107
00:04:10,200 --> 00:04:11,519
and

108
00:04:11,519 --> 00:04:15,060
um the major artifact servers uh decided

109
00:04:15,060 --> 00:04:16,680
yes we will do this and they published

110
00:04:16,680 --> 00:04:18,180
their blog post announcing that they

111
00:04:18,180 --> 00:04:19,440
would do this

112
00:04:19,440 --> 00:04:21,418
um in a coordinated manner

113
00:04:21,418 --> 00:04:23,180
however

114
00:04:23,180 --> 00:04:25,919
uh I reached out to sonotype again and

115
00:04:25,919 --> 00:04:28,860
in January of 2020 only a few days

116
00:04:28,860 --> 00:04:30,780
before the plan decommission of support

117
00:04:30,780 --> 00:04:33,960
of HTTP in favor of Rage GPS only they

118
00:04:33,960 --> 00:04:36,540
said that 20 of their traffic was still

119
00:04:36,540 --> 00:04:39,240
using http

120
00:04:39,240 --> 00:04:40,860
so

121
00:04:40,860 --> 00:04:43,940
you can imagine what might have happened

122
00:04:43,940 --> 00:04:48,380
on uh January 15 2020

123
00:04:48,780 --> 00:04:51,660
broken software everywhere because uh

124
00:04:51,660 --> 00:04:54,960
suddenly people's builds stopped working

125
00:04:54,960 --> 00:04:56,520
um but

126
00:04:56,520 --> 00:04:59,220
they stopped the bleeding

127
00:04:59,220 --> 00:05:00,479
sorry

128
00:05:00,479 --> 00:05:03,139
hang on

129
00:05:04,080 --> 00:05:06,900
we stopped the bleeding but what about

130
00:05:06,900 --> 00:05:09,540
the other repositories so these are the

131
00:05:09,540 --> 00:05:11,460
only the most commonly used repositories

132
00:05:11,460 --> 00:05:13,740
in the Java ecosystem Maven J Center

133
00:05:13,740 --> 00:05:15,840
spring and Gradle plug-in portal other

134
00:05:15,840 --> 00:05:17,940
organizations in the Java ecosystem host

135
00:05:17,940 --> 00:05:20,040
their own artifact servers and they're

136
00:05:20,040 --> 00:05:23,039
unlike npm or pip where there's one

137
00:05:23,039 --> 00:05:24,840
Central repository the Java ecosystem

138
00:05:24,840 --> 00:05:26,580
has been around for a long time and so

139
00:05:26,580 --> 00:05:29,840
multiple other repositories have have

140
00:05:29,840 --> 00:05:32,100
evolved to be used by organizations

141
00:05:32,100 --> 00:05:34,440
around the world to host artifacts

142
00:05:34,440 --> 00:05:36,479
so how do we fix the rest

143
00:05:36,479 --> 00:05:38,280
and he said well let's just go to the

144
00:05:38,280 --> 00:05:40,740
source of the problem and let's just fix

145
00:05:40,740 --> 00:05:42,900
it in the repositories themselves let's

146
00:05:42,900 --> 00:05:44,639
try bulk pull request generation to fix

147
00:05:44,639 --> 00:05:46,020
this vulnerability

148
00:05:46,020 --> 00:05:48,240
so how well the first thing that you

149
00:05:48,240 --> 00:05:49,620
need to do is you need to find the

150
00:05:49,620 --> 00:05:51,060
projects that are vulnerable because I

151
00:05:51,060 --> 00:05:52,680
knew that it was everywhere but how do

152
00:05:52,680 --> 00:05:54,960
you need a list of vulnerable projects

153
00:05:54,960 --> 00:05:57,000
and so for that I wrote this code ql

154
00:05:57,000 --> 00:05:58,560
query

155
00:05:58,560 --> 00:06:00,180
um and it's very simple little bit of

156
00:06:00,180 --> 00:06:02,220
code but it finds this vulnerability in

157
00:06:02,220 --> 00:06:05,639
mavenpom files codeql scans hundreds of

158
00:06:05,639 --> 00:06:08,220
thousands of Open Source projects

159
00:06:08,220 --> 00:06:09,960
um and you can use it to find

160
00:06:09,960 --> 00:06:12,440
vulnerabilities across open source

161
00:06:12,440 --> 00:06:15,539
and for this very simple query

162
00:06:15,539 --> 00:06:19,020
GitHub awarded me a 2 300 Bounty and so

163
00:06:19,020 --> 00:06:21,300
that gave me a list of projects that

164
00:06:21,300 --> 00:06:22,800
were vulnerable to this particular

165
00:06:22,800 --> 00:06:24,840
vulnerability and then I wrote a pull

166
00:06:24,840 --> 00:06:27,060
request generator to generate the fixes

167
00:06:27,060 --> 00:06:28,680
to generate the pull request to fix this

168
00:06:28,680 --> 00:06:29,880
vulnerability

169
00:06:29,880 --> 00:06:31,979
and so the first pull request generator

170
00:06:31,979 --> 00:06:34,919
was python based it was a wrapper over

171
00:06:34,919 --> 00:06:37,919
github's Hub CLI it had one nasty

172
00:06:37,919 --> 00:06:39,900
regular expression and a lot of logic

173
00:06:39,900 --> 00:06:41,160
for bouncing off of github's rate

174
00:06:41,160 --> 00:06:42,660
limiter

175
00:06:42,660 --> 00:06:44,699
and this is the logic

176
00:06:44,699 --> 00:06:46,680
um at a high level it's got an

177
00:06:46,680 --> 00:06:48,419
underlying engine

178
00:06:48,419 --> 00:06:50,100
um but it has all the logic for the

179
00:06:50,100 --> 00:06:51,780
commit message and the regular

180
00:06:51,780 --> 00:06:52,800
expression that's doing the

181
00:06:52,800 --> 00:06:54,600
transformation

182
00:06:54,600 --> 00:06:56,340
um and the file yeah fixing the

183
00:06:56,340 --> 00:06:58,800
vulnerable files and this is the regular

184
00:06:58,800 --> 00:07:01,319
expression and the reason that I used a

185
00:07:01,319 --> 00:07:04,259
regular expression to fix XML files is

186
00:07:04,259 --> 00:07:07,740
that if you use an XML parser

187
00:07:07,740 --> 00:07:10,319
any XML parser that you parse your

188
00:07:10,319 --> 00:07:13,020
source code into that XML parser and you

189
00:07:13,020 --> 00:07:14,639
make a modification

190
00:07:14,639 --> 00:07:17,220
will result in when you dump back out

191
00:07:17,220 --> 00:07:19,020
will dump the source code dump the code

192
00:07:19,020 --> 00:07:22,259
back out in the format of the parser not

193
00:07:22,259 --> 00:07:24,180
the format the file originally came in

194
00:07:24,180 --> 00:07:25,199
as

195
00:07:25,199 --> 00:07:27,180
and so if you don't use a regular

196
00:07:27,180 --> 00:07:29,400
expression unfortunately

197
00:07:29,400 --> 00:07:31,979
the XML that you'd end up having fixed

198
00:07:31,979 --> 00:07:33,660
the code in would end up with a massive

199
00:07:33,660 --> 00:07:35,520
white space change across the entire

200
00:07:35,520 --> 00:07:38,160
file and the maintainer who'd receive

201
00:07:38,160 --> 00:07:40,080
that pull request would be like great

202
00:07:40,080 --> 00:07:41,340
thank you so much for the contribution

203
00:07:41,340 --> 00:07:43,139
you fixed a vulnerability

204
00:07:43,139 --> 00:07:44,819
but you've changed the rest of the file

205
00:07:44,819 --> 00:07:47,759
so we can't accept it so you need to

206
00:07:47,759 --> 00:07:49,620
make targeted changes and so that only

207
00:07:49,620 --> 00:07:51,000
leaves you with regular Expressions

208
00:07:51,000 --> 00:07:53,460
unfortunately to fix this problem

209
00:07:53,460 --> 00:07:54,960
but the problem is if you regularly use

210
00:07:54,960 --> 00:07:57,720
regular Expressions to fix a problem

211
00:07:57,720 --> 00:07:59,520
now you end up with two problems the

212
00:07:59,520 --> 00:08:01,800
regular expression and the problem you

213
00:08:01,800 --> 00:08:03,840
originally had

214
00:08:03,840 --> 00:08:07,139
um regardless though it worked

215
00:08:07,139 --> 00:08:09,720
I generated pull requests

216
00:08:09,720 --> 00:08:11,280
um lots of them

217
00:08:11,280 --> 00:08:13,259
um and here's an example of the diff

218
00:08:13,259 --> 00:08:14,639
that was generated you can see the

219
00:08:14,639 --> 00:08:16,800
simple replacement use of HTTP and https

220
00:08:16,800 --> 00:08:18,660
in in the correct locations in this

221
00:08:18,660 --> 00:08:22,800
Maven Palm files and I generated 1 596

222
00:08:22,800 --> 00:08:24,900
pull requests across the Java ecosystem

223
00:08:24,900 --> 00:08:27,840
and this was back in 2020

224
00:08:27,840 --> 00:08:29,759
um as of 2022

225
00:08:29,759 --> 00:08:32,159
um there's been about a 40 merge rate of

226
00:08:32,159 --> 00:08:33,419
all these pull requests at this point

227
00:08:33,419 --> 00:08:35,760
which is a pretty significant uh number

228
00:08:35,760 --> 00:08:37,799
of vulnerable projects fixed across the

229
00:08:37,799 --> 00:08:39,299
Java ecosystem

230
00:08:39,299 --> 00:08:41,880
and for this work GitHub awarded me a

231
00:08:41,880 --> 00:08:43,679
four thousand dollar Bounty from the

232
00:08:43,679 --> 00:08:46,440
GitHub security lab bug Bounty program

233
00:08:46,440 --> 00:08:49,200
so I got hooked on this idea of bulk

234
00:08:49,200 --> 00:08:51,480
pull request generation as a solution to

235
00:08:51,480 --> 00:08:53,640
fix vulnerabilities at scale across open

236
00:08:53,640 --> 00:08:55,620
source

237
00:08:55,620 --> 00:08:57,180
um this is my GitHub contribution graph

238
00:08:57,180 --> 00:08:59,640
for 2020. and you can see there's two

239
00:08:59,640 --> 00:09:02,820
major Peaks where I did these campaigns

240
00:09:02,820 --> 00:09:05,160
um and you know had a and so

241
00:09:05,160 --> 00:09:06,779
um it's just it's really cool to see the

242
00:09:06,779 --> 00:09:08,519
you know the visual representation of

243
00:09:08,519 --> 00:09:10,140
the work you're doing

244
00:09:10,140 --> 00:09:13,200
so I have a problem

245
00:09:13,200 --> 00:09:14,580
and the problem

246
00:09:14,580 --> 00:09:16,920
um I have ADHD and that's not my problem

247
00:09:16,920 --> 00:09:18,839
I don't believe that ADHD is a problem

248
00:09:18,839 --> 00:09:21,779
but the problem is I love chasing

249
00:09:21,779 --> 00:09:25,380
squirrels I love chasing vulnerabilities

250
00:09:25,380 --> 00:09:27,360
and learning about them

251
00:09:27,360 --> 00:09:30,360
um I will read GitHub security advisory

252
00:09:30,360 --> 00:09:32,580
feeds or advisory feeds and I'll be

253
00:09:32,580 --> 00:09:34,620
curious about a vulnerability

254
00:09:34,620 --> 00:09:38,760
and I can find if I use GitHub codeql or

255
00:09:38,760 --> 00:09:41,519
if I use GitHub code search I can find

256
00:09:41,519 --> 00:09:43,560
those vulnerabilities everywhere so the

257
00:09:43,560 --> 00:09:45,120
problem that I have is because I chase

258
00:09:45,120 --> 00:09:47,760
squirrels I find too many security

259
00:09:47,760 --> 00:09:50,399
vulnerabilities in open source

260
00:09:50,399 --> 00:09:54,240
as an example this is a list of

261
00:09:54,240 --> 00:09:56,220
vulnerabilities called zip slip and

262
00:09:56,220 --> 00:09:57,480
we're going to get into what zip slip is

263
00:09:57,480 --> 00:09:58,920
later I know I've mentioned it twice now

264
00:09:58,920 --> 00:10:00,000
I'm going to mention a bunch of more

265
00:10:00,000 --> 00:10:01,740
times we'll dig into what zip slip is

266
00:10:01,740 --> 00:10:04,320
for those of you who don't know but this

267
00:10:04,320 --> 00:10:05,220
is a pretty critical security

268
00:10:05,220 --> 00:10:07,860
vulnerability and there are pages and

269
00:10:07,860 --> 00:10:11,100
pages and pages of this alert for this

270
00:10:11,100 --> 00:10:13,080
vulnerability in open source that you

271
00:10:13,080 --> 00:10:17,100
can find just by going to lgtm.com and

272
00:10:17,100 --> 00:10:19,800
punching and zip slip like you know

273
00:10:19,800 --> 00:10:22,860
there's more of this than I can

274
00:10:22,860 --> 00:10:25,980
reasonably report in open source so I'm

275
00:10:25,980 --> 00:10:26,940
finding too many security

276
00:10:26,940 --> 00:10:29,459
vulnerabilities so how do we get these

277
00:10:29,459 --> 00:10:31,080
vulnerabilities fixed so they don't just

278
00:10:31,080 --> 00:10:33,480
leave they don't just linger there we

279
00:10:33,480 --> 00:10:34,740
need automation

280
00:10:34,740 --> 00:10:36,420
to fix these vulnerabilities actually

281
00:10:36,420 --> 00:10:39,240
get them fixed and not just be alerts

282
00:10:39,240 --> 00:10:42,120
and so this is where

283
00:10:42,120 --> 00:10:45,240
um I need automated Transformations at

284
00:10:45,240 --> 00:10:46,980
massive scale

285
00:10:46,980 --> 00:10:48,959
and so this is where open rewrite comes

286
00:10:48,959 --> 00:10:50,100
in

287
00:10:50,100 --> 00:10:52,500
normally when you're compiling source

288
00:10:52,500 --> 00:10:55,320
code you have an the compiler produces

289
00:10:55,320 --> 00:10:57,120
what's called an abstract syntax tree

290
00:10:57,120 --> 00:11:00,360
it's a code or tree representation of

291
00:11:00,360 --> 00:11:02,760
the source code

292
00:11:02,760 --> 00:11:03,720
um and so if you want to make

293
00:11:03,720 --> 00:11:06,480
modifications to that AST

294
00:11:06,480 --> 00:11:08,880
um you can but the problem is that if

295
00:11:08,880 --> 00:11:10,920
you were to dump that AST back out into

296
00:11:10,920 --> 00:11:12,420
source code you'd lose all the

297
00:11:12,420 --> 00:11:13,680
formatting you'll notice that the

298
00:11:13,680 --> 00:11:16,380
spacing the tabs the comments all of

299
00:11:16,380 --> 00:11:17,459
those things are gone because the

300
00:11:17,459 --> 00:11:20,540
compiler doesn't care about those things

301
00:11:20,540 --> 00:11:24,660
and so what open rewrite provides is a

302
00:11:24,660 --> 00:11:26,579
format preserving abstract syntax tree

303
00:11:26,579 --> 00:11:30,120
and so the source code and the tree map

304
00:11:30,120 --> 00:11:31,980
back and forth to each other they are

305
00:11:31,980 --> 00:11:33,720
the same thing you can transform back

306
00:11:33,720 --> 00:11:35,880
and forth between the two of them

307
00:11:35,880 --> 00:11:38,880
and in addition you can generate new

308
00:11:38,880 --> 00:11:40,860
code that looks like the surrounding

309
00:11:40,860 --> 00:11:43,079
code because the as the parser is

310
00:11:43,079 --> 00:11:44,640
running and as the formatting is is

311
00:11:44,640 --> 00:11:46,560
getting grabbed you're also capturing

312
00:11:46,560 --> 00:11:49,140
the white space the tabs what the style

313
00:11:49,140 --> 00:11:51,899
is from this code base and so it learns

314
00:11:51,899 --> 00:11:53,820
what the code base is and so it can

315
00:11:53,820 --> 00:11:55,380
generate new code

316
00:11:55,380 --> 00:11:58,680
that uses the tabs or uses spaces

317
00:11:58,680 --> 00:12:02,040
and it's also fully type attributed

318
00:12:02,040 --> 00:12:03,660
um so the reason that's important right

319
00:12:03,660 --> 00:12:05,579
we don't know just looking at this code

320
00:12:05,579 --> 00:12:09,600
is that log4j slf4j log back right that

321
00:12:09,600 --> 00:12:11,399
might be really critical to know what

322
00:12:11,399 --> 00:12:13,620
type that is I know I can't imagine

323
00:12:13,620 --> 00:12:15,060
there ever being a massive security

324
00:12:15,060 --> 00:12:16,740
vulnerability in a logging framework

325
00:12:16,740 --> 00:12:20,240
that impacts the entire industry

326
00:12:20,459 --> 00:12:23,220
uh log4j anybody

327
00:12:23,220 --> 00:12:27,839
um anyways uh so and also open rewrites

328
00:12:27,839 --> 00:12:29,579
AST is both syntactically and

329
00:12:29,579 --> 00:12:31,200
semantically aware

330
00:12:31,200 --> 00:12:33,180
um that graph that grid on the left side

331
00:12:33,180 --> 00:12:35,040
is the amount of data that's Inc there's

332
00:12:35,040 --> 00:12:37,680
actually 6 000 nodes missing from that

333
00:12:37,680 --> 00:12:39,060
image on the left because it would just

334
00:12:39,060 --> 00:12:42,360
be fuzz so with the amount of data you

335
00:12:42,360 --> 00:12:44,220
end up with a lot of data and a lot of

336
00:12:44,220 --> 00:12:47,220
ability to un um to manipulate that data

337
00:12:47,220 --> 00:12:50,160
to do uh cool transformations

338
00:12:50,160 --> 00:12:52,380
and then if you want to add new code

339
00:12:52,380 --> 00:12:56,100
into the AST to modify it the problem is

340
00:12:56,100 --> 00:12:58,800
that even simple little changes in code

341
00:12:58,800 --> 00:13:02,399
create complex asts so let's say that I

342
00:13:02,399 --> 00:13:04,019
want to inject this little bit of code

343
00:13:04,019 --> 00:13:06,360
to fix a vulnerability the vulnerability

344
00:13:06,360 --> 00:13:08,040
zip slip this is the code that you want

345
00:13:08,040 --> 00:13:10,139
to fix this vulnerability

346
00:13:10,139 --> 00:13:12,240
well you need to place this in the code

347
00:13:12,240 --> 00:13:14,399
in the context of the surrounding code

348
00:13:14,399 --> 00:13:16,200
so open rewrite

349
00:13:16,200 --> 00:13:18,540
has a templating engine

350
00:13:18,540 --> 00:13:20,459
and the templating engine allows you to

351
00:13:20,459 --> 00:13:24,180
have variables and it also comes with a

352
00:13:24,180 --> 00:13:25,860
coordinate system that lets you state I

353
00:13:25,860 --> 00:13:28,380
want to place this chunk of code into

354
00:13:28,380 --> 00:13:29,940
the AST

355
00:13:29,940 --> 00:13:32,100
after this statement

356
00:13:32,100 --> 00:13:35,060
and that unlocks us the ability to

357
00:13:35,060 --> 00:13:37,380
specifically Target a specific location

358
00:13:37,380 --> 00:13:39,060
in the AST

359
00:13:39,060 --> 00:13:42,240
and generate and add that fix in and

360
00:13:42,240 --> 00:13:44,040
this is the fix for zip slip and again

361
00:13:44,040 --> 00:13:45,779
we'll go into what zip slip is in a

362
00:13:45,779 --> 00:13:47,100
little bit later

363
00:13:47,100 --> 00:13:49,500
so what's possible now

364
00:13:49,500 --> 00:13:51,480
what other vulnerabilities can we fix

365
00:13:51,480 --> 00:13:53,100
with the unlock that open rewrite

366
00:13:53,100 --> 00:13:54,540
provides

367
00:13:54,540 --> 00:13:56,220
I'm going to talk to you all about three

368
00:13:56,220 --> 00:13:58,200
vulnerabilities

369
00:13:58,200 --> 00:14:00,540
um temporary directory hijacking partial

370
00:14:00,540 --> 00:14:04,079
path traversal and zip slip and how I

371
00:14:04,079 --> 00:14:06,360
applied openrate to fixing these

372
00:14:06,360 --> 00:14:08,940
vulnerabilities across open source

373
00:14:08,940 --> 00:14:10,560
so the first vulnerability we're going

374
00:14:10,560 --> 00:14:12,180
to talk about is temporary directory

375
00:14:12,180 --> 00:14:13,399
hijacking

376
00:14:13,399 --> 00:14:15,959
temporary directory hijacking

377
00:14:15,959 --> 00:14:17,880
um the temporary system temp directory

378
00:14:17,880 --> 00:14:19,800
on unix-like systems is shared between

379
00:14:19,800 --> 00:14:22,560
all users so

380
00:14:22,560 --> 00:14:24,120
um and the impact of that is if you

381
00:14:24,120 --> 00:14:25,980
write sensitive files to the temporary

382
00:14:25,980 --> 00:14:27,600
directory and you haven't set the

383
00:14:27,600 --> 00:14:29,880
correct posix permissions on those files

384
00:14:29,880 --> 00:14:32,160
any other local users can view the

385
00:14:32,160 --> 00:14:33,839
contents of those directories those

386
00:14:33,839 --> 00:14:35,700
files or directories

387
00:14:35,700 --> 00:14:37,200
and this is temporary directory

388
00:14:37,200 --> 00:14:39,720
hijacking as it appears in the Java

389
00:14:39,720 --> 00:14:42,959
language or well what you'll see and the

390
00:14:42,959 --> 00:14:45,060
reason this pattern appears is that

391
00:14:45,060 --> 00:14:48,660
prior to Java 1.7 there did not exist an

392
00:14:48,660 --> 00:14:52,380
API to create temporary directories

393
00:14:52,380 --> 00:14:54,959
so people created temporary files using

394
00:14:54,959 --> 00:14:56,699
the Java's temporary direct file

395
00:14:56,699 --> 00:15:00,199
creation API which does create a a

396
00:15:00,199 --> 00:15:03,959
csprnj g generated securely generated

397
00:15:03,959 --> 00:15:06,420
name for the file but then they'd call

398
00:15:06,420 --> 00:15:09,600
delete and then they called maker and

399
00:15:09,600 --> 00:15:11,040
this has a vulnerability in it and the

400
00:15:11,040 --> 00:15:12,600
reason that you'd find this code again

401
00:15:12,600 --> 00:15:15,060
and again and again is because if you

402
00:15:15,060 --> 00:15:16,500
said I need to create a temp directory

403
00:15:16,500 --> 00:15:18,000
how do I do that and punch that into

404
00:15:18,000 --> 00:15:19,260
Google

405
00:15:19,260 --> 00:15:22,019
if you'd ask stack Overflow you'd get

406
00:15:22,019 --> 00:15:23,420
vulnerabilities

407
00:15:23,420 --> 00:15:25,740
and why is this vulnerable well the

408
00:15:25,740 --> 00:15:27,360
reason this is vulnerable is because

409
00:15:27,360 --> 00:15:29,519
there's a race condition here

410
00:15:29,519 --> 00:15:32,699
the race condition exists because maker

411
00:15:32,699 --> 00:15:35,820
if it fails because another user has

412
00:15:35,820 --> 00:15:36,899
beaten

413
00:15:36,899 --> 00:15:39,600
you to creating that directory

414
00:15:39,600 --> 00:15:42,600
then it returns false it does not throw

415
00:15:42,600 --> 00:15:44,220
an exception

416
00:15:44,220 --> 00:15:47,100
so the fix or one potential fix that

417
00:15:47,100 --> 00:15:49,019
you'll see is people putting this maker

418
00:15:49,019 --> 00:15:52,260
into a guard that throws an i o

419
00:15:52,260 --> 00:15:54,899
exception however this is insufficient

420
00:15:54,899 --> 00:15:57,060
still because that maker call does not

421
00:15:57,060 --> 00:16:00,060
set the correct posix permissions and so

422
00:16:00,060 --> 00:16:01,920
the contents of that directory are still

423
00:16:01,920 --> 00:16:05,160
exposed to other local users and so it's

424
00:16:05,160 --> 00:16:06,660
still this vulner this is still

425
00:16:06,660 --> 00:16:08,279
vulnerable to what's called temporary

426
00:16:08,279 --> 00:16:10,199
directory infra local information

427
00:16:10,199 --> 00:16:12,300
disclosure

428
00:16:12,300 --> 00:16:14,579
and so what's the real fix well the real

429
00:16:14,579 --> 00:16:18,360
fix is to use the new well very old but

430
00:16:18,360 --> 00:16:19,920
the one point Java will introduced in

431
00:16:19,920 --> 00:16:22,920
Java 1.7 Java 1.7 is very very old it's

432
00:16:22,920 --> 00:16:24,600
been around for a very long time you can

433
00:16:24,600 --> 00:16:27,360
safely use this API and this both

434
00:16:27,360 --> 00:16:29,519
creates a directory and also sets the

435
00:16:29,519 --> 00:16:31,260
correct posix permissions on the

436
00:16:31,260 --> 00:16:32,940
directory

437
00:16:32,940 --> 00:16:35,040
and so I've gotten a couple several cves

438
00:16:35,040 --> 00:16:36,959
for this vulnerability and I figured

439
00:16:36,959 --> 00:16:39,000
okay let's see what I can do you know

440
00:16:39,000 --> 00:16:40,560
I'm sure I've gotten a bunch of CVS for

441
00:16:40,560 --> 00:16:41,759
it but let's try to just fix this

442
00:16:41,759 --> 00:16:43,860
vulnerability across open source and so

443
00:16:43,860 --> 00:16:45,300
that's when I applied temporary

444
00:16:45,300 --> 00:16:47,820
directory uh pull request generation and

445
00:16:47,820 --> 00:16:49,620
for this particular vulnerability I've

446
00:16:49,620 --> 00:16:51,839
generated over 64 pull requests across

447
00:16:51,839 --> 00:16:53,160
the Java system to fix this

448
00:16:53,160 --> 00:16:54,899
vulnerability

449
00:16:54,899 --> 00:16:57,300
and so what does this look like well you

450
00:16:57,300 --> 00:16:59,160
can see that we're deleting the

451
00:16:59,160 --> 00:17:01,560
vulnerable lines and replacing it with

452
00:17:01,560 --> 00:17:04,199
that one safe line but also remember

453
00:17:04,199 --> 00:17:05,160
when I was talking to you about

454
00:17:05,160 --> 00:17:06,240
temporary directory information

455
00:17:06,240 --> 00:17:09,359
disclosure we can also fix that by

456
00:17:09,359 --> 00:17:11,640
deleting those if blocks and replacing

457
00:17:11,640 --> 00:17:15,559
it with that one non-vulnerable line

458
00:17:15,660 --> 00:17:17,280
um and that's all due to the power of

459
00:17:17,280 --> 00:17:19,679
open rewrite

460
00:17:19,679 --> 00:17:22,439
so vulnerability number two is a

461
00:17:22,439 --> 00:17:23,939
vulnerability called partial path

462
00:17:23,939 --> 00:17:25,500
traversal

463
00:17:25,500 --> 00:17:28,439
and partial path traversal exists let's

464
00:17:28,439 --> 00:17:30,059
assume that you have two users on a

465
00:17:30,059 --> 00:17:32,280
system you have user Sam and user

466
00:17:32,280 --> 00:17:33,660
Samantha

467
00:17:33,660 --> 00:17:36,299
and you want a Sandbox as a developer

468
00:17:36,299 --> 00:17:37,740
software developer you want to sandbox

469
00:17:37,740 --> 00:17:39,179
your logic

470
00:17:39,179 --> 00:17:42,000
to user Sam

471
00:17:42,000 --> 00:17:44,220
um partial past reversal allows an

472
00:17:44,220 --> 00:17:46,380
attacker access to a sibling directory

473
00:17:46,380 --> 00:17:49,559
with the same prefix so starting again

474
00:17:49,559 --> 00:17:51,480
we have user Sam and we've tried to

475
00:17:51,480 --> 00:17:54,840
sandbox our logic to only that and use a

476
00:17:54,840 --> 00:17:56,880
Samantha the reason that you an attacker

477
00:17:56,880 --> 00:17:58,500
could access user Samantha is because

478
00:17:58,500 --> 00:18:01,140
they share the same prefix

479
00:18:01,140 --> 00:18:03,419
and so this is the partial path

480
00:18:03,419 --> 00:18:05,640
traversal vulnerability

481
00:18:05,640 --> 00:18:08,340
well why is this vulnerable well the

482
00:18:08,340 --> 00:18:10,080
reason this logic is vulnerable is

483
00:18:10,080 --> 00:18:12,720
because when you call

484
00:18:12,720 --> 00:18:15,660
um when you call uh

485
00:18:15,660 --> 00:18:19,260
the method get canonical path on a file

486
00:18:19,260 --> 00:18:22,080
it returns a string

487
00:18:22,080 --> 00:18:24,179
that looks like this and you'll notice

488
00:18:24,179 --> 00:18:25,799
there's something missing from that

489
00:18:25,799 --> 00:18:26,700
string

490
00:18:26,700 --> 00:18:28,500
it's that trailing slash that was

491
00:18:28,500 --> 00:18:29,940
originally passed

492
00:18:29,940 --> 00:18:32,100
and so when you call starts with so get

493
00:18:32,100 --> 00:18:33,780
canonical path does what you normally

494
00:18:33,780 --> 00:18:37,620
wanted to do it normalizes the path

495
00:18:37,620 --> 00:18:39,960
um uh it normalizes the path so you

496
00:18:39,960 --> 00:18:41,940
remove the dot dot slash the path to

497
00:18:41,940 --> 00:18:43,919
versatile payloads

498
00:18:43,919 --> 00:18:46,440
um but it has this characteristic where

499
00:18:46,440 --> 00:18:47,940
it removes that trailing slash that you

500
00:18:47,940 --> 00:18:49,799
need for starts with comparisons

501
00:18:49,799 --> 00:18:52,620
and so when we have this Parent

502
00:18:52,620 --> 00:18:54,539
Directory this intended sandbox

503
00:18:54,539 --> 00:18:58,020
directory user Sam

504
00:18:58,020 --> 00:18:59,940
um and then we have an attacker payload

505
00:18:59,940 --> 00:19:03,120
come in past reversal Samantha slash baz

506
00:19:03,120 --> 00:19:05,880
when get canonical path gets called on

507
00:19:05,880 --> 00:19:07,080
that

508
00:19:07,080 --> 00:19:09,600
we end up with user slash Samantha slash

509
00:19:09,600 --> 00:19:13,500
baz starts with user Sam and that does

510
00:19:13,500 --> 00:19:16,020
indeed pass so this i o exception does

511
00:19:16,020 --> 00:19:18,200
not get thrown

512
00:19:18,200 --> 00:19:20,640
and so what's the fix for partial paths

513
00:19:20,640 --> 00:19:22,020
reversal

514
00:19:22,020 --> 00:19:26,340
well the fix for this is that you one

515
00:19:26,340 --> 00:19:28,559
solution is to re-add the file separator

516
00:19:28,559 --> 00:19:30,840
character back into the string for the

517
00:19:30,840 --> 00:19:32,760
starts with call

518
00:19:32,760 --> 00:19:35,400
um but the better fix is to use

519
00:19:35,400 --> 00:19:38,640
um the Java path API which was

520
00:19:38,640 --> 00:19:41,100
introduced in Java 1.7 which does these

521
00:19:41,100 --> 00:19:42,720
starts with comparison correctly on the

522
00:19:42,720 --> 00:19:44,400
correct path

523
00:19:44,400 --> 00:19:47,340
so how do we find this vulnerability

524
00:19:47,340 --> 00:19:49,620
so the way to find this vulnerability is

525
00:19:49,620 --> 00:19:52,320
to look for the Java string starts with

526
00:19:52,320 --> 00:19:55,380
call and then look for the subject and

527
00:19:55,380 --> 00:19:58,440
argument where the get canonical path is

528
00:19:58,440 --> 00:20:00,539
the argument being passed

529
00:20:00,539 --> 00:20:02,100
but we want to make sure that we're not

530
00:20:02,100 --> 00:20:05,039
fixing non-vulnerable code so we also

531
00:20:05,039 --> 00:20:06,419
want to look for cases where that file

532
00:20:06,419 --> 00:20:09,419
that separator uh character is passed

533
00:20:09,419 --> 00:20:11,520
and not fix it in this case

534
00:20:11,520 --> 00:20:14,220
but it can't be that easy right

535
00:20:14,220 --> 00:20:16,440
well developers write code in a lot of

536
00:20:16,440 --> 00:20:18,840
different ways so what if the developer

537
00:20:18,840 --> 00:20:20,940
writes their code like this

538
00:20:20,940 --> 00:20:23,280
where they extract that get canonical

539
00:20:23,280 --> 00:20:25,620
path to a to a variable

540
00:20:25,620 --> 00:20:28,559
or they put the parent into a variable

541
00:20:28,559 --> 00:20:31,860
as well how do we or they put the safe

542
00:20:31,860 --> 00:20:35,160
version like this how do we determine if

543
00:20:35,160 --> 00:20:37,500
this is vulnerable or not in this case

544
00:20:37,500 --> 00:20:39,539
well we need this New Concept it's

545
00:20:39,539 --> 00:20:41,580
called data flow analysis

546
00:20:41,580 --> 00:20:45,539
data flow analysis allows us to track

547
00:20:45,539 --> 00:20:48,600
the variable assignments of the data as

548
00:20:48,600 --> 00:20:50,940
it flows through the application as

549
00:20:50,940 --> 00:20:52,679
we're looking at the AST in the source

550
00:20:52,679 --> 00:20:54,840
code as we're making the modification

551
00:20:54,840 --> 00:20:57,780
and it lets us track you know this say

552
00:20:57,780 --> 00:20:59,940
that this this variable is safe so we

553
00:20:59,940 --> 00:21:01,380
don't need to fix this vulnerability and

554
00:21:01,380 --> 00:21:03,480
dataflow can even handle intermediate

555
00:21:03,480 --> 00:21:06,360
variable assignments as well

556
00:21:06,360 --> 00:21:08,580
so data flow uncovers hard to find

557
00:21:08,580 --> 00:21:10,320
vulnerabilities and helps us prevent

558
00:21:10,320 --> 00:21:12,419
false positives

559
00:21:12,419 --> 00:21:13,980
and

560
00:21:13,980 --> 00:21:15,299
um as a show of hands have any of you

561
00:21:15,299 --> 00:21:18,200
written code ql

562
00:21:18,299 --> 00:21:21,480
okay so if you've written any code ql

563
00:21:21,480 --> 00:21:23,700
um this is designed this API for data

564
00:21:23,700 --> 00:21:25,380
flow analysis is designed to be very

565
00:21:25,380 --> 00:21:27,419
similar to codeql's data flow analysis

566
00:21:27,419 --> 00:21:29,760
because I've written code ql before also

567
00:21:29,760 --> 00:21:32,220
let me translate my knowledge easier um

568
00:21:32,220 --> 00:21:34,140
but hopefully your knowledge can be

569
00:21:34,140 --> 00:21:35,880
transferred easier as well by using this

570
00:21:35,880 --> 00:21:36,900
API

571
00:21:36,900 --> 00:21:39,480
and so when we put all this together

572
00:21:39,480 --> 00:21:41,880
um you can find that this is vulnerable

573
00:21:41,880 --> 00:21:44,480
this logic and fix it appropriately

574
00:21:44,480 --> 00:21:49,100
because of the data flow analysis

575
00:21:49,320 --> 00:21:51,659
um I want to talk about an example case

576
00:21:51,659 --> 00:21:53,700
um there was a vulnerability in the AWS

577
00:21:53,700 --> 00:21:55,919
Java SDK

578
00:21:55,919 --> 00:21:57,299
um and this is the vulnerable you can

579
00:21:57,299 --> 00:21:58,559
see the partial path to versatile

580
00:21:58,559 --> 00:21:59,700
vulnerability right there because

581
00:21:59,700 --> 00:22:01,320
there's that starts with call on get

582
00:22:01,320 --> 00:22:03,059
canonical path

583
00:22:03,059 --> 00:22:05,039
um they were using this logic to

584
00:22:05,039 --> 00:22:07,679
determine if a as you're downloading the

585
00:22:07,679 --> 00:22:10,559
contents of it sorry as you're

586
00:22:10,559 --> 00:22:12,659
downloading the contents of an AWS

587
00:22:12,659 --> 00:22:16,140
bucket to your local machine

588
00:22:16,140 --> 00:22:18,419
um the entire contents is that is the

589
00:22:18,419 --> 00:22:21,419
AWS bucket key a past reversal payload

590
00:22:21,419 --> 00:22:23,159
that is attempting to escape the

591
00:22:23,159 --> 00:22:24,780
destination directory

592
00:22:24,780 --> 00:22:27,000
and so they were using this logic leaves

593
00:22:27,000 --> 00:22:29,280
root as a guard

594
00:22:29,280 --> 00:22:31,620
that tries to make sure that that does

595
00:22:31,620 --> 00:22:33,659
not happen

596
00:22:33,659 --> 00:22:36,120
um and so they did fix it there is a cve

597
00:22:36,120 --> 00:22:38,520
they they're but of course a little bit

598
00:22:38,520 --> 00:22:40,200
of vulnerability disclosure drama plays

599
00:22:40,200 --> 00:22:42,780
out uh in any good story

600
00:22:42,780 --> 00:22:45,120
um the AWS team said we'd love to award

601
00:22:45,120 --> 00:22:47,520
you a bug Bounty however we need you to

602
00:22:47,520 --> 00:22:49,980
sign a non-disclosure agreement

603
00:22:49,980 --> 00:22:52,140
and I said I normally don't agree to

604
00:22:52,140 --> 00:22:54,059
non-disclosure agreements can I read it

605
00:22:54,059 --> 00:22:56,460
before before potentially agreeing

606
00:22:56,460 --> 00:22:58,500
and the AWS team came back to me and

607
00:22:58,500 --> 00:23:00,480
said we're unable to share the bug

608
00:23:00,480 --> 00:23:02,280
Bounty program non-disclosure agreement

609
00:23:02,280 --> 00:23:04,140
since it and other contract documents

610
00:23:04,140 --> 00:23:05,640
are considered sensitive by the legal

611
00:23:05,640 --> 00:23:07,820
team

612
00:23:11,520 --> 00:23:13,639
um

613
00:23:14,460 --> 00:23:18,200
for any of you who played Pokemon

614
00:23:18,240 --> 00:23:21,240
um so yes that was a little bit of I

615
00:23:21,240 --> 00:23:23,460
still have not been paid by them

616
00:23:23,460 --> 00:23:25,200
it's an ongoing story

617
00:23:25,200 --> 00:23:27,240
um we'll see what happens

618
00:23:27,240 --> 00:23:28,559
um so the third vulnerability is a

619
00:23:28,559 --> 00:23:31,200
vulnerability called zip slip

620
00:23:31,200 --> 00:23:32,700
um now zip slip

621
00:23:32,700 --> 00:23:34,200
um we discussed a couple of times zip

622
00:23:34,200 --> 00:23:36,480
slip is a path traversal vulnerability

623
00:23:36,480 --> 00:23:38,940
while unplucking zip files zip files are

624
00:23:38,940 --> 00:23:41,220
basically a key value pair where the key

625
00:23:41,220 --> 00:23:43,080
is the director of the file that you

626
00:23:43,080 --> 00:23:45,780
want to unpack to and the value is the

627
00:23:45,780 --> 00:23:48,659
contents of the file but the key if it's

628
00:23:48,659 --> 00:23:50,340
a controlled by an attacker because

629
00:23:50,340 --> 00:23:52,559
you've been provided a malicious zip

630
00:23:52,559 --> 00:23:53,580
file

631
00:23:53,580 --> 00:23:57,000
could be a path to versatile payload

632
00:23:57,000 --> 00:24:00,600
and so this is zip slip this bit of code

633
00:24:00,600 --> 00:24:02,760
well why is this vulnerable

634
00:24:02,760 --> 00:24:05,460
it's vulnerable because you're using

635
00:24:05,460 --> 00:24:08,640
this entry this named entry in the zip

636
00:24:08,640 --> 00:24:12,240
zip file as the the way to create a file

637
00:24:12,240 --> 00:24:14,940
and so if that uh is a past reversal

638
00:24:14,940 --> 00:24:17,520
payload it can escape this directory and

639
00:24:17,520 --> 00:24:20,220
overwrite the contents of uh you know

640
00:24:20,220 --> 00:24:22,740
bin bash or something similar and that

641
00:24:22,740 --> 00:24:24,179
can allow an attacker to achieve remote

642
00:24:24,179 --> 00:24:26,280
code execution so ziplip is a critical

643
00:24:26,280 --> 00:24:28,980
vulnerability in the right scenarios

644
00:24:28,980 --> 00:24:31,620
zip slip is complicated and the reason

645
00:24:31,620 --> 00:24:34,080
that it's complicated is that

646
00:24:34,080 --> 00:24:37,679
this is a valid fix but the problem is

647
00:24:37,679 --> 00:24:41,600
that although this is a valid fix

648
00:24:42,059 --> 00:24:44,700
this is also a valid fix

649
00:24:44,700 --> 00:24:46,980
and again we don't want to fix code

650
00:24:46,980 --> 00:24:49,200
that's not vulnerable so how do we

651
00:24:49,200 --> 00:24:51,900
determine if we we're looking at this

652
00:24:51,900 --> 00:24:53,760
case or this case when we're looking

653
00:24:53,760 --> 00:24:56,100
just at the abstract syntax tree

654
00:24:56,100 --> 00:24:58,860
in code and so we need this New Concept

655
00:24:58,860 --> 00:25:01,080
again which is called control flow

656
00:25:01,080 --> 00:25:02,520
analysis

657
00:25:02,520 --> 00:25:05,100
so control flow analysis allows us to

658
00:25:05,100 --> 00:25:07,320
differentiate between these two bits of

659
00:25:07,320 --> 00:25:08,520
code that vulnerable and the

660
00:25:08,520 --> 00:25:10,260
non-vulnerable code

661
00:25:10,260 --> 00:25:13,320
and control flow analysis is a graph

662
00:25:13,320 --> 00:25:15,900
it's control flow analysis is

663
00:25:15,900 --> 00:25:18,299
represented by two data or two primary

664
00:25:18,299 --> 00:25:21,360
data structures basic blocks which make

665
00:25:21,360 --> 00:25:23,700
up the set of contiguous operations that

666
00:25:23,700 --> 00:25:25,919
are going to occur in a program without

667
00:25:25,919 --> 00:25:27,659
a jump occurring

668
00:25:27,659 --> 00:25:30,059
and then condition nodes where

669
00:25:30,059 --> 00:25:31,860
conditional logic will occur and there

670
00:25:31,860 --> 00:25:34,320
will be a branch in the execution of the

671
00:25:34,320 --> 00:25:35,700
program

672
00:25:35,700 --> 00:25:38,520
and so by generating the uh the control

673
00:25:38,520 --> 00:25:40,080
flow graph

674
00:25:40,080 --> 00:25:44,279
for a program like this we can look at

675
00:25:44,279 --> 00:25:47,460
the graph and determine that there is a

676
00:25:47,460 --> 00:25:49,200
check in place

677
00:25:49,200 --> 00:25:51,480
for this vulnerability and so we don't

678
00:25:51,480 --> 00:25:53,279
need to fit we don't need to generate a

679
00:25:53,279 --> 00:25:55,559
fix for this vulnerability

680
00:25:55,559 --> 00:25:57,659
and so when you put this all together we

681
00:25:57,659 --> 00:25:58,919
can determine that there is a

682
00:25:58,919 --> 00:26:00,240
vulnerability here

683
00:26:00,240 --> 00:26:01,980
and that we need to fix it and so

684
00:26:01,980 --> 00:26:05,100
generate the fix for the vulnerability

685
00:26:05,100 --> 00:26:07,080
and then we can even do more complicated

686
00:26:07,080 --> 00:26:08,460
things due to the power that open

687
00:26:08,460 --> 00:26:10,500
rewrite provides and you know even clean

688
00:26:10,500 --> 00:26:13,559
up the surrounding code a little bit too

689
00:26:13,559 --> 00:26:15,659
so let's get to the pull request

690
00:26:15,659 --> 00:26:17,760
generation part of this talk

691
00:26:17,760 --> 00:26:19,380
um if you have security vulnerabilities

692
00:26:19,380 --> 00:26:23,120
everybody gets a pull request

693
00:26:23,460 --> 00:26:24,960
so let's talk about the problems with

694
00:26:24,960 --> 00:26:27,000
pull request generation and one of the

695
00:26:27,000 --> 00:26:29,220
problems you'll run into is how fast you

696
00:26:29,220 --> 00:26:32,100
can generate pull requests across uh

697
00:26:32,100 --> 00:26:33,480
GitHub

698
00:26:33,480 --> 00:26:36,179
so when you're generating pull requests

699
00:26:36,179 --> 00:26:39,480
uh you need to do three there's uh six

700
00:26:39,480 --> 00:26:41,340
steps and there's three main three major

701
00:26:41,340 --> 00:26:43,500
categories file i o which is basically

702
00:26:43,500 --> 00:26:44,700
free because it's happening on your

703
00:26:44,700 --> 00:26:47,100
local machine git operations which are

704
00:26:47,100 --> 00:26:48,960
free on GitHub and do not incur rate

705
00:26:48,960 --> 00:26:51,480
limit and then GitHub API calls which

706
00:26:51,480 --> 00:26:52,919
are rate Limited

707
00:26:52,919 --> 00:26:54,299
so the first thing you need to do is

708
00:26:54,299 --> 00:26:56,159
check out the source code and download

709
00:26:56,159 --> 00:26:57,779
the code Repository

710
00:26:57,779 --> 00:26:59,880
and then you need to branch and apply

711
00:26:59,880 --> 00:27:01,440
the diff that was generated by open

712
00:27:01,440 --> 00:27:04,260
rewrite and then commit the change

713
00:27:04,260 --> 00:27:06,179
then you want to Fork the repository on

714
00:27:06,179 --> 00:27:07,260
GitHub

715
00:27:07,260 --> 00:27:09,720
rename the repository on GitHub and the

716
00:27:09,720 --> 00:27:11,460
reason that renaming the repository is

717
00:27:11,460 --> 00:27:12,840
important is because when you're

718
00:27:12,840 --> 00:27:15,240
generating tens hundreds or thousands of

719
00:27:15,240 --> 00:27:17,159
pull requests you're going to end up

720
00:27:17,159 --> 00:27:19,080
with name collisions and GitHub won't

721
00:27:19,080 --> 00:27:21,720
let you Fork repositories when you

722
00:27:21,720 --> 00:27:23,279
already have a repository with that same

723
00:27:23,279 --> 00:27:25,380
name so you need to change every

724
00:27:25,380 --> 00:27:27,179
repository's name to something that's

725
00:27:27,179 --> 00:27:28,440
unique

726
00:27:28,440 --> 00:27:30,600
and then you need to push the change

727
00:27:30,600 --> 00:27:32,039
and then you need to create the pull

728
00:27:32,039 --> 00:27:34,080
request on GitHub

729
00:27:34,080 --> 00:27:37,020
and so you'll notice there are three

730
00:27:37,020 --> 00:27:40,620
three API calls and GitHub asks that you

731
00:27:40,620 --> 00:27:42,299
wait at least one second between each

732
00:27:42,299 --> 00:27:43,620
one of these

733
00:27:43,620 --> 00:27:45,659
so that's three times the number of pull

734
00:27:45,659 --> 00:27:47,039
requests you're trying to generate

735
00:27:47,039 --> 00:27:49,320
number of seconds but then there's a

736
00:27:49,320 --> 00:27:51,360
secondary and tertiary rate limit that

737
00:27:51,360 --> 00:27:53,760
they document which is one of them is a

738
00:27:53,760 --> 00:27:55,500
header that says please back off until

739
00:27:55,500 --> 00:27:57,480
this point and then a third rate limit

740
00:27:57,480 --> 00:27:59,039
which is basically

741
00:27:59,039 --> 00:28:02,460
just stop for right now and it's not

742
00:28:02,460 --> 00:28:04,320
documented like how long you're supposed

743
00:28:04,320 --> 00:28:05,640
to wait so

744
00:28:05,640 --> 00:28:07,860
throw a sleep in there and hope for the

745
00:28:07,860 --> 00:28:09,299
best basically is what your what's your

746
00:28:09,299 --> 00:28:11,940
best option is at that point so GitHub

747
00:28:11,940 --> 00:28:13,980
if any of you are in the audience uh if

748
00:28:13,980 --> 00:28:15,480
you could stop Rave limiting or limit

749
00:28:15,480 --> 00:28:17,400
the rate limiting of your API it would

750
00:28:17,400 --> 00:28:19,860
be great and make my life a lot easier

751
00:28:19,860 --> 00:28:21,659
um so yes

752
00:28:21,659 --> 00:28:23,520
so we've made it this far

753
00:28:23,520 --> 00:28:26,159
the vulnerability has been detected the

754
00:28:26,159 --> 00:28:28,200
style has been detected the code has

755
00:28:28,200 --> 00:28:30,299
been fixed the diff has been generated

756
00:28:30,299 --> 00:28:33,840
and the rate limit has been bypassed

757
00:28:33,840 --> 00:28:35,760
um at this point I'm going to enter so

758
00:28:35,760 --> 00:28:37,080
how do we fix this for all the

759
00:28:37,080 --> 00:28:39,600
repositories across open source

760
00:28:39,600 --> 00:28:41,279
at this point I'm going to introduce you

761
00:28:41,279 --> 00:28:42,419
to Modern

762
00:28:42,419 --> 00:28:45,419
is free for open source projects

763
00:28:45,419 --> 00:28:47,039
um they've indexed about 7 000

764
00:28:47,039 --> 00:28:48,840
repositories

765
00:28:48,840 --> 00:28:50,279
um and it lets you run open rewrite

766
00:28:50,279 --> 00:28:52,380
Transformations at scale and it

767
00:28:52,380 --> 00:28:54,299
generates and lets you update those pull

768
00:28:54,299 --> 00:28:56,100
requests

769
00:28:56,100 --> 00:28:58,980
um there are over 800 recipes that

770
00:28:58,980 --> 00:29:01,140
modern and open read write contain

771
00:29:01,140 --> 00:29:03,960
inside of it and it lets you generate

772
00:29:03,960 --> 00:29:05,820
pull requests one of the use cases for

773
00:29:05,820 --> 00:29:09,659
example is let's say you need to update

774
00:29:09,659 --> 00:29:12,480
your version of uh spring you can do

775
00:29:12,480 --> 00:29:14,700
that but the problem is that if you want

776
00:29:14,700 --> 00:29:16,679
to use the latest version of spring and

777
00:29:16,679 --> 00:29:18,419
we all you know security practitioners

778
00:29:18,419 --> 00:29:19,740
know that running the latest version of

779
00:29:19,740 --> 00:29:21,419
spring in your Java applications is

780
00:29:21,419 --> 00:29:23,399
really important well for a lot of

781
00:29:23,399 --> 00:29:25,440
developers if you want to upgrade your

782
00:29:25,440 --> 00:29:27,059
version of spring you actually also have

783
00:29:27,059 --> 00:29:29,159
to upgrade your test framework

784
00:29:29,159 --> 00:29:31,500
and the test framework the latest

785
00:29:31,500 --> 00:29:33,600
version of spring will only be tested by

786
00:29:33,600 --> 00:29:35,039
junit 5.

787
00:29:35,039 --> 00:29:37,500
and there was an API break major API

788
00:29:37,500 --> 00:29:39,240
breaking change between junit 4 and J

789
00:29:39,240 --> 00:29:41,940
unit 5. and so you may not think of your

790
00:29:41,940 --> 00:29:44,880
testing framework as a security uh like

791
00:29:44,880 --> 00:29:46,320
what version of the secure testing

792
00:29:46,320 --> 00:29:48,419
framework you're using is a security

793
00:29:48,419 --> 00:29:51,120
um you know blocker to security but it

794
00:29:51,120 --> 00:29:52,980
really can be when you can't upgrade the

795
00:29:52,980 --> 00:29:54,600
version of spring because you're running

796
00:29:54,600 --> 00:29:57,059
low on running your old tests so there's

797
00:29:57,059 --> 00:29:58,860
a different there's a open rewrite

798
00:29:58,860 --> 00:30:00,240
transformation for migrating all your

799
00:30:00,240 --> 00:30:02,580
tests from the a previous June version

800
00:30:02,580 --> 00:30:04,919
to the latest version of junit

801
00:30:04,919 --> 00:30:06,840
and it also enables bulk pull request

802
00:30:06,840 --> 00:30:07,980
generation

803
00:30:07,980 --> 00:30:10,860
for across either your organization or

804
00:30:10,860 --> 00:30:13,260
across open source

805
00:30:13,260 --> 00:30:16,080
um as an example if you have a list of

806
00:30:16,080 --> 00:30:18,120
this is an actual result set that I was

807
00:30:18,120 --> 00:30:19,980
going to generate pull requests for you

808
00:30:19,980 --> 00:30:21,539
can say I want to generate this pull

809
00:30:21,539 --> 00:30:24,659
requests uh as a fork from a fork you

810
00:30:24,659 --> 00:30:26,220
can set the commit name you can set the

811
00:30:26,220 --> 00:30:28,020
pull request title you can provide the

812
00:30:28,020 --> 00:30:31,320
get the commit title you can supply your

813
00:30:31,320 --> 00:30:34,679
gpg key and then off to the races it'll

814
00:30:34,679 --> 00:30:36,120
it'll generate

815
00:30:36,120 --> 00:30:38,399
all the pull requests for you right

816
00:30:38,399 --> 00:30:40,260
within the SAS

817
00:30:40,260 --> 00:30:43,919
um and uh so this this is how I

818
00:30:43,919 --> 00:30:45,779
generated all these pull requests the

819
00:30:45,779 --> 00:30:48,179
most recent set of pull requests

820
00:30:48,179 --> 00:30:49,380
but there's more than just seven

821
00:30:49,380 --> 00:30:51,059
thousand repositories in the world how

822
00:30:51,059 --> 00:30:53,880
do we find the other vulnerable projects

823
00:30:53,880 --> 00:30:56,399
well this is where code ql comes in

824
00:30:56,399 --> 00:30:58,620
code ql index a hundred thousand open

825
00:30:58,620 --> 00:31:00,960
source projects and thirty five thousand

826
00:31:00,960 --> 00:31:03,000
Java projects so you can write a code

827
00:31:03,000 --> 00:31:04,980
Cloud query and get a list of vulnerable

828
00:31:04,980 --> 00:31:06,539
projects

829
00:31:06,539 --> 00:31:08,520
and then using that list of projects

830
00:31:08,520 --> 00:31:11,039
that I you now know are vulnerable if

831
00:31:11,039 --> 00:31:13,679
you provide that list into this CSV file

832
00:31:13,679 --> 00:31:17,640
in uh that's uh in uh under this GitHub

833
00:31:17,640 --> 00:31:19,080
repository

834
00:31:19,080 --> 00:31:21,480
modern after they've ingested this list

835
00:31:21,480 --> 00:31:23,520
will begin to index those repositories

836
00:31:23,520 --> 00:31:25,740
and you can run your recipes that you've

837
00:31:25,740 --> 00:31:28,679
created across these repositories that

838
00:31:28,679 --> 00:31:30,779
you've identified this vulnerability in

839
00:31:30,779 --> 00:31:33,419
so finally let's go generate some open

840
00:31:33,419 --> 00:31:35,340
source pull requests

841
00:31:35,340 --> 00:31:37,679
that's what I did

842
00:31:37,679 --> 00:31:40,559
um and some of the statistics for

843
00:31:40,559 --> 00:31:42,179
temporary directory hijacking I

844
00:31:42,179 --> 00:31:44,100
generated 64 pull requests with a 25

845
00:31:44,100 --> 00:31:45,539
merge rate

846
00:31:45,539 --> 00:31:47,279
50 pull requests for partial past

847
00:31:47,279 --> 00:31:49,919
reversal with a 22 merge rate and zip

848
00:31:49,919 --> 00:31:53,640
slip with 152 pull requests with a 20

849
00:31:53,640 --> 00:31:56,159
merge rate now I looked I haven't

850
00:31:56,159 --> 00:31:58,320
updated these statistics for about a

851
00:31:58,320 --> 00:32:00,960
month but I did this campaign in August

852
00:32:00,960 --> 00:32:04,980
of this year so the 40 merge rate was

853
00:32:04,980 --> 00:32:08,039
from 2019. so hopefully we will see more

854
00:32:08,039 --> 00:32:10,440
things get merged as maintainers notice

855
00:32:10,440 --> 00:32:11,820
their notification feeds and start

856
00:32:11,820 --> 00:32:13,679
merging pull requests it just takes time

857
00:32:13,679 --> 00:32:15,779
at this point

858
00:32:15,779 --> 00:32:18,659
um but in 2022 I've generated 600 new

859
00:32:18,659 --> 00:32:21,720
pull requests and in my history I've

860
00:32:21,720 --> 00:32:24,539
generated over 5 200 pull requests to my

861
00:32:24,539 --> 00:32:26,039
name

862
00:32:26,039 --> 00:32:28,559
one unlucky project was the recipient of

863
00:32:28,559 --> 00:32:31,020
all three pull requests

864
00:32:31,020 --> 00:32:34,500
um uh yes and this is my cam this is my

865
00:32:34,500 --> 00:32:38,580
GitHub uh uh profile uh for this year

866
00:32:38,580 --> 00:32:39,960
um

867
00:32:39,960 --> 00:32:41,820
so let's talk about some best practices

868
00:32:41,820 --> 00:32:44,460
of rock pull request generation

869
00:32:44,460 --> 00:32:46,679
the first thing is messaging

870
00:32:46,679 --> 00:32:49,559
you're reaching out to the so there's

871
00:32:49,559 --> 00:32:51,000
this saying

872
00:32:51,000 --> 00:32:52,620
all software problems are people

873
00:32:52,620 --> 00:32:54,360
problems in disguise

874
00:32:54,360 --> 00:32:56,820
and we are automating the generation of

875
00:32:56,820 --> 00:32:58,740
pull requests to fix a vulnerability at

876
00:32:58,740 --> 00:33:01,140
scale maintainers don't like Bots very

877
00:33:01,140 --> 00:33:03,600
much developers they like real people

878
00:33:03,600 --> 00:33:07,919
but yeah so you need to be considerate

879
00:33:07,919 --> 00:33:10,140
of communicating both why you're doing

880
00:33:10,140 --> 00:33:13,080
this but also the impact and then I

881
00:33:13,080 --> 00:33:14,940
think that you're a real person willing

882
00:33:14,940 --> 00:33:17,399
to communicate with them

883
00:33:17,399 --> 00:33:20,100
um so very important to maintain that

884
00:33:20,100 --> 00:33:22,559
human element in this in this Dynamic um

885
00:33:22,559 --> 00:33:23,700
even though you are throwing an

886
00:33:23,700 --> 00:33:25,740
automated solution to the problem

887
00:33:25,740 --> 00:33:28,620
and so some simpler lessons sign off on

888
00:33:28,620 --> 00:33:30,120
your commits

889
00:33:30,120 --> 00:33:31,320
um and the reason you want to sign off

890
00:33:31,320 --> 00:33:32,519
on your commits this is what a git

891
00:33:32,519 --> 00:33:34,679
commit sign off looks like

892
00:33:34,679 --> 00:33:36,240
um you just put this in the commit body

893
00:33:36,240 --> 00:33:38,640
and you might ask well why do I want to

894
00:33:38,640 --> 00:33:41,039
sign off on my commits well there was a

895
00:33:41,039 --> 00:33:42,720
bunch of lawsuits in open source a few

896
00:33:42,720 --> 00:33:45,179
years ago tldr

897
00:33:45,179 --> 00:33:46,799
lawyers

898
00:33:46,799 --> 00:33:47,960
um

899
00:33:47,960 --> 00:33:49,679
otherwise you'll get your commits

900
00:33:49,679 --> 00:33:52,740
rejected by evil dragon bureaucrats

901
00:33:52,740 --> 00:33:53,580
um

902
00:33:53,580 --> 00:33:55,200
be a good committee

903
00:33:55,200 --> 00:33:57,779
gpg sign your commits

904
00:33:57,779 --> 00:33:59,039
um this is what it looks like it just

905
00:33:59,039 --> 00:34:01,140
adds that verified badge otherwise

906
00:34:01,140 --> 00:34:02,880
you'll end up like Linus torvald who has

907
00:34:02,880 --> 00:34:04,559
been impersonated on GitHub several

908
00:34:04,559 --> 00:34:06,299
times

909
00:34:06,299 --> 00:34:09,599
um c-com seacom is a commit format for

910
00:34:09,599 --> 00:34:11,639
commit messages

911
00:34:11,639 --> 00:34:14,879
um for vulnerable ability fixes so

912
00:34:14,879 --> 00:34:16,199
um if you want a way to lay out your

913
00:34:16,199 --> 00:34:18,060
messages this might be a good thing to

914
00:34:18,060 --> 00:34:19,320
use

915
00:34:19,320 --> 00:34:21,899
there are uh Lesson Four there are risks

916
00:34:21,899 --> 00:34:23,760
to using your personal GitHub account

917
00:34:23,760 --> 00:34:25,500
by show of hands is anybody here

918
00:34:25,500 --> 00:34:29,359
familiar with github's angry unicorn

919
00:34:30,540 --> 00:34:33,060
no okay only me this is what gets what's

920
00:34:33,060 --> 00:34:34,619
what shows up when you've broken GitHub

921
00:34:34,619 --> 00:34:37,260
or something's gone wrong

922
00:34:37,260 --> 00:34:39,480
this is my GitHub profile for most of

923
00:34:39,480 --> 00:34:42,899
2020. I broke my GitHub account I

924
00:34:42,899 --> 00:34:44,820
although I did break my GitHub account I

925
00:34:44,820 --> 00:34:46,560
still recommend using a personal account

926
00:34:46,560 --> 00:34:49,379
for this as it keeps that human element

927
00:34:49,379 --> 00:34:53,040
involved in this Dynamic and maintainers

928
00:34:53,040 --> 00:34:55,260
are less likely to be upset if it and

929
00:34:55,260 --> 00:34:56,879
they're more likely to be upset if it

930
00:34:56,879 --> 00:34:59,040
looks like it's coming from a company or

931
00:34:59,040 --> 00:35:01,320
a bot than it is if it's coming from a

932
00:35:01,320 --> 00:35:03,180
real person

933
00:35:03,180 --> 00:35:05,760
lesson five coordinate with GitHub

934
00:35:05,760 --> 00:35:07,680
before attempting reach out to GitHub

935
00:35:07,680 --> 00:35:09,300
that's what I did

936
00:35:09,300 --> 00:35:11,640
um and let them know that you're going

937
00:35:11,640 --> 00:35:12,780
to do this they want to know they want

938
00:35:12,780 --> 00:35:14,400
to help you out

939
00:35:14,400 --> 00:35:16,700
lesson six consider the implications

940
00:35:16,700 --> 00:35:20,040
shortly after beginning this campaign I

941
00:35:20,040 --> 00:35:22,320
received this issue against my GitHub

942
00:35:22,320 --> 00:35:26,339
account uh jaylaichu security research

943
00:35:26,339 --> 00:35:28,980
is this responsible disclosure

944
00:35:28,980 --> 00:35:31,980
now I use the new the more nuanced term

945
00:35:31,980 --> 00:35:34,619
coordinated disclosure but the answer is

946
00:35:34,619 --> 00:35:37,859
no this is not responsible disclosure it

947
00:35:37,859 --> 00:35:39,900
is full public disclosure of a security

948
00:35:39,900 --> 00:35:42,200
vulnerability in an open source project

949
00:35:42,200 --> 00:35:47,000
you are odang a maintainer potentially

950
00:35:47,000 --> 00:35:50,339
unfortunately the the alternative for me

951
00:35:50,339 --> 00:35:52,079
is to not report the vulnerability at

952
00:35:52,079 --> 00:35:54,420
all because there's only so much time

953
00:35:54,420 --> 00:35:56,160
that I have in my day

954
00:35:56,160 --> 00:35:58,680
and I am overwhelmed

955
00:35:58,680 --> 00:36:01,980
and so I believe that this is a solid

956
00:36:01,980 --> 00:36:04,500
solution to fix these vulnerabilities at

957
00:36:04,500 --> 00:36:07,260
scale and best use my time

958
00:36:07,260 --> 00:36:08,700
to fix the to actually get these

959
00:36:08,700 --> 00:36:10,859
vulnerabilities fixed

960
00:36:10,859 --> 00:36:13,200
so in conclusion

961
00:36:13,200 --> 00:36:15,060
as security researchers and security

962
00:36:15,060 --> 00:36:16,740
practitioners

963
00:36:16,740 --> 00:36:18,660
I believe we have an obligation to

964
00:36:18,660 --> 00:36:20,940
society

965
00:36:20,940 --> 00:36:22,619
we know these vulnerabilities are out

966
00:36:22,619 --> 00:36:24,660
there we've seen them in pen test

967
00:36:24,660 --> 00:36:27,200
reports we've written them up ourselves

968
00:36:27,200 --> 00:36:29,520
we've been on the receiving end we know

969
00:36:29,520 --> 00:36:31,380
how to audit this code

970
00:36:31,380 --> 00:36:33,060
spoiler

971
00:36:33,060 --> 00:36:36,000
most software developers don't watch

972
00:36:36,000 --> 00:36:38,760
black hat talks or Defcon talks or code

973
00:36:38,760 --> 00:36:40,260
blue talks

974
00:36:40,260 --> 00:36:42,599
most developers are focused on

975
00:36:42,599 --> 00:36:44,339
developing the code to the features that

976
00:36:44,339 --> 00:36:46,560
they've been asked to develop

977
00:36:46,560 --> 00:36:48,420
there's this assistant there's this

978
00:36:48,420 --> 00:36:50,880
statistic that GitHub provided for every

979
00:36:50,880 --> 00:36:52,980
500 developers you have one security

980
00:36:52,980 --> 00:36:55,200
researcher

981
00:36:55,200 --> 00:36:59,040
we are heavily outnumbered as security

982
00:36:59,040 --> 00:37:01,560
practitioners

983
00:37:01,560 --> 00:37:05,339
and so I believe truly that automated

984
00:37:05,339 --> 00:37:07,980
bulk pull request generation is the best

985
00:37:07,980 --> 00:37:09,900
way for us to scale our knowledge of

986
00:37:09,900 --> 00:37:12,359
math science technology to fix

987
00:37:12,359 --> 00:37:14,820
vulnerabilities across open source at

988
00:37:14,820 --> 00:37:17,280
scale and actually see

989
00:37:17,280 --> 00:37:19,020
these vulnerabilities

990
00:37:19,020 --> 00:37:21,240
fixed finally

991
00:37:21,240 --> 00:37:23,760
and so with that I want to leave you

992
00:37:23,760 --> 00:37:25,380
with one final quote

993
00:37:25,380 --> 00:37:27,780
this is from Dan Kaminski it's on his

994
00:37:27,780 --> 00:37:29,760
Twitter profile and it's there to this

995
00:37:29,760 --> 00:37:30,960
day

996
00:37:30,960 --> 00:37:34,500
we can fix it we have the technology

997
00:37:34,500 --> 00:37:36,480
okay we need to create the technology

998
00:37:36,480 --> 00:37:38,760
all right the policy guys are mucking

999
00:37:38,760 --> 00:37:40,440
with the technology

1000
00:37:40,440 --> 00:37:42,119
relax

1001
00:37:42,119 --> 00:37:44,960
we're on it

1002
00:37:50,640 --> 00:37:53,700
and so uh just some final things uh

1003
00:37:53,700 --> 00:37:55,619
learn code ql it's an incredibly

1004
00:37:55,619 --> 00:37:57,060
powerful language

1005
00:37:57,060 --> 00:37:58,980
um contribute to open rewrite and you

1006
00:37:58,980 --> 00:38:00,720
can deploy your security fixes at scale

1007
00:38:00,720 --> 00:38:02,579
if you want to discuss this with other

1008
00:38:02,579 --> 00:38:04,440
people join the GitHub security lab and

1009
00:38:04,440 --> 00:38:07,320
open right slack channels and

1010
00:38:07,320 --> 00:38:09,300
um then also if you're interested in

1011
00:38:09,300 --> 00:38:11,839
open source security at in general

1012
00:38:11,839 --> 00:38:14,280
consider becoming involved in the open

1013
00:38:14,280 --> 00:38:16,560
source security Foundation there are

1014
00:38:16,560 --> 00:38:18,359
working group meetings not necessarily

1015
00:38:18,359 --> 00:38:19,800
in the right time zone for everybody in

1016
00:38:19,800 --> 00:38:21,300
Japan but there are working group

1017
00:38:21,300 --> 00:38:22,680
meetings that are happening on a daily

1018
00:38:22,680 --> 00:38:24,900
basis or on a weekly basis to discuss

1019
00:38:24,900 --> 00:38:27,119
the biggest issues facing open source

1020
00:38:27,119 --> 00:38:28,680
security around the end around the

1021
00:38:28,680 --> 00:38:30,240
industry

1022
00:38:30,240 --> 00:38:32,640
and with that I want to thank human my

1023
00:38:32,640 --> 00:38:34,920
employer for enabling the Dan Kaminsky

1024
00:38:34,920 --> 00:38:36,780
Fellowship modern for working with me

1025
00:38:36,780 --> 00:38:38,760
Lydia Giuliano the speak black hat

1026
00:38:38,760 --> 00:38:40,500
speaking coach that I worked with and

1027
00:38:40,500 --> 00:38:42,420
Sham my intern who came up with some of

1028
00:38:42,420 --> 00:38:43,859
the graphics you saw for control flow

1029
00:38:43,859 --> 00:38:45,359
analysis

1030
00:38:45,359 --> 00:38:50,240
um and this is me so thank you all

