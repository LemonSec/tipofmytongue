1
00:00:00,960 --> 00:00:03,959
okay uh good afternoon everyone uh today

2
00:00:03,959 --> 00:00:07,500
I want to talk about WS links virtual

3
00:00:07,500 --> 00:00:11,760
machine uh so WS link is a malware

4
00:00:11,760 --> 00:00:14,460
loader that we discovered last year it

5
00:00:14,460 --> 00:00:17,580
is likely linked to Lazarus and all this

6
00:00:17,580 --> 00:00:21,320
presentation we will focus on the VM

7
00:00:21,320 --> 00:00:24,779
edus to obfuscate these samples and we

8
00:00:24,779 --> 00:00:27,060
will discuss our approach to the

9
00:00:27,060 --> 00:00:28,800
obfuscate it

10
00:00:28,800 --> 00:00:31,560
so let's start I'll skip this

11
00:00:31,560 --> 00:00:34,440
introduction slide as I already was

12
00:00:34,440 --> 00:00:37,500
introduced and let's take a look at the

13
00:00:37,500 --> 00:00:40,320
agenda so we'll begin with an

14
00:00:40,320 --> 00:00:43,440
introduction into VMS in general and

15
00:00:43,440 --> 00:00:46,800
also simple execution because we use it

16
00:00:46,800 --> 00:00:50,360
frequently uh throughout the obfuscation

17
00:00:50,360 --> 00:00:54,239
after that we'll cover internals of the

18
00:00:54,239 --> 00:00:57,239
VM used in WS link

19
00:00:57,239 --> 00:00:59,280
and after that

20
00:00:59,280 --> 00:01:03,000
uh explain our approach to deal with the

21
00:01:03,000 --> 00:01:05,760
obfuscation and finally demonstrate it

22
00:01:05,760 --> 00:01:08,880
on a piece of bytecode to prove that it

23
00:01:08,880 --> 00:01:11,700
works and I'll also mention that after

24
00:01:11,700 --> 00:01:14,820
starting our analysis we discovered a

25
00:01:14,820 --> 00:01:18,960
sample that is not obfuscated so we

26
00:01:18,960 --> 00:01:22,020
weren't motivated to fully deophoscate

27
00:01:22,020 --> 00:01:24,479
the sample and we'll present it just on

28
00:01:24,479 --> 00:01:27,119
a piece of by code

29
00:01:27,119 --> 00:01:29,939
so now let's take a look at the VMS so

30
00:01:29,939 --> 00:01:32,340
we know that there are two types of VMS

31
00:01:32,340 --> 00:01:36,180
or system and process or system VMS are

32
00:01:36,180 --> 00:01:39,780
for example a VMware or virtualbox that

33
00:01:39,780 --> 00:01:42,500
virtualize the entire operating system

34
00:01:42,500 --> 00:01:46,140
and memile process VMS are for example

35
00:01:46,140 --> 00:01:49,200
Java virtual machine that allows us to

36
00:01:49,200 --> 00:01:50,600
execute

37
00:01:50,600 --> 00:01:53,340
application on different operating

38
00:01:53,340 --> 00:01:56,700
systems so how do

39
00:01:56,700 --> 00:01:59,939
oh sorry

40
00:01:59,939 --> 00:02:05,000
let me find laser pointer

41
00:02:05,579 --> 00:02:08,639
okay so actually um

42
00:02:08,639 --> 00:02:11,099
virtual machines work sort of like

43
00:02:11,099 --> 00:02:13,800
standard machines for example they both

44
00:02:13,800 --> 00:02:16,379
contain this sort of byte code but in

45
00:02:16,379 --> 00:02:18,739
standard machines is like machine code

46
00:02:18,739 --> 00:02:23,220
and it consists of op codes and operands

47
00:02:23,220 --> 00:02:26,280
where operands are like parameters for

48
00:02:26,280 --> 00:02:29,700
instructions and there are some handlers

49
00:02:29,700 --> 00:02:33,840
that basically Define the behavior of

50
00:02:33,840 --> 00:02:35,900
individual instructions

51
00:02:35,900 --> 00:02:39,300
and when we have bytecode like this we

52
00:02:39,300 --> 00:02:42,120
somehow need to transfer the execution

53
00:02:42,120 --> 00:02:44,160
from one virtual instruction to the

54
00:02:44,160 --> 00:02:48,120
other and we use an interpreter for this

55
00:02:48,120 --> 00:02:51,360
and here's a example of how it can work

56
00:02:51,360 --> 00:02:54,840
so we have a function that accepts a VM

57
00:02:54,840 --> 00:02:58,260
context which basically just like in

58
00:02:58,260 --> 00:03:00,660
standard machines contain some for

59
00:03:00,660 --> 00:03:03,180
example registers and program counter

60
00:03:03,180 --> 00:03:05,400
and things like that and apart from that

61
00:03:05,400 --> 00:03:07,140
byte code that is supposed to be

62
00:03:07,140 --> 00:03:09,360
executed

63
00:03:09,360 --> 00:03:13,019
so here we fetch an OP code from the

64
00:03:13,019 --> 00:03:15,840
byte code based on the current program

65
00:03:15,840 --> 00:03:18,800
counter after that increase that and

66
00:03:18,800 --> 00:03:22,200
execute one of the handlers

67
00:03:22,200 --> 00:03:24,680
and this can be actually performed in

68
00:03:24,680 --> 00:03:27,720
multiple ways this is actually called

69
00:03:27,720 --> 00:03:31,319
direct call trading because we store all

70
00:03:31,319 --> 00:03:35,459
the handlers in this table and depending

71
00:03:35,459 --> 00:03:38,340
on the value of code execute the

72
00:03:38,340 --> 00:03:40,200
particular one that is supposed to be

73
00:03:40,200 --> 00:03:41,340
executed

74
00:03:41,340 --> 00:03:43,620
and when we execute one of them we can

75
00:03:43,620 --> 00:03:47,700
see that for example the instructions

76
00:03:47,700 --> 00:03:50,159
can do whatever they want so the first

77
00:03:50,159 --> 00:03:51,019
one

78
00:03:51,019 --> 00:03:54,540
fetches to operands from the byte code

79
00:03:54,540 --> 00:03:57,540
base on the program counter increases

80
00:03:57,540 --> 00:04:00,959
that and then chooses a general purpose

81
00:04:00,959 --> 00:04:03,500
register based on that

82
00:04:03,500 --> 00:04:08,599
operand and performs an operation

83
00:04:10,439 --> 00:04:12,319
sorry

84
00:04:12,319 --> 00:04:17,298
yeah and this uh as I said it can be

85
00:04:17,298 --> 00:04:19,918
implemented on multiple ways for example

86
00:04:19,918 --> 00:04:22,860
instead of this direct call trading we

87
00:04:22,860 --> 00:04:25,919
can use for example a simple switch case

88
00:04:25,919 --> 00:04:28,500
or another technique is called direct

89
00:04:28,500 --> 00:04:31,740
threading where we basically move this

90
00:04:31,740 --> 00:04:35,400
call into all the handlers at the end of

91
00:04:35,400 --> 00:04:37,919
them so basically each virtual

92
00:04:37,919 --> 00:04:40,320
instructions execute the one that is

93
00:04:40,320 --> 00:04:41,580
supposed to be

94
00:04:41,580 --> 00:04:43,699
executed after that

95
00:04:43,699 --> 00:04:47,639
and The Interpreter only executes uh the

96
00:04:47,639 --> 00:04:49,919
first virtual instruction

97
00:04:49,919 --> 00:04:53,180
so how can we use this for obfuscation

98
00:04:53,180 --> 00:04:56,460
basically the strength of this

99
00:04:56,460 --> 00:04:59,340
obfuscation technique resides uh in the

100
00:04:59,340 --> 00:05:02,160
fact that the instruction set of the

101
00:05:02,160 --> 00:05:05,699
virtual machine is unknown and reverse

102
00:05:05,699 --> 00:05:08,400
engineer needs to

103
00:05:08,400 --> 00:05:11,639
understand all the instructions and

104
00:05:11,639 --> 00:05:17,160
somehow develop a custom disassembler to

105
00:05:17,160 --> 00:05:20,220
remove the protection and it's a really

106
00:05:20,220 --> 00:05:22,919
time consuming so how can we achieve

107
00:05:22,919 --> 00:05:24,419
this so

108
00:05:24,419 --> 00:05:28,080
let's say that this entire part these

109
00:05:28,080 --> 00:05:30,380
four blocks are actually located

110
00:05:30,380 --> 00:05:34,020
in a separate section inside of a file

111
00:05:34,020 --> 00:05:36,720
that PE file that is supposed to be

112
00:05:36,720 --> 00:05:40,759
obfuscated so we need to have there our

113
00:05:40,759 --> 00:05:44,340
custom VM and then when we take a

114
00:05:44,340 --> 00:05:49,139
function we need to translate it to the

115
00:05:49,139 --> 00:05:52,620
instructions set that our VM understands

116
00:05:52,620 --> 00:05:56,340
and generate bytecode of that and then

117
00:05:56,340 --> 00:05:59,580
store address of the bytecode somewhere

118
00:05:59,580 --> 00:06:04,020
inside executable and replace the

119
00:06:04,020 --> 00:06:07,259
original function with a call to our

120
00:06:07,259 --> 00:06:11,280
custom VM and remove the rest of the

121
00:06:11,280 --> 00:06:13,860
original instructions

122
00:06:13,860 --> 00:06:17,460
and after that when the VM is executed

123
00:06:17,460 --> 00:06:20,520
we need to choose the byte code which is

124
00:06:20,520 --> 00:06:22,440
supposed to be executed we can determine

125
00:06:22,440 --> 00:06:25,259
it for example based on the caller's

126
00:06:25,259 --> 00:06:26,300
address

127
00:06:26,300 --> 00:06:30,960
and then switch our context to Virtual

128
00:06:30,960 --> 00:06:34,919
because we were running like in the

129
00:06:34,919 --> 00:06:38,400
native one like we used registers like

130
00:06:38,400 --> 00:06:42,720
eax e BX and so on and we now need to

131
00:06:42,720 --> 00:06:45,840
move them to our virtual context and

132
00:06:45,840 --> 00:06:47,280
after that we can execute The

133
00:06:47,280 --> 00:06:49,319
Interpreter that understands this

134
00:06:49,319 --> 00:06:52,979
context and does some operations on it

135
00:06:52,979 --> 00:06:55,979
and after that we switch it back to

136
00:06:55,979 --> 00:06:58,560
Native so we just move on the virtual

137
00:06:58,560 --> 00:07:01,860
registers back to Native ones and then

138
00:07:01,860 --> 00:07:04,860
continue in the execution and we can

139
00:07:04,860 --> 00:07:07,080
apply this obfuscation for example on

140
00:07:07,080 --> 00:07:10,979
only specific functions that we need to

141
00:07:10,979 --> 00:07:11,639
um

142
00:07:11,639 --> 00:07:16,220
hide from some reverse engineers

143
00:07:24,060 --> 00:07:26,940
okay so let's look at symbolic execution

144
00:07:26,940 --> 00:07:28,860
we'll focus on the implementation in

145
00:07:28,860 --> 00:07:31,319
miasm because

146
00:07:31,319 --> 00:07:35,280
we'll use it in our code

147
00:07:35,280 --> 00:07:38,280
and so what it is it actually expresses

148
00:07:38,280 --> 00:07:42,020
a code in mathematical formulas

149
00:07:42,020 --> 00:07:44,759
registers and memory are treated as a

150
00:07:44,759 --> 00:07:46,620
sort of symbolic values and it

151
00:07:46,620 --> 00:07:49,500
summarizes codes effects on this

152
00:07:49,500 --> 00:07:52,979
symbolic values inside of a basic block

153
00:07:52,979 --> 00:07:55,680
so here we can see it on an example

154
00:07:55,680 --> 00:07:57,680
which should make it clear

155
00:07:57,680 --> 00:08:00,960
basically when we simply click execute

156
00:08:00,960 --> 00:08:05,160
this as a basic block we'll have in the

157
00:08:05,160 --> 00:08:07,800
result something like this so right away

158
00:08:07,800 --> 00:08:11,039
we can see what the resulting

159
00:08:11,039 --> 00:08:15,419
instruction pointer is which is like a

160
00:08:15,419 --> 00:08:18,539
almost the same as this IR DST which

161
00:08:18,539 --> 00:08:20,639
stands for intermediate representation

162
00:08:20,639 --> 00:08:23,099
destination which is sort of a program

163
00:08:23,099 --> 00:08:27,060
counter in miasm and these two can

164
00:08:27,060 --> 00:08:28,979
actually sometimes differ for example

165
00:08:28,979 --> 00:08:31,319
when we have instructions such as

166
00:08:31,319 --> 00:08:34,140
conditional move we translate it to

167
00:08:34,140 --> 00:08:38,940
multiple blocks in ir and

168
00:08:38,940 --> 00:08:43,200
basically we need to add a conditional

169
00:08:43,200 --> 00:08:45,360
jump inside of that that differs from

170
00:08:45,360 --> 00:08:48,000
the EIP

171
00:08:48,000 --> 00:08:51,000
and then we see that they are explicitly

172
00:08:51,000 --> 00:08:54,959
defined uh Flex

173
00:08:54,959 --> 00:08:56,700
and

174
00:08:56,700 --> 00:08:59,399
apart from that the

175
00:08:59,399 --> 00:09:02,399
semantics are sort of clear I think this

176
00:09:02,399 --> 00:09:05,100
is uh the reference or effort to build

177
00:09:05,100 --> 00:09:08,399
value and this expression might be a bit

178
00:09:08,399 --> 00:09:10,920
more difficult to understand it's called

179
00:09:10,920 --> 00:09:13,500
composition and it basically says that

180
00:09:13,500 --> 00:09:18,480
the first 16 bits of the resulting eax

181
00:09:18,480 --> 00:09:21,120
register are set to reference the value

182
00:09:21,120 --> 00:09:23,519
of ESI and

183
00:09:23,519 --> 00:09:27,240
the other 16 bits are set to the value

184
00:09:27,240 --> 00:09:30,019
of ebx

185
00:09:33,660 --> 00:09:36,839
yeah and how we can use this so it

186
00:09:36,839 --> 00:09:40,560
allows us to Simply Implement some no

187
00:09:40,560 --> 00:09:44,880
known concrete values so for example uh

188
00:09:44,880 --> 00:09:49,620
if we know that edx was set to 96 and

189
00:09:49,620 --> 00:09:52,260
the memory value at 96 is what's set to

190
00:09:52,260 --> 00:09:54,720
fit we can just tell it to the symbolic

191
00:09:54,720 --> 00:09:57,420
execution engine and after that we can

192
00:09:57,420 --> 00:09:59,100
right away see for example the

193
00:09:59,100 --> 00:10:01,019
destination address

194
00:10:01,019 --> 00:10:05,120
and that's it for introduction

195
00:10:06,600 --> 00:10:12,360
so after the publication of uh our work

196
00:10:12,360 --> 00:10:15,779
we found out that the VM used is

197
00:10:15,779 --> 00:10:18,600
actually code virtualizer used also in

198
00:10:18,600 --> 00:10:22,980
temida but uh still uh the structure

199
00:10:22,980 --> 00:10:25,940
hasn't been discussed publicly before

200
00:10:25,940 --> 00:10:28,040
and

201
00:10:28,040 --> 00:10:32,040
our theophisication technique neither so

202
00:10:32,040 --> 00:10:35,820
still interesting and when someone finds

203
00:10:35,820 --> 00:10:37,260
a

204
00:10:37,260 --> 00:10:40,860
unknown VM or he can use a similar

205
00:10:40,860 --> 00:10:43,920
approach to get over it

206
00:10:43,920 --> 00:10:46,500
okay so let's take a look at the

207
00:10:46,500 --> 00:10:49,320
virtualized sample so we open up the

208
00:10:49,320 --> 00:10:51,300
sampling either and look at the entry

209
00:10:51,300 --> 00:10:55,279
point we see this function and basically

210
00:10:55,279 --> 00:10:58,680
all the symbols that are in these

211
00:10:58,680 --> 00:11:00,839
examples are basically ours they are not

212
00:11:00,839 --> 00:11:03,000
original they were removed and we

213
00:11:03,000 --> 00:11:06,079
decided to call this function mm3 so

214
00:11:06,079 --> 00:11:09,000
this is a virtualized function and we

215
00:11:09,000 --> 00:11:11,459
can see that the prologue is basically

216
00:11:11,459 --> 00:11:13,920
the original one after that there's this

217
00:11:13,920 --> 00:11:16,200
code to BM entry and there there are

218
00:11:16,200 --> 00:11:18,600
just some gibberish instructions

219
00:11:18,600 --> 00:11:22,260
and either recognized seven uh calls to

220
00:11:22,260 --> 00:11:24,180
this VM entry which means that there are

221
00:11:24,180 --> 00:11:27,120
at least seven virtualized functions now

222
00:11:27,120 --> 00:11:28,440
before

223
00:11:28,440 --> 00:11:31,320
we jump into what VM what happens in

224
00:11:31,320 --> 00:11:35,040
vmn3 I will say that uh all over the

225
00:11:35,040 --> 00:11:37,440
code uh

226
00:11:37,440 --> 00:11:40,740
the VM uses a giant code which is

227
00:11:40,740 --> 00:11:44,640
basically insertion of instructions that

228
00:11:44,640 --> 00:11:46,880
are supposed to obscure

229
00:11:46,880 --> 00:11:50,160
the code so basically in the right

230
00:11:50,160 --> 00:11:52,339
picture we see

231
00:11:52,339 --> 00:11:55,940
or a part of the first basic block

232
00:11:55,940 --> 00:11:58,980
decompiled by Ida and we can see that

233
00:11:58,980 --> 00:12:01,380
it's a really difficult and hard to

234
00:12:01,380 --> 00:12:04,740
determine what's going on uh meanwhile a

235
00:12:04,740 --> 00:12:06,899
symbolic execution emails and the loved

236
00:12:06,899 --> 00:12:10,740
one helped us to simplify this and we

237
00:12:10,740 --> 00:12:13,920
can right away see that everything which

238
00:12:13,920 --> 00:12:16,860
what's happening in the block is pushing

239
00:12:16,860 --> 00:12:19,040
off some

240
00:12:19,040 --> 00:12:22,760
registers onto the stack

241
00:12:23,120 --> 00:12:26,339
now let's get back to the VM entry so

242
00:12:26,339 --> 00:12:28,980
what's going on so what's going on after

243
00:12:28,980 --> 00:12:29,820
that

244
00:12:29,820 --> 00:12:32,880
uh basically there are seven VM entry

245
00:12:32,880 --> 00:12:37,560
vmpra init entry functions and they are

246
00:12:37,560 --> 00:12:42,959
called from a VM entry and they are

247
00:12:42,959 --> 00:12:46,860
chosen uh based on the

248
00:12:46,860 --> 00:12:49,380
caller's address and they are supposed

249
00:12:49,380 --> 00:12:52,380
to choose the bytecode address that is

250
00:12:52,380 --> 00:12:54,620
supposed to be interpreted

251
00:12:54,620 --> 00:12:57,180
offset of the first virtual instruction

252
00:12:57,180 --> 00:12:59,940
that is supposed to be executed and

253
00:12:59,940 --> 00:13:03,660
store a CPU Flex after that all these VM

254
00:13:03,660 --> 00:13:07,399
Pro in it are called one common VM in it

255
00:13:07,399 --> 00:13:10,380
which is supposed to save the rest of

256
00:13:10,380 --> 00:13:13,200
the Native contacts on stack and

257
00:13:13,200 --> 00:13:15,240
optionally wait for another running

258
00:13:15,240 --> 00:13:19,260
virtualized block to end because all the

259
00:13:19,260 --> 00:13:22,139
threads actually share one common

260
00:13:22,139 --> 00:13:25,100
virtual context so they somehow need to

261
00:13:25,100 --> 00:13:27,779
manage and synchronize

262
00:13:27,779 --> 00:13:30,420
and after that they relocate internal

263
00:13:30,420 --> 00:13:34,440
constructs and finally execute the

264
00:13:34,440 --> 00:13:37,260
virtual instruction based on the offset

265
00:13:37,260 --> 00:13:39,899
and in the in this VM there are actually

266
00:13:39,899 --> 00:13:43,139
45 virtual instructions and they used

267
00:13:43,139 --> 00:13:45,839
direct threading as I said every

268
00:13:45,839 --> 00:13:47,880
instruction is supposed to execute the

269
00:13:47,880 --> 00:13:49,399
following one

270
00:13:49,399 --> 00:13:53,579
and what we discovered is that each of

271
00:13:53,579 --> 00:13:55,500
these 45 instructions is again

272
00:13:55,500 --> 00:13:58,139
virtualized with another VM that uses

273
00:13:58,139 --> 00:14:01,320
the same construct again some VMware in

274
00:14:01,320 --> 00:14:04,800
it one common VM in it and after that

275
00:14:04,800 --> 00:14:07,860
there's more than 1000 another virtual

276
00:14:07,860 --> 00:14:09,300
instructions

277
00:14:09,300 --> 00:14:11,420
and the reason is

278
00:14:11,420 --> 00:14:14,399
that they are actually duplicated and

279
00:14:14,399 --> 00:14:17,040
they will get to it more freely after

280
00:14:17,040 --> 00:14:19,139
this

281
00:14:19,139 --> 00:14:21,959
and I forgot to mention in Via minute

282
00:14:21,959 --> 00:14:24,899
that it actually also sets a virtual

283
00:14:24,899 --> 00:14:27,000
program counter or register

284
00:14:27,000 --> 00:14:31,200
and stores Base address uh that is later

285
00:14:31,200 --> 00:14:36,480
used to relocate uh structures and apis

286
00:14:36,480 --> 00:14:38,220
when they are supposed to be used or

287
00:14:38,220 --> 00:14:41,040
called and it also sets instruction

288
00:14:41,040 --> 00:14:44,459
table register to hard-coded value

289
00:14:44,459 --> 00:14:48,899
and all these registers are used by the

290
00:14:48,899 --> 00:14:51,860
virtual instructions later

291
00:14:52,500 --> 00:14:58,199
and now I will look at the first vm2

292
00:14:58,199 --> 00:15:00,060
virtual instructions that are executed

293
00:15:00,060 --> 00:15:02,839
in the bytecode

294
00:15:02,880 --> 00:15:05,160
so if we look at the structure of the

295
00:15:05,160 --> 00:15:07,760
first one here we see some RBP in it

296
00:15:07,760 --> 00:15:10,699
which is basically the context pointer

297
00:15:10,699 --> 00:15:14,100
and at the offset A4 is actually the

298
00:15:14,100 --> 00:15:16,079
mentioned instruction table

299
00:15:16,079 --> 00:15:17,820
and

300
00:15:17,820 --> 00:15:20,639
at least of the 28 it's virtual program

301
00:15:20,639 --> 00:15:25,100
counter so here we actually fetch

302
00:15:25,560 --> 00:15:28,860
sorry the next the ins address of the

303
00:15:28,860 --> 00:15:30,480
next instruction that is supposed to be

304
00:15:30,480 --> 00:15:35,160
executed after that uh increase the

305
00:15:35,160 --> 00:15:37,440
virtual program counter and set a

306
00:15:37,440 --> 00:15:39,720
register to zero and actually these

307
00:15:39,720 --> 00:15:41,760
operations are Atomic so they happen all

308
00:15:41,760 --> 00:15:44,480
at the same time

309
00:15:45,240 --> 00:15:47,699
now the the other the next two

310
00:15:47,699 --> 00:15:50,399
instructions the second one Set uh

311
00:15:50,399 --> 00:15:53,699
several virtual registers to zero and

312
00:15:53,699 --> 00:15:56,100
the third one just stores RSP in a

313
00:15:56,100 --> 00:15:57,800
virtual register

314
00:15:57,800 --> 00:16:00,720
and now the fourth one is interesting

315
00:16:00,720 --> 00:16:02,399
for the first time it uses multiple

316
00:16:02,399 --> 00:16:05,160
basic blocks and if we summarize it

317
00:16:05,160 --> 00:16:08,579
using symbolic execution we see an

318
00:16:08,579 --> 00:16:11,220
interesting expression actually these

319
00:16:11,220 --> 00:16:14,279
two virtual registers were set earlier

320
00:16:14,279 --> 00:16:17,180
to zero so we do know

321
00:16:17,180 --> 00:16:22,380
what their value should be and we should

322
00:16:22,380 --> 00:16:26,339
be able to simplify it and when we

323
00:16:26,339 --> 00:16:30,120
analyzed multiple instructions that are

324
00:16:30,120 --> 00:16:32,459
executed after this one found out that

325
00:16:32,459 --> 00:16:34,199
actually this construct is used

326
00:16:34,199 --> 00:16:35,519
repeatedly

327
00:16:35,519 --> 00:16:39,420
and it is supposed to encrypt operands

328
00:16:39,420 --> 00:16:42,540
and parameters of the

329
00:16:42,540 --> 00:16:45,420
virtual instructions and it is actually

330
00:16:45,420 --> 00:16:49,500
called rolling decryption and it's used

331
00:16:49,500 --> 00:16:52,320
also in VM product and this technique

332
00:16:52,320 --> 00:16:53,300
was

333
00:16:53,300 --> 00:16:56,579
described publicly before

334
00:16:56,579 --> 00:17:00,240
okay so if I manage to lose some of you

335
00:17:00,240 --> 00:17:04,140
now I'll explain uh how we uh the

336
00:17:04,140 --> 00:17:06,780
opuscate this so we should pay attention

337
00:17:06,780 --> 00:17:09,079
now

338
00:17:09,839 --> 00:17:12,359
okay so this is the first original block

339
00:17:12,359 --> 00:17:15,540
and we want to apply the known values we

340
00:17:15,540 --> 00:17:18,299
use symbolic execution and just tell the

341
00:17:18,299 --> 00:17:21,720
engine that this memory places or should

342
00:17:21,720 --> 00:17:25,140
be this particle values in our case zero

343
00:17:25,140 --> 00:17:27,540
and after that we can see that the

344
00:17:27,540 --> 00:17:30,120
engine simplified into the following

345
00:17:30,120 --> 00:17:34,020
form uh now we see this construct and

346
00:17:34,020 --> 00:17:36,780
again if we think about this this is

347
00:17:36,780 --> 00:17:40,260
actually a pointer to the bytecode so we

348
00:17:40,260 --> 00:17:42,900
access an operand and sort it against a

349
00:17:42,900 --> 00:17:46,500
value and again this complicated

350
00:17:46,500 --> 00:17:48,900
expression can be simplified because we

351
00:17:48,900 --> 00:17:52,620
have access to the byte code so

352
00:17:52,620 --> 00:17:55,380
we decided to make values that are

353
00:17:55,380 --> 00:17:58,460
relative to the

354
00:17:58,460 --> 00:18:01,280
virtual program counter or

355
00:18:01,280 --> 00:18:05,039
bytecode pointer or concrete and we

356
00:18:05,039 --> 00:18:08,039
apply the engine on it we can further

357
00:18:08,039 --> 00:18:11,280
simplify it and now it's not only the

358
00:18:11,280 --> 00:18:13,440
first block but we were able to simplify

359
00:18:13,440 --> 00:18:17,100
the conditional jump and now all these

360
00:18:17,100 --> 00:18:19,799
three or four basic blocks do is

361
00:18:19,799 --> 00:18:22,260
actually this in these four lines

362
00:18:22,260 --> 00:18:25,919
so here we actually uh fetch the value

363
00:18:25,919 --> 00:18:28,980
of the we get the next instruction that

364
00:18:28,980 --> 00:18:31,020
is supposed to be executed after that

365
00:18:31,020 --> 00:18:33,059
increase the virtual program counter and

366
00:18:33,059 --> 00:18:37,380
at offset one for one is actually the

367
00:18:37,380 --> 00:18:41,520
RSP distort RSP that I mentioned earlier

368
00:18:41,520 --> 00:18:43,200
and

369
00:18:43,200 --> 00:18:46,280
at the end we actually

370
00:18:46,280 --> 00:18:49,380
store a value that is on top of the

371
00:18:49,380 --> 00:18:52,860
stack uh inside of a register

372
00:18:52,860 --> 00:18:55,080
oh which basically means that this is a

373
00:18:55,080 --> 00:18:57,380
pop instruction because here we

374
00:18:57,380 --> 00:19:00,900
increase the the stack and here we pop

375
00:19:00,900 --> 00:19:03,299
the value and it is actually atomical so

376
00:19:03,299 --> 00:19:06,320
it happens at the same time

377
00:19:06,480 --> 00:19:08,940
so how can we use this studio and

378
00:19:08,940 --> 00:19:10,440
terabyte code so basically this is

379
00:19:10,440 --> 00:19:13,380
summary of one of the instructions and

380
00:19:13,380 --> 00:19:14,700
we want to

381
00:19:14,700 --> 00:19:18,059
build a control flow graph out of this

382
00:19:18,059 --> 00:19:20,280
to see what's going on inside of the

383
00:19:20,280 --> 00:19:25,020
byte and terabyte code and we during

384
00:19:25,020 --> 00:19:27,480
that treats and values as concrete are

385
00:19:27,480 --> 00:19:29,280
particularly rolling decryption

386
00:19:29,280 --> 00:19:32,039
registers and memory accesses relative

387
00:19:32,039 --> 00:19:33,919
to the bytecode pointer

388
00:19:33,919 --> 00:19:36,780
and we preserve only decryption

389
00:19:36,780 --> 00:19:40,260
registers values between blocks to have

390
00:19:40,260 --> 00:19:44,460
the actual value that is supposed to be

391
00:19:44,460 --> 00:19:47,700
inside of the registers at the time of

392
00:19:47,700 --> 00:19:53,059
execution of that particular instruction

393
00:19:53,700 --> 00:19:57,000
so this is a result of the first

394
00:19:57,000 --> 00:19:58,799
bytecode

395
00:19:58,799 --> 00:20:00,980
basically we can

396
00:20:00,980 --> 00:20:04,799
summarize the results into three parts

397
00:20:04,799 --> 00:20:08,640
like some intro outro and body of the

398
00:20:08,640 --> 00:20:11,700
instruction and actually here we see the

399
00:20:11,700 --> 00:20:13,919
virtualized virtual instructions from

400
00:20:13,919 --> 00:20:17,580
the first VM and in the beginning we see

401
00:20:17,580 --> 00:20:20,039
that there's a register set to zero then

402
00:20:20,039 --> 00:20:22,080
there's empty block and actually it

403
00:20:22,080 --> 00:20:23,700
contains the

404
00:20:23,700 --> 00:20:25,679
initiation of the Rolling decryption

405
00:20:25,679 --> 00:20:27,539
registers that we just skip because

406
00:20:27,539 --> 00:20:30,120
their values are not interesting after

407
00:20:30,120 --> 00:20:32,580
that we store RSP and then there's a

408
00:20:32,580 --> 00:20:34,799
series of Pop instruction

409
00:20:34,799 --> 00:20:38,460
s and basically we remember that the VM

410
00:20:38,460 --> 00:20:39,900
in it

411
00:20:39,900 --> 00:20:43,140
start or the native registers on the

412
00:20:43,140 --> 00:20:45,720
stack and now we are actually getting

413
00:20:45,720 --> 00:20:49,200
them back to the virtual context

414
00:20:49,200 --> 00:20:53,460
now let's take a look at the outro

415
00:20:53,460 --> 00:20:57,900
and we can see that in the beginning we

416
00:20:57,900 --> 00:21:01,200
push the virtual registers onto the

417
00:21:01,200 --> 00:21:03,900
stack after they pop them back to Native

418
00:21:03,900 --> 00:21:08,100
ones and then transfer the control uh to

419
00:21:08,100 --> 00:21:10,140
the next virtual instruction this is

420
00:21:10,140 --> 00:21:12,360
actually sort of jump to a register

421
00:21:12,360 --> 00:21:14,100
which is

422
00:21:14,100 --> 00:21:17,220
which looks just like the

423
00:21:17,220 --> 00:21:21,980
virtual instructions in the second VM

424
00:21:22,919 --> 00:21:27,240
and yeah this uh larger empty spaces

425
00:21:27,240 --> 00:21:30,120
actually separate individual virtual

426
00:21:30,120 --> 00:21:34,100
instructions of vm2

427
00:21:34,380 --> 00:21:37,380
okay now let's analyze the byte code of

428
00:21:37,380 --> 00:21:39,960
the first VM so the first three

429
00:21:39,960 --> 00:21:42,419
instructions behave just like those in

430
00:21:42,419 --> 00:21:45,840
vm2 but the fourth one is again a

431
00:21:45,840 --> 00:21:49,280
different uh it contains

432
00:21:49,280 --> 00:21:52,140
lots of basic blocks this is just a

433
00:21:52,140 --> 00:21:53,880
small part of it

434
00:21:53,880 --> 00:21:57,600
and when we inspected the code like more

435
00:21:57,600 --> 00:22:01,440
closely we found out what was the cause

436
00:22:01,440 --> 00:22:04,159
and the reason is instruction merging

437
00:22:04,159 --> 00:22:07,140
basically it can perform multiple

438
00:22:07,140 --> 00:22:09,659
operations and

439
00:22:09,659 --> 00:22:11,580
the operation that is supposed to be

440
00:22:11,580 --> 00:22:13,559
executed is decided based on the

441
00:22:13,559 --> 00:22:14,820
operands

442
00:22:14,820 --> 00:22:16,919
so in the fourth instruction there are

443
00:22:16,919 --> 00:22:19,440
for example these blocks and we can see

444
00:22:19,440 --> 00:22:22,620
that here's sort of push again we can

445
00:22:22,620 --> 00:22:25,140
see the RSP

446
00:22:25,140 --> 00:22:27,240
oh

447
00:22:27,240 --> 00:22:33,120
is decreased actually minus eight and

448
00:22:33,120 --> 00:22:36,299
a virtual register is stored on the

449
00:22:36,299 --> 00:22:37,200
stack

450
00:22:37,200 --> 00:22:40,020
and apart from it it can also perform

451
00:22:40,020 --> 00:22:42,780
pop here we see that the stack pointer

452
00:22:42,780 --> 00:22:44,880
is increased and

453
00:22:44,880 --> 00:22:47,159
the value at the top of the stack is

454
00:22:47,159 --> 00:22:50,580
stored inside of a memory

455
00:22:50,580 --> 00:22:53,880
and we can again simplify this by making

456
00:22:53,880 --> 00:22:57,179
this memory addresses and operands

457
00:22:57,179 --> 00:23:01,080
concrete and actually use the same

458
00:23:01,080 --> 00:23:05,100
approach as in vm2 we build a graph from

459
00:23:05,100 --> 00:23:07,799
the same summaries sheets certain values

460
00:23:07,799 --> 00:23:10,500
as concrete and preserve certain values

461
00:23:10,500 --> 00:23:14,760
between blocks or particularly the

462
00:23:14,760 --> 00:23:17,880
rolling decryption registers and we can

463
00:23:17,880 --> 00:23:20,480
actually process both VMS at once

464
00:23:20,480 --> 00:23:24,539
because we know what memory range

465
00:23:24,539 --> 00:23:26,880
belongs to the VMS that we know the

466
00:23:26,880 --> 00:23:30,840
context and we just trade them as the

467
00:23:30,840 --> 00:23:34,020
concrete values like the entire vm2 and

468
00:23:34,020 --> 00:23:37,320
ignore assignments into its context and

469
00:23:37,320 --> 00:23:40,620
now if we look at the results of the

470
00:23:40,620 --> 00:23:43,679
application of the entire virtual

471
00:23:43,679 --> 00:23:46,440
instruction of the entire bytecode of

472
00:23:46,440 --> 00:23:50,460
vm1 we expected a series of Pops again

473
00:23:50,460 --> 00:23:52,799
but there are some weird conditional

474
00:23:52,799 --> 00:23:54,480
branches

475
00:23:54,480 --> 00:23:58,740
and if we look a bit more at the

476
00:23:58,740 --> 00:24:00,960
branches we noticed that there's

477
00:24:00,960 --> 00:24:02,700
comparison of

478
00:24:02,700 --> 00:24:05,460
the

479
00:24:05,460 --> 00:24:07,799
virtual context pointer against a

480
00:24:07,799 --> 00:24:10,679
hard-coded value and there were like two

481
00:24:10,679 --> 00:24:14,039
or three patterns like this and we just

482
00:24:14,039 --> 00:24:19,080
we can just match them and eliminate uh

483
00:24:19,080 --> 00:24:22,380
these conditional jumps because we know

484
00:24:22,380 --> 00:24:26,400
what value belongs to RBP in it and this

485
00:24:26,400 --> 00:24:29,580
is actually sort of OPAC predicates

486
00:24:29,580 --> 00:24:32,640
and when we applied these values we

487
00:24:32,640 --> 00:24:34,919
actually the office get the byte code

488
00:24:34,919 --> 00:24:37,140
like completely

489
00:24:37,140 --> 00:24:39,179
and the question is does the approach

490
00:24:39,179 --> 00:24:43,260
work so before we compare

491
00:24:43,260 --> 00:24:46,679
our results against uh the discovered

492
00:24:46,679 --> 00:24:49,500
non-obfuscated sample we will look at

493
00:24:49,500 --> 00:24:51,480
some statistics

494
00:24:51,480 --> 00:24:53,240
so

495
00:24:53,240 --> 00:24:55,940
in the second VM

496
00:24:55,940 --> 00:24:59,159
or the most important thing is the third

497
00:24:59,159 --> 00:25:02,159
line uh actually we were able to

498
00:25:02,159 --> 00:25:06,240
simplify around 17 000 executed native

499
00:25:06,240 --> 00:25:07,820
instructions

500
00:25:07,820 --> 00:25:12,240
two three to about 300 or IR

501
00:25:12,240 --> 00:25:15,179
instructions and it took us like 10

502
00:25:15,179 --> 00:25:22,039
seconds and in the vm1 we were able to

503
00:25:22,340 --> 00:25:26,820
compress uh more than 3 and 0.5 million

504
00:25:26,820 --> 00:25:30,679
or native instructions into like 400

505
00:25:30,679 --> 00:25:33,779
lines of ir

506
00:25:33,779 --> 00:25:36,779
and since we wanted to

507
00:25:36,779 --> 00:25:39,480
analyze only one interesting sample this

508
00:25:39,480 --> 00:25:42,260
is perfectly fine

509
00:25:42,260 --> 00:25:44,760
considering that otherwise we would have

510
00:25:44,760 --> 00:25:48,539
to analyze all the 1000 instructions to

511
00:25:48,539 --> 00:25:51,600
know what's going on and if we use this

512
00:25:51,600 --> 00:25:54,900
approach it simplifies our work and

513
00:25:54,900 --> 00:25:57,779
makes it much faster

514
00:25:57,779 --> 00:26:00,659
so let's look at the comparison so in

515
00:26:00,659 --> 00:26:03,380
the left side there's

516
00:26:03,380 --> 00:26:06,179
the virtualized function and the right

517
00:26:06,179 --> 00:26:10,320
side the normal fuscated sample so the

518
00:26:10,320 --> 00:26:13,440
prologue is the same but there's then

519
00:26:13,440 --> 00:26:17,039
this difference in this assignment in

520
00:26:17,039 --> 00:26:19,020
the second image there's there are

521
00:26:19,020 --> 00:26:21,720
friends and in the first one or not

522
00:26:21,720 --> 00:26:25,559
but if you look at the results

523
00:26:25,559 --> 00:26:28,039
okay

524
00:26:28,080 --> 00:26:30,840
we see that the reference is applied

525
00:26:30,840 --> 00:26:33,140
later on

526
00:26:33,140 --> 00:26:37,559
and actually we can simplify these

527
00:26:37,559 --> 00:26:40,260
Expressions into a form of pseudocode is

528
00:26:40,260 --> 00:26:42,240
not supposed to be arm

529
00:26:42,240 --> 00:26:44,940
to compare it against the original

530
00:26:44,940 --> 00:26:47,760
sample or easier

531
00:26:47,760 --> 00:26:51,020
and we see that actually

532
00:26:51,020 --> 00:26:54,299
there's there are two same lines in the

533
00:26:54,299 --> 00:26:55,440
beginning

534
00:26:55,440 --> 00:26:58,279
and

535
00:26:59,039 --> 00:27:01,440
now we will continue the comparison we

536
00:27:01,440 --> 00:27:04,799
see that Texas is this service status uh

537
00:27:04,799 --> 00:27:07,440
structure and in the simplified view we

538
00:27:07,440 --> 00:27:10,980
see that we load uh service status

539
00:27:10,980 --> 00:27:14,640
structure into register and now we use

540
00:27:14,640 --> 00:27:16,980
uh the Base address register that I

541
00:27:16,980 --> 00:27:20,400
mentioned we use it to find the current

542
00:27:20,400 --> 00:27:24,140
address of the structure

543
00:27:25,860 --> 00:27:28,740
now we see that in both there's a loop

544
00:27:28,740 --> 00:27:33,080
and if we inspect the body

545
00:27:35,360 --> 00:27:39,240
uh we see that registers is being

546
00:27:39,240 --> 00:27:41,880
decreased and

547
00:27:41,880 --> 00:27:47,220
then we set a memory value or based on

548
00:27:47,220 --> 00:27:50,460
the decreased register to zero and it

549
00:27:50,460 --> 00:27:52,799
happens in both picture in both pictures

550
00:27:52,799 --> 00:27:55,158
yeah

551
00:27:57,960 --> 00:28:01,919
when we continue again we see the Base

552
00:28:01,919 --> 00:28:05,760
address register used and this time we

553
00:28:05,760 --> 00:28:09,659
find address of a function and store it

554
00:28:09,659 --> 00:28:11,580
inside of register and then do simple

555
00:28:11,580 --> 00:28:12,900
move

556
00:28:12,900 --> 00:28:15,960
and after that

557
00:28:15,960 --> 00:28:20,159
we call a function and in the bytecode

558
00:28:20,159 --> 00:28:23,520
we do it in a bit more complicated way

559
00:28:23,520 --> 00:28:26,400
again use the Base address register to

560
00:28:26,400 --> 00:28:29,159
find the current address of the

561
00:28:29,159 --> 00:28:31,140
API call

562
00:28:31,140 --> 00:28:34,159
and store it inside of a special

563
00:28:34,159 --> 00:28:37,559
internal internal register

564
00:28:37,559 --> 00:28:41,340
oh at offset one three three and now if

565
00:28:41,340 --> 00:28:46,140
we follow uh the register at the end we

566
00:28:46,140 --> 00:28:48,840
see that we actually jump into into its

567
00:28:48,840 --> 00:28:51,539
address and this basically performs the

568
00:28:51,539 --> 00:28:55,919
call and before that we set the return

569
00:28:55,919 --> 00:28:58,760
address of the code

570
00:28:58,760 --> 00:29:02,520
to function again uh

571
00:29:02,520 --> 00:29:04,799
relative to the Base address register

572
00:29:04,799 --> 00:29:08,760
and actually we choose a certain VMware

573
00:29:08,760 --> 00:29:13,440
in it uh based on the operands and when

574
00:29:13,440 --> 00:29:16,679
the call is after the call is executed

575
00:29:16,679 --> 00:29:19,140
we actually jump again to another VMware

576
00:29:19,140 --> 00:29:22,380
in it which means that there are certain

577
00:29:22,380 --> 00:29:24,419
blocks of functions virtualized like

578
00:29:24,419 --> 00:29:25,559
this

579
00:29:25,559 --> 00:29:27,799
okay

580
00:29:27,799 --> 00:29:30,179
and to the office get the entire

581
00:29:30,179 --> 00:29:32,700
function we would have to follow the

582
00:29:32,700 --> 00:29:34,980
next VM prayer in it and

583
00:29:34,980 --> 00:29:37,020
continue like this

584
00:29:37,020 --> 00:29:38,880
now what are the limitations of the

585
00:29:38,880 --> 00:29:40,860
approach basically they are the same as

586
00:29:40,860 --> 00:29:43,440
simple execution

587
00:29:43,440 --> 00:29:45,120
um since we use it

588
00:29:45,120 --> 00:29:47,340
and basically

589
00:29:47,340 --> 00:29:50,279
we cannot uh

590
00:29:50,279 --> 00:29:53,100
process instructions with unbounded

591
00:29:53,100 --> 00:29:55,620
loops using this approach and we need to

592
00:29:55,620 --> 00:29:59,179
address such instructions by other means

593
00:29:59,179 --> 00:30:03,120
for example some heuristics or manually

594
00:30:03,120 --> 00:30:06,960
but it's not such a problem because

595
00:30:06,960 --> 00:30:09,419
uh most of the instructions do not

596
00:30:09,419 --> 00:30:14,580
contain such loops and for example moves

597
00:30:14,580 --> 00:30:16,460
or and everything

598
00:30:16,460 --> 00:30:19,919
you can usually imagine is it can be

599
00:30:19,919 --> 00:30:21,899
processed like this

600
00:30:21,899 --> 00:30:24,299
and what is the takeaway

601
00:30:24,299 --> 00:30:28,559
we can use a symbolic execution to the

602
00:30:28,559 --> 00:30:32,279
virtualize some Advanced unknown VM or

603
00:30:32,279 --> 00:30:36,179
in arizonaable time if we treat the

604
00:30:36,179 --> 00:30:40,620
right values as concrete by Advanced we

605
00:30:40,620 --> 00:30:41,539
mean

606
00:30:41,539 --> 00:30:45,480
VMS that we use junk code duplicate and

607
00:30:45,480 --> 00:30:50,360
merge handlers and encrypt operands

608
00:30:54,539 --> 00:30:58,440
okay so that's it so you can find the

609
00:30:58,440 --> 00:31:02,700
wall by white paper at our site and the

610
00:31:02,700 --> 00:31:04,919
source code which is roughly like 400

611
00:31:04,919 --> 00:31:09,620
lines uh is in our git Repository

