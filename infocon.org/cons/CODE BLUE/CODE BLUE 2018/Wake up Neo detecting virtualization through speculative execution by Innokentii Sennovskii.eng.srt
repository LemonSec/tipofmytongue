1
00:00:05,100 --> 00:00:08,550
hello my name is Anna Kenji Sinofsky

2
00:00:06,840 --> 00:00:10,289
I'll be giving a talk wake up Neal

3
00:00:08,550 --> 00:00:13,019
detecting virtualization through

4
00:00:10,289 --> 00:00:13,619
speculative execution a little bit about

5
00:00:13,019 --> 00:00:16,619
myself

6
00:00:13,619 --> 00:00:18,840
I graduated this year from national

7
00:00:16,619 --> 00:00:21,930
Russian University MFE with an

8
00:00:18,840 --> 00:00:23,820
information security degree I'm a

9
00:00:21,930 --> 00:00:28,320
reverse engineering specialist at buy

10
00:00:23,820 --> 00:00:30,600
zone LLC I'm generally interested in

11
00:00:28,320 --> 00:00:32,219
applied cryptography reverse engineering

12
00:00:30,600 --> 00:00:34,710
hardware attacks and especially

13
00:00:32,219 --> 00:00:36,870
side-channel attacks and the talk I'm

14
00:00:34,710 --> 00:00:39,870
given is based on my discovery of

15
00:00:36,870 --> 00:00:42,690
spectral variant fear if you have any

16
00:00:39,870 --> 00:00:44,820
questions about the talk or want to

17
00:00:42,690 --> 00:00:49,739
contact me on another unrelated manner

18
00:00:44,820 --> 00:00:54,930
you can use this email or write me on

19
00:00:49,739 --> 00:00:58,980
Twitter so let's dive in modern CPU

20
00:00:54,930 --> 00:01:03,840
attacks on the x86 architecture go back

21
00:00:58,980 --> 00:01:08,840
from the first intro 8086 processor the

22
00:01:03,840 --> 00:01:12,630
CPUs back in the day were much less

23
00:01:08,840 --> 00:01:16,680
complex for example into 8086 used just

24
00:01:12,630 --> 00:01:20,130
16-bit registers if you you can only

25
00:01:16,680 --> 00:01:22,380
address one megabyte of memory through

26
00:01:20,130 --> 00:01:25,500
the use of segments there were no memory

27
00:01:22,380 --> 00:01:28,770
protections the only thing you could use

28
00:01:25,500 --> 00:01:31,350
was real mode the feature size was just

29
00:01:28,770 --> 00:01:34,259
three micrometers but at that time

30
00:01:31,350 --> 00:01:37,289
already they had a 6 byte prefetch so

31
00:01:34,260 --> 00:01:40,530
that you could load the next instruction

32
00:01:37,290 --> 00:01:44,340
while the current one was execution and

33
00:01:40,530 --> 00:01:47,040
there was no and there was even no SPU

34
00:01:44,340 --> 00:01:50,400
or floating-point unit inside so we had

35
00:01:47,040 --> 00:01:52,790
to buy a separate coprocessor just to

36
00:01:50,400 --> 00:01:57,720
operate on floating-point numbers

37
00:01:52,790 --> 00:02:00,840
obviously the cpus had to evolve to be

38
00:01:57,720 --> 00:02:04,229
able to manage and compute modern tasks

39
00:02:00,840 --> 00:02:06,930
one of the first things to come was the

40
00:02:04,229 --> 00:02:10,169
floating-point unit which is now only

41
00:02:06,930 --> 00:02:13,290
present we have an increased register

42
00:02:10,169 --> 00:02:14,489
size nowadays registers regular

43
00:02:13,290 --> 00:02:19,650
registers are up

44
00:02:14,490 --> 00:02:21,780
to 64-bits modern CPUs also have

45
00:02:19,650 --> 00:02:25,470
implemented protected mode and paging

46
00:02:21,780 --> 00:02:29,670
which allow for great many manipulation

47
00:02:25,470 --> 00:02:33,900
of memory space and allow multi-user

48
00:02:29,670 --> 00:02:36,859
environments to operate we have a single

49
00:02:33,900 --> 00:02:39,650
instruction multiple data MIT extensions

50
00:02:36,860 --> 00:02:42,930
which allow the user to execute

51
00:02:39,650 --> 00:02:48,930
simultaneous tasks on the same sets of

52
00:02:42,930 --> 00:02:51,240
data without using the same instructions

53
00:02:48,930 --> 00:02:53,790
and we even have system management mode

54
00:02:51,240 --> 00:03:01,190
for tasks specific to manipulation of

55
00:02:53,790 --> 00:03:05,850
hardware and precise management of power

56
00:03:01,190 --> 00:03:10,170
obviously the CP is today wouldn't be so

57
00:03:05,850 --> 00:03:14,760
welcome and so used if those were the

58
00:03:10,170 --> 00:03:17,609
only parts of the evolution the CPUs has

59
00:03:14,760 --> 00:03:20,549
become much more efficient they can

60
00:03:17,610 --> 00:03:22,530
process more data they're faster and the

61
00:03:20,550 --> 00:03:26,810
straightforward ways to increase this

62
00:03:22,530 --> 00:03:29,280
performance were usually bring

63
00:03:26,810 --> 00:03:33,620
increasing the frequency so that more

64
00:03:29,280 --> 00:03:36,090
operation could be completed in a single

65
00:03:33,620 --> 00:03:39,060
second and increasing the course so that

66
00:03:36,090 --> 00:03:41,580
you could split the operation into

67
00:03:39,060 --> 00:03:44,520
several cores and perform tasks

68
00:03:41,580 --> 00:03:48,000
simultaneously so basically just more

69
00:03:44,520 --> 00:03:52,260
power but this approach has its limits

70
00:03:48,000 --> 00:03:53,610
first one of the bottlenecks of CPU

71
00:03:52,260 --> 00:03:56,160
performance is memory access time

72
00:03:53,610 --> 00:04:00,840
obviously the CPU has to retrieve the

73
00:03:56,160 --> 00:04:02,850
data somehow and the data isn't stored

74
00:04:00,840 --> 00:04:06,900
on the CPU itself it has to it

75
00:04:02,850 --> 00:04:11,420
to access ram memory access is usually

76
00:04:06,900 --> 00:04:14,100
quite slow in terms of CPU cycles so

77
00:04:11,420 --> 00:04:15,899
that's one of the limits obviously

78
00:04:14,100 --> 00:04:18,810
increasing the frequency also decreases

79
00:04:15,900 --> 00:04:22,860
energy efficiency and can even overheat

80
00:04:18,810 --> 00:04:25,590
the CPU finally there are basic laws of

81
00:04:22,860 --> 00:04:32,590
nature for example if we try to

82
00:04:25,590 --> 00:04:35,198
operate a CPU at 500 gigahertz we would

83
00:04:32,590 --> 00:04:37,359
run into the problems with Einstein's

84
00:04:35,199 --> 00:04:43,090
theory of relativity we just wouldn't be

85
00:04:37,360 --> 00:04:45,729
able to do that so we had to imagine new

86
00:04:43,090 --> 00:04:48,030
ways of increasing performance without

87
00:04:45,729 --> 00:04:50,080
resorting to increase in frequency and

88
00:04:48,030 --> 00:04:52,438
increasing the number of cores such

89
00:04:50,080 --> 00:04:54,849
clever solutions include cache

90
00:04:52,439 --> 00:04:57,340
translation lookaside buffer

91
00:04:54,849 --> 00:05:01,479
hyper phrasing branch prediction and

92
00:04:57,340 --> 00:05:04,688
return stack buffers cache is a

93
00:05:01,479 --> 00:05:08,699
mechanism created to decrease in the

94
00:05:04,689 --> 00:05:12,490
number of memory accesses from the cpu

95
00:05:08,699 --> 00:05:15,550
basically what it does is a save data

96
00:05:12,490 --> 00:05:18,729
from previous accesses on the CPU so

97
00:05:15,550 --> 00:05:21,370
that the next time it doesn't have to go

98
00:05:18,729 --> 00:05:26,590
through to ram get the data and retrieve

99
00:05:21,370 --> 00:05:30,009
it back to the CPU in Intel processors

100
00:05:26,590 --> 00:05:30,599
there a free level of cache level 3 2 &

101
00:05:30,009 --> 00:05:34,270
1

102
00:05:30,599 --> 00:05:36,159
level 3 is the same for all course level

103
00:05:34,270 --> 00:05:41,639
2 levels 2 & 1

104
00:05:36,159 --> 00:05:44,919
are specific to each core and level 1 is

105
00:05:41,639 --> 00:05:47,520
also split into data cache and

106
00:05:44,919 --> 00:05:51,279
instruction cache which don't overlap

107
00:05:47,520 --> 00:05:54,520
they decrease in size from level 3 to

108
00:05:51,279 --> 00:05:59,020
level 1 and level 1 is much faster than

109
00:05:54,520 --> 00:06:01,539
level 3 and level 2 also we have to

110
00:05:59,020 --> 00:06:05,859
remember that cache is split into cache

111
00:06:01,539 --> 00:06:11,318
lines which means that if you retrieve

112
00:06:05,860 --> 00:06:13,629
one byte of data from Ram 6 16 bytes of

113
00:06:11,319 --> 00:06:15,129
data are actually placed on cache for

114
00:06:13,629 --> 00:06:17,889
example if you retrieve the first byte

115
00:06:15,129 --> 00:06:21,699
from a particular page the following 15

116
00:06:17,889 --> 00:06:24,069
bytes will also be saved

117
00:06:21,699 --> 00:06:26,889
so basically cache operates

118
00:06:24,069 --> 00:06:30,939
kind of like trying to look up an entry

119
00:06:26,889 --> 00:06:32,589
in an encyclopedia if you want to look

120
00:06:30,939 --> 00:06:34,479
up top the first time you have to go to

121
00:06:32,589 --> 00:06:36,099
the library check out the book and bring

122
00:06:34,479 --> 00:06:37,740
it home

123
00:06:36,099 --> 00:06:40,319
the next time you

124
00:06:37,740 --> 00:06:42,990
try to read the same entry you can just

125
00:06:40,319 --> 00:06:44,880
get it on your bookshelf at home and

126
00:06:42,990 --> 00:06:48,180
basically all your family members can

127
00:06:44,880 --> 00:06:50,039
get it too and the last level of cache

128
00:06:48,180 --> 00:06:51,569
the level one caches is when you have

129
00:06:50,039 --> 00:06:55,818
the book beside you and you just have to

130
00:06:51,569 --> 00:06:55,819
stretch your hand take it and look

131
00:06:57,440 --> 00:07:03,660
translation lookaside buffer czar kind

132
00:06:59,940 --> 00:07:05,330
of like a cache for paging patron is the

133
00:07:03,660 --> 00:07:08,280
mechanism which is used to translate

134
00:07:05,330 --> 00:07:09,979
virtual addresses into physical address

135
00:07:08,280 --> 00:07:14,369
space

136
00:07:09,979 --> 00:07:17,310
the problem with the modern views and

137
00:07:14,370 --> 00:07:21,889
with multi-user environments is that you

138
00:07:17,310 --> 00:07:25,949
can just use linear mapping of linear

139
00:07:21,889 --> 00:07:28,409
paging you have to manager the pages

140
00:07:25,949 --> 00:07:31,199
that are allocated for each user you

141
00:07:28,409 --> 00:07:33,210
have to load different pages and you

142
00:07:31,199 --> 00:07:35,520
have to set up specific addresses for

143
00:07:33,210 --> 00:07:40,770
example the address space for a colonel

144
00:07:35,520 --> 00:07:43,560
and for user mode is split so each axis

145
00:07:40,770 --> 00:07:47,070
of a particular set of data requires you

146
00:07:43,560 --> 00:07:51,030
first to go through the paging so we

147
00:07:47,070 --> 00:07:53,099
have to look the virtual the parts of

148
00:07:51,030 --> 00:07:57,989
the virtual address in several pages

149
00:07:53,099 --> 00:08:00,780
resulting in five four three accesses

150
00:07:57,990 --> 00:08:03,539
before you actually get the data which

151
00:08:00,780 --> 00:08:08,099
means that the time effects in the data

152
00:08:03,539 --> 00:08:12,240
without cache is five times slower than

153
00:08:08,099 --> 00:08:14,849
if we just use physical addresses to

154
00:08:12,240 --> 00:08:17,550
cope with that modern CPUs have this

155
00:08:14,849 --> 00:08:23,219
this translation lookaside buffer which

156
00:08:17,550 --> 00:08:25,110
save the the translation from virtual

157
00:08:23,219 --> 00:08:26,789
address to physical address or at least

158
00:08:25,110 --> 00:08:29,069
some steps of it for example which can

159
00:08:26,789 --> 00:08:35,520
cache page table entries or page

160
00:08:29,069 --> 00:08:37,829
directory entries one of the features

161
00:08:35,520 --> 00:08:41,250
with modern CPUs is that there are many

162
00:08:37,828 --> 00:08:42,539
different computing units you have as I

163
00:08:41,250 --> 00:08:44,700
previously said single instruction

164
00:08:42,539 --> 00:08:46,860
multiple data effects you have

165
00:08:44,700 --> 00:08:50,279
floating-point units you have the

166
00:08:46,860 --> 00:08:54,899
general register operations we

167
00:08:50,279 --> 00:08:57,899
used to compute different tasks the

168
00:08:54,899 --> 00:09:01,920
problem with the previous CPUs for

169
00:08:57,899 --> 00:09:05,910
example with Pentiums were that certain

170
00:09:01,920 --> 00:09:09,389
instructions was that there was a strong

171
00:09:05,910 --> 00:09:14,069
ordering of instructions that the CPU

172
00:09:09,389 --> 00:09:16,620
executed so if an instruction was going

173
00:09:14,069 --> 00:09:20,670
after a certain instruction it had to be

174
00:09:16,620 --> 00:09:22,889
executed in that particular order but at

175
00:09:20,670 --> 00:09:26,399
some point you know intro decided that

176
00:09:22,889 --> 00:09:28,259
well what's the problem with splitting

177
00:09:26,399 --> 00:09:32,240
the execution into several parts for

178
00:09:28,259 --> 00:09:35,430
example you can preemptively execute

179
00:09:32,240 --> 00:09:38,459
something on an unused part of the CPU

180
00:09:35,430 --> 00:09:42,989
for example if you are operating on

181
00:09:38,459 --> 00:09:48,119
general registers you can at the same

182
00:09:42,990 --> 00:09:51,689
time compute a future tasks on the SIMD

183
00:09:48,120 --> 00:09:55,949
extensions so we got out of order

184
00:09:51,689 --> 00:09:58,139
execution well the problem with out of

185
00:09:55,949 --> 00:10:00,479
order execution was to decide what to

186
00:09:58,139 --> 00:10:06,240
execute and for that purpose

187
00:10:00,480 --> 00:10:09,480
Intel implemented several techniques one

188
00:10:06,240 --> 00:10:11,550
is branch prediction branch prediction

189
00:10:09,480 --> 00:10:14,490
collects statistics collects information

190
00:10:11,550 --> 00:10:17,519
about previously executed branches

191
00:10:14,490 --> 00:10:20,040
previous jump previous calls and from

192
00:10:17,519 --> 00:10:24,120
that statistics it decides and when it

193
00:10:20,040 --> 00:10:27,689
meets similar conditions that probably

194
00:10:24,120 --> 00:10:31,230
the next branch the next jump is going

195
00:10:27,689 --> 00:10:34,139
to go to this location so while we are

196
00:10:31,230 --> 00:10:36,240
executing our current tasks we can start

197
00:10:34,139 --> 00:10:39,929
on that task with a different part of

198
00:10:36,240 --> 00:10:44,429
the CPU return start return stack

199
00:10:39,929 --> 00:10:46,829
buffers contain up to 16 return

200
00:10:44,429 --> 00:10:50,519
indications for previous calls so

201
00:10:46,829 --> 00:10:57,420
basically each time you use a call in

202
00:10:50,519 --> 00:11:00,689
info x86 or x64 and the location to

203
00:10:57,420 --> 00:11:03,689
which the function you are calling has

204
00:11:00,689 --> 00:11:05,790
to return is cached in this

205
00:11:03,690 --> 00:11:09,960
returns tech buffer which is on the CPU

206
00:11:05,790 --> 00:11:16,020
and if the execution takes a long time

207
00:11:09,960 --> 00:11:18,960
then the CPU starts to compute the data

208
00:11:16,020 --> 00:11:21,829
and execute the instructions after the

209
00:11:18,960 --> 00:11:24,360
actual call getting the information

210
00:11:21,830 --> 00:11:26,310
which it has to execute from return

211
00:11:24,360 --> 00:11:30,990
stack buffer this is what's caused

212
00:11:26,310 --> 00:11:34,709
speculative execution now speculative

213
00:11:30,990 --> 00:11:36,570
execution is a little bit like standing

214
00:11:34,710 --> 00:11:39,570
in queue for ice cream for example you

215
00:11:36,570 --> 00:11:40,920
have two flavors a and B you and your

216
00:11:39,570 --> 00:11:43,290
friends are waiting and one of you

217
00:11:40,920 --> 00:11:45,599
decides to go and get drinks the problem

218
00:11:43,290 --> 00:11:48,510
is that a particular flavor of ice cream

219
00:11:45,600 --> 00:11:51,300
only works with a particular flavor of

220
00:11:48,510 --> 00:11:55,890
drink the guy gets the drink then you

221
00:11:51,300 --> 00:11:58,680
meet and you see that you mismatched you

222
00:11:55,890 --> 00:12:00,360
got the flavor of ice cream which

223
00:11:58,680 --> 00:12:03,239
doesn't work with this particular drink

224
00:12:00,360 --> 00:12:06,120
what you have to do after that is get

225
00:12:03,240 --> 00:12:09,570
the drink you really need so basically

226
00:12:06,120 --> 00:12:13,020
you discard the thing you got before and

227
00:12:09,570 --> 00:12:15,240
do it in you that's how a speculative

228
00:12:13,020 --> 00:12:17,280
execution works if there are some

229
00:12:15,240 --> 00:12:20,430
problems for example if you don't

230
00:12:17,280 --> 00:12:23,640
actually return to the predetermined

231
00:12:20,430 --> 00:12:26,939
place then in just discards the data

232
00:12:23,640 --> 00:12:29,010
that was computed it performs all the

233
00:12:26,940 --> 00:12:31,190
checks and you have to do everything in

234
00:12:29,010 --> 00:12:31,189
you

235
00:12:31,980 --> 00:12:37,350
so speculative execution wouldn't be as

236
00:12:35,850 --> 00:12:40,910
important today and that's problematic

237
00:12:37,350 --> 00:12:43,140
today if they want a cache side-channel

238
00:12:40,910 --> 00:12:47,800
side-channel was the general reveal

239
00:12:43,140 --> 00:12:53,019
information about a process that

240
00:12:47,800 --> 00:12:53,859
without using the process entry and exit

241
00:12:53,019 --> 00:12:57,249
points

242
00:12:53,860 --> 00:12:59,559
it uses an a previously unintended way

243
00:12:57,249 --> 00:13:01,860
of getting information especially

244
00:12:59,559 --> 00:13:05,230
sensitive information about the process

245
00:13:01,860 --> 00:13:07,809
through irregular means some common

246
00:13:05,230 --> 00:13:09,429
sight in channel xin the cpu and

247
00:13:07,809 --> 00:13:12,040
previously discovered side channels

248
00:13:09,429 --> 00:13:15,129
accrue the cross VM prime plus probe

249
00:13:12,040 --> 00:13:18,248
attack on Aris a square and multiply

250
00:13:15,129 --> 00:13:21,910
algorithm I asked each table flush it

251
00:13:18,249 --> 00:13:24,790
reload attack and a few more but for the

252
00:13:21,910 --> 00:13:30,389
most part this kind of attack was used

253
00:13:24,790 --> 00:13:33,339
only on on cryptography since

254
00:13:30,389 --> 00:13:36,970
cryptography always have has sensitive

255
00:13:33,339 --> 00:13:38,369
data for example the key and after a

256
00:13:36,970 --> 00:13:42,069
certain point

257
00:13:38,369 --> 00:13:44,279
cryptography which was executed in a

258
00:13:42,069 --> 00:13:47,319
shared environment was perceived to be

259
00:13:44,279 --> 00:13:52,509
quite secure before these kind of

260
00:13:47,319 --> 00:13:54,699
attacks came up so the cache

261
00:13:52,509 --> 00:13:59,799
side-channel is performed through

262
00:13:54,699 --> 00:14:02,049
observing the states of cache lines for

263
00:13:59,799 --> 00:14:06,160
example if you access a certain location

264
00:14:02,049 --> 00:14:09,519
and a cache line is committed to memory

265
00:14:06,160 --> 00:14:12,399
it's committed to the CPU after that you

266
00:14:09,519 --> 00:14:14,170
can discern whether the cache line was

267
00:14:12,399 --> 00:14:17,709
committed there are several techniques

268
00:14:14,170 --> 00:14:20,860
for abusing side channels one is flash

269
00:14:17,709 --> 00:14:24,339
and reload the last time and flash plus

270
00:14:20,860 --> 00:14:27,369
flash are a variation of flash plus

271
00:14:24,339 --> 00:14:30,160
reload attack and there is also Primus

272
00:14:27,369 --> 00:14:34,269
probe I'll be going into more detail on

273
00:14:30,160 --> 00:14:38,230
flash blaster Road since I use it in my

274
00:14:34,269 --> 00:14:42,249
technique so flash plus reload takes a

275
00:14:38,230 --> 00:14:47,230
contiguous page region for example the

276
00:14:42,249 --> 00:14:49,660
usual way is a 256 4 kilobyte pages then

277
00:14:47,230 --> 00:14:51,449
it flushes all the cache line from all

278
00:14:49,660 --> 00:14:55,480
the cache lines from these pages and

279
00:14:51,449 --> 00:14:58,179
triggers the execution of the observed

280
00:14:55,480 --> 00:15:01,430
function of process or just wait for it

281
00:14:58,179 --> 00:15:05,750
to execute the process

282
00:15:01,430 --> 00:15:09,529
is the memory in some way for example

283
00:15:05,750 --> 00:15:13,760
this continuous range and then you can

284
00:15:09,529 --> 00:15:16,640
time the access to each page to retrieve

285
00:15:13,760 --> 00:15:19,189
some data from it then well depending on

286
00:15:16,640 --> 00:15:21,949
what kind of process it is you can get

287
00:15:19,190 --> 00:15:24,680
some sensitive value so you basically

288
00:15:21,950 --> 00:15:28,180
get profit

289
00:15:24,680 --> 00:15:30,949
so how speculative execution flows plus

290
00:15:28,180 --> 00:15:33,380
cache side-channel word first you have

291
00:15:30,950 --> 00:15:37,310
to serialize the execution so that whole

292
00:15:33,380 --> 00:15:40,220
store and flush unload and flushing

293
00:15:37,310 --> 00:15:44,810
operations complete we use memory fact

294
00:15:40,220 --> 00:15:47,390
memory fans operation in the intro CPU

295
00:15:44,810 --> 00:15:50,540
for that then we call a specific

296
00:15:47,390 --> 00:15:53,770
function called herring which compute

297
00:15:50,540 --> 00:15:58,819
which executes many instructions on the

298
00:15:53,770 --> 00:16:01,220
seemed as SIMD part of the CPU then in

299
00:15:58,820 --> 00:16:03,380
the end of the Heron we actually switch

300
00:16:01,220 --> 00:16:06,980
the return address so that it doesn't

301
00:16:03,380 --> 00:16:09,200
return to line free here so everything

302
00:16:06,980 --> 00:16:11,029
from line free is actually executed

303
00:16:09,200 --> 00:16:16,370
speculatively and preemptively

304
00:16:11,029 --> 00:16:21,490
we move we place value five into the

305
00:16:16,370 --> 00:16:28,250
rocks register there a register we then

306
00:16:21,490 --> 00:16:32,050
multiply Erick's by 4096 to align it to

307
00:16:28,250 --> 00:16:36,110
a page and we do a speculative read from

308
00:16:32,050 --> 00:16:38,060
this page all the results of this read

309
00:16:36,110 --> 00:16:40,070
are obviously discarded but there is

310
00:16:38,060 --> 00:16:43,729
still a change in the micro

311
00:16:40,070 --> 00:16:46,240
architectural state so we can see on the

312
00:16:43,730 --> 00:16:50,060
right side that the fifth region

313
00:16:46,240 --> 00:16:52,940
actually lights up because the access

314
00:16:50,060 --> 00:16:58,130
time to the fifth region after this

315
00:16:52,940 --> 00:17:01,700
function executes is much much lower

316
00:16:58,130 --> 00:17:06,760
than for any other page in this

317
00:17:01,700 --> 00:17:09,140
particular region so obviously we can

318
00:17:06,760 --> 00:17:11,439
send some data through speculative

319
00:17:09,140 --> 00:17:14,500
execution and there have already been

320
00:17:11,439 --> 00:17:19,730
several solutions which

321
00:17:14,500 --> 00:17:21,949
stole an access privilege data well the

322
00:17:19,730 --> 00:17:26,559
case in point being now down is there

323
00:17:21,949 --> 00:17:32,690
anything else we can retrieve from this

324
00:17:26,559 --> 00:17:35,030
from speculative execution well first we

325
00:17:32,690 --> 00:17:38,230
have to ask ourselves can we execute can

326
00:17:35,030 --> 00:17:40,639
we execute everything speculatively

327
00:17:38,230 --> 00:17:42,680
obviously there are some limits for

328
00:17:40,640 --> 00:17:45,200
example we taught execute interrupt

329
00:17:42,680 --> 00:17:48,020
for example the entry breakpoint which

330
00:17:45,200 --> 00:17:51,080
is commonly used for debugging can be

331
00:17:48,020 --> 00:17:54,500
executed speculatively some privileged

332
00:17:51,080 --> 00:17:57,139
instructions for example error dmsr

333
00:17:54,500 --> 00:18:00,740
which is used to read the model specific

334
00:17:57,140 --> 00:18:04,220
registers can be executed in user mode

335
00:18:00,740 --> 00:18:10,220
it is only executable in current

336
00:18:04,220 --> 00:18:12,650
privilege level being 0 also many other

337
00:18:10,220 --> 00:18:15,710
instructions which lead to context

338
00:18:12,650 --> 00:18:17,090
switches can't be executed since the CPU

339
00:18:15,710 --> 00:18:21,830
doesn't know how to handle them

340
00:18:17,090 --> 00:18:23,379
speculative so what can we do with this

341
00:18:21,830 --> 00:18:26,710
information

342
00:18:23,380 --> 00:18:29,150
basically malware for example or some

343
00:18:26,710 --> 00:18:33,309
DRM solution digital rights management

344
00:18:29,150 --> 00:18:36,020
solutions can use this to detect

345
00:18:33,309 --> 00:18:38,590
software breakpoints but they usually

346
00:18:36,020 --> 00:18:42,139
easily detectable anyway just through

347
00:18:38,590 --> 00:18:45,199
reading the memory and checking if

348
00:18:42,140 --> 00:18:49,550
anything has changed we can check for

349
00:18:45,200 --> 00:18:51,230
hardware breakpoints which usually quite

350
00:18:49,550 --> 00:18:55,309
hard to detect since they leave no trace

351
00:18:51,230 --> 00:18:58,280
in the readable main memory and I just

352
00:18:55,309 --> 00:19:03,440
set by setting their registers they are

353
00:18:58,280 --> 00:19:06,530
0 for gr 7 in the kernel mode and the

354
00:19:03,440 --> 00:19:09,800
most interesting of all is we can detect

355
00:19:06,530 --> 00:19:15,020
page breakpoint which are usually quite

356
00:19:09,800 --> 00:19:18,649
hard to detect so for example I'll show

357
00:19:15,020 --> 00:19:25,950
right now how to detect hardware

358
00:19:18,650 --> 00:19:31,080
breakpoints so we have a simple

359
00:19:25,950 --> 00:19:34,740
program here which which creates a

360
00:19:31,080 --> 00:19:37,500
continuous memory range then it uses

361
00:19:34,740 --> 00:19:40,940
speculate function which cause herring

362
00:19:37,500 --> 00:19:44,760
and then executes something after that

363
00:19:40,940 --> 00:19:47,880
with the access and page from a certain

364
00:19:44,760 --> 00:19:54,889
location basically from region 20 if we

365
00:19:47,880 --> 00:19:54,889
execute it as it is now we can see that

366
00:19:57,260 --> 00:20:03,600
that they will no cache misses basically

367
00:20:01,380 --> 00:20:04,139
we see that speculative region is not

368
00:20:03,600 --> 00:20:07,789
debugged

369
00:20:04,139 --> 00:20:10,740
and through the use of monitoring which

370
00:20:07,789 --> 00:20:13,529
pages were actually accessed we see that

371
00:20:10,740 --> 00:20:16,019
the speculative region obsessed region

372
00:20:13,529 --> 00:20:18,840
number 20 in hex most of the time there

373
00:20:16,019 --> 00:20:23,220
were just two misses which is negligible

374
00:20:18,840 --> 00:20:27,480
basically anything under 1% is okay now

375
00:20:23,220 --> 00:20:31,039
let's try to set a breakpoint and let's

376
00:20:27,480 --> 00:20:31,039
set a hardware one at that

377
00:20:38,640 --> 00:20:43,040
let's try to execute the same function

378
00:20:43,820 --> 00:20:49,590
as we see the breakpoint wasn't hit

379
00:20:46,860 --> 00:20:51,928
since it's in speculative region and

380
00:20:49,590 --> 00:20:54,209
either no the debugger doesn't know

381
00:20:51,929 --> 00:20:56,220
anything about it actually it doesn't

382
00:20:54,210 --> 00:21:01,429
think that this portion of memory was

383
00:20:56,220 --> 00:21:05,580
executed and what did we get we see that

384
00:21:01,429 --> 00:21:09,510
the page me misses are all over we have

385
00:21:05,580 --> 00:21:11,668
actually most of the accesses our cache

386
00:21:09,510 --> 00:21:15,900
misses which didn't go in the specified

387
00:21:11,669 --> 00:21:20,540
region so we can determine that there

388
00:21:15,900 --> 00:21:20,540
was a hardware breakpoint on execution

389
00:21:23,000 --> 00:21:30,299
now let's talk about virtualization

390
00:21:26,240 --> 00:21:35,630
virtualization is used on servers it is

391
00:21:30,299 --> 00:21:41,280
used by researchers of programmers to

392
00:21:35,630 --> 00:21:42,840
for a secure environment and full to to

393
00:21:41,280 --> 00:21:45,720
run problems for example in a different

394
00:21:42,840 --> 00:21:47,760
operating system but what most interests

395
00:21:45,720 --> 00:21:49,679
us is that it's used for security

396
00:21:47,760 --> 00:21:52,620
purposes for example in virtualization

397
00:21:49,679 --> 00:21:54,960
send boxes basically hardware

398
00:21:52,620 --> 00:21:59,399
virtualization on in case of window into

399
00:21:54,960 --> 00:22:01,740
virtual machine extensions split the

400
00:21:59,400 --> 00:22:04,500
execution into two classes of software

401
00:22:01,740 --> 00:22:07,559
the virtual machine monitor and the

402
00:22:04,500 --> 00:22:10,620
guest software virtual machine monitor

403
00:22:07,559 --> 00:22:13,879
actually initializes virtual machine

404
00:22:10,620 --> 00:22:18,809
extensions then it sets up and

405
00:22:13,880 --> 00:22:20,730
initializes the guests it can catch the

406
00:22:18,809 --> 00:22:24,299
guest when a certain condition is met

407
00:22:20,730 --> 00:22:24,780
and stopped and the execution of a guest

408
00:22:24,299 --> 00:22:28,110
a stop

409
00:22:24,780 --> 00:22:30,149
this condition is called a VM exit after

410
00:22:28,110 --> 00:22:31,620
that and controls the state of the guest

411
00:22:30,150 --> 00:22:35,520
and get change at the form of execution

412
00:22:31,620 --> 00:22:37,290
basically the guest the virtual machine

413
00:22:35,520 --> 00:22:41,490
monitor controls the guest completely

414
00:22:37,290 --> 00:22:45,418
and after that it can rain rain

415
00:22:41,490 --> 00:22:49,130
initialize or continue the state of the

416
00:22:45,419 --> 00:22:52,020
guest so that the guest gets executed

417
00:22:49,130 --> 00:22:53,990
guest software on the other hand

418
00:22:52,020 --> 00:22:59,790
as if there is no virtualization

419
00:22:53,990 --> 00:23:04,110
obviously some hypervisors so guess that

420
00:22:59,790 --> 00:23:06,570
it is virtualized so that it can perform

421
00:23:04,110 --> 00:23:09,840
tasks better but for example sandbox

422
00:23:06,570 --> 00:23:11,879
virtualization usually does everything

423
00:23:09,840 --> 00:23:15,090
so it can be detected by the guest of

424
00:23:11,880 --> 00:23:18,930
that malware can detect that it has been

425
00:23:15,090 --> 00:23:20,699
virtualized also guest gives control

426
00:23:18,930 --> 00:23:22,380
back to virtual machine monitor all the

427
00:23:20,700 --> 00:23:24,210
time so basically if anything suspicious

428
00:23:22,380 --> 00:23:26,610
have anything out of the ordinary

429
00:23:24,210 --> 00:23:28,590
happens for example a context switch it

430
00:23:26,610 --> 00:23:32,520
gives control back to virtual machine

431
00:23:28,590 --> 00:23:35,520
monitor so the standard separation is

432
00:23:32,520 --> 00:23:38,730
virtual machine monitor starting with

433
00:23:35,520 --> 00:23:43,650
raining so on then launching the guest

434
00:23:38,730 --> 00:23:46,320
with the with VM entry then it receives

435
00:23:43,650 --> 00:23:49,920
a VM exit from guest so the guest at

436
00:23:46,320 --> 00:23:52,260
this point stops has its execution

437
00:23:49,920 --> 00:23:56,460
stopped and after that virtual machine

438
00:23:52,260 --> 00:23:59,460
monitor can launch the first zero guest

439
00:23:56,460 --> 00:24:01,860
new or start a new guest and in the end

440
00:23:59,460 --> 00:24:07,830
it can switch off virtualization

441
00:24:01,860 --> 00:24:10,590
completely by using the mix off the MX

442
00:24:07,830 --> 00:24:15,060
it is effectively a contest switch a

443
00:24:10,590 --> 00:24:17,370
contact switch from guest to VN man it

444
00:24:15,060 --> 00:24:20,629
can happen under several conditions for

445
00:24:17,370 --> 00:24:23,189
example on certain breakpoints on

446
00:24:20,630 --> 00:24:26,280
instructions which are computed by the

447
00:24:23,190 --> 00:24:29,760
virtual machine monitor for example CPU

448
00:24:26,280 --> 00:24:31,590
IDs so that the virtual machine monitor

449
00:24:29,760 --> 00:24:34,290
can present a different environment to

450
00:24:31,590 --> 00:24:36,810
the guest than the one which it's

451
00:24:34,290 --> 00:24:41,310
actually executed on for example you can

452
00:24:36,810 --> 00:24:45,300
substitute the interest standard Intel

453
00:24:41,310 --> 00:24:49,530
CPU code from CPU I did I am these two

454
00:24:45,300 --> 00:24:54,240
MDS and the guest won't actually know

455
00:24:49,530 --> 00:24:56,160
that it's executed on an Intel CPU vmm

456
00:24:54,240 --> 00:24:59,430
also receives all the information about

457
00:24:56,160 --> 00:25:04,830
the current state of the guest when the

458
00:24:59,430 --> 00:25:05,810
guest when a VM exit happens so all

459
00:25:04,830 --> 00:25:09,889
register states

460
00:25:05,810 --> 00:25:12,260
all the states of memory which which

461
00:25:09,890 --> 00:25:17,450
operation is currently executing

462
00:25:12,260 --> 00:25:19,670
everything so there were several ways to

463
00:25:17,450 --> 00:25:22,700
detect hardware virtualization one of

464
00:25:19,670 --> 00:25:25,510
the most obvious ones is time in VN

465
00:25:22,700 --> 00:25:31,250
magazine instructions through the use of

466
00:25:25,510 --> 00:25:34,430
our DTC and for that particular problem

467
00:25:31,250 --> 00:25:37,060
intro came up with a solution basically

468
00:25:34,430 --> 00:25:41,270
our did our DTC became an instruction

469
00:25:37,060 --> 00:25:43,280
which is also causing a VM exit and you

470
00:25:41,270 --> 00:25:48,139
can change the actual values which are

471
00:25:43,280 --> 00:25:50,780
returned so that you can take execution

472
00:25:48,140 --> 00:25:55,160
without virtualization you just decrease

473
00:25:50,780 --> 00:25:57,200
they are DC value each time so this

474
00:25:55,160 --> 00:26:01,270
particular technique is not quite useful

475
00:25:57,200 --> 00:26:03,640
now rise against sandbox virtualization

476
00:26:01,270 --> 00:26:07,520
then there is also detecting

477
00:26:03,640 --> 00:26:11,900
microarchitecture changes for example if

478
00:26:07,520 --> 00:26:16,280
you try to well return stack buffer gets

479
00:26:11,900 --> 00:26:20,840
flushed when a VM exit is committed

480
00:26:16,280 --> 00:26:22,550
because the the execution flows which is

481
00:26:20,840 --> 00:26:25,850
back to virtual machine monitor and

482
00:26:22,550 --> 00:26:28,850
every piece of data which was stored is

483
00:26:25,850 --> 00:26:30,949
in return stack buffer is actually

484
00:26:28,850 --> 00:26:35,360
overwritten so you know when you return

485
00:26:30,950 --> 00:26:39,440
the returns are actually slower than if

486
00:26:35,360 --> 00:26:43,969
there was no virtualization at all these

487
00:26:39,440 --> 00:26:47,120
are quite interesting but there are some

488
00:26:43,970 --> 00:26:48,980
problems with that so time time in vm x

489
00:26:47,120 --> 00:26:52,250
it has several problems

490
00:26:48,980 --> 00:26:55,550
it's obvious to sandbox the values can

491
00:26:52,250 --> 00:26:57,980
be manipulated and it also can be evaded

492
00:26:55,550 --> 00:27:00,860
with blue chicken-leg techniques you can

493
00:26:57,980 --> 00:27:03,290
read John route Kavkaz research on this

494
00:27:00,860 --> 00:27:07,570
part basically sometimes you can just

495
00:27:03,290 --> 00:27:10,670
unload virtualization or unload our DTC

496
00:27:07,570 --> 00:27:15,470
caching on VM exits and it would allow

497
00:27:10,670 --> 00:27:18,170
you to evade such techniques in my crack

498
00:27:15,470 --> 00:27:19,670
micro architecture change detection why

499
00:27:18,170 --> 00:27:23,000
while being

500
00:27:19,670 --> 00:27:25,190
my precise has a single problem that it

501
00:27:23,000 --> 00:27:27,500
has to be executed in current privilege

502
00:27:25,190 --> 00:27:30,230
level with zero basically this means

503
00:27:27,500 --> 00:27:32,870
that malware has first needs first to go

504
00:27:30,230 --> 00:27:36,110
to kernel mode which is not the case

505
00:27:32,870 --> 00:27:38,409
with most malware nowadays and only then

506
00:27:36,110 --> 00:27:45,020
it can check that it's being debugged or

507
00:27:38,410 --> 00:27:47,150
traced so that's a problem but this

508
00:27:45,020 --> 00:27:48,610
particular technique allows you to

509
00:27:47,150 --> 00:27:53,380
detect virtualization from

510
00:27:48,610 --> 00:27:57,100
microarchitecture changes in rain-free

511
00:27:53,380 --> 00:28:00,560
what we do is a place an RDD

512
00:27:57,100 --> 00:28:04,820
CSC instruction in the speculative

513
00:28:00,560 --> 00:28:07,370
region and then base memory accesses for

514
00:28:04,820 --> 00:28:10,580
side-channel on the value which was

515
00:28:07,370 --> 00:28:14,330
returned so here we get the standard M

516
00:28:10,580 --> 00:28:16,760
fence instruction then the code which

517
00:28:14,330 --> 00:28:20,590
triggers speculative execution then we

518
00:28:16,760 --> 00:28:28,520
get our dt assumed which returns data to

519
00:28:20,590 --> 00:28:31,220
register eggs and eggs then we cut some

520
00:28:28,520 --> 00:28:34,010
of the data out so that we only have the

521
00:28:31,220 --> 00:28:35,570
last four bits we need to store well we

522
00:28:34,010 --> 00:28:39,020
need to collect some of those bits so

523
00:28:35,570 --> 00:28:45,159
that speculative execution can go past

524
00:28:39,020 --> 00:28:49,820
our DTC if it's not executed we and oh

525
00:28:45,160 --> 00:28:51,800
it's 52 wraps so that we predetermine a

526
00:28:49,820 --> 00:28:55,669
region which is going to be accessed and

527
00:28:51,800 --> 00:29:01,669
then we align it to page border and read

528
00:28:55,670 --> 00:29:04,850
from there so basically we execute model

529
00:29:01,670 --> 00:29:07,820
vmx and instructions modify the results

530
00:29:04,850 --> 00:29:11,870
and read from the page this is enough

531
00:29:07,820 --> 00:29:14,320
since there are now two cases if we are

532
00:29:11,870 --> 00:29:18,919
not executing in a virtual environment

533
00:29:14,320 --> 00:29:21,050
then our dtc will work it will be

534
00:29:18,920 --> 00:29:24,440
executed speculative there are no

535
00:29:21,050 --> 00:29:27,020
problems and if we are executed in a

536
00:29:24,440 --> 00:29:29,990
virtual environment then our dtc can't

537
00:29:27,020 --> 00:29:31,850
be executed speculatively at all the

538
00:29:29,990 --> 00:29:32,900
problem being that the CPU doesn't know

539
00:29:31,850 --> 00:29:35,540
how to

540
00:29:32,900 --> 00:29:37,730
it knows how to execute rzjc but it

541
00:29:35,540 --> 00:29:40,309
would take too much time to perform a

542
00:29:37,730 --> 00:29:43,340
contact switch so would decides not to

543
00:29:40,309 --> 00:29:47,389
execute our dtc and just wait for the

544
00:29:43,340 --> 00:29:50,809
execution to serialize then we see two

545
00:29:47,390 --> 00:29:55,580
completely different pictures the one on

546
00:29:50,809 --> 00:29:58,370
the left is when our deed is TSE is

547
00:29:55,580 --> 00:30:02,059
executed speculatively we commit to a

548
00:29:58,370 --> 00:30:07,689
certain region basically the fifth

549
00:30:02,059 --> 00:30:10,280
region which was predetermined and then

550
00:30:07,690 --> 00:30:13,880
we know that when I not executor

551
00:30:10,280 --> 00:30:16,910
speckles and the one on the right is the

552
00:30:13,880 --> 00:30:20,150
case with the virtual machine

553
00:30:16,910 --> 00:30:20,840
since our DAC instruction can be

554
00:30:20,150 --> 00:30:24,260
executed

555
00:30:20,840 --> 00:30:28,100
we can't there is no side channel back

556
00:30:24,260 --> 00:30:30,260
to the memory and all the accesses the

557
00:30:28,100 --> 00:30:32,330
quickest pages over for example a

558
00:30:30,260 --> 00:30:36,830
thousand tries or 10,000 tries are

559
00:30:32,330 --> 00:30:42,139
evenly spread over the evenly spread

560
00:30:36,830 --> 00:30:46,370
over the area so I'll show demo now

561
00:30:42,140 --> 00:30:48,290
basically the terminal on the left is

562
00:30:46,370 --> 00:30:51,770
operating in a non virtualized

563
00:30:48,290 --> 00:30:54,230
environment in the vm m and Nikoli

564
00:30:51,770 --> 00:30:57,290
virtual machine on the right operates

565
00:30:54,230 --> 00:31:07,820
under virtualization

566
00:30:57,290 --> 00:31:13,240
so first let's create the elf let me

567
00:31:07,820 --> 00:31:13,240
show you that all the files are the same

568
00:31:15,970 --> 00:31:23,240
we can see in that those are the same

569
00:31:19,220 --> 00:31:26,690
files this is the same actual executable

570
00:31:23,240 --> 00:31:30,410
this is just a shared folder now let's

571
00:31:26,690 --> 00:31:33,410
try to execute the virtualization check

572
00:31:30,410 --> 00:31:37,370
in on virtualized environment as we can

573
00:31:33,410 --> 00:31:40,790
see only ten out of ten thousand try

574
00:31:37,370 --> 00:31:43,550
tries actually missed the cache area

575
00:31:40,790 --> 00:31:45,290
which was predetermined so we see that

576
00:31:43,550 --> 00:31:46,639
our DTC is not virtualized it is

577
00:31:45,290 --> 00:31:50,270
executed speculative

578
00:31:46,640 --> 00:31:52,460
there is no problem now let's try to

579
00:31:50,270 --> 00:31:56,510
execute the same program on the

580
00:31:52,460 --> 00:31:59,300
virtualization first you saw how it took

581
00:31:56,510 --> 00:32:01,850
a little bit more time that's because

582
00:31:59,300 --> 00:32:04,220
there was no cash though

583
00:32:01,850 --> 00:32:07,250
basically that was one of the

584
00:32:04,220 --> 00:32:11,000
differences the second one is that

585
00:32:07,250 --> 00:32:13,070
obviously are the TC is not executed

586
00:32:11,000 --> 00:32:24,560
speculatively so we have a lot lots of

587
00:32:13,070 --> 00:32:28,060
cache misses so what's the problem

588
00:32:24,560 --> 00:32:31,490
with this one you can reliably detect

589
00:32:28,060 --> 00:32:33,950
virtualization from rain-free through

590
00:32:31,490 --> 00:32:37,100
speculative execution and you can do it

591
00:32:33,950 --> 00:32:40,670
simply by checking whether the region is

592
00:32:37,100 --> 00:32:44,750
the same so you have two cases which I

593
00:32:40,670 --> 00:32:48,970
showed basically a small amount of cache

594
00:32:44,750 --> 00:32:52,430
misses under 1% or a large one where

595
00:32:48,970 --> 00:32:55,760
almost all of the cases return the cache

596
00:32:52,430 --> 00:32:59,710
miss and that's quite simple for example

597
00:32:55,760 --> 00:33:03,320
if you created a simple binary check

598
00:32:59,710 --> 00:33:06,980
then the reverse engineer in the end

599
00:33:03,320 --> 00:33:09,260
would be able to detect this while a

600
00:33:06,980 --> 00:33:11,450
sandbox in solution wouldn't probably be

601
00:33:09,260 --> 00:33:13,310
able to detect this automatically still

602
00:33:11,450 --> 00:33:16,130
there that wouldn't be a problem for

603
00:33:13,310 --> 00:33:21,100
reverse engineer he would just flip the

604
00:33:16,130 --> 00:33:25,280
switch flip the jump of the result of

605
00:33:21,100 --> 00:33:28,389
the test and we still get an intact

606
00:33:25,280 --> 00:33:32,870
solution for example if there is

607
00:33:28,390 --> 00:33:36,230
attacked malware binary which uses this

608
00:33:32,870 --> 00:33:41,090
to detect virtualization the problem

609
00:33:36,230 --> 00:33:44,120
with speculative execution based hyper-v

610
00:33:41,090 --> 00:33:46,540
the detect detection is that it's the

611
00:33:44,120 --> 00:33:50,199
first of its kind which can actually

612
00:33:46,540 --> 00:33:52,850
compute some data based on the fact

613
00:33:50,200 --> 00:34:03,020
whether there is virtualization or not

614
00:33:52,850 --> 00:34:05,540
for example that's so basically the

615
00:34:03,020 --> 00:34:22,730
problem is that you can place anything

616
00:34:05,540 --> 00:34:24,889
in the speculative region you can place

617
00:34:22,730 --> 00:34:27,350
anything in the speculative region for

618
00:34:24,889 --> 00:34:30,139
example after our DTSC you can place

619
00:34:27,350 --> 00:34:32,120
some instructions which compute

620
00:34:30,139 --> 00:34:34,909
different data based on the

621
00:34:32,120 --> 00:34:37,009
predetermined data and then collect the

622
00:34:34,909 --> 00:34:39,949
results of that execution

623
00:34:37,010 --> 00:34:42,410
you can then compute a key used for

624
00:34:39,949 --> 00:34:55,549
unpacking from that data and that would

625
00:34:42,409 --> 00:34:58,990
be a big problem for a research what's

626
00:34:55,550 --> 00:35:02,690
more is that under certain conditions

627
00:34:58,990 --> 00:35:05,140
speculative execution when not a problem

628
00:35:02,690 --> 00:35:08,450
when there is no side-channel has

629
00:35:05,140 --> 00:35:10,490
so-called zero bias it means that when

630
00:35:08,450 --> 00:35:14,390
your time in pages to determine which

631
00:35:10,490 --> 00:35:18,169
page is has the fastest access most of

632
00:35:14,390 --> 00:35:21,140
the values will be biased to zero page

633
00:35:18,170 --> 00:35:24,740
since all of them can be at the fastest

634
00:35:21,140 --> 00:35:27,740
but it's just but they can also have the

635
00:35:24,740 --> 00:35:31,790
same access time which means that you

636
00:35:27,740 --> 00:35:34,189
can create two separate sets of data for

637
00:35:31,790 --> 00:35:36,740
untaken two separate sets of keys one

638
00:35:34,190 --> 00:35:41,210
key which is actually computed with a

639
00:35:36,740 --> 00:35:43,430
speculative execution during if there is

640
00:35:41,210 --> 00:35:46,670
a side channel and the second set which

641
00:35:43,430 --> 00:35:49,129
is computed with some tampering if there

642
00:35:46,670 --> 00:35:51,770
is no side channel totally bias to zero

643
00:35:49,130 --> 00:35:54,440
and you can still decrypt meaningful

644
00:35:51,770 --> 00:35:57,220
data through the use of this scheme and

645
00:35:54,440 --> 00:35:59,780
this cunning scheme would enable you to

646
00:35:57,220 --> 00:36:01,790
create a completely different solution

647
00:35:59,780 --> 00:36:03,650
for example to unpack some kind of

648
00:36:01,790 --> 00:36:05,750
adware or some

649
00:36:03,650 --> 00:36:12,320
kind of game instead of actual malware

650
00:36:05,750 --> 00:36:15,940
and trick reverse engineer into flag in

651
00:36:12,320 --> 00:36:23,020
your executable which actually has

652
00:36:15,940 --> 00:36:25,640
Bioware as benign so the conclusions are

653
00:36:23,020 --> 00:36:29,300
spectral obviously speculative execution

654
00:36:25,640 --> 00:36:32,629
can be used to detect virtualization it

655
00:36:29,300 --> 00:36:35,770
can also be a great headache for

656
00:36:32,630 --> 00:36:38,330
researchers and reverse engineers since

657
00:36:35,770 --> 00:36:41,590
there would be a lot of problems and it

658
00:36:38,330 --> 00:36:45,130
would be quite hard to analyze as

659
00:36:41,590 --> 00:36:48,980
speculative execution can be debugged

660
00:36:45,130 --> 00:36:52,030
there is no way to debug it since it's

661
00:36:48,980 --> 00:36:56,270
not executed in regular software terms

662
00:36:52,030 --> 00:36:59,930
also if it's used by mass malware it can

663
00:36:56,270 --> 00:37:03,259
be a great problem for many automatics

664
00:36:59,930 --> 00:37:05,810
and boxes and it can actually lead to

665
00:37:03,260 --> 00:37:09,980
many false positive too many false

666
00:37:05,810 --> 00:37:12,140
positive for future detections if you're

667
00:37:09,980 --> 00:37:14,810
interesting if you're interested in

668
00:37:12,140 --> 00:37:20,259
trying it yourself you can look up the

669
00:37:14,810 --> 00:37:20,259
proof-of-concept on github on this thing

