1
00:00:05,620 --> 00:00:10,550
okay

2
00:00:06,830 --> 00:00:13,490
hi guys Pietro I'm from the Busiek group

3
00:00:10,550 --> 00:00:15,349
which is the system and security groups

4
00:00:13,490 --> 00:00:18,859
from the dry universe state of Amsterdam

5
00:00:15,349 --> 00:00:20,779
and this work was my master thesis which

6
00:00:18,859 --> 00:00:22,669
I did in cooperation with the Christiano

7
00:00:20,779 --> 00:00:26,839
era Burton cada which are the three main

8
00:00:22,669 --> 00:00:29,329
professors of the group so let's start

9
00:00:26,839 --> 00:00:32,269
with understanding what's glitch so

10
00:00:29,329 --> 00:00:35,230
glitch is the first runner exploit from

11
00:00:32,270 --> 00:00:38,540
JavaScript on mobile so before this

12
00:00:35,230 --> 00:00:42,769
study there was no proof of JavaScript

13
00:00:38,540 --> 00:00:44,060
exploit that using runner on mobile it's

14
00:00:42,770 --> 00:00:46,220
not only the first one but it's also the

15
00:00:44,060 --> 00:00:49,700
fastest JavaScript based runner exploit

16
00:00:46,220 --> 00:00:51,560
so far but what's the main contribution

17
00:00:49,700 --> 00:00:54,079
of this work is the fact that is the

18
00:00:51,560 --> 00:00:55,550
first GPU accelerated big flip so we

19
00:00:54,079 --> 00:00:59,840
triggered the flips not using the CPU

20
00:00:55,550 --> 00:01:02,030
but the GPU now to understand a bit the

21
00:00:59,840 --> 00:01:04,040
context were working on I'm gonna go

22
00:01:02,030 --> 00:01:05,780
through the Chronicles of bullet so just

23
00:01:04,040 --> 00:01:10,579
give a bit of a contextual background

24
00:01:05,780 --> 00:01:13,520
and why we did this so this a bit of a

25
00:01:10,579 --> 00:01:17,479
timeline and that little guy there is me

26
00:01:13,520 --> 00:01:20,179
and it was me 2016 I was looking for

27
00:01:17,479 --> 00:01:22,700
master thesis and I met cristiano now my

28
00:01:20,179 --> 00:01:24,259
advisor who was talking about rahama

29
00:01:22,700 --> 00:01:26,509
theorem and bit flips at a conference

30
00:01:24,259 --> 00:01:28,700
and the time I didn't know anything

31
00:01:26,509 --> 00:01:32,149
about this kind of confuse I didn't know

32
00:01:28,700 --> 00:01:35,899
what was going on so let me explain to

33
00:01:32,149 --> 00:01:39,920
you a bit how this works and how DRAM

34
00:01:35,899 --> 00:01:41,840
works and what is runner so this is how

35
00:01:39,920 --> 00:01:45,049
you can look at theorem which is

36
00:01:41,840 --> 00:01:48,920
basically a grid of a lot of cells and

37
00:01:45,049 --> 00:01:52,130
these cells contain capacitors and

38
00:01:48,920 --> 00:01:54,439
capacitors if you have any background in

39
00:01:52,130 --> 00:01:55,880
electronics they don't keep the charges

40
00:01:54,439 --> 00:01:59,298
forever so the leak charges over time

41
00:01:55,880 --> 00:02:01,399
and as a consequence they need to be

42
00:01:59,299 --> 00:02:03,139
refreshed to keep the data otherwise you

43
00:02:01,399 --> 00:02:05,209
will do your data that you store indium

44
00:02:03,139 --> 00:02:09,109
and that's also why it's called DRAM

45
00:02:05,209 --> 00:02:11,510
dynamic random-access memory and the way

46
00:02:09,110 --> 00:02:12,710
Adam Reed works is if you have data for

47
00:02:11,510 --> 00:02:14,890
instance in row 2 that you want to read

48
00:02:12,710 --> 00:02:17,350
what you need to do is you

49
00:02:14,890 --> 00:02:18,640
you get that data so you activate the

50
00:02:17,350 --> 00:02:20,739
role which means that you bring it to

51
00:02:18,640 --> 00:02:23,170
the row buffer the row buffer is this

52
00:02:20,740 --> 00:02:26,890
one down there which is basically a

53
00:02:23,170 --> 00:02:28,780
cache for for Dion and once the data is

54
00:02:26,890 --> 00:02:31,000
there the data gets removed from the row

55
00:02:28,780 --> 00:02:32,290
so the way capacitor works is to get the

56
00:02:31,000 --> 00:02:34,540
content of the character you need to

57
00:02:32,290 --> 00:02:36,489
lick the charge to something else to

58
00:02:34,540 --> 00:02:38,560
read what was there so if it's charged

59
00:02:36,490 --> 00:02:40,660
it might be a 1 or a 0 depending on the

60
00:02:38,560 --> 00:02:42,910
encoding and once it's in the row buffer

61
00:02:40,660 --> 00:02:44,470
you can read the data from there but

62
00:02:42,910 --> 00:02:46,750
then you need to send it back to the to

63
00:02:44,470 --> 00:02:50,890
the row so you need to pre charge 0 or

64
00:02:46,750 --> 00:02:53,350
restore the data to have it still in

65
00:02:50,890 --> 00:02:55,420
memory otherwise you lose it now what

66
00:02:53,350 --> 00:02:57,370
research has discovered is that if you

67
00:02:55,420 --> 00:02:59,649
perform a specific access pattern so

68
00:02:57,370 --> 00:03:01,959
usually what they do is they choose to

69
00:02:59,650 --> 00:03:04,750
aggressor rows with a victim row in the

70
00:03:01,959 --> 00:03:07,510
middle if you access the glacier rows

71
00:03:04,750 --> 00:03:10,660
fast enough you might have charges in

72
00:03:07,510 --> 00:03:12,519
the victim row that start leaking at one

73
00:03:10,660 --> 00:03:15,579
point you can trigger up these two so

74
00:03:12,519 --> 00:03:17,290
you can change the data from a 1 to 0 or

75
00:03:15,580 --> 00:03:20,500
0 to 1 again depending on the encoding

76
00:03:17,290 --> 00:03:21,670
and this is quite important because it

77
00:03:20,500 --> 00:03:23,739
means that you can compromise the

78
00:03:21,670 --> 00:03:26,619
integrity of data in theorem without

79
00:03:23,739 --> 00:03:28,480
actually accessing it and the crazy

80
00:03:26,620 --> 00:03:30,130
thing about this is that once you get a

81
00:03:28,480 --> 00:03:32,290
bit flip you may think okay that's a

82
00:03:30,130 --> 00:03:34,150
random error but the thing is once you

83
00:03:32,290 --> 00:03:36,730
get a bit flip on a specific cell that's

84
00:03:34,150 --> 00:03:39,459
that be usually reproducible so you can

85
00:03:36,730 --> 00:03:43,119
reuse it later on to compromise and

86
00:03:39,459 --> 00:03:45,850
stiff data so back to a time line I

87
00:03:43,120 --> 00:03:48,370
started studying a bit the history of

88
00:03:45,850 --> 00:03:49,570
this of this bug and turns out it was

89
00:03:48,370 --> 00:03:52,540
quite recent

90
00:03:49,570 --> 00:03:54,250
so the first proof was in 2014 they were

91
00:03:52,540 --> 00:03:55,690
showing it was possible to flip him to

92
00:03:54,250 --> 00:03:58,750
flip bits in memory without accessing

93
00:03:55,690 --> 00:04:00,700
them and then just one year later a

94
00:03:58,750 --> 00:04:02,500
Google project 0 thought okay you can

95
00:04:00,700 --> 00:04:04,959
actually exploit this no it's not just

96
00:04:02,500 --> 00:04:08,230
this reliability issue we can actually

97
00:04:04,959 --> 00:04:09,730
build a root exploit with this and the

98
00:04:08,230 --> 00:04:11,709
same year people show that was possible

99
00:04:09,730 --> 00:04:14,260
to trigger this bit faced from

100
00:04:11,709 --> 00:04:15,609
JavaScript and at the same time was in

101
00:04:14,260 --> 00:04:17,228
our group some people working on that

102
00:04:15,609 --> 00:04:20,410
and also working on breaking the cloud

103
00:04:17,228 --> 00:04:24,760
so compromising built on machines in the

104
00:04:20,410 --> 00:04:26,800
cloud so I I made a like I did a bit of

105
00:04:24,760 --> 00:04:28,750
recap and I thought ok there is a root

106
00:04:26,800 --> 00:04:31,780
exploit to JavaScript

107
00:04:28,750 --> 00:04:34,120
one on the cloud so the next step is

108
00:04:31,780 --> 00:04:37,539
clearly can you trigger this beefless on

109
00:04:34,120 --> 00:04:38,650
your mobile and turns out that somebody

110
00:04:37,540 --> 00:04:41,830
else already thought about it

111
00:04:38,650 --> 00:04:43,210
so Victor another guy from our group but

112
00:04:41,830 --> 00:04:45,729
at that time it was not yet my group so

113
00:04:43,210 --> 00:04:47,680
I was not aware of this was working on

114
00:04:45,730 --> 00:04:51,640
this exploit that the code wrote Android

115
00:04:47,680 --> 00:04:53,260
phones using beef lips so I thought okay

116
00:04:51,640 --> 00:04:56,140
still I don't have a topic for my thesis

117
00:04:53,260 --> 00:05:00,010
but then it turns out that while Victor

118
00:04:56,140 --> 00:05:01,330
was bragging on Twitter about his work

119
00:05:00,010 --> 00:05:03,520
it was saying that it would think that

120
00:05:01,330 --> 00:05:06,340
it could be possible to trigger this

121
00:05:03,520 --> 00:05:08,530
also from a browser include that's not

122
00:05:06,340 --> 00:05:11,080
that easy so the garage which is quite

123
00:05:08,530 --> 00:05:12,219
famous in the community said well I

124
00:05:11,080 --> 00:05:14,490
would love to see that up and like

125
00:05:12,220 --> 00:05:17,680
calling out calling out on his

126
00:05:14,490 --> 00:05:19,600
so challenge accepted there was a good

127
00:05:17,680 --> 00:05:21,460
project to work on and I start work

128
00:05:19,600 --> 00:05:23,980
looking into what you need to build this

129
00:05:21,460 --> 00:05:25,330
kind of attacks and when you think about

130
00:05:23,980 --> 00:05:27,040
the tax usually you think about the

131
00:05:25,330 --> 00:05:29,169
primitives that you need to build attack

132
00:05:27,040 --> 00:05:31,450
and the case of the wrong attacks you

133
00:05:29,169 --> 00:05:34,719
have two main primitives the first one

134
00:05:31,450 --> 00:05:36,520
is a fast cash addiction so what are the

135
00:05:34,720 --> 00:05:38,560
caches well usually when you read data

136
00:05:36,520 --> 00:05:39,969
from theorem you don't want to always

137
00:05:38,560 --> 00:05:42,660
access it from the ROM because that's

138
00:05:39,970 --> 00:05:45,550
very slow so CPUs usually include

139
00:05:42,660 --> 00:05:48,400
another layer of smaller memory which

140
00:05:45,550 --> 00:05:51,250
are called caches and this one are just

141
00:05:48,400 --> 00:05:53,200
used to hide the latency of these memory

142
00:05:51,250 --> 00:05:56,290
accesses so what happens usually is that

143
00:05:53,200 --> 00:05:58,510
you go to the cash check if the data is

144
00:05:56,290 --> 00:05:59,890
there if it's not there you get to

145
00:05:58,510 --> 00:06:01,510
determine and then you bring it to the

146
00:05:59,890 --> 00:06:05,680
cache so that you can reuse it later on

147
00:06:01,510 --> 00:06:07,360
and the next time though even if you

148
00:06:05,680 --> 00:06:08,800
want to access the data is gonna be in

149
00:06:07,360 --> 00:06:10,750
the cache so you're gonna get it from

150
00:06:08,800 --> 00:06:12,669
the cache so if you want to touch the

151
00:06:10,750 --> 00:06:13,840
same memory location the next time

152
00:06:12,669 --> 00:06:17,890
you're not going to do it because it's

153
00:06:13,840 --> 00:06:21,130
in cache so the solution to these are

154
00:06:17,890 --> 00:06:24,159
two the first one natively is to use the

155
00:06:21,130 --> 00:06:26,110
CL / instruction which basically remove

156
00:06:24,160 --> 00:06:28,600
the data from the cache so it just

157
00:06:26,110 --> 00:06:30,130
flashes the cache line so means that it

158
00:06:28,600 --> 00:06:32,380
gets the cache line and just send it

159
00:06:30,130 --> 00:06:35,229
back to the memory so the next time you

160
00:06:32,380 --> 00:06:37,090
can get it back from the memory and this

161
00:06:35,229 --> 00:06:39,219
is a really good solution but on

162
00:06:37,090 --> 00:06:40,630
JavaScript you don't have this luxury so

163
00:06:39,220 --> 00:06:42,500
you need to do something different which

164
00:06:40,630 --> 00:06:46,550
is called a cache addiction

165
00:06:42,500 --> 00:06:48,770
and the way this works is that you need

166
00:06:46,550 --> 00:06:50,950
to touch around a bunch of random pages

167
00:06:48,770 --> 00:06:53,270
so it just touched a different data

168
00:06:50,950 --> 00:06:54,530
until at one point this data is gonna be

169
00:06:53,270 --> 00:06:58,640
removed and then you can access it again

170
00:06:54,530 --> 00:07:00,260
to trigger the big flip second the

171
00:06:58,640 --> 00:07:03,050
second print that you need is a

172
00:07:00,260 --> 00:07:05,360
contiguous memory so as we said we

173
00:07:03,050 --> 00:07:06,830
usually usually need three adjacent rows

174
00:07:05,360 --> 00:07:08,000
so you want to have the two aggressor

175
00:07:06,830 --> 00:07:11,150
rose and the became ill in the middle

176
00:07:08,000 --> 00:07:14,330
and this is usually supported by by

177
00:07:11,150 --> 00:07:15,950
using transparent which pages which are

178
00:07:14,330 --> 00:07:17,180
basically pages of two megabytes so

179
00:07:15,950 --> 00:07:20,510
usually in virtual memory allocated

180
00:07:17,180 --> 00:07:21,770
pages of four kilobytes but with two

181
00:07:20,510 --> 00:07:25,490
megabytes pages you can span over

182
00:07:21,770 --> 00:07:29,000
multiple rows in memory now the mapping

183
00:07:25,490 --> 00:07:31,220
it's not linear so you don't just follow

184
00:07:29,000 --> 00:07:34,340
the addresses the other in memory into

185
00:07:31,220 --> 00:07:38,480
DM cells but it's a simplification that

186
00:07:34,340 --> 00:07:40,880
works pretty well now now when you bring

187
00:07:38,480 --> 00:07:43,880
all these to mobile platform so on arm

188
00:07:40,880 --> 00:07:46,909
it turns out that CL flush it's a

189
00:07:43,880 --> 00:07:50,840
privileged instruction so you cannot use

190
00:07:46,910 --> 00:07:53,120
it as a user's PC application an

191
00:07:50,840 --> 00:07:56,390
eviction sets also don't work because

192
00:07:53,120 --> 00:07:58,400
the CPU caches are too large and

193
00:07:56,390 --> 00:08:01,460
implement a random replacement policy

194
00:07:58,400 --> 00:08:03,890
and this means that for instance if you

195
00:08:01,460 --> 00:08:05,930
want to take a your run B flip what

196
00:08:03,890 --> 00:08:08,270
people do is you touch the first row and

197
00:08:05,930 --> 00:08:09,800
then the content goes to the cache the

198
00:08:08,270 --> 00:08:12,229
second row and the content goes to the

199
00:08:09,800 --> 00:08:14,600
cache and then you will start the big

200
00:08:12,229 --> 00:08:17,180
thing so you touch the one page another

201
00:08:14,600 --> 00:08:20,810
one another one and you keep on doing it

202
00:08:17,180 --> 00:08:22,820
and sometimes you may actually addicting

203
00:08:20,810 --> 00:08:25,490
that use for a gig addiction so that's

204
00:08:22,820 --> 00:08:26,870
not really efficient until at one point

205
00:08:25,490 --> 00:08:29,630
you're gonna remove the content from the

206
00:08:26,870 --> 00:08:31,760
cache and you can access it again for

207
00:08:29,630 --> 00:08:33,559
your bit flips but this doesn't work

208
00:08:31,760 --> 00:08:36,439
because it takes forever since the cache

209
00:08:33,559 --> 00:08:40,640
is large and and as a consequence it is

210
00:08:36,440 --> 00:08:42,620
not an option on arm and about continues

211
00:08:40,640 --> 00:08:46,610
memory transparent which pages also are

212
00:08:42,620 --> 00:08:49,760
not available so I was wondering how

213
00:08:46,610 --> 00:08:52,700
Victor did it so I asked him so how did

214
00:08:49,760 --> 00:08:54,589
you do it an arm and he answered ion and

215
00:08:52,700 --> 00:08:55,850
that for me it was okay what are you

216
00:08:54,589 --> 00:08:58,550
talking about

217
00:08:55,850 --> 00:09:00,230
and the ioan apparently is a an API

218
00:08:58,550 --> 00:09:04,219
provided by the Android kernel that

219
00:09:00,230 --> 00:09:06,080
provides you with the DMA memory and DNA

220
00:09:04,220 --> 00:09:08,270
stands for direct memory access

221
00:09:06,080 --> 00:09:11,390
so it's memory that usually is used by

222
00:09:08,270 --> 00:09:14,689
peripherals and the peripherals for

223
00:09:11,390 --> 00:09:16,910
instance if you add PCI peripherals they

224
00:09:14,690 --> 00:09:18,980
might not have a memory management unit

225
00:09:16,910 --> 00:09:20,630
which is the one it translates via total

226
00:09:18,980 --> 00:09:23,330
physical addresses so in the contiguous

227
00:09:20,630 --> 00:09:25,490
memory and also these peripherals

228
00:09:23,330 --> 00:09:27,590
usually don't want to deal with cache

229
00:09:25,490 --> 00:09:31,610
coherency so the memory is also on cache

230
00:09:27,590 --> 00:09:33,980
for the CPU so lucky Viktor but not

231
00:09:31,610 --> 00:09:35,000
lucky me because it means that I don't

232
00:09:33,980 --> 00:09:37,420
have access to this memory from

233
00:09:35,000 --> 00:09:42,470
JavaScript so I thought well what's good

234
00:09:37,420 --> 00:09:44,510
we cannot do much now and then I started

235
00:09:42,470 --> 00:09:48,020
thinking a bit and I thought well what

236
00:09:44,510 --> 00:09:50,750
if we change the attack vector and what

237
00:09:48,020 --> 00:09:52,160
do we mean by that basically when you

238
00:09:50,750 --> 00:09:53,960
consider this kind of attacks you have

239
00:09:52,160 --> 00:09:57,880
your JavaScript code running in the

240
00:09:53,960 --> 00:10:00,500
browser which then runs on the CPU and

241
00:09:57,880 --> 00:10:03,680
then use it to trigger the free zone

242
00:10:00,500 --> 00:10:05,870
theorem it turns out that in motor

243
00:10:03,680 --> 00:10:07,459
systems you don't have a only CPU but

244
00:10:05,870 --> 00:10:08,930
the other system on chip that contains

245
00:10:07,460 --> 00:10:10,310
the CPU GPU

246
00:10:08,930 --> 00:10:14,599
which is the signal processor and

247
00:10:10,310 --> 00:10:16,640
whatnot and the CPU is not the only one

248
00:10:14,600 --> 00:10:19,130
available from the web so you can run

249
00:10:16,640 --> 00:10:22,040
your code on JavaScript in JavaScript on

250
00:10:19,130 --> 00:10:23,480
the CPU but as you maybe have guessed

251
00:10:22,040 --> 00:10:26,689
from the title of this talk you can also

252
00:10:23,480 --> 00:10:30,890
use WebGL on the GPU so you can run code

253
00:10:26,690 --> 00:10:33,440
on the GPU from the web so back to the

254
00:10:30,890 --> 00:10:35,199
other primitives now we need to figure

255
00:10:33,440 --> 00:10:37,910
out how to get these two from the GPU

256
00:10:35,200 --> 00:10:40,310
and also we need to figure out how to

257
00:10:37,910 --> 00:10:44,270
get DM access first of all to from the

258
00:10:40,310 --> 00:10:45,619
GPU so to understand how we get theorem

259
00:10:44,270 --> 00:10:48,260
axis we first need to understand how the

260
00:10:45,620 --> 00:10:51,170
GPU works so let's have a bit of

261
00:10:48,260 --> 00:10:54,140
introduction on how this works so the

262
00:10:51,170 --> 00:10:55,969
GPU as the purpose of aiding the

263
00:10:54,140 --> 00:10:59,720
rendering pipeline which consists in

264
00:10:55,970 --> 00:11:02,330
mainly four stages at the beginning you

265
00:10:59,720 --> 00:11:05,950
have the CPU providing with inputs the

266
00:11:02,330 --> 00:11:08,330
GPU and these inputs is vertices and

267
00:11:05,950 --> 00:11:09,590
then these vertices are sent to the GPU

268
00:11:08,330 --> 00:11:11,180
to run

269
00:11:09,590 --> 00:11:13,010
of computations on them and the first

270
00:11:11,180 --> 00:11:14,630
one is some geometrical computations

271
00:11:13,010 --> 00:11:17,240
that are performed by the vertex shader

272
00:11:14,630 --> 00:11:20,210
so this computation are usually

273
00:11:17,240 --> 00:11:24,170
rotations or translations and then you

274
00:11:20,210 --> 00:11:26,510
get the output the modified vertices at

275
00:11:24,170 --> 00:11:28,880
the output of the vertex shader you will

276
00:11:26,510 --> 00:11:30,530
get a polygon which basically is the

277
00:11:28,880 --> 00:11:33,020
edges that connect these different

278
00:11:30,530 --> 00:11:37,430
vertices and the polygon contains all

279
00:11:33,020 --> 00:11:39,620
the pixels inside these edges and the

280
00:11:37,430 --> 00:11:40,819
pixels are it's not exactly a pixel

281
00:11:39,620 --> 00:11:42,500
they're actually called fragments and

282
00:11:40,820 --> 00:11:44,390
the fragments that one that gets sent

283
00:11:42,500 --> 00:11:45,830
then to the fragment shader so the

284
00:11:44,390 --> 00:11:50,810
fragment shader as the purpose of

285
00:11:45,830 --> 00:11:52,250
coloring these pixels one by one now

286
00:11:50,810 --> 00:11:53,959
usually you don't want to just draw a

287
00:11:52,250 --> 00:11:56,600
red triangle that would be kind of

288
00:11:53,960 --> 00:11:59,890
useless so you want to use textures to

289
00:11:56,600 --> 00:12:02,750
do it to make a fancier rendering and

290
00:11:59,890 --> 00:12:05,720
therefore the GPU needs to accept these

291
00:12:02,750 --> 00:12:07,760
textures as an external input and then

292
00:12:05,720 --> 00:12:10,340
in this case you will get your booting

293
00:12:07,760 --> 00:12:12,650
texture to color your wooden triangle

294
00:12:10,340 --> 00:12:14,870
and now at the output is going to be

295
00:12:12,650 --> 00:12:18,670
your wooden triangle on the screen of

296
00:12:14,870 --> 00:12:20,720
your smartphone so on the frame buffer

297
00:12:18,670 --> 00:12:25,819
now how does this work

298
00:12:20,720 --> 00:12:29,960
on the GPU architecture so this is an

299
00:12:25,820 --> 00:12:32,060
idea of how the GPU looks like and you

300
00:12:29,960 --> 00:12:34,670
have these units which are the stream

301
00:12:32,060 --> 00:12:38,479
processors which are basically the main

302
00:12:34,670 --> 00:12:39,770
course of the GPU and usually a multiple

303
00:12:38,480 --> 00:12:43,880
of them to paralyze as much as possible

304
00:12:39,770 --> 00:12:45,770
your computations and what they do is

305
00:12:43,880 --> 00:12:49,550
they start by querying the vertices from

306
00:12:45,770 --> 00:12:52,970
DRAM to run the vertex shader so you get

307
00:12:49,550 --> 00:12:54,709
the polygons at the end of the vertex

308
00:12:52,970 --> 00:12:57,710
shader inside your stream processors and

309
00:12:54,710 --> 00:13:00,920
then what it does is other units which

310
00:12:57,710 --> 00:13:03,290
are the textual processors to get the

311
00:13:00,920 --> 00:13:05,930
texture from memory and fill in the the

312
00:13:03,290 --> 00:13:08,660
fragment fragments with the associated

313
00:13:05,930 --> 00:13:12,229
pixel of the texture at the end you will

314
00:13:08,660 --> 00:13:14,240
get the content in the frame buffer now

315
00:13:12,230 --> 00:13:19,130
this gives you three possibilities to

316
00:13:14,240 --> 00:13:20,330
get DM axis and this address of the

317
00:13:19,130 --> 00:13:21,410
vertices in texture and the frame buffer

318
00:13:20,330 --> 00:13:24,170
as you can understand

319
00:13:21,410 --> 00:13:27,350
and turns out that reading the texture

320
00:13:24,170 --> 00:13:30,140
is the most predictable one so it's the

321
00:13:27,350 --> 00:13:32,510
one which shows and the way this works

322
00:13:30,140 --> 00:13:35,930
is you can just write a program so this

323
00:13:32,510 --> 00:13:38,270
is an example of a fragment shader where

324
00:13:35,930 --> 00:13:40,699
you use this instruction the texture to

325
00:13:38,270 --> 00:13:43,930
the instruction to get the content from

326
00:13:40,700 --> 00:13:45,980
a texture at specific coordinates and

327
00:13:43,930 --> 00:13:47,569
the way you can see this is basically

328
00:13:45,980 --> 00:13:50,600
saying you have an array which is your

329
00:13:47,570 --> 00:13:53,720
texture of the raw data and you access

330
00:13:50,600 --> 00:13:55,190
at index coordinate that content now

331
00:13:53,720 --> 00:13:57,170
again the mapping is not super

332
00:13:55,190 --> 00:13:58,730
straightforward but once you know the

333
00:13:57,170 --> 00:14:01,640
function that is used for the mapping

334
00:13:58,730 --> 00:14:05,990
between the raw data and their shot

335
00:14:01,640 --> 00:14:10,900
pixels it's easy to touch specific

336
00:14:05,990 --> 00:14:14,360
locations in memory so we have diem axis

337
00:14:10,900 --> 00:14:16,189
what about the caches well we didn't

338
00:14:14,360 --> 00:14:18,620
mention them but there are also here to

339
00:14:16,190 --> 00:14:21,590
level of caches so l1 l2 r2 level of

340
00:14:18,620 --> 00:14:23,960
caches and they do the same thing as for

341
00:14:21,590 --> 00:14:26,570
the CPU so let's say again you want to

342
00:14:23,960 --> 00:14:29,900
run this code you would get the content

343
00:14:26,570 --> 00:14:31,760
for the variable a from the texture so

344
00:14:29,900 --> 00:14:35,079
the text processor is going to query the

345
00:14:31,760 --> 00:14:37,640
memory and then bring the content to l1

346
00:14:35,080 --> 00:14:39,530
and the next time you're gonna get it

347
00:14:37,640 --> 00:14:42,560
directly from there so you don't touch

348
00:14:39,530 --> 00:14:44,660
memory anymore and so what's the

349
00:14:42,560 --> 00:14:46,069
advantage of using the GPU so if you

350
00:14:44,660 --> 00:14:49,010
still have the caches what what's the

351
00:14:46,070 --> 00:14:50,840
point of using it at all it turns out

352
00:14:49,010 --> 00:14:52,370
that these caches were not documented at

353
00:14:50,840 --> 00:14:55,880
all so we had to reverse-engineer them

354
00:14:52,370 --> 00:14:59,210
ourselves and quite different from CPU

355
00:14:55,880 --> 00:15:01,460
caches so the difference is that the

356
00:14:59,210 --> 00:15:03,050
cache that very small and they

357
00:15:01,460 --> 00:15:06,650
implemented deterministic replacement

358
00:15:03,050 --> 00:15:08,150
policy and this means that once you want

359
00:15:06,650 --> 00:15:11,780
to trigger your bit flips what you need

360
00:15:08,150 --> 00:15:16,010
to do is just touch the first rows or n

361
00:15:11,780 --> 00:15:18,350
minus 1 and then bring the content okay

362
00:15:16,010 --> 00:15:21,920
to the cache same for a row and plus one

363
00:15:18,350 --> 00:15:23,150
and then you start evicting but the

364
00:15:21,920 --> 00:15:25,640
fiction here is deterministic so you

365
00:15:23,150 --> 00:15:28,790
know how many accesses you need to

366
00:15:25,640 --> 00:15:30,080
perform and at the same time you know

367
00:15:28,790 --> 00:15:32,270
that every time you do it is gonna be

368
00:15:30,080 --> 00:15:35,180
the same so you know that for sure once

369
00:15:32,270 --> 00:15:38,210
you access enough objects which

370
00:15:35,180 --> 00:15:40,670
v16 orator depends on the GPU you will

371
00:15:38,210 --> 00:15:43,820
remove the content and you can trigger

372
00:15:40,670 --> 00:15:48,310
your bit flips so yay it's fast enough

373
00:15:43,820 --> 00:15:48,310
for bit flips we can we can use it and

374
00:15:48,490 --> 00:15:55,820
so the next step is trying to figure out

375
00:15:51,080 --> 00:15:57,170
how to get contiguous memory and to do

376
00:15:55,820 --> 00:16:01,280
this we first need to understand how the

377
00:15:57,170 --> 00:16:03,620
memory gets allocated now here's a bit

378
00:16:01,280 --> 00:16:06,579
of simplification this looks this is a

379
00:16:03,620 --> 00:16:08,780
page in memory so it's four kilobyte and

380
00:16:06,580 --> 00:16:10,430
this is not exactly how it looks in the

381
00:16:08,780 --> 00:16:14,540
ROM but you have multiple pages in the

382
00:16:10,430 --> 00:16:18,439
same row usually and let's say we want

383
00:16:14,540 --> 00:16:20,480
to look at some textures from WebGL what

384
00:16:18,440 --> 00:16:22,970
you would do is you say you want to

385
00:16:20,480 --> 00:16:25,070
allocate texture of four kilobytes so

386
00:16:22,970 --> 00:16:27,530
the operating system we try to not

387
00:16:25,070 --> 00:16:28,820
fragment the memory so it will provide

388
00:16:27,530 --> 00:16:31,329
it with the smallest possible chunk

389
00:16:28,820 --> 00:16:34,850
available that time so we start with the

390
00:16:31,330 --> 00:16:38,300
single pages so this is isolated so it's

391
00:16:34,850 --> 00:16:39,680
single saying goes for this one this one

392
00:16:38,300 --> 00:16:41,630
the same but then you will start getting

393
00:16:39,680 --> 00:16:42,829
a contiguous pages first for instance

394
00:16:41,630 --> 00:16:44,660
these two are still considered

395
00:16:42,830 --> 00:16:47,360
contiguous even though it's just two

396
00:16:44,660 --> 00:16:49,480
pages and then after that you will start

397
00:16:47,360 --> 00:16:52,340
getting the bigger chunks so once you

398
00:16:49,480 --> 00:16:53,570
exhaust all these more ones you will

399
00:16:52,340 --> 00:16:57,110
start going to the bigger ones and

400
00:16:53,570 --> 00:16:58,880
you'll get the content of this one until

401
00:16:57,110 --> 00:17:02,510
one point you get your three contiguous

402
00:16:58,880 --> 00:17:03,890
rows that you want now you have a part

403
00:17:02,510 --> 00:17:07,400
which is horrible and a part which is

404
00:17:03,890 --> 00:17:11,180
not honorable so we need to figure out

405
00:17:07,400 --> 00:17:13,840
how to distinguish them so that's that's

406
00:17:11,180 --> 00:17:18,050
the main problem now and the answer is

407
00:17:13,839 --> 00:17:19,579
we can use side channels and at the bush

408
00:17:18,050 --> 00:17:22,430
like we are actually quite good at that

409
00:17:19,579 --> 00:17:23,960
we really like them so it was the first

410
00:17:22,430 --> 00:17:26,450
thing we came to our mind to try to use

411
00:17:23,960 --> 00:17:32,420
this one and the side channel here is on

412
00:17:26,450 --> 00:17:34,040
how theorem works so a bit of recap we

413
00:17:32,420 --> 00:17:36,740
said that one when you want to read it

414
00:17:34,040 --> 00:17:38,510
from theorem what you need to do is you

415
00:17:36,740 --> 00:17:39,980
say let's you want to read it from at

416
00:17:38,510 --> 00:17:42,320
that page what you need to do is that

417
00:17:39,980 --> 00:17:43,850
you activate a row you bring it to the

418
00:17:42,320 --> 00:17:47,960
row buffer and then you can read from

419
00:17:43,850 --> 00:17:48,899
there and then you send it back so the

420
00:17:47,960 --> 00:17:51,150
trick here is that

421
00:17:48,900 --> 00:17:52,740
that contiguous memory is to touch

422
00:17:51,150 --> 00:17:54,780
different pages that you allocated

423
00:17:52,740 --> 00:17:56,760
continuously so you think okay and

424
00:17:54,780 --> 00:17:58,290
texture one first and then texture to

425
00:17:56,760 --> 00:17:59,430
when you keep on going with that you

426
00:17:58,290 --> 00:18:00,990
touch a different texture that you've

427
00:17:59,430 --> 00:18:04,320
just allocated so let's say you want to

428
00:18:00,990 --> 00:18:07,320
touch this first three textures and this

429
00:18:04,320 --> 00:18:10,020
will do this this process so we will

430
00:18:07,320 --> 00:18:12,540
touch the you take the first row and you

431
00:18:10,020 --> 00:18:15,840
will activate it you read from there and

432
00:18:12,540 --> 00:18:17,940
then you send it back second row read it

433
00:18:15,840 --> 00:18:21,689
from there and send it back and again

434
00:18:17,940 --> 00:18:24,180
for the last one now clearly this is a

435
00:18:21,690 --> 00:18:26,280
low most of a time but most importantly

436
00:18:24,180 --> 00:18:29,280
is very noisy so you don't know where

437
00:18:26,280 --> 00:18:31,230
the data is going to come from and as a

438
00:18:29,280 --> 00:18:32,790
consequence you don't know what like the

439
00:18:31,230 --> 00:18:34,020
standard deviation of your signal is

440
00:18:32,790 --> 00:18:37,740
going to be very different depending on

441
00:18:34,020 --> 00:18:39,330
which pages you touch it's very

442
00:18:37,740 --> 00:18:41,760
different for contiguous memory so let's

443
00:18:39,330 --> 00:18:43,949
say you want to do the same but when you

444
00:18:41,760 --> 00:18:46,379
have a textures are located by a

445
00:18:43,950 --> 00:18:48,300
contiguous memory and you want to touch

446
00:18:46,380 --> 00:18:51,480
again the first three what thing to do

447
00:18:48,300 --> 00:18:54,780
is you just activate that row touch the

448
00:18:51,480 --> 00:18:56,430
first three and send it back and this

449
00:18:54,780 --> 00:18:59,610
provides you with a very fast and clear

450
00:18:56,430 --> 00:19:02,610
signal and you can distinguish these two

451
00:18:59,610 --> 00:19:04,139
signals from from the GPU as a

452
00:19:02,610 --> 00:19:06,389
consequence you can figure out when the

453
00:19:04,140 --> 00:19:08,220
when the GPU is allocated when the

454
00:19:06,390 --> 00:19:11,490
current has allocated for the GPU

455
00:19:08,220 --> 00:19:15,060
contiguous memory for the textures now

456
00:19:11,490 --> 00:19:18,180
to detect this this side channel you

457
00:19:15,060 --> 00:19:19,860
need timers and turns out that what GL

458
00:19:18,180 --> 00:19:23,280
provides you with the two family of

459
00:19:19,860 --> 00:19:28,500
timers the first one is a based on the

460
00:19:23,280 --> 00:19:30,270
disjoint timer query extension and this

461
00:19:28,500 --> 00:19:31,950
is a very similar to clock at time so

462
00:19:30,270 --> 00:19:34,320
you just ask for a timestamp and you get

463
00:19:31,950 --> 00:19:37,590
back the value and this has a very high

464
00:19:34,320 --> 00:19:39,240
resolution and the problem with it is

465
00:19:37,590 --> 00:19:41,310
that since its extension base you can

466
00:19:39,240 --> 00:19:42,660
simply disable it you just remove the

467
00:19:41,310 --> 00:19:46,200
extension and then you resolve the

468
00:19:42,660 --> 00:19:47,910
problem so to prove our theory we found

469
00:19:46,200 --> 00:19:51,360
another timer as well which is great on

470
00:19:47,910 --> 00:19:54,090
web geosync object and these objects are

471
00:19:51,360 --> 00:19:57,719
basically fences to synchronize CPU and

472
00:19:54,090 --> 00:19:58,620
GPU operations and even though these are

473
00:19:57,720 --> 00:20:00,900
more coarse-grained

474
00:19:58,620 --> 00:20:01,709
they have still good enough for our side

475
00:20:00,900 --> 00:20:03,659
Channel

476
00:20:01,710 --> 00:20:07,350
and since they are implicit in the WebGL

477
00:20:03,659 --> 00:20:09,510
to standard they they cannot be simply

478
00:20:07,350 --> 00:20:11,789
disabled but you need to really find a

479
00:20:09,510 --> 00:20:13,279
standard basically and the reason why

480
00:20:11,789 --> 00:20:15,390
these are scary is because then you can

481
00:20:13,279 --> 00:20:16,649
reinvent attacks such as spectra for

482
00:20:15,390 --> 00:20:19,049
instance so once you have these kind of

483
00:20:16,649 --> 00:20:21,840
timers and you can measure again cache

484
00:20:19,049 --> 00:20:24,090
tour and cache memory accesses you can

485
00:20:21,840 --> 00:20:29,789
bring back to life attacks such as

486
00:20:24,090 --> 00:20:32,220
spectra so we have our three primitives

487
00:20:29,789 --> 00:20:34,500
the next step is what do we do with

488
00:20:32,220 --> 00:20:37,740
these primitives and the answer is

489
00:20:34,500 --> 00:20:39,870
glitch glitch is our exploit that we

490
00:20:37,740 --> 00:20:41,730
developed and without the glitch because

491
00:20:39,870 --> 00:20:45,750
of Rama which is a hardware glitch and

492
00:20:41,730 --> 00:20:47,429
GL because of what gel and the way a

493
00:20:45,750 --> 00:20:50,610
glitch works is basically a flipping

494
00:20:47,429 --> 00:20:51,990
show in JavaScript so we call this

495
00:20:50,610 --> 00:20:53,939
process flipping shoe because it's very

496
00:20:51,990 --> 00:20:56,370
similar to any hit Fung shooey attack

497
00:20:53,940 --> 00:20:58,980
but you do it on physical level so and

498
00:20:56,370 --> 00:21:01,350
Ihram so the first step which is

499
00:20:58,980 --> 00:21:04,140
specific for our attack is you need to

500
00:21:01,350 --> 00:21:08,010
allocate and detect contiguous memory so

501
00:21:04,140 --> 00:21:10,169
we use our side channel then what you

502
00:21:08,010 --> 00:21:11,850
need to do is memory templating so

503
00:21:10,169 --> 00:21:14,390
memory templating is the process of

504
00:21:11,850 --> 00:21:17,070
looking for exploitable bit flips and

505
00:21:14,390 --> 00:21:18,570
basically you just allocate a big chunk

506
00:21:17,070 --> 00:21:20,600
of memory and then you start scanning

507
00:21:18,570 --> 00:21:24,090
for this bit flips until you find them

508
00:21:20,600 --> 00:21:25,889
then you perform memory massaging which

509
00:21:24,090 --> 00:21:27,330
is the process of releasing this texture

510
00:21:25,890 --> 00:21:31,169
that you found with the vulnerable

511
00:21:27,330 --> 00:21:33,809
memory with the vulnerable self and that

512
00:21:31,169 --> 00:21:37,740
trigger the allocation of sensitive data

513
00:21:33,809 --> 00:21:39,029
so what you would do is get any

514
00:21:37,740 --> 00:21:41,279
JavaScript application you want to

515
00:21:39,029 --> 00:21:44,669
compromise and spawn the allocation of

516
00:21:41,279 --> 00:21:48,899
this data to have it eventually end up

517
00:21:44,669 --> 00:21:50,850
in the specific location in memory and

518
00:21:48,899 --> 00:21:52,949
finally exploitation which is the act of

519
00:21:50,850 --> 00:21:56,178
triggering the be flippin use like this

520
00:21:52,950 --> 00:21:57,990
date that you just found so the

521
00:21:56,179 --> 00:21:59,970
interesting part here is the

522
00:21:57,990 --> 00:22:02,309
exploitation because the rest it's very

523
00:21:59,970 --> 00:22:04,380
trivial to to understand how it works

524
00:22:02,309 --> 00:22:07,320
and the question is what's the target of

525
00:22:04,380 --> 00:22:10,980
our exploitation and the target are Java

526
00:22:07,320 --> 00:22:14,200
arrays so let's say you want to locate

527
00:22:10,980 --> 00:22:17,590
an array of 100 elements

528
00:22:14,200 --> 00:22:20,260
and then you can for instance put an

529
00:22:17,590 --> 00:22:22,750
integer in there and then a double in

530
00:22:20,260 --> 00:22:24,519
there an object so you can just create

531
00:22:22,750 --> 00:22:27,039
another array implicit in the same array

532
00:22:24,519 --> 00:22:30,279
and a lot of other things or other

533
00:22:27,039 --> 00:22:33,190
double strings or functions boolean

534
00:22:30,279 --> 00:22:36,279
whatever you want now the first question

535
00:22:33,190 --> 00:22:40,240
is why would you do it because it's not

536
00:22:36,279 --> 00:22:42,460
very smart considering that it can be

537
00:22:40,240 --> 00:22:43,559
very insecure to do this but the second

538
00:22:42,460 --> 00:22:45,789
question is how would you do it

539
00:22:43,559 --> 00:22:48,129
efficiently because of course a browser

540
00:22:45,789 --> 00:22:49,929
wants to keep up performances so they

541
00:22:48,130 --> 00:22:53,350
need to have a an efficient way to do

542
00:22:49,929 --> 00:22:59,710
this and not decrease the performances

543
00:22:53,350 --> 00:23:02,408
and the answer is a non boxing now how

544
00:22:59,710 --> 00:23:06,669
many of you know about non boxing is

545
00:23:02,409 --> 00:23:10,539
anyone familiar with non boxing no okay

546
00:23:06,669 --> 00:23:13,990
well I'm gonna explain so numb boxing

547
00:23:10,539 --> 00:23:17,740
it's a consequence of the way that the

548
00:23:13,990 --> 00:23:20,080
IT Polly consortium decided to design

549
00:23:17,740 --> 00:23:22,210
floating-point numbers so let's say you

550
00:23:20,080 --> 00:23:24,240
have these two numbers one point one

551
00:23:22,210 --> 00:23:26,980
twenty five and eleven point five and

552
00:23:24,240 --> 00:23:28,840
the way this is a usually stored is by

553
00:23:26,980 --> 00:23:31,389
using the explanation notation so what

554
00:23:28,840 --> 00:23:34,449
you do is you just get the significant

555
00:23:31,389 --> 00:23:36,189
and the exponent and the significant

556
00:23:34,450 --> 00:23:40,000
this case you see is the same so you

557
00:23:36,190 --> 00:23:42,190
have 1125 times the different exponent

558
00:23:40,000 --> 00:23:43,480
so one is ten to the minus to the power

559
00:23:42,190 --> 00:23:47,860
of minus three and the other one is my

560
00:23:43,480 --> 00:23:49,720
two powers million to minus two and as

561
00:23:47,860 --> 00:23:51,580
you can see the significant is the same

562
00:23:49,720 --> 00:23:55,360
but the explain is different in this

563
00:23:51,580 --> 00:23:58,720
case now in binary what you have instead

564
00:23:55,360 --> 00:24:00,570
is you have your sign bit which tells

565
00:23:58,720 --> 00:24:02,860
you if it's positive or negative number

566
00:24:00,570 --> 00:24:06,220
then you have eleven bits for the

567
00:24:02,860 --> 00:24:07,719
exponent and then finally you have 52

568
00:24:06,220 --> 00:24:12,510
bits for the mantissa which is the

569
00:24:07,720 --> 00:24:16,120
significant and what to design during

570
00:24:12,510 --> 00:24:18,100
when they decide the standard it was

571
00:24:16,120 --> 00:24:21,729
that if all the exponent bits are set to

572
00:24:18,100 --> 00:24:23,949
one and another bit inside the

573
00:24:21,730 --> 00:24:27,140
significant is set to one as well

574
00:24:23,950 --> 00:24:29,900
this value would be considered as none

575
00:24:27,140 --> 00:24:31,960
stands for not a number which means that

576
00:24:29,900 --> 00:24:35,930
that value cannot really use it for any

577
00:24:31,960 --> 00:24:37,520
computation but it's just there so this

578
00:24:35,930 --> 00:24:40,550
means that you have to do a power of

579
00:24:37,520 --> 00:24:44,300
fifty three minus one and use values in

580
00:24:40,550 --> 00:24:45,860
the same encoding and clearly smart

581
00:24:44,300 --> 00:24:48,110
people thought well what if you actually

582
00:24:45,860 --> 00:24:50,479
store pointers in there so why don't we

583
00:24:48,110 --> 00:24:52,699
use this encoding for the browser to

584
00:24:50,480 --> 00:24:55,720
store pointers and then we can use the

585
00:24:52,700 --> 00:25:00,020
same value to still store numbers and

586
00:24:55,720 --> 00:25:04,400
also objects so the way they do it in in

587
00:25:00,020 --> 00:25:06,200
Firefox 32 bit so we analyzed the 32 bit

588
00:25:04,400 --> 00:25:10,310
version because our exploit was running

589
00:25:06,200 --> 00:25:14,200
on a nexus 5 but similar encoding works

590
00:25:10,310 --> 00:25:17,120
works on 64-bit it's just a different

591
00:25:14,200 --> 00:25:20,390
formatting so what they do is they

592
00:25:17,120 --> 00:25:22,639
divided the 64 bits into parts so you

593
00:25:20,390 --> 00:25:25,040
have a tag and a payload clearly these

594
00:25:22,640 --> 00:25:30,020
are 32 bits each because it's a 32 bit

595
00:25:25,040 --> 00:25:32,120
environment and and what they do is they

596
00:25:30,020 --> 00:25:34,070
check the tag and if the tag is less of

597
00:25:32,120 --> 00:25:37,010
a threshold value which is this one in

598
00:25:34,070 --> 00:25:38,689
case of a Firefox 32 bit the value the

599
00:25:37,010 --> 00:25:42,950
whole 64 bits is going to be considered

600
00:25:38,690 --> 00:25:45,380
as a double number whereas if the tag is

601
00:25:42,950 --> 00:25:47,810
considered if the tag is bigger than

602
00:25:45,380 --> 00:25:49,280
that value the the whole thing is going

603
00:25:47,810 --> 00:25:50,270
to be considered know that the pillow is

604
00:25:49,280 --> 00:25:55,280
going to be considered as a pointer

605
00:25:50,270 --> 00:25:56,960
sorry so what happens here is that let's

606
00:25:55,280 --> 00:25:59,030
say you want to write in the array these

607
00:25:56,960 --> 00:26:00,530
two values well of course you can try

608
00:25:59,030 --> 00:26:02,810
them in JavaScript but it's just to

609
00:26:00,530 --> 00:26:04,550
understand what's happening you would

610
00:26:02,810 --> 00:26:05,990
have like the 64 bits inside the value

611
00:26:04,550 --> 00:26:07,430
and the Java square we would interpret

612
00:26:05,990 --> 00:26:09,980
the first one and the second one

613
00:26:07,430 --> 00:26:11,480
differently and the first one is going

614
00:26:09,980 --> 00:26:15,710
to be a double and second on the a

615
00:26:11,480 --> 00:26:19,700
pointer to an object and both of them

616
00:26:15,710 --> 00:26:22,670
have the same payload but the tag is

617
00:26:19,700 --> 00:26:25,460
different from one bit which in other

618
00:26:22,670 --> 00:26:28,580
terms is basically one bit flip away one

619
00:26:25,460 --> 00:26:31,580
from the other and now you can see

620
00:26:28,580 --> 00:26:34,550
what's the point of our primitive so our

621
00:26:31,580 --> 00:26:36,230
print is called the type flipping and

622
00:26:34,550 --> 00:26:39,860
what you can do is basically by

623
00:26:36,230 --> 00:26:40,730
triggering a bit flip in the tag you can

624
00:26:39,860 --> 00:26:42,678
convert

625
00:26:40,730 --> 00:26:44,539
and you pointed into a double which

626
00:26:42,679 --> 00:26:45,580
means that you can break a Solara as

627
00:26:44,539 --> 00:26:48,019
simple as that

628
00:26:45,580 --> 00:26:49,730
and you can convert any double into a

629
00:26:48,019 --> 00:26:56,419
pointer which means that you can craft

630
00:26:49,730 --> 00:26:58,639
any pointer without any restriction so

631
00:26:56,419 --> 00:27:00,470
this gives us two primitives an

632
00:26:58,639 --> 00:27:03,229
arbitrary lick with the 1 to 0 bit flip

633
00:27:00,470 --> 00:27:09,409
and an arbitrary craft with a 0 to 1 bit

634
00:27:03,230 --> 00:27:11,929
flip now sound my ask may ask why a 0 n

635
00:27:09,409 --> 00:27:15,499
bit flip since bit flips are discharges

636
00:27:11,929 --> 00:27:17,149
of of capacitors and the reason is

637
00:27:15,499 --> 00:27:20,320
because of the encoding that that you

638
00:27:17,149 --> 00:27:23,629
have in theorem so sometimes you have

639
00:27:20,320 --> 00:27:25,489
cells that are recognized as zeros even

640
00:27:23,629 --> 00:27:28,039
though they are charged and in the

641
00:27:25,489 --> 00:27:29,359
indium so the logical value C when you

642
00:27:28,039 --> 00:27:31,059
perform your computation is different

643
00:27:29,359 --> 00:27:33,499
what is actually stored in diem and

644
00:27:31,059 --> 00:27:38,090
that's why you can perform both of the

645
00:27:33,499 --> 00:27:40,100
bit flips and then what you want to do

646
00:27:38,090 --> 00:27:44,178
is to get an arbitrary readwrite

647
00:27:40,100 --> 00:27:45,379
primitive so the idea is that you want

648
00:27:44,179 --> 00:27:47,119
to have an object that allows you to

649
00:27:45,379 --> 00:27:48,350
scan the memory and right there so you

650
00:27:47,119 --> 00:27:51,199
just want to have this object that

651
00:27:48,350 --> 00:27:54,949
allows you to go around and scan and

652
00:27:51,200 --> 00:27:57,080
change whatever you want and the way you

653
00:27:54,950 --> 00:27:59,629
can do this is with the rate buffers in

654
00:27:57,080 --> 00:28:01,309
in JavaScript so every time you think

655
00:27:59,629 --> 00:28:03,980
about the arbitrary readwrite primitive

656
00:28:01,309 --> 00:28:07,129
in JavaScript the go to object is an

657
00:28:03,980 --> 00:28:09,679
array buffer now an array buffer as an

658
00:28:07,129 --> 00:28:12,799
adder with a pointer to the data and it

659
00:28:09,679 --> 00:28:15,859
is just a byte array and then it has a

660
00:28:12,799 --> 00:28:18,830
size value that tells you how big is the

661
00:28:15,859 --> 00:28:21,019
DeRay the problem we decides that if you

662
00:28:18,830 --> 00:28:22,999
want to perform an access out of bounds

663
00:28:21,019 --> 00:28:25,509
of course it's going to trigger an error

664
00:28:22,999 --> 00:28:27,739
because you're not allowed to read that

665
00:28:25,509 --> 00:28:31,759
and as a consequence we need to go

666
00:28:27,739 --> 00:28:33,710
deeper and with this we mean that you

667
00:28:31,759 --> 00:28:35,779
actually need to create a fake array

668
00:28:33,710 --> 00:28:37,039
buffer inside the array buffer so it's

669
00:28:35,779 --> 00:28:39,859
kind of an inception and that's why the

670
00:28:37,039 --> 00:28:42,169
reference and then you want to trigger

671
00:28:39,859 --> 00:28:48,199
you want to create a reference to that

672
00:28:42,169 --> 00:28:52,009
array buffer and the problem here is

673
00:28:48,200 --> 00:28:53,460
that you have two challenges the first

674
00:28:52,009 --> 00:28:55,710
one is that

675
00:28:53,460 --> 00:28:57,809
the header of the array buffer contains

676
00:28:55,710 --> 00:28:59,130
other data structure that you don't know

677
00:28:57,809 --> 00:29:01,350
so there are some unknown fields in

678
00:28:59,130 --> 00:29:02,790
there for instance the garbage collector

679
00:29:01,350 --> 00:29:07,168
root which of course you are not

680
00:29:02,790 --> 00:29:08,790
supposed to know and as a consequence

681
00:29:07,169 --> 00:29:10,200
when you want to create your own fake

682
00:29:08,790 --> 00:29:13,710
carrot buffer you also need to know this

683
00:29:10,200 --> 00:29:15,809
data and the second one is that you

684
00:29:13,710 --> 00:29:20,190
don't know the location of the of the

685
00:29:15,809 --> 00:29:21,629
data so you can know the the location of

686
00:29:20,190 --> 00:29:23,480
the header because that's the reference

687
00:29:21,630 --> 00:29:26,070
to would store in your JavaScript array

688
00:29:23,480 --> 00:29:29,760
so you can trigger the bit flip to

689
00:29:26,070 --> 00:29:31,799
liquidate and break a SLR but you cannot

690
00:29:29,760 --> 00:29:36,330
know the value of the distance between

691
00:29:31,799 --> 00:29:38,040
the header and the and the byte array so

692
00:29:36,330 --> 00:29:41,189
to solve the first challenge the second

693
00:29:38,040 --> 00:29:44,100
challenge we can use inline array

694
00:29:41,190 --> 00:29:49,679
buffers which are array buffers that are

695
00:29:44,100 --> 00:29:52,469
created for values of less than 96 bytes

696
00:29:49,679 --> 00:29:54,990
I think if I remember correctly so if

697
00:29:52,470 --> 00:29:57,510
the if the size of the of the battery is

698
00:29:54,990 --> 00:30:00,260
less than that value the header and the

699
00:29:57,510 --> 00:30:05,059
data are going to be stored sequentially

700
00:30:00,260 --> 00:30:07,650
and for the second challenge is that

701
00:30:05,059 --> 00:30:10,889
well then of course like once you know

702
00:30:07,650 --> 00:30:12,570
the the the distance is the is like the

703
00:30:10,890 --> 00:30:14,130
two things that the header and the data

704
00:30:12,570 --> 00:30:16,439
are connected then once you look the

705
00:30:14,130 --> 00:30:19,140
data pointer then you can also know the

706
00:30:16,440 --> 00:30:22,500
the offset between that and and the

707
00:30:19,140 --> 00:30:24,570
battery for the further the challenge is

708
00:30:22,500 --> 00:30:28,860
that unknown other fields in something

709
00:30:24,570 --> 00:30:30,540
more and this is an arbitrary grid which

710
00:30:28,860 --> 00:30:32,639
means it need to first get an arbitrary

711
00:30:30,540 --> 00:30:35,129
width at to lik that content to then get

712
00:30:32,640 --> 00:30:39,720
the arbitrary right and the way we do

713
00:30:35,130 --> 00:30:43,350
this is by using javascript strings so

714
00:30:39,720 --> 00:30:46,200
this is a class so unicode strings can

715
00:30:43,350 --> 00:30:49,110
read any value in 16 bytes so you can

716
00:30:46,200 --> 00:30:55,020
read that anything from 0 0 0 to FFF

717
00:30:49,110 --> 00:30:57,299
and the way this class looks like is you

718
00:30:55,020 --> 00:31:00,418
have a flag so it tells you what type of

719
00:30:57,299 --> 00:31:02,460
string you add then a length which is

720
00:31:00,419 --> 00:31:04,150
the size of the string and then a

721
00:31:02,460 --> 00:31:08,080
pointer to the string

722
00:31:04,150 --> 00:31:11,650
and the first one it's a constant so you

723
00:31:08,080 --> 00:31:13,389
know that you can put one every kind of

724
00:31:11,650 --> 00:31:16,690
values just an integer same for the

725
00:31:13,390 --> 00:31:18,160
length and the pointer to a string is

726
00:31:16,690 --> 00:31:20,290
clear the pointer to the header of the

727
00:31:18,160 --> 00:31:23,050
buffer which you can lick with the with

728
00:31:20,290 --> 00:31:27,159
your type looking typewritten primitive

729
00:31:23,050 --> 00:31:29,379
as a consequence you'll stop that one so

730
00:31:27,160 --> 00:31:32,920
the way you would do it is you create a

731
00:31:29,380 --> 00:31:35,520
fake header of a string which would

732
00:31:32,920 --> 00:31:37,990
point to the header of the array buffer

733
00:31:35,520 --> 00:31:39,430
then once you look once you break a SLR

734
00:31:37,990 --> 00:31:41,410
which you can adjust a reference the

735
00:31:39,430 --> 00:31:47,500
fake string and lick the data in there

736
00:31:41,410 --> 00:31:49,450
and then you can write the fake buffer

737
00:31:47,500 --> 00:31:52,180
either inside your own array buffer

738
00:31:49,450 --> 00:31:57,760
which you can down to get your rabbit

739
00:31:52,180 --> 00:32:01,510
reviewed right so a quick recap of how

740
00:31:57,760 --> 00:32:05,020
this works you have your array with the

741
00:32:01,510 --> 00:32:07,420
reference to the real array buffer and

742
00:32:05,020 --> 00:32:11,830
you first break ice alarm by triggering

743
00:32:07,420 --> 00:32:14,830
a bit flip in the in the pointer to the

744
00:32:11,830 --> 00:32:17,830
to the right buffer once you break a SLR

745
00:32:14,830 --> 00:32:20,590
you can get your arbitrary read so you

746
00:32:17,830 --> 00:32:23,290
just write your double you create a

747
00:32:20,590 --> 00:32:25,510
custom double that with a bit flip with

748
00:32:23,290 --> 00:32:27,070
pointed your fake string and then you

749
00:32:25,510 --> 00:32:29,320
create you trigger the bit flip that

750
00:32:27,070 --> 00:32:32,290
will change that into a pointer so you

751
00:32:29,320 --> 00:32:34,270
can reference your fake string and then

752
00:32:32,290 --> 00:32:36,730
you can lick the the header of the array

753
00:32:34,270 --> 00:32:39,430
buffer and finally you get the arbitrary

754
00:32:36,730 --> 00:32:45,040
ID by triggering the bit flip one again

755
00:32:39,430 --> 00:32:47,620
on the fake array buffer header and then

756
00:32:45,040 --> 00:32:49,780
basically you can lick any data you want

757
00:32:47,620 --> 00:32:55,330
and you can also overwrite any data you

758
00:32:49,780 --> 00:32:59,200
want and to do this in the two bits

759
00:32:55,330 --> 00:33:02,100
loops 1 2 0 bit flip and a 0 2 1 bit

760
00:32:59,200 --> 00:33:04,720
flip so since you need to business

761
00:33:02,100 --> 00:33:07,330
people will ask like why how is it

762
00:33:04,720 --> 00:33:11,410
possible this is faster than current

763
00:33:07,330 --> 00:33:13,780
attacks and the answer is because with

764
00:33:11,410 --> 00:33:16,720
the GPU so this deterministic behavior

765
00:33:13,780 --> 00:33:20,059
of the caches can speed up a lot

766
00:33:16,720 --> 00:33:22,940
the the act of triggering the beef lips

767
00:33:20,059 --> 00:33:26,690
so we can get more busy than previous

768
00:33:22,940 --> 00:33:29,600
JavaScript implementation even on x86

769
00:33:26,690 --> 00:33:32,000
systems and it runs on average on less

770
00:33:29,600 --> 00:33:34,639
than 2 minutes so we run it we run it 20

771
00:33:32,000 --> 00:33:37,160
times and we tested for the for the

772
00:33:34,640 --> 00:33:42,320
average value I was running on average

773
00:33:37,160 --> 00:33:45,160
in 116 seconds so now let's have a short

774
00:33:42,320 --> 00:33:45,159
demo

775
00:34:02,910 --> 00:34:06,570
this open or not

776
00:34:28,929 --> 00:34:36,168
okay so here on the left side we have a

777
00:34:32,840 --> 00:34:37,909
terminal with a shell to the phone so we

778
00:34:36,168 --> 00:34:39,199
cannot recall the phone because you're

779
00:34:37,909 --> 00:34:40,940
using the GPU to trigger the Biff this

780
00:34:39,199 --> 00:34:43,100
so it will conflict with the bit flips

781
00:34:40,940 --> 00:34:46,490
the recording on the screen so what

782
00:34:43,100 --> 00:34:48,259
whether it's on the left side a terminal

783
00:34:46,489 --> 00:34:53,209
to the phone and on the right side where

784
00:34:48,260 --> 00:34:55,580
the bug in Firefox remotely and now what

785
00:34:53,210 --> 00:34:59,990
we do is on the Left we just check the

786
00:34:55,580 --> 00:35:01,509
the base address of the Firefox main

787
00:34:59,990 --> 00:35:03,470
libraries which is the actual library

788
00:35:01,510 --> 00:35:06,590
and on the right side in the meantime

789
00:35:03,470 --> 00:35:10,790
we're starting to locate the textures to

790
00:35:06,590 --> 00:35:14,480
look for our bit flips so you see on the

791
00:35:10,790 --> 00:35:16,130
left side we got the base address on the

792
00:35:14,480 --> 00:35:17,030
other side once we get enough textures

793
00:35:16,130 --> 00:35:21,500
allocated we start looking for

794
00:35:17,030 --> 00:35:23,960
contiguous memory so here we're looking

795
00:35:21,500 --> 00:35:24,980
for the confused memory and then

796
00:35:23,960 --> 00:35:27,860
afterwards once you get the contiguous

797
00:35:24,980 --> 00:35:29,300
memory we start looking for bit flips so

798
00:35:27,860 --> 00:35:32,590
you need to look for a 1 to 0 bit flip

799
00:35:29,300 --> 00:35:32,590
and a 0 to 1 bit flip

800
00:35:39,900 --> 00:35:45,570
so I found two exploitable one-two-zero

801
00:35:42,750 --> 00:35:51,000
bit flips now it's looking for a zero to

802
00:35:45,570 --> 00:35:54,980
one found one but it's not exploitable

803
00:35:51,000 --> 00:35:54,980
which means might not be in the tag

804
00:36:06,880 --> 00:36:13,060
so then once she finds the extra bit

805
00:36:09,850 --> 00:36:14,950
flip what it does is release the texture

806
00:36:13,060 --> 00:36:16,480
that contains this bit flips so once you

807
00:36:14,950 --> 00:36:20,379
find them you want to give back the

808
00:36:16,480 --> 00:36:21,910
memory to the to the operating system so

809
00:36:20,380 --> 00:36:24,190
then once the operating system has back

810
00:36:21,910 --> 00:36:26,080
the memory you can start triggering the

811
00:36:24,190 --> 00:36:32,680
allocation of the JavaScript or digit we

812
00:36:26,080 --> 00:36:35,220
want to compromise so arrays in starts

813
00:36:32,680 --> 00:36:35,220
allocating memory

814
00:36:42,900 --> 00:36:50,010
now it's gonna show up blob of text

815
00:36:44,670 --> 00:36:51,960
which I'm gonna explain so first of all

816
00:36:50,010 --> 00:36:53,640
of course you have to scan the memory

817
00:36:51,960 --> 00:36:55,520
for the big flip so once you place the

818
00:36:53,640 --> 00:36:59,069
erase you need to trigger them and

819
00:36:55,520 --> 00:37:01,050
locate where they're happening in the

820
00:36:59,070 --> 00:37:05,010
array so it can figure out which cells

821
00:37:01,050 --> 00:37:08,160
are the one vulnerable and then as you

822
00:37:05,010 --> 00:37:09,840
can see here you have the the code which

823
00:37:08,160 --> 00:37:11,879
is the actual exploit so what you do is

824
00:37:09,840 --> 00:37:15,330
you first break SLR so you lick the rate

825
00:37:11,880 --> 00:37:17,910
buffer pointer and then yeah there's

826
00:37:15,330 --> 00:37:19,620
some bad formatting from my side then

827
00:37:17,910 --> 00:37:23,009
you create a fake string that contains

828
00:37:19,620 --> 00:37:25,200
that pointer and you trigger a bit that

829
00:37:23,010 --> 00:37:28,800
reference the string and as we said then

830
00:37:25,200 --> 00:37:32,520
you can create the figure a buffer so

831
00:37:28,800 --> 00:37:36,660
now we have a an arbitrary readwrite so

832
00:37:32,520 --> 00:37:38,460
what we do is lick the pointer to a

833
00:37:36,660 --> 00:37:41,190
function and it it a knitting

834
00:37:38,460 --> 00:37:46,050
function so we just try to lick the

835
00:37:41,190 --> 00:37:48,780
pointer to max and then the the base of

836
00:37:46,050 --> 00:37:51,030
the library it's located at a specific

837
00:37:48,780 --> 00:37:52,320
offset from that function since the

838
00:37:51,030 --> 00:38:00,360
function is contained in there so it's a

839
00:37:52,320 --> 00:38:02,760
static offset so as you can see now we

840
00:38:00,360 --> 00:38:03,840
have the same value here for the noise

841
00:38:02,760 --> 00:38:10,830
you can see it let's see if I can zoom

842
00:38:03,840 --> 00:38:13,170
in we have the same value for the for

843
00:38:10,830 --> 00:38:15,200
the base there and the same value over

844
00:38:13,170 --> 00:38:15,200
here

845
00:38:19,110 --> 00:38:25,350
and then eventually what I can do is

846
00:38:20,910 --> 00:38:29,970
read the content from there and you will

847
00:38:25,350 --> 00:38:32,420
see that it's the header of enough

848
00:38:29,970 --> 00:38:32,419
binary

849
00:38:48,940 --> 00:38:53,680
as you can see whether you just lick the

850
00:38:51,970 --> 00:38:58,000
header of the health binary and if you

851
00:38:53,680 --> 00:39:00,220
want then you can just overwrite any

852
00:38:58,000 --> 00:39:12,040
function pointer or whatever else you

853
00:39:00,220 --> 00:39:15,399
want with this primitive and yeah so in

854
00:39:12,040 --> 00:39:17,440
conclusion we show that this was the

855
00:39:15,400 --> 00:39:20,470
first run exploit from JavaScript on

856
00:39:17,440 --> 00:39:24,340
mobile and we showed that it was

857
00:39:20,470 --> 00:39:29,950
possible thanks for the GPU so the GPU

858
00:39:24,340 --> 00:39:31,510
is the the actual the actual - that

859
00:39:29,950 --> 00:39:35,259
provides us with the primitive allows us

860
00:39:31,510 --> 00:39:37,600
to to build this attack and they take

861
00:39:35,260 --> 00:39:39,010
away message of these of this research

862
00:39:37,600 --> 00:39:41,250
is that we actually need to completely

863
00:39:39,010 --> 00:39:45,760
redefine the threat model so so far

864
00:39:41,250 --> 00:39:47,590
everybody just look at the CPU and of

865
00:39:45,760 --> 00:39:51,820
course it's important to look at the CPU

866
00:39:47,590 --> 00:39:54,010
but that's not it and by just restoring

867
00:39:51,820 --> 00:39:56,320
the the threat model to only the CPU

868
00:39:54,010 --> 00:39:57,910
it's actually a very very risky

869
00:39:56,320 --> 00:40:00,220
assumption because it means that you

870
00:39:57,910 --> 00:40:02,020
live out everything else and there is a

871
00:40:00,220 --> 00:40:05,830
lot more in there so you have digital

872
00:40:02,020 --> 00:40:08,110
signal processor we said and now on for

873
00:40:05,830 --> 00:40:11,110
instance on a service system used at the

874
00:40:08,110 --> 00:40:12,880
FPGAs in the same system moonship so you

875
00:40:11,110 --> 00:40:15,820
can run a lot of code on these CPUs to

876
00:40:12,880 --> 00:40:18,910
perform these attacks that is much more

877
00:40:15,820 --> 00:40:23,050
than what is currently considering the

878
00:40:18,910 --> 00:40:24,430
threat model so basically that's it

879
00:40:23,050 --> 00:40:26,770
if you want more information you can

880
00:40:24,430 --> 00:40:30,250
check on the project page of our group

881
00:40:26,770 --> 00:40:36,160
and this is a QR code that brings you

882
00:40:30,250 --> 00:40:37,630
there and you can check me on Twitter I

883
00:40:36,160 --> 00:40:38,500
don't really tweet that much but you can

884
00:40:37,630 --> 00:40:42,690
ask me a question if you have any

885
00:40:38,500 --> 00:40:45,400
question there I was follow bucyk and

886
00:40:42,690 --> 00:40:48,190
yeah so if you think this research is

887
00:40:45,400 --> 00:40:50,290
cool you should probably join us this is

888
00:40:48,190 --> 00:40:52,630
a sales pitch part of the talk we're

889
00:40:50,290 --> 00:40:56,310
hiring so feel free to think as if

890
00:40:52,630 --> 00:40:56,310
you're interested in a PhD in Amsterdam

