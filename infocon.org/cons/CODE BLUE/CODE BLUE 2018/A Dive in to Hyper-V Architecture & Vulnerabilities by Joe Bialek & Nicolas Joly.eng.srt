1
00:00:04,330 --> 00:00:09,950
so glad to be here thank you cut blue

2
00:00:07,370 --> 00:00:12,320
for receiving us we are very happy to be

3
00:00:09,950 --> 00:00:14,719
here so this is Joe standing next to me

4
00:00:12,320 --> 00:00:17,689
and I'm Miko we both work for Microsoft

5
00:00:14,720 --> 00:00:19,730
as a Security Response Center the nsrc

6
00:00:17,689 --> 00:00:24,380
and we are here today to talk about

7
00:00:19,730 --> 00:00:28,249
hyper-v its internals and some of the

8
00:00:24,380 --> 00:00:30,349
vulnerabilities we've seen so why are we

9
00:00:28,249 --> 00:00:33,140
doing that you might be wondering why us

10
00:00:30,349 --> 00:00:36,740
Microsoft are talking about bugs in one

11
00:00:33,140 --> 00:00:39,830
products it may not make sense for you

12
00:00:36,740 --> 00:00:44,180
well there are many reasons for that but

13
00:00:39,830 --> 00:00:46,339
me mostly we want to bug them and we

14
00:00:44,180 --> 00:00:48,710
know that it's hard it's not trivial to

15
00:00:46,340 --> 00:00:50,510
find bugs in hyper-v and that's foul

16
00:00:48,710 --> 00:00:53,000
that's white we thought it'd be great

17
00:00:50,510 --> 00:00:56,150
for us to give a presentation I'll talk

18
00:00:53,000 --> 00:00:58,940
about how hyper-v works and how we can

19
00:00:56,150 --> 00:01:03,530
fight bugs you can find those and report

20
00:00:58,940 --> 00:01:06,259
them to us and if you do that we we are

21
00:01:03,530 --> 00:01:09,890
will be delighted to pay you so look at

22
00:01:06,259 --> 00:01:13,490
these figures for example find a remote

23
00:01:09,890 --> 00:01:15,530
code execution bugs in the host kernel

24
00:01:13,490 --> 00:01:19,339
that can be trigger able from the guest

25
00:01:15,530 --> 00:01:21,369
and will tell you $200,000 that's a huge

26
00:01:19,340 --> 00:01:24,200
amount of money you don't even need to

27
00:01:21,369 --> 00:01:27,229
send us an exploit but if you do we'll

28
00:01:24,200 --> 00:01:28,729
pay another 50,000 more you know before

29
00:01:27,229 --> 00:01:31,670
joining Microsoft I used to be a bank

30
00:01:28,729 --> 00:01:33,469
bounty hunter and I do think right now

31
00:01:31,670 --> 00:01:37,990
that this is one of the best bug

32
00:01:33,469 --> 00:01:41,538
bounties on the market so think about it

33
00:01:37,990 --> 00:01:44,630
sorry so we know that finding bug is

34
00:01:41,539 --> 00:01:48,499
hard there are not that many resources

35
00:01:44,630 --> 00:01:51,649
available not many bugs documented and

36
00:01:48,499 --> 00:01:53,899
so this is what the talk is all about

37
00:01:51,649 --> 00:01:56,209
today so Joe in a minute he's going to

38
00:01:53,899 --> 00:01:59,209
talk about the internals of Highbury and

39
00:01:56,209 --> 00:02:01,579
I will come back afterwards to talk

40
00:01:59,209 --> 00:02:04,189
about some of the varieties that we've

41
00:02:01,579 --> 00:02:06,048
seen thanks Nico

42
00:02:04,189 --> 00:02:09,109
yeah so we're gonna start off just

43
00:02:06,049 --> 00:02:11,870
giving you guys overview of the hyper-v

44
00:02:09,110 --> 00:02:14,240
architecture really from the perspective

45
00:02:11,870 --> 00:02:15,230
of a security researcher that wants to

46
00:02:14,240 --> 00:02:16,819
go and

47
00:02:15,230 --> 00:02:19,640
find guests to host escape

48
00:02:16,819 --> 00:02:24,349
vulnerabilities that qualify for our bug

49
00:02:19,640 --> 00:02:26,750
bounty so when we look at hyper-v from a

50
00:02:24,349 --> 00:02:29,329
really high level you can see up at the

51
00:02:26,750 --> 00:02:31,540
top here we have the hypervisor and down

52
00:02:29,330 --> 00:02:34,849
below we have what we call partitions

53
00:02:31,540 --> 00:02:37,910
now in hyper-v the hypervisor is a

54
00:02:34,849 --> 00:02:40,548
standalone binary it doesn't run inside

55
00:02:37,910 --> 00:02:42,349
of the hosts operating systems kernel it

56
00:02:40,549 --> 00:02:44,090
runs completely by itself completely

57
00:02:42,349 --> 00:02:46,819
isolated from everything else on the

58
00:02:44,090 --> 00:02:48,709
system so it has its own unique physical

59
00:02:46,819 --> 00:02:51,078
address space and virtual address space

60
00:02:48,709 --> 00:02:53,870
from both the virtual machines and the

61
00:02:51,079 --> 00:02:57,410
host operating system now in hyper-v a

62
00:02:53,870 --> 00:02:59,840
partition is how we describe the logical

63
00:02:57,410 --> 00:03:02,450
unit of isolation that the hypervisor

64
00:02:59,840 --> 00:03:04,690
provides to the different operating

65
00:03:02,450 --> 00:03:08,179
systems that are running on the system

66
00:03:04,690 --> 00:03:11,299
the hypervisor provides this isolation

67
00:03:08,180 --> 00:03:15,049
in two primary ways first we use the

68
00:03:11,299 --> 00:03:19,099
extended page tables that the cpus

69
00:03:15,049 --> 00:03:21,079
provide to isolate the physical memory

70
00:03:19,099 --> 00:03:23,510
of all of the different virtual machines

71
00:03:21,079 --> 00:03:25,329
from each other so they can't interact

72
00:03:23,510 --> 00:03:27,679
with each other's physical memory and

73
00:03:25,329 --> 00:03:30,919
the other thing that the hypervisor does

74
00:03:27,680 --> 00:03:33,709
is it intercepts attempts to execute

75
00:03:30,919 --> 00:03:35,569
certain privileged instructions so for

76
00:03:33,709 --> 00:03:38,150
example if one of the guest virtual

77
00:03:35,569 --> 00:03:40,518
machine machines tries to execute an in

78
00:03:38,150 --> 00:03:43,040
or out instruction which would let you

79
00:03:40,519 --> 00:03:45,950
talk to a piece of hardware over i/o

80
00:03:43,040 --> 00:03:47,959
ports the hypervisor will intercept that

81
00:03:45,950 --> 00:03:50,929
attempt and it won't actually let you

82
00:03:47,959 --> 00:03:53,389
talk to the hardware the hypervisor is

83
00:03:50,930 --> 00:03:55,819
also responsible for a number of other

84
00:03:53,389 --> 00:03:58,400
things somewhat ISO Taric things so it

85
00:03:55,819 --> 00:04:01,220
it's responsible for doing all of the

86
00:03:58,400 --> 00:04:03,440
virtualization specific configuration

87
00:04:01,220 --> 00:04:06,190
and doing things like delivering

88
00:04:03,440 --> 00:04:08,329
interrupts to the hardware that's

89
00:04:06,190 --> 00:04:14,650
delivering interrupts to the guest

90
00:04:08,329 --> 00:04:16,789
operating systems so my abuse choice for

91
00:04:14,650 --> 00:04:18,739
targeting hyper-v would be for example

92
00:04:16,789 --> 00:04:20,510
to go after every hyper course do you

93
00:04:18,738 --> 00:04:22,638
think it would be a good idea so it's

94
00:04:20,510 --> 00:04:25,610
actually not that great of an attack

95
00:04:22,639 --> 00:04:28,790
surface the hypervisor itself really has

96
00:04:25,610 --> 00:04:31,520
a pretty minimal set of functionality

97
00:04:28,790 --> 00:04:36,140
and it's it's really not a great place

98
00:04:31,520 --> 00:04:38,690
to start looking for bugs so let's talk

99
00:04:36,140 --> 00:04:41,870
about the root partition a little bit so

100
00:04:38,690 --> 00:04:44,540
the root partition or the host operating

101
00:04:41,870 --> 00:04:47,660
system is a special partition on the

102
00:04:44,540 --> 00:04:51,130
system it's responsible for managing all

103
00:04:47,660 --> 00:04:54,020
of the actual virtual machines that run

104
00:04:51,130 --> 00:04:56,600
to do that it actually needs some

105
00:04:54,020 --> 00:04:59,120
special access so in the last slide I

106
00:04:56,600 --> 00:05:01,040
told you that the hypervisor prevents

107
00:04:59,120 --> 00:05:03,380
all of the partitions from accessing

108
00:05:01,040 --> 00:05:06,770
each other's physical memory that wasn't

109
00:05:03,380 --> 00:05:08,810
quite true the root partition has access

110
00:05:06,770 --> 00:05:11,180
to the physical memory of all of the

111
00:05:08,810 --> 00:05:12,890
other partitions it doesn't have access

112
00:05:11,180 --> 00:05:15,770
to the hypervisors physical memory

113
00:05:12,890 --> 00:05:17,810
though the root partition also has

114
00:05:15,770 --> 00:05:20,090
access to the CPU state of all the other

115
00:05:17,810 --> 00:05:21,980
partitions and the reason for this

116
00:05:20,090 --> 00:05:24,770
access is because the root partition

117
00:05:21,980 --> 00:05:26,480
needs to provide a number of services to

118
00:05:24,770 --> 00:05:28,400
all of these virtual machines running

119
00:05:26,480 --> 00:05:30,020
and we'll talk a little bit more about

120
00:05:28,400 --> 00:05:32,539
that later but it needs to provide

121
00:05:30,020 --> 00:05:35,330
functionality like networking and

122
00:05:32,540 --> 00:05:37,100
storage things along that nature so it

123
00:05:35,330 --> 00:05:41,240
ends up needing access to these other

124
00:05:37,100 --> 00:05:43,030
VMs physical memory so you think it's

125
00:05:41,240 --> 00:05:45,920
better to focus on the components yeah

126
00:05:43,030 --> 00:05:48,140
yeah I think I think that if you want to

127
00:05:45,920 --> 00:05:50,840
try to find interesting bugs and hyper-v

128
00:05:48,140 --> 00:05:53,060
the root partition and all the services

129
00:05:50,840 --> 00:05:56,080
that run in the root partition really is

130
00:05:53,060 --> 00:06:00,080
the best place to start looking for bugs

131
00:05:56,080 --> 00:06:02,659
and last we have the guest partitions

132
00:06:00,080 --> 00:06:04,909
these are the actual virtual machines

133
00:06:02,660 --> 00:06:06,890
that are running in hyper-v now these

134
00:06:04,910 --> 00:06:09,740
partitions really don't have access to

135
00:06:06,890 --> 00:06:11,150
each other's physical memory they don't

136
00:06:09,740 --> 00:06:12,740
have access to the hypervisor physical

137
00:06:11,150 --> 00:06:15,650
memory the routes physical memory or any

138
00:06:12,740 --> 00:06:17,720
other partitions physical memory they

139
00:06:15,650 --> 00:06:19,940
don't have any way that they can

140
00:06:17,720 --> 00:06:22,040
directly communicate with any of the

141
00:06:19,940 --> 00:06:25,430
other partitions either except for the

142
00:06:22,040 --> 00:06:28,940
route partition so in hyper-v there

143
00:06:25,430 --> 00:06:31,790
really is no direct attack surface from

144
00:06:28,940 --> 00:06:34,490
a guest to another guest all of the

145
00:06:31,790 --> 00:06:37,220
attack surface is from the guest to the

146
00:06:34,490 --> 00:06:41,200
hypervisor or from the guest to the

147
00:06:37,220 --> 00:06:41,200
route to the root partition

148
00:06:42,569 --> 00:06:46,960
now when we're dealing with

149
00:06:44,860 --> 00:06:50,289
virtualization we end up talking about

150
00:06:46,960 --> 00:06:52,840
physical memory quite a bit in hyper-v

151
00:06:50,289 --> 00:06:56,080
we use the term system physical address

152
00:06:52,840 --> 00:06:58,688
or s.p.a to describe the real physical

153
00:06:56,080 --> 00:07:01,029
address of some piece of memory and we

154
00:06:58,689 --> 00:07:03,939
use the term GPA or guessed physical

155
00:07:01,029 --> 00:07:07,389
address to describe the physical address

156
00:07:03,939 --> 00:07:09,370
that a guest sees and this is the lie

157
00:07:07,389 --> 00:07:11,439
that the hypervisor tilts to the guest

158
00:07:09,370 --> 00:07:13,360
using the extended page tables so the

159
00:07:11,439 --> 00:07:16,620
hypervisor can map a guest physical

160
00:07:13,360 --> 00:07:19,120
address on to a system physical address

161
00:07:16,620 --> 00:07:22,419
we also have something in hyper-v that

162
00:07:19,120 --> 00:07:25,120
we call G paddles or guest physical

163
00:07:22,419 --> 00:07:26,979
address descriptor lists if you're

164
00:07:25,120 --> 00:07:30,520
familiar with windows kernel development

165
00:07:26,979 --> 00:07:33,669
at all these are extremely similar to an

166
00:07:30,520 --> 00:07:36,128
MDL conceptually it is just a structure

167
00:07:33,669 --> 00:07:38,799
that contains a list of guest physical

168
00:07:36,129 --> 00:07:43,569
addresses and it's used to describe some

169
00:07:38,800 --> 00:07:45,370
guest physical memory the other thing

170
00:07:43,569 --> 00:07:47,469
I'd like to briefly talk about are some

171
00:07:45,370 --> 00:07:50,289
of the types of components so if you're

172
00:07:47,469 --> 00:07:51,969
going and reversing hyper-v you'll see

173
00:07:50,289 --> 00:07:53,560
references to some of this stuff and I

174
00:07:51,969 --> 00:07:56,439
just want you guys to know what it means

175
00:07:53,560 --> 00:07:59,860
so in hyper-v we have what's called a

176
00:07:56,439 --> 00:08:04,110
Vida or virtual device and this is a

177
00:07:59,860 --> 00:08:05,439
device that is either emulated or

178
00:08:04,110 --> 00:08:09,370
paravirtualized

179
00:08:05,439 --> 00:08:12,550
and it is hosted in user mode of the

180
00:08:09,370 --> 00:08:15,539
route partition and that contrasts with

181
00:08:12,550 --> 00:08:18,819
a VSP or virtualization service provider

182
00:08:15,539 --> 00:08:21,520
which is a para virtualized device that

183
00:08:18,819 --> 00:08:25,120
is hosted inside of kernel mode of the

184
00:08:21,520 --> 00:08:28,029
root partition and last we have what we

185
00:08:25,120 --> 00:08:30,159
call an integration component or IC and

186
00:08:28,029 --> 00:08:33,099
from an attackers point of view an

187
00:08:30,159 --> 00:08:36,099
integration component is effectively

188
00:08:33,099 --> 00:08:39,310
identical to a virtual device it is just

189
00:08:36,099 --> 00:08:42,099
some component that lives inside of user

190
00:08:39,309 --> 00:08:44,709
mode on the root partition that guest

191
00:08:42,099 --> 00:08:47,620
operating systems can communicate with I

192
00:08:44,709 --> 00:08:49,089
wishing menu those you the eye sees

193
00:08:47,620 --> 00:08:50,529
really haven't had many bugs I think

194
00:08:49,089 --> 00:08:52,790
there's been like one bug that's been

195
00:08:50,529 --> 00:08:54,620
found in the past 10 or 15 years

196
00:08:52,790 --> 00:08:56,209
tiny area yeah so they're they're not

197
00:08:54,620 --> 00:09:01,820
super awesome targets but they're worth

198
00:08:56,210 --> 00:09:05,000
calling out so if you're interested in

199
00:09:01,820 --> 00:09:06,110
trying to find bugs and hyper-v probably

200
00:09:05,000 --> 00:09:08,600
one of the things that you're going to

201
00:09:06,110 --> 00:09:11,120
be wondering is what are the components

202
00:09:08,600 --> 00:09:13,880
that I could possibly attack right what

203
00:09:11,120 --> 00:09:15,800
is accessible to the guest I mentioned

204
00:09:13,880 --> 00:09:17,780
earlier that the root partition is

205
00:09:15,800 --> 00:09:19,819
responsible for providing a number of

206
00:09:17,780 --> 00:09:22,819
services to all of the guest operating

207
00:09:19,820 --> 00:09:25,430
systems that run and this is just kind

208
00:09:22,820 --> 00:09:26,570
of an overview of what kinds of services

209
00:09:25,430 --> 00:09:29,300
need to be offered

210
00:09:26,570 --> 00:09:31,280
so for virtual machines that aren't

211
00:09:29,300 --> 00:09:32,750
really aware that their virtual machines

212
00:09:31,280 --> 00:09:34,699
they think that they're running on real

213
00:09:32,750 --> 00:09:37,340
hardware we have a whole bunch of

214
00:09:34,700 --> 00:09:39,800
devices that we emulate so we have a

215
00:09:37,340 --> 00:09:43,760
network card that we can emulate we have

216
00:09:39,800 --> 00:09:45,829
an IDE device hard drive optical drive

217
00:09:43,760 --> 00:09:49,220
that we can emulate floppy drive video

218
00:09:45,830 --> 00:09:51,440
card etc so just basically any piece of

219
00:09:49,220 --> 00:09:53,480
hardware that an operating system

220
00:09:51,440 --> 00:09:56,060
expects it should be able to communicate

221
00:09:53,480 --> 00:10:00,200
with when it's running on bare metal we

222
00:09:56,060 --> 00:10:02,599
emulate that however emulation is super

223
00:10:00,200 --> 00:10:06,290
slow and so for certain things like

224
00:10:02,600 --> 00:10:08,840
networking and storage we have para

225
00:10:06,290 --> 00:10:11,689
virtualized devices which are much

226
00:10:08,840 --> 00:10:15,110
higher speed devices but they require

227
00:10:11,690 --> 00:10:16,520
guest participation so the guest needs

228
00:10:15,110 --> 00:10:18,950
to know that it's a hyper-v virtual

229
00:10:16,520 --> 00:10:22,430
machine and it needs to know how to talk

230
00:10:18,950 --> 00:10:24,770
to the root partition over a you know

231
00:10:22,430 --> 00:10:27,410
much more performant communication

232
00:10:24,770 --> 00:10:30,410
channel and then we have sort of a

233
00:10:27,410 --> 00:10:33,050
grab-bag of various you know services

234
00:10:30,410 --> 00:10:34,550
and pieces of functionality that hyper-v

235
00:10:33,050 --> 00:10:38,120
needs to offer to the guest virtual

236
00:10:34,550 --> 00:10:39,949
machines things like live migration so

237
00:10:38,120 --> 00:10:43,070
you need to be able to migrate a virtual

238
00:10:39,950 --> 00:10:45,350
machine from one host to another or the

239
00:10:43,070 --> 00:10:47,380
BIOS firmware that the virtual machine

240
00:10:45,350 --> 00:10:49,940
boots off of when you turn it on the

241
00:10:47,380 --> 00:10:53,120
root partition needs to provide that

242
00:10:49,940 --> 00:10:55,130
firmware to the guests to boot off of we

243
00:10:53,120 --> 00:10:57,170
have things like integration components

244
00:10:55,130 --> 00:10:59,600
so some examples of things that

245
00:10:57,170 --> 00:11:02,839
integration components do are time

246
00:10:59,600 --> 00:11:06,440
synchronization the host or route can

247
00:11:02,840 --> 00:11:07,850
tell the guests what it's time is

248
00:11:06,440 --> 00:11:09,430
so that the guests don't need to

249
00:11:07,850 --> 00:11:13,009
synchronize their time with the internet

250
00:11:09,430 --> 00:11:15,739
or we can have a heartbeat service so

251
00:11:13,009 --> 00:11:17,959
the host will receive a heartbeat from

252
00:11:15,740 --> 00:11:19,850
the guests and if it stops receiving

253
00:11:17,959 --> 00:11:22,160
that heartbeat the host will know that

254
00:11:19,850 --> 00:11:22,879
something went wrong with a guest so

255
00:11:22,160 --> 00:11:25,610
that's the kind of things that

256
00:11:22,879 --> 00:11:28,009
integration services do and then we have

257
00:11:25,610 --> 00:11:30,350
functionality like we have an SMB server

258
00:11:28,009 --> 00:11:33,769
that runs in user mode that provides

259
00:11:30,350 --> 00:11:37,399
file sharing to some of the hyper-v

260
00:11:33,769 --> 00:11:41,449
virtual machines specifically if they're

261
00:11:37,399 --> 00:11:42,829
hyper-v container virtual machines that

262
00:11:41,449 --> 00:11:45,170
brings me to my next point which is that

263
00:11:42,829 --> 00:11:46,489
while we have a lot of different

264
00:11:45,170 --> 00:11:48,819
services and pieces of functionality

265
00:11:46,490 --> 00:11:52,370
that can be exposed to the guests

266
00:11:48,819 --> 00:11:54,050
they're not always available some of

267
00:11:52,370 --> 00:11:56,779
this stuff depends on how the virtual

268
00:11:54,050 --> 00:11:59,329
machine is configured so for example if

269
00:11:56,779 --> 00:12:01,670
you're running a generation one virtual

270
00:11:59,329 --> 00:12:04,699
machine you'll have all of these

271
00:12:01,670 --> 00:12:07,040
emulated devices exposed but if you run

272
00:12:04,699 --> 00:12:08,569
a generation two virtual machine you

273
00:12:07,040 --> 00:12:10,699
will have almost none of those devices

274
00:12:08,569 --> 00:12:13,069
exposed because we expect that

275
00:12:10,699 --> 00:12:15,519
generation two virtual machines can talk

276
00:12:13,069 --> 00:12:18,410
to all of the paravirtualized components

277
00:12:15,519 --> 00:12:20,779
certain options here are only available

278
00:12:18,410 --> 00:12:22,250
to hyper-v containers certain options

279
00:12:20,779 --> 00:12:25,040
are only available if you're using

280
00:12:22,250 --> 00:12:26,120
specific features etc so when you're

281
00:12:25,040 --> 00:12:28,519
doing your research it's always

282
00:12:26,120 --> 00:12:30,380
important to try to figure out for the

283
00:12:28,519 --> 00:12:32,420
scenario that you want to target what

284
00:12:30,380 --> 00:12:38,120
devices what components are actually

285
00:12:32,420 --> 00:12:40,130
available for you to attack now hyper-v

286
00:12:38,120 --> 00:12:42,829
really is designed with the principle of

287
00:12:40,130 --> 00:12:46,399
least privilege in mind whenever

288
00:12:42,829 --> 00:12:50,719
possible we try to put new code inside

289
00:12:46,399 --> 00:12:52,939
of user mode processes on the host we

290
00:12:50,720 --> 00:12:55,189
don't like adding new code to the kernel

291
00:12:52,939 --> 00:12:57,139
or to the hypervisor it's not always

292
00:12:55,189 --> 00:13:01,040
possible but that's always our intent

293
00:12:57,139 --> 00:13:02,990
and so if we look at where all of these

294
00:13:01,040 --> 00:13:04,009
different components live which I

295
00:13:02,990 --> 00:13:07,579
personally think is really interesting

296
00:13:04,009 --> 00:13:08,990
you can see at the top here we have a

297
00:13:07,579 --> 00:13:11,359
number of things that do live in the

298
00:13:08,990 --> 00:13:13,040
kernel so networking and storage for

299
00:13:11,360 --> 00:13:14,930
example the paravirtualized networking

300
00:13:13,040 --> 00:13:16,930
and storage components those are in the

301
00:13:14,930 --> 00:13:20,209
kernel because they need to go real fast

302
00:13:16,930 --> 00:13:23,239
so they just have to be in the kernel

303
00:13:20,209 --> 00:13:26,118
then we have V PCI which is our

304
00:13:23,240 --> 00:13:28,339
paravirtualized PCI bus and this

305
00:13:26,119 --> 00:13:30,619
component is in the kernel because it is

306
00:13:28,339 --> 00:13:32,839
responsible for enabling scenarios like

307
00:13:30,619 --> 00:13:35,420
direct device assignment and single

308
00:13:32,839 --> 00:13:38,029
route IO virtualization these are

309
00:13:35,420 --> 00:13:40,519
technologies that allow you to directly

310
00:13:38,029 --> 00:13:43,429
attach Hardware into a virtual machine

311
00:13:40,519 --> 00:13:46,100
so for example you can go and attach a

312
00:13:43,429 --> 00:13:47,869
network card or a graphics card directly

313
00:13:46,100 --> 00:13:49,069
to a virtual machine and then the

314
00:13:47,869 --> 00:13:50,809
virtual machine doesn't need to go

315
00:13:49,069 --> 00:13:53,569
through any software layers to use that

316
00:13:50,809 --> 00:13:55,999
device so V PCI is in the kernel so that

317
00:13:53,569 --> 00:13:57,769
it can facilitate all of that we have

318
00:13:55,999 --> 00:13:59,089
the VM bus which lives in the kernel and

319
00:13:57,769 --> 00:14:02,769
we'll talk a little bit more about that

320
00:13:59,089 --> 00:14:06,170
in a minute but that's our high-speed

321
00:14:02,769 --> 00:14:08,569
communication channel we have what we

322
00:14:06,170 --> 00:14:11,779
call the kernel hypervisor interface or

323
00:14:08,569 --> 00:14:14,740
Winn h vr and this is really the kernel

324
00:14:11,779 --> 00:14:18,110
32 of the hypervisor world it just

325
00:14:14,740 --> 00:14:19,730
contains functions that call hyper calls

326
00:14:18,110 --> 00:14:21,949
for you so they're functions that are

327
00:14:19,730 --> 00:14:24,379
wrappers around hyper calls similar to

328
00:14:21,949 --> 00:14:26,839
how kernel32 the DLL and Windows

329
00:14:24,379 --> 00:14:30,589
contains functions that are wrappers

330
00:14:26,839 --> 00:14:32,839
around system calls and last but not

331
00:14:30,589 --> 00:14:34,970
least we have the vid or virtualization

332
00:14:32,839 --> 00:14:36,740
infrastructure driver and you'll

333
00:14:34,970 --> 00:14:38,689
probably see the vid used in quite a

334
00:14:36,740 --> 00:14:40,069
number of places although usually it

335
00:14:38,689 --> 00:14:43,660
doesn't really have direct attack

336
00:14:40,069 --> 00:14:45,979
surface the vid is really the glue that

337
00:14:43,660 --> 00:14:49,569
brings a lot of different hyper-v

338
00:14:45,980 --> 00:14:53,119
components together so as an example if

339
00:14:49,569 --> 00:14:55,579
you want to create a new virtual machine

340
00:14:53,119 --> 00:14:58,100
it is ultimately the vid that will call

341
00:14:55,579 --> 00:14:59,899
into the hypervisor to do that if you

342
00:14:58,100 --> 00:15:02,389
need to add more physical memory to a

343
00:14:59,899 --> 00:15:04,309
virtual machine ultimately the vid will

344
00:15:02,389 --> 00:15:07,369
call into the hypervisor to deposit that

345
00:15:04,309 --> 00:15:09,379
physical memory and the vids responsible

346
00:15:07,369 --> 00:15:12,189
for a lot of other things it's it's used

347
00:15:09,379 --> 00:15:12,189
quite frequently

348
00:15:15,100 --> 00:15:20,620
so the next thing that I think is you

349
00:15:19,240 --> 00:15:22,750
know really interesting to look at are

350
00:15:20,620 --> 00:15:25,300
the different communication channels

351
00:15:22,750 --> 00:15:27,280
that hyper-v has because ultimately you

352
00:15:25,300 --> 00:15:30,040
want to be able to talk to these

353
00:15:27,280 --> 00:15:32,740
components right so how do you talk to

354
00:15:30,040 --> 00:15:34,930
the hypervisor the main way that a guest

355
00:15:32,740 --> 00:15:37,060
can talk to the hypervisor is by making

356
00:15:34,930 --> 00:15:39,160
hyper calls which are really just like

357
00:15:37,060 --> 00:15:42,339
system calls they have a well-defined

358
00:15:39,160 --> 00:15:44,469
interface and we actually document all

359
00:15:42,340 --> 00:15:47,800
of the hyper calls that a guest can make

360
00:15:44,470 --> 00:15:50,350
as part of the hyper-v TL FS which is

361
00:15:47,800 --> 00:15:52,000
available online and we have a link to

362
00:15:50,350 --> 00:15:56,170
that at the end of this presentation in

363
00:15:52,000 --> 00:15:57,640
the appendix the next there's there's a

364
00:15:56,170 --> 00:15:59,860
number of other ways that you can kind

365
00:15:57,640 --> 00:16:04,569
of indirectly communicate with the

366
00:15:59,860 --> 00:16:06,790
hypervisor they're not the best of

367
00:16:04,570 --> 00:16:09,670
attack surface in my opinion it's things

368
00:16:06,790 --> 00:16:11,469
like faults if you have a triple fault

369
00:16:09,670 --> 00:16:14,050
in your virtual machine and it's about

370
00:16:11,470 --> 00:16:17,380
to crash the hypervisor will intercept

371
00:16:14,050 --> 00:16:19,359
that triple fault and can do things if

372
00:16:17,380 --> 00:16:22,060
you have an extended page table fault

373
00:16:19,360 --> 00:16:25,810
the hypervisor will receive a trap and

374
00:16:22,060 --> 00:16:27,939
will decide what to do about that if you

375
00:16:25,810 --> 00:16:29,709
execute an instruction that needs to be

376
00:16:27,940 --> 00:16:32,110
emulated such as an in or out

377
00:16:29,710 --> 00:16:34,330
instruction the hypervisor will receive

378
00:16:32,110 --> 00:16:36,130
a trap and it will have to decide if it

379
00:16:34,330 --> 00:16:38,410
wants to emulate that or if it wants to

380
00:16:36,130 --> 00:16:40,360
forward it to the host to emulate what

381
00:16:38,410 --> 00:16:43,030
it wants to do

382
00:16:40,360 --> 00:16:45,520
same thing for register access certain

383
00:16:43,030 --> 00:16:49,120
like MSRs can be intercepted by the

384
00:16:45,520 --> 00:16:51,160
hypervisor and emulated but there really

385
00:16:49,120 --> 00:16:54,370
is not a whole lot of super complicated

386
00:16:51,160 --> 00:16:56,140
functionality in there and so I I

387
00:16:54,370 --> 00:17:02,290
personally don't think that it's the

388
00:16:56,140 --> 00:17:04,000
best place to start looking for bugs so

389
00:17:02,290 --> 00:17:06,579
how do you communicate with kernel-mode

390
00:17:04,000 --> 00:17:08,319
components the primary way you

391
00:17:06,579 --> 00:17:11,800
communicate with hyper-v kernel-mode

392
00:17:08,319 --> 00:17:13,629
components is over the vm bus and we're

393
00:17:11,800 --> 00:17:17,319
gonna talk more about how vm bus works

394
00:17:13,630 --> 00:17:20,100
in just a minute so i'm just gonna leave

395
00:17:17,319 --> 00:17:22,629
it at that for now the next way is

396
00:17:20,099 --> 00:17:26,230
through what we call extended hyper

397
00:17:22,630 --> 00:17:29,140
calls an extended hyper call is just a

398
00:17:26,230 --> 00:17:31,750
hyper call that the hypervisor doesn't

399
00:17:29,140 --> 00:17:34,470
want to handle itself and it just

400
00:17:31,750 --> 00:17:37,420
forwards directly to the vid to handle

401
00:17:34,470 --> 00:17:39,730
there's very few of them and they're not

402
00:17:37,420 --> 00:17:42,670
very complicated but I just wanted to

403
00:17:39,730 --> 00:17:45,070
call it out for completeness we also

404
00:17:42,670 --> 00:17:46,330
have what we call apertures and I'm

405
00:17:45,070 --> 00:17:47,800
going to talk more about that on the

406
00:17:46,330 --> 00:17:50,620
next slide because they're really used

407
00:17:47,800 --> 00:17:52,240
more by user mode components and then

408
00:17:50,620 --> 00:17:55,959
once again we have intercept handling

409
00:17:52,240 --> 00:17:58,690
here and when I say intercept by the way

410
00:17:55,960 --> 00:18:00,040
that is really just a trap in hyper-v we

411
00:17:58,690 --> 00:18:03,670
just call that an intercept

412
00:18:00,040 --> 00:18:05,830
so whenever the hypervisor ends up

413
00:18:03,670 --> 00:18:07,090
receiving a trap or some some other

414
00:18:05,830 --> 00:18:10,720
thing from the guest

415
00:18:07,090 --> 00:18:12,580
that's an intercept and kernel-mode

416
00:18:10,720 --> 00:18:15,910
components specifically the vid in

417
00:18:12,580 --> 00:18:18,790
hyper-v can end up being triggered due

418
00:18:15,910 --> 00:18:21,250
to this intercept handling for example

419
00:18:18,790 --> 00:18:23,470
if you have a io port reader right that

420
00:18:21,250 --> 00:18:24,730
needs to be emulated it first gets

421
00:18:23,470 --> 00:18:26,920
trapped by the hypervisor

422
00:18:24,730 --> 00:18:30,340
but then the hypervisor will forward

423
00:18:26,920 --> 00:18:33,150
that down to the vid in kernel mode on

424
00:18:30,340 --> 00:18:34,720
the host so there's a number of you know

425
00:18:33,150 --> 00:18:36,550
miscellaneous pieces of functionality

426
00:18:34,720 --> 00:18:38,620
like that where technically you can

427
00:18:36,550 --> 00:18:41,020
exercise code in the kernel by having

428
00:18:38,620 --> 00:18:45,159
intercepts but it's probably not the

429
00:18:41,020 --> 00:18:46,510
best place to look for bugs and finally

430
00:18:45,160 --> 00:18:49,000
let's talk about how you communicate

431
00:18:46,510 --> 00:18:50,890
with the user mode components and user

432
00:18:49,000 --> 00:18:52,510
mode has the most communication channels

433
00:18:50,890 --> 00:18:55,000
available to it because it's where all

434
00:18:52,510 --> 00:18:57,250
the emulation happens so we have i/o

435
00:18:55,000 --> 00:18:58,780
port emulation so if you do an i/o port

436
00:18:57,250 --> 00:19:00,910
reader right you can end up triggering

437
00:18:58,780 --> 00:19:02,760
code in a virtual device that's going to

438
00:19:00,910 --> 00:19:06,850
emulate that

439
00:19:02,760 --> 00:19:09,730
same thing for mm IO so various virtual

440
00:19:06,850 --> 00:19:12,209
devices will register mm IO ranges that

441
00:19:09,730 --> 00:19:14,560
they want to receive intercepts for and

442
00:19:12,210 --> 00:19:16,930
if you read or write to that physical

443
00:19:14,560 --> 00:19:18,610
address then you will end up triggering

444
00:19:16,930 --> 00:19:21,940
some code path in one of these virtual

445
00:19:18,610 --> 00:19:23,229
devices we have the VM bus once again

446
00:19:21,940 --> 00:19:26,460
and I promise we're gonna talk about it

447
00:19:23,230 --> 00:19:29,890
on the next slide we have apertures

448
00:19:26,460 --> 00:19:34,330
apertures are effectively just shared

449
00:19:29,890 --> 00:19:38,260
sections okay they allow a component to

450
00:19:34,330 --> 00:19:40,990
map guest physical addresses into that

451
00:19:38,260 --> 00:19:42,590
components virtual address space so for

452
00:19:40,990 --> 00:19:44,419
all of these Virge

453
00:19:42,590 --> 00:19:46,250
devices for example that live in the VM

454
00:19:44,419 --> 00:19:48,919
worker process they can choose to map

455
00:19:46,250 --> 00:19:52,309
some guest physical memory directly into

456
00:19:48,919 --> 00:19:53,570
the VM WP virtual address space now if

457
00:19:52,309 --> 00:19:55,850
they do that they need to be careful

458
00:19:53,570 --> 00:19:58,580
because that memory is still mapped in

459
00:19:55,850 --> 00:20:00,949
the guest and some of you might be

460
00:19:58,580 --> 00:20:03,918
familiar with double fetch attacks but

461
00:20:00,950 --> 00:20:07,250
one common programming problem that you

462
00:20:03,919 --> 00:20:09,110
can have with shared memory is you read

463
00:20:07,250 --> 00:20:11,330
some data from that shared memory and

464
00:20:09,110 --> 00:20:13,668
then you read it a second time and you

465
00:20:11,330 --> 00:20:15,260
expect that it hasn't changed but it

466
00:20:13,669 --> 00:20:17,929
could have changed because that memory

467
00:20:15,260 --> 00:20:19,309
is mapped inside of the guest so you

468
00:20:17,929 --> 00:20:21,950
need to be very careful when you're

469
00:20:19,309 --> 00:20:23,059
dealing with shared memory the last one

470
00:20:21,950 --> 00:20:26,380
we have here are read and write

471
00:20:23,059 --> 00:20:29,678
notifications so a component can tell

472
00:20:26,380 --> 00:20:33,529
hypervisor that it wants to be alerted

473
00:20:29,679 --> 00:20:36,140
anytime a specific physical page is read

474
00:20:33,529 --> 00:20:38,330
or written to now you might be thinking

475
00:20:36,140 --> 00:20:39,679
this sounds kind of like MMI oh right

476
00:20:38,330 --> 00:20:41,918
isn't that what you just described with

477
00:20:39,679 --> 00:20:44,600
MMI oh there's one key difference here

478
00:20:41,919 --> 00:20:47,600
read and write notifications do not

479
00:20:44,600 --> 00:20:49,730
advance the instruction pointer and what

480
00:20:47,600 --> 00:20:52,309
that means is that they cannot emulate

481
00:20:49,730 --> 00:20:54,409
the instruction that caused that read or

482
00:20:52,309 --> 00:20:56,090
write notification to be triggered so

483
00:20:54,409 --> 00:20:57,980
you literally just get notified that a

484
00:20:56,090 --> 00:21:00,949
read or write happened and you then need

485
00:20:57,980 --> 00:21:04,370
to disable the read write notification

486
00:21:00,950 --> 00:21:06,980
and continue execution and then that

487
00:21:04,370 --> 00:21:09,770
instruction will actually be allowed to

488
00:21:06,980 --> 00:21:12,559
execute and the program will go on its

489
00:21:09,770 --> 00:21:14,320
merry way why is this useful this is

490
00:21:12,559 --> 00:21:16,970
useful for scenarios like live migration

491
00:21:14,320 --> 00:21:19,189
when you live migrate a VM you might

492
00:21:16,970 --> 00:21:20,870
copy a page of data from your current

493
00:21:19,190 --> 00:21:23,539
machine over the network to another

494
00:21:20,870 --> 00:21:25,610
machine and you will then go and you

495
00:21:23,539 --> 00:21:28,039
will put a write notification on that

496
00:21:25,610 --> 00:21:30,620
page of memory because the VM is still

497
00:21:28,039 --> 00:21:32,330
running on the host alright so you'll

498
00:21:30,620 --> 00:21:35,059
say I just copied this page of memory

499
00:21:32,330 --> 00:21:36,980
over notify me if it changes because if

500
00:21:35,059 --> 00:21:38,750
it changes that means I need to recopy

501
00:21:36,980 --> 00:21:43,309
it over the wire before I can fully

502
00:21:38,750 --> 00:21:48,409
migrate the VM so that's that's why read

503
00:21:43,309 --> 00:21:50,210
and write notifications exist okay so

504
00:21:48,409 --> 00:21:54,320
let's talk about the vm bus just a

505
00:21:50,210 --> 00:21:56,030
little bit vm bus is a super high-speed

506
00:21:54,320 --> 00:21:56,580
communication channel between the guests

507
00:21:56,030 --> 00:22:00,780
and

508
00:21:56,580 --> 00:22:03,240
and it works using shared memory now the

509
00:22:00,780 --> 00:22:05,970
host never actually interacts with the

510
00:22:03,240 --> 00:22:09,260
VM bus directly it always interacts with

511
00:22:05,970 --> 00:22:11,550
the VM bus through abstraction layers

512
00:22:09,260 --> 00:22:13,950
from a high level the way that this

513
00:22:11,550 --> 00:22:16,620
system works is the host will make what

514
00:22:13,950 --> 00:22:19,860
we call a channel offer to the guest a

515
00:22:16,620 --> 00:22:22,169
VM bus channel offer and a little

516
00:22:19,860 --> 00:22:25,229
handshake will happen and part of that

517
00:22:22,170 --> 00:22:27,840
handshake involves the guest setting

518
00:22:25,230 --> 00:22:30,179
aside some of its physical memory to be

519
00:22:27,840 --> 00:22:32,129
used as shared memory for this channel

520
00:22:30,179 --> 00:22:33,540
so the guest will carve out some of its

521
00:22:32,130 --> 00:22:36,000
physical memory and it will tell the

522
00:22:33,540 --> 00:22:37,620
host these guest physical addresses are

523
00:22:36,000 --> 00:22:40,290
what we're going to use for the ring

524
00:22:37,620 --> 00:22:42,209
buffer the host will then map that

525
00:22:40,290 --> 00:22:45,389
memory into its virtual address space

526
00:22:42,210 --> 00:22:48,360
and either side can then write data into

527
00:22:45,390 --> 00:22:50,070
that channel and send an interrupt to

528
00:22:48,360 --> 00:22:56,459
the other side letting it know that

529
00:22:50,070 --> 00:22:58,470
there's data waiting for it oh one thing

530
00:22:56,460 --> 00:23:02,580
one thing I'd like to note here is that

531
00:22:58,470 --> 00:23:06,330
if you're interested in how either the

532
00:23:02,580 --> 00:23:12,629
VM bus protocol works or any of the

533
00:23:06,330 --> 00:23:14,040
client side the client side code for or

534
00:23:12,630 --> 00:23:16,800
I guess I shouldn't say client side what

535
00:23:14,040 --> 00:23:19,500
I mean is the guest side of these

536
00:23:16,800 --> 00:23:21,450
virtual devices work you can easily

537
00:23:19,500 --> 00:23:24,420
figure that out because all of the

538
00:23:21,450 --> 00:23:27,030
source code for VM bus and the guest

539
00:23:24,420 --> 00:23:30,120
side of these virtual devices and VSPs

540
00:23:27,030 --> 00:23:32,550
is checked into the Linux source tree so

541
00:23:30,120 --> 00:23:34,320
we have links in the appendix here you

542
00:23:32,550 --> 00:23:40,350
can go and check that out there's

543
00:23:34,320 --> 00:23:42,240
there's no mystery there so I mentioned

544
00:23:40,350 --> 00:23:43,830
that VM bus is never interacted with

545
00:23:42,240 --> 00:23:46,110
directly it's always interacted with

546
00:23:43,830 --> 00:23:47,610
through abstraction layers on the kernel

547
00:23:46,110 --> 00:23:50,459
mode side of things the way that we

548
00:23:47,610 --> 00:23:53,040
interact with it is through kmco or the

549
00:23:50,460 --> 00:23:55,220
kernel mode client library this

550
00:23:53,040 --> 00:23:57,928
interface is really built around

551
00:23:55,220 --> 00:24:00,510
callbacks so when you make a channel

552
00:23:57,929 --> 00:24:03,630
offer you also register with km CL a

553
00:24:00,510 --> 00:24:05,129
number of callbacks for things like call

554
00:24:03,630 --> 00:24:08,730
this function whenever I receive a

555
00:24:05,130 --> 00:24:10,890
message from the other end and

556
00:24:08,730 --> 00:24:12,540
you might be thinking while vm bus

557
00:24:10,890 --> 00:24:15,360
sounds dangerous because it uses shared

558
00:24:12,540 --> 00:24:17,610
memory and so all the devices that use

559
00:24:15,360 --> 00:24:21,059
VM bus are at risk of double fetch

560
00:24:17,610 --> 00:24:23,879
attacks however the messages that get

561
00:24:21,059 --> 00:24:25,980
sent over the vm bus actually get copied

562
00:24:23,880 --> 00:24:29,100
into pool windows kernel pool memory

563
00:24:25,980 --> 00:24:31,919
before they are delivered to the device

564
00:24:29,100 --> 00:24:34,678
that is using the vm bus so they are

565
00:24:31,919 --> 00:24:36,480
copied out of shared memory into memory

566
00:24:34,679 --> 00:24:38,820
that's only available to the host so

567
00:24:36,480 --> 00:24:42,450
there's no risk of double fetch attacks

568
00:24:38,820 --> 00:24:45,299
there except for this mechanism we have

569
00:24:42,450 --> 00:24:48,270
called external data so I had mentioned

570
00:24:45,299 --> 00:24:50,129
earlier that we have GPA T elds in

571
00:24:48,270 --> 00:24:52,650
hyper-v or guest physical address

572
00:24:50,130 --> 00:24:54,570
descriptor lists and one of the things

573
00:24:52,650 --> 00:24:57,090
that you can do when you're sending VM

574
00:24:54,570 --> 00:25:00,000
bus messages over the wire is you can

575
00:24:57,090 --> 00:25:03,120
actually attach a GPA DL to that VM bus

576
00:25:00,000 --> 00:25:07,799
message and it's called external data in

577
00:25:03,120 --> 00:25:09,750
the structure definition now in order

578
00:25:07,799 --> 00:25:12,840
for the host to use this external data

579
00:25:09,750 --> 00:25:14,970
it needs to explicitly map that data so

580
00:25:12,840 --> 00:25:18,689
nothing will just magically happen under

581
00:25:14,970 --> 00:25:20,460
the covers but the host can choose to

582
00:25:18,690 --> 00:25:22,020
map that data and if it does it does

583
00:25:20,460 --> 00:25:23,760
need to be very careful because that

584
00:25:22,020 --> 00:25:31,168
data is mapped in both the guest and the

585
00:25:23,760 --> 00:25:33,210
host now at the end of the slide deck in

586
00:25:31,169 --> 00:25:35,429
the appendix we have lots of function

587
00:25:33,210 --> 00:25:36,780
signatures that we documented to make it

588
00:25:35,429 --> 00:25:39,390
easier if you want to reverse engineer

589
00:25:36,780 --> 00:25:41,309
hyper-v but this is just a you know

590
00:25:39,390 --> 00:25:43,440
super brief example this middle function

591
00:25:41,309 --> 00:25:45,149
here that's what the callback looks like

592
00:25:43,440 --> 00:25:48,179
for the VM bus and so the third

593
00:25:45,150 --> 00:25:49,710
parameter is the buffer parameter so

594
00:25:48,179 --> 00:25:51,600
that's just a pointer to the message

595
00:25:49,710 --> 00:25:58,950
that you're receiving and it's in it's

596
00:25:51,600 --> 00:26:00,629
in safe memory it's in pool memory so km

597
00:25:58,950 --> 00:26:02,160
CL is how the kernel mode components use

598
00:26:00,630 --> 00:26:05,160
VM bus but what about user mode

599
00:26:02,160 --> 00:26:07,320
components the most common way for user

600
00:26:05,160 --> 00:26:11,820
mode components to use the VM bus is

601
00:26:07,320 --> 00:26:13,830
through VM bus pipes and a VM bus pipe

602
00:26:11,820 --> 00:26:17,220
is an interface that's set up to look

603
00:26:13,830 --> 00:26:20,439
exactly like named pipes on Windows so

604
00:26:17,220 --> 00:26:22,950
the the way that

605
00:26:20,440 --> 00:26:25,180
you start using a VM bus pipe is the

606
00:26:22,950 --> 00:26:26,980
component the virtual device or

607
00:26:25,180 --> 00:26:30,040
integration component will once again

608
00:26:26,980 --> 00:26:32,980
make a channel offer but the channel

609
00:26:30,040 --> 00:26:35,320
offer will give it a handle to this VM

610
00:26:32,980 --> 00:26:37,660
bus pipe and it then interacts with it

611
00:26:35,320 --> 00:26:39,669
using read file and write file just like

612
00:26:37,660 --> 00:26:42,280
you would with the normal named pipe or

613
00:26:39,670 --> 00:26:45,310
you can do asynchronous i/o if you want

614
00:26:42,280 --> 00:26:47,110
using i/o completion once again just

615
00:26:45,310 --> 00:26:49,179
like you would using normal named pipes

616
00:26:47,110 --> 00:26:51,219
on windows so that one's really easy to

617
00:26:49,180 --> 00:26:53,050
understand once again at the end of the

618
00:26:51,220 --> 00:26:56,110
slide deck we've documented a bunch of

619
00:26:53,050 --> 00:26:58,450
the ways that components will stand up

620
00:26:56,110 --> 00:27:03,669
vm bus named pipe channels to

621
00:26:58,450 --> 00:27:05,530
communicate with the guests alright and

622
00:27:03,670 --> 00:27:07,390
the last communication channel that I

623
00:27:05,530 --> 00:27:10,720
want to just briefly talk about our I Oh

624
00:27:07,390 --> 00:27:12,730
ports and mm IO entry points just to

625
00:27:10,720 --> 00:27:15,790
give you an idea as to how this looks in

626
00:27:12,730 --> 00:27:17,830
the code so for i/o ports you can see

627
00:27:15,790 --> 00:27:20,560
it's it's really simple here basically

628
00:27:17,830 --> 00:27:22,510
any device that wants to use i/o ports

629
00:27:20,560 --> 00:27:24,429
needs to implement these two functions a

630
00:27:22,510 --> 00:27:26,740
notify function that gets called when

631
00:27:24,430 --> 00:27:28,990
the i/o port is read or written to and

632
00:27:26,740 --> 00:27:31,180
that function just tells the component

633
00:27:28,990 --> 00:27:34,600
here's the i/o port address that was

634
00:27:31,180 --> 00:27:38,380
called here is the size of the access

635
00:27:34,600 --> 00:27:40,060
it's one two or four bytes and it'll

636
00:27:38,380 --> 00:27:42,100
either give you the data that's being

637
00:27:40,060 --> 00:27:44,320
written or it will give you a pointer to

638
00:27:42,100 --> 00:27:48,070
the data that you are expected to fill

639
00:27:44,320 --> 00:27:50,110
in as part of the emulation and it's

640
00:27:48,070 --> 00:27:53,860
pretty much the exact same story for mm

641
00:27:50,110 --> 00:27:55,929
IO you're given you have to implement

642
00:27:53,860 --> 00:27:57,699
these two functions and you'll be

643
00:27:55,930 --> 00:27:59,470
informed the number of bytes that are

644
00:27:57,700 --> 00:28:01,120
being read or written given a pointer to

645
00:27:59,470 --> 00:28:02,920
the buffer that either contains the data

646
00:28:01,120 --> 00:28:06,189
or that needs to be populated with the

647
00:28:02,920 --> 00:28:08,370
data so at this point I hope that you

648
00:28:06,190 --> 00:28:11,470
guys have at least a somewhat decent

649
00:28:08,370 --> 00:28:14,260
understanding as to what sorts of

650
00:28:11,470 --> 00:28:16,240
attacks surface there is in hyper-v what

651
00:28:14,260 --> 00:28:18,970
sorts of services we need to provide to

652
00:28:16,240 --> 00:28:22,510
virtual machines and what sorts of

653
00:28:18,970 --> 00:28:24,700
interfaces we commonly use to bridge

654
00:28:22,510 --> 00:28:27,730
that gap between the guest and the host

655
00:28:24,700 --> 00:28:29,710
operating system and so now Nico wants

656
00:28:27,730 --> 00:28:32,410
to walk you guys through some of the

657
00:28:29,710 --> 00:28:34,320
cool bugs that we found in hyper-v that

658
00:28:32,410 --> 00:28:37,110
lie behind these commune

659
00:28:34,320 --> 00:28:38,370
creation channels Thank You Jude that

660
00:28:37,110 --> 00:28:41,668
was super useful

661
00:28:38,370 --> 00:28:43,678
um you know before we even thought about

662
00:28:41,669 --> 00:28:48,029
giving this talk we were asking around

663
00:28:43,679 --> 00:28:51,240
us why was it so hard for researchers to

664
00:28:48,029 --> 00:28:53,970
find bug in hyper reason and one of the

665
00:28:51,240 --> 00:28:56,250
most common answers replies that I had

666
00:28:53,970 --> 00:28:58,710
was Nico you don't seem to realize

667
00:28:56,250 --> 00:29:00,750
you've got access to source code you've

668
00:28:58,710 --> 00:29:03,899
got access to case reports you've got

669
00:29:00,750 --> 00:29:06,419
access to everything but we don't even

670
00:29:03,899 --> 00:29:09,600
have access to symbols and that's

671
00:29:06,419 --> 00:29:14,730
actually a very good point so six months

672
00:29:09,600 --> 00:29:17,250
ago we open our symbols for HIV so not

673
00:29:14,730 --> 00:29:19,740
all of them fortunately for you but

674
00:29:17,250 --> 00:29:22,889
definitely very Stephanie enough there

675
00:29:19,740 --> 00:29:24,929
for you to start a reverse engineering I

676
00:29:22,889 --> 00:29:30,809
think right now where's around 40

677
00:29:24,929 --> 00:29:33,870
symbols they are really decent and there

678
00:29:30,809 --> 00:29:36,210
are definitely what you need to look for

679
00:29:33,870 --> 00:29:38,879
bugs so I think I think I've seen a

680
00:29:36,210 --> 00:29:42,149
tweet from you last week about that Joan

681
00:29:38,879 --> 00:29:46,469
- yeah so we actually as of yeah about a

682
00:29:42,149 --> 00:29:49,340
week ago we released the symbols for all

683
00:29:46,470 --> 00:29:51,539
of the hyper-v storage components we had

684
00:29:49,340 --> 00:29:54,090
accidentally not published a few of them

685
00:29:51,539 --> 00:29:55,110
that we meant to publish and so actually

686
00:29:54,090 --> 00:29:57,330
as of right now

687
00:29:55,110 --> 00:29:59,639
symbols are released for every hyper-v

688
00:29:57,330 --> 00:30:01,860
component except for the hypervisor and

689
00:29:59,639 --> 00:30:03,508
the hypervisor loader but all of the

690
00:30:01,860 --> 00:30:05,969
attack surface in the host operating

691
00:30:03,509 --> 00:30:08,909
system we've got symbols published for

692
00:30:05,970 --> 00:30:11,700
all that stuff that's great so just keep

693
00:30:08,909 --> 00:30:14,669
checking out that link at the bottom of

694
00:30:11,700 --> 00:30:18,179
the page because maybe one day remaining

695
00:30:14,669 --> 00:30:20,879
symbols may be available so let's talk

696
00:30:18,179 --> 00:30:25,769
about some bugs now so we've selected

697
00:30:20,879 --> 00:30:28,678
there's five varieties so why why this

698
00:30:25,769 --> 00:30:32,159
five in particular what some of them

699
00:30:28,679 --> 00:30:35,190
were reported by externals and that's

700
00:30:32,159 --> 00:30:38,549
that's good that's good because here we

701
00:30:35,190 --> 00:30:41,759
can tell you their methodology how these

702
00:30:38,549 --> 00:30:45,600
guys sound bugs that we match stuff

703
00:30:41,759 --> 00:30:47,830
didn't sign before also all the

704
00:30:45,600 --> 00:30:50,168
components here that I've

705
00:30:47,830 --> 00:30:52,600
affected by these varieties of public

706
00:30:50,169 --> 00:30:55,510
symbols so you guys if you want to

707
00:30:52,600 --> 00:30:57,879
reproduce this bugs you can just with

708
00:30:55,510 --> 00:31:00,908
the symbols put your breakpoint and try

709
00:30:57,880 --> 00:31:04,210
to reproduce against Randy Jill and last

710
00:31:00,909 --> 00:31:07,029
point crucially these verbs are easy to

711
00:31:04,210 --> 00:31:09,100
understand we've seen incredibly

712
00:31:07,029 --> 00:31:12,010
complicated bugs we've seen bugs that

713
00:31:09,100 --> 00:31:16,600
would take at least more than one hour

714
00:31:12,010 --> 00:31:19,419
to talk about we just don't have time to

715
00:31:16,600 --> 00:31:22,000
talk about baseball's here so just to

716
00:31:19,419 --> 00:31:22,809
give you a quick overview of what I'm

717
00:31:22,000 --> 00:31:27,039
going to talk about

718
00:31:22,809 --> 00:31:33,960
so two bugs affecting the kernels mostly

719
00:31:27,039 --> 00:31:38,590
pmbus and / bugs affecting the i/o ports

720
00:31:33,960 --> 00:31:41,559
so I'll start with one bug affecting VM

721
00:31:38,590 --> 00:31:45,610
switch so what's VM switch so Jo quickly

722
00:31:41,559 --> 00:31:48,668
talked about it in env architecture so

723
00:31:45,610 --> 00:31:49,990
this is what provides next war this is a

724
00:31:48,669 --> 00:31:52,809
component that provides a network

725
00:31:49,990 --> 00:31:55,330
connectivity to the VM it's a huge

726
00:31:52,809 --> 00:32:00,190
component so go have a look

727
00:31:55,330 --> 00:32:03,519
try to reverse it so the first bug was

728
00:32:00,190 --> 00:32:05,590
reported to us while ago by somebody

729
00:32:03,519 --> 00:32:10,389
named Peter our party working for a

730
00:32:05,590 --> 00:32:13,750
ten-cent and unfortunately for us this

731
00:32:10,389 --> 00:32:14,320
bug had to do with a long string sent to

732
00:32:13,750 --> 00:32:20,230
the host

733
00:32:14,320 --> 00:32:23,500
so Peter found a way to trigger a crash

734
00:32:20,230 --> 00:32:26,549
in V oast just by sending a packet that

735
00:32:23,500 --> 00:32:30,399
was emitting the string without an ER

736
00:32:26,549 --> 00:32:32,918
terminate without an earth character and

737
00:32:30,399 --> 00:32:37,689
so what was happening there is that

738
00:32:32,919 --> 00:32:41,769
between th two and RS one the developers

739
00:32:37,690 --> 00:32:43,630
added a function in in in a function a

740
00:32:41,769 --> 00:32:46,840
function that was actually reporting

741
00:32:43,630 --> 00:32:50,049
errors and so in the set network address

742
00:32:46,840 --> 00:32:53,320
function if an error was detecting that

743
00:32:50,049 --> 00:32:55,809
function was logging the string and it

744
00:32:53,320 --> 00:33:00,039
turns out that we didn't check if the

745
00:32:55,809 --> 00:33:01,460
string was not terminated so if you were

746
00:33:00,039 --> 00:33:03,950
applying as a space

747
00:33:01,460 --> 00:33:06,409
like two VMs which at that moment you

748
00:33:03,950 --> 00:33:10,240
would be able to crash just for a bug

749
00:33:06,409 --> 00:33:13,640
like this right now we would pay to

750
00:33:10,240 --> 00:33:16,010
$15,000 and that's almost what people

751
00:33:13,640 --> 00:33:17,840
Peter got I think he got 10 because he

752
00:33:16,010 --> 00:33:19,760
that was two years ago when you reported

753
00:33:17,840 --> 00:33:24,799
it yeah so we keep increasing your

754
00:33:19,760 --> 00:33:28,850
bounty also so what Peter did how did he

755
00:33:24,799 --> 00:33:32,149
find his balloon he was he was clever as

756
00:33:28,850 --> 00:33:35,178
Joe mentioned so Linux drivers are

757
00:33:32,149 --> 00:33:39,408
available and that's exactly what he did

758
00:33:35,179 --> 00:33:41,659
he fetched this drivers he studied them

759
00:33:39,409 --> 00:33:44,270
got an idea of how they worked and then

760
00:33:41,659 --> 00:33:46,100
he just implemented a quick buzzer just

761
00:33:44,270 --> 00:33:48,799
something that was just sending packets

762
00:33:46,100 --> 00:33:50,658
to the hosts and since his run our wiki

763
00:33:48,799 --> 00:33:53,990
was really easy to trigger he got it

764
00:33:50,659 --> 00:33:59,120
within five minutes afterwards he just

765
00:33:53,990 --> 00:34:02,539
build up small POC just consisting of

766
00:33:59,120 --> 00:34:04,760
lines keyboard from from the original

767
00:34:02,539 --> 00:34:07,700
source code and then sent his packet

768
00:34:04,760 --> 00:34:10,070
with the wrong string to - vos and that

769
00:34:07,700 --> 00:34:13,190
was enough that's what we got it was an

770
00:34:10,070 --> 00:34:17,810
easy to reproduce bug and we are very

771
00:34:13,190 --> 00:34:21,050
thankful that he sent that to us so if

772
00:34:17,810 --> 00:34:24,230
you guys want to reproduce that

773
00:34:21,050 --> 00:34:27,500
vulnerability you might not see a direct

774
00:34:24,230 --> 00:34:30,918
relationship between functions a renewal

775
00:34:27,500 --> 00:34:32,719
function in question and VM bus it's

776
00:34:30,918 --> 00:34:35,989
just because there's requests or

777
00:34:32,719 --> 00:34:39,199
processed a synchronously so just put a

778
00:34:35,989 --> 00:34:43,040
breakpoint in the renard function and at

779
00:34:39,199 --> 00:34:48,049
some point it will be called so just to

780
00:34:43,040 --> 00:34:49,369
finish on vm switch we we should mention

781
00:34:48,050 --> 00:34:51,889
that some bugs

782
00:34:49,369 --> 00:34:54,020
i've been reported to us before by

783
00:34:51,889 --> 00:34:56,510
costia course it's key from google so

784
00:34:54,020 --> 00:34:59,150
that was three years ago I think these

785
00:34:56,510 --> 00:35:00,980
bugs are publicly documented proof of

786
00:34:59,150 --> 00:35:04,730
concept are available so you can have

787
00:35:00,980 --> 00:35:06,859
look at them and also Jordan rabbit from

788
00:35:04,730 --> 00:35:08,839
the offensive security research team at

789
00:35:06,859 --> 00:35:11,390
mark stuff gave a very interesting talk

790
00:35:08,839 --> 00:35:13,910
at blackhat this year about an exploit

791
00:35:11,390 --> 00:35:14,839
he did for VMs which two years ago I

792
00:35:13,910 --> 00:35:16,100
think

793
00:35:14,840 --> 00:35:19,730
check out that talk it's very

794
00:35:16,100 --> 00:35:21,950
interesting all right so we stay in the

795
00:35:19,730 --> 00:35:23,060
kernel and this time we're going to talk

796
00:35:21,950 --> 00:35:26,810
about VP CI

797
00:35:23,060 --> 00:35:30,020
so VI what is that component so it's

798
00:35:26,810 --> 00:35:32,060
basically what so comment on that the

799
00:35:30,020 --> 00:35:35,300
guest is going to use when you want to

800
00:35:32,060 --> 00:35:36,950
use a PCI device on the host so for

801
00:35:35,300 --> 00:35:41,360
example if you have a guest that wants

802
00:35:36,950 --> 00:35:43,189
to talk to you your latest graphic card

803
00:35:41,360 --> 00:35:47,360
that's probably the component that it's

804
00:35:43,190 --> 00:35:50,900
going to use so in the aust you've got V

805
00:35:47,360 --> 00:35:54,560
PCI DSP Dottie's and in that in that

806
00:35:50,900 --> 00:35:57,220
driver you've got a big switch guys it's

807
00:35:54,560 --> 00:36:00,320
if you're sure well whatever that

808
00:35:57,220 --> 00:36:03,560
function name is it's on earth 25k

809
00:36:00,320 --> 00:36:06,230
season in one of the stages had to do

810
00:36:03,560 --> 00:36:10,610
with creating tried to request miss

811
00:36:06,230 --> 00:36:14,780
edges so this what that cases was doing

812
00:36:10,610 --> 00:36:18,440
was using a stack buffer and giving it

813
00:36:14,780 --> 00:36:20,780
to an internal function if you look at

814
00:36:18,440 --> 00:36:22,990
how these internal function is under

815
00:36:20,780 --> 00:36:25,820
you'll see that we initialize

816
00:36:22,990 --> 00:36:28,569
initialization of this stack buffer is

817
00:36:25,820 --> 00:36:30,860
done at the very end of it

818
00:36:28,570 --> 00:36:33,260
unfortunately what the developer didn't

819
00:36:30,860 --> 00:36:36,350
do at that moment was to initialize it

820
00:36:33,260 --> 00:36:38,840
before in case an error or an issue or

821
00:36:36,350 --> 00:36:40,310
an exception was detected and that's

822
00:36:38,840 --> 00:36:43,390
exactly what happened

823
00:36:40,310 --> 00:36:45,560
so deal bug was found by the

824
00:36:43,390 --> 00:36:49,549
virtualization security team at

825
00:36:45,560 --> 00:36:52,250
Microsoft and they figure out that by

826
00:36:49,550 --> 00:36:55,280
causing an issue an exception in that

827
00:36:52,250 --> 00:36:58,490
function they would the stack buffer

828
00:36:55,280 --> 00:37:01,520
would be left and initialized and sent

829
00:36:58,490 --> 00:37:04,729
back to the guest for a bug like this

830
00:37:01,520 --> 00:37:07,870
where you can leak stack memory from the

831
00:37:04,730 --> 00:37:12,580
corner from us kernel we would pay up to

832
00:37:07,870 --> 00:37:16,609
$25,000 however we would need a pocket

833
00:37:12,580 --> 00:37:19,970
for this kind of issue generate eco-park

834
00:37:16,610 --> 00:37:22,430
is not that difficult I advise you to

835
00:37:19,970 --> 00:37:24,649
just put a breakpoint fgo protocol

836
00:37:22,430 --> 00:37:27,230
communication in the guest in VPI

837
00:37:24,650 --> 00:37:28,460
Dottie's and just look at how the and

838
00:37:27,230 --> 00:37:31,520
shake is taken

839
00:37:28,460 --> 00:37:33,710
then you can just change your messages

840
00:37:31,520 --> 00:37:41,930
and try to face it and see if that gives

841
00:37:33,710 --> 00:37:44,810
you any result it's up to you so next we

842
00:37:41,930 --> 00:37:47,029
leave the kernel and we move to the

843
00:37:44,810 --> 00:37:51,250
worker process but we stay with the VM

844
00:37:47,030 --> 00:37:56,890
bus so I'm not going to talk about the

845
00:37:51,250 --> 00:38:00,770
center since a synthetic device sorry

846
00:37:56,890 --> 00:38:03,348
which has to do with the resolution the

847
00:38:00,770 --> 00:38:06,680
screen resolution so this component is

848
00:38:03,349 --> 00:38:10,940
under by VM Yui device the error in the

849
00:38:06,680 --> 00:38:14,839
worker process so you've got these again

850
00:38:10,940 --> 00:38:18,320
a switch case in in that component which

851
00:38:14,839 --> 00:38:21,619
handles just nine cases it's very easy

852
00:38:18,320 --> 00:38:23,480
to so not only this company there's not

853
00:38:21,619 --> 00:38:26,060
only this particular component in this

854
00:38:23,480 --> 00:38:29,180
year we're also others but as a

855
00:38:26,060 --> 00:38:31,490
reasoning is always the same just look

856
00:38:29,180 --> 00:38:34,129
at the endpoints how the messages are

857
00:38:31,490 --> 00:38:34,640
processed and try to figure out what's

858
00:38:34,130 --> 00:38:36,920
going on

859
00:38:34,640 --> 00:38:39,799
this is a saccade ver is really easy to

860
00:38:36,920 --> 00:38:42,410
understand so the bug in question here

861
00:38:39,800 --> 00:38:44,900
had to do with a particular message sent

862
00:38:42,410 --> 00:38:46,848
by the guest so the guest would send a

863
00:38:44,900 --> 00:38:51,500
message and set a boolean in that

864
00:38:46,849 --> 00:38:53,960
message to force in which case the host

865
00:38:51,500 --> 00:38:57,230
would see that Briana and would return

866
00:38:53,960 --> 00:39:00,020
the message we have a structure that was

867
00:38:57,230 --> 00:39:03,940
not fully initialized so I found that by

868
00:39:00,020 --> 00:39:08,359
like two years ago just by looking at

869
00:39:03,940 --> 00:39:11,839
not at the sources but at the GSO DLL

870
00:39:08,359 --> 00:39:14,630
itself with Ida and something surprised

871
00:39:11,839 --> 00:39:18,830
me I only saw just a couple of fields

872
00:39:14,630 --> 00:39:21,050
initialized but the size the used in vir

873
00:39:18,830 --> 00:39:23,990
occasion was much bigger and it turns

874
00:39:21,050 --> 00:39:27,410
out that several fields were not

875
00:39:23,990 --> 00:39:31,430
initialized there so in Viana we would

876
00:39:27,410 --> 00:39:33,740
leak up to almost 90 bytes of heap

877
00:39:31,430 --> 00:39:36,440
memory from the worker processed to

878
00:39:33,740 --> 00:39:39,140
biast a bug like this right now if you

879
00:39:36,440 --> 00:39:41,119
report that to us you'll get $15,000 in

880
00:39:39,140 --> 00:39:41,870
this case there was also an over bug

881
00:39:41,119 --> 00:39:44,030
present

882
00:39:41,870 --> 00:39:48,880
in another function so do some research

883
00:39:44,030 --> 00:39:52,400
like this and you'll get your wo bounty

884
00:39:48,880 --> 00:39:56,210
however you'd need a pack or at least

885
00:39:52,400 --> 00:39:58,100
something that we can reproduce easy so

886
00:39:56,210 --> 00:40:01,670
one thing that I haven't mentioned so

887
00:39:58,100 --> 00:40:04,730
far is that we don't necessarily need a

888
00:40:01,670 --> 00:40:06,800
driver we can you can for example just

889
00:40:04,730 --> 00:40:08,990
send us a script a windy box script

890
00:40:06,800 --> 00:40:12,680
something that put a breakpoint in that

891
00:40:08,990 --> 00:40:14,839
function and just change the message who

892
00:40:12,680 --> 00:40:17,540
party overall type this run ability is

893
00:40:14,840 --> 00:40:20,690
very easy to trigger so we just send a

894
00:40:17,540 --> 00:40:22,640
message to the sorry to the worker

895
00:40:20,690 --> 00:40:25,090
process said that boolean to files and

896
00:40:22,640 --> 00:40:27,650
then there is a response we've you know

897
00:40:25,090 --> 00:40:30,470
initialized data is sent straight away

898
00:40:27,650 --> 00:40:32,690
to the guest that's very easy to see we

899
00:40:30,470 --> 00:40:39,109
don't need a driver for that just a

900
00:40:32,690 --> 00:40:41,480
script would be enough so next we leave

901
00:40:39,110 --> 00:40:44,630
the VM bus and we're talking a bit about

902
00:40:41,480 --> 00:40:47,630
the i/o ports I think Joe you want to

903
00:40:44,630 --> 00:40:49,280
talk about that one because yeah yeah so

904
00:40:47,630 --> 00:40:51,950
this one it's actually an MMA Oh

905
00:40:49,280 --> 00:40:54,940
emulation so one of the things that we

906
00:40:51,950 --> 00:40:57,560
had mentioned earlier was that these

907
00:40:54,940 --> 00:40:58,630
various virtual devices that implement

908
00:40:57,560 --> 00:41:01,310
mm IO

909
00:40:58,630 --> 00:41:04,040
emulation have to em you'll have to

910
00:41:01,310 --> 00:41:07,250
implement this function notify mm IO

911
00:41:04,040 --> 00:41:09,650
read and the way that this function

912
00:41:07,250 --> 00:41:11,840
works is that it's called when you try

913
00:41:09,650 --> 00:41:15,500
to read from a guest physical address

914
00:41:11,840 --> 00:41:17,810
that's used for mm IO and it will be

915
00:41:15,500 --> 00:41:19,970
informed as to the number of bytes that

916
00:41:17,810 --> 00:41:23,390
the guest is trying to read and it is

917
00:41:19,970 --> 00:41:26,600
expected to populate that read buffer

918
00:41:23,390 --> 00:41:29,180
with that many bytes and the issue was

919
00:41:26,600 --> 00:41:34,190
that there were actually some emulators

920
00:41:29,180 --> 00:41:36,890
that we had which would in air cases not

921
00:41:34,190 --> 00:41:38,810
initialize that buffer so you can see

922
00:41:36,890 --> 00:41:43,790
here this example of the battery

923
00:41:38,810 --> 00:41:46,340
emulator which is used to tell a virtual

924
00:41:43,790 --> 00:41:49,940
machine running in a laptop how much

925
00:41:46,340 --> 00:41:52,880
battery that laptop has this emulator

926
00:41:49,940 --> 00:41:55,520
would was expecting that there would

927
00:41:52,880 --> 00:41:59,390
only be four byte reads happening

928
00:41:55,520 --> 00:42:01,190
- its mm IO range and so if you tried to

929
00:41:59,390 --> 00:42:04,190
read anything other than four bytes it

930
00:42:01,190 --> 00:42:06,200
would just return so this means that if

931
00:42:04,190 --> 00:42:08,780
you try to do an 8 byte read then you

932
00:42:06,200 --> 00:42:11,000
will read 8 bytes of uninitialized data

933
00:42:08,780 --> 00:42:14,390
and actually this bug was kind of nice

934
00:42:11,000 --> 00:42:17,570
because it turns out that the 8 bytes

935
00:42:14,390 --> 00:42:19,730
that I would read was always well when I

936
00:42:17,570 --> 00:42:22,940
when I tested it at least it was always

937
00:42:19,730 --> 00:42:24,830
a pointer to a very specific object on

938
00:42:22,940 --> 00:42:26,930
the heap so it's a pretty nice way to

939
00:42:24,830 --> 00:42:28,220
break a SLR if you had another memory

940
00:42:26,930 --> 00:42:31,190
corruption bug you were trying to

941
00:42:28,220 --> 00:42:33,790
exploit and this bug if you found that

942
00:42:31,190 --> 00:42:37,340
today and reported it to us we would pay

943
00:42:33,790 --> 00:42:41,000
$15,000 for I'm glad you got it -

944
00:42:37,340 --> 00:42:42,619
because I missed it so the res bug were

945
00:42:41,000 --> 00:42:47,110
going to talk about is actually your

946
00:42:42,619 --> 00:42:50,360
favorite it effects the emulated ID

947
00:42:47,110 --> 00:42:53,260
component which is used by as you

948
00:42:50,360 --> 00:42:57,590
mentioned before the floppy floppy disk

949
00:42:53,260 --> 00:43:00,850
CD runs the ID drive and it's definitely

950
00:42:57,590 --> 00:43:05,230
a favorite so it was reported to us by

951
00:43:00,850 --> 00:43:05,230
somebody who wishes to remain anonymous

952
00:43:05,320 --> 00:43:09,619
so this component what it is so you talk

953
00:43:09,109 --> 00:43:13,490
to it

954
00:43:09,619 --> 00:43:17,170
through 8 ports so the first 7 ones are

955
00:43:13,490 --> 00:43:21,140
just to say it to set its internal state

956
00:43:17,170 --> 00:43:23,930
the last one is more interesting if you

957
00:43:21,140 --> 00:43:26,180
read or write data to this port you're

958
00:43:23,930 --> 00:43:31,339
going to end up in that function that's

959
00:43:26,180 --> 00:43:33,440
you that is read/write data port so if

960
00:43:31,340 --> 00:43:36,109
you look at this function you'll see

961
00:43:33,440 --> 00:43:39,260
that quickly in the beginning the code

962
00:43:36,109 --> 00:43:42,859
is doing your tests on the state on the

963
00:43:39,260 --> 00:43:46,130
internal state and if the internal state

964
00:43:42,859 --> 00:43:50,119
is set to a particular value then it's

965
00:43:46,130 --> 00:43:54,190
going to use an offset to index into an

966
00:43:50,119 --> 00:43:57,710
internal buffer an internal buffer and

967
00:43:54,190 --> 00:44:02,480
this is where the bug is so it's a guy

968
00:43:57,710 --> 00:44:07,160
who found that just

969
00:44:02,480 --> 00:44:11,660
first quickly Vaio's and managed to get

970
00:44:07,160 --> 00:44:14,839
a crash involving this this dis buffer

971
00:44:11,660 --> 00:44:18,799
and what's crazy here is that you could

972
00:44:14,840 --> 00:44:21,740
control the offset it's a four bytes

973
00:44:18,800 --> 00:44:25,940
offset so you could in VN get an

974
00:44:21,740 --> 00:44:29,089
arbitrary read or write premium on four

975
00:44:25,940 --> 00:44:31,070
gigs on a hip segment and this is super

976
00:44:29,090 --> 00:44:32,990
useful when you are looking to write an

977
00:44:31,070 --> 00:44:37,790
exploit so I'm like to tell you that

978
00:44:32,990 --> 00:44:40,100
today up to no that's the highest bounty

979
00:44:37,790 --> 00:44:44,930
that we've paid one hundred and fifty

980
00:44:40,100 --> 00:44:47,290
thousand dollars this burger it's it was

981
00:44:44,930 --> 00:44:52,850
trickier to find it's just a sequence of

982
00:44:47,290 --> 00:44:56,870
out instructions it's it's really it's

983
00:44:52,850 --> 00:45:01,460
it's trigger I hope we don't have that

984
00:44:56,870 --> 00:45:05,359
many bugs and you see Joe do you want to

985
00:45:01,460 --> 00:45:07,160
have some final words yeah so thanks for

986
00:45:05,360 --> 00:45:09,890
having us here we've really enjoyed

987
00:45:07,160 --> 00:45:12,109
being at code blue we hope that this

988
00:45:09,890 --> 00:45:13,940
talk has been interesting for you we

989
00:45:12,110 --> 00:45:15,890
hope that some of you are interested in

990
00:45:13,940 --> 00:45:18,650
participating in our hyper-v bug bounty

991
00:45:15,890 --> 00:45:20,450
I personally think that hyper-v is a

992
00:45:18,650 --> 00:45:23,270
super interesting target to go after

993
00:45:20,450 --> 00:45:26,720
it's really well designed in my opinion

994
00:45:23,270 --> 00:45:28,520
and the code quality is quite high so

995
00:45:26,720 --> 00:45:30,319
it's definitely not an easy target to go

996
00:45:28,520 --> 00:45:32,870
after but when you do find bugs that's

997
00:45:30,320 --> 00:45:35,120
very gratifying and of course our bug

998
00:45:32,870 --> 00:45:38,180
bounty pays quite a bit of money we

999
00:45:35,120 --> 00:45:40,009
really want to pay bounties so please do

1000
00:45:38,180 --> 00:45:42,759
send us bugs and let us know if there's

1001
00:45:40,010 --> 00:45:45,650
anything that we can do to help you guys

1002
00:45:42,760 --> 00:45:49,310
do research on hyper-v or other

1003
00:45:45,650 --> 00:45:52,130
Microsoft components and yeah as Nico

1004
00:45:49,310 --> 00:45:54,020
had noted Jordan had given a talk at

1005
00:45:52,130 --> 00:45:56,390
blackhat earlier this year which was

1006
00:45:54,020 --> 00:45:59,300
also about hyper-v and exploiting some

1007
00:45:56,390 --> 00:46:01,040
bugs he found in the VM switch so if you

1008
00:45:59,300 --> 00:46:03,290
are interested in hyper-v and you want

1009
00:46:01,040 --> 00:46:06,009
to see more interesting hyper-v research

1010
00:46:03,290 --> 00:46:09,350
you should definitely check that out

1011
00:46:06,010 --> 00:46:12,220
that's what we got so thank you thank

1012
00:46:09,350 --> 00:46:12,220
you guys thank you

