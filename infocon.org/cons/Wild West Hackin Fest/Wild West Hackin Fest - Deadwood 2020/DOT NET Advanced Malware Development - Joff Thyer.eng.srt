1
00:00:00,580 --> 00:00:05,589
I want to say thank you very much for

2
00:00:02,560 --> 00:00:09,550
attending already just right out of the

3
00:00:05,589 --> 00:00:11,230
gate it looks like our first talk for

4
00:00:09,550 --> 00:00:12,940
wild was hacking fest is taking off

5
00:00:11,230 --> 00:00:15,639
really well we already got like a

6
00:00:12,940 --> 00:00:18,880
hundred and twenty people here to here

7
00:00:15,639 --> 00:00:21,698
listen to job talk about dotnet advanced

8
00:00:18,880 --> 00:00:23,830
malware development I want to say thank

9
00:00:21,699 --> 00:00:26,140
you to everybody for being patient to

10
00:00:23,830 --> 00:00:28,610
for wireless hacking fast and Black

11
00:00:26,140 --> 00:00:31,100
Hills information security

12
00:00:28,610 --> 00:00:33,350
I want to be completely blunt last week

13
00:00:31,100 --> 00:00:35,150
and we weren't entirely sure that

14
00:00:33,350 --> 00:00:37,880
switching this thing virtual was the

15
00:00:35,150 --> 00:00:40,940
right idea there was a lot of fear and

16
00:00:37,880 --> 00:00:42,890
trepidation as to whether or not doing

17
00:00:40,940 --> 00:00:44,480
this was the right call I will say that

18
00:00:42,890 --> 00:00:47,030
there's been nothing we've seen in the

19
00:00:44,480 --> 00:00:49,940
news that makes me question what we've

20
00:00:47,030 --> 00:00:51,590
done and it looks like I can't announce

21
00:00:49,940 --> 00:00:54,050
it yet but it looks like this entire

22
00:00:51,590 --> 00:00:57,200
crew is going to be helping out yet

23
00:00:54,050 --> 00:00:59,720
another con go virtual and do the exact

24
00:00:57,200 --> 00:01:01,940
same lift probably in the next couple of

25
00:00:59,720 --> 00:01:03,980
weeks but our goal is to make sure that

26
00:01:01,940 --> 00:01:06,530
cons continue to happen I cannot stress

27
00:01:03,980 --> 00:01:08,450
enough how important I think conferences

28
00:01:06,530 --> 00:01:10,820
are it's the lifeblood of information

29
00:01:08,450 --> 00:01:12,500
security cons are a place for us to get

30
00:01:10,820 --> 00:01:15,740
together to share information to

31
00:01:12,500 --> 00:01:17,210
commiserate and to honestly feel better

32
00:01:15,740 --> 00:01:18,740
about all the different political

33
00:01:17,210 --> 00:01:20,449
battles and all the things that we fight

34
00:01:18,740 --> 00:01:22,759
and all the times that we get breached

35
00:01:20,450 --> 00:01:24,759
in short cons have always been the

36
00:01:22,759 --> 00:01:27,950
lifeblood of the InfoSec industry and

37
00:01:24,759 --> 00:01:29,720
for us to be able to be part of keeping

38
00:01:27,950 --> 00:01:31,910
that lifeblood flowing in this industry

39
00:01:29,720 --> 00:01:33,860
is I think one of the most important

40
00:01:31,910 --> 00:01:37,429
things that we've done in a long long

41
00:01:33,860 --> 00:01:39,560
long time so thank you very much for

42
00:01:37,430 --> 00:01:40,670
being part of that also speaking of

43
00:01:39,560 --> 00:01:43,850
people that are part of this entire

44
00:01:40,670 --> 00:01:45,350
crazy train ride that is Black Hills

45
00:01:43,850 --> 00:01:47,000
information security and wild was

46
00:01:45,350 --> 00:01:49,729
hacking fest I like to introduce you to

47
00:01:47,000 --> 00:01:51,229
JA dire there's really not much more I

48
00:01:49,729 --> 00:01:52,880
can say about JA father than the fact

49
00:01:51,229 --> 00:01:55,490
that he is one of the smartest people I

50
00:01:52,880 --> 00:01:58,369
have ever met and I mean that I really

51
00:01:55,490 --> 00:02:00,710
really really do and more importantly

52
00:01:58,369 --> 00:02:02,810
he's I honestly consider him to be one

53
00:02:00,710 --> 00:02:04,460
of my absolute best friends at Black

54
00:02:02,810 --> 00:02:05,810
Hills information security and Wild West

55
00:02:04,460 --> 00:02:08,570
High confessed and everything that we've

56
00:02:05,810 --> 00:02:10,640
done Joff is one of the people I'll go

57
00:02:08,570 --> 00:02:11,989
weeks without talking to him but if I

58
00:02:10,639 --> 00:02:12,640
actually have something hard to talk

59
00:02:11,989 --> 00:02:15,920
about

60
00:02:12,640 --> 00:02:18,649
Joff is the first person that I call a

61
00:02:15,920 --> 00:02:21,350
Black Hills information security so sit

62
00:02:18,650 --> 00:02:23,360
back relax grab a frosty beverage of

63
00:02:21,350 --> 00:02:26,390
your choice because ladies and gentlemen

64
00:02:23,360 --> 00:02:28,519
JA Thyer is going to present dotnet

65
00:02:26,390 --> 00:02:31,820
advanced malware development hold on to

66
00:02:28,519 --> 00:02:34,250
your shorts all right thanks John what a

67
00:02:31,820 --> 00:02:35,900
great introduction very very kind of you

68
00:02:34,250 --> 00:02:38,630
to say those things

69
00:02:35,900 --> 00:02:40,970
so somebody already asked in the slides

70
00:02:38,630 --> 00:02:42,560
we made a bit larger I'm a victim of my

71
00:02:40,970 --> 00:02:43,790
own big wide monitor he

72
00:02:42,560 --> 00:02:46,190
so we're gonna have to deal with the

73
00:02:43,790 --> 00:02:48,380
slides as they are it's all my fault so

74
00:02:46,190 --> 00:02:49,120
let's just jump into it and see how we

75
00:02:48,380 --> 00:02:57,260
go

76
00:02:49,120 --> 00:03:00,620
so this talk was inspired by the fact

77
00:02:57,260 --> 00:03:02,359
that getting malware on systems these

78
00:03:00,620 --> 00:03:04,459
days is becoming more and more difficult

79
00:03:02,360 --> 00:03:06,170
and I've done a tremendous turn a

80
00:03:04,459 --> 00:03:09,590
tremendous amount of work let's see if I

81
00:03:06,170 --> 00:03:12,140
can speak English in that area for black

82
00:03:09,590 --> 00:03:14,739
holes and trying to advance the state of

83
00:03:12,140 --> 00:03:18,518
the art and get us a little bit more

84
00:03:14,739 --> 00:03:21,319
able especially in our red teams and our

85
00:03:18,519 --> 00:03:23,630
c2 and pivot exercises that we do at the

86
00:03:21,319 --> 00:03:25,760
company so I'm Jeff just a brief

87
00:03:23,630 --> 00:03:26,540
introduction you already know I work at

88
00:03:25,760 --> 00:03:28,190
Black Hills

89
00:03:26,540 --> 00:03:30,920
I'm also saying certified instructor I

90
00:03:28,190 --> 00:03:33,670
do teach the SEC 573 class which is

91
00:03:30,920 --> 00:03:36,440
called automating InfoSec with Python

92
00:03:33,670 --> 00:03:38,089
I'm a security weekly co-host some of

93
00:03:36,440 --> 00:03:40,849
you may be watching that on a weekly

94
00:03:38,090 --> 00:03:43,580
basis or on your podcast I'm a geek I'm

95
00:03:40,849 --> 00:03:45,738
a mathematician I'm a musician and I

96
00:03:43,580 --> 00:03:50,299
love doing all those things so let's

97
00:03:45,739 --> 00:03:53,920
jump into it without further ado first

98
00:03:50,299 --> 00:03:56,200
of all the agenda for the talk

99
00:03:53,920 --> 00:03:58,540
I just wanted to set a few expectations

100
00:03:56,200 --> 00:04:01,810
I'm not here to drop zero days or Oh

101
00:03:58,540 --> 00:04:04,900
days of course a no day is in the eye of

102
00:04:01,810 --> 00:04:06,520
the beholder so you decide what you

103
00:04:04,900 --> 00:04:09,010
think about some of the material that's

104
00:04:06,520 --> 00:04:10,989
I'm going to present I'm definitely not

105
00:04:09,010 --> 00:04:12,190
going to talk directly about heap or

106
00:04:10,989 --> 00:04:15,700
stack exploitation

107
00:04:12,190 --> 00:04:17,950
I'm not releasing a new tool but I am

108
00:04:15,700 --> 00:04:20,168
gonna talk about some C sharp and dotnet

109
00:04:17,950 --> 00:04:22,719
programming and I'm going to give you

110
00:04:20,168 --> 00:04:24,729
some source code because that is

111
00:04:22,720 --> 00:04:27,040
something that I like to do whenever I

112
00:04:24,730 --> 00:04:29,470
do talks I think it's really cool if you

113
00:04:27,040 --> 00:04:32,200
can go home with something to play with

114
00:04:29,470 --> 00:04:35,639
and something to extend and customize

115
00:04:32,200 --> 00:04:38,169
for your own benefit

116
00:04:35,639 --> 00:04:39,850
bottom line what follows here is

117
00:04:38,169 --> 00:04:43,650
thoughts about custom shell code

118
00:04:39,850 --> 00:04:48,030
delivery techniques in the world of

119
00:04:43,650 --> 00:04:52,299
modern windows defense in the enterprise

120
00:04:48,030 --> 00:04:55,419
Windows 10 as we all know and in fact I

121
00:04:52,300 --> 00:04:58,900
do admire what Microsoft has done is has

122
00:04:55,419 --> 00:05:02,440
turned into a really really solid

123
00:04:58,900 --> 00:05:04,690
product I mean let's face it if if you

124
00:05:02,440 --> 00:05:06,940
have able customers in the pen testing

125
00:05:04,690 --> 00:05:10,000
industry and we have a number of very

126
00:05:06,940 --> 00:05:11,740
confident and very good customers you

127
00:05:10,000 --> 00:05:14,919
can configure some really strong

128
00:05:11,740 --> 00:05:18,070
defenses in this platform now it already

129
00:05:14,919 --> 00:05:20,080
ships by default with a SLR and Depp and

130
00:05:18,070 --> 00:05:23,140
heat protection and control flow guard

131
00:05:20,080 --> 00:05:26,260
and all these great things that frankly

132
00:05:23,140 --> 00:05:30,430
are now turned on by default when they

133
00:05:26,260 --> 00:05:33,180
went before which is a huge advance in

134
00:05:30,430 --> 00:05:37,060
the state of the art from an enterprise

135
00:05:33,180 --> 00:05:40,840
desktop protection perspective but to

136
00:05:37,060 --> 00:05:42,490
make life even more difficult for us we

137
00:05:40,840 --> 00:05:45,010
now live in a world of really capable

138
00:05:42,490 --> 00:05:47,830
endpoint detection response products now

139
00:05:45,010 --> 00:05:49,990
you may question that and and you're

140
00:05:47,830 --> 00:05:52,330
okay to question that I do as well

141
00:05:49,990 --> 00:05:54,310
sometimes but let's face it I think the

142
00:05:52,330 --> 00:05:57,430
industry has gotten better and we're all

143
00:05:54,310 --> 00:05:58,450
here to really support people getting

144
00:05:57,430 --> 00:06:00,490
better at what they do

145
00:05:58,450 --> 00:06:02,919
ultimately and moving the state of the

146
00:06:00,490 --> 00:06:05,680
industry forward so all of this is good

147
00:06:02,919 --> 00:06:07,780
stuff now we have organizations and

148
00:06:05,680 --> 00:06:09,700
customers at Black Hills

149
00:06:07,780 --> 00:06:11,138
as do many of you I'm sure that are

150
00:06:09,700 --> 00:06:12,700
doing really good things they're doing

151
00:06:11,139 --> 00:06:15,520
things like AppLocker policy they're

152
00:06:12,700 --> 00:06:17,830
doing user behavior analytics they're

153
00:06:15,520 --> 00:06:21,400
doing threat analytics they're doing

154
00:06:17,830 --> 00:06:24,639
things that making a difference when

155
00:06:21,400 --> 00:06:26,770
they weren't before ultimately the

156
00:06:24,639 --> 00:06:29,260
conclusions that we've all come to and I

157
00:06:26,770 --> 00:06:31,320
think we've seen kind of an explosion in

158
00:06:29,260 --> 00:06:34,599
the software development space in

159
00:06:31,320 --> 00:06:36,280
InfoSec lately on the red side is that

160
00:06:34,600 --> 00:06:38,050
all of our commodity pen testing

161
00:06:36,280 --> 00:06:40,000
frameworks they're getting busted all

162
00:06:38,050 --> 00:06:44,470
the time they're getting court right if

163
00:06:40,000 --> 00:06:48,040
you try to drop a malware executive or

164
00:06:44,470 --> 00:06:49,870
file in an engagement these days it's

165
00:06:48,040 --> 00:06:52,630
probably not going to work and unless

166
00:06:49,870 --> 00:06:55,120
the environment is really not configured

167
00:06:52,630 --> 00:06:57,580
with any defense but even if it's not

168
00:06:55,120 --> 00:07:00,070
you know standard out-of-the-box Windows

169
00:06:57,580 --> 00:07:04,810
Defender frankly is doing a really great

170
00:07:00,070 --> 00:07:07,590
job and so it's become really difficult

171
00:07:04,810 --> 00:07:10,150
for us to get that foothold on systems

172
00:07:07,590 --> 00:07:12,099
where it wasn't before now I'm not

173
00:07:10,150 --> 00:07:14,770
saying it's impossible right

174
00:07:12,100 --> 00:07:16,960
our PowerShell script execution has also

175
00:07:14,770 --> 00:07:19,840
become tough you know we've seen this

176
00:07:16,960 --> 00:07:22,810
situation over the past you know four

177
00:07:19,840 --> 00:07:26,080
four five six years where people became

178
00:07:22,810 --> 00:07:28,870
really well aware of how much we were

179
00:07:26,080 --> 00:07:30,370
doing through PowerShell as the red

180
00:07:28,870 --> 00:07:33,760
teaming community and the attacker

181
00:07:30,370 --> 00:07:35,440
community was doing and responded right

182
00:07:33,760 --> 00:07:37,780
people are instrumenting it well they're

183
00:07:35,440 --> 00:07:41,289
doing things like tuning on script block

184
00:07:37,780 --> 00:07:44,109
logging and and transcription and and

185
00:07:41,289 --> 00:07:46,570
module logging and they're doing things

186
00:07:44,110 --> 00:07:48,250
like looking for specific events and

187
00:07:46,570 --> 00:07:50,169
logging things centrally they're doing

188
00:07:48,250 --> 00:07:51,580
the right things you know not everybody

189
00:07:50,169 --> 00:07:55,539
but a lot of people are doing the right

190
00:07:51,580 --> 00:07:59,650
things so that backdrop is what really

191
00:07:55,539 --> 00:08:03,820
inspired me to push down the route more

192
00:07:59,650 --> 00:08:08,620
of dotnet and really focus on what can I

193
00:08:03,820 --> 00:08:11,590
do with dll's or assemblies in terms of

194
00:08:08,620 --> 00:08:13,930
ultimately payload delivery and the

195
00:08:11,590 --> 00:08:16,479
flexibility that that brings me and the

196
00:08:13,930 --> 00:08:19,270
reason I wanted to go down that road is

197
00:08:16,479 --> 00:08:21,700
because even the frameworks we're using

198
00:08:19,270 --> 00:08:23,680
now where we do get success

199
00:08:21,700 --> 00:08:27,190
things like your cobalt strike for

200
00:08:23,680 --> 00:08:31,030
example allow us often to load and

201
00:08:27,190 --> 00:08:33,159
assembly through an HTTP or HTTPS

202
00:08:31,030 --> 00:08:36,480
channel and so having the ability to

203
00:08:33,159 --> 00:08:39,579
have an additional compiled assembly

204
00:08:36,480 --> 00:08:41,710
handy and ready to roll for different

205
00:08:39,580 --> 00:08:47,280
situations is actually really really

206
00:08:41,710 --> 00:08:50,530
useful from an offensive perspective now

207
00:08:47,280 --> 00:08:52,569
what do we normally want to do well when

208
00:08:50,530 --> 00:08:54,160
we're talking about initial operations

209
00:08:52,570 --> 00:08:57,160
when we're talking about things like

210
00:08:54,160 --> 00:09:00,819
fishing campaigns or even if we've been

211
00:08:57,160 --> 00:09:02,410
given a position in an environment 99

212
00:09:00,820 --> 00:09:04,450
percent of the time a lot of us are

213
00:09:02,410 --> 00:09:06,880
wanting to get some sort of shell code

214
00:09:04,450 --> 00:09:09,070
to run all right this is really really

215
00:09:06,880 --> 00:09:10,780
common why why we want to do that is

216
00:09:09,070 --> 00:09:13,810
because we want to establish that

217
00:09:10,780 --> 00:09:16,630
initial c2 channel we want to gain our

218
00:09:13,810 --> 00:09:19,060
foothold so that we can then leverage

219
00:09:16,630 --> 00:09:21,250
that to stop moving around in the

220
00:09:19,060 --> 00:09:23,890
environment and doing things from a red

221
00:09:21,250 --> 00:09:27,760
teaming or a pen testing perspective

222
00:09:23,890 --> 00:09:29,590
that is useful in terms of reporting on

223
00:09:27,760 --> 00:09:31,569
the vulnerabilities and reporting on the

224
00:09:29,590 --> 00:09:32,920
environmental issues inside of an

225
00:09:31,570 --> 00:09:37,110
enterprise environment

226
00:09:32,920 --> 00:09:40,439
now MSF venom is an awesome tool for

227
00:09:37,110 --> 00:09:43,660
payload generation MSF venom is

228
00:09:40,440 --> 00:09:47,320
fantastic but what I find more

229
00:09:43,660 --> 00:09:50,079
interesting in MSF venom is the

230
00:09:47,320 --> 00:09:53,560
transform formats rather than

231
00:09:50,080 --> 00:09:55,660
necessarily the direct output formats so

232
00:09:53,560 --> 00:09:59,439
if you look at the transform formats we

233
00:09:55,660 --> 00:10:03,100
get things like C byte arrays or C shop

234
00:09:59,440 --> 00:10:06,430
byte arrays Python byte arrays VBA

235
00:10:03,100 --> 00:10:09,400
Rohrer assembly java byte arrays and so

236
00:10:06,430 --> 00:10:11,770
on these things are actually built for

237
00:10:09,400 --> 00:10:14,650
us so that we can pick them up and use

238
00:10:11,770 --> 00:10:16,600
them inside of other software projects

239
00:10:14,650 --> 00:10:19,449
and this is largely what this talk is

240
00:10:16,600 --> 00:10:21,130
going to be about and meterpreter you

241
00:10:19,450 --> 00:10:23,500
know it's not dead let's face it an

242
00:10:21,130 --> 00:10:25,570
interpreter is a really useful shellcode

243
00:10:23,500 --> 00:10:27,850
if we can get that delivered and get an

244
00:10:25,570 --> 00:10:30,940
established C to channel meterpreter

245
00:10:27,850 --> 00:10:33,670
really works well they will definitely

246
00:10:30,940 --> 00:10:35,440
be made available just the answer

247
00:10:33,670 --> 00:10:38,050
daniel's a question he said will the

248
00:10:35,440 --> 00:10:39,580
slides be made available I will plan to

249
00:10:38,050 --> 00:10:42,219
make them available through something

250
00:10:39,580 --> 00:10:43,210
like SlideShare and I believe later on

251
00:10:42,220 --> 00:10:44,710
we're going to try to make them

252
00:10:43,210 --> 00:10:47,590
available through the conference as well

253
00:10:44,710 --> 00:10:50,260
but we'll clarify that at the end so

254
00:10:47,590 --> 00:10:52,690
it's really useful shellcode we'll just

255
00:10:50,260 --> 00:10:56,160
need to work a little bit harder to get

256
00:10:52,690 --> 00:10:58,180
that shellcode delivered to the endpoint

257
00:10:56,160 --> 00:11:02,110
cobalt strike that I've already

258
00:10:58,180 --> 00:11:04,180
mentioned extremely useful for the most

259
00:11:02,110 --> 00:11:06,730
part because of its collaborative aspect

260
00:11:04,180 --> 00:11:08,920
where the Metasploit project falls down

261
00:11:06,730 --> 00:11:10,800
as it doesn't really have certainly in

262
00:11:08,920 --> 00:11:13,180
the you know free as in free beer

263
00:11:10,800 --> 00:11:15,670
download version it doesn't have the

264
00:11:13,180 --> 00:11:17,800
ability to collaborate easily whereas

265
00:11:15,670 --> 00:11:19,959
the cobalt strike framework has got a

266
00:11:17,800 --> 00:11:22,540
really really nice interface for

267
00:11:19,960 --> 00:11:25,120
collaborative red teaming and I think a

268
00:11:22,540 --> 00:11:28,150
lot of us that are doing red team really

269
00:11:25,120 --> 00:11:30,250
love to use cobalt strike because of

270
00:11:28,150 --> 00:11:33,310
that collaborative ability however

271
00:11:30,250 --> 00:11:35,440
having said that we also suffer from the

272
00:11:33,310 --> 00:11:38,410
same issues as the Metasploit framework

273
00:11:35,440 --> 00:11:40,810
if we try to drop an XE or we try to

274
00:11:38,410 --> 00:11:41,589
drop a PowerShell payload that they're

275
00:11:40,810 --> 00:11:44,260
getting caught

276
00:11:41,590 --> 00:11:46,210
cobalt strike is publicly available it's

277
00:11:44,260 --> 00:11:47,860
certainly been studied I'm sure by the

278
00:11:46,210 --> 00:11:51,460
endpoint defense and protection industry

279
00:11:47,860 --> 00:11:55,090
and you know we have the same issue now

280
00:11:51,460 --> 00:11:57,610
cobalt strike also has transform type

281
00:11:55,090 --> 00:12:00,190
formats that we can leverage in the

282
00:11:57,610 --> 00:12:02,260
attack generation and so hopefully

283
00:12:00,190 --> 00:12:04,150
you're sensing a theme here we should

284
00:12:02,260 --> 00:12:06,880
try to use some of those transform

285
00:12:04,150 --> 00:12:10,510
formats and develop our own assemblies

286
00:12:06,880 --> 00:12:13,960
to try and deliver those into the

287
00:12:10,510 --> 00:12:17,500
environment in custom software instead

288
00:12:13,960 --> 00:12:24,720
of just depending on the publicly

289
00:12:17,500 --> 00:12:27,110
available code in terms of processing

290
00:12:24,720 --> 00:12:29,730
action or shellcode delivery techniques

291
00:12:27,110 --> 00:12:30,360
largely we can think about it in this

292
00:12:29,730 --> 00:12:32,339
form

293
00:12:30,360 --> 00:12:35,129
we've got dynamic link library injection

294
00:12:32,339 --> 00:12:37,019
which is your classic or older technique

295
00:12:35,129 --> 00:12:38,790
now that the technique here reflexive

296
00:12:37,019 --> 00:12:41,850
DLL injection and another name for it

297
00:12:38,790 --> 00:12:44,879
typically we are going to write a DLL to

298
00:12:41,850 --> 00:12:47,069
disk we're going to use the kernel 32

299
00:12:44,879 --> 00:12:49,410
call load library a to put that in

300
00:12:47,069 --> 00:12:52,319
memory we're going to hook some sort of

301
00:12:49,410 --> 00:12:54,689
routine with that library injecting it

302
00:12:52,319 --> 00:12:56,670
into another process may be using create

303
00:12:54,689 --> 00:13:01,469
remote thread or something like that and

304
00:12:56,670 --> 00:13:04,560
we've in fact pushing that DLL into some

305
00:13:01,470 --> 00:13:06,990
sort of other process the thing about

306
00:13:04,560 --> 00:13:09,660
this is it's a very very well studied

307
00:13:06,990 --> 00:13:12,600
technique and we really don't need to go

308
00:13:09,660 --> 00:13:15,629
as far as injecting an entire DLL it is

309
00:13:12,600 --> 00:13:18,000
just not necessary we also have the

310
00:13:15,629 --> 00:13:21,300
concept of things like process hollowing

311
00:13:18,000 --> 00:13:23,670
of PE cough processes which is your

312
00:13:21,300 --> 00:13:25,859
standard portable execution common

313
00:13:23,670 --> 00:13:28,170
object format in the Windows operating

314
00:13:25,860 --> 00:13:31,050
system we have the idea of thread

315
00:13:28,170 --> 00:13:33,719
execution or thread hijacking we also

316
00:13:31,050 --> 00:13:35,309
have the idea of asynchronous procedure

317
00:13:33,720 --> 00:13:38,189
call injection which is kind of an

318
00:13:35,309 --> 00:13:40,170
alternative to thread execution and

319
00:13:38,189 --> 00:13:43,139
thread hijacking I like to think of

320
00:13:40,170 --> 00:13:45,660
asynchronous procedure call injection as

321
00:13:43,139 --> 00:13:48,509
kind of a pre-emptive thread hijacking

322
00:13:45,660 --> 00:13:50,670
because an async procedure call does not

323
00:13:48,509 --> 00:13:53,519
get immediately executed in all cases

324
00:13:50,670 --> 00:13:55,199
and sometimes we have to wait until the

325
00:13:53,519 --> 00:13:57,540
process actually wakes up a thread

326
00:13:55,199 --> 00:14:00,180
before that asynchronous procedure call

327
00:13:57,540 --> 00:14:02,610
actually comes alive and and executes

328
00:14:00,180 --> 00:14:04,290
our shell code and then we have thread

329
00:14:02,610 --> 00:14:08,129
local pointer manipulation or hooking

330
00:14:04,290 --> 00:14:10,379
things like hooking the various aspects

331
00:14:08,129 --> 00:14:13,829
of the windows API such as keyboard

332
00:14:10,379 --> 00:14:16,500
controls and so forth and then beyond

333
00:14:13,829 --> 00:14:19,199
that we really have the concept of just

334
00:14:16,500 --> 00:14:21,779
native DLL assembly execution we don't

335
00:14:19,199 --> 00:14:24,479
actually have to inject into another

336
00:14:21,779 --> 00:14:26,819
process at all if we don't choose to

337
00:14:24,480 --> 00:14:30,379
there are numerous ways that we can load

338
00:14:26,819 --> 00:14:30,378
and execute a native DLL

339
00:14:32,500 --> 00:14:37,010
now some of the challenges that we have

340
00:14:35,420 --> 00:14:38,660
with some of these techniques is we're

341
00:14:37,010 --> 00:14:42,560
going to create in indicators of

342
00:14:38,660 --> 00:14:45,380
compromise right if we do things to

343
00:14:42,560 --> 00:14:48,560
limit our exposure in this sense we can

344
00:14:45,380 --> 00:14:51,290
try to avoid getting caught with our

345
00:14:48,560 --> 00:14:53,569
activity right one of the processes that

346
00:14:51,290 --> 00:14:57,740
I think we all have seen the bad guys

347
00:14:53,570 --> 00:14:59,810
use and frankly I also use inside of my

348
00:14:57,740 --> 00:15:02,210
activity is to use the service host a

349
00:14:59,810 --> 00:15:04,160
taxi process it's an oldie but a goodie

350
00:15:02,210 --> 00:15:07,760
the thing about service host a taxi is

351
00:15:04,160 --> 00:15:10,610
this thing is running multiple instances

352
00:15:07,760 --> 00:15:12,890
on any up and running system during very

353
00:15:10,610 --> 00:15:15,920
many different things and it is often

354
00:15:12,890 --> 00:15:19,250
got network activity associated with it

355
00:15:15,920 --> 00:15:21,860
well our c2 Channel with the thread of

356
00:15:19,250 --> 00:15:24,080
shell code we want to inject is going to

357
00:15:21,860 --> 00:15:26,450
have network activity associated with it

358
00:15:24,080 --> 00:15:29,960
and so if we can get our c2 channel

359
00:15:26,450 --> 00:15:32,270
shellcode into service hosted XE it's

360
00:15:29,960 --> 00:15:34,430
more than likely that somebody is not

361
00:15:32,270 --> 00:15:37,340
going to be able to see that from a

362
00:15:34,430 --> 00:15:39,680
defensive perspective well not always

363
00:15:37,340 --> 00:15:43,130
right we also have the concept of

364
00:15:39,680 --> 00:15:46,400
repenting a process if we want to inject

365
00:15:43,130 --> 00:15:49,120
shell code into service host our taxi we

366
00:15:46,400 --> 00:15:51,800
either have to find an existing process

367
00:15:49,120 --> 00:15:55,820
that is owned by the current user on the

368
00:15:51,800 --> 00:15:58,280
system and inject to that process or we

369
00:15:55,820 --> 00:16:01,280
have to create a service host a taxi and

370
00:15:58,280 --> 00:16:03,829
then suspend it and perhaps queue up an

371
00:16:01,280 --> 00:16:06,530
asynchronous procedure call and then

372
00:16:03,830 --> 00:16:08,150
resumed the thread or maybe just start

373
00:16:06,530 --> 00:16:11,240
the process and inject the thread

374
00:16:08,150 --> 00:16:14,199
directly with a create remote thread now

375
00:16:11,240 --> 00:16:16,910
that the challenge with the latter

376
00:16:14,200 --> 00:16:18,740
option is that you're going to end up

377
00:16:16,910 --> 00:16:22,010
with a process that is going to be a

378
00:16:18,740 --> 00:16:24,800
child of whatever process you used to

379
00:16:22,010 --> 00:16:27,950
gain access to the system let's say you

380
00:16:24,800 --> 00:16:32,060
used a macro then that parent process

381
00:16:27,950 --> 00:16:34,970
might be windward XE it might be Excel

382
00:16:32,060 --> 00:16:36,380
dot XE and so you're going to be in a

383
00:16:34,970 --> 00:16:39,280
situation where you're going to create a

384
00:16:36,380 --> 00:16:41,000
child of that parent process and astute

385
00:16:39,280 --> 00:16:42,920
environment that it's watching

386
00:16:41,000 --> 00:16:44,449
parent-child relationships are probably

387
00:16:42,920 --> 00:16:48,079
going to bust you and there

388
00:16:44,449 --> 00:16:49,399
plenty of examples of EDI products that

389
00:16:48,079 --> 00:16:51,049
will actually look at parent-child

390
00:16:49,399 --> 00:16:54,470
relationships and be able to trace them

391
00:16:51,049 --> 00:16:58,879
now we do have a concept that we can use

392
00:16:54,470 --> 00:17:02,269
in C shop to reparent a process by

393
00:16:58,879 --> 00:17:05,990
actually suspending a process rewriting

394
00:17:02,269 --> 00:17:07,638
the parent information in the parent

395
00:17:05,990 --> 00:17:09,559
information data structure when we

396
00:17:07,638 --> 00:17:12,589
create the process initially and then

397
00:17:09,559 --> 00:17:14,480
unsuspended it again thus effectively

398
00:17:12,589 --> 00:17:16,760
attaching that process to another owned

399
00:17:14,480 --> 00:17:20,929
process and one of my favorite things to

400
00:17:16,760 --> 00:17:23,419
do is create something like run time

401
00:17:20,929 --> 00:17:26,539
broker or another service so sexy and

402
00:17:23,419 --> 00:17:28,909
then rhe parent it to a process like

403
00:17:26,539 --> 00:17:30,049
services that XE that the user owns so

404
00:17:28,909 --> 00:17:31,760
you end up with a parent-child

405
00:17:30,049 --> 00:17:34,760
relationship with service host being a

406
00:17:31,760 --> 00:17:36,889
child or services for example or runtime

407
00:17:34,760 --> 00:17:38,480
broker being a child of service host so

408
00:17:36,889 --> 00:17:41,629
some of that stuff works really really

409
00:17:38,480 --> 00:17:44,620
well now the other thing that we can do

410
00:17:41,630 --> 00:17:48,260
with mature environments is combine

411
00:17:44,620 --> 00:17:50,750
these kind of techniques with leveraging

412
00:17:48,260 --> 00:17:52,340
living off the land binaries now a lot

413
00:17:50,750 --> 00:17:55,730
of you are probably aware of the lol

414
00:17:52,340 --> 00:17:57,320
bass dot IO website and I've got some

415
00:17:55,730 --> 00:17:59,630
references at the end of the show here

416
00:17:57,320 --> 00:18:01,639
where we can leverage livering living

417
00:17:59,630 --> 00:18:04,519
off the land binaries that's hard to say

418
00:18:01,639 --> 00:18:07,668
three times fast the thing about living

419
00:18:04,519 --> 00:18:10,610
off the land binaries is 90% of the time

420
00:18:07,669 --> 00:18:12,710
what we can do is leverage a living off

421
00:18:10,610 --> 00:18:15,979
the land binary that is part of the

422
00:18:12,710 --> 00:18:20,059
dotnet environment to create an object

423
00:18:15,980 --> 00:18:22,940
that is a dotnet DLL assembly and if we

424
00:18:20,059 --> 00:18:25,730
can write a custom assembly then we can

425
00:18:22,940 --> 00:18:28,690
directly leverage that ability to load

426
00:18:25,730 --> 00:18:31,639
that assembly and in many times evade

427
00:18:28,690 --> 00:18:35,809
application whitelisting environments

428
00:18:31,639 --> 00:18:38,389
which is well really kind of nice so

429
00:18:35,809 --> 00:18:40,730
let's talk about writing a DLL assembly

430
00:18:38,389 --> 00:18:42,500
to deliver some shellcode I told you I

431
00:18:40,730 --> 00:18:45,080
was going to give you gifts so I'm going

432
00:18:42,500 --> 00:18:47,480
to try to show some code and point out

433
00:18:45,080 --> 00:18:49,850
some features now what I've done is put

434
00:18:47,480 --> 00:18:52,250
together a repo with three examples of

435
00:18:49,850 --> 00:18:55,039
shell code injection and I'm gonna make

436
00:18:52,250 --> 00:18:58,289
that freely available to everybody to

437
00:18:55,039 --> 00:19:01,600
download and use for your own purposes

438
00:18:58,289 --> 00:19:03,158
first of all the outline of steps that

439
00:19:01,600 --> 00:19:06,760
we need for shellcode and direct

440
00:19:03,159 --> 00:19:10,750
injection is largely us manipulating

441
00:19:06,760 --> 00:19:14,260
kernel32 api's right fundamentally the

442
00:19:10,750 --> 00:19:17,710
the steps we need follow this pattern in

443
00:19:14,260 --> 00:19:19,720
just about all cases if you're

444
00:19:17,710 --> 00:19:22,240
interested in remote process injection

445
00:19:19,720 --> 00:19:24,250
you need to find or create a target

446
00:19:22,240 --> 00:19:26,250
process for injection so you would use

447
00:19:24,250 --> 00:19:29,350
the create process or the open process

448
00:19:26,250 --> 00:19:31,570
methods out of kernel32 for that you

449
00:19:29,350 --> 00:19:34,750
need to allocate memory within a local

450
00:19:31,570 --> 00:19:37,689
or remote process in order to contain

451
00:19:34,750 --> 00:19:39,399
your shellcode there are a number of

452
00:19:37,690 --> 00:19:41,529
opportunities here you can use virtual

453
00:19:39,399 --> 00:19:44,229
alloc in the same process you can use

454
00:19:41,529 --> 00:19:46,690
virtual alik e.x in a remote process and

455
00:19:44,230 --> 00:19:50,409
you could actually use hepa create and

456
00:19:46,690 --> 00:19:51,909
heap alik in the same process the next

457
00:19:50,409 --> 00:19:54,720
step you need is to actually copy

458
00:19:51,909 --> 00:19:58,120
shellcode to the newly allocated memory

459
00:19:54,720 --> 00:20:00,880
dot Nets marshalled a copy or RTL move

460
00:19:58,120 --> 00:20:03,370
mem out of kernel32 work very

461
00:20:00,880 --> 00:20:05,440
effectively to do this and then

462
00:20:03,370 --> 00:20:07,870
optionally something that I do like to

463
00:20:05,440 --> 00:20:15,190
do and I do credit sub T with this one

464
00:20:07,870 --> 00:20:16,959
is to reproduce you fly below the rate

465
00:20:15,190 --> 00:20:20,740
at radar a little bit so we could use

466
00:20:16,960 --> 00:20:22,690
virtual protect to do that and the final

467
00:20:20,740 --> 00:20:24,580
step after that is to get our process to

468
00:20:22,690 --> 00:20:26,490
actually execute the shell code that we

469
00:20:24,580 --> 00:20:29,230
have copied over into that memory space

470
00:20:26,490 --> 00:20:31,630
so we could use create thread to do that

471
00:20:29,230 --> 00:20:33,820
we can use create remote thread to do

472
00:20:31,630 --> 00:20:36,340
that if we are creating a thread in a

473
00:20:33,820 --> 00:20:39,189
remote process and as mentioned earlier

474
00:20:36,340 --> 00:20:42,428
we can also leverage the async procedure

475
00:20:39,190 --> 00:20:43,600
call method which is Q user APC to

476
00:20:42,429 --> 00:20:45,909
actually queue up an asynchronous

477
00:20:43,600 --> 00:20:48,549
procedure call to get the process to

478
00:20:45,909 --> 00:20:50,440
execute the shell code now this is just

479
00:20:48,549 --> 00:20:52,299
a number of options that are possibly

480
00:20:50,440 --> 00:20:53,799
available to you this is not an

481
00:20:52,299 --> 00:20:56,200
exhaustive list with the only

482
00:20:53,799 --> 00:20:58,600
possibilities I'm sure you're well aware

483
00:20:56,200 --> 00:21:00,970
that the attacker community is very very

484
00:20:58,600 --> 00:21:04,029
creative and they have a number of

485
00:21:00,970 --> 00:21:05,649
different techniques which I really just

486
00:21:04,029 --> 00:21:07,210
don't have time to talk about in this

487
00:21:05,649 --> 00:21:10,049
talk so we're going to talk about some

488
00:21:07,210 --> 00:21:10,049
fundamentals first

489
00:21:10,960 --> 00:21:17,240
with respect to same process thread

490
00:21:13,730 --> 00:21:19,220
manipulation we can create a DLL

491
00:21:17,240 --> 00:21:20,750
assembly object which ultimately just

492
00:21:19,220 --> 00:21:23,720
delivers the shellcode in that same

493
00:21:20,750 --> 00:21:26,380
process to load the assembly once we've

494
00:21:23,720 --> 00:21:28,970
created it we can either use PowerShell

495
00:21:26,380 --> 00:21:31,700
reflection dot assembly and new object

496
00:21:28,970 --> 00:21:33,500
just to create the assembly directly or

497
00:21:31,700 --> 00:21:35,930
we can even load the assembly in another

498
00:21:33,500 --> 00:21:40,370
teashop program either an XE or another

499
00:21:35,930 --> 00:21:43,370
assembly also in my design criteria I

500
00:21:40,370 --> 00:21:45,409
want to be leet enough so to speak to be

501
00:21:43,370 --> 00:21:48,050
able to detect the target architecture

502
00:21:45,410 --> 00:21:51,410
in the DLL source code so I want to be

503
00:21:48,050 --> 00:21:54,820
able to deliver both x86 32-bit based

504
00:21:51,410 --> 00:21:57,980
shellcode as well as 64-bit based

505
00:21:54,820 --> 00:22:00,649
shellcode and then furthermore I want to

506
00:21:57,980 --> 00:22:03,740
talk about an MS build.xml template that

507
00:22:00,650 --> 00:22:06,890
we can use to actually deliver that

508
00:22:03,740 --> 00:22:10,940
shellcode as a running process on the

509
00:22:06,890 --> 00:22:12,710
target system so let's dive into a

510
00:22:10,940 --> 00:22:14,170
little bit of code I told you we're

511
00:22:12,710 --> 00:22:18,200
going to do a little bit of programming

512
00:22:14,170 --> 00:22:20,980
so forshay same process injection what

513
00:22:18,200 --> 00:22:24,260
I've created here is an example called

514
00:22:20,980 --> 00:22:27,170
example one which has just got a very

515
00:22:24,260 --> 00:22:31,700
very simple method here called run now

516
00:22:27,170 --> 00:22:34,640
this run method accepts two options and

517
00:22:31,700 --> 00:22:37,280
the two options are string variables one

518
00:22:34,640 --> 00:22:39,530
is x86 based shellcode the other one is

519
00:22:37,280 --> 00:22:41,750
x64 based shellcode so what I'm making

520
00:22:39,530 --> 00:22:44,690
the assumption here is that we can

521
00:22:41,750 --> 00:22:47,000
detect the architecture and then we can

522
00:22:44,690 --> 00:22:51,140
select which shellcode we want to run

523
00:22:47,000 --> 00:22:52,670
based on the in pointer size which is

524
00:22:51,140 --> 00:22:55,190
really one of the most effective ways to

525
00:22:52,670 --> 00:22:58,280
detect the architecture the int pointer

526
00:22:55,190 --> 00:22:59,840
class is going to be sized for when it's

527
00:22:58,280 --> 00:23:02,000
a 32-bit architecture and it's going to

528
00:22:59,840 --> 00:23:05,179
be of size eight when it's a 64-bit

529
00:23:02,000 --> 00:23:08,240
architecture after I run the code to

530
00:23:05,180 --> 00:23:10,190
detect the size what I'm immediately

531
00:23:08,240 --> 00:23:12,770
going to do is just convert that shell

532
00:23:10,190 --> 00:23:14,780
code from the base64 string which

533
00:23:12,770 --> 00:23:18,710
frankly in this case is just stored in

534
00:23:14,780 --> 00:23:20,750
the same DLL for simplicity into a byte

535
00:23:18,710 --> 00:23:22,670
array so that's what this line right

536
00:23:20,750 --> 00:23:24,110
here is doing just converting this from

537
00:23:22,670 --> 00:23:26,510
the pace

538
00:23:24,110 --> 00:23:28,309
sixty-four string to a byte array then

539
00:23:26,510 --> 00:23:31,670
I'm allocating some memory with the

540
00:23:28,309 --> 00:23:34,580
virtual Alec call copying that shellcode

541
00:23:31,670 --> 00:23:37,490
into memory using Marshall dot copy and

542
00:23:34,580 --> 00:23:40,309
then I'm just simply using create thread

543
00:23:37,490 --> 00:23:43,520
with an option pointing to that memory

544
00:23:40,309 --> 00:23:46,610
that I allocated to actually spin up the

545
00:23:43,520 --> 00:23:49,790
thread in the same process with that

546
00:23:46,610 --> 00:23:51,740
shell code to execute now this is

547
00:23:49,790 --> 00:23:54,530
something that you have all probably

548
00:23:51,740 --> 00:23:56,990
seen before if you've actually dug under

549
00:23:54,530 --> 00:23:59,540
the hood and looked at some of the

550
00:23:56,990 --> 00:24:01,340
Metasploit macros or perhaps you've done

551
00:23:59,540 --> 00:24:03,620
dug under the hood and looked at some of

552
00:24:01,340 --> 00:24:05,480
the things that dave is doing in unicorn

553
00:24:03,620 --> 00:24:08,000
and some of these other tools that we

554
00:24:05,480 --> 00:24:10,490
use in the community this fundamental

555
00:24:08,000 --> 00:24:13,160
process of actually spinning up a thread

556
00:24:10,490 --> 00:24:17,480
with shell code in the same process

557
00:24:13,160 --> 00:24:20,410
spray space is extremely common okay

558
00:24:17,480 --> 00:24:23,510
just a couple of comments on the

559
00:24:20,410 --> 00:24:26,090
kernel32 allocation calls here for

560
00:24:23,510 --> 00:24:28,490
virtual Alec we're actually allocating

561
00:24:26,090 --> 00:24:30,620
the memory with memory commit which is a

562
00:24:28,490 --> 00:24:33,200
specific flag I don't actually put a

563
00:24:30,620 --> 00:24:35,809
text-based flag in the code I'd rather

564
00:24:33,200 --> 00:24:37,760
just put the short integer just to avoid

565
00:24:35,809 --> 00:24:39,320
any additional things being in the in

566
00:24:37,760 --> 00:24:41,960
the source code and we're also

567
00:24:39,320 --> 00:24:44,389
allocating it with a page execute read

568
00:24:41,960 --> 00:24:46,429
write flag and that tells us that we

569
00:24:44,390 --> 00:24:51,110
want to actually execute shellcode from

570
00:24:46,429 --> 00:24:51,680
that memory that we're allocating with

571
00:24:51,110 --> 00:24:54,699
respect

572
00:24:51,680 --> 00:24:59,060
a compilation I'm using Visual Studio

573
00:24:54,700 --> 00:25:00,500
I'm setting it to any CPU as the

574
00:24:59,060 --> 00:25:02,600
architecture for the resulting

575
00:25:00,500 --> 00:25:05,330
compilation and I'm setting the output

576
00:25:02,600 --> 00:25:07,929
to be a class library so it's going to

577
00:25:05,330 --> 00:25:11,210
produce a dll in this particular case

578
00:25:07,930 --> 00:25:14,390
with the output of the build process now

579
00:25:11,210 --> 00:25:17,390
the any CPU flag tells us that we can

580
00:25:14,390 --> 00:25:20,300
run this on either a 32-bit system or a

581
00:25:17,390 --> 00:25:23,270
64-bit system and the intermediate

582
00:25:20,300 --> 00:25:26,360
language interpretation that occurs in

583
00:25:23,270 --> 00:25:29,480
in the.net framework will compile it to

584
00:25:26,360 --> 00:25:31,129
either 32-bit or 64-bit based at what

585
00:25:29,480 --> 00:25:33,800
architecture it's running on at runtime

586
00:25:31,130 --> 00:25:36,050
which is actually very very useful if

587
00:25:33,800 --> 00:25:38,540
you want to limit your architecture

588
00:25:36,050 --> 00:25:41,540
purely to a particular machine you can

589
00:25:38,540 --> 00:25:48,260
certainly set that to x86 or you can set

590
00:25:41,540 --> 00:25:51,200
it to 64-bit it's really up to you so

591
00:25:48,260 --> 00:25:53,840
taking this a little bit further example

592
00:25:51,200 --> 00:25:56,780
2 I'm going to repeat the same process

593
00:25:53,840 --> 00:25:59,899
here except I'm writing the source code

594
00:25:56,780 --> 00:26:03,260
this time to use the heap and so I am

595
00:25:59,900 --> 00:26:06,550
creating a heap segment that is of the

596
00:26:03,260 --> 00:26:09,500
length of the shellcode and then I am

597
00:26:06,550 --> 00:26:11,840
allocating memory on that on that heap

598
00:26:09,500 --> 00:26:13,100
that is also of the length of the

599
00:26:11,840 --> 00:26:15,350
shellcode so those are the two

600
00:26:13,100 --> 00:26:17,330
fundamental calls I'm using instead of

601
00:26:15,350 --> 00:26:20,030
using virtual Alec and this is just for

602
00:26:17,330 --> 00:26:21,860
a little bit of diversity because there

603
00:26:20,030 --> 00:26:23,690
are cases where some of the end point

604
00:26:21,860 --> 00:26:25,820
detection products I believe are

605
00:26:23,690 --> 00:26:28,940
actually looking for various kernel32

606
00:26:25,820 --> 00:26:30,230
API calls and sometimes you want to have

607
00:26:28,940 --> 00:26:33,650
a little bit of diversity in your

608
00:26:30,230 --> 00:26:35,690
payload delivery then we're using the

609
00:26:33,650 --> 00:26:37,880
same method to copy the shellcode right

610
00:26:35,690 --> 00:26:39,890
we're using marshal copy down here to

611
00:26:37,880 --> 00:26:42,140
copy the shellcode into that memory

612
00:26:39,890 --> 00:26:43,790
allocated segment in this case it's a

613
00:26:42,140 --> 00:26:46,520
heap pointer and I called the variable

614
00:26:43,790 --> 00:26:48,920
heap and then again we're using create

615
00:26:46,520 --> 00:26:52,639
thread and wait for a single object to

616
00:26:48,920 --> 00:26:57,200
just cause the process to suspend now in

617
00:26:52,640 --> 00:27:00,170
both the cases of example one an example

618
00:26:57,200 --> 00:27:02,660
to the shellcode is going to spin up a

619
00:27:00,170 --> 00:27:05,130
thread in that same process and if the

620
00:27:02,660 --> 00:27:07,650
thread continues to run then

621
00:27:05,130 --> 00:27:13,110
same process is going to stay in memory

622
00:27:07,650 --> 00:27:15,810
so for example if I used msbuild and I

623
00:27:13,110 --> 00:27:17,729
put this dll inside of a msbuild

624
00:27:15,810 --> 00:27:21,629
XML which I'm going to talk about later

625
00:27:17,730 --> 00:27:24,720
then that msbuild process is going to

626
00:27:21,630 --> 00:27:27,900
stay static in memory as msbuild XE and

627
00:27:24,720 --> 00:27:30,210
stay there with your thread of shell

628
00:27:27,900 --> 00:27:32,880
code running inside that msbuild XE

629
00:27:30,210 --> 00:27:35,160
process I see a question there will be

630
00:27:32,880 --> 00:27:37,800
examples beyond github and the answer is

631
00:27:35,160 --> 00:27:39,570
yes they will sir so you are more than

632
00:27:37,800 --> 00:27:42,629
welcome to download them and play with

633
00:27:39,570 --> 00:27:45,330
them to your heart's content I will give

634
00:27:42,630 --> 00:27:50,130
you the link for the github later in the

635
00:27:45,330 --> 00:27:52,320
presentation now one of the other

636
00:27:50,130 --> 00:27:55,680
challenges that we run into with dotnet

637
00:27:52,320 --> 00:27:57,540
is we must get the DLL imports correct

638
00:27:55,680 --> 00:28:02,220
when we're writing the source code and

639
00:27:57,540 --> 00:28:05,870
so we need to actually look on MSDN or p

640
00:28:02,220 --> 00:28:09,510
invoke and check out what the different

641
00:28:05,870 --> 00:28:11,639
kernel32.dll imports require in terms of

642
00:28:09,510 --> 00:28:14,790
the various parameters that you're

643
00:28:11,640 --> 00:28:16,290
setting in the kernel 32 calls if you

644
00:28:14,790 --> 00:28:21,000
don't do this

645
00:28:16,290 --> 00:28:22,860
or if you do it wrong frankly the

646
00:28:21,000 --> 00:28:26,880
defaults are going to drop back to just

647
00:28:22,860 --> 00:28:29,870
an integer in the API and this could

648
00:28:26,880 --> 00:28:32,040
result in let's just say suboptimal

649
00:28:29,870 --> 00:28:34,739
results in fact you won't get your code

650
00:28:32,040 --> 00:28:37,110
to work so you need to appropriately set

651
00:28:34,740 --> 00:28:41,250
the integers and the int pointers and

652
00:28:37,110 --> 00:28:43,290
you know the appropriate imports with

653
00:28:41,250 --> 00:28:46,350
these kind of statements in your source

654
00:28:43,290 --> 00:28:49,379
code now I often use P invoke because

655
00:28:46,350 --> 00:28:51,810
it's very very handy for looking up what

656
00:28:49,380 --> 00:28:54,840
the appropriate see shop DLL import

657
00:28:51,810 --> 00:28:58,639
should be and I often use MSDN to

658
00:28:54,840 --> 00:29:02,720
actually validate from the win32

659
00:28:58,640 --> 00:29:04,890
original MFC api's whether my

660
00:29:02,720 --> 00:29:10,590
appropriate variables in c-sharp are

661
00:29:04,890 --> 00:29:11,210
correct so what have we created we now

662
00:29:10,590 --> 00:29:13,189
have two

663
00:29:11,210 --> 00:29:15,529
classes for two different shellcode

664
00:29:13,190 --> 00:29:17,809
injection techniques each of these

665
00:29:15,529 --> 00:29:20,600
classes has an entry method entry point

666
00:29:17,809 --> 00:29:23,480
a method which we've just called run the

667
00:29:20,600 --> 00:29:26,449
run method accepts either an x86 or an

668
00:29:23,480 --> 00:29:29,720
x64 shellcode parameter as a string and

669
00:29:26,450 --> 00:29:34,789
it expects those strings to be base64

670
00:29:29,720 --> 00:29:38,690
encoded now it's pretty easy to compile

671
00:29:34,789 --> 00:29:42,289
the dotnet code down to an executable

672
00:29:38,690 --> 00:29:44,240
and use this as a testing method before

673
00:29:42,289 --> 00:29:46,250
we even go to the extent of doing

674
00:29:44,240 --> 00:29:48,860
something like building an MS build dot

675
00:29:46,250 --> 00:29:52,580
XML or trying to load the object in

676
00:29:48,860 --> 00:29:55,219
PowerShell one of the simplest things to

677
00:29:52,580 --> 00:29:58,750
do is in your source code just go ahead

678
00:29:55,220 --> 00:30:02,299
and define a public static void main and

679
00:29:58,750 --> 00:30:05,240
call your run function in the main

680
00:30:02,299 --> 00:30:08,840
function here and pass it some base64

681
00:30:05,240 --> 00:30:11,059
encoded shellcode now one of the easiest

682
00:30:08,840 --> 00:30:13,010
things to do is to pop a calculator

683
00:30:11,059 --> 00:30:15,500
because well who doesn't need a

684
00:30:13,010 --> 00:30:17,059
calculator right in fact by the way if

685
00:30:15,500 --> 00:30:18,590
you get a spreadsheet from me and you

686
00:30:17,059 --> 00:30:22,700
get a calculator that comes with that

687
00:30:18,590 --> 00:30:24,310
you probably should be suspicious so in

688
00:30:22,700 --> 00:30:27,130
my code

689
00:30:24,310 --> 00:30:30,370
you can see here we have private string

690
00:30:27,130 --> 00:30:33,490
static calc underscore x86 and this is

691
00:30:30,370 --> 00:30:36,370
literally me taking the output of MSF

692
00:30:33,490 --> 00:30:38,440
venom windows slash exec CMD equals

693
00:30:36,370 --> 00:30:41,590
Caltech see in RAW format and just

694
00:30:38,440 --> 00:30:44,620
piping it to base64 cutting and pasting

695
00:30:41,590 --> 00:30:47,169
the resulting base64 directly into the C

696
00:30:44,620 --> 00:30:47,709
shop source code and I'm off to the

697
00:30:47,170 --> 00:30:50,800
races

698
00:30:47,710 --> 00:30:52,720
now I can hear a lot of you thinking to

699
00:30:50,800 --> 00:30:55,210
yourself in fact I know what you're

700
00:30:52,720 --> 00:30:57,880
going to say you're all thinking hey

701
00:30:55,210 --> 00:31:00,160
Joff as soon as this thing decodes in

702
00:30:57,880 --> 00:31:03,880
memory the endpoint defense

703
00:31:00,160 --> 00:31:07,380
whatever it is is gonna say gotcha there

704
00:31:03,880 --> 00:31:10,750
is some raw assembly from Metasploit

705
00:31:07,380 --> 00:31:14,170
windows slash exact method you're busted

706
00:31:10,750 --> 00:31:18,190
and you're right that's probably going

707
00:31:14,170 --> 00:31:21,340
to happen now I think everybody on this

708
00:31:18,190 --> 00:31:24,880
call is probably super super smart and

709
00:31:21,340 --> 00:31:27,429
can think of numerous ways that if you

710
00:31:24,880 --> 00:31:29,950
just do a little google coding or even a

711
00:31:27,430 --> 00:31:32,710
little use a little imagination with C

712
00:31:29,950 --> 00:31:36,040
sharp you could probably off escape this

713
00:31:32,710 --> 00:31:37,720
shellcode a little bit more and frankly

714
00:31:36,040 --> 00:31:40,240
it's not hard

715
00:31:37,720 --> 00:31:42,820
what about rot13 for example what about

716
00:31:40,240 --> 00:31:46,930
exclusive-or right there's all kinds of

717
00:31:42,820 --> 00:31:48,399
things you could think of alright so

718
00:31:46,930 --> 00:31:51,040
example 1 and 2 are going to stay

719
00:31:48,400 --> 00:31:52,450
resident in process the new thread is

720
00:31:51,040 --> 00:31:54,730
going to be a threat of whatever process

721
00:31:52,450 --> 00:31:56,980
that created that object if the process

722
00:31:54,730 --> 00:32:01,660
stays alive great your payload continues

723
00:31:56,980 --> 00:32:04,840
running let's push the accelerator down

724
00:32:01,660 --> 00:32:09,010
a little bit more what if we wanted to

725
00:32:04,840 --> 00:32:14,679
inject into another running process okay

726
00:32:09,010 --> 00:32:17,440
well to do this we have first of all the

727
00:32:14,680 --> 00:32:20,050
challenge of finding a suitable process

728
00:32:17,440 --> 00:32:22,810
for injection now we really have a

729
00:32:20,050 --> 00:32:25,570
choice here we could create a suitable

730
00:32:22,810 --> 00:32:28,600
process for injection or we can just go

731
00:32:25,570 --> 00:32:31,570
out searching for one now in my example

732
00:32:28,600 --> 00:32:35,169
code I decided to just go out and search

733
00:32:31,570 --> 00:32:37,570
for a process because why not right so

734
00:32:35,170 --> 00:32:38,500
in this case I'm looking for something

735
00:32:37,570 --> 00:32:41,530
like service

736
00:32:38,500 --> 00:32:43,870
or any other process frankly that is

737
00:32:41,530 --> 00:32:47,379
owned by you and then what I need to do

738
00:32:43,870 --> 00:32:48,549
in my C shop code is open up the process

739
00:32:47,380 --> 00:32:51,870
handle of that pit

740
00:32:48,549 --> 00:32:54,850
using the kernel32 open process API call

741
00:32:51,870 --> 00:32:58,330
use virtual Alec e^x to allocate memory

742
00:32:54,850 --> 00:33:00,580
inside the target process then use write

743
00:32:58,330 --> 00:33:03,250
process memory to write the payload into

744
00:33:00,580 --> 00:33:06,010
the process optionally use virtual

745
00:33:03,250 --> 00:33:08,650
protect e^x to apply read execute only

746
00:33:06,010 --> 00:33:10,270
permissions this is kind of fun because

747
00:33:08,650 --> 00:33:13,570
it helps you stay under the radar a

748
00:33:10,270 --> 00:33:16,120
little bit and then use Create remote

749
00:33:13,570 --> 00:33:18,370
thread instead of create thread to

750
00:33:16,120 --> 00:33:22,658
actually create the shell code thread in

751
00:33:18,370 --> 00:33:25,689
that remote process now I want you to be

752
00:33:22,659 --> 00:33:29,230
aware of one thing here if we do this

753
00:33:25,690 --> 00:33:31,360
step where we use virtual protect e^x to

754
00:33:29,230 --> 00:33:35,429
change the permissions to read execute

755
00:33:31,360 --> 00:33:37,658
only we cannot encode our shell code

756
00:33:35,429 --> 00:33:41,650
before we put it into our source code

757
00:33:37,659 --> 00:33:45,429
and by that I mean we cannot use the

758
00:33:41,650 --> 00:33:48,730
Metasploit encoders for example the best

759
00:33:45,429 --> 00:33:51,580
thing i well my best understanding about

760
00:33:48,730 --> 00:33:54,730
that is that the Metasploit encoders

761
00:33:51,580 --> 00:33:57,158
appear to rely on the fact that the

762
00:33:54,730 --> 00:33:59,500
shell code that runs needs to be able to

763
00:33:57,159 --> 00:34:02,950
write back to the same memory segment

764
00:33:59,500 --> 00:34:05,830
before actually executing the real

765
00:34:02,950 --> 00:34:08,440
original shell code if you protect it as

766
00:34:05,830 --> 00:34:10,779
read execute you will not be able to

767
00:34:08,440 --> 00:34:13,060
write back to that same memory segment

768
00:34:10,780 --> 00:34:14,679
and you will fail so that's my

769
00:34:13,060 --> 00:34:16,210
understanding of that process if anybody

770
00:34:14,679 --> 00:34:16,780
has a different understanding please

771
00:34:16,210 --> 00:34:18,850
tell me

772
00:34:16,780 --> 00:34:23,470
but trust me I've tried it many times

773
00:34:18,850 --> 00:34:25,600
and you cannot encode your shell code

774
00:34:23,469 --> 00:34:27,040
with an encoder that requires a dynamic

775
00:34:25,600 --> 00:34:30,710
write permission back to the memory

776
00:34:27,040 --> 00:34:33,050
segment finding the target

777
00:34:30,710 --> 00:34:36,349
process you've got a couple of options

778
00:34:33,050 --> 00:34:39,740
here you can certainly use WMI from

779
00:34:36,349 --> 00:34:42,619
within net and within c-sharp or you can

780
00:34:39,739 --> 00:34:45,290
use the dotnet process class for listing

781
00:34:42,619 --> 00:34:48,859
processes and finding processes that are

782
00:34:45,290 --> 00:34:51,589
running on the system windows management

783
00:34:48,859 --> 00:34:55,279
instrumentation is awesome it is very

784
00:34:51,589 --> 00:34:56,629
reliable but it is slow and possibly you

785
00:34:55,280 --> 00:34:58,430
might have other indicators of

786
00:34:56,629 --> 00:35:01,130
compromise that could be shown if you

787
00:34:58,430 --> 00:35:03,589
use it it depends on how well

788
00:35:01,130 --> 00:35:06,950
instrumented your environment is the

789
00:35:03,589 --> 00:35:10,970
dotnet process class is much faster it's

790
00:35:06,950 --> 00:35:13,848
more native and frankly I prefer it from

791
00:35:10,970 --> 00:35:17,118
a usability perspective but it does use

792
00:35:13,849 --> 00:35:18,980
a few more kernel calls as its running

793
00:35:17,119 --> 00:35:21,260
for example when you grab a handle on a

794
00:35:18,980 --> 00:35:24,650
process it actually opens that process

795
00:35:21,260 --> 00:35:29,089
so you probably need to think about both

796
00:35:24,650 --> 00:35:31,640
options potentially you can use WMI in

797
00:35:29,089 --> 00:35:33,140
dotnet I discarded this approach after

798
00:35:31,640 --> 00:35:35,299
my first attempt because I got sick of

799
00:35:33,140 --> 00:35:38,660
it being slow that doesn't mean my code

800
00:35:35,300 --> 00:35:41,839
was bad it just means that I didn't like

801
00:35:38,660 --> 00:35:43,339
the slowness of it because it was well

802
00:35:41,839 --> 00:35:45,680
bothering me let's just put it that way

803
00:35:43,339 --> 00:35:48,740
so I wrote a method here called select

804
00:35:45,680 --> 00:35:51,319
stock target process I gave it an a

805
00:35:48,740 --> 00:35:53,540
process name as a string entry and you

806
00:35:51,320 --> 00:35:56,390
can see here that the wql which is the

807
00:35:53,540 --> 00:35:58,040
WMI query is just selecting everything

808
00:35:56,390 --> 00:36:00,799
from the win32 on the school process

809
00:35:58,040 --> 00:36:04,040
class and then it's going through a loop

810
00:36:00,800 --> 00:36:06,230
where it's actually getting the owner of

811
00:36:04,040 --> 00:36:09,740
the process and it's getting the process

812
00:36:06,230 --> 00:36:12,109
ID and then it's comparing you with the

813
00:36:09,740 --> 00:36:14,359
owner of the process making sure that

814
00:36:12,109 --> 00:36:15,890
you are indeed that owner and if it

815
00:36:14,359 --> 00:36:18,740
finds that you are the owner of the

816
00:36:15,890 --> 00:36:22,220
process it's adding it to a list of

817
00:36:18,740 --> 00:36:24,979
potential candidates for selection then

818
00:36:22,220 --> 00:36:27,740
at the end of the routine here if there

819
00:36:24,980 --> 00:36:31,400
are candidates that can be selected I am

820
00:36:27,740 --> 00:36:33,740
actually calling R&D necks which is just

821
00:36:31,400 --> 00:36:36,230
selecting a random number from the count

822
00:36:33,740 --> 00:36:38,899
of candidates and the reason that I did

823
00:36:36,230 --> 00:36:41,359
that is because I don't want to select

824
00:36:38,900 --> 00:36:43,670
the same process every time this code

825
00:36:41,359 --> 00:36:44,400
runs I actually want to get a pseudo

826
00:36:43,670 --> 00:36:47,190
random number

827
00:36:44,400 --> 00:36:49,440
and pick some process out of a potential

828
00:36:47,190 --> 00:36:55,110
list of candidates to make things a

829
00:36:49,440 --> 00:36:56,700
little bit more interesting the

830
00:36:55,110 --> 00:37:00,920
alternative method which I did not

831
00:36:56,700 --> 00:37:04,109
discard is using the.net process class

832
00:37:00,920 --> 00:37:07,140
what I wrote here is a method called

833
00:37:04,110 --> 00:37:09,600
fine target process this one uses the

834
00:37:07,140 --> 00:37:14,879
process class from the system

835
00:37:09,600 --> 00:37:16,799
Diagnostics namespace where it gets a

836
00:37:14,880 --> 00:37:19,440
list of processes from the system and

837
00:37:16,800 --> 00:37:24,180
then it loops through each one of those

838
00:37:19,440 --> 00:37:27,450
processes and it tries to check whether

839
00:37:24,180 --> 00:37:30,390
the thread state of each process is in a

840
00:37:27,450 --> 00:37:33,480
standby state and it also tries to check

841
00:37:30,390 --> 00:37:36,359
whether the current process is the same

842
00:37:33,480 --> 00:37:38,430
process as you are running in if either

843
00:37:36,360 --> 00:37:40,440
one of those is true it just continues

844
00:37:38,430 --> 00:37:43,620
with the loop because we do not want to

845
00:37:40,440 --> 00:37:46,230
select a suspended process and we do not

846
00:37:43,620 --> 00:37:48,120
want to select our own current process

847
00:37:46,230 --> 00:37:50,100
it would kind of defeat the purpose if

848
00:37:48,120 --> 00:37:53,069
we're doing remote process injection and

849
00:37:50,100 --> 00:37:54,509
then we decided to inject into our own

850
00:37:53,070 --> 00:37:57,240
process that we're running on right

851
00:37:54,510 --> 00:38:00,030
that's kind of silly then I do a little

852
00:37:57,240 --> 00:38:02,299
couple of things that are somewhat

853
00:38:00,030 --> 00:38:04,800
clever at least I thought they were I

854
00:38:02,300 --> 00:38:07,470
look at the current process that I'm

855
00:38:04,800 --> 00:38:10,350
running and if my current in pointer is

856
00:38:07,470 --> 00:38:13,859
size eight meaning I'm on a 64-bit

857
00:38:10,350 --> 00:38:18,630
system and the target process is a

858
00:38:13,860 --> 00:38:22,200
64-bit process then I add this process

859
00:38:18,630 --> 00:38:23,910
to the list using a string format here

860
00:38:22,200 --> 00:38:27,089
in fact it's not a list it's actually a

861
00:38:23,910 --> 00:38:29,040
collection called a dictionary where the

862
00:38:27,090 --> 00:38:31,770
Pibb is the key to the dictionary the

863
00:38:29,040 --> 00:38:35,509
process name and the architecture are

864
00:38:31,770 --> 00:38:37,860
the actual values in the dictionary and

865
00:38:35,510 --> 00:38:39,870
there are three use cases that I

866
00:38:37,860 --> 00:38:43,080
discovered that will work nicely and it

867
00:38:39,870 --> 00:38:47,130
goes like this you can inject from a

868
00:38:43,080 --> 00:38:50,370
host 64-bit process to a target 64-bit

869
00:38:47,130 --> 00:38:53,430
process that's a legitimate case you can

870
00:38:50,370 --> 00:38:56,529
inject from a host 64-bit pass that

871
00:38:53,430 --> 00:38:58,839
process to a target 32-bit process that

872
00:38:56,530 --> 00:39:03,040
also a legitimate case you can also

873
00:38:58,840 --> 00:39:05,710
inject from a host 32-bit process into a

874
00:39:03,040 --> 00:39:07,509
target 32-bit process the thing you

875
00:39:05,710 --> 00:39:11,470
cannot do or at least it didn't work for

876
00:39:07,510 --> 00:39:14,170
me was inject from a host 32-bit process

877
00:39:11,470 --> 00:39:15,879
into a target 64-bit process and I'm

878
00:39:14,170 --> 00:39:18,220
sure all those people that are more

879
00:39:15,880 --> 00:39:21,250
Microsoft savvy than me can probably

880
00:39:18,220 --> 00:39:26,080
tell me why at some point so there might

881
00:39:21,250 --> 00:39:29,140
three use cases then I at go ahead and I

882
00:39:26,080 --> 00:39:32,620
create a list of keys in that candidate

883
00:39:29,140 --> 00:39:35,859
list and then I select again from those

884
00:39:32,620 --> 00:39:38,200
keys a random selection to return back

885
00:39:35,860 --> 00:39:40,150
to the parent process so what i'm doing

886
00:39:38,200 --> 00:39:44,169
here is i'm looking for processes that i

887
00:39:40,150 --> 00:39:47,500
own and i'm finding anything that's

888
00:39:44,170 --> 00:39:51,160
either 64-bit or 32-bit and returning it

889
00:39:47,500 --> 00:39:52,780
back to the core of this method in which

890
00:39:51,160 --> 00:39:55,270
you can then use to inject into the

891
00:39:52,780 --> 00:39:57,820
process now subsequently i've improved

892
00:39:55,270 --> 00:40:00,190
this a little bit because i got a little

893
00:39:57,820 --> 00:40:03,430
bit nervous you probably don't want to

894
00:40:00,190 --> 00:40:06,640
inject into else ass for example well

895
00:40:03,430 --> 00:40:08,890
unless you had other motivations or you

896
00:40:06,640 --> 00:40:11,529
probably don't want to inject into win

897
00:40:08,890 --> 00:40:14,290
in it dot XE unless you want to see the

898
00:40:11,530 --> 00:40:17,230
system crash horribly so you may want to

899
00:40:14,290 --> 00:40:19,480
add a little bit of extra logic into the

900
00:40:17,230 --> 00:40:24,190
code but this is just an example for you

901
00:40:19,480 --> 00:40:26,770
to play with now in the main part of our

902
00:40:24,190 --> 00:40:28,930
code find target process that we just

903
00:40:26,770 --> 00:40:31,270
looked at returns a string consisting of

904
00:40:28,930 --> 00:40:33,640
the pit the process name and the

905
00:40:31,270 --> 00:40:36,970
architecture which we can then leverage

906
00:40:33,640 --> 00:40:38,290
to choose which shell code to run and so

907
00:40:36,970 --> 00:40:40,089
we can write a little bit of code that

908
00:40:38,290 --> 00:40:42,820
separates out the pit from the

909
00:40:40,090 --> 00:40:45,250
architecture from the process just a

910
00:40:42,820 --> 00:40:48,760
little side note here the process class

911
00:40:45,250 --> 00:40:51,610
in system Diagnostics of dotnet does not

912
00:40:48,760 --> 00:40:54,310
include the dot XE extension in the

913
00:40:51,610 --> 00:40:56,680
process thought process name attribute

914
00:40:54,310 --> 00:40:58,990
and so you notice here i'm adding the

915
00:40:56,680 --> 00:41:00,850
extension of dot exe onto it not that

916
00:40:58,990 --> 00:41:02,350
that really matters just be aware of it

917
00:41:00,850 --> 00:41:05,049
if you're looking for a process and

918
00:41:02,350 --> 00:41:07,180
expecting the dot XE to be on there well

919
00:41:05,050 --> 00:41:08,200
it's not so you have to you know you

920
00:41:07,180 --> 00:41:09,669
might get frustrated

921
00:41:08,200 --> 00:41:10,270
hence you'll be able to leverage my

922
00:41:09,670 --> 00:41:13,660
example

923
00:41:10,270 --> 00:41:16,600
and then I can actually make a selection

924
00:41:13,660 --> 00:41:19,390
on the shellcode that I want to inject

925
00:41:16,600 --> 00:41:22,600
based on the target architecture of the

926
00:41:19,390 --> 00:41:26,379
process that I've selected which is well

927
00:41:22,600 --> 00:41:29,259
kind of handy right and I can then go

928
00:41:26,380 --> 00:41:31,440
ahead and inject that shellcode so how

929
00:41:29,260 --> 00:41:34,119
do we actually inject into the target

930
00:41:31,440 --> 00:41:37,060
well again we probably want to convert

931
00:41:34,119 --> 00:41:39,400
our shellcode from base 64 then we want

932
00:41:37,060 --> 00:41:42,910
to create a process handle by using the

933
00:41:39,400 --> 00:41:45,130
open process API call now I've used the

934
00:41:42,910 --> 00:41:47,618
flag 0 X 0 0 0 0

935
00:41:45,130 --> 00:41:50,230
wow that's a lot of zeros 28 with the

936
00:41:47,619 --> 00:41:52,780
open process call that is opening the

937
00:41:50,230 --> 00:41:54,670
process with only a select number of

938
00:41:52,780 --> 00:41:57,670
process rights which I'm going to talk

939
00:41:54,670 --> 00:41:59,680
about on the next screen a lot of people

940
00:41:57,670 --> 00:42:02,619
choose to open the process with process

941
00:41:59,680 --> 00:42:04,270
all access but if you open the process

942
00:42:02,619 --> 00:42:06,600
with all access you've got process

943
00:42:04,270 --> 00:42:09,160
rights you really don't need to have and

944
00:42:06,600 --> 00:42:11,950
it could be seen as an indicator of

945
00:42:09,160 --> 00:42:14,560
compromise if you've got of a capable

946
00:42:11,950 --> 00:42:16,720
endpoint detection are running so I just

947
00:42:14,560 --> 00:42:19,600
open it with only the process rights

948
00:42:16,720 --> 00:42:22,529
that I need then I use virtual Alec e^x

949
00:42:19,600 --> 00:42:25,509
to allocate memory within that process I

950
00:42:22,530 --> 00:42:28,060
write the process memory with my

951
00:42:25,510 --> 00:42:31,359
shellcode into the remote process memory

952
00:42:28,060 --> 00:42:34,840
segment that I allocated I protect it as

953
00:42:31,359 --> 00:42:36,850
read execute only again and that's this

954
00:42:34,840 --> 00:42:38,830
is the same as the protect call I used

955
00:42:36,850 --> 00:42:41,920
earlier with the heap Alec example and

956
00:42:38,830 --> 00:42:44,710
then I use create remote thread which

957
00:42:41,920 --> 00:42:48,160
effectively spins up a remote thread in

958
00:42:44,710 --> 00:42:50,380
that process that I've actually

959
00:42:48,160 --> 00:42:53,319
allocated the shellcode memory in and

960
00:42:50,380 --> 00:42:55,450
created alright and in fact it turns out

961
00:42:53,320 --> 00:42:57,790
you can even free the memory so there

962
00:42:55,450 --> 00:42:59,859
must be a process going on inside of

963
00:42:57,790 --> 00:43:01,840
create remote thread that's replicating

964
00:42:59,859 --> 00:43:03,759
that shellcode because freeing the

965
00:43:01,840 --> 00:43:06,520
memory did not seem to impact the

966
00:43:03,760 --> 00:43:11,530
execution of that shellcode thread which

967
00:43:06,520 --> 00:43:14,619
is kind of cool now the different flag

968
00:43:11,530 --> 00:43:17,290
meanings that we have when we create the

969
00:43:14,619 --> 00:43:20,109
process I'm only using process create

970
00:43:17,290 --> 00:43:23,850
thread and I'm only using process VM

971
00:43:20,109 --> 00:43:26,009
operation so I'm being very selective in

972
00:43:23,850 --> 00:43:29,310
terms of only asking for the process

973
00:43:26,010 --> 00:43:32,310
rights that I exactly need when I use

974
00:43:29,310 --> 00:43:36,150
virtual Alec I'm actually using the

975
00:43:32,310 --> 00:43:39,180
memory commit option which is described

976
00:43:36,150 --> 00:43:41,100
in MSDN I won't read the entire text and

977
00:43:39,180 --> 00:43:42,810
I'm also using memory reserve which

978
00:43:41,100 --> 00:43:45,410
actually reserves that range in the

979
00:43:42,810 --> 00:43:47,670
process virtual address space without

980
00:43:45,410 --> 00:43:51,270
actually allocating any physical storage

981
00:43:47,670 --> 00:43:54,870
on the page file in disk right I'm also

982
00:43:51,270 --> 00:43:57,360
using page execute readwrite but later

983
00:43:54,870 --> 00:44:00,029
in the code I come back and I virtual

984
00:43:57,360 --> 00:44:02,940
protect changing that permission back to

985
00:44:00,030 --> 00:44:04,650
page executes read-only again that's one

986
00:44:02,940 --> 00:44:06,960
of those things I'm doing to try to fly

987
00:44:04,650 --> 00:44:09,750
under the radar a little bit although of

988
00:44:06,960 --> 00:44:11,840
course now it's very public for this

989
00:44:09,750 --> 00:44:14,400
code

990
00:44:11,840 --> 00:44:15,780
alright so awesome I'm actually running

991
00:44:14,400 --> 00:44:18,690
out of time and I had a feeling this

992
00:44:15,780 --> 00:44:20,880
would happen I have a DLL assembly I

993
00:44:18,690 --> 00:44:23,820
have three different examples example1

994
00:44:20,880 --> 00:44:27,510
example2 an example 3 that will actually

995
00:44:23,820 --> 00:44:30,600
be able to run out of this code how do

996
00:44:27,510 --> 00:44:32,910
we load and execute this DLL assembly

997
00:44:30,600 --> 00:44:36,150
this is where the living off the land

998
00:44:32,910 --> 00:44:38,540
binaries can really benefit us we've got

999
00:44:36,150 --> 00:44:40,370
three different techniques

1000
00:44:38,540 --> 00:44:42,320
that are possible in fact there are many

1001
00:44:40,370 --> 00:44:45,049
more I'm just gonna mention these three

1002
00:44:42,320 --> 00:44:46,190
techniques msbuild XE which I've already

1003
00:44:45,050 --> 00:44:48,800
talked about earlier

1004
00:44:46,190 --> 00:44:51,320
we've got installed util dot XE which is

1005
00:44:48,800 --> 00:44:53,330
also a very useful dotnet utility for

1006
00:44:51,320 --> 00:44:55,250
loading an assembly and then we can even

1007
00:44:53,330 --> 00:44:59,810
directly load an assembly in PowerShell

1008
00:44:55,250 --> 00:45:02,120
if we choose to do so let's talk about

1009
00:44:59,810 --> 00:45:05,990
msbuild this is the only meme I should

1010
00:45:02,120 --> 00:45:07,609
have got more memes alright the Golden

1011
00:45:05,990 --> 00:45:10,129
Goose a platform for building

1012
00:45:07,610 --> 00:45:12,230
applications it's included in net almost

1013
00:45:10,130 --> 00:45:14,510
always allowed to run even in

1014
00:45:12,230 --> 00:45:16,130
whitelisted environments and it has

1015
00:45:14,510 --> 00:45:18,860
these characteristics which make it

1016
00:45:16,130 --> 00:45:21,680
really awesome for use in terms of shell

1017
00:45:18,860 --> 00:45:25,220
code delivery it uses an XML schema to

1018
00:45:21,680 --> 00:45:27,799
create a project file a visual studio

1019
00:45:25,220 --> 00:45:32,330
also uses it and tasks can be developed

1020
00:45:27,800 --> 00:45:36,260
within the XML file and a task is fully

1021
00:45:32,330 --> 00:45:39,310
functional c-sharp net code awesome

1022
00:45:36,260 --> 00:45:42,920
thanks Microsoft that's fantastic so

1023
00:45:39,310 --> 00:45:47,509
what we can do inside of our msbuild

1024
00:45:42,920 --> 00:45:51,950
code is go ahead and create a task that

1025
00:45:47,510 --> 00:45:55,310
is designed to execute some code which

1026
00:45:51,950 --> 00:45:58,250
will load our assembly now there's a few

1027
00:45:55,310 --> 00:46:01,340
requirements here the class and the task

1028
00:45:58,250 --> 00:46:04,820
name have got to match the execute

1029
00:46:01,340 --> 00:46:08,150
method has to be in the XML as the code

1030
00:46:04,820 --> 00:46:10,730
entry point and it has to return true if

1031
00:46:08,150 --> 00:46:12,820
I believe correctly out of that boolean

1032
00:46:10,730 --> 00:46:16,130
return value from the execute method

1033
00:46:12,820 --> 00:46:18,260
everything else is completely up to you

1034
00:46:16,130 --> 00:46:22,190
you can go ahead and write your msbuild

1035
00:46:18,260 --> 00:46:24,380
however you want to write it now there

1036
00:46:22,190 --> 00:46:27,260
are a myriad of possibilities you could

1037
00:46:24,380 --> 00:46:29,560
choose if you wanted to to include your

1038
00:46:27,260 --> 00:46:32,570
entire shellcode delivery technique

1039
00:46:29,560 --> 00:46:33,799
inside of that msbuild file in other

1040
00:46:32,570 --> 00:46:35,750
words you could take one of my examples

1041
00:46:33,800 --> 00:46:38,900
and just put it all inside the msbuild

1042
00:46:35,750 --> 00:46:41,690
file that may be suboptimal though

1043
00:46:38,900 --> 00:46:43,790
because well you might have an issue

1044
00:46:41,690 --> 00:46:45,860
where it might get more likely to be

1045
00:46:43,790 --> 00:46:48,529
flagged by an in point detection and

1046
00:46:45,860 --> 00:46:51,860
response product or Windows Defender or

1047
00:46:48,530 --> 00:46:52,320
something like that right you could and

1048
00:46:51,860 --> 00:46:53,910
which

1049
00:46:52,320 --> 00:46:57,930
is what I'm going to show you compress

1050
00:46:53,910 --> 00:47:00,750
and base64 encode a precompiled dll

1051
00:46:57,930 --> 00:47:03,060
assembly and then construct an MS build

1052
00:47:00,750 --> 00:47:04,680
file that has that compressed dll and

1053
00:47:03,060 --> 00:47:08,460
the encrypted encoded shellcode

1054
00:47:04,680 --> 00:47:10,020
contained within it for example if you

1055
00:47:08,460 --> 00:47:13,110
wanted to encrypt that's up to you as

1056
00:47:10,020 --> 00:47:15,330
well and then write some C shop code to

1057
00:47:13,110 --> 00:47:18,480
uncompress decode the DLL and create a

1058
00:47:15,330 --> 00:47:23,850
new object for it and that's what I

1059
00:47:18,480 --> 00:47:25,880
chose to do all right so decompression

1060
00:47:23,850 --> 00:47:28,350
is a challenge

1061
00:47:25,880 --> 00:47:30,150
it's very nice first of all to be able

1062
00:47:28,350 --> 00:47:34,230
to compress the DLL because the DLL

1063
00:47:30,150 --> 00:47:36,360
tends to get pretty large base64 is also

1064
00:47:34,230 --> 00:47:39,480
extremely useful in this case so what we

1065
00:47:36,360 --> 00:47:42,660
can do is compress then base64 encode

1066
00:47:39,480 --> 00:47:45,630
and then use Nets system dot IO

1067
00:47:42,660 --> 00:47:48,420
compression deflate stream to decompress

1068
00:47:45,630 --> 00:47:51,180
this into a new buffer convert that to a

1069
00:47:48,420 --> 00:47:54,870
byte array and then go ahead and load

1070
00:47:51,180 --> 00:47:58,140
that byte array in memory as a DLL

1071
00:47:54,870 --> 00:48:00,630
assembly object so here is a method

1072
00:47:58,140 --> 00:48:04,500
which enables us to decode and

1073
00:48:00,630 --> 00:48:06,810
decompress a DLL it literally is taking

1074
00:48:04,500 --> 00:48:10,140
the encoded dll and converting it from

1075
00:48:06,810 --> 00:48:13,560
base64 using c-sharp it is creating new

1076
00:48:10,140 --> 00:48:17,670
memory streams which it then uses to

1077
00:48:13,560 --> 00:48:20,120
basically loop through the DLL

1078
00:48:17,670 --> 00:48:23,340
compression compressed object and

1079
00:48:20,120 --> 00:48:25,529
block-by-block decompress it and write

1080
00:48:23,340 --> 00:48:28,410
it into this new memory array and then

1081
00:48:25,530 --> 00:48:32,370
return essentially a byte array version

1082
00:48:28,410 --> 00:48:35,430
of that memory which gives us the

1083
00:48:32,370 --> 00:48:41,400
ability to then load that byte array as

1084
00:48:35,430 --> 00:48:43,470
a DLL in.net okay so after decoding and

1085
00:48:41,400 --> 00:48:45,060
decompressing we're going to use system

1086
00:48:43,470 --> 00:48:47,430
dot reflection dot assembly dot load

1087
00:48:45,060 --> 00:48:49,799
we're going to retrieve an object type

1088
00:48:47,430 --> 00:48:52,350
of the class name example one or two in

1089
00:48:49,800 --> 00:48:54,690
this case or maybe example three we're

1090
00:48:52,350 --> 00:48:57,330
going to create a class instance of the

1091
00:48:54,690 --> 00:48:59,940
object and then we're going to use

1092
00:48:57,330 --> 00:49:02,040
method dot invoke with the class

1093
00:48:59,940 --> 00:49:04,260
instance and the arguments to the entry

1094
00:49:02,040 --> 00:49:05,730
point method running a little short on

1095
00:49:04,260 --> 00:49:07,920
time so I'm just sort of going to

1096
00:49:05,730 --> 00:49:10,350
through this a little bit but the short

1097
00:49:07,920 --> 00:49:13,140
version of it is here here we are

1098
00:49:10,350 --> 00:49:16,440
loading the assembly after we decode and

1099
00:49:13,140 --> 00:49:20,609
decompress the DLL here we are actually

1100
00:49:16,440 --> 00:49:22,740
getting the type which is example 2 with

1101
00:49:20,609 --> 00:49:25,770
the class type we're creating an

1102
00:49:22,740 --> 00:49:28,979
instance of that class type then we are

1103
00:49:25,770 --> 00:49:32,160
retrieving the entry point and creating

1104
00:49:28,980 --> 00:49:35,460
and getting the method which is inside

1105
00:49:32,160 --> 00:49:39,660
of that DLL called run which we can then

1106
00:49:35,460 --> 00:49:41,880
invoke passing to it base64 encoded

1107
00:49:39,660 --> 00:49:46,649
shellcode now this should look somewhat

1108
00:49:41,880 --> 00:49:47,940
familiar because in the other instance

1109
00:49:46,650 --> 00:49:50,340
you know when we were testing the

1110
00:49:47,940 --> 00:49:53,970
shellcode we also had this idea of an

1111
00:49:50,340 --> 00:49:56,040
entry point and using the run method to

1112
00:49:53,970 --> 00:49:57,959
actually invoke the shellcode so we're

1113
00:49:56,040 --> 00:50:00,359
really just doing the same thing we're

1114
00:49:57,960 --> 00:50:06,119
loading the DLL in this case though from

1115
00:50:00,359 --> 00:50:08,040
a variable inside of the XML file right

1116
00:50:06,119 --> 00:50:09,900
I want to show you I'm gonna skip over

1117
00:50:08,040 --> 00:50:10,410
the install util we can look at this

1118
00:50:09,900 --> 00:50:12,570
later

1119
00:50:10,410 --> 00:50:14,069
I'm gonna show you a quick example of

1120
00:50:12,570 --> 00:50:17,130
the msbuild

1121
00:50:14,070 --> 00:50:18,210
here is a full working example and I'm

1122
00:50:17,130 --> 00:50:21,270
just going to point out the highlights

1123
00:50:18,210 --> 00:50:24,840
here this is a fully compressed and

1124
00:50:21,270 --> 00:50:29,160
encoded DLL okay this is the output of

1125
00:50:24,840 --> 00:50:31,200
the compilation of the example one or

1126
00:50:29,160 --> 00:50:34,980
example two this one in particular is

1127
00:50:31,200 --> 00:50:39,480
example one this is the same MSF venom

1128
00:50:34,980 --> 00:50:41,910
shellcode okay x86 shellcode this is the

1129
00:50:39,480 --> 00:50:45,510
64 bit version of the MSF venom

1130
00:50:41,910 --> 00:50:47,549
shellcode no surprises there this is the

1131
00:50:45,510 --> 00:50:50,190
decode and decompression method which

1132
00:50:47,550 --> 00:50:53,700
allows us to uncompress and decode the

1133
00:50:50,190 --> 00:50:57,000
DLL and then this is the actual execute

1134
00:50:53,700 --> 00:50:59,720
method in the MS build which loads up

1135
00:50:57,000 --> 00:51:02,270
that decompressed the ll performs the

1136
00:50:59,720 --> 00:51:06,140
acquisition of the class name and the

1137
00:51:02,270 --> 00:51:09,500
method to use and then literally calls

1138
00:51:06,140 --> 00:51:11,910
the invoke method on that particular

1139
00:51:09,500 --> 00:51:15,300
method that was retrieved with the

1140
00:51:11,910 --> 00:51:18,000
shellcode variables and you will find in

1141
00:51:15,300 --> 00:51:19,650
fact I'll just go ahead and show you not

1142
00:51:18,000 --> 00:51:22,020
that this is going to be Patek

1143
00:51:19,650 --> 00:51:25,050
really exciting but you will find that

1144
00:51:22,020 --> 00:51:28,800
this will indeed execute the shellcode

1145
00:51:25,050 --> 00:51:31,980
now I'm going to examine demonstrate

1146
00:51:28,800 --> 00:51:35,250
should I say both options so I'm running

1147
00:51:31,980 --> 00:51:37,950
it first with 32-bit msbuild and you can

1148
00:51:35,250 --> 00:51:42,720
see that when I run this I get a

1149
00:51:37,950 --> 00:51:46,799
calculator surprise right and when I run

1150
00:51:42,720 --> 00:51:48,859
the 64-bit version of example one by

1151
00:51:46,800 --> 00:51:51,420
just putting framework 64 in the path

1152
00:51:48,860 --> 00:51:52,350
the code is smart enough to understand

1153
00:51:51,420 --> 00:51:54,870
the architecture

1154
00:51:52,350 --> 00:51:56,819
did you notice here how there were 413

1155
00:51:54,870 --> 00:51:59,460
bytes of payload that it displayed it

1156
00:51:56,820 --> 00:52:03,480
was copying because the 64-bit payload

1157
00:51:59,460 --> 00:52:05,790
is slightly bigger than the 32-bit

1158
00:52:03,480 --> 00:52:07,320
payload that we actually executed in

1159
00:52:05,790 --> 00:52:10,500
memory okay

1160
00:52:07,320 --> 00:52:12,540
so this works really well we can do the

1161
00:52:10,500 --> 00:52:15,390
same thing with example 3 which is

1162
00:52:12,540 --> 00:52:17,130
targeting a remote process and you can

1163
00:52:15,390 --> 00:52:18,960
see we're popping calculators all over

1164
00:52:17,130 --> 00:52:22,170
the pace of my calculator diet that's a

1165
00:52:18,960 --> 00:52:25,350
shame this particular one tried to

1166
00:52:22,170 --> 00:52:29,400
inject into application frame host as a

1167
00:52:25,350 --> 00:52:31,290
64-bit process we can inject into maybe

1168
00:52:29,400 --> 00:52:34,020
a 32-bit process using the original

1169
00:52:31,290 --> 00:52:36,270
framework this one injected into perf

1170
00:52:34,020 --> 00:52:38,430
Watson - awesome

1171
00:52:36,270 --> 00:52:42,450
right and we have a calculator running

1172
00:52:38,430 --> 00:52:47,299
all right so these techniques work and

1173
00:52:42,450 --> 00:52:50,189
they're useful and furthermore we can

1174
00:52:47,300 --> 00:52:54,360
extend them to different dotnet

1175
00:52:50,190 --> 00:52:58,140
utilities install util also allows us to

1176
00:52:54,360 --> 00:53:01,110
load a dotnet object into memory you

1177
00:52:58,140 --> 00:53:05,190
just need to supply an additional method

1178
00:53:01,110 --> 00:53:07,500
so in Visual Studio we can go down to

1179
00:53:05,190 --> 00:53:10,530
the bottom here and I created a

1180
00:53:07,500 --> 00:53:13,110
namespace called my installer in my

1181
00:53:10,530 --> 00:53:15,960
installer uses this run installer

1182
00:53:13,110 --> 00:53:18,840
attribute and actually has an install

1183
00:53:15,960 --> 00:53:21,540
and an uninstall method and literally

1184
00:53:18,840 --> 00:53:25,620
these are built so that we can use

1185
00:53:21,540 --> 00:53:28,320
install util as a delivery tool and the

1186
00:53:25,620 --> 00:53:31,680
install util will call either the

1187
00:53:28,320 --> 00:53:33,699
install or the uninstall method for the

1188
00:53:31,680 --> 00:53:35,919
options that you are

1189
00:53:33,699 --> 00:53:39,189
pass to the install util on the command

1190
00:53:35,919 --> 00:53:41,609
line so I mean goes without saying I

1191
00:53:39,189 --> 00:53:44,609
could demonstrate this I suppose I will

1192
00:53:41,609 --> 00:53:48,848
let's try it

1193
00:53:44,609 --> 00:53:50,558
install util and then for the install

1194
00:53:48,849 --> 00:53:52,779
you till we actually have to pick the

1195
00:53:50,559 --> 00:53:55,599
DLL this is where live demos can go

1196
00:53:52,779 --> 00:53:59,669
horribly wrong so we'll pick the DLL

1197
00:53:55,599 --> 00:54:03,640
itself and a calculator pops up right

1198
00:53:59,669 --> 00:54:06,009
awesome page off yeah we just got a

1199
00:54:03,640 --> 00:54:08,078
question from the people that are

1200
00:54:06,009 --> 00:54:09,699
watching this if hackers are so good at

1201
00:54:08,079 --> 00:54:14,199
math how come they always pop

1202
00:54:09,699 --> 00:54:18,999
calculators I love it what a great

1203
00:54:14,199 --> 00:54:22,059
question because a calculator is kind of

1204
00:54:18,999 --> 00:54:24,788
harmless I suppose I don't know what the

1205
00:54:22,059 --> 00:54:27,130
right answer to that is but very good

1206
00:54:24,789 --> 00:54:29,079
question I very enjoyable we can make

1207
00:54:27,130 --> 00:54:31,689
that kind of a challenge in the chat if

1208
00:54:29,079 --> 00:54:34,149
you can think of witty sort of punch

1209
00:54:31,689 --> 00:54:37,299
line to that joke kind of why did the

1210
00:54:34,149 --> 00:54:38,739
chicken cross the road you know type in

1211
00:54:37,299 --> 00:54:40,449
what you think your witty response would

1212
00:54:38,739 --> 00:54:41,649
be if somebody said if hackers are so

1213
00:54:40,449 --> 00:54:45,209
good at math why they're popping

1214
00:54:41,649 --> 00:54:48,279
calculators that's right that's right so

1215
00:54:45,209 --> 00:54:50,019
of course you're probably going to put

1216
00:54:48,279 --> 00:54:52,329
some sort of encoded cobalt strike

1217
00:54:50,019 --> 00:54:54,339
beacon a shell code into your code

1218
00:54:52,329 --> 00:54:55,689
rather than popping a calculator unless

1219
00:54:54,339 --> 00:54:58,689
you just want to show off with a

1220
00:54:55,689 --> 00:55:00,759
calculator or notepad I've used dope pad

1221
00:54:58,689 --> 00:55:03,908
just for the record

1222
00:55:00,759 --> 00:55:05,709
but anyway okay so we can do that we can

1223
00:55:03,909 --> 00:55:09,619
take this even further and this is a

1224
00:55:05,709 --> 00:55:13,430
technique that I actually showed on

1225
00:55:09,619 --> 00:55:15,529
on our last sacred cash cow tipping

1226
00:55:13,430 --> 00:55:18,019
where you can load the object directly

1227
00:55:15,529 --> 00:55:21,529
with PowerShell this is kind of cool you

1228
00:55:18,019 --> 00:55:24,890
can use system dot reflection dot

1229
00:55:21,529 --> 00:55:29,089
assembly and you actually can use the

1230
00:55:24,890 --> 00:55:30,618
load file or load from method the only

1231
00:55:29,089 --> 00:55:34,869
challenge is you have to use a full path

1232
00:55:30,619 --> 00:55:40,160
name here so you : met with dev talk

1233
00:55:34,869 --> 00:55:43,339
example one been lease god this is

1234
00:55:40,160 --> 00:55:46,220
horrible example 1 dot DLL so if I load

1235
00:55:43,339 --> 00:55:48,589
that assembly into memory I can then do

1236
00:55:46,220 --> 00:55:51,740
something really cool and leverage the

1237
00:55:48,589 --> 00:55:54,950
class name of the install util stuff to

1238
00:55:51,740 --> 00:55:57,410
create a new object which is I think is

1239
00:55:54,950 --> 00:56:01,129
kind of neat so I can say a equals new

1240
00:55:57,410 --> 00:56:03,859
object and I can say my installer dot my

1241
00:56:01,130 --> 00:56:06,380
installer which was the method if you

1242
00:56:03,859 --> 00:56:08,509
remember in the C shot code the

1243
00:56:06,380 --> 00:56:12,109
namespace is my installer and the class

1244
00:56:08,509 --> 00:56:17,299
is my installer and then we can do this

1245
00:56:12,109 --> 00:56:19,700
a dot invoke or install sorry and pass

1246
00:56:17,299 --> 00:56:21,799
it just an empty dictionary because the

1247
00:56:19,700 --> 00:56:25,279
install method requires a dictionary and

1248
00:56:21,799 --> 00:56:29,839
guess what we pop a calculator all right

1249
00:56:25,279 --> 00:56:31,640
awesome so you know these these are some

1250
00:56:29,839 --> 00:56:33,529
really cool techniques that you can use

1251
00:56:31,640 --> 00:56:35,410
to actually get shellcode in a memory

1252
00:56:33,529 --> 00:56:38,200
even though it is a boring calculator

1253
00:56:35,410 --> 00:56:40,578
demo time we've already talked about

1254
00:56:38,200 --> 00:56:43,759
from an invasion of Defense's

1255
00:56:40,579 --> 00:56:45,440
perspective yeah your unencoded shell

1256
00:56:43,759 --> 00:56:47,900
code inside of a dll is going to get

1257
00:56:45,440 --> 00:56:49,759
busted right but you guys have ways you

1258
00:56:47,900 --> 00:56:51,680
can fix that and you're all very

1259
00:56:49,759 --> 00:56:54,099
creative people right I'm sure you can

1260
00:56:51,680 --> 00:56:56,930
Excel the things or rot13 or whatever

1261
00:56:54,099 --> 00:56:59,779
your msbuild xml that loads are dot

1262
00:56:56,930 --> 00:57:03,140
Nelnet object might well get caught all

1263
00:56:59,779 --> 00:57:04,819
right so yeah that's funny John hackers

1264
00:57:03,140 --> 00:57:07,788
use calc to divide and conquer that's

1265
00:57:04,819 --> 00:57:10,339
awesome very woody all right the DLL

1266
00:57:07,789 --> 00:57:11,930
assembly files you create will probably

1267
00:57:10,339 --> 00:57:14,299
get uploaded to virustotal

1268
00:57:11,930 --> 00:57:15,529
no big surprise right that's going to

1269
00:57:14,299 --> 00:57:17,960
happen

1270
00:57:15,530 --> 00:57:20,030
so make your DLL different each time I

1271
00:57:17,960 --> 00:57:23,780
think you can probably accomplish that

1272
00:57:20,030 --> 00:57:25,160
right so trivial to use an excel

1273
00:57:23,780 --> 00:57:27,920
function if you want to encode your

1274
00:57:25,160 --> 00:57:31,790
shellcode and just decode it in the in

1275
00:57:27,920 --> 00:57:33,500
another excellent inside of your inside

1276
00:57:31,790 --> 00:57:35,570
of your source code right

1277
00:57:33,500 --> 00:57:37,520
you can certainly choose to encode the

1278
00:57:35,570 --> 00:57:39,410
shellcode with MSF fennan but I already

1279
00:57:37,520 --> 00:57:41,180
gave you the warning about the assembly

1280
00:57:39,410 --> 00:57:43,609
stub that decodes and right back to the

1281
00:57:41,180 --> 00:57:45,230
same memory segment and you might run

1282
00:57:43,610 --> 00:57:49,850
into trouble there so be aware of that

1283
00:57:45,230 --> 00:57:52,280
one source code obfuscation something

1284
00:57:49,850 --> 00:57:55,040
I've noticed certainly from the msbuild

1285
00:57:52,280 --> 00:57:57,830
case and I'd love to hear Microsoft's

1286
00:57:55,040 --> 00:58:00,140
point of view on this actually highly

1287
00:57:57,830 --> 00:58:04,400
pseudo-random names in source code of

1288
00:58:00,140 --> 00:58:06,740
msbuild xml's tend to be looked upon as

1289
00:58:04,400 --> 00:58:10,810
suspicious these days or at least from

1290
00:58:06,740 --> 00:58:13,069
anecdotal testing that's my evidence so

1291
00:58:10,810 --> 00:58:16,910
maybe use something different like

1292
00:58:13,070 --> 00:58:19,280
English words okay you can alias in

1293
00:58:16,910 --> 00:58:23,210
source code inside of the dotnet

1294
00:58:19,280 --> 00:58:25,400
compilation itself if you want using

1295
00:58:23,210 --> 00:58:28,460
funny word equals system using another

1296
00:58:25,400 --> 00:58:31,550
funny word equals system Diagnostics and

1297
00:58:28,460 --> 00:58:32,440
you can do this inside the msbuild XML

1298
00:58:31,550 --> 00:58:35,300
as well

1299
00:58:32,440 --> 00:58:38,240
you can add some time to nice if you

1300
00:58:35,300 --> 00:58:39,800
want manual delays in the code perhaps

1301
00:58:38,240 --> 00:58:41,750
make some method for calculating

1302
00:58:39,800 --> 00:58:43,730
something intensive I don't know

1303
00:58:41,750 --> 00:58:46,190
calculate a fractal or something right

1304
00:58:43,730 --> 00:58:48,140
throw in code that makes it look more

1305
00:58:46,190 --> 00:58:51,230
attractive to people reversing right

1306
00:58:48,140 --> 00:58:53,839
Chum the water so to speak I think

1307
00:58:51,230 --> 00:58:56,330
that's kind of fun REE parenting to a

1308
00:58:53,840 --> 00:58:57,590
suspect are to reap Aron ting sorry as

1309
00:58:56,330 --> 00:58:59,690
suspended process that you're

1310
00:58:57,590 --> 00:59:01,400
manipulating unfortunately I don't have

1311
00:58:59,690 --> 00:59:01,700
a sample piece of code for you on that

1312
00:59:01,400 --> 00:59:03,290
one

1313
00:59:01,700 --> 00:59:04,970
but if you go out and do a little

1314
00:59:03,290 --> 00:59:09,320
research I'm sure that you will find

1315
00:59:04,970 --> 00:59:11,689
some interesting things there also just

1316
00:59:09,320 --> 00:59:14,750
write some sort of method that generates

1317
00:59:11,690 --> 00:59:16,640
random c-sharp code why not just throw a

1318
00:59:14,750 --> 00:59:21,680
bunch of random stuff in there for fun

1319
00:59:16,640 --> 00:59:23,270
all right final tips in developing your

1320
00:59:21,680 --> 00:59:27,440
malware and I'm coming right up on the

1321
00:59:23,270 --> 00:59:29,090
hour please think about containment when

1322
00:59:27,440 --> 00:59:31,630
you're doing malware

1323
00:59:29,090 --> 00:59:34,460
what I like to do is program in a

1324
00:59:31,630 --> 00:59:37,640
configurable shelf-life such as an

1325
00:59:34,460 --> 00:59:40,040
expiry date maybe 30 days on and then

1326
00:59:37,640 --> 00:59:42,529
have the DLL automatically exit or

1327
00:59:40,040 --> 00:59:45,320
destroy itself or whatever works for you

1328
00:59:42,530 --> 00:59:47,900
if the expiry date is passed because

1329
00:59:45,320 --> 00:59:50,840
well you know when you're red teaming

1330
00:59:47,900 --> 00:59:54,620
when your pen testing you're not an

1331
00:59:50,840 --> 00:59:56,120
attacker in the true orange jumpsuit

1332
00:59:54,620 --> 00:59:58,130
sense of the word even though some

1333
00:59:56,120 --> 00:59:59,930
people think we are and so you need to

1334
00:59:58,130 --> 01:00:01,670
be a little bit responsible right so

1335
00:59:59,930 --> 01:00:04,069
having an expiry date some sort of

1336
01:00:01,670 --> 01:00:05,900
self-destruction is very useful you can

1337
01:00:04,070 --> 01:00:08,600
restrict your malware execution to a

1338
01:00:05,900 --> 01:00:10,940
specific domain or perhaps a specific

1339
01:00:08,600 --> 01:00:15,230
username if you wanted to go that deep

1340
01:00:10,940 --> 01:00:17,570
the the dotnet calls to do that are very

1341
01:00:15,230 --> 01:00:21,050
much readily available and very easy to

1342
01:00:17,570 --> 01:00:25,790
look up from a defense perspective in an

1343
01:00:21,050 --> 01:00:27,410
environment what I found very useful in

1344
01:00:25,790 --> 01:00:30,140
most of my customers that we're

1345
01:00:27,410 --> 01:00:32,060
consulting with is some group policy

1346
01:00:30,140 --> 01:00:34,400
restrictions on some of these common

1347
01:00:32,060 --> 01:00:37,009
living off the land binaries do your

1348
01:00:34,400 --> 01:00:41,560
regular users really need to run in

1349
01:00:37,010 --> 01:00:44,420
install util or reg ASM for example or

1350
01:00:41,560 --> 01:00:46,700
msbuild XE I mean they really don't

1351
01:00:44,420 --> 01:00:49,010
write things like user behavior

1352
01:00:46,700 --> 01:00:50,930
analytics is certainly useful do your

1353
01:00:49,010 --> 01:00:53,060
users even need to run a powershell for

1354
01:00:50,930 --> 01:00:55,339
that matter or cmd.exe there's a lot of

1355
01:00:53,060 --> 01:00:58,100
things that can be done here C -

1356
01:00:55,340 --> 01:00:59,840
communication - techniques detection

1357
01:00:58,100 --> 01:01:03,529
techniques sorry I'm things like

1358
01:00:59,840 --> 01:01:06,650
shameless plug here AI hunter and rita

1359
01:01:03,530 --> 01:01:08,630
which is part of things that the active

1360
01:01:06,650 --> 01:01:11,600
countermeasures folks at but black holes

1361
01:01:08,630 --> 01:01:13,330
sister company are doing you can also

1362
01:01:11,600 --> 01:01:15,440
have a little bit of sport with

1363
01:01:13,330 --> 01:01:17,450
defenders and analysts right

1364
01:01:15,440 --> 01:01:19,040
maybe program your malware to do

1365
01:01:17,450 --> 01:01:20,839
something completely different in a

1366
01:01:19,040 --> 01:01:24,350
virtual machine because why not

1367
01:01:20,840 --> 01:01:26,570
that would be kind of fun right alright

1368
01:01:24,350 --> 01:01:28,279
so I'm gonna stop talking I am exhausted

1369
01:01:26,570 --> 01:01:29,660
I've been talking a thousand miles a

1370
01:01:28,280 --> 01:01:32,450
minute I knew I had too much material

1371
01:01:29,660 --> 01:01:34,790
but it was hard not to present this

1372
01:01:32,450 --> 01:01:36,859
stuff because I've been working as John

1373
01:01:34,790 --> 01:01:39,860
knows really hard on some cool

1374
01:01:36,860 --> 01:01:41,780
techniques and I wanted to just talk

1375
01:01:39,860 --> 01:01:42,980
about a little bit of stuff here for you

1376
01:01:41,780 --> 01:01:45,619
guys to be

1377
01:01:42,980 --> 01:01:48,230
leverage some of the work we're doing in

1378
01:01:45,619 --> 01:01:51,590
and consider other techniques in terms

1379
01:01:48,230 --> 01:01:55,820
of intrusion ops in that initial stage

1380
01:01:51,590 --> 01:01:59,270
of red teaming those of you that are in

1381
01:01:55,820 --> 01:02:02,030
Chris Francis class I probably seen some

1382
01:01:59,270 --> 01:02:05,060
of this material already chris is a good

1383
01:02:02,030 --> 01:02:06,800
friend we talked a lot and we certainly

1384
01:02:05,060 --> 01:02:09,290
have shared information

1385
01:02:06,800 --> 01:02:12,050
you know subti is also really really

1386
01:02:09,290 --> 01:02:14,720
active in this area as well there's lots

1387
01:02:12,050 --> 01:02:17,030
of great material out there first of all

1388
01:02:14,720 --> 01:02:19,700
I'm making my entire malware dev talk

1389
01:02:17,030 --> 01:02:22,550
get repo with those three examples

1390
01:02:19,700 --> 01:02:24,439
freely available to you so please go

1391
01:02:22,550 --> 01:02:29,450
check that out download it and play with

1392
01:02:24,440 --> 01:02:31,850
it the the lol bass project is extremely

1393
01:02:29,450 --> 01:02:34,430
useful for reading up on these

1394
01:02:31,850 --> 01:02:37,970
techniques last year at blackhat there

1395
01:02:34,430 --> 01:02:39,770
was an extremely great talk about all of

1396
01:02:37,970 --> 01:02:41,839
the legitimate process injection

1397
01:02:39,770 --> 01:02:44,720
techniques and there's a PDF on that

1398
01:02:41,840 --> 01:02:46,910
that I highly recommend you reading if

1399
01:02:44,720 --> 01:02:49,669
you're interested in this area and then

1400
01:02:46,910 --> 01:02:53,240
finally there's an Associated C++

1401
01:02:49,670 --> 01:02:55,820
project called panchetta which actually

1402
01:02:53,240 --> 01:02:59,209
implements examples of many of these

1403
01:02:55,820 --> 01:03:01,190
techniques as well and final question is

1404
01:02:59,210 --> 01:03:04,040
a bit of a poll I'm thinking pretty

1405
01:03:01,190 --> 01:03:05,990
seriously of expanding this material

1406
01:03:04,040 --> 01:03:08,270
into kind of an advanced malware a two

1407
01:03:05,990 --> 01:03:09,919
day training class I'd love for you to

1408
01:03:08,270 --> 01:03:12,770
weigh in on that I don't know whether we

1409
01:03:09,920 --> 01:03:15,890
have the ability to do a poll we would

1410
01:03:12,770 --> 01:03:17,660
love to do that we should do is if

1411
01:03:15,890 --> 01:03:20,910
you're interested in a class just type

1412
01:03:17,660 --> 01:03:23,040
class into the questions

1413
01:03:20,910 --> 01:03:24,540
Boulder are in the questions box and

1414
01:03:23,040 --> 01:03:26,880
then we'll kind of collect that get that

1415
01:03:24,540 --> 01:03:28,560
back to Java kind of the way we collect

1416
01:03:26,880 --> 01:03:28,920
demos and all those different things as

1417
01:03:28,560 --> 01:03:30,450
well

1418
01:03:28,920 --> 01:03:32,160
but I think that this would be cool

1419
01:03:30,450 --> 01:03:34,770
right like I think what you've covered

1420
01:03:32,160 --> 01:03:36,600
in this presentation in like an hour is

1421
01:03:34,770 --> 01:03:38,430
literally what you would cover in an

1422
01:03:36,600 --> 01:03:40,410
entire day with like labs and

1423
01:03:38,430 --> 01:03:42,990
step-by-step even down to explanations

1424
01:03:40,410 --> 01:03:45,000
and everything so I think it would I

1425
01:03:42,990 --> 01:03:47,430
think it would be a very cool class God

1426
01:03:45,000 --> 01:03:49,170
knows I would take it because I'd like

1427
01:03:47,430 --> 01:03:50,850
to sit there one percent pretend oh yeah

1428
01:03:49,170 --> 01:03:53,640
I know everything Jobs talking about no

1429
01:03:50,850 --> 01:03:55,470
I don't it didn't involve PowerPoint and

1430
01:03:53,640 --> 01:03:56,700
how to set up powerpoints so it's

1431
01:03:55,470 --> 01:03:59,009
probably a little bit out of my league

1432
01:03:56,700 --> 01:04:00,299
these days but yeah if you guys think

1433
01:03:59,010 --> 01:04:02,190
that it would be a cool class just type

1434
01:04:00,300 --> 01:04:04,530
in class and we can definitely make that

1435
01:04:02,190 --> 01:04:07,260
happen so I'm very encouraged I'm seeing

1436
01:04:04,530 --> 01:04:10,530
a lot of class responses so much

1437
01:04:07,260 --> 01:04:14,340
appreciated you've just got a like super

1438
01:04:10,530 --> 01:04:17,610
super fast version of more or less about

1439
01:04:14,340 --> 01:04:20,280
four months of my brain so the class

1440
01:04:17,610 --> 01:04:23,070
would turn into a much deeper look at

1441
01:04:20,280 --> 01:04:24,990
that work that I've been doing and I

1442
01:04:23,070 --> 01:04:28,620
would be really excited to share that

1443
01:04:24,990 --> 01:04:31,350
with people so I I'm really this is

1444
01:04:28,620 --> 01:04:33,750
something I do really excited about

1445
01:04:31,350 --> 01:04:35,610
doing and to turn that into a class

1446
01:04:33,750 --> 01:04:37,650
would would be absolutely pleasure and

1447
01:04:35,610 --> 01:04:40,440
I'd love to see folks being a part of

1448
01:04:37,650 --> 01:04:42,000
that and really digging deeper in in

1449
01:04:40,440 --> 01:04:44,040
getting into you know more of these

1450
01:04:42,000 --> 01:04:46,070
techniques and having a good time with

1451
01:04:44,040 --> 01:04:46,070
it

