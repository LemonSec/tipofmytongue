1
00:00:14,269 --> 00:00:20,450
so let's talk about service compute how

2
00:00:17,600 --> 00:00:23,930
many people use service compute in some

3
00:00:20,450 --> 00:00:27,619
form or another today Wow about half the

4
00:00:23,930 --> 00:00:31,340
room so if you don't use service compute

5
00:00:27,619 --> 00:00:33,830
today we're talking about sort of pure

6
00:00:31,340 --> 00:00:37,100
service offerings that you write some

7
00:00:33,830 --> 00:00:38,780
code you upload it to a sandbox of some

8
00:00:37,100 --> 00:00:41,480
kind you don't get a lot of visibility

9
00:00:38,780 --> 00:00:43,820
into how that code is executed and you

10
00:00:41,480 --> 00:00:45,260
get the return of that code there's

11
00:00:43,820 --> 00:00:47,900
other things that people label as server

12
00:00:45,260 --> 00:00:51,799
less like sqs or s3 we're not talking

13
00:00:47,900 --> 00:00:53,809
about those so these are what people

14
00:00:51,799 --> 00:00:56,360
refer to as ephemeral runtimes which

15
00:00:53,809 --> 00:00:59,989
means that they sort of come into being

16
00:00:56,360 --> 00:01:02,839
your code executes and then that that

17
00:00:59,989 --> 00:01:08,390
environment sometimes it's container is

18
00:01:02,839 --> 00:01:10,850
gone shortly thereafter so why use the

19
00:01:08,390 --> 00:01:12,470
service thing at all the primary reason

20
00:01:10,850 --> 00:01:14,839
that most people go to service compute

21
00:01:12,470 --> 00:01:17,210
is actually parallelism because in an

22
00:01:14,840 --> 00:01:20,750
environment like AWS lambda more or less

23
00:01:17,210 --> 00:01:23,020
you have nearly infinite scale fan-out

24
00:01:20,750 --> 00:01:26,240
pattern style programming is very easy

25
00:01:23,020 --> 00:01:28,460
and most programming models for it are

26
00:01:26,240 --> 00:01:30,679
event-driven and you can hook automatic

27
00:01:28,460 --> 00:01:33,380
events up to other things in your cloud

28
00:01:30,679 --> 00:01:35,799
environment in theory this has more

29
00:01:33,380 --> 00:01:38,749
security features than your standard

30
00:01:35,799 --> 00:01:40,429
thick server high availability is really

31
00:01:38,749 --> 00:01:42,380
simple largely because you as a consumer

32
00:01:40,429 --> 00:01:44,539
don't have to manage it

33
00:01:42,380 --> 00:01:46,640
it has enforce architecture patterns and

34
00:01:44,539 --> 00:01:50,569
little to no management for your ops

35
00:01:46,640 --> 00:01:52,729
team so another way I like to put that

36
00:01:50,569 --> 00:01:56,359
though is that server list is really

37
00:01:52,729 --> 00:01:59,899
hope by you right you're putting a lot

38
00:01:56,359 --> 00:02:03,079
of trust in the vendor to sort of do all

39
00:01:59,899 --> 00:02:07,969
the right things and I don't always

40
00:02:03,079 --> 00:02:10,489
necessarily like to trust vendors but we

41
00:02:07,969 --> 00:02:12,049
hope some set of things about the these

42
00:02:10,490 --> 00:02:14,390
service environments these are kind of

43
00:02:12,050 --> 00:02:15,800
the rules of server lists that we

44
00:02:14,390 --> 00:02:18,440
believe should always be true we hope

45
00:02:15,800 --> 00:02:19,790
there are code executes securely we hope

46
00:02:18,440 --> 00:02:21,829
that people can't tamper with the

47
00:02:19,790 --> 00:02:23,269
execution of that code we hope that the

48
00:02:21,830 --> 00:02:25,700
vendor is patching the underlying

49
00:02:23,270 --> 00:02:27,450
operating system we hope that our code

50
00:02:25,700 --> 00:02:29,250
hasn't been modified in transit

51
00:02:27,450 --> 00:02:31,530
the sandbox and we hope that this is

52
00:02:29,250 --> 00:02:33,750
somehow actually more secure than

53
00:02:31,530 --> 00:02:35,340
running our own servers because maybe

54
00:02:33,750 --> 00:02:38,790
we're actually pretty good at that

55
00:02:35,340 --> 00:02:40,019
sometimes so the things I hope you'll

56
00:02:38,790 --> 00:02:41,730
take away from this talk is how

57
00:02:40,019 --> 00:02:45,110
different vendors implement their

58
00:02:41,730 --> 00:02:47,940
sandbox so this is isolation technology

59
00:02:45,110 --> 00:02:49,800
really attack patterns and techniques

60
00:02:47,940 --> 00:02:52,079
for persisting in various environments

61
00:02:49,800 --> 00:02:55,319
and how to build your own test tools to

62
00:02:52,080 --> 00:02:58,590
sort of hack around in the sandbox this

63
00:02:55,319 --> 00:03:00,750
is the hacking part of the talk most

64
00:02:58,590 --> 00:03:02,910
importantly I hope that you'll walk away

65
00:03:00,750 --> 00:03:04,680
sort of answering the question should

66
00:03:02,910 --> 00:03:08,010
you use this at all or should you avoid

67
00:03:04,680 --> 00:03:10,470
it entirely so things you won't learn in

68
00:03:08,010 --> 00:03:12,630
this talk because I didn't do them is

69
00:03:10,470 --> 00:03:15,750
kernel level exploits I don't have any

70
00:03:12,630 --> 00:03:18,599
you also won't see a container escape to

71
00:03:15,750 --> 00:03:20,700
the AWS hypervisor because if I had done

72
00:03:18,599 --> 00:03:26,640
that I would be selling it somewhere and

73
00:03:20,700 --> 00:03:28,380
not talking here so we'll look at some

74
00:03:26,640 --> 00:03:30,480
Python in this because python is a

75
00:03:28,380 --> 00:03:32,549
primary language I write in we'll look

76
00:03:30,480 --> 00:03:35,069
at a little bit of nodejs which makes me

77
00:03:32,549 --> 00:03:41,160
sad and we'll also look at some I am

78
00:03:35,069 --> 00:03:42,660
policy docs a quick favor though you

79
00:03:41,160 --> 00:03:44,130
need to remember that when we talk about

80
00:03:42,660 --> 00:03:46,290
the initial attack vector for the

81
00:03:44,130 --> 00:03:48,359
environments it's that it's bad code so

82
00:03:46,290 --> 00:03:50,459
we assume some sort of contrived

83
00:03:48,359 --> 00:03:53,010
vulnerability initially to get into the

84
00:03:50,459 --> 00:03:54,870
environment because we assume that at

85
00:03:53,010 --> 00:03:56,340
some point you will make a mistake and

86
00:03:54,870 --> 00:03:58,380
some bad code will get introduced into

87
00:03:56,340 --> 00:03:59,730
your environment and you will have sqli

88
00:03:58,380 --> 00:04:02,700
or an RCE

89
00:03:59,730 --> 00:04:04,350
because this happens despite your best

90
00:04:02,700 --> 00:04:06,959
efforts all your static analysis all

91
00:04:04,350 --> 00:04:10,440
your quality controls someday this will

92
00:04:06,959 --> 00:04:12,180
happen to you the question is how bad

93
00:04:10,440 --> 00:04:14,160
does it get like how dangerous is

94
00:04:12,180 --> 00:04:14,940
serverless compute when one of those

95
00:04:14,160 --> 00:04:18,269
RCEs

96
00:04:14,940 --> 00:04:20,010
is actually introduced so before we get

97
00:04:18,269 --> 00:04:22,470
into that let's look at who sells the

98
00:04:20,010 --> 00:04:24,570
serverless thing everybody like pretty

99
00:04:22,470 --> 00:04:26,789
much every vendor that has an interest

100
00:04:24,570 --> 00:04:29,130
in cloud has an interest in service

101
00:04:26,789 --> 00:04:30,870
because all these vendors get together

102
00:04:29,130 --> 00:04:32,250
they compete with each other and they

103
00:04:30,870 --> 00:04:33,479
seem to think that this is the future

104
00:04:32,250 --> 00:04:36,090
the way that we will interact with

105
00:04:33,479 --> 00:04:38,750
computer sources so Google compute

106
00:04:36,090 --> 00:04:41,219
engine has Google compute functions

107
00:04:38,750 --> 00:04:43,170
Asher has Asher functions

108
00:04:41,220 --> 00:04:46,860
AWS had the first market offering which

109
00:04:43,170 --> 00:04:48,990
is AWS lambda IBM vens this project

110
00:04:46,860 --> 00:04:51,330
called Apache open whisk which is

111
00:04:48,990 --> 00:04:53,280
actually pretty neat and then there's a

112
00:04:51,330 --> 00:04:56,130
couple small vendors in the space the

113
00:04:53,280 --> 00:05:00,450
most notable of which is 0 who has an

114
00:04:56,130 --> 00:05:02,280
engine called web tasks so what do

115
00:05:00,450 --> 00:05:04,140
people use serverless for probably

116
00:05:02,280 --> 00:05:06,000
nothing critical right it's brand-new

117
00:05:04,140 --> 00:05:07,440
hasn't been around a long time the

118
00:05:06,000 --> 00:05:09,990
answer is they pretty much use it for

119
00:05:07,440 --> 00:05:12,600
everything so kind of on the low risk

120
00:05:09,990 --> 00:05:15,240
side a lot of slack bots are written in

121
00:05:12,600 --> 00:05:17,370
serverless frameworks and on the high

122
00:05:15,240 --> 00:05:19,200
risk side you have things like oz0 who

123
00:05:17,370 --> 00:05:22,050
is using the web task engine to provide

124
00:05:19,200 --> 00:05:24,690
open ID connect and sam'l authentication

125
00:05:22,050 --> 00:05:29,250
for consumers and their public and

126
00:05:24,690 --> 00:05:31,350
private cloud environments so while I

127
00:05:29,250 --> 00:05:33,030
was working on this talk my boss tweeted

128
00:05:31,350 --> 00:05:34,680
at me that somebody had actually figured

129
00:05:33,030 --> 00:05:35,309
out how to run docker containers and

130
00:05:34,680 --> 00:05:38,550
userland

131
00:05:35,310 --> 00:05:40,050
inside of lambda as well so this is kind

132
00:05:38,550 --> 00:05:42,000
of the moral of the story here is that

133
00:05:40,050 --> 00:05:43,530
if you can figure out a way to sort of

134
00:05:42,000 --> 00:05:47,340
misappropriate a technology to do a

135
00:05:43,530 --> 00:05:49,440
thing you can do it and this was kind of

136
00:05:47,340 --> 00:05:51,810
my response to that which is why would

137
00:05:49,440 --> 00:05:53,100
you even want to do that because I think

138
00:05:51,810 --> 00:05:55,380
we already frankly have enough

139
00:05:53,100 --> 00:05:57,620
abstraction in these environments from

140
00:05:55,380 --> 00:06:01,260
an auditing and dfi our perspective

141
00:05:57,620 --> 00:06:03,120
because we have containers now running

142
00:06:01,260 --> 00:06:05,610
in server love sand boxes running in

143
00:06:03,120 --> 00:06:08,940
sandbox containers running in virtual

144
00:06:05,610 --> 00:06:11,790
machines on compute hosts all in the

145
00:06:08,940 --> 00:06:14,760
cloud and as somebody who started their

146
00:06:11,790 --> 00:06:19,580
career in DF IR this makes me nervous

147
00:06:14,760 --> 00:06:22,770
for some reason I can't imagine why so

148
00:06:19,580 --> 00:06:25,200
when I started working in IT this is

149
00:06:22,770 --> 00:06:27,450
what a server look like you know kind of

150
00:06:25,200 --> 00:06:28,830
like look like c-3po and sometimes they

151
00:06:27,450 --> 00:06:30,630
restart when they misbehave you turned

152
00:06:28,830 --> 00:06:34,200
it off and on again this is loads more

153
00:06:30,630 --> 00:06:36,210
complex and so I wanted to know what is

154
00:06:34,200 --> 00:06:38,370
the attack surface really of these

155
00:06:36,210 --> 00:06:40,260
things and when they're breached what

156
00:06:38,370 --> 00:06:43,320
are the potential pivots and persistence

157
00:06:40,260 --> 00:06:45,150
methods so the attack surface is

158
00:06:43,320 --> 00:06:48,120
primarily in two places right it said

159
00:06:45,150 --> 00:06:51,659
code execution time and in code pipeline

160
00:06:48,120 --> 00:06:55,530
so this is like a code corruption style

161
00:06:51,660 --> 00:06:56,940
attack so the the first way we aren't

162
00:06:55,530 --> 00:06:58,619
going to talk about much the code

163
00:06:56,940 --> 00:07:00,660
pipeline attacks because if you can own

164
00:06:58,620 --> 00:07:02,220
the code where it lives in github or

165
00:07:00,660 --> 00:07:03,990
something you pretty much own the

166
00:07:02,220 --> 00:07:06,180
environment anyway that's not very

167
00:07:03,990 --> 00:07:08,280
interesting but I do want to mention it

168
00:07:06,180 --> 00:07:10,020
because there's kind of a hot topic in

169
00:07:08,280 --> 00:07:12,989
InfoSec right now which is this concept

170
00:07:10,020 --> 00:07:14,250
of sub-domain takeovers and this is

171
00:07:12,990 --> 00:07:17,190
largely because of the way that

172
00:07:14,250 --> 00:07:19,680
technologies like Amazon s3 work where

173
00:07:17,190 --> 00:07:22,229
you might go in s3 and allocate an s3

174
00:07:19,680 --> 00:07:25,590
bucket to do a thing and the name might

175
00:07:22,229 --> 00:07:26,159
be ABC XYZ comm and if you delete that

176
00:07:25,590 --> 00:07:27,900
bucket

177
00:07:26,160 --> 00:07:30,900
somebody can immediately reallocate it

178
00:07:27,900 --> 00:07:32,400
with the same name and then if they were

179
00:07:30,900 --> 00:07:33,659
storing source code in there and there's

180
00:07:32,400 --> 00:07:35,909
some other set of things chained to it

181
00:07:33,660 --> 00:07:38,100
they can potentially pollute your

182
00:07:35,910 --> 00:07:40,349
deployment pipeline inside of the

183
00:07:38,100 --> 00:07:42,330
confines of their own account so this is

184
00:07:40,349 --> 00:07:45,090
a problem when you publish all your code

185
00:07:42,330 --> 00:07:49,260
totally in the open and these kind of

186
00:07:45,090 --> 00:07:51,119
attacks really do happen in the wild so

187
00:07:49,260 --> 00:07:53,010
the other way that you can attack this

188
00:07:51,120 --> 00:07:55,140
is actually at runtime

189
00:07:53,010 --> 00:07:58,500
which is far more interesting right so

190
00:07:55,140 --> 00:08:00,719
this is the concept in this diagram I

191
00:07:58,500 --> 00:08:03,270
have a web app represented you're

192
00:08:00,720 --> 00:08:05,789
actually attacking through Amazon API

193
00:08:03,270 --> 00:08:08,430
gateway into the lambda sandbox and then

194
00:08:05,789 --> 00:08:09,900
depending on how lacks the iam policies

195
00:08:08,430 --> 00:08:12,360
are and we know that people are bad at

196
00:08:09,900 --> 00:08:14,909
AWS I am they're getting better but it's

197
00:08:12,360 --> 00:08:16,260
still really hard you can pivot to other

198
00:08:14,910 --> 00:08:19,169
things in the environment from that

199
00:08:16,260 --> 00:08:21,270
sandbox so maybe that's not very

200
00:08:19,169 --> 00:08:23,190
interesting it's kind of all the usual

201
00:08:21,270 --> 00:08:24,330
attack techniques but it's kind of

202
00:08:23,190 --> 00:08:27,060
interesting because people are

203
00:08:24,330 --> 00:08:28,740
forklifting existing application

204
00:08:27,060 --> 00:08:30,990
workflows sort of similar to when we

205
00:08:28,740 --> 00:08:32,969
made the transition from data center to

206
00:08:30,990 --> 00:08:34,110
ec2 initially now we're making a

207
00:08:32,969 --> 00:08:36,300
transition from

208
00:08:34,110 --> 00:08:38,070
ec2 and we're taking those apps just

209
00:08:36,299 --> 00:08:41,338
like the docker container ID and we're

210
00:08:38,070 --> 00:08:43,110
shoving them into service so maybe

211
00:08:41,339 --> 00:08:45,690
there's some some unique considerations

212
00:08:43,110 --> 00:08:47,370
here that we need to know about so

213
00:08:45,690 --> 00:08:49,550
there's two things we're primarily

214
00:08:47,370 --> 00:08:52,290
concerned with when we talk about

215
00:08:49,550 --> 00:08:56,030
attacks on service environments and

216
00:08:52,290 --> 00:08:59,339
their persistence and data exfiltration

217
00:08:56,030 --> 00:09:01,410
and this goes back to all the things

218
00:08:59,339 --> 00:09:04,380
that we hope are true about service

219
00:09:01,410 --> 00:09:06,240
compute the most notable of which is

220
00:09:04,380 --> 00:09:08,130
that we believe as consumers that these

221
00:09:06,240 --> 00:09:09,930
sand boxes get thrown away

222
00:09:08,130 --> 00:09:11,400
at the end of their life we have to be

223
00:09:09,930 --> 00:09:12,540
able to take it to the bank that this

224
00:09:11,400 --> 00:09:15,420
happens in order to trust the

225
00:09:12,540 --> 00:09:16,740
environment we also believe because

226
00:09:15,420 --> 00:09:19,410
these are server lists that they have

227
00:09:16,740 --> 00:09:21,660
maximum execution runtimes and that

228
00:09:19,410 --> 00:09:23,730
should always be true - so an AWS lambda

229
00:09:21,660 --> 00:09:25,980
the limit for code execution is five

230
00:09:23,730 --> 00:09:27,720
minutes supposed to go five minutes if

231
00:09:25,980 --> 00:09:30,450
your code goes five point zero one

232
00:09:27,720 --> 00:09:34,920
minutes it should die whether it's done

233
00:09:30,450 --> 00:09:37,680
or not and then it should go away so

234
00:09:34,920 --> 00:09:39,479
five minutes is a lot of time if you

235
00:09:37,680 --> 00:09:40,560
have the right type of attack right you

236
00:09:39,480 --> 00:09:42,300
can do a lot of things in the

237
00:09:40,560 --> 00:09:45,150
environment programmatically in five

238
00:09:42,300 --> 00:09:46,589
minutes that's an issue and before we

239
00:09:45,150 --> 00:09:48,150
dive into what those things are let's

240
00:09:46,590 --> 00:09:52,800
talk about a couple other terms

241
00:09:48,150 --> 00:09:54,630
so term number one is cold start so this

242
00:09:52,800 --> 00:09:55,920
is what happens when you first execute

243
00:09:54,630 --> 00:09:58,800
some code inside of a service

244
00:09:55,920 --> 00:10:01,110
environment the provider Amazon Azure

245
00:09:58,800 --> 00:10:02,760
DCP has to allocate some compute

246
00:10:01,110 --> 00:10:05,850
resources to you they have to stream the

247
00:10:02,760 --> 00:10:09,000
code down to that container and load it

248
00:10:05,850 --> 00:10:12,720
so this takes a little bit of time it's

249
00:10:09,000 --> 00:10:15,080
about a half a second penalty each time

250
00:10:12,720 --> 00:10:17,940
that you have a cold start and so

251
00:10:15,080 --> 00:10:20,250
providers introduce this feature called

252
00:10:17,940 --> 00:10:22,440
warmness in the name of performance

253
00:10:20,250 --> 00:10:25,530
which is that if you invoke a function

254
00:10:22,440 --> 00:10:28,260
multiple times that code will actually

255
00:10:25,530 --> 00:10:31,110
stay on the compute host that was

256
00:10:28,260 --> 00:10:34,890
executing it and you may or may not be

257
00:10:31,110 --> 00:10:36,930
returned the same container so on

258
00:10:34,890 --> 00:10:39,180
subsequent executions if they happen in

259
00:10:36,930 --> 00:10:41,969
a certain time window so you can kind of

260
00:10:39,180 --> 00:10:43,609
see where I'm going with this maybe so

261
00:10:41,970 --> 00:10:47,460
the first person to talk about this

262
00:10:43,610 --> 00:10:49,260
warmness versus cold start concept was

263
00:10:47,460 --> 00:10:51,090
rich jones and he actually writes a

264
00:10:49,260 --> 00:10:53,550
service framework called the Zappa

265
00:10:51,090 --> 00:10:55,830
framework and this framework pretty much

266
00:10:53,550 --> 00:10:58,380
allows you to take a flask app or a

267
00:10:55,830 --> 00:11:01,410
django app and more or less forklifted

268
00:10:58,380 --> 00:11:03,720
into AWS lambda without having to modify

269
00:11:01,410 --> 00:11:05,610
the underlying application so he was

270
00:11:03,720 --> 00:11:07,320
doing a lot of work in lambda and he

271
00:11:05,610 --> 00:11:10,050
gives a great talk called gone in 60

272
00:11:07,320 --> 00:11:11,340
milliseconds about data exfiltration you

273
00:11:10,050 --> 00:11:15,719
should check it out I linked it in the

274
00:11:11,340 --> 00:11:17,400
slides so these environments have two

275
00:11:15,720 --> 00:11:21,500
attack surfaces they have the outer

276
00:11:17,400 --> 00:11:21,500
attack surface and inner attack surface

277
00:11:21,570 --> 00:11:26,550
on the outter attack surface side we

278
00:11:23,670 --> 00:11:28,949
have AWS API gateway this is kind of a

279
00:11:26,550 --> 00:11:30,540
black box reverse proxy you don't really

280
00:11:28,949 --> 00:11:32,490
get a lot of visibility into how it does

281
00:11:30,540 --> 00:11:33,930
what it does it costs four dollars a

282
00:11:32,490 --> 00:11:36,269
month to have it in your environment and

283
00:11:33,930 --> 00:11:39,209
it hooks up all of the routes to the

284
00:11:36,269 --> 00:11:41,550
underlying application on the inside you

285
00:11:39,209 --> 00:11:43,619
have the actual AWS lambda functions and

286
00:11:41,550 --> 00:11:45,990
then under that you have some set of

287
00:11:43,620 --> 00:11:48,029
other services which are kind of the

288
00:11:45,990 --> 00:11:49,529
chocolaty Center that as an attacker you

289
00:11:48,029 --> 00:11:51,509
want to be able to go and take over

290
00:11:49,529 --> 00:11:55,079
those other services for your

291
00:11:51,509 --> 00:11:56,910
exfiltration or persistence so when

292
00:11:55,079 --> 00:11:58,709
you're scanning for these things in the

293
00:11:56,910 --> 00:12:01,230
cloud the way that you identify that

294
00:11:58,709 --> 00:12:03,209
it's a service app might be based on

295
00:12:01,230 --> 00:12:06,480
things like HTTP headers there are some

296
00:12:03,209 --> 00:12:08,969
dead giveaways that something is running

297
00:12:06,480 --> 00:12:11,220
inside of AWS lambda this isn't like a

298
00:12:08,970 --> 00:12:14,819
smoking gun necessarily but you can look

299
00:12:11,220 --> 00:12:16,199
for the header X a.m. z CF ID which just

300
00:12:14,819 --> 00:12:18,569
pretty much indicates that something is

301
00:12:16,199 --> 00:12:21,990
coming from cloud front but API gateway

302
00:12:18,569 --> 00:12:25,259
also discloses that information so you

303
00:12:21,990 --> 00:12:26,940
can say maybe this is lambda on the off

304
00:12:25,259 --> 00:12:28,800
zero side of things in the web task

305
00:12:26,940 --> 00:12:31,589
engine it actually identifies itself in

306
00:12:28,800 --> 00:12:35,550
a header as web tasks and on the azure

307
00:12:31,589 --> 00:12:36,930
side it's just a is so we don't actually

308
00:12:35,550 --> 00:12:40,380
get any disclosure maybe it's

309
00:12:36,930 --> 00:12:43,500
intentional maybe it's not but no

310
00:12:40,380 --> 00:12:45,779
smoking gun there on the azure side you

311
00:12:43,500 --> 00:12:47,490
can also do some recon on github to see

312
00:12:45,779 --> 00:12:49,980
what apps are being deployed in service

313
00:12:47,490 --> 00:12:53,160
there's a popular framework called the

314
00:12:49,980 --> 00:12:55,680
serverless framework surprise it has a

315
00:12:53,160 --> 00:12:57,089
config file server Lestat yamo you can

316
00:12:55,680 --> 00:12:58,769
see there's quite a lot of results here

317
00:12:57,089 --> 00:13:00,120
you can sort of dig in and see how

318
00:12:58,769 --> 00:13:02,940
people are constructing their apps and

319
00:13:00,120 --> 00:13:04,290
where they're deploying them so when you

320
00:13:02,940 --> 00:13:08,279
find the serverless apps what do you do

321
00:13:04,290 --> 00:13:09,839
with them I didn't know the answer to

322
00:13:08,279 --> 00:13:12,689
that so I wanted to kind of dig around

323
00:13:09,839 --> 00:13:16,529
and see what was possible inside of that

324
00:13:12,689 --> 00:13:17,790
each execution environment and so I went

325
00:13:16,529 --> 00:13:19,380
out and I actually looked at the vendor

326
00:13:17,790 --> 00:13:21,839
Docs to see if any vendor was super

327
00:13:19,380 --> 00:13:23,639
transparent about the way they allocated

328
00:13:21,839 --> 00:13:26,009
resources and put together their sandbox

329
00:13:23,639 --> 00:13:29,550
environments and I didn't really find

330
00:13:26,009 --> 00:13:32,130
anything so most vendors consider their

331
00:13:29,550 --> 00:13:35,400
service technology to be super secret

332
00:13:32,130 --> 00:13:37,950
proprietary sauce right they won't even

333
00:13:35,400 --> 00:13:39,949
it's a docker container but we can know

334
00:13:37,950 --> 00:13:42,089
that it's a docker container by sort of

335
00:13:39,950 --> 00:13:43,770
poking at it a bit and seeing if it

336
00:13:42,089 --> 00:13:45,180
behaves like a docker container because

337
00:13:43,770 --> 00:13:48,800
if it looks like a duck and it quacks

338
00:13:45,180 --> 00:13:51,239
like a duck it's probably a duck so I

339
00:13:48,800 --> 00:13:53,579
personally have a problem with using

340
00:13:51,240 --> 00:13:55,290
things that I can't understand which is

341
00:13:53,580 --> 00:13:58,050
why I love open source software right I

342
00:13:55,290 --> 00:14:00,469
can always rip open the code and know

343
00:13:58,050 --> 00:14:03,500
how it works

344
00:14:00,470 --> 00:14:05,370
so I started writing some code in Python

345
00:14:03,500 --> 00:14:08,700
that I would deploy into these

346
00:14:05,370 --> 00:14:12,240
environments that would literally run OS

347
00:14:08,700 --> 00:14:14,520
shell out commands and learn things

348
00:14:12,240 --> 00:14:17,700
about the environment and this was based

349
00:14:14,520 --> 00:14:20,569
on another project by a guy by the name

350
00:14:17,700 --> 00:14:23,279
of Eric Hammond who wrote a web shell

351
00:14:20,570 --> 00:14:26,010
wrapper and no js' there's executes bash

352
00:14:23,279 --> 00:14:29,820
commands so I started kind of evolving

353
00:14:26,010 --> 00:14:31,740
this until I had a bunch of checks that

354
00:14:29,820 --> 00:14:33,300
would more or less try to know all the

355
00:14:31,740 --> 00:14:35,820
things about the environment was it

356
00:14:33,300 --> 00:14:37,770
Linux what was the kernel version what

357
00:14:35,820 --> 00:14:40,620
kind of processors did it have how much

358
00:14:37,770 --> 00:14:42,630
memory if it was Python what were the

359
00:14:40,620 --> 00:14:44,910
Python packages what were the versions

360
00:14:42,630 --> 00:14:46,589
are they up to date how long was the

361
00:14:44,910 --> 00:14:48,990
host alive how long was a container

362
00:14:46,589 --> 00:14:51,270
alive what's a networking like can i

363
00:14:48,990 --> 00:14:56,150
exfiltrate data through a NAT gateway

364
00:14:51,270 --> 00:14:58,529
and so I built all these checks up

365
00:14:56,150 --> 00:15:01,140
here's kind of like the list of things I

366
00:14:58,529 --> 00:15:03,510
primarily wanted to know though based on

367
00:15:01,140 --> 00:15:05,580
an analysis for that data I wanted to

368
00:15:03,510 --> 00:15:10,260
know is this a regular operating system

369
00:15:05,580 --> 00:15:12,240
like rel or CentOS or Windows if so are

370
00:15:10,260 --> 00:15:14,189
the general things about that OS true or

371
00:15:12,240 --> 00:15:16,410
has it been modified by the vendor in a

372
00:15:14,190 --> 00:15:18,990
way that's proprietary to make it more

373
00:15:16,410 --> 00:15:20,100
secure which sort of led me to ask can I

374
00:15:18,990 --> 00:15:23,310
read and write everywhere in the

375
00:15:20,100 --> 00:15:27,360
operating system if I can can I poison

376
00:15:23,310 --> 00:15:28,800
my code by an RCE can I modify the

377
00:15:27,360 --> 00:15:30,300
actual code that's loaded into the

378
00:15:28,800 --> 00:15:33,209
runtime can I get in set environment

379
00:15:30,300 --> 00:15:35,040
variables and are the permissions in the

380
00:15:33,209 --> 00:15:37,020
cloud too permissive or just right and

381
00:15:35,040 --> 00:15:39,660
what about Internet egress because if I

382
00:15:37,020 --> 00:15:41,520
just get any internet access I want that

383
00:15:39,660 --> 00:15:43,709
makes it really easy for me to just do

384
00:15:41,520 --> 00:15:45,480
one data burst of any set of data that I

385
00:15:43,709 --> 00:15:48,329
got and make that kind of hard to detect

386
00:15:45,480 --> 00:15:48,899
and you know slip away with lots of

387
00:15:48,329 --> 00:15:51,180
great

388
00:15:48,899 --> 00:15:52,920
data so this is a little bit in the

389
00:15:51,180 --> 00:15:54,839
cloud like playing operation right so I

390
00:15:52,920 --> 00:15:57,930
totally don't advise that you do this

391
00:15:54,839 --> 00:15:58,980
until you have a frank conversation with

392
00:15:57,930 --> 00:16:00,959
your vendor that you're gonna audit

393
00:15:58,980 --> 00:16:02,100
their environment because depending on

394
00:16:00,959 --> 00:16:04,709
what you're doing and what vendor it is

395
00:16:02,100 --> 00:16:07,019
you will trigger their actual automated

396
00:16:04,709 --> 00:16:09,149
user protection and you'll get kind of a

397
00:16:07,019 --> 00:16:12,809
cease-and-desist noticed and so I work

398
00:16:09,149 --> 00:16:15,929
with Azure and AWS and ethereal pretty

399
00:16:12,809 --> 00:16:17,309
tightly during this project so if you're

400
00:16:15,929 --> 00:16:20,309
interested in doing this I can connect

401
00:16:17,309 --> 00:16:22,499
you with the right people so I looked at

402
00:16:20,309 --> 00:16:24,420
lambda asher and author your web tasks

403
00:16:22,499 --> 00:16:25,889
I'm actually in the process right now of

404
00:16:24,420 --> 00:16:28,498
also doing this for Google compute

405
00:16:25,889 --> 00:16:32,009
engine but that data will not be

406
00:16:28,499 --> 00:16:35,040
publicly available until January so if

407
00:16:32,009 --> 00:16:37,920
you follow me on my website you can get

408
00:16:35,040 --> 00:16:39,420
that data at the end of the year let's

409
00:16:37,920 --> 00:16:41,128
talk about lambda first because lambda

410
00:16:39,420 --> 00:16:44,490
is kind of the easiest it's the longest

411
00:16:41,129 --> 00:16:46,170
lived service runtime we know a few

412
00:16:44,490 --> 00:16:49,110
things from the research of other people

413
00:16:46,170 --> 00:16:50,639
not necessarily from public vendor Docs

414
00:16:49,110 --> 00:16:53,249
we know it's some kind of container

415
00:16:50,639 --> 00:16:55,800
based system we know it runs on Amazon

416
00:16:53,249 --> 00:16:57,360
Linux big surprise there Amazon Linux is

417
00:16:55,800 --> 00:16:59,550
just a rel derivative

418
00:16:57,360 --> 00:17:02,490
it has a read-only file system code is

419
00:16:59,550 --> 00:17:05,099
injected into VAR run task code execute

420
00:17:02,490 --> 00:17:06,870
as a non root user there's a single AWS

421
00:17:05,099 --> 00:17:09,569
I emeral accessible to the sandbox

422
00:17:06,869 --> 00:17:13,979
reverse shells are not possible because

423
00:17:09,569 --> 00:17:16,199
of AWS nat gateway magic somebody

424
00:17:13,980 --> 00:17:17,849
tweeted at me to correct me on this

425
00:17:16,199 --> 00:17:21,179
point there is a way to get reverse

426
00:17:17,849 --> 00:17:22,859
shells in lambda but it assumes a lot of

427
00:17:21,179 --> 00:17:23,669
custom configuration it's really hard so

428
00:17:22,859 --> 00:17:26,339
I'm going to stand by that statement

429
00:17:23,669 --> 00:17:28,770
that under normal circumstances you

430
00:17:26,339 --> 00:17:31,350
can't get reverse shells in lambda and

431
00:17:28,770 --> 00:17:33,899
you can get Internet egress and in some

432
00:17:31,350 --> 00:17:38,189
cases by default your functions do have

433
00:17:33,899 --> 00:17:39,570
internet egress so I wanted to know if I

434
00:17:38,190 --> 00:17:41,309
could steal the credentials where the

435
00:17:39,570 --> 00:17:44,610
credentials inside of these functions

436
00:17:41,309 --> 00:17:46,649
special in any way and if I can how bad

437
00:17:44,610 --> 00:17:48,809
does it get where can i persist code

438
00:17:46,649 --> 00:17:51,299
when I do attack it and how long can i

439
00:17:48,809 --> 00:17:53,460
persist code and then can I get lambda

440
00:17:51,299 --> 00:17:55,408
to do things other than execute code in

441
00:17:53,460 --> 00:17:57,120
the language I prefer to use so this is

442
00:17:55,409 --> 00:17:59,490
kind of like a two stage attack I get an

443
00:17:57,120 --> 00:18:02,020
RC e I stream down an arbitrary binary

444
00:17:59,490 --> 00:18:04,000
that maybe does some nasty or things

445
00:18:02,020 --> 00:18:07,990
should lambda prevent the execution of

446
00:18:04,000 --> 00:18:10,090
that and how frequently lastly does the

447
00:18:07,990 --> 00:18:11,559
OS get patched because you know we know

448
00:18:10,090 --> 00:18:17,439
patch management is kind of a hot topic

449
00:18:11,559 --> 00:18:19,720
because Equifax so I won't dive into the

450
00:18:17,440 --> 00:18:21,190
sample output here because the internet

451
00:18:19,720 --> 00:18:23,320
access in this room is really terrible

452
00:18:21,190 --> 00:18:26,980
and frankly I'm terrified to leave my

453
00:18:23,320 --> 00:18:28,990
slides but this is a blob of descriptive

454
00:18:26,980 --> 00:18:30,820
JSON just picture the most descriptive

455
00:18:28,990 --> 00:18:34,780
JSON about the sandbox that you can

456
00:18:30,820 --> 00:18:36,309
think of in your mind so this is what

457
00:18:34,780 --> 00:18:38,710
the container structure looks like from

458
00:18:36,309 --> 00:18:40,470
my analysis of that JSON right it's it

459
00:18:38,710 --> 00:18:43,150
just a regular Linux file system

460
00:18:40,470 --> 00:18:45,820
connected to AWS API gateway to code

461
00:18:43,150 --> 00:18:47,380
streams down there's a magic file that

462
00:18:45,820 --> 00:18:50,559
nobody talks about in here called

463
00:18:47,380 --> 00:18:51,730
bootstrap Pi which has tons of juicy

464
00:18:50,559 --> 00:18:54,340
stuff that I could have spent a long

465
00:18:51,730 --> 00:18:57,190
time analyzing but this is how Amazon

466
00:18:54,340 --> 00:18:59,770
does x-ray this is how they talk to

467
00:18:57,190 --> 00:19:01,480
other proprietary things in Amazon to

468
00:18:59,770 --> 00:19:03,040
instrument the container and lastly it's

469
00:19:01,480 --> 00:19:06,490
also how they hook up whether it's

470
00:19:03,040 --> 00:19:08,399
Python or nodejs so that files kind of

471
00:19:06,490 --> 00:19:10,780
interesting you can dig into that

472
00:19:08,400 --> 00:19:12,220
there's also /a to be OS lambda

473
00:19:10,780 --> 00:19:14,530
directory and then down at the bottom

474
00:19:12,220 --> 00:19:16,000
there there's only one writable

475
00:19:14,530 --> 00:19:18,940
directory in the whole thing which is

476
00:19:16,000 --> 00:19:21,370
slash temp which is actually a ram disk

477
00:19:18,940 --> 00:19:23,320
so if you slide little slider in lambda

478
00:19:21,370 --> 00:19:24,399
and you allocate 512 makes of Ram it

479
00:19:23,320 --> 00:19:27,280
will actually make a slash temp

480
00:19:24,400 --> 00:19:28,870
partition that's 512 megs and that's the

481
00:19:27,280 --> 00:19:31,960
only place in the container that you can

482
00:19:28,870 --> 00:19:34,540
persist and then on the side there are

483
00:19:31,960 --> 00:19:36,520
how the credentials are delivered some

484
00:19:34,540 --> 00:19:38,350
things in AWS use the metadata proxy

485
00:19:36,520 --> 00:19:41,820
service if you're familiar with that it

486
00:19:38,350 --> 00:19:44,260
spins up a web server on 169.254 169.254

487
00:19:41,820 --> 00:19:46,030
these don't have that you can't access

488
00:19:44,260 --> 00:19:48,490
the metadata service all the creds are

489
00:19:46,030 --> 00:19:50,200
delivered as environment variables which

490
00:19:48,490 --> 00:19:53,920
are just temporary session tokens that

491
00:19:50,200 --> 00:19:57,190
are valid for an hour so that's how the

492
00:19:53,920 --> 00:19:59,440
creds live in the container so given

493
00:19:57,190 --> 00:20:01,059
these limits because the attack surface

494
00:19:59,440 --> 00:20:03,280
is really really small the container is

495
00:20:01,059 --> 00:20:04,990
really really limited as an attacker you

496
00:20:03,280 --> 00:20:06,760
can kind of laser focus on how you're

497
00:20:04,990 --> 00:20:09,250
going to design a piece of serverless

498
00:20:06,760 --> 00:20:11,080
malware right your initial payload needs

499
00:20:09,250 --> 00:20:13,179
to be as small as possible because maybe

500
00:20:11,080 --> 00:20:15,230
you can only get it into the sandbox via

501
00:20:13,179 --> 00:20:17,990
API gateway there's maximum

502
00:20:15,230 --> 00:20:19,520
forget put post requests potentially you

503
00:20:17,990 --> 00:20:20,390
need to persist it in temp attempts

504
00:20:19,520 --> 00:20:22,429
really small

505
00:20:20,390 --> 00:20:25,610
maybe 512 megs in a lot of cases maybe

506
00:20:22,429 --> 00:20:27,650
128 and others you need to be able from

507
00:20:25,610 --> 00:20:29,540
inside of your malware to assess lateral

508
00:20:27,650 --> 00:20:31,580
movement in the environment as fast as

509
00:20:29,540 --> 00:20:32,990
you can if you can't pivot you need to

510
00:20:31,580 --> 00:20:34,970
just die because maybe you're going to

511
00:20:32,990 --> 00:20:36,440
be detected and you need to exfiltrate

512
00:20:34,970 --> 00:20:38,600
your results to somewhere else as

513
00:20:36,440 --> 00:20:42,290
quickly as you can before the container

514
00:20:38,600 --> 00:20:45,459
exits and dies so in other words your

515
00:20:42,290 --> 00:20:47,720
attack needs to be bigger on the inside

516
00:20:45,460 --> 00:20:50,030
so there's some great ways to do this in

517
00:20:47,720 --> 00:20:51,770
Python so python minification is a thing

518
00:20:50,030 --> 00:20:54,168
so you can write Python you can run it

519
00:20:51,770 --> 00:20:56,360
through Python minna fire that basically

520
00:20:54,169 --> 00:20:59,179
takes all of your Python and it kind of

521
00:20:56,360 --> 00:21:01,729
cross compiles it to totally like non

522
00:20:59,179 --> 00:21:03,200
human understandable Python lambda

523
00:21:01,730 --> 00:21:04,910
statements and smashes all the

524
00:21:03,200 --> 00:21:06,290
whitespace out of it so that's one way

525
00:21:04,910 --> 00:21:08,770
you can get your Python really small

526
00:21:06,290 --> 00:21:11,840
even supports inline compression and

527
00:21:08,770 --> 00:21:13,730
then when you're building your Python to

528
00:21:11,840 --> 00:21:14,928
do reconnaissance you probably want to

529
00:21:13,730 --> 00:21:16,910
know what you can do

530
00:21:14,929 --> 00:21:19,760
so inside AWS lambda you get the boat oh

531
00:21:16,910 --> 00:21:22,809
three library for free which is AWS

532
00:21:19,760 --> 00:21:25,100
interface to all of its api's and so

533
00:21:22,809 --> 00:21:26,809
this is kind of an example of how you

534
00:21:25,100 --> 00:21:28,610
might write some Python that would brute

535
00:21:26,809 --> 00:21:30,590
out the permission as to whether that

536
00:21:28,610 --> 00:21:32,418
function can create cloud watch log

537
00:21:30,590 --> 00:21:35,959
grooves which is probably a great way to

538
00:21:32,419 --> 00:21:38,660
exfiltrate data if you can do that just

539
00:21:35,960 --> 00:21:40,520
to create a cloud watch log group put

540
00:21:38,660 --> 00:21:42,710
your your stolen data to cloud watch

541
00:21:40,520 --> 00:21:44,600
logs and then pick it up later from some

542
00:21:42,710 --> 00:21:47,540
other service or a subsequent execution

543
00:21:44,600 --> 00:21:48,830
of the function and so I wrote a bunch

544
00:21:47,540 --> 00:21:51,530
of samples of this and there's a github

545
00:21:48,830 --> 00:21:54,110
just in here with kind of a

546
00:21:51,530 --> 00:21:56,330
reconnaissance script that I use there's

547
00:21:54,110 --> 00:21:58,490
also a Python module called one-liner

548
00:21:56,330 --> 00:22:00,290
Iser that will take any Python script

549
00:21:58,490 --> 00:22:04,250
and turn it into one totally

550
00:22:00,290 --> 00:22:07,309
unintelligible line this works great if

551
00:22:04,250 --> 00:22:08,960
you want to make circle smaller I didn't

552
00:22:07,309 --> 00:22:10,370
make circle smaller that I have to share

553
00:22:08,960 --> 00:22:13,700
with you but boy that sure would've been

554
00:22:10,370 --> 00:22:15,678
cool maybe next year so in summary you

555
00:22:13,700 --> 00:22:17,840
have two techniques with lots of payload

556
00:22:15,679 --> 00:22:20,530
packing and if I was writing service

557
00:22:17,840 --> 00:22:22,820
malware that's probably how I do it

558
00:22:20,530 --> 00:22:24,678
instead I decided to build an app that

559
00:22:22,820 --> 00:22:28,700
was horrible and just sort of attack it

560
00:22:24,679 --> 00:22:32,300
by hand so I wrote a slack bot because

561
00:22:28,700 --> 00:22:35,090
we'll use slack for a lot of things and

562
00:22:32,300 --> 00:22:37,340
that slack BOTS primary job was to take

563
00:22:35,090 --> 00:22:39,050
a web hook from github send a

564
00:22:37,340 --> 00:22:40,909
notification to a channel and then allow

565
00:22:39,050 --> 00:22:44,360
a user to ask a question of that slack

566
00:22:40,910 --> 00:22:46,220
bot about commit messages but I put a

567
00:22:44,360 --> 00:22:47,870
vulnerability into that slack bot that

568
00:22:46,220 --> 00:22:51,530
allows you to get a string escape and

569
00:22:47,870 --> 00:22:54,770
execute arbitrary code and so I have a

570
00:22:51,530 --> 00:22:57,200
little demo of that this is what the

571
00:22:54,770 --> 00:22:59,180
normal behavior will look like this is

572
00:22:57,200 --> 00:23:00,680
what the bad behavior will look like you

573
00:22:59,180 --> 00:23:03,280
can see I have the slack bot sort of

574
00:23:00,680 --> 00:23:07,250
vomiting creds back into the channel

575
00:23:03,280 --> 00:23:09,710
from some code injection and you can

576
00:23:07,250 --> 00:23:11,150
escalate the behavior of that but the

577
00:23:09,710 --> 00:23:13,480
video to sort of tells a story a little

578
00:23:11,150 --> 00:23:13,480
bit better

579
00:23:23,680 --> 00:23:28,690
so let's fast-forward to the juicy stuff

580
00:23:26,040 --> 00:23:30,610
this is me making fun of my co-presenter

581
00:23:28,690 --> 00:23:35,200
at blackhat in the slack Channel while

582
00:23:30,610 --> 00:23:37,689
I'm performing the attack so there's the

583
00:23:35,200 --> 00:23:39,490
commit message that says hey somebody

584
00:23:37,690 --> 00:23:41,140
committed some stuff to github this is

585
00:23:39,490 --> 00:23:42,820
normal behavior and you can ask it to go

586
00:23:41,140 --> 00:23:45,540
get the changelog for you and you can

587
00:23:42,820 --> 00:23:49,270
inline a file name between some sort of

588
00:23:45,540 --> 00:23:50,860
templating style language and so this is

589
00:23:49,270 --> 00:23:53,050
me asking it to do the regular thing go

590
00:23:50,860 --> 00:23:53,560
get the changelog and copy that into the

591
00:23:53,050 --> 00:23:56,860
channel

592
00:23:53,560 --> 00:23:59,230
look there's the change lock that was

593
00:23:56,860 --> 00:24:04,629
ASCII Star Wars but slack does not honor

594
00:23:59,230 --> 00:24:06,520
ASCII and so this is just me validating

595
00:24:04,630 --> 00:24:11,380
that it actually did go out and get the

596
00:24:06,520 --> 00:24:15,610
changelog so again me making fun of my

597
00:24:11,380 --> 00:24:18,010
co-presenter and so there's the

598
00:24:15,610 --> 00:24:19,810
vulnerability it calls a OS thought P

599
00:24:18,010 --> 00:24:22,540
open and it does a shell out instead of

600
00:24:19,810 --> 00:24:25,889
using native Python read facilities so

601
00:24:22,540 --> 00:24:25,889
kind of unsafe

602
00:24:31,470 --> 00:24:36,720
so this is me in lining just the list

603
00:24:34,679 --> 00:24:40,679
command in there to validate that it

604
00:24:36,720 --> 00:24:43,769
actually works and boom yay I know I can

605
00:24:40,679 --> 00:24:46,519
do stuff so now what else can I get lots

606
00:24:43,769 --> 00:24:49,200
of juicy stuff is maybe if I'm route

607
00:24:46,519 --> 00:24:51,539
definitely not route I'm SPX user which

608
00:24:49,200 --> 00:24:54,120
is the regular user for AWS lamda dead

609
00:24:51,539 --> 00:24:56,490
giveaway I know from other stuff and

610
00:24:54,120 --> 00:24:58,860
things that environment variables or

611
00:24:56,490 --> 00:25:04,139
where the creds live and so I get the

612
00:24:58,860 --> 00:25:07,439
credits okay and so then I want to know

613
00:25:04,139 --> 00:25:09,120
stuff and things about those creds so I

614
00:25:07,440 --> 00:25:13,110
just copy them into my regular boto

615
00:25:09,120 --> 00:25:18,418
profile and once they're in my regular

616
00:25:13,110 --> 00:25:21,330
boto profile I try to call s3 with them

617
00:25:18,419 --> 00:25:23,700
and I can't because this is a hard and I

618
00:25:21,330 --> 00:25:26,399
am policy but this validates that the

619
00:25:23,700 --> 00:25:28,919
creds do work outside the sandbox I can

620
00:25:26,399 --> 00:25:31,889
know who I am and then I can run Daniel

621
00:25:28,919 --> 00:25:33,659
gresling AWS pone to see all the other

622
00:25:31,889 --> 00:25:35,699
stuff that I can do so this is a script

623
00:25:33,659 --> 00:25:37,919
that you can run locally that just goes

624
00:25:35,700 --> 00:25:39,659
through and it will brood out all the

625
00:25:37,919 --> 00:25:42,600
permissions more or less by just trying

626
00:25:39,659 --> 00:25:44,490
every permission in every service one at

627
00:25:42,600 --> 00:25:46,769
a time and recording whether it was

628
00:25:44,490 --> 00:25:49,799
authorized or unauthorized now that's a

629
00:25:46,769 --> 00:25:51,539
really noisy very stupid attack if you

630
00:25:49,799 --> 00:25:55,940
actually care about somebody not

631
00:25:51,539 --> 00:25:55,940
noticing you but you can do that

632
00:26:01,230 --> 00:26:07,090
so you can also get artifacts out this

633
00:26:06,460 --> 00:26:09,580
is me

634
00:26:07,090 --> 00:26:11,110
basically proving that you can post to

635
00:26:09,580 --> 00:26:13,389
other places on the Internet

636
00:26:11,110 --> 00:26:15,520
so I I wrote that test to see if I could

637
00:26:13,390 --> 00:26:17,230
create log streams and then report the

638
00:26:15,520 --> 00:26:18,639
status back to yet another service

639
00:26:17,230 --> 00:26:21,160
function so using server lists to

640
00:26:18,640 --> 00:26:24,370
collect data about hacking service so

641
00:26:21,160 --> 00:26:26,140
it's server list inception the attack

642
00:26:24,370 --> 00:26:28,570
surface of these kind of attacks becomes

643
00:26:26,140 --> 00:26:30,340
larger with bad I am and the issue here

644
00:26:28,570 --> 00:26:31,899
is really frameworks so this is new

645
00:26:30,340 --> 00:26:34,149
technology right we're still making a

646
00:26:31,900 --> 00:26:35,950
lot of custom tooling around making it

647
00:26:34,150 --> 00:26:37,660
easy for developers to interact with and

648
00:26:35,950 --> 00:26:40,630
a lot of the frameworks like Zappa and

649
00:26:37,660 --> 00:26:43,930
Apex framework do not make good iam

650
00:26:40,630 --> 00:26:46,360
policies so this is the default policy

651
00:26:43,930 --> 00:26:48,550
of a Zappa deployment and if you know

652
00:26:46,360 --> 00:26:50,350
much about AWS policies maybe you don't

653
00:26:48,550 --> 00:26:51,669
know much about AWS policies all you

654
00:26:50,350 --> 00:26:54,969
really need to know is the more stars

655
00:26:51,670 --> 00:26:56,010
there are the worse it is and this has a

656
00:26:54,970 --> 00:26:59,520
lot of stars

657
00:26:56,010 --> 00:27:02,740
so the IM struggle is really really real

658
00:26:59,520 --> 00:27:04,210
my boss likes to say that I am an AWS is

659
00:27:02,740 --> 00:27:08,860
the killer feature and the killer

660
00:27:04,210 --> 00:27:10,690
feature so detection is also kind of

661
00:27:08,860 --> 00:27:14,110
difficult here on premise we have a lot

662
00:27:10,690 --> 00:27:15,190
of mature facilities for seeing if our

663
00:27:14,110 --> 00:27:17,409
environment is been breached we have

664
00:27:15,190 --> 00:27:19,540
network tabs we have audit D we have

665
00:27:17,410 --> 00:27:21,190
syslog shipping other sim functions in

666
00:27:19,540 --> 00:27:24,820
the cloud we basically have cloud watch

667
00:27:21,190 --> 00:27:27,150
logs in AWS and anything else that we do

668
00:27:24,820 --> 00:27:29,830
to instrument our own applications and

669
00:27:27,150 --> 00:27:31,180
so if I have one piece of advice about

670
00:27:29,830 --> 00:27:32,439
this it's that if you're designing an

671
00:27:31,180 --> 00:27:34,480
application for server lace

672
00:27:32,440 --> 00:27:36,280
don't leave your time machine in the

673
00:27:34,480 --> 00:27:38,320
garage like make really heavy use of

674
00:27:36,280 --> 00:27:40,270
cloud watch logs and actually have

675
00:27:38,320 --> 00:27:41,649
developers write sane log into the app

676
00:27:40,270 --> 00:27:43,480
that proves that it's behaving normally

677
00:27:41,650 --> 00:27:45,400
because you don't really have a ton of

678
00:27:43,480 --> 00:27:49,000
native instrumentation in the

679
00:27:45,400 --> 00:27:51,190
environment so oh I did my demo early

680
00:27:49,000 --> 00:27:52,360
for the bad slack bot app so just

681
00:27:51,190 --> 00:27:55,870
pretend that it happened here and

682
00:27:52,360 --> 00:27:58,449
everything went really smooth so when I

683
00:27:55,870 --> 00:27:59,919
did that demo of the slack bot app I had

684
00:27:58,450 --> 00:28:02,110
cloud watch logs turned on and you can

685
00:27:59,920 --> 00:28:04,120
see that there's some abnormal things

686
00:28:02,110 --> 00:28:07,090
that end up in cloud watch logs if I'm

687
00:28:04,120 --> 00:28:08,919
using them there are definitely lots of

688
00:28:07,090 --> 00:28:13,179
great indicators of compromised

689
00:28:08,920 --> 00:28:14,620
for the environment here so besides just

690
00:28:13,180 --> 00:28:17,200
the fact that I had shell come

691
00:28:14,620 --> 00:28:19,750
in my cloud watch log I had anomalous

692
00:28:17,200 --> 00:28:21,640
execution times for those functions so

693
00:28:19,750 --> 00:28:23,800
one of the things that AWS cloud watch

694
00:28:21,640 --> 00:28:26,050
gets natively so it gets the execution

695
00:28:23,800 --> 00:28:28,030
time that it took for a function so you

696
00:28:26,050 --> 00:28:29,919
can definitely in some cases average

697
00:28:28,030 --> 00:28:33,280
that and you can know if it's within a

698
00:28:29,920 --> 00:28:34,990
standard deviation of the mean right and

699
00:28:33,280 --> 00:28:37,149
anything that's outside of you know

700
00:28:34,990 --> 00:28:40,030
maybe like 1.25 you should trigger an

701
00:28:37,150 --> 00:28:42,430
alert on high error rates are a dead

702
00:28:40,030 --> 00:28:44,680
giveaway that something's gone wrong and

703
00:28:42,430 --> 00:28:47,559
cloud trail high denials for the role in

704
00:28:44,680 --> 00:28:49,059
lambda it's another sort of smell test

705
00:28:47,559 --> 00:28:53,220
that somebody might have exfiltrated

706
00:28:49,059 --> 00:28:53,220
some credentials and is doing bad things

707
00:28:54,090 --> 00:29:01,449
this is what the cloud trail event looks

708
00:28:57,610 --> 00:29:04,030
like for deny cloud trail deny events do

709
00:29:01,450 --> 00:29:06,010
not surface in the regular AWS cloud

710
00:29:04,030 --> 00:29:07,899
trail interface you don't see them

711
00:29:06,010 --> 00:29:10,390
unless you look at cloud trail in cloud

712
00:29:07,900 --> 00:29:11,770
watch or you look at the raw data so a

713
00:29:10,390 --> 00:29:13,840
lot of people that I talked to don't

714
00:29:11,770 --> 00:29:15,340
even know that cloud trail logs denials

715
00:29:13,840 --> 00:29:18,850
but it totally does

716
00:29:15,340 --> 00:29:20,500
and you can use this so bottom line

717
00:29:18,850 --> 00:29:22,870
about lambda is that it's only as bad as

718
00:29:20,500 --> 00:29:25,360
your I am and AWS cases and you can

719
00:29:22,870 --> 00:29:27,760
detect it through cloud watch log

720
00:29:25,360 --> 00:29:29,830
delivery but your mean time to respond

721
00:29:27,760 --> 00:29:31,240
is about seven to 10 minutes in a

722
00:29:29,830 --> 00:29:33,159
best-case because of the way that cloud

723
00:29:31,240 --> 00:29:35,380
watch logs bubble up in the environment

724
00:29:33,160 --> 00:29:41,530
so now let's talk about Azure functions

725
00:29:35,380 --> 00:29:43,179
a sure unsurprisingly runs on Windows it

726
00:29:41,530 --> 00:29:46,178
has a set of functions grouped within

727
00:29:43,179 --> 00:29:47,679
what they refer to as apps because it is

728
00:29:46,179 --> 00:29:50,290
windows and windows is built in a very

729
00:29:47,679 --> 00:29:53,080
specific way the file system in these is

730
00:29:50,290 --> 00:29:55,600
largely writable it does not have

731
00:29:53,080 --> 00:29:58,120
internet egress everything runs as

732
00:29:55,600 --> 00:30:02,110
non-root all functions in the same app

733
00:29:58,120 --> 00:30:03,760
share a system or tenant all functions

734
00:30:02,110 --> 00:30:06,820
in the same app execute as the same user

735
00:30:03,760 --> 00:30:08,490
app code is loaded into a root in a

736
00:30:06,820 --> 00:30:12,270
drive that's called D that's attached

737
00:30:08,490 --> 00:30:15,190
code gets injected into an is root

738
00:30:12,270 --> 00:30:18,010
unsurprisingly some secrets are stored

739
00:30:15,190 --> 00:30:20,590
in data functions secrets and that's

740
00:30:18,010 --> 00:30:24,300
going to come into play later how as

741
00:30:20,590 --> 00:30:27,010
you're sort of mismanages those secrets

742
00:30:24,300 --> 00:30:28,370
so i wanted to know the same questions i

743
00:30:27,010 --> 00:30:30,740
asked about lambda

744
00:30:28,370 --> 00:30:33,049
and since all these things unlike lambda

745
00:30:30,740 --> 00:30:36,169
I get deployed on to the same tenant how

746
00:30:33,049 --> 00:30:39,860
could I use that functionality to maybe

747
00:30:36,169 --> 00:30:41,779
do bad things to a single app so a

748
00:30:39,860 --> 00:30:43,459
couple other tidbits about a sure they

749
00:30:41,779 --> 00:30:45,860
do publicly disclose is that you don't

750
00:30:43,460 --> 00:30:49,669
get WMI access and get event log list

751
00:30:45,860 --> 00:30:51,260
does return objects but not in the way

752
00:30:49,669 --> 00:30:54,200
that you think they actually send all

753
00:30:51,260 --> 00:30:58,190
the windows event logs to dev null for

754
00:30:54,200 --> 00:30:59,659
some reason so in digging around I use

755
00:30:58,190 --> 00:31:02,750
the same programmatic shell wrapper as

756
00:30:59,659 --> 00:31:04,039
before it's a less ephemeral system so

757
00:31:02,750 --> 00:31:07,010
it means I have more tools at my

758
00:31:04,039 --> 00:31:09,200
disposal potentially azor does open

759
00:31:07,010 --> 00:31:13,309
source this sandbox to its credit it's

760
00:31:09,200 --> 00:31:15,110
available but in the Microsoft developer

761
00:31:13,309 --> 00:31:16,850
Network documentation they don't

762
00:31:15,110 --> 00:31:18,799
actually say that they open source it

763
00:31:16,850 --> 00:31:22,250
they actually open source it under a

764
00:31:18,799 --> 00:31:24,080
code name called product kudu and they

765
00:31:22,250 --> 00:31:27,260
don't really marry those Doc's together

766
00:31:24,080 --> 00:31:28,939
to make it easy for you to know you can

767
00:31:27,260 --> 00:31:31,090
run PowerShell in the environment we all

768
00:31:28,940 --> 00:31:33,529
know that InfoSec people love PowerShell

769
00:31:31,090 --> 00:31:35,389
and that greatly reduces the pain of

770
00:31:33,529 --> 00:31:39,110
understanding how the environment is put

771
00:31:35,390 --> 00:31:40,520
together so in order to demonstrate this

772
00:31:39,110 --> 00:31:42,918
my colleague who is not here

773
00:31:40,520 --> 00:31:45,379
co-presenting with me created a

774
00:31:42,919 --> 00:31:48,200
vulnerable app concept that was supposed

775
00:31:45,380 --> 00:31:49,820
to be a credit card matching api and it

776
00:31:48,200 --> 00:31:52,159
does very much work like a credit card

777
00:31:49,820 --> 00:31:53,510
matching api and it's composed of a few

778
00:31:52,159 --> 00:31:55,070
different functions that are single

779
00:31:53,510 --> 00:31:57,200
responsibilities that are designed to do

780
00:31:55,070 --> 00:31:59,600
things like accept credit card numbers

781
00:31:57,200 --> 00:32:04,370
charge someone and then build them at

782
00:31:59,600 --> 00:32:06,110
the end of the month so it is written in

783
00:32:04,370 --> 00:32:08,739
nodejs and so we introduced a little

784
00:32:06,110 --> 00:32:11,870
vulnerability here that allows you to

785
00:32:08,740 --> 00:32:13,760
execute some arbitrary code and get a

786
00:32:11,870 --> 00:32:17,209
function to return before the it's

787
00:32:13,760 --> 00:32:18,980
intended to Asher's credit this when a

788
00:32:17,210 --> 00:32:22,520
function does return early it raises a

789
00:32:18,980 --> 00:32:24,440
red flag in the log but it still does

790
00:32:22,520 --> 00:32:26,929
execute all the way to completion here's

791
00:32:24,440 --> 00:32:28,760
the indicator that a function has

792
00:32:26,929 --> 00:32:30,559
returned returned early it'll say error

793
00:32:28,760 --> 00:32:32,360
done has already been called please

794
00:32:30,559 --> 00:32:37,399
check your script for extraneous calls

795
00:32:32,360 --> 00:32:40,820
to done that is a smoking gun that means

796
00:32:37,399 --> 00:32:43,010
somebody got RCE in your function so

797
00:32:40,820 --> 00:32:45,370
if you're a visual learner all the

798
00:32:43,010 --> 00:32:48,800
functions live on the same tenant and

799
00:32:45,370 --> 00:32:51,770
any function inside of that tenant can

800
00:32:48,800 --> 00:32:53,540
by default list all functions that run

801
00:32:51,770 --> 00:32:57,350
on the tenant so immediately you have

802
00:32:53,540 --> 00:32:59,300
API access if you gain a foothold and a

803
00:32:57,350 --> 00:33:02,659
low privilege function to know what the

804
00:32:59,300 --> 00:33:05,149
other functions are you can change API

805
00:33:02,660 --> 00:33:08,330
keys from inside one function for any

806
00:33:05,150 --> 00:33:10,640
function on the same tenant so this is

807
00:33:08,330 --> 00:33:12,560
bad you can change the triggering method

808
00:33:10,640 --> 00:33:13,910
methods of other functions so let's say

809
00:33:12,560 --> 00:33:16,100
that you have a credit card matcher app

810
00:33:13,910 --> 00:33:17,960
and some of the things are event based

811
00:33:16,100 --> 00:33:19,429
from a REST API and you have a billing

812
00:33:17,960 --> 00:33:21,830
function that's supposed to send bills

813
00:33:19,430 --> 00:33:23,690
out every month you can change that

814
00:33:21,830 --> 00:33:27,129
billing function to run on an event

815
00:33:23,690 --> 00:33:30,260
trigger instead or run every minute and

816
00:33:27,130 --> 00:33:32,120
lastly which I will show you in an ask

817
00:33:30,260 --> 00:33:34,400
you know my demo you can actually from a

818
00:33:32,120 --> 00:33:39,169
low privilege function poisson the code

819
00:33:34,400 --> 00:33:40,970
of a higher privilege function so I

820
00:33:39,170 --> 00:33:43,040
think I'm running a little bit behind

821
00:33:40,970 --> 00:33:45,470
here so I'm just gonna skip to the juicy

822
00:33:43,040 --> 00:33:51,379
stuff which is changing the source code

823
00:33:45,470 --> 00:33:55,070
of the function here we go internet

824
00:33:51,380 --> 00:33:57,890
access is hard oh yay there we go so

825
00:33:55,070 --> 00:33:59,629
what you're gonna see on screen before I

826
00:33:57,890 --> 00:34:04,490
actually click the play button on this

827
00:33:59,630 --> 00:34:06,860
is a a post with curl that will cause

828
00:34:04,490 --> 00:34:09,230
the billing function to say that my

829
00:34:06,860 --> 00:34:11,989
credit card bill instead of being what

830
00:34:09,230 --> 00:34:14,570
the normal charge is is one dollar and

831
00:34:11,989 --> 00:34:17,359
the way that it will do that is by

832
00:34:14,570 --> 00:34:19,940
hitting a low privilege function with an

833
00:34:17,360 --> 00:34:21,770
RCE it will list all the functions it

834
00:34:19,940 --> 00:34:24,740
will ask for the API key for the high

835
00:34:21,770 --> 00:34:27,290
privilege billing function and then that

836
00:34:24,739 --> 00:34:29,000
API key will be encrypted but since all

837
00:34:27,290 --> 00:34:31,159
the functions run on the same tenant and

838
00:34:29,000 --> 00:34:33,290
Azure is perhaps not as mature in their

839
00:34:31,159 --> 00:34:36,290
I am model I can actually just very

840
00:34:33,290 --> 00:34:38,719
nicely ask as your kms to decrypt that

841
00:34:36,290 --> 00:34:40,909
API key for me and it will return me the

842
00:34:38,719 --> 00:34:45,949
key and then I can use that to access

843
00:34:40,909 --> 00:34:47,359
the high privileged function so at the

844
00:34:45,949 --> 00:34:48,620
when when this happens even though it

845
00:34:47,360 --> 00:34:54,100
will be unseen say tional you need to

846
00:34:48,620 --> 00:34:54,100
clap for my co-presenter who is not here

847
00:34:55,159 --> 00:35:01,470
there it goes

848
00:34:57,030 --> 00:35:03,840
I've got the bill back now I'm gonna

849
00:35:01,470 --> 00:35:07,319
patch the billing code to always return

850
00:35:03,840 --> 00:35:11,130
one dollar and then I'm going to ask it

851
00:35:07,320 --> 00:35:21,960
what the charge is at the very end and

852
00:35:11,130 --> 00:35:24,750
it should say one dollar so yes the bill

853
00:35:21,960 --> 00:35:27,630
on the left there 1 2 3 4 5 6 7 8 9 0 1

854
00:35:24,750 --> 00:35:29,700
2 3 4 5 6 is now one dollar and the

855
00:35:27,630 --> 00:35:32,790
other charge has been moved to another

856
00:35:29,700 --> 00:35:35,129
credit card number all of the code for

857
00:35:32,790 --> 00:35:37,110
this is totally public by the way so you

858
00:35:35,130 --> 00:35:38,760
can deploy this in Azure and you can

859
00:35:37,110 --> 00:35:41,280
play around with it yourself if you want

860
00:35:38,760 --> 00:35:47,220
to test the IO C's out or you want to

861
00:35:41,280 --> 00:35:48,000
test the API key thing all right moving

862
00:35:47,220 --> 00:35:51,000
right along

863
00:35:48,000 --> 00:35:53,850
so takeaways from that having separate

864
00:35:51,000 --> 00:35:55,530
API keys is great but once you're in one

865
00:35:53,850 --> 00:35:57,509
function you have access to all the

866
00:35:55,530 --> 00:36:00,620
other API keys so you might as well not

867
00:35:57,510 --> 00:36:02,640
have many it's only inconvenient for you

868
00:36:00,620 --> 00:36:04,170
be aware of the choices that you're

869
00:36:02,640 --> 00:36:05,850
making by putting functions in the same

870
00:36:04,170 --> 00:36:08,130
app I actually think this is a bad piece

871
00:36:05,850 --> 00:36:10,470
of advice that's given for a feature

872
00:36:08,130 --> 00:36:12,660
that was intended to work this way so

873
00:36:10,470 --> 00:36:14,310
the default blueprint is for all your

874
00:36:12,660 --> 00:36:15,720
functions to deploy in one tenant if you

875
00:36:14,310 --> 00:36:17,880
want to work around this don't deploy

876
00:36:15,720 --> 00:36:19,560
all your functions in one tenant if they

877
00:36:17,880 --> 00:36:22,020
have separate security boundaries

878
00:36:19,560 --> 00:36:24,690
you can make this secure it's not that

879
00:36:22,020 --> 00:36:25,860
hard you just it'll cost you more money

880
00:36:24,690 --> 00:36:27,870
but when you're talking about running

881
00:36:25,860 --> 00:36:30,420
functions for a fraction of a cent if it

882
00:36:27,870 --> 00:36:33,960
cost you point 0:02 cents instead of

883
00:36:30,420 --> 00:36:35,190
0.0001 who really cares so the last

884
00:36:33,960 --> 00:36:37,260
vendor I'm going to talk about is off

885
00:36:35,190 --> 00:36:40,890
zero offs your web task is probably the

886
00:36:37,260 --> 00:36:42,930
smallest run time I looked at web task

887
00:36:40,890 --> 00:36:44,279
is to Ozzie Rose credit totally open

888
00:36:42,930 --> 00:36:46,770
source

889
00:36:44,280 --> 00:36:49,350
it runs in docker containers on core OS

890
00:36:46,770 --> 00:36:51,930
they are very transparent about that it

891
00:36:49,350 --> 00:36:54,150
allegedly runs nodejs only there's no

892
00:36:51,930 --> 00:36:56,279
restriction on internet egress this is

893
00:36:54,150 --> 00:36:59,070
because of the nature of how azio works

894
00:36:56,280 --> 00:37:00,330
they are a identity provider and it

895
00:36:59,070 --> 00:37:02,010
would be very hard for an identity

896
00:37:00,330 --> 00:37:03,480
provider to have compute environments

897
00:37:02,010 --> 00:37:07,200
that could not talk to other things on

898
00:37:03,480 --> 00:37:08,910
the internet it's used

899
00:37:07,200 --> 00:37:10,169
it's used inside of the Osseo rule

900
00:37:08,910 --> 00:37:11,009
engine and lots of other stuff like

901
00:37:10,170 --> 00:37:13,020
github webhook

902
00:37:11,010 --> 00:37:14,640
based applications it has public and

903
00:37:13,020 --> 00:37:16,320
private tenants you can give them lots

904
00:37:14,640 --> 00:37:20,129
of extra money to run your own instance

905
00:37:16,320 --> 00:37:21,870
of it so at first I thought oh man it

906
00:37:20,130 --> 00:37:24,210
runs nodejs I have to re-implement all

907
00:37:21,870 --> 00:37:29,520
my code that mines the sandbox in node

908
00:37:24,210 --> 00:37:31,020
and that sucks but then my coworker

909
00:37:29,520 --> 00:37:33,600
actually figured out that you could just

910
00:37:31,020 --> 00:37:34,830
circumvent the actual native sandbox

911
00:37:33,600 --> 00:37:37,140
protection that prevented you from

912
00:37:34,830 --> 00:37:38,100
calling other things by just launching

913
00:37:37,140 --> 00:37:42,540
subprocesses

914
00:37:38,100 --> 00:37:46,290
and so yay

915
00:37:42,540 --> 00:37:48,630
he wrote a web shell for me to use his

916
00:37:46,290 --> 00:37:49,830
Twitter handle is kingster Iser and if

917
00:37:48,630 --> 00:37:51,180
you think this is cool you should go

918
00:37:49,830 --> 00:37:54,029
follow him on Twitter cuz he tweets

919
00:37:51,180 --> 00:37:54,629
about lots of other neat things he's

920
00:37:54,030 --> 00:37:56,310
French

921
00:37:54,630 --> 00:37:59,640
that's a French name by the way I won't

922
00:37:56,310 --> 00:38:04,290
even try to say his actual name it's

923
00:37:59,640 --> 00:38:06,600
Guillaume and so that's the output of

924
00:38:04,290 --> 00:38:09,240
the web shell running inside the sandbox

925
00:38:06,600 --> 00:38:12,180
and so now I didn't have to do much

926
00:38:09,240 --> 00:38:13,259
right because I could get the sandbox to

927
00:38:12,180 --> 00:38:17,129
do whatever I want

928
00:38:13,260 --> 00:38:20,100
I could also run Python in the sandbox

929
00:38:17,130 --> 00:38:21,720
so once I can exact child processes I

930
00:38:20,100 --> 00:38:26,009
pretty much found out I can do all the

931
00:38:21,720 --> 00:38:28,290
things and so we've had a couple other

932
00:38:26,010 --> 00:38:31,470
things where we are digging around in

933
00:38:28,290 --> 00:38:33,630
here one of which is a raw socket that's

934
00:38:31,470 --> 00:38:36,200
mounted inside the container is a shared

935
00:38:33,630 --> 00:38:39,210
docker boolean and that was interesting

936
00:38:36,200 --> 00:38:41,850
so I'm going to show you a quick process

937
00:38:39,210 --> 00:38:43,770
demo and so this demonstrates that auth0

938
00:38:41,850 --> 00:38:46,980
does not follow one of the rules of

939
00:38:43,770 --> 00:38:48,420
sandbox sandboxes which is that we

940
00:38:46,980 --> 00:38:51,980
believe that sandbox is die at the end

941
00:38:48,420 --> 00:38:51,980
of their maximum execution time

942
00:39:01,960 --> 00:39:15,339
I lost my web tasks session it is

943
00:39:10,390 --> 00:39:19,410
definitely not web's web task comm we

944
00:39:15,339 --> 00:39:19,410
are so lucky that that was a benign site

945
00:39:25,920 --> 00:39:29,660
the tubes are slow today

946
00:39:41,410 --> 00:39:46,990
so it has a nice IDE you know I'm sort

947
00:39:45,280 --> 00:39:48,610
of dancing up here waiting for this to

948
00:39:46,990 --> 00:39:58,660
load or you can just write the node.js

949
00:39:48,610 --> 00:40:01,720
like right in the browser all right so

950
00:39:58,660 --> 00:40:03,910
now we can pass arbitrary arguments and

951
00:40:01,720 --> 00:40:05,799
so if I type something that actually

952
00:40:03,910 --> 00:40:07,720
like Forks a process to the background

953
00:40:05,800 --> 00:40:12,880
and sticks like Python that would pop

954
00:40:07,720 --> 00:40:14,919
the Python interpreter the sandbox will

955
00:40:12,880 --> 00:40:17,470
just stick on the tenant until another

956
00:40:14,920 --> 00:40:19,180
process comes and sweeps it away so just

957
00:40:17,470 --> 00:40:21,509
by forking a process I can keep this

958
00:40:19,180 --> 00:40:26,160
container alive longer than the intended

959
00:40:21,510 --> 00:40:26,160
execution period which is lame

960
00:40:32,730 --> 00:40:35,909
[Music]

961
00:40:35,990 --> 00:40:41,419
sometimes this works and sometimes it

962
00:40:38,300 --> 00:40:44,830
doesn't to run PS because it associates

963
00:40:41,420 --> 00:40:44,830
something with my IP

964
00:40:57,830 --> 00:41:04,440
there so that's proof two tabs Python

965
00:41:01,860 --> 00:41:08,310
still running in this if I just sit here

966
00:41:04,440 --> 00:41:10,770
and refresh up that one died so maybe

967
00:41:08,310 --> 00:41:12,360
they've improved this but if you watch

968
00:41:10,770 --> 00:41:24,090
the blackhat demo this totally works

969
00:41:12,360 --> 00:41:26,150
I swear alright ops your learnings I

970
00:41:24,090 --> 00:41:28,770
left my slide that came back has to work

971
00:41:26,150 --> 00:41:30,780
for processes hang the container maybe

972
00:41:28,770 --> 00:41:32,610
they don't need more back-channel talk

973
00:41:30,780 --> 00:41:34,380
is a socket that is a rest endpoint

974
00:41:32,610 --> 00:41:35,760
likely for credential exchanges during

975
00:41:34,380 --> 00:41:38,660
off I didn't poke at that too much

976
00:41:35,760 --> 00:41:41,130
sandbox is escapable to the container

977
00:41:38,660 --> 00:41:43,080
sandbox system is Debian with little

978
00:41:41,130 --> 00:41:44,730
anomaly detection or monitoring during

979
00:41:43,080 --> 00:41:48,569
the entire time that I did super noisy

980
00:41:44,730 --> 00:41:49,620
things in here including running several

981
00:41:48,570 --> 00:41:51,510
docker exploits

982
00:41:49,620 --> 00:41:54,710
I didn't trigger their automated

983
00:41:51,510 --> 00:41:57,510
protection which is a little unsettling

984
00:41:54,710 --> 00:41:58,860
and so I decided to kind of start a

985
00:41:57,510 --> 00:42:02,790
project to put this all together all

986
00:41:58,860 --> 00:42:05,700
this data this profiling so I had the

987
00:42:02,790 --> 00:42:07,920
server showdown project which is all

988
00:42:05,700 --> 00:42:11,580
those things I gather from Python lots

989
00:42:07,920 --> 00:42:12,750
of tests it matters because as consumers

990
00:42:11,580 --> 00:42:14,730
we need to know when the environment

991
00:42:12,750 --> 00:42:16,440
changes we need to know how often the

992
00:42:14,730 --> 00:42:18,000
vendor patches because there's no such

993
00:42:16,440 --> 00:42:21,030
thing as a patch feed for serverless

994
00:42:18,000 --> 00:42:23,040
sandboxes and it allows us to really

995
00:42:21,030 --> 00:42:25,170
keep the vendors honest with us as

996
00:42:23,040 --> 00:42:26,880
consumers and sometimes it'll give us

997
00:42:25,170 --> 00:42:28,260
clues when new features are coming out

998
00:42:26,880 --> 00:42:30,540
because you'll see new environment

999
00:42:28,260 --> 00:42:31,950
variables for NDA services kind of

1000
00:42:30,540 --> 00:42:33,900
popping into these containers before

1001
00:42:31,950 --> 00:42:35,569
they're actually publicly released I

1002
00:42:33,900 --> 00:42:40,860
don't know how you could use that

1003
00:42:35,570 --> 00:42:42,300
financially profit so I decided to make

1004
00:42:40,860 --> 00:42:44,190
a project called the service Observatory

1005
00:42:42,300 --> 00:42:46,050
Mozilla we love things that do

1006
00:42:44,190 --> 00:42:47,490
observatory stuff and things and this is

1007
00:42:46,050 --> 00:42:49,290
not a Mozilla project but we have the

1008
00:42:47,490 --> 00:42:51,029
web observatory and it inspired me to

1009
00:42:49,290 --> 00:42:53,370
make the service observatory which is

1010
00:42:51,030 --> 00:42:55,020
still not done by the way because I am a

1011
00:42:53,370 --> 00:42:57,060
busy guy but if this is something that

1012
00:42:55,020 --> 00:42:59,700
you're interested in being a first-time

1013
00:42:57,060 --> 00:43:02,580
or many time open source contributor to

1014
00:42:59,700 --> 00:43:05,220
I would love to collaborate with you it

1015
00:43:02,580 --> 00:43:07,529
is actually a project with an API allows

1016
00:43:05,220 --> 00:43:09,120
you to sign up and send profiles to this

1017
00:43:07,530 --> 00:43:10,109
and then it will run a bunch of tests on

1018
00:43:09,120 --> 00:43:12,420
the profile and

1019
00:43:10,109 --> 00:43:14,009
SCOR the serverless sandbox and i made

1020
00:43:12,420 --> 00:43:16,230
this in an abstract way so that it can

1021
00:43:14,009 --> 00:43:18,029
run in any container environment so you

1022
00:43:16,230 --> 00:43:20,460
could really use this to test any

1023
00:43:18,029 --> 00:43:22,499
serverless engine out there and get back

1024
00:43:20,460 --> 00:43:24,749
an A through F grade based on some

1025
00:43:22,499 --> 00:43:28,499
opinions that I have that are actually

1026
00:43:24,749 --> 00:43:30,209
derived from the docker cis benchmark so

1027
00:43:28,499 --> 00:43:31,919
if you think this is cool

1028
00:43:30,210 --> 00:43:34,170
sign up for my mailing list on threat

1029
00:43:31,920 --> 00:43:35,910
response cloud that's my website for the

1030
00:43:34,170 --> 00:43:41,999
open source project that I presented

1031
00:43:35,910 --> 00:43:43,828
here last year and the year before yeah

1032
00:43:41,999 --> 00:43:47,430
so how did the security feature stack up

1033
00:43:43,829 --> 00:43:50,420
across vendors this is a cool slide to

1034
00:43:47,430 --> 00:43:52,589
tweet this is how all the vendors

1035
00:43:50,420 --> 00:43:54,660
implement the controls I think are most

1036
00:43:52,589 --> 00:43:57,630
important so none of them are strict the

1037
00:43:54,660 --> 00:43:59,399
language that's executing this is bad

1038
00:43:57,630 --> 00:44:01,019
only some of them have read-only file

1039
00:43:59,400 --> 00:44:04,680
systems all of them actually to their

1040
00:44:01,019 --> 00:44:07,379
credit do patch very frequently AWS has

1041
00:44:04,680 --> 00:44:09,058
the most granular I am AWS is the only

1042
00:44:07,380 --> 00:44:12,150
one that you can deploy functions that

1043
00:44:09,059 --> 00:44:13,829
don't have internet egress none of them

1044
00:44:12,150 --> 00:44:14,999
have immutable environment variables and

1045
00:44:13,829 --> 00:44:15,900
that's not really the vendors fault

1046
00:44:14,999 --> 00:44:18,209
that's just kind of the way their

1047
00:44:15,900 --> 00:44:20,039
operating systems work so if you want to

1048
00:44:18,210 --> 00:44:21,599
give something back to the world give a

1049
00:44:20,039 --> 00:44:23,549
PR to the Linux kernel that makes

1050
00:44:21,599 --> 00:44:25,140
environment variables no longer writable

1051
00:44:23,549 --> 00:44:28,559
sometimes I hear this is an impossible

1052
00:44:25,140 --> 00:44:29,879
problem to solve because things and

1053
00:44:28,559 --> 00:44:33,390
almost all of them have some kind of

1054
00:44:29,880 --> 00:44:34,920
warmness concept so if I could ask the

1055
00:44:33,390 --> 00:44:37,440
vendors to do things for me in this

1056
00:44:34,920 --> 00:44:39,359
magical world where I can get all of

1057
00:44:37,440 --> 00:44:42,900
Amazon to deliver me a feature what

1058
00:44:39,359 --> 00:44:44,578
would I ask for I would ask for any

1059
00:44:42,900 --> 00:44:48,119
control that requires out of sandbox

1060
00:44:44,579 --> 00:44:50,039
levels of access to implement so that

1061
00:44:48,119 --> 00:44:52,799
would include things like native code

1062
00:44:50,039 --> 00:44:54,299
signing protection so if I use PK I to

1063
00:44:52,799 --> 00:44:57,359
sign my code I don't want it to execute

1064
00:44:54,299 --> 00:44:59,038
if it's not mine

1065
00:44:57,359 --> 00:45:01,529
I'd like a mutable environment variable

1066
00:44:59,039 --> 00:45:03,480
so I know it's hard but you know they

1067
00:45:01,529 --> 00:45:05,039
have lots of employees I'd like the

1068
00:45:03,480 --> 00:45:07,680
ability to choose cold-start

1069
00:45:05,039 --> 00:45:10,109
in favor of security so that warmness

1070
00:45:07,680 --> 00:45:11,640
capability we talked about that's in

1071
00:45:10,109 --> 00:45:13,440
favor of performance if I don't need it

1072
00:45:11,640 --> 00:45:15,720
I'd like to be able to choose to turn it

1073
00:45:13,440 --> 00:45:18,089
off maybe I'd even like to pay less for

1074
00:45:15,720 --> 00:45:19,828
that I'd like the ability to kill any

1075
00:45:18,089 --> 00:45:21,509
process that's not executing in the

1076
00:45:19,829 --> 00:45:24,179
language that the runtime

1077
00:45:21,509 --> 00:45:26,130
has selected automatically and I'd like

1078
00:45:24,179 --> 00:45:28,499
more transparency in the patch cycle and

1079
00:45:26,130 --> 00:45:30,419
trade secrets of the run time because

1080
00:45:28,499 --> 00:45:32,038
the more things I know is a consumer the

1081
00:45:30,419 --> 00:45:35,269
better choices I can make about the risk

1082
00:45:32,039 --> 00:45:39,630
of running things in that environment so

1083
00:45:35,269 --> 00:45:42,299
should you use this probably it's

1084
00:45:39,630 --> 00:45:44,729
probably still better than startup size

1085
00:45:42,299 --> 00:45:47,909
to OPSEC or something and being able to

1086
00:45:44,729 --> 00:45:50,459
lead on a vendor for this is is still

1087
00:45:47,909 --> 00:45:54,059
good in most cases but you can limit the

1088
00:45:50,459 --> 00:45:56,399
blast radius of these attacks you can

1089
00:45:54,059 --> 00:45:57,899
use event-driven security in Amazon like

1090
00:45:56,399 --> 00:45:59,939
cloud watch events cloud trail and

1091
00:45:57,899 --> 00:46:02,249
automated response like the project I

1092
00:45:59,939 --> 00:46:03,779
make threat response remember that name

1093
00:46:02,249 --> 00:46:06,109
threat response threat response threat

1094
00:46:03,779 --> 00:46:10,199
response I make an auto I our pipeline

1095
00:46:06,109 --> 00:46:12,719
for this stuff so I'll leave you with

1096
00:46:10,199 --> 00:46:14,549
this one last quote before I take a few

1097
00:46:12,719 --> 00:46:16,319
questions which is that modern security

1098
00:46:14,549 --> 00:46:18,299
does not resemble high walls or strong

1099
00:46:16,319 --> 00:46:20,279
doors but rather bells on strings that

1100
00:46:18,299 --> 00:46:24,509
ring each time an attacker moves forward

1101
00:46:20,279 --> 00:46:25,979
so all these people contributed to my

1102
00:46:24,509 --> 00:46:27,269
project there's actually a couple people

1103
00:46:25,979 --> 00:46:31,769
here today that contributed to my

1104
00:46:27,269 --> 00:46:33,359
project my boss Jeff Breiner and Danny

1105
00:46:31,769 --> 00:46:35,939
Hartnell from Mozilla

1106
00:46:33,359 --> 00:46:37,348
both were contributors to this profiling

1107
00:46:35,939 --> 00:46:39,749
project I could never have done this

1108
00:46:37,349 --> 00:46:41,639
alone it was a ton of work and also my

1109
00:46:39,749 --> 00:46:43,678
co-presenter Graham Jones who works for

1110
00:46:41,639 --> 00:46:45,929
a Portland based company legit script

1111
00:46:43,679 --> 00:46:47,009
was my co-presenter at blackhat and he

1112
00:46:45,929 --> 00:46:50,089
did the lion's share of the Azure

1113
00:46:47,009 --> 00:46:53,459
research so I got to mention him

1114
00:46:50,089 --> 00:46:56,339
so vendors were really nice - thank you

1115
00:46:53,459 --> 00:46:57,689
to them and now I'll take questions I'll

1116
00:46:56,339 --> 00:47:00,209
be in the hall and I'm also running the

1117
00:46:57,689 --> 00:47:04,578
CTF come find me if you want to talk

1118
00:47:00,209 --> 00:47:04,578
about general cloud stuff and things

1119
00:47:11,910 --> 00:47:13,970
you

