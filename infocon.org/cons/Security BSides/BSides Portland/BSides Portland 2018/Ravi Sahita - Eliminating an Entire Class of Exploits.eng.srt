1
00:00:15,710 --> 00:00:21,180
so yeah try to cover and a topic

2
00:00:19,590 --> 00:00:23,160
hopefully you know a lot of a lot of you

3
00:00:21,180 --> 00:00:27,150
guys have heard about over the last you

4
00:00:23,160 --> 00:00:29,430
know five seven years it's good to also

5
00:00:27,150 --> 00:00:31,140
be back at besides I was I was at attend

6
00:00:29,430 --> 00:00:32,610
besides like four or five years back

7
00:00:31,140 --> 00:00:35,030
when we started working on this problem

8
00:00:32,610 --> 00:00:37,470
and it takes quite a while to sort of

9
00:00:35,030 --> 00:00:39,900
you know do some of these things that

10
00:00:37,470 --> 00:00:41,790
where we try to like eliminate a whole

11
00:00:39,900 --> 00:00:45,390
class of you know vulnerabilities or

12
00:00:41,790 --> 00:00:47,489
exploits right so I try to go over some

13
00:00:45,390 --> 00:00:49,920
of those experiences and what what we've

14
00:00:47,489 --> 00:00:54,809
proposed in this in this space to to

15
00:00:49,920 --> 00:00:56,460
address control flow attacks so so I'll

16
00:00:54,809 --> 00:00:58,620
start with the summary there's really

17
00:00:56,460 --> 00:01:01,469
two topics I'm going to cover forces

18
00:00:58,620 --> 00:01:04,110
I'll briefly talk about you know how do

19
00:01:01,469 --> 00:01:05,910
you control for attacks work how do they

20
00:01:04,110 --> 00:01:07,830
actually achieve the goals of the

21
00:01:05,910 --> 00:01:10,890
adversary or thus the software attacker

22
00:01:07,830 --> 00:01:13,470
in this case to essentially do privilege

23
00:01:10,890 --> 00:01:15,840
escalation or essentially break the the

24
00:01:13,470 --> 00:01:18,810
intentions with which the software

25
00:01:15,840 --> 00:01:21,869
defenses were built right and then I'll

26
00:01:18,810 --> 00:01:25,500
use this new capability that is proposed

27
00:01:21,869 --> 00:01:26,580
for future processors where we hope that

28
00:01:25,500 --> 00:01:28,350
with the right amount of software

29
00:01:26,580 --> 00:01:31,650
ingredients in place it can actually

30
00:01:28,350 --> 00:01:34,830
address this type of exploit class

31
00:01:31,650 --> 00:01:36,810
completely and hopefully move software

32
00:01:34,830 --> 00:01:39,570
into a much better place in terms of

33
00:01:36,810 --> 00:01:41,100
being able to defend both at the kernel

34
00:01:39,570 --> 00:01:46,770
level as well as at the application

35
00:01:41,100 --> 00:01:49,889
level so so let's look at sort of the

36
00:01:46,770 --> 00:01:51,360
the evolution of of attacks right so you

37
00:01:49,890 --> 00:01:52,680
know for people who have been in this in

38
00:01:51,360 --> 00:01:56,369
the security space or in the software

39
00:01:52,680 --> 00:01:58,320
security space for a while we know this

40
00:01:56,369 --> 00:02:01,399
is sort of has always been sort of an

41
00:01:58,320 --> 00:02:03,839
arms race right there there have been

42
00:02:01,399 --> 00:02:05,970
you know approaches where people would

43
00:02:03,840 --> 00:02:08,489
do sort of trivial attack so it was like

44
00:02:05,970 --> 00:02:10,829
stack smashing or executing data off of

45
00:02:08,489 --> 00:02:12,900
the stack and you know CPU designers

46
00:02:10,829 --> 00:02:14,280
looked at and they said that's kind of

47
00:02:12,900 --> 00:02:16,410
dumb I mean that should just not be

48
00:02:14,280 --> 00:02:18,239
allowed to begin with right and there

49
00:02:16,410 --> 00:02:22,019
were capabilities put in place to stop

50
00:02:18,239 --> 00:02:23,310
the execution of the stack so that

51
00:02:22,019 --> 00:02:25,380
address a lot of the data execution

52
00:02:23,310 --> 00:02:27,840
problem in general right

53
00:02:25,380 --> 00:02:31,460
you know a single bit was added into the

54
00:02:27,840 --> 00:02:34,800
into the OS page tables even to

55
00:02:31,460 --> 00:02:36,120
basically block execution off of the off

56
00:02:34,800 --> 00:02:38,310
of data regions right because data

57
00:02:36,120 --> 00:02:39,720
should never really be executable unless

58
00:02:38,310 --> 00:02:41,310
you're doing some really wacky

59
00:02:39,720 --> 00:02:43,140
tamper-resistant programming or

60
00:02:41,310 --> 00:02:45,090
something like that you know even there

61
00:02:43,140 --> 00:02:48,510
you need to like convert your code you

62
00:02:45,090 --> 00:02:50,820
know data to execute code injection

63
00:02:48,510 --> 00:02:52,950
attacks were then blocked by people

64
00:02:50,820 --> 00:02:55,200
doing additional additional things to

65
00:02:52,950 --> 00:02:57,179
essentially you know add in safe

66
00:02:55,200 --> 00:02:59,549
exception handling or just paste

67
00:02:57,180 --> 00:03:01,530
randomization adding code integrity

68
00:02:59,550 --> 00:03:03,780
checks things like that where you know

69
00:03:01,530 --> 00:03:06,390
it sort of made sense to know what

70
00:03:03,780 --> 00:03:07,770
you're executing right for once so you

71
00:03:06,390 --> 00:03:09,540
know people who do measurement of the

72
00:03:07,770 --> 00:03:11,580
code when it was being loaded or

73
00:03:09,540 --> 00:03:13,620
unloaded off of the disk operating

74
00:03:11,580 --> 00:03:15,330
systems added driver signing and things

75
00:03:13,620 --> 00:03:16,770
like that there you would validate the

76
00:03:15,330 --> 00:03:20,340
code before you would execute all right

77
00:03:16,770 --> 00:03:21,810
so pretty sort of standard sanity check

78
00:03:20,340 --> 00:03:25,320
kind of things that that should be

79
00:03:21,810 --> 00:03:26,610
performed right but as we were saying

80
00:03:25,320 --> 00:03:28,079
this is sort of an arms race and our

81
00:03:26,610 --> 00:03:30,450
attackers keep evolving as well they're

82
00:03:28,080 --> 00:03:31,980
not sort of standing standing in one

83
00:03:30,450 --> 00:03:33,660
place right as defenses are being put in

84
00:03:31,980 --> 00:03:35,700
place somebody will figure out hey how

85
00:03:33,660 --> 00:03:37,200
can I mean people are creative hackers

86
00:03:35,700 --> 00:03:39,690
are creative you know they'll figure out

87
00:03:37,200 --> 00:03:41,910
like hey what can I do that breaks this

88
00:03:39,690 --> 00:03:43,530
this new set of defenses right so a lot

89
00:03:41,910 --> 00:03:46,260
of control flow attacks were sort of the

90
00:03:43,530 --> 00:03:50,250
new new realm where people people move

91
00:03:46,260 --> 00:03:51,899
to so let's look at a brief introduction

92
00:03:50,250 --> 00:03:54,600
to like how control for attacks really

93
00:03:51,900 --> 00:03:56,550
be here so when you write code and

94
00:03:54,600 --> 00:03:58,530
you've me write in any language you know

95
00:03:56,550 --> 00:04:00,540
high level language low level language

96
00:03:58,530 --> 00:04:01,830
but eventually and ends up in some sort

97
00:04:00,540 --> 00:04:04,620
of machine code write the dual machine

98
00:04:01,830 --> 00:04:07,230
excuse and the programmer already always

99
00:04:04,620 --> 00:04:08,730
writes code in a certain way where you

100
00:04:07,230 --> 00:04:10,140
know you know you use a compiler it gets

101
00:04:08,730 --> 00:04:12,030
translated but there's still some

102
00:04:10,140 --> 00:04:13,829
intention that the programmer has in you

103
00:04:12,030 --> 00:04:18,450
know what order the instructions should

104
00:04:13,830 --> 00:04:20,609
execute it well an interesting property

105
00:04:18,450 --> 00:04:22,469
and attackers can can use is they don't

106
00:04:20,608 --> 00:04:24,270
really have to follow those rules that

107
00:04:22,470 --> 00:04:26,820
the programmer set in place so they can

108
00:04:24,270 --> 00:04:29,190
execute code from any place that they

109
00:04:26,820 --> 00:04:31,469
want once that code is executable on

110
00:04:29,190 --> 00:04:34,260
your system right so that's sort of the

111
00:04:31,470 --> 00:04:35,640
main property that attackers used in

112
00:04:34,260 --> 00:04:37,760
this class of exploits called return

113
00:04:35,640 --> 00:04:40,490
oriented

114
00:04:37,760 --> 00:04:43,430
where if you see this this you know bite

115
00:04:40,490 --> 00:04:45,320
sequence the yellow instruction is what

116
00:04:43,430 --> 00:04:47,510
the programmer intended it's moving some

117
00:04:45,320 --> 00:04:49,940
some you know string you know some some

118
00:04:47,510 --> 00:04:53,810
value into a register in the CPU right

119
00:04:49,940 --> 00:04:55,310
it could be reading that value but if

120
00:04:53,810 --> 00:04:56,930
the attacker jumps into the middle of

121
00:04:55,310 --> 00:05:01,160
that code sequence starting at like the

122
00:04:56,930 --> 00:05:03,860
the hex 41 bytes the machine starts

123
00:05:01,160 --> 00:05:06,380
executing from there and what the

124
00:05:03,860 --> 00:05:08,240
Machine sees as interprets as execution

125
00:05:06,380 --> 00:05:10,130
of the instructions from that point on

126
00:05:08,240 --> 00:05:13,130
is completely different from what the

127
00:05:10,130 --> 00:05:15,700
programmer originally intended so what

128
00:05:13,130 --> 00:05:19,280
the attacker executes in this case a

129
00:05:15,700 --> 00:05:21,170
move of a register into that memory at

130
00:05:19,280 --> 00:05:23,690
that offset and then followed by a

131
00:05:21,170 --> 00:05:28,370
return right so the c3 is a very

132
00:05:23,690 --> 00:05:29,750
interesting by pattern in in the x86

133
00:05:28,370 --> 00:05:33,620
architecture because it essentially

134
00:05:29,750 --> 00:05:34,940
transfers control to some to some

135
00:05:33,620 --> 00:05:37,190
different location right it's called an

136
00:05:34,940 --> 00:05:41,000
indirect branch because you have a you

137
00:05:37,190 --> 00:05:42,500
have a programmer value that the program

138
00:05:41,000 --> 00:05:43,940
execution goes through that's not really

139
00:05:42,500 --> 00:05:45,350
under the control of the programmer at

140
00:05:43,940 --> 00:05:48,890
that point it's dynamically changing

141
00:05:45,350 --> 00:05:50,780
right so let's see how how that gets

142
00:05:48,890 --> 00:05:52,490
used and by the way the term for that in

143
00:05:50,780 --> 00:05:54,260
this in the terminology you're going to

144
00:05:52,490 --> 00:05:55,640
use as a gadget because if this sequence

145
00:05:54,260 --> 00:05:57,770
is very interesting where you can

146
00:05:55,640 --> 00:06:00,740
execute one or more instructions

147
00:05:57,770 --> 00:06:04,130
followed by a return to a next to the

148
00:06:00,740 --> 00:06:05,840
next block of code right so let's see

149
00:06:04,130 --> 00:06:07,850
how we can use the attacker can use that

150
00:06:05,840 --> 00:06:10,239
return so let's say I give you a body of

151
00:06:07,850 --> 00:06:13,130
code you know it's let's say you know

152
00:06:10,240 --> 00:06:15,830
50,000 instructions right 50,000 bytes

153
00:06:13,130 --> 00:06:17,480
of machine code and you can run you can

154
00:06:15,830 --> 00:06:22,460
scan through that code and you can find

155
00:06:17,480 --> 00:06:24,920
all the places where in the code right

156
00:06:22,460 --> 00:06:26,630
that's an interesting pattern yeah

157
00:06:24,920 --> 00:06:29,300
thanks

158
00:06:26,630 --> 00:06:31,130
because now you can you can now work

159
00:06:29,300 --> 00:06:33,230
your way back from that instruction and

160
00:06:31,130 --> 00:06:35,750
you can find all the interesting gadgets

161
00:06:33,230 --> 00:06:37,880
that are present in that body of code so

162
00:06:35,750 --> 00:06:39,500
how can how can an attacker use it so if

163
00:06:37,880 --> 00:06:40,790
you recall we already took care of one

164
00:06:39,500 --> 00:06:43,040
problem where we made the stack not

165
00:06:40,790 --> 00:06:44,960
executable but remember that the stack

166
00:06:43,040 --> 00:06:47,060
is still readable and writeable so if

167
00:06:44,960 --> 00:06:49,340
the attacker can overwrite can use some

168
00:06:47,060 --> 00:06:51,590
logic flaw in some program or

169
00:06:49,340 --> 00:06:54,169
in the kernel right and you can load up

170
00:06:51,590 --> 00:06:57,138
the tea stack with the set of return

171
00:06:54,169 --> 00:06:59,990
addresses right if you combine the fact

172
00:06:57,139 --> 00:07:01,550
that the way the stack behaves is when

173
00:06:59,990 --> 00:07:03,410
you execute a return instruction the

174
00:07:01,550 --> 00:07:05,570
processor takes takes whatever addresses

175
00:07:03,410 --> 00:07:08,300
on the stack and transfers control to

176
00:07:05,570 --> 00:07:09,770
that location in the code right so now

177
00:07:08,300 --> 00:07:11,360
we take these two pieces together it's

178
00:07:09,770 --> 00:07:13,460
like you have the ability to load up the

179
00:07:11,360 --> 00:07:15,590
stack with a bunch of bunch of addresses

180
00:07:13,460 --> 00:07:18,888
of your choice of the attackers choice

181
00:07:15,590 --> 00:07:20,989
and you have a priori analyzed that code

182
00:07:18,889 --> 00:07:22,460
that you're trying to attack with where

183
00:07:20,990 --> 00:07:24,020
you know what kind of these and where

184
00:07:22,460 --> 00:07:26,840
these interesting gadgets lie in that

185
00:07:24,020 --> 00:07:29,240
code right so you can just basically put

186
00:07:26,840 --> 00:07:32,119
those two pieces together and you can

187
00:07:29,240 --> 00:07:34,340
write your own program on top of the

188
00:07:32,120 --> 00:07:37,280
code that was oddly beautiful right so

189
00:07:34,340 --> 00:07:38,840
that that's really a paradigm or or a

190
00:07:37,280 --> 00:07:41,299
model that attackers use which is called

191
00:07:38,840 --> 00:07:43,219
return oriented programming so the

192
00:07:41,300 --> 00:07:45,080
closest analogy is like a ransomware

193
00:07:43,220 --> 00:07:46,370
node right if you look at a ransom where

194
00:07:45,080 --> 00:07:47,750
note the way it's constructed you know

195
00:07:46,370 --> 00:07:49,850
the old-style ones that you would see in

196
00:07:47,750 --> 00:07:51,350
like you know old cell movies where

197
00:07:49,850 --> 00:07:53,030
somebody wants to send her and somewhere

198
00:07:51,350 --> 00:07:54,650
note they would copy letters from

199
00:07:53,030 --> 00:07:56,570
different you know magazines and

200
00:07:54,650 --> 00:07:58,549
newspaper articles and stick it together

201
00:07:56,570 --> 00:08:00,590
and then you sort of know wouldn't tell

202
00:07:58,550 --> 00:08:02,660
who wrote this because it was completely

203
00:08:00,590 --> 00:08:04,400
you know unintelligible right you didn't

204
00:08:02,660 --> 00:08:05,750
know the handwriting it's kind of a

205
00:08:04,400 --> 00:08:08,239
similar analogy in the digital space

206
00:08:05,750 --> 00:08:09,860
where you have code that's executable if

207
00:08:08,240 --> 00:08:12,500
you can find and analyze the code

208
00:08:09,860 --> 00:08:13,940
offline and exploit a vulnerability in

209
00:08:12,500 --> 00:08:16,280
the program then you can write your own

210
00:08:13,940 --> 00:08:19,930
code on that system you can literally

211
00:08:16,280 --> 00:08:22,789
build your own program at runtime right

212
00:08:19,930 --> 00:08:24,950
so that's that's pretty scary because

213
00:08:22,789 --> 00:08:26,570
now the attacker can essentially just

214
00:08:24,950 --> 00:08:29,409
bounce off these gadgets and execute

215
00:08:26,570 --> 00:08:31,639
completely different different codes so

216
00:08:29,410 --> 00:08:34,099
so any of our you know previous

217
00:08:31,639 --> 00:08:35,479
techniques of you know code signing and

218
00:08:34,099 --> 00:08:38,300
all these things are sort of out out of

219
00:08:35,479 --> 00:08:39,680
the door because you verified your code

220
00:08:38,299 --> 00:08:41,478
but it doesn't really help because this

221
00:08:39,679 --> 00:08:45,319
is a runtime exploit and it uses your

222
00:08:41,479 --> 00:08:46,430
verified code to begin with so this this

223
00:08:45,320 --> 00:08:50,720
technique is called written read

224
00:08:46,430 --> 00:08:52,670
programming or ROP or Rob and

225
00:08:50,720 --> 00:08:54,560
unfortunately there's not just one type

226
00:08:52,670 --> 00:08:55,849
there's actually three types of them out

227
00:08:54,560 --> 00:08:57,380
there right because there are many types

228
00:08:55,850 --> 00:08:59,900
of indirect branches so wherever you

229
00:08:57,380 --> 00:09:01,490
have indirect branches you can exploit

230
00:08:59,900 --> 00:09:03,050
this type of attack so there's 300

231
00:09:01,490 --> 00:09:05,480
indirect branches

232
00:09:03,050 --> 00:09:07,760
in in intel architecture and there's

233
00:09:05,480 --> 00:09:09,080
similar sort of indirect branches and

234
00:09:07,760 --> 00:09:10,959
other architectures like arm as well

235
00:09:09,080 --> 00:09:14,149
right so this is sort of a general from

236
00:09:10,959 --> 00:09:18,079
the other variants are called cop and

237
00:09:14,149 --> 00:09:19,610
job right basically based on the other

238
00:09:18,080 --> 00:09:21,380
two types of indirect branches a call

239
00:09:19,610 --> 00:09:22,970
oriented programming or a jump oriented

240
00:09:21,380 --> 00:09:24,439
programming which essentially worked the

241
00:09:22,970 --> 00:09:26,120
same way but instead of using the stack

242
00:09:24,440 --> 00:09:28,310
they would use some corrupted memory

243
00:09:26,120 --> 00:09:29,720
somewhere in some pointer table and then

244
00:09:28,310 --> 00:09:31,760
have the call essentially use that

245
00:09:29,720 --> 00:09:37,010
corrupted data to go essentially to the

246
00:09:31,760 --> 00:09:39,950
similar similar kind of gadget so how do

247
00:09:37,010 --> 00:09:42,700
attackers use Rob so typically what

248
00:09:39,950 --> 00:09:45,170
happens is they just keep track of time

249
00:09:42,700 --> 00:09:47,360
the exploits are typically broken down

250
00:09:45,170 --> 00:09:49,160
into two stages once you figure out that

251
00:09:47,360 --> 00:09:50,899
there is some sort of a buffer flow or

252
00:09:49,160 --> 00:09:53,990
there's some exploit flaw that you can

253
00:09:50,899 --> 00:09:55,190
use in some song logic you write a first

254
00:09:53,990 --> 00:09:56,510
stage drop and you can see a lot of

255
00:09:55,190 --> 00:09:58,730
these rock constructions rather and

256
00:09:56,510 --> 00:10:01,010
Metis flight and other other tools if

257
00:09:58,730 --> 00:10:03,320
you've used those to see if you want to

258
00:10:01,010 --> 00:10:05,060
see like examples of these the first

259
00:10:03,320 --> 00:10:07,370
stage dropped will typically execute and

260
00:10:05,060 --> 00:10:10,040
invoke really critical system calls that

261
00:10:07,370 --> 00:10:11,750
open up the doorway is for for dropping

262
00:10:10,040 --> 00:10:12,949
down the defenses to your sort of to

263
00:10:11,750 --> 00:10:15,440
take your machine back to the stone

264
00:10:12,950 --> 00:10:17,990
Age's effectively right so if you can if

265
00:10:15,440 --> 00:10:19,760
you can execute this first stage Rob you

266
00:10:17,990 --> 00:10:21,589
can start doing either second stage drop

267
00:10:19,760 --> 00:10:23,600
or just rely on shellcode from that

268
00:10:21,589 --> 00:10:25,910
point on because you can open up memory

269
00:10:23,600 --> 00:10:27,589
to become executable again you can you

270
00:10:25,910 --> 00:10:31,459
can make heap executable again and

271
00:10:27,589 --> 00:10:33,350
things like that right and and sometimes

272
00:10:31,459 --> 00:10:35,359
people use second stage Rob as well but

273
00:10:33,350 --> 00:10:37,100
then once you've done those two stages

274
00:10:35,360 --> 00:10:39,079
your your result essentially is that you

275
00:10:37,100 --> 00:10:40,279
can take privilege control of that

276
00:10:39,079 --> 00:10:41,810
thread whether it's a browser

277
00:10:40,279 --> 00:10:44,300
application or you know other

278
00:10:41,810 --> 00:10:49,699
application or even the kernel in many

279
00:10:44,300 --> 00:10:53,209
cases so you know a lot of tools have

280
00:10:49,699 --> 00:10:55,069
been have been created by you know many

281
00:10:53,209 --> 00:10:57,410
many sort of researchers and analysts

282
00:10:55,070 --> 00:11:01,160
out there to understand how you can

283
00:10:57,410 --> 00:11:02,750
actually make Rob easier right so you

284
00:11:01,160 --> 00:11:04,640
know anytime like people find out a

285
00:11:02,750 --> 00:11:06,260
particular attack class you know like

286
00:11:04,640 --> 00:11:08,060
people wrote Metasploit and things like

287
00:11:06,260 --> 00:11:09,649
that people have also written compilers

288
00:11:08,060 --> 00:11:11,540
for Rob so you can actually take a body

289
00:11:09,649 --> 00:11:13,910
of code let's say you take some version

290
00:11:11,540 --> 00:11:16,459
of Linux so you take some version of C

291
00:11:13,910 --> 00:11:16,910
library and you can upload it to a

292
00:11:16,459 --> 00:11:18,290
website

293
00:11:16,910 --> 00:11:20,449
and it will actually dump out all the

294
00:11:18,290 --> 00:11:22,490
gadgets for you it will tell you like

295
00:11:20,450 --> 00:11:25,310
hey if you wanted gadgets off size five

296
00:11:22,490 --> 00:11:26,690
or search for gadgets up to size five it

297
00:11:25,310 --> 00:11:28,489
will drop on all those gadgets for you

298
00:11:26,690 --> 00:11:30,920
and then you can kind of combine that

299
00:11:28,490 --> 00:11:32,810
with other other tools and there's many

300
00:11:30,920 --> 00:11:34,610
versions of of that the other thing we

301
00:11:32,810 --> 00:11:36,530
found was why we started working on this

302
00:11:34,610 --> 00:11:38,600
problem was we said hey if you look at

303
00:11:36,530 --> 00:11:39,829
the type of this type of attack it's

304
00:11:38,600 --> 00:11:42,680
really a fundamental attack that

305
00:11:39,830 --> 00:11:44,660
software can't really defend against and

306
00:11:42,680 --> 00:11:46,939
we saw that with browsers and and many

307
00:11:44,660 --> 00:11:52,069
other zero-days being using this kind of

308
00:11:46,940 --> 00:11:53,990
raw attacks so that was sort of our key

309
00:11:52,070 --> 00:11:56,000
observation is that pure pure software

310
00:11:53,990 --> 00:11:58,730
mitigations are falling short in this

311
00:11:56,000 --> 00:12:00,920
space because if you have software

312
00:11:58,730 --> 00:12:02,660
depending on software for security it's

313
00:12:00,920 --> 00:12:04,849
sort of a you know an arms race you

314
00:12:02,660 --> 00:12:06,199
can't win because at some point your

315
00:12:04,850 --> 00:12:08,150
defenses are going to break down because

316
00:12:06,200 --> 00:12:09,490
you know you can't rely on the on the

317
00:12:08,150 --> 00:12:11,420
software to ensure that your

318
00:12:09,490 --> 00:12:13,540
instructions are executing in the right

319
00:12:11,420 --> 00:12:15,680
way and things like that right so it's

320
00:12:13,540 --> 00:12:18,319
there's there's a couple of different

321
00:12:15,680 --> 00:12:20,120
other artifacts to consider where why

322
00:12:18,320 --> 00:12:21,590
does this attack work because we have

323
00:12:20,120 --> 00:12:23,300
sort of you know we don't have any any

324
00:12:21,590 --> 00:12:25,790
force instruction alignment in the

325
00:12:23,300 --> 00:12:27,560
architecture right it's a very dense

326
00:12:25,790 --> 00:12:29,709
instruction set so you have a lot of

327
00:12:27,560 --> 00:12:32,239
combinations you can you can search for

328
00:12:29,710 --> 00:12:33,740
we have a one byte return instruction

329
00:12:32,240 --> 00:12:34,670
the c3 that I showed earlier which we

330
00:12:33,740 --> 00:12:36,590
have to maintain because of

331
00:12:34,670 --> 00:12:39,170
compatibility right we cannot say hey

332
00:12:36,590 --> 00:12:40,370
let's use a 15 byte return instruction

333
00:12:39,170 --> 00:12:41,569
that might solve the problem but then

334
00:12:40,370 --> 00:12:44,000
you break software all over the place

335
00:12:41,570 --> 00:12:46,160
right so we have to you know make sure

336
00:12:44,000 --> 00:12:47,750
this works with with the existing

337
00:12:46,160 --> 00:12:49,280
software and we can't change the ABI

338
00:12:47,750 --> 00:12:51,050
like we couldn't say hey let's just

339
00:12:49,280 --> 00:12:54,199
switch over and make use a completely

340
00:12:51,050 --> 00:12:55,520
different stack right and change the

341
00:12:54,200 --> 00:12:57,620
programming model because that would

342
00:12:55,520 --> 00:12:59,750
break the Linux ABI the windows API and

343
00:12:57,620 --> 00:13:01,550
everything else right so those were sort

344
00:12:59,750 --> 00:13:04,340
of some of the constraints that that we

345
00:13:01,550 --> 00:13:06,949
had to work with so we came up with this

346
00:13:04,340 --> 00:13:09,400
architecture called CD that's documented

347
00:13:06,950 --> 00:13:13,430
you know in a public spec

348
00:13:09,400 --> 00:13:15,590
now we updated the version last year and

349
00:13:13,430 --> 00:13:19,060
the idea behind CD was essentially to

350
00:13:15,590 --> 00:13:23,000
you know take the intuition or take the

351
00:13:19,060 --> 00:13:25,910
explicit information that compilers have

352
00:13:23,000 --> 00:13:27,530
from how the program programmer intended

353
00:13:25,910 --> 00:13:29,740
the program to operate and encode that

354
00:13:27,530 --> 00:13:32,610
into into instructions that is used

355
00:13:29,740 --> 00:13:35,710
to enforce those properties at runtime

356
00:13:32,610 --> 00:13:36,820
so the first intrinsic is is a new set

357
00:13:35,710 --> 00:13:40,000
of instructions called

358
00:13:36,820 --> 00:13:42,310
n branch and branch 64 and branch 32

359
00:13:40,000 --> 00:13:44,200
which essentially act you can think of

360
00:13:42,310 --> 00:13:45,880
these are these are like landing pads or

361
00:13:44,200 --> 00:13:47,380
landing tanks so when you see an

362
00:13:45,880 --> 00:13:49,420
indirect branch happen which takes your

363
00:13:47,380 --> 00:13:52,270
execution control from point A to point

364
00:13:49,420 --> 00:13:54,099
B in the program what this instruction

365
00:13:52,270 --> 00:13:55,540
lets you enforce is that when your

366
00:13:54,100 --> 00:13:58,150
indirect branch occurs that you actually

367
00:13:55,540 --> 00:14:01,240
land on an N branch instruction so it

368
00:13:58,150 --> 00:14:03,490
effectively sets off it arm does the

369
00:14:01,240 --> 00:14:05,410
system or arms the machine when indirect

370
00:14:03,490 --> 00:14:06,970
branch happens and it disarms the

371
00:14:05,410 --> 00:14:08,949
machine when then when it sees the N

372
00:14:06,970 --> 00:14:10,960
branch right and if the machine doesn't

373
00:14:08,950 --> 00:14:12,550
see that n branch in the execution

374
00:14:10,960 --> 00:14:14,490
sequence it generates an exception so

375
00:14:12,550 --> 00:14:17,079
it's like it's a really really simple

376
00:14:14,490 --> 00:14:20,560
construct right and it's really really

377
00:14:17,080 --> 00:14:22,390
there that's why very low you know cost

378
00:14:20,560 --> 00:14:24,819
in terms of tech implement performance

379
00:14:22,390 --> 00:14:26,980
and things like that but it's very

380
00:14:24,820 --> 00:14:29,920
powerful because now for for the first

381
00:14:26,980 --> 00:14:32,410
time you know we can actually enforce

382
00:14:29,920 --> 00:14:34,030
things in software that we can inline

383
00:14:32,410 --> 00:14:35,920
enforce those policies that cannot be

384
00:14:34,030 --> 00:14:38,380
bypassed we just by simple circumvention

385
00:14:35,920 --> 00:14:39,790
so today if I have let's say a V

386
00:14:38,380 --> 00:14:42,250
software that I'm using and the EB

387
00:14:39,790 --> 00:14:43,540
software wants to hook certain API is to

388
00:14:42,250 --> 00:14:45,070
enforce that you know I'm doing some

389
00:14:43,540 --> 00:14:46,599
sort of filter filtering off like

390
00:14:45,070 --> 00:14:47,740
parameters right I'm checking the

391
00:14:46,600 --> 00:14:49,900
parameters that have been passed in

392
00:14:47,740 --> 00:14:51,610
today I can very easily just circumvent

393
00:14:49,900 --> 00:14:53,949
that check and nothing will stop the

394
00:14:51,610 --> 00:14:55,870
stopped that occur on the system I can

395
00:14:53,950 --> 00:14:57,700
just jump to like the I can read the

396
00:14:55,870 --> 00:14:59,650
memory at the at the hook point or the

397
00:14:57,700 --> 00:15:03,130
start of the function if I see that the

398
00:14:59,650 --> 00:15:04,900
location is is it has a prequel jump on

399
00:15:03,130 --> 00:15:06,910
it then I know the API is hooked and I

400
00:15:04,900 --> 00:15:08,800
can just jump past that that jump point

401
00:15:06,910 --> 00:15:11,110
and everything will just work from there

402
00:15:08,800 --> 00:15:12,910
right but now with things like in branch

403
00:15:11,110 --> 00:15:14,230
you can actually enforce those checks in

404
00:15:12,910 --> 00:15:16,120
life because the Machine will generate

405
00:15:14,230 --> 00:15:18,160
an exception if your indirect branch

406
00:15:16,120 --> 00:15:20,500
when you called into a DLL and things

407
00:15:18,160 --> 00:15:22,510
like that did not have a landing tag on

408
00:15:20,500 --> 00:15:24,220
the on the other end so this is a

409
00:15:22,510 --> 00:15:26,080
compiler inserted capability so

410
00:15:24,220 --> 00:15:27,580
obviously this requires a recompile

411
00:15:26,080 --> 00:15:28,090
right so this would have to be an

412
00:15:27,580 --> 00:15:31,360
explicit

413
00:15:28,090 --> 00:15:33,250
opt-in capability that somebody wants to

414
00:15:31,360 --> 00:15:34,630
you know harden their code can be

415
00:15:33,250 --> 00:15:36,400
compiled with that version of the

416
00:15:34,630 --> 00:15:39,730
compiler that enforces this this

417
00:15:36,400 --> 00:15:40,959
intrinsic the second one which is the

418
00:15:39,730 --> 00:15:42,950
more interesting one which actually

419
00:15:40,960 --> 00:15:45,170
prevents the drop

420
00:15:42,950 --> 00:15:47,960
like I described earlier is essentially

421
00:15:45,170 --> 00:15:49,969
a shadow stack right so so shadow sacks

422
00:15:47,960 --> 00:15:51,830
have been around you know have been

423
00:15:49,970 --> 00:15:53,930
discussed in like the academia for like

424
00:15:51,830 --> 00:15:56,360
many many years now right and so really

425
00:15:53,930 --> 00:15:58,640
the problem we solved here was more from

426
00:15:56,360 --> 00:16:00,170
the perspective of the Intel Iser how do

427
00:15:58,640 --> 00:16:01,699
we really add the right set of

428
00:16:00,170 --> 00:16:04,400
instructions that as I described earlier

429
00:16:01,700 --> 00:16:06,110
don't break the ABI right so we want to

430
00:16:04,400 --> 00:16:07,430
provide the right intrinsic to software

431
00:16:06,110 --> 00:16:10,070
so that they can actually manage the

432
00:16:07,430 --> 00:16:11,510
shadow stack correctly without breaking

433
00:16:10,070 --> 00:16:14,120
the existing software infrastructure

434
00:16:11,510 --> 00:16:16,340
that we have but still enforce the

435
00:16:14,120 --> 00:16:17,570
security property that attacker should

436
00:16:16,340 --> 00:16:20,210
not be able to use it on or in

437
00:16:17,570 --> 00:16:21,830
programming fundamentals right so with

438
00:16:20,210 --> 00:16:23,720
the way shadow stack essentially works

439
00:16:21,830 --> 00:16:26,960
actually I've described it in animation

440
00:16:23,720 --> 00:16:28,550
since I'm running out of time so let me

441
00:16:26,960 --> 00:16:30,680
show you sort of intuitively what what

442
00:16:28,550 --> 00:16:32,839
end ranch does right so if I have this

443
00:16:30,680 --> 00:16:34,910
this code and you know this is compiled

444
00:16:32,840 --> 00:16:36,560
from what n branch essentially looks

445
00:16:34,910 --> 00:16:38,329
like is those landing tags that that

446
00:16:36,560 --> 00:16:39,770
I've marked with the stars at the

447
00:16:38,330 --> 00:16:42,170
beginning of the exported functions

448
00:16:39,770 --> 00:16:43,760
right so now note that you don't have to

449
00:16:42,170 --> 00:16:45,770
put any branch in functions that are not

450
00:16:43,760 --> 00:16:47,060
indirectly called right because the

451
00:16:45,770 --> 00:16:48,860
function the indirect are directly

452
00:16:47,060 --> 00:16:50,750
called those are sort of enforced

453
00:16:48,860 --> 00:16:52,430
statically in your non writable code to

454
00:16:50,750 --> 00:16:54,890
begin with right it's only interesting

455
00:16:52,430 --> 00:16:56,420
to enforce an branch for functions that

456
00:16:54,890 --> 00:16:59,750
are your that you're exporting that you

457
00:16:56,420 --> 00:17:01,670
expect to be the targets of of indirect

458
00:16:59,750 --> 00:17:04,819
branches right because those are the

459
00:17:01,670 --> 00:17:08,240
ones that can can get and you know can

460
00:17:04,819 --> 00:17:09,919
get attacked right so so this sort of a

461
00:17:08,240 --> 00:17:11,839
transition happens the machine says

462
00:17:09,920 --> 00:17:13,760
everything is fine this is a normal call

463
00:17:11,839 --> 00:17:16,220
indirect call going to an end branch so

464
00:17:13,760 --> 00:17:18,500
it continues normally but if you see

465
00:17:16,220 --> 00:17:20,089
some some indirect call going to some

466
00:17:18,500 --> 00:17:22,069
location where there is an end branch

467
00:17:20,089 --> 00:17:23,869
not present and CT is enabled for that

468
00:17:22,069 --> 00:17:26,540
process context you essentially will get

469
00:17:23,869 --> 00:17:28,850
a control flow exception violation which

470
00:17:26,540 --> 00:17:30,440
is a new violation reported to the OS

471
00:17:28,850 --> 00:17:32,810
right so the operating system will stop

472
00:17:30,440 --> 00:17:34,670
the process at that point and it's a

473
00:17:32,810 --> 00:17:37,070
falling exception so those can go look

474
00:17:34,670 --> 00:17:39,140
at the scenario and see what's going on

475
00:17:37,070 --> 00:17:40,730
and either allow the app to continue or

476
00:17:39,140 --> 00:17:43,130
stop it because obviously it's oh yeah

477
00:17:40,730 --> 00:17:44,960
it was a CT any will apt and it's it's a

478
00:17:43,130 --> 00:17:48,650
violation that it wants to explicitly

479
00:17:44,960 --> 00:17:51,110
disallow the other one is the shadow

480
00:17:48,650 --> 00:17:53,120
stack and that essentially in the in

481
00:17:51,110 --> 00:17:54,860
terms of the software construct is think

482
00:17:53,120 --> 00:17:56,060
of it as a regular stack but it's access

483
00:17:54,860 --> 00:17:57,679
protected and it

484
00:17:56,060 --> 00:17:59,810
only holds the return addresses right so

485
00:17:57,680 --> 00:18:02,450
this is how we could maintain the AVI

486
00:17:59,810 --> 00:18:04,280
and not break the the parameter passing

487
00:18:02,450 --> 00:18:08,060
techniques on the regular regular data

488
00:18:04,280 --> 00:18:09,320
stack so when CET shadow stack is active

489
00:18:08,060 --> 00:18:11,120
you essentially have both the program

490
00:18:09,320 --> 00:18:13,220
stack and the shadow stack and simply

491
00:18:11,120 --> 00:18:16,340
effectively what what CT does when it's

492
00:18:13,220 --> 00:18:18,560
when channel stacks enable is it checks

493
00:18:16,340 --> 00:18:20,300
on on return instruction on that c3

494
00:18:18,560 --> 00:18:21,860
instruction that I showed earlier it

495
00:18:20,300 --> 00:18:23,570
checks a return address from the shadows

496
00:18:21,860 --> 00:18:25,129
stack in the data stack and if there's a

497
00:18:23,570 --> 00:18:27,649
mismatch generates control flow

498
00:18:25,130 --> 00:18:30,440
violation right and if it's correct it

499
00:18:27,650 --> 00:18:32,360
lets it continue as normal the other

500
00:18:30,440 --> 00:18:34,310
important property to note here is for

501
00:18:32,360 --> 00:18:35,659
this construct to work correctly the

502
00:18:34,310 --> 00:18:37,879
shadow stack has to obviously be non

503
00:18:35,660 --> 00:18:39,950
writable completely to software right

504
00:18:37,880 --> 00:18:41,810
otherwise this access control mechanism

505
00:18:39,950 --> 00:18:44,540
doesn't really work right so that's

506
00:18:41,810 --> 00:18:47,330
that's a key property of the the shadow

507
00:18:44,540 --> 00:18:49,100
stack that's enforced through new page

508
00:18:47,330 --> 00:18:50,600
table enforcement mechanisms that go

509
00:18:49,100 --> 00:18:53,030
with this architecture right so though

510
00:18:50,600 --> 00:18:54,949
when the OS creates a data stack in

511
00:18:53,030 --> 00:18:56,360
linear address space it also creates the

512
00:18:54,950 --> 00:18:58,280
shadow stack and marks it as non

513
00:18:56,360 --> 00:19:00,050
writable and turns shadow stack on from

514
00:18:58,280 --> 00:19:02,780
that point you get this property being

515
00:19:00,050 --> 00:19:05,120
enforced so the nice thing about shadow

516
00:19:02,780 --> 00:19:06,200
stack is for the most part the

517
00:19:05,120 --> 00:19:06,830
application doesn't need to be

518
00:19:06,200 --> 00:19:08,660
recompiled

519
00:19:06,830 --> 00:19:11,510
it needs it may need to be recompiled or

520
00:19:08,660 --> 00:19:13,850
free linked with new runtime binaries

521
00:19:11,510 --> 00:19:15,200
right runtime libraries so that your OS

522
00:19:13,850 --> 00:19:17,240
exception handling and things like that

523
00:19:15,200 --> 00:19:18,350
that knows that the shadow stack is

524
00:19:17,240 --> 00:19:19,850
active can work correctly

525
00:19:18,350 --> 00:19:22,040
but for the most part your application

526
00:19:19,850 --> 00:19:27,050
code doesn't need to change which shows

527
00:19:22,040 --> 00:19:29,450
that there's a sort of a final point

528
00:19:27,050 --> 00:19:32,180
here of like whenever we do these kinds

529
00:19:29,450 --> 00:19:33,890
of new instruction set that try to you

530
00:19:32,180 --> 00:19:35,840
know enforce this new kinds of

531
00:19:33,890 --> 00:19:38,150
properties a lot of software potentially

532
00:19:35,840 --> 00:19:39,379
breaks right so something we have to

533
00:19:38,150 --> 00:19:41,750
keep in mind is how do we create this

534
00:19:39,380 --> 00:19:44,780
transition path right so that we say hey

535
00:19:41,750 --> 00:19:46,310
you can go and evil CET for specific

536
00:19:44,780 --> 00:19:48,470
targeted applications or even

537
00:19:46,310 --> 00:19:49,970
applications that may not be completely

538
00:19:48,470 --> 00:19:52,340
ready for seeding right because you may

539
00:19:49,970 --> 00:19:53,900
have legacy binaries or libraries or DLL

540
00:19:52,340 --> 00:19:56,540
that you're using in that process

541
00:19:53,900 --> 00:19:58,610
address space right there have to be you

542
00:19:56,540 --> 00:20:00,050
know supported right so there's a

543
00:19:58,610 --> 00:20:01,790
there's a notion of this like what we

544
00:20:00,050 --> 00:20:04,190
call the legacy compatibility bitmap

545
00:20:01,790 --> 00:20:06,950
it's it's actually like a really really

546
00:20:04,190 --> 00:20:08,300
you know it's it's sort of a bad idea in

547
00:20:06,950 --> 00:20:09,230
the architecture that we don't really

548
00:20:08,300 --> 00:20:11,270
like but

549
00:20:09,230 --> 00:20:13,250
sort of you know you know reality that

550
00:20:11,270 --> 00:20:14,750
we have to deal with that if you really

551
00:20:13,250 --> 00:20:16,010
want your application to be secure you

552
00:20:14,750 --> 00:20:17,750
do not want to turn on like icy

553
00:20:16,010 --> 00:20:19,070
compatibility bitmap for your

554
00:20:17,750 --> 00:20:21,350
application it has to be fully and

555
00:20:19,070 --> 00:20:23,570
completely CET compiled in enable but

556
00:20:21,350 --> 00:20:25,490
the reality is we might see a transition

557
00:20:23,570 --> 00:20:27,409
path where certain applications have to

558
00:20:25,490 --> 00:20:29,480
turn on load libraries that are not

559
00:20:27,410 --> 00:20:30,860
fully CET compatible and then this is a

560
00:20:29,480 --> 00:20:33,140
way for the operating system to say

561
00:20:30,860 --> 00:20:35,209
here's the libraries or code that are

562
00:20:33,140 --> 00:20:37,340
not fully CET compatible so if you do

563
00:20:35,210 --> 00:20:39,799
see a transition into that path look up

564
00:20:37,340 --> 00:20:42,409
this bitmap to distort decide whether to

565
00:20:39,799 --> 00:20:44,629
generate an exception or not right so

566
00:20:42,410 --> 00:20:47,929
gives a flexible path to the OS to

567
00:20:44,630 --> 00:20:50,809
manage that so let's look at some of the

568
00:20:47,929 --> 00:20:52,130
key results and I'm gonna run out of

569
00:20:50,809 --> 00:20:54,590
time so I'm going to just go through

570
00:20:52,130 --> 00:20:56,540
this quickly and I can take questions so

571
00:20:54,590 --> 00:20:59,090
we did a sort of a security analysis of

572
00:20:56,540 --> 00:21:00,918
CET using simulators right and one thing

573
00:20:59,090 --> 00:21:02,870
we realized was we kind of were thinking

574
00:21:00,919 --> 00:21:04,940
about like is shadow stacked by itself

575
00:21:02,870 --> 00:21:06,979
enough or do we also need n branch to be

576
00:21:04,940 --> 00:21:08,600
to be supported even though the

577
00:21:06,980 --> 00:21:09,080
architecture allows you to enable one or

578
00:21:08,600 --> 00:21:11,600
the other

579
00:21:09,080 --> 00:21:13,549
right or both what we realized in our

580
00:21:11,600 --> 00:21:15,409
analysis from Linux is that you have to

581
00:21:13,549 --> 00:21:16,610
really a good implementation that's

582
00:21:15,410 --> 00:21:18,200
using software implementation that's

583
00:21:16,610 --> 00:21:20,209
using CT should turn on both the

584
00:21:18,200 --> 00:21:22,340
capabilities because it's very easy for

585
00:21:20,210 --> 00:21:24,350
an attacker if you block up to just

586
00:21:22,340 --> 00:21:26,090
pivot over to use copper job and and

587
00:21:24,350 --> 00:21:28,129
really use the same gadgets assets and

588
00:21:26,090 --> 00:21:30,168
we showed that this is some code that we

589
00:21:28,130 --> 00:21:32,660
found in Linux for example that

590
00:21:30,169 --> 00:21:34,370
essentially iterates over an indirect

591
00:21:32,660 --> 00:21:37,130
branch in India which is essentially a

592
00:21:34,370 --> 00:21:39,260
cop right so so if I turned off Rob and

593
00:21:37,130 --> 00:21:41,179
the attacker was forced to using cop and

594
00:21:39,260 --> 00:21:42,530
I did not implement any branch didn't

595
00:21:41,179 --> 00:21:45,020
compile my kernel within branch they

596
00:21:42,530 --> 00:21:47,660
could simply use this this loop here to

597
00:21:45,020 --> 00:21:49,879
invoke this call cause indirect and

598
00:21:47,660 --> 00:21:52,220
invoke literally the same tangents right

599
00:21:49,880 --> 00:21:55,730
so that's a that's an important property

600
00:21:52,220 --> 00:21:57,530
to take together so one thing you guys

601
00:21:55,730 --> 00:21:58,730
might be wondering is okay so what what

602
00:21:57,530 --> 00:22:00,350
am I going to pay for this right what's

603
00:21:58,730 --> 00:22:03,169
the cost of turning this capability on

604
00:22:00,350 --> 00:22:04,760
so what we have done in analysis right

605
00:22:03,169 --> 00:22:06,110
now because we don't have hardware for

606
00:22:04,760 --> 00:22:08,870
this its own it's everything is on

607
00:22:06,110 --> 00:22:11,629
simulators right now we've analyzed the

608
00:22:08,870 --> 00:22:13,760
sort of the 3/3 cost aspects of CT right

609
00:22:11,630 --> 00:22:15,320
one is what's the performance cost for

610
00:22:13,760 --> 00:22:17,240
shadow stack right and we are aiming for

611
00:22:15,320 --> 00:22:19,639
this target to be around less than 2%

612
00:22:17,240 --> 00:22:21,110
what's the power impact that's important

613
00:22:19,640 --> 00:22:22,700
for large data centers that are turning

614
00:22:21,110 --> 00:22:24,260
this on at scale right

615
00:22:22,700 --> 00:22:25,460
and the third one what is the code size

616
00:22:24,260 --> 00:22:27,500
good because if you have really really

617
00:22:25,460 --> 00:22:30,050
small kernels and emitted kernels you

618
00:22:27,500 --> 00:22:31,490
may not be able to take the cost of your

619
00:22:30,050 --> 00:22:33,800
you know your code becoming too bloated

620
00:22:31,490 --> 00:22:34,520
because of adding in branch instructions

621
00:22:33,800 --> 00:22:37,010
things like that

622
00:22:34,520 --> 00:22:38,930
so what we found is for code growth with

623
00:22:37,010 --> 00:22:41,690
G with n branch the Geo mean is about

624
00:22:38,930 --> 00:22:44,810
0.2% with Intel compilers with GC C

625
00:22:41,690 --> 00:22:48,260
compilers it's about 0.4% so that's that

626
00:22:44,810 --> 00:22:52,760
seems you know reasonable for for you

627
00:22:48,260 --> 00:22:54,740
know that kind of defense capability so

628
00:22:52,760 --> 00:22:56,840
last couple of things to end so as I

629
00:22:54,740 --> 00:22:58,700
said the spec is online and you you know

630
00:22:56,840 --> 00:23:00,110
will be great if this community can go

631
00:22:58,700 --> 00:23:03,350
look at the spec and give us feedback

632
00:23:00,110 --> 00:23:06,409
you know it's always good to have sort

633
00:23:03,350 --> 00:23:07,939
of really focused audience look at look

634
00:23:06,410 --> 00:23:09,500
at the spec especially for these kinds

635
00:23:07,940 --> 00:23:12,200
of defense mechanisms right because it's

636
00:23:09,500 --> 00:23:14,360
harder to build defense mechanisms and

637
00:23:12,200 --> 00:23:17,690
it's much straightforward to you know

638
00:23:14,360 --> 00:23:20,090
build one one attack mechanism there's a

639
00:23:17,690 --> 00:23:22,160
bunch of software enabling in place the

640
00:23:20,090 --> 00:23:23,810
GCC patches or GCC support for this

641
00:23:22,160 --> 00:23:25,550
capability is in the GCC version eight

642
00:23:23,810 --> 00:23:29,270
right now that you can turn off turn on

643
00:23:25,550 --> 00:23:31,820
with the FCF protection flag

644
00:23:29,270 --> 00:23:33,050
there's also Intel C C++ compiler

645
00:23:31,820 --> 00:23:34,790
supports it and there's a tool called

646
00:23:33,050 --> 00:23:37,310
SDE that is actually is an emulation

647
00:23:34,790 --> 00:23:39,649
vehicle that has CT capability in it so

648
00:23:37,310 --> 00:23:41,690
you can actually compile your code for

649
00:23:39,650 --> 00:23:43,520
CT and run it on SD and make sure it

650
00:23:41,690 --> 00:23:46,850
works correctly so you can actually get

651
00:23:43,520 --> 00:23:48,860
a lot of your code transition over to to

652
00:23:46,850 --> 00:23:50,179
see it even before the CPU shows up and

653
00:23:48,860 --> 00:23:52,610
there's finally there's over space for

654
00:23:50,180 --> 00:23:57,590
for Linux that are in the interview

655
00:23:52,610 --> 00:23:59,330
right now so so are we so we can't care

656
00:23:57,590 --> 00:24:00,679
if we say we address drop I'll be done

657
00:23:59,330 --> 00:24:02,389
our attacker is basically going to just

658
00:24:00,680 --> 00:24:03,890
say okay we are we are also done we are

659
00:24:02,390 --> 00:24:06,590
going to you know close shop and go home

660
00:24:03,890 --> 00:24:07,730
that's not really going to happen so we

661
00:24:06,590 --> 00:24:09,889
are looking at from the research

662
00:24:07,730 --> 00:24:11,570
perspective how the attacks evolve we've

663
00:24:09,890 --> 00:24:13,910
seen this new class of attacks called

664
00:24:11,570 --> 00:24:16,280
data oriented programming that's that

665
00:24:13,910 --> 00:24:17,720
seems to be emerging right now it's at

666
00:24:16,280 --> 00:24:20,510
the research stage there's a couple of

667
00:24:17,720 --> 00:24:21,530
talks at blackhat this year a couple of

668
00:24:20,510 --> 00:24:24,620
recent papers that have been published

669
00:24:21,530 --> 00:24:26,780
from a couple of good universities so

670
00:24:24,620 --> 00:24:29,179
the research continues but I think you

671
00:24:26,780 --> 00:24:30,830
know with with with blocking rap

672
00:24:29,180 --> 00:24:33,860
exploits we have at least shaved off a

673
00:24:30,830 --> 00:24:35,990
bunch of exploit types that can be that

674
00:24:33,860 --> 00:24:36,559
use that technique and the attackers

675
00:24:35,990 --> 00:24:37,700
will have to

676
00:24:36,559 --> 00:24:40,158
not looking at much more advanced

677
00:24:37,700 --> 00:24:41,389
techniques like get oriented programming

678
00:24:40,159 --> 00:24:44,149
data oriented programming the general

679
00:24:41,389 --> 00:24:46,129
idea here is by corrupting data you can

680
00:24:44,149 --> 00:24:48,379
essentially use full functions right and

681
00:24:46,129 --> 00:24:50,120
cause the code to execute differently

682
00:24:48,379 --> 00:24:51,230
from what the programmer intended even

683
00:24:50,120 --> 00:24:54,018
though you may not be violating the

684
00:24:51,230 --> 00:24:55,759
control flow integrity properties so a

685
00:24:54,019 --> 00:24:57,769
data oriented programming attacker is

686
00:24:55,759 --> 00:25:00,799
going to try and attack a program even

687
00:24:57,769 --> 00:25:09,499
when even when you are your code is CT

688
00:25:00,799 --> 00:25:11,539
compiled yeah so I'd like to end with

689
00:25:09,499 --> 00:25:13,879
that as I said a lot of the tools are

690
00:25:11,539 --> 00:25:15,590
online so folks are interested they can

691
00:25:13,879 --> 00:25:17,059
go download the emulators for it

692
00:25:15,590 --> 00:25:19,340
cut download the latest compilers

693
00:25:17,059 --> 00:25:21,529
compile their code with CT and actually

694
00:25:19,340 --> 00:25:23,059
go evaluate what it takes to harden

695
00:25:21,529 --> 00:25:26,050
those code against those types of

696
00:25:23,059 --> 00:25:31,280
exploits thank you

697
00:25:26,050 --> 00:25:31,280
[Applause]

698
00:25:36,480 --> 00:25:38,540
you

