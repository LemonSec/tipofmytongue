1
00:00:01,680 --> 00:00:02,720
foreign

2
00:00:02,720 --> 00:00:06,469
[Music]

3
00:00:48,020 --> 00:00:50,820
will be speaking about Windows kernel

4
00:00:50,820 --> 00:00:53,340
rootkits for red team and so hope you

5
00:00:53,340 --> 00:00:54,300
enjoy it

6
00:00:54,300 --> 00:00:56,718
look

7
00:01:03,059 --> 00:01:05,099
hello everyone

8
00:01:05,099 --> 00:01:07,380
um so this is going to be Windows kernel

9
00:01:07,380 --> 00:01:10,699
rootkits for rad teams

10
00:01:11,040 --> 00:01:15,060
my name is Andrea Lima I work I do red

11
00:01:15,060 --> 00:01:19,220
teaming at PWC Norway and Oslo

12
00:01:19,220 --> 00:01:21,979
and I try to publish as much as I can

13
00:01:21,979 --> 00:01:26,640
doing research and just in case you

14
00:01:26,640 --> 00:01:28,439
don't have a chance to ask me anything

15
00:01:28,439 --> 00:01:32,040
just feel free to hit me online

16
00:01:32,040 --> 00:01:33,960
so this is what we're going to talk

17
00:01:33,960 --> 00:01:35,220
about

18
00:01:35,220 --> 00:01:36,420
um

19
00:01:36,420 --> 00:01:39,659
but instead of going through each of

20
00:01:39,659 --> 00:01:41,520
these let's just jump into it because I

21
00:01:41,520 --> 00:01:43,320
think I'm short on time

22
00:01:43,320 --> 00:01:45,840
uh so first of all why kernel

23
00:01:45,840 --> 00:01:47,939
development uh

24
00:01:47,939 --> 00:01:50,880
well first of all we are basically a red

25
00:01:50,880 --> 00:01:53,280
team so our whole job is to make blue

26
00:01:53,280 --> 00:01:55,740
teams better uh and in order to do that

27
00:01:55,740 --> 00:01:57,619
you have to be able to emulate the text

28
00:01:57,619 --> 00:02:00,540
that are being done out there and one of

29
00:02:00,540 --> 00:02:02,040
the type of the attacks that's been done

30
00:02:02,040 --> 00:02:04,380
more and more recently is definitely

31
00:02:04,380 --> 00:02:06,299
bringing your own vulnerable driver type

32
00:02:06,299 --> 00:02:08,818
of attacks and these are some of the

33
00:02:08,818 --> 00:02:11,340
examples of a recent malware that's been

34
00:02:11,340 --> 00:02:13,440
using this type of technique and of

35
00:02:13,440 --> 00:02:14,700
course it's important for you to

36
00:02:14,700 --> 00:02:16,680
replicate that in order to be able to

37
00:02:16,680 --> 00:02:19,860
help the blue teams get better

38
00:02:19,860 --> 00:02:22,080
so more advanced tool development for

39
00:02:22,080 --> 00:02:24,480
red teams for sure uh Advanced blue team

40
00:02:24,480 --> 00:02:28,140
training now the thing I find is that uh

41
00:02:28,140 --> 00:02:30,120
while this is definitely not this should

42
00:02:30,120 --> 00:02:32,340
definitely not be your priority

43
00:02:32,340 --> 00:02:34,920
um because obviously there are more

44
00:02:34,920 --> 00:02:37,080
important things more basic important

45
00:02:37,080 --> 00:02:40,500
things that uh you should prioritize uh

46
00:02:40,500 --> 00:02:42,680
take care of your passwords to factor

47
00:02:42,680 --> 00:02:47,040
authentication and such but

48
00:02:47,040 --> 00:02:49,379
um what I find is that some teams are

49
00:02:49,379 --> 00:02:52,260
very confident in their procedure and

50
00:02:52,260 --> 00:02:55,440
security controls and they look at these

51
00:02:55,440 --> 00:02:56,819
more advanced attacks and they want to

52
00:02:56,819 --> 00:02:59,280
emulate them so that to see if they are

53
00:02:59,280 --> 00:03:02,700
ready to for him for them and they're

54
00:03:02,700 --> 00:03:04,920
usually can't find anyone to replicate

55
00:03:04,920 --> 00:03:06,420
them so getting into the series is

56
00:03:06,420 --> 00:03:08,160
definitely a good bet

57
00:03:08,160 --> 00:03:10,980
and uh obviously a better understanding

58
00:03:10,980 --> 00:03:13,140
of Kernel exploit development

59
00:03:13,140 --> 00:03:16,019
um I remember seeing this uh exploit

60
00:03:16,019 --> 00:03:18,860
development uh YouTube video recently

61
00:03:18,860 --> 00:03:23,700
where the guy was clearly looking into a

62
00:03:23,700 --> 00:03:25,680
vulnerable driver and trying to find the

63
00:03:25,680 --> 00:03:28,319
exploit uh the vulnerability uh to that

64
00:03:28,319 --> 00:03:31,940
exploit and the way he clearly never

65
00:03:31,940 --> 00:03:34,560
didn't have the experience of knowing

66
00:03:34,560 --> 00:03:39,239
how driver structure is so he took a

67
00:03:39,239 --> 00:03:41,340
very long time whereas I was looking at

68
00:03:41,340 --> 00:03:42,659
it and because I have experience with

69
00:03:42,659 --> 00:03:46,140
kernel development I knew exactly in Ida

70
00:03:46,140 --> 00:03:48,060
even looking at assembly where exactly

71
00:03:48,060 --> 00:03:50,760
to go so it definitely speeds up your

72
00:03:50,760 --> 00:03:53,040
process not only if you're doing bug

73
00:03:53,040 --> 00:03:55,099
hunting but also if you're doing

74
00:03:55,099 --> 00:03:58,980
malware analysis type of analysis so and

75
00:03:58,980 --> 00:04:00,659
obviously if you're in the kernel then

76
00:04:00,659 --> 00:04:03,420
you have a whole a lot of new attack

77
00:04:03,420 --> 00:04:06,239
surface to things that are lower even

78
00:04:06,239 --> 00:04:08,239
lower level like uh

79
00:04:08,239 --> 00:04:10,860
Microsoft's type 1 hypervisor which is

80
00:04:10,860 --> 00:04:13,700
the hyper-v

81
00:04:13,920 --> 00:04:16,858
now I just want to clarify here that the

82
00:04:16,858 --> 00:04:18,418
objective here is to make you guys

83
00:04:18,418 --> 00:04:20,160
curious about all things kernel and to

84
00:04:20,160 --> 00:04:21,358
show you some interesting things that

85
00:04:21,358 --> 00:04:24,199
you can do when you developing a kernel

86
00:04:24,199 --> 00:04:27,240
it's not so much to spend time in the

87
00:04:27,240 --> 00:04:29,759
user mode uh trying to figure out ways

88
00:04:29,759 --> 00:04:32,400
to execute code in the kernel that would

89
00:04:32,400 --> 00:04:35,040
be kernel exploitation and that's a

90
00:04:35,040 --> 00:04:38,180
whole other presentation

91
00:04:38,940 --> 00:04:41,520
so getting kernel code execution is not

92
00:04:41,520 --> 00:04:43,680
exactly kernel code execution but in the

93
00:04:43,680 --> 00:04:47,759
sense of having your root kit loaded so

94
00:04:47,759 --> 00:04:50,160
there are a few ways you can go about it

95
00:04:50,160 --> 00:04:51,139
um

96
00:04:51,139 --> 00:04:54,900
you can have your own uh driver signed

97
00:04:54,900 --> 00:04:56,820
uh just to clarify I've never gone

98
00:04:56,820 --> 00:04:58,740
through this process yet uh that's

99
00:04:58,740 --> 00:05:01,380
something I want to go uh after but I've

100
00:05:01,380 --> 00:05:02,699
been more focused on bring your own

101
00:05:02,699 --> 00:05:06,240
vulnerable driver uh attack type

102
00:05:06,240 --> 00:05:10,220
um and I'll clarify that in a second but

103
00:05:10,220 --> 00:05:12,479
it's technically simpler because

104
00:05:12,479 --> 00:05:14,160
obviously you're just signing your code

105
00:05:14,160 --> 00:05:17,340
in off you go but it's also more risky

106
00:05:17,340 --> 00:05:19,800
because uh and again I'm not sure how

107
00:05:19,800 --> 00:05:21,540
hard it is for to go through the whole

108
00:05:21,540 --> 00:05:23,220
process of signing your own getting your

109
00:05:23,220 --> 00:05:24,960
own certification signing certificate

110
00:05:24,960 --> 00:05:28,080
but it is more risky because if for

111
00:05:28,080 --> 00:05:29,699
whatever reason you get caught your

112
00:05:29,699 --> 00:05:34,020
payload gets analyzed it they will often

113
00:05:34,020 --> 00:05:37,320
revoke your signing certificate and that

114
00:05:37,320 --> 00:05:39,960
could be more of a problem than to just

115
00:05:39,960 --> 00:05:43,560
flag your payload because there's a

116
00:05:43,560 --> 00:05:44,820
billion different ways that you can

117
00:05:44,820 --> 00:05:47,400
change your codes to bypass cdrs and

118
00:05:47,400 --> 00:05:49,380
such

119
00:05:49,380 --> 00:05:51,539
now the other way is bring your own

120
00:05:51,539 --> 00:05:54,419
vulnerable driver that's less risky

121
00:05:54,419 --> 00:05:55,880
um but

122
00:05:55,880 --> 00:05:58,800
technically it's trickier

123
00:05:58,800 --> 00:05:59,460
um

124
00:05:59,460 --> 00:06:01,380
there are two ways you can go about this

125
00:06:01,380 --> 00:06:04,259
one which is using known uh vulnerable

126
00:06:04,259 --> 00:06:07,320
drivers by the community and there are a

127
00:06:07,320 --> 00:06:08,880
lot for sure

128
00:06:08,880 --> 00:06:11,820
and but you can also find your own now

129
00:06:11,820 --> 00:06:14,220
the finding your own is a bit tricky

130
00:06:14,220 --> 00:06:16,380
because

131
00:06:16,380 --> 00:06:18,960
um it raises ethical questions because

132
00:06:18,960 --> 00:06:20,460
obviously if you're a red team and

133
00:06:20,460 --> 00:06:21,479
you're finding out that there's

134
00:06:21,479 --> 00:06:23,460
vulnerabilities in the kernel in a

135
00:06:23,460 --> 00:06:26,100
driver you should obviously report those

136
00:06:26,100 --> 00:06:29,039
back and have them fix so that one is a

137
00:06:29,039 --> 00:06:32,240
bit of a gray area

138
00:06:34,020 --> 00:06:36,479
um regardless the the way you should go

139
00:06:36,479 --> 00:06:38,520
about is definitely try to sign have

140
00:06:38,520 --> 00:06:42,360
sign your own driver but you should also

141
00:06:42,360 --> 00:06:45,720
go through the phase of uh the phases of

142
00:06:45,720 --> 00:06:48,660
uh having your known a vulnerable driver

143
00:06:48,660 --> 00:06:50,340
and bring your own vulnerable driver

144
00:06:50,340 --> 00:06:52,259
type of attack

145
00:06:52,259 --> 00:06:55,199
um just because there's you want to be

146
00:06:55,199 --> 00:06:57,539
able to emulate the common malicious

147
00:06:57,539 --> 00:06:59,699
techniques that are being used out there

148
00:06:59,699 --> 00:07:03,380
and better uh recommend

149
00:07:03,380 --> 00:07:06,419
mitigations to Blue teams so if you

150
00:07:06,419 --> 00:07:07,979
really understand what are the apis

151
00:07:07,979 --> 00:07:10,080
being called that kind of thing you can

152
00:07:10,080 --> 00:07:12,539
better do just give out better

153
00:07:12,539 --> 00:07:14,580
recommendations

154
00:07:14,580 --> 00:07:16,199
uh

155
00:07:16,199 --> 00:07:19,860
now after you get your vulnerable driver

156
00:07:19,860 --> 00:07:23,580
loaded uh what you want to do is to try

157
00:07:23,580 --> 00:07:28,080
to uh disable the DSC which is the

158
00:07:28,080 --> 00:07:29,940
driver's signature enforcement feature

159
00:07:29,940 --> 00:07:34,500
in uh in Windows operating system now uh

160
00:07:34,500 --> 00:07:38,039
this is not the point again of this

161
00:07:38,039 --> 00:07:40,319
presentation so we're going to skip uh

162
00:07:40,319 --> 00:07:43,380
just jump into the kernel but uh yeah

163
00:07:43,380 --> 00:07:45,300
usually that's the objective it gets

164
00:07:45,300 --> 00:07:47,340
very technical but that's more of a

165
00:07:47,340 --> 00:07:49,919
workshop type of thing

166
00:07:49,919 --> 00:07:52,680
now let's go through a demo just by

167
00:07:52,680 --> 00:07:55,139
passing the SC

168
00:07:55,139 --> 00:07:57,720
so here you see me just going out let's

169
00:07:57,720 --> 00:08:00,419
show Windows 11 but uh then we see the

170
00:08:00,419 --> 00:08:01,979
added just to show that test signing is

171
00:08:01,979 --> 00:08:04,319
on so no test drivers are allowed and

172
00:08:04,319 --> 00:08:07,080
debug is off as well so here I try to

173
00:08:07,080 --> 00:08:08,880
load a root kit and you can see cannot

174
00:08:08,880 --> 00:08:11,400
verify the digital signature

175
00:08:11,400 --> 00:08:13,440
um but then I run the tool I developed

176
00:08:13,440 --> 00:08:15,419
injector and it gives you a couple of

177
00:08:15,419 --> 00:08:17,580
options and one of them is load record

178
00:08:17,580 --> 00:08:21,000
from Intel the first option it loads

179
00:08:21,000 --> 00:08:23,759
that uh that one exploits it and then

180
00:08:23,759 --> 00:08:26,099
loads the rootkit which I randomly

181
00:08:26,099 --> 00:08:28,740
generates random names every time and it

182
00:08:28,740 --> 00:08:32,580
calls it BPH and then you can see that

183
00:08:32,580 --> 00:08:36,839
the BPH is actually loaded so that's

184
00:08:36,839 --> 00:08:38,880
getting into the kernel that's just a

185
00:08:38,880 --> 00:08:39,719
repeat

186
00:08:39,719 --> 00:08:43,080
now disclaimer uh on recently updated

187
00:08:43,080 --> 00:08:46,920
systems uh this no longer works for

188
00:08:46,920 --> 00:08:49,620
known vulnerable drivers

189
00:08:49,620 --> 00:08:52,620
um so it tells you now if you update

190
00:08:52,620 --> 00:08:55,740
your system uh to this day you'll get a

191
00:08:55,740 --> 00:08:58,260
certificate was explicit explicitly

192
00:08:58,260 --> 00:09:01,500
revoked now this has a bit of

193
00:09:01,500 --> 00:09:04,820
controversy because it's not exactly as

194
00:09:04,820 --> 00:09:07,940
Microsoft was state it there's this

195
00:09:07,940 --> 00:09:10,740
researcher on on Twitter will Dorman

196
00:09:10,740 --> 00:09:12,680
that

197
00:09:12,680 --> 00:09:16,200
reported that he wasn't seeing in the

198
00:09:16,200 --> 00:09:19,080
updated Windows systems what Microsoft

199
00:09:19,080 --> 00:09:22,320
was saying to do I think they have fixed

200
00:09:22,320 --> 00:09:23,060
that

201
00:09:23,060 --> 00:09:26,760
later on but this has been going on in

202
00:09:26,760 --> 00:09:28,980
the last couple of days traveling the

203
00:09:28,980 --> 00:09:31,260
figure doing the presentation prepping

204
00:09:31,260 --> 00:09:33,420
so I didn't follow it through but

205
00:09:33,420 --> 00:09:35,760
definitely recommend looking at will the

206
00:09:35,760 --> 00:09:39,420
romance uh Twitter account

207
00:09:39,420 --> 00:09:41,519
now just summarize from the attacker's

208
00:09:41,519 --> 00:09:44,820
perspective they're um there are these

209
00:09:44,820 --> 00:09:47,040
kernel uh trying these ways for you to

210
00:09:47,040 --> 00:09:49,560
try to load your word kit and in terms

211
00:09:49,560 --> 00:09:52,260
of trying to stop it uh there are

212
00:09:52,260 --> 00:09:53,880
usually two guys two ways to go about it

213
00:09:53,880 --> 00:09:56,459
either stop you while loading the driver

214
00:09:56,459 --> 00:10:00,120
or stop you at exploitation uh when

215
00:10:00,120 --> 00:10:01,380
you're doing yeah the actual

216
00:10:01,380 --> 00:10:03,360
exploitation so if you have a signed

217
00:10:03,360 --> 00:10:06,800
driver uh loading your driver is

218
00:10:06,800 --> 00:10:09,480
a forgotten conclusion so you definitely

219
00:10:09,480 --> 00:10:12,180
be able to do that an exploitation is

220
00:10:12,180 --> 00:10:14,100
not exact it's not applicable just

221
00:10:14,100 --> 00:10:16,380
because you're not exploiting anything

222
00:10:16,380 --> 00:10:17,700
to get code execution you're already

223
00:10:17,700 --> 00:10:20,279
running your code then you have bring

224
00:10:20,279 --> 00:10:22,019
your own vulnerable driver

225
00:10:22,019 --> 00:10:26,940
the known part and uh in that's a minus

226
00:10:26,940 --> 00:10:30,120
or plus just because it is blocked in

227
00:10:30,120 --> 00:10:33,240
more recent systems but most systems are

228
00:10:33,240 --> 00:10:35,040
not protected so you can definitely

229
00:10:35,040 --> 00:10:38,220
still load uh for sure on most uh and

230
00:10:38,220 --> 00:10:40,500
not updated systems and and other

231
00:10:40,500 --> 00:10:42,300
operating systems

232
00:10:42,300 --> 00:10:45,600
and uh in terms of exploitation if you

233
00:10:45,600 --> 00:10:48,600
have hvci enabled it will stop Tech

234
00:10:48,600 --> 00:10:50,640
specific exploitation techniques like

235
00:10:50,640 --> 00:10:54,500
memory patching in the in the kernel but

236
00:10:54,500 --> 00:10:58,500
uh that's just one type of exploitation

237
00:10:58,500 --> 00:11:00,120
that you can do so it doesn't

238
00:11:00,120 --> 00:11:01,700
necessarily

239
00:11:01,700 --> 00:11:05,540
stop you from doing

240
00:11:05,540 --> 00:11:09,180
using other exploitation techniques the

241
00:11:09,180 --> 00:11:12,360
third row is again not ethical but and

242
00:11:12,360 --> 00:11:13,860
to be honest quite unnecessary just

243
00:11:13,860 --> 00:11:16,740
because if you can test properly for the

244
00:11:16,740 --> 00:11:19,800
two first scenarios two first rows the

245
00:11:19,800 --> 00:11:22,019
third row you can pretty much derive

246
00:11:22,019 --> 00:11:24,300
that knowledge so

247
00:11:24,300 --> 00:11:27,300
now so now at this point we're in the

248
00:11:27,300 --> 00:11:29,399
kernel so what do we do usually the

249
00:11:29,399 --> 00:11:31,200
answer is you can do anything that's not

250
00:11:31,200 --> 00:11:34,019
quite true but before we do that let's

251
00:11:34,019 --> 00:11:36,779
just uh do a quick intro

252
00:11:36,779 --> 00:11:38,700
um usually the way you interact with the

253
00:11:38,700 --> 00:11:41,820
kernel is through dlls in user mode so

254
00:11:41,820 --> 00:11:43,980
you call it dll an API function it

255
00:11:43,980 --> 00:11:48,000
trickles down to uh one of the API calls

256
00:11:48,000 --> 00:11:53,220
in um in ntdll.dll and then one of those

257
00:11:53,220 --> 00:11:56,100
will do assist call which will switch

258
00:11:56,100 --> 00:11:59,160
contacts into the kernel where you have

259
00:11:59,160 --> 00:12:02,579
a lot of components to it one of the

260
00:12:02,579 --> 00:12:05,820
most important ones is definitely the

261
00:12:05,820 --> 00:12:10,200
executive so the executive is the upper

262
00:12:10,200 --> 00:12:12,380
layer of the anti-os

263
00:12:12,380 --> 00:12:15,660
kernel.exe and it includes most of the

264
00:12:15,660 --> 00:12:19,820
various managers so input output manager

265
00:12:19,820 --> 00:12:22,320
memory manager Plug and Play manager

266
00:12:22,320 --> 00:12:24,480
power manager and so on but then you

267
00:12:24,480 --> 00:12:27,500
also have the and usually you can tell

268
00:12:27,500 --> 00:12:29,880
when structures are part of the

269
00:12:29,880 --> 00:12:31,740
executive by the fact that they will

270
00:12:31,740 --> 00:12:34,500
start with an e so for example a process

271
00:12:34,500 --> 00:12:36,300
will have a representation in executive

272
00:12:36,300 --> 00:12:38,760
called e-process the name of structure

273
00:12:38,760 --> 00:12:40,800
underscore e process and then you also

274
00:12:40,800 --> 00:12:43,079
have a kernel there in dark blue even

275
00:12:43,079 --> 00:12:44,940
though you can't tell really tell but

276
00:12:44,940 --> 00:12:48,540
that's AKA lower kernel now that's

277
00:12:48,540 --> 00:12:51,079
responsible for things like scheduling

278
00:12:51,079 --> 00:12:53,660
interrupt and exception

279
00:12:53,660 --> 00:12:56,279
exception dispatching an exception

280
00:12:56,279 --> 00:12:58,680
handling but then dispatching an

281
00:12:58,680 --> 00:13:00,720
implementation of various other kernel

282
00:13:00,720 --> 00:13:02,660
Primitives

283
00:13:02,660 --> 00:13:06,240
like mutex and sema-force

284
00:13:06,240 --> 00:13:07,920
um

285
00:13:07,920 --> 00:13:10,320
and yeah usually the structures there

286
00:13:10,320 --> 00:13:12,600
usually start with a k so in terms of

287
00:13:12,600 --> 00:13:16,940
process you will have a k process

288
00:13:17,160 --> 00:13:19,139
now just a quick run through through the

289
00:13:19,139 --> 00:13:21,120
methodology for root care development

290
00:13:21,120 --> 00:13:23,160
when you think about a new feature you

291
00:13:23,160 --> 00:13:25,320
will usually go through understanding

292
00:13:25,320 --> 00:13:27,480
the feature you wish to manipulate test

293
00:13:27,480 --> 00:13:30,120
manipulation live on wind debugger

294
00:13:30,120 --> 00:13:32,700
because you can change memory uh while

295
00:13:32,700 --> 00:13:35,639
you're on it test if it actually works

296
00:13:35,639 --> 00:13:38,639
and then you will write the code in your

297
00:13:38,639 --> 00:13:42,420
driver to do exactly what you did uh

298
00:13:42,420 --> 00:13:45,660
live compile then it's a whole lot of

299
00:13:45,660 --> 00:13:49,380
blue screens until you figure things out

300
00:13:49,380 --> 00:13:52,800
let's go through hiding a process so how

301
00:13:52,800 --> 00:13:54,300
do you process one of those things that

302
00:13:54,300 --> 00:13:56,700
seems in theory relatively easy just

303
00:13:56,700 --> 00:13:58,079
because you have a doubly linked list

304
00:13:58,079 --> 00:14:00,959
and all you have to do is rearrange a

305
00:14:00,959 --> 00:14:04,320
few pointers but that's the the problem

306
00:14:04,320 --> 00:14:10,100
here is uh you don't want to be caught

307
00:14:10,100 --> 00:14:13,399
your threads while manipulated pointers

308
00:14:13,399 --> 00:14:16,079
and left out in an inconsistent State

309
00:14:16,079 --> 00:14:17,880
and then another thread goes through

310
00:14:17,880 --> 00:14:20,639
that same doubly linked list and just

311
00:14:20,639 --> 00:14:23,220
simply crashes the whole thing

312
00:14:23,220 --> 00:14:24,180
um

313
00:14:24,180 --> 00:14:25,800
now in order to understand the

314
00:14:25,800 --> 00:14:28,139
difficulty of it you need to look

315
00:14:28,139 --> 00:14:30,060
understand two concepts which are

316
00:14:30,060 --> 00:14:32,279
article interrupt request levels and

317
00:14:32,279 --> 00:14:35,399
deferred procedure calls uh interrupt

318
00:14:35,399 --> 00:14:37,260
request levels

319
00:14:37,260 --> 00:14:38,639
you've probably never heard of it

320
00:14:38,639 --> 00:14:40,800
because in user mode you're always in

321
00:14:40,800 --> 00:14:43,740
passive level that's level zero so you

322
00:14:43,740 --> 00:14:45,959
never heard of this concept probably but

323
00:14:45,959 --> 00:14:48,079
when you're in a kernel uh things switch

324
00:14:48,079 --> 00:14:50,339
it can increase depending on the

325
00:14:50,339 --> 00:14:53,760
interrupts and one thing that often

326
00:14:53,760 --> 00:14:57,839
happens is preemption preemption is

327
00:14:57,839 --> 00:15:00,959
after a specific amount of time has gone

328
00:15:00,959 --> 00:15:03,420
by called the quantum

329
00:15:03,420 --> 00:15:05,760
uh in which your thread is running the

330
00:15:05,760 --> 00:15:07,380
CPU is just simply taken away from you

331
00:15:07,380 --> 00:15:09,620
and what happens is the operating system

332
00:15:09,620 --> 00:15:12,899
sends an interrupt for dispatch level

333
00:15:12,899 --> 00:15:15,540
that's level two uh where dispatch

334
00:15:15,540 --> 00:15:17,399
happens dispatch is basically the

335
00:15:17,399 --> 00:15:18,959
transition between one thread to the

336
00:15:18,959 --> 00:15:21,420
other giving the CPU from one thread to

337
00:15:21,420 --> 00:15:23,040
the other

338
00:15:23,040 --> 00:15:26,100
um and that's this much level now dpcs

339
00:15:26,100 --> 00:15:27,240
is also important for you to understand

340
00:15:27,240 --> 00:15:30,360
is that it's basically a function that

341
00:15:30,360 --> 00:15:33,720
always runs at dispatch level uh what

342
00:15:33,720 --> 00:15:35,519
happens is you have an operating system

343
00:15:35,519 --> 00:15:37,579
let's say you're on a video call

344
00:15:37,579 --> 00:15:40,680
and your webcam is an input device and

345
00:15:40,680 --> 00:15:42,660
let's say it's hooked to the interrupt

346
00:15:42,660 --> 00:15:44,940
14 for example

347
00:15:44,940 --> 00:15:48,839
um if it's up there at 14 anything at

348
00:15:48,839 --> 00:15:50,399
the same level and interrupts at the

349
00:15:50,399 --> 00:15:52,680
same level or below won't get triggered

350
00:15:52,680 --> 00:15:54,779
while it's still there executing so if

351
00:15:54,779 --> 00:15:56,519
the code is buggy or it takes too long

352
00:15:56,519 --> 00:15:59,940
everything below it will not work so

353
00:15:59,940 --> 00:16:02,940
what happens is Microsoft Windows will

354
00:16:02,940 --> 00:16:05,519
give you you dpcs so that you can

355
00:16:05,519 --> 00:16:08,100
execute just the really necessary

356
00:16:08,100 --> 00:16:10,740
actions that you need usually some just

357
00:16:10,740 --> 00:16:13,199
moving memory around and then you will

358
00:16:13,199 --> 00:16:15,420
do the actual processing at the DPC

359
00:16:15,420 --> 00:16:17,339
level so that you're guaranteed that

360
00:16:17,339 --> 00:16:20,699
you're not going to passive level yet so

361
00:16:20,699 --> 00:16:23,839
you give it some priority

362
00:16:24,000 --> 00:16:26,399
now it's important to note as well that

363
00:16:26,399 --> 00:16:29,760
there are only two things that happen at

364
00:16:29,760 --> 00:16:32,339
dispatch level and that's a processing

365
00:16:32,339 --> 00:16:36,180
DPC cues the dpcq and running the

366
00:16:36,180 --> 00:16:39,000
dispatcher this is very important if

367
00:16:39,000 --> 00:16:40,860
you're trying to synchronize with an

368
00:16:40,860 --> 00:16:42,720
operating system that is not cooperating

369
00:16:42,720 --> 00:16:45,440
with you because if you're running as uh

370
00:16:45,440 --> 00:16:48,300
let's go through the algorithm this is

371
00:16:48,300 --> 00:16:49,980
high level just the function calling

372
00:16:49,980 --> 00:16:52,920
obviously the magical happens behind

373
00:16:52,920 --> 00:16:56,100
those functions but you first raise your

374
00:16:56,100 --> 00:16:57,259
Urkle

375
00:16:57,259 --> 00:17:00,600
uh and to dispatch level and the reason

376
00:17:00,600 --> 00:17:02,519
for that is if you're at dispatch level

377
00:17:02,519 --> 00:17:04,980
uh you basically have an infinite

378
00:17:04,980 --> 00:17:07,859
Quantum because only if you release the

379
00:17:07,859 --> 00:17:10,919
CPU lower your Oracle the CPU will get

380
00:17:10,919 --> 00:17:13,799
taken away from you so in that sense you

381
00:17:13,799 --> 00:17:16,079
fix the issue of the CPU being taken

382
00:17:16,079 --> 00:17:18,419
away for you preemption but you still

383
00:17:18,419 --> 00:17:21,599
have all the other CPUs and that's why I

384
00:17:21,599 --> 00:17:24,660
call also the acquire lock and the

385
00:17:24,660 --> 00:17:26,939
acquire lock what it does is it creates

386
00:17:26,939 --> 00:17:29,940
dpcs and assigns it and that's where you

387
00:17:29,940 --> 00:17:32,460
see that that's why it's highlighted the

388
00:17:32,460 --> 00:17:34,919
number because you can send it give it

389
00:17:34,919 --> 00:17:36,960
an index when you're creating the DPC

390
00:17:36,960 --> 00:17:39,660
and when you create it it gets assigned

391
00:17:39,660 --> 00:17:43,260
to a specific CPU logic CPU so in that

392
00:17:43,260 --> 00:17:46,200
way you will have the code you obviously

393
00:17:46,200 --> 00:17:49,020
set a callback code uh kind of thing

394
00:17:49,020 --> 00:17:52,500
that will basically Circle through uh

395
00:17:52,500 --> 00:17:55,799
while uh waiting for your signal for it

396
00:17:55,799 --> 00:17:57,840
to stop and in that way way you

397
00:17:57,840 --> 00:18:00,179
basically freeze the whole system and

398
00:18:00,179 --> 00:18:01,860
just guarantee that no one takes away

399
00:18:01,860 --> 00:18:04,140
the CPU from you so you can do anything

400
00:18:04,140 --> 00:18:07,320
you want and in this case the what I

401
00:18:07,320 --> 00:18:09,000
call the sensitive action this was just

402
00:18:09,000 --> 00:18:11,160
an abstraction so that I can use this in

403
00:18:11,160 --> 00:18:14,039
more than one calls

404
00:18:14,039 --> 00:18:16,860
just one other detail and little things

405
00:18:16,860 --> 00:18:18,960
about the kernel uh

406
00:18:18,960 --> 00:18:21,660
obviously the first thing I I did was

407
00:18:21,660 --> 00:18:24,179
hide a process by its process ID but

408
00:18:24,179 --> 00:18:26,299
then I also want to do it with its name

409
00:18:26,299 --> 00:18:30,780
the problem is the there is an API in

410
00:18:30,780 --> 00:18:32,880
kernel called called PS get process

411
00:18:32,880 --> 00:18:34,320
image file name

412
00:18:34,320 --> 00:18:36,660
and you give it a an e-process and it

413
00:18:36,660 --> 00:18:41,100
gives you the name uh uh in ASCII but it

414
00:18:41,100 --> 00:18:44,580
the field where it grabs this from uh is

415
00:18:44,580 --> 00:18:46,320
image file name and as you can see it

416
00:18:46,320 --> 00:18:49,320
has only 15 but it's 15 bytes long

417
00:18:49,320 --> 00:18:51,120
um so

418
00:18:51,120 --> 00:18:53,700
um the process search protocol host.exe

419
00:18:53,700 --> 00:18:56,039
uh actually just shows up as search

420
00:18:56,039 --> 00:18:59,520
protocol and those are 14 characters so

421
00:18:59,520 --> 00:19:01,020
I'm assuming there's a null byte there

422
00:19:01,020 --> 00:19:04,740
but obviously that's a no-go but if you

423
00:19:04,740 --> 00:19:08,400
look around uh just be creative you can

424
00:19:08,400 --> 00:19:10,380
just you will find that in the same

425
00:19:10,380 --> 00:19:12,480
e-process there's an image file pointer

426
00:19:12,480 --> 00:19:14,760
and in that image file pointer there's a

427
00:19:14,760 --> 00:19:16,740
file name a Unicode string where you

428
00:19:16,740 --> 00:19:18,419
actually can grab the whole name which

429
00:19:18,419 --> 00:19:19,980
is super useful

430
00:19:19,980 --> 00:19:23,039
so let's just hide a few processes so

431
00:19:23,039 --> 00:19:24,960
here I call injector the record is

432
00:19:24,960 --> 00:19:26,100
already loaded so it doesn't do it

433
00:19:26,100 --> 00:19:30,120
anymore but then uh I will call hide PID

434
00:19:30,120 --> 00:19:32,280
that's the injector itself and you can

435
00:19:32,280 --> 00:19:33,840
see that they're disappearing sometimes

436
00:19:33,840 --> 00:19:35,160
it happens too fast like the next

437
00:19:35,160 --> 00:19:37,020
example so you won't see the coloring

438
00:19:37,020 --> 00:19:39,240
but now I'm running notepad and I'll

439
00:19:39,240 --> 00:19:42,840
tell it to hide the name notepad and you

440
00:19:42,840 --> 00:19:45,720
can see it just disappearing there

441
00:19:45,720 --> 00:19:49,200
and then I can also do a more stealth

442
00:19:49,200 --> 00:19:51,600
one which is hide on creation which is

443
00:19:51,600 --> 00:19:54,480
basically me uh hooking up to the a

444
00:19:54,480 --> 00:19:56,280
callback the the notification where

445
00:19:56,280 --> 00:19:59,039
processes are created and I hide it

446
00:19:59,039 --> 00:20:00,660
immediately as soon as I detect it that

447
00:20:00,660 --> 00:20:02,820
it's running

448
00:20:02,820 --> 00:20:05,280
um then I call partial

449
00:20:05,280 --> 00:20:07,679
and as you can see uh this is just a

450
00:20:07,679 --> 00:20:09,660
privilege proof of escalation so I can

451
00:20:09,660 --> 00:20:10,980
assign privilege escalation to any

452
00:20:10,980 --> 00:20:14,580
processes I want and you can see I was

453
00:20:14,580 --> 00:20:16,500
um uh just

454
00:20:16,500 --> 00:20:19,020
doing the LP for the process ID and now

455
00:20:19,020 --> 00:20:21,900
when I execute who am I I am system this

456
00:20:21,900 --> 00:20:23,280
is some of the cool stuff you can do

457
00:20:23,280 --> 00:20:26,580
while on kernel

458
00:20:26,580 --> 00:20:28,559
now let's quickly run through the key

459
00:20:28,559 --> 00:20:29,940
logger

460
00:20:29,940 --> 00:20:31,440
um

461
00:20:31,440 --> 00:20:34,980
the uh so first of all you want to

462
00:20:34,980 --> 00:20:38,039
identify uh the the keyboard driver and

463
00:20:38,039 --> 00:20:39,780
you just list them all and you can

464
00:20:39,780 --> 00:20:43,440
clearly see there's a kbd class there

465
00:20:43,440 --> 00:20:46,080
um here

466
00:20:46,080 --> 00:20:47,880
um

467
00:20:47,880 --> 00:20:50,100
the so basically here you will see the

468
00:20:50,100 --> 00:20:52,860
device list uh when uh only one session

469
00:20:52,860 --> 00:20:55,020
exists so this is the interactive

470
00:20:55,020 --> 00:20:56,760
session that you're on uh on the

471
00:20:56,760 --> 00:21:00,059
computer physically and uh it will have

472
00:21:00,059 --> 00:21:03,660
one driver for all devices and one

473
00:21:03,660 --> 00:21:05,460
device for each and this is basically in

474
00:21:05,460 --> 00:21:07,200
the stretcher the driver will point to

475
00:21:07,200 --> 00:21:09,059
the first device and then the next

476
00:21:09,059 --> 00:21:11,160
device will Point uh to the next until

477
00:21:11,160 --> 00:21:14,460
it's null so and that's the ending of

478
00:21:14,460 --> 00:21:16,380
the list so here you can see that

479
00:21:16,380 --> 00:21:19,380
there's only one there now that's the

480
00:21:19,380 --> 00:21:21,600
device stack so you can clearly see that

481
00:21:21,600 --> 00:21:24,900
the device uh driver for the keyboard

482
00:21:24,900 --> 00:21:27,960
class is on top

483
00:21:27,960 --> 00:21:30,960
and after a new RDP session into the

484
00:21:30,960 --> 00:21:33,539
same machine One keyboard device is

485
00:21:33,539 --> 00:21:36,480
created for each session so you see the

486
00:21:36,480 --> 00:21:38,700
first image is the one on top is the

487
00:21:38,700 --> 00:21:41,520
driver it points to the first device and

488
00:21:41,520 --> 00:21:43,080
then the the first device will point to

489
00:21:43,080 --> 00:21:44,640
the next and the next one doesn't have

490
00:21:44,640 --> 00:21:47,700
any more so no now

491
00:21:47,700 --> 00:21:50,580
after the key logger uh devices are

492
00:21:50,580 --> 00:21:53,700
attached uh to the keyboard device so on

493
00:21:53,700 --> 00:21:55,679
the left you see the same sequence I've

494
00:21:55,679 --> 00:21:58,320
shown before but the difference to the

495
00:21:58,320 --> 00:22:01,140
right after I attach my key logger is

496
00:22:01,140 --> 00:22:03,419
you I didn't put a third one just out of

497
00:22:03,419 --> 00:22:05,039
laziness but

498
00:22:05,039 --> 00:22:07,260
um then you can see that the attached

499
00:22:07,260 --> 00:22:10,799
device is no on the previous one whereas

500
00:22:10,799 --> 00:22:14,400
now it has something there there is an

501
00:22:14,400 --> 00:22:15,960
attach device which is a device created

502
00:22:15,960 --> 00:22:19,020
by my keylogger driver

503
00:22:19,020 --> 00:22:21,480
uh this is the before and after of the

504
00:22:21,480 --> 00:22:23,700
devices attached

505
00:22:23,700 --> 00:22:26,100
um a device stack and you can see that

506
00:22:26,100 --> 00:22:28,080
previously the keyboard was on top and

507
00:22:28,080 --> 00:22:31,260
now it's not anymore so I get the input

508
00:22:31,260 --> 00:22:34,620
output request packets uh first and last

509
00:22:34,620 --> 00:22:37,219
as well

510
00:22:37,740 --> 00:22:39,780
um now in this one usually I would I

511
00:22:39,780 --> 00:22:41,820
would show like creating multiple RDP

512
00:22:41,820 --> 00:22:45,960
sessions but I recently added a new uh

513
00:22:45,960 --> 00:22:47,880
feature because and this is just an

514
00:22:47,880 --> 00:22:49,919
example of how you can start just being

515
00:22:49,919 --> 00:22:51,419
creative and just doing whatever you

516
00:22:51,419 --> 00:22:53,039
want in the kernel and creating new

517
00:22:53,039 --> 00:22:55,799
features where I thought if I have a

518
00:22:55,799 --> 00:22:58,440
keylogger enabled I don't really need

519
00:22:58,440 --> 00:23:00,780
injector to communicate with it so I can

520
00:23:00,780 --> 00:23:03,419
just type in commands and the protocol I

521
00:23:03,419 --> 00:23:06,419
advised was if you type in 666 the

522
00:23:06,419 --> 00:23:09,900
password 666 and you type enter it gets

523
00:23:09,900 --> 00:23:12,780
into this command and control mode so it

524
00:23:12,780 --> 00:23:14,400
will interpret any string that you type

525
00:23:14,400 --> 00:23:17,039
in as long as you type an enter in the

526
00:23:17,039 --> 00:23:19,440
end it will interpret it and execute

527
00:23:19,440 --> 00:23:22,260
that command

528
00:23:22,260 --> 00:23:26,159
so let's look into it so here you see

529
00:23:26,159 --> 00:23:28,500
the key log the last option uh I will

530
00:23:28,500 --> 00:23:31,320
enable the key logger and then I will

531
00:23:31,320 --> 00:23:33,679
exit so I don't need injector anymore

532
00:23:33,679 --> 00:23:36,840
and then I will lock the screen

533
00:23:36,840 --> 00:23:39,780
and you can see there's a CMD there by

534
00:23:39,780 --> 00:23:42,020
the way

535
00:23:42,360 --> 00:23:45,539
um so here I type 666 and I will show

536
00:23:45,539 --> 00:23:48,600
that here yeah so I type enter so now

537
00:23:48,600 --> 00:23:50,820
I'm in command control monitoring mode

538
00:23:50,820 --> 00:23:53,039
and now I type a command and that's the

539
00:23:53,039 --> 00:23:56,100
PID you'll see that 7760 which was the

540
00:23:56,100 --> 00:23:59,520
PID from the cmd.exe so now I type in my

541
00:23:59,520 --> 00:24:01,620
proper actual password and you don't see

542
00:24:01,620 --> 00:24:03,480
CMD there anymore

543
00:24:03,480 --> 00:24:06,179
and that's the beauty of having a key

544
00:24:06,179 --> 00:24:08,580
logger for example you can transparently

545
00:24:08,580 --> 00:24:10,980
interact with the the key logger without

546
00:24:10,980 --> 00:24:13,980
anyone noticing

547
00:24:13,980 --> 00:24:17,159
uh now usually the the people will uh

548
00:24:17,159 --> 00:24:19,440
people will tell you when you get kernel

549
00:24:19,440 --> 00:24:22,200
execution uh it's you can do anything

550
00:24:22,200 --> 00:24:24,960
that's not quite true

551
00:24:24,960 --> 00:24:28,440
um ever since virtual secure mode is on

552
00:24:28,440 --> 00:24:31,919
uh here you will see

553
00:24:31,919 --> 00:24:34,200
um the hypervisor will basically

554
00:24:34,200 --> 00:24:38,760
Implement a virtual secure mode by using

555
00:24:38,760 --> 00:24:41,700
slat that's sl80 that second level

556
00:24:41,700 --> 00:24:45,179
address translation usually what you

557
00:24:45,179 --> 00:24:47,100
what you have is

558
00:24:47,100 --> 00:24:49,380
um by the way the gray part on top left

559
00:24:49,380 --> 00:24:52,260
is what usually used to be just the

560
00:24:52,260 --> 00:24:53,460
environment the whole environment you

561
00:24:53,460 --> 00:24:56,000
had but now the hypervisor will isolate

562
00:24:56,000 --> 00:24:59,240
that part where you are in the system

563
00:24:59,240 --> 00:25:03,240
which is uh the low privilege of virtual

564
00:25:03,240 --> 00:25:04,159
machine

565
00:25:04,159 --> 00:25:07,500
vtl 0 and then the higher privilege one

566
00:25:07,500 --> 00:25:09,200
which is vtl1

567
00:25:09,200 --> 00:25:13,080
the hypervisor will uh

568
00:25:13,080 --> 00:25:15,840
protect memory and isolate your

569
00:25:15,840 --> 00:25:18,360
visibility of memory as well depending

570
00:25:18,360 --> 00:25:20,820
on VM you're at using second level

571
00:25:20,820 --> 00:25:22,740
address translation now usually address

572
00:25:22,740 --> 00:25:24,600
translation is done in the virtual

573
00:25:24,600 --> 00:25:27,480
machine and we're used to it as virtual

574
00:25:27,480 --> 00:25:30,320
address translated to physical address

575
00:25:30,320 --> 00:25:33,480
but now what you have is the virtual

576
00:25:33,480 --> 00:25:36,600
address is translated to GPA that's

577
00:25:36,600 --> 00:25:39,600
guest physical address and the guest

578
00:25:39,600 --> 00:25:42,320
physical address is then translated

579
00:25:42,320 --> 00:25:45,260
through the page table entries at sled

580
00:25:45,260 --> 00:25:48,870
to the system physical address

581
00:25:48,870 --> 00:25:49,559
[Music]

582
00:25:49,559 --> 00:25:51,059
um

583
00:25:51,059 --> 00:25:54,299
now those two operatings those two VMS

584
00:25:54,299 --> 00:25:56,159
they look the same

585
00:25:56,159 --> 00:25:59,340
um but they're not because the kernel is

586
00:25:59,340 --> 00:26:02,820
not exactly the same so that's a secure

587
00:26:02,820 --> 00:26:05,640
kernel and it basically works out as a

588
00:26:05,640 --> 00:26:08,039
proxy kernel

589
00:26:08,039 --> 00:26:10,940
um a secure proxy kernel uh interacting

590
00:26:10,940 --> 00:26:13,640
between isolated

591
00:26:13,640 --> 00:26:16,559
user modes and the actual kernel mode

592
00:26:16,559 --> 00:26:18,240
because you can see that the isolated

593
00:26:18,240 --> 00:26:20,760
process which is called the trusslet

594
00:26:20,760 --> 00:26:23,100
process C does have a kernel

595
00:26:23,100 --> 00:26:25,860
representation in the vulnerable kernel

596
00:26:25,860 --> 00:26:28,380
mode and this whole thing is just to try

597
00:26:28,380 --> 00:26:30,179
to protect you because Microsoft

598
00:26:30,179 --> 00:26:32,940
realized that they cannot because it's

599
00:26:32,940 --> 00:26:35,100
the drivers that are usually provided to

600
00:26:35,100 --> 00:26:37,919
them are are developed by other people

601
00:26:37,919 --> 00:26:41,400
not Microsoft uh not that Microsoft

602
00:26:41,400 --> 00:26:44,039
doesn't make mistakes but

603
00:26:44,039 --> 00:26:46,260
um they can't control the fact that

604
00:26:46,260 --> 00:26:48,000
there will be vulnerabilities and people

605
00:26:48,000 --> 00:26:49,980
will exploit their way into the kernel

606
00:26:49,980 --> 00:26:53,700
so their whole idea here is to isolate

607
00:26:53,700 --> 00:26:57,120
that and not allow you to compromise

608
00:26:57,120 --> 00:26:59,720
fully an operating system

609
00:26:59,720 --> 00:27:02,580
now the proxy

610
00:27:02,580 --> 00:27:05,460
um the secure kernel will act as a proxy

611
00:27:05,460 --> 00:27:07,140
and will actually have important

612
00:27:07,140 --> 00:27:09,779
implementation secure implementations uh

613
00:27:09,779 --> 00:27:12,000
that are relevant for security one of

614
00:27:12,000 --> 00:27:13,620
them is memory management for example

615
00:27:13,620 --> 00:27:15,840
that's because if you think about it if

616
00:27:15,840 --> 00:27:18,360
I have an isolated process usually the

617
00:27:18,360 --> 00:27:20,400
memory it's using it's sensitive

618
00:27:20,400 --> 00:27:22,860
information so one of the features that

619
00:27:22,860 --> 00:27:26,220
the operating system has is to page out

620
00:27:26,220 --> 00:27:28,380
memory if it's not being used for a long

621
00:27:28,380 --> 00:27:29,600
time

622
00:27:29,600 --> 00:27:32,220
now obviously if it has sensitive

623
00:27:32,220 --> 00:27:33,659
information and you're just processing

624
00:27:33,659 --> 00:27:36,860
it out to the vulnerable kernel mode

625
00:27:36,860 --> 00:27:40,020
then they will eventually get access to

626
00:27:40,020 --> 00:27:42,900
it so what it does it encrypts its

627
00:27:42,900 --> 00:27:44,760
memory manager will encrypt that memory

628
00:27:44,760 --> 00:27:46,980
before getting it out to actually being

629
00:27:46,980 --> 00:27:52,159
put in a hard drive it also handles some

630
00:27:52,159 --> 00:27:55,260
synchronization just because if you

631
00:27:55,260 --> 00:27:57,600
think about it synchronization if you

632
00:27:57,600 --> 00:28:00,480
can manipulate the order in which you

633
00:28:00,480 --> 00:28:03,080
can enter a sensitive region

634
00:28:03,080 --> 00:28:07,620
you can often provoke some bugs in the

635
00:28:07,620 --> 00:28:08,840
in the process

636
00:28:08,840 --> 00:28:12,179
in its execution and that's definitely a

637
00:28:12,179 --> 00:28:14,039
no-go so synchronization is definitely a

638
00:28:14,039 --> 00:28:17,100
sensitive thing uh then it also provides

639
00:28:17,100 --> 00:28:19,740
uh crypto services and

640
00:28:19,740 --> 00:28:22,740
um marshalling marshalling is basically

641
00:28:22,740 --> 00:28:24,900
input validation input and output

642
00:28:24,900 --> 00:28:28,260
validation uh in and out from the vtl

643
00:28:28,260 --> 00:28:32,539
one the uh isolated user mode

644
00:28:32,539 --> 00:28:36,840
now this doesn't solve all the problems

645
00:28:36,840 --> 00:28:39,059
and assuming you're using every single

646
00:28:39,059 --> 00:28:41,340
one of it because obviously it assumes

647
00:28:41,340 --> 00:28:43,020
that in the origin when you install your

648
00:28:43,020 --> 00:28:46,260
operating system it's not vulnerable so

649
00:28:46,260 --> 00:28:47,940
you're creating like setting up your

650
00:28:47,940 --> 00:28:51,720
password and such but it's more done to

651
00:28:51,720 --> 00:28:52,640
protect

652
00:28:52,640 --> 00:28:56,820
the operating system but for example if

653
00:28:56,820 --> 00:28:58,740
sensitive information if you're

654
00:28:58,740 --> 00:29:00,000
compromised and then sensitive

655
00:29:00,000 --> 00:29:02,400
information is being originated from the

656
00:29:02,400 --> 00:29:04,880
user mode the vulnerable one in vtl zero

657
00:29:04,880 --> 00:29:07,140
sensitive information information such

658
00:29:07,140 --> 00:29:10,500
as typing your password your I don't

659
00:29:10,500 --> 00:29:13,799
know private letters whatever secrets

660
00:29:13,799 --> 00:29:15,840
if you're typing it that's a secret

661
00:29:15,840 --> 00:29:18,480
coming in through the user mode so

662
00:29:18,480 --> 00:29:20,820
obviously if I compromise the the kernel

663
00:29:20,820 --> 00:29:24,419
and I have a key logger then uh game on

664
00:29:24,419 --> 00:29:28,440
uh but this is absolutely a step amazing

665
00:29:28,440 --> 00:29:31,940
step in the right direction

666
00:29:32,399 --> 00:29:35,640
now uh to finalize I just want to point

667
00:29:35,640 --> 00:29:37,679
out a few references and great setting

668
00:29:37,679 --> 00:29:42,240
resources the more recent uh content if

669
00:29:42,240 --> 00:29:44,279
you want to get into kernel development

670
00:29:44,279 --> 00:29:47,480
is definitely Pavel josephovich

671
00:29:47,480 --> 00:29:50,340
content both in pentaster Academy he has

672
00:29:50,340 --> 00:29:52,740
a couple of courses and his books are

673
00:29:52,740 --> 00:29:53,960
amazing

674
00:29:53,960 --> 00:29:56,460
and very very practical so you will

675
00:29:56,460 --> 00:29:58,679
actually write code and most importantly

676
00:29:58,679 --> 00:30:01,679
the biggest issue when you're starting

677
00:30:01,679 --> 00:30:05,159
this whole thing is to get the whole

678
00:30:05,159 --> 00:30:07,559
environment set up if you've never done

679
00:30:07,559 --> 00:30:10,140
it it can be quite tricky and then you

680
00:30:10,140 --> 00:30:13,260
have the classic rootkit books uh root

681
00:30:13,260 --> 00:30:15,620
kids and the rootkit Arsenal

682
00:30:15,620 --> 00:30:19,559
they will give you ideas great ideas and

683
00:30:19,559 --> 00:30:22,860
techniques that worked in older versions

684
00:30:22,860 --> 00:30:25,919
of windows but if you're comfortable

685
00:30:25,919 --> 00:30:28,020
enough and you study your way into the

686
00:30:28,020 --> 00:30:29,279
kernel and you're really starting to

687
00:30:29,279 --> 00:30:31,140
understand things you can easily adapt

688
00:30:31,140 --> 00:30:34,919
those to 64-bit and or not use the

689
00:30:34,919 --> 00:30:36,899
deprecated API functions that they use

690
00:30:36,899 --> 00:30:38,760
because back then it wasn't deprecated

691
00:30:38,760 --> 00:30:41,760
and of course the windows internals

692
00:30:41,760 --> 00:30:44,520
books are amazing as well really good

693
00:30:44,520 --> 00:30:45,840
for the part where you're trying to

694
00:30:45,840 --> 00:30:47,039
understand the feature you're trying to

695
00:30:47,039 --> 00:30:47,960
hack

696
00:30:47,960 --> 00:30:51,240
and if you're a blue teamer

697
00:30:51,240 --> 00:30:54,000
the Practical reverse engineer the

698
00:30:54,000 --> 00:30:55,559
coloring is that you can see the

699
00:30:55,559 --> 00:30:57,000
Practical on top of reverse engineering

700
00:30:57,000 --> 00:30:59,279
but it's about reverse engineering a

701
00:30:59,279 --> 00:31:01,820
book by Bruce tang

702
00:31:01,820 --> 00:31:04,860
and the book is just amazing super

703
00:31:04,860 --> 00:31:07,140
practical and you actually go through

704
00:31:07,140 --> 00:31:08,940
the exercises of reverse engineering

705
00:31:08,940 --> 00:31:11,700
root kits that they will provide to you

706
00:31:11,700 --> 00:31:14,580
so that's really good now there is a

707
00:31:14,580 --> 00:31:16,679
really really really old book in the

708
00:31:16,679 --> 00:31:19,320
middle there and you might want to be

709
00:31:19,320 --> 00:31:20,820
wondering like why would I put such an

710
00:31:20,820 --> 00:31:23,820
old book it's a great book in terms of

711
00:31:23,820 --> 00:31:26,039
explaining to you the reasoning why

712
00:31:26,039 --> 00:31:28,919
because a lot of these tutorials or

713
00:31:28,919 --> 00:31:32,580
books will just tell you what are the

714
00:31:32,580 --> 00:31:34,440
rules of the game but you start

715
00:31:34,440 --> 00:31:36,240
wondering like why would they do such a

716
00:31:36,240 --> 00:31:37,440
thing like why did they implement it

717
00:31:37,440 --> 00:31:38,640
this way because there's a million

718
00:31:38,640 --> 00:31:39,720
different ways you can Implement all

719
00:31:39,720 --> 00:31:42,120
these features and this book is really

720
00:31:42,120 --> 00:31:44,820
good at that it will actually go through

721
00:31:44,820 --> 00:31:46,620
the reasoning and try to explain things

722
00:31:46,620 --> 00:31:48,720
to you so you understand it better and

723
00:31:48,720 --> 00:31:50,399
better

724
00:31:50,399 --> 00:31:53,340
um and the reason why that book is

725
00:31:53,340 --> 00:31:56,460
really old but still relevant is as the

726
00:31:56,460 --> 00:31:58,559
great David Cutler said there's nothing

727
00:31:58,559 --> 00:32:00,659
that's not NT Windows 10 is NT when he

728
00:32:00,659 --> 00:32:02,820
said that Windows 10 was the more recent

729
00:32:02,820 --> 00:32:07,020
one and this man is definitely one of a

730
00:32:07,020 --> 00:32:08,179
kind

731
00:32:08,179 --> 00:32:12,120
he is the only person who's been an

732
00:32:12,120 --> 00:32:14,880
architect in three uh commercially

733
00:32:14,880 --> 00:32:17,640
successful operating systems that's uh

734
00:32:17,640 --> 00:32:23,240
RSX 11 VMS VMS which was the first

735
00:32:23,240 --> 00:32:25,980
operating system with virtual memory in

736
00:32:25,980 --> 00:32:29,520
32 bits uh so this guy is just amazing

737
00:32:29,520 --> 00:32:32,279
and obviously later on the third Windows

738
00:32:32,279 --> 00:32:34,740
NT at Microsoft

739
00:32:34,740 --> 00:32:38,159
uh and I cannot uh go through these uh

740
00:32:38,159 --> 00:32:39,840
good references without talking about

741
00:32:39,840 --> 00:32:42,720
Dave Probert and channel 9 going uh deep

742
00:32:42,720 --> 00:32:45,779
uh he has some amazing videos and there

743
00:32:45,779 --> 00:32:47,220
are a lot of videos on other people as

744
00:32:47,220 --> 00:32:49,320
well but David Probert is just magical

745
00:32:49,320 --> 00:32:51,179
in explaining uh a lot of the basics

746
00:32:51,179 --> 00:32:54,240
here so that's really good

747
00:32:54,240 --> 00:32:56,940
and yeah uh

748
00:32:56,940 --> 00:33:00,360
um here to answer any questions now uh

749
00:33:00,360 --> 00:33:02,640
if you don't get the chance again uh hit

750
00:33:02,640 --> 00:33:06,000
me up uh live online

751
00:33:06,000 --> 00:33:10,260
um I'm usually very responsive so yeah

752
00:33:10,260 --> 00:33:13,940
that's it for me thank you

753
00:33:16,320 --> 00:33:18,659
okay

754
00:33:18,659 --> 00:33:20,940
thank you very much for your talk on the

755
00:33:20,940 --> 00:33:23,700
right uh just before questions and

756
00:33:23,700 --> 00:33:26,100
before you leave and but we will open to

757
00:33:26,100 --> 00:33:28,500
questions just want to say something uh

758
00:33:28,500 --> 00:33:30,179
we'll have the the lunch available

759
00:33:30,179 --> 00:33:33,360
outside and there are some boxes so if

760
00:33:33,360 --> 00:33:34,860
you have leftovers leave it there it's

761
00:33:34,860 --> 00:33:37,860
not trash so it's anything that you want

762
00:33:37,860 --> 00:33:39,779
to leave behind because we'll give it

763
00:33:39,779 --> 00:33:41,580
away obviously to people who need it so

764
00:33:41,580 --> 00:33:43,380
it's not trash please don't don't put

765
00:33:43,380 --> 00:33:47,600
trash in those boxes okay so questions

766
00:33:47,700 --> 00:33:50,539
foreign

767
00:33:53,360 --> 00:33:55,440
congratulations on the talk that was

768
00:33:55,440 --> 00:33:56,760
really nice

769
00:33:56,760 --> 00:33:58,880
um when you talked about the

770
00:33:58,880 --> 00:34:01,620
hvci to protect the exploitation of the

771
00:34:01,620 --> 00:34:04,740
vulnerable kernel drivers will that

772
00:34:04,740 --> 00:34:07,019
protect you well will that provide a

773
00:34:07,019 --> 00:34:09,000
protection where for instance there was

774
00:34:09,000 --> 00:34:10,379
a couple of years ago there was this

775
00:34:10,379 --> 00:34:12,599
driver which was amazing that we just

776
00:34:12,599 --> 00:34:15,899
Supply it with some some Shell Code and

777
00:34:15,899 --> 00:34:18,480
put execute it at kernel level so that

778
00:34:18,480 --> 00:34:20,940
was kind of fought by Design I would say

779
00:34:20,940 --> 00:34:24,540
but would that protection would would it

780
00:34:24,540 --> 00:34:26,760
prevent that kind of stuff so executing

781
00:34:26,760 --> 00:34:28,859
code coming from the user level which

782
00:34:28,859 --> 00:34:31,199
was not a it was not debugging the

783
00:34:31,199 --> 00:34:33,960
driver it was operating as designed you

784
00:34:33,960 --> 00:34:36,540
can think about who would design such a

785
00:34:36,540 --> 00:34:39,719
thing but they did yeah so that was kind

786
00:34:39,719 --> 00:34:42,119
of the question yeah uh in terms of

787
00:34:42,119 --> 00:34:44,159
buffer overflow to be honest with you I

788
00:34:44,159 --> 00:34:46,500
haven't gone deep into it uh because my

789
00:34:46,500 --> 00:34:48,719
main concern was disabling the IC and

790
00:34:48,719 --> 00:34:50,940
seeing how I could do that it's done

791
00:34:50,940 --> 00:34:53,399
through memory patching and

792
00:34:53,399 --> 00:34:56,879
the hvci thing is really good in terms

793
00:34:56,879 --> 00:35:00,480
of uh because the slat thing that I

794
00:35:00,480 --> 00:35:01,380
explained second level address

795
00:35:01,380 --> 00:35:03,540
translation basically what it does is

796
00:35:03,540 --> 00:35:06,000
the um if you've ever seen like how

797
00:35:06,000 --> 00:35:07,740
virtual address is translated into

798
00:35:07,740 --> 00:35:09,960
physical address you see all the The

799
00:35:09,960 --> 00:35:13,200
Columns the four ones uh the which then

800
00:35:13,200 --> 00:35:16,200
get into the page table entry at the end

801
00:35:16,200 --> 00:35:19,320
that page page table entry will point to

802
00:35:19,320 --> 00:35:21,420
a page of course and will have the

803
00:35:21,420 --> 00:35:24,720
permissions of the page now that when

804
00:35:24,720 --> 00:35:27,960
when you have an hvci enabled with slab

805
00:35:27,960 --> 00:35:30,960
it basically turns that irrelevant it's

806
00:35:30,960 --> 00:35:32,640
obviously still used but if it goes

807
00:35:32,640 --> 00:35:35,579
against whatever is in actual slat which

808
00:35:35,579 --> 00:35:37,500
is memory that the kernel driver doesn't

809
00:35:37,500 --> 00:35:40,579
have access to so you can't vulnerable

810
00:35:40,579 --> 00:35:44,280
driver won't be able to manipulate it

811
00:35:44,280 --> 00:35:49,040
won't allow it to uh it's just the the

812
00:35:49,040 --> 00:35:51,920
prevalent one is this slat one

813
00:35:51,920 --> 00:35:56,280
now if you're doing buffer overflow uh I

814
00:35:56,280 --> 00:35:58,020
guess it depends

815
00:35:58,020 --> 00:36:00,480
um because if you're writing to some

816
00:36:00,480 --> 00:36:04,140
page that is writable already uh then I

817
00:36:04,140 --> 00:36:06,660
guess you could but it's usually the

818
00:36:06,660 --> 00:36:08,820
stack so

819
00:36:08,820 --> 00:36:11,220
um so yeah that's usually writable so

820
00:36:11,220 --> 00:36:12,839
that would probably have to have other

821
00:36:12,839 --> 00:36:15,720
mitigations and not precisely exactly

822
00:36:15,720 --> 00:36:19,260
hvci but there's cfh there's a whole

823
00:36:19,260 --> 00:36:22,200
bunch of stuff so buffer flows is a bit

824
00:36:22,200 --> 00:36:23,940
hard usually the more common type of

825
00:36:23,940 --> 00:36:25,140
attacks that you can take advantage of

826
00:36:25,140 --> 00:36:27,480
this kind of stuff is write what where

827
00:36:27,480 --> 00:36:29,220
types where you get read and write

828
00:36:29,220 --> 00:36:30,660
Primitives

829
00:36:30,660 --> 00:36:34,220
thank you you're welcome

830
00:36:34,440 --> 00:36:37,339
any more questions

831
00:36:39,599 --> 00:36:42,599
okay once again thank you Andre and

832
00:36:42,599 --> 00:36:44,780
let's have lunch

833
00:36:44,780 --> 00:36:47,869
[Applause]

834
00:36:48,250 --> 00:36:51,889
[Music]

