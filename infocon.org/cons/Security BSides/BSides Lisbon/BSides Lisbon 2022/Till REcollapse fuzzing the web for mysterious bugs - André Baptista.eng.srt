1
00:00:01,199 --> 00:00:04,199
foreign

2
00:00:04,850 --> 00:00:08,179
[Applause]

3
00:00:08,179 --> 00:00:12,000
hello everyone it's really nice to be

4
00:00:12,000 --> 00:00:14,360
here back at besides Lisbon

5
00:00:14,360 --> 00:00:19,220
so first of all I'm Andre also known as

6
00:00:19,220 --> 00:00:21,960
oxacb I'm a co-founder of a startup

7
00:00:21,960 --> 00:00:24,420
named etiac I'm also an invited

8
00:00:24,420 --> 00:00:25,859
professor at the Masters in information

9
00:00:25,859 --> 00:00:28,920
security at University of Porto for the

10
00:00:28,920 --> 00:00:31,140
last couple of years I've been hacking

11
00:00:31,140 --> 00:00:33,420
companies worldwide mostly on anchor one

12
00:00:33,420 --> 00:00:35,160
live hacking events as a big Bounty

13
00:00:35,160 --> 00:00:38,219
Hunter and I'm a former captain of the

14
00:00:38,219 --> 00:00:40,920
extreme security task force CTF team

15
00:00:40,920 --> 00:00:43,920
from the University of Porto

16
00:00:43,920 --> 00:00:47,040
all right so the agenda for today uh

17
00:00:47,040 --> 00:00:50,280
we'll be talking about the user input as

18
00:00:50,280 --> 00:00:52,980
always being uh one of the root causes

19
00:00:52,980 --> 00:00:56,579
for uh weird behaviors and also we are

20
00:00:56,579 --> 00:01:00,180
going to look at some regex quirks

21
00:01:00,180 --> 00:01:01,860
um then we'll move on to the actual

22
00:01:01,860 --> 00:01:04,680
technique that I've been using for the

23
00:01:04,680 --> 00:01:07,020
last couple of years to find impactful

24
00:01:07,020 --> 00:01:09,920
super effectful actually vulnerabilities

25
00:01:09,920 --> 00:01:14,400
in stuff that you all use

26
00:01:14,400 --> 00:01:17,340
um in the bug Bounty context so

27
00:01:17,340 --> 00:01:20,100
regarding this uh the technique and the

28
00:01:20,100 --> 00:01:23,580
the goal here is to present a very

29
00:01:23,580 --> 00:01:26,220
simple technique that can be very very

30
00:01:26,220 --> 00:01:30,600
impactful and then I'll show our how I

31
00:01:30,600 --> 00:01:33,479
approach a Target to uncover uh

32
00:01:33,479 --> 00:01:36,060
so-called mysterious bugs by using this

33
00:01:36,060 --> 00:01:37,920
technique and then I'll show you some

34
00:01:37,920 --> 00:01:41,340
real world examples in terms of the

35
00:01:41,340 --> 00:01:44,100
examples I didn't get authorization from

36
00:01:44,100 --> 00:01:46,439
all of these companies to disclose the

37
00:01:46,439 --> 00:01:48,119
vulnerability

38
00:01:48,119 --> 00:01:50,820
um but I'll disclose at least one

39
00:01:50,820 --> 00:01:52,619
so

40
00:01:52,619 --> 00:01:54,840
um how I come up with this

41
00:01:54,840 --> 00:01:56,220
um the technique that I'm going to show

42
00:01:56,220 --> 00:01:59,700
you today so I was hacking a Target in a

43
00:01:59,700 --> 00:02:03,060
bug Bounty context and I had an URL like

44
00:02:03,060 --> 00:02:05,100
this so redirect with the overall

45
00:02:05,100 --> 00:02:07,320
parameter to

46
00:02:07,320 --> 00:02:10,619
um a host like legit.example.com so I

47
00:02:10,619 --> 00:02:13,319
wanted to redirect to another host such

48
00:02:13,319 --> 00:02:17,540
as evil.com and it didn't work I also

49
00:02:17,540 --> 00:02:21,599
loved the orange site research regarding

50
00:02:21,599 --> 00:02:24,840
like URL parsers and so on but those

51
00:02:24,840 --> 00:02:26,700
techniques weren't working so I wanted

52
00:02:26,700 --> 00:02:29,640
to find a new bypass to actually perform

53
00:02:29,640 --> 00:02:32,819
this redirect that would lead to more

54
00:02:32,819 --> 00:02:34,620
impact actually than just an open

55
00:02:34,620 --> 00:02:36,239
redirect

56
00:02:36,239 --> 00:02:40,379
so let's start with the user input so

57
00:02:40,379 --> 00:02:43,319
most modern web apps or apis and even

58
00:02:43,319 --> 00:02:47,060
more software rely on validation

59
00:02:47,060 --> 00:02:50,640
mostly by regular expressions of course

60
00:02:50,640 --> 00:02:53,819
and basically G is just a simple example

61
00:02:53,819 --> 00:02:56,599
that will match for an email address

62
00:02:56,599 --> 00:02:59,879
format a very simple reacts just end it

63
00:02:59,879 --> 00:03:03,120
as an example that will reject aa.com

64
00:03:03,120 --> 00:03:07,019
but we'll accept a at a.com

65
00:03:07,019 --> 00:03:09,840
uh we also have sanitization of course

66
00:03:09,840 --> 00:03:12,180
this is just an example of PHP HTML

67
00:03:12,180 --> 00:03:15,420
special cards that will escape the HTML

68
00:03:15,420 --> 00:03:20,340
into HTML entities which will prevent

69
00:03:20,340 --> 00:03:22,739
cross-site scripting attacks and more

70
00:03:22,739 --> 00:03:26,459
stuff and they also rely on

71
00:03:26,459 --> 00:03:29,280
normalization techniques this one this

72
00:03:29,280 --> 00:03:31,340
there's already some research on

73
00:03:31,340 --> 00:03:34,379
normalization from the past but these

74
00:03:34,379 --> 00:03:36,000
are just examples

75
00:03:36,000 --> 00:03:39,000
um such as the icon function in PHP with

76
00:03:39,000 --> 00:03:41,040
the translate option that will basically

77
00:03:41,040 --> 00:03:44,099
will convert and normalize an input like

78
00:03:44,099 --> 00:03:46,739
this the string you see on the right and

79
00:03:46,739 --> 00:03:49,980
it will basically convert to some weird

80
00:03:49,980 --> 00:03:54,180
stuff and also in in Python we have the

81
00:03:54,180 --> 00:03:56,819
unity codes and more libraries that will

82
00:03:56,819 --> 00:04:00,000
basically process this type of input and

83
00:04:00,000 --> 00:04:03,120
we'll normalize it to a strain in terms

84
00:04:03,120 --> 00:04:05,819
of the second one the python one it's

85
00:04:05,819 --> 00:04:07,739
interesting that not only the accents

86
00:04:07,739 --> 00:04:10,620
are removed but also you have like this

87
00:04:10,620 --> 00:04:13,799
degree symbol being normalized to

88
00:04:13,799 --> 00:04:20,358
um d a uh d e g in terms of the php1 so

89
00:04:20,358 --> 00:04:22,740
you can see like that we have some

90
00:04:22,740 --> 00:04:26,880
single quotes or quotes being inserted

91
00:04:26,880 --> 00:04:29,699
before the E and the I for instance and

92
00:04:29,699 --> 00:04:31,500
basically you can see where this is

93
00:04:31,500 --> 00:04:33,900
going so basically if we send this input

94
00:04:33,900 --> 00:04:36,720
and this input is like trusted somehow

95
00:04:36,720 --> 00:04:38,400
because it's been normalized it's been

96
00:04:38,400 --> 00:04:41,280
validated and if we can insert this

97
00:04:41,280 --> 00:04:43,940
sometimes in the script context we can

98
00:04:43,940 --> 00:04:46,979
basically achieve cross-site scripting

99
00:04:46,979 --> 00:04:49,979
with the single code or the the double

100
00:04:49,979 --> 00:04:54,540
quote for example in this in this case

101
00:04:54,540 --> 00:04:56,759
um so there are some problems with the

102
00:04:56,759 --> 00:04:59,280
validation in terms of developers

103
00:04:59,280 --> 00:05:02,040
copying from stack over overflow of

104
00:05:02,040 --> 00:05:05,220
course so rig X is widely used to very

105
00:05:05,220 --> 00:05:08,220
validate parameters and it's like okay I

106
00:05:08,220 --> 00:05:10,080
sir please give me a way to make sure

107
00:05:10,080 --> 00:05:12,479
that email an email is valid in

108
00:05:12,479 --> 00:05:15,540
JavaScript or someone can just find a

109
00:05:15,540 --> 00:05:18,240
response like here's a regular

110
00:05:18,240 --> 00:05:20,460
expression secure and should introduce

111
00:05:20,460 --> 00:05:23,940
no bugs in your code enjoy it so the

112
00:05:23,940 --> 00:05:25,800
developers enjoy doing this and they

113
00:05:25,800 --> 00:05:28,020
paste like different regular expressions

114
00:05:28,020 --> 00:05:29,940
in their code specially in the backend

115
00:05:29,940 --> 00:05:32,940
but also in the front end so it's not

116
00:05:32,940 --> 00:05:36,180
mostly not tested by developers and for

117
00:05:36,180 --> 00:05:39,000
instance they could use a reacts 101 and

118
00:05:39,000 --> 00:05:40,500
try to understand what the regular

119
00:05:40,500 --> 00:05:43,259
expression is at least like the

120
00:05:43,259 --> 00:05:46,199
explanation part is really useful for

121
00:05:46,199 --> 00:05:48,199
those that don't understand that much

122
00:05:48,199 --> 00:05:51,539
from regular Expressions so you as you

123
00:05:51,539 --> 00:05:54,060
can see we have the slash S

124
00:05:54,060 --> 00:05:56,520
that will match any known white space

125
00:05:56,520 --> 00:05:57,900
character

126
00:05:57,900 --> 00:06:00,479
um in the in the string so we can have

127
00:06:00,479 --> 00:06:02,100
some problems with this so we need to

128
00:06:02,100 --> 00:06:04,080
have good regular Expressions to make

129
00:06:04,080 --> 00:06:06,660
sure that input will not and inputs that

130
00:06:06,660 --> 00:06:08,820
are used in flows

131
00:06:08,820 --> 00:06:11,759
um and are they are using many Flows In

132
00:06:11,759 --> 00:06:14,100
especially in complex applications and

133
00:06:14,100 --> 00:06:17,100
companies so we need to make sure that

134
00:06:17,100 --> 00:06:20,940
the regex is properly covering uh the

135
00:06:20,940 --> 00:06:23,100
the input scenarios in this case you can

136
00:06:23,100 --> 00:06:25,860
see that like even tactics and like it

137
00:06:25,860 --> 00:06:28,020
will just go through

138
00:06:28,020 --> 00:06:30,240
um also sometimes testing code exists

139
00:06:30,240 --> 00:06:32,580
with the typical assertions but it's

140
00:06:32,580 --> 00:06:35,580
specific to a subset of the the cases in

141
00:06:35,580 --> 00:06:37,979
this example we have the test string but

142
00:06:37,979 --> 00:06:40,139
then we have a DOT that will allow a lot

143
00:06:40,139 --> 00:06:42,419
of characters even special characters

144
00:06:42,419 --> 00:06:44,160
and basically

145
00:06:44,160 --> 00:06:46,740
um it's not properly testing the the

146
00:06:46,740 --> 00:06:51,180
possibilities in terms of user input

147
00:06:51,180 --> 00:06:53,940
and then we have an example that I

148
00:06:53,940 --> 00:06:55,860
wanted to show you uh it's like

149
00:06:55,860 --> 00:06:57,840
according to the standard the dollar

150
00:06:57,840 --> 00:07:00,240
sign will assert the position at the end

151
00:07:00,240 --> 00:07:03,240
of the string for example in this case

152
00:07:03,240 --> 00:07:06,360
you can see that we have an assertion at

153
00:07:06,360 --> 00:07:09,000
the start of a line and then we have an

154
00:07:09,000 --> 00:07:11,160
assertion with the dollar sign in at the

155
00:07:11,160 --> 00:07:14,340
end of of the string or before the line

156
00:07:14,340 --> 00:07:16,680
Terminator right at the end of the

157
00:07:16,680 --> 00:07:19,500
string so this actually means that okay

158
00:07:19,500 --> 00:07:21,780
we have a string and we are only

159
00:07:21,780 --> 00:07:24,240
accepting that string if it basically

160
00:07:24,240 --> 00:07:26,819
the the regular expression it's between

161
00:07:26,819 --> 00:07:29,280
that rule

162
00:07:29,280 --> 00:07:31,620
um so or before the line Terminator

163
00:07:31,620 --> 00:07:34,500
right at the end of the string so if we

164
00:07:34,500 --> 00:07:36,720
have a string that ends with a new line

165
00:07:36,720 --> 00:07:38,160
character

166
00:07:38,160 --> 00:07:40,860
um it will still be accepted so this is

167
00:07:40,860 --> 00:07:44,759
like what the standard says about it

168
00:07:44,759 --> 00:07:47,819
but in terms of implementation we have

169
00:07:47,819 --> 00:07:50,220
for instance JavaScript and that will

170
00:07:50,220 --> 00:07:53,580
basically match the string AIA for these

171
00:07:53,580 --> 00:07:57,300
simple reacts from A to Z and it will

172
00:07:57,300 --> 00:07:59,099
basically reject the second one which is

173
00:07:59,099 --> 00:08:01,740
absolutely right like AAA one two three

174
00:08:01,740 --> 00:08:03,960
one two three is not part of the the

175
00:08:03,960 --> 00:08:07,620
regex and then we have a slash n a new

176
00:08:07,620 --> 00:08:09,720
line character that according to this

177
00:08:09,720 --> 00:08:12,599
should be accepted and it will reject a

178
00:08:12,599 --> 00:08:14,520
new line character and with numbers

179
00:08:14,520 --> 00:08:16,979
after that as well then we have Python

180
00:08:16,979 --> 00:08:19,500
and python will have the same behavior

181
00:08:19,500 --> 00:08:23,280
except for the AAA and a new line

182
00:08:23,280 --> 00:08:25,860
character that will still match the the

183
00:08:25,860 --> 00:08:27,840
actual string

184
00:08:27,840 --> 00:08:29,819
then we have Ruby which you will

185
00:08:29,819 --> 00:08:33,539
basically accept three cases so to sum

186
00:08:33,539 --> 00:08:35,940
it up for this reacts we have different

187
00:08:35,940 --> 00:08:38,219
behaviors for the dollar sign this is

188
00:08:38,219 --> 00:08:40,559
just an example of these uh the default

189
00:08:40,559 --> 00:08:43,559
implementations of regax validations can

190
00:08:43,559 --> 00:08:46,080
lead to different behaviors in many

191
00:08:46,080 --> 00:08:50,360
cases for different regular

192
00:08:50,360 --> 00:08:53,040
Expressions so and one of the problems

193
00:08:53,040 --> 00:08:54,720
is that um

194
00:08:54,720 --> 00:08:57,839
people actually validate the input and

195
00:08:57,839 --> 00:09:00,360
they are not extracting these match data

196
00:09:00,360 --> 00:09:03,660
that is what actually matters regardless

197
00:09:03,660 --> 00:09:05,820
of the input so they are just like okay

198
00:09:05,820 --> 00:09:07,519
the regular

199
00:09:07,519 --> 00:09:12,180
match regax uh on on the input and if

200
00:09:12,180 --> 00:09:14,399
it's valid we'll use the original input

201
00:09:14,399 --> 00:09:17,519
and not what we are extracting

202
00:09:17,519 --> 00:09:20,220
um so this is very very common in

203
00:09:20,220 --> 00:09:21,660
backends

204
00:09:21,660 --> 00:09:24,600
so after this intro we'll move on to the

205
00:09:24,600 --> 00:09:25,980
actual technique

206
00:09:25,980 --> 00:09:29,339
um that I call recall apps

207
00:09:29,339 --> 00:09:31,740
um how can we bypass most user input

208
00:09:31,740 --> 00:09:34,320
validations that rely on regular

209
00:09:34,320 --> 00:09:36,959
Expressions but also how can we leverage

210
00:09:36,959 --> 00:09:39,959
user input Transformations like the

211
00:09:39,959 --> 00:09:43,560
normalizations that I showed you so the

212
00:09:43,560 --> 00:09:45,240
main idea behind this technique is to

213
00:09:45,240 --> 00:09:48,959
First the parameters but in a smart way

214
00:09:48,959 --> 00:09:51,300
so let's start with initial scenario we

215
00:09:51,300 --> 00:09:53,399
have the first one it's been accepted of

216
00:09:53,399 --> 00:09:55,680
course it's like okay example.com to a

217
00:09:55,680 --> 00:09:58,080
subdomain a legitimate subdomain of

218
00:09:58,080 --> 00:10:00,959
example.com it will be accepted but if

219
00:10:00,959 --> 00:10:04,200
we send evil.com it will be rejected

220
00:10:04,200 --> 00:10:05,580
uh

221
00:10:05,580 --> 00:10:09,360
so um this is mostly an abstraction of

222
00:10:09,360 --> 00:10:11,459
the technique so we send like an

223
00:10:11,459 --> 00:10:14,580
unexpected inputs we just fuzz a lot of

224
00:10:14,580 --> 00:10:16,380
input even in the context of a web

225
00:10:16,380 --> 00:10:18,779
application we get back a weird behavior

226
00:10:18,779 --> 00:10:21,240
and we keep doing this so the Black Box

227
00:10:21,240 --> 00:10:23,940
will actually start revealing uh

228
00:10:23,940 --> 00:10:24,959
information

229
00:10:24,959 --> 00:10:27,360
so the recoilapse technique is about

230
00:10:27,360 --> 00:10:30,120
identifying regex pivot positions we

231
00:10:30,120 --> 00:10:32,339
don't have actual access to the regular

232
00:10:32,339 --> 00:10:34,860
expression in the back end so we'll

233
00:10:34,860 --> 00:10:37,260
start by identifying the starting and

234
00:10:37,260 --> 00:10:39,660
termination positions I'll show you what

235
00:10:39,660 --> 00:10:41,040
this actually means in the next couple

236
00:10:41,040 --> 00:10:43,080
of flights then also separator and

237
00:10:43,080 --> 00:10:45,420
normalization positions we'll fast these

238
00:10:45,420 --> 00:10:47,519
positions with all the possible bytes

239
00:10:47,519 --> 00:10:50,700
that we can have in that range from 0 to

240
00:10:50,700 --> 00:10:54,000
FF for example and then we'll analyze

241
00:10:54,000 --> 00:10:56,279
the responses to to get some conclusions

242
00:10:56,279 --> 00:10:59,519
so this is an example of picking the

243
00:10:59,519 --> 00:11:01,079
starting position termination position

244
00:11:01,079 --> 00:11:04,860
to verify if we have some assertions in

245
00:11:04,860 --> 00:11:06,839
the regex that are missing in terms of

246
00:11:06,839 --> 00:11:10,079
starting and and ending properly we also

247
00:11:10,079 --> 00:11:12,839
have the new line variations that I

248
00:11:12,839 --> 00:11:15,240
showed you as well then we have the

249
00:11:15,240 --> 00:11:17,040
separator positions so the separator

250
00:11:17,040 --> 00:11:19,800
positions are basically about

251
00:11:19,800 --> 00:11:22,980
um special characters so we know that in

252
00:11:22,980 --> 00:11:24,839
terms of regex we have ranges of

253
00:11:24,839 --> 00:11:27,660
characters rules and special characters

254
00:11:27,660 --> 00:11:30,540
in The regex itself and how many times

255
00:11:30,540 --> 00:11:33,240
they can like repeat

256
00:11:33,240 --> 00:11:36,779
um so the major idea about the second uh

257
00:11:36,779 --> 00:11:39,600
Vivo position is basically inserting

258
00:11:39,600 --> 00:11:43,019
fuzzing points fuzzing positions around

259
00:11:43,019 --> 00:11:45,540
the the special characters

260
00:11:45,540 --> 00:11:49,079
um and take a look what happens if we

261
00:11:49,079 --> 00:11:52,140
first with the new bytes on on these

262
00:11:52,140 --> 00:11:54,240
positions one by one and then we have

263
00:11:54,240 --> 00:11:56,399
the normalization position so typically

264
00:11:56,399 --> 00:11:59,100
vowels but it's not only limited to to

265
00:11:59,100 --> 00:12:01,920
vowels for instance if we have an

266
00:12:01,920 --> 00:12:04,140
uppercase a or a with an accent and so

267
00:12:04,140 --> 00:12:06,260
on an ordinal indicator

268
00:12:06,260 --> 00:12:09,839
we actually get if we try for instance

269
00:12:09,839 --> 00:12:14,880
to sign up on a given application with

270
00:12:14,880 --> 00:12:16,800
an email with these characters it will

271
00:12:16,800 --> 00:12:19,260
be like converted to lowercase and most

272
00:12:19,260 --> 00:12:22,019
of times it will normalize all of these

273
00:12:22,019 --> 00:12:24,120
on the username part and also on the

274
00:12:24,120 --> 00:12:28,100
domain part so it's for security reasons

275
00:12:28,100 --> 00:12:32,700
so to sum it up basically we have all

276
00:12:32,700 --> 00:12:35,160
these positions now and we'll first all

277
00:12:35,160 --> 00:12:39,060
the positions from a new byte to uh FF

278
00:12:39,060 --> 00:12:41,100
so basically

279
00:12:41,100 --> 00:12:44,100
um we'll do this one by one and we'll

280
00:12:44,100 --> 00:12:47,160
look at the the responses

281
00:12:47,160 --> 00:12:49,980
more examples this is this was an

282
00:12:49,980 --> 00:12:52,620
example for legit.example.com where we

283
00:12:52,620 --> 00:12:55,339
should insert the the fuzzing the people

284
00:12:55,339 --> 00:12:58,500
positions then we have an example for

285
00:12:58,500 --> 00:13:01,740
email that will have the same the

286
00:13:01,740 --> 00:13:03,180
starting position and termination

287
00:13:03,180 --> 00:13:05,820
position as well then we have a username

288
00:13:05,820 --> 00:13:08,160
with an underscore and you can see as a

289
00:13:08,160 --> 00:13:09,959
green you have the separator positions

290
00:13:09,959 --> 00:13:12,180
on the underscore and this is an example

291
00:13:12,180 --> 00:13:15,540
more a more complex example for an HTML

292
00:13:15,540 --> 00:13:18,120
so this is actually useful if you do it

293
00:13:18,120 --> 00:13:21,000
in terms of cross-site basically stuff

294
00:13:21,000 --> 00:13:22,339
that is

295
00:13:22,339 --> 00:13:24,740
validating or

296
00:13:24,740 --> 00:13:28,019
trying to purify the the input in terms

297
00:13:28,019 --> 00:13:30,480
of HTML it's actually interesting to

298
00:13:30,480 --> 00:13:32,940
understand if we can get a bypass in

299
00:13:32,940 --> 00:13:36,300
terms of attributes and so on

300
00:13:36,300 --> 00:13:39,600
um so and for that I'll be launching uh

301
00:13:39,600 --> 00:13:42,779
very very soon at my GitHub uh basically

302
00:13:42,779 --> 00:13:44,639
at Albert tool that is capable of

303
00:13:44,639 --> 00:13:46,980
generating inputs according to all of

304
00:13:46,980 --> 00:13:49,019
these rules that we will have for

305
00:13:49,019 --> 00:13:51,540
normalization for separator and starting

306
00:13:51,540 --> 00:13:52,980
and

307
00:13:52,980 --> 00:13:55,620
um termination positions so it will

308
00:13:55,620 --> 00:13:58,139
support multiple fuzzing sizes and

309
00:13:58,139 --> 00:14:00,360
encoding so you can basically paste them

310
00:14:00,360 --> 00:14:03,540
pretty easily in burp Suite or other

311
00:14:03,540 --> 00:14:05,820
tools in for instance in wordpressivity

312
00:14:05,820 --> 00:14:08,880
you can just like copy paste that

313
00:14:08,880 --> 00:14:12,240
um on on Intruder and then you'll be

314
00:14:12,240 --> 00:14:14,700
able to just to give you an example here

315
00:14:14,700 --> 00:14:17,040
on the right how it works just for the

316
00:14:17,040 --> 00:14:19,260
option of separation and starting

317
00:14:19,260 --> 00:14:21,420
determination positions

318
00:14:21,420 --> 00:14:23,160
um it will basically just generate an

319
00:14:23,160 --> 00:14:25,260
input like this and then you'll just

320
00:14:25,260 --> 00:14:29,279
need to look at the the actual responses

321
00:14:29,279 --> 00:14:32,100
so I'll just give you an example about

322
00:14:32,100 --> 00:14:36,060
the thinking process of this so

323
00:14:36,060 --> 00:14:39,000
um I have an application running on my

324
00:14:39,000 --> 00:14:42,360
laptop so this is basically an example

325
00:14:42,360 --> 00:14:45,480
of you know like you can go to a

326
00:14:45,480 --> 00:14:48,180
subdomain of example.com okay so

327
00:14:48,180 --> 00:14:51,000
basically the idea here is that you can

328
00:14:51,000 --> 00:14:52,980
go to

329
00:14:52,980 --> 00:14:55,620
um it basically will redirect so if you

330
00:14:55,620 --> 00:14:59,579
we go to burp we can see that will

331
00:14:59,579 --> 00:15:03,000
basically uh you'll have a request to

332
00:15:03,000 --> 00:15:03,600
um

333
00:15:03,600 --> 00:15:06,480
local test dot me in this case I was

334
00:15:06,480 --> 00:15:09,060
able to to be resolving these DNS but

335
00:15:09,060 --> 00:15:12,480
whatever okay so basically it will

336
00:15:12,480 --> 00:15:15,060
um have uh this functionality if we

337
00:15:15,060 --> 00:15:16,079
redirect

338
00:15:16,079 --> 00:15:18,720
um we get the redirect endpoint with uh

339
00:15:18,720 --> 00:15:21,839
x stock example.com we'll have a 302

340
00:15:21,839 --> 00:15:25,220
font to x.example.com

341
00:15:25,220 --> 00:15:28,560
so if we try to go to a different domain

342
00:15:28,560 --> 00:15:32,519
like x.evil.com it will be forbidden so

343
00:15:32,519 --> 00:15:35,339
the idea here is to basically

344
00:15:35,339 --> 00:15:40,019
um fuzz the the string so if I open burp

345
00:15:40,019 --> 00:15:43,139
Suite I will just send these requests to

346
00:15:43,139 --> 00:15:46,139
the repeater and I'll try to send these

347
00:15:46,139 --> 00:15:49,800
requests all right it works okay so we

348
00:15:49,800 --> 00:15:51,959
could do this manually but let's try to

349
00:15:51,959 --> 00:15:55,500
use the Intruder okay so we'll add a

350
00:15:55,500 --> 00:15:59,040
position here and basically first of all

351
00:15:59,040 --> 00:16:01,620
if we try regular stuff like dot

352
00:16:01,620 --> 00:16:04,620
evil.com it will be forbidden then if

353
00:16:04,620 --> 00:16:06,920
we'll try at evil.com

354
00:16:06,920 --> 00:16:10,620
it will also result in a 403 so

355
00:16:10,620 --> 00:16:13,040
basically the idea here is to fast

356
00:16:13,040 --> 00:16:16,260
positions in the input so just to make

357
00:16:16,260 --> 00:16:18,420
it more simple I'll add a position for

358
00:16:18,420 --> 00:16:20,220
fuzzing in the end of the string and

359
00:16:20,220 --> 00:16:22,920
I'll put it like evil.com so we want to

360
00:16:22,920 --> 00:16:24,779
First all the possible byte combinations

361
00:16:24,779 --> 00:16:27,600
here to see if we can actually get the

362
00:16:27,600 --> 00:16:30,839
302. so I'll basically just let load a

363
00:16:30,839 --> 00:16:33,839
list that I have here are coded and

364
00:16:33,839 --> 00:16:37,079
basically I'll start the the Intruder to

365
00:16:37,079 --> 00:16:40,680
take a look at the responses

366
00:16:40,680 --> 00:16:44,279
all right so if we order by status we

367
00:16:44,279 --> 00:16:46,980
can see that percentage to F which is

368
00:16:46,980 --> 00:16:49,139
basically a slash

369
00:16:49,139 --> 00:16:51,540
um will have a 302 font but it's not

370
00:16:51,540 --> 00:16:53,880
useful at all because we cannot go to to

371
00:16:53,880 --> 00:16:55,259
evil.com

372
00:16:55,259 --> 00:16:58,620
so we can try more stuff let's keep it

373
00:16:58,620 --> 00:17:01,860
simple as determination position that

374
00:17:01,860 --> 00:17:03,540
you'll be able to generate all of these

375
00:17:03,540 --> 00:17:05,939
cases with the the recollapse tool so

376
00:17:05,939 --> 00:17:08,040
basically let's start an attack like

377
00:17:08,040 --> 00:17:10,799
this to see what characters will be

378
00:17:10,799 --> 00:17:13,919
going through at this stage and we have

379
00:17:13,919 --> 00:17:18,720
a 402 to the slash as well but we also

380
00:17:18,720 --> 00:17:21,540
have it for the ad symbol so basically

381
00:17:21,540 --> 00:17:25,559
we have a 302 font to x.example.com and

382
00:17:25,559 --> 00:17:28,099
an ad symbol but we cannot use evil.com

383
00:17:28,099 --> 00:17:31,440
so at this point we can try to start

384
00:17:31,440 --> 00:17:33,540
understanding the regex in the back end

385
00:17:33,540 --> 00:17:39,600
so if we try to send like at evil

386
00:17:39,600 --> 00:17:42,299
it will go through so basically the dot

387
00:17:42,299 --> 00:17:44,940
wasn't actually uh preventing the regex

388
00:17:44,940 --> 00:17:49,080
to to validate the the URL uh so at this

389
00:17:49,080 --> 00:17:52,140
point for exploitation uh we will just

390
00:17:52,140 --> 00:17:54,600
need to use something like this that is

391
00:17:54,600 --> 00:17:57,419
basically a decimal IP address and

392
00:17:57,419 --> 00:17:58,860
basically

393
00:17:58,860 --> 00:18:02,820
if we hit send we'll get the 302 and

394
00:18:02,820 --> 00:18:07,159
basically if we that we'll go to

395
00:18:08,400 --> 00:18:11,100
to a different IP address so basically

396
00:18:11,100 --> 00:18:13,740
we didn't know what's the regax and we

397
00:18:13,740 --> 00:18:16,440
were able to understand how the fuzzing

398
00:18:16,440 --> 00:18:20,400
can be applied to get an actual payload

399
00:18:20,400 --> 00:18:23,700
specific for that situation instead of

400
00:18:23,700 --> 00:18:26,820
being like spraying payloads that are

401
00:18:26,820 --> 00:18:29,640
available on GitHub for example

402
00:18:29,640 --> 00:18:31,860
um okay so let's move on to the actual

403
00:18:31,860 --> 00:18:34,320
methodology where we can apply this

404
00:18:34,320 --> 00:18:37,500
technique so what to look for so we want

405
00:18:37,500 --> 00:18:39,539
to look for for a it's basically

406
00:18:39,539 --> 00:18:41,520
literally anything that gets validated

407
00:18:41,520 --> 00:18:44,880
in the context of a web application but

408
00:18:44,880 --> 00:18:47,400
also other types of software as well so

409
00:18:47,400 --> 00:18:49,980
basically we are looking for uh stuff

410
00:18:49,980 --> 00:18:53,220
that gets sanitized validated normalized

411
00:18:53,220 --> 00:18:57,539
used inquiries and so on uh so the data

412
00:18:57,539 --> 00:18:59,220
that is usually have more operations

413
00:18:59,220 --> 00:19:02,039
could be like the the name of the user

414
00:19:02,039 --> 00:19:05,400
that shows up in very in many places the

415
00:19:05,400 --> 00:19:07,919
email address the the username and so on

416
00:19:07,919 --> 00:19:10,380
so these will actually open the door to

417
00:19:10,380 --> 00:19:12,720
mysterious bugs that we don't get like

418
00:19:12,720 --> 00:19:14,760
what's the impact at the first place and

419
00:19:14,760 --> 00:19:16,919
we we try to realize it

420
00:19:16,919 --> 00:19:20,100
so the the methodology to uncover these

421
00:19:20,100 --> 00:19:22,200
type of weird bugs that basically just

422
00:19:22,200 --> 00:19:24,960
required like a one byte variation let's

423
00:19:24,960 --> 00:19:28,380
say on your input so the strategy is to

424
00:19:28,380 --> 00:19:30,600
set your goal for example uh account

425
00:19:30,600 --> 00:19:32,760
takeover and then we'll pick your Target

426
00:19:32,760 --> 00:19:34,559
Field for example the email you start

427
00:19:34,559 --> 00:19:36,660
understanding the application and you'll

428
00:19:36,660 --> 00:19:39,059
see okay so the email is responsible for

429
00:19:39,059 --> 00:19:40,919
the most authentication mechanisms and

430
00:19:40,919 --> 00:19:43,919
not the username for example so we'll

431
00:19:43,919 --> 00:19:46,559
identify all the flows that consume it

432
00:19:46,559 --> 00:19:48,440
and I'm just just not talking about

433
00:19:48,440 --> 00:19:51,299
flaws within one single application

434
00:19:51,299 --> 00:19:54,539
talking about you having an overview of

435
00:19:54,539 --> 00:19:58,679
all the the hosts that actually consume

436
00:19:58,679 --> 00:20:00,360
this Target Field for instance you can

437
00:20:00,360 --> 00:20:03,080
have a notification sub domain

438
00:20:03,080 --> 00:20:05,280
login.example.com then the actual

439
00:20:05,280 --> 00:20:08,820
application or whatever like log in with

440
00:20:08,820 --> 00:20:10,799
the application in other services and so

441
00:20:10,799 --> 00:20:13,740
on so we'll identify all the entry

442
00:20:13,740 --> 00:20:16,320
points for this Target Field and for

443
00:20:16,320 --> 00:20:18,960
every in endpoint hosts an application

444
00:20:18,960 --> 00:20:21,600
you basically apply this technique your

445
00:20:21,600 --> 00:20:24,600
smart pick these positions and you'll

446
00:20:24,600 --> 00:20:26,760
try to understand what actually goes

447
00:20:26,760 --> 00:20:29,400
through and is accepted by these type of

448
00:20:29,400 --> 00:20:31,320
filters and then we'll just need to

449
00:20:31,320 --> 00:20:34,200
analyze all response codes did you get

450
00:20:34,200 --> 00:20:38,760
any successful response and if so like

451
00:20:38,760 --> 00:20:41,280
the 302 from from my simple demo

452
00:20:41,280 --> 00:20:43,799
basically you'll go into it and you'll

453
00:20:43,799 --> 00:20:46,140
try to realize okay so if the rig X

454
00:20:46,140 --> 00:20:48,600
rejects the dot and we cannot of ever

455
00:20:48,600 --> 00:20:51,120
host we can actually put like an IP

456
00:20:51,120 --> 00:20:53,039
address or a decimal IP address and so

457
00:20:53,039 --> 00:20:55,380
on in this case it's always specific to

458
00:20:55,380 --> 00:20:57,900
the situation you are analyzing so

459
00:20:57,900 --> 00:21:00,179
another question is that okay is the rig

460
00:21:00,179 --> 00:21:02,640
X always the same in all the endpoints

461
00:21:02,640 --> 00:21:05,460
and applications usually not as I told

462
00:21:05,460 --> 00:21:07,320
you the developers copy like and

463
00:21:07,320 --> 00:21:09,240
different developers copy different rig

464
00:21:09,240 --> 00:21:12,480
axes to multiple backends so basically

465
00:21:12,480 --> 00:21:15,179
what's going to happen is that sometimes

466
00:21:15,179 --> 00:21:18,120
in specific host or in a mobile

467
00:21:18,120 --> 00:21:20,460
application an email with weird

468
00:21:20,460 --> 00:21:23,220
characters is like accepted and on the

469
00:21:23,220 --> 00:21:25,620
core web app it will not be accepted so

470
00:21:25,620 --> 00:21:28,320
this can lead to a lot of problems uh so

471
00:21:28,320 --> 00:21:30,360
the strategy at this point when we have

472
00:21:30,360 --> 00:21:32,039
the response codes will pick a weird

473
00:21:32,039 --> 00:21:34,559
bite that went through you can have

474
00:21:34,559 --> 00:21:36,059
multiple you can have one you can have

475
00:21:36,059 --> 00:21:38,280
two and so on so you'll pick a weird

476
00:21:38,280 --> 00:21:40,260
bite a special character that went

477
00:21:40,260 --> 00:21:43,080
through uh so you'll go out throughout

478
00:21:43,080 --> 00:21:45,299
the folds that you identify from step

479
00:21:45,299 --> 00:21:47,340
three all the flows that consume the

480
00:21:47,340 --> 00:21:49,980
Target Field in the case of email we

481
00:21:49,980 --> 00:21:51,960
have the recovery process for an account

482
00:21:51,960 --> 00:21:55,380
login sign up or single sign-on email

483
00:21:55,380 --> 00:21:58,500
change confirmation it will again depend

484
00:21:58,500 --> 00:22:01,080
on the Target Field so at this point

485
00:22:01,080 --> 00:22:03,179
hopefully you just found like a

486
00:22:03,179 --> 00:22:05,700
mysterious bug so and to realize it you

487
00:22:05,700 --> 00:22:07,620
need to look for

488
00:22:07,620 --> 00:22:09,840
um errors and weird responses weird

489
00:22:09,840 --> 00:22:13,080
behaviors stack traces and so on and

490
00:22:13,080 --> 00:22:15,360
then you'll try to realize the impact or

491
00:22:15,360 --> 00:22:17,760
an attack scenario for you in the real

492
00:22:17,760 --> 00:22:19,260
examples that I'm going to show you

493
00:22:19,260 --> 00:22:22,020
understand this this better if not if

494
00:22:22,020 --> 00:22:23,940
there is no bug or there is no impact

495
00:22:23,940 --> 00:22:27,240
like we are able to bypass this filter

496
00:22:27,240 --> 00:22:30,179
on the sign up page let's say but we

497
00:22:30,179 --> 00:22:32,220
don't know what's the impact of it okay

498
00:22:32,220 --> 00:22:34,620
there's no impact in any of these flows

499
00:22:34,620 --> 00:22:36,600
like a confusion between the accounts

500
00:22:36,600 --> 00:22:38,880
and so on you'll go back to step 5B

501
00:22:38,880 --> 00:22:41,220
you'll pick another weird bite that went

502
00:22:41,220 --> 00:22:43,380
through or you can always go to

503
00:22:43,380 --> 00:22:45,960
redefining your goal or picking another

504
00:22:45,960 --> 00:22:48,000
Target Field of course so this is

505
00:22:48,000 --> 00:22:49,620
basically the methodology I've been

506
00:22:49,620 --> 00:22:51,360
following for the last couple of years

507
00:22:51,360 --> 00:22:54,000
and it has been very very successful in

508
00:22:54,000 --> 00:22:56,580
our net targets

509
00:22:56,580 --> 00:22:59,760
so let's move on to the real world uh

510
00:22:59,760 --> 00:23:01,020
examples

511
00:23:01,020 --> 00:23:04,559
um so this is an example of an open

512
00:23:04,559 --> 00:23:07,380
direct that could lead to a token

513
00:23:07,380 --> 00:23:10,020
exfiltration basically so

514
00:23:10,020 --> 00:23:13,140
um we have login.redight.com alph and

515
00:23:13,140 --> 00:23:16,380
then URL something with the subdomain of

516
00:23:16,380 --> 00:23:18,960
the Target that will return the 302 and

517
00:23:18,960 --> 00:23:21,120
then you have this location a token with

518
00:23:21,120 --> 00:23:22,980
something that is secret and that will

519
00:23:22,980 --> 00:23:25,740
actually authenticate the user after or

520
00:23:25,740 --> 00:23:28,080
if the user is already logged in when

521
00:23:28,080 --> 00:23:31,020
the attacker sends this URL it will

522
00:23:31,020 --> 00:23:33,360
redirect to a URL within our token

523
00:23:33,360 --> 00:23:36,780
parameter so as an attacker our goal is

524
00:23:36,780 --> 00:23:39,120
to exfiltrate this this token obviously

525
00:23:39,120 --> 00:23:41,400
and then after the victim clicks on the

526
00:23:41,400 --> 00:23:44,280
link will be able to reuse this token

527
00:23:44,280 --> 00:23:46,919
because it has not been consumed to

528
00:23:46,919 --> 00:23:48,740
perform account takeover

529
00:23:48,740 --> 00:23:51,000
so usually there's some sort of

530
00:23:51,000 --> 00:23:53,280
validation through regular Expressions

531
00:23:53,280 --> 00:23:56,700
that only allows redacted.com and some

532
00:23:56,700 --> 00:23:59,720
domains of it or even whitelists of

533
00:23:59,720 --> 00:24:02,880
subdomains for example

534
00:24:02,880 --> 00:24:05,400
um so if we try to send like a DOT or a

535
00:24:05,400 --> 00:24:08,460
net symbol or so on we'll get a 403 so

536
00:24:08,460 --> 00:24:11,580
now what from the demo we will first all

537
00:24:11,580 --> 00:24:13,679
of these and you'll eventually come up

538
00:24:13,679 --> 00:24:16,620
with a response so this wasn't exactly

539
00:24:16,620 --> 00:24:20,700
the case so fuzzing URL with like a a

540
00:24:20,700 --> 00:24:23,280
position a pivot position before

541
00:24:23,280 --> 00:24:28,200
evil.com from a null to FF one byte

542
00:24:28,200 --> 00:24:31,440
basically will return no useful 302 so

543
00:24:31,440 --> 00:24:34,380
only for the ash symbol a slash or a

544
00:24:34,380 --> 00:24:36,840
question mark that will basically uh in

545
00:24:36,840 --> 00:24:39,059
this case will will not actually go to

546
00:24:39,059 --> 00:24:43,380
evil.com at all so my idea on this

547
00:24:43,380 --> 00:24:46,020
scenario was like okay let's fuzz all

548
00:24:46,020 --> 00:24:47,700
the possible combinations in terms of

549
00:24:47,700 --> 00:24:51,000
two bytes in this position so and all of

550
00:24:51,000 --> 00:24:54,059
a sudden it returned a nice 302 with 3B

551
00:24:54,059 --> 00:24:56,100
4 0 which is basically

552
00:24:56,100 --> 00:24:57,620
um

553
00:24:57,620 --> 00:25:00,600
what you see down there

554
00:25:00,600 --> 00:25:03,059
um and we can send a a link to a victim

555
00:25:03,059 --> 00:25:06,059
and exfiltrate legitimate token to

556
00:25:06,059 --> 00:25:08,820
perform an ATO with semicolon and an ad

557
00:25:08,820 --> 00:25:11,700
symbol evil.com so and this will

558
00:25:11,700 --> 00:25:14,520
redirect to evil.com an attacker will be

559
00:25:14,520 --> 00:25:17,280
able to exfiltrate the Token from the

560
00:25:17,280 --> 00:25:20,640
core login process that would serve many

561
00:25:20,640 --> 00:25:23,100
applications on this target through a

562
00:25:23,100 --> 00:25:26,279
one-click interaction based ATO via

563
00:25:26,279 --> 00:25:29,640
redirect well like very ardnance and in

564
00:25:29,640 --> 00:25:33,000
this case it was a specific like a

565
00:25:33,000 --> 00:25:35,400
library internal library that they were

566
00:25:35,400 --> 00:25:38,039
using to validate subdomains and

567
00:25:38,039 --> 00:25:41,700
whitelists for the the top level domain

568
00:25:41,700 --> 00:25:45,179
so it was pretty impactful and then some

569
00:25:45,179 --> 00:25:47,580
of you might have seen this there's a

570
00:25:47,580 --> 00:25:49,320
actually a blog post for this

571
00:25:49,320 --> 00:25:51,960
collaboration so basically

572
00:25:51,960 --> 00:25:55,380
um we were fuzzing a target with the

573
00:25:55,380 --> 00:25:58,799
same technique I'm presenting and zlz we

574
00:25:58,799 --> 00:26:01,380
were in a Starbucks shop and we were

575
00:26:01,380 --> 00:26:03,779
preparing for for Defcon and basically

576
00:26:03,779 --> 00:26:07,799
we were hacking a Target so zlz noticed

577
00:26:07,799 --> 00:26:09,720
that a new byte on a sign up request

578
00:26:09,720 --> 00:26:12,480
will reveal a weird very weird Behavior

579
00:26:12,480 --> 00:26:14,340
you can always go through the blog post

580
00:26:14,340 --> 00:26:17,520
to know more details so basically the

581
00:26:17,520 --> 00:26:19,559
idea is that okay we were basically

582
00:26:19,559 --> 00:26:23,220
fuzzing the username in this case it was

583
00:26:23,220 --> 00:26:26,220
an email address actually an attempt to

584
00:26:26,220 --> 00:26:27,380
sign up

585
00:26:27,380 --> 00:26:30,179
then basically the back end will

586
00:26:30,179 --> 00:26:32,460
supposedly check if there's an email

587
00:26:32,460 --> 00:26:35,880
that exists like this it will consider

588
00:26:35,880 --> 00:26:37,919
it as unique we'll proceed with this

589
00:26:37,919 --> 00:26:40,620
iteration the registration process and

590
00:26:40,620 --> 00:26:43,740
basically the derived value after being

591
00:26:43,740 --> 00:26:46,140
passed between two Services the null

592
00:26:46,140 --> 00:26:48,419
byte was being removed in this case it

593
00:26:48,419 --> 00:26:51,480
was by we think like a very low level

594
00:26:51,480 --> 00:26:54,059
library that is being used by the the

595
00:26:54,059 --> 00:26:57,659
target so when we try to sign up with

596
00:26:57,659 --> 00:27:00,539
victim null byte domain.com and only

597
00:27:00,539 --> 00:27:02,940
that byte in in these positions

598
00:27:02,940 --> 00:27:06,299
basically this would return victim L

599
00:27:06,299 --> 00:27:10,140
with an uppercase L at domain.com so we

600
00:27:10,140 --> 00:27:12,840
were like what the is going on and

601
00:27:12,840 --> 00:27:15,480
basically we sprayed a lot of null bytes

602
00:27:15,480 --> 00:27:18,360
and this was kind of like uh art bleed

603
00:27:18,360 --> 00:27:20,279
over again because

604
00:27:20,279 --> 00:27:23,159
um we did a script to continuously dump

605
00:27:23,159 --> 00:27:27,120
this from the target the login system

606
00:27:27,120 --> 00:27:29,400
and we'll get all the passwords from

607
00:27:29,400 --> 00:27:32,460
even logins signups from a specific

608
00:27:32,460 --> 00:27:36,120
region of this this target even private

609
00:27:36,120 --> 00:27:39,480
keys that would allow us to do like some

610
00:27:39,480 --> 00:27:41,400
nasty stuff basically

611
00:27:41,400 --> 00:27:44,220
um even passwords and like many more

612
00:27:44,220 --> 00:27:47,059
secrets and personal data pii and so on

613
00:27:47,059 --> 00:27:49,980
so this was a pretty impactful bug again

614
00:27:49,980 --> 00:27:51,720
using this technique on specific

615
00:27:51,720 --> 00:27:54,240
positions will reveal weird behaviors we

616
00:27:54,240 --> 00:27:56,159
just need to go and try to understand

617
00:27:56,159 --> 00:27:58,740
what's actually happening that we don't

618
00:27:58,740 --> 00:28:00,419
know inside the black box

619
00:28:00,419 --> 00:28:03,480
then we have another example uh what I

620
00:28:03,480 --> 00:28:06,299
call re-cash deception so basically the

621
00:28:06,299 --> 00:28:08,220
idea about webcast deception for those

622
00:28:08,220 --> 00:28:10,500
that are not familiar with it is that

623
00:28:10,500 --> 00:28:12,840
okay if we go to a specific endpoint

624
00:28:12,840 --> 00:28:14,700
this is the traditional more traditional

625
00:28:14,700 --> 00:28:17,460
web cache deception is that basically we

626
00:28:17,460 --> 00:28:19,919
go to an endpoint and we add like a CSS

627
00:28:19,919 --> 00:28:22,799
or static extension and it will

628
00:28:22,799 --> 00:28:25,740
basically if it returns a 200 and it's

629
00:28:25,740 --> 00:28:28,140
cached we can basically access it from

630
00:28:28,140 --> 00:28:30,120
like another session or another location

631
00:28:30,120 --> 00:28:32,760
or whatever without being in the context

632
00:28:32,760 --> 00:28:36,419
of the the user session so basically

633
00:28:36,419 --> 00:28:39,299
um we have this Target redactor.com and

634
00:28:39,299 --> 00:28:41,460
then an API that will return details

635
00:28:41,460 --> 00:28:44,880
about the user and also the API token of

636
00:28:44,880 --> 00:28:48,179
the user that could be basically uh if

637
00:28:48,179 --> 00:28:50,100
we get this token again we get access to

638
00:28:50,100 --> 00:28:52,740
the account so basically we try to go to

639
00:28:52,740 --> 00:28:53,840
Dot

640
00:28:53,840 --> 00:28:56,760
css.pdf.js and it will return the 404 so

641
00:28:56,760 --> 00:29:00,240
no caching at all so the caching rules

642
00:29:00,240 --> 00:29:04,440
are are usually also regax based and the

643
00:29:04,440 --> 00:29:06,720
static extension is not enough these

644
00:29:06,720 --> 00:29:10,860
days to perform web cache deception so

645
00:29:10,860 --> 00:29:12,900
many times we need to enforce the

646
00:29:12,900 --> 00:29:15,779
correct content type in the in the

647
00:29:15,779 --> 00:29:20,580
response so if we send like dot PDF if

648
00:29:20,580 --> 00:29:22,860
there's not application slash PDF in the

649
00:29:22,860 --> 00:29:25,080
response it will eventually not get

650
00:29:25,080 --> 00:29:27,480
cached it always depends on the rules of

651
00:29:27,480 --> 00:29:31,200
a specific application or something that

652
00:29:31,200 --> 00:29:34,320
is in the front of it so okay let's fuzz

653
00:29:34,320 --> 00:29:36,480
it according to the same technique it's

654
00:29:36,480 --> 00:29:40,500
always the same so we try to smartphase

655
00:29:40,500 --> 00:29:44,520
it as well so we will put a pivot

656
00:29:44,520 --> 00:29:47,520
position after user we also tried a

657
00:29:47,520 --> 00:29:48,720
bunch of other stuffs and other

658
00:29:48,720 --> 00:29:51,179
positions but we try this one as well

659
00:29:51,179 --> 00:29:54,539
and we try it again from 0 to FF and

660
00:29:54,539 --> 00:29:55,679
basically

661
00:29:55,679 --> 00:29:58,799
um and well-known extensions as well

662
00:29:58,799 --> 00:30:01,460
mostly static extensions from

663
00:30:01,460 --> 00:30:05,100
min.jsmin.css jpeg PNG and so on and

664
00:30:05,100 --> 00:30:08,159
basically it actually returned at 200

665
00:30:08,159 --> 00:30:12,299
with a new era encoded version of a Nash

666
00:30:12,299 --> 00:30:15,299
symbol and a question mark percentage 23

667
00:30:15,299 --> 00:30:20,580
and 3F and this response have an age a

668
00:30:20,580 --> 00:30:23,940
caching header for H and X cache it so

669
00:30:23,940 --> 00:30:27,320
basically if we send this to a victim

670
00:30:27,320 --> 00:30:30,299
which is logged in in the context of the

671
00:30:30,299 --> 00:30:32,700
application then we just need to access

672
00:30:32,700 --> 00:30:35,720
the cachet content from our

673
00:30:35,720 --> 00:30:39,539
end and we'll be able to retrieve the

674
00:30:39,539 --> 00:30:42,059
actual response that you see near and

675
00:30:42,059 --> 00:30:46,020
reuse the API token as the the victim

676
00:30:46,020 --> 00:30:49,140
and perform account takeover via webcash

677
00:30:49,140 --> 00:30:51,480
deception this one I got authorization

678
00:30:51,480 --> 00:30:54,059
to disclose this one thanks Shopify

679
00:30:54,059 --> 00:30:57,179
folks for having enough some bug Bounty

680
00:30:57,179 --> 00:31:00,299
program so Shopify offers a sign up

681
00:31:00,299 --> 00:31:04,440
login with Shopify of mechanism so the

682
00:31:04,440 --> 00:31:07,620
or scope is well documented and includes

683
00:31:07,620 --> 00:31:10,159
email addresses to log in in multiple

684
00:31:10,159 --> 00:31:11,899
applications

685
00:31:11,899 --> 00:31:15,000
basically you can build Even build as a

686
00:31:15,000 --> 00:31:17,279
developer an application like this so

687
00:31:17,279 --> 00:31:20,220
there was this application that Shopify

688
00:31:20,220 --> 00:31:22,799
acquired I think like taller dot app

689
00:31:22,799 --> 00:31:25,679
which was in scope for an engagement and

690
00:31:25,679 --> 00:31:28,679
basically the email address in this app

691
00:31:28,679 --> 00:31:30,720
and many others doesn't need to be

692
00:31:30,720 --> 00:31:33,059
verified to create an account you can

693
00:31:33,059 --> 00:31:35,700
create an account on Shopify and then

694
00:31:35,700 --> 00:31:38,880
you'll be pending email verification and

695
00:31:38,880 --> 00:31:40,980
basically you need to verify it but you

696
00:31:40,980 --> 00:31:44,220
can log in to to other applications if

697
00:31:44,220 --> 00:31:47,340
they are not actually enforcing this so

698
00:31:47,340 --> 00:31:50,220
but if the email already existed in

699
00:31:50,220 --> 00:31:52,620
taller.app or in the Target application

700
00:31:52,620 --> 00:31:55,440
you can log in or sign up with the

701
00:31:55,440 --> 00:31:57,240
victim on shop if I because you don't

702
00:31:57,240 --> 00:31:59,580
know the password you can have two fi

703
00:31:59,580 --> 00:32:02,039
and so on and you can cannot also sign

704
00:32:02,039 --> 00:32:05,039
up because the email already exists so

705
00:32:05,039 --> 00:32:07,860
our goal was like to understand if there

706
00:32:07,860 --> 00:32:11,700
was some weird Behavior again so we went

707
00:32:11,700 --> 00:32:14,100
to the subdomain responsible for sign

708
00:32:14,100 --> 00:32:16,740
ups and login process of Shopify which

709
00:32:16,740 --> 00:32:20,039
is accounts.shopify.com and there was a

710
00:32:20,039 --> 00:32:23,220
proper regex in place in terms of uh

711
00:32:23,220 --> 00:32:26,159
when you are already logged in and you

712
00:32:26,159 --> 00:32:29,279
found first the email change request so

713
00:32:29,279 --> 00:32:32,520
no weird characters are allowed

714
00:32:32,520 --> 00:32:35,159
um but then we tried we identified all

715
00:32:35,159 --> 00:32:37,559
the flows and all the endpoints so we

716
00:32:37,559 --> 00:32:40,200
tried all the other ones and a sign up

717
00:32:40,200 --> 00:32:42,899
request on accounts.shopify.com and

718
00:32:42,899 --> 00:32:45,480
basically victim with these weird eye

719
00:32:45,480 --> 00:32:48,059
character with a circle will go through

720
00:32:48,059 --> 00:32:50,700
actually and will show up like that so

721
00:32:50,700 --> 00:32:53,640
if we eat login with Shopify in this

722
00:32:53,640 --> 00:32:55,559
state with an account on on this state

723
00:32:55,559 --> 00:32:58,380
if even like being unverified it will

724
00:32:58,380 --> 00:33:01,080
bypass all the process in the Target

725
00:33:01,080 --> 00:33:04,140
application and we can successfully take

726
00:33:04,140 --> 00:33:08,039
over the the target account so I have a

727
00:33:08,039 --> 00:33:12,140
video POC uh here so we are on

728
00:33:12,140 --> 00:33:14,220
accounts.shopify.com we were not able to

729
00:33:14,220 --> 00:33:16,200
change it here this is the actual

730
00:33:16,200 --> 00:33:18,120
victim's account

731
00:33:18,120 --> 00:33:21,899
so we go to another session we log in

732
00:33:21,899 --> 00:33:24,600
and then we in this case we'll be

733
00:33:24,600 --> 00:33:27,600
basically signing up with Shopify

734
00:33:27,600 --> 00:33:29,990
and after this

735
00:33:29,990 --> 00:33:30,419
[Music]

736
00:33:30,419 --> 00:33:32,039
um

737
00:33:32,039 --> 00:33:34,500
go a while all right so basically we'll

738
00:33:34,500 --> 00:33:37,559
uh in this case it wasn't and I actually

739
00:33:37,559 --> 00:33:40,260
it was an a from this video example so

740
00:33:40,260 --> 00:33:42,419
basically we put like a password and the

741
00:33:42,419 --> 00:33:44,220
name we are not the victim this email

742
00:33:44,220 --> 00:33:46,500
without this weird character already

743
00:33:46,500 --> 00:33:50,399
existed so and if we go to taller dot

744
00:33:50,399 --> 00:33:52,980
app it will basically will be in the

745
00:33:52,980 --> 00:33:54,960
victims account right away without even

746
00:33:54,960 --> 00:33:58,320
verifying our email address so the

747
00:33:58,320 --> 00:34:00,960
takeaway here is that

748
00:34:00,960 --> 00:34:02,700
um

749
00:34:02,700 --> 00:34:05,820
so basically oauth flows this wasn't the

750
00:34:05,820 --> 00:34:08,520
only case where we were able to exploit

751
00:34:08,520 --> 00:34:09,839
a bug like this in terms of

752
00:34:09,839 --> 00:34:13,379
normalization because oauth flows and

753
00:34:13,379 --> 00:34:16,320
single sign-on saml assertions and so on

754
00:34:16,320 --> 00:34:18,418
in terms of email addresses and

755
00:34:18,418 --> 00:34:20,820
usernames when they are retrieved or

756
00:34:20,820 --> 00:34:22,980
they are basically by the Target

757
00:34:22,980 --> 00:34:24,599
application

758
00:34:24,599 --> 00:34:27,000
normalization is often used in these

759
00:34:27,000 --> 00:34:29,040
flows even by the libraries that

760
00:34:29,040 --> 00:34:32,580
basically all these saml libraries use a

761
00:34:32,580 --> 00:34:34,859
lot of them not actually normalize the

762
00:34:34,859 --> 00:34:36,960
email address that is being retrieved

763
00:34:36,960 --> 00:34:39,800
and if that happens

764
00:34:39,800 --> 00:34:42,139
the problem is not that is basically

765
00:34:42,139 --> 00:34:47,339
that in the source The Source shouldn't

766
00:34:47,339 --> 00:34:49,980
allow the the wheel characters and

767
00:34:49,980 --> 00:34:52,260
should properly validate and normalize

768
00:34:52,260 --> 00:34:55,619
the email in the first place because in

769
00:34:55,619 --> 00:34:57,240
terms of the destination of the

770
00:34:57,240 --> 00:35:00,180
authentication the target application uh

771
00:35:00,180 --> 00:35:03,180
it's actually it makes sense that they

772
00:35:03,180 --> 00:35:05,160
normalize the the stuff that is coming

773
00:35:05,160 --> 00:35:07,980
through but if not in the login provider

774
00:35:07,980 --> 00:35:11,460
these is not taken into account it will

775
00:35:11,460 --> 00:35:12,900
basically result in this type of

776
00:35:12,900 --> 00:35:15,780
problems then we have a final example

777
00:35:15,780 --> 00:35:18,960
this was a very impactful one I didn't

778
00:35:18,960 --> 00:35:20,700
get authorization to disclose it

779
00:35:20,700 --> 00:35:23,280
unfortunately so the target is actually

780
00:35:23,280 --> 00:35:26,520
an email provider and our goal is to

781
00:35:26,520 --> 00:35:30,180
take over a victim at target.com inbox

782
00:35:30,180 --> 00:35:33,540
without any interaction people can sign

783
00:35:33,540 --> 00:35:36,960
up as username at target.com or use the

784
00:35:36,960 --> 00:35:39,660
current email address so let's explore

785
00:35:39,660 --> 00:35:42,359
all the flows that the email provider

786
00:35:42,359 --> 00:35:43,800
has

787
00:35:43,800 --> 00:35:46,500
so we try to recover the email from the

788
00:35:46,500 --> 00:35:49,619
victim and this will present like a

789
00:35:49,619 --> 00:35:52,200
redacted email address and we can send

790
00:35:52,200 --> 00:35:55,560
the code to these email address and if

791
00:35:55,560 --> 00:35:57,540
we have the code we can use a recovery

792
00:35:57,540 --> 00:35:59,400
email address and we can have access to

793
00:35:59,400 --> 00:36:01,260
the victims account

794
00:36:01,260 --> 00:36:05,400
so Evan basically the victim email as

795
00:36:05,400 --> 00:36:08,339
the attacker recovery we email will

796
00:36:08,339 --> 00:36:11,579
require email verification but if we go

797
00:36:11,579 --> 00:36:13,680
to another session and we try to recover

798
00:36:13,680 --> 00:36:16,320
the actual victims account uh it will

799
00:36:16,320 --> 00:36:18,599
result in a change in the flow so here

800
00:36:18,599 --> 00:36:22,140
and one email showed up and if we as an

801
00:36:22,140 --> 00:36:24,300
attacker add the victim's email as a

802
00:36:24,300 --> 00:36:25,980
recovery email we get like some

803
00:36:25,980 --> 00:36:29,460
confusion so it returns now we insert

804
00:36:29,460 --> 00:36:31,320
okay we want to recover victim at

805
00:36:31,320 --> 00:36:34,920
target.com and it basically we want to

806
00:36:34,920 --> 00:36:37,560
use the same email to perform a recovery

807
00:36:37,560 --> 00:36:39,660
which doesn't make sense like I don't

808
00:36:39,660 --> 00:36:41,300
have access as a victim to this account

809
00:36:41,300 --> 00:36:44,220
and also the same redacted original

810
00:36:44,220 --> 00:36:47,160
recovery email address from the victim

811
00:36:47,160 --> 00:36:49,920
so some sort of free x was matching at

812
00:36:49,920 --> 00:36:52,380
target.com in order to distinguish both

813
00:36:52,380 --> 00:36:54,060
account types the ones that you create

814
00:36:54,060 --> 00:36:57,480
at the target.com which is basically the

815
00:36:57,480 --> 00:37:01,200
email provider a specific email or an

816
00:37:01,200 --> 00:37:02,820
external email address

817
00:37:02,820 --> 00:37:04,859
so after fuzzing the email parameter

818
00:37:04,859 --> 00:37:06,660
with the same technique some special

819
00:37:06,660 --> 00:37:08,579
characters were displaying the same

820
00:37:08,579 --> 00:37:11,400
recovery email addresses

821
00:37:11,400 --> 00:37:14,400
so having a recovery email address and

822
00:37:14,400 --> 00:37:17,099
we felt that the the regex wasn't

823
00:37:17,099 --> 00:37:20,339
properly built it was actually matching

824
00:37:20,339 --> 00:37:22,940
the the at target.com

825
00:37:22,940 --> 00:37:26,480
rig X because it wasn't assertion

826
00:37:26,480 --> 00:37:29,460
asserting the end of the string so if we

827
00:37:29,460 --> 00:37:33,440
added the victim email address at

828
00:37:33,440 --> 00:37:35,640
target.com.ourdomain.com it will

829
00:37:35,640 --> 00:37:38,040
basically show up as a recovery email of

830
00:37:38,040 --> 00:37:40,740
the attacker's account but as option two

831
00:37:40,740 --> 00:37:43,320
we still have a confusion that will show

832
00:37:43,320 --> 00:37:47,640
the original victims email so after

833
00:37:47,640 --> 00:37:50,400
recovering the code via email to victim

834
00:37:50,400 --> 00:37:53,700
and on our subdomain that looks like the

835
00:37:53,700 --> 00:37:56,060
Target in is like

836
00:37:56,060 --> 00:37:57,960
target.com.ourdomain.com and we set up

837
00:37:57,960 --> 00:38:01,619
the DNS and MX records for it we will be

838
00:38:01,619 --> 00:38:03,839
able to select an account and we hit the

839
00:38:03,839 --> 00:38:05,940
victims account and boom like we will

840
00:38:05,940 --> 00:38:07,920
take over the victims account and bypass

841
00:38:07,920 --> 00:38:11,280
like all to fi and so on and get access

842
00:38:11,280 --> 00:38:13,320
to the email inbox without any

843
00:38:13,320 --> 00:38:15,480
interaction so this was by far one of

844
00:38:15,480 --> 00:38:17,820
the most impactful so far since we are

845
00:38:17,820 --> 00:38:20,040
talking about an email provider

846
00:38:20,040 --> 00:38:22,859
all right to sum it up uh some takeaways

847
00:38:22,859 --> 00:38:23,880
so

848
00:38:23,880 --> 00:38:27,480
um developers always test fuzz and fuzz

849
00:38:27,480 --> 00:38:29,700
your regex and rely on well-known

850
00:38:29,700 --> 00:38:32,220
libraries but as you've seen like even

851
00:38:32,220 --> 00:38:35,160
the core functions from programming

852
00:38:35,160 --> 00:38:37,079
languages have some problems in terms of

853
00:38:37,079 --> 00:38:40,800
regex simple input modifications can

854
00:38:40,800 --> 00:38:43,560
result in great damage so we can just

855
00:38:43,560 --> 00:38:46,859
fuss by flipping or having bytes and

856
00:38:46,859 --> 00:38:49,020
applying some sort of like what fuzzing

857
00:38:49,020 --> 00:38:52,440
those in terms of web as well so Black

858
00:38:52,440 --> 00:38:55,079
Box regax testing is still not very

859
00:38:55,079 --> 00:38:57,660
touched so it's a very creative and

860
00:38:57,660 --> 00:39:01,440
manual work but go for it there's plenty

861
00:39:01,440 --> 00:39:03,540
of stuff to to get in terms of bounties

862
00:39:03,540 --> 00:39:05,400
I'm pretty sure and I don't have the

863
00:39:05,400 --> 00:39:08,700
time for it so go for it rig X behavior

864
00:39:08,700 --> 00:39:10,619
Can reveal information about libraries

865
00:39:10,619 --> 00:39:13,200
the programming languages because if you

866
00:39:13,200 --> 00:39:15,900
actually try to and you are suspicious

867
00:39:15,900 --> 00:39:17,520
that the back end is being programming

868
00:39:17,520 --> 00:39:20,700
like PHP or node.js and so on you can

869
00:39:20,700 --> 00:39:22,920
actually try to do the same validation

870
00:39:22,920 --> 00:39:25,859
and try to understand if like new lines

871
00:39:25,859 --> 00:39:27,780
and all these weird characters go

872
00:39:27,780 --> 00:39:29,280
through and you can understand the

873
00:39:29,280 --> 00:39:31,680
backend language and get that

874
00:39:31,680 --> 00:39:33,780
information which can be very useful for

875
00:39:33,780 --> 00:39:37,800
further exploitation so if something is

876
00:39:37,800 --> 00:39:39,780
being validated and you can bypass it

877
00:39:39,780 --> 00:39:41,880
even in terms of fluffs that prevent

878
00:39:41,880 --> 00:39:45,000
payloads just fuzz on these positions

879
00:39:45,000 --> 00:39:47,760
and I'm pretty sure that will basically

880
00:39:47,760 --> 00:39:51,180
be able sorry you'll be able to find the

881
00:39:51,180 --> 00:39:53,940
bypass pretty easily actually instead of

882
00:39:53,940 --> 00:39:56,160
being just spraying copy paste payloads

883
00:39:56,160 --> 00:39:59,099
from you know GitHub so the goal here is

884
00:39:59,099 --> 00:40:01,320
that something very simple it's the

885
00:40:01,320 --> 00:40:03,300
opposite of like complex exploitation

886
00:40:03,300 --> 00:40:05,280
it's very simple but what's this

887
00:40:05,280 --> 00:40:07,500
difficult is to have a big picture of

888
00:40:07,500 --> 00:40:09,780
the target realizing the actual impact

889
00:40:09,780 --> 00:40:12,480
and then hopefully you'll see the big

890
00:40:12,480 --> 00:40:13,280
picture

891
00:40:13,280 --> 00:40:16,260
so to finish I would like to thank many

892
00:40:16,260 --> 00:40:18,780
people that helped me review this talk

893
00:40:18,780 --> 00:40:21,839
and to also that were great

894
00:40:21,839 --> 00:40:24,540
collaborators I couldn't enumerate all

895
00:40:24,540 --> 00:40:28,020
of them in here but big thanks all of

896
00:40:28,020 --> 00:40:31,920
these dudes and then also my team from

897
00:40:31,920 --> 00:40:33,480
my startup where we have been

898
00:40:33,480 --> 00:40:35,220
researching this technique as well the

899
00:40:35,220 --> 00:40:37,260
disturbance team and also the Acker one

900
00:40:37,260 --> 00:40:39,480
team for changing my life in the last

901
00:40:39,480 --> 00:40:42,660
years as well all right thank you and I

902
00:40:42,660 --> 00:40:43,600
hope you liked it

903
00:40:43,600 --> 00:40:51,000
[Applause]

904
00:40:52,980 --> 00:40:54,680
thank you Andrea

905
00:40:54,680 --> 00:40:58,578
anyone for any questions

906
00:41:02,880 --> 00:41:08,060
oh okay thank you Andre thank you

907
00:41:08,060 --> 00:41:16,000
[Applause]

908
00:41:16,000 --> 00:41:20,300
[Music]

