1
00:00:00,000 --> 00:00:07,290
good afternoon everyone<font color="#CCCCCC"> we are ready for</font>

2
00:00:02,939 --> 00:00:10,740
<font color="#E5E5E5">the next presentation by joachim kennedy</font>

3
00:00:07,290 --> 00:00:13,080
on a deep dive<font color="#CCCCCC"> in to</font><font color="#E5E5E5"> comb</font><font color="#CCCCCC"> our using</font>

4
00:00:10,740 --> 00:00:15,260
metadata to empower the<font color="#CCCCCC"> analyst joking</font>

5
00:00:13,080 --> 00:00:17,698
all yours

6
00:00:15,260 --> 00:00:20,130
good afternoon

7
00:00:17,699 --> 00:00:24,180
so the graveyard slot<font color="#CCCCCC"> so let's get</font>

8
00:00:20,130 --> 00:00:25,680
<font color="#E5E5E5">through this it's a little bit about me</font>

9
00:00:24,180 --> 00:00:28,590
before<font color="#CCCCCC"> start so my name is</font><font color="#E5E5E5"> Joakim</font>

10
00:00:25,680 --> 00:00:32,180
Kennedy I'm a senior principal security

11
00:00:28,590 --> 00:00:35,489
researcher for anomaly and when I'm

12
00:00:32,180 --> 00:00:36,899
focusing on<font color="#E5E5E5"> researching and gathering</font>

13
00:00:35,489 --> 00:00:41,040
threat intelligence that<font color="#E5E5E5"> we are</font>

14
00:00:36,899 --> 00:00:43,290
providing<font color="#CCCCCC"> to our</font><font color="#E5E5E5"> customers so the</font><font color="#CCCCCC"> agenda</font>

15
00:00:41,040 --> 00:00:44,760
for this talk is first we're<font color="#E5E5E5"> gonna go</font>

16
00:00:43,290 --> 00:00:46,800
<font color="#CCCCCC">over and do a little</font><font color="#E5E5E5"> bit of an</font>

17
00:00:44,760 --> 00:00:49,589
<font color="#E5E5E5">introduction to go the programming</font>

18
00:00:46,800 --> 00:00:51,000
language<font color="#E5E5E5"> and so most of us here in the</font>

19
00:00:49,590 --> 00:00:53,100
room<font color="#CCCCCC"> will have sort of the</font><font color="#E5E5E5"> same</font>

20
00:00:51,000 --> 00:00:55,800
background<font color="#E5E5E5"> knowledge</font><font color="#CCCCCC"> and then we're</font>

21
00:00:53,100 --> 00:00:57,660
gonna look at how we can recover

22
00:00:55,800 --> 00:01:00,419
function information from stripped

23
00:00:57,660 --> 00:01:03,510
binaries<font color="#E5E5E5"> there have been compiled by</font><font color="#CCCCCC"> the</font>

24
00:01:00,420 --> 00:01:06,360
go compiler and<font color="#E5E5E5"> then we take a look at</font>

25
00:01:03,510 --> 00:01:09,060
some<font color="#CCCCCC"> malware and</font><font color="#E5E5E5"> we'll apply it sort of</font>

26
00:01:06,360 --> 00:01:12,150
<font color="#E5E5E5">this but a tool and extract and get</font>

27
00:01:09,060 --> 00:01:14,520
information from<font color="#CCCCCC"> them that otherwise is</font>

28
00:01:12,150 --> 00:01:15,960
sort of<font color="#E5E5E5"> hidden and then we'd take a look</font>

29
00:01:14,520 --> 00:01:18,840
at see<font color="#CCCCCC"> what else we can find</font><font color="#E5E5E5"> in the</font>

30
00:01:15,960 --> 00:01:23,990
binaries and what we can draw from<font color="#E5E5E5"> those</font>

31
00:01:18,840 --> 00:01:26,520
conclusions<font color="#E5E5E5"> so to start with</font><font color="#CCCCCC"> goal was</font>

32
00:01:23,990 --> 00:01:29,729
sort of it worked on internally at

33
00:01:26,520 --> 00:01:32,298
Google and starting<font color="#E5E5E5"> off at 2007 by</font><font color="#CCCCCC"> Rob</font>

34
00:01:29,729 --> 00:01:37,770
charisma and Rob Pike and Ken Thompson

35
00:01:32,299 --> 00:01:41,610
<font color="#E5E5E5">it's designed to be a memory language is</font>

36
00:01:37,770 --> 00:01:45,600
using a garbage<font color="#CCCCCC"> collector</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> its static</font>

37
00:01:41,610 --> 00:01:47,820
typing and the language<font color="#E5E5E5"> was sort of</font>

38
00:01:45,600 --> 00:01:50,399
designed to be a new language<font color="#CCCCCC"> for the</font>

39
00:01:47,820 --> 00:01:55,689
21st century<font color="#CCCCCC"> so it has wealth support</font>

40
00:01:50,399 --> 00:02:01,149
for and multi-threading<font color="#E5E5E5"> and not working</font>

41
00:01:55,689 --> 00:02:04,029
etc<font color="#E5E5E5"> the language is relative simple and</font>

42
00:02:01,149 --> 00:02:07,030
easy to read<font color="#CCCCCC"> and which</font><font color="#E5E5E5"> is mainly</font><font color="#CCCCCC"> civil</font>

43
00:02:04,030 --> 00:02:12,190
<font color="#CCCCCC">bite from</font><font color="#E5E5E5"> design so this is a hello</font>

44
00:02:07,030 --> 00:02:15,190
<font color="#CCCCCC">world and go and each all code in go is</font>

45
00:02:12,190 --> 00:02:18,400
part<font color="#E5E5E5"> of a package and the package that's</font>

46
00:02:15,190 --> 00:02:19,540
<font color="#E5E5E5">been executed it's called main and so in</font>

47
00:02:18,400 --> 00:02:21,970
here<font color="#E5E5E5"> we</font><font color="#CCCCCC"> were sort of looking for the</font>

48
00:02:19,540 --> 00:02:24,989
main package with the main function that

49
00:02:21,970 --> 00:02:27,220
would<font color="#E5E5E5"> execute we're importing a a</font>

50
00:02:24,989 --> 00:02:29,769
standard<font color="#E5E5E5"> library for</font><font color="#CCCCCC"> doing some</font>

51
00:02:27,220 --> 00:02:32,379
formatting<font color="#E5E5E5"> and printing and essentially</font>

52
00:02:29,769 --> 00:02:38,019
just writes hello<font color="#E5E5E5"> world to this manner</font>

53
00:02:32,379 --> 00:02:41,410
<font color="#E5E5E5">to the output go has support for sort of</font>

54
00:02:38,019 --> 00:02:43,000
most a standard type numerical types

55
00:02:41,410 --> 00:02:46,510
we've both had<font color="#CCCCCC"> four unsigned and signed</font>

56
00:02:43,000 --> 00:02:48,879
integers of specific sites in size and

57
00:02:46,510 --> 00:02:53,739
it also have support for floats<font color="#E5E5E5"> and</font>

58
00:02:48,879 --> 00:02:56,048
complex<font color="#CCCCCC"> numbers</font><font color="#E5E5E5"> it also has a couple</font><font color="#CCCCCC"> of</font>

59
00:02:53,739 --> 00:02:56,670
aliases so for example a byte<font color="#E5E5E5"> is an</font>

60
00:02:56,049 --> 00:03:00,340
unint

61
00:02:56,670 --> 00:03:04,388
<font color="#E5E5E5">eight and in a room and which is more</font>

62
00:03:00,340 --> 00:03:07,840
used for characters<font color="#E5E5E5"> so go has a support</font>

63
00:03:04,389 --> 00:03:12,669
for utf-8 and this is sort of handled by

64
00:03:07,840 --> 00:03:17,620
<font color="#E5E5E5">roon is a utf-8 character it also</font><font color="#CCCCCC"> allow</font>

65
00:03:12,669 --> 00:03:19,810
sort<font color="#E5E5E5"> of the programmer to use a non size</font>

66
00:03:17,620 --> 00:03:22,930
sort of a integer<font color="#E5E5E5"> so you have enough a</font>

67
00:03:19,810 --> 00:03:24,940
<font color="#E5E5E5">nun size you ain't in an</font><font color="#CCCCCC"> int these are</font>

68
00:03:22,930 --> 00:03:26,799
the sizes<font color="#CCCCCC"> of them are dependent</font><font color="#E5E5E5"> on the</font>

69
00:03:24,940 --> 00:03:29,829
architecture that<font color="#E5E5E5"> you're compiling it to</font>

70
00:03:26,799 --> 00:03:35,680
and then it also has a pointer

71
00:03:29,829 --> 00:03:39,190
representation for these strings<font color="#E5E5E5"> so go</font>

72
00:03:35,680 --> 00:03:41,109
has<font color="#CCCCCC"> first-class</font><font color="#E5E5E5"> support for Strings you</font>

73
00:03:39,190 --> 00:03:42,880
can<font color="#CCCCCC"> either</font><font color="#E5E5E5"> sort of the sort of define it</font>

74
00:03:41,109 --> 00:03:46,349
at the top<font color="#E5E5E5"> where you tell it that this</font>

75
00:03:42,880 --> 00:03:50,530
<font color="#E5E5E5">is a specific</font><font color="#CCCCCC"> string</font><font color="#E5E5E5"> or you can allow a</font>

76
00:03:46,349 --> 00:03:54,099
<font color="#E5E5E5">compiler to do the they will resolve the</font>

77
00:03:50,530 --> 00:03:56,319
type for it under<font color="#CCCCCC"> the hood a string it</font>

78
00:03:54,099 --> 00:03:58,690
is<font color="#E5E5E5"> different this go strings are</font>

79
00:03:56,319 --> 00:04:01,358
different<font color="#CCCCCC"> from C strings</font><font color="#E5E5E5"> so it's using</font>

80
00:03:58,690 --> 00:04:03,069
two words to represent<font color="#CCCCCC"> the data and you</font>

81
00:04:01,359 --> 00:04:04,940
have<font color="#E5E5E5"> first a pointer that</font><font color="#CCCCCC"> points to</font>

82
00:04:03,069 --> 00:04:09,470
where<font color="#E5E5E5"> the data is located and then</font>

83
00:04:04,940 --> 00:04:15,050
a length parameter<font color="#E5E5E5"> so this makes length</font>

84
00:04:09,470 --> 00:04:18,890
calculations of strings constant<font color="#CCCCCC"> array</font>

85
00:04:15,050 --> 00:04:20,600
<font color="#CCCCCC">since and then on top of that go has a</font>

86
00:04:18,890 --> 00:04:23,570
sort of a functionality<font color="#CCCCCC"> called slices</font>

87
00:04:20,600 --> 00:04:26,900
and arrays are the same as what they are

88
00:04:23,570 --> 00:04:30,710
<font color="#E5E5E5">and see where slices are more similar to</font>

89
00:04:26,900 --> 00:04:33,340
Python lists so a slice can grow and

90
00:04:30,710 --> 00:04:37,729
it's an abstraction on top of the<font color="#CCCCCC"> race</font>

91
00:04:33,340 --> 00:04:40,099
the slice is represented by first<font color="#E5E5E5"> a</font>

92
00:04:37,730 --> 00:04:41,960
<font color="#E5E5E5">pointed toward a day to start and then</font>

93
00:04:40,100 --> 00:04:45,680
<font color="#CCCCCC">the length of the current slice and</font><font color="#E5E5E5"> then</font>

94
00:04:41,960 --> 00:04:48,469
a capacity the capacity<font color="#E5E5E5"> if it's set this</font>

95
00:04:45,680 --> 00:04:50,960
to<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> a this slice can grow until you</font>

96
00:04:48,470 --> 00:04:55,570
run out<font color="#CCCCCC"> of memory if</font><font color="#E5E5E5"> you have a value</font>

97
00:04:50,960 --> 00:04:55,570
<font color="#E5E5E5">that's how far</font><font color="#CCCCCC"> it can grow essentially</font>

98
00:04:55,720 --> 00:05:01,340
structs are<font color="#E5E5E5"> very similar to how it's in</font>

99
00:04:58,700 --> 00:05:04,360
<font color="#E5E5E5">C it's just a</font><font color="#CCCCCC"> line that sort of laid out</font>

100
00:05:01,340 --> 00:05:07,280
in in the memory<font color="#E5E5E5"> and the way</font>

101
00:05:04,360 --> 00:05:08,960
object-oriented programming is<font color="#CCCCCC"> done is</font>

102
00:05:07,280 --> 00:05:12,380
through interfaces where you sort<font color="#E5E5E5"> of</font>

103
00:05:08,960 --> 00:05:14,960
specify<font color="#E5E5E5"> a function signature and as long</font>

104
00:05:12,380 --> 00:05:18,680
as<font color="#E5E5E5"> the type implements that function</font>

105
00:05:14,960 --> 00:05:20,840
signature<font color="#E5E5E5"> and it sort</font><font color="#CCCCCC"> of a satisfies the</font>

106
00:05:18,680 --> 00:05:22,880
interface<font color="#CCCCCC"> and under the hood this</font><font color="#E5E5E5"> is</font>

107
00:05:20,840 --> 00:05:25,340
<font color="#E5E5E5">done through a V table that were points</font>

108
00:05:22,880 --> 00:05:29,770
to<font color="#CCCCCC"> these specific</font><font color="#E5E5E5"> functions and then a</font>

109
00:05:25,340 --> 00:05:29,770
pointer to<font color="#E5E5E5"> the actual</font><font color="#CCCCCC"> underlying struct</font>

110
00:05:30,730 --> 00:05:34,370
so let's take a<font color="#E5E5E5"> look a little</font><font color="#CCCCCC"> bit</font><font color="#E5E5E5"> under</font>

111
00:05:32,900 --> 00:05:39,489
<font color="#E5E5E5">the hood what happens when you compile</font>

112
00:05:34,370 --> 00:05:41,930
it so this is a snippet<font color="#CCCCCC"> from a malware</font>

113
00:05:39,490 --> 00:05:48,260
<font color="#E5E5E5">that this is one of</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> first bits that</font>

114
00:05:41,930 --> 00:05:51,350
runs and so what it does<font color="#CCCCCC"> is it first</font>

115
00:05:48,260 --> 00:05:54,020
takes and reads in the argument list

116
00:05:51,350 --> 00:05:57,100
<font color="#CCCCCC">that</font><font color="#E5E5E5"> was executed and so what it's</font>

117
00:05:54,020 --> 00:05:57,099
looking<font color="#E5E5E5"> at for is the</font>

118
00:05:57,210 --> 00:06:01,448
first entry in the<font color="#E5E5E5"> argument</font><font color="#CCCCCC"> list which</font>

119
00:05:59,919 --> 00:06:05,049
will be the name<font color="#CCCCCC"> of the binary that was</font>

120
00:06:01,449 --> 00:06:08,680
executed<font color="#CCCCCC"> and it</font><font color="#E5E5E5"> would read this one in</font>

121
00:06:05,050 --> 00:06:11,439
<font color="#CCCCCC">and to move it into re</font><font color="#E5E5E5"> X and then take</font>

122
00:06:08,680 --> 00:06:15,370
the next<font color="#CCCCCC"> parameter after</font><font color="#E5E5E5"> which would</font>

123
00:06:11,439 --> 00:06:17,740
suggest<font color="#E5E5E5"> that this is a string</font><font color="#CCCCCC"> and then</font>

124
00:06:15,370 --> 00:06:19,509
<font color="#CCCCCC">will move this onto the stack so here's</font>

125
00:06:17,740 --> 00:06:22,419
you have<font color="#CCCCCC"> their pointer to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> red</font><font color="#E5E5E5"> data</font>

126
00:06:19,509 --> 00:06:25,090
start and then your length parameter and

127
00:06:22,419 --> 00:06:27,849
<font color="#E5E5E5">then it will call a standard library</font>

128
00:06:25,090 --> 00:06:30,460
<font color="#CCCCCC">just</font><font color="#E5E5E5"> to get the base element hundreds</font>

129
00:06:27,849 --> 00:06:33,419
and the return value<font color="#CCCCCC"> is actually</font>

130
00:06:30,460 --> 00:06:35,948
<font color="#E5E5E5">returned also on the stack so</font><font color="#CCCCCC"> you see</font>

131
00:06:33,419 --> 00:06:37,750
the calling<font color="#CCCCCC"> function then</font><font color="#E5E5E5"> basically</font>

132
00:06:35,949 --> 00:06:41,949
pulling those data off the<font color="#E5E5E5"> stack and</font><font color="#CCCCCC"> put</font>

133
00:06:37,750 --> 00:06:44,080
it into its<font color="#CCCCCC"> local variables so the</font>

134
00:06:41,949 --> 00:06:46,810
difference we have<font color="#E5E5E5"> normally you would</font>

135
00:06:44,080 --> 00:06:50,849
see just a<font color="#E5E5E5"> bunch of push and pops and</font>

136
00:06:46,810 --> 00:06:54,129
<font color="#E5E5E5">the go compiler instead is opting for a</font>

137
00:06:50,849 --> 00:07:00,520
faster runtime over smaller size in

138
00:06:54,129 --> 00:07:03,279
terms<font color="#E5E5E5"> of</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> binary so on top</font><font color="#CCCCCC"> of this and</font>

139
00:07:00,520 --> 00:07:07,479
since it's designed for multi-threading

140
00:07:03,279 --> 00:07:11,849
and<font color="#CCCCCC"> multi-core</font><font color="#E5E5E5"> currency it has a concept</font>

141
00:07:07,479 --> 00:07:16,589
of call of a go routine<font color="#CCCCCC"> a go routine</font><font color="#E5E5E5"> is</font>

142
00:07:11,849 --> 00:07:19,750
simple<font color="#E5E5E5"> similar to a thin thread yeah</font>

143
00:07:16,589 --> 00:07:22,150
it's executed we<font color="#E5E5E5"> have this</font><font color="#CCCCCC"> keyword so</font>

144
00:07:19,750 --> 00:07:25,719
<font color="#E5E5E5">you actually will call go before the</font>

145
00:07:22,150 --> 00:07:27,698
function<font color="#CCCCCC"> that's executed and then this</font>

146
00:07:25,719 --> 00:07:30,219
<font color="#CCCCCC">system</font><font color="#E5E5E5"> put on a scheduler that runs</font>

147
00:07:27,699 --> 00:07:32,560
internally in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> runtime and</font><font color="#E5E5E5"> thus get</font>

148
00:07:30,219 --> 00:07:34,389
the<font color="#CCCCCC"> runtime selects between the</font>

149
00:07:32,560 --> 00:07:36,250
different go routine or who will be

150
00:07:34,389 --> 00:07:38,550
<font color="#E5E5E5">executing what so it's basically</font>

151
00:07:36,250 --> 00:07:42,490
scheduling but in the<font color="#E5E5E5"> actual current</font>

152
00:07:38,550 --> 00:07:45,180
application and under the<font color="#E5E5E5"> hood this is</font>

153
00:07:42,490 --> 00:07:49,210
<font color="#E5E5E5">done through the call to new proc and</font>

154
00:07:45,180 --> 00:07:52,029
<font color="#CCCCCC">which</font><font color="#E5E5E5"> takes a</font><font color="#CCCCCC"> sizeof integer and then a</font>

155
00:07:49,210 --> 00:07:56,258
function<font color="#E5E5E5"> pointer the size</font><font color="#CCCCCC"> tell-tell</font>

156
00:07:52,029 --> 00:07:59,529
<font color="#CCCCCC">state scheduler how many arguments</font><font color="#E5E5E5"> this</font>

157
00:07:56,259 --> 00:08:01,270
function<font color="#E5E5E5"> takes and it requires that</font><font color="#CCCCCC"> all</font>

158
00:07:59,529 --> 00:08:02,680
the arguments<font color="#CCCCCC"> for</font><font color="#E5E5E5"> the function</font><font color="#CCCCCC"> to be</font>

159
00:08:01,270 --> 00:08:06,310
<font color="#CCCCCC">called has been pushed on the stack</font>

160
00:08:02,680 --> 00:08:07,690
before<font color="#E5E5E5"> it's executed</font>

161
00:08:06,310 --> 00:08:08,900
so essentially you will have this

162
00:08:07,690 --> 00:08:14,060
<font color="#E5E5E5">structure</font>

163
00:08:08,900 --> 00:08:17,840
let's kick it off<font color="#E5E5E5"> okay so now can I know</font>

164
00:08:14,060 --> 00:08:19,340
a<font color="#E5E5E5"> little bit haldi what's and what's</font>

165
00:08:17,840 --> 00:08:21,099
under the<font color="#CCCCCC"> hood so</font><font color="#E5E5E5"> let's take a look at</font>

166
00:08:19,340 --> 00:08:26,619
how we can<font color="#CCCCCC"> actually recover functions</font>

167
00:08:21,100 --> 00:08:31,550
information so here we have the simple

168
00:08:26,620 --> 00:08:33,169
demo program and so what essentially

169
00:08:31,550 --> 00:08:36,710
<font color="#E5E5E5">we're gonna do is just panic which is</font>

170
00:08:33,169 --> 00:08:40,039
the way Google<font color="#E5E5E5"> sort of throw was the go</font>

171
00:08:36,710 --> 00:08:43,190
throws exceptions<font color="#E5E5E5"> we're just gonna panic</font>

172
00:08:40,039 --> 00:08:45,470
hello world and if we<font color="#E5E5E5"> compile that and</font>

173
00:08:43,190 --> 00:08:48,440
<font color="#CCCCCC">tells the compiler</font><font color="#E5E5E5"> to strip the binary</font>

174
00:08:45,470 --> 00:08:51,470
<font color="#E5E5E5">and remove all</font><font color="#CCCCCC"> the possible all</font><font color="#E5E5E5"> the</font>

175
00:08:48,440 --> 00:08:54,650
debug information<font color="#E5E5E5"> and output from files</font>

176
00:08:51,470 --> 00:08:57,740
as this is a stripped binary<font color="#E5E5E5"> and then</font>

177
00:08:54,650 --> 00:09:01,640
<font color="#E5E5E5">when we run it we get the exception</font>

178
00:08:57,740 --> 00:09:04,580
which says this file path<font color="#E5E5E5"> where actually</font>

179
00:09:01,640 --> 00:09:06,830
the exception<font color="#CCCCCC"> have had so</font><font color="#E5E5E5"> you tells us</font>

180
00:09:04,580 --> 00:09:11,810
that we throw an exception on<font color="#CCCCCC"> line</font><font color="#E5E5E5"> four</font>

181
00:09:06,830 --> 00:09:15,350
<font color="#E5E5E5">so even though we've removed all symbols</font>

182
00:09:11,810 --> 00:09:16,969
or external symbols go I'll have the

183
00:09:15,350 --> 00:09:20,150
capability to figure out which line

184
00:09:16,970 --> 00:09:23,890
source like<font color="#E5E5E5"> they</font><font color="#CCCCCC"> actually this exception</font>

185
00:09:20,150 --> 00:09:26,240
was thrown<font color="#E5E5E5"> so where this comes from</font>

186
00:09:23,890 --> 00:09:27,439
if you take a look you find you can

187
00:09:26,240 --> 00:09:29,779
actually<font color="#E5E5E5"> find the strings for these</font>

188
00:09:27,440 --> 00:09:34,970
function names and they're located<font color="#CCCCCC"> in a</font>

189
00:09:29,779 --> 00:09:38,480
table<font color="#CCCCCC"> that's called go PCL and tab which</font>

190
00:09:34,970 --> 00:09:45,080
is<font color="#E5E5E5"> for alpha binaries is a it's separate</font>

191
00:09:38,480 --> 00:09:46,820
section this table is a sort of a

192
00:09:45,080 --> 00:09:50,300
heritage from<font color="#E5E5E5"> or a something that was</font>

193
00:09:46,820 --> 00:09:53,450
came in from plan<font color="#E5E5E5"> nine so if you this is</font>

194
00:09:50,300 --> 00:09:58,279
<font color="#CCCCCC">a man output from man out</font><font color="#E5E5E5"> and on plan</font>

195
00:09:53,450 --> 00:10:01,100
nine and it's talking about<font color="#E5E5E5"> that you</font>

196
00:09:58,279 --> 00:10:04,130
have a<font color="#CCCCCC"> PC line number table</font><font color="#E5E5E5"> in the</font>

197
00:10:01,100 --> 00:10:06,830
binary<font color="#CCCCCC"> maybe further down and</font><font color="#E5E5E5"> they in</font>

198
00:10:04,130 --> 00:10:10,279
the main page that<font color="#E5E5E5"> says this is reused</font>

199
00:10:06,830 --> 00:10:15,320
<font color="#CCCCCC">to recover source line number from a</font>

200
00:10:10,279 --> 00:10:19,790
failure so this<font color="#E5E5E5"> function I was attitude</font>

201
00:10:15,320 --> 00:10:22,020
<font color="#CCCCCC">the go compiler</font><font color="#E5E5E5"> in version 1.2</font><font color="#CCCCCC"> and it is</font>

202
00:10:19,790 --> 00:10:24,630
there to sort of provide a accurate

203
00:10:22,020 --> 00:10:29,630
and a way of<font color="#E5E5E5"> debugging</font><font color="#CCCCCC"> to figure out</font>

204
00:10:24,630 --> 00:10:32,339
where the exception<font color="#CCCCCC"> was</font><font color="#E5E5E5"> wrong and</font>

205
00:10:29,630 --> 00:10:35,130
<font color="#CCCCCC">luckily for us</font><font color="#E5E5E5"> who wants to sort of</font>

206
00:10:32,339 --> 00:10:37,470
<font color="#E5E5E5">utilize this to extract information from</font>

207
00:10:35,130 --> 00:10:39,630
straight binaries<font color="#E5E5E5"> the debug package in</font>

208
00:10:37,470 --> 00:10:43,440
the standard library has<font color="#CCCCCC"> functions to</font>

209
00:10:39,630 --> 00:10:45,270
read<font color="#E5E5E5"> this table and extract it and this</font>

210
00:10:43,440 --> 00:10:48,089
is a<font color="#E5E5E5"> snippet of code that's taken</font><font color="#CCCCCC"> from</font>

211
00:10:45,270 --> 00:10:51,569
the test and which would read in this

212
00:10:48,089 --> 00:10:54,120
<font color="#E5E5E5">one an elf binary it looks like it</font>

213
00:10:51,570 --> 00:10:57,870
expecting the symbol table<font color="#E5E5E5"> but luckily</font>

214
00:10:54,120 --> 00:11:05,220
the symbol can<font color="#E5E5E5"> be empty and it will</font>

215
00:10:57,870 --> 00:11:09,000
generate<font color="#CCCCCC"> the table</font><font color="#E5E5E5"> correctly so the the</font>

216
00:11:05,220 --> 00:11:12,750
table that's returned has in most cases

217
00:11:09,000 --> 00:11:16,800
<font color="#CCCCCC">a an array of internal</font><font color="#E5E5E5"> microphones and</font>

218
00:11:12,750 --> 00:11:20,040
then and as this<font color="#CCCCCC"> lying table using the</font>

219
00:11:16,800 --> 00:11:22,050
line table<font color="#E5E5E5"> we can actually get the from</font>

220
00:11:20,040 --> 00:11:24,750
the program<font color="#E5E5E5"> counter</font><font color="#CCCCCC"> get the source code</font>

221
00:11:22,050 --> 00:11:26,189
line number or vice versa you<font color="#CCCCCC"> can use</font>

222
00:11:24,750 --> 00:11:28,279
the source code<font color="#CCCCCC"> line</font><font color="#E5E5E5"> number</font><font color="#CCCCCC"> to family</font>

223
00:11:26,190 --> 00:11:31,230
<font color="#CCCCCC">pour the program counter in the binary</font>

224
00:11:28,279 --> 00:11:33,500
so this is kind<font color="#CCCCCC"> of very very interesting</font>

225
00:11:31,230 --> 00:11:38,130
useful<font color="#CCCCCC"> when you want to</font><font color="#E5E5E5"> look at malware</font>

226
00:11:33,500 --> 00:11:42,630
so let's take a look at some so I just

227
00:11:38,130 --> 00:11:46,110
have a little<font color="#E5E5E5"> tool</font><font color="#CCCCCC"> here that is sort of</font>

228
00:11:42,630 --> 00:11:47,610
reading this table it will and extract

229
00:11:46,110 --> 00:11:50,810
all<font color="#CCCCCC"> the</font><font color="#E5E5E5"> functions in and just look at</font>

230
00:11:47,610 --> 00:11:52,950
the specific one for<font color="#CCCCCC"> the</font><font color="#E5E5E5"> main and then</font>

231
00:11:50,810 --> 00:11:55,739
packages<font color="#CCCCCC"> that are</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> imports or</font>

232
00:11:52,950 --> 00:11:57,300
third-party vendors or<font color="#E5E5E5"> stat and sort of</font>

233
00:11:55,740 --> 00:12:03,709
standard library and<font color="#CCCCCC"> just focus</font><font color="#E5E5E5"> on the</font>

234
00:11:57,300 --> 00:12:03,709
malware code<font color="#E5E5E5"> and it will try</font><font color="#CCCCCC"> to guess</font>

235
00:12:05,930 --> 00:12:14,040
not right no I can't could have to start

236
00:12:09,029 --> 00:12:20,790
over<font color="#CCCCCC"> then say</font><font color="#E5E5E5"> and it will hopefully get</font>

237
00:12:14,040 --> 00:12:23,160
more text so it<font color="#E5E5E5"> it's using the the</font>

238
00:12:20,790 --> 00:12:24,660
information<font color="#CCCCCC"> and tries to guess the</font>

239
00:12:23,160 --> 00:12:27,240
length of the functions in<font color="#CCCCCC"> the source</font>

240
00:12:24,660 --> 00:12:30,540
code<font color="#E5E5E5"> and then also sort</font><font color="#CCCCCC"> of structure a</font>

241
00:12:27,240 --> 00:12:34,170
source code<font color="#CCCCCC"> trace</font><font color="#E5E5E5"> so here's an example</font>

242
00:12:30,540 --> 00:12:35,199
for a and this<font color="#CCCCCC"> is a malware</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> was</font>

243
00:12:34,170 --> 00:12:39,040
reported<font color="#E5E5E5"> about a year</font>

244
00:12:35,200 --> 00:12:42,760
<font color="#CCCCCC">bye Cisco Telus and they sort of</font>

245
00:12:39,040 --> 00:12:44,640
reported a<font color="#CCCCCC"> BNA something that was</font>

246
00:12:42,760 --> 00:12:47,020
<font color="#E5E5E5">scanning and certain looking for SSH</font>

247
00:12:44,640 --> 00:12:48,580
service and then brute forcing them and

248
00:12:47,020 --> 00:12:54,340
<font color="#E5E5E5">sort</font><font color="#CCCCCC"> of spreading spreading that way</font>

249
00:12:48,580 --> 00:12:56,110
and what we have essentially<font color="#CCCCCC"> is it's</font>

250
00:12:54,340 --> 00:12:57,850
finding<font color="#E5E5E5"> where the packets of the mains</font>

251
00:12:56,110 --> 00:12:59,380
this is the source<font color="#CCCCCC"> look this is actually</font>

252
00:12:57,850 --> 00:13:01,510
<font color="#E5E5E5">folder location where the file was</font>

253
00:12:59,380 --> 00:13:05,500
located<font color="#E5E5E5"> when it was compiled and by the</font>

254
00:13:01,510 --> 00:13:08,740
author<font color="#E5E5E5"> here's the the source code file</font>

255
00:13:05,500 --> 00:13:10,630
<font color="#E5E5E5">and then under there you have</font><font color="#CCCCCC"> serve</font><font color="#E5E5E5"> all</font>

256
00:13:08,740 --> 00:13:13,170
the functions starting<font color="#E5E5E5"> from the first</font>

257
00:13:10,630 --> 00:13:18,610
<font color="#E5E5E5">line number starting</font><font color="#CCCCCC"> actually from line</font>

258
00:13:13,170 --> 00:13:20,949
188<font color="#CCCCCC"> to at 181 and then it's sort of</font>

259
00:13:18,610 --> 00:13:23,050
guessing<font color="#E5E5E5"> and some guessing there's a</font>

260
00:13:20,950 --> 00:13:28,030
bunch of<font color="#CCCCCC"> struct</font><font color="#E5E5E5"> defined on top of that</font>

261
00:13:23,050 --> 00:13:31,150
that<font color="#E5E5E5"> we can't see and</font><font color="#CCCCCC"> so this does from</font>

262
00:13:28,030 --> 00:13:36,640
a this one was only targeting mainly

263
00:13:31,150 --> 00:13:42,189
like<font color="#E5E5E5"> Linux malware and at the end of</font>

264
00:13:36,640 --> 00:13:44,170
last year<font color="#CCCCCC"> and there was a new version at</font>

265
00:13:42,190 --> 00:13:47,080
one<font color="#E5E5E5"> version of</font><font color="#CCCCCC"> Saburo</font><font color="#E5E5E5"> Brizzy that was</font>

266
00:13:44,170 --> 00:13:50,819
found<font color="#E5E5E5"> I think it was starting in October</font>

267
00:13:47,080 --> 00:13:54,910
and this<font color="#E5E5E5"> is a malware that's used by</font><font color="#CCCCCC"> the</font>

268
00:13:50,820 --> 00:13:55,690
<font color="#CCCCCC">russian a apt</font><font color="#E5E5E5"> group</font><font color="#CCCCCC"> apt 28 and it's</font>

269
00:13:54,910 --> 00:13:58,719
<font color="#E5E5E5">downloader</font>

270
00:13:55,690 --> 00:14:00,970
they have a way<font color="#CCCCCC"> of writing it in</font>

271
00:13:58,720 --> 00:14:04,090
<font color="#CCCCCC">multiple languages too subtle</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> sort of</font>

272
00:14:00,970 --> 00:14:06,610
throw off<font color="#CCCCCC"> analysts and one of the</font>

273
00:14:04,090 --> 00:14:08,230
samples<font color="#CCCCCC"> you</font><font color="#E5E5E5"> could get was representing</font>

274
00:14:06,610 --> 00:14:09,670
sort of all<font color="#E5E5E5"> of the functions</font><font color="#CCCCCC"> that we</font>

275
00:14:08,230 --> 00:14:19,630
have so they hadn't<font color="#E5E5E5"> done any</font><font color="#CCCCCC"> of</font>

276
00:14:09,670 --> 00:14:21,420
<font color="#E5E5E5">obfuscation so there have</font><font color="#CCCCCC"> been a couple</font>

277
00:14:19,630 --> 00:14:24,689
of sort of malware that's been

278
00:14:21,420 --> 00:14:27,520
obfuscated so for example we have

279
00:14:24,690 --> 00:14:30,100
one-way<font color="#CCCCCC"> annals gets through this or</font>

280
00:14:27,520 --> 00:14:32,410
malware authors<font color="#E5E5E5"> and sort of by renaming</font>

281
00:14:30,100 --> 00:14:33,820
<font color="#E5E5E5">the functions so</font><font color="#CCCCCC"> we can sort of tell</font>

282
00:14:32,410 --> 00:14:36,280
<font color="#E5E5E5">from the function name or what it's</font>

283
00:14:33,820 --> 00:14:39,520
doing and we do have to<font color="#CCCCCC"> sell</font><font color="#E5E5E5"> the package</font>

284
00:14:36,280 --> 00:14:41,860
name but and<font color="#E5E5E5"> also with all of the</font>

285
00:14:39,520 --> 00:14:45,910
<font color="#E5E5E5">different libraries</font><font color="#CCCCCC"> that they're using</font>

286
00:14:41,860 --> 00:14:48,880
<font color="#CCCCCC">are not obfuscated so it's a little</font><font color="#E5E5E5"> bit</font>

287
00:14:45,910 --> 00:14:58,389
of a<font color="#E5E5E5"> hurdle but still</font><font color="#CCCCCC"> we're</font>

288
00:14:48,880 --> 00:15:01,120
working on<font color="#E5E5E5"> a so just on top of sort of</font>

289
00:14:58,389 --> 00:15:04,990
function names<font color="#CCCCCC"> it's also possible of</font>

290
00:15:01,120 --> 00:15:09,339
recovering<font color="#CCCCCC"> it</font><font color="#E5E5E5"> type information so this</font>

291
00:15:04,990 --> 00:15:11,680
is a simple little<font color="#E5E5E5"> demo and in this sort</font>

292
00:15:09,339 --> 00:15:14,110
of code we're defining our own<font color="#E5E5E5"> struct</font>

293
00:15:11,680 --> 00:15:17,050
<font color="#E5E5E5">that</font><font color="#CCCCCC"> just will contain one</font><font color="#E5E5E5"> string and</font>

294
00:15:14,110 --> 00:15:19,000
one<font color="#E5E5E5"> integer and then our code the</font>

295
00:15:17,050 --> 00:15:21,519
substantiates a new version<font color="#E5E5E5"> like a new</font>

296
00:15:19,000 --> 00:15:23,319
instance<font color="#E5E5E5"> of this and</font><font color="#CCCCCC"> assigned a string</font>

297
00:15:21,519 --> 00:15:27,329
<font color="#E5E5E5">and an integer to it and then we will</font>

298
00:15:23,319 --> 00:15:30,790
just<font color="#E5E5E5"> print out what the struct is the</font>

299
00:15:27,329 --> 00:15:33,930
compilation of this sort<font color="#CCCCCC"> of return this</font>

300
00:15:30,790 --> 00:15:37,389
kind<font color="#E5E5E5"> of code just sort of move</font>

301
00:15:33,930 --> 00:15:39,099
<font color="#E5E5E5">highlighting them important part and at</font>

302
00:15:37,389 --> 00:15:43,750
the bottom<font color="#E5E5E5"> we</font><font color="#CCCCCC"> see the call to printf and</font>

303
00:15:39,100 --> 00:15:46,990
<font color="#CCCCCC">here we see the format</font><font color="#E5E5E5"> string being</font>

304
00:15:43,750 --> 00:15:49,690
pushed to this actually being<font color="#E5E5E5"> loaded</font>

305
00:15:46,990 --> 00:15:51,970
into this<font color="#E5E5E5"> onto the stack and then we can</font>

306
00:15:49,690 --> 00:15:54,250
see the two different<font color="#E5E5E5"> values</font><font color="#CCCCCC"> added</font><font color="#E5E5E5"> to</font>

307
00:15:51,970 --> 00:15:58,620
destruct<font color="#CCCCCC"> and</font><font color="#E5E5E5"> in before that we see a</font>

308
00:15:54,250 --> 00:16:05,139
call to new object<font color="#CCCCCC"> and it's called on</font>

309
00:15:58,620 --> 00:16:08,290
this offset is<font color="#E5E5E5"> used in the call and if</font>

310
00:16:05,139 --> 00:16:10,509
we here's a sort<font color="#E5E5E5"> of a hex dump of this</font>

311
00:16:08,290 --> 00:16:12,459
offset<font color="#E5E5E5"> there's a clear structure there's</font>

312
00:16:10,509 --> 00:16:16,180
a bunch of<font color="#E5E5E5"> structures afterwards it</font>

313
00:16:12,459 --> 00:16:17,829
looks pretty<font color="#E5E5E5"> much the same</font><font color="#CCCCCC"> and what it</font>

314
00:16:16,180 --> 00:16:21,099
turns out is<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is a type that's</font>

315
00:16:17,829 --> 00:16:23,229
called underscore type and this<font color="#E5E5E5"> is the</font>

316
00:16:21,100 --> 00:16:27,519
first three<font color="#E5E5E5"> lines from</font><font color="#CCCCCC"> that hex dump</font>

317
00:16:23,230 --> 00:16:29,199
<font color="#CCCCCC">sort of translate it on to destruct this</font>

318
00:16:27,519 --> 00:16:32,110
<font color="#E5E5E5">actually</font><font color="#CCCCCC"> would tell it so this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> what's</font>

319
00:16:29,199 --> 00:16:34,959
being used<font color="#E5E5E5"> in that new func although</font>

320
00:16:32,110 --> 00:16:36,519
this new object<font color="#E5E5E5"> called and it's using</font>

321
00:16:34,959 --> 00:16:38,729
this and passing that to malloc so it

322
00:16:36,519 --> 00:16:40,660
knows<font color="#E5E5E5"> how much memory needs to allocate</font>

323
00:16:38,730 --> 00:16:42,519
<font color="#CCCCCC">but the structure contains other</font>

324
00:16:40,660 --> 00:16:45,839
information is very very interesting

325
00:16:42,519 --> 00:16:49,480
from sort of<font color="#E5E5E5"> a reverse engineer one</font>

326
00:16:45,839 --> 00:16:53,800
really<font color="#E5E5E5"> cool</font><font color="#CCCCCC"> feature is the</font><font color="#E5E5E5"> kind section</font>

327
00:16:49,480 --> 00:16:57,490
and so this is in enum<font color="#CCCCCC"> and if you look</font>

328
00:16:53,800 --> 00:17:00,099
in the source code for<font color="#CCCCCC"> them</font><font color="#E5E5E5"> for the for</font>

329
00:16:57,490 --> 00:17:02,410
the go compiler<font color="#E5E5E5"> this is returned as a</font>

330
00:17:00,100 --> 00:17:05,079
kind struct<font color="#CCCCCC"> so we know now that</font>

331
00:17:02,410 --> 00:17:09,639
what's here is<font color="#E5E5E5"> reference</font><font color="#CCCCCC"> referred to as</font>

332
00:17:05,079 --> 00:17:13,139
a struct<font color="#CCCCCC"> and the other</font><font color="#E5E5E5"> interesting part</font>

333
00:17:09,640 --> 00:17:18,040
is this name off which is an<font color="#E5E5E5"> offset to a</font>

334
00:17:13,140 --> 00:17:20,100
name type which is a internally sort of

335
00:17:18,040 --> 00:17:23,770
reported which is an internal structure

336
00:17:20,099 --> 00:17:26,230
<font color="#E5E5E5">so it's its own type and it's just a</font>

337
00:17:23,770 --> 00:17:31,810
<font color="#E5E5E5">structure</font><font color="#CCCCCC"> that holds a pointer to a byte</font>

338
00:17:26,230 --> 00:17:35,770
<font color="#E5E5E5">and using that</font><font color="#CCCCCC"> we can calculate where</font>

339
00:17:31,810 --> 00:17:40,030
this<font color="#CCCCCC"> looking this name is located and in</font>

340
00:17:35,770 --> 00:17:42,160
this sample<font color="#CCCCCC"> it's based on where the this</font>

341
00:17:40,030 --> 00:17:44,320
list start and the Lord this the list

342
00:17:42,160 --> 00:17:46,840
starts at<font color="#CCCCCC"> a the</font><font color="#E5E5E5"> section so we can</font>

343
00:17:44,320 --> 00:17:48,669
actually just<font color="#CCCCCC"> take</font><font color="#E5E5E5"> the section and</font>

344
00:17:46,840 --> 00:17:50,709
locate<font color="#CCCCCC"> an absolute location and then</font>

345
00:17:48,670 --> 00:17:55,720
just add the<font color="#CCCCCC"> offset and</font><font color="#E5E5E5"> we'll get where</font>

346
00:17:50,710 --> 00:17:59,830
does is located and it it<font color="#E5E5E5"> returns this</font>

347
00:17:55,720 --> 00:18:03,340
bytes pointed to this byte and the

348
00:17:59,830 --> 00:18:06,100
function and<font color="#E5E5E5"> this type has some methods</font>

349
00:18:03,340 --> 00:18:08,459
to return the string representation<font color="#CCCCCC"> of</font>

350
00:18:06,100 --> 00:18:13,060
it and if you look at that one<font color="#E5E5E5"> it</font>

351
00:18:08,460 --> 00:18:15,130
basically<font color="#E5E5E5"> jumps three and basically</font>

352
00:18:13,060 --> 00:18:19,179
<font color="#E5E5E5">three steps</font><font color="#CCCCCC"> ahead and that's resolved</font>

353
00:18:15,130 --> 00:18:20,710
this the actual<font color="#E5E5E5"> string which is if we</font><font color="#CCCCCC"> if</font>

354
00:18:19,180 --> 00:18:23,620
it's here where it's pointing here's

355
00:18:20,710 --> 00:18:26,410
<font color="#E5E5E5">where the name starts and we</font><font color="#CCCCCC"> basically</font>

356
00:18:23,620 --> 00:18:29,590
gotten<font color="#E5E5E5"> that the name of this item is</font>

357
00:18:26,410 --> 00:18:31,990
called<font color="#E5E5E5"> main dot my struct so we have</font>

358
00:18:29,590 --> 00:18:33,550
both<font color="#E5E5E5"> the package name and what the</font>

359
00:18:31,990 --> 00:18:35,410
author called

360
00:18:33,550 --> 00:18:41,470
the actual structure in the source code

361
00:18:35,410 --> 00:18:43,270
and<font color="#E5E5E5"> there was more stuff below it and so</font>

362
00:18:41,470 --> 00:18:45,340
now<font color="#E5E5E5"> when</font><font color="#CCCCCC"> we know</font><font color="#E5E5E5"> that it is a struct we</font>

363
00:18:43,270 --> 00:18:48,310
can actually<font color="#E5E5E5"> look up and see the what</font>

364
00:18:45,340 --> 00:18:51,459
the real type is there and this is<font color="#CCCCCC"> the</font>

365
00:18:48,310 --> 00:18:54,070
real type so it's actually a<font color="#CCCCCC"> underscores</font>

366
00:18:51,460 --> 00:18:56,650
type that's been embedded in a bigger

367
00:18:54,070 --> 00:19:00,939
struct<font color="#CCCCCC"> and right</font><font color="#E5E5E5"> after</font><font color="#CCCCCC"> that we should</font>

368
00:18:56,650 --> 00:19:03,670
<font color="#E5E5E5">have a name type which is again another</font>

369
00:19:00,940 --> 00:19:05,500
struct and<font color="#E5E5E5"> then some struck fields the</font>

370
00:19:03,670 --> 00:19:07,810
struct field is sort of<font color="#E5E5E5"> a little bit</font><font color="#CCCCCC"> of</font>

371
00:19:05,500 --> 00:19:09,580
an image<font color="#E5E5E5"> of what the main struct is so</font>

372
00:19:07,810 --> 00:19:13,659
it will have<font color="#E5E5E5"> a pointer to some names and</font>

373
00:19:09,580 --> 00:19:16,000
then their own<font color="#CCCCCC"> types so we</font><font color="#E5E5E5"> can</font>

374
00:19:13,660 --> 00:19:22,810
essentially just<font color="#E5E5E5"> unwind this and</font>

375
00:19:16,000 --> 00:19:25,660
reconstruct what type<font color="#E5E5E5"> this is so taking</font>

376
00:19:22,810 --> 00:19:27,250
<font color="#CCCCCC">there the other section here is we're</font>

377
00:19:25,660 --> 00:19:30,130
<font color="#E5E5E5">basically just translating so here's we</font>

378
00:19:27,250 --> 00:19:33,040
have the the<font color="#E5E5E5"> location where the package</font>

379
00:19:30,130 --> 00:19:36,850
name is which in<font color="#E5E5E5"> this term will be</font><font color="#CCCCCC"> Nate</font>

380
00:19:33,040 --> 00:19:40,710
just<font color="#E5E5E5"> main we have the fields which will</font>

381
00:19:36,850 --> 00:19:45,699
be starting from<font color="#E5E5E5"> here as here stay</font><font color="#CCCCCC"> where</font>

382
00:19:40,710 --> 00:19:47,620
<font color="#E5E5E5">the</font><font color="#CCCCCC"> off-site</font><font color="#E5E5E5"> is for the data and then</font>

383
00:19:45,700 --> 00:19:52,050
<font color="#E5E5E5">with two and two so we just know we have</font>

384
00:19:47,620 --> 00:19:54,459
two<font color="#E5E5E5"> fields in the struct and</font><font color="#CCCCCC"> then</font>

385
00:19:52,050 --> 00:19:58,200
<font color="#E5E5E5">looking at this offset is actually just</font>

386
00:19:54,460 --> 00:20:00,580
<font color="#E5E5E5">pop just points down right below it and</font>

387
00:19:58,200 --> 00:20:03,430
there if we can actually just translate

388
00:20:00,580 --> 00:20:05,169
<font color="#E5E5E5">these values so we know it's two we can</font>

389
00:20:03,430 --> 00:20:06,550
get the name<font color="#CCCCCC"> and we can sort of get</font>

390
00:20:05,170 --> 00:20:10,960
<font color="#E5E5E5">where we can figure out what at the time</font>

391
00:20:06,550 --> 00:20:12,879
<font color="#E5E5E5">where the type is located and so if we</font>

392
00:20:10,960 --> 00:20:15,970
just<font color="#E5E5E5"> dereference those we'll get the</font>

393
00:20:12,880 --> 00:20:20,080
actual name of the<font color="#E5E5E5"> fields but</font><font color="#CCCCCC"> in the</font>

394
00:20:15,970 --> 00:20:22,660
structure<font color="#CCCCCC"> and so finally we can</font><font color="#E5E5E5"> sort of</font>

395
00:20:20,080 --> 00:20:29,560
just reconstruct<font color="#E5E5E5"> what this initial</font>

396
00:20:22,660 --> 00:20:35,020
source code was so sort of just to

397
00:20:29,560 --> 00:20:37,090
conclude so go binaries<font color="#CCCCCC"> initially</font><font color="#E5E5E5"> when</font>

398
00:20:35,020 --> 00:20:40,000
you look at them from a as a reverse

399
00:20:37,090 --> 00:20:44,159
engineer their beasts<font color="#CCCCCC"> there it's not</font>

400
00:20:40,000 --> 00:20:49,420
uncommon to come<font color="#E5E5E5"> across a a binary with</font>

401
00:20:44,160 --> 00:20:50,710
<font color="#CCCCCC">6000 plus subroutines</font><font color="#E5E5E5"> so starting out if</font>

402
00:20:49,420 --> 00:20:52,630
you don't have the right to link this

403
00:20:50,710 --> 00:20:54,130
it's really<font color="#CCCCCC"> really hard but</font><font color="#E5E5E5"> if you have</font>

404
00:20:52,630 --> 00:20:56,920
the right<font color="#E5E5E5"> to link or you develop the</font>

405
00:20:54,130 --> 00:21:01,240
<font color="#E5E5E5">right</font><font color="#CCCCCC"> tooling it's relatively easy</font><font color="#E5E5E5"> to</font>

406
00:20:56,920 --> 00:21:04,210
actually deal<font color="#CCCCCC"> with these there's also</font>

407
00:21:01,240 --> 00:21:07,230
<font color="#CCCCCC">massive amount of method metadata</font><font color="#E5E5E5"> this</font>

408
00:21:04,210 --> 00:21:11,680
<font color="#E5E5E5">is not the only thing that's</font><font color="#CCCCCC"> there and</font>

409
00:21:07,230 --> 00:21:12,970
the sort of interesting part is here

410
00:21:11,680 --> 00:21:15,460
that<font color="#E5E5E5"> we can actually recover the</font>

411
00:21:12,970 --> 00:21:17,470
functions and<font color="#E5E5E5"> the type</font><font color="#CCCCCC"> information</font><font color="#E5E5E5"> and</font>

412
00:21:15,460 --> 00:21:20,560
since this is directly<font color="#E5E5E5"> coming from the</font>

413
00:21:17,470 --> 00:21:25,350
source code sort of be translated even

414
00:21:20,560 --> 00:21:28,090
if there's a slight changes to<font color="#E5E5E5"> it there</font>

415
00:21:25,350 --> 00:21:28,780
we can still sort of see<font color="#E5E5E5"> similar area</font>

416
00:21:28,090 --> 00:21:33,070
between

417
00:21:28,780 --> 00:21:35,080
other samples you<font color="#E5E5E5"> can also do an</font>

418
00:21:33,070 --> 00:21:36,760
interesting<font color="#CCCCCC"> of sort</font><font color="#E5E5E5"> of it's interesting</font>

419
00:21:35,080 --> 00:21:39,220
you can<font color="#E5E5E5"> do an educated guess of the</font>

420
00:21:36,760 --> 00:21:40,870
source<font color="#E5E5E5"> code structure and so there are a</font>

421
00:21:39,220 --> 00:21:42,130
couple<font color="#CCCCCC"> of samples that have come across</font>

422
00:21:40,870 --> 00:21:45,459
<font color="#CCCCCC">there being compiled in different</font>

423
00:21:42,130 --> 00:21:47,140
operating systems and but you still have

424
00:21:45,460 --> 00:21:49,240
the sort of<font color="#E5E5E5"> the same source code</font>

425
00:21:47,140 --> 00:21:53,289
structure<font color="#E5E5E5"> so you can map across that</font>

426
00:21:49,240 --> 00:21:55,570
they're the<font color="#CCCCCC"> same and it also allows</font><font color="#E5E5E5"> you</font>

427
00:21:53,289 --> 00:21:57,340
to do sort<font color="#E5E5E5"> of a he met with like</font>

428
00:21:55,570 --> 00:21:59,980
<font color="#E5E5E5">metadata analysis so</font><font color="#CCCCCC"> you can look at</font>

429
00:21:57,340 --> 00:22:04,360
samples that we<font color="#E5E5E5"> compiled forearm or MIPS</font>

430
00:21:59,980 --> 00:22:07,600
<font color="#E5E5E5">and then map them</font><font color="#CCCCCC"> to sort</font><font color="#E5E5E5"> of compare</font>

431
00:22:04,360 --> 00:22:10,330
them to other samples and just using

432
00:22:07,600 --> 00:22:12,428
<font color="#E5E5E5">sort of</font><font color="#CCCCCC"> this source code analysis and</font>

433
00:22:10,330 --> 00:22:14,649
you can sort of see<font color="#CCCCCC"> that they're</font><font color="#E5E5E5"> similar</font>

434
00:22:12,429 --> 00:22:20,200
or the same<font color="#CCCCCC"> they essentially</font><font color="#E5E5E5"> coming from</font>

435
00:22:14,650 --> 00:22:24,299
the same source<font color="#E5E5E5"> so with that and I'm</font>

436
00:22:20,200 --> 00:22:24,299
taking any<font color="#CCCCCC"> questions if there are any</font>

437
00:22:32,370 --> 00:22:42,370
what kind<font color="#E5E5E5"> of tools do you use to re go</font>

438
00:22:36,669 --> 00:22:45,640
samples so this is a it's its own sort

439
00:22:42,370 --> 00:22:49,840
of<font color="#E5E5E5"> a the tool that I use is a tool</font>

440
00:22:45,640 --> 00:22:54,250
that's<font color="#E5E5E5"> written</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> go with itself and it</font>

441
00:22:49,840 --> 00:22:58,899
it<font color="#E5E5E5"> has the capability</font><font color="#CCCCCC"> of being used to</font>

442
00:22:54,250 --> 00:23:04,090
be<font color="#E5E5E5"> used in other tools so so far I</font>

443
00:22:58,900 --> 00:23:09,970
haven't<font color="#E5E5E5"> written a and Ida</font><font color="#CCCCCC"> plugin</font><font color="#E5E5E5"> for it</font>

444
00:23:04,090 --> 00:23:12,189
but I can it works for<font color="#CCCCCC"> art</font><font color="#E5E5E5"> too so it if</font>

445
00:23:09,970 --> 00:23:14,350
you use the art<font color="#E5E5E5"> to you it will basically</font>

446
00:23:12,190 --> 00:23:17,020
run instead<font color="#CCCCCC"> of</font><font color="#E5E5E5"> so printing out</font><font color="#CCCCCC"> the</font>

447
00:23:14,350 --> 00:23:19,840
structure it will reconstruct the

448
00:23:17,020 --> 00:23:24,700
symbols and inject them like it<font color="#E5E5E5"> was a</font>

449
00:23:19,840 --> 00:23:26,470
non stripped binary yeah I think you

450
00:23:24,700 --> 00:23:31,120
partially answered<font color="#E5E5E5"> my question I was</font>

451
00:23:26,470 --> 00:23:33,570
<font color="#E5E5E5">gonna ask about Ida Pro support and it's</font>

452
00:23:31,120 --> 00:23:33,570
in the plans

453
00:23:37,679 --> 00:23:42,609
hello<font color="#E5E5E5"> does the runtime depend on that</font>

454
00:23:40,719 --> 00:23:51,819
metadata<font color="#E5E5E5"> couldn't</font><font color="#CCCCCC"> attacker</font><font color="#E5E5E5"> like strip it</font>

455
00:23:42,609 --> 00:23:53,649
out if they were so the the type data

456
00:23:51,819 --> 00:23:57,789
I think it's I'm pretty sure it's used

457
00:23:53,649 --> 00:24:01,119
by the reflection capability so if you

458
00:23:57,789 --> 00:24:04,329
did strip it<font color="#E5E5E5"> out you may end up crash</font>

459
00:24:01,119 --> 00:24:07,749
and random<font color="#CCCCCC"> places and I think it's the</font>

460
00:24:04,329 --> 00:24:09,639
same with the the<font color="#E5E5E5"> information that's</font>

461
00:24:07,749 --> 00:24:13,809
used to<font color="#E5E5E5"> recover the function information</font>

462
00:24:09,639 --> 00:24:20,498
<font color="#E5E5E5">while it is used for the the panics</font><font color="#CCCCCC"> step</font>

463
00:24:13,809 --> 00:24:22,389
<font color="#E5E5E5">and there are I remember reading a while</font>

464
00:24:20,499 --> 00:24:26,499
back<font color="#E5E5E5"> where people were starting</font><font color="#CCCCCC"> with</font>

465
00:24:22,389 --> 00:24:29,019
<font color="#E5E5E5">using</font><font color="#CCCCCC"> just a normal strip tool to strip</font>

466
00:24:26,499 --> 00:24:32,109
go<font color="#CCCCCC"> binders and kind of resulting random</font>

467
00:24:29,019 --> 00:24:33,999
crashes because it was selectively ruin

468
00:24:32,109 --> 00:24:39,249
basically removing stuff they didn't

469
00:24:33,999 --> 00:24:41,349
need<font color="#E5E5E5"> it</font><font color="#CCCCCC"> and to be honest I don't</font><font color="#E5E5E5"> I don't</font>

470
00:24:39,249 --> 00:24:46,809
know what happens if you<font color="#CCCCCC"> remove the that</font>

471
00:24:41,349 --> 00:24:51,489
table<font color="#CCCCCC"> and now since functions are sort</font>

472
00:24:46,809 --> 00:24:53,428
of first<font color="#E5E5E5"> class citizen in go and this</font>

473
00:24:51,489 --> 00:24:55,539
type information<font color="#CCCCCC"> should</font><font color="#E5E5E5"> also also</font>

474
00:24:53,429 --> 00:24:58,569
there's another representation<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font>

475
00:24:55,539 --> 00:25:00,429
function<font color="#CCCCCC"> in that type list so if you</font>

476
00:24:58,569 --> 00:25:02,438
walk the type<font color="#E5E5E5"> list and get all of these</font>

477
00:25:00,429 --> 00:25:05,139
different types<font color="#E5E5E5"> you can also find all</font>

478
00:25:02,439 --> 00:25:12,669
the functions and you should<font color="#CCCCCC"> very be</font>

479
00:25:05,139 --> 00:25:18,488
able to<font color="#E5E5E5"> recover that so a quick</font><font color="#CCCCCC"> question</font>

480
00:25:12,669 --> 00:25:20,229
about<font color="#E5E5E5"> like heavy I'm right here hey so</font>

481
00:25:18,489 --> 00:25:22,689
have you ever looked<font color="#E5E5E5"> at a binary that</font>

482
00:25:20,229 --> 00:25:26,139
has used the project go off you skate

483
00:25:22,689 --> 00:25:30,189
and<font color="#E5E5E5"> do you have any insights as how that</font>

484
00:25:26,139 --> 00:25:31,988
<font color="#CCCCCC">works or does it</font><font color="#E5E5E5"> provide a few station</font>

485
00:25:30,189 --> 00:25:34,739
<font color="#CCCCCC">against some of the</font><font color="#E5E5E5"> things that</font><font color="#CCCCCC"> you saw</font>

486
00:25:31,989 --> 00:25:38,319
today so I haven't<font color="#E5E5E5"> looked at that</font>

487
00:25:34,739 --> 00:25:42,099
<font color="#E5E5E5">project and but I've come across a bunch</font>

488
00:25:38,319 --> 00:25:45,279
of malware there are obfuscated but they

489
00:25:42,099 --> 00:25:47,350
are only<font color="#CCCCCC"> officers getting</font><font color="#E5E5E5"> their code so</font>

490
00:25:45,279 --> 00:25:50,150
all the

491
00:25:47,350 --> 00:25:51,770
dependency that's pulling in<font color="#E5E5E5"> are not off</font>

492
00:25:50,150 --> 00:25:57,650
you skated<font color="#E5E5E5"> and the standard library or</font>

493
00:25:51,770 --> 00:25:59,720
not off just get it so it is<font color="#E5E5E5"> just a</font>

494
00:25:57,650 --> 00:26:01,429
little<font color="#CCCCCC"> bit of a hurdle</font><font color="#E5E5E5"> now you just have</font>

495
00:25:59,720 --> 00:26:07,610
a random<font color="#E5E5E5"> string but you can see all the</font>

496
00:26:01,429 --> 00:26:10,490
calls that<font color="#E5E5E5"> it's doing so unless unless</font>

497
00:26:07,610 --> 00:26:15,110
it you know would obvious get all of the

498
00:26:10,490 --> 00:26:20,620
functions you<font color="#CCCCCC"> have which may get</font><font color="#E5E5E5"> some</font>

499
00:26:15,110 --> 00:26:23,689
problematic<font color="#CCCCCC"> you know so</font><font color="#E5E5E5"> okay</font><font color="#CCCCCC"> I think</font>

500
00:26:20,620 --> 00:26:26,959
we're out<font color="#E5E5E5"> of time</font><font color="#CCCCCC"> if you have any more</font>

501
00:26:23,690 --> 00:26:30,200
<font color="#E5E5E5">questions</font><font color="#CCCCCC"> you can just talk to</font><font color="#E5E5E5"> your kin</font>

502
00:26:26,960 --> 00:26:31,970
<font color="#E5E5E5">after the session on behalf of besides</font>

503
00:26:30,200 --> 00:26:32,410
we thank you for<font color="#E5E5E5"> your presentation</font>

504
00:26:31,970 --> 00:26:39,520
thank you

505
00:26:32,410 --> 00:26:39,520
[Applause]

