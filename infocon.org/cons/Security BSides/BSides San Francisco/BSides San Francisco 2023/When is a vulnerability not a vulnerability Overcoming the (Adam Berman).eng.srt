1
00:00:00,240 --> 00:00:04,319
our presenter today is Adam Berman

2
00:00:04,319 --> 00:00:07,020
Adam I think it's time

3
00:00:07,020 --> 00:00:08,820
take it away

4
00:00:08,820 --> 00:00:10,920
awesome uh great sounds like the mic is

5
00:00:10,920 --> 00:00:13,019
working hey folks my name is Adam I'm

6
00:00:13,019 --> 00:00:15,000
going to be talking about uh when is a

7
00:00:15,000 --> 00:00:16,619
vulnerability not a vulnerability

8
00:00:16,619 --> 00:00:18,420
overcoming the inundation of supply

9
00:00:18,420 --> 00:00:21,240
chain security alerts

10
00:00:21,240 --> 00:00:23,279
um a little bit about me my name is Adam

11
00:00:23,279 --> 00:00:25,500
Berman I lead the semcarp supply chain

12
00:00:25,500 --> 00:00:28,019
team at semgrip I lead the engineering

13
00:00:28,019 --> 00:00:30,720
and product org uh for our product

14
00:00:30,720 --> 00:00:32,640
um I started as a staff engineer here at

15
00:00:32,640 --> 00:00:34,579
stem grip back when it was called r2c

16
00:00:34,579 --> 00:00:36,540
had the pleasure of getting to build

17
00:00:36,540 --> 00:00:38,640
security tools many of which are open

18
00:00:38,640 --> 00:00:41,219
source if you've used if you haven't

19
00:00:41,219 --> 00:00:42,480
used seven grip before give it a shot

20
00:00:42,480 --> 00:00:45,480
it's a pretty cool tool and yeah I work

21
00:00:45,480 --> 00:00:47,219
at some grip we build the open source

22
00:00:47,219 --> 00:00:49,379
static analysis tool and we're focused

23
00:00:49,379 --> 00:00:52,079
on uh security generally

24
00:00:52,079 --> 00:00:53,879
um so I want to first start with like

25
00:00:53,879 --> 00:00:55,320
who's ever opened up their code base or

26
00:00:55,320 --> 00:00:57,239
security tool and seen a tab with a big

27
00:00:57,239 --> 00:01:00,180
alert that looks something like this

28
00:01:00,180 --> 00:01:03,300
um I think the reality is uh if this

29
00:01:03,300 --> 00:01:04,739
were true if all these vulnerabilities

30
00:01:04,739 --> 00:01:06,240
were really dangerous in our

31
00:01:06,240 --> 00:01:09,780
applications we'd all be fired right

32
00:01:09,780 --> 00:01:12,840
um we all know this isn't real so many

33
00:01:12,840 --> 00:01:15,299
of these alerts are like just not that

34
00:01:15,299 --> 00:01:18,000
dangerous so few represent like a real

35
00:01:18,000 --> 00:01:19,740
risk to the business

36
00:01:19,740 --> 00:01:21,659
um the trick is finding those real

37
00:01:21,659 --> 00:01:22,920
dangerous needles in the haystack

38
00:01:22,920 --> 00:01:25,320
because those can't be ignored

39
00:01:25,320 --> 00:01:26,820
um and the real trick is finding those

40
00:01:26,820 --> 00:01:28,560
needles without having to overwhelm your

41
00:01:28,560 --> 00:01:31,200
team with a huge quantity of work so

42
00:01:31,200 --> 00:01:34,200
today we're going to talk uh about some

43
00:01:34,200 --> 00:01:35,280
strategies for that we're going to talk

44
00:01:35,280 --> 00:01:37,200
about the rise of Open Source usage uh

45
00:01:37,200 --> 00:01:39,360
what that means for security uh we're

46
00:01:39,360 --> 00:01:41,280
going to talk about traditional software

47
00:01:41,280 --> 00:01:43,320
composition analysis tools how they work

48
00:01:43,320 --> 00:01:45,780
uh the challenge of running an effective

49
00:01:45,780 --> 00:01:47,759
SCA program and then we're going to dive

50
00:01:47,759 --> 00:01:49,560
into like what reachability analysis is

51
00:01:49,560 --> 00:01:51,360
and how it can help folks move up a

52
00:01:51,360 --> 00:01:53,460
level in terms of their Leverage

53
00:01:53,460 --> 00:01:56,280
okay so I hope at the end of the talk we

54
00:01:56,280 --> 00:01:57,720
can get to some strategies I'm sorry not

55
00:01:57,720 --> 00:02:00,840
ignoring alerts but reducing alerts uh

56
00:02:00,840 --> 00:02:03,659
so that this can help security and

57
00:02:03,659 --> 00:02:05,880
developers be partners together

58
00:02:05,880 --> 00:02:08,280
so we'll start with the rise of Open

59
00:02:08,280 --> 00:02:09,899
Source software

60
00:02:09,899 --> 00:02:11,580
um it's a tale of like velocity but also

61
00:02:11,580 --> 00:02:15,180
risk so uh open source software usage

62
00:02:15,180 --> 00:02:17,760
has massively increased I think when I

63
00:02:17,760 --> 00:02:19,980
started uh you know it was writing

64
00:02:19,980 --> 00:02:21,780
software it was popular in common but

65
00:02:21,780 --> 00:02:23,760
today it's like the overwhelming uh

66
00:02:23,760 --> 00:02:25,260
percentage of the lines of code in our

67
00:02:25,260 --> 00:02:26,580
applications come from open source

68
00:02:26,580 --> 00:02:30,660
software this is good this means that

69
00:02:30,660 --> 00:02:32,400
open source project is happening against

70
00:02:32,400 --> 00:02:33,959
open source projects are solving

71
00:02:33,959 --> 00:02:35,540
problems that are generic to all of us

72
00:02:35,540 --> 00:02:38,160
we're a startup we don't have to figure

73
00:02:38,160 --> 00:02:40,560
out how to render HTML we don't have to

74
00:02:40,560 --> 00:02:41,640
figure out how to parse a cookie or

75
00:02:41,640 --> 00:02:43,920
spend our time doing that instead we use

76
00:02:43,920 --> 00:02:45,300
react and flask and a bunch of other

77
00:02:45,300 --> 00:02:46,739
open source projects that Implement that

78
00:02:46,739 --> 00:02:48,360
functionality really well and we get to

79
00:02:48,360 --> 00:02:50,459
move on to other things that are

80
00:02:50,459 --> 00:02:52,379
important for our business I get to

81
00:02:52,379 --> 00:02:54,180
spend more of my engineering time on

82
00:02:54,180 --> 00:02:56,340
like things that are unique to us but

83
00:02:56,340 --> 00:02:58,680
the downside is that we also inherit all

84
00:02:58,680 --> 00:03:00,120
of the security problems of the open

85
00:03:00,120 --> 00:03:01,800
source tools we bring in and we don't

86
00:03:01,800 --> 00:03:03,480
always do that like with our eyes wide

87
00:03:03,480 --> 00:03:05,700
open to those problems

88
00:03:05,700 --> 00:03:07,680
those these like old vulnerabilities

89
00:03:07,680 --> 00:03:09,959
live forever they're out there

90
00:03:09,959 --> 00:03:11,760
continuously hackers keep blasting the

91
00:03:11,760 --> 00:03:12,959
internet seeing if anyone is using

92
00:03:12,959 --> 00:03:14,580
vulnerable versions these are our logs

93
00:03:14,580 --> 00:03:16,739
from a few months ago uh catching some

94
00:03:16,739 --> 00:03:18,239
of the spam this is especially funny to

95
00:03:18,239 --> 00:03:19,620
us we don't use WordPress anywhere but

96
00:03:19,620 --> 00:03:21,060
like we still pick up people trying to

97
00:03:21,060 --> 00:03:23,819
see old WordPress versions in the wild

98
00:03:23,819 --> 00:03:25,080
um and looking at the rate of

99
00:03:25,080 --> 00:03:26,220
disclosures for open source

100
00:03:26,220 --> 00:03:27,360
vulnerabilities it just keeps on going

101
00:03:27,360 --> 00:03:29,099
up so last year I think we saw something

102
00:03:29,099 --> 00:03:31,080
like 22 000 vulnerabilities disclosed

103
00:03:31,080 --> 00:03:33,000
over the last three months we've seen 8

104
00:03:33,000 --> 00:03:34,860
000 new vulnerabilities disclosed we can

105
00:03:34,860 --> 00:03:36,599
just see this is going to increase more

106
00:03:36,599 --> 00:03:39,239
and more over time and that doesn't even

107
00:03:39,239 --> 00:03:40,860
take into account folks who are running

108
00:03:40,860 --> 00:03:42,900
microservices or projects with multiple

109
00:03:42,900 --> 00:03:45,060
lock files where a single unique

110
00:03:45,060 --> 00:03:48,299
vulnerability disclosure might compound

111
00:03:48,299 --> 00:03:50,040
and multiply out across the many

112
00:03:50,040 --> 00:03:51,480
applications you care about think about

113
00:03:51,480 --> 00:03:52,799
how many services your teams are

114
00:03:52,799 --> 00:03:54,599
supporting think about how many alerts

115
00:03:54,599 --> 00:03:56,519
you get when a disclosure happens on

116
00:03:56,519 --> 00:03:58,140
your support week a single new

117
00:03:58,140 --> 00:03:59,580
disclosure can account for tens or

118
00:03:59,580 --> 00:04:01,500
hundreds maybe sometimes thousands in

119
00:04:01,500 --> 00:04:02,700
large companies of vulnerabilities

120
00:04:02,700 --> 00:04:04,739
across a large number of projects and

121
00:04:04,739 --> 00:04:05,819
then the security team has to understand

122
00:04:05,819 --> 00:04:08,400
the context for each application in

123
00:04:08,400 --> 00:04:10,680
order to budget

124
00:04:10,680 --> 00:04:13,200
the worst part about this is that a huge

125
00:04:13,200 --> 00:04:15,420
percentage of those vulnerabilities are

126
00:04:15,420 --> 00:04:17,820
false positives we ran a study of 1100

127
00:04:17,820 --> 00:04:19,500
of the most popular open source packages

128
00:04:19,500 --> 00:04:21,180
with vulnerabilities and our analysis

129
00:04:21,180 --> 00:04:23,040
showed that about two percent of

130
00:04:23,040 --> 00:04:24,419
reported vulnerabilities are even

131
00:04:24,419 --> 00:04:26,460
theoretically reachable never mind

132
00:04:26,460 --> 00:04:28,440
exploitable we've replicated these

133
00:04:28,440 --> 00:04:29,699
results on customer code and Enterprise

134
00:04:29,699 --> 00:04:31,919
environments as well and this means that

135
00:04:31,919 --> 00:04:34,620
SCA programs are typically really low

136
00:04:34,620 --> 00:04:35,940
Roi

137
00:04:35,940 --> 00:04:38,100
so before we dive into how to fix this

138
00:04:38,100 --> 00:04:40,020
let's back up a bit and figure out how

139
00:04:40,020 --> 00:04:42,120
we ended up here in the first place

140
00:04:42,120 --> 00:04:44,759
so I want to talk about traditional SCA

141
00:04:44,759 --> 00:04:47,220
tools how do they work

142
00:04:47,220 --> 00:04:47,940
um

143
00:04:47,940 --> 00:04:49,560
there are a lot of tools that most of us

144
00:04:49,560 --> 00:04:51,180
might use for SCA there are free tools

145
00:04:51,180 --> 00:04:52,680
like oauth dependency track and

146
00:04:52,680 --> 00:04:54,479
dependabot they're paid Solutions like

147
00:04:54,479 --> 00:04:56,400
black duck and sneak but fundamentally

148
00:04:56,400 --> 00:04:57,900
these tools are pretty similar when it

149
00:04:57,900 --> 00:04:59,600
comes to vulnerability management

150
00:04:59,600 --> 00:05:02,100
first they collect a database of

151
00:05:02,100 --> 00:05:04,020
vulnerabilities these are sourced from

152
00:05:04,020 --> 00:05:06,060
public vulnerability databases like nvd

153
00:05:06,060 --> 00:05:08,000
perhaps companies have their own

154
00:05:08,000 --> 00:05:10,259
security research team investigating

155
00:05:10,259 --> 00:05:12,479
packages and finding new vulnerabilities

156
00:05:12,479 --> 00:05:14,520
but each database entry is going to look

157
00:05:14,520 --> 00:05:18,120
something like this a package uh a

158
00:05:18,120 --> 00:05:20,880
vulnerable version or version range the

159
00:05:20,880 --> 00:05:22,680
minimum patched version and then ideally

160
00:05:22,680 --> 00:05:24,360
they'll also be accompanied by helpful

161
00:05:24,360 --> 00:05:26,400
information like a description a

162
00:05:26,400 --> 00:05:29,460
recommendation a severity this is like a

163
00:05:29,460 --> 00:05:30,660
pretty good database entry helps you

164
00:05:30,660 --> 00:05:31,979
understand what's going on with this

165
00:05:31,979 --> 00:05:33,960
vulnerability

166
00:05:33,960 --> 00:05:35,820
but then they have to so then the next

167
00:05:35,820 --> 00:05:36,960
phase the next thing they have to be

168
00:05:36,960 --> 00:05:38,160
able to do is they have to be able to

169
00:05:38,160 --> 00:05:40,259
scan your dependencies perhaps they scan

170
00:05:40,259 --> 00:05:41,759
your manifest file or your lock file

171
00:05:41,759 --> 00:05:43,259
they might query your build system for

172
00:05:43,259 --> 00:05:44,520
the list but they have to be able to see

173
00:05:44,520 --> 00:05:46,380
okay what dependencies are in my system

174
00:05:46,380 --> 00:05:48,600
here we're showing a lock file giving

175
00:05:48,600 --> 00:05:51,720
you uh the list of uh dependencies in

176
00:05:51,720 --> 00:05:54,479
the system finally they have to match

177
00:05:54,479 --> 00:05:55,800
the package versions back to the

178
00:05:55,800 --> 00:05:57,780
database and then they tell you hey do

179
00:05:57,780 --> 00:05:59,220
you have a vulnerable version of a

180
00:05:59,220 --> 00:06:00,840
package in your system so at the end of

181
00:06:00,840 --> 00:06:02,340
the day you end up with a list like this

182
00:06:02,340 --> 00:06:05,220
of vulnerable packages in your ecosystem

183
00:06:05,220 --> 00:06:06,060
foreign

184
00:06:06,060 --> 00:06:09,060
so what's the issue here

185
00:06:09,060 --> 00:06:11,100
the problem is this is not a list of

186
00:06:11,100 --> 00:06:12,600
vulnerabilities that are exposed in your

187
00:06:12,600 --> 00:06:14,400
system instead it's a list of packages

188
00:06:14,400 --> 00:06:16,680
that have vulnerabilities that are in

189
00:06:16,680 --> 00:06:18,479
your system the vast majority of

190
00:06:18,479 --> 00:06:19,979
packages that might show up on this list

191
00:06:19,979 --> 00:06:22,199
are not dangerous based off how they're

192
00:06:22,199 --> 00:06:24,240
being used in that specific application

193
00:06:24,240 --> 00:06:26,340
for a package to be dangerous the first

194
00:06:26,340 --> 00:06:28,380
party code typically has to use the

195
00:06:28,380 --> 00:06:29,880
vulnerable part of the library in a

196
00:06:29,880 --> 00:06:31,740
specific way

197
00:06:31,740 --> 00:06:33,240
so let's take this low Dash

198
00:06:33,240 --> 00:06:35,100
vulnerability as an example

199
00:06:35,100 --> 00:06:37,979
what is lodash well it's a JavaScript

200
00:06:37,979 --> 00:06:40,380
utility library with uh let's see if

201
00:06:40,380 --> 00:06:41,819
this will go

202
00:06:41,819 --> 00:06:42,900
um

203
00:06:42,900 --> 00:06:46,139
no maybe I won't okay uh

204
00:06:46,139 --> 00:06:48,240
a few hundred public functions on it

205
00:06:48,240 --> 00:06:49,560
there's supposed to be a video that like

206
00:06:49,560 --> 00:06:51,419
Scrolls through a million pages of

207
00:06:51,419 --> 00:06:53,280
documentation uh it's a really large

208
00:06:53,280 --> 00:06:54,780
utility Library it has hundreds of

209
00:06:54,780 --> 00:06:56,940
functions on it this vulnerability here

210
00:06:56,940 --> 00:06:59,520
says that merge with is vulnerable to

211
00:06:59,520 --> 00:07:01,319
prototype pollution but the whole

212
00:07:01,319 --> 00:07:02,759
Library isn't vulnerable at that version

213
00:07:02,759 --> 00:07:05,280
just this function and a few more that

214
00:07:05,280 --> 00:07:07,020
also have disclosures associated with

215
00:07:07,020 --> 00:07:09,360
them like merge and merge deep if say I

216
00:07:09,360 --> 00:07:11,160
use lodash's partition method to

217
00:07:11,160 --> 00:07:13,319
manipulate an array I'm totally safe

218
00:07:13,319 --> 00:07:15,600
partition is not vulnerable does not

219
00:07:15,600 --> 00:07:17,400
rely on any of the vulnerable methods so

220
00:07:17,400 --> 00:07:18,840
there's no undue risk added to my

221
00:07:18,840 --> 00:07:20,400
application

222
00:07:20,400 --> 00:07:22,080
now looking back at this list you might

223
00:07:22,080 --> 00:07:23,759
be thinking why not just fix all of them

224
00:07:23,759 --> 00:07:25,620
anyway and if they're only five like

225
00:07:25,620 --> 00:07:27,599
absolutely that might be easy and we all

226
00:07:27,599 --> 00:07:29,099
want to live in a world where all

227
00:07:29,099 --> 00:07:30,720
vulnerabilities are fixed all the time

228
00:07:30,720 --> 00:07:33,300
and everything is rainbows and unicorns

229
00:07:33,300 --> 00:07:35,880
but many of us work at places where

230
00:07:35,880 --> 00:07:37,860
getting to inbox zero is just not

231
00:07:37,860 --> 00:07:39,960
feasible

232
00:07:39,960 --> 00:07:42,720
instead we're closer to here a huge or

233
00:07:42,720 --> 00:07:45,120
perhaps even unknown number of

234
00:07:45,120 --> 00:07:46,800
vulnerabilities to triage

235
00:07:46,800 --> 00:07:49,259
so let's talk about why is it so hard to

236
00:07:49,259 --> 00:07:51,000
get to inbox zero shouldn't we able to

237
00:07:51,000 --> 00:07:52,800
be able to just upgrade our way out of

238
00:07:52,800 --> 00:07:53,940
this mess

239
00:07:53,940 --> 00:07:56,819
well in reality upgrading is rarely

240
00:07:56,819 --> 00:07:59,160
quite that simple organizations are

241
00:07:59,160 --> 00:08:01,500
pretty rarely only one version behind

242
00:08:01,500 --> 00:08:03,720
when a vulnerability is disclosed or

243
00:08:03,720 --> 00:08:05,580
being addressed we might be dozens of

244
00:08:05,580 --> 00:08:07,259
versions behind the closest safe version

245
00:08:07,259 --> 00:08:09,780
in the best case scenario when you have

246
00:08:09,780 --> 00:08:11,699
a rock solid test Suite you still need

247
00:08:11,699 --> 00:08:13,560
the developer bandwidth to fix the

248
00:08:13,560 --> 00:08:15,599
upgrades that are breaking changes

249
00:08:15,599 --> 00:08:18,660
and in most scenarios when you don't

250
00:08:18,660 --> 00:08:20,520
have a really good test Suite you also

251
00:08:20,520 --> 00:08:21,900
have to do the manual work to figure out

252
00:08:21,900 --> 00:08:23,340
if they're breaking changes in the first

253
00:08:23,340 --> 00:08:24,240
place

254
00:08:24,240 --> 00:08:26,460
and you may need to land a fix for each

255
00:08:26,460 --> 00:08:28,020
vulnerability across a breadth of

256
00:08:28,020 --> 00:08:29,340
services at your organization which

257
00:08:29,340 --> 00:08:30,900
means you have to rinse and repeat for

258
00:08:30,900 --> 00:08:32,700
the test suite for the testing for the

259
00:08:32,700 --> 00:08:34,320
manuals testing for each of those

260
00:08:34,320 --> 00:08:36,000
applications

261
00:08:36,000 --> 00:08:38,039
and developers have a lot of different

262
00:08:38,039 --> 00:08:40,020
concerns they have to build features

263
00:08:40,020 --> 00:08:42,479
scale existing scale existing features

264
00:08:42,479 --> 00:08:45,000
pay down Tech debt fix bugs let's go

265
00:08:45,000 --> 00:08:46,920
about new work upgrades and other

266
00:08:46,920 --> 00:08:48,420
security work have to be balanced

267
00:08:48,420 --> 00:08:51,660
against all of these competing needs

268
00:08:51,660 --> 00:08:52,920
but there's a really tough trade-off

269
00:08:52,920 --> 00:08:55,620
here security teams face similar time

270
00:08:55,620 --> 00:08:57,120
constraints with asks from across the

271
00:08:57,120 --> 00:08:59,880
business prioritizing triage time takes

272
00:08:59,880 --> 00:09:01,680
away from other important work and since

273
00:09:01,680 --> 00:09:03,240
vulnerabilities keep getting disclosed

274
00:09:03,240 --> 00:09:04,920
this is a forever commitment you'll be

275
00:09:04,920 --> 00:09:07,080
forever pushing this boulder up the hill

276
00:09:07,080 --> 00:09:09,240
so security teams are often faced with

277
00:09:09,240 --> 00:09:11,640
an extremely difficult Choice balancing

278
00:09:11,640 --> 00:09:14,519
the value against the resources required

279
00:09:14,519 --> 00:09:16,380
for an SCA program in a resource

280
00:09:16,380 --> 00:09:18,240
constrained environment so for some

281
00:09:18,240 --> 00:09:20,040
companies for some organizations running

282
00:09:20,040 --> 00:09:22,140
a security focused sea program just

283
00:09:22,140 --> 00:09:25,140
isn't worth it it's too much work for

284
00:09:25,140 --> 00:09:27,000
too little reward and instead the goal

285
00:09:27,000 --> 00:09:28,560
becomes meeting the minimum bar for

286
00:09:28,560 --> 00:09:30,600
compliance folks might turn on a tool

287
00:09:30,600 --> 00:09:33,060
that can check the compliance box and

288
00:09:33,060 --> 00:09:34,560
ignore the rest of the results and

289
00:09:34,560 --> 00:09:35,820
accept the risk

290
00:09:35,820 --> 00:09:38,339
for others they cannot accept the risk

291
00:09:38,339 --> 00:09:39,600
the needle in the haystack is too

292
00:09:39,600 --> 00:09:41,519
dangerous and so folks commit to

293
00:09:41,519 --> 00:09:43,560
manually triaging these alerts so they

294
00:09:43,560 --> 00:09:45,480
can find the few real vulnerabilities to

295
00:09:45,480 --> 00:09:47,519
forward to the development teams and

296
00:09:47,519 --> 00:09:49,580
this is a really terrible trade-off

297
00:09:49,580 --> 00:09:53,339
okay so the the Crux of the talk here is

298
00:09:53,339 --> 00:09:54,839
that reachability analysis helps you

299
00:09:54,839 --> 00:09:56,880
escape from that choice and move a lever

300
00:09:56,880 --> 00:09:59,580
uh move a level up uh and work on higher

301
00:09:59,580 --> 00:10:01,920
leverage work here

302
00:10:01,920 --> 00:10:03,480
um so reachability analysis helps

303
00:10:03,480 --> 00:10:05,220
security teams run a more scalable and

304
00:10:05,220 --> 00:10:07,920
pragmatic SCA program it lets us ignore

305
00:10:07,920 --> 00:10:09,959
or de-prioritize less urgent

306
00:10:09,959 --> 00:10:12,240
vulnerabilities in the ever-growing uh

307
00:10:12,240 --> 00:10:14,040
like background tasks a queue of

308
00:10:14,040 --> 00:10:15,959
background tasks it also lets us find

309
00:10:15,959 --> 00:10:17,700
and immediately address the

310
00:10:17,700 --> 00:10:18,660
vulnerabilities that are the most

311
00:10:18,660 --> 00:10:20,820
pressing today so we can be strategic

312
00:10:20,820 --> 00:10:22,980
with our triage time and then it also

313
00:10:22,980 --> 00:10:24,660
lets us codify acceptable and

314
00:10:24,660 --> 00:10:26,880
unacceptable uses of packages with known

315
00:10:26,880 --> 00:10:29,160
vulnerabilities so developers can fix

316
00:10:29,160 --> 00:10:31,320
and self-serve uh to prevent real

317
00:10:31,320 --> 00:10:33,180
security issues uh without having to

318
00:10:33,180 --> 00:10:34,620
spend a lot of time on upgrades that

319
00:10:34,620 --> 00:10:36,420
aren't useful today

320
00:10:36,420 --> 00:10:38,640
okay so what is reachability analysis

321
00:10:38,640 --> 00:10:41,040
how does it work let's dive in

322
00:10:41,040 --> 00:10:43,019
um reachability analysis is a process by

323
00:10:43,019 --> 00:10:44,880
which we check to see if the vulnerable

324
00:10:44,880 --> 00:10:47,220
part of the library is used we call it

325
00:10:47,220 --> 00:10:49,019
reachable when the dangerous part of a

326
00:10:49,019 --> 00:10:50,940
vulnerable package is used by the first

327
00:10:50,940 --> 00:10:54,180
party code so let's go over an example

328
00:10:54,180 --> 00:10:56,459
here we import low Dash and let's say

329
00:10:56,459 --> 00:10:58,920
it's at a vulnerable version

330
00:10:58,920 --> 00:11:01,019
on line five here we see evidence of

331
00:11:01,019 --> 00:11:02,459
reachability we see the program has

332
00:11:02,459 --> 00:11:04,079
called the dangerous function on the

333
00:11:04,079 --> 00:11:07,200
library with potentially untrusted user

334
00:11:07,200 --> 00:11:09,360
input and then on line eight we see how

335
00:11:09,360 --> 00:11:11,040
a user might be able to get a malicious

336
00:11:11,040 --> 00:11:13,740
input into the vulnerable function

337
00:11:13,740 --> 00:11:16,019
here we see a very similar function same

338
00:11:16,019 --> 00:11:18,300
user input same library but we're

339
00:11:18,300 --> 00:11:19,620
calling the zip function which we know

340
00:11:19,620 --> 00:11:21,360
not to be vulnerable we know it doesn't

341
00:11:21,360 --> 00:11:22,500
utilize any of the vulnerable

342
00:11:22,500 --> 00:11:24,720
functionality in low Dash thus we'd call

343
00:11:24,720 --> 00:11:25,980
the vulnerability in this context

344
00:11:25,980 --> 00:11:27,860
unreachable

345
00:11:27,860 --> 00:11:30,180
I want to make an important distinction

346
00:11:30,180 --> 00:11:32,820
this is different from exploitability a

347
00:11:32,820 --> 00:11:34,440
vulnerability might be reachable but

348
00:11:34,440 --> 00:11:36,660
still not exploitable exploitability

349
00:11:36,660 --> 00:11:38,399
requires a lot more context the

350
00:11:38,399 --> 00:11:40,200
environment the infrastructure you have

351
00:11:40,200 --> 00:11:42,180
to know how the software is really being

352
00:11:42,180 --> 00:11:44,459
used in practice and it's a much higher

353
00:11:44,459 --> 00:11:46,380
bar much more difficult to also to

354
00:11:46,380 --> 00:11:48,120
automate this detection

355
00:11:48,120 --> 00:11:49,740
but so if we go back to our previous

356
00:11:49,740 --> 00:11:52,500
example from this code sample we can't

357
00:11:52,500 --> 00:11:55,140
tell if this script is exploitable

358
00:11:55,140 --> 00:11:57,060
reachability analysis is this lower bar

359
00:11:57,060 --> 00:11:59,100
basically does the code touch the

360
00:11:59,100 --> 00:12:00,779
vulnerable part of the library and it

361
00:12:00,779 --> 00:12:02,519
has nice property that it's much easier

362
00:12:02,519 --> 00:12:03,540
to automate the detection of

363
00:12:03,540 --> 00:12:05,600
reachability

364
00:12:05,600 --> 00:12:08,760
okay so how do you do reachability

365
00:12:08,760 --> 00:12:11,519
analysis this has three parts the first

366
00:12:11,519 --> 00:12:13,920
part is an engine of some kind that can

367
00:12:13,920 --> 00:12:16,380
scan the code and detect well like some

368
00:12:16,380 --> 00:12:18,360
pattern uh so a nice property of

369
00:12:18,360 --> 00:12:19,860
reachability analysis is this this can

370
00:12:19,860 --> 00:12:21,660
be done with static analysis we don't

371
00:12:21,660 --> 00:12:23,459
need to compile the code or test it

372
00:12:23,459 --> 00:12:24,779
dynamically

373
00:12:24,779 --> 00:12:26,519
um at some grip we've built and

374
00:12:26,519 --> 00:12:27,660
maintained the open source static

375
00:12:27,660 --> 00:12:29,100
analysis tool semcraft we just changed

376
00:12:29,100 --> 00:12:30,180
our name I don't really know how to say

377
00:12:30,180 --> 00:12:33,000
at sem grip we build sem grip uh this

378
00:12:33,000 --> 00:12:34,620
works really well for analysis like this

379
00:12:34,620 --> 00:12:36,959
and I'll show some examples uh in a bit

380
00:12:36,959 --> 00:12:38,880
on the lightweight side you can use

381
00:12:38,880 --> 00:12:40,920
something as simple as grep you might

382
00:12:40,920 --> 00:12:42,420
use a language specific linter like

383
00:12:42,420 --> 00:12:44,880
RoboCop or eslint if you have access to

384
00:12:44,880 --> 00:12:46,380
something like code ql you might be able

385
00:12:46,380 --> 00:12:48,660
to wire up something like this too

386
00:12:48,660 --> 00:12:51,120
um second you need an engine that can

387
00:12:51,120 --> 00:12:52,860
tell what version of the library is

388
00:12:52,860 --> 00:12:54,660
being used in an application there are a

389
00:12:54,660 --> 00:12:56,579
lot of great free tools like this Sam

390
00:12:56,579 --> 00:12:58,260
grip does this but oauth dependency

391
00:12:58,260 --> 00:12:59,519
track does this dependabot does this

392
00:12:59,519 --> 00:13:01,920
there's a lot of good tools for this

393
00:13:01,920 --> 00:13:03,959
um and finally you need a database of

394
00:13:03,959 --> 00:13:05,760
vulnerabilities and you need to know the

395
00:13:05,760 --> 00:13:07,560
list of vulnerable functions for a

396
00:13:07,560 --> 00:13:09,300
library at a particular version and

397
00:13:09,300 --> 00:13:10,800
under what conditions those functions

398
00:13:10,800 --> 00:13:13,139
are dangerous now here there is no

399
00:13:13,139 --> 00:13:15,660
Silver Bullet this is going to require a

400
00:13:15,660 --> 00:13:17,040
little bit of work a decent amount of

401
00:13:17,040 --> 00:13:18,240
security knowledge

402
00:13:18,240 --> 00:13:21,300
some elbow grease but essentially you

403
00:13:21,300 --> 00:13:22,860
flip the switch on triaging of

404
00:13:22,860 --> 00:13:24,540
vulnerability it means rather than

405
00:13:24,540 --> 00:13:26,700
digging into your own code to see how

406
00:13:26,700 --> 00:13:28,800
you use the library it means digging

407
00:13:28,800 --> 00:13:30,660
into the vulnerable library and looking

408
00:13:30,660 --> 00:13:32,399
at the patch diff reading blog posts on

409
00:13:32,399 --> 00:13:33,959
successful exploits stuff like that in

410
00:13:33,959 --> 00:13:35,820
order to figure out what makes this

411
00:13:35,820 --> 00:13:37,260
Library dangerous at this particular

412
00:13:37,260 --> 00:13:38,459
version

413
00:13:38,459 --> 00:13:41,459
so uh right so we've also found that

414
00:13:41,459 --> 00:13:42,899
there are some open source databases

415
00:13:42,899 --> 00:13:44,279
that are beginning to have some of these

416
00:13:44,279 --> 00:13:45,839
lists of vulnerable functions there's an

417
00:13:45,839 --> 00:13:46,800
effort in the open source community

418
00:13:46,800 --> 00:13:48,899
Through tools like osv to try to provide

419
00:13:48,899 --> 00:13:50,579
that information more readily we're

420
00:13:50,579 --> 00:13:52,019
trying to get involved with these uh

421
00:13:52,019 --> 00:13:53,940
resources as well

422
00:13:53,940 --> 00:13:54,600
um

423
00:13:54,600 --> 00:13:56,339
I want to give a couple uh I'll give an

424
00:13:56,339 --> 00:13:57,540
example of like how this works in

425
00:13:57,540 --> 00:13:58,560
practice

426
00:13:58,560 --> 00:14:01,320
um so uh towards the end of 2022 we saw

427
00:14:01,320 --> 00:14:03,959
a disclosure in the pytorch library

428
00:14:03,959 --> 00:14:06,000
um looking at the issue on the library

429
00:14:06,000 --> 00:14:07,740
itself it doesn't take very long to

430
00:14:07,740 --> 00:14:09,000
figure out what's dangerous about the

431
00:14:09,000 --> 00:14:10,740
library someone even did a great job of

432
00:14:10,740 --> 00:14:12,060
demonstrating the exploit in the

433
00:14:12,060 --> 00:14:14,399
comments on the issue so you can see

434
00:14:14,399 --> 00:14:15,839
exactly the function that needs to be

435
00:14:15,839 --> 00:14:17,940
called for it to be dangerous and what

436
00:14:17,940 --> 00:14:20,399
that looks like in the wild so then the

437
00:14:20,399 --> 00:14:23,480
next step is actually writing a rule so

438
00:14:23,480 --> 00:14:26,399
you look at the engine you specify that

439
00:14:26,399 --> 00:14:27,959
okay this is a pie torch this is for

440
00:14:27,959 --> 00:14:29,700
python you write a message that helps a

441
00:14:29,700 --> 00:14:31,500
developer perhaps understand why they

442
00:14:31,500 --> 00:14:33,240
need to fix this and then you specify

443
00:14:33,240 --> 00:14:35,700
the pattern so here we specify the you

444
00:14:35,700 --> 00:14:36,720
know pattern here's what needs to be

445
00:14:36,720 --> 00:14:39,600
called uh for this uh vulnerability to

446
00:14:39,600 --> 00:14:42,240
be dangerous then the second part is the

447
00:14:42,240 --> 00:14:43,440
engine for matching the dependency

448
00:14:43,440 --> 00:14:46,320
version we can run this rule against a

449
00:14:46,320 --> 00:14:48,540
code base see if it's used at all and

450
00:14:48,540 --> 00:14:49,920
then to see whether or not it's

451
00:14:49,920 --> 00:14:51,839
reachable or unreachable so here we

452
00:14:51,839 --> 00:14:54,540
specify are you using the library at the

453
00:14:54,540 --> 00:14:56,579
known dangerous versions

454
00:14:56,579 --> 00:14:58,740
now that we have some rules

455
00:14:58,740 --> 00:15:00,959
um we can talk about how we build

456
00:15:00,959 --> 00:15:03,240
reachability into our SCA program at all

457
00:15:03,240 --> 00:15:05,940
so let's zoom out for a second think

458
00:15:05,940 --> 00:15:07,980
about how vulnerabilities might show up

459
00:15:07,980 --> 00:15:09,300
in our systems

460
00:15:09,300 --> 00:15:11,040
there are two main vectors of

461
00:15:11,040 --> 00:15:12,660
vulnerability risk one is new

462
00:15:12,660 --> 00:15:15,240
disclosures and the other is new commits

463
00:15:15,240 --> 00:15:17,399
so the first a new disclosure new

464
00:15:17,399 --> 00:15:19,079
disclosure is going to impact old code

465
00:15:19,079 --> 00:15:20,399
code that hasn't been touched in years

466
00:15:20,399 --> 00:15:22,440
code that you really thought was safe

467
00:15:22,440 --> 00:15:24,480
but now it turns out that that nokigiri

468
00:15:24,480 --> 00:15:26,220
XML parser that you thought was safe

469
00:15:26,220 --> 00:15:28,320
wasn't safe after all we need to either

470
00:15:28,320 --> 00:15:30,360
spend some time sanitizing the input or

471
00:15:30,360 --> 00:15:32,639
we need to upgrade so how do we prevent

472
00:15:32,639 --> 00:15:33,839
how do we like protect ourselves against

473
00:15:33,839 --> 00:15:35,639
these kinds of disclosures

474
00:15:35,639 --> 00:15:38,220
here we to do reachability analysis you

475
00:15:38,220 --> 00:15:39,720
want to be able to run scans basically

476
00:15:39,720 --> 00:15:42,779
ad hoc at request time you might build a

477
00:15:42,779 --> 00:15:44,459
script that pulls your repos and scans

478
00:15:44,459 --> 00:15:46,440
the whole repo with this new rule when

479
00:15:46,440 --> 00:15:47,820
you have once you've written it for this

480
00:15:47,820 --> 00:15:50,519
disclosure if you use a standard static

481
00:15:50,519 --> 00:15:52,560
analysis tool these scans are going to

482
00:15:52,560 --> 00:15:54,480
be dominated by how long it takes to

483
00:15:54,480 --> 00:15:55,860
pull the code rather than running the

484
00:15:55,860 --> 00:15:58,139
scan itself typically so a lot of folks

485
00:15:58,139 --> 00:16:00,300
have uh worked on like kind of nightly

486
00:16:00,300 --> 00:16:02,760
or hourly chrons pre-scheduled in CI

487
00:16:02,760 --> 00:16:04,380
that when you check in your rule it's

488
00:16:04,380 --> 00:16:05,639
going to automatically get a scan in

489
00:16:05,639 --> 00:16:07,260
your next run and then you'll be able to

490
00:16:07,260 --> 00:16:09,839
get a result pretty quickly

491
00:16:09,839 --> 00:16:12,480
um the second Vector is new or changed

492
00:16:12,480 --> 00:16:14,459
code so once you've scanned or confirmed

493
00:16:14,459 --> 00:16:16,920
at the time sorry so right so when

494
00:16:16,920 --> 00:16:18,839
someone's checked in some code

495
00:16:18,839 --> 00:16:20,820
um or sorry when a new disclosure comes

496
00:16:20,820 --> 00:16:22,139
out you've scanned you've confirmed at

497
00:16:22,139 --> 00:16:23,519
the time of the disclosure the

498
00:16:23,519 --> 00:16:24,959
vulnerability doesn't exist in your code

499
00:16:24,959 --> 00:16:26,040
base

500
00:16:26,040 --> 00:16:28,079
um but people don't stop changing their

501
00:16:28,079 --> 00:16:30,180
code people keep adding new code they

502
00:16:30,180 --> 00:16:31,680
keep on making changes to existing code

503
00:16:31,680 --> 00:16:33,600
and someone checks in maybe a new

504
00:16:33,600 --> 00:16:36,360
library or makes a use of a library in a

505
00:16:36,360 --> 00:16:37,380
new way and all of a sudden that

506
00:16:37,380 --> 00:16:38,759
library's vulnerability is reachable

507
00:16:38,759 --> 00:16:40,440
what we want to do is we want to put a

508
00:16:40,440 --> 00:16:42,180
guardrail in place to prevent developers

509
00:16:42,180 --> 00:16:43,800
from introducing new reachable

510
00:16:43,800 --> 00:16:46,320
vulnerabilities so to do these folks

511
00:16:46,320 --> 00:16:48,300
typically instrument PR scans to make

512
00:16:48,300 --> 00:16:50,040
sure that code changes don't let in

513
00:16:50,040 --> 00:16:52,139
newly reachable vulnerabilities this is

514
00:16:52,139 --> 00:16:54,300
ideal it lets developers self-serve or

515
00:16:54,300 --> 00:16:56,040
fix especially if you can add a comment

516
00:16:56,040 --> 00:16:58,560
when it fails a PR check and you can

517
00:16:58,560 --> 00:16:59,519
make it blocking to ensure

518
00:16:59,519 --> 00:17:00,660
vulnerabilities never make it to

519
00:17:00,660 --> 00:17:02,880
production for some orgs that like PR

520
00:17:02,880 --> 00:17:04,319
comments are blocking is it quite

521
00:17:04,319 --> 00:17:06,419
feasible you can orchestrate this also

522
00:17:06,419 --> 00:17:08,040
with out of band scans that allow

523
00:17:08,040 --> 00:17:09,959
security teams to fast follow with fixes

524
00:17:09,959 --> 00:17:13,740
without slowing down Developers

525
00:17:13,740 --> 00:17:16,020
um cool so running a reachability

526
00:17:16,020 --> 00:17:17,819
program kind of in action here's what it

527
00:17:17,819 --> 00:17:19,919
looks like you hook up a feed uh to some

528
00:17:19,919 --> 00:17:21,480
vulnerability database so you get

529
00:17:21,480 --> 00:17:23,099
notified when new vulnerabilities are

530
00:17:23,099 --> 00:17:24,660
disclosed I think a lot of folks have

531
00:17:24,660 --> 00:17:25,980
something like this already in place

532
00:17:25,980 --> 00:17:28,740
with something like uh dependabot or uh

533
00:17:28,740 --> 00:17:30,419
vulnerability tracker

534
00:17:30,419 --> 00:17:32,100
um one of when a vulnerability comes

535
00:17:32,100 --> 00:17:33,480
through then rather than jumping into

536
00:17:33,480 --> 00:17:35,340
your code to triage you dig into the

537
00:17:35,340 --> 00:17:37,380
vulnerability itself if there's a single

538
00:17:37,380 --> 00:17:39,120
function that's vulnerable or particular

539
00:17:39,120 --> 00:17:40,559
kinds of inputs that make it vulnerable

540
00:17:40,559 --> 00:17:42,480
you then write a rule

541
00:17:42,480 --> 00:17:44,580
um to codify like what is acceptable

542
00:17:44,580 --> 00:17:46,679
usage what is not you scan your existing

543
00:17:46,679 --> 00:17:48,419
code base to excise parts that might be

544
00:17:48,419 --> 00:17:50,160
vulnerable today and then you check into

545
00:17:50,160 --> 00:17:52,080
guardrail to make sure the vulnerability

546
00:17:52,080 --> 00:17:53,960
doesn't become reachable in the future

547
00:17:53,960 --> 00:17:57,600
okay so reachability uh lets folks scale

548
00:17:57,600 --> 00:18:00,000
and run a more effective pragmatic SCA

549
00:18:00,000 --> 00:18:02,580
program but I think this and this allows

550
00:18:02,580 --> 00:18:03,840
your security team really to level up

551
00:18:03,840 --> 00:18:06,120
and work on at a higher leverage uh

552
00:18:06,120 --> 00:18:08,640
point of view takes you from manual toil

553
00:18:08,640 --> 00:18:10,320
to allowing you to automate away your

554
00:18:10,320 --> 00:18:12,059
current and future work but I think I

555
00:18:12,059 --> 00:18:13,980
want to say is by no means bulletproof

556
00:18:13,980 --> 00:18:16,140
static analysis is imperfect there are

557
00:18:16,140 --> 00:18:17,700
false positives and false negatives as

558
00:18:17,700 --> 00:18:20,400
with any analysis technique but our goal

559
00:18:20,400 --> 00:18:22,400
here is to run something pragmatic

560
00:18:22,400 --> 00:18:24,299
there are some volts that are

561
00:18:24,299 --> 00:18:25,620
vulnerabilities that are so bad you want

562
00:18:25,620 --> 00:18:27,240
to excise them no matter what so you

563
00:18:27,240 --> 00:18:28,679
know log4j things like that you just

564
00:18:28,679 --> 00:18:29,880
want to get out of your system you might

565
00:18:29,880 --> 00:18:32,100
not trust reachability analysis for I

566
00:18:32,100 --> 00:18:33,059
think it's also important to remember

567
00:18:33,059 --> 00:18:34,559
there's not a trivial amount of work

568
00:18:34,559 --> 00:18:36,539
researching and writing your own rules

569
00:18:36,539 --> 00:18:39,360
for each ability program but especially

570
00:18:39,360 --> 00:18:41,100
for orgs with multiple services and

571
00:18:41,100 --> 00:18:42,780
multiple applications this lets you

572
00:18:42,780 --> 00:18:45,000
scale a single research effort rather

573
00:18:45,000 --> 00:18:46,799
than having to manually triage each

574
00:18:46,799 --> 00:18:49,740
vulnerability by hand I think if you

575
00:18:49,740 --> 00:18:50,700
don't want to run this program yourself

576
00:18:50,700 --> 00:18:51,960
there are products out there that do

577
00:18:51,960 --> 00:18:53,700
this same graph has a product that does

578
00:18:53,700 --> 00:18:54,780
this but there are a variety of other

579
00:18:54,780 --> 00:18:57,000
SCA tools that do this as well and we

580
00:18:57,000 --> 00:18:58,200
kind of want to push to make this the de

581
00:18:58,200 --> 00:19:01,320
facto uh standard that reach SCA tools

582
00:19:01,320 --> 00:19:03,059
should have reachability but it's

583
00:19:03,059 --> 00:19:04,679
something every org has to evaluate for

584
00:19:04,679 --> 00:19:05,760
themselves whether they want to build it

585
00:19:05,760 --> 00:19:08,940
or buy it but I think the key part is

586
00:19:08,940 --> 00:19:11,160
security here isn't a purity test if we

587
00:19:11,160 --> 00:19:13,200
can only have security in a world in

588
00:19:13,200 --> 00:19:14,580
which every vulnerability is upgraded

589
00:19:14,580 --> 00:19:16,500
we're on inbox zero it's going to be

590
00:19:16,500 --> 00:19:18,000
hard for a lot of organizations we

591
00:19:18,000 --> 00:19:20,039
believe in pragmatic security pragmatic

592
00:19:20,039 --> 00:19:21,600
security should not require so much toil

593
00:19:21,600 --> 00:19:24,120
thanks for having me uh come join our

594
00:19:24,120 --> 00:19:25,320
community slack at sem group we're also

595
00:19:25,320 --> 00:19:27,299
hiring quite a bit so I would love to

596
00:19:27,299 --> 00:19:29,100
chat with you all if you're interested

597
00:19:29,100 --> 00:19:32,059
thanks so much

598
00:19:32,760 --> 00:19:35,890
[Applause]

599
00:19:36,780 --> 00:19:39,080
foreign

600
00:19:49,220 --> 00:19:51,720
yeah so the question is why like why

601
00:19:51,720 --> 00:19:52,860
capture reachability early if

602
00:19:52,860 --> 00:19:54,539
reachability doesn't mean exploitable I

603
00:19:54,539 --> 00:19:57,260
think the the idea is that the number of

604
00:19:57,260 --> 00:19:59,640
exploitable vulnerabilities is a subset

605
00:19:59,640 --> 00:20:01,080
of the reachable vulnerabilities but

606
00:20:01,080 --> 00:20:04,080
that reachability already filters out a

607
00:20:04,080 --> 00:20:06,179
ton of vulnerabilities that you that

608
00:20:06,179 --> 00:20:07,380
aren't exploitable and that you don't

609
00:20:07,380 --> 00:20:08,340
have to look at because they're not

610
00:20:08,340 --> 00:20:09,900
reachable either so if you start with a

611
00:20:09,900 --> 00:20:11,580
list of a thousand vulnerabilities if we

612
00:20:11,580 --> 00:20:13,440
can get you down to the 10 that are

613
00:20:13,440 --> 00:20:15,120
reachable and then help you find the

614
00:20:15,120 --> 00:20:16,980
five within that that are exploitable it

615
00:20:16,980 --> 00:20:18,240
really cuts down the amount of triage

616
00:20:18,240 --> 00:20:19,500
times you still there is still some

617
00:20:19,500 --> 00:20:20,940
triage to do figure out which of those

618
00:20:20,940 --> 00:20:23,760
are are uh exploitable but it helps you

619
00:20:23,760 --> 00:20:26,760
kind of get past the other 990 that

620
00:20:26,760 --> 00:20:30,799
aren't exploitable or or reachable

621
00:20:31,679 --> 00:20:34,160
sure

622
00:20:39,600 --> 00:20:42,299
um a lot of the dependency alerts that

623
00:20:42,299 --> 00:20:44,880
I've seen can be a dependency of a

624
00:20:44,880 --> 00:20:47,220
dependency of a dependency yeah

625
00:20:47,220 --> 00:20:51,179
um the scanning bins that you can the

626
00:20:51,179 --> 00:20:53,900
coding engine

627
00:20:55,580 --> 00:20:58,939
Mike swap

628
00:20:59,820 --> 00:21:01,440
um Can the code scanning engines that

629
00:21:01,440 --> 00:21:04,559
you highlighted trace the call stack to

630
00:21:04,559 --> 00:21:07,220
understand like reachability even when

631
00:21:07,220 --> 00:21:11,220
the uh function is used very deep within

632
00:21:11,220 --> 00:21:13,200
the stack yeah not all of them can some

633
00:21:13,200 --> 00:21:14,280
of those there are some that can there

634
00:21:14,280 --> 00:21:15,480
are some that cannot

635
00:21:15,480 --> 00:21:17,400
um what we've also found there's like a

636
00:21:17,400 --> 00:21:18,960
multiplication Factor here where it's

637
00:21:18,960 --> 00:21:20,220
like okay if two percent of

638
00:21:20,220 --> 00:21:22,200
vulnerabilities are reachable in direct

639
00:21:22,200 --> 00:21:24,840
dependencies then two percent of the

640
00:21:24,840 --> 00:21:26,400
vulnerabilities in those dependencies

641
00:21:26,400 --> 00:21:29,039
are reachable we're at 0.04 percent so

642
00:21:29,039 --> 00:21:30,500
because it starts to become like

643
00:21:30,500 --> 00:21:33,360
incredibly difficult and a very tailored

644
00:21:33,360 --> 00:21:35,100
attack that I have to get through so in

645
00:21:35,100 --> 00:21:36,840
terms of risk management it's often not

646
00:21:36,840 --> 00:21:38,820
like the top thing that you'd have to

647
00:21:38,820 --> 00:21:40,320
worry about but I think the like for the

648
00:21:40,320 --> 00:21:41,400
truth of the matter is like a lot of

649
00:21:41,400 --> 00:21:43,080
them cannot and it's like you know you

650
00:21:43,080 --> 00:21:45,240
can't grep your way through but or maybe

651
00:21:45,240 --> 00:21:46,559
you can but then like that'd be

652
00:21:46,559 --> 00:21:47,640
something you have to wire up as you

653
00:21:47,640 --> 00:21:49,679
have to grip your way through a call

654
00:21:49,679 --> 00:21:50,640
stack

655
00:21:50,640 --> 00:21:53,179
thanks

656
00:21:55,020 --> 00:21:57,960
folks

657
00:21:57,960 --> 00:22:00,840
due to time constraints

658
00:22:00,840 --> 00:22:02,280
due to time constraints folks we

659
00:22:02,280 --> 00:22:03,720
probably need to just take the questions

660
00:22:03,720 --> 00:22:06,299
outside I got freestyle question Cipher

661
00:22:06,299 --> 00:22:08,159
with Adam okay yep I'll be out in the

662
00:22:08,159 --> 00:22:09,600
hallway for anyone or maybe I shouldn't

663
00:22:09,600 --> 00:22:10,679
be in the hallway I'm not sure if you

664
00:22:10,679 --> 00:22:12,720
want me in the hallway I'll be I'll be

665
00:22:12,720 --> 00:22:14,400
yeah by the concessions area if people

666
00:22:14,400 --> 00:22:16,039
have questions

667
00:22:16,039 --> 00:22:19,340
thanks folks

