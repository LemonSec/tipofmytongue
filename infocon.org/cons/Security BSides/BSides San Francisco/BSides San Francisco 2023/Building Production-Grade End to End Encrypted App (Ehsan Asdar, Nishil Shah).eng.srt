1
00:00:00,000 --> 00:00:01,860
hi everyone thanks for joining us I'm

2
00:00:01,860 --> 00:00:04,259
excited to announce our first speakers a

3
00:00:04,259 --> 00:00:06,420
song initial with their talk building

4
00:00:06,420 --> 00:00:08,460
production grade end-to-end encrypted

5
00:00:08,460 --> 00:00:11,000
applications

6
00:00:15,059 --> 00:00:17,760
yeah hi everyone thank you so much for

7
00:00:17,760 --> 00:00:20,699
coming uh we're built like like she said

8
00:00:20,699 --> 00:00:22,619
uh our talk is called building

9
00:00:22,619 --> 00:00:24,240
production grade n10 encrypted

10
00:00:24,240 --> 00:00:27,680
applications I'm Esson this is initial

11
00:00:27,680 --> 00:00:31,740
so I'm a senior engineer at skiff

12
00:00:31,740 --> 00:00:34,079
initial is the director of security for

13
00:00:34,079 --> 00:00:35,520
skiff

14
00:00:35,520 --> 00:00:37,860
just to give a brief background about

15
00:00:37,860 --> 00:00:40,079
what skiff is we're not going to talk

16
00:00:40,079 --> 00:00:41,340
too much about skiff during the

17
00:00:41,340 --> 00:00:43,079
presentation but we want to give a bit

18
00:00:43,079 --> 00:00:44,820
of a motivation for why we're speaking

19
00:00:44,820 --> 00:00:47,100
about this skiff is a privacy first

20
00:00:47,100 --> 00:00:49,500
workspace we say for the next generation

21
00:00:49,500 --> 00:00:51,239
of the internet with end-to-end

22
00:00:51,239 --> 00:00:53,520
encryption built in by default so what

23
00:00:53,520 --> 00:00:55,260
this looks like is we have a suite of

24
00:00:55,260 --> 00:00:57,480
products for workspace collaboration

25
00:00:57,480 --> 00:00:59,520
skiff mail which is an end-to-end

26
00:00:59,520 --> 00:01:02,340
encrypted email platform skip Pages for

27
00:01:02,340 --> 00:01:04,280
document collaboration real time

28
00:01:04,280 --> 00:01:07,680
calendar and then drive which is intend

29
00:01:07,680 --> 00:01:10,200
encrypted file storage and so you can

30
00:01:10,200 --> 00:01:11,939
imagine a lot of teams and businesses

31
00:01:11,939 --> 00:01:14,400
and individuals use skiff to sort of

32
00:01:14,400 --> 00:01:16,380
work on their most sensitive research or

33
00:01:16,380 --> 00:01:17,760
projects

34
00:01:17,760 --> 00:01:20,640
I lead the development of skiff mail and

35
00:01:20,640 --> 00:01:23,040
skiff calendar and initials director of

36
00:01:23,040 --> 00:01:26,840
security across the entire product Suite

37
00:01:27,000 --> 00:01:28,560
to start we'll talk a little bit about

38
00:01:28,560 --> 00:01:30,840
nt10 encrypted applications and how they

39
00:01:30,840 --> 00:01:33,720
differ from traditional applications

40
00:01:33,720 --> 00:01:36,119
so in a traditional application let's

41
00:01:36,119 --> 00:01:38,040
take the example of like a traditional

42
00:01:38,040 --> 00:01:40,920
email service provider your email that

43
00:01:40,920 --> 00:01:43,560
you send let's say to another friend is

44
00:01:43,560 --> 00:01:45,659
going to be in plain text or can be

45
00:01:45,659 --> 00:01:47,820
decrypted by the server that is

46
00:01:47,820 --> 00:01:50,399
providing the service so in a sense we

47
00:01:50,399 --> 00:01:51,780
can say that the server this email

48
00:01:51,780 --> 00:01:54,000
service provider holds the keys to your

49
00:01:54,000 --> 00:01:56,399
email and if the server is compromised

50
00:01:56,399 --> 00:01:58,560
it's potentially possible for the

51
00:01:58,560 --> 00:02:01,079
contents of your email to be leaked

52
00:02:01,079 --> 00:02:03,060
in an end-to-end encrypted application

53
00:02:03,060 --> 00:02:05,700
data is encrypted everywhere and can

54
00:02:05,700 --> 00:02:07,799
only be decrypted by the user sending

55
00:02:07,799 --> 00:02:10,199
the email and the friend or the user

56
00:02:10,199 --> 00:02:12,720
receiving the email so in a sense the

57
00:02:12,720 --> 00:02:15,540
user holds the keys to their email and

58
00:02:15,540 --> 00:02:18,300
on our service all we see is a cipher

59
00:02:18,300 --> 00:02:20,760
text sort of encrypted meaningless

60
00:02:20,760 --> 00:02:22,739
string of letters and numbers that

61
00:02:22,739 --> 00:02:24,599
cannot be reversed into the actual email

62
00:02:24,599 --> 00:02:27,120
content so if the server is compromised

63
00:02:27,120 --> 00:02:29,400
only that Cipher text is leaked

64
00:02:29,400 --> 00:02:32,459
so overall like their end-to-end

65
00:02:32,459 --> 00:02:34,140
encryption seems really cool right like

66
00:02:34,140 --> 00:02:36,239
it has all these privacy advantages so

67
00:02:36,239 --> 00:02:38,879
why isn't every app intent encrypted

68
00:02:38,879 --> 00:02:41,280
um and one answer for that is that it

69
00:02:41,280 --> 00:02:43,200
makes a lot of feature development and a

70
00:02:43,200 --> 00:02:44,819
lot of things you would do to build a

71
00:02:44,819 --> 00:02:46,739
really nice compelling easy to use

72
00:02:46,739 --> 00:02:49,260
product a lot harder

73
00:02:49,260 --> 00:02:51,720
and why is it harder it's it's because

74
00:02:51,720 --> 00:02:53,940
of this property we just talked about

75
00:02:53,940 --> 00:02:55,800
which is that our service doesn't have

76
00:02:55,800 --> 00:02:58,379
the keys to the user's information so a

77
00:02:58,379 --> 00:03:00,239
lot of different activities that would

78
00:03:00,239 --> 00:03:02,160
normally be pretty simple become much

79
00:03:02,160 --> 00:03:04,260
more complex because of this let's take

80
00:03:04,260 --> 00:03:06,060
account recovery right like let's say a

81
00:03:06,060 --> 00:03:08,940
user forgets their password when um and

82
00:03:08,940 --> 00:03:11,159
is trying to log into their account and

83
00:03:11,159 --> 00:03:13,319
a normal traditional application you may

84
00:03:13,319 --> 00:03:14,700
just need to verify their identity

85
00:03:14,700 --> 00:03:16,739
verify their email address in some way

86
00:03:16,739 --> 00:03:18,000
and then you can just reset their

87
00:03:18,000 --> 00:03:19,260
password and give them access to the

88
00:03:19,260 --> 00:03:21,980
account but an end-to-end encrypted

89
00:03:21,980 --> 00:03:24,480
model that becomes a lot harder because

90
00:03:24,480 --> 00:03:26,099
we also have to help the user recover

91
00:03:26,099 --> 00:03:27,959
their keys but we don't have actually

92
00:03:27,959 --> 00:03:29,760
have access to that key as the service

93
00:03:29,760 --> 00:03:31,080
provider

94
00:03:31,080 --> 00:03:33,180
another sort of thing that becomes much

95
00:03:33,180 --> 00:03:34,680
more challenging is real-time

96
00:03:34,680 --> 00:03:37,560
collaboration so in a traditional

97
00:03:37,560 --> 00:03:39,599
application let's say multiple users are

98
00:03:39,599 --> 00:03:41,760
like typing on a document you maybe just

99
00:03:41,760 --> 00:03:43,440
send all those different changes that

100
00:03:43,440 --> 00:03:45,120
they're making to a server the server

101
00:03:45,120 --> 00:03:46,860
runs some algorithm to reconcile them

102
00:03:46,860 --> 00:03:48,239
and then can like distribute that back

103
00:03:48,239 --> 00:03:51,299
out to the users but for end-to-end

104
00:03:51,299 --> 00:03:53,459
encrypted products we don't know the

105
00:03:53,459 --> 00:03:55,739
actual changes users are making to these

106
00:03:55,739 --> 00:03:57,599
documents so that becomes a lot more of

107
00:03:57,599 --> 00:03:59,819
a challenge how do you reconcile changes

108
00:03:59,819 --> 00:04:02,280
maybe on the client we'll talk about

109
00:04:02,280 --> 00:04:03,959
some strategies for that later

110
00:04:03,959 --> 00:04:06,540
and then observability of product bugs

111
00:04:06,540 --> 00:04:08,159
so there's a lot of really cool

112
00:04:08,159 --> 00:04:09,840
Frameworks that you can install in your

113
00:04:09,840 --> 00:04:11,280
front end that will help you track when

114
00:04:11,280 --> 00:04:13,560
users are seeing errors and users are

115
00:04:13,560 --> 00:04:16,260
maybe a user is can't click a button for

116
00:04:16,260 --> 00:04:17,760
some reason or maybe users in a certain

117
00:04:17,760 --> 00:04:20,279
country are not able to load the site

118
00:04:20,279 --> 00:04:22,560
um but a lot of these will break n10

119
00:04:22,560 --> 00:04:23,880
encryption because they'll send

120
00:04:23,880 --> 00:04:26,460
information about the user's page or the

121
00:04:26,460 --> 00:04:28,080
user's content that they're typing to

122
00:04:28,080 --> 00:04:30,840
the server so in end-to-end encrypted

123
00:04:30,840 --> 00:04:33,060
applications understanding what issues

124
00:04:33,060 --> 00:04:34,620
users are facing and solving those

125
00:04:34,620 --> 00:04:36,360
issues becomes a lot more challenging

126
00:04:36,360 --> 00:04:37,860
and then there's many other challenges

127
00:04:37,860 --> 00:04:40,560
as well so at skiff We Believe really

128
00:04:40,560 --> 00:04:43,020
strongly in usable privacy making

129
00:04:43,020 --> 00:04:45,060
privacy first products that are as

130
00:04:45,060 --> 00:04:47,100
simple to use as their traditional

131
00:04:47,100 --> 00:04:49,380
Alternatives so a lot of what we'll talk

132
00:04:49,380 --> 00:04:50,940
about in this talk is how we've

133
00:04:50,940 --> 00:04:52,860
developed clever solutions to a lot of

134
00:04:52,860 --> 00:04:54,900
these problems that make the end user

135
00:04:54,900 --> 00:04:56,820
experience seamless even if the

136
00:04:56,820 --> 00:04:59,400
application is end-to-end encrypted

137
00:04:59,400 --> 00:05:03,198
with that I'll turn it over to initial

138
00:05:03,660 --> 00:05:06,360
thanks Hassan for that intro so what I'm

139
00:05:06,360 --> 00:05:07,500
going to talk about here is we're going

140
00:05:07,500 --> 00:05:09,419
to go you know in the theme of b-sides

141
00:05:09,419 --> 00:05:11,880
is uh you know putting the Cyber in

142
00:05:11,880 --> 00:05:13,740
space or maybe it's the other way I

143
00:05:13,740 --> 00:05:15,240
don't remember but we're going to go

144
00:05:15,240 --> 00:05:16,259
through a mission we're going to build

145
00:05:16,259 --> 00:05:18,000
an end-to-end encrypted mission log for

146
00:05:18,000 --> 00:05:19,199
our spaceship

147
00:05:19,199 --> 00:05:21,000
and so what is the one of the first

148
00:05:21,000 --> 00:05:22,199
things you're going to have to do in

149
00:05:22,199 --> 00:05:23,759
developing an application well the

150
00:05:23,759 --> 00:05:26,220
captain's got to be able to log in

151
00:05:26,220 --> 00:05:29,100
so let's just recap you know most

152
00:05:29,100 --> 00:05:32,039
applications right we have the captain

153
00:05:32,039 --> 00:05:33,900
will just type their password in the

154
00:05:33,900 --> 00:05:35,039
password would have been sent over the

155
00:05:35,039 --> 00:05:37,139
network to the server the server hashes

156
00:05:37,139 --> 00:05:39,780
that password and then Compares those

157
00:05:39,780 --> 00:05:41,580
hash values to authenticate the captain

158
00:05:41,580 --> 00:05:43,440
ultimately

159
00:05:43,440 --> 00:05:45,360
this leaks the password to the server

160
00:05:45,360 --> 00:05:47,400
but you know you're using it to hash

161
00:05:47,400 --> 00:05:49,199
however an end-to-end encrypted scheme

162
00:05:49,199 --> 00:05:51,240
we might want to use that password to

163
00:05:51,240 --> 00:05:53,280
help generate the user's encryption keys

164
00:05:53,280 --> 00:05:55,680
so that would imply that sending the

165
00:05:55,680 --> 00:05:57,000
password to the server would break the

166
00:05:57,000 --> 00:05:58,500
end-to-end encrypted end-to-end

167
00:05:58,500 --> 00:06:01,440
encryption guarantees

168
00:06:01,440 --> 00:06:03,660
so we can actually use a class of

169
00:06:03,660 --> 00:06:05,460
algorithms called an asymmetric or

170
00:06:05,460 --> 00:06:07,440
augmented Pig you may have heard about

171
00:06:07,440 --> 00:06:10,440
this as the SRP secure remote password

172
00:06:10,440 --> 00:06:13,199
um you know it's now it's more

173
00:06:13,199 --> 00:06:14,820
modernized version It's called opaque

174
00:06:14,820 --> 00:06:18,060
and SRP just to provide a brief recap

175
00:06:18,060 --> 00:06:20,580
allows us to authenticate the client to

176
00:06:20,580 --> 00:06:21,960
the server without needing to send the

177
00:06:21,960 --> 00:06:22,800
password

178
00:06:22,800 --> 00:06:24,960
it also has a very strong benefit in

179
00:06:24,960 --> 00:06:26,580
being fishing resistant because the

180
00:06:26,580 --> 00:06:29,100
server also authenticates to the client

181
00:06:29,100 --> 00:06:31,500
so here we have you know passwords are

182
00:06:31,500 --> 00:06:33,479
not sent over the network great right

183
00:06:33,479 --> 00:06:35,280
and we're mutually authenticated both

184
00:06:35,280 --> 00:06:37,020
server and client and I'm just going to

185
00:06:37,020 --> 00:06:39,660
take a tangent here is that when

186
00:06:39,660 --> 00:06:42,180
reviewing kind of oauth's top 10 you

187
00:06:42,180 --> 00:06:44,039
know both the 2023 release candidate

188
00:06:44,039 --> 00:06:48,060
2021 also talking about these exact type

189
00:06:48,060 --> 00:06:50,520
of issues there's really no mention of

190
00:06:50,520 --> 00:06:52,080
SRP which has been around for 20 years

191
00:06:52,080 --> 00:06:54,360
or opaque as potential solutions to

192
00:06:54,360 --> 00:06:55,620
password leakage problems in the

193
00:06:55,620 --> 00:06:57,600
industry it's not even mentioned in the

194
00:06:57,600 --> 00:07:00,180
nist standards and so

195
00:07:00,180 --> 00:07:01,680
one of the things that I recommend

196
00:07:01,680 --> 00:07:03,720
looking at for for most applications is

197
00:07:03,720 --> 00:07:05,880
actually adopting SRP or opaque as a way

198
00:07:05,880 --> 00:07:07,919
to prevent password leakage entirely in

199
00:07:07,919 --> 00:07:10,199
in traditional applications

200
00:07:10,199 --> 00:07:13,020
the way SRP works is just to provide a

201
00:07:13,020 --> 00:07:15,060
really quick example is it uses a

202
00:07:15,060 --> 00:07:17,520
diffie-hellman like key exchange and a

203
00:07:17,520 --> 00:07:18,960
you know challenge response mechanism

204
00:07:18,960 --> 00:07:22,400
but I won't go into that here

205
00:07:22,620 --> 00:07:24,419
so if you get anything from the slide

206
00:07:24,419 --> 00:07:26,099
from this presentations you can't leave

207
00:07:26,099 --> 00:07:27,539
passwords if you don't have them right

208
00:07:27,539 --> 00:07:29,160
and this has been a huge problem in the

209
00:07:29,160 --> 00:07:32,220
industry for many years so the one thing

210
00:07:32,220 --> 00:07:34,199
we're heavily pushing for is you know

211
00:07:34,199 --> 00:07:35,759
traditional applications to adopt these

212
00:07:35,759 --> 00:07:37,800
sorts of mechanisms

213
00:07:37,800 --> 00:07:41,580
all right so now that rant is over let's

214
00:07:41,580 --> 00:07:42,900
walk through how we can generate Keys

215
00:07:42,900 --> 00:07:44,759
required for SRP to authenticate to the

216
00:07:44,759 --> 00:07:46,979
Mission Log server we take our password

217
00:07:46,979 --> 00:07:49,740
and run it through argon2id which some

218
00:07:49,740 --> 00:07:51,660
of you might be familiar with as a

219
00:07:51,660 --> 00:07:54,120
modern successor to you know pbk df2

220
00:07:54,120 --> 00:07:56,280
apps script decrypt all that fun stuff

221
00:07:56,280 --> 00:07:58,800
we'll take it through argon2id generate

222
00:07:58,800 --> 00:08:00,780
some random data we'll take that random

223
00:08:00,780 --> 00:08:02,039
data and process it through another

224
00:08:02,039 --> 00:08:03,840
function called an hmac key derivation

225
00:08:03,840 --> 00:08:05,220
function and this basically just

226
00:08:05,220 --> 00:08:07,680
generates more random data and from that

227
00:08:07,680 --> 00:08:08,880
we can actually generate

228
00:08:08,880 --> 00:08:10,680
cryptographically secure Keys we'll

229
00:08:10,680 --> 00:08:12,180
generate two key pairs that we'll talk

230
00:08:12,180 --> 00:08:13,620
about in this presentation we'll

231
00:08:13,620 --> 00:08:15,479
generate some signing keys and we'll

232
00:08:15,479 --> 00:08:17,639
generate encryption Keys the signing key

233
00:08:17,639 --> 00:08:19,199
pairs you actually use for the SRP

234
00:08:19,199 --> 00:08:21,120
protocol I mentioned earlier and then

235
00:08:21,120 --> 00:08:22,620
the encryption key pair is actually what

236
00:08:22,620 --> 00:08:24,360
we'll use to bootstrap

237
00:08:24,360 --> 00:08:28,139
the the end-to-end encrypted of the user

238
00:08:28,139 --> 00:08:31,919
data okay great but what happens when I

239
00:08:31,919 --> 00:08:33,539
forgetful Captain forgets their password

240
00:08:33,539 --> 00:08:36,479
and wants to reset it if the encryption

241
00:08:36,479 --> 00:08:37,799
keys are derived from the password does

242
00:08:37,799 --> 00:08:39,419
this mean the captain loses all of their

243
00:08:39,419 --> 00:08:41,339
mission log data

244
00:08:41,339 --> 00:08:43,200
so we'll talk about how we can go

245
00:08:43,200 --> 00:08:44,940
through a forgot password

246
00:08:44,940 --> 00:08:46,860
ultimately here if we're thinking about

247
00:08:46,860 --> 00:08:48,720
the captain their goal is to recover

248
00:08:48,720 --> 00:08:50,760
Mission Log data and change their

249
00:08:50,760 --> 00:08:53,160
password right changing the password and

250
00:08:53,160 --> 00:08:55,019
losing their data would be a mission

251
00:08:55,019 --> 00:08:56,519
critical failure

252
00:08:56,519 --> 00:08:58,560
the first step here what we're going to

253
00:08:58,560 --> 00:08:59,339
do

254
00:08:59,339 --> 00:09:01,980
is to generate a new asymmetric key pair

255
00:09:01,980 --> 00:09:04,200
called the recovery key pair

256
00:09:04,200 --> 00:09:05,820
and that's the key pair here in the

257
00:09:05,820 --> 00:09:07,380
middle Black Box

258
00:09:07,380 --> 00:09:09,660
this recovery key pair is used to

259
00:09:09,660 --> 00:09:11,820
encrypt that user's asymmetric

260
00:09:11,820 --> 00:09:13,560
encryption keys I showed on the previous

261
00:09:13,560 --> 00:09:14,820
slide

262
00:09:14,820 --> 00:09:17,100
this encrypted recovery payload is now

263
00:09:17,100 --> 00:09:18,959
stored on the mission lock server but

264
00:09:18,959 --> 00:09:20,580
can't be used to access the encryption

265
00:09:20,580 --> 00:09:22,860
Keys nor the mission log data

266
00:09:22,860 --> 00:09:24,420
so now what do we do with this recovery

267
00:09:24,420 --> 00:09:25,680
key pair right we've encrypted this

268
00:09:25,680 --> 00:09:27,480
payload what do we do with it we can

269
00:09:27,480 --> 00:09:29,880
actually use Shamir secret sharing split

270
00:09:29,880 --> 00:09:32,160
this private key material up into three

271
00:09:32,160 --> 00:09:34,560
shards where two shards are needed to

272
00:09:34,560 --> 00:09:36,839
reconstruct the private keys and what we

273
00:09:36,839 --> 00:09:38,700
can do is we can be clever about how we

274
00:09:38,700 --> 00:09:40,620
give these shards and how we how the

275
00:09:40,620 --> 00:09:43,500
user can access them so for example

276
00:09:43,500 --> 00:09:45,480
you know we can give one we can store

277
00:09:45,480 --> 00:09:47,160
one on the users on the captain's device

278
00:09:47,160 --> 00:09:49,019
we can store another one as a PDF

279
00:09:49,019 --> 00:09:50,339
document the captain hides underneath

280
00:09:50,339 --> 00:09:52,620
their bed and a third we can actually

281
00:09:52,620 --> 00:09:55,680
store maybe on the server because again

282
00:09:55,680 --> 00:09:57,360
only two are needed to reconstruct the

283
00:09:57,360 --> 00:09:59,820
private key and so by putting one on on

284
00:09:59,820 --> 00:10:01,860
the server we can actually have the user

285
00:10:01,860 --> 00:10:05,060
go through traditional forgot password

286
00:10:05,060 --> 00:10:08,100
forgot password mechanisms you can do

287
00:10:08,100 --> 00:10:09,959
you know email verification you could do

288
00:10:09,959 --> 00:10:11,880
phone number verification you can run

289
00:10:11,880 --> 00:10:13,200
any sort of advanced heuristics that

290
00:10:13,200 --> 00:10:14,760
we're already used to in in traditional

291
00:10:14,760 --> 00:10:17,220
applications but the point is the

292
00:10:17,220 --> 00:10:18,959
captain needs two of the three to

293
00:10:18,959 --> 00:10:22,099
reconstruct their keys

294
00:10:23,640 --> 00:10:25,740
so let's go through the actual process

295
00:10:25,740 --> 00:10:27,600
of resetting the password the captain

296
00:10:27,600 --> 00:10:29,760
can present two of the three shards we

297
00:10:29,760 --> 00:10:32,040
can reassemble that recovery private key

298
00:10:32,040 --> 00:10:33,959
which is then used to decrypt that

299
00:10:33,959 --> 00:10:36,060
payload the recovery key payload which

300
00:10:36,060 --> 00:10:37,560
actually again gets them access to the

301
00:10:37,560 --> 00:10:39,600
decryption keys

302
00:10:39,600 --> 00:10:41,580
so Captain has their data we can

303
00:10:41,580 --> 00:10:44,399
actually run a very similar process to

304
00:10:44,399 --> 00:10:46,260
gain access to the signing keys for SRP

305
00:10:46,260 --> 00:10:48,300
to reset their password it's very much

306
00:10:48,300 --> 00:10:50,279
the exact same process it's just it's

307
00:10:50,279 --> 00:10:51,959
just a different key pair

308
00:10:51,959 --> 00:10:54,420
so all of this complexity can be hidden

309
00:10:54,420 --> 00:10:56,100
within like the appropriate user flows

310
00:10:56,100 --> 00:10:58,260
and so to the to the to the caption

311
00:10:58,260 --> 00:10:59,519
they're just resetting their password

312
00:10:59,519 --> 00:11:01,019
but all of this happens behind the

313
00:11:01,019 --> 00:11:03,320
scenes

314
00:11:03,660 --> 00:11:05,399
great so now that we've talked about

315
00:11:05,399 --> 00:11:08,100
that about how the how the captain can

316
00:11:08,100 --> 00:11:09,660
authenticate to the Mission Log we'll

317
00:11:09,660 --> 00:11:11,519
talk about how the captain can actually

318
00:11:11,519 --> 00:11:15,079
use these keys to encrypt data

319
00:11:16,620 --> 00:11:17,940
awesome

320
00:11:17,940 --> 00:11:20,579
so yeah so our motivation for this

321
00:11:20,579 --> 00:11:22,980
section is now we know how a user

322
00:11:22,980 --> 00:11:24,480
authenticates like the captain

323
00:11:24,480 --> 00:11:26,519
authenticates to their mission log but

324
00:11:26,519 --> 00:11:28,860
we want to understand okay how does the

325
00:11:28,860 --> 00:11:30,899
actual n10 encryption process work like

326
00:11:30,899 --> 00:11:32,820
let's say you wanted to upload a mission

327
00:11:32,820 --> 00:11:35,760
log and have it be intent encrypted how

328
00:11:35,760 --> 00:11:37,740
how would you do that

329
00:11:37,740 --> 00:11:40,079
so first just to explain some really

330
00:11:40,079 --> 00:11:42,420
simple Primitives that we'll use there

331
00:11:42,420 --> 00:11:44,760
are two sort of classes of cryptographic

332
00:11:44,760 --> 00:11:46,440
algorithms that are going to be relevant

333
00:11:46,440 --> 00:11:48,779
to this discussion asymmetric and

334
00:11:48,779 --> 00:11:51,120
symmetric encryption so I'll start by

335
00:11:51,120 --> 00:11:52,500
explaining symmetric encryption

336
00:11:52,500 --> 00:11:54,720
symmetric encryption is a pretty simple

337
00:11:54,720 --> 00:11:57,060
crypto class of cryptographic algorithms

338
00:11:57,060 --> 00:11:59,880
where you basically just have a key and

339
00:11:59,880 --> 00:12:02,339
you insert into this algorithm this key

340
00:12:02,339 --> 00:12:04,680
you can or a passphrase you can call it

341
00:12:04,680 --> 00:12:07,140
multiple things plus plain text and you

342
00:12:07,140 --> 00:12:09,240
get ciphertext and then if you use that

343
00:12:09,240 --> 00:12:11,579
same key that same passphrase plus

344
00:12:11,579 --> 00:12:15,120
ciphertext you get plain text right so

345
00:12:15,120 --> 00:12:17,160
like imagine I was

346
00:12:17,160 --> 00:12:19,380
sending a package initial and I didn't

347
00:12:19,380 --> 00:12:21,300
want it to be intercepted by anyone in

348
00:12:21,300 --> 00:12:25,140
between I could put a lock box in this

349
00:12:25,140 --> 00:12:27,959
package right and and lock it with a

350
00:12:27,959 --> 00:12:30,120
combination lock send that package to

351
00:12:30,120 --> 00:12:32,640
initial and if initial if I've told

352
00:12:32,640 --> 00:12:34,860
initial the combination before like

353
00:12:34,860 --> 00:12:36,600
maybe I texted it to him or something

354
00:12:36,600 --> 00:12:39,060
else he can use that same combination to

355
00:12:39,060 --> 00:12:40,680
open the lock box and retrieve what was

356
00:12:40,680 --> 00:12:42,180
inside

357
00:12:42,180 --> 00:12:44,220
asymmetric encryption Works a little

358
00:12:44,220 --> 00:12:46,139
differently so an asymmetric encryption

359
00:12:46,139 --> 00:12:48,600
you actually generate two keys a public

360
00:12:48,600 --> 00:12:50,639
key and a private key and then these are

361
00:12:50,639 --> 00:12:53,339
this is called a key pair

362
00:12:53,339 --> 00:12:55,380
um and these this public key and private

363
00:12:55,380 --> 00:12:56,940
key are related through a special

364
00:12:56,940 --> 00:12:59,700
mathematical operation where the public

365
00:12:59,700 --> 00:13:02,279
key can be used to encrypt

366
00:13:02,279 --> 00:13:04,200
um a piece of information that is only

367
00:13:04,200 --> 00:13:07,320
able to be decrypted by the private key

368
00:13:07,320 --> 00:13:09,540
so the reason these are called public

369
00:13:09,540 --> 00:13:11,279
and private is because the idea is

370
00:13:11,279 --> 00:13:13,019
basically you can share your public key

371
00:13:13,019 --> 00:13:14,639
with the world

372
00:13:14,639 --> 00:13:16,620
um anyone so in this case initial could

373
00:13:16,620 --> 00:13:18,480
share his public key with me post it on

374
00:13:18,480 --> 00:13:21,180
a public messaging board whatever and I

375
00:13:21,180 --> 00:13:24,839
can use that to let's say encrypt a

376
00:13:24,839 --> 00:13:27,180
letter for him in this case but then

377
00:13:27,180 --> 00:13:30,060
only he can decrypt that letter with a

378
00:13:30,060 --> 00:13:32,279
private key so the cool thing with

379
00:13:32,279 --> 00:13:34,380
asymmetric encryption is like I don't

380
00:13:34,380 --> 00:13:35,820
need to do this step that I mentioned

381
00:13:35,820 --> 00:13:37,620
before where like maybe I text the

382
00:13:37,620 --> 00:13:39,899
passphrase to him out of band instead

383
00:13:39,899 --> 00:13:41,639
because there's two keys I can just use

384
00:13:41,639 --> 00:13:43,500
his public key to encrypt something and

385
00:13:43,500 --> 00:13:45,779
he can decrypt it with a private key so

386
00:13:45,779 --> 00:13:47,399
at skiff like National was mentioning

387
00:13:47,399 --> 00:13:49,579
and for most nt10 encrypted applications

388
00:13:49,579 --> 00:13:53,160
we we assign each user an asymmetric key

389
00:13:53,160 --> 00:13:55,560
pair so this is the public and private

390
00:13:55,560 --> 00:13:57,680
key

391
00:13:57,839 --> 00:13:59,820
so let's go through encrypting the

392
00:13:59,820 --> 00:14:02,579
mission log there's one more Nuance you

393
00:14:02,579 --> 00:14:04,680
might think okay so like asymmetric

394
00:14:04,680 --> 00:14:06,000
encryption is really cool there's these

395
00:14:06,000 --> 00:14:07,860
two keys you can post the public key

396
00:14:07,860 --> 00:14:09,420
like what's the disadvantage of

397
00:14:09,420 --> 00:14:11,700
asymmetric encryption right

398
00:14:11,700 --> 00:14:13,320
um and the disadvantage is because of

399
00:14:13,320 --> 00:14:15,120
the mathematical operations involved

400
00:14:15,120 --> 00:14:17,519
asymmetric encryption is actually very

401
00:14:17,519 --> 00:14:19,980
slow for encrypting large amounts of

402
00:14:19,980 --> 00:14:21,600
data

403
00:14:21,600 --> 00:14:23,279
um like like let's say a file like the

404
00:14:23,279 --> 00:14:24,420
mission log

405
00:14:24,420 --> 00:14:27,899
um so symmetric encryption is fast but

406
00:14:27,899 --> 00:14:29,459
it has this problem where you have to

407
00:14:29,459 --> 00:14:31,620
share the key in advance so how do we

408
00:14:31,620 --> 00:14:34,680
combine these two things to encrypt our

409
00:14:34,680 --> 00:14:38,160
mission log properly so what we'll do

410
00:14:38,160 --> 00:14:41,220
is we generate a symmetric key called

411
00:14:41,220 --> 00:14:45,120
the data key this this key is very small

412
00:14:45,120 --> 00:14:50,040
like maybe 32 bytes 32 characters

413
00:14:50,040 --> 00:14:52,079
and we'll use the data key to encrypt

414
00:14:52,079 --> 00:14:54,360
the mission log with a symmetric Cipher

415
00:14:54,360 --> 00:14:56,579
this is very fast because a symmetric

416
00:14:56,579 --> 00:14:58,260
Cipher is fast at encrypting large

417
00:14:58,260 --> 00:14:59,579
amounts of data

418
00:14:59,579 --> 00:15:02,100
and then we use the user key pair to

419
00:15:02,100 --> 00:15:04,440
encrypt the data key itself and this is

420
00:15:04,440 --> 00:15:07,079
also very fast because the data key is

421
00:15:07,079 --> 00:15:09,480
very small it's only 32 bytes

422
00:15:09,480 --> 00:15:11,279
and then we'll store two things we'll

423
00:15:11,279 --> 00:15:13,500
store the encrypted data key and we'll

424
00:15:13,500 --> 00:15:17,160
store the encrypted mission log

425
00:15:17,160 --> 00:15:19,139
now let's walk through how decryption

426
00:15:19,139 --> 00:15:22,980
works so to decrypt we'll use a user's

427
00:15:22,980 --> 00:15:25,560
key pair to decrypt this data key that's

428
00:15:25,560 --> 00:15:28,320
fast because the data key is small and

429
00:15:28,320 --> 00:15:30,060
then we'll use the data key to decrypt

430
00:15:30,060 --> 00:15:31,980
the mission log so you can see in this

431
00:15:31,980 --> 00:15:34,079
data in this diagram right here there's

432
00:15:34,079 --> 00:15:36,000
an encrypted data key with the user's

433
00:15:36,000 --> 00:15:38,100
key pair we do decryption we get the

434
00:15:38,100 --> 00:15:40,079
data key out and then we use the data

435
00:15:40,079 --> 00:15:42,240
key with the encrypted Mission Log and

436
00:15:42,240 --> 00:15:45,920
we'll get the point text mission log out

437
00:15:46,500 --> 00:15:48,660
so now let's say I wanted to share this

438
00:15:48,660 --> 00:15:51,120
mission log with initial

439
00:15:51,120 --> 00:15:53,220
so I've uploaded it I've done all those

440
00:15:53,220 --> 00:15:54,260
operations

441
00:15:54,260 --> 00:15:56,519
now if I want to share the mission log

442
00:15:56,519 --> 00:15:59,519
initial all I have to do is encrypt that

443
00:15:59,519 --> 00:16:01,860
data key with initials key pair as well

444
00:16:01,860 --> 00:16:04,339
and upload that to the server

445
00:16:04,339 --> 00:16:06,959
now initial can follow the same

446
00:16:06,959 --> 00:16:10,320
procedure to decrypt the document that I

447
00:16:10,320 --> 00:16:12,079
just described

448
00:16:12,079 --> 00:16:14,880
one other really cool property of

449
00:16:14,880 --> 00:16:16,740
sharing a document in this way is notice

450
00:16:16,740 --> 00:16:18,899
that I did not need to re-encrypt the

451
00:16:18,899 --> 00:16:21,180
entire document a second time I only

452
00:16:21,180 --> 00:16:24,060
needed to re-encrypt the data key so it

453
00:16:24,060 --> 00:16:26,220
turns out this approach actually scales

454
00:16:26,220 --> 00:16:28,260
really really well when you're sharing

455
00:16:28,260 --> 00:16:30,899
with a large number of collaborators

456
00:16:30,899 --> 00:16:33,540
um even in even as a further Advantage

457
00:16:33,540 --> 00:16:37,880
than just an individual

458
00:16:38,120 --> 00:16:40,800
so now let's say we have multiple

459
00:16:40,800 --> 00:16:43,019
Mission Log entries I've you know

460
00:16:43,019 --> 00:16:44,579
uploaded it I've shared the single

461
00:16:44,579 --> 00:16:46,440
Mission Log initial a bunch of time has

462
00:16:46,440 --> 00:16:48,120
passed we've accumulated multiple of

463
00:16:48,120 --> 00:16:50,220
these Mission logs and we want to share

464
00:16:50,220 --> 00:16:53,279
a folder of these Mission logs and I

465
00:16:53,279 --> 00:16:54,660
want to share a folder with these of

466
00:16:54,660 --> 00:16:55,920
these Mission logs

467
00:16:55,920 --> 00:16:58,199
without going as opposed to you know

468
00:16:58,199 --> 00:16:59,399
going through this process of like

469
00:16:59,399 --> 00:17:01,500
sharing each one with him as I generate

470
00:17:01,500 --> 00:17:02,699
them

471
00:17:02,699 --> 00:17:05,699
so one way to do this is to kind of

472
00:17:05,699 --> 00:17:08,400
treat folders like a user where a folder

473
00:17:08,400 --> 00:17:10,439
is sort of a special construct that

474
00:17:10,439 --> 00:17:13,859
actually has its own asymmetric key pair

475
00:17:13,859 --> 00:17:16,799
and when I add a log to a folder instead

476
00:17:16,799 --> 00:17:18,480
of sharing it with a user what I'm

477
00:17:18,480 --> 00:17:20,520
actually doing it as I'm sharing the

478
00:17:20,520 --> 00:17:25,679
logs data key with the folder key pair

479
00:17:25,679 --> 00:17:28,260
so now let's say I want to decrypt a

480
00:17:28,260 --> 00:17:30,059
file that is stored in a folder a

481
00:17:30,059 --> 00:17:31,640
mission log that is stored in a folder

482
00:17:31,640 --> 00:17:35,340
we kind of follow this tree hierarchy so

483
00:17:35,340 --> 00:17:37,020
we have an example here on the right

484
00:17:37,020 --> 00:17:39,299
where there's a mission logs folder in

485
00:17:39,299 --> 00:17:41,880
that there's a year one logs folder and

486
00:17:41,880 --> 00:17:45,500
in that there's a 422 log for today

487
00:17:45,500 --> 00:17:49,500
so what I'll do is I'll use my key to

488
00:17:49,500 --> 00:17:51,660
decrypt the mission log folder

489
00:17:51,660 --> 00:17:53,760
and then I'll use the mission logs key

490
00:17:53,760 --> 00:17:56,820
to decrypt the year one logs folder and

491
00:17:56,820 --> 00:17:58,799
then I'll use the year one logs key pair

492
00:17:58,799 --> 00:18:01,980
to decrypt the 422 log

493
00:18:01,980 --> 00:18:04,559
so you might notice this is kind of

494
00:18:04,559 --> 00:18:06,360
following like a tree structure right

495
00:18:06,360 --> 00:18:08,160
like a recursive structure for those of

496
00:18:08,160 --> 00:18:09,240
you that are familiar with like

497
00:18:09,240 --> 00:18:11,460
recursive algorithms

498
00:18:11,460 --> 00:18:14,220
um and it and indeed this sort of forms

499
00:18:14,220 --> 00:18:16,020
like this key system that we're

500
00:18:16,020 --> 00:18:18,240
describing kind of can be generalized to

501
00:18:18,240 --> 00:18:20,340
any tree where you have one root node

502
00:18:20,340 --> 00:18:22,559
that you are shared on and then want to

503
00:18:22,559 --> 00:18:24,900
decrypt any of the sub elements of that

504
00:18:24,900 --> 00:18:25,740
node

505
00:18:25,740 --> 00:18:28,919
so we just described a case of shared

506
00:18:28,919 --> 00:18:31,880
documents at skiff we also are

507
00:18:31,880 --> 00:18:34,200
investigating using a similar approach

508
00:18:34,200 --> 00:18:36,660
for several other product features so

509
00:18:36,660 --> 00:18:39,179
you can imagine that this would work

510
00:18:39,179 --> 00:18:42,539
well for a team inbox like a a user

511
00:18:42,539 --> 00:18:45,419
inbox that or an inbox that an email

512
00:18:45,419 --> 00:18:48,900
that multiple users have access to or

513
00:18:48,900 --> 00:18:52,320
shared calendars um that are popular in

514
00:18:52,320 --> 00:18:55,380
many other calendar softwares so this is

515
00:18:55,380 --> 00:18:58,140
a calendar where multiple users can view

516
00:18:58,140 --> 00:19:01,160
and edit events

517
00:19:03,179 --> 00:19:05,520
um and and I'll also just add that um

518
00:19:05,520 --> 00:19:07,500
besides these use cases these are some

519
00:19:07,500 --> 00:19:09,720
use cases that we have at skip but you

520
00:19:09,720 --> 00:19:11,520
can imagine many other such use cases

521
00:19:11,520 --> 00:19:13,679
for what is essentially just a generic

522
00:19:13,679 --> 00:19:16,039
tree of end-to-end encrypted information

523
00:19:16,039 --> 00:19:18,720
can have applicability for a wide range

524
00:19:18,720 --> 00:19:21,960
of n10 encrypted applications

525
00:19:21,960 --> 00:19:24,900
but a lot of folks here and a lot of

526
00:19:24,900 --> 00:19:26,160
folks around the world are not

527
00:19:26,160 --> 00:19:27,960
developing on intent encrypted

528
00:19:27,960 --> 00:19:30,840
applications just yet so we wanted to

529
00:19:30,840 --> 00:19:32,280
talk a little bit about how this can

530
00:19:32,280 --> 00:19:34,500
also be applicable to more traditional

531
00:19:34,500 --> 00:19:37,260
applications right so let's say you

532
00:19:37,260 --> 00:19:38,700
don't have an intent encrypted you don't

533
00:19:38,700 --> 00:19:40,020
have you don't have these keys on the

534
00:19:40,020 --> 00:19:41,520
client but you still want to apply some

535
00:19:41,520 --> 00:19:44,400
of these principles and let's take the

536
00:19:44,400 --> 00:19:46,740
example of you're storing a user's first

537
00:19:46,740 --> 00:19:49,620
name right typically when you're storing

538
00:19:49,620 --> 00:19:51,299
a user's first name maybe you collect it

539
00:19:51,299 --> 00:19:54,120
on sign up and then it goes through a

540
00:19:54,120 --> 00:19:56,160
bunch of different like data storage

541
00:19:56,160 --> 00:19:58,799
Services user authentication Services

542
00:19:58,799 --> 00:20:00,600
whatever is ultimately stored in the

543
00:20:00,600 --> 00:20:02,640
database and then later you want to read

544
00:20:02,640 --> 00:20:04,440
it all the way out right so you like

545
00:20:04,440 --> 00:20:06,299
retrieve it from the database retrieve

546
00:20:06,299 --> 00:20:07,500
it through a user storage service

547
00:20:07,500 --> 00:20:09,720
whatever whatever eventually you display

548
00:20:09,720 --> 00:20:11,400
it on the user's page

549
00:20:11,400 --> 00:20:13,820
but a lot of those intermediary Services

550
00:20:13,820 --> 00:20:17,039
don't actually need to do anything with

551
00:20:17,039 --> 00:20:19,080
the user's first name they're just kind

552
00:20:19,080 --> 00:20:22,080
of passing it on and passing it through

553
00:20:22,080 --> 00:20:24,480
so one sort of principle you can borrow

554
00:20:24,480 --> 00:20:28,320
from what we just discussed is at the at

555
00:20:28,320 --> 00:20:30,960
the like sort of API layer or the last

556
00:20:30,960 --> 00:20:33,240
service that needs to actually do a

557
00:20:33,240 --> 00:20:35,580
computation with the users

558
00:20:35,580 --> 00:20:37,980
um first name you can encrypt this piece

559
00:20:37,980 --> 00:20:39,480
of information right and then when

560
00:20:39,480 --> 00:20:41,039
you're feeding it through all the

561
00:20:41,039 --> 00:20:43,980
dependent Services those services will

562
00:20:43,980 --> 00:20:46,200
just pass on this encrypted piece of

563
00:20:46,200 --> 00:20:49,260
data and then on on the other hand when

564
00:20:49,260 --> 00:20:51,480
you're pulling it out you can decrypt it

565
00:20:51,480 --> 00:20:53,400
at the layer that you need to access it

566
00:20:53,400 --> 00:20:56,400
and what's really powerful about this is

567
00:20:56,400 --> 00:20:58,620
it means that now you've isolated the

568
00:20:58,620 --> 00:21:00,900
set of services that have access to the

569
00:21:00,900 --> 00:21:03,900
plain text copy of this user's name

570
00:21:03,900 --> 00:21:06,419
and as a security engineer you can spend

571
00:21:06,419 --> 00:21:09,059
a lot less time worried about hardening

572
00:21:09,059 --> 00:21:13,080
and like protecting the services that

573
00:21:13,080 --> 00:21:14,580
um have only have access to the

574
00:21:14,580 --> 00:21:16,679
encrypted copy because you know that

575
00:21:16,679 --> 00:21:18,660
they even if there was a compromise of

576
00:21:18,660 --> 00:21:20,760
those Services an attacker would only

577
00:21:20,760 --> 00:21:23,100
recover the cipher text

578
00:21:23,100 --> 00:21:24,900
and then on the other side as an

579
00:21:24,900 --> 00:21:26,960
engineer who's working on these Services

580
00:21:26,960 --> 00:21:30,059
you can spend a lot you can worry a lot

581
00:21:30,059 --> 00:21:31,740
less about a compromise of these

582
00:21:31,740 --> 00:21:33,840
Services compromising the user's first

583
00:21:33,840 --> 00:21:35,580
name or any other piece of information

584
00:21:35,580 --> 00:21:37,919
that's encrypted in this way because

585
00:21:37,919 --> 00:21:40,320
your your application is only ever

586
00:21:40,320 --> 00:21:43,679
operating off the ciphertext

587
00:21:43,679 --> 00:21:45,419
uh with that I'll turn it over to

588
00:21:45,419 --> 00:21:49,080
initial to talk about how we can use

589
00:21:49,080 --> 00:21:51,840
this end-tent encrypted context to

590
00:21:51,840 --> 00:21:53,880
enable many product features in

591
00:21:53,880 --> 00:21:57,419
different n10 encrypted applications

592
00:21:57,419 --> 00:21:59,159
awesome

593
00:21:59,159 --> 00:22:01,740
thanks Hassan so we talked a lot about

594
00:22:01,740 --> 00:22:04,559
data data being read data being written

595
00:22:04,559 --> 00:22:07,320
sharing that data but ultimately there's

596
00:22:07,320 --> 00:22:09,120
other things about data right data

597
00:22:09,120 --> 00:22:10,679
schemas will change data transmission

598
00:22:10,679 --> 00:22:12,780
layers will change and so how do you

599
00:22:12,780 --> 00:22:14,460
adapt end-to-end encrypted applications

600
00:22:14,460 --> 00:22:16,380
for a lot of these future goals when you

601
00:22:16,380 --> 00:22:17,880
don't even have access to the underlying

602
00:22:17,880 --> 00:22:18,900
data

603
00:22:18,900 --> 00:22:21,480
so basically everything about data

604
00:22:21,480 --> 00:22:23,400
except the data could change and so how

605
00:22:23,400 --> 00:22:25,140
do we handle that

606
00:22:25,140 --> 00:22:26,880
so let's talk about an example for like

607
00:22:26,880 --> 00:22:28,559
notifications

608
00:22:28,559 --> 00:22:30,240
let's say I want to send this on a

609
00:22:30,240 --> 00:22:31,679
calendar invite to go over the mission

610
00:22:31,679 --> 00:22:32,760
log

611
00:22:32,760 --> 00:22:34,740
I would encrypt a notification for Assan

612
00:22:34,740 --> 00:22:36,840
containing the event title and maybe the

613
00:22:36,840 --> 00:22:37,679
time

614
00:22:37,679 --> 00:22:39,120
my phone sends out encrypted

615
00:22:39,120 --> 00:22:41,640
notification data to the server

616
00:22:41,640 --> 00:22:43,260
the server delivers that encrypted

617
00:22:43,260 --> 00:22:44,580
notification

618
00:22:44,580 --> 00:22:47,940
to uh to assan's phone I'm sorry the

619
00:22:47,940 --> 00:22:50,520
other way around to to my phone and then

620
00:22:50,520 --> 00:22:52,740
assan's phone decrypts and displays the

621
00:22:52,740 --> 00:22:54,720
notification so essentially what we've

622
00:22:54,720 --> 00:22:56,760
described is real-time unidirectional

623
00:22:56,760 --> 00:22:57,900
communication

624
00:22:57,900 --> 00:22:59,760
right and if you're not really going to

625
00:22:59,760 --> 00:23:01,260
enter an encrypted app end-to-end

626
00:23:01,260 --> 00:23:02,580
encrypted notifications are actually

627
00:23:02,580 --> 00:23:04,860
very simple can be supported by

628
00:23:04,860 --> 00:23:06,480
traditional applications and the way you

629
00:23:06,480 --> 00:23:08,940
would do that is on device enrollment of

630
00:23:08,940 --> 00:23:10,200
you know accepting these push

631
00:23:10,200 --> 00:23:12,720
notifications from Apple or Google

632
00:23:12,720 --> 00:23:15,000
you generate keys and you send those

633
00:23:15,000 --> 00:23:16,740
keys to your server and you simply

634
00:23:16,740 --> 00:23:17,880
encrypt those notifications before

635
00:23:17,880 --> 00:23:19,620
sending them out

636
00:23:19,620 --> 00:23:22,440
so this is really easy to set up don't

637
00:23:22,440 --> 00:23:24,000
need to have a full end-to-end encrypted

638
00:23:24,000 --> 00:23:25,440
applications but you can send end-to-end

639
00:23:25,440 --> 00:23:27,419
encrypted notifications in traditional

640
00:23:27,419 --> 00:23:30,720
applications actually very simply

641
00:23:30,720 --> 00:23:32,280
great what about bi-directional

642
00:23:32,280 --> 00:23:34,080
real-time communication

643
00:23:34,080 --> 00:23:35,580
so we can actually

644
00:23:35,580 --> 00:23:38,159
use a data structure an algorithm called

645
00:23:38,159 --> 00:23:40,559
crdt conflict-free replicated data type

646
00:23:40,559 --> 00:23:42,299
I won't go into that here in this talk

647
00:23:42,299 --> 00:23:46,440
but the point is is that crdds are

648
00:23:46,440 --> 00:23:48,299
eventually consistent and I mean that in

649
00:23:48,299 --> 00:23:49,860
the computer science like Theory

650
00:23:49,860 --> 00:23:51,840
perspective in that

651
00:23:51,840 --> 00:23:53,880
when when the clock when collaborators

652
00:23:53,880 --> 00:23:55,320
are you know reading and writing from

653
00:23:55,320 --> 00:23:56,760
documents and generating these diffs

654
00:23:56,760 --> 00:23:59,159
these disks are encrypted distributed

655
00:23:59,159 --> 00:24:01,140
out to all the clients and the clients

656
00:24:01,140 --> 00:24:03,000
are guaranteed to eventually see the

657
00:24:03,000 --> 00:24:04,260
same data

658
00:24:04,260 --> 00:24:06,419
and so what we can support here is

659
00:24:06,419 --> 00:24:08,400
bi-directional end-to-end encrypted

660
00:24:08,400 --> 00:24:10,320
real-time communication

661
00:24:10,320 --> 00:24:13,200
and so application encrypted live

662
00:24:13,200 --> 00:24:14,700
collaboration and traditional apps

663
00:24:14,700 --> 00:24:16,799
really only needs an ephemeral layer

664
00:24:16,799 --> 00:24:19,140
sorry ephemeral Keys like per

665
00:24:19,140 --> 00:24:20,700
collaboration device

666
00:24:20,700 --> 00:24:22,559
and per collab live collaboration

667
00:24:22,559 --> 00:24:24,780
session so live collaboration for

668
00:24:24,780 --> 00:24:26,340
traditional applications can be pretty

669
00:24:26,340 --> 00:24:29,039
easily supported as well and this also

670
00:24:29,039 --> 00:24:31,260
has the advantage of protecting user

671
00:24:31,260 --> 00:24:33,299
data from leaking into caches you know

672
00:24:33,299 --> 00:24:35,880
often used to support live collaborate

673
00:24:35,880 --> 00:24:38,960
live collaboration

674
00:24:40,260 --> 00:24:42,960
okay so we talked about bi-directional

675
00:24:42,960 --> 00:24:44,640
unidirectional real-time communication

676
00:24:44,640 --> 00:24:46,799
what about like data changes right

677
00:24:46,799 --> 00:24:48,780
oftentimes your back-end Engineers will

678
00:24:48,780 --> 00:24:50,340
say like well this data schema doesn't

679
00:24:50,340 --> 00:24:52,080
work anymore we need to make some

680
00:24:52,080 --> 00:24:54,600
updates but you don't have access to the

681
00:24:54,600 --> 00:24:56,280
content not only do you don't have

682
00:24:56,280 --> 00:24:58,200
access to the content you have no

683
00:24:58,200 --> 00:24:59,580
control over when a client will come

684
00:24:59,580 --> 00:25:01,559
back online to actually perform the data

685
00:25:01,559 --> 00:25:03,840
upgrade right as a back-end engineer if

686
00:25:03,840 --> 00:25:05,520
I'm on my database run a data migration

687
00:25:05,520 --> 00:25:07,860
great I can do that but I can't tell a

688
00:25:07,860 --> 00:25:10,080
customer to come online and say hey we

689
00:25:10,080 --> 00:25:11,640
need your device to come online so we

690
00:25:11,640 --> 00:25:13,620
can run this data migration so we can

691
00:25:13,620 --> 00:25:15,840
like support you know support you in the

692
00:25:15,840 --> 00:25:17,340
future that's just not acceptable

693
00:25:17,340 --> 00:25:19,320
imagine trying to call you know if

694
00:25:19,320 --> 00:25:20,640
you're a consumer application trying to

695
00:25:20,640 --> 00:25:22,380
call a billion customers it's just it's

696
00:25:22,380 --> 00:25:24,419
not going to work

697
00:25:24,419 --> 00:25:28,320
so what we can do here is for like the

698
00:25:28,320 --> 00:25:30,059
mission log example we can maybe build

699
00:25:30,059 --> 00:25:31,380
like an initial version of this Mission

700
00:25:31,380 --> 00:25:33,539
Log but let's say Mission Control wants

701
00:25:33,539 --> 00:25:35,279
to update the schema to clarify like the

702
00:25:35,279 --> 00:25:37,740
time is UTC they want to add audio you

703
00:25:37,740 --> 00:25:38,940
know recording the planet information

704
00:25:38,940 --> 00:25:40,740
just like they're just trying to add

705
00:25:40,740 --> 00:25:43,020
things to it because you know ski must

706
00:25:43,020 --> 00:25:44,340
change over time

707
00:25:44,340 --> 00:25:45,900
I think unfortunately the captain and

708
00:25:45,900 --> 00:25:47,100
the crew have disappeared into a

709
00:25:47,100 --> 00:25:48,299
wormhole and we have no idea when

710
00:25:48,299 --> 00:25:49,740
they're going to come back

711
00:25:49,740 --> 00:25:52,140
but Mission Control Engineers are just

712
00:25:52,140 --> 00:25:53,580
like well we have to keep moving on we

713
00:25:53,580 --> 00:25:54,779
have to keep building

714
00:25:54,779 --> 00:25:56,279
and so they want to make sure we have

715
00:25:56,279 --> 00:25:57,840
both forwards and backwards

716
00:25:57,840 --> 00:26:00,179
compatibility and actually we take a we

717
00:26:00,179 --> 00:26:01,980
take a lesson out from you know the SRE

718
00:26:01,980 --> 00:26:03,840
playbooks and infrastructure engineering

719
00:26:03,840 --> 00:26:07,140
uh protobots which are often often

720
00:26:07,140 --> 00:26:09,299
related to you know grpc or internal

721
00:26:09,299 --> 00:26:11,159
service communication and we can

722
00:26:11,159 --> 00:26:14,100
actually use protobufs to perform you

723
00:26:14,100 --> 00:26:15,960
know to allow for this backwards and

724
00:26:15,960 --> 00:26:18,419
forwards sorry excuse me forwards and

725
00:26:18,419 --> 00:26:20,520
backwards compatibility

726
00:26:20,520 --> 00:26:23,460
and so the way this happens is that

727
00:26:23,460 --> 00:26:25,260
protobufs actually will Auto generate

728
00:26:25,260 --> 00:26:26,580
code for serialization and

729
00:26:26,580 --> 00:26:28,620
deserialization and you can say like why

730
00:26:28,620 --> 00:26:30,480
not just use Json it's been around for a

731
00:26:30,480 --> 00:26:32,640
while supported everywhere so you can

732
00:26:32,640 --> 00:26:34,620
imagine like if we're making so many

733
00:26:34,620 --> 00:26:36,299
different schema changes over time

734
00:26:36,299 --> 00:26:37,799
you're going to have a bunch of these if

735
00:26:37,799 --> 00:26:39,659
statements or case switches about you

736
00:26:39,659 --> 00:26:41,100
know version one this is the schema

737
00:26:41,100 --> 00:26:43,020
version two this is the schema and that

738
00:26:43,020 --> 00:26:44,940
requires humans getting it right and we

739
00:26:44,940 --> 00:26:46,440
know how that can happen especially over

740
00:26:46,440 --> 00:26:47,760
time if we're talking about years and

741
00:26:47,760 --> 00:26:49,980
years of data and data schema changes

742
00:26:49,980 --> 00:26:51,900
but the nice thing about protobuf is

743
00:26:51,900 --> 00:26:53,340
that it's self-documenting you get

744
00:26:53,340 --> 00:26:55,140
exactly what you get exactly what you

745
00:26:55,140 --> 00:26:56,840
see you know what fields are deprecated

746
00:26:56,840 --> 00:26:58,919
and the serialization and

747
00:26:58,919 --> 00:27:01,200
deserialization is auto-generated by the

748
00:27:01,200 --> 00:27:03,179
protocol itself so you never have to

749
00:27:03,179 --> 00:27:06,779
worry about your spec being out of date

750
00:27:06,779 --> 00:27:09,120
it also has a nice Advantage is that

751
00:27:09,120 --> 00:27:11,039
it's a binary serialization format so

752
00:27:11,039 --> 00:27:13,020
it's a lot more efficient than Json but

753
00:27:13,020 --> 00:27:16,220
that's just a nice slight advantage

754
00:27:16,440 --> 00:27:18,900
great so another thing about building

755
00:27:18,900 --> 00:27:20,340
you know production grade applications

756
00:27:20,340 --> 00:27:23,039
is your users or your engineers want to

757
00:27:23,039 --> 00:27:24,840
be able to debug and you know observe

758
00:27:24,840 --> 00:27:27,659
user behavior and be able to fix issues

759
00:27:27,659 --> 00:27:30,240
at the end of the day right traditional

760
00:27:30,240 --> 00:27:31,919
clients find monitoring like such as

761
00:27:31,919 --> 00:27:34,200
recession replay or user monitoring can

762
00:27:34,200 --> 00:27:37,919
leak user data or data about the user

763
00:27:37,919 --> 00:27:40,080
so what can we do here right we can see

764
00:27:40,080 --> 00:27:42,659
an example of this is like some some you

765
00:27:42,659 --> 00:27:44,580
know product that offers session

766
00:27:44,580 --> 00:27:46,200
monitoring right the user is clicking

767
00:27:46,200 --> 00:27:48,480
around they're maybe adding products to

768
00:27:48,480 --> 00:27:50,700
a cart they get angry but ultimately

769
00:27:50,700 --> 00:27:52,140
you're recording the user session and

770
00:27:52,140 --> 00:27:53,340
for doing that in an end-to-end

771
00:27:53,340 --> 00:27:55,980
encrypted application though it may not

772
00:27:55,980 --> 00:27:57,480
break the actual underlying

773
00:27:57,480 --> 00:27:59,220
cryptographic guarantees it really goes

774
00:27:59,220 --> 00:28:01,440
against the spirit of it and so we're

775
00:28:01,440 --> 00:28:03,179
actually very very interested in future

776
00:28:03,179 --> 00:28:05,820
work coming out of the ietf known as the

777
00:28:05,820 --> 00:28:08,460
distributed aggregation protocol and at

778
00:28:08,460 --> 00:28:09,960
a high level what this protocol allows

779
00:28:09,960 --> 00:28:13,380
you to do is send anonymized metrics

780
00:28:13,380 --> 00:28:14,460
that

781
00:28:14,460 --> 00:28:16,799
anonymized metrics to your server and

782
00:28:16,799 --> 00:28:18,299
the way they're anonymized is that

783
00:28:18,299 --> 00:28:20,400
multiple users will have to report the

784
00:28:20,400 --> 00:28:22,320
same information and once it hits a

785
00:28:22,320 --> 00:28:23,700
certain threshold you'll get that data

786
00:28:23,700 --> 00:28:25,020
so let's say you're you know you're

787
00:28:25,020 --> 00:28:26,580
seeing thousands of users run into an

788
00:28:26,580 --> 00:28:27,960
error you'll still see that information

789
00:28:27,960 --> 00:28:29,460
but you won't know anything about the

790
00:28:29,460 --> 00:28:31,620
end user which is great

791
00:28:31,620 --> 00:28:33,779
but right now as we're still exploring

792
00:28:33,779 --> 00:28:36,120
this like we really rely on heavily

793
00:28:36,120 --> 00:28:37,980
pre-production testing automated testing

794
00:28:37,980 --> 00:28:39,840
and user error reports you know probably

795
00:28:39,840 --> 00:28:43,760
the same as as many people here as well

796
00:28:44,820 --> 00:28:47,760
so even this occurs actually in the

797
00:28:47,760 --> 00:28:49,140
security space as well you say like oh

798
00:28:49,140 --> 00:28:51,419
haha like bad front-end Engineers like

799
00:28:51,419 --> 00:28:53,279
you're recording user data actually we

800
00:28:53,279 --> 00:28:54,480
have a problem with this in the security

801
00:28:54,480 --> 00:28:56,039
Community as well

802
00:28:56,039 --> 00:28:57,779
so if you look at content security

803
00:28:57,779 --> 00:28:59,940
policy trusted types it's a fairly new

804
00:28:59,940 --> 00:29:02,100
reporting it's a fairly new policy

805
00:29:02,100 --> 00:29:05,580
Beyond normal CSP trusted types was

806
00:29:05,580 --> 00:29:07,500
heavily pushed by Google and a few

807
00:29:07,500 --> 00:29:09,360
others to help protect against Dom based

808
00:29:09,360 --> 00:29:10,440
xss

809
00:29:10,440 --> 00:29:13,020
and what this does is it it looks for

810
00:29:13,020 --> 00:29:15,419
potentially unsanitized data Landing

811
00:29:15,419 --> 00:29:18,360
into into an into a bad sink

812
00:29:18,360 --> 00:29:20,640
but great I get this report I'll find my

813
00:29:20,640 --> 00:29:22,500
dom based xss I can go solve these

814
00:29:22,500 --> 00:29:24,779
issues the problem is is that this

815
00:29:24,779 --> 00:29:26,940
starts leaking user data and how does it

816
00:29:26,940 --> 00:29:28,799
do that well because it's Dom based

817
00:29:28,799 --> 00:29:31,559
access has the user input is part of is

818
00:29:31,559 --> 00:29:33,360
part of the actual like script sample

819
00:29:33,360 --> 00:29:34,860
that is sent back to your backend server

820
00:29:34,860 --> 00:29:36,539
so you can actually see an example of

821
00:29:36,539 --> 00:29:37,980
this as we were testing this in our

822
00:29:37,980 --> 00:29:39,600
staging environment if you look at the

823
00:29:39,600 --> 00:29:41,039
script sample towards the bottom right

824
00:29:41,039 --> 00:29:42,840
above the black box you'll see Dom

825
00:29:42,840 --> 00:29:44,580
parser error parts from string and then

826
00:29:44,580 --> 00:29:46,980
you can see user data saying heya

827
00:29:46,980 --> 00:29:48,960
so there's not even a way to turn this

828
00:29:48,960 --> 00:29:51,539
off like so really the solution we have

829
00:29:51,539 --> 00:29:54,840
is we can either look for Dom based xss

830
00:29:54,840 --> 00:29:57,779
and have this reporting enabled or we

831
00:29:57,779 --> 00:29:59,220
literally have to fly blind like we've

832
00:29:59,220 --> 00:30:01,320
been doing for the last few years and so

833
00:30:01,320 --> 00:30:03,120
this isn't a great example either so

834
00:30:03,120 --> 00:30:05,100
it's not just to say that like we have

835
00:30:05,100 --> 00:30:06,360
issues in front end tools we actually

836
00:30:06,360 --> 00:30:07,980
have a problem with these privacy issues

837
00:30:07,980 --> 00:30:10,140
in in the security Community as well in

838
00:30:10,140 --> 00:30:13,039
the apps like community

839
00:30:14,159 --> 00:30:16,980
so we talked a lot here about a lot of

840
00:30:16,980 --> 00:30:19,140
things Keys a lot you know a ton of a

841
00:30:19,140 --> 00:30:20,220
ton of work

842
00:30:20,220 --> 00:30:21,899
well we hope to have accomplished here

843
00:30:21,899 --> 00:30:23,039
is that clarifying A lot of

844
00:30:23,039 --> 00:30:24,779
misconceptions around the limitations of

845
00:30:24,779 --> 00:30:26,760
end-to-end encrypted applications right

846
00:30:26,760 --> 00:30:28,679
authentication password recovery

847
00:30:28,679 --> 00:30:31,440
efficient data sharing you know

848
00:30:31,440 --> 00:30:33,000
real-time Communications over both

849
00:30:33,000 --> 00:30:34,559
unidirectional and bi-directional

850
00:30:34,559 --> 00:30:36,720
channels we also talked about where it

851
00:30:36,720 --> 00:30:38,399
does actually get challenging from our

852
00:30:38,399 --> 00:30:39,840
experience right data migrations

853
00:30:39,840 --> 00:30:41,340
observability

854
00:30:41,340 --> 00:30:43,320
but we hope that you know if you're

855
00:30:43,320 --> 00:30:44,760
building more traditional applications

856
00:30:44,760 --> 00:30:46,919
what hopefully you can take away from

857
00:30:46,919 --> 00:30:48,480
this talk and take back to your own

858
00:30:48,480 --> 00:30:50,940
organizations you know is using SRP or

859
00:30:50,940 --> 00:30:52,860
opaque to prevent you know password

860
00:30:52,860 --> 00:30:54,720
leakage and actually protect against

861
00:30:54,720 --> 00:30:56,700
phishing you don't need to you know buy

862
00:30:56,700 --> 00:30:58,679
into the hype of you know Hardware Keys

863
00:30:58,679 --> 00:31:00,539
they're great they do their job but

864
00:31:00,539 --> 00:31:02,159
we've had this protocol for you know 20

865
00:31:02,159 --> 00:31:04,679
years to deal with this issue

866
00:31:04,679 --> 00:31:06,539
application layer encryption at trust

867
00:31:06,539 --> 00:31:08,039
boundaries to prevent data leakage

868
00:31:08,039 --> 00:31:10,380
though you know it can happen at you

869
00:31:10,380 --> 00:31:11,580
know people have talked about it a lot

870
00:31:11,580 --> 00:31:14,220
we do think it's fairly fairly powerful

871
00:31:14,220 --> 00:31:15,779
and you know privacy preserving

872
00:31:15,779 --> 00:31:17,520
observability like we talked about the

873
00:31:17,520 --> 00:31:19,260
distribution aggregation protocol coming

874
00:31:19,260 --> 00:31:21,600
out of the ietf to improve user privacy

875
00:31:21,600 --> 00:31:23,279
doesn't require end-to-end encryption

876
00:31:23,279 --> 00:31:25,080
but still allows you to collect this

877
00:31:25,080 --> 00:31:26,760
data in a you know

878
00:31:26,760 --> 00:31:30,860
more user friendly and private way

879
00:31:31,500 --> 00:31:32,820
um with that being said we just wanted

880
00:31:32,820 --> 00:31:34,320
to give us a couple special shout outs

881
00:31:34,320 --> 00:31:37,380
Zach uh who you know was that skiff he

882
00:31:37,380 --> 00:31:38,520
made a large amount of the crypto

883
00:31:38,520 --> 00:31:40,020
engineering contributions that we talked

884
00:31:40,020 --> 00:31:42,120
about here co-founders who built a lot

885
00:31:42,120 --> 00:31:44,039
Andrew and Jason who built a lot of the

886
00:31:44,039 --> 00:31:46,080
original implementations

887
00:31:46,080 --> 00:31:47,760
um our entire team we're a small team of

888
00:31:47,760 --> 00:31:49,500
you know 15 people

889
00:31:49,500 --> 00:31:50,820
um and we're presenting here today

890
00:31:50,820 --> 00:31:52,559
because of a lot of their work and

891
00:31:52,559 --> 00:31:54,600
contributions to to what we've been able

892
00:31:54,600 --> 00:31:57,000
to do and you know we are standing on

893
00:31:57,000 --> 00:31:58,440
the Giants we are standing on the

894
00:31:58,440 --> 00:31:59,700
shoulders of giants both like

895
00:31:59,700 --> 00:32:01,260
cryptographers a lot of these protocols

896
00:32:01,260 --> 00:32:03,179
that have been built over the last 20 20

897
00:32:03,179 --> 00:32:05,460
years and obviously a shout out to all

898
00:32:05,460 --> 00:32:07,140
the b-sides volunteers and organizers

899
00:32:07,140 --> 00:32:08,640
because we wouldn't be here to be able

900
00:32:08,640 --> 00:32:11,220
to talk about this without them

901
00:32:11,220 --> 00:32:14,399
awesome so we talked a lot you might

902
00:32:14,399 --> 00:32:15,960
have questions happy to take those now

903
00:32:15,960 --> 00:32:18,240
we have about eight minutes six seven

904
00:32:18,240 --> 00:32:19,500
minutes for questions

905
00:32:19,500 --> 00:32:22,919
so uh feel free to raise your hand and

906
00:32:22,919 --> 00:32:24,840
I'll try to see you in the

907
00:32:24,840 --> 00:32:27,320
light

908
00:32:41,039 --> 00:32:44,899
yeah for sure for sure

909
00:33:07,260 --> 00:33:10,080
yeah really good question so yeah I'll

910
00:33:10,080 --> 00:33:12,419
repeat the question the question is um

911
00:33:12,419 --> 00:33:14,100
sort of a clarification on how the

912
00:33:14,100 --> 00:33:16,380
folder sharing is working

913
00:33:16,380 --> 00:33:19,679
um sort of asking like I use uh about

914
00:33:19,679 --> 00:33:22,260
how you use your users key to get access

915
00:33:22,260 --> 00:33:24,600
to the folder and then also let's say

916
00:33:24,600 --> 00:33:28,320
that the access was revoked uh how what

917
00:33:28,320 --> 00:33:30,840
sort of would you rotate

918
00:33:30,840 --> 00:33:33,480
yeah so the way this will work uh

919
00:33:33,480 --> 00:33:35,580
there's kind of a Nuance here that that

920
00:33:35,580 --> 00:33:38,159
we um simplified for the purpose of the

921
00:33:38,159 --> 00:33:39,659
presentation but I can explain it in

922
00:33:39,659 --> 00:33:40,620
more detail

923
00:33:40,620 --> 00:33:42,899
so a folder kind of has this hybrid

924
00:33:42,899 --> 00:33:45,059
structure at least at skiff where it

925
00:33:45,059 --> 00:33:47,340
kind of has this like asymmetric key

926
00:33:47,340 --> 00:33:49,500
pair where it almost acts like a user

927
00:33:49,500 --> 00:33:51,659
which was the analogy I was making but

928
00:33:51,659 --> 00:33:54,059
it also can sort of act like a document

929
00:33:54,059 --> 00:33:57,240
so users can be shared on a folder a

930
00:33:57,240 --> 00:34:00,059
folder actually has its own data key and

931
00:34:00,059 --> 00:34:03,360
the data key it exists alongside this

932
00:34:03,360 --> 00:34:06,480
asymmetric key pair that a user sorry a

933
00:34:06,480 --> 00:34:08,040
folder has where it can kind of act like

934
00:34:08,040 --> 00:34:11,580
a user and have documents underneath it

935
00:34:11,580 --> 00:34:13,440
so that that maybe answers like the

936
00:34:13,440 --> 00:34:14,699
first part of your question like that's

937
00:34:14,699 --> 00:34:16,800
how you kind of are shared as a user on

938
00:34:16,800 --> 00:34:18,418
a folder

939
00:34:18,418 --> 00:34:19,918
um and then the second part of the

940
00:34:19,918 --> 00:34:23,460
question was key rotation right so let's

941
00:34:23,460 --> 00:34:26,460
say a user is unshared from a folder

942
00:34:26,460 --> 00:34:29,099
what ends up happening

943
00:34:29,099 --> 00:34:31,619
um so one really simple way to do this

944
00:34:31,619 --> 00:34:33,599
is to

945
00:34:33,599 --> 00:34:36,659
sort of re-encrypt the entire tree uh

946
00:34:36,659 --> 00:34:38,520
that that's not very efficient

947
00:34:38,520 --> 00:34:41,219
um so initial do you know what our

948
00:34:41,219 --> 00:34:43,199
approach is yeah

949
00:34:43,199 --> 00:34:46,139
so the the what we're comparing here

950
00:34:46,139 --> 00:34:47,699
against is traditional applications

951
00:34:47,699 --> 00:34:50,639
right versus in this context key

952
00:34:50,639 --> 00:34:52,020
rotation

953
00:34:52,020 --> 00:34:54,659
what we can actually do is just pretty

954
00:34:54,659 --> 00:34:56,520
much use server side controls here

955
00:34:56,520 --> 00:34:58,440
because what we can say is that the user

956
00:34:58,440 --> 00:35:00,480
is unshared on that document we can

957
00:35:00,480 --> 00:35:02,339
simply say they no longer access the

958
00:35:02,339 --> 00:35:04,440
ciphertext so though cryptographically

959
00:35:04,440 --> 00:35:07,020
there's an issue ultimately if the user

960
00:35:07,020 --> 00:35:09,000
doesn't have access to that Cipher text

961
00:35:09,000 --> 00:35:11,099
they don't have access to the plain text

962
00:35:11,099 --> 00:35:12,720
and you could argue like well what if

963
00:35:12,720 --> 00:35:13,980
they have access to the old type of text

964
00:35:13,980 --> 00:35:16,079
well that's no different than a user in

965
00:35:16,079 --> 00:35:17,400
a traditional application copying and

966
00:35:17,400 --> 00:35:19,320
pasting the dot somewhere else so we

967
00:35:19,320 --> 00:35:21,900
really have to care about can we protect

968
00:35:21,900 --> 00:35:24,480
the document against future changes and

969
00:35:24,480 --> 00:35:26,400
that's the real question or the

970
00:35:26,400 --> 00:35:28,260
confidentiality of that document for for

971
00:35:28,260 --> 00:35:30,780
like with future changes and so we can

972
00:35:30,780 --> 00:35:32,640
do is apply server side control and then

973
00:35:32,640 --> 00:35:34,920
look at like okay if we really need to

974
00:35:34,920 --> 00:35:37,200
re-encrypt this this specific document

975
00:35:37,200 --> 00:35:39,780
like allowing the user to do that but in

976
00:35:39,780 --> 00:35:41,640
most cases the server-side access

977
00:35:41,640 --> 00:35:45,020
control is is sufficient

978
00:35:55,619 --> 00:35:58,680
yeah so my question is I use a password

979
00:35:58,680 --> 00:36:01,320
and then I generate a

980
00:36:01,320 --> 00:36:05,480
I think an encryption right if I use it

981
00:36:05,880 --> 00:36:06,960
okay

982
00:36:06,960 --> 00:36:09,540
no there's um there's a there's a couple

983
00:36:09,540 --> 00:36:11,040
of salts in secret like server side

984
00:36:11,040 --> 00:36:14,460
Secrets involved uh sorry not server

985
00:36:14,460 --> 00:36:15,780
side but yeah there's halting involved

986
00:36:15,780 --> 00:36:18,060
and whatnot so you won't client-side so

987
00:36:18,060 --> 00:36:20,160
the client has to remember uh so the

988
00:36:20,160 --> 00:36:22,380
salts are considered public they're not

989
00:36:22,380 --> 00:36:24,300
they don't need to be

990
00:36:24,300 --> 00:36:26,220
um you can't so it's actually what one

991
00:36:26,220 --> 00:36:28,020
password does is they do they don't

992
00:36:28,020 --> 00:36:29,760
store the salt to make this a lot hard

993
00:36:29,760 --> 00:36:31,320
to make this brute forcing a lot harder

994
00:36:31,320 --> 00:36:33,720
but technically to keep the protocol

995
00:36:33,720 --> 00:36:35,760
secure you can store the password in

996
00:36:35,760 --> 00:36:37,380
your own database and the client can

997
00:36:37,380 --> 00:36:38,880
query it and that's like perfectly

998
00:36:38,880 --> 00:36:42,480
acceptable the salt the salt okay yeah

999
00:36:42,480 --> 00:36:45,420
um the other thing that happens here is

1000
00:36:45,420 --> 00:36:47,940
that what I didn't go into is that the

1001
00:36:47,940 --> 00:36:50,280
SRP protocol also takes you can take

1002
00:36:50,280 --> 00:36:51,780
into account

1003
00:36:51,780 --> 00:36:53,339
the

1004
00:36:53,339 --> 00:36:54,240
um

1005
00:36:54,240 --> 00:36:57,540
the bootstrapping of that on the SRP

1006
00:36:57,540 --> 00:36:59,099
protocol that actually prevents like the

1007
00:36:59,099 --> 00:37:01,380
fishing so even if a user typed in it's

1008
00:37:01,380 --> 00:37:03,440
like their password somewhere else

1009
00:37:03,440 --> 00:37:06,240
the assuming they weren't just capturing

1010
00:37:06,240 --> 00:37:07,800
the password which would break you know

1011
00:37:07,800 --> 00:37:09,359
if that can't do anything about but if

1012
00:37:09,359 --> 00:37:10,740
they were also running SRP on this

1013
00:37:10,740 --> 00:37:12,900
phishing website you couldn't use that

1014
00:37:12,900 --> 00:37:16,800
same uh response to then log into like

1015
00:37:16,800 --> 00:37:18,839
you know Skip for example so it does

1016
00:37:18,839 --> 00:37:20,400
protect against that when it doesn't

1017
00:37:20,400 --> 00:37:22,500
protect against is like yeah the pat

1018
00:37:22,500 --> 00:37:24,000
like the password leaks somewhere else

1019
00:37:24,000 --> 00:37:25,859
and somebody typed it in again like

1020
00:37:25,859 --> 00:37:28,020
we're hosed either way like

1021
00:37:28,020 --> 00:37:30,540
and so our comparison is always are we

1022
00:37:30,540 --> 00:37:32,460
do we have the equivalent security

1023
00:37:32,460 --> 00:37:33,960
considerations in a traditional

1024
00:37:33,960 --> 00:37:36,300
application or do we exceed them right

1025
00:37:36,300 --> 00:37:38,160
we should never be worse so in some

1026
00:37:38,160 --> 00:37:39,960
cases we'll actually be equivalent like

1027
00:37:39,960 --> 00:37:42,060
the security model is no different but

1028
00:37:42,060 --> 00:37:44,040
what we're hoping is I don't know most

1029
00:37:44,040 --> 00:37:46,500
cases we're actually better

1030
00:37:46,500 --> 00:37:48,660
okay I mean

1031
00:37:48,660 --> 00:37:50,760
because you said don't use physical

1032
00:37:50,760 --> 00:37:53,099
fight or two keys and I think they have

1033
00:37:53,099 --> 00:37:54,599
better protection than all of this right

1034
00:37:54,599 --> 00:37:57,119
yeah so we offer MFA

1035
00:37:57,119 --> 00:37:59,099
um MFA is possible right because you can

1036
00:37:59,099 --> 00:38:00,240
still

1037
00:38:00,240 --> 00:38:03,720
you could still basically don't

1038
00:38:03,720 --> 00:38:06,960
don't respond on the SRP protocol until

1039
00:38:06,960 --> 00:38:08,820
like the MFA challenge was completed so

1040
00:38:08,820 --> 00:38:10,800
you can still do MFA as much as you want

1041
00:38:10,800 --> 00:38:13,020
like skiff we supported web offend you

1042
00:38:13,020 --> 00:38:14,520
can support all these keys so you can do

1043
00:38:14,520 --> 00:38:17,099
all of that like none of that is uh

1044
00:38:17,099 --> 00:38:21,320
prevented in these systems oh okay

1045
00:38:25,140 --> 00:38:27,240
all right yeah you can just say it you

1046
00:38:27,240 --> 00:38:30,979
just say it yeah that's fine

1047
00:38:33,180 --> 00:38:36,180
okay

1048
00:38:39,000 --> 00:38:41,400
yeah that's a great question

1049
00:38:41,400 --> 00:38:43,140
um we haven't built that it's something

1050
00:38:43,140 --> 00:38:45,119
we're exploring oh sorry the question

1051
00:38:45,119 --> 00:38:47,280
was can this scheme be used to support

1052
00:38:47,280 --> 00:38:49,740
saml SSO kind of these other Federated

1053
00:38:49,740 --> 00:38:52,140
authenticated approaches the answer is

1054
00:38:52,140 --> 00:38:54,359
yes we're looking into it but we're

1055
00:38:54,359 --> 00:38:55,980
really inspired by what one password

1056
00:38:55,980 --> 00:38:58,859
recently launched with their kind of uh

1057
00:38:58,859 --> 00:39:02,220
you know Federated identity uh you know

1058
00:39:02,220 --> 00:39:04,320
integrating with basically OCTA and that

1059
00:39:04,320 --> 00:39:06,660
is you know they they run a very very

1060
00:39:06,660 --> 00:39:09,000
similar authentication process to this

1061
00:39:09,000 --> 00:39:10,680
um though maybe not exactly the same and

1062
00:39:10,680 --> 00:39:12,119
so we're pretty inspired that you know

1063
00:39:12,119 --> 00:39:14,579
if they can support it on a you know one

1064
00:39:14,579 --> 00:39:16,140
password with real Enterprise customers

1065
00:39:16,140 --> 00:39:18,780
using OCTA like we could we there will

1066
00:39:18,780 --> 00:39:20,579
be differences but we think it's very

1067
00:39:20,579 --> 00:39:22,380
possible they've proven it out so we're

1068
00:39:22,380 --> 00:39:23,280
not

1069
00:39:23,280 --> 00:39:24,660
um we're very optimistic that we could

1070
00:39:24,660 --> 00:39:27,500
support that in the future

1071
00:39:28,079 --> 00:39:30,079
um

1072
00:39:45,060 --> 00:39:47,400
yeah so you want to take the question

1073
00:39:47,400 --> 00:39:48,660
yeah

1074
00:39:48,660 --> 00:39:51,540
yeah so the question was

1075
00:39:51,540 --> 00:39:53,400
um we're talking about the folder

1076
00:39:53,400 --> 00:39:55,619
sharing again and and the question was

1077
00:39:55,619 --> 00:39:58,200
if we treat a use a folder like a user

1078
00:39:58,200 --> 00:40:00,540
where it has its own key pair are we

1079
00:40:00,540 --> 00:40:03,540
sharing the private key with the users

1080
00:40:03,540 --> 00:40:06,300
that have access to that folder

1081
00:40:06,300 --> 00:40:08,579
um and the answer is yes so the way it

1082
00:40:08,579 --> 00:40:11,220
works is any user that is shared on that

1083
00:40:11,220 --> 00:40:14,579
folder has access to the private key of

1084
00:40:14,579 --> 00:40:16,800
the folder and then they use that

1085
00:40:16,800 --> 00:40:19,680
private key of the folder to decrypt any

1086
00:40:19,680 --> 00:40:22,700
child documents

1087
00:40:31,400 --> 00:40:34,920
yeah so the the follow-up was what about

1088
00:40:34,920 --> 00:40:36,660
in a situation where a user has access

1089
00:40:36,660 --> 00:40:38,880
to the parent folder but does not have

1090
00:40:38,880 --> 00:40:40,680
access to we don't want them to have

1091
00:40:40,680 --> 00:40:42,960
access to the child folder So currently

1092
00:40:42,960 --> 00:40:44,820
cryptographically that's not really

1093
00:40:44,820 --> 00:40:46,560
possible to support at least in our

1094
00:40:46,560 --> 00:40:48,000
framework

1095
00:40:48,000 --> 00:40:50,820
um you may be able to support that by

1096
00:40:50,820 --> 00:40:52,800
server side controls like initial was

1097
00:40:52,800 --> 00:40:54,900
mentioning where you could just not

1098
00:40:54,900 --> 00:40:57,359
present the user the encrypted piece of

1099
00:40:57,359 --> 00:40:59,339
information but

1100
00:40:59,339 --> 00:41:00,960
um if they were pretend it's not

1101
00:41:00,960 --> 00:41:02,579
protected in like sort of an end-to-end

1102
00:41:02,579 --> 00:41:04,859
encrypted context right like if they did

1103
00:41:04,859 --> 00:41:07,560
gain access to that Cipher text for that

1104
00:41:07,560 --> 00:41:09,240
that subfolder they're not supposed to

1105
00:41:09,240 --> 00:41:10,740
have access to or that sub document that

1106
00:41:10,740 --> 00:41:11,760
you're not supposed to have access to

1107
00:41:11,760 --> 00:41:13,260
they would technically be able to

1108
00:41:13,260 --> 00:41:15,859
decrypt it

1109
00:41:17,940 --> 00:41:20,119
foreign

1110
00:41:28,740 --> 00:41:31,200
hey thanks for the great talk have you

1111
00:41:31,200 --> 00:41:32,940
put much thought into solving the

1112
00:41:32,940 --> 00:41:34,800
problem of the use meeting to trust the

1113
00:41:34,800 --> 00:41:36,180
client-side software that you're serving

1114
00:41:36,180 --> 00:41:37,440
them

1115
00:41:37,440 --> 00:41:38,940
showing that you haven't been compiled

1116
00:41:38,940 --> 00:41:40,380
or compromised into something that

1117
00:41:40,380 --> 00:41:42,300
undermine your controls

1118
00:41:42,300 --> 00:41:43,800
yeah really great question initial you

1119
00:41:43,800 --> 00:41:46,200
want to take that yeah

1120
00:41:46,200 --> 00:41:48,359
yeah this is a tough one right yeah so

1121
00:41:48,359 --> 00:41:49,980
the question is

1122
00:41:49,980 --> 00:41:50,940
um

1123
00:41:50,940 --> 00:41:54,119
basically have we thought about

1124
00:41:54,119 --> 00:41:56,099
the Integrity of our client software

1125
00:41:56,099 --> 00:41:57,599
right the client software used to

1126
00:41:57,599 --> 00:41:59,040
generate these keys and encrypt a

1127
00:41:59,040 --> 00:42:01,680
decrypt and and all that and it's tough

1128
00:42:01,680 --> 00:42:03,060
because

1129
00:42:03,060 --> 00:42:05,880
we don't really have a way

1130
00:42:05,880 --> 00:42:08,160
to assure the Integrity of the client

1131
00:42:08,160 --> 00:42:10,619
besides hashing like all the scripts

1132
00:42:10,619 --> 00:42:12,780
like through CSP and like assuring those

1133
00:42:12,780 --> 00:42:15,240
like hashes are valid or so it's a

1134
00:42:15,240 --> 00:42:17,760
little bit tough we we're thinking about

1135
00:42:17,760 --> 00:42:20,099
it more but we don't have a great

1136
00:42:20,099 --> 00:42:21,720
solution to that like you could say like

1137
00:42:21,720 --> 00:42:23,280
oh we can package it up in the desktop

1138
00:42:23,280 --> 00:42:25,619
apps and users can run it that way so

1139
00:42:25,619 --> 00:42:27,480
we're looking at stuff like that but

1140
00:42:27,480 --> 00:42:29,339
we're open to ideas I know cloudflare

1141
00:42:29,339 --> 00:42:31,140
has been working on this with I think

1142
00:42:31,140 --> 00:42:32,940
they had a partnership with WhatsApp if

1143
00:42:32,940 --> 00:42:35,339
I remember correctly to try to do better

1144
00:42:35,339 --> 00:42:36,240
um

1145
00:42:36,240 --> 00:42:38,820
our client-side app like to assure I

1146
00:42:38,820 --> 00:42:40,440
think what they did was like when

1147
00:42:40,440 --> 00:42:43,200
WhatsApp makes an update then cloudflare

1148
00:42:43,200 --> 00:42:44,940
will look at like the hash of that

1149
00:42:44,940 --> 00:42:46,079
update and make sure that it's like

1150
00:42:46,079 --> 00:42:47,760
still valid and so you kind of run into

1151
00:42:47,760 --> 00:42:50,339
like two-party computation scheme maybe

1152
00:42:50,339 --> 00:42:51,780
completely butchering that so somebody

1153
00:42:51,780 --> 00:42:55,020
can correct me but that's something I

1154
00:42:55,020 --> 00:42:56,579
think that's like the closest we can get

1155
00:42:56,579 --> 00:42:58,500
like we're just sort of reliant on you

1156
00:42:58,500 --> 00:43:00,240
know what what specs are coming out of

1157
00:43:00,240 --> 00:43:01,740
web browsers at the end of the day and

1158
00:43:01,740 --> 00:43:04,079
the closest thing I've seen is like CSP

1159
00:43:04,079 --> 00:43:07,079
and like hashing all the scripts or and

1160
00:43:07,079 --> 00:43:09,420
whatnot and like you know you can do

1161
00:43:09,420 --> 00:43:10,800
that but obviously we always have like

1162
00:43:10,800 --> 00:43:12,540
JavaScript dependency so it's like okay

1163
00:43:12,540 --> 00:43:14,400
you know it's Turtles all the way down

1164
00:43:14,400 --> 00:43:15,599
again right you're talking about supply

1165
00:43:15,599 --> 00:43:18,540
chain uh issues here that we're not

1166
00:43:18,540 --> 00:43:20,099
immune to just like any other app like

1167
00:43:20,099 --> 00:43:21,599
it's the same issues that you would have

1168
00:43:21,599 --> 00:43:23,220
in both cases

1169
00:43:23,220 --> 00:43:25,759
thank you

1170
00:43:28,020 --> 00:43:30,359
yeah we have a question up top oh okay

1171
00:43:30,359 --> 00:43:32,400
great yeah yeah that's the light is

1172
00:43:32,400 --> 00:43:34,579
there

1173
00:43:43,200 --> 00:43:45,180
you can you can talk I probably can't I

1174
00:43:45,180 --> 00:43:48,020
can't see you though that's okay

1175
00:43:49,740 --> 00:43:51,960
um there was a question on

1176
00:43:51,960 --> 00:43:56,839
key rotation on the user piece

1177
00:44:00,960 --> 00:44:03,200
is

1178
00:44:08,640 --> 00:44:11,359
it worth

1179
00:44:16,680 --> 00:44:20,399
it yeah so yeah

1180
00:44:36,180 --> 00:44:39,020
thank you

1181
00:44:40,079 --> 00:44:42,619
have access

1182
00:44:50,940 --> 00:44:53,280
yeah okay

1183
00:44:53,280 --> 00:44:55,319
um I'll take those backwards so the

1184
00:44:55,319 --> 00:44:58,440
second question was around is there a

1185
00:44:58,440 --> 00:45:00,960
way to if I have a document of a very

1186
00:45:00,960 --> 00:45:03,599
large document to selectively share just

1187
00:45:03,599 --> 00:45:05,640
parts of that document from a

1188
00:45:05,640 --> 00:45:07,800
cryptographic standpoint I I can't speak

1189
00:45:07,800 --> 00:45:09,660
to product strategy but I can say like

1190
00:45:09,660 --> 00:45:11,520
it's very possible Right all we're doing

1191
00:45:11,520 --> 00:45:13,260
is just treating these

1192
00:45:13,260 --> 00:45:15,300
this one large document that the user

1193
00:45:15,300 --> 00:45:17,099
looks at one document but treated as

1194
00:45:17,099 --> 00:45:19,020
multiple cryptographic documents right

1195
00:45:19,020 --> 00:45:20,640
and so you can just compose that and say

1196
00:45:20,640 --> 00:45:22,020
like well pages one through ten is

1197
00:45:22,020 --> 00:45:24,000
actually like one document and you know

1198
00:45:24,000 --> 00:45:26,640
11 and 13 through 13 is a separately

1199
00:45:26,640 --> 00:45:28,140
shared document and then the rest is

1200
00:45:28,140 --> 00:45:30,420
that so it's like that you could just

1201
00:45:30,420 --> 00:45:32,099
split up across multiple documents to

1202
00:45:32,099 --> 00:45:33,420
support that that

1203
00:45:33,420 --> 00:45:35,280
would be fairly straightforward you

1204
00:45:35,280 --> 00:45:37,079
would have to do a sort of work in the

1205
00:45:37,079 --> 00:45:39,119
ux to make sure like the it's pretty

1206
00:45:39,119 --> 00:45:40,740
seamless for the user but that's where

1207
00:45:40,740 --> 00:45:43,020
the complications would be

1208
00:45:43,020 --> 00:45:44,640
um and then the first question was

1209
00:45:44,640 --> 00:45:46,800
around the rotation of the data

1210
00:45:46,800 --> 00:45:49,380
encryption keys so generally we try to

1211
00:45:49,380 --> 00:45:52,800
avoid in our application to re-encrypt

1212
00:45:52,800 --> 00:45:55,200
that data like we try to avoid it as

1213
00:45:55,200 --> 00:45:57,060
much as possible because

1214
00:45:57,060 --> 00:45:59,520
the real issue becomes that if a user

1215
00:45:59,520 --> 00:46:01,920
has like a huge document and they're

1216
00:46:01,920 --> 00:46:03,240
re-encrypting

1217
00:46:03,240 --> 00:46:05,760
we have to have the client online and

1218
00:46:05,760 --> 00:46:07,319
users don't like to wait right they're

1219
00:46:07,319 --> 00:46:08,700
just going to close out the Chrome tab

1220
00:46:08,700 --> 00:46:11,160
or the browser Tab and leave or you know

1221
00:46:11,160 --> 00:46:12,420
they turn off their computer like users

1222
00:46:12,420 --> 00:46:14,359
do all sorts of you know crazy things

1223
00:46:14,359 --> 00:46:17,880
and so we try to avoid those

1224
00:46:17,880 --> 00:46:19,800
re-encryption operations as much as

1225
00:46:19,800 --> 00:46:22,079
possible there are cases where we will

1226
00:46:22,079 --> 00:46:23,640
have to go re-encrypt especially if like

1227
00:46:23,640 --> 00:46:25,260
you know the user is requesting it and

1228
00:46:25,260 --> 00:46:26,099
whatnot

1229
00:46:26,099 --> 00:46:28,500
but for small documents it's great it's

1230
00:46:28,500 --> 00:46:30,180
like super easy you do it it's fast

1231
00:46:30,180 --> 00:46:32,099
right but even with symmetric keys right

1232
00:46:32,099 --> 00:46:34,260
if I have like a zip file of like two

1233
00:46:34,260 --> 00:46:36,660
gigs right I have to read I have to

1234
00:46:36,660 --> 00:46:39,420
download that that file which is usually

1235
00:46:39,420 --> 00:46:40,560
not too pumped if you have a fast

1236
00:46:40,560 --> 00:46:42,660
internet connection re-encrypt even with

1237
00:46:42,660 --> 00:46:44,280
Modern Hardware but the problem is you

1238
00:46:44,280 --> 00:46:46,020
have to re-upload that payload and so we

1239
00:46:46,020 --> 00:46:48,260
try to avoid the the

1240
00:46:48,260 --> 00:46:50,280
re-encrypt operations as much as

1241
00:46:50,280 --> 00:46:52,319
possible right and and sort of say like

1242
00:46:52,319 --> 00:46:54,660
well if the user doesn't have access

1243
00:46:54,660 --> 00:46:56,400
you know to the cipher attacks we can

1244
00:46:56,400 --> 00:46:57,960
actually you know deploy server-side

1245
00:46:57,960 --> 00:47:00,300
controls to protect against it and we

1246
00:47:00,300 --> 00:47:01,619
can get around it we can try to get

1247
00:47:01,619 --> 00:47:04,940
around it that way in a lot of cases

1248
00:47:05,660 --> 00:47:08,040
just to add one thing

1249
00:47:08,040 --> 00:47:09,480
um we left this out of the presentation

1250
00:47:09,480 --> 00:47:11,700
but uh these are a lot of these

1251
00:47:11,700 --> 00:47:13,619
questions about the cryptography are

1252
00:47:13,619 --> 00:47:16,020
really really awesome to hear

1253
00:47:16,020 --> 00:47:17,640
um just wanted to plug that we actually

1254
00:47:17,640 --> 00:47:19,619
have a white paper on our website that

1255
00:47:19,619 --> 00:47:22,140
is sort of more of a technical paper

1256
00:47:22,140 --> 00:47:24,359
like almost like a research paper type

1257
00:47:24,359 --> 00:47:25,560
thing

1258
00:47:25,560 --> 00:47:27,180
um that you can go and read and it

1259
00:47:27,180 --> 00:47:29,280
spells out all of these operations and

1260
00:47:29,280 --> 00:47:30,960
all of the sort of things that we do at

1261
00:47:30,960 --> 00:47:33,660
skiff to encrypt data in much more

1262
00:47:33,660 --> 00:47:35,579
detail it's just really simple link

1263
00:47:35,579 --> 00:47:38,940
skiff.com white paper so if you want to

1264
00:47:38,940 --> 00:47:41,400
read that after the talk it goes into a

1265
00:47:41,400 --> 00:47:43,800
lot more detail and like sort of math

1266
00:47:43,800 --> 00:47:45,660
and cryptography detail on a lot of

1267
00:47:45,660 --> 00:47:48,020
these things

1268
00:47:49,980 --> 00:47:52,980
okay

1269
00:48:07,680 --> 00:48:10,020
right okay so the question is how do you

1270
00:48:10,020 --> 00:48:12,720
deal with data coming into the system or

1271
00:48:12,720 --> 00:48:13,859
out of the system that needs to be

1272
00:48:13,859 --> 00:48:15,540
decrypted in order to have third-party

1273
00:48:15,540 --> 00:48:17,760
interoperability especially in the cases

1274
00:48:17,760 --> 00:48:19,980
of email for example if you're sending a

1275
00:48:19,980 --> 00:48:22,260
message from skiffmail to Gmail or the

1276
00:48:22,260 --> 00:48:23,339
other way around

1277
00:48:23,339 --> 00:48:24,780
so

1278
00:48:24,780 --> 00:48:27,180
um actually what we do what what this

1279
00:48:27,180 --> 00:48:28,440
slide

1280
00:48:28,440 --> 00:48:30,180
was heavily inspired by what we do

1281
00:48:30,180 --> 00:48:31,619
actually do at skiff

1282
00:48:31,619 --> 00:48:33,359
um and in these cases what we do is a

1283
00:48:33,359 --> 00:48:35,400
user is attempting to send to an

1284
00:48:35,400 --> 00:48:37,079
external address that is not in skip

1285
00:48:37,079 --> 00:48:38,400
systems you know whether it's a

1286
00:48:38,400 --> 00:48:41,400
skiff.com address or a custom domain we

1287
00:48:41,400 --> 00:48:43,619
actually have the user encrypt it with

1288
00:48:43,619 --> 00:48:45,720
this special like encryption users keys

1289
00:48:45,720 --> 00:48:48,060
or decryption users keys and so this way

1290
00:48:48,060 --> 00:48:51,000
we we can we let the email go through as

1291
00:48:51,000 --> 00:48:52,859
long as possible in our system stays

1292
00:48:52,859 --> 00:48:55,200
encrypted and then only for the purposes

1293
00:48:55,200 --> 00:48:57,420
of processing that and sending it out

1294
00:48:57,420 --> 00:49:01,079
like via smgp will be decrypt and so we

1295
00:49:01,079 --> 00:49:02,579
and then and then we delete the plain

1296
00:49:02,579 --> 00:49:04,560
text copies we never store right and so

1297
00:49:04,560 --> 00:49:06,839
this is one thing we also we're hinting

1298
00:49:06,839 --> 00:49:09,359
at here but didn't explicitly say is

1299
00:49:09,359 --> 00:49:13,500
that you don't like we we do as much as

1300
00:49:13,500 --> 00:49:15,780
possible on these trust boundaries to

1301
00:49:15,780 --> 00:49:17,339
say we're only going to process this

1302
00:49:17,339 --> 00:49:18,660
data and we're not actually going to

1303
00:49:18,660 --> 00:49:20,540
store it and if we can you know

1304
00:49:20,540 --> 00:49:22,800
differentiate the storage and the

1305
00:49:22,800 --> 00:49:24,660
processing of the the plain text Data

1306
00:49:24,660 --> 00:49:27,240
you can actually still reduce a lot of

1307
00:49:27,240 --> 00:49:28,140
risk

1308
00:49:28,140 --> 00:49:30,359
um because if you're storing all the

1309
00:49:30,359 --> 00:49:31,800
data that

1310
00:49:31,800 --> 00:49:33,300
you know you can compromise whatever

1311
00:49:33,300 --> 00:49:34,619
that data storage is and leak everything

1312
00:49:34,619 --> 00:49:36,599
but if you're processing it and that

1313
00:49:36,599 --> 00:49:39,359
processing step is compromised the only

1314
00:49:39,359 --> 00:49:42,000
thing you can access is future data that

1315
00:49:42,000 --> 00:49:43,619
is being processed in that pipeline not

1316
00:49:43,619 --> 00:49:45,180
all previous data so you can actually do

1317
00:49:45,180 --> 00:49:47,220
a lot of you get a lot of risk

1318
00:49:47,220 --> 00:49:50,060
mitigation this way too

1319
00:49:56,660 --> 00:49:59,940
yes we're looking at like supporting pgp

1320
00:49:59,940 --> 00:50:01,680
um we were using more modern Cipher

1321
00:50:01,680 --> 00:50:02,700
schemes

1322
00:50:02,700 --> 00:50:04,680
um but we think like you know we've had

1323
00:50:04,680 --> 00:50:06,240
a lot of users that are pgp users it's

1324
00:50:06,240 --> 00:50:07,440
something we're exploring haven't

1325
00:50:07,440 --> 00:50:10,260
decided on I'm just told I have to stop

1326
00:50:10,260 --> 00:50:12,780
so there's a ton of follow-up questions

1327
00:50:12,780 --> 00:50:15,420
I think there's a

1328
00:50:15,420 --> 00:50:17,400
come meet us in the hallway like I look

1329
00:50:17,400 --> 00:50:18,900
like a traffic cone so come find me it

1330
00:50:18,900 --> 00:50:20,940
should be hard to find so all right

1331
00:50:20,940 --> 00:50:22,380
thanks everyone and yeah thanks for

1332
00:50:22,380 --> 00:50:25,040
coming to the talk

