1
00:00:00,000 --> 00:00:05,549
all right all right can you guys hear me

2
00:00:01,770 --> 00:00:07,160
okay all right welcome to script all the

3
00:00:05,549 --> 00:00:09,809
things reverse all the malware an

4
00:00:07,160 --> 00:00:12,990
introduction to JSON enhanced reverse

5
00:00:09,809 --> 00:00:14,070
engineering with the aedra so before I

6
00:00:12,990 --> 00:00:16,199
get started I just want to introduce

7
00:00:14,070 --> 00:00:19,050
myself a little bit you so you guys know

8
00:00:16,199 --> 00:00:20,760
what I do I come from a computer science

9
00:00:19,050 --> 00:00:23,220
background software development as well

10
00:00:20,760 --> 00:00:26,460
I'm gonna so see it on the coal fire

11
00:00:23,220 --> 00:00:28,049
systems the federal labs team so that

12
00:00:26,460 --> 00:00:30,170
means on a day to day basis I can be

13
00:00:28,050 --> 00:00:32,820
doing any number of things ranging from

14
00:00:30,170 --> 00:00:37,579
Network or application pen testing to

15
00:00:32,820 --> 00:00:39,300
malware analysis and looking at breaches

16
00:00:37,579 --> 00:00:41,790
all right so what are we gonna cover

17
00:00:39,300 --> 00:00:43,828
today is my goal and then during this

18
00:00:41,790 --> 00:00:45,600
presentation is to take a look at a new

19
00:00:43,829 --> 00:00:47,670
tool that was released by the National

20
00:00:45,600 --> 00:00:49,620
Security Agency back in March of last

21
00:00:47,670 --> 00:00:51,629
year and kind of highlight some of the

22
00:00:49,620 --> 00:00:55,320
features that you don't see that often

23
00:00:51,629 --> 00:00:57,390
in online tutorials on how it works I

24
00:00:55,320 --> 00:00:59,219
think are a really powerful part of the

25
00:00:57,390 --> 00:01:02,399
reverse engineering process especially

26
00:00:59,219 --> 00:01:04,949
for malware analysts so I'm gonna start

27
00:01:02,399 --> 00:01:07,470
by kind of talking a little about what

28
00:01:04,949 --> 00:01:09,149
the problem is during when we do static

29
00:01:07,470 --> 00:01:10,408
malware analysis and what makes it so

30
00:01:09,150 --> 00:01:12,000
difficult I think that's important to

31
00:01:10,409 --> 00:01:15,180
understand why these tools are so

32
00:01:12,000 --> 00:01:16,890
powerful and then I'm gonna take a

33
00:01:15,180 --> 00:01:18,780
little bit of time to talk about deidre

34
00:01:16,890 --> 00:01:20,939
and some of its core features and some

35
00:01:18,780 --> 00:01:26,100
of the things that really set it apart

36
00:01:20,939 --> 00:01:28,258
from other solutions and the big part of

37
00:01:26,100 --> 00:01:29,729
this we are going to look at do a case

38
00:01:28,259 --> 00:01:32,610
study of a real piece of malware that's

39
00:01:29,729 --> 00:01:34,229
been found in the wild take a look at

40
00:01:32,610 --> 00:01:37,259
some of the things it does and ways it

41
00:01:34,229 --> 00:01:39,450
hides from analysts and then we're going

42
00:01:37,259 --> 00:01:41,640
to use Gilders features to take those

43
00:01:39,450 --> 00:01:44,970
apart undo them and learn a lot about

44
00:01:41,640 --> 00:01:48,509
what it's actually trying to do and then

45
00:01:44,970 --> 00:01:49,770
last part takeaways and I'm going to

46
00:01:48,509 --> 00:01:52,590
talk a little about next steps things

47
00:01:49,770 --> 00:01:56,310
that I'm working on that will maybe see

48
00:01:52,590 --> 00:02:00,299
you next year and then open up time for

49
00:01:56,310 --> 00:02:01,890
questions once we're done so we're going

50
00:02:00,299 --> 00:02:03,990
over there first question why is static

51
00:02:01,890 --> 00:02:05,219
analysis so hard it's by this we're

52
00:02:03,990 --> 00:02:07,770
talking about we have a piece of malware

53
00:02:05,219 --> 00:02:09,720
from an incident response or something

54
00:02:07,770 --> 00:02:10,829
like that if you're on a blue team and

55
00:02:09,720 --> 00:02:11,730
we want to take it apart one of the

56
00:02:10,830 --> 00:02:12,580
things we're gonna do is we're gonna

57
00:02:11,730 --> 00:02:15,840
look at it

58
00:02:12,580 --> 00:02:18,400
a binary level and problem with is that

59
00:02:15,840 --> 00:02:20,080
from a analysis standpoint we have a

60
00:02:18,400 --> 00:02:22,180
pretty big lack of context this is the

61
00:02:20,080 --> 00:02:24,130
key to why these things are so hard to

62
00:02:22,180 --> 00:02:27,310
take apart part of this is kind of

63
00:02:24,130 --> 00:02:29,350
inherent to any compiled code once we go

64
00:02:27,310 --> 00:02:31,000
from source code to a binary it's

65
00:02:29,350 --> 00:02:33,880
designed to be easy for a computer to

66
00:02:31,000 --> 00:02:35,050
interpret not for humans we lose a lot

67
00:02:33,880 --> 00:02:36,609
of the context that you have in source

68
00:02:35,050 --> 00:02:39,220
code things like variable names and

69
00:02:36,610 --> 00:02:41,260
function names and parameters and all

70
00:02:39,220 --> 00:02:47,410
the stuff that kind of gets stripped out

71
00:02:41,260 --> 00:02:49,090
most of the time so the job of a reverse

72
00:02:47,410 --> 00:02:52,870
engineer especially the malware world is

73
00:02:49,090 --> 00:02:54,970
to be able to go back and kind of try to

74
00:02:52,870 --> 00:02:56,230
figure out some of that context because

75
00:02:54,970 --> 00:02:58,300
that's how we tell what is this thing

76
00:02:56,230 --> 00:03:00,880
trying to do what kind of things is it

77
00:02:58,300 --> 00:03:03,820
trying to get to and that's that's

78
00:03:00,880 --> 00:03:05,590
really what we're trying to find now

79
00:03:03,820 --> 00:03:07,720
once you introduce a piece of malware

80
00:03:05,590 --> 00:03:09,070
that's actively working against you and

81
00:03:07,720 --> 00:03:12,070
it starts adding things like obfuscation

82
00:03:09,070 --> 00:03:14,799
encrypting itself encoding you know

83
00:03:12,070 --> 00:03:16,900
packing things really get crazy and

84
00:03:14,800 --> 00:03:18,790
there's a picture I think I found it's

85
00:03:16,900 --> 00:03:20,640
actually an emoji that I think

86
00:03:18,790 --> 00:03:22,840
represents a pretty accurate

87
00:03:20,640 --> 00:03:24,040
representation of an analyst when he's

88
00:03:22,840 --> 00:03:26,620
working on a particularly hard by on

89
00:03:24,040 --> 00:03:29,859
what malware there's a lot of been times

90
00:03:26,620 --> 00:03:31,360
when that's what I've looked like all

91
00:03:29,860 --> 00:03:34,510
right so on the other hand

92
00:03:31,360 --> 00:03:35,830
luckily technology had give us as if

93
00:03:34,510 --> 00:03:38,380
benefits is that we've been able to

94
00:03:35,830 --> 00:03:41,470
develop a lot of tools to make this

95
00:03:38,380 --> 00:03:44,380
process easier now in most cases this

96
00:03:41,470 --> 00:03:46,600
involves static analysis tools commonly

97
00:03:44,380 --> 00:03:48,160
heard one is called Ida some of you

98
00:03:46,600 --> 00:03:52,510
happy how many of you have actually had

99
00:03:48,160 --> 00:03:55,000
a chance to use it oh ok awesome so

100
00:03:52,510 --> 00:03:55,929
that's been the big one for people who

101
00:03:55,000 --> 00:03:58,209
are getting learning is a little bit

102
00:03:55,930 --> 00:04:01,390
there's a free version as well and then

103
00:03:58,209 --> 00:04:04,480
there's a also a decompilers another

104
00:04:01,390 --> 00:04:06,850
feature of that isn't that on but we got

105
00:04:04,480 --> 00:04:08,380
a us reverse engineers got a little bit

106
00:04:06,850 --> 00:04:11,519
of an early Christmas present last year

107
00:04:08,380 --> 00:04:14,970
in March the NSA open source deidre

108
00:04:11,519 --> 00:04:17,769
which is a open source completely free

109
00:04:14,970 --> 00:04:19,478
full-featured reverse sound and now

110
00:04:17,769 --> 00:04:23,500
reverse engineering platform for

111
00:04:19,478 --> 00:04:23,940
software and to sum it up it's pretty

112
00:04:23,500 --> 00:04:26,320
awesome

113
00:04:23,940 --> 00:04:30,040
first of all it's written in Java and C

114
00:04:26,320 --> 00:04:31,750
Plus this the B compiler is the one part

115
00:04:30,040 --> 00:04:33,820
that's really written in C++ the most of

116
00:04:31,750 --> 00:04:36,820
the rest the user interface is written

117
00:04:33,820 --> 00:04:40,000
in Java at its core it's a disassembler

118
00:04:36,820 --> 00:04:41,950
and AD compiler it supports 15 different

119
00:04:40,000 --> 00:04:45,490
architectures that's not if you include

120
00:04:41,950 --> 00:04:47,469
variants like 32 64 bit 15 different

121
00:04:45,490 --> 00:04:49,360
types of architectures and we're going

122
00:04:47,470 --> 00:04:52,510
to talk a little bit why that's so easy

123
00:04:49,360 --> 00:04:55,420
indeed draw a few slides in a few slides

124
00:04:52,510 --> 00:04:57,159
and on top of that it's also got a

125
00:04:55,420 --> 00:04:58,920
pretty robust set of analysis

126
00:04:57,160 --> 00:05:02,650
capabilities we can do things like

127
00:04:58,920 --> 00:05:05,110
detection functions in binary code we

128
00:05:02,650 --> 00:05:06,729
can do control and data flow analysis we

129
00:05:05,110 --> 00:05:08,830
can tell what functions are accessing

130
00:05:06,730 --> 00:05:11,200
what variables what focus functions are

131
00:05:08,830 --> 00:05:12,310
calling other functions things like that

132
00:05:11,200 --> 00:05:13,719
which are really useful during their

133
00:05:12,310 --> 00:05:17,470
verse engineering process and they're

134
00:05:13,720 --> 00:05:20,530
pretty critical to what we do it also

135
00:05:17,470 --> 00:05:22,870
does metadata metadata analysis as part

136
00:05:20,530 --> 00:05:26,320
of the analysis process it does all the

137
00:05:22,870 --> 00:05:28,450
things like parsing de binary headers to

138
00:05:26,320 --> 00:05:30,820
figure out a lot of different de that we

139
00:05:28,450 --> 00:05:34,150
can use to determine whether something

140
00:05:30,820 --> 00:05:35,469
is malicious or not and it also has and

141
00:05:34,150 --> 00:05:37,030
I have to admit I haven't experimented

142
00:05:35,470 --> 00:05:39,280
too much with this but it also has

143
00:05:37,030 --> 00:05:42,130
ability to function fingerprinting can

144
00:05:39,280 --> 00:05:44,020
take known signatures of known code

145
00:05:42,130 --> 00:05:46,420
blocks for example binaries from a

146
00:05:44,020 --> 00:05:49,510
certain library and it can take a

147
00:05:46,420 --> 00:05:51,730
executable you put into it and they can

148
00:05:49,510 --> 00:05:53,620
identify okay this is something from I

149
00:05:51,730 --> 00:05:54,700
don't know boost which is a library you

150
00:05:53,620 --> 00:05:56,290
know commonly use it has a bunch of

151
00:05:54,700 --> 00:05:59,860
different tools to supplement standard

152
00:05:56,290 --> 00:06:02,170
libraries on Windows or Linux and that's

153
00:05:59,860 --> 00:06:04,410
kind of like I guess I just flare it so

154
00:06:02,170 --> 00:06:06,760
it's kind of a counterpart to that and

155
00:06:04,410 --> 00:06:09,840
this is one of the really cool things it

156
00:06:06,760 --> 00:06:12,849
also has a pretty in-depth data type and

157
00:06:09,840 --> 00:06:14,469
function database has pretty much all

158
00:06:12,850 --> 00:06:15,700
the different windows API functions that

159
00:06:14,470 --> 00:06:17,830
you might use if you're doing a

160
00:06:15,700 --> 00:06:19,360
low-level Windows programming it's got

161
00:06:17,830 --> 00:06:21,669
them in there it has their names what

162
00:06:19,360 --> 00:06:23,140
kind of types they pass much like

163
00:06:21,670 --> 00:06:27,010
structures that you would use if you're

164
00:06:23,140 --> 00:06:28,450
a C programmer and it can annotate the D

165
00:06:27,010 --> 00:06:33,280
compiler output with a lot of this cool

166
00:06:28,450 --> 00:06:34,450
stuff so as far as features that really

167
00:06:33,280 --> 00:06:35,619
set it apart I think the first one I'm

168
00:06:34,450 --> 00:06:39,039
going to talk about is how it does

169
00:06:35,620 --> 00:06:39,969
analysis of code a lot of pieces of

170
00:06:39,040 --> 00:06:41,619
software that do this

171
00:06:39,969 --> 00:06:45,219
all kind of as one big monolithic

172
00:06:41,619 --> 00:06:46,779
process but Peter takes a slightly

173
00:06:45,219 --> 00:06:49,599
different approach it's completely

174
00:06:46,779 --> 00:06:51,639
modular when when you start with a

175
00:06:49,599 --> 00:06:55,058
binary it's first you start with machine

176
00:06:51,639 --> 00:06:58,869
code which is x86 machine code that will

177
00:06:55,059 --> 00:07:00,659
interpret and instead parses this into

178
00:06:58,869 --> 00:07:03,989
what's called P code this is a

179
00:07:00,659 --> 00:07:06,819
architecture agnostic language kind of

180
00:07:03,989 --> 00:07:09,128
akin to what a compiler would use for

181
00:07:06,819 --> 00:07:11,079
those you work with compiler internals

182
00:07:09,129 --> 00:07:14,409
it's really a register transfer language

183
00:07:11,079 --> 00:07:16,319
and basically this allows us to totally

184
00:07:14,409 --> 00:07:18,610
separate the CPU architecture from

185
00:07:16,319 --> 00:07:21,369
what's happening within the actual CPU

186
00:07:18,610 --> 00:07:23,619
State this is part of the reason why we

187
00:07:21,369 --> 00:07:25,479
have fit for 15 different architectures

188
00:07:23,619 --> 00:07:28,179
because we can just add a new

189
00:07:25,479 --> 00:07:30,519
architecture by basically creating a

190
00:07:28,179 --> 00:07:33,128
configuration file that defines how each

191
00:07:30,519 --> 00:07:36,309
CPU instruction changes the CPU State

192
00:07:33,129 --> 00:07:39,939
and then once we got this P code we can

193
00:07:36,309 --> 00:07:42,339
then go from there and do analysis that

194
00:07:39,939 --> 00:07:44,409
allows us to generate pseudocode not

195
00:07:42,339 --> 00:07:46,989
actual like a level above assembler

196
00:07:44,409 --> 00:07:48,308
which is makes the whole analysis

197
00:07:46,989 --> 00:07:53,378
process trying to figure out what's

198
00:07:48,309 --> 00:07:56,860
going on a lot easier and on top of all

199
00:07:53,379 --> 00:08:01,179
this we have a Java API which is perhaps

200
00:07:56,860 --> 00:08:03,369
the coolest part now I know I adapt for

201
00:08:01,179 --> 00:08:07,539
example has their Python by libraries or

202
00:08:03,369 --> 00:08:10,239
C++ cool part about this is it's on one

203
00:08:07,539 --> 00:08:12,729
level above what you see in other pieces

204
00:08:10,239 --> 00:08:14,498
of software we have the ability in the

205
00:08:12,729 --> 00:08:15,818
gauge or API to work at the level of

206
00:08:14,499 --> 00:08:17,979
okay I want to look at a certain

207
00:08:15,819 --> 00:08:19,539
function and that data once the analysis

208
00:08:17,979 --> 00:08:21,878
is once we've gone through this analysis

209
00:08:19,539 --> 00:08:24,248
process can be exposed and we can take a

210
00:08:21,879 --> 00:08:25,869
look at what's going on do some kind of

211
00:08:24,249 --> 00:08:27,939
whatever kind of analysis you want and

212
00:08:25,869 --> 00:08:31,509
then annotate your disassembly or

213
00:08:27,939 --> 00:08:33,789
decompiler output to show you what you

214
00:08:31,509 --> 00:08:36,009
found or edit it or add comments stuff

215
00:08:33,789 --> 00:08:37,779
like that so it's super powerful just

216
00:08:36,009 --> 00:08:39,219
give you an idea what it looks like this

217
00:08:37,779 --> 00:08:42,250
is an example of a couple functions I

218
00:08:39,219 --> 00:08:45,069
pulled out of to get your API this is at

219
00:08:42,250 --> 00:08:46,059
the Java level there's also a Python

220
00:08:45,069 --> 00:08:48,339
interpreter which I'll talk to you a

221
00:08:46,059 --> 00:08:50,469
little bit more in a little bit just for

222
00:08:48,339 --> 00:08:53,270
example here let me see if I can pull

223
00:08:50,470 --> 00:08:55,190
this I'll do without a pointer

224
00:08:53,270 --> 00:08:56,540
there's this is kind of the kind of

225
00:08:55,190 --> 00:08:58,490
things you'd be interacting with for

226
00:08:56,540 --> 00:09:00,800
example it has an object a class a Java

227
00:08:58,490 --> 00:09:02,149
class for a function this is a piece of

228
00:09:00,800 --> 00:09:06,770
something that you would call for

229
00:09:02,149 --> 00:09:09,830
example use an example a Windows library

230
00:09:06,770 --> 00:09:11,300
function load library for example that

231
00:09:09,830 --> 00:09:13,700
would be something that would you might

232
00:09:11,300 --> 00:09:15,380
bill timed and something like this you

233
00:09:13,700 --> 00:09:17,450
can for example look at the parameters

234
00:09:15,380 --> 00:09:20,240
it takes you can look at what functions

235
00:09:17,450 --> 00:09:22,430
call it what functions it calls we can

236
00:09:20,240 --> 00:09:24,830
even interact with the output of the

237
00:09:22,430 --> 00:09:26,719
analysis and put a comment there to say

238
00:09:24,830 --> 00:09:28,450
ok something else is going on here and

239
00:09:26,720 --> 00:09:31,100
we kind of do that whatever you want and

240
00:09:28,450 --> 00:09:34,100
for example in a CPU instruction at a

241
00:09:31,100 --> 00:09:36,740
lower level we can you know get its

242
00:09:34,100 --> 00:09:38,300
address where is it in memory we can

243
00:09:36,740 --> 00:09:40,250
figure out what instruction is next for

244
00:09:38,300 --> 00:09:41,660
example if you have a bunch of data

245
00:09:40,250 --> 00:09:42,950
that's in between two instructions it'll

246
00:09:41,660 --> 00:09:45,709
automatically skip all that and go right

247
00:09:42,950 --> 00:09:50,000
to the next one and like for example if

248
00:09:45,709 --> 00:09:51,680
an instruction takes data as input we

249
00:09:50,000 --> 00:09:53,930
can see there's a get it get input

250
00:09:51,680 --> 00:09:55,910
objects for example how many of you guys

251
00:09:53,930 --> 00:09:57,020
work with x86 on a regular basis

252
00:09:55,910 --> 00:09:59,839
assembly look at it

253
00:09:57,020 --> 00:10:01,130
ok good number them one there's an

254
00:09:59,839 --> 00:10:04,640
instruction called a push instruction

255
00:10:01,130 --> 00:10:06,860
which is used to put data onto the stack

256
00:10:04,640 --> 00:10:08,959
and generally what you do is you have

257
00:10:06,860 --> 00:10:12,610
push and then the name of a CPU register

258
00:10:08,959 --> 00:10:14,959
and using this get input objects we can

259
00:10:12,610 --> 00:10:16,339
figure out what register that is and in

260
00:10:14,959 --> 00:10:18,800
some cases even figure out what its

261
00:10:16,339 --> 00:10:20,660
value is and then there's also get

262
00:10:18,800 --> 00:10:24,740
results object which basically tells you

263
00:10:20,660 --> 00:10:26,779
what that instruction changes now to

264
00:10:24,740 --> 00:10:29,930
interact with this API you can basically

265
00:10:26,779 --> 00:10:32,029
write scripts either in Java or in

266
00:10:29,930 --> 00:10:33,410
Python using JSON which basically

267
00:10:32,029 --> 00:10:35,930
integrates with Java bytecode

268
00:10:33,410 --> 00:10:39,589
any Java library it can call it as if

269
00:10:35,930 --> 00:10:41,239
it's built-in you can see here from the

270
00:10:39,589 --> 00:10:43,940
screenshot I don't know if you can see

271
00:10:41,240 --> 00:10:46,130
there's out of the box there's more than

272
00:10:43,940 --> 00:10:48,079
200 different scripts that the NS a

273
00:10:46,130 --> 00:10:49,850
included in here these vary from

274
00:10:48,079 --> 00:10:52,000
actually useful tools to just kind of

275
00:10:49,850 --> 00:10:55,970
examples to get you started on your own

276
00:10:52,000 --> 00:10:57,529
project and normally what you do you can

277
00:10:55,970 --> 00:11:00,500
edit it directly in a piece of software

278
00:10:57,529 --> 00:11:03,290
or you can do it in equation of the

279
00:11:00,500 --> 00:11:05,180
clips so you can actually connect the

280
00:11:03,290 --> 00:11:06,449
two and be editing your script in

281
00:11:05,180 --> 00:11:08,189
eclipse and have it go back

282
00:11:06,450 --> 00:11:09,540
or Theodora which is super useful or you

283
00:11:08,190 --> 00:11:12,930
can just write it in the your own text

284
00:11:09,540 --> 00:11:14,099
editor if you want to now to run one of

285
00:11:12,930 --> 00:11:15,900
these you can also see that there's a

286
00:11:14,100 --> 00:11:17,610
column there that's mostly empty you can

287
00:11:15,900 --> 00:11:19,380
actually take get your scripts and bind

288
00:11:17,610 --> 00:11:20,430
them right in there you can bind them to

289
00:11:19,380 --> 00:11:22,620
keyboard shortcuts so if you have

290
00:11:20,430 --> 00:11:24,089
something that using a bunch you can put

291
00:11:22,620 --> 00:11:25,410
in the keyboard shortcut you want to use

292
00:11:24,090 --> 00:11:27,090
and from then on you can launch that

293
00:11:25,410 --> 00:11:30,990
script just by putting it that keyboard

294
00:11:27,090 --> 00:11:33,030
shortcut so it's pretty powerful and it

295
00:11:30,990 --> 00:11:33,960
also has I might add a if you're doing

296
00:11:33,030 --> 00:11:35,130
this and you don't want to actually

297
00:11:33,960 --> 00:11:37,470
write the script out there's also a

298
00:11:35,130 --> 00:11:39,270
full-on Python interpreter as well they

299
00:11:37,470 --> 00:11:41,820
can use it to interact with the analysis

300
00:11:39,270 --> 00:11:42,870
and results yeah it's pretty much access

301
00:11:41,820 --> 00:11:44,340
to it you can do it in the user

302
00:11:42,870 --> 00:11:48,810
interface you can do it in a script

303
00:11:44,340 --> 00:11:50,490
which is pretty awesome all right so now

304
00:11:48,810 --> 00:11:53,699
we talked a little bit on goodra and its

305
00:11:50,490 --> 00:11:55,560
features I'm getting into talking about

306
00:11:53,700 --> 00:11:58,080
spy I this is give me the subject of our

307
00:11:55,560 --> 00:11:59,310
case study really for those of you who

308
00:11:58,080 --> 00:12:02,340
don't know what it is it is a piece of

309
00:11:59,310 --> 00:12:04,500
banking malware that originated in

310
00:12:02,340 --> 00:12:06,810
Russia and I think was around 2009 is

311
00:12:04,500 --> 00:12:08,340
when I was first discovered has a lot of

312
00:12:06,810 --> 00:12:11,040
cool features if you're a cyber criminal

313
00:12:08,340 --> 00:12:13,200
I could do things like steal people's

314
00:12:11,040 --> 00:12:16,680
passwords it had a key logger in it it

315
00:12:13,200 --> 00:12:18,590
could steal inputs from web browsers it

316
00:12:16,680 --> 00:12:21,479
would actually interact directly with

317
00:12:18,590 --> 00:12:23,460
Internet Explorer and inject code into

318
00:12:21,480 --> 00:12:26,070
your webpages so that I could steal your

319
00:12:23,460 --> 00:12:27,570
banking information right off of it it

320
00:12:26,070 --> 00:12:29,190
should be it's detected and should be

321
00:12:27,570 --> 00:12:31,500
detected and pretty much any endpoint

322
00:12:29,190 --> 00:12:33,720
solution nowadays since it's pretty well

323
00:12:31,500 --> 00:12:34,980
known and well studied but it's a cool

324
00:12:33,720 --> 00:12:37,020
that's actually if you're learning want

325
00:12:34,980 --> 00:12:38,130
to get into malware analysis and reverse

326
00:12:37,020 --> 00:12:39,930
engineering it's actually a great place

327
00:12:38,130 --> 00:12:43,260
to start because it has a lot of these

328
00:12:39,930 --> 00:12:44,870
cool reverse engineering or anti reverse

329
00:12:43,260 --> 00:12:47,760
engineering techniques kind of

330
00:12:44,870 --> 00:12:49,260
obfuscation z' that are pretty common in

331
00:12:47,760 --> 00:12:51,240
the malware world but not enough to the

332
00:12:49,260 --> 00:12:54,210
point where it's really a pain in the

333
00:12:51,240 --> 00:12:55,890
butt to take it apart it's just it's I

334
00:12:54,210 --> 00:13:01,800
would like to say it's interesting but

335
00:12:55,890 --> 00:13:04,470
not too interesting so now I got this

336
00:13:01,800 --> 00:13:06,870
binary I'm gonna start and start into

337
00:13:04,470 --> 00:13:10,620
this reverse analysis process the first

338
00:13:06,870 --> 00:13:12,540
thing I'm gonna look at is look at how

339
00:13:10,620 --> 00:13:15,270
it interacts with the Windows system

340
00:13:12,540 --> 00:13:17,490
this is kind of the key if we can figure

341
00:13:15,270 --> 00:13:18,960
out how a binary interacts with Windows

342
00:13:17,490 --> 00:13:19,850
we've solved half of the problem because

343
00:13:18,960 --> 00:13:20,930
we don't have to reverse

344
00:13:19,850 --> 00:13:24,529
the window stuff we know what its gonna

345
00:13:20,930 --> 00:13:26,479
do because there's documentation so at

346
00:13:24,529 --> 00:13:27,829
that point we're gonna look at the first

347
00:13:26,480 --> 00:13:28,910
thing we do is look at the binary it's

348
00:13:27,829 --> 00:13:31,339
got some interesting data in there a

349
00:13:28,910 --> 00:13:33,860
second that get your parses out and one

350
00:13:31,339 --> 00:13:36,319
of things is import tables for those of

351
00:13:33,860 --> 00:13:38,240
you who deal with Windows internals this

352
00:13:36,319 --> 00:13:41,050
is a list of libraries and functions

353
00:13:38,240 --> 00:13:43,490
that a binary needs to you needs to use

354
00:13:41,050 --> 00:13:45,229
because Windows is changing its

355
00:13:43,490 --> 00:13:46,370
libraries all the time and changing the

356
00:13:45,230 --> 00:13:48,350
functions and how they're implemented

357
00:13:46,370 --> 00:13:50,720
where they're gonna be in memory changes

358
00:13:48,350 --> 00:13:52,009
all changes a lot so it could be one one

359
00:13:50,720 --> 00:13:52,970
time you run it if you run it two months

360
00:13:52,009 --> 00:13:55,519
later it could be totally different

361
00:13:52,970 --> 00:13:59,480
place so that guy sends the whole thing

362
00:13:55,519 --> 00:14:01,579
of dynamic library loading and the way

363
00:13:59,480 --> 00:14:03,709
Windows deals with this is it uses

364
00:14:01,579 --> 00:14:06,229
function import tables get your policies

365
00:14:03,709 --> 00:14:08,540
out and we'll tell you what Windows

366
00:14:06,230 --> 00:14:09,980
functions a binary will use I've got

367
00:14:08,540 --> 00:14:11,389
this as an example I've got a legitimate

368
00:14:09,980 --> 00:14:14,120
executable this is actually process

369
00:14:11,389 --> 00:14:15,860
Explorer it's its internals tool and I

370
00:14:14,120 --> 00:14:17,269
can see if I can see pull this up here a

371
00:14:15,860 --> 00:14:20,779
second I could pull it my mouth so I can

372
00:14:17,269 --> 00:14:21,889
point it could you guys see that okay so

373
00:14:20,779 --> 00:14:24,470
we can see that there's a bunch of

374
00:14:21,889 --> 00:14:26,120
different functions close handle create

375
00:14:24,470 --> 00:14:28,300
thread and create process a bunch of

376
00:14:26,120 --> 00:14:30,319
different stuff that it wants to use

377
00:14:28,300 --> 00:14:31,959
this is really powerful losses and

378
00:14:30,319 --> 00:14:34,250
analysts we can tell a little bit about

379
00:14:31,959 --> 00:14:37,399
what process Explorer is trying to do

380
00:14:34,250 --> 00:14:38,540
now process Explorer is I guess a fairly

381
00:14:37,399 --> 00:14:40,160
good example because it tries to do a

382
00:14:38,540 --> 00:14:42,050
lot of stuff it's pretty tightly it does

383
00:14:40,160 --> 00:14:42,889
a lot of interaction with Windows so we

384
00:14:42,050 --> 00:14:44,779
can see there's a lot of different

385
00:14:42,889 --> 00:14:45,889
functions this is just one out of four

386
00:14:44,779 --> 00:14:48,980
or five different libraries that it

387
00:14:45,889 --> 00:14:51,439
tries to use and get draw it does a lot

388
00:14:48,980 --> 00:14:52,970
of cool stuff with this information if

389
00:14:51,439 --> 00:14:54,800
we pull up the D compiler which is one

390
00:14:52,970 --> 00:14:56,660
level above the disassembly at the

391
00:14:54,800 --> 00:14:58,579
pseudo code we can see that it actually

392
00:14:56,660 --> 00:15:00,769
annotates any time we try to use for

393
00:14:58,579 --> 00:15:02,630
example in this a leave critical section

394
00:15:00,769 --> 00:15:04,490
that's in the import table it can

395
00:15:02,630 --> 00:15:06,139
identify that okay this isn't called

396
00:15:04,490 --> 00:15:07,970
leave critical section it renames it in

397
00:15:06,139 --> 00:15:09,740
the decompiler just super useful this is

398
00:15:07,970 --> 00:15:12,740
pretty close to what you'd see in NHD

399
00:15:09,740 --> 00:15:16,880
program and I don't if you can also see

400
00:15:12,740 --> 00:15:18,589
it but it also is able to interpret data

401
00:15:16,880 --> 00:15:22,069
types so for example leaf critical

402
00:15:18,589 --> 00:15:24,350
section I'll go over the mouse you can

403
00:15:22,069 --> 00:15:25,849
see that the first thing in the Windows

404
00:15:24,350 --> 00:15:27,620
documentation the first argument that it

405
00:15:25,850 --> 00:15:30,010
takes is of type LP critical section

406
00:15:27,620 --> 00:15:31,760
this is the Windows API structure and

407
00:15:30,010 --> 00:15:34,340
Diedre has

408
00:15:31,760 --> 00:15:36,439
I basically said oh yeah that must

409
00:15:34,340 --> 00:15:37,520
variable then must be this you can kind

410
00:15:36,440 --> 00:15:39,440
of see it's a little bit lost over here

411
00:15:37,520 --> 00:15:41,240
on the side you can see that variable is

412
00:15:39,440 --> 00:15:43,130
a LP critical section structure and it's

413
00:15:41,240 --> 00:15:47,120
able to put that in as an extra

414
00:15:43,130 --> 00:15:49,490
information now it's a little bit

415
00:15:47,120 --> 00:15:51,710
different if we look at that spy I this

416
00:15:49,490 --> 00:15:53,420
is what we get keep in mind I said

417
00:15:51,710 --> 00:15:56,840
earlier it does a lot of stuff it can

418
00:15:53,420 --> 00:15:58,849
interact with Internet Explorer it is

419
00:15:56,840 --> 00:16:01,490
able to do key logging a lot of things

420
00:15:58,850 --> 00:16:03,470
that it does interact with Windows but

421
00:16:01,490 --> 00:16:06,920
if we look at the list of functions that

422
00:16:03,470 --> 00:16:10,850
it imports pretty sure something's going

423
00:16:06,920 --> 00:16:13,729
on here so just to give you an example

424
00:16:10,850 --> 00:16:15,050
what that this kind of does both in the

425
00:16:13,730 --> 00:16:18,020
D compiler and to the person breeze

426
00:16:15,050 --> 00:16:21,109
reverse engineering it it's not quite as

427
00:16:18,020 --> 00:16:23,569
useful we can see here that all these

428
00:16:21,110 --> 00:16:25,340
functions that we have are just text and

429
00:16:23,570 --> 00:16:26,600
SML values they're used by addres to

430
00:16:25,340 --> 00:16:29,330
tell which functions which they're

431
00:16:26,600 --> 00:16:31,280
basically you have the fu n tells you

432
00:16:29,330 --> 00:16:34,610
that it's a function and the other

433
00:16:31,280 --> 00:16:37,750
digits are where it is in memory so we

434
00:16:34,610 --> 00:16:40,610
got to figure out what's going on here

435
00:16:37,750 --> 00:16:42,020
all right so next step is to talk I want

436
00:16:40,610 --> 00:16:44,090
to take a little quick detour to go a

437
00:16:42,020 --> 00:16:46,790
little bit more detail about how import

438
00:16:44,090 --> 00:16:49,010
Able's work because it's useful I've

439
00:16:46,790 --> 00:16:50,930
gotten here is just an example kind of

440
00:16:49,010 --> 00:16:52,550
what we're dealing with here we've got I

441
00:16:50,930 --> 00:16:55,250
kind of like to think of it like a menu

442
00:16:52,550 --> 00:16:57,130
at a restaurant we've got a list here

443
00:16:55,250 --> 00:17:00,680
this piece of software has a list

444
00:16:57,130 --> 00:17:02,960
hypothetically of software of libraries

445
00:17:00,680 --> 00:17:04,069
and functions it wants to use it doesn't

446
00:17:02,960 --> 00:17:06,170
know where they are what before it

447
00:17:04,069 --> 00:17:08,359
starts so windows when it's launching an

448
00:17:06,170 --> 00:17:09,890
application will take a look at all

449
00:17:08,359 --> 00:17:11,869
these it will load each of those

450
00:17:09,890 --> 00:17:15,380
libraries in this case it was load win32

451
00:17:11,869 --> 00:17:17,419
dll and it'll load when I net dll into

452
00:17:15,380 --> 00:17:19,280
memory and then it will go through and

453
00:17:17,420 --> 00:17:21,350
say okay where are each of these located

454
00:17:19,280 --> 00:17:24,290
so it'll say ok where's file create a

455
00:17:21,349 --> 00:17:26,899
whereas virtual protect and it'll fill

456
00:17:24,290 --> 00:17:29,980
in those addresses so now we know that

457
00:17:26,900 --> 00:17:32,240
where all the addresses are in memory

458
00:17:29,980 --> 00:17:35,480
whatever application has this import

459
00:17:32,240 --> 00:17:37,460
table can say ok we've got all these

460
00:17:35,480 --> 00:17:38,990
different things we can then access the

461
00:17:37,460 --> 00:17:41,330
function so whenever you want to call go

462
00:17:38,990 --> 00:17:43,120
create file a it goes ok we need to go

463
00:17:41,330 --> 00:17:47,590
to then use this function at 7f f

464
00:17:43,120 --> 00:17:51,489
four zeros are eight so something's

465
00:17:47,590 --> 00:17:54,549
going on here move to further on in the

466
00:17:51,490 --> 00:17:55,990
reverse engineering process we're

467
00:17:54,549 --> 00:17:56,980
looking at a little bit of function and

468
00:17:55,990 --> 00:17:58,480
there's something interesting going on

469
00:17:56,980 --> 00:18:03,789
here anybody recognize what that well

470
00:17:58,480 --> 00:18:09,730
this is happening here it's those two

471
00:18:03,789 --> 00:18:11,110
highlighted functions I have so we can

472
00:18:09,730 --> 00:18:16,210
see there's this the first highlighted

473
00:18:11,110 --> 00:18:17,649
line we can see that PC bar one is you

474
00:18:16,210 --> 00:18:19,649
can see that there's a code a pointer to

475
00:18:17,649 --> 00:18:22,178
code for those of you C programmers

476
00:18:19,649 --> 00:18:23,620
basically what's happening here is the

477
00:18:22,179 --> 00:18:27,100
result of this function that's being

478
00:18:23,620 --> 00:18:29,289
called that function 200 400 400 to 0-8

479
00:18:27,100 --> 00:18:32,350
6 is returning some kind of address of

480
00:18:29,289 --> 00:18:33,908
some function in memory is the key part

481
00:18:32,350 --> 00:18:37,209
of what gage is doing it was able to

482
00:18:33,909 --> 00:18:39,010
tell based on the fact that this PC var

483
00:18:37,210 --> 00:18:40,929
1 was used to call a function it knows

484
00:18:39,010 --> 00:18:42,549
there's a function there and then it can

485
00:18:40,929 --> 00:18:45,850
go through and say ok we need to analyze

486
00:18:42,549 --> 00:18:47,320
this like it's code and then later on we

487
00:18:45,850 --> 00:18:48,699
take the result whatever address is

488
00:18:47,320 --> 00:18:50,350
returned from this weird function we

489
00:18:48,700 --> 00:18:53,380
don't know what it does and we call it

490
00:18:50,350 --> 00:18:55,539
with the arguments that are passed so as

491
00:18:53,380 --> 00:18:57,610
reverse engineer from a Windows

492
00:18:55,539 --> 00:19:02,140
perspective we say ok this is doing some

493
00:18:57,610 --> 00:19:03,699
kind of function lookup and if we take a

494
00:19:02,140 --> 00:19:05,470
look at that first function a little bit

495
00:19:03,700 --> 00:19:09,010
deeper we go look at it in the be

496
00:19:05,470 --> 00:19:13,510
compiler we see some interesting text

497
00:19:09,010 --> 00:19:15,100
anybody want to Windows libraries hmm

498
00:19:13,510 --> 00:19:16,658
we might be getting a little bit closer

499
00:19:15,100 --> 00:19:18,340
to what we're looking for this is a big

500
00:19:16,659 --> 00:19:19,809
hint here it's trying to load these

501
00:19:18,340 --> 00:19:21,668
basically what if you go look at this

502
00:19:19,809 --> 00:19:22,960
function it's loading these things in

503
00:19:21,669 --> 00:19:25,419
the memory and doing some other stuff

504
00:19:22,960 --> 00:19:27,399
which I'll get to in a second so we know

505
00:19:25,419 --> 00:19:32,500
we're at least getting a little bit

506
00:19:27,399 --> 00:19:33,428
closer to the right track and if you

507
00:19:32,500 --> 00:19:35,289
look at these this is the

508
00:19:33,429 --> 00:19:37,059
cross-references this is the where this

509
00:19:35,289 --> 00:19:38,679
thing is used this function that we

510
00:19:37,059 --> 00:19:39,879
don't know what it does yet we can see

511
00:19:38,679 --> 00:19:42,640
that it's used in a lot of different

512
00:19:39,880 --> 00:19:44,230
places in this case 9 that tells us that

513
00:19:42,640 --> 00:19:45,700
this is kind of a framework thing it's

514
00:19:44,230 --> 00:19:49,169
using a bunch of different places it's

515
00:19:45,700 --> 00:19:51,520
probably pretty integral to how it works

516
00:19:49,169 --> 00:19:53,230
so I'm gonna skip over a little bit here

517
00:19:51,520 --> 00:19:54,490
now that we kind of got that framed if

518
00:19:53,230 --> 00:19:56,990
we've gotten this far we know where this

519
00:19:54,490 --> 00:19:58,640
is function is probably doing its

520
00:19:56,990 --> 00:19:59,960
function lookups getting the addresses

521
00:19:58,640 --> 00:20:03,289
of all these windows API functions that

522
00:19:59,960 --> 00:20:06,860
it wants to use I'm just gonna go right

523
00:20:03,289 --> 00:20:08,059
to kind of how SpyEye does its its

524
00:20:06,860 --> 00:20:09,139
function lookups and replaces this

525
00:20:08,059 --> 00:20:12,820
window function out windows

526
00:20:09,140 --> 00:20:12,820
functionality i talked about earlier so

527
00:20:14,740 --> 00:20:20,000
basically what it rolls down boils down

528
00:20:17,149 --> 00:20:21,799
to is when it was being developed what

529
00:20:20,000 --> 00:20:24,289
the SpyEye authors did is they took

530
00:20:21,799 --> 00:20:26,600
every single function name for Windows

531
00:20:24,289 --> 00:20:28,279
normally these appear in the binary you

532
00:20:26,600 --> 00:20:30,529
can actually just basically look at it

533
00:20:28,279 --> 00:20:32,630
in a hex or text editor and all those

534
00:20:30,529 --> 00:20:35,120
functions that we saw in the function

535
00:20:32,630 --> 00:20:36,529
import table will show up so as an

536
00:20:35,120 --> 00:20:38,360
analyst I can take a look at it and say

537
00:20:36,529 --> 00:20:41,750
ok yeah this is using this one I don't

538
00:20:38,360 --> 00:20:44,928
even have to decompile it so that's even

539
00:20:41,750 --> 00:20:46,669
starting out that's pretty useful but

540
00:20:44,929 --> 00:20:50,240
what SpyEye does is it hashes all these

541
00:20:46,669 --> 00:20:51,830
ahead of time so instead of seeing all

542
00:20:50,240 --> 00:20:55,130
these strings you see some if you leave

543
00:20:51,830 --> 00:20:57,408
and if you look at the D compilation you

544
00:20:55,130 --> 00:20:58,669
see a hex hexadecimal number I actually

545
00:20:57,409 --> 00:21:01,490
forgot to mention it but you can

546
00:20:58,669 --> 00:21:04,370
actually see this hash right here

547
00:21:01,490 --> 00:21:05,929
there's this 32-bit number this is the

548
00:21:04,370 --> 00:21:07,760
hash that you use is some string that's

549
00:21:05,929 --> 00:21:12,080
been hashed we're going to reverse that

550
00:21:07,760 --> 00:21:14,658
a second so what it does is the instead

551
00:21:12,080 --> 00:21:17,539
of using Windows spy I loads these

552
00:21:14,659 --> 00:21:19,039
libraries into memory itself so it uses

553
00:21:17,539 --> 00:21:20,870
an undocumented function to do this

554
00:21:19,039 --> 00:21:23,029
which actually bypasses or at least at

555
00:21:20,870 --> 00:21:27,739
the time we'd bypass a lot and a virus

556
00:21:23,029 --> 00:21:30,620
checks and basically it goes through

557
00:21:27,740 --> 00:21:31,669
each each exported function in the

558
00:21:30,620 --> 00:21:34,070
library for example if we're

559
00:21:31,669 --> 00:21:36,500
kernel32.dll we'll go through each of

560
00:21:34,070 --> 00:21:38,539
them and usually these functional cups

561
00:21:36,500 --> 00:21:40,820
are done by names so those not names are

562
00:21:38,539 --> 00:21:43,700
included in the binary and it goes

563
00:21:40,820 --> 00:21:45,918
through each one one by one and you've

564
00:21:43,700 --> 00:21:47,720
already you've supplied this lookup

565
00:21:45,919 --> 00:21:50,659
function 32-bit hashes you want to see

566
00:21:47,720 --> 00:21:52,309
it goes through and checks and hashes

567
00:21:50,659 --> 00:21:54,559
each export and function in this library

568
00:21:52,309 --> 00:21:55,070
and sees what it's matched what you've

569
00:21:54,559 --> 00:21:59,330
asked for

570
00:21:55,070 --> 00:22:01,658
and if it does it then okay figures out

571
00:21:59,330 --> 00:22:05,689
what the address is of this function and

572
00:22:01,659 --> 00:22:07,549
returns it basically for in Windows

573
00:22:05,690 --> 00:22:09,200
terms it's get praça address if you if

574
00:22:07,549 --> 00:22:10,790
then you do payload development stuff

575
00:22:09,200 --> 00:22:12,380
like that but it's

576
00:22:10,790 --> 00:22:17,690
a lot of stealthier doesn't show up in

577
00:22:12,380 --> 00:22:19,580
the binary itself and going a little bit

578
00:22:17,690 --> 00:22:20,900
further down this path eventually come

579
00:22:19,580 --> 00:22:22,280
to this hashing function which is going

580
00:22:20,900 --> 00:22:26,180
to be the key to this whole process

581
00:22:22,280 --> 00:22:28,070
going on later on so what it is it's

582
00:22:26,180 --> 00:22:30,470
actually pretty simple it's just takes

583
00:22:28,070 --> 00:22:32,480
those strings does a little bit of bit

584
00:22:30,470 --> 00:22:34,520
shifting and exclusive warring it's up

585
00:22:32,480 --> 00:22:35,810
here and see if you're interested in see

586
00:22:34,520 --> 00:22:38,139
what it does

587
00:22:35,810 --> 00:22:41,840
and from those strings that generates a

588
00:22:38,140 --> 00:22:43,370
pseudo-random not really but value

589
00:22:41,840 --> 00:22:45,889
32-bit value that it uses to identify

590
00:22:43,370 --> 00:22:48,560
this function just an example if you run

591
00:22:45,890 --> 00:22:53,530
this get hash function on load library a

592
00:22:48,560 --> 00:22:57,560
it's going to generate 0 XC 8 AC 802 6

593
00:22:53,530 --> 00:22:59,120
so if you if this malware wants to call

594
00:22:57,560 --> 00:23:00,590
it will library a you're gonna see

595
00:22:59,120 --> 00:23:07,100
instead of load library a you're gonna

596
00:23:00,590 --> 00:23:09,620
see that value so next step how do we go

597
00:23:07,100 --> 00:23:10,820
this we know we have a pretty easy to

598
00:23:09,620 --> 00:23:13,280
get a list of all the windows api

599
00:23:10,820 --> 00:23:13,760
functions that exists you can look it up

600
00:23:13,280 --> 00:23:17,030
line

601
00:23:13,760 --> 00:23:19,180
there's tons of lists of them and we

602
00:23:17,030 --> 00:23:22,010
have we know the encryption function

603
00:23:19,180 --> 00:23:25,490
what you do with passwords when you got

604
00:23:22,010 --> 00:23:26,450
this you generate a rainbow table now

605
00:23:25,490 --> 00:23:28,370
it's a little bit interesting because

606
00:23:26,450 --> 00:23:30,950
the number of different possible values

607
00:23:28,370 --> 00:23:32,570
is a lot smaller just based on the

608
00:23:30,950 --> 00:23:35,090
libraries that SpyEye uses there were

609
00:23:32,570 --> 00:23:37,100
only I think 8,000 well it's still a lot

610
00:23:35,090 --> 00:23:38,720
but there were 8,000 values so this is

611
00:23:37,100 --> 00:23:40,760
something that normally you know take

612
00:23:38,720 --> 00:23:43,160
you hours to generate on a GPU for

613
00:23:40,760 --> 00:23:44,300
passwords but since it's enough it's a

614
00:23:43,160 --> 00:23:45,800
small enough data set here it's actually

615
00:23:44,300 --> 00:23:47,360
pretty quick we can generate it on the

616
00:23:45,800 --> 00:23:49,790
fly whenever we use the function that

617
00:23:47,360 --> 00:23:52,399
we're gonna develop earlier so the next

618
00:23:49,790 --> 00:23:54,409
step of course is to write some code to

619
00:23:52,400 --> 00:23:57,260
generate this rainbow tables and when I

620
00:23:54,410 --> 00:23:58,970
was doing this analysis initially I just

621
00:23:57,260 --> 00:24:00,260
basically wrote it and see because that

622
00:23:58,970 --> 00:24:02,120
was what I was comfortable with for

623
00:24:00,260 --> 00:24:05,660
doing bitwise arithmetic which you can

624
00:24:02,120 --> 00:24:07,280
see is used in the function and just to

625
00:24:05,660 --> 00:24:09,530
show you what this does we tested it out

626
00:24:07,280 --> 00:24:11,840
just to see if this matches up kind of

627
00:24:09,530 --> 00:24:14,930
makes sense so we take the 32 bit value

628
00:24:11,840 --> 00:24:18,770
I have in this code we had from the

629
00:24:14,930 --> 00:24:22,200
earlier screenshot and I have developed

630
00:24:18,770 --> 00:24:25,000
here you can see in the command I have

631
00:24:22,200 --> 00:24:27,970
ahead of time I've got a list where's my

632
00:24:25,000 --> 00:24:29,590
bell stairs of kernel32 functions I just

633
00:24:27,970 --> 00:24:31,450
picked one so actually I forgot to

634
00:24:29,590 --> 00:24:33,010
mention earlier but this zero in this

635
00:24:31,450 --> 00:24:34,480
lookup function that's why I have tells

636
00:24:33,010 --> 00:24:36,190
what library it's fun it's just if it's

637
00:24:34,480 --> 00:24:38,409
zero it's in this library if it's one

638
00:24:36,190 --> 00:24:41,320
it's in another and in this case it's in

639
00:24:38,409 --> 00:24:44,200
kernel32.dll and ahead of time i

640
00:24:41,320 --> 00:24:46,799
generate i had basically scraped off the

641
00:24:44,200 --> 00:24:48,850
internet scraped a bunch of the list of

642
00:24:46,799 --> 00:24:50,529
functions of this library you could

643
00:24:48,850 --> 00:24:52,270
actually if you wanted to use goodra to

644
00:24:50,529 --> 00:24:54,899
generate that list as well by going

645
00:24:52,270 --> 00:24:59,110
right through the actual binary headers

646
00:24:54,899 --> 00:25:02,590
but so we got this list i then basically

647
00:24:59,110 --> 00:25:05,459
do some text processing to generate all

648
00:25:02,590 --> 00:25:08,168
these hashes for all those functions and

649
00:25:05,460 --> 00:25:10,840
basically create a mapping between those

650
00:25:08,169 --> 00:25:12,549
32 values and the names so was that and

651
00:25:10,840 --> 00:25:16,330
then i can just use grep to figure out

652
00:25:12,549 --> 00:25:17,470
okay this nine seven six a nine seven

653
00:25:16,330 --> 00:25:19,928
nine a is it in that file

654
00:25:17,470 --> 00:25:21,309
sure enough shows up we can see that it

655
00:25:19,929 --> 00:25:24,010
says the numerate time format so that's

656
00:25:21,309 --> 00:25:25,539
windows function so we know that when in

657
00:25:24,010 --> 00:25:28,059
this particular case what it's trying to

658
00:25:25,539 --> 00:25:30,549
do is trying to call the numerate time

659
00:25:28,059 --> 00:25:33,700
functions there are two numerate time

660
00:25:30,549 --> 00:25:36,129
formats sorry so we've got a pretty

661
00:25:33,700 --> 00:25:38,140
solid process here we've can go and we

662
00:25:36,130 --> 00:25:39,520
can take any one of these functions take

663
00:25:38,140 --> 00:25:42,610
that value and go look it up and figure

664
00:25:39,520 --> 00:25:45,460
out what is actually trying to do but it

665
00:25:42,610 --> 00:25:46,779
still it still addresses one problem we

666
00:25:45,460 --> 00:25:48,520
saw that earlier that it was used in

667
00:25:46,779 --> 00:25:49,659
nine different places there actually if

668
00:25:48,520 --> 00:25:51,220
you go and look at it there's a couple

669
00:25:49,659 --> 00:25:54,070
different lookups at a dozen slightly

670
00:25:51,220 --> 00:25:55,870
different ways I haven't quite gone into

671
00:25:54,070 --> 00:25:58,899
the deep enough thing to get make sure I

672
00:25:55,870 --> 00:26:00,428
had all them but that still represents a

673
00:25:58,899 --> 00:26:02,320
lot of tedious work of knowing okay

674
00:26:00,429 --> 00:26:03,700
here's the value we're talking about a

675
00:26:02,320 --> 00:26:06,549
program that may have hundreds of

676
00:26:03,700 --> 00:26:08,380
thousands of instructions it still pain

677
00:26:06,549 --> 00:26:15,190
in the butt to go do that so we need to

678
00:26:08,380 --> 00:26:16,990
automate this so all right let's see all

679
00:26:15,190 --> 00:26:18,580
right so we're going to develop an

680
00:26:16,990 --> 00:26:20,020
algorithm about this I want to preface

681
00:26:18,580 --> 00:26:21,250
this by when you're doing this kind of

682
00:26:20,020 --> 00:26:23,440
process we don't really have to think

683
00:26:21,250 --> 00:26:25,539
about this as being kind of interactive

684
00:26:23,440 --> 00:26:27,130
programming I don't know how many of you

685
00:26:25,539 --> 00:26:30,280
guys have had a chance to work with a

686
00:26:27,130 --> 00:26:32,340
system like our for data analysis or

687
00:26:30,280 --> 00:26:34,330
Python like interactively an interpreter

688
00:26:32,340 --> 00:26:35,770
but one of the key things is when you're

689
00:26:34,330 --> 00:26:37,600
working on this it's important to

690
00:26:35,770 --> 00:26:40,180
remember that what you're doing here

691
00:26:37,600 --> 00:26:41,439
doesn't have to be pretty it doesn't

692
00:26:40,180 --> 00:26:43,180
even have to be efficient it just has to

693
00:26:41,440 --> 00:26:44,500
work and usually when you're doing this

694
00:26:43,180 --> 00:26:46,330
kind of stuff it's on some kind of time

695
00:26:44,500 --> 00:26:47,980
frame so it's important not to get too

696
00:26:46,330 --> 00:26:50,889
picky about pro-quality you just need to

697
00:26:47,980 --> 00:26:52,690
make it work and it's even doubly so

698
00:26:50,890 --> 00:26:54,970
with malware because whenever you

699
00:26:52,690 --> 00:26:56,620
develop for spy I if I go and go down

700
00:26:54,970 --> 00:26:57,700
and I'll say working on configure it to

701
00:26:56,620 --> 00:26:58,750
be totally different I have to do

702
00:26:57,700 --> 00:27:00,070
something totally different so you got

703
00:26:58,750 --> 00:27:01,780
really gotta treat this as okay I'm

704
00:27:00,070 --> 00:27:04,600
doing analysis and I need to use this to

705
00:27:01,780 --> 00:27:06,280
support manual review of the code this

706
00:27:04,600 --> 00:27:08,620
just basically takes the steps that we

707
00:27:06,280 --> 00:27:11,350
would do we could do manually and just

708
00:27:08,620 --> 00:27:12,820
makes the computer even alright so

709
00:27:11,350 --> 00:27:14,350
talking about what we're gonna do here

710
00:27:12,820 --> 00:27:16,149
what we're gonna do here we're gonna

711
00:27:14,350 --> 00:27:18,070
take advantage of Windows calling

712
00:27:16,150 --> 00:27:19,540
conventions for those of you don't know

713
00:27:18,070 --> 00:27:22,899
when we saw the function with all the

714
00:27:19,540 --> 00:27:25,659
parameters when there when a function is

715
00:27:22,900 --> 00:27:27,010
called all of its arguments that you

716
00:27:25,660 --> 00:27:28,840
want to pass in this function are pushed

717
00:27:27,010 --> 00:27:30,820
on to the stack in Reverse so we had

718
00:27:28,840 --> 00:27:32,530
argument one two and three what would

719
00:27:30,820 --> 00:27:34,120
happen is that in the instructions we

720
00:27:32,530 --> 00:27:35,830
would see three push instructions we

721
00:27:34,120 --> 00:27:38,500
push the third argument we push the

722
00:27:35,830 --> 00:27:39,580
second one we push the first one on the

723
00:27:38,500 --> 00:27:42,610
stack and then there's a call which

724
00:27:39,580 --> 00:27:46,990
actually moves the program counter to

725
00:27:42,610 --> 00:27:48,669
the routine now we can take advantage of

726
00:27:46,990 --> 00:27:49,900
this when we're going through once we've

727
00:27:48,670 --> 00:27:51,550
done the analysis and gidran it

728
00:27:49,900 --> 00:27:54,730
generates our disassembly and decompiler

729
00:27:51,550 --> 00:27:57,340
we can just basically use those push

730
00:27:54,730 --> 00:27:59,110
instructions to find those values so we

731
00:27:57,340 --> 00:28:00,490
do we've generated we generate our

732
00:27:59,110 --> 00:28:02,979
rainbow tables ahead of time it only

733
00:28:00,490 --> 00:28:04,690
takes takes less than a second so we can

734
00:28:02,980 --> 00:28:08,260
actually just do this whenever we're on

735
00:28:04,690 --> 00:28:10,030
the script and then we sweep once we got

736
00:28:08,260 --> 00:28:12,460
those look-up tables the rainbow tables

737
00:28:10,030 --> 00:28:14,560
generated we can just go through the

738
00:28:12,460 --> 00:28:16,750
store library or the entire binary

739
00:28:14,560 --> 00:28:18,520
starting at the beginning and just look

740
00:28:16,750 --> 00:28:19,930
for every push instruction ginger has a

741
00:28:18,520 --> 00:28:20,860
function to do this I'll show it to you

742
00:28:19,930 --> 00:28:23,890
in a second when I pull up some source

743
00:28:20,860 --> 00:28:26,740
code of the script I've got and we take

744
00:28:23,890 --> 00:28:29,170
a look at it and say okay is it 32-bit

745
00:28:26,740 --> 00:28:31,810
is it pulling pushing a number and if

746
00:28:29,170 --> 00:28:34,060
it's pushing a number we then okay we'll

747
00:28:31,810 --> 00:28:36,750
say okay is it in our function lookup or

748
00:28:34,060 --> 00:28:38,530
in our lookup database and if it is we

749
00:28:36,750 --> 00:28:41,520
basically add a comment in the

750
00:28:38,530 --> 00:28:43,450
disassembly so we can see it later and

751
00:28:41,520 --> 00:28:45,490
rename the function that the push

752
00:28:43,450 --> 00:28:47,560
instruction is in because most of the

753
00:28:45,490 --> 00:28:49,539
ways and I think I'm beginning to

754
00:28:47,560 --> 00:28:51,609
question this assumption now

755
00:28:49,539 --> 00:28:53,080
but I looked at a little bit closer I

756
00:28:51,609 --> 00:28:54,789
think it's a little bit not quite right

757
00:28:53,080 --> 00:28:57,249
but at this point what we're basically

758
00:28:54,789 --> 00:29:00,249
the way I eye does it function look up

759
00:28:57,249 --> 00:29:01,720
says it has a each each windows function

760
00:29:00,249 --> 00:29:03,129
has its function that's my eyes

761
00:29:01,720 --> 00:29:05,440
implemented so basically all that

762
00:29:03,129 --> 00:29:06,789
function does is it uses spy eyes lookup

763
00:29:05,440 --> 00:29:10,830
code to find the address of the windows

764
00:29:06,789 --> 00:29:13,929
API function and calls it so if we if we

765
00:29:10,830 --> 00:29:16,359
rename that external function that has a

766
00:29:13,929 --> 00:29:18,639
lookup in it we can then just say okay

767
00:29:16,359 --> 00:29:20,678
yeah that's essentially like the windows

768
00:29:18,639 --> 00:29:24,340
API function we can move on from there

769
00:29:20,679 --> 00:29:28,720
so I don't know if you guys can see this

770
00:29:24,340 --> 00:29:32,349
okay cuz it's readable yeah questionable

771
00:29:28,720 --> 00:29:36,119
okay I can actually try and let me see

772
00:29:32,349 --> 00:29:39,908
if I can actually do a little bit of

773
00:29:36,119 --> 00:29:42,059
that better let me try this one more

774
00:29:39,909 --> 00:29:42,059
time

775
00:29:45,040 --> 00:29:55,210
we'll start here nope that didn't work

776
00:29:46,960 --> 00:29:56,650
at all how kind of did their so what

777
00:29:55,210 --> 00:29:58,210
I've done here is I is not the entire

778
00:29:56,650 --> 00:29:59,530
script I've just pulled out the parts I

779
00:29:58,210 --> 00:30:03,490
don't I didn't include up here I didn't

780
00:29:59,530 --> 00:30:05,110
include the the generation cone for the

781
00:30:03,490 --> 00:30:08,410
rainbow tables cuz it's just reading

782
00:30:05,110 --> 00:30:09,549
from a file and writing back to it but

783
00:30:08,410 --> 00:30:10,990
what we here we can see that there's

784
00:30:09,549 --> 00:30:13,410
this custom hash which I basically

785
00:30:10,990 --> 00:30:19,840
taking what I've gotten from the binary

786
00:30:13,410 --> 00:30:22,390
and ivory implemented in Python just the

787
00:30:19,840 --> 00:30:23,770
same thing input and get the output I

788
00:30:22,390 --> 00:30:25,480
just want to add at this I actually

789
00:30:23,770 --> 00:30:27,100
meant to talk about this in earlier

790
00:30:25,480 --> 00:30:28,390
slide one of the cool features that we

791
00:30:27,100 --> 00:30:30,010
were talking about how features modular

792
00:30:28,390 --> 00:30:31,450
one of the cool features that you can do

793
00:30:30,010 --> 00:30:33,580
that would replace this is we can

794
00:30:31,450 --> 00:30:36,250
actually because of this fact that we

795
00:30:33,580 --> 00:30:38,559
can go from binary to P code to pseudo

796
00:30:36,250 --> 00:30:40,690
code we can actually emulate the CPU

797
00:30:38,559 --> 00:30:42,668
instruction by instruction for little

798
00:30:40,690 --> 00:30:44,559
sections of code and we could just use

799
00:30:42,669 --> 00:30:46,270
the binary code binary code that was

800
00:30:44,559 --> 00:30:47,740
already in there to do this for us I

801
00:30:46,270 --> 00:30:49,059
didn't do in here because I've only

802
00:30:47,740 --> 00:30:50,770
haven't had much of a chance to play

803
00:30:49,059 --> 00:30:51,820
with it yet but that's kind of one of

804
00:30:50,770 --> 00:30:54,190
the next steps I'm gonna be talking

805
00:30:51,820 --> 00:30:59,200
about later anyways we've got this

806
00:30:54,190 --> 00:31:03,929
function to do that and let's go back

807
00:30:59,200 --> 00:31:05,799
here alright that did not work anyways

808
00:31:03,929 --> 00:31:07,330
that's gonna be little bit more

809
00:31:05,799 --> 00:31:10,179
challenging at work what we do here I'll

810
00:31:07,330 --> 00:31:12,100
pull my mouse first of all this is our

811
00:31:10,179 --> 00:31:13,480
function we currently get the program

812
00:31:12,100 --> 00:31:14,799
that's have active in the editor this is

813
00:31:13,480 --> 00:31:17,470
just basically okay what are we working

814
00:31:14,799 --> 00:31:20,290
on and we just do some a little bit of

815
00:31:17,470 --> 00:31:22,690
setup and our first step is to get the

816
00:31:20,290 --> 00:31:24,399
address of the first instruction in

817
00:31:22,690 --> 00:31:27,070
memory this is the first thing that

818
00:31:24,400 --> 00:31:29,770
successfully just assembled into a x86

819
00:31:27,070 --> 00:31:31,570
instruction and we basically loop

820
00:31:29,770 --> 00:31:34,150
through every instruction in the binary

821
00:31:31,570 --> 00:31:39,428
against doesn't take long it takes maybe

822
00:31:34,150 --> 00:31:40,570
five seconds to run and we first of all

823
00:31:39,429 --> 00:31:41,679
check if it's if it's not a push

824
00:31:40,570 --> 00:31:44,590
instruction we don't care about it we

825
00:31:41,679 --> 00:31:47,020
can go we can continue on and we just

826
00:31:44,590 --> 00:31:48,399
skip the next one and if it is push

827
00:31:47,020 --> 00:31:50,139
instruction we want to get whatever is

828
00:31:48,400 --> 00:31:51,400
being pushed onto the stack so we use I

829
00:31:50,140 --> 00:31:53,590
talked about earlier we use get input

830
00:31:51,400 --> 00:31:54,820
objects this basically says if it's a

831
00:31:53,590 --> 00:31:57,639
register it'll tell you what the

832
00:31:54,820 --> 00:31:58,840
register is if it's a constant value

833
00:31:57,640 --> 00:32:02,560
you'll be able to see that cost

834
00:31:58,840 --> 00:32:04,449
value and if it's if it's a scalar

835
00:32:02,560 --> 00:32:09,879
number as in if it's an integer or a

836
00:32:04,450 --> 00:32:12,880
float we then check about 32 bits and we

837
00:32:09,880 --> 00:32:14,320
get its unsigned value after that's

838
00:32:12,880 --> 00:32:15,880
pretty simple if it's if it's in the

839
00:32:14,320 --> 00:32:17,860
function database that we've already

840
00:32:15,880 --> 00:32:19,600
generated ahead of time we know that

841
00:32:17,860 --> 00:32:22,810
it's a Windows API function that it's

842
00:32:19,600 --> 00:32:24,520
probably trying to handle here and if it

843
00:32:22,810 --> 00:32:25,810
is and it matches and it shows up we

844
00:32:24,520 --> 00:32:29,770
basically take the name of the function

845
00:32:25,810 --> 00:32:31,929
and annotate the source code you can see

846
00:32:29,770 --> 00:32:33,160
there's a set common command this will

847
00:32:31,930 --> 00:32:35,800
show up in the D compiler and the

848
00:32:33,160 --> 00:32:37,510
disassembler and initially this was just

849
00:32:35,800 --> 00:32:38,770
all I did it didn't do any renaming of

850
00:32:37,510 --> 00:32:40,530
functions or whatnot but I added that a

851
00:32:38,770 --> 00:32:43,450
couple days ago I added the renaming and

852
00:32:40,530 --> 00:32:44,830
then finally we get we get the function

853
00:32:43,450 --> 00:32:46,870
that the push instruction is inside

854
00:32:44,830 --> 00:32:47,949
because it's generally one function

855
00:32:46,870 --> 00:32:52,659
lookup and then you call it that's it

856
00:32:47,950 --> 00:32:55,330
and we rename it all right

857
00:32:52,660 --> 00:32:56,260
so the process actually from a for those

858
00:32:55,330 --> 00:32:57,429
of you who are interested from user

859
00:32:56,260 --> 00:32:59,260
interface standpoint we had that

860
00:32:57,430 --> 00:33:01,870
function the script manager I showed you

861
00:32:59,260 --> 00:33:03,790
earlier with the 200 scripts I've got

862
00:33:01,870 --> 00:33:06,100
loaded in there I've got the spy search

863
00:33:03,790 --> 00:33:07,409
spy which is the source code you saw

864
00:33:06,100 --> 00:33:10,240
earlier in the previous slide

865
00:33:07,410 --> 00:33:11,950
double-click it and we see some console

866
00:33:10,240 --> 00:33:13,510
output and it tells you okay I found

867
00:33:11,950 --> 00:33:17,800
that this address I found this windows

868
00:33:13,510 --> 00:33:18,730
function things are going well and the

869
00:33:17,800 --> 00:33:22,090
upper is pretty cool we can see it

870
00:33:18,730 --> 00:33:25,960
before and after this is basically the

871
00:33:22,090 --> 00:33:27,490
code segment we saw where we've been

872
00:33:25,960 --> 00:33:30,070
kind of working on from the beginning

873
00:33:27,490 --> 00:33:32,620
and we can see that there's a couple of

874
00:33:30,070 --> 00:33:34,270
different changes here we can see that

875
00:33:32,620 --> 00:33:36,790
the functions been renamed first of all

876
00:33:34,270 --> 00:33:38,830
so we know that that function more or

877
00:33:36,790 --> 00:33:41,230
less is an analogue for enumerate time

878
00:33:38,830 --> 00:33:43,570
formats and there's actually one more

879
00:33:41,230 --> 00:33:45,820
step you do you could a few buttons and

880
00:33:43,570 --> 00:33:47,169
it also says okay I now know what kind

881
00:33:45,820 --> 00:33:52,750
of arguments it takes so we know what

882
00:33:47,170 --> 00:33:54,190
types there and you can also see that

883
00:33:52,750 --> 00:33:55,480
it's renamed some variables as well

884
00:33:54,190 --> 00:33:58,780
because this basically matches the

885
00:33:55,480 --> 00:34:00,010
windows Doc's now and I think this is

886
00:33:58,780 --> 00:34:01,480
this is one example but I think it's

887
00:34:00,010 --> 00:34:03,970
more illustrative is when you have

888
00:34:01,480 --> 00:34:05,650
functions that call this one because

889
00:34:03,970 --> 00:34:06,760
those will look a lot different we can

890
00:34:05,650 --> 00:34:08,230
see on the left this is before it

891
00:34:06,760 --> 00:34:10,079
started this is another function within

892
00:34:08,230 --> 00:34:15,069
the within SpyEye

893
00:34:10,079 --> 00:34:17,940
because he's a lot different we can see

894
00:34:15,069 --> 00:34:19,869
for example that a bunch of different

895
00:34:17,940 --> 00:34:21,639
variables in this function which

896
00:34:19,869 --> 00:34:23,649
previously were listed as undefined

897
00:34:21,639 --> 00:34:25,300
which is basically deters way of saying

898
00:34:23,649 --> 00:34:30,520
we don't know what this is we just know

899
00:34:25,300 --> 00:34:32,829
it's 4 bytes or 32 bits and since we can

900
00:34:30,520 --> 00:34:35,109
see that the windows functions that

901
00:34:32,829 --> 00:34:38,440
spiah has tried to use have been labeled

902
00:34:35,109 --> 00:34:40,480
and also the types that they take so we

903
00:34:38,440 --> 00:34:44,079
know that since create mutex a will know

904
00:34:40,480 --> 00:34:47,319
that none that lowest arrow since each

905
00:34:44,079 --> 00:34:50,169
object right there is the result of a

906
00:34:47,319 --> 00:34:51,279
call to create mutex a we know that it's

907
00:34:50,168 --> 00:34:52,929
got a certain type based on the

908
00:34:51,280 --> 00:34:54,310
specifications that windows have or that

909
00:34:52,929 --> 00:34:56,859
Microsoft has released for this library

910
00:34:54,310 --> 00:34:59,230
and we can see above in the variable

911
00:34:56,859 --> 00:35:02,560
definitions that or I think it's in

912
00:34:59,230 --> 00:35:03,670
there maybe it isn't that the types are

913
00:35:02,560 --> 00:35:06,460
made to match you can see the wind bool

914
00:35:03,670 --> 00:35:08,650
handle those are all just from what

915
00:35:06,460 --> 00:35:10,690
Ghidorah knows about the windows api and

916
00:35:08,650 --> 00:35:15,060
the fact that we've renamed all of our

917
00:35:10,690 --> 00:35:15,060
functions to match it's pretty awesome

918
00:35:15,720 --> 00:35:20,020
so next I wanna go take aways kind of

919
00:35:18,220 --> 00:35:25,230
what I want you to go away

920
00:35:20,020 --> 00:35:27,819
end up coming away with first of all

921
00:35:25,230 --> 00:35:29,950
Deidre's api is super powerful

922
00:35:27,819 --> 00:35:33,130
it's extendable you can write all this

923
00:35:29,950 --> 00:35:34,540
stuff to it I mean literally what I've

924
00:35:33,130 --> 00:35:36,490
showed you here just scratches the

925
00:35:34,540 --> 00:35:39,550
surface I talked about its ability to

926
00:35:36,490 --> 00:35:40,209
emulate code it's gonna make my life a

927
00:35:39,550 --> 00:35:44,050
lot easier

928
00:35:40,210 --> 00:35:47,290
once I figure it out and future features

929
00:35:44,050 --> 00:35:49,630
are I'm gonna make it even better there

930
00:35:47,290 --> 00:35:52,540
is talk that there is integration with

931
00:35:49,630 --> 00:35:53,589
debugging debuggers in the future it's

932
00:35:52,540 --> 00:35:55,900
been a little while since they said they

933
00:35:53,589 --> 00:35:59,259
were going to do that but that's me

934
00:35:55,900 --> 00:36:01,690
pretty awesome and it's still

935
00:35:59,260 --> 00:36:03,069
time-consuming and tedious but this kind

936
00:36:01,690 --> 00:36:04,329
of automation it's important to learn

937
00:36:03,069 --> 00:36:05,920
how to do it as part when you're

938
00:36:04,329 --> 00:36:08,500
learning how to be a reverse engineer

939
00:36:05,920 --> 00:36:09,760
because without it your effectiveness is

940
00:36:08,500 --> 00:36:12,970
pretty limited because it's just the

941
00:36:09,760 --> 00:36:14,680
amount of time it's gonna take but I

942
00:36:12,970 --> 00:36:17,140
think even with all these tools it's

943
00:36:14,680 --> 00:36:19,240
also important to say that having an

944
00:36:17,140 --> 00:36:21,009
underlying platform knowledge is still

945
00:36:19,240 --> 00:36:22,950
critical to being a good reverse

946
00:36:21,010 --> 00:36:24,750
engineer

947
00:36:22,950 --> 00:36:26,790
along those lines if there's any CISOs

948
00:36:24,750 --> 00:36:30,240
in the room I just want to say that I

949
00:36:26,790 --> 00:36:31,350
cannot encourage you enough to get your

950
00:36:30,240 --> 00:36:33,180
team members using a tool like this

951
00:36:31,350 --> 00:36:37,049
there's no cost to you as far as money

952
00:36:33,180 --> 00:36:38,879
it's open source and the skills that

953
00:36:37,050 --> 00:36:40,460
they will learn if it's even if it's

954
00:36:38,880 --> 00:36:43,020
taking something that's been detected by

955
00:36:40,460 --> 00:36:45,090
an antivirus tool or something maybe

956
00:36:43,020 --> 00:36:48,420
that isn't that kind of a suspicious but

957
00:36:45,090 --> 00:36:49,590
didn't didn't rip any detections have

958
00:36:48,420 --> 00:36:50,940
them take a look at it and learn about

959
00:36:49,590 --> 00:36:54,390
it because the knowledge you'll gain

960
00:36:50,940 --> 00:36:56,340
from that is pretty invaluable and if

961
00:36:54,390 --> 00:36:57,720
you do use it contribute back to it

962
00:36:56,340 --> 00:36:59,460
because the more people use it and

963
00:36:57,720 --> 00:37:00,899
contribute and write code for it the

964
00:36:59,460 --> 00:37:05,760
better it's going to be twitch is really

965
00:37:00,900 --> 00:37:07,050
awesome and with that type of questions

966
00:37:05,760 --> 00:37:08,940
before I just want to go into questions

967
00:37:07,050 --> 00:37:11,750
I want to thank a couple people calling

968
00:37:08,940 --> 00:37:14,430
Coolidge from segment for being

969
00:37:11,750 --> 00:37:15,870
providing invaluable advice from all

970
00:37:14,430 --> 00:37:18,180
this presentation is in the works and

971
00:37:15,870 --> 00:37:21,200
especially my team at coal fire federal

972
00:37:18,180 --> 00:37:23,009
for also providing and put it on as well

973
00:37:21,200 --> 00:37:24,210
all right with that let's get into

974
00:37:23,010 --> 00:37:31,530
questions here for a second I will pull

975
00:37:24,210 --> 00:37:35,790
them up does anybody got from the

976
00:37:31,530 --> 00:37:38,030
audience before I Benny are they in here

977
00:37:35,790 --> 00:37:38,029
yes

978
00:37:39,440 --> 00:37:46,130
ah okay awesome so yes he asked what the

979
00:37:44,599 --> 00:37:48,680
process is for working with a team on a

980
00:37:46,130 --> 00:37:49,880
single Gator process your project is

981
00:37:48,680 --> 00:37:51,950
actually an interesting question because

982
00:37:49,880 --> 00:37:53,329
one of the features that get your has is

983
00:37:51,950 --> 00:37:57,470
actually has the ability to do

984
00:37:53,329 --> 00:37:59,270
collaboration at this point it's kind of

985
00:37:57,470 --> 00:38:02,089
basic so there's a server application

986
00:37:59,270 --> 00:38:04,280
that you can put on a server it can be

987
00:38:02,089 --> 00:38:08,808
on your local laptop it can be on a VPS

988
00:38:04,280 --> 00:38:11,960
somewhere and then that server setup you

989
00:38:08,809 --> 00:38:14,420
add Billy add users to that and then you

990
00:38:11,960 --> 00:38:15,829
as part of the project creation process

991
00:38:14,420 --> 00:38:17,329
you just see that basically they say

992
00:38:15,829 --> 00:38:20,030
okay I want this to be a shared project

993
00:38:17,329 --> 00:38:21,890
say okay the server is hosted here it

994
00:38:20,030 --> 00:38:27,109
goes and it does all stuff I will say

995
00:38:21,890 --> 00:38:28,490
that its features are good but what I

996
00:38:27,109 --> 00:38:29,990
was kind of expecting and what it was

997
00:38:28,490 --> 00:38:31,609
hoping would be was not quite match that

998
00:38:29,990 --> 00:38:33,259
it's a little bit at this point it's a

999
00:38:31,609 --> 00:38:36,109
little bit closer to being a version

1000
00:38:33,260 --> 00:38:38,089
control system really tailor taking what

1001
00:38:36,109 --> 00:38:41,029
Guidry does its features are you know

1002
00:38:38,089 --> 00:38:42,859
check in and check out get code but it

1003
00:38:41,030 --> 00:38:44,029
may change at that time you know more

1004
00:38:42,859 --> 00:38:45,109
people may develop those kind of

1005
00:38:44,029 --> 00:38:47,329
solutions which would be really cool to

1006
00:38:45,109 --> 00:38:48,980
see the ability to do like Google Docs

1007
00:38:47,329 --> 00:38:50,569
style of reverse analysis reverse

1008
00:38:48,980 --> 00:38:51,859
engineering be awesome I don't think

1009
00:38:50,569 --> 00:38:59,930
it's there yet but I'm hoping it gets

1010
00:38:51,859 --> 00:39:02,210
there at some point any other ones as

1011
00:38:59,930 --> 00:39:05,828
far as versus Ida Pro I haven't had a

1012
00:39:02,210 --> 00:39:08,029
ton of time to compare the two directly

1013
00:39:05,829 --> 00:39:09,650
there's some things and this may be a

1014
00:39:08,029 --> 00:39:11,510
matter of matter of perfect that by the

1015
00:39:09,650 --> 00:39:14,329
way he asked how does it compare to Ida

1016
00:39:11,510 --> 00:39:16,369
Pro as far as in this maybe it matters

1017
00:39:14,329 --> 00:39:17,960
of personal preference there's some

1018
00:39:16,369 --> 00:39:19,819
things that I like about goodra and how

1019
00:39:17,960 --> 00:39:22,190
it lays things out and does certain

1020
00:39:19,819 --> 00:39:24,020
analyses that I really prefer I would

1021
00:39:22,190 --> 00:39:26,809
say that having in the what direct

1022
00:39:24,020 --> 00:39:31,369
comparison I had done it is pretty close

1023
00:39:26,809 --> 00:39:32,779
to being the same I haven't been able to

1024
00:39:31,369 --> 00:39:34,130
get like a lot of the we talked about

1025
00:39:32,779 --> 00:39:35,329
datatypes and windows and be able to

1026
00:39:34,130 --> 00:39:37,849
detect those and annotate those I

1027
00:39:35,329 --> 00:39:40,039
haven't really been able to get Ida to

1028
00:39:37,849 --> 00:39:41,930
do that quite as much I think it may

1029
00:39:40,039 --> 00:39:43,880
change a lot if you get hex raised the

1030
00:39:41,930 --> 00:39:45,859
decompiler I currently don't have a

1031
00:39:43,880 --> 00:39:47,660
license for that right now because

1032
00:39:45,859 --> 00:39:50,750
goodra has worked pretty well for me so

1033
00:39:47,660 --> 00:39:52,970
far so there's really been a need but I

1034
00:39:50,750 --> 00:39:54,530
think it's pretty close

1035
00:39:52,970 --> 00:39:56,839
I haven't looked at far as much as far

1036
00:39:54,530 --> 00:39:58,850
as performance the decompile ourself

1037
00:39:56,840 --> 00:40:01,970
incident C++ so it's not terrible it's

1038
00:39:58,850 --> 00:40:03,470
pretty good and so at some point I'll

1039
00:40:01,970 --> 00:40:06,020
get to comparing those but it's been

1040
00:40:03,470 --> 00:40:07,879
that's it for someone who's getting into

1041
00:40:06,020 --> 00:40:11,900
the getting into it it's amazing I think

1042
00:40:07,880 --> 00:40:13,610
it's very very near parity even the fact

1043
00:40:11,900 --> 00:40:15,440
that you have as many support for many

1044
00:40:13,610 --> 00:40:18,170
architectures if you were to buy Ida

1045
00:40:15,440 --> 00:40:20,300
with this many architectures and you're

1046
00:40:18,170 --> 00:40:21,560
getting close to you know tens of that

1047
00:40:20,300 --> 00:40:22,880
well easily tens of thousands maybe

1048
00:40:21,560 --> 00:40:28,730
hundreds of thousands of dollars to get

1049
00:40:22,880 --> 00:40:30,110
all those so almost the same and I think

1050
00:40:28,730 --> 00:40:37,630
a lot of that again personal preference

1051
00:40:30,110 --> 00:40:37,630
but it's pretty pretty darn close yeah

1052
00:40:47,440 --> 00:40:55,640
yes so the question that was asked was a

1053
00:40:53,290 --> 00:40:57,020
what libraries are there any libraries

1054
00:40:55,640 --> 00:40:58,279
available as far as skeeter scripting

1055
00:40:57,020 --> 00:40:59,750
it's an interesting question one of the

1056
00:40:58,280 --> 00:41:01,760
struggles I've had in going through

1057
00:40:59,750 --> 00:41:03,770
Gager and learning over the past you

1058
00:41:01,760 --> 00:41:06,830
know almost a year is that the

1059
00:41:03,770 --> 00:41:09,170
documentation is kind of there but at

1060
00:41:06,830 --> 00:41:10,310
really at some point you end up coming

1061
00:41:09,170 --> 00:41:12,020
down to the point where you have to read

1062
00:41:10,310 --> 00:41:13,610
the Java Docs which they are and they're

1063
00:41:12,020 --> 00:41:14,690
very good because Java Doc's are and

1064
00:41:13,610 --> 00:41:20,480
that's one of the awesome features of

1065
00:41:14,690 --> 00:41:23,120
Java and I will say that as far as

1066
00:41:20,480 --> 00:41:24,500
libraries I'm haven't seen any external

1067
00:41:23,120 --> 00:41:28,670
ones yet and may just not have seen them

1068
00:41:24,500 --> 00:41:31,040
I say in a lot of cases I would question

1069
00:41:28,670 --> 00:41:32,630
the ability often when I'm dealing with

1070
00:41:31,040 --> 00:41:34,070
the kind of things I might take a script

1071
00:41:32,630 --> 00:41:35,270
like that and there's little teeny

1072
00:41:34,070 --> 00:41:36,830
things that I wanted to do but it

1073
00:41:35,270 --> 00:41:38,120
doesn't quite do so my dinner and my

1074
00:41:36,830 --> 00:41:40,580
approach has been take the features

1075
00:41:38,120 --> 00:41:42,140
engage your API apply them specifically

1076
00:41:40,580 --> 00:41:45,200
to the piece of the sample that I'm

1077
00:41:42,140 --> 00:41:46,940
analyzing and then when I go to another

1078
00:41:45,200 --> 00:41:48,620
sample you do that process again there

1079
00:41:46,940 --> 00:41:50,960
are places where you can generalize some

1080
00:41:48,620 --> 00:41:54,710
of that but I at least at this point I

1081
00:41:50,960 --> 00:41:57,200
haven't really develop scripts that work

1082
00:41:54,710 --> 00:42:00,650
on everything and I think it approaches

1083
00:41:57,200 --> 00:42:01,819
to expression in these cases develop for

1084
00:42:00,650 --> 00:42:04,010
the software that you're bigger

1085
00:42:01,820 --> 00:42:06,440
analyzing you can do it on the fly it

1086
00:42:04,010 --> 00:42:08,510
does that be pretty like I said

1087
00:42:06,440 --> 00:42:10,099
but as far as libraries I haven't seen

1088
00:42:08,510 --> 00:42:10,580
anything out there there is a big list

1089
00:42:10,099 --> 00:42:12,230
here

1090
00:42:10,580 --> 00:42:13,250
Paulette scripts and I had a chance to

1091
00:42:12,230 --> 00:42:15,460
play with but I haven't seen anything

1092
00:42:13,250 --> 00:42:17,300
other than that out there you just yet

1093
00:42:15,460 --> 00:42:22,359
one more from the audience if there

1094
00:42:17,300 --> 00:42:22,359
isn't and I'll go to the slides slide oh

1095
00:42:22,750 --> 00:42:32,060
let me see a close-up okay let something

1096
00:42:28,430 --> 00:42:33,379
final zero want okay

1097
00:42:32,060 --> 00:42:35,150
I know if you have slight Oh up if you

1098
00:42:33,380 --> 00:42:36,980
and be able to see my phone might not be

1099
00:42:35,150 --> 00:42:55,550
working but yes you able to see

1100
00:42:36,980 --> 00:42:58,760
questions yeah yep so a gentleman over

1101
00:42:55,550 --> 00:43:01,270
here asked whether we've encountered in

1102
00:42:58,760 --> 00:43:03,500
situations where there's been collisions

1103
00:43:01,270 --> 00:43:04,460
as far as the hashtag algorithms and I

1104
00:43:03,500 --> 00:43:05,960
think this is actually an important

1105
00:43:04,460 --> 00:43:07,130
question I wish I had covered look I

1106
00:43:05,960 --> 00:43:10,550
probably should cover a little bit more

1107
00:43:07,130 --> 00:43:13,339
but in this case there is the potential

1108
00:43:10,550 --> 00:43:15,290
for there to be collisions I think since

1109
00:43:13,339 --> 00:43:15,560
the amount of data that you're working

1110
00:43:15,290 --> 00:43:18,859
with

1111
00:43:15,560 --> 00:43:20,540
okay there's eight thousand two billion

1112
00:43:18,859 --> 00:43:21,890
possible hash values and eight thousand

1113
00:43:20,540 --> 00:43:23,180
instructions the chances of that are

1114
00:43:21,890 --> 00:43:24,680
going to be pretty low and it's

1115
00:43:23,180 --> 00:43:26,899
something to keep in mind in this case

1116
00:43:24,680 --> 00:43:30,618
there was I had a very there was a very

1117
00:43:26,900 --> 00:43:34,730
uh in my case it was a very conscious

1118
00:43:30,619 --> 00:43:36,800
decision to avoid trying to be too

1119
00:43:34,730 --> 00:43:39,290
specific because in this particular case

1120
00:43:36,800 --> 00:43:41,180
if I get a pulse false positive it is in

1121
00:43:39,290 --> 00:43:42,380
the end of the world I at some point

1122
00:43:41,180 --> 00:43:45,319
it's gonna come up and I'm like this

1123
00:43:42,380 --> 00:43:46,730
doesn't seem right and I'll see that and

1124
00:43:45,320 --> 00:43:49,310
I'll say okay yeah that's some weird

1125
00:43:46,730 --> 00:43:51,500
edge case it's more important for me in

1126
00:43:49,310 --> 00:43:52,910
this state since there's since spy I

1127
00:43:51,500 --> 00:43:54,859
doesn't weigh there's multiple did ways

1128
00:43:52,910 --> 00:43:57,649
of doing the same thing to some degree

1129
00:43:54,859 --> 00:44:00,529
it's more important that I get all get

1130
00:43:57,650 --> 00:44:02,540
all of those or close to all of them so

1131
00:44:00,530 --> 00:44:04,640
in this particular I wrote that script

1132
00:44:02,540 --> 00:44:06,560
with that in mind which doesn't take

1133
00:44:04,640 --> 00:44:08,029
into account collisions or you know

1134
00:44:06,560 --> 00:44:09,529
pushing on some value the stack that

1135
00:44:08,030 --> 00:44:12,589
happens to be some hash of some windows

1136
00:44:09,530 --> 00:44:13,760
function so it's something you should

1137
00:44:12,589 --> 00:44:16,599
keep in mind when you're working with

1138
00:44:13,760 --> 00:44:19,720
these but in this particular case I

1139
00:44:16,599 --> 00:44:21,740
haven't seen anything yet

1140
00:44:19,720 --> 00:44:31,220
all right any from the room since

1141
00:44:21,740 --> 00:44:32,479
there's not on there yes okay I don't

1142
00:44:31,220 --> 00:44:35,000
want ask as far as fingerprinting is

1143
00:44:32,480 --> 00:44:37,610
there a global database for like what we

1144
00:44:35,000 --> 00:44:41,090
say with flair there are databases

1145
00:44:37,610 --> 00:44:43,700
available on github I think there what

1146
00:44:41,090 --> 00:44:45,140
I've seen and I may have forgetting

1147
00:44:43,700 --> 00:44:49,279
something I've seen in the past there

1148
00:44:45,140 --> 00:44:50,890
are the FI DB function and it's the

1149
00:44:49,280 --> 00:44:52,880
function ID is the function that is the

1150
00:44:50,890 --> 00:44:55,549
functionality what they call in deidre

1151
00:44:52,880 --> 00:44:57,530
there are databases available for some

1152
00:44:55,550 --> 00:44:59,570
libraries and here's one for boost and a

1153
00:44:57,530 --> 00:45:02,900
lot of like the general Lib C libraries

1154
00:44:59,570 --> 00:45:06,560
in Linux I haven't really seen one too

1155
00:45:02,900 --> 00:45:08,480
much for Windows more the analysis that

1156
00:45:06,560 --> 00:45:12,170
I've seen done so far has come from

1157
00:45:08,480 --> 00:45:14,150
pulling out the imports and I will say

1158
00:45:12,170 --> 00:45:16,550
that in my experimentation with the

1159
00:45:14,150 --> 00:45:17,930
function ID so far I haven't had a ton

1160
00:45:16,550 --> 00:45:21,050
of luck and getting it to detect with

1161
00:45:17,930 --> 00:45:23,379
the databases I've had and so I don't a

1162
00:45:21,050 --> 00:45:25,490
really good picture of how it works yet

1163
00:45:23,380 --> 00:45:27,290
but there are databases there is there

1164
00:45:25,490 --> 00:45:29,120
one that's comprehensive I haven't seen

1165
00:45:27,290 --> 00:45:30,350
one yet there are combinations of

1166
00:45:29,120 --> 00:45:32,900
smaller ones that are specific to

1167
00:45:30,350 --> 00:45:35,770
certain libraries but I guess that is

1168
00:45:32,900 --> 00:45:35,770
that answer your question okay

1169
00:45:37,870 --> 00:45:43,730
yeah they're out there I can think of

1170
00:45:40,550 --> 00:45:45,860
one I can come after I can probably pull

1171
00:45:43,730 --> 00:45:47,480
up the one that I have but as far as

1172
00:45:45,860 --> 00:45:55,010
Windows I'd have to look somewhere to

1173
00:45:47,480 --> 00:45:56,630
find it any others all right well thank

1174
00:45:55,010 --> 00:45:58,160
you guys so much come out I'll put my

1175
00:45:56,630 --> 00:46:00,530
contact info we'll be up here for a

1176
00:45:58,160 --> 00:46:01,509
second ironed out rows on coal fire comm

1177
00:46:00,530 --> 00:46:05,510
that'll work

1178
00:46:01,510 --> 00:46:06,590
or I do have a Twitter account it's kind

1179
00:46:05,510 --> 00:46:08,660
of a ghost town right now I don't really

1180
00:46:06,590 --> 00:46:11,300
use them much but I'll keep an eye out

1181
00:46:08,660 --> 00:46:13,339
and then over the next few weeks I'm at

1182
00:46:11,300 --> 00:46:15,680
some point I'm hoping I need to talk

1183
00:46:13,340 --> 00:46:16,730
with people at coal fire to make sure it

1184
00:46:15,680 --> 00:46:18,620
and just make sure everything's in line

1185
00:46:16,730 --> 00:46:20,450
but I'm gonna try to take the Python

1186
00:46:18,620 --> 00:46:22,220
script and put it up somewhere that'll

1187
00:46:20,450 --> 00:46:26,370
probably be through their online

1188
00:46:22,220 --> 00:46:28,430
presence all right thank you

1189
00:46:26,370 --> 00:46:28,430
you

