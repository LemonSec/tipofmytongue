1
00:00:00,000 --> 00:00:06,500
hi everyone good afternoon crypto geeks

2
00:00:06,890 --> 00:00:13,410
so let's go ahead and get started I hope

3
00:00:11,460 --> 00:00:15,690
everybody remembers this about a month

4
00:00:13,410 --> 00:00:17,850
ago maybe five or six weeks ago I don't

5
00:00:15,690 --> 00:00:20,009
remember exactly but there was a huge

6
00:00:17,850 --> 00:00:24,420
vulnerability in Microsoft Windows which

7
00:00:20,010 --> 00:00:27,420
was an NSA this time was nice enough to

8
00:00:24,420 --> 00:00:30,570
let everybody know about it so vendor

9
00:00:27,420 --> 00:00:35,430
could cash it and why am i bringing up

10
00:00:30,570 --> 00:00:41,280
today this thing was this an issue with

11
00:00:35,430 --> 00:00:43,320
some cryptographic protocol like TLS no

12
00:00:41,280 --> 00:00:46,680
was it an issue with some critter

13
00:00:43,320 --> 00:00:47,910
graphic algorithm like a yeah so Shaun

14
00:00:46,680 --> 00:00:51,090
no not really

15
00:00:47,910 --> 00:00:53,459
this was just a this vulnerability that

16
00:00:51,090 --> 00:00:56,610
let but that could potential that an

17
00:00:53,460 --> 00:00:58,829
attacker do all kinds of bad things was

18
00:00:56,610 --> 00:01:05,430
just the result of one or two stupid

19
00:00:58,829 --> 00:01:08,340
coding mistakes and why is that

20
00:01:05,430 --> 00:01:09,960
so cryptography is hard right if anybody

21
00:01:08,340 --> 00:01:13,560
disagrees with me I want to talk to you

22
00:01:09,960 --> 00:01:16,110
after this talk and coding mistakes are

23
00:01:13,560 --> 00:01:19,200
bad and we all deal with coding mistakes

24
00:01:16,110 --> 00:01:22,830
and coding mistakes in cryptography are

25
00:01:19,200 --> 00:01:24,750
especially bad because virtually all the

26
00:01:22,830 --> 00:01:28,259
time they lead to some kind of security

27
00:01:24,750 --> 00:01:29,579
issue like the one we just mentioned so

28
00:01:28,259 --> 00:01:32,280
today we're gonna talk about how to

29
00:01:29,579 --> 00:01:34,399
exploit some of these coding mistakes or

30
00:01:32,280 --> 00:01:39,320
implementation mistakes I should say

31
00:01:34,400 --> 00:01:43,890
we're not gonna talk about any zero days

32
00:01:39,320 --> 00:01:46,169
no not today there's not gonna be any

33
00:01:43,890 --> 00:01:48,869
complex math everything's gonna be

34
00:01:46,170 --> 00:01:52,439
pretty basic we're not gonna talk about

35
00:01:48,869 --> 00:01:53,700
any about the dark future of

36
00:01:52,439 --> 00:01:56,008
cryptography which is going to be

37
00:01:53,700 --> 00:01:59,579
completely broken by quantum computing

38
00:01:56,009 --> 00:02:01,590
and we're not gonna break the internet

39
00:01:59,579 --> 00:02:06,240
today which is based on the correctly

40
00:02:01,590 --> 00:02:08,640
implemented crypto all right so my name

41
00:02:06,240 --> 00:02:11,640
is Alexey I'm a recovering software

42
00:02:08,639 --> 00:02:12,779
developer at some point I realized that

43
00:02:11,640 --> 00:02:15,690
breaking code was

44
00:02:12,780 --> 00:02:18,270
more more fun than writing code so I

45
00:02:15,690 --> 00:02:20,609
don't fight much code anymore but I do

46
00:02:18,270 --> 00:02:23,400
break some sometimes I currently work

47
00:02:20,610 --> 00:02:25,590
for a company few blocks away from here

48
00:02:23,400 --> 00:02:29,130
I'm not actually based in San Francisco

49
00:02:25,590 --> 00:02:31,520
though I have a couple of industry certs

50
00:02:29,130 --> 00:02:33,180
but there is a fine print of this slide

51
00:02:31,520 --> 00:02:36,840
now here it is

52
00:02:33,180 --> 00:02:38,069
I'm not a cryptographer so and I don't

53
00:02:36,840 --> 00:02:39,840
even know what the definition of

54
00:02:38,069 --> 00:02:42,000
cryptography is is it somebody who

55
00:02:39,840 --> 00:02:45,420
invented an algorithm or I don't know

56
00:02:42,000 --> 00:02:48,480
but anyway so this this is a talk by and

57
00:02:45,420 --> 00:02:51,720
non-experts non expert hopefully for

58
00:02:48,480 --> 00:02:52,950
non-experts but I hope it will be

59
00:02:51,720 --> 00:02:57,450
interesting so a few general

60
00:02:52,950 --> 00:02:59,459
recommendations first of all we all need

61
00:02:57,450 --> 00:03:03,768
to use well-known and secure algorithms

62
00:02:59,459 --> 00:03:07,200
right we don't use md5 anymore or des

63
00:03:03,769 --> 00:03:09,840
that's clear and we need to use standard

64
00:03:07,200 --> 00:03:13,230
and stable implementations of those

65
00:03:09,840 --> 00:03:17,730
algorithms we don't use some obscure

66
00:03:13,230 --> 00:03:22,410
libraries who and nobody knows where

67
00:03:17,730 --> 00:03:24,298
they were written a very important thing

68
00:03:22,410 --> 00:03:26,489
is we need to follow best practices so

69
00:03:24,299 --> 00:03:29,040
if somebody's telling you if the book

70
00:03:26,489 --> 00:03:32,910
says you gotta use a random IV there's

71
00:03:29,040 --> 00:03:36,090
probably a reason for that right and you

72
00:03:32,910 --> 00:03:37,410
heard this advice many many times I'm

73
00:03:36,090 --> 00:03:42,959
just gonna give it to you again do not

74
00:03:37,410 --> 00:03:43,980
invent your own crypto the mixed a

75
00:03:42,959 --> 00:03:47,579
mistakes with cryptographic

76
00:03:43,980 --> 00:03:50,488
implementations or code around it can

77
00:03:47,579 --> 00:03:52,170
boil down to several categories first

78
00:03:50,489 --> 00:03:55,049
there isn't there could be insufficient

79
00:03:52,170 --> 00:03:57,420
entropy which means basically means not

80
00:03:55,049 --> 00:03:59,760
enough randomness and randomness is

81
00:03:57,420 --> 00:04:02,010
really important here second is

82
00:03:59,760 --> 00:04:05,328
algorithm choice so we don't use the

83
00:04:02,010 --> 00:04:05,328
correct algorithm for the purpose

84
00:04:06,709 --> 00:04:12,600
algorithmic considerations are really

85
00:04:09,720 --> 00:04:14,609
important because depending on what

86
00:04:12,600 --> 00:04:17,010
you're trying to do there are certain

87
00:04:14,609 --> 00:04:21,599
things certain tweaks that you need to

88
00:04:17,010 --> 00:04:23,420
use to to get what you need and not to

89
00:04:21,599 --> 00:04:26,150
make a mistake

90
00:04:23,420 --> 00:04:28,880
one thing that we often overlook we

91
00:04:26,150 --> 00:04:30,710
which I we tend to focus on secrecy and

92
00:04:28,880 --> 00:04:33,830
we forget about integrity

93
00:04:30,710 --> 00:04:36,409
so we yeah okay we hide this message

94
00:04:33,830 --> 00:04:40,010
really well but can anybody tamper with

95
00:04:36,410 --> 00:04:44,030
it and we forget and the last but not

96
00:04:40,010 --> 00:04:47,000
least is you can have a perfect system

97
00:04:44,030 --> 00:04:49,340
with very secure keys modern algorithms

98
00:04:47,000 --> 00:04:52,130
but as long as you don't handle those

99
00:04:49,340 --> 00:04:55,489
keys correctly and they leaked are you

100
00:04:52,130 --> 00:04:57,740
broken let's talk about a couple of

101
00:04:55,490 --> 00:05:00,890
basics first I hope everybody knows what

102
00:04:57,740 --> 00:05:02,930
exclusive-or is but if you don't this is

103
00:05:00,890 --> 00:05:05,560
the ultimate crypto weapon for the

104
00:05:02,930 --> 00:05:08,510
purpose of this talk and we'll see why

105
00:05:05,560 --> 00:05:11,270
and there are and there are a few cool

106
00:05:08,510 --> 00:05:16,730
properties of this operation first is

107
00:05:11,270 --> 00:05:21,289
anything X or 0 is same thing something

108
00:05:16,730 --> 00:05:25,550
X or the same thing is 0 and if a X or B

109
00:05:21,290 --> 00:05:28,100
is C then a X or C is B and B X or C is

110
00:05:25,550 --> 00:05:31,720
a so you can move the parameter on

111
00:05:28,100 --> 00:05:33,890
either side of the of that equal sign

112
00:05:31,720 --> 00:05:39,200
because the second basic thing is

113
00:05:33,890 --> 00:05:42,200
randomness there are two big types of

114
00:05:39,200 --> 00:05:44,810
random number generators one is to

115
00:05:42,200 --> 00:05:46,400
random number generator which is non

116
00:05:44,810 --> 00:05:48,140
deterministic and completely

117
00:05:46,400 --> 00:05:51,409
unpredictable and those are normally

118
00:05:48,140 --> 00:05:54,250
based on some physical characteristics

119
00:05:51,410 --> 00:05:57,290
may be ambient temperature or noise or

120
00:05:54,250 --> 00:06:00,740
electric current fluctuations or some

121
00:05:57,290 --> 00:06:03,320
visual data and there was again there's

122
00:06:00,740 --> 00:06:04,850
no way to predict what the next random

123
00:06:03,320 --> 00:06:07,190
number from that generator is going to

124
00:06:04,850 --> 00:06:09,860
be and there are also pseudo-random

125
00:06:07,190 --> 00:06:11,570
number generators and these are

126
00:06:09,860 --> 00:06:14,560
completely deterministic these are

127
00:06:11,570 --> 00:06:17,540
algorithms and they based on on a seed

128
00:06:14,560 --> 00:06:19,370
so you give it the same seed to time

129
00:06:17,540 --> 00:06:23,690
said it's gonna generate the same

130
00:06:19,370 --> 00:06:25,640
sequence of random numbers and a lot of

131
00:06:23,690 --> 00:06:30,380
times we use the combination of both so

132
00:06:25,640 --> 00:06:31,580
we would use the two random for for the

133
00:06:30,380 --> 00:06:35,490
seed and then we give it to

134
00:06:31,580 --> 00:06:37,229
pseudo-random and then we get a nice

135
00:06:35,490 --> 00:06:40,370
a stream that that's looking like

136
00:06:37,229 --> 00:06:44,250
completely random speaking of randomness

137
00:06:40,370 --> 00:06:46,380
few years ago some smart guys got fed up

138
00:06:44,250 --> 00:06:49,530
with all ransomware being written for

139
00:06:46,380 --> 00:06:50,940
Windows so they decided to to create one

140
00:06:49,530 --> 00:06:52,830
for Linux

141
00:06:50,940 --> 00:06:55,080
after all the next runs a lot of stuff

142
00:06:52,830 --> 00:06:58,650
right and you could probably monetize

143
00:06:55,080 --> 00:07:01,469
something like this really easy the

144
00:06:58,650 --> 00:07:02,638
problem was they used predictable

145
00:07:01,470 --> 00:07:06,150
encryption keys when they were

146
00:07:02,639 --> 00:07:09,599
encrypting the data and researchers

147
00:07:06,150 --> 00:07:12,210
found it pretty quickly and and released

148
00:07:09,599 --> 00:07:13,800
a decrypter which anybody could use to

149
00:07:12,210 --> 00:07:18,000
decrypt their data without paying any

150
00:07:13,800 --> 00:07:25,979
ransom and I have a demo so let's see

151
00:07:18,000 --> 00:07:28,020
how it works so I have a small document

152
00:07:25,979 --> 00:07:32,449
which says not all random functions were

153
00:07:28,020 --> 00:07:35,520
created equal and I have my encrypter

154
00:07:32,449 --> 00:07:39,060
which encrypted my file with some key

155
00:07:35,520 --> 00:07:40,859
that it just created and actually it

156
00:07:39,060 --> 00:07:44,990
forgot about the key I don't even have

157
00:07:40,860 --> 00:07:48,199
it but if I look at this document ransom

158
00:07:44,990 --> 00:07:51,990
it's looking completely like some random

159
00:07:48,199 --> 00:07:55,530
binary data and I have no idea what the

160
00:07:51,990 --> 00:07:57,300
keys again and what the what the what is

161
00:07:55,530 --> 00:08:06,150
document is but I can use my Decrypter

162
00:07:57,300 --> 00:08:08,250
script to if I can type it correctly and

163
00:08:06,150 --> 00:08:10,739
it decrypted that file because in this

164
00:08:08,250 --> 00:08:13,500
particular case it could just get the

165
00:08:10,740 --> 00:08:20,159
timestamp of the file modification

166
00:08:13,500 --> 00:08:24,240
timestamp and give it to the to the

167
00:08:20,159 --> 00:08:28,349
generator here and and that's it that's

168
00:08:24,240 --> 00:08:30,240
very very easy so before I move on I

169
00:08:28,349 --> 00:08:32,159
wanted to mention that all the code that

170
00:08:30,240 --> 00:08:33,479
I'm using today is on github and you'll

171
00:08:32,159 --> 00:08:35,789
get a link at the end of this talk and

172
00:08:33,479 --> 00:08:38,719
you'll be able to download it play with

173
00:08:35,789 --> 00:08:38,718
it do whatever you want

174
00:08:41,500 --> 00:08:46,860
cool yeah so it's a great advice right

175
00:08:47,250 --> 00:08:53,140
of course

176
00:08:49,630 --> 00:08:57,060
he if you md5 current time you you're

177
00:08:53,140 --> 00:09:01,780
gonna get predictable random non random

178
00:08:57,060 --> 00:09:03,550
whatever don't do that well let's talk

179
00:09:01,780 --> 00:09:05,949
about some encryption algorithms there

180
00:09:03,550 --> 00:09:08,319
is a very very secure extremely secure

181
00:09:05,950 --> 00:09:10,660
an extremely simple algorithm called

182
00:09:08,320 --> 00:09:14,100
one-time pad and it works like this

183
00:09:10,660 --> 00:09:17,380
suppose you have a message m and a key K

184
00:09:14,100 --> 00:09:19,960
and the encryption would be a simple XOR

185
00:09:17,380 --> 00:09:24,040
operation of message with the key that's

186
00:09:19,960 --> 00:09:27,850
it and decryption is a similar basic

187
00:09:24,040 --> 00:09:33,550
operation you just XOR ciphertext with

188
00:09:27,850 --> 00:09:36,850
the key here's an example it's very

189
00:09:33,550 --> 00:09:38,410
secure because it was again I think

190
00:09:36,850 --> 00:09:40,420
there is a theorem of some kind that

191
00:09:38,410 --> 00:09:46,449
that says that it's secure and it was

192
00:09:40,420 --> 00:09:49,780
proven but there is a one-one issue with

193
00:09:46,450 --> 00:09:52,450
this algorithm is if the key has to be

194
00:09:49,780 --> 00:09:54,250
as long as the data so if you encrypt a

195
00:09:52,450 --> 00:09:56,350
gigabyte of data you gotta have a

196
00:09:54,250 --> 00:09:57,550
gigabyte long key and you gotta store it

197
00:09:56,350 --> 00:10:00,970
somewhere you gotta share it with

198
00:09:57,550 --> 00:10:03,180
someone so it's very impractical another

199
00:10:00,970 --> 00:10:08,020
issue with this algorithm is in the name

200
00:10:03,180 --> 00:10:09,969
it's called one-time pad but why so

201
00:10:08,020 --> 00:10:12,760
let's see what happens when we encrypt

202
00:10:09,970 --> 00:10:17,020
two messages with the same key message 1

203
00:10:12,760 --> 00:10:22,300
and message T now if we XOR these two

204
00:10:17,020 --> 00:10:25,300
ciphertext the DTO to the properties of

205
00:10:22,300 --> 00:10:29,530
XOR operation these two keys will cancel

206
00:10:25,300 --> 00:10:31,510
out and XOR of ciphertext is equal to

207
00:10:29,530 --> 00:10:36,250
the XOR of the original plaintext

208
00:10:31,510 --> 00:10:40,240
messages and this is obviously not very

209
00:10:36,250 --> 00:10:43,150
good we cannot reuse keys and the more

210
00:10:40,240 --> 00:10:45,340
messages we the more ciphertext we can

211
00:10:43,150 --> 00:10:50,930
intercept the more data we can gather

212
00:10:45,340 --> 00:10:55,370
from something like this so

213
00:10:50,930 --> 00:10:56,750
since the key for one time pad well what

214
00:10:55,370 --> 00:11:01,240
the pad is in practical because of its

215
00:10:56,750 --> 00:11:04,550
key a requirement we use stream ciphers

216
00:11:01,240 --> 00:11:07,420
stream cipher is using a short key or a

217
00:11:04,550 --> 00:11:12,020
lot relatively short maybe 16 bytes and

218
00:11:07,420 --> 00:11:16,699
it's giving it to a key stream generator

219
00:11:12,020 --> 00:11:18,770
function G that takes that key as

220
00:11:16,700 --> 00:11:23,540
basically as a seed and generates as a

221
00:11:18,770 --> 00:11:25,310
stream of pseudo-random data and our

222
00:11:23,540 --> 00:11:28,760
encryption operation is the same as a

223
00:11:25,310 --> 00:11:31,520
one-time pad is just XOR and decryption

224
00:11:28,760 --> 00:11:34,310
is XOR so it's basically one-time paired

225
00:11:31,520 --> 00:11:36,650
with a different kind of key but it's

226
00:11:34,310 --> 00:11:41,300
it's much better because we can manage

227
00:11:36,650 --> 00:11:44,120
short keys but again we cannot reuse

228
00:11:41,300 --> 00:11:46,250
these keys with stream ciphers well

229
00:11:44,120 --> 00:11:49,130
there is an asterisk here because in

230
00:11:46,250 --> 00:11:51,680
some modern implementations of of modern

231
00:11:49,130 --> 00:11:55,010
key stream ciphers you can actually

232
00:11:51,680 --> 00:11:57,439
reuse the keys because they introduce

233
00:11:55,010 --> 00:12:01,069
randomness through some other means but

234
00:11:57,440 --> 00:12:04,550
in in its pure implementation and with

235
00:12:01,070 --> 00:12:06,470
old algorithms like rc4 this was the

236
00:12:04,550 --> 00:12:10,599
case you cannot reuse keys so let's see

237
00:12:06,470 --> 00:12:10,600
what happens when when you reuse the key

238
00:12:15,750 --> 00:12:24,870
I have a couple example but I have an

239
00:12:23,010 --> 00:12:27,390
image of me cool picture

240
00:12:24,870 --> 00:12:30,090
and another cool picture of a smiley

241
00:12:27,390 --> 00:12:33,000
face there's both images are the same

242
00:12:30,090 --> 00:12:36,300
dimensions and I'm gonna encrypt them

243
00:12:33,000 --> 00:12:38,700
both with the same key using a stream

244
00:12:36,300 --> 00:12:41,300
cipher called rc4 and let's see what

245
00:12:38,700 --> 00:12:41,300
happens after that

246
00:12:41,870 --> 00:12:53,910
hi my cool script so I've got you this

247
00:12:50,670 --> 00:12:55,979
is the result of one picture being

248
00:12:53,910 --> 00:12:59,040
encrypted and this is the other pink

249
00:12:55,980 --> 00:13:02,990
picture encrypted completely random

250
00:12:59,040 --> 00:13:06,689
right can gather any data from here

251
00:13:02,990 --> 00:13:11,970
well what if we give the feed these two

252
00:13:06,690 --> 00:13:15,420
images the encrypted images to graphics

253
00:13:11,970 --> 00:13:22,200
editor so this graphics editor lets me

254
00:13:15,420 --> 00:13:25,319
do a pretty cool thing I can add I can

255
00:13:22,200 --> 00:13:33,240
overlay the two images as layers right

256
00:13:25,320 --> 00:13:34,050
and then I can select see if I can make

257
00:13:33,240 --> 00:13:37,410
a little larger

258
00:13:34,050 --> 00:13:41,370
I can select select a layer operation

259
00:13:37,410 --> 00:13:43,490
and one of them is XOR so if we just

260
00:13:41,370 --> 00:13:45,990
exported two layers

261
00:13:43,490 --> 00:13:49,770
it doesn't align really well but you

262
00:13:45,990 --> 00:13:51,900
know as a as humans we can immediately

263
00:13:49,770 --> 00:13:53,480
see that something is wrong with this

264
00:13:51,900 --> 00:13:58,079
encryption right

265
00:13:53,480 --> 00:14:02,280
now what what if we as attacker know one

266
00:13:58,080 --> 00:14:04,680
of these plaintext messages so let's

267
00:14:02,280 --> 00:14:07,680
let's say when we know that one of these

268
00:14:04,680 --> 00:14:11,699
messages was was a that smiley face so

269
00:14:07,680 --> 00:14:13,500
I'm gonna give it to my editor I'm gonna

270
00:14:11,700 --> 00:14:21,170
add that smiley face as another layer

271
00:14:13,500 --> 00:14:23,820
and I'm going to XOR it with that so

272
00:14:21,170 --> 00:14:27,209
having these two layers of seemingly

273
00:14:23,820 --> 00:14:29,700
random stuff and a smiley face I get a

274
00:14:27,209 --> 00:14:38,979
picture of me how cool is that

275
00:14:29,700 --> 00:14:40,930
all right well I don't know so in real

276
00:14:38,980 --> 00:14:44,649
world though this is this might not be

277
00:14:40,930 --> 00:14:47,680
as simple right you might have to do

278
00:14:44,649 --> 00:14:49,050
some kind of really smart analysis but

279
00:14:47,680 --> 00:14:53,140
you get the idea

280
00:14:49,050 --> 00:14:54,849
reusing the key is not good thing okay

281
00:14:53,140 --> 00:14:58,899
let's talk about block ciphers

282
00:14:54,850 --> 00:15:02,020
unlike stream ciphers that operate with

283
00:14:58,899 --> 00:15:03,910
bytes or maybe even bits block cipher

284
00:15:02,020 --> 00:15:06,790
operates with blocks so you feed it a

285
00:15:03,910 --> 00:15:09,670
block of data normally it's maybe 16

286
00:15:06,790 --> 00:15:14,490
bytes it does a permutation based on the

287
00:15:09,670 --> 00:15:19,000
key and it it gives you another block so

288
00:15:14,490 --> 00:15:21,760
that's how the primitive works but your

289
00:15:19,000 --> 00:15:24,790
data is not always as short as the block

290
00:15:21,760 --> 00:15:28,110
size right in most cases it's not so

291
00:15:24,790 --> 00:15:32,770
what do we do in this case the pretty

292
00:15:28,110 --> 00:15:34,450
like straightforward thing to do is to

293
00:15:32,770 --> 00:15:38,589
encrypt each one of the blocks

294
00:15:34,450 --> 00:15:41,080
individually and you get a ciphertext

295
00:15:38,589 --> 00:15:44,080
everything is cool well apparently it's

296
00:15:41,080 --> 00:15:47,320
not and you can guess that the same

297
00:15:44,080 --> 00:15:50,560
plaintext block well if it's somewhere

298
00:15:47,320 --> 00:15:53,110
in the file we will encrypt to the same

299
00:15:50,560 --> 00:15:55,560
ciphertext so by looking at the

300
00:15:53,110 --> 00:15:59,680
ciphertext you can see the patterns

301
00:15:55,560 --> 00:16:03,369
which is not good as we know that good

302
00:15:59,680 --> 00:16:06,069
encryption will result in in data that

303
00:16:03,370 --> 00:16:08,279
indistinguishable from random noise and

304
00:16:06,070 --> 00:16:14,459
this is not random noise anymore

305
00:16:08,279 --> 00:16:14,459
and let's see how how non-random that is

306
00:16:16,740 --> 00:16:26,250
okay I have another visual example this

307
00:16:22,209 --> 00:16:30,239
is an image screenshot of my title slide

308
00:16:26,250 --> 00:16:30,240
so I'm going to encrypt it

309
00:16:32,290 --> 00:16:37,599
so this script encrypts it twice one

310
00:16:34,930 --> 00:16:40,479
it's using that ECB mode that we just

311
00:16:37,600 --> 00:16:42,160
talked about and it all it's also used

312
00:16:40,480 --> 00:16:43,950
in CBC mode which we have not discussed

313
00:16:42,160 --> 00:16:52,930
yet so let's see how they differ

314
00:16:43,950 --> 00:16:56,200
visually this is the image encrypted

315
00:16:52,930 --> 00:16:58,150
with CBC mode completely random and this

316
00:16:56,200 --> 00:17:00,580
is the image included with encrypted

317
00:16:58,150 --> 00:17:04,900
with ECB mode where each block encrypts

318
00:17:00,580 --> 00:17:07,750
individually and although it's not

319
00:17:04,900 --> 00:17:10,600
looking like exactly like the original

320
00:17:07,750 --> 00:17:14,560
image again we as humans can immediately

321
00:17:10,599 --> 00:17:16,569
see you can immediately get information

322
00:17:14,560 --> 00:17:19,929
from here you know you can read the text

323
00:17:16,569 --> 00:17:29,050
because it's an image I was cheating but

324
00:17:19,930 --> 00:17:31,450
you know so not a good idea so what's

325
00:17:29,050 --> 00:17:36,490
what's the CBC mode so CBC mode

326
00:17:31,450 --> 00:17:39,100
introduces randomness and it doesn't

327
00:17:36,490 --> 00:17:40,930
matter what the blocks of plaintext

328
00:17:39,100 --> 00:17:42,370
aren't going to repeat does really

329
00:17:40,930 --> 00:17:45,640
matter because everything is going to

330
00:17:42,370 --> 00:17:48,219
look like random after encryption so the

331
00:17:45,640 --> 00:17:50,830
previous ciphertext block is XOR with

332
00:17:48,220 --> 00:17:53,470
current plain text before encryption and

333
00:17:50,830 --> 00:17:57,520
that's how that randomness is propagated

334
00:17:53,470 --> 00:17:59,650
all the way through the data we the

335
00:17:57,520 --> 00:18:04,000
first block though we don't have that

336
00:17:59,650 --> 00:18:07,030
previous ciphertext so what we use is a

337
00:18:04,000 --> 00:18:12,280
thing called initialization vector or IV

338
00:18:07,030 --> 00:18:16,800
and IV is just a random just just some

339
00:18:12,280 --> 00:18:20,830
random data just which is equal to the

340
00:18:16,800 --> 00:18:24,090
size of the block and it's not secret we

341
00:18:20,830 --> 00:18:26,290
transmit it with the ciphertext openly

342
00:18:24,090 --> 00:18:30,520
but we just need it for the for this

343
00:18:26,290 --> 00:18:33,250
randomness the decryption is the

344
00:18:30,520 --> 00:18:35,200
opposite operation so when we decrypt

345
00:18:33,250 --> 00:18:38,230
the first block we first apply that

346
00:18:35,200 --> 00:18:41,140
primitive reach the crypts and then we

347
00:18:38,230 --> 00:18:43,870
XOR it with IV the second block we

348
00:18:41,140 --> 00:18:50,530
decrypt that block and XOR it with c1

349
00:18:43,870 --> 00:18:55,959
and so on this one we XOR with c2 some

350
00:18:50,530 --> 00:18:59,080
people think that have an idea since I

351
00:18:55,960 --> 00:19:01,630
already know the key and whoever is

352
00:18:59,080 --> 00:19:05,409
going to decrypt this message later

353
00:19:01,630 --> 00:19:09,130
knows the key why cannot can I just

354
00:19:05,410 --> 00:19:10,510
can't I just use the key as IV I don't

355
00:19:09,130 --> 00:19:13,020
have to transmit it right because it's

356
00:19:10,510 --> 00:19:16,540
known to both to encrypt and decrypt

357
00:19:13,020 --> 00:19:19,629
I'll just feed it here and it will

358
00:19:16,540 --> 00:19:23,770
definitely introduce randomness well

359
00:19:19,630 --> 00:19:26,830
it's not a good idea because under some

360
00:19:23,770 --> 00:19:29,110
assumptions this kind of stuff is easily

361
00:19:26,830 --> 00:19:32,740
broken and broken to the point that you

362
00:19:29,110 --> 00:19:33,550
get the original encryption key not just

363
00:19:32,740 --> 00:19:36,400
original data

364
00:19:33,550 --> 00:19:39,040
so suppose we intercept a message of

365
00:19:36,400 --> 00:19:40,570
three ciphertext blocks or maybe more

366
00:19:39,040 --> 00:19:43,090
ciphertext block doesn't really matter

367
00:19:40,570 --> 00:19:47,350
because we only use the first one you

368
00:19:43,090 --> 00:19:50,889
see one we put it here then the next

369
00:19:47,350 --> 00:19:53,169
block we just put all zeroes 16 zeroes

370
00:19:50,890 --> 00:19:57,090
or eight zeros whatever your cipher is

371
00:19:53,170 --> 00:20:00,430
and the third block will repeat c1 again

372
00:19:57,090 --> 00:20:00,760
well this looks funny but here's how it

373
00:20:00,430 --> 00:20:05,350
works

374
00:20:00,760 --> 00:20:07,360
if we have an assault if we if we assume

375
00:20:05,350 --> 00:20:09,399
that we can give this to the Decrypter

376
00:20:07,360 --> 00:20:12,879
and they'll try to decrypt it and tell

377
00:20:09,400 --> 00:20:15,580
us the result then see what happens the

378
00:20:12,880 --> 00:20:19,330
first block is decrypted and X sort with

379
00:20:15,580 --> 00:20:21,879
IV and IV happens to be the key so it's

380
00:20:19,330 --> 00:20:23,679
XOR with the key the second block is

381
00:20:21,880 --> 00:20:27,100
decrypted to garbage and we don't care

382
00:20:23,680 --> 00:20:30,070
about it the third block is decrypted

383
00:20:27,100 --> 00:20:33,969
and X sort with the previous block which

384
00:20:30,070 --> 00:20:36,669
is all zeros so on the right side here

385
00:20:33,970 --> 00:20:39,190
we have the result of the decryption of

386
00:20:36,670 --> 00:20:44,430
Block C 1 and here is the same thing

387
00:20:39,190 --> 00:20:45,640
exhort K so if we now XOR these two

388
00:20:44,430 --> 00:20:54,390
plaintext

389
00:20:45,640 --> 00:20:58,110
we get the encryption key okay let's see

390
00:20:54,390 --> 00:21:05,610
I actually have a web application for

391
00:20:58,110 --> 00:21:09,050
this so this application is giving you a

392
00:21:05,610 --> 00:21:12,990
session cookie which is encrypted JSON

393
00:21:09,050 --> 00:21:17,550
and let's suppose the the source is open

394
00:21:12,990 --> 00:21:20,160
we can see how it works and what's doing

395
00:21:17,550 --> 00:21:22,889
but we did we have no idea about what

396
00:21:20,160 --> 00:21:25,820
the encryption key is right so here's

397
00:21:22,890 --> 00:21:25,820
our encrypted cookie

398
00:21:27,830 --> 00:21:42,659
let me so first thing we need to do is

399
00:21:37,340 --> 00:21:46,139
feed that cookie to our first first step

400
00:21:42,660 --> 00:21:48,000
is to build that that funny message with

401
00:21:46,140 --> 00:21:53,220
zeros in the middle which are

402
00:21:48,000 --> 00:21:56,550
represented by a a in base64 now we give

403
00:21:53,220 --> 00:21:58,080
it back to the application and since

404
00:21:56,550 --> 00:22:01,080
it's a session cookie it expects a good

405
00:21:58,080 --> 00:22:02,520
stuff from us i refresh the page and it

406
00:22:01,080 --> 00:22:04,649
says bye

407
00:22:02,520 --> 00:22:06,750
data isn't valid I could not decrypt it

408
00:22:04,650 --> 00:22:09,150
sorry here is what you gave me here is

409
00:22:06,750 --> 00:22:12,510
what I was able to to get this is the

410
00:22:09,150 --> 00:22:18,480
result of the encryption great we say

411
00:22:12,510 --> 00:22:24,090
great let's just use that our second

412
00:22:18,480 --> 00:22:26,670
step is this this script analyzed this

413
00:22:24,090 --> 00:22:31,439
message and told us the cook encryption

414
00:22:26,670 --> 00:22:33,240
key is this well let's check it now the

415
00:22:31,440 --> 00:22:36,240
server is running on the same machine

416
00:22:33,240 --> 00:22:39,090
obviously so I can see its session key

417
00:22:36,240 --> 00:22:42,270
which is stored in the file and of

418
00:22:39,090 --> 00:22:48,120
course I should use something other than

419
00:22:42,270 --> 00:22:51,510
cat and the key is exactly C 4 F 1 is 0

420
00:22:48,120 --> 00:22:58,229
and B and so on so we broke the

421
00:22:51,510 --> 00:23:02,270
encryption key alright so don't use key

422
00:22:58,230 --> 00:23:05,150
as IV now

423
00:23:02,270 --> 00:23:08,420
not only your message is normally not as

424
00:23:05,150 --> 00:23:10,760
short as blog it's normally not the

425
00:23:08,420 --> 00:23:12,860
length of it is normally not a multiple

426
00:23:10,760 --> 00:23:15,350
of the block so what do you do in this

427
00:23:12,860 --> 00:23:19,610
case and because the block cipher only

428
00:23:15,350 --> 00:23:21,740
parades on this fixed length in this

429
00:23:19,610 --> 00:23:24,500
case this V is padding so let's say we

430
00:23:21,740 --> 00:23:27,370
have 10 bytes we want to encrypt we

431
00:23:24,500 --> 00:23:31,250
cannot just give it to the block cipher

432
00:23:27,370 --> 00:23:33,860
we need to Pat it and pattern is just

433
00:23:31,250 --> 00:23:36,470
adding the missing number of bytes at

434
00:23:33,860 --> 00:23:40,459
the end in this case we we are missing 6

435
00:23:36,470 --> 00:23:45,100
bytes and we adding 6 of them each one

436
00:23:40,460 --> 00:23:48,860
of them is 636 that's the convention

437
00:23:45,100 --> 00:23:50,719
cool and so this can be encrypted and

438
00:23:48,860 --> 00:23:53,770
this can be later decrypted and what

439
00:23:50,720 --> 00:23:56,630
usually on the decryption side the

440
00:23:53,770 --> 00:23:58,340
program or the L or the implementation

441
00:23:56,630 --> 00:24:02,330
of the algorithm checks whether the

442
00:23:58,340 --> 00:24:06,560
padding was correct which may lead to

443
00:24:02,330 --> 00:24:08,980
attack hold pairing Oracle so if we

444
00:24:06,560 --> 00:24:13,370
receive ciphertext and decrypt it and

445
00:24:08,980 --> 00:24:16,730
some people assume that decryption with

446
00:24:13,370 --> 00:24:19,040
the wrong key will fail it's not gonna

447
00:24:16,730 --> 00:24:21,310
fail the krypter will decrypt anything

448
00:24:19,040 --> 00:24:24,020
you throw at it you can throw garbage

449
00:24:21,310 --> 00:24:26,270
ciphertext garbage key it will produce

450
00:24:24,020 --> 00:24:32,150
something it's just it's just a

451
00:24:26,270 --> 00:24:34,750
permutation but then you check your

452
00:24:32,150 --> 00:24:39,650
pairing and it's wrong so in this case

453
00:24:34,750 --> 00:24:41,210
it's feels like the right thing to do

454
00:24:39,650 --> 00:24:45,250
would be to let user know that the

455
00:24:41,210 --> 00:24:47,570
message was corrupted maybe so you

456
00:24:45,250 --> 00:24:51,590
produce an error message if the pairing

457
00:24:47,570 --> 00:24:55,129
was wrong and that leads to an attack

458
00:24:51,590 --> 00:24:56,659
called parent Oracle and this attack is

459
00:24:55,130 --> 00:24:59,390
out of I'm not gonna explain how it

460
00:24:56,660 --> 00:25:05,000
works it's out of scope of this talk but

461
00:24:59,390 --> 00:25:07,670
basically you modify bit by bit 256

462
00:25:05,000 --> 00:25:11,510
tries per byte and you can decrypt the

463
00:25:07,670 --> 00:25:13,680
entire message and although we're not

464
00:25:11,510 --> 00:25:18,810
gonna go into many details I have a demo

465
00:25:13,680 --> 00:25:21,270
that which is really cool I think so

466
00:25:18,810 --> 00:25:23,970
here's another application that accepts

467
00:25:21,270 --> 00:25:26,730
a message from the user encrypted

468
00:25:23,970 --> 00:25:30,690
message and it gives me an example here

469
00:25:26,730 --> 00:25:34,020
I don't know what it's really rude

470
00:25:30,690 --> 00:25:37,170
though I don't have the key so I cannot

471
00:25:34,020 --> 00:25:38,790
decrypt it well if I try to refresh the

472
00:25:37,170 --> 00:25:40,680
page it gives me a new message every

473
00:25:38,790 --> 00:25:43,139
time actually the same message is just

474
00:25:40,680 --> 00:25:46,620
it's using a random IV so that's why

475
00:25:43,140 --> 00:25:49,560
it's looking different so if I click

476
00:25:46,620 --> 00:25:52,679
here it's an example the application

477
00:25:49,560 --> 00:25:57,720
accepted that message told me thank you

478
00:25:52,680 --> 00:26:00,690
very much okay what if I try to modify

479
00:25:57,720 --> 00:26:05,730
that last bite of that message it was -

480
00:26:00,690 --> 00:26:10,920
I'm gonna set it to 1 and I sent it an

481
00:26:05,730 --> 00:26:13,080
application gave me an error cool which

482
00:26:10,920 --> 00:26:20,900
tells me that I could probably run my

483
00:26:13,080 --> 00:26:20,899
padding Oracle against it let's see

484
00:26:25,750 --> 00:26:33,760
here's Michael exploit I'm just given it

485
00:26:30,150 --> 00:26:36,250
this exploit script this URL and it has

486
00:26:33,760 --> 00:26:39,990
no other information it just is just

487
00:26:36,250 --> 00:26:43,030
gonna go to this server and try to send

488
00:26:39,990 --> 00:26:46,330
different things it's gonna try many

489
00:26:43,030 --> 00:26:48,490
things and here is the server log it's

490
00:26:46,330 --> 00:26:51,820
basically accepting hundreds maybe

491
00:26:48,490 --> 00:26:55,060
thousands of requests but at the end

492
00:26:51,820 --> 00:27:00,040
just in a few seconds it was able to

493
00:26:55,060 --> 00:27:00,639
decrypt the entire message so this stuff

494
00:27:00,040 --> 00:27:03,670
is real

495
00:27:00,640 --> 00:27:06,940
you know when we read about these things

496
00:27:03,670 --> 00:27:10,800
with sometimes we think you know yeah

497
00:27:06,940 --> 00:27:13,900
these are theoretical attacks well no

498
00:27:10,800 --> 00:27:14,980
you can you can actually use them

499
00:27:13,900 --> 00:27:18,220
sometimes

500
00:27:14,980 --> 00:27:20,410
so yeah just wanted to show you what

501
00:27:18,220 --> 00:27:23,260
what's happening on the back end is just

502
00:27:20,410 --> 00:27:25,720
processing the message is doing the

503
00:27:23,260 --> 00:27:28,150
decryption and then this padding stuff

504
00:27:25,720 --> 00:27:30,340
and then it's just catching the error I

505
00:27:28,150 --> 00:27:33,040
mean this is like normal way to do

506
00:27:30,340 --> 00:27:33,520
things so if there's a errors of some

507
00:27:33,040 --> 00:27:35,620
kind

508
00:27:33,520 --> 00:27:39,430
this probably user is giving us garbage

509
00:27:35,620 --> 00:27:41,679
and they not authorized to perform

510
00:27:39,430 --> 00:27:47,020
operations so normal to give an error

511
00:27:41,680 --> 00:27:49,480
like this or I'll be careful okay so a

512
00:27:47,020 --> 00:27:52,629
few examples so far were based on the

513
00:27:49,480 --> 00:27:54,970
fact that our vulnerable applications

514
00:27:52,630 --> 00:27:56,620
were not checking the integrity so I can

515
00:27:54,970 --> 00:27:58,840
pet an Oracle attack we modified that

516
00:27:56,620 --> 00:28:00,550
message bit by bit and we threw it at

517
00:27:58,840 --> 00:28:04,090
the application it was trying to decrypt

518
00:28:00,550 --> 00:28:07,930
them which apparently is not a good idea

519
00:28:04,090 --> 00:28:10,629
it should have just rejected because it

520
00:28:07,930 --> 00:28:15,790
should have somehow determined that the

521
00:28:10,630 --> 00:28:17,890
message has been modified well yeah we

522
00:28:15,790 --> 00:28:20,050
give it garbage it process it but what

523
00:28:17,890 --> 00:28:23,020
about not giving a garbage but giving it

524
00:28:20,050 --> 00:28:25,600
something that you control so for

525
00:28:23,020 --> 00:28:27,940
example you know that somebody is

526
00:28:25,600 --> 00:28:31,240
sending someone a message sign $1.00 to

527
00:28:27,940 --> 00:28:35,020
Alice and they encrypt it and all you

528
00:28:31,240 --> 00:28:37,630
have is that encrypted thing the

529
00:28:35,020 --> 00:28:39,879
ciphertext what if you can modify that

530
00:28:37,630 --> 00:28:42,940
ciphertext without knowing the key

531
00:28:39,880 --> 00:28:46,300
so when the other person decrypts it

532
00:28:42,940 --> 00:28:48,490
they get what you that what you want the

533
00:28:46,300 --> 00:28:50,649
message to be so instead of sending

534
00:28:48,490 --> 00:28:53,820
hundred dollars to Alice the poor Bob

535
00:28:50,650 --> 00:28:59,140
will send hard dollars to Mallory

536
00:28:53,820 --> 00:29:01,990
apparently this is possible and a simple

537
00:28:59,140 --> 00:29:04,660
example of this is with stream cipher

538
00:29:01,990 --> 00:29:07,990
using a bit flippant attack suppose our

539
00:29:04,660 --> 00:29:09,760
message is guest it's a string so our

540
00:29:07,990 --> 00:29:14,410
encryption looks like this remember

541
00:29:09,760 --> 00:29:17,860
right the attacker will modify these

542
00:29:14,410 --> 00:29:21,610
cipher text that they intercepted by XOR

543
00:29:17,860 --> 00:29:25,469
innovate with original plaintext and XOR

544
00:29:21,610 --> 00:29:29,949
in it with the new message that they

545
00:29:25,470 --> 00:29:34,630
that they want to that to be so when

546
00:29:29,950 --> 00:29:36,640
this is decrypted so yeah yeah one this

547
00:29:34,630 --> 00:29:39,430
is decrypted this is the decryption

548
00:29:36,640 --> 00:29:41,770
operation which expands to this right

549
00:29:39,430 --> 00:29:46,270
and it further expands to this and

550
00:29:41,770 --> 00:29:49,090
guests and guests cancel out gia K and

551
00:29:46,270 --> 00:29:51,100
GK castle out and the resultant message

552
00:29:49,090 --> 00:29:53,409
is admin so it seems like a silly

553
00:29:51,100 --> 00:29:56,260
example but what if this message is used

554
00:29:53,410 --> 00:29:59,400
to make access control decision and this

555
00:29:56,260 --> 00:30:11,100
is like your again session cookie

556
00:29:59,400 --> 00:30:11,100
let's take a look me refresh this

557
00:30:13,280 --> 00:30:18,530
all right so in this case again we

558
00:30:16,490 --> 00:30:22,550
assume that the source is open we can

559
00:30:18,530 --> 00:30:23,960
see it we just don't know the key we

560
00:30:22,550 --> 00:30:26,000
know that this application is using a

561
00:30:23,960 --> 00:30:27,980
stream cipher in this case it's also 20

562
00:30:26,000 --> 00:30:29,600
which is a pretty strong modern cipher

563
00:30:27,980 --> 00:30:32,050
which is using a random nonce

564
00:30:29,600 --> 00:30:36,740
so the key we use is no longer possible

565
00:30:32,050 --> 00:30:38,360
and we know the value of the of this

566
00:30:36,740 --> 00:30:44,950
user cookie which is printed right here

567
00:30:38,360 --> 00:30:44,949
but we could have guessed it too easily

568
00:30:45,610 --> 00:30:54,469
all right so I have my bit flippant

569
00:30:50,440 --> 00:31:04,070
exploit I'm giving it that ciphertext

570
00:30:54,470 --> 00:31:09,980
I'm giving it the original value and I

571
00:31:04,070 --> 00:31:14,450
want to give it a new value if I analyze

572
00:31:09,980 --> 00:31:16,790
the code though I see that the date

573
00:31:14,450 --> 00:31:20,620
parameter is not even used by this

574
00:31:16,790 --> 00:31:23,180
application so I can completely skip it

575
00:31:20,620 --> 00:31:25,070
I'm just going to remove it it doesn't

576
00:31:23,180 --> 00:31:31,060
really matter I mean we could keep it

577
00:31:25,070 --> 00:31:35,270
but I'm just gonna do it like this and

578
00:31:31,060 --> 00:31:37,129
here is my new encrypted cookie again I

579
00:31:35,270 --> 00:31:45,230
mean my exploit script didn't do

580
00:31:37,130 --> 00:31:48,850
anything it was just exploring stuff so

581
00:31:45,230 --> 00:31:53,200
I'm given that cookie back to the app

582
00:31:48,850 --> 00:31:56,560
refresh and I'm in the admin interface

583
00:31:53,200 --> 00:31:57,950
well awesome all stream ciphers are easy

584
00:31:56,560 --> 00:32:00,470
sometimes

585
00:31:57,950 --> 00:32:02,030
what about block ciphers apparently bit

586
00:32:00,470 --> 00:32:03,890
flipping attack is possible in block

587
00:32:02,030 --> 00:32:06,649
ciphers as well although it might not

588
00:32:03,890 --> 00:32:11,930
seem as straightforward but let's say

589
00:32:06,650 --> 00:32:13,880
our messages guest and it happens to be

590
00:32:11,930 --> 00:32:18,110
in the first block of our encrypted

591
00:32:13,880 --> 00:32:22,750
message so our ciphertext is the

592
00:32:18,110 --> 00:32:25,760
encryption of that message X sort IV and

593
00:32:22,750 --> 00:32:27,010
due to X or properties these are true as

594
00:32:25,760 --> 00:32:30,289
well

595
00:32:27,010 --> 00:32:32,510
so in this case what we need to do is to

596
00:32:30,289 --> 00:32:34,669
modify the IV we don't modify this

597
00:32:32,510 --> 00:32:36,740
ciphertext modify the IV which is not

598
00:32:34,669 --> 00:32:41,000
secret again it was it's transmitted

599
00:32:36,740 --> 00:32:43,280
along with the ciphertext in open so we

600
00:32:41,000 --> 00:32:46,880
modify it like this very I mean there's

601
00:32:43,280 --> 00:32:50,539
a V right we've seen it before when it's

602
00:32:46,880 --> 00:32:56,570
decrypted the that block is XOR with our

603
00:32:50,539 --> 00:32:59,480
new IV and which expands to this the two

604
00:32:56,570 --> 00:33:04,178
IVs cancel out expensive this two guests

605
00:32:59,480 --> 00:33:04,179
cancel out and we get our admin again

606
00:33:07,480 --> 00:33:18,220
all right let's see if it works yeah so

607
00:33:14,240 --> 00:33:18,220
here's our new encrypted cookie

608
00:33:24,880 --> 00:33:30,910
and I need to give it that ciphertext

609
00:33:27,880 --> 00:33:36,700
again I need to give it the original

610
00:33:30,910 --> 00:33:39,460
data well actually in this case I'm only

611
00:33:36,700 --> 00:33:42,640
concerned about the first block and this

612
00:33:39,460 --> 00:33:52,210
happens to be exactly 16 bytes I'm so

613
00:33:42,640 --> 00:33:57,400
lucky today so I'm going to change this

614
00:33:52,210 --> 00:34:00,130
to admin so it's only modifying IV which

615
00:33:57,400 --> 00:34:02,500
will only go into effect the first block

616
00:34:00,130 --> 00:34:12,870
and when I give it back to the

617
00:34:02,500 --> 00:34:16,360
application I'm the admin again well

618
00:34:12,870 --> 00:34:18,730
this was I mean pretty I mean we got

619
00:34:16,360 --> 00:34:21,540
really lucky here right but in real

620
00:34:18,730 --> 00:34:25,210
world you can still do a lot of damage

621
00:34:21,540 --> 00:34:26,800
even if you're if something you try to

622
00:34:25,210 --> 00:34:30,040
modify it's not exactly the first block

623
00:34:26,800 --> 00:34:32,399
it's somewhere else yeah there are there

624
00:34:30,040 --> 00:34:38,560
are ways to do real harm

625
00:34:32,399 --> 00:34:41,589
so integrity is extremely important in

626
00:34:38,560 --> 00:34:45,159
cryptography we have a thing called

627
00:34:41,590 --> 00:34:46,840
authenticated encryption which means in

628
00:34:45,159 --> 00:34:48,730
addition to encryption the message in

629
00:34:46,840 --> 00:34:51,429
hide in it making it secret

630
00:34:48,730 --> 00:34:53,770
we also authenticate it so when somebody

631
00:34:51,429 --> 00:34:56,168
is trying to decrypt it they are able to

632
00:34:53,770 --> 00:35:00,610
determine whether it has been tampered

633
00:34:56,168 --> 00:35:04,629
with or not so during the encryption we

634
00:35:00,610 --> 00:35:07,240
just we just provide plaintext and the

635
00:35:04,630 --> 00:35:09,610
key and the output of such authenticated

636
00:35:07,240 --> 00:35:12,089
encryption will be our cipher text and

637
00:35:09,610 --> 00:35:15,160
some kind of authentication tag and

638
00:35:12,090 --> 00:35:18,640
decryption will validate that

639
00:35:15,160 --> 00:35:20,890
authentication tag and if it sees

640
00:35:18,640 --> 00:35:24,509
something weird like it doesn't match

641
00:35:20,890 --> 00:35:27,520
what it calculated it should just reject

642
00:35:24,510 --> 00:35:32,349
the message completely not even try to

643
00:35:27,520 --> 00:35:35,410
decrypt it okay

644
00:35:32,349 --> 00:35:39,729
and the last thing for today I want to

645
00:35:35,410 --> 00:35:42,098
talk about is storing passwords we have

646
00:35:39,729 --> 00:35:46,200
a couple of rules rule number one no

647
00:35:42,099 --> 00:35:48,489
plaintext passwords yes

648
00:35:46,200 --> 00:35:52,649
rule number two no decrypt able

649
00:35:48,489 --> 00:35:56,079
passwords right because no matter how

650
00:35:52,650 --> 00:35:58,960
well you do it sooner or later your keys

651
00:35:56,079 --> 00:36:01,509
are gonna be leaked or gonna get to the

652
00:35:58,960 --> 00:36:04,089
wrong hands and somebody's gonna get the

653
00:36:01,509 --> 00:36:09,430
passwords rule number three no one way

654
00:36:04,089 --> 00:36:11,229
hash right I mean what I thought

655
00:36:09,430 --> 00:36:12,269
everybody was saying that one way hash

656
00:36:11,229 --> 00:36:15,549
is the way to do it

657
00:36:12,269 --> 00:36:17,558
well yes but some people take it

658
00:36:15,549 --> 00:36:20,319
literally and they use it use a hash

659
00:36:17,559 --> 00:36:22,960
function so they use something like

660
00:36:20,319 --> 00:36:26,109
Chateau which is not a good idea because

661
00:36:22,960 --> 00:36:28,509
of its speed so hash functions are cheap

662
00:36:26,109 --> 00:36:34,538
they're fast which makes brute-force

663
00:36:28,509 --> 00:36:36,759
attacks possible in contrast key

664
00:36:34,539 --> 00:36:40,119
derivation function Zork ADF's are

665
00:36:36,759 --> 00:36:44,099
expensive they take a lot of time maybe

666
00:36:40,119 --> 00:36:47,799
a lot of memory or maybe both and they

667
00:36:44,099 --> 00:36:50,529
when you implement them when you use

668
00:36:47,799 --> 00:36:51,210
them you want them to be as slow as

669
00:36:50,529 --> 00:36:55,089
possible

670
00:36:51,210 --> 00:36:59,859
like whatever slowness you can get is

671
00:36:55,089 --> 00:37:02,078
the way to go and I just wanted I mean

672
00:36:59,859 --> 00:37:05,288
some people yeah kind of standard but

673
00:37:02,079 --> 00:37:07,150
they don't really appreciate how huge

674
00:37:05,289 --> 00:37:12,640
the difference is between something like

675
00:37:07,150 --> 00:37:19,960
chateau and KDF so I just wanted to run

676
00:37:12,640 --> 00:37:26,799
a very short demo here this script

677
00:37:19,960 --> 00:37:31,059
generates a password hash and first it

678
00:37:26,799 --> 00:37:37,630
does using sha and I can use John the

679
00:37:31,059 --> 00:37:42,530
Ripper to to brute-force that using a

680
00:37:37,630 --> 00:37:44,540
using a dictionary boom

681
00:37:42,530 --> 00:37:48,830
took a fraction of a second my password

682
00:37:44,540 --> 00:37:52,850
is Pink Floyd and John the Ripper tells

683
00:37:48,830 --> 00:37:59,000
me that it was able to try 60,000

684
00:37:52,850 --> 00:38:02,900
passwords per second not bad let's

685
00:37:59,000 --> 00:38:04,970
repeat this with pbkdf2 function which

686
00:38:02,900 --> 00:38:07,340
is by the way not the best key duration

687
00:38:04,970 --> 00:38:11,379
derivation function these days but I'm

688
00:38:07,340 --> 00:38:11,380
using it here just because it was easy

689
00:38:12,880 --> 00:38:20,660
so let's try to brute-force it now and

690
00:38:17,620 --> 00:38:21,020
as you can tell it's taken much longer

691
00:38:20,660 --> 00:38:25,009
now

692
00:38:21,020 --> 00:38:32,120
it ran open threads eight eight open

693
00:38:25,010 --> 00:38:35,480
eight frets and okay well it was able to

694
00:38:32,120 --> 00:38:38,750
crack it the password is Pink Floyd but

695
00:38:35,480 --> 00:38:41,420
it was only able to process 85 passwords

696
00:38:38,750 --> 00:38:44,360
per second versus 60,000 passwords per

697
00:38:41,420 --> 00:38:45,650
second so I'm in this case it would be

698
00:38:44,360 --> 00:38:48,920
really impractical if your password is

699
00:38:45,650 --> 00:38:52,010
strong and maybe not in the dictionary

700
00:38:48,920 --> 00:38:57,140
file at all which is what we should all

701
00:38:52,010 --> 00:38:59,780
strive for so takeaways if you're a

702
00:38:57,140 --> 00:39:02,029
breaker you need to understand the

703
00:38:59,780 --> 00:39:05,090
cryptographic concept not just in

704
00:39:02,030 --> 00:39:07,310
general terms but on technical level you

705
00:39:05,090 --> 00:39:10,000
might want to go a little deeper to

706
00:39:07,310 --> 00:39:12,740
really understand what's going on

707
00:39:10,000 --> 00:39:15,080
examining the industry guidelines and

708
00:39:12,740 --> 00:39:17,839
understanding them and understanding why

709
00:39:15,080 --> 00:39:21,580
they were given at some point in time is

710
00:39:17,840 --> 00:39:26,450
very important to you know things like

711
00:39:21,580 --> 00:39:29,150
again not using keys IV right there's

712
00:39:26,450 --> 00:39:30,970
probably a reason for that expand on

713
00:39:29,150 --> 00:39:35,450
other people's work there are some tools

714
00:39:30,970 --> 00:39:39,819
there is my really bad demo software

715
00:39:35,450 --> 00:39:41,540
that you can try if you are a builder

716
00:39:39,820 --> 00:39:44,540
again you need to understand the

717
00:39:41,540 --> 00:39:46,580
concepts and your tasks so you need to

718
00:39:44,540 --> 00:39:49,460
know what to use when and with what

719
00:39:46,580 --> 00:39:51,610
parameters because if you use a hammer

720
00:39:49,460 --> 00:39:53,750
where you you need to use a chainsaw

721
00:39:51,610 --> 00:39:54,960
it's probably not going to work really

722
00:39:53,750 --> 00:39:57,190
well

723
00:39:54,960 --> 00:40:01,540
follow the guidelines you don't have to

724
00:39:57,190 --> 00:40:03,820
understand them but those fibs check

725
00:40:01,540 --> 00:40:08,440
about check box boxes sometimes are

726
00:40:03,820 --> 00:40:09,850
useful although I'm smiling and learn

727
00:40:08,440 --> 00:40:13,630
from other people's mistakes and don't

728
00:40:09,850 --> 00:40:15,190
make them again so for further learning

729
00:40:13,630 --> 00:40:17,140
I just wanted to give you a couple of

730
00:40:15,190 --> 00:40:20,200
recommendations I'm not affiliated with

731
00:40:17,140 --> 00:40:22,629
this at all but there is a really nice

732
00:40:20,200 --> 00:40:25,060
course on Coursera called cryptography

733
00:40:22,630 --> 00:40:28,750
one it's awesome awesome awesome course

734
00:40:25,060 --> 00:40:32,020
highly recommended the and the second

735
00:40:28,750 --> 00:40:34,120
one is crypto 101 online book it's

736
00:40:32,020 --> 00:40:36,390
basically a PDF that you can download it

737
00:40:34,120 --> 00:40:40,290
and read it still needs some work but

738
00:40:36,390 --> 00:40:43,060
most of the great stuff is already there

739
00:40:40,290 --> 00:40:46,660
so like I promised my code is on github

740
00:40:43,060 --> 00:40:49,110
feel free to fork it clone it give it a

741
00:40:46,660 --> 00:40:52,330
try let me know if it doesn't work and

742
00:40:49,110 --> 00:40:55,780
you can contact me and thank you very

743
00:40:52,330 --> 00:40:57,960
much and I guess we have time for

744
00:40:55,780 --> 00:40:57,960
questions

745
00:40:58,520 --> 00:41:09,009
[Applause]

746
00:41:10,930 --> 00:41:22,250
any questions no questions online

747
00:41:13,720 --> 00:41:26,060
questions these slides the question is

748
00:41:22,250 --> 00:41:31,850
whether the slides online not right now

749
00:41:26,060 --> 00:41:32,759
but I out put them up thank you all

750
00:41:31,850 --> 00:41:37,749
right thank you

751
00:41:32,760 --> 00:41:37,749
[Applause]

