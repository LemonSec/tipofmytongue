1
00:00:00,030 --> 00:00:05,730
we have UJ we will be giving a talk on

2
00:00:03,720 --> 00:00:09,380
off you station please give them your

3
00:00:05,730 --> 00:00:14,900
attention throughout the entire

4
00:00:09,380 --> 00:00:18,480
throughout the entire talk thank you oh

5
00:00:14,900 --> 00:00:21,570
hi everyone thank you for coming to my

6
00:00:18,480 --> 00:00:24,600
talk on an effective approach to solve

7
00:00:21,570 --> 00:00:26,849
for occupation so before we get to the

8
00:00:24,600 --> 00:00:29,910
main idea which is the idea of how to

9
00:00:26,849 --> 00:00:31,980
effectively implement occupation let's

10
00:00:29,910 --> 00:00:35,190
first understand what software education

11
00:00:31,980 --> 00:00:38,190
is so what is software application

12
00:00:35,190 --> 00:00:40,680
software application is a software

13
00:00:38,190 --> 00:00:43,019
protection mechanism that is performed

14
00:00:40,680 --> 00:00:45,329
through program transformation and this

15
00:00:43,020 --> 00:00:48,090
transformation has two main side effects

16
00:00:45,329 --> 00:00:50,370
first it makes a corresponding

17
00:00:48,090 --> 00:00:53,460
executable binary more difficult to

18
00:00:50,370 --> 00:00:56,070
analyze and second is I perform that

19
00:00:53,460 --> 00:00:59,520
first step without changing programs

20
00:00:56,070 --> 00:01:03,149
core functionalities so this definition

21
00:00:59,520 --> 00:01:04,860
is still very textbook like so we can we

22
00:01:03,149 --> 00:01:07,170
can break it down a little bit more what

23
00:01:04,860 --> 00:01:10,439
do we mean by more difficult to analyze

24
00:01:07,170 --> 00:01:12,530
and this difficult aspect is actually

25
00:01:10,439 --> 00:01:15,889
made up of three distinct properties

26
00:01:12,530 --> 00:01:18,900
potency restaurants and stealth and

27
00:01:15,890 --> 00:01:20,850
Christian Kohlberg is is actually the

28
00:01:18,900 --> 00:01:24,390
first person that used those three

29
00:01:20,850 --> 00:01:28,020
properties to assess the quality of an

30
00:01:24,390 --> 00:01:30,270
occupation transformation or application

31
00:01:28,020 --> 00:01:33,929
technique so what are these three

32
00:01:30,270 --> 00:01:36,149
properties done so on one hand potency

33
00:01:33,930 --> 00:01:38,280
is a measure measure the strength of the

34
00:01:36,150 --> 00:01:41,759
transformation against automated

35
00:01:38,280 --> 00:01:44,960
analysis and automated analysis as in a

36
00:01:41,759 --> 00:01:47,189
person sitting from computer like myself

37
00:01:44,960 --> 00:01:49,979
actively trying to figure out how to

38
00:01:47,189 --> 00:01:52,798
undo the transformation with traditional

39
00:01:49,979 --> 00:01:56,850
torn like a disassembly such as 4.28

40
00:01:52,799 --> 00:02:00,030
Oprah Gita binary ninja that can take an

41
00:01:56,850 --> 00:02:02,250
executable and zero and one and display

42
00:02:00,030 --> 00:02:04,560
its content in human readable form and

43
00:02:02,250 --> 00:02:07,530
usually that human readable form and

44
00:02:04,560 --> 00:02:10,590
tells the instruction that's contained

45
00:02:07,530 --> 00:02:12,530
within the executable binary and usually

46
00:02:10,590 --> 00:02:14,810
we call that the disassembly and

47
00:02:12,530 --> 00:02:17,209
so the data that the instruction use so

48
00:02:14,810 --> 00:02:20,180
presided disassembler another popular

49
00:02:17,209 --> 00:02:22,780
tool is also the debugger such as gdb

50
00:02:20,180 --> 00:02:25,880
that can take a snippet of this assemble

51
00:02:22,780 --> 00:02:28,760
target help an analyst verify a snippet

52
00:02:25,880 --> 00:02:32,329
of disassembly and verify as in verify

53
00:02:28,760 --> 00:02:35,179
the runtime behavior so the stronger the

54
00:02:32,330 --> 00:02:37,700
potency the harder it is for an analyst

55
00:02:35,180 --> 00:02:40,520
to understand that this assembly that is

56
00:02:37,700 --> 00:02:42,350
displayed by this assembler or to verify

57
00:02:40,520 --> 00:02:45,160
the runtime behavior with the help of a

58
00:02:42,350 --> 00:02:47,239
debugger and on the other hand

59
00:02:45,160 --> 00:02:49,190
restaurants measure the strength of the

60
00:02:47,239 --> 00:02:52,130
transformation against automated

61
00:02:49,190 --> 00:02:54,709
analysis and automated analysis is just

62
00:02:52,130 --> 00:02:57,230
like myself again sitting in front of a

63
00:02:54,709 --> 00:02:59,569
computer press a button and boom the

64
00:02:57,230 --> 00:03:01,910
transformation is undone and some

65
00:02:59,569 --> 00:03:05,268
automated example automated analysis

66
00:03:01,910 --> 00:03:08,299
tools are anger being said BAP and b2 r2

67
00:03:05,269 --> 00:03:11,450
and actually in particular being SEC has

68
00:03:08,300 --> 00:03:15,140
the capability to undo a transformation

69
00:03:11,450 --> 00:03:17,078
called opaque predicates and things

70
00:03:15,140 --> 00:03:19,970
Agnew is basically a terminal program

71
00:03:17,079 --> 00:03:23,329
underlined in blue is the command you

72
00:03:19,970 --> 00:03:26,510
type to a terminal to invoke being SEC

73
00:03:23,329 --> 00:03:29,510
on an executable binary code and Graham

74
00:03:26,510 --> 00:03:31,820
underscore all LLVM and underlines

75
00:03:29,510 --> 00:03:34,510
yellow is basically the output from pin

76
00:03:31,820 --> 00:03:37,540
SEC that will actually accurately

77
00:03:34,510 --> 00:03:40,399
identify the opaque predicates in that

78
00:03:37,540 --> 00:03:42,769
executable binary and lastly

79
00:03:40,400 --> 00:03:45,049
stealth.stealth measure the strength of

80
00:03:42,769 --> 00:03:48,019
the transformation against initial

81
00:03:45,049 --> 00:03:50,810
detection so essentially it just just

82
00:03:48,019 --> 00:03:53,480
how well the transform coat blends in

83
00:03:50,810 --> 00:03:56,209
with the original authentic code so the

84
00:03:53,480 --> 00:03:59,298
stronger the stealth property the harder

85
00:03:56,209 --> 00:04:05,480
it is to differentiate between the

86
00:03:59,299 --> 00:04:12,290
transform code and original code so with

87
00:04:05,480 --> 00:04:15,890
the knowledge that oops sorry

88
00:04:12,290 --> 00:04:18,620
oh sorry so one picked extinct

89
00:04:15,890 --> 00:04:21,019
distinction that I must made is our

90
00:04:18,620 --> 00:04:23,060
software application it's not the same

91
00:04:21,019 --> 00:04:25,310
as cryptography the protection

92
00:04:23,060 --> 00:04:26,660
offers/buy software application

93
00:04:25,310 --> 00:04:29,060
does not have the same mathematical

94
00:04:26,660 --> 00:04:30,860
guarantees as cryptography so for

95
00:04:29,060 --> 00:04:34,100
example we cannot make statements such

96
00:04:30,860 --> 00:04:37,010
as it will take 2000 years of a 2.2

97
00:04:34,100 --> 00:04:39,500
single-core CPU to undo the set

98
00:04:37,010 --> 00:04:41,780
transformation in other word the

99
00:04:39,500 --> 00:04:44,560
strength of the transformation three

100
00:04:41,780 --> 00:04:48,109
properties that we'll just discuss this

101
00:04:44,560 --> 00:04:52,370
discussed earlier the strength of each

102
00:04:48,110 --> 00:04:53,900
one can be introduced so with the

103
00:04:52,370 --> 00:04:56,150
knowledge that we can never make a

104
00:04:53,900 --> 00:05:00,500
computation impossible in one's lifetime

105
00:04:56,150 --> 00:05:02,719
to undo a oxidation transformation the

106
00:05:00,500 --> 00:05:05,120
one that we know now or the one that we

107
00:05:02,720 --> 00:05:08,270
might discover in the future perhaps us

108
00:05:05,120 --> 00:05:10,180
a better or more precise term but what

109
00:05:08,270 --> 00:05:12,740
we meant by more difficult to analyze

110
00:05:10,180 --> 00:05:15,680
and really that precise term is time

111
00:05:12,740 --> 00:05:18,080
consuming essentially we can only hope

112
00:05:15,680 --> 00:05:22,550
to make an oxidation technique more

113
00:05:18,080 --> 00:05:26,180
time-consuming for an analyst to undo so

114
00:05:22,550 --> 00:05:28,180
ultimately the transformations three

115
00:05:26,180 --> 00:05:31,640
properties that made up this

116
00:05:28,180 --> 00:05:33,560
time-consuming aspect combine to answer

117
00:05:31,640 --> 00:05:35,930
the question of how much more

118
00:05:33,560 --> 00:05:39,050
time-consuming that this transformation

119
00:05:35,930 --> 00:05:41,000
makes in full reverse engineering at the

120
00:05:39,050 --> 00:05:43,669
end of the day we really just want to

121
00:05:41,000 --> 00:05:46,490
make the analyst gives up and software

122
00:05:43,669 --> 00:05:49,159
application achieve this not by making

123
00:05:46,490 --> 00:05:51,830
the information that protects impossible

124
00:05:49,160 --> 00:05:54,940
to uncover software application achieve

125
00:05:51,830 --> 00:05:58,550
this by making the process of uncovering

126
00:05:54,940 --> 00:06:02,780
this information so time-consuming that

127
00:05:58,550 --> 00:06:04,850
the analyst eventually gives up so now

128
00:06:02,780 --> 00:06:08,020
the question is how do we make them

129
00:06:04,850 --> 00:06:10,820
maximize this time-consuming aspect and

130
00:06:08,020 --> 00:06:12,979
to answer that let's look at the the

131
00:06:10,820 --> 00:06:15,830
occupation process because really this

132
00:06:12,979 --> 00:06:18,050
generic deification process actually

133
00:06:15,830 --> 00:06:21,440
Maps really well to the three properties

134
00:06:18,050 --> 00:06:24,110
that we just discussed earlier so for

135
00:06:21,440 --> 00:06:25,760
the application usually the first step

136
00:06:24,110 --> 00:06:28,639
is that we want to identify the

137
00:06:25,760 --> 00:06:31,610
occupation technique and the ability for

138
00:06:28,639 --> 00:06:34,460
an analyst to perform this step really

139
00:06:31,610 --> 00:06:36,890
depends on the stealth property so the

140
00:06:34,460 --> 00:06:38,810
stronger the stealth property the harder

141
00:06:36,890 --> 00:06:41,240
it is to perform this step

142
00:06:38,810 --> 00:06:44,150
and after we identified the occupation

143
00:06:41,240 --> 00:06:47,120
technique now then we can perform the

144
00:06:44,150 --> 00:06:48,979
relevant the occupation step and the

145
00:06:47,120 --> 00:06:51,020
ability for analysts perform this step

146
00:06:48,980 --> 00:06:53,510
really depends on the potency and

147
00:06:51,020 --> 00:06:56,060
residents property so the stronger the

148
00:06:53,510 --> 00:06:58,580
potency in residents the harder is to

149
00:06:56,060 --> 00:07:00,980
perform this second step and if we look

150
00:06:58,580 --> 00:07:03,320
at modern occupation technique really

151
00:07:00,980 --> 00:07:05,330
what we see is that they only focus on

152
00:07:03,320 --> 00:07:08,360
the second step of the occupation

153
00:07:05,330 --> 00:07:10,969
process so they only focus on making the

154
00:07:08,360 --> 00:07:13,520
potency and residents property stronger

155
00:07:10,970 --> 00:07:17,150
well given little to no regards on the

156
00:07:13,520 --> 00:07:19,280
stealth property in summary modern

157
00:07:17,150 --> 00:07:21,469
occupation are noisy and they're noisy

158
00:07:19,280 --> 00:07:23,809
because they are easy to identify and

159
00:07:21,470 --> 00:07:26,770
the root cause of that is really because

160
00:07:23,810 --> 00:07:30,350
they have low stealth so let's take a

161
00:07:26,770 --> 00:07:32,630
look at an example of an modern

162
00:07:30,350 --> 00:07:35,150
altercation technique called control

163
00:07:32,630 --> 00:07:36,860
photograph flattening so before we get

164
00:07:35,150 --> 00:07:39,349
to the theory of how this occupation

165
00:07:36,860 --> 00:07:41,900
technique work let's first understand

166
00:07:39,350 --> 00:07:47,510
what a control flow graph or abbreviated

167
00:07:41,900 --> 00:07:49,789
CFG is so a CFG is a representation of a

168
00:07:47,510 --> 00:07:53,750
function disassembly where the program

169
00:07:49,789 --> 00:07:55,610
flow is also encoded and how is able to

170
00:07:53,750 --> 00:07:58,300
encode program flow into its

171
00:07:55,610 --> 00:08:01,430
representation in slightly represent

172
00:07:58,300 --> 00:08:03,289
disassembly in basic blocks and use

173
00:08:01,430 --> 00:08:07,789
arrows connecting two different basic

174
00:08:03,289 --> 00:08:09,620
blocks to represent a control flow and a

175
00:08:07,789 --> 00:08:12,320
basic plot basically has one unique

176
00:08:09,620 --> 00:08:15,470
entrance point and one unique exit point

177
00:08:12,320 --> 00:08:17,419
so once you enter a basic block you will

178
00:08:15,470 --> 00:08:19,789
always execute the same sequence of

179
00:08:17,419 --> 00:08:23,060
instruction so this means that if the

180
00:08:19,789 --> 00:08:24,650
disassembly contains like a control flow

181
00:08:23,060 --> 00:08:28,729
ordering instruction like an if

182
00:08:24,650 --> 00:08:30,888
statement then this assembly and the CFG

183
00:08:28,729 --> 00:08:32,689
representation will be split into

184
00:08:30,889 --> 00:08:36,620
multiple basic block as shown in this

185
00:08:32,690 --> 00:08:39,680
picture here so in this picture based

186
00:08:36,620 --> 00:08:41,630
the top basic block ends with an if

187
00:08:39,679 --> 00:08:43,968
statement and if the if statement

188
00:08:41,630 --> 00:08:46,339
evaluates to true it will go to the

189
00:08:43,969 --> 00:08:49,370
basic block at where the green arrows is

190
00:08:46,339 --> 00:08:51,290
pointing and if it evaluates to false it

191
00:08:49,370 --> 00:08:51,730
will go to the basic block where the red

192
00:08:51,290 --> 00:08:54,579
arrow

193
00:08:51,730 --> 00:08:58,230
pointing so why does this representation

194
00:08:54,579 --> 00:09:00,489
useful then well in this representation

195
00:08:58,230 --> 00:09:03,070
it actually increases that this

196
00:09:00,490 --> 00:09:05,260
Assembly's glens value with the ability

197
00:09:03,070 --> 00:09:07,660
to quickly glance over the disassembly

198
00:09:05,260 --> 00:09:10,569
and have some sort of understanding of

199
00:09:07,660 --> 00:09:13,269
what the co is doing and to be more

200
00:09:10,570 --> 00:09:15,399
precise one can recognize high-level

201
00:09:13,269 --> 00:09:17,250
programming constructs such as the if

202
00:09:15,399 --> 00:09:19,899
statement actually explained earlier

203
00:09:17,250 --> 00:09:22,329
while loop for loop and also switched

204
00:09:19,899 --> 00:09:25,750
statement by just a quick glance of the

205
00:09:22,329 --> 00:09:29,050
disassembly so what does this particular

206
00:09:25,750 --> 00:09:31,360
oxidation technique do is that it remove

207
00:09:29,050 --> 00:09:33,760
the increased glance value that the CFG

208
00:09:31,360 --> 00:09:36,190
representation provides such as the

209
00:09:33,760 --> 00:09:38,680
shape indicating high level programming

210
00:09:36,190 --> 00:09:41,380
to construct as discussed earlier and

211
00:09:38,680 --> 00:09:44,109
also just any type of inference that

212
00:09:41,380 --> 00:09:47,709
analysts can make by just how close the

213
00:09:44,110 --> 00:09:50,339
basic block is to one another and how

214
00:09:47,709 --> 00:09:54,699
its able to do so is that it it

215
00:09:50,339 --> 00:09:57,639
transform every possible control flow

216
00:09:54,699 --> 00:10:01,120
graph an example show to the left into

217
00:09:57,639 --> 00:10:03,069
the into the one shown to the right and

218
00:10:01,120 --> 00:10:06,130
how able to do so is I takes each

219
00:10:03,069 --> 00:10:09,250
original basic block from the original

220
00:10:06,130 --> 00:10:13,060
CFG starting at the bottom of the new

221
00:10:09,250 --> 00:10:15,160
CFG and then a dispatcher that chooses

222
00:10:13,060 --> 00:10:19,060
which original CFG to go to

223
00:10:15,160 --> 00:10:21,310
so essentially post occupation by this

224
00:10:19,060 --> 00:10:24,420
particular transformation will make

225
00:10:21,310 --> 00:10:27,729
every control flow graph look like this

226
00:10:24,420 --> 00:10:31,029
so why this is I have no stealth well

227
00:10:27,730 --> 00:10:32,889
that's because all the transform CFG

228
00:10:31,029 --> 00:10:37,899
will have that particular distinctive

229
00:10:32,889 --> 00:10:39,699
shape so modern education is noisy they

230
00:10:37,899 --> 00:10:41,889
are easy to identify because they have

231
00:10:39,699 --> 00:10:43,689
love stealth but doesn't matter it

232
00:10:41,889 --> 00:10:45,970
shouldn't matter if that the application

233
00:10:43,690 --> 00:10:48,699
process still takes a long time right

234
00:10:45,970 --> 00:10:50,380
well the problem with that way of

235
00:10:48,699 --> 00:10:52,779
thinking is that real world

236
00:10:50,380 --> 00:10:55,120
implementation leaves behind very

237
00:10:52,779 --> 00:10:58,420
distinctive footprint to allow for tor

238
00:10:55,120 --> 00:11:01,180
pacific or non generic approach to the

239
00:10:58,420 --> 00:11:03,490
application let's take a look at all

240
00:11:01,180 --> 00:11:06,099
LLVM implementation of control

241
00:11:03,490 --> 00:11:10,240
flow graph flattening so all of VM is a

242
00:11:06,100 --> 00:11:13,260
publicly available applicator that you

243
00:11:10,240 --> 00:11:17,410
can just find on github so an example

244
00:11:13,260 --> 00:11:23,050
transform comb bio LVM is shown in that

245
00:11:17,410 --> 00:11:25,120
particular CFG so in OPM an original

246
00:11:23,050 --> 00:11:27,910
basic block will always end up with

247
00:11:25,120 --> 00:11:31,120
setting the same local variable to a

248
00:11:27,910 --> 00:11:33,399
constant that tells the dispatcher was

249
00:11:31,120 --> 00:11:36,820
the next original basic block that they

250
00:11:33,399 --> 00:11:38,350
should execute next this means that once

251
00:11:36,820 --> 00:11:40,570
we figure out the content that

252
00:11:38,350 --> 00:11:43,120
correspond to each of the original basic

253
00:11:40,570 --> 00:11:46,510
block that's flatting at the bottom then

254
00:11:43,120 --> 00:11:50,250
now allow us to just quickly reconstruct

255
00:11:46,510 --> 00:11:52,899
the original CFG so what's the solution

256
00:11:50,250 --> 00:11:55,810
how do we effectively implement

257
00:11:52,899 --> 00:11:58,060
occupation then well instead of focusing

258
00:11:55,810 --> 00:12:00,609
on making the altercation technique

259
00:11:58,060 --> 00:12:03,279
harder to break also focus on making it

260
00:12:00,610 --> 00:12:05,230
harder to identify so instead of just

261
00:12:03,279 --> 00:12:05,830
focus on this potency and wrestling's

262
00:12:05,230 --> 00:12:07,540
property

263
00:12:05,830 --> 00:12:09,790
don't forget the stealth property

264
00:12:07,540 --> 00:12:14,199
respect each property that makes up this

265
00:12:09,790 --> 00:12:16,240
time-consuming aspect and perhaps to

266
00:12:14,200 --> 00:12:18,520
drive the importance of this stealth

267
00:12:16,240 --> 00:12:21,579
property even more it might be better

268
00:12:18,520 --> 00:12:24,130
for us to also think of a higher level

269
00:12:21,579 --> 00:12:25,989
what's more frustrating understanding

270
00:12:24,130 --> 00:12:28,779
what the problem is but now how to solve

271
00:12:25,990 --> 00:12:30,820
it well with the availability of the

272
00:12:28,779 --> 00:12:32,860
world wide web you know there's bound to

273
00:12:30,820 --> 00:12:35,290
be solution online the self-similar

274
00:12:32,860 --> 00:12:37,720
problem so learn the general approach to

275
00:12:35,290 --> 00:12:40,390
tackle those problems and use it to

276
00:12:37,720 --> 00:12:42,940
tackle the one you have a hands how

277
00:12:40,390 --> 00:12:46,319
about not understanding or even aware of

278
00:12:42,940 --> 00:12:49,120
what the problem is well in that case

279
00:12:46,320 --> 00:12:53,200
it's really not anything I can do right

280
00:12:49,120 --> 00:12:55,779
so if an analyst is now aware of what is

281
00:12:53,200 --> 00:12:57,520
oxic ated it makes that person makes the

282
00:12:55,779 --> 00:12:59,500
run assumption about what the co is

283
00:12:57,520 --> 00:13:01,839
doing and once you make the wrong

284
00:12:59,500 --> 00:13:04,690
assumption it also makes them fall

285
00:13:01,839 --> 00:13:06,670
deeper into this rabbit hole and in the

286
00:13:04,690 --> 00:13:08,079
context of reverse engineering we

287
00:13:06,670 --> 00:13:11,199
usually call out the reversing help

288
00:13:08,079 --> 00:13:14,199
which is spending days weeks hopefully

289
00:13:11,200 --> 00:13:16,110
not month but probably of analyzing the

290
00:13:14,199 --> 00:13:18,329
same executable binary

291
00:13:16,110 --> 00:13:20,610
without understanding anything about

292
00:13:18,329 --> 00:13:24,060
what the internal is how the internal is

293
00:13:20,610 --> 00:13:25,709
implemented and really out of three

294
00:13:24,060 --> 00:13:28,469
properties that make up this

295
00:13:25,709 --> 00:13:31,140
time-consuming aspect only the stealth

296
00:13:28,470 --> 00:13:33,240
property can achieve this idea of making

297
00:13:31,140 --> 00:13:37,019
the analyst make the wrong assumption

298
00:13:33,240 --> 00:13:39,930
about what the co is doing so to end

299
00:13:37,019 --> 00:13:44,760
this talk I will give a more concrete

300
00:13:39,930 --> 00:13:47,310
example and under importance of the

301
00:13:44,760 --> 00:13:49,709
stealth property so recently I was

302
00:13:47,310 --> 00:13:54,060
studying an application technique called

303
00:13:49,709 --> 00:13:56,430
opaque predicate and during my research

304
00:13:54,060 --> 00:13:59,849
I discovered the assumption that either

305
00:13:56,430 --> 00:14:02,370
pro makes when tries to I automatically

306
00:13:59,850 --> 00:14:05,550
identify opaque predicates and I was

307
00:14:02,370 --> 00:14:07,800
able to utilize our assumption to make

308
00:14:05,550 --> 00:14:11,399
stealthy opaque predicates when it's

309
00:14:07,800 --> 00:14:12,990
analyzed under either Pro so just a

310
00:14:11,399 --> 00:14:15,870
little background opaque predicate

311
00:14:12,990 --> 00:14:18,450
belongs to disassembly desynchronization

312
00:14:15,870 --> 00:14:20,990
and thus assembly distinct translation

313
00:14:18,450 --> 00:14:23,670
is basically an umbrella term for

314
00:14:20,990 --> 00:14:25,589
application technique whose main goal is

315
00:14:23,670 --> 00:14:27,719
to degrade the accuracy of the retrieved

316
00:14:25,589 --> 00:14:30,240
disassembly so what do I mean by

317
00:14:27,720 --> 00:14:33,690
inaccurate disassembly then or an

318
00:14:30,240 --> 00:14:35,339
inaccurate disassembly contains it's

319
00:14:33,690 --> 00:14:38,160
basically a disassembly that contains

320
00:14:35,339 --> 00:14:40,350
code that will never be executed during

321
00:14:38,160 --> 00:14:42,839
program runtime and here's an example

322
00:14:40,350 --> 00:14:45,990
shown here the first instruction is

323
00:14:42,839 --> 00:14:49,050
basically an if statement and if this if

324
00:14:45,990 --> 00:14:51,570
statement evaluates to true it will the

325
00:14:49,050 --> 00:14:53,910
execution will go to where the arrow is

326
00:14:51,570 --> 00:14:56,220
pointing so it will start executing the

327
00:14:53,910 --> 00:14:58,649
the add instruction and then the

328
00:14:56,220 --> 00:15:00,779
decrement instruction but if the if

329
00:14:58,649 --> 00:15:02,699
statement evaluates to false it will go

330
00:15:00,779 --> 00:15:05,189
to an instruction right after that the

331
00:15:02,699 --> 00:15:09,089
if statement which is the MOV move

332
00:15:05,190 --> 00:15:11,550
instruction but this particular if

333
00:15:09,089 --> 00:15:14,459
statement during runtime will actually

334
00:15:11,550 --> 00:15:16,709
always evaluate to false but that this

335
00:15:14,459 --> 00:15:18,569
assembler does not know that so it's

336
00:15:16,709 --> 00:15:21,119
still disassembled the code at where the

337
00:15:18,570 --> 00:15:23,220
arrow is pointing or the by edge where

338
00:15:21,120 --> 00:15:27,990
the arrow is pointing as Co instruction

339
00:15:23,220 --> 00:15:29,390
thus inaccurate disassembly so what is

340
00:15:27,990 --> 00:15:31,640
opaque predicates

341
00:15:29,390 --> 00:15:34,160
opaque predicates is basically just that

342
00:15:31,640 --> 00:15:37,400
there are conditional branches that

343
00:15:34,160 --> 00:15:39,890
always evaluate to true or false this

344
00:15:37,400 --> 00:15:42,410
means that one of the branch is always

345
00:15:39,890 --> 00:15:44,930
unreachable at programming runtime so

346
00:15:42,410 --> 00:15:47,780
jump bytes or random data bytes that are

347
00:15:44,930 --> 00:15:51,469
not meant to be parses Co instruction

348
00:15:47,780 --> 00:15:55,610
can be inserted and in this particular

349
00:15:51,470 --> 00:15:58,190
paper case shown here which is kind of

350
00:15:55,610 --> 00:16:00,350
like in a CFG representation this

351
00:15:58,190 --> 00:16:02,510
particular opaque predicate contains a

352
00:16:00,350 --> 00:16:03,020
predicate that will always evaluates to

353
00:16:02,510 --> 00:16:05,390
true

354
00:16:03,020 --> 00:16:08,210
this means that you can put junk by at

355
00:16:05,390 --> 00:16:12,410
the false branch so other than either

356
00:16:08,210 --> 00:16:14,350
pro there are also other other tool that

357
00:16:12,410 --> 00:16:17,689
will try to automatically identify

358
00:16:14,350 --> 00:16:20,330
opaque predicates died including SEC and

359
00:16:17,690 --> 00:16:23,180
also a binary ninja plug-in copaque

360
00:16:20,330 --> 00:16:26,000
predicate patcher and the way they work

361
00:16:23,180 --> 00:16:28,250
is that at every basically if statement

362
00:16:26,000 --> 00:16:31,250
they will ask the question of can both

363
00:16:28,250 --> 00:16:33,410
branch be executed and if the answer is

364
00:16:31,250 --> 00:16:35,540
no or if they can determine that the

365
00:16:33,410 --> 00:16:38,150
answer is no then they know that an

366
00:16:35,540 --> 00:16:40,550
opaque predicate exists but the problem

367
00:16:38,150 --> 00:16:42,800
with that approach is that opaque

368
00:16:40,550 --> 00:16:45,160
predicates well the predicate itself

369
00:16:42,800 --> 00:16:47,990
depending on how its constructed

370
00:16:45,160 --> 00:16:51,610
determining that property or being able

371
00:16:47,990 --> 00:16:55,310
to answer that question is non-trivial

372
00:16:51,610 --> 00:16:57,980
so since identifying opaque predicate is

373
00:16:55,310 --> 00:17:01,280
high idle Pro takes a heuristic based

374
00:16:57,980 --> 00:17:04,190
approach to identify them instead and

375
00:17:01,280 --> 00:17:06,589
here's Ida heuristic if Ida Pro detects

376
00:17:04,190 --> 00:17:09,199
overlap instruction and sibling basic

377
00:17:06,589 --> 00:17:11,240
block it will always assume that the

378
00:17:09,199 --> 00:17:13,190
conditional branch is an opaque

379
00:17:11,240 --> 00:17:15,740
predicate so what I mean by a sibling

380
00:17:13,190 --> 00:17:20,000
basic block or in the picture shown here

381
00:17:15,740 --> 00:17:23,000
basically plot a sorry x papi and base

382
00:17:20,000 --> 00:17:26,270
bossy are sibling because they originate

383
00:17:23,000 --> 00:17:28,700
from the same if statement and what I

384
00:17:26,270 --> 00:17:30,940
mean by overlapping structure overlap

385
00:17:28,700 --> 00:17:34,160
instructions are wins one or more

386
00:17:30,940 --> 00:17:37,460
instruction bytes are interpreted as

387
00:17:34,160 --> 00:17:40,430
more than one instruction so for the

388
00:17:37,460 --> 00:17:41,720
opaque predicates here if the if

389
00:17:40,430 --> 00:17:48,289
statements

390
00:17:41,720 --> 00:17:51,740
- true then the by 31 C 0 D 1 CA will be

391
00:17:48,289 --> 00:17:54,470
paused as an XOR and our instruction but

392
00:17:51,740 --> 00:17:56,990
if it evaluates to false those sent 4

393
00:17:54,470 --> 00:18:02,419
bytes will be evaluated as an move

394
00:17:56,990 --> 00:18:05,510
instruction so here's where either makes

395
00:18:02,419 --> 00:18:07,419
an incorrect assumption if it takes our

396
00:18:05,510 --> 00:18:09,950
structure I just discussed earlier

397
00:18:07,419 --> 00:18:12,169
basically overlap instruction and

398
00:18:09,950 --> 00:18:15,230
sibling basic block it will always

399
00:18:12,169 --> 00:18:18,200
assume that the jump bike is placed in

400
00:18:15,230 --> 00:18:20,960
the false branch but there's really no

401
00:18:18,200 --> 00:18:24,620
stopping for the junk by to place in the

402
00:18:20,960 --> 00:18:27,950
true branch instead and that's look at a

403
00:18:24,620 --> 00:18:30,559
more concrete example here so and this

404
00:18:27,950 --> 00:18:33,230
disassembly the second instruction is

405
00:18:30,559 --> 00:18:36,590
basically basically the if statement and

406
00:18:33,230 --> 00:18:38,330
if the if statement evaluates to true it

407
00:18:36,590 --> 00:18:40,879
will go to the instruction and with the

408
00:18:38,330 --> 00:18:43,010
not jump label is so it will start

409
00:18:40,880 --> 00:18:45,470
executing the XOR and all our

410
00:18:43,010 --> 00:18:48,620
instruction and just to explain that

411
00:18:45,470 --> 00:18:50,650
this assembly a little bit those two

412
00:18:48,620 --> 00:18:54,949
instruction actual and all are

413
00:18:50,650 --> 00:18:59,090
essentially sets ei X - 0 and eix is the

414
00:18:54,950 --> 00:19:03,080
return return value so on a higher level

415
00:18:59,090 --> 00:19:06,530
this function will return 0 as shown by

416
00:19:03,080 --> 00:19:08,330
this disassembly but if we look at the

417
00:19:06,530 --> 00:19:12,168
false branch which is the instruction

418
00:19:08,330 --> 00:19:15,020
that follows the JN z or the if

419
00:19:12,169 --> 00:19:16,010
statement essentially that instruction

420
00:19:15,020 --> 00:19:19,639
is not disassembled

421
00:19:16,010 --> 00:19:21,890
it's just left as the data by b8 so it's

422
00:19:19,640 --> 00:19:24,770
just left as a rata by why didn't I die

423
00:19:21,890 --> 00:19:26,840
disassemble that well I thought detect

424
00:19:24,770 --> 00:19:30,500
that structure we discussed earlier

425
00:19:26,840 --> 00:19:34,280
basically overlapping instruction and

426
00:19:30,500 --> 00:19:37,010
sibling basic block and no and remember

427
00:19:34,280 --> 00:19:39,740
once I detect that structure it will

428
00:19:37,010 --> 00:19:42,020
always assume that junk by 2 to be

429
00:19:39,740 --> 00:19:44,020
placed in the false branch so

430
00:19:42,020 --> 00:19:48,918
essentially what happens is that either

431
00:19:44,020 --> 00:19:52,639
the basically believed that be a gala by

432
00:19:48,919 --> 00:19:56,970
is a jump by and not an instruction pike

433
00:19:52,639 --> 00:19:58,320
but for example the junk bite is

434
00:19:56,970 --> 00:20:02,250
actually placed in the true branch

435
00:19:58,320 --> 00:20:04,408
instead so this means that the EXO and

436
00:20:02,250 --> 00:20:05,429
all our instruction will actually never

437
00:20:04,409 --> 00:20:07,470
be executed

438
00:20:05,429 --> 00:20:11,220
they are lately all the junk bike and

439
00:20:07,470 --> 00:20:13,529
the real instruction actually starts

440
00:20:11,220 --> 00:20:18,230
there so the instruction should actually

441
00:20:13,529 --> 00:20:22,529
be paused at where the be a data bias

442
00:20:18,230 --> 00:20:25,679
and if we disassemble from there we see

443
00:20:22,529 --> 00:20:27,929
that what's really will be executed

444
00:20:25,679 --> 00:20:31,440
during program run time is that EAX

445
00:20:27,929 --> 00:20:33,690
register will be a sign non zero value

446
00:20:31,440 --> 00:20:35,760
so essentially instead of returning zero

447
00:20:33,690 --> 00:20:39,330
this function well I should return non

448
00:20:35,760 --> 00:20:42,929
zero value so remember how previously I

449
00:20:39,330 --> 00:20:45,840
said how this particular about this

450
00:20:42,929 --> 00:20:48,120
opaque bracket is stealthier well how's

451
00:20:45,840 --> 00:20:50,668
it out here well here we're able to

452
00:20:48,120 --> 00:20:54,029
achieve three things first we make

453
00:20:50,669 --> 00:20:57,450
either display the wrong structure the

454
00:20:54,029 --> 00:20:59,700
EXO and our second we make I doubt not

455
00:20:57,450 --> 00:21:05,100
disassemble the authentic instruction

456
00:20:59,700 --> 00:21:07,860
and third we make I Donna show any sign

457
00:21:05,100 --> 00:21:10,139
of distress on that there's some problem

458
00:21:07,860 --> 00:21:11,729
going on with the disassembly so before

459
00:21:10,139 --> 00:21:14,580
either implemented this particular

460
00:21:11,730 --> 00:21:17,909
heuristic to detect opaque predicates if

461
00:21:14,580 --> 00:21:19,408
if there's overlap instruction I doubt

462
00:21:17,909 --> 00:21:22,500
we'll highlight certain part of the

463
00:21:19,409 --> 00:21:24,960
disassembly in red to let the user know

464
00:21:22,500 --> 00:21:27,690
what the analysts know that something is

465
00:21:24,960 --> 00:21:29,399
wrong but since here I'd I believed I

466
00:21:27,690 --> 00:21:32,340
had successfully detected opaque

467
00:21:29,399 --> 00:21:33,779
predicates the show it does not do that

468
00:21:32,340 --> 00:21:38,010
type of highlighting home so it shows

469
00:21:33,779 --> 00:21:41,340
zero sign of distress to the analysts so

470
00:21:38,010 --> 00:21:44,399
in summary really when trying to

471
00:21:41,340 --> 00:21:45,689
implement occupation try to respect each

472
00:21:44,399 --> 00:21:48,449
property that makes up this

473
00:21:45,690 --> 00:21:50,429
time-consuming aspect and right now

474
00:21:48,450 --> 00:21:53,010
really the focus has only been on the

475
00:21:50,429 --> 00:21:54,720
potency and residence property but we

476
00:21:53,010 --> 00:21:56,908
should really also focus on the stealth

477
00:21:54,720 --> 00:22:01,190
property because it is also equally as

478
00:21:56,909 --> 00:22:18,200
important thank you

479
00:22:01,190 --> 00:22:19,789
I guess any question oh oh yeah the

480
00:22:18,200 --> 00:22:22,129
question was how does the earlier

481
00:22:19,789 --> 00:22:28,249
example look like on the photograph

482
00:22:22,129 --> 00:22:33,590
oh we're showing Ida actually to be

483
00:22:28,249 --> 00:22:38,720
honest I I don't remember but if Ida if

484
00:22:33,590 --> 00:22:40,728
I died to test any sorry second actually

485
00:22:38,720 --> 00:22:42,830
yeah it was show not the other branches

486
00:22:40,729 --> 00:22:43,909
that's why I will assume too because I

487
00:22:42,830 --> 00:22:46,489
don't believe that that's actually

488
00:22:43,909 --> 00:22:48,830
correct and correct this assembly so the

489
00:22:46,489 --> 00:22:50,840
control flow graph would just be it will

490
00:22:48,830 --> 00:22:54,289
just be policy one branch pointing to

491
00:22:50,840 --> 00:22:59,599
the other but I actually don't remember

492
00:22:54,289 --> 00:23:02,049
so I can say that for sure so I need the

493
00:22:59,599 --> 00:23:02,049
questions

494
00:23:08,950 --> 00:23:17,260
okay thanks just gonna open it up

495
00:23:20,020 --> 00:23:25,550
excuse me just one more question for you

496
00:23:22,640 --> 00:23:28,790
you said there was opening predicate

497
00:23:25,550 --> 00:23:30,560
Hatcher's do they work when the

498
00:23:28,790 --> 00:23:32,360
predicate itself relies on two variables

499
00:23:30,560 --> 00:23:34,610
that are unknown or do you have to feed

500
00:23:32,360 --> 00:23:36,560
it known States for it to be able to

501
00:23:34,610 --> 00:23:40,929
determine that something is OPIC oh yeah

502
00:23:36,560 --> 00:23:44,960
so for that particular plugin actually

503
00:23:40,930 --> 00:23:48,260
by the binary ninja disassembler they

504
00:23:44,960 --> 00:23:50,450
they can't do this more events program

505
00:23:48,260 --> 00:23:52,280
analysis technique called value set

506
00:23:50,450 --> 00:23:55,220
analysis which is basically the ability

507
00:23:52,280 --> 00:23:57,500
to like for a register they will try to

508
00:23:55,220 --> 00:24:01,760
determine all the value in that register

509
00:23:57,500 --> 00:24:05,600
so for that particular plugin if it

510
00:24:01,760 --> 00:24:07,520
determines that the it's the wall that

511
00:24:05,600 --> 00:24:09,800
the register that the if statement

512
00:24:07,520 --> 00:24:13,340
depends on always evaluate to the same

513
00:24:09,800 --> 00:24:15,860
value then it will it will basically no

514
00:24:13,340 --> 00:24:18,260
dice an opaque predicate but if we can't

515
00:24:15,860 --> 00:24:20,929
determine that then then it doesn't so

516
00:24:18,260 --> 00:24:24,830
let's just say if the construction of

517
00:24:20,930 --> 00:24:27,740
the predicate is still like because I

518
00:24:24,830 --> 00:24:30,949
know that and they actually talk about

519
00:24:27,740 --> 00:24:33,860
the limitation and so the limitation so

520
00:24:30,950 --> 00:24:36,800
basically how well that tool work is

521
00:24:33,860 --> 00:24:40,040
based on how well the value set analysis

522
00:24:36,800 --> 00:24:44,300
is so and certain limitation is

523
00:24:40,040 --> 00:24:50,270
basically if I remember correctly if the

524
00:24:44,300 --> 00:24:53,149
predicate depends on like is it may be

525
00:24:50,270 --> 00:24:55,940
may be memory like on the heap like they

526
00:24:53,150 --> 00:24:57,770
won't do certain analysis if the

527
00:24:55,940 --> 00:25:02,660
predicate is constructing a certain way

528
00:24:57,770 --> 00:25:07,120
so one more question if you uh you don't

529
00:25:02,660 --> 00:25:09,650
mind oh yeah for Ida if the junk jump

530
00:25:07,120 --> 00:25:11,389
goes to a location that doesn't overlap

531
00:25:09,650 --> 00:25:14,690
with any other functions will I to pick

532
00:25:11,390 --> 00:25:16,140
up that that is a opaque predicate or do

533
00:25:14,690 --> 00:25:19,260
I have to overlap

534
00:25:16,140 --> 00:25:21,780
so yeah I does case it does have to

535
00:25:19,260 --> 00:25:26,129
overlap so I so in a way either

536
00:25:21,780 --> 00:25:27,540
heuristic is very it's it's very it's

537
00:25:26,130 --> 00:25:31,200
incomplete per se

538
00:25:27,540 --> 00:25:32,520
so it's an incomplete implementation to

539
00:25:31,200 --> 00:25:41,150
detect opaque predicates

540
00:25:32,520 --> 00:25:41,150
so ah thank you

