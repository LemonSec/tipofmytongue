1
00:00:01,879 --> 00:00:05,730
for those of you that are in the back

2
00:00:04,170 --> 00:00:08,849
you might want to come up front we've

3
00:00:05,730 --> 00:00:15,200
got about 50 to 60 lines of code eight

4
00:00:08,849 --> 00:00:15,200
point font it goes by really fast

5
00:00:16,820 --> 00:00:31,198
we're sniffing you too all right so let

6
00:00:28,109 --> 00:00:34,500
me go ahead introduce Nick miles and

7
00:00:31,199 --> 00:00:37,770
Chris Linn how many were here in the

8
00:00:34,500 --> 00:00:40,469
last two sessions all right yeah we got

9
00:00:37,770 --> 00:00:43,140
some pen testing red team's threatening

10
00:00:40,469 --> 00:00:47,489
physical and IT security breaches war

11
00:00:43,140 --> 00:00:47,940
walking Wi-Fi sniffing this gets even

12
00:00:47,489 --> 00:00:53,030
better

13
00:00:47,940 --> 00:00:57,839
IOT sniffing any IOT sniffers

14
00:00:53,030 --> 00:01:00,059
well Nick joined tenable as a research

15
00:00:57,840 --> 00:01:02,730
manager in 2011 he has written hundreds

16
00:01:00,059 --> 00:01:04,378
of necess plugins and developed several

17
00:01:02,730 --> 00:01:06,390
core libraries used in the nests

18
00:01:04,379 --> 00:01:10,020
ascension he now leads the company's

19
00:01:06,390 --> 00:01:12,810
zero-day research team in his free time

20
00:01:10,020 --> 00:01:15,479
Nick likes model aircraft metalworking

21
00:01:12,810 --> 00:01:18,570
and breaking out his telescope on clear

22
00:01:15,479 --> 00:01:20,400
nights and then we've got Chris Lynn

23
00:01:18,570 --> 00:01:22,559
here he's a senior researcher on zero

24
00:01:20,400 --> 00:01:25,020
day research team as well with tenable

25
00:01:22,560 --> 00:01:27,810
is passionate about security he enjoys

26
00:01:25,020 --> 00:01:31,369
attacking targets ranging from web apps

27
00:01:27,810 --> 00:01:33,600
to IOT targets people in the audience

28
00:01:31,369 --> 00:01:35,610
outside of work Chris enjoys playing

29
00:01:33,600 --> 00:01:38,339
competitive tennis and the occasional

30
00:01:35,610 --> 00:01:41,369
craft beer which of course tamp is a

31
00:01:38,340 --> 00:01:43,579
great place for craft beers it's all

32
00:01:41,369 --> 00:01:43,579
yours

33
00:01:45,920 --> 00:01:55,159
hello hi welcome to our talk and this is

34
00:01:50,909 --> 00:01:57,750
about extracting an elf from an ESP 32

35
00:01:55,159 --> 00:02:00,750
as he mentioned I'm Nick miles

36
00:01:57,750 --> 00:02:02,219
I'm research volunteer search Manager

37
00:02:00,750 --> 00:02:04,560
for the desert a research team it's

38
00:02:02,219 --> 00:02:07,229
enable and this is Chris lon he was a

39
00:02:04,560 --> 00:02:10,009
senior researcher on the zero day

40
00:02:07,229 --> 00:02:10,008
research team

41
00:02:10,650 --> 00:02:18,400
so we're gonna talk about ESP 32 and

42
00:02:14,470 --> 00:02:21,430
what it is and what it's used for so

43
00:02:18,400 --> 00:02:23,740
here is an ESP 32 development kit and

44
00:02:21,430 --> 00:02:25,870
the chip we can see it's that's they're

45
00:02:23,740 --> 00:02:28,930
interested in is highlighted in the

46
00:02:25,870 --> 00:02:31,660
green box and as you can see it's pretty

47
00:02:28,930 --> 00:02:33,610
small so it's it's a complete system on

48
00:02:31,660 --> 00:02:40,000
a chip and there's a flash chip that is

49
00:02:33,610 --> 00:02:44,950
on there too it's below rate right there

50
00:02:40,000 --> 00:02:47,950
and it's up to 16 megabytes in size is

51
00:02:44,950 --> 00:02:49,690
what it supports and that that's the

52
00:02:47,950 --> 00:02:51,700
board we actually use for testing and

53
00:02:49,690 --> 00:02:53,590
finding of all the funding for mobility

54
00:02:51,700 --> 00:02:59,980
in simply safe which we're going to talk

55
00:02:53,590 --> 00:03:03,420
about so it supports Wi-Fi bluetooth it

56
00:02:59,980 --> 00:03:06,570
has two cores and it's really popular in

57
00:03:03,420 --> 00:03:10,329
IOT devices so cameras light bulbs

58
00:03:06,570 --> 00:03:13,420
appliances wearables alarm systems which

59
00:03:10,330 --> 00:03:17,530
we'll talk about and it's either used as

60
00:03:13,420 --> 00:03:22,839
a standalone system or as more commonly

61
00:03:17,530 --> 00:03:24,280
as a as a slave for you know talking to

62
00:03:22,840 --> 00:03:26,190
through Wi-Fi and Bluetooth so it

63
00:03:24,280 --> 00:03:27,940
reduces the overhead on the core

64
00:03:26,190 --> 00:03:33,100
application microcontroller or a

65
00:03:27,940 --> 00:03:36,070
processor so this is house design

66
00:03:33,100 --> 00:03:39,010
there's two extends ax CPUs and they're

67
00:03:36,070 --> 00:03:41,109
labeled app CPU and pro CPU which you

68
00:03:39,010 --> 00:03:42,489
would think that would make you think

69
00:03:41,110 --> 00:03:44,200
that they are both dedicated to doing

70
00:03:42,489 --> 00:03:46,300
certain tasks but they're not they used

71
00:03:44,200 --> 00:03:48,988
to be they moved away from that to a

72
00:03:46,300 --> 00:03:52,570
asymmetric design or both the CPUs can

73
00:03:48,989 --> 00:03:54,970
be used interchangeably and they both

74
00:03:52,570 --> 00:03:58,359
use the same aggresses to access memory

75
00:03:54,970 --> 00:04:00,220
with a few exceptions being one being

76
00:03:58,360 --> 00:04:02,080
that the RTC fast memory can only be

77
00:04:00,220 --> 00:04:04,720
accessed by the pro cpu and it can

78
00:04:02,080 --> 00:04:07,930
support 13 peripherals that are equipped

79
00:04:04,720 --> 00:04:09,400
with DMA and you know and also all these

80
00:04:07,930 --> 00:04:13,720
leaders flash memory on it too you can

81
00:04:09,400 --> 00:04:16,750
program so this is the device we found

82
00:04:13,720 --> 00:04:20,760
one of these on its is simply safe three

83
00:04:16,750 --> 00:04:23,710
or ss3 alarm system and this is the

84
00:04:20,760 --> 00:04:25,750
it's the base station so you have

85
00:04:23,710 --> 00:04:28,659
sensors your the keypad and you have the

86
00:04:25,750 --> 00:04:31,300
base station that organizes everything

87
00:04:28,660 --> 00:04:34,960
it talks to the cloud it talks to all

88
00:04:31,300 --> 00:04:38,920
the sensors it has a Wi-Fi chip in it

89
00:04:34,960 --> 00:04:40,359
which is the Obama s is on the S SP 32

90
00:04:38,920 --> 00:04:42,490
it's that that's how it's talked to the

91
00:04:40,360 --> 00:04:45,240
internet it has a cell radio it has

92
00:04:42,490 --> 00:04:50,850
another radio for talking to all the

93
00:04:45,240 --> 00:04:53,800
sensors you can talk about and there

94
00:04:50,850 --> 00:04:56,440
there it is inside you can see it here

95
00:04:53,800 --> 00:04:58,060
so on one side of the board

96
00:04:56,440 --> 00:04:59,650
there's DSP 32 and actually used for

97
00:04:58,060 --> 00:05:03,520
Wi-Fi and Bluetooth and on the other

98
00:04:59,650 --> 00:05:06,400
side there's a TI c c11 - one chip I

99
00:05:03,520 --> 00:05:09,849
believe and that's used to talk to all

100
00:05:06,400 --> 00:05:12,340
the sensors on 433 megahertz network

101
00:05:09,850 --> 00:05:13,780
using frequency shift keying and we

102
00:05:12,340 --> 00:05:21,119
actually decoded that protocol but it

103
00:05:13,780 --> 00:05:23,080
wasn't very helpful so probably ran into

104
00:05:21,120 --> 00:05:25,120
so the first thing we wanted to do is

105
00:05:23,080 --> 00:05:27,909
actually look at the firmware on this

106
00:05:25,120 --> 00:05:29,110
chip and figure out what's there so to

107
00:05:27,910 --> 00:05:31,840
get the firmware off we found the

108
00:05:29,110 --> 00:05:34,270
easiest way was to desolder it from the

109
00:05:31,840 --> 00:05:36,310
simply safe get a development board and

110
00:05:34,270 --> 00:05:38,590
replace the flash upon the development

111
00:05:36,310 --> 00:05:41,800
board with the flash chip on the simply

112
00:05:38,590 --> 00:05:43,450
safe it's really easy to do that with

113
00:05:41,800 --> 00:05:44,620
the heat gun if you don't have a heat

114
00:05:43,450 --> 00:05:48,370
gun there there's something called a

115
00:05:44,620 --> 00:05:51,870
chip quick and what key uik and it

116
00:05:48,370 --> 00:05:54,520
basically it's like solder that stays

117
00:05:51,870 --> 00:05:56,770
molten for very long like several

118
00:05:54,520 --> 00:06:00,219
seconds so you can basically just splash

119
00:05:56,770 --> 00:06:02,020
it across the pads and and pull the chip

120
00:06:00,220 --> 00:06:03,370
off really quickly it's a really easy

121
00:06:02,020 --> 00:06:05,909
really nice to use if you just have a

122
00:06:03,370 --> 00:06:08,050
soldering iron I want to do this at home

123
00:06:05,910 --> 00:06:11,170
and then you can use the dev kit that

124
00:06:08,050 --> 00:06:14,320
comes with SP 32 to access the flash and

125
00:06:11,170 --> 00:06:16,900
dump all the contents which we did and

126
00:06:14,320 --> 00:06:20,469
we ran a through file and obviously it's

127
00:06:16,900 --> 00:06:22,270
data so we used our next favorite tool

128
00:06:20,470 --> 00:06:24,160
called den walk and we ran it through

129
00:06:22,270 --> 00:06:25,320
then walk and it really doesn't tell us

130
00:06:24,160 --> 00:06:29,629
a whole lot there's a bunch of paths

131
00:06:25,320 --> 00:06:32,240
there is some sha-256 constants

132
00:06:29,629 --> 00:06:33,529
some certificates and private keys but

133
00:06:32,240 --> 00:06:35,240
we need to figure out how this data is

134
00:06:33,529 --> 00:06:37,759
organized so we can do a static analysis

135
00:06:35,240 --> 00:06:41,509
we can't we don't see any binaries or

136
00:06:37,759 --> 00:06:42,979
any anything obvious to look at so it'd

137
00:06:41,509 --> 00:06:45,979
be nice if we could come up with a way

138
00:06:42,979 --> 00:06:48,378
to put the process this flash put into

139
00:06:45,979 --> 00:06:51,529
format we could parse and have it be

140
00:06:48,379 --> 00:06:53,479
repeatable so we need some sort of you

141
00:06:51,529 --> 00:06:56,889
know a little script or a tool to do it

142
00:06:53,479 --> 00:06:56,889
which is what this talk is about

143
00:06:57,520 --> 00:07:02,209
so we looked to see if there is anything

144
00:07:00,229 --> 00:07:04,159
that would do this for us there are a

145
00:07:02,209 --> 00:07:07,189
couple of different things there was a

146
00:07:04,159 --> 00:07:08,869
good blog post on board pentester about

147
00:07:07,189 --> 00:07:13,089
the previous version of this ship the

148
00:07:08,869 --> 00:07:15,259
esp8266 but we couldn't use that

149
00:07:13,089 --> 00:07:17,689
research on our new chip because it

150
00:07:15,259 --> 00:07:20,029
wasn't backwards compatible we found an

151
00:07:17,689 --> 00:07:23,119
Ida plug-in for you know reading the

152
00:07:20,029 --> 00:07:24,139
machine code extends ax CPUs so we did

153
00:07:23,119 --> 00:07:25,610
end up using that that was pretty

154
00:07:24,139 --> 00:07:30,490
helpful

155
00:07:25,610 --> 00:07:34,849
there was a plugin for Ida for loading

156
00:07:30,490 --> 00:07:36,379
the esp8266 like parts of the phone

157
00:07:34,849 --> 00:07:37,938
we're into but it didn't work very well

158
00:07:36,379 --> 00:07:42,559
and it was designed for the older chip

159
00:07:37,939 --> 00:07:44,209
and there was also a another new item

160
00:07:42,559 --> 00:07:46,459
loader by Joe Rosner which I haven't

161
00:07:44,209 --> 00:07:49,159
looked at but apparently it's supposed

162
00:07:46,459 --> 00:07:54,619
to do some of this but we just found out

163
00:07:49,159 --> 00:07:56,808
about that recently so this section will

164
00:07:54,619 --> 00:07:59,569
be dedicated to discussing the firmware

165
00:07:56,809 --> 00:08:01,699
and image layout and it will serve as an

166
00:07:59,569 --> 00:08:03,079
intro to the section it follows and this

167
00:08:01,699 --> 00:08:05,300
will largely be a discussion of the

168
00:08:03,079 --> 00:08:06,680
online documentation but will will teach

169
00:08:05,300 --> 00:08:08,869
the audience the foundational knowledge

170
00:08:06,680 --> 00:08:10,909
that you need to understand the build

171
00:08:08,869 --> 00:08:13,129
process and we'll look at topics such as

172
00:08:10,909 --> 00:08:16,308
partition types image sections and

173
00:08:13,129 --> 00:08:18,499
over-the-air updates so you know the

174
00:08:16,309 --> 00:08:21,499
goal like I said is to take a flash dump

175
00:08:18,499 --> 00:08:23,389
and extract an e.l.f and then if you

176
00:08:21,499 --> 00:08:25,699
take if you get an e LF that we can load

177
00:08:23,389 --> 00:08:28,309
that into Ida no problem because I

178
00:08:25,699 --> 00:08:29,779
didn't understand elf's and it could

179
00:08:28,309 --> 00:08:33,349
portion on all the sections understand

180
00:08:29,779 --> 00:08:35,750
it so in order to extract an elf we need

181
00:08:33,349 --> 00:08:37,250
to know the composition of the flash

182
00:08:35,750 --> 00:08:41,029
contents and we also need to understand

183
00:08:37,250 --> 00:08:42,078
the build process so the first part the

184
00:08:41,029 --> 00:08:43,400
first thing we need to understand is

185
00:08:42,078 --> 00:08:46,219
there's two bootloader

186
00:08:43,400 --> 00:08:48,199
that the SP 32 users one is sort of mom

187
00:08:46,220 --> 00:08:50,270
and it's a first age bootloader and the

188
00:08:48,200 --> 00:08:51,890
second stage is stored in flash and the

189
00:08:50,270 --> 00:08:53,930
first stage doesn't do anything other

190
00:08:51,890 --> 00:08:57,140
than just load the second stage and the

191
00:08:53,930 --> 00:08:59,719
RAM and then handoff execution and then

192
00:08:57,140 --> 00:09:01,640
the second stage starts and if I talk

193
00:08:59,720 --> 00:09:03,770
about boot loaders anymore in this talk

194
00:09:01,640 --> 00:09:06,110
talking about stage 2 and this

195
00:09:03,770 --> 00:09:09,980
bootloader is stored in flash address a

196
00:09:06,110 --> 00:09:12,800
fixed address at hex a thousand so this

197
00:09:09,980 --> 00:09:19,730
is actually what boots up loads it boots

198
00:09:12,800 --> 00:09:21,050
up the application image so first the

199
00:09:19,730 --> 00:09:23,510
bootloader reads the partition table

200
00:09:21,050 --> 00:09:25,760
which is at X 8000 that's a default

201
00:09:23,510 --> 00:09:27,319
location and that will tell you where

202
00:09:25,760 --> 00:09:29,750
all the apps and the data and everything

203
00:09:27,320 --> 00:09:31,910
is found and then it will pick a

204
00:09:29,750 --> 00:09:34,130
partition to boot up to there could be

205
00:09:31,910 --> 00:09:36,079
multiple app partitions because you know

206
00:09:34,130 --> 00:09:39,470
you can you can over-the-air update this

207
00:09:36,080 --> 00:09:41,690
chip so there's a factory partition

208
00:09:39,470 --> 00:09:44,930
usually and then you another partition

209
00:09:41,690 --> 00:09:48,200
gets you know place when you update it

210
00:09:44,930 --> 00:09:49,849
with data so it chooses to see which

211
00:09:48,200 --> 00:09:51,050
partition it should boot to checks to

212
00:09:49,850 --> 00:09:55,550
make sure they're healthy and picks one

213
00:09:51,050 --> 00:09:58,339
and boots here's an example this this is

214
00:09:55,550 --> 00:10:02,569
actually the UART log for the simply

215
00:09:58,340 --> 00:10:03,950
safe that we reversed engineered and you

216
00:10:02,570 --> 00:10:06,620
can see there there's the first stage

217
00:10:03,950 --> 00:10:07,850
running so it's it's doing it the

218
00:10:06,620 --> 00:10:11,960
hardware configuration this is all

219
00:10:07,850 --> 00:10:14,000
hardware configuration and then it goes

220
00:10:11,960 --> 00:10:19,250
and starts loading the second-stage boot

221
00:10:14,000 --> 00:10:20,570
loader into memory and then the second

222
00:10:19,250 --> 00:10:23,930
stage boot loader you can see it right

223
00:10:20,570 --> 00:10:25,940
here loads you can see that it reads the

224
00:10:23,930 --> 00:10:27,469
partition table there's all the that's a

225
00:10:25,940 --> 00:10:28,940
pretty typical configuration we'll talk

226
00:10:27,470 --> 00:10:31,310
about that here in a second but there's

227
00:10:28,940 --> 00:10:32,660
the data partition where that that

228
00:10:31,310 --> 00:10:34,790
basically has the informations from

229
00:10:32,660 --> 00:10:40,250
which partition of v2 which at partition

230
00:10:34,790 --> 00:10:43,130
and these two are the app partitions so

231
00:10:40,250 --> 00:10:44,660
then it picks the boot this ot a one

232
00:10:43,130 --> 00:10:48,080
partition you can see the offset matches

233
00:10:44,660 --> 00:10:53,060
this offset and then it switches a stage

234
00:10:48,080 --> 00:10:55,820
to so you know like I said this

235
00:10:53,060 --> 00:10:56,780
partition keeps track of which partition

236
00:10:55,820 --> 00:10:58,850
to boot to its

237
00:10:56,780 --> 00:11:01,189
the over-the-air update and process it's

238
00:10:58,850 --> 00:11:03,910
written - this year keeps track of some

239
00:11:01,190 --> 00:11:05,960
physical configuration information but

240
00:11:03,910 --> 00:11:07,189
you don't really it's not really used

241
00:11:05,960 --> 00:11:09,140
that much anymore you can actually get

242
00:11:07,190 --> 00:11:12,050
rid of it if you need to save space it's

243
00:11:09,140 --> 00:11:13,610
built into the apps now this year we'll

244
00:11:12,050 --> 00:11:15,620
talk about is it's got this is called

245
00:11:13,610 --> 00:11:17,570
non-volatile storage it's like a little

246
00:11:15,620 --> 00:11:20,090
miniature key value pair file system

247
00:11:17,570 --> 00:11:24,140
that has you can use there's there's a

248
00:11:20,090 --> 00:11:26,690
API and that kit to use it this year is

249
00:11:24,140 --> 00:11:29,569
a ble data partition and it has a little

250
00:11:26,690 --> 00:11:33,050
binary that if using the chip or using

251
00:11:29,570 --> 00:11:35,840
the device as a ble Bluetooth server you

252
00:11:33,050 --> 00:11:38,209
you'll put this on there and there are

253
00:11:35,840 --> 00:11:40,550
the two data partitions and there's

254
00:11:38,210 --> 00:11:42,620
usually like a factory partition also

255
00:11:40,550 --> 00:11:44,780
and there's usually two other OTA

256
00:11:42,620 --> 00:11:46,820
partitions but this one just uses OT a

257
00:11:44,780 --> 00:11:48,459
zero as the factory partition and a lot

258
00:11:46,820 --> 00:11:52,040
of them will do that at the same space

259
00:11:48,460 --> 00:11:54,170
so the reason is booting from ot a one

260
00:11:52,040 --> 00:11:57,349
is because ot a 0 is the factory

261
00:11:54,170 --> 00:12:00,319
built-in partition so somewhere along

262
00:11:57,350 --> 00:12:03,200
the line it got updated data one on OTA

263
00:12:00,320 --> 00:12:05,090
one it updated the OTA data and then the

264
00:12:03,200 --> 00:12:14,450
device is booting from the data

265
00:12:05,090 --> 00:12:16,340
partition alright so now that we know

266
00:12:14,450 --> 00:12:19,610
how the flash is laid out and what the

267
00:12:16,340 --> 00:12:20,990
partitions are and we'll be examining

268
00:12:19,610 --> 00:12:23,150
how the data is structured in the

269
00:12:20,990 --> 00:12:24,860
application partition and these are the

270
00:12:23,150 --> 00:12:26,420
OTA data partition and the factory

271
00:12:24,860 --> 00:12:29,050
partition and it's available so all

272
00:12:26,420 --> 00:12:36,829
these partition types that you might see

273
00:12:29,050 --> 00:12:38,420
all right can everyone hear me okay all

274
00:12:36,830 --> 00:12:40,820
right all right so now we'll be talking

275
00:12:38,420 --> 00:12:42,620
about the application format and like

276
00:12:40,820 --> 00:12:45,290
Nick said the the bootloader has to pick

277
00:12:42,620 --> 00:12:50,870
an app so we had to understand what that

278
00:12:45,290 --> 00:12:53,030
app looked like so an app partition it

279
00:12:50,870 --> 00:12:55,580
has a very specific structure as you can

280
00:12:53,030 --> 00:12:58,970
see it starts off with an app header and

281
00:12:55,580 --> 00:13:02,450
then you know we have either code

282
00:12:58,970 --> 00:13:05,420
segments or data segments and so each

283
00:13:02,450 --> 00:13:07,220
segment we'll have a its own header and

284
00:13:05,420 --> 00:13:09,329
then data you know you can have any

285
00:13:07,220 --> 00:13:11,310
number of segments

286
00:13:09,330 --> 00:13:14,700
and then also we'll have a checksum byte

287
00:13:11,310 --> 00:13:20,489
and optionally sha-256 and a digital

288
00:13:14,700 --> 00:13:21,959
signature for integrity verification and

289
00:13:20,490 --> 00:13:24,180
so if we we drill down a little bit

290
00:13:21,959 --> 00:13:26,640
deeper into the app image header you can

291
00:13:24,180 --> 00:13:29,550
see that it's broken down into a common

292
00:13:26,640 --> 00:13:32,040
and extended header so if we run through

293
00:13:29,550 --> 00:13:35,189
these fields here see we have a magic

294
00:13:32,040 --> 00:13:37,860
word so that just lets the you know the

295
00:13:35,190 --> 00:13:40,110
the chip figure out that this is an app

296
00:13:37,860 --> 00:13:42,120
image header that's starting then we

297
00:13:40,110 --> 00:13:43,860
also have a segment count and then

298
00:13:42,120 --> 00:13:47,279
there's some settings there that tell

299
00:13:43,860 --> 00:13:50,820
the chip this is how fast to read to

300
00:13:47,279 --> 00:13:53,189
read the the chip here and also how big

301
00:13:50,820 --> 00:13:55,320
it is like our flash chip was four

302
00:13:53,190 --> 00:13:57,329
megabytes so that would be in here and

303
00:13:55,320 --> 00:13:59,850
also we have an entry point address so

304
00:13:57,329 --> 00:14:02,370
where does the code start and if in the

305
00:13:59,850 --> 00:14:04,560
extended header we have some settings

306
00:14:02,370 --> 00:14:07,260
here like write protect pin spy pen

307
00:14:04,560 --> 00:14:10,170
drive settings and also the chip ID and

308
00:14:07,260 --> 00:14:13,920
then this piece is important here it

309
00:14:10,170 --> 00:14:16,649
tells tells the the chip whether it can

310
00:14:13,920 --> 00:14:17,910
actually read this image or not then we

311
00:14:16,649 --> 00:14:22,709
have a reserved section here and then

312
00:14:17,910 --> 00:14:24,420
another shot 256 so the the segment

313
00:14:22,709 --> 00:14:27,149
header is a little bit simpler here

314
00:14:24,420 --> 00:14:28,649
we've just got two fields it specifies

315
00:14:27,149 --> 00:14:34,829
where the load address will be and then

316
00:14:28,649 --> 00:14:36,690
also the length of the data and so like

317
00:14:34,829 --> 00:14:38,219
I said we have two different segment

318
00:14:36,690 --> 00:14:41,190
types you can either have code or you

319
00:14:38,220 --> 00:14:42,959
can have data and so if you like a an

320
00:14:41,190 --> 00:14:45,470
app segment type is going to have code

321
00:14:42,959 --> 00:14:49,739
and you can store it in three different

322
00:14:45,470 --> 00:14:53,339
segments in memory you have I Ram I ROM

323
00:14:49,740 --> 00:14:56,730
or RTC fast memory and so I Ram is

324
00:14:53,339 --> 00:14:59,190
that's instruction RAM and it does have

325
00:14:56,730 --> 00:15:01,770
a specific purpose so a few of the

326
00:14:59,190 --> 00:15:03,149
components like of the development

327
00:15:01,770 --> 00:15:05,970
framework and then the Wi-Fi stack are

328
00:15:03,149 --> 00:15:07,709
placed in here and and also the

329
00:15:05,970 --> 00:15:09,570
developer like let's say they want the

330
00:15:07,709 --> 00:15:13,079
code to run faster though they'll say

331
00:15:09,570 --> 00:15:15,360
you know they'll specify that the code

332
00:15:13,079 --> 00:15:17,420
should be run from RAM and then also we

333
00:15:15,360 --> 00:15:19,970
have a ROM that's

334
00:15:17,420 --> 00:15:21,979
executed from flash and the difference

335
00:15:19,970 --> 00:15:23,570
here is that the memory mapping unit

336
00:15:21,980 --> 00:15:26,930
will have to be used to actually put

337
00:15:23,570 --> 00:15:29,080
into RAM and then also the device has

338
00:15:26,930 --> 00:15:31,339
the ability to go into low-power mode so

339
00:15:29,080 --> 00:15:33,560
if that were the case and it needed to

340
00:15:31,340 --> 00:15:40,190
wake up from like deep sleep I would use

341
00:15:33,560 --> 00:15:42,500
RTC fast memory and so on the data side

342
00:15:40,190 --> 00:15:45,320
we you know similar similar concept here

343
00:15:42,500 --> 00:15:49,040
we have three different regions DRAM ROM

344
00:15:45,320 --> 00:15:51,230
and then RTC so generally the non

345
00:15:49,040 --> 00:15:54,500
constant data and zero initialized data

346
00:15:51,230 --> 00:15:58,070
goes in that that DRAM section and in d

347
00:15:54,500 --> 00:15:59,810
rom again that's that's flash by default

348
00:15:58,070 --> 00:16:01,880
we have constant data stored here and

349
00:15:59,810 --> 00:16:04,760
then as we'll see in the the next slide

350
00:16:01,880 --> 00:16:06,140
there's a specific purpose for that iran

351
00:16:04,760 --> 00:16:09,260
segment and that's describing the

352
00:16:06,140 --> 00:16:11,030
application and then also like like i

353
00:16:09,260 --> 00:16:11,840
was just talking about with coming out

354
00:16:11,030 --> 00:16:14,360
from deep sleep

355
00:16:11,840 --> 00:16:16,100
we have RTC slow memory so that will

356
00:16:14,360 --> 00:16:20,540
store Global's and statics related to

357
00:16:16,100 --> 00:16:21,680
that kind of code so the DRAM segment I

358
00:16:20,540 --> 00:16:24,110
just talked about which is the

359
00:16:21,680 --> 00:16:27,199
application description it has its own

360
00:16:24,110 --> 00:16:29,960
format at the top it has its own magic

361
00:16:27,200 --> 00:16:32,510
word we have a secure version and that's

362
00:16:29,960 --> 00:16:34,370
for anti rollback purposes

363
00:16:32,510 --> 00:16:37,310
we also have two reserved fields that

364
00:16:34,370 --> 00:16:39,740
aren't used at the moment but then most

365
00:16:37,310 --> 00:16:42,050
importantly here this segment it tells

366
00:16:39,740 --> 00:16:44,750
you the application version project name

367
00:16:42,050 --> 00:16:46,790
compile date and time and then also the

368
00:16:44,750 --> 00:16:49,790
version of the development framework

369
00:16:46,790 --> 00:16:53,920
that was used to create the the app and

370
00:16:49,790 --> 00:16:53,920
also we have a sha-256 of the elf file

371
00:16:54,190 --> 00:17:00,290
okay so now we've kind of got an idea of

372
00:16:57,640 --> 00:17:02,689
what that application image format is

373
00:17:00,290 --> 00:17:05,210
you know we've got an app app header and

374
00:17:02,690 --> 00:17:07,900
then for each segment we've got its own

375
00:17:05,210 --> 00:17:13,280
header segment data and then some

376
00:17:07,900 --> 00:17:15,020
integrity verification stuff so if we

377
00:17:13,280 --> 00:17:16,970
zoom out a little bit you know in our

378
00:17:15,020 --> 00:17:20,660
grand scheme of things we want to take

379
00:17:16,970 --> 00:17:22,280
it ultimately to high to pro right so

380
00:17:20,660 --> 00:17:24,790
that's kind of where everything fits

381
00:17:22,280 --> 00:17:24,790
into the flash

382
00:17:26,349 --> 00:17:31,120
so now we can kind of start taking a

383
00:17:28,390 --> 00:17:33,580
look at the the build process of how the

384
00:17:31,120 --> 00:17:35,909
firmware is built before it's put on to

385
00:17:33,580 --> 00:17:35,909
the device

386
00:17:38,730 --> 00:17:43,360
all right so bear with me I know the

387
00:17:40,990 --> 00:17:45,940
codes kind of small but in order for us

388
00:17:43,360 --> 00:17:47,770
to understand the process we started off

389
00:17:45,940 --> 00:17:49,539
with a hello world application so we've

390
00:17:47,770 --> 00:17:52,389
got some C code kind of like you would

391
00:17:49,539 --> 00:17:54,460
use with an Arduino or whatever but

392
00:17:52,390 --> 00:17:56,860
basically it's going to print out hello

393
00:17:54,460 --> 00:17:58,960
world it's then it'll print out some

394
00:17:56,860 --> 00:18:01,479
chip information and then after 10

395
00:17:58,960 --> 00:18:06,820
seconds it'll reboot so pretty pretty

396
00:18:01,480 --> 00:18:09,100
basic and so when you actually want to

397
00:18:06,820 --> 00:18:10,270
build the project and compile it that

398
00:18:09,100 --> 00:18:12,939
the development framework makes it

399
00:18:10,270 --> 00:18:15,100
really simple all you do is run a Python

400
00:18:12,940 --> 00:18:17,409
script ID effed-up high and then pass it

401
00:18:15,100 --> 00:18:19,418
a build parameter and if your if you

402
00:18:17,409 --> 00:18:22,000
were to look into that bill directory

403
00:18:19,419 --> 00:18:24,460
that has you know the contents of the

404
00:18:22,000 --> 00:18:26,350
output you would see that you've got

405
00:18:24,460 --> 00:18:28,720
number one a hello world

406
00:18:26,350 --> 00:18:31,750
elf file and in case you're not familiar

407
00:18:28,720 --> 00:18:35,740
the elf is that's the executable format

408
00:18:31,750 --> 00:18:38,080
used on on Linux you'll also have a

409
00:18:35,740 --> 00:18:40,270
hello world bin file and then a

410
00:18:38,080 --> 00:18:44,110
bootloader directory and a partition

411
00:18:40,270 --> 00:18:45,879
table directory and if you were to look

412
00:18:44,110 --> 00:18:47,889
into the bootloader directory you'd also

413
00:18:45,880 --> 00:18:51,580
have an elf there and you'd have that

414
00:18:47,890 --> 00:18:53,409
binary format as well and in the

415
00:18:51,580 --> 00:18:59,918
partition table directory you'll just

416
00:18:53,409 --> 00:19:01,299
have the binary format so after your

417
00:18:59,919 --> 00:19:04,240
compilation happens and you built

418
00:19:01,299 --> 00:19:06,940
everything the the IDF will tell you

419
00:19:04,240 --> 00:19:08,200
that ok now your stuffs built you need

420
00:19:06,940 --> 00:19:10,210
to put it on the chip you need to flash

421
00:19:08,200 --> 00:19:12,610
it and there's a command that you can

422
00:19:10,210 --> 00:19:15,490
run using esp tool which comes with the

423
00:19:12,610 --> 00:19:17,979
development framework so it tells you

424
00:19:15,490 --> 00:19:19,090
exactly how to flash it and it literally

425
00:19:17,980 --> 00:19:21,340
tells you the command this is the

426
00:19:19,090 --> 00:19:24,668
commander told me and as you can see the

427
00:19:21,340 --> 00:19:26,649
bootloader bin and then partition table

428
00:19:24,669 --> 00:19:30,240
been hello world bin those all need to

429
00:19:26,650 --> 00:19:32,679
get flashed but we had to figure out

430
00:19:30,240 --> 00:19:35,020
where do these binary file without

431
00:19:32,679 --> 00:19:37,420
excuse me where did the binary files

432
00:19:35,020 --> 00:19:39,940
come from

433
00:19:37,420 --> 00:19:42,820
and the answer is that there's a another

434
00:19:39,940 --> 00:19:45,070
tool with an ESP pie yes be tool it's

435
00:19:42,820 --> 00:19:47,500
called health to image so it literally

436
00:19:45,070 --> 00:19:52,389
converts the elf through the binary

437
00:19:47,500 --> 00:19:56,040
format and the partition table a little

438
00:19:52,390 --> 00:19:58,720
different there's there's no elf instead

439
00:19:56,040 --> 00:20:00,389
you specify a partition table format

440
00:19:58,720 --> 00:20:03,610
kind of like Nick talked about before

441
00:20:00,390 --> 00:20:05,710
you and it's in a comma separated value

442
00:20:03,610 --> 00:20:10,719
format and then you can run a tool and

443
00:20:05,710 --> 00:20:12,220
it'll build that binary so if we go back

444
00:20:10,720 --> 00:20:14,890
to the command that we were told to use

445
00:20:12,220 --> 00:20:16,930
to flash everything kind of makes sense

446
00:20:14,890 --> 00:20:19,150
right with what Nick told us the stage

447
00:20:16,930 --> 00:20:21,250
to boot loaders at hex 1000 and yellow

448
00:20:19,150 --> 00:20:24,040
then we have the partition table at hex

449
00:20:21,250 --> 00:20:26,590
8000 that's in pink and then our factory

450
00:20:24,040 --> 00:20:30,909
app which is the hello world got flashed

451
00:20:26,590 --> 00:20:36,070
to hex 10,000 okay and here's the output

452
00:20:30,910 --> 00:20:37,720
we get you know kind of same story and

453
00:20:36,070 --> 00:20:38,169
when we run it we get the expected

454
00:20:37,720 --> 00:20:40,510
output

455
00:20:38,170 --> 00:20:44,910
we got hello world got the chip info and

456
00:20:40,510 --> 00:20:47,620
then it's going to reboot in ten seconds

457
00:20:44,910 --> 00:20:49,780
okay so now we've we've taken a look at

458
00:20:47,620 --> 00:20:51,610
the build process where we you know

459
00:20:49,780 --> 00:20:54,070
bootloader starts as an elf it's

460
00:20:51,610 --> 00:20:55,719
converted to a bin same story with the

461
00:20:54,070 --> 00:20:58,000
hello world and that's our you know

462
00:20:55,720 --> 00:21:00,370
that's our app that we want to run but

463
00:20:58,000 --> 00:21:03,040
the partition table goes from CSV to the

464
00:21:00,370 --> 00:21:09,550
binary format then all that gets flashed

465
00:21:03,040 --> 00:21:12,670
onto the chip okay so now we got to go a

466
00:21:09,550 --> 00:21:14,560
little bit deeper here now that we know

467
00:21:12,670 --> 00:21:16,630
that elf gets turned into a binary how

468
00:21:14,560 --> 00:21:24,850
does it actually with what's the magic

469
00:21:16,630 --> 00:21:28,540
there that happens all right so more

470
00:21:24,850 --> 00:21:30,730
small code apologize for that but okay

471
00:21:28,540 --> 00:21:32,200
so we're converting an elf to the image

472
00:21:30,730 --> 00:21:35,080
here so the first thing that happens is

473
00:21:32,200 --> 00:21:38,980
we load up an elf file that HelloWorld

474
00:21:35,080 --> 00:21:41,590
elf and that's pretty basic we've

475
00:21:38,980 --> 00:21:44,440
there's a custom elf file class that

476
00:21:41,590 --> 00:21:47,470
gets used so there's a call to to read

477
00:21:44,440 --> 00:21:50,290
elf file and if we dive into there

478
00:21:47,470 --> 00:21:50,700
basically that read elf file function

479
00:21:50,290 --> 00:21:53,519
has

480
00:21:50,700 --> 00:21:55,590
the main purpose of validating that elf

481
00:21:53,519 --> 00:21:58,289
file so it looks at the elf header

482
00:21:55,590 --> 00:22:02,309
structure make sure it looks good also

483
00:21:58,289 --> 00:22:04,379
the the CPU architecture of the the chip

484
00:22:02,309 --> 00:22:07,080
is extends ax so you might have heard

485
00:22:04,379 --> 00:22:13,738
like x86 or arm it's neither of those

486
00:22:07,080 --> 00:22:15,210
it's a it's extends ax so yeah so we're

487
00:22:13,739 --> 00:22:17,609
checking to make sure the header entries

488
00:22:15,210 --> 00:22:19,289
are the proper size and then it has to

489
00:22:17,609 --> 00:22:24,418
have section headers in order for us to

490
00:22:19,289 --> 00:22:26,399
convert it okay and so if if that all

491
00:22:24,419 --> 00:22:32,519
passes then we're able to start reading

492
00:22:26,399 --> 00:22:35,998
sections let me zoom in here for you and

493
00:22:32,519 --> 00:22:38,279
so it chooses sections from the elf file

494
00:22:35,999 --> 00:22:40,889
to include in the application image

495
00:22:38,279 --> 00:22:43,289
based on whether the section is of type

496
00:22:40,889 --> 00:22:44,820
program bits and also a checks to make

497
00:22:43,289 --> 00:22:48,029
sure that the load address is going to

498
00:22:44,820 --> 00:22:49,859
be it's not going to be 0 and then also

499
00:22:48,029 --> 00:22:54,029
the size of the the section has to be

500
00:22:49,859 --> 00:22:55,970
greater than 0 and so something to take

501
00:22:54,029 --> 00:22:59,039
note of is that since we're choosing

502
00:22:55,970 --> 00:23:01,200
sections of type program bits we're

503
00:22:59,039 --> 00:23:03,210
actually leaving out the symbol table

504
00:23:01,200 --> 00:23:04,919
and that's really important to reverse

505
00:23:03,210 --> 00:23:06,570
engineering because we need to know

506
00:23:04,919 --> 00:23:11,600
function names and variable names stuff

507
00:23:06,570 --> 00:23:15,359
like that okay so just recap real quick

508
00:23:11,600 --> 00:23:17,189
when we when we load up that elf file we

509
00:23:15,359 --> 00:23:19,199
first have to validate it you make sure

510
00:23:17,190 --> 00:23:22,289
the elf looks good that it's built for

511
00:23:19,200 --> 00:23:24,330
the the chip then we also select

512
00:23:22,289 --> 00:23:27,658
particular elf sections you know with

513
00:23:24,330 --> 00:23:31,019
program bits address and size how to

514
00:23:27,659 --> 00:23:33,570
check those so the next part now that

515
00:23:31,019 --> 00:23:36,299
we've parsed out the elf file we got to

516
00:23:33,570 --> 00:23:38,309
build out the the new ESP 32 firmware

517
00:23:36,299 --> 00:23:43,080
image so that's that the constructor

518
00:23:38,309 --> 00:23:45,418
call right here so since we're not

519
00:23:43,080 --> 00:23:48,418
loading a file this whole section down

520
00:23:45,419 --> 00:23:51,480
here does not get executed and just that

521
00:23:48,419 --> 00:23:53,340
top block does you might recognize some

522
00:23:51,480 --> 00:23:55,580
of the fields in here we talked about

523
00:23:53,340 --> 00:23:59,539
them earlier like the flash read mode

524
00:23:55,580 --> 00:23:59,539
flash size frequency

525
00:24:01,170 --> 00:24:04,830
okay and if we go a little bit further

526
00:24:02,190 --> 00:24:07,080
down here the next thing that happens is

527
00:24:04,830 --> 00:24:11,340
we're we're copying over elf sections

528
00:24:07,080 --> 00:24:13,620
into the new image segments so first we

529
00:24:11,340 --> 00:24:19,770
copy over the entry point then we copy

530
00:24:13,620 --> 00:24:23,969
over elf sections and we're able to do

531
00:24:19,770 --> 00:24:26,480
that because the the image segment is

532
00:24:23,970 --> 00:24:29,400
actually a superclass of the elf section

533
00:24:26,480 --> 00:24:32,130
so if you take a look here we've got you

534
00:24:29,400 --> 00:24:34,530
know that's load address the data in an

535
00:24:32,130 --> 00:24:36,300
image segment and file offset and the

536
00:24:34,530 --> 00:24:37,770
the health section class has the exact

537
00:24:36,300 --> 00:24:42,540
same attributes so we can just copy

538
00:24:37,770 --> 00:24:45,990
those over okay so here's another high

539
00:24:42,540 --> 00:24:51,000
level copy over the entry point and then

540
00:24:45,990 --> 00:24:52,770
we're copying over elf sections and the

541
00:24:51,000 --> 00:24:56,580
most important part here we got to

542
00:24:52,770 --> 00:24:59,010
actually save that that image so this

543
00:24:56,580 --> 00:25:01,649
this method is longer so I've split it

544
00:24:59,010 --> 00:25:02,910
up into a few sections here but

545
00:25:01,650 --> 00:25:05,010
basically what happens is we first

546
00:25:02,910 --> 00:25:08,070
create the common and the extended

547
00:25:05,010 --> 00:25:10,379
header like we talked about earlier and

548
00:25:08,070 --> 00:25:16,889
then flash segments and RAM segments are

549
00:25:10,380 --> 00:25:18,390
split out based on their address and so

550
00:25:16,890 --> 00:25:19,820
there's a constraint here that has to be

551
00:25:18,390 --> 00:25:23,430
checked

552
00:25:19,820 --> 00:25:26,639
flash segments cannot be in the same 64

553
00:25:23,430 --> 00:25:29,490
kilobyte mapping region so if that were

554
00:25:26,640 --> 00:25:31,710
to happen how's the comment suggesting

555
00:25:29,490 --> 00:25:38,360
here that would be you know be

556
00:25:31,710 --> 00:25:41,400
indicative of a broken linker script so

557
00:25:38,360 --> 00:25:45,060
when we're writing flash segments we

558
00:25:41,400 --> 00:25:48,360
might have to write padding and the way

559
00:25:45,060 --> 00:25:49,980
we do that is with excess RAM segments

560
00:25:48,360 --> 00:25:51,719
or if we don't have any of those and we

561
00:25:49,980 --> 00:25:55,430
have padded with no bytes in order to

562
00:25:51,720 --> 00:25:55,430
fill up that 64 kilobytes

563
00:25:58,240 --> 00:26:03,559
so here's a graphic for that you know we

564
00:26:01,220 --> 00:26:04,940
got the 64 kilobytes might have to put a

565
00:26:03,559 --> 00:26:10,220
ram segment in there or just fill it up

566
00:26:04,940 --> 00:26:12,110
with nulls the next next thing here is

567
00:26:10,220 --> 00:26:13,970
just to write out any remaining Ram

568
00:26:12,110 --> 00:26:15,678
segments so if we didn't use them for

569
00:26:13,970 --> 00:26:22,070
padding then we just we're just gonna

570
00:26:15,679 --> 00:26:24,710
write him out and also if if secure

571
00:26:22,070 --> 00:26:27,230
padding was needed we'll end up padding

572
00:26:24,710 --> 00:26:33,320
the the image so that it ends after

573
00:26:27,230 --> 00:26:34,760
signing on a 64 kilobyte boundary and so

574
00:26:33,320 --> 00:26:36,070
after we've done all that we kind of

575
00:26:34,760 --> 00:26:38,570
have to go back in and update the image

576
00:26:36,070 --> 00:26:41,299
make sure the segment count is updated

577
00:26:38,570 --> 00:26:45,230
you know to include any any padding

578
00:26:41,299 --> 00:26:48,440
segments also will append a digest if

579
00:26:45,230 --> 00:26:50,650
needed and then we'll go ahead and write

580
00:26:48,440 --> 00:26:53,540
it out

581
00:26:50,650 --> 00:26:57,100
okay so another high-level overview here

582
00:26:53,540 --> 00:27:00,549
so first we create that app image header

583
00:26:57,100 --> 00:27:04,280
next we have to write out the the

584
00:27:00,549 --> 00:27:06,110
segments whether it be flash or Ram we

585
00:27:04,280 --> 00:27:07,580
might end up using some padding you know

586
00:27:06,110 --> 00:27:10,040
depending on how big those those

587
00:27:07,580 --> 00:27:12,139
segments are and then also after we do

588
00:27:10,040 --> 00:27:14,030
all this is padding stuff then we'll

589
00:27:12,140 --> 00:27:18,370
update the checksum update segments

590
00:27:14,030 --> 00:27:18,370
count and then update the sha-256 hash

591
00:27:18,610 --> 00:27:23,928
okay so this graphic is kind of I'm

592
00:27:22,280 --> 00:27:27,350
trying to help you visualize what we

593
00:27:23,929 --> 00:27:29,240
just talked about so the top here is the

594
00:27:27,350 --> 00:27:31,250
conversion that happens when you convert

595
00:27:29,240 --> 00:27:34,429
an elf to an image and I've added some

596
00:27:31,250 --> 00:27:36,679
print statements here but like so if you

597
00:27:34,429 --> 00:27:39,130
remember we just will write out flash

598
00:27:36,679 --> 00:27:42,410
segments first and if we need padding

599
00:27:39,130 --> 00:27:44,120
we'll pull them from RAM segments so

600
00:27:42,410 --> 00:27:47,540
that's why we have these padded segments

601
00:27:44,120 --> 00:27:50,629
right here and then then we'll write

602
00:27:47,540 --> 00:27:54,940
another flash segment and then since

603
00:27:50,630 --> 00:27:57,590
this I rammed text was used as padding

604
00:27:54,940 --> 00:27:59,090
only part of it was used as padding so

605
00:27:57,590 --> 00:28:02,449
we have to write out the rest at the end

606
00:27:59,090 --> 00:28:04,580
here and this bottom image it's just

607
00:28:02,450 --> 00:28:08,330
showing some information about the image

608
00:28:04,580 --> 00:28:10,189
we just converted so if you look at it

609
00:28:08,330 --> 00:28:12,439
it all kind of matches up right so

610
00:28:10,190 --> 00:28:16,039
we have a flash read-only in yellow that

611
00:28:12,440 --> 00:28:20,029
maps out 2d ROM then we also have D Ram

612
00:28:16,039 --> 00:28:21,379
data in pink that maps out to D Ram you

613
00:28:20,029 --> 00:28:25,549
know if you were to trace it here you

614
00:28:21,379 --> 00:28:27,799
make sense and in the teal notice that

615
00:28:25,549 --> 00:28:32,539
it was also split out as well and

616
00:28:27,799 --> 00:28:34,879
that'll be important moving forward so

617
00:28:32,539 --> 00:28:42,259
here's the observed mapping just to help

618
00:28:34,879 --> 00:28:43,549
you visualize it even better okay so now

619
00:28:42,259 --> 00:28:48,860
we've gotten through the elf to image

620
00:28:43,549 --> 00:28:50,960
process and now we can start talking

621
00:28:48,860 --> 00:28:54,709
about our tooling which is the reverse

622
00:28:50,960 --> 00:29:03,559
of that process and I'll hand it over to

623
00:28:54,710 --> 00:29:05,269
to Nick all right so our tool do several

624
00:29:03,559 --> 00:29:08,000
things it can show all the partitions

625
00:29:05,269 --> 00:29:11,120
around them to flash dump it can dump a

626
00:29:08,000 --> 00:29:13,490
specified partition to disk and you can

627
00:29:11,120 --> 00:29:15,860
convert an app partition back to an elf

628
00:29:13,490 --> 00:29:17,509
which I didn't understand elves and load

629
00:29:15,860 --> 00:29:18,229
them without any problem you build any

630
00:29:17,509 --> 00:29:20,509
sort of loader

631
00:29:18,230 --> 00:29:22,429
you should probably wrote this and it

632
00:29:20,509 --> 00:29:25,820
can also dump the contents at the nvs

633
00:29:22,429 --> 00:29:28,250
non-volatile storage partition so here's

634
00:29:25,820 --> 00:29:31,009
what the partition table looks like it's

635
00:29:28,250 --> 00:29:34,309
not a standard Perdition table that i've

636
00:29:31,009 --> 00:29:36,649
seen before it's kind of strange but it

637
00:29:34,309 --> 00:29:39,408
there's basically it's 495 entries that

638
00:29:36,649 --> 00:29:40,789
you'll never use so there's no way to

639
00:29:39,409 --> 00:29:42,049
know how many entries are in advance you

640
00:29:40,789 --> 00:29:44,990
kind of just go through it until you hit

641
00:29:42,049 --> 00:29:48,730
it in marker which has an basis or has

642
00:29:44,990 --> 00:29:53,029
an md5 sum of all the previous entries

643
00:29:48,730 --> 00:29:56,840
combined together and it's you know each

644
00:29:53,029 --> 00:29:58,549
build is 32 bytes there's some magic a

645
00:29:56,840 --> 00:30:00,769
partition type is sub tight so you can

646
00:29:58,549 --> 00:30:02,870
figure out if it's data or an app if

647
00:30:00,769 --> 00:30:07,490
it's a if it's an app if the partition

648
00:30:02,870 --> 00:30:10,549
type is an app there's you can it can be

649
00:30:07,490 --> 00:30:13,970
factory or test and if it's data that

650
00:30:10,549 --> 00:30:15,230
the part types can be OTA or fi-fire nvs

651
00:30:13,970 --> 00:30:17,029
and then there are so it's pretty

652
00:30:15,230 --> 00:30:18,710
self-explanatory there's offset where

653
00:30:17,029 --> 00:30:21,080
you can find the data

654
00:30:18,710 --> 00:30:23,210
those are size there's a label a null

655
00:30:21,080 --> 00:30:24,139
terminating and there's a flag that's at

656
00:30:23,210 --> 00:30:25,790
the end right now

657
00:30:24,140 --> 00:30:30,020
tell you if the partition is encrypted

658
00:30:25,790 --> 00:30:31,340
or not it's all it's ports and that's

659
00:30:30,020 --> 00:30:37,040
pretty much it for the partition table

660
00:30:31,340 --> 00:30:38,990
parsing it's pretty simple alright so

661
00:30:37,040 --> 00:30:41,030
since we can parse the partition table

662
00:30:38,990 --> 00:30:47,530
now we can pick out an app that we want

663
00:30:41,030 --> 00:30:50,090
to convert to an elf Wow oops excuse me

664
00:30:47,530 --> 00:30:53,899
so here's our image two elf

665
00:30:50,090 --> 00:30:55,549
you know reverse of elf 2 image you know

666
00:30:53,900 --> 00:30:57,799
fortunately we were able to reuse some

667
00:30:55,549 --> 00:30:59,929
of the code that's already provided with

668
00:30:57,799 --> 00:31:01,840
the development framework so we were

669
00:30:59,929 --> 00:31:05,090
able to use this load firmware image

670
00:31:01,840 --> 00:31:08,230
function and basically it just loads up

671
00:31:05,090 --> 00:31:11,080
app segments so that was super helpful

672
00:31:08,230 --> 00:31:14,360
the next thing that we had to do is

673
00:31:11,080 --> 00:31:15,830
create an elf and we used this you can

674
00:31:14,360 --> 00:31:18,229
see it down here but we use the make elf

675
00:31:15,830 --> 00:31:19,750
module to do that so you know we're

676
00:31:18,230 --> 00:31:23,570
creating an elf that's little-endian

677
00:31:19,750 --> 00:31:27,260
with an extensive CPU and then we copy

678
00:31:23,570 --> 00:31:28,629
over the entry point and again if we

679
00:31:27,260 --> 00:31:31,730
look at that mapping that we use before

680
00:31:28,630 --> 00:31:35,660
we could create a dictionary to to map

681
00:31:31,730 --> 00:31:37,549
health sections to the image segments so

682
00:31:35,660 --> 00:31:40,809
that's you know that's why you see iran

683
00:31:37,549 --> 00:31:43,370
it's mapped up to flash read-only data

684
00:31:40,809 --> 00:31:46,309
the one thing you might note notice is

685
00:31:43,370 --> 00:31:47,418
that i ram 0 is not in there at all and

686
00:31:46,309 --> 00:31:47,960
that's that's because it's kind of a

687
00:31:47,419 --> 00:31:50,540
special case

688
00:31:47,960 --> 00:31:52,460
you know it's split into two separate

689
00:31:50,540 --> 00:31:55,100
ones here and then also you know we had

690
00:31:52,460 --> 00:31:58,340
had to work with that and also we're not

691
00:31:55,100 --> 00:32:03,590
accounting for the real-time clock so

692
00:31:58,340 --> 00:32:05,000
that that's on the to-do list so the

693
00:32:03,590 --> 00:32:07,309
next thing that we had to do is define

694
00:32:05,000 --> 00:32:09,230
the section header attributes and we

695
00:32:07,309 --> 00:32:11,450
went we're able to do this based off of

696
00:32:09,230 --> 00:32:15,320
the retail output so if you look up here

697
00:32:11,450 --> 00:32:18,530
like you'll see you know we've got read

698
00:32:15,320 --> 00:32:20,899
or write execute so these are attributes

699
00:32:18,530 --> 00:32:22,970
and then we've got some alignment stuff

700
00:32:20,900 --> 00:32:30,559
here and we hooked it all up in these

701
00:32:22,970 --> 00:32:31,970
these dictionaries so the next thing we

702
00:32:30,559 --> 00:32:33,740
could do after creating those mappings

703
00:32:31,970 --> 00:32:36,080
and whatnot is we could start

704
00:32:33,740 --> 00:32:37,380
constructing the section data and again

705
00:32:36,080 --> 00:32:39,780
we had a

706
00:32:37,380 --> 00:32:44,250
for the special case where I Ramsey row

707
00:32:39,780 --> 00:32:47,250
was split into vectors and text and then

708
00:32:44,250 --> 00:32:51,390
also padding what had to be accounted

709
00:32:47,250 --> 00:32:54,150
for to and so then we were able to

710
00:32:51,390 --> 00:32:57,690
actually create the help sections again

711
00:32:54,150 --> 00:32:59,850
there of type program bits and then we

712
00:32:57,690 --> 00:33:02,810
we tack on the section header attributes

713
00:32:59,850 --> 00:33:07,350
that we restored in that that dictionary

714
00:33:02,810 --> 00:33:09,720
and we also we added in a string table

715
00:33:07,350 --> 00:33:11,790
and a symbol table the string table

716
00:33:09,720 --> 00:33:14,130
really helps with like you know back

717
00:33:11,790 --> 00:33:15,780
referencing stuff in Ida the only

718
00:33:14,130 --> 00:33:17,910
problem you know we tried to add some

719
00:33:15,780 --> 00:33:22,340
health symbols in but we weren't able to

720
00:33:17,910 --> 00:33:24,210
use like dynamic link library stuff

721
00:33:22,340 --> 00:33:29,220
because they pulled out all those

722
00:33:24,210 --> 00:33:31,620
symbols so the next step was to create

723
00:33:29,220 --> 00:33:34,050
the program headers kind of similar to

724
00:33:31,620 --> 00:33:36,389
building out the sections we looked at

725
00:33:34,050 --> 00:33:39,510
the read elf output figured out the

726
00:33:36,390 --> 00:33:42,150
flags here read write read execute as

727
00:33:39,510 --> 00:33:45,990
you can see here I ran vectors and texts

728
00:33:42,150 --> 00:33:52,320
were in the same segment so again we're

729
00:33:45,990 --> 00:33:53,730
building out a dictionary and so now we

730
00:33:52,320 --> 00:33:56,070
could actually create the program

731
00:33:53,730 --> 00:33:58,650
headers and again we've got that special

732
00:33:56,070 --> 00:34:01,050
case I RAM 0 vectors and if we saw that

733
00:33:58,650 --> 00:34:03,540
then then we would add on or that we

734
00:34:01,050 --> 00:34:06,240
would append the eye ram 0 text section

735
00:34:03,540 --> 00:34:11,250
to create that you know that combined

736
00:34:06,240 --> 00:34:13,980
program header and finally we're able to

737
00:34:11,250 --> 00:34:15,780
actually write out that elf file so

738
00:34:13,980 --> 00:34:20,330
again this is the reverse process that

739
00:34:15,780 --> 00:34:23,909
we talked about before so our tooling

740
00:34:20,330 --> 00:34:25,319
will will take a flash dump and convert

741
00:34:23,909 --> 00:34:29,190
it back to an elf that we can then

742
00:34:25,320 --> 00:34:33,270
analyze with Ida Pro and I'll hand it

743
00:34:29,190 --> 00:34:36,240
over to Nick talk about n vs n vs is

744
00:34:33,270 --> 00:34:38,610
it's pretty fun it's a storage system

745
00:34:36,239 --> 00:34:40,830
with key value data pairs

746
00:34:38,610 --> 00:34:44,040
it can't be encrypted on are simply safe

747
00:34:40,830 --> 00:34:46,440
device was not encrypted which is a fun

748
00:34:44,040 --> 00:34:48,449
thing our toolkit could dump it as well

749
00:34:46,440 --> 00:34:50,889
it's basically organizing the pages each

750
00:34:48,449 --> 00:34:53,500
containing 4096 bytes

751
00:34:50,889 --> 00:34:55,149
and the pages have 126 entries which

752
00:34:53,500 --> 00:34:58,660
contain the key value data pairs and

753
00:34:55,149 --> 00:35:01,269
there's an API for interfacing with this

754
00:34:58,660 --> 00:35:03,879
storage system and it doesn't have any

755
00:35:01,269 --> 00:35:05,410
sort of indexing system and you have to

756
00:35:03,880 --> 00:35:06,910
do a linear search to find things so

757
00:35:05,410 --> 00:35:09,129
it's not great if you're storing a lot

758
00:35:06,910 --> 00:35:11,109
of data it says in the documentation not

759
00:35:09,130 --> 00:35:13,450
to use this if you're storing a lot of

760
00:35:11,109 --> 00:35:15,700
data use a real file system but it seems

761
00:35:13,450 --> 00:35:18,220
to be really popular to use for

762
00:35:15,700 --> 00:35:21,180
development and basically the way the

763
00:35:18,220 --> 00:35:23,828
functions mostly SS data is through

764
00:35:21,180 --> 00:35:25,750
namespaces and key value and key values

765
00:35:23,829 --> 00:35:29,190
so it looks for namespace and which were

766
00:35:25,750 --> 00:35:33,220
the key and then it pulls the data out

767
00:35:29,190 --> 00:35:34,839
so here's how a page looks over the page

768
00:35:33,220 --> 00:35:37,930
looks like you can see a dump of it

769
00:35:34,839 --> 00:35:40,450
below you can see that it dumps the

770
00:35:37,930 --> 00:35:42,430
entry state bitmap and the bitmap

771
00:35:40,450 --> 00:35:45,220
basically has two bits for each entry so

772
00:35:42,430 --> 00:35:46,690
252 bits or the 256 bits that are

773
00:35:45,220 --> 00:35:48,788
allowed so it just ignores the last four

774
00:35:46,690 --> 00:35:53,319
bits but what's interesting about it is

775
00:35:48,789 --> 00:35:56,410
that the erased definition for the

776
00:35:53,319 --> 00:35:59,109
bitmap those those those fields those

777
00:35:56,410 --> 00:36:00,819
those entries still contain data it's

778
00:35:59,109 --> 00:36:02,200
like you know when you delete a file in

779
00:36:00,819 --> 00:36:04,808
standard file system it actually doesn't

780
00:36:02,200 --> 00:36:07,720
delete the files to just changes the you

781
00:36:04,809 --> 00:36:09,130
know the metadata so from a forensics

782
00:36:07,720 --> 00:36:11,019
perspective there's a lot of interesting

783
00:36:09,130 --> 00:36:14,730
data that you can pull including Billy

784
00:36:11,019 --> 00:36:14,729
pairing data from previous connections

785
00:36:15,210 --> 00:36:20,920
and here's the storage entry so it's 24

786
00:36:18,460 --> 00:36:23,109
byte header 8 bytes of data for the

787
00:36:20,920 --> 00:36:24,609
integer data types data actually data

788
00:36:23,109 --> 00:36:26,348
field actually contains the data but for

789
00:36:24,609 --> 00:36:28,538
the blob ensuring that the field just

790
00:36:26,349 --> 00:36:30,759
contains size information and the crc32

791
00:36:28,539 --> 00:36:33,339
and the data is contained in the

792
00:36:30,759 --> 00:36:34,539
subsequent spanning entries for those so

793
00:36:33,339 --> 00:36:36,640
it doesn't contain any header data just

794
00:36:34,539 --> 00:36:39,549
raw data and for the blob index which is

795
00:36:36,640 --> 00:36:41,769
like 4 big amount of data there's

796
00:36:39,549 --> 00:36:43,750
metadata to enable larger blocks that

797
00:36:41,769 --> 00:36:46,390
span multiple pages to be reconstructed

798
00:36:43,750 --> 00:36:50,140
especially if they're not in order if

799
00:36:46,390 --> 00:36:53,950
the name space field right here

800
00:36:50,140 --> 00:36:55,839
in the header is 0 than the entries in

801
00:36:53,950 --> 00:36:58,210
main space definition with the key being

802
00:36:55,839 --> 00:36:59,380
the namespace name and value being the

803
00:36:58,210 --> 00:37:00,599
namespace index and you can see an

804
00:36:59,380 --> 00:37:04,020
example die here where there's a

805
00:37:00,599 --> 00:37:06,900
definition for the misc Canaan space and

806
00:37:04,020 --> 00:37:09,680
subsequent entry uses that so it it

807
00:37:06,900 --> 00:37:12,300
references index 1 which is misc

808
00:37:09,680 --> 00:37:15,960
and this is a dump

809
00:37:12,300 --> 00:37:19,350
of the envious of you can see here this

810
00:37:15,960 --> 00:37:21,150
is of our Wi-Fi of our simply safe

811
00:37:19,350 --> 00:37:22,770
device and this is actually we dumped it

812
00:37:21,150 --> 00:37:25,650
you can see the Wi-Fi card entrance in

813
00:37:22,770 --> 00:37:27,870
the NV s so if someone steals your

814
00:37:25,650 --> 00:37:29,790
simply safe you probably should change

815
00:37:27,870 --> 00:37:34,200
your Wi-Fi password assuming your router

816
00:37:29,790 --> 00:37:36,060
didn't also get stolen and here is

817
00:37:34,200 --> 00:37:38,490
here's one this is cool because it's

818
00:37:36,060 --> 00:37:40,200
been erased but you can see the pairing

819
00:37:38,490 --> 00:37:43,649
data from a previous Bluetooth

820
00:37:40,200 --> 00:37:49,980
connection so that's really neat and

821
00:37:43,650 --> 00:37:51,480
then demo cool so now we can we don't

822
00:37:49,980 --> 00:37:55,770
have a video but we do have some some

823
00:37:51,480 --> 00:37:57,720
screenshots for you alright so like the

824
00:37:55,770 --> 00:37:58,920
first thing we do is you know we we

825
00:37:57,720 --> 00:38:01,709
pulled the chip out of the simply safe

826
00:37:58,920 --> 00:38:03,210
and we have to read it right so after we

827
00:38:01,710 --> 00:38:05,250
soldered it back on it the development

828
00:38:03,210 --> 00:38:07,890
board we ran that you know the tool that

829
00:38:05,250 --> 00:38:13,370
that comes with the kit and it dumps the

830
00:38:07,890 --> 00:38:16,109
flash on to disk and so here's our tool

831
00:38:13,370 --> 00:38:18,420
so we can we can dump any partition or

832
00:38:16,110 --> 00:38:21,660
dump all the partitions on the flash so

833
00:38:18,420 --> 00:38:22,920
as you can see you know we've got n2 nvs

834
00:38:21,660 --> 00:38:24,960
like Nick just talked about

835
00:38:22,920 --> 00:38:27,780
we've got OTA data which tells you which

836
00:38:24,960 --> 00:38:33,720
app is to be booted got some apps we've

837
00:38:27,780 --> 00:38:36,270
got this by f FS and so when we wanted

838
00:38:33,720 --> 00:38:37,740
to if we want to convert one of those

839
00:38:36,270 --> 00:38:41,130
partitions we need to choose an app

840
00:38:37,740 --> 00:38:44,160
partition and so we actually chose you

841
00:38:41,130 --> 00:38:47,520
know we chose one of these right we

842
00:38:44,160 --> 00:38:51,410
chose a partition partition app 0 so

843
00:38:47,520 --> 00:38:54,930
then it spits out an app 0 elf file and

844
00:38:51,410 --> 00:38:57,180
so when we want to load it up in Ida the

845
00:38:54,930 --> 00:38:59,430
first thing we had to do was use a

846
00:38:57,180 --> 00:39:01,319
third-party processor module for extends

847
00:38:59,430 --> 00:39:04,799
ax because I did as in support extends

848
00:39:01,320 --> 00:39:07,020
it right out of the box as you can see

849
00:39:04,800 --> 00:39:08,910
we had to choose processor type tentacle

850
00:39:07,020 --> 00:39:11,540
I can't even pronounce that 10 silica

851
00:39:08,910 --> 00:39:11,540
extends ax

852
00:39:11,610 --> 00:39:15,400
and once we loaded it up it would it

853
00:39:14,620 --> 00:39:17,529
worked really well

854
00:39:15,400 --> 00:39:19,600
which was surprising we were able to get

855
00:39:17,530 --> 00:39:21,310
this this nice graph I don't know if you

856
00:39:19,600 --> 00:39:23,529
can see over here but none of these

857
00:39:21,310 --> 00:39:25,900
function names are named it's just like

858
00:39:23,530 --> 00:39:26,980
sub and then the address not you know

859
00:39:25,900 --> 00:39:31,750
that's because we didn't have the the

860
00:39:26,980 --> 00:39:33,610
simple table to work with and so the

861
00:39:31,750 --> 00:39:35,560
string the strings looked really good

862
00:39:33,610 --> 00:39:37,780
too I don't know if you can read that

863
00:39:35,560 --> 00:39:39,820
but it says ready for credentials and

864
00:39:37,780 --> 00:39:42,340
I'll show you where that comes from

865
00:39:39,820 --> 00:39:44,380
but if we were to back off

866
00:39:42,340 --> 00:39:47,050
cross-reference it and find where it's

867
00:39:44,380 --> 00:39:50,370
being referenced in the code we ran into

868
00:39:47,050 --> 00:39:53,860
this kind of interesting function and

869
00:39:50,370 --> 00:39:54,730
what it ended up doing was it would

870
00:39:53,860 --> 00:39:56,890
process

871
00:39:54,730 --> 00:39:58,810
jaison's over bluetooth so we could

872
00:39:56,890 --> 00:40:00,670
connect to the simply safe over

873
00:39:58,810 --> 00:40:04,299
bluetooth and then we could send it a

874
00:40:00,670 --> 00:40:06,550
JSON with an SSID password and a token

875
00:40:04,300 --> 00:40:08,980
and we could tell the simply safe to

876
00:40:06,550 --> 00:40:09,520
connect to a different different Wi-Fi

877
00:40:08,980 --> 00:40:11,890
network

878
00:40:09,520 --> 00:40:15,850
altogether we ended up reporting this

879
00:40:11,890 --> 00:40:17,740
this was CBE 2019 398 not the biggest

880
00:40:15,850 --> 00:40:19,480
security issue but you know we still

881
00:40:17,740 --> 00:40:21,939
found some some hidden functionality

882
00:40:19,480 --> 00:40:23,950
with our tools which was kind of fun and

883
00:40:21,940 --> 00:40:27,040
here's a UART don't just showing that

884
00:40:23,950 --> 00:40:29,529
that process so we have all of this this

885
00:40:27,040 --> 00:40:32,800
Bluetooth activity going on and then it

886
00:40:29,530 --> 00:40:34,930
actually read my SSID Chris test my

887
00:40:32,800 --> 00:40:40,030
password and it connected to my network

888
00:40:34,930 --> 00:40:41,740
so it was pretty fun and that's our talk

889
00:40:40,030 --> 00:40:46,540
if you want to check out our project

890
00:40:41,740 --> 00:40:48,399
it's on github you can contribute report

891
00:40:46,540 --> 00:40:50,710
any issues you might find and then also

892
00:40:48,400 --> 00:40:53,590
tenable is always hiring researchers so

893
00:40:50,710 --> 00:41:02,610
check out our careers page and we'll

894
00:40:53,590 --> 00:41:05,290
open it up for questions yes it was free

895
00:41:02,610 --> 00:41:08,050
huh

896
00:41:05,290 --> 00:41:11,800
yep yeah the he asked about the extends

897
00:41:08,050 --> 00:41:14,280
Ida plugin and that's free on github we

898
00:41:11,800 --> 00:41:19,000
didn't write it with someone else did

899
00:41:14,280 --> 00:41:20,940
yes sir yeah we'll put them on github

900
00:41:19,000 --> 00:41:43,000
yep

901
00:41:20,940 --> 00:41:45,690
anyone else have questions yes I'm gonna

902
00:41:43,000 --> 00:41:48,130
hand that over to my manager

903
00:41:45,690 --> 00:41:50,050
so each researcher on our team has a

904
00:41:48,130 --> 00:41:53,050
different special you know specialty and

905
00:41:50,050 --> 00:41:55,060
different motivations so I basically let

906
00:41:53,050 --> 00:41:56,800
them pretty much choose their targets

907
00:41:55,060 --> 00:41:59,020
although occasionally there are focuses

908
00:41:56,800 --> 00:42:00,640
from request to focus on certain things

909
00:41:59,020 --> 00:42:01,390
so we'll sweep well shift focus from

910
00:42:00,640 --> 00:42:03,220
time to time

911
00:42:01,390 --> 00:42:05,379
but most for the most part the

912
00:42:03,220 --> 00:42:07,629
researchers pick whatever their whatever

913
00:42:05,380 --> 00:42:09,250
they want and they usually you know do

914
00:42:07,630 --> 00:42:10,720
some market research and some Showdown

915
00:42:09,250 --> 00:42:12,880
searches to make sure that it's you know

916
00:42:10,720 --> 00:42:14,200
being utilized before they invest a

917
00:42:12,880 --> 00:42:15,970
whole lot of time on it to make sure we

918
00:42:14,200 --> 00:42:18,790
get some return on investment of our

919
00:42:15,970 --> 00:42:20,680
research it's no it's kind of silly to

920
00:42:18,790 --> 00:42:28,420
research things that aren't used by

921
00:42:20,680 --> 00:42:28,910
anybody any other questions cool thank

922
00:42:28,420 --> 00:42:30,840
you guys

923
00:42:28,910 --> 00:42:33,959
[Applause]

924
00:42:30,840 --> 00:42:33,959
[Music]

