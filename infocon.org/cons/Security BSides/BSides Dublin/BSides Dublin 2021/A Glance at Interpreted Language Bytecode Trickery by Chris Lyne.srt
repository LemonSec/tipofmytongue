1
00:00:06,000 --> 00:00:07,440
thanks everyone for joining my talk

2
00:00:07,440 --> 00:00:08,240
today

3
00:00:08,240 --> 00:00:10,320
um we'll be taking a glance at

4
00:00:10,320 --> 00:00:12,960
interpreted language by code trickery

5
00:00:12,960 --> 00:00:15,120
um as karen said my name is chris line

6
00:00:15,120 --> 00:00:17,920
i'm on tenable zero day research team

7
00:00:17,920 --> 00:00:20,320
the team's goal is to discover unknown

8
00:00:20,320 --> 00:00:21,600
vulnerabilities

9
00:00:21,600 --> 00:00:24,640
in third party products we'll also

10
00:00:24,640 --> 00:00:26,960
coordinate disclosure with a product

11
00:00:26,960 --> 00:00:28,240
vendor

12
00:00:28,240 --> 00:00:30,880
and also we do quite a bit of sharing

13
00:00:30,880 --> 00:00:34,079
our research with the community

14
00:00:34,239 --> 00:00:37,600
so some quick background on the talk

15
00:00:37,600 --> 00:00:39,840
it started off with two research

16
00:00:39,840 --> 00:00:40,960
projects

17
00:00:40,960 --> 00:00:43,440
one of which i looked at druva in sync

18
00:00:43,440 --> 00:00:44,000
which is

19
00:00:44,000 --> 00:00:48,000
a an endpoint backup solution

20
00:00:48,000 --> 00:00:49,920
so that one's written in python and

21
00:00:49,920 --> 00:00:51,520
there was another project

22
00:00:51,520 --> 00:00:54,480
nagios xi which is an enterprise server

23
00:00:54,480 --> 00:00:56,480
and network monitoring software

24
00:00:56,480 --> 00:00:59,760
that one's written in php so the main

25
00:00:59,760 --> 00:01:01,359
goal when i first started these projects

26
00:01:01,359 --> 00:01:02,559
was to get a hold of their

27
00:01:02,559 --> 00:01:04,959
their source code and read it figure out

28
00:01:04,959 --> 00:01:06,080
how the product works

29
00:01:06,080 --> 00:01:08,960
see if i can find vulnerabilities but in

30
00:01:08,960 --> 00:01:11,680
both cases i was presented with

31
00:01:11,680 --> 00:01:14,640
bytecode protection so i wasn't able to

32
00:01:14,640 --> 00:01:15,280
just

33
00:01:15,280 --> 00:01:18,880
read the source code like i had hoped

34
00:01:19,200 --> 00:01:21,119
so some topics for today that we'll go

35
00:01:21,119 --> 00:01:22,960
over we'll talk a little bit about

36
00:01:22,960 --> 00:01:25,920
interpreted languages we'll talk about

37
00:01:25,920 --> 00:01:27,920
what bytecode is

38
00:01:27,920 --> 00:01:29,360
we'll talk about the protections i

39
00:01:29,360 --> 00:01:31,280
encountered and also

40
00:01:31,280 --> 00:01:35,360
we'll go through how i bypass them

41
00:01:35,680 --> 00:01:37,680
so real quick let's let's talk about

42
00:01:37,680 --> 00:01:40,720
compiled versus interpreted languages

43
00:01:40,720 --> 00:01:43,360
so on the compiled side of things you're

44
00:01:43,360 --> 00:01:44,799
probably familiar with c or c

45
00:01:44,799 --> 00:01:46,960
plus plus or go those are all compiled

46
00:01:46,960 --> 00:01:48,240
languages

47
00:01:48,240 --> 00:01:50,880
but basically you have your source code

48
00:01:50,880 --> 00:01:52,640
program

49
00:01:52,640 --> 00:01:55,600
the programmer has to explicitly compile

50
00:01:55,600 --> 00:01:56,880
that source code into

51
00:01:56,880 --> 00:01:58,960
an executable format which is machine

52
00:01:58,960 --> 00:02:00,399
code

53
00:02:00,399 --> 00:02:02,000
that targets the operating system and

54
00:02:02,000 --> 00:02:03,680
the processor

55
00:02:03,680 --> 00:02:05,759
so for this talk we'll be focusing on

56
00:02:05,759 --> 00:02:07,040
interpretive languages

57
00:02:07,040 --> 00:02:10,560
like such as python or php or ruby

58
00:02:10,560 --> 00:02:12,080
it's different than compiled language

59
00:02:12,080 --> 00:02:14,959
because the programmer doesn't have to

60
00:02:14,959 --> 00:02:18,000
compile it explicitly

61
00:02:18,000 --> 00:02:20,080
there is an interpreter that does that

62
00:02:20,080 --> 00:02:21,120
job

63
00:02:21,120 --> 00:02:24,160
and the interpreter will convert the

64
00:02:24,160 --> 00:02:26,000
source code into bytecode

65
00:02:26,000 --> 00:02:28,160
which is similar to machine code except

66
00:02:28,160 --> 00:02:29,840
that it targets a virtual machine

67
00:02:29,840 --> 00:02:30,480
environment

68
00:02:30,480 --> 00:02:32,720
so the python virtual machine or php

69
00:02:32,720 --> 00:02:36,160
virtual machine

70
00:02:36,160 --> 00:02:37,920
so first we'll take a look at python

71
00:02:37,920 --> 00:02:39,360
opcode remapping

72
00:02:39,360 --> 00:02:40,879
and that was in the druva instinct

73
00:02:40,879 --> 00:02:42,959
product and then we'll take a look at

74
00:02:42,959 --> 00:02:43,360
the

75
00:02:43,360 --> 00:02:46,400
protection code objects and fixing the

76
00:02:46,400 --> 00:02:48,239
op codes

77
00:02:48,239 --> 00:02:51,360
so in druva

78
00:02:51,360 --> 00:02:53,599
one of the first things i did was

79
00:02:53,599 --> 00:02:54,800
analyze the

80
00:02:54,800 --> 00:02:57,440
the program behavior and at the top here

81
00:02:57,440 --> 00:02:58,959
you can see procmon output

82
00:02:58,959 --> 00:03:00,959
so that shows some events that took

83
00:03:00,959 --> 00:03:03,360
place when the nsync

84
00:03:03,360 --> 00:03:06,879
program launched and as you could see

85
00:03:06,879 --> 00:03:10,640
a python 2.7 dll was opened

86
00:03:10,640 --> 00:03:14,000
and also a library.zip archive was open

87
00:03:14,000 --> 00:03:16,480
which is down here so this type of

88
00:03:16,480 --> 00:03:18,319
behavior is indicative of

89
00:03:18,319 --> 00:03:20,959
a python application that's built with

90
00:03:20,959 --> 00:03:22,560
pi to exe

91
00:03:22,560 --> 00:03:25,519
basically what it does is it allows the

92
00:03:25,519 --> 00:03:27,760
developer to write python code

93
00:03:27,760 --> 00:03:30,640
but then they can ship their application

94
00:03:30,640 --> 00:03:33,120
as a windows executable

95
00:03:33,120 --> 00:03:35,920
so essentially it ships it with python

96
00:03:35,920 --> 00:03:37,920
and all of the python libraries

97
00:03:37,920 --> 00:03:39,760
that are required which is what you see

98
00:03:39,760 --> 00:03:42,799
in here if you notice all of the

99
00:03:42,799 --> 00:03:44,720
the files in here for the most part end

100
00:03:44,720 --> 00:03:47,519
with dot pyc

101
00:03:47,519 --> 00:03:49,599
so again those are those are the modules

102
00:03:49,599 --> 00:03:51,760
the python modules

103
00:03:51,760 --> 00:03:55,200
so you might be asking what's a pyc file

104
00:03:55,200 --> 00:03:56,879
and the answer is that it's a byte

105
00:03:56,879 --> 00:03:59,599
compiled python file

106
00:03:59,599 --> 00:04:02,799
so if you were to load up a pyc file in

107
00:04:02,799 --> 00:04:03,760
your text editor

108
00:04:03,760 --> 00:04:05,599
you're not going to be able to read

109
00:04:05,599 --> 00:04:07,439
python source code like you would with a

110
00:04:07,439 --> 00:04:09,519
dot pi

111
00:04:09,519 --> 00:04:12,640
the idea of compiling a python file like

112
00:04:12,640 --> 00:04:15,200
that is to help speed up the load time

113
00:04:15,200 --> 00:04:17,839
and this especially is true with modules

114
00:04:17,839 --> 00:04:18,959
because as you saw there are a lot of

115
00:04:18,959 --> 00:04:19,839
modules

116
00:04:19,839 --> 00:04:21,279
so if they're already compiled when

117
00:04:21,279 --> 00:04:23,600
they're imported it really speeds things

118
00:04:23,600 --> 00:04:25,759
up

119
00:04:26,400 --> 00:04:28,479
however if you wanted to read the source

120
00:04:28,479 --> 00:04:29,600
code of

121
00:04:29,600 --> 00:04:32,080
those compiled files you would need to

122
00:04:32,080 --> 00:04:33,919
use a decompiler

123
00:04:33,919 --> 00:04:36,560
such as uncompile six and that's what

124
00:04:36,560 --> 00:04:37,520
i've showed you here

125
00:04:37,520 --> 00:04:41,360
in this screenshot i used uncompile 6

126
00:04:41,360 --> 00:04:45,120
to decompile the python struct

127
00:04:45,120 --> 00:04:48,720
module and as you can see it it works

128
00:04:48,720 --> 00:04:49,680
pretty well

129
00:04:49,680 --> 00:04:52,240
basically that module is just a few

130
00:04:52,240 --> 00:04:54,720
imports

131
00:04:55,280 --> 00:04:58,240
now the protection i encountered i

132
00:04:58,240 --> 00:05:00,880
encountered it when i tried to decompile

133
00:05:00,880 --> 00:05:03,199
the destruct module that was shipped

134
00:05:03,199 --> 00:05:05,360
with druva insect

135
00:05:05,360 --> 00:05:08,160
now when i tried to decompile it i got

136
00:05:08,160 --> 00:05:09,600
this interesting error

137
00:05:09,600 --> 00:05:13,840
unknown magic number 62216.

138
00:05:13,840 --> 00:05:16,800
so clearly there was something in the

139
00:05:16,800 --> 00:05:18,320
pyc file

140
00:05:18,320 --> 00:05:21,039
that uncompiled 6 didn't like so my next

141
00:05:21,039 --> 00:05:21,360
step

142
00:05:21,360 --> 00:05:23,840
was to figure out what is what's the

143
00:05:23,840 --> 00:05:25,919
structure of this pyc file why is it

144
00:05:25,919 --> 00:05:29,120
what's going wrong here so when i was

145
00:05:29,120 --> 00:05:30,960
trying to learn about the pyc format i

146
00:05:30,960 --> 00:05:32,400
started off with the hello world

147
00:05:32,400 --> 00:05:33,759
application

148
00:05:33,759 --> 00:05:36,400
it's just one print statement i use the

149
00:05:36,400 --> 00:05:38,080
pi compile module

150
00:05:38,080 --> 00:05:42,479
to create a pyc from that source code

151
00:05:42,479 --> 00:05:44,960
and at the bottom here you see a hexdump

152
00:05:44,960 --> 00:05:45,600
of that

153
00:05:45,600 --> 00:05:49,280
pyc file so the first four bytes of a

154
00:05:49,280 --> 00:05:51,280
pyc file are what's called the magic

155
00:05:51,280 --> 00:05:53,120
string

156
00:05:53,120 --> 00:05:55,520
the the the next four bytes are the

157
00:05:55,520 --> 00:05:58,160
timestamp of when the file was created

158
00:05:58,160 --> 00:06:01,039
and then following all of this is a code

159
00:06:01,039 --> 00:06:01,919
object

160
00:06:01,919 --> 00:06:03,840
we'll talk more about the magic string

161
00:06:03,840 --> 00:06:07,840
and code object as we go

162
00:06:07,840 --> 00:06:09,759
so that magic string i just mentioned to

163
00:06:09,759 --> 00:06:11,360
you contains a magic

164
00:06:11,360 --> 00:06:14,720
number and if you remember the

165
00:06:14,720 --> 00:06:16,800
the the error before said unknown magic

166
00:06:16,800 --> 00:06:19,199
number 62216.

167
00:06:19,199 --> 00:06:22,080
if you look in here this is a list of

168
00:06:22,080 --> 00:06:24,319
documented magic numbers

169
00:06:24,319 --> 00:06:26,720
so like six two two one one corresponds

170
00:06:26,720 --> 00:06:28,880
with two point seven a zero

171
00:06:28,880 --> 00:06:30,720
and actually all these many of these

172
00:06:30,720 --> 00:06:32,319
correspond with that python

173
00:06:32,319 --> 00:06:37,520
version so with each magic number

174
00:06:37,520 --> 00:06:39,600
you can see that something's introduced

175
00:06:39,600 --> 00:06:42,000
right so we introduced setup with

176
00:06:42,000 --> 00:06:44,639
build set we introduced map ad we

177
00:06:44,639 --> 00:06:45,199
introduced

178
00:06:45,199 --> 00:06:49,280
set ad these are all python instructions

179
00:06:49,280 --> 00:06:52,479
from bytecode instructions

180
00:06:53,840 --> 00:06:56,400
now all of these bytecode instructions

181
00:06:56,400 --> 00:06:58,080
have a corresponding

182
00:06:58,080 --> 00:07:00,960
op code so for instance the highlighted

183
00:07:00,960 --> 00:07:02,400
line here

184
00:07:02,400 --> 00:07:05,199
and this is defined in the upcode module

185
00:07:05,199 --> 00:07:06,880
the highlighted line here shows that the

186
00:07:06,880 --> 00:07:07,280
call

187
00:07:07,280 --> 00:07:10,560
function instruction

188
00:07:10,560 --> 00:07:14,240
maps up to the 131 opcode

189
00:07:14,240 --> 00:07:16,960
and so forth make function maps up to

190
00:07:16,960 --> 00:07:18,240
132

191
00:07:18,240 --> 00:07:21,199
build slice maps up to 133. now there

192
00:07:21,199 --> 00:07:21,599
are

193
00:07:21,599 --> 00:07:24,880
quite a few of them now

194
00:07:24,880 --> 00:07:27,840
if you were to use the opcode module so

195
00:07:27,840 --> 00:07:28,479
import

196
00:07:28,479 --> 00:07:33,360
opcode and dump out the op code map

197
00:07:33,360 --> 00:07:35,440
you can verify that number we just saw

198
00:07:35,440 --> 00:07:36,639
call function

199
00:07:36,639 --> 00:07:40,240
maps up to op code 131

200
00:07:40,240 --> 00:07:42,080
and so take note of that one also take

201
00:07:42,080 --> 00:07:43,360
note of dupe top

202
00:07:43,360 --> 00:07:47,280
maps up to 4 28.

203
00:07:47,280 --> 00:07:51,360
so if we were to do the same thing

204
00:07:51,360 --> 00:07:53,520
with the druva installation we import

205
00:07:53,520 --> 00:07:54,879
the opcode

206
00:07:54,879 --> 00:07:58,080
module that was given with the druva

207
00:07:58,080 --> 00:07:59,039
installation

208
00:07:59,039 --> 00:08:01,280
check out the op map notice that call

209
00:08:01,280 --> 00:08:02,319
function has a

210
00:08:02,319 --> 00:08:05,199
totally different up number there and so

211
00:08:05,199 --> 00:08:06,240
does dupe top

212
00:08:06,240 --> 00:08:10,160
i'll go back so you can see that the 131

213
00:08:10,160 --> 00:08:15,440
and four 1 11 64.

214
00:08:18,479 --> 00:08:20,400
so now we'll look at code objects a

215
00:08:20,400 --> 00:08:21,840
little bit more in depth as

216
00:08:21,840 --> 00:08:24,319
that's where the instructions and op

217
00:08:24,319 --> 00:08:27,840
codes are contained

218
00:08:30,000 --> 00:08:33,200
so that code object that's in the pyc

219
00:08:33,200 --> 00:08:34,640
file

220
00:08:34,640 --> 00:08:38,399
if we were to read from a pyc file

221
00:08:38,399 --> 00:08:40,399
load up the code object that starts at

222
00:08:40,399 --> 00:08:41,599
index eight

223
00:08:41,599 --> 00:08:43,839
use the marshall module to load those

224
00:08:43,839 --> 00:08:44,959
code bytes

225
00:08:44,959 --> 00:08:47,440
you can see that there is a code object

226
00:08:47,440 --> 00:08:48,240
in there

227
00:08:48,240 --> 00:08:50,240
and if we were to execute it we would

228
00:08:50,240 --> 00:08:51,920
get that expected output

229
00:08:51,920 --> 00:08:55,040
hello world right so

230
00:08:55,040 --> 00:08:57,519
in that code object there is a field

231
00:08:57,519 --> 00:08:58,640
called

232
00:08:58,640 --> 00:09:02,880
co code which contains the raw byte code

233
00:09:02,880 --> 00:09:04,959
so this string you see right here this

234
00:09:04,959 --> 00:09:06,080
is raw byte code

235
00:09:06,080 --> 00:09:09,120
it contains at the beginning here this d

236
00:09:09,120 --> 00:09:12,320
um is a it's an op code

237
00:09:12,320 --> 00:09:15,120
and then each op code has operands

238
00:09:15,120 --> 00:09:17,200
following it so the arguments to the

239
00:09:17,200 --> 00:09:19,760
instruction

240
00:09:20,839 --> 00:09:24,000
now since we're trying to decompile

241
00:09:24,000 --> 00:09:27,200
a python a compiled python file um i

242
00:09:27,200 --> 00:09:28,160
should want to tell you about

243
00:09:28,160 --> 00:09:29,519
disassembly real quick

244
00:09:29,519 --> 00:09:31,760
because that's an intermediate step in

245
00:09:31,760 --> 00:09:33,920
between decompilation

246
00:09:33,920 --> 00:09:37,200
so those op codes um can be disassembled

247
00:09:37,200 --> 00:09:38,959
you take a code object use the disk

248
00:09:38,959 --> 00:09:41,360
module and you can disassemble the

249
00:09:41,360 --> 00:09:44,320
the bytecode so as you can see for that

250
00:09:44,320 --> 00:09:46,640
hello world it ends up being

251
00:09:46,640 --> 00:09:48,880
quite a few instructions compared to the

252
00:09:48,880 --> 00:09:50,399
the python source file

253
00:09:50,399 --> 00:09:52,640
you have a load const which loads the

254
00:09:52,640 --> 00:09:54,320
hello world constant

255
00:09:54,320 --> 00:09:57,760
which is defined in the constants tuple

256
00:09:57,760 --> 00:10:00,320
that constant is printed a new line is

257
00:10:00,320 --> 00:10:01,440
printed

258
00:10:01,440 --> 00:10:05,839
and then the script returns none

259
00:10:08,079 --> 00:10:10,240
now in the real world obviously we're

260
00:10:10,240 --> 00:10:11,440
not going to see hello world

261
00:10:11,440 --> 00:10:12,399
applications

262
00:10:12,399 --> 00:10:15,440
we'll see more object oriented like

263
00:10:15,440 --> 00:10:16,240
applications

264
00:10:16,240 --> 00:10:19,200
they're much more complex and still this

265
00:10:19,200 --> 00:10:19,600
is a

266
00:10:19,600 --> 00:10:22,160
fairly simple example but if we take for

267
00:10:22,160 --> 00:10:24,079
instance the hello class

268
00:10:24,079 --> 00:10:26,800
it has a a blank constructor doesn't do

269
00:10:26,800 --> 00:10:27,760
anything

270
00:10:27,760 --> 00:10:29,279
and then there's a method called say

271
00:10:29,279 --> 00:10:32,480
hello that just says oh hey

272
00:10:32,480 --> 00:10:34,640
if we were to disassemble that code

273
00:10:34,640 --> 00:10:35,839
object

274
00:10:35,839 --> 00:10:37,839
i want you to notice here at

275
00:10:37,839 --> 00:10:38,880
construction

276
00:10:38,880 --> 00:10:42,720
at offset 9 we're loading a constant

277
00:10:42,720 --> 00:10:46,000
which is a code object

278
00:10:46,000 --> 00:10:47,440
so if we were to look into that

279
00:10:47,440 --> 00:10:49,440
constants tuple

280
00:10:49,440 --> 00:10:52,720
at index 1 you would see that there is

281
00:10:52,720 --> 00:10:54,480
indeed a code object

282
00:10:54,480 --> 00:10:56,480
now we can disassemble that code object

283
00:10:56,480 --> 00:10:57,519
too

284
00:10:57,519 --> 00:11:00,640
and in fact it contains

285
00:11:00,640 --> 00:11:03,920
um some instructions to load even more

286
00:11:03,920 --> 00:11:05,519
code objects

287
00:11:05,519 --> 00:11:08,800
so as you can see a basic

288
00:11:08,800 --> 00:11:12,000
class can start to get pretty

289
00:11:12,000 --> 00:11:14,160
pretty complex you have nested code

290
00:11:14,160 --> 00:11:16,640
objects

291
00:11:17,440 --> 00:11:19,360
now now we'll start getting into how i

292
00:11:19,360 --> 00:11:21,360
went about fixing these code objects in

293
00:11:21,360 --> 00:11:22,000
order to

294
00:11:22,000 --> 00:11:26,399
decompile the stuff so

295
00:11:26,399 --> 00:11:29,920
my my strategy was to

296
00:11:29,920 --> 00:11:32,480
you know you read a pyc file and then

297
00:11:32,480 --> 00:11:34,160
take a look at all the op codes

298
00:11:34,160 --> 00:11:37,839
in the bytecode if so we know that

299
00:11:37,839 --> 00:11:39,200
we have the mapping for the druva

300
00:11:39,200 --> 00:11:41,200
opcodes and we have the mapping for a

301
00:11:41,200 --> 00:11:42,240
normal

302
00:11:42,240 --> 00:11:45,680
python 2.7 if we see

303
00:11:45,680 --> 00:11:48,880
a druva opcode of 111 we know that it's

304
00:11:48,880 --> 00:11:50,959
a call function instruction

305
00:11:50,959 --> 00:11:54,959
now we can replace that opcode with 131

306
00:11:54,959 --> 00:11:57,200
and so on if we see a 64 we know it's a

307
00:11:57,200 --> 00:11:58,240
dupe top

308
00:11:58,240 --> 00:12:01,839
then we replace it with a 4.

309
00:12:03,760 --> 00:12:07,120
so ultimately because of the

310
00:12:07,120 --> 00:12:10,320
complex nature of code objects

311
00:12:10,320 --> 00:12:12,720
and how they could be nested the

312
00:12:12,720 --> 00:12:15,440
algorithm had to be

313
00:12:15,440 --> 00:12:17,839
recursive so just bear with me we're

314
00:12:17,839 --> 00:12:19,040
going to go through this diagram real

315
00:12:19,040 --> 00:12:21,200
quick

316
00:12:21,200 --> 00:12:23,440
so obviously we're reading a puic file

317
00:12:23,440 --> 00:12:24,480
has a magic string

318
00:12:24,480 --> 00:12:26,079
timestamp and that code object we're

319
00:12:26,079 --> 00:12:29,519
interested in so we read the code object

320
00:12:29,519 --> 00:12:31,680
and then there is a main function that i

321
00:12:31,680 --> 00:12:32,639
implemented

322
00:12:32,639 --> 00:12:36,160
for fixing code objects so when the code

323
00:12:36,160 --> 00:12:37,519
object comes in

324
00:12:37,519 --> 00:12:41,440
that raw byte code in the co code

325
00:12:41,440 --> 00:12:47,440
field is remapped so like we saw before

326
00:12:47,440 --> 00:12:49,040
and then we also saw that the constants

327
00:12:49,040 --> 00:12:52,560
tuple can contain nested by code

328
00:12:52,560 --> 00:12:55,600
so if there are if there are more code

329
00:12:55,600 --> 00:12:56,560
objects

330
00:12:56,560 --> 00:12:59,200
in the constants tuple we'll go ahead

331
00:12:59,200 --> 00:13:00,800
and loop through those

332
00:13:00,800 --> 00:13:02,880
pull out a code object and then call

333
00:13:02,880 --> 00:13:04,720
this routine again

334
00:13:04,720 --> 00:13:07,440
so that's where the recursion comes in

335
00:13:07,440 --> 00:13:08,079
and the

336
00:13:08,079 --> 00:13:09,920
the whole idea is to produce a new code

337
00:13:09,920 --> 00:13:11,120
object

338
00:13:11,120 --> 00:13:14,079
with remapped op codes and co code and

339
00:13:14,079 --> 00:13:15,600
then remapped op codes

340
00:13:15,600 --> 00:13:18,000
inside the nested code objects in this

341
00:13:18,000 --> 00:13:19,680
constants tuple

342
00:13:19,680 --> 00:13:21,839
and ultimately in order to make the

343
00:13:21,839 --> 00:13:23,440
compilation work with a

344
00:13:23,440 --> 00:13:26,800
standardized tool i set the

345
00:13:26,800 --> 00:13:29,760
the magic number there to 62211 which

346
00:13:29,760 --> 00:13:31,200
was python 2.7

347
00:13:31,200 --> 00:13:35,360
a0 i also set a

348
00:13:35,360 --> 00:13:38,639
a time stamp of today right uh and then

349
00:13:38,639 --> 00:13:39,839
that new code object

350
00:13:39,839 --> 00:13:42,959
is is stuffed in there

351
00:13:44,079 --> 00:13:46,720
so after i did that on after i ran that

352
00:13:46,720 --> 00:13:48,639
routine on all of the

353
00:13:48,639 --> 00:13:51,199
um the pycs that were delivered with

354
00:13:51,199 --> 00:13:53,360
druva insync i was able to decompile

355
00:13:53,360 --> 00:13:54,639
them

356
00:13:54,639 --> 00:13:56,079
unfortunately i can't show you all their

357
00:13:56,079 --> 00:13:57,920
source code because it's you know it's

358
00:13:57,920 --> 00:13:58,959
their

359
00:13:58,959 --> 00:14:02,160
intellectual property um

360
00:14:02,160 --> 00:14:03,680
yeah so that that's python opcode

361
00:14:03,680 --> 00:14:05,279
remapping

362
00:14:05,279 --> 00:14:08,160
um next when i was looking at nagios xi

363
00:14:08,160 --> 00:14:09,440
i ran into

364
00:14:09,440 --> 00:14:12,920
php source guardian and this is a

365
00:14:12,920 --> 00:14:17,839
proprietary protection mechanism

366
00:14:18,399 --> 00:14:20,880
so when i was looking through their code

367
00:14:20,880 --> 00:14:21,839
base they have

368
00:14:21,839 --> 00:14:25,120
had all sorts of php files some of which

369
00:14:25,120 --> 00:14:26,560
i could read the source code and then

370
00:14:26,560 --> 00:14:28,399
there were others that looked

371
00:14:28,399 --> 00:14:31,839
like this and i don't know about you but

372
00:14:31,839 --> 00:14:34,160
when i look at this i can't i can't read

373
00:14:34,160 --> 00:14:35,920
any of this there's

374
00:14:35,920 --> 00:14:37,680
there's no uh there's no programming

375
00:14:37,680 --> 00:14:39,440
logic in here

376
00:14:39,440 --> 00:14:41,680
basically what this is this is an

377
00:14:41,680 --> 00:14:43,360
encoded file

378
00:14:43,360 --> 00:14:45,440
so if you were to run the source code

379
00:14:45,440 --> 00:14:47,040
guardian encoder

380
00:14:47,040 --> 00:14:49,360
on a php source file you would end up

381
00:14:49,360 --> 00:14:51,199
with something like this

382
00:14:51,199 --> 00:14:53,440
notice at the top here that it checks to

383
00:14:53,440 --> 00:14:54,639
see if the sg load

384
00:14:54,639 --> 00:14:58,000
function exists and if so make our way

385
00:14:58,000 --> 00:15:02,480
down then the sg load function is called

386
00:15:02,480 --> 00:15:05,680
and what this function what this

387
00:15:05,680 --> 00:15:08,480
this code does is it allows source

388
00:15:08,480 --> 00:15:10,839
guardian protected files to decode

389
00:15:10,839 --> 00:15:14,560
themselves and execute themselves

390
00:15:14,560 --> 00:15:17,600
now if we zoom in on that sg load call

391
00:15:17,600 --> 00:15:21,519
there's a big string of stuff

392
00:15:21,519 --> 00:15:24,880
and this is the the programmer's logic

393
00:15:24,880 --> 00:15:27,600
that we're interested in

394
00:15:27,600 --> 00:15:29,279
so i'll take a quote off of the source

395
00:15:29,279 --> 00:15:30,880
guardian website they describe their

396
00:15:30,880 --> 00:15:31,600
product

397
00:15:31,600 --> 00:15:34,160
they say our php encoder protects your

398
00:15:34,160 --> 00:15:35,680
php code

399
00:15:35,680 --> 00:15:38,800
by compiling the php source code into a

400
00:15:38,800 --> 00:15:40,880
binary bytecode format

401
00:15:40,880 --> 00:15:42,720
which is then supplemented with an

402
00:15:42,720 --> 00:15:44,720
encryption layer

403
00:15:44,720 --> 00:15:47,279
so they compile the php code and then

404
00:15:47,279 --> 00:15:48,720
encrypt it

405
00:15:48,720 --> 00:15:51,759
now this sg load function

406
00:15:51,759 --> 00:15:55,120
has to first decrypt then execute the

407
00:15:55,120 --> 00:15:56,639
bytecode

408
00:15:56,639 --> 00:15:59,519
so this argument here this is the

409
00:15:59,519 --> 00:16:00,560
encrypted

410
00:16:00,560 --> 00:16:04,880
bytecode so that's what we're after

411
00:16:05,680 --> 00:16:07,440
so we'll take a look at a few quick

412
00:16:07,440 --> 00:16:10,079
internals concepts

413
00:16:10,079 --> 00:16:12,399
so php byte code is it's similar to

414
00:16:12,399 --> 00:16:14,160
python and that

415
00:16:14,160 --> 00:16:16,240
you know it's a it's a bytecode format

416
00:16:16,240 --> 00:16:17,440
that the the vm

417
00:16:17,440 --> 00:16:21,199
understands however i'm i'm not aware of

418
00:16:21,199 --> 00:16:22,240
a

419
00:16:22,240 --> 00:16:25,519
concept of a pyc file in the php world

420
00:16:25,519 --> 00:16:29,920
however there are php extensions

421
00:16:29,920 --> 00:16:33,600
that will pre-compile scripts um

422
00:16:33,600 --> 00:16:35,600
and here's a quote the op cache

423
00:16:35,600 --> 00:16:38,320
extension improves php performance

424
00:16:38,320 --> 00:16:40,800
by storing pre-compiled script by code

425
00:16:40,800 --> 00:16:42,720
and shared memory

426
00:16:42,720 --> 00:16:45,040
thereby removing the need for php to

427
00:16:45,040 --> 00:16:47,920
load and parse scripts on each request

428
00:16:47,920 --> 00:16:50,959
so same idea scripts are precompiled

429
00:16:50,959 --> 00:16:52,160
into bytecode

430
00:16:52,160 --> 00:16:55,759
for speed purposes right now in general

431
00:16:55,759 --> 00:16:58,079
when a php script is executed it does

432
00:16:58,079 --> 00:17:00,000
get compiled into bytecode

433
00:17:00,000 --> 00:17:02,839
which is then executed by the zen vm

434
00:17:02,839 --> 00:17:05,839
runtime

435
00:17:06,160 --> 00:17:09,839
so php and the zen engine also

436
00:17:09,839 --> 00:17:13,199
provide different hooks for extensions

437
00:17:13,199 --> 00:17:15,039
and these hooks allow extension

438
00:17:15,039 --> 00:17:18,079
developers to control the php runtime in

439
00:17:18,079 --> 00:17:20,079
ways that are not available from php

440
00:17:20,079 --> 00:17:21,679
user land

441
00:17:21,679 --> 00:17:24,400
so some hooks that we're we'll talk

442
00:17:24,400 --> 00:17:24,959
about

443
00:17:24,959 --> 00:17:28,799
coming up here are zen compile file

444
00:17:28,799 --> 00:17:32,320
so think about when php source code is

445
00:17:32,320 --> 00:17:36,240
transformed into bytecode that bytecode

446
00:17:36,240 --> 00:17:38,480
is then executed so we could hook send

447
00:17:38,480 --> 00:17:39,919
execute

448
00:17:39,919 --> 00:17:43,600
and also each instruction

449
00:17:43,600 --> 00:17:45,760
just like in python has its own specific

450
00:17:45,760 --> 00:17:46,799
op code

451
00:17:46,799 --> 00:17:49,520
and those op code handlers the functions

452
00:17:49,520 --> 00:17:50,799
that know what to do with those

453
00:17:50,799 --> 00:17:52,080
instructions

454
00:17:52,080 --> 00:17:55,039
those can be overwritten as well and

455
00:17:55,039 --> 00:17:56,320
something i'd like to point out here as

456
00:17:56,320 --> 00:17:58,400
well is that

457
00:17:58,400 --> 00:18:01,280
hooking is extremely useful for

458
00:18:01,280 --> 00:18:02,799
debuggers

459
00:18:02,799 --> 00:18:04,720
um if you think about some debugging

460
00:18:04,720 --> 00:18:06,240
you've ever done you probably set a

461
00:18:06,240 --> 00:18:08,480
breakpoint on a function name

462
00:18:08,480 --> 00:18:10,400
um so that's that's the same concept you

463
00:18:10,400 --> 00:18:14,960
would hook that function name

464
00:18:14,960 --> 00:18:18,080
now in order to

465
00:18:18,080 --> 00:18:19,600
to pull this by code out that i was

466
00:18:19,600 --> 00:18:21,360
interested in i used a

467
00:18:21,360 --> 00:18:24,240
an extension called the vulcan logic

468
00:18:24,240 --> 00:18:25,679
dumper

469
00:18:25,679 --> 00:18:28,799
and the vulcan logic dumper allowed me

470
00:18:28,799 --> 00:18:29,600
to

471
00:18:29,600 --> 00:18:34,160
dump the instructions of a php script

472
00:18:34,160 --> 00:18:38,880
it did it at compile time so when this

473
00:18:38,880 --> 00:18:42,080
source code is compiled into bytecode

474
00:18:42,080 --> 00:18:43,840
that's at the point where it's dumping

475
00:18:43,840 --> 00:18:45,280
it so as you can see

476
00:18:45,280 --> 00:18:47,919
there's an echo that goes hello world

477
00:18:47,919 --> 00:18:50,799
and a return one

478
00:18:50,960 --> 00:18:55,039
now when i tried excuse me so

479
00:18:55,039 --> 00:18:59,200
vld like i said hooks zen compile file

480
00:18:59,200 --> 00:19:01,760
this is a snippet from vld that shows

481
00:19:01,760 --> 00:19:02,559
how that works

482
00:19:02,559 --> 00:19:06,160
so first the the script is compiled

483
00:19:06,160 --> 00:19:08,480
and then the and it compiles it into an

484
00:19:08,480 --> 00:19:10,960
op array

485
00:19:10,960 --> 00:19:14,320
and that op array contains the byte code

486
00:19:14,320 --> 00:19:16,320
and then vld dumps the op array so

487
00:19:16,320 --> 00:19:18,080
that's that output you saw here this is

488
00:19:18,080 --> 00:19:18,720
vld

489
00:19:18,720 --> 00:19:21,520
don't bop array

490
00:19:22,400 --> 00:19:25,679
now if you were to run vld as is

491
00:19:25,679 --> 00:19:29,039
when it hooks at compilation time

492
00:19:29,039 --> 00:19:30,640
if you were to run it against the source

493
00:19:30,640 --> 00:19:32,799
guardian protected file

494
00:19:32,799 --> 00:19:34,559
you wouldn't get the output that we're

495
00:19:34,559 --> 00:19:37,120
interested in we're interested in

496
00:19:37,120 --> 00:19:41,440
what the nagios xi developer

497
00:19:41,440 --> 00:19:43,600
implemented however what you would see

498
00:19:43,600 --> 00:19:45,440
is that source guardian wrapper that i

499
00:19:45,440 --> 00:19:47,280
was talking about before

500
00:19:47,280 --> 00:19:50,240
this is all the bytecode that would run

501
00:19:50,240 --> 00:19:52,799
in order to decode

502
00:19:52,799 --> 00:19:56,000
and execute the protected bytecode so as

503
00:19:56,000 --> 00:19:57,679
you can see at the top here

504
00:19:57,679 --> 00:20:00,160
like we saw in the source code it looks

505
00:20:00,160 --> 00:20:02,400
for that sg load function

506
00:20:02,400 --> 00:20:04,320
if it exists then eventually it would

507
00:20:04,320 --> 00:20:06,080
get called however

508
00:20:06,080 --> 00:20:08,559
the the output is pretty lengthy so it's

509
00:20:08,559 --> 00:20:11,200
not shown here

510
00:20:11,360 --> 00:20:14,400
okay so just let's let's uh take a step

511
00:20:14,400 --> 00:20:15,600
back real quick

512
00:20:15,600 --> 00:20:18,240
so if we're visualizing the hook that we

513
00:20:18,240 --> 00:20:19,360
want

514
00:20:19,360 --> 00:20:23,280
we know we don't want it at compile time

515
00:20:23,679 --> 00:20:25,679
but basically when a source guardian

516
00:20:25,679 --> 00:20:27,679
protected file is launched by php

517
00:20:27,679 --> 00:20:30,960
the interpreter launches

518
00:20:31,039 --> 00:20:34,080
all of the code is in there to decode

519
00:20:34,080 --> 00:20:37,039
the compiled encrypted bytecode

520
00:20:37,039 --> 00:20:40,400
at compile time which we just saw

521
00:20:40,400 --> 00:20:43,280
it would be compiled into bytecode which

522
00:20:43,280 --> 00:20:45,120
is end operate

523
00:20:45,120 --> 00:20:48,240
this includes that call to sg load

524
00:20:48,240 --> 00:20:50,159
and then after comp compiling the

525
00:20:50,159 --> 00:20:52,080
wrapper

526
00:20:52,080 --> 00:20:53,840
that code would get executed which in

527
00:20:53,840 --> 00:20:55,440
turn would execute

528
00:20:55,440 --> 00:20:58,720
sg load so as she load a fire

529
00:20:58,720 --> 00:21:01,440
it would decrypt the encrypted bytecode

530
00:21:01,440 --> 00:21:02,720
and then call

531
00:21:02,720 --> 00:21:06,080
zen execute to execute that protected by

532
00:21:06,080 --> 00:21:06,480
code

533
00:21:06,480 --> 00:21:07,919
and that's the by code we're interested

534
00:21:07,919 --> 00:21:09,760
in so

535
00:21:09,760 --> 00:21:13,440
the second invocation of zend execute

536
00:21:13,440 --> 00:21:17,840
is what we want to hook

537
00:21:18,480 --> 00:21:22,400
so my next step was to modify vld

538
00:21:22,400 --> 00:21:25,520
and i did this

539
00:21:25,520 --> 00:21:27,360
just like we talked about i i hooked the

540
00:21:27,360 --> 00:21:30,480
second invocation of zen execute

541
00:21:30,480 --> 00:21:33,840
so here's my vld um hook

542
00:21:33,840 --> 00:21:36,799
um so i wanted to see when execute ran

543
00:21:36,799 --> 00:21:38,720
so i printed out execute

544
00:21:38,720 --> 00:21:41,360
and then the operator would be dumped

545
00:21:41,360 --> 00:21:42,480
and then finally the

546
00:21:42,480 --> 00:21:45,679
by code would be actually executed so

547
00:21:45,679 --> 00:21:49,440
with the hello world we can see that

548
00:21:49,440 --> 00:21:53,200
the hook was hit execute was printed

549
00:21:53,200 --> 00:21:57,120
and clearly the instructions were

550
00:21:57,120 --> 00:22:01,280
were executed successfully however

551
00:22:01,280 --> 00:22:02,960
you don't see any instructions like we

552
00:22:02,960 --> 00:22:05,600
did earlier

553
00:22:07,280 --> 00:22:09,919
um the question was why why am i not

554
00:22:09,919 --> 00:22:11,679
seeing any instructions and at this

555
00:22:11,679 --> 00:22:12,080
point

556
00:22:12,080 --> 00:22:15,360
i decided i needed to debug the php

557
00:22:15,360 --> 00:22:16,080
process

558
00:22:16,080 --> 00:22:20,320
when i launched this encoded file

559
00:22:20,320 --> 00:22:23,440
so i set a breakpoint at send execute

560
00:22:23,440 --> 00:22:25,039
as you can see it was hit twice we're

561
00:22:25,039 --> 00:22:27,360
interested in the second one

562
00:22:27,360 --> 00:22:30,720
so at the second break point here

563
00:22:30,720 --> 00:22:33,840
i printed out the the op array

564
00:22:33,840 --> 00:22:35,600
and as you can see there are three

565
00:22:35,600 --> 00:22:38,320
instructions

566
00:22:38,480 --> 00:22:41,600
and lines start is zero and line end is

567
00:22:41,600 --> 00:22:44,000
zero

568
00:22:45,120 --> 00:22:48,000
and that was weird because if you looked

569
00:22:48,000 --> 00:22:49,760
at all the individual instructions

570
00:22:49,760 --> 00:22:52,880
in the operae um and actually the the

571
00:22:52,880 --> 00:22:54,000
instructions

572
00:22:54,000 --> 00:22:57,039
are zen ops

573
00:22:57,039 --> 00:22:59,760
each of these had a line number of zero

574
00:22:59,760 --> 00:23:02,320
which was kind of strange

575
00:23:02,320 --> 00:23:03,440
um but if you were to look at the

576
00:23:03,440 --> 00:23:05,919
structure you can see it has a handler

577
00:23:05,919 --> 00:23:10,080
it has operands line numbers

578
00:23:10,080 --> 00:23:14,080
now i dug into the vld source code to

579
00:23:14,080 --> 00:23:15,919
try and figure out why the instructions

580
00:23:15,919 --> 00:23:17,760
weren't being dumped

581
00:23:17,760 --> 00:23:21,840
and i ran into a function that dumps

582
00:23:21,840 --> 00:23:25,120
individual instructions and i found this

583
00:23:25,120 --> 00:23:28,400
interesting if block if um

584
00:23:28,400 --> 00:23:30,799
op line number equals zero which they

585
00:23:30,799 --> 00:23:31,440
all do

586
00:23:31,440 --> 00:23:34,480
we return we don't dump anything so

587
00:23:34,480 --> 00:23:38,159
i went ahead and commented that out

588
00:23:38,240 --> 00:23:40,400
and i got some new output so that was

589
00:23:40,400 --> 00:23:41,840
pretty exciting

590
00:23:41,840 --> 00:23:45,120
so at the top here is

591
00:23:45,120 --> 00:23:48,159
my modified vld against

592
00:23:48,159 --> 00:23:51,440
an encoded file encoded hello world

593
00:23:51,440 --> 00:23:53,760
and at the bottom here is vld run

594
00:23:53,760 --> 00:23:54,640
against

595
00:23:54,640 --> 00:23:58,000
um the hello world prior to being

596
00:23:58,000 --> 00:23:59,840
encoded so this is not an encoded file

597
00:23:59,840 --> 00:24:02,840
this is what we're expecting to get

598
00:24:02,840 --> 00:24:04,000
however

599
00:24:04,000 --> 00:24:05,919
um the output i got was interesting

600
00:24:05,919 --> 00:24:07,200
because

601
00:24:07,200 --> 00:24:09,679
the number of ops were increased you'll

602
00:24:09,679 --> 00:24:11,279
notice there are three up top and two at

603
00:24:11,279 --> 00:24:12,640
the bottom

604
00:24:12,640 --> 00:24:14,159
and that there is an additional

605
00:24:14,159 --> 00:24:15,760
instruction prepended

606
00:24:15,760 --> 00:24:18,000
there's a jump at the beginning but if

607
00:24:18,000 --> 00:24:20,000
you trace the jump

608
00:24:20,000 --> 00:24:24,880
jump to instruction at offset two

609
00:24:24,880 --> 00:24:28,159
then it would simply return and the echo

610
00:24:28,159 --> 00:24:30,159
would not get executed

611
00:24:30,159 --> 00:24:31,679
so the control flow is a little off

612
00:24:31,679 --> 00:24:33,600
there

613
00:24:33,600 --> 00:24:36,799
now i i wasn't sure why

614
00:24:36,799 --> 00:24:39,039
this was happening so naturally i

615
00:24:39,039 --> 00:24:40,480
started off you know creating more

616
00:24:40,480 --> 00:24:41,200
samples

617
00:24:41,200 --> 00:24:43,440
and this was my next sample i generate a

618
00:24:43,440 --> 00:24:44,559
random number which

619
00:24:44,559 --> 00:24:47,120
will end up being either zero or one

620
00:24:47,120 --> 00:24:49,039
depending on the out but depending on

621
00:24:49,039 --> 00:24:49,600
that

622
00:24:49,600 --> 00:24:54,240
random number i'll echo one or zero

623
00:24:54,799 --> 00:24:58,400
so i reran this test again the encoded

624
00:24:58,400 --> 00:24:59,279
versions at the top

625
00:24:59,279 --> 00:25:02,400
the unencoded versions at the bottom and

626
00:25:02,400 --> 00:25:04,240
notice that again there are more

627
00:25:04,240 --> 00:25:07,520
instructions there's an additional jump

628
00:25:07,520 --> 00:25:14,480
if we follow the jump to four

629
00:25:14,480 --> 00:25:17,039
what happens here is a function call to

630
00:25:17,039 --> 00:25:18,559
rand takes place

631
00:25:18,559 --> 00:25:22,880
but only one is passed as an argument

632
00:25:22,880 --> 00:25:25,919
so if we jump straight to four then zero

633
00:25:25,919 --> 00:25:28,320
doesn't get added as an argument

634
00:25:28,320 --> 00:25:30,720
so that doesn't match up with the source

635
00:25:30,720 --> 00:25:32,720
code

636
00:25:32,720 --> 00:25:35,039
additionally if you were to look at the

637
00:25:35,039 --> 00:25:36,880
output down here

638
00:25:36,880 --> 00:25:39,919
there's a jump z but there is no

639
00:25:39,919 --> 00:25:44,080
jump z so it looks like that

640
00:25:44,080 --> 00:25:47,840
instruction got changed

641
00:25:48,640 --> 00:25:51,679
so i went back to the debugger

642
00:25:51,679 --> 00:25:54,559
for the hello world

643
00:25:54,799 --> 00:25:56,000
if you remember there were three

644
00:25:56,000 --> 00:25:58,240
instructions a jump an echo

645
00:25:58,240 --> 00:26:01,760
and a return now something that stood

646
00:26:01,760 --> 00:26:03,200
out to me was

647
00:26:03,200 --> 00:26:06,240
the jump handler address

648
00:26:06,240 --> 00:26:09,039
didn't point to a symbol like the other

649
00:26:09,039 --> 00:26:10,720
two

650
00:26:10,720 --> 00:26:13,760
as you can see with the echo instruction

651
00:26:13,760 --> 00:26:16,080
the handler is it has a symbol

652
00:26:16,080 --> 00:26:17,279
associated with it

653
00:26:17,279 --> 00:26:20,400
zen echo spec const handler

654
00:26:20,400 --> 00:26:22,640
and the return has a symbol associated

655
00:26:22,640 --> 00:26:24,000
with it

656
00:26:24,000 --> 00:26:27,279
so that was kind of strange

657
00:26:27,279 --> 00:26:29,919
i looked into this address for the jump

658
00:26:29,919 --> 00:26:31,840
handler

659
00:26:31,840 --> 00:26:33,840
to see where it was in the loaded

660
00:26:33,840 --> 00:26:36,400
libraries and sure enough

661
00:26:36,400 --> 00:26:39,600
it actually pointed into the

662
00:26:39,600 --> 00:26:43,279
the source guardian extension

663
00:26:43,279 --> 00:26:45,679
so this weird file name is the source

664
00:26:45,679 --> 00:26:48,960
guardian loader extension

665
00:26:48,960 --> 00:26:51,360
i set a break point on that address and

666
00:26:51,360 --> 00:26:52,240
sure enough

667
00:26:52,240 --> 00:26:55,919
once that function fired i was inside of

668
00:26:55,919 --> 00:26:57,279
the source guardian

669
00:26:57,279 --> 00:27:00,000
extension there

670
00:27:01,120 --> 00:27:03,520
now when i disassembled that source

671
00:27:03,520 --> 00:27:04,400
guardian jump

672
00:27:04,400 --> 00:27:07,919
handler function there was a specific

673
00:27:07,919 --> 00:27:10,799
instruction that stood out to me and

674
00:27:10,799 --> 00:27:12,960
that was the call

675
00:27:12,960 --> 00:27:15,039
so inside the source guardian jump

676
00:27:15,039 --> 00:27:17,840
handler it's calling another function

677
00:27:17,840 --> 00:27:20,159
at a pointer you know it's a function

678
00:27:20,159 --> 00:27:21,440
pointer

679
00:27:21,440 --> 00:27:24,399
when i stepped into that function sure

680
00:27:24,399 --> 00:27:25,360
enough

681
00:27:25,360 --> 00:27:28,720
the zend jump handler was called

682
00:27:28,720 --> 00:27:31,600
so basically a bunch of stuff happens

683
00:27:31,600 --> 00:27:33,440
when a jump is encountered

684
00:27:33,440 --> 00:27:36,880
and then the actual zen jump handler is

685
00:27:36,880 --> 00:27:39,200
called

686
00:27:39,520 --> 00:27:42,799
if you were to look at the operands of

687
00:27:42,799 --> 00:27:44,880
the jump instruction

688
00:27:44,880 --> 00:27:47,840
before entering the source guardian jump

689
00:27:47,840 --> 00:27:49,440
handler

690
00:27:49,440 --> 00:27:52,640
and then compare it to inside of that

691
00:27:52,640 --> 00:27:54,240
source guardian jump handler

692
00:27:54,240 --> 00:27:56,640
right before the zen jump handler got

693
00:27:56,640 --> 00:27:57,679
called

694
00:27:57,679 --> 00:28:00,720
you would notice that operand one

695
00:28:00,720 --> 00:28:03,039
actually changed and since it's a jump

696
00:28:03,039 --> 00:28:05,760
the operating one is a jump address

697
00:28:05,760 --> 00:28:09,200
so the address of the jump changed

698
00:28:09,200 --> 00:28:12,799
which means that the jump would then

699
00:28:12,799 --> 00:28:17,840
jump to a different instruction

700
00:28:17,919 --> 00:28:20,880
now just to kind of recap on that inside

701
00:28:20,880 --> 00:28:22,880
the the source guardian jump handler

702
00:28:22,880 --> 00:28:27,200
this is the logic so first that jump

703
00:28:27,200 --> 00:28:30,320
operation is referenced

704
00:28:30,320 --> 00:28:35,200
the operands are de-obfuscated

705
00:28:35,200 --> 00:28:37,279
and then the default implementation of

706
00:28:37,279 --> 00:28:38,559
the zen jump handler

707
00:28:38,559 --> 00:28:42,480
is executed after that the operands

708
00:28:42,480 --> 00:28:45,520
were re-obfuscated

709
00:28:45,520 --> 00:28:48,559
to their original state

710
00:28:50,399 --> 00:28:52,080
okay so now we'll start getting into my

711
00:28:52,080 --> 00:28:54,399
solution

712
00:28:54,399 --> 00:28:56,399
in order so so i started off with this

713
00:28:56,399 --> 00:28:57,679
jump instruction

714
00:28:57,679 --> 00:29:01,840
how can i fix just one jump

715
00:29:03,360 --> 00:29:07,039
so my solution was to modify

716
00:29:07,039 --> 00:29:08,799
the source guardian jump handler

717
00:29:08,799 --> 00:29:10,480
function

718
00:29:10,480 --> 00:29:13,279
but create my own new function so when a

719
00:29:13,279 --> 00:29:14,480
jump was encountered

720
00:29:14,480 --> 00:29:18,000
my function would run so

721
00:29:18,000 --> 00:29:20,480
i copied some of their their code to

722
00:29:20,480 --> 00:29:22,000
allow for

723
00:29:22,000 --> 00:29:25,440
the operands to de-obfuscate

724
00:29:25,440 --> 00:29:29,120
however i did not allow the zen jump

725
00:29:29,120 --> 00:29:31,520
handler to run

726
00:29:31,520 --> 00:29:34,960
instead i set the

727
00:29:34,960 --> 00:29:38,159
current current zendops handler

728
00:29:38,159 --> 00:29:41,120
that jump handler to be the at the

729
00:29:41,120 --> 00:29:41,919
actual zen

730
00:29:41,919 --> 00:29:46,000
jump handler and then i didn't allow

731
00:29:46,000 --> 00:29:49,039
the operands to restore to their

732
00:29:49,039 --> 00:29:52,080
obfuscated state

733
00:29:53,120 --> 00:29:56,000
um so that's just for one operation but

734
00:29:56,000 --> 00:29:57,279
we did have to fix

735
00:29:57,279 --> 00:30:00,320
we have to fix the entire opera so if

736
00:30:00,320 --> 00:30:02,320
you remember back before

737
00:30:02,320 --> 00:30:05,200
um when we would dump an opera it would

738
00:30:05,200 --> 00:30:06,159
just show the

739
00:30:06,159 --> 00:30:09,600
obfuscated values and then

740
00:30:09,600 --> 00:30:12,640
once the operator was executed

741
00:30:12,640 --> 00:30:15,440
by zendexq the source guardian handlers

742
00:30:15,440 --> 00:30:16,159
would run for

743
00:30:16,159 --> 00:30:18,960
zendot the operands would be obfuscated

744
00:30:18,960 --> 00:30:19,679
then the real

745
00:30:19,679 --> 00:30:22,640
zen handler would run and the operands

746
00:30:22,640 --> 00:30:23,039
were

747
00:30:23,039 --> 00:30:26,159
obfuscated again now with my solution i

748
00:30:26,159 --> 00:30:27,600
added a step at the beginning to

749
00:30:27,600 --> 00:30:30,320
fix that operator so using the same

750
00:30:30,320 --> 00:30:31,440
logic

751
00:30:31,440 --> 00:30:34,480
from from the source guardian handlers i

752
00:30:34,480 --> 00:30:36,559
would allow those end operations to the

753
00:30:36,559 --> 00:30:37,440
obfuscate

754
00:30:37,440 --> 00:30:39,919
as intended and then i would set the

755
00:30:39,919 --> 00:30:40,720
handler for

756
00:30:40,720 --> 00:30:43,360
operation to actually point to the zen

757
00:30:43,360 --> 00:30:44,480
handler

758
00:30:44,480 --> 00:30:47,279
so then when i dump the operae you would

759
00:30:47,279 --> 00:30:51,039
see those corrected operands

760
00:30:51,039 --> 00:30:53,200
and when the actual operator was

761
00:30:53,200 --> 00:30:54,799
executed

762
00:30:54,799 --> 00:30:57,840
the zendops would execute correctly

763
00:30:57,840 --> 00:30:58,960
because

764
00:30:58,960 --> 00:31:02,080
the operands were de-obfuscated and the

765
00:31:02,080 --> 00:31:02,720
handler

766
00:31:02,720 --> 00:31:06,320
was pointing to the zen handler

767
00:31:07,919 --> 00:31:09,840
and okay so i told you about the jump

768
00:31:09,840 --> 00:31:13,039
handler but there were several different

769
00:31:13,039 --> 00:31:15,840
source guardian op code handlers for

770
00:31:15,840 --> 00:31:17,760
different types of

771
00:31:17,760 --> 00:31:20,720
instructions so i've grouped them into

772
00:31:20,720 --> 00:31:22,559
five different

773
00:31:22,559 --> 00:31:24,880
handlers here so source guardian had

774
00:31:24,880 --> 00:31:26,720
five different handlers

775
00:31:26,720 --> 00:31:29,840
depending on the opcode value it would

776
00:31:29,840 --> 00:31:32,240
determine which handler was called

777
00:31:32,240 --> 00:31:34,240
so i ended up having to create five of

778
00:31:34,240 --> 00:31:36,080
my own

779
00:31:36,080 --> 00:31:39,519
as you can see off to the left here

780
00:31:40,559 --> 00:31:42,960
i would loop through the the op array

781
00:31:42,960 --> 00:31:43,679
look at

782
00:31:43,679 --> 00:31:47,760
every instruction and

783
00:31:47,760 --> 00:31:50,880
depending on the opcode value i would

784
00:31:50,880 --> 00:31:54,559
call a specific function to fix it

785
00:31:54,559 --> 00:31:57,360
as you can see the top here if it's 42

786
00:31:57,360 --> 00:32:00,240
or 100 i call the fixed jump

787
00:32:00,240 --> 00:32:03,519
this function handles these op codes

788
00:32:03,519 --> 00:32:06,080
and so on

789
00:32:07,600 --> 00:32:10,880
so we've seen how to fix an opera

790
00:32:10,880 --> 00:32:13,840
now like in the python world classes

791
00:32:13,840 --> 00:32:16,880
create a different layer of complexity

792
00:32:16,880 --> 00:32:19,360
here's another example we have a class

793
00:32:19,360 --> 00:32:21,279
one and a class two

794
00:32:21,279 --> 00:32:23,120
each of which has either a funk one or

795
00:32:23,120 --> 00:32:24,799
funk two that echoes

796
00:32:24,799 --> 00:32:28,000
one or two each class also has

797
00:32:28,000 --> 00:32:30,399
a function that is not used so i've not

798
00:32:30,399 --> 00:32:32,640
used one or not used to

799
00:32:32,640 --> 00:32:37,360
and they return one or two now

800
00:32:37,360 --> 00:32:39,600
i define these classes and also i have

801
00:32:39,600 --> 00:32:41,840
like kind of a main function here

802
00:32:41,840 --> 00:32:43,679
generate a random number one or two

803
00:32:43,679 --> 00:32:44,960
depending on the value

804
00:32:44,960 --> 00:32:46,880
either class one or class two is

805
00:32:46,880 --> 00:32:48,240
instantiated

806
00:32:48,240 --> 00:32:50,399
and either func one or function will be

807
00:32:50,399 --> 00:32:52,799
called

808
00:32:53,919 --> 00:32:57,039
now when i ran my modified vld against

809
00:32:57,039 --> 00:32:58,080
this

810
00:32:58,080 --> 00:33:00,000
um here's the main that we saw right we

811
00:33:00,000 --> 00:33:01,840
generate a random number

812
00:33:01,840 --> 00:33:03,919
uh depending on the value either class

813
00:33:03,919 --> 00:33:06,080
one or class two is instantiated

814
00:33:06,080 --> 00:33:09,360
func one or font two is called

815
00:33:09,360 --> 00:33:12,960
and for this particular case the random

816
00:33:12,960 --> 00:33:13,679
value was

817
00:33:13,679 --> 00:33:17,039
one um so as you can see

818
00:33:17,039 --> 00:33:21,519
func one was dumped however

819
00:33:21,519 --> 00:33:24,559
um they not used

820
00:33:24,559 --> 00:33:27,919
one function was not dumped and class

821
00:33:27,919 --> 00:33:28,480
two

822
00:33:28,480 --> 00:33:31,760
entirely was not done so

823
00:33:31,760 --> 00:33:34,159
i only got the output for the

824
00:33:34,159 --> 00:33:36,080
instructions that were executed

825
00:33:36,080 --> 00:33:40,159
the main and class ones funk one

826
00:33:40,159 --> 00:33:43,120
so in order to dump it all i had to tap

827
00:33:43,120 --> 00:33:43,600
into

828
00:33:43,600 --> 00:33:48,159
the class table and the function table

829
00:33:48,159 --> 00:33:50,480
so like we saw before i have that fixed

830
00:33:50,480 --> 00:33:52,240
op array

831
00:33:52,240 --> 00:33:55,600
routine which would fix the main

832
00:33:55,600 --> 00:33:57,120
and then i would have to tap into the

833
00:33:57,120 --> 00:33:59,440
class table which contains class 1 class

834
00:33:59,440 --> 00:34:00,399
2

835
00:34:00,399 --> 00:34:02,000
and all their functions and in this case

836
00:34:02,000 --> 00:34:04,559
we didn't really have any functions but

837
00:34:04,559 --> 00:34:08,079
outside of the classes but all of these

838
00:34:08,079 --> 00:34:09,599
would need to be processed

839
00:34:09,599 --> 00:34:13,119
as operas um and then at that point

840
00:34:13,119 --> 00:34:17,280
we would dump the operae and

841
00:34:17,280 --> 00:34:20,399
so then i was able to view the

842
00:34:20,399 --> 00:34:23,599
instructions for not used one and

843
00:34:23,599 --> 00:34:25,119
additionally

844
00:34:25,119 --> 00:34:28,560
class two entirely

845
00:34:30,079 --> 00:34:33,199
so thank you all for joining

846
00:34:33,199 --> 00:34:36,000
just to recap we talked about remapping

847
00:34:36,000 --> 00:34:39,918
python opcodes in a static pyc file

848
00:34:39,918 --> 00:34:42,639
and we also fixed php bytecode at

849
00:34:42,639 --> 00:34:44,800
runtime

850
00:34:44,800 --> 00:34:46,639
hopefully this talk helps you down the

851
00:34:46,639 --> 00:34:48,079
road when you encounter a similar

852
00:34:48,079 --> 00:34:49,918
protection mechanism

853
00:34:49,918 --> 00:34:51,679
if you're if you're interested in diving

854
00:34:51,679 --> 00:34:53,119
in a little bit deeper

855
00:34:53,119 --> 00:34:54,480
i have written a couple blogs on the

856
00:34:54,480 --> 00:34:56,639
topic and

857
00:34:56,639 --> 00:35:00,000
all my source code is available online

858
00:35:00,000 --> 00:35:02,320
and at this point i will open it up for

859
00:35:02,320 --> 00:35:04,720
questions

860
00:35:05,440 --> 00:35:07,760
thank you chris uh very interesting

861
00:35:07,760 --> 00:35:09,680
normally i can um

862
00:35:09,680 --> 00:35:11,839
have an opinion on most talks that are

863
00:35:11,839 --> 00:35:13,520
given but this was like

864
00:35:13,520 --> 00:35:16,240
a different language to me so um very

865
00:35:16,240 --> 00:35:17,920
very interesting very technical so so

866
00:35:17,920 --> 00:35:19,040
thanks for that

867
00:35:19,040 --> 00:35:21,520
i'm just going to check the questions uh

868
00:35:21,520 --> 00:35:23,359
tab there and swap card just give me a

869
00:35:23,359 --> 00:35:25,759
second

870
00:35:26,880 --> 00:35:29,040
so there have been no questions yet so

871
00:35:29,040 --> 00:35:30,400
i'll just give folks under maybe

872
00:35:30,400 --> 00:35:33,520
10 or 20 seconds sure and if there's no

873
00:35:33,520 --> 00:35:34,640
questions then we'll

874
00:35:34,640 --> 00:35:45,119
give you back maybe eight minutes

875
00:35:45,119 --> 00:35:46,640
okay there's no questions coming in

876
00:35:46,640 --> 00:35:48,480
chris so thanks again for your

877
00:35:48,480 --> 00:35:51,520
for your time today um the feedback was

878
00:35:51,520 --> 00:35:53,040
very good on the on the chat

879
00:35:53,040 --> 00:35:55,119
uh very informative from from lots of

880
00:35:55,119 --> 00:35:56,400
folks um

881
00:35:56,400 --> 00:35:58,240
so thanks again for your time chris and

882
00:35:58,240 --> 00:35:59,680
enjoy the rest of your day

883
00:35:59,680 --> 00:36:09,440
awesome thank you for having me

