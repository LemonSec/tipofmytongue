1
00:00:00,329 --> 00:00:03,629
the next speakers are also very active

2
00:00:03,629 --> 00:00:05,430
in the local community and they deliver

3
00:00:05,430 --> 00:00:10,170
talks in DC a couple of times and one

4
00:00:10,170 --> 00:00:13,650
time each of them and today they are

5
00:00:13,650 --> 00:00:16,139
going to be talking about hooks in

6
00:00:16,139 --> 00:00:19,250
64-bits it's extremely interesting talk

7
00:00:19,250 --> 00:00:27,529
but before you can start fine

8
00:00:31,770 --> 00:00:38,179
[Applause]

9
00:00:38,840 --> 00:00:45,950
show me hi everyone we are safe until

10
00:00:45,950 --> 00:00:47,660
then we're here to talk about the

11
00:00:47,660 --> 00:00:49,490
project we did in the past few months a

12
00:00:49,490 --> 00:00:51,950
nickname The Cook's the purpose of this

13
00:00:51,950 --> 00:00:54,050
project is to monitor the native

14
00:00:54,050 --> 00:00:56,870
execution inside of all 64 processors in

15
00:00:56,870 --> 00:00:58,550
order to gain some visibility into

16
00:00:58,550 --> 00:01:01,370
certain viruses inside of such processes

17
00:01:01,370 --> 00:01:03,170
so we'll start with a quick introduction

18
00:01:03,170 --> 00:01:06,170
I know then I'm a dancer a gymnast

19
00:01:06,170 --> 00:01:08,210
nacrobat they started competing with

20
00:01:08,210 --> 00:01:10,250
gymnastics a kid and danced for many

21
00:01:10,250 --> 00:01:12,860
years recent years I'm a circus acrobat

22
00:01:12,860 --> 00:01:15,470
they did you perform aerial silks and

23
00:01:15,470 --> 00:01:17,450
Lyra in my spare time I'm a security

24
00:01:17,450 --> 00:01:19,670
researcher at San Pierre one who I have

25
00:01:19,670 --> 00:01:21,950
done this project and with me here is a

26
00:01:21,950 --> 00:01:23,869
staff who is also a security researcher

27
00:01:23,869 --> 00:01:25,850
at San Pio one and let me introduce

28
00:01:25,850 --> 00:01:28,210
himself

29
00:01:28,479 --> 00:01:30,320
so hi everyone

30
00:01:30,320 --> 00:01:31,580
I am a self and I'm a security

31
00:01:31,580 --> 00:01:40,520
researcher 29:1 before we start with the

32
00:01:40,520 --> 00:01:42,680
project itself let's let's have a bit of

33
00:01:42,680 --> 00:01:45,020
background in Avery's and security

34
00:01:45,020 --> 00:01:46,820
products in general want to monitor

35
00:01:46,820 --> 00:01:48,530
every things going on in the system and

36
00:01:48,530 --> 00:01:50,210
what's happening inside its inner

37
00:01:50,210 --> 00:01:52,220
process one of the most common ways to

38
00:01:52,220 --> 00:01:54,410
do that is by using user mode hooks

39
00:01:54,410 --> 00:01:56,479
placed on some interesting API functions

40
00:01:56,479 --> 00:01:59,030
such as those that dealing with virtual

41
00:01:59,030 --> 00:02:01,250
memory operations or inter-process

42
00:02:01,250 --> 00:02:04,429
communications major disadvantage of

43
00:02:04,429 --> 00:02:05,929
this hook is that they can be bypassed

44
00:02:05,929 --> 00:02:07,940
pretty easily using lots of different

45
00:02:07,940 --> 00:02:09,740
techniques we won't talk about most of

46
00:02:09,740 --> 00:02:11,060
these techniques we'll focus on a

47
00:02:11,060 --> 00:02:13,940
certain family of viruses the target the

48
00:02:13,940 --> 00:02:16,550
you are 64 mechanism so a couple of

49
00:02:16,550 --> 00:02:19,640
words about this mechanism when

50
00:02:19,640 --> 00:02:22,190
Microsoft started developing the 64-bit

51
00:02:22,190 --> 00:02:24,080
operating system they faced a bit of a

52
00:02:24,080 --> 00:02:26,870
problem exists in 32-bit applications

53
00:02:26,870 --> 00:02:29,840
can't natively run on top of 64-bit

54
00:02:29,840 --> 00:02:31,670
operating systems and will just break

55
00:02:31,670 --> 00:02:33,350
Microsoft didn't wanna break all these

56
00:02:33,350 --> 00:02:35,750
applications so they had to find some

57
00:02:35,750 --> 00:02:37,580
solution to allow them to run the

58
00:02:37,580 --> 00:02:39,350
solution they came up with is called

59
00:02:39,350 --> 00:02:42,260
1264 which is naturally for Windows and

60
00:02:42,260 --> 00:02:43,010
Windows 64

61
00:02:43,010 --> 00:02:45,560
it's a compatibility layer that allows

62
00:02:45,560 --> 00:02:48,530
32-bit applications to run on top of the

63
00:02:48,530 --> 00:02:49,410
64 bit

64
00:02:49,410 --> 00:02:50,760
rating systems as if they were running

65
00:02:50,760 --> 00:02:54,060
inside of a 32-bit system this layer is

66
00:02:54,060 --> 00:02:57,030
basically just made of a few a 64-bit

67
00:02:57,030 --> 00:03:00,270
DLL loaded into 32-bit applications and

68
00:03:00,270 --> 00:03:02,310
it has lots of different applications

69
00:03:02,310 --> 00:03:03,960
across the system some of these

70
00:03:03,960 --> 00:03:06,690
implications such as file system and

71
00:03:06,690 --> 00:03:09,090
registry direction aren't we development

72
00:03:09,090 --> 00:03:10,560
for this project and there are pretty

73
00:03:10,560 --> 00:03:11,850
well documented so we won't talk about

74
00:03:11,850 --> 00:03:13,950
them and implication we'll talk about

75
00:03:13,950 --> 00:03:16,520
has to do with system called handling

76
00:03:16,520 --> 00:03:20,520
whenever process wants to make a request

77
00:03:20,520 --> 00:03:22,830
from the operating system they do that

78
00:03:22,830 --> 00:03:25,320
through a mechanism called a system call

79
00:03:25,320 --> 00:03:27,090
most of these system calls are

80
00:03:27,090 --> 00:03:29,820
dispatched through a dedicated system

81
00:03:29,820 --> 00:03:32,430
DLL which is loaded into every Windows

82
00:03:32,430 --> 00:03:35,490
process called ntdll while 64 processes

83
00:03:35,490 --> 00:03:37,680
have two versions of this anti DLL a

84
00:03:37,680 --> 00:03:40,590
32-bit one and a 64-bit one and let's

85
00:03:40,590 --> 00:03:42,720
see why it looks like here on the Left

86
00:03:42,720 --> 00:03:45,630
we have the 32-bit version of ntdll and

87
00:03:45,630 --> 00:03:48,210
which receives requests from the

88
00:03:48,210 --> 00:03:50,940
application these API functions in the

89
00:03:50,940 --> 00:03:52,610
DLL don't really do much except for

90
00:03:52,610 --> 00:03:54,780
forwarding the request to the ah-64

91
00:03:54,780 --> 00:03:57,870
layer the slayerfest first has to make

92
00:03:57,870 --> 00:04:01,230
the transition to 64-bit mode and they

93
00:04:01,230 --> 00:04:04,470
do that through the jump instruction we

94
00:04:04,470 --> 00:04:05,250
have in the middle

95
00:04:05,250 --> 00:04:08,459
this is a unique jump instruction for

96
00:04:08,459 --> 00:04:11,130
jump to code segment 33 which makes the

97
00:04:11,130 --> 00:04:13,680
processor on the hardware level switch

98
00:04:13,680 --> 00:04:16,339
from 32-bit to 64-bit execution mode

99
00:04:16,339 --> 00:04:18,899
afterwards the you are 64 layer has to

100
00:04:18,899 --> 00:04:20,459
make a few more adjustments to the

101
00:04:20,459 --> 00:04:23,100
request such as pointer size expansion

102
00:04:23,100 --> 00:04:25,560
from 32 bits to 64 bits a calling

103
00:04:25,560 --> 00:04:27,780
convention adjustments as the convention

104
00:04:27,780 --> 00:04:30,390
is different on 64 bit and a couple more

105
00:04:30,390 --> 00:04:33,090
stuff when the request is complete the

106
00:04:33,090 --> 00:04:36,300
one 64 layer forwards it to an API

107
00:04:36,300 --> 00:04:38,820
function in the 64 bit ntdll which can

108
00:04:38,820 --> 00:04:41,250
actually dispatch the request to the

109
00:04:41,250 --> 00:04:43,620
Oscar know through our dedicated CPU

110
00:04:43,620 --> 00:04:46,500
instruction now let's talk about these

111
00:04:46,500 --> 00:04:48,650
vices as I mentioned in the beginning

112
00:04:48,650 --> 00:04:51,240
there is a whole family of bypasses the

113
00:04:51,240 --> 00:04:54,210
target the you are 64 mechanism they all

114
00:04:54,210 --> 00:04:57,150
basically work by calling 64 bit API

115
00:04:57,150 --> 00:04:59,940
functions without going through

116
00:04:59,940 --> 00:05:03,420
the 32-bit API functions or the or 64

117
00:05:03,420 --> 00:05:06,000
layer the most well-known and most

118
00:05:06,000 --> 00:05:09,330
commonly used bypass uses of this family

119
00:05:09,330 --> 00:05:11,610
is called heaven's gate it was first

120
00:05:11,610 --> 00:05:13,560
published about 10 years ago and was

121
00:05:13,560 --> 00:05:15,810
seen quite commonly in the wild in lots

122
00:05:15,810 --> 00:05:16,860
of different types of Malwa

123
00:05:16,860 --> 00:05:19,680
if we haven't been technique works by

124
00:05:19,680 --> 00:05:22,740
making the transition to 64-bit a mode

125
00:05:22,740 --> 00:05:24,990
on its own making of the required

126
00:05:24,990 --> 00:05:26,310
adjustments to the request and then

127
00:05:26,310 --> 00:05:30,300
directly a call in 64-bit API functions

128
00:05:30,300 --> 00:05:33,600
found in a 64-bit ntdll now why is that

129
00:05:33,600 --> 00:05:36,540
hoped by this technique because while 64

130
00:05:36,540 --> 00:05:39,030
processors are effectively 32-bit

131
00:05:39,030 --> 00:05:41,280
processes user mode hooks are anomic are

132
00:05:41,280 --> 00:05:43,860
normally placed on 32-bit API functions

133
00:05:43,860 --> 00:05:48,390
with the assumption that the 64 bit

134
00:05:48,390 --> 00:05:52,000
functions will not be called indirectly

135
00:05:52,000 --> 00:05:53,630
[Music]

136
00:05:53,630 --> 00:05:56,880
this is normally - except for cases

137
00:05:56,880 --> 00:05:58,590
where techniques such as heaven's gate

138
00:05:58,590 --> 00:06:02,910
are used and they cause they create a

139
00:06:02,910 --> 00:06:05,340
sort of a blind spot for a vs which will

140
00:06:05,340 --> 00:06:08,190
miss most calls than using such

141
00:06:08,190 --> 00:06:10,200
techniques so we want to address this

142
00:06:10,200 --> 00:06:13,140
blind spot and do that by you hooking

143
00:06:13,140 --> 00:06:16,560
the 64 bit API functions themselves this

144
00:06:16,560 --> 00:06:19,500
sounds easy but in reality it's not that

145
00:06:19,500 --> 00:06:23,430
much we first need to find a way to run

146
00:06:23,430 --> 00:06:25,530
or 64-bit code inside of our 64

147
00:06:25,530 --> 00:06:28,020
processes which are effectively 32-bit

148
00:06:28,020 --> 00:06:30,480
processors will do that by injecting or

149
00:06:30,480 --> 00:06:33,510
64 MIDI ll into these processes then we

150
00:06:33,510 --> 00:06:35,990
can't just inject any 64 bit DLL because

151
00:06:35,990 --> 00:06:39,000
64-bit code faces lots of limitations

152
00:06:39,000 --> 00:06:41,040
inside of all 64 processors and

153
00:06:41,040 --> 00:06:43,169
eventually we actually want to hook our

154
00:06:43,169 --> 00:06:45,750
API functions so for that we'll need a

155
00:06:45,750 --> 00:06:47,280
hook in engine that is actually capable

156
00:06:47,280 --> 00:06:49,740
of hooking 64-bit code in this processes

157
00:06:49,740 --> 00:06:55,080
now we'll start with the injection okay

158
00:06:55,080 --> 00:06:57,390
so just like Lauren said the first task

159
00:06:57,390 --> 00:06:59,790
that one must accomplish is finding an

160
00:06:59,790 --> 00:07:01,440
injection method which will allow us to

161
00:07:01,440 --> 00:07:03,930
run our own 64-bit code inside the

162
00:07:03,930 --> 00:07:05,820
context of the target process so

163
00:07:05,820 --> 00:07:07,380
generally speaking there are lots of

164
00:07:07,380 --> 00:07:08,669
different injection methods which are

165
00:07:08,669 --> 00:07:10,470
available at our disposal but

166
00:07:10,470 --> 00:07:12,630
unfortunately most of them are not going

167
00:07:12,630 --> 00:07:13,849
to be very beneficial

168
00:07:13,849 --> 00:07:15,770
to us and the reason for that is that

169
00:07:15,770 --> 00:07:17,240
most injection techniques will only

170
00:07:17,240 --> 00:07:21,139
allow us to inject dll's which has the

171
00:07:21,139 --> 00:07:23,419
same business as the target process so

172
00:07:23,419 --> 00:07:25,879
that means either injecting 64-bit code

173
00:07:25,879 --> 00:07:28,249
into a 64-bit processors or 32-bit code

174
00:07:28,249 --> 00:07:30,499
into 32-bit processes and what we needed

175
00:07:30,499 --> 00:07:31,909
in the course of this research is

176
00:07:31,909 --> 00:07:33,379
something a little bit more unique and

177
00:07:33,379 --> 00:07:35,479
is basically the ability to inject

178
00:07:35,479 --> 00:07:38,689
64-bit DLL into valve 1264 processes

179
00:07:38,689 --> 00:07:40,969
which just like Alden said they are

180
00:07:40,969 --> 00:07:43,490
effectively 32-bit processes so not

181
00:07:43,490 --> 00:07:45,259
every inject the Methodist capable of

182
00:07:45,259 --> 00:07:48,860
doing Greece okay in the course of this

183
00:07:48,860 --> 00:07:51,559
talk we are going to describe three

184
00:07:51,559 --> 00:07:53,209
relatively known methods which are

185
00:07:53,209 --> 00:07:55,279
capable of injecting 64-bit errors in

186
00:07:55,279 --> 00:07:58,069
1264 processes and we will start with

187
00:07:58,069 --> 00:07:59,749
the relatively easy stuff and gradually

188
00:07:59,749 --> 00:08:01,279
work our way through to more complicated

189
00:08:01,279 --> 00:08:03,229
their techniques and we will conclude

190
00:08:03,229 --> 00:08:04,939
this part by talking about the technique

191
00:08:04,939 --> 00:08:07,369
called injection via a PC and we will

192
00:08:07,369 --> 00:08:08,659
see that while this technique works

193
00:08:08,659 --> 00:08:10,129
great on some of the older Windows

194
00:08:10,129 --> 00:08:11,990
platforms it would probably break when

195
00:08:11,990 --> 00:08:13,759
you try to run it in more modern systems

196
00:08:13,759 --> 00:08:15,469
so after we will get a firm

197
00:08:15,469 --> 00:08:16,669
understanding of why this failure

198
00:08:16,669 --> 00:08:19,219
happens we will be able to present two

199
00:08:19,219 --> 00:08:21,079
new variations developed by us during

200
00:08:21,079 --> 00:08:22,610
the course of this research which

201
00:08:22,610 --> 00:08:24,349
basically allows a PC injection to

202
00:08:24,349 --> 00:08:26,329
function correctly even on the latest

203
00:08:26,329 --> 00:08:29,509
release of Windows 10 for example so

204
00:08:29,509 --> 00:08:31,249
let's start with the easy stuff so the

205
00:08:31,249 --> 00:08:32,328
first technique we are going to talk

206
00:08:32,328 --> 00:08:34,490
about revolves around hijacking of a dll

207
00:08:34,490 --> 00:08:37,068
912 64 log and this technique was

208
00:08:37,068 --> 00:08:38,509
discovered several years ago by a

209
00:08:38,509 --> 00:08:40,578
security researcher named Wally dasa

210
00:08:40,578 --> 00:08:43,219
which I think he's a is opposed to the

211
00:08:43,219 --> 00:08:44,839
BDS movement but other than that is a

212
00:08:44,839 --> 00:08:50,720
pretty cool guy so yeah ok so what is

213
00:08:50,720 --> 00:08:52,730
this dll anyway and so whenever you

214
00:08:52,730 --> 00:08:54,709
launch a new of 64 process in the system

215
00:08:54,709 --> 00:08:57,230
an integral part of its initialization

216
00:08:57,230 --> 00:08:59,269
phase will try to look up and load the

217
00:08:59,269 --> 00:09:02,269
64-bit DLL name of 64 log directly from

218
00:09:02,269 --> 00:09:06,170
the system 32 directory and so what

219
00:09:06,170 --> 00:09:08,569
happens is this is that this DLL is not

220
00:09:08,569 --> 00:09:10,430
shipped as part of the standard Windows

221
00:09:10,430 --> 00:09:12,680
installation which makes us and many

222
00:09:12,680 --> 00:09:14,240
other security researchers believe that

223
00:09:14,240 --> 00:09:15,680
this dll is actually only used

224
00:09:15,680 --> 00:09:18,139
internally by Microsoft in order to aid

225
00:09:18,139 --> 00:09:20,180
debugging or diagnostics of 1264

226
00:09:20,180 --> 00:09:22,220
applications and in fact we can leverage

227
00:09:22,220 --> 00:09:23,990
the fact that this dll is not shipped in

228
00:09:23,990 --> 00:09:26,180
order to gain code injection and the way

229
00:09:26,180 --> 00:09:27,779
we do this is by simply

230
00:09:27,779 --> 00:09:30,389
waiting our DLL renaming it 1264 log

231
00:09:30,389 --> 00:09:32,519
making it export a specific set a

232
00:09:32,519 --> 00:09:34,050
function and then just dropping it to

233
00:09:34,050 --> 00:09:36,269
the system32 directory and once we have

234
00:09:36,269 --> 00:09:38,699
done so well the other will be like

235
00:09:38,699 --> 00:09:41,310
magically loaded into everyone 64 poses

236
00:09:41,310 --> 00:09:43,589
in the system thus we've gained our code

237
00:09:43,589 --> 00:09:46,980
injection so overall really easy and

238
00:09:46,980 --> 00:09:51,720
straightforward the DLL hijacking ok and

239
00:09:51,720 --> 00:09:53,220
the second technique we are going to

240
00:09:53,220 --> 00:09:55,350
talk about takes advantage of Heaven's

241
00:09:55,350 --> 00:09:57,449
Gate so if you recall not long ago we

242
00:09:57,449 --> 00:09:58,920
all then talked about Heaven's Gate and

243
00:09:58,920 --> 00:10:01,649
basically described it as a hook evasion

244
00:10:01,649 --> 00:10:03,600
technique which is used used mostly by

245
00:10:03,600 --> 00:10:05,509
malicious actors in order to bypass

246
00:10:05,509 --> 00:10:08,670
hooks inserted by security product but

247
00:10:08,670 --> 00:10:10,170
reality is sometimes a little bit more

248
00:10:10,170 --> 00:10:11,100
complex than that

249
00:10:11,100 --> 00:10:13,649
and there is usually a very fine line

250
00:10:13,649 --> 00:10:15,329
which separates Marvel from security

251
00:10:15,329 --> 00:10:17,370
products and I think this is one of the

252
00:10:17,370 --> 00:10:19,019
cases in which the very same technique

253
00:10:19,019 --> 00:10:20,730
can be beneficial for the attacker as

254
00:10:20,730 --> 00:10:22,709
well as the defender so with that in

255
00:10:22,709 --> 00:10:24,449
mind let's see how an AV for example

256
00:10:24,449 --> 00:10:27,360
might benefit from Heaven's Gate so what

257
00:10:27,360 --> 00:10:29,730
we should know is that every one 64

258
00:10:29,730 --> 00:10:31,680
process has in it two distinct image

259
00:10:31,680 --> 00:10:34,529
low-dose 1 implementing the 32-bit until

260
00:10:34,529 --> 00:10:35,910
the other which can only load additional

261
00:10:35,910 --> 00:10:38,189
32-bit images and another one

262
00:10:38,189 --> 00:10:39,959
implemented in the 64-bit entity error

263
00:10:39,959 --> 00:10:42,000
which can only load additional 64-bit

264
00:10:42,000 --> 00:10:44,040
images now for the sake of argument

265
00:10:44,040 --> 00:10:46,290
let's assume that we already have 32-bit

266
00:10:46,290 --> 00:10:48,079
code running inside the target process

267
00:10:48,079 --> 00:10:50,009
again if we're talking about the

268
00:10:50,009 --> 00:10:52,079
security solution such as an AV this is

269
00:10:52,079 --> 00:10:54,500
a valid assumption which usually holds

270
00:10:54,500 --> 00:10:57,720
so this 32-bit code normally can only

271
00:10:57,720 --> 00:10:59,759
access the 32-bit image image loader

272
00:10:59,759 --> 00:11:01,620
which isn't really getting us anywhere

273
00:11:01,620 --> 00:11:03,449
because we can't use it to load our

274
00:11:03,449 --> 00:11:06,089
desired 64-bit payload but what is

275
00:11:06,089 --> 00:11:08,309
32-bit code can do is to use techniques

276
00:11:08,309 --> 00:11:09,870
such as seventh gate in order to

277
00:11:09,870 --> 00:11:12,120
transition itself into 64-bit mode and

278
00:11:12,120 --> 00:11:14,370
once it's done so it basically opens up

279
00:11:14,370 --> 00:11:16,230
the possibility of using the 64-bit

280
00:11:16,230 --> 00:11:18,300
loader for example by calling the 64-bit

281
00:11:18,300 --> 00:11:20,429
version of a function called LDR load

282
00:11:20,429 --> 00:11:22,379
DLL and we can use this function to load

283
00:11:22,379 --> 00:11:25,379
our desired payload so to summarize we

284
00:11:25,379 --> 00:11:26,370
are talking about the two phase

285
00:11:26,370 --> 00:11:27,929
injection method here in which in the

286
00:11:27,929 --> 00:11:30,089
first phase we inject a 32-bit dealer

287
00:11:30,089 --> 00:11:32,610
use this dll to transition into 64-bit

288
00:11:32,610 --> 00:11:36,959
mode and then load our 64-bit additional

289
00:11:36,959 --> 00:11:40,319
64-bit a dealer ok the third and last

290
00:11:40,319 --> 00:11:41,610
injection method

291
00:11:41,610 --> 00:11:42,990
to describe is something called an

292
00:11:42,990 --> 00:11:45,300
injection via a PC so before we dive

293
00:11:45,300 --> 00:11:47,100
into all of the nitty-gritty details of

294
00:11:47,100 --> 00:11:48,269
how this injection is actually

295
00:11:48,269 --> 00:11:50,430
implemented a couple of thoughts about a

296
00:11:50,430 --> 00:11:52,769
pcs in general are usually in place so

297
00:11:52,769 --> 00:11:54,390
an APC is an acronym which stands for

298
00:11:54,390 --> 00:11:56,640
asynchronous procedural call and it's

299
00:11:56,640 --> 00:11:58,320
basically a mechanism built into the

300
00:11:58,320 --> 00:12:00,329
Windows kernel which allows us to take a

301
00:12:00,329 --> 00:12:02,130
particular routine and then queue it to

302
00:12:02,130 --> 00:12:03,899
a thread of our choice and what is

303
00:12:03,899 --> 00:12:05,640
mechanism guarantees is that at some

304
00:12:05,640 --> 00:12:07,620
point in the future the target thread

305
00:12:07,620 --> 00:12:09,420
will stop whatever it is currently doing

306
00:12:09,420 --> 00:12:14,220
and execute our routine instead so in

307
00:12:14,220 --> 00:12:15,870
Windows a PCS come in several flavors

308
00:12:15,870 --> 00:12:17,940
and in the course of this talk we're

309
00:12:17,940 --> 00:12:20,040
only going to describe one specific kind

310
00:12:20,040 --> 00:12:23,010
called user mode a PCS user mode a pcs

311
00:12:23,010 --> 00:12:24,779
have some distinct characteristics to

312
00:12:24,779 --> 00:12:28,350
them first and foremost the code that is

313
00:12:28,350 --> 00:12:31,620
about going to run the target of the APC

314
00:12:31,620 --> 00:12:33,720
will run with user mode permissions

315
00:12:33,720 --> 00:12:36,450
unlike kernel mode permissions the

316
00:12:36,450 --> 00:12:38,610
second one is that the APC itself will

317
00:12:38,610 --> 00:12:40,920
only fire or trigger once the target

318
00:12:40,920 --> 00:12:42,570
thread enters something called an alert

319
00:12:42,570 --> 00:12:44,070
able wait state that happens for example

320
00:12:44,070 --> 00:12:46,320
when the thread goes to sleep wait for

321
00:12:46,320 --> 00:12:47,910
synchronization object something like

322
00:12:47,910 --> 00:12:50,190
that and the third key point to notice

323
00:12:50,190 --> 00:12:54,329
is that all user mode a pieces are

324
00:12:54,329 --> 00:12:56,970
handled by one single function called K

325
00:12:56,970 --> 00:12:59,310
IPC dispatcher which is exported from

326
00:12:59,310 --> 00:13:01,649
ntdll so this function will basically

327
00:13:01,649 --> 00:13:03,540
make several preparations and then we

328
00:13:03,540 --> 00:13:05,850
just follow the call to the real target

329
00:13:05,850 --> 00:13:07,800
of the APC which the programmer intended

330
00:13:07,800 --> 00:13:10,980
to call yeah an AP C's can be cute both

331
00:13:10,980 --> 00:13:12,899
from user mode and from camera mode we

332
00:13:12,899 --> 00:13:14,130
are going to use the kernel mode

333
00:13:14,130 --> 00:13:17,100
variation and yeah so now let's talk

334
00:13:17,100 --> 00:13:19,199
about injection so injection via a PC is

335
00:13:19,199 --> 00:13:20,790
probably the most popular injection

336
00:13:20,790 --> 00:13:23,550
method used by AV solutions as well by

337
00:13:23,550 --> 00:13:25,260
some intelligence agencies as you can

338
00:13:25,260 --> 00:13:27,329
see and they basically do this by

339
00:13:27,329 --> 00:13:30,060
queuing in a PC which ultimately calls

340
00:13:30,060 --> 00:13:32,550
either LD all of the ll overload library

341
00:13:32,550 --> 00:13:34,949
or one of its variants and most of them

342
00:13:34,949 --> 00:13:36,449
use this technique to inject the DLL

343
00:13:36,449 --> 00:13:37,769
which has the same business as the

344
00:13:37,769 --> 00:13:39,570
target process but what we should keep

345
00:13:39,570 --> 00:13:42,660
in mind is that in one 64 process a pcs

346
00:13:42,660 --> 00:13:45,480
can run both 32-bit code or 64-bit code

347
00:13:45,480 --> 00:13:48,959
and in some cases for example when we

348
00:13:48,959 --> 00:13:51,149
cue our IPC from kernel ma driver and

349
00:13:51,149 --> 00:13:53,850
the default will be to 118 64-bit mode

350
00:13:53,850 --> 00:13:55,860
so that makes them

351
00:13:55,860 --> 00:13:57,540
great candidate for loading additional

352
00:13:57,540 --> 00:14:01,680
64-bit the errors okay what we can see

353
00:14:01,680 --> 00:14:04,290
here is some kernel mode code which

354
00:14:04,290 --> 00:14:06,600
implements this technique can Ahmad

355
00:14:06,600 --> 00:14:09,240
inject injection of DLS from the kernel

356
00:14:09,240 --> 00:14:12,000
mode rival so several key takeaways from

357
00:14:12,000 --> 00:14:15,330
this slide first of all the target of

358
00:14:15,330 --> 00:14:17,010
the APC the function which executes in

359
00:14:17,010 --> 00:14:17,970
the context of an APC

360
00:14:17,970 --> 00:14:20,370
must conform to a standard prototype

361
00:14:20,370 --> 00:14:22,830
which was predefined by Microsoft so as

362
00:14:22,830 --> 00:14:24,630
you can see all of these functions must

363
00:14:24,630 --> 00:14:27,060
return void and receive free pointers as

364
00:14:27,060 --> 00:14:29,730
their input arguments now this raises

365
00:14:29,730 --> 00:14:31,860
the question what happens if the

366
00:14:31,860 --> 00:14:33,690
function that I wish to call has a

367
00:14:33,690 --> 00:14:35,880
different prototype so to overcome this

368
00:14:35,880 --> 00:14:38,400
problem we use some some sort of a trick

369
00:14:38,400 --> 00:14:40,890
and the trick basically says that we use

370
00:14:40,890 --> 00:14:42,540
the first parameter the normal context

371
00:14:42,540 --> 00:14:44,610
parameter to pass in a user-defined

372
00:14:44,610 --> 00:14:46,740
structure and inside the structure we

373
00:14:46,740 --> 00:14:49,260
can encapsulate both the address of the

374
00:14:49,260 --> 00:14:50,820
function that I really wish to call as

375
00:14:50,820 --> 00:14:52,410
well as the values of all the parameters

376
00:14:52,410 --> 00:14:54,510
that I wish to forward into it so in our

377
00:14:54,510 --> 00:14:55,680
case because we are dealing with

378
00:14:55,680 --> 00:14:57,540
injectors we are going to pass the

379
00:14:57,540 --> 00:14:59,490
address of the 64-bit version of LD all

380
00:14:59,490 --> 00:15:01,500
of the error as well as the name of the

381
00:15:01,500 --> 00:15:04,529
dll that we wish to inject so if you

382
00:15:04,529 --> 00:15:06,420
take a closer look at this function in

383
00:15:06,420 --> 00:15:08,339
its entirely you can see that it

384
00:15:08,339 --> 00:15:10,170
basically just translates one function

385
00:15:10,170 --> 00:15:12,690
prototype into another and this is the

386
00:15:12,690 --> 00:15:14,190
reason we chose to term it an adapter

387
00:15:14,190 --> 00:15:16,080
func this is not an official terminology

388
00:15:16,080 --> 00:15:18,000
of any kind but this is the term that we

389
00:15:18,000 --> 00:15:19,200
are going to use for the rest of the

390
00:15:19,200 --> 00:15:21,600
talk so keep that in mind and now

391
00:15:21,600 --> 00:15:23,310
because the type of the APC we're using

392
00:15:23,310 --> 00:15:25,890
is a user mode APC the adapter func

393
00:15:25,890 --> 00:15:27,510
itself must reside in memory which is

394
00:15:27,510 --> 00:15:29,700
accessible to user mode in order to make

395
00:15:29,700 --> 00:15:31,770
sure it does we first have to allocate a

396
00:15:31,770 --> 00:15:33,029
user mode buffer which is both

397
00:15:33,029 --> 00:15:35,820
executable as well suitable and after

398
00:15:35,820 --> 00:15:37,500
we've done so we can simply copy into

399
00:15:37,500 --> 00:15:39,480
this buffer the actual code bytes which

400
00:15:39,480 --> 00:15:42,630
comprise the adapter func after we do

401
00:15:42,630 --> 00:15:44,459
this we can simply initialize a user

402
00:15:44,459 --> 00:15:46,230
mode APC which points to the buffer we

403
00:15:46,230 --> 00:15:49,260
have allocated and queue it to the APC

404
00:15:49,260 --> 00:15:51,660
queue of the target file we can repeat

405
00:15:51,660 --> 00:15:53,610
this entire procedure for every a newly

406
00:15:53,610 --> 00:15:55,980
created web 64's run in the system and

407
00:15:55,980 --> 00:15:57,779
because we know that every thread

408
00:15:57,779 --> 00:15:59,520
empties its APC queue as part of

409
00:15:59,520 --> 00:16:02,100
standard for initialization this

410
00:16:02,100 --> 00:16:03,720
basically guarantees that our dll will

411
00:16:03,720 --> 00:16:05,760
be ultimately loaded into every 164

412
00:16:05,760 --> 00:16:08,700
process in the system and so what we did

413
00:16:08,700 --> 00:16:09,430
is

414
00:16:09,430 --> 00:16:11,740
we have taken the source code that I've

415
00:16:11,740 --> 00:16:13,870
just shown you compiled it into a driver

416
00:16:13,870 --> 00:16:16,030
loaded it into a Windows 7 system and

417
00:16:16,030 --> 00:16:17,860
indeed as you can see the injection

418
00:16:17,860 --> 00:16:19,330
walked this plan we have a 32-bit

419
00:16:19,330 --> 00:16:22,150
notepad X the process which loaded our

420
00:16:22,150 --> 00:16:26,800
64-bit the other and ok so after some

421
00:16:26,800 --> 00:16:28,810
time one of the one of us said it would

422
00:16:28,810 --> 00:16:30,700
be like a good idea to test the same

423
00:16:30,700 --> 00:16:33,490
solution on some more recent Windows

424
00:16:33,490 --> 00:16:36,430
platforms so we decided to test it on

425
00:16:36,430 --> 00:16:37,780
Windows 10 and then we got some very

426
00:16:37,780 --> 00:16:40,090
different results what we found out is

427
00:16:40,090 --> 00:16:41,590
that most processes to which we try to

428
00:16:41,590 --> 00:16:44,950
inject our the other simply crashed so

429
00:16:44,950 --> 00:16:46,510
after a little bit of probing on Twitter

430
00:16:46,510 --> 00:16:48,460
we bumped into this twit you can see

431
00:16:48,460 --> 00:16:50,710
here from Alex ionesco and from this to

432
00:16:50,710 --> 00:16:52,780
it we learned like took effect the first

433
00:16:52,780 --> 00:16:56,080
one is that he encountered probably the

434
00:16:56,080 --> 00:16:58,570
very same problem just something like I

435
00:16:58,570 --> 00:16:59,980
don't know to an air-filled before us

436
00:16:59,980 --> 00:17:02,290
and the second one is that the crash

437
00:17:02,290 --> 00:17:04,930
probably relates to CFG so before we can

438
00:17:04,930 --> 00:17:06,400
start thinking about possible solutions

439
00:17:06,400 --> 00:17:07,599
to the problem we first have to

440
00:17:07,599 --> 00:17:09,940
understand what zfg is what are its

441
00:17:09,940 --> 00:17:11,920
implications on the system and how it is

442
00:17:11,920 --> 00:17:15,360
related to well 64

443
00:17:18,409 --> 00:17:22,980
so CFG is an acronym for a control flow

444
00:17:22,980 --> 00:17:25,579
guard it's a relatively new

445
00:17:25,579 --> 00:17:27,269
experimentation technique first

446
00:17:27,269 --> 00:17:29,639
introduced by Microsoft in Windows 8.1

447
00:17:29,639 --> 00:17:33,299
and later enhanced in Windows 10 its

448
00:17:33,299 --> 00:17:35,460
features it's meant that is meant to

449
00:17:35,460 --> 00:17:37,009
combat memory corruption vulnerabilities

450
00:17:37,009 --> 00:17:40,799
by preventing indirect calls to non

451
00:17:40,799 --> 00:17:42,990
legitimate call targets such a compiler

452
00:17:42,990 --> 00:17:44,190
enabled mitigation

453
00:17:44,190 --> 00:17:46,940
it works by inserting an additional call

454
00:17:46,940 --> 00:17:49,619
before every indirect call into a

455
00:17:49,619 --> 00:17:51,299
validation routine this validation

456
00:17:51,299 --> 00:17:52,950
routine receives the address that is

457
00:17:52,950 --> 00:17:53,999
about to be called in the interactive

458
00:17:53,999 --> 00:17:56,490
and checks whether it's a legitimate

459
00:17:56,490 --> 00:17:59,009
call target or not if it is the function

460
00:17:59,009 --> 00:18:00,480
returns and the execution continues

461
00:18:00,480 --> 00:18:03,059
normally if the function decides that

462
00:18:03,059 --> 00:18:04,950
the address does not make of alcohol

463
00:18:04,950 --> 00:18:09,259
target then it will crash the process

464
00:18:09,649 --> 00:18:13,169
what are these val call targets for

465
00:18:13,169 --> 00:18:15,509
images these are defined as start

466
00:18:15,509 --> 00:18:17,309
addresses of functions every image

467
00:18:17,309 --> 00:18:20,009
compared with CFG exports a list of its

468
00:18:20,009 --> 00:18:21,690
functions and whether each of them makes

469
00:18:21,690 --> 00:18:24,809
of alcohol target or not the for private

470
00:18:24,809 --> 00:18:26,580
memory allocations we don't have a list

471
00:18:26,580 --> 00:18:28,769
of where the functions are so this

472
00:18:28,769 --> 00:18:31,220
system just marks the whole buffer as

473
00:18:31,220 --> 00:18:36,419
valid colt idea just to be safe these

474
00:18:36,419 --> 00:18:39,360
whenever new executive memory is

475
00:18:39,360 --> 00:18:41,029
introduced into a process the system

476
00:18:41,029 --> 00:18:47,639
marks the marks which parts of the

477
00:18:47,639 --> 00:18:50,009
process make of out call target to do

478
00:18:50,009 --> 00:18:54,119
that we have a new memory area inside

479
00:18:54,119 --> 00:18:56,610
inside the process called a CFG bitmap

480
00:18:56,610 --> 00:18:59,429
this is a relatively large memory area

481
00:18:59,429 --> 00:19:02,369
where each bit marks eight bytes in the

482
00:19:02,369 --> 00:19:04,409
process address space and shows me

483
00:19:04,409 --> 00:19:05,970
whether these eight bytes make of

484
00:19:05,970 --> 00:19:08,490
alcohol target or not the validation

485
00:19:08,490 --> 00:19:12,029
routine checks this safety bitmap for

486
00:19:12,029 --> 00:19:14,249
each address it receives to see whether

487
00:19:14,249 --> 00:19:16,799
it's about call target now let's take a

488
00:19:16,799 --> 00:19:20,580
look at this validation 15 M this is l

489
00:19:20,580 --> 00:19:22,950
dfp validate user call target a function

490
00:19:22,950 --> 00:19:25,230
found inside of ntdll and i say it

491
00:19:25,230 --> 00:19:27,119
receives the address it is about to be

492
00:19:27,119 --> 00:19:29,220
called indirectly and makes the rate

493
00:19:29,220 --> 00:19:30,990
calculations required to see

494
00:19:30,990 --> 00:19:33,030
to find the beat in safety bitmap that

495
00:19:33,030 --> 00:19:36,000
marks this address if the bit is set

496
00:19:36,000 --> 00:19:37,830
meaning this address is a valid call

497
00:19:37,830 --> 00:19:40,470
target we take the left branch and the

498
00:19:40,470 --> 00:19:42,510
function returns if the bit is not set

499
00:19:42,510 --> 00:19:44,580
it means that the address is not a valid

500
00:19:44,580 --> 00:19:46,140
call target so it takes the right branch

501
00:19:46,140 --> 00:19:48,270
which will eventually cross the process

502
00:19:48,270 --> 00:19:50,940
and result in this cords call stack that

503
00:19:50,940 --> 00:19:52,470
we took from our crash dump in Windows

504
00:19:52,470 --> 00:19:57,390
10 now on all 64 processes CFG gets a

505
00:19:57,390 --> 00:19:58,830
tiny bit more complicated

506
00:19:58,830 --> 00:20:02,340
while 64 processes host both 32-bit code

507
00:20:02,340 --> 00:20:05,250
and 64-bit code so we also have to

508
00:20:05,250 --> 00:20:08,130
safety bitmaps native CFG bitmap that

509
00:20:08,130 --> 00:20:11,010
mark 64-bit code in the process and our

510
00:20:11,010 --> 00:20:14,160
64-bit map that marks 32-bit code as you

511
00:20:14,160 --> 00:20:16,140
might remember these processes also have

512
00:20:16,140 --> 00:20:18,900
two versions of anti DLL a 32-bit and

513
00:20:18,900 --> 00:20:21,840
64-bit one so this works nicely with the

514
00:20:21,840 --> 00:20:23,250
to safety bitmaps

515
00:20:23,250 --> 00:20:26,040
the validation routine in the 64-bit

516
00:20:26,040 --> 00:20:28,740
ntdll and checks addresses against

517
00:20:28,740 --> 00:20:31,679
native bitmap and invalidation routine

518
00:20:31,679 --> 00:20:33,780
32-bit ntdll checks addresses against

519
00:20:33,780 --> 00:20:36,660
the our 64 bit map a new the cuticle

520
00:20:36,660 --> 00:20:38,580
memory introduced into these processors

521
00:20:38,580 --> 00:20:40,530
only gets marked in one of these two

522
00:20:40,530 --> 00:20:42,840
bitmaps so how does this system make the

523
00:20:42,840 --> 00:20:45,270
decision of which bitmap to Mark's new

524
00:20:45,270 --> 00:20:47,309
addresses in with that we have the

525
00:20:47,309 --> 00:20:49,710
kernel function mi select CFG bitmap

526
00:20:49,710 --> 00:20:51,690
which gets called whenever a new memo

527
00:20:51,690 --> 00:20:55,440
new executive memory is introduced it it

528
00:20:55,440 --> 00:20:58,170
chooses the correct safety bitmap to

529
00:20:58,170 --> 00:21:00,210
mark this memory in based on a few

530
00:21:00,210 --> 00:21:03,210
simple checks first the process has to

531
00:21:03,210 --> 00:21:05,790
actually be about 64 process if it's a

532
00:21:05,790 --> 00:21:08,460
native process we should only have a

533
00:21:08,460 --> 00:21:10,710
single native CFG bitmap so we'll only

534
00:21:10,710 --> 00:21:13,110
so will always choose that one then if

535
00:21:13,110 --> 00:21:15,450
the process is our 64 one which app

536
00:21:15,450 --> 00:21:17,640
whether the address is above or below a

537
00:21:17,640 --> 00:21:20,070
four gigabytes if the address is above

538
00:21:20,070 --> 00:21:21,660
four gigabytes it will get marked in the

539
00:21:21,660 --> 00:21:23,820
native safety bitmap but that shouldn't

540
00:21:23,820 --> 00:21:25,920
happen very often because in one 64

541
00:21:25,920 --> 00:21:30,000
processes the whole a memory above 4

542
00:21:30,000 --> 00:21:31,650
gigabytes is actually reserved and we

543
00:21:31,650 --> 00:21:33,630
can't allocate it or access it so this

544
00:21:33,630 --> 00:21:36,990
check should almost always be true then

545
00:21:36,990 --> 00:21:39,840
the final check is whether this memory

546
00:21:39,840 --> 00:21:40,800
is

547
00:21:40,800 --> 00:21:43,650
relocation or a part of an image if this

548
00:21:43,650 --> 00:21:46,280
segment parameter is null meaning the

549
00:21:46,280 --> 00:21:49,050
memory is part of a private memory

550
00:21:49,050 --> 00:21:51,810
location and in that case it will always

551
00:21:51,810 --> 00:21:55,440
get marked in v1 64 CFG bitmap if this

552
00:21:55,440 --> 00:21:57,330
memory is part of an image the function

553
00:21:57,330 --> 00:21:58,860
checks whether it's a 32-bit or 64-bit

554
00:21:58,860 --> 00:22:01,290
image and chooses the bitmap accordingly

555
00:22:01,290 --> 00:22:04,320
now how does that all relate to our

556
00:22:04,320 --> 00:22:08,070
problem I'm our problem was that we

557
00:22:08,070 --> 00:22:11,040
tried to inject our DLL using an EPC

558
00:22:11,040 --> 00:22:13,950
injector we actually managed to puree PC

559
00:22:13,950 --> 00:22:17,580
successfully to pro 1264 processes but

560
00:22:17,580 --> 00:22:21,210
we took a look at our crash dump and saw

561
00:22:21,210 --> 00:22:23,850
that we got two queries or EPC

562
00:22:23,850 --> 00:22:25,320
dispatcher the function that should

563
00:22:25,320 --> 00:22:28,860
dispatch or a PC and call our APC target

564
00:22:28,860 --> 00:22:30,780
but before it managed to call our

565
00:22:30,780 --> 00:22:32,790
adapter thunk this function checked

566
00:22:32,790 --> 00:22:35,880
whether it's a valid or invalid call

567
00:22:35,880 --> 00:22:38,310
Tania decided that it's an invalid call

568
00:22:38,310 --> 00:22:41,550
target and crashed our processes but why

569
00:22:41,550 --> 00:22:44,070
did that happen as you might recall with

570
00:22:44,070 --> 00:22:46,110
Sony my select safety bitmap that all

571
00:22:46,110 --> 00:22:48,300
private memory locations below four

572
00:22:48,300 --> 00:22:50,670
gigabytes inside of all 64 processes are

573
00:22:50,670 --> 00:22:54,090
marked in V was 64 safety bitmap now the

574
00:22:54,090 --> 00:22:56,520
function that should handle our APC is

575
00:22:56,520 --> 00:22:59,460
the 64 bit ki user a PCB structure found

576
00:22:59,460 --> 00:23:02,550
in 64-bit ntdll so our validation

577
00:23:02,550 --> 00:23:04,410
routine tested the address against the

578
00:23:04,410 --> 00:23:06,930
native safety bitmap because our

579
00:23:06,930 --> 00:23:09,300
adapters and is marked in v1 64 and not

580
00:23:09,300 --> 00:23:11,460
the native safety bitmap this caused our

581
00:23:11,460 --> 00:23:14,850
processes to crash it seems like a dead

582
00:23:14,850 --> 00:23:16,530
end but we didn't want to give up on our

583
00:23:16,530 --> 00:23:18,330
APC injector just yet kind of liked it

584
00:23:18,330 --> 00:23:20,670
so we tried looking for a solution to

585
00:23:20,670 --> 00:23:22,920
our problem and in this case I'll do

586
00:23:22,920 --> 00:23:25,560
what I usually do in such cases and ask

587
00:23:25,560 --> 00:23:28,550
us after solve a problem

588
00:23:28,910 --> 00:23:31,700
thank you

589
00:23:31,700 --> 00:23:36,540
okay so in order to fix our IPC injector

590
00:23:36,540 --> 00:23:39,210
we must somehow make the adaptil func

591
00:23:39,210 --> 00:23:42,300
occupy the native CFG bitmap so we took

592
00:23:42,300 --> 00:23:44,130
another look at em I select CFG bitmap

593
00:23:44,130 --> 00:23:46,530
and started to see what we can do about

594
00:23:46,530 --> 00:23:49,140
it so what we realize is that all we

595
00:23:49,140 --> 00:23:50,880
need to do is to make one of the sub

596
00:23:50,880 --> 00:23:52,590
conditions inside the if statement

597
00:23:52,590 --> 00:23:54,539
evaluate to false

598
00:23:54,539 --> 00:23:57,299
so at first we decided to tackle the

599
00:23:57,299 --> 00:23:59,519
first sub condition because it seemed

600
00:23:59,519 --> 00:24:02,369
like the easiest one to manipulate so

601
00:24:02,369 --> 00:24:03,899
the first sub condition actually checks

602
00:24:03,899 --> 00:24:06,299
whether or not the comment process is a

603
00:24:06,299 --> 00:24:10,320
native 64-bit process so it basically

604
00:24:10,320 --> 00:24:13,529
does this does this by probing the 1264

605
00:24:13,529 --> 00:24:15,449
process member of the relevant it was a

606
00:24:15,449 --> 00:24:17,879
structure if this pointer is set to null

607
00:24:17,879 --> 00:24:19,529
the kernel thinks the process is a

608
00:24:19,529 --> 00:24:21,599
native 64-bit process otherwise it is

609
00:24:21,599 --> 00:24:24,929
splitted as 1264 process so with that in

610
00:24:24,929 --> 00:24:26,909
mind we came into some sort of a

611
00:24:26,909 --> 00:24:29,099
solution in which right before we

612
00:24:29,099 --> 00:24:31,079
allocate member with our adapter func we

613
00:24:31,079 --> 00:24:33,899
simply go into this pointer and zero it

614
00:24:33,899 --> 00:24:36,419
out or nullified and this will basically

615
00:24:36,419 --> 00:24:39,299
make mi selective G bitmap it will trick

616
00:24:39,299 --> 00:24:40,709
it into thinking that we are allocating

617
00:24:40,709 --> 00:24:43,349
private executable memory in a native

618
00:24:43,349 --> 00:24:45,690
64-bit process and thus our adapter func

619
00:24:45,690 --> 00:24:47,489
will be marked in the native CFG bitmap

620
00:24:47,489 --> 00:24:50,009
of course that after memory so the

621
00:24:50,009 --> 00:24:51,509
adapter func has been allocated we

622
00:24:51,509 --> 00:24:52,859
should restore the original value of

623
00:24:52,859 --> 00:24:54,719
this pointer otherwise bad things might

624
00:24:54,719 --> 00:24:57,749
happen so to summarize this technique

625
00:24:57,749 --> 00:25:00,209
basically works by temporarily native

626
00:25:00,209 --> 00:25:03,479
eyes in 164 process and while it does do

627
00:25:03,479 --> 00:25:05,459
the trick it suffers from some serious

628
00:25:05,459 --> 00:25:07,649
downsides for mainly because they pose a

629
00:25:07,649 --> 00:25:09,809
structure that has to be modified is

630
00:25:09,809 --> 00:25:11,789
largely undocumented and changes often

631
00:25:11,789 --> 00:25:14,459
between Windows releases and so we try

632
00:25:14,459 --> 00:25:15,809
to look up for an alternative solution

633
00:25:15,809 --> 00:25:17,819
and preferably one which doesn't require

634
00:25:17,819 --> 00:25:19,799
making modifications to undocumented

635
00:25:19,799 --> 00:25:24,809
counter structures so at this point we

636
00:25:24,809 --> 00:25:26,969
decided like to mentally zoom out and

637
00:25:26,969 --> 00:25:28,949
really think about our problem in the

638
00:25:28,949 --> 00:25:31,469
first place so our problem is caused by

639
00:25:31,469 --> 00:25:33,359
the fact that our IPC injector uses an

640
00:25:33,359 --> 00:25:35,309
adaptive func and we know that since the

641
00:25:35,309 --> 00:25:36,690
adaptil func is a private memory

642
00:25:36,690 --> 00:25:38,459
allocation it will be marked in the well

643
00:25:38,459 --> 00:25:41,519
64 CFG bitmap now if you recall the only

644
00:25:41,519 --> 00:25:42,869
reason we have an adapter func in the

645
00:25:42,869 --> 00:25:45,389
first place is basically to act as a

646
00:25:45,389 --> 00:25:47,669
middleman which just forwards calls to

647
00:25:47,669 --> 00:25:49,619
the 64-bit version of El Diablo DLL and

648
00:25:49,619 --> 00:25:51,509
we know that the 64-bit version of El

649
00:25:51,509 --> 00:25:55,139
Diablo DLL is marked in the native CFG

650
00:25:55,139 --> 00:25:55,589
bitmap

651
00:25:55,589 --> 00:25:58,440
so this made us wonder why do we need an

652
00:25:58,440 --> 00:25:59,999
adapter func at all or to put it in

653
00:25:59,999 --> 00:26:01,919
other words why can't we just initialize

654
00:26:01,919 --> 00:26:04,909
our APC to call el Diablo dll directly

655
00:26:04,909 --> 00:26:07,379
so on the surface of it it looks like we

656
00:26:07,379 --> 00:26:08,190
have some sort of

657
00:26:08,190 --> 00:26:10,080
problem on the right-hand side you can

658
00:26:10,080 --> 00:26:12,090
see the common function prototype which

659
00:26:12,090 --> 00:26:14,190
is which is shared by all user mode a PC

660
00:26:14,190 --> 00:26:16,110
routines we have seen this one before

661
00:26:16,110 --> 00:26:19,769
and like I said all of these functions

662
00:26:19,769 --> 00:26:21,450
receive free pointers as their input

663
00:26:21,450 --> 00:26:23,460
arguments and on the left hand side we

664
00:26:23,460 --> 00:26:25,379
can see the prototype of El Diablo DLL

665
00:26:25,379 --> 00:26:28,769
which happens to accept expect four

666
00:26:28,769 --> 00:26:30,899
arguments and so at the very least we

667
00:26:30,899 --> 00:26:32,159
have you know some sort of a function

668
00:26:32,159 --> 00:26:35,129
prototyping consistency issue and so

669
00:26:35,129 --> 00:26:36,480
does this mean we have reached the dead

670
00:26:36,480 --> 00:26:37,070
end

671
00:26:37,070 --> 00:26:39,840
not yet and what might actually work in

672
00:26:39,840 --> 00:26:42,419
our favor is is the x64 calling

673
00:26:42,419 --> 00:26:44,490
convention and like some of you might

674
00:26:44,490 --> 00:26:46,710
know already in x64 almost every

675
00:26:46,710 --> 00:26:48,090
function received its first four

676
00:26:48,090 --> 00:26:50,279
arguments we are registers the first

677
00:26:50,279 --> 00:26:52,230
argument is passed in the r6 like easter

678
00:26:52,230 --> 00:26:54,659
the second one in our DX the third in r8

679
00:26:54,659 --> 00:26:58,169
and the fourth one in our nine so that

680
00:26:58,169 --> 00:27:00,750
means that if we for example we

681
00:27:00,750 --> 00:27:02,610
initialize an APC which directly calls

682
00:27:02,610 --> 00:27:04,590
El Diablo dealer we will have direct

683
00:27:04,590 --> 00:27:06,690
control over the values of the first

684
00:27:06,690 --> 00:27:09,419
three arguments unfortunately we won't

685
00:27:09,419 --> 00:27:11,370
have any direct control over the value

686
00:27:11,370 --> 00:27:13,710
of the fourth parameter and what will

687
00:27:13,710 --> 00:27:15,570
happen is that by the time al Diablo the

688
00:27:15,570 --> 00:27:17,580
error will be called whatever whatever

689
00:27:17,580 --> 00:27:19,500
value happens to be loaded into our nine

690
00:27:19,500 --> 00:27:21,480
at this very moment will be interpreted

691
00:27:21,480 --> 00:27:23,879
as the missing as the fourth so called

692
00:27:23,879 --> 00:27:27,299
the missing parameter so now let's take

693
00:27:27,299 --> 00:27:29,009
a closer look at a yellow dll and

694
00:27:29,009 --> 00:27:31,559
specifically at its off parameter so as

695
00:27:31,559 --> 00:27:33,210
you can see the fourth parameter is

696
00:27:33,210 --> 00:27:36,019
annotated as an output parameter and

697
00:27:36,019 --> 00:27:38,759
basically it's a pointer to which the

698
00:27:38,759 --> 00:27:40,440
function will write to the base address

699
00:27:40,440 --> 00:27:42,450
of the dll that it is just loaded and

700
00:27:42,450 --> 00:27:44,639
this actually makes things a little bit

701
00:27:44,639 --> 00:27:46,169
more complicated because it means that

702
00:27:46,169 --> 00:27:48,629
not any value loaded into our nine will

703
00:27:48,629 --> 00:27:52,230
suit our needs more specifically it

704
00:27:52,230 --> 00:27:54,000
means that our nine has to be a pointer

705
00:27:54,000 --> 00:27:55,830
to a writable memory location and

706
00:27:55,830 --> 00:27:57,659
moreover this memory location has to be

707
00:27:57,659 --> 00:27:59,429
some sort of a scratch space because we

708
00:27:59,429 --> 00:28:00,990
cannot overwrite important information

709
00:28:00,990 --> 00:28:04,080
in the process without risking in

710
00:28:04,080 --> 00:28:07,200
crashing so the million dollar question

711
00:28:07,200 --> 00:28:09,240
is what value will be held by our nine

712
00:28:09,240 --> 00:28:11,610
by the time L diallo dll gets called so

713
00:28:11,610 --> 00:28:13,470
in order to answer this question we had

714
00:28:13,470 --> 00:28:15,240
to perform some reverse engineering 1k

715
00:28:15,240 --> 00:28:17,820
with a PC dispatcher and indeed after

716
00:28:17,820 --> 00:28:20,340
some reversing what we found out is that

717
00:28:20,340 --> 00:28:22,050
right before ok

718
00:28:22,050 --> 00:28:24,450
we see the special for words the call to

719
00:28:24,450 --> 00:28:26,280
the target of the APC which again is a

720
00:28:26,280 --> 00:28:28,770
yellow DLL in our case it will load our

721
00:28:28,770 --> 00:28:30,630
line with a pointer to something called

722
00:28:30,630 --> 00:28:33,090
a context structure so what is this

723
00:28:33,090 --> 00:28:36,870
context Luxur it's basically a memory

724
00:28:36,870 --> 00:28:39,780
block which holds the CPU state that is

725
00:28:39,780 --> 00:28:42,420
about to be restored or resumed once the

726
00:28:42,420 --> 00:28:45,380
APC dispatching process has finished now

727
00:28:45,380 --> 00:28:48,780
like we've said LD allodial is going to

728
00:28:48,780 --> 00:28:50,250
interpolate our nine assets off

729
00:28:50,250 --> 00:28:52,620
parameter and this basically means it is

730
00:28:52,620 --> 00:28:54,750
going to overwrite the first eight bytes

731
00:28:54,750 --> 00:28:56,490
of the structure with the with the base

732
00:28:56,490 --> 00:28:58,110
address of the DLL it is loaded so

733
00:28:58,110 --> 00:28:59,850
generally this doesn't sound like a very

734
00:28:59,850 --> 00:29:01,620
good idea because we are basically

735
00:29:01,620 --> 00:29:03,630
overwriting saved CPU state that is

736
00:29:03,630 --> 00:29:04,940
about to be resumed

737
00:29:04,940 --> 00:29:08,780
so doesn't sound like a good idea but

738
00:29:08,780 --> 00:29:12,840
luckily for us in x64 the first few

739
00:29:12,840 --> 00:29:14,400
members of every context truck sure

740
00:29:14,400 --> 00:29:16,620
don't actually hold members which are

741
00:29:16,620 --> 00:29:18,840
CPU related as you can see all these p1

742
00:29:18,840 --> 00:29:21,000
home P to home and so on are not really

743
00:29:21,000 --> 00:29:24,450
CPU related and this basically means we

744
00:29:24,450 --> 00:29:26,190
can overwrite them safely because we

745
00:29:26,190 --> 00:29:28,680
know they want to be used later by by

746
00:29:28,680 --> 00:29:30,330
anti continue to actually restore the

747
00:29:30,330 --> 00:29:33,210
context so to summarize what we found

748
00:29:33,210 --> 00:29:35,100
out is that we can get rid of the

749
00:29:35,100 --> 00:29:36,750
adapter funk entirely and just

750
00:29:36,750 --> 00:29:38,640
initialize our IPC to point to a yellow

751
00:29:38,640 --> 00:29:42,330
DLL so we've modified our APC injector

752
00:29:42,330 --> 00:29:44,120
accordingly compiled it into a driver

753
00:29:44,120 --> 00:29:46,200
tested it this time on the Windows 10

754
00:29:46,200 --> 00:29:48,960
machine and as you can see here this

755
00:29:48,960 --> 00:29:50,940
time it worked we managed to inject our

756
00:29:50,940 --> 00:29:54,540
64 bit DLL 21264 process which is safe

757
00:29:54,540 --> 00:29:56,960
GL

758
00:30:01,700 --> 00:30:04,470
so now that we have a working injection

759
00:30:04,470 --> 00:30:06,750
method or like three and a half we can

760
00:30:06,750 --> 00:30:08,460
move on to the second part of this

761
00:30:08,460 --> 00:30:11,790
project which is the hooking we actually

762
00:30:11,790 --> 00:30:13,680
start this project by wanting to hook

763
00:30:13,680 --> 00:30:16,830
64-bit API functions inside of our 64

764
00:30:16,830 --> 00:30:19,350
processes so to do that we need a work

765
00:30:19,350 --> 00:30:22,080
in hooking engine we chose to use a

766
00:30:22,080 --> 00:30:26,190
method used by most token engines called

767
00:30:26,190 --> 00:30:28,580
inline hooks this method works by

768
00:30:28,580 --> 00:30:30,870
overwriting the prologue of the hook

769
00:30:30,870 --> 00:30:33,630
function with a jump into a code buffer

770
00:30:33,630 --> 00:30:35,490
we allocated in the process called the

771
00:30:35,490 --> 00:30:37,710
trampoline list and pulling forward the

772
00:30:37,710 --> 00:30:40,260
call to our detail function found in the

773
00:30:40,260 --> 00:30:42,360
DLL we've just injected into the process

774
00:30:42,360 --> 00:30:44,640
this little function can basically do

775
00:30:44,640 --> 00:30:46,500
what everyone wanted to do and will at

776
00:30:46,500 --> 00:30:48,390
some point call back into a trampoline

777
00:30:48,390 --> 00:30:50,880
trampoline will execute the missing

778
00:30:50,880 --> 00:30:52,890
instructions the ones that we wrote over

779
00:30:52,890 --> 00:30:55,290
in the hook function and jump back into

780
00:30:55,290 --> 00:30:56,730
the hook function to allow it to

781
00:30:56,730 --> 00:30:59,070
continue its normal execution if there

782
00:30:59,070 --> 00:31:01,200
are lot of different hooking engines

783
00:31:01,200 --> 00:31:03,870
that use this technique but none of

784
00:31:03,870 --> 00:31:05,880
those who inspected can actually hook

785
00:31:05,880 --> 00:31:08,460
64-bit code inside of 32-bit processes

786
00:31:08,460 --> 00:31:10,890
the main reason for that is that

787
00:31:10,890 --> 00:31:13,200
basically almost any code written for

788
00:31:13,200 --> 00:31:16,230
Windows makes use of some core and win32

789
00:31:16,230 --> 00:31:17,090
dll's

790
00:31:17,090 --> 00:31:20,490
that implement most of the win32 api

791
00:31:20,490 --> 00:31:24,300
this DLL such as kernel32 a user 32

792
00:31:24,300 --> 00:31:26,970
kernel-based cetera exists in almost

793
00:31:26,970 --> 00:31:29,670
every process but their 64 bit version

794
00:31:29,670 --> 00:31:32,940
is just not loaded into one 64 processes

795
00:31:32,940 --> 00:31:35,220
and because of different limitations we

796
00:31:35,220 --> 00:31:37,680
normally can't load them in either so we

797
00:31:37,680 --> 00:31:39,390
have to make do without them which

798
00:31:39,390 --> 00:31:42,090
basically leaves us with just the native

799
00:31:42,090 --> 00:31:45,360
ntdll to work with so to create a

800
00:31:45,360 --> 00:31:47,460
hulking engine that can actually work in

801
00:31:47,460 --> 00:31:49,860
such an environment we chose one of the

802
00:31:49,860 --> 00:31:52,290
engines we inspected earlier and started

803
00:31:52,290 --> 00:31:54,180
stripping off its dependencies other

804
00:31:54,180 --> 00:31:56,520
than the native ntdll the first and

805
00:31:56,520 --> 00:31:59,160
major step was reimplemented win32 api

806
00:31:59,160 --> 00:32:02,790
functions we had to implement all API

807
00:32:02,790 --> 00:32:04,920
functions that the hooking engine used

808
00:32:04,920 --> 00:32:07,620
to only make use of functions exported

809
00:32:07,620 --> 00:32:08,580
from ntdll

810
00:32:08,580 --> 00:32:10,590
most of these were pretty easy for

811
00:32:10,590 --> 00:32:11,560
example here

812
00:32:11,560 --> 00:32:12,910
we have our implementation of ritual

813
00:32:12,910 --> 00:32:14,890
protect which is basically just a

814
00:32:14,890 --> 00:32:16,600
forwarder - and to protect virtual

815
00:32:16,600 --> 00:32:19,570
memory exported from ntdll which means

816
00:32:19,570 --> 00:32:21,280
we can use it so most of our

817
00:32:21,280 --> 00:32:23,020
implementations look something like this

818
00:32:23,020 --> 00:32:25,480
some were a bit more complicated and

819
00:32:25,480 --> 00:32:27,730
then we had to either reverse engineer

820
00:32:27,730 --> 00:32:30,100
the missing dll or go to the reactor

821
00:32:30,100 --> 00:32:33,100
resources and do whatever they did after

822
00:32:33,100 --> 00:32:36,430
we implemented of them all of the api's

823
00:32:36,430 --> 00:32:38,740
we tried to recompile or modified

824
00:32:38,740 --> 00:32:41,170
looking engine and we're left with this

825
00:32:41,170 --> 00:32:43,180
this list of errors looks kind of

826
00:32:43,180 --> 00:32:45,220
threatening but most of these just

827
00:32:45,220 --> 00:32:47,260
requires like configuration changes to a

828
00:32:47,260 --> 00:32:49,900
project like disabling some runtime

829
00:32:49,900 --> 00:32:53,830
checks and stuff implemented in CRT so

830
00:32:53,830 --> 00:32:56,590
it wasn't such a big deal I won't go

831
00:32:56,590 --> 00:32:58,240
into details here because it's very

832
00:32:58,240 --> 00:33:00,190
technical and generally it is pretty

833
00:33:00,190 --> 00:33:02,470
boring so after we took care of all that

834
00:33:02,470 --> 00:33:05,410
we managed to successfully recompile our

835
00:33:05,410 --> 00:33:08,410
hooking engine implemented inside of a

836
00:33:08,410 --> 00:33:11,080
DLL and generate the 11 that only makes

837
00:33:11,080 --> 00:33:14,050
use of the native ntdll itself then we

838
00:33:14,050 --> 00:33:16,540
again tested it toward Windows 7 and it

839
00:33:16,540 --> 00:33:19,660
did great we managed to hook any a 64

840
00:33:19,660 --> 00:33:22,030
bit API functions we wanted so we're

841
00:33:22,030 --> 00:33:24,220
really glad about that then we

842
00:33:24,220 --> 00:33:25,840
remembered what happened last time and

843
00:33:25,840 --> 00:33:28,150
tested to understand very didn't do so

844
00:33:28,150 --> 00:33:31,360
great actually it failed to who KPI

845
00:33:31,360 --> 00:33:34,900
functions completely so what happened

846
00:33:34,900 --> 00:33:38,410
there there is we took a look at these

847
00:33:38,410 --> 00:33:40,810
processes and so that there is slight

848
00:33:40,810 --> 00:33:42,970
difference in the morula layout between

849
00:33:42,970 --> 00:33:46,150
Windows 7 and Windows 10 as you might

850
00:33:46,150 --> 00:33:49,660
remember Windows 7 and in wall 64 Pro

851
00:33:49,660 --> 00:33:52,150
says the whole memory above 4 gigabytes

852
00:33:52,150 --> 00:33:54,730
is reserved and we can't allocate or

853
00:33:54,730 --> 00:33:57,160
access it this means that all the DLL or

854
00:33:57,160 --> 00:34:00,160
all of our code is all found below v4

855
00:34:00,160 --> 00:34:02,230
gigabyte boundary Windows 10 however

856
00:34:02,230 --> 00:34:05,290
this looks almost identical but the

857
00:34:05,290 --> 00:34:07,600
native ntdll which we want to hook was

858
00:34:07,600 --> 00:34:09,190
actually moved to a much higher address

859
00:34:09,190 --> 00:34:12,130
way above the 4 bond boundary

860
00:34:12,130 --> 00:34:14,710
other than that the rest of the memory

861
00:34:14,710 --> 00:34:17,469
about 4 gigabytes is still reserved so

862
00:34:17,469 --> 00:34:19,860
we can't use it why is that a problem

863
00:34:19,860 --> 00:34:22,960
because the jump instruction that we use

864
00:34:22,960 --> 00:34:24,340
to overwrite

865
00:34:24,340 --> 00:34:27,429
the hooked function in order to jump

866
00:34:27,429 --> 00:34:29,620
into a trampoline is a relative jump

867
00:34:29,620 --> 00:34:31,540
which receives a four byte offset

868
00:34:31,540 --> 00:34:34,300
meaning it can pass a distance of up to

869
00:34:34,300 --> 00:34:36,639
two gigabytes from the hooked function

870
00:34:36,639 --> 00:34:39,130
into a trampoline another on Windows

871
00:34:39,130 --> 00:34:41,050
seven that's fine we can just allocate

872
00:34:41,050 --> 00:34:43,090
our trampoline right next to the native

873
00:34:43,090 --> 00:34:43,690
ntdll

874
00:34:43,690 --> 00:34:45,969
and we need to pass a distance of much

875
00:34:45,969 --> 00:34:48,610
less than two gigabytes on Windows 10 we

876
00:34:48,610 --> 00:34:50,320
can't allocate our trampoline next to

877
00:34:50,320 --> 00:34:51,969
the native ntdll since this memory is

878
00:34:51,969 --> 00:34:53,949
written is reserved and a trampoline

879
00:34:53,949 --> 00:34:55,900
will always be allocated below 4

880
00:34:55,900 --> 00:34:58,240
gigabytes since the total address space

881
00:34:58,240 --> 00:35:01,360
of 64-bit processes is 128 terabytes

882
00:35:01,360 --> 00:35:03,730
this means that we should have a

883
00:35:03,730 --> 00:35:06,040
distance of way more than 2 gigabytes to

884
00:35:06,040 --> 00:35:09,250
pass so our relative jump instruction is

885
00:35:09,250 --> 00:35:11,680
just not good enough and would fail on

886
00:35:11,680 --> 00:35:14,530
all while 64 processes or Windows 8.1

887
00:35:14,530 --> 00:35:17,200
and 10 so we had to replace it with a

888
00:35:17,200 --> 00:35:19,210
different instruction preferably one

889
00:35:19,210 --> 00:35:21,490
that can jump into an absolute 64 bit

890
00:35:21,490 --> 00:35:27,640
address okay so at this point we just

891
00:35:27,640 --> 00:35:30,490
like compiled the list of alternatives

892
00:35:30,490 --> 00:35:32,950
blanching instructions and with the

893
00:35:32,950 --> 00:35:34,630
generous help for McGill double of

894
00:35:34,630 --> 00:35:37,450
course and so let's just go over them

895
00:35:37,450 --> 00:35:39,220
one by one and see what might fit and

896
00:35:39,220 --> 00:35:43,060
what not so the first option is actually

897
00:35:43,060 --> 00:35:44,620
the relative jump which is already in

898
00:35:44,620 --> 00:35:46,570
use by most hooking engines so just like

899
00:35:46,570 --> 00:35:48,820
your Dan said it works on the devote

900
00:35:48,820 --> 00:35:50,200
size operand which means it can only

901
00:35:50,200 --> 00:35:51,790
pass the distance of up to two gigabytes

902
00:35:51,790 --> 00:35:54,490
in every direction and like she said to

903
00:35:54,490 --> 00:35:56,080
 bytes or simply not enough for us

904
00:35:56,080 --> 00:35:58,210
we need to pass a much greater distance

905
00:35:58,210 --> 00:36:00,940
so we had to discard this option almost

906
00:36:00,940 --> 00:36:04,120
immediately the next two options walk by

907
00:36:04,120 --> 00:36:06,730
a loading register with 64-bit absolute

908
00:36:06,730 --> 00:36:09,820
address either by loading it with an

909
00:36:09,820 --> 00:36:11,530
immediate value or by reference to a

910
00:36:11,530 --> 00:36:13,720
memory location and then branching to

911
00:36:13,720 --> 00:36:15,430
the address held by the register and

912
00:36:15,430 --> 00:36:17,230
while these two are both perfectly valid

913
00:36:17,230 --> 00:36:19,300
solutions they suffer from the same

914
00:36:19,300 --> 00:36:21,460
problem they both Delta at the register

915
00:36:21,460 --> 00:36:22,900
which kind of makes things a little bit

916
00:36:22,900 --> 00:36:25,060
more complicated so we wanted to keep

917
00:36:25,060 --> 00:36:26,920
things as simple as possible so we had

918
00:36:26,920 --> 00:36:29,470
to give up on these two as well the

919
00:36:29,470 --> 00:36:30,820
fourth option is actually quite

920
00:36:30,820 --> 00:36:32,230
interesting because it doesn't use the

921
00:36:32,230 --> 00:36:35,860
jump instruction instead it builds an

922
00:36:35,860 --> 00:36:37,690
address onto the stack into this

923
00:36:37,690 --> 00:36:40,810
racist and then just returns to it again

924
00:36:40,810 --> 00:36:42,190
for the first iteration it seems a

925
00:36:42,190 --> 00:36:44,680
little bit complicated so we put this

926
00:36:44,680 --> 00:36:46,990
aside and the quick spoiler allows we

927
00:36:46,990 --> 00:36:48,630
will probably get back into this later

928
00:36:48,630 --> 00:36:52,360
and so for the first iteration this just

929
00:36:52,360 --> 00:36:54,700
left us with the final option which

930
00:36:54,700 --> 00:36:56,620
takes advantage of an addressing mode

931
00:36:56,620 --> 00:36:58,360
called our IP relative addressing and

932
00:36:58,360 --> 00:37:01,570
basically just branches to the 64-bit

933
00:37:01,570 --> 00:37:02,830
absolute address which immediately

934
00:37:02,830 --> 00:37:04,740
follows the jump instruction in memory

935
00:37:04,740 --> 00:37:07,450
so we have modified our hooking engine

936
00:37:07,450 --> 00:37:09,370
accordingly bundled it into a DLL

937
00:37:09,370 --> 00:37:12,370
injected it and what we so this time is

938
00:37:12,370 --> 00:37:14,380
that while this solution works perfectly

939
00:37:14,380 --> 00:37:16,780
on Windows 10 it simply failed to create

940
00:37:16,780 --> 00:37:18,550
the hooks on all the platforms such as

941
00:37:18,550 --> 00:37:21,280
Windows 7 so to get into the root cause

942
00:37:21,280 --> 00:37:23,860
of this we took like an anti DLL version

943
00:37:23,860 --> 00:37:25,780
for Windows 7 and to DLL version for

944
00:37:25,780 --> 00:37:28,930
Windows 10 and decided to do some sort

945
00:37:28,930 --> 00:37:30,460
of a binary diffing and see if and if

946
00:37:30,460 --> 00:37:32,260
there is anything suspicious that pops

947
00:37:32,260 --> 00:37:34,930
up and what we found out is that in

948
00:37:34,930 --> 00:37:36,850
Windows 10 all functions to which we

949
00:37:36,850 --> 00:37:38,230
wish to apply our hooks are

950
00:37:38,230 --> 00:37:40,090
significantly longer than their windows

951
00:37:40,090 --> 00:37:42,220
7 counterparts so why is this a problem

952
00:37:42,220 --> 00:37:44,710
and because what I haven't told you is

953
00:37:44,710 --> 00:37:48,460
that the branching sequence that we

954
00:37:48,460 --> 00:37:50,260
decided to use is actually quite long

955
00:37:50,260 --> 00:37:52,150
it's binary encoding is something like

956
00:37:52,150 --> 00:37:54,610
14 bytes and what happens in Windows 7

957
00:37:54,610 --> 00:37:56,230
for example the functions are simply not

958
00:37:56,230 --> 00:37:57,520
long enough we don't have enough bytes

959
00:37:57,520 --> 00:38:02,230
to overwrite and so this kind of took us

960
00:38:02,230 --> 00:38:05,020
back to the drawing board and so at this

961
00:38:05,020 --> 00:38:06,940
point we decided to take a closer look

962
00:38:06,940 --> 00:38:08,680
at the fourth option the one which works

963
00:38:08,680 --> 00:38:10,270
by building an understood onto the stack

964
00:38:10,270 --> 00:38:12,820
so as you can see here this option is

965
00:38:12,820 --> 00:38:15,010
actually comprised out of three distinct

966
00:38:15,010 --> 00:38:17,050
instructions we first have the push

967
00:38:17,050 --> 00:38:19,330
instruction which builds the lower B

968
00:38:19,330 --> 00:38:21,400
world of the address it is then followed

969
00:38:21,400 --> 00:38:22,900
by a move instruction which builds the

970
00:38:22,900 --> 00:38:24,820
high order the world of the address and

971
00:38:24,820 --> 00:38:26,410
it then concludes with a read

972
00:38:26,410 --> 00:38:28,240
instruction which just pops up an eight

973
00:38:28,240 --> 00:38:29,890
byte value from the stack and branches

974
00:38:29,890 --> 00:38:32,560
to it so in its current form this

975
00:38:32,560 --> 00:38:34,510
sequence is again too long for us it

976
00:38:34,510 --> 00:38:36,580
actually longer it takes up sixteen

977
00:38:36,580 --> 00:38:39,250
bytes if I recall correctly and we try

978
00:38:39,250 --> 00:38:41,170
to think how can we optimize this

979
00:38:41,170 --> 00:38:43,240
sequence so after a little bit of trial

980
00:38:43,240 --> 00:38:45,880
and error we found out that we can get

981
00:38:45,880 --> 00:38:47,470
rid of the move instruction entirely and

982
00:38:47,470 --> 00:38:49,270
still be left with a walking solution so

983
00:38:49,270 --> 00:38:52,650
let's understand why is this possible

984
00:38:52,650 --> 00:38:54,730
so like we have said several times

985
00:38:54,730 --> 00:38:56,800
during the course of this talk in 164

986
00:38:56,800 --> 00:38:59,020
applications we normally can't allocate

987
00:38:59,020 --> 00:39:00,700
memory above the four gigabyte boundary

988
00:39:00,700 --> 00:39:02,109
because most of the address space that

989
00:39:02,109 --> 00:39:04,390
we simply reserved and because the

990
00:39:04,390 --> 00:39:06,550
trampoline is itself mm okay is a

991
00:39:06,550 --> 00:39:08,770
private memorial occasion it will always

992
00:39:08,770 --> 00:39:11,470
be below that line now if we take a look

993
00:39:11,470 --> 00:39:13,780
at a 64-bit absolute address which again

994
00:39:13,780 --> 00:39:17,020
is below that line we can see that it's

995
00:39:17,020 --> 00:39:18,579
high order the world will always be

996
00:39:18,579 --> 00:39:21,339
zeroed out and what works in our favor

997
00:39:21,339 --> 00:39:26,109
is x64 assembly because when you do a

998
00:39:26,109 --> 00:39:29,710
push on a 32-bit immediate value what

999
00:39:29,710 --> 00:39:31,270
will actually happen is that the CPU

1000
00:39:31,270 --> 00:39:33,880
will push an 8 byte value onto the stack

1001
00:39:33,880 --> 00:39:35,770
because the stack always has to remain 8

1002
00:39:35,770 --> 00:39:38,829
byte aligned and the high order diode

1003
00:39:38,829 --> 00:39:41,020
will be zeroed out by default so this is

1004
00:39:41,020 --> 00:39:43,150
exactly what we need and after we get

1005
00:39:43,150 --> 00:39:44,950
rid of the move instruction we are left

1006
00:39:44,950 --> 00:39:46,750
with a much shorter sequence which only

1007
00:39:46,750 --> 00:39:50,470
takes up 6 bytes and this kind of makes

1008
00:39:50,470 --> 00:39:51,820
this solution a universal solution

1009
00:39:51,820 --> 00:39:53,470
because it will work on all Windows

1010
00:39:53,470 --> 00:39:56,290
platforms starting from Windows 7 up to

1011
00:39:56,290 --> 00:39:59,200
an including Windows 10 so again we have

1012
00:39:59,200 --> 00:40:01,420
modified our hooking engine compiled it

1013
00:40:01,420 --> 00:40:03,760
into a DLL injected it and this time it

1014
00:40:03,760 --> 00:40:06,700
just worked and if you for example

1015
00:40:06,700 --> 00:40:09,609
disassemble one of the Warlocks of a

1016
00:40:09,609 --> 00:40:11,109
hook function you can see something like

1017
00:40:11,109 --> 00:40:14,880
this push which is followed by a late

1018
00:40:18,580 --> 00:40:22,520
okay so that's basically it let's do a

1019
00:40:22,520 --> 00:40:24,410
quick recap of what we had here

1020
00:40:24,410 --> 00:40:28,070
we started by injecting or 64-bit dll

1021
00:40:28,070 --> 00:40:31,430
into our work 64 process we did that by

1022
00:40:31,430 --> 00:40:34,880
first using a free previously known

1023
00:40:34,880 --> 00:40:37,550
method and jet and then improving our

1024
00:40:37,550 --> 00:40:40,220
APC injector to make it work on new

1025
00:40:40,220 --> 00:40:42,290
Windows versions as well then we took

1026
00:40:42,290 --> 00:40:44,600
care of our Hawken engine we implemented

1027
00:40:44,600 --> 00:40:47,450
win32 API is that accuses we fix its

1028
00:40:47,450 --> 00:40:49,670
configuration and we managed to get it

1029
00:40:49,670 --> 00:40:53,090
to hook a 64-bit API is on what on one

1030
00:40:53,090 --> 00:40:56,540
64 processes we then verified that it

1031
00:40:56,540 --> 00:40:58,130
actually works across all windows

1032
00:40:58,130 --> 00:41:00,050
platforms so we won't mess up this time

1033
00:41:00,050 --> 00:41:03,110
and we thought it actually worked we did

1034
00:41:03,110 --> 00:41:05,900
exactly what we wanted and then we

1035
00:41:05,900 --> 00:41:10,180
celebrated by going home before 12 a.m.

1036
00:41:11,050 --> 00:41:14,600
well sooner we actually published this

1037
00:41:14,600 --> 00:41:16,670
research in a series of blogs and we

1038
00:41:16,670 --> 00:41:18,440
have and we published our source code

1039
00:41:18,440 --> 00:41:21,110
for our token engine it will pretty soon

1040
00:41:21,110 --> 00:41:25,040
publish this this slides so the links

1041
00:41:25,040 --> 00:41:28,990
are here and that's basically

1042
00:41:28,990 --> 00:41:39,250
[Applause]

