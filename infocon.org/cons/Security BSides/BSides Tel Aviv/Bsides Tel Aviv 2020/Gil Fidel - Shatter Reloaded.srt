1
00:00:00,390 --> 00:00:03,090
I'm Gil I'm going to talk about making

2
00:00:03,090 --> 00:00:05,009
shutter attacks right again but first I

3
00:00:05,009 --> 00:00:08,010
want to say a very big thank you and a

4
00:00:08,010 --> 00:00:10,500
big kudos to all the organizing crew and

5
00:00:10,500 --> 00:00:12,900
the volunteers for making this happen

6
00:00:12,900 --> 00:00:14,730
despite the crazy times you're in so

7
00:00:14,730 --> 00:00:19,710
great job guys okay a bit about me sorry

8
00:00:19,710 --> 00:00:22,490
I lead R&D in Accenture screw to Israel

9
00:00:22,490 --> 00:00:27,750
formerly in Milan and we do development

10
00:00:27,750 --> 00:00:29,939
of offensive and defensive tools we do a

11
00:00:29,939 --> 00:00:33,360
vulnerability research do some general

12
00:00:33,360 --> 00:00:36,329
security related innovation and also AI

13
00:00:36,329 --> 00:00:38,520
security so this sounds interesting

14
00:00:38,520 --> 00:00:40,110
pink me we're always looking for bright

15
00:00:40,110 --> 00:00:43,829
minds to join us now what are what are

16
00:00:43,829 --> 00:00:46,440
we going to talk about today so I'm

17
00:00:46,440 --> 00:00:47,870
going to give a bit of background

18
00:00:47,870 --> 00:00:53,039
history about shatter attacks how they

19
00:00:53,039 --> 00:00:55,079
came to be how they were mitigated in

20
00:00:55,079 --> 00:00:58,649
Windows Vista then won't talk about our

21
00:00:58,649 --> 00:01:01,500
reincarnation of them in the context of

22
00:01:01,500 --> 00:01:04,280
to main use cases the first is breaking

23
00:01:04,280 --> 00:01:07,080
sandboxes the second one is very needy

24
00:01:07,080 --> 00:01:09,510
ours we're going to talk a bit a little

25
00:01:09,510 --> 00:01:11,549
bit about passive integrations and we're

26
00:01:11,549 --> 00:01:13,380
going to show demo that will hopefully

27
00:01:13,380 --> 00:01:18,950
work so let's start so once upon a time

28
00:01:18,950 --> 00:01:21,509
shatter attacks they were introduced in

29
00:01:21,509 --> 00:01:25,860
2002 they were used mainly as a way to

30
00:01:25,860 --> 00:01:29,040
do privilege escalation on Windows so

31
00:01:29,040 --> 00:01:33,659
the way it would work it would have some

32
00:01:33,659 --> 00:01:37,340
win32 service running the system and

33
00:01:37,340 --> 00:01:39,990
making the big mistake of showing some

34
00:01:39,990 --> 00:01:43,680
user interface some GUI to the user on

35
00:01:43,680 --> 00:01:46,710
the user's desktop and then a user even

36
00:01:46,710 --> 00:01:49,590
now guest user would actually send a

37
00:01:49,590 --> 00:01:51,899
bunch of special crafted mean Windows

38
00:01:51,899 --> 00:01:55,290
messages to this GUI which eventually

39
00:01:55,290 --> 00:01:58,079
called code execution in the service in

40
00:01:58,079 --> 00:02:01,290
system privileges so the way it would

41
00:02:01,290 --> 00:02:03,869
work we have the attacker over here

42
00:02:03,869 --> 00:02:06,180
denied it's nice snake have the target

43
00:02:06,180 --> 00:02:10,530
process which shows the piece of GUI let

44
00:02:10,530 --> 00:02:13,720
among other things includes an edit box

45
00:02:13,720 --> 00:02:16,960
and we assume now the dead bugs buffer

46
00:02:16,960 --> 00:02:18,910
like the buffer that stores the actual

47
00:02:18,910 --> 00:02:21,790
contents of the Edit box is in this

48
00:02:21,790 --> 00:02:24,490
constant address so what an attacker

49
00:02:24,490 --> 00:02:28,090
would do it will first send a set text

50
00:02:28,090 --> 00:02:30,520
message with the shell code he wants to

51
00:02:30,520 --> 00:02:34,120
run so since this message copies a

52
00:02:34,120 --> 00:02:38,200
string to the Edit box this shell code

53
00:02:38,200 --> 00:02:39,820
should be now free which is not a big

54
00:02:39,820 --> 00:02:43,210
problem so he sent this message the

55
00:02:43,210 --> 00:02:44,640
shell code is now in the edit box

56
00:02:44,640 --> 00:02:49,990
meaning in the distress 2000 hexam then

57
00:02:49,990 --> 00:02:51,880
the attacker would need to know this

58
00:02:51,880 --> 00:02:54,070
address so this can be this can be done

59
00:02:54,070 --> 00:02:57,520
for example by doing some recon in

60
00:02:57,520 --> 00:02:59,680
advanced and doing some reversing or

61
00:02:59,680 --> 00:03:02,020
debugging and knowing that this is the

62
00:03:02,020 --> 00:03:04,690
static address that always holds the

63
00:03:04,690 --> 00:03:07,540
buffer of the read box for the specific

64
00:03:07,540 --> 00:03:10,209
version of the service for example and

65
00:03:10,209 --> 00:03:11,980
then he would simply send a WM timer

66
00:03:11,980 --> 00:03:15,400
message and one of the parameters

67
00:03:15,400 --> 00:03:16,900
receives is actually the address of the

68
00:03:16,900 --> 00:03:18,430
call box it needs it needs to be

69
00:03:18,430 --> 00:03:21,100
executed basically once it sends its

70
00:03:21,100 --> 00:03:23,709
message the shell code gets executed and

71
00:03:23,709 --> 00:03:27,400
we're all done pretty simple so

72
00:03:27,400 --> 00:03:30,940
Microsoft of course patched this well

73
00:03:30,940 --> 00:03:34,030
the first batch was actually to not

74
00:03:34,030 --> 00:03:37,330
handle WM timer messages for a non

75
00:03:37,330 --> 00:03:39,400
previously registered timer which seems

76
00:03:39,400 --> 00:03:41,980
kind of vyas and quite funny didn't do

77
00:03:41,980 --> 00:03:43,540
it like that in advance so what this

78
00:03:43,540 --> 00:03:45,910
means the textual integra now has to

79
00:03:45,910 --> 00:03:49,630
first call set timer set timer API in

80
00:03:49,630 --> 00:03:51,730
the context of the target process which

81
00:03:51,730 --> 00:03:53,530
is something he cannot do unless he

82
00:03:53,530 --> 00:03:55,600
already has some code injected into it

83
00:03:55,600 --> 00:03:57,580
which kind of it's a perfect purpose so

84
00:03:57,580 --> 00:04:02,440
that was good and also Microsoft fixed

85
00:04:02,440 --> 00:04:04,959
all of their services not to show any

86
00:04:04,959 --> 00:04:07,000
GUI on the usual desktop and of course

87
00:04:07,000 --> 00:04:09,400
and probably updated their best

88
00:04:09,400 --> 00:04:11,650
practices guidelines that everybody

89
00:04:11,650 --> 00:04:14,590
ignores but that kind of put a stop to

90
00:04:14,590 --> 00:04:17,040
the to this simple and vulnerability

91
00:04:17,040 --> 00:04:21,040
being used in the world now if we think

92
00:04:21,040 --> 00:04:24,520
a little bit in more general what is

93
00:04:24,520 --> 00:04:26,920
actually the problem here that caused

94
00:04:26,920 --> 00:04:29,650
escalation liability so the first one

95
00:04:29,650 --> 00:04:32,950
was the lack of access control so the

96
00:04:32,950 --> 00:04:35,530
fact that I process running as a low

97
00:04:35,530 --> 00:04:38,230
privileged user even guests could send

98
00:04:38,230 --> 00:04:40,600
Windows messages to a high privilege

99
00:04:40,600 --> 00:04:43,270
versus even a system process that's one

100
00:04:43,270 --> 00:04:46,770
problem the second one was the lack of

101
00:04:46,770 --> 00:04:50,770
namespace isolation in terms of Windows

102
00:04:50,770 --> 00:04:54,310
sessions and desktops so they're

103
00:04:54,310 --> 00:04:56,590
actually no there is no good reason for

104
00:04:56,590 --> 00:05:00,190
user processes and services run to be

105
00:05:00,190 --> 00:05:03,400
running on the same Windows desktop at

106
00:05:03,400 --> 00:05:07,480
the third one is the fact that the this

107
00:05:07,480 --> 00:05:10,510
win32 service expose the user interface

108
00:05:10,510 --> 00:05:14,170
directly instead of the way it's done

109
00:05:14,170 --> 00:05:17,950
today of running some client utility was

110
00:05:17,950 --> 00:05:19,690
you know a little Tricon or something

111
00:05:19,690 --> 00:05:22,240
like that which is transient with low

112
00:05:22,240 --> 00:05:24,580
privileges as opposed to the service

113
00:05:24,580 --> 00:05:26,950
running high privileges and the first

114
00:05:26,950 --> 00:05:29,860
one which is like more generic and it's

115
00:05:29,860 --> 00:05:32,590
rooted deep in the design of the win32

116
00:05:32,590 --> 00:05:35,080
GUI subsystem is actually the fact that

117
00:05:35,080 --> 00:05:37,480
you can send a Windows message across

118
00:05:37,480 --> 00:05:39,580
process boundaries that contains a

119
00:05:39,580 --> 00:05:42,010
pointer to a call because it's to be

120
00:05:42,010 --> 00:05:44,200
executed in the target process well

121
00:05:44,200 --> 00:05:48,550
that's a big problem by itself and so

122
00:05:48,550 --> 00:05:51,460
with Windows Vista the most of those

123
00:05:51,460 --> 00:05:54,550
issues were fixed so Microsoft

124
00:05:54,550 --> 00:05:58,720
introduced so-called you IP I using user

125
00:05:58,720 --> 00:06:00,850
interface privilege escalation which

126
00:06:00,850 --> 00:06:04,120
basically added a new label to each

127
00:06:04,120 --> 00:06:06,610
process and could be either low medium

128
00:06:06,610 --> 00:06:08,800
high or system so medium was the default

129
00:06:08,800 --> 00:06:12,040
one used for non elevated processes how

130
00:06:12,040 --> 00:06:14,680
I was used for elevated ones and low was

131
00:06:14,680 --> 00:06:16,930
used for example for the interest

132
00:06:16,930 --> 00:06:19,120
Explorer renderer process that we wanted

133
00:06:19,120 --> 00:06:21,550
to run with even lower privileges and

134
00:06:21,550 --> 00:06:26,110
normal processes and then what is new

135
00:06:26,110 --> 00:06:28,360
mechanism would actually do is that you

136
00:06:28,360 --> 00:06:30,790
can you could no longer send Windows

137
00:06:30,790 --> 00:06:34,540
messages from long term return processes

138
00:06:34,540 --> 00:06:37,960
to high integrity level processes

139
00:06:37,960 --> 00:06:41,000
that's that so the second second thing

140
00:06:41,000 --> 00:06:43,220
it was introduced in Vista its session

141
00:06:43,220 --> 00:06:46,610
zero isolation which meant that all

142
00:06:46,610 --> 00:06:49,160
windows services were now running in a

143
00:06:49,160 --> 00:06:51,139
distinct window session so previously

144
00:06:51,139 --> 00:06:53,900
the first user logon session was session

145
00:06:53,900 --> 00:06:56,419
zero which was shared with all the win32

146
00:06:56,419 --> 00:06:58,970
services that was the way in Windows XP

147
00:06:58,970 --> 00:07:01,100
for example but starting with Whiston

148
00:07:01,100 --> 00:07:03,470
onwards services would run in session

149
00:07:03,470 --> 00:07:05,690
zero whether the first user logon

150
00:07:05,690 --> 00:07:07,820
session was session 1 and then if there

151
00:07:07,820 --> 00:07:09,410
were more users that would get sessions

152
00:07:09,410 --> 00:07:13,010
two three etc the third thing might

153
00:07:13,010 --> 00:07:14,260
receive did in that regard

154
00:07:14,260 --> 00:07:16,940
to preserve better compatibility for

155
00:07:16,940 --> 00:07:19,550
services that for some reason still

156
00:07:19,550 --> 00:07:22,580
wanted to show GUI directly is that if a

157
00:07:22,580 --> 00:07:25,699
service tried to show a piece of GUI the

158
00:07:25,699 --> 00:07:27,470
user would receive this funny-looking

159
00:07:27,470 --> 00:07:30,590
message and if we did the mistake of

160
00:07:30,590 --> 00:07:32,060
taking view message it would be

161
00:07:32,060 --> 00:07:34,580
redirected to a special desktop that

162
00:07:34,580 --> 00:07:37,150
contained the UI shown by by the service

163
00:07:37,150 --> 00:07:41,510
so that was very good and actually put a

164
00:07:41,510 --> 00:07:43,810
stop to shutter attacks altogether

165
00:07:43,810 --> 00:07:46,340
because they could no longer be used for

166
00:07:46,340 --> 00:07:50,060
escalating privileges and of course

167
00:07:50,060 --> 00:07:53,210
there were quite forgotten until we came

168
00:07:53,210 --> 00:07:56,960
along not really but let's keep that

169
00:07:56,960 --> 00:08:01,310
story so the first use case we're going

170
00:08:01,310 --> 00:08:04,789
to talk about it's actually commercial

171
00:08:04,789 --> 00:08:07,669
sandboxes so we had a project where we

172
00:08:07,669 --> 00:08:10,400
needed to do some fun ability research

173
00:08:10,400 --> 00:08:13,039
and assessment of commercial sandbox to

174
00:08:13,039 --> 00:08:17,000
find witnesses so this sandbox I've not

175
00:08:17,000 --> 00:08:18,919
disclosed its name was was a client but

176
00:08:18,919 --> 00:08:22,130
basically the concept was that we want

177
00:08:22,130 --> 00:08:25,849
to isolate between trusted and untrusted

178
00:08:25,849 --> 00:08:28,699
processes so untrusted ones which were

179
00:08:28,699 --> 00:08:30,139
running inside the side-box

180
00:08:30,139 --> 00:08:32,809
are processes that communicate with the

181
00:08:32,809 --> 00:08:34,820
internet directly like we can think of

182
00:08:34,820 --> 00:08:37,208
for example web browsers stuff with that

183
00:08:37,208 --> 00:08:40,070
British trusted processes or the ones

184
00:08:40,070 --> 00:08:42,860
that are actually access in process

185
00:08:42,860 --> 00:08:45,800
sensitive corporate data like documents

186
00:08:45,800 --> 00:08:48,079
etc and have access to the corporate

187
00:08:48,079 --> 00:08:51,020
network and basically this sandwich

188
00:08:51,020 --> 00:08:52,790
wanted to isolate between them so that

189
00:08:52,790 --> 00:08:54,890
it for example some client-side attack

190
00:08:54,890 --> 00:08:58,040
gains code execution in the browser to

191
00:08:58,040 --> 00:09:01,250
not be able to do any further damage or

192
00:09:01,250 --> 00:09:05,870
collecting information so the sandbox it

193
00:09:05,870 --> 00:09:08,770
implemented like all the possible

194
00:09:08,770 --> 00:09:11,090
isolation you know rather than the

195
00:09:11,090 --> 00:09:13,220
Mexican think of so both file system in

196
00:09:13,220 --> 00:09:15,380
registry so trusted and untrusted

197
00:09:15,380 --> 00:09:17,360
processes had different view of the file

198
00:09:17,360 --> 00:09:20,440
system in registry did network isolation

199
00:09:20,440 --> 00:09:23,900
so that trusted processes can access the

200
00:09:23,900 --> 00:09:25,640
local network the corporate network

201
00:09:25,640 --> 00:09:27,890
where's untrusted processes can access

202
00:09:27,890 --> 00:09:31,100
the internet and it also implemented

203
00:09:31,100 --> 00:09:34,430
elation for win32 GUI so you couldn't

204
00:09:34,430 --> 00:09:37,100
down like copy/paste stuff between them

205
00:09:37,100 --> 00:09:39,200
and you couldn't perform GDI operations

206
00:09:39,200 --> 00:09:41,750
that taking screenshots and you couldn't

207
00:09:41,750 --> 00:09:43,520
send Windows messages between trusted

208
00:09:43,520 --> 00:09:47,690
and untrusted processes so we were in

209
00:09:47,690 --> 00:09:49,430
quite a bit of a difficult situation

210
00:09:49,430 --> 00:09:52,610
there as an attacker because actually

211
00:09:52,610 --> 00:09:55,040
the file system najin registry and were

212
00:09:55,040 --> 00:09:58,120
implemented using kernel mini filters

213
00:09:58,120 --> 00:10:00,650
the required solid and quite difficult

214
00:10:00,650 --> 00:10:06,980
to exploit and also the implemented

215
00:10:06,980 --> 00:10:09,440
process isolation using object callbacks

216
00:10:09,440 --> 00:10:12,020
the OB registered called this API which

217
00:10:12,020 --> 00:10:16,160
actually didn't allow processes to open

218
00:10:16,160 --> 00:10:18,800
the processor running the untrusted

219
00:10:18,800 --> 00:10:21,440
untrust environment couldn't open a

220
00:10:21,440 --> 00:10:23,030
process in the trusted environment for

221
00:10:23,030 --> 00:10:24,650
writing so that was the first thing we

222
00:10:24,650 --> 00:10:26,600
tried like wanted to for example try

223
00:10:26,600 --> 00:10:29,600
injection code to a trusted process but

224
00:10:29,600 --> 00:10:33,170
that was denied so we couldn't open a

225
00:10:33,170 --> 00:10:36,890
process in which was trusted with right

226
00:10:36,890 --> 00:10:39,860
access but we actually were able to open

227
00:10:39,860 --> 00:10:42,370
it with read access which proved useful

228
00:10:42,370 --> 00:10:45,770
afterwards this will seem so and then

229
00:10:45,770 --> 00:10:47,000
we're thinking okay so what what else

230
00:10:47,000 --> 00:10:49,100
can we do and or in other in other words

231
00:10:49,100 --> 00:10:53,660
what is the weakest link here and not

232
00:10:53,660 --> 00:10:56,540
surprisingly there was one which was the

233
00:10:56,540 --> 00:10:59,810
way free to you is elation and the

234
00:10:59,810 --> 00:11:01,400
reason was the weakest link is it was

235
00:11:01,400 --> 00:11:04,690
actually implemented by user mode hooks

236
00:11:04,690 --> 00:11:07,210
since as we know since patchwork came

237
00:11:07,210 --> 00:11:10,060
along kernel-mode hooks for api's are

238
00:11:10,060 --> 00:11:14,290
not really feasible so the white would

239
00:11:14,290 --> 00:11:16,600
work for example let's say I'm running

240
00:11:16,600 --> 00:11:19,090
an untrusted process want to send a

241
00:11:19,090 --> 00:11:21,580
Windows message to a trusted one so

242
00:11:21,580 --> 00:11:23,520
basically the moment I call send message

243
00:11:23,520 --> 00:11:26,200
there's an inline hook intercepting it

244
00:11:26,200 --> 00:11:28,960
and basically denying the call returning

245
00:11:28,960 --> 00:11:32,260
me access denied but since this is a

246
00:11:32,260 --> 00:11:33,820
user mode who in the process we are

247
00:11:33,820 --> 00:11:36,520
executing we were actually able to

248
00:11:36,520 --> 00:11:40,720
remove them Juden quite a generic method

249
00:11:40,720 --> 00:11:44,110
of comparing the the entry points of all

250
00:11:44,110 --> 00:11:46,060
exported symbols from all loaded modules

251
00:11:46,060 --> 00:11:49,750
and then comparing them in memory versus

252
00:11:49,750 --> 00:11:52,450
the copy on disk taking relocations into

253
00:11:52,450 --> 00:11:54,160
account of course and we never saw a

254
00:11:54,160 --> 00:11:57,970
difference would simply overwrite the

255
00:11:57,970 --> 00:11:59,710
memory version with the one from the

256
00:11:59,710 --> 00:12:02,380
disk which effectively removed all the

257
00:12:02,380 --> 00:12:06,580
holes so now we were actually able to

258
00:12:06,580 --> 00:12:08,710
send messages across isolation

259
00:12:08,710 --> 00:12:13,270
boundaries so and then wondered how that

260
00:12:13,270 --> 00:12:15,520
might be useful so this was before this

261
00:12:15,520 --> 00:12:19,030
lecture I banged my head on the wall for

262
00:12:19,030 --> 00:12:22,000
a day or two until shatter attacks came

263
00:12:22,000 --> 00:12:27,370
along and then basically if you remember

264
00:12:27,370 --> 00:12:30,550
we talked about Windows Vista mitigating

265
00:12:30,550 --> 00:12:33,340
shatter attacks used for previous

266
00:12:33,340 --> 00:12:34,930
escalation but the thing that Microsoft

267
00:12:34,930 --> 00:12:37,960
actually didn't address is the fact that

268
00:12:37,960 --> 00:12:42,400
you still had Windows messages that

269
00:12:42,400 --> 00:12:44,650
could be sent across process boundaries

270
00:12:44,650 --> 00:12:47,380
at least processes run in the same

271
00:12:47,380 --> 00:12:52,020
integrity level that contained callbacks

272
00:12:52,020 --> 00:12:55,480
which means addresses pointers that are

273
00:12:55,480 --> 00:12:57,070
interpreted in the context of a tablet

274
00:12:57,070 --> 00:12:59,920
process and executed so this looks like

275
00:12:59,920 --> 00:13:01,839
something that can eventually be

276
00:13:01,839 --> 00:13:06,130
exploited and actually if you remember

277
00:13:06,130 --> 00:13:07,810
we talked in the beginning about basic

278
00:13:07,810 --> 00:13:08,440
special tact

279
00:13:08,440 --> 00:13:10,630
shatter dive based on the WM timer

280
00:13:10,630 --> 00:13:14,720
message but apparently there are

281
00:13:14,720 --> 00:13:18,019
a bunch of other windows messages that

282
00:13:18,019 --> 00:13:20,389
had the same pattern of having an

283
00:13:20,389 --> 00:13:25,220
argument which is a callback so I was

284
00:13:25,220 --> 00:13:27,230
stupid enough to go off and enumerate

285
00:13:27,230 --> 00:13:29,329
them myself instead of looking for other

286
00:13:29,329 --> 00:13:32,240
folks who have already done it but this

287
00:13:32,240 --> 00:13:34,879
is what a yeah this is what they found

288
00:13:34,879 --> 00:13:37,639
so there are a number of them in which

289
00:13:37,639 --> 00:13:39,889
edit controls used for customizing

290
00:13:39,889 --> 00:13:43,009
different behaviors such as autocorrect

291
00:13:43,009 --> 00:13:45,949
and start with that the list view

292
00:13:45,949 --> 00:13:48,290
control has a bunch of them for certain

293
00:13:48,290 --> 00:13:52,459
elements and basically allowing the user

294
00:13:52,459 --> 00:13:55,430
to provide a custom compare callback for

295
00:13:55,430 --> 00:13:59,120
the sorting and also the tree view had

296
00:13:59,120 --> 00:14:01,310
the same so there's a message you can

297
00:14:01,310 --> 00:14:04,699
send to a tree view that sorts the

298
00:14:04,699 --> 00:14:07,759
elements of the tree and it actually you

299
00:14:07,759 --> 00:14:09,410
can give it a callback to the custom

300
00:14:09,410 --> 00:14:11,389
compare function which proved very

301
00:14:11,389 --> 00:14:15,759
useful as we will soon see so here's a

302
00:14:15,759 --> 00:14:20,089
sample for using this tree view message

303
00:14:20,089 --> 00:14:25,160
to execute code so this snippet by

304
00:14:25,160 --> 00:14:26,720
itself is not really useful to us

305
00:14:26,720 --> 00:14:30,889
because it requires and write access to

306
00:14:30,889 --> 00:14:32,959
the target process in order to allocate

307
00:14:32,959 --> 00:14:36,259
memory and excuse me and write to it but

308
00:14:36,259 --> 00:14:38,779
this will prove useful to understand

309
00:14:38,779 --> 00:14:42,319
what we did further okay so I'm going to

310
00:14:42,319 --> 00:14:45,589
go over it quite quickly so basically

311
00:14:45,589 --> 00:14:49,069
what this code does it injects code

312
00:14:49,069 --> 00:14:51,649
specifically into the registry editor so

313
00:14:51,649 --> 00:14:54,379
it first finds the tree view that's

314
00:14:54,379 --> 00:14:58,009
inside it it gets the process ID opens

315
00:14:58,009 --> 00:15:01,490
the process for all access and then

316
00:15:01,490 --> 00:15:03,920
allocates memory which is executable and

317
00:15:03,920 --> 00:15:06,379
write the payload which is the shell

318
00:15:06,379 --> 00:15:08,899
code we want to run into the target

319
00:15:08,899 --> 00:15:11,750
process in the registry editor then it

320
00:15:11,750 --> 00:15:13,730
obtains the route item from the tree

321
00:15:13,730 --> 00:15:19,129
view and then initializes the tv-tv

322
00:15:19,129 --> 00:15:22,639
sorts to be struct which basically

323
00:15:22,639 --> 00:15:24,470
contains the parent which is the route

324
00:15:24,470 --> 00:15:26,329
item

325
00:15:26,329 --> 00:15:28,009
which represent the sub-tree that we

326
00:15:28,009 --> 00:15:30,980
want assert hasn't addressed of the

327
00:15:30,980 --> 00:15:32,509
compare function which is narcotized

328
00:15:32,509 --> 00:15:35,839
address of her shell code and an altar

329
00:15:35,839 --> 00:15:37,989
on which is now you don't care about

330
00:15:37,989 --> 00:15:42,379
then it allocates memory in order to

331
00:15:42,379 --> 00:15:45,139
copy this TV swords be struct into the

332
00:15:45,139 --> 00:15:49,519
table process and finally it sends this

333
00:15:49,519 --> 00:15:52,670
TVM sort children CB message to

334
00:15:52,670 --> 00:15:55,220
crosses and when it's sent it starts

335
00:15:55,220 --> 00:15:57,860
sorting the tree view and the moment it

336
00:15:57,860 --> 00:15:59,749
first needs to compare to elements in

337
00:15:59,749 --> 00:16:01,819
order to implement the sorting it's

338
00:16:01,819 --> 00:16:03,860
actually called the callback but the

339
00:16:03,860 --> 00:16:05,480
callbacks points or shell code which

340
00:16:05,480 --> 00:16:08,509
gets executed and they're very happy so

341
00:16:08,509 --> 00:16:12,529
that's the way it works now as I said

342
00:16:12,529 --> 00:16:16,040
before it's not really helpful for us as

343
00:16:16,040 --> 00:16:18,920
it is because we still need to find a

344
00:16:18,920 --> 00:16:21,559
way to copy some shell code into the

345
00:16:21,559 --> 00:16:24,129
target process

346
00:16:24,439 --> 00:16:26,449
moreover we need to do it mean to put

347
00:16:26,449 --> 00:16:28,519
the shell code into executable memory

348
00:16:28,519 --> 00:16:31,160
because otherwise that will prevent it

349
00:16:31,160 --> 00:16:35,089
from running now step back a little bit

350
00:16:35,089 --> 00:16:39,169
for looking at into code injection in a

351
00:16:39,169 --> 00:16:42,079
bit more general fashion like I said we

352
00:16:42,079 --> 00:16:44,540
need to first copy the shell code into

353
00:16:44,540 --> 00:16:46,790
some address we know of in the target

354
00:16:46,790 --> 00:16:50,290
process and we need to make sure it's in

355
00:16:50,290 --> 00:16:52,309
executable region of memory so either

356
00:16:52,309 --> 00:16:55,040
copy to excuse memory up front or we

357
00:16:55,040 --> 00:16:57,350
need to migrate it into it using some

358
00:16:57,350 --> 00:16:59,389
method and eventually we need to trigger

359
00:16:59,389 --> 00:17:01,970
execution so at this stage we have the

360
00:17:01,970 --> 00:17:05,179
trigger which is the TV trivial

361
00:17:05,179 --> 00:17:07,880
shortened message you still need to find

362
00:17:07,880 --> 00:17:10,909
a way to copy or shellcode into

363
00:17:10,909 --> 00:17:12,709
executable memory in the process which

364
00:17:12,709 --> 00:17:16,638
is what we're going to show now okay so

365
00:17:16,638 --> 00:17:19,010
this is a heart of lower view of what we

366
00:17:19,010 --> 00:17:23,329
did so first we used an added box in the

367
00:17:23,329 --> 00:17:27,648
target process and sent to it WM set

368
00:17:27,648 --> 00:17:30,169
text message in order to copy our shell

369
00:17:30,169 --> 00:17:33,289
code into the process now we used the

370
00:17:33,289 --> 00:17:35,659
unicode flavor of send message and that

371
00:17:35,659 --> 00:17:37,220
way we were actually able to inject

372
00:17:37,220 --> 00:17:40,190
shell code that does contain us but

373
00:17:40,190 --> 00:17:41,750
not double notes because that's the null

374
00:17:41,750 --> 00:17:45,920
Terminator for Unicode next we need to

375
00:17:45,920 --> 00:17:47,900
find the address of the shellcode so in

376
00:17:47,900 --> 00:17:50,140
the original schedule attacks it was

377
00:17:50,140 --> 00:17:55,040
they assumed that dresses is static and

378
00:17:55,040 --> 00:17:58,550
they simply hard-coded it hard-coded it

379
00:17:58,550 --> 00:18:00,800
but we wanted to do it dynamically and

380
00:18:00,800 --> 00:18:03,140
it does at this stage we actually

381
00:18:03,140 --> 00:18:04,850
leverage the fact that we have read

382
00:18:04,850 --> 00:18:08,150
access to the target process and so we

383
00:18:08,150 --> 00:18:11,480
simply scanned we open the target

384
00:18:11,480 --> 00:18:13,570
process for reading scanned its memory

385
00:18:13,570 --> 00:18:17,000
using visual query ax to get our memory

386
00:18:17,000 --> 00:18:20,600
region at a time until we found the

387
00:18:20,600 --> 00:18:23,000
pattern until pattern matched the

388
00:18:23,000 --> 00:18:24,770
shellcode we copied into edit box so now

389
00:18:24,770 --> 00:18:26,570
we had the dress over shellcode and

390
00:18:26,570 --> 00:18:29,720
target process memory next we need to

391
00:18:29,720 --> 00:18:32,180
migrate the shellcode to some little

392
00:18:32,180 --> 00:18:34,970
memory so what we did we used the same

393
00:18:34,970 --> 00:18:38,330
memory scanning technique to find the

394
00:18:38,330 --> 00:18:40,190
region of memory which is read write

395
00:18:40,190 --> 00:18:43,010
execute we assumed it does exist

396
00:18:43,010 --> 00:18:44,690
internal process we'll talk about it in

397
00:18:44,690 --> 00:18:48,410
a moment and once we found it we used a

398
00:18:48,410 --> 00:18:51,710
status bar to actually migrate the

399
00:18:51,710 --> 00:18:54,050
shellcode so what's very nice about the

400
00:18:54,050 --> 00:18:56,510
status bar is opposed to dirty box is

401
00:18:56,510 --> 00:19:00,140
that actually it has set text and get

402
00:19:00,140 --> 00:19:04,610
text messages and argument they receive

403
00:19:04,610 --> 00:19:07,730
is not serialized but instead treated as

404
00:19:07,730 --> 00:19:10,760
a pointer to data in the target process

405
00:19:10,760 --> 00:19:13,550
so you could use set text to copy the

406
00:19:13,550 --> 00:19:15,380
shellcode from red box buffer into the

407
00:19:15,380 --> 00:19:18,140
status bar and then we could use get

408
00:19:18,140 --> 00:19:21,020
text to actually copy the shellcode from

409
00:19:21,020 --> 00:19:23,900
the status bar to our target executable

410
00:19:23,900 --> 00:19:27,410
address so now we had our shellcode an

411
00:19:27,410 --> 00:19:29,660
executable memory and we could use the

412
00:19:29,660 --> 00:19:32,180
treeview in order to execute it so

413
00:19:32,180 --> 00:19:34,580
that's the way it would work in on a

414
00:19:34,580 --> 00:19:39,470
high level now how did we actually used

415
00:19:39,470 --> 00:19:42,740
it so luckily for us Windows Explorer on

416
00:19:42,740 --> 00:19:45,890
win7 has all of these controls that we

417
00:19:45,890 --> 00:19:49,730
need and what's more important Windows

418
00:19:49,730 --> 00:19:52,040
Explorer in the context of this sandbox

419
00:19:52,040 --> 00:19:53,750
was actually treated as a trust

420
00:19:53,750 --> 00:19:56,390
process so that means that if you are

421
00:19:56,390 --> 00:20:00,160
able to inject code into Explorer we win

422
00:20:00,160 --> 00:20:03,320
so the winners Explorer so it has an

423
00:20:03,320 --> 00:20:05,930
added box right merchants which serves

424
00:20:05,930 --> 00:20:08,570
the search bar so it's not strictly an

425
00:20:08,570 --> 00:20:11,660
added box like it's it has a different

426
00:20:11,660 --> 00:20:13,970
windows class but it does support WM

427
00:20:13,970 --> 00:20:16,520
text WM set text with the same semantics

428
00:20:16,520 --> 00:20:18,230
which which is what is what's important

429
00:20:18,230 --> 00:20:22,070
for us so it has also a tree view right

430
00:20:22,070 --> 00:20:24,980
here and it also has a status bar so it

431
00:20:24,980 --> 00:20:27,050
it status bar is actually hidden you

432
00:20:27,050 --> 00:20:29,000
cannot see it but it's there and it's

433
00:20:29,000 --> 00:20:32,600
useful nevertheless and also what was

434
00:20:32,600 --> 00:20:38,660
very important and even crucial was this

435
00:20:38,660 --> 00:20:41,030
Explorer on win7 also contains a

436
00:20:41,030 --> 00:20:44,470
read/write/execute full region of memory

437
00:20:44,470 --> 00:20:47,060
without doing anything special so just a

438
00:20:47,060 --> 00:20:49,280
vanilla Windows 7 will have our double

439
00:20:49,280 --> 00:20:52,970
disk memory in Windows Explorer and now

440
00:20:52,970 --> 00:20:55,370
let's go over the attack sequence in a

441
00:20:55,370 --> 00:20:59,210
bit more detail so we have a shell code

442
00:20:59,210 --> 00:21:02,240
without double nulls we find the

443
00:21:02,240 --> 00:21:04,250
following UI elements in our target

444
00:21:04,250 --> 00:21:07,760
process which is explorer.exe we find an

445
00:21:07,760 --> 00:21:11,900
ID box a treeview and a status bar then

446
00:21:11,900 --> 00:21:15,490
we also find an RW eeks

447
00:21:15,490 --> 00:21:18,460
disputable memory region inside Explorer

448
00:21:18,460 --> 00:21:22,310
by simply iterating over all the memory

449
00:21:22,310 --> 00:21:24,770
regions and checking their protection

450
00:21:24,770 --> 00:21:27,940
sites so now we have this target address

451
00:21:27,940 --> 00:21:32,390
that we define as being in the slag

452
00:21:32,390 --> 00:21:34,100
space like in the end of the memory

453
00:21:34,100 --> 00:21:39,410
region which is all nulls next we

454
00:21:39,410 --> 00:21:41,870
allocate Activa sorts be

455
00:21:41,870 --> 00:21:49,040
struct and initialize it we allocate the

456
00:21:49,040 --> 00:21:50,900
payload buffer which contains both or

457
00:21:50,900 --> 00:21:56,240
shellcode and under struct and we copy

458
00:21:56,240 --> 00:21:58,940
this shellcode into the edit box using

459
00:21:58,940 --> 00:22:03,800
WM set text the Unicode flavor next we

460
00:22:03,800 --> 00:22:06,560
scan the target process to find this

461
00:22:06,560 --> 00:22:07,740
payload

462
00:22:07,740 --> 00:22:14,210
in this dress then we define the the

463
00:22:14,210 --> 00:22:18,810
address of the TV source destruct has

464
00:22:18,810 --> 00:22:20,760
been this initial dress plastered on

465
00:22:20,760 --> 00:22:22,290
line through the shellcode which brings

466
00:22:22,290 --> 00:22:26,790
us here next we migrate the shellcode

467
00:22:26,790 --> 00:22:29,760
executable memory so as I said earlier

468
00:22:29,760 --> 00:22:32,370
we're using the status bar for this so

469
00:22:32,370 --> 00:22:34,830
we're taking we're sending a set text w

470
00:22:34,830 --> 00:22:38,250
message to copy the buffer from this

471
00:22:38,250 --> 00:22:40,020
initial pair of the dress which is null

472
00:22:40,020 --> 00:22:43,890
terminated into the status bar and we

473
00:22:43,890 --> 00:22:46,890
use get text W to copy it to target

474
00:22:46,890 --> 00:22:49,650
address which is now in executable

475
00:22:49,650 --> 00:22:53,220
memory and then finally we have

476
00:22:53,220 --> 00:22:55,890
everything in place and we send the TVM

477
00:22:55,890 --> 00:22:57,030
soldier drewcb

478
00:22:57,030 --> 00:22:59,850
message with the address of our struct

479
00:22:59,850 --> 00:23:02,700
over here and it works we have code

480
00:23:02,700 --> 00:23:08,190
execution now there are two small

481
00:23:08,190 --> 00:23:11,670
pitfalls we need to overcome to actually

482
00:23:11,670 --> 00:23:13,740
veteran eyes it didn't be able to use it

483
00:23:13,740 --> 00:23:16,950
robustly the first one is that actually

484
00:23:16,950 --> 00:23:19,530
the compare function which compares

485
00:23:19,530 --> 00:23:21,750
pairs of elements in the tree view while

486
00:23:21,750 --> 00:23:23,790
sorting can be called multiple times

487
00:23:23,790 --> 00:23:26,460
which is probably not something we

488
00:23:26,460 --> 00:23:28,530
really want we don't really want her

489
00:23:28,530 --> 00:23:30,480
shell code to run multiple times so to

490
00:23:30,480 --> 00:23:34,370
overcome this on 64 bits we simply add

491
00:23:34,370 --> 00:23:38,400
this bit of assembly which repend it to

492
00:23:38,400 --> 00:23:40,140
a shell code which basically overrides

493
00:23:40,140 --> 00:23:42,240
the beginning of itself with the right

494
00:23:42,240 --> 00:23:46,620
instruction it returns immediately the

495
00:23:46,620 --> 00:23:50,370
second pitfall so what so what that

496
00:23:50,370 --> 00:23:52,740
means actually that after the first time

497
00:23:52,740 --> 00:23:54,930
it runs the next time the compare

498
00:23:54,930 --> 00:23:56,400
function is invoked it doesn't do

499
00:23:56,400 --> 00:23:57,870
anything it doesn't run or shell code

500
00:23:57,870 --> 00:24:00,030
instead it simply returns which is what

501
00:24:00,030 --> 00:24:02,630
we want now the second pitfall is that

502
00:24:02,630 --> 00:24:05,700
actually in order to have all the

503
00:24:05,700 --> 00:24:07,890
controls on the windows controls we need

504
00:24:07,890 --> 00:24:10,980
we need a file explorer window to be

505
00:24:10,980 --> 00:24:13,170
open which is not always the case like

506
00:24:13,170 --> 00:24:14,760
there are folks like me using total

507
00:24:14,760 --> 00:24:16,590
commander so they will not have file

508
00:24:16,590 --> 00:24:19,770
explorer windows open at any time so top

509
00:24:19,770 --> 00:24:21,899
comte's

510
00:24:21,899 --> 00:24:24,000
we actually found out that you can use

511
00:24:24,000 --> 00:24:27,600
shall execute and pass it an SW hide

512
00:24:27,600 --> 00:24:29,850
flag so that we can upload file explorer

513
00:24:29,850 --> 00:24:32,789
without the users seen anything and then

514
00:24:32,789 --> 00:24:34,440
we open it and check the shellcode run

515
00:24:34,440 --> 00:24:39,179
it and close the window afterwards so

516
00:24:39,179 --> 00:24:41,279
this is it and then it worked it worked

517
00:24:41,279 --> 00:24:42,809
we were able to break the sandbox were

518
00:24:42,809 --> 00:24:47,750
very happy now on to the second use case

519
00:24:47,750 --> 00:24:50,190
second thing we thought we could do with

520
00:24:50,190 --> 00:24:52,590
this technique is to actually perform

521
00:24:52,590 --> 00:24:55,740
code injection into Explorer that EDRs

522
00:24:55,740 --> 00:24:57,629
will not attack because they're probably

523
00:24:57,629 --> 00:24:59,360
not familiar with this technique and

524
00:24:59,360 --> 00:25:02,159
doesn't do anything suspicious so if

525
00:25:02,159 --> 00:25:07,200
thought it it might fly so and as well

526
00:25:07,200 --> 00:25:10,200
know the challenge with EDRs if we're

527
00:25:10,200 --> 00:25:11,490
talking about college action is that

528
00:25:11,490 --> 00:25:13,769
they're actually very sensitive to

529
00:25:13,769 --> 00:25:16,019
processes open open other processes and

530
00:25:16,019 --> 00:25:19,409
write into their memory etc so I wanted

531
00:25:19,409 --> 00:25:22,100
to implement college action without this

532
00:25:22,100 --> 00:25:25,379
and of course our attacks came to help

533
00:25:25,379 --> 00:25:26,909
once more

534
00:25:26,909 --> 00:25:28,470
the Ross however an extra challenge

535
00:25:28,470 --> 00:25:30,929
since we wanted to do this on Windows 10

536
00:25:30,929 --> 00:25:34,139
this time and the issue now was that

537
00:25:34,139 --> 00:25:36,269
there is actually no read write acts

538
00:25:36,269 --> 00:25:38,429
with memory in Windows Explorer on

539
00:25:38,429 --> 00:25:40,110
Windows 10 which is what you would

540
00:25:40,110 --> 00:25:45,779
expect and now it is the case but we

541
00:25:45,779 --> 00:25:49,200
still had a few ideas so if you remember

542
00:25:49,200 --> 00:25:53,429
we use the TVM so trilled rune CB which

543
00:25:53,429 --> 00:25:55,019
receives a call back to compare function

544
00:25:55,019 --> 00:25:57,779
and then we decided to look into it in a

545
00:25:57,779 --> 00:26:01,049
bit more detail so this is the struct it

546
00:26:01,049 --> 00:26:02,700
has the parent which is subtree we want

547
00:26:02,700 --> 00:26:03,870
to sort it has the compare function

548
00:26:03,870 --> 00:26:06,899
which is or callback and this is the

549
00:26:06,899 --> 00:26:08,879
signature of the compare func so it

550
00:26:08,879 --> 00:26:13,740
receives three arguments the last one is

551
00:26:13,740 --> 00:26:16,230
actually the same l prom from the team

552
00:26:16,230 --> 00:26:18,029
source be strapped so we can control it

553
00:26:18,029 --> 00:26:22,200
easily the other two are the l / am i an

554
00:26:22,200 --> 00:26:25,350
L prom fields of the tree view items

555
00:26:25,350 --> 00:26:28,529
been compared so we could actually

556
00:26:28,529 --> 00:26:31,379
control them as well because we are able

557
00:26:31,379 --> 00:26:33,720
to inject data into the process so we

558
00:26:33,720 --> 00:26:34,590
can inject

559
00:26:34,590 --> 00:26:36,770
a TV item struct into the target process

560
00:26:36,770 --> 00:26:40,799
and then we can we can send the set TV

561
00:26:40,799 --> 00:26:43,770
item message so since we can control the

562
00:26:43,770 --> 00:26:47,279
L params of the tree view we can

563
00:26:47,279 --> 00:26:51,720
actually control these two arguments so

564
00:26:51,720 --> 00:26:53,610
it might be difficult to control their

565
00:26:53,610 --> 00:26:56,220
order because it's difficult to say what

566
00:26:56,220 --> 00:26:58,380
will be the order of the comparisons

567
00:26:58,380 --> 00:27:01,440
that this sorting algorithm does but as

568
00:27:01,440 --> 00:27:03,120
we see in next slide doesn't really

569
00:27:03,120 --> 00:27:06,240
matter so the bottom line is we can call

570
00:27:06,240 --> 00:27:09,500
some function and any function we want

571
00:27:09,500 --> 00:27:12,360
and pass it three arguments we control

572
00:27:12,360 --> 00:27:15,059
or almost control and then we started

573
00:27:15,059 --> 00:27:17,309
looking for function that we can call

574
00:27:17,309 --> 00:27:20,700
this might help us gain some executable

575
00:27:20,700 --> 00:27:26,700
memory to use so the first first one we

576
00:27:26,700 --> 00:27:30,200
thought of was of course we showed a log

577
00:27:30,980 --> 00:27:35,039
so virtual lock looks good the first

578
00:27:35,039 --> 00:27:36,659
three arguments we can control the

579
00:27:36,659 --> 00:27:38,130
problem is the last one which is the

580
00:27:38,130 --> 00:27:39,960
most important one which contains the

581
00:27:39,960 --> 00:27:42,419
protection flags is actually out of a

582
00:27:42,419 --> 00:27:44,549
reach that's the first argument so we

583
00:27:44,549 --> 00:27:50,220
were said the runner-up was we shall

584
00:27:50,220 --> 00:27:53,159
protect so this looked a lot more

585
00:27:53,159 --> 00:27:54,870
promising because actually the first

586
00:27:54,870 --> 00:27:56,520
three arguments are the important ones

587
00:27:56,520 --> 00:27:59,760
the first to identify the memory region

588
00:27:59,760 --> 00:28:02,820
it's offset in size address in size the

589
00:28:02,820 --> 00:28:04,970
third one contains the protection slag

590
00:28:04,970 --> 00:28:08,399
this is good and the last one like it's

591
00:28:08,399 --> 00:28:10,679
simply an out forum to receive the old

592
00:28:10,679 --> 00:28:13,470
protection slugs so we thought ok we'll

593
00:28:13,470 --> 00:28:15,450
person out there or hope just an out

594
00:28:15,450 --> 00:28:20,880
will be passed by itself and then it

595
00:28:20,880 --> 00:28:22,529
would work but unfortunately Microsoft

596
00:28:22,529 --> 00:28:24,750
didn't really want anyone to do that as

597
00:28:24,750 --> 00:28:27,899
the documentation clearly says that if

598
00:28:27,899 --> 00:28:29,669
you pass an all or and involve the dress

599
00:28:29,669 --> 00:28:33,299
the function will fail so we were said

600
00:28:33,299 --> 00:28:37,760
once more now there are a bunch of other

601
00:28:37,760 --> 00:28:41,130
ritual alok or visual protect like

602
00:28:41,130 --> 00:28:43,620
functions a lot more than I expected

603
00:28:43,620 --> 00:28:45,780
and they're all they'll have even more

604
00:28:45,780 --> 00:28:47,100
arguments so

605
00:28:47,100 --> 00:28:53,600
even worse than the first two but then

606
00:28:53,600 --> 00:28:56,640
one of my team members run he had a

607
00:28:56,640 --> 00:28:58,740
bright idea he said okay there's a

608
00:28:58,740 --> 00:29:01,020
function called hip created that creates

609
00:29:01,020 --> 00:29:04,110
a new heap and actually its first

610
00:29:04,110 --> 00:29:07,080
argument has some optional optional

611
00:29:07,080 --> 00:29:09,750
slacks options and one of them is hip

612
00:29:09,750 --> 00:29:11,340
create enable execute which basically

613
00:29:11,340 --> 00:29:14,070
allows the user to create an executable

614
00:29:14,070 --> 00:29:17,010
heap so I guess it might be useful like

615
00:29:17,010 --> 00:29:19,409
for just-in-time compiler stuff like

616
00:29:19,409 --> 00:29:22,049
that and of course it was very useful to

617
00:29:22,049 --> 00:29:24,720
us and since hip create receives free

618
00:29:24,720 --> 00:29:28,220
arguments we were very happy this time

619
00:29:28,220 --> 00:29:34,110
so what we did we actually set all the L

620
00:29:34,110 --> 00:29:36,059
per on fields of all the elements in the

621
00:29:36,059 --> 00:29:38,400
tree view with the value of heap create

622
00:29:38,400 --> 00:29:43,230
enable execute so as you remember that

623
00:29:43,230 --> 00:29:44,880
no mind as a remember the compare

624
00:29:44,880 --> 00:29:47,400
function the first two arguments are the

625
00:29:47,400 --> 00:29:49,350
L params of the tree items being

626
00:29:49,350 --> 00:29:51,539
compared so we said if we cannot really

627
00:29:51,539 --> 00:29:53,640
control the order but we can simply pass

628
00:29:53,640 --> 00:29:55,770
this same value in both of them into

629
00:29:55,770 --> 00:29:59,700
work and then basically were able to

630
00:29:59,700 --> 00:30:04,110
call heap create using the TVM so

631
00:30:04,110 --> 00:30:07,289
treason CB trick and we were able to

632
00:30:07,289 --> 00:30:10,559
create an executable heap which means we

633
00:30:10,559 --> 00:30:13,100
now had read write execute memory and

634
00:30:13,100 --> 00:30:15,450
we're back to the same scenarios on

635
00:30:15,450 --> 00:30:19,650
Windows 7 however it was a nozzle

636
00:30:19,650 --> 00:30:23,030
another small challenge so it turned out

637
00:30:23,030 --> 00:30:28,200
that actually the status bar it does

638
00:30:28,200 --> 00:30:31,559
some filtering basically what it does it

639
00:30:31,559 --> 00:30:34,559
filters the white character counterparts

640
00:30:34,559 --> 00:30:38,520
of the non-printable small ASCII

641
00:30:38,520 --> 00:30:41,539
characters which means that for each

642
00:30:41,539 --> 00:30:44,460
white character of the form B which is

643
00:30:44,460 --> 00:30:49,110
some byte and 0 0 if B is between 1 and

644
00:30:49,110 --> 00:30:52,260
1 F except for 9 which is a tab

645
00:30:52,260 --> 00:30:54,720
character then basically transforms it

646
00:30:54,720 --> 00:30:58,140
into 2000 which is a space character it

647
00:30:58,140 --> 00:31:00,450
does some sensitization

648
00:31:00,450 --> 00:31:04,080
so when we only wanted to as in the

649
00:31:04,080 --> 00:31:05,789
context of the sandbox when you only

650
00:31:05,789 --> 00:31:09,029
wanted to copy a shellcode it was fine

651
00:31:09,029 --> 00:31:10,619
because you know you can craft a

652
00:31:10,619 --> 00:31:13,470
shellcode without special characters of

653
00:31:13,470 --> 00:31:16,230
your choosing but in this case it was a

654
00:31:16,230 --> 00:31:18,330
problem and another problem was that we

655
00:31:18,330 --> 00:31:23,549
also had some double nos or even four

656
00:31:23,549 --> 00:31:26,220
consecutive nails that were that we

657
00:31:26,220 --> 00:31:28,470
needed to pass around this part of the

658
00:31:28,470 --> 00:31:31,139
struct for setting the helper arms in

659
00:31:31,139 --> 00:31:34,710
the tree view etc so what we did in

660
00:31:34,710 --> 00:31:36,690
order to overcome this is to actually

661
00:31:36,690 --> 00:31:42,059
come up with a very careful procedure

662
00:31:42,059 --> 00:31:45,029
for copying data into the process

663
00:31:45,029 --> 00:31:48,359
through the Edit box in status bar so

664
00:31:48,359 --> 00:31:52,489
more concretely in order to overcome

665
00:31:52,489 --> 00:31:56,960
multiple consecutive nulls we actually

666
00:31:56,960 --> 00:32:00,179
found when we looked for an executable

667
00:32:00,179 --> 00:32:02,639
memory region and we made sure that we

668
00:32:02,639 --> 00:32:05,759
find the region which contains which is

669
00:32:05,759 --> 00:32:09,090
all zeros which was very easy because we

670
00:32:09,090 --> 00:32:10,980
used to create to contain it so the heap

671
00:32:10,980 --> 00:32:12,419
was zeroed first

672
00:32:12,419 --> 00:32:15,299
and then if we needed to copy a bunch of

673
00:32:15,299 --> 00:32:18,480
nulls would simply escape to the offset

674
00:32:18,480 --> 00:32:20,759
after in the else don't you need to copy

675
00:32:20,759 --> 00:32:23,129
them they're already there now in order

676
00:32:23,129 --> 00:32:25,590
to overcome the filtering by the status

677
00:32:25,590 --> 00:32:28,399
bar we did the following so let's assume

678
00:32:28,399 --> 00:32:30,960
this is the source buffer want to copy

679
00:32:30,960 --> 00:32:34,679
so AABB can be copied nicely but 0 5 0 0

680
00:32:34,679 --> 00:32:38,190
will be sanitized to 2000 which is bad

681
00:32:38,190 --> 00:32:42,960
and thence this is also fun and etc so

682
00:32:42,960 --> 00:32:45,659
we would first copy a IBB to offset 0 in

683
00:32:45,659 --> 00:32:49,200
target which works but then instead of

684
00:32:49,200 --> 00:32:51,779
copying in 0 5 0 0 which would be

685
00:32:51,779 --> 00:32:56,220
filtered we actually copy vb 0 5 again

686
00:32:56,220 --> 00:32:58,409
to offset 1 and it would look like this

687
00:32:58,409 --> 00:33:01,679
so we override the BB character again

688
00:33:01,679 --> 00:33:05,100
but doesn't really it's there's no

689
00:33:05,100 --> 00:33:08,820
problem with that so we now have 0 5 and

690
00:33:08,820 --> 00:33:11,879
then we jump to copying 0 0 CC 2 of the

691
00:33:11,879 --> 00:33:13,960
3 so eventually we have the

692
00:33:13,960 --> 00:33:17,559
entire source buffer copied so basically

693
00:33:17,559 --> 00:33:20,020
in order to copy a filtered white

694
00:33:20,020 --> 00:33:22,809
character of the form b00 first copy B

695
00:33:22,809 --> 00:33:24,730
with the previous one and then we copied

696
00:33:24,730 --> 00:33:29,980
0-0 with the next one and basically that

697
00:33:29,980 --> 00:33:34,529
was 8 now it worked so we were able to

698
00:33:34,529 --> 00:33:37,720
set up all the memory and target process

699
00:33:37,720 --> 00:33:40,480
in order to invoke hit create with the

700
00:33:40,480 --> 00:33:42,880
correct parameters and then once we

701
00:33:42,880 --> 00:33:45,760
called it we had our W keys memory and

702
00:33:45,760 --> 00:33:48,850
then it was back to the win 7 scenario

703
00:33:48,850 --> 00:33:51,100
that we already talked about and we were

704
00:33:51,100 --> 00:33:57,159
able to inject code into Explorer now

705
00:33:57,159 --> 00:34:00,039
just to give you a glimpse of how it

706
00:34:00,039 --> 00:34:02,890
looked like when the EDR was looking at

707
00:34:02,890 --> 00:34:05,440
our at us doing this so this is really

708
00:34:05,440 --> 00:34:09,599
our so just to create a baseline for the

709
00:34:09,599 --> 00:34:14,050
for this test we did a good old create

710
00:34:14,050 --> 00:34:15,820
remote thread load library just to see

711
00:34:15,820 --> 00:34:18,190
that the alert is triggered so it

712
00:34:18,190 --> 00:34:20,560
shouted you know alert severity and

713
00:34:20,560 --> 00:34:23,409
inject inject code and now nap etc and

714
00:34:23,409 --> 00:34:26,500
those are the low-level events and this

715
00:34:26,500 --> 00:34:28,719
is the high level alert the application

716
00:34:28,719 --> 00:34:30,580
injector injected code into system

717
00:34:30,580 --> 00:34:33,629
process as we would expect from any

718
00:34:33,629 --> 00:34:38,889
self-respecting EDR then we used our

719
00:34:38,889 --> 00:34:41,699
injector which is shatter eggs over here

720
00:34:41,699 --> 00:34:45,489
so there are no alerts so we don't show

721
00:34:45,489 --> 00:34:49,089
it now there are a few events here but

722
00:34:49,089 --> 00:34:51,429
there isn't for this mainly is because

723
00:34:51,429 --> 00:34:53,589
we implemented the proof-of-concept in

724
00:34:53,589 --> 00:34:55,960
Python used by to exit to package it so

725
00:34:55,960 --> 00:34:58,480
the first all but the last event here

726
00:34:58,480 --> 00:35:01,300
actually caused by PI to eggs and doing

727
00:35:01,300 --> 00:35:04,720
stuff and last one is actually not in

728
00:35:04,720 --> 00:35:06,849
process so if you remember we did use

729
00:35:06,849 --> 00:35:09,400
open process to open the target process

730
00:35:09,400 --> 00:35:13,300
Explorer for reading so this is dr did

731
00:35:13,300 --> 00:35:15,250
complain about this but didn't sound

732
00:35:15,250 --> 00:35:22,109
alert so we consider it to success yeah

733
00:35:22,109 --> 00:35:25,210
okay so we're almost done so let's do a

734
00:35:25,210 --> 00:35:27,120
quick recap

735
00:35:27,120 --> 00:35:30,670
so we took a very old security-related

736
00:35:30,670 --> 00:35:34,840
design issue in Windows that wasn't

737
00:35:34,840 --> 00:35:38,440
really fixed so fixes in Vista please

738
00:35:38,440 --> 00:35:42,100
contain it but the root cause for this

739
00:35:42,100 --> 00:35:44,380
for the shatter attack wasn't really

740
00:35:44,380 --> 00:35:46,390
addressed so in the root cause is the

741
00:35:46,390 --> 00:35:49,660
fact that pointers been passed in

742
00:35:49,660 --> 00:35:52,150
Windows messages are a giant mess so you

743
00:35:52,150 --> 00:35:55,030
have pointers for some messages that are

744
00:35:55,030 --> 00:35:56,980
actually treated as strings and they're

745
00:35:56,980 --> 00:35:59,220
serialized and copied to target process

746
00:35:59,220 --> 00:36:02,610
you have pointers to strings that are

747
00:36:02,610 --> 00:36:06,580
simply treated as pointer to data in the

748
00:36:06,580 --> 00:36:09,550
remote process which helped us migrate

749
00:36:09,550 --> 00:36:11,470
the shellcode from one place to another

750
00:36:11,470 --> 00:36:14,560
and sometimes which is the most

751
00:36:14,560 --> 00:36:17,140
dangerous thing you have pointers you

752
00:36:17,140 --> 00:36:20,620
have a sudden you have arguments to

753
00:36:20,620 --> 00:36:22,660
Windows messages which are actually

754
00:36:22,660 --> 00:36:24,460
passed around and they're treated as

755
00:36:24,460 --> 00:36:27,760
pointers to callback callbacks in the

756
00:36:27,760 --> 00:36:29,920
target process that are simply executed

757
00:36:29,920 --> 00:36:31,330
and you can give any address you want

758
00:36:31,330 --> 00:36:34,450
and to get executed so the combination

759
00:36:34,450 --> 00:36:36,850
of them gave us all the primitives we

760
00:36:36,850 --> 00:36:40,060
needed to implement code injection so we

761
00:36:40,060 --> 00:36:42,400
could allocate read write execute memory

762
00:36:42,400 --> 00:36:46,030
using hit create you couldn't write to

763
00:36:46,030 --> 00:36:48,250
an arbitrary address we can mine we can

764
00:36:48,250 --> 00:36:50,650
copy code around from place to place and

765
00:36:50,650 --> 00:36:53,440
we couldn't execute a specific point

766
00:36:53,440 --> 00:36:56,140
where we wanted which is more than you

767
00:36:56,140 --> 00:36:59,200
actually need and now in terms of

768
00:36:59,200 --> 00:37:02,290
possible implications for this sub the

769
00:37:02,290 --> 00:37:04,150
most trivial one would be to say okay

770
00:37:04,150 --> 00:37:07,090
let's hook send message and and block

771
00:37:07,090 --> 00:37:09,670
the dangerous Windows messages or

772
00:37:09,670 --> 00:37:11,710
sanitize the callbacks or some like that

773
00:37:11,710 --> 00:37:14,170
the problem is that use remote hooks

774
00:37:14,170 --> 00:37:17,290
like we said and not really could not

775
00:37:17,290 --> 00:37:19,000
really treat it as a security mechanism

776
00:37:19,000 --> 00:37:24,370
because they can be disabled but luckily

777
00:37:24,370 --> 00:37:28,600
for us Windows actually does provide a

778
00:37:28,600 --> 00:37:31,840
very robust method for filtering Windows

779
00:37:31,840 --> 00:37:33,880
messages which is the set windows houki

780
00:37:33,880 --> 00:37:39,960
acts api with the appropriate wh

781
00:37:40,590 --> 00:37:43,440
types I wouldn't implemented but it

782
00:37:43,440 --> 00:37:46,770
should work so I think that that would

783
00:37:46,770 --> 00:37:51,420
be like the best mitigation for this and

784
00:37:51,420 --> 00:37:55,010
now let's see a demo I hope it works

785
00:37:57,080 --> 00:38:02,040
okay so you have your VM we're going to

786
00:38:02,040 --> 00:38:04,020
run shatter run from Explorer which

787
00:38:04,020 --> 00:38:07,230
should run someone explorer now that the

788
00:38:07,230 --> 00:38:08,430
sample shell code you'll see now

789
00:38:08,430 --> 00:38:10,620
basically all it does is pop up a

790
00:38:10,620 --> 00:38:13,190
message box just so that you can show

791
00:38:13,190 --> 00:38:15,540
and demonstrate this message box is

792
00:38:15,540 --> 00:38:20,280
actually opened from Windows Explorer so

793
00:38:20,280 --> 00:38:23,820
let's run it hope for the best because

794
00:38:23,820 --> 00:38:26,900
so it says that of course didn't work

795
00:38:26,900 --> 00:38:35,820
let's try this again okay not work so it

796
00:38:35,820 --> 00:38:37,500
says that no read/write/execute memory

797
00:38:37,500 --> 00:38:42,030
was found so it created it it's actually

798
00:38:42,030 --> 00:38:43,890
sound man I feel it I'm a dog the

799
00:38:43,890 --> 00:38:47,700
message box is here the Explorer does so

800
00:38:47,700 --> 00:38:52,350
if you take spy plus plus yeah fine some

801
00:38:52,350 --> 00:38:55,320
people in below that and go to the

802
00:38:55,320 --> 00:39:02,250
process spies a bit slow and it's empty

803
00:39:02,250 --> 00:39:03,570
no nice ocean yacht

804
00:39:03,570 --> 00:39:09,480
I do need some help alright so you see

805
00:39:09,480 --> 00:39:12,090
this this is open from Explorer so what

806
00:39:12,090 --> 00:39:14,310
happens now is actually since our code

807
00:39:14,310 --> 00:39:17,390
and send message with a certain message

808
00:39:17,390 --> 00:39:20,580
actually ways for the code for the shell

809
00:39:20,580 --> 00:39:24,450
code we call because the Explorer is

810
00:39:24,450 --> 00:39:25,800
currently trying to sort it in this

811
00:39:25,800 --> 00:39:28,170
stuck in the callback so good okay

812
00:39:28,170 --> 00:39:31,170
finishes you're all good obviously we

813
00:39:31,170 --> 00:39:34,740
can put any shell code we want there the

814
00:39:34,740 --> 00:39:36,810
shell code would probably want to use it

815
00:39:36,810 --> 00:39:38,760
for real probably often a new thread and

816
00:39:38,760 --> 00:39:40,710
then execute in it so it doesn't block

817
00:39:40,710 --> 00:39:47,400
anything but you get the idea okay look

818
00:39:47,400 --> 00:39:50,340
here we're actually done so thank you

819
00:39:50,340 --> 00:39:53,160
very much this is my email you can scan

820
00:39:53,160 --> 00:39:54,360
this QR code

821
00:39:54,360 --> 00:39:56,790
it also contains my email so if you have

822
00:39:56,790 --> 00:39:59,190
any questions suggestions remark I'd be

823
00:39:59,190 --> 00:40:01,430
very glad to hear them send me a line

824
00:40:01,430 --> 00:40:04,730
thank you very much

