1
00:00:00,000 --> 00:00:02,520
all of us in our next talk by Sophia

2
00:00:02,520 --> 00:00:06,089
Valley covet ski is it about another

3
00:00:06,089 --> 00:00:07,890
subject that is going to take more and

4
00:00:07,890 --> 00:00:10,230
more significance in our lives and that

5
00:00:10,230 --> 00:00:11,599
is the relationship between

6
00:00:11,599 --> 00:00:14,400
virtualization environments and

7
00:00:14,400 --> 00:00:16,980
underlying hardware and the title of our

8
00:00:16,980 --> 00:00:20,369
talk is the butterfly effect actively

9
00:00:20,369 --> 00:00:22,560
manipulating VMs through hypervisor

10
00:00:22,560 --> 00:00:28,859
intro introspection yet is so a round of

11
00:00:28,859 --> 00:00:32,009
applause first of all and the

12
00:00:32,009 --> 00:00:36,510
traditional Cheers

13
00:00:36,510 --> 00:00:40,379
welcome to besides Sophie let's all have

14
00:00:40,379 --> 00:00:42,870
fun with the butterfly effect please

15
00:00:42,870 --> 00:00:43,950
take your seats

16
00:00:43,950 --> 00:01:00,539
Sophie the stage is yours after after a

17
00:01:00,539 --> 00:01:02,879
turn in the chaos theory that says that

18
00:01:02,879 --> 00:01:06,090
even minor changes in the right time can

19
00:01:06,090 --> 00:01:13,770
cause can cause big consequences and the

20
00:01:13,770 --> 00:01:17,340
example it's usually given is that even

21
00:01:17,340 --> 00:01:19,650
the butterfly flapping its wings on one

22
00:01:19,650 --> 00:01:22,170
side of the world in the right time can

23
00:01:22,170 --> 00:01:25,830
cause a storm on the other side of the

24
00:01:25,830 --> 00:01:28,020
world so it's very similar to what we're

25
00:01:28,020 --> 00:01:32,310
going to show how a by manipulating

26
00:01:32,310 --> 00:01:35,220
single values in the memory of the

27
00:01:35,220 --> 00:01:46,649
hypervisor itself we can okay so how by

28
00:01:46,649 --> 00:01:48,540
in manipulating values in the hypervisor

29
00:01:48,540 --> 00:01:50,399
itself in the memory of the hypervisor

30
00:01:50,399 --> 00:01:54,869
we can lead to big results and in the

31
00:01:54,869 --> 00:01:58,200
virtual machines and such as even

32
00:01:58,200 --> 00:02:01,799
stopping cyber attacks so a bit about

33
00:02:01,799 --> 00:02:06,240
myself a really big photo

34
00:02:06,240 --> 00:02:09,479
so I have over 10 years of experience in

35
00:02:09,479 --> 00:02:12,180
the cybersecurity and cyber intelligence

36
00:02:12,180 --> 00:02:15,420
space and currently I'm in the final

37
00:02:15,420 --> 00:02:17,670
stage of finishing my PhD in the Ben

38
00:02:17,670 --> 00:02:21,660
Gurion University in Israel and today

39
00:02:21,660 --> 00:02:23,700
I'm going to talk about a challenge that

40
00:02:23,700 --> 00:02:27,000
we had in one of our recent projects so

41
00:02:27,000 --> 00:02:32,250
in we had in our level we had a huge

42
00:02:32,250 --> 00:02:35,730
private a cloud environment and most of

43
00:02:35,730 --> 00:02:37,230
the virtual machines running on this

44
00:02:37,230 --> 00:02:39,690
environment where ours were fully under

45
00:02:39,690 --> 00:02:42,330
our control but some of the virtual

46
00:02:42,330 --> 00:02:44,700
machines were provided by external

47
00:02:44,700 --> 00:02:47,130
vendors and were meant to function as a

48
00:02:47,130 --> 00:02:47,820
black box

49
00:02:47,820 --> 00:02:50,300
at least from the security point of view

50
00:02:50,300 --> 00:02:53,820
an example of such a VM is a virtual

51
00:02:53,820 --> 00:02:56,550
router it was meant to be placed as is

52
00:02:56,550 --> 00:02:58,680
in our environment of course configured

53
00:02:58,680 --> 00:03:02,400
correctly and just to run we can't

54
00:03:02,400 --> 00:03:03,959
really connect to it directly

55
00:03:03,959 --> 00:03:08,040
we can't force the vendor to install any

56
00:03:08,040 --> 00:03:11,640
of our security agents inside and

57
00:03:11,640 --> 00:03:13,980
practically we're blind to what's really

58
00:03:13,980 --> 00:03:17,370
going on inside the virtual machine and

59
00:03:17,370 --> 00:03:20,040
this problem is actually very popular

60
00:03:20,040 --> 00:03:21,930
and of course it's the same thing in

61
00:03:21,930 --> 00:03:25,380
public cloud infrastructures where let's

62
00:03:25,380 --> 00:03:27,570
say Amazon is providing the

63
00:03:27,570 --> 00:03:29,549
infrastructure and the environment but

64
00:03:29,549 --> 00:03:31,620
the virtual machine that we are using

65
00:03:31,620 --> 00:03:33,420
they are not connecting to them directly

66
00:03:33,420 --> 00:03:35,730
they're not forcing us to install

67
00:03:35,730 --> 00:03:39,690
anything inside and what they are doing

68
00:03:39,690 --> 00:03:42,510
right now in order to and in order to

69
00:03:42,510 --> 00:03:44,989
see what's going on is practically only

70
00:03:44,989 --> 00:03:48,320
monitoring the network communication

71
00:03:48,320 --> 00:03:52,170
looking what's going on and what's going

72
00:03:52,170 --> 00:03:53,670
into the machine and what's going on

73
00:03:53,670 --> 00:03:55,230
from the machine and trying to find

74
00:03:55,230 --> 00:03:59,190
Network anomalies and that what's going

75
00:03:59,190 --> 00:04:01,980
on and this was what we did in our

76
00:04:01,980 --> 00:04:04,709
network but we wanted to challenge

77
00:04:04,709 --> 00:04:07,230
ourselves we decided this is not enough

78
00:04:07,230 --> 00:04:10,680
and we wanted to find a solution under

79
00:04:10,680 --> 00:04:13,320
the following limitations so one we

80
00:04:13,320 --> 00:04:17,599
cannot connect to the virtual machine

81
00:04:23,810 --> 00:04:28,380
okay okay

82
00:04:28,380 --> 00:04:31,290
and the second thing that we can't

83
00:04:31,290 --> 00:04:33,930
install any agent inside and the third

84
00:04:33,930 --> 00:04:35,760
thing that we do not want to rely only

85
00:04:35,760 --> 00:04:37,830
on the network communication on the

86
00:04:37,830 --> 00:04:41,460
external network communication so we

87
00:04:41,460 --> 00:04:43,640
started reading about it and pretty

88
00:04:43,640 --> 00:04:46,650
right away we came to this really big

89
00:04:46,650 --> 00:04:51,270
body of work of research around how how

90
00:04:51,270 --> 00:04:52,680
to understand what's going on inside

91
00:04:52,680 --> 00:04:54,570
your virtual machine from the outside

92
00:04:54,570 --> 00:04:57,390
only for monitoring the network and the

93
00:04:57,390 --> 00:05:01,440
memory and the basic idea behind this

94
00:05:01,440 --> 00:05:04,410
body of work is do not try to secure

95
00:05:04,410 --> 00:05:06,180
your virtual machine it's the same way

96
00:05:06,180 --> 00:05:07,760
you try to secure your physical

97
00:05:07,760 --> 00:05:10,470
workstations here you have an additional

98
00:05:10,470 --> 00:05:12,920
layer the layer of virtualization and

99
00:05:12,920 --> 00:05:15,480
let's take advantage of this layer to

100
00:05:15,480 --> 00:05:21,030
enhance our security and so this talk is

101
00:05:21,030 --> 00:05:24,180
about that is about our thinking process

102
00:05:24,180 --> 00:05:26,250
and how we took advantage of this

103
00:05:26,250 --> 00:05:30,180
ability how we build a security strategy

104
00:05:30,180 --> 00:05:35,550
of both in identifying the threat to

105
00:05:35,550 --> 00:05:37,440
security threats inside our virtual

106
00:05:37,440 --> 00:05:40,650
machines and remediating them from the

107
00:05:40,650 --> 00:05:46,280
outside and ok so let's talk about the

108
00:05:46,280 --> 00:05:49,320
dis virtualization layer so the main

109
00:05:49,320 --> 00:05:51,480
component of the virtualization layer is

110
00:05:51,480 --> 00:05:55,470
the hypervisor and which and we have two

111
00:05:55,470 --> 00:05:58,350
types of hypervisors the first type is a

112
00:05:58,350 --> 00:06:00,950
native hypervisor or bare-metal and

113
00:06:00,950 --> 00:06:04,680
which which runs directly on the

114
00:06:04,680 --> 00:06:07,890
hardware the hypervisors job is to

115
00:06:07,890 --> 00:06:11,100
manage and to stop and run the virtual

116
00:06:11,100 --> 00:06:13,340
machines that are running on top of it

117
00:06:13,340 --> 00:06:19,200
so this is a popular architecture where

118
00:06:19,200 --> 00:06:21,420
the hypervisor is running on top of the

119
00:06:21,420 --> 00:06:24,030
hard way of the hardware and an example

120
00:06:24,030 --> 00:06:27,480
of such hypervisors is es6 and hyper-v

121
00:06:27,480 --> 00:06:30,090
and this is usually

122
00:06:30,090 --> 00:06:32,220
more expensive and the second

123
00:06:32,220 --> 00:06:35,610
architecture is the hosted hypervisor

124
00:06:35,610 --> 00:06:38,040
which is running is an application on

125
00:06:38,040 --> 00:06:40,320
top of the existing operating system

126
00:06:40,320 --> 00:06:42,870
it runs the virtual machines on top of

127
00:06:42,870 --> 00:06:47,479
it and this is usually a cheaper setup

128
00:06:47,479 --> 00:06:50,280
and this was a set up in our private

129
00:06:50,280 --> 00:06:52,440
cloud environment and the hypervisor

130
00:06:52,440 --> 00:06:57,150
that we used is the k vm so when looking

131
00:06:57,150 --> 00:07:00,030
at this architecture and security

132
00:07:00,030 --> 00:07:02,520
research found that straight away that

133
00:07:02,520 --> 00:07:04,050
there is something interesting in the

134
00:07:04,050 --> 00:07:07,650
memory just because the virtual machines

135
00:07:07,650 --> 00:07:10,620
are running on top of the hypervisor the

136
00:07:10,620 --> 00:07:12,750
memory of the virtual machine signs

137
00:07:12,750 --> 00:07:14,700
within the memory space of the

138
00:07:14,700 --> 00:07:17,220
hypervisor meaning that by correctly

139
00:07:17,220 --> 00:07:20,760
parsing this memory we can understand

140
00:07:20,760 --> 00:07:22,889
what's going on inside each of the

141
00:07:22,889 --> 00:07:25,229
virtual machines and this is exactly

142
00:07:25,229 --> 00:07:28,740
what we wanted so what are we going to

143
00:07:28,740 --> 00:07:37,020
do with this ability ok so what we're

144
00:07:37,020 --> 00:07:40,889
going to do with the stability and so

145
00:07:40,889 --> 00:07:43,710
first of all and we started thinking ok

146
00:07:43,710 --> 00:07:45,360
this is great this is exactly what we

147
00:07:45,360 --> 00:07:46,860
want we want to see what's going on

148
00:07:46,860 --> 00:07:49,289
inside the virtual machines maybe

149
00:07:49,289 --> 00:07:51,389
someone already did it so maybe we don't

150
00:07:51,389 --> 00:07:55,050
need to do the hard work so we looked

151
00:07:55,050 --> 00:07:58,169
for commercial tools that are actually

152
00:07:58,169 --> 00:08:00,240
doing hypervisor introspection and they

153
00:08:00,240 --> 00:08:02,310
thought the only thing that we found was

154
00:08:02,310 --> 00:08:05,729
the BitDefender tool but it focuses only

155
00:08:05,729 --> 00:08:09,630
on mainly on es6 and of course we have

156
00:08:09,630 --> 00:08:12,990
the KVM hypervisor and it's not not

157
00:08:12,990 --> 00:08:16,050
suitable for that so this means we need

158
00:08:16,050 --> 00:08:19,500
to do it ourselves and then we looked at

159
00:08:19,500 --> 00:08:22,110
the research ok what other researchers

160
00:08:22,110 --> 00:08:26,810
doing so a lot of the work is focused on

161
00:08:26,810 --> 00:08:29,160
monitoring the network the memory in

162
00:08:29,160 --> 00:08:31,200
order to find a security threat so ok

163
00:08:31,200 --> 00:08:33,330
this is very interesting which we wanted

164
00:08:33,330 --> 00:08:35,549
to start with something simple so

165
00:08:35,549 --> 00:08:37,500
because of the because all the virtual

166
00:08:37,500 --> 00:08:38,789
machines that are running in our

167
00:08:38,789 --> 00:08:40,890
environment we want to monitor that are

168
00:08:40,890 --> 00:08:42,539
really interesting we don't have any

169
00:08:42,539 --> 00:08:43,210
access to

170
00:08:43,210 --> 00:08:46,899
are provided by the vendors they also

171
00:08:46,899 --> 00:08:49,089
are pretty much predictable that there

172
00:08:49,089 --> 00:08:50,860
are services that are running and we

173
00:08:50,860 --> 00:08:53,110
know what is actually going on inside

174
00:08:53,110 --> 00:08:56,380
all we can guess so the first thing that

175
00:08:56,380 --> 00:09:00,160
we wanted to implement was a white

176
00:09:00,160 --> 00:09:02,260
listing of running processes we will

177
00:09:02,260 --> 00:09:05,380
have some pre-prepared a list what

178
00:09:05,380 --> 00:09:10,000
should run and and we will monitor every

179
00:09:10,000 --> 00:09:12,970
new process and and see if it matches

180
00:09:12,970 --> 00:09:18,459
this list so let's talk about how it's

181
00:09:18,459 --> 00:09:22,870
actually done so if I could write an

182
00:09:22,870 --> 00:09:25,480
agent this will be pretty much the logic

183
00:09:25,480 --> 00:09:27,850
behind this agent and we just go through

184
00:09:27,850 --> 00:09:29,950
all the running processes I will find

185
00:09:29,950 --> 00:09:31,570
out the information that is relevant

186
00:09:31,570 --> 00:09:34,330
that they want to let identifies this

187
00:09:34,330 --> 00:09:37,149
process and I will check it against a

188
00:09:37,149 --> 00:09:40,870
predefined list but by looking only on

189
00:09:40,870 --> 00:09:43,839
the memory I have this huge blob of it

190
00:09:43,839 --> 00:09:47,140
of memory and I'm losing all them and

191
00:09:47,140 --> 00:09:49,720
all the capabilities of the operating

192
00:09:49,720 --> 00:09:52,540
system is providing for me so what I'm

193
00:09:52,540 --> 00:09:55,330
losing just by looking at this blob not

194
00:09:55,330 --> 00:09:57,339
by running inside the operating system

195
00:09:57,339 --> 00:10:00,820
is of course they can't run any of the

196
00:10:00,820 --> 00:10:03,820
API so the operating system I cannot

197
00:10:03,820 --> 00:10:07,209
rely on any security events or operating

198
00:10:07,209 --> 00:10:10,060
system events and the most important

199
00:10:10,060 --> 00:10:13,170
thing that used to really appreciate is

200
00:10:13,170 --> 00:10:16,300
the translation of the physical and

201
00:10:16,300 --> 00:10:20,950
virtual addresses and as you recall the

202
00:10:20,950 --> 00:10:24,100
addresses in memory are virtual and I

203
00:10:24,100 --> 00:10:26,529
really need the physical the physical

204
00:10:26,529 --> 00:10:33,550
address in order to get the data so what

205
00:10:33,550 --> 00:10:34,240
am I missing

206
00:10:34,240 --> 00:10:36,279
what do I need to know in order to

207
00:10:36,279 --> 00:10:39,370
implement this so we started working on

208
00:10:39,370 --> 00:10:43,810
a Linux in Linux operating system and in

209
00:10:43,810 --> 00:10:46,020
Linux the running processes is a

210
00:10:46,020 --> 00:10:52,170
circular circular double linked list of

211
00:10:52,170 --> 00:10:56,600
task struct structures

212
00:10:56,600 --> 00:10:59,810
every data structure and has the

213
00:10:59,810 --> 00:11:01,590
information that I need in order to

214
00:11:01,590 --> 00:11:06,060
identify a process and the beginning of

215
00:11:06,060 --> 00:11:09,060
this list is a kernel simple that's

216
00:11:09,060 --> 00:11:13,170
called any task and so I need several

217
00:11:13,170 --> 00:11:15,420
things in order to do this first of all

218
00:11:15,420 --> 00:11:20,130
I need to know and what is the virtual

219
00:11:20,130 --> 00:11:23,460
address of any task then when I know I

220
00:11:23,460 --> 00:11:25,650
need to turn translator to the physical

221
00:11:25,650 --> 00:11:27,960
address to know we're in this huge blob

222
00:11:27,960 --> 00:11:30,990
of memory is the actual beginning of any

223
00:11:30,990 --> 00:11:35,130
task then I need to take every task and

224
00:11:35,130 --> 00:11:39,590
cast it into the right construct a

225
00:11:39,590 --> 00:11:42,960
structure according to the right Linux

226
00:11:42,960 --> 00:11:45,840
version of course and retrieve the

227
00:11:45,840 --> 00:11:49,850
information that I need to find the next

228
00:11:49,850 --> 00:11:53,070
task the virtual address of next task

229
00:11:53,070 --> 00:11:57,890
and do this whole process all over again

230
00:11:57,890 --> 00:12:02,040
so thank God I didn't have to do it by

231
00:12:02,040 --> 00:12:02,640
myself

232
00:12:02,640 --> 00:12:06,030
of course there is a tool and it's a

233
00:12:06,030 --> 00:12:08,400
it's been a it's been here for a while

234
00:12:08,400 --> 00:12:11,100
so maybe most of you already familiar

235
00:12:11,100 --> 00:12:14,040
with it and so there's a totally PMI and

236
00:12:14,040 --> 00:12:17,250
github and it's and it's a sea library

237
00:12:17,250 --> 00:12:21,330
that runs on the host and it queries the

238
00:12:21,330 --> 00:12:25,460
hypervisor and its main job is to

239
00:12:25,460 --> 00:12:28,110
translate between the physical and the

240
00:12:28,110 --> 00:12:30,270
virtual addresses of each virtual

241
00:12:30,270 --> 00:12:36,240
machine and right now it supports

242
00:12:36,240 --> 00:12:42,030
kayvyun and then hypervisors but and but

243
00:12:42,030 --> 00:12:44,970
it's in development still and it's post

244
00:12:44,970 --> 00:12:47,700
multiple a guest operating system so

245
00:12:47,700 --> 00:12:49,430
this is exactly what I wanted and this

246
00:12:49,430 --> 00:12:53,550
and we've used this a library and the

247
00:12:53,550 --> 00:12:55,650
thing that we need to provide to this

248
00:12:55,650 --> 00:12:57,300
library in order for it to work is two

249
00:12:57,300 --> 00:12:59,520
things so first of all we need to

250
00:12:59,520 --> 00:13:01,320
provide some kind of a mapping between

251
00:13:01,320 --> 00:13:04,950
kernel symbols that we rely on and their

252
00:13:04,950 --> 00:13:09,690
virtual address and the two ways to do

253
00:13:09,690 --> 00:13:11,340
this is look at the easy way and the

254
00:13:11,340 --> 00:13:15,210
hard way of course and the easy way is

255
00:13:15,210 --> 00:13:19,080
is a bit of cheating so either you have

256
00:13:19,080 --> 00:13:21,660
to run like a script once on this

257
00:13:21,660 --> 00:13:23,730
virtual machine to get this mapping or

258
00:13:23,730 --> 00:13:26,730
you can ask the vendor of course you can

259
00:13:26,730 --> 00:13:29,490
do both so easier is not not really an

260
00:13:29,490 --> 00:13:32,490
option and the hard way is to look at

261
00:13:32,490 --> 00:13:34,370
the memory and you Rishta cailli and

262
00:13:34,370 --> 00:13:39,050
find the process list and and then to

263
00:13:39,050 --> 00:13:42,440
find the beginning of the init task and

264
00:13:42,440 --> 00:13:45,570
this is what we did of course and the

265
00:13:45,570 --> 00:13:46,890
second thing that you need to do is

266
00:13:46,890 --> 00:13:52,590
provide the right and the right header

267
00:13:52,590 --> 00:13:56,160
files for the kernel simple structures

268
00:13:56,160 --> 00:13:59,430
for the specific virtual machine that

269
00:13:59,430 --> 00:14:03,390
you are running on and but if you're

270
00:14:03,390 --> 00:14:05,280
going to do it either way just just so

271
00:14:05,280 --> 00:14:07,530
you know you can just take the system

272
00:14:07,530 --> 00:14:09,570
map file from your computer from the

273
00:14:09,570 --> 00:14:12,030
inside the virtual machine which is just

274
00:14:12,030 --> 00:14:14,160
a mapping of caramel symbols and their

275
00:14:14,160 --> 00:14:19,380
virtual addresses and just in its apply

276
00:14:19,380 --> 00:14:23,190
it to the lip vmi and the way Olivia

277
00:14:23,190 --> 00:14:27,480
your mind works is it receives all the

278
00:14:27,480 --> 00:14:29,910
kernel symbol mappings it takes the

279
00:14:29,910 --> 00:14:33,090
right virtual addresses it travels then

280
00:14:33,090 --> 00:14:36,270
a page table and the page directory it

281
00:14:36,270 --> 00:14:38,700
retrieves the right page that is needed

282
00:14:38,700 --> 00:14:42,120
it gives it that to the application the

283
00:14:42,120 --> 00:14:44,580
application takes this big blob of

284
00:14:44,580 --> 00:14:48,750
memory cast it to the right structure

285
00:14:48,750 --> 00:14:50,940
that we have provided before takes the

286
00:14:50,940 --> 00:14:53,100
information that is needed and moves on

287
00:14:53,100 --> 00:14:58,110
and the way it looks it's a it's really

288
00:14:58,110 --> 00:15:01,590
like a textbook example of Libby mi this

289
00:15:01,590 --> 00:15:04,740
is from within the virtual machine it's

290
00:15:04,740 --> 00:15:07,320
running the PS after Isis agent inside

291
00:15:07,320 --> 00:15:10,290
and you can see that we we get all the

292
00:15:10,290 --> 00:15:11,820
information about the process we have

293
00:15:11,820 --> 00:15:13,920
this like demo malware process running

294
00:15:13,920 --> 00:15:16,560
inside and this is what we're getting

295
00:15:16,560 --> 00:15:18,720
from the outside without supplying any

296
00:15:18,720 --> 00:15:21,630
password of the virtual machine just by

297
00:15:21,630 --> 00:15:22,870
monitoring the memory

298
00:15:22,870 --> 00:15:25,000
over the hypervisor we get the same

299
00:15:25,000 --> 00:15:27,790
information we of course get the process

300
00:15:27,790 --> 00:15:32,200
ID and the process name so this is very

301
00:15:32,200 --> 00:15:32,740
cool

302
00:15:32,740 --> 00:15:36,970
because because you get all the you can

303
00:15:36,970 --> 00:15:38,529
get all the information you want from

304
00:15:38,529 --> 00:15:41,440
the outside so what we did for our first

305
00:15:41,440 --> 00:15:46,300
security application was we then we

306
00:15:46,300 --> 00:15:48,430
defined something that we called a

307
00:15:48,430 --> 00:15:51,220
process identity and those were the

308
00:15:51,220 --> 00:15:54,580
parameters that we have used for now so

309
00:15:54,580 --> 00:15:56,500
we have defined that every running

310
00:15:56,500 --> 00:16:00,820
process is a subset of its name it's a

311
00:16:00,820 --> 00:16:03,580
the file on disk that is running for

312
00:16:03,580 --> 00:16:06,520
from the shared object that are loaded

313
00:16:06,520 --> 00:16:09,400
inside this running process the

314
00:16:09,400 --> 00:16:11,200
permission level process and the user

315
00:16:11,200 --> 00:16:15,160
that is connected and we have monitored

316
00:16:15,160 --> 00:16:17,410
that our environment for several weeks

317
00:16:17,410 --> 00:16:20,920
we found out we build some kind of a

318
00:16:20,920 --> 00:16:25,089
baseline to see and to see what's really

319
00:16:25,089 --> 00:16:26,890
going inside and if it should run and

320
00:16:26,890 --> 00:16:30,040
once we have a looked I'll look at our

321
00:16:30,040 --> 00:16:32,620
baseline we have compared every running

322
00:16:32,620 --> 00:16:37,800
process against against this baseline

323
00:16:37,800 --> 00:16:41,290
okay so this was our first security

324
00:16:41,290 --> 00:16:44,230
application and it worked pretty well

325
00:16:44,230 --> 00:16:46,690
and when we decided to move to something

326
00:16:46,690 --> 00:16:50,080
and more complicated so while we were at

327
00:16:50,080 --> 00:16:53,920
digging inside our kernel structures in

328
00:16:53,920 --> 00:16:56,770
order to get the shell object and of

329
00:16:56,770 --> 00:16:58,450
course we had we started with every

330
00:16:58,450 --> 00:17:02,260
truck we task struct that has like a

331
00:17:02,260 --> 00:17:04,839
list files that is going to read your

332
00:17:04,839 --> 00:17:07,720
files that is connected to it and a file

333
00:17:07,720 --> 00:17:11,470
can be several things should really use

334
00:17:11,470 --> 00:17:15,220
the clicker can be several things and

335
00:17:15,220 --> 00:17:17,679
one of the thing it can be is a socket

336
00:17:17,679 --> 00:17:21,040
and we found it a really interesting so

337
00:17:21,040 --> 00:17:25,089
by the so by digging inside I know that

338
00:17:25,089 --> 00:17:29,860
our socket type two layers down there is

339
00:17:29,860 --> 00:17:32,410
a sock structure which contains

340
00:17:32,410 --> 00:17:35,460
information about the network

341
00:17:35,460 --> 00:17:37,289
connections that are related to this

342
00:17:37,289 --> 00:17:40,529
process and the information that we have

343
00:17:40,529 --> 00:17:44,970
and this task is a source IP desktop in

344
00:17:44,970 --> 00:17:50,640
stores poor desperate so what can we do

345
00:17:50,640 --> 00:17:53,100
with this information so we started

346
00:17:53,100 --> 00:17:55,289
thinking about it right now

347
00:17:55,289 --> 00:17:57,179
the first application only focused on

348
00:17:57,179 --> 00:17:59,970
the virtual machine itself as a separate

349
00:17:59,970 --> 00:18:02,490
unit but we are controlling all data

350
00:18:02,490 --> 00:18:04,860
center and we're sitting we can see all

351
00:18:04,860 --> 00:18:16,950
the virtual machines so so by ok so by

352
00:18:16,950 --> 00:18:18,690
seeing all the assumptions we can do a

353
00:18:18,690 --> 00:18:23,750
bigger things so we decided to create a

354
00:18:23,750 --> 00:18:28,020
context aware firewall so we had we

355
00:18:28,020 --> 00:18:29,970
already had firewalls in our network but

356
00:18:29,970 --> 00:18:32,399
we had several problems with them first

357
00:18:32,399 --> 00:18:36,929
of all and and we cannot we don't have a

358
00:18:36,929 --> 00:18:39,000
firewall between every virtual machine

359
00:18:39,000 --> 00:18:40,770
of course they are usually on the edges

360
00:18:40,770 --> 00:18:41,580
of the network

361
00:18:41,580 --> 00:18:44,190
the second thing from the outside of

362
00:18:44,190 --> 00:18:46,740
very limited we can only see the network

363
00:18:46,740 --> 00:18:51,000
and information and third if we really

364
00:18:51,000 --> 00:18:54,120
have to if we would have been able to

365
00:18:54,120 --> 00:18:58,130
put an agent inside we could have a

366
00:18:58,130 --> 00:19:00,990
combined in the network information with

367
00:19:00,990 --> 00:19:03,330
the information with a state internal

368
00:19:03,330 --> 00:19:08,610
state of the the virtual machine in

369
00:19:08,610 --> 00:19:11,399
order to create smart rules so this is

370
00:19:11,399 --> 00:19:12,390
exactly what we did

371
00:19:12,390 --> 00:19:15,179
using the hypervisor introspection so we

372
00:19:15,179 --> 00:19:17,909
have combined our process identity with

373
00:19:17,909 --> 00:19:21,630
the network communication information in

374
00:19:21,630 --> 00:19:23,929
order to create smart firewall rules

375
00:19:23,929 --> 00:19:27,270
then so what are like an example of a

376
00:19:27,270 --> 00:19:31,830
rule that we can create if we so we can

377
00:19:31,830 --> 00:19:34,140
create a following rule we can make sure

378
00:19:34,140 --> 00:19:36,690
that only an application that is running

379
00:19:36,690 --> 00:19:40,620
from a specific place in memory that is

380
00:19:40,620 --> 00:19:43,950
on disk that is it has only specific

381
00:19:43,950 --> 00:19:47,669
DLLs that are loaded inside with a

382
00:19:47,669 --> 00:19:49,170
specific user or specific

383
00:19:49,170 --> 00:19:52,920
connections can talk to a specific

384
00:19:52,920 --> 00:19:55,290
process identity on the other side of a

385
00:19:55,290 --> 00:19:58,320
data center and that's why and that's

386
00:19:58,320 --> 00:20:02,010
why we are creating and like a context

387
00:20:02,010 --> 00:20:08,180
aware firewall and the way it looks is

388
00:20:08,180 --> 00:20:11,220
you can see from running let's start

389
00:20:11,220 --> 00:20:13,950
from inside we get the information about

390
00:20:13,950 --> 00:20:16,050
the connection itself and of course we

391
00:20:16,050 --> 00:20:18,630
know what is the process ID that is

392
00:20:18,630 --> 00:20:21,030
running it and this is what we get from

393
00:20:21,030 --> 00:20:25,080
the outside it's not like we didn't

394
00:20:25,080 --> 00:20:30,360
construct a GUI just so we can see that

395
00:20:30,360 --> 00:20:34,020
from the outside view we can match the

396
00:20:34,020 --> 00:20:36,690
network communication to the process

397
00:20:36,690 --> 00:20:39,660
that is running it to the client process

398
00:20:39,660 --> 00:20:44,340
in this case and of course we can and we

399
00:20:44,340 --> 00:20:46,710
can look at any other information that

400
00:20:46,710 --> 00:20:49,470
is relevant in order to construct this

401
00:20:49,470 --> 00:20:56,670
firewall ok great ok so now what we did

402
00:20:56,670 --> 00:20:59,190
it it will it worked great we found a

403
00:20:59,190 --> 00:21:04,110
find out a lot of the security threats

404
00:21:04,110 --> 00:21:08,220
but what we can do with it so we were

405
00:21:08,220 --> 00:21:10,980
thinking about it so far we just looked

406
00:21:10,980 --> 00:21:13,260
at the writing cup of at the reading

407
00:21:13,260 --> 00:21:15,150
capability but there is also a way to

408
00:21:15,150 --> 00:21:18,360
write a capability right mmm into memory

409
00:21:18,360 --> 00:21:23,670
so the thing that we we were thinking

410
00:21:23,670 --> 00:21:27,120
about was what if we write into memory

411
00:21:27,120 --> 00:21:29,760
can we manipulate the behavior of the

412
00:21:29,760 --> 00:21:33,810
virtual machine probably right we can

413
00:21:33,810 --> 00:21:35,820
always do some kind of damage if you

414
00:21:35,820 --> 00:21:39,210
write into memory ok then we said if we

415
00:21:39,210 --> 00:21:42,660
write into memory can we create a

416
00:21:42,660 --> 00:21:45,420
specific outcome a certain outcome can

417
00:21:45,420 --> 00:21:51,060
we for example stop a process and maybe

418
00:21:51,060 --> 00:21:53,070
ok this is interesting maybe we can do

419
00:21:53,070 --> 00:21:53,340
it

420
00:21:53,340 --> 00:21:56,160
so let's look into that the first thing

421
00:21:56,160 --> 00:21:58,980
we wanted to do was exactly this we have

422
00:21:58,980 --> 00:22:01,860
already a wine-tasting application can

423
00:22:01,860 --> 00:22:02,909
we stop

424
00:22:02,909 --> 00:22:06,570
process or terminated once it does not

425
00:22:06,570 --> 00:22:11,489
match our baseline and how we did it was

426
00:22:11,489 --> 00:22:13,679
just we said okay let's look at the test

427
00:22:13,679 --> 00:22:16,470
track that we already have and try to

428
00:22:16,470 --> 00:22:19,590
find some suspicious the elements that

429
00:22:19,590 --> 00:22:21,869
can influence the behavior of the

430
00:22:21,869 --> 00:22:24,830
virtual machine so just by looking on a

431
00:22:24,830 --> 00:22:27,659
destructor we have several leads okay

432
00:22:27,659 --> 00:22:30,419
the first one is literally almost always

433
00:22:30,419 --> 00:22:32,879
it first is the state with really

434
00:22:32,879 --> 00:22:36,749
interesting comment there are a lot of

435
00:22:36,749 --> 00:22:38,129
others like flags

436
00:22:38,129 --> 00:22:40,080
maybe if we change the flags we can stop

437
00:22:40,080 --> 00:22:42,809
the process from running and maybe if we

438
00:22:42,809 --> 00:22:47,840
play with it scheduling and the CPU time

439
00:22:47,840 --> 00:22:52,440
priority and also exit sites okay so we

440
00:22:52,440 --> 00:22:54,629
decided to code with the first which was

441
00:22:54,629 --> 00:22:58,769
the easiest and try to see what are the

442
00:22:58,769 --> 00:23:02,460
values that we can put inside and if you

443
00:23:02,460 --> 00:23:04,919
if you can read it like everything here

444
00:23:04,919 --> 00:23:06,379
looks interesting and probably

445
00:23:06,379 --> 00:23:09,149
everything you will try will do some

446
00:23:09,149 --> 00:23:13,559
kind of damage to this process and but

447
00:23:13,559 --> 00:23:15,840
we wanted to have a specific outcome so

448
00:23:15,840 --> 00:23:17,909
we won't try it so in order to get a

449
00:23:17,909 --> 00:23:19,619
specific outcome we started to read

450
00:23:19,619 --> 00:23:23,489
about what's really every value means

451
00:23:23,489 --> 00:23:28,259
and and pretty produce right away we got

452
00:23:28,259 --> 00:23:31,289
into the task interruptible which means

453
00:23:31,289 --> 00:23:33,960
that we can change the value and even if

454
00:23:33,960 --> 00:23:36,479
there is a signal that signals it to

455
00:23:36,479 --> 00:23:38,460
wake up it will not wake up until we

456
00:23:38,460 --> 00:23:41,759
wake it up manually so this is exactly

457
00:23:41,759 --> 00:23:46,440
what we tried we have took our demo

458
00:23:46,440 --> 00:23:48,419
malware process that was running that we

459
00:23:48,419 --> 00:23:51,989
wanted to terminate we have assigned

460
00:23:51,989 --> 00:23:56,399
tasks an uninterruptible value into the

461
00:23:56,399 --> 00:23:59,970
state obsessed of the task track and so

462
00:23:59,970 --> 00:24:01,559
what happened and what happened was

463
00:24:01,559 --> 00:24:04,289
exactly what we wanted the the state of

464
00:24:04,289 --> 00:24:08,369
this struct went to an uninterruptible

465
00:24:08,369 --> 00:24:12,570
which means that if we want we can run

466
00:24:12,570 --> 00:24:15,929
it again and right now when the throw

467
00:24:15,929 --> 00:24:19,200
and then when the process is frozen we

468
00:24:19,200 --> 00:24:25,080
can actually take its memory we can

469
00:24:25,080 --> 00:24:27,179
retrieve its memory encode data and

470
00:24:27,179 --> 00:24:29,990
analyze it and if we want we can even

471
00:24:29,990 --> 00:24:33,869
resume it it's running without hurting

472
00:24:33,869 --> 00:24:36,029
any other of the running processes

473
00:24:36,029 --> 00:24:40,769
inside the same virtual machine and so

474
00:24:40,769 --> 00:24:46,350
and so it was nice but bad thing we

475
00:24:46,350 --> 00:24:50,639
wanted to do after that was to kiloton

476
00:24:50,639 --> 00:24:55,649
entirely to make it in - to turn it into

477
00:24:55,649 --> 00:24:58,289
a state that it would not be resumed so

478
00:24:58,289 --> 00:25:00,259
this is what we did we played with the

479
00:25:00,259 --> 00:25:05,009
exit state as well of the the path state

480
00:25:05,009 --> 00:25:07,379
and the exit state as well and the thing

481
00:25:07,379 --> 00:25:09,360
we found we found interesting was the

482
00:25:09,360 --> 00:25:12,840
exit dead and my time is up so I will

483
00:25:12,840 --> 00:25:17,970
just go through it briefly and we have

484
00:25:17,970 --> 00:25:20,249
assigned both values and we of course

485
00:25:20,249 --> 00:25:25,889
got it where we wanted okay so I will

486
00:25:25,889 --> 00:25:30,389
not go through all those guys yeah

487
00:25:30,389 --> 00:25:35,580
couple months okay okay great great guys

488
00:25:35,580 --> 00:25:40,080
okay I have more to say but an arrant

489
00:25:40,080 --> 00:25:44,669
okay so we were this looks a bit random

490
00:25:44,669 --> 00:25:46,470
but it wasn't where they were in the

491
00:25:46,470 --> 00:25:50,639
room it was by reading the EM at the

492
00:25:50,639 --> 00:25:53,100
open source code of course and looking

493
00:25:53,100 --> 00:25:57,250
at the manuals and and by reading a

494
00:25:57,250 --> 00:26:00,220
the cotton trying to figure out how to

495
00:26:00,220 --> 00:26:02,500
get to a state that I want to get to

496
00:26:02,500 --> 00:26:05,140
this is nothing not necessary there is

497
00:26:05,140 --> 00:26:08,080
the code there is any path in the code

498
00:26:08,080 --> 00:26:10,059
that goes into this state

499
00:26:10,059 --> 00:26:12,929
it's imagine like a state machine that

500
00:26:12,929 --> 00:26:15,929
usually the code goes into certain

501
00:26:15,929 --> 00:26:18,970
positions but manipulating the memory I

502
00:26:18,970 --> 00:26:21,940
just I can take my running position and

503
00:26:21,940 --> 00:26:25,049
place it everywhere I want inside this

504
00:26:25,049 --> 00:26:30,070
state machine so by manipulating both

505
00:26:30,070 --> 00:26:33,309
those memories we achieved the dead

506
00:26:33,309 --> 00:26:36,100
should never be seen a state of course

507
00:26:36,100 --> 00:26:38,970
because it should never really happen

508
00:26:38,970 --> 00:26:42,880
and okay so this is what we did for the

509
00:26:42,880 --> 00:26:46,360
running processes application and the

510
00:26:46,360 --> 00:26:50,760
second application what we wanted to

511
00:26:50,760 --> 00:26:54,549
create was an activated firewall we

512
00:26:54,549 --> 00:26:56,620
already have our context-aware firewall

513
00:26:56,620 --> 00:26:59,260
and the things we wanted to say to do is

514
00:26:59,260 --> 00:27:01,659
exactly the same thing we have a process

515
00:27:01,659 --> 00:27:04,990
running and we want to kill it we did

516
00:27:04,990 --> 00:27:07,360
the same a way of thinking we found some

517
00:27:07,360 --> 00:27:10,320
suspicious places that were suspicious

518
00:27:10,320 --> 00:27:13,840
values that we can change and we change

519
00:27:13,840 --> 00:27:17,919
them according to the correct value

520
00:27:17,919 --> 00:27:20,650
after reading of course the manuals and

521
00:27:20,650 --> 00:27:24,070
the code and some examples of how it

522
00:27:24,070 --> 00:27:26,799
works is for example here we can see

523
00:27:26,799 --> 00:27:31,150
that if the sock dead flag is raised

524
00:27:31,150 --> 00:27:35,890
then it will not do not process the data

525
00:27:35,890 --> 00:27:39,879
another example is Stoke Don and

526
00:27:39,879 --> 00:27:42,729
flag is shown on then it will will not

527
00:27:42,729 --> 00:27:45,820
go with who not to am and bring the

528
00:27:45,820 --> 00:27:48,759
memory and further it will break and

529
00:27:48,759 --> 00:27:51,249
those are exactly the way of thing and

530
00:27:51,249 --> 00:27:54,389
that we have applied for this project

531
00:27:54,389 --> 00:27:56,769
and this is not everything that is

532
00:27:56,769 --> 00:27:58,629
needed to stop a project but this is the

533
00:27:58,629 --> 00:28:03,570
way of thinking is the same so we have

534
00:28:03,570 --> 00:28:07,509
changed the state of the flag it put it

535
00:28:07,509 --> 00:28:10,869
inside and what happened is not really

536
00:28:10,869 --> 00:28:14,379
exciting from like the visual point of

537
00:28:14,379 --> 00:28:15,789
view but it's very exciting when it's

538
00:28:15,789 --> 00:28:18,940
really happening the process we kill the

539
00:28:18,940 --> 00:28:21,460
process from the outside so here we have

540
00:28:21,460 --> 00:28:24,909
a process running inside two virtual

541
00:28:24,909 --> 00:28:26,139
machines that communicating with each

542
00:28:26,139 --> 00:28:29,499
other and by changing minor values in

543
00:28:29,499 --> 00:28:31,989
the hypervisor not touching the virtual

544
00:28:31,989 --> 00:28:35,879
machine at all we have of course

545
00:28:35,970 --> 00:28:39,519
terminated this this process with

546
00:28:39,519 --> 00:28:43,139
communication and the cool thing is and

547
00:28:43,139 --> 00:28:45,970
that the operating system is now is

548
00:28:45,970 --> 00:28:48,369
doing the hard work for us we have

549
00:28:48,369 --> 00:28:49,989
changed the values and the operating

550
00:28:49,989 --> 00:28:52,299
system understand that it is in the

551
00:28:52,299 --> 00:28:54,519
state that needs to close this

552
00:28:54,519 --> 00:28:56,710
connection and it frees all the

553
00:28:56,710 --> 00:28:58,690
resources that were used for this

554
00:28:58,690 --> 00:29:02,499
network communication and and leaves the

555
00:29:02,499 --> 00:29:08,379
state a clear okay so so why this is

556
00:29:08,379 --> 00:29:08,859
cool

557
00:29:08,859 --> 00:29:12,789
we have done what we set up to do we

558
00:29:12,789 --> 00:29:16,389
have built a no agent no touch and not

559
00:29:16,389 --> 00:29:18,729
only rely on network communication and

560
00:29:18,729 --> 00:29:22,179
solution and this is really cool also

561
00:29:22,179 --> 00:29:24,580
because any modular that is running

562
00:29:24,580 --> 00:29:27,999
inside it it will be a bit harder to

563
00:29:27,999 --> 00:29:30,129
evade because we are seeing all the

564
00:29:30,129 --> 00:29:32,889
memory and an attacker doesn't really

565
00:29:32,889 --> 00:29:36,159
know what we are monitoring for what in

566
00:29:36,159 --> 00:29:38,950
memory we are looking at and and not and

567
00:29:38,950 --> 00:29:43,509
when an operating system does all the

568
00:29:43,509 --> 00:29:46,960
work for us once we are true once we are

569
00:29:46,960 --> 00:29:49,330
moving from one state to another state

570
00:29:49,330 --> 00:29:52,730
the operating system knows how to

571
00:29:52,730 --> 00:29:55,190
the job and they closed all the things

572
00:29:55,190 --> 00:29:58,549
that needs to close and the cool part

573
00:29:58,549 --> 00:30:02,570
here is by some more effort especially

574
00:30:02,570 --> 00:30:04,520
in kayvyun because we don't have events

575
00:30:04,520 --> 00:30:08,210
and we can also run code so this will be

576
00:30:08,210 --> 00:30:11,450
probably for some for next talk

577
00:30:11,450 --> 00:30:16,070
not now and some caveats things that are

578
00:30:16,070 --> 00:30:19,990
said that are not true or not really

579
00:30:19,990 --> 00:30:24,440
problematic so one of the things one of

580
00:30:24,440 --> 00:30:26,270
the problem sort of a hypervisor

581
00:30:26,270 --> 00:30:29,480
introspection is pausing the virtual

582
00:30:29,480 --> 00:30:31,910
machine every time you do you need to

583
00:30:31,910 --> 00:30:35,000
find you need to translate a virtual

584
00:30:35,000 --> 00:30:36,350
address and the physical address you

585
00:30:36,350 --> 00:30:38,540
need to pause the virtual machine in the

586
00:30:38,540 --> 00:30:42,740
current implementation so what we did in

587
00:30:42,740 --> 00:30:47,720
order to to overcome this we have worked

588
00:30:47,720 --> 00:30:50,200
with some heuristic access we are always

589
00:30:50,200 --> 00:30:52,250
monitoring the network and trying to

590
00:30:52,250 --> 00:30:54,410
find us tickly if the information is

591
00:30:54,410 --> 00:30:57,799
fresh or not if it's relevant or not so

592
00:30:57,799 --> 00:30:59,330
this is one thing that we did in order

593
00:30:59,330 --> 00:31:03,230
to overcome this the second thing is the

594
00:31:03,230 --> 00:31:06,500
mapping between the channel symbols and

595
00:31:06,500 --> 00:31:09,860
their virtual address so if the case

596
00:31:09,860 --> 00:31:12,350
that are is turned on then what I said

597
00:31:12,350 --> 00:31:14,750
before is not really relevant system map

598
00:31:14,750 --> 00:31:18,620
would not be relevant after every reboot

599
00:31:18,620 --> 00:31:21,169
so in order to overcome this you need to

600
00:31:21,169 --> 00:31:23,179
do the heuristic method every time you

601
00:31:23,179 --> 00:31:24,890
need to every time to scan the memory

602
00:31:24,890 --> 00:31:27,620
every time the system comes up and find

603
00:31:27,620 --> 00:31:31,820
the right kind of symbol locations and

604
00:31:31,820 --> 00:31:34,070
they will not talk about the last one if

605
00:31:34,070 --> 00:31:38,510
you want see me after and so some

606
00:31:38,510 --> 00:31:42,860
takeaways and so this was a big

607
00:31:42,860 --> 00:31:44,900
challenge and I think that the

608
00:31:44,900 --> 00:31:47,299
limitations even though they were really

609
00:31:47,299 --> 00:31:50,000
strict really helped the solution and I

610
00:31:50,000 --> 00:31:51,530
do believe an invitation based on

611
00:31:51,530 --> 00:31:56,000
innovation and this is a really cool

612
00:31:56,000 --> 00:31:57,620
platform you can get almost anything

613
00:31:57,620 --> 00:32:00,049
from the memory of the virtual machine

614
00:32:00,049 --> 00:32:02,419
and so the possibilities are really

615
00:32:02,419 --> 00:32:04,250
endless of what you can do with it and

616
00:32:04,250 --> 00:32:05,510
it's not really

617
00:32:05,510 --> 00:32:09,050
utilized enough right now and of course

618
00:32:09,050 --> 00:32:11,420
you can always do harm and they learn it

619
00:32:11,420 --> 00:32:15,940
how the way so use it with caution

620
00:32:15,940 --> 00:32:18,200
thank you

621
00:32:18,200 --> 00:32:20,839
[Applause]

