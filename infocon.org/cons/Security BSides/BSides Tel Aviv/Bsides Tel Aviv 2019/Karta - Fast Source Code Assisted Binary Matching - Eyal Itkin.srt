1
00:00:03,110 --> 00:00:06,420
okay hi everybody sorry for the

2
00:00:06,420 --> 00:00:09,630
technical issues I'm and I'm going to

3
00:00:09,630 --> 00:00:11,790
present an ID a plug in it but I wrote a

4
00:00:11,790 --> 00:00:15,330
called kata but let's start from the

5
00:00:15,330 --> 00:00:18,359
beginning I'm really keen I'm a

6
00:00:18,359 --> 00:00:20,400
vulnerability researcher at checkpoint

7
00:00:20,400 --> 00:00:23,220
research usually my justice project so

8
00:00:23,220 --> 00:00:25,470
focused on embedded devices and network

9
00:00:25,470 --> 00:00:27,720
protocols which was the background for

10
00:00:27,720 --> 00:00:30,900
this specific Ida plugin usually you

11
00:00:30,900 --> 00:00:33,780
could see my results projects or suggest

12
00:00:33,780 --> 00:00:38,070
your own project for my Twitter and

13
00:00:38,070 --> 00:00:43,559
let's begin the motivation for research

14
00:00:43,559 --> 00:00:48,320
for this plug-in what is that

15
00:00:48,410 --> 00:00:51,750
usually and marwari searchers or even

16
00:00:51,750 --> 00:00:53,190
irritability researchers in female

17
00:00:53,190 --> 00:00:56,899
projects need to identify open source

18
00:00:56,899 --> 00:01:01,050
versions inside a given binary this

19
00:01:01,050 --> 00:01:03,149
could be the version of a open SSL what

20
00:01:03,149 --> 00:01:06,840
is being used and Lee P&G easily but

21
00:01:06,840 --> 00:01:10,350
you'll see often and you want to

22
00:01:10,350 --> 00:01:12,390
identify the open source for specific

23
00:01:12,390 --> 00:01:14,610
reasons sometimes you want to help

24
00:01:14,610 --> 00:01:16,470
researchers in the reverse engineering

25
00:01:16,470 --> 00:01:19,799
process because I want to find out what

26
00:01:19,799 --> 00:01:22,170
the binary does and does it support TIFF

27
00:01:22,170 --> 00:01:25,549
if it has a liberty if inside it

28
00:01:25,549 --> 00:01:28,890
locating one day's and given film where

29
00:01:28,890 --> 00:01:32,880
in many many ephemeral projects you

30
00:01:32,880 --> 00:01:35,729
don't need to find a zero because they

31
00:01:35,729 --> 00:01:39,150
don't update the open sources so you

32
00:01:39,150 --> 00:01:41,430
must probably have a given one day that

33
00:01:41,430 --> 00:01:43,920
is exploitable but you need to find out

34
00:01:43,920 --> 00:01:46,470
which open sources are being used

35
00:01:46,470 --> 00:01:48,329
statically linked inside the film and

36
00:01:48,329 --> 00:01:50,640
what are the versions of each open

37
00:01:50,640 --> 00:01:53,040
source and hopefully we could do that

38
00:01:53,040 --> 00:01:56,490
automatically we want to identify a

39
00:01:56,490 --> 00:01:58,829
Lipsey functions because we don't have

40
00:01:58,829 --> 00:02:02,729
good heuristics to find STR LAN or mem

41
00:02:02,729 --> 00:02:06,659
copy STR and copy or a socket when you

42
00:02:06,659 --> 00:02:08,970
reverse engineer a filmer file on

43
00:02:08,970 --> 00:02:11,340
Windows you will have it for Lib C but

44
00:02:11,340 --> 00:02:12,810
if you

45
00:02:12,810 --> 00:02:16,290
have an embedded file it's an HP printer

46
00:02:16,290 --> 00:02:19,950
for some reason it's in an arm CPU you

47
00:02:19,950 --> 00:02:22,740
need to find it all on your own and one

48
00:02:22,740 --> 00:02:24,600
more reason with several people here in

49
00:02:24,600 --> 00:02:28,680
the audience know that because I work

50
00:02:28,680 --> 00:02:31,050
with them on a given project is that I

51
00:02:31,050 --> 00:02:33,810
worked three days to reverse-engineer a

52
00:02:33,810 --> 00:02:36,530
specific SNMP model in some device and

53
00:02:36,530 --> 00:02:39,959
after which I found out that it's a used

54
00:02:39,959 --> 00:02:43,140
open source called net assign IP and I

55
00:02:43,140 --> 00:02:45,630
knew the open source already and I

56
00:02:45,630 --> 00:02:48,120
simply couldn't realize that I'm

57
00:02:48,120 --> 00:02:52,800
reversing a known open source so I don't

58
00:02:52,800 --> 00:02:54,630
want to reverse engineer and Edison in P

59
00:02:54,630 --> 00:02:56,610
over and over and over again if you

60
00:02:56,610 --> 00:02:58,380
would have an automatic tool to identify

61
00:02:58,380 --> 00:03:02,760
it and match the functions I could skip

62
00:03:02,760 --> 00:03:04,769
directly to interesting models instead

63
00:03:04,769 --> 00:03:07,950
of reverse engineering the same open

64
00:03:07,950 --> 00:03:10,200
source but is already known it has no

65
00:03:10,200 --> 00:03:14,400
good exploitable vulnerabilities the

66
00:03:14,400 --> 00:03:18,680
problem with current tools is that

67
00:03:18,680 --> 00:03:22,170
usually the firmware is used we have a

68
00:03:22,170 --> 00:03:24,170
specific showing we used in a previous

69
00:03:24,170 --> 00:03:27,470
research project which has roughly

70
00:03:27,470 --> 00:03:30,720
65,000 functions are in Cisco hotels you

71
00:03:30,720 --> 00:03:32,940
have hundreds of thousands of functions

72
00:03:32,940 --> 00:03:36,120
and even on TV viewer which is a simple

73
00:03:36,120 --> 00:03:38,160
process on your Windows computer you

74
00:03:38,160 --> 00:03:42,959
have roughly 150,000 functions binary is

75
00:03:42,959 --> 00:03:46,560
a pretty large and we need to cope with

76
00:03:46,560 --> 00:03:49,109
that and find our functions inside these

77
00:03:49,109 --> 00:03:52,920
large binaries and this is the problem

78
00:03:52,920 --> 00:03:56,670
because most being diffing tools are

79
00:03:56,670 --> 00:03:59,160
dependent on the size of your binary and

80
00:03:59,160 --> 00:04:02,220
not on the size of the file or open

81
00:04:02,220 --> 00:04:04,950
source you want to match inside it so I

82
00:04:04,950 --> 00:04:07,410
mean the liability size is carry most of

83
00:04:07,410 --> 00:04:09,660
the tools are dependent on n and not ok

84
00:04:09,660 --> 00:04:12,660
which means that although bindis and the

85
00:04:12,660 --> 00:04:15,299
fo are really good tools for binary

86
00:04:15,299 --> 00:04:19,079
diffing or pet reefing they fail poorly

87
00:04:19,079 --> 00:04:22,860
on huge embedded files few more files

88
00:04:22,860 --> 00:04:25,910
they simply can't find small

89
00:04:25,910 --> 00:04:29,330
known chunks inside a big live away when

90
00:04:29,330 --> 00:04:33,110
I used the offline one project the D

91
00:04:33,110 --> 00:04:35,720
beer goes to roughly three gigabytes and

92
00:04:35,720 --> 00:04:37,910
when Paul compressed and when I used

93
00:04:37,910 --> 00:04:40,190
bindi if we took it three hours and it

94
00:04:40,190 --> 00:04:43,220
found nothing we want something that

95
00:04:43,220 --> 00:04:45,860
takes two into attention the size of the

96
00:04:45,860 --> 00:04:48,170
film and the size of the library we want

97
00:04:48,170 --> 00:04:51,110
to find and hopefully the complexity

98
00:04:51,110 --> 00:04:52,940
will be dependent on carry rather than

99
00:04:52,940 --> 00:04:57,500
on in some background last year we had a

100
00:04:57,500 --> 00:05:01,880
research on the fax protocol here's the

101
00:05:01,880 --> 00:05:05,720
link for the full research the film were

102
00:05:05,720 --> 00:05:07,970
for our test case was an HP Officejet is

103
00:05:07,970 --> 00:05:12,080
simple common HP Officejet when the

104
00:05:12,080 --> 00:05:13,940
purpose of the research was to find a

105
00:05:13,940 --> 00:05:15,410
remote code execution over the fax

106
00:05:15,410 --> 00:05:20,570
protocol which worked now we want to

107
00:05:20,570 --> 00:05:23,300
look on this project and see how that

108
00:05:23,300 --> 00:05:27,080
plug-in kada would help us in a research

109
00:05:27,080 --> 00:05:30,890
we wanted to find a to build develop a

110
00:05:30,890 --> 00:05:34,700
debugger and we could debug for any one

111
00:05:34,700 --> 00:05:36,410
day we found in a farewell for the web

112
00:05:36,410 --> 00:05:40,400
interface for example exploit a one day

113
00:05:40,400 --> 00:05:43,190
you use the debugger and then debug the

114
00:05:43,190 --> 00:05:46,490
Fox worker in order to look for one day

115
00:05:46,490 --> 00:05:48,980
we need to identify the open sources we

116
00:05:48,980 --> 00:05:50,660
need to find the vulnerable functions

117
00:05:50,660 --> 00:05:53,000
and eventually we use David's ivory from

118
00:05:53,000 --> 00:05:55,220
G so which is not the important part

119
00:05:55,220 --> 00:05:58,400
the bad part for us was manually

120
00:05:58,400 --> 00:06:00,710
identifying the open sources in manual

121
00:06:00,710 --> 00:06:03,050
identifying the vulnerable functions if

122
00:06:03,050 --> 00:06:06,080
it would have used Cora for instance we

123
00:06:06,080 --> 00:06:08,510
can see what the basic output where once

124
00:06:08,510 --> 00:06:10,790
you execute a script is this nice list

125
00:06:10,790 --> 00:06:13,520
which shows you that the open source is

126
00:06:13,520 --> 00:06:16,010
further used orally PNG is really about

127
00:06:16,010 --> 00:06:18,680
- a cell and a vulnerable version of G

128
00:06:18,680 --> 00:06:22,190
so because if you simply type in Google

129
00:06:22,190 --> 00:06:24,800
G soap and vulnerabilities you'll find

130
00:06:24,800 --> 00:06:26,900
that this specific version is vulnerable

131
00:06:26,900 --> 00:06:30,380
to device IV and now the most important

132
00:06:30,380 --> 00:06:33,380
part is woodcutter match function and

133
00:06:33,380 --> 00:06:35,510
see me tell us here is this vulnerable

134
00:06:35,510 --> 00:06:37,490
function start the exploit form this

135
00:06:37,490 --> 00:06:39,139
point

136
00:06:39,139 --> 00:06:42,949
let's see and yes simply out of the box

137
00:06:42,949 --> 00:06:45,560
you take a feel will you find out of the

138
00:06:45,560 --> 00:06:47,150
vulnerable open sources which are

139
00:06:47,150 --> 00:06:49,719
embedded inside it match the

140
00:06:49,719 --> 00:06:51,860
configurations to find a function and

141
00:06:51,860 --> 00:06:52,610
that's it

142
00:06:52,610 --> 00:06:55,370
and in an additional research this time

143
00:06:55,370 --> 00:06:58,249
from plotted Zillow if we have a series

144
00:06:58,249 --> 00:07:01,759
of blog posts about a WebRTC in this

145
00:07:01,759 --> 00:07:05,659
link and it found one specific CV which

146
00:07:05,659 --> 00:07:08,599
is in not in home itself but in a

147
00:07:08,599 --> 00:07:11,060
library called leave the px and we

148
00:07:11,060 --> 00:07:13,069
specifically said that this

149
00:07:13,069 --> 00:07:16,669
vulnerability is most poly effects more

150
00:07:16,669 --> 00:07:20,180
versions and more products okay let's

151
00:07:20,180 --> 00:07:24,050
take T if you will for example execute

152
00:07:24,050 --> 00:07:25,909
kata and check if it's vulnerable to the

153
00:07:25,909 --> 00:07:27,469
same vulnerability which Google found

154
00:07:27,469 --> 00:07:30,319
and we found a vulnerable version of

155
00:07:30,319 --> 00:07:32,509
live depicts actually really vulnerable

156
00:07:32,509 --> 00:07:34,460
version because it's outdated in two

157
00:07:34,460 --> 00:07:39,080
years this is the code function of the

158
00:07:39,080 --> 00:07:40,909
vulnerability and it pays special

159
00:07:40,909 --> 00:07:43,310
attention to the numerical constants

160
00:07:43,310 --> 00:07:46,310
inside it because when you execute it

161
00:07:46,310 --> 00:07:48,680
Cora we found it in either and we can

162
00:07:48,680 --> 00:07:51,229
see the same numerical constants and it

163
00:07:51,229 --> 00:07:54,490
took it roughly ten seconds to find it

164
00:07:54,490 --> 00:07:57,050
so the tool works it's already on our

165
00:07:57,050 --> 00:07:59,029
github account now let's check out how

166
00:07:59,029 --> 00:08:03,949
it works okay we want to map the binary

167
00:08:03,949 --> 00:08:08,060
and actually really really a descriptive

168
00:08:08,060 --> 00:08:11,259
mapping of the functions in the binary

169
00:08:11,259 --> 00:08:13,909
we are interested in a specific open

170
00:08:13,909 --> 00:08:16,520
source which is found over there and it

171
00:08:16,520 --> 00:08:18,589
should be somewhere inside the large

172
00:08:18,589 --> 00:08:21,800
film file a large executable and we're

173
00:08:21,800 --> 00:08:24,169
not interested in all of the executable

174
00:08:24,169 --> 00:08:27,020
we only want to find the open source if

175
00:08:27,020 --> 00:08:29,839
we zoom in and we pay special attention

176
00:08:29,839 --> 00:08:32,448
to each of the functions in the selected

177
00:08:32,448 --> 00:08:35,479
area we will see that the selected area

178
00:08:35,479 --> 00:08:37,640
starts with all of the functions from

179
00:08:37,640 --> 00:08:40,099
one specific compiled source file

180
00:08:40,099 --> 00:08:43,279
followed by all of the functions form an

181
00:08:43,279 --> 00:08:46,820
additional compiled so as file and so on

182
00:08:46,820 --> 00:08:50,300
and so forth we can see that essentially

183
00:08:50,300 --> 00:08:52,520
the compiler compiled each

184
00:08:52,520 --> 00:08:55,400
file independently and then link them

185
00:08:55,400 --> 00:08:59,980
all together which means that instead of

186
00:08:59,980 --> 00:09:03,710
matching each function on its own we can

187
00:09:03,710 --> 00:09:08,960
use this behavior in order to match full

188
00:09:08,960 --> 00:09:11,660
files one to another instead of matching

189
00:09:11,660 --> 00:09:15,650
a single functions and that's the basic

190
00:09:15,650 --> 00:09:18,470
idea behind Carter we want to map the

191
00:09:18,470 --> 00:09:22,490
files inside the binary outer space this

192
00:09:22,490 --> 00:09:24,470
is a plug-in it's already on our github

193
00:09:24,470 --> 00:09:28,310
account and we're we are focused on

194
00:09:28,310 --> 00:09:31,870
binary matching and not binary diffing

195
00:09:31,870 --> 00:09:35,480
the matching is done on geographical

196
00:09:35,480 --> 00:09:38,180
base which means we want to locate the

197
00:09:38,180 --> 00:09:40,520
binary we want to locate the open source

198
00:09:40,520 --> 00:09:45,590
and then locate each file inside and one

199
00:09:45,590 --> 00:09:48,710
important feature of our plug is that

200
00:09:48,710 --> 00:09:50,990
it's a high depth of mastic we compile

201
00:09:50,990 --> 00:09:53,030
the configuration for Lee PNG for

202
00:09:53,030 --> 00:09:56,960
example on x86 and then matched it on in

203
00:09:56,960 --> 00:10:00,110
our big endian 32 bits you simply could

204
00:10:00,110 --> 00:10:01,670
need to compile the configuration once

205
00:10:01,670 --> 00:10:05,150
and use it everywhere now let's see how

206
00:10:05,150 --> 00:10:09,940
it works the first stage is

207
00:10:09,940 --> 00:10:12,710
fingerprinting the open sources which

208
00:10:12,710 --> 00:10:14,900
are used inside a binary it's an

209
00:10:14,900 --> 00:10:19,370
independent stage it doesn't have

210
00:10:19,370 --> 00:10:21,440
anything in common with the matching

211
00:10:21,440 --> 00:10:23,570
phase so we can simply fingerprinting

212
00:10:23,570 --> 00:10:26,720
and that's it we want to find which

213
00:10:26,720 --> 00:10:28,940
versions are used which open sources

214
00:10:28,940 --> 00:10:31,940
exist and hopefully we'll get a specific

215
00:10:31,940 --> 00:10:37,160
version it works with for now it works

216
00:10:37,160 --> 00:10:39,020
with a basic string search and you can

217
00:10:39,020 --> 00:10:41,600
say ok you simply search for given

218
00:10:41,600 --> 00:10:44,300
strings why would that suffice to find

219
00:10:44,300 --> 00:10:47,450
Lee PNG or Z Leybourne Edison in P and

220
00:10:47,450 --> 00:10:49,370
it turns out it's it's good enough

221
00:10:49,370 --> 00:10:51,800
because if you look in this string a

222
00:10:51,800 --> 00:10:54,620
descriptive string from Lee PNG there's

223
00:10:54,620 --> 00:10:56,600
no reason that the credit for the

224
00:10:56,600 --> 00:10:58,820
developer will be in a string inside the

225
00:10:58,820 --> 00:11:01,130
binary usually it's comments in the open

226
00:11:01,130 --> 00:11:03,580
source but he decided to compile it in

227
00:11:03,580 --> 00:11:05,250
instead

228
00:11:05,250 --> 00:11:08,220
we should in the future improve this

229
00:11:08,220 --> 00:11:12,720
thing the search for constants or

230
00:11:12,720 --> 00:11:14,610
anything other than basic springs but

231
00:11:14,610 --> 00:11:18,509
even if we look on a common OpenSSL we

232
00:11:18,509 --> 00:11:20,730
can even see that it's an open SSL the

233
00:11:20,730 --> 00:11:22,620
specific version in the specific model

234
00:11:22,620 --> 00:11:24,870
and even the compilation date for the

235
00:11:24,870 --> 00:11:27,329
open source in the string inside the

236
00:11:27,329 --> 00:11:30,839
binary it it turns out that in most open

237
00:11:30,839 --> 00:11:33,060
sources that we looked for a popular in

238
00:11:33,060 --> 00:11:36,269
embedded point and devices you have such

239
00:11:36,269 --> 00:11:38,519
descriptive strings compiled inside it

240
00:11:38,519 --> 00:11:41,550
basic string search is enough for the

241
00:11:41,550 --> 00:11:44,399
beginning now that we know that it uses

242
00:11:44,399 --> 00:11:47,100
leap PNG or open SSL it's time to match

243
00:11:47,100 --> 00:11:51,050
the specific version inside or binary

244
00:11:51,050 --> 00:11:55,620
sorry okay you want to locate what we

245
00:11:55,620 --> 00:11:57,899
call anchor functions which are strong

246
00:11:57,899 --> 00:12:00,300
descriptive functions that we won't

247
00:12:00,300 --> 00:12:03,480
easily be confused with functions from

248
00:12:03,480 --> 00:12:05,399
other projects or other open sources

249
00:12:05,399 --> 00:12:07,670
which means that they should have a

250
00:12:07,670 --> 00:12:11,309
quite unique artifacts these could be

251
00:12:11,309 --> 00:12:13,620
unique numerical constants such as these

252
00:12:13,620 --> 00:12:18,209
constants form sha-2 you think and it

253
00:12:18,209 --> 00:12:20,610
could be some really really really long

254
00:12:20,610 --> 00:12:23,790
string from this version of lip PNG if

255
00:12:23,790 --> 00:12:26,040
you have this string inside your

256
00:12:26,040 --> 00:12:29,040
farewell it most probably holds Lib PNG

257
00:12:29,040 --> 00:12:32,100
and if one function refers to this thing

258
00:12:32,100 --> 00:12:35,370
you will know what this function is this

259
00:12:35,370 --> 00:12:38,069
means that using a unique enough

260
00:12:38,069 --> 00:12:40,500
constants we can search throughout the

261
00:12:40,500 --> 00:12:43,889
entire binary for anchor functions and

262
00:12:43,889 --> 00:12:47,129
once we found a single function we can

263
00:12:47,129 --> 00:12:49,769
zoom in because we know that the open

264
00:12:49,769 --> 00:12:51,750
source blue will compile to this

265
00:12:51,750 --> 00:12:55,500
specific area and it will look like this

266
00:12:55,500 --> 00:12:58,399
we will have K minus 1 functions

267
00:12:58,399 --> 00:13:01,319
potentially before this match and K

268
00:13:01,319 --> 00:13:03,779
minus 1 functions potentially after this

269
00:13:03,779 --> 00:13:06,990
match but the entire open source will be

270
00:13:06,990 --> 00:13:10,259
compiled into this specific area and it

271
00:13:10,259 --> 00:13:12,360
won't be scattered around the favorite

272
00:13:12,360 --> 00:13:16,620
space in other ways once you find a say

273
00:13:16,620 --> 00:13:18,870
first anchor we have many

274
00:13:18,870 --> 00:13:22,560
in the P&G we have roughly 50 we found

275
00:13:22,560 --> 00:13:24,410
all of the anchor functions we have

276
00:13:24,410 --> 00:13:27,540
matches to begin with and now for the

277
00:13:27,540 --> 00:13:34,920
next phase next phase okay now we can

278
00:13:34,920 --> 00:13:37,500
draw basic file boundaries around these

279
00:13:37,500 --> 00:13:39,570
matches exactly like we did when you

280
00:13:39,570 --> 00:13:42,030
zoomed in on the library itself if you

281
00:13:42,030 --> 00:13:44,760
know the function is contained in a file

282
00:13:44,760 --> 00:13:48,030
with five functions and we already found

283
00:13:48,030 --> 00:13:51,030
one we have basic boundaries around it

284
00:13:51,030 --> 00:13:53,070
and we could do the same all over all

285
00:13:53,070 --> 00:13:55,530
over all over again and sometimes two

286
00:13:55,530 --> 00:13:58,170
files will be adjacent enough to border

287
00:13:58,170 --> 00:13:58,680
each other

288
00:13:58,680 --> 00:14:01,800
so we'll have a better limit even simply

289
00:14:01,800 --> 00:14:04,320
saying okay we have a given set of

290
00:14:04,320 --> 00:14:06,060
functions that could be beneath us

291
00:14:06,060 --> 00:14:08,610
because we have an a lower bound from

292
00:14:08,610 --> 00:14:10,950
the upper bound of a given a file before

293
00:14:10,950 --> 00:14:13,830
us now we have basic file boundaries

294
00:14:13,830 --> 00:14:16,200
essentially we know where several files

295
00:14:16,200 --> 00:14:19,260
could reside some of the files will be

296
00:14:19,260 --> 00:14:22,200
floating we don't know where the files

297
00:14:22,200 --> 00:14:25,500
could be inside the scope area and we

298
00:14:25,500 --> 00:14:27,540
refer to them as omnipresent there could

299
00:14:27,540 --> 00:14:29,880
be anywhere when we'll find a single

300
00:14:29,880 --> 00:14:32,190
match for that file will pinpoint its

301
00:14:32,190 --> 00:14:37,230
location only now when we have this

302
00:14:37,230 --> 00:14:40,170
specific scope we can start building two

303
00:14:40,170 --> 00:14:41,610
canonical representation for each

304
00:14:41,610 --> 00:14:44,100
functions we know we want to know the

305
00:14:44,100 --> 00:14:46,740
size of the function the size of the

306
00:14:46,740 --> 00:14:51,690
storage stack the auricle strings no

307
00:14:51,690 --> 00:14:54,210
matter constants the strings a call

308
00:14:54,210 --> 00:14:56,040
graph everything we need to know about

309
00:14:56,040 --> 00:14:58,680
each function but we only need to do it

310
00:14:58,680 --> 00:15:01,140
for order of magnitude of K functions

311
00:15:01,140 --> 00:15:04,140
instead of n meaning that Philippian do

312
00:15:04,140 --> 00:15:05,820
we need to do it for roughly 400

313
00:15:05,820 --> 00:15:10,760
functions instead of 100,000 functions

314
00:15:11,540 --> 00:15:13,560
once we build its canonical

315
00:15:13,560 --> 00:15:15,030
representation we can refer to that

316
00:15:15,030 --> 00:15:17,940
function later on and it will look like

317
00:15:17,940 --> 00:15:20,310
this we know what is the frame size

318
00:15:20,310 --> 00:15:22,740
numerical constants which functions are

319
00:15:22,740 --> 00:15:25,740
being called and from this point onwards

320
00:15:25,740 --> 00:15:29,010
we will only work on this canonical

321
00:15:29,010 --> 00:15:32,000
representation of each function we don't

322
00:15:32,000 --> 00:15:35,120
need Ida anymore

323
00:15:35,120 --> 00:15:39,440
this means too that if you implement the

324
00:15:39,440 --> 00:15:43,420
basic pre-processing phase for your

325
00:15:43,420 --> 00:15:45,740
reverse engineering tool for example

326
00:15:45,740 --> 00:15:47,990
that out - you only need to implement

327
00:15:47,990 --> 00:15:51,160
this part the rest of the logic is

328
00:15:51,160 --> 00:15:54,320
completely a disassembly independent it

329
00:15:54,320 --> 00:15:59,480
only needs these representations now we

330
00:15:59,480 --> 00:16:02,330
need to look for file hints you find it

331
00:16:02,330 --> 00:16:06,050
in Microsoft binary use in many other

332
00:16:06,050 --> 00:16:10,010
devices you have traced strings form and

333
00:16:10,010 --> 00:16:14,000
traces form log outputs which often

334
00:16:14,000 --> 00:16:16,940
contains the name of the file so it will

335
00:16:16,940 --> 00:16:20,000
be a tcp dot C or RDP

336
00:16:20,000 --> 00:16:22,790
something-something dot C and this means

337
00:16:22,790 --> 00:16:24,470
that there are some functions which

338
00:16:24,470 --> 00:16:26,960
contain the name of the file inside them

339
00:16:26,960 --> 00:16:30,290
if you already know where the file

340
00:16:30,290 --> 00:16:32,690
should be we could look inside it and

341
00:16:32,690 --> 00:16:34,880
search for this these references and

342
00:16:34,880 --> 00:16:38,600
find more matches and sometimes you can

343
00:16:38,600 --> 00:16:40,430
find you know it's called area more

344
00:16:40,430 --> 00:16:43,750
files this gives more information and

345
00:16:43,750 --> 00:16:48,350
inside each file we have a agents it's

346
00:16:48,350 --> 00:16:50,570
like anchors but weaker they have

347
00:16:50,570 --> 00:16:52,760
locally unique numerical constants or

348
00:16:52,760 --> 00:16:56,060
locally any extremes and we can find

349
00:16:56,060 --> 00:16:59,060
them with a high to positive probability

350
00:16:59,060 --> 00:17:02,030
which means that the chances for error

351
00:17:02,030 --> 00:17:05,869
are slim in ly PNG on the office

352
00:17:05,869 --> 00:17:11,329
suitcase at this race we had roughly 70

353
00:17:11,329 --> 00:17:14,359
functions but were already matched even

354
00:17:14,359 --> 00:17:16,339
before we tried the traditional a

355
00:17:16,339 --> 00:17:18,920
matching of scoring similarities called

356
00:17:18,920 --> 00:17:24,050
RAF and every other ballistics which is

357
00:17:24,050 --> 00:17:26,720
the last phase here you do everything to

358
00:17:26,720 --> 00:17:28,970
do and every other tool being different

359
00:17:28,970 --> 00:17:32,630
to will be matching tor you walk on you

360
00:17:32,630 --> 00:17:34,940
score each feature you check what

361
00:17:34,940 --> 00:17:37,010
feature match what features don't match

362
00:17:37,010 --> 00:17:38,540
and you have the

363
00:17:38,540 --> 00:17:42,350
basic scoring function to declare if the

364
00:17:42,350 --> 00:17:44,120
functions are similar enough to be

365
00:17:44,120 --> 00:17:47,690
declared as matches this part is generic

366
00:17:47,690 --> 00:17:50,410
you can simply take it from your a tool

367
00:17:50,410 --> 00:17:53,690
plug it in and it will work the most

368
00:17:53,690 --> 00:17:55,370
important part is the geographic

369
00:17:55,370 --> 00:17:58,310
location because we have additional

370
00:17:58,310 --> 00:18:00,950
scoring we could use and we have penalty

371
00:18:00,950 --> 00:18:04,310
is rooted in fear also geographic

372
00:18:04,310 --> 00:18:05,780
matching means we have several

373
00:18:05,780 --> 00:18:09,050
assumptions which are hard rules we must

374
00:18:09,050 --> 00:18:09,710
obey

375
00:18:09,710 --> 00:18:13,430
this means that two kind of a candidate

376
00:18:13,430 --> 00:18:15,980
for a given file must reside on the

377
00:18:15,980 --> 00:18:19,190
scoped area of that file if you know

378
00:18:19,190 --> 00:18:21,680
that sha-1 in it should be in sha-1 dot

379
00:18:21,680 --> 00:18:23,780
c there's no reason to look for it on

380
00:18:23,780 --> 00:18:27,380
the file mp5 dot C or AES dot C or any

381
00:18:27,380 --> 00:18:29,480
other file if you already know the

382
00:18:29,480 --> 00:18:32,540
Chowan dot C has four candidates and we

383
00:18:32,540 --> 00:18:34,400
don't know which candidate is which

384
00:18:34,400 --> 00:18:36,620
function we only need to look for these

385
00:18:36,620 --> 00:18:39,290
four matches and that's it so we have a

386
00:18:39,290 --> 00:18:42,920
low a other space to look for meaning

387
00:18:42,920 --> 00:18:46,930
that it will be much faster and the

388
00:18:46,930 --> 00:18:53,240
probability for error is slim in

389
00:18:53,240 --> 00:18:55,430
addition most of the compilers tend to

390
00:18:55,430 --> 00:18:58,250
preserve the function audio which means

391
00:18:58,250 --> 00:19:01,100
that if I found sha-1 dot in it the next

392
00:19:01,100 --> 00:19:03,140
function will most probably be sha-1

393
00:19:03,140 --> 00:19:05,570
that digest and when sha-1 dot finalize

394
00:19:05,570 --> 00:19:07,250
because that's the order of the

395
00:19:07,250 --> 00:19:10,940
functions inside sha-1 dot c a Carter

396
00:19:10,940 --> 00:19:12,830
gradually learns if the compiler

397
00:19:12,830 --> 00:19:15,260
preserves the order or not and when

398
00:19:15,260 --> 00:19:19,180
adaptively boosted this gives a

399
00:19:19,180 --> 00:19:22,370
distinctive amount of matches with high

400
00:19:22,370 --> 00:19:25,460
probability if Carter found the compiler

401
00:19:25,460 --> 00:19:32,120
to preserve the order and walking on the

402
00:19:32,120 --> 00:19:34,490
neighbors of each function we could say

403
00:19:34,490 --> 00:19:38,380
that ok we had a free and streak of a

404
00:19:38,380 --> 00:19:40,910
function from the file match to a given

405
00:19:40,910 --> 00:19:43,670
binary this next function matched to the

406
00:19:43,670 --> 00:19:45,410
next function in the binary and so on

407
00:19:45,410 --> 00:19:48,050
and we can even guess that ok

408
00:19:48,050 --> 00:19:51,080
maybe even the next function will match

409
00:19:51,080 --> 00:19:53,210
in check and if the score will be big

410
00:19:53,210 --> 00:19:57,710
enough will matter that's how cada is a

411
00:19:57,710 --> 00:20:01,149
working and now how do you use it

412
00:20:01,149 --> 00:20:04,100
Carter compiles configurations from the

413
00:20:04,100 --> 00:20:05,659
open source because its source code

414
00:20:05,659 --> 00:20:08,630
assisted binary matching this means that

415
00:20:08,630 --> 00:20:10,250
you simply take your favorite open

416
00:20:10,250 --> 00:20:13,399
source you compile it in debug mode so

417
00:20:13,399 --> 00:20:16,779
we won't have compiler optimizations to

418
00:20:16,779 --> 00:20:20,120
compile the source you get the binaries

419
00:20:20,120 --> 00:20:25,600
and Carter is being trained on these

420
00:20:27,700 --> 00:20:30,500
later one read the configuration you we

421
00:20:30,500 --> 00:20:32,750
have several precompiled configurations

422
00:20:32,750 --> 00:20:35,929
on a github now when you have a given

423
00:20:35,929 --> 00:20:37,760
set of configurations the first phase

424
00:20:37,760 --> 00:20:40,760
face will be identifying the used open

425
00:20:40,760 --> 00:20:43,220
sources once we identify the given

426
00:20:43,220 --> 00:20:44,779
specific version and we have a

427
00:20:44,779 --> 00:20:47,570
configuration for it I'll take the

428
00:20:47,570 --> 00:20:49,490
binary we'll match it to get the

429
00:20:49,490 --> 00:20:52,159
specific configuration and now the metro

430
00:20:52,159 --> 00:20:54,440
will take the binary the configurations

431
00:20:54,440 --> 00:20:56,750
and we'll try to match it as simply as

432
00:20:56,750 --> 00:21:00,320
that and hopefully it will find most of

433
00:21:00,320 --> 00:21:03,110
the functions inside binary and we have

434
00:21:03,110 --> 00:21:04,880
an annotated banner way to start a

435
00:21:04,880 --> 00:21:07,279
research instead of reverse engineering

436
00:21:07,279 --> 00:21:08,840
the same functions all over all over

437
00:21:08,840 --> 00:21:10,960
again

438
00:21:10,960 --> 00:21:14,539
thumbs up ok this is a new part we added

439
00:21:14,539 --> 00:21:18,380
today it's on our github account or it

440
00:21:18,380 --> 00:21:22,789
should be on a github account now when

441
00:21:22,789 --> 00:21:25,340
working on x86 binary is a either does a

442
00:21:25,340 --> 00:21:27,799
pretty good job when working on film

443
00:21:27,799 --> 00:21:30,919
files for example arm files for research

444
00:21:30,919 --> 00:21:32,320
projects

445
00:21:32,320 --> 00:21:35,360
either could be improved it fails

446
00:21:35,360 --> 00:21:37,730
totally fine transitions between a arm

447
00:21:37,730 --> 00:21:40,460
in thumb code sections it fails to find

448
00:21:40,460 --> 00:21:44,690
many functions we need to improve the

449
00:21:44,690 --> 00:21:47,029
analysis so Carter could be used and

450
00:21:47,029 --> 00:21:51,350
instead of manually identifying well a

451
00:21:51,350 --> 00:21:53,149
function starts and where function ends

452
00:21:53,149 --> 00:21:55,730
which could be pretty meticulous

453
00:21:55,730 --> 00:21:58,700
I develop an additional part to be used

454
00:21:58,700 --> 00:22:01,970
with kata which uses really really

455
00:22:01,970 --> 00:22:02,710
really

456
00:22:02,710 --> 00:22:05,950
seek machinery in order to improve the

457
00:22:05,950 --> 00:22:08,440
analysis of either it's being trained on

458
00:22:08,440 --> 00:22:11,350
your own IDB and vanity proves the same

459
00:22:11,350 --> 00:22:14,110
ID be from the same file you could

460
00:22:14,110 --> 00:22:16,570
already find on a github account and

461
00:22:16,570 --> 00:22:19,809
this is the blog post for mr. suits

462
00:22:19,809 --> 00:22:22,169
published right now

463
00:22:22,169 --> 00:22:24,490
thumbs up should be used as

464
00:22:24,490 --> 00:22:27,570
pre-processing phase before using Carra

465
00:22:27,570 --> 00:22:30,640
we checked it on several film files and

466
00:22:30,640 --> 00:22:34,419
we actually used it on a MIPS binary and

467
00:22:34,419 --> 00:22:37,330
MIPS dll file before we started a

468
00:22:37,330 --> 00:22:41,169
current research project and it for the

469
00:22:41,169 --> 00:22:44,559
HP office dirty took 40,000 functions

470
00:22:44,559 --> 00:22:47,350
into 70,000 functions and on the MIPS

471
00:22:47,350 --> 00:22:50,320
finally took 200 and thousand functions

472
00:22:50,320 --> 00:22:55,690
into 50% more I think it works quite

473
00:22:55,690 --> 00:22:57,940
well for us maybe it will work also for

474
00:22:57,940 --> 00:23:01,929
you and now for the results we tested

475
00:23:01,929 --> 00:23:03,700
the main writing results after we

476
00:23:03,700 --> 00:23:08,250
manually analyzed Li PNG is 11 OpenSSL

477
00:23:08,250 --> 00:23:10,990
we have several disclaimers because open

478
00:23:10,990 --> 00:23:14,320
SSL is used it has 5000 functions only a

479
00:23:14,320 --> 00:23:19,210
3,000 3,500 functions were compiled

480
00:23:19,210 --> 00:23:22,210
inside the Officejet and i had to

481
00:23:22,210 --> 00:23:24,340
manually analyze each of the functions

482
00:23:24,340 --> 00:23:27,960
because that's how you test it

483
00:23:27,960 --> 00:23:30,730
eventually in the PNG we had 300

484
00:23:30,730 --> 00:23:33,309
functions we found all of them we found

485
00:23:33,309 --> 00:23:36,640
all of the excerpt functions but inside

486
00:23:36,640 --> 00:23:40,570
the HP Officejet fumer we had no false

487
00:23:40,570 --> 00:23:42,610
positives and it took less than 30

488
00:23:42,610 --> 00:23:45,279
seconds to find all of Li PNG inside a

489
00:23:45,279 --> 00:23:47,770
huge binary for a silly bit was even

490
00:23:47,770 --> 00:23:49,750
easier because it took roughly 20

491
00:23:49,750 --> 00:23:52,570
seconds and no false positives and even

492
00:23:52,570 --> 00:23:54,820
in open necessarily takes less than 20

493
00:23:54,820 --> 00:23:57,880
minutes to find the vast majority of

494
00:23:57,880 --> 00:24:01,960
functions inside open SSL with 8 false

495
00:24:01,960 --> 00:24:07,059
positives out of almost 3 K functions so

496
00:24:07,059 --> 00:24:09,779
in this test case it worked quite well

497
00:24:09,779 --> 00:24:12,010
later on we tested it on Windows

498
00:24:12,010 --> 00:24:14,169
binaries and other wineries and it seems

499
00:24:14,169 --> 00:24:16,900
to be consistent

500
00:24:16,900 --> 00:24:20,710
the result of when I executed kada on a

501
00:24:20,710 --> 00:24:23,920
VM on my laptop and these are the

502
00:24:23,920 --> 00:24:25,960
timings so it's not the best timing

503
00:24:25,960 --> 00:24:28,240
constraints probably could be faster on

504
00:24:28,240 --> 00:24:30,910
your computer but it's fast enough even

505
00:24:30,910 --> 00:24:34,240
an open SSL you can execute it go to eat

506
00:24:34,240 --> 00:24:36,340
something and wave before you get back

507
00:24:36,340 --> 00:24:40,350
it's finished only P&G leave the pigs

508
00:24:40,350 --> 00:24:44,920
silly it simply finishes fast and that's

509
00:24:44,920 --> 00:24:51,730
it why use kora there are many good open

510
00:24:51,730 --> 00:24:54,130
source and close source tools if it

511
00:24:54,130 --> 00:24:56,140
could be used for binary matching or

512
00:24:56,140 --> 00:25:01,210
binary diffing you have functions in

513
00:25:01,210 --> 00:25:03,820
search of Google DFO and P guys from

514
00:25:03,820 --> 00:25:06,520
Kishan you have been deceive an aversion

515
00:25:06,520 --> 00:25:10,000
of being this just came out every

516
00:25:10,000 --> 00:25:12,790
problem here is good but each program

517
00:25:12,790 --> 00:25:16,840
should be judged against the goal of the

518
00:25:16,840 --> 00:25:19,120
developer of the fan of the program

519
00:25:19,120 --> 00:25:22,180
because if you read the documentation of

520
00:25:22,180 --> 00:25:25,090
belief belief was being developed for

521
00:25:25,090 --> 00:25:28,270
pet diffing for a finding similarities

522
00:25:28,270 --> 00:25:31,690
in a different close enough binaries it

523
00:25:31,690 --> 00:25:35,500
wasn't designed to match open sources in

524
00:25:35,500 --> 00:25:38,950
a huge database of a fellow fire big ice

525
00:25:38,950 --> 00:25:41,560
is the same hey sorry the auto is the

526
00:25:41,560 --> 00:25:46,440
same because is more matching oriented

527
00:25:46,440 --> 00:25:49,210
eventually you could use beam this but

528
00:25:49,210 --> 00:25:51,310
it's it wasn't designed for binary

529
00:25:51,310 --> 00:25:54,100
matching and its really great for pet

530
00:25:54,100 --> 00:25:55,570
riffing so use it for if it's different

531
00:25:55,570 --> 00:25:59,170
instead if we compare the basic tools in

532
00:25:59,170 --> 00:26:01,780
our specific scenario of matching open

533
00:26:01,780 --> 00:26:05,740
source functions we could see this basic

534
00:26:05,740 --> 00:26:10,240
table and essentially there was no other

535
00:26:10,240 --> 00:26:12,970
tool was a hit actual Gnostic that works

536
00:26:12,970 --> 00:26:15,640
quite well on the origin of binaries and

537
00:26:15,640 --> 00:26:18,220
that is aimed upon matching the

538
00:26:18,220 --> 00:26:20,950
functions it's hard to match the

539
00:26:20,950 --> 00:26:22,990
functions and BL hit actual agnostic

540
00:26:22,990 --> 00:26:24,760
when you use fuzzy hashing luck in

541
00:26:24,760 --> 00:26:26,900
functions themselves and

542
00:26:26,900 --> 00:26:28,970
you can't use all of the features form

543
00:26:28,970 --> 00:26:31,880
the open source when you try to match

544
00:26:31,880 --> 00:26:36,650
because the gaius tries to compile the

545
00:26:36,650 --> 00:26:39,860
sources on its own and finding out

546
00:26:39,860 --> 00:26:43,550
macros and structs will differ from each

547
00:26:43,550 --> 00:26:47,930
execution and you if you simply compile

548
00:26:47,930 --> 00:26:50,059
it with a regular compiler you don't

549
00:26:50,059 --> 00:26:52,670
have to emulate a compiler to derive the

550
00:26:52,670 --> 00:26:58,130
features each tool here is good most of

551
00:26:58,130 --> 00:27:00,230
them were designed for binary matching

552
00:27:00,230 --> 00:27:02,059
we were designed for pet defend and they

553
00:27:02,059 --> 00:27:08,120
work well for positive that's it this is

554
00:27:08,120 --> 00:27:17,300
the tool thank you for coming that was

555
00:27:17,300 --> 00:27:18,800
great thank you so much

556
00:27:18,800 --> 00:27:21,350
high-five first we say love you talk

557
00:27:21,350 --> 00:27:23,750
ever forget so and hopefully more soon

558
00:27:23,750 --> 00:27:25,700
remember if you want to be a speaker at

559
00:27:25,700 --> 00:27:27,530
besides that avi if you have to submit

560
00:27:27,530 --> 00:27:29,660
to talk in our call for papers questions

561
00:27:29,660 --> 00:27:33,040
hey what's that courses we have time for

562
00:27:33,040 --> 00:27:35,960
one question we have time for one

563
00:27:35,960 --> 00:27:39,070
question for Alice

564
00:28:01,450 --> 00:28:05,299
okay so the question was a the first

565
00:28:05,299 --> 00:28:08,690
stage was a ankle functions and is it

566
00:28:08,690 --> 00:28:10,910
sensitive for different compilations and

567
00:28:10,910 --> 00:28:13,850
different compilers anchor matching uses

568
00:28:13,850 --> 00:28:17,720
a high enough enthalpy of numerical

569
00:28:17,720 --> 00:28:20,720
constants or long enough strings and the

570
00:28:20,720 --> 00:28:23,330
compilation doesn't change that so we

571
00:28:23,330 --> 00:28:26,750
only need to scan either to search for

572
00:28:26,750 --> 00:28:29,809
strings or a numerical constants the

573
00:28:29,809 --> 00:28:33,169
computation doesn't change that if you

574
00:28:33,169 --> 00:28:35,470
compile your own configuration without

575
00:28:35,470 --> 00:28:38,090
optimizations you will know which

576
00:28:38,090 --> 00:28:40,760
constants are connected to which

577
00:28:40,760 --> 00:28:43,070
functions and on the binary itself if

578
00:28:43,070 --> 00:28:45,080
you look for the computation doesn't

579
00:28:45,080 --> 00:28:47,150
change that at all so the anchors are

580
00:28:47,150 --> 00:28:49,820
quite stable hence the name and in

581
00:28:49,820 --> 00:28:52,100
libyans you had roughly 50 anchors and

582
00:28:52,100 --> 00:28:56,510
it finds most of them just before I

583
00:28:56,510 --> 00:28:59,390
finish we have a bill outside if you

584
00:28:59,390 --> 00:29:02,600
wish to work on such projects in a

585
00:29:02,600 --> 00:29:04,760
research group we have a course for a

586
00:29:04,760 --> 00:29:06,559
new employees and qhorin employee is

587
00:29:06,559 --> 00:29:09,320
called CSI and you could visit us in the

588
00:29:09,320 --> 00:29:13,389
booth in the kill zone

