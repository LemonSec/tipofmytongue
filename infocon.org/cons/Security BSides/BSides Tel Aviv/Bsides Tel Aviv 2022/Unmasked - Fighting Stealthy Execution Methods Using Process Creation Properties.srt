1
00:00:00,290 --> 00:00:03,220
[Music]

2
00:00:03,220 --> 00:00:03,740
[Applause]

3
00:00:03,740 --> 00:00:10,219
[Music]

4
00:00:10,219 --> 00:00:14,340
hi hello there dearest attendees uh my

5
00:00:14,340 --> 00:00:16,800
name's Philip and I was incapable of

6
00:00:16,800 --> 00:00:18,779
providing a correct email for the

7
00:00:18,779 --> 00:00:20,820
besides registration which makes me

8
00:00:20,820 --> 00:00:22,619
equipped to talk to you about technology

9
00:00:22,619 --> 00:00:26,160
and I work for Microsoft

10
00:00:26,160 --> 00:00:28,320
hey everyone my name is Amir I'm a

11
00:00:28,320 --> 00:00:30,000
senior engineer in Microsoft Defender

12
00:00:30,000 --> 00:00:32,520
for endpoint unlike Philip I do remember

13
00:00:32,520 --> 00:00:34,739
my email address so I sent the right man

14
00:00:34,739 --> 00:00:37,800
and that's it basically

15
00:00:37,800 --> 00:00:42,120
right so let's for let's for a moment

16
00:00:42,120 --> 00:00:44,520
suppose that you've had the privilege to

17
00:00:44,520 --> 00:00:47,160
run a piece of malware on someone's

18
00:00:47,160 --> 00:00:48,059
computer

19
00:00:48,059 --> 00:00:50,520
uh now don't worry this is the only meme

20
00:00:50,520 --> 00:00:51,899
in the presentation and pretty much

21
00:00:51,899 --> 00:00:53,579
everything else is like kernel debugger

22
00:00:53,579 --> 00:00:56,219
screenshots so do not worry

23
00:00:56,219 --> 00:00:59,280
so if you have this opportunity you

24
00:00:59,280 --> 00:01:03,120
mostly do not want to get detected and

25
00:01:03,120 --> 00:01:05,400
to do so you mostly don't want to look

26
00:01:05,400 --> 00:01:08,580
like I don't know malware.exe or any

27
00:01:08,580 --> 00:01:11,400
kind of weird process or executable and

28
00:01:11,400 --> 00:01:13,920
it's often preferable for you to seem

29
00:01:13,920 --> 00:01:15,720
like you're some kind of legitimate

30
00:01:15,720 --> 00:01:16,860
process

31
00:01:16,860 --> 00:01:19,619
even more beneficial if you're able to

32
00:01:19,619 --> 00:01:21,600
do your malicious stuff from a process

33
00:01:21,600 --> 00:01:24,119
that does similar stuff for example

34
00:01:24,119 --> 00:01:26,939
if you're connecting to the internet and

35
00:01:26,939 --> 00:01:30,360
talking by using SSL or whatever you

36
00:01:30,360 --> 00:01:31,920
would like to use a browser or something

37
00:01:31,920 --> 00:01:34,680
like that and there are no there are

38
00:01:34,680 --> 00:01:37,020
numerous techniques that allow you to do

39
00:01:37,020 --> 00:01:39,720
something like that uh the most

40
00:01:39,720 --> 00:01:41,700
prevalent category of those techniques

41
00:01:41,700 --> 00:01:44,280
is called process injection which is

42
00:01:44,280 --> 00:01:46,860
actually made out of two main categories

43
00:01:46,860 --> 00:01:49,860
two main Primitives first is a right

44
00:01:49,860 --> 00:01:52,140
primitive meaning that if I want to

45
00:01:52,140 --> 00:01:53,399
execute in the context of another

46
00:01:53,399 --> 00:01:56,100
process I would like to have my code

47
00:01:56,100 --> 00:01:58,259
inside of that process now there's a lot

48
00:01:58,259 --> 00:02:00,119
of different apis techniques and

49
00:02:00,119 --> 00:02:01,979
whatever that you can use for that you

50
00:02:01,979 --> 00:02:04,740
can you can manually allocate allocate

51
00:02:04,740 --> 00:02:06,240
memory inside of that process and then

52
00:02:06,240 --> 00:02:08,098
write to it you can map shared memory

53
00:02:08,098 --> 00:02:10,378
you can do a lot of stuff but in the end

54
00:02:10,378 --> 00:02:12,599
there's the right primitive that allows

55
00:02:12,599 --> 00:02:13,739
you to have

56
00:02:13,739 --> 00:02:16,440
your code inside of another process

57
00:02:16,440 --> 00:02:18,480
the other primitive that you need for

58
00:02:18,480 --> 00:02:20,700
that is an execution primitive because

59
00:02:20,700 --> 00:02:22,739
oh cool you have your own memory inside

60
00:02:22,739 --> 00:02:25,680
of a process but like who's gonna

61
00:02:25,680 --> 00:02:27,720
execute it why would that process run

62
00:02:27,720 --> 00:02:29,640
your code so there's a bunch of

63
00:02:29,640 --> 00:02:31,260
different apis that your piece of

64
00:02:31,260 --> 00:02:33,959
malware could use to actually divert the

65
00:02:33,959 --> 00:02:36,239
execution for for that process now you

66
00:02:36,239 --> 00:02:38,040
could start a new thread in that process

67
00:02:38,040 --> 00:02:39,959
and make it start executing your code or

68
00:02:39,959 --> 00:02:42,360
you could try to divert at least in

69
00:02:42,360 --> 00:02:44,280
Windows the execution of an existing

70
00:02:44,280 --> 00:02:46,019
thread using things like set thread

71
00:02:46,019 --> 00:02:49,620
context or apcs but this is not the only

72
00:02:49,620 --> 00:02:52,920
category of this kind of masquerading

73
00:02:52,920 --> 00:02:54,360
attack

74
00:02:54,360 --> 00:02:57,360
so another alternative is using some

75
00:02:57,360 --> 00:02:58,800
kind of something called process

76
00:02:58,800 --> 00:03:01,200
hollowing unlike process injection when

77
00:03:01,200 --> 00:03:02,879
you take an arbitrary process and

78
00:03:02,879 --> 00:03:05,280
introduce new code to it in process

79
00:03:05,280 --> 00:03:07,379
holding the basically you create your

80
00:03:07,379 --> 00:03:11,040
own process with a legitimate binary and

81
00:03:11,040 --> 00:03:13,440
you somehow replace the code with a

82
00:03:13,440 --> 00:03:16,260
malicious one how it basically work is

83
00:03:16,260 --> 00:03:18,659
you create a process in a suspended

84
00:03:18,659 --> 00:03:21,120
State and before it actually starts

85
00:03:21,120 --> 00:03:23,640
running you unmap all the legitimate

86
00:03:23,640 --> 00:03:26,040
memory of of the process and replace it

87
00:03:26,040 --> 00:03:29,400
with your own one then after you remap

88
00:03:29,400 --> 00:03:31,379
the process you're gonna you're just

89
00:03:31,379 --> 00:03:33,420
taking the initial thread and redirects

90
00:03:33,420 --> 00:03:35,760
it back to the new starting endpoint

91
00:03:35,760 --> 00:03:38,580
entry point of the process after you're

92
00:03:38,580 --> 00:03:40,980
completing the redirection you just

93
00:03:40,980 --> 00:03:43,200
resume the initial thread and the

94
00:03:43,200 --> 00:03:46,200
process starts the execution but it's

95
00:03:46,200 --> 00:03:49,819
running the malicious memory

96
00:03:49,819 --> 00:03:53,220
so in the last few years we observed a

97
00:03:53,220 --> 00:03:56,640
new static execution technique and which

98
00:03:56,640 --> 00:03:58,920
the fundamentals of it is basically

99
00:03:58,920 --> 00:04:02,280
unlike process enrolling that use a lot

100
00:04:02,280 --> 00:04:04,739
of memory operation I mean you go ahead

101
00:04:04,739 --> 00:04:07,560
you remap the files you unload some

102
00:04:07,560 --> 00:04:09,420
memory there's a lot of memory operation

103
00:04:09,420 --> 00:04:11,640
in between this specific class is

104
00:04:11,640 --> 00:04:14,040
focusing on the file system itself and

105
00:04:14,040 --> 00:04:16,680
the target of this class is basically

106
00:04:16,680 --> 00:04:18,959
created from malicious process from the

107
00:04:18,959 --> 00:04:22,500
disk and somehow do not leave any

108
00:04:22,500 --> 00:04:24,960
records of it the thing how it's work is

109
00:04:24,960 --> 00:04:28,259
by somehow allowing the attacker before

110
00:04:28,259 --> 00:04:30,660
the process starts execution to somehow

111
00:04:30,660 --> 00:04:33,300
revert the malicious content from the

112
00:04:33,300 --> 00:04:36,240
disk and so basically the process is

113
00:04:36,240 --> 00:04:38,699
initial is launched from a malicious a

114
00:04:38,699 --> 00:04:41,820
malicious image file and then the image

115
00:04:41,820 --> 00:04:45,600
file is being somehow rolled back and a

116
00:04:45,600 --> 00:04:47,940
benign content is being overwritten

117
00:04:47,940 --> 00:04:50,940
through the file itself and when the

118
00:04:50,940 --> 00:04:52,620
process starts the execution itself

119
00:04:52,620 --> 00:04:55,440
there's no actual content to be to

120
00:04:55,440 --> 00:04:57,600
actually scan

121
00:04:57,600 --> 00:05:00,060
so there's a bunch of examples in the

122
00:05:00,060 --> 00:05:02,460
last few years we observed one of them

123
00:05:02,460 --> 00:05:04,139
is called process Doppler gang for

124
00:05:04,139 --> 00:05:06,660
example that uses anti-fs transaction

125
00:05:06,660 --> 00:05:08,880
basically they create a file which is

126
00:05:08,880 --> 00:05:11,340
the transaction contacts they override a

127
00:05:11,340 --> 00:05:13,199
benign file with the malicious one and

128
00:05:13,199 --> 00:05:16,020
they create a process from that file but

129
00:05:16,020 --> 00:05:17,460
before they start they start the

130
00:05:17,460 --> 00:05:20,039
execution of the process they just roll

131
00:05:20,039 --> 00:05:22,800
back the identity NTFS transaction they

132
00:05:22,800 --> 00:05:25,740
never committed to the disk so the real

133
00:05:25,740 --> 00:05:28,620
content array isn't really committed

134
00:05:28,620 --> 00:05:31,380
another another approach within the

135
00:05:31,380 --> 00:05:32,639
another technique we've seen the right

136
00:05:32,639 --> 00:05:35,039
is called process hypertherapy basically

137
00:05:35,039 --> 00:05:37,380
like process Doppler gaming they get

138
00:05:37,380 --> 00:05:39,479
they get the same execution primitive

139
00:05:39,479 --> 00:05:42,360
they somehow get a writable handle to

140
00:05:42,360 --> 00:05:44,699
the process file and they just overwrite

141
00:05:44,699 --> 00:05:47,699
it with the benign content and again in

142
00:05:47,699 --> 00:05:49,139
the same way they do it they do it

143
00:05:49,139 --> 00:05:51,060
before the process execution and again

144
00:05:51,060 --> 00:05:54,060
when it when it starts execution we have

145
00:05:54,060 --> 00:05:55,740
nothing to scan for

146
00:05:55,740 --> 00:05:58,139
and the other the last Technique we can

147
00:05:58,139 --> 00:05:59,880
talk about is process ghosting which

148
00:05:59,880 --> 00:06:02,220
basically leverages deleted deletable

149
00:06:02,220 --> 00:06:04,740
handles to the file and they actually

150
00:06:04,740 --> 00:06:07,319
delete the file before the process does

151
00:06:07,319 --> 00:06:09,419
execution so when we want to scan it

152
00:06:09,419 --> 00:06:12,240
there's nothing on the disk

153
00:06:12,240 --> 00:06:15,000
so let's talk about our motivation for

154
00:06:15,000 --> 00:06:17,699
this session so we've seen all those

155
00:06:17,699 --> 00:06:19,139
kind of techniques and we want to

156
00:06:19,139 --> 00:06:22,080
understand why which OS properties make

157
00:06:22,080 --> 00:06:24,000
them work because if you think about it

158
00:06:24,000 --> 00:06:27,000
is it a process and it has a backing

159
00:06:27,000 --> 00:06:29,340
file which is completely different with

160
00:06:29,340 --> 00:06:31,620
for Miss memory which doesn't make a lot

161
00:06:31,620 --> 00:06:34,080
of sense right so we wanted to find out

162
00:06:34,080 --> 00:06:36,300
which dependencies and which primitive

163
00:06:36,300 --> 00:06:39,000
they are using inside the OS

164
00:06:39,000 --> 00:06:42,240
to actually understand how they work and

165
00:06:42,240 --> 00:06:44,580
once we find all the common ground and

166
00:06:44,580 --> 00:06:46,740
all the Primitives they are actually

167
00:06:46,740 --> 00:06:49,800
using hopefully we can build a robust

168
00:06:49,800 --> 00:06:52,919
detection mechanism that allows to to

169
00:06:52,919 --> 00:06:54,900
detect those anomalies and hopefully

170
00:06:54,900 --> 00:06:57,539
break the entire class and not just

171
00:06:57,539 --> 00:07:00,318
those techniques

172
00:07:00,960 --> 00:07:05,580
so when does antiviruses scan files

173
00:07:05,580 --> 00:07:07,800
optimally we would have scanned a file

174
00:07:07,800 --> 00:07:10,020
each time would have changed right and

175
00:07:10,020 --> 00:07:12,000
for every change we go ahead and scan it

176
00:07:12,000 --> 00:07:15,060
and see the actual content the problem

177
00:07:15,060 --> 00:07:17,039
is that from performance perspective

178
00:07:17,039 --> 00:07:18,780
it's not really acceptable you can't

179
00:07:18,780 --> 00:07:22,560
scan file all the time and so how we do

180
00:07:22,560 --> 00:07:24,840
it is basically try to scan it in a

181
00:07:24,840 --> 00:07:27,300
stable state for example when the file

182
00:07:27,300 --> 00:07:29,880
is being opened for use we know it's not

183
00:07:29,880 --> 00:07:32,340
doing editing or something we can safely

184
00:07:32,340 --> 00:07:35,580
scan it now another option is during the

185
00:07:35,580 --> 00:07:38,400
cleanup procedure a cleanup is where the

186
00:07:38,400 --> 00:07:40,620
handle for the file is being closed and

187
00:07:40,620 --> 00:07:43,020
the user basically says I'm done using

188
00:07:43,020 --> 00:07:44,759
the file I've done editing it I done

189
00:07:44,759 --> 00:07:47,039
reading and that's a really stable point

190
00:07:47,039 --> 00:07:49,979
for us to go ahead and scan the file

191
00:07:49,979 --> 00:07:53,099
another option is when a section object

192
00:07:53,099 --> 00:07:55,259
when we talk about the bit later is

193
00:07:55,259 --> 00:07:57,300
being created on top of the file as a

194
00:07:57,300 --> 00:07:58,940
part of the process creation for example

195
00:07:58,940 --> 00:08:01,860
because it's need to be in the same in a

196
00:08:01,860 --> 00:08:03,599
stable state to create a section that's

197
00:08:03,599 --> 00:08:05,639
a good place for us to scan as well

198
00:08:05,639 --> 00:08:08,879
and the last uh probably more optimal

199
00:08:08,879 --> 00:08:10,740
place to scan is when the process is

200
00:08:10,740 --> 00:08:12,840
actually created as an antivirus we can

201
00:08:12,840 --> 00:08:15,060
see those kind of event and that's a

202
00:08:15,060 --> 00:08:16,680
good place for us to go ahead and scan

203
00:08:16,680 --> 00:08:18,780
the file before we allow the process to

204
00:08:18,780 --> 00:08:20,940
execute

205
00:08:20,940 --> 00:08:22,220
right

206
00:08:22,220 --> 00:08:25,259
so to understand how this kind of

207
00:08:25,259 --> 00:08:27,240
technique can even exist which is

208
00:08:27,240 --> 00:08:28,680
basically some kind of time of check

209
00:08:28,680 --> 00:08:31,500
time of use attack because the moment we

210
00:08:31,500 --> 00:08:34,279
are able to scan the process or the file

211
00:08:34,279 --> 00:08:37,200
it's completely different from what we

212
00:08:37,200 --> 00:08:39,299
are expecting to be to be on disk we

213
00:08:39,299 --> 00:08:40,979
need to understand what can happen

214
00:08:40,979 --> 00:08:44,459
before that last opportunity before the

215
00:08:44,459 --> 00:08:46,800
process actually starts existing and to

216
00:08:46,800 --> 00:08:48,600
understand that we need to understand

217
00:08:48,600 --> 00:08:51,120
how the kernel views process creation or

218
00:08:51,120 --> 00:08:53,880
how a kernel antivirus driver could view

219
00:08:53,880 --> 00:08:55,380
process creation

220
00:08:55,380 --> 00:08:58,080
so process creation notifications or

221
00:08:58,080 --> 00:09:00,540
callbacks have been designed for this

222
00:09:00,540 --> 00:09:03,360
Express purpose it's to allow a driver

223
00:09:03,360 --> 00:09:05,820
to inspect every single created process

224
00:09:05,820 --> 00:09:07,860
and say oh this is good this is bad I

225
00:09:07,860 --> 00:09:09,420
want to do something to this

226
00:09:09,420 --> 00:09:12,060
now counter-intuitively

227
00:09:12,060 --> 00:09:14,459
process creation notifications are not

228
00:09:14,459 --> 00:09:16,920
executed when the process object is

229
00:09:16,920 --> 00:09:21,000
created but rather when the initial

230
00:09:21,000 --> 00:09:24,120
thread is inserted into that process

231
00:09:24,120 --> 00:09:26,279
and this is invoked in the context of

232
00:09:26,279 --> 00:09:28,620
the Creator process and not the one that

233
00:09:28,620 --> 00:09:31,399
is actually getting uh executed

234
00:09:31,399 --> 00:09:35,100
now this small distinction might not

235
00:09:35,100 --> 00:09:38,459
sound interesting until you start diving

236
00:09:38,459 --> 00:09:40,440
into the internals of Windows process

237
00:09:40,440 --> 00:09:41,640
creation

238
00:09:41,640 --> 00:09:44,459
the modern way to create processes in

239
00:09:44,459 --> 00:09:45,660
Windows

240
00:09:45,660 --> 00:09:48,080
is through an assist call called

241
00:09:48,080 --> 00:09:51,480
anti-create user process now this

242
00:09:51,480 --> 00:09:54,240
syscall gets an executable path as an

243
00:09:54,240 --> 00:09:56,580
input meaning that oh here's the path to

244
00:09:56,580 --> 00:09:58,800
I don't know cal.exe and whatever

245
00:09:58,800 --> 00:10:01,380
and when it enters the kernel it opens

246
00:10:01,380 --> 00:10:03,959
the file on its own creates the process

247
00:10:03,959 --> 00:10:06,300
the process object inserts the first

248
00:10:06,300 --> 00:10:08,880
thread does a bunch of other stuff and

249
00:10:08,880 --> 00:10:12,660
then returns this means that from the

250
00:10:12,660 --> 00:10:16,620
moment I actually call this function and

251
00:10:16,620 --> 00:10:19,920
and when it returns I already have an

252
00:10:19,920 --> 00:10:22,019
operational process perhaps not fully

253
00:10:22,019 --> 00:10:24,300
operational but something that already

254
00:10:24,300 --> 00:10:27,600
has opened the file already created the

255
00:10:27,600 --> 00:10:29,640
process object already has code and that

256
00:10:29,640 --> 00:10:31,079
code can run

257
00:10:31,079 --> 00:10:33,300
and there's really no time of check time

258
00:10:33,300 --> 00:10:35,940
of use thing here because

259
00:10:35,940 --> 00:10:36,899
um

260
00:10:36,899 --> 00:10:38,940
I can't really play around with the file

261
00:10:38,940 --> 00:10:41,880
as long as this syscall is executing

262
00:10:41,880 --> 00:10:44,579
and the process creation callback as

263
00:10:44,579 --> 00:10:47,579
we've said is executed and invoked

264
00:10:47,579 --> 00:10:50,760
during initial thread creation but this

265
00:10:50,760 --> 00:10:52,560
initial threat insertion into the into

266
00:10:52,560 --> 00:10:54,600
the process happens within the context

267
00:10:54,600 --> 00:10:57,720
of the of the syscall so looks like

268
00:10:57,720 --> 00:11:00,420
we're okay here we have our process

269
00:11:00,420 --> 00:11:02,820
creation callback being executed in this

270
00:11:02,820 --> 00:11:04,800
call stack and we can see that

271
00:11:04,800 --> 00:11:07,140
anti-create user process is somehow is

272
00:11:07,140 --> 00:11:09,120
somewhere near the the base of the

273
00:11:09,120 --> 00:11:12,000
kernel of the kernel mode call set so we

274
00:11:12,000 --> 00:11:13,860
should be okay no time check time views

275
00:11:13,860 --> 00:11:16,680
no race conditions the problem is

276
00:11:16,680 --> 00:11:19,680
this is not the only way to create

277
00:11:19,680 --> 00:11:22,740
processes in Windows and actually before

278
00:11:22,740 --> 00:11:26,160
Windows Vista there was another pair of

279
00:11:26,160 --> 00:11:28,079
Cisco's anti-create process and

280
00:11:28,079 --> 00:11:29,880
anti-create process EX

281
00:11:29,880 --> 00:11:32,760
now this Cisco pretty much breaks every

282
00:11:32,760 --> 00:11:35,459
single assumption an antivirus or an

283
00:11:35,459 --> 00:11:37,980
endpoint protection uh solution

284
00:11:37,980 --> 00:11:40,620
has regarding process Creation in the

285
00:11:40,620 --> 00:11:41,519
kernel

286
00:11:41,519 --> 00:11:44,339
first of all you don't really get a path

287
00:11:44,339 --> 00:11:46,320
to an executable as it doesn't to an

288
00:11:46,320 --> 00:11:48,720
executable as input and instead you have

289
00:11:48,720 --> 00:11:51,540
a section object that you need to obtain

290
00:11:51,540 --> 00:11:54,240
from previously opening a file on your

291
00:11:54,240 --> 00:11:56,579
own creating a section from that file

292
00:11:56,579 --> 00:12:00,300
and only then uh submitting it as an

293
00:12:00,300 --> 00:12:02,639
argument to the access call this means

294
00:12:02,639 --> 00:12:05,040
that between the creation of the file

295
00:12:05,040 --> 00:12:07,339
and the execution of the syscall we have

296
00:12:07,339 --> 00:12:09,959
arbitrary time that we can use to do

297
00:12:09,959 --> 00:12:11,120
whatever

298
00:12:11,120 --> 00:12:13,920
uh the the second thing that's

299
00:12:13,920 --> 00:12:15,959
interesting about the Cisco is that it

300
00:12:15,959 --> 00:12:18,660
creates exactly zero threads in the

301
00:12:18,660 --> 00:12:19,740
process

302
00:12:19,740 --> 00:12:21,420
why is that interesting

303
00:12:21,420 --> 00:12:23,700
because as we've said the process

304
00:12:23,700 --> 00:12:25,680
callbacks the process creation callbacks

305
00:12:25,680 --> 00:12:27,480
are executed

306
00:12:27,480 --> 00:12:30,839
within initial thread creation so we can

307
00:12:30,839 --> 00:12:33,360
open the file do whatever create the

308
00:12:33,360 --> 00:12:35,459
process to do whatever and then create

309
00:12:35,459 --> 00:12:37,220
the initial thread

310
00:12:37,220 --> 00:12:40,560
and after and we have this huge

311
00:12:40,560 --> 00:12:42,779
opportunity of arbitrary time in which

312
00:12:42,779 --> 00:12:47,060
we can do weird stuff to the to the file

313
00:12:47,060 --> 00:12:51,120
uh now let's look at a generalization of

314
00:12:51,120 --> 00:12:53,040
all of our attacks of of process ghost

315
00:12:53,040 --> 00:12:55,500
interpreter being and doppelganging and

316
00:12:55,500 --> 00:12:58,200
also a couple of other unpublished

317
00:12:58,200 --> 00:13:01,500
variants so the attacker opens a file in

318
00:13:01,500 --> 00:13:04,079
some kind of modifiable state this could

319
00:13:04,079 --> 00:13:06,240
be using a right handle this could be

320
00:13:06,240 --> 00:13:09,480
using a share right handle uh Delete

321
00:13:09,480 --> 00:13:11,459
access or even just a volatile

322
00:13:11,459 --> 00:13:14,700
transaction that could be rolled back

323
00:13:14,700 --> 00:13:17,639
after this we introduce malicious

324
00:13:17,639 --> 00:13:20,160
content to that file and we don't close

325
00:13:20,160 --> 00:13:22,320
the handle and as we've said we can't

326
00:13:22,320 --> 00:13:24,600
just scan on every right so this is just

327
00:13:24,600 --> 00:13:26,700
one more right nothing happened to this

328
00:13:26,700 --> 00:13:29,639
file that puts it into a new stable

329
00:13:29,639 --> 00:13:31,860
state so no scanning

330
00:13:31,860 --> 00:13:34,800
we then create a section and use that

331
00:13:34,800 --> 00:13:36,600
section to create a process

332
00:13:36,600 --> 00:13:38,040
again

333
00:13:38,040 --> 00:13:40,440
it's still not time for a scan because

334
00:13:40,440 --> 00:13:42,480
if you scan at this point for every

335
00:13:42,480 --> 00:13:45,060
process you will not be able to you know

336
00:13:45,060 --> 00:13:47,459
run any actual application code between

337
00:13:47,459 --> 00:13:49,500
your antivirus scans and will make your

338
00:13:49,500 --> 00:13:51,420
customers extremely angry

339
00:13:51,420 --> 00:13:55,800
so we still cannot scan at this point

340
00:13:55,800 --> 00:13:58,980
we then can revert the changes delete

341
00:13:58,980 --> 00:14:01,279
the file we roll back the transaction

342
00:14:01,279 --> 00:14:04,320
override the file with whatever and the

343
00:14:04,320 --> 00:14:07,380
section bits in the in memory are

344
00:14:07,380 --> 00:14:10,199
unchanged because that that is already

345
00:14:10,199 --> 00:14:12,720
something that has been mapped and only

346
00:14:12,720 --> 00:14:14,940
then can we create the initial thread of

347
00:14:14,940 --> 00:14:17,579
the process and now we have

348
00:14:17,579 --> 00:14:20,220
a process with malicious content and

349
00:14:20,220 --> 00:14:21,779
some weird file or maybe even a

350
00:14:21,779 --> 00:14:23,579
non-existent file

351
00:14:23,579 --> 00:14:26,279
but something that an AV really cannot

352
00:14:26,279 --> 00:14:28,260
find on disk and didn't have any

353
00:14:28,260 --> 00:14:31,860
opportunity to scan uh before we did our

354
00:14:31,860 --> 00:14:34,199
evil stuff

355
00:14:34,199 --> 00:14:36,420
so what do we want to detect here we

356
00:14:36,420 --> 00:14:38,519
want to detect two things one is this

357
00:14:38,519 --> 00:14:39,560
Legacy

358
00:14:39,560 --> 00:14:42,839
process creation API usage because if

359
00:14:42,839 --> 00:14:44,699
you use the modern process creation API

360
00:14:44,699 --> 00:14:47,519
you don't have the opportunity for a for

361
00:14:47,519 --> 00:14:49,980
a time of check time of use so if we

362
00:14:49,980 --> 00:14:52,620
don't have the opportunity to abuse this

363
00:14:52,620 --> 00:14:54,779
this is the prosecution is not

364
00:14:54,779 --> 00:14:57,899
interesting uh the second thing that we

365
00:14:57,899 --> 00:15:00,720
want to to understand is whether this

366
00:15:00,720 --> 00:15:02,699
time of check time of use was abused

367
00:15:02,699 --> 00:15:05,579
meaning that someone has actually done

368
00:15:05,579 --> 00:15:08,100
something weird to that file from which

369
00:15:08,100 --> 00:15:10,620
the process was created because it's not

370
00:15:10,620 --> 00:15:12,600
enough to have just Legacy apis you

371
00:15:12,600 --> 00:15:15,720
actually want to find an attack and when

372
00:15:15,720 --> 00:15:17,639
do we want to see this we want to see

373
00:15:17,639 --> 00:15:18,740
this

374
00:15:18,740 --> 00:15:22,680
at as as late as process creation

375
00:15:22,680 --> 00:15:25,079
notifications because we want to be able

376
00:15:25,079 --> 00:15:27,660
to stop this malicious process or this

377
00:15:27,660 --> 00:15:29,040
potentially most delicious process from

378
00:15:29,040 --> 00:15:31,920
executing and we want to do this using

379
00:15:31,920 --> 00:15:34,500
minimal scanning because again if we

380
00:15:34,500 --> 00:15:37,279
always can we can't run application code

381
00:15:37,279 --> 00:15:40,800
and while this is more secure throwing

382
00:15:40,800 --> 00:15:42,839
your computer out of the window is also

383
00:15:42,839 --> 00:15:45,120
more secure and we really want to run

384
00:15:45,120 --> 00:15:47,339
some kind of code

385
00:15:47,339 --> 00:15:49,740
so first let's talk about Legacy process

386
00:15:49,740 --> 00:15:51,660
creation

387
00:15:51,660 --> 00:15:53,940
so there are common patterns for this

388
00:15:53,940 --> 00:15:56,180
kind of for this kind of detection work

389
00:15:56,180 --> 00:15:58,500
which really aren't applicable because

390
00:15:58,500 --> 00:16:00,480
we want to detect this from the most

391
00:16:00,480 --> 00:16:03,600
privileged place we can so that user

392
00:16:03,600 --> 00:16:05,279
mode attackers can't really bypass our

393
00:16:05,279 --> 00:16:07,980
stuff first of all you could use user

394
00:16:07,980 --> 00:16:10,320
mode hooks but you're basically trying

395
00:16:10,320 --> 00:16:12,300
to mess around with a process that's

396
00:16:12,300 --> 00:16:14,940
completely controlled by an attacker and

397
00:16:14,940 --> 00:16:17,880
they can always unhook Your Hooks

398
00:16:17,880 --> 00:16:19,860
it might take a bit of effort but

399
00:16:19,860 --> 00:16:21,779
there's no vulnerability involved they

400
00:16:21,779 --> 00:16:23,720
will always do this if they need this

401
00:16:23,720 --> 00:16:26,220
another thing that you can do is call

402
00:16:26,220 --> 00:16:28,860
stack analysis the user mode call stack

403
00:16:28,860 --> 00:16:31,920
can also be forged if I wanted to look

404
00:16:31,920 --> 00:16:33,839
that there was some kind of arbitrary

405
00:16:33,839 --> 00:16:36,180
call stack I can just push the same

406
00:16:36,180 --> 00:16:39,000
addresses to the stack itself and then

407
00:16:39,000 --> 00:16:40,620
jump to whatever code I wanted to

408
00:16:40,620 --> 00:16:43,079
execute from so I can push all of my

409
00:16:43,079 --> 00:16:46,320
arguments uh or I actually can push a

410
00:16:46,320 --> 00:16:48,000
bunch of addresses push up push all of

411
00:16:48,000 --> 00:16:49,800
my arguments jump to whatever Cisco

412
00:16:49,800 --> 00:16:51,959
stuff I want and then I have an

413
00:16:51,959 --> 00:16:54,899
arbitrary uh user mode call stack

414
00:16:54,899 --> 00:16:56,759
kernel mode calls directs are also

415
00:16:56,759 --> 00:16:58,740
problematic because there's a lot of

416
00:16:58,740 --> 00:17:00,540
ways to create processes and threads

417
00:17:00,540 --> 00:17:03,540
from the kernel and operating systems

418
00:17:03,540 --> 00:17:05,699
change constantly so we can't really

419
00:17:05,699 --> 00:17:08,520
rely on one call stack remaining the

420
00:17:08,520 --> 00:17:12,000
same so this is also quite unreliable

421
00:17:12,000 --> 00:17:15,539
we could try to look at the the bits in

422
00:17:15,539 --> 00:17:18,599
memory versus the bits

423
00:17:18,599 --> 00:17:21,299
versus the bits on this

424
00:17:21,299 --> 00:17:25,319
at some point but this is uh again a

425
00:17:25,319 --> 00:17:27,059
strong perf concern so we do not want to

426
00:17:27,059 --> 00:17:28,079
do that

427
00:17:28,079 --> 00:17:30,660
we want to see if there's any way to

428
00:17:30,660 --> 00:17:32,820
detect this with zero scanning and with

429
00:17:32,820 --> 00:17:35,460
zero Reliance and user mode

430
00:17:35,460 --> 00:17:39,120
so to do this we've discovered uh we can

431
00:17:39,120 --> 00:17:42,360
use something called NTFS extra file X

432
00:17:42,360 --> 00:17:43,740
to create parameters

433
00:17:43,740 --> 00:17:46,799
this is a Windows File system feature

434
00:17:46,799 --> 00:17:51,000
that allows the kernel and other file

435
00:17:51,000 --> 00:17:54,299
system drivers or mini filter drivers to

436
00:17:54,299 --> 00:17:57,000
supply some kind of context to the to

437
00:17:57,000 --> 00:17:58,620
the file creation operation of the file

438
00:17:58,620 --> 00:18:01,740
why do we want this because for example

439
00:18:01,740 --> 00:18:04,200
it's useful for a file system to know

440
00:18:04,200 --> 00:18:06,539
whether a file was open remotely or

441
00:18:06,539 --> 00:18:08,400
whether a file was opened by some kind

442
00:18:08,400 --> 00:18:11,340
of weird kernel feature or file system

443
00:18:11,340 --> 00:18:13,799
features such as the prefetcher so that

444
00:18:13,799 --> 00:18:17,100
the operating system itself can treat it

445
00:18:17,100 --> 00:18:18,780
somehow differently

446
00:18:18,780 --> 00:18:20,280
now

447
00:18:20,280 --> 00:18:22,919
extra create parameters are basically

448
00:18:22,919 --> 00:18:24,780
just some kind of key Value Store where

449
00:18:24,780 --> 00:18:26,760
the key is the guide that said that

450
00:18:26,760 --> 00:18:28,559
tells you which kind of extra create

451
00:18:28,559 --> 00:18:31,980
parameter this is and the value is some

452
00:18:31,980 --> 00:18:34,440
kind of struct that well whoever needs

453
00:18:34,440 --> 00:18:36,179
to read that X to create parameter knows

454
00:18:36,179 --> 00:18:37,200
how to use

455
00:18:37,200 --> 00:18:38,580
uh

456
00:18:38,580 --> 00:18:40,919
now something funny about extra create

457
00:18:40,919 --> 00:18:43,320
parameters that is that there's

458
00:18:43,320 --> 00:18:46,320
a couple of documented kernel mode

459
00:18:46,320 --> 00:18:49,500
Windows apis that check whether this ECP

460
00:18:49,500 --> 00:18:51,240
extra p8 parameter

461
00:18:51,240 --> 00:18:53,760
originated from user mode or from kernel

462
00:18:53,760 --> 00:18:55,980
mode and this actually checks a bunch of

463
00:18:55,980 --> 00:18:58,320
internal kernel structures in the in the

464
00:18:58,320 --> 00:19:00,419
RP and the request package for the open

465
00:19:00,419 --> 00:19:02,580
request and checks whether there's a

466
00:19:02,580 --> 00:19:04,380
special flag there and this sounds

467
00:19:04,380 --> 00:19:06,780
interesting but there's actually no user

468
00:19:06,780 --> 00:19:08,460
mode functionality then can't Supply

469
00:19:08,460 --> 00:19:11,520
that so this entire function is enough

470
00:19:11,520 --> 00:19:15,120
and it's a no-op and if you're in user

471
00:19:15,120 --> 00:19:17,520
mode you can't really Forge any kind of

472
00:19:17,520 --> 00:19:20,280
extra create parameter now why is this

473
00:19:20,280 --> 00:19:22,919
interesting because during modern

474
00:19:22,919 --> 00:19:24,480
process creation

475
00:19:24,480 --> 00:19:26,640
and to create user process actually

476
00:19:26,640 --> 00:19:29,600
opens the file that we Supply as a path

477
00:19:29,600 --> 00:19:33,120
using and appends a specific extra

478
00:19:33,120 --> 00:19:35,760
create parameter to it it was actually

479
00:19:35,760 --> 00:19:38,100
made for for AVS but not for the express

480
00:19:38,100 --> 00:19:40,580
purpose of our attack

481
00:19:40,580 --> 00:19:44,580
and this thing actually contains the

482
00:19:44,580 --> 00:19:46,320
token of the Creator process but that's

483
00:19:46,320 --> 00:19:47,940
not as interesting for us what's

484
00:19:47,940 --> 00:19:50,700
interesting for us is that we need to

485
00:19:50,700 --> 00:19:54,840
supply to the Legacy API

486
00:19:54,840 --> 00:19:57,900
an open file handle or even a section

487
00:19:57,900 --> 00:20:00,179
created from an open file handle

488
00:20:00,179 --> 00:20:02,760
and if we're opening this from user mode

489
00:20:02,760 --> 00:20:05,280
there's no way we can make this look as

490
00:20:05,280 --> 00:20:07,200
if it has this ECP

491
00:20:07,200 --> 00:20:10,380
so right now we have an unforgeable Way

492
00:20:10,380 --> 00:20:13,100
by user mode to differentiate between

493
00:20:13,100 --> 00:20:15,960
modern process creation and Legacy

494
00:20:15,960 --> 00:20:18,840
process creation meaning that now if we

495
00:20:18,840 --> 00:20:21,720
don't see this ECP in in the open

496
00:20:21,720 --> 00:20:24,059
request for the file we know that oh

497
00:20:24,059 --> 00:20:26,520
there's a chance uh time of check time

498
00:20:26,520 --> 00:20:30,480
of use attack uh could be abused but as

499
00:20:30,480 --> 00:20:32,460
I've said this is not enough and we need

500
00:20:32,460 --> 00:20:34,980
to understand whether this attack was

501
00:20:34,980 --> 00:20:37,260
abused

502
00:20:37,260 --> 00:20:39,240
so as we understand that basically

503
00:20:39,240 --> 00:20:41,580
Legacy process allows the attacker the

504
00:20:41,580 --> 00:20:44,400
gap of the window that it can modify the

505
00:20:44,400 --> 00:20:46,919
file before it actually inserted the

506
00:20:46,919 --> 00:20:49,740
initial thread and gets scanned we still

507
00:20:49,740 --> 00:20:52,320
not understand why there's a process and

508
00:20:52,320 --> 00:20:54,900
a backing file which are complete not

509
00:20:54,900 --> 00:20:56,700
the same which is not make a lot of

510
00:20:56,700 --> 00:20:59,280
sense so let's dive a bit to the windows

511
00:20:59,280 --> 00:21:01,320
memory manager the first object we're

512
00:21:01,320 --> 00:21:03,480
going to talk about is section object a

513
00:21:03,480 --> 00:21:05,280
section object is basically an object

514
00:21:05,280 --> 00:21:07,440
that represents a shared memory across

515
00:21:07,440 --> 00:21:10,500
the operating system there are basically

516
00:21:10,500 --> 00:21:12,780
two types of section objects one of them

517
00:21:12,780 --> 00:21:15,480
are file backed basically shared memory

518
00:21:15,480 --> 00:21:18,120
that is created on top of a file it can

519
00:21:18,120 --> 00:21:21,480
be a data file just like any a text file

520
00:21:21,480 --> 00:21:24,360
or Word document which is basically the

521
00:21:24,360 --> 00:21:25,980
same as you see on the disk and there's

522
00:21:25,980 --> 00:21:28,919
also can be an image file that you can

523
00:21:28,919 --> 00:21:31,380
you can back up like in process for

524
00:21:31,380 --> 00:21:32,460
example

525
00:21:32,460 --> 00:21:35,280
the other type of section are page fire

526
00:21:35,280 --> 00:21:37,200
section page five section are basically

527
00:21:37,200 --> 00:21:40,140
a shared memory that is not backing by

528
00:21:40,140 --> 00:21:43,020
any file at all basically it also calls

529
00:21:43,020 --> 00:21:45,539
like memory section and basically you

530
00:21:45,539 --> 00:21:47,820
can share a bunch of memory Pages

531
00:21:47,820 --> 00:21:50,039
between different processes and it works

532
00:21:50,039 --> 00:21:51,419
just fine

533
00:21:51,419 --> 00:21:54,419
so when we talk about section mapping

534
00:21:54,419 --> 00:21:56,640
how we're going to actually going to map

535
00:21:56,640 --> 00:21:58,740
this section into memory there are two

536
00:21:58,740 --> 00:22:01,320
type of section mapping one of them is

537
00:22:01,320 --> 00:22:03,780
data mapping basically you want to view

538
00:22:03,780 --> 00:22:05,940
you you want to write your to your wall

539
00:22:05,940 --> 00:22:08,640
document and you want to map it the data

540
00:22:08,640 --> 00:22:11,520
that's in the memory it's the same as in

541
00:22:11,520 --> 00:22:13,080
the file it's basically a reflection

542
00:22:13,080 --> 00:22:16,260
every byte offset in in the memory is

543
00:22:16,260 --> 00:22:19,440
the same in as in the file but unlike

544
00:22:19,440 --> 00:22:23,039
data file and mapping an image file is a

545
00:22:23,039 --> 00:22:25,140
bit more complicated because it's highly

546
00:22:25,140 --> 00:22:28,500
rely on the PE format if you recall P

547
00:22:28,500 --> 00:22:30,840
format it contains a lot of section

548
00:22:30,840 --> 00:22:33,120
there's a text section with basically

549
00:22:33,120 --> 00:22:35,039
the code which is readable and

550
00:22:35,039 --> 00:22:37,260
executable there's the data section

551
00:22:37,260 --> 00:22:39,000
which is the read and write and all

552
00:22:39,000 --> 00:22:40,620
those kind of sections should be

553
00:22:40,620 --> 00:22:43,140
reflected differently in memory because

554
00:22:43,140 --> 00:22:44,880
in the process memory there's not it's

555
00:22:44,880 --> 00:22:47,580
not like one bulk of memory read that

556
00:22:47,580 --> 00:22:50,520
right execute every section Define the

557
00:22:50,520 --> 00:22:53,100
layout of the memory so there's a more

558
00:22:53,100 --> 00:22:57,320
complexity for mapping image files

559
00:22:57,720 --> 00:22:59,640
the other structure we're going to talk

560
00:22:59,640 --> 00:23:02,340
about is the control area so when each

561
00:23:02,340 --> 00:23:05,280
each time process want to open a shared

562
00:23:05,280 --> 00:23:07,679
memory to map it so you can use it it

563
00:23:07,679 --> 00:23:09,600
goes ahead and create the section object

564
00:23:09,600 --> 00:23:12,360
each process has its own sector object

565
00:23:12,360 --> 00:23:15,780
reference but we need how to connect all

566
00:23:15,780 --> 00:23:17,820
them together so all the section will

567
00:23:17,820 --> 00:23:21,539
point out to the same a pages so we can

568
00:23:21,539 --> 00:23:24,360
we can actually share data so each time

569
00:23:24,360 --> 00:23:27,299
a section is initially created there's a

570
00:23:27,299 --> 00:23:29,280
controller area that is created by the

571
00:23:29,280 --> 00:23:31,320
memory manager as well and the control

572
00:23:31,320 --> 00:23:34,260
area basically holds and maintains all

573
00:23:34,260 --> 00:23:36,960
the metadata we require to go and

574
00:23:36,960 --> 00:23:40,620
actually manage those short section

575
00:23:40,620 --> 00:23:43,440
either it's the segments it's the

576
00:23:43,440 --> 00:23:47,159
permission for the for the file

577
00:23:47,159 --> 00:23:49,320
um how many views are all currently

578
00:23:49,320 --> 00:23:51,299
mapped on the control area everything

579
00:23:51,299 --> 00:23:53,580
that the memory manager needs to know is

580
00:23:53,580 --> 00:23:56,700
centralized in the control area now it's

581
00:23:56,700 --> 00:23:58,980
important to note that because as we've

582
00:23:58,980 --> 00:24:00,600
said there are different type of mapping

583
00:24:00,600 --> 00:24:03,900
mapping data in images there's a control

584
00:24:03,900 --> 00:24:06,779
area created for each type of mapping

585
00:24:06,779 --> 00:24:09,000
there's a single control area for all

586
00:24:09,000 --> 00:24:11,400
the data mapping pointing out to one

587
00:24:11,400 --> 00:24:14,520
file and there's also an image control

588
00:24:14,520 --> 00:24:17,039
area that's pointed out to the image

589
00:24:17,039 --> 00:24:19,460
mapping

590
00:24:20,220 --> 00:24:23,659
and the last

591
00:24:24,960 --> 00:24:27,120
is a prototype it is

592
00:24:27,120 --> 00:24:30,260
segments basically

593
00:24:30,960 --> 00:24:36,320
itself basically it holds an array for

594
00:24:36,900 --> 00:24:39,840
this section this section and it's just

595
00:24:39,840 --> 00:24:42,299
an array of ptes but it's not a normal

596
00:24:42,299 --> 00:24:45,539
pities it's our prototyped PTS

597
00:24:45,539 --> 00:24:48,480
prototype pts are special kind of pts

598
00:24:48,480 --> 00:24:51,240
they are not really used by the hardware

599
00:24:51,240 --> 00:24:53,580
by the MU to go ahead and just execute

600
00:24:53,580 --> 00:24:55,919
code they are specifically used by the

601
00:24:55,919 --> 00:24:58,919
memory measure to Cache the physical

602
00:24:58,919 --> 00:25:01,980
Pages for the shell memory now each time

603
00:25:01,980 --> 00:25:06,620
a process wants to go ahead and map if

604
00:25:06,960 --> 00:25:11,480
the memory measure goes ahead and

605
00:25:13,100 --> 00:25:18,320
Proto pts so if you can if

606
00:25:18,960 --> 00:25:23,179
ptes that's going to be

607
00:25:26,779 --> 00:25:29,220
now let's talk let's talk a bit about

608
00:25:29,220 --> 00:25:32,880
section and backup file miscoherency so

609
00:25:32,880 --> 00:25:34,980
we know that the fact is that those

610
00:25:34,980 --> 00:25:36,120
techniques

611
00:25:36,120 --> 00:25:38,460
cause the process to run malicious code

612
00:25:38,460 --> 00:25:40,679
while the backend file is completely

613
00:25:40,679 --> 00:25:42,900
different and

614
00:25:42,900 --> 00:25:44,880
for obvious reasons there's some sort of

615
00:25:44,880 --> 00:25:47,520
miscoherency between the memory and the

616
00:25:47,520 --> 00:25:51,000
backing file but if you recall creating

617
00:25:51,000 --> 00:25:54,840
a section image requires a handle to a

618
00:25:54,840 --> 00:25:57,539
file section image cannot be created on

619
00:25:57,539 --> 00:25:59,880
the page file they handle so you cannot

620
00:25:59,880 --> 00:26:01,500
really you cannot really create second

621
00:26:01,500 --> 00:26:04,140
image that are totally on memory not

622
00:26:04,140 --> 00:26:06,539
upon file but

623
00:26:06,539 --> 00:26:09,659
when does this section is created is its

624
00:26:09,659 --> 00:26:11,940
responsibility of the memory manager to

625
00:26:11,940 --> 00:26:15,179
guarantee that the memory and the

626
00:26:15,179 --> 00:26:17,520
backing file will be coherent for all

627
00:26:17,520 --> 00:26:19,559
the light of the section because

628
00:26:19,559 --> 00:26:22,200
eventually when there's paging eye of

629
00:26:22,200 --> 00:26:24,500
from

630
00:26:24,960 --> 00:26:27,659
you need to move the pages back to the

631
00:26:27,659 --> 00:26:29,279
file and then we need to read from the

632
00:26:29,279 --> 00:26:30,960
file back we want when we want to

633
00:26:30,960 --> 00:26:33,419
restore execution so it's the memory

634
00:26:33,419 --> 00:26:35,640
magic guaranteed to provide it

635
00:26:35,640 --> 00:26:38,700
but as you've seen in all those

636
00:26:38,700 --> 00:26:41,820
techniques the attackers somehow used a

637
00:26:41,820 --> 00:26:43,919
modified handle like using transaction

638
00:26:43,919 --> 00:26:48,440
object writable file a file

639
00:26:49,080 --> 00:26:51,900
they don't use the read-only handles and

640
00:26:51,900 --> 00:26:54,500
if you think

641
00:26:54,960 --> 00:26:57,659
the image section but it knows that the

642
00:26:57,659 --> 00:26:59,960
handle

643
00:27:01,140 --> 00:27:05,960
I mean it can't guarantee that it will

644
00:27:06,900 --> 00:27:09,900
file and then the next paging IO the

645
00:27:09,900 --> 00:27:12,320
process will

646
00:27:12,960 --> 00:27:18,140
so in that point of the section creation

647
00:27:18,960 --> 00:27:22,200
doing those guarantees so what it's

648
00:27:22,200 --> 00:27:24,440
actually

649
00:27:24,899 --> 00:27:28,320
story to be backed up by the page file

650
00:27:28,320 --> 00:27:30,419
instead of the file it goes ahead to the

651
00:27:30,419 --> 00:27:33,140
physical pages

652
00:27:33,899 --> 00:27:36,419
make sure they go back to the page file

653
00:27:36,419 --> 00:27:38,520
and not the file itself so it's

654
00:27:38,520 --> 00:27:40,380
basically decouples between the two

655
00:27:40,380 --> 00:27:42,539
because it know it can't guarantee the

656
00:27:42,539 --> 00:27:45,360
coherency and the result is that you

657
00:27:45,360 --> 00:27:48,299
have an image section which is backed up

658
00:27:48,299 --> 00:27:51,080
by the file

659
00:27:51,899 --> 00:27:54,299
there's a file path and it all seems

660
00:27:54,299 --> 00:27:56,418
good

661
00:27:57,960 --> 00:28:00,380
oh

662
00:28:01,620 --> 00:28:05,120
so what we

663
00:28:06,960 --> 00:28:12,020
and that we have a suspicious that

664
00:28:12,899 --> 00:28:16,260
rather buy some arbitrary memory pages

665
00:28:16,260 --> 00:28:19,020
that have nothing to do with the file

666
00:28:19,020 --> 00:28:20,340
so

667
00:28:20,340 --> 00:28:23,460
as the memory manager goes ahead and

668
00:28:23,460 --> 00:28:27,500
inspects the file object and check if it

669
00:28:28,580 --> 00:28:31,320
deletable any what we call writable

670
00:28:31,320 --> 00:28:34,799
references it's automatically decides

671
00:28:34,799 --> 00:28:37,620
let's move it back to the page file and

672
00:28:37,620 --> 00:28:39,720
it does it in the section creation

673
00:28:39,720 --> 00:28:42,539
we can do the same thing and look in the

674
00:28:42,539 --> 00:28:44,640
process file object which is the same

675
00:28:44,640 --> 00:28:47,220
file objects in the section and see if

676
00:28:47,220 --> 00:28:49,620
it was open with writeable a whatever

677
00:28:49,620 --> 00:28:53,159
access deletable access anything thought

678
00:28:53,159 --> 00:28:57,120
of that and understand that if this how

679
00:28:57,120 --> 00:28:59,658
the fellow

680
00:29:00,960 --> 00:29:03,480
memory manager decided that it can

681
00:29:03,480 --> 00:29:05,640
guarantee the currency and everything

682
00:29:05,640 --> 00:29:07,620
should be moved back to the paging file

683
00:29:07,620 --> 00:29:10,080
so we can mark the process highly

684
00:29:10,080 --> 00:29:13,140
suspicious as we know there's

685
00:29:13,140 --> 00:29:15,059
most of the chances it's really running

686
00:29:15,059 --> 00:29:18,139
on memory only

687
00:29:19,980 --> 00:29:22,740
right so now we have two Primitives for

688
00:29:22,740 --> 00:29:25,440
detection the first is how we detect

689
00:29:25,440 --> 00:29:29,419
this Legacy API usage and as we've said

690
00:29:29,419 --> 00:29:32,220
if there's no uh process create

691
00:29:32,220 --> 00:29:34,940
anti-create user process ECP this means

692
00:29:34,940 --> 00:29:37,980
we are using almost in every case except

693
00:29:37,980 --> 00:29:40,500
for a couple of very scopable edge cases

694
00:29:40,500 --> 00:29:43,559
we are actually using the Legacy API and

695
00:29:43,559 --> 00:29:45,360
if you're somehow able to forge this

696
00:29:45,360 --> 00:29:47,460
thing because this is not a user mode

697
00:29:47,460 --> 00:29:50,279
functionality at all this probably means

698
00:29:50,279 --> 00:29:52,020
you have some kind of Kernel read write

699
00:29:52,020 --> 00:29:54,059
primitive which well you can do other

700
00:29:54,059 --> 00:29:55,860
better stuff with a read write primitive

701
00:29:55,860 --> 00:29:57,080
in the kernel

702
00:29:57,080 --> 00:30:00,899
uh so we can safely assume that

703
00:30:00,899 --> 00:30:03,659
if you don't see this ECP and the in the

704
00:30:03,659 --> 00:30:06,960
file creation uh operation then we are

705
00:30:06,960 --> 00:30:09,299
talking about this Legacy process

706
00:30:09,299 --> 00:30:12,360
creation API and this gives us

707
00:30:12,360 --> 00:30:13,919
opportunity for a time of check time

708
00:30:13,919 --> 00:30:15,000
views

709
00:30:15,000 --> 00:30:17,700
and just as the mirrors has explained

710
00:30:17,700 --> 00:30:18,899
right now

711
00:30:18,899 --> 00:30:21,120
we know that a file has probably been

712
00:30:21,120 --> 00:30:23,940
abused because weird stuff happened to

713
00:30:23,940 --> 00:30:26,940
the file to the file backing the the

714
00:30:26,940 --> 00:30:28,980
actual image section of the process

715
00:30:28,980 --> 00:30:30,659
because

716
00:30:30,659 --> 00:30:33,659
if this section coherency thing is

717
00:30:33,659 --> 00:30:36,779
broken and you can make something that

718
00:30:36,779 --> 00:30:39,360
doesn't make the memory manager Mark all

719
00:30:39,360 --> 00:30:41,760
of those pages as dirty you have a much

720
00:30:41,760 --> 00:30:44,100
more significant problem because now

721
00:30:44,100 --> 00:30:46,399
this is an OS stability problem because

722
00:30:46,399 --> 00:30:49,740
if my code gets paged out and then

723
00:30:49,740 --> 00:30:52,559
Windows tries to take this code from an

724
00:30:52,559 --> 00:30:55,260
entirely different file I can override

725
00:30:55,260 --> 00:30:57,600
the kernel I can overwrite I don't know

726
00:30:57,600 --> 00:30:59,340
some kind of driver I can override

727
00:30:59,340 --> 00:31:01,200
pretty much every piece of code that

728
00:31:01,200 --> 00:31:04,140
should be protected and this is a much

729
00:31:04,140 --> 00:31:07,320
more significant uh security and

730
00:31:07,320 --> 00:31:10,080
stability problem so as long as we

731
00:31:10,080 --> 00:31:12,360
assume there's no super cool zero day

732
00:31:12,360 --> 00:31:14,820
Happening Here we can assume that again

733
00:31:14,820 --> 00:31:17,220
no kind of user mode thing can forge

734
00:31:17,220 --> 00:31:18,360
this information

735
00:31:18,360 --> 00:31:21,779
and those two things together as we've

736
00:31:21,779 --> 00:31:23,700
seen from our data as we've seen from

737
00:31:23,700 --> 00:31:25,820
analyzing the code of EOS

738
00:31:25,820 --> 00:31:28,620
uh are pretty much a Surefire detection

739
00:31:28,620 --> 00:31:30,960
for every single one of the techniques

740
00:31:30,960 --> 00:31:33,720
we've mentioned and for any potential

741
00:31:33,720 --> 00:31:36,899
variation on this schema because as

742
00:31:36,899 --> 00:31:38,100
we've said

743
00:31:38,100 --> 00:31:41,159
if you can't forge this information from

744
00:31:41,159 --> 00:31:43,919
any from the user mode and if you have

745
00:31:43,919 --> 00:31:46,080
any other way that you can basically

746
00:31:46,080 --> 00:31:49,019
pull out the the memory rug from a from

747
00:31:49,019 --> 00:31:51,840
under the from under the process and do

748
00:31:51,840 --> 00:31:53,940
something weird to the file

749
00:31:53,940 --> 00:31:56,940
the the memory manager will know because

750
00:31:56,940 --> 00:31:58,860
it has to know so you don't get a blue

751
00:31:58,860 --> 00:31:59,880
screen

752
00:31:59,880 --> 00:32:02,460
so together with that we now have this

753
00:32:02,460 --> 00:32:05,880
super stable 100 uh through positive

754
00:32:05,880 --> 00:32:07,159
detection

755
00:32:07,159 --> 00:32:09,899
uh that really can be bypassed by user

756
00:32:09,899 --> 00:32:10,740
mode

757
00:32:10,740 --> 00:32:13,080
um and

758
00:32:13,080 --> 00:32:14,880
we've as I said we've tested this

759
00:32:14,880 --> 00:32:16,919
against a couple of other unpublished

760
00:32:16,919 --> 00:32:18,659
variants

761
00:32:18,659 --> 00:32:21,480
um and while there is a way to bypass

762
00:32:21,480 --> 00:32:24,539
this this is actually you know using

763
00:32:24,539 --> 00:32:26,340
some kind of driver and again you have a

764
00:32:26,340 --> 00:32:28,140
kernel read write primitive so do other

765
00:32:28,140 --> 00:32:30,720
cooler stuff uh if you're using a

766
00:32:30,720 --> 00:32:32,600
militia malicious driver

767
00:32:32,600 --> 00:32:36,960
uh so we at least believe this this

768
00:32:36,960 --> 00:32:39,059
entire class of techniques could be

769
00:32:39,059 --> 00:32:41,399
called by our stuff and if you want to

770
00:32:41,399 --> 00:32:43,620
be do something else you have to

771
00:32:43,620 --> 00:32:45,539
actually innovate it do something novel

772
00:32:45,539 --> 00:32:48,720
and not another variations of I know

773
00:32:48,720 --> 00:32:51,000
process bamboozling or whatever

774
00:32:51,000 --> 00:32:55,220
and that's it thank you for listening

775
00:32:57,670 --> 00:32:59,279
[Applause]

776
00:32:59,279 --> 00:33:02,600
I have a ton of time for questions

777
00:33:14,340 --> 00:33:16,740
um so there's a couple

778
00:33:16,740 --> 00:33:21,240
yes of course so we uh we were asked

779
00:33:21,240 --> 00:33:23,220
about false positives and examples for

780
00:33:23,220 --> 00:33:26,419
false positives so one such example

781
00:33:26,419 --> 00:33:29,340
is process cloning which is the weird

782
00:33:29,340 --> 00:33:33,360
name we Microsoft people call Fork

783
00:33:33,360 --> 00:33:37,140
um now when this happens uh a lot of

784
00:33:37,140 --> 00:33:39,360
weird stuff happens there's a bunch of

785
00:33:39,360 --> 00:33:41,220
apis that clone the process and then

786
00:33:41,220 --> 00:33:43,740
don't use the ACP even even though it's

787
00:33:43,740 --> 00:33:45,600
the modern API there's there are other

788
00:33:45,600 --> 00:33:48,419
apis that create a new process using

789
00:33:48,419 --> 00:33:50,460
anti-create process ex but then this

790
00:33:50,460 --> 00:33:52,200
process can never run code so it's not

791
00:33:52,200 --> 00:33:54,179
interesting for our case because go

792
00:33:54,179 --> 00:33:55,860
ahead open a new process that can't run

793
00:33:55,860 --> 00:33:58,260
code I mean I won't stop you

794
00:33:58,260 --> 00:34:00,779
but but yeah uh so those are the two

795
00:34:00,779 --> 00:34:03,260
main ones

796
00:34:03,960 --> 00:34:06,360
that's all that's all operating system

797
00:34:06,360 --> 00:34:08,219
functionality

798
00:34:08,219 --> 00:34:10,279
um

799
00:34:10,560 --> 00:34:13,320
you have iodide I suppose

800
00:34:13,320 --> 00:34:16,280
uh anyone else

801
00:34:17,579 --> 00:34:18,899
well it's time for us to take a drink

802
00:34:18,899 --> 00:34:19,730
then

803
00:34:19,730 --> 00:34:22,670
[Applause]

804
00:34:22,670 --> 00:34:25,370
[Music]

805
00:34:25,370 --> 00:34:28,560
[Applause]

