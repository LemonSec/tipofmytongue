1
00:00:00,290 --> 00:00:03,220
[Music]

2
00:00:03,220 --> 00:00:03,740
[Applause]

3
00:00:03,740 --> 00:00:09,880
[Music]

4
00:00:09,880 --> 00:00:12,559
[Applause]

5
00:00:12,559 --> 00:00:15,519
so first i want to

6
00:00:15,519 --> 00:00:17,680
thank to the besides team for organizing

7
00:00:17,680 --> 00:00:20,000
such a great conference and for the

8
00:00:20,000 --> 00:00:22,240
opportunity and to give for giving me

9
00:00:22,240 --> 00:00:24,560
the opportunity to speak here today

10
00:00:24,560 --> 00:00:27,690
and thank you for coming

11
00:00:27,690 --> 00:00:31,219
[Applause]

12
00:00:32,399 --> 00:00:34,960
so nice to meet you i'm muyan

13
00:00:34,960 --> 00:00:36,800
i really love windows internals and

14
00:00:36,800 --> 00:00:38,719
reverse engineering

15
00:00:38,719 --> 00:00:40,960
so we're going to have some fun today

16
00:00:40,960 --> 00:00:43,600
and generally learning new things

17
00:00:43,600 --> 00:00:46,079
i recently joined the app on my team as

18
00:00:46,079 --> 00:00:47,680
a security researcher

19
00:00:47,680 --> 00:00:49,120
[Applause]

20
00:00:49,120 --> 00:00:50,640
that's my team

21
00:00:50,640 --> 00:00:53,440
my they mostly do vulnerability research

22
00:00:53,440 --> 00:00:55,600
malware research and

23
00:00:55,600 --> 00:00:58,320
many kinds of research basically before

24
00:00:58,320 --> 00:01:01,760
that i was a low-level researcher and

25
00:01:01,760 --> 00:01:03,920
developer at symantec protecting from

26
00:01:03,920 --> 00:01:07,280
active directory attacks

27
00:01:08,799 --> 00:01:09,760
so

28
00:01:09,760 --> 00:01:10,880
usually

29
00:01:10,880 --> 00:01:12,960
i'm detecting malware but

30
00:01:12,960 --> 00:01:14,880
today i will take the attacker's point

31
00:01:14,880 --> 00:01:17,040
of view

32
00:01:17,040 --> 00:01:18,640
now let's say we want to take over the

33
00:01:18,640 --> 00:01:19,680
world

34
00:01:19,680 --> 00:01:22,640
and in order to do so we want to

35
00:01:22,640 --> 00:01:25,119
load and execute our code on a certain

36
00:01:25,119 --> 00:01:27,439
process

37
00:01:27,439 --> 00:01:28,479
now

38
00:01:28,479 --> 00:01:30,079
when pos says

39
00:01:30,079 --> 00:01:32,799
processes office often needs to load

40
00:01:32,799 --> 00:01:34,400
their code

41
00:01:34,400 --> 00:01:36,799
additional code on demand

42
00:01:36,799 --> 00:01:39,680
and in order to do so they can call the

43
00:01:39,680 --> 00:01:42,960
win api function load library

44
00:01:42,960 --> 00:01:47,040
this function uh not only implements the

45
00:01:47,040 --> 00:01:49,920
um not only loads it to the memory but

46
00:01:49,920 --> 00:01:51,040
does some

47
00:01:51,040 --> 00:01:54,079
more extra work behind the stage so in

48
00:01:54,079 --> 00:01:56,320
order for the code in the library to run

49
00:01:56,320 --> 00:01:58,560
successfully

50
00:01:58,560 --> 00:02:03,200
uh for example it might change

51
00:02:03,200 --> 00:02:05,360
it might change the right

52
00:02:05,360 --> 00:02:07,520
memory permissions according to the

53
00:02:07,520 --> 00:02:09,919
different sections inside of it

54
00:02:09,919 --> 00:02:13,040
uh it can resolve some relative

55
00:02:13,040 --> 00:02:14,560
addresses inside

56
00:02:14,560 --> 00:02:16,080
that the uh

57
00:02:16,080 --> 00:02:17,840
library code uses

58
00:02:17,840 --> 00:02:20,800
and it does many many other work

59
00:02:20,800 --> 00:02:23,760
preparation before it finally executes

60
00:02:23,760 --> 00:02:27,040
the library entry point

61
00:02:28,160 --> 00:02:30,480
now let's say that as the attackers we

62
00:02:30,480 --> 00:02:33,040
somehow gained access to this process to

63
00:02:33,040 --> 00:02:35,440
the ability to run a certain code tiny

64
00:02:35,440 --> 00:02:37,760
tiny payload

65
00:02:37,760 --> 00:02:39,200
on this process

66
00:02:39,200 --> 00:02:41,760
but we want to run some more complicated

67
00:02:41,760 --> 00:02:42,800
code

68
00:02:42,800 --> 00:02:47,200
so let's load it from a dll file

69
00:02:47,360 --> 00:02:49,280
now we can call the load library

70
00:02:49,280 --> 00:02:50,480
function

71
00:02:50,480 --> 00:02:52,720
but

72
00:02:52,959 --> 00:02:56,640
we will have two main problems with it

73
00:02:56,640 --> 00:02:57,760
first

74
00:02:57,760 --> 00:02:58,720
it is

75
00:02:58,720 --> 00:03:02,640
monitored by antiviruses edr products

76
00:03:02,640 --> 00:03:04,560
so it might get blocked or raise an

77
00:03:04,560 --> 00:03:06,560
alert

78
00:03:06,560 --> 00:03:08,000
second

79
00:03:08,000 --> 00:03:10,319
this function registers into internal

80
00:03:10,319 --> 00:03:12,720
structures of the operating system

81
00:03:12,720 --> 00:03:15,200
such as the loaded modulus that every

82
00:03:15,200 --> 00:03:16,879
process has

83
00:03:16,879 --> 00:03:19,200
so it might be a bit too

84
00:03:19,200 --> 00:03:21,760
loud or noisy if we want to hide

85
00:03:21,760 --> 00:03:24,000
ourselves

86
00:03:24,000 --> 00:03:25,760
what we can do

87
00:03:25,760 --> 00:03:28,319
is implement our own function

88
00:03:28,319 --> 00:03:29,599
that will be

89
00:03:29,599 --> 00:03:31,920
pretty similar

90
00:03:31,920 --> 00:03:34,079
to

91
00:03:35,680 --> 00:03:38,560
that will be pretty similar to the load

92
00:03:38,560 --> 00:03:40,879
library implement implementation

93
00:03:40,879 --> 00:03:45,720
but would skip the noisy part of it

94
00:03:47,760 --> 00:03:48,720
so

95
00:03:48,720 --> 00:03:50,720
we said that we can't use the load

96
00:03:50,720 --> 00:03:53,280
library function and we need to somehow

97
00:03:53,280 --> 00:03:55,360
um

98
00:03:55,360 --> 00:03:56,879
we need to somehow achieve its

99
00:03:56,879 --> 00:03:59,040
functionality by calling other bits of

100
00:03:59,040 --> 00:04:01,280
code

101
00:04:01,280 --> 00:04:03,519
from unexported functions down its call

102
00:04:03,519 --> 00:04:05,920
stack

103
00:04:06,000 --> 00:04:07,040
today

104
00:04:07,040 --> 00:04:09,439
actually this is exactly what reflective

105
00:04:09,439 --> 00:04:12,319
loader does and today we'll see how they

106
00:04:12,319 --> 00:04:15,120
do it

107
00:04:15,120 --> 00:04:18,000
but first what is a reflective loading

108
00:04:18,000 --> 00:04:19,600
reflective loader

109
00:04:19,600 --> 00:04:21,759
so reflective loading is a library

110
00:04:21,759 --> 00:04:23,199
injection technique

111
00:04:23,199 --> 00:04:26,560
it kind of implements a tiny

112
00:04:26,560 --> 00:04:29,520
minimal pe loader itself and eventually

113
00:04:29,520 --> 00:04:30,240
it

114
00:04:30,240 --> 00:04:31,440
um

115
00:04:31,440 --> 00:04:34,720
allocate and execute the payload

116
00:04:34,720 --> 00:04:37,199
from within the memory process

117
00:04:37,199 --> 00:04:40,160
the process memory

118
00:04:40,840 --> 00:04:44,160
now reflective loading is a widely used

119
00:04:44,160 --> 00:04:45,759
technique

120
00:04:45,759 --> 00:04:47,919
um

121
00:04:47,919 --> 00:04:50,000
and

122
00:04:50,000 --> 00:04:53,759
it exists in many uh

123
00:04:53,759 --> 00:04:57,520
in many open source tools such as

124
00:04:57,520 --> 00:05:00,080
blackboard

125
00:05:00,240 --> 00:05:02,400
if

126
00:05:03,759 --> 00:05:04,900
wait

127
00:05:04,900 --> 00:05:06,160
[Laughter]

128
00:05:06,160 --> 00:05:08,479
okay

129
00:05:08,479 --> 00:05:11,600
so it exists on many open source tools

130
00:05:11,600 --> 00:05:14,160
if you want to take a further look at it

131
00:05:14,160 --> 00:05:16,000
blackboard is a good example for one but

132
00:05:16,000 --> 00:05:16,880
there are

133
00:05:16,880 --> 00:05:20,000
really many others

134
00:05:20,000 --> 00:05:22,639
and

135
00:05:23,360 --> 00:05:25,199
this function

136
00:05:25,199 --> 00:05:28,400
is a function form and the blackboard

137
00:05:28,400 --> 00:05:31,120
source code i simplified it a bit so we

138
00:05:31,120 --> 00:05:33,759
can see easily the function that it

139
00:05:33,759 --> 00:05:35,360
looks for

140
00:05:35,360 --> 00:05:36,800
and every

141
00:05:36,800 --> 00:05:38,720
get pattern

142
00:05:38,720 --> 00:05:40,560
function name

143
00:05:40,560 --> 00:05:42,320
basically

144
00:05:42,320 --> 00:05:43,440
holds

145
00:05:43,440 --> 00:05:44,880
a

146
00:05:44,880 --> 00:05:46,320
how it

147
00:05:46,320 --> 00:05:49,199
implements how its

148
00:05:49,199 --> 00:05:51,759
search for the exported functions in

149
00:05:51,759 --> 00:05:54,240
memory

150
00:05:54,639 --> 00:05:57,039
today i will focus on the first

151
00:05:57,039 --> 00:06:00,960
function there the ldlp and ltla's data

152
00:06:00,960 --> 00:06:02,319
but

153
00:06:02,319 --> 00:06:04,560
notice that this choice is completely

154
00:06:04,560 --> 00:06:06,639
arbitrary you can

155
00:06:06,639 --> 00:06:08,000
use any

156
00:06:08,000 --> 00:06:10,160
other function you can use this search

157
00:06:10,160 --> 00:06:12,800
method that we'll see today in order to

158
00:06:12,800 --> 00:06:14,800
locate any other unexported functions

159
00:06:14,800 --> 00:06:17,520
you wish to find

160
00:06:17,840 --> 00:06:21,120
but first what our exported functions

161
00:06:21,120 --> 00:06:23,199
well

162
00:06:23,199 --> 00:06:26,160
uh function addresses inside the dll

163
00:06:26,160 --> 00:06:28,720
often changes between if the dll and

164
00:06:28,720 --> 00:06:30,080
some

165
00:06:30,080 --> 00:06:31,680
changes between different windows

166
00:06:31,680 --> 00:06:32,960
versions

167
00:06:32,960 --> 00:06:34,780
they usually do so

168
00:06:34,780 --> 00:06:37,840
[Music]

169
00:06:37,840 --> 00:06:40,479
in order to overcome this

170
00:06:40,479 --> 00:06:43,440
uh every module holds a table that maps

171
00:06:43,440 --> 00:06:46,080
between the function addresses

172
00:06:46,080 --> 00:06:47,919
the function names and their addresses

173
00:06:47,919 --> 00:06:49,759
in memory

174
00:06:49,759 --> 00:06:51,120
a

175
00:06:51,120 --> 00:06:54,720
dc table called exported export table

176
00:06:54,720 --> 00:06:57,199
and these functions are called exported

177
00:06:57,199 --> 00:06:58,960
functions

178
00:06:58,960 --> 00:07:01,199
unexported functions are all the

179
00:07:01,199 --> 00:07:02,800
functions that don't appear in this

180
00:07:02,800 --> 00:07:04,800
table so we have to look for it

181
00:07:04,800 --> 00:07:07,280
ourselves

182
00:07:08,240 --> 00:07:10,000
now

183
00:07:10,000 --> 00:07:13,039
while we can use exported functions

184
00:07:13,039 --> 00:07:16,880
both both statically

185
00:07:16,880 --> 00:07:19,599
just importing inside of our code the

186
00:07:19,599 --> 00:07:21,520
library and then just call it calling

187
00:07:21,520 --> 00:07:23,520
the function

188
00:07:23,520 --> 00:07:25,840
leaving the address resolving parts to

189
00:07:25,840 --> 00:07:27,120
the compiler

190
00:07:27,120 --> 00:07:29,759
or by dynamically

191
00:07:29,759 --> 00:07:32,240
get the process uh

192
00:07:32,240 --> 00:07:34,080
the

193
00:07:34,080 --> 00:07:36,240
function address in memory using the

194
00:07:36,240 --> 00:07:39,919
getpork address win api function

195
00:07:39,919 --> 00:07:42,639
with unexported functions we can since

196
00:07:42,639 --> 00:07:45,599
we they don't appear in this table

197
00:07:45,599 --> 00:07:50,240
so how can we allocate them ourselves

198
00:07:50,639 --> 00:07:51,759
now

199
00:07:51,759 --> 00:07:53,440
it is very

200
00:07:53,440 --> 00:07:56,639
important to understand this part

201
00:07:56,639 --> 00:07:58,479
effective loaders

202
00:07:58,479 --> 00:07:59,360
are

203
00:07:59,360 --> 00:08:01,680
need to resolve this function

204
00:08:01,680 --> 00:08:03,680
during runtime

205
00:08:03,680 --> 00:08:06,160
during runtime we don't have

206
00:08:06,160 --> 00:08:08,400
any symbols we don't have access to the

207
00:08:08,400 --> 00:08:09,840
function names

208
00:08:09,840 --> 00:08:12,319
we actually have no way to guarantee

209
00:08:12,319 --> 00:08:14,400
that we hit the right function or even

210
00:08:14,400 --> 00:08:18,080
in the start address of the function

211
00:08:18,080 --> 00:08:19,360
so

212
00:08:19,360 --> 00:08:22,479
we need to do a lot of

213
00:08:22,479 --> 00:08:24,479
research in advance we need to do some

214
00:08:24,479 --> 00:08:27,039
homework in order to tell them to tell

215
00:08:27,039 --> 00:08:29,199
it how we want to

216
00:08:29,199 --> 00:08:32,640
find it how can we find it and be really

217
00:08:32,640 --> 00:08:33,440
sure

218
00:08:33,440 --> 00:08:37,039
that this is the right address

219
00:08:38,240 --> 00:08:39,760
so today

220
00:08:39,760 --> 00:08:41,839
we'll explore three different ways to do

221
00:08:41,839 --> 00:08:42,719
it

222
00:08:42,719 --> 00:08:44,640
then we'll see how we can automate this

223
00:08:44,640 --> 00:08:45,680
process

224
00:08:45,680 --> 00:08:48,240
uh to make it easier for us to compare

225
00:08:48,240 --> 00:08:49,279
between

226
00:08:49,279 --> 00:08:51,360
the search data between the different

227
00:08:51,360 --> 00:08:53,120
windows versions

228
00:08:53,120 --> 00:08:55,680
and finally we'll be able to choose

229
00:08:55,680 --> 00:08:58,560
which one is the best way for our target

230
00:08:58,560 --> 00:09:00,959
function

231
00:09:02,640 --> 00:09:04,480
why do we need three different ways to

232
00:09:04,480 --> 00:09:06,320
locate this function

233
00:09:06,320 --> 00:09:08,720
can we just calculate its offset from

234
00:09:08,720 --> 00:09:09,440
the

235
00:09:09,440 --> 00:09:11,760
model started us

236
00:09:11,760 --> 00:09:15,839
well you might ask yourself that but

237
00:09:15,839 --> 00:09:18,320
the answer is that it would be very

238
00:09:18,320 --> 00:09:19,760
unstable

239
00:09:19,760 --> 00:09:20,959
in this case

240
00:09:20,959 --> 00:09:22,959
because we don't know in which part of

241
00:09:22,959 --> 00:09:25,440
the dll the function will be

242
00:09:25,440 --> 00:09:27,839
and

243
00:09:28,000 --> 00:09:30,320
it is very like likely that we will have

244
00:09:30,320 --> 00:09:33,040
to hold a different offset for every

245
00:09:33,040 --> 00:09:34,480
windows version

246
00:09:34,480 --> 00:09:38,480
we want something more generic than that

247
00:09:38,480 --> 00:09:42,399
but what if we could somehow uh

248
00:09:42,399 --> 00:09:44,800
calculate the offset from

249
00:09:44,800 --> 00:09:47,600
a a position that is closer to our

250
00:09:47,600 --> 00:09:49,760
function address then it will less

251
00:09:49,760 --> 00:09:54,160
likely to be changed this offset

252
00:09:54,880 --> 00:09:57,600
so our first method for today would be

253
00:09:57,600 --> 00:09:59,760
to locate a unique byte sequence within

254
00:09:59,760 --> 00:10:01,440
the

255
00:10:01,440 --> 00:10:03,680
boundaries of this function

256
00:10:03,680 --> 00:10:04,480
and

257
00:10:04,480 --> 00:10:07,200
then calculate our offset to the start

258
00:10:07,200 --> 00:10:10,160
address of the function

259
00:10:10,399 --> 00:10:12,640
so this is part of our target function

260
00:10:12,640 --> 00:10:13,760
code

261
00:10:13,760 --> 00:10:14,560
this

262
00:10:14,560 --> 00:10:17,519
is the it is the disassembled view for

263
00:10:17,519 --> 00:10:20,560
taken from the ida disassembler

264
00:10:20,560 --> 00:10:22,160
and

265
00:10:22,160 --> 00:10:24,079
it consists of two parts

266
00:10:24,079 --> 00:10:26,720
there is the instructions part

267
00:10:26,720 --> 00:10:27,600
and there

268
00:10:27,600 --> 00:10:30,399
is the actual vital presentation

269
00:10:30,399 --> 00:10:33,279
of it in memory

270
00:10:33,279 --> 00:10:35,920
now let's take a look at these commands

271
00:10:35,920 --> 00:10:36,880
which

272
00:10:36,880 --> 00:10:39,040
end their byte sequence which i assure

273
00:10:39,040 --> 00:10:40,720
you it is unique

274
00:10:40,720 --> 00:10:42,480
and why is it important for it to be

275
00:10:42,480 --> 00:10:44,320
unique

276
00:10:44,320 --> 00:10:45,760
well

277
00:10:45,760 --> 00:10:48,560
we want to avoid false positives

278
00:10:48,560 --> 00:10:51,600
if we will have this uh byte sequence in

279
00:10:51,600 --> 00:10:54,160
multiple locations on the dll we might

280
00:10:54,160 --> 00:10:55,279
reach the

281
00:10:55,279 --> 00:10:58,160
uh we won't hit the wrong function or

282
00:10:58,160 --> 00:11:00,880
the wrong address

283
00:11:00,880 --> 00:11:03,120
so it is very important for for it to be

284
00:11:03,120 --> 00:11:05,440
unique

285
00:11:06,320 --> 00:11:09,279
now let's say we locate this by sequence

286
00:11:09,279 --> 00:11:11,519
address inside the memory so it's pretty

287
00:11:11,519 --> 00:11:12,800
close to the

288
00:11:12,800 --> 00:11:15,760
to the start address of the memory

289
00:11:15,760 --> 00:11:17,440
and then all we have to do is to

290
00:11:17,440 --> 00:11:20,079
decrease from it the offset to the start

291
00:11:20,079 --> 00:11:23,120
of the moment of the function

292
00:11:23,120 --> 00:11:26,000
so our formula in this case would be

293
00:11:26,000 --> 00:11:28,160
to locate a unique by

294
00:11:28,160 --> 00:11:31,200
the the by sequence address

295
00:11:31,200 --> 00:11:34,240
which in this case would be this address

296
00:11:34,240 --> 00:11:37,440
then we can will be able to uh decrease

297
00:11:37,440 --> 00:11:39,600
from it its offset

298
00:11:39,600 --> 00:11:42,399
which in our case would be 46

299
00:11:42,399 --> 00:11:44,800
for this windows version

300
00:11:44,800 --> 00:11:47,120
and finally we'll get this address which

301
00:11:47,120 --> 00:11:49,200
is

302
00:11:49,200 --> 00:11:50,880
happen to be the

303
00:11:50,880 --> 00:11:53,680
function address

304
00:11:55,760 --> 00:11:57,440
i started my way as an automation

305
00:11:57,440 --> 00:12:00,079
developer so it was only natural for me

306
00:12:00,079 --> 00:12:03,600
to try and automate all this process

307
00:12:03,600 --> 00:12:06,639
so let's see how we can automate

308
00:12:06,639 --> 00:12:08,959
it

309
00:12:09,040 --> 00:12:10,560
so this is ida

310
00:12:10,560 --> 00:12:12,480
the uh the view

311
00:12:12,480 --> 00:12:13,600
ida main

312
00:12:13,600 --> 00:12:15,040
window

313
00:12:15,040 --> 00:12:19,040
and it consists it has a built-in python

314
00:12:19,040 --> 00:12:24,399
interpreter in every in idapo versions

315
00:12:24,399 --> 00:12:26,399
it's it's an actual python interpreter

316
00:12:26,399 --> 00:12:28,800
just as we know it and

317
00:12:28,800 --> 00:12:32,880
we can run a command inside of it

318
00:12:32,880 --> 00:12:36,000
uh which is pretty uh helpful and we'll

319
00:12:36,000 --> 00:12:38,240
see today why

320
00:12:38,240 --> 00:12:40,160
we also have two other

321
00:12:40,160 --> 00:12:42,880
options for running python scripts on

322
00:12:42,880 --> 00:12:44,560
ida

323
00:12:44,560 --> 00:12:46,639
we have the script command

324
00:12:46,639 --> 00:12:47,440
which

325
00:12:47,440 --> 00:12:49,200
is an interface that allows us to run

326
00:12:49,200 --> 00:12:51,839
multi-line python commands

327
00:12:51,839 --> 00:12:56,800
and we can also import a code from

328
00:12:56,800 --> 00:12:59,279
python files or export what we wrote

329
00:12:59,279 --> 00:13:00,079
there

330
00:13:00,079 --> 00:13:02,160
to uh script files

331
00:13:02,160 --> 00:13:04,320
and we can also run it

332
00:13:04,320 --> 00:13:05,600
and getting the

333
00:13:05,600 --> 00:13:07,040
outputs

334
00:13:07,040 --> 00:13:11,040
inside of our python interpreter

335
00:13:11,360 --> 00:13:14,240
another option is if you already have a

336
00:13:14,240 --> 00:13:16,399
propelled script you can just run it

337
00:13:16,399 --> 00:13:20,200
using the escape file

338
00:13:20,320 --> 00:13:22,240
now how can we automate our search

339
00:13:22,240 --> 00:13:23,920
process

340
00:13:23,920 --> 00:13:26,639
uh we said that we have to locate a

341
00:13:26,639 --> 00:13:29,760
unique the unique by sequence address

342
00:13:29,760 --> 00:13:31,279
and then

343
00:13:31,279 --> 00:13:33,600
we want to validate that we hit the

344
00:13:33,600 --> 00:13:35,120
right address

345
00:13:35,120 --> 00:13:39,440
because we are doing it before

346
00:13:39,440 --> 00:13:41,680
and we are doing only the preparations

347
00:13:41,680 --> 00:13:42,639
now

348
00:13:42,639 --> 00:13:45,760
we have either symbols and we can

349
00:13:45,760 --> 00:13:46,880
know

350
00:13:46,880 --> 00:13:49,839
what the uh function address

351
00:13:49,839 --> 00:13:50,639
a

352
00:13:50,639 --> 00:13:53,680
using its name

353
00:13:53,760 --> 00:13:54,959
so

354
00:13:54,959 --> 00:13:56,240
we said that we

355
00:13:56,240 --> 00:13:58,720
uh we are calculating our function

356
00:13:58,720 --> 00:14:00,399
address using this

357
00:14:00,399 --> 00:14:02,560
by sequence address and the decreasing

358
00:14:02,560 --> 00:14:05,600
format the offset

359
00:14:05,600 --> 00:14:06,720
and

360
00:14:06,720 --> 00:14:08,720
eventually we want to make sure that we

361
00:14:08,720 --> 00:14:10,399
hit the right function so we'll compare

362
00:14:10,399 --> 00:14:11,360
it

363
00:14:11,360 --> 00:14:14,720
to this uh output uh from this function

364
00:14:14,720 --> 00:14:16,800
which is an id api function that allows

365
00:14:16,800 --> 00:14:17,920
us to

366
00:14:17,920 --> 00:14:19,360
locate a function

367
00:14:19,360 --> 00:14:22,079
using its name

368
00:14:22,320 --> 00:14:25,360
then all we have to do is to print

369
00:14:25,360 --> 00:14:28,839
the right message whether we found it or

370
00:14:28,839 --> 00:14:31,360
not once we run it

371
00:14:31,360 --> 00:14:34,000
we see that we successfully found

372
00:14:34,000 --> 00:14:36,959
our our function using the search data

373
00:14:36,959 --> 00:14:39,599
so that's cool

374
00:14:40,320 --> 00:14:42,639
now we want to be able to run it on

375
00:14:42,639 --> 00:14:44,639
multiple files because we don't want to

376
00:14:44,639 --> 00:14:46,480
manually run it on for

377
00:14:46,480 --> 00:14:49,040
every windows version right there too

378
00:14:49,040 --> 00:14:50,240
many

379
00:14:50,240 --> 00:14:51,040
so

380
00:14:51,040 --> 00:14:53,600
how can we do it

381
00:14:53,600 --> 00:14:57,760
actually we can use ida and python again

382
00:14:57,760 --> 00:14:59,120
how

383
00:14:59,120 --> 00:15:00,639
so

384
00:15:00,639 --> 00:15:02,240
uh

385
00:15:02,240 --> 00:15:04,720
ida allows us to run script from a

386
00:15:04,720 --> 00:15:07,600
command line we don't have to open

387
00:15:07,600 --> 00:15:10,320
the dll file with the guru and we can

388
00:15:10,320 --> 00:15:14,560
easily automate it there are two uh

389
00:15:14,560 --> 00:15:16,560
arguments which are relevant relevant

390
00:15:16,560 --> 00:15:18,240
for our case

391
00:15:18,240 --> 00:15:21,199
a a is for autonomous mode and s is for

392
00:15:21,199 --> 00:15:24,000
running script which in our case would

393
00:15:24,000 --> 00:15:28,959
be uh a patent ido python script

394
00:15:28,959 --> 00:15:30,000
a

395
00:15:30,000 --> 00:15:33,920
this is how the command should look like

396
00:15:34,880 --> 00:15:37,279
now we can use this uh command line

397
00:15:37,279 --> 00:15:39,279
feature to

398
00:15:39,279 --> 00:15:41,920
write another python script

399
00:15:41,920 --> 00:15:43,120
and

400
00:15:43,120 --> 00:15:44,720
then iterate

401
00:15:44,720 --> 00:15:47,279
all the dll files from every windows

402
00:15:47,279 --> 00:15:49,440
version and run it

403
00:15:49,440 --> 00:15:52,399
using the command line

404
00:15:53,120 --> 00:15:55,600
so we will have to adjust our script

405
00:15:55,600 --> 00:15:58,000
first to be able to run form a command

406
00:15:58,000 --> 00:16:00,399
line so it will take its argument from

407
00:16:00,399 --> 00:16:02,399
the command line

408
00:16:02,399 --> 00:16:04,560
and instead of printing it to the a

409
00:16:04,560 --> 00:16:06,399
built-in interpreter we will have to

410
00:16:06,399 --> 00:16:10,320
save our results into a file

411
00:16:10,399 --> 00:16:13,360
we also have two of two

412
00:16:13,360 --> 00:16:15,440
id api functions

413
00:16:15,440 --> 00:16:19,360
one is allows us to wait until

414
00:16:19,360 --> 00:16:22,000
the db and all the symbols are loaded

415
00:16:22,000 --> 00:16:23,360
successfully

416
00:16:23,360 --> 00:16:25,759
and the other one just exits gracefully

417
00:16:25,759 --> 00:16:28,560
from the ida

418
00:16:31,839 --> 00:16:33,279
next

419
00:16:33,279 --> 00:16:35,440
now we want to have a separate file

420
00:16:35,440 --> 00:16:38,720
another python script that will hold all

421
00:16:38,720 --> 00:16:41,360
of our search data

422
00:16:41,360 --> 00:16:43,600
for and all of our

423
00:16:43,600 --> 00:16:45,199
dll

424
00:16:45,199 --> 00:16:47,599
files

425
00:16:48,240 --> 00:16:51,040
the search data consists of the by

426
00:16:51,040 --> 00:16:53,120
sequence address and its offset just

427
00:16:53,120 --> 00:16:55,759
like we saw

428
00:16:55,759 --> 00:16:58,000
and now we'll want to

429
00:16:58,000 --> 00:16:59,519
open a

430
00:16:59,519 --> 00:17:01,519
file with the relevant headers and

431
00:17:01,519 --> 00:17:02,720
everything

432
00:17:02,720 --> 00:17:04,959
for our output

433
00:17:04,959 --> 00:17:08,799
and then we will just iterate the uh

434
00:17:08,799 --> 00:17:12,079
every uh file and will execute

435
00:17:12,079 --> 00:17:15,280
the cmd command

436
00:17:15,919 --> 00:17:18,400
after we run this uh this script

437
00:17:18,400 --> 00:17:20,400
this is the results that we get

438
00:17:20,400 --> 00:17:22,959
we see that we uh successfully found

439
00:17:22,959 --> 00:17:27,280
using this uh search data for uh

440
00:17:27,280 --> 00:17:29,440
this function on four different windows

441
00:17:29,440 --> 00:17:32,160
versions but that's not good enough we

442
00:17:32,160 --> 00:17:33,840
still have five

443
00:17:33,840 --> 00:17:36,080
uh windows versions that we couldn't

444
00:17:36,080 --> 00:17:39,200
find our function using there's it's

445
00:17:39,200 --> 00:17:41,280
this search data

446
00:17:41,280 --> 00:17:43,760
so we have to somewhere some to somehow

447
00:17:43,760 --> 00:17:47,559
fix the search data

448
00:17:47,919 --> 00:17:49,679
we said that it consists of

449
00:17:49,679 --> 00:17:52,880
byte sequence and an offset right so one

450
00:17:52,880 --> 00:17:55,520
of them is probably wrong

451
00:17:55,520 --> 00:17:59,120
the question is which one of them

452
00:17:59,120 --> 00:18:02,240
so we'll go back to our script

453
00:18:02,240 --> 00:18:04,000
and this time we can add a function that

454
00:18:04,000 --> 00:18:05,840
will allow us to

455
00:18:05,840 --> 00:18:08,080
uh debug it

456
00:18:08,080 --> 00:18:08,960
and

457
00:18:08,960 --> 00:18:10,880
this time

458
00:18:10,880 --> 00:18:13,280
if we won't find the sequence

459
00:18:13,280 --> 00:18:15,600
the byte sequence address we will print

460
00:18:15,600 --> 00:18:17,600
the right message

461
00:18:17,600 --> 00:18:20,000
if we did find the by sequence address

462
00:18:20,000 --> 00:18:23,280
then the offset might be wrong so let's

463
00:18:23,280 --> 00:18:26,080
try to recalculate it and see if where

464
00:18:26,080 --> 00:18:29,840
what is the right offset

465
00:18:31,840 --> 00:18:34,000
so i ran this file i took the latest

466
00:18:34,000 --> 00:18:36,720
windows version that it didn't worked on

467
00:18:36,720 --> 00:18:38,880
and

468
00:18:38,880 --> 00:18:40,799
now it says that

469
00:18:40,799 --> 00:18:42,559
it found the byte sequence address it

470
00:18:42,559 --> 00:18:45,600
didn't printed any message and the error

471
00:18:45,600 --> 00:18:47,039
message on it

472
00:18:47,039 --> 00:18:50,880
uh but it said tie with with offset 44.

473
00:18:50,880 --> 00:18:53,360
so okay let's try to change

474
00:18:53,360 --> 00:18:55,919
uh our code

475
00:18:55,919 --> 00:18:58,080
all the other functions that all the

476
00:18:58,080 --> 00:19:00,240
other windows versions that we couldn't

477
00:19:00,240 --> 00:19:02,480
locate our function on

478
00:19:02,480 --> 00:19:05,760
and see what happens

479
00:19:05,760 --> 00:19:06,559
so

480
00:19:06,559 --> 00:19:08,960
these were our first results and this

481
00:19:08,960 --> 00:19:11,760
time we got these results

482
00:19:11,760 --> 00:19:12,880
so

483
00:19:12,880 --> 00:19:14,640
as you as you see

484
00:19:14,640 --> 00:19:16,559
we uh found our

485
00:19:16,559 --> 00:19:19,200
our target function on two other uh

486
00:19:19,200 --> 00:19:22,640
windows versions so that's a progress

487
00:19:22,640 --> 00:19:25,280
but we still have those three windows

488
00:19:25,280 --> 00:19:28,080
versions that it didn't worked on so

489
00:19:28,080 --> 00:19:30,160
again let's try to want to escape and

490
00:19:30,160 --> 00:19:31,520
see what went

491
00:19:31,520 --> 00:19:33,120
wrong

492
00:19:33,120 --> 00:19:35,200
and this time we see that it couldn't

493
00:19:35,200 --> 00:19:37,039
find the buy sequence

494
00:19:37,039 --> 00:19:39,919
so we again have to look for another

495
00:19:39,919 --> 00:19:41,760
unique by sequence

496
00:19:41,760 --> 00:19:43,679
and

497
00:19:43,679 --> 00:19:45,039
and then

498
00:19:45,039 --> 00:19:48,400
try to run our script again

499
00:19:48,400 --> 00:19:49,760
and this time

500
00:19:49,760 --> 00:19:51,679
we already found all of our windows

501
00:19:51,679 --> 00:19:53,120
versions

502
00:19:53,120 --> 00:19:54,240
so

503
00:19:54,240 --> 00:19:56,960
we can sum this uh

504
00:19:56,960 --> 00:19:58,559
a method

505
00:19:58,559 --> 00:20:00,880
up with uh

506
00:20:00,880 --> 00:20:03,440
we that we have three uh different

507
00:20:03,440 --> 00:20:05,919
combinations

508
00:20:05,919 --> 00:20:08,799
for in order to locate our target

509
00:20:08,799 --> 00:20:10,559
functions

510
00:20:10,559 --> 00:20:12,720
on our target function on all these

511
00:20:12,720 --> 00:20:15,600
windows versions

512
00:20:16,640 --> 00:20:20,000
so the pros for this method would be

513
00:20:20,000 --> 00:20:21,360
that

514
00:20:21,360 --> 00:20:22,400
it is

515
00:20:22,400 --> 00:20:25,280
the closer that we get to our function

516
00:20:25,280 --> 00:20:26,559
uh the

517
00:20:26,559 --> 00:20:30,399
more likely the offset

518
00:20:30,559 --> 00:20:32,480
the less likely that the offset would

519
00:20:32,480 --> 00:20:34,400
change

520
00:20:34,400 --> 00:20:35,840
but

521
00:20:35,840 --> 00:20:37,200
what if we

522
00:20:37,200 --> 00:20:39,760
have no byte sequence no unique byte

523
00:20:39,760 --> 00:20:43,840
sequence inside this function uh

524
00:20:43,840 --> 00:20:46,000
the other addresses

525
00:20:46,000 --> 00:20:48,720
or boundaries

526
00:20:48,720 --> 00:20:51,280
and this leads me to the next

527
00:20:51,280 --> 00:20:52,960
method that we have to locate this

528
00:20:52,960 --> 00:20:54,480
function

529
00:20:54,480 --> 00:20:55,440
so

530
00:20:55,440 --> 00:20:57,679
we can still locate a unique byte

531
00:20:57,679 --> 00:20:58,880
sequence

532
00:20:58,880 --> 00:20:59,760
but

533
00:20:59,760 --> 00:21:01,200
we can try to locate the unique by

534
00:21:01,200 --> 00:21:04,480
sequence of the function call

535
00:21:05,039 --> 00:21:06,240
so this is

536
00:21:06,240 --> 00:21:08,559
the the function that calls our target

537
00:21:08,559 --> 00:21:10,000
function

538
00:21:10,000 --> 00:21:12,480
and this is the call instruction that

539
00:21:12,480 --> 00:21:15,760
calls our target function

540
00:21:15,760 --> 00:21:17,760
this instruction consists of two parts

541
00:21:17,760 --> 00:21:19,120
there is the call instruction

542
00:21:19,120 --> 00:21:22,400
represented by e8 and it followed by an

543
00:21:22,400 --> 00:21:23,440
offset

544
00:21:23,440 --> 00:21:27,280
to the start address of our function

545
00:21:27,280 --> 00:21:29,600
which is a relative to the end of this

546
00:21:29,600 --> 00:21:32,320
call instruction

547
00:21:33,280 --> 00:21:34,480
but

548
00:21:34,480 --> 00:21:36,400
okay why not search for the byte

549
00:21:36,400 --> 00:21:40,320
sequence of the call instruction

550
00:21:40,400 --> 00:21:42,559
actually i can assure you this byte

551
00:21:42,559 --> 00:21:44,480
sequence is probably

552
00:21:44,480 --> 00:21:47,919
really not unique it is probably

553
00:21:47,919 --> 00:21:50,080
widely used and we need some to find

554
00:21:50,080 --> 00:21:51,120
something

555
00:21:51,120 --> 00:21:54,159
which we can assure it is a unique byte

556
00:21:54,159 --> 00:21:57,120
sequence remember

557
00:21:57,360 --> 00:22:00,640
but we can take a look at these commands

558
00:22:00,640 --> 00:22:03,120
these instructions prior to this

559
00:22:03,120 --> 00:22:04,559
call

560
00:22:04,559 --> 00:22:06,400
and

561
00:22:06,400 --> 00:22:08,000
actually this is

562
00:22:08,000 --> 00:22:09,360
the

563
00:22:09,360 --> 00:22:10,840
parameters

564
00:22:10,840 --> 00:22:13,280
preparation before the

565
00:22:13,280 --> 00:22:14,400
call

566
00:22:14,400 --> 00:22:17,919
that it passes to our function

567
00:22:17,919 --> 00:22:19,280
so

568
00:22:19,280 --> 00:22:20,080
if

569
00:22:20,080 --> 00:22:22,720
there by sequence is unique we can try

570
00:22:22,720 --> 00:22:24,559
and look for this one

571
00:22:24,559 --> 00:22:27,600
for this address

572
00:22:27,600 --> 00:22:30,640
then adding to it the uh by sequence

573
00:22:30,640 --> 00:22:32,400
plan

574
00:22:32,400 --> 00:22:34,559
and eventually take the relative offset

575
00:22:34,559 --> 00:22:36,880
from there and find our way to our

576
00:22:36,880 --> 00:22:38,960
target function

577
00:22:38,960 --> 00:22:39,760
so

578
00:22:39,760 --> 00:22:42,880
our formula in this case would be we'll

579
00:22:42,880 --> 00:22:44,480
still have to locate the by sequence

580
00:22:44,480 --> 00:22:47,360
address we'll still have to

581
00:22:47,360 --> 00:22:50,080
add an offset now

582
00:22:50,080 --> 00:22:53,520
a the byte sequence length in this case

583
00:22:53,520 --> 00:22:55,600
and now we also have a new offset that

584
00:22:55,600 --> 00:22:57,919
we just found that we have to add to our

585
00:22:57,919 --> 00:22:59,600
formula

586
00:22:59,600 --> 00:23:01,600
so let's say that the by sequence

587
00:23:01,600 --> 00:23:04,000
address in this case would be

588
00:23:04,000 --> 00:23:05,520
this address

589
00:23:05,520 --> 00:23:07,200
then we will add

590
00:23:07,200 --> 00:23:09,039
to it to the byte sequence length which

591
00:23:09,039 --> 00:23:11,200
is 11 in this case

592
00:23:11,200 --> 00:23:12,559
but

593
00:23:12,559 --> 00:23:15,840
we also have to add the offset length

594
00:23:15,840 --> 00:23:19,280
because we said that the offset is uh

595
00:23:19,280 --> 00:23:20,960
relative to the end of the score

596
00:23:20,960 --> 00:23:23,679
instruction

597
00:23:23,679 --> 00:23:26,000
then we'll add to it

598
00:23:26,000 --> 00:23:28,320
this offset that we just found

599
00:23:28,320 --> 00:23:31,280
and eventually we'll get this address

600
00:23:31,280 --> 00:23:32,799
which is uh

601
00:23:32,799 --> 00:23:34,559
our target function address and if you

602
00:23:34,559 --> 00:23:36,559
remember that's exactly the address that

603
00:23:36,559 --> 00:23:38,720
we previously saw

604
00:23:38,720 --> 00:23:40,480
so that's good we have two different

605
00:23:40,480 --> 00:23:44,000
ways to locate the same function

606
00:23:44,320 --> 00:23:46,799
now how can we automate this

607
00:23:46,799 --> 00:23:48,080
so

608
00:23:48,080 --> 00:23:50,159
it should work pretty similar to the

609
00:23:50,159 --> 00:23:52,640
first method right because we only added

610
00:23:52,640 --> 00:23:56,400
one tiny uh detail so we'll still look

611
00:23:56,400 --> 00:23:59,039
for the uh sequence address

612
00:23:59,039 --> 00:24:01,919
then we will have to find the a call

613
00:24:01,919 --> 00:24:04,320
address extract format the offset and

614
00:24:04,320 --> 00:24:06,159
compare it to

615
00:24:06,159 --> 00:24:07,200
our

616
00:24:07,200 --> 00:24:10,080
function address taking from the

617
00:24:10,080 --> 00:24:12,640
symbols because we're in iodine we're

618
00:24:12,640 --> 00:24:15,919
offline so that's good

619
00:24:15,919 --> 00:24:17,679
then

620
00:24:17,679 --> 00:24:20,159
all we have to do is add a tiny flag

621
00:24:20,159 --> 00:24:21,840
that will

622
00:24:21,840 --> 00:24:23,200
call the right

623
00:24:23,200 --> 00:24:25,200
search function

624
00:24:25,200 --> 00:24:27,520
so that's easy

625
00:24:27,520 --> 00:24:30,480
and now we'll go to our second script

626
00:24:30,480 --> 00:24:32,559
and we will have to hold another list

627
00:24:32,559 --> 00:24:35,440
that will hold all the search data for

628
00:24:35,440 --> 00:24:38,320
the second method

629
00:24:38,320 --> 00:24:39,840
so

630
00:24:39,840 --> 00:24:41,600
this time it will look like this pretty

631
00:24:41,600 --> 00:24:44,719
similar to the first one

632
00:24:44,799 --> 00:24:48,080
and now we'll just change the output

633
00:24:48,080 --> 00:24:50,000
file uh to a different name so we can

634
00:24:50,000 --> 00:24:51,120
differenti

635
00:24:51,120 --> 00:24:55,360
differentiate between the outputs

636
00:24:55,919 --> 00:24:57,919
now i run the script and this is the

637
00:24:57,919 --> 00:24:59,679
results that we got we see that the buy

638
00:24:59,679 --> 00:25:01,440
sequence is pretty similar but it still

639
00:25:01,440 --> 00:25:03,600
has some tiny changes

640
00:25:03,600 --> 00:25:05,760
and

641
00:25:05,760 --> 00:25:07,520
this time we could

642
00:25:07,520 --> 00:25:10,240
divide it our search data into two

643
00:25:10,240 --> 00:25:12,840
groups so that's good that's more

644
00:25:12,840 --> 00:25:15,440
consistent than the first method that we

645
00:25:15,440 --> 00:25:18,559
saw that's a progress

646
00:25:19,279 --> 00:25:21,120
okay so

647
00:25:21,120 --> 00:25:22,559
what are the pros

648
00:25:22,559 --> 00:25:24,000
of this method

649
00:25:24,000 --> 00:25:25,039
well

650
00:25:25,039 --> 00:25:27,760
it doesn't count on a really random byte

651
00:25:27,760 --> 00:25:30,480
to count on the function signature which

652
00:25:30,480 --> 00:25:31,360
is

653
00:25:31,360 --> 00:25:34,320
less likely to change of course that

654
00:25:34,320 --> 00:25:38,080
nothing is uh sure

655
00:25:38,320 --> 00:25:40,960
but again what if the byte sequence

656
00:25:40,960 --> 00:25:42,720
address

657
00:25:42,720 --> 00:25:45,120
of this

658
00:25:45,120 --> 00:25:47,200
parameter preparation

659
00:25:47,200 --> 00:25:49,360
is not unique

660
00:25:49,360 --> 00:25:52,159
so i kind of get tired of

661
00:25:52,159 --> 00:25:53,520
relying on

662
00:25:53,520 --> 00:25:56,240
bisequences address and uniqueness and

663
00:25:56,240 --> 00:25:59,840
so i try to look for another method

664
00:25:59,840 --> 00:26:02,240
and this leads me to

665
00:26:02,240 --> 00:26:04,799
our third and last method which is to

666
00:26:04,799 --> 00:26:08,080
locate an indirect function call

667
00:26:08,080 --> 00:26:10,080
a using uh

668
00:26:10,080 --> 00:26:12,640
its exported function and

669
00:26:12,640 --> 00:26:14,559
going down the call chain

670
00:26:14,559 --> 00:26:15,440
uh

671
00:26:15,440 --> 00:26:18,320
and then once we get our

672
00:26:18,320 --> 00:26:19,440
uh

673
00:26:19,440 --> 00:26:21,360
function offset from the call

674
00:26:21,360 --> 00:26:23,679
instruction just like we saw in our

675
00:26:23,679 --> 00:26:26,480
second method we will be able to reach

676
00:26:26,480 --> 00:26:29,600
our function atlas

677
00:26:30,320 --> 00:26:32,799
so again this is the function called our

678
00:26:32,799 --> 00:26:34,960
target function

679
00:26:34,960 --> 00:26:36,559
and if

680
00:26:36,559 --> 00:26:38,240
by now we focused on the byte

681
00:26:38,240 --> 00:26:40,799
representation now i want us to focus on

682
00:26:40,799 --> 00:26:44,000
the actual instructions

683
00:26:44,000 --> 00:26:45,840
but before that let's zoom out for a

684
00:26:45,840 --> 00:26:47,039
second

685
00:26:47,039 --> 00:26:50,080
we have our target function

686
00:26:50,080 --> 00:26:52,720
and the function calls it but what if

687
00:26:52,720 --> 00:26:55,039
the function of close it is not exported

688
00:26:55,039 --> 00:26:57,600
so there might be there has to be

689
00:26:57,600 --> 00:26:59,600
another function who calls it and

690
00:26:59,600 --> 00:27:01,760
another function calls it and so on and

691
00:27:01,760 --> 00:27:04,400
so on until we reach our exported

692
00:27:04,400 --> 00:27:06,640
function which in this case would be

693
00:27:06,640 --> 00:27:09,760
elialo diana

694
00:27:09,919 --> 00:27:12,559
and of course let's not forget that the

695
00:27:12,559 --> 00:27:15,360
function equals our target function also

696
00:27:15,360 --> 00:27:17,919
might call other functions

697
00:27:17,919 --> 00:27:21,039
and back to our code now i want us to

698
00:27:21,039 --> 00:27:22,960
take a look not only on

699
00:27:22,960 --> 00:27:25,679
part of our function code but i want us

700
00:27:25,679 --> 00:27:27,440
to take a look at the entire function

701
00:27:27,440 --> 00:27:28,480
code

702
00:27:28,480 --> 00:27:30,559
and actually i want us to focus on the

703
00:27:30,559 --> 00:27:32,960
whole instructions inside of it

704
00:27:32,960 --> 00:27:35,600
did you spotted our target function

705
00:27:35,600 --> 00:27:36,480
well

706
00:27:36,480 --> 00:27:38,960
it's this second call

707
00:27:38,960 --> 00:27:41,520
so if we'll step into the second call of

708
00:27:41,520 --> 00:27:43,600
this target of the function who calls

709
00:27:43,600 --> 00:27:45,760
our target function we can activate the

710
00:27:45,760 --> 00:27:46,799
offset

711
00:27:46,799 --> 00:27:48,960
just like we did on the previous method

712
00:27:48,960 --> 00:27:50,480
again

713
00:27:50,480 --> 00:27:51,600
and

714
00:27:51,600 --> 00:27:55,120
find our target function

715
00:27:55,440 --> 00:27:56,240
but

716
00:27:56,240 --> 00:27:58,240
remember this picture

717
00:27:58,240 --> 00:28:00,559
well we found a way to locate our target

718
00:28:00,559 --> 00:28:01,600
function

719
00:28:01,600 --> 00:28:02,399
but

720
00:28:02,399 --> 00:28:04,480
what about the function who calls it and

721
00:28:04,480 --> 00:28:05,679
what about the function of cause the

722
00:28:05,679 --> 00:28:07,120
function of causes

723
00:28:07,120 --> 00:28:10,559
and so on and so on

724
00:28:10,960 --> 00:28:12,880
so let's take a look

725
00:28:12,880 --> 00:28:14,799
the answer is exactly the same by the

726
00:28:14,799 --> 00:28:17,279
way

727
00:28:17,279 --> 00:28:20,159
let's take a look uh on the calls flow

728
00:28:20,159 --> 00:28:22,080
at the call flow

729
00:28:22,080 --> 00:28:24,480
and this is our exported function this

730
00:28:24,480 --> 00:28:26,720
is the ldl or dll function just like we

731
00:28:26,720 --> 00:28:29,279
saw on the picture

732
00:28:29,279 --> 00:28:31,120
if we'll step into the second call

733
00:28:31,120 --> 00:28:33,120
instruction inside of it we'll get to

734
00:28:33,120 --> 00:28:34,880
this internal function

735
00:28:34,880 --> 00:28:37,679
then we'll step into the third call then

736
00:28:37,679 --> 00:28:39,760
we step into another call and another

737
00:28:39,760 --> 00:28:43,200
call and this one also should uh

738
00:28:43,200 --> 00:28:45,279
probably already look familiar because

739
00:28:45,279 --> 00:28:47,360
this is the target to calls

740
00:28:47,360 --> 00:28:48,799
uh the function calls our target

741
00:28:48,799 --> 00:28:50,480
function

742
00:28:50,480 --> 00:28:52,799
so if we'll go down this call chain

743
00:28:52,799 --> 00:28:55,760
we'll have a way to locate our function

744
00:28:55,760 --> 00:28:57,360
without uh

745
00:28:57,360 --> 00:28:59,840
using any by sequences by sequence

746
00:28:59,840 --> 00:29:02,080
addresses

747
00:29:02,080 --> 00:29:03,840
once we've found the function address we

748
00:29:03,840 --> 00:29:05,679
can call it from we can simply call it

749
00:29:05,679 --> 00:29:09,679
from our memory a formal code

750
00:29:10,640 --> 00:29:12,799
so now let's take a look how we can

751
00:29:12,799 --> 00:29:15,279
automate it this one is a bit different

752
00:29:15,279 --> 00:29:17,279
than the first two methods so we can

753
00:29:17,279 --> 00:29:19,039
write another script or add another

754
00:29:19,039 --> 00:29:21,600
function or whatever works for you

755
00:29:21,600 --> 00:29:22,880
and

756
00:29:22,880 --> 00:29:25,520
now we have to get all the code

757
00:29:25,520 --> 00:29:27,039
call the call instruction inside the

758
00:29:27,039 --> 00:29:28,080
memory

759
00:29:28,080 --> 00:29:29,760
and try to find

760
00:29:29,760 --> 00:29:32,159
the function sorry try to find the

761
00:29:32,159 --> 00:29:34,720
function and get its

762
00:29:34,720 --> 00:29:37,120
index

763
00:29:37,840 --> 00:29:38,640
then

764
00:29:38,640 --> 00:29:41,360
we said that we have to look for it uh

765
00:29:41,360 --> 00:29:44,000
for the entire change so we'll have to

766
00:29:44,000 --> 00:29:45,200
hold the list

767
00:29:45,200 --> 00:29:47,039
of uh

768
00:29:47,039 --> 00:29:50,000
every caller and colleague uh

769
00:29:50,000 --> 00:29:53,360
couples uh of this uh whole chain

770
00:29:53,360 --> 00:29:57,200
so we will be able to uh

771
00:29:57,200 --> 00:29:58,960
to calculate

772
00:29:58,960 --> 00:30:03,440
the all the uh all these process

773
00:30:04,640 --> 00:30:07,200
then we will just iterate it and execute

774
00:30:07,200 --> 00:30:10,399
of course the same function

775
00:30:10,960 --> 00:30:13,200
if we print the result to the python

776
00:30:13,200 --> 00:30:14,880
interpreter this is the result that we

777
00:30:14,880 --> 00:30:17,120
get

778
00:30:17,360 --> 00:30:19,679
but now let's see how it

779
00:30:19,679 --> 00:30:21,840
how this method work compares to other

780
00:30:21,840 --> 00:30:24,559
windows version

781
00:30:24,559 --> 00:30:26,000
so

782
00:30:26,000 --> 00:30:27,120
now

783
00:30:27,120 --> 00:30:29,440
we will go back to our second script the

784
00:30:29,440 --> 00:30:32,000
one that runs on multiple dls

785
00:30:32,000 --> 00:30:32,960
and

786
00:30:32,960 --> 00:30:37,039
we will take care of the e output file

787
00:30:37,039 --> 00:30:39,360
and

788
00:30:39,440 --> 00:30:42,720
save no sorry this is uh sorry this is

789
00:30:42,720 --> 00:30:44,799
the first script and we need to adjust

790
00:30:44,799 --> 00:30:46,159
it to write

791
00:30:46,159 --> 00:30:50,760
the output to a csv file

792
00:30:52,159 --> 00:30:54,240
um

793
00:30:54,240 --> 00:30:56,799
then we will iterate uh only the dls we

794
00:30:56,799 --> 00:30:59,600
don't have extra data in this case

795
00:30:59,600 --> 00:31:01,360
and this is the output that will get

796
00:31:01,360 --> 00:31:03,760
after running it on all the windows

797
00:31:03,760 --> 00:31:05,919
versions

798
00:31:05,919 --> 00:31:08,399
so we see that the first couple

799
00:31:08,399 --> 00:31:10,799
is pretty stable it's almost uh always

800
00:31:10,799 --> 00:31:12,000
the second

801
00:31:12,000 --> 00:31:14,320
function call

802
00:31:14,320 --> 00:31:16,840
the second couple and the third couple

803
00:31:16,840 --> 00:31:21,200
also very stable seems to be like

804
00:31:21,200 --> 00:31:23,279
they seem to uh

805
00:31:23,279 --> 00:31:25,600
not change at all

806
00:31:25,600 --> 00:31:26,960
um

807
00:31:26,960 --> 00:31:30,720
the first the fourth one again

808
00:31:30,720 --> 00:31:32,960
and uh our

809
00:31:32,960 --> 00:31:33,919
uh

810
00:31:33,919 --> 00:31:36,080
caller function that calls our target

811
00:31:36,080 --> 00:31:39,039
function also very stable and it's also

812
00:31:39,039 --> 00:31:41,679
always the second function that's being

813
00:31:41,679 --> 00:31:42,960
called

814
00:31:42,960 --> 00:31:47,039
but the problem starts here in this line

815
00:31:47,039 --> 00:31:49,279
we can see that this function is very

816
00:31:49,279 --> 00:31:50,880
inconsistent

817
00:31:50,880 --> 00:31:51,600
it's

818
00:31:51,600 --> 00:31:52,960
also the

819
00:31:52,960 --> 00:31:56,880
both the function a index is changed

820
00:31:56,880 --> 00:31:58,399
and also

821
00:31:58,399 --> 00:32:00,640
the amount of the call instruction

822
00:32:00,640 --> 00:32:02,480
inside of this function

823
00:32:02,480 --> 00:32:04,240
are also often changed

824
00:32:04,240 --> 00:32:05,279
so

825
00:32:05,279 --> 00:32:08,960
it probably means that this function is

826
00:32:08,960 --> 00:32:12,240
changes openly and we don't really want

827
00:32:12,240 --> 00:32:13,679
to count on it

828
00:32:13,679 --> 00:32:16,480
so if we'll take a closer look and we'll

829
00:32:16,480 --> 00:32:18,720
try to sum it up

830
00:32:18,720 --> 00:32:20,240
if we would

831
00:32:20,240 --> 00:32:23,840
look for any one of these first four

832
00:32:23,840 --> 00:32:25,519
internal functions

833
00:32:25,519 --> 00:32:27,679
we could successfully use this method to

834
00:32:27,679 --> 00:32:29,679
locate them

835
00:32:29,679 --> 00:32:30,559
but

836
00:32:30,559 --> 00:32:32,000
starting

837
00:32:32,000 --> 00:32:33,919
from

838
00:32:33,919 --> 00:32:36,559
this function that's starting to

839
00:32:36,559 --> 00:32:38,159
make some troubles

840
00:32:38,159 --> 00:32:40,240
we can really rely on it

841
00:32:40,240 --> 00:32:42,559
so let's uh

842
00:32:42,559 --> 00:32:43,919
sum this

843
00:32:43,919 --> 00:32:46,320
method

844
00:32:46,720 --> 00:32:48,080
uh

845
00:32:48,080 --> 00:32:48,960
well

846
00:32:48,960 --> 00:32:52,559
it doesn't rely on rely on any

847
00:32:52,559 --> 00:32:54,840
byte sequence

848
00:32:54,840 --> 00:33:00,559
address no uniqueness no random good

849
00:33:00,559 --> 00:33:01,600
but

850
00:33:01,600 --> 00:33:03,919
we have to remember that the first we go

851
00:33:03,919 --> 00:33:06,320
down the call chain uh

852
00:33:06,320 --> 00:33:07,279
the

853
00:33:07,279 --> 00:33:09,440
chances that we

854
00:33:09,440 --> 00:33:10,880
won't be able

855
00:33:10,880 --> 00:33:12,000
to

856
00:33:12,000 --> 00:33:14,559
find our function or that it would be

857
00:33:14,559 --> 00:33:16,080
stable

858
00:33:16,080 --> 00:33:18,860
decreases so

859
00:33:18,860 --> 00:33:21,440
[Music]

860
00:33:21,440 --> 00:33:23,440
it is better for us to use this method

861
00:33:23,440 --> 00:33:25,600
to locate

862
00:33:25,600 --> 00:33:28,159
functions that are closer to the export

863
00:33:28,159 --> 00:33:29,200
function

864
00:33:29,200 --> 00:33:31,279
also it relies on other functions that

865
00:33:31,279 --> 00:33:33,519
don't really relate to us so

866
00:33:33,519 --> 00:33:34,960
just also

867
00:33:34,960 --> 00:33:38,360
not so good

868
00:33:39,039 --> 00:33:41,519
and now let's talk about the stability

869
00:33:41,519 --> 00:33:45,440
between all these uh versions

870
00:33:45,440 --> 00:33:48,000
we add the buy sequence address that and

871
00:33:48,000 --> 00:33:50,240
calculate from it the opt to the start

872
00:33:50,240 --> 00:33:51,919
function

873
00:33:51,919 --> 00:33:54,480
we saw that it has three combinations

874
00:33:54,480 --> 00:33:57,600
but we had better options using two so

875
00:33:57,600 --> 00:34:00,080
we had better options

876
00:34:00,080 --> 00:34:00,960
uh

877
00:34:00,960 --> 00:34:03,200
the direct function call using

878
00:34:03,200 --> 00:34:05,279
locating the a

879
00:34:05,279 --> 00:34:08,480
bit sequence address of the parameters

880
00:34:08,480 --> 00:34:10,000
preparation

881
00:34:10,000 --> 00:34:12,879
went really great we had only two

882
00:34:12,879 --> 00:34:15,199
search data tuples

883
00:34:15,199 --> 00:34:16,800
and

884
00:34:16,800 --> 00:34:20,320
eventually we also saw that the last

885
00:34:20,320 --> 00:34:22,399
method of uh

886
00:34:22,399 --> 00:34:24,399
going down the uh

887
00:34:24,399 --> 00:34:26,320
function uh code chain

888
00:34:26,320 --> 00:34:29,440
could also be successful but

889
00:34:29,440 --> 00:34:34,239
we prefer uh we can't really rely on it

890
00:34:34,239 --> 00:34:36,480
so

891
00:34:36,480 --> 00:34:38,480
we have three different ways to locate

892
00:34:38,480 --> 00:34:39,918
this function

893
00:34:39,918 --> 00:34:41,040
and

894
00:34:41,040 --> 00:34:44,000
for our target function the the best way

895
00:34:44,000 --> 00:34:46,800
to locate it as we saw according to the

896
00:34:46,800 --> 00:34:48,800
result that we just

897
00:34:48,800 --> 00:34:49,839
got

898
00:34:49,839 --> 00:34:52,000
the best way to locate it is the direct

899
00:34:52,000 --> 00:34:54,079
function call

900
00:34:54,079 --> 00:34:57,200
but it is very important to say

901
00:34:57,200 --> 00:34:58,000
that

902
00:34:58,000 --> 00:35:01,119
there is no right or wrong method here

903
00:35:01,119 --> 00:35:03,760
because as you can see it can really

904
00:35:03,760 --> 00:35:05,839
change between different functions and

905
00:35:05,839 --> 00:35:08,400
it very depends on

906
00:35:08,400 --> 00:35:09,920
what is the target function that you are

907
00:35:09,920 --> 00:35:11,520
looking for

908
00:35:11,520 --> 00:35:14,560
so my conclusion is

909
00:35:14,560 --> 00:35:17,839
i use the automation to for every target

910
00:35:17,839 --> 00:35:19,839
function you're looking for

911
00:35:19,839 --> 00:35:22,560
in order to find the best way that suits

912
00:35:22,560 --> 00:35:25,119
your needs

913
00:35:26,400 --> 00:35:28,480
now we have not one but three different

914
00:35:28,480 --> 00:35:32,640
ways to locate unexported functions

915
00:35:34,960 --> 00:35:36,400
again

916
00:35:36,400 --> 00:35:38,880
use the python scripts to

917
00:35:38,880 --> 00:35:42,720
find what's better works for you

918
00:35:42,800 --> 00:35:45,200
oh and that's a great question waldo

919
00:35:45,200 --> 00:35:47,119
well of course you can try it at home if

920
00:35:47,119 --> 00:35:51,760
you wish to try and learn more about it

921
00:35:51,760 --> 00:35:55,119
you can use any one of these resources

922
00:35:55,119 --> 00:35:58,480
which is a very good point to start with

923
00:35:58,480 --> 00:36:00,160
and

924
00:36:00,160 --> 00:36:02,960
i will also try to

925
00:36:02,960 --> 00:36:04,880
i will also post this

926
00:36:04,880 --> 00:36:07,680
resources link to twitter account

927
00:36:07,680 --> 00:36:09,760
to my twitter account we'll have a

928
00:36:09,760 --> 00:36:11,440
twitter thread if you have any

929
00:36:11,440 --> 00:36:13,599
additional resources feel free to share

930
00:36:13,599 --> 00:36:15,839
them

931
00:36:16,960 --> 00:36:19,280
and of course the github repository with

932
00:36:19,280 --> 00:36:21,440
all the scripts that we saw today will

933
00:36:21,440 --> 00:36:22,160
be

934
00:36:22,160 --> 00:36:24,000
uploaded

935
00:36:24,000 --> 00:36:27,359
later on today i also will be posted on

936
00:36:27,359 --> 00:36:29,839
twitter that's my twitter and they'll

937
00:36:29,839 --> 00:36:32,000
uh we don't have really time for

938
00:36:32,000 --> 00:36:34,320
questions due to time constraints but

939
00:36:34,320 --> 00:36:36,960
for any uh questions feel free to

940
00:36:36,960 --> 00:36:40,560
contact me either on twitter or now or

941
00:36:40,560 --> 00:36:42,800
whenever you feel like

942
00:36:42,800 --> 00:36:43,920
and

943
00:36:43,920 --> 00:36:47,010
that's it thank you

944
00:36:47,010 --> 00:36:55,610
[Music]

945
00:36:55,610 --> 00:36:57,760
[Applause]

946
00:36:57,760 --> 00:36:59,839
you

