1
00:00:01,490 --> 00:00:04,620
okay welcome everybody to the Gold Room

2
00:00:04,620 --> 00:00:06,930
we are gonna start this is Robert's

3
00:00:06,930 --> 00:00:09,719
Accord Java serialization the serial

4
00:00:09,719 --> 00:00:19,910
killer without further ado thanks so

5
00:00:19,910 --> 00:00:22,800
that's that's me and my fully evolved

6
00:00:22,800 --> 00:00:27,180
form for those of you who watch anime I

7
00:00:27,180 --> 00:00:30,260
guess I'm a technical director NTC group

8
00:00:30,260 --> 00:00:34,680
I spend my time sort of split between

9
00:00:34,680 --> 00:00:37,020
three activities one of those activities

10
00:00:37,020 --> 00:00:39,300
is developing delivering secure coding

11
00:00:39,300 --> 00:00:41,969
training classes in Java C C++ C sharp

12
00:00:41,969 --> 00:00:46,469
the material presenting today is sort of

13
00:00:46,469 --> 00:00:49,309
cut down from a full day I developed on

14
00:00:49,309 --> 00:00:55,469
serialization which is a you know sort

15
00:00:55,469 --> 00:00:57,000
of an interesting idea cuz now I'm

16
00:00:57,000 --> 00:00:58,320
trying to figure out who wants to listen

17
00:00:58,320 --> 00:00:59,940
to me talk about serialization for full

18
00:00:59,940 --> 00:01:03,449
day but a few people have I also do

19
00:01:03,449 --> 00:01:05,459
secure coding research which at NCC

20
00:01:05,459 --> 00:01:07,619
group mainly publishing white papers

21
00:01:07,619 --> 00:01:09,299
there's actually is a white paper on

22
00:01:09,299 --> 00:01:12,210
Java serialization on are on the NCC

23
00:01:12,210 --> 00:01:13,619
group website people like to have a look

24
00:01:13,619 --> 00:01:16,890
at that and the third thing I do is code

25
00:01:16,890 --> 00:01:20,159
security reviews so try to keep keep my

26
00:01:20,159 --> 00:01:23,610
hands in it and you know make sure I

27
00:01:23,610 --> 00:01:26,450
sort of maintain the skillset not just

28
00:01:26,450 --> 00:01:30,659
you know teach so how many of you here

29
00:01:30,659 --> 00:01:35,490
do you Java serialization okay just

30
00:01:35,490 --> 00:01:37,259
David's forboden maybe three or four of

31
00:01:37,259 --> 00:01:42,229
you how many of you are Java developers

32
00:01:42,229 --> 00:01:44,759
how many of you just like came in the

33
00:01:44,759 --> 00:01:50,460
wrong room by accident so I'll give a

34
00:01:50,460 --> 00:01:53,189
quick intro into Java serialization I I

35
00:01:53,189 --> 00:01:55,530
try to trim this down to fit the

36
00:01:55,530 --> 00:01:58,770
available time and I decided to focus on

37
00:01:58,770 --> 00:02:00,180
demos because I thought people liked

38
00:02:00,180 --> 00:02:04,979
demos so I had to kind of eliminate some

39
00:02:04,979 --> 00:02:08,340
of the overview stuff but Java C rosacea

40
00:02:08,340 --> 00:02:10,169
in general supports transformation of a

41
00:02:10,169 --> 00:02:12,120
graph of objects into a stream of bytes

42
00:02:12,120 --> 00:02:13,600
which can be stored or

43
00:02:13,600 --> 00:02:16,960
transmitted so you have objects which

44
00:02:16,960 --> 00:02:20,440
are serialized the serialized data can

45
00:02:20,440 --> 00:02:22,540
then be stored a file and a database or

46
00:02:22,540 --> 00:02:25,660
just maintain a memory and then the the

47
00:02:25,660 --> 00:02:27,820
objects can be reconstituted from the

48
00:02:27,820 --> 00:02:30,670
serialized data so of course the

49
00:02:30,670 --> 00:02:32,590
serialize form has to identify and

50
00:02:32,590 --> 00:02:34,480
verify the class information there's no

51
00:02:34,480 --> 00:02:37,030
source code that gets transmitted it's

52
00:02:37,030 --> 00:02:40,000
just information about the actual object

53
00:02:40,000 --> 00:02:42,610
so to reconstitute these objects the

54
00:02:42,610 --> 00:02:44,590
source code has to be available to the

55
00:02:44,590 --> 00:02:48,160
JVM that's you know deserializing the

56
00:02:48,160 --> 00:02:50,560
objects and so the source code will be

57
00:02:50,560 --> 00:02:53,700
loaded just as Java normally loads

58
00:02:53,700 --> 00:02:55,720
classes you know looking through the

59
00:02:55,720 --> 00:02:59,410
class path and so forth so let's say we

60
00:02:59,410 --> 00:03:02,110
have a simple class a bicycle class we

61
00:03:02,110 --> 00:03:04,450
want to see I realize it it's it's

62
00:03:04,450 --> 00:03:08,470
exceedingly simple so we create an

63
00:03:08,470 --> 00:03:10,270
output stream which in this case is a

64
00:03:10,270 --> 00:03:12,250
file output stream to receive the bytes

65
00:03:12,250 --> 00:03:14,770
so basically we're creating a file

66
00:03:14,770 --> 00:03:17,170
called temp then we create an object

67
00:03:17,170 --> 00:03:19,390
output stream to decorate the file

68
00:03:19,390 --> 00:03:22,750
output stream object and then we call

69
00:03:22,750 --> 00:03:24,430
the write method on object output stream

70
00:03:24,430 --> 00:03:26,680
we create a new instance of this object

71
00:03:26,680 --> 00:03:28,900
and call write object on it that

72
00:03:28,900 --> 00:03:30,720
serializes the object and then we just

73
00:03:30,720 --> 00:03:34,300
flush the stream to then DC realize that

74
00:03:34,300 --> 00:03:36,610
we just do the opposite process we

75
00:03:36,610 --> 00:03:38,470
create input stream which is a file

76
00:03:38,470 --> 00:03:40,960
input stream to leave read in the temp

77
00:03:40,960 --> 00:03:44,590
file and then we create a new object

78
00:03:44,590 --> 00:03:48,580
input stream object and then we call the

79
00:03:48,580 --> 00:03:50,320
read object method on object input

80
00:03:50,320 --> 00:03:52,030
stream to deserialize

81
00:03:52,030 --> 00:03:54,880
the object so read object just returns a

82
00:03:54,880 --> 00:03:56,560
generic object because it can be used to

83
00:03:56,560 --> 00:03:58,870
deserialize any type of object so

84
00:03:58,870 --> 00:04:01,870
typically what the developer does here

85
00:04:01,870 --> 00:04:05,200
is they cast the return by a read object

86
00:04:05,200 --> 00:04:07,330
to the anticipated type of the object

87
00:04:07,330 --> 00:04:08,770
that's being deserialized so in this

88
00:04:08,770 --> 00:04:10,950
particular case the developers

89
00:04:10,950 --> 00:04:16,390
anticipating a bicycle object so there

90
00:04:16,390 --> 00:04:19,329
are series of callbacks that can be used

91
00:04:19,329 --> 00:04:23,160
to customize how objects are serialized

92
00:04:23,160 --> 00:04:27,520
so I a lot of times people think

93
00:04:27,520 --> 00:04:29,379
that if these callbacks are used that

94
00:04:29,379 --> 00:04:31,180
indicates that there's a problem with

95
00:04:31,180 --> 00:04:36,930
the code but it turns out that sort of

96
00:04:36,930 --> 00:04:39,580
creating these custom methods is is

97
00:04:39,580 --> 00:04:42,270
really sort of a necessary part of

98
00:04:42,270 --> 00:04:45,060
implementing serialization securely and

99
00:04:45,060 --> 00:04:48,250
for more details on that probably come

100
00:04:48,250 --> 00:04:50,379
to the six-hour class because that gets

101
00:04:50,379 --> 00:04:53,889
gets in the weeds so there's a write

102
00:04:53,889 --> 00:04:56,409
replace method which replies provides a

103
00:04:56,409 --> 00:04:58,300
replacement object to serialize that's

104
00:04:58,300 --> 00:05:02,650
basically for use with proxy objects the

105
00:05:02,650 --> 00:05:04,509
right object method gives full control

106
00:05:04,509 --> 00:05:07,900
over writing the stream so if when if

107
00:05:07,900 --> 00:05:09,870
you implement right object you can

108
00:05:09,870 --> 00:05:12,009
either accept sort of the default

109
00:05:12,009 --> 00:05:14,530
serialize form or you can decide I want

110
00:05:14,530 --> 00:05:17,050
to only see realize these fields or you

111
00:05:17,050 --> 00:05:18,610
could decide that you want to write

112
00:05:18,610 --> 00:05:20,080
information that has nothing at all to

113
00:05:20,080 --> 00:05:21,340
do with the object that you're

114
00:05:21,340 --> 00:05:23,610
serializing you have complete control

115
00:05:23,610 --> 00:05:26,650
during the serialization of course you

116
00:05:26,650 --> 00:05:28,719
need to implement a read object method

117
00:05:28,719 --> 00:05:30,400
that corresponds to your write object

118
00:05:30,400 --> 00:05:32,889
method so you actually read in the data

119
00:05:32,889 --> 00:05:35,979
that was written out and the read

120
00:05:35,979 --> 00:05:37,659
resolve is called T replace a

121
00:05:37,659 --> 00:05:39,340
deserialized object with another one

122
00:05:39,340 --> 00:05:42,969
again basically to take a proxy object

123
00:05:42,969 --> 00:05:46,000
and use that proxy object to create the

124
00:05:46,000 --> 00:05:47,800
actual object that you're you're trying

125
00:05:47,800 --> 00:05:51,180
to serialize and deserialize

126
00:05:51,180 --> 00:05:53,469
and then finally there's a valid object

127
00:05:53,469 --> 00:05:57,849
method that's called after after the

128
00:05:57,849 --> 00:06:01,300
objects have been created and also after

129
00:06:01,300 --> 00:06:03,819
it's sort of too late to ensure the

130
00:06:03,819 --> 00:06:08,590
security of the transaction so during

131
00:06:08,590 --> 00:06:10,630
serialization the write replace methods

132
00:06:10,630 --> 00:06:14,050
execute it first and then if it's

133
00:06:14,050 --> 00:06:15,460
present the right object method will

134
00:06:15,460 --> 00:06:17,560
operate on the replacement object not on

135
00:06:17,560 --> 00:06:19,599
the original object during d

136
00:06:19,599 --> 00:06:22,500
serialization read object is called

137
00:06:22,500 --> 00:06:25,000
potentially to work on a proxy object if

138
00:06:25,000 --> 00:06:26,440
it is a proxy object then there'll be a

139
00:06:26,440 --> 00:06:29,319
read resolve method invoked and then

140
00:06:29,319 --> 00:06:32,460
finally the call to validate the object

141
00:06:32,460 --> 00:06:34,930
so the validation methods executed on

142
00:06:34,930 --> 00:06:36,789
the replacement object not on the proxy

143
00:06:36,789 --> 00:06:40,210
object that silently discarded so if you

144
00:06:40,210 --> 00:06:41,200
look at

145
00:06:41,200 --> 00:06:44,200
a UML sequence diagram here you see we

146
00:06:44,200 --> 00:06:46,450
have the application code and it's it's

147
00:06:46,450 --> 00:06:48,370
implementing those four lines of code I

148
00:06:48,370 --> 00:06:51,700
showed earlier to you know just read the

149
00:06:51,700 --> 00:06:54,420
bytes from the file or any stream

150
00:06:54,420 --> 00:06:57,430
initialize the object input stream then

151
00:06:57,430 --> 00:06:59,770
read the object from the stream with the

152
00:06:59,770 --> 00:07:03,580
read object method call that transfers

153
00:07:03,580 --> 00:07:06,780
control to the object input stream which

154
00:07:06,780 --> 00:07:08,950
resolves the classes the stream using

155
00:07:08,950 --> 00:07:10,840
resolve class so that's just the normal

156
00:07:10,840 --> 00:07:14,080
process of looking up the definition of

157
00:07:14,080 --> 00:07:16,330
the class corresponding to the object

158
00:07:16,330 --> 00:07:19,090
that's being deserialized and you know

159
00:07:19,090 --> 00:07:20,620
that could already be loaded into memory

160
00:07:20,620 --> 00:07:23,140
or it can be loaded by you know looking

161
00:07:23,140 --> 00:07:26,020
at the bootstrap loader and looking at

162
00:07:26,020 --> 00:07:28,270
the class path and just the normal

163
00:07:28,270 --> 00:07:31,120
process by which classes are loaded so

164
00:07:31,120 --> 00:07:32,800
then we go to deserialize the objects

165
00:07:32,800 --> 00:07:36,190
and you know there can be any number of

166
00:07:36,190 --> 00:07:38,230
objects in the serialization stream even

167
00:07:38,230 --> 00:07:40,240
even serializing a single object

168
00:07:40,240 --> 00:07:41,950
typically that object references other

169
00:07:41,950 --> 00:07:43,570
objects so in order to serialize a

170
00:07:43,570 --> 00:07:46,360
single object that typically serializes

171
00:07:46,360 --> 00:07:49,480
a entire graph of objects and also you

172
00:07:49,480 --> 00:07:51,120
could have multiple objects in a single

173
00:07:51,120 --> 00:07:55,870
stream so for each object discovered in

174
00:07:55,870 --> 00:07:58,360
the stream object input stream is going

175
00:07:58,360 --> 00:08:01,060
to call the read object read resolve and

176
00:08:01,060 --> 00:08:03,190
validate object methods if they're if

177
00:08:03,190 --> 00:08:04,800
they've been implemented if not they'll

178
00:08:04,800 --> 00:08:08,260
call basically default versions of

179
00:08:08,260 --> 00:08:11,470
default version of read object so it

180
00:08:11,470 --> 00:08:13,120
finally returns control to the

181
00:08:13,120 --> 00:08:15,580
application code which again a cast the

182
00:08:15,580 --> 00:08:17,290
deserialize object to the expected type

183
00:08:17,290 --> 00:08:18,970
in the previous example that was a

184
00:08:18,970 --> 00:08:21,370
bicycle and then goes and uses

185
00:08:21,370 --> 00:08:24,220
deserialized object and eventually these

186
00:08:24,220 --> 00:08:26,260
objects are finalized which people

187
00:08:26,260 --> 00:08:29,200
forget about and a lot of Java

188
00:08:29,200 --> 00:08:32,200
serialization researchers don't talk

189
00:08:32,200 --> 00:08:34,539
about but that that finalized call might

190
00:08:34,539 --> 00:08:36,220
actually be the most dangerous thing up

191
00:08:36,220 --> 00:08:41,710
on the slide so the security issues and

192
00:08:41,710 --> 00:08:43,330
here's my here's a kind of classic

193
00:08:43,330 --> 00:08:46,150
understatement naive use of objects

194
00:08:46,150 --> 00:08:48,310
serialization may allow malicious party

195
00:08:48,310 --> 00:08:50,290
with access to the serialization byte

196
00:08:50,290 --> 00:08:53,380
stream to read private data or create

197
00:08:53,380 --> 00:08:55,340
objects within ballot or dangerous

198
00:08:55,340 --> 00:08:58,100
and and the security issue in in a

199
00:08:58,100 --> 00:09:00,530
nutshell is that this this guy down here

200
00:09:00,530 --> 00:09:02,780
who accidentally cut his hand off while

201
00:09:02,780 --> 00:09:03,860
slicing a sandwich

202
00:09:03,860 --> 00:09:05,390
he could probably implement

203
00:09:05,390 --> 00:09:06,980
serialization right it's just those

204
00:09:06,980 --> 00:09:09,020
three or four lines of code I showed you

205
00:09:09,020 --> 00:09:11,540
earlier but to get it right you have to

206
00:09:11,540 --> 00:09:14,120
be extremely knowledgeable and so this

207
00:09:14,120 --> 00:09:16,310
sort of gap here is is basically the

208
00:09:16,310 --> 00:09:17,360
security problem

209
00:09:17,360 --> 00:09:19,010
you know this ability to people to

210
00:09:19,010 --> 00:09:20,840
deploy systems that use serialization

211
00:09:20,840 --> 00:09:23,630
without kind of understanding how these

212
00:09:23,630 --> 00:09:27,890
things can be attacked so default

213
00:09:27,890 --> 00:09:29,690
serialization of object rates all the

214
00:09:29,690 --> 00:09:31,550
fields the serialization stream that

215
00:09:31,550 --> 00:09:33,740
includes private fields package private

216
00:09:33,740 --> 00:09:37,190
fields protect it public and so there's

217
00:09:37,190 --> 00:09:39,680
there's no there's really no attempt at

218
00:09:39,680 --> 00:09:42,590
all at protecting the serialized data

219
00:09:42,590 --> 00:09:44,660
right so the the first mistake you can

220
00:09:44,660 --> 00:09:47,780
make is just to serialize some sensitive

221
00:09:47,780 --> 00:09:50,720
information and make that available to

222
00:09:50,720 --> 00:09:52,490
someone who shouldn't have access to it

223
00:09:52,490 --> 00:09:55,610
because there's no protection at all you

224
00:09:55,610 --> 00:09:57,500
can look at the files and basically

225
00:09:57,500 --> 00:09:59,900
you'll see the ASCII right in the file

226
00:09:59,900 --> 00:10:02,240
and if that's inadequate there's a

227
00:10:02,240 --> 00:10:04,400
there's a specification which fully

228
00:10:04,400 --> 00:10:05,870
defines all the fields and there's some

229
00:10:05,870 --> 00:10:08,450
tools which will you know convert them

230
00:10:08,450 --> 00:10:10,840
into human readable form for you so

231
00:10:10,840 --> 00:10:14,030
there's there are no protections and and

232
00:10:14,030 --> 00:10:15,830
you can see here that the private data

233
00:10:15,830 --> 00:10:18,230
is also written out right so any private

234
00:10:18,230 --> 00:10:20,740
field you have is gonna be exposed

235
00:10:20,740 --> 00:10:26,330
malicious code can even basically access

236
00:10:26,330 --> 00:10:27,920
private fields within a serialized

237
00:10:27,920 --> 00:10:29,810
object by just serializing the object

238
00:10:29,810 --> 00:10:32,540
and then you know kind of manually going

239
00:10:32,540 --> 00:10:33,980
through the resulting byte stream to

240
00:10:33,980 --> 00:10:36,020
extract the private information that's

241
00:10:36,020 --> 00:10:38,180
yet another way sensitive information

242
00:10:38,180 --> 00:10:41,390
can get leaked out all these are covered

243
00:10:41,390 --> 00:10:44,180
by a single cwe d serialization of

244
00:10:44,180 --> 00:10:47,330
untrusted data the consequences of these

245
00:10:47,330 --> 00:10:51,260
vulnerabilities vary widely we talked

246
00:10:51,260 --> 00:10:53,420
already about leaking private fields

247
00:10:53,420 --> 00:10:56,200
it's it's able your attackers can also

248
00:10:56,200 --> 00:10:59,750
modify the objects so you know if you

249
00:10:59,750 --> 00:11:02,330
get a cookie which is a serialized data

250
00:11:02,330 --> 00:11:04,790
that's got your bank account name on it

251
00:11:04,790 --> 00:11:06,620
and you decide that there's not enough

252
00:11:06,620 --> 00:11:07,790
money in your bank account you rather

253
00:11:07,790 --> 00:11:08,160
have

254
00:11:08,160 --> 00:11:10,019
bill gates bank account you could just

255
00:11:10,019 --> 00:11:12,120
modify the object and send that modified

256
00:11:12,120 --> 00:11:15,959
object to the service these can be very

257
00:11:15,959 --> 00:11:18,540
simply exploited for denial of service

258
00:11:18,540 --> 00:11:20,940
tax and also remote code execution so

259
00:11:20,940 --> 00:11:22,230
these these problems have been around

260
00:11:22,230 --> 00:11:24,360
for a long time but in the last couple

261
00:11:24,360 --> 00:11:27,120
years they sort of blew up quite a lot

262
00:11:27,120 --> 00:11:30,899
when people you know we're able to

263
00:11:30,899 --> 00:11:33,149
figure out that serialization is using

264
00:11:33,149 --> 00:11:36,990
our my and and you know our my and C

265
00:11:36,990 --> 00:11:39,899
realizations used in WebSphere and Cisco

266
00:11:39,899 --> 00:11:43,829
products and JMS and and you know 15 or

267
00:11:43,829 --> 00:11:47,370
20 other popular you know software

268
00:11:47,370 --> 00:11:48,779
infrastructures that people regularly

269
00:11:48,779 --> 00:11:52,290
deploy so so this these vulnerabilities

270
00:11:52,290 --> 00:11:54,079
are sort of out there in spades and

271
00:11:54,079 --> 00:11:58,470
there are they're not at all difficult

272
00:11:58,470 --> 00:12:03,470
to exploit so here's a very simple

273
00:12:03,470 --> 00:12:07,110
unrealistic remote command execution

274
00:12:07,110 --> 00:12:09,000
example and when I say simple and

275
00:12:09,000 --> 00:12:11,699
unrealistic I mean you know I can

276
00:12:11,699 --> 00:12:13,709
guarantee we found this in code right

277
00:12:13,709 --> 00:12:15,990
but I have to say it's simple enough

278
00:12:15,990 --> 00:12:19,350
listing because you know it looks kind

279
00:12:19,350 --> 00:12:22,949
of dumb but so here we've got a gadget

280
00:12:22,949 --> 00:12:25,829
the serializable and it's got a private

281
00:12:25,829 --> 00:12:29,069
field here called command and it's got a

282
00:12:29,069 --> 00:12:31,380
reader so let me talk about this this

283
00:12:31,380 --> 00:12:33,540
command right so so the purpose of this

284
00:12:33,540 --> 00:12:35,370
you know the what the developer was

285
00:12:35,370 --> 00:12:38,160
thinking here was probably you know I

286
00:12:38,160 --> 00:12:41,490
want to I want to write a class that's

287
00:12:41,490 --> 00:12:43,529
gonna invoke commands in a safe way so

288
00:12:43,529 --> 00:12:45,509
gonna have command field which is a

289
00:12:45,509 --> 00:12:48,750
private field and this is this is gonna

290
00:12:48,750 --> 00:12:51,209
be set you know we're gonna have

291
00:12:51,209 --> 00:12:53,009
restricted access to this by making it

292
00:12:53,009 --> 00:12:54,480
private so we're only being set that

293
00:12:54,480 --> 00:12:57,480
through methods defined interface to

294
00:12:57,480 --> 00:12:59,550
safe secure commands that can be

295
00:12:59,550 --> 00:13:02,579
executed but what happens is we have a

296
00:13:02,579 --> 00:13:05,750
read object method which then calls

297
00:13:05,750 --> 00:13:09,240
runtime exec on the command and the

298
00:13:09,240 --> 00:13:10,800
problem of course here is that the

299
00:13:10,800 --> 00:13:12,779
attacker and attacker who can access

300
00:13:12,779 --> 00:13:15,509
this serialized data and very simply

301
00:13:15,509 --> 00:13:19,800
edit or you know modify the serialized

302
00:13:19,800 --> 00:13:21,300
form of this to put any come

303
00:13:21,300 --> 00:13:23,820
and here they want right and when this

304
00:13:23,820 --> 00:13:26,940
object gets deserialized this command is

305
00:13:26,940 --> 00:13:28,860
gonna be executed so this is a very

306
00:13:28,860 --> 00:13:31,140
simple version of this but the principle

307
00:13:31,140 --> 00:13:32,970
is largely the same right so what

308
00:13:32,970 --> 00:13:37,470
happens is the attacker can identify it

309
00:13:37,470 --> 00:13:39,450
can provide whatever objects really they

310
00:13:39,450 --> 00:13:41,790
want in the serialization stream it

311
00:13:41,790 --> 00:13:43,019
doesn't have to be the one the

312
00:13:43,019 --> 00:13:46,560
developers into expecting and then they

313
00:13:46,560 --> 00:13:49,860
can basically invoke code in these

314
00:13:49,860 --> 00:13:52,740
objects using attacker supplied data so

315
00:13:52,740 --> 00:13:58,529
it's a form of almost a form of kind of

316
00:13:58,529 --> 00:14:00,779
you know return or into programming with

317
00:14:00,779 --> 00:14:03,870
invocation of gadgets so here's a quick

318
00:14:03,870 --> 00:14:07,790
list of some of the protocols that use

319
00:14:07,790 --> 00:14:10,079
serialization so if you use any design

320
00:14:10,079 --> 00:14:13,589
you could likely be affected by these

321
00:14:13,589 --> 00:14:19,140
class of vulnerabilities okay so the

322
00:14:19,140 --> 00:14:21,029
further problem with D serialization is

323
00:14:21,029 --> 00:14:23,459
his code is susceptible to vulnerability

324
00:14:23,459 --> 00:14:25,800
even when the code really appears to be

325
00:14:25,800 --> 00:14:27,870
correct right so the the code I showed

326
00:14:27,870 --> 00:14:29,970
you before is more or less correct

327
00:14:29,970 --> 00:14:32,880
that's how keep deserialize but it is

328
00:14:32,880 --> 00:14:35,029
completely vulnerable to these exploits

329
00:14:35,029 --> 00:14:38,310
so again an attacker could provide an

330
00:14:38,310 --> 00:14:41,010
instance of an unexpected class and send

331
00:14:41,010 --> 00:14:42,899
it to a service that will then decirles

332
00:14:42,899 --> 00:14:45,390
that malicious object and and and likely

333
00:14:45,390 --> 00:14:47,040
cast it's the expected type so when the

334
00:14:47,040 --> 00:14:50,550
cast occurs you'll get a you'll get a

335
00:14:50,550 --> 00:14:52,800
cast exception right but by the time

336
00:14:52,800 --> 00:14:55,560
that exception occurs it's already too

337
00:14:55,560 --> 00:14:57,600
late because the entire exploit has

338
00:14:57,600 --> 00:15:03,540
already completed so so here's our again

339
00:15:03,540 --> 00:15:06,570
T serialization process and during this

340
00:15:06,570 --> 00:15:08,820
you know the deserialization of each

341
00:15:08,820 --> 00:15:11,430
object in the stream it's going to VOC

342
00:15:11,430 --> 00:15:14,880
these methods read object read resolve

343
00:15:14,880 --> 00:15:17,430
and validate object so basically the

344
00:15:17,430 --> 00:15:20,579
attacker you know provides a list of

345
00:15:20,579 --> 00:15:22,620
objects and for each object it's gonna

346
00:15:22,620 --> 00:15:25,440
call these methods with the data they

347
00:15:25,440 --> 00:15:27,779
supply and so what they can do is they

348
00:15:27,779 --> 00:15:33,180
can basically you know specify a program

349
00:15:33,180 --> 00:15:35,430
that's going to execute in your JVM

350
00:15:35,430 --> 00:15:37,650
driven by this data right so they can

351
00:15:37,650 --> 00:15:40,110
run any existing code and there's enough

352
00:15:40,110 --> 00:15:43,500
code there that you know it's not too

353
00:15:43,500 --> 00:15:46,980
hard to piece together you know you know

354
00:15:46,980 --> 00:15:48,500
a program that's gonna have some

355
00:15:48,500 --> 00:15:51,540
malicious impact such as calling runtime

356
00:15:51,540 --> 00:15:57,360
exec on a on a command ok so let's do a

357
00:15:57,360 --> 00:16:01,440
demonstration this demonstration uses

358
00:16:01,440 --> 00:16:03,390
the Apache Commons collection

359
00:16:03,390 --> 00:16:05,580
invoker transformer got a lot of bad

360
00:16:05,580 --> 00:16:07,140
press so I didn't use that I use a

361
00:16:07,140 --> 00:16:09,810
different gadget you know common

362
00:16:09,810 --> 00:16:11,130
solution to this problem is black

363
00:16:11,130 --> 00:16:15,570
listing gadgets that solution is I'm

364
00:16:15,570 --> 00:16:18,330
gonna use the ill-informed because there

365
00:16:18,330 --> 00:16:21,230
is not a there is not a known set of

366
00:16:21,230 --> 00:16:23,700
dangerous gadgets this is sort of an

367
00:16:23,700 --> 00:16:26,220
unknown unlimited set of dangerous

368
00:16:26,220 --> 00:16:29,340
gadgets out there so blacklisting is not

369
00:16:29,340 --> 00:16:31,830
appropriate approach I'll show you some

370
00:16:31,830 --> 00:16:36,860
code everyone excited about seeing code

371
00:16:36,860 --> 00:16:40,220
thank you

372
00:16:41,270 --> 00:16:47,550
so this is I'm gonna show you a CRO five

373
00:16:47,550 --> 00:16:50,310
let me debug this a little bit and said

374
00:16:50,310 --> 00:17:00,810
just running it so we're going to call

375
00:17:00,810 --> 00:17:03,839
basically this RC 8 RC e payload method

376
00:17:03,839 --> 00:17:06,900
I'll step into that this is going to

377
00:17:06,900 --> 00:17:09,839
create a command exploit that we're

378
00:17:09,839 --> 00:17:12,390
gonna you know this is the payload so

379
00:17:12,390 --> 00:17:13,530
our payload here's gonna be the cow

380
00:17:13,530 --> 00:17:15,000
program

381
00:17:15,000 --> 00:17:17,189
someone asked me once you know Kent can

382
00:17:17,189 --> 00:17:19,260
you also call command with parameters

383
00:17:19,260 --> 00:17:20,670
and yes you can

384
00:17:20,670 --> 00:17:23,550
that was what this was for so going

385
00:17:23,550 --> 00:17:25,709
through this quickly we're gonna create

386
00:17:25,709 --> 00:17:29,370
a constant transformer object we're

387
00:17:29,370 --> 00:17:31,230
gonna create an instantiation sperm

388
00:17:31,230 --> 00:17:36,780
object get some of the parameters create

389
00:17:36,780 --> 00:17:38,850
a chain transformer and a priority queue

390
00:17:38,850 --> 00:17:39,750
add a couple things

391
00:17:39,750 --> 00:17:43,380
q activate the attack and now we're

392
00:17:43,380 --> 00:17:46,250
going to serialize this gadget chain

393
00:17:46,250 --> 00:17:49,110
that I'm using for this exploit

394
00:17:49,110 --> 00:17:50,850
I'll step into the serialization code

395
00:17:50,850 --> 00:17:54,330
real quick this is the equivalent to

396
00:17:54,330 --> 00:17:55,740
what I showed you on the slide earlier

397
00:17:55,740 --> 00:17:57,330
we're just creating an object output

398
00:17:57,330 --> 00:17:59,490
stream and a try with resources block

399
00:17:59,490 --> 00:18:01,919
and then we called the right object

400
00:18:01,919 --> 00:18:03,929
method and here we're just converting it

401
00:18:03,929 --> 00:18:08,520
in memory to a byte array so that's the

402
00:18:08,520 --> 00:18:12,090
serialized attack and now the next thing

403
00:18:12,090 --> 00:18:13,320
we're going to do is going to take that

404
00:18:13,320 --> 00:18:14,850
serialized payload and we're going to

405
00:18:14,850 --> 00:18:16,710
deserialize it so again I'll step into

406
00:18:16,710 --> 00:18:19,890
that so again we have an object input

407
00:18:19,890 --> 00:18:21,480
stream now and a try with resources

408
00:18:21,480 --> 00:18:25,020
block and this this read object here as

409
00:18:25,020 --> 00:18:26,820
soon as I execute the read object that

410
00:18:26,820 --> 00:18:28,799
entire exploit is going to get triggered

411
00:18:28,799 --> 00:18:32,130
so so this this whole exploit will occur

412
00:18:32,130 --> 00:18:34,530
before read object returns meaning that

413
00:18:34,530 --> 00:18:37,020
any cast you have here to detect an

414
00:18:37,020 --> 00:18:40,559
invalid type is coming too late so I'm

415
00:18:40,559 --> 00:18:42,900
just gonna hit single step here and

416
00:18:42,900 --> 00:18:44,929
you'll see that there's a calculator and

417
00:18:44,929 --> 00:18:48,570
you can use this to figure out how much

418
00:18:48,570 --> 00:18:50,549
everyone should pay for lunch including

419
00:18:50,549 --> 00:18:55,919
a 15% tip and all works just fine okay

420
00:18:55,919 --> 00:18:59,250
so that's the end of that demo go back

421
00:18:59,250 --> 00:19:01,820
to the slides

422
00:19:03,919 --> 00:19:06,390
so there's your remote command execution

423
00:19:06,390 --> 00:19:08,490
I had some I gave this class once and

424
00:19:08,490 --> 00:19:10,289
someone right at this point raised a

425
00:19:10,289 --> 00:19:15,000
hand and said so what's the danger and I

426
00:19:15,000 --> 00:19:18,360
I just kind of Joe kind of fell open and

427
00:19:18,360 --> 00:19:20,039
someone else the audience had to explain

428
00:19:20,039 --> 00:19:22,620
to them I want attackers running code on

429
00:19:22,620 --> 00:19:28,400
your systems it seemed obvious to me

430
00:19:28,400 --> 00:19:33,710
okay so here's another demo which is a

431
00:19:33,710 --> 00:19:36,330
boss attack develop by this guy vote

432
00:19:36,330 --> 00:19:38,730
Tuco carrots at least I think that's how

433
00:19:38,730 --> 00:19:40,350
his name's pronounced haven't anyone

434
00:19:40,350 --> 00:19:42,120
tried to correct me yet so seems like a

435
00:19:42,120 --> 00:19:44,370
close approximation at least so he

436
00:19:44,370 --> 00:19:47,580
defined a half set with cycles and it's

437
00:19:47,580 --> 00:19:48,929
it's actually particularly devious

438
00:19:48,929 --> 00:19:50,909
because it doesn't exhaust memory which

439
00:19:50,909 --> 00:19:52,440
eventually will cause an out of memory

440
00:19:52,440 --> 00:19:54,179
exception what this does is just

441
00:19:54,179 --> 00:19:57,630
recursos indefinitely consuming CPU and

442
00:19:57,630 --> 00:20:00,630
you know runs forever so I'll show you

443
00:20:00,630 --> 00:20:02,990
this one real quick

444
00:20:02,990 --> 00:20:07,980
the let me show you the code so so

445
00:20:07,980 --> 00:20:11,580
here's the dose the dose payload we're

446
00:20:11,580 --> 00:20:13,440
just gonna create a half set and then

447
00:20:13,440 --> 00:20:15,330
we're gonna loop and basically create

448
00:20:15,330 --> 00:20:17,940
new half sets and assign them to other

449
00:20:17,940 --> 00:20:20,880
half sets and sort of create this cyclic

450
00:20:20,880 --> 00:20:23,010
structure so that's all there is to it

451
00:20:23,010 --> 00:20:26,159
it's very simple the demo is this one's

452
00:20:26,159 --> 00:20:30,900
a little bit cerebral cerebral sir you

453
00:20:30,900 --> 00:20:33,360
know what word I'm trying to say like in

454
00:20:33,360 --> 00:20:38,400
the mind yeah sorry one of the things

455
00:20:38,400 --> 00:20:39,690
that goes when you get older so your

456
00:20:39,690 --> 00:20:44,070
vocabulary home from NCC group you know

457
00:20:44,070 --> 00:20:45,390
so one of the things I did early on was

458
00:20:45,390 --> 00:20:48,809
I I put a sign on my front door that

459
00:20:48,809 --> 00:20:51,240
says put pants on you know so that that

460
00:20:51,240 --> 00:20:58,289
doesn't happen again cuz so anyway so so

461
00:20:58,289 --> 00:21:00,659
this example I'm gonna create a thread

462
00:21:00,659 --> 00:21:02,640
and in that thread I'm gonna deserialize

463
00:21:02,640 --> 00:21:05,190
the das payload then I'm gonna wait 10

464
00:21:05,190 --> 00:21:08,220
seconds so in computing terms 10 seconds

465
00:21:08,220 --> 00:21:10,350
is basically infinity because we don't

466
00:21:10,350 --> 00:21:12,659
want to wait until the Sun burns out to

467
00:21:12,659 --> 00:21:14,850
see if this returns so I'm just gonna

468
00:21:14,850 --> 00:21:17,850
run this and basically if you see

469
00:21:17,850 --> 00:21:21,659
exiting appear in the console it means

470
00:21:21,659 --> 00:21:24,570
that this this thread never completed

471
00:21:24,570 --> 00:21:26,640
because of the das attack if you see das

472
00:21:26,640 --> 00:21:31,950
has been deserialized my you know my

473
00:21:31,950 --> 00:21:33,570
demo would have ended in an embarrassing

474
00:21:33,570 --> 00:21:37,500
fashion but instead you know this this

475
00:21:37,500 --> 00:21:40,260
never completes so that's a wonderful

476
00:21:40,260 --> 00:21:41,970
little attack just using a hash table

477
00:21:41,970 --> 00:21:43,950
deserializing hash table which obviously

478
00:21:43,950 --> 00:21:48,230
is part of the java runtime environment

479
00:21:49,340 --> 00:21:56,100
okay moving on so I want to mention also

480
00:21:56,100 --> 00:21:59,850
patchy Commons a file upload which is

481
00:21:59,850 --> 00:22:01,890
another kind of dangerous gadget so this

482
00:22:01,890 --> 00:22:04,950
has a class called just file item which

483
00:22:04,950 --> 00:22:07,440
handles file uploads a serializable has

484
00:22:07,440 --> 00:22:09,450
custom write object and read object

485
00:22:09,450 --> 00:22:12,149
methods and this also allows remote

486
00:22:12,149 --> 00:22:15,179
execution and file manipulation using

487
00:22:15,179 --> 00:22:15,960
the the

488
00:22:15,960 --> 00:22:19,890
all to finalize and you know the

489
00:22:19,890 --> 00:22:21,330
interesting thing about the call to

490
00:22:21,330 --> 00:22:24,000
finalise is it runs as part of a

491
00:22:24,000 --> 00:22:27,150
separate thread so this called a you

492
00:22:27,150 --> 00:22:27,990
know it's called from the garbage

493
00:22:27,990 --> 00:22:29,640
collectors part of a separate thread so

494
00:22:29,640 --> 00:22:31,800
this call is not in the same security

495
00:22:31,800 --> 00:22:33,870
context as the normal deserialization

496
00:22:33,870 --> 00:22:36,120
right so it's outside of the security

497
00:22:36,120 --> 00:22:38,580
context which makes it even more

498
00:22:38,580 --> 00:22:42,540
dangerous sort of you know eliminates

499
00:22:42,540 --> 00:22:45,450
any mitigation you might have attempted

500
00:22:45,450 --> 00:22:53,820
by removing privileges so in this really

501
00:22:53,820 --> 00:22:56,040
there's just in the finalized method

502
00:22:56,040 --> 00:22:58,170
there's some code which goes and deletes

503
00:22:58,170 --> 00:23:00,750
a file right and so the risk here is

504
00:23:00,750 --> 00:23:03,420
that the name of the file is supplied by

505
00:23:03,420 --> 00:23:06,200
the attacker right so the attacker can

506
00:23:06,200 --> 00:23:08,670
you know modify the serialized data

507
00:23:08,670 --> 00:23:12,000
specify whatever file they want to you

508
00:23:12,000 --> 00:23:14,040
know blow way on your system and when

509
00:23:14,040 --> 00:23:16,290
this object gets finalized that file is

510
00:23:16,290 --> 00:23:21,990
as file is removed okay so risk factors

511
00:23:21,990 --> 00:23:25,020
and all this so so the biggest risk

512
00:23:25,020 --> 00:23:26,970
factor is you know are you deserializing

513
00:23:26,970 --> 00:23:29,430
untrusted data you know and a lot of

514
00:23:29,430 --> 00:23:30,780
people do this right people will

515
00:23:30,780 --> 00:23:34,080
serialize a cookie on their client

516
00:23:34,080 --> 00:23:35,790
system and then deserialize it and of

517
00:23:35,790 --> 00:23:38,610
course that's untrusted because it got

518
00:23:38,610 --> 00:23:42,930
to the to the end user you know if you

519
00:23:42,930 --> 00:23:46,050
if you're just doing serialization with

520
00:23:46,050 --> 00:23:48,360
within your trusted computing boundary

521
00:23:48,360 --> 00:23:50,430
within your trusting computer base it

522
00:23:50,430 --> 00:23:52,370
might not be so bad

523
00:23:52,370 --> 00:23:54,480
so does it take place before

524
00:23:54,480 --> 00:23:57,390
authentication sort of makes it worse

525
00:23:57,390 --> 00:23:58,830
it's nice to know at least the email of

526
00:23:58,830 --> 00:24:00,690
the person who's attacking you not that

527
00:24:00,690 --> 00:24:05,790
it's real and is there any attempt to

528
00:24:05,790 --> 00:24:07,470
limit what ties can be serialized which

529
00:24:07,470 --> 00:24:09,810
is a common effective mitigation you

530
00:24:09,810 --> 00:24:11,220
know basically whitelisting mitigation

531
00:24:11,220 --> 00:24:13,920
and also there's always this question

532
00:24:13,920 --> 00:24:16,740
does the deserialization host of gadgets

533
00:24:16,740 --> 00:24:19,620
that can be utilized and attack anyone

534
00:24:19,620 --> 00:24:21,650
want to hazard a guess at that question

535
00:24:21,650 --> 00:24:25,920
you think the host has gadgets that can

536
00:24:25,920 --> 00:24:27,780
be used in the attack there's couple

537
00:24:27,780 --> 00:24:29,940
people nodding so the answers

538
00:24:29,940 --> 00:24:32,730
yes yeah yes it does don't even think

539
00:24:32,730 --> 00:24:34,890
that well I haven't installed patchy

540
00:24:34,890 --> 00:24:38,750
comm and so I'm not at risk you know

541
00:24:38,750 --> 00:24:42,030
there are a number of you know dangerous

542
00:24:42,030 --> 00:24:44,070
gadgets but they've been identified but

543
00:24:44,070 --> 00:24:46,260
I think it's very clear that there are

544
00:24:46,260 --> 00:24:49,670
many more which have not been identified

545
00:24:50,010 --> 00:24:53,370
so I wanted to touch briefly on a

546
00:24:53,370 --> 00:24:56,460
mitigation so the the primary mitigation

547
00:24:56,460 --> 00:24:59,030
again is you know just don't do this

548
00:24:59,030 --> 00:25:03,420
don't do serialize untrusted data but

549
00:25:03,420 --> 00:25:05,640
the problem here I mean I I would

550
00:25:05,640 --> 00:25:06,960
describe this as the most difficult

551
00:25:06,960 --> 00:25:09,000
problem and software security because

552
00:25:09,000 --> 00:25:11,220
basically the problem you're trying to

553
00:25:11,220 --> 00:25:14,040
solve by deserializing untrusted data is

554
00:25:14,040 --> 00:25:17,370
how do i execute attacker supplied code

555
00:25:17,370 --> 00:25:20,520
securely in my environment right that's

556
00:25:20,520 --> 00:25:22,280
basically what you're doing so it's a

557
00:25:22,280 --> 00:25:25,020
really really really tough problem to

558
00:25:25,020 --> 00:25:30,810
solve so if you decide to try to solve

559
00:25:30,810 --> 00:25:32,340
this problem

560
00:25:32,340 --> 00:25:35,600
you know look ahead deserialization

561
00:25:35,600 --> 00:25:37,860
can be used for white listing or black

562
00:25:37,860 --> 00:25:40,050
listing now I've already put most people

563
00:25:40,050 --> 00:25:41,880
use it for black listing and I've also

564
00:25:41,880 --> 00:25:43,890
pointed out that black listing is 100%

565
00:25:43,890 --> 00:25:48,000
ineffective so if you're WebLogic

566
00:25:48,000 --> 00:25:49,680
whatever you know there's blacklist

567
00:25:49,680 --> 00:25:52,410
invoke or transformer you are still

568
00:25:52,410 --> 00:25:55,290
completely vulnerable to attacks just

569
00:25:55,290 --> 00:25:59,340
not the most popular one so there are a

570
00:25:59,340 --> 00:26:01,650
bunch of existing office off-the-shelf

571
00:26:01,650 --> 00:26:03,060
solutions bizzy's

572
00:26:03,060 --> 00:26:06,230
even one that kind of has the name of my

573
00:26:06,230 --> 00:26:11,880
my talk but my favorite has become the

574
00:26:11,880 --> 00:26:15,930
JDK the jp2 90 which was implemented by

575
00:26:15,930 --> 00:26:19,800
Oracle and and shipped starting with

576
00:26:19,800 --> 00:26:22,080
Java 9 and also portions of it were back

577
00:26:22,080 --> 00:26:27,810
ported to Java 6 7 & 8 so so the way

578
00:26:27,810 --> 00:26:30,140
this Java serialization filtering works

579
00:26:30,140 --> 00:26:35,910
is basically allows filtering of the

580
00:26:35,910 --> 00:26:39,780
classes before they are deserialize

581
00:26:39,780 --> 00:26:43,380
before the read object method starts to

582
00:26:43,380 --> 00:26:46,790
these various callback methods so we can

583
00:26:46,790 --> 00:26:49,050
we can narrow the set up deserialize

584
00:26:49,050 --> 00:26:51,420
with classes to a context appropriate

585
00:26:51,420 --> 00:26:54,420
set of classes you can also filter for a

586
00:26:54,420 --> 00:26:56,460
graph size and complexity to try to

587
00:26:56,460 --> 00:26:59,930
eliminate the denial of service attacks

588
00:26:59,930 --> 00:27:02,700
I'll show you in a minute that that

589
00:27:02,700 --> 00:27:08,250
doesn't work so it's very well basically

590
00:27:08,250 --> 00:27:11,160
that that well voltar Co carats attack

591
00:27:11,160 --> 00:27:14,100
Gossett AK I showed you is exceptionally

592
00:27:14,100 --> 00:27:17,160
tiny and there are no limits small

593
00:27:17,160 --> 00:27:18,750
enough to be set that would prevent that

594
00:27:18,750 --> 00:27:22,440
particularly das attacks so the you know

595
00:27:22,440 --> 00:27:25,440
the the limits that a lot of these tools

596
00:27:25,440 --> 00:27:27,270
implement is not particularly effective

597
00:27:27,270 --> 00:27:34,290
at preventing Gauss attacks so so

598
00:27:34,290 --> 00:27:37,830
they're starting in Java 9 and now I

599
00:27:37,830 --> 00:27:40,980
guess Java 9 is already obsolete it's

600
00:27:40,980 --> 00:27:43,850
kind of a fast-moving world so Java 10

601
00:27:43,850 --> 00:27:46,740
you have processed wide filters custom

602
00:27:46,740 --> 00:27:49,410
filters and built-in filters the core

603
00:27:49,410 --> 00:27:51,180
mechanism upon which all these things is

604
00:27:51,180 --> 00:27:54,840
built is a filter interface which is set

605
00:27:54,840 --> 00:27:57,990
on the object input stream the process

606
00:27:57,990 --> 00:27:59,550
wine filters they're kind of the big

607
00:27:59,550 --> 00:28:04,020
hammer solution those were back port it

608
00:28:04,020 --> 00:28:08,520
to JDK 8 7 & 6 as of these versions so

609
00:28:08,520 --> 00:28:11,400
if you're using you know an older

610
00:28:11,400 --> 00:28:13,050
version of Java and many people are

611
00:28:13,050 --> 00:28:16,290
still using JDK 8 because it's sort of

612
00:28:16,290 --> 00:28:18,720
the long term supported version right

613
00:28:18,720 --> 00:28:22,500
now of of Java you can at least use this

614
00:28:22,500 --> 00:28:25,170
process wide filter so the process wide

615
00:28:25,170 --> 00:28:27,330
filters configured via system property

616
00:28:27,330 --> 00:28:30,360
or configuration file so the system

617
00:28:30,360 --> 00:28:32,250
properties JDK serial filter and

618
00:28:32,250 --> 00:28:34,290
security properties the same but in the

619
00:28:34,290 --> 00:28:39,380
con security job of properties and the

620
00:28:39,380 --> 00:28:42,240
and it's basically kind of a string I'll

621
00:28:42,240 --> 00:28:44,880
show you what it looks like so custom

622
00:28:44,880 --> 00:28:46,620
filters can be written by implementing

623
00:28:46,620 --> 00:28:48,510
the object input felt interface and

624
00:28:48,510 --> 00:28:51,030
overriding the check input method you

625
00:28:51,030 --> 00:28:54,420
need to be using Java 9 or later to take

626
00:28:54,420 --> 00:28:56,800
advantage of this there's

627
00:28:56,800 --> 00:28:58,150
two methods add it to object input

628
00:28:58,150 --> 00:29:00,700
stream there's a set object input filter

629
00:29:00,700 --> 00:29:04,720
and a get object input filter and you

630
00:29:04,720 --> 00:29:08,350
can also set filters using config set 0

631
00:29:08,350 --> 00:29:11,170
filter which affect every object input

632
00:29:11,170 --> 00:29:12,610
stream that doesn't otherwise have a

633
00:29:12,610 --> 00:29:16,840
filter if there's no filter then a

634
00:29:16,840 --> 00:29:19,930
global filters use if it's defined so

635
00:29:19,930 --> 00:29:23,710
let me do a demo of this and might sort

636
00:29:23,710 --> 00:29:26,050
of cut this down a little bit in the

637
00:29:26,050 --> 00:29:29,470
interest of time I think I have 20

638
00:29:29,470 --> 00:29:31,870
minutes left which is I could show more

639
00:29:31,870 --> 00:29:35,850
of this yeah I've got two slides left

640
00:29:35,850 --> 00:29:37,810
it's been pretty fast

641
00:29:37,810 --> 00:29:40,450
I mean you eliminate more slides than I

642
00:29:40,450 --> 00:29:41,920
needed to

643
00:29:41,920 --> 00:29:46,030
okay so let me demo this and you know

644
00:29:46,030 --> 00:29:48,010
now that I'm less afraid of the time

645
00:29:48,010 --> 00:29:55,180
I'll say ask questions so this is this

646
00:29:55,180 --> 00:29:57,310
is down here I haven't a different

647
00:29:57,310 --> 00:30:00,730
project because I need it to use Java 9

648
00:30:00,730 --> 00:30:05,830
or now I'm up to Java 10 and I guess

649
00:30:05,830 --> 00:30:09,510
what I'll show first is I'll show the

650
00:30:09,510 --> 00:30:12,280
vulnerable code so I'm gonna take out

651
00:30:12,280 --> 00:30:16,300
the mitigation here and start to debug

652
00:30:16,300 --> 00:30:22,020
this so one of the things I did here

653
00:30:22,020 --> 00:30:25,720
which I I mostly think was a good idea

654
00:30:25,720 --> 00:30:37,930
was I I swapped out okay I swapped out

655
00:30:37,930 --> 00:30:43,150
the default Java compiler and I used the

656
00:30:43,150 --> 00:30:47,140
Google compiler which is called me

657
00:30:47,140 --> 00:30:50,410
cheating look Oh error prone

658
00:30:50,410 --> 00:30:52,630
an error prone is kind of cool I mean it

659
00:30:52,630 --> 00:30:55,840
just diagnose so usually here David

660
00:30:55,840 --> 00:30:57,190
could back me up on this you know you

661
00:30:57,190 --> 00:30:59,620
you run into the Sun Java guys one so on

662
00:30:59,620 --> 00:31:01,930
you say could you please flag you know

663
00:31:01,930 --> 00:31:05,110
like no how about no and they're like

664
00:31:05,110 --> 00:31:06,550
well it's too many false pauses we're

665
00:31:06,550 --> 00:31:08,470
not gonna flag that and so what

666
00:31:08,470 --> 00:31:10,450
error-prone did was you know

667
00:31:10,450 --> 00:31:12,130
every one of those requests to flag

668
00:31:12,130 --> 00:31:14,590
something they implemented so so

669
00:31:14,590 --> 00:31:16,150
error-prone actually Flags all these

670
00:31:16,150 --> 00:31:18,760
sort of dangerous pieces of code and you

671
00:31:18,760 --> 00:31:21,160
know if you don't like false positives I

672
00:31:21,160 --> 00:31:23,290
guess don't use error-prone go back to

673
00:31:23,290 --> 00:31:27,220
using just a normal Oracle compiler okay

674
00:31:27,220 --> 00:31:28,930
so in this example we're going to

675
00:31:28,930 --> 00:31:32,290
serialize a bicycle ensure this is

676
00:31:32,290 --> 00:31:34,800
working

677
00:31:40,230 --> 00:31:42,690
okay so we're gonna see you realize a

678
00:31:42,690 --> 00:31:44,549
bicycle I'm gonna serialize a file

679
00:31:44,549 --> 00:31:47,250
object the idea here is that the bicycle

680
00:31:47,250 --> 00:31:49,769
is what we want to serialize deserialize

681
00:31:49,769 --> 00:31:52,200
and the files what we do not as it's the

682
00:31:52,200 --> 00:31:55,110
misuse case so we're gonna deserialize

683
00:31:55,110 --> 00:31:58,830
the bicycle and that there's the call to

684
00:31:58,830 --> 00:32:01,529
read object and so that works just

685
00:32:01,529 --> 00:32:03,480
wonderfully and now we're going to

686
00:32:03,480 --> 00:32:07,169
deserialize our file and there's a call

687
00:32:07,169 --> 00:32:10,289
to read object and that also works

688
00:32:10,289 --> 00:32:13,250
wonderfully and what I've done here is

689
00:32:13,250 --> 00:32:16,139
instead of sort of casting this expected

690
00:32:16,139 --> 00:32:17,820
type i just assigned it to an object

691
00:32:17,820 --> 00:32:20,279
that eliminates the actual cast

692
00:32:20,279 --> 00:32:23,130
exception that you should receive this

693
00:32:23,130 --> 00:32:24,899
seems like a stupid thing to do but

694
00:32:24,899 --> 00:32:28,590
again it's not uncommon for us to find

695
00:32:28,590 --> 00:32:31,820
this in source code that we evaluate

696
00:32:31,820 --> 00:32:35,070
okay so let me modify this code and

697
00:32:35,070 --> 00:32:39,120
we'll show the mitigations so we're

698
00:32:39,120 --> 00:32:41,820
gonna do here is we're gonna we're gonna

699
00:32:41,820 --> 00:32:44,820
add a custom filter this bike filter to

700
00:32:44,820 --> 00:32:48,720
the object input stream let's go ahead

701
00:32:48,720 --> 00:32:54,269
and debug that the bicycle filter well I

702
00:32:54,269 --> 00:32:59,389
guess you'll see it start to look at it

703
00:33:01,370 --> 00:33:03,690
okay so we're going to serialize the

704
00:33:03,690 --> 00:33:08,159
bicycle we're going to serialize the

705
00:33:08,159 --> 00:33:11,250
file and now we're going to deserialize

706
00:33:11,250 --> 00:33:15,360
the bicycle there's the read object

707
00:33:15,360 --> 00:33:18,480
method and now the read object method

708
00:33:18,480 --> 00:33:20,279
invokes the custom filter that we've

709
00:33:20,279 --> 00:33:22,590
installed so here's the custom filter it

710
00:33:22,590 --> 00:33:25,350
makes a call to check input and you can

711
00:33:25,350 --> 00:33:27,120
see here in the output that I just

712
00:33:27,120 --> 00:33:28,649
printed out some of the data that's

713
00:33:28,649 --> 00:33:30,210
passed here right so you can see the

714
00:33:30,210 --> 00:33:32,970
number of references the depth you know

715
00:33:32,970 --> 00:33:35,669
the depth of the object graph the number

716
00:33:35,669 --> 00:33:37,980
of bytes and the actual name of the

717
00:33:37,980 --> 00:33:39,419
class being deserialized which is

718
00:33:39,419 --> 00:33:44,100
bicycle so we check the limits and none

719
00:33:44,100 --> 00:33:45,899
of the limits are exceeded so we're good

720
00:33:45,899 --> 00:33:48,120
there then we get the name of the class

721
00:33:48,120 --> 00:33:51,920
we find out it's a bicycle and

722
00:33:51,920 --> 00:33:55,550
this is sort of interesting you ever

723
00:33:55,550 --> 00:33:57,920
change your coat just before the night

724
00:33:57,920 --> 00:33:59,180
before you give a demo and they forgot

725
00:33:59,180 --> 00:34:00,800
to change it back so that's what I did

726
00:34:00,800 --> 00:34:03,410
so so what this was supposed to say here

727
00:34:03,410 --> 00:34:06,140
was accept it

728
00:34:06,140 --> 00:34:08,710
reject it and undecided but now it says

729
00:34:08,710 --> 00:34:10,730
undecided because I was wondering what

730
00:34:10,730 --> 00:34:11,810
would happen if it just returned

731
00:34:11,810 --> 00:34:14,000
undecided now the interesting thing here

732
00:34:14,000 --> 00:34:17,989
let me show you so we're going to return

733
00:34:17,989 --> 00:34:24,020
undecided if you return undecided it

734
00:34:24,020 --> 00:34:27,139
will actually deserialize the object so

735
00:34:27,139 --> 00:34:30,110
that will actually succeed but my next

736
00:34:30,110 --> 00:34:32,449
one is not gonna work because it's

737
00:34:32,449 --> 00:34:38,630
supposed to be rejected so I guess let's

738
00:34:38,630 --> 00:34:48,168
fix it Oh bicycle doctor so this should

739
00:34:48,168 --> 00:34:51,400
be accepted

740
00:34:59,950 --> 00:35:03,808
my spelling except it wrong

741
00:35:12,360 --> 00:35:15,810
and here we're gonna do reject it that

742
00:35:15,810 --> 00:35:22,580
shows up and go back here

743
00:35:27,850 --> 00:35:30,360
okay now what

744
00:35:30,360 --> 00:35:33,420
I just do undecided for now because it

745
00:35:33,420 --> 00:35:37,800
does work it turns out I was off looking

746
00:35:37,800 --> 00:35:41,070
at the you know Oracle source code and

747
00:35:41,070 --> 00:35:43,260
they never do a test on anything beside

748
00:35:43,260 --> 00:35:45,840
rejected which means that in their code

749
00:35:45,840 --> 00:35:48,420
that handles this accept it and

750
00:35:48,420 --> 00:35:50,690
undecided or handled exactly the same

751
00:35:50,690 --> 00:35:53,880
normally this should be accept it and

752
00:35:53,880 --> 00:35:56,640
this should be undecided here but let's

753
00:35:56,640 --> 00:35:58,730
go ahead and try this again

754
00:35:58,730 --> 00:36:06,990
going to you I'm gonna stop the code

755
00:36:06,990 --> 00:36:15,060
from running and then I'm sorry go ahead

756
00:36:15,060 --> 00:36:17,900
and debug this again

757
00:36:21,120 --> 00:36:22,980
yeah so the problem with air prone is it

758
00:36:22,980 --> 00:36:24,840
compiles a little slower which makes it

759
00:36:24,840 --> 00:36:28,200
not perfect for demos but okay so we're

760
00:36:28,200 --> 00:36:30,000
gonna create the bicycle object we're

761
00:36:30,000 --> 00:36:31,440
gonna create the file object we're gonna

762
00:36:31,440 --> 00:36:35,510
deserialize the bicycle object now we're

763
00:36:35,510 --> 00:36:39,180
we're still returning undecided it still

764
00:36:39,180 --> 00:36:39,870
works

765
00:36:39,870 --> 00:36:44,430
and now we're going to do you see

766
00:36:44,430 --> 00:36:46,350
realize the file objects that we call

767
00:36:46,350 --> 00:36:48,720
read object we're into the filter method

768
00:36:48,720 --> 00:36:50,820
and you can see here now we're dealing

769
00:36:50,820 --> 00:36:53,640
with deserializing a file object again

770
00:36:53,640 --> 00:36:55,650
the all the all the limits are quite

771
00:36:55,650 --> 00:36:57,510
small so that's not going to trigger the

772
00:36:57,510 --> 00:37:01,950
rejection but the class now is is a file

773
00:37:01,950 --> 00:37:06,270
it's not bicycle so based on that this

774
00:37:06,270 --> 00:37:10,610
will be rejected and that will cause

775
00:37:10,610 --> 00:37:13,290
that will cause an exception to be

776
00:37:13,290 --> 00:37:16,290
thrown so you'll see here that we end up

777
00:37:16,290 --> 00:37:19,260
with a invalid class exception so the D

778
00:37:19,260 --> 00:37:22,490
serialization is prevented

779
00:37:22,550 --> 00:37:29,250
let me just well stop twelve minutes

780
00:37:29,250 --> 00:37:31,260
I'll show the whole demo that I normally

781
00:37:31,260 --> 00:37:37,500
show so here I'm going to disable the

782
00:37:37,500 --> 00:37:40,260
custom filter and I'm going to show the

783
00:37:40,260 --> 00:37:43,470
process wide filter so the advantage of

784
00:37:43,470 --> 00:37:46,830
this one is that you know it sets for

785
00:37:46,830 --> 00:37:49,830
everything in your JVM and also it's

786
00:37:49,830 --> 00:37:51,870
available in Java 6 7 & 8 so this is

787
00:37:51,870 --> 00:37:53,190
something you could use today if you're

788
00:37:53,190 --> 00:37:56,280
using Java 8 so let me start to compile

789
00:37:56,280 --> 00:37:59,580
this just think lack of interest in

790
00:37:59,580 --> 00:38:01,670
process Y filters I thought these were

791
00:38:01,670 --> 00:38:05,970
sort of more interesting than that so

792
00:38:05,970 --> 00:38:08,370
here's the filter basically that's being

793
00:38:08,370 --> 00:38:11,160
set and it takes a little practice to

794
00:38:11,160 --> 00:38:13,680
get this right so the first time I did

795
00:38:13,680 --> 00:38:16,350
this I said you know don't serialize

796
00:38:16,350 --> 00:38:19,290
anything and then serialize bicycle and

797
00:38:19,290 --> 00:38:20,940
it turned out that basically said don't

798
00:38:20,940 --> 00:38:23,130
serialize anything because that first

799
00:38:23,130 --> 00:38:25,200
filter would catch everything so you

800
00:38:25,200 --> 00:38:27,270
have to put sort of the more specialized

801
00:38:27,270 --> 00:38:29,340
filters here so what I'm saying now is

802
00:38:29,340 --> 00:38:32,370
to serialize by scope but don't Syria

803
00:38:32,370 --> 00:38:34,560
deserialize anything else and then

804
00:38:34,560 --> 00:38:36,570
set some limits for no good reason

805
00:38:36,570 --> 00:38:39,960
because this this does not work I've

806
00:38:39,960 --> 00:38:42,510
been successful so if I go ahead and

807
00:38:42,510 --> 00:38:54,470
debug this let me just run it okay

808
00:38:54,470 --> 00:39:07,110
you'll see that the filter snags okay

809
00:39:07,110 --> 00:39:09,900
so this filter that we set this process

810
00:39:09,900 --> 00:39:13,620
white filter snags that you know based

811
00:39:13,620 --> 00:39:15,480
on this filter it says hey bicycle is

812
00:39:15,480 --> 00:39:17,340
allowed but nothing else is allowed so

813
00:39:17,340 --> 00:39:22,140
it rejects the the file class okay so

814
00:39:22,140 --> 00:39:23,820
one last example and then we're done

815
00:39:23,820 --> 00:39:28,110
with this and then I'll wrap up so for

816
00:39:28,110 --> 00:39:30,900
the last example I'm gonna go back to

817
00:39:30,900 --> 00:39:34,590
the custom alright everybody we're

818
00:39:34,590 --> 00:39:36,390
trying to get life set up for you all so

819
00:39:36,390 --> 00:39:38,070
please make sure to keep room in the

820
00:39:38,070 --> 00:39:40,050
hallways for the lunch people to get the

821
00:39:40,050 --> 00:39:43,290
food back for you and also it's not

822
00:39:43,290 --> 00:39:45,480
quite the time to get in line for lunch

823
00:39:45,480 --> 00:39:47,880
yet so just hold off there's plenty of

824
00:39:47,880 --> 00:39:50,490
food for everybody and it's gonna be

825
00:39:50,490 --> 00:39:55,830
starting at noon so and the booths will

826
00:39:55,830 --> 00:39:58,680
be open at noon - so form two lines one

827
00:39:58,680 --> 00:40:00,120
for the booze and one for the food thank

828
00:40:00,120 --> 00:40:03,570
you freeze Georgia being here say how

829
00:40:03,570 --> 00:40:08,190
woot that's the first time I did Georgia

830
00:40:08,190 --> 00:40:11,220
Binks in first nation works ok yes ok so

831
00:40:11,220 --> 00:40:13,500
I just made that last change and then I

832
00:40:13,500 --> 00:40:16,980
ran this and what I can show you here is

833
00:40:16,980 --> 00:40:19,590
that this daus attack at the end this

834
00:40:19,590 --> 00:40:21,930
ultra curse attack lines up getting

835
00:40:21,930 --> 00:40:24,840
defeated now the interesting thing about

836
00:40:24,840 --> 00:40:27,600
this is it's not to feed it because of

837
00:40:27,600 --> 00:40:30,390
the limits right so you see the voter

838
00:40:30,390 --> 00:40:33,240
Koko's attack has has one reference it's

839
00:40:33,240 --> 00:40:35,040
it's less bytes than the bicycle attack

840
00:40:35,040 --> 00:40:38,580
is 36 bytes and there's there's really

841
00:40:38,580 --> 00:40:40,590
nothing here that you can detect with

842
00:40:40,590 --> 00:40:42,840
the lemon the only reason it gets caught

843
00:40:42,840 --> 00:40:45,420
is because hash set wasn't in my

844
00:40:45,420 --> 00:40:47,640
whitelist and so it turns out that you

845
00:40:47,640 --> 00:40:48,330
really don't

846
00:40:48,330 --> 00:40:50,580
to serialize hash anyway so it's a good

847
00:40:50,580 --> 00:40:53,640
it's a good object to leave out of your

848
00:40:53,640 --> 00:40:57,240
your white list of objects okay so going

849
00:40:57,240 --> 00:41:03,390
back to the slides the so the primary

850
00:41:03,390 --> 00:41:05,580
mitigation for this stuff again is do

851
00:41:05,580 --> 00:41:08,040
not serialize untrusted data it's really

852
00:41:08,040 --> 00:41:11,790
a tough thing to get right you know if

853
00:41:11,790 --> 00:41:14,670
you need to do that you can look at this

854
00:41:14,670 --> 00:41:16,650
look ahead object input streams to use

855
00:41:16,650 --> 00:41:19,980
whitelisting to to serialize only only

856
00:41:19,980 --> 00:41:21,840
those necessary classes and then

857
00:41:21,840 --> 00:41:25,860
basically you know you should come to my

858
00:41:25,860 --> 00:41:27,630
full-day course and then I'll teach you

859
00:41:27,630 --> 00:41:30,300
how to write those whitelisted classes

860
00:41:30,300 --> 00:41:31,680
so they're secure right because it's

861
00:41:31,680 --> 00:41:34,100
also very easy to make an error in

862
00:41:34,100 --> 00:41:38,250
implementing those classes so you can

863
00:41:38,250 --> 00:41:40,200
apply a custom filter with a whitelist

864
00:41:40,200 --> 00:41:42,870
for each use of deserialization that

865
00:41:42,870 --> 00:41:46,080
lets you be more precise about you know

866
00:41:46,080 --> 00:41:47,940
which objects can be to serialize in

867
00:41:47,940 --> 00:41:50,250
which context and then I didn't talk

868
00:41:50,250 --> 00:41:51,750
about this at all but makes sense to

869
00:41:51,750 --> 00:41:53,280
have a Security Manager with the

870
00:41:53,280 --> 00:41:55,950
security policy so you can sort of limit

871
00:41:55,950 --> 00:41:57,780
the potential damage that might be done

872
00:41:57,780 --> 00:42:01,230
if your deserializing untrusted objects

873
00:42:01,230 --> 00:42:07,700
so that's said for my talk this is me

874
00:42:07,700 --> 00:42:11,370
this is my email address I answer email

875
00:42:11,370 --> 00:42:14,580
7:24 I know it sounds weird but I will

876
00:42:14,580 --> 00:42:17,550
wake up at 2:45 a.m. on a Saturday

877
00:42:17,550 --> 00:42:20,490
morning and have this instinct that

878
00:42:20,490 --> 00:42:21,900
someone just sent me an email and you'll

879
00:42:21,900 --> 00:42:24,350
get a response within five minutes so

880
00:42:24,350 --> 00:42:29,790
and you know there's a I have a live

881
00:42:29,790 --> 00:42:31,440
lessons out with Pearson which is a

882
00:42:31,440 --> 00:42:33,840
video series on Java series and feel

883
00:42:33,840 --> 00:42:35,670
free to enjoy that it's open also

884
00:42:35,670 --> 00:42:38,270
available on Safari books online or

885
00:42:38,270 --> 00:42:40,320
contact us and we can come to your

886
00:42:40,320 --> 00:42:41,820
organization and spend a whole day

887
00:42:41,820 --> 00:42:43,740
training your developers up on how to

888
00:42:43,740 --> 00:42:47,790
use Java sedation securely okay that's

889
00:42:47,790 --> 00:42:52,520
it for me any questions yes sir

890
00:42:57,619 --> 00:43:00,619
yeah

891
00:43:15,619 --> 00:43:19,800
yeah it's just any any field in in the

892
00:43:19,800 --> 00:43:22,950
serialized object is open to you

893
00:43:22,950 --> 00:43:25,230
tampering right because the format's

894
00:43:25,230 --> 00:43:27,750
fully defined so you know an attacker

895
00:43:27,750 --> 00:43:31,410
can just get it get it and you know edit

896
00:43:31,410 --> 00:43:33,930
the the contents of the object and

897
00:43:33,930 --> 00:43:36,380
replace one file name with another

898
00:43:36,380 --> 00:43:39,210
typically the way most attackers do this

899
00:43:39,210 --> 00:43:40,980
is they just they just write D

900
00:43:40,980 --> 00:43:43,619
serialization code and so to create

901
00:43:43,619 --> 00:43:46,530
their own objects with their you know

902
00:43:46,530 --> 00:43:49,970
their specific values in order to create

903
00:43:49,970 --> 00:43:53,630
sort of specially crafted malicious

904
00:43:53,630 --> 00:43:56,970
serialization stream but that tampering

905
00:43:56,970 --> 00:43:58,800
is really straightforward

906
00:43:58,800 --> 00:44:01,080
I have normal you know my normal

907
00:44:01,080 --> 00:44:03,119
training I showed an example of popping

908
00:44:03,119 --> 00:44:05,010
open a file the series asian file and

909
00:44:05,010 --> 00:44:06,690
editing it and then saving it and the

910
00:44:06,690 --> 00:44:09,710
date has changed

911
00:44:21,740 --> 00:44:25,849
yeah if you can get to the you know if

912
00:44:25,849 --> 00:44:28,700
you can get to the proxy object right so

913
00:44:28,700 --> 00:44:31,040
the proxy object is typically designed

914
00:44:31,040 --> 00:44:33,920
to be the perfect serialize form of the

915
00:44:33,920 --> 00:44:37,220
object right so it it's only purpose is

916
00:44:37,220 --> 00:44:39,530
to store the information and retrieve it

917
00:44:39,530 --> 00:44:41,900
whereas the actual object you know it's

918
00:44:41,900 --> 00:44:43,609
mostly designed to be efficient at

919
00:44:43,609 --> 00:44:48,710
runtime ring functionality but but the

920
00:44:48,710 --> 00:44:53,180
proxy will make a copy of really the

921
00:44:53,180 --> 00:45:00,910
arguments constructor and pass that data

922
00:45:00,910 --> 00:45:07,430
to the objects constructor during so

923
00:45:07,430 --> 00:45:20,599
that data is gonna be serialized David

924
00:45:20,599 --> 00:45:23,330
next she's smart used to work for me at

925
00:45:23,330 --> 00:45:24,830
certain he knows all about sterilization

926
00:45:24,830 --> 00:45:26,060
but it's nice to know that there's like

927
00:45:26,060 --> 00:45:29,180
two people who understood yeah

928
00:45:29,180 --> 00:45:39,730
any other questions okay yeah yeah

929
00:45:39,770 --> 00:45:45,260
uh no I don't think there's any way to

930
00:45:45,260 --> 00:45:48,740
fix it and furthermore it's hash tables

931
00:45:48,740 --> 00:45:50,330
that are not really designed for

932
00:45:50,330 --> 00:45:54,890
serialization because but even without

933
00:45:54,890 --> 00:45:57,260
the attacker in the picture because when

934
00:45:57,260 --> 00:45:59,840
you when you deserialize at the

935
00:45:59,840 --> 00:46:03,320
different JVM the keys aren't guaranteed

936
00:46:03,320 --> 00:46:07,340
to work anymore so so there's kind of

937
00:46:07,340 --> 00:46:10,700
multiple reasons not to serialize and

938
00:46:10,700 --> 00:46:12,590
deserialize those sort of collections

939
00:46:12,590 --> 00:46:22,670
what you could try is to use a proxy you

940
00:46:22,670 --> 00:46:28,640
know I know all the details of every but

941
00:46:28,640 --> 00:46:32,690
I guess in general I met the highly

942
00:46:32,690 --> 00:46:35,390
suspicious point where I wouldn't use

943
00:46:35,390 --> 00:46:46,730
any of these unless and you know a lot

944
00:46:46,730 --> 00:46:48,590
of experts in this area basically just

945
00:46:48,590 --> 00:46:59,480
kind of say that attack streams any

946
00:46:59,480 --> 00:47:01,609
other questions okay

947
00:47:01,609 --> 00:47:04,750
I think there's a lot

948
00:47:04,960 --> 00:47:10,729
[Applause]

