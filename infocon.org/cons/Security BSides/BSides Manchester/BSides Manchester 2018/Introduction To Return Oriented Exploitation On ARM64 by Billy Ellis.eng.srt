1
00:00:06,710 --> 00:00:11,010
<font color="#E5E5E5">all right so today we're talking</font><font color="#CCCCCC"> about</font>

2
00:00:09,059 --> 00:00:14,340
an introduction<font color="#CCCCCC"> to</font><font color="#E5E5E5"> return oriented</font>

3
00:00:11,010 --> 00:00:15,629
exploitation on 64 and I did<font color="#CCCCCC"> actually</font>

4
00:00:14,340 --> 00:00:18,090
<font color="#CCCCCC">really present this talk earlier today</font>

5
00:00:15,630 --> 00:00:21,350
<font color="#CCCCCC">but</font><font color="#E5E5E5"> the audio didn't record</font>

6
00:00:18,090 --> 00:00:23,460
unfortunately so I'm<font color="#E5E5E5"> doing</font><font color="#CCCCCC"> a second time</font>

7
00:00:21,350 --> 00:00:24,150
<font color="#E5E5E5">so first of all</font><font color="#CCCCCC"> for those you</font><font color="#E5E5E5"> don't know</font>

8
00:00:23,460 --> 00:00:26,369
<font color="#E5E5E5">who I am</font>

9
00:00:24,150 --> 00:00:27,959
my<font color="#E5E5E5"> name is Billy Ellis a</font><font color="#CCCCCC"> seventeen year</font>

10
00:00:26,369 --> 00:00:30,150
<font color="#CCCCCC">old from</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> UK and I've been doing</font>

11
00:00:27,960 --> 00:00:31,790
<font color="#E5E5E5">programming and iOS app development for</font>

12
00:00:30,150 --> 00:00:33,780
around five or<font color="#E5E5E5"> six years now</font><font color="#CCCCCC"> and</font>

13
00:00:31,790 --> 00:00:36,360
recently in the last<font color="#E5E5E5"> two years</font><font color="#CCCCCC"> I got</font>

14
00:00:33,780 --> 00:00:38,520
<font color="#E5E5E5">interested in security specifically</font>

15
00:00:36,360 --> 00:00:42,149
<font color="#E5E5E5">mobile security and so for exploitation</font>

16
00:00:38,520 --> 00:00:44,969
<font color="#E5E5E5">and during</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> time I've created a</font>

17
00:00:42,149 --> 00:00:47,399
various<font color="#E5E5E5"> a set of</font><font color="#CCCCCC"> various armed</font><font color="#E5E5E5"> exploit</font>

18
00:00:44,969 --> 00:00:48,750
exercise binaries which are they're

19
00:00:47,399 --> 00:00:51,090
<font color="#E5E5E5">basically like small programs where you</font>

20
00:00:48,750 --> 00:00:53,850
<font color="#CCCCCC">can</font><font color="#E5E5E5"> test your</font><font color="#CCCCCC"> skills</font><font color="#E5E5E5"> at</font><font color="#CCCCCC"> different types</font>

21
00:00:51,090 --> 00:00:55,680
of memory corruption exploitation<font color="#CCCCCC"> and</font>

22
00:00:53,850 --> 00:00:56,789
those are<font color="#CCCCCC"> available online I'm also</font><font color="#E5E5E5"> the</font>

23
00:00:55,680 --> 00:00:58,980
author<font color="#E5E5E5"> of beginner's guide to</font>

24
00:00:56,789 --> 00:01:00,809
exploitation arm which is<font color="#E5E5E5"> what the title</font>

25
00:00:58,980 --> 00:01:03,269
<font color="#CCCCCC">says it's a beginner's got a beginner's</font>

26
00:01:00,809 --> 00:01:05,459
guide to the basic concepts of software

27
00:01:03,270 --> 00:01:07,680
exploitation<font color="#E5E5E5"> specifically geared towards</font>

28
00:01:05,459 --> 00:01:09,330
the ARM architecture so mobile devices

29
00:01:07,680 --> 00:01:11,070
and I also run<font color="#E5E5E5"> a YouTube</font><font color="#CCCCCC"> channel</font>

30
00:01:09,330 --> 00:01:13,860
<font color="#CCCCCC">teaching</font><font color="#E5E5E5"> different</font><font color="#CCCCCC"> programming related</font>

31
00:01:11,070 --> 00:01:15,929
<font color="#E5E5E5">topics</font><font color="#CCCCCC"> app development expert</font>

32
00:01:13,860 --> 00:01:20,880
development things<font color="#E5E5E5"> like that mostly</font>

33
00:01:15,930 --> 00:01:22,439
related towards iOS jailbreaking<font color="#E5E5E5"> so the</font>

34
00:01:20,880 --> 00:01:24,570
<font color="#E5E5E5">focus of this talk is to</font><font color="#CCCCCC"> introduce</font>

35
00:01:22,439 --> 00:01:26,580
<font color="#E5E5E5">return oriented exploitation techniques</font>

36
00:01:24,570 --> 00:01:28,860
for people who are not<font color="#E5E5E5"> familiar with</font><font color="#CCCCCC"> it</font>

37
00:01:26,580 --> 00:01:30,420
<font color="#CCCCCC">also to cover the fundamentals of both</font>

38
00:01:28,860 --> 00:01:32,490
the arm and the arm<font color="#E5E5E5"> be early on</font>

39
00:01:30,420 --> 00:01:34,650
<font color="#CCCCCC">sixty-four architectures and then</font><font color="#E5E5E5"> I'm</font>

40
00:01:32,490 --> 00:01:36,570
going<font color="#E5E5E5"> to demo a rope exploit at the end</font>

41
00:01:34,650 --> 00:01:38,280
to<font color="#E5E5E5"> kind of integrate some</font><font color="#CCCCCC"> of the</font>

42
00:01:36,570 --> 00:01:42,089
techniques I'm going to discuss<font color="#E5E5E5"> into an</font>

43
00:01:38,280 --> 00:01:44,340
example that<font color="#E5E5E5"> you can see so first of all</font>

44
00:01:42,090 --> 00:01:46,380
why<font color="#CCCCCC"> would you want</font><font color="#E5E5E5"> to target arm so arm</font>

45
00:01:44,340 --> 00:01:48,299
<font color="#E5E5E5">devices are us the mobile devices these</font>

46
00:01:46,380 --> 00:01:50,360
<font color="#E5E5E5">are</font><font color="#CCCCCC"> all</font><font color="#E5E5E5"> running on ARM based chips some</font>

47
00:01:48,299 --> 00:01:52,829
laptops<font color="#E5E5E5"> now even use arm as well and</font>

48
00:01:50,360 --> 00:01:54,509
embedded<font color="#CCCCCC"> systems smartwatches</font><font color="#E5E5E5"> lots of</font>

49
00:01:52,829 --> 00:01:55,110
different devices<font color="#E5E5E5"> are</font><font color="#CCCCCC"> running on on-base</font>

50
00:01:54,509 --> 00:01:57,180
<font color="#E5E5E5">chips</font>

51
00:01:55,110 --> 00:01:59,250
<font color="#E5E5E5">so obviously it's making</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> huge</font>

52
00:01:57,180 --> 00:02:00,990
worthwhile target for attackers<font color="#E5E5E5"> and</font>

53
00:01:59,250 --> 00:02:03,840
malware developers because<font color="#E5E5E5"> they become</font>

54
00:02:00,990 --> 00:02:07,079
<font color="#E5E5E5">more and more popular</font><font color="#CCCCCC"> and so there's a</font>

55
00:02:03,840 --> 00:02:08,878
big market<font color="#CCCCCC"> for</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> so we're going</font><font color="#E5E5E5"> to</font>

56
00:02:07,079 --> 00:02:11,549
<font color="#E5E5E5">look at the fundamentals first of all of</font>

57
00:02:08,878 --> 00:02:12,870
the arm<font color="#CCCCCC"> v7 architecture so this is the</font>

58
00:02:11,550 --> 00:02:15,659
<font color="#E5E5E5">32-bit</font>

59
00:02:12,870 --> 00:02:18,269
arm architecture<font color="#CCCCCC"> it</font><font color="#E5E5E5"> uses instructions of</font>

60
00:02:15,659 --> 00:02:19,739
a fixed size<font color="#CCCCCC"> of</font><font color="#E5E5E5"> 32 bits and also it</font>

61
00:02:18,269 --> 00:02:22,769
supports a<font color="#CCCCCC"> different mode known as the</font>

62
00:02:19,739 --> 00:02:27,120
thumb mode which is a<font color="#CCCCCC"> 16-bit</font><font color="#E5E5E5"> mode so</font>

63
00:02:22,769 --> 00:02:29,549
that's<font color="#E5E5E5"> useful at memory efficiency</font>

64
00:02:27,120 --> 00:02:33,569
it also has<font color="#E5E5E5"> 16 main registers</font><font color="#CCCCCC"> that you</font>

65
00:02:29,549 --> 00:02:38,250
need to know about as a semblance are

66
00:02:33,569 --> 00:02:39,929
labeled from<font color="#CCCCCC"> R 0 to</font><font color="#E5E5E5"> R</font><font color="#CCCCCC"> 15 so</font><font color="#E5E5E5"> R 0 to R 12</font>

67
00:02:38,250 --> 00:02:42,810
these<font color="#E5E5E5"> are all general purpose registers</font>

68
00:02:39,930 --> 00:02:45,030
and you can essentially<font color="#CCCCCC"> use these to</font>

69
00:02:42,810 --> 00:02:47,220
store any any date you need for<font color="#E5E5E5"> your</font>

70
00:02:45,030 --> 00:02:49,560
<font color="#CCCCCC">figure programs</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> first few of those</font>

71
00:02:47,220 --> 00:02:51,540
so I think<font color="#CCCCCC"> R 0 up until of</font><font color="#E5E5E5"> three</font><font color="#CCCCCC"> may be</font>

72
00:02:49,560 --> 00:02:53,340
those used<font color="#CCCCCC"> for passing arguments</font><font color="#E5E5E5"> to</font>

73
00:02:51,540 --> 00:02:55,849
functions<font color="#E5E5E5"> so you would pass your first</font>

74
00:02:53,340 --> 00:02:58,109
argument<font color="#E5E5E5"> in R 0 second in R 1 and so on</font>

75
00:02:55,849 --> 00:03:00,839
<font color="#E5E5E5">then you also have</font><font color="#CCCCCC"> some special</font><font color="#E5E5E5"> purpose</font>

76
00:02:58,109 --> 00:03:03,150
<font color="#E5E5E5">registers so</font><font color="#CCCCCC"> our</font><font color="#E5E5E5"> 13 first of all this is</font>

77
00:03:00,840 --> 00:03:04,890
used as<font color="#E5E5E5"> a stack pointer register which</font>

78
00:03:03,150 --> 00:03:06,480
<font color="#CCCCCC">will always</font><font color="#E5E5E5"> hold the address the points</font>

79
00:03:04,890 --> 00:03:10,290
to the<font color="#CCCCCC"> top</font><font color="#E5E5E5"> of the current stack frame</font>

80
00:03:06,480 --> 00:03:12,450
our 14 is<font color="#CCCCCC"> the link register which will</font>

81
00:03:10,290 --> 00:03:14,190
hold an address aware code execution

82
00:03:12,450 --> 00:03:16,619
needs<font color="#E5E5E5"> to resume after</font><font color="#CCCCCC"> a function is</font>

83
00:03:14,190 --> 00:03:18,180
returned to<font color="#E5E5E5"> its caller</font><font color="#CCCCCC"> and finally our</font>

84
00:03:16,620 --> 00:03:20,190
15 is<font color="#CCCCCC"> the program counter which will</font>

85
00:03:18,180 --> 00:03:23,730
<font color="#E5E5E5">store the address of the next</font>

86
00:03:20,190 --> 00:03:26,370
instruction to<font color="#E5E5E5"> be</font><font color="#CCCCCC"> executed</font><font color="#E5E5E5"> so on the</font>

87
00:03:23,730 --> 00:03:28,018
<font color="#E5E5E5">other hand we have RB 8 this is the</font><font color="#CCCCCC"> 64</font>

88
00:03:26,370 --> 00:03:31,980
<font color="#CCCCCC">bit version so it's also referred</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> ism</font>

89
00:03:28,019 --> 00:03:34,049
arm 64 and this the<font color="#CCCCCC"> arm VI chips</font><font color="#E5E5E5"> do</font>

90
00:03:31,980 --> 00:03:36,000
actually support a aux 32 for backwards

91
00:03:34,049 --> 00:03:38,370
compatibility<font color="#CCCCCC"> and there's also some</font>

92
00:03:36,000 --> 00:03:40,470
additional<font color="#CCCCCC"> features in arm 64 processors</font>

93
00:03:38,370 --> 00:03:42,690
<font color="#E5E5E5">including the support for exception</font>

94
00:03:40,470 --> 00:03:45,120
levels which is a way of<font color="#E5E5E5"> physically</font>

95
00:03:42,690 --> 00:03:47,160
separating the<font color="#CCCCCC"> execution</font><font color="#E5E5E5"> levels of code</font>

96
00:03:45,120 --> 00:03:49,680
so you<font color="#CCCCCC"> can compare this to something</font>

97
00:03:47,160 --> 00:03:51,269
<font color="#CCCCCC">like</font><font color="#E5E5E5"> ring 0 and ring 1 that sort of</font>

98
00:03:49,680 --> 00:03:55,019
thing but that's beyond<font color="#E5E5E5"> the</font><font color="#CCCCCC"> scope of</font>

99
00:03:51,269 --> 00:03:56,280
<font color="#E5E5E5">this talk</font><font color="#CCCCCC"> where the registers an</font><font color="#E5E5E5"> RB 8 we</font>

100
00:03:55,019 --> 00:03:57,720
have<font color="#CCCCCC"> a different set of registers this</font>

101
00:03:56,280 --> 00:04:00,000
time we have a lot more general-purpose

102
00:03:57,720 --> 00:04:03,989
<font color="#E5E5E5">ones we have 30 so and these are labeled</font>

103
00:04:00,000 --> 00:04:05,940
from X 0<font color="#CCCCCC"> to X 29</font><font color="#E5E5E5"> and you also can</font>

104
00:04:03,989 --> 00:04:08,370
actually refer<font color="#CCCCCC"> to these in a 32-bit</font>

105
00:04:05,940 --> 00:04:10,859
context<font color="#CCCCCC"> if you use a w-2</font><font color="#E5E5E5"> reference</font>

106
00:04:08,370 --> 00:04:12,780
<font color="#E5E5E5">Empire so the W actually</font><font color="#CCCCCC"> obviously will</font>

107
00:04:10,859 --> 00:04:14,849
<font color="#CCCCCC">be in the</font><font color="#E5E5E5"> same register but it will</font>

108
00:04:12,780 --> 00:04:16,769
refer to<font color="#E5E5E5"> as a 32-bit register register</font>

109
00:04:14,849 --> 00:04:19,949
instead<font color="#E5E5E5"> so it will essentially ignore</font>

110
00:04:16,769 --> 00:04:22,320
the<font color="#CCCCCC"> upper</font><font color="#E5E5E5"> 32 bits</font><font color="#CCCCCC"> and again we have the</font>

111
00:04:19,949 --> 00:04:24,599
same free<font color="#E5E5E5"> special purpose registers the</font>

112
00:04:22,320 --> 00:04:25,950
link register<font color="#CCCCCC"> X 13 is</font><font color="#E5E5E5"> done</font>

113
00:04:24,599 --> 00:04:28,020
stack pointer<font color="#E5E5E5"> X 31</font>

114
00:04:25,950 --> 00:04:30,120
and then the program<font color="#CCCCCC"> counter this time</font>

115
00:04:28,020 --> 00:04:33,390
is its own<font color="#E5E5E5"> register that's not actually</font>

116
00:04:30,120 --> 00:04:34,650
directly<font color="#E5E5E5"> modifiable by the programmer so</font>

117
00:04:33,390 --> 00:04:36,630
if you're<font color="#E5E5E5"> writing some</font><font color="#CCCCCC"> armors - oh I'm</font>

118
00:04:34,650 --> 00:04:38,700
64 assembly code<font color="#E5E5E5"> you cannot actually</font>

119
00:04:36,630 --> 00:04:40,320
move a value directly<font color="#E5E5E5"> into the program</font>

120
00:04:38,700 --> 00:04:42,840
<font color="#CCCCCC">Conner you</font><font color="#E5E5E5"> have you can only use the</font>

121
00:04:40,320 --> 00:04:45,690
branch instructions whereas on<font color="#E5E5E5"> rb7 you</font>

122
00:04:42,840 --> 00:04:46,830
can<font color="#CCCCCC"> actually use r15 as a registered</font><font color="#E5E5E5"> to</font>

123
00:04:45,690 --> 00:04:50,940
manipulate<font color="#E5E5E5"> just like you would with</font><font color="#CCCCCC"> any</font>

124
00:04:46,830 --> 00:04:52,380
others so here's a couple<font color="#CCCCCC"> of</font>

125
00:04:50,940 --> 00:04:53,450
illustrations<font color="#E5E5E5"> to demonstrate the</font>

126
00:04:52,380 --> 00:04:55,770
differences between<font color="#E5E5E5"> these</font><font color="#CCCCCC"> two</font>

127
00:04:53,450 --> 00:04:56,940
instruction<font color="#CCCCCC"> sets so</font><font color="#E5E5E5"> you can see there's</font>

128
00:04:55,770 --> 00:04:58,530
<font color="#CCCCCC">an differences in the register names</font>

129
00:04:56,940 --> 00:04:59,850
both these small<font color="#CCCCCC"> functions doing the</font>

130
00:04:58,530 --> 00:05:01,530
same<font color="#E5E5E5"> thing</font>

131
00:04:59,850 --> 00:05:03,900
introduction mnemonics<font color="#E5E5E5"> are going to</font><font color="#CCCCCC"> vary</font>

132
00:05:01,530 --> 00:05:06,659
<font color="#E5E5E5">very slightly and then return</font>

133
00:05:03,900 --> 00:05:08,609
instructions with arm b7<font color="#E5E5E5"> we have a</font>

134
00:05:06,660 --> 00:05:11,730
branch<font color="#CCCCCC"> - the link</font><font color="#E5E5E5"> register instruction</font>

135
00:05:08,610 --> 00:05:15,330
<font color="#CCCCCC">on b8</font><font color="#E5E5E5"> you actually have a ret which is</font>

136
00:05:11,730 --> 00:05:17,040
actually does the same thing some

137
00:05:15,330 --> 00:05:19,440
differences with<font color="#E5E5E5"> these</font><font color="#CCCCCC"> stuck access</font>

138
00:05:17,040 --> 00:05:21,780
instructions<font color="#E5E5E5"> so we're on b7</font><font color="#CCCCCC"> we have a</font>

139
00:05:19,440 --> 00:05:24,270
push which is the kind of classic<font color="#E5E5E5"> stack</font>

140
00:05:21,780 --> 00:05:25,710
access instruction you<font color="#CCCCCC"> know about which</font>

141
00:05:24,270 --> 00:05:27,299
<font color="#E5E5E5">will add items to the top of the stack</font>

142
00:05:25,710 --> 00:05:29,700
so<font color="#CCCCCC"> in this case specified by the</font>

143
00:05:27,300 --> 00:05:31,560
registers on b8 is slightly different

144
00:05:29,700 --> 00:05:33,990
<font color="#E5E5E5">you first of all actually manually</font>

145
00:05:31,560 --> 00:05:35,640
<font color="#CCCCCC">shrink off so it grow the stack by</font>

146
00:05:33,990 --> 00:05:37,470
subtracting a value from<font color="#E5E5E5"> the stack</font>

147
00:05:35,640 --> 00:05:40,140
pointer so this gives stuck some new

148
00:05:37,470 --> 00:05:42,000
space<font color="#E5E5E5"> at the top and then you use an STP</font>

149
00:05:40,140 --> 00:05:44,490
instruction this will store a pair of

150
00:05:42,000 --> 00:05:46,740
registers so in this case X 29<font color="#E5E5E5"> and X 30</font>

151
00:05:44,490 --> 00:05:48,660
at<font color="#E5E5E5"> the address relative to</font><font color="#CCCCCC"> its stack</font>

152
00:05:46,740 --> 00:05:50,970
<font color="#E5E5E5">pointer so it's done in two stages</font>

153
00:05:48,660 --> 00:05:53,310
<font color="#E5E5E5">instead of one and then that same thing</font>

154
00:05:50,970 --> 00:05:55,470
goes for the opposite so<font color="#E5E5E5"> removing items</font>

155
00:05:53,310 --> 00:05:57,660
<font color="#E5E5E5">from the stack and this also ties in</font>

156
00:05:55,470 --> 00:05:59,730
with return from functions so again with

157
00:05:57,660 --> 00:06:01,590
<font color="#E5E5E5">bomb b7 we just have a pop instruction</font>

158
00:05:59,730 --> 00:06:04,800
which pops values from the stack into

159
00:06:01,590 --> 00:06:06,510
<font color="#E5E5E5">the registers and</font><font color="#CCCCCC"> in as I</font><font color="#E5E5E5"> said you can</font>

160
00:06:04,800 --> 00:06:07,830
directly access<font color="#E5E5E5"> the program counter</font><font color="#CCCCCC"> in</font>

161
00:06:06,510 --> 00:06:09,690
<font color="#E5E5E5">our b7 so this would actually be</font>

162
00:06:07,830 --> 00:06:10,800
sufficient enough<font color="#E5E5E5"> to return from a</font>

163
00:06:09,690 --> 00:06:12,719
function you would<font color="#E5E5E5"> have your return</font>

164
00:06:10,800 --> 00:06:14,610
<font color="#CCCCCC">address on</font><font color="#E5E5E5"> the stack and you'd pop it</font>

165
00:06:12,720 --> 00:06:15,660
directly<font color="#E5E5E5"> off into the program counter</font><font color="#CCCCCC"> to</font>

166
00:06:14,610 --> 00:06:18,000
return back<font color="#E5E5E5"> to where you were before</font>

167
00:06:15,660 --> 00:06:21,120
<font color="#E5E5E5">with</font><font color="#CCCCCC"> our</font><font color="#E5E5E5"> b8 this time we have</font><font color="#CCCCCC"> three</font>

168
00:06:18,000 --> 00:06:23,850
<font color="#E5E5E5">instructions so</font><font color="#CCCCCC"> we as an LD P to load a</font>

169
00:06:21,120 --> 00:06:26,970
pair of registers from<font color="#E5E5E5"> the stack</font><font color="#CCCCCC"> so in</font>

170
00:06:23,850 --> 00:06:28,920
this case we<font color="#CCCCCC"> X 29</font><font color="#E5E5E5"> X 30 again then we</font>

171
00:06:26,970 --> 00:06:30,360
manually shrink the stack<font color="#E5E5E5"> by adding a</font>

172
00:06:28,920 --> 00:06:32,640
value<font color="#CCCCCC"> to the</font><font color="#E5E5E5"> stack pointer so it shrinks</font>

173
00:06:30,360 --> 00:06:34,530
<font color="#CCCCCC">it back to</font><font color="#E5E5E5"> its original stars and then</font>

174
00:06:32,640 --> 00:06:36,780
we<font color="#E5E5E5"> return with the rect which actually</font>

175
00:06:34,530 --> 00:06:38,119
branches<font color="#E5E5E5"> to X 30 which we would have</font>

176
00:06:36,780 --> 00:06:42,229
just<font color="#E5E5E5"> loaded</font><font color="#CCCCCC"> with the</font>

177
00:06:38,120 --> 00:06:43,940
LDP<font color="#E5E5E5"> so that's the basics of the</font><font color="#CCCCCC"> ARM</font>

178
00:06:42,229 --> 00:06:46,400
architecture<font color="#CCCCCC"> the other way now when I</font>

179
00:06:43,940 --> 00:06:49,010
<font color="#E5E5E5">talk about the basics of rock or return</font>

180
00:06:46,400 --> 00:06:50,539
oriented programming so Rob stands<font color="#E5E5E5"> for</font>

181
00:06:49,010 --> 00:06:52,490
return<font color="#CCCCCC"> oriented programming and</font><font color="#E5E5E5"> it's a</font>

182
00:06:50,540 --> 00:06:55,880
modern<font color="#E5E5E5"> exploit technique used to execute</font>

183
00:06:52,490 --> 00:06:57,590
<font color="#E5E5E5">a payload and it works</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the basis of a</font>

184
00:06:55,880 --> 00:06:59,960
code reuse attack<font color="#CCCCCC"> so this was originally</font>

185
00:06:57,590 --> 00:07:02,810
<font color="#CCCCCC">designed as an alternative to shellcode</font>

186
00:06:59,960 --> 00:07:05,500
payloads<font color="#E5E5E5"> which is the</font><font color="#CCCCCC"> old-fashioned way</font>

187
00:07:02,810 --> 00:07:07,729
<font color="#CCCCCC">of writing a payload</font><font color="#E5E5E5"> that you may know</font>

188
00:07:05,500 --> 00:07:09,949
<font color="#E5E5E5">this basically</font><font color="#CCCCCC"> involved</font><font color="#E5E5E5"> right in</font><font color="#CCCCCC"> the</font>

189
00:07:07,729 --> 00:07:11,599
actual byte encoding<font color="#E5E5E5"> for several</font>

190
00:07:09,949 --> 00:07:13,760
introductions<font color="#CCCCCC"> to somewhere</font><font color="#E5E5E5"> in the memory</font>

191
00:07:11,600 --> 00:07:15,199
<font color="#CCCCCC">that you</font><font color="#E5E5E5"> control so for example on the</font>

192
00:07:13,760 --> 00:07:17,060
stack or<font color="#E5E5E5"> on the heap an attacker could</font>

193
00:07:15,199 --> 00:07:19,010
write their own instructions and then

194
00:07:17,060 --> 00:07:21,260
they would just<font color="#E5E5E5"> jump to this place in</font>

195
00:07:19,010 --> 00:07:22,669
memory<font color="#E5E5E5"> using their code execution bug</font>

196
00:07:21,260 --> 00:07:24,020
<font color="#CCCCCC">and then they would be able</font><font color="#E5E5E5"> to execute</font>

197
00:07:22,669 --> 00:07:26,330
<font color="#E5E5E5">every stroke whatever introductions they</font>

198
00:07:24,020 --> 00:07:28,090
wanted to obviously<font color="#CCCCCC"> in modern systems</font>

199
00:07:26,330 --> 00:07:30,289
<font color="#E5E5E5">it's actually not possible anymore but</font>

200
00:07:28,090 --> 00:07:32,179
here's the diagram<font color="#CCCCCC"> to kind</font><font color="#E5E5E5"> of illustrate</font>

201
00:07:30,289 --> 00:07:34,400
how that<font color="#CCCCCC"> would work so you can see we</font>

202
00:07:32,180 --> 00:07:36,229
have a stack here<font color="#CCCCCC"> and assuming this is</font>

203
00:07:34,400 --> 00:07:38,630
vulnerable<font color="#CCCCCC"> to a classic kind</font><font color="#E5E5E5"> of stack</font>

204
00:07:36,229 --> 00:07:40,699
buffer overflow vulnerability<font color="#CCCCCC"> you can</font>

205
00:07:38,630 --> 00:07:42,320
see we write lots of<font color="#CCCCCC"> shellcode in the</font>

206
00:07:40,699 --> 00:07:44,360
green there which is the<font color="#E5E5E5"> actual</font>

207
00:07:42,320 --> 00:07:46,070
instructions of byte representation and

208
00:07:44,360 --> 00:07:47,450
<font color="#CCCCCC">we write that down until we get to</font><font color="#E5E5E5"> the</font>

209
00:07:46,070 --> 00:07:49,400
<font color="#E5E5E5">point of the</font><font color="#CCCCCC"> save</font><font color="#E5E5E5"> return address</font><font color="#CCCCCC"> and</font>

210
00:07:47,450 --> 00:07:51,260
then we<font color="#E5E5E5"> just overwrite the save return</font>

211
00:07:49,400 --> 00:07:53,810
address with an address pointing back to

212
00:07:51,260 --> 00:07:55,070
the<font color="#E5E5E5"> start of the shellcode buffer and</font>

213
00:07:53,810 --> 00:07:56,300
then when the function that<font color="#E5E5E5"> you're</font>

214
00:07:55,070 --> 00:07:58,250
currently in returns<font color="#E5E5E5"> it's going to jump</font>

215
00:07:56,300 --> 00:07:59,720
<font color="#CCCCCC">to your</font><font color="#E5E5E5"> shellcode</font><font color="#CCCCCC"> and execute all the</font>

216
00:07:58,250 --> 00:08:01,039
instructions you've<font color="#E5E5E5"> prepared so you can</font>

217
00:07:59,720 --> 00:08:03,530
essentially execute arbitrary<font color="#E5E5E5"> code on</font>

218
00:08:01,039 --> 00:08:04,460
<font color="#CCCCCC">your and your</font><font color="#E5E5E5"> target process but as I</font>

219
00:08:03,530 --> 00:08:06,200
<font color="#CCCCCC">said it's not</font><font color="#E5E5E5"> long it's no longer</font>

220
00:08:04,460 --> 00:08:08,630
<font color="#E5E5E5">possible because we have basic forms of</font>

221
00:08:06,200 --> 00:08:10,580
data execution prevention which

222
00:08:08,630 --> 00:08:12,320
essentially<font color="#E5E5E5"> means that the stack and</font>

223
00:08:10,580 --> 00:08:13,669
<font color="#CCCCCC">heap memory</font><font color="#E5E5E5"> you cannot execute anything</font>

224
00:08:12,320 --> 00:08:16,099
<font color="#E5E5E5">from there because it's considered data</font>

225
00:08:13,669 --> 00:08:17,419
so you can<font color="#E5E5E5"> only execute code that's in</font>

226
00:08:16,099 --> 00:08:21,020
the<font color="#CCCCCC"> actual text segment</font><font color="#E5E5E5"> of the binary</font>

227
00:08:17,419 --> 00:08:22,760
<font color="#E5E5E5">where the</font><font color="#CCCCCC"> GRU instructions will be so</font>

228
00:08:21,020 --> 00:08:24,440
<font color="#CCCCCC">Rach obviously provides the workaround</font>

229
00:08:22,760 --> 00:08:25,729
to<font color="#E5E5E5"> that because</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> uses real</font>

230
00:08:24,440 --> 00:08:27,560
<font color="#E5E5E5">instructions that are actually in the</font>

231
00:08:25,729 --> 00:08:29,419
code segment<font color="#E5E5E5"> but it just uses them in a</font>

232
00:08:27,560 --> 00:08:31,789
different<font color="#E5E5E5"> order essentially so it's kind</font>

233
00:08:29,419 --> 00:08:33,468
of like piecing together<font color="#CCCCCC"> parts of</font><font color="#E5E5E5"> the</font>

234
00:08:31,789 --> 00:08:35,870
code in<font color="#CCCCCC"> your own</font><font color="#E5E5E5"> order so you just take</font>

235
00:08:33,469 --> 00:08:37,250
pieces from<font color="#CCCCCC"> different functions</font><font color="#E5E5E5"> connect</font>

236
00:08:35,870 --> 00:08:38,659
them<font color="#E5E5E5"> together in order</font><font color="#CCCCCC"> that achieves an</font>

237
00:08:37,250 --> 00:08:40,940
outcome<font color="#CCCCCC"> you</font><font color="#E5E5E5"> want and that's how you can</font>

238
00:08:38,659 --> 00:08:44,150
stock the payload with<font color="#CCCCCC"> Rob</font><font color="#E5E5E5"> so you</font>

239
00:08:40,940 --> 00:08:46,850
<font color="#CCCCCC">actually use gadgets</font><font color="#E5E5E5"> which are these are</font>

240
00:08:44,150 --> 00:08:48,949
short sequences of instructions<font color="#E5E5E5"> that</font><font color="#CCCCCC"> end</font>

241
00:08:46,850 --> 00:08:50,690
with a return instruction<font color="#CCCCCC"> and this</font>

242
00:08:48,950 --> 00:08:51,800
return instruction is<font color="#CCCCCC"> the vital part</font>

243
00:08:50,690 --> 00:08:53,899
that allows you to<font color="#E5E5E5"> actually</font>

244
00:08:51,800 --> 00:08:56,179
<font color="#E5E5E5">chained together several pieces of code</font>

245
00:08:53,899 --> 00:08:58,459
<font color="#E5E5E5">to then execute a full chain</font><font color="#CCCCCC"> before</font>

246
00:08:56,179 --> 00:08:59,869
<font color="#CCCCCC">train payload now</font><font color="#E5E5E5"> these gadgets are</font>

247
00:08:58,459 --> 00:09:02,479
obviously<font color="#E5E5E5"> found within the</font><font color="#CCCCCC"> tech</font><font color="#E5E5E5"> segment</font>

248
00:08:59,869 --> 00:09:04,399
<font color="#E5E5E5">or</font><font color="#CCCCCC"> the actual</font><font color="#E5E5E5"> binary the executable</font>

249
00:09:02,480 --> 00:09:05,779
<font color="#E5E5E5">segment and they're normally found at</font>

250
00:09:04,399 --> 00:09:07,220
the end of a function because<font color="#E5E5E5"> obviously</font>

251
00:09:05,779 --> 00:09:08,540
<font color="#E5E5E5">they end in the return and that's where</font>

252
00:09:07,220 --> 00:09:13,850
you that's where you'd normally find

253
00:09:08,540 --> 00:09:16,399
<font color="#E5E5E5">them so this is</font><font color="#CCCCCC"> an example of one gadget</font>

254
00:09:13,850 --> 00:09:18,769
<font color="#E5E5E5">you might find</font><font color="#CCCCCC"> four</font><font color="#E5E5E5"> on the arm 64</font>

255
00:09:16,399 --> 00:09:20,749
<font color="#CCCCCC">architecture you can</font><font color="#E5E5E5"> see it consists of</font>

256
00:09:18,769 --> 00:09:23,299
<font color="#CCCCCC">three instructions</font><font color="#E5E5E5"> the first one is an</font>

257
00:09:20,749 --> 00:09:26,779
STR<font color="#E5E5E5"> instruction and this in this case it</font>

258
00:09:23,299 --> 00:09:28,819
stores the value of a register<font color="#E5E5E5"> to memory</font>

259
00:09:26,779 --> 00:09:30,290
location so in this case it stores

260
00:09:28,819 --> 00:09:33,170
whatever data is currently<font color="#E5E5E5"> hold inside</font>

261
00:09:30,290 --> 00:09:37,160
of x0<font color="#E5E5E5"> and it store that where wherever</font>

262
00:09:33,170 --> 00:09:39,769
<font color="#E5E5E5">x1 points to so for example an attacker</font>

263
00:09:37,160 --> 00:09:42,019
<font color="#E5E5E5">if they can already control x0 and x1</font>

264
00:09:39,769 --> 00:09:43,699
<font color="#E5E5E5">beforehand they have using this gadget</font>

265
00:09:42,019 --> 00:09:45,920
<font color="#E5E5E5">an arbitrary</font><font color="#CCCCCC"> right primitive</font><font color="#E5E5E5"> because</font>

266
00:09:43,699 --> 00:09:47,209
they can patch any error of the process

267
00:09:45,920 --> 00:09:48,439
<font color="#CCCCCC">memory by setting up</font><font color="#E5E5E5"> these</font><font color="#CCCCCC"> values</font>

268
00:09:47,209 --> 00:09:51,319
beforehand and then jump<font color="#CCCCCC"> into this</font>

269
00:09:48,439 --> 00:09:52,819
gadget<font color="#CCCCCC"> so that's what</font><font color="#E5E5E5"> might use this the</font>

270
00:09:51,319 --> 00:09:54,439
next<font color="#CCCCCC"> two instructions in</font><font color="#E5E5E5"> the gadget are</font>

271
00:09:52,819 --> 00:09:55,998
not actually<font color="#E5E5E5"> really part of the gadget</font>

272
00:09:54,439 --> 00:09:58,399
they're just the return<font color="#CCCCCC"> instruction so</font>

273
00:09:55,999 --> 00:10:00,379
on<font color="#CCCCCC"> tom be an RBA you have the two</font><font color="#E5E5E5"> two</font>

274
00:09:58,399 --> 00:10:01,549
instructions to return so again loading

275
00:10:00,379 --> 00:10:02,480
the<font color="#CCCCCC"> parent registers</font><font color="#E5E5E5"> and then branch</font>

276
00:10:01,549 --> 00:10:05,149
into<font color="#CCCCCC"> x30</font>

277
00:10:02,480 --> 00:10:06,679
so but<font color="#E5E5E5"> this the STR instruction is the</font>

278
00:10:05,149 --> 00:10:11,119
only<font color="#E5E5E5"> real desired instructions in this</font>

279
00:10:06,679 --> 00:10:12,949
gadget so<font color="#E5E5E5"> gadget services chained as I</font>

280
00:10:11,119 --> 00:10:14,869
mentioned with the<font color="#E5E5E5"> return instructions</font>

281
00:10:12,949 --> 00:10:16,099
and this works essentially by placing

282
00:10:14,869 --> 00:10:18,259
all<font color="#E5E5E5"> the gadget addresses that you want</font>

283
00:10:16,100 --> 00:10:20,660
to execute<font color="#E5E5E5"> in a chronological order on</font>

284
00:10:18,259 --> 00:10:23,089
the stack going downwards<font color="#E5E5E5"> and then every</font>

285
00:10:20,660 --> 00:10:24,439
return instruction<font color="#CCCCCC"> is</font><font color="#E5E5E5"> going to get the</font>

286
00:10:23,089 --> 00:10:26,059
<font color="#E5E5E5">next address from the top of the stack</font>

287
00:10:24,439 --> 00:10:27,618
because<font color="#CCCCCC"> that's how returning normally</font>

288
00:10:26,059 --> 00:10:29,149
works with<font color="#CCCCCC"> function</font><font color="#E5E5E5"> so it was extremely</font>

289
00:10:27,619 --> 00:10:31,009
address to return<font color="#E5E5E5"> to will be on the</font>

290
00:10:29,149 --> 00:10:31,879
stack and therefore it's going<font color="#E5E5E5"> to</font>

291
00:10:31,009 --> 00:10:33,290
essentially go through your whole

292
00:10:31,879 --> 00:10:36,439
payload jump into<font color="#E5E5E5"> these</font><font color="#CCCCCC"> different</font>

293
00:10:33,290 --> 00:10:38,299
locations<font color="#E5E5E5"> in code so</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> diagram kind</font>

294
00:10:36,439 --> 00:10:39,410
of represents<font color="#E5E5E5"> that so again</font><font color="#CCCCCC"> if we have a</font>

295
00:10:38,299 --> 00:10:40,160
stack<font color="#CCCCCC"> with</font><font color="#E5E5E5"> a buffer overflow</font>

296
00:10:39,410 --> 00:10:42,410
vulnerability

297
00:10:40,160 --> 00:10:43,910
<font color="#E5E5E5">this time we fill it up with some junk</font>

298
00:10:42,410 --> 00:10:46,879
<font color="#E5E5E5">not the</font><font color="#CCCCCC"> shellcode so in the green</font><font color="#E5E5E5"> is</font>

299
00:10:43,910 --> 00:10:48,439
<font color="#CCCCCC">just some junk data</font><font color="#E5E5E5"> then we get to the</font>

300
00:10:46,879 --> 00:10:50,299
point<font color="#CCCCCC"> of the safe return address</font><font color="#E5E5E5"> and</font>

301
00:10:48,439 --> 00:10:52,129
then this time we overwrite that<font color="#E5E5E5"> with</font>

302
00:10:50,299 --> 00:10:53,779
the address<font color="#E5E5E5"> point into somewhere</font><font color="#CCCCCC"> in the</font>

303
00:10:52,129 --> 00:10:55,459
<font color="#E5E5E5">code segment so you can see how</font><font color="#CCCCCC"> very</font>

304
00:10:53,779 --> 00:10:57,259
points<font color="#CCCCCC"> fall it the gray arrow it points</font>

305
00:10:55,459 --> 00:10:59,660
to some gadget<font color="#CCCCCC"> it doesn't matter what it</font>

306
00:10:57,259 --> 00:11:00,709
is<font color="#CCCCCC"> but it points</font><font color="#E5E5E5"> to some gadget then all</font>

307
00:10:59,660 --> 00:11:02,569
of the other gadgets<font color="#CCCCCC"> that we want to</font>

308
00:11:00,709 --> 00:11:04,459
<font color="#E5E5E5">execute after that we just place them</font>

309
00:11:02,569 --> 00:11:04,839
continuously going down the stack in the

310
00:11:04,459 --> 00:11:07,420
<font color="#E5E5E5">Chrome</font>

311
00:11:04,840 --> 00:11:09,010
and what happens is when<font color="#E5E5E5"> the function</font>

312
00:11:07,420 --> 00:11:10,660
<font color="#CCCCCC">returns</font><font color="#E5E5E5"> it's going to jump to</font><font color="#CCCCCC"> your first</font>

313
00:11:09,010 --> 00:11:12,100
gadget<font color="#E5E5E5"> which obviously can execute</font>

314
00:11:10,660 --> 00:11:13,630
<font color="#E5E5E5">because</font><font color="#CCCCCC"> it's in the real code segment</font>

315
00:11:12,100 --> 00:11:15,130
that gadgets going<font color="#E5E5E5"> to return which is</font>

316
00:11:13,630 --> 00:11:17,290
<font color="#E5E5E5">going to follow the blue</font><font color="#CCCCCC"> line back down</font>

317
00:11:15,130 --> 00:11:18,790
<font color="#E5E5E5">go to your next</font><font color="#CCCCCC"> gadget and</font><font color="#E5E5E5"> so on this</font>

318
00:11:17,290 --> 00:11:21,160
<font color="#E5E5E5">will keep going</font><font color="#CCCCCC"> on depending</font><font color="#E5E5E5"> on how many</font>

319
00:11:18,790 --> 00:11:24,969
<font color="#E5E5E5">goats you've set up and that's how you</font>

320
00:11:21,160 --> 00:11:26,829
execute a full payload and yet so the

321
00:11:24,970 --> 00:11:29,950
<font color="#CCCCCC">rep's is what allows them to</font><font color="#E5E5E5"> you jump to</font>

322
00:11:26,830 --> 00:11:32,320
<font color="#E5E5E5">the next gadget so to actually find</font>

323
00:11:29,950 --> 00:11:33,340
gadgets<font color="#CCCCCC"> you obviously have to work with</font>

324
00:11:32,320 --> 00:11:34,840
what you've<font color="#CCCCCC"> got in the</font><font color="#E5E5E5"> binary so you</font>

325
00:11:33,340 --> 00:11:36,220
need to be able<font color="#E5E5E5"> to use have an efficient</font>

326
00:11:34,840 --> 00:11:37,750
way<font color="#CCCCCC"> to go to</font><font color="#E5E5E5"> actually scan the binary so</font>

327
00:11:36,220 --> 00:11:39,760
there's a lot of tools<font color="#E5E5E5"> out there</font><font color="#CCCCCC"> that</font>

328
00:11:37,750 --> 00:11:42,520
<font color="#E5E5E5">will allow</font><font color="#CCCCCC"> you to</font><font color="#E5E5E5"> search the binary for</font>

329
00:11:39,760 --> 00:11:44,439
gadgets<font color="#CCCCCC"> so</font><font color="#E5E5E5"> essentially it works by</font>

330
00:11:42,520 --> 00:11:46,390
scanning<font color="#E5E5E5"> the whole binary for return</font>

331
00:11:44,440 --> 00:11:47,620
instructions<font color="#E5E5E5"> first of all and then when</font>

332
00:11:46,390 --> 00:11:49,930
you find a return instruction<font color="#CCCCCC"> you just</font>

333
00:11:47,620 --> 00:11:50,950
search backwards<font color="#CCCCCC"> in</font><font color="#E5E5E5"> for byte chunks</font><font color="#CCCCCC"> to</font>

334
00:11:49,930 --> 00:11:53,290
look at the<font color="#E5E5E5"> instructions</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> come</font>

335
00:11:50,950 --> 00:11:54,550
before it<font color="#E5E5E5"> and then obviously if you find</font>

336
00:11:53,290 --> 00:11:56,620
an instruction before<font color="#CCCCCC"> it that is useful</font>

337
00:11:54,550 --> 00:11:57,819
<font color="#E5E5E5">to</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> in your specific case then you</font>

338
00:11:56,620 --> 00:12:00,940
can<font color="#E5E5E5"> note down</font><font color="#CCCCCC"> the address</font><font color="#E5E5E5"> of that gadget</font>

339
00:11:57,820 --> 00:12:02,110
<font color="#E5E5E5">and use that in your payload</font><font color="#CCCCCC"> and there's</font>

340
00:12:00,940 --> 00:12:03,700
<font color="#CCCCCC">obviously a lot of tools that online</font>

341
00:12:02,110 --> 00:12:05,860
available that<font color="#E5E5E5"> will do this for you so</font>

342
00:12:03,700 --> 00:12:10,240
there's a there's a<font color="#CCCCCC"> couple examples</font>

343
00:12:05,860 --> 00:12:12,820
there<font color="#CCCCCC"> which</font><font color="#E5E5E5"> you want to check out so</font>

344
00:12:10,240 --> 00:12:14,500
when executing a complex<font color="#CCCCCC"> Rob chain or a</font>

345
00:12:12,820 --> 00:12:17,230
rope chain involving a lot of<font color="#CCCCCC"> gadgets</font>

346
00:12:14,500 --> 00:12:19,930
<font color="#CCCCCC">there's</font><font color="#E5E5E5"> often a problem that you may</font><font color="#CCCCCC"> run</font>

347
00:12:17,230 --> 00:12:21,190
<font color="#CCCCCC">into because this obviously very common</font>

348
00:12:19,930 --> 00:12:23,079
occurrence if you're<font color="#E5E5E5"> working with a real</font>

349
00:12:21,190 --> 00:12:26,170
<font color="#CCCCCC">world exploit so for example if your tug</font>

350
00:12:23,080 --> 00:12:28,110
in a kernel vulnerability<font color="#E5E5E5"> for example in</font>

351
00:12:26,170 --> 00:12:30,339
the iOS kernel and<font color="#E5E5E5"> the Android kernel</font>

352
00:12:28,110 --> 00:12:31,690
often the goal<font color="#E5E5E5"> would be to use</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> kind</font>

353
00:12:30,340 --> 00:12:33,550
<font color="#E5E5E5">of owner ability to obtain code</font>

354
00:12:31,690 --> 00:12:35,410
<font color="#E5E5E5">execution and then actually patch out</font>

355
00:12:33,550 --> 00:12:36,790
<font color="#E5E5E5">security measures that</font><font color="#CCCCCC"> allow you to use</font>

356
00:12:35,410 --> 00:12:38,050
a device<font color="#E5E5E5"> in a different way now this is</font>

357
00:12:36,790 --> 00:12:39,280
not going<font color="#E5E5E5"> to be done</font><font color="#CCCCCC"> with a</font><font color="#E5E5E5"> single</font>

358
00:12:38,050 --> 00:12:40,630
gadget you're also going to need<font color="#E5E5E5"> a lot</font>

359
00:12:39,280 --> 00:12:43,180
of<font color="#E5E5E5"> preparation a lot of different</font>

360
00:12:40,630 --> 00:12:44,890
patches<font color="#E5E5E5"> being applied and in some cases</font>

361
00:12:43,180 --> 00:12:47,739
you may<font color="#CCCCCC"> need several hundreds of gadgets</font>

362
00:12:44,890 --> 00:12:49,990
to actually achieve the outcome now

363
00:12:47,740 --> 00:12:51,520
there is a problem<font color="#E5E5E5"> with that which it</font>

364
00:12:49,990 --> 00:12:54,310
will arise if you're working<font color="#CCCCCC"> with</font><font color="#E5E5E5"> modern</font>

365
00:12:51,520 --> 00:12:57,130
bugs<font color="#E5E5E5"> particularly ones based around the</font>

366
00:12:54,310 --> 00:12:58,359
heap<font color="#CCCCCC"> so the majority of bugs found</font><font color="#E5E5E5"> in</font>

367
00:12:57,130 --> 00:13:00,610
<font color="#E5E5E5">modern systems</font><font color="#CCCCCC"> today</font><font color="#E5E5E5"> at least</font><font color="#CCCCCC"> at what</font>

368
00:12:58,360 --> 00:13:03,040
I've studied and<font color="#CCCCCC"> what I've</font><font color="#E5E5E5"> seen are heap</font>

369
00:13:00,610 --> 00:13:04,960
related bug so for example heap

370
00:13:03,040 --> 00:13:06,520
overflows or<font color="#E5E5E5"> more complicated</font><font color="#CCCCCC"> one such</font>

371
00:13:04,960 --> 00:13:08,740
<font color="#E5E5E5">as used after freeze or double freeze</font>

372
00:13:06,520 --> 00:13:10,329
<font color="#E5E5E5">these are the ones that</font><font color="#CCCCCC"> most people are</font>

373
00:13:08,740 --> 00:13:12,550
most commonly<font color="#E5E5E5"> found in modern</font><font color="#CCCCCC"> systems</font>

374
00:13:10,330 --> 00:13:14,050
<font color="#E5E5E5">today and obviously a lot</font><font color="#CCCCCC"> of these that</font>

375
00:13:12,550 --> 00:13:16,180
every every vulnerability is different

376
00:13:14,050 --> 00:13:17,750
<font color="#E5E5E5">so in a certain way it can occur</font><font color="#CCCCCC"> you may</font>

377
00:13:16,180 --> 00:13:18,680
be limited<font color="#CCCCCC"> to the amount of gadgets</font>

378
00:13:17,750 --> 00:13:20,930
you can actually you can<font color="#E5E5E5"> actually</font>

379
00:13:18,680 --> 00:13:22,939
execute<font color="#E5E5E5"> and this is because if you don't</font>

380
00:13:20,930 --> 00:13:24,229
<font color="#E5E5E5">actually have access to</font><font color="#CCCCCC"> the stack</font><font color="#E5E5E5"> like</font><font color="#CCCCCC"> I</font>

381
00:13:22,940 --> 00:13:25,400
just<font color="#E5E5E5"> showed</font><font color="#CCCCCC"> with the demo before</font><font color="#E5E5E5"> if</font>

382
00:13:24,230 --> 00:13:27,440
you're<font color="#E5E5E5"> not</font><font color="#CCCCCC"> working with a stack well</font>

383
00:13:25,400 --> 00:13:28,819
<font color="#E5E5E5">over flip run</font><font color="#CCCCCC"> ability then you have no</font>

384
00:13:27,440 --> 00:13:30,860
<font color="#CCCCCC">Falken</font><font color="#E5E5E5"> you have no controller with a</font>

385
00:13:28,820 --> 00:13:32,510
<font color="#CCCCCC">dater on the stack</font><font color="#E5E5E5"> so if you have your</font>

386
00:13:30,860 --> 00:13:34,400
<font color="#E5E5E5">heap overflow</font><font color="#CCCCCC"> then you trigger your bug</font>

387
00:13:32,510 --> 00:13:36,170
<font color="#E5E5E5">jump your first gadget when that gadget</font>

388
00:13:34,400 --> 00:13:37,490
tries to return<font color="#E5E5E5"> it's going to be</font>

389
00:13:36,170 --> 00:13:39,740
returning to the stack<font color="#E5E5E5"> because that's</font>

390
00:13:37,490 --> 00:13:40,790
how<font color="#E5E5E5"> that's done and therefore you're</font><font color="#CCCCCC"> not</font>

391
00:13:39,740 --> 00:13:42,110
<font color="#CCCCCC">going to have any dater on the stack</font>

392
00:13:40,790 --> 00:13:44,240
that<font color="#CCCCCC"> you</font><font color="#E5E5E5"> control so you can only execute</font>

393
00:13:42,110 --> 00:13:47,030
<font color="#E5E5E5">one</font><font color="#CCCCCC"> gadget before the program is</font>

394
00:13:44,240 --> 00:13:49,190
<font color="#E5E5E5">terminates so the solution to this is</font>

395
00:13:47,030 --> 00:13:51,650
<font color="#E5E5E5">using a technique known as stack</font>

396
00:13:49,190 --> 00:13:53,030
<font color="#CCCCCC">pivoting which is a technique</font><font color="#E5E5E5"> that</font>

397
00:13:51,650 --> 00:13:55,250
<font color="#CCCCCC">allows</font><font color="#E5E5E5"> you to</font><font color="#CCCCCC"> basically</font><font color="#E5E5E5"> create your</font><font color="#CCCCCC"> own</font>

398
00:13:53,030 --> 00:13:58,160
fake stack with data<font color="#E5E5E5"> that you fully</font>

399
00:13:55,250 --> 00:14:00,410
control and you do this by<font color="#CCCCCC"> basically</font>

400
00:13:58,160 --> 00:14:01,939
modifying the stack pointer register<font color="#CCCCCC"> and</font>

401
00:14:00,410 --> 00:14:04,219
making it point<font color="#CCCCCC"> to a new</font><font color="#E5E5E5"> location in</font>

402
00:14:01,940 --> 00:14:05,450
<font color="#CCCCCC">memory and</font><font color="#E5E5E5"> in this memory it's populated</font>

403
00:14:04,220 --> 00:14:07,490
with your<font color="#CCCCCC"> octane or your</font><font color="#E5E5E5"> gadget</font>

404
00:14:05,450 --> 00:14:09,140
addresses and then you redirect code

405
00:14:07,490 --> 00:14:11,300
execution to your first gadget and<font color="#E5E5E5"> then</font>

406
00:14:09,140 --> 00:14:13,130
when it returns<font color="#E5E5E5"> instead of going to the</font>

407
00:14:11,300 --> 00:14:14,750
real stack it's going to be using your

408
00:14:13,130 --> 00:14:16,760
fake stack which is<font color="#E5E5E5"> obviously</font><font color="#CCCCCC"> called at</font>

409
00:14:14,750 --> 00:14:18,590
you control so it's<font color="#E5E5E5"> going to go through</font>

410
00:14:16,760 --> 00:14:20,000
your gadget chain just<font color="#E5E5E5"> as normal</font><font color="#CCCCCC"> as if</font>

411
00:14:18,590 --> 00:14:22,850
you did have full control<font color="#CCCCCC"> over</font><font color="#E5E5E5"> the real</font>

412
00:14:20,000 --> 00:14:24,680
stack so I'm going<font color="#E5E5E5"> to explain kind of</font>

413
00:14:22,850 --> 00:14:27,110
<font color="#CCCCCC">how this works</font><font color="#E5E5E5"> exactly but first of all</font>

414
00:14:24,680 --> 00:14:29,630
for those of you who are a bit<font color="#E5E5E5"> more</font>

415
00:14:27,110 --> 00:14:31,910
<font color="#E5E5E5">about the stack itself</font><font color="#CCCCCC"> in most computer</font>

416
00:14:29,630 --> 00:14:34,700
science classes you'd be told that<font color="#E5E5E5"> the</font>

417
00:14:31,910 --> 00:14:36,800
stack is a last in first out data

418
00:14:34,700 --> 00:14:38,810
structure<font color="#CCCCCC"> and you essentially treat it</font>

419
00:14:36,800 --> 00:14:41,719
as a physical<font color="#E5E5E5"> stack of items so you can</font>

420
00:14:38,810 --> 00:14:43,010
<font color="#E5E5E5">add an item to</font><font color="#CCCCCC"> the top</font><font color="#E5E5E5"> by pushing it and</font>

421
00:14:41,720 --> 00:14:45,350
<font color="#CCCCCC">then you can</font><font color="#E5E5E5"> remove an item from the top</font>

422
00:14:43,010 --> 00:14:46,700
by popping it so this<font color="#E5E5E5"> is essentially</font>

423
00:14:45,350 --> 00:14:47,810
like<font color="#E5E5E5"> a stack of place you can always you</font>

424
00:14:46,700 --> 00:14:49,610
can add one to the<font color="#E5E5E5"> top and remove one</font>

425
00:14:47,810 --> 00:14:51,949
<font color="#CCCCCC">from the top obviously this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> just a</font>

426
00:14:49,610 --> 00:14:54,589
theoretical<font color="#CCCCCC"> model of it and the actual</font>

427
00:14:51,950 --> 00:14:56,450
way this works is<font color="#E5E5E5"> a lot different</font><font color="#CCCCCC"> in in</font>

428
00:14:54,589 --> 00:14:58,580
low-level memory in terms<font color="#CCCCCC"> of how the</font>

429
00:14:56,450 --> 00:14:59,990
binary<font color="#CCCCCC"> would execute the stack is just</font>

430
00:14:58,580 --> 00:15:01,880
an area<font color="#CCCCCC"> of</font><font color="#E5E5E5"> memory and the only thing</font>

431
00:14:59,990 --> 00:15:05,630
that makes<font color="#E5E5E5"> it the stack is the fact that</font>

432
00:15:01,880 --> 00:15:07,730
<font color="#CCCCCC">a stack pointer points to</font><font color="#E5E5E5"> it so for</font>

433
00:15:05,630 --> 00:15:09,200
example this<font color="#E5E5E5"> is just</font><font color="#CCCCCC"> a block</font><font color="#E5E5E5"> of memory</font>

434
00:15:07,730 --> 00:15:12,170
here<font color="#E5E5E5"> and you can see I've got the stack</font>

435
00:15:09,200 --> 00:15:14,120
pointer up there<font color="#E5E5E5"> set to address 1 0 and</font>

436
00:15:12,170 --> 00:15:15,530
that red arrow represents that<font color="#E5E5E5"> so this</font>

437
00:15:14,120 --> 00:15:17,690
<font color="#E5E5E5">is currently considered as the top of</font>

438
00:15:15,530 --> 00:15:18,980
the stack and it's<font color="#E5E5E5"> only considered that</font>

439
00:15:17,690 --> 00:15:21,410
because of the pointer<font color="#CCCCCC"> of the stack</font>

440
00:15:18,980 --> 00:15:23,540
pointer value<font color="#E5E5E5"> so you can see the date on</font>

441
00:15:21,410 --> 00:15:25,579
the stack it's 4 1<font color="#E5E5E5"> 4 1 4 1 is the top</font>

442
00:15:23,540 --> 00:15:27,500
<font color="#E5E5E5">item so if you wanted to remove this</font>

443
00:15:25,580 --> 00:15:30,050
<font color="#CCCCCC">item from</font><font color="#E5E5E5"> the stack</font><font color="#CCCCCC"> you would</font><font color="#E5E5E5"> execute a</font>

444
00:15:27,500 --> 00:15:30,950
pop instruction and the weight<font color="#CCCCCC"> is</font>

445
00:15:30,050 --> 00:15:33,290
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> X</font>

446
00:15:30,950 --> 00:15:34,940
<font color="#E5E5E5">in the low level is all that's happening</font>

447
00:15:33,290 --> 00:15:37,279
<font color="#E5E5E5">as you're stuck pointer value is being</font>

448
00:15:34,940 --> 00:15:39,620
incremented by<font color="#CCCCCC"> four</font><font color="#E5E5E5"> for every value you</font>

449
00:15:37,279 --> 00:15:41,240
<font color="#E5E5E5">want to pop so you incremented by four</font>

450
00:15:39,620 --> 00:15:43,519
the stack pointer now points to

451
00:15:41,240 --> 00:15:44,779
<font color="#CCCCCC">somewhere higher in memory but lower</font>

452
00:15:43,519 --> 00:15:46,279
down the stack because<font color="#CCCCCC"> the stack grows</font>

453
00:15:44,779 --> 00:15:47,839
<font color="#CCCCCC">in</font><font color="#E5E5E5"> the opposite way</font><font color="#CCCCCC"> to me to what you</font>

454
00:15:46,279 --> 00:15:50,389
may<font color="#CCCCCC"> think it grows towards the lower</font>

455
00:15:47,839 --> 00:15:52,519
addresses<font color="#CCCCCC"> and therefore</font><font color="#E5E5E5"> now you're stuck</font>

456
00:15:50,389 --> 00:15:54,440
is one item shorter<font color="#CCCCCC"> no data is actually</font>

457
00:15:52,519 --> 00:15:56,570
changed in terms<font color="#E5E5E5"> of the memory but your</font>

458
00:15:54,440 --> 00:15:58,670
pointer is pointing one higher in memory

459
00:15:56,570 --> 00:16:01,910
so this<font color="#E5E5E5"> is considered the</font><font color="#CCCCCC"> new top of</font><font color="#E5E5E5"> the</font>

460
00:15:58,670 --> 00:16:03,229
stack<font color="#CCCCCC"> and you can see the data</font><font color="#E5E5E5"> actually</font>

461
00:16:01,910 --> 00:16:04,760
remains in the memory<font color="#E5E5E5"> because it doesn't</font>

462
00:16:03,230 --> 00:16:06,199
<font color="#E5E5E5">doesn't really matter if it's there</font><font color="#CCCCCC"> or</font>

463
00:16:04,760 --> 00:16:09,620
not<font color="#E5E5E5"> it's no longer considered part of</font>

464
00:16:06,199 --> 00:16:11,839
the stack<font color="#CCCCCC"> and</font><font color="#E5E5E5"> same thing</font><font color="#CCCCCC"> goes for</font>

465
00:16:09,620 --> 00:16:13,430
pushing<font color="#E5E5E5"> so in this case it's the</font>

466
00:16:11,839 --> 00:16:17,060
opposite so you would decrement<font color="#E5E5E5"> the</font>

467
00:16:13,430 --> 00:16:18,829
stack pointer<font color="#E5E5E5"> to grow it</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> up to here</font>

468
00:16:17,060 --> 00:16:22,819
<font color="#CCCCCC">and</font><font color="#E5E5E5"> then you write</font><font color="#CCCCCC"> your new data to this</font>

469
00:16:18,829 --> 00:16:24,109
new location<font color="#CCCCCC"> here and</font><font color="#E5E5E5"> then your new item</font>

470
00:16:22,820 --> 00:16:27,920
<font color="#CCCCCC">has been</font><font color="#E5E5E5"> added</font><font color="#CCCCCC"> to the top of the stack</font>

471
00:16:24,110 --> 00:16:29,600
<font color="#CCCCCC">so with this knowledge you</font><font color="#E5E5E5"> can now see</font>

472
00:16:27,920 --> 00:16:31,040
how<font color="#CCCCCC"> I stack pivot would work so let's</font>

473
00:16:29,600 --> 00:16:33,980
assume this<font color="#E5E5E5"> is the whole process memory</font>

474
00:16:31,040 --> 00:16:35,660
for<font color="#E5E5E5"> a target program and down here this</font>

475
00:16:33,980 --> 00:16:37,279
section<font color="#E5E5E5"> here is reserved for the stack</font>

476
00:16:35,660 --> 00:16:38,779
so<font color="#CCCCCC"> you have the stack base and then</font>

477
00:16:37,279 --> 00:16:40,430
everything in between<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the stack and</font>

478
00:16:38,779 --> 00:16:42,470
<font color="#E5E5E5">in the stack pointer</font><font color="#CCCCCC"> which is the top of</font>

479
00:16:40,430 --> 00:16:43,910
<font color="#E5E5E5">the stack now if you have some other</font>

480
00:16:42,470 --> 00:16:45,800
block of memory somewhere else<font color="#E5E5E5"> which you</font>

481
00:16:43,910 --> 00:16:47,959
<font color="#CCCCCC">controls</font><font color="#E5E5E5"> if you work with</font><font color="#CCCCCC"> a heap heap</font>

482
00:16:45,800 --> 00:16:50,689
<font color="#CCCCCC">relate bug</font><font color="#E5E5E5"> let's say we have a heap</font>

483
00:16:47,959 --> 00:16:51,979
memory here with our fake<font color="#E5E5E5"> rock stuck in</font>

484
00:16:50,690 --> 00:16:53,390
so we<font color="#CCCCCC"> fully</font><font color="#E5E5E5"> controlled this memory we</font>

485
00:16:51,980 --> 00:16:56,149
let we lay this out<font color="#CCCCCC"> about gadget</font>

486
00:16:53,390 --> 00:16:58,100
addresses and all we need<font color="#CCCCCC"> to do to</font>

487
00:16:56,149 --> 00:17:00,529
<font color="#CCCCCC">actually achieve the stack pivot is to</font>

488
00:16:58,100 --> 00:17:02,500
<font color="#E5E5E5">somehow move the stack pointer so it</font>

489
00:17:00,529 --> 00:17:04,819
<font color="#E5E5E5">points to the start of this heap memory</font>

490
00:17:02,500 --> 00:17:06,199
<font color="#E5E5E5">so when it points here the</font><font color="#CCCCCC"> program's not</font>

491
00:17:04,819 --> 00:17:07,579
<font color="#E5E5E5">going to know any different it just</font>

492
00:17:06,199 --> 00:17:09,439
treats the stack as whatever<font color="#E5E5E5"> this</font>

493
00:17:07,579 --> 00:17:10,790
pointer points<font color="#CCCCCC"> to</font><font color="#E5E5E5"> and therefore</font><font color="#CCCCCC"> this</font>

494
00:17:09,439 --> 00:17:13,280
whole<font color="#E5E5E5"> block is essentially going to be</font>

495
00:17:10,790 --> 00:17:14,839
treated as a stack<font color="#E5E5E5"> so what that means is</font>

496
00:17:13,280 --> 00:17:16,189
when you<font color="#E5E5E5"> then go</font><font color="#CCCCCC"> to execute your</font><font color="#E5E5E5"> gadgets</font>

497
00:17:14,839 --> 00:17:18,109
and they return<font color="#E5E5E5"> they're going to be</font>

498
00:17:16,189 --> 00:17:19,189
returning from gadget addresses that

499
00:17:18,109 --> 00:17:20,688
<font color="#E5E5E5">have been placed in</font><font color="#CCCCCC"> your</font><font color="#E5E5E5"> controlled</font>

500
00:17:19,189 --> 00:17:22,970
memory as opposed to what the real stack

501
00:17:20,689 --> 00:17:26,630
was and that's how you get your fake

502
00:17:22,970 --> 00:17:28,250
stack working so how do you how would

503
00:17:26,630 --> 00:17:31,100
<font color="#CCCCCC">you actually</font><font color="#E5E5E5"> do this in practice</font><font color="#CCCCCC"> well</font>

504
00:17:28,250 --> 00:17:33,230
you would use a special<font color="#E5E5E5"> type of</font><font color="#CCCCCC"> rock</font>

505
00:17:31,100 --> 00:17:35,059
gadget known as a pivot gadget<font color="#E5E5E5"> which its</font>

506
00:17:33,230 --> 00:17:36,740
sole<font color="#CCCCCC"> purpose is to</font><font color="#E5E5E5"> control</font><font color="#CCCCCC"> the stack</font>

507
00:17:35,059 --> 00:17:39,980
pointer<font color="#E5E5E5"> body with something that you can</font>

508
00:17:36,740 --> 00:17:42,320
<font color="#E5E5E5">you</font><font color="#CCCCCC"> can have some</font><font color="#E5E5E5"> control over so here's</font>

509
00:17:39,980 --> 00:17:43,040
an example<font color="#E5E5E5"> of one again</font><font color="#CCCCCC"> a simple gadget</font>

510
00:17:42,320 --> 00:17:44,840
consistent

511
00:17:43,040 --> 00:17:46,940
<font color="#E5E5E5">for instructions</font><font color="#CCCCCC"> the first instruction</font>

512
00:17:44,840 --> 00:17:48,889
this time is a move instruction<font color="#E5E5E5"> which</font>

513
00:17:46,940 --> 00:17:52,730
will move<font color="#CCCCCC"> x5 the</font><font color="#E5E5E5"> value of x-5</font>

514
00:17:48,890 --> 00:17:54,620
into the stack pointer<font color="#E5E5E5"> so assuming</font><font color="#CCCCCC"> that</font>

515
00:17:52,730 --> 00:17:57,320
the attacker<font color="#E5E5E5"> already has their</font>

516
00:17:54,620 --> 00:17:58,729
controlled address<font color="#E5E5E5"> held in x5 this</font>

517
00:17:57,320 --> 00:18:00,500
gadget<font color="#E5E5E5"> would be perfect because</font><font color="#CCCCCC"> they can</font>

518
00:17:58,730 --> 00:18:02,060
<font color="#E5E5E5">then move that to the stack</font><font color="#CCCCCC"> pointer and</font>

519
00:18:00,500 --> 00:18:04,220
now the stack pointer points to their

520
00:18:02,060 --> 00:18:05,270
<font color="#E5E5E5">control memory and again the last two</font>

521
00:18:04,220 --> 00:18:06,410
instructions are<font color="#CCCCCC"> not actually</font><font color="#E5E5E5"> really</font>

522
00:18:05,270 --> 00:18:10,639
part the gadget<font color="#E5E5E5"> Ledger's for</font><font color="#CCCCCC"> the</font>

523
00:18:06,410 --> 00:18:11,720
<font color="#E5E5E5">returning part so using those couple</font><font color="#CCCCCC"> of</font>

524
00:18:10,640 --> 00:18:14,690
techniques I've discovered I'm going to

525
00:18:11,720 --> 00:18:16,510
show<font color="#E5E5E5"> you an example attack on a kind of</font>

526
00:18:14,690 --> 00:18:18,830
<font color="#E5E5E5">demo program I built for this talk so</font>

527
00:18:16,510 --> 00:18:21,440
the demo program the target name<font color="#E5E5E5"> is</font>

528
00:18:18,830 --> 00:18:23,149
<font color="#CCCCCC">besides demo</font><font color="#E5E5E5"> this is a small simple</font>

529
00:18:21,440 --> 00:18:24,740
<font color="#E5E5E5">artificial binary for the purpose of</font>

530
00:18:23,150 --> 00:18:26,870
<font color="#CCCCCC">testing this</font><font color="#E5E5E5"> out now there's an arm v7</font>

531
00:18:24,740 --> 00:18:28,700
<font color="#E5E5E5">v8 version both</font><font color="#CCCCCC"> of them I'm going</font><font color="#E5E5E5"> to</font>

532
00:18:26,870 --> 00:18:30,040
<font color="#E5E5E5">upload somewhere after this talk if you</font>

533
00:18:28,700 --> 00:18:32,060
<font color="#E5E5E5">want to actually try</font><font color="#CCCCCC"> this out yourself</font>

534
00:18:30,040 --> 00:18:33,320
<font color="#E5E5E5">and the description there you can see it</font>

535
00:18:32,060 --> 00:18:35,389
<font color="#E5E5E5">says the small binary vulnerable to a</font>

536
00:18:33,320 --> 00:18:36,770
<font color="#CCCCCC">heap buffer overflow so obviously we're</font>

537
00:18:35,390 --> 00:18:39,380
working<font color="#E5E5E5"> with the heat begin so we are</font>

538
00:18:36,770 --> 00:18:40,639
<font color="#E5E5E5">going to need a stack pivot and it</font>

539
00:18:39,380 --> 00:18:42,500
allows<font color="#E5E5E5"> a function pointer</font><font color="#CCCCCC"> to be</font>

540
00:18:40,640 --> 00:18:44,690
overwritten so we're<font color="#CCCCCC"> gonna take a look</font>

541
00:18:42,500 --> 00:18:46,550
<font color="#E5E5E5">at this binary well first of all the aim</font>

542
00:18:44,690 --> 00:18:48,560
for<font color="#CCCCCC"> the exploit we're gonna we're gonna</font>

543
00:18:46,550 --> 00:18:51,200
<font color="#E5E5E5">attempt to call the secret function</font><font color="#CCCCCC"> now</font>

544
00:18:48,560 --> 00:18:54,139
<font color="#E5E5E5">the secret function</font><font color="#CCCCCC"> is a function</font><font color="#E5E5E5"> inside</font>

545
00:18:51,200 --> 00:18:55,580
this<font color="#E5E5E5"> binary that is never called in the</font>

546
00:18:54,140 --> 00:18:57,170
<font color="#E5E5E5">actual normal execution</font><font color="#CCCCCC"> flow so it's</font>

547
00:18:55,580 --> 00:18:59,000
kind of<font color="#E5E5E5"> a hidden unused function and</font>

548
00:18:57,170 --> 00:19:01,640
we're<font color="#E5E5E5"> going to call that function and</font>

549
00:18:59,000 --> 00:19:03,320
pass a code to the as the first

550
00:19:01,640 --> 00:19:04,580
parameter<font color="#E5E5E5"> to</font><font color="#CCCCCC"> this function and we're</font>

551
00:19:03,320 --> 00:19:05,960
gonna get<font color="#E5E5E5"> some kind</font><font color="#CCCCCC"> of success message</font>

552
00:19:04,580 --> 00:19:09,080
<font color="#CCCCCC">saying that we still successfully</font>

553
00:19:05,960 --> 00:19:10,250
exploit the binary so here's a

554
00:19:09,080 --> 00:19:11,810
screenshot<font color="#E5E5E5"> of what</font><font color="#CCCCCC"> the binary looks like</font>

555
00:19:10,250 --> 00:19:13,280
when you execute<font color="#E5E5E5"> it</font><font color="#CCCCCC"> so you can see</font>

556
00:19:11,810 --> 00:19:15,379
though it<font color="#E5E5E5"> gives you a</font><font color="#CCCCCC"> b-sides</font><font color="#E5E5E5"> banner at</font>

557
00:19:13,280 --> 00:19:17,780
<font color="#CCCCCC">the top and then it asks you to enter</font>

558
00:19:15,380 --> 00:19:20,090
the path to a file<font color="#CCCCCC"> containing some data</font>

559
00:19:17,780 --> 00:19:22,399
and you enter that<font color="#CCCCCC"> wherever</font><font color="#E5E5E5"> you want</font>

560
00:19:20,090 --> 00:19:24,110
there so file dot txt<font color="#E5E5E5"> it's gonna read in</font>

561
00:19:22,400 --> 00:19:26,390
all the data<font color="#E5E5E5"> from the file and then</font><font color="#CCCCCC"> just</font>

562
00:19:24,110 --> 00:19:28,550
<font color="#E5E5E5">print out</font><font color="#CCCCCC"> dr. is valid and then that</font>

563
00:19:26,390 --> 00:19:30,650
<font color="#E5E5E5">sort will quit so by now you probably</font>

564
00:19:28,550 --> 00:19:32,000
<font color="#E5E5E5">already guessed the only place the heap</font>

565
00:19:30,650 --> 00:19:34,370
overflow can occur is when<font color="#E5E5E5"> it actually</font>

566
00:19:32,000 --> 00:19:36,860
<font color="#E5E5E5">reads the</font><font color="#CCCCCC"> data at</font><font color="#E5E5E5"> the file which is</font>

567
00:19:34,370 --> 00:19:38,810
right because this<font color="#CCCCCC"> is a snippet taken</font>

568
00:19:36,860 --> 00:19:40,909
from<font color="#E5E5E5"> hopper disassembler some</font><font color="#CCCCCC"> pseudo</font>

569
00:19:38,810 --> 00:19:43,790
<font color="#CCCCCC">code on the actual vulnerable part so</font>

570
00:19:40,910 --> 00:19:47,180
you<font color="#CCCCCC"> can see this call to f read this is</font>

571
00:19:43,790 --> 00:19:48,820
actually reading<font color="#E5E5E5"> in 512 bytes from from</font>

572
00:19:47,180 --> 00:19:53,480
whatever<font color="#E5E5E5"> file the</font><font color="#CCCCCC"> user specifies and</font>

573
00:19:48,820 --> 00:19:55,550
it's storing it into<font color="#E5E5E5"> a 64 byte Charlotte</font>

574
00:19:53,480 --> 00:19:56,679
right<font color="#E5E5E5"> so this is a blatant buffer</font>

575
00:19:55,550 --> 00:19:57,940
overflow there it

576
00:19:56,679 --> 00:20:00,389
not store that<font color="#CCCCCC"> date you're in it</font><font color="#E5E5E5"> so it's</font>

577
00:19:57,940 --> 00:20:02,679
<font color="#E5E5E5">gonna overflow into adjacent memory and</font>

578
00:20:00,389 --> 00:20:04,959
conveniently for us<font color="#E5E5E5"> there</font><font color="#CCCCCC"> is a function</font>

579
00:20:02,679 --> 00:20:07,210
pointer<font color="#E5E5E5"> directly next to this buffer so</font>

580
00:20:04,960 --> 00:20:08,769
any extra day<font color="#CCCCCC"> or other</font><font color="#E5E5E5"> than the 64 bytes</font>

581
00:20:07,210 --> 00:20:11,019
<font color="#E5E5E5">this is going to be directly written in</font>

582
00:20:08,769 --> 00:20:13,149
over to this<font color="#CCCCCC"> function pointer</font><font color="#E5E5E5"> which</font>

583
00:20:11,019 --> 00:20:15,759
again conveniently<font color="#E5E5E5"> is actually called</font>

584
00:20:13,149 --> 00:20:16,918
directly after it's caught every so it's

585
00:20:15,759 --> 00:20:19,960
a very<font color="#CCCCCC"> artificial</font>

586
00:20:16,919 --> 00:20:21,309
<font color="#CCCCCC">case because obviously</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> real-world</font><font color="#E5E5E5"> one</font>

587
00:20:19,960 --> 00:20:23,350
<font color="#CCCCCC">or ability would</font><font color="#E5E5E5"> not be as simplistic as</font>

588
00:20:21,309 --> 00:20:26,200
this but<font color="#E5E5E5"> this will this just serves well</font>

589
00:20:23,350 --> 00:20:28,299
for the demo<font color="#CCCCCC"> purpose and that</font><font color="#E5E5E5"> is the</font>

590
00:20:26,200 --> 00:20:30,700
that's<font color="#E5E5E5"> the offset from this structure</font>

591
00:20:28,299 --> 00:20:32,139
which will actually<font color="#E5E5E5"> be on the heap so 64</font>

592
00:20:30,700 --> 00:20:35,220
bytes<font color="#E5E5E5"> as long will be after</font><font color="#CCCCCC"> that buffer</font>

593
00:20:32,139 --> 00:20:37,449
and it will call<font color="#E5E5E5"> that function pointer</font>

594
00:20:35,220 --> 00:20:40,029
so the secret function<font color="#CCCCCC"> this is the one I</font>

595
00:20:37,450 --> 00:20:42,490
said is hidden it's not actually used in

596
00:20:40,029 --> 00:20:44,080
the<font color="#E5E5E5"> real program</font><font color="#CCCCCC"> but essentially</font><font color="#E5E5E5"> is a</font>

597
00:20:42,490 --> 00:20:46,330
function that will take in a code as the

598
00:20:44,080 --> 00:20:48,279
<font color="#E5E5E5">first parameter and it will compare that</font>

599
00:20:46,330 --> 00:20:50,549
<font color="#CCCCCC">so the code in this case</font><font color="#E5E5E5"> is for</font><font color="#CCCCCC"> one for</font>

600
00:20:48,279 --> 00:20:54,970
F and<font color="#E5E5E5"> it's going</font><font color="#CCCCCC"> to compare that code to</font>

601
00:20:50,549 --> 00:20:56,529
your your first<font color="#CCCCCC"> argument or w0 and if</font>

602
00:20:54,970 --> 00:20:58,480
<font color="#CCCCCC">the</font><font color="#E5E5E5"> or if the code is correct then it's</font>

603
00:20:56,529 --> 00:21:00,129
going<font color="#E5E5E5"> to jump you</font><font color="#CCCCCC"> to this section</font><font color="#E5E5E5"> here</font>

604
00:20:58,480 --> 00:21:01,629
which will<font color="#E5E5E5"> give you a kind of success</font>

605
00:21:00,129 --> 00:21:03,639
message<font color="#E5E5E5"> and so you've completely exploit</font>

606
00:21:01,629 --> 00:21:04,990
<font color="#E5E5E5">challenge if the code is incorrect or if</font>

607
00:21:03,639 --> 00:21:06,729
you don't actually put<font color="#E5E5E5"> a code at all or</font>

608
00:21:04,990 --> 00:21:07,629
supply code<font color="#E5E5E5"> it's going to jump you here</font>

609
00:21:06,730 --> 00:21:10,299
<font color="#E5E5E5">which will just give you an error</font>

610
00:21:07,629 --> 00:21:11,769
<font color="#CCCCCC">message so you may be</font><font color="#E5E5E5"> thinking why would</font>

611
00:21:10,299 --> 00:21:13,960
<font color="#E5E5E5">you not just jump directly to this place</font>

612
00:21:11,769 --> 00:21:15,519
<font color="#E5E5E5">because that would obviously by policies</font>

613
00:21:13,960 --> 00:21:17,320
check and you'd get<font color="#CCCCCC"> the errantly you get</font>

614
00:21:15,519 --> 00:21:18,909
the<font color="#E5E5E5"> success message right</font><font color="#CCCCCC"> away but</font>

615
00:21:17,320 --> 00:21:20,590
that'd be<font color="#E5E5E5"> too</font><font color="#CCCCCC"> easy and for the</font>

616
00:21:18,909 --> 00:21:23,049
demonstration<font color="#CCCCCC"> purposes we're going to</font>

617
00:21:20,590 --> 00:21:24,820
assume that<font color="#E5E5E5"> we have to call secret from</font>

618
00:21:23,049 --> 00:21:26,679
<font color="#E5E5E5">its entry point just so we</font><font color="#CCCCCC"> actually do</font>

619
00:21:24,820 --> 00:21:28,539
<font color="#E5E5E5">have</font><font color="#CCCCCC"> to work with a real life a real</font>

620
00:21:26,679 --> 00:21:30,220
<font color="#CCCCCC">Rock chain that consists of a few more</font>

621
00:21:28,539 --> 00:21:31,869
gadgets because otherwise it would

622
00:21:30,220 --> 00:21:33,070
<font color="#E5E5E5">literally as simple as a replace in the</font>

623
00:21:31,869 --> 00:21:36,970
function pointer address<font color="#CCCCCC"> with that</font>

624
00:21:33,070 --> 00:21:38,320
<font color="#CCCCCC">address of the secret part so the</font>

625
00:21:36,970 --> 00:21:40,029
exploit pan is<font color="#E5E5E5"> going to be -</font><font color="#CCCCCC"> obviously</font>

626
00:21:38,320 --> 00:21:41,499
game code execution which we<font color="#CCCCCC"> already</font>

627
00:21:40,029 --> 00:21:43,600
know how<font color="#CCCCCC"> to do that with the blatant</font>

628
00:21:41,499 --> 00:21:45,190
overflow<font color="#E5E5E5"> into the function pointer then</font>

629
00:21:43,600 --> 00:21:46,840
we're going to<font color="#CCCCCC"> use</font><font color="#E5E5E5"> that to use the rock</font>

630
00:21:45,190 --> 00:21:49,809
chain which is<font color="#E5E5E5"> going to first of all set</font>

631
00:21:46,840 --> 00:21:51,610
<font color="#E5E5E5">up X 0 or W 0</font><font color="#CCCCCC"> hope to make sure it holds</font>

632
00:21:49,809 --> 00:21:53,559
the<font color="#CCCCCC"> secret code and</font><font color="#E5E5E5"> then you're going to</font>

633
00:21:51,610 --> 00:21:55,418
<font color="#E5E5E5">just jump to the secret entry point</font>

634
00:21:53,559 --> 00:21:58,509
which should<font color="#CCCCCC"> then validate</font><font color="#E5E5E5"> that code and</font>

635
00:21:55,419 --> 00:21:59,919
give us the success message<font color="#E5E5E5"> so what do</font>

636
00:21:58,509 --> 00:22:01,360
we know already well we can<font color="#CCCCCC"> obviously</font>

637
00:21:59,919 --> 00:22:03,249
control the<font color="#E5E5E5"> program counter or the</font>

638
00:22:01,360 --> 00:22:05,080
<font color="#CCCCCC">execution flow by overriding</font><font color="#E5E5E5"> that</font>

639
00:22:03,249 --> 00:22:07,179
pointer and since we're working<font color="#E5E5E5"> with the</font>

640
00:22:05,080 --> 00:22:09,279
heap we can execute a<font color="#E5E5E5"> single gadget</font>

641
00:22:07,179 --> 00:22:10,360
worth of execution so we're<font color="#E5E5E5"> going to</font>

642
00:22:09,279 --> 00:22:11,470
need<font color="#E5E5E5"> a stack pivot so</font>

643
00:22:10,360 --> 00:22:15,790
we can actually<font color="#E5E5E5"> execute several</font>

644
00:22:11,470 --> 00:22:17,110
<font color="#CCCCCC">mortgages after that</font><font color="#E5E5E5"> and this</font><font color="#CCCCCC"> criteria</font>

645
00:22:15,790 --> 00:22:18,399
for the stack pivot again<font color="#E5E5E5"> must be a</font>

646
00:22:17,110 --> 00:22:20,080
single gadget<font color="#E5E5E5"> because that's all we get</font>

647
00:22:18,400 --> 00:22:21,970
<font color="#E5E5E5">to</font><font color="#CCCCCC"> work</font><font color="#E5E5E5"> with and it must allow us to</font>

648
00:22:20,080 --> 00:22:23,620
<font color="#E5E5E5">point the stack stack pointer to this</font>

649
00:22:21,970 --> 00:22:25,660
very start of the heat buffer because

650
00:22:23,620 --> 00:22:27,459
this is where the data from the file is

651
00:22:25,660 --> 00:22:28,630
going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> go into so obviously we control</font>

652
00:22:27,460 --> 00:22:32,230
this memory<font color="#CCCCCC"> and that's</font><font color="#E5E5E5"> what we want</font><font color="#CCCCCC"> us</font>

653
00:22:28,630 --> 00:22:33,340
<font color="#CCCCCC">our fake stack so this gadget is</font>

654
00:22:32,230 --> 00:22:35,620
actually within the binary the one I

655
00:22:33,340 --> 00:22:38,800
just gave<font color="#CCCCCC"> is an</font><font color="#E5E5E5"> example as a staff pivot</font>

656
00:22:35,620 --> 00:22:40,810
gadget<font color="#E5E5E5"> so it moves again x5 into the</font>

657
00:22:38,800 --> 00:22:44,530
stack<font color="#CCCCCC"> pointer and</font><font color="#E5E5E5"> conveniently for us</font>

658
00:22:40,810 --> 00:22:46,690
again<font color="#CCCCCC"> I programmed this example app in</font>

659
00:22:44,530 --> 00:22:48,960
such a way that x5 will happen to hold

660
00:22:46,690 --> 00:22:51,820
the address<font color="#E5E5E5"> of our heap chunk anyway so</font>

661
00:22:48,960 --> 00:22:53,020
again<font color="#E5E5E5"> very artificial because it</font>

662
00:22:51,820 --> 00:22:54,730
<font color="#E5E5E5">wouldn't be as easy as this</font><font color="#CCCCCC"> defined</font>

663
00:22:53,020 --> 00:22:56,350
<font color="#CCCCCC">stack pivot in a real situation but</font>

664
00:22:54,730 --> 00:22:59,860
again it serves as well for this

665
00:22:56,350 --> 00:23:02,379
demonstration purpose so we've got the

666
00:22:59,860 --> 00:23:06,070
stack<font color="#CCCCCC"> paper sort</font><font color="#E5E5E5"> out now for</font><font color="#CCCCCC"> loading X 1</font>

667
00:23:02,380 --> 00:23:07,630
or X 0<font color="#CCCCCC"> or</font><font color="#E5E5E5"> W 0 so here</font><font color="#CCCCCC"> are two gadgets</font>

668
00:23:06,070 --> 00:23:09,189
we're going to use to do this now<font color="#CCCCCC"> you</font>

669
00:23:07,630 --> 00:23:11,010
<font color="#CCCCCC">could theoretically do this with one</font>

670
00:23:09,190 --> 00:23:15,160
gadget<font color="#E5E5E5"> but I wanted</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> kind of replicate</font>

671
00:23:11,010 --> 00:23:17,080
<font color="#E5E5E5">the more real-world</font><font color="#CCCCCC"> idea Rob because</font><font color="#E5E5E5"> you</font>

672
00:23:15,160 --> 00:23:18,250
often<font color="#E5E5E5"> when</font><font color="#CCCCCC"> working with Rob obviously</font>

673
00:23:17,080 --> 00:23:19,750
you have<font color="#CCCCCC"> to work with what you've got in</font>

674
00:23:18,250 --> 00:23:21,700
your<font color="#E5E5E5"> target binary so you cannot create</font>

675
00:23:19,750 --> 00:23:23,140
instructions<font color="#E5E5E5"> so often it will be</font><font color="#CCCCCC"> the</font>

676
00:23:21,700 --> 00:23:24,640
case<font color="#E5E5E5"> that you find a gadget that's sort</font>

677
00:23:23,140 --> 00:23:26,470
of it does kind<font color="#E5E5E5"> of what you need it to</font>

678
00:23:24,640 --> 00:23:28,090
do but there may be<font color="#E5E5E5"> side effects</font><font color="#CCCCCC"> or it</font>

679
00:23:26,470 --> 00:23:31,210
may<font color="#E5E5E5"> be not</font><font color="#CCCCCC"> straightforward</font><font color="#E5E5E5"> so in this</font>

680
00:23:28,090 --> 00:23:32,649
case we want<font color="#E5E5E5"> to control X 0 but we have</font>

681
00:23:31,210 --> 00:23:34,780
to do it in two stages<font color="#E5E5E5"> because this</font>

682
00:23:32,650 --> 00:23:36,820
first gadget<font color="#E5E5E5"> this lets us control X 3</font>

683
00:23:34,780 --> 00:23:38,080
and X<font color="#CCCCCC"> 4 by</font><font color="#E5E5E5"> loading</font><font color="#CCCCCC"> a pair of registers</font>

684
00:23:36,820 --> 00:23:39,280
<font color="#E5E5E5">it loads them from the stack</font><font color="#CCCCCC"> so if we</font>

685
00:23:38,080 --> 00:23:41,350
can have control<font color="#E5E5E5"> debtor on the stack</font>

686
00:23:39,280 --> 00:23:43,149
which we<font color="#CCCCCC"> already know we can do we</font><font color="#E5E5E5"> can</font>

687
00:23:41,350 --> 00:23:46,030
control both<font color="#CCCCCC"> of</font><font color="#E5E5E5"> these registers</font><font color="#CCCCCC"> now the</font>

688
00:23:43,150 --> 00:23:48,220
next gadget will then allow<font color="#CCCCCC"> us to move X</font>

689
00:23:46,030 --> 00:23:50,710
<font color="#E5E5E5">4 which we just</font><font color="#CCCCCC"> control into X 0 so we</font>

690
00:23:48,220 --> 00:23:52,750
can't have to take two steps to do this

691
00:23:50,710 --> 00:23:57,100
and at that point<font color="#E5E5E5"> we will</font><font color="#CCCCCC"> have full</font>

692
00:23:52,750 --> 00:23:59,230
control<font color="#CCCCCC"> over</font><font color="#E5E5E5"> X 0 so that's how we're</font>

693
00:23:57,100 --> 00:24:01,149
<font color="#CCCCCC">going to load the</font><font color="#E5E5E5"> X 0</font><font color="#CCCCCC"> moves it with the</font>

694
00:23:59,230 --> 00:24:02,350
code and<font color="#E5E5E5"> finally it's a cool secret with</font>

695
00:24:01,150 --> 00:24:03,700
it you just<font color="#CCCCCC"> need the address of the</font>

696
00:24:02,350 --> 00:24:05,860
secret function<font color="#E5E5E5"> which you can just find</font>

697
00:24:03,700 --> 00:24:09,670
<font color="#E5E5E5">were disassembled in the binary so we've</font>

698
00:24:05,860 --> 00:24:12,030
also got<font color="#E5E5E5"> that done so I've actually</font>

699
00:24:09,670 --> 00:24:14,230
<font color="#E5E5E5">built an exploit file before</font><font color="#CCCCCC"> I came here</font>

700
00:24:12,030 --> 00:24:15,790
<font color="#CCCCCC">this this file here successfully</font>

701
00:24:14,230 --> 00:24:17,110
exploits the binary and<font color="#E5E5E5"> does</font>

702
00:24:15,790 --> 00:24:18,580
carries<font color="#E5E5E5"> a little</font><font color="#CCCCCC"> black rock though</font><font color="#E5E5E5"> just</font>

703
00:24:17,110 --> 00:24:20,709
explained and I'm going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> briefly</font>

704
00:24:18,580 --> 00:24:23,409
dissect what<font color="#E5E5E5"> each part of this does</font>

705
00:24:20,710 --> 00:24:23,929
again just to make<font color="#CCCCCC"> it</font><font color="#E5E5E5"> clear how</font><font color="#CCCCCC"> this</font>

706
00:24:23,410 --> 00:24:26,749
payload

707
00:24:23,929 --> 00:24:29,809
works so this is<font color="#E5E5E5"> just the hex dump of</font>

708
00:24:26,749 --> 00:24:32,119
the file exploit payload<font color="#E5E5E5"> and all of this</font>

709
00:24:29,809 --> 00:24:33,379
<font color="#E5E5E5">data this is less than 512 bytes so all</font>

710
00:24:32,119 --> 00:24:35,928
of this data<font color="#CCCCCC"> is going to</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> written to</font>

711
00:24:33,379 --> 00:24:37,639
<font color="#CCCCCC">the heap</font><font color="#E5E5E5"> and the first 64 bytes of it so</font>

712
00:24:35,929 --> 00:24:40,519
up until<font color="#CCCCCC"> this point here</font><font color="#E5E5E5"> this is going</font>

713
00:24:37,639 --> 00:24:43,100
to fill up the 64 byte char array<font color="#E5E5E5"> that</font>

714
00:24:40,519 --> 00:24:45,289
we had on heap and that means that any

715
00:24:43,100 --> 00:24:46,998
data after that is<font color="#E5E5E5"> going to be what goes</font>

716
00:24:45,289 --> 00:24:49,100
<font color="#E5E5E5">into the what overwrites the function</font>

717
00:24:46,999 --> 00:24:52,039
<font color="#CCCCCC">pointer so the first thing we have after</font>

718
00:24:49,100 --> 00:24:54,379
that<font color="#E5E5E5"> is this which is the address of the</font>

719
00:24:52,039 --> 00:24:55,789
<font color="#CCCCCC">first</font><font color="#E5E5E5"> gadget so essentially we</font><font color="#CCCCCC"> have we</font>

720
00:24:54,379 --> 00:24:57,110
fill out the buffer<font color="#CCCCCC"> we overwrite the</font>

721
00:24:55,789 --> 00:24:58,700
function<font color="#E5E5E5"> pointer with the address of our</font>

722
00:24:57,110 --> 00:25:00,469
first gadget which is our pivot gadget

723
00:24:58,700 --> 00:25:01,879
you<font color="#CCCCCC"> can see there and</font><font color="#E5E5E5"> therefore when the</font>

724
00:25:00,470 --> 00:25:03,200
function<font color="#CCCCCC"> returns it's going to be doing</font>

725
00:25:01,879 --> 00:25:04,600
the stack pivot<font color="#E5E5E5"> straight away so this</font>

726
00:25:03,200 --> 00:25:07,100
will move<font color="#CCCCCC"> x5 into the stack pointer</font>

727
00:25:04,600 --> 00:25:08,869
which once that's<font color="#E5E5E5"> actually done that</font>

728
00:25:07,100 --> 00:25:11,389
essentially<font color="#E5E5E5"> means the stack points to</font>

729
00:25:08,869 --> 00:25:13,340
the top of this file<font color="#CCCCCC"> all</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> data are in</font>

730
00:25:11,389 --> 00:25:15,049
<font color="#E5E5E5">this file will be on the heap</font><font color="#CCCCCC"> so when</font>

731
00:25:13,340 --> 00:25:16,220
the<font color="#E5E5E5"> stack</font><font color="#CCCCCC"> with it's done the stack</font>

732
00:25:15,049 --> 00:25:17,539
pointer<font color="#CCCCCC"> is gonna be pointing to the top</font>

733
00:25:16,220 --> 00:25:20,779
of this<font color="#E5E5E5"> so therefore this is our new</font>

734
00:25:17,539 --> 00:25:22,759
stack and then<font color="#E5E5E5"> obviously it returns by</font>

735
00:25:20,779 --> 00:25:26,480
loading a pair of registers it loads<font color="#E5E5E5"> X</font>

736
00:25:22,759 --> 00:25:28,519
<font color="#CCCCCC">29 and X 30 and</font><font color="#E5E5E5"> then it branches to X 30</font>

737
00:25:26,480 --> 00:25:29,869
so on the top of the stack<font color="#CCCCCC"> what we have</font>

738
00:25:28,519 --> 00:25:31,429
is some junk data<font color="#E5E5E5"> that's going to</font><font color="#CCCCCC"> be</font>

739
00:25:29,869 --> 00:25:33,559
<font color="#E5E5E5">loaded into X 29 because we don't</font>

740
00:25:31,429 --> 00:25:36,289
actually<font color="#E5E5E5"> care about that register then</font>

741
00:25:33,559 --> 00:25:38,059
we have the address<font color="#CCCCCC"> that will go into X</font>

742
00:25:36,289 --> 00:25:39,110
30 which we then jump to afterwards so

743
00:25:38,059 --> 00:25:41,928
this isn't<font color="#E5E5E5"> going to be the address</font><font color="#CCCCCC"> of</font>

744
00:25:39,110 --> 00:25:43,729
the second gadget and this is the first

745
00:25:41,929 --> 00:25:45,889
stage in control<font color="#E5E5E5"> and X 0</font><font color="#CCCCCC"> so you can see</font>

746
00:25:43,730 --> 00:25:48,379
this one is<font color="#CCCCCC"> the</font><font color="#E5E5E5"> one that loads X 3 and X</font>

747
00:25:45,889 --> 00:25:51,139
<font color="#E5E5E5">4 again from addresses relative to the</font>

748
00:25:48,379 --> 00:25:52,459
stack so<font color="#CCCCCC"> we load</font><font color="#E5E5E5"> some random data into X</font>

749
00:25:51,139 --> 00:25:54,289
<font color="#E5E5E5">3 because I don't care about that one</font>

750
00:25:52,460 --> 00:25:56,570
and then we load<font color="#E5E5E5"> the secret code into X</font>

751
00:25:54,289 --> 00:25:58,570
<font color="#E5E5E5">4 which is the</font><font color="#CCCCCC"> for 1 for F and this is</font>

752
00:25:56,570 --> 00:26:00,830
<font color="#E5E5E5">all in little-endian that's why the</font>

753
00:25:58,570 --> 00:26:03,590
bytes are in reverse order<font color="#E5E5E5"> if</font><font color="#CCCCCC"> you're</font>

754
00:26:00,830 --> 00:26:05,570
<font color="#E5E5E5">wondering then we return from this</font>

755
00:26:03,590 --> 00:26:07,519
gadget<font color="#E5E5E5"> so again we load</font><font color="#CCCCCC"> some junk into</font><font color="#E5E5E5"> X</font>

756
00:26:05,570 --> 00:26:09,980
29<font color="#E5E5E5"> and then we load the next address we</font>

757
00:26:07,519 --> 00:26:12,169
want<font color="#E5E5E5"> to go to into X 30 and this points</font>

758
00:26:09,980 --> 00:26:15,440
to the<font color="#E5E5E5"> third gadget which will move x4</font>

759
00:26:12,169 --> 00:26:18,379
<font color="#E5E5E5">to X</font><font color="#CCCCCC"> 0 and again</font><font color="#E5E5E5"> returns again so we</font>

760
00:26:15,440 --> 00:26:19,639
have junk in X 29<font color="#E5E5E5"> and finally the last</font>

761
00:26:18,379 --> 00:26:22,730
<font color="#E5E5E5">thing we</font><font color="#CCCCCC"> need to do is</font><font color="#E5E5E5"> just jump to</font>

762
00:26:19,639 --> 00:26:23,869
secret entry point which is what that

763
00:26:22,730 --> 00:26:26,299
<font color="#E5E5E5">address is there so that</font><font color="#CCCCCC"> will jump</font>

764
00:26:23,869 --> 00:26:28,279
straight into secret<font color="#E5E5E5"> and if all has been</font>

765
00:26:26,299 --> 00:26:29,629
self correctly then at<font color="#E5E5E5"> that point we</font>

766
00:26:28,279 --> 00:26:31,490
<font color="#CCCCCC">should already have</font><font color="#E5E5E5"> the controlled code</font>

767
00:26:29,629 --> 00:26:33,109
inside of<font color="#E5E5E5"> X 0 and so secret should</font>

768
00:26:31,490 --> 00:26:36,259
<font color="#CCCCCC">validate that</font><font color="#E5E5E5"> and give us the success</font>

769
00:26:33,109 --> 00:26:37,760
message so here we can<font color="#E5E5E5"> specify that</font>

770
00:26:36,259 --> 00:26:39,590
exploit payload file

771
00:26:37,760 --> 00:26:41,180
and then when we run this and<font color="#CCCCCC"> enter that</font>

772
00:26:39,590 --> 00:26:42,649
<font color="#E5E5E5">into the program</font><font color="#CCCCCC"> instead of it just</font>

773
00:26:41,180 --> 00:26:44,210
reading out<font color="#CCCCCC"> the</font><font color="#E5E5E5"> data and saying that saw</font>

774
00:26:42,650 --> 00:26:46,400
<font color="#E5E5E5">this time it takes full control</font>

775
00:26:44,210 --> 00:26:49,310
<font color="#CCCCCC">execuse</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> rock</font><font color="#E5E5E5"> chain and then we have</font>

776
00:26:46,400 --> 00:26:50,840
this success many success message<font color="#E5E5E5"> saying</font>

777
00:26:49,310 --> 00:26:53,960
<font color="#E5E5E5">that we managed</font><font color="#CCCCCC"> to successfully crack</font>

778
00:26:50,840 --> 00:26:57,110
the binary<font color="#E5E5E5"> and an executor you name - a</font>

779
00:26:53,960 --> 00:26:59,330
command so<font color="#E5E5E5"> that is the exploit complete</font>

780
00:26:57,110 --> 00:27:00,860
so just a quick<font color="#E5E5E5"> demonstration of the</font>

781
00:26:59,330 --> 00:27:02,480
<font color="#CCCCCC">rock technique and the stack pivot</font>

782
00:27:00,860 --> 00:27:04,969
technique<font color="#E5E5E5"> if you want to learn more</font>

783
00:27:02,480 --> 00:27:06,920
about arm specifically or any other

784
00:27:04,970 --> 00:27:09,200
memory corruption exploitation then

785
00:27:06,920 --> 00:27:11,510
there's a few useful<font color="#E5E5E5"> links here the top</font>

786
00:27:09,200 --> 00:27:13,310
<font color="#E5E5E5">one is especially good for learning</font>

787
00:27:11,510 --> 00:27:15,290
about just assembly programming on the

788
00:27:13,310 --> 00:27:16,399
<font color="#E5E5E5">arm architectures there's a few</font><font color="#CCCCCC"> other</font>

789
00:27:15,290 --> 00:27:17,960
<font color="#E5E5E5">ones that you</font><font color="#CCCCCC"> can check</font><font color="#E5E5E5"> out and that</font>

790
00:27:16,400 --> 00:27:19,700
second from bottom one that's where you

791
00:27:17,960 --> 00:27:22,580
can<font color="#E5E5E5"> download the exploit challenges that</font>

792
00:27:19,700 --> 00:27:23,600
I've ran for arm-based devices<font color="#CCCCCC"> so if you</font>

793
00:27:22,580 --> 00:27:27,230
want to<font color="#E5E5E5"> try out some of those yourself</font>

794
00:27:23,600 --> 00:27:29,959
and yeah that's my<font color="#CCCCCC"> twitter handle if you</font>

795
00:27:27,230 --> 00:27:33,590
want to tweet<font color="#CCCCCC"> me or follow any of my</font>

796
00:27:29,960 --> 00:27:34,670
work and yeah that's<font color="#E5E5E5"> basically it</font><font color="#CCCCCC"> so if</font>

797
00:27:33,590 --> 00:27:36,320
anyone has<font color="#CCCCCC"> any questions I'm happy to</font>

798
00:27:34,670 --> 00:27:39,100
answer<font color="#E5E5E5"> if not then you can tweet</font><font color="#CCCCCC"> me</font>

799
00:27:36,320 --> 00:28:05,320
afterwards and<font color="#CCCCCC"> or come</font><font color="#E5E5E5"> up to</font><font color="#CCCCCC"> my office</font>

800
00:27:39,100 --> 00:28:07,580
<font color="#E5E5E5">yeah yeah so there are actually some</font>

801
00:28:05,320 --> 00:28:09,770
some methods some mitigations against

802
00:28:07,580 --> 00:28:11,030
<font color="#CCCCCC">Rob I have</font><font color="#E5E5E5"> not personally looked into</font>

803
00:28:09,770 --> 00:28:13,040
them very much<font color="#E5E5E5"> so I can't really answer</font>

804
00:28:11,030 --> 00:28:14,270
<font color="#E5E5E5">that question too much detail but even</font>

805
00:28:13,040 --> 00:28:16,399
with those mitigations is actually

806
00:28:14,270 --> 00:28:19,220
another<font color="#E5E5E5"> form of rock known as drop or</font>

807
00:28:16,400 --> 00:28:20,510
jump oriented programming<font color="#CCCCCC"> which uses a</font>

808
00:28:19,220 --> 00:28:23,020
<font color="#E5E5E5">kind of a similar approach we've</font>

809
00:28:20,510 --> 00:28:25,160
obviously reusing code<font color="#E5E5E5"> but it uses a</font>

810
00:28:23,020 --> 00:28:27,290
dispatcher gadget<font color="#E5E5E5"> and instead of using</font>

811
00:28:25,160 --> 00:28:29,510
functions or instead<font color="#E5E5E5"> of</font><font color="#CCCCCC"> using gadgets in</font>

812
00:28:27,290 --> 00:28:32,270
<font color="#CCCCCC">the return instruction</font><font color="#E5E5E5"> it uses gadgets</font>

813
00:28:29,510 --> 00:28:33,980
<font color="#CCCCCC">that end with conditional branches</font><font color="#E5E5E5"> to</font>

814
00:28:32,270 --> 00:28:36,440
other registers so it's a lot harder<font color="#E5E5E5"> to</font>

815
00:28:33,980 --> 00:28:38,120
mitigate that<font color="#CCCCCC"> but yeah there are</font>

816
00:28:36,440 --> 00:28:40,340
<font color="#CCCCCC">litigations against</font><font color="#E5E5E5"> rock I've not seen</font>

817
00:28:38,120 --> 00:28:43,729
very effective uses<font color="#CCCCCC"> of lemon in major</font>

818
00:28:40,340 --> 00:28:45,679
<font color="#E5E5E5">systems so I'm not really sure not</font>

819
00:28:43,730 --> 00:28:50,710
really sure too much about them but yeah

820
00:28:45,680 --> 00:28:50,710
thank you<font color="#CCCCCC"> a many other questions</font>

821
00:28:53,240 --> 00:28:56,240
<font color="#CCCCCC">yeah</font>

