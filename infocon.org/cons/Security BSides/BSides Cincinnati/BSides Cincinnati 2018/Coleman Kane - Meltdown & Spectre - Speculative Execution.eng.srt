1
00:00:00,050 --> 00:00:12,950
no starch press CBTs cyber-ark Booz

2
00:00:10,530 --> 00:00:22,609
Allen Hamilton

3
00:00:12,950 --> 00:00:22,609
Darkrai no security and the game RSA

4
00:00:23,030 --> 00:00:30,740
and US Bank join the conversation

5
00:00:27,650 --> 00:00:34,510
tweet us at b-side cincy the

6
00:00:30,740 --> 00:00:34,510
presentation will begin shortly

7
00:00:38,470 --> 00:00:51,280
besides Cincinnati 2018 is sponsored by

8
00:00:42,410 --> 00:00:54,279
GE Aviation no starch press CBTs

9
00:00:51,280 --> 00:00:54,280
cyber-ark

10
00:00:55,559 --> 00:01:07,940
Booz Allen Hamilton Darkrai no security

11
00:01:01,039 --> 00:01:07,940
and again RSA

12
00:01:08,230 --> 00:01:16,060
and US Bank join the conversation

13
00:01:13,000 --> 00:01:19,860
tweet us at b-side cincy the

14
00:01:16,060 --> 00:01:19,860
presentation will begin shortly

15
00:01:23,820 --> 00:01:36,630
besides Cincinnati 2018 is sponsored by

16
00:01:27,760 --> 00:01:39,630
GE Aviation no starch press CBTs

17
00:01:36,630 --> 00:01:39,630
cyber-ark

18
00:01:40,880 --> 00:01:53,590
Booz Allen Hamilton Darkrai no security

19
00:01:46,270 --> 00:01:53,590
and the game RSA

20
00:01:53,740 --> 00:02:01,419
and US Bank join the conversation

21
00:01:58,329 --> 00:02:05,189
tweet us at b-side cincy the

22
00:02:01,420 --> 00:02:05,189
presentation will begin shortly

23
00:02:09,149 --> 00:02:21,959
besides Cincinnati 2018 is sponsored by

24
00:02:13,120 --> 00:02:24,959
GE Aviation no starch press CBTs

25
00:02:21,959 --> 00:02:24,959
cyber-ark

26
00:02:26,240 --> 00:02:38,650
Booz Allen Hamilton Darkrai no security

27
00:02:31,660 --> 00:02:38,650
and the game RSA

28
00:02:38,880 --> 00:02:47,820
and US Bank join the conversation tweet

29
00:02:44,010 --> 00:02:50,540
us at b-side cincy the presentation will

30
00:02:47,820 --> 00:02:50,540
begin shortly

31
00:02:54,500 --> 00:03:07,310
besides Cincinnati 2018 is sponsored by

32
00:02:58,470 --> 00:03:10,310
GE Aviation no starch press CBTs

33
00:03:07,310 --> 00:03:10,310
cyber-ark

34
00:03:11,590 --> 00:03:24,000
Booz Allen Hamilton dark rhino security

35
00:03:17,099 --> 00:03:24,000
and the game RSA

36
00:03:24,430 --> 00:03:32,109
and US Bank join the conversation

37
00:03:29,019 --> 00:03:35,879
tweet us at b-side cincy the

38
00:03:32,109 --> 00:03:35,879
presentation will begin shortly

39
00:03:39,840 --> 00:03:52,650
besides Cincinnati 2018 is sponsored by

40
00:03:43,810 --> 00:03:55,650
GE Aviation no starch press CBTs

41
00:03:52,650 --> 00:03:55,650
cyber-ark

42
00:03:56,920 --> 00:04:09,329
Booz Allen Hamilton Darkrai no security

43
00:04:02,310 --> 00:04:09,330
and the game RSA

44
00:04:09,610 --> 00:04:17,470
and US Bank join the conversation

45
00:04:14,380 --> 00:04:21,238
tweet us at b-side cincy the

46
00:04:17,470 --> 00:04:21,239
presentation will begin shortly

47
00:04:25,200 --> 00:04:38,010
besides Cincinnati 2018 is sponsored by

48
00:04:29,140 --> 00:04:41,010
GE Aviation no starch press CBTs

49
00:04:38,010 --> 00:04:41,010
cyber-ark

50
00:04:42,290 --> 00:04:54,670
Booz Allen Hamilton dark rhino security

51
00:04:47,680 --> 00:04:54,670
and the game RSA

52
00:04:55,129 --> 00:05:02,809
and US Bank join the conversation

53
00:04:59,719 --> 00:05:06,580
tweet us at b-side cincy the

54
00:05:02,809 --> 00:05:06,580
presentation will begin shortly

55
00:05:10,539 --> 00:05:23,349
besides Cincinnati 2018 is sponsored by

56
00:05:14,509 --> 00:05:26,349
GE Aviation no starch press CBTs

57
00:05:23,349 --> 00:05:26,349
cyber-ark

58
00:05:27,600 --> 00:05:40,010
Booz Allen Hamilton Darkrai no security

59
00:05:33,200 --> 00:05:40,010
and the game RSA

60
00:05:40,300 --> 00:05:48,159
and US Bank join the conversation

61
00:05:45,069 --> 00:05:51,930
tweet us at b-side cincy the

62
00:05:48,159 --> 00:05:51,930
presentation will begin shortly

63
00:05:55,889 --> 00:06:08,699
besides Cincinnati 2018 is sponsored by

64
00:05:59,830 --> 00:06:11,698
GE Aviation no starch press CBTs

65
00:06:08,699 --> 00:06:11,699
cyber-ark

66
00:06:12,930 --> 00:06:19,210
crying everybody we run a little late

67
00:06:16,780 --> 00:06:20,530
here so we'll get started here present

68
00:06:19,210 --> 00:06:22,150
Coleman came to you guys he'll be

69
00:06:20,530 --> 00:06:27,159
talking about meltdown inspector and the

70
00:06:22,150 --> 00:06:33,729
view of speculoos execution yeah alright

71
00:06:27,160 --> 00:06:37,120
everyone find your seats so before I get

72
00:06:33,729 --> 00:06:39,159
started on my talk I wanted to just kind

73
00:06:37,120 --> 00:06:42,250
of remind everyone that we have this

74
00:06:39,160 --> 00:06:44,290
really neat CTF going so if you're not

75
00:06:42,250 --> 00:06:46,630
familiar a real popular thing at DEFCON

76
00:06:44,290 --> 00:06:50,200
and Derby Khan and some of the other

77
00:06:46,630 --> 00:06:52,960
Star cons is capture the flag challenge

78
00:06:50,200 --> 00:06:54,490
a lot of times they're like super super

79
00:06:52,960 --> 00:06:56,530
technical and we definitely have some of

80
00:06:54,490 --> 00:07:02,669
that here but I wanted to kind of give

81
00:06:56,530 --> 00:07:05,169
people an idea of what else we've got so

82
00:07:02,669 --> 00:07:07,210
this right here is basically like you

83
00:07:05,169 --> 00:07:09,039
can log into it if you go on our Twitter

84
00:07:07,210 --> 00:07:11,349
account you can get all the access info

85
00:07:09,039 --> 00:07:13,270
and everything as far as I can tell I

86
00:07:11,350 --> 00:07:14,470
can actually get the Wi-Fi down here so

87
00:07:13,270 --> 00:07:17,919
if you wanted to play in the audience

88
00:07:14,470 --> 00:07:19,750
downstairs it seems like it works but

89
00:07:17,919 --> 00:07:22,539
basically present a phone map of the

90
00:07:19,750 --> 00:07:26,550
world and then you hover over any one of

91
00:07:22,539 --> 00:07:28,450
these things and it basically has

92
00:07:26,550 --> 00:07:32,020
challenges and stuff like that and

93
00:07:28,450 --> 00:07:33,550
apologies for the crummy resolution my

94
00:07:32,020 --> 00:07:35,440
laptop screen is actually a lot bigger

95
00:07:33,550 --> 00:07:37,330
one of the things I did want to point

96
00:07:35,440 --> 00:07:40,210
out is that a lot of these challenges

97
00:07:37,330 --> 00:07:43,000
are actually kind of trivia quizzes type

98
00:07:40,210 --> 00:07:45,810
things with a kind of subject matter

99
00:07:43,000 --> 00:07:48,639
leaning towards like InfoSec stuff so

100
00:07:45,810 --> 00:07:51,700
the point of this is that anyone can

101
00:07:48,639 --> 00:07:54,729
play and anyone can win you don't have

102
00:07:51,700 --> 00:07:56,440
to be a like Network forensics or file

103
00:07:54,729 --> 00:07:58,810
system you know Carver or anything like

104
00:07:56,440 --> 00:08:00,219
that in order to have fun with this and

105
00:07:58,810 --> 00:08:04,270
that's kind of what we wanted it to be

106
00:08:00,220 --> 00:08:07,030
so anyhow with that I just wanted to let

107
00:08:04,270 --> 00:08:08,320
you know that that's a thing I'll go

108
00:08:07,030 --> 00:08:10,510
ahead and close this now and get my

109
00:08:08,320 --> 00:08:15,780
presentation working

110
00:08:10,510 --> 00:08:15,780
oh geez that's huge

111
00:08:19,610 --> 00:08:22,610
but

112
00:08:22,669 --> 00:08:32,490
presentation there we go and then dude

113
00:08:26,990 --> 00:08:34,440
awesome so now just hope my laptop

114
00:08:32,490 --> 00:08:37,770
doesn't fall asleep on me in the middle

115
00:08:34,440 --> 00:08:39,479
of the presentation which I think as

116
00:08:37,770 --> 00:08:45,510
long as I do this is good alright

117
00:08:39,479 --> 00:08:46,220
everyone so today I'm going to talk to

118
00:08:45,510 --> 00:08:49,170
you

119
00:08:46,220 --> 00:08:50,750
non super technical terms but we will

120
00:08:49,170 --> 00:08:53,459
dive a little bit down into the weeds

121
00:08:50,750 --> 00:08:56,610
meltdown inspector which I'm sure that

122
00:08:53,460 --> 00:08:59,850
many of you saw in the news as the new

123
00:08:56,610 --> 00:09:02,550
sky is falling problem back in January

124
00:08:59,850 --> 00:09:04,589
and then recently saw that it came back

125
00:09:02,550 --> 00:09:08,520
in the news again toward the end of

126
00:09:04,589 --> 00:09:11,610
April early May as it's alleged that

127
00:09:08,520 --> 00:09:16,170
there's a large number of more flaws so

128
00:09:11,610 --> 00:09:17,850
these are CPU hardware flaws you know so

129
00:09:16,170 --> 00:09:20,010
basically architectural design issues

130
00:09:17,850 --> 00:09:23,040
that are inherent a lot of the CPUs so

131
00:09:20,010 --> 00:09:25,439
it was revealed and I kind of expected

132
00:09:23,040 --> 00:09:28,050
this that there's going to be more flaws

133
00:09:25,440 --> 00:09:33,420
of these types they'll probably come up

134
00:09:28,050 --> 00:09:35,069
with much fancier sillier names so we'll

135
00:09:33,420 --> 00:09:36,420
wait and see I was actually hoping a lot

136
00:09:35,070 --> 00:09:39,510
of the details would be released by now

137
00:09:36,420 --> 00:09:42,599
but from what I understand publications

138
00:09:39,510 --> 00:09:45,360
been I know withheld or embargoed or

139
00:09:42,600 --> 00:09:48,360
whatever you want to call it until late

140
00:09:45,360 --> 00:09:51,140
May so while they get some fixes out so

141
00:09:48,360 --> 00:09:53,310
I'll talk to you about these and why

142
00:09:51,140 --> 00:09:55,470
what they're gonna release this month is

143
00:09:53,310 --> 00:09:58,949
the next step and why it's probably not

144
00:09:55,470 --> 00:10:03,260
the end but just the beginning so let's

145
00:09:58,950 --> 00:10:06,540
get started so a little bit about me

146
00:10:03,260 --> 00:10:09,750
I've been a security analyst for just

147
00:10:06,540 --> 00:10:11,400
about eight years so really uh I think

148
00:10:09,750 --> 00:10:13,200
when I first started got out of

149
00:10:11,400 --> 00:10:15,750
undergrad they didn't really have

150
00:10:13,200 --> 00:10:18,480
information security as a career itself

151
00:10:15,750 --> 00:10:19,800
I did a large amount of embedded system

152
00:10:18,480 --> 00:10:23,150
design and stuff like that mostly

153
00:10:19,800 --> 00:10:27,990
focused around Linux platforms I've been

154
00:10:23,150 --> 00:10:31,110
programming since before guerrillas bass

155
00:10:27,990 --> 00:10:34,839
if any of you are familiar with that so

156
00:10:31,110 --> 00:10:36,790
that was probably one of my earliest

157
00:10:34,839 --> 00:10:39,580
you know Tony around with programming

158
00:10:36,790 --> 00:10:41,199
exercises I was a computer engineering

159
00:10:39,580 --> 00:10:44,020
grad at the University of Cincinnati

160
00:10:41,200 --> 00:10:45,839
so differs from computer science in that

161
00:10:44,020 --> 00:10:48,399
it includes a large amount of like

162
00:10:45,839 --> 00:10:50,890
architecture like CPU and operating

163
00:10:48,399 --> 00:10:54,700
system architecture work as well and

164
00:10:50,890 --> 00:10:56,199
then I'm a PhD candidate abd all but

165
00:10:54,700 --> 00:10:58,720
dissertation just finish my coursework

166
00:10:56,200 --> 00:11:01,630
this month at the University of

167
00:10:58,720 --> 00:11:02,890
Cincinnati where I also have put

168
00:11:01,630 --> 00:11:05,830
together some of their curriculum for

169
00:11:02,890 --> 00:11:10,959
their cyber classes so one of the things

170
00:11:05,830 --> 00:11:12,520
I will say is that one way as Danny had

171
00:11:10,959 --> 00:11:14,199
mentioned earlier in his talk is you

172
00:11:12,520 --> 00:11:16,270
know find mentorship opportunities try

173
00:11:14,200 --> 00:11:18,580
and get the knowledge that you've

174
00:11:16,270 --> 00:11:21,069
learned out I've only been in security

175
00:11:18,580 --> 00:11:22,510
for 8 years I've got a lot of knowledge

176
00:11:21,070 --> 00:11:23,920
to share and everything like that and I

177
00:11:22,510 --> 00:11:26,260
try and get it out one way that I do

178
00:11:23,920 --> 00:11:29,410
that is through University of Cincinnati

179
00:11:26,260 --> 00:11:30,850
so I have taught some classes there one

180
00:11:29,410 --> 00:11:35,230
of the great things about this school is

181
00:11:30,850 --> 00:11:36,640
that they don't necessarily presume to

182
00:11:35,230 --> 00:11:38,140
know everything so they actually

183
00:11:36,640 --> 00:11:39,970
recruited myself and a number of other

184
00:11:38,140 --> 00:11:41,110
folks from the industry who didn't

185
00:11:39,970 --> 00:11:42,970
necessarily have a huge teaching

186
00:11:41,110 --> 00:11:46,209
background to help them put together

187
00:11:42,970 --> 00:11:48,370
some of the material they need you know

188
00:11:46,209 --> 00:11:50,709
to actually have a cybersecurity program

189
00:11:48,370 --> 00:11:52,959
that had that's informed by a lot of the

190
00:11:50,709 --> 00:11:55,300
people who do the work every day so I'm

191
00:11:52,959 --> 00:11:56,949
also contributor to a number of

192
00:11:55,300 --> 00:12:00,550
open-source projects this is just a

193
00:11:56,950 --> 00:12:01,990
handful of them but you know through

194
00:12:00,550 --> 00:12:04,120
projects that some of you may or may not

195
00:12:01,990 --> 00:12:08,170
be familiar with creates as an Intel

196
00:12:04,120 --> 00:12:11,200
database Yara is the you know fancy er

197
00:12:08,170 --> 00:12:12,490
thing you know pattern matcher malware

198
00:12:11,200 --> 00:12:16,209
analysis engine whatever you want to

199
00:12:12,490 --> 00:12:18,880
call it extra extra grep and then the

200
00:12:16,209 --> 00:12:21,839
FreeBSD project open source system that

201
00:12:18,880 --> 00:12:23,770
was actually one of my first open source

202
00:12:21,839 --> 00:12:26,020
contribution efforts and I'll say that

203
00:12:23,770 --> 00:12:27,730
another piece in addition to mentoring

204
00:12:26,020 --> 00:12:30,699
everyone is get involved in these

205
00:12:27,730 --> 00:12:32,529
communities just a little tiny bit of

206
00:12:30,700 --> 00:12:35,980
contribution from you can go a long way

207
00:12:32,529 --> 00:12:37,990
to helping a lot of people's lives so I

208
00:12:35,980 --> 00:12:40,209
list myself as a contributor to these

209
00:12:37,990 --> 00:12:43,290
things but my contributions to them is

210
00:12:40,209 --> 00:12:44,880
probably 1% of what they do and

211
00:12:43,290 --> 00:12:48,449
that's the same with a lot of the other

212
00:12:44,880 --> 00:12:50,340
contributors as well and it helps out

213
00:12:48,450 --> 00:12:52,050
those projects immensely and those are

214
00:12:50,340 --> 00:12:55,170
projects that rather than me building my

215
00:12:52,050 --> 00:12:58,229
own version of everything projects that

216
00:12:55,170 --> 00:12:59,520
can help a lot of people and a lot of

217
00:12:58,230 --> 00:13:01,260
different companies so that's one of the

218
00:12:59,520 --> 00:13:02,880
things I always like to stress get

219
00:13:01,260 --> 00:13:04,380
involved in that because that's one

220
00:13:02,880 --> 00:13:07,320
that's another way that we can all solve

221
00:13:04,380 --> 00:13:09,840
the problem together so now to the

222
00:13:07,320 --> 00:13:14,130
actual subject matter that we're here to

223
00:13:09,840 --> 00:13:17,670
talk about meltdown specter so wTF is

224
00:13:14,130 --> 00:13:19,650
that so I just grabbed the information

225
00:13:17,670 --> 00:13:21,120
from meltdown attack they actually have

226
00:13:19,650 --> 00:13:23,730
this nice paragraph that's really really

227
00:13:21,120 --> 00:13:25,710
long I will hit on three things that

228
00:13:23,730 --> 00:13:28,410
have highlighted in red for you so

229
00:13:25,710 --> 00:13:29,580
vulnerabilities in modern processors so

230
00:13:28,410 --> 00:13:30,630
we're not talking about old stuff or

231
00:13:29,580 --> 00:13:32,880
anything we're actually talking about

232
00:13:30,630 --> 00:13:34,620
stuff that's you still go on a best buy

233
00:13:32,880 --> 00:13:36,540
today and buy a laptop you're buying

234
00:13:34,620 --> 00:13:40,400
very likely you're buying vulnerable

235
00:13:36,540 --> 00:13:42,870
processors vulnerable operating system

236
00:13:40,400 --> 00:13:44,790
allows programs to steal data which is

237
00:13:42,870 --> 00:13:46,950
currently processed on the computers a

238
00:13:44,790 --> 00:13:48,959
data in flight it's not necessarily

239
00:13:46,950 --> 00:13:50,280
going to be cracking the contents your

240
00:13:48,960 --> 00:13:51,810
hard drive or anything like that but

241
00:13:50,280 --> 00:13:52,920
it's going to be identifying anything

242
00:13:51,810 --> 00:13:56,489
that other people happen to be working

243
00:13:52,920 --> 00:13:58,199
on this is where I think the point that

244
00:13:56,490 --> 00:14:02,310
Danny was making in the last talk about

245
00:13:58,200 --> 00:14:03,810
we all need to get familiar with doing

246
00:14:02,310 --> 00:14:06,060
threat hunting and doing you know

247
00:14:03,810 --> 00:14:07,500
basically security work in the cloud how

248
00:14:06,060 --> 00:14:09,300
the clouds architected how much you use

249
00:14:07,500 --> 00:14:11,160
and everything like that we've become

250
00:14:09,300 --> 00:14:13,920
accustomed to having a lot of these

251
00:14:11,160 --> 00:14:15,540
dedicated systems where myself plus a

252
00:14:13,920 --> 00:14:18,120
handful of authorized users are what are

253
00:14:15,540 --> 00:14:21,990
responsible or what are running any code

254
00:14:18,120 --> 00:14:24,180
on this system nowadays chances are that

255
00:14:21,990 --> 00:14:30,750
any single website that you're using

256
00:14:24,180 --> 00:14:32,969
today is running code simultaneity you

257
00:14:30,750 --> 00:14:35,910
likely unidentifiable to the owner of

258
00:14:32,970 --> 00:14:38,940
the hardware as well so random code is

259
00:14:35,910 --> 00:14:42,900
running on numerous systems in the cloud

260
00:14:38,940 --> 00:14:44,850
today and you may be entirely unaware of

261
00:14:42,900 --> 00:14:47,130
it as well I think you know we had a

262
00:14:44,850 --> 00:14:51,240
conversation upstairs about the CTF

263
00:14:47,130 --> 00:14:52,220
stuff the CTF website that we got

264
00:14:51,240 --> 00:14:53,750
running

265
00:14:52,220 --> 00:14:56,209
and it actually references something

266
00:14:53,750 --> 00:14:58,220
that's hosted at Google api's org as one

267
00:14:56,209 --> 00:15:00,589
of the UI visual elements or whatever

268
00:14:58,220 --> 00:15:03,940
random thing completely unexpected but

269
00:15:00,589 --> 00:15:06,259
is a part of that platform that type of

270
00:15:03,940 --> 00:15:08,300
leakage into the cloud or leakage from

271
00:15:06,259 --> 00:15:10,759
the cloud is a pervasive these days and

272
00:15:08,300 --> 00:15:13,790
it is incumbent on all of us to

273
00:15:10,759 --> 00:15:16,100
understand how it works so basically

274
00:15:13,790 --> 00:15:18,170
they get a hold of secrets stored this

275
00:15:16,100 --> 00:15:19,730
is kind of you know repeats my point

276
00:15:18,170 --> 00:15:23,750
secrets stored in the memory of other

277
00:15:19,730 --> 00:15:26,600
running programs so we get started with

278
00:15:23,750 --> 00:15:28,279
what our modern processors because as

279
00:15:26,600 --> 00:15:31,189
you know gonna be a lot of subjectivity

280
00:15:28,279 --> 00:15:32,959
about that so the two things that I

281
00:15:31,189 --> 00:15:36,500
think are both applicable to these

282
00:15:32,959 --> 00:15:38,149
vulnerabilities and also the key

283
00:15:36,500 --> 00:15:39,649
features that most people are looking

284
00:15:38,149 --> 00:15:42,259
for and what they would consider to be a

285
00:15:39,649 --> 00:15:44,019
modern processor or a processor worth

286
00:15:42,259 --> 00:15:46,220
buying in a computer I want to buy today

287
00:15:44,019 --> 00:15:48,620
are these features and I'm not gonna

288
00:15:46,220 --> 00:15:50,300
dive into too much detail on all of them

289
00:15:48,620 --> 00:15:52,550
but the big thing is superscalar

290
00:15:50,300 --> 00:15:54,439
architecture so I give some details over

291
00:15:52,550 --> 00:15:57,859
here what that means but in a nutshell

292
00:15:54,439 --> 00:16:00,230
it means that you can if you're familiar

293
00:15:57,860 --> 00:16:02,329
with processor labeling stuff like that

294
00:16:00,230 --> 00:16:04,730
you might see it sold is like you know

295
00:16:02,329 --> 00:16:07,130
one gigahertz 3.2 gigahertz that type of

296
00:16:04,730 --> 00:16:10,130
thing so any of you familiar with like

297
00:16:07,130 --> 00:16:11,870
basic physics that means you know that's

298
00:16:10,130 --> 00:16:15,560
frequency so that's how many times per

299
00:16:11,870 --> 00:16:18,529
second it does a thing you know so in

300
00:16:15,560 --> 00:16:21,130
this case superscalar architecture is

301
00:16:18,529 --> 00:16:23,990
how do I get the processor to run

302
00:16:21,130 --> 00:16:26,209
instructions at a rate that's more

303
00:16:23,990 --> 00:16:27,860
frequent than the gigahertz rating

304
00:16:26,209 --> 00:16:30,829
that's given so there's a lot of

305
00:16:27,860 --> 00:16:34,519
circuitry for that the other goal is how

306
00:16:30,829 --> 00:16:36,199
do I do it without 100% duplicating that

307
00:16:34,519 --> 00:16:38,480
processor so making two of them

308
00:16:36,199 --> 00:16:41,269
basically can I get the same outcome

309
00:16:38,480 --> 00:16:43,420
which is faster than the frequency

310
00:16:41,269 --> 00:16:45,769
faster than the clock rate

311
00:16:43,420 --> 00:16:48,139
instruction speed without fully

312
00:16:45,769 --> 00:16:50,509
duplicating the processor why would I do

313
00:16:48,139 --> 00:16:53,509
that because it's cheaper it mate allows

314
00:16:50,509 --> 00:16:57,649
me to sell a faster processor at a lower

315
00:16:53,509 --> 00:16:59,509
price the other piece that a lot of you

316
00:16:57,649 --> 00:17:01,670
are probably getting familiar with is

317
00:16:59,509 --> 00:17:03,079
multi processing virtual memory

318
00:17:01,670 --> 00:17:05,030
architecture and everything like that so

319
00:17:03,079 --> 00:17:08,030
that allows us to run

320
00:17:05,030 --> 00:17:10,250
Microsoft Excel while I'm washing a

321
00:17:08,030 --> 00:17:12,560
video on YouTube while my facebook chats

322
00:17:10,250 --> 00:17:14,869
updating all of that stuff happening in

323
00:17:12,560 --> 00:17:17,960
real time the critical things here I I

324
00:17:14,869 --> 00:17:20,839
always feel is what we call a time

325
00:17:17,960 --> 00:17:23,480
sharing support so the ability for your

326
00:17:20,839 --> 00:17:25,490
programs to Tranter be silly run in

327
00:17:23,480 --> 00:17:28,000
parallel behind the scenes without

328
00:17:25,490 --> 00:17:30,650
themselves having to be written to say

329
00:17:28,000 --> 00:17:32,870
hand off the processor to the next

330
00:17:30,650 --> 00:17:35,780
program manually so the programs don't

331
00:17:32,870 --> 00:17:37,159
have to be pre-written for multitasking

332
00:17:35,780 --> 00:17:41,149
or multiprocessing

333
00:17:37,160 --> 00:17:43,280
the other thing virtual memory the big

334
00:17:41,150 --> 00:17:45,230
thing here is that you can separate your

335
00:17:43,280 --> 00:17:46,820
memory out into basically privileged

336
00:17:45,230 --> 00:17:48,860
levels you can have memory that's

337
00:17:46,820 --> 00:17:51,439
supposed to be where private stuff

338
00:17:48,860 --> 00:17:55,040
happens and you give memory where you

339
00:17:51,440 --> 00:17:57,680
know Facebook happens or something like

340
00:17:55,040 --> 00:17:59,960
that right you don't want the two of

341
00:17:57,680 --> 00:18:01,850
them to be able to be to read one

342
00:17:59,960 --> 00:18:03,950
another or necessarily or at least you

343
00:18:01,850 --> 00:18:06,679
don't want the Facebook process the

344
00:18:03,950 --> 00:18:09,680
Facebook memory to be able to execute

345
00:18:06,680 --> 00:18:11,690
code that reads the private memory your

346
00:18:09,680 --> 00:18:15,950
you know private key or something like

347
00:18:11,690 --> 00:18:18,110
that so you know the objectives of these

348
00:18:15,950 --> 00:18:22,660
features are pretty you know pretty

349
00:18:18,110 --> 00:18:26,270
clear but your I should say are

350
00:18:22,660 --> 00:18:30,200
desirable but the critical one is this

351
00:18:26,270 --> 00:18:32,990
right here back in the day we may have

352
00:18:30,200 --> 00:18:35,600
had especially working a scientific

353
00:18:32,990 --> 00:18:38,360
environment you may have had computers

354
00:18:35,600 --> 00:18:40,580
dedicated for each one of the jobs that

355
00:18:38,360 --> 00:18:43,729
you needed to do that's expensive

356
00:18:40,580 --> 00:18:47,840
naturally that's a lot of power a lot of

357
00:18:43,730 --> 00:18:50,540
hardware etc the goal with this always

358
00:18:47,840 --> 00:18:53,000
going forward is can we figure out a way

359
00:18:50,540 --> 00:18:55,040
to gradually more and more over the

360
00:18:53,000 --> 00:18:56,870
years consolidate work that's done

361
00:18:55,040 --> 00:19:00,590
across multiple computers multiple

362
00:18:56,870 --> 00:19:03,020
systems into single systems can we you

363
00:19:00,590 --> 00:19:05,030
know basically reduce the hardware costs

364
00:19:03,020 --> 00:19:07,700
while not losing any of the performance

365
00:19:05,030 --> 00:19:09,139
that's the goal that most processor

366
00:19:07,700 --> 00:19:11,000
companies today are going after

367
00:19:09,140 --> 00:19:13,160
in fact most computing companies today

368
00:19:11,000 --> 00:19:14,980
are going after it that's why the cloud

369
00:19:13,160 --> 00:19:17,800
exists

370
00:19:14,980 --> 00:19:19,870
so the other piece support concurrent

371
00:19:17,800 --> 00:19:21,399
computer users that's where a lot of the

372
00:19:19,870 --> 00:19:23,320
memory protection I was talking about

373
00:19:21,400 --> 00:19:26,830
comes into play that's where being able

374
00:19:23,320 --> 00:19:28,750
to divide up access control and memory

375
00:19:26,830 --> 00:19:31,120
and everything work that's why that's

376
00:19:28,750 --> 00:19:33,600
important that facilitates the idea of

377
00:19:31,120 --> 00:19:36,010
this public cloud where you can have

378
00:19:33,600 --> 00:19:39,870
Facebook's living side by side with

379
00:19:36,010 --> 00:19:42,700
Twitter if you want it or you know your

380
00:19:39,870 --> 00:19:44,860
storefront sitting side by side with

381
00:19:42,700 --> 00:19:48,400
somebody's minecraft server that type of

382
00:19:44,860 --> 00:19:50,979
thing you want to minimize real-world

383
00:19:48,400 --> 00:19:53,470
execution times by eliminating

384
00:19:50,980 --> 00:19:56,290
bottlenecks increasing concurrency so

385
00:19:53,470 --> 00:19:59,140
this means you know reduce the cost of

386
00:19:56,290 --> 00:20:01,450
hardware over time while always seeing

387
00:19:59,140 --> 00:20:03,040
it going faster reason for that is we're

388
00:20:01,450 --> 00:20:04,960
always adding new features to software

389
00:20:03,040 --> 00:20:07,210
we're always wanting something to do one

390
00:20:04,960 --> 00:20:09,190
more thing every time you tack on an

391
00:20:07,210 --> 00:20:11,680
extra bit of work it takes that much

392
00:20:09,190 --> 00:20:14,890
more effort in order to get it done so

393
00:20:11,680 --> 00:20:17,110
you know this is the ideal and I kind of

394
00:20:14,890 --> 00:20:20,320
set this here is like this is the

395
00:20:17,110 --> 00:20:23,169
engineering mindset that's behind most

396
00:20:20,320 --> 00:20:25,389
of the consumer you know hardware

397
00:20:23,170 --> 00:20:29,350
development today well this is the

398
00:20:25,390 --> 00:20:31,210
mindset that goes into a lot of it most

399
00:20:29,350 --> 00:20:32,490
of the time and you may run into this in

400
00:20:31,210 --> 00:20:35,440
a lot of your place of business as well

401
00:20:32,490 --> 00:20:37,750
at a management level and whatever is

402
00:20:35,440 --> 00:20:40,690
that security is still reactive in this

403
00:20:37,750 --> 00:20:43,330
environment so in the words of the

404
00:20:40,690 --> 00:20:45,340
Prophet harder better faster stronger

405
00:20:43,330 --> 00:20:47,379
that's what they're going for every

406
00:20:45,340 --> 00:20:50,409
single year they want you to keep buying

407
00:20:47,380 --> 00:20:52,330
more processors more laptops etc keep

408
00:20:50,410 --> 00:20:56,560
upgrading and that's the way they get

409
00:20:52,330 --> 00:20:59,770
you to do it so if you've ever looked at

410
00:20:56,560 --> 00:21:02,830
the you know at the white papers or the

411
00:20:59,770 --> 00:21:05,470
you know what have you called the spec

412
00:21:02,830 --> 00:21:07,510
sheets for a laptop or for a CPU if you

413
00:21:05,470 --> 00:21:08,980
build your own that type of thing you

414
00:21:07,510 --> 00:21:12,580
might have seen all these fancy

415
00:21:08,980 --> 00:21:14,290
buzzwords here so every single one of

416
00:21:12,580 --> 00:21:16,030
these are actual built on so they're not

417
00:21:14,290 --> 00:21:19,870
necessarily core to a processor doing

418
00:21:16,030 --> 00:21:23,379
its work these are all built on or

419
00:21:19,870 --> 00:21:25,100
bolted on features that allow CPUs to do

420
00:21:23,380 --> 00:21:29,419
their work fast

421
00:21:25,100 --> 00:21:31,129
better you know harder stronger etc I'm

422
00:21:29,419 --> 00:21:33,740
gonna cover a handful of these because

423
00:21:31,130 --> 00:21:36,289
to be totally honest this is the type of

424
00:21:33,740 --> 00:21:39,080
stuff they cram into an entire semester

425
00:21:36,289 --> 00:21:40,759
of computer organization but I'm going

426
00:21:39,080 --> 00:21:43,309
to touch on pipelining branch prediction

427
00:21:40,759 --> 00:21:45,799
shared cache and speculative execution

428
00:21:43,309 --> 00:21:50,120
and then probably touch on out of order

429
00:21:45,799 --> 00:21:52,340
execution as well so here we go so way

430
00:21:50,120 --> 00:21:54,678
back in 2005 and I bring this one up I

431
00:21:52,340 --> 00:21:58,370
loved it because this was probably the

432
00:21:54,679 --> 00:21:59,240
first first indication that something

433
00:21:58,370 --> 00:22:00,979
was just not right

434
00:21:59,240 --> 00:22:03,649
we're running ahead of ourselves and

435
00:22:00,980 --> 00:22:05,570
we're building hardware without thinking

436
00:22:03,649 --> 00:22:07,129
the ramifications of some of the

437
00:22:05,570 --> 00:22:09,860
features were implementing it also

438
00:22:07,129 --> 00:22:13,219
illustrates that so this is 13 years ago

439
00:22:09,860 --> 00:22:16,279
so essentially this mindset this

440
00:22:13,220 --> 00:22:18,139
research is actually pretty old suddenly

441
00:22:16,279 --> 00:22:19,549
we had the meltdown specter stuff pop up

442
00:22:18,139 --> 00:22:21,949
this years if it came out of the blue

443
00:22:19,549 --> 00:22:23,690
but if you go all the way back to 2005

444
00:22:21,950 --> 00:22:25,789
even before that you'll see a lot of

445
00:22:23,690 --> 00:22:29,029
academic papers have been published on a

446
00:22:25,789 --> 00:22:32,720
lot of these research topics so in 2005

447
00:22:29,029 --> 00:22:35,149
Colin Percival published a what's called

448
00:22:32,720 --> 00:22:38,090
a cache timing attack against the shared

449
00:22:35,149 --> 00:22:41,000
cache future implementations in I think

450
00:22:38,090 --> 00:22:42,830
at the time it was the hyper-threading

451
00:22:41,000 --> 00:22:44,600
feature that was in the Pentium that was

452
00:22:42,830 --> 00:22:46,370
initially released in the Pentium 4 at

453
00:22:44,600 --> 00:22:48,918
the time so I don't know if any you

454
00:22:46,370 --> 00:22:52,600
remember there was a Pentium 4 his very

455
00:22:48,919 --> 00:22:56,389
short-lived not super successful

456
00:22:52,600 --> 00:23:01,070
actually it was very unsuccessful but

457
00:22:56,389 --> 00:23:03,139
they introduced this idea of can we make

458
00:23:01,070 --> 00:23:06,049
it look like the computer has 2 CPUs

459
00:23:03,139 --> 00:23:10,399
even if it only has one so can we do a

460
00:23:06,049 --> 00:23:14,179
lot of work in parallel by duplicating

461
00:23:10,399 --> 00:23:16,610
more components within the CPU without

462
00:23:14,179 --> 00:23:18,649
actually bolting another CPU on the

463
00:23:16,610 --> 00:23:23,149
motherboard and they did this by

464
00:23:18,649 --> 00:23:24,979
duplicating some hardware but not

465
00:23:23,149 --> 00:23:27,049
duplicating other hardware such as

466
00:23:24,980 --> 00:23:29,779
things like cache and everything which

467
00:23:27,049 --> 00:23:32,980
I'll get into in a little bit not

468
00:23:29,779 --> 00:23:36,019
duplicating Hardware such as memory

469
00:23:32,980 --> 00:23:37,010
access and stuff like that so the

470
00:23:36,019 --> 00:23:39,330
outcome of this

471
00:23:37,010 --> 00:23:41,220
results have been accidentally exposing

472
00:23:39,330 --> 00:23:43,110
a mechanism to identify whether values

473
00:23:41,220 --> 00:23:46,170
are cached in memory or not with a

474
00:23:43,110 --> 00:23:49,379
timing analysis attack it existed before

475
00:23:46,170 --> 00:23:52,050
this but this feature art should say the

476
00:23:49,380 --> 00:23:55,820
concept existed prior to this however

477
00:23:52,050 --> 00:24:00,000
this feature made it very very very easy

478
00:23:55,820 --> 00:24:04,200
to exploit so we'll jump into cache

479
00:24:00,000 --> 00:24:05,940
operation with a quick diagram don't

480
00:24:04,200 --> 00:24:07,350
need to understand all this I'm not even

481
00:24:05,940 --> 00:24:08,150
sure how many people program and see

482
00:24:07,350 --> 00:24:12,449
these days

483
00:24:08,150 --> 00:24:14,610
but basically take this piece of code in

484
00:24:12,450 --> 00:24:18,030
as an example so the idea here is that

485
00:24:14,610 --> 00:24:19,740
you have to source arrays you're trying

486
00:24:18,030 --> 00:24:22,320
to do a matrix addition operation here

487
00:24:19,740 --> 00:24:23,880
so you have two arrays and you want to

488
00:24:22,320 --> 00:24:27,300
add all the values in each array and

489
00:24:23,880 --> 00:24:29,240
then store those in a third array so the

490
00:24:27,300 --> 00:24:34,740
way that most computers organize this is

491
00:24:29,240 --> 00:24:38,479
that these three arrays here are located

492
00:24:34,740 --> 00:24:42,389
in sequential memory segments right here

493
00:24:38,479 --> 00:24:46,169
and then if you walk across it so this

494
00:24:42,389 --> 00:24:48,238
basically goes from one although you

495
00:24:46,169 --> 00:24:50,580
know basically from this one down here

496
00:24:48,239 --> 00:24:52,289
this one down here adds each cell

497
00:24:50,580 --> 00:24:55,649
together and then stores them in a Cell

498
00:24:52,289 --> 00:24:58,789
right here historically what would

499
00:24:55,649 --> 00:25:01,168
happen is your processor would want look

500
00:24:58,789 --> 00:25:03,359
apologies historically what happen is

501
00:25:01,169 --> 00:25:05,700
your processor would want to go and

502
00:25:03,359 --> 00:25:08,158
basically take one from here take one

503
00:25:05,700 --> 00:25:11,099
from here add them together store it

504
00:25:08,159 --> 00:25:12,719
here then take one take the next one

505
00:25:11,099 --> 00:25:15,539
from here take the next one from here at

506
00:25:12,719 --> 00:25:17,519
it store it in here the problem is that

507
00:25:15,539 --> 00:25:21,440
as processors got to be a lot faster

508
00:25:17,519 --> 00:25:24,809
like pretend this guy is 3.2 gigahertz

509
00:25:21,440 --> 00:25:27,149
memory is still a lot slower than that

510
00:25:24,809 --> 00:25:29,339
maybe 1 gigahertz maybe less maybe 800

511
00:25:27,149 --> 00:25:31,199
megahertz something like that I kind of

512
00:25:29,339 --> 00:25:35,849
gave a rough thing maybe 10 times slower

513
00:25:31,200 --> 00:25:40,559
than the CPU if I do that I can only run

514
00:25:35,849 --> 00:25:42,299
as fast as my fastest memory so to try

515
00:25:40,559 --> 00:25:44,399
and get around that what they ended up

516
00:25:42,299 --> 00:25:47,519
doing was they came up with this idea of

517
00:25:44,399 --> 00:25:50,428
caching the data locally every time CPU

518
00:25:47,519 --> 00:25:54,059
talks to this much much much smaller but

519
00:25:50,429 --> 00:25:56,429
much much faster piece of memory that's

520
00:25:54,059 --> 00:25:57,989
actually attached to the CPU and then

521
00:25:56,429 --> 00:26:01,740
what they'll do is the first time that

522
00:25:57,989 --> 00:26:04,440
the CPU wants something from a

523
00:26:01,740 --> 00:26:07,650
all of a is actually loaded into the

524
00:26:04,440 --> 00:26:09,150
CPUs memory and then from there it

525
00:26:07,650 --> 00:26:10,740
basically walks through a by going back

526
00:26:09,150 --> 00:26:16,340
and forth right here without ever

527
00:26:10,740 --> 00:26:18,690
touching this again so what happens is

528
00:26:16,340 --> 00:26:21,178
if you end up having this CPU that's

529
00:26:18,690 --> 00:26:22,710
doing the work and then you end up

530
00:26:21,179 --> 00:26:24,960
duplicating it over here with another

531
00:26:22,710 --> 00:26:30,620
CPU that's doing the work and they're

532
00:26:24,960 --> 00:26:33,420
sharing this cache memory right here if

533
00:26:30,620 --> 00:26:35,580
this guy retrieves memory from a and

534
00:26:33,420 --> 00:26:37,950
then the other CPU tries to also

535
00:26:35,580 --> 00:26:40,199
retrieve memory from a the first time it

536
00:26:37,950 --> 00:26:42,360
pulls the first element from a it takes

537
00:26:40,200 --> 00:26:45,030
a long time it takes memory time it

538
00:26:42,360 --> 00:26:47,070
takes 10 times the speed to get it the

539
00:26:45,030 --> 00:26:49,910
second time it wants something from a if

540
00:26:47,070 --> 00:26:53,040
it's only going here then it's immediate

541
00:26:49,910 --> 00:26:56,070
it's fast whoops this thing's a little

542
00:26:53,040 --> 00:26:57,809
touchy apologies so if you have a second

543
00:26:56,070 --> 00:27:02,070
CPU running over here that just happens

544
00:26:57,809 --> 00:27:03,450
to basically be waiting on a it can

545
00:27:02,070 --> 00:27:07,260
learn that stuff is being read from a

546
00:27:03,450 --> 00:27:08,340
whoops by looking and comparing the

547
00:27:07,260 --> 00:27:10,679
amount of time it takes to read

548
00:27:08,340 --> 00:27:12,570
something from a so that seems innocuous

549
00:27:10,679 --> 00:27:16,410
at first and we'll get into why that

550
00:27:12,570 --> 00:27:18,570
significant but anyway I kind of wanted

551
00:27:16,410 --> 00:27:20,640
to give a real quick refresher on or

552
00:27:18,570 --> 00:27:23,340
brief explanation as to how this works

553
00:27:20,640 --> 00:27:25,530
the basic idea here is like think of

554
00:27:23,340 --> 00:27:27,659
this as if I went to the grocery store

555
00:27:25,530 --> 00:27:30,450
for every single ingredient I wanted for

556
00:27:27,660 --> 00:27:30,870
a recipe whenever I needed it at that

557
00:27:30,450 --> 00:27:32,940
moment

558
00:27:30,870 --> 00:27:35,909
think of how slow that would be that's

559
00:27:32,940 --> 00:27:36,540
why I go to the grocery store like once

560
00:27:35,910 --> 00:27:38,820
a week

561
00:27:36,540 --> 00:27:40,980
buy all the things I need and then keep

562
00:27:38,820 --> 00:27:42,960
them at home this cashier is my home

563
00:27:40,980 --> 00:27:44,730
that's the fridge of the pantry or

564
00:27:42,960 --> 00:27:50,070
whatever and this is the grocery store

565
00:27:44,730 --> 00:27:51,750
so there we go so this kind of runs down

566
00:27:50,070 --> 00:27:54,629
a lot of what I was talking through in

567
00:27:51,750 --> 00:27:57,000
the diagram I won't dwell on this slide

568
00:27:54,630 --> 00:28:00,059
too much but the important thing here is

569
00:27:57,000 --> 00:28:02,400
that I can learn if something was read

570
00:28:00,059 --> 00:28:04,110
from memory or not or if a particular

571
00:28:02,400 --> 00:28:06,600
address in memory was actually accessed

572
00:28:04,110 --> 00:28:09,990
by another processor just by trying to

573
00:28:06,600 --> 00:28:11,699
figure out how quick or slow it took me

574
00:28:09,990 --> 00:28:13,090
to try and read something from that cell

575
00:28:11,700 --> 00:28:19,389
in memory

576
00:28:13,090 --> 00:28:21,879
so the common like attack techniques

577
00:28:19,389 --> 00:28:24,570
that are used for this one of them is

578
00:28:21,879 --> 00:28:28,509
covert channels so that's a way of

579
00:28:24,570 --> 00:28:31,029
communicating data between two cysteine

580
00:28:28,509 --> 00:28:34,779
basically two processes that may be Bo

581
00:28:31,029 --> 00:28:37,120
that may be aware of one another without

582
00:28:34,779 --> 00:28:39,249
that necessarily showing up physically

583
00:28:37,120 --> 00:28:40,689
in RAM and the other one is private data

584
00:28:39,249 --> 00:28:43,720
theft also known as snooping

585
00:28:40,690 --> 00:28:46,869
so trying to steal information so leave

586
00:28:43,720 --> 00:28:48,749
this up here for a moment you know this

587
00:28:46,869 --> 00:28:51,279
right here is the quick is the

588
00:28:48,749 --> 00:28:53,559
description of the math that works here

589
00:28:51,279 --> 00:28:56,110
and again this and it's this in itself

590
00:28:53,559 --> 00:28:58,658
is not the exploit this is one piece of

591
00:28:56,110 --> 00:29:01,258
the exploit just to jump back here for a

592
00:28:58,659 --> 00:29:03,309
moment there's a lot of features here

593
00:29:01,259 --> 00:29:05,860
one of these features is invulnerable

594
00:29:03,309 --> 00:29:09,580
the combination of these features

595
00:29:05,860 --> 00:29:12,008
creates a vulnerable complex system so

596
00:29:09,580 --> 00:29:14,139
this is one thing that can leak a little

597
00:29:12,009 --> 00:29:18,490
bit of information that on its own right

598
00:29:14,139 --> 00:29:19,899
seems innocuous so some attack

599
00:29:18,490 --> 00:29:22,240
mitigations if you actually did feel

600
00:29:19,899 --> 00:29:23,939
this information was you know important

601
00:29:22,240 --> 00:29:26,970
to try and prevent someone from seeing

602
00:29:23,940 --> 00:29:29,080
these are some ways to work around it

603
00:29:26,970 --> 00:29:30,999
unfortunately as you can see every

604
00:29:29,080 --> 00:29:35,230
single one of them comes with some sort

605
00:29:30,999 --> 00:29:36,970
of penalty that takes away some of that

606
00:29:35,230 --> 00:29:39,399
ideal goal that I was talking about

607
00:29:36,970 --> 00:29:42,429
earlier it makes it more expensive it

608
00:29:39,399 --> 00:29:45,668
decreases performance so it reduces the

609
00:29:42,429 --> 00:29:49,059
superscalar Ness of the processor and

610
00:29:45,669 --> 00:29:50,830
that's why you see a lot of people who

611
00:29:49,059 --> 00:29:52,658
may be resistant you see a lot of

612
00:29:50,830 --> 00:29:54,509
architectures that may be resistant to

613
00:29:52,659 --> 00:29:57,070
trying to implement things like this

614
00:29:54,509 --> 00:29:58,600
because every single one of them makes

615
00:29:57,070 --> 00:30:00,700
the processor a little bit slower and as

616
00:29:58,600 --> 00:30:03,120
we all know that's a very competitive

617
00:30:00,700 --> 00:30:06,360
market right now

618
00:30:03,120 --> 00:30:08,719
so I'm getting to the next feature which

619
00:30:06,360 --> 00:30:12,149
is pipelining instruction level

620
00:30:08,720 --> 00:30:15,720
parallelism so this is how you move from

621
00:30:12,150 --> 00:30:18,930
having a very slow processor that can

622
00:30:15,720 --> 00:30:20,400
execute maybe one instruction every few

623
00:30:18,930 --> 00:30:22,740
cycles through having something that can

624
00:30:20,400 --> 00:30:25,710
execute maybe multiple instructions in

625
00:30:22,740 --> 00:30:32,330
one clock cycle you know more than 3.2

626
00:30:25,710 --> 00:30:38,490
gigahertz worth of work in a second so

627
00:30:32,330 --> 00:30:40,800
many operations that you deal with or or

628
00:30:38,490 --> 00:30:42,720
I should say many algorithms are complex

629
00:30:40,800 --> 00:30:46,110
operations that perform like multiple

630
00:30:42,720 --> 00:30:48,120
steps so for instance multiplication or

631
00:30:46,110 --> 00:30:50,010
division in the processor that doesn't

632
00:30:48,120 --> 00:30:54,139
happen in one clock cycle a lot of times

633
00:30:50,010 --> 00:30:56,940
that takes multiple clock cycles to work

634
00:30:54,140 --> 00:31:00,030
because of this the CPU actually breaks

635
00:30:56,940 --> 00:31:02,850
a lot of those operations up into

636
00:31:00,030 --> 00:31:05,100
discrete steps so you can think of it as

637
00:31:02,850 --> 00:31:07,260
like a recipe book or whatever right so

638
00:31:05,100 --> 00:31:10,370
in order to do a multiplication of two

639
00:31:07,260 --> 00:31:12,960
numbers step one get the first number

640
00:31:10,370 --> 00:31:14,699
and put it on the table step two get the

641
00:31:12,960 --> 00:31:16,890
second number put it on the table

642
00:31:14,700 --> 00:31:18,300
step three do the sequence of steps

643
00:31:16,890 --> 00:31:19,980
where you put them on top of each other

644
00:31:18,300 --> 00:31:22,740
and do the multiplication work and

645
00:31:19,980 --> 00:31:26,090
everything right step four you have a

646
00:31:22,740 --> 00:31:29,250
result step five put that somewhere so

647
00:31:26,090 --> 00:31:32,189
remember the computer's not really all

648
00:31:29,250 --> 00:31:35,670
that intelligent it just does what it's

649
00:31:32,190 --> 00:31:40,380
told to do exactly very very very very

650
00:31:35,670 --> 00:31:41,700
well and very fast so the a lot of these

651
00:31:40,380 --> 00:31:44,400
units are designed to execute in

652
00:31:41,700 --> 00:31:45,870
parallel on staggered fragments of the

653
00:31:44,400 --> 00:31:49,650
original instructions so this is a real

654
00:31:45,870 --> 00:31:52,709
common table that's built up and some of

655
00:31:49,650 --> 00:31:54,300
you who may have taken CS or Computer

656
00:31:52,710 --> 00:31:55,830
Engineering or something like that might

657
00:31:54,300 --> 00:31:59,700
recognize it but the idea here is that

658
00:31:55,830 --> 00:32:01,740
each one of these things is a component

659
00:31:59,700 --> 00:32:04,950
so it's a circuitry physical circuitry

660
00:32:01,740 --> 00:32:07,170
within the processor I colored these

661
00:32:04,950 --> 00:32:10,440
things here to show you each of the

662
00:32:07,170 --> 00:32:13,230
instructions moving through the stages

663
00:32:10,440 --> 00:32:14,940
and then this is time so this is the

664
00:32:13,230 --> 00:32:16,200
first clock cycle this or you can

665
00:32:14,940 --> 00:32:19,649
pretend this is set

666
00:32:16,200 --> 00:32:21,269
zero right second one second two second

667
00:32:19,649 --> 00:32:23,459
three second four so this is a timing

668
00:32:21,269 --> 00:32:27,450
diagram basically and then I have some

669
00:32:23,460 --> 00:32:30,870
details as to what these mean but the

670
00:32:27,450 --> 00:32:34,230
idea here is that at the first you know

671
00:32:30,870 --> 00:32:35,879
first second or first clock I'm fetching

672
00:32:34,230 --> 00:32:37,980
the instruction from memory so I don't

673
00:32:35,880 --> 00:32:40,019
know what it says I don't know what's

674
00:32:37,980 --> 00:32:42,419
telling me to do until I actually read

675
00:32:40,019 --> 00:32:44,549
it the second one I actually need to

676
00:32:42,419 --> 00:32:48,269
decode it into what work that I need to

677
00:32:44,549 --> 00:32:50,789
do the third third second I actually

678
00:32:48,269 --> 00:32:52,019
need to go to memory and put the stuff

679
00:32:50,789 --> 00:32:55,919
on the table that I was talking about

680
00:32:52,019 --> 00:33:00,870
etc the interesting thing about this is

681
00:32:55,919 --> 00:33:03,299
that if I was not to start loading in

682
00:33:00,870 --> 00:33:06,229
the next instructions while I've moved

683
00:33:03,299 --> 00:33:09,779
this one forward I would end up with

684
00:33:06,230 --> 00:33:13,019
basically processor performance that's

685
00:33:09,779 --> 00:33:15,750
like 20% of my clock cycle because I

686
00:33:13,019 --> 00:33:17,909
would have to do every five of these

687
00:33:15,750 --> 00:33:19,710
things before I could even start doing

688
00:33:17,909 --> 00:33:22,409
the first one you know the first stage

689
00:33:19,710 --> 00:33:24,779
on the next instruction the other thing

690
00:33:22,409 --> 00:33:28,260
that this reveals and I think I have

691
00:33:24,779 --> 00:33:32,250
this on the next slide is that by the

692
00:33:28,260 --> 00:33:35,120
time I get here so for transitions in by

693
00:33:32,250 --> 00:33:37,350
the time I get here I am in I am

694
00:33:35,120 --> 00:33:40,559
partially executing five different

695
00:33:37,350 --> 00:33:43,980
instructions at once so I managed to

696
00:33:40,559 --> 00:33:47,690
approach my you know approach my

697
00:33:43,980 --> 00:33:50,610
maximize work load which is you know

698
00:33:47,690 --> 00:33:52,350
being able to run five things at once in

699
00:33:50,610 --> 00:33:56,240
the processor but the other thing is

700
00:33:52,350 --> 00:33:58,529
that if we step here to like time three

701
00:33:56,240 --> 00:34:00,809
this instruction hasn't finished

702
00:33:58,529 --> 00:34:03,510
executing yet before I'm already

703
00:34:00,809 --> 00:34:05,908
starting to do work on the three

704
00:34:03,510 --> 00:34:09,649
instructions ahead of it how do I even

705
00:34:05,909 --> 00:34:12,089
know that this one's worth executing

706
00:34:09,649 --> 00:34:13,739
because as we all know you can have if

707
00:34:12,089 --> 00:34:15,449
statements or while statements you can

708
00:34:13,739 --> 00:34:17,219
basically have like jumps and stuff like

709
00:34:15,449 --> 00:34:20,939
that in your code I don't know

710
00:34:17,219 --> 00:34:23,279
necessarily if I'm able to run this I'm

711
00:34:20,940 --> 00:34:24,750
actually speculating here I'm more I

712
00:34:23,280 --> 00:34:26,040
should say the processor is actually

713
00:34:24,750 --> 00:34:28,349
speculating here the processor just

714
00:34:26,040 --> 00:34:29,699
assumes that all the following

715
00:34:28,349 --> 00:34:32,010
instructions ahead of the curve

716
00:34:29,699 --> 00:34:37,230
one I'm working on are probably going to

717
00:34:32,010 --> 00:34:39,480
be run so and I kind of lay that out

718
00:34:37,230 --> 00:34:42,570
right here so the other thing too is

719
00:34:39,480 --> 00:34:44,460
that so for instance this one right here

720
00:34:42,570 --> 00:34:47,339
will jump to this one right here right

721
00:34:44,460 --> 00:34:50,190
so while this one's storing its result

722
00:34:47,339 --> 00:34:52,918
back into memory instruction three is

723
00:34:50,190 --> 00:34:55,230
already loading the data that it relies

724
00:34:52,918 --> 00:34:57,000
on from memory and then the second

725
00:34:55,230 --> 00:34:59,329
instruction already did that so I've

726
00:34:57,000 --> 00:35:02,329
basically loaded data from three places

727
00:34:59,329 --> 00:35:07,740
while I've only completed one operation

728
00:35:02,329 --> 00:35:12,240
so speculative execution so we're gonna

729
00:35:07,740 --> 00:35:13,618
speculate on speculation so consider the

730
00:35:12,240 --> 00:35:15,359
following instruction sequence and I

731
00:35:13,619 --> 00:35:16,589
didn't do assembly language what I did

732
00:35:15,359 --> 00:35:19,920
is I turn to some of the language and a

733
00:35:16,589 --> 00:35:22,529
math for this but every single one of

734
00:35:19,920 --> 00:35:26,550
these things reduces into on assembly

735
00:35:22,530 --> 00:35:27,990
language like you know instruction in

736
00:35:26,550 --> 00:35:30,270
pretty much every single architecture

737
00:35:27,990 --> 00:35:31,589
and the point of this is that the

738
00:35:30,270 --> 00:35:34,259
vulnerabilities I'm talking about today

739
00:35:31,589 --> 00:35:36,089
actually apply across the board so

740
00:35:34,260 --> 00:35:38,640
they're not limited to just your Intel

741
00:35:36,089 --> 00:35:40,200
processor now these are you know

742
00:35:38,640 --> 00:35:42,839
features that I'm talking about here

743
00:35:40,200 --> 00:35:49,129
that exist in every single CPU since

744
00:35:42,839 --> 00:35:51,150
like the Pentium Pro and the AMD 29k so

745
00:35:49,130 --> 00:35:52,589
consider the following algorithm this

746
00:35:51,150 --> 00:35:57,750
one seems pretty straightforward right

747
00:35:52,589 --> 00:35:59,310
so you know a is one B's for multiply

748
00:35:57,750 --> 00:36:02,670
the two of them together and overwrite B

749
00:35:59,310 --> 00:36:04,950
with whatever that result is then add

750
00:36:02,670 --> 00:36:06,900
them together so add a and B together

751
00:36:04,950 --> 00:36:08,910
and then store the result in a so then

752
00:36:06,900 --> 00:36:12,690
by here the original values of a and B

753
00:36:08,910 --> 00:36:16,250
are trashed and B and a have new kind of

754
00:36:12,690 --> 00:36:18,540
combined values not only that but a

755
00:36:16,250 --> 00:36:21,000
contains what you'd expect to be the

756
00:36:18,540 --> 00:36:26,160
result of the operation

757
00:36:21,000 --> 00:36:27,780
likewise then store five in c8 and D do

758
00:36:26,160 --> 00:36:30,589
the same thing here multiplied two

759
00:36:27,780 --> 00:36:32,880
together over right C and then finally

760
00:36:30,590 --> 00:36:36,330
take the initial one that was computed

761
00:36:32,880 --> 00:36:37,920
up here and then add this value here to

762
00:36:36,330 --> 00:36:44,400
get a final value for say the whole

763
00:36:37,920 --> 00:36:47,090
function so getting back to how you can

764
00:36:44,400 --> 00:36:50,040
execute multiple instructions at once

765
00:36:47,090 --> 00:36:53,010
that requires the processor to figure

766
00:36:50,040 --> 00:36:55,290
out what the dependencies are between

767
00:36:53,010 --> 00:36:57,930
all these for instance I can't do this

768
00:36:55,290 --> 00:37:01,109
instruction right here without first

769
00:36:57,930 --> 00:37:03,899
doing these two and this one so I can't

770
00:37:01,109 --> 00:37:06,598
do it so the processor needs to figure

771
00:37:03,900 --> 00:37:08,220
out those things highlighted in yellow

772
00:37:06,599 --> 00:37:10,740
are the ones that don't have what we

773
00:37:08,220 --> 00:37:13,490
call execution dependencies I can load

774
00:37:10,740 --> 00:37:18,118
all this data into these four variables

775
00:37:13,490 --> 00:37:19,859
into these four locations without

776
00:37:18,119 --> 00:37:23,010
waiting on anything else in this program

777
00:37:19,859 --> 00:37:25,369
in this very simple program highlighted

778
00:37:23,010 --> 00:37:28,260
Nakhla are the ones that have minimal

779
00:37:25,369 --> 00:37:30,750
dependencies and by minimal dependencies

780
00:37:28,260 --> 00:37:34,589
I mean they don't depend on any prior

781
00:37:30,750 --> 00:37:38,180
math they only depend on again let me

782
00:37:34,589 --> 00:37:38,180
get back to that cashing diagram right

783
00:37:38,540 --> 00:37:45,509
this one they only depend on this part

784
00:37:43,440 --> 00:37:48,950
of the CPU the part that brings stuff

785
00:37:45,510 --> 00:37:48,950
out of memory and into the cache

786
00:37:52,830 --> 00:37:58,860
because of that a modern CPU might

787
00:37:57,090 --> 00:38:02,460
actually choose to rework a lot of this

788
00:37:58,860 --> 00:38:05,760
stuff so that it can execute more of the

789
00:38:02,460 --> 00:38:09,960
work concurrently for instance because I

790
00:38:05,760 --> 00:38:12,270
can load large rows of memory into the

791
00:38:09,960 --> 00:38:14,430
processor at once in a single memory

792
00:38:12,270 --> 00:38:17,130
read operation rather than doing all

793
00:38:14,430 --> 00:38:19,230
four of these as four separate memory

794
00:38:17,130 --> 00:38:23,070
read operations how about if I just read

795
00:38:19,230 --> 00:38:24,330
all of them at once in one big operation

796
00:38:23,070 --> 00:38:28,550
here so how about if I join them

797
00:38:24,330 --> 00:38:32,160
together additionally what I've done is

798
00:38:28,550 --> 00:38:35,430
this operation down here actually moved

799
00:38:32,160 --> 00:38:38,640
up just above this one right here so

800
00:38:35,430 --> 00:38:40,049
this little whatever you call this

801
00:38:38,640 --> 00:38:43,109
little margin right here between the two

802
00:38:40,050 --> 00:38:46,470
lines that's where this computation to

803
00:38:43,110 --> 00:38:49,920
get the end value of C happens so I

804
00:38:46,470 --> 00:38:55,799
think I'd sure that there the important

805
00:38:49,920 --> 00:38:57,750
thing is that this computation doesn't

806
00:38:55,800 --> 00:39:00,330
actually rely upon this at all to work

807
00:38:57,750 --> 00:39:03,090
so you can perhaps in this case the

808
00:39:00,330 --> 00:39:06,720
processor has broken up the mathematical

809
00:39:03,090 --> 00:39:08,040
you know work into maybe three different

810
00:39:06,720 --> 00:39:09,990
pieces of circuitry or two different

811
00:39:08,040 --> 00:39:12,990
pieces of circuitry so it can do these

812
00:39:09,990 --> 00:39:15,859
two at the same time the interesting

813
00:39:12,990 --> 00:39:15,859
thing about that is

814
00:39:17,010 --> 00:39:23,700
when I wrote the program my expectation

815
00:39:21,600 --> 00:39:26,730
was that I would do this work first a

816
00:39:23,700 --> 00:39:29,368
equals eight equals a plus B I would do

817
00:39:26,730 --> 00:39:31,920
that first before the processor does any

818
00:39:29,369 --> 00:39:35,040
of these three great that was how I

819
00:39:31,920 --> 00:39:38,400
wrote the program to work the problem is

820
00:39:35,040 --> 00:39:40,830
that that's not how the processor made

821
00:39:38,400 --> 00:39:45,900
the program work the processor actually

822
00:39:40,830 --> 00:39:49,500
made the program run this before this

823
00:39:45,900 --> 00:39:57,050
happens or these two happen which means

824
00:39:49,500 --> 00:39:57,050
that when a plus B gets executed

825
00:39:57,119 --> 00:40:02,670
I have the processor has already done

826
00:39:59,970 --> 00:40:09,049
the same memory loading work for these

827
00:40:02,670 --> 00:40:11,249
right here and this so what happens if

828
00:40:09,049 --> 00:40:14,190
this right here runs into an air

829
00:40:11,249 --> 00:40:15,480
condition for instance these two are not

830
00:40:14,190 --> 00:40:18,749
values that can be added together or

831
00:40:15,480 --> 00:40:21,509
something like that the way I wrote the

832
00:40:18,749 --> 00:40:23,129
program I might have had it I might have

833
00:40:21,509 --> 00:40:27,029
had the Assumption bead that I can do

834
00:40:23,130 --> 00:40:31,349
all this work after this condition has

835
00:40:27,029 --> 00:40:34,950
been satisfied it's you know if that

836
00:40:31,349 --> 00:40:36,960
operation is not invalid so if that

837
00:40:34,950 --> 00:40:39,029
operation doesn't fail right it doesn't

838
00:40:36,960 --> 00:40:41,400
cause an error then all this work

839
00:40:39,029 --> 00:40:42,480
happens the processor reordered it so

840
00:40:41,400 --> 00:40:45,859
that that work happens no matter what

841
00:40:42,480 --> 00:40:48,690
and then if this causes an error

842
00:40:45,859 --> 00:40:50,549
the architects concept the architects

843
00:40:48,690 --> 00:40:53,940
philosophy is that oh well in that case

844
00:40:50,549 --> 00:40:55,369
I just wasted my time I did a bunch of

845
00:40:53,940 --> 00:40:57,930
extra work that I'll just throw away

846
00:40:55,369 --> 00:41:00,390
that was the kind of architect mentality

847
00:40:57,930 --> 00:41:03,149
and the benefit was that I can still

848
00:41:00,390 --> 00:41:05,609
have a faster processor the consequence

849
00:41:03,150 --> 00:41:08,009
is that there is work that went into

850
00:41:05,609 --> 00:41:09,480
these woods based upon say another

851
00:41:08,009 --> 00:41:15,140
feature in the processor the caching

852
00:41:09,480 --> 00:41:17,619
piece that also leaks some information

853
00:41:15,140 --> 00:41:21,049
so another piece that's here is um

854
00:41:17,619 --> 00:41:23,869
complex array indexing so this is the

855
00:41:21,049 --> 00:41:26,089
work that processors were originally

856
00:41:23,869 --> 00:41:28,670
invented for so electronic computers

857
00:41:26,089 --> 00:41:31,009
originally invented to handle large

858
00:41:28,670 --> 00:41:32,869
matrix operations basically to do your

859
00:41:31,009 --> 00:41:35,599
spreadsheets on the computer instead of

860
00:41:32,869 --> 00:41:38,029
by hand right so if you go all the way

861
00:41:35,599 --> 00:41:39,489
back to like the work that like IBM and

862
00:41:38,029 --> 00:41:42,259
NASA did and everything like that as

863
00:41:39,489 --> 00:41:48,109
tabulation work large table calculations

864
00:41:42,259 --> 00:41:49,910
things like that so one of the

865
00:41:48,109 --> 00:41:52,759
interesting things this gets a little

866
00:41:49,910 --> 00:41:55,279
bit into kind of memory nomenclature and

867
00:41:52,759 --> 00:41:56,960
everything but one of the interesting

868
00:41:55,279 --> 00:42:01,099
things is that they came up with all

869
00:41:56,960 --> 00:42:03,109
these very complex ways to refer to data

870
00:42:01,099 --> 00:42:06,859
in the table that's in a nutshell what

871
00:42:03,109 --> 00:42:08,598
all this is so you can either say oh you

872
00:42:06,859 --> 00:42:11,269
know if I have a list of numbers the

873
00:42:08,599 --> 00:42:12,859
seventh number right I can even tell it

874
00:42:11,269 --> 00:42:17,538
to give me different data sizes for each

875
00:42:12,859 --> 00:42:19,578
one of those things I can maybe have not

876
00:42:17,539 --> 00:42:22,999
just one column but I can have columns

877
00:42:19,579 --> 00:42:24,650
and rows so I can have maybe B tells me

878
00:42:22,999 --> 00:42:25,970
what the column is and C tells me what

879
00:42:24,650 --> 00:42:30,049
the row is or something like that

880
00:42:25,970 --> 00:42:31,730
ditto for this we have a few simplistic

881
00:42:30,049 --> 00:42:34,038
things here it actually gets quite more

882
00:42:31,730 --> 00:42:35,299
complex when you dive into the assembly

883
00:42:34,039 --> 00:42:37,190
language and I didn't necessarily want

884
00:42:35,299 --> 00:42:40,069
to give an entire presentation on that

885
00:42:37,190 --> 00:42:42,200
but in a nutshell I have a bunch of

886
00:42:40,069 --> 00:42:47,058
circuitry built into the processor that

887
00:42:42,200 --> 00:42:49,460
allows me to do math on the indexes into

888
00:42:47,059 --> 00:42:51,650
my array in all sorts of complex ways

889
00:42:49,460 --> 00:42:54,499
and some of these are native so some of

890
00:42:51,650 --> 00:42:58,099
these are built-in others are operations

891
00:42:54,499 --> 00:42:59,689
that I can create by stringing multiple

892
00:42:58,099 --> 00:43:01,069
different steps together multiple

893
00:42:59,690 --> 00:43:03,890
different instructions together such as

894
00:43:01,069 --> 00:43:07,099
this one and that's a left shift for

895
00:43:03,890 --> 00:43:09,980
instance a complex operation leveraging

896
00:43:07,099 --> 00:43:13,999
you know the mathematical or arithmetic

897
00:43:09,980 --> 00:43:15,950
unit plus you know some other work so

898
00:43:13,999 --> 00:43:20,328
this is kind of remember we invented

899
00:43:15,950 --> 00:43:21,890
these things originally to do you know

900
00:43:20,329 --> 00:43:23,660
tabular calculations and things like

901
00:43:21,890 --> 00:43:26,239
that not to play Minecraft or anything

902
00:43:23,660 --> 00:43:27,558
or overwatch or anything like that these

903
00:43:26,239 --> 00:43:28,580
things were originally created to do

904
00:43:27,559 --> 00:43:30,650
this stuff

905
00:43:28,580 --> 00:43:34,279
basically do matrix math do this stuff

906
00:43:30,650 --> 00:43:38,300
very very very efficiency or efficiently

907
00:43:34,280 --> 00:43:41,810
and at very high dimensions so this one

908
00:43:38,300 --> 00:43:44,360
is the one I'm gonna hone in on for the

909
00:43:41,810 --> 00:43:47,840
next uh for the next feature right and

910
00:43:44,360 --> 00:43:51,410
the next feature combines all of the

911
00:43:47,840 --> 00:43:55,100
things that we just saw in a very simple

912
00:43:51,410 --> 00:43:56,839
program to basically create that

913
00:43:55,100 --> 00:43:59,750
meltdown vulnerability so this is the

914
00:43:56,840 --> 00:44:02,360
one that many of the patches were pushed

915
00:43:59,750 --> 00:44:05,270
out for you know the ones that you saw

916
00:44:02,360 --> 00:44:06,970
the emergency patches from a number of

917
00:44:05,270 --> 00:44:09,800
cloud providers and things like that

918
00:44:06,970 --> 00:44:12,529
were pushed out to close this particular

919
00:44:09,800 --> 00:44:15,920
vulnerability the was at the middle of

920
00:44:12,530 --> 00:44:17,450
the night like undisclosed Linux patches

921
00:44:15,920 --> 00:44:19,820
that went in that then were explained

922
00:44:17,450 --> 00:44:23,180
after they went in that was these all

923
00:44:19,820 --> 00:44:25,430
the the super say the out of out of band

924
00:44:23,180 --> 00:44:28,009
non Super Tuesday patches the one in the

925
00:44:25,430 --> 00:44:30,080
Windows this vulnerability this is also

926
00:44:28,010 --> 00:44:35,240
the one that primarily affected Intel

927
00:44:30,080 --> 00:44:37,580
CPUs so again I converted it and I

928
00:44:35,240 --> 00:44:39,140
simplified it a bit so it takes a little

929
00:44:37,580 --> 00:44:41,210
bit more work than what I show up here

930
00:44:39,140 --> 00:44:45,680
but at its core it's three basic steps

931
00:44:41,210 --> 00:44:47,210
so remember I talked about how you have

932
00:44:45,680 --> 00:44:49,250
the concept of privileged and

933
00:44:47,210 --> 00:44:52,790
unprivileged memory you have the memory

934
00:44:49,250 --> 00:44:55,040
that is your private key great where

935
00:44:52,790 --> 00:44:58,670
that works done versus the memory that

936
00:44:55,040 --> 00:45:00,050
is your Facebook posts so both of them

937
00:44:58,670 --> 00:45:05,060
are running code both of them are

938
00:45:00,050 --> 00:45:08,360
running programs will say that B happens

939
00:45:05,060 --> 00:45:10,759
to be something that is a memory where

940
00:45:08,360 --> 00:45:13,010
your private key is located something

941
00:45:10,760 --> 00:45:16,430
like that and then will say that C

942
00:45:13,010 --> 00:45:17,930
happens to be memory where a random

943
00:45:16,430 --> 00:45:22,549
facebook program is running or something

944
00:45:17,930 --> 00:45:26,839
like that so what happens is first you

945
00:45:22,550 --> 00:45:29,180
may try and bring some data out of that

946
00:45:26,840 --> 00:45:32,930
privileged memory and store it in this

947
00:45:29,180 --> 00:45:34,399
variable X obviously that's going to

948
00:45:32,930 --> 00:45:36,290
result in an error of some sort

949
00:45:34,400 --> 00:45:39,230
sometimes that error might just be to

950
00:45:36,290 --> 00:45:41,009
give you a you know give you a junk

951
00:45:39,230 --> 00:45:42,960
value give you an error code for this

952
00:45:41,010 --> 00:45:44,190
other times that might be to throw to

953
00:45:42,960 --> 00:45:45,390
cause what's called an exception or

954
00:45:44,190 --> 00:45:47,340
interrupt your program while it's

955
00:45:45,390 --> 00:45:49,379
running well the interesting thing about

956
00:45:47,340 --> 00:45:51,420
this is that if you get back to the

957
00:45:49,380 --> 00:45:57,720
pipelining thing that I was talking

958
00:45:51,420 --> 00:46:02,040
about back here this remember that by

959
00:45:57,720 --> 00:46:04,200
the time we get to executing that that

960
00:46:02,040 --> 00:46:06,029
first inch or yeah by the time I get to

961
00:46:04,200 --> 00:46:07,710
executing that first instruction we've

962
00:46:06,030 --> 00:46:09,750
already started doing work on the next

963
00:46:07,710 --> 00:46:11,880
three right and this is a simplified

964
00:46:09,750 --> 00:46:13,619
thing the architecture for your Intel

965
00:46:11,880 --> 00:46:15,960
chips goes much deeper than this so

966
00:46:13,619 --> 00:46:20,130
we're actually executing maybe 15 or 20

967
00:46:15,960 --> 00:46:23,190
instructions ahead of time for that so

968
00:46:20,130 --> 00:46:24,690
let's get back over here so basically

969
00:46:23,190 --> 00:46:27,330
what I mean is by the time you realize

970
00:46:24,690 --> 00:46:30,960
that you aren't allowed to read this

971
00:46:27,330 --> 00:46:33,540
data here I should say by the time the

972
00:46:30,960 --> 00:46:35,400
CPU realizes that you've already started

973
00:46:33,540 --> 00:46:38,009
to do this work and you've already

974
00:46:35,400 --> 00:46:40,550
started to do this work and the

975
00:46:38,010 --> 00:46:43,770
processor identifies that right here

976
00:46:40,550 --> 00:46:45,750
this work is also trying to reference

977
00:46:43,770 --> 00:46:48,509
other memory that's in your program

978
00:46:45,750 --> 00:46:50,910
space that's in facebook facebook's

979
00:46:48,510 --> 00:46:53,190
memory space or something like that so

980
00:46:50,910 --> 00:46:55,920
right here you're doing a very simple

981
00:46:53,190 --> 00:46:58,859
calculation based on this data inside

982
00:46:55,920 --> 00:47:01,410
the processor they allow the speculative

983
00:46:58,859 --> 00:47:03,420
execution to pull this stuff out by

984
00:47:01,410 --> 00:47:06,000
passing a lot of the memory protections

985
00:47:03,420 --> 00:47:07,560
the checks that determine whether this

986
00:47:06,000 --> 00:47:09,690
memory is supposed to be read by

987
00:47:07,560 --> 00:47:12,180
such-and-such process because again

988
00:47:09,690 --> 00:47:14,130
their assumption is that they'll figure

989
00:47:12,180 --> 00:47:15,390
out whether or not the thing they've

990
00:47:14,130 --> 00:47:17,310
computed the thing that they've

991
00:47:15,390 --> 00:47:19,029
retrieved is something you're allowed to

992
00:47:17,310 --> 00:47:21,160
see

993
00:47:19,030 --> 00:47:23,440
after they finish executing this and

994
00:47:21,160 --> 00:47:26,620
they'll just discard the wasted effort

995
00:47:23,440 --> 00:47:28,780
the wasted work the interesting thing

996
00:47:26,620 --> 00:47:32,740
about this one is that I'm taking a

997
00:47:28,780 --> 00:47:35,770
value out of here right I'm taking data

998
00:47:32,740 --> 00:47:38,740
that's stored in private memory and then

999
00:47:35,770 --> 00:47:40,900
I'm using it to basically compute an

1000
00:47:38,740 --> 00:47:42,939
index into another array that I know of

1001
00:47:40,900 --> 00:47:45,700
so it's not just an array that I can

1002
00:47:42,940 --> 00:47:49,030
read get out of gets an array that I

1003
00:47:45,700 --> 00:47:51,069
pre-populated with data that maybe might

1004
00:47:49,030 --> 00:47:54,160
be a unique value in every single cell

1005
00:47:51,070 --> 00:47:57,490
or something like that and then I'm

1006
00:47:54,160 --> 00:48:00,399
storing that in Y so this right here is

1007
00:47:57,490 --> 00:48:04,299
something I'm allowed to see right I'm

1008
00:48:00,400 --> 00:48:05,950
allowed to view this I am basing the

1009
00:48:04,300 --> 00:48:07,780
index into this or what's called the

1010
00:48:05,950 --> 00:48:09,850
offset so I'm doing math here on the

1011
00:48:07,780 --> 00:48:12,670
memory to basically pull out something

1012
00:48:09,850 --> 00:48:16,049
that might be four steps or four slots

1013
00:48:12,670 --> 00:48:16,050
in front of the beginning of this array

1014
00:48:16,500 --> 00:48:23,320
based on whoops based on what was

1015
00:48:20,590 --> 00:48:25,030
private here so in a normal world what

1016
00:48:23,320 --> 00:48:27,040
happens is the processor throws a lot of

1017
00:48:25,030 --> 00:48:30,700
this away after it decides that I'm not

1018
00:48:27,040 --> 00:48:36,790
allowed to see the thing in reality what

1019
00:48:30,700 --> 00:48:38,740
ends up happening is right here sorry in

1020
00:48:36,790 --> 00:48:44,500
reality of what ends up happening is

1021
00:48:38,740 --> 00:48:48,069
that I've pre cached the data right here

1022
00:48:44,500 --> 00:48:49,900
and I can basically go back through

1023
00:48:48,070 --> 00:48:52,210
after I recover from this error after

1024
00:48:49,900 --> 00:48:53,830
I'm told that this didn't work I can go

1025
00:48:52,210 --> 00:48:57,670
back through and I can try and find out

1026
00:48:53,830 --> 00:49:01,870
oh sorry the button is working I can go

1027
00:48:57,670 --> 00:49:05,140
find out which of the slots in this

1028
00:49:01,870 --> 00:49:07,450
really big array come back very quickly

1029
00:49:05,140 --> 00:49:10,120
to me so which ones are a very quick

1030
00:49:07,450 --> 00:49:11,689
read versus which ones are very slow

1031
00:49:10,120 --> 00:49:15,078
read

1032
00:49:11,690 --> 00:49:17,960
and by doing that I can find out what

1033
00:49:15,079 --> 00:49:21,200
value X was right here that I multiplied

1034
00:49:17,960 --> 00:49:22,819
it by this number and then I can find

1035
00:49:21,200 --> 00:49:24,230
out what was computed here based on that

1036
00:49:22,819 --> 00:49:26,240
and that's kind of your timing attack in

1037
00:49:24,230 --> 00:49:27,950
a nutshell is I basically will go

1038
00:49:26,240 --> 00:49:30,589
through and try and read all the data in

1039
00:49:27,950 --> 00:49:31,970
this memory region right here and try

1040
00:49:30,589 --> 00:49:34,369
and figure out which data comes back

1041
00:49:31,970 --> 00:49:40,490
very quickly for me versus which data

1042
00:49:34,369 --> 00:49:44,359
comes back very slowly so and then this

1043
00:49:40,490 --> 00:49:46,399
is basically the this is the very

1044
00:49:44,359 --> 00:49:48,470
detailed explanation of all that so I

1045
00:49:46,400 --> 00:49:52,250
figured it'd be a lot easier for the

1046
00:49:48,470 --> 00:49:55,430
audience to basically show you using the

1047
00:49:52,250 --> 00:49:57,200
using the program there but on modern

1048
00:49:55,430 --> 00:50:00,140
processes you know again this is kind of

1049
00:49:57,200 --> 00:50:01,490
the core thing here bottom modern

1050
00:50:00,140 --> 00:50:03,788
processes architected with the

1051
00:50:01,490 --> 00:50:06,229
assumption that these internal details

1052
00:50:03,789 --> 00:50:09,349
are transparent to the running program

1053
00:50:06,230 --> 00:50:11,359
but there's no way to actually know that

1054
00:50:09,349 --> 00:50:13,730
basically note they assume that I can't

1055
00:50:11,359 --> 00:50:16,098
do what I just did and that's because

1056
00:50:13,730 --> 00:50:17,930
the whole concept of like memory timing

1057
00:50:16,099 --> 00:50:20,839
and everything like that falls into the

1058
00:50:17,930 --> 00:50:23,270
realm of something that's unpredictable

1059
00:50:20,839 --> 00:50:26,150
but not so unpredictable that it's

1060
00:50:23,270 --> 00:50:29,359
impossible to say judge within a certain

1061
00:50:26,150 --> 00:50:32,839
you know probability that you got the

1062
00:50:29,359 --> 00:50:35,299
right answer so that's kind of melt down

1063
00:50:32,839 --> 00:50:37,160
in a nutshell and as you can see I mean

1064
00:50:35,299 --> 00:50:39,319
the code to do this this comes out of

1065
00:50:37,160 --> 00:50:43,520
the paper right I simplified it a little

1066
00:50:39,319 --> 00:50:45,829
bit but it's really just the are it's

1067
00:50:43,520 --> 00:50:48,069
like I think they have seven lines of

1068
00:50:45,829 --> 00:50:50,990
code and five of them are like execution

1069
00:50:48,069 --> 00:50:52,700
and two of the lines of code actually

1070
00:50:50,990 --> 00:50:54,890
just make it a little bit more reliable

1071
00:50:52,700 --> 00:50:57,558
they overcome some other design issue

1072
00:50:54,890 --> 00:50:59,150
that might end up causing it to be on a

1073
00:50:57,559 --> 00:51:03,619
little bit more unpredictable than

1074
00:50:59,150 --> 00:51:05,980
normal so anyway that one was a pretty

1075
00:51:03,619 --> 00:51:08,180
big glaring error and it requires

1076
00:51:05,980 --> 00:51:09,799
combining all of those different

1077
00:51:08,180 --> 00:51:11,270
features together so all those things

1078
00:51:09,799 --> 00:51:13,670
that I just talked about that go into

1079
00:51:11,270 --> 00:51:15,770
processor design if any one of those had

1080
00:51:13,670 --> 00:51:17,610
not been implemented then this wouldn't

1081
00:51:15,770 --> 00:51:19,680
work

1082
00:51:17,610 --> 00:51:23,610
and that's kind of the you know the idea

1083
00:51:19,680 --> 00:51:26,640
here is a culmination of many many many

1084
00:51:23,610 --> 00:51:30,390
years of effort and people's little

1085
00:51:26,640 --> 00:51:32,879
discreet good ideas kind of collecting

1086
00:51:30,390 --> 00:51:35,009
together into a complex system that now

1087
00:51:32,880 --> 00:51:37,050
presents a really really really glaring

1088
00:51:35,010 --> 00:51:39,440
privacy flaw so we get in a branch

1089
00:51:37,050 --> 00:51:41,640
prediction inspector because that's

1090
00:51:39,440 --> 00:51:43,440
Spectre is very similar uses a lot of

1091
00:51:41,640 --> 00:51:45,029
the same logic that we talked about

1092
00:51:43,440 --> 00:51:47,940
there but then also uses what's called

1093
00:51:45,030 --> 00:51:50,670
branch prediction and those are you

1094
00:51:47,940 --> 00:51:54,000
familiar with the exit twelve meme this

1095
00:51:50,670 --> 00:51:58,800
is basically how your CPU works how your

1096
00:51:54,000 --> 00:52:00,750
CPU speculatively execute anything that

1097
00:51:58,800 --> 00:52:04,290
fits a model like this so if there's a

1098
00:52:00,750 --> 00:52:06,450
decision to be made so as all programs

1099
00:52:04,290 --> 00:52:09,390
can be broken up into a decision tree in

1100
00:52:06,450 --> 00:52:12,509
this case the decision to be made is

1101
00:52:09,390 --> 00:52:16,319
when I get to this test right here do I

1102
00:52:12,510 --> 00:52:18,270
execute this line at number two or do I

1103
00:52:16,320 --> 00:52:20,760
start executing at what's in number six

1104
00:52:18,270 --> 00:52:22,560
that isn't shown up here right do I

1105
00:52:20,760 --> 00:52:28,290
start executing past the end of this

1106
00:52:22,560 --> 00:52:30,990
block so again we're gonna consider a is

1107
00:52:28,290 --> 00:52:37,710
a really large array B is a really large

1108
00:52:30,990 --> 00:52:40,259
array a contains some data that maybe

1109
00:52:37,710 --> 00:52:42,330
you don't I should say contains an array

1110
00:52:40,260 --> 00:52:44,340
of data that you want to expose to the

1111
00:52:42,330 --> 00:52:47,220
program but there's more memory around

1112
00:52:44,340 --> 00:52:48,570
there as well that may be the users

1113
00:52:47,220 --> 00:52:49,740
query or something like that or the

1114
00:52:48,570 --> 00:52:53,520
program scoring that you want to keep

1115
00:52:49,740 --> 00:52:55,500
private so

1116
00:52:53,520 --> 00:52:57,690
the branch predictor will keep track of

1117
00:52:55,500 --> 00:53:00,660
the frequency with with with which a

1118
00:52:57,690 --> 00:53:03,809
branch is taken so if this was inside of

1119
00:53:00,660 --> 00:53:05,848
a loop it basically scores how

1120
00:53:03,809 --> 00:53:11,309
frequently do we go from this line to

1121
00:53:05,849 --> 00:53:13,740
this line versus this line down here so

1122
00:53:11,309 --> 00:53:17,190
if you're doing this loop and let's

1123
00:53:13,740 --> 00:53:18,930
pretend that a is a really large array

1124
00:53:17,190 --> 00:53:22,530
we'll say that a is like a million

1125
00:53:18,930 --> 00:53:24,690
elements or something right a million

1126
00:53:22,530 --> 00:53:27,089
minus one times it goes from this line

1127
00:53:24,690 --> 00:53:29,430
down here and then only one time it

1128
00:53:27,089 --> 00:53:31,109
jumps all the way down here out of that

1129
00:53:29,430 --> 00:53:34,279
so that's what it means it's literally

1130
00:53:31,109 --> 00:53:34,279
basically a frequency test

1131
00:53:34,600 --> 00:53:38,350
and the reason why it's doing that is so

1132
00:53:36,640 --> 00:53:40,720
that getting back to the pipelining

1133
00:53:38,350 --> 00:53:43,180
stuff they can figure out whether it

1134
00:53:40,720 --> 00:53:48,040
needs to start loading in these three

1135
00:53:43,180 --> 00:53:49,810
operations or if it needs to go from

1136
00:53:48,040 --> 00:53:52,870
here and then start pre loading the

1137
00:53:49,810 --> 00:53:53,770
operations down here that I you know

1138
00:53:52,870 --> 00:53:56,430
they didn't show because they're

1139
00:53:53,770 --> 00:54:00,370
irrelevant for the for the case here so

1140
00:53:56,430 --> 00:54:03,460
if branch prediction is misidentified so

1141
00:54:00,370 --> 00:54:08,140
say on the last run here when you get to

1142
00:54:03,460 --> 00:54:10,510
the end of the array it may already

1143
00:54:08,140 --> 00:54:12,759
start doing this stuff with the

1144
00:54:10,510 --> 00:54:14,890
character with the data that's just past

1145
00:54:12,760 --> 00:54:17,920
the array the data that was not supposed

1146
00:54:14,890 --> 00:54:20,350
to be read by the program and again

1147
00:54:17,920 --> 00:54:23,260
it'll throw away the data because it'll

1148
00:54:20,350 --> 00:54:24,670
realize oh the the user really wanted to

1149
00:54:23,260 --> 00:54:26,980
go down here so it's a the program

1150
00:54:24,670 --> 00:54:29,800
really goes down here but this work is

1151
00:54:26,980 --> 00:54:31,840
still done and so we can take some of

1152
00:54:29,800 --> 00:54:34,420
the stuff that was discussed right here

1153
00:54:31,840 --> 00:54:37,900
you know we can take a very similar

1154
00:54:34,420 --> 00:54:43,360
timing attack time and computation to

1155
00:54:37,900 --> 00:54:45,490
basically try and figure out what's past

1156
00:54:43,360 --> 00:54:48,160
the end of the array if we write this in

1157
00:54:45,490 --> 00:54:52,600
a proper way so this example that they

1158
00:54:48,160 --> 00:54:55,899
gave a really good use case for this

1159
00:54:52,600 --> 00:54:57,940
might be if you end up having a program

1160
00:54:55,900 --> 00:54:59,500
that's using like public key

1161
00:54:57,940 --> 00:55:02,800
authentication or something like that so

1162
00:54:59,500 --> 00:55:04,780
the user's keyring right and that thing

1163
00:55:02,800 --> 00:55:07,180
typically keeps some data private in

1164
00:55:04,780 --> 00:55:09,220
memory so this is a possible way to leak

1165
00:55:07,180 --> 00:55:11,109
that memory out this one's a lot less

1166
00:55:09,220 --> 00:55:13,359
successful this is also the one that's

1167
00:55:11,110 --> 00:55:15,700
not patched so if you remember when

1168
00:55:13,360 --> 00:55:18,430
meltdown specter was published there was

1169
00:55:15,700 --> 00:55:20,439
one patched vulnerability or one major

1170
00:55:18,430 --> 00:55:22,960
one that was patched which was the

1171
00:55:20,440 --> 00:55:26,110
meltdown vulnerability specter remains

1172
00:55:22,960 --> 00:55:29,280
unpatched today because if you mess with

1173
00:55:26,110 --> 00:55:31,510
this then all of today's processors

1174
00:55:29,280 --> 00:55:33,190
basically if you rent if you turn this

1175
00:55:31,510 --> 00:55:34,870
feature off this branch prediction

1176
00:55:33,190 --> 00:55:37,720
feature off all of today's processors

1177
00:55:34,870 --> 00:55:40,330
lose so much of their optimizations that

1178
00:55:37,720 --> 00:55:41,790
they become so much slower even with the

1179
00:55:40,330 --> 00:55:44,890
meltdown patch the impact was

1180
00:55:41,790 --> 00:55:49,160
particularly noticeable for a lot of

1181
00:55:44,890 --> 00:55:51,230
for instance cloud compute workloads so

1182
00:55:49,160 --> 00:55:52,399
my thoughts and we're getting toward the

1183
00:55:51,230 --> 00:55:56,050
end of it I think we have about 6

1184
00:55:52,400 --> 00:55:57,920
minutes left so things that I ponder

1185
00:55:56,050 --> 00:55:59,720
this has nothing to do with the

1186
00:55:57,920 --> 00:56:05,119
presentation but it is a interesting

1187
00:55:59,720 --> 00:56:08,299
factoid so the scary so this is where it

1188
00:56:05,119 --> 00:56:09,440
kind of gets to you you know you all in

1189
00:56:08,300 --> 00:56:11,119
many of the different roles that you're

1190
00:56:09,440 --> 00:56:14,599
in want to be the solution to this

1191
00:56:11,119 --> 00:56:16,460
problem and this goes beyond just CPUs

1192
00:56:14,599 --> 00:56:19,580
right this is kind of engineering and

1193
00:56:16,460 --> 00:56:21,500
design mentality so many of these

1194
00:56:19,580 --> 00:56:23,740
superscalar enabling features so the

1195
00:56:21,500 --> 00:56:26,660
things I talked about they date back to

1196
00:56:23,740 --> 00:56:30,020
the design of these two architectures

1197
00:56:26,660 --> 00:56:33,618
from the big two CPU companies they also

1198
00:56:30,020 --> 00:56:36,109
exist like was it PowerPC implements a

1199
00:56:33,619 --> 00:56:41,960
lot of the same features as well Andy's

1200
00:56:36,109 --> 00:56:44,450
29k which was predecessor to the k5 also

1201
00:56:41,960 --> 00:56:46,820
had that had a lot of the same problems

1202
00:56:44,450 --> 00:56:49,220
as well but the important thing here is

1203
00:56:46,820 --> 00:56:52,369
that many of you may not have seen these

1204
00:56:49,220 --> 00:56:54,109
two chips since the 90s that's when a

1205
00:56:52,369 --> 00:56:58,460
lot of this was introduced it was nearly

1206
00:56:54,109 --> 00:57:01,190
a generation ago so we're now living in

1207
00:56:58,460 --> 00:57:02,990
a world where we've gone through I think

1208
00:57:01,190 --> 00:57:08,330
like five or six generations since then

1209
00:57:02,990 --> 00:57:10,819
and the assumptions have been reinforced

1210
00:57:08,330 --> 00:57:12,440
during all those development cycles that

1211
00:57:10,820 --> 00:57:14,900
this is how you design a processor it's

1212
00:57:12,440 --> 00:57:17,060
no longer a like oh should I add this

1213
00:57:14,900 --> 00:57:19,070
piece should I add that piece it's now

1214
00:57:17,060 --> 00:57:20,299
like I'm not building a processor if I

1215
00:57:19,070 --> 00:57:23,180
don't include all those features I

1216
00:57:20,300 --> 00:57:26,930
showed you earlier and we're constantly

1217
00:57:23,180 --> 00:57:28,549
adding even new features as well so all

1218
00:57:26,930 --> 00:57:30,680
of those things are basically taken for

1219
00:57:28,550 --> 00:57:33,050
granted as building blocks for a modern

1220
00:57:30,680 --> 00:57:35,540
processor they're likely more skeletons

1221
00:57:33,050 --> 00:57:37,670
in the closet because you know this is

1222
00:57:35,540 --> 00:57:39,859
coming up just now it's just starting to

1223
00:57:37,670 --> 00:57:42,230
show up on the radar as a lot of you saw

1224
00:57:39,859 --> 00:57:44,540
recently there was a warning that I

1225
00:57:42,230 --> 00:57:47,210
think this past week there should have

1226
00:57:44,540 --> 00:57:49,279
been a large release of even more

1227
00:57:47,210 --> 00:57:51,890
glaring flaws that were found by the

1228
00:57:49,280 --> 00:57:52,820
same project team those got pushed off I

1229
00:57:51,890 --> 00:57:54,890
think they're supposed to be released

1230
00:57:52,820 --> 00:57:58,220
later on this month

1231
00:57:54,890 --> 00:57:59,690
but in my opinion I think that this is

1232
00:57:58,220 --> 00:58:03,649
just the tip of the iceberg for a lot of

1233
00:57:59,690 --> 00:58:05,569
this stuff so the problem is remember

1234
00:58:03,650 --> 00:58:08,150
there's no free lunch a lot of these

1235
00:58:05,569 --> 00:58:12,650
things came up because they're like how

1236
00:58:08,150 --> 00:58:14,510
do I get multiple instructions executing

1237
00:58:12,650 --> 00:58:16,010
at the same time without duplicating my

1238
00:58:14,510 --> 00:58:18,230
processors which itself is the most

1239
00:58:16,010 --> 00:58:20,299
expensive way to do it how can I do it

1240
00:58:18,230 --> 00:58:23,359
cheaper how can I do it faster how can I

1241
00:58:20,299 --> 00:58:25,130
do it easier that's the design mentality

1242
00:58:23,359 --> 00:58:30,078
that's coming up with a lot of this

1243
00:58:25,130 --> 00:58:31,849
stuff software flaws are easy to fix

1244
00:58:30,079 --> 00:58:34,130
you know easier than Hardware flaws

1245
00:58:31,849 --> 00:58:35,660
Hardware flaws are more difficult but

1246
00:58:34,130 --> 00:58:37,099
now what I'm talking about is kind of

1247
00:58:35,660 --> 00:58:39,049
the cultural common knowledge

1248
00:58:37,099 --> 00:58:40,720
assumptions floats so this is not

1249
00:58:39,049 --> 00:58:43,849
necessarily flaws that are in design

1250
00:58:40,720 --> 00:58:45,109
flaws that are in thinking so take

1251
00:58:43,849 --> 00:58:48,019
nothing for granted

1252
00:58:45,109 --> 00:58:50,690
assume nothing is ultimate you know

1253
00:58:48,019 --> 00:58:52,879
don't presume that oh because this

1254
00:58:50,690 --> 00:58:55,099
happened 30 years ago it's been proven

1255
00:58:52,880 --> 00:58:57,349
it's been tested I should never question

1256
00:58:55,099 --> 00:58:59,320
it that's not the full mindset that you

1257
00:58:57,349 --> 00:59:01,690
want to take

1258
00:58:59,320 --> 00:59:03,640
so this is kind of like what I call

1259
00:59:01,690 --> 00:59:07,690
vulnerability model for complex systems

1260
00:59:03,640 --> 00:59:10,000
every new feature introduces or adds to

1261
00:59:07,690 --> 00:59:12,190
the probability of a new security or

1262
00:59:10,000 --> 00:59:14,440
just design flaw in general the renew

1263
00:59:12,190 --> 00:59:17,830
optimization similarly brings this risk

1264
00:59:14,440 --> 00:59:19,540
in times spent analyzing system

1265
00:59:17,830 --> 00:59:21,490
integrity fixing vulnerabilities that

1266
00:59:19,540 --> 00:59:24,310
actually carries a risk reduction

1267
00:59:21,490 --> 00:59:25,870
typically you're invent engineering

1268
00:59:24,310 --> 00:59:28,570
firms are investing in these top two

1269
00:59:25,870 --> 00:59:32,529
primarily we need to start figuring out

1270
00:59:28,570 --> 00:59:34,060
how to measure this probability increase

1271
00:59:32,530 --> 00:59:35,590
this risk increase which is not

1272
00:59:34,060 --> 00:59:37,690
something necessarily done today that's

1273
00:59:35,590 --> 00:59:41,260
not a science that's more of like an art

1274
00:59:37,690 --> 00:59:42,970
or one of us pitching up here we need to

1275
00:59:41,260 --> 00:59:46,720
figure out how to measure these

1276
00:59:42,970 --> 00:59:48,430
properties effectively using data using

1277
00:59:46,720 --> 00:59:52,899
recorded history that type of thing so

1278
00:59:48,430 --> 00:59:54,520
that then we can build number-3 into the

1279
00:59:52,900 --> 00:59:55,930
engineering process not just the

1280
00:59:54,520 --> 00:59:57,880
hardware engineering process because

1281
00:59:55,930 --> 01:00:00,250
also software design flaws are

1282
00:59:57,880 --> 01:00:02,200
introducing the same thing over time but

1283
01:00:00,250 --> 01:00:04,660
think about that every time a new

1284
01:00:02,200 --> 01:00:06,430
feature and we all know that with my

1285
01:00:04,660 --> 01:00:07,060
phones or Facebook or Twitter or

1286
01:00:06,430 --> 01:00:09,399
anything like that

1287
01:00:07,060 --> 01:00:10,420
you know with what is it Facebook now

1288
01:00:09,400 --> 01:00:13,210
with my it's a whole bunch of features

1289
01:00:10,420 --> 01:00:15,280
for to try and duplicate what snapchat

1290
01:00:13,210 --> 01:00:16,780
does right like basically try and steal

1291
01:00:15,280 --> 01:00:18,070
that marketer away they're all chasing

1292
01:00:16,780 --> 01:00:19,750
new features and everything like that

1293
01:00:18,070 --> 01:00:21,910
but with every single one of those new

1294
01:00:19,750 --> 01:00:26,320
features they're introducing new code

1295
01:00:21,910 --> 01:00:27,970
that may introduce new design flaws it's

1296
01:00:26,320 --> 01:00:31,080
not guaranteed and is very unlikely that

1297
01:00:27,970 --> 01:00:33,600
it is ever going to be perfectly secure

1298
01:00:31,080 --> 01:00:37,630
we want to figure out how to build

1299
01:00:33,600 --> 01:00:40,450
number-3 system integrity vulnerability

1300
01:00:37,630 --> 01:00:42,910
fixing vulnerability hunting into the

1301
01:00:40,450 --> 01:00:45,129
engineering process because otherwise

1302
01:00:42,910 --> 01:00:48,040
it's going to become more expensive or

1303
01:00:45,130 --> 01:00:51,280
even impossible to do in a reactive mode

1304
01:00:48,040 --> 01:00:53,350
as we've seen with this guy right here

1305
01:00:51,280 --> 01:00:56,110
this is a reason why it's it's not

1306
01:00:53,350 --> 01:00:57,759
unfixable it's not practically fixable

1307
01:00:56,110 --> 01:00:59,680
right now because we've already

1308
01:00:57,760 --> 01:01:03,700
installed all these things around the

1309
01:00:59,680 --> 01:01:06,000
world and chances are if we were to fix

1310
01:01:03,700 --> 01:01:09,359
this right now we would break the world

1311
01:01:06,000 --> 01:01:14,849
and that's not something we like to do

1312
01:01:09,359 --> 01:01:16,319
so with that very gun to us or I'll

1313
01:01:14,849 --> 01:01:18,499
probably get kicked off because I took

1314
01:01:16,319 --> 01:01:18,499
too long

1315
01:01:32,420 --> 01:01:34,480
you

