1
00:00:06,410 --> 00:00:09,500
hear me

2
00:00:40,270 --> 00:00:45,680
so I wanted to kind of go back and just

3
00:00:43,220 --> 00:00:48,519
think about a trustworthy software user

4
00:00:45,680 --> 00:00:51,050
the classical view of confidentiality

5
00:00:48,519 --> 00:00:53,110
availability and integrity but I don't

6
00:00:51,050 --> 00:00:55,760
really think that's enough just to

7
00:00:53,110 --> 00:00:58,010
really show what we want from

8
00:00:55,760 --> 00:01:00,489
trustworthy software what we wanted

9
00:00:58,010 --> 00:01:03,049
sucker-head behaves as we expected

10
00:01:00,489 --> 00:01:07,729
doesn't have any unexpected behaviors

11
00:01:03,049 --> 00:01:09,979
predictable and reliable and to really

12
00:01:07,729 --> 00:01:11,780
get at that and to be able to really

13
00:01:09,979 --> 00:01:14,210
create prosperity software especially

14
00:01:11,780 --> 00:01:16,700
out of the complexity that we're seeing

15
00:01:14,210 --> 00:01:19,429
these days we didn't think about the

16
00:01:16,700 --> 00:01:21,350
policies we applied to it what we expect

17
00:01:19,430 --> 00:01:25,310
are possible not gonna do what we allow

18
00:01:21,350 --> 00:01:28,009
it to do and I think a lot about is

19
00:01:25,310 --> 00:01:32,060
there an ideal size granularity for

20
00:01:28,009 --> 00:01:34,100
policy objects and so through this taco

21
00:01:32,060 --> 00:01:36,140
people talking a little bit about type

22
00:01:34,100 --> 00:01:38,470
theory I'll talk about litters

23
00:01:36,140 --> 00:01:41,710
bootloader you

24
00:01:38,470 --> 00:01:44,080
motor drought then I will kind of go

25
00:01:41,710 --> 00:01:47,470
into my memory regions text picture

26
00:01:44,080 --> 00:01:50,289
policy and make a little more about this

27
00:01:47,470 --> 00:01:53,050
one-size-fits-all like how we can get

28
00:01:50,290 --> 00:01:54,940
away from that and start having policy

29
00:01:53,050 --> 00:01:57,460
objects that really better encode our

30
00:01:54,940 --> 00:02:00,009
attentions in what the software should

31
00:01:57,460 --> 00:02:02,830
be doing this doesn't look so nice but

32
00:02:00,010 --> 00:02:05,170
finding the right granularity so when I

33
00:02:02,830 --> 00:02:08,109
talk about tape systems I kind of

34
00:02:05,170 --> 00:02:10,000
generalize a little more most folks

35
00:02:08,110 --> 00:02:13,180
usage of types is programming language

36
00:02:10,000 --> 00:02:15,970
centric and it really applies to

37
00:02:13,180 --> 00:02:19,300
programming language constructs of the

38
00:02:15,970 --> 00:02:22,359
data and function calls function

39
00:02:19,300 --> 00:02:25,570
parameters are sorry parameters of a

40
00:02:22,360 --> 00:02:28,240
function are silent type return values

41
00:02:25,570 --> 00:02:31,359
and it's up to the compiler or the

42
00:02:28,240 --> 00:02:32,470
runtime to really ensure that data the

43
00:02:31,360 --> 00:02:34,420
correct type are being processed

44
00:02:32,470 --> 00:02:37,690
function and being returned from that

45
00:02:34,420 --> 00:02:38,890
function and these type rules will of

46
00:02:37,690 --> 00:02:41,770
course these relationship

47
00:02:38,890 --> 00:02:43,149
between the different constructs but

48
00:02:41,770 --> 00:02:46,540
there's so many other things that kind

49
00:02:43,150 --> 00:02:48,820
of seem like types to me really put

50
00:02:46,540 --> 00:02:50,620
takes generally define what operations

51
00:02:48,820 --> 00:02:52,930
are allowed on objects what you need

52
00:02:50,620 --> 00:02:55,360
gears are allowed and there's what

53
00:02:52,930 --> 00:02:57,550
constructs that exists outside of

54
00:02:55,360 --> 00:03:01,540
programming languages that really have

55
00:02:57,550 --> 00:03:03,820
this feel to them and for example when

56
00:03:01,540 --> 00:03:06,579
we're loading data into memory space

57
00:03:03,820 --> 00:03:09,489
instead of a process really the regions

58
00:03:06,580 --> 00:03:13,420
that we're copying over our objects they

59
00:03:09,490 --> 00:03:16,410
have each of them kind of have a purpose

60
00:03:13,420 --> 00:03:19,780
to this group to this region back and

61
00:03:16,410 --> 00:03:22,030
just to give you a little more sense of

62
00:03:19,780 --> 00:03:24,250
where types are used so interpreted

63
00:03:22,030 --> 00:03:29,310
languages there is types

64
00:03:24,250 --> 00:03:29,310
sometimes these are often dynamically

65
00:03:29,850 --> 00:03:37,180
dynamically stores tested so if I try to

66
00:03:35,470 --> 00:03:37,630
you to say at an institute to this

67
00:03:37,180 --> 00:03:40,740
treatment

68
00:03:37,630 --> 00:03:43,230
PyCon complain

69
00:03:40,740 --> 00:03:50,190
in Ruby there's a similar thing if I try

70
00:03:43,230 --> 00:03:52,739
to do the same JavaScript that has a lot

71
00:03:50,190 --> 00:03:54,240
of pure gifts I couldn't really define

72
00:03:52,740 --> 00:03:58,620
two good examples and there's a great

73
00:03:54,240 --> 00:04:00,900
pop up that we see FPS on YouTube

74
00:03:58,620 --> 00:04:03,630
has a lot of interesting we're dissing

75
00:04:00,900 --> 00:04:06,690
have a script so I thought if you make

76
00:04:03,630 --> 00:04:08,400
the string you'll tell your stream but

77
00:04:06,690 --> 00:04:14,280
if you ask it if the street is an

78
00:04:08,400 --> 00:04:16,890
instance of street it will take balls so

79
00:04:14,280 --> 00:04:20,488
types aren't out like pipes have this

80
00:04:16,890 --> 00:04:22,620
purpose though I'll be really bring the

81
00:04:20,488 --> 00:04:24,960
attention like explicitly into our code

82
00:04:22,620 --> 00:04:27,360
but maybe for some languages that don't

83
00:04:24,960 --> 00:04:31,260
do it as well as others and then press

84
00:04:27,360 --> 00:04:34,770
your CLI compiled languages and what

85
00:04:31,260 --> 00:04:36,270
would happen is if you don't appear to

86
00:04:34,770 --> 00:04:38,640
the tight constraints you'll see

87
00:04:36,270 --> 00:04:42,270
compiler warnings or errors

88
00:04:38,640 --> 00:04:44,070
it seems mostly warnings like well you

89
00:04:42,270 --> 00:04:47,609
didn't cast them into here's what we

90
00:04:44,070 --> 00:04:50,719
could treat it as one if you do and so

91
00:04:47,610 --> 00:04:53,449
job is a little more just

92
00:04:50,719 --> 00:04:56,469
so I'll see conversion double the hips

93
00:04:53,449 --> 00:04:59,539
and rust has a lot of really interesting

94
00:04:56,469 --> 00:05:01,909
uses of pipes nuture currency had been

95
00:04:59,539 --> 00:05:04,938
received beyond what we seen just Java

96
00:05:01,909 --> 00:05:06,949
taxi types and so forth and rust is

97
00:05:04,939 --> 00:05:08,839
really been in a language that they've

98
00:05:06,949 --> 00:05:12,409
been pushing to do systems programming

99
00:05:08,839 --> 00:05:15,079
low local stuff and you know as an

100
00:05:12,409 --> 00:05:17,179
alternative to see but hasn't really

101
00:05:15,079 --> 00:05:24,349
been picked up by the general public so

102
00:05:17,179 --> 00:05:28,099
parts a lot use a lot of Firefox donors

103
00:05:24,349 --> 00:05:29,748
other types of types and also going to

104
00:05:28,099 --> 00:05:33,349
make a gif types and picking up and

105
00:05:29,749 --> 00:05:36,349
Plyler injected policy so stack Canaries

106
00:05:33,349 --> 00:05:40,099
are one of this type enforcement of the

107
00:05:36,349 --> 00:05:42,229
stack so if you know some important

108
00:05:40,099 --> 00:05:44,389
function for gets over right Enders to

109
00:05:42,229 --> 00:05:47,899
take bearer at runtime that's like us

110
00:05:44,389 --> 00:05:51,019
you know buffer overflow dependent types

111
00:05:47,899 --> 00:05:52,039
are kind of interesting they're the

112
00:05:51,019 --> 00:05:54,259
example ire

113
00:05:52,039 --> 00:05:58,099
it doesn't actually compiled of anything

114
00:05:54,259 --> 00:05:59,629
but it depending types the idea is your

115
00:05:58,099 --> 00:06:02,239
cyclic check types are actually

116
00:05:59,629 --> 00:06:04,969
dependent on runtime value so you might

117
00:06:02,239 --> 00:06:08,089
not actually know at build time that it

118
00:06:04,969 --> 00:06:11,710
take text properly but with one thing

119
00:06:08,089 --> 00:06:15,430
you can do with dependent types

120
00:06:11,710 --> 00:06:17,590
I have a list I have a list of length

121
00:06:15,430 --> 00:06:19,330
two and have that be a spike in our

122
00:06:17,590 --> 00:06:21,880
breath you know if you try to create a

123
00:06:19,330 --> 00:06:24,370
list that has be more or less than two

124
00:06:21,880 --> 00:06:29,520
elements a dissapointment entire moon is

125
00:06:24,370 --> 00:06:33,330
alone this has not been used too much

126
00:06:29,520 --> 00:06:33,330
really generally

127
00:06:33,700 --> 00:06:36,760
[Music]

128
00:06:44,700 --> 00:06:50,260
the idea is you define it if you have an

129
00:06:47,920 --> 00:06:52,480
object of at Whitefoot sort of the

130
00:06:50,260 --> 00:06:54,730
functions you can call on the option to

131
00:06:52,480 --> 00:06:56,890
put in on the students currently it so

132
00:06:54,730 --> 00:06:59,380
you can maybe maybe are highly Keating

133
00:06:56,890 --> 00:07:01,030
something and deallocating it and after

134
00:06:59,380 --> 00:07:04,330
you've allocated you can read and write

135
00:07:01,030 --> 00:07:05,979
or deallocate but if it's not ready in

136
00:07:04,330 --> 00:07:08,919
that state the only thing you can do is

137
00:07:05,980 --> 00:07:11,380
allocate so that is definitely an eisley

138
00:07:08,920 --> 00:07:13,390
contention based policy right there

139
00:07:11,380 --> 00:07:15,969
it's not always chuckle at compile time

140
00:07:13,390 --> 00:07:18,039
but there's of course a lot oh there is

141
00:07:15,970 --> 00:07:20,350
it was sort of an older idea in

142
00:07:18,040 --> 00:07:25,240
programming languages and not sort of

143
00:07:20,350 --> 00:07:27,730
research it a lot of popularity buzz yes

144
00:07:25,240 --> 00:07:32,100
something that's very interesting to me

145
00:07:27,730 --> 00:07:32,100
control flow integrity which we see

146
00:07:33,120 --> 00:07:39,360
we see use these days and so I I kind of

147
00:07:37,680 --> 00:07:41,430
pick it as a compiler injection pump

148
00:07:39,360 --> 00:07:43,440
policy so there are kind of branches

149
00:07:41,430 --> 00:07:46,080
along your control photograph that you

150
00:07:43,440 --> 00:07:49,710
think that are valid that you're allowed

151
00:07:46,080 --> 00:07:52,469
and the idea profile integrity is that

152
00:07:49,710 --> 00:07:54,900
you disallow jumps across branches or

153
00:07:52,470 --> 00:07:59,970
things that are not explicitly allowed

154
00:07:54,900 --> 00:08:01,440
in this policy and so if it looks like

155
00:07:59,970 --> 00:08:03,540
that the quacks like a duck

156
00:08:01,440 --> 00:08:06,090
beneath batteries probably have the

157
00:08:03,540 --> 00:08:07,770
wrong abstraction so I'm when it comes

158
00:08:06,090 --> 00:08:10,770
to tech policies they definitely are

159
00:08:07,770 --> 00:08:12,539
useful in helping you write code or

160
00:08:10,770 --> 00:08:14,609
especially the text that we use most

161
00:08:12,540 --> 00:08:17,880
most pens we use they help you break

162
00:08:14,610 --> 00:08:19,290
code that kind of keep with your

163
00:08:17,880 --> 00:08:21,150
attention of what this function is

164
00:08:19,290 --> 00:08:23,490
supposed to do but it's very much on

165
00:08:21,150 --> 00:08:27,270
this functional module level and it

166
00:08:23,490 --> 00:08:29,700
doesn't necessarily easily like expand

167
00:08:27,270 --> 00:08:32,490
to enjoy your program behaviors and ones

168
00:08:29,700 --> 00:08:35,010
that we're interested in it and that's

169
00:08:32,490 --> 00:08:37,370
what I want to try to get at with some

170
00:08:35,010 --> 00:08:40,200
of the work that have been a presents

171
00:08:37,370 --> 00:08:42,750
types outside of programming languages

172
00:08:40,200 --> 00:08:45,510
you know once it are all these things I

173
00:08:42,750 --> 00:08:48,180
consider types in their own ways that

174
00:08:45,510 --> 00:08:49,710
file permissions are can be felt like a

175
00:08:48,180 --> 00:08:53,760
type and there's some enforcement there

176
00:08:49,710 --> 00:08:58,380
by the kernel su Linux sort of is this

177
00:08:53,760 --> 00:08:59,370
very fine-grain and click system on

178
00:08:58,380 --> 00:09:02,580
syscalls

179
00:08:59,370 --> 00:09:04,580
over in linux and then you know

180
00:09:02,580 --> 00:09:09,510
like this coarser one read/write/execute

181
00:09:04,580 --> 00:09:13,830
Commission's across pages so moving now

182
00:09:09,510 --> 00:09:17,850
from this TED talk to a policy how is

183
00:09:13,830 --> 00:09:20,160
policy like training a puppy well it

184
00:09:17,850 --> 00:09:22,529
helps that your apology of policy

185
00:09:20,160 --> 00:09:24,569
objects or file size so if you're Alice

186
00:09:22,529 --> 00:09:26,610
and you shrunk down and you just drank I

187
00:09:24,570 --> 00:09:30,570
miss dog it's not going to like you want

188
00:09:26,610 --> 00:09:33,779
to put the candlestick inter-process I

189
00:09:30,570 --> 00:09:35,550
kind of thinking a lot of work has been

190
00:09:33,779 --> 00:09:39,360
done on into your process and like in

191
00:09:35,550 --> 00:09:42,199
process of so inter process we have UNIX

192
00:09:39,360 --> 00:09:44,880
file Commission's that are fairly coarse

193
00:09:42,200 --> 00:09:46,920
and the protections are against you know

194
00:09:44,880 --> 00:09:49,350
labels on the file depending and then

195
00:09:46,920 --> 00:09:52,500
versus the process you know a label of

196
00:09:49,350 --> 00:09:54,480
the processes running who own stacks and

197
00:09:52,500 --> 00:09:57,240
that's pretty porous and SEO makes is

198
00:09:54,480 --> 00:09:59,130
kind of pretty hard to work on is you

199
00:09:57,240 --> 00:10:01,910
know bag of permission so you really

200
00:09:59,130 --> 00:10:05,189
have to strictly defined across files

201
00:10:01,910 --> 00:10:07,949
Hegarty desist calls types of syscalls

202
00:10:05,190 --> 00:10:10,560
and domain which is you know sort of

203
00:10:07,950 --> 00:10:12,750
like the runtime label again into your

204
00:10:10,560 --> 00:10:16,170
process you will see read write execute

205
00:10:12,750 --> 00:10:19,860
permissions of pages in that can be two

206
00:10:16,170 --> 00:10:22,199
cars so we've seen there is a function

207
00:10:19,860 --> 00:10:24,420
pointer in writable area you don't

208
00:10:22,200 --> 00:10:26,910
always want to be able to overwrite that

209
00:10:24,420 --> 00:10:28,709
and there's you know the C type system

210
00:10:26,910 --> 00:10:31,170
which kind of seems neat you can know

211
00:10:28,709 --> 00:10:33,709
he's cast some thinking like then

212
00:10:31,170 --> 00:10:36,930
compiler well you can compile it anyway

213
00:10:33,709 --> 00:10:39,719
pablor but pretty much let you do

214
00:10:36,930 --> 00:10:43,378
you tell it to you know make all

215
00:10:39,720 --> 00:10:47,009
whirring stairs and also you know

216
00:10:43,379 --> 00:10:49,199
screaming with all the warnings and I'm

217
00:10:47,009 --> 00:10:50,970
wondering now with region-based types

218
00:10:49,199 --> 00:10:55,859
when you think about regions of memory

219
00:10:50,970 --> 00:10:58,290
there is no actual like specific size

220
00:10:55,860 --> 00:11:00,360
it's very variable you can have a very

221
00:10:58,290 --> 00:11:03,329
large region of memory or you can think

222
00:11:00,360 --> 00:11:08,040
of a single object and maybe that's

223
00:11:03,329 --> 00:11:10,979
adjusted right and when we want this

224
00:11:08,040 --> 00:11:12,660
right granularity whatever it is it

225
00:11:10,980 --> 00:11:15,959
should really help us more easily

226
00:11:12,660 --> 00:11:18,600
describe what matters to us in software

227
00:11:15,959 --> 00:11:21,748
behavior so when we're correcting a

228
00:11:18,600 --> 00:11:23,459
policy if what is this wish list that we

229
00:11:21,749 --> 00:11:26,759
walked and I put about this term that

230
00:11:23,459 --> 00:11:27,689
Sergey used in a black hat topper that

231
00:11:26,759 --> 00:11:31,889
this policy

232
00:11:27,689 --> 00:11:35,459
wish list we need to be able to really

233
00:11:31,889 --> 00:11:36,869
say to our policy it types or types with

234
00:11:35,459 --> 00:11:40,559
other things we want to say with

235
00:11:36,869 --> 00:11:43,999
relevance like what data is very

236
00:11:40,559 --> 00:11:46,860
sensitive and describe what matters and

237
00:11:43,999 --> 00:11:49,379
perhaps certain operations have to

238
00:11:46,860 --> 00:11:51,959
happen in a certain order it can be

239
00:11:49,379 --> 00:11:54,059
harder to describe that with the type

240
00:11:51,959 --> 00:11:56,219
system of these fine great wads of these

241
00:11:54,059 --> 00:12:00,990
course green wants that we have you know

242
00:11:56,220 --> 00:12:02,309
in practice another policy idea for

243
00:12:00,990 --> 00:12:04,740
policies or another thing we might want

244
00:12:02,309 --> 00:12:08,790
is to be able to be concise and describe

245
00:12:04,740 --> 00:12:11,990
only what matters because time well it's

246
00:12:08,790 --> 00:12:15,469
not evil we die avenged

247
00:12:11,990 --> 00:12:17,899
sorry to say but you can't take forever

248
00:12:15,470 --> 00:12:20,779
to write a policy or your software

249
00:12:17,899 --> 00:12:22,279
because it needs to you know be used as

250
00:12:20,779 --> 00:12:25,040
a guest is probably reason while you're

251
00:12:22,279 --> 00:12:28,670
writing in so sometimes just need a

252
00:12:25,040 --> 00:12:32,240
focus on what matters and I'm picking on

253
00:12:28,670 --> 00:12:35,170
SELinux again but it requires you to to

254
00:12:32,240 --> 00:12:37,250
assign types to everything and to decide

255
00:12:35,170 --> 00:12:38,810
permissions to every single sis call

256
00:12:37,250 --> 00:12:42,350
that might be performed on any object

257
00:12:38,810 --> 00:12:48,709
that is part of its language which is

258
00:12:42,350 --> 00:12:51,770
usually files file so what does matter

259
00:12:48,709 --> 00:12:54,079
to me it really depends on the software

260
00:12:51,770 --> 00:12:56,689
and the larger context in which it's

261
00:12:54,080 --> 00:12:59,600
being run in which is being used and I'd

262
00:12:56,690 --> 00:13:04,399
like to explore that a little as I

263
00:12:59,600 --> 00:13:08,930
continue so what do we want intense

264
00:13:04,399 --> 00:13:10,580
level semantics again this is part from

265
00:13:08,930 --> 00:13:12,529
Sergei that Bush Texas students the

266
00:13:10,580 --> 00:13:17,149
doshas so you don't really know what

267
00:13:12,529 --> 00:13:18,980
those words are we know the but there is

268
00:13:17,149 --> 00:13:21,860
a grammar between them that reveals

269
00:13:18,980 --> 00:13:24,899
relationships so even though we might

270
00:13:21,860 --> 00:13:28,249
not know exactly the layout of

271
00:13:24,899 --> 00:13:30,269
function etc what every single one does

272
00:13:28,249 --> 00:13:33,629
it's easier to understand the

273
00:13:30,269 --> 00:13:35,579
relationships between them and semantics

274
00:13:33,629 --> 00:13:37,709
can be derived from real relationships

275
00:13:35,579 --> 00:13:39,779
and the intent can be derived through

276
00:13:37,709 --> 00:13:45,059
these relationships and we can start

277
00:13:39,779 --> 00:13:48,389
using that to to create policy and not

278
00:13:45,059 --> 00:13:50,459
only that but code you know it executes

279
00:13:48,389 --> 00:13:53,610
to has different pages so perhaps an

280
00:13:50,459 --> 00:13:56,399
object at certain time in execution is

281
00:13:53,610 --> 00:13:58,529
not sensitive but eventually it will

282
00:13:56,399 --> 00:14:01,529
become a sensitive or maybe it needs to

283
00:13:58,529 --> 00:14:06,050
be used so in some hypothetical email

284
00:14:01,529 --> 00:14:08,610
client if they initialize itself

285
00:14:06,050 --> 00:14:11,339
authenticate with some key and then

286
00:14:08,610 --> 00:14:13,619
after this authentication process you

287
00:14:11,339 --> 00:14:15,779
know to some remote server it will start

288
00:14:13,619 --> 00:14:17,910
processing input handling error is

289
00:14:15,779 --> 00:14:21,689
during a session it is eventually be

290
00:14:17,910 --> 00:14:24,779
authenticated why should it be able to

291
00:14:21,689 --> 00:14:27,599
ask question of the code that processes

292
00:14:24,779 --> 00:14:28,920
the input ever look at keys again it's

293
00:14:27,600 --> 00:14:30,929
already been authenticated there's

294
00:14:28,920 --> 00:14:35,329
probably a small session fee just for

295
00:14:30,929 --> 00:14:37,980
that but it's to treat it the same

296
00:14:35,329 --> 00:14:40,800
currently as every other object in

297
00:14:37,980 --> 00:14:43,800
memory as the email client executes and

298
00:14:40,800 --> 00:14:46,349
it was these different phases we should

299
00:14:43,800 --> 00:14:49,109
really be able to say this region these

300
00:14:46,350 --> 00:14:51,990
types of objects here are important and

301
00:14:49,110 --> 00:14:53,639
readable and writeable but while we're

302
00:14:51,990 --> 00:14:55,679
executing this other phase where we're

303
00:14:53,639 --> 00:14:57,269
handling sensitive love well we're

304
00:14:55,679 --> 00:14:59,100
handling untrusted input

305
00:14:57,269 --> 00:15:02,310
let's lock down the

306
00:14:59,100 --> 00:15:04,890
of objects so that we don't you know so

307
00:15:02,310 --> 00:15:06,329
that's a runaway process because there's

308
00:15:04,890 --> 00:15:08,490
going to be like some issues with the

309
00:15:06,330 --> 00:15:12,930
parser right so something that happens

310
00:15:08,490 --> 00:15:14,790
doesn't necessarily week the keys so we

311
00:15:12,930 --> 00:15:17,670
don't want the keys to be leaked to the

312
00:15:14,790 --> 00:15:18,990
interwebs but because everything sits in

313
00:15:17,670 --> 00:15:22,260
a single address space

314
00:15:18,990 --> 00:15:25,590
it's happen I mean this is not

315
00:15:22,260 --> 00:15:26,880
hypothetical email client series but you

316
00:15:25,590 --> 00:15:30,020
know this is something that does happen

317
00:15:26,880 --> 00:15:33,990
and so why do we allow this

318
00:15:30,020 --> 00:15:36,990
Ubud is a food butter that's used in

319
00:15:33,990 --> 00:15:39,060
embedded devices and this is something

320
00:15:36,990 --> 00:15:42,870
that I dug into deeply when I was

321
00:15:39,060 --> 00:15:46,500
thinking about regions as types so

322
00:15:42,870 --> 00:15:48,660
before you go a blue letter which I

323
00:15:46,500 --> 00:15:51,360
consider as a type of floater they're to

324
00:15:48,660 --> 00:15:53,160
me they're sort of the same thing so the

325
00:15:51,360 --> 00:15:55,740
loaders aren't you know the magic to

326
00:15:53,160 --> 00:15:57,810
transform a binary image into a running

327
00:15:55,740 --> 00:16:00,780
application and it sort of does this

328
00:15:57,810 --> 00:16:02,819
transduction based on metadata in the

329
00:16:00,780 --> 00:16:06,390
image and what it knows about the

330
00:16:02,820 --> 00:16:08,520
runtime in the binary image which I do

331
00:16:06,390 --> 00:16:11,189
what I mean by binary image is a static

332
00:16:08,520 --> 00:16:13,949
representation of the machine code so

333
00:16:11,190 --> 00:16:19,730
elf is the type used in like Unix Linux

334
00:16:13,950 --> 00:16:26,149
it's Pease Windows Paco or macho however

335
00:16:19,730 --> 00:16:29,959
that's it it is the one in OS X and then

336
00:16:26,149 --> 00:16:30,799
also two more things at his faces the

337
00:16:29,959 --> 00:16:33,439
term design

338
00:16:30,799 --> 00:16:35,869
I used to refer to any addressable

339
00:16:33,439 --> 00:16:38,358
memory as you know the code is running

340
00:16:35,869 --> 00:16:41,239
anything that's reachable so it should

341
00:16:38,359 --> 00:16:43,129
be higher up your space memory map I

342
00:16:41,239 --> 00:16:45,319
think as a model of the address space

343
00:16:43,129 --> 00:16:46,999
that were there semantic labels of a

344
00:16:45,319 --> 00:16:49,699
different regions and this naturally

345
00:16:46,999 --> 00:16:51,649
happens whenever software is executed

346
00:16:49,699 --> 00:16:54,439
because there will be a chunk that's its

347
00:16:51,649 --> 00:16:56,509
code which chunk that's data and you

348
00:16:54,439 --> 00:17:00,469
know it's junk that's a stack so forth

349
00:16:56,509 --> 00:17:03,799
this is just natural who looks a loader

350
00:17:00,470 --> 00:17:07,699
well it's another loader it's loaders

351
00:17:03,799 --> 00:17:09,559
all the way down and the bootloader is

352
00:17:07,699 --> 00:17:12,709
just a term that I use it's you mean

353
00:17:09,559 --> 00:17:15,619
like the loader that executes before the

354
00:17:12,709 --> 00:17:18,559
kernel or the primary application is and

355
00:17:15,619 --> 00:17:21,229
so we've seen plenty of them so what do

356
00:17:18,559 --> 00:17:24,949
we expect from our loot loaders and what

357
00:17:21,230 --> 00:17:28,459
are what's unexpected well I expect that

358
00:17:24,949 --> 00:17:30,809
it really any loader or mid letter will

359
00:17:28,459 --> 00:17:32,639
do the discovery and initialization

360
00:17:30,809 --> 00:17:35,210
sources in the add new space or the

361
00:17:32,639 --> 00:17:38,309
hardware is part of the larger system

362
00:17:35,210 --> 00:17:40,169
especially it's a bootloader he will

363
00:17:38,309 --> 00:17:42,720
prepare the outer space for whatever

364
00:17:40,169 --> 00:17:45,120
needs to be run next it might actually

365
00:17:42,720 --> 00:17:47,820
have to relocate itself to another place

366
00:17:45,120 --> 00:17:51,029
in memory especially with booth motors

367
00:17:47,820 --> 00:17:53,129
that are confined regions of it if

368
00:17:51,029 --> 00:17:55,679
there's good find resources early on a

369
00:17:53,129 --> 00:17:56,789
bootloader might be to move itself out

370
00:17:55,679 --> 00:17:59,490
of the way

371
00:17:56,789 --> 00:18:02,519
you know it might actually enable some

372
00:17:59,490 --> 00:18:06,559
more around coffee itself over there and

373
00:18:02,519 --> 00:18:09,450
then continue on and also you expect the

374
00:18:06,559 --> 00:18:12,658
bootloader to prepare this image in

375
00:18:09,450 --> 00:18:15,809
memory and finally executed so I like to

376
00:18:12,659 --> 00:18:18,059
think of you know that is stages the

377
00:18:15,809 --> 00:18:21,720
loading seems to be a very you know for

378
00:18:18,059 --> 00:18:24,269
doing process you'll start and it'll do

379
00:18:21,720 --> 00:18:26,789
some bookkeeping and perhaps at some

380
00:18:24,269 --> 00:18:28,799
point the stack will be available to be

381
00:18:26,789 --> 00:18:30,749
available for the rest of the time and

382
00:18:28,799 --> 00:18:33,418
then you enter another phase where

383
00:18:30,749 --> 00:18:36,960
you're locating the target image but you

384
00:18:33,419 --> 00:18:38,879
know that's more bookkeeping and after

385
00:18:36,960 --> 00:18:40,679
you do that you'll see that there's more

386
00:18:38,879 --> 00:18:43,168
data there might be Heath available the

387
00:18:40,679 --> 00:18:46,200
through my feet of BSS region and that's

388
00:18:43,169 --> 00:18:47,879
zeroed out and ready and then I might be

389
00:18:46,200 --> 00:18:50,190
another face uploading the target image

390
00:18:47,879 --> 00:18:50,719
and doing preparations eventually the

391
00:18:50,190 --> 00:18:53,360
target

392
00:18:50,720 --> 00:18:55,460
ready and there's like this final phase

393
00:18:53,360 --> 00:18:59,899
that we can execute that's and jump into

394
00:18:55,460 --> 00:19:02,720
the targets and all the metadata weird

395
00:18:59,900 --> 00:19:04,640
machine is some of the work that vision

396
00:19:02,720 --> 00:19:08,450
Allah inspired me to think about me

397
00:19:04,640 --> 00:19:11,179
Jesus types so how a loner is expected

398
00:19:08,450 --> 00:19:12,980
to work is that it will read metadata in

399
00:19:11,179 --> 00:19:14,600
this file that it's parsing at us

400
00:19:12,980 --> 00:19:16,130
well first you might actually copy

401
00:19:14,600 --> 00:19:17,840
everything in memory and then I'll start

402
00:19:16,130 --> 00:19:21,500
reading up the metadata to figure out

403
00:19:17,840 --> 00:19:23,899
what it's supposed to do and it will

404
00:19:21,500 --> 00:19:26,659
search in regions of packages in memory

405
00:19:23,900 --> 00:19:28,250
as needed because the might need some

406
00:19:26,659 --> 00:19:31,789
absolute a business that are not known

407
00:19:28,250 --> 00:19:34,520
until runtime and then you might use it

408
00:19:31,789 --> 00:19:35,990
if it continues and it looks to see with

409
00:19:34,520 --> 00:19:38,150
its own you know data structure is

410
00:19:35,990 --> 00:19:41,960
whether there is more than it needs to

411
00:19:38,150 --> 00:19:45,230
pass another library that's loaded but

412
00:19:41,960 --> 00:19:49,490
this doesn't have to work this way and

413
00:19:45,230 --> 00:19:50,659
some broken promises results in a

414
00:19:49,490 --> 00:19:54,590
turing-complete

415
00:19:50,659 --> 00:19:56,750
butter which I possess it before Amun at

416
00:19:54,590 --> 00:20:00,199
Def Con and GCC if you're interested in

417
00:19:56,750 --> 00:20:05,200
that I can give links later but in this

418
00:20:00,200 --> 00:20:08,419
particular like weird execution model or

419
00:20:05,200 --> 00:20:11,870
if you have weird metadata you might see

420
00:20:08,419 --> 00:20:14,220
the loader reading it writing all over

421
00:20:11,870 --> 00:20:19,530
the address space because of the met

422
00:20:14,220 --> 00:20:22,530
just telling it to do so and then it

423
00:20:19,530 --> 00:20:26,190
will end up reading it again and finding

424
00:20:22,530 --> 00:20:28,049
itself hatching again into the metadata

425
00:20:26,190 --> 00:20:30,240
and actually running them as

426
00:20:28,049 --> 00:20:32,400
instructions and suddenly you get this

427
00:20:30,240 --> 00:20:35,280
you know argh you do arbitrary

428
00:20:32,400 --> 00:20:36,690
computation with this metadata but

429
00:20:35,280 --> 00:20:38,428
really the only thing they should have

430
00:20:36,690 --> 00:20:45,059
been doing is writing some very specific

431
00:20:38,429 --> 00:20:47,840
regions of memory so in my mind this is

432
00:20:45,059 --> 00:20:51,389
a type confusion issue these metadata

433
00:20:47,840 --> 00:20:54,240
are meant to end the face which the

434
00:20:51,390 --> 00:20:56,400
process is really only meant to like

435
00:20:54,240 --> 00:20:58,860
write to certain regions of memory which

436
00:20:56,400 --> 00:21:02,370
contain points to the places that should

437
00:20:58,860 --> 00:21:06,000
have to say absolute pointers but in

438
00:21:02,370 --> 00:21:08,370
this weird machine is writing to regions

439
00:21:06,000 --> 00:21:11,159
of memory that should never be right

440
00:21:08,370 --> 00:21:12,928
written to you while the loader after

441
00:21:11,159 --> 00:21:14,880
the loader you know reads and the

442
00:21:12,929 --> 00:21:16,409
metadata it's over writing its own

443
00:21:14,880 --> 00:21:19,169
metadata and we're going to get the

444
00:21:16,409 --> 00:21:22,380
learner to do well journey complete

445
00:21:19,169 --> 00:21:26,340
computation and so that simply typed

446
00:21:22,380 --> 00:21:28,679
confusion to me so going to you I mean I

447
00:21:26,340 --> 00:21:33,590
didn't do anything as interesting with

448
00:21:28,679 --> 00:21:36,250
you good but there is a lot of trust in

449
00:21:33,590 --> 00:21:40,290
some instances or something

450
00:21:36,250 --> 00:21:43,230
muted how should it be hey I

451
00:21:40,290 --> 00:21:47,620
specifically looked at the u-boot SPL

452
00:21:43,230 --> 00:21:52,240
for people born XM the beagleboard-xm

453
00:21:47,620 --> 00:21:54,879
has multiple rounds or stages of blue

454
00:21:52,240 --> 00:21:57,670
glowing what is soda if it's on chip ROM

455
00:21:54,880 --> 00:22:01,330
then it invokes an SPL which is a

456
00:21:57,670 --> 00:22:03,550
smaller like in terms of hood size boo

457
00:22:01,330 --> 00:22:06,250
butter which then invokes a larger chunk

458
00:22:03,550 --> 00:22:08,649
of you boots entirely separate dimension

459
00:22:06,250 --> 00:22:10,360
and finally Linux so I was just looking

460
00:22:08,650 --> 00:22:15,330
at the more simple one which is really a

461
00:22:10,360 --> 00:22:17,639
subset of the larger meaning boot image

462
00:22:15,330 --> 00:22:22,149
while looking at this I was wondering

463
00:22:17,640 --> 00:22:24,610
does this blue litter always behave or

464
00:22:22,150 --> 00:22:28,780
yes does it always behave as it's

465
00:22:24,610 --> 00:22:33,240
expected never be made unexpectedly at

466
00:22:28,780 --> 00:22:36,280
predictably astrologically and how does

467
00:22:33,240 --> 00:22:39,130
you go to accomplish what is expected of

468
00:22:36,280 --> 00:22:41,190
it within the context behaving expected

469
00:22:39,130 --> 00:22:45,340
as expected and never behaving

470
00:22:41,190 --> 00:22:46,960
unexpectedly you know you know one of

471
00:22:45,340 --> 00:22:53,800
the best vacations is to discover

472
00:22:46,960 --> 00:22:55,440
resources just to give you a sense of

473
00:22:53,800 --> 00:22:57,330
what it's doing was

474
00:22:55,440 --> 00:23:00,299
sources is that there is sort of

475
00:22:57,330 --> 00:23:04,049
parkland discovery where addresses of

476
00:23:00,299 --> 00:23:07,590
thank memory mapped Hardware memory

477
00:23:04,049 --> 00:23:09,870
mapped i/o is just known compiled and

478
00:23:07,590 --> 00:23:12,240
statically into the binary and it will

479
00:23:09,870 --> 00:23:15,689
read a value to get say that's just boot

480
00:23:12,240 --> 00:23:18,120
status which is you know why is this

481
00:23:15,690 --> 00:23:21,059
bootloader to vote is it a cold boot or

482
00:23:18,120 --> 00:23:24,870
mood etc then there's sort of semi Ammar

483
00:23:21,059 --> 00:23:27,149
coded where you booth as it's running

484
00:23:24,870 --> 00:23:29,668
you know some values of a register in

485
00:23:27,149 --> 00:23:31,199
perhaps and use that to look up in the

486
00:23:29,669 --> 00:23:33,990
table to figure out how to use this

487
00:23:31,200 --> 00:23:36,659
hardware and Nanoha also needs some

488
00:23:33,990 --> 00:23:39,990
protocol based discovery it will know

489
00:23:36,659 --> 00:23:43,019
how to send and receive earths really

490
00:23:39,990 --> 00:23:47,340
work with MMC that going to call to the

491
00:23:43,019 --> 00:23:49,500
SD card and it has to in this case it

492
00:23:47,340 --> 00:23:51,779
knows how to read a fat file system in

493
00:23:49,500 --> 00:23:54,389
order to find this next stage so these

494
00:23:51,779 --> 00:23:57,659
are the different discovery modes and

495
00:23:54,389 --> 00:23:59,820
how it uses resources is often based on

496
00:23:57,659 --> 00:24:02,820
what it discovered sometimes vixen

497
00:23:59,820 --> 00:24:06,928
herkimer actresses so this is an example

498
00:24:02,820 --> 00:24:10,830
of it setting up we're writing to the

499
00:24:06,929 --> 00:24:12,629
i2c bus and bottom the bottom table is

500
00:24:10,830 --> 00:24:14,480
just you know the documentation on the

501
00:24:12,629 --> 00:24:17,100
chip of the address of each of these

502
00:24:14,480 --> 00:24:19,139
memory mapped registers and it

503
00:24:17,100 --> 00:24:22,889
corresponds to like these magic numbers

504
00:24:19,139 --> 00:24:25,199
in the code itself in order to make use

505
00:24:22,889 --> 00:24:27,149
of these resources and again when

506
00:24:25,200 --> 00:24:29,710
including images it's crawling the

507
00:24:27,149 --> 00:24:31,719
filesystem person headers

508
00:24:29,710 --> 00:24:34,840
using that cutter information to figure

509
00:24:31,720 --> 00:24:37,779
out what to do next and donate this is

510
00:24:34,840 --> 00:24:41,649
just it also sometimes relocates and

511
00:24:37,779 --> 00:24:45,940
relocation is also based on hard coded

512
00:24:41,649 --> 00:24:48,279
information as well as pulp mostly hard

513
00:24:45,940 --> 00:24:51,039
code as information it knows the size it

514
00:24:48,279 --> 00:24:53,740
is so we can move itself elsewhere and

515
00:24:51,039 --> 00:24:55,390
in each doesn't necessarily know how

516
00:24:53,740 --> 00:24:57,460
much room is available it just assumes

517
00:24:55,390 --> 00:25:00,909
it won't overlap with anything in this

518
00:24:57,460 --> 00:25:04,090
particular case so these are things you

519
00:25:00,909 --> 00:25:06,220
might see and along these things it does

520
00:25:04,090 --> 00:25:09,370
you'll see these are relationships

521
00:25:06,220 --> 00:25:11,860
between resources memory regions and

522
00:25:09,370 --> 00:25:13,959
then also the phase in which it's

523
00:25:11,860 --> 00:25:17,709
executing will use different resources

524
00:25:13,960 --> 00:25:19,360
so in other words it will focus on read

525
00:25:17,710 --> 00:25:22,779
and write to different memory regions

526
00:25:19,360 --> 00:25:25,289
and this is an overall address piece for

527
00:25:22,779 --> 00:25:28,149
this particular chip in people board

528
00:25:25,289 --> 00:25:31,360
this is from the documentation and

529
00:25:28,149 --> 00:25:33,399
there's you know obedia that there's a

530
00:25:31,360 --> 00:25:35,479
lot of reserve space but there's some

531
00:25:33,399 --> 00:25:37,908
addresses physical addresses that

532
00:25:35,480 --> 00:25:39,649
beyond ship food from there are some

533
00:25:37,909 --> 00:25:42,049
physical addresses that are they are

534
00:25:39,649 --> 00:25:45,199
crayons and a lot of Regents that are

535
00:25:42,049 --> 00:25:47,840
for different hardware resources for

536
00:25:45,200 --> 00:25:50,630
different memory not registers and if we

537
00:25:47,840 --> 00:25:53,330
zoom in to one of these areas of memory

538
00:25:50,630 --> 00:25:57,500
map registers will start seeing you know

539
00:25:53,330 --> 00:25:59,418
the ICC they're just something for our

540
00:25:57,500 --> 00:26:02,840
to see something curves and timer

541
00:25:59,419 --> 00:26:05,210
registers and so really these regions

542
00:26:02,840 --> 00:26:06,799
memory are objects and these objects are

543
00:26:05,210 --> 00:26:10,039
part of can really be part of a policy

544
00:26:06,799 --> 00:26:13,399
and we can decide because region sizes

545
00:26:10,039 --> 00:26:15,679
can be as big or small as we've lost we

546
00:26:13,399 --> 00:26:18,260
can have a course policy that's like

547
00:26:15,679 --> 00:26:19,970
this region these are all registers at

548
00:26:18,260 --> 00:26:22,129
this place between not be touching those

549
00:26:19,970 --> 00:26:25,159
or you can have a policy that's like

550
00:26:22,130 --> 00:26:26,870
this region of memory is the MMC

551
00:26:25,159 --> 00:26:29,269
registers and we're going to be able to

552
00:26:26,870 --> 00:26:31,580
be using those and we don't want for

553
00:26:29,269 --> 00:26:33,889
some reason to overwrite some other

554
00:26:31,580 --> 00:26:37,820
types of registers because you know how

555
00:26:33,889 --> 00:26:39,649
its interacting with the MMC and it is

556
00:26:37,820 --> 00:26:42,379
late with embedded stuff there's a lot

557
00:26:39,649 --> 00:26:44,360
of styling failures so you might not

558
00:26:42,380 --> 00:26:47,090
even see in your testing of it that

559
00:26:44,360 --> 00:26:49,279
you're writing to your spouse I go to a

560
00:26:47,090 --> 00:26:52,250
policy and interactive the reads and

561
00:26:49,279 --> 00:26:54,169
writes for you dudes and I actually had

562
00:26:52,250 --> 00:26:56,450
a script that went through all the

563
00:26:54,169 --> 00:27:00,100
tables in the documentation of registers

564
00:26:56,450 --> 00:27:04,190
found their addresses and look to see if

565
00:27:00,100 --> 00:27:06,429
any Abbas's that were not will any

566
00:27:04,190 --> 00:27:09,190
read-only registers and

567
00:27:06,430 --> 00:27:11,110
Marin whoever and I also wanted to see

568
00:27:09,190 --> 00:27:13,390
if there is any episodes that were not

569
00:27:11,110 --> 00:27:17,110
specifically defined as a valid address

570
00:27:13,390 --> 00:27:18,970
in this you know in the documentation to

571
00:27:17,110 --> 00:27:21,149
see if any that was written and I

572
00:27:18,970 --> 00:27:21,150
actually

