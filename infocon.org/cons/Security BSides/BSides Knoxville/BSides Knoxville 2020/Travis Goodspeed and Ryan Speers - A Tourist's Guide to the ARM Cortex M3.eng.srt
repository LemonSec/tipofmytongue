1
00:00:00,240 --> 00:00:03,918
yep so sorry ryan i don't know you but i

2
00:00:02,800 --> 00:00:07,120
i know travis is

3
00:00:03,919 --> 00:00:10,320
is one of our most neighborly hackers

4
00:00:07,120 --> 00:00:11,040
in the uh community and um always

5
00:00:10,320 --> 00:00:13,360
interest is

6
00:00:11,040 --> 00:00:14,719
interested to see what he's talking

7
00:00:13,360 --> 00:00:17,600
about if it's gonna be

8
00:00:14,719 --> 00:00:18,960
radios or watches or watches with radios

9
00:00:17,600 --> 00:00:20,240
or studebakers

10
00:00:18,960 --> 00:00:22,560
i see we've already at least do the

11
00:00:20,240 --> 00:00:23,599
bakers today we've ticked off the

12
00:00:22,560 --> 00:00:26,160
studebaker box

13
00:00:23,600 --> 00:00:28,640
real quick we got studebakers we got

14
00:00:26,160 --> 00:00:28,640
cats

15
00:00:28,880 --> 00:00:32,879
moisture studebakers and more cats yeah

16
00:00:31,199 --> 00:00:35,520
we got one cat picture that includes a

17
00:00:32,880 --> 00:00:35,520
studebaker

18
00:00:35,680 --> 00:00:39,920
excellent every combination let's see

19
00:00:37,760 --> 00:00:41,920
how many we can hit

20
00:00:39,920 --> 00:00:43,200
all right it's it's five o'clock uh you

21
00:00:41,920 --> 00:00:45,200
might as well uh

22
00:00:43,200 --> 00:00:46,719
go ahead and take it away i don't see

23
00:00:45,200 --> 00:00:50,000
any reason to wait

24
00:00:46,719 --> 00:00:51,520
all right so um the

25
00:00:50,000 --> 00:00:53,280
lecture we'll be sharing with you today

26
00:00:51,520 --> 00:00:56,160
is based on a paper

27
00:00:53,280 --> 00:00:57,280
that ryan and i wrote a few years back

28
00:00:56,160 --> 00:00:59,760
um

29
00:00:57,280 --> 00:01:01,680
the concept is that um many of you have

30
00:00:59,760 --> 00:01:03,358
done a little bit of reverse engineering

31
00:01:01,680 --> 00:01:05,040
and you would like to do more reverse

32
00:01:03,359 --> 00:01:09,200
engineering

33
00:01:05,040 --> 00:01:11,439
of uh things and

34
00:01:09,200 --> 00:01:12,320
the skills that it takes to reverse

35
00:01:11,439 --> 00:01:14,798
engineer an

36
00:01:12,320 --> 00:01:15,360
embedded system really aren't that

37
00:01:14,799 --> 00:01:17,200
different

38
00:01:15,360 --> 00:01:19,040
from the skills that are necessary to

39
00:01:17,200 --> 00:01:21,520
reverse engineer like a desktop

40
00:01:19,040 --> 00:01:24,560
application or a game

41
00:01:21,520 --> 00:01:24,560
um so

42
00:01:24,640 --> 00:01:27,920
today we're going to discuss the fancy

43
00:01:27,119 --> 00:01:30,560
tricks that

44
00:01:27,920 --> 00:01:31,520
take what might be seen as a hardware

45
00:01:30,560 --> 00:01:34,720
problem

46
00:01:31,520 --> 00:01:36,640
and converting

47
00:01:34,720 --> 00:01:38,400
that hardware problem into a software

48
00:01:36,640 --> 00:01:40,400
problem that is then

49
00:01:38,400 --> 00:01:42,159
easy to solve on a desktop with modern

50
00:01:40,400 --> 00:01:45,600
tooling and

51
00:01:42,159 --> 00:01:47,920
a nice environment uh sound good

52
00:01:45,600 --> 00:01:50,880
everybody

53
00:01:47,920 --> 00:01:51,520
um so i keep forgetting that there's no

54
00:01:50,880 --> 00:01:54,640
audience

55
00:01:51,520 --> 00:01:55,200
feedback in this so ryan is going to

56
00:01:54,640 --> 00:01:58,399
sort of

57
00:01:55,200 --> 00:02:01,040
play the part of the audience and

58
00:01:58,399 --> 00:02:01,439
interrupt me if i skip over something or

59
00:02:01,040 --> 00:02:08,560
fail

60
00:02:01,439 --> 00:02:11,760
to express it properly this is

61
00:02:08,560 --> 00:02:15,520
yeah feel free to send in those

62
00:02:11,760 --> 00:02:18,720
all right so um reverse engineering

63
00:02:15,520 --> 00:02:20,239
embedded systems is like uh loads of fun

64
00:02:18,720 --> 00:02:21,280
on its own but at the end of the day

65
00:02:20,239 --> 00:02:23,200
you're just looking

66
00:02:21,280 --> 00:02:25,760
at numbers and figuring out what the

67
00:02:23,200 --> 00:02:28,319
code does so what you really want

68
00:02:25,760 --> 00:02:31,359
is a worthy project at the end of it

69
00:02:28,319 --> 00:02:34,079
that proves that your time wasn't wasted

70
00:02:31,360 --> 00:02:35,599
um one of the the first of these that

71
00:02:34,080 --> 00:02:36,080
was pretty cool is an open source

72
00:02:35,599 --> 00:02:39,119
project

73
00:02:36,080 --> 00:02:40,959
called rockbox i believe this debuted in

74
00:02:39,120 --> 00:02:43,360
2002.

75
00:02:40,959 --> 00:02:44,480
um the idea was that they wrote their

76
00:02:43,360 --> 00:02:47,120
own mp3

77
00:02:44,480 --> 00:02:48,000
mp3 player application and then reverse

78
00:02:47,120 --> 00:02:51,200
engineered

79
00:02:48,000 --> 00:02:54,160
commercial mp3 player hardware in order

80
00:02:51,200 --> 00:02:56,079
to port this application to run on it so

81
00:02:54,160 --> 00:02:56,560
you can run this on an ipod you can run

82
00:02:56,080 --> 00:03:01,280
this

83
00:02:56,560 --> 00:03:01,280
on pretty much any of the

84
00:03:01,920 --> 00:03:06,559
popular mp3 player hardware from 15

85
00:03:04,879 --> 00:03:09,920
years ago back when

86
00:03:06,560 --> 00:03:13,120
uh people collected mp3s

87
00:03:09,920 --> 00:03:13,760
um another nifty result of revised

88
00:03:13,120 --> 00:03:16,480
engineering

89
00:03:13,760 --> 00:03:18,720
is a project that i started back when i

90
00:03:16,480 --> 00:03:20,560
lived in new york or the godless north

91
00:03:18,720 --> 00:03:24,239
as we call it a knoxville

92
00:03:20,560 --> 00:03:27,599
this project is called mv380 tools it's

93
00:03:24,239 --> 00:03:30,879
reverse engineered its patches

94
00:03:27,599 --> 00:03:33,359
against a commercial

95
00:03:30,879 --> 00:03:35,280
push push-to-talk two-way radio that can

96
00:03:33,360 --> 00:03:38,480
be applied

97
00:03:35,280 --> 00:03:40,319
against the manufacturer firmware so the

98
00:03:38,480 --> 00:03:43,200
patches are written in c

99
00:03:40,319 --> 00:03:44,079
they then change the behavior of the

100
00:03:43,200 --> 00:03:47,040
commercial

101
00:03:44,080 --> 00:03:47,840
from where the hardware was designed for

102
00:03:47,040 --> 00:03:51,040
allowing you

103
00:03:47,840 --> 00:03:51,599
to add such things as um like a phone

104
00:03:51,040 --> 00:03:54,720
book

105
00:03:51,599 --> 00:03:56,640
of amateur radio operators that are

106
00:03:54,720 --> 00:04:00,080
registered with the protocol

107
00:03:56,640 --> 00:04:04,000
you can enable promiscuous mode you can

108
00:04:00,080 --> 00:04:05,760
also dump out the memory and

109
00:04:04,000 --> 00:04:07,680
dump raw packets off of the air in order

110
00:04:05,760 --> 00:04:10,879
to reverse engineer the settings

111
00:04:07,680 --> 00:04:10,879
of a commercial network

112
00:04:11,599 --> 00:04:16,238
and more recently hudson has been

113
00:04:14,319 --> 00:04:18,959
playing around with this thing which is

114
00:04:16,238 --> 00:04:19,918
a cpap machine that he's attempting to

115
00:04:18,959 --> 00:04:23,040
firm our patch

116
00:04:19,918 --> 00:04:23,039
into being a respirator

117
00:04:24,240 --> 00:04:28,720
in all of these you need to begin by

118
00:04:27,120 --> 00:04:30,320
understanding the architecture that

119
00:04:28,720 --> 00:04:33,199
you're working with

120
00:04:30,320 --> 00:04:34,639
then you need to dump a firmware image

121
00:04:33,199 --> 00:04:35,840
load the firmware image into reverse

122
00:04:34,639 --> 00:04:38,320
engineering tool

123
00:04:35,840 --> 00:04:43,840
and then read it and annotate it until

124
00:04:38,320 --> 00:04:43,840
you can understand what it does

125
00:04:44,240 --> 00:04:47,919
so we're going to begin by taking the

126
00:04:46,479 --> 00:04:50,560
architecture at a high level and then

127
00:04:47,919 --> 00:04:52,560
we're going to jump into some details

128
00:04:50,560 --> 00:04:56,639
um it's impossible to learn how to

129
00:04:52,560 --> 00:04:59,440
reverse engineer a new uh

130
00:04:56,639 --> 00:05:00,880
architecture in just one hour so what

131
00:04:59,440 --> 00:05:01,280
you should be trying to remember from

132
00:05:00,880 --> 00:05:04,159
this

133
00:05:01,280 --> 00:05:05,758
are the nifty tricks that make the

134
00:05:04,160 --> 00:05:08,720
reverse engineering easier

135
00:05:05,759 --> 00:05:09,280
or the things that might block you and

136
00:05:08,720 --> 00:05:11,199
how to get

137
00:05:09,280 --> 00:05:12,559
beyond them and if you remember some

138
00:05:11,199 --> 00:05:14,720
high-level details

139
00:05:12,560 --> 00:05:16,880
about the architecture and its quirks

140
00:05:14,720 --> 00:05:19,440
that would be good too

141
00:05:16,880 --> 00:05:20,159
uh ryan you want to take this one and

142
00:05:19,440 --> 00:05:23,360
begin

143
00:05:20,160 --> 00:05:24,000
um like the the high level of what an

144
00:05:23,360 --> 00:05:27,199
embedded arm

145
00:05:24,000 --> 00:05:28,960
ship is sure

146
00:05:27,199 --> 00:05:30,400
yeah so an embedded arm chip there's a

147
00:05:28,960 --> 00:05:33,680
few examples that you see

148
00:05:30,400 --> 00:05:36,080
here a common one that stm32 is a small

149
00:05:33,680 --> 00:05:39,680
microcontroller the nrf51

150
00:05:36,080 --> 00:05:40,560
is from nordic it's uh has an rf core in

151
00:05:39,680 --> 00:05:43,360
it

152
00:05:40,560 --> 00:05:43,759
and there's many other examples and in

153
00:05:43,360 --> 00:05:46,800
arm

154
00:05:43,759 --> 00:05:47,840
keep in mind that uh you have typically

155
00:05:46,800 --> 00:05:50,880
32-bit

156
00:05:47,840 --> 00:05:53,599
registers but your instructions could be

157
00:05:50,880 --> 00:05:54,880
32-bit or it could be 16-bit if you're

158
00:05:53,600 --> 00:05:59,120
in thumb mode

159
00:05:54,880 --> 00:06:01,520
and i think that one of the the um

160
00:05:59,120 --> 00:06:03,520
most notable things here to keep in mind

161
00:06:01,520 --> 00:06:05,919
as your reverse engineering arm

162
00:06:03,520 --> 00:06:07,599
is figuring out which context you're in

163
00:06:05,919 --> 00:06:09,198
and figuring out how to follow as we

164
00:06:07,600 --> 00:06:11,680
jump between contexts and we'll cover

165
00:06:09,199 --> 00:06:11,680
that later

166
00:06:12,000 --> 00:06:15,680
we're not talking about chips that have

167
00:06:13,919 --> 00:06:17,440
support for legacy classic arm

168
00:06:15,680 --> 00:06:21,120
instructions

169
00:06:17,440 --> 00:06:22,800
these chips are notably small in size

170
00:06:21,120 --> 00:06:23,919
and when we mean small and we look at

171
00:06:22,800 --> 00:06:25,759
their

172
00:06:23,919 --> 00:06:27,198
memory maps you'll see it's less than a

173
00:06:25,759 --> 00:06:30,240
mega flash

174
00:06:27,199 --> 00:06:31,520
less than 128 kilobytes from a very

175
00:06:30,240 --> 00:06:33,919
small ram as well

176
00:06:31,520 --> 00:06:35,280
so this helps keep the code size that we

177
00:06:33,919 --> 00:06:37,280
have to look at smaller

178
00:06:35,280 --> 00:06:38,799
but also means that the developers are

179
00:06:37,280 --> 00:06:40,318
going to be playing tricks for code

180
00:06:38,800 --> 00:06:43,440
optimization

181
00:06:40,319 --> 00:06:44,400
and the code can run from sram but it

182
00:06:43,440 --> 00:06:46,960
usually runs

183
00:06:44,400 --> 00:06:48,719
in place from flash memory you'll only

184
00:06:46,960 --> 00:06:51,919
find it running from sram when it's

185
00:06:48,720 --> 00:06:54,400
a temporary patch or when it needs

186
00:06:51,919 --> 00:06:56,000
to load a small driver to rewrite flash

187
00:06:54,400 --> 00:06:57,679
memory

188
00:06:56,000 --> 00:07:00,880
and for that reason can't be executing

189
00:06:57,680 --> 00:07:03,840
from flash memory at the same time

190
00:07:00,880 --> 00:07:05,360
the registers are different than in x86

191
00:07:03,840 --> 00:07:08,719
or md64

192
00:07:05,360 --> 00:07:10,080
in that um someone put some

193
00:07:08,720 --> 00:07:12,960
thought into what the hell they should

194
00:07:10,080 --> 00:07:16,318
be and decided to give them

195
00:07:12,960 --> 00:07:17,840
meaningful names instead of

196
00:07:16,319 --> 00:07:19,599
conglomerates of all the backward

197
00:07:17,840 --> 00:07:22,000
compatibility history of the platform of

198
00:07:19,599 --> 00:07:24,400
the 1970s

199
00:07:22,000 --> 00:07:26,800
r15 is what you think of as the

200
00:07:24,400 --> 00:07:29,758
instruction pointer in an x86

201
00:07:26,800 --> 00:07:30,880
we call it a program counter or a pc in

202
00:07:29,759 --> 00:07:34,400
risk ships

203
00:07:30,880 --> 00:07:37,680
but it's the same thing r14

204
00:07:34,400 --> 00:07:38,239
is the link register 13 is the stack

205
00:07:37,680 --> 00:07:41,039
pointer

206
00:07:38,240 --> 00:07:41,680
and then your local variables sit

207
00:07:41,039 --> 00:07:45,199
between

208
00:07:41,680 --> 00:07:47,440
r4 and r12 and it's the child's

209
00:07:45,199 --> 00:07:49,680
responsibility to restore these before

210
00:07:47,440 --> 00:07:53,039
returning to the parent

211
00:07:49,680 --> 00:07:55,599
while registers 0 to 3 hold parameters

212
00:07:53,039 --> 00:07:56,560
and return values and any time you call

213
00:07:55,599 --> 00:07:58,560
another function

214
00:07:56,560 --> 00:08:01,280
the child can clobber those and not fix

215
00:07:58,560 --> 00:08:01,280
them on the return

216
00:08:03,520 --> 00:08:08,960
the program counter is always on when

217
00:08:06,800 --> 00:08:10,800
you're in thumb two mode

218
00:08:08,960 --> 00:08:12,719
and if it were ever even that would mean

219
00:08:10,800 --> 00:08:14,240
that you were executing in the classic

220
00:08:12,720 --> 00:08:16,960
arm mode

221
00:08:14,240 --> 00:08:18,319
with 32-bit wide instructions in thumb

222
00:08:16,960 --> 00:08:21,680
tune mode your instructions can be

223
00:08:18,319 --> 00:08:23,919
either 16 or 32 bits wide

224
00:08:21,680 --> 00:08:24,879
and you have very little memory so the

225
00:08:23,919 --> 00:08:27,599
high bits

226
00:08:24,879 --> 00:08:28,800
of your program counter are pretty much

227
00:08:27,599 --> 00:08:32,399
always consistent

228
00:08:28,800 --> 00:08:35,120
and the same and point to flash memory

229
00:08:32,399 --> 00:08:36,719
they can point to sram but in almost any

230
00:08:35,120 --> 00:08:40,959
code that you look at they'll be running

231
00:08:36,719 --> 00:08:42,560
consistently from inside of flash

232
00:08:40,958 --> 00:08:44,399
now i said that there were two

233
00:08:42,559 --> 00:08:46,399
instruction sets you've got arm and you

234
00:08:44,399 --> 00:08:50,240
have thumb two

235
00:08:46,399 --> 00:08:53,200
arm is optional in the smaller chips

236
00:08:50,240 --> 00:08:54,000
but anything that's a little bit older

237
00:08:53,200 --> 00:08:56,959
or a little bit

238
00:08:54,000 --> 00:08:58,399
larger older as in like uh game boy or

239
00:08:56,959 --> 00:09:01,680
game boy color

240
00:08:58,399 --> 00:09:03,120
uh game boy advance um

241
00:09:01,680 --> 00:09:05,120
i'm actually not entirely sure about the

242
00:09:03,120 --> 00:09:06,480
game boy first generation the game boy

243
00:09:05,120 --> 00:09:09,279
advance can definitely run both

244
00:09:06,480 --> 00:09:12,240
instruction sets

245
00:09:09,279 --> 00:09:12,800
and again it's the least significant bit

246
00:09:12,240 --> 00:09:15,360
of

247
00:09:12,800 --> 00:09:16,880
the program counter that tells you which

248
00:09:15,360 --> 00:09:20,399
instruction set you're

249
00:09:16,880 --> 00:09:20,959
executing so on the machines that can do

250
00:09:20,399 --> 00:09:23,600
both

251
00:09:20,959 --> 00:09:26,560
if you jump to an odd address you get

252
00:09:23,600 --> 00:09:29,040
the thumb two interpretation

253
00:09:26,560 --> 00:09:29,680
of the function that begins one byte

254
00:09:29,040 --> 00:09:32,319
before

255
00:09:29,680 --> 00:09:33,439
the pointer that you're going to if it's

256
00:09:32,320 --> 00:09:35,040
an even address

257
00:09:33,440 --> 00:09:37,279
you don't use the thumb two instruction

258
00:09:35,040 --> 00:09:39,040
site you use the arm instruction set

259
00:09:37,279 --> 00:09:40,880
and they did this so that you could

260
00:09:39,040 --> 00:09:44,399
freely jump back and forth

261
00:09:40,880 --> 00:09:46,720
between these different instruction sets

262
00:09:44,399 --> 00:09:48,480
within one single program produced by a

263
00:09:46,720 --> 00:09:51,600
single compiler

264
00:09:48,480 --> 00:09:53,120
without the uh

265
00:09:51,600 --> 00:09:55,839
without breaking compatibility and

266
00:09:53,120 --> 00:09:55,839
function pointers

267
00:09:56,560 --> 00:10:03,518
um r14 is the link register

268
00:09:59,839 --> 00:10:05,760
you can think about this as the um

269
00:10:03,519 --> 00:10:07,360
the return pointer on the call stack in

270
00:10:05,760 --> 00:10:10,480
x86

271
00:10:07,360 --> 00:10:11,279
except that in arm and in thumb and

272
00:10:10,480 --> 00:10:14,959
power pc

273
00:10:11,279 --> 00:10:18,000
and many other risk instruction sets

274
00:10:14,959 --> 00:10:20,479
the instead of the the parent pushing

275
00:10:18,000 --> 00:10:22,000
the return pointer onto the stack as it

276
00:10:20,480 --> 00:10:24,560
calls the child

277
00:10:22,000 --> 00:10:26,399
it's the child's responsibility to save

278
00:10:24,560 --> 00:10:28,160
the link register before calling your

279
00:10:26,399 --> 00:10:30,079
grandchild

280
00:10:28,160 --> 00:10:31,920
so if you have a leaf function that you

281
00:10:30,079 --> 00:10:34,000
call a leave function is a function that

282
00:10:31,920 --> 00:10:37,120
has no children of its own

283
00:10:34,000 --> 00:10:37,519
then um you branch to that function and

284
00:10:37,120 --> 00:10:40,320
it can

285
00:10:37,519 --> 00:10:42,240
do its work and return without ever

286
00:10:40,320 --> 00:10:44,320
writing to the step

287
00:10:42,240 --> 00:10:46,000
as long as it doesn't need to save

288
00:10:44,320 --> 00:10:49,279
registers or call another child

289
00:10:46,000 --> 00:10:52,000
or anything and because

290
00:10:49,279 --> 00:10:53,200
this value gets thrown right back into

291
00:10:52,000 --> 00:10:57,680
the program counter

292
00:10:53,200 --> 00:10:57,680
on thumb two it will also always be odd

293
00:10:58,320 --> 00:11:05,600
r13 is the stack pointer it is

294
00:11:01,440 --> 00:11:07,680
always even it is always 32-bit aligned

295
00:11:05,600 --> 00:11:08,880
and just like in x86 your stack grows

296
00:11:07,680 --> 00:11:11,839
down

297
00:11:08,880 --> 00:11:12,240
um the differences in the stack behavior

298
00:11:11,839 --> 00:11:14,800
are

299
00:11:12,240 --> 00:11:17,519
generally in that the sac is sort of

300
00:11:14,800 --> 00:11:21,599
manually managed

301
00:11:17,519 --> 00:11:23,440
when you do a call that doesn't directly

302
00:11:21,600 --> 00:11:26,839
change the sac it's the child's

303
00:11:23,440 --> 00:11:28,480
responsibility to save things after it

304
00:11:26,839 --> 00:11:33,440
arrives

305
00:11:28,480 --> 00:11:35,200
now the local variables are also

306
00:11:33,440 --> 00:11:36,800
the responsibility of the child to

307
00:11:35,200 --> 00:11:39,839
restore so

308
00:11:36,800 --> 00:11:43,120
when you have a sum2 function

309
00:11:39,839 --> 00:11:46,000
you'll see it begin by pushing the

310
00:11:43,120 --> 00:11:46,720
link register and some of the local

311
00:11:46,000 --> 00:11:49,839
variables

312
00:11:46,720 --> 00:11:52,000
onto the call stack and then at the end

313
00:11:49,839 --> 00:11:53,279
it pops them back off and if you read

314
00:11:52,000 --> 00:11:53,760
through the function you'll see that

315
00:11:53,279 --> 00:11:57,279
those

316
00:11:53,760 --> 00:11:59,439
are the same registers that it changes

317
00:11:57,279 --> 00:12:01,200
by overriding

318
00:11:59,440 --> 00:12:03,040
the requirement is that the state be

319
00:12:01,200 --> 00:12:05,120
restored

320
00:12:03,040 --> 00:12:06,319
as long as it goes back to what it was

321
00:12:05,120 --> 00:12:08,880
the child can do whatever the hell it

322
00:12:06,320 --> 00:12:08,880
wants with them

323
00:12:09,760 --> 00:12:14,399
registers zero to three are used for the

324
00:12:11,839 --> 00:12:17,600
parameters and the return values

325
00:12:14,399 --> 00:12:20,000
um our zero is the first one by the

326
00:12:17,600 --> 00:12:22,880
calling convention and it also contains

327
00:12:20,000 --> 00:12:25,040
the 32-bit word that you might return if

328
00:12:22,880 --> 00:12:28,240
you return a 64-bit word

329
00:12:25,040 --> 00:12:31,120
then you will also use r1

330
00:12:28,240 --> 00:12:32,880
and you're under no responsibility to

331
00:12:31,120 --> 00:12:35,120
preserve

332
00:12:32,880 --> 00:12:36,560
the other parameters so the the trial

333
00:12:35,120 --> 00:12:37,600
function can clobber any of these that

334
00:12:36,560 --> 00:12:39,119
it wants to

335
00:12:37,600 --> 00:12:41,360
and if the parent expects it to be the

336
00:12:39,120 --> 00:12:42,959
same it's it's responsibility to save it

337
00:12:41,360 --> 00:12:45,360
onto the call stack before branching to

338
00:12:42,959 --> 00:12:45,359
the child

339
00:12:47,680 --> 00:12:50,719
but you're going to come here for a

340
00:12:50,079 --> 00:12:54,399
description

341
00:12:50,720 --> 00:12:56,160
of the uh the number of registers

342
00:12:54,399 --> 00:12:58,000
their names and stuff um you wanted to

343
00:12:56,160 --> 00:13:00,639
know how you could get code and begin

344
00:12:58,000 --> 00:13:00,639
working with it

345
00:13:01,040 --> 00:13:04,959
so there are a couple of different ways

346
00:13:03,360 --> 00:13:07,839
to

347
00:13:04,959 --> 00:13:08,399
to get the firmware um the easiest of

348
00:13:07,839 --> 00:13:12,000
course

349
00:13:08,399 --> 00:13:13,279
is a firmware update um

350
00:13:12,000 --> 00:13:15,360
brian when you're trying to mess with

351
00:13:13,279 --> 00:13:17,680
something what what fraction of the time

352
00:13:15,360 --> 00:13:19,519
do you get the firmware for free just by

353
00:13:17,680 --> 00:13:22,880
looking at an update or executable

354
00:13:19,519 --> 00:13:25,519
or the vendors i'd say yeah

355
00:13:22,880 --> 00:13:26,959
i'd say uh you get lucky on that about

356
00:13:25,519 --> 00:13:30,560
80 percent of the time

357
00:13:26,959 --> 00:13:34,000
it's uh you know you can just

358
00:13:30,560 --> 00:13:35,760
um sometimes i mean not handed off but

359
00:13:34,000 --> 00:13:37,760
you know yeah get it out of like a

360
00:13:35,760 --> 00:13:39,279
you know application download that goes

361
00:13:37,760 --> 00:13:41,279
through the smartphone and you can sniff

362
00:13:39,279 --> 00:13:43,760
on the wire or something right

363
00:13:41,279 --> 00:13:45,120
yeah uh for bluetooth you'll have to do

364
00:13:43,760 --> 00:13:48,720
chip extraction

365
00:13:45,120 --> 00:13:51,199
for bluetooth devices in particular um

366
00:13:48,720 --> 00:13:53,440
android has excellent support for

367
00:13:51,199 --> 00:13:56,719
logging bluetooth to disk

368
00:13:53,440 --> 00:13:57,920
which you can then replay in wireshark

369
00:13:56,720 --> 00:13:59,360
in order to

370
00:13:57,920 --> 00:14:01,120
capture the firmware update as it goes

371
00:13:59,360 --> 00:14:04,800
up there

372
00:14:01,120 --> 00:14:07,760
um another way of grabbing it

373
00:14:04,800 --> 00:14:09,359
is through jtag which is a debugging

374
00:14:07,760 --> 00:14:12,079
protocol that's very often

375
00:14:09,360 --> 00:14:13,440
unlocked and if jtag is unlocked then

376
00:14:12,079 --> 00:14:17,040
you can connect a debugger

377
00:14:13,440 --> 00:14:18,880
and dump an image out there's also a rom

378
00:14:17,040 --> 00:14:20,240
boot loader which can be either locked

379
00:14:18,880 --> 00:14:21,839
or unlocked

380
00:14:20,240 --> 00:14:24,240
if it's unlocked you just read it out

381
00:14:21,839 --> 00:14:26,480
through the serial port

382
00:14:24,240 --> 00:14:27,920
um but if if jtag or the wrong

383
00:14:26,480 --> 00:14:31,680
bootloader are locked

384
00:14:27,920 --> 00:14:35,360
there are still options so

385
00:14:31,680 --> 00:14:37,199
for a specific example the stm32f0

386
00:14:35,360 --> 00:14:41,040
family is rather popular

387
00:14:37,199 --> 00:14:43,120
um it has a vulnerability in its

388
00:14:41,040 --> 00:14:44,079
jtag implementation which i believe was

389
00:14:43,120 --> 00:14:47,760
first documented

390
00:14:44,079 --> 00:14:47,760
at using 2017.

391
00:14:48,000 --> 00:14:51,199
the vulnerability is that when you

392
00:14:50,560 --> 00:14:56,160
attach

393
00:14:51,199 --> 00:14:58,719
jtag to the spm32f0

394
00:14:56,160 --> 00:14:59,600
flash memory is disconnected from the

395
00:14:58,720 --> 00:15:02,959
cpu core

396
00:14:59,600 --> 00:15:04,240
and the memory bus the idea here is that

397
00:15:02,959 --> 00:15:07,839
if you think that there is

398
00:15:04,240 --> 00:15:11,120
a functionality problem with your device

399
00:15:07,839 --> 00:15:13,120
you're free to connect a debugger

400
00:15:11,120 --> 00:15:14,560
to check for that but you're not allowed

401
00:15:13,120 --> 00:15:16,240
to read the code out of it that you

402
00:15:14,560 --> 00:15:19,279
would need to copy the device

403
00:15:16,240 --> 00:15:21,279
or to reverse engineer it

404
00:15:19,279 --> 00:15:23,199
there's a minor problem here which is

405
00:15:21,279 --> 00:15:25,519
that sram is still exposed

406
00:15:23,199 --> 00:15:26,639
because it's not disconnected but the

407
00:15:25,519 --> 00:15:29,920
major problem

408
00:15:26,639 --> 00:15:30,560
that was presented used in exclude is

409
00:15:29,920 --> 00:15:33,680
that

410
00:15:30,560 --> 00:15:38,000
when you attach jtag

411
00:15:33,680 --> 00:15:41,519
flash is disconnected one cycle too late

412
00:15:38,000 --> 00:15:45,920
so your jk debugger can

413
00:15:41,519 --> 00:15:48,320
uh dump out a single word per connection

414
00:15:45,920 --> 00:15:49,920
and by repeatedly reconnecting and

415
00:15:48,320 --> 00:15:52,839
resetting the device

416
00:15:49,920 --> 00:15:55,839
the jtag debugger can dump out all the

417
00:15:52,839 --> 00:15:55,839
firmware

418
00:15:56,480 --> 00:16:03,199
the nrf51 is another popular

419
00:15:59,759 --> 00:16:03,199
jtag there's another popular

420
00:16:04,079 --> 00:16:07,599
embedded arm chip with radio support

421
00:16:06,880 --> 00:16:10,240
this is the

422
00:16:07,600 --> 00:16:12,240
one of the first bluetooth ships that

423
00:16:10,240 --> 00:16:15,440
supported bluetooth low energy

424
00:16:12,240 --> 00:16:18,560
and was nice to program

425
00:16:15,440 --> 00:16:19,440
um there's similar there's a similar

426
00:16:18,560 --> 00:16:22,000
situation here

427
00:16:19,440 --> 00:16:24,160
in that jtag was supposed to be able to

428
00:16:22,000 --> 00:16:26,079
connect to the chip

429
00:16:24,160 --> 00:16:28,399
without being able to dump out all of

430
00:16:26,079 --> 00:16:31,439
code when the device is locked

431
00:16:28,399 --> 00:16:34,399
the vulnerability here is that you're

432
00:16:31,440 --> 00:16:37,440
still allowed to single step the cpu

433
00:16:34,399 --> 00:16:40,560
and you're still allowed to

434
00:16:37,440 --> 00:16:42,079
um view its registers you can read them

435
00:16:40,560 --> 00:16:44,079
and you can write them

436
00:16:42,079 --> 00:16:46,160
um you're just not allowed to do the

437
00:16:44,079 --> 00:16:49,040
extra memory yourself

438
00:16:46,160 --> 00:16:49,360
so what they did was uh with chris brush

439
00:16:49,040 --> 00:16:52,880
did

440
00:16:49,360 --> 00:16:56,480
in 2015 was he found an instruction that

441
00:16:52,880 --> 00:16:58,639
loads the um

442
00:16:56,480 --> 00:17:00,320
the word in memory at the address that's

443
00:16:58,639 --> 00:17:03,199
in register zero it takes that word and

444
00:17:00,320 --> 00:17:06,240
it loads it into register one

445
00:17:03,199 --> 00:17:08,720
um and after he finds that instruction

446
00:17:06,240 --> 00:17:10,480
he can then loop through this

447
00:17:08,720 --> 00:17:11,520
instruction while changing the value of

448
00:17:10,480 --> 00:17:13,520
register zero

449
00:17:11,520 --> 00:17:15,119
in order to dump all of the firmware out

450
00:17:13,520 --> 00:17:18,720
the jtech port

451
00:17:15,119 --> 00:17:21,039
even though the chip is locked

452
00:17:18,720 --> 00:17:22,000
and once you have the firmware you can

453
00:17:21,039 --> 00:17:24,480
unlock the chip

454
00:17:22,000 --> 00:17:25,359
or replace it with a new chip right in

455
00:17:24,480 --> 00:17:26,959
the firmware

456
00:17:25,359 --> 00:17:29,438
and continue debugging with full

457
00:17:26,959 --> 00:17:29,439
privileges

458
00:17:29,760 --> 00:17:34,160
there are also bugs in uh master on boot

459
00:17:33,440 --> 00:17:37,200
loaders

460
00:17:34,160 --> 00:17:37,600
um i used to love writing exploits for

461
00:17:37,200 --> 00:17:39,200
these

462
00:17:37,600 --> 00:17:40,719
because when you find a vulnerability in

463
00:17:39,200 --> 00:17:44,320
a mask rom

464
00:17:40,720 --> 00:17:46,880
and you exploit it you generally have an

465
00:17:44,320 --> 00:17:46,879
expert live

466
00:17:49,520 --> 00:17:52,799
and ryan how long do they live

467
00:17:53,360 --> 00:18:00,240
they they never go away these are the

468
00:17:55,039 --> 00:18:03,120
best ones have you ever seen one patched

469
00:18:00,240 --> 00:18:04,720
i think somebody passed one once by

470
00:18:03,120 --> 00:18:06,320
ripping everything out of the field and

471
00:18:04,720 --> 00:18:08,080
pushing out all new chips but

472
00:18:06,320 --> 00:18:09,439
it's just not uh not something people

473
00:18:08,080 --> 00:18:12,240
like to do

474
00:18:09,440 --> 00:18:13,280
so the cost of patching this is that you

475
00:18:12,240 --> 00:18:16,400
need to

476
00:18:13,280 --> 00:18:17,520
begin manufacturing new chips of every

477
00:18:16,400 --> 00:18:20,799
affected item

478
00:18:17,520 --> 00:18:21,679
in the family which requires the mask

479
00:18:20,799 --> 00:18:23,360
revision

480
00:18:21,679 --> 00:18:25,440
so you're looking at about a minimum of

481
00:18:23,360 --> 00:18:28,799
a quarter million dollars

482
00:18:25,440 --> 00:18:32,240
per unique model number in the family

483
00:18:28,799 --> 00:18:33,760
so in the case of stm32

484
00:18:32,240 --> 00:18:36,960
they would need to do this separately

485
00:18:33,760 --> 00:18:42,000
for the stm32f407

486
00:18:36,960 --> 00:18:44,880
and 417 and 207 and 217

487
00:18:42,000 --> 00:18:47,360
and so on so the these bugs live a very

488
00:18:44,880 --> 00:18:49,039
very long time

489
00:18:47,360 --> 00:18:53,039
they're the sort of thing where when you

490
00:18:49,039 --> 00:18:54,799
um when you find one as a defender

491
00:18:53,039 --> 00:18:56,640
there's not much that you can do about

492
00:18:54,799 --> 00:18:57,760
it certainly can't upgrade anything in

493
00:18:56,640 --> 00:19:00,240
the field

494
00:18:57,760 --> 00:19:01,679
and if you have the decision to burn

495
00:19:00,240 --> 00:19:04,240
your warehouse into the ground and

496
00:19:01,679 --> 00:19:06,720
remanufacture the chips from scratch

497
00:19:04,240 --> 00:19:11,840
over a security bug you generally choose

498
00:19:06,720 --> 00:19:11,840
not to do it

499
00:19:12,640 --> 00:19:17,200
when i'm hunting for a bootloader

500
00:19:14,720 --> 00:19:18,880
vulnerability

501
00:19:17,200 --> 00:19:21,120
this is one of my favorite tricks that

502
00:19:18,880 --> 00:19:24,480
would never work on a pc

503
00:19:21,120 --> 00:19:27,520
um on a pc you have something called a

504
00:19:24,480 --> 00:19:29,840
guard page at uh

505
00:19:27,520 --> 00:19:30,720
address zero and the purpose of the

506
00:19:29,840 --> 00:19:33,360
guard page

507
00:19:30,720 --> 00:19:35,360
is that if you ever have a null pointer

508
00:19:33,360 --> 00:19:38,240
meaning that the pointer is zero

509
00:19:35,360 --> 00:19:40,000
and you try to read from address zero

510
00:19:38,240 --> 00:19:42,000
the guard page will trap

511
00:19:40,000 --> 00:19:45,039
and inform the operating system and the

512
00:19:42,000 --> 00:19:47,520
operating system will kill your process

513
00:19:45,039 --> 00:19:49,840
and the reason for that is that very

514
00:19:47,520 --> 00:19:52,320
often you forget to initialize something

515
00:19:49,840 --> 00:19:54,000
or you try to allocate a buffer when

516
00:19:52,320 --> 00:19:54,480
you're out of memory or any number of

517
00:19:54,000 --> 00:19:57,280
things

518
00:19:54,480 --> 00:19:57,280
and you're stuck

519
00:19:58,000 --> 00:20:01,039
on embedded systems it works differently

520
00:20:00,400 --> 00:20:03,039
um

521
00:20:01,039 --> 00:20:04,400
this code here the the print data

522
00:20:03,039 --> 00:20:05,440
function that i've thrown together that

523
00:20:04,400 --> 00:20:07,440
just prints

524
00:20:05,440 --> 00:20:09,039
uh the bytes at a location in

525
00:20:07,440 --> 00:20:11,679
hexadecimal

526
00:20:09,039 --> 00:20:13,520
um this will dump the beginning of your

527
00:20:11,679 --> 00:20:16,640
firmware image if you call it

528
00:20:13,520 --> 00:20:17,600
for thumb length and for address equals

529
00:20:16,640 --> 00:20:20,880
zero

530
00:20:17,600 --> 00:20:23,439
on many embedded arm chips because

531
00:20:20,880 --> 00:20:26,640
quite a few of them will locate whatever

532
00:20:23,440 --> 00:20:28,400
memory you booted from to address zero

533
00:20:26,640 --> 00:20:30,640
meaning that when you dereference a null

534
00:20:28,400 --> 00:20:31,760
pointer you get the beginning of your

535
00:20:30,640 --> 00:20:33,760
code

536
00:20:31,760 --> 00:20:34,799
so if you can ever find a place either

537
00:20:33,760 --> 00:20:36,480
in the application

538
00:20:34,799 --> 00:20:38,559
or in the bootloader where you can trick

539
00:20:36,480 --> 00:20:41,440
it into sending you

540
00:20:38,559 --> 00:20:43,200
uh data from the device's own memory at

541
00:20:41,440 --> 00:20:49,840
address zero

542
00:20:43,200 --> 00:20:49,840
you have a firmware

543
00:20:50,400 --> 00:20:59,039
this brings us to the concept of um

544
00:20:54,960 --> 00:20:59,039
what is in memory at which location

545
00:20:59,360 --> 00:21:05,439
this is the memory map from

546
00:21:03,039 --> 00:21:06,640
the pocket gtfo article that ryan and i

547
00:21:05,440 --> 00:21:09,760
published

548
00:21:06,640 --> 00:21:13,679
uh it was illustrated by angela martini

549
00:21:09,760 --> 00:21:15,440
and you know the

550
00:21:13,679 --> 00:21:17,840
the only advantage of doing this lecture

551
00:21:15,440 --> 00:21:18,799
remotely is that you can read some of

552
00:21:17,840 --> 00:21:22,000
the

553
00:21:18,799 --> 00:21:26,080
uh the items on this list

554
00:21:22,000 --> 00:21:29,919
the um is being

555
00:21:26,080 --> 00:21:32,000
that memory is sort of arranged into 512

556
00:21:29,919 --> 00:21:34,480
megabyte regions

557
00:21:32,000 --> 00:21:35,440
and that you've got a full 32-bit

558
00:21:34,480 --> 00:21:38,880
address space

559
00:21:35,440 --> 00:21:40,960
so four gigabytes of memory that can

560
00:21:38,880 --> 00:21:43,039
possibly be addressed

561
00:21:40,960 --> 00:21:44,000
for a microcontroller with one megabyte

562
00:21:43,039 --> 00:21:48,879
of flash

563
00:21:44,000 --> 00:21:48,880
and 192 kilobytes of ram

564
00:21:51,120 --> 00:21:56,320
here's the and travis maybe just

565
00:21:54,720 --> 00:21:58,240
covered for people how if they don't

566
00:21:56,320 --> 00:21:59,200
have a poc or gtfo article to reference

567
00:21:58,240 --> 00:22:02,240
the memory map

568
00:21:59,200 --> 00:22:04,720
they might find that in documentation

569
00:22:02,240 --> 00:22:05,679
oh yes so this is always in either the

570
00:22:04,720 --> 00:22:07,760
data sheet

571
00:22:05,679 --> 00:22:10,000
or the programmer's guide which is

572
00:22:07,760 --> 00:22:12,080
sometimes called a family guide

573
00:22:10,000 --> 00:22:14,799
it will be unique to your chip or at

574
00:22:12,080 --> 00:22:19,120
least to the chip's family

575
00:22:14,799 --> 00:22:22,559
and it will um it will tell you

576
00:22:19,120 --> 00:22:24,879
um which pointer goes to which location

577
00:22:22,559 --> 00:22:26,080
if you're so unlucky that you do not

578
00:22:24,880 --> 00:22:28,559
have documentation

579
00:22:26,080 --> 00:22:31,840
for this or it's not in the data sheets

580
00:22:28,559 --> 00:22:34,000
you'll find it in the linking scripts

581
00:22:31,840 --> 00:22:36,000
and if you don't have the linking

582
00:22:34,000 --> 00:22:38,880
scripts freely available from

583
00:22:36,000 --> 00:22:40,559
the manufacturer you can very often find

584
00:22:38,880 --> 00:22:42,000
them included with commercial c

585
00:22:40,559 --> 00:22:45,120
compilots

586
00:22:42,000 --> 00:22:46,480
and since you're not trying to do you're

587
00:22:45,120 --> 00:22:48,239
not trying to use the compiler you're

588
00:22:46,480 --> 00:22:50,960
just trying to read its header files

589
00:22:48,240 --> 00:22:55,360
it's very often not restricted by the

590
00:22:50,960 --> 00:22:58,320
compiler's license enforcement

591
00:22:55,360 --> 00:22:59,120
when you look into the list you'll see

592
00:22:58,320 --> 00:23:01,439
that

593
00:22:59,120 --> 00:23:03,600
everything is sort of organized by the

594
00:23:01,440 --> 00:23:06,880
most significant bits

595
00:23:03,600 --> 00:23:09,199
of the of the address

596
00:23:06,880 --> 00:23:11,760
in this table here we're only looking at

597
00:23:09,200 --> 00:23:15,200
the most significant byte

598
00:23:11,760 --> 00:23:17,280
if um if that byte is c0

599
00:23:15,200 --> 00:23:19,039
we know that we're looking at mask from

600
00:23:17,280 --> 00:23:20,639
this is the wrong boot loader that is

601
00:23:19,039 --> 00:23:23,200
physically baked into the chip that

602
00:23:20,640 --> 00:23:26,320
cannot be patched or changed

603
00:23:23,200 --> 00:23:28,720
if the first part is before

604
00:23:26,320 --> 00:23:29,918
zero we know that this is in the i o

605
00:23:28,720 --> 00:23:34,080
region

606
00:23:29,919 --> 00:23:34,880
and that the um the thing being pointed

607
00:23:34,080 --> 00:23:38,240
to

608
00:23:34,880 --> 00:23:41,679
is something like a counter or a timer

609
00:23:38,240 --> 00:23:44,960
or a serial port that it interfaces with

610
00:23:41,679 --> 00:23:46,960
the outside world from the cpu core

611
00:23:44,960 --> 00:23:48,400
if the first pipe is twenty and

612
00:23:46,960 --> 00:23:50,880
hexadecimal we know that it's

613
00:23:48,400 --> 00:23:53,120
s gram and if it's 10 in hexadecimal we

614
00:23:50,880 --> 00:23:55,440
know that it's tightly coupled round

615
00:23:53,120 --> 00:23:59,039
which on this particular chip happens to

616
00:23:55,440 --> 00:24:00,640
be slightly faster but is not executable

617
00:23:59,039 --> 00:24:02,000
and the vast majority of the pointers

618
00:24:00,640 --> 00:24:03,840
that you see when taking the firmware

619
00:24:02,000 --> 00:24:06,000
apart will begin with zero eight which

620
00:24:03,840 --> 00:24:09,279
means that they're in flash memory

621
00:24:06,000 --> 00:24:11,120
which can't be freely written simply by

622
00:24:09,279 --> 00:24:13,600
writing to an address

623
00:24:11,120 --> 00:24:14,879
like the other memories can but it is

624
00:24:13,600 --> 00:24:16,840
directly executable

625
00:24:14,880 --> 00:24:18,320
and it's where the majority of our code

626
00:24:16,840 --> 00:24:23,120
runs

627
00:24:18,320 --> 00:24:26,320
and then on this chip the stm32f4 series

628
00:24:23,120 --> 00:24:29,039
if the first byte is a zero that alias

629
00:24:26,320 --> 00:24:32,320
to whichever memory we booted from which

630
00:24:29,039 --> 00:24:34,320
is probably either the mask rom or flash

631
00:24:32,320 --> 00:24:38,320
but the hardware does allow booting from

632
00:24:34,320 --> 00:24:38,320
sram for development purposes

633
00:24:41,760 --> 00:24:50,640
so let's take a look at some pointers um

634
00:24:47,279 --> 00:24:54,159
20 again from our list above

635
00:24:50,640 --> 00:24:57,679
20 is in f ram so

636
00:24:54,159 --> 00:25:00,080
the first pointer is to

637
00:24:57,679 --> 00:25:02,480
srm this is like a global variable

638
00:25:00,080 --> 00:25:02,480
perhaps

639
00:25:02,559 --> 00:25:06,240
the second and the third pointers those

640
00:25:05,679 --> 00:25:10,960
are both

641
00:25:06,240 --> 00:25:10,960
odd and they both begin with zero eight

642
00:25:11,200 --> 00:25:18,400
zero eight tells me that they are in

643
00:25:14,240 --> 00:25:18,400
um that they're in flash memory

644
00:25:19,200 --> 00:25:22,960
but they're being odd the least

645
00:25:20,480 --> 00:25:25,039
significant bit being off by one

646
00:25:22,960 --> 00:25:26,240
tells me that these are either very

647
00:25:25,039 --> 00:25:30,080
strange pointers

648
00:25:26,240 --> 00:25:30,880
to a byte offset which exists for rather

649
00:25:30,080 --> 00:25:33,199
rare

650
00:25:30,880 --> 00:25:34,159
or far more likely they're odd because

651
00:25:33,200 --> 00:25:36,960
their code

652
00:25:34,159 --> 00:25:38,080
and their thumb two code because

653
00:25:36,960 --> 00:25:41,760
remember this ship

654
00:25:38,080 --> 00:25:43,678
cannot run the classic 32-bit wide arm

655
00:25:41,760 --> 00:25:47,120
instruction set

656
00:25:43,679 --> 00:25:50,320
it's unable to

657
00:25:47,120 --> 00:25:51,840
have code and even addresses so every

658
00:25:50,320 --> 00:25:54,000
function pointer that you find will be

659
00:25:51,840 --> 00:25:57,199
odd

660
00:25:54,000 --> 00:25:57,600
and then this last one uh four zero zero

661
00:25:57,200 --> 00:26:00,799
two

662
00:25:57,600 --> 00:26:02,879
three c zero zero

663
00:26:00,799 --> 00:26:04,240
that's in the i o region which we know

664
00:26:02,880 --> 00:26:07,520
because it begins with

665
00:26:04,240 --> 00:26:08,640
uh 40 and hexadecimal and there are

666
00:26:07,520 --> 00:26:12,320
header files

667
00:26:08,640 --> 00:26:15,200
for this chip that define

668
00:26:12,320 --> 00:26:16,879
all of the i o addresses this happens to

669
00:26:15,200 --> 00:26:17,760
be the flash control register so

670
00:26:16,880 --> 00:26:21,279
whatever function

671
00:26:17,760 --> 00:26:24,799
contains this pointer

672
00:26:21,279 --> 00:26:27,279
that function is interacting with

673
00:26:24,799 --> 00:26:28,320
flash memory it might be writing it or

674
00:26:27,279 --> 00:26:32,720
it might be

675
00:26:28,320 --> 00:26:32,720
um locking the chip

676
00:26:33,200 --> 00:26:36,880
we can then search for these numbers in

677
00:26:35,120 --> 00:26:38,320
order to find all of the functions that

678
00:26:36,880 --> 00:26:40,000
involve flash memory

679
00:26:38,320 --> 00:26:42,559
or all of the functions that involve a

680
00:26:40,000 --> 00:26:44,400
particular serial port

681
00:26:42,559 --> 00:26:45,840
and by doing that we can then narrow

682
00:26:44,400 --> 00:26:47,919
down

683
00:26:45,840 --> 00:26:53,840
the code to the individual function that

684
00:26:47,919 --> 00:26:53,840
we care about

685
00:26:57,039 --> 00:27:00,720
um ryan i've been hugging the mic would

686
00:26:59,200 --> 00:27:01,520
you care to talk about the interrupt

687
00:27:00,720 --> 00:27:05,600
vector table

688
00:27:01,520 --> 00:27:08,879
and what it means sure i can go through

689
00:27:05,600 --> 00:27:08,879
that um

690
00:27:09,919 --> 00:27:15,600
let's see actually travis why don't you

691
00:27:13,919 --> 00:27:18,240
start and i'll jump in on the next one

692
00:27:15,600 --> 00:27:19,360
that'll work so the interrupt vector

693
00:27:18,240 --> 00:27:21,679
table begins

694
00:27:19,360 --> 00:27:22,719
at the very beginning of an arm from our

695
00:27:21,679 --> 00:27:24,320
image

696
00:27:22,720 --> 00:27:26,480
when you get a firmware image you don't

697
00:27:24,320 --> 00:27:28,320
get a exe

698
00:27:26,480 --> 00:27:30,399
file or an elf file like you would in

699
00:27:28,320 --> 00:27:33,279
windows or in linux

700
00:27:30,399 --> 00:27:34,479
instead you very often get just a blob

701
00:27:33,279 --> 00:27:36,640
of bytes

702
00:27:34,480 --> 00:27:38,480
and you need to figure out where those

703
00:27:36,640 --> 00:27:40,880
bytes need to be loaded

704
00:27:38,480 --> 00:27:42,960
and you also need to figure out inside

705
00:27:40,880 --> 00:27:47,279
of memory

706
00:27:42,960 --> 00:27:50,559
where the basic functions are

707
00:27:47,279 --> 00:27:54,320
this table begins with the initial

708
00:27:50,559 --> 00:27:56,240
stack pointer which is a really cool

709
00:27:54,320 --> 00:27:58,080
thing kind of unique to microcontrollers

710
00:27:56,240 --> 00:28:00,840
because it means that

711
00:27:58,080 --> 00:28:02,480
from the very instant the program begins

712
00:28:00,840 --> 00:28:05,520
running

713
00:28:02,480 --> 00:28:09,120
it has a functioning call stack

714
00:28:05,520 --> 00:28:11,360
yeah so that's that's r13

715
00:28:09,120 --> 00:28:13,678
yes and that means that your reset

716
00:28:11,360 --> 00:28:15,279
vector which is the entry point for your

717
00:28:13,679 --> 00:28:17,760
code

718
00:28:15,279 --> 00:28:18,640
your reset vector can be written in c

719
00:28:17,760 --> 00:28:21,520
and you don't need

720
00:28:18,640 --> 00:28:22,960
any custom assembly language to write

721
00:28:21,520 --> 00:28:26,320
the beginning of your

722
00:28:22,960 --> 00:28:31,840
kernel on an arm

723
00:28:26,320 --> 00:28:31,840
cortex m firmware image

724
00:28:32,320 --> 00:28:39,039
so these are the beginning bytes

725
00:28:35,360 --> 00:28:42,559
of a real firmware image for

726
00:28:39,039 --> 00:28:46,000
um a cortex m3 chip

727
00:28:42,559 --> 00:28:48,399
you see that address zero we have

728
00:28:46,000 --> 00:28:50,080
um these four bytes in hexadecimal we

729
00:28:48,399 --> 00:28:53,360
have 30 14

730
00:28:50,080 --> 00:28:54,799
0 0 20. and

731
00:28:53,360 --> 00:28:57,360
because this is a little ending in

732
00:28:54,799 --> 00:29:00,639
architecture we read them backward

733
00:28:57,360 --> 00:29:01,279
so the first 32-bit word in memory is 2

734
00:29:00,640 --> 00:29:04,480
0

735
00:29:01,279 --> 00:29:08,240
0 0 14 30.

736
00:29:04,480 --> 00:29:09,840
the 2 0 is an sram and that's our stack

737
00:29:08,240 --> 00:29:12,640
pointer

738
00:29:09,840 --> 00:29:14,879
and the value after that reading the

739
00:29:12,640 --> 00:29:17,919
next four bytes backward

740
00:29:14,880 --> 00:29:21,360
if you follow along is zero eight zero

741
00:29:17,919 --> 00:29:23,760
zero four one two one

742
00:29:21,360 --> 00:29:24,879
well the zero eight the most significant

743
00:29:23,760 --> 00:29:28,080
byte tells us

744
00:29:24,880 --> 00:29:30,000
that it's in flash memory and q1

745
00:29:28,080 --> 00:29:33,279
the least significant byte is odd which

746
00:29:30,000 --> 00:29:36,559
tells us that it's thumb code

747
00:29:33,279 --> 00:29:38,960
so when we decode these we get first

748
00:29:36,559 --> 00:29:40,240
the initial fact pointer which tells us

749
00:29:38,960 --> 00:29:43,440
which piece of ram

750
00:29:40,240 --> 00:29:45,760
the firmware is using

751
00:29:43,440 --> 00:29:47,360
and then we get a bunch of interrupt

752
00:29:45,760 --> 00:29:49,039
handler addresses beginning with the

753
00:29:47,360 --> 00:29:51,760
entry point of the program

754
00:29:49,039 --> 00:29:53,440
and continuing on to other events like

755
00:29:51,760 --> 00:29:57,200
receiving a byte

756
00:29:53,440 --> 00:29:59,760
on a serial port or um

757
00:29:57,200 --> 00:30:00,720
having the nmi tin or non-maskable

758
00:29:59,760 --> 00:30:04,399
interrupt

759
00:30:00,720 --> 00:30:07,679
uh attacks and

760
00:30:04,399 --> 00:30:08,479
we can work on the component pieces of

761
00:30:07,679 --> 00:30:12,640
the firmware

762
00:30:08,480 --> 00:30:14,000
in order to um in order to confirm

763
00:30:12,640 --> 00:30:16,480
that we have it loaded to the right

764
00:30:14,000 --> 00:30:16,480
location

765
00:30:18,559 --> 00:30:22,240
so the next step uh the one that you've

766
00:30:20,640 --> 00:30:23,840
been waiting for is actually loading

767
00:30:22,240 --> 00:30:26,880
this into ida pro

768
00:30:23,840 --> 00:30:32,320
or binary ninja or guidra

769
00:30:26,880 --> 00:30:35,279
or vadara 2 and doing something with it

770
00:30:32,320 --> 00:30:36,320
when you go through this and the concept

771
00:30:35,279 --> 00:30:40,000
go ahead trash

772
00:30:36,320 --> 00:30:43,918
oh sorry sorry when you um

773
00:30:40,000 --> 00:30:46,480
when you open the file in ida um it sees

774
00:30:43,919 --> 00:30:47,279
this as a bunch of bikes and it doesn't

775
00:30:46,480 --> 00:30:48,960
really know

776
00:30:47,279 --> 00:30:50,960
the instruction set or the loading

777
00:30:48,960 --> 00:30:53,200
location or any of those details

778
00:30:50,960 --> 00:30:54,880
so you need to help it out a little bit

779
00:30:53,200 --> 00:30:57,440
the first thing that you need to do is

780
00:30:54,880 --> 00:30:59,760
change the processor type manually to

781
00:30:57,440 --> 00:31:02,720
arm little engine

782
00:30:59,760 --> 00:31:03,360
arm at some point did make big endian

783
00:31:02,720 --> 00:31:04,960
machines

784
00:31:03,360 --> 00:31:06,559
and even machines that can switch back

785
00:31:04,960 --> 00:31:07,679
and forth between big engine and little

786
00:31:06,559 --> 00:31:09,519
indian mode

787
00:31:07,679 --> 00:31:12,000
but these days it'll be rather rare for

788
00:31:09,519 --> 00:31:14,159
you to find the beginning firmware

789
00:31:12,000 --> 00:31:15,919
so you choose little indian and then in

790
00:31:14,159 --> 00:31:20,000
processor options

791
00:31:15,919 --> 00:31:23,360
um you have all of these fancy uh

792
00:31:20,000 --> 00:31:24,720
variants of the instruction set but arm

793
00:31:23,360 --> 00:31:26,879
is pretty good about keeping them

794
00:31:24,720 --> 00:31:28,640
backward compatible

795
00:31:26,880 --> 00:31:30,320
so about the only thing that you need to

796
00:31:28,640 --> 00:31:33,360
do for these images

797
00:31:30,320 --> 00:31:33,918
is mark that the architecture does not

798
00:31:33,360 --> 00:31:37,360
support

799
00:31:33,919 --> 00:31:37,360
32-bit wide instructions

800
00:31:38,799 --> 00:31:44,799
and then ida is going to ask you um

801
00:31:42,240 --> 00:31:46,480
for the memory organization and if you

802
00:31:44,799 --> 00:31:50,240
remember that memory map

803
00:31:46,480 --> 00:31:54,159
that i showed you earlier this is where

804
00:31:50,240 --> 00:31:57,200
you present the memory map to item

805
00:31:54,159 --> 00:32:00,799
so we do need a ram section

806
00:31:57,200 --> 00:32:04,559
or code that tries to read and write ram

807
00:32:00,799 --> 00:32:07,600
won't properly decompile

808
00:32:04,559 --> 00:32:11,120
and we also won't be able to track the

809
00:32:07,600 --> 00:32:12,158
global variables and we definitely need

810
00:32:11,120 --> 00:32:15,039
a rom

811
00:32:12,159 --> 00:32:16,960
stacker but ida defaults both of these

812
00:32:15,039 --> 00:32:20,000
to being at address zero

813
00:32:16,960 --> 00:32:21,919
and uh the ram to not even being of any

814
00:32:20,000 --> 00:32:25,679
size

815
00:32:21,919 --> 00:32:26,320
so we correct it by two methods the

816
00:32:25,679 --> 00:32:29,360
first

817
00:32:26,320 --> 00:32:32,158
uh the easy one is the ram we know

818
00:32:29,360 --> 00:32:34,879
from the data sheet where ram begins and

819
00:32:32,159 --> 00:32:38,640
how large it is

820
00:32:34,880 --> 00:32:40,320
here i begin ram at um

821
00:32:38,640 --> 00:32:42,960
the address with a high bite of 20

822
00:32:40,320 --> 00:32:45,200
because that's what i found in the

823
00:32:42,960 --> 00:32:47,679
memory map of the data sheet and i set

824
00:32:45,200 --> 00:32:48,159
the size to 128 kilobytes because that's

825
00:32:47,679 --> 00:32:51,039
also

826
00:32:48,159 --> 00:32:51,919
the value that i find in the data sheet

827
00:32:51,039 --> 00:32:55,039
the rom

828
00:32:51,919 --> 00:32:58,159
i load to a strange address it's

829
00:32:55,039 --> 00:33:02,799
zero eight zero zero and then um c

830
00:32:58,159 --> 00:33:05,519
thousand and the reason why i do that

831
00:33:02,799 --> 00:33:07,600
is because in this particular device

832
00:33:05,519 --> 00:33:09,760
there are two

833
00:33:07,600 --> 00:33:11,279
kernels and the first sits at the very

834
00:33:09,760 --> 00:33:13,200
beginning of flash memory

835
00:33:11,279 --> 00:33:16,320
and acts as a sort of recovery

836
00:33:13,200 --> 00:33:18,960
bootloader to start the second one

837
00:33:16,320 --> 00:33:20,799
and the offset for the second one i had

838
00:33:18,960 --> 00:33:23,600
to find

839
00:33:20,799 --> 00:33:24,720
uh by reading that first bootloader's

840
00:33:23,600 --> 00:33:27,840
code

841
00:33:24,720 --> 00:33:32,080
so now that i know that it begins

842
00:33:27,840 --> 00:33:36,240
just 48 kilobytes further in memory

843
00:33:32,080 --> 00:33:39,199
than i then the documentation

844
00:33:36,240 --> 00:33:40,240
says i can apply that in ida and have

845
00:33:39,200 --> 00:33:42,720
everything loaded at the correct

846
00:33:40,240 --> 00:33:42,720
location

847
00:33:43,120 --> 00:33:46,239
and there's one more thing that you'll

848
00:33:44,880 --> 00:33:48,480
need to do or

849
00:33:46,240 --> 00:33:50,320
ida will give you total garbage for your

850
00:33:48,480 --> 00:33:53,360
results

851
00:33:50,320 --> 00:33:56,720
which is that um when ida loads

852
00:33:53,360 --> 00:33:59,918
an arm image it's a little bit confused

853
00:33:56,720 --> 00:34:02,640
about the instruction set

854
00:33:59,919 --> 00:34:04,399
because um on the arm architecture you

855
00:34:02,640 --> 00:34:06,960
have two different instruction sets and

856
00:34:04,399 --> 00:34:10,799
you can freely jump between them

857
00:34:06,960 --> 00:34:14,399
so you need to use alt g

858
00:34:10,800 --> 00:34:16,960
and set the t value to be one

859
00:34:14,399 --> 00:34:17,598
when you do this you then told it that

860
00:34:16,960 --> 00:34:20,800
you want

861
00:34:17,599 --> 00:34:21,760
a code 16 section instead of a code 32

862
00:34:20,800 --> 00:34:23,440
section

863
00:34:21,760 --> 00:34:25,119
and from that point on the disassembly

864
00:34:23,440 --> 00:34:25,839
will be correct and then you can begin

865
00:34:25,119 --> 00:34:29,119
exploring

866
00:34:25,839 --> 00:34:29,119
and marking up your functions

867
00:34:30,159 --> 00:34:33,440
at the very beginning it knows nothing

868
00:34:32,079 --> 00:34:37,919
about it

869
00:34:33,440 --> 00:34:40,399
so you see code 32 as your organization

870
00:34:37,918 --> 00:34:40,960
everything is at the correct loading

871
00:34:40,399 --> 00:34:43,759
address

872
00:34:40,960 --> 00:34:44,639
and the bytes are correct but ida

873
00:34:43,760 --> 00:34:48,399
doesn't know where

874
00:34:44,639 --> 00:34:49,119
any functions begin so the first thing

875
00:34:48,399 --> 00:34:52,399
that you do

876
00:34:49,119 --> 00:34:53,280
is you type alt g and set t equals one

877
00:34:52,399 --> 00:34:58,319
in the dialog

878
00:34:53,280 --> 00:34:59,839
to change code 32 to code 16.

879
00:34:58,320 --> 00:35:02,000
the next thing that you do is you use

880
00:34:59,839 --> 00:35:06,400
the d key to mark

881
00:35:02,000 --> 00:35:10,000
these data bytes as being

882
00:35:06,400 --> 00:35:10,000
data words

883
00:35:11,280 --> 00:35:15,520
so once we mark all of them up as 32-bit

884
00:35:13,359 --> 00:35:17,598
words we find

885
00:35:15,520 --> 00:35:18,640
the internal table and it's very large

886
00:35:17,599 --> 00:35:19,920
it's more than a page in this

887
00:35:18,640 --> 00:35:22,960
architecture

888
00:35:19,920 --> 00:35:24,320
and each of these 32-bit addresses after

889
00:35:22,960 --> 00:35:26,800
the first one

890
00:35:24,320 --> 00:35:28,839
is a valid interrupt handler that the

891
00:35:26,800 --> 00:35:31,680
cpu will jump to when the right event

892
00:35:28,839 --> 00:35:35,599
happens

893
00:35:31,680 --> 00:35:38,160
we can then use this for a sanity check

894
00:35:35,599 --> 00:35:39,280
if we made a mistake at this point or up

895
00:35:38,160 --> 00:35:41,040
to this point

896
00:35:39,280 --> 00:35:42,960
if our alignment is off if our

897
00:35:41,040 --> 00:35:44,960
configuration is wrong

898
00:35:42,960 --> 00:35:46,720
there are tales that can let us know

899
00:35:44,960 --> 00:35:49,200
that we're about to waste our time by

900
00:35:46,720 --> 00:35:50,000
reverse engineering gobbledygook and let

901
00:35:49,200 --> 00:35:53,359
us sort of

902
00:35:50,000 --> 00:35:55,920
uh step back a minute and and take a

903
00:35:53,359 --> 00:35:55,920
second look

904
00:35:56,240 --> 00:36:00,160
the first thing to check is that some of

905
00:35:59,520 --> 00:36:03,359
the

906
00:36:00,160 --> 00:36:05,279
instructions are only two bytes wide

907
00:36:03,359 --> 00:36:07,520
implying that we're properly in thumb

908
00:36:05,280 --> 00:36:07,520
mode

909
00:36:08,079 --> 00:36:12,160
the other thing to check is that any

910
00:36:10,240 --> 00:36:15,279
function which is apparent

911
00:36:12,160 --> 00:36:18,399
meaning that it calls another function

912
00:36:15,280 --> 00:36:21,200
should begin by pushing

913
00:36:18,400 --> 00:36:23,040
the at least the link register and maybe

914
00:36:21,200 --> 00:36:25,680
some other registers

915
00:36:23,040 --> 00:36:26,960
and also at the end of that function it

916
00:36:25,680 --> 00:36:30,399
should pop those

917
00:36:26,960 --> 00:36:32,160
back um off of the stack

918
00:36:30,400 --> 00:36:35,040
and into the registers that came from

919
00:36:32,160 --> 00:36:35,040
before returning

920
00:36:35,520 --> 00:36:41,040
we should also check that every target

921
00:36:38,560 --> 00:36:43,040
of a branch and link instruction which

922
00:36:41,040 --> 00:36:45,119
is how function calls work

923
00:36:43,040 --> 00:36:46,320
that every function call is to a

924
00:36:45,119 --> 00:36:48,320
reasonable address

925
00:36:46,320 --> 00:36:50,240
meaning that when you look at the

926
00:36:48,320 --> 00:36:52,560
address that it's targeting

927
00:36:50,240 --> 00:36:54,640
you find the entry point of another

928
00:36:52,560 --> 00:36:57,160
valid function

929
00:36:54,640 --> 00:36:58,640
this one isn't as

930
00:36:57,160 --> 00:37:00,799
[Music]

931
00:36:58,640 --> 00:37:02,319
as useful as you would expect it to be

932
00:37:00,800 --> 00:37:05,440
because the branch and link

933
00:37:02,320 --> 00:37:07,280
instruction is relative in thumb to

934
00:37:05,440 --> 00:37:09,680
meaning that if i've loaded my image to

935
00:37:07,280 --> 00:37:12,960
the wrong address

936
00:37:09,680 --> 00:37:13,359
function calls will still work and we'll

937
00:37:12,960 --> 00:37:16,720
still

938
00:37:13,359 --> 00:37:20,480
jump to the correct address because

939
00:37:16,720 --> 00:37:23,118
they inherit the um the same mistake as

940
00:37:20,480 --> 00:37:25,520
our loading

941
00:37:23,119 --> 00:37:26,480
and then at the end of the function

942
00:37:25,520 --> 00:37:30,000
after

943
00:37:26,480 --> 00:37:32,320
the after the program counter

944
00:37:30,000 --> 00:37:33,599
is restored and the function goes back

945
00:37:32,320 --> 00:37:37,359
to its parent

946
00:37:33,599 --> 00:37:39,680
we will either find another function or

947
00:37:37,359 --> 00:37:40,799
some has something called a constant

948
00:37:39,680 --> 00:37:45,839
pool

949
00:37:40,800 --> 00:37:48,720
and the constant pool is used instead of

950
00:37:45,839 --> 00:37:49,599
where x86 would use immediate values so

951
00:37:48,720 --> 00:37:50,720
in x86

952
00:37:49,599 --> 00:37:53,520
you can have an instruction that

953
00:37:50,720 --> 00:37:55,919
contains a 32-bit word inside of it

954
00:37:53,520 --> 00:37:58,880
in thumb 2 the longest instruction is

955
00:37:55,920 --> 00:38:02,560
only 32 bits so there's no room for that

956
00:37:58,880 --> 00:38:04,960
constant to fit so instead you point it

957
00:38:02,560 --> 00:38:05,920
you point relatively to the end of your

958
00:38:04,960 --> 00:38:07,920
function

959
00:38:05,920 --> 00:38:09,520
where you have a list of all the 32-bit

960
00:38:07,920 --> 00:38:12,800
values you might want to load

961
00:38:09,520 --> 00:38:12,800
and it can be fetched from there

962
00:38:14,480 --> 00:38:18,400
this is an example of a thumb 2

963
00:38:16,839 --> 00:38:21,040
instruction it's

964
00:38:18,400 --> 00:38:22,400
a short one i use this one during a

965
00:38:21,040 --> 00:38:25,119
sanity check

966
00:38:22,400 --> 00:38:26,400
the purpose of this function is just to

967
00:38:25,119 --> 00:38:27,520
make sure that everything is loaded

968
00:38:26,400 --> 00:38:30,240
right

969
00:38:27,520 --> 00:38:31,040
we see that at the very beginning it

970
00:38:30,240 --> 00:38:33,359
pushes

971
00:38:31,040 --> 00:38:34,640
register 4 and the link register to the

972
00:38:33,359 --> 00:38:37,040
call stack

973
00:38:34,640 --> 00:38:39,359
at the very end it pops register 4 and

974
00:38:37,040 --> 00:38:42,560
the program counter off of it

975
00:38:39,359 --> 00:38:46,319
this is a neat way to cheaply return

976
00:38:42,560 --> 00:38:49,040
because in

977
00:38:46,320 --> 00:38:50,480
popping the value from the what was the

978
00:38:49,040 --> 00:38:52,400
link register at the time

979
00:38:50,480 --> 00:38:53,520
the function entered back into the

980
00:38:52,400 --> 00:38:57,359
program counter

981
00:38:53,520 --> 00:39:00,240
it can skip restoring that we also see

982
00:38:57,359 --> 00:39:02,160
a bl instruction in the middle which

983
00:39:00,240 --> 00:39:05,359
calls another

984
00:39:02,160 --> 00:39:05,759
function within the program jumping

985
00:39:05,359 --> 00:39:08,000
there

986
00:39:05,760 --> 00:39:14,800
i find a valid function which tells me

987
00:39:08,000 --> 00:39:18,640
that this is correctly loaded

988
00:39:14,800 --> 00:39:21,440
when you have your image and you begin

989
00:39:18,640 --> 00:39:24,319
to understand it

990
00:39:21,440 --> 00:39:26,320
you're generally trying to do it for um

991
00:39:24,320 --> 00:39:27,760
for some reason

992
00:39:26,320 --> 00:39:29,920
one reason might be to change the

993
00:39:27,760 --> 00:39:31,839
firmware on the physical device

994
00:39:29,920 --> 00:39:33,359
but another useful thing that you might

995
00:39:31,839 --> 00:39:36,480
want to do is

996
00:39:33,359 --> 00:39:37,598
extract a library from the physical

997
00:39:36,480 --> 00:39:40,160
device

998
00:39:37,599 --> 00:39:41,599
so that you can run it on your desktop

999
00:39:40,160 --> 00:39:43,759
this is especially true

1000
00:39:41,599 --> 00:39:46,000
if the library is proprietary or if you

1001
00:39:43,760 --> 00:39:49,119
can't um

1002
00:39:46,000 --> 00:39:52,000
you can't purchase the copy so

1003
00:39:49,119 --> 00:39:53,440
this radio the titera md380 has a

1004
00:39:52,000 --> 00:39:57,440
proprietary audio codec

1005
00:39:53,440 --> 00:40:00,640
called ambi plus two

1006
00:39:57,440 --> 00:40:00,640
and the um

1007
00:40:01,359 --> 00:40:04,960
if you want md plus two there's an open

1008
00:40:03,280 --> 00:40:06,560
source decoder

1009
00:40:04,960 --> 00:40:09,440
but there is nothing open source that

1010
00:40:06,560 --> 00:40:11,759
will encode the audio

1011
00:40:09,440 --> 00:40:13,599
instead you're supposed to purchase a

1012
00:40:11,760 --> 00:40:14,560
dongle that plugs into the serial port

1013
00:40:13,599 --> 00:40:17,440
it's supposed to send

1014
00:40:14,560 --> 00:40:21,279
your audio samples out the serial port

1015
00:40:17,440 --> 00:40:21,280
and then get back the compressed packets

1016
00:40:22,079 --> 00:40:25,520
so what you can do instead which is i

1017
00:40:24,880 --> 00:40:29,520
explained

1018
00:40:25,520 --> 00:40:32,079
in uh hypocrisy tfo 13 5

1019
00:40:29,520 --> 00:40:32,560
is you can take the firmware image that

1020
00:40:32,079 --> 00:40:34,079
you now

1021
00:40:32,560 --> 00:40:36,480
understand because you reverse

1022
00:40:34,079 --> 00:40:40,319
engineered pieces of it

1023
00:40:36,480 --> 00:40:44,480
and you can re-link it to be

1024
00:40:40,319 --> 00:40:47,440
a linux arm executable

1025
00:40:44,480 --> 00:40:50,319
you can then compile your own speed code

1026
00:40:47,440 --> 00:40:54,319
to run against that library

1027
00:40:50,319 --> 00:40:57,520
and the end result is that you have um

1028
00:40:54,319 --> 00:40:59,920
a unix command line tool that is able to

1029
00:40:57,520 --> 00:41:03,200
call the proprietary library functions

1030
00:40:59,920 --> 00:41:05,359
of the physical radio and because it has

1031
00:41:03,200 --> 00:41:06,560
the correct code and it has the correct

1032
00:41:05,359 --> 00:41:08,640
ram

1033
00:41:06,560 --> 00:41:11,839
everything is in the correct position

1034
00:41:08,640 --> 00:41:11,839
and everything still works

1035
00:41:13,280 --> 00:41:17,119
these are the uh

1036
00:41:17,359 --> 00:41:24,319
gcc 9 commands to actually perform

1037
00:41:20,560 --> 00:41:26,319
the linking the um

1038
00:41:24,319 --> 00:41:27,359
the gist of it is that i'm telling it to

1039
00:41:26,319 --> 00:41:30,079
load the

1040
00:41:27,359 --> 00:41:30,560
firmware image where the firmware would

1041
00:41:30,079 --> 00:41:34,200
go

1042
00:41:30,560 --> 00:41:39,279
at zero eight zero

1043
00:41:34,200 --> 00:41:41,200
c000 so this leaves experiment.img

1044
00:41:39,280 --> 00:41:42,640
as our firmware where the firmware

1045
00:41:41,200 --> 00:41:45,040
should go

1046
00:41:42,640 --> 00:41:46,799
and then what this does is this loads

1047
00:41:45,040 --> 00:41:50,560
ram.bin

1048
00:41:46,800 --> 00:41:53,839
into memory where the ram should go

1049
00:41:50,560 --> 00:41:56,960
and i also give it um section names

1050
00:41:53,839 --> 00:41:57,759
so that my linker can provide pointers

1051
00:41:56,960 --> 00:42:02,079
for this back

1052
00:41:57,760 --> 00:42:05,440
to my main function

1053
00:42:02,079 --> 00:42:08,560
and when i link all of this together

1054
00:42:05,440 --> 00:42:08,560
i can then um

1055
00:42:09,200 --> 00:42:13,200
i can then call into these functions so

1056
00:42:11,359 --> 00:42:16,720
the first thing that i do is i make

1057
00:42:13,200 --> 00:42:17,839
a function pointer to the same firmware

1058
00:42:16,720 --> 00:42:19,759
address

1059
00:42:17,839 --> 00:42:22,319
as i found a function that does nothing

1060
00:42:19,760 --> 00:42:25,040
but return

1061
00:42:22,319 --> 00:42:25,759
and what this piece if it does is it it

1062
00:42:25,040 --> 00:42:28,640
makes that

1063
00:42:25,760 --> 00:42:30,079
function pointer and then it calls it

1064
00:42:28,640 --> 00:42:31,759
and if it doesn't crash

1065
00:42:30,079 --> 00:42:34,400
that means that it has called into the

1066
00:42:31,760 --> 00:42:36,560
firmware and successfully returned

1067
00:42:34,400 --> 00:42:38,400
if it crashes it might be because the

1068
00:42:36,560 --> 00:42:39,759
page is not executable

1069
00:42:38,400 --> 00:42:42,720
or it might be because of another

1070
00:42:39,760 --> 00:42:42,720
mistake along the way

1071
00:42:42,880 --> 00:42:46,480
after i have a very short function

1072
00:42:46,000 --> 00:42:48,319
working

1073
00:42:46,480 --> 00:42:49,520
i can then take a much more complicated

1074
00:42:48,319 --> 00:42:52,880
function

1075
00:42:49,520 --> 00:42:56,560
uh mba decode wave this

1076
00:42:52,880 --> 00:42:59,839
is the function that takes a compressed

1077
00:42:56,560 --> 00:43:01,759
amde audio packet as the radio would

1078
00:42:59,839 --> 00:43:04,560
receive over the air

1079
00:43:01,760 --> 00:43:05,520
and it decodes it into a wave buffer

1080
00:43:04,560 --> 00:43:08,078
that will be played

1081
00:43:05,520 --> 00:43:10,480
out the sound card of the radio and this

1082
00:43:08,079 --> 00:43:13,280
is how you receive digital audio

1083
00:43:10,480 --> 00:43:15,839
and hear it as a voice that you

1084
00:43:13,280 --> 00:43:15,839
understand

1085
00:43:16,400 --> 00:43:20,800
now um you can see from my comments that

1086
00:43:18,960 --> 00:43:22,480
i don't really understand

1087
00:43:20,800 --> 00:43:24,800
what all of the parameters of this

1088
00:43:22,480 --> 00:43:28,640
function do

1089
00:43:24,800 --> 00:43:31,680
um i know that a5 and a4 are always zero

1090
00:43:28,640 --> 00:43:34,879
so i just make them zero

1091
00:43:31,680 --> 00:43:37,598
um the buffer

1092
00:43:34,880 --> 00:43:39,839
is uh i think a temporary buffer and i

1093
00:43:37,599 --> 00:43:41,359
use the one that was already loaded into

1094
00:43:39,839 --> 00:43:44,720
ram on the device

1095
00:43:41,359 --> 00:43:45,920
because there might be um tables that

1096
00:43:44,720 --> 00:43:49,598
are required

1097
00:43:45,920 --> 00:43:50,079
and then also a7 is always the same

1098
00:43:49,599 --> 00:43:53,200
address

1099
00:43:50,079 --> 00:43:56,880
inside of sram at

1100
00:43:53,200 --> 00:44:00,000
2001 1224

1101
00:43:56,880 --> 00:44:02,240
i just repeat that same address

1102
00:44:00,000 --> 00:44:04,400
from what i see in the disassembled

1103
00:44:02,240 --> 00:44:05,919
firmware

1104
00:44:04,400 --> 00:44:08,800
i don't actually know what it means or

1105
00:44:05,920 --> 00:44:10,800
what's located there and i don't have to

1106
00:44:08,800 --> 00:44:12,800
because as far as that function is

1107
00:44:10,800 --> 00:44:15,119
concerned everything that it expects in

1108
00:44:12,800 --> 00:44:17,119
flash memory is at the correct address

1109
00:44:15,119 --> 00:44:18,960
and everything that it expects in ram is

1110
00:44:17,119 --> 00:44:21,280
at the correct address

1111
00:44:18,960 --> 00:44:24,319
so if i call it with the same parameters

1112
00:44:21,280 --> 00:44:27,359
it performs the same functions

1113
00:44:24,319 --> 00:44:29,759
this audio codec happens to have a copy

1114
00:44:27,359 --> 00:44:32,240
protection mechanism

1115
00:44:29,760 --> 00:44:33,520
which i didn't notice when i first

1116
00:44:32,240 --> 00:44:36,720
emulated it

1117
00:44:33,520 --> 00:44:38,560
because in my emulation the copy

1118
00:44:36,720 --> 00:44:42,319
protection check had already

1119
00:44:38,560 --> 00:44:43,920
passed so by running the firmware image

1120
00:44:42,319 --> 00:44:45,200
that i've dumped out of the real radio

1121
00:44:43,920 --> 00:44:47,359
and the frame that i've dumped out of

1122
00:44:45,200 --> 00:44:50,399
the real radio it's almost

1123
00:44:47,359 --> 00:44:53,359
like i've paused the running program

1124
00:44:50,400 --> 00:44:54,160
inside of the physical hardware and then

1125
00:44:53,359 --> 00:44:57,680
migrated it

1126
00:44:54,160 --> 00:45:00,319
into a unix process and continue time

1127
00:44:57,680 --> 00:45:00,319
off from there

1128
00:45:01,990 --> 00:45:05,040
[Music]

1129
00:45:03,119 --> 00:45:07,200
part of the weirdness of this function

1130
00:45:05,040 --> 00:45:11,520
is that uh

1131
00:45:07,200 --> 00:45:14,000
in in amd you have two time slots so you

1132
00:45:11,520 --> 00:45:15,920
have to call the decoder twice

1133
00:45:14,000 --> 00:45:17,280
and only once it will work so i just

1134
00:45:15,920 --> 00:45:19,920
double that up

1135
00:45:17,280 --> 00:45:21,680
but the end result is that i have an arm

1136
00:45:19,920 --> 00:45:24,960
linux executable

1137
00:45:21,680 --> 00:45:26,720
which runs perfectly fine under qmo

1138
00:45:24,960 --> 00:45:28,720
so it doesn't matter that my desktop is

1139
00:45:26,720 --> 00:45:31,359
an intel xeon or whatever

1140
00:45:28,720 --> 00:45:33,118
um which is then able to call back into

1141
00:45:31,359 --> 00:45:35,040
the firmware

1142
00:45:33,119 --> 00:45:37,760
if i were doing this for a commercial

1143
00:45:35,040 --> 00:45:39,680
project instead of a hobby project

1144
00:45:37,760 --> 00:45:41,200
or if i were more diligent in the

1145
00:45:39,680 --> 00:45:44,720
quality control for my how

1146
00:45:41,200 --> 00:45:45,598
for my hobby projects i could use this

1147
00:45:44,720 --> 00:45:48,399
to write

1148
00:45:45,599 --> 00:45:49,920
unit tests and integration tests to know

1149
00:45:48,400 --> 00:45:52,960
that my understanding

1150
00:45:49,920 --> 00:46:00,640
of the meaning of the firmware and the

1151
00:45:52,960 --> 00:46:02,079
locations of the functions were correct

1152
00:46:00,640 --> 00:46:05,520
there are some other nifty tricks that

1153
00:46:02,079 --> 00:46:05,520
you should know um

1154
00:46:08,079 --> 00:46:11,359
when you're reverse engineering desktop

1155
00:46:10,480 --> 00:46:13,839
software

1156
00:46:11,359 --> 00:46:14,720
um we've worked our way to a point in

1157
00:46:13,839 --> 00:46:17,759
the world where

1158
00:46:14,720 --> 00:46:20,319
most new software

1159
00:46:17,760 --> 00:46:20,319
uses

1160
00:46:21,200 --> 00:46:23,919
utf-8

1161
00:46:24,960 --> 00:46:29,359
and there are some exceptions like if

1162
00:46:26,640 --> 00:46:30,480
you're looking at very old software you

1163
00:46:29,359 --> 00:46:33,920
might find

1164
00:46:30,480 --> 00:46:35,920
um a national standard

1165
00:46:33,920 --> 00:46:37,040
or if you're looking at windows software

1166
00:46:35,920 --> 00:46:40,560
you might find

1167
00:46:37,040 --> 00:46:43,920
unicode 16 instead of etf8

1168
00:46:40,560 --> 00:46:46,000
in firmware for arm

1169
00:46:43,920 --> 00:46:47,359
it's surprising what you'll very often

1170
00:46:46,000 --> 00:46:51,200
find um

1171
00:46:47,359 --> 00:46:52,640
the chinese standard called gb2312

1172
00:46:51,200 --> 00:46:55,040
so sometimes when you're looking through

1173
00:46:52,640 --> 00:46:58,640
a firmware image for a device

1174
00:46:55,040 --> 00:47:02,720
that has a free display in chinese

1175
00:46:58,640 --> 00:47:02,720
but not in english um

1176
00:47:03,119 --> 00:47:07,599
and you run springs on it you look for

1177
00:47:04,800 --> 00:47:11,040
unicode strings and you find none of it

1178
00:47:07,599 --> 00:47:12,800
you will still find gd231 two strings

1179
00:47:11,040 --> 00:47:14,560
if you try that and you can then run

1180
00:47:12,800 --> 00:47:17,040
them through google translate

1181
00:47:14,560 --> 00:47:17,920
and use those strings to understand the

1182
00:47:17,040 --> 00:47:20,640
meaning of the

1183
00:47:17,920 --> 00:47:20,640
code involved

1184
00:47:21,200 --> 00:47:26,078
i have a github project that that dumps

1185
00:47:24,480 --> 00:47:27,280
these strings because the standard tools

1186
00:47:26,079 --> 00:47:30,319
don't seem to

1187
00:47:27,280 --> 00:47:31,839
like that format magic constants are

1188
00:47:30,319 --> 00:47:34,558
also useful

1189
00:47:31,839 --> 00:47:35,759
in the case of reverse engineering the

1190
00:47:34,559 --> 00:47:39,520
radio firmware

1191
00:47:35,760 --> 00:47:43,440
there was um support in the protocol

1192
00:47:39,520 --> 00:47:46,240
for um like an emergency

1193
00:47:43,440 --> 00:47:48,400
shouting mode where every radio that

1194
00:47:46,240 --> 00:47:50,479
hears the message will decode it

1195
00:47:48,400 --> 00:47:52,079
you use this if you need to address

1196
00:47:50,480 --> 00:47:53,520
everybody on the network

1197
00:47:52,079 --> 00:47:56,000
even though some of them might not be

1198
00:47:53,520 --> 00:48:00,000
configured to receive you

1199
00:47:56,000 --> 00:48:02,079
by searching for the address

1200
00:48:00,000 --> 00:48:03,920
that you send that audio to i was able

1201
00:48:02,079 --> 00:48:06,319
to find the functions

1202
00:48:03,920 --> 00:48:09,520
that control whether the radio plays

1203
00:48:06,319 --> 00:48:11,920
incoming audio or not

1204
00:48:09,520 --> 00:48:12,960
um which allowed me to make promiscuous

1205
00:48:11,920 --> 00:48:15,680
mode to decode

1206
00:48:12,960 --> 00:48:17,119
all all incoming audio you can also

1207
00:48:15,680 --> 00:48:20,240
search for masks

1208
00:48:17,119 --> 00:48:24,079
in this particular protocol addresses

1209
00:48:20,240 --> 00:48:25,680
are three bytes long instead of four

1210
00:48:24,079 --> 00:48:27,839
or eight or 16 or whatever else you

1211
00:48:25,680 --> 00:48:33,359
would want so by searching

1212
00:48:27,839 --> 00:48:35,200
for zero zero ffff

1213
00:48:33,359 --> 00:48:36,960
i could find all of the masking

1214
00:48:35,200 --> 00:48:39,520
operations that were trying to drop

1215
00:48:36,960 --> 00:48:40,640
off the extra byte that was not a part

1216
00:48:39,520 --> 00:48:42,559
of the address

1217
00:48:40,640 --> 00:48:45,759
and that allowed me to locate large

1218
00:48:42,559 --> 00:48:49,040
parts of the networking style

1219
00:48:45,760 --> 00:48:52,160
you can also hunt for reference code so

1220
00:48:49,040 --> 00:48:53,359
um in my case i was attempting to

1221
00:48:52,160 --> 00:48:56,160
reverse engineer

1222
00:48:53,359 --> 00:48:58,160
a device which locked its own firmware

1223
00:48:56,160 --> 00:49:00,720
and i needed to find the function

1224
00:48:58,160 --> 00:49:02,399
that locked the firmware in order to

1225
00:49:00,720 --> 00:49:05,118
disable it

1226
00:49:02,400 --> 00:49:07,440
to do that i i looked at the

1227
00:49:05,119 --> 00:49:10,559
manufacturer's reference design

1228
00:49:07,440 --> 00:49:13,520
and they provided this example function

1229
00:49:10,559 --> 00:49:15,680
which was used exactly with no

1230
00:49:13,520 --> 00:49:19,040
modification

1231
00:49:15,680 --> 00:49:21,279
by the radio vendor it was um statically

1232
00:49:19,040 --> 00:49:23,279
linked into the firmware image

1233
00:49:21,280 --> 00:49:25,359
so i could look at what assembly code

1234
00:49:23,280 --> 00:49:26,640
was generated by compiling this

1235
00:49:25,359 --> 00:49:29,598
and then i could search for everything

1236
00:49:26,640 --> 00:49:31,118
similar and by clicking i was able to

1237
00:49:29,599 --> 00:49:33,440
find the correct function in very little

1238
00:49:31,119 --> 00:49:33,440
time

1239
00:49:39,040 --> 00:49:46,240
you can also automate a lot of the

1240
00:49:43,200 --> 00:49:47,439
the dredge work of

1241
00:49:46,240 --> 00:49:49,279
sorting through the image and

1242
00:49:47,440 --> 00:49:52,079
identifying things

1243
00:49:49,280 --> 00:49:54,240
so one very useful thing to do is to

1244
00:49:52,079 --> 00:49:57,040
realize that most functions are targets

1245
00:49:54,240 --> 00:50:01,839
of a branch only construction

1246
00:49:57,040 --> 00:50:05,279
and um the only exceptions to that

1247
00:50:01,839 --> 00:50:07,759
in a normal application will be um

1248
00:50:05,280 --> 00:50:10,319
functions that are called by pointer

1249
00:50:07,760 --> 00:50:12,400
where you will find

1250
00:50:10,319 --> 00:50:14,240
a copy of the function pointer either in

1251
00:50:12,400 --> 00:50:15,920
flash or sram

1252
00:50:14,240 --> 00:50:18,240
and interrupt handlers which are in the

1253
00:50:15,920 --> 00:50:21,359
internet handler table

1254
00:50:18,240 --> 00:50:23,759
so if you run through memory

1255
00:50:21,359 --> 00:50:24,480
and you find every branch in link

1256
00:50:23,760 --> 00:50:27,680
instruction

1257
00:50:24,480 --> 00:50:29,520
and then look at its target and then you

1258
00:50:27,680 --> 00:50:33,040
instruct your disassembly tool

1259
00:50:29,520 --> 00:50:34,880
through an item python script or

1260
00:50:33,040 --> 00:50:36,480
the scripting for whatever other tool

1261
00:50:34,880 --> 00:50:38,559
you're using

1262
00:50:36,480 --> 00:50:40,720
you can automatically identify all of

1263
00:50:38,559 --> 00:50:44,880
those functions and then

1264
00:50:40,720 --> 00:50:47,359
um then begin working with the entry

1265
00:50:44,880 --> 00:50:50,079
points all known

1266
00:50:47,359 --> 00:50:51,520
or even instruct i to decompile the

1267
00:50:50,079 --> 00:50:53,040
entire image and then search through it

1268
00:50:51,520 --> 00:50:55,839
as c code without having to look at the

1269
00:50:53,040 --> 00:50:55,839
assembly

1270
00:50:56,319 --> 00:51:02,640
and when

1271
00:50:59,359 --> 00:51:04,720
the vendor releases a firmware update

1272
00:51:02,640 --> 00:51:06,558
and you would like to stay up to date

1273
00:51:04,720 --> 00:51:08,160
with that firmware

1274
00:51:06,559 --> 00:51:09,760
but you've written your patches against

1275
00:51:08,160 --> 00:51:12,640
an older firmer image

1276
00:51:09,760 --> 00:51:13,839
um you need some way to automatically

1277
00:51:12,640 --> 00:51:16,879
port

1278
00:51:13,839 --> 00:51:19,200
because if you do all of this by hand

1279
00:51:16,880 --> 00:51:20,240
then you forget why you did certain

1280
00:51:19,200 --> 00:51:23,040
things or why

1281
00:51:20,240 --> 00:51:26,000
um you patched out certain functions and

1282
00:51:23,040 --> 00:51:28,240
it becomes difficult to maintain

1283
00:51:26,000 --> 00:51:29,680
instead it would be nice if all of your

1284
00:51:28,240 --> 00:51:32,879
patching were performed

1285
00:51:29,680 --> 00:51:35,359
in c in the style of replacing a

1286
00:51:32,880 --> 00:51:37,520
function of a particular name

1287
00:51:35,359 --> 00:51:38,640
and the names you could apply to one

1288
00:51:37,520 --> 00:51:39,839
version of the firmware and

1289
00:51:38,640 --> 00:51:43,759
automatically move

1290
00:51:39,839 --> 00:51:47,119
to future versions so

1291
00:51:43,760 --> 00:51:50,480
if you're trying to do this between

1292
00:51:47,119 --> 00:51:54,720
let's say adobe pdf reader on spark

1293
00:51:50,480 --> 00:51:57,200
and modern mac os

1294
00:51:54,720 --> 00:51:57,839
um that becomes a hard problem because

1295
00:51:57,200 --> 00:51:59,040
you have

1296
00:51:57,839 --> 00:52:00,400
different compilers different

1297
00:51:59,040 --> 00:52:01,839
instruction sets different major

1298
00:52:00,400 --> 00:52:04,000
versions

1299
00:52:01,839 --> 00:52:05,759
um and they're very smart people who

1300
00:52:04,000 --> 00:52:06,960
work on those problems and get results

1301
00:52:05,760 --> 00:52:09,200
in them

1302
00:52:06,960 --> 00:52:10,640
in my case i'm interested in getting an

1303
00:52:09,200 --> 00:52:13,919
answer immediately

1304
00:52:10,640 --> 00:52:16,160
with a couple pages of c code so

1305
00:52:13,920 --> 00:52:18,400
the way that i do this is that i realize

1306
00:52:16,160 --> 00:52:20,799
that um

1307
00:52:18,400 --> 00:52:22,480
embedded developers usually use the same

1308
00:52:20,800 --> 00:52:24,480
version of the compiler

1309
00:52:22,480 --> 00:52:25,760
they don't update their compiler

1310
00:52:24,480 --> 00:52:30,800
frequently

1311
00:52:25,760 --> 00:52:33,200
like um like a desktop linux user might

1312
00:52:30,800 --> 00:52:34,319
and when you're using the same compiler

1313
00:52:33,200 --> 00:52:37,439
to compile different

1314
00:52:34,319 --> 00:52:39,920
versions of the same firmware most of

1315
00:52:37,440 --> 00:52:44,800
the functions don't change at all

1316
00:52:39,920 --> 00:52:44,800
and those that do change um

1317
00:52:45,200 --> 00:52:50,240
those that do change are usually for

1318
00:52:48,319 --> 00:52:51,759
the small feature that gets fixed

1319
00:52:50,240 --> 00:52:53,359
they're not necessarily the same

1320
00:52:51,760 --> 00:52:55,599
function that you might want to

1321
00:52:53,359 --> 00:52:55,598
hook

1322
00:52:56,400 --> 00:53:02,640
so you're usually looking at the exact

1323
00:53:00,079 --> 00:53:03,200
same assembly code linked to a new

1324
00:53:02,640 --> 00:53:05,598
address

1325
00:53:03,200 --> 00:53:06,240
and when it's linked to a new address

1326
00:53:05,599 --> 00:53:09,680
the

1327
00:53:06,240 --> 00:53:12,959
targets of the bl instructions

1328
00:53:09,680 --> 00:53:16,000
which means branch and link which is the

1329
00:53:12,960 --> 00:53:18,480
thumb version of a function call those

1330
00:53:16,000 --> 00:53:22,720
change but nothing else changes

1331
00:53:18,480 --> 00:53:25,040
so we can do this trick where um

1332
00:53:22,720 --> 00:53:26,240
you can compare how similar two

1333
00:53:25,040 --> 00:53:30,558
functions are

1334
00:53:26,240 --> 00:53:33,520
by stepping through every 16-bit word

1335
00:53:30,559 --> 00:53:34,640
in the function with a being the word in

1336
00:53:33,520 --> 00:53:36,800
the first function and b

1337
00:53:34,640 --> 00:53:38,319
being the word in the second function

1338
00:53:36,800 --> 00:53:39,760
and if a equals b

1339
00:53:38,319 --> 00:53:42,079
then great they're identical and you can

1340
00:53:39,760 --> 00:53:45,119
move on if they don't equal

1341
00:53:42,079 --> 00:53:46,720
each other but they both have a most

1342
00:53:45,119 --> 00:53:49,760
significant nibble

1343
00:53:46,720 --> 00:53:52,799
of f meaning both of them have their

1344
00:53:49,760 --> 00:53:56,720
most significant four bits set

1345
00:53:52,800 --> 00:53:59,040
then that that 16-bit word

1346
00:53:56,720 --> 00:54:00,078
is part of a branch and link instruction

1347
00:53:59,040 --> 00:54:02,079
and it doesn't

1348
00:54:00,079 --> 00:54:04,640
matter that it changed because it's

1349
00:54:02,079 --> 00:54:06,559
expected to during location

1350
00:54:04,640 --> 00:54:08,480
so this lets you come up with a very

1351
00:54:06,559 --> 00:54:11,839
very short c function

1352
00:54:08,480 --> 00:54:12,880
that will race through large firmware

1353
00:54:11,839 --> 00:54:15,520
images

1354
00:54:12,880 --> 00:54:16,960
and directly compare their functions in

1355
00:54:15,520 --> 00:54:17,920
order to identify which ones are

1356
00:54:16,960 --> 00:54:21,200
equivalent

1357
00:54:17,920 --> 00:54:23,200
so that you can import your symbol names

1358
00:54:21,200 --> 00:54:24,319
if you'd like an example of this there's

1359
00:54:23,200 --> 00:54:26,319
a

1360
00:54:24,319 --> 00:54:29,759
code in the symbols directory of the

1361
00:54:26,319 --> 00:54:29,759
md380 tools project

1362
00:54:30,240 --> 00:54:34,160
um we've gone over a lot in this lecture

1363
00:54:33,040 --> 00:54:35,920
i

1364
00:54:34,160 --> 00:54:37,040
hope that you picked up some nifty

1365
00:54:35,920 --> 00:54:38,400
tricks that you'll use in your own

1366
00:54:37,040 --> 00:54:40,960
projects

1367
00:54:38,400 --> 00:54:41,599
i do not expect you to remember every

1368
00:54:40,960 --> 00:54:43,359
detail

1369
00:54:41,599 --> 00:54:44,880
and i certainly wouldn't if i watched it

1370
00:54:43,359 --> 00:54:47,520
myself

1371
00:54:44,880 --> 00:54:48,720
but it's the nifty tricks that save you

1372
00:54:47,520 --> 00:54:52,079
when you're blocked

1373
00:54:48,720 --> 00:54:53,598
or that allow you to um

1374
00:54:52,079 --> 00:54:55,839
to hack something that you might

1375
00:54:53,599 --> 00:54:57,920
otherwise get stuck on

1376
00:54:55,839 --> 00:55:00,799
that are the valuable things that i look

1377
00:54:57,920 --> 00:55:00,799
for in these lectures

1378
00:55:01,920 --> 00:55:06,240
if anyone wants to have reference

1379
00:55:03,760 --> 00:55:10,400
material for this polka gtfo

1380
00:55:06,240 --> 00:55:12,078
11 11 6 has the

1381
00:55:10,400 --> 00:55:14,160
full article that some of this content

1382
00:55:12,079 --> 00:55:21,760
came from so you can also look at that

1383
00:55:14,160 --> 00:55:26,078
if you want reference

1384
00:55:21,760 --> 00:55:28,319
howdy hey so i'm uh

1385
00:55:26,079 --> 00:55:29,280
sent out a query for questions uh one

1386
00:55:28,319 --> 00:55:32,000
question we got

1387
00:55:29,280 --> 00:55:32,640
was um what modern devices have the

1388
00:55:32,000 --> 00:55:35,119
cortex

1389
00:55:32,640 --> 00:55:35,839
m in it and i was just doing some

1390
00:55:35,119 --> 00:55:38,799
noodling

1391
00:55:35,839 --> 00:55:40,078
uh while while you all were talking and

1392
00:55:38,799 --> 00:55:42,640
i found that ifixit

1393
00:55:40,079 --> 00:55:44,319
is a pretty good place to find what

1394
00:55:42,640 --> 00:55:46,000
chips are and what things since they do

1395
00:55:44,319 --> 00:55:47,920
tear downs and they

1396
00:55:46,000 --> 00:55:50,720
verbally you know they write out what

1397
00:55:47,920 --> 00:55:52,559
chips they find and identify the chips

1398
00:55:50,720 --> 00:55:53,839
oh yeah their tear downs are great they

1399
00:55:52,559 --> 00:55:58,000
also show you like

1400
00:55:53,839 --> 00:55:59,440
um which tiny ribbon cable you're most

1401
00:55:58,000 --> 00:56:01,839
likely to screw up when you

1402
00:55:59,440 --> 00:56:02,559
open the device yeah yeah this thing

1403
00:56:01,839 --> 00:56:06,319
will tear

1404
00:56:02,559 --> 00:56:08,640
if you if you pull that screen off yep

1405
00:56:06,319 --> 00:56:11,440
um yeah so i found out like uh some of

1406
00:56:08,640 --> 00:56:15,359
those hoverboards use them the apple tv

1407
00:56:11,440 --> 00:56:18,480
uses them ipod touch sixth generation

1408
00:56:15,359 --> 00:56:21,279
uh the pebble watches smart watches

1409
00:56:18,480 --> 00:56:22,960
use them so in the apple tv this won't

1410
00:56:21,280 --> 00:56:26,240
be the main cpu this will be

1411
00:56:22,960 --> 00:56:28,880
off on the side so it's in the

1412
00:56:26,240 --> 00:56:31,839
they they use it both in the main unit

1413
00:56:28,880 --> 00:56:31,839
and inside the remote

1414
00:56:33,040 --> 00:56:38,880
controller does it have a chip name it's

1415
00:56:36,160 --> 00:56:41,359
for the rf4ce travis in that one

1416
00:56:38,880 --> 00:56:41,359
i believe

1417
00:56:42,160 --> 00:56:45,200
yeah so a lot of these that that's a

1418
00:56:43,680 --> 00:56:46,000
great point engine right a lot of these

1419
00:56:45,200 --> 00:56:48,558
will be in

1420
00:56:46,000 --> 00:56:50,480
uh you'll often find these families in

1421
00:56:48,559 --> 00:56:52,880
smart remotes so

1422
00:56:50,480 --> 00:56:54,640
uh i don't know specifically if it's the

1423
00:56:52,880 --> 00:56:56,000
m3 and them but you know think of any

1424
00:56:54,640 --> 00:56:57,839
remote that you're pushing your

1425
00:56:56,000 --> 00:56:59,119
your uh yeah i'm pretty sure they're

1426
00:56:57,839 --> 00:57:01,359
actually empty-based

1427
00:56:59,119 --> 00:57:03,280
that you push and do voice to tell your

1428
00:57:01,359 --> 00:57:05,440
tv what you want to do for example

1429
00:57:03,280 --> 00:57:06,720
whether that's a tv an apple product or

1430
00:57:05,440 --> 00:57:09,599
a third party

1431
00:57:06,720 --> 00:57:11,439
um typically these are integrated into

1432
00:57:09,599 --> 00:57:14,720
some of those radio chipsets

1433
00:57:11,440 --> 00:57:16,400
or based on this architecture and if you

1434
00:57:14,720 --> 00:57:18,319
have uh

1435
00:57:16,400 --> 00:57:19,920
if you have like a small consumer device

1436
00:57:18,319 --> 00:57:22,319
with an lcd screen

1437
00:57:19,920 --> 00:57:23,599
but that clearly isn't as powerful as

1438
00:57:22,319 --> 00:57:25,520
android

1439
00:57:23,599 --> 00:57:29,040
um it's quite likely one of the

1440
00:57:25,520 --> 00:57:29,040
higher-end gore-tex-iron chips

1441
00:57:31,040 --> 00:57:34,799
cool yeah yeah it's what it looks like

1442
00:57:32,720 --> 00:57:37,359
with a few devices here

1443
00:57:34,799 --> 00:57:39,280
the oculus rift multiple versions of the

1444
00:57:37,359 --> 00:57:44,319
oculus rift also use it

1445
00:57:39,280 --> 00:57:44,319
and the uh second generation nest

1446
00:57:46,559 --> 00:57:49,440
so yeah that was that was pretty cool i

1447
00:57:48,000 --> 00:57:50,720
was trying to think like how would i

1448
00:57:49,440 --> 00:57:53,280
even find that because

1449
00:57:50,720 --> 00:57:54,000
you know manufacturers usually don't

1450
00:57:53,280 --> 00:57:55,920
publicize

1451
00:57:54,000 --> 00:57:57,200
that you know what chips are using for

1452
00:57:55,920 --> 00:58:00,160
what things

1453
00:57:57,200 --> 00:58:02,480
and i realized i fix it uh that's what

1454
00:58:00,160 --> 00:58:05,920
they specialize in

1455
00:58:02,480 --> 00:58:06,240
so the manufacturer won't publicize it

1456
00:58:05,920 --> 00:58:08,799
but

1457
00:58:06,240 --> 00:58:11,040
very often you can find out which chips

1458
00:58:08,799 --> 00:58:13,839
they use from their fcc filing

1459
00:58:11,040 --> 00:58:14,480
yeah yeah we see a lot of leaks come

1460
00:58:13,839 --> 00:58:18,240
from that

1461
00:58:14,480 --> 00:58:18,240
before devices come out sometimes

1462
00:58:21,359 --> 00:58:28,480
well very cool um

1463
00:58:24,480 --> 00:58:30,319
yes so i'm i'm not seeing any questions

1464
00:58:28,480 --> 00:58:31,599
so thank you thank you both very much

1465
00:58:30,319 --> 00:58:34,240
for the talk and

1466
00:58:31,599 --> 00:58:35,440
um yeah there's uh there's definitely

1467
00:58:34,240 --> 00:58:37,520
some

1468
00:58:35,440 --> 00:58:38,559
discussion going on on the on the

1469
00:58:37,520 --> 00:58:43,200
discord

1470
00:58:38,559 --> 00:58:43,200
which has been fun to have

