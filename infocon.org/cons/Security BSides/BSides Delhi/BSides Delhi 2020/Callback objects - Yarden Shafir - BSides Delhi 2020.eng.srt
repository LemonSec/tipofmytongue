1
00:00:02,960 --> 00:00:06,960
uh

2
00:00:03,439 --> 00:00:10,320
this is by yardan shafir

3
00:00:06,960 --> 00:00:12,400
hello yarden hello how are you

4
00:00:10,320 --> 00:00:15,360
i'm very well thank you how are you and

5
00:00:12,400 --> 00:00:18,240
and uh where are you calling in from

6
00:00:15,360 --> 00:00:19,198
i'm good i'm calling in from greece

7
00:00:18,240 --> 00:00:21,919
right now

8
00:00:19,199 --> 00:00:23,760
ah lovely excellent and is is that your

9
00:00:21,920 --> 00:00:24,080
artwork on the walls behind you or is

10
00:00:23,760 --> 00:00:30,080
that

11
00:00:24,080 --> 00:00:33,440
no no this is not mine this is

12
00:00:30,080 --> 00:00:35,040
good anyway uh we are well we're

13
00:00:33,440 --> 00:00:36,559
in order to try and stay on track we're

14
00:00:35,040 --> 00:00:39,600
going to crack straight on

15
00:00:36,559 --> 00:00:42,078
you are going to talk to us about

16
00:00:39,600 --> 00:00:43,200
uh and since i'm definitely not going to

17
00:00:42,079 --> 00:00:45,520
know what this is about

18
00:00:43,200 --> 00:00:46,640
uh call back objects everything you

19
00:00:45,520 --> 00:00:49,680
didn't know

20
00:00:46,640 --> 00:00:53,280
you wanted to hook in the kernel

21
00:00:49,680 --> 00:00:55,840
um so yarden please take it away

22
00:00:53,280 --> 00:00:56,719
and i'll be monitoring for questions and

23
00:00:55,840 --> 00:01:00,239
get back to you

24
00:00:56,719 --> 00:01:04,079
at the end yes let me

25
00:01:00,239 --> 00:01:04,078
share my slides

26
00:01:04,080 --> 00:01:07,920
okay let me know if that worked

27
00:01:08,240 --> 00:01:13,039
i think that's worked i will

28
00:01:11,600 --> 00:01:15,119
leave you to get on with your

29
00:01:13,040 --> 00:01:18,240
presentation thank you very much

30
00:01:15,119 --> 00:01:21,759
thank you uh okay so yeah

31
00:01:18,240 --> 00:01:22,560
like i said uh amiodan and we're gonna

32
00:01:21,759 --> 00:01:26,479
talk about

33
00:01:22,560 --> 00:01:28,400
callback objects is um

34
00:01:26,479 --> 00:01:29,759
an internal communication mechanism in

35
00:01:28,400 --> 00:01:33,119
the windows kernel

36
00:01:29,759 --> 00:01:36,560
that you're probably gonna want to

37
00:01:33,119 --> 00:01:40,799
use or look at for your next rootkit or

38
00:01:36,560 --> 00:01:43,280
adr software so first of all about me

39
00:01:40,799 --> 00:01:45,520
um my name is joden i'm a software

40
00:01:43,280 --> 00:01:46,880
engineer at crowdstrike previously it's

41
00:01:45,520 --> 00:01:50,000
center one

42
00:01:46,880 --> 00:01:50,798
uh doing windows security research and

43
00:01:50,000 --> 00:01:54,560
development

44
00:01:50,799 --> 00:01:57,040
form of defense purposes i'm also

45
00:01:54,560 --> 00:01:59,600
an instructor in onesider teaching

46
00:01:57,040 --> 00:02:03,520
windows internals classes together with

47
00:01:59,600 --> 00:02:06,960
nesco and i'm also a circus artist

48
00:02:03,520 --> 00:02:09,038
instructor and performer mostly

49
00:02:06,960 --> 00:02:11,760
working in israel teaching aerial

50
00:02:09,038 --> 00:02:14,958
teaching performing aerial arts

51
00:02:11,760 --> 00:02:18,239
i do a lot of things i'm a pastry chef

52
00:02:14,959 --> 00:02:21,760
and during quarantine i

53
00:02:18,239 --> 00:02:25,120
mostly taught my mom how to unmute zoom

54
00:02:21,760 --> 00:02:28,480
almost by herself so that's probably my

55
00:02:25,120 --> 00:02:28,480
greatest achievement so far

56
00:02:29,200 --> 00:02:34,879
and what about callback objects

57
00:02:32,560 --> 00:02:36,000
we might sound familiar to a lot of you

58
00:02:34,879 --> 00:02:38,640
because the windows kernel

59
00:02:36,000 --> 00:02:39,680
has a lot of things that have the name

60
00:02:38,640 --> 00:02:42,480
callback

61
00:02:39,680 --> 00:02:42,959
in them there's a lot of user mode

62
00:02:42,480 --> 00:02:45,599
combat

63
00:02:42,959 --> 00:02:46,480
kernel mode callbacks some of you might

64
00:02:45,599 --> 00:02:49,679
know

65
00:02:46,480 --> 00:02:51,119
the process and thread and load image

66
00:02:49,680 --> 00:02:54,160
notifications

67
00:02:51,120 --> 00:02:55,920
which are also called callbacks

68
00:02:54,160 --> 00:02:57,680
those are all different things for

69
00:02:55,920 --> 00:03:00,879
example process and thread

70
00:02:57,680 --> 00:03:03,040
on notifications are legacy callbacks

71
00:03:00,879 --> 00:03:04,879
which are a different thing in which the

72
00:03:03,040 --> 00:03:07,679
kernel

73
00:03:04,879 --> 00:03:10,239
notifies different drivers about certain

74
00:03:07,680 --> 00:03:13,200
events happening in the system

75
00:03:10,239 --> 00:03:14,319
now callback objects are a slightly

76
00:03:13,200 --> 00:03:17,119
different thing

77
00:03:14,319 --> 00:03:17,518
they're an actual object like a file

78
00:03:17,120 --> 00:03:20,239
like

79
00:03:17,519 --> 00:03:21,840
process like a symbolic link they're one

80
00:03:20,239 --> 00:03:24,879
of about 70 different

81
00:03:21,840 --> 00:03:26,799
object types in the system

82
00:03:24,879 --> 00:03:28,000
and they're named when you create a

83
00:03:26,799 --> 00:03:30,080
callback

84
00:03:28,000 --> 00:03:31,440
you can choose a name for it or not you

85
00:03:30,080 --> 00:03:34,159
don't have to

86
00:03:31,440 --> 00:03:36,319
and that's how other drivers in the

87
00:03:34,159 --> 00:03:37,840
system are going to recognize it

88
00:03:36,319 --> 00:03:39,679
and the thing that makes callback

89
00:03:37,840 --> 00:03:42,400
objects different

90
00:03:39,680 --> 00:03:44,000
from a few other communication

91
00:03:42,400 --> 00:03:46,640
mechanisms in the kernel

92
00:03:44,000 --> 00:03:48,560
is that anyone can create a callback

93
00:03:46,640 --> 00:03:49,279
anyone can register for one and anyone

94
00:03:48,560 --> 00:03:52,640
can

95
00:03:49,280 --> 00:03:53,439
notify one unlike other mechanisms in

96
00:03:52,640 --> 00:03:57,279
which the

97
00:03:53,439 --> 00:03:59,120
colonel exports some functionality some

98
00:03:57,280 --> 00:04:00,959
options some call back like

99
00:03:59,120 --> 00:04:03,040
here you can register to receive

100
00:04:00,959 --> 00:04:05,840
notifications about processes

101
00:04:03,040 --> 00:04:06,319
with callback objects anyone can use

102
00:04:05,840 --> 00:04:09,680
them

103
00:04:06,319 --> 00:04:12,238
in the kernel any way they want

104
00:04:09,680 --> 00:04:12,799
there are certain callbacks that the

105
00:04:12,239 --> 00:04:17,040
kernel

106
00:04:12,799 --> 00:04:19,918
makes available like power state

107
00:04:17,040 --> 00:04:20,639
um you know if the system is going to

108
00:04:19,918 --> 00:04:23,359
shut down

109
00:04:20,639 --> 00:04:24,720
or restart or go to sleep and a few

110
00:04:23,360 --> 00:04:26,400
other things

111
00:04:24,720 --> 00:04:28,240
but you can also create your own

112
00:04:26,400 --> 00:04:29,520
callback object for example if your

113
00:04:28,240 --> 00:04:32,400
product has

114
00:04:29,520 --> 00:04:34,560
two or three or four different drivers

115
00:04:32,400 --> 00:04:35,520
that want a way to pass information to

116
00:04:34,560 --> 00:04:37,919
each other

117
00:04:35,520 --> 00:04:40,320
you can create internal callback objects

118
00:04:37,919 --> 00:04:43,198
have all your drivers or some of them

119
00:04:40,320 --> 00:04:45,199
register for those and any of them can

120
00:04:43,199 --> 00:04:48,000
notify the others

121
00:04:45,199 --> 00:04:48,960
to pass any kind of information you want

122
00:04:48,000 --> 00:04:52,240
callbacks

123
00:04:48,960 --> 00:04:54,400
when notified receive

124
00:04:52,240 --> 00:04:56,560
three arguments two of them controlled

125
00:04:54,400 --> 00:05:00,638
by whoever is notifying it

126
00:04:56,560 --> 00:05:02,160
so that's as long as all sides

127
00:05:00,639 --> 00:05:04,479
as long as all sides of the

128
00:05:02,160 --> 00:05:07,440
communication agree on

129
00:05:04,479 --> 00:05:09,280
which arguments these are which types

130
00:05:07,440 --> 00:05:10,800
they're in

131
00:05:09,280 --> 00:05:12,400
you can have your own internal

132
00:05:10,800 --> 00:05:15,840
communication mechanism

133
00:05:12,400 --> 00:05:18,960
inside the kernel but it's not private

134
00:05:15,840 --> 00:05:22,239
anyone can register to

135
00:05:18,960 --> 00:05:26,560
any callback almost

136
00:05:22,240 --> 00:05:27,919
um we'll see how that's not true and how

137
00:05:26,560 --> 00:05:31,039
it's still

138
00:05:27,919 --> 00:05:31,039
kinda true anyway

139
00:05:33,039 --> 00:05:39,039
so this is roughly

140
00:05:36,800 --> 00:05:40,240
what that mechanism looks like you have

141
00:05:39,039 --> 00:05:42,639
a few drivers

142
00:05:40,240 --> 00:05:45,280
one of them creates a callback with

143
00:05:42,639 --> 00:05:47,440
excrete callback

144
00:05:45,280 --> 00:05:48,559
creates a new callback object that they

145
00:05:47,440 --> 00:05:52,560
said can have

146
00:05:48,560 --> 00:05:54,400
or not have a name and other drivers can

147
00:05:52,560 --> 00:05:56,479
register for that callback to register

148
00:05:54,400 --> 00:05:58,719
for they first need to find it

149
00:05:56,479 --> 00:06:00,240
they do it again with excreate callback

150
00:05:58,720 --> 00:06:04,560
which create which gives them

151
00:06:00,240 --> 00:06:06,639
pointer a handle to the object and then

152
00:06:04,560 --> 00:06:08,240
they can register functions they can

153
00:06:06,639 --> 00:06:10,880
register

154
00:06:08,240 --> 00:06:13,360
functions that will be notified when

155
00:06:10,880 --> 00:06:15,360
someone wants to notify the callback

156
00:06:13,360 --> 00:06:16,400
and then after there are registered

157
00:06:15,360 --> 00:06:19,440
drivers

158
00:06:16,400 --> 00:06:21,840
anyone any of the registered drivers can

159
00:06:19,440 --> 00:06:25,919
notify the callback and anyone who

160
00:06:21,840 --> 00:06:28,719
registered a function will be called

161
00:06:25,919 --> 00:06:30,318
thing is you can technically you can

162
00:06:28,720 --> 00:06:31,600
notify a callback without being

163
00:06:30,319 --> 00:06:34,319
registered to it

164
00:06:31,600 --> 00:06:35,520
you just need to have the handle to the

165
00:06:34,319 --> 00:06:38,080
callback now

166
00:06:35,520 --> 00:06:39,599
you're not supposed to have the handle

167
00:06:38,080 --> 00:06:40,880
without registering because you're

168
00:06:39,600 --> 00:06:43,680
supposed to receive it

169
00:06:40,880 --> 00:06:45,440
when you register callback function or

170
00:06:43,680 --> 00:06:49,680
create the callback

171
00:06:45,440 --> 00:06:50,800
but you're in the kernel you have access

172
00:06:49,680 --> 00:06:52,720
to

173
00:06:50,800 --> 00:06:54,000
basically everything so you can kind of

174
00:06:52,720 --> 00:06:57,199
get the handle

175
00:06:54,000 --> 00:06:57,199
anyway by yourself

176
00:06:58,880 --> 00:07:05,919
here is some simple code um

177
00:07:02,639 --> 00:07:07,360
a simple poc code to show how to create

178
00:07:05,919 --> 00:07:10,159
and register

179
00:07:07,360 --> 00:07:11,280
a notification function for callback in

180
00:07:10,160 --> 00:07:14,479
this case

181
00:07:11,280 --> 00:07:17,679
it's the kernel's image verification

182
00:07:14,479 --> 00:07:19,680
uh info callback that's that's one

183
00:07:17,680 --> 00:07:21,919
that's provided by the windows kernel

184
00:07:19,680 --> 00:07:25,120
starting in windows 8.1

185
00:07:21,919 --> 00:07:28,560
and that's a that's a fun callback that

186
00:07:25,120 --> 00:07:31,520
gives you for every newly loaded driver

187
00:07:28,560 --> 00:07:33,759
information about its hash its signature

188
00:07:31,520 --> 00:07:37,120
its certification

189
00:07:33,759 --> 00:07:38,479
um so for an edr tool that's a fun one

190
00:07:37,120 --> 00:07:41,199
to use

191
00:07:38,479 --> 00:07:41,840
as you can see like with almost any

192
00:07:41,199 --> 00:07:43,280
object

193
00:07:41,840 --> 00:07:46,159
we need to initialize the object

194
00:07:43,280 --> 00:07:48,719
attributes part of which are the name

195
00:07:46,160 --> 00:07:49,599
of the callback we want then we call

196
00:07:48,720 --> 00:07:52,800
excreate

197
00:07:49,599 --> 00:07:53,919
callback to get object and then we use

198
00:07:52,800 --> 00:07:56,319
that object

199
00:07:53,919 --> 00:07:58,159
to register our own function in this

200
00:07:56,319 --> 00:08:00,479
case they called it image verification

201
00:07:58,160 --> 00:08:03,039
callback function

202
00:08:00,479 --> 00:08:04,318
and then every time a new driver is

203
00:08:03,039 --> 00:08:07,680
going to be loaded

204
00:08:04,319 --> 00:08:09,039
kernel is going to notify our callback

205
00:08:07,680 --> 00:08:10,400
and any other callback

206
00:08:09,039 --> 00:08:13,520
and any other function that was

207
00:08:10,400 --> 00:08:13,520
registered for this call

208
00:08:22,960 --> 00:08:31,520
fortunately the internal structures

209
00:08:27,120 --> 00:08:34,399
that are used for uh call backstation

210
00:08:31,520 --> 00:08:35,760
are not public they're not documented

211
00:08:34,399 --> 00:08:36,320
and they're not in the symbols which

212
00:08:35,760 --> 00:08:39,439
makes

213
00:08:36,320 --> 00:08:41,680
callback objects a bit harder

214
00:08:39,440 --> 00:08:43,360
and more annoying to work with um

215
00:08:41,679 --> 00:08:44,800
especially if you want to debug them

216
00:08:43,360 --> 00:08:48,000
because you can't use

217
00:08:44,800 --> 00:08:50,240
public symbols for that um but the

218
00:08:48,000 --> 00:08:53,120
structures are pretty well known anyway

219
00:08:50,240 --> 00:08:54,720
we have two main structures that we need

220
00:08:53,120 --> 00:08:56,720
to know there is the one

221
00:08:54,720 --> 00:08:58,480
on the right that's the callback object

222
00:08:56,720 --> 00:09:00,560
itself that's what you're

223
00:08:58,480 --> 00:09:01,920
creating and receiving when you call ex

224
00:09:00,560 --> 00:09:03,599
create callback

225
00:09:01,920 --> 00:09:06,160
it has a signature which is not very

226
00:09:03,600 --> 00:09:09,440
interesting and a lock

227
00:09:06,160 --> 00:09:12,399
and then it has two linked lists

228
00:09:09,440 --> 00:09:12,800
first thing i like linked lists because

229
00:09:12,399 --> 00:09:16,800
that's

230
00:09:12,800 --> 00:09:20,160
the easiest way to get access

231
00:09:16,800 --> 00:09:23,279
to information that you might

232
00:09:20,160 --> 00:09:24,880
not normally have access to

233
00:09:23,279 --> 00:09:26,560
and you want to find something windows

234
00:09:24,880 --> 00:09:29,760
kernel if it's not

235
00:09:26,560 --> 00:09:32,319
exported or

236
00:09:29,760 --> 00:09:34,160
some official documented thing you might

237
00:09:32,320 --> 00:09:35,680
have a hard time finding it that's why

238
00:09:34,160 --> 00:09:37,920
we have

239
00:09:35,680 --> 00:09:39,120
makes like binary scanning trying to

240
00:09:37,920 --> 00:09:43,040
match specific

241
00:09:39,120 --> 00:09:44,560
bytes signatures but if something is

242
00:09:43,040 --> 00:09:47,680
linked in the list

243
00:09:44,560 --> 00:09:49,518
it's enough to have one part of the list

244
00:09:47,680 --> 00:09:51,680
to have all of it you can just walk the

245
00:09:49,519 --> 00:09:53,120
list so i like lists in this case we

246
00:09:51,680 --> 00:09:56,640
have two

247
00:09:53,120 --> 00:09:58,880
the last field here is the callback list

248
00:09:56,640 --> 00:09:59,680
which links all the callback objects in

249
00:09:58,880 --> 00:10:01,279
the system

250
00:09:59,680 --> 00:10:03,120
in a single list which means once you

251
00:10:01,279 --> 00:10:06,800
have one callback object

252
00:10:03,120 --> 00:10:09,360
you can find all of them and the second

253
00:10:06,800 --> 00:10:10,640
is the list of registered callbacks

254
00:10:09,360 --> 00:10:14,720
because when you

255
00:10:10,640 --> 00:10:15,439
register a function to be notified by a

256
00:10:14,720 --> 00:10:17,360
callback

257
00:10:15,440 --> 00:10:19,440
you don't just register a function you

258
00:10:17,360 --> 00:10:22,320
register you create a

259
00:10:19,440 --> 00:10:22,880
callback registration structure that's

260
00:10:22,320 --> 00:10:26,560
what

261
00:10:22,880 --> 00:10:26,560
that's what gets internally created

262
00:10:26,720 --> 00:10:31,120
and we'll look at that in a second and

263
00:10:29,839 --> 00:10:32,720
those are all

264
00:10:31,120 --> 00:10:35,440
connected by a linked list which makes

265
00:10:32,720 --> 00:10:38,720
sense girl needs to

266
00:10:35,440 --> 00:10:41,040
have a way to get all the

267
00:10:38,720 --> 00:10:42,720
registered functions and notify them one

268
00:10:41,040 --> 00:10:43,839
by one so alex there's an easy way to do

269
00:10:42,720 --> 00:10:45,279
that

270
00:10:43,839 --> 00:10:46,880
and the last field in the callback

271
00:10:45,279 --> 00:10:48,240
object that's interesting is allow

272
00:10:46,880 --> 00:10:51,680
multiple callbacks

273
00:10:48,240 --> 00:10:56,720
like the name suggests that's

274
00:10:51,680 --> 00:10:56,719
um boolean value that says

275
00:10:57,120 --> 00:11:04,160
allow do you want to allow

276
00:11:00,160 --> 00:11:06,880
more than one callback function to be

277
00:11:04,160 --> 00:11:09,120
registered here or not that's

278
00:11:06,880 --> 00:11:11,279
that field is being specified when the

279
00:11:09,120 --> 00:11:14,240
callback is first created

280
00:11:11,279 --> 00:11:15,040
and if it's set to false when you

281
00:11:14,240 --> 00:11:18,399
register

282
00:11:15,040 --> 00:11:20,079
callback function the kernel will check

283
00:11:18,399 --> 00:11:22,240
if there's already someone registered

284
00:11:20,079 --> 00:11:25,439
for this callback and if there is

285
00:11:22,240 --> 00:11:25,440
it won't let you register

286
00:11:26,079 --> 00:11:30,800
no that's not a very major limit because

287
00:11:29,040 --> 00:11:32,640
the callback is in the kernel

288
00:11:30,800 --> 00:11:35,199
your driver is in the kernel you can go

289
00:11:32,640 --> 00:11:36,800
and catch the list yourself and just

290
00:11:35,200 --> 00:11:39,279
add your function there anyway but

291
00:11:36,800 --> 00:11:41,279
you're not supposed to

292
00:11:39,279 --> 00:11:43,600
so now when you create when you register

293
00:11:41,279 --> 00:11:45,439
a function for a callback

294
00:11:43,600 --> 00:11:47,760
behind the scenes there's a callback

295
00:11:45,440 --> 00:11:49,519
registration structure that's created

296
00:11:47,760 --> 00:11:51,279
again that has the linked list

297
00:11:49,519 --> 00:11:54,320
connecting all

298
00:11:51,279 --> 00:11:56,000
the callback registration structures it

299
00:11:54,320 --> 00:11:59,040
has the pointer to the callback

300
00:11:56,000 --> 00:12:02,000
function and it has a pointer

301
00:11:59,040 --> 00:12:04,800
to something called a callback context

302
00:12:02,000 --> 00:12:08,399
now that callback context

303
00:12:04,800 --> 00:12:09,599
is see if i have that in my example i

304
00:12:08,399 --> 00:12:12,880
didn't use it

305
00:12:09,600 --> 00:12:16,160
um that callback context is

306
00:12:12,880 --> 00:12:17,200
a pointer that you supply when you

307
00:12:16,160 --> 00:12:19,760
register

308
00:12:17,200 --> 00:12:21,519
for a callback and whenever your

309
00:12:19,760 --> 00:12:25,040
callback whenever the

310
00:12:21,519 --> 00:12:28,160
callback is notified every

311
00:12:25,040 --> 00:12:29,760
function that's listed in the list is

312
00:12:28,160 --> 00:12:33,040
going to be called

313
00:12:29,760 --> 00:12:36,240
and receive as one of the arguments

314
00:12:33,040 --> 00:12:38,240
the callback context that it registered

315
00:12:36,240 --> 00:12:39,920
it's not something like the caller it's

316
00:12:38,240 --> 00:12:41,360
not something that whoever notifies the

317
00:12:39,920 --> 00:12:42,800
callback determines it's not something

318
00:12:41,360 --> 00:12:45,040
that the kernel determines

319
00:12:42,800 --> 00:12:46,399
whoever registered the callback will

320
00:12:45,040 --> 00:12:48,719
receive

321
00:12:46,399 --> 00:12:50,399
its own callback context when the

322
00:12:48,720 --> 00:12:53,920
callback is notified

323
00:12:50,399 --> 00:12:54,720
on first look that might not make much

324
00:12:53,920 --> 00:12:57,920
sense because

325
00:12:54,720 --> 00:12:59,120
why would you register an argument that

326
00:12:57,920 --> 00:13:03,519
you're gonna receive

327
00:12:59,120 --> 00:13:05,440
later actually that's um

328
00:13:03,519 --> 00:13:06,959
the logic behind is that this is a

329
00:13:05,440 --> 00:13:10,240
pretty

330
00:13:06,959 --> 00:13:13,279
um rough way to implement

331
00:13:10,240 --> 00:13:15,440
classes but kernel is

332
00:13:13,279 --> 00:13:18,160
is not built with classes it's basically

333
00:13:15,440 --> 00:13:21,279
c there's no

334
00:13:18,160 --> 00:13:23,040
there's no complicated development

335
00:13:21,279 --> 00:13:24,000
concepts there there's no classes in the

336
00:13:23,040 --> 00:13:26,639
kernel

337
00:13:24,000 --> 00:13:28,399
but that's a rough way to implement a

338
00:13:26,639 --> 00:13:29,440
class where the whenever the callback

339
00:13:28,399 --> 00:13:32,160
object it would

340
00:13:29,440 --> 00:13:32,959
is notified would receive the class

341
00:13:32,160 --> 00:13:34,959
instance

342
00:13:32,959 --> 00:13:36,479
basically it's a way for drivers to have

343
00:13:34,959 --> 00:13:39,839
some

344
00:13:36,480 --> 00:13:42,079
internal global data structure that they

345
00:13:39,839 --> 00:13:44,800
want to have available

346
00:13:42,079 --> 00:13:46,638
in a lot of cases including in their

347
00:13:44,800 --> 00:13:49,760
callback

348
00:13:46,639 --> 00:13:52,560
in their callback function but

349
00:13:49,760 --> 00:13:55,199
without saving it as a global that

350
00:13:52,560 --> 00:13:57,920
anyone can easily find

351
00:13:55,199 --> 00:13:59,199
so that's that and why is that

352
00:13:57,920 --> 00:14:01,839
interesting

353
00:13:59,199 --> 00:14:03,599
because that means that those callback

354
00:14:01,839 --> 00:14:06,399
contexts when used

355
00:14:03,600 --> 00:14:07,040
can will probably be pointers to pretty

356
00:14:06,399 --> 00:14:09,680
large

357
00:14:07,040 --> 00:14:11,599
internal data structures where we might

358
00:14:09,680 --> 00:14:13,439
have information that

359
00:14:11,600 --> 00:14:15,440
we're interested in but we'll have a

360
00:14:13,440 --> 00:14:16,720
pretty hard time finding otherwise

361
00:14:15,440 --> 00:14:18,720
because it's usually

362
00:14:16,720 --> 00:14:20,399
full memory it can be anywhere it

363
00:14:18,720 --> 00:14:23,279
doesn't usually have

364
00:14:20,399 --> 00:14:25,199
something that makes it easy to identify

365
00:14:23,279 --> 00:14:27,519
to find if you need to go and dig inside

366
00:14:25,199 --> 00:14:29,199
the driver for pointers

367
00:14:27,519 --> 00:14:31,360
but the callback context is an easy way

368
00:14:29,199 --> 00:14:33,599
to find a pointer into it

369
00:14:31,360 --> 00:14:35,279
a lot of drivers don't use that callback

370
00:14:33,600 --> 00:14:38,079
context later we'll

371
00:14:35,279 --> 00:14:38,800
dump some callbacks and see and mostly

372
00:14:38,079 --> 00:14:41,920
it's

373
00:14:38,800 --> 00:14:45,839
null but when it's not you can sometimes

374
00:14:41,920 --> 00:14:45,839
find some interesting things there

375
00:14:47,440 --> 00:14:50,720
here we basically have the same thing in

376
00:14:49,519 --> 00:14:53,519
diagram

377
00:14:50,720 --> 00:14:55,199
form we have the two lists we have a

378
00:14:53,519 --> 00:14:58,720
list that connects

379
00:14:55,199 --> 00:15:01,120
all the callback objects together and

380
00:14:58,720 --> 00:15:02,160
in each one of them we have the internal

381
00:15:01,120 --> 00:15:06,560
list

382
00:15:02,160 --> 00:15:06,560
connecting all the callback registration

383
00:15:07,040 --> 00:15:10,800
entries inside the callback each

384
00:15:08,959 --> 00:15:14,160
callback registration is

385
00:15:10,800 --> 00:15:16,719
one driver that registered a function

386
00:15:14,160 --> 00:15:18,160
to be notified when the callback is

387
00:15:16,720 --> 00:15:21,440
notified

388
00:15:18,160 --> 00:15:23,600
as we can see here if we get

389
00:15:21,440 --> 00:15:26,800
one of them any of them a callback

390
00:15:23,600 --> 00:15:29,199
object or a callback registration

391
00:15:26,800 --> 00:15:31,040
we have all of them we can find every

392
00:15:29,199 --> 00:15:33,439
registered

393
00:15:31,040 --> 00:15:34,800
function in every callback object in the

394
00:15:33,440 --> 00:15:36,399
system

395
00:15:34,800 --> 00:15:38,240
means even if there's callback objects

396
00:15:36,399 --> 00:15:41,120
that we can't easily find

397
00:15:38,240 --> 00:15:42,880
for example unnamed ones that we can't

398
00:15:41,120 --> 00:15:55,839
index by name

399
00:15:42,880 --> 00:15:55,839
we still have a way to find them

400
00:15:57,360 --> 00:16:04,560
now who actually uses those callbacks

401
00:16:00,720 --> 00:16:07,279
first the windows kernel itself exports

402
00:16:04,560 --> 00:16:08,079
but not exports exposes some callbacks

403
00:16:07,279 --> 00:16:10,480
like

404
00:16:08,079 --> 00:16:11,519
a very popular one pretty well known one

405
00:16:10,480 --> 00:16:14,959
is the

406
00:16:11,519 --> 00:16:18,079
power state callback i mentioned earlier

407
00:16:14,959 --> 00:16:21,040
um there is a processor add callback

408
00:16:18,079 --> 00:16:22,079
there's license there's a license

409
00:16:21,040 --> 00:16:24,880
licensing

410
00:16:22,079 --> 00:16:27,199
data callback and like we saw the image

411
00:16:24,880 --> 00:16:30,560
verification one that's pretty useful

412
00:16:27,199 --> 00:16:34,079
for edr software

413
00:16:30,560 --> 00:16:35,920
to to know what drivers are loaded

414
00:16:34,079 --> 00:16:38,160
one thing i have to add is that callback

415
00:16:35,920 --> 00:16:40,639
objects are unlike some other

416
00:16:38,160 --> 00:16:42,560
parts of the system callback object

417
00:16:40,639 --> 00:16:45,680
objects are just notifications

418
00:16:42,560 --> 00:16:47,439
for example being notified that a driver

419
00:16:45,680 --> 00:16:48,560
is being loaded doesn't give you the

420
00:16:47,440 --> 00:16:51,120
option of

421
00:16:48,560 --> 00:16:52,000
blocking it or changing it in any way it

422
00:16:51,120 --> 00:16:55,279
just

423
00:16:52,000 --> 00:16:57,040
sends you message saying hey this thing

424
00:16:55,279 --> 00:16:58,720
is get is being loaded here's its

425
00:16:57,040 --> 00:17:02,639
information

426
00:16:58,720 --> 00:17:05,039
good luck uh so there's a few of those

427
00:17:02,639 --> 00:17:06,480
there's some interesting callbacks in

428
00:17:05,039 --> 00:17:10,400
the kernel

429
00:17:06,480 --> 00:17:15,120
that some of them are used pretty often

430
00:17:10,400 --> 00:17:18,319
for example win32k has some callbacks

431
00:17:15,119 --> 00:17:22,559
that uses mostly anonymous callbacks for

432
00:17:18,319 --> 00:17:26,119
internal 132k communication and

433
00:17:22,559 --> 00:17:29,200
for whoever is interested in win32k 132k

434
00:17:26,119 --> 00:17:32,399
exploitation and bugs and

435
00:17:29,200 --> 00:17:35,520
finding more ways in there that might be

436
00:17:32,400 --> 00:17:37,679
an interesting direction to look at

437
00:17:35,520 --> 00:17:39,280
other than that there are security

438
00:17:37,679 --> 00:17:40,799
products that use them for internal

439
00:17:39,280 --> 00:17:42,399
communication

440
00:17:40,799 --> 00:17:44,960
security products that have more than

441
00:17:42,400 --> 00:17:46,880
one driver and want an easy way to

442
00:17:44,960 --> 00:17:48,400
synchronize between them and pass

443
00:17:46,880 --> 00:17:50,320
information

444
00:17:48,400 --> 00:17:52,320
might use that for example windows

445
00:17:50,320 --> 00:17:54,720
defender has a few

446
00:17:52,320 --> 00:17:55,360
different drivers and uses callback

447
00:17:54,720 --> 00:17:58,400
objects

448
00:17:55,360 --> 00:18:00,559
for communication between them and it's

449
00:17:58,400 --> 00:18:01,280
actually a fun example to look at that

450
00:18:00,559 --> 00:18:04,480
we'll

451
00:18:01,280 --> 00:18:07,280
look at in a bit more detail later and

452
00:18:04,480 --> 00:18:10,320
another example that's

453
00:18:07,280 --> 00:18:14,080
that's pretty interesting is patch card

454
00:18:10,320 --> 00:18:15,439
patch card has a callback object that is

455
00:18:14,080 --> 00:18:18,639
used to

456
00:18:15,440 --> 00:18:21,840
initialize a pointer to

457
00:18:18,640 --> 00:18:23,919
a function that does patch or periodic

458
00:18:21,840 --> 00:18:26,840
checks

459
00:18:23,919 --> 00:18:29,840
and we'll look at that a bit more later

460
00:18:26,840 --> 00:18:29,840
too

461
00:18:30,720 --> 00:18:35,919
now i'm mentioning all these callbacks

462
00:18:32,559 --> 00:18:38,960
but how can we actually find them

463
00:18:35,919 --> 00:18:40,960
these callbacks because they're not just

464
00:18:38,960 --> 00:18:42,000
the when just the kernels callbacks

465
00:18:40,960 --> 00:18:45,360
because anyone can use

466
00:18:42,000 --> 00:18:47,440
them each of you will have different

467
00:18:45,360 --> 00:18:48,320
callbacks on your system based on what

468
00:18:47,440 --> 00:18:50,720
products run

469
00:18:48,320 --> 00:18:52,000
run there like is windows defender

470
00:18:50,720 --> 00:18:53,840
running

471
00:18:52,000 --> 00:18:55,440
or do you have some other security

472
00:18:53,840 --> 00:18:59,439
product or

473
00:18:55,440 --> 00:19:02,720
some other things that use callbacks so

474
00:18:59,440 --> 00:19:05,120
a few ways to see

475
00:19:02,720 --> 00:19:07,760
what callbacks you have one of them is

476
00:19:05,120 --> 00:19:08,399
using winobgx that's a pretty easy one

477
00:19:07,760 --> 00:19:10,960
just

478
00:19:08,400 --> 00:19:12,799
looking for callbacks with window gx the

479
00:19:10,960 --> 00:19:13,840
only limitation is that it's only going

480
00:19:12,799 --> 00:19:16,879
to show

481
00:19:13,840 --> 00:19:18,799
named callbacks it won't show you the

482
00:19:16,880 --> 00:19:20,720
unnamed one so you'll only see ones that

483
00:19:18,799 --> 00:19:23,918
have a name

484
00:19:20,720 --> 00:19:28,880
another option is to use wind bag

485
00:19:23,919 --> 00:19:30,640
and run bang object uh slash callbacks

486
00:19:28,880 --> 00:19:32,480
i'll show this later when i show the

487
00:19:30,640 --> 00:19:34,000
demos uh but that

488
00:19:32,480 --> 00:19:36,880
again that will only show the named

489
00:19:34,000 --> 00:19:38,960
callbacks you can also use winback to

490
00:19:36,880 --> 00:19:42,400
write a script a dx script or

491
00:19:38,960 --> 00:19:46,160
javascript to a javascript script

492
00:19:42,400 --> 00:19:46,960
to manually parse the callback objects

493
00:19:46,160 --> 00:19:49,520
and then you will

494
00:19:46,960 --> 00:19:50,799
have all of them not just the named ones

495
00:19:49,520 --> 00:19:52,320
the

496
00:19:50,799 --> 00:19:54,879
part that makes it difficult is again

497
00:19:52,320 --> 00:19:57,120
the internal structures

498
00:19:54,880 --> 00:19:58,320
are not documented and not in the

499
00:19:57,120 --> 00:20:00,639
symbols

500
00:19:58,320 --> 00:20:02,720
so you'll have a bit of a hard time

501
00:20:00,640 --> 00:20:05,600
doing that it is possible

502
00:20:02,720 --> 00:20:07,360
but it will be slightly difficult to

503
00:20:05,600 --> 00:20:10,240
it's that difficult to work with

504
00:20:07,360 --> 00:20:11,840
undocumented structures in one bag third

505
00:20:10,240 --> 00:20:15,679
option which i'll show later

506
00:20:11,840 --> 00:20:18,959
is using just using c writing either

507
00:20:15,679 --> 00:20:19,280
debugger api which is what i did or

508
00:20:18,960 --> 00:20:22,320
write

509
00:20:19,280 --> 00:20:23,280
a driver that will parse the callback

510
00:20:22,320 --> 00:20:26,320
list

511
00:20:23,280 --> 00:20:27,200
both are valid options i i wrote a tool

512
00:20:26,320 --> 00:20:29,760
to do that

513
00:20:27,200 --> 00:20:31,760
um a debugger api tool that i'll share

514
00:20:29,760 --> 00:20:35,120
later

515
00:20:31,760 --> 00:20:38,640
and then if we look at the list this

516
00:20:35,120 --> 00:20:41,199
this way ex screenshot is from

517
00:20:38,640 --> 00:20:43,200
my machine and we can see stuff like

518
00:20:41,200 --> 00:20:46,320
that first one the one with the

519
00:20:43,200 --> 00:20:50,159
with all the weird named number

520
00:20:46,320 --> 00:20:53,760
that's the patch card callback actually

521
00:20:50,159 --> 00:20:57,440
then we have all sorts of callbacks

522
00:20:53,760 --> 00:21:01,120
from my audio and video cards

523
00:20:57,440 --> 00:21:01,120
there's a few of them here

524
00:21:01,280 --> 00:21:06,320
we see the power state callback we see

525
00:21:03,919 --> 00:21:11,120
the image verification callback

526
00:21:06,320 --> 00:21:14,559
and at the end we see three wd callbacks

527
00:21:11,120 --> 00:21:16,559
those are the windows defender ones

528
00:21:14,559 --> 00:21:17,678
the one that windows defender uses for

529
00:21:16,559 --> 00:21:20,399
its internal

530
00:21:17,679 --> 00:21:20,400
communication

531
00:21:21,760 --> 00:21:24,879
now we've seen this mechanism we see

532
00:21:23,679 --> 00:21:27,679
what it does we see how we can

533
00:21:24,880 --> 00:21:31,200
legitimately use it

534
00:21:27,679 --> 00:21:33,840
how can we abuse this mechanism

535
00:21:31,200 --> 00:21:34,240
there's all sorts of fun ways like i

536
00:21:33,840 --> 00:21:37,600
said

537
00:21:34,240 --> 00:21:38,640
this mechanism is can used for internal

538
00:21:37,600 --> 00:21:41,678
communication

539
00:21:38,640 --> 00:21:43,919
but it is not private

540
00:21:41,679 --> 00:21:45,039
as long as a callback is not defined

541
00:21:43,919 --> 00:21:46,960
with

542
00:21:45,039 --> 00:21:48,640
don't allow multiple callbacks anyone

543
00:21:46,960 --> 00:21:50,640
can register to it

544
00:21:48,640 --> 00:21:52,000
you cannot specify who is allowed and

545
00:21:50,640 --> 00:21:53,760
who is not allowed

546
00:21:52,000 --> 00:21:55,440
even if technically a callback is not

547
00:21:53,760 --> 00:21:56,960
allowed to have multiple callbacks you

548
00:21:55,440 --> 00:22:00,159
can go and patch them

549
00:21:56,960 --> 00:22:03,760
and patch the memory yourself you can

550
00:22:00,159 --> 00:22:06,400
find pointers and hook

551
00:22:03,760 --> 00:22:08,640
um communication by replacing the

552
00:22:06,400 --> 00:22:10,640
pointer with your own function

553
00:22:08,640 --> 00:22:12,080
or just adding another one to the list

554
00:22:10,640 --> 00:22:14,880
and listening

555
00:22:12,080 --> 00:22:16,320
into callbacks that might have

556
00:22:14,880 --> 00:22:17,520
interesting information that we want to

557
00:22:16,320 --> 00:22:20,639
follow for example

558
00:22:17,520 --> 00:22:21,918
the windows defender callbacks you can

559
00:22:20,640 --> 00:22:26,480
also

560
00:22:21,919 --> 00:22:27,600
remove remove functions from those lists

561
00:22:26,480 --> 00:22:30,240
which will

562
00:22:27,600 --> 00:22:31,678
probably break something depending on

563
00:22:30,240 --> 00:22:34,960
what you remove

564
00:22:31,679 --> 00:22:34,960
and from which callbacks

565
00:22:35,600 --> 00:22:39,520
you can use the callback context to find

566
00:22:37,840 --> 00:22:41,360
pointers to interesting

567
00:22:39,520 --> 00:22:42,799
structures interesting internal

568
00:22:41,360 --> 00:22:45,918
structures used by

569
00:22:42,799 --> 00:22:48,240
drivers that you that you care about

570
00:22:45,919 --> 00:22:49,760
and you can also notify those callbacks

571
00:22:48,240 --> 00:22:52,799
yourself

572
00:22:49,760 --> 00:22:55,520
with possibly false information

573
00:22:52,799 --> 00:22:56,559
which good with security products which

574
00:22:55,520 --> 00:23:00,080
could lead some

575
00:22:56,559 --> 00:23:00,080
to some interesting results there

576
00:23:05,280 --> 00:23:10,720
a couple of the examples that

577
00:23:08,720 --> 00:23:13,360
i mentioned that we'll look at are

578
00:23:10,720 --> 00:23:17,600
windows defender and patch card

579
00:23:13,360 --> 00:23:20,399
so windows defender a very rough um

580
00:23:17,600 --> 00:23:22,639
very rough design it has is windows

581
00:23:20,400 --> 00:23:26,320
defender on windows 10 has

582
00:23:22,640 --> 00:23:29,120
three drivers first one is

583
00:23:26,320 --> 00:23:30,879
the filter driver which does love the

584
00:23:29,120 --> 00:23:32,959
work it registers for the processing

585
00:23:30,880 --> 00:23:35,520
thread notifications it

586
00:23:32,960 --> 00:23:36,240
monitors file system does all sorts of

587
00:23:35,520 --> 00:23:39,679
things

588
00:23:36,240 --> 00:23:42,880
that one has one callback

589
00:23:39,679 --> 00:23:44,960
the second one is the network driver

590
00:23:42,880 --> 00:23:46,880
which communicates with the management

591
00:23:44,960 --> 00:23:48,240
system and that one has a second

592
00:23:46,880 --> 00:23:50,720
callback

593
00:23:48,240 --> 00:23:51,520
and the last one is the boot or elam

594
00:23:50,720 --> 00:23:55,360
driver

595
00:23:51,520 --> 00:23:58,240
um for anyone who's not familiar elam is

596
00:23:55,360 --> 00:23:59,199
a microsoft program in which it allows

597
00:23:58,240 --> 00:24:03,279
certain

598
00:23:59,200 --> 00:24:05,600
av vendors to load their driver

599
00:24:03,279 --> 00:24:06,720
very early earlier than most drivers are

600
00:24:05,600 --> 00:24:09,120
allowed to load

601
00:24:06,720 --> 00:24:09,840
and what those drivers are allowed to do

602
00:24:09,120 --> 00:24:13,840
is

603
00:24:09,840 --> 00:24:17,760
pretty much one thing register for

604
00:24:13,840 --> 00:24:20,320
windows callback another callback object

605
00:24:17,760 --> 00:24:21,760
which will give them which will notify

606
00:24:20,320 --> 00:24:25,039
them every time

607
00:24:21,760 --> 00:24:28,158
a boot driver is loaded

608
00:24:25,039 --> 00:24:31,760
with with information

609
00:24:28,159 --> 00:24:33,840
about the hash with some basic

610
00:24:31,760 --> 00:24:37,679
information about the driver

611
00:24:33,840 --> 00:24:38,959
this one allows those allows the boot

612
00:24:37,679 --> 00:24:42,159
drive allows the

613
00:24:38,960 --> 00:24:45,760
av driver to use

614
00:24:42,159 --> 00:24:47,679
um an allow list or block list

615
00:24:45,760 --> 00:24:49,760
to decide if it wants to block those

616
00:24:47,679 --> 00:24:53,120
drivers that's meant to

617
00:24:49,760 --> 00:24:56,240
allow some av drivers to block

618
00:24:53,120 --> 00:25:01,840
early loaded malicious drivers like root

619
00:24:56,240 --> 00:25:01,840
kits that will be loaded in the system

620
00:25:05,760 --> 00:25:09,200
so windows defender has a boot drive has

621
00:25:08,000 --> 00:25:11,039
a

622
00:25:09,200 --> 00:25:13,840
has an elam driver that is loaded very

623
00:25:11,039 --> 00:25:17,360
early in the system

624
00:25:13,840 --> 00:25:20,240
for this callback and has an internal

625
00:25:17,360 --> 00:25:22,080
callback object of its own that it uses

626
00:25:20,240 --> 00:25:24,960
to communicate with the other

627
00:25:22,080 --> 00:25:26,399
with the filter driver so what does this

628
00:25:24,960 --> 00:25:28,400
callback do

629
00:25:26,400 --> 00:25:30,240
um one thing to know about elon drivers

630
00:25:28,400 --> 00:25:33,120
is that they have to

631
00:25:30,240 --> 00:25:34,960
unload early too they're allowed to load

632
00:25:33,120 --> 00:25:37,760
very early

633
00:25:34,960 --> 00:25:39,200
see all the boot drivers load uh block

634
00:25:37,760 --> 00:25:40,960
or not block them

635
00:25:39,200 --> 00:25:42,799
and then they need to unload they can't

636
00:25:40,960 --> 00:25:45,039
keep running so what the windows

637
00:25:42,799 --> 00:25:47,279
defender driver does

638
00:25:45,039 --> 00:25:48,559
is that it receives those driver

639
00:25:47,279 --> 00:25:50,480
notifications

640
00:25:48,559 --> 00:25:51,760
and it saves the information about the

641
00:25:50,480 --> 00:25:55,120
drivers in

642
00:25:51,760 --> 00:25:56,240
an internal data structure then when the

643
00:25:55,120 --> 00:25:59,279
filter driver

644
00:25:56,240 --> 00:26:01,200
loads right before the boot driver needs

645
00:25:59,279 --> 00:26:04,880
to unload

646
00:26:01,200 --> 00:26:08,000
the filter driver registers for

647
00:26:04,880 --> 00:26:09,279
the windows defender boot callback and

648
00:26:08,000 --> 00:26:12,559
notifies it

649
00:26:09,279 --> 00:26:15,279
telling the boot driver hey

650
00:26:12,559 --> 00:26:16,799
send me all the driver information that

651
00:26:15,279 --> 00:26:20,080
you kept

652
00:26:16,799 --> 00:26:22,320
so it can use it for whichever detection

653
00:26:20,080 --> 00:26:24,480
logics or notifications

654
00:26:22,320 --> 00:26:26,559
or whatever it wants to do with them and

655
00:26:24,480 --> 00:26:30,080
the boot driver sends back

656
00:26:26,559 --> 00:26:32,000
the all the info that internal data

657
00:26:30,080 --> 00:26:35,918
structure with all the information

658
00:26:32,000 --> 00:26:39,120
about the early loaded drivers

659
00:26:35,919 --> 00:26:39,919
so that's one callback which is if you

660
00:26:39,120 --> 00:26:42,399
manage to

661
00:26:39,919 --> 00:26:43,840
load early enough before the boot driver

662
00:26:42,400 --> 00:26:45,840
is unloaded

663
00:26:43,840 --> 00:26:47,439
you can notify that callback and receive

664
00:26:45,840 --> 00:26:50,320
all that information to us and when you

665
00:26:47,440 --> 00:26:52,640
know how to parse it

666
00:26:50,320 --> 00:26:55,678
second callback is the filter driver

667
00:26:52,640 --> 00:26:55,679
callback that's the

668
00:26:58,159 --> 00:27:03,039
call we had it here that's the last one

669
00:27:02,080 --> 00:27:06,520
on the list

670
00:27:03,039 --> 00:27:09,039
w the the boot driver callback is the

671
00:27:06,520 --> 00:27:11,840
wdeb notification callback

672
00:27:09,039 --> 00:27:12,720
and the filter driver has the it creates

673
00:27:11,840 --> 00:27:16,399
the wd

674
00:27:12,720 --> 00:27:16,400
process notification callback

675
00:27:19,520 --> 00:27:24,960
so like the like it sounds from the name

676
00:27:22,320 --> 00:27:28,240
the wd process notification callback

677
00:27:24,960 --> 00:27:31,120
is a way for windows defender to notify

678
00:27:28,240 --> 00:27:34,080
other drivers about processes

679
00:27:31,120 --> 00:27:36,479
um starting in the system because what

680
00:27:34,080 --> 00:27:37,600
happens is the filter driver registers

681
00:27:36,480 --> 00:27:39,760
for the

682
00:27:37,600 --> 00:27:40,879
legacy process notification callbacks

683
00:27:39,760 --> 00:27:44,000
the one where

684
00:27:40,880 --> 00:27:45,520
the kernel notifies drivers about every

685
00:27:44,000 --> 00:27:47,520
loaded process

686
00:27:45,520 --> 00:27:48,559
so when your defender receives that

687
00:27:47,520 --> 00:27:51,918
notification

688
00:27:48,559 --> 00:27:53,918
that a new process has been loaded it

689
00:27:51,919 --> 00:27:55,520
does some analysis gets some information

690
00:27:53,919 --> 00:27:58,880
about the driver

691
00:27:55,520 --> 00:28:01,039
and then it wants to pass that

692
00:27:58,880 --> 00:28:02,399
information to the network driver so it

693
00:28:01,039 --> 00:28:06,879
can pass it on

694
00:28:02,399 --> 00:28:10,479
to the management server to the

695
00:28:06,880 --> 00:28:13,039
centralized server so when a windows

696
00:28:10,480 --> 00:28:15,279
defender is notified about a new process

697
00:28:13,039 --> 00:28:18,000
it gets whatever information needs it

698
00:28:15,279 --> 00:28:20,960
saves it in its own internal structure

699
00:28:18,000 --> 00:28:22,320
and then it uses the windows defender

700
00:28:20,960 --> 00:28:25,360
callback object

701
00:28:22,320 --> 00:28:28,240
to notify the network driver hey

702
00:28:25,360 --> 00:28:31,520
there is a new process in the system

703
00:28:28,240 --> 00:28:35,679
here is the information about it

704
00:28:31,520 --> 00:28:37,600
now what's fun about this callback is

705
00:28:35,679 --> 00:28:39,440
that something that you haven't

706
00:28:37,600 --> 00:28:40,959
mentioned before callback objects are

707
00:28:39,440 --> 00:28:42,720
not very well known

708
00:28:40,960 --> 00:28:44,720
and as far as i know they're not really

709
00:28:42,720 --> 00:28:46,880
monitored by

710
00:28:44,720 --> 00:28:48,720
anyone i don't know any security

711
00:28:46,880 --> 00:28:51,840
products that monitor them

712
00:28:48,720 --> 00:28:53,919
uh tools like when check don't

713
00:28:51,840 --> 00:28:55,039
dump callback objects as far as i'm

714
00:28:53,919 --> 00:28:59,279
aware

715
00:28:55,039 --> 00:29:02,480
so they're not really looked at

716
00:28:59,279 --> 00:29:03,039
but for example the call legacy called

717
00:29:02,480 --> 00:29:06,960
accept

718
00:29:03,039 --> 00:29:11,120
legacy process notification callback is

719
00:29:06,960 --> 00:29:13,440
a much more well-known one and

720
00:29:11,120 --> 00:29:14,879
a lot of products are looking at it

721
00:29:13,440 --> 00:29:16,720
seeing who is registered

722
00:29:14,880 --> 00:29:18,640
there where does it point does it point

723
00:29:16,720 --> 00:29:22,640
to driver memory does it point to

724
00:29:18,640 --> 00:29:26,159
non-driver memory if you register there

725
00:29:22,640 --> 00:29:27,039
you're a lot more exposed but you can do

726
00:29:26,159 --> 00:29:29,440
something interesting

727
00:29:27,039 --> 00:29:31,120
if you have windows defender running and

728
00:29:29,440 --> 00:29:32,640
you want your rootkit to get cross

729
00:29:31,120 --> 00:29:36,000
notifications

730
00:29:32,640 --> 00:29:38,399
but not be super

731
00:29:36,000 --> 00:29:40,080
out there about it you can let the

732
00:29:38,399 --> 00:29:42,559
windows defender register for

733
00:29:40,080 --> 00:29:44,399
pros notifications let it receive the

734
00:29:42,559 --> 00:29:47,440
data process the data

735
00:29:44,399 --> 00:29:50,479
and then register your own driver

736
00:29:47,440 --> 00:29:53,600
to the windows defender callback so

737
00:29:50,480 --> 00:29:56,080
whenever a new proxy is loaded windows

738
00:29:53,600 --> 00:29:59,199
defender will notify its own callback

739
00:29:56,080 --> 00:30:02,720
and as a result will notify

740
00:29:59,200 --> 00:30:03,120
your driver too and not only do you get

741
00:30:02,720 --> 00:30:06,320
to

742
00:30:03,120 --> 00:30:08,479
sort of hide and not

743
00:30:06,320 --> 00:30:10,559
and not be super visible because you're

744
00:30:08,480 --> 00:30:13,760
not registered to the

745
00:30:10,559 --> 00:30:15,440
system's pros notification callback you

746
00:30:13,760 --> 00:30:16,559
also get slightly more processed

747
00:30:15,440 --> 00:30:18,399
information

748
00:30:16,559 --> 00:30:20,960
and kind of letting windows defender do

749
00:30:18,399 --> 00:30:22,639
some of the work for you

750
00:30:20,960 --> 00:30:24,159
the only downside here is that windows

751
00:30:22,640 --> 00:30:25,840
defender uses an

752
00:30:24,159 --> 00:30:28,080
internal data structure for its

753
00:30:25,840 --> 00:30:30,720
information so you'll need to

754
00:30:28,080 --> 00:30:31,840
figure out how this data structure is

755
00:30:30,720 --> 00:30:33,679
built

756
00:30:31,840 --> 00:30:36,000
and how to parse it properly once you

757
00:30:33,679 --> 00:30:37,679
have that you've got everything and

758
00:30:36,000 --> 00:30:40,000
that's actually the most interesting

759
00:30:37,679 --> 00:30:40,720
callback that windows defender has the

760
00:30:40,000 --> 00:30:44,559
third one

761
00:30:40,720 --> 00:30:46,480
is the network drivers callback which is

762
00:30:44,559 --> 00:30:48,000
only actually called once

763
00:30:46,480 --> 00:30:50,159
it's called when the network driver

764
00:30:48,000 --> 00:30:52,320
starts because it starts a lot later

765
00:30:50,159 --> 00:30:53,520
than the filter drivers then the filter

766
00:30:52,320 --> 00:30:55,918
driver

767
00:30:53,520 --> 00:30:57,918
when the network driver starts it

768
00:30:55,919 --> 00:31:01,440
registers for this

769
00:30:57,919 --> 00:31:04,320
callback object that the filter driver

770
00:31:01,440 --> 00:31:06,399
creates to notify the filter driver hey

771
00:31:04,320 --> 00:31:08,240
i'm up you can start sending me

772
00:31:06,399 --> 00:31:11,279
information

773
00:31:08,240 --> 00:31:13,279
and then immediately the

774
00:31:11,279 --> 00:31:14,880
filter driver sends it the information

775
00:31:13,279 --> 00:31:16,880
about all the processes

776
00:31:14,880 --> 00:31:18,399
that were loaded before the fill before

777
00:31:16,880 --> 00:31:20,960
the network driver started

778
00:31:18,399 --> 00:31:22,320
so it's only actually notified once you

779
00:31:20,960 --> 00:31:24,240
don't really get

780
00:31:22,320 --> 00:31:26,399
different information than you do with

781
00:31:24,240 --> 00:31:29,120
the process

782
00:31:26,399 --> 00:31:29,678
with the process callback um you just

783
00:31:29,120 --> 00:31:33,039
get a

784
00:31:29,679 --> 00:31:34,880
more you get information about more

785
00:31:33,039 --> 00:31:36,559
processes but you don't get actually

786
00:31:34,880 --> 00:31:37,200
different information that's just an

787
00:31:36,559 --> 00:31:41,600
internal

788
00:31:37,200 --> 00:31:41,600
synchronization mechanism for them

789
00:31:45,120 --> 00:31:50,959
so the second callback object that

790
00:31:48,960 --> 00:31:53,039
seems pretty exciting is the patch card

791
00:31:50,960 --> 00:31:55,039
callback it has this

792
00:31:53,039 --> 00:31:56,240
very unclear name because it's not going

793
00:31:55,039 --> 00:31:59,679
to be called

794
00:31:56,240 --> 00:32:03,120
patchguard notification callback

795
00:31:59,679 --> 00:32:05,440
and that one is also only called

796
00:32:03,120 --> 00:32:06,479
once it's not called to trigger patch

797
00:32:05,440 --> 00:32:10,240
card checks

798
00:32:06,480 --> 00:32:13,360
it is called to initialize a pointer

799
00:32:10,240 --> 00:32:14,320
to the function that performs patch card

800
00:32:13,360 --> 00:32:16,639
checks

801
00:32:14,320 --> 00:32:18,678
um the kernel notifies this callback

802
00:32:16,640 --> 00:32:22,640
once when

803
00:32:18,679 --> 00:32:25,919
initialization of the system ends when

804
00:32:22,640 --> 00:32:29,039
um phase zero ends up

805
00:32:25,919 --> 00:32:30,640
the system wants to make

806
00:32:29,039 --> 00:32:32,158
patch cards start running to enable

807
00:32:30,640 --> 00:32:33,360
patch card because everything is where

808
00:32:32,159 --> 00:32:34,399
it's supposed to be everything is

809
00:32:33,360 --> 00:32:36,000
initialized

810
00:32:34,399 --> 00:32:37,518
now it wants patch guard to start

811
00:32:36,000 --> 00:32:39,919
monitoring

812
00:32:37,519 --> 00:32:42,480
so enables patch card and as part of

813
00:32:39,919 --> 00:32:45,600
that it notifies that callback

814
00:32:42,480 --> 00:32:49,440
which has one registered function to it

815
00:32:45,600 --> 00:32:53,439
the function is in ms-sec-flt

816
00:32:49,440 --> 00:32:57,840
and it notifies it with a pointer

817
00:32:53,440 --> 00:32:57,840
to the function that will perform

818
00:32:58,559 --> 00:33:02,480
random random patch card checks

819
00:33:02,559 --> 00:33:06,158
to tell i'm a second faulty this is the

820
00:33:04,559 --> 00:33:08,559
function that you need to call

821
00:33:06,159 --> 00:33:10,399
to do patch card checks now the

822
00:33:08,559 --> 00:33:11,840
interesting thing about this is

823
00:33:10,399 --> 00:33:14,719
registering for this callback is not

824
00:33:11,840 --> 00:33:17,760
very useful because

825
00:33:14,720 --> 00:33:19,200
you're going to register too late um if

826
00:33:17,760 --> 00:33:23,039
you somehow manage to

827
00:33:19,200 --> 00:33:26,000
have your driver running before phase 0

828
00:33:23,039 --> 00:33:28,080
of uh system initialization ends there

829
00:33:26,000 --> 00:33:29,600
are more interesting things you can do

830
00:33:28,080 --> 00:33:31,760
than registering for the patch card

831
00:33:29,600 --> 00:33:32,719
callback so registering for it is not

832
00:33:31,760 --> 00:33:34,799
going to be

833
00:33:32,720 --> 00:33:35,840
very useful because it won't be called

834
00:33:34,799 --> 00:33:39,360
by the time

835
00:33:35,840 --> 00:33:42,000
your driver is up but

836
00:33:39,360 --> 00:33:44,559
looking at the look at the way it's

837
00:33:42,000 --> 00:33:44,559
implemented

838
00:33:44,640 --> 00:33:50,000
the function in msc flt is implemented

839
00:33:47,840 --> 00:33:52,158
in such a way that it

840
00:33:50,000 --> 00:33:53,840
initializes its own global with the

841
00:33:52,159 --> 00:33:56,720
pointer that it received

842
00:33:53,840 --> 00:33:58,799
but never checks if the pointer is if

843
00:33:56,720 --> 00:34:02,320
the global

844
00:33:58,799 --> 00:34:05,440
is already initialized which means

845
00:34:02,320 --> 00:34:06,000
if you notify this callback again you

846
00:34:05,440 --> 00:34:08,960
can replace

847
00:34:06,000 --> 00:34:09,359
the pointer you would expect it to bug

848
00:34:08,960 --> 00:34:11,040
check

849
00:34:09,359 --> 00:34:13,199
because hey the pointer is already

850
00:34:11,040 --> 00:34:14,560
initialized who's trying to change it

851
00:34:13,199 --> 00:34:18,239
and why

852
00:34:14,560 --> 00:34:20,639
but it doesn't um

853
00:34:18,239 --> 00:34:22,399
so you can notify the callback again and

854
00:34:20,639 --> 00:34:25,679
see what happens

855
00:34:22,399 --> 00:34:27,279
now my guess is that on newer systems

856
00:34:25,679 --> 00:34:30,560
with hyperguard

857
00:34:27,280 --> 00:34:32,159
this pointer uh will probably be

858
00:34:30,560 --> 00:34:35,119
protected and you will probably

859
00:34:32,159 --> 00:34:37,760
not be able to change it but it might be

860
00:34:35,119 --> 00:34:41,679
worth checking might be worth

861
00:34:37,760 --> 00:34:45,200
seeing what's there and also

862
00:34:41,679 --> 00:34:47,359
if if ms flt is still registered for the

863
00:34:45,199 --> 00:34:50,480
function by the time your driver is up

864
00:34:47,359 --> 00:34:52,960
probably won't be you can walk

865
00:34:50,480 --> 00:34:53,679
the registered callback registration

866
00:34:52,960 --> 00:34:56,720
structures

867
00:34:53,679 --> 00:35:01,280
to see who's registered receive

868
00:34:56,719 --> 00:35:04,319
the pointer to the callback function

869
00:35:01,280 --> 00:35:06,880
do some simple binary parsing

870
00:35:04,320 --> 00:35:09,200
there it's not a very large function and

871
00:35:06,880 --> 00:35:12,640
find the global which has the pointer

872
00:35:09,200 --> 00:35:13,200
to the patch card to the patch card

873
00:35:12,640 --> 00:35:16,879
function

874
00:35:13,200 --> 00:35:18,640
the patch card um monitoring function

875
00:35:16,880 --> 00:35:21,119
which is fun for some path for some

876
00:35:18,640 --> 00:35:22,720
patch card research

877
00:35:21,119 --> 00:35:24,880
uh if you want to do some patch card

878
00:35:22,720 --> 00:35:28,560
research

879
00:35:24,880 --> 00:35:29,760
um obviously this is this is a very

880
00:35:28,560 --> 00:35:33,119
rough

881
00:35:29,760 --> 00:35:34,880
description of callback objects we only

882
00:35:33,119 --> 00:35:36,640
kind of scrape the surface here

883
00:35:34,880 --> 00:35:37,920
there's a lot more interesting callbacks

884
00:35:36,640 --> 00:35:39,920
to look at

885
00:35:37,920 --> 00:35:41,520
i would look at security products i

886
00:35:39,920 --> 00:35:43,760
would

887
00:35:41,520 --> 00:35:46,160
maybe look at some other third-party

888
00:35:43,760 --> 00:35:47,440
products that might be using them

889
00:35:46,160 --> 00:35:49,200
there is a base for some very

890
00:35:47,440 --> 00:35:51,440
interesting research here that can go in

891
00:35:49,200 --> 00:35:53,839
a lot of different directions

892
00:35:51,440 --> 00:35:54,960
but what doesn't really exist is an easy

893
00:35:53,839 --> 00:35:57,599
way to

894
00:35:54,960 --> 00:35:58,720
investigate callbacks like public tools

895
00:35:57,599 --> 00:36:02,960
or whatever

896
00:35:58,720 --> 00:36:13,279
so let me unshare and

897
00:36:02,960 --> 00:36:17,280
share uh all that i wrote for this

898
00:36:13,280 --> 00:36:22,240
okay so i wrote this

899
00:36:17,280 --> 00:36:25,119
simple tool that analyzes a crash dump

900
00:36:22,240 --> 00:36:26,799
or takes a crash damper of its own or

901
00:36:25,119 --> 00:36:29,920
connects to a kernel debugger

902
00:36:26,800 --> 00:36:33,359
and dumps all the callbacks

903
00:36:29,920 --> 00:36:35,599
and registered functions that are in it

904
00:36:33,359 --> 00:36:36,720
so we'll let it run and while it runs we

905
00:36:35,599 --> 00:36:39,599
can look at things

906
00:36:36,720 --> 00:36:42,720
so the first ones on the list are as

907
00:36:39,599 --> 00:36:46,480
you'd expect the kernel ones

908
00:36:42,720 --> 00:36:47,598
there's enlightenment state set system

909
00:36:46,480 --> 00:36:49,280
time

910
00:36:47,599 --> 00:36:51,359
now here's the power state one we see

911
00:36:49,280 --> 00:36:52,960
it's popular there is

912
00:36:51,359 --> 00:36:55,119
stuff registered here that you'd expect

913
00:36:52,960 --> 00:37:00,560
to see in a power state callback there's

914
00:36:55,119 --> 00:37:00,560
acpi there's hal

915
00:37:00,640 --> 00:37:09,839
there's a lot of other drivers here

916
00:37:02,400 --> 00:37:09,839
registered for that one

917
00:37:10,000 --> 00:37:13,520
now here we start seeing different

918
00:37:12,320 --> 00:37:16,079
callbacks

919
00:37:13,520 --> 00:37:16,079
we see

920
00:37:17,200 --> 00:37:23,439
different here's for example one of the

921
00:37:20,320 --> 00:37:25,680
win32k callbacks we can see that it's

922
00:37:23,440 --> 00:37:26,720
unnamed when 32k uses anonymous

923
00:37:25,680 --> 00:37:30,560
callbacks

924
00:37:26,720 --> 00:37:34,839
for its port signaling

925
00:37:30,560 --> 00:37:37,920
um here's our few who chose the name

926
00:37:34,839 --> 00:37:39,119
null for the callbacks those are i think

927
00:37:37,920 --> 00:37:42,880
my graphic

928
00:37:39,119 --> 00:37:42,880
um my graphics drivers

929
00:37:43,220 --> 00:37:48,560
[Music]

930
00:37:44,800 --> 00:37:50,560
here's the dam driver which always has

931
00:37:48,560 --> 00:37:53,839
some interesting stuff

932
00:37:50,560 --> 00:37:55,200
in this on this machine i don't have

933
00:37:53,839 --> 00:38:00,799
windows defender running

934
00:37:55,200 --> 00:38:02,560
so we won't see so we won't see that

935
00:38:00,800 --> 00:38:04,000
and just because we have a couple more

936
00:38:02,560 --> 00:38:06,560
minutes i'll show

937
00:38:04,000 --> 00:38:08,630
how we can also dump callbacks with

938
00:38:06,560 --> 00:38:13,009
windbag but only named ones

939
00:38:08,630 --> 00:38:13,010
[Music]

940
00:38:16,880 --> 00:38:22,320
so simple we run bank object

941
00:38:27,599 --> 00:38:32,800
and give it a minute because always a

942
00:38:30,960 --> 00:38:36,160
bit slow

943
00:38:32,800 --> 00:38:41,040
uh internally it just looks for

944
00:38:36,160 --> 00:38:43,279
all objects that have that part of the

945
00:38:41,040 --> 00:38:44,320
that have slash callback as part of the

946
00:38:43,280 --> 00:38:48,560
name

947
00:38:44,320 --> 00:38:48,560
now while it's running right

948
00:38:52,960 --> 00:38:56,880
never remember if it's one or two so

949
00:38:55,200 --> 00:39:01,839
while we're letting it run

950
00:38:56,880 --> 00:39:01,839
uh anyone has any questions

951
00:39:10,240 --> 00:39:14,000
so we don't have any questions yet uh

952
00:39:13,520 --> 00:39:16,079
i'm afraid

953
00:39:14,000 --> 00:39:17,839
jardin i think uh i think you've blown

954
00:39:16,079 --> 00:39:20,240
them away with your

955
00:39:17,839 --> 00:39:21,520
technical expertise and um you need some

956
00:39:20,240 --> 00:39:23,520
time to process

957
00:39:21,520 --> 00:39:24,640
exactly exactly and i can tell you as an

958
00:39:23,520 --> 00:39:26,640
ex-ciso

959
00:39:24,640 --> 00:39:28,000
one of the great advantages of being a

960
00:39:26,640 --> 00:39:29,759
cso is you get this

961
00:39:28,000 --> 00:39:32,079
very high level view of everything

962
00:39:29,760 --> 00:39:33,520
that's going on security wise in the

963
00:39:32,079 --> 00:39:35,920
organization

964
00:39:33,520 --> 00:39:37,040
the downside of being an ex of being a

965
00:39:35,920 --> 00:39:38,800
cso is this with this

966
00:39:37,040 --> 00:39:40,160
very high level view of the organization

967
00:39:38,800 --> 00:39:40,960
i didn't understand a word of what you

968
00:39:40,160 --> 00:39:44,000
just said

969
00:39:40,960 --> 00:39:46,160
but but i do know

970
00:39:44,000 --> 00:39:48,000
i do know that there are many many

971
00:39:46,160 --> 00:39:50,399
people in the audience who

972
00:39:48,000 --> 00:39:51,440
will have found this incredibly useful

973
00:39:50,400 --> 00:39:54,320
um

974
00:39:51,440 --> 00:39:56,079
and folks if um if you're still

975
00:39:54,320 --> 00:39:58,800
processing not quite ready to

976
00:39:56,079 --> 00:40:00,400
ask yarden a question just yet you can

977
00:39:58,800 --> 00:40:02,800
still use the slack channels

978
00:40:00,400 --> 00:40:03,760
um yard and you'll be on slack available

979
00:40:02,800 --> 00:40:06,319
to ask any

980
00:40:03,760 --> 00:40:07,280
answer any questions that sent your way

981
00:40:06,319 --> 00:40:10,560
please

982
00:40:07,280 --> 00:40:14,000
continue the conversation uh afterwards

983
00:40:10,560 --> 00:40:14,480
um uh having someone like yardan with

984
00:40:14,000 --> 00:40:17,040
such

985
00:40:14,480 --> 00:40:17,680
a deep level of technical expertise here

986
00:40:17,040 --> 00:40:20,000
is

987
00:40:17,680 --> 00:40:21,680
invaluable to you please take full

988
00:40:20,000 --> 00:40:24,720
advantage

989
00:40:21,680 --> 00:40:27,839
and um really really

990
00:40:24,720 --> 00:40:31,118
uh um you know make the most of it

991
00:40:27,839 --> 00:40:32,720
uh let me just check time we do have uh

992
00:40:31,119 --> 00:40:34,480
a couple of questions now typically

993
00:40:32,720 --> 00:40:36,799
they've literally just appeared

994
00:40:34,480 --> 00:40:38,000
um so let me just check to see do we

995
00:40:36,800 --> 00:40:41,040
have time

996
00:40:38,000 --> 00:40:42,240
we've got four minutes to answer

997
00:40:41,040 --> 00:40:44,880
questions

998
00:40:42,240 --> 00:40:45,359
so let me yes thank you for getting the

999
00:40:44,880 --> 00:40:46,720
photo

1000
00:40:45,359 --> 00:40:48,640
do you have any interesting structures

1001
00:40:46,720 --> 00:40:50,720
in the object context that you've seen

1002
00:40:48,640 --> 00:40:52,560
yeah i'm assuming you mean the callback

1003
00:40:50,720 --> 00:40:56,160
context there um

1004
00:40:52,560 --> 00:40:59,520
so yes if i'll

1005
00:40:56,160 --> 00:41:00,160
sec i'll reshare the output of the tool

1006
00:40:59,520 --> 00:41:02,800
i wrote

1007
00:41:00,160 --> 00:41:06,078
i'm going to it's on github i'm going to

1008
00:41:02,800 --> 00:41:09,440
publish it later

1009
00:41:06,079 --> 00:41:12,800
um and i'll send the link okay so

1010
00:41:09,440 --> 00:41:14,720
yeah we have your text out here

1011
00:41:12,800 --> 00:41:16,400
yeah we have the callback context output

1012
00:41:14,720 --> 00:41:19,279
here you can use it to see

1013
00:41:16,400 --> 00:41:21,440
which functions have initialized a

1014
00:41:19,280 --> 00:41:27,200
callback context and which one's

1015
00:41:21,440 --> 00:41:30,880
not um like here we see that dom doesn't

1016
00:41:27,200 --> 00:41:33,520
and one specific one

1017
00:41:30,880 --> 00:41:34,000
that i know if you're interested in

1018
00:41:33,520 --> 00:41:36,319
graphics

1019
00:41:34,000 --> 00:41:38,480
drivers almost all the graphics and

1020
00:41:36,319 --> 00:41:40,079
audio drivers do use a callback context

1021
00:41:38,480 --> 00:41:41,599
so there are probably some interesting

1022
00:41:40,079 --> 00:41:43,119
stuff there they're all pointing to very

1023
00:41:41,599 --> 00:41:46,560
large structures

1024
00:41:43,119 --> 00:41:49,680
and the windows defender driver

1025
00:41:46,560 --> 00:41:52,078
uses a callback context for all of its

1026
00:41:49,680 --> 00:41:54,078
callbacks and that points to the

1027
00:41:52,079 --> 00:41:57,119
internal windows defender

1028
00:41:54,079 --> 00:41:59,040
global data structure that always has

1029
00:41:57,119 --> 00:42:02,240
interesting information of

1030
00:41:59,040 --> 00:42:03,839
all sorts of kinds depends on exactly

1031
00:42:02,240 --> 00:42:07,118
what you're interested in but you're

1032
00:42:03,839 --> 00:42:07,119
probably going to find it there

1033
00:42:07,280 --> 00:42:11,119
okay excellent and i think we do have

1034
00:42:10,160 --> 00:42:13,440
time for this

1035
00:42:11,119 --> 00:42:15,359
second question what should you look for

1036
00:42:13,440 --> 00:42:18,800
when window defender is

1037
00:42:15,359 --> 00:42:21,598
stuff and admin cannot start it anymore

1038
00:42:18,800 --> 00:42:22,319
i'm not really sure what the question

1039
00:42:21,599 --> 00:42:24,880
here is

1040
00:42:22,319 --> 00:42:25,599
uh when windows defender is stopped

1041
00:42:24,880 --> 00:42:31,839
maybe

1042
00:42:25,599 --> 00:42:31,839
uh an admin i'm not sure

1043
00:42:36,800 --> 00:42:41,680
windows defender technical support i

1044
00:42:39,040 --> 00:42:41,680
don't really do

1045
00:42:42,160 --> 00:42:49,279
okay and in which case

1046
00:42:45,200 --> 00:42:50,799
let's go on to this final question

1047
00:42:49,280 --> 00:42:52,400
uh what is the difference in the image

1048
00:42:50,800 --> 00:42:55,119
loader callback object and the regular

1049
00:42:52,400 --> 00:42:56,880
load image notify routine

1050
00:42:55,119 --> 00:42:58,400
uh there's actually no image loader

1051
00:42:56,880 --> 00:43:00,880
callback object

1052
00:42:58,400 --> 00:43:02,160
the image load the load image notify

1053
00:43:00,880 --> 00:43:04,400
routine

1054
00:43:02,160 --> 00:43:06,640
is the legacy callback that notifies

1055
00:43:04,400 --> 00:43:08,400
about newly loaded image as far as i

1056
00:43:06,640 --> 00:43:10,480
know there is no image loader callback

1057
00:43:08,400 --> 00:43:12,880
object

1058
00:43:10,480 --> 00:43:14,480
if you mean the image verification

1059
00:43:12,880 --> 00:43:16,000
information the difference is that the

1060
00:43:14,480 --> 00:43:20,160
image verification callback

1061
00:43:16,000 --> 00:43:22,319
is only for kernel mode images

1062
00:43:20,160 --> 00:43:23,359
it only notifies about drivers and it

1063
00:43:22,319 --> 00:43:25,599
supplies

1064
00:43:23,359 --> 00:43:27,200
information that's actually a public one

1065
00:43:25,599 --> 00:43:29,119
all the structures are public because

1066
00:43:27,200 --> 00:43:32,000
it's meant to be used by edr

1067
00:43:29,119 --> 00:43:33,040
software and that gives you information

1068
00:43:32,000 --> 00:43:37,200
for example about

1069
00:43:33,040 --> 00:43:39,359
the who signed the image

1070
00:43:37,200 --> 00:43:40,720
uh it gives you it gives you some

1071
00:43:39,359 --> 00:43:43,119
information that you don't

1072
00:43:40,720 --> 00:43:44,560
get from the load image notification but

1073
00:43:43,119 --> 00:43:47,200
they're used for separate

1074
00:43:44,560 --> 00:43:48,880
purposes because one is only for kernel

1075
00:43:47,200 --> 00:43:52,480
mode images and image load

1076
00:43:48,880 --> 00:43:56,240
and the legacy image load notify routine

1077
00:43:52,480 --> 00:43:56,240
is for both kernel and user mode

1078
00:43:56,720 --> 00:44:00,000
i hope that answers your question uh

1079
00:43:59,359 --> 00:44:02,000
yarden

1080
00:44:00,000 --> 00:44:03,839
thank you very much one of the huge

1081
00:44:02,000 --> 00:44:05,440
downsides of a virtual event is that you

1082
00:44:03,839 --> 00:44:08,480
don't get a round of applause at the end

1083
00:44:05,440 --> 00:44:11,839
so please take mine

1084
00:44:08,480 --> 00:44:13,920
or your presentation um the

1085
00:44:11,839 --> 00:44:15,759
um please hang around on the slack

1086
00:44:13,920 --> 00:44:18,400
channels afterwards folks please

1087
00:44:15,760 --> 00:44:20,839
um ask questions there yard and you'll

1088
00:44:18,400 --> 00:44:22,560
be posting links to the github that you

1089
00:44:20,839 --> 00:44:25,359
mentioned yes i'll be

1090
00:44:22,560 --> 00:44:27,599
i'll be posting it there um and on

1091
00:44:25,359 --> 00:44:28,160
twitter and even after a slack channel

1092
00:44:27,599 --> 00:44:30,800
is not

1093
00:44:28,160 --> 00:44:31,359
relevant it's easy to find me feel free

1094
00:44:30,800 --> 00:44:33,839
to ask

1095
00:44:31,359 --> 00:44:35,598
questions if you think of any later

1096
00:44:33,839 --> 00:44:36,720
fantastic do you have a twitter handle

1097
00:44:35,599 --> 00:44:37,040
or anything that people should know

1098
00:44:36,720 --> 00:44:39,439
about

1099
00:44:37,040 --> 00:44:41,839
i do it's you then sofia the same name

1100
00:44:39,440 --> 00:44:46,400
that's on the slide so very easy to find

1101
00:44:41,839 --> 00:44:46,400
okay excellent yarden thank you very

1102
00:44:47,640 --> 00:44:50,640
much

