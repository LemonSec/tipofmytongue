1
00:00:00,000 --> 00:00:06,720
the<font color="#CCCCCC"> b-sides DC 2016 videos are brought</font>

2
00:00:03,240 --> 00:00:10,129
to you by clear jobs net and cyber sex

3
00:00:06,720 --> 00:00:12,899
<font color="#E5E5E5">calm tools for your next career move and</font>

4
00:00:10,130 --> 00:00:15,299
Antietam technologies focusing on

5
00:00:12,900 --> 00:00:18,510
advanced cyber detection analysis and

6
00:00:15,299 --> 00:00:21,090
mitigation<font color="#E5E5E5"> okay so this is tales of</font>

7
00:00:18,510 --> 00:00:23,130
fails and tools for message integrity so

8
00:00:21,090 --> 00:00:25,230
I'm Jacob Thompson I work for

9
00:00:23,130 --> 00:00:27,419
independent security evaluators for a

10
00:00:25,230 --> 00:00:30,029
security evaluation and consulting

11
00:00:27,420 --> 00:00:34,170
company located in Baltimore so we're

12
00:00:30,029 --> 00:00:35,730
local a quick commercial break so our

13
00:00:34,170 --> 00:00:38,340
company were composed of computer

14
00:00:35,730 --> 00:00:40,319
science academics ethical hackers we do

15
00:00:38,340 --> 00:00:42,750
all sorts of white box style security

16
00:00:40,320 --> 00:00:44,820
evaluations for our customers<font color="#CCCCCC"> so very</font>

17
00:00:42,750 --> 00:00:47,670
much<font color="#CCCCCC"> in attackers mindset and so forth</font>

18
00:00:44,820 --> 00:00:49,170
trying<font color="#E5E5E5"> to look at a product and tell</font>

19
00:00:47,670 --> 00:00:52,879
them where the problems are and<font color="#E5E5E5"> how to</font>

20
00:00:49,170 --> 00:00:55,770
fix them and<font color="#E5E5E5"> so forth back to the talk</font>

21
00:00:52,879 --> 00:00:58,019
so thinking about message integrity in

22
00:00:55,770 --> 00:00:59,670
terms of cryptography so personally I

23
00:00:58,020 --> 00:01:02,699
think there's much more<font color="#E5E5E5"> of a focus on</font>

24
00:00:59,670 --> 00:01:05,790
confidentiality so AES and so forth in

25
00:01:02,699 --> 00:01:08,399
the terms of say enthusiasm but actually

26
00:01:05,790 --> 00:01:10,979
integrity is just as important and by

27
00:01:08,400 --> 00:01:13,290
integrity I'm talking about two ways one

28
00:01:10,979 --> 00:01:15,270
<font color="#CCCCCC">of them would be modification of data</font>

29
00:01:13,290 --> 00:01:17,310
while it's at rest sitting on a disk

30
00:01:15,270 --> 00:01:19,740
somewhere or in transit like<font color="#E5E5E5"> over a</font>

31
00:01:17,310 --> 00:01:22,380
network and passwords would be the

32
00:01:19,740 --> 00:01:24,960
second example it's important<font color="#E5E5E5"> to note</font>

33
00:01:22,380 --> 00:01:27,330
though that in many cryptographic

34
00:01:24,960 --> 00:01:28,979
protocols the ability to modify a

35
00:01:27,330 --> 00:01:30,860
message or tamper with a message<font color="#E5E5E5"> can</font>

36
00:01:28,979 --> 00:01:35,270
also lead to<font color="#E5E5E5"> the loss of confidentiality</font>

37
00:01:30,860 --> 00:01:38,430
so<font color="#E5E5E5"> I've often especially earlier in my</font>

38
00:01:35,270 --> 00:01:40,890
progression as a security<font color="#E5E5E5"> person in the</font>

39
00:01:38,430 --> 00:01:43,079
scoping and attack surface recognition

40
00:01:40,890 --> 00:01:45,600
part of an assessment they<font color="#E5E5E5"> talk about we</font>

41
00:01:43,079 --> 00:01:46,979
use such and such a es for this and they

42
00:01:45,600 --> 00:01:49,350
didn't have anything in for integrity

43
00:01:46,979 --> 00:01:50,880
and I have a habit of saying well like

44
00:01:49,350 --> 00:01:52,500
how likely is it that anybody will

45
00:01:50,880 --> 00:01:54,960
tamper<font color="#E5E5E5"> with out anyway but it can be</font>

46
00:01:52,500 --> 00:01:56,969
very important and I<font color="#CCCCCC"> think it's also</font>

47
00:01:54,960 --> 00:01:59,158
more nuanced and interesting than

48
00:01:56,969 --> 00:02:03,210
confidentiality sometimes just<font color="#E5E5E5"> because a</font>

49
00:01:59,159 --> 00:02:06,090
lot of<font color="#E5E5E5"> the problems are not as close to</font>

50
00:02:03,210 --> 00:02:08,639
being one<font color="#CCCCCC"> hundred percent solved as they</font>

51
00:02:06,090 --> 00:02:11,190
it might be in symmetric encryption and

52
00:02:08,639 --> 00:02:12,929
so forth or at least<font color="#E5E5E5"> to a degree so the</font>

53
00:02:11,190 --> 00:02:13,500
approach I'm going to take is on I'm

54
00:02:12,930 --> 00:02:15,930
going<font color="#E5E5E5"> to go</font>

55
00:02:13,500 --> 00:02:18,030
a tour of a lot of past vulnerabilities

56
00:02:15,930 --> 00:02:20,520
past exploits and various projects<font color="#E5E5E5"> and</font>

57
00:02:18,030 --> 00:02:21,960
the attack methodology behind them<font color="#CCCCCC"> so</font>

58
00:02:20,520 --> 00:02:24,240
that<font color="#E5E5E5"> you can kind of see</font><font color="#CCCCCC"> the ways in</font>

59
00:02:21,960 --> 00:02:27,030
which integrity checking often fails and

60
00:02:24,240 --> 00:02:29,160
then I'll close out with a review of

61
00:02:27,030 --> 00:02:31,320
best practices so if your security

62
00:02:29,160 --> 00:02:33,750
analysts also you'll<font color="#CCCCCC"> have some things to</font>

63
00:02:31,320 --> 00:02:35,970
<font color="#CCCCCC">think about as you do assessment so</font>

64
00:02:33,750 --> 00:02:38,700
we'll take<font color="#CCCCCC"> a look at fails so common</font>

65
00:02:35,970 --> 00:02:41,070
ways in which puts a programmers or

66
00:02:38,700 --> 00:02:44,100
architects fail when they're designing a

67
00:02:41,070 --> 00:02:46,440
system so I would<font color="#E5E5E5"> say one of</font><font color="#CCCCCC"> the most</font>

68
00:02:44,100 --> 00:02:48,780
common is assuming that encryption of

69
00:02:46,440 --> 00:02:52,920
data also protects it from being

70
00:02:48,780 --> 00:02:55,220
modified if not well then good enough so

71
00:02:52,920 --> 00:02:58,649
first example and<font color="#E5E5E5"> this is the</font><font color="#CCCCCC"> worst-case</font>

72
00:02:55,220 --> 00:03:00,630
<font color="#E5E5E5">stream ciphers and malleability so</font>

73
00:02:58,650 --> 00:03:05,130
remembering what a stream cipher is a

74
00:03:00,630 --> 00:03:06,660
one-time pad right<font color="#CCCCCC"> rc4 basically you</font>

75
00:03:05,130 --> 00:03:08,400
have a key stream and you have plain

76
00:03:06,660 --> 00:03:10,890
text and you XOR them together and<font color="#E5E5E5"> you</font>

77
00:03:08,400 --> 00:03:13,200
get<font color="#CCCCCC"> cipher text just as I Show on here</font>

78
00:03:10,890 --> 00:03:15,269
so hello world take the ASCII values you

79
00:03:13,200 --> 00:03:16,950
have a key stream you get data so just

80
00:03:15,270 --> 00:03:20,420
like a one-time pad right or it could be

81
00:03:16,950 --> 00:03:23,609
<font color="#CCCCCC">something a PR ng generating key stream</font>

82
00:03:20,420 --> 00:03:26,100
decryption is just the opposite so

83
00:03:23,610 --> 00:03:28,320
biggest thing<font color="#CCCCCC"> to notice</font><font color="#E5E5E5"> encryption and</font>

84
00:03:26,100 --> 00:03:30,840
decryption of the same operation they

85
00:03:28,320 --> 00:03:32,340
cancel<font color="#E5E5E5"> out so if you encrypt it twice</font>

86
00:03:30,840 --> 00:03:37,799
with the same key it's not twice as

87
00:03:32,340 --> 00:03:39,630
secure looking at how decryption happens

88
00:03:37,799 --> 00:03:41,370
if the if we've tampered with this

89
00:03:39,630 --> 00:03:46,170
message in some way the important thing

90
00:03:41,370 --> 00:03:48,840
to<font color="#CCCCCC"> note is flip a bit in the ciphertext</font>

91
00:03:46,170 --> 00:03:50,790
the same exact bit gets flipped in the

92
00:03:48,840 --> 00:03:52,560
<font color="#E5E5E5">plaintext after it gets decrypted so</font>

93
00:03:50,790 --> 00:03:55,620
this<font color="#CCCCCC"> is called malleability it affects</font>

94
00:03:52,560 --> 00:03:56,880
every stream cipher so in a way<font color="#CCCCCC"> one-time</font>

95
00:03:55,620 --> 00:03:58,470
pad might be the<font color="#E5E5E5"> best for</font>

96
00:03:56,880 --> 00:04:00,630
confidentiality it's the worst<font color="#E5E5E5"> for</font>

97
00:03:58,470 --> 00:04:03,930
integrity unless you<font color="#E5E5E5"> have something else</font>

98
00:04:00,630 --> 00:04:05,910
in place to protect that so seeing that

99
00:04:03,930 --> 00:04:08,700
<font color="#E5E5E5">let's take a look at some ways in this</font>

100
00:04:05,910 --> 00:04:11,450
in which this might actually fail in a

101
00:04:08,700 --> 00:04:13,890
real system so<font color="#E5E5E5"> I made an example here</font>

102
00:04:11,450 --> 00:04:15,839
everybody knows about client side

103
00:04:13,890 --> 00:04:17,880
session management kind of being all the

104
00:04:15,840 --> 00:04:20,040
rage right now so you<font color="#CCCCCC"> have</font><font color="#E5E5E5"> these restful</font>

105
00:04:17,880 --> 00:04:21,779
api s and load balancers and you get a

106
00:04:20,040 --> 00:04:23,760
different server with every request and

107
00:04:21,779 --> 00:04:25,650
so forth so a lot of developers have

108
00:04:23,760 --> 00:04:26,490
this idea<font color="#E5E5E5"> let's just store the session</font>

109
00:04:25,650 --> 00:04:28,409
data in the

110
00:04:26,490 --> 00:04:30,539
cookie rather than having the cookie

111
00:04:28,410 --> 00:04:34,169
refer to it right so you do<font color="#E5E5E5"> something</font>

112
00:04:30,539 --> 00:04:35,940
<font color="#E5E5E5">like</font><font color="#CCCCCC"> that so</font><font color="#E5E5E5"> I made a small web</font>

113
00:04:34,169 --> 00:04:38,669
application you<font color="#E5E5E5"> have a session cookie</font>

114
00:04:35,940 --> 00:04:41,910
<font color="#E5E5E5">it's some encrypted and base64 encoded</font>

115
00:04:38,669 --> 00:04:43,440
string right<font color="#CCCCCC"> I formatted it so that the</font>

116
00:04:41,910 --> 00:04:45,599
<font color="#E5E5E5">layout of that cookie is an</font>

117
00:04:43,440 --> 00:04:48,690
initialization vector concatenated with

118
00:04:45,599 --> 00:04:51,030
cipher text that was encrypted in aes

119
00:04:48,690 --> 00:04:52,949
counter mode so counter mode just

120
00:04:51,030 --> 00:04:55,049
recalling turns a block cipher into a

121
00:04:52,949 --> 00:04:57,479
stream cipher so it is<font color="#E5E5E5"> also affected by</font>

122
00:04:55,050 --> 00:04:59,870
these problems looking at the plain text

123
00:04:57,479 --> 00:05:04,080
<font color="#E5E5E5">format of that cookie its JSON data</font>

124
00:04:59,870 --> 00:05:05,940
username is admin and a<font color="#E5E5E5"> timestamp so the</font>

125
00:05:04,080 --> 00:05:07,889
question<font color="#CCCCCC"> is using what we just</font><font color="#E5E5E5"> looked at</font>

126
00:05:05,940 --> 00:05:10,440
about malleability could we flip is

127
00:05:07,889 --> 00:05:16,169
admin<font color="#CCCCCC"> 0</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> 1 without knowing the key</font>

128
00:05:10,440 --> 00:05:18,000
right so looking more closely at the

129
00:05:16,169 --> 00:05:20,280
actual positions and layout of<font color="#CCCCCC"> the</font>

130
00:05:18,000 --> 00:05:22,949
cookie you<font color="#CCCCCC"> may not know what the key is</font>

131
00:05:20,280 --> 00:05:25,440
but if you have known plaintext you can

132
00:05:22,949 --> 00:05:28,139
determine the position of<font color="#E5E5E5"> the bit where</font>

133
00:05:25,440 --> 00:05:30,659
the<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> ascii value could be flipped to</font>

134
00:05:28,139 --> 00:05:33,840
become a<font color="#CCCCCC"> 1 and we do just</font><font color="#E5E5E5"> that so look</font>

135
00:05:30,659 --> 00:05:37,250
down at<font color="#E5E5E5"> that is admin 0 line and we can</font>

136
00:05:33,840 --> 00:05:40,320
flip the ciphertext bite 40 to 41

137
00:05:37,250 --> 00:05:42,110
knowing<font color="#CCCCCC"> that from the ASCII values of 0</font>

138
00:05:40,320 --> 00:05:46,500
<font color="#E5E5E5">and one that causes it to become a one</font>

139
00:05:42,110 --> 00:05:48,419
does that work of course so taking a

140
00:05:46,500 --> 00:05:51,060
normal request to our fake web

141
00:05:48,419 --> 00:05:53,400
application we get you are not an admin

142
00:05:51,060 --> 00:05:55,830
and presumably it won't<font color="#E5E5E5"> let</font><font color="#CCCCCC"> you do non</font>

143
00:05:53,400 --> 00:05:58,169
administrative things if we tamper with

144
00:05:55,830 --> 00:06:00,508
that cookie and<font color="#CCCCCC"> then read base64 encode</font>

145
00:05:58,169 --> 00:06:03,210
it send it to the server again we get

146
00:06:00,509 --> 00:06:06,569
exact same request except now we are an

147
00:06:03,210 --> 00:06:09,539
administrator so encryption doesn't

148
00:06:06,569 --> 00:06:12,419
protect the integrity if you have a

149
00:06:09,539 --> 00:06:14,099
chance to quickly copy down the URL if

150
00:06:12,419 --> 00:06:16,530
you're interested basically demo dot

151
00:06:14,099 --> 00:06:18,330
security evaluators calm / integrity /

152
00:06:16,530 --> 00:06:21,869
street and then we'll<font color="#E5E5E5"> take a look at</font>

153
00:06:18,330 --> 00:06:24,000
another example so everybody knows<font color="#CCCCCC"> that</font>

154
00:06:21,870 --> 00:06:26,250
<font color="#E5E5E5">about stream ciphers in many cases but</font>

155
00:06:24,000 --> 00:06:30,750
also block ciphers can also be affected

156
00:06:26,250 --> 00:06:32,759
by tampering so CBC mode cipher block

157
00:06:30,750 --> 00:06:35,669
chaining is one of the more common and

158
00:06:32,759 --> 00:06:37,889
easy to do correctly modes of encryption

159
00:06:35,669 --> 00:06:39,630
so it's often recommended is like if you

160
00:06:37,889 --> 00:06:40,270
have to implement it yourself maybe do

161
00:06:39,630 --> 00:06:43,960
this

162
00:06:40,270 --> 00:06:46,719
in terms of a formula you have a<font color="#E5E5E5"> special</font>

163
00:06:43,960 --> 00:06:49,630
first<font color="#E5E5E5"> block called the</font><font color="#CCCCCC"> IV and then you</font>

164
00:06:46,720 --> 00:06:51,490
have encrypted blocks of plaintext where

165
00:06:49,630 --> 00:06:53,350
during the encryption process you add

166
00:06:51,490 --> 00:06:56,230
this kind<font color="#E5E5E5"> of noise term which is the</font>

167
00:06:53,350 --> 00:06:59,020
previous cipher block cipher text block

168
00:06:56,230 --> 00:07:00,850
into the encryption and then because

169
00:06:59,020 --> 00:07:03,520
it's a block cipher you can only encrypt

170
00:07:00,850 --> 00:07:05,140
in multiples of the block size you might

171
00:07:03,520 --> 00:07:07,060
have padding at the end which<font color="#E5E5E5"> I've added</font>

172
00:07:05,140 --> 00:07:09,490
in this case as well so this<font color="#E5E5E5"> might be</font><font color="#CCCCCC"> a</font>

173
00:07:07,060 --> 00:07:12,130
typical block cipher encryption of<font color="#CCCCCC"> the</font>

174
00:07:09,490 --> 00:07:15,970
string hello hello world three times<font color="#E5E5E5"> in</font>

175
00:07:12,130 --> 00:07:19,330
the<font color="#CCCCCC"> plaintext decryption is the opposite</font>

176
00:07:15,970 --> 00:07:23,920
process except your IV and padding will

177
00:07:19,330 --> 00:07:27,070
be thrown away now in stream ciphers if

178
00:07:23,920 --> 00:07:29,230
we make some change to the ciphertext it

179
00:07:27,070 --> 00:07:30,490
made<font color="#E5E5E5"> the same change in the plaintext</font>

180
00:07:29,230 --> 00:07:33,490
right it was very easy to make

181
00:07:30,490 --> 00:07:35,800
modifications<font color="#CCCCCC"> oftentimes</font><font color="#E5E5E5"> because of what</font>

182
00:07:33,490 --> 00:07:38,380
is<font color="#E5E5E5"> called the Avalanche property if you</font>

183
00:07:35,800 --> 00:07:40,360
take within<font color="#E5E5E5"> one unit of ciphertext in a</font>

184
00:07:38,380 --> 00:07:42,490
block you<font color="#CCCCCC"> flip a bit you have</font><font color="#E5E5E5"> zero</font>

185
00:07:40,360 --> 00:07:46,270
control over what will happen to that

186
00:07:42,490 --> 00:07:48,370
<font color="#E5E5E5">block when it decrypts but take a look</font>

187
00:07:46,270 --> 00:07:52,080
at<font color="#E5E5E5"> what happens in CBC mode let's flip</font>

188
00:07:48,370 --> 00:07:56,050
that six a bite on<font color="#E5E5E5"> the second line to 7a</font>

189
00:07:52,080 --> 00:07:57,580
all right that block that<font color="#CCCCCC"> D</font><font color="#E5E5E5"> Crips when</font>

190
00:07:56,050 --> 00:07:59,170
that block decrypt you get noise right

191
00:07:57,580 --> 00:08:01,659
at some random data because of that

192
00:07:59,170 --> 00:08:05,650
<font color="#E5E5E5">Avalanche property however</font><font color="#CCCCCC"> because of</font>

193
00:08:01,660 --> 00:08:08,770
how CBC mode operates that cipher text

194
00:08:05,650 --> 00:08:10,960
will be that X or will happen and notice

195
00:08:08,770 --> 00:08:13,240
we<font color="#CCCCCC"> have a very controllable modification</font>

196
00:08:10,960 --> 00:08:15,400
to the next block where we changed some

197
00:08:13,240 --> 00:08:17,770
<font color="#CCCCCC">ASCII</font><font color="#E5E5E5"> value so that instead of an X or a</font>

198
00:08:15,400 --> 00:08:19,929
set of an H we got an X so that<font color="#E5E5E5"> could be</font>

199
00:08:17,770 --> 00:08:21,880
a problem now if whatever<font color="#E5E5E5"> application</font>

200
00:08:19,930 --> 00:08:24,520
you're working with<font color="#CCCCCC"> is very rigid about</font>

201
00:08:21,880 --> 00:08:26,890
its data format this<font color="#E5E5E5"> is probably not</font>

202
00:08:24,520 --> 00:08:29,830
<font color="#E5E5E5">going to work if it's some special case</font>

203
00:08:26,890 --> 00:08:32,549
maybe it will another thing we can do in

204
00:08:29,830 --> 00:08:36,880
CBC mode is a cut-and-paste attack where

205
00:08:32,549 --> 00:08:39,069
because a block can be moved<font color="#CCCCCC"> around as</font>

206
00:08:36,880 --> 00:08:41,080
long as the block before it is correct

207
00:08:39,070 --> 00:08:43,720
<font color="#E5E5E5">it will still decrypt the same thing so</font>

208
00:08:41,080 --> 00:08:46,660
let's<font color="#E5E5E5"> look at another made-up example to</font>

209
00:08:43,720 --> 00:08:50,590
demonstrate that so here I've made a

210
00:08:46,660 --> 00:08:53,380
<font color="#CCCCCC">python program that is kind of</font><font color="#E5E5E5"> a very</font>

211
00:08:50,590 --> 00:08:54,130
<font color="#CCCCCC">boil</font><font color="#E5E5E5"> down demonstration of something</font>

212
00:08:53,380 --> 00:08:57,189
that<font color="#CCCCCC"> might be doing</font>

213
00:08:54,130 --> 00:08:59,200
so it starts<font color="#CCCCCC"> it takes</font><font color="#E5E5E5"> one command line</font>

214
00:08:57,190 --> 00:09:01,090
argument pointing to some directory it

215
00:08:59,200 --> 00:09:02,650
does some kind of sanity check and if

216
00:09:01,090 --> 00:09:05,680
that check passes it does something

217
00:09:02,650 --> 00:09:08,050
dangerous maybe RM dash RF / have it for

218
00:09:05,680 --> 00:09:10,060
real or maybe it does a backup or

219
00:09:08,050 --> 00:09:12,520
<font color="#E5E5E5">something right or upgrades a package</font>

220
00:09:10,060 --> 00:09:14,109
but<font color="#E5E5E5"> I've made this this is actually made</font>

221
00:09:12,520 --> 00:09:16,000
in a very specific format for

222
00:09:14,110 --> 00:09:18,480
convenience so that all the boundaries

223
00:09:16,000 --> 00:09:21,490
between<font color="#E5E5E5"> cbc blocks will line up right</font>

224
00:09:18,480 --> 00:09:23,380
but the core of<font color="#E5E5E5"> this is this if</font>

225
00:09:21,490 --> 00:09:26,710
statement at the bottom if we focus in

226
00:09:23,380 --> 00:09:29,770
on that then for<font color="#E5E5E5"> demonstration purposes</font>

227
00:09:26,710 --> 00:09:31,780
the sanity check is always true so if

228
00:09:29,770 --> 00:09:34,930
true don't actually do the operation

229
00:09:31,780 --> 00:09:38,199
else do it so our question is knowing

230
00:09:34,930 --> 00:09:40,270
what we've learned about<font color="#CCCCCC"> CBC given only</font>

231
00:09:38,200 --> 00:09:42,850
an encrypted copy of the script and no

232
00:09:40,270 --> 00:09:45,480
key is there a way to modify it so that

233
00:09:42,850 --> 00:09:48,280
the<font color="#E5E5E5"> else block execute instead of the if</font>

234
00:09:45,480 --> 00:09:50,200
so you know what the script has<font color="#E5E5E5"> inside</font>

235
00:09:48,280 --> 00:09:52,000
it and you have an encrypted copy you

236
00:09:50,200 --> 00:09:53,590
don't have the key so<font color="#E5E5E5"> you can't do the</font>

237
00:09:52,000 --> 00:09:56,440
straightforward modify it and be

238
00:09:53,590 --> 00:10:00,520
encrypted well if we actually break that

239
00:09:56,440 --> 00:10:04,710
script into blocks then we notice<font color="#CCCCCC"> that</font>

240
00:10:00,520 --> 00:10:07,780
what is a triple quote string in Python

241
00:10:04,710 --> 00:10:10,330
multi-line string literal right so this

242
00:10:07,780 --> 00:10:13,300
<font color="#E5E5E5">is in such a way that what if we could</font>

243
00:10:10,330 --> 00:10:15,700
take this multi-line string literal have

244
00:10:13,300 --> 00:10:17,050
it not end where it does and move the

245
00:10:15,700 --> 00:10:20,440
end of that string to somewhere below

246
00:10:17,050 --> 00:10:22,420
the code we don't want to run right so<font color="#E5E5E5"> I</font>

247
00:10:20,440 --> 00:10:25,060
have abbreviated<font color="#E5E5E5"> it some but you see</font>

248
00:10:22,420 --> 00:10:27,729
that else block has an if above it if

249
00:10:25,060 --> 00:10:29,500
that if is no longer in the syntax of

250
00:10:27,730 --> 00:10:31,090
the program the<font color="#CCCCCC"> else will instead be</font>

251
00:10:29,500 --> 00:10:34,300
paired with<font color="#CCCCCC"> the one at</font><font color="#E5E5E5"> the beginning and</font>

252
00:10:31,090 --> 00:10:37,840
will run because the command line check

253
00:10:34,300 --> 00:10:39,609
would succeed so what about CBC mode can

254
00:10:37,840 --> 00:10:41,200
we do we<font color="#CCCCCC"> can move blocks around so let's</font>

255
00:10:39,610 --> 00:10:44,230
<font color="#E5E5E5">take a look at</font><font color="#CCCCCC"> what happens to the plain</font>

256
00:10:41,200 --> 00:10:45,670
text when<font color="#CCCCCC"> we do actual working</font>

257
00:10:44,230 --> 00:10:49,060
implementation of that that<font color="#E5E5E5"> I'll show</font>

258
00:10:45,670 --> 00:10:52,150
briefly afterward so suppose we look<font color="#E5E5E5"> at</font>

259
00:10:49,060 --> 00:10:55,000
the script and we do three things so in

260
00:10:52,150 --> 00:10:56,800
that usage statement it used to say if a

261
00:10:55,000 --> 00:10:59,110
security error is detected it terminates

262
00:10:56,800 --> 00:11:01,900
with a nonzero exit status or something

263
00:10:59,110 --> 00:11:04,990
like that what has happened<font color="#CCCCCC"> here is that</font>

264
00:11:01,900 --> 00:11:06,499
block before the block that contained

265
00:11:04,990 --> 00:11:08,569
<font color="#E5E5E5">the triple quote I</font>

266
00:11:06,499 --> 00:11:11,539
just removed and put somewhere aside

267
00:11:08,569 --> 00:11:14,419
what did that do the next<font color="#E5E5E5"> block that</font>

268
00:11:11,539 --> 00:11:16,729
came after it is now corrupt but this it

269
00:11:14,419 --> 00:11:19,489
recovers after that so one block was

270
00:11:16,729 --> 00:11:23,029
lost in one block became corrupt take

271
00:11:19,489 --> 00:11:25,879
that prior block and a second<font color="#E5E5E5"> copy of</font>

272
00:11:23,029 --> 00:11:28,819
the triple quote block and reinsert

273
00:11:25,879 --> 00:11:30,949
those in<font color="#E5E5E5"> front of the else so just after</font>

274
00:11:28,819 --> 00:11:33,439
the if and<font color="#E5E5E5"> exactly what happens is that</font>

275
00:11:30,949 --> 00:11:36,049
triple quote gets moved below the if

276
00:11:33,439 --> 00:11:38,689
statement and is now no longer code the

277
00:11:36,049 --> 00:11:40,339
else will run how would that code

278
00:11:38,689 --> 00:11:43,659
actually<font color="#E5E5E5"> look to do this attack well</font>

279
00:11:40,339 --> 00:11:47,149
it's easy to do with DD with all the

280
00:11:43,659 --> 00:11:50,529
skip and seek and count options so a

281
00:11:47,149 --> 00:11:53,089
block in AES is 16 bytes long 128 bits

282
00:11:50,529 --> 00:11:55,639
so if you have an input file an output

283
00:11:53,089 --> 00:11:57,379
file you can copy the beginning and end

284
00:11:55,639 --> 00:11:59,239
verbatim and<font color="#E5E5E5"> mess around in between and</font>

285
00:11:57,379 --> 00:12:03,409
that's basically<font color="#E5E5E5"> what this does this</font>

286
00:11:59,239 --> 00:12:05,179
also is on<font color="#E5E5E5"> that demo site how would this</font>

287
00:12:03,409 --> 00:12:08,199
actually can we come up<font color="#CCCCCC"> with a scenario</font>

288
00:12:05,179 --> 00:12:12,348
where this might actually work possibly

289
00:12:08,199 --> 00:12:14,539
maybe we have some system administrator

290
00:12:12,349 --> 00:12:16,759
or developer with large numbers<font color="#CCCCCC"> of cloud</font>

291
00:12:14,539 --> 00:12:19,069
<font color="#CCCCCC">VMs or something and they want a</font>

292
00:12:16,759 --> 00:12:21,589
scenario<font color="#CCCCCC"> where it reaches out during the</font>

293
00:12:19,069 --> 00:12:23,988
boot process to run some script that has

294
00:12:21,589 --> 00:12:26,119
some routine system administration tasks

295
00:12:23,989 --> 00:12:28,220
that they want to be able<font color="#E5E5E5"> to change they</font>

296
00:12:26,119 --> 00:12:29,959
put it on plain HTTP they recognize that

297
00:12:28,220 --> 00:12:32,139
<font color="#CCCCCC">as dangerous so they decide let's</font>

298
00:12:29,959 --> 00:12:34,789
encrypt it so nobody can modify it right

299
00:12:32,139 --> 00:12:36,799
so they implement something in the boot

300
00:12:34,789 --> 00:12:40,809
process where we download an encrypted

301
00:12:36,799 --> 00:12:43,429
script over HTTP decrypt it and run it

302
00:12:40,809 --> 00:12:46,309
one thing<font color="#CCCCCC"> that people can be misled by</font>

303
00:12:43,429 --> 00:12:48,108
is<font color="#CCCCCC"> that openssl has a command line</font>

304
00:12:46,309 --> 00:12:50,779
utility that<font color="#E5E5E5"> will help you encrypt and</font>

305
00:12:48,109 --> 00:12:53,209
decrypt things and like most command

306
00:12:50,779 --> 00:12:56,389
line utilities it returns an exit status

307
00:12:53,209 --> 00:12:58,039
for success or failure the exit status

308
00:12:56,389 --> 00:13:01,249
is based only on the padding being

309
00:12:58,039 --> 00:13:03,019
correct so if someone<font color="#CCCCCC"> just learns a</font>

310
00:13:01,249 --> 00:13:04,999
little<font color="#E5E5E5"> bit too much to be dangerous they</font>

311
00:13:03,019 --> 00:13:06,439
could be very misleading that oh it's

312
00:13:04,999 --> 00:13:08,209
still the<font color="#CCCCCC"> same because of padding</font>

313
00:13:06,439 --> 00:13:11,478
succeeded let's take a look at<font color="#CCCCCC"> that</font>

314
00:13:08,209 --> 00:13:12,978
actually happening so suppose there's a

315
00:13:11,479 --> 00:13:14,929
man-in-the-middle attack where they

316
00:13:12,979 --> 00:13:16,369
substitute out the original<font color="#E5E5E5"> script for</font>

317
00:13:14,929 --> 00:13:19,020
this modified version that we<font color="#E5E5E5"> just</font>

318
00:13:16,369 --> 00:13:21,720
<font color="#CCCCCC">showed okay</font>

319
00:13:19,020 --> 00:13:24,210
say it happens normally this boot

320
00:13:21,720 --> 00:13:25,800
process script runs as that script was

321
00:13:24,210 --> 00:13:27,750
written the<font color="#E5E5E5"> f true gets hit and it</font>

322
00:13:25,800 --> 00:13:31,260
prints out detected a security error you

323
00:13:27,750 --> 00:13:34,950
lose substitute out the modified version

324
00:13:31,260 --> 00:13:36,720
instead now it runs the<font color="#E5E5E5"> else so no</font>

325
00:13:34,950 --> 00:13:39,720
security problem detected dangerous

326
00:13:36,720 --> 00:13:43,470
operation happens like the<font color="#E5E5E5"> other one the</font>

327
00:13:39,720 --> 00:13:45,000
sample code is in<font color="#E5E5E5"> this directory so if</font>

328
00:13:43,470 --> 00:13:46,110
you back up there's actually directory

329
00:13:45,000 --> 00:13:50,490
listing if you want to see all the

330
00:13:46,110 --> 00:13:53,420
examples so another problem say you know

331
00:13:50,490 --> 00:13:56,280
like okay I need integrity protection

332
00:13:53,420 --> 00:13:57,569
but you implement some kind of integrity

333
00:13:56,280 --> 00:14:00,000
check that is not cryptographically

334
00:13:57,570 --> 00:14:02,130
secure and now I'm getting<font color="#E5E5E5"> into examples</font>

335
00:14:00,000 --> 00:14:04,280
where I have some some actual historical

336
00:14:02,130 --> 00:14:07,380
exploits where these were big problems

337
00:14:04,280 --> 00:14:09,860
so I would say<font color="#CCCCCC"> the</font><font color="#E5E5E5"> most common like</font>

338
00:14:07,380 --> 00:14:12,390
misuse security or redundancy check

339
00:14:09,860 --> 00:14:15,450
cyclic redundancy check is probably the

340
00:14:12,390 --> 00:14:17,340
<font color="#CCCCCC">most misused integrity check in terms of</font>

341
00:14:15,450 --> 00:14:19,530
not defending against the right attack

342
00:14:17,340 --> 00:14:21,000
scenario so crcs they're quick to

343
00:14:19,530 --> 00:14:24,569
compute they're easy to implement in

344
00:14:21,000 --> 00:14:26,640
hardware so<font color="#E5E5E5"> okay we'll use that it as an</font>

345
00:14:24,570 --> 00:14:30,270
integrity check right the problem is

346
00:14:26,640 --> 00:14:32,370
<font color="#E5E5E5">that the system model or attack model of</font>

347
00:14:30,270 --> 00:14:35,040
crcs is called the binary symmetric

348
00:14:32,370 --> 00:14:37,560
<font color="#E5E5E5">channel and this has to do with radios</font>

349
00:14:35,040 --> 00:14:38,880
and wires and<font color="#E5E5E5"> stray alpha particles and</font>

350
00:14:37,560 --> 00:14:41,609
whatever else you might call it<font color="#CCCCCC"> that</font>

351
00:14:38,880 --> 00:14:43,860
might randomly flip a bit as it's being

352
00:14:41,610 --> 00:14:46,980
sent down a wire so with some high

353
00:14:43,860 --> 00:14:48,930
probability you send a<font color="#E5E5E5"> zero the other</font>

354
00:14:46,980 --> 00:14:51,470
side ceasar<font color="#CCCCCC"> zero you send a one the</font>

355
00:14:48,930 --> 00:14:53,339
other side sees a one with some small

356
00:14:51,470 --> 00:14:55,710
probability independent and identically

357
00:14:53,340 --> 00:14:58,500
distributed in all of those<font color="#CCCCCC"> things it</font>

358
00:14:55,710 --> 00:15:00,990
gets flipped right well the problem is

359
00:14:58,500 --> 00:15:02,460
if there's<font color="#E5E5E5"> a malicious adversary sitting</font>

360
00:15:00,990 --> 00:15:04,530
in between these this<font color="#E5E5E5"> is not random</font>

361
00:15:02,460 --> 00:15:06,180
chance anymore they can flip<font color="#E5E5E5"> it's</font>

362
00:15:04,530 --> 00:15:07,890
maliciously and<font color="#CCCCCC"> whenever they want so</font>

363
00:15:06,180 --> 00:15:10,079
they can sit<font color="#CCCCCC"> there and wait all here's</font>

364
00:15:07,890 --> 00:15:12,510
the<font color="#E5E5E5"> check saw or here is the permission</font>

365
00:15:10,080 --> 00:15:14,490
level and<font color="#CCCCCC"> just flip</font><font color="#E5E5E5"> it more details</font>

366
00:15:12,510 --> 00:15:17,510
about crcs and where they're actually

367
00:15:14,490 --> 00:15:21,840
<font color="#E5E5E5">used and things to know about them</font>

368
00:15:17,510 --> 00:15:23,370
they're commonly 16 or 32 bits long when

369
00:15:21,840 --> 00:15:25,560
you're in cryptography and you see

370
00:15:23,370 --> 00:15:28,260
something important<font color="#CCCCCC"> that is 16 or 32</font>

371
00:15:25,560 --> 00:15:30,329
bits long what does that mean brute

372
00:15:28,260 --> 00:15:32,339
<font color="#CCCCCC">force right to short so brute force</font>

373
00:15:30,330 --> 00:15:35,189
<font color="#CCCCCC">attacks say you have some</font>

374
00:15:32,339 --> 00:15:36,809
system that takes messages and verifies

375
00:15:35,189 --> 00:15:40,559
the<font color="#CCCCCC"> CRC and does something you just</font>

376
00:15:36,809 --> 00:15:42,480
blast all<font color="#CCCCCC"> 22 the</font><font color="#E5E5E5"> 16th possible values</font>

377
00:15:40,559 --> 00:15:45,749
and you'll and you'll<font color="#E5E5E5"> get it if that's a</font>

378
00:15:42,480 --> 00:15:49,350
security mechanism in that in that

379
00:15:45,749 --> 00:15:52,319
application when someone says CRC just

380
00:15:49,350 --> 00:15:56,220
the CRC it's not the CRC as there might

381
00:15:52,319 --> 00:15:58,769
be the shy one or the md5 CRC is kind of

382
00:15:56,220 --> 00:16:01,709
a building block that needs more

383
00:15:58,769 --> 00:16:04,139
<font color="#E5E5E5">parameters so a polynomial actually goes</font>

384
00:16:01,709 --> 00:16:06,540
into there and<font color="#E5E5E5"> like AES and other</font>

385
00:16:04,139 --> 00:16:08,579
cryptographic and error correcting code

386
00:16:06,540 --> 00:16:11,219
and so forth theory there's Galois

387
00:16:08,579 --> 00:16:12,920
fields and polynomial reduction and so

388
00:16:11,220 --> 00:16:16,079
forth going on behind the scenes in

389
00:16:12,920 --> 00:16:18,449
addition<font color="#CCCCCC"> to that so certain polynomial</font>

390
00:16:16,079 --> 00:16:20,279
needs to be picked implementations will

391
00:16:18,449 --> 00:16:22,829
commonly do some tweaks to try and

392
00:16:20,279 --> 00:16:25,230
prevent<font color="#E5E5E5"> like CRC of zero being zero and</font>

393
00:16:22,829 --> 00:16:28,498
other bad things like that so they<font color="#E5E5E5"> will</font>

394
00:16:25,230 --> 00:16:30,269
often say do bitwise not the input

395
00:16:28,499 --> 00:16:33,389
before processing it or at a post

396
00:16:30,269 --> 00:16:35,040
processing step like that<font color="#E5E5E5"> they have to</font>

397
00:16:33,389 --> 00:16:36,689
<font color="#CCCCCC">decide whether</font><font color="#E5E5E5"> the bits will be</font>

398
00:16:35,040 --> 00:16:38,519
<font color="#E5E5E5">processed little-endian or</font><font color="#CCCCCC"> big-endian</font>

399
00:16:36,689 --> 00:16:41,160
<font color="#E5E5E5">and so forth so I'm just mentioning</font>

400
00:16:38,519 --> 00:16:43,110
those because the CRC you might be<font color="#CCCCCC"> Miss</font>

401
00:16:41,160 --> 00:16:44,579
<font color="#CCCCCC">Lydell attack</font><font color="#E5E5E5"> doesn't work or what I</font>

402
00:16:43,110 --> 00:16:47,129
thought<font color="#E5E5E5"> isn't true in this case they may</font>

403
00:16:44,579 --> 00:16:49,199
<font color="#E5E5E5">have just</font><font color="#CCCCCC"> done something</font><font color="#E5E5E5"> like this the</font>

404
00:16:47,129 --> 00:16:51,420
actual<font color="#E5E5E5"> appropriate places for using it</font>

405
00:16:49,199 --> 00:16:53,969
is as a defense against some kind<font color="#E5E5E5"> of</font>

406
00:16:51,420 --> 00:16:56,399
random corruption so<font color="#E5E5E5"> Ethernet say the</font>

407
00:16:53,970 --> 00:16:58,350
zip files and hard drives are all places

408
00:16:56,399 --> 00:17:02,040
where<font color="#E5E5E5"> it's actually used but not in this</font>

409
00:16:58,350 --> 00:17:05,399
attacker modification scenario so say

410
00:17:02,040 --> 00:17:07,438
you ignore this advice and use CRC for

411
00:17:05,398 --> 00:17:08,760
some security relevant purpose well

412
00:17:07,439 --> 00:17:12,419
let's look at some of<font color="#E5E5E5"> the problems with</font>

413
00:17:08,760 --> 00:17:14,939
its properties so starting out i'm using

414
00:17:12,419 --> 00:17:17,970
a python implementation<font color="#CCCCCC"> built in just</font>

415
00:17:14,939 --> 00:17:21,120
for ease of use we take the<font color="#CCCCCC"> CRC of the</font>

416
00:17:17,970 --> 00:17:24,929
string<font color="#E5E5E5"> hello world we get a 32-bit value</font>

417
00:17:21,119 --> 00:17:27,270
the end constant there is to force it to

418
00:17:24,929 --> 00:17:30,330
be unsigned so that's not important so

419
00:17:27,270 --> 00:17:33,960
the CRC of hello world is some value the

420
00:17:30,330 --> 00:17:36,360
bitwise not of that CRC is exactly what

421
00:17:33,960 --> 00:17:39,659
<font color="#CCCCCC">you would expect first problematic</font>

422
00:17:36,360 --> 00:17:42,240
property of CRC what if<font color="#E5E5E5"> we take the CRC</font>

423
00:17:39,659 --> 00:17:45,510
of hello<font color="#CCCCCC"> world concatenated with the</font>

424
00:17:42,240 --> 00:17:46,440
bitwise not if its own<font color="#E5E5E5"> CRC well in the</font>

425
00:17:45,510 --> 00:17:49,080
Python implement a

426
00:17:46,440 --> 00:17:50,250
should we get all<font color="#CCCCCC"> one bits not something</font>

427
00:17:49,080 --> 00:17:52,590
that's<font color="#CCCCCC"> going</font><font color="#E5E5E5"> to happen with random</font>

428
00:17:50,250 --> 00:17:56,639
chance right if you saw a sha-1 or md5

429
00:17:52,590 --> 00:17:58,678
of<font color="#E5E5E5"> zero or all ones that's not something</font>

430
00:17:56,639 --> 00:18:02,070
that happens by random chance so this is

431
00:17:58,679 --> 00:18:03,450
<font color="#CCCCCC">a</font><font color="#E5E5E5"> big problem with crc as it cycles</font>

432
00:18:02,070 --> 00:18:05,668
through these bits there's a state

433
00:18:03,450 --> 00:18:07,950
inside that has like the current crc of

434
00:18:05,669 --> 00:18:09,960
what<font color="#CCCCCC"> i've looked</font><font color="#E5E5E5"> at if it takes the crc</font>

435
00:18:07,950 --> 00:18:12,210
of itself it kind of resets the internal

436
00:18:09,960 --> 00:18:13,620
state to like 0<font color="#E5E5E5"> or 1 depending on how</font>

437
00:18:12,210 --> 00:18:18,360
its implemented so not good for

438
00:18:13,620 --> 00:18:21,539
cryptography another<font color="#E5E5E5"> problem so given</font>

439
00:18:18,360 --> 00:18:26,070
this ability<font color="#E5E5E5"> to reset</font><font color="#CCCCCC"> CRC whenever we</font>

440
00:18:21,539 --> 00:18:28,230
want say we take hello world crc of

441
00:18:26,070 --> 00:18:30,960
hello<font color="#CCCCCC"> world hello world again we get a</font>

442
00:18:28,230 --> 00:18:32,909
certain<font color="#CCCCCC"> crc now knowing that we can</font>

443
00:18:30,960 --> 00:18:35,039
reset it whenever we want we can do that

444
00:18:32,909 --> 00:18:38,070
as many times as we want and that allows

445
00:18:35,039 --> 00:18:41,370
<font color="#CCCCCC">us to produce as many messages as we</font>

446
00:18:38,070 --> 00:18:42,418
want that<font color="#CCCCCC"> all have the CMC RC value so</font>

447
00:18:41,370 --> 00:18:45,570
<font color="#CCCCCC">this could come in handy if you're</font>

448
00:18:42,419 --> 00:18:47,519
modifying something right how about<font color="#E5E5E5"> some</font>

449
00:18:45,570 --> 00:18:51,200
real world examples where<font color="#CCCCCC"> crc was</font>

450
00:18:47,519 --> 00:18:53,820
misused so everybody uses ssh and

451
00:18:51,200 --> 00:18:56,190
there's ssh to point oh and then there's

452
00:18:53,820 --> 00:18:58,080
this ancient<font color="#CCCCCC"> ssh one that like nobody's</font>

453
00:18:56,190 --> 00:18:59,899
supposed to<font color="#E5E5E5"> use and is disabled and has</font>

454
00:18:58,080 --> 00:19:03,178
all these problems<font color="#E5E5E5"> well one of those in</font>

455
00:18:59,899 --> 00:19:06,149
ssh version 1.5 was that when it came

456
00:19:03,179 --> 00:19:08,909
<font color="#E5E5E5">time to verify packets are not modified</font>

457
00:19:06,149 --> 00:19:11,969
they settle it so you see RC and this is

458
00:19:08,909 --> 00:19:15,090
<font color="#CCCCCC">actually an excerpt from the draft RFC</font>

459
00:19:11,970 --> 00:19:18,750
document for ssh v 1.5 it's basically

460
00:19:15,090 --> 00:19:21,928
saying you take some plain text message

461
00:19:18,750 --> 00:19:24,570
you add some<font color="#CCCCCC"> padding you add an IV so</font>

462
00:19:21,929 --> 00:19:26,250
forth<font color="#CCCCCC"> you encrypt it but</font><font color="#E5E5E5"> before the</font>

463
00:19:24,570 --> 00:19:28,110
encryption you take a<font color="#CCCCCC"> CRC of the</font>

464
00:19:26,250 --> 00:19:31,139
plaintext<font color="#E5E5E5"> and put it in that packet</font>

465
00:19:28,110 --> 00:19:35,789
right so if somebody flips a bit the<font color="#CCCCCC"> CRC</font>

466
00:19:31,139 --> 00:19:38,459
will be invalid well when they

467
00:19:35,789 --> 00:19:40,830
redesigned ssh2 they<font color="#CCCCCC"> recognize that is a</font>

468
00:19:38,460 --> 00:19:43,169
big problem this<font color="#CCCCCC"> is from the openssh</font>

469
00:19:40,830 --> 00:19:47,699
website among the things they wanted<font color="#E5E5E5"> to</font>

470
00:19:43,169 --> 00:19:50,460
do was switch from crc to a proper<font color="#CCCCCC"> h mac</font>

471
00:19:47,700 --> 00:19:53,879
or real-wheel<font color="#CCCCCC"> h-back algorithm as they</font>

472
00:19:50,460 --> 00:19:56,399
call it<font color="#CCCCCC"> here due to</font><font color="#E5E5E5"> an insertion</font><font color="#CCCCCC"> and</font>

473
00:19:53,879 --> 00:19:58,500
<font color="#E5E5E5">tack so that sounds weird an insertion</font>

474
00:19:56,399 --> 00:19:59,549
attack in secure shell where you're like

475
00:19:58,500 --> 00:20:01,379
<font color="#CCCCCC">sue do this</font>

476
00:19:59,549 --> 00:20:02,970
do that that could be a problem so let's

477
00:20:01,379 --> 00:20:07,619
look into the details of<font color="#E5E5E5"> that attack</font>

478
00:20:02,970 --> 00:20:09,749
it's actually I guess 17 years old so

479
00:20:07,619 --> 00:20:12,988
here's a here's a bug track posting for

480
00:20:09,749 --> 00:20:16,320
that so someone actually was looking at

481
00:20:12,989 --> 00:20:18,480
SSH 1.5 I guess<font color="#CCCCCC"> four years or so after</font>

482
00:20:16,320 --> 00:20:21,090
<font color="#CCCCCC">it came out and they actually</font><font color="#E5E5E5"> found by</font>

483
00:20:18,480 --> 00:20:23,669
combining some of these block cipher cut

484
00:20:21,090 --> 00:20:25,980
and paste<font color="#E5E5E5"> things I showed before as well</font>

485
00:20:23,669 --> 00:20:28,049
<font color="#E5E5E5">as the ability to flip a bit corrupt</font>

486
00:20:25,980 --> 00:20:30,330
that block but control the value of the

487
00:20:28,049 --> 00:20:32,249
next block when it was decrypted they

488
00:20:30,330 --> 00:20:34,470
found<font color="#E5E5E5"> they could kind of synthetically</font>

489
00:20:32,249 --> 00:20:36,960
construct a packet containing some

490
00:20:34,470 --> 00:20:39,149
command by modifying an existing<font color="#E5E5E5"> one and</font>

491
00:20:36,960 --> 00:20:41,369
still have the<font color="#E5E5E5"> CRC check out in the end</font>

492
00:20:39,149 --> 00:20:43,859
by flipping bits and controlling what

493
00:20:41,369 --> 00:20:46,590
the<font color="#E5E5E5"> CRC would be so you can imagine you</font>

494
00:20:43,859 --> 00:20:48,389
could inject like sudo RM<font color="#CCCCCC"> v RF / or</font>

495
00:20:46,590 --> 00:20:50,668
something like that into<font color="#CCCCCC"> the SSH command</font>

496
00:20:48,389 --> 00:20:53,189
stream not a good<font color="#E5E5E5"> thing so that's why</font>

497
00:20:50,669 --> 00:20:56,820
ssh2 should only be used among other

498
00:20:53,190 --> 00:21:00,659
things it uses real integrity checks

499
00:20:56,820 --> 00:21:02,220
that are cryptographically based the

500
00:21:00,659 --> 00:21:05,970
other thing in addition to kind of the

501
00:21:02,220 --> 00:21:08,070
collision problem is modifying data that

502
00:21:05,970 --> 00:21:09,989
is protected<font color="#CCCCCC"> with a CRC and being able</font>

503
00:21:08,070 --> 00:21:13,820
to predict the<font color="#E5E5E5"> effect that that will</font>

504
00:21:09,989 --> 00:21:17,159
have on the new CRC of the modified data

505
00:21:13,820 --> 00:21:20,999
so here is<font color="#E5E5E5"> something as a stream cipher</font>

506
00:21:17,159 --> 00:21:22,919
might do we have some message x<font color="#E5E5E5"> sword</font>

507
00:21:20,999 --> 00:21:24,960
with some other message of the same

508
00:21:22,919 --> 00:21:27,600
length so<font color="#CCCCCC"> i have hexadecimal and ascii</font>

509
00:21:24,960 --> 00:21:30,749
so all B's<font color="#E5E5E5"> XOR with always produces</font>

510
00:21:27,600 --> 00:21:34,080
pound signs in this<font color="#E5E5E5"> scenario we take the</font>

511
00:21:30,749 --> 00:21:37,289
<font color="#E5E5E5">CRC of both of</font><font color="#CCCCCC"> those incoming messages</font>

512
00:21:34,080 --> 00:21:39,899
and then we get<font color="#CCCCCC"> the new message now the</font>

513
00:21:37,289 --> 00:21:41,970
question<font color="#E5E5E5"> is without actually taking the</font>

514
00:21:39,899 --> 00:21:44,729
CRC of all the pound signs could we

515
00:21:41,970 --> 00:21:48,989
predict what that value would<font color="#CCCCCC"> be given</font>

516
00:21:44,730 --> 00:21:51,659
only the CRC of<font color="#E5E5E5"> X the first message and</font>

517
00:21:48,989 --> 00:21:58,019
the value of y that<font color="#CCCCCC"> we rec soaring</font>

518
00:21:51,659 --> 00:22:03,090
against it right so we actually<font color="#E5E5E5"> could do</font>

519
00:21:58,019 --> 00:22:05,609
that we end up<font color="#E5E5E5"> with the CRC if we</font>

520
00:22:03,090 --> 00:22:08,279
compute it explicitly is this 7 f 95 so

521
00:22:05,609 --> 00:22:10,949
forth and then in the Python script

522
00:22:08,279 --> 00:22:12,840
underneath you can see the CRC can

523
00:22:10,950 --> 00:22:13,240
actually be computed without looking at

524
00:22:12,840 --> 00:22:15,669
<font color="#E5E5E5">X</font>

525
00:22:13,240 --> 00:22:18,190
you take the<font color="#E5E5E5"> CRC of X XOR with the</font>

526
00:22:15,670 --> 00:22:22,360
bitwise not of reset the state and<font color="#E5E5E5"> the</font>

527
00:22:18,190 --> 00:22:24,550
<font color="#CCCCCC">aldi ace so in other words take a</font>

528
00:22:22,360 --> 00:22:26,469
message tamper with it by flipping some

529
00:22:24,550 --> 00:22:30,070
bit as long<font color="#CCCCCC"> as you do the correct thing</font>

530
00:22:26,470 --> 00:22:32,620
to the crc will still check out well

531
00:22:30,070 --> 00:22:34,600
what<font color="#E5E5E5"> if that x value were actually</font>

532
00:22:32,620 --> 00:22:36,580
unknown to the attacker or only

533
00:22:34,600 --> 00:22:40,240
partially known but they still know the

534
00:22:36,580 --> 00:22:43,149
<font color="#CCCCCC">CRC well that could be a problem or</font>

535
00:22:40,240 --> 00:22:45,670
alternatively what if both that original

536
00:22:43,150 --> 00:22:48,580
X message and at CRC are encrypted using

537
00:22:45,670 --> 00:22:50,380
a stream cipher well stream cipher we

538
00:22:48,580 --> 00:22:52,780
can still flip bits wherever we want and

539
00:22:50,380 --> 00:22:56,170
that brings us<font color="#CCCCCC"> to an infamous security</font>

540
00:22:52,780 --> 00:23:00,160
problem which would be wet so<font color="#CCCCCC"> remember</font>

541
00:22:56,170 --> 00:23:03,850
WEP 802 11 40 bit Ivy's too short

542
00:23:00,160 --> 00:23:07,540
<font color="#E5E5E5">injection so forth so how the web frames</font>

543
00:23:03,850 --> 00:23:11,320
actually looked they sent<font color="#E5E5E5"> a frame</font>

544
00:23:07,540 --> 00:23:15,700
containing an IV and then<font color="#CCCCCC"> rc4 encrypted</font>

545
00:23:11,320 --> 00:23:18,970
data composed of a message in its<font color="#E5E5E5"> crc so</font>

546
00:23:15,700 --> 00:23:21,250
some researchers basically from like<font color="#CCCCCC"> two</font>

547
00:23:18,970 --> 00:23:23,560
<font color="#CCCCCC">thousand i like to 2010 and</font><font color="#E5E5E5"> i guess</font>

548
00:23:21,250 --> 00:23:25,060
nobody<font color="#E5E5E5"> cares about WEP anymore but</font>

549
00:23:23,560 --> 00:23:27,159
<font color="#E5E5E5">basically was one attack after another</font>

550
00:23:25,060 --> 00:23:29,919
each one improving<font color="#E5E5E5"> on the last one of</font>

551
00:23:27,160 --> 00:23:32,590
those earliest papers was recognizing

552
00:23:29,920 --> 00:23:35,860
the fact that looking at these two

553
00:23:32,590 --> 00:23:38,530
properties<font color="#CCCCCC"> XOR on</font><font color="#E5E5E5"> ciphertext does the</font>

554
00:23:35,860 --> 00:23:42,520
same thing to<font color="#E5E5E5"> the plaintext and we can</font>

555
00:23:38,530 --> 00:23:44,980
fix up the<font color="#CCCCCC"> CRC after modifying it they</font>

556
00:23:42,520 --> 00:23:47,170
gave<font color="#CCCCCC"> a much more precise and theoretical</font>

557
00:23:44,980 --> 00:23:50,200
description of exactly that basically

558
00:23:47,170 --> 00:23:52,480
saying we have<font color="#E5E5E5"> a message and a delta or</font>

559
00:23:50,200 --> 00:23:54,670
changes to that message if we take the

560
00:23:52,480 --> 00:23:56,560
CRC of the message the CRC the Delta and

561
00:23:54,670 --> 00:23:59,170
<font color="#E5E5E5">do everything</font><font color="#CCCCCC"> exactly right we can</font>

562
00:23:56,560 --> 00:24:02,169
produce a<font color="#E5E5E5"> new message based on an old</font>

563
00:23:59,170 --> 00:24:06,520
one having<font color="#E5E5E5"> never known the key so that</font>

564
00:24:02,170 --> 00:24:08,620
led many things the most one matching up

565
00:24:06,520 --> 00:24:11,650
with this particular vulnerability being

566
00:24:08,620 --> 00:24:14,320
cafe latte attack which someone actually

567
00:24:11,650 --> 00:24:16,660
presented a torque on like six years<font color="#CCCCCC"> ago</font>

568
00:24:14,320 --> 00:24:19,870
or something but basically<font color="#CCCCCC"> they</font>

569
00:24:16,660 --> 00:24:21,850
<font color="#CCCCCC">recognized that rather</font><font color="#E5E5E5"> than doing</font>

570
00:24:19,870 --> 00:24:24,280
typical approaches to breaking WEP which

571
00:24:21,850 --> 00:24:26,119
is<font color="#E5E5E5"> I'm standing here the access point is</font>

572
00:24:24,280 --> 00:24:28,309
there let's interact with it and get it

573
00:24:26,119 --> 00:24:30,708
lots of<font color="#E5E5E5"> IVs they took the opposite</font>

574
00:24:28,309 --> 00:24:33,529
approach which is corporate<font color="#CCCCCC"> Windows</font>

575
00:24:30,709 --> 00:24:36,709
laptop leaves the company like somebody

576
00:24:33,529 --> 00:24:39,529
goes on vacation or to a conference they

577
00:24:36,709 --> 00:24:41,239
noticed a property about the versions of

578
00:24:39,529 --> 00:24:43,849
windows at<font color="#CCCCCC"> the time where there was this</font>

579
00:24:41,239 --> 00:24:46,159
remembered network list it would like

580
00:24:43,849 --> 00:24:47,599
reach out actively for like where is

581
00:24:46,159 --> 00:24:49,309
this network where is this network you

582
00:24:47,599 --> 00:24:51,678
could pretend<font color="#CCCCCC"> to be the access point and</font>

583
00:24:49,309 --> 00:24:54,439
then they notice a couple things like it

584
00:24:51,679 --> 00:24:55,969
would<font color="#E5E5E5"> send out an</font><font color="#CCCCCC"> ARP request upon</font>

585
00:24:54,439 --> 00:24:57,889
connection which you couldn't answer

586
00:24:55,969 --> 00:24:59,869
because you didn't<font color="#E5E5E5"> know the key or maybe</font>

587
00:24:57,889 --> 00:25:01,998
you<font color="#E5E5E5"> could because using this</font>

588
00:24:59,869 --> 00:25:04,549
malleability property and the ability to

589
00:25:01,999 --> 00:25:06,199
compute<font color="#CCCCCC"> the correct CRC they could flip</font>

590
00:25:04,549 --> 00:25:09,289
around the correct fields and the

591
00:25:06,199 --> 00:25:11,239
message to send a<font color="#E5E5E5"> message to that device</font>

592
00:25:09,289 --> 00:25:13,309
and every time it would we spawn with

593
00:25:11,239 --> 00:25:16,339
like an<font color="#E5E5E5"> arc response and one of the</font>

594
00:25:13,309 --> 00:25:20,178
properties of WEP is if you have to to

595
00:25:16,339 --> 00:25:23,448
the 24th packets because<font color="#E5E5E5"> of the IV being</font>

596
00:25:20,179 --> 00:25:25,489
24 bits long then with increasing

597
00:25:23,449 --> 00:25:27,649
probability you've seen all of the IV's

598
00:25:25,489 --> 00:25:30,829
and all of the key streams and then can

599
00:25:27,649 --> 00:25:34,339
take advantage of various biases in our

600
00:25:30,829 --> 00:25:36,678
c4 and recover<font color="#CCCCCC"> the WEP key so this is</font>

601
00:25:34,339 --> 00:25:38,688
<font color="#CCCCCC">like the nail in the coffin for WEP if</font>

602
00:25:36,679 --> 00:25:42,859
the other 50 attacks before<font color="#CCCCCC"> it were not</font>

603
00:25:38,689 --> 00:25:45,589
so<font color="#CCCCCC"> that's a problem with</font><font color="#E5E5E5"> crcs now say</font>

604
00:25:42,859 --> 00:25:47,809
your developer knows<font color="#CCCCCC"> okay</font>

605
00:25:45,589 --> 00:25:49,399
cryptographically secure one-way

606
00:25:47,809 --> 00:25:52,819
function so cryptographically secure

607
00:25:49,399 --> 00:25:54,438
hashes wonderful let's use that well

608
00:25:52,819 --> 00:25:59,029
what if they forget about<font color="#E5E5E5"> the fact that</font>

609
00:25:54,439 --> 00:26:02,269
these typical functions are uncured have

610
00:25:59,029 --> 00:26:06,609
a message<font color="#E5E5E5"> just like</font><font color="#CCCCCC"> CRC anyone can</font>

611
00:26:02,269 --> 00:26:09,259
compute the hash of it as well right

612
00:26:06,609 --> 00:26:12,198
well one of the problems if we take our

613
00:26:09,259 --> 00:26:14,479
CS<font color="#CCCCCC"> CRC approach is the guarantees and</font>

614
00:26:12,199 --> 00:26:17,389
properties of even on keyed hash

615
00:26:14,479 --> 00:26:18,949
functions which are the famous three

616
00:26:17,389 --> 00:26:20,208
here that are always<font color="#E5E5E5"> confusing and</font>

617
00:26:18,949 --> 00:26:22,819
trying to remember what the distinction

618
00:26:20,209 --> 00:26:24,909
is so collision<font color="#CCCCCC"> preimage is second</font>

619
00:26:22,819 --> 00:26:27,469
preimage which basically boil down to

620
00:26:24,909 --> 00:26:30,739
you can't find<font color="#E5E5E5"> two messages with the</font>

621
00:26:27,469 --> 00:26:32,029
same hash value for one and also given a

622
00:26:30,739 --> 00:26:34,429
hash value it's computationally

623
00:26:32,029 --> 00:26:36,709
infeasible to generate some message of

624
00:26:34,429 --> 00:26:38,299
the actors to that value or at least

625
00:26:36,709 --> 00:26:39,530
when<font color="#CCCCCC"> the hash function comes out it</font>

626
00:26:38,299 --> 00:26:41,420
meets all of<font color="#E5E5E5"> its properties</font>

627
00:26:39,530 --> 00:26:43,700
but<font color="#CCCCCC"> more all the story this</font><font color="#E5E5E5"> whole idea</font>

628
00:26:41,420 --> 00:26:45,590
<font color="#E5E5E5">of flip a bed and like somehow fix up</font>

629
00:26:43,700 --> 00:26:47,590
the hash value<font color="#CCCCCC"> is not going to work and</font>

630
00:26:45,590 --> 00:26:51,500
<font color="#CCCCCC">it's catastrophic Lee broken in some way</font>

631
00:26:47,590 --> 00:26:53,240
so we have to find some other attack or

632
00:26:51,500 --> 00:26:55,400
look at even<font color="#E5E5E5"> worse programs than before</font>

633
00:26:53,240 --> 00:26:58,220
and this one I'll<font color="#CCCCCC"> actually look at</font>

634
00:26:55,400 --> 00:27:01,370
something behavioral so who is ever

635
00:26:58,220 --> 00:27:03,950
downloaded a linux distribution all

636
00:27:01,370 --> 00:27:06,110
right maybe using<font color="#E5E5E5"> W get or something in</font>

637
00:27:03,950 --> 00:27:07,460
the background so it doesn't crash or

638
00:27:06,110 --> 00:27:10,939
you accidentally close the tab or

639
00:27:07,460 --> 00:27:12,860
whatever right and you might use HTTP or

640
00:27:10,940 --> 00:27:15,350
if you're old-fashioned<font color="#E5E5E5"> FTP</font><font color="#CCCCCC"> or something</font>

641
00:27:12,860 --> 00:27:16,729
else right<font color="#E5E5E5"> and once it finishes you</font>

642
00:27:15,350 --> 00:27:18,320
don't want a coaster so you want to

643
00:27:16,730 --> 00:27:20,570
verify that the image downloaded

644
00:27:18,320 --> 00:27:24,080
correctly so you take a look<font color="#E5E5E5"> at</font><font color="#CCCCCC"> a file</font>

645
00:27:20,570 --> 00:27:25,970
that looks<font color="#E5E5E5"> like this right so</font><font color="#CCCCCC"> sha256</font>

646
00:27:24,080 --> 00:27:27,740
some you compute it locally see if they

647
00:27:25,970 --> 00:27:30,650
match and if they match you're good to

648
00:27:27,740 --> 00:27:33,530
go right well if your attack model or

649
00:27:30,650 --> 00:27:35,480
threat model as you call it was about

650
00:27:33,530 --> 00:27:38,450
random corruption to that image as it

651
00:27:35,480 --> 00:27:40,580
was downloaded fine but<font color="#E5E5E5"> one of the other</font>

652
00:27:38,450 --> 00:27:41,840
reasons why they produce these is<font color="#CCCCCC"> that</font>

653
00:27:40,580 --> 00:27:43,460
if you think<font color="#CCCCCC"> about it there are large</font>

654
00:27:41,840 --> 00:27:46,610
numbers of mirror sites that they just

655
00:27:43,460 --> 00:27:47,930
kind of transparently send you to if you

656
00:27:46,610 --> 00:27:49,610
<font color="#E5E5E5">think about certificate authorities</font>

657
00:27:47,930 --> 00:27:52,130
having like 50 people that are all

658
00:27:49,610 --> 00:27:54,080
trusted to do the same thing maybe not

659
00:27:52,130 --> 00:27:55,970
<font color="#E5E5E5">too good of an idea so if you</font><font color="#CCCCCC"> think</font>

660
00:27:54,080 --> 00:27:59,149
about a compromise or malicious mirror

661
00:27:55,970 --> 00:28:02,510
site this may not be good<font color="#CCCCCC"> enough because</font>

662
00:27:59,150 --> 00:28:04,700
they modify the ISO they can modify the

663
00:28:02,510 --> 00:28:08,150
hash file as well well this<font color="#CCCCCC"> is not</font>

664
00:28:04,700 --> 00:28:10,610
something that they overlooked as ubuntu

665
00:28:08,150 --> 00:28:13,130
and debian or<font color="#E5E5E5"> read at whoever the</font>

666
00:28:10,610 --> 00:28:14,479
property that ubuntu and debian actually

667
00:28:13,130 --> 00:28:17,810
do is they put<font color="#E5E5E5"> the signature in a</font>

668
00:28:14,480 --> 00:28:19,430
separate file that looks like this so of

669
00:28:17,810 --> 00:28:21,620
the people that download linux

670
00:28:19,430 --> 00:28:22,880
distributions and compare the hash who

671
00:28:21,620 --> 00:28:25,280
actually remembers to verify<font color="#E5E5E5"> the</font>

672
00:28:22,880 --> 00:28:28,130
signature of the hash not so many<font color="#E5E5E5"> one</font>

673
00:28:25,280 --> 00:28:29,899
<font color="#CCCCCC">okay so that's important this was just a</font>

674
00:28:28,130 --> 00:28:32,420
behavioral or example but anybody that

675
00:28:29,900 --> 00:28:35,210
implements in their soft or some kind of

676
00:28:32,420 --> 00:28:37,820
auto update feature I've often seen its

677
00:28:35,210 --> 00:28:39,920
file and hash a file and you're good to

678
00:28:37,820 --> 00:28:42,050
go they don't think<font color="#E5E5E5"> about well if you're</font>

679
00:28:39,920 --> 00:28:45,020
<font color="#CCCCCC">a burp suite or whatever</font><font color="#E5E5E5"> I can just put</font>

680
00:28:42,050 --> 00:28:47,360
whatever hash I want so that's important

681
00:28:45,020 --> 00:28:48,920
you need to think<font color="#E5E5E5"> about not</font><font color="#CCCCCC"> only is ash</font>

682
00:28:47,360 --> 00:28:53,209
correct but who's capable of generating

683
00:28:48,920 --> 00:28:53,570
it say they do recognize<font color="#CCCCCC"> that we want</font><font color="#E5E5E5"> to</font>

684
00:28:53,210 --> 00:28:55,910
produce

685
00:28:53,570 --> 00:28:58,040
a keyed hash or keyed one-way function

686
00:28:55,910 --> 00:29:00,560
which is<font color="#CCCCCC"> a message authentication code</font>

687
00:28:58,040 --> 00:29:02,360
but some people think of that and decide

688
00:29:00,560 --> 00:29:03,649
let's make<font color="#CCCCCC"> our own let's take a key in a</font>

689
00:29:02,360 --> 00:29:07,699
<font color="#E5E5E5">message combine them in some way and</font>

690
00:29:03,650 --> 00:29:09,620
hash them well<font color="#CCCCCC"> quickly what a</font><font color="#E5E5E5"> message</font>

691
00:29:07,700 --> 00:29:11,960
authentication is supposed to do is<font color="#CCCCCC"> just</font>

692
00:29:09,620 --> 00:29:14,090
like a hash except there's a key so only

693
00:29:11,960 --> 00:29:16,550
<font color="#E5E5E5">someone in possession of a key can</font>

694
00:29:14,090 --> 00:29:17,990
generate that hash but don't forget<font color="#E5E5E5"> only</font>

695
00:29:16,550 --> 00:29:20,659
<font color="#E5E5E5">someone in possession of that key can</font>

696
00:29:17,990 --> 00:29:22,250
verify it either so it's like<font color="#E5E5E5"> symmetric</font>

697
00:29:20,660 --> 00:29:26,870
cryptography as opposed to asymmetric

698
00:29:22,250 --> 00:29:29,270
cryptography what a Mac does protect a

699
00:29:26,870 --> 00:29:30,800
message from being modified a lot<font color="#E5E5E5"> of</font>

700
00:29:29,270 --> 00:29:33,080
<font color="#CCCCCC">people see Mac and just immediately</font>

701
00:29:30,800 --> 00:29:35,960
<font color="#E5E5E5">think of H Mac that's probably the most</font>

702
00:29:33,080 --> 00:29:38,720
popular way because<font color="#CCCCCC"> of various rfcs and</font>

703
00:29:35,960 --> 00:29:41,330
ietf standards but it's not the only way

704
00:29:38,720 --> 00:29:43,730
to implement a Mac in fact it's kind of

705
00:29:41,330 --> 00:29:45,710
a passing thing if you look at some of

706
00:29:43,730 --> 00:29:50,540
<font color="#E5E5E5">the newer cipher suites that I'll get to</font>

707
00:29:45,710 --> 00:29:52,790
later in TLS and so forth but a hash is

708
00:29:50,540 --> 00:29:55,670
probably in isolation in one<font color="#CCCCCC"> of the</font>

709
00:29:52,790 --> 00:29:57,409
fastest ways so it's often the one you

710
00:29:55,670 --> 00:29:58,850
<font color="#E5E5E5">think of first don't confuse them with</font>

711
00:29:57,410 --> 00:30:02,090
digital signatures just like the

712
00:29:58,850 --> 00:30:04,040
previous example so it's symmetric this

713
00:30:02,090 --> 00:30:06,320
<font color="#E5E5E5">math software distribution would not be</font>

714
00:30:04,040 --> 00:30:07,730
a place to use an h-back because you

715
00:30:06,320 --> 00:30:10,659
would have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> have the key to verify it</font>

716
00:30:07,730 --> 00:30:14,000
and you've had the key<font color="#CCCCCC"> you can modify it</font>

717
00:30:10,660 --> 00:30:17,600
don't try<font color="#CCCCCC"> to make your</font><font color="#E5E5E5"> own so how can</font>

718
00:30:14,000 --> 00:30:19,070
you<font color="#E5E5E5"> fail well it turns</font><font color="#CCCCCC"> out that all</font>

719
00:30:17,600 --> 00:30:21,500
<font color="#E5E5E5">three of the immediately obvious</font>

720
00:30:19,070 --> 00:30:25,220
approaches for constructing a Mac or

721
00:30:21,500 --> 00:30:26,780
insecure some worse than others so basic

722
00:30:25,220 --> 00:30:28,730
problem you have a key you<font color="#E5E5E5"> have a</font>

723
00:30:26,780 --> 00:30:30,920
message you want to<font color="#E5E5E5"> hash them so that</font>

724
00:30:28,730 --> 00:30:33,800
you cannot generate that hash without

725
00:30:30,920 --> 00:30:35,480
the key well one first one maybe you

726
00:30:33,800 --> 00:30:38,540
take the message<font color="#E5E5E5"> and you concatenate the</font>

727
00:30:35,480 --> 00:30:41,240
key on at the end well the the<font color="#E5E5E5"> problem</font>

728
00:30:38,540 --> 00:30:43,460
there which if you actually want an H

729
00:30:41,240 --> 00:30:47,270
Mac to be secure as any other form of

730
00:30:43,460 --> 00:30:49,850
Mac suppose the hashing algorithm has a

731
00:30:47,270 --> 00:30:53,210
collision in it that approach would<font color="#CCCCCC"> be</font>

732
00:30:49,850 --> 00:30:55,429
broken<font color="#E5E5E5"> because of the layout</font><font color="#CCCCCC"> of the</font>

733
00:30:53,210 --> 00:30:57,830
message coming first<font color="#E5E5E5"> but it's not so bad</font>

734
00:30:55,430 --> 00:30:59,870
<font color="#E5E5E5">necessarily the one that is worse is the</font>

735
00:30:57,830 --> 00:31:02,230
second example key concatenate message

736
00:30:59,870 --> 00:31:04,370
and I'll get to<font color="#E5E5E5"> why in a second and then</font>

737
00:31:02,230 --> 00:31:06,890
<font color="#CCCCCC">actually the people that really care</font>

738
00:31:04,370 --> 00:31:07,370
about these things say you have<font color="#E5E5E5"> two keys</font>

739
00:31:06,890 --> 00:31:09,980
and you

740
00:31:07,370 --> 00:31:12,080
do<font color="#CCCCCC"> a key the message another key that</font>

741
00:31:09,980 --> 00:31:14,750
can be shown<font color="#E5E5E5"> it snow snow more secure</font>

742
00:31:12,080 --> 00:31:17,000
than one key so all three of these are

743
00:31:14,750 --> 00:31:19,190
<font color="#CCCCCC">not something a crypt analysts would</font>

744
00:31:17,000 --> 00:31:22,040
think very highly of but this middle one

745
00:31:19,190 --> 00:31:24,770
is catastrophic ly broken the reason is

746
00:31:22,040 --> 00:31:28,370
<font color="#CCCCCC">because of a length extension attack and</font>

747
00:31:24,770 --> 00:31:31,370
the<font color="#E5E5E5"> reason</font><font color="#CCCCCC"> for this when you have a hash</font>

748
00:31:28,370 --> 00:31:33,439
value that hash value represents the

749
00:31:31,370 --> 00:31:35,179
internal state of that hashing algorithm

750
00:31:33,440 --> 00:31:39,200
when it was done processing the message

751
00:31:35,180 --> 00:31:41,030
if you can turn<font color="#E5E5E5"> that take that state and</font>

752
00:31:39,200 --> 00:31:42,920
put it back into the hashing<font color="#E5E5E5"> algorithm</font>

753
00:31:41,030 --> 00:31:44,660
and feed more data through it the keys

754
00:31:42,920 --> 00:31:47,000
<font color="#E5E5E5">already been through so you'll compete a</font>

755
00:31:44,660 --> 00:31:49,370
correct hash in a real-world scenario

756
00:31:47,000 --> 00:31:51,350
the key is unknown but you might know

757
00:31:49,370 --> 00:31:52,879
its length<font color="#E5E5E5"> six bytes in this case</font>

758
00:31:51,350 --> 00:31:55,969
hopefully<font color="#CCCCCC"> it's actually bigger than that</font>

759
00:31:52,880 --> 00:31:58,490
<font color="#E5E5E5">and let's observe that we're interacting</font>

760
00:31:55,970 --> 00:32:00,350
with some system that we are able<font color="#E5E5E5"> to</font>

761
00:31:58,490 --> 00:32:02,570
convince it to do the<font color="#CCCCCC"> H back of the</font>

762
00:32:00,350 --> 00:32:06,260
string hello world and it returns this

763
00:32:02,570 --> 00:32:08,600
value<font color="#CCCCCC"> and it uses md5 which md5</font><font color="#E5E5E5"> 4h</font><font color="#CCCCCC"> Mac</font>

764
00:32:06,260 --> 00:32:12,590
is not considered broken unlike<font color="#CCCCCC"> we're</font>

765
00:32:08,600 --> 00:32:14,270
<font color="#CCCCCC">all md5 just an important point now can</font>

766
00:32:12,590 --> 00:32:17,840
we use a length extension attack to

767
00:32:14,270 --> 00:32:19,520
somehow feed<font color="#E5E5E5"> earth-mars onto the end of</font>

768
00:32:17,840 --> 00:32:22,300
hello<font color="#CCCCCC"> world and</font><font color="#E5E5E5"> still be able to commute</font>

769
00:32:19,520 --> 00:32:28,190
compute the<font color="#CCCCCC"> Mac</font><font color="#E5E5E5"> without knowing the key</font>

770
00:32:22,300 --> 00:32:29,990
almost so as stated you have a hash you

771
00:32:28,190 --> 00:32:32,929
can put that<font color="#E5E5E5"> back in and keep going the</font>

772
00:32:29,990 --> 00:32:35,600
problem is that md5 and sha-1 and shot

773
00:32:32,929 --> 00:32:37,400
to share a property where they like a

774
00:32:35,600 --> 00:32:39,740
block cipher actually have a block size

775
00:32:37,400 --> 00:32:42,080
they don't<font color="#E5E5E5"> just go like bit by bit or</font>

776
00:32:39,740 --> 00:32:44,980
character by character and knowing the

777
00:32:42,080 --> 00:32:48,320
property of md5 you have a message

778
00:32:44,980 --> 00:32:52,970
before it hashes it it concatenates a<font color="#E5E5E5"> 1</font>

779
00:32:48,320 --> 00:32:54,740
<font color="#E5E5E5">bit or a 0 80 bite fills it in with</font><font color="#CCCCCC"> 0</font>

780
00:32:52,970 --> 00:32:57,650
bytes to meet a boundary on the block

781
00:32:54,740 --> 00:33:00,080
size and then or just before<font color="#CCCCCC"> it and then</font>

782
00:32:57,650 --> 00:33:02,990
adds to that the length of the message

783
00:33:00,080 --> 00:33:06,409
in bits and as a 64 bit little endian

784
00:33:02,990 --> 00:33:08,240
integer so the length part is important

785
00:33:06,410 --> 00:33:10,490
otherwise you would have the padding at

786
00:33:08,240 --> 00:33:12,890
it in different strings could end up

787
00:33:10,490 --> 00:33:16,370
with<font color="#CCCCCC"> the same post padding</font>

788
00:33:12,890 --> 00:33:18,860
representation notice though that the

789
00:33:16,370 --> 00:33:21,139
consequence is this is because md5 only

790
00:33:18,860 --> 00:33:23,689
operates on a certain block size of 64

791
00:33:21,140 --> 00:33:25,940
but knowing this going back to<font color="#CCCCCC"> our</font>

792
00:33:23,690 --> 00:33:30,680
problem<font color="#E5E5E5"> we don't know the secret but we</font>

793
00:33:25,940 --> 00:33:33,110
know<font color="#E5E5E5"> it six bytes long and if you do</font>

794
00:33:30,680 --> 00:33:35,360
this value on hello world you end up

795
00:33:33,110 --> 00:33:37,669
with knowing that<font color="#E5E5E5"> internal state</font>

796
00:33:35,360 --> 00:33:40,580
contained this as the hash was generated

797
00:33:37,670 --> 00:33:42,920
the first 0x80 is that one bit the

798
00:33:40,580 --> 00:33:46,939
second 0x80 is the length of the string

799
00:33:42,920 --> 00:33:49,400
hello world in bits how do you

800
00:33:46,940 --> 00:33:51,170
reconstruct the state well this is<font color="#E5E5E5"> one</font>

801
00:33:49,400 --> 00:33:52,820
of<font color="#E5E5E5"> those corner cases that i always find</font>

802
00:33:51,170 --> 00:33:56,540
where scripting languages make it more

803
00:33:52,820 --> 00:34:00,409
difficult than<font color="#CCCCCC"> c so in openssl you can</font>

804
00:33:56,540 --> 00:34:02,659
actually<font color="#E5E5E5"> take that hash and just force</font>

805
00:34:00,410 --> 00:34:04,460
it into the struct<font color="#CCCCCC"> contexts that</font><font color="#E5E5E5"> it</font>

806
00:34:02,660 --> 00:34:07,220
keeps around for maintaining the

807
00:34:04,460 --> 00:34:10,699
internal state of md5 so we take this

808
00:34:07,220 --> 00:34:13,130
128-bit long hash and after looking at

809
00:34:10,699 --> 00:34:14,899
the RFC or<font color="#CCCCCC"> Wikipedia article of</font><font color="#E5E5E5"> Hell md5</font>

810
00:34:13,130 --> 00:34:17,330
works you<font color="#CCCCCC"> know where the various values</font>

811
00:34:14,899 --> 00:34:19,880
go and you<font color="#E5E5E5"> know how to reverse the bits</font>

812
00:34:17,330 --> 00:34:21,710
or bytes in the correct order the NL is

813
00:34:19,880 --> 00:34:24,200
<font color="#CCCCCC">just keeping track of how many bits of</font>

814
00:34:21,710 --> 00:34:27,139
message have been<font color="#E5E5E5"> seen so we've put that</font>

815
00:34:24,199 --> 00:34:30,489
state back into md5<font color="#E5E5E5"> and we can feed more</font>

816
00:34:27,139 --> 00:34:33,049
things through it let's do exactly that

817
00:34:30,489 --> 00:34:36,199
run that Earth Mars through<font color="#E5E5E5"> there and</font>

818
00:34:33,050 --> 00:34:38,659
md5 final will add the padding again and

819
00:34:36,199 --> 00:34:41,779
release the hash and we notice we run

820
00:34:38,659 --> 00:34:45,560
that program and we get this 16 15 and

821
00:34:41,780 --> 00:34:47,659
so on hash what this told us is the hash

822
00:34:45,560 --> 00:34:50,060
of this synthetically constructed string

823
00:34:47,659 --> 00:34:52,490
underneath of hello world padding Earth

824
00:34:50,060 --> 00:34:55,009
Mars and in reality padding again is

825
00:34:52,489 --> 00:34:57,109
that value so we can<font color="#E5E5E5"> check</font><font color="#CCCCCC"> that out by</font>

826
00:34:55,010 --> 00:34:59,200
manually taking the md5 of this string

827
00:34:57,110 --> 00:35:02,360
and seeing if<font color="#CCCCCC"> we get the same</font><font color="#E5E5E5"> value and</font>

828
00:34:59,200 --> 00:35:05,689
we do so that's a length extension

829
00:35:02,360 --> 00:35:07,190
attack similarly to<font color="#CCCCCC"> the other problems</font>

830
00:35:05,690 --> 00:35:08,600
some sample code there if you want to

831
00:35:07,190 --> 00:35:13,070
play around<font color="#E5E5E5"> with it the important thing</font>

832
00:35:08,600 --> 00:35:14,900
<font color="#CCCCCC">to note is it's not just md5 sha-1 and</font>

833
00:35:13,070 --> 00:35:17,000
<font color="#CCCCCC">sha to have the same property with</font>

834
00:35:14,900 --> 00:35:18,830
different block sizes and maybe

835
00:35:17,000 --> 00:35:21,440
different<font color="#E5E5E5"> byte order depends on who</font>

836
00:35:18,830 --> 00:35:23,569
designed it but<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> something that</font>

837
00:35:21,440 --> 00:35:26,390
<font color="#E5E5E5">nest and others actually took into</font>

838
00:35:23,570 --> 00:35:28,490
consideration as they<font color="#CCCCCC"> design</font><font color="#E5E5E5"> sha-3 and</font>

839
00:35:26,390 --> 00:35:30,500
it's not susceptible and the<font color="#E5E5E5"> only</font>

840
00:35:28,490 --> 00:35:33,109
distinction is if you don't reveal the

841
00:35:30,500 --> 00:35:34,950
entire<font color="#E5E5E5"> state of the hash you can't like</font>

842
00:35:33,110 --> 00:35:38,070
rewind and go back into<font color="#CCCCCC"> that</font>

843
00:35:34,950 --> 00:35:39,810
<font color="#E5E5E5">eight and continue so this seems like</font>

844
00:35:38,070 --> 00:35:42,930
something who would ever make this

845
00:35:39,810 --> 00:35:44,130
mistake well flickr did which may have

846
00:35:42,930 --> 00:35:46,078
been<font color="#E5E5E5"> more important when they made the</font>

847
00:35:44,130 --> 00:35:47,339
mistake than they are today so<font color="#CCCCCC"> i think</font>

848
00:35:46,079 --> 00:35:51,270
they're associated with<font color="#E5E5E5"> yahoo or</font>

849
00:35:47,339 --> 00:35:52,799
something so they had an<font color="#E5E5E5"> api which kind</font>

850
00:35:51,270 --> 00:35:55,770
<font color="#E5E5E5">of if you think</font><font color="#CCCCCC"> about amazon web</font>

851
00:35:52,800 --> 00:35:58,079
services they have this idea of a signed

852
00:35:55,770 --> 00:35:59,849
URL which in reality should be called a

853
00:35:58,079 --> 00:36:03,420
<font color="#E5E5E5">mac to your elf because it's not a</font>

854
00:35:59,849 --> 00:36:05,220
symmetric but they had some URL we call

855
00:36:03,420 --> 00:36:07,380
an<font color="#CCCCCC"> API and you have a bunch</font><font color="#E5E5E5"> of</font>

856
00:36:05,220 --> 00:36:09,540
parameters saying like user ID equals

857
00:36:07,380 --> 00:36:12,540
this action equals that<font color="#E5E5E5"> maybe photo ID</font>

858
00:36:09,540 --> 00:36:15,599
equals something else and then a hash

859
00:36:12,540 --> 00:36:17,369
value so that you could hand this as a

860
00:36:15,599 --> 00:36:19,770
web application you can hand this URL

861
00:36:17,369 --> 00:36:21,900
out to a user's browser they could reach

862
00:36:19,770 --> 00:36:23,849
out<font color="#E5E5E5"> to the Flickr servers and those</font>

863
00:36:21,900 --> 00:36:26,760
servers could in turn verify that the

864
00:36:23,849 --> 00:36:27,990
user and application<font color="#CCCCCC"> everybody is</font><font color="#E5E5E5"> okay</font>

865
00:36:26,760 --> 00:36:31,589
with this and it's<font color="#E5E5E5"> not just some random</font>

866
00:36:27,990 --> 00:36:33,930
<font color="#E5E5E5">URL that your brute forcing so they had</font>

867
00:36:31,589 --> 00:36:37,020
had an API that looks<font color="#E5E5E5"> like this I the</font>

868
00:36:33,930 --> 00:36:39,299
paper at the bottom linked but the<font color="#E5E5E5"> moral</font>

869
00:36:37,020 --> 00:36:41,759
of the story was they were able<font color="#E5E5E5"> to do</font>

870
00:36:39,300 --> 00:36:43,920
the length extension attack combine this

871
00:36:41,760 --> 00:36:47,010
with some properties of HTTP query

872
00:36:43,920 --> 00:36:49,740
strings as well as the way in which<font color="#E5E5E5"> they</font>

873
00:36:47,010 --> 00:36:53,250
computed the hash to have a URL<font color="#CCCCCC"> that</font>

874
00:36:49,740 --> 00:36:55,049
looks like<font color="#E5E5E5"> this and you can't really see</font>

875
00:36:53,250 --> 00:36:57,150
because of this projector but where I

876
00:36:55,050 --> 00:37:00,240
have<font color="#E5E5E5"> the md5 padding it's very similar</font>

877
00:36:57,150 --> 00:37:02,339
to<font color="#E5E5E5"> what i just showed with a 80 000 00</font>

878
00:37:00,240 --> 00:37:05,490
and then a<font color="#E5E5E5"> link and then they were able</font>

879
00:37:02,339 --> 00:37:07,950
to<font color="#E5E5E5"> have essentially the original request</font>

880
00:37:05,490 --> 00:37:08,819
padding and then more data added on<font color="#CCCCCC"> the</font>

881
00:37:07,950 --> 00:37:10,500
end that did<font color="#E5E5E5"> something completely</font>

882
00:37:08,819 --> 00:37:13,950
different than<font color="#E5E5E5"> the original</font><font color="#CCCCCC"> one and the</font>

883
00:37:10,500 --> 00:37:15,800
server accepted it so this<font color="#CCCCCC"> is a big</font>

884
00:37:13,950 --> 00:37:17,939
problem but if you just use standard

885
00:37:15,800 --> 00:37:19,829
algorithms like<font color="#E5E5E5"> H</font><font color="#CCCCCC"> Mac you would have</font>

886
00:37:17,940 --> 00:37:24,150
been<font color="#E5E5E5"> fine so kind of embarrassing for</font>

887
00:37:19,829 --> 00:37:26,099
them another problem as these systems

888
00:37:24,150 --> 00:37:28,079
were thinking of thinking<font color="#CCCCCC"> about get more</font>

889
00:37:26,099 --> 00:37:29,790
and more<font color="#CCCCCC"> sophisticated say you are</font>

890
00:37:28,079 --> 00:37:32,520
indeed doing<font color="#E5E5E5"> encryption and</font>

891
00:37:29,790 --> 00:37:35,279
authentication well the problem<font color="#E5E5E5"> you have</font>

892
00:37:32,520 --> 00:37:37,940
is what order to do them in right at the

893
00:37:35,280 --> 00:37:40,800
two systems that you see<font color="#E5E5E5"> are see it was</font>

894
00:37:37,940 --> 00:37:42,690
integrity check and then encrypt well it

895
00:37:40,800 --> 00:37:46,170
turns<font color="#CCCCCC"> out that if you think about the</font>

896
00:37:42,690 --> 00:37:47,820
<font color="#E5E5E5">three ways</font><font color="#CCCCCC"> to do that modern practice is</font>

897
00:37:46,170 --> 00:37:50,130
you do the encryption first

898
00:37:47,820 --> 00:37:51,810
and whether the others are insecure or

899
00:37:50,130 --> 00:37:54,080
not depends on the specific protocol

900
00:37:51,810 --> 00:37:56,820
you're looking at but they're called

901
00:37:54,080 --> 00:38:00,000
encrypt then Mac which is as<font color="#E5E5E5"> it sounds</font>

902
00:37:56,820 --> 00:38:01,620
you have message and<font color="#E5E5E5"> it's hash or other</font>

903
00:38:00,000 --> 00:38:06,000
integrity check and encrypt the whole

904
00:38:01,620 --> 00:38:07,770
thing<font color="#CCCCCC"> and then or that's Mac then</font>

905
00:38:06,000 --> 00:38:11,220
encrypt encrypt then Mac is you<font color="#E5E5E5"> would</font>

906
00:38:07,770 --> 00:38:13,530
have the<font color="#CCCCCC"> okay this is very confusing as</font>

907
00:38:11,220 --> 00:38:16,950
you can see so encrypt and mac vs mac

908
00:38:13,530 --> 00:38:19,230
then encrypt versus encrypt then<font color="#CCCCCC"> mac so</font>

909
00:38:16,950 --> 00:38:20,669
do<font color="#E5E5E5"> you encrypt the hash</font><font color="#CCCCCC"> value or not and</font>

910
00:38:19,230 --> 00:38:24,150
do<font color="#E5E5E5"> you do it before or after encryption</font>

911
00:38:20,670 --> 00:38:25,950
is what it boils down<font color="#E5E5E5"> to and the encrypt</font>

912
00:38:24,150 --> 00:38:28,680
then<font color="#E5E5E5"> Mac is what is recommended today</font>

913
00:38:25,950 --> 00:38:32,879
the problem with the others is<font color="#E5E5E5"> the issue</font>

914
00:38:28,680 --> 00:38:35,810
of<font color="#E5E5E5"> padding so if you hatch or integrity</font>

915
00:38:32,880 --> 00:38:38,250
<font color="#CCCCCC">check cipher text and then encrypt the</font>

916
00:38:35,810 --> 00:38:40,290
plain text and then encrypt that plain

917
00:38:38,250 --> 00:38:42,150
tex actually changed a little bit in the

918
00:38:40,290 --> 00:38:45,930
process of encrypting by adding padding

919
00:38:42,150 --> 00:38:48,210
so block ciphers have to do this only

920
00:38:45,930 --> 00:38:50,310
<font color="#E5E5E5">and encrypt then Mac because the</font>

921
00:38:48,210 --> 00:38:51,540
encryption happens first is the value of

922
00:38:50,310 --> 00:38:53,250
<font color="#E5E5E5">the padding covered by the</font>

923
00:38:51,540 --> 00:38:55,259
<font color="#E5E5E5">authentication check and all the others</font>

924
00:38:53,250 --> 00:38:57,180
you can tamper with it and<font color="#E5E5E5"> the check</font>

925
00:38:55,260 --> 00:38:59,760
will still pass unless the padding

926
00:38:57,180 --> 00:39:03,060
itself fails but what<font color="#E5E5E5"> if the padding</font>

927
00:38:59,760 --> 00:39:05,370
itself is not<font color="#E5E5E5"> very well defined and it's</font>

928
00:39:03,060 --> 00:39:08,340
not<font color="#E5E5E5"> covered by the HVAC</font><font color="#CCCCCC"> and you can flip</font>

929
00:39:05,370 --> 00:39:10,290
bits or cut and<font color="#E5E5E5"> paste blocks around if</font>

930
00:39:08,340 --> 00:39:13,560
this starts to film familiar this is

931
00:39:10,290 --> 00:39:16,910
actually poodle<font color="#E5E5E5"> the kind of stake</font>

932
00:39:13,560 --> 00:39:21,299
through the heart for<font color="#E5E5E5"> SSL three-point</font><font color="#CCCCCC"> oh</font>

933
00:39:16,910 --> 00:39:26,549
the actual root of the problem is CBC

934
00:39:21,300 --> 00:39:28,170
encryption unlike<font color="#CCCCCC"> the actual rfcs that</font>

935
00:39:26,550 --> 00:39:31,320
have come out since that protocol

936
00:39:28,170 --> 00:39:33,930
existed the padding block which is<font color="#E5E5E5"> 16</font>

937
00:39:31,320 --> 00:39:35,730
byte was defined that just one single

938
00:39:33,930 --> 00:39:39,359
byte in there had to<font color="#CCCCCC"> have the size of</font>

939
00:39:35,730 --> 00:39:42,630
the padding right well what they<font color="#E5E5E5"> noticed</font>

940
00:39:39,360 --> 00:39:45,180
in that paper is by taking advantage<font color="#CCCCCC"> of</font>

941
00:39:42,630 --> 00:39:48,690
these<font color="#CCCCCC"> cbc attacks and kind of</font>

942
00:39:45,180 --> 00:39:50,339
controlling values before earlier in<font color="#E5E5E5"> the</font>

943
00:39:48,690 --> 00:39:53,070
process and<font color="#CCCCCC"> just cutting those blocks</font>

944
00:39:50,340 --> 00:39:54,720
away and putting them later you have the

945
00:39:53,070 --> 00:39:57,000
single bite that has to be correct<font color="#E5E5E5"> and</font>

946
00:39:54,720 --> 00:39:59,399
by random chance you have one and 256 of

947
00:39:57,000 --> 00:40:01,560
matching<font color="#E5E5E5"> and if you match that they were</font>

948
00:39:59,400 --> 00:40:04,740
able<font color="#E5E5E5"> to go bite by bite</font>

949
00:40:01,560 --> 00:40:06,570
and reconstruct values of session

950
00:40:04,740 --> 00:40:09,209
cookies and so forth and once you do

951
00:40:06,570 --> 00:40:11,460
that despite it being over SSL now you

952
00:40:09,210 --> 00:40:14,940
can just go<font color="#CCCCCC"> to the application directly</font>

953
00:40:11,460 --> 00:40:16,320
and be that user however if they had

954
00:40:14,940 --> 00:40:18,210
authenticated that padding by using

955
00:40:16,320 --> 00:40:21,720
encrypt then Mac they would have<font color="#E5E5E5"> been</font>

956
00:40:18,210 --> 00:40:24,210
<font color="#CCCCCC">okay so minor</font><font color="#E5E5E5"> little detail</font><font color="#CCCCCC"> like that is</font>

957
00:40:21,720 --> 00:40:25,589
why that's why i say this seems a little

958
00:40:24,210 --> 00:40:28,830
more interesting<font color="#E5E5E5"> than just encryption</font>

959
00:40:25,590 --> 00:40:30,840
alone often times<font color="#CCCCCC"> and the secondary</font>

960
00:40:28,830 --> 00:40:32,460
thing you thought an integrity check was

961
00:40:30,840 --> 00:40:34,620
for integrity but in this case it

962
00:40:32,460 --> 00:40:38,490
actually helped you out with conf yet

963
00:40:34,620 --> 00:40:40,620
confidentiality as well looking<font color="#E5E5E5"> at the</font>

964
00:40:38,490 --> 00:40:43,919
other purpose of integrity checks as<font color="#E5E5E5"> I</font>

965
00:40:40,620 --> 00:40:45,779
get ready<font color="#E5E5E5"> to close out here so the other</font>

966
00:40:43,920 --> 00:40:48,210
thing that kind of<font color="#E5E5E5"> falls out of the</font>

967
00:40:45,780 --> 00:40:51,060
design of an integrity check that's now

968
00:40:48,210 --> 00:40:53,160
used almost universally is you want to

969
00:40:51,060 --> 00:40:55,110
<font color="#E5E5E5">verify that a message</font><font color="#CCCCCC"> you receive today</font>

970
00:40:53,160 --> 00:40:57,390
and a message<font color="#CCCCCC"> you receive a year from</font>

971
00:40:55,110 --> 00:40:59,070
now are the same without storing it

972
00:40:57,390 --> 00:41:02,450
which is exactly the problem you have

973
00:40:59,070 --> 00:41:04,890
with passwords right but all the

974
00:41:02,450 --> 00:41:10,290
immediately intuitive ways of doing that

975
00:41:04,890 --> 00:41:12,600
are insecure pretty much so you might by

976
00:41:10,290 --> 00:41:14,850
<font color="#E5E5E5">looking at a hash function say</font><font color="#CCCCCC"> ok</font>

977
00:41:12,600 --> 00:41:16,620
<font color="#CCCCCC">one-way transform great you can</font><font color="#E5E5E5"> go one</font>

978
00:41:14,850 --> 00:41:20,040
way you can't go the other so you take a

979
00:41:16,620 --> 00:41:22,259
password password one you hash it and

980
00:41:20,040 --> 00:41:25,140
you get a hash value and you throw that

981
00:41:22,260 --> 00:41:27,750
in a database because of<font color="#CCCCCC"> preimage</font>

982
00:41:25,140 --> 00:41:30,509
<font color="#E5E5E5">resistance this wonderful property that</font>

983
00:41:27,750 --> 00:41:32,760
we studied of this algorithm we know

984
00:41:30,510 --> 00:41:35,180
that taking that hash and figuring out

985
00:41:32,760 --> 00:41:39,780
<font color="#E5E5E5">what</font><font color="#CCCCCC"> the password</font><font color="#E5E5E5"> was is infeasible</font>

986
00:41:35,180 --> 00:41:42,810
right well if the user use a weak

987
00:41:39,780 --> 00:41:44,430
password every common password is

988
00:41:42,810 --> 00:41:46,980
already out there as its hash has been

989
00:41:44,430 --> 00:41:49,529
pre computed in a dictionary<font color="#E5E5E5"> disk sizes</font>

990
00:41:46,980 --> 00:41:51,750
are large enough to soar very common

991
00:41:49,530 --> 00:41:53,850
words or even less common words you

992
00:41:51,750 --> 00:41:55,650
google an md5 of something that's not

993
00:41:53,850 --> 00:41:57,660
cryptographically secure or not a<font color="#E5E5E5"> good</font>

994
00:41:55,650 --> 00:42:01,320
password it's going to<font color="#E5E5E5"> come up in one of</font>

995
00:41:57,660 --> 00:42:02,970
<font color="#E5E5E5">these sites so this is you think this</font>

996
00:42:01,320 --> 00:42:04,590
would<font color="#CCCCCC"> be a solved problem but if you</font>

997
00:42:02,970 --> 00:42:06,810
look<font color="#E5E5E5"> at kind of these niche market web</font>

998
00:42:04,590 --> 00:42:08,550
applications that we see often like this

999
00:42:06,810 --> 00:42:13,080
has not been realized and fixed<font color="#E5E5E5"> even</font>

1000
00:42:08,550 --> 00:42:15,390
today and<font color="#E5E5E5"> I actually want to mention the</font>

1001
00:42:13,080 --> 00:42:19,650
LinkedIn breach<font color="#E5E5E5"> like two or three years</font>

1002
00:42:15,390 --> 00:42:24,390
ago<font color="#E5E5E5"> I think they had plane hashes I'll</font>

1003
00:42:19,650 --> 00:42:26,339
get<font color="#E5E5E5"> to the correct way a little on so</font>

1004
00:42:24,390 --> 00:42:28,828
given<font color="#E5E5E5"> all those failures what are the</font>

1005
00:42:26,339 --> 00:42:31,078
actual tools that we covered<font color="#CCCCCC"> and how do</font>

1006
00:42:28,829 --> 00:42:33,690
the one of the guarantees they provided

1007
00:42:31,079 --> 00:42:36,210
a little<font color="#E5E5E5"> more detail so I kind of</font>

1008
00:42:33,690 --> 00:42:38,549
covered one-way functions or hashes that

1009
00:42:36,210 --> 00:42:40,019
they're not<font color="#E5E5E5"> the only way once again you</font>

1010
00:42:38,549 --> 00:42:42,240
take a message you get<font color="#E5E5E5"> an integrity</font>

1011
00:42:40,019 --> 00:42:45,209
value message authentication codes a

1012
00:42:42,240 --> 00:42:46,709
keyed version of that authenticated

1013
00:42:45,210 --> 00:42:50,910
encryption I'll get to in a<font color="#E5E5E5"> little bit</font>

1014
00:42:46,710 --> 00:42:52,650
and digital signatures so one-way

1015
00:42:50,910 --> 00:42:54,328
functions you take a message you<font color="#E5E5E5"> get</font>

1016
00:42:52,650 --> 00:42:56,309
some transformation of it that can't be

1017
00:42:54,329 --> 00:42:59,130
reversed hashes are not the only way to

1018
00:42:56,309 --> 00:43:01,529
do<font color="#CCCCCC"> that and another way is you can take</font>

1019
00:42:59,130 --> 00:43:03,779
a CBC mode<font color="#E5E5E5"> cipher and kind of manipulate</font>

1020
00:43:01,529 --> 00:43:06,569
it in a certain way to<font color="#E5E5E5"> get what you</font>

1021
00:43:03,779 --> 00:43:07,859
might call a hashing algorithm remember

1022
00:43:06,569 --> 00:43:09,359
those properties I don't want to

1023
00:43:07,859 --> 00:43:12,960
reiterate them again<font color="#E5E5E5"> because they just</font>

1024
00:43:09,359 --> 00:43:16,109
confuse me and you most<font color="#E5E5E5"> likely maybe not</font>

1025
00:43:12,960 --> 00:43:19,289
everybody but I think a notable property

1026
00:43:16,109 --> 00:43:21,750
here is unlike symmetric encryption

1027
00:43:19,289 --> 00:43:23,819
which we still have plenty<font color="#E5E5E5"> of things</font>

1028
00:43:21,750 --> 00:43:26,130
<font color="#E5E5E5">from the 70s and 80s that are failing</font>

1029
00:43:23,819 --> 00:43:28,319
because of key length rather than other

1030
00:43:26,130 --> 00:43:30,900
properties like<font color="#E5E5E5"> Triple DES or something</font>

1031
00:43:28,319 --> 00:43:34,170
or even our c4s kind of just in the past

1032
00:43:30,900 --> 00:43:36,150
few years been like unusable they tend

1033
00:43:34,170 --> 00:43:40,109
to catastrophic<font color="#CCCCCC"> lee fail not very long</font>

1034
00:43:36,150 --> 00:43:42,779
after they come<font color="#E5E5E5"> out I've noticed so md4</font>

1035
00:43:40,109 --> 00:43:45,390
still has some residual uses and some NT

1036
00:43:42,779 --> 00:43:47,430
password things I belief and then md5

1037
00:43:45,390 --> 00:43:49,710
and<font color="#E5E5E5"> then sha-1 all three of those or</font>

1038
00:43:47,430 --> 00:43:51,000
like do not<font color="#E5E5E5"> use at this point because of</font>

1039
00:43:49,710 --> 00:43:53,400
collision problem so<font color="#CCCCCC"> if</font><font color="#E5E5E5"> you think about</font>

1040
00:43:51,000 --> 00:43:54,980
it like sha-1 something coming out in

1041
00:43:53,400 --> 00:43:57,180
the mid-90s and twenty years later

1042
00:43:54,980 --> 00:43:58,980
considerably completely unusable and

1043
00:43:57,180 --> 00:44:00,690
it's reputable people that came up<font color="#E5E5E5"> with</font>

1044
00:43:58,980 --> 00:44:04,529
these<font color="#E5E5E5"> things it's obviously much more</font>

1045
00:44:00,690 --> 00:44:07,319
difficult than just<font color="#CCCCCC"> a plain cipher so</font>

1046
00:44:04,529 --> 00:44:10,289
recommended today are<font color="#E5E5E5"> Shaw to and</font><font color="#CCCCCC"> Shaw</font>

1047
00:44:07,319 --> 00:44:11,849
three sha three is more recent<font color="#E5E5E5"> and may</font>

1048
00:44:10,289 --> 00:44:14,730
<font color="#CCCCCC">not be in all the library so you want</font>

1049
00:44:11,849 --> 00:44:17,490
you that we would use shot too can be a

1050
00:44:14,730 --> 00:44:20,099
little confusing because<font color="#CCCCCC"> sha 384 is</font>

1051
00:44:17,490 --> 00:44:25,529
considered a 384-bit long version of

1052
00:44:20,099 --> 00:44:27,539
<font color="#E5E5E5">Shaw to and that notch 03 if you need to</font>

1053
00:44:25,529 --> 00:44:29,310
implement method message authentication

1054
00:44:27,539 --> 00:44:32,040
codes or use one remember

1055
00:44:29,310 --> 00:44:35,160
or that it's not just adding a key to a

1056
00:44:32,040 --> 00:44:37,259
one-way function H<font color="#E5E5E5"> Mack is probably the</font>

1057
00:44:35,160 --> 00:44:39,089
<font color="#CCCCCC">most popular it's not the only</font><font color="#E5E5E5"> way don't</font>

1058
00:44:37,260 --> 00:44:41,130
build your own if<font color="#E5E5E5"> you look at</font><font color="#CCCCCC"> the</font>

1059
00:44:39,090 --> 00:44:42,960
implementation of<font color="#E5E5E5"> H Mac it's actually a</font>

1060
00:44:41,130 --> 00:44:45,840
hash inside of a hash with these weird

1061
00:44:42,960 --> 00:44:47,940
constants added in there for various

1062
00:44:45,840 --> 00:44:49,770
reasons that theoretically give you

1063
00:44:47,940 --> 00:44:52,770
certain guarantees so I<font color="#E5E5E5"> don't tamper</font>

1064
00:44:49,770 --> 00:44:55,230
with that and an interesting<font color="#CCCCCC"> point as I</font>

1065
00:44:52,770 --> 00:44:58,440
mentioned<font color="#CCCCCC"> before because H Mac is so</font>

1066
00:44:55,230 --> 00:45:01,230
well defined or<font color="#CCCCCC"> well-designed even if a</font>

1067
00:44:58,440 --> 00:45:03,840
collision is found in the hash the H Mac

1068
00:45:01,230 --> 00:45:05,160
might not itself be broken and this is

1069
00:45:03,840 --> 00:45:06,900
something<font color="#CCCCCC"> that's a little important to</font>

1070
00:45:05,160 --> 00:45:10,200
me because I write recommendations and

1071
00:45:06,900 --> 00:45:13,140
reports say they're using<font color="#E5E5E5"> hmm</font><font color="#CCCCCC"> b5 well</font>

1072
00:45:10,200 --> 00:45:15,750
this<font color="#CCCCCC"> is not like</font><font color="#E5E5E5"> critical places on fire</font>

1073
00:45:13,140 --> 00:45:17,850
you can say there are RFC's out there

1074
00:45:15,750 --> 00:45:20,130
that are kind of like halfway on the

1075
00:45:17,850 --> 00:45:21,960
point like updating considerations for

1076
00:45:20,130 --> 00:45:24,930
md5 and if you search for that you'll

1077
00:45:21,960 --> 00:45:26,970
see it but it says like hmm<font color="#E5E5E5"> v5 is not</font>

1078
00:45:24,930 --> 00:45:28,560
necessarily broken but in the spirit of

1079
00:45:26,970 --> 00:45:30,149
deprecating algorithms when they're weak

1080
00:45:28,560 --> 00:45:33,180
like it's a very weak statement like

1081
00:45:30,150 --> 00:45:36,810
that<font color="#CCCCCC"> hmh cha one is considered like good</font>

1082
00:45:33,180 --> 00:45:39,270
to go still so as you<font color="#CCCCCC"> look</font><font color="#E5E5E5"> at that</font>

1083
00:45:36,810 --> 00:45:40,980
problem what if you could encrypt

1084
00:45:39,270 --> 00:45:43,170
something and authenticate it in one

1085
00:45:40,980 --> 00:45:46,080
step it's difficult to do incorrectly

1086
00:45:43,170 --> 00:45:48,480
and that's the idea behind authenticated

1087
00:45:46,080 --> 00:45:50,370
encryption and part of<font color="#E5E5E5"> their that's less</font>

1088
00:45:48,480 --> 00:45:53,970
opportunity for mistakes if the

1089
00:45:50,370 --> 00:45:56,130
encryption process is a black box API to

1090
00:45:53,970 --> 00:45:59,730
the developer and this is the mindset

1091
00:45:56,130 --> 00:46:01,470
behind<font color="#E5E5E5"> AES GCM or gal counter mode in</font>

1092
00:45:59,730 --> 00:46:04,230
<font color="#E5E5E5">addition to some others that</font><font color="#CCCCCC"> are less</font>

1093
00:46:01,470 --> 00:46:07,200
popular and the reason this is important

1094
00:46:04,230 --> 00:46:12,510
is particularly for best practices in

1095
00:46:07,200 --> 00:46:15,149
TLS and ssh both of those offer GCM and

1096
00:46:12,510 --> 00:46:18,090
modern versions and that's<font color="#E5E5E5"> the best way</font>

1097
00:46:15,150 --> 00:46:20,850
to go because<font color="#E5E5E5"> the whole historical order</font>

1098
00:46:18,090 --> 00:46:22,620
of mac and encrypt just goes away if you

1099
00:46:20,850 --> 00:46:25,319
<font color="#E5E5E5">use that it's also faster than doing the</font>

1100
00:46:22,620 --> 00:46:28,200
to a separate steps so that's important

1101
00:46:25,320 --> 00:46:30,270
when you think about a ESN<font color="#CCCCCC"> i and other</font>

1102
00:46:28,200 --> 00:46:31,560
performance improvements and making sure

1103
00:46:30,270 --> 00:46:36,450
you get one hundred percent of the

1104
00:46:31,560 --> 00:46:38,400
benefit of those final review on digital

1105
00:46:36,450 --> 00:46:41,430
signatures it's basically a<font color="#E5E5E5"> Mac but</font>

1106
00:46:38,400 --> 00:46:42,880
<font color="#CCCCCC">asymmetric so anyone can verify</font><font color="#E5E5E5"> it but</font>

1107
00:46:41,430 --> 00:46:45,910
<font color="#CCCCCC">only one person can</font>

1108
00:46:42,880 --> 00:46:48,849
the important thing though is that these

1109
00:46:45,910 --> 00:46:51,700
use one-way functions like hashes in

1110
00:46:48,849 --> 00:46:56,440
their raw forms internally as part of

1111
00:46:51,700 --> 00:46:58,960
that<font color="#E5E5E5"> process so a RSA certificate has a</font>

1112
00:46:56,440 --> 00:47:01,680
shot if you<font color="#E5E5E5"> see 256 hash of things</font>

1113
00:46:58,960 --> 00:47:05,289
inside<font color="#E5E5E5"> it so if the collision is found</font>

1114
00:47:01,680 --> 00:47:08,470
unlike H max the whole system goes away

1115
00:47:05,289 --> 00:47:10,240
so md5 this is like 10 years ago<font color="#E5E5E5"> at this</font>

1116
00:47:08,470 --> 00:47:14,470
point you can modify a certificate and

1117
00:47:10,240 --> 00:47:16,720
reconstruct the hash and and break TLS

1118
00:47:14,470 --> 00:47:18,578
or other system in that way when you

1119
00:47:16,720 --> 00:47:20,348
think of digital signature think of RSA

1120
00:47:18,579 --> 00:47:24,369
and ecdsa two most common

1121
00:47:20,349 --> 00:47:27,279
implementations so<font color="#E5E5E5"> closing out as a</font>

1122
00:47:24,369 --> 00:47:28,599
developer or security person what should

1123
00:47:27,279 --> 00:47:29,950
you know about<font color="#CCCCCC"> these things if nothing</font>

1124
00:47:28,599 --> 00:47:33,549
else and<font color="#E5E5E5"> that will be the</font>

1125
00:47:29,950 --> 00:47:36,089
recommendations so if you are developing

1126
00:47:33,549 --> 00:47:38,710
<font color="#E5E5E5">an application or just as an end user</font>

1127
00:47:36,089 --> 00:47:40,450
you run<font color="#E5E5E5"> into a situation where you're</font>

1128
00:47:38,710 --> 00:47:43,359
doing something security relevant that

1129
00:47:40,450 --> 00:47:45,759
requires message integrity if you're

1130
00:47:43,359 --> 00:47:48,519
making some system that has multiple

1131
00:47:45,759 --> 00:47:51,940
network nodes or<font color="#E5E5E5"> IOT since I'm from the</font>

1132
00:47:48,519 --> 00:47:53,859
IOT village just use TLS if you can or

1133
00:47:51,940 --> 00:47:55,509
maybe use SSH if that's more appropriate

1134
00:47:53,859 --> 00:47:58,390
for what you're doing don't design your

1135
00:47:55,509 --> 00:48:01,329
own and if<font color="#E5E5E5"> you do insist on designing</font>

1136
00:47:58,390 --> 00:48:04,000
your own as a blank slate<font color="#CCCCCC"> today really</font>

1137
00:48:01,329 --> 00:48:06,460
look at aes<font color="#CCCCCC"> GCM mode for performance and</font>

1138
00:48:04,000 --> 00:48:09,160
the stronger and more difficult ways of

1139
00:48:06,460 --> 00:48:11,619
messing it up on the other<font color="#CCCCCC"> side if</font>

1140
00:48:09,160 --> 00:48:14,710
you're doing passwords don't<font color="#E5E5E5"> say well</font>

1141
00:48:11,619 --> 00:48:16,420
we'll md5 this and our salt is this just

1142
00:48:14,710 --> 00:48:20,049
use one of these built-in algorithms

1143
00:48:16,420 --> 00:48:21,579
like PB<font color="#CCCCCC"> kdf to be crypt s script and so</font>

1144
00:48:20,049 --> 00:48:23,859
on they're actually designed for

1145
00:48:21,579 --> 00:48:25,450
deriving a cryptographic key from a

1146
00:48:23,859 --> 00:48:27,670
password but<font color="#E5E5E5"> you can use them for</font>

1147
00:48:25,450 --> 00:48:31,149
verification as well current

1148
00:48:27,670 --> 00:48:32,859
recommendations are enforce a minimum

1149
00:48:31,150 --> 00:48:35,140
length and perform a dictionary check

1150
00:48:32,859 --> 00:48:37,660
this is actually things going on with

1151
00:48:35,140 --> 00:48:39,578
the nist SP process right now<font color="#E5E5E5"> where a</font>

1152
00:48:37,660 --> 00:48:42,359
lot of the old wisdom like password

1153
00:48:39,579 --> 00:48:44,980
aging and so many<font color="#E5E5E5"> exclamation points and</font>

1154
00:48:42,359 --> 00:48:47,230
security questions all<font color="#E5E5E5"> that is actually</font>

1155
00:48:44,980 --> 00:48:49,920
not just security people frustrated with

1156
00:48:47,230 --> 00:48:52,329
that the actual government<font color="#E5E5E5"> standards</font>

1157
00:48:49,920 --> 00:48:55,490
community<font color="#CCCCCC"> is starting to realize that</font>

1158
00:48:52,329 --> 00:49:00,490
and move away from it as<font color="#E5E5E5"> well so</font>

1159
00:48:55,490 --> 00:49:00,490
Oh closing out at 4957 any questions

1160
00:49:03,040 --> 00:49:08,509
<font color="#CCCCCC">okay so i</font><font color="#E5E5E5"> will have these they're not on</font>

1161
00:49:06,530 --> 00:49:11,480
our ifc website immediately but i'll get

1162
00:49:08,510 --> 00:49:13,970
them there sometime tomorrow and in the

1163
00:49:11,480 --> 00:49:16,820
<font color="#E5E5E5">meantime if you go to demo dot security</font>

1164
00:49:13,970 --> 00:49:18,319
evaluators calm / integrity you can play

1165
00:49:16,820 --> 00:49:23,350
with some<font color="#E5E5E5"> of those examples if you so</font>

1166
00:49:18,320 --> 00:49:23,350
desire all right thank<font color="#CCCCCC"> you</font>

