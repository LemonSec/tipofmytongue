1
00:00:02,290 --> 00:00:06,560
[Music]

2
00:00:06,560 --> 00:00:08,000
good afternoon everybody

3
00:00:08,000 --> 00:00:10,559
uh my name is tripty and today we will

4
00:00:10,559 --> 00:00:13,120
be talking about serverless applications

5
00:00:13,120 --> 00:00:13,440
and

6
00:00:13,440 --> 00:00:16,400
how we can secure them using

7
00:00:16,400 --> 00:00:18,640
microservices secure design

8
00:00:18,640 --> 00:00:21,920
what are the things that we cannot uh

9
00:00:21,920 --> 00:00:24,240
secure using these design patterns and

10
00:00:24,240 --> 00:00:25,039
for that

11
00:00:25,039 --> 00:00:28,320
uh what do we need to do and

12
00:00:28,320 --> 00:00:31,359
before i begin and tell you guys about

13
00:00:31,359 --> 00:00:34,880
myself i would like to express gratitude

14
00:00:34,880 --> 00:00:36,719
to the entire crew

15
00:00:36,719 --> 00:00:40,160
of seattle b-sides volunteers

16
00:00:40,160 --> 00:00:42,840
and organizers for giving this awesome

17
00:00:42,840 --> 00:00:44,719
opportunity in the middle of the

18
00:00:44,719 --> 00:00:47,039
pandemic

19
00:00:47,039 --> 00:00:49,600
so thank you very much guys now little

20
00:00:49,600 --> 00:00:50,879
bit about me

21
00:00:50,879 --> 00:00:53,600
uh as i said my name is tripty currently

22
00:00:53,600 --> 00:00:54,480
i'm working

23
00:00:54,480 --> 00:00:56,559
as a principal application security

24
00:00:56,559 --> 00:00:59,359
engineer at elimio

25
00:00:59,359 --> 00:01:02,000
it's been 13 years but i started my

26
00:01:02,000 --> 00:01:04,239
career as a mobile game developer

27
00:01:04,239 --> 00:01:06,479
and after doing game development for a

28
00:01:06,479 --> 00:01:07,680
couple of years

29
00:01:07,680 --> 00:01:10,960
i realized my passion is a security

30
00:01:10,960 --> 00:01:13,200
when i'm not doing security i like to

31
00:01:13,200 --> 00:01:15,040
travel and paint

32
00:01:15,040 --> 00:01:17,759
and about four or five years back i also

33
00:01:17,759 --> 00:01:19,439
got my yoga teacher's training

34
00:01:19,439 --> 00:01:22,159
certificate so at illimeo i not only

35
00:01:22,159 --> 00:01:25,040
uh do security i also teach weekly

36
00:01:25,040 --> 00:01:26,720
meditation classes and breathing

37
00:01:26,720 --> 00:01:28,320
exercises

38
00:01:28,320 --> 00:01:30,159
after this talk if you want to get in

39
00:01:30,159 --> 00:01:31,840
touch with me this is my

40
00:01:31,840 --> 00:01:34,880
contact information

41
00:01:34,960 --> 00:01:37,840
so this is today's agenda in next 1 hour

42
00:01:37,840 --> 00:01:39,360
i will be

43
00:01:39,360 --> 00:01:42,399
covering what serverless applications

44
00:01:42,399 --> 00:01:45,119
are what what do you mean by serverless

45
00:01:45,119 --> 00:01:47,360
in the context of microservices how they

46
00:01:47,360 --> 00:01:47,600
are

47
00:01:47,600 --> 00:01:50,880
evolved and then how we can analyze some

48
00:01:50,880 --> 00:01:51,680
of the

49
00:01:51,680 --> 00:01:53,680
microservices design pattern from

50
00:01:53,680 --> 00:01:55,119
security perspective

51
00:01:55,119 --> 00:01:57,040
and towards the end i will be talking

52
00:01:57,040 --> 00:01:58,640
about some of the best

53
00:01:58,640 --> 00:02:01,520
practices for securing serverless

54
00:02:01,520 --> 00:02:04,079
applications and microservices

55
00:02:04,079 --> 00:02:06,880
all right so let's begin let's start

56
00:02:06,880 --> 00:02:08,080
with evolution

57
00:02:08,080 --> 00:02:10,800
and then try to understand uh what are

58
00:02:10,800 --> 00:02:11,840
the security

59
00:02:11,840 --> 00:02:14,959
pain points and how the overall role of

60
00:02:14,959 --> 00:02:16,000
security has

61
00:02:16,000 --> 00:02:19,440
changed with the evolution of

62
00:02:19,440 --> 00:02:23,520
microservices serverless

63
00:02:23,520 --> 00:02:26,959
awesome so as you can see

64
00:02:26,959 --> 00:02:29,280
on the left hand side there is a

65
00:02:29,280 --> 00:02:30,879
monolith application

66
00:02:30,879 --> 00:02:34,000
if you remember around 15 to 20 years

67
00:02:34,000 --> 00:02:36,720
back the world was full of monolith

68
00:02:36,720 --> 00:02:39,280
giant applications which contain a

69
00:02:39,280 --> 00:02:40,959
typical ui layer

70
00:02:40,959 --> 00:02:43,360
then a big fat business logic layer

71
00:02:43,360 --> 00:02:44,959
which was tightly coupled

72
00:02:44,959 --> 00:02:47,680
with the back end data layer and then

73
00:02:47,680 --> 00:02:48,319
around

74
00:02:48,319 --> 00:02:51,760
10-12 years back we saw the industry is

75
00:02:51,760 --> 00:02:53,120
moving more towards

76
00:02:53,120 --> 00:02:55,280
loosely coupled service oriented

77
00:02:55,280 --> 00:02:56,239
architecture

78
00:02:56,239 --> 00:02:58,400
but that was not sufficient and that's

79
00:02:58,400 --> 00:02:59,519
exactly when

80
00:02:59,519 --> 00:03:03,120
we started seeing rise in microservices

81
00:03:03,120 --> 00:03:05,680
so if you look at microservices these

82
00:03:05,680 --> 00:03:07,200
are nothing but

83
00:03:07,200 --> 00:03:09,280
more loosely coupled service oriented

84
00:03:09,280 --> 00:03:11,920
architecture

85
00:03:11,920 --> 00:03:15,120
and lately in last five six years we are

86
00:03:15,120 --> 00:03:15,599
seeing

87
00:03:15,599 --> 00:03:18,159
rise in serverless applications some of

88
00:03:18,159 --> 00:03:20,720
the serverless applications are aws

89
00:03:20,720 --> 00:03:22,720
lambda google functions and we will be

90
00:03:22,720 --> 00:03:24,159
talking a lot about them

91
00:03:24,159 --> 00:03:26,879
today but before we jump there i just

92
00:03:26,879 --> 00:03:27,599
want to put

93
00:03:27,599 --> 00:03:30,799
things into perspective um

94
00:03:30,799 --> 00:03:34,560
some of the uh applications which were

95
00:03:34,560 --> 00:03:36,080
built monolith

96
00:03:36,080 --> 00:03:38,319
it takes a lot of time to break them

97
00:03:38,319 --> 00:03:39,280
down into

98
00:03:39,280 --> 00:03:41,519
a micro service oriented architecture

99
00:03:41,519 --> 00:03:42,799
for example

100
00:03:42,799 --> 00:03:45,519
netflix original application was a

101
00:03:45,519 --> 00:03:46,080
monolith

102
00:03:46,080 --> 00:03:48,400
application and it took netflix two

103
00:03:48,400 --> 00:03:50,720
years to break it down split into

104
00:03:50,720 --> 00:03:52,560
a nice micro service oriented

105
00:03:52,560 --> 00:03:54,799
architecture and then

106
00:03:54,799 --> 00:03:57,760
uh it took them seven years to complete

107
00:03:57,760 --> 00:03:59,040
that transition

108
00:03:59,040 --> 00:04:01,599
from the giant monolith to microservices

109
00:04:01,599 --> 00:04:03,120
so as you can imagine

110
00:04:03,120 --> 00:04:06,159
this is not something easy what this

111
00:04:06,159 --> 00:04:08,400
transition really meant to netflix was

112
00:04:08,400 --> 00:04:10,799
they were a traditional development

113
00:04:10,799 --> 00:04:11,760
company

114
00:04:11,760 --> 00:04:13,920
with 100 engineers producing a

115
00:04:13,920 --> 00:04:16,639
monolithic dvd rental application

116
00:04:16,639 --> 00:04:19,040
and when they uh changed their

117
00:04:19,040 --> 00:04:21,519
architecture to micro service oriented

118
00:04:21,519 --> 00:04:24,080
they became multi they divided

119
00:04:24,080 --> 00:04:26,720
themselves among multiple small teams

120
00:04:26,720 --> 00:04:29,520
responsible for end-to-end developments

121
00:04:29,520 --> 00:04:29,759
of

122
00:04:29,759 --> 00:04:32,400
hundreds of microservices that work

123
00:04:32,400 --> 00:04:33,199
together

124
00:04:33,199 --> 00:04:36,240
to stream the digital entertainment uh

125
00:04:36,240 --> 00:04:38,560
to millions of netflix customers

126
00:04:38,560 --> 00:04:40,320
that we are enjoying pretty much every

127
00:04:40,320 --> 00:04:42,800
day in this pandemic

128
00:04:42,800 --> 00:04:45,120
so when it comes to serverless

129
00:04:45,120 --> 00:04:47,600
serverless is actually a deployment type

130
00:04:47,600 --> 00:04:49,360
of microservices only

131
00:04:49,360 --> 00:04:52,240
now the big question is are serverless

132
00:04:52,240 --> 00:04:53,199
application

133
00:04:53,199 --> 00:04:56,639
going to replace service oriented

134
00:04:56,639 --> 00:04:57,440
architecture

135
00:04:57,440 --> 00:05:00,000
microservice architecture well the

136
00:05:00,000 --> 00:05:01,680
answer is

137
00:05:01,680 --> 00:05:04,400
serverless applications have some

138
00:05:04,400 --> 00:05:05,840
serious limitation

139
00:05:05,840 --> 00:05:09,840
so they definitely cannot replace

140
00:05:09,840 --> 00:05:12,160
what we will see in the industry is

141
00:05:12,160 --> 00:05:14,400
serverless and microservices

142
00:05:14,400 --> 00:05:17,840
will exist together now let's

143
00:05:17,840 --> 00:05:21,440
dive deep into what serverless

144
00:05:21,440 --> 00:05:25,440
applications really are

145
00:05:25,440 --> 00:05:28,479
as the name suggests in serverless

146
00:05:28,479 --> 00:05:31,360
we don't have to manage the servers

147
00:05:31,360 --> 00:05:32,880
management of servers

148
00:05:32,880 --> 00:05:35,120
patches and whatnot and other

149
00:05:35,120 --> 00:05:37,120
operational duties are performed by the

150
00:05:37,120 --> 00:05:38,479
cloud provider

151
00:05:38,479 --> 00:05:40,880
serverless applications are like these

152
00:05:40,880 --> 00:05:42,479
extracted service

153
00:05:42,479 --> 00:05:44,320
which are even driven they are

154
00:05:44,320 --> 00:05:46,800
short-lived and stateless

155
00:05:46,800 --> 00:05:49,120
the beauty of serverless application is

156
00:05:49,120 --> 00:05:49,840
they can

157
00:05:49,840 --> 00:05:53,120
scale up on demand or scale down

158
00:05:53,120 --> 00:05:56,560
up on demand and from business

159
00:05:56,560 --> 00:05:58,319
perspective the best benefit

160
00:05:58,319 --> 00:06:01,919
is you pay as you use and that's exactly

161
00:06:01,919 --> 00:06:04,000
what serverless application that's what

162
00:06:04,000 --> 00:06:04,880
exactly

163
00:06:04,880 --> 00:06:07,199
serverless applications are now let's

164
00:06:07,199 --> 00:06:08,080
take a

165
00:06:08,080 --> 00:06:11,199
a deeper look into different attributes

166
00:06:11,199 --> 00:06:14,319
from modularity perspective we have seen

167
00:06:14,319 --> 00:06:17,120
that monoliths are very tightly coupled

168
00:06:17,120 --> 00:06:17,840
whereas

169
00:06:17,840 --> 00:06:20,319
microservices are loosely coupled just

170
00:06:20,319 --> 00:06:22,160
like serverless application

171
00:06:22,160 --> 00:06:23,680
when it comes to inter process

172
00:06:23,680 --> 00:06:25,520
communication

173
00:06:25,520 --> 00:06:27,759
monolith applications uses heavyweight

174
00:06:27,759 --> 00:06:29,440
protocols like so

175
00:06:29,440 --> 00:06:31,759
but microservices use lightweight

176
00:06:31,759 --> 00:06:34,479
protocol like rest or grpc

177
00:06:34,479 --> 00:06:36,880
serverless we often see the user rest

178
00:06:36,880 --> 00:06:38,000
api

179
00:06:38,000 --> 00:06:40,560
when it comes to handling data we have

180
00:06:40,560 --> 00:06:43,440
seen with monolith applications

181
00:06:43,440 --> 00:06:46,880
we uh most of these applications use

182
00:06:46,880 --> 00:06:48,240
global data model or

183
00:06:48,240 --> 00:06:51,599
shared databases whereas microservices

184
00:06:51,599 --> 00:06:54,240
they use data models smaller data models

185
00:06:54,240 --> 00:06:56,800
or database per services

186
00:06:56,800 --> 00:06:59,199
and in case of serverless we all know

187
00:06:59,199 --> 00:07:00,960
the data is f armor

188
00:07:00,960 --> 00:07:02,400
and we are going to talk a little bit

189
00:07:02,400 --> 00:07:04,400
more about it after a few slides

190
00:07:04,400 --> 00:07:06,240
what are the threads associated with the

191
00:07:06,240 --> 00:07:09,599
data handled by serverless

192
00:07:09,599 --> 00:07:13,360
now let's talk about deployment model

193
00:07:13,360 --> 00:07:17,199
imagine what it takes to deploy a giant

194
00:07:17,199 --> 00:07:19,599
monolith application lots and lots of

195
00:07:19,599 --> 00:07:20,400
time

196
00:07:20,400 --> 00:07:21,919
therefore the overall speed of

197
00:07:21,919 --> 00:07:23,919
development uh sorry deployment

198
00:07:23,919 --> 00:07:27,599
is slow whereas microservices these are

199
00:07:27,599 --> 00:07:29,840
small independent services so the speed

200
00:07:29,840 --> 00:07:31,840
of deployment is quite fast

201
00:07:31,840 --> 00:07:34,319
and when it comes to serverless because

202
00:07:34,319 --> 00:07:36,560
majority of the operational tasks are

203
00:07:36,560 --> 00:07:39,039
taken care by cloud service provider

204
00:07:39,039 --> 00:07:42,960
the deployment speed is even more faster

205
00:07:42,960 --> 00:07:45,680
now let's take a look at some of the

206
00:07:45,680 --> 00:07:48,720
micro services pain point

207
00:07:48,720 --> 00:07:50,400
and i'm going to play a short video here

208
00:07:50,400 --> 00:07:52,000
still not understanding this why is it

209
00:07:52,000 --> 00:07:54,000
so hard to display the birthday date on

210
00:07:54,000 --> 00:07:55,039
the settings page

211
00:07:55,039 --> 00:07:56,400
why can't we get this done this quarter

212
00:07:56,400 --> 00:07:58,160
look i'm sorry we've been over this it's

213
00:07:58,160 --> 00:07:59,520
the design of our back end

214
00:07:59,520 --> 00:08:01,360
first people call the bingo service see

215
00:08:01,360 --> 00:08:03,120
bingo knows everyone's name though so we

216
00:08:03,120 --> 00:08:04,800
get the user's id out of there and for

217
00:08:04,800 --> 00:08:05,360
bingo

218
00:08:05,360 --> 00:08:07,680
we can call papaya and mbs to get that

219
00:08:07,680 --> 00:08:09,520
user id and turn it into a user session

220
00:08:09,520 --> 00:08:10,080
token

221
00:08:10,080 --> 00:08:11,919
we can validate those with old knob and

222
00:08:11,919 --> 00:08:13,199
then once we have that

223
00:08:13,199 --> 00:08:15,039
we can finally pull the user's info down

224
00:08:15,039 --> 00:08:16,639
from raccoon yeah but couldn't the

225
00:08:16,639 --> 00:08:18,639
raccoon team basically just no raccoon

226
00:08:18,639 --> 00:08:20,240
isn't guaranteed to have that info

227
00:08:20,240 --> 00:08:22,000
before we do this we have to go

228
00:08:22,000 --> 00:08:23,599
to a query to see if the user is willing

229
00:08:23,599 --> 00:08:25,120
to take it to the next level or they're

230
00:08:25,120 --> 00:08:26,240
just playing the field

231
00:08:26,240 --> 00:08:28,240
now wingman is cool but he doesn't store

232
00:08:28,240 --> 00:08:30,000
any user info himself he has to reach

233
00:08:30,000 --> 00:08:32,080
out to other user info provider services

234
00:08:32,080 --> 00:08:33,200
like rgs

235
00:08:33,200 --> 00:08:36,640
barbie doll ringo 2 pll

236
00:08:36,640 --> 00:08:37,839
but how does it know what all the user

237
00:08:37,839 --> 00:08:39,839
provider services are well for that it

238
00:08:39,839 --> 00:08:41,279
has to go to go active

239
00:08:41,279 --> 00:08:42,719
all knowing user service provider

240
00:08:42,719 --> 00:08:44,880
activator

241
00:08:44,880 --> 00:08:46,720
galactus has a mission knowledge of all

242
00:08:46,720 --> 00:08:48,160
current user input providers

243
00:08:48,160 --> 00:08:49,680
it doesn't have future site or knowledge

244
00:08:49,680 --> 00:08:51,440
of past user input providers so it

245
00:08:51,440 --> 00:08:52,480
expects a time limit

246
00:08:52,480 --> 00:08:53,680
to get all the current user input

247
00:08:53,680 --> 00:08:55,279
providers we need to pass a time range

248
00:08:55,279 --> 00:08:56,160
of the current time

249
00:08:56,160 --> 00:08:57,440
and a time representing the end of the

250
00:08:57,440 --> 00:08:59,360
universe we get from eks

251
00:08:59,360 --> 00:09:02,640
our entry chaos service vks is being

252
00:09:02,640 --> 00:09:03,920
deprecated at the end of the month for

253
00:09:03,920 --> 00:09:04,880
ominous

254
00:09:04,880 --> 00:09:07,040
megastar still doesn't support iso

255
00:09:07,040 --> 00:09:08,800
timestamps like they said they would a

256
00:09:08,800 --> 00:09:09,440
month ago

257
00:09:09,440 --> 00:09:11,200
so until omega star gets their

258
00:09:11,200 --> 00:09:13,040
 together we're blocked

259
00:09:13,040 --> 00:09:14,560
we can't get signed up for our use case

260
00:09:14,560 --> 00:09:16,399
we can't use eks there's nothing we can

261
00:09:16,399 --> 00:09:17,360
do

262
00:09:17,360 --> 00:09:18,880
so galactus won't be able to find our

263
00:09:18,880 --> 00:09:20,480
new birthday boy provider which means

264
00:09:20,480 --> 00:09:21,600
wingman won't know how to talk to

265
00:09:21,600 --> 00:09:22,080
anybody

266
00:09:22,080 --> 00:09:23,360
which means i will be able to find true

267
00:09:23,360 --> 00:09:25,600
love all right

268
00:09:25,600 --> 00:09:28,080
so that was a conversation between a

269
00:09:28,080 --> 00:09:28,800
developer

270
00:09:28,800 --> 00:09:32,080
who builds microservices for living and

271
00:09:32,080 --> 00:09:34,240
a product manager who wants him to do

272
00:09:34,240 --> 00:09:35,680
certain changes

273
00:09:35,680 --> 00:09:38,560
and we can totally see how common will

274
00:09:38,560 --> 00:09:39,839
not understand it

275
00:09:39,839 --> 00:09:43,040
how complicated it was uh for him to

276
00:09:43,040 --> 00:09:44,160
explain

277
00:09:44,160 --> 00:09:46,959
the dependency layers and how to

278
00:09:46,959 --> 00:09:48,880
introduce a small change

279
00:09:48,880 --> 00:09:51,360
and i hope the product managers got it

280
00:09:51,360 --> 00:09:52,800
this particular video is

281
00:09:52,800 --> 00:09:55,200
uh provided by shazam and it's available

282
00:09:55,200 --> 00:09:57,279
on youtube and i highly recommend go

283
00:09:57,279 --> 00:09:59,200
check it out

284
00:09:59,200 --> 00:10:02,079
now just the way the developer has these

285
00:10:02,079 --> 00:10:04,320
pain points around complexity

286
00:10:04,320 --> 00:10:07,120
security people face exact same pain

287
00:10:07,120 --> 00:10:08,399
points

288
00:10:08,399 --> 00:10:10,480
micro service oriented architecture

289
00:10:10,480 --> 00:10:11,839
which is a mix of

290
00:10:11,839 --> 00:10:14,079
different micro services and serverless

291
00:10:14,079 --> 00:10:15,040
application

292
00:10:15,040 --> 00:10:18,720
it's highly complex if you imagine

293
00:10:18,720 --> 00:10:21,600
a monolith application because of tight

294
00:10:21,600 --> 00:10:24,160
coupling of different components

295
00:10:24,160 --> 00:10:26,079
and sub components there was this

296
00:10:26,079 --> 00:10:27,760
implicit trust

297
00:10:27,760 --> 00:10:30,800
and we humans are habituated

298
00:10:30,800 --> 00:10:33,839
we try to uh you know repeat the

299
00:10:33,839 --> 00:10:34,640
patterns

300
00:10:34,640 --> 00:10:37,120
in case of microservice oriented

301
00:10:37,120 --> 00:10:38,079
architecture

302
00:10:38,079 --> 00:10:41,120
this implicit trust is very dangerous it

303
00:10:41,120 --> 00:10:42,320
gets replaced by

304
00:10:42,320 --> 00:10:45,680
explicit trust and every time checking

305
00:10:45,680 --> 00:10:46,079
these

306
00:10:46,079 --> 00:10:48,720
micro services before they talk to each

307
00:10:48,720 --> 00:10:49,279
other for

308
00:10:49,279 --> 00:10:53,600
explicit trust can be quite complex

309
00:10:53,600 --> 00:10:56,640
next thing is in case of monolith there

310
00:10:56,640 --> 00:10:58,160
is a static order of

311
00:10:58,160 --> 00:11:00,800
api and if you look at this picture on

312
00:11:00,800 --> 00:11:02,160
the right hand side

313
00:11:02,160 --> 00:11:04,800
now that has changed into dynamic order

314
00:11:04,800 --> 00:11:05,680
of api

315
00:11:05,680 --> 00:11:09,040
which is also quite tedious when we have

316
00:11:09,040 --> 00:11:12,000
typical monolith application we know the

317
00:11:12,000 --> 00:11:12,880
attack surface

318
00:11:12,880 --> 00:11:14,640
what is getting exposed what is not

319
00:11:14,640 --> 00:11:15,920
getting exposed

320
00:11:15,920 --> 00:11:19,519
but in case of serverless

321
00:11:19,680 --> 00:11:21,920
where the cloud provider have lot of

322
00:11:21,920 --> 00:11:23,200
leverage

323
00:11:23,200 --> 00:11:26,160
sometimes the attack surface is quite

324
00:11:26,160 --> 00:11:26,720
unknown

325
00:11:26,720 --> 00:11:28,800
we have to pay a special attention to

326
00:11:28,800 --> 00:11:31,360
define that attack surface

327
00:11:31,360 --> 00:11:33,760
most importantly if you look at the

328
00:11:33,760 --> 00:11:34,640
traditional

329
00:11:34,640 --> 00:11:37,680
application security uh tooling or

330
00:11:37,680 --> 00:11:40,399
application security review mechanisms

331
00:11:40,399 --> 00:11:40,800
that

332
00:11:40,800 --> 00:11:43,600
tooling is really not adequate for

333
00:11:43,600 --> 00:11:45,600
something that gets deployed like this

334
00:11:45,600 --> 00:11:46,000
with

335
00:11:46,000 --> 00:11:48,480
a level of complexity therefore the

336
00:11:48,480 --> 00:11:49,279
traditional

337
00:11:49,279 --> 00:11:52,480
application security always doesn't work

338
00:11:52,480 --> 00:11:55,279
uh and most importantly the speed of

339
00:11:55,279 --> 00:11:56,800
deployment

340
00:11:56,800 --> 00:11:59,360
with the help of serverless application

341
00:11:59,360 --> 00:12:00,560
infrastructure

342
00:12:00,560 --> 00:12:03,040
the cloud service providers empowers

343
00:12:03,040 --> 00:12:04,880
developer with so much speed

344
00:12:04,880 --> 00:12:07,519
and easiness to deploy their innovation

345
00:12:07,519 --> 00:12:09,760
that if we go a traditional route

346
00:12:09,760 --> 00:12:12,639
it becomes difficult for absent person

347
00:12:12,639 --> 00:12:14,240
to do his job

348
00:12:14,240 --> 00:12:16,560
and as a result traditional application

349
00:12:16,560 --> 00:12:19,200
security reviews are not possible

350
00:12:19,200 --> 00:12:21,440
so those were some of the pain points

351
00:12:21,440 --> 00:12:22,240
now let's

352
00:12:22,240 --> 00:12:24,639
look at uh some of the implementation

353
00:12:24,639 --> 00:12:27,360
specific pain points

354
00:12:27,360 --> 00:12:30,880
the funny thing is oas vulnerabilities

355
00:12:30,880 --> 00:12:33,120
which were published 20 years back

356
00:12:33,120 --> 00:12:36,720
are still applicable to

357
00:12:36,720 --> 00:12:39,040
micro service oriented applications and

358
00:12:39,040 --> 00:12:40,720
serverless applications

359
00:12:40,720 --> 00:12:42,880
these are pretty much exact same

360
00:12:42,880 --> 00:12:44,000
vulnerabilities

361
00:12:44,000 --> 00:12:46,800
what this means is when the cloud

362
00:12:46,800 --> 00:12:48,240
service provider

363
00:12:48,240 --> 00:12:50,480
offers you the ability to write code

364
00:12:50,480 --> 00:12:52,320
fast and deploy fast

365
00:12:52,320 --> 00:12:55,360
they don't necessarily offer you

366
00:12:55,360 --> 00:12:57,680
the ways to take care of these

367
00:12:57,680 --> 00:12:59,279
vulnerabilities by default

368
00:12:59,279 --> 00:13:01,040
so as a developer you have to pay

369
00:13:01,040 --> 00:13:02,800
attention towards all these

370
00:13:02,800 --> 00:13:04,079
vulnerabilities

371
00:13:04,079 --> 00:13:06,639
and we are going to talk some of uh we

372
00:13:06,639 --> 00:13:07,839
are going to talk some of these

373
00:13:07,839 --> 00:13:08,880
vulnerabilities

374
00:13:08,880 --> 00:13:12,560
uh shortly in detail

375
00:13:12,560 --> 00:13:15,920
let's take a look at uh aws lambda

376
00:13:15,920 --> 00:13:18,880
so those who know aws lambda is a

377
00:13:18,880 --> 00:13:20,720
serverless function

378
00:13:20,720 --> 00:13:23,760
basically you write the code you zip it

379
00:13:23,760 --> 00:13:26,320
and hand it over to the lambda we call

380
00:13:26,320 --> 00:13:28,160
that as a function

381
00:13:28,160 --> 00:13:31,200
and then we configure it to integrate

382
00:13:31,200 --> 00:13:32,880
with number of events

383
00:13:32,880 --> 00:13:35,760
for example let's say a record change in

384
00:13:35,760 --> 00:13:36,720
dynamodb

385
00:13:36,720 --> 00:13:39,839
then do this now

386
00:13:39,839 --> 00:13:41,839
when you're dealing with such serverless

387
00:13:41,839 --> 00:13:43,279
functions

388
00:13:43,279 --> 00:13:45,279
all the debugging must be done through

389
00:13:45,279 --> 00:13:46,639
logging there are not

390
00:13:46,639 --> 00:13:49,440
additional interfaces available to

391
00:13:49,440 --> 00:13:50,639
troubleshoot

392
00:13:50,639 --> 00:13:53,040
uh this type of functionality and

393
00:13:53,040 --> 00:13:54,000
because of that

394
00:13:54,000 --> 00:13:57,040
the testing is very limited how can you

395
00:13:57,040 --> 00:13:57,680
use

396
00:13:57,680 --> 00:13:59,519
traditional tooling to test something

397
00:13:59,519 --> 00:14:01,680
that is so short-lived

398
00:14:01,680 --> 00:14:04,959
if we are not careful about wiping the

399
00:14:04,959 --> 00:14:06,160
data securely

400
00:14:06,160 --> 00:14:09,279
after the function is uh executed then

401
00:14:09,279 --> 00:14:10,800
there is a possibility

402
00:14:10,800 --> 00:14:13,920
of temporary data leakage and most

403
00:14:13,920 --> 00:14:17,760
important thing is aws lambda

404
00:14:17,760 --> 00:14:21,199
security is enforced using im policies

405
00:14:21,199 --> 00:14:24,399
and these im policies are not available

406
00:14:24,399 --> 00:14:27,760
to be secure by default so if somebody

407
00:14:27,760 --> 00:14:28,800
makes a mistake

408
00:14:28,800 --> 00:14:31,199
lets say use wildcard then there is a

409
00:14:31,199 --> 00:14:33,839
chance that the overall security of aws

410
00:14:33,839 --> 00:14:35,279
lambda can be compromised

411
00:14:35,279 --> 00:14:38,240
so we have to be extra careful just like

412
00:14:38,240 --> 00:14:39,839
any software

413
00:14:39,839 --> 00:14:42,560
even aws lambda had security

414
00:14:42,560 --> 00:14:44,240
vulnerabilities it was

415
00:14:44,240 --> 00:14:47,279
introduced in 2014 and so far three

416
00:14:47,279 --> 00:14:49,440
vulnerabilities have published

417
00:14:49,440 --> 00:14:51,440
their most recent vulnerability was

418
00:14:51,440 --> 00:14:54,160
around code injection in their cli tool

419
00:14:54,160 --> 00:14:57,199
called aws lambda

420
00:14:57,199 --> 00:14:59,839
uh where a simple uh bound check was

421
00:14:59,839 --> 00:15:00,320
missing

422
00:15:00,320 --> 00:15:02,800
and as a result attacker can execute

423
00:15:02,800 --> 00:15:04,480
arbitrary os command

424
00:15:04,480 --> 00:15:07,920
so the point is we can't rely

425
00:15:07,920 --> 00:15:10,800
on the security provided by cloud

426
00:15:10,800 --> 00:15:12,079
service provider

427
00:15:12,079 --> 00:15:15,279
we have to make sure every aspect of the

428
00:15:15,279 --> 00:15:17,600
serverless application or function that

429
00:15:17,600 --> 00:15:18,480
we are using

430
00:15:18,480 --> 00:15:22,959
is secure now let's ask a question

431
00:15:22,959 --> 00:15:26,480
why is that and what's our role

432
00:15:26,480 --> 00:15:29,440
in this security as a developer or

433
00:15:29,440 --> 00:15:30,000
appsec

434
00:15:30,000 --> 00:15:32,800
engineer so if you carefully look at

435
00:15:32,800 --> 00:15:33,360
this

436
00:15:33,360 --> 00:15:36,720
um shared security model

437
00:15:36,720 --> 00:15:38,720
uh provided by any cloud service

438
00:15:38,720 --> 00:15:40,079
provider you will

439
00:15:40,079 --> 00:15:42,959
understand how the role of security has

440
00:15:42,959 --> 00:15:44,639
changed

441
00:15:44,639 --> 00:15:48,320
even in case of serverless functionality

442
00:15:48,320 --> 00:15:50,240
the cloud service provider is

443
00:15:50,240 --> 00:15:51,360
responsible

444
00:15:51,360 --> 00:15:53,519
for taking care of operating system

445
00:15:53,519 --> 00:15:54,639
virtual machines

446
00:15:54,639 --> 00:15:57,600
storage database and security of the

447
00:15:57,600 --> 00:16:00,000
infrastructure part they are responsible

448
00:16:00,000 --> 00:16:01,680
for deploying the

449
00:16:01,680 --> 00:16:04,880
operating system patches but

450
00:16:04,880 --> 00:16:07,759
the complete responsibility of the core

451
00:16:07,759 --> 00:16:09,120
that we write

452
00:16:09,120 --> 00:16:12,959
the data that uh the application handles

453
00:16:12,959 --> 00:16:13,680
either at

454
00:16:13,680 --> 00:16:16,720
rest or in transit uh the

455
00:16:16,720 --> 00:16:20,079
identity and access management plus

456
00:16:20,079 --> 00:16:23,440
various cloud service configurations

457
00:16:23,440 --> 00:16:26,480
needed for your application to work

458
00:16:26,480 --> 00:16:28,639
properly everything is your

459
00:16:28,639 --> 00:16:30,880
responsibility

460
00:16:30,880 --> 00:16:33,839
and this is a big eye opener this takes

461
00:16:33,839 --> 00:16:35,120
away the myth

462
00:16:35,120 --> 00:16:38,480
from us just because something is hosted

463
00:16:38,480 --> 00:16:39,519
by aws

464
00:16:39,519 --> 00:16:41,839
or google cloud provider or any other

465
00:16:41,839 --> 00:16:43,519
cloud service provider that means that

466
00:16:43,519 --> 00:16:44,800
is secure and waited

467
00:16:44,800 --> 00:16:47,920
no you know as a developer we need to

468
00:16:47,920 --> 00:16:51,360
take full responsibility of security

469
00:16:51,360 --> 00:16:54,480
now let's see how we can do that

470
00:16:54,480 --> 00:16:56,639
in this section i'm going to talk about

471
00:16:56,639 --> 00:16:57,920
uh some of the

472
00:16:57,920 --> 00:17:00,959
micro service design patterns so design

473
00:17:00,959 --> 00:17:04,720
patterns are basically uh reusable

474
00:17:04,720 --> 00:17:06,319
autonomous service

475
00:17:06,319 --> 00:17:09,199
that we can use it again and again so

476
00:17:09,199 --> 00:17:11,119
that nothing becomes hindrance to our

477
00:17:11,119 --> 00:17:12,480
innovation

478
00:17:12,480 --> 00:17:15,679
these design patterns uh basically

479
00:17:15,679 --> 00:17:18,240
allows us to accelerate application

480
00:17:18,240 --> 00:17:19,439
releases

481
00:17:19,439 --> 00:17:21,839
so i have often seen my developers

482
00:17:21,839 --> 00:17:24,400
coming to us with these templates

483
00:17:24,400 --> 00:17:26,640
and security team reviews those

484
00:17:26,640 --> 00:17:28,880
templates and make sure these templates

485
00:17:28,880 --> 00:17:30,320
are nicely wetted

486
00:17:30,320 --> 00:17:32,720
and in this way they don't need a

487
00:17:32,720 --> 00:17:34,080
security team's review

488
00:17:34,080 --> 00:17:36,720
every single time uh they deploy these

489
00:17:36,720 --> 00:17:37,760
micro services

490
00:17:37,760 --> 00:17:39,760
so that's the beauty of using design

491
00:17:39,760 --> 00:17:41,039
patterns

492
00:17:41,039 --> 00:17:43,200
as such there are a lot of design

493
00:17:43,200 --> 00:17:44,320
patterns out there

494
00:17:44,320 --> 00:17:48,799
just on the screen you can see 26

495
00:17:48,799 --> 00:17:51,200
design pattern obviously i don't have

496
00:17:51,200 --> 00:17:51,919
time

497
00:17:51,919 --> 00:17:53,919
to go through each one of them so i have

498
00:17:53,919 --> 00:17:55,280
selected few

499
00:17:55,280 --> 00:17:58,320
that i find are very interesting from

500
00:17:58,320 --> 00:18:00,160
security point of view

501
00:18:00,160 --> 00:18:03,200
you will see in these design patterns

502
00:18:03,200 --> 00:18:05,600
some of the security features are very

503
00:18:05,600 --> 00:18:06,880
well thought through

504
00:18:06,880 --> 00:18:09,520
they come as out of box and that makes

505
00:18:09,520 --> 00:18:10,400
it very

506
00:18:10,400 --> 00:18:13,600
easy for developer to configure them

507
00:18:13,600 --> 00:18:16,400
all right let's take a look at the first

508
00:18:16,400 --> 00:18:17,840
design pattern

509
00:18:17,840 --> 00:18:20,960
api gateway this is

510
00:18:20,960 --> 00:18:24,480
my the most favorite design pattern

511
00:18:24,480 --> 00:18:28,799
now imagine your aws lambda service or

512
00:18:28,799 --> 00:18:30,000
google function

513
00:18:30,000 --> 00:18:32,480
is part of service a or service b in

514
00:18:32,480 --> 00:18:33,919
order to protect them

515
00:18:33,919 --> 00:18:36,160
just take a look at how many security

516
00:18:36,160 --> 00:18:37,120
functionalities

517
00:18:37,120 --> 00:18:40,880
api gateway provides out of box

518
00:18:40,880 --> 00:18:44,320
when we use api gateway we can

519
00:18:44,320 --> 00:18:48,320
uh leverage it for authentication

520
00:18:48,320 --> 00:18:51,440
api authorization it also provides

521
00:18:51,440 --> 00:18:52,400
capabilities

522
00:18:52,400 --> 00:18:56,799
to prevent a denial of service attacks

523
00:18:56,799 --> 00:19:00,160
it performs routing of requests uh

524
00:19:00,160 --> 00:19:03,440
it has mechanisms to prevent

525
00:19:03,440 --> 00:19:06,640
layer 7 or dos attacks by providing us

526
00:19:06,640 --> 00:19:07,679
capabilities

527
00:19:07,679 --> 00:19:10,400
to define throttling limits api rate

528
00:19:10,400 --> 00:19:11,440
limits

529
00:19:11,440 --> 00:19:13,280
basically it does the overall load

530
00:19:13,280 --> 00:19:14,799
balancing for us

531
00:19:14,799 --> 00:19:17,919
it makes sure all the end points are

532
00:19:17,919 --> 00:19:21,520
available on https which is a big

533
00:19:21,520 --> 00:19:25,200
big big plus point moreover uh you can

534
00:19:25,200 --> 00:19:28,640
do security and resiliency monitoring

535
00:19:28,640 --> 00:19:32,080
using your api gateway

536
00:19:32,080 --> 00:19:34,400
so what i really like about this is

537
00:19:34,400 --> 00:19:36,799
there are tons and tons of good security

538
00:19:36,799 --> 00:19:38,559
functionality are inbuilt

539
00:19:38,559 --> 00:19:41,919
and if we enable them our applications

540
00:19:41,919 --> 00:19:42,640
are secure

541
00:19:42,640 --> 00:19:46,160
up to an extent but again this is not

542
00:19:46,160 --> 00:19:49,520
a silver bullet just because it provides

543
00:19:49,520 --> 00:19:50,240
all this

544
00:19:50,240 --> 00:19:52,400
nice wonderful security functionality

545
00:19:52,400 --> 00:19:54,240
that doesn't mean it is not vulnerable

546
00:19:54,240 --> 00:19:56,960
to attack so there are some attacks

547
00:19:56,960 --> 00:19:59,760
uh that api gateway cannot provide so

548
00:19:59,760 --> 00:20:01,039
this is something

549
00:20:01,039 --> 00:20:03,919
uh the developer of serverless

550
00:20:03,919 --> 00:20:04,720
applications

551
00:20:04,720 --> 00:20:07,280
has to keep in mind some of those

552
00:20:07,280 --> 00:20:09,039
vulnerable attacks are

553
00:20:09,039 --> 00:20:12,400
let's say layer 7 ddos

554
00:20:12,400 --> 00:20:15,760
attack with counterfeit request or ddos

555
00:20:15,760 --> 00:20:17,520
with cascading requests

556
00:20:17,520 --> 00:20:19,679
now cascading requests are basically

557
00:20:19,679 --> 00:20:21,679
simple requests

558
00:20:21,679 --> 00:20:24,480
which when reached to the back end they

559
00:20:24,480 --> 00:20:25,280
generate

560
00:20:25,280 --> 00:20:28,720
many requests and then it becomes

561
00:20:28,720 --> 00:20:29,600
difficult

562
00:20:29,600 --> 00:20:33,200
for back-end microservices

563
00:20:33,200 --> 00:20:36,640
to manage it and as a result the service

564
00:20:36,640 --> 00:20:39,120
experiences denial of service

565
00:20:39,120 --> 00:20:43,039
next one uh is you know if there are any

566
00:20:43,039 --> 00:20:45,600
implementation specific login or

567
00:20:45,600 --> 00:20:46,640
identity attack

568
00:20:46,640 --> 00:20:49,919
let's say related to jwf token then

569
00:20:49,919 --> 00:20:52,400
that is not something api gateway can

570
00:20:52,400 --> 00:20:53,280
take care

571
00:20:53,280 --> 00:20:56,400
it's a design pattern so it obviously

572
00:20:56,400 --> 00:20:58,320
has some security features but there are

573
00:20:58,320 --> 00:20:59,360
definitely some

574
00:20:59,360 --> 00:21:02,640
attacks it cannot handle for example

575
00:21:02,640 --> 00:21:05,280
cross-site scripting and sql injection

576
00:21:05,280 --> 00:21:07,840
so it is the responsibility of the

577
00:21:07,840 --> 00:21:10,159
developer to ensure that

578
00:21:10,159 --> 00:21:12,880
these implementation specific attacks

579
00:21:12,880 --> 00:21:13,919
are taken care

580
00:21:13,919 --> 00:21:16,960
of level so let's take a look at

581
00:21:16,960 --> 00:21:20,080
one of the serverless

582
00:21:20,080 --> 00:21:22,320
function here let's say we have a

583
00:21:22,320 --> 00:21:23,840
serverless function

584
00:21:23,840 --> 00:21:26,000
which is responsible for performing

585
00:21:26,000 --> 00:21:28,400
login

586
00:21:28,480 --> 00:21:32,080
service it accepts username password and

587
00:21:32,080 --> 00:21:35,039
returns a jwp token

588
00:21:35,039 --> 00:21:38,559
awesome right uh you will see these type

589
00:21:38,559 --> 00:21:39,360
of

590
00:21:39,360 --> 00:21:41,600
serverless functions are used for you

591
00:21:41,600 --> 00:21:43,679
know authentication of apis or

592
00:21:43,679 --> 00:21:45,840
performing authorization for each

593
00:21:45,840 --> 00:21:47,360
request

594
00:21:47,360 --> 00:21:49,039
which is basically needed between

595
00:21:49,039 --> 00:21:52,080
service to service communication

596
00:21:52,080 --> 00:21:55,200
now if uh we get certain things

597
00:21:55,200 --> 00:21:59,039
right for example uh in a typical jwt

598
00:21:59,039 --> 00:22:02,400
web token which consists of a header

599
00:22:02,400 --> 00:22:04,799
a cipher specification where we specify

600
00:22:04,799 --> 00:22:06,880
the crypto algorithm then a payload and

601
00:22:06,880 --> 00:22:09,760
then signature of the payload

602
00:22:09,760 --> 00:22:13,200
if we get the cipher uh specification

603
00:22:13,200 --> 00:22:14,400
right

604
00:22:14,400 --> 00:22:18,159
if i set it to none then basically all

605
00:22:18,159 --> 00:22:20,159
the cryptographic security which is

606
00:22:20,159 --> 00:22:22,720
provided by the jwd token can be

607
00:22:22,720 --> 00:22:24,000
bypassed

608
00:22:24,000 --> 00:22:27,200
then the jwt specification

609
00:22:27,200 --> 00:22:30,799
provides a field called jpi if this

610
00:22:30,799 --> 00:22:33,840
field is disabled by default then

611
00:22:33,840 --> 00:22:36,480
our jwt implementation and the resulting

612
00:22:36,480 --> 00:22:37,919
serverless function

613
00:22:37,919 --> 00:22:41,120
is subject to every player tag and when

614
00:22:41,120 --> 00:22:44,159
you're not protecting your jwt token

615
00:22:44,159 --> 00:22:47,280
properly using right crypto or

616
00:22:47,280 --> 00:22:51,039
replay uh attack prevention then

617
00:22:51,039 --> 00:22:53,280
information leakage can possible so

618
00:22:53,280 --> 00:22:54,559
these are some small

619
00:22:54,559 --> 00:22:57,679
things which are extremely important

620
00:22:57,679 --> 00:22:59,520
and the developer have to keep these

621
00:22:59,520 --> 00:23:01,440
things in mind

622
00:23:01,440 --> 00:23:03,440
for secure implementation of your

623
00:23:03,440 --> 00:23:05,280
serverless application

624
00:23:05,280 --> 00:23:08,880
now let's move on to a next design

625
00:23:08,880 --> 00:23:09,760
pattern

626
00:23:09,760 --> 00:23:13,840
uh a circuit breaker design pattern

627
00:23:13,840 --> 00:23:15,760
basically the software design pattern

628
00:23:15,760 --> 00:23:17,840
which is used in many micro service

629
00:23:17,840 --> 00:23:18,240
based

630
00:23:18,240 --> 00:23:21,120
software development it works the same

631
00:23:21,120 --> 00:23:22,480
way as

632
00:23:22,480 --> 00:23:25,280
how an electric circuit breaker works

633
00:23:25,280 --> 00:23:26,000
when

634
00:23:26,000 --> 00:23:28,400
multiple service communicate with each

635
00:23:28,400 --> 00:23:29,360
other to serve

636
00:23:29,360 --> 00:23:31,679
the number of requests there are many

637
00:23:31,679 --> 00:23:32,720
possibilities

638
00:23:32,720 --> 00:23:35,679
that the services are unavailable and

639
00:23:35,679 --> 00:23:37,280
are not responding

640
00:23:37,280 --> 00:23:41,039
for example this is a health check app

641
00:23:41,039 --> 00:23:44,080
and it is connected to redis cluster

642
00:23:44,080 --> 00:23:47,200
and dynamodb and some external apis

643
00:23:47,200 --> 00:23:50,559
let's say the redis cluster is down

644
00:23:50,559 --> 00:23:54,639
now what will happen is

645
00:23:55,039 --> 00:23:58,559
this particular microservice will inform

646
00:23:58,559 --> 00:24:01,120
a circuit breaker after a certain

647
00:24:01,120 --> 00:24:02,960
threshold is crossed

648
00:24:02,960 --> 00:24:05,440
and as a result the circuit will break

649
00:24:05,440 --> 00:24:07,520
the circuit breaker will communicate

650
00:24:07,520 --> 00:24:09,679
with the external applications which

651
00:24:09,679 --> 00:24:10,320
relies

652
00:24:10,320 --> 00:24:12,799
on smooth connectivity and communication

653
00:24:12,799 --> 00:24:14,000
with these internal

654
00:24:14,000 --> 00:24:17,120
services and as a result a

655
00:24:17,120 --> 00:24:20,720
failure is very gracefully communicated

656
00:24:20,720 --> 00:24:24,320
with all the intended parties

657
00:24:24,320 --> 00:24:27,600
and this whole thing makes uh your

658
00:24:27,600 --> 00:24:28,480
application

659
00:24:28,480 --> 00:24:31,600
a design very resilient when the service

660
00:24:31,600 --> 00:24:32,320
is back

661
00:24:32,320 --> 00:24:34,799
and it reaches certain uh threshold

662
00:24:34,799 --> 00:24:35,760
circuit breaker

663
00:24:35,760 --> 00:24:38,559
checks it again every few uh you know

664
00:24:38,559 --> 00:24:39,120
seconds

665
00:24:39,120 --> 00:24:41,679
and once it's working fine uh the whole

666
00:24:41,679 --> 00:24:42,880
thing works again

667
00:24:42,880 --> 00:24:45,039
an appropriate message is communicated

668
00:24:45,039 --> 00:24:46,880
with the external application

669
00:24:46,880 --> 00:24:50,240
so this particular um pattern basically

670
00:24:50,240 --> 00:24:51,240
introduces

671
00:24:51,240 --> 00:24:54,240
resiliency in your architecture and

672
00:24:54,240 --> 00:24:56,400
it is very important because you know

673
00:24:56,400 --> 00:24:58,159
failures do happen

674
00:24:58,159 --> 00:25:00,799
and it's the ability of the service to

675
00:25:00,799 --> 00:25:01,600
bounce back

676
00:25:01,600 --> 00:25:03,520
gracefully from failure which is very

677
00:25:03,520 --> 00:25:04,960
important here

678
00:25:04,960 --> 00:25:08,640
now uh usually circuit breakers are fine

679
00:25:08,640 --> 00:25:11,360
in api gateways now they are not

680
00:25:11,360 --> 00:25:13,279
bulletproof

681
00:25:13,279 --> 00:25:15,360
what if somebody attacks the circuit

682
00:25:15,360 --> 00:25:17,679
breaker itself

683
00:25:17,679 --> 00:25:21,039
right you need to keep in mind how can

684
00:25:21,039 --> 00:25:24,240
uh we prevent attack on circuit breaker

685
00:25:24,240 --> 00:25:25,279
itself

686
00:25:25,279 --> 00:25:27,600
from resiliency perspective so these are

687
00:25:27,600 --> 00:25:29,120
some interesting point

688
00:25:29,120 --> 00:25:31,200
that the security team members and

689
00:25:31,200 --> 00:25:32,799
developers need to

690
00:25:32,799 --> 00:25:34,960
talk out when they're designing

691
00:25:34,960 --> 00:25:36,400
serverless applications with

692
00:25:36,400 --> 00:25:39,279
microservices

693
00:25:39,919 --> 00:25:44,320
now let's move on to the next uh slide

694
00:25:44,320 --> 00:25:47,600
uh service mesh service mesh is actually

695
00:25:47,600 --> 00:25:50,640
uh infrastructure deployment of micro

696
00:25:50,640 --> 00:25:51,840
services

697
00:25:51,840 --> 00:25:55,039
in a typical service mesh uh

698
00:25:55,039 --> 00:25:58,320
proxies these blue color boxes you see

699
00:25:58,320 --> 00:26:00,799
yeah these proxies are injected into

700
00:26:00,799 --> 00:26:03,039
each service which is deployment

701
00:26:03,039 --> 00:26:05,760
deployed as a side car now instead of

702
00:26:05,760 --> 00:26:07,919
calling services directly over the

703
00:26:07,919 --> 00:26:08,799
network

704
00:26:08,799 --> 00:26:13,120
services then call their local site cars

705
00:26:13,120 --> 00:26:16,240
and these local sidecar proxies manage

706
00:26:16,240 --> 00:26:19,039
entire communication the reason i like

707
00:26:19,039 --> 00:26:21,520
this particular microservice design

708
00:26:21,520 --> 00:26:24,960
because um it uses

709
00:26:24,960 --> 00:26:28,080
mutual tls to ensure the inter-service

710
00:26:28,080 --> 00:26:29,279
communication

711
00:26:29,279 --> 00:26:33,520
is completely encrypted

712
00:26:33,520 --> 00:26:36,640
it also provides mechanisms to perform

713
00:26:36,640 --> 00:26:39,120
authentication and authorization of all

714
00:26:39,120 --> 00:26:40,400
the services

715
00:26:40,400 --> 00:26:43,279
it provides access control policies to

716
00:26:43,279 --> 00:26:44,080
even

717
00:26:44,080 --> 00:26:47,760
enforce fine grain access control

718
00:26:47,760 --> 00:26:50,240
so it provides lot of security features

719
00:26:50,240 --> 00:26:51,520
out of box

720
00:26:51,520 --> 00:26:54,799
now again this is also not bulletproof

721
00:26:54,799 --> 00:26:58,240
because of such complex

722
00:26:58,240 --> 00:27:01,200
infrastructure and design this

723
00:27:01,200 --> 00:27:02,960
particular design pattern

724
00:27:02,960 --> 00:27:06,480
is prone to lot of specific

725
00:27:06,480 --> 00:27:08,960
security misconfiguration so we have to

726
00:27:08,960 --> 00:27:11,760
watch out for those

727
00:27:11,760 --> 00:27:14,720
all right let's move on to log

728
00:27:14,720 --> 00:27:18,480
aggregator and design patterns

729
00:27:19,440 --> 00:27:22,320
we all know that logs are extremely

730
00:27:22,320 --> 00:27:23,360
important from

731
00:27:23,360 --> 00:27:26,159
auditing and uh investigation

732
00:27:26,159 --> 00:27:26,960
perspective

733
00:27:26,960 --> 00:27:30,159
anytime there is uh you know failure or

734
00:27:30,159 --> 00:27:31,840
security incident

735
00:27:31,840 --> 00:27:34,399
uh we need the logs to do the

736
00:27:34,399 --> 00:27:36,080
investigation

737
00:27:36,080 --> 00:27:39,200
so whenever you are building

738
00:27:39,200 --> 00:27:42,000
microservices serverless function always

739
00:27:42,000 --> 00:27:43,200
make sure

740
00:27:43,200 --> 00:27:45,679
you have this particular design pattern

741
00:27:45,679 --> 00:27:46,720
included

742
00:27:46,720 --> 00:27:50,159
in as part of your core applications

743
00:27:50,159 --> 00:27:52,399
this particular design pattern allows

744
00:27:52,399 --> 00:27:53,200
collection of

745
00:27:53,200 --> 00:27:56,399
logs which enables us to do real-time

746
00:27:56,399 --> 00:27:58,720
monitoring of enormous

747
00:27:58,720 --> 00:28:02,080
patterns and events you can

748
00:28:02,080 --> 00:28:04,480
also leverage this design pattern to

749
00:28:04,480 --> 00:28:06,640
perform automated login

750
00:28:06,640 --> 00:28:09,120
now just like other design patterns that

751
00:28:09,120 --> 00:28:10,399
we discuss

752
00:28:10,399 --> 00:28:13,200
this one is also not a bullet proof

753
00:28:13,200 --> 00:28:16,480
there are some limitations it is the

754
00:28:16,480 --> 00:28:18,720
responsibility of the architect to make

755
00:28:18,720 --> 00:28:19,440
sure

756
00:28:19,440 --> 00:28:22,880
correlation of logs happens correctly

757
00:28:22,880 --> 00:28:25,760
uh then as a developer we want to make

758
00:28:25,760 --> 00:28:26,559
sure

759
00:28:26,559 --> 00:28:29,760
that we do not log any sensitive

760
00:28:29,760 --> 00:28:32,399
information in our logs such as station

761
00:28:32,399 --> 00:28:35,200
tokens or authentication tokens

762
00:28:35,200 --> 00:28:39,200
or secrets because many times

763
00:28:39,200 --> 00:28:42,080
the speed at which we deploy these uh

764
00:28:42,080 --> 00:28:44,159
serverless applications

765
00:28:44,159 --> 00:28:46,240
we don't have time to do double check so

766
00:28:46,240 --> 00:28:48,000
we have to be mindful

767
00:28:48,000 --> 00:28:51,360
of uh

768
00:28:51,360 --> 00:28:53,600
in advance that we are not logging

769
00:28:53,600 --> 00:28:55,520
sensitive information

770
00:28:55,520 --> 00:28:57,600
third thing if you are logging sensitive

771
00:28:57,600 --> 00:28:59,200
information or not

772
00:28:59,200 --> 00:29:02,240
but if these logs get into the hands

773
00:29:02,240 --> 00:29:05,200
wrong hands then game over because

774
00:29:05,200 --> 00:29:06,559
somebody can construct

775
00:29:06,559 --> 00:29:09,679
a lot of information uh from this lock

776
00:29:09,679 --> 00:29:12,080
so it is very important to make sure the

777
00:29:12,080 --> 00:29:13,919
logs do not have any

778
00:29:13,919 --> 00:29:17,520
uh unauthorized access all right so that

779
00:29:17,520 --> 00:29:18,240
was about

780
00:29:18,240 --> 00:29:20,559
you know our design patterns and what uh

781
00:29:20,559 --> 00:29:22,559
security functionality they provide

782
00:29:22,559 --> 00:29:24,960
out of box and we discuss many

783
00:29:24,960 --> 00:29:26,960
implementation specific

784
00:29:26,960 --> 00:29:29,120
attacks and misconfigurations and

785
00:29:29,120 --> 00:29:31,679
settings that if we are not careful

786
00:29:31,679 --> 00:29:34,559
then uh maybe the designs are not as

787
00:29:34,559 --> 00:29:36,159
effective as we think

788
00:29:36,159 --> 00:29:39,440
in this section let's talk about some of

789
00:29:39,440 --> 00:29:40,000
the best

790
00:29:40,000 --> 00:29:43,200
practices and understand what kind of

791
00:29:43,200 --> 00:29:43,919
scanning

792
00:29:43,919 --> 00:29:46,320
and tooling capabilities are out there

793
00:29:46,320 --> 00:29:47,919
that we can

794
00:29:47,919 --> 00:29:51,279
leverage to meet the speed of innovation

795
00:29:51,279 --> 00:29:54,880
and security assessment

796
00:29:54,880 --> 00:29:57,200
so some of the best practices are first

797
00:29:57,200 --> 00:29:58,000
of all

798
00:29:58,000 --> 00:30:00,799
zero trust everything what i mean by

799
00:30:00,799 --> 00:30:01,360
that

800
00:30:01,360 --> 00:30:04,640
in monolith world we were having this

801
00:30:04,640 --> 00:30:06,640
implicit trust because things were

802
00:30:06,640 --> 00:30:10,000
tightly coupled in microservices world

803
00:30:10,000 --> 00:30:12,880
zero trust your code that means verify

804
00:30:12,880 --> 00:30:13,919
your code

805
00:30:13,919 --> 00:30:16,960
verify uh applications

806
00:30:16,960 --> 00:30:19,279
that interact with each other even

807
00:30:19,279 --> 00:30:20,880
verify the inter process

808
00:30:20,880 --> 00:30:24,000
communication what i mean by verify

809
00:30:24,000 --> 00:30:26,480
is make sure the authenticity and

810
00:30:26,480 --> 00:30:28,799
integrity is validated before you talk

811
00:30:28,799 --> 00:30:30,720
to them

812
00:30:30,720 --> 00:30:33,919
uh in cloud we have seen there are

813
00:30:33,919 --> 00:30:36,720
many uh encryption at rest services

814
00:30:36,720 --> 00:30:38,480
available and this could be

815
00:30:38,480 --> 00:30:41,360
confusing to developers you know

816
00:30:41,360 --> 00:30:43,520
encryption at rest

817
00:30:43,520 --> 00:30:46,640
encryption in transit using server-side

818
00:30:46,640 --> 00:30:47,440
libraries

819
00:30:47,440 --> 00:30:50,320
or using client-side encryption you can

820
00:30:50,320 --> 00:30:51,919
bring your own keys

821
00:30:51,919 --> 00:30:55,440
or you can leverage uh keys provided by

822
00:30:55,440 --> 00:30:57,760
cloud service provider and this could be

823
00:30:57,760 --> 00:30:59,039
really confusing

824
00:30:59,039 --> 00:31:01,919
i would say for encryption or any

825
00:31:01,919 --> 00:31:04,000
cryptography related design

826
00:31:04,000 --> 00:31:06,000
implementation decision get in touch

827
00:31:06,000 --> 00:31:07,760
with your security team

828
00:31:07,760 --> 00:31:11,039
understand what option is right for you

829
00:31:11,039 --> 00:31:13,760
what option is economic for you because

830
00:31:13,760 --> 00:31:15,440
it varies from

831
00:31:15,440 --> 00:31:18,720
case to case in some cases where you're

832
00:31:18,720 --> 00:31:19,519
implementing

833
00:31:19,519 --> 00:31:21,919
end-to-end encryption or message level

834
00:31:21,919 --> 00:31:22,799
encryption

835
00:31:22,799 --> 00:31:26,240
it makes total sense to use client-side

836
00:31:26,240 --> 00:31:27,120
encryption

837
00:31:27,120 --> 00:31:30,159
with your own keys but let's say your

838
00:31:30,159 --> 00:31:31,679
data is not so

839
00:31:31,679 --> 00:31:34,399
sensitive but you care about

840
00:31:34,399 --> 00:31:37,440
unauthorized modification to that data

841
00:31:37,440 --> 00:31:39,840
maybe it's okay to leverage the server

842
00:31:39,840 --> 00:31:41,200
side

843
00:31:41,200 --> 00:31:43,600
encryption provided by the cloud site

844
00:31:43,600 --> 00:31:46,159
provider so it it varies there is really

845
00:31:46,159 --> 00:31:48,320
no one-size-fits-all solution so

846
00:31:48,320 --> 00:31:49,840
definitely get in touch with your

847
00:31:49,840 --> 00:31:51,120
security team

848
00:31:51,120 --> 00:31:54,320
uh involve them early and find out

849
00:31:54,320 --> 00:31:58,159
what is the right encryption for you

850
00:31:58,159 --> 00:32:00,480
next best practices whether you're

851
00:32:00,480 --> 00:32:02,240
writing monolith application

852
00:32:02,240 --> 00:32:05,120
microservices or serverless function

853
00:32:05,120 --> 00:32:06,159
regardless

854
00:32:06,159 --> 00:32:08,559
you need to pay special attention to a

855
00:32:08,559 --> 00:32:10,399
secure coding convention

856
00:32:10,399 --> 00:32:12,240
whatever programming language you are

857
00:32:12,240 --> 00:32:14,080
using there are always

858
00:32:14,080 --> 00:32:17,120
a security best best coding practices

859
00:32:17,120 --> 00:32:18,000
available

860
00:32:18,000 --> 00:32:20,480
go read them and ensure you incorporate

861
00:32:20,480 --> 00:32:22,480
them as you write for

862
00:32:22,480 --> 00:32:24,640
then we already discussed the importance

863
00:32:24,640 --> 00:32:26,159
of logs

864
00:32:26,159 --> 00:32:29,120
not only generate logs but analyze those

865
00:32:29,120 --> 00:32:29,679
log

866
00:32:29,679 --> 00:32:32,320
uh monitor those log for any anomalous

867
00:32:32,320 --> 00:32:34,480
activity and it would be nice if you can

868
00:32:34,480 --> 00:32:35,279
use

869
00:32:35,279 --> 00:32:38,559
some sim uh stuff get in touch with your

870
00:32:38,559 --> 00:32:42,720
infrastructure security team for that

871
00:32:42,720 --> 00:32:45,760
next one is all these

872
00:32:45,760 --> 00:32:48,480
uh serverless function that you write

873
00:32:48,480 --> 00:32:49,760
from scratch

874
00:32:49,760 --> 00:32:52,480
we all know there is heavy reliance on

875
00:32:52,480 --> 00:32:55,200
third party libraries

876
00:32:55,200 --> 00:32:58,080
and these third-party libraries always

877
00:32:58,080 --> 00:33:00,000
always have cvs

878
00:33:00,000 --> 00:33:03,600
so stay on top of those cvs use a good

879
00:33:03,600 --> 00:33:06,799
uh static uh source code composition

880
00:33:06,799 --> 00:33:10,159
scanner to find out the known cves and

881
00:33:10,159 --> 00:33:14,240
ensure that your code is secure

882
00:33:14,240 --> 00:33:17,039
and a small cve in the underlying

883
00:33:17,039 --> 00:33:19,279
library doesn't become the weakest link

884
00:33:19,279 --> 00:33:22,720
in your application and i have said this

885
00:33:22,720 --> 00:33:25,360
numerous time always always always

886
00:33:25,360 --> 00:33:28,159
involve your security team early you

887
00:33:28,159 --> 00:33:30,480
will be amazed the kind of impact

888
00:33:30,480 --> 00:33:34,159
they can uh create uh just because you

889
00:33:34,159 --> 00:33:35,679
have involved them early

890
00:33:35,679 --> 00:33:38,240
because finding security issues right

891
00:33:38,240 --> 00:33:39,360
before

892
00:33:39,360 --> 00:33:42,480
uh production or in production no fun

893
00:33:42,480 --> 00:33:45,919
but when you involve them early you can

894
00:33:45,919 --> 00:33:49,600
prevent so many vulnerabilities

895
00:33:49,600 --> 00:33:53,120
proactively now let's take a look at

896
00:33:53,120 --> 00:33:56,720
some of the security best practices um

897
00:33:56,720 --> 00:33:59,440
more carefully so secure communication

898
00:33:59,440 --> 00:34:00,799
is extremely

899
00:34:00,799 --> 00:34:03,279
extremely important in microservices

900
00:34:03,279 --> 00:34:04,320
world

901
00:34:04,320 --> 00:34:07,600
if you remember in monolith architecture

902
00:34:07,600 --> 00:34:10,480
where there was a thick giant uh

903
00:34:10,480 --> 00:34:12,480
server-side application communicating

904
00:34:12,480 --> 00:34:12,960
with

905
00:34:12,960 --> 00:34:16,239
uh the client side we used to have tls

906
00:34:16,239 --> 00:34:17,440
connection

907
00:34:17,440 --> 00:34:19,440
these tls connections were not

908
00:34:19,440 --> 00:34:20,800
necessarily

909
00:34:20,800 --> 00:34:23,119
mutual because again there was some sort

910
00:34:23,119 --> 00:34:25,040
of implicit trust

911
00:34:25,040 --> 00:34:27,199
and we used to establish this tls

912
00:34:27,199 --> 00:34:28,719
connection to prevent

913
00:34:28,719 --> 00:34:30,879
man in the middle attack but when it

914
00:34:30,879 --> 00:34:32,960
comes to microservice

915
00:34:32,960 --> 00:34:35,440
architecture or architecture which

916
00:34:35,440 --> 00:34:36,320
consists of

917
00:34:36,320 --> 00:34:39,280
native uh you know serverless functions

918
00:34:39,280 --> 00:34:39,599
or

919
00:34:39,599 --> 00:34:42,719
applications in a cloud environment

920
00:34:42,719 --> 00:34:46,159
we can't trust anybody so simple tls

921
00:34:46,159 --> 00:34:48,480
connection doesn't work we have to

922
00:34:48,480 --> 00:34:49,280
leverage

923
00:34:49,280 --> 00:34:53,199
mutual tls where both the parties

924
00:34:53,199 --> 00:34:56,320
are authenticated and validated

925
00:34:56,320 --> 00:34:58,880
and the reason this is important just

926
00:34:58,880 --> 00:35:01,119
take a look at on your right hand side

927
00:35:01,119 --> 00:35:03,680
how many attacks were published in last

928
00:35:03,680 --> 00:35:04,560
10 years

929
00:35:04,560 --> 00:35:08,000
related to pls protocol implementation

930
00:35:08,000 --> 00:35:10,560
and what does that tell you

931
00:35:10,560 --> 00:35:12,720
just like any other software even

932
00:35:12,720 --> 00:35:14,560
security software

933
00:35:14,560 --> 00:35:17,440
is buggy and that's why we have to stay

934
00:35:17,440 --> 00:35:19,359
on top of it

935
00:35:19,359 --> 00:35:22,960
do not use older tls protocols because

936
00:35:22,960 --> 00:35:25,440
they have one of these vulnerabilities

937
00:35:25,440 --> 00:35:30,079
in fact i would say make your code write

938
00:35:30,079 --> 00:35:32,240
your code in such a way

939
00:35:32,240 --> 00:35:35,040
that you introduce crypto agility you

940
00:35:35,040 --> 00:35:37,200
know we are on the verge of

941
00:35:37,200 --> 00:35:39,680
quantum cryptography uh post quantum

942
00:35:39,680 --> 00:35:41,119
cryptography attack

943
00:35:41,119 --> 00:35:44,000
so the cryptography that you use in your

944
00:35:44,000 --> 00:35:45,280
application

945
00:35:45,280 --> 00:35:48,800
has to be a post quantum cryptography

946
00:35:48,800 --> 00:35:50,000
grade

947
00:35:50,000 --> 00:35:53,440
so make sure you do not hardcore any

948
00:35:53,440 --> 00:35:56,240
cyphers algorithm key size but make your

949
00:35:56,240 --> 00:35:56,720
code

950
00:35:56,720 --> 00:35:58,640
agile enough so that if you have to

951
00:35:58,640 --> 00:36:00,160
upgrade certain

952
00:36:00,160 --> 00:36:03,520
tls protocol or ciphers you can do that

953
00:36:03,520 --> 00:36:06,640
uh tls 1.3 is coming

954
00:36:06,640 --> 00:36:10,079
january 2020 uh two

955
00:36:10,079 --> 00:36:12,960
so ensure that uh you know it's very

956
00:36:12,960 --> 00:36:13,599
easy

957
00:36:13,599 --> 00:36:16,320
in your crypto code to upgrade to tls

958
00:36:16,320 --> 00:36:19,440
1.3 when it comes

959
00:36:19,440 --> 00:36:22,160
uh last thing on this slide pay

960
00:36:22,160 --> 00:36:24,400
attention to the key sizes

961
00:36:24,400 --> 00:36:29,040
and cipher uh algorithm types as well as

962
00:36:29,040 --> 00:36:31,359
their modes and again crypto is not

963
00:36:31,359 --> 00:36:33,520
something i would say anybody to do it

964
00:36:33,520 --> 00:36:35,440
get in touch with your security team and

965
00:36:35,440 --> 00:36:38,320
they will guide you

966
00:36:38,880 --> 00:36:41,920
let's move to the next one um

967
00:36:41,920 --> 00:36:44,320
the next best practice is about input

968
00:36:44,320 --> 00:36:46,640
and output validation

969
00:36:46,640 --> 00:36:49,200
in microservice oriented architecture

970
00:36:49,200 --> 00:36:51,280
with serverless application

971
00:36:51,280 --> 00:36:53,520
i don't see those many cross-site

972
00:36:53,520 --> 00:36:54,560
scripting

973
00:36:54,560 --> 00:36:58,000
as i see blind cross-site scripting

974
00:36:58,000 --> 00:37:00,079
what blind cross-site scripting really

975
00:37:00,079 --> 00:37:01,040
is uh

976
00:37:01,040 --> 00:37:04,240
let me explain suppose uh you know your

977
00:37:04,240 --> 00:37:06,839
application deals with four more

978
00:37:06,839 --> 00:37:08,000
applications

979
00:37:08,000 --> 00:37:10,400
and out of four applications three

980
00:37:10,400 --> 00:37:11,440
applications

981
00:37:11,440 --> 00:37:14,720
have uh input validation and let's say

982
00:37:14,720 --> 00:37:16,079
output when coding

983
00:37:16,079 --> 00:37:19,680
but there is a fourth application

984
00:37:19,680 --> 00:37:22,320
which is a legacy application and let's

985
00:37:22,320 --> 00:37:23,440
say we did not get

986
00:37:23,440 --> 00:37:26,560
funding to change the monolith legacy

987
00:37:26,560 --> 00:37:28,320
application into a more modern

988
00:37:28,320 --> 00:37:30,800
microservice oriented architecture

989
00:37:30,800 --> 00:37:34,160
and as a result it has vulnerability

990
00:37:34,160 --> 00:37:36,960
so there is some data which is not

991
00:37:36,960 --> 00:37:38,160
validated

992
00:37:38,160 --> 00:37:40,640
and when your application gets in touch

993
00:37:40,640 --> 00:37:41,760
with that

994
00:37:41,760 --> 00:37:45,520
uh data store it gets affected by

995
00:37:45,520 --> 00:37:47,119
cross-site scripting

996
00:37:47,119 --> 00:37:49,760
and when the cross-site scripting is not

997
00:37:49,760 --> 00:37:51,040
visible

998
00:37:51,040 --> 00:37:54,079
on the front end but it exists

999
00:37:54,079 --> 00:37:56,640
it is called blind cross site scripting

1000
00:37:56,640 --> 00:37:57,760
so because of this

1001
00:37:57,760 --> 00:38:02,160
complex a complexity arise due to a mix

1002
00:38:02,160 --> 00:38:04,960
hybrid mix of you know monolith micro

1003
00:38:04,960 --> 00:38:06,480
services which is a combination of

1004
00:38:06,480 --> 00:38:08,400
legacy and new applications

1005
00:38:08,400 --> 00:38:11,200
it is quite possible that old code is

1006
00:38:11,200 --> 00:38:13,200
making your new code vulnerable

1007
00:38:13,200 --> 00:38:15,839
so therefore very important if something

1008
00:38:15,839 --> 00:38:16,720
is in your

1009
00:38:16,720 --> 00:38:19,760
application scope make sure all the user

1010
00:38:19,760 --> 00:38:20,960
entered

1011
00:38:20,960 --> 00:38:24,880
input is thoroughly validated

1012
00:38:26,240 --> 00:38:29,200
let's go to the next one this one is

1013
00:38:29,200 --> 00:38:30,160
about

1014
00:38:30,160 --> 00:38:33,520
secure handling and storing of secrets

1015
00:38:33,520 --> 00:38:36,480
usually i have seen in a monolith

1016
00:38:36,480 --> 00:38:37,760
applications

1017
00:38:37,760 --> 00:38:41,040
secrets are stored uh in

1018
00:38:41,040 --> 00:38:44,480
plain text files environmental variables

1019
00:38:44,480 --> 00:38:47,359
or runtime configuration files assuming

1020
00:38:47,359 --> 00:38:49,280
that attacker can't get there and

1021
00:38:49,280 --> 00:38:50,720
doesn't have access

1022
00:38:50,720 --> 00:38:53,599
but in microservices world that's not

1023
00:38:53,599 --> 00:38:54,480
true

1024
00:38:54,480 --> 00:38:56,640
everything is out there and because of

1025
00:38:56,640 --> 00:38:58,560
the sheer complexity

1026
00:38:58,560 --> 00:39:00,880
just see how many different types of

1027
00:39:00,880 --> 00:39:02,400
secrets we deal with

1028
00:39:02,400 --> 00:39:05,359
secrets related to api service each api

1029
00:39:05,359 --> 00:39:08,000
service secrets related to artifactory

1030
00:39:08,000 --> 00:39:10,160
secrets related to your ci cd

1031
00:39:10,160 --> 00:39:12,640
environment secrets related to testing

1032
00:39:12,640 --> 00:39:13,200
or

1033
00:39:13,200 --> 00:39:16,240
code management all secrets

1034
00:39:16,240 --> 00:39:20,079
must go in a weighted

1035
00:39:20,079 --> 00:39:23,680
secret store cloud service provider

1036
00:39:23,680 --> 00:39:26,560
provides tons and tons of options here

1037
00:39:26,560 --> 00:39:27,680
always use

1038
00:39:27,680 --> 00:39:30,640
the secret store provided by the cloud

1039
00:39:30,640 --> 00:39:32,800
service provider and weighted by your

1040
00:39:32,800 --> 00:39:33,680
security team

1041
00:39:33,680 --> 00:39:36,560
super important

1042
00:39:37,119 --> 00:39:40,079
now let's take a look at how we can

1043
00:39:40,079 --> 00:39:42,960
scale security

1044
00:39:42,960 --> 00:39:45,440
we have seen how difficult the

1045
00:39:45,440 --> 00:39:47,520
architecture becomes how complex it

1046
00:39:47,520 --> 00:39:48,240
becomes

1047
00:39:48,240 --> 00:39:50,560
and therefore the speed at which

1048
00:39:50,560 --> 00:39:53,599
developer wants to deploy

1049
00:39:53,599 --> 00:39:57,440
the code is not the same

1050
00:39:57,440 --> 00:40:00,079
speed at which security team can do all

1051
00:40:00,079 --> 00:40:01,200
these reviews

1052
00:40:01,200 --> 00:40:04,160
that's exactly where tooling comes into

1053
00:40:04,160 --> 00:40:06,640
the picture

1054
00:40:07,040 --> 00:40:09,760
use your static code analysis tool

1055
00:40:09,760 --> 00:40:10,800
integrated

1056
00:40:10,800 --> 00:40:14,079
uh in your ide itself so that as soon as

1057
00:40:14,079 --> 00:40:15,040
you write code

1058
00:40:15,040 --> 00:40:18,319
you can find out about those silly

1059
00:40:18,319 --> 00:40:20,480
you know security defects we make

1060
00:40:20,480 --> 00:40:22,160
unknowingly

1061
00:40:22,160 --> 00:40:25,359
even before the comment then use

1062
00:40:25,359 --> 00:40:28,400
you know your application specifics uh

1063
00:40:28,400 --> 00:40:30,880
secure configuration checks at the time

1064
00:40:30,880 --> 00:40:32,400
of build

1065
00:40:32,400 --> 00:40:35,359
and what this means is you can use some

1066
00:40:35,359 --> 00:40:37,200
homegrown scanners as well which are

1067
00:40:37,200 --> 00:40:39,040
specific to your applications

1068
00:40:39,040 --> 00:40:41,760
in case you don't find commercial tools

1069
00:40:41,760 --> 00:40:43,119
in testing phase

1070
00:40:43,119 --> 00:40:45,359
make sure you're performing your dynamic

1071
00:40:45,359 --> 00:40:47,119
application security testing

1072
00:40:47,119 --> 00:40:49,119
or lately interactive application

1073
00:40:49,119 --> 00:40:50,960
security testing is becoming very

1074
00:40:50,960 --> 00:40:51,760
popular

1075
00:40:51,760 --> 00:40:54,240
which is agent-based testing and it has

1076
00:40:54,240 --> 00:40:55,520
access to both

1077
00:40:55,520 --> 00:40:58,000
source code repository and dynamic

1078
00:40:58,000 --> 00:41:00,240
execution of your application

1079
00:41:00,240 --> 00:41:03,440
so it uses both the sources to come up

1080
00:41:03,440 --> 00:41:04,880
with more intelligent

1081
00:41:04,880 --> 00:41:06,960
uh true positives and less false

1082
00:41:06,960 --> 00:41:08,079
positives

1083
00:41:08,079 --> 00:41:11,040
so make sure all these tools are nicely

1084
00:41:11,040 --> 00:41:13,599
integrated in your ci cd pipeline

1085
00:41:13,599 --> 00:41:16,000
if you are using serverless applications

1086
00:41:16,000 --> 00:41:17,359
as container

1087
00:41:17,359 --> 00:41:19,839
ensure that your templates go through

1088
00:41:19,839 --> 00:41:21,200
security reviews

1089
00:41:21,200 --> 00:41:24,079
and there is lots and lots of uh free

1090
00:41:24,079 --> 00:41:24,880
open source

1091
00:41:24,880 --> 00:41:27,599
uh container security tools available

1092
00:41:27,599 --> 00:41:28,960
based on your need

1093
00:41:28,960 --> 00:41:31,760
leverage those make your basic templates

1094
00:41:31,760 --> 00:41:32,400
secure

1095
00:41:32,400 --> 00:41:34,160
and hand it over to your development

1096
00:41:34,160 --> 00:41:36,160
teams

1097
00:41:36,160 --> 00:41:38,560
all right so that was about security

1098
00:41:38,560 --> 00:41:41,440
scanning in cicd

1099
00:41:41,440 --> 00:41:44,880
now as you all know these tools are

1100
00:41:44,880 --> 00:41:47,119
in their first or second generation

1101
00:41:47,119 --> 00:41:48,079
these tools

1102
00:41:48,079 --> 00:41:50,720
do not have contacts and that's why they

1103
00:41:50,720 --> 00:41:52,160
generate false positive

1104
00:41:52,160 --> 00:41:55,040
or they do not provide adequate uh

1105
00:41:55,040 --> 00:41:57,440
coverage to your micro services

1106
00:41:57,440 --> 00:42:00,560
in that case what to do i would say

1107
00:42:00,560 --> 00:42:04,319
that write security unit test cases

1108
00:42:04,319 --> 00:42:06,960
and automate them as part of your build

1109
00:42:06,960 --> 00:42:08,880
pipeline

1110
00:42:08,880 --> 00:42:11,680
do it once and run it every time

1111
00:42:11,680 --> 00:42:13,599
leverage your security team

1112
00:42:13,599 --> 00:42:16,960
to do threat modeling of the new feature

1113
00:42:16,960 --> 00:42:19,920
or function you're building they will

1114
00:42:19,920 --> 00:42:21,359
help you to come up with

1115
00:42:21,359 --> 00:42:24,160
abuse cases and then write unit test

1116
00:42:24,160 --> 00:42:24,960
cases

1117
00:42:24,960 --> 00:42:28,960
to cover those abuse cases

1118
00:42:28,960 --> 00:42:32,319
last if you see a pattern of

1119
00:42:32,319 --> 00:42:34,079
application security vulnerability

1120
00:42:34,079 --> 00:42:36,079
either related to the code

1121
00:42:36,079 --> 00:42:39,200
uh or related to you know business logic

1122
00:42:39,200 --> 00:42:41,760
in that case probably commercial tool

1123
00:42:41,760 --> 00:42:42,960
cannot help

1124
00:42:42,960 --> 00:42:45,760
so what really helps is uh build your

1125
00:42:45,760 --> 00:42:47,599
own homegrown scanners

1126
00:42:47,599 --> 00:42:51,040
to detect those vulnerabilities

1127
00:42:51,040 --> 00:42:54,240
all right i know i have covered a lot of

1128
00:42:54,240 --> 00:42:55,760
content and now

1129
00:42:55,760 --> 00:42:59,520
we are moving towards a conclusion

1130
00:42:59,520 --> 00:43:03,119
so let me summarize um today we discuss

1131
00:43:03,119 --> 00:43:06,319
different uh architectures

1132
00:43:06,319 --> 00:43:08,960
how monolith architectures are different

1133
00:43:08,960 --> 00:43:11,599
from microservice oriented architecture

1134
00:43:11,599 --> 00:43:14,079
and then the rise of serverless function

1135
00:43:14,079 --> 00:43:16,480
and why it is important to

1136
00:43:16,480 --> 00:43:20,000
zero trust them by default each time

1137
00:43:20,000 --> 00:43:22,480
you leverage serverless application it

1138
00:43:22,480 --> 00:43:24,240
is extremely important

1139
00:43:24,240 --> 00:43:27,359
to validate the authenticity of the

1140
00:43:27,359 --> 00:43:28,960
serverless application to

1141
00:43:28,960 --> 00:43:32,000
earn trust next

1142
00:43:32,000 --> 00:43:35,599
is uh if you use weighted

1143
00:43:35,599 --> 00:43:38,480
micro service design patterns provided

1144
00:43:38,480 --> 00:43:40,000
by security team and of course

1145
00:43:40,000 --> 00:43:42,079
it's a you know collaborative work

1146
00:43:42,079 --> 00:43:44,720
between security team devops and uh

1147
00:43:44,720 --> 00:43:47,440
the development team these weighted

1148
00:43:47,440 --> 00:43:48,400
design patterns

1149
00:43:48,400 --> 00:43:51,040
really help you to scale and foster

1150
00:43:51,040 --> 00:43:52,960
security

1151
00:43:52,960 --> 00:43:54,800
then we have seen that although the

1152
00:43:54,800 --> 00:43:56,640
design patterns take care

1153
00:43:56,640 --> 00:43:59,760
of majority of security functionalities

1154
00:43:59,760 --> 00:44:02,000
but they do not take care of some of the

1155
00:44:02,000 --> 00:44:04,319
classic application security

1156
00:44:04,319 --> 00:44:06,960
attacks so know that these type of

1157
00:44:06,960 --> 00:44:08,000
attacks are still

1158
00:44:08,000 --> 00:44:11,599
possible and think about how you can

1159
00:44:11,599 --> 00:44:14,079
tackle them you can either leverage you

1160
00:44:14,079 --> 00:44:15,440
know uh commercial

1161
00:44:15,440 --> 00:44:17,520
security tooling which is available out

1162
00:44:17,520 --> 00:44:19,920
there along with the open source tooling

1163
00:44:19,920 --> 00:44:22,560
or you can build your own homegrown

1164
00:44:22,560 --> 00:44:24,240
security scanners

1165
00:44:24,240 --> 00:44:27,119
if you implement those scanners uh with

1166
00:44:27,119 --> 00:44:28,640
your build pipeline

1167
00:44:28,640 --> 00:44:31,520
uh then the shift left of security

1168
00:44:31,520 --> 00:44:34,480
transformation becomes super easy

1169
00:44:34,480 --> 00:44:37,359
and as i said earlier you know tooling

1170
00:44:37,359 --> 00:44:39,680
is not everything it cannot guarantee

1171
00:44:39,680 --> 00:44:40,160
you

1172
00:44:40,160 --> 00:44:42,640
a hundred percent security nobody can

1173
00:44:42,640 --> 00:44:45,040
but what really helps uh when you are in

1174
00:44:45,040 --> 00:44:45,760
design

1175
00:44:45,760 --> 00:44:47,520
and requirement gathering phase is

1176
00:44:47,520 --> 00:44:49,200
threat modeling

1177
00:44:49,200 --> 00:44:51,359
sit down with your development team

1178
00:44:51,359 --> 00:44:52,319
security team

1179
00:44:52,319 --> 00:44:55,599
and do threat modeling in my experience

1180
00:44:55,599 --> 00:44:56,400
i have seen

1181
00:44:56,400 --> 00:44:59,680
is threat modeling returns the highest

1182
00:44:59,680 --> 00:45:01,520
number of vulnerabilities

1183
00:45:01,520 --> 00:45:04,720
it makes you think about abuse cases and

1184
00:45:04,720 --> 00:45:07,119
all possible attacks and gives developer

1185
00:45:07,119 --> 00:45:08,400
enough time

1186
00:45:08,400 --> 00:45:11,760
to uh incorporate those in the

1187
00:45:11,760 --> 00:45:13,359
basic design templates that you're

1188
00:45:13,359 --> 00:45:16,480
building and last

1189
00:45:16,480 --> 00:45:19,760
do not just focus on serverless

1190
00:45:19,760 --> 00:45:21,920
applications or microservice but we'll

1191
00:45:21,920 --> 00:45:24,160
take a look at a complete uh

1192
00:45:24,160 --> 00:45:27,200
stack and ensure there is end-to-end

1193
00:45:27,200 --> 00:45:28,079
security

1194
00:45:28,079 --> 00:45:31,280
implemented now

1195
00:45:31,280 --> 00:45:32,960
uh these are some of the great

1196
00:45:32,960 --> 00:45:34,400
references that i

1197
00:45:34,400 --> 00:45:39,200
used uh to uh build this presentation

1198
00:45:39,200 --> 00:45:43,040
and uh yeah these are great um

1199
00:45:43,040 --> 00:45:46,880
please take a look at these and i will

1200
00:45:46,880 --> 00:45:50,079
take questions now

1201
00:45:50,400 --> 00:45:53,359
thank you everybody

1202
00:45:54,880 --> 00:45:58,240
that was great trippy thanks we got

1203
00:45:58,240 --> 00:46:01,040
one question so far in discord so let me

1204
00:46:01,040 --> 00:46:03,119
take a quick look for you there and it's

1205
00:46:03,119 --> 00:46:05,920
wouldn't sidecar proxies add overhead to

1206
00:46:05,920 --> 00:46:08,000
the microservices

1207
00:46:08,000 --> 00:46:10,319
of course they are that's why they are

1208
00:46:10,319 --> 00:46:12,800
not one size fit all solution

1209
00:46:12,800 --> 00:46:14,800
only when you need that type of

1210
00:46:14,800 --> 00:46:16,880
architecture one should leverage service

1211
00:46:16,880 --> 00:46:17,280
mesh

1212
00:46:17,280 --> 00:46:20,640
with sidecar proxies anything that you

1213
00:46:20,640 --> 00:46:21,200
design

1214
00:46:21,200 --> 00:46:23,440
must map to the business requirement as

1215
00:46:23,440 --> 00:46:26,000
well so yes they are overhead and that

1216
00:46:26,000 --> 00:46:41,359
overhead actually introduces complexity

