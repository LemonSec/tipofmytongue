1
00:00:04,290 --> 00:00:14,009
cool so assume everyone's already sweet

2
00:00:09,410 --> 00:00:16,560
so um I'm gonna be talking about pandas

3
00:00:14,009 --> 00:00:19,890
and rabbits America's in meets merican

4
00:00:16,560 --> 00:00:22,500
fuzzy lot so my name's Matthew daily or

5
00:00:19,890 --> 00:00:27,599
as my friends like to call me Matty

6
00:00:22,500 --> 00:00:29,220
petty you can ask them why you can see

7
00:00:27,599 --> 00:00:32,189
some of my previous work on these

8
00:00:29,220 --> 00:00:35,280
websites here but out-of-date I need to

9
00:00:32,189 --> 00:00:36,660
update them if anything in this talk

10
00:00:35,280 --> 00:00:38,870
interest to you and check it out because

11
00:00:36,660 --> 00:00:41,610
I've found lots more vulnerabilities and

12
00:00:38,870 --> 00:00:45,720
virtual machines and you can see a bit

13
00:00:41,610 --> 00:00:52,140
more detail through there and this talk

14
00:00:45,720 --> 00:00:54,239
is completely unprotected to pull me off

15
00:00:52,140 --> 00:00:56,010
stage at the OWASP Oakland conference

16
00:00:54,240 --> 00:00:59,130
because I was going over time may still

17
00:00:56,010 --> 00:01:02,879
may be in this room so I have to watch

18
00:00:59,130 --> 00:01:04,619
my deck okay so the first thing is first

19
00:01:02,880 --> 00:01:07,020
thing my friend one of his friends said

20
00:01:04,619 --> 00:01:09,110
when I started this introduces talk is

21
00:01:07,020 --> 00:01:14,039
why the animals why pandas and rabbits

22
00:01:09,110 --> 00:01:17,750
so panda is in so the Xin is the mascot

23
00:01:14,040 --> 00:01:19,770
of the Panda is the mascot of Stan

24
00:01:17,750 --> 00:01:21,350
apparently has this name but no one

25
00:01:19,770 --> 00:01:24,750
seems to know what it actually is

26
00:01:21,350 --> 00:01:27,960
originally made so Xin is a hypervisor

27
00:01:24,750 --> 00:01:29,850
it's a fancy word for virtual machine

28
00:01:27,960 --> 00:01:32,990
manager which is a fancy way of signing

29
00:01:29,850 --> 00:01:35,669
saying computers running other computers

30
00:01:32,990 --> 00:01:40,350
and there's two different types of

31
00:01:35,670 --> 00:01:41,670
hypervisor type 1 and type 2 now just be

32
00:01:40,350 --> 00:01:44,880
annoying I'm going to start with type 2

33
00:01:41,670 --> 00:01:46,229
so type 2 is one that runs on top of an

34
00:01:44,880 --> 00:01:48,570
existing operating system so this is

35
00:01:46,229 --> 00:01:49,740
things like VirtualBox parallels you can

36
00:01:48,570 --> 00:01:52,798
see there in orange you'll be running

37
00:01:49,740 --> 00:01:56,039
VirtualBox no run is an F in itself on a

38
00:01:52,799 --> 00:01:58,500
normal operating system type one is like

39
00:01:56,040 --> 00:02:00,750
a Zen or hyper-v or VMware and that's

40
00:01:58,500 --> 00:02:02,070
where the hypervisor is like an

41
00:02:00,750 --> 00:02:04,799
operating system in itself

42
00:02:02,070 --> 00:02:07,080
it runs other oasis on top just how like

43
00:02:04,799 --> 00:02:12,959
another OS would run applications so Zen

44
00:02:07,080 --> 00:02:14,310
is one of these now just a bit of a head

45
00:02:12,959 --> 00:02:15,749
trouble putting some of these things in

46
00:02:14,310 --> 00:02:16,950
the right order so you'll have to be

47
00:02:15,749 --> 00:02:18,240
with me here as I sort of jump between

48
00:02:16,950 --> 00:02:19,350
topics a bit but if you

49
00:02:18,240 --> 00:02:22,230
I'll come back to them and it will make

50
00:02:19,350 --> 00:02:24,440
sense so now I'm gonna talk about CPU

51
00:02:22,230 --> 00:02:26,310
protection rings privilege shrinks so

52
00:02:24,440 --> 00:02:27,630
CPUs have a way of dividing up

53
00:02:26,310 --> 00:02:29,520
privileged just like how you have root

54
00:02:27,630 --> 00:02:31,620
and you know of standard users in a UNIX

55
00:02:29,520 --> 00:02:34,140
environment these are called protection

56
00:02:31,620 --> 00:02:36,120
rings so there's four rings zero to

57
00:02:34,140 --> 00:02:38,279
three because we're computer scientists

58
00:02:36,120 --> 00:02:39,720
and the intent is that the most well the

59
00:02:38,280 --> 00:02:41,520
intent was that the most privileged

60
00:02:39,720 --> 00:02:44,609
which is ring zero would run an

61
00:02:41,520 --> 00:02:46,680
operating system and 1 & 2 would be yeah

62
00:02:44,610 --> 00:02:48,210
1 & 2 would be the drivers and 3 which

63
00:02:46,680 --> 00:02:50,250
is the least privileged would run the

64
00:02:48,210 --> 00:02:53,580
apps themselves however in the real

65
00:02:50,250 --> 00:02:57,150
world we only use rings 0 3 0 for the OS

66
00:02:53,580 --> 00:02:58,830
kernel and 3 4 own for user apps by the

67
00:02:57,150 --> 00:03:00,210
way this is what the until architecture

68
00:02:58,830 --> 00:03:02,400
reference manual looks like they used to

69
00:03:00,210 --> 00:03:04,320
seen these up for free this is my

70
00:03:02,400 --> 00:03:05,790
favorite page turner many many heavy

71
00:03:04,320 --> 00:03:08,640
Knights and beards been reading this one

72
00:03:05,790 --> 00:03:10,380
good old vol 3 a this is part 2

73
00:03:08,640 --> 00:03:11,609
describes protection rings but like half

74
00:03:10,380 --> 00:03:13,530
of it is actually and not in use anymore

75
00:03:11,610 --> 00:03:16,710
so this just shows the complexity of the

76
00:03:13,530 --> 00:03:19,380
x86 in x86 64 architecture as its

77
00:03:16,710 --> 00:03:20,850
evolved over time so back to the type 1

78
00:03:19,380 --> 00:03:23,460
hypervisor how would it integrate with

79
00:03:20,850 --> 00:03:25,980
these privileged rings so we need the OS

80
00:03:23,460 --> 00:03:27,000
the apps the guest OS and the hypervisor

81
00:03:25,980 --> 00:03:29,640
all need to be running at different

82
00:03:27,000 --> 00:03:31,260
privileges but the Oasis expect to be

83
00:03:29,640 --> 00:03:33,299
able to use all the brings from frieza's

84
00:03:31,260 --> 00:03:35,880
zeros so where would the hypervisor go

85
00:03:33,300 --> 00:03:38,910
so this is where hardware virtualization

86
00:03:35,880 --> 00:03:40,140
comes in this is called well Intel's

87
00:03:38,910 --> 00:03:43,340
version of hardware virtualization

88
00:03:40,140 --> 00:03:47,609
extensions VTX and of course AMD is

89
00:03:43,340 --> 00:03:49,320
called so what this introduces is the

90
00:03:47,610 --> 00:03:51,870
idea of a VM mix root and a V mix

91
00:03:49,320 --> 00:03:54,000
non-root surprisingly so this means that

92
00:03:51,870 --> 00:03:56,490
we can have the unchanged operating

93
00:03:54,000 --> 00:03:58,110
systems to continue to use ring 3 + 0 +

94
00:03:56,490 --> 00:04:00,060
1 - if they really want and the

95
00:03:58,110 --> 00:04:04,200
hypervisor can run and bring whatever in

96
00:04:00,060 --> 00:04:05,520
the VM X root now this is ok but what

97
00:04:04,200 --> 00:04:07,369
this requires Hardware extensions to

98
00:04:05,520 --> 00:04:10,140
work so they're pretty common nowadays

99
00:04:07,370 --> 00:04:13,170
but they haven't always been and in

100
00:04:10,140 --> 00:04:15,299
addition is it's sometimes it's not the

101
00:04:13,170 --> 00:04:17,250
most efficient way to virtualize a

102
00:04:15,300 --> 00:04:19,680
system so are there is there a more

103
00:04:17,250 --> 00:04:23,130
efficient way of virtualizing a system

104
00:04:19,680 --> 00:04:25,710
an operating system so looking back at

105
00:04:23,130 --> 00:04:27,210
the type 1 hypervisor stack again here's

106
00:04:25,710 --> 00:04:28,169
our operating systems normally they

107
00:04:27,210 --> 00:04:30,900
don't know that they're running on a

108
00:04:28,169 --> 00:04:31,599
hypervisor right unchanged those Windows

109
00:04:30,900 --> 00:04:34,630
Linux

110
00:04:31,600 --> 00:04:36,280
FreeBSD whatever what would happen if we

111
00:04:34,630 --> 00:04:38,650
would tell them they were running on a

112
00:04:36,280 --> 00:04:40,750
hypervisor so this is called

113
00:04:38,650 --> 00:04:43,090
enlightenment and Zen speech this is a

114
00:04:40,750 --> 00:04:44,920
very nice pun so we tell the operating

115
00:04:43,090 --> 00:04:48,070
systems that we're switching out the

116
00:04:44,920 --> 00:04:50,200
hardware underneath them for in the

117
00:04:48,070 --> 00:04:51,280
hypervisor so they don't freak out when

118
00:04:50,200 --> 00:04:54,370
they see that they're running on

119
00:04:51,280 --> 00:04:55,840
something unusual so that's what this

120
00:04:54,370 --> 00:04:57,790
means is that with our enlightened

121
00:04:55,840 --> 00:04:59,560
operating systems they're able to run

122
00:04:57,790 --> 00:05:01,090
and bring three the same ring as the

123
00:04:59,560 --> 00:05:03,310
applications are actually running and

124
00:05:01,090 --> 00:05:04,960
the hypervisor can use ring zero and

125
00:05:03,310 --> 00:05:06,220
none of this requires any Hardware

126
00:05:04,960 --> 00:05:08,620
extensions because we're still using the

127
00:05:06,220 --> 00:05:10,060
same old privileged ring setup we've

128
00:05:08,620 --> 00:05:11,800
just used we've just pushed the

129
00:05:10,060 --> 00:05:13,780
operating system from ring zero to rank

130
00:05:11,800 --> 00:05:15,400
three now this is called para

131
00:05:13,780 --> 00:05:17,049
virtualization and I got sick of writing

132
00:05:15,400 --> 00:05:20,560
this so you'll probably see me writing

133
00:05:17,050 --> 00:05:23,380
it as PV so para virtualization is fast

134
00:05:20,560 --> 00:05:24,940
it's lightweight but as you can see the

135
00:05:23,380 --> 00:05:26,800
downside is you need an enlightened

136
00:05:24,940 --> 00:05:28,840
operating system so that means things

137
00:05:26,800 --> 00:05:31,030
like linux freebsd open source things

138
00:05:28,840 --> 00:05:33,159
i'll call the windows now they actually

139
00:05:31,030 --> 00:05:35,080
windows did actually write a porter

140
00:05:33,160 --> 00:05:36,760
version of windows XP this is when

141
00:05:35,080 --> 00:05:39,010
Zenith started big speed was a thing

142
00:05:36,760 --> 00:05:41,409
pull it a visual version of Windows XP

143
00:05:39,010 --> 00:05:43,180
to run on Zen they never released it

144
00:05:41,410 --> 00:05:44,830
there was just a research project with

145
00:05:43,180 --> 00:05:49,900
the collaboration with this input as

146
00:05:44,830 --> 00:05:51,190
then team so who actually uses Xion well

147
00:05:49,900 --> 00:05:53,320
you might have heard of these guys so

148
00:05:51,190 --> 00:05:56,110
these guys use it for ec2 and these are

149
00:05:53,320 --> 00:05:59,170
slightly modified is in kernel and these

150
00:05:56,110 --> 00:06:00,970
guys Rex press rec space cloud similar

151
00:05:59,170 --> 00:06:03,670
sort of thing and chances are if you

152
00:06:00,970 --> 00:06:05,530
have a unix linux unix VPS provider

153
00:06:03,670 --> 00:06:09,280
chances are they can be using either k

154
00:06:05,530 --> 00:06:11,619
vm or it's in people that slightly it's

155
00:06:09,280 --> 00:06:14,950
about half and half use between the two

156
00:06:11,620 --> 00:06:17,320
I know mine uses Zin

157
00:06:14,950 --> 00:06:18,430
for example okay so now the REA but that

158
00:06:17,320 --> 00:06:20,170
was about the Panda and how about the

159
00:06:18,430 --> 00:06:21,400
record the bunny so this is the bunny

160
00:06:20,170 --> 00:06:23,530
you believe it or not this is an

161
00:06:21,400 --> 00:06:25,870
American fuzzy lob it's a breed of

162
00:06:23,530 --> 00:06:28,539
rabbit so I just want to quickly talk to

163
00:06:25,870 --> 00:06:31,860
you about what fuzzing or what American

164
00:06:28,540 --> 00:06:33,940
the fuzzy lock does which is fuzzing so

165
00:06:31,860 --> 00:06:36,840
let's say we have some system that

166
00:06:33,940 --> 00:06:38,890
accepts potentially untrusted input

167
00:06:36,840 --> 00:06:40,830
fuzzing is the process of trying to

168
00:06:38,890 --> 00:06:41,950
break that system by providing it with

169
00:06:40,830 --> 00:06:44,409
malformed

170
00:06:41,950 --> 00:06:45,280
input so that malformed input might be

171
00:06:44,410 --> 00:06:47,320
you know

172
00:06:45,280 --> 00:06:48,880
Alicia's in nature if we're trying to

173
00:06:47,320 --> 00:06:51,849
actually break it or it could just be

174
00:06:48,880 --> 00:06:53,919
the wild world of crazy PDFs and JPEGs

175
00:06:51,850 --> 00:06:55,810
and all the way it files out there so

176
00:06:53,919 --> 00:06:58,120
the data can be mutated versions of

177
00:06:55,810 --> 00:07:01,150
things that would normally expect or it

178
00:06:58,120 --> 00:07:03,280
could be things can be data generated

179
00:07:01,150 --> 00:07:05,229
from scratch from a specification so you

180
00:07:03,280 --> 00:07:06,880
might make a JPEG image by taking you

181
00:07:05,230 --> 00:07:09,250
might fuzz a JPEG reader by taking a

182
00:07:06,880 --> 00:07:11,230
JPEG image you taste a little bit so

183
00:07:09,250 --> 00:07:13,389
flips and Burt's swats and bits around

184
00:07:11,230 --> 00:07:15,880
drop some stuff and send that to the to

185
00:07:13,389 --> 00:07:18,510
the JPEG loader alternatively you might

186
00:07:15,880 --> 00:07:22,240
make a JPEG from scratch like

187
00:07:18,510 --> 00:07:24,010
generatively so anyway what we hope is

188
00:07:22,240 --> 00:07:26,410
that the system under the under test

189
00:07:24,010 --> 00:07:29,080
takes that input and completely freaks

190
00:07:26,410 --> 00:07:30,850
out and in the world of software what we

191
00:07:29,080 --> 00:07:32,590
ideally want to see is a crash of some

192
00:07:30,850 --> 00:07:34,840
sort this would indicate that the

193
00:07:32,590 --> 00:07:35,770
software has done something naughty wolf

194
00:07:34,840 --> 00:07:38,289
memory and memory corruption

195
00:07:35,770 --> 00:07:41,200
vulnerability and these are frequently

196
00:07:38,290 --> 00:07:43,030
well usually exploitable so this is the

197
00:07:41,200 --> 00:07:44,979
way that we can use a fuzzy not just for

198
00:07:43,030 --> 00:07:48,280
reliability testing but to actually find

199
00:07:44,979 --> 00:07:52,210
security bugs vulnerabilities in

200
00:07:48,280 --> 00:07:53,950
software so fuzzer can generate a huge

201
00:07:52,210 --> 00:07:56,830
amount of random inputs from a small

202
00:07:53,950 --> 00:08:00,729
sample of test cases represented by

203
00:07:56,830 --> 00:08:02,260
these god-awful drawings so each of

204
00:08:00,729 --> 00:08:04,330
these represents a different randomized

205
00:08:02,260 --> 00:08:07,780
test case now this is all well and good

206
00:08:04,330 --> 00:08:08,349
but as you know software isn't quite

207
00:08:07,780 --> 00:08:10,359
that simple

208
00:08:08,350 --> 00:08:12,850
so this randomness can sometimes hurt us

209
00:08:10,360 --> 00:08:14,979
so imagine a system that checks certain

210
00:08:12,850 --> 00:08:16,630
predicates on tests and puts before it

211
00:08:14,979 --> 00:08:18,849
actually goes ahead and does any

212
00:08:16,630 --> 00:08:21,240
processing on it so here we have the

213
00:08:18,850 --> 00:08:23,919
thing processor Enterprise Edition

214
00:08:21,240 --> 00:08:26,080
whatever and basically this is going to

215
00:08:23,919 --> 00:08:28,150
check you know some two key attributes

216
00:08:26,080 --> 00:08:30,010
of the test inputs it gets the color and

217
00:08:28,150 --> 00:08:31,989
that's height so if they don't match

218
00:08:30,010 --> 00:08:33,069
it's going to ignore it and if they do

219
00:08:31,990 --> 00:08:36,430
match then it's going to continue

220
00:08:33,070 --> 00:08:37,960
processing now chances are the cheeks

221
00:08:36,429 --> 00:08:39,609
are going to be implemented fine but the

222
00:08:37,960 --> 00:08:42,460
actual processing is weird the

223
00:08:39,610 --> 00:08:44,950
vulnerabilities may likely may likely to

224
00:08:42,460 --> 00:08:47,830
be so we want to make Kraft hist inputs

225
00:08:44,950 --> 00:08:49,450
that will actually exercise the system

226
00:08:47,830 --> 00:08:52,690
under test efficiently so it will

227
00:08:49,450 --> 00:08:55,420
actually test all all parts of the code

228
00:08:52,690 --> 00:08:58,000
not just these initial checks so for

229
00:08:55,420 --> 00:08:59,020
example those first two checks our first

230
00:08:58,000 --> 00:09:00,820
check is going to rule out

231
00:08:59,020 --> 00:09:03,550
you know these of these ones flight test

232
00:09:00,820 --> 00:09:05,320
cases and finally the second chick is

233
00:09:03,550 --> 00:09:07,270
gonna rule out even more test cases so

234
00:09:05,320 --> 00:09:08,800
we spend a lot of time generating and

235
00:09:07,270 --> 00:09:11,230
running all these test cases on our

236
00:09:08,800 --> 00:09:13,120
target software that without only

237
00:09:11,230 --> 00:09:15,460
without actually doing anything we only

238
00:09:13,120 --> 00:09:17,350
got one very few small my small amount

239
00:09:15,460 --> 00:09:20,050
of test cases will actually do anything

240
00:09:17,350 --> 00:09:22,620
useful so this is where we're AFL stiffs

241
00:09:20,050 --> 00:09:25,120
and AFL is what's called a guided fuzzer

242
00:09:22,620 --> 00:09:26,980
so instead of just purely randomly

243
00:09:25,120 --> 00:09:29,410
generating test cases and throwing them

244
00:09:26,980 --> 00:09:31,180
at the the system under test well it

245
00:09:29,410 --> 00:09:33,880
does that to start with but what it does

246
00:09:31,180 --> 00:09:37,329
is it looks at the code path execution

247
00:09:33,880 --> 00:09:39,880
the execution code path taken in

248
00:09:37,330 --> 00:09:43,210
response to each test input and so what

249
00:09:39,880 --> 00:09:45,700
it can do is over time it can watch to

250
00:09:43,210 --> 00:09:48,040
see these Co paths and figure out which

251
00:09:45,700 --> 00:09:50,500
of the inputs are actually exercising

252
00:09:48,040 --> 00:09:53,650
new test cases and which ones aren't

253
00:09:50,500 --> 00:09:55,660
and then after it's built up a sort of

254
00:09:53,650 --> 00:09:57,819
internal graph of what the program looks

255
00:09:55,660 --> 00:10:00,160
like as a general idea of which parts of

256
00:09:57,820 --> 00:10:02,290
the intestine put interesting mm which

257
00:10:00,160 --> 00:10:04,660
parts aren't so what we'll end up with

258
00:10:02,290 --> 00:10:06,130
is actually generating test inputs after

259
00:10:04,660 --> 00:10:08,589
a small amount of time that actually

260
00:10:06,130 --> 00:10:11,620
makes sense to be tested on the system

261
00:10:08,590 --> 00:10:15,100
under test so to give you an example I

262
00:10:11,620 --> 00:10:18,250
was writing a buzzer for a job I was

263
00:10:15,100 --> 00:10:22,120
doing and it were head to fuzz network

264
00:10:18,250 --> 00:10:24,190
traffic now we used a dumb fuzzy first

265
00:10:22,120 --> 00:10:26,020
so that just generates random near word

266
00:10:24,190 --> 00:10:28,840
packets and throws him at the minute the

267
00:10:26,020 --> 00:10:30,400
device under test and it was all good so

268
00:10:28,840 --> 00:10:32,560
I lift up running over the weekend to

269
00:10:30,400 --> 00:10:36,459
come back and saw that it had decided to

270
00:10:32,560 --> 00:10:38,199
fuzz IP version 5 for about two days and

271
00:10:36,460 --> 00:10:40,780
you can see that's gonna do absolutely

272
00:10:38,200 --> 00:10:43,240
nothing right so I want to be able to

273
00:10:40,780 --> 00:10:44,709
reuse guided fuzz that quickly sees try

274
00:10:43,240 --> 00:10:47,290
off your vision to nothing does

275
00:10:44,710 --> 00:10:48,790
something try ot vision t3 same thing

276
00:10:47,290 --> 00:10:51,160
happened for something different

277
00:10:48,790 --> 00:10:53,560
happened okay let's try poking for a bit

278
00:10:51,160 --> 00:10:55,209
more this is guided fuzzing once we do

279
00:10:53,560 --> 00:10:57,550
as a test and find a test input that

280
00:10:55,210 --> 00:10:59,620
does some different code execution path

281
00:10:57,550 --> 00:11:01,359
we hold onto that and then we we then

282
00:10:59,620 --> 00:11:04,420
start mutating from that one and so we

283
00:11:01,360 --> 00:11:08,020
get levels and levels of mutation this

284
00:11:04,420 --> 00:11:10,449
is really efficient and it's it's a one

285
00:11:08,020 --> 00:11:12,339
of the more practical breakthroughs to

286
00:11:10,450 --> 00:11:14,410
come through in the world of fuzzing

287
00:11:12,339 --> 00:11:17,529
there isn't from like that pure academic

288
00:11:14,410 --> 00:11:19,839
side so FL will run all of these test

289
00:11:17,529 --> 00:11:20,620
cases on the target and C's see which

290
00:11:19,839 --> 00:11:23,290
ones fail

291
00:11:20,620 --> 00:11:25,660
so for each tip failing test case we can

292
00:11:23,290 --> 00:11:28,839
get the bug data and so from there we

293
00:11:25,660 --> 00:11:30,490
can do the sometimes the harder part

294
00:11:28,839 --> 00:11:32,319
which is actually to find out why this

295
00:11:30,490 --> 00:11:34,360
test input crash their program and

296
00:11:32,319 --> 00:11:35,979
usually during that process you

297
00:11:34,360 --> 00:11:37,089
implicitly also can sort of figure out

298
00:11:35,980 --> 00:11:39,759
well how would I usually start

299
00:11:37,089 --> 00:11:40,779
exploiting this how can I do tune this

300
00:11:39,759 --> 00:11:42,670
test important to something that does

301
00:11:40,779 --> 00:11:45,579
crash as the program into something that

302
00:11:42,670 --> 00:11:49,540
actually makes it vulnerable and does

303
00:11:45,579 --> 00:11:51,370
something that I wanted to do so AFL

304
00:11:49,540 --> 00:11:53,290
generates this fast inputs into the

305
00:11:51,370 --> 00:11:54,699
target gets execution bitmap which is a

306
00:11:53,290 --> 00:11:57,099
fancy way of to say in the code path

307
00:11:54,699 --> 00:12:00,430
that the program took an doubtful a

308
00:11:57,100 --> 00:12:02,860
bunch of results a crashing test cases

309
00:12:00,430 --> 00:12:05,138
so this is all cool but how would we go

310
00:12:02,860 --> 00:12:08,410
integrating this with AF how old we

311
00:12:05,139 --> 00:12:11,199
integrate AFL words in so it's easy to

312
00:12:08,410 --> 00:12:13,389
see how you would integrate AFL with a

313
00:12:11,199 --> 00:12:15,399
file types on a file type handler right

314
00:12:13,389 --> 00:12:17,439
so a PDF reader you would just put your

315
00:12:15,399 --> 00:12:19,209
test your test case is the file in that

316
00:12:17,439 --> 00:12:21,099
case your GPA or your PDF or whatever

317
00:12:19,209 --> 00:12:24,279
and so for network protocols it's

318
00:12:21,100 --> 00:12:25,929
similar people have done work to modify

319
00:12:24,279 --> 00:12:27,939
a a fail a little bit so that instead of

320
00:12:25,929 --> 00:12:29,499
outputting its test cases to file it

321
00:12:27,939 --> 00:12:31,990
outputs them to in it wherever a network

322
00:12:29,499 --> 00:12:34,329
socket and then it can see the result of

323
00:12:31,990 --> 00:12:37,139
the program the server after it reads

324
00:12:34,329 --> 00:12:39,998
that socket by the hypervisor so

325
00:12:37,139 --> 00:12:42,579
hypervisor is a pretty low level thing

326
00:12:39,999 --> 00:12:45,879
and it's a brand virtual machine so like

327
00:12:42,579 --> 00:12:48,160
it's not potentially and I have done it

328
00:12:45,879 --> 00:12:51,850
you could fuzz like the file format that

329
00:12:48,160 --> 00:12:54,129
it uses to you know load vm's like OVA

330
00:12:51,850 --> 00:13:03,579
files for example and VirtualBox and

331
00:12:54,129 --> 00:13:05,860
whatever else Oracle VM and anyway apart

332
00:13:03,579 --> 00:13:07,149
from the the virtual machine file format

333
00:13:05,860 --> 00:13:09,459
itself what else is there that we could

334
00:13:07,149 --> 00:13:11,949
fuzz so let's look at the type 1

335
00:13:09,459 --> 00:13:13,748
hypervisor stack again and remember

336
00:13:11,949 --> 00:13:15,160
these remember our guest OS is our

337
00:13:13,749 --> 00:13:16,569
enlightened so they know they're running

338
00:13:15,160 --> 00:13:18,160
on a hypervisor they know they're

339
00:13:16,569 --> 00:13:21,519
running and ring 3 which isn't normal

340
00:13:18,160 --> 00:13:23,709
so on native hardware that the operating

341
00:13:21,519 --> 00:13:24,759
system can just tell the hardware the

342
00:13:23,709 --> 00:13:26,018
operating system we just tell the

343
00:13:24,759 --> 00:13:27,489
hardware to do things

344
00:13:26,019 --> 00:13:30,999
right to interact with hardware devices

345
00:13:27,489 --> 00:13:32,679
to allocate memory to do whatever but

346
00:13:30,999 --> 00:13:33,699
will para virtualization and I wrote the

347
00:13:32,679 --> 00:13:35,709
whole thing for some reason

348
00:13:33,699 --> 00:13:38,229
Zen is in the middle right and so

349
00:13:35,709 --> 00:13:39,579
operating systems can't just have direct

350
00:13:38,230 --> 00:13:40,779
access to the hardware because otherwise

351
00:13:39,579 --> 00:13:43,029
I'd be able to break out of their

352
00:13:40,779 --> 00:13:44,379
virtual machine confines and the whole

353
00:13:43,029 --> 00:13:45,999
point of design is that it's there's

354
00:13:44,379 --> 00:13:48,249
hypervisor to prevent or afford any

355
00:13:45,999 --> 00:13:50,199
systems from being able to do that so

356
00:13:48,249 --> 00:13:51,519
when an operating system needs a thing

357
00:13:50,199 --> 00:13:54,248
and these are mechanisms to be able to

358
00:13:51,519 --> 00:13:56,470
request that from Xion and so then can

359
00:13:54,249 --> 00:13:58,449
then actually do the interaction with

360
00:13:56,470 --> 00:14:01,629
hardware if it likes what it sees the

361
00:13:58,449 --> 00:14:04,269
the request is okay and we will do it

362
00:14:01,629 --> 00:14:06,189
does its thing this is it that it ends

363
00:14:04,269 --> 00:14:06,879
in pretends that I did it to the

364
00:14:06,189 --> 00:14:10,509
operating system

365
00:14:06,879 --> 00:14:12,249
now what would hit so this is useful

366
00:14:10,509 --> 00:14:13,929
because we can then this provides the

367
00:14:12,249 --> 00:14:15,279
necessary isolation that guarantees that

368
00:14:13,929 --> 00:14:17,319
we need so if an operating system tries

369
00:14:15,279 --> 00:14:19,569
to do something dodgy or just wrong

370
00:14:17,319 --> 00:14:22,868
because the mistake right the scene you

371
00:14:19,569 --> 00:14:24,429
can say no and that no can vary all the

372
00:14:22,869 --> 00:14:26,709
way from an error code to killing the

373
00:14:24,429 --> 00:14:28,059
entire operating system but either way

374
00:14:26,709 --> 00:14:29,649
he's in keeps running the hardware is

375
00:14:28,059 --> 00:14:31,329
still happy and the other operating

376
00:14:29,649 --> 00:14:33,129
systems are still busy sleeping or doing

377
00:14:31,329 --> 00:14:37,089
whatever they want so you can't Theory

378
00:14:33,129 --> 00:14:41,920
break out of your VPS and 2zn by through

379
00:14:37,089 --> 00:14:44,170
these Hydra calls or can you so in a

380
00:14:41,920 --> 00:14:47,259
normal operating system environment sits

381
00:14:44,170 --> 00:14:48,819
on the left hand side well in both both

382
00:14:47,259 --> 00:14:50,170
environments applications talk to the

383
00:14:48,819 --> 00:14:52,240
operating system they're running on

384
00:14:50,170 --> 00:14:54,389
using system calls so the system calls

385
00:14:52,240 --> 00:14:57,279
are things like read write open close

386
00:14:54,389 --> 00:14:59,769
socket connect those sort of things if

387
00:14:57,279 --> 00:15:01,779
you've done programming using the

388
00:14:59,769 --> 00:15:04,209
Odyssey for example so these are the

389
00:15:01,779 --> 00:15:05,619
calls there an application can't do

390
00:15:04,209 --> 00:15:07,388
themselves it needs to talk to the wider

391
00:15:05,619 --> 00:15:08,829
world somehow so it uses operating

392
00:15:07,389 --> 00:15:12,129
system to do that and it uses system

393
00:15:08,829 --> 00:15:13,989
calls equivalent in a hypervisor

394
00:15:12,129 --> 00:15:15,850
situation as high for calls because that

395
00:15:13,990 --> 00:15:17,799
sounds even better than system calls so

396
00:15:15,850 --> 00:15:19,990
high for calls allow an operating system

397
00:15:17,799 --> 00:15:22,230
to although one of those enlightened

398
00:15:19,990 --> 00:15:24,819
operating systems to communicate this in

399
00:15:22,230 --> 00:15:26,829
so this is the list of hyper calls that

400
00:15:24,819 --> 00:15:29,559
we have there's quite a large attack

401
00:15:26,829 --> 00:15:32,349
surface you can see there so what we

402
00:15:29,559 --> 00:15:36,118
could perhaps do is take these hyper

403
00:15:32,350 --> 00:15:38,499
calls as the input that we can fast so

404
00:15:36,119 --> 00:15:39,400
once again the cute little shapes

405
00:15:38,499 --> 00:15:42,430
represent a

406
00:15:39,400 --> 00:15:44,020
fuzz inputs so when if our malicious

407
00:15:42,430 --> 00:15:47,229
operating systems can say that it needs

408
00:15:44,020 --> 00:15:48,970
to do something with a first hyper call

409
00:15:47,230 --> 00:15:51,790
and we give that to zine and see what

410
00:15:48,970 --> 00:15:53,320
happens so Zen might get confused or it

411
00:15:51,790 --> 00:15:55,360
might get so confused that it kills

412
00:15:53,320 --> 00:15:57,250
itself and the hardware is unhealthy or

413
00:15:55,360 --> 00:15:58,570
it might who knows what it's going to do

414
00:15:57,250 --> 00:15:59,920
but that's what we want we want to see

415
00:15:58,570 --> 00:16:01,779
the system under test do something

416
00:15:59,920 --> 00:16:05,020
unusual so we can see if we can then

417
00:16:01,779 --> 00:16:05,500
exploit that how can we get a FL to do

418
00:16:05,020 --> 00:16:07,810
this for us

419
00:16:05,500 --> 00:16:09,610
so fuzzing the application is pretty

420
00:16:07,810 --> 00:16:11,859
easy so I keep jumping between native

421
00:16:09,610 --> 00:16:13,960
and visualized worlds you have to be

422
00:16:11,860 --> 00:16:15,490
able to me here but so fuzzing an F is

423
00:16:13,960 --> 00:16:17,380
easy in the native world right you ran

424
00:16:15,490 --> 00:16:19,570
your fuzzer on the same machine as the

425
00:16:17,380 --> 00:16:20,860
application itself if the app dies and

426
00:16:19,570 --> 00:16:22,660
the fuzzer can just ask the operating

427
00:16:20,860 --> 00:16:25,180
system to restart it and that's cool

428
00:16:22,660 --> 00:16:26,199
your fuzzing an operating system well of

429
00:16:25,180 --> 00:16:27,910
course you probably want to use a

430
00:16:26,200 --> 00:16:29,710
virtual machine I've like a hypervisor

431
00:16:27,910 --> 00:16:31,060
and run your fuzzer and a different

432
00:16:29,710 --> 00:16:32,920
operating system than the one you're

433
00:16:31,060 --> 00:16:34,540
actually fuzzing so that way if that

434
00:16:32,920 --> 00:16:37,150
your operating system your testing

435
00:16:34,540 --> 00:16:38,680
crashes the fuzz I can ask through the

436
00:16:37,150 --> 00:16:40,329
operate its operating system and through

437
00:16:38,680 --> 00:16:43,000
the hypervisor to launch that operating

438
00:16:40,330 --> 00:16:45,700
system and start again but if you're

439
00:16:43,000 --> 00:16:47,589
fuzzing a hypervisor well when the

440
00:16:45,700 --> 00:16:49,690
hypervisor crashes everything crashes

441
00:16:47,589 --> 00:16:51,279
and when I say crash I mean everything

442
00:16:49,690 --> 00:16:53,680
crashes like the Machine actually you

443
00:16:51,279 --> 00:16:55,570
have to pull the power or physically

444
00:16:53,680 --> 00:16:57,010
restart it to in the bug road you have

445
00:16:55,570 --> 00:16:57,640
to actually physically restart it to get

446
00:16:57,010 --> 00:16:59,410
it going again

447
00:16:57,640 --> 00:17:00,850
now this isn't conducive to fuzzing

448
00:16:59,410 --> 00:17:03,760
because I don't want to sit there

449
00:17:00,850 --> 00:17:05,110
playing with it all day so what we could

450
00:17:03,760 --> 00:17:07,240
do is we could split the fuzzer on two

451
00:17:05,109 --> 00:17:08,829
separate physical machine just like good

452
00:17:07,240 --> 00:17:10,900
old days before virtual machines and put

453
00:17:08,829 --> 00:17:12,490
the target host that puts us in the

454
00:17:10,900 --> 00:17:15,550
retargeting and a different physical

455
00:17:12,490 --> 00:17:17,140
host so AFL instead of launching a

456
00:17:15,550 --> 00:17:19,899
program that wants to test it launches a

457
00:17:17,140 --> 00:17:21,730
stub little temporary stub that stub

458
00:17:19,900 --> 00:17:23,589
talks to a persistent connector which

459
00:17:21,730 --> 00:17:25,059
talks to a stub operating system on the

460
00:17:23,589 --> 00:17:29,919
test environment which then does the

461
00:17:25,059 --> 00:17:31,920
haifa call so remember fuzzing runs in

462
00:17:29,920 --> 00:17:34,030
the loop tight loop to generate results

463
00:17:31,920 --> 00:17:36,700
and we want this to be as fast as

464
00:17:34,030 --> 00:17:39,129
possible so in the world of AFL for

465
00:17:36,700 --> 00:17:41,290
example if it if you get less than 100

466
00:17:39,130 --> 00:17:43,240
you know test runs per second it

467
00:17:41,290 --> 00:17:45,610
considers that slow and if you get less

468
00:17:43,240 --> 00:17:48,940
than 20 it considers asleep

469
00:17:45,610 --> 00:17:51,310
so this first initial team got 12

470
00:17:48,940 --> 00:17:53,679
seconds per execution and that's not a

471
00:17:51,310 --> 00:17:56,649
typo that's seconds per

472
00:17:53,679 --> 00:17:59,080
so that 0.083 executions per second

473
00:17:56,649 --> 00:18:03,219
remember a FL thinks 20 per second just

474
00:17:59,080 --> 00:18:05,230
way too slow so yeah so no so what we do

475
00:18:03,220 --> 00:18:06,970
is we could modify FL so that instead of

476
00:18:05,230 --> 00:18:08,919
having that whole stub and persistent

477
00:18:06,970 --> 00:18:10,360
connector malarky it just talks straight

478
00:18:08,919 --> 00:18:12,789
to the stub or any systems like toast

479
00:18:10,360 --> 00:18:15,010
sockets say here's some test data run

480
00:18:12,789 --> 00:18:16,510
this hyper call and it does it and they

481
00:18:15,010 --> 00:18:19,720
can stop any concern back at the code

482
00:18:16,510 --> 00:18:21,879
path through their same socket 10

483
00:18:19,720 --> 00:18:24,240
executions per second ok it's a little

484
00:18:21,880 --> 00:18:25,960
light that's coming through this tunnel

485
00:18:24,240 --> 00:18:28,269
what if we just

486
00:18:25,960 --> 00:18:29,200
what if we just play AFL in the damn

487
00:18:28,269 --> 00:18:31,360
machine that we're trying to test

488
00:18:29,200 --> 00:18:33,760
ourselves and say propose just have a

489
00:18:31,360 --> 00:18:35,379
monitor that can they can handle

490
00:18:33,760 --> 00:18:38,260
restarting machine and collecting logs

491
00:18:35,380 --> 00:18:40,539
because when AFL tells the stub to do a

492
00:18:38,260 --> 00:18:41,980
hyper call which crashes then of course

493
00:18:40,539 --> 00:18:45,429
that entire machine is going to be gone

494
00:18:41,980 --> 00:18:47,320
including AFL with it so the monitor is

495
00:18:45,429 --> 00:18:49,299
able to then restart the whole box and

496
00:18:47,320 --> 00:18:51,428
also little checkpoints so that you know

497
00:18:49,299 --> 00:18:54,399
when it doesn't fall over we haven't

498
00:18:51,429 --> 00:18:55,750
lost a whole day's worth of work I'm so

499
00:18:54,399 --> 00:18:58,299
hundred execution for a second this is

500
00:18:55,750 --> 00:19:00,669
good we can speed it up a little bit

501
00:18:58,299 --> 00:19:01,840
more and it's a little hard to see the

502
00:19:00,669 --> 00:19:03,820
difference here there's no error between

503
00:19:01,840 --> 00:19:06,039
AFL and Xion and this one and it isn't

504
00:19:03,820 --> 00:19:08,918
this one so what that represents is we

505
00:19:06,039 --> 00:19:10,658
instead of the stub being told what the

506
00:19:08,919 --> 00:19:12,970
hyper callers to call and then it

507
00:19:10,659 --> 00:19:15,010
calling it throws in AFL can sort of

508
00:19:12,970 --> 00:19:17,169
pre-pre loads in with the hyper call

509
00:19:15,010 --> 00:19:20,399
data and then tell just tell the stub to

510
00:19:17,169 --> 00:19:22,539
run it so it's works like this AFL tells

511
00:19:20,399 --> 00:19:24,820
what's up with modified fo and with

512
00:19:22,539 --> 00:19:27,309
modified seen in this case because to do

513
00:19:24,820 --> 00:19:29,470
this we tell AFL here's some test data

514
00:19:27,309 --> 00:19:31,539
for you next hyper call and it takes it

515
00:19:29,470 --> 00:19:34,149
and then we tell the stub or a system to

516
00:19:31,539 --> 00:19:36,700
actually execute the hyper calls it's

517
00:19:34,149 --> 00:19:39,459
kind of like a latent pending hyper call

518
00:19:36,700 --> 00:19:40,480
it does it this way as in gets its

519
00:19:39,460 --> 00:19:43,630
knickers in a twist

520
00:19:40,480 --> 00:19:45,279
it's the stub operating system will be

521
00:19:43,630 --> 00:19:49,450
the one that gets killed and not the

522
00:19:45,279 --> 00:19:50,950
operating system running AFL which is

523
00:19:49,450 --> 00:19:53,080
important because the context is

524
00:19:50,950 --> 00:19:54,460
important here of the machine with a the

525
00:19:53,080 --> 00:19:56,260
operating system of AFL running in it

526
00:19:54,460 --> 00:19:57,760
tried to do the hide call itself that

527
00:19:56,260 --> 00:19:58,870
would die so by putting in a stub or

528
00:19:57,760 --> 00:20:00,669
operating system and still doing this

529
00:19:58,870 --> 00:20:02,080
weird split we get the benefits of speed

530
00:20:00,669 --> 00:20:03,760
but also the fact that there are

531
00:20:02,080 --> 00:20:05,929
operating system running AFL doesn't

532
00:20:03,760 --> 00:20:07,610
crash

533
00:20:05,930 --> 00:20:09,440
so I mentioned before that the monitor

534
00:20:07,610 --> 00:20:11,719
on the separate physical host needs to

535
00:20:09,440 --> 00:20:13,880
actually restart the target host wins in

536
00:20:11,720 --> 00:20:18,380
crashes so we have these handy-dandy

537
00:20:13,880 --> 00:20:20,570
things these Belkin power switching off

538
00:20:18,380 --> 00:20:21,920
in Wi-Fi things and I'm lucky enough to

539
00:20:20,570 --> 00:20:24,169
have a power supply which hasn't burnt

540
00:20:21,920 --> 00:20:26,750
out after like a thousand power cycles

541
00:20:24,170 --> 00:20:29,390
so far it would be it would need

542
00:20:26,750 --> 00:20:30,860
restarting probably once every four

543
00:20:29,390 --> 00:20:32,420
minutes I think it depends on what hyper

544
00:20:30,860 --> 00:20:35,149
call your fuzzing and what hard you're

545
00:20:32,420 --> 00:20:38,330
doing it and so this is what my puzzling

546
00:20:35,150 --> 00:20:40,400
setup looks like and my din so you've

547
00:20:38,330 --> 00:20:42,500
got two machines here the one on the

548
00:20:40,400 --> 00:20:43,880
left is the actual the test machine when

549
00:20:42,500 --> 00:20:47,090
it's been fast in the right is the

550
00:20:43,880 --> 00:20:51,200
monitor and this is my networking stick

551
00:20:47,090 --> 00:20:52,580
ache a heap of noodle and this is

552
00:20:51,200 --> 00:20:54,500
an important box because winds in

553
00:20:52,580 --> 00:20:56,780
crashes it's only way of telling you is

554
00:20:54,500 --> 00:20:58,880
via a serial console because it can't

555
00:20:56,780 --> 00:21:00,379
show anything on VGA because that's used

556
00:20:58,880 --> 00:21:02,000
by the one in the operating system from

557
00:21:00,380 --> 00:21:03,770
sample and it can't use Ethan it because

558
00:21:02,000 --> 00:21:05,690
that's controlled it's complicated but

559
00:21:03,770 --> 00:21:07,370
can't so it has to use serial so

560
00:21:05,690 --> 00:21:08,930
originally I just used those serial we

561
00:21:07,370 --> 00:21:10,159
over to USB converters biased against so

562
00:21:08,930 --> 00:21:12,620
many boxes that need a serial output

563
00:21:10,160 --> 00:21:14,240
conversion I brought this from one of

564
00:21:12,620 --> 00:21:16,580
those god-awful you know import sites

565
00:21:14,240 --> 00:21:19,250
and it's it seems to do the job so it's

566
00:21:16,580 --> 00:21:20,990
serial to Ethernet adapter there's some

567
00:21:19,250 --> 00:21:22,640
graphs here this is what the graph AFL

568
00:21:20,990 --> 00:21:24,230
looks like when it's running I don't

569
00:21:22,640 --> 00:21:26,030
expect you to give a crap about what

570
00:21:24,230 --> 00:21:27,950
these are we need to explain what they

571
00:21:26,030 --> 00:21:29,750
are but as one of my friends likes to

572
00:21:27,950 --> 00:21:31,340
quote to me nobody knows what it means

573
00:21:29,750 --> 00:21:34,240
but it's provocative it gets people

574
00:21:31,340 --> 00:21:37,610
going so you can see the lines go down

575
00:21:34,240 --> 00:21:40,940
lines going straight cool

576
00:21:37,610 --> 00:21:42,669
so eventually hopefully Zen will crash

577
00:21:40,940 --> 00:21:45,400
and this is what this looks like so

578
00:21:42,670 --> 00:21:47,630
that's what is English looks like on the

579
00:21:45,400 --> 00:21:49,070
serial console and you can see there

580
00:21:47,630 --> 00:21:50,900
this is manual reset required because I

581
00:21:49,070 --> 00:21:52,700
wanted to stop in this case I don't want

582
00:21:50,900 --> 00:21:56,420
it to automatically restart but the bug

583
00:21:52,700 --> 00:21:57,800
purposes and the the observe enough for

584
00:21:56,420 --> 00:22:00,020
you will have noticed there's a giant

585
00:21:57,800 --> 00:22:02,570
cat sitting on the networking table um

586
00:22:00,020 --> 00:22:04,670
gee okay it is there to inform me if I

587
00:22:02,570 --> 00:22:06,020
get like email those signals or whatsapp

588
00:22:04,670 --> 00:22:08,210
source snaps and it uses a color-coded

589
00:22:06,020 --> 00:22:09,470
is to tell me and purple means Deena's

590
00:22:08,210 --> 00:22:12,260
crashed so this is something I like

591
00:22:09,470 --> 00:22:14,720
coming home to and seeing gee okay it

592
00:22:12,260 --> 00:22:16,790
also holds the proud privilege of owning

593
00:22:14,720 --> 00:22:18,290
its own Twitter account and you know I

594
00:22:16,790 --> 00:22:19,700
even I don't have my own Twitter

595
00:22:18,290 --> 00:22:21,409
and the reason it has one is because

596
00:22:19,700 --> 00:22:24,170
white Skopje okay just as a side thing

597
00:22:21,410 --> 00:22:26,150
is because it used to look at geonets

598
00:22:24,170 --> 00:22:27,710
Twitter feed and tell me the intensities

599
00:22:26,150 --> 00:22:29,390
of earthquakes near earthquakes using

600
00:22:27,710 --> 00:22:31,700
the colors of it sighs unfortunately

601
00:22:29,390 --> 00:22:33,710
GeoNet changed the feed their twitter

602
00:22:31,700 --> 00:22:36,200
layup recently so i need to go and fix

603
00:22:33,710 --> 00:22:37,820
it but yeah one of my internet of things

604
00:22:36,200 --> 00:22:40,040
internet kind of things here's a Twitter

605
00:22:37,820 --> 00:22:41,270
account and I don't so anyway we run the

606
00:22:40,040 --> 00:22:43,070
puzzle like this for bit and we get a

607
00:22:41,270 --> 00:22:45,350
bunch of test inputs test results a

608
00:22:43,070 --> 00:22:48,350
crash let's look at some of those tests

609
00:22:45,350 --> 00:22:50,120
crashes so the first one is coming to do

610
00:22:48,350 --> 00:22:51,590
a bad Numa node handling so numerous

611
00:22:50,120 --> 00:22:52,939
downs for non-uniform memory access and

612
00:22:51,590 --> 00:22:56,000
I'm going really fast now sorry

613
00:22:52,940 --> 00:22:58,520
so non-uniform memory access is ability

614
00:22:56,000 --> 00:23:00,080
for a pro computer to have more than one

615
00:22:58,520 --> 00:23:01,580
kind of memory and and then allow the

616
00:23:00,080 --> 00:23:02,929
applications or the operating systems

617
00:23:01,580 --> 00:23:04,960
running on it to actually specify which

618
00:23:02,930 --> 00:23:07,730
memory is wants to use for an allocation

619
00:23:04,960 --> 00:23:09,620
so in the world of ZN an operating

620
00:23:07,730 --> 00:23:12,650
system can say tells ian i need memory

621
00:23:09,620 --> 00:23:15,110
and a certain Numa notified by into J

622
00:23:12,650 --> 00:23:17,000
IDs so then we'll go looking at internal

623
00:23:15,110 --> 00:23:18,860
structures because hold state for each

624
00:23:17,000 --> 00:23:20,840
of these new Monod and some information

625
00:23:18,860 --> 00:23:22,429
now the problem is is that there's only

626
00:23:20,840 --> 00:23:23,570
a limited amount of for new monoids and

627
00:23:22,430 --> 00:23:25,640
you can see where this is going

628
00:23:23,570 --> 00:23:27,080
zyne doesn't actually check to see if

629
00:23:25,640 --> 00:23:29,960
the Numa node you gave is actually in

630
00:23:27,080 --> 00:23:31,580
range so it'll fall way off the end and

631
00:23:29,960 --> 00:23:35,210
it'll come back to you with like some

632
00:23:31,580 --> 00:23:37,070
really weird situation so what will

633
00:23:35,210 --> 00:23:39,980
either happen is the operating system

634
00:23:37,070 --> 00:23:42,290
will crash or Z in itself will crash now

635
00:23:39,980 --> 00:23:43,970
this is interesting this is good we can

636
00:23:42,290 --> 00:23:45,379
make a little Python POC that will just

637
00:23:43,970 --> 00:23:47,300
do the crashing no exploitation but

638
00:23:45,380 --> 00:23:49,670
it'll do the crash can send that to the

639
00:23:47,300 --> 00:23:51,050
same security team and you can see they

640
00:23:49,670 --> 00:23:52,910
put all their security visors on this

641
00:23:51,050 --> 00:23:54,440
page and I'm proud to be the reason that

642
00:23:52,910 --> 00:24:01,610
they started this page back three years

643
00:23:54,440 --> 00:24:03,020
ago and in this is the advisory yeah

644
00:24:01,610 --> 00:24:04,969
cool

645
00:24:03,020 --> 00:24:07,220
number two is boring just trust me

646
00:24:04,970 --> 00:24:10,340
number three is also boring number four

647
00:24:07,220 --> 00:24:12,170
is slightly more interesting so zine

648
00:24:10,340 --> 00:24:14,689
allows operating systems to share memory

649
00:24:12,170 --> 00:24:16,250
between each other so if the operating

650
00:24:14,690 --> 00:24:18,140
system wants to share memory between two

651
00:24:16,250 --> 00:24:21,080
another one it just asks it and Xin does

652
00:24:18,140 --> 00:24:23,930
the magic and we're heavy there's a

653
00:24:21,080 --> 00:24:26,389
problem where there's certain types so

654
00:24:23,930 --> 00:24:27,620
you specify what virtual machine you

655
00:24:26,390 --> 00:24:29,330
want to see memory worth buying as your

656
00:24:27,620 --> 00:24:30,679
ID but the student into dry J's which is

657
00:24:29,330 --> 00:24:32,120
special they used for like bookkeeping

658
00:24:30,680 --> 00:24:33,410
purposes you know they're like the

659
00:24:32,120 --> 00:24:35,179
the weird numbers off the top of the end

660
00:24:33,410 --> 00:24:36,410
which scientist racism numbers they're

661
00:24:35,180 --> 00:24:37,850
there to say you know operating system

662
00:24:36,410 --> 00:24:40,130
or all operating systems all that sort

663
00:24:37,850 --> 00:24:42,230
of thing so if we tell it's in to share

664
00:24:40,130 --> 00:24:44,660
memory to one of these it tries to do it

665
00:24:42,230 --> 00:24:46,310
so da Mayo is one of those weird numbers

666
00:24:44,660 --> 00:24:47,900
for us talking about tries to do it and

667
00:24:46,310 --> 00:24:50,990
of course a crash it so that's also cool

668
00:24:47,900 --> 00:24:57,260
we rode a Python POC for that we can get

669
00:24:50,990 --> 00:24:58,700
the Advisory thank you okay number five

670
00:24:57,260 --> 00:24:59,510
is boring number six is boring number

671
00:24:58,700 --> 00:25:03,290
seven is too hard

672
00:24:59,510 --> 00:25:05,420
so okay going real fast okay so we've

673
00:25:03,290 --> 00:25:06,980
seen how we can get a test case and we

674
00:25:05,420 --> 00:25:08,150
can get frozen we can find his cases and

675
00:25:06,980 --> 00:25:10,790
they Croatian that's cool but how do we

676
00:25:08,150 --> 00:25:12,560
actually exploit those now so let's take

677
00:25:10,790 --> 00:25:13,970
the first one that you saw there I've

678
00:25:12,560 --> 00:25:15,290
caught a bad node that's not because I'm

679
00:25:13,970 --> 00:25:16,790
some cool marketing person that's just

680
00:25:15,290 --> 00:25:18,110
because that's the first seven

681
00:25:16,790 --> 00:25:21,050
characters that I typed in my get

682
00:25:18,110 --> 00:25:22,909
repository so this is CV by our exes a

683
00:25:21,050 --> 00:25:24,500
two three one so let's just quickly go

684
00:25:22,910 --> 00:25:27,380
over the vulnerability so Xin has two

685
00:25:24,500 --> 00:25:29,870
heaps in heaped on heap so domains can

686
00:25:27,380 --> 00:25:31,490
request and you know request and release

687
00:25:29,870 --> 00:25:33,739
memory into the domain heap and there's

688
00:25:31,490 --> 00:25:39,440
in heap is for all the Zen heap has full

689
00:25:33,740 --> 00:25:41,810
memory that can't be you know accounted

690
00:25:39,440 --> 00:25:43,340
for by a single VM and the Don heap is

691
00:25:41,810 --> 00:25:45,830
for ones that can be account memory that

692
00:25:43,340 --> 00:25:47,389
can be accounted to a single VM so

693
00:25:45,830 --> 00:25:49,250
here's that list of hyper calls again

694
00:25:47,390 --> 00:25:50,630
this is the one that was causing the

695
00:25:49,250 --> 00:25:52,940
crashes we're getting seen these crisis

696
00:25:50,630 --> 00:25:54,380
with memory op this is the format that

697
00:25:52,940 --> 00:25:56,180
we part the structure that we use to

698
00:25:54,380 --> 00:25:58,220
pass in the data the parameters to this

699
00:25:56,180 --> 00:25:59,810
hyper call and this is the attribute

700
00:25:58,220 --> 00:26:02,720
where we actually pass in the new monoid

701
00:25:59,810 --> 00:26:05,540
ID and these are the macros okay

702
00:26:02,720 --> 00:26:08,390
functions that we used to write there to

703
00:26:05,540 --> 00:26:10,430
modify the numeron old ID into the waves

704
00:26:08,390 --> 00:26:14,090
in once if we look here we see there's a

705
00:26:10,430 --> 00:26:16,610
maximum of hex or Hix if which is 255

706
00:26:14,090 --> 00:26:18,290
decimal so we can tell Xin to request an

707
00:26:16,610 --> 00:26:20,750
allocation from an 8-bit wide Numa node

708
00:26:18,290 --> 00:26:23,030
so that between 0 and 255 but of course

709
00:26:20,750 --> 00:26:24,620
there might not be that many nodes okay

710
00:26:23,030 --> 00:26:28,820
this is the start off that this is the

711
00:26:24,620 --> 00:26:32,810
start of the actual they either call

712
00:26:28,820 --> 00:26:34,429
Handler and Xin so this code does some

713
00:26:32,810 --> 00:26:36,379
initial validation of the hyper call

714
00:26:34,430 --> 00:26:38,930
parameters but nothing to do with no

715
00:26:36,380 --> 00:26:41,300
monoids it's bit more generic and so it

716
00:26:38,930 --> 00:26:42,980
calls a function and as that function

717
00:26:41,300 --> 00:26:45,110
and this function calls another function

718
00:26:42,980 --> 00:26:45,890
and that's the function and this calls

719
00:26:45,110 --> 00:26:49,010
another function

720
00:26:45,890 --> 00:26:50,780
and this is that function now the start

721
00:26:49,010 --> 00:26:52,850
of this function is where the important

722
00:26:50,780 --> 00:26:54,379
part is so allocate pages we're in the

723
00:26:52,850 --> 00:26:56,270
right sort of place here so we can see

724
00:26:54,380 --> 00:26:58,580
here this is where it gets the node from

725
00:26:56,270 --> 00:27:00,110
the wave shoved into the memory flags

726
00:26:58,580 --> 00:27:02,770
one of the attributes of the hyper call

727
00:27:00,110 --> 00:27:05,600
that the operating system is Givens in

728
00:27:02,770 --> 00:27:07,430
and we can see that a chick's to see if

729
00:27:05,600 --> 00:27:09,020
node equals Newman or node which is one

730
00:27:07,430 --> 00:27:10,370
of those sort of it's a special signal

731
00:27:09,020 --> 00:27:12,920
value that's is we don't actually care

732
00:27:10,370 --> 00:27:14,149
what Numa note it goes on but that's not

733
00:27:12,920 --> 00:27:17,030
a limit check it's just an equality

734
00:27:14,150 --> 00:27:18,980
check now we do see there's a limit sort

735
00:27:17,030 --> 00:27:21,350
of check here assert node a smaller than

736
00:27:18,980 --> 00:27:24,080
max num note now this sounds pretty like

737
00:27:21,350 --> 00:27:26,149
you know good right we're taking that

738
00:27:24,080 --> 00:27:28,310
the that the node that the user has just

739
00:27:26,150 --> 00:27:30,230
find the hyper call is less than the

740
00:27:28,310 --> 00:27:32,419
maximum number of nodes we know exists

741
00:27:30,230 --> 00:27:34,960
there's a problem here developers will

742
00:27:32,420 --> 00:27:37,070
probably already see it in the bug mode

743
00:27:34,960 --> 00:27:39,530
so there's two modes that you can bot

744
00:27:37,070 --> 00:27:41,000
build it's the in just like he can build

745
00:27:39,530 --> 00:27:43,040
Linux and lots of other things the bug

746
00:27:41,000 --> 00:27:44,570
mode release mode debug mode is what

747
00:27:43,040 --> 00:27:45,950
developers will use release mode is what

748
00:27:44,570 --> 00:27:50,960
actually gets released to the world or

749
00:27:45,950 --> 00:27:52,820
the public so in the bug mode a failing

750
00:27:50,960 --> 00:27:54,590
assertion so an assertion that tries to

751
00:27:52,820 --> 00:27:55,730
check something that doesn't isn't true

752
00:27:54,590 --> 00:27:57,740
and get this case like you know the

753
00:27:55,730 --> 00:27:59,360
number of numa numa node given is bigger

754
00:27:57,740 --> 00:28:01,310
than the number of new monoids it would

755
00:27:59,360 --> 00:28:03,560
stop the program supports to stop scene

756
00:28:01,310 --> 00:28:05,419
with a fatal exception and crap would

757
00:28:03,560 --> 00:28:08,659
scroll up the serial console and cat

758
00:28:05,420 --> 00:28:09,710
starts going nuts in release mode assert

759
00:28:08,660 --> 00:28:12,560
there's absolutely nothing

760
00:28:09,710 --> 00:28:16,610
so assertions aren't meant to be used

761
00:28:12,560 --> 00:28:18,740
for actual error checking that IRA's

762
00:28:16,610 --> 00:28:20,419
might conceivably happen at runtime in

763
00:28:18,740 --> 00:28:22,760
the real world they only mean to be used

764
00:28:20,420 --> 00:28:25,070
for developer sanity checking right

765
00:28:22,760 --> 00:28:27,379
things that if if this condition is

766
00:28:25,070 --> 00:28:29,060
wrong well all hope is lost you just

767
00:28:27,380 --> 00:28:32,690
have to kill the program right if

768
00:28:29,060 --> 00:28:34,330
something has IFFT up so badly in a case

769
00:28:32,690 --> 00:28:36,740
that isn't one of those things you know

770
00:28:34,330 --> 00:28:39,020
guest operating system can give a node

771
00:28:36,740 --> 00:28:42,620
which is out of range we need to be able

772
00:28:39,020 --> 00:28:44,330
to handle that properly so that's their

773
00:28:42,620 --> 00:28:45,919
assertion there isn't actually doing

774
00:28:44,330 --> 00:28:47,600
anything in release mode the bug mode it

775
00:28:45,920 --> 00:28:48,770
does but in release mode so that was

776
00:28:47,600 --> 00:28:50,240
interesting in the bug mode which I'm

777
00:28:48,770 --> 00:28:51,290
where I do normally do my fuzzing I

778
00:28:50,240 --> 00:28:52,460
noticed you know it did a nice simple

779
00:28:51,290 --> 00:28:54,320
assertion feller I was like oh that's

780
00:28:52,460 --> 00:28:55,850
boring but then I noticed you know in

781
00:28:54,320 --> 00:28:57,620
release mode well I keep going at the

782
00:28:55,850 --> 00:28:59,090
actual full memory crash and that's even

783
00:28:57,620 --> 00:29:01,399
more interesting

784
00:28:59,090 --> 00:29:02,658
okay so this is the continuing on down

785
00:29:01,399 --> 00:29:03,949
that functions and we've tried to do

786
00:29:02,659 --> 00:29:05,330
that validation but we haven't on the

787
00:29:03,950 --> 00:29:08,360
Numa node so now let's see what happens

788
00:29:05,330 --> 00:29:10,009
so it uses that notice the node variable

789
00:29:08,360 --> 00:29:12,979
that we've given it and a bunch of

790
00:29:10,009 --> 00:29:14,210
locations so it uses it to see if

791
00:29:12,980 --> 00:29:15,620
there's any memory available in that new

792
00:29:14,210 --> 00:29:18,230
manner which is fired to see if there's

793
00:29:15,620 --> 00:29:19,729
enough memory on that Numa node and then

794
00:29:18,230 --> 00:29:23,749
remove the memory from the heap link

795
00:29:19,730 --> 00:29:25,159
list if there's a second so the

796
00:29:23,749 --> 00:29:26,870
important thing is and all of these

797
00:29:25,159 --> 00:29:29,629
places we could coerce in to crash right

798
00:29:26,870 --> 00:29:30,620
by giving it a new node of 253 or

799
00:29:29,629 --> 00:29:32,418
something like that and it's probably

800
00:29:30,620 --> 00:29:34,309
going to like you know look into a sum

801
00:29:32,419 --> 00:29:36,350
off this end of the array and it's going

802
00:29:34,309 --> 00:29:38,720
to crash in some exciting non exciting

803
00:29:36,350 --> 00:29:40,668
way but exploitation is just a

804
00:29:38,720 --> 00:29:42,799
controlled crash right a crash in a

805
00:29:40,669 --> 00:29:44,749
memory corruption situation usually

806
00:29:42,799 --> 00:29:46,789
means that you if you have the skills

807
00:29:44,749 --> 00:29:50,210
you can actually at a time you can

808
00:29:46,789 --> 00:29:52,879
actually turn that crash into something

809
00:29:50,210 --> 00:29:54,980
that works for the attackers benefit so

810
00:29:52,879 --> 00:29:56,990
exploitation so looking done that

811
00:29:54,980 --> 00:29:59,450
function a bit further we notice that

812
00:29:56,990 --> 00:30:00,980
that actually adds it can actually not

813
00:29:59,450 --> 00:30:02,869
just take memory from one of these Numa

814
00:30:00,980 --> 00:30:06,080
nodes that also give it back so why

815
00:30:02,869 --> 00:30:07,610
would it do this so this is because then

816
00:30:06,080 --> 00:30:10,549
uses something called Buddy allocation

817
00:30:07,610 --> 00:30:13,219
which is a very friendly term so it

818
00:30:10,549 --> 00:30:16,100
stores free memory and linked lists and

819
00:30:13,220 --> 00:30:18,139
it has a linked list per order and when

820
00:30:16,100 --> 00:30:21,110
I say order I just mean it's a size

821
00:30:18,139 --> 00:30:22,580
right so order 0 is 4 K 1 is 8 and it

822
00:30:21,110 --> 00:30:25,490
doubles each time you go up in the order

823
00:30:22,580 --> 00:30:26,928
and those of you might notice that 4k is

824
00:30:25,490 --> 00:30:31,039
like a page size so you can only

825
00:30:26,929 --> 00:30:32,869
allocate a page or one or more pages so

826
00:30:31,039 --> 00:30:34,879
you know if we are seen to allocate

827
00:30:32,869 --> 00:30:37,009
space for example 16 K it might look at

828
00:30:34,879 --> 00:30:38,748
the 16 K door to list see there's a

829
00:30:37,009 --> 00:30:40,879
memory there and we're all having it

830
00:30:38,749 --> 00:30:44,210
cool the second case is that it looks in

831
00:30:40,879 --> 00:30:45,439
that list and that's empty okay now it's

832
00:30:44,210 --> 00:30:46,909
not actually ran out of memory it's just

833
00:30:45,440 --> 00:30:50,330
run out of memory and that linked list

834
00:30:46,909 --> 00:30:52,009
for exact chunks of size 16 K what it

835
00:30:50,330 --> 00:30:54,049
can do is let go up the order list until

836
00:30:52,009 --> 00:30:56,539
it finds a non-empty list take that

837
00:30:54,049 --> 00:30:58,730
one's memory split it in half put that

838
00:30:56,539 --> 00:31:01,899
one back to put the unused half into the

839
00:30:58,730 --> 00:31:04,159
order to list and and now we have a

840
00:31:01,899 --> 00:31:04,459
properly sized allocation and we're all

841
00:31:04,159 --> 00:31:07,190
happy

842
00:31:04,460 --> 00:31:09,559
so buddy allocation means you take no

843
00:31:07,190 --> 00:31:11,600
it's buddy but you ask your buddy it for

844
00:31:09,559 --> 00:31:12,440
a favor I guess and then splits memory

845
00:31:11,600 --> 00:31:16,189
in half and then you

846
00:31:12,440 --> 00:31:17,540
stance did so this is where you have to

847
00:31:16,190 --> 00:31:19,790
hold on to your butt's a bit this is per

848
00:31:17,540 --> 00:31:25,070
Numa node okay so there's one of these

849
00:31:19,790 --> 00:31:27,230
per one of these there's this there's

850
00:31:25,070 --> 00:31:29,510
linked list for each order for each Numa

851
00:31:27,230 --> 00:31:30,950
node ID so there's zero one two three

852
00:31:29,510 --> 00:31:33,770
and then there's all of those ones you

853
00:31:30,950 --> 00:31:36,290
know sixty-three so if we specify a node

854
00:31:33,770 --> 00:31:37,790
ID that doesn't exist once we get past

855
00:31:36,290 --> 00:31:39,980
all the weird crap

856
00:31:37,790 --> 00:31:41,600
we eventually is in starts looking at

857
00:31:39,980 --> 00:31:43,910
memory that we actually control I won't

858
00:31:41,600 --> 00:31:46,939
go over why but it does so effectively

859
00:31:43,910 --> 00:31:50,480
we can actually create our own fake

860
00:31:46,940 --> 00:31:53,420
memory list order structure thing and

861
00:31:50,480 --> 00:31:55,300
gets into work on that instead of the

862
00:31:53,420 --> 00:31:57,740
ones that it's actually generated itself

863
00:31:55,300 --> 00:31:59,300
so here's our test set up for example

864
00:31:57,740 --> 00:32:01,580
we've got an empty zero or two zero less

865
00:31:59,300 --> 00:32:04,250
than an empty order one list and we ask

866
00:32:01,580 --> 00:32:05,419
it to allocate an order zero it sees

867
00:32:04,250 --> 00:32:07,400
that it's empty

868
00:32:05,420 --> 00:32:10,420
it looks at number one so it does the

869
00:32:07,400 --> 00:32:13,250
whole it rewrites the list takes out the

870
00:32:10,420 --> 00:32:16,160
memory splits and a half puts it does

871
00:32:13,250 --> 00:32:19,760
the things right like I just said before

872
00:32:16,160 --> 00:32:20,900
it does what I said okay so it's done

873
00:32:19,760 --> 00:32:22,400
that in the process of doing this it's

874
00:32:20,900 --> 00:32:24,050
done a bunch of writes to memory to

875
00:32:22,400 --> 00:32:26,210
update all these lists and stuff like

876
00:32:24,050 --> 00:32:27,530
that so unfortunately for us these

877
00:32:26,210 --> 00:32:28,610
writes here for example aren't

878
00:32:27,530 --> 00:32:30,740
interesting to us because they're to

879
00:32:28,610 --> 00:32:32,270
memory we already control and these

880
00:32:30,740 --> 00:32:34,820
writes to memory aren't interesting to

881
00:32:32,270 --> 00:32:36,590
us because of reasons those reasons are

882
00:32:34,820 --> 00:32:38,750
because we can't get it to actually

883
00:32:36,590 --> 00:32:41,209
write to out of bound me out of range

884
00:32:38,750 --> 00:32:42,530
memory we can great we can tell zena's

885
00:32:41,210 --> 00:32:43,580
writing to memory you don't control in

886
00:32:42,530 --> 00:32:46,120
this case but it's not writing to all

887
00:32:43,580 --> 00:32:49,970
memory just a very small part of it

888
00:32:46,120 --> 00:32:51,439
right yeah that sums it up so what we

889
00:32:49,970 --> 00:32:53,690
can do instead is we can do a little

890
00:32:51,440 --> 00:32:55,580
trick we ask it to do the same thing we

891
00:32:53,690 --> 00:32:58,640
we've set up a fake memory list we asked

892
00:32:55,580 --> 00:33:00,560
in to allocate an order zero allocation

893
00:32:58,640 --> 00:33:02,330
looks in the empty list Co starts

894
00:33:00,560 --> 00:33:05,510
looking in the second list but then

895
00:33:02,330 --> 00:33:07,220
behind its back we secretly put in we

896
00:33:05,510 --> 00:33:10,370
start putting what sort of guest like

897
00:33:07,220 --> 00:33:12,470
that I guess we put in a node and the

898
00:33:10,370 --> 00:33:15,290
orders here a node memory chunk in the

899
00:33:12,470 --> 00:33:17,690
order 0 list and we can normally we can

900
00:33:15,290 --> 00:33:19,370
do this because normally this in lot

901
00:33:17,690 --> 00:33:21,350
does locking writes ok you can't

902
00:33:19,370 --> 00:33:25,189
concurrently sin can't concurrently

903
00:33:21,350 --> 00:33:26,240
modify a memory list with by two three

904
00:33:25,190 --> 00:33:27,650
is like two three

905
00:33:26,240 --> 00:33:29,900
trying to modify a list it won't happen

906
00:33:27,650 --> 00:33:32,330
cuz it's got locking but unfortunately

907
00:33:29,900 --> 00:33:34,190
for us the the weird nodes that were you

908
00:33:32,330 --> 00:33:35,480
control we can just bypass that locking

909
00:33:34,190 --> 00:33:38,390
because we don't have to take the lock

910
00:33:35,480 --> 00:33:40,550
that sin does we just do it anyway right

911
00:33:38,390 --> 00:33:42,230
like a bad programmer this is called a

912
00:33:40,550 --> 00:33:44,480
race condition except that's not really

913
00:33:42,230 --> 00:33:45,890
because of Zeena's we've broken Zin so

914
00:33:44,480 --> 00:33:48,230
much that it's not even really a race

915
00:33:45,890 --> 00:33:51,800
condition that's just not not being

916
00:33:48,230 --> 00:33:53,600
blocked at all so anyway back to this so

917
00:33:51,800 --> 00:33:55,659
it's looking at order one when we've

918
00:33:53,600 --> 00:33:58,399
particularly put something to order zero

919
00:33:55,660 --> 00:34:01,040
it takes the one the order one thing

920
00:33:58,400 --> 00:34:03,290
splits it in half and now remember

921
00:34:01,040 --> 00:34:05,210
previously it put it on it's a it puts

922
00:34:03,290 --> 00:34:07,580
the split the unused split shank on to

923
00:34:05,210 --> 00:34:09,379
the tail of the list that was actually

924
00:34:07,580 --> 00:34:11,719
you know mean to be on so in this case

925
00:34:09,379 --> 00:34:13,969
is putting it on to the end of the new

926
00:34:11,719 --> 00:34:15,709
node that we added an order 0 so got

927
00:34:13,969 --> 00:34:17,839
some different kinds of rights here so

928
00:34:15,710 --> 00:34:22,100
the most important one is this one here

929
00:34:17,840 --> 00:34:25,790
now this one actually is the value that

930
00:34:22,100 --> 00:34:28,580
it writes as is the what it's writing is

931
00:34:25,790 --> 00:34:33,590
the value of the order 0 linked lists

932
00:34:28,580 --> 00:34:35,418
heads next pointer I think and so we

933
00:34:33,590 --> 00:34:37,419
implicitly control the value that it's

934
00:34:35,418 --> 00:34:40,520
written because it's the address of that

935
00:34:37,418 --> 00:34:42,500
node that it split into half and we also

936
00:34:40,520 --> 00:34:44,149
control the address that has to write

937
00:34:42,500 --> 00:34:47,060
that value into because that's the

938
00:34:44,149 --> 00:34:49,399
address of the fake first memory chunk

939
00:34:47,060 --> 00:34:50,899
and the order 0 list so I've got a

940
00:34:49,399 --> 00:34:52,609
variable there and a value that settings

941
00:34:50,899 --> 00:34:54,710
are basically and all of this miss we

942
00:34:52,609 --> 00:34:56,659
can write for chosen bytes anywhere in

943
00:34:54,710 --> 00:34:58,880
memory and this is what's called a right

944
00:34:56,659 --> 00:35:02,359
what we're print right what we are

945
00:34:58,880 --> 00:35:04,340
primitive ok so all its exploitation we

946
00:35:02,359 --> 00:35:05,840
now we need to know what do we write and

947
00:35:04,340 --> 00:35:07,550
we had rewrite it so I'm going to

948
00:35:05,840 --> 00:35:10,869
introduce the page tables pretty damn

949
00:35:07,550 --> 00:35:14,150
quickly so in a normal operating system

950
00:35:10,869 --> 00:35:15,619
you have over applications running on

951
00:35:14,150 --> 00:35:18,230
operating system running in hardware and

952
00:35:15,619 --> 00:35:19,820
an operating system uses page tables and

953
00:35:18,230 --> 00:35:23,420
also to see for rate the memory spaces

954
00:35:19,820 --> 00:35:24,800
that each application just can see so on

955
00:35:23,420 --> 00:35:26,510
the Left we have virtual memory which is

956
00:35:24,800 --> 00:35:28,070
memory how an application will actually

957
00:35:26,510 --> 00:35:29,030
see it and hardware memory which is hot

958
00:35:28,070 --> 00:35:30,440
the hell the memory actually looks in

959
00:35:29,030 --> 00:35:32,270
Hardware and you probably have more than

960
00:35:30,440 --> 00:35:34,790
64 kilobytes these days but that's all

961
00:35:32,270 --> 00:35:38,540
they gave us I can fit in so what will

962
00:35:34,790 --> 00:35:39,770
happen is if a applications tries to

963
00:35:38,540 --> 00:35:41,750
read or write from virtual me

964
00:35:39,770 --> 00:35:43,400
you know uses virtual memory spaces

965
00:35:41,750 --> 00:35:45,290
addresses and assembly and stuff like

966
00:35:43,400 --> 00:35:46,850
that so well it'll say I want to read it

967
00:35:45,290 --> 00:35:49,550
right to this part of memory the CPU

968
00:35:46,850 --> 00:35:51,380
chorus looks at the page tables and says

969
00:35:49,550 --> 00:35:53,900
is all those maps to this place and

970
00:35:51,380 --> 00:35:55,100
hardware memory so what this means is

971
00:35:53,900 --> 00:35:56,960
that although there's a whole bunch of

972
00:35:55,100 --> 00:35:58,279
applications all fragmented all

973
00:35:56,960 --> 00:36:00,760
throughout hardware memory each

974
00:35:58,280 --> 00:36:03,020
application can get a kind of you know

975
00:36:00,760 --> 00:36:04,880
aruba tree view of that memory and only

976
00:36:03,020 --> 00:36:06,560
its memory the operating system can make

977
00:36:04,880 --> 00:36:08,300
the applications virtual address space

978
00:36:06,560 --> 00:36:11,029
look however there wants it to look like

979
00:36:08,300 --> 00:36:12,800
but it can also control enforce

980
00:36:11,030 --> 00:36:15,230
isolation by ensuring the applications

981
00:36:12,800 --> 00:36:17,090
can't see other applications memory in

982
00:36:15,230 --> 00:36:19,460
the world of Xen pates tables still

983
00:36:17,090 --> 00:36:21,020
exist but as you can see they don't get

984
00:36:19,460 --> 00:36:22,460
used to control applications running on

985
00:36:21,020 --> 00:36:24,830
OS the scene users into control

986
00:36:22,460 --> 00:36:26,180
operating systems now the operating

987
00:36:24,830 --> 00:36:27,319
systems can use those hyper calls to

988
00:36:26,180 --> 00:36:28,669
modify the page tables because they

989
00:36:27,320 --> 00:36:29,930
might still need to modify the page

990
00:36:28,670 --> 00:36:31,910
tables because they still need to be

991
00:36:29,930 --> 00:36:34,850
able to control their own applications

992
00:36:31,910 --> 00:36:36,170
memory isolation but the thing is an

993
00:36:34,850 --> 00:36:38,150
operating system can't want to fly these

994
00:36:36,170 --> 00:36:40,640
patients directly because that would

995
00:36:38,150 --> 00:36:42,620
violate the key invariant that only then

996
00:36:40,640 --> 00:36:45,109
can control what operating system can

997
00:36:42,620 --> 00:36:47,180
see what memory but what if we just do

998
00:36:45,110 --> 00:36:49,700
the patch ourself right then we're able

999
00:36:47,180 --> 00:36:52,879
to use that patch page table to look at

1000
00:36:49,700 --> 00:36:54,080
our physical memory ourselves now I'm

1001
00:36:52,880 --> 00:36:56,300
gonna have to go real fast here but

1002
00:36:54,080 --> 00:36:58,490
basically that means that we can create

1003
00:36:56,300 --> 00:37:00,530
a little portal into virtual to hardware

1004
00:36:58,490 --> 00:37:02,120
memory so we can read or write for two

1005
00:37:00,530 --> 00:37:04,460
we can rewrite any amount of bytes

1006
00:37:02,120 --> 00:37:06,560
anywhere in memory but stability and

1007
00:37:04,460 --> 00:37:08,420
usefulness important so you know cating

1008
00:37:06,560 --> 00:37:09,710
give null over my friends operating

1009
00:37:08,420 --> 00:37:12,830
system sounds fun but it's not exactly

1010
00:37:09,710 --> 00:37:14,390
you know useful so what if we use one of

1011
00:37:12,830 --> 00:37:15,860
those page table over writes to actually

1012
00:37:14,390 --> 00:37:17,569
get access to the page table itself

1013
00:37:15,860 --> 00:37:19,310
because the page table is actually in

1014
00:37:17,570 --> 00:37:20,510
memory just like everything else so we

1015
00:37:19,310 --> 00:37:22,040
use the page table over write to

1016
00:37:20,510 --> 00:37:23,780
actually get access readwrite access to

1017
00:37:22,040 --> 00:37:25,520
the page table and this is funny because

1018
00:37:23,780 --> 00:37:27,470
to get readwrite access to a page table

1019
00:37:25,520 --> 00:37:29,720
only takes flipping one bit of the

1020
00:37:27,470 --> 00:37:30,770
second bit so in fact to break out of

1021
00:37:29,720 --> 00:37:32,029
the switch or machine you'll see

1022
00:37:30,770 --> 00:37:34,220
everything you see here only takes

1023
00:37:32,030 --> 00:37:37,160
flipping one bit right the second bit of

1024
00:37:34,220 --> 00:37:38,720
one page table entry so this is what the

1025
00:37:37,160 --> 00:37:40,190
code looks like for initializing their

1026
00:37:38,720 --> 00:37:44,830
portal so we allocate some memory for

1027
00:37:40,190 --> 00:37:47,060
that portal we do some crap and then we

1028
00:37:44,830 --> 00:37:49,279
create exploit page tables yep so we

1029
00:37:47,060 --> 00:37:52,850
make some stuff and then we fill the

1030
00:37:49,280 --> 00:37:55,300
page tables we getting a bunch of stuff

1031
00:37:52,850 --> 00:37:55,299
here sorry

1032
00:37:56,289 --> 00:38:00,890
but basically it comes down to there's

1033
00:37:59,269 --> 00:38:01,970
this there's two threads one thread

1034
00:38:00,890 --> 00:38:03,589
which is constantly adding and removing

1035
00:38:01,970 --> 00:38:04,970
that page from the order 0 list and

1036
00:38:03,589 --> 00:38:07,519
another one which is creating the fake

1037
00:38:04,970 --> 00:38:09,200
page table the fake memory list and

1038
00:38:07,519 --> 00:38:10,220
trying to trigger the Vaughn ability

1039
00:38:09,200 --> 00:38:12,140
that's what triggering it looks like

1040
00:38:10,220 --> 00:38:13,788
yeah it's just dead right that's what it

1041
00:38:12,140 --> 00:38:15,589
comes down to at the end of it calling

1042
00:38:13,789 --> 00:38:20,569
the hyper call to do the naughty thing

1043
00:38:15,589 --> 00:38:22,880
so we we have to is I'm gonna skip all

1044
00:38:20,569 --> 00:38:24,140
that because though it's boring so what

1045
00:38:22,880 --> 00:38:26,089
we have is two threads one which is

1046
00:38:24,140 --> 00:38:27,410
constantly twiddling as I call it adding

1047
00:38:26,089 --> 00:38:28,700
and removing pages and one which is

1048
00:38:27,410 --> 00:38:29,779
setting up those things telling them to

1049
00:38:28,700 --> 00:38:31,549
look at them and checking to see if

1050
00:38:29,779 --> 00:38:33,680
things overridden eventually hopefully

1051
00:38:31,549 --> 00:38:36,019
it does it takes between five and thirty

1052
00:38:33,680 --> 00:38:38,930
three minutes pinning on the load of the

1053
00:38:36,019 --> 00:38:40,008
other there is a machine okay so we're

1054
00:38:38,930 --> 00:38:41,328
happy so we've got access to the page

1055
00:38:40,009 --> 00:38:42,799
tables now what's a little F code

1056
00:38:41,329 --> 00:38:46,700
execution we have full page table exists

1057
00:38:42,799 --> 00:38:48,140
so that interrupts so CPU Santa wielding

1058
00:38:46,700 --> 00:38:49,279
themselves right there's external events

1059
00:38:48,140 --> 00:38:51,499
they happen and they need to be able to

1060
00:38:49,279 --> 00:38:53,119
respond to them so this might be user

1061
00:38:51,499 --> 00:38:54,769
input for example will knit web packet

1062
00:38:53,119 --> 00:38:57,140
handled neatly packet data so what

1063
00:38:54,769 --> 00:38:58,879
happens when its CPU gets an external

1064
00:38:57,140 --> 00:39:00,920
interrupt it looks at something called

1065
00:38:58,880 --> 00:39:01,970
the IDT interrupt descriptor table and

1066
00:39:00,920 --> 00:39:04,369
this is basically a list of addresses

1067
00:39:01,970 --> 00:39:08,209
that it can go to to see what it should

1068
00:39:04,369 --> 00:39:10,279
do we've given that situation now we can

1069
00:39:08,210 --> 00:39:12,680
met there IDT just like anything else we

1070
00:39:10,279 --> 00:39:15,829
can map there IDT and Pech it so now

1071
00:39:12,680 --> 00:39:17,569
when the CPU looks at a the IDT to see

1072
00:39:15,829 --> 00:39:19,970
what we actually jump to to handle an

1073
00:39:17,569 --> 00:39:22,069
event it sees this thing and it doesn't

1074
00:39:19,970 --> 00:39:24,439
think anything off that right um so then

1075
00:39:22,069 --> 00:39:25,910
it starts executing our code stage one

1076
00:39:24,440 --> 00:39:27,380
and it's doing this and bring zero so

1077
00:39:25,910 --> 00:39:31,038
we've broken out of ring three and guest

1078
00:39:27,380 --> 00:39:33,430
operating system to ring zero this is

1079
00:39:31,039 --> 00:39:33,430
how it works

1080
00:39:33,829 --> 00:39:38,069
okay the stage zero does some stage one

1081
00:39:36,660 --> 00:39:39,808
does some cleanup and then it returns

1082
00:39:38,069 --> 00:39:41,250
the system call handler so remember

1083
00:39:39,809 --> 00:39:44,880
system calls were between Epps

1084
00:39:41,250 --> 00:39:47,760
there's os's and OSS is in so if we so

1085
00:39:44,880 --> 00:39:49,380
normally operate system calls are used

1086
00:39:47,760 --> 00:39:51,690
for hyper calls from our sisters in and

1087
00:39:49,380 --> 00:39:53,039
they're also used from applications to

1088
00:39:51,690 --> 00:39:54,420
your operating systems this in just

1089
00:39:53,039 --> 00:39:55,980
bounces it back to the operating system

1090
00:39:54,420 --> 00:39:57,809
so what happens if we touch the system

1091
00:39:55,980 --> 00:40:00,869
call handler okay so and it's gonna

1092
00:39:57,809 --> 00:40:03,210
quickly just jump here and then speak a

1093
00:40:00,869 --> 00:40:06,000
VM it's a domain and domain user normal

1094
00:40:03,210 --> 00:40:07,920
VMs domain 0 is sounds cool it's the

1095
00:40:06,000 --> 00:40:08,490
privileged initial VM and I just a nice

1096
00:40:07,920 --> 00:40:10,619
typo there

1097
00:40:08,490 --> 00:40:12,390
the main 0 is a domain that can control

1098
00:40:10,619 --> 00:40:14,220
other domains in and add some other

1099
00:40:12,390 --> 00:40:15,839
hardware so this is the domain that is

1100
00:40:14,220 --> 00:40:17,069
actually the control Virtual Machine

1101
00:40:15,839 --> 00:40:19,078
basically is that the main you launch

1102
00:40:17,069 --> 00:40:20,308
domains from it's the one that your your

1103
00:40:19,079 --> 00:40:21,450
VPS provider will actually all their

1104
00:40:20,309 --> 00:40:23,880
scripts and all the launching and

1105
00:40:21,450 --> 00:40:26,098
closings so from so I went into this one

1106
00:40:23,880 --> 00:40:28,440
so when we patch the system call handler

1107
00:40:26,099 --> 00:40:30,900
not only do we see all every system call

1108
00:40:28,440 --> 00:40:32,880
we see system calls from Don 0 and

1109
00:40:30,900 --> 00:40:34,920
specifically we see system calls from

1110
00:40:32,880 --> 00:40:37,500
user mode applications running in Don 0

1111
00:40:34,920 --> 00:40:43,160
so we catch it and we call the stage 2

1112
00:40:37,500 --> 00:40:45,029
so stage 2 does things so the CPU is M

1113
00:40:43,160 --> 00:40:47,190
there's an interesting thing where we

1114
00:40:45,029 --> 00:40:48,630
can't just overwrite stage 2 the system

1115
00:40:47,190 --> 00:40:50,940
called Hana directly because another CPU

1116
00:40:48,630 --> 00:40:52,230
might actually be running it so that

1117
00:40:50,940 --> 00:40:55,200
really confuses the crap out of their

1118
00:40:52,230 --> 00:40:57,390
CPU so what we have to do is modify it

1119
00:40:55,200 --> 00:40:58,439
in place modifier atomically which is a

1120
00:40:57,390 --> 00:41:01,799
whole nother kettle of fish

1121
00:40:58,440 --> 00:41:03,029
so in domain 0 some user space program

1122
00:41:01,799 --> 00:41:05,069
will be trying to execute some heavy

1123
00:41:03,029 --> 00:41:06,599
thing so in order to assist call and

1124
00:41:05,069 --> 00:41:10,589
that gets redirected all the way to

1125
00:41:06,599 --> 00:41:11,670
stage 2 right so this is stage 2 so the

1126
00:41:10,589 --> 00:41:12,839
first thing we need to do is we need to

1127
00:41:11,670 --> 00:41:14,490
check that the system called with

1128
00:41:12,839 --> 00:41:15,630
hijacked actually belongs to Tom zero

1129
00:41:14,490 --> 00:41:16,828
and we need to check that it's actually

1130
00:41:15,630 --> 00:41:19,140
belonging to a user space application

1131
00:41:16,829 --> 00:41:21,390
and Don zero so this is what these first

1132
00:41:19,140 --> 00:41:23,578
two chicks are for then we patch the

1133
00:41:21,390 --> 00:41:26,190
victim apps page tables and then we jump

1134
00:41:23,579 --> 00:41:28,140
to there's page tables stage 3 another

1135
00:41:26,190 --> 00:41:30,359
stage gets injected into that Dom 0 app

1136
00:41:28,140 --> 00:41:33,390
and then in stage 2 jumps to that stage

1137
00:41:30,359 --> 00:41:36,180
now this is actually kind of funny to

1138
00:41:33,390 --> 00:41:37,740
watch because if I say here's a program

1139
00:41:36,180 --> 00:41:39,868
running in gdb which is about to do a

1140
00:41:37,740 --> 00:41:42,538
system call we can see here it's got to

1141
00:41:39,869 --> 00:41:44,760
do a system call does a system call and

1142
00:41:42,539 --> 00:41:45,930
an instantly jumped to looks like kernel

1143
00:41:44,760 --> 00:41:47,069
space right if you're a developer you

1144
00:41:45,930 --> 00:41:47,669
know there's waking you give a user

1145
00:41:47,069 --> 00:41:50,430
space probe

1146
00:41:47,670 --> 00:41:52,680
executing in high memory and there is it

1147
00:41:50,430 --> 00:41:55,379
although gdb can't see anything dear the

1148
00:41:52,680 --> 00:41:57,750
application can write so it's actually

1149
00:41:55,380 --> 00:41:59,640
executing stage three and it's just so

1150
00:41:57,750 --> 00:42:01,140
if that even Linux can't see it right

1151
00:41:59,640 --> 00:42:04,259
but eventually it starts getting to

1152
00:42:01,140 --> 00:42:05,520
stage four execute stage two is copied

1153
00:42:04,260 --> 00:42:07,650
stage three in and here's a training

1154
00:42:05,520 --> 00:42:09,360
stage through and in eventually runs the

1155
00:42:07,650 --> 00:42:10,590
execution back to the program the in

1156
00:42:09,360 --> 00:42:11,010
stage three goes to stage four because

1157
00:42:10,590 --> 00:42:13,650
of reasons

1158
00:42:11,010 --> 00:42:15,630
so then stage 4 is also injected there

1159
00:42:13,650 --> 00:42:17,760
now stage for it we have code execution

1160
00:42:15,630 --> 00:42:20,040
is root and domain zero this is great

1161
00:42:17,760 --> 00:42:22,170
but I want to show right

1162
00:42:20,040 --> 00:42:23,790
I want interactivity currently we have

1163
00:42:22,170 --> 00:42:25,800
our stages that are hijacked into

1164
00:42:23,790 --> 00:42:27,420
domains zero application how do they

1165
00:42:25,800 --> 00:42:29,010
actually get back to the exploit running

1166
00:42:27,420 --> 00:42:30,300
in my guest operating system from the

1167
00:42:29,010 --> 00:42:31,890
main zero in the applications point of

1168
00:42:30,300 --> 00:42:33,870
view nothing else exists right it's like

1169
00:42:31,890 --> 00:42:35,940
this picture which took me forever fine

1170
00:42:33,870 --> 00:42:38,819
right Stage four wants to break out of

1171
00:42:35,940 --> 00:42:39,990
domain 0 into heavens above right so

1172
00:42:38,820 --> 00:42:41,370
what we do is we get Stage four to make

1173
00:42:39,990 --> 00:42:43,049
what's called allocate some memory and

1174
00:42:41,370 --> 00:42:45,930
put some rings into it when I say ring I

1175
00:42:43,050 --> 00:42:48,870
just means circularbuffer right so what

1176
00:42:45,930 --> 00:42:50,129
can happen is once the extremely exploit

1177
00:42:48,870 --> 00:42:52,109
knows where these circular buffers are

1178
00:42:50,130 --> 00:42:55,530
it can write a command that we give to

1179
00:42:52,110 --> 00:42:57,330
this circular buffer the stage 4 can see

1180
00:42:55,530 --> 00:42:59,520
it seen that command turban shell and

1181
00:42:57,330 --> 00:43:01,080
indel be an input ring an output ring

1182
00:42:59,520 --> 00:43:03,900
and it can write the result to another

1183
00:43:01,080 --> 00:43:05,670
ring and then where our external exploit

1184
00:43:03,900 --> 00:43:07,020
can see that and then print that out to

1185
00:43:05,670 --> 00:43:09,240
us and these are the rings because

1186
00:43:07,020 --> 00:43:11,700
they're circular right the hidden tail

1187
00:43:09,240 --> 00:43:14,399
pointers will just loop around so this

1188
00:43:11,700 --> 00:43:18,629
is what this looks like yeah yeah

1189
00:43:14,400 --> 00:43:20,460
so stage force forks so one side of the

1190
00:43:18,630 --> 00:43:21,570
fork will just go back and continue

1191
00:43:20,460 --> 00:43:22,980
running the program is if nothing had

1192
00:43:21,570 --> 00:43:24,390
happened like you saw in gdb and then

1193
00:43:22,980 --> 00:43:27,990
the other one will handle to etch the

1194
00:43:24,390 --> 00:43:30,359
actual shell execution so this is what

1195
00:43:27,990 --> 00:43:32,100
the we currently have set up so Stage

1196
00:43:30,360 --> 00:43:33,330
four tells our patch syscall handle

1197
00:43:32,100 --> 00:43:35,100
where to find this memory and then I

1198
00:43:33,330 --> 00:43:36,600
exploit can query that so then they can

1199
00:43:35,100 --> 00:43:39,120
join a link together so now we actually

1200
00:43:36,600 --> 00:43:40,470
have communications and this is the code

1201
00:43:39,120 --> 00:43:42,600
that does reading and writing so now we

1202
00:43:40,470 --> 00:43:46,020
have remote shell as route in domain 0

1203
00:43:42,600 --> 00:43:48,089
this is actually good ok so enough talk

1204
00:43:46,020 --> 00:43:50,910
but first I did promise what happens

1205
00:43:48,090 --> 00:43:52,950
what happens when things go wrong so

1206
00:43:50,910 --> 00:43:56,490
here's me running in an if sorry for

1207
00:43:52,950 --> 00:43:58,200
those bad video me running a early

1208
00:43:56,490 --> 00:44:00,240
version of this exploit and as you can

1209
00:43:58,200 --> 00:44:01,540
see this is the main zeros PS tree and

1210
00:44:00,240 --> 00:44:03,609
you can

1211
00:44:01,540 --> 00:44:05,410
for some reason everything is now

1212
00:44:03,610 --> 00:44:10,900
loading the facility incopy he's a

1213
00:44:05,410 --> 00:44:12,970
Python so engine X and so forth

1214
00:44:10,900 --> 00:44:15,100
now it's python-based and the program

1215
00:44:12,970 --> 00:44:17,379
the machine creations brew soon after

1216
00:44:15,100 --> 00:44:20,410
this ok so enough talk let's have the

1217
00:44:17,380 --> 00:44:22,750
real demo so here's and okay so Co have

1218
00:44:20,410 --> 00:44:24,160
you pronounce it is I might main 0 so

1219
00:44:22,750 --> 00:44:26,200
here it is showing the VNS writing

1220
00:44:24,160 --> 00:44:28,990
there's a domain 0 vm a domain and a bed

1221
00:44:26,200 --> 00:44:30,879
no I'm normal I'm privileged domain here

1222
00:44:28,990 --> 00:44:32,649
we are in there unprivileged domain so

1223
00:44:30,880 --> 00:44:36,270
we'll make the exploit office when they

1224
00:44:32,650 --> 00:44:36,270
clean of course and then we'll make it

1225
00:44:38,610 --> 00:44:48,580
cool and we run the thing now this is D

1226
00:44:46,450 --> 00:44:50,799
message output so the kernel output so

1227
00:44:48,580 --> 00:44:53,140
remember it has to execute it has to win

1228
00:44:50,800 --> 00:44:54,790
a race condition and do a dodgy sir so

1229
00:44:53,140 --> 00:44:56,170
Linux doesn't like this a guest

1230
00:44:54,790 --> 00:44:57,730
operating system does not like this

1231
00:44:56,170 --> 00:44:59,470
module and it starts screaming out about

1232
00:44:57,730 --> 00:45:00,670
it and saying you'll see if you use a

1233
00:44:59,470 --> 00:45:02,529
locked up and stuff that's because I'm

1234
00:45:00,670 --> 00:45:04,360
not yielding back to Linux normal

1235
00:45:02,530 --> 00:45:05,770
modules are supposed to your back ok as

1236
00:45:04,360 --> 00:45:08,650
you can see now it's been triggered it's

1237
00:45:05,770 --> 00:45:09,970
copying its stealing memory from zen its

1238
00:45:08,650 --> 00:45:11,950
patching all the things I told you about

1239
00:45:09,970 --> 00:45:14,680
and now it's found this shell ring and

1240
00:45:11,950 --> 00:45:16,839
it's cleaning up after itself and it's

1241
00:45:14,680 --> 00:45:19,240
doing more cleaning up after itself and

1242
00:45:16,840 --> 00:45:20,320
now if we switch to another terminal we

1243
00:45:19,240 --> 00:45:21,790
now hit this is still in the

1244
00:45:20,320 --> 00:45:24,340
unprivileged machine and privilege

1245
00:45:21,790 --> 00:45:27,860
virtual machine now we have a root shell

1246
00:45:24,340 --> 00:45:34,269
in the main 0

1247
00:45:27,860 --> 00:45:34,269
[Applause]

1248
00:45:35,370 --> 00:45:40,259
and we can do everything that a normal

1249
00:45:38,850 --> 00:45:42,240
person could do in route including

1250
00:45:40,260 --> 00:45:44,670
shutting down the machine from within

1251
00:45:42,240 --> 00:45:45,540
the shell which is hilarious now I might

1252
00:45:44,670 --> 00:45:46,980
have mentioned cubes

1253
00:45:45,540 --> 00:45:48,300
I'm cubes as a security system I believe

1254
00:45:46,980 --> 00:45:50,130
someone talked about it yesterday I'm in

1255
00:45:48,300 --> 00:45:51,750
theory this exploit can break cubes and

1256
00:45:50,130 --> 00:45:53,340
it used to usually have to go for an

1257
00:45:51,750 --> 00:45:55,050
unprivileged cube to an a privilege cube

1258
00:45:53,340 --> 00:45:56,430
unfortunately when I tried to run it at

1259
00:45:55,050 --> 00:45:58,350
1 a.m. last night and this is what

1260
00:45:56,430 --> 00:46:00,029
happens I've changed my code so much

1261
00:45:58,350 --> 00:46:03,509
since I last run it unfortunately you

1262
00:46:00,030 --> 00:46:05,340
and certainly insert the exploit module

1263
00:46:03,510 --> 00:46:07,890
and the machine dies so obviously

1264
00:46:05,340 --> 00:46:11,850
there's some work to be done there and

1265
00:46:07,890 --> 00:46:13,440
so this is the final setup the Beck my

1266
00:46:11,850 --> 00:46:15,360
friend said what are the takeaways for

1267
00:46:13,440 --> 00:46:17,100
the people so I don't know so far thing

1268
00:46:15,360 --> 00:46:18,720
isn't just for file and network format

1269
00:46:17,100 --> 00:46:19,910
if you customized fuzzer it can be used

1270
00:46:18,720 --> 00:46:21,899
for lots of interesting things

1271
00:46:19,910 --> 00:46:22,830
virtualization is not a panacea right

1272
00:46:21,900 --> 00:46:24,060
there's waste could be people like me

1273
00:46:22,830 --> 00:46:25,710
who will break out a few VMs and all

1274
00:46:24,060 --> 00:46:27,270
that sort of thing writing a VM

1275
00:46:25,710 --> 00:46:28,950
ex-players like writing a operating

1276
00:46:27,270 --> 00:46:30,270
system parasitical operating system that

1277
00:46:28,950 --> 00:46:31,799
the guest lights the real operating

1278
00:46:30,270 --> 00:46:33,540
systems and for things that may or may

1279
00:46:31,800 --> 00:46:34,710
not be there and that's really waited to

1280
00:46:33,540 --> 00:46:36,779
bargain that's really exciting and

1281
00:46:34,710 --> 00:46:40,170
debugging interrupt handlers is really

1282
00:46:36,780 --> 00:46:41,640
really not fun thanks to Tim Loras is in

1283
00:46:40,170 --> 00:46:42,900
project for dealing with my crap these

1284
00:46:41,640 --> 00:46:46,279
sites Wellington oversee and Tamura

1285
00:46:42,900 --> 00:46:50,010
level working with you guys thanks

1286
00:46:46,280 --> 00:46:50,010
[Applause]

1287
00:46:56,210 --> 00:46:58,270
you

