1
00:00:04,960 --> 00:00:07,279
thank you good morning

2
00:00:07,279 --> 00:00:09,440
back in 2019

3
00:00:09,440 --> 00:00:10,960
apple at the worldwide developer

4
00:00:10,960 --> 00:00:12,480
conference announced they were making a

5
00:00:12,480 --> 00:00:14,000
dramatic change to the way they were

6
00:00:14,000 --> 00:00:15,599
dealing with the kernel space on their

7
00:00:15,599 --> 00:00:17,199
mac operating systems

8
00:00:17,199 --> 00:00:18,960
today i'm going to be dealing with one

9
00:00:18,960 --> 00:00:20,880
of the results of this namely the

10
00:00:20,880 --> 00:00:24,640
endpoint security framework or the esf

11
00:00:24,640 --> 00:00:27,840
i am a senior researcher with secure

12
00:00:27,840 --> 00:00:30,160
within their countercept team prior to

13
00:00:30,160 --> 00:00:31,519
being part of the research team was a

14
00:00:31,519 --> 00:00:33,280
threat hunter for years

15
00:00:33,280 --> 00:00:34,880
i have produced multiple white papers

16
00:00:34,880 --> 00:00:37,200
and proof of concept detection codes and

17
00:00:37,200 --> 00:00:39,440
presented at a number of international

18
00:00:39,440 --> 00:00:41,760
conventions

19
00:00:41,760 --> 00:00:43,040
so what are we going to be going over

20
00:00:43,040 --> 00:00:45,039
today we'll be going over what exactly

21
00:00:45,039 --> 00:00:46,800
the essay is

22
00:00:46,800 --> 00:00:49,120
why the esf is important to the

23
00:00:49,120 --> 00:00:50,879
detection industry

24
00:00:50,879 --> 00:00:52,559
how can we

25
00:00:52,559 --> 00:00:55,039
in the industry utilize the esf

26
00:00:55,039 --> 00:00:57,600
some of the issues during implementation

27
00:00:57,600 --> 00:00:58,960
and some of the solutions that i found

28
00:00:58,960 --> 00:01:00,480
to these issues

29
00:01:00,480 --> 00:01:02,800
uh my device poc solution which i code

30
00:01:02,800 --> 00:01:04,239
named esfang

31
00:01:04,239 --> 00:01:06,320
and briefly going over a use case

32
00:01:06,320 --> 00:01:09,760
against the return pressure agent

33
00:01:09,760 --> 00:01:13,040
so first off what exactly is the esf

34
00:01:13,040 --> 00:01:15,360
so the esf is developed as a

35
00:01:15,360 --> 00:01:17,200
kernel-based telemetry acquisition

36
00:01:17,200 --> 00:01:19,520
system by apple and it's

37
00:01:19,520 --> 00:01:21,680
been developed as a way for a one-stop

38
00:01:21,680 --> 00:01:23,680
shop for telemetry needs from the

39
00:01:23,680 --> 00:01:25,759
security industry as you said it works

40
00:01:25,759 --> 00:01:27,200
in the kernel space and because of that

41
00:01:27,200 --> 00:01:28,960
it actually works fairly similar to the

42
00:01:28,960 --> 00:01:31,200
way the etw works inside the windows

43
00:01:31,200 --> 00:01:32,799
operating system

44
00:01:32,799 --> 00:01:35,040
in many ways it succeeds the open bsm or

45
00:01:35,040 --> 00:01:36,880
the open basic security module by sun

46
00:01:36,880 --> 00:01:38,640
systems that was used primarily for

47
00:01:38,640 --> 00:01:42,000
auditing purposes prior to esf and one

48
00:01:42,000 --> 00:01:44,159
of the great results of esf is that it

49
00:01:44,159 --> 00:01:46,560
allows for real-time event acquisition

50
00:01:46,560 --> 00:01:47,439
for

51
00:01:47,439 --> 00:01:49,360
um

52
00:01:49,360 --> 00:01:52,640
direct intervention on a real-time

53
00:01:52,640 --> 00:01:54,240
interception

54
00:01:54,240 --> 00:01:56,240
but what does this exactly look like so

55
00:01:56,240 --> 00:01:58,159
the image on the right here gives a very

56
00:01:58,159 --> 00:02:00,079
basic overview of how this works from

57
00:02:00,079 --> 00:02:00,799
the

58
00:02:00,799 --> 00:02:02,960
user space at the bottom with a endpoint

59
00:02:02,960 --> 00:02:04,799
security application feeding into the

60
00:02:04,799 --> 00:02:06,719
kernel space and getting messages from

61
00:02:06,719 --> 00:02:09,199
the kernel space for the telemetry and

62
00:02:09,199 --> 00:02:11,360
on the left is a demonstration of that

63
00:02:11,360 --> 00:02:13,840
information which from every single

64
00:02:13,840 --> 00:02:17,040
event type includes multiple low-level

65
00:02:17,040 --> 00:02:19,680
data points including the parent process

66
00:02:19,680 --> 00:02:20,640
id

67
00:02:20,640 --> 00:02:23,599
path environmental variables cd hashes

68
00:02:23,599 --> 00:02:26,399
and so forth

69
00:02:27,040 --> 00:02:30,160
but why is the esf important

70
00:02:30,160 --> 00:02:31,200
so

71
00:02:31,200 --> 00:02:33,920
during the presentation at the worldwide

72
00:02:33,920 --> 00:02:35,280
developer conference in 2019 they

73
00:02:35,280 --> 00:02:37,040
announced they were going to deprecate

74
00:02:37,040 --> 00:02:39,760
text or kernel extensions primarily this

75
00:02:39,760 --> 00:02:40,800
means that they were removing

76
00:02:40,800 --> 00:02:42,160
third-party current extensions from the

77
00:02:42,160 --> 00:02:44,720
kernel space meaning that

78
00:02:44,720 --> 00:02:46,560
third-party security vendors could not

79
00:02:46,560 --> 00:02:48,239
use their own kernel extensions for

80
00:02:48,239 --> 00:02:50,480
telemetry acquisition because of this

81
00:02:50,480 --> 00:02:52,400
they introduced something called system

82
00:02:52,400 --> 00:02:54,400
extensions which is their way of

83
00:02:54,400 --> 00:02:57,040
allowing kernel extension

84
00:02:57,040 --> 00:02:58,959
proprietary apple kernel extension

85
00:02:58,959 --> 00:03:00,720
access from the user space using

86
00:03:00,720 --> 00:03:03,599
something called system extensions

87
00:03:03,599 --> 00:03:06,080
equally before esf came along open bsm

88
00:03:06,080 --> 00:03:07,920
as i said was a primary auditing tool

89
00:03:07,920 --> 00:03:09,920
but it was quite clunky to use and

90
00:03:09,920 --> 00:03:11,200
fairly difficult to integrate there's

91
00:03:11,200 --> 00:03:12,879
lots of documentation on the problems

92
00:03:12,879 --> 00:03:14,720
with open bsm so i won't go into them

93
00:03:14,720 --> 00:03:16,720
but needless to say earsafe is a much

94
00:03:16,720 --> 00:03:18,159
easier solution to getting these

95
00:03:18,159 --> 00:03:20,720
telemetry points

96
00:03:20,720 --> 00:03:23,440
so let's have a look at the old way of

97
00:03:23,440 --> 00:03:25,360
how monitoring worked

98
00:03:25,360 --> 00:03:27,120
so at the bottom we have the user space

99
00:03:27,120 --> 00:03:30,080
top kernel space on the left the logs

100
00:03:30,080 --> 00:03:31,840
so what would happen is is that

101
00:03:31,840 --> 00:03:33,200
third-party vendors would have their

102
00:03:33,200 --> 00:03:34,959
monitoring program hooked into a

103
00:03:34,959 --> 00:03:36,400
third-party canal extension running in

104
00:03:36,400 --> 00:03:38,799
the kernel space and acquire telemetry

105
00:03:38,799 --> 00:03:40,159
via that point

106
00:03:40,159 --> 00:03:42,159
then using open bsm hooks they would

107
00:03:42,159 --> 00:03:44,480
hook into log files and acquire them

108
00:03:44,480 --> 00:03:46,400
through an auditing process run them

109
00:03:46,400 --> 00:03:48,159
back to the monitoring program for

110
00:03:48,159 --> 00:03:51,519
detection uh processing

111
00:03:51,519 --> 00:03:53,439
the new way is slightly different

112
00:03:53,439 --> 00:03:55,360
so as we said the system extensions work

113
00:03:55,360 --> 00:03:57,439
in the user space

114
00:03:57,439 --> 00:03:59,360
and they work on frameworks that were

115
00:03:59,360 --> 00:04:02,080
introduced by apple to directly access

116
00:04:02,080 --> 00:04:03,920
kernel space using their proprietary

117
00:04:03,920 --> 00:04:06,400
kernel extensions these work out as the

118
00:04:06,400 --> 00:04:08,239
network extension framework

119
00:04:08,239 --> 00:04:10,239
endpoint security framework esf and the

120
00:04:10,239 --> 00:04:12,319
driver kit framework and using a

121
00:04:12,319 --> 00:04:14,400
amalgamation of the three you have very

122
00:04:14,400 --> 00:04:16,320
high visibility over the low level

123
00:04:16,320 --> 00:04:18,560
telemetry of the operating system

124
00:04:18,560 --> 00:04:20,720
however we're focusing on the esf and

125
00:04:20,720 --> 00:04:22,240
from that it actually hooks into the

126
00:04:22,240 --> 00:04:23,759
endpoint security current extension

127
00:04:23,759 --> 00:04:25,919
getting developed by apple so it allows

128
00:04:25,919 --> 00:04:28,320
them to have this proprietary pipeline

129
00:04:28,320 --> 00:04:30,479
from the user space system extension to

130
00:04:30,479 --> 00:04:34,159
their maintained kernel extension

131
00:04:35,360 --> 00:04:37,280
but why make the change

132
00:04:37,280 --> 00:04:40,880
so the one of the primary reasons

133
00:04:40,880 --> 00:04:42,800
that apple made the change to remove

134
00:04:42,800 --> 00:04:44,320
current extensions was for increased

135
00:04:44,320 --> 00:04:46,400
stability and security

136
00:04:46,400 --> 00:04:48,320
so by removing third-party kernel

137
00:04:48,320 --> 00:04:50,880
extensions you avoid things like the

138
00:04:50,880 --> 00:04:52,479
black screens of death but equally you

139
00:04:52,479 --> 00:04:54,479
avoid third-party malicious kind of

140
00:04:54,479 --> 00:04:56,080
accentuation being introduced into the

141
00:04:56,080 --> 00:04:58,160
operating system

142
00:04:58,160 --> 00:04:59,600
this means that they have much greater

143
00:04:59,600 --> 00:05:01,039
control over what is happening in the

144
00:05:01,039 --> 00:05:03,120
kernel space and it just eliminates a

145
00:05:03,120 --> 00:05:04,800
lot of the overheads and a lot of the

146
00:05:04,800 --> 00:05:07,360
problems that are being encountered with

147
00:05:07,360 --> 00:05:08,560
less stable current extensions that

148
00:05:08,560 --> 00:05:10,160
we're finding in the wild and it means

149
00:05:10,160 --> 00:05:12,720
that everything becomes very uniform

150
00:05:12,720 --> 00:05:14,320
one of the things to note about kernel

151
00:05:14,320 --> 00:05:16,000
extensions is that even though they've

152
00:05:16,000 --> 00:05:20,000
been deprecated they can still be used

153
00:05:20,000 --> 00:05:22,240
they're just you have to dramatically

154
00:05:22,240 --> 00:05:24,560
reduce the security profile of a mac

155
00:05:24,560 --> 00:05:26,800
operating system in order to do so

156
00:05:26,800 --> 00:05:28,560
primarily you used to be able to

157
00:05:28,560 --> 00:05:30,320
introduce current extensions on the fly

158
00:05:30,320 --> 00:05:32,240
on demand however now you have to

159
00:05:32,240 --> 00:05:33,840
degrade the security profile that's

160
00:05:33,840 --> 00:05:35,600
running then you have to

161
00:05:35,600 --> 00:05:37,360
turn on canon extension and then reboot

162
00:05:37,360 --> 00:05:39,280
the system which means you can't just

163
00:05:39,280 --> 00:05:42,000
inject them as you would

164
00:05:42,000 --> 00:05:45,520
but how can we use the esf

165
00:05:45,520 --> 00:05:46,639
so

166
00:05:46,639 --> 00:05:48,240
this slides a little bit messy so i'll

167
00:05:48,240 --> 00:05:50,080
just walk you through it so in the

168
00:05:50,080 --> 00:05:51,440
bottom right you have the main code

169
00:05:51,440 --> 00:05:52,560
running in the user space of your

170
00:05:52,560 --> 00:05:53,520
program

171
00:05:53,520 --> 00:05:55,199
you would then create an endpoint

172
00:05:55,199 --> 00:05:57,440
security client object

173
00:05:57,440 --> 00:05:59,039
this would then subscribe to the

174
00:05:59,039 --> 00:06:01,440
endpoint security kernel extension with

175
00:06:01,440 --> 00:06:03,520
the event types that you want so you

176
00:06:03,520 --> 00:06:05,680
specify the event points one like the

177
00:06:05,680 --> 00:06:07,840
file creation or process creation or

178
00:06:07,840 --> 00:06:09,440
anything to that sort of thing

179
00:06:09,440 --> 00:06:10,960
the endpoint security kernel extension

180
00:06:10,960 --> 00:06:13,280
then crea populates an event message

181
00:06:13,280 --> 00:06:16,240
queue in the kernel space and then pipes

182
00:06:16,240 --> 00:06:18,080
that out to your endpoint security

183
00:06:18,080 --> 00:06:20,080
client which you have already subscribed

184
00:06:20,080 --> 00:06:21,759
which you use to subscribe to the kernel

185
00:06:21,759 --> 00:06:22,880
extension

186
00:06:22,880 --> 00:06:25,440
then on on each message a callback is

187
00:06:25,440 --> 00:06:26,880
generated which you can have a callback

188
00:06:26,880 --> 00:06:28,880
monitor and then each message that's

189
00:06:28,880 --> 00:06:31,039
received can be processed back into your

190
00:06:31,039 --> 00:06:35,240
main code for detection purposes

191
00:06:36,240 --> 00:06:38,400
but what are some of the issues with the

192
00:06:38,400 --> 00:06:41,680
esf use and what are the solutions so

193
00:06:41,680 --> 00:06:44,560
during my experimentation with esf back

194
00:06:44,560 --> 00:06:45,520
in

195
00:06:45,520 --> 00:06:47,440
early 2020

196
00:06:47,440 --> 00:06:49,199
there were a number of solutions that

197
00:06:49,199 --> 00:06:51,599
came out from multiple researchers and

198
00:06:51,599 --> 00:06:54,240
vendors but there were some very primary

199
00:06:54,240 --> 00:06:55,280
issues that came out with its

200
00:06:55,280 --> 00:06:57,199
utilization

201
00:06:57,199 --> 00:06:59,919
namely a bottlenecking issue uh system

202
00:06:59,919 --> 00:07:02,240
verbosity and real parent process id

203
00:07:02,240 --> 00:07:03,680
issue i shall go through each

204
00:07:03,680 --> 00:07:05,759
individually

205
00:07:05,759 --> 00:07:07,360
first of all a bottlenecking issue so

206
00:07:07,360 --> 00:07:09,280
this was actually something that i was

207
00:07:09,280 --> 00:07:11,280
banging my head against for

208
00:07:11,280 --> 00:07:12,960
a couple of weeks even a month two

209
00:07:12,960 --> 00:07:14,479
months and effectively what was

210
00:07:14,479 --> 00:07:16,479
happening was is where you were doing

211
00:07:16,479 --> 00:07:18,479
exactly the same experiment

212
00:07:18,479 --> 00:07:20,240
you would get different data points

213
00:07:20,240 --> 00:07:21,680
being populated and you'd have different

214
00:07:21,680 --> 00:07:22,720
numbers

215
00:07:22,720 --> 00:07:24,080
and it didn't really make any sense as

216
00:07:24,080 --> 00:07:25,360
to why

217
00:07:25,360 --> 00:07:27,199
so you'd conduct the same malicious

218
00:07:27,199 --> 00:07:28,960
experiment using the esf telemetry

219
00:07:28,960 --> 00:07:31,360
acquisition but you'd always get you

220
00:07:31,360 --> 00:07:32,960
always get mismatched data points and

221
00:07:32,960 --> 00:07:34,400
you'd have data points that were being

222
00:07:34,400 --> 00:07:36,400
missing for no particular reason and

223
00:07:36,400 --> 00:07:38,639
equally from a detection perspective

224
00:07:38,639 --> 00:07:40,000
this means that it's inconsistent and

225
00:07:40,000 --> 00:07:42,319
therefore the data points are unreliable

226
00:07:42,319 --> 00:07:44,160
and it was a very long-standing reason

227
00:07:44,160 --> 00:07:45,919
before i figured out exactly why this

228
00:07:45,919 --> 00:07:48,240
was

229
00:07:49,120 --> 00:07:50,879
primarily the issue was caused by the

230
00:07:50,879 --> 00:07:52,960
kernel level q so you may remember from

231
00:07:52,960 --> 00:07:54,639
the previous slide i said that the

232
00:07:54,639 --> 00:07:58,240
kernel extension inside um for the esf

233
00:07:58,240 --> 00:08:00,160
would populate a queue within the kernel

234
00:08:00,160 --> 00:08:02,479
space but what was happening was is this

235
00:08:02,479 --> 00:08:04,720
queue was being overloaded because the

236
00:08:04,720 --> 00:08:06,639
amount of data that you were subscribing

237
00:08:06,639 --> 00:08:09,360
to was simply too much so if you try to

238
00:08:09,360 --> 00:08:11,360
subscribe to too many event types the

239
00:08:11,360 --> 00:08:13,759
queue gets overloaded and silently drops

240
00:08:13,759 --> 00:08:15,360
data packets which then don't come back

241
00:08:15,360 --> 00:08:17,199
to the user space but there's no

242
00:08:17,199 --> 00:08:19,520
indication that this happens so although

243
00:08:19,520 --> 00:08:21,199
the packets have dropped from the kernel

244
00:08:21,199 --> 00:08:22,639
side because the kernel side is

245
00:08:22,639 --> 00:08:23,840
obviously

246
00:08:23,840 --> 00:08:26,319
secure and it's isolated you don't get a

247
00:08:26,319 --> 00:08:28,319
notification that this has happened

248
00:08:28,319 --> 00:08:31,280
which is which is problematic

249
00:08:31,280 --> 00:08:34,000
two primary solutions to this are a

250
00:08:34,000 --> 00:08:36,640
development solution and a

251
00:08:36,640 --> 00:08:39,039
esf proprietary solution i'll go over

252
00:08:39,039 --> 00:08:42,080
the event muting first so event event

253
00:08:42,080 --> 00:08:44,399
musing is a function that was built into

254
00:08:44,399 --> 00:08:45,839
esf

255
00:08:45,839 --> 00:08:48,320
and what it does is it allows for

256
00:08:48,320 --> 00:08:51,120
specification for events to be dropped

257
00:08:51,120 --> 00:08:53,440
inside the current extension space

258
00:08:53,440 --> 00:08:55,519
now what this means is that through a

259
00:08:55,519 --> 00:08:57,920
process path or process token you can

260
00:08:57,920 --> 00:09:00,399
specify particular event types to be

261
00:09:00,399 --> 00:09:01,680
dropped on the kernel side and not

262
00:09:01,680 --> 00:09:04,320
published into the event message queue

263
00:09:04,320 --> 00:09:06,080
inside the kernel extension

264
00:09:06,080 --> 00:09:07,519
because of this it means that you can

265
00:09:07,519 --> 00:09:09,600
avoid overloading

266
00:09:09,600 --> 00:09:12,480
however it's quite a blunt tool back

267
00:09:12,480 --> 00:09:14,399
when i was experimenting with it because

268
00:09:14,399 --> 00:09:15,839
you either had to specify an entire

269
00:09:15,839 --> 00:09:17,920
process path again assuming it hasn't

270
00:09:17,920 --> 00:09:20,000
been hijacked by anything or you had to

271
00:09:20,000 --> 00:09:21,680
do it by process token which only works

272
00:09:21,680 --> 00:09:23,680
for that instance of the process it was

273
00:09:23,680 --> 00:09:25,760
either too much of a sledgehammer or it

274
00:09:25,760 --> 00:09:29,040
was too um unspecific it wasn't targeted

275
00:09:29,040 --> 00:09:31,120
enough so for

276
00:09:31,120 --> 00:09:33,279
a um

277
00:09:33,279 --> 00:09:35,519
viable solution event muting just wasn't

278
00:09:35,519 --> 00:09:38,480
specific enough for effective filtering

279
00:09:38,480 --> 00:09:40,800
multi-client system however did turn out

280
00:09:40,800 --> 00:09:43,040
to be very effective so whereas you

281
00:09:43,040 --> 00:09:44,880
would have a

282
00:09:44,880 --> 00:09:46,240
endpoint security client within a

283
00:09:46,240 --> 00:09:48,640
process subscribe to event types instead

284
00:09:48,640 --> 00:09:50,399
of having one client subscribe to

285
00:09:50,399 --> 00:09:52,160
multiple event types you could have

286
00:09:52,160 --> 00:09:54,000
multiple clients subscribe to individual

287
00:09:54,000 --> 00:09:56,000
event types which equally generated

288
00:09:56,000 --> 00:09:58,480
their own queue within the kernel space

289
00:09:58,480 --> 00:10:00,160
and by using this method you don't get

290
00:10:00,160 --> 00:10:01,760
overload and you get all the data you

291
00:10:01,760 --> 00:10:03,519
require and you can conglomerate them

292
00:10:03,519 --> 00:10:04,399
into one

293
00:10:04,399 --> 00:10:05,440
data set and then run it through your

294
00:10:05,440 --> 00:10:07,360
detection stack by crop referencing

295
00:10:07,360 --> 00:10:10,399
which was very effective

296
00:10:10,399 --> 00:10:12,800
one point to note is that um the

297
00:10:12,800 --> 00:10:15,360
original development was on sdk 10.15

298
00:10:15,360 --> 00:10:17,360
for catalina this was when esf was

299
00:10:17,360 --> 00:10:21,600
introduced but between 10.15 and 10.15.4

300
00:10:21,600 --> 00:10:24,240
the sdk was suddenly updated one with a

301
00:10:24,240 --> 00:10:26,480
number of new event types they increased

302
00:10:26,480 --> 00:10:28,320
something called the sec num or sequence

303
00:10:28,320 --> 00:10:30,480
number in the es message so whereas i

304
00:10:30,480 --> 00:10:31,519
was saying before there's no

305
00:10:31,519 --> 00:10:33,200
notification from the kernel that silent

306
00:10:33,200 --> 00:10:35,200
drops have occurred that is still the

307
00:10:35,200 --> 00:10:37,600
case but by using the sequence number

308
00:10:37,600 --> 00:10:39,440
you can see whether there's a gap in

309
00:10:39,440 --> 00:10:40,880
those sequence numbers to see whether a

310
00:10:40,880 --> 00:10:42,160
message has been dropped due to

311
00:10:42,160 --> 00:10:44,640
overloading so it doesn't alert you per

312
00:10:44,640 --> 00:10:47,279
se but it does allow you to filter that

313
00:10:47,279 --> 00:10:49,040
data and detect when it's happening and

314
00:10:49,040 --> 00:10:50,959
from that do diet things like dynamic

315
00:10:50,959 --> 00:10:55,040
rebalancing in order to prevent overload

316
00:10:55,040 --> 00:10:57,120
system verbosity um if you look on the

317
00:10:57,120 --> 00:10:58,320
image on the right you'll see that the

318
00:10:58,320 --> 00:11:00,720
original uid is zero

319
00:11:00,720 --> 00:11:03,040
this is the system user id on the on the

320
00:11:03,040 --> 00:11:05,760
system on the operating system

321
00:11:05,760 --> 00:11:07,839
and because it works at the kernel level

322
00:11:07,839 --> 00:11:09,839
it ingests all the processing and all

323
00:11:09,839 --> 00:11:11,519
the file information for the system as

324
00:11:11,519 --> 00:11:13,839
well including system daemons and system

325
00:11:13,839 --> 00:11:14,959
level

326
00:11:14,959 --> 00:11:17,120
propriety management systems

327
00:11:17,120 --> 00:11:19,200
and this creates a problem because we've

328
00:11:19,200 --> 00:11:20,880
talked about the bottlenecking issue

329
00:11:20,880 --> 00:11:23,760
before the simple amount of data that's

330
00:11:23,760 --> 00:11:25,920
being processed by the esf when you take

331
00:11:25,920 --> 00:11:28,399
into account the system events is

332
00:11:28,399 --> 00:11:30,399
extremely high

333
00:11:30,399 --> 00:11:31,600
and because of this you end up with a

334
00:11:31,600 --> 00:11:34,079
sort of overhead issue where you have to

335
00:11:34,079 --> 00:11:35,600
either filter out these system level

336
00:11:35,600 --> 00:11:38,000
events or you have to

337
00:11:38,000 --> 00:11:39,519
allow them but then do additional

338
00:11:39,519 --> 00:11:42,959
filtering for anomalous indications

339
00:11:42,959 --> 00:11:44,959
so one of the things again is that you

340
00:11:44,959 --> 00:11:46,720
could do it either before or after

341
00:11:46,720 --> 00:11:48,959
collection so before collection as we

342
00:11:48,959 --> 00:11:51,120
said would be by event muting but as

343
00:11:51,120 --> 00:11:52,800
i've said before this is quite a blunt

344
00:11:52,800 --> 00:11:55,200
tool and to use this for this sort of

345
00:11:55,200 --> 00:11:57,360
activity it means you'll be dropping

346
00:11:57,360 --> 00:11:58,959
the only way to do this would be to drop

347
00:11:58,959 --> 00:12:00,639
all processes running at the system

348
00:12:00,639 --> 00:12:02,560
level which can

349
00:12:02,560 --> 00:12:04,320
introduce ignorance of system level

350
00:12:04,320 --> 00:12:08,000
compromise which could be very dangerous

351
00:12:08,000 --> 00:12:09,360
so instead you have to look at

352
00:12:09,360 --> 00:12:10,880
client-side filtering but then you look

353
00:12:10,880 --> 00:12:12,800
at the bottleneck issue that i mentioned

354
00:12:12,800 --> 00:12:15,040
before and even when you start to filter

355
00:12:15,040 --> 00:12:16,800
down the event types into individual

356
00:12:16,800 --> 00:12:18,720
clients you still run the risk of data

357
00:12:18,720 --> 00:12:20,560
events being dropped simply because the

358
00:12:20,560 --> 00:12:23,200
system level processing event generation

359
00:12:23,200 --> 00:12:26,240
is just so high so it's a becomes a

360
00:12:26,240 --> 00:12:28,800
balancing act between the two um there's

361
00:12:28,800 --> 00:12:30,720
no real

362
00:12:30,720 --> 00:12:32,800
one-size-fits-all solution for this so

363
00:12:32,800 --> 00:12:34,480
you have to sort of balance this

364
00:12:34,480 --> 00:12:38,760
dynamically as well as possible

365
00:12:38,959 --> 00:12:40,880
parent process id issue so this is an

366
00:12:40,880 --> 00:12:42,959
ongoing issue in the mac operating

367
00:12:42,959 --> 00:12:45,279
system

368
00:12:46,240 --> 00:12:47,519
primarily this

369
00:12:47,519 --> 00:12:49,839
relates back to

370
00:12:49,839 --> 00:12:52,800
identifying where the original process

371
00:12:52,800 --> 00:12:55,200
was spawned from so this actually goes

372
00:12:55,200 --> 00:12:58,079
back to things like xpc proxy launch d

373
00:12:58,079 --> 00:12:59,440
and more recently something called

374
00:12:59,440 --> 00:13:01,040
running board

375
00:13:01,040 --> 00:13:02,720
so you may see at the top there's a real

376
00:13:02,720 --> 00:13:06,320
ppid of -1 this is actually by using a

377
00:13:06,320 --> 00:13:09,200
ppid solution um

378
00:13:09,200 --> 00:13:10,720
but as you can see because it was

379
00:13:10,720 --> 00:13:12,399
running on a newer open system the

380
00:13:12,399 --> 00:13:14,880
result has actually come out as -1 which

381
00:13:14,880 --> 00:13:15,920
is

382
00:13:15,920 --> 00:13:17,760
incorrect data just to demonstrate that

383
00:13:17,760 --> 00:13:19,040
this is actually an ongoing issue that

384
00:13:19,040 --> 00:13:20,399
there isn't really

385
00:13:20,399 --> 00:13:22,880
a permanent solution for at the bottom

386
00:13:22,880 --> 00:13:25,519
you can see that there is launch d being

387
00:13:25,519 --> 00:13:28,079
launched um xbc proxy being launched

388
00:13:28,079 --> 00:13:30,399
launched by launch d but that doesn't

389
00:13:30,399 --> 00:13:32,079
necessarily indicate where an original

390
00:13:32,079 --> 00:13:34,079
processor is called from the reason for

391
00:13:34,079 --> 00:13:36,240
this is because of how cross-process

392
00:13:36,240 --> 00:13:38,880
communications work in mac os it's not

393
00:13:38,880 --> 00:13:41,360
really that easy to identify what

394
00:13:41,360 --> 00:13:43,279
process was initiating another because

395
00:13:43,279 --> 00:13:45,600
it jumps through these other programs so

396
00:13:45,600 --> 00:13:47,199
when you start to go back to the process

397
00:13:47,199 --> 00:13:49,519
chain that can be gapped

398
00:13:49,519 --> 00:13:53,440
due to these underlying system processes

399
00:13:53,440 --> 00:13:55,680
as i said there is no real future-proof

400
00:13:55,680 --> 00:13:57,120
solution the real reason for this is

401
00:13:57,120 --> 00:13:59,360
that apple keep changing the way that

402
00:13:59,360 --> 00:14:01,199
this cross-process communication works

403
00:14:01,199 --> 00:14:04,240
for process um spawning so any time a

404
00:14:04,240 --> 00:14:05,839
solution is made for one operating

405
00:14:05,839 --> 00:14:07,920
system version it can be made obsolete

406
00:14:07,920 --> 00:14:09,760
by the next update which as you can

407
00:14:09,760 --> 00:14:10,959
imagine is

408
00:14:10,959 --> 00:14:12,880
fairly frustrating

409
00:14:12,880 --> 00:14:14,480
the current solutions that i was looking

410
00:14:14,480 --> 00:14:16,079
at at the time were true tree by john

411
00:14:16,079 --> 00:14:18,639
bradley and launch xpc by patrick wall

412
00:14:18,639 --> 00:14:20,720
launch xvc was actually the solution

413
00:14:20,720 --> 00:14:22,880
that was implemented in

414
00:14:22,880 --> 00:14:24,800
my esfang solution

415
00:14:24,800 --> 00:14:26,399
but it doesn't take into account running

416
00:14:26,399 --> 00:14:29,120
board at the time which means that as

417
00:14:29,120 --> 00:14:32,480
was demonstrated by the -1 real ppid

418
00:14:32,480 --> 00:14:35,519
it is not a fully fledged or conclusive

419
00:14:35,519 --> 00:14:37,440
solution to this

420
00:14:37,440 --> 00:14:39,839
as i said this is an ongoing problem

421
00:14:39,839 --> 00:14:41,519
that there isn't a one-size-fits-all

422
00:14:41,519 --> 00:14:44,720
solution for yet um and it it was beyond

423
00:14:44,720 --> 00:14:46,639
my scope to to try and figure that one

424
00:14:46,639 --> 00:14:48,320
out

425
00:14:48,320 --> 00:14:50,560
so looking at the solution that i

426
00:14:50,560 --> 00:14:53,519
developed on my psc poc which i code

427
00:14:53,519 --> 00:14:55,199
named es fang

428
00:14:55,199 --> 00:14:57,279
so first of all i need to shout out to

429
00:14:57,279 --> 00:15:00,000
patrick wardle chris ross and omar ikram

430
00:15:00,000 --> 00:15:03,360
they back in the early 2020 really set

431
00:15:03,360 --> 00:15:05,920
the stage for how esf could work the

432
00:15:05,920 --> 00:15:07,680
sort of telemetry acquisitions and

433
00:15:07,680 --> 00:15:09,040
really basic

434
00:15:09,040 --> 00:15:11,760
um fundamentals of how to ingest esf

435
00:15:11,760 --> 00:15:12,480
data

436
00:15:12,480 --> 00:15:14,800
and the my poc was based primarily off

437
00:15:14,800 --> 00:15:16,399
of their work and then expanding on it

438
00:15:16,399 --> 00:15:19,440
and introducing capabilities and

439
00:15:19,440 --> 00:15:21,440
solutions that i mentioned before for

440
00:15:21,440 --> 00:15:25,040
some of the issues that i encountered

441
00:15:25,360 --> 00:15:27,120
my solution was actually developed early

442
00:15:27,120 --> 00:15:30,639
in 2021 um and it was based off of 52

443
00:15:30,639 --> 00:15:32,839
event types back in sdk

444
00:15:32,839 --> 00:15:34,560
10.15.4

445
00:15:34,560 --> 00:15:35,440
the

446
00:15:35,440 --> 00:15:37,440
primary reason that i did this was that

447
00:15:37,440 --> 00:15:40,160
the old solutions had a fixed definition

448
00:15:40,160 --> 00:15:42,560
of what event types it would ingest and

449
00:15:42,560 --> 00:15:44,240
as i said before

450
00:15:44,240 --> 00:15:46,160
this meant that overloading could occur

451
00:15:46,160 --> 00:15:48,240
because it was a fixed number of event

452
00:15:48,240 --> 00:15:51,040
types which you couldn't necessarily um

453
00:15:51,040 --> 00:15:53,040
deviate from which if it was causing

454
00:15:53,040 --> 00:15:54,959
eventing you couldn't

455
00:15:54,959 --> 00:15:57,600
change from the rigid structure

456
00:15:57,600 --> 00:16:00,000
however the solution that i put in was a

457
00:16:00,000 --> 00:16:02,079
dynamic solution so this allows you that

458
00:16:02,079 --> 00:16:04,240
each boot you can specify which event

459
00:16:04,240 --> 00:16:05,680
types you want to subscribe to so you

460
00:16:05,680 --> 00:16:07,920
can have multiple espang instances

461
00:16:07,920 --> 00:16:09,920
subscribe to different event types or

462
00:16:09,920 --> 00:16:10,880
you can have them subscribed to

463
00:16:10,880 --> 00:16:13,360
multi-event types or group types like

464
00:16:13,360 --> 00:16:14,480
file

465
00:16:14,480 --> 00:16:17,600
file creation data or file metadata

466
00:16:17,600 --> 00:16:21,519
uipc data um cross-beneath cross

467
00:16:21,519 --> 00:16:23,199
processed communication port data and

468
00:16:23,199 --> 00:16:25,680
things like that

469
00:16:25,680 --> 00:16:28,079
using this solution you can avoid the

470
00:16:28,079 --> 00:16:30,720
overhead um the bottlenecking issue

471
00:16:30,720 --> 00:16:33,199
i when i started this had never coded in

472
00:16:33,199 --> 00:16:35,680
objective c before so doing um

473
00:16:35,680 --> 00:16:37,759
multi-threaded processes to achieve this

474
00:16:37,759 --> 00:16:39,920
as a standard solution was actually a

475
00:16:39,920 --> 00:16:42,560
bit outside the scope but it is it

476
00:16:42,560 --> 00:16:44,959
should be easy to do moving forward from

477
00:16:44,959 --> 00:16:47,199
any objective-c programmers out there

478
00:16:47,199 --> 00:16:48,880
one thing to note is that because this

479
00:16:48,880 --> 00:16:51,040
was not done with an apple developer id

480
00:16:51,040 --> 00:16:53,680
it is a poc code so sip has to be

481
00:16:53,680 --> 00:16:56,320
disabled or system integrity protection

482
00:16:56,320 --> 00:16:59,440
so esf cannot be accessed with sip

483
00:16:59,440 --> 00:17:01,600
enabled unless the program that you're

484
00:17:01,600 --> 00:17:03,199
using has been signed by an apple

485
00:17:03,199 --> 00:17:04,480
developer id

486
00:17:04,480 --> 00:17:06,480
so if you want to use this for testing

487
00:17:06,480 --> 00:17:08,720
purposes you have to disable sip

488
00:17:08,720 --> 00:17:11,280
on your system so this isn't viable for

489
00:17:11,280 --> 00:17:13,599
production level systems

490
00:17:13,599 --> 00:17:15,839
the other thing is that it was designed

491
00:17:15,839 --> 00:17:18,480
for json output for upstream integration

492
00:17:18,480 --> 00:17:19,280
so

493
00:17:19,280 --> 00:17:21,119
all the output is put into json format

494
00:17:21,119 --> 00:17:22,799
so it can be easily piped up into a

495
00:17:22,799 --> 00:17:24,880
database for further detection

496
00:17:24,880 --> 00:17:28,799
processing and easy acquisition by um

497
00:17:28,799 --> 00:17:30,720
elastic or threatening teams to those

498
00:17:30,720 --> 00:17:33,760
data sets

499
00:17:33,760 --> 00:17:35,440
so let's go over the merterpretty use

500
00:17:35,440 --> 00:17:37,760
case

501
00:17:38,000 --> 00:17:39,360
use case

502
00:17:39,360 --> 00:17:41,720
was done on macos

503
00:17:41,720 --> 00:17:43,600
11.2.2

504
00:17:43,600 --> 00:17:45,679
i used esvang to collect all the data

505
00:17:45,679 --> 00:17:47,440
and this is for the agent only so this

506
00:17:47,440 --> 00:17:48,480
isn't to do with the metasploit

507
00:17:48,480 --> 00:17:49,840
frameworks capability that can be piped

508
00:17:49,840 --> 00:17:51,600
through the interpreter agent it is only

509
00:17:51,600 --> 00:17:54,799
for the native material agent capability

510
00:17:54,799 --> 00:17:56,720
this is only done on the post exploit

511
00:17:56,720 --> 00:17:58,720
phase so i'm not interested in how the

512
00:17:58,720 --> 00:18:00,320
agent got onto the system only what the

513
00:18:00,320 --> 00:18:02,160
age you can do once it is on a system

514
00:18:02,160 --> 00:18:03,760
and this was done only against a single

515
00:18:03,760 --> 00:18:05,600
host so not against an enterprise

516
00:18:05,600 --> 00:18:08,320
interconnected um sort of demonstration

517
00:18:08,320 --> 00:18:10,720
so it's not necessarily representative

518
00:18:10,720 --> 00:18:12,559
of a real life attack but it's to

519
00:18:12,559 --> 00:18:14,720
demonstrate what esf telemetry is

520
00:18:14,720 --> 00:18:17,440
capable of

521
00:18:17,520 --> 00:18:19,200
so the overall findings again the graph

522
00:18:19,200 --> 00:18:21,520
on the right is very small it's

523
00:18:21,520 --> 00:18:24,240
it's a representation of all the um

524
00:18:24,240 --> 00:18:26,480
commands that were executed and the data

525
00:18:26,480 --> 00:18:28,480
that was generated as you can see from

526
00:18:28,480 --> 00:18:30,400
the top solution is actually uh webcam

527
00:18:30,400 --> 00:18:32,799
streaming which is not opsec obviously

528
00:18:32,799 --> 00:18:34,640
and as you can see it generates a

529
00:18:34,640 --> 00:18:36,880
massive amount of data but as you move

530
00:18:36,880 --> 00:18:38,559
further down you can see that some of

531
00:18:38,559 --> 00:18:41,760
the data some of the commands generated

532
00:18:41,760 --> 00:18:43,679
seemingly none of very little event

533
00:18:43,679 --> 00:18:45,280
types but i will go through some of

534
00:18:45,280 --> 00:18:47,440
these to demonstrate some of the data

535
00:18:47,440 --> 00:18:49,760
values that can be found

536
00:18:49,760 --> 00:18:53,360
so during the install you can see that

537
00:18:53,360 --> 00:18:54,400
open

538
00:18:54,400 --> 00:18:56,799
read directory and protect were the

539
00:18:56,799 --> 00:18:58,400
highest event types that were generated

540
00:18:58,400 --> 00:19:01,360
through esf for temperature installation

541
00:19:01,360 --> 00:19:04,240
now memory protect and um memory mapping

542
00:19:04,240 --> 00:19:06,400
for new processes you expect this to

543
00:19:06,400 --> 00:19:07,679
occur and remember protect being that

544
00:19:07,679 --> 00:19:09,280
high is actually not bad anomalous even

545
00:19:09,280 --> 00:19:11,120
though it's quite a high number but if

546
00:19:11,120 --> 00:19:12,960
you turn this against what a normal

547
00:19:12,960 --> 00:19:14,799
process would do on the mac estate it

548
00:19:14,799 --> 00:19:16,160
actually doesn't stand out as that

549
00:19:16,160 --> 00:19:17,520
anomalous especially when you look into

550
00:19:17,520 --> 00:19:19,200
the internal data

551
00:19:19,200 --> 00:19:21,440
the open event however is slightly more

552
00:19:21,440 --> 00:19:24,640
anomalous alongside the fc ntl or file

553
00:19:24,640 --> 00:19:26,799
control events the reason for this is

554
00:19:26,799 --> 00:19:29,600
that during during deployment the amount

555
00:19:29,600 --> 00:19:31,120
of file that it accesses in order to

556
00:19:31,120 --> 00:19:35,120
enumerate number of system um

557
00:19:35,120 --> 00:19:36,960
enumerate the system information and

558
00:19:36,960 --> 00:19:39,360
equally to change certain file access

559
00:19:39,360 --> 00:19:41,679
controls can be indicative of a

560
00:19:41,679 --> 00:19:43,280
temperature deployment so actually

561
00:19:43,280 --> 00:19:45,120
looking at these two specific event

562
00:19:45,120 --> 00:19:47,360
types does allow you to process a

563
00:19:47,360 --> 00:19:50,080
profile interpreter installation on a

564
00:19:50,080 --> 00:19:53,799
mac operating system

565
00:19:57,919 --> 00:19:59,200
so breaking down that slide a little bit

566
00:19:59,200 --> 00:20:02,240
further in total 259 data points are

567
00:20:02,240 --> 00:20:04,080
generated during an interpreter

568
00:20:04,080 --> 00:20:05,360
installation

569
00:20:05,360 --> 00:20:08,320
but 259 data points doesn't necessarily

570
00:20:08,320 --> 00:20:09,600
mean that they're great data points

571
00:20:09,600 --> 00:20:12,559
quantity is not always an indicator of

572
00:20:12,559 --> 00:20:13,760
quality

573
00:20:13,760 --> 00:20:15,600
but if you have enough data points with

574
00:20:15,600 --> 00:20:17,200
enough cross referencing you can

575
00:20:17,200 --> 00:20:19,600
generate more accurate processes

576
00:20:19,600 --> 00:20:21,919
profiles and higher fidelity as long as

577
00:20:21,919 --> 00:20:24,640
you know what you're looking for and esf

578
00:20:24,640 --> 00:20:26,480
during my experimentation showed that it

579
00:20:26,480 --> 00:20:28,640
had both quantity and it had quality

580
00:20:28,640 --> 00:20:30,799
event types so by filtering the two

581
00:20:30,799 --> 00:20:32,159
together you actually get a very

582
00:20:32,159 --> 00:20:33,360
accurate representation of when

583
00:20:33,360 --> 00:20:36,080
anomalous behavior has occurred

584
00:20:36,080 --> 00:20:37,360
but let's look at some of the other

585
00:20:37,360 --> 00:20:39,600
event types that are generated and

586
00:20:39,600 --> 00:20:42,080
against what sort of commands

587
00:20:42,080 --> 00:20:44,640
so on this slide again so this is to do

588
00:20:44,640 --> 00:20:47,360
with file open events so on the far

589
00:20:47,360 --> 00:20:50,080
right you can see webcam stream of 478

590
00:20:50,080 --> 00:20:51,600
and it's not operation secure so that

591
00:20:51,600 --> 00:20:53,440
stands out like a sort of thumb

592
00:20:53,440 --> 00:20:55,120
process listing is slightly different so

593
00:20:55,120 --> 00:20:57,280
for each process that's running it opens

594
00:20:57,280 --> 00:20:59,440
an individual file for each process to

595
00:20:59,440 --> 00:21:02,400
see whether it is whether it is running

596
00:21:02,400 --> 00:21:04,320
um when you look at that event type

597
00:21:04,320 --> 00:21:06,080
individually you can actually filter out

598
00:21:06,080 --> 00:21:07,440
that it's scanning each individual

599
00:21:07,440 --> 00:21:09,679
processes file which is quite easy to

600
00:21:09,679 --> 00:21:10,720
profile

601
00:21:10,720 --> 00:21:12,240
if you already know what processes are

602
00:21:12,240 --> 00:21:14,240
running on the system you can just scan

603
00:21:14,240 --> 00:21:15,120
for

604
00:21:15,120 --> 00:21:17,600
is asus is a process scanning for all

605
00:21:17,600 --> 00:21:19,600
the running processing files and detect

606
00:21:19,600 --> 00:21:21,440
against that

607
00:21:21,440 --> 00:21:23,760
the screen share and system information

608
00:21:23,760 --> 00:21:28,400
follows the uh same sort of um

609
00:21:28,559 --> 00:21:30,880
process so in order to enumerate and

610
00:21:30,880 --> 00:21:32,320
gather information about how it's going

611
00:21:32,320 --> 00:21:34,000
to screen share it has to open up a

612
00:21:34,000 --> 00:21:35,840
number of system files and system

613
00:21:35,840 --> 00:21:37,120
information it does the same way as it

614
00:21:37,120 --> 00:21:38,799
does for process listing instead of

615
00:21:38,799 --> 00:21:40,640
using general system information

616
00:21:40,640 --> 00:21:42,240
commands from the bash terminal and

617
00:21:42,240 --> 00:21:45,520
instead accesses a number of system um

618
00:21:45,520 --> 00:21:48,240
files on the on the operating system in

619
00:21:48,240 --> 00:21:51,919
order to enumerate that information

620
00:21:51,919 --> 00:21:53,679
notify right this is a really

621
00:21:53,679 --> 00:21:55,840
interesting one so edit file when it

622
00:21:55,840 --> 00:21:57,840
targets an individual file to edit it

623
00:21:57,840 --> 00:21:59,280
writes the information the file and you

624
00:21:59,280 --> 00:22:01,280
get one writer then

625
00:22:01,280 --> 00:22:03,280
upload is slightly different so when you

626
00:22:03,280 --> 00:22:06,320
upload using meterpreter instead as it's

627
00:22:06,320 --> 00:22:08,400
transferring the data from your

628
00:22:08,400 --> 00:22:10,400
attack machine to the compromised

629
00:22:10,400 --> 00:22:12,880
machine each packet is appended to the

630
00:22:12,880 --> 00:22:14,000
file

631
00:22:14,000 --> 00:22:15,840
routinely as it's received which

632
00:22:15,840 --> 00:22:18,640
generates this nump this huge number of

633
00:22:18,640 --> 00:22:21,039
write events to an individual file but

634
00:22:21,039 --> 00:22:23,679
the write a size is quite small and it

635
00:22:23,679 --> 00:22:25,840
actually corresponds to the size of

636
00:22:25,840 --> 00:22:27,280
network packets being received from the

637
00:22:27,280 --> 00:22:28,640
interpreter agent

638
00:22:28,640 --> 00:22:31,280
so from this you can actually target one

639
00:22:31,280 --> 00:22:34,000
processor targeting one other file and

640
00:22:34,000 --> 00:22:36,080
write it then and doing it in very small

641
00:22:36,080 --> 00:22:37,120
increments

642
00:22:37,120 --> 00:22:39,520
um repeatedly especially if you filter

643
00:22:39,520 --> 00:22:41,200
out things like internet browsers and

644
00:22:41,200 --> 00:22:42,880
things like that you very quickly can

645
00:22:42,880 --> 00:22:46,320
isolate when this is occurring

646
00:22:46,720 --> 00:22:48,720
io open is another interesting one so

647
00:22:48,720 --> 00:22:50,960
this is to do with driver or hardware

648
00:22:50,960 --> 00:22:52,000
access

649
00:22:52,000 --> 00:22:53,679
and again you'd expect to see webcam

650
00:22:53,679 --> 00:22:55,840
stream 220 because it's hijacking the

651
00:22:55,840 --> 00:22:59,039
webcam streams um data feed

652
00:22:59,039 --> 00:23:00,799
but screen share again because it's

653
00:23:00,799 --> 00:23:03,520
hijacking the user interface uh display

654
00:23:03,520 --> 00:23:07,120
feed it equally generates io event types

655
00:23:07,120 --> 00:23:09,840
and again io kit is not something you

656
00:23:09,840 --> 00:23:13,039
see commonly is quite a

657
00:23:13,039 --> 00:23:15,679
low generated event so finding any io

658
00:23:15,679 --> 00:23:18,720
kit events outside of system uid is

659
00:23:18,720 --> 00:23:20,640
quite anonymous and makes it very easy

660
00:23:20,640 --> 00:23:22,720
to identify when malicious behavior is

661
00:23:22,720 --> 00:23:24,799
occurring

662
00:23:24,799 --> 00:23:27,120
this is a list of some of the valued

663
00:23:27,120 --> 00:23:29,919
event types done against other that i've

664
00:23:29,919 --> 00:23:31,760
isolated from other investigations

665
00:23:31,760 --> 00:23:33,280
against things like

666
00:23:33,280 --> 00:23:35,360
max shell swift sliver

667
00:23:35,360 --> 00:23:38,320
merlin and other attack frameworks one

668
00:23:38,320 --> 00:23:39,600
of the interesting ones uh one of the

669
00:23:39,600 --> 00:23:41,200
primary interesting ones is on the right

670
00:23:41,200 --> 00:23:43,279
there for pty grant

671
00:23:43,279 --> 00:23:45,440
uh the reason for this is that p3 guard

672
00:23:45,440 --> 00:23:48,840
is for pseudo-terminal generation so for

673
00:23:48,840 --> 00:23:51,840
a dynamic user session instead of piping

674
00:23:51,840 --> 00:23:53,200
the command through a bash terminal like

675
00:23:53,200 --> 00:23:55,600
you normally would instead max shell

676
00:23:55,600 --> 00:23:57,360
swift generates a pseudo terminal which

677
00:23:57,360 --> 00:23:59,279
is a master slave comparison and

678
00:23:59,279 --> 00:24:00,880
actually executes the commands that way

679
00:24:00,880 --> 00:24:02,400
which is slightly weird and you don't

680
00:24:02,400 --> 00:24:05,840
see that very often

681
00:24:06,400 --> 00:24:08,480
so in summary

682
00:24:08,480 --> 00:24:11,520
esf is extremely powerful and it's very

683
00:24:11,520 --> 00:24:14,000
clear that apple is taking the time to

684
00:24:14,000 --> 00:24:16,080
really look over the problems that are

685
00:24:16,080 --> 00:24:17,760
occurring

686
00:24:17,760 --> 00:24:19,840
during its use and equally to refine the

687
00:24:19,840 --> 00:24:21,679
event types that are available

688
00:24:21,679 --> 00:24:24,960
during s d progression from sdk 10.15 to

689
00:24:24,960 --> 00:24:26,880
sdk 10.15.4

690
00:24:26,880 --> 00:24:28,400
the number of event types increased but

691
00:24:28,400 --> 00:24:29,840
equally so did the

692
00:24:29,840 --> 00:24:31,440
capabilities of detection when the

693
00:24:31,440 --> 00:24:32,880
system wasn't necessarily doing what it

694
00:24:32,880 --> 00:24:34,559
was meant to

695
00:24:34,559 --> 00:24:36,960
because of this um it's actually quite

696
00:24:36,960 --> 00:24:38,640
especially quite reassuring knowing that

697
00:24:38,640 --> 00:24:40,480
apple have made this not really optional

698
00:24:40,480 --> 00:24:41,760
due to the deprecation of kernel

699
00:24:41,760 --> 00:24:43,600
extensions from third parties

700
00:24:43,600 --> 00:24:44,960
and the fact that they're actually

701
00:24:44,960 --> 00:24:46,400
maintaining this

702
00:24:46,400 --> 00:24:48,240
shows that they realize that they've

703
00:24:48,240 --> 00:24:49,360
taken that control away from the

704
00:24:49,360 --> 00:24:50,559
security industry but are actually

705
00:24:50,559 --> 00:24:52,320
taking steps to provide all the

706
00:24:52,320 --> 00:24:54,159
information and the stability that is

707
00:24:54,159 --> 00:24:55,360
required

708
00:24:55,360 --> 00:24:56,799
as we said some of the teething issues

709
00:24:56,799 --> 00:24:58,799
to begin with have been addressed but

710
00:24:58,799 --> 00:25:00,720
there are still more that exist and

711
00:25:00,720 --> 00:25:02,480
during more and more experimentation

712
00:25:02,480 --> 00:25:04,240
they will rear their heads as we go

713
00:25:04,240 --> 00:25:06,159
forward

714
00:25:06,159 --> 00:25:08,559
as i said earlier um compared to prior

715
00:25:08,559 --> 00:25:09,919
solutions especially developing your

716
00:25:09,919 --> 00:25:11,520
internal extensions or using open bsn

717
00:25:11,520 --> 00:25:13,840
which is very clunky esf is very

718
00:25:13,840 --> 00:25:16,000
streamlined it's very easy to integrate

719
00:25:16,000 --> 00:25:18,000
into your existing stack

720
00:25:18,000 --> 00:25:20,320
and because of this it makes integration

721
00:25:20,320 --> 00:25:22,159
and development on it very easy from a

722
00:25:22,159 --> 00:25:25,120
security development standpoint

723
00:25:25,120 --> 00:25:27,440
looking at the use cases and some of the

724
00:25:27,440 --> 00:25:28,960
other experimentations that i've done in

725
00:25:28,960 --> 00:25:30,960
the past it does mean the detection

726
00:25:30,960 --> 00:25:32,880
capabilities that are available are very

727
00:25:32,880 --> 00:25:34,960
high and it means that moving forward we

728
00:25:34,960 --> 00:25:36,720
were able to create better detection

729
00:25:36,720 --> 00:25:39,520
profiles based off the esf telemetry

730
00:25:39,520 --> 00:25:41,200
that is available in equally expanding

731
00:25:41,200 --> 00:25:42,640
event types that they're they're

732
00:25:42,640 --> 00:25:43,760
allowing

733
00:25:43,760 --> 00:25:46,159
the the final point to know is that

734
00:25:46,159 --> 00:25:48,720
as as i've mentioned the number of event

735
00:25:48,720 --> 00:25:50,159
points that are generated especially

736
00:25:50,159 --> 00:25:51,760
because the system level and even

737
00:25:51,760 --> 00:25:53,120
because of the low level temperatures

738
00:25:53,120 --> 00:25:55,520
available is very very high and because

739
00:25:55,520 --> 00:25:57,679
you don't have control over the current

740
00:25:57,679 --> 00:26:00,080
extension itself filtering is absolutely

741
00:26:00,080 --> 00:26:02,480
essential and it becomes

742
00:26:02,480 --> 00:26:04,559
not optional and it's one of those

743
00:26:04,559 --> 00:26:05,919
things that we're just going to have to

744
00:26:05,919 --> 00:26:07,279
deal with moving forward in when

745
00:26:07,279 --> 00:26:11,159
developing using the system

746
00:26:11,919 --> 00:26:13,919
that's my email that is the github with

747
00:26:13,919 --> 00:26:15,760
the esf rang source code if anyone has

748
00:26:15,760 --> 00:26:18,880
any questions please feel free to email

749
00:26:18,880 --> 00:26:20,559
me afterwards

750
00:26:20,559 --> 00:26:23,279
we do have some time for q a so if

751
00:26:23,279 --> 00:26:26,640
anyone has your questions please

752
00:26:32,400 --> 00:26:34,640
so if anybody has questions please come

753
00:26:34,640 --> 00:26:38,840
in frontier to the first mike

754
00:26:41,200 --> 00:26:42,880
just come to the mic yeah yeah yeah

755
00:26:42,880 --> 00:26:45,880
thanks

756
00:26:53,440 --> 00:26:54,640
okay uh

757
00:26:54,640 --> 00:26:57,679
so uh thank you for the talk uh i was

758
00:26:57,679 --> 00:27:00,400
wondering from a perspective from a blue

759
00:27:00,400 --> 00:27:03,840
team uh what kind of events i'm kind of

760
00:27:03,840 --> 00:27:06,720
i'm um i can find when i'm look at the

761
00:27:06,720 --> 00:27:09,200
telemetry because uh i'm more familiar

762
00:27:09,200 --> 00:27:11,120
with the windows events and sometimes we

763
00:27:11,120 --> 00:27:13,039
can find like credentials passwords

764
00:27:13,039 --> 00:27:14,720
what's not good so we have to remove

765
00:27:14,720 --> 00:27:16,480
them do you know if there is something

766
00:27:16,480 --> 00:27:20,000
in place that remove this pi data or do

767
00:27:20,000 --> 00:27:22,320
i have to do it with myself

768
00:27:22,320 --> 00:27:23,760
so yeah that's great question so you'd

769
00:27:23,760 --> 00:27:25,600
have to do this all manually the events

770
00:27:25,600 --> 00:27:26,880
that are generated by the current

771
00:27:26,880 --> 00:27:29,039
extension themselves are raw so when you

772
00:27:29,039 --> 00:27:30,799
get them from the esf client side they

773
00:27:30,799 --> 00:27:32,320
can't be tampered with from the current

774
00:27:32,320 --> 00:27:34,000
extension side so it will have to be

775
00:27:34,000 --> 00:27:36,399
filtered on the client slide itself um

776
00:27:36,399 --> 00:27:37,919
and there's no way of doing this further

777
00:27:37,919 --> 00:27:38,960
up the chain

778
00:27:38,960 --> 00:27:41,840
okay so if i decide to ingest this in

779
00:27:41,840 --> 00:27:44,320
some like uh splunk so i have to take

780
00:27:44,320 --> 00:27:46,000
care of this yes

781
00:27:46,000 --> 00:27:46,880
okay

782
00:27:46,880 --> 00:27:50,880
okay cool thank you very much no problem

783
00:27:51,520 --> 00:27:53,760
yep

784
00:27:55,279 --> 00:27:57,039
uh you mentioned that there's the user

785
00:27:57,039 --> 00:28:00,880
space component that is registering for

786
00:28:00,880 --> 00:28:04,159
for the filters or for events sorry yeah

787
00:28:04,159 --> 00:28:06,480
uh two questions basically is there also

788
00:28:06,480 --> 00:28:08,880
an unregister element that i can for

789
00:28:08,880 --> 00:28:10,799
example call if i'm doing a red teaming

790
00:28:10,799 --> 00:28:13,520
assessment and i got a gain access to

791
00:28:13,520 --> 00:28:15,200
this user space component can i then

792
00:28:15,200 --> 00:28:17,200
call or unregister event that i

793
00:28:17,200 --> 00:28:19,919
basically disable monitoring for that uh

794
00:28:19,919 --> 00:28:22,000
so because the event monitoring has to

795
00:28:22,000 --> 00:28:23,200
be done together and it's done by an

796
00:28:23,200 --> 00:28:25,200
individual endpoint security client

797
00:28:25,200 --> 00:28:27,039
object inside the process there isn't a

798
00:28:27,039 --> 00:28:29,120
way to unregister them from an internal

799
00:28:29,120 --> 00:28:30,960
process unless you hijack it yourself

800
00:28:30,960 --> 00:28:32,640
and then basically destroy the object

801
00:28:32,640 --> 00:28:34,480
and recreate it you can't do it from

802
00:28:34,480 --> 00:28:36,960
external because it's an internal uh

803
00:28:36,960 --> 00:28:39,120
code object all right then the other

804
00:28:39,120 --> 00:28:42,000
question is also solved

805
00:28:43,200 --> 00:28:45,840
are there any other questions

806
00:28:49,520 --> 00:28:51,679
yep we have time for another question

807
00:28:51,679 --> 00:28:53,919
nope

808
00:28:56,080 --> 00:28:58,000
okay

809
00:28:58,000 --> 00:29:02,120
thank you very much thanks for listening

