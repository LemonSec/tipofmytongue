1
00:00:28,540 --> 00:00:31,060
everyone good morning my name is

2
00:00:31,060 --> 00:00:32,200
Cheyenne's Devinder Doshi

3
00:00:32,200 --> 00:00:33,730
I hope everyone is having a great time

4
00:00:33,730 --> 00:00:38,739
here at the conference yeah awesome so

5
00:00:38,739 --> 00:00:41,230
my talk is labeled perfidious make PE

6
00:00:41,230 --> 00:00:42,940
backdooring great again and even though

7
00:00:42,940 --> 00:00:44,380
we will be discussing a technique that

8
00:00:44,380 --> 00:00:45,879
could be used to possibly backdoor PE

9
00:00:45,879 --> 00:00:48,370
files I would like to make sure that you

10
00:00:48,370 --> 00:00:49,600
keep an eye out for the bigger picture

11
00:00:49,600 --> 00:00:50,980
which is the framework and the library

12
00:00:50,980 --> 00:00:54,760
itself right so Who am I my name is

13
00:00:54,760 --> 00:00:56,320
chance David although she I am a cyber

14
00:00:56,320 --> 00:00:58,900
security graduate student at UMD and I'm

15
00:00:58,900 --> 00:01:00,370
a teaching assistant for the reverse

16
00:01:00,370 --> 00:01:02,589
engineering course at UMD I have

17
00:01:02,589 --> 00:01:04,209
previously worked as a male research

18
00:01:04,209 --> 00:01:05,770
internet cidery where I started

19
00:01:05,770 --> 00:01:07,720
developing this project and I like

20
00:01:07,720 --> 00:01:09,400
malware analysis and reverse engineering

21
00:01:09,400 --> 00:01:11,440
so that's enough about me

22
00:01:11,440 --> 00:01:14,680
I like to know something about you so

23
00:01:14,680 --> 00:01:16,240
how many of you all are interested in

24
00:01:16,240 --> 00:01:18,549
reverse engineering malware arises stuff

25
00:01:18,549 --> 00:01:24,280
like that awesome great so before we get

26
00:01:24,280 --> 00:01:26,380
started and do what perfidious is and

27
00:01:26,380 --> 00:01:27,909
what it it is trying to do it is

28
00:01:27,909 --> 00:01:29,590
important to understand the context

29
00:01:29,590 --> 00:01:30,760
under which this entire thing was

30
00:01:30,760 --> 00:01:33,010
developed right so it was summer 2019

31
00:01:33,010 --> 00:01:36,370
May August period I started working at

32
00:01:36,370 --> 00:01:38,620
cyber tea as a mall research intern and

33
00:01:38,620 --> 00:01:41,320
my manager for the budget basically said

34
00:01:41,320 --> 00:01:43,390
ok we want to develop a project that

35
00:01:43,390 --> 00:01:46,300
could be used to develop malicious files

36
00:01:46,300 --> 00:01:49,390
out of benign PE files and you can maybe

37
00:01:49,390 --> 00:01:51,580
pass develop our source for source code

38
00:01:51,580 --> 00:01:53,350
and plug it into a machine learning

39
00:01:53,350 --> 00:01:55,000
system that could automatically generate

40
00:01:55,000 --> 00:01:56,980
malware samples right that was his

41
00:01:56,980 --> 00:01:59,470
initial idea now I had two questions

42
00:01:59,470 --> 00:02:01,540
regarding this is this legal for me to

43
00:02:01,540 --> 00:02:03,220
work on because what I would be

44
00:02:03,220 --> 00:02:04,510
essentially doing is developing

45
00:02:04,510 --> 00:02:06,400
malicious software that could be used to

46
00:02:06,400 --> 00:02:08,019
bypass the endpoint detection systems

47
00:02:08,019 --> 00:02:10,060
that are currently in place right I do

48
00:02:10,060 --> 00:02:12,430
not want to get arrested by the FBI the

49
00:02:12,430 --> 00:02:15,099
second question was that how would I go

50
00:02:15,099 --> 00:02:17,379
about getting the source code for all

51
00:02:17,379 --> 00:02:19,420
these malware samples right because if

52
00:02:19,420 --> 00:02:21,040
you have worked in the field you know

53
00:02:21,040 --> 00:02:22,690
that malware sample malware source code

54
00:02:22,690 --> 00:02:24,220
is something that is really hard to come

55
00:02:24,220 --> 00:02:26,260
by right and you would need enough

56
00:02:26,260 --> 00:02:28,480
source code to be able to even if you

57
00:02:28,480 --> 00:02:30,069
had passes in place right that could

58
00:02:30,069 --> 00:02:32,170
pass all the source code to develop new

59
00:02:32,170 --> 00:02:34,569
malware you would need enough samples

60
00:02:34,569 --> 00:02:35,650
that would train a machine learning

61
00:02:35,650 --> 00:02:38,349
model on it right now as fate would have

62
00:02:38,349 --> 00:02:40,030
it the manager basically left the

63
00:02:40,030 --> 00:02:41,580
company for another company

64
00:02:41,580 --> 00:02:43,200
I was left with the project to whatever

65
00:02:43,200 --> 00:02:45,210
to do whatever I wanted to do with it

66
00:02:45,210 --> 00:02:47,850
right so I had two choices basically I

67
00:02:47,850 --> 00:02:50,070
could idle away my time at Highbury or I

68
00:02:50,070 --> 00:02:52,320
could be develop a project that could be

69
00:02:52,320 --> 00:02:54,840
a logical conclusion to what he started

70
00:02:54,840 --> 00:02:57,000
right so that is where perfidious comes

71
00:02:57,000 --> 00:02:59,340
into picture now before you can get into

72
00:02:59,340 --> 00:03:01,200
perfidious it is important that you

73
00:03:01,200 --> 00:03:02,850
understand what a PE file format looks

74
00:03:02,850 --> 00:03:04,830
like right because that is the input to

75
00:03:04,830 --> 00:03:08,670
perfidious so this is the basic

76
00:03:08,670 --> 00:03:10,860
structure of a B file you have the daus

77
00:03:10,860 --> 00:03:13,140
header followed by the Doster followed

78
00:03:13,140 --> 00:03:15,000
by a rich header which may or may not be

79
00:03:15,000 --> 00:03:17,280
present followed by the PE signature

80
00:03:17,280 --> 00:03:19,830
followed by NT header these together

81
00:03:19,830 --> 00:03:21,930
compose the entire PE header that we

82
00:03:21,930 --> 00:03:24,360
know about this is followed by the

83
00:03:24,360 --> 00:03:26,190
section header and the actual sections

84
00:03:26,190 --> 00:03:30,810
right so before we get into each of

85
00:03:30,810 --> 00:03:33,450
these components of a PE file it is

86
00:03:33,450 --> 00:03:35,010
important to understand what these terms

87
00:03:35,010 --> 00:03:37,350
mean raw address so raw address space as

88
00:03:37,350 --> 00:03:39,090
we know starts at 0 this is basically

89
00:03:39,090 --> 00:03:41,580
the raw file size of the actual PE file

90
00:03:41,580 --> 00:03:44,190
that we have it starts at 0 there's

91
00:03:44,190 --> 00:03:45,600
virtual address virtual address is

92
00:03:45,600 --> 00:03:47,730
basically the address such at which each

93
00:03:47,730 --> 00:03:49,440
of the components in the raw file are

94
00:03:49,440 --> 00:03:51,810
loaded in memory when the file is run so

95
00:03:51,810 --> 00:03:53,519
raw address is usually start at that

96
00:03:53,519 --> 00:03:56,070
height hex number then we have something

97
00:03:56,070 --> 00:03:58,470
called rvs now RVs are important to

98
00:03:58,470 --> 00:04:00,030
understand because RVs are something

99
00:04:00,030 --> 00:04:02,280
that the PE file uses internally to map

100
00:04:02,280 --> 00:04:04,739
addresses right so whenever we have an

101
00:04:04,739 --> 00:04:07,140
RV a present inside the PE file we need

102
00:04:07,140 --> 00:04:09,120
to convert it into a raw address to find

103
00:04:09,120 --> 00:04:10,950
that data structure on the file itself

104
00:04:10,950 --> 00:04:13,320
right so this is the formula that we

105
00:04:13,320 --> 00:04:14,890
utilize

106
00:04:14,890 --> 00:04:18,519
now the first data structure present

107
00:04:18,519 --> 00:04:19,988
inside a PE file is the daus header

108
00:04:19,988 --> 00:04:22,180
right daus header contains a ton of

109
00:04:22,180 --> 00:04:26,590
different internal components the the

110
00:04:26,590 --> 00:04:29,440
main ones are highlighted in yellow G

111
00:04:29,440 --> 00:04:31,450
magic is the MC signature that we see at

112
00:04:31,450 --> 00:04:33,400
the beginning of any PE file right this

113
00:04:33,400 --> 00:04:35,530
basically identifies that this file is a

114
00:04:35,530 --> 00:04:37,780
PE file and it can run with the help of

115
00:04:37,780 --> 00:04:39,250
Windows loader right

116
00:04:39,250 --> 00:04:40,960
checksum checksum is basically the

117
00:04:40,960 --> 00:04:42,250
checksum of the PE file

118
00:04:42,250 --> 00:04:44,950
this helps us this is basically one of

119
00:04:44,950 --> 00:04:46,480
the first checks that you need to make

120
00:04:46,480 --> 00:04:48,730
sure that the checksum of the PE file is

121
00:04:48,730 --> 00:04:50,800
same as the checksum mentioned in this

122
00:04:50,800 --> 00:04:53,020
particular field that basically tells

123
00:04:53,020 --> 00:04:54,520
you that this file has not been tampered

124
00:04:54,520 --> 00:04:54,940
with

125
00:04:54,940 --> 00:04:58,240
right the e.l.f knew basically tells us

126
00:04:58,240 --> 00:05:00,160
the offset to the extended header header

127
00:05:00,160 --> 00:05:02,080
which is where the actual PE file begins

128
00:05:02,080 --> 00:05:05,980
from dosa or how many of you all have

129
00:05:05,980 --> 00:05:08,200
participated in in any of the flareon

130
00:05:08,200 --> 00:05:11,599
challenges by fire

131
00:05:11,599 --> 00:05:13,879
so they they're basically the reverse

132
00:05:13,879 --> 00:05:16,099
engineering Olympics you can say they

133
00:05:16,099 --> 00:05:17,419
are some of the reverse engineering

134
00:05:17,419 --> 00:05:19,069
challenges that fireEye puts out every

135
00:05:19,069 --> 00:05:20,990
year in 2016 they put out a challenge

136
00:05:20,990 --> 00:05:23,689
which was basically a DOS file that was

137
00:05:23,689 --> 00:05:26,419
that basically said so once you

138
00:05:26,419 --> 00:05:27,860
completed the reverse engineering

139
00:05:27,860 --> 00:05:29,569
challenge when you executed the file it

140
00:05:29,569 --> 00:05:32,419
basically said that this file cannot not

141
00:05:32,419 --> 00:05:34,459
be run in DOS mode right so done

142
00:05:34,459 --> 00:05:36,319
basically a DOS program which was

143
00:05:36,319 --> 00:05:38,629
present inside this das stuff so da sub

144
00:05:38,629 --> 00:05:40,520
can contain an entire DOS program hidden

145
00:05:40,520 --> 00:05:42,889
inside it or it can contain a program

146
00:05:42,889 --> 00:05:45,020
which runs and says ok this program

147
00:05:45,020 --> 00:05:46,789
cannot be run in DOS mode when you try

148
00:05:46,789 --> 00:05:50,149
to execute it in DOS mode right rich

149
00:05:50,149 --> 00:05:52,309
header now rich header was previously

150
00:05:52,309 --> 00:05:53,629
unknown data structure that was

151
00:05:53,629 --> 00:05:56,270
discovered around 2015-2016 timeframe

152
00:05:56,270 --> 00:05:58,909
this was previously used by Microsoft in

153
00:05:58,909 --> 00:06:01,580
order to find various malware groups

154
00:06:01,580 --> 00:06:03,979
that were utilizing because this data

155
00:06:03,979 --> 00:06:05,619
structure contains information about the

156
00:06:05,619 --> 00:06:07,610
compilers and the linkers that were used

157
00:06:07,610 --> 00:06:10,039
to create the p5 right so this could be

158
00:06:10,039 --> 00:06:11,509
used as a mechanism to develop

159
00:06:11,509 --> 00:06:13,519
signatures for various malware groups

160
00:06:13,519 --> 00:06:15,580
that were writing malware samples right

161
00:06:15,580 --> 00:06:19,189
so this is another important data

162
00:06:19,189 --> 00:06:21,110
structure that one needs to make sure to

163
00:06:21,110 --> 00:06:23,659
keep in mind P signature this is the PE

164
00:06:23,659 --> 00:06:26,240
followed by NAR null this is the place

165
00:06:26,240 --> 00:06:28,309
where the actual PE file should ideally

166
00:06:28,309 --> 00:06:30,319
begin from like the data structures

167
00:06:30,319 --> 00:06:32,449
present previously are basically used

168
00:06:32,449 --> 00:06:34,249
for backward compatibility reasons right

169
00:06:34,249 --> 00:06:35,809
we don't really need those data

170
00:06:35,809 --> 00:06:37,410
structures

171
00:06:37,410 --> 00:06:39,270
this is followed by the NT header which

172
00:06:39,270 --> 00:06:40,950
is composed of the file header and the

173
00:06:40,950 --> 00:06:43,020
optional header which links to the data

174
00:06:43,020 --> 00:06:45,810
directories now file header how many of

175
00:06:45,810 --> 00:06:51,020
you all know what uwp means yes

176
00:06:52,849 --> 00:06:56,939
platform yeah so why do we have uwv like

177
00:06:56,939 --> 00:06:59,309
why does Microsoft need UWB what is the

178
00:06:59,309 --> 00:07:03,169
agenda for having UWB in place

179
00:07:08,810 --> 00:07:11,610
exactly exactly

180
00:07:11,610 --> 00:07:13,620
so what Microsoft is ideally trying to

181
00:07:13,620 --> 00:07:15,840
do is have a single file format for each

182
00:07:15,840 --> 00:07:17,490
of the various applications that can run

183
00:07:17,490 --> 00:07:19,890
on every device that they have so they

184
00:07:19,890 --> 00:07:21,780
are trying to have some sort of

185
00:07:21,780 --> 00:07:23,160
uniformity throughout the various

186
00:07:23,160 --> 00:07:25,680
devices that they can support on their

187
00:07:25,680 --> 00:07:28,140
operating system right so for in order

188
00:07:28,140 --> 00:07:30,560
to do that the files need to have enough

189
00:07:30,560 --> 00:07:32,790
fields and enough information in place

190
00:07:32,790 --> 00:07:34,620
that can help the programs run on

191
00:07:34,620 --> 00:07:36,390
various Windows loaders that exist on

192
00:07:36,390 --> 00:07:38,670
those platforms right so file header

193
00:07:38,670 --> 00:07:40,200
basically contains the information about

194
00:07:40,200 --> 00:07:42,300
all those things it contains the machine

195
00:07:42,300 --> 00:07:44,610
code basically switch says that okay

196
00:07:44,610 --> 00:07:46,140
this is the architecture on which this

197
00:07:46,140 --> 00:07:47,940
particular file is supposed to run on it

198
00:07:47,940 --> 00:07:49,860
has the number of sections that it

199
00:07:49,860 --> 00:07:52,320
contains the time date data at the time

200
00:07:52,320 --> 00:07:54,210
date Sam anyone know what that time

201
00:07:54,210 --> 00:07:56,530
means

202
00:07:56,530 --> 00:08:00,010
January 1st 1970 why is that time like

203
00:08:00,010 --> 00:08:03,480
why that specific time

204
00:08:05,210 --> 00:08:08,370
so that basic day that that date that

205
00:08:08,370 --> 00:08:10,410
time SAP is basically called the epoch

206
00:08:10,410 --> 00:08:12,240
time right that is considered as the

207
00:08:12,240 --> 00:08:14,670
beginning of time so that particular

208
00:08:14,670 --> 00:08:16,710
field calculates the time date Delta

209
00:08:16,710 --> 00:08:18,210
between when the program was actually

210
00:08:18,210 --> 00:08:22,140
compiled with that - the that particular

211
00:08:22,140 --> 00:08:24,240
time they are time Sam and the time date

212
00:08:24,240 --> 00:08:26,700
Delta that you get is basically stored

213
00:08:26,700 --> 00:08:28,620
in that particular time dates and field

214
00:08:28,620 --> 00:08:30,570
so you can use that field in order to

215
00:08:30,570 --> 00:08:31,920
find when this particular program was

216
00:08:31,920 --> 00:08:35,640
compiled right now all the other data

217
00:08:35,640 --> 00:08:37,890
structures after that contain

218
00:08:37,890 --> 00:08:40,260
information that is important as well

219
00:08:40,260 --> 00:08:42,419
another important field is

220
00:08:42,419 --> 00:08:44,130
characteristics right characteristics

221
00:08:44,130 --> 00:08:45,690
basically gives you information about

222
00:08:45,690 --> 00:08:48,480
what kind of file this actually is vet

223
00:08:48,480 --> 00:08:50,880
whether it's a DLL it's an exe what kind

224
00:08:50,880 --> 00:08:52,800
of permissions this file has and stuff

225
00:08:52,800 --> 00:08:55,740
like that next we have optional header

226
00:08:55,740 --> 00:08:57,120
even though it says that it's an

227
00:08:57,120 --> 00:08:58,620
optional header it's not really optional

228
00:08:58,620 --> 00:09:01,380
it contains information about the base

229
00:09:01,380 --> 00:09:03,120
of code base of code basically tells you

230
00:09:03,120 --> 00:09:06,030
at what point inside the PE file the

231
00:09:06,030 --> 00:09:07,980
text section begins right X section is

232
00:09:07,980 --> 00:09:10,260
the place where the actual code for that

233
00:09:10,260 --> 00:09:12,690
particular program is stored right the

234
00:09:12,690 --> 00:09:14,190
image base basically tells you which

235
00:09:14,190 --> 00:09:17,280
virtual address is used in order to load

236
00:09:17,280 --> 00:09:18,810
this particular program into memory

237
00:09:18,810 --> 00:09:21,030
right so even though it says that it's

238
00:09:21,030 --> 00:09:22,230
an optional header it is not really

239
00:09:22,230 --> 00:09:24,510
optional now once this optional header

240
00:09:24,510 --> 00:09:26,340
is completed it's followed by the data

241
00:09:26,340 --> 00:09:28,830
directory stable data directory stable

242
00:09:28,830 --> 00:09:30,510
basically contains information about the

243
00:09:30,510 --> 00:09:32,790
size of the data decrees and the raw

244
00:09:32,790 --> 00:09:34,590
virtual address at which this particular

245
00:09:34,590 --> 00:09:37,590
data directory is loaded right these are

246
00:09:37,590 --> 00:09:39,570
some of the data directories that are

247
00:09:39,570 --> 00:09:42,720
common commonly found inside PD files

248
00:09:42,720 --> 00:09:44,700
not all of these data directories will

249
00:09:44,700 --> 00:09:47,280
be contained inside a B file but some of

250
00:09:47,280 --> 00:09:49,560
the common ones which I will explain are

251
00:09:49,560 --> 00:09:51,720
the ones that are usually found inside

252
00:09:51,720 --> 00:09:54,600
all these PE files right export table

253
00:09:54,600 --> 00:09:56,970
can anyone of you tell me what an export

254
00:09:56,970 --> 00:09:58,740
table means why would you have an export

255
00:09:58,740 --> 00:10:01,500
table inside a PE file what could it

256
00:10:01,500 --> 00:10:03,950
contain

257
00:10:05,020 --> 00:10:07,650
anyone

258
00:10:08,800 --> 00:10:11,529
so as the name suggests exportable

259
00:10:11,529 --> 00:10:12,999
basically contains information about the

260
00:10:12,999 --> 00:10:14,889
functions that are exported by this

261
00:10:14,889 --> 00:10:17,589
particular PE file right now PE files

262
00:10:17,589 --> 00:10:20,290
not necessarily are executables right

263
00:10:20,290 --> 00:10:22,540
they can also be dll's dll's are

264
00:10:22,540 --> 00:10:24,249
basically dynamically loaded library

265
00:10:24,249 --> 00:10:26,230
length libraries right now dll is

266
00:10:26,230 --> 00:10:27,819
basically contain information about the

267
00:10:27,819 --> 00:10:30,040
functions that it exports so this table

268
00:10:30,040 --> 00:10:31,660
can be used as a reference to find all

269
00:10:31,660 --> 00:10:33,160
those functions and the ad and the

270
00:10:33,160 --> 00:10:35,110
addresses inside the dns where these

271
00:10:35,110 --> 00:10:38,319
functions are stored right then we have

272
00:10:38,319 --> 00:10:40,179
the import table import ables are

273
00:10:40,179 --> 00:10:42,790
usually present inside the PE files data

274
00:10:42,790 --> 00:10:45,189
exe is these these basically give you

275
00:10:45,189 --> 00:10:46,689
information about all the functions that

276
00:10:46,689 --> 00:10:48,579
are imported by that exe from the

277
00:10:48,579 --> 00:10:50,920
various dll and the addresses at which

278
00:10:50,920 --> 00:10:53,170
these functions can be found there are

279
00:10:53,170 --> 00:10:55,149
multiple sub data structures as well

280
00:10:55,149 --> 00:10:57,639
found inside for for the import tables

281
00:10:57,639 --> 00:11:00,610
will not go into that resource table why

282
00:11:00,610 --> 00:11:03,040
would you need a resource table inside

283
00:11:03,040 --> 00:11:06,309
the exe inside any PD file why would you

284
00:11:06,309 --> 00:11:09,399
need a resource table now when we

285
00:11:09,399 --> 00:11:11,679
usually think about programs they need

286
00:11:11,679 --> 00:11:14,170
not always be a CLI program right they

287
00:11:14,170 --> 00:11:15,970
can be GUI programs as well like games

288
00:11:15,970 --> 00:11:17,769
right you'll have a ton of different

289
00:11:17,769 --> 00:11:21,129
resources like images song files icons

290
00:11:21,129 --> 00:11:23,499
stuff like that right you need to have a

291
00:11:23,499 --> 00:11:25,540
resource table that can be used in order

292
00:11:25,540 --> 00:11:28,600
to index those resources right so that

293
00:11:28,600 --> 00:11:30,459
the program when it runs it can find

294
00:11:30,459 --> 00:11:32,439
find those resources add those memory

295
00:11:32,439 --> 00:11:34,420
addresses resource table contains all

296
00:11:34,420 --> 00:11:36,369
that information exception table

297
00:11:36,369 --> 00:11:38,139
exception table contains information

298
00:11:38,139 --> 00:11:40,209
about the various exceptional exception

299
00:11:40,209 --> 00:11:41,949
handlers that are present inside the P

300
00:11:41,949 --> 00:11:43,660
if I write whenever an exception is

301
00:11:43,660 --> 00:11:45,249
triggered it goes through this exception

302
00:11:45,249 --> 00:11:47,889
table find out what function it needs to

303
00:11:47,889 --> 00:11:49,689
execute for that particular exception

304
00:11:49,689 --> 00:11:52,839
trigger and it executes that certificate

305
00:11:52,839 --> 00:11:55,360
table certificate table contains

306
00:11:55,360 --> 00:11:56,860
information about the certificate that I

307
00:11:56,860 --> 00:11:59,619
that is used to sign this p5 right so

308
00:11:59,619 --> 00:12:02,290
say you had Microsoft certificates lying

309
00:12:02,290 --> 00:12:03,999
around right you could cite in your own

310
00:12:03,999 --> 00:12:05,529
executables with those Microsoft

311
00:12:05,529 --> 00:12:07,480
certificates and your certificate table

312
00:12:07,480 --> 00:12:08,980
would contain the Microsoft certificates

313
00:12:08,980 --> 00:12:11,230
right then when you run those on Windows

314
00:12:11,230 --> 00:12:14,169
you'd never encounter the yellow box

315
00:12:14,169 --> 00:12:15,730
that you get when you try to run files

316
00:12:15,730 --> 00:12:17,110
that are not signed by Microsoft right

317
00:12:17,110 --> 00:12:19,209
yeah like this program has not been

318
00:12:19,209 --> 00:12:20,370
signed by Michael

319
00:12:20,370 --> 00:12:22,620
that is basically how you can bypass the

320
00:12:22,620 --> 00:12:24,900
certificate table check debug table

321
00:12:24,900 --> 00:12:26,550
debug table is usually stripped inside

322
00:12:26,550 --> 00:12:30,840
most professionally put out PE files

323
00:12:30,840 --> 00:12:32,910
basically this contains all the debug

324
00:12:32,910 --> 00:12:34,470
information like all the debuff flags

325
00:12:34,470 --> 00:12:36,540
all the breakpoints that were used when

326
00:12:36,540 --> 00:12:38,430
it were when you were debugging the PE

327
00:12:38,430 --> 00:12:41,880
file TLS saver can anyone of you tell me

328
00:12:41,880 --> 00:12:44,880
what TLS table means what it could have

329
00:12:44,880 --> 00:12:47,750
what TLS means

330
00:12:48,200 --> 00:12:52,029
what is TLS in this context

331
00:12:52,930 --> 00:12:55,160
it's not networks

332
00:12:55,160 --> 00:12:58,600
so what does TLS mean

333
00:13:01,760 --> 00:13:04,430
anyone

334
00:13:04,430 --> 00:13:06,489
you

335
00:13:07,130 --> 00:13:09,260
so TL is basically stands for

336
00:13:09,260 --> 00:13:11,720
thread-local storage hey most operating

337
00:13:11,720 --> 00:13:13,960
systems that we have today are

338
00:13:13,960 --> 00:13:15,860
multi-threaded operating systems right

339
00:13:15,860 --> 00:13:17,900
programs use this multi-threaded

340
00:13:17,900 --> 00:13:19,910
capabilities to TLS evil basically

341
00:13:19,910 --> 00:13:21,590
stores information about various

342
00:13:21,590 --> 00:13:23,510
variables inside various threads inside

343
00:13:23,510 --> 00:13:25,610
your program right this differentiation

344
00:13:25,610 --> 00:13:27,950
is important because otherwise we could

345
00:13:27,950 --> 00:13:29,810
not have that multi storage capability

346
00:13:29,810 --> 00:13:31,610
where same area bill is used for

347
00:13:31,610 --> 00:13:33,350
multiple threads right that all that

348
00:13:33,350 --> 00:13:34,910
information is stored inside the TLS

349
00:13:34,910 --> 00:13:37,310
table import address table is basically

350
00:13:37,310 --> 00:13:38,930
same as the import table until it is

351
00:13:38,930 --> 00:13:41,000
loaded in memory at which point the

352
00:13:41,000 --> 00:13:43,280
addresses are replaced by the actual

353
00:13:43,280 --> 00:13:46,520
addresses in memory now this is followed

354
00:13:46,520 --> 00:13:48,410
by the section header section header

355
00:13:48,410 --> 00:13:50,870
contains information about the section

356
00:13:50,870 --> 00:13:53,450
itself that the data present after it it

357
00:13:53,450 --> 00:13:54,950
contains the name the virtual address

358
00:13:54,950 --> 00:13:57,200
the size of the raw data pointer to that

359
00:13:57,200 --> 00:14:00,170
raw data and the characteristics now can

360
00:14:00,170 --> 00:14:02,360
anyone tell me why characteristics are

361
00:14:02,360 --> 00:14:04,310
important for various sections inside PE

362
00:14:04,310 --> 00:14:07,160
file for those of you who have worked

363
00:14:07,160 --> 00:14:09,260
with PE file why do you need

364
00:14:09,260 --> 00:14:10,850
characteristics for each of these

365
00:14:10,850 --> 00:14:12,890
sections it's just a stream of bytes

366
00:14:12,890 --> 00:14:14,570
right why do you need characteristics

367
00:14:14,570 --> 00:14:19,700
yes exactly so depending on which

368
00:14:19,700 --> 00:14:21,650
section is present inside the PE file

369
00:14:21,650 --> 00:14:23,210
each of these sections have their own

370
00:14:23,210 --> 00:14:25,040
permissions right not all these sections

371
00:14:25,040 --> 00:14:26,690
present inside PE files have execute

372
00:14:26,690 --> 00:14:28,670
permissions only the text section can be

373
00:14:28,670 --> 00:14:30,980
executable but the text section cannot

374
00:14:30,980 --> 00:14:33,260
be reliable right because you don't want

375
00:14:33,260 --> 00:14:34,790
your text section to be replaced by

376
00:14:34,790 --> 00:14:37,340
another text section right so that is

377
00:14:37,340 --> 00:14:38,870
why you need characteristics which can

378
00:14:38,870 --> 00:14:40,670
highlight what kind of permissions are

379
00:14:40,670 --> 00:14:42,040
contained for that particular section

380
00:14:42,040 --> 00:14:44,660
now the current code injection

381
00:14:44,660 --> 00:14:47,630
techniques that we have one of the most

382
00:14:47,630 --> 00:14:49,490
common ones has custom section edition

383
00:14:49,490 --> 00:14:51,650
right this is something that if any one

384
00:14:51,650 --> 00:14:54,200
of you have gone through YC this is one

385
00:14:54,200 --> 00:14:55,580
of the techniques that is discussed in

386
00:14:55,580 --> 00:14:56,210
that course

387
00:14:56,210 --> 00:14:58,850
so you basically add a section at the

388
00:14:58,850 --> 00:15:01,790
end of the B file you create an entry

389
00:15:01,790 --> 00:15:03,650
inside the section header for that new

390
00:15:03,650 --> 00:15:05,600
section and you give it D right you read

391
00:15:05,600 --> 00:15:07,310
write execute permissions right or

392
00:15:07,310 --> 00:15:08,720
whatever permissions that you want to

393
00:15:08,720 --> 00:15:10,370
give and then you basically change the

394
00:15:10,370 --> 00:15:13,760
entry point of the PE file to point to

395
00:15:13,760 --> 00:15:15,770
that new section what this does is

396
00:15:15,770 --> 00:15:17,630
instead of executing the text section

397
00:15:17,630 --> 00:15:20,270
when you try to run this program it will

398
00:15:20,270 --> 00:15:20,950
execute the

399
00:15:20,950 --> 00:15:23,650
section that you added at the end now

400
00:15:23,650 --> 00:15:25,990
the disadvantages of this approach are

401
00:15:25,990 --> 00:15:28,240
basically it is very easy to detect by

402
00:15:28,240 --> 00:15:30,190
most end point detection systems right

403
00:15:30,190 --> 00:15:33,970
because not in most P files only that X

404
00:15:33,970 --> 00:15:35,380
section is the section that contains

405
00:15:35,380 --> 00:15:38,110
execute permissions so the enjoined

406
00:15:38,110 --> 00:15:39,790
detection system can basically just

407
00:15:39,790 --> 00:15:41,640
check for these actions that have

408
00:15:41,640 --> 00:15:44,170
execute permissions and it can say okay

409
00:15:44,170 --> 00:15:46,000
this section is something weird I

410
00:15:46,000 --> 00:15:48,160
basically want to flag this P if I write

411
00:15:48,160 --> 00:15:49,960
to the cell gain versus the time

412
00:15:49,960 --> 00:15:52,570
required to correctly implement this

413
00:15:52,570 --> 00:15:56,920
thing is way too low right so what is

414
00:15:56,920 --> 00:15:59,080
the other approach you can take P code

415
00:15:59,080 --> 00:16:00,700
giving can anyone of you tell me what a

416
00:16:00,700 --> 00:16:03,360
code cave is

417
00:16:04,380 --> 00:16:07,170
what does it mean to be a code cave like

418
00:16:07,170 --> 00:16:09,450
what what could a code cave be what do

419
00:16:09,450 --> 00:16:12,500
you understand by that word

420
00:16:13,180 --> 00:16:16,030
so P files are basically stream of bytes

421
00:16:16,030 --> 00:16:18,670
right not all those bytes are filled

422
00:16:18,670 --> 00:16:21,040
with information that is important for

423
00:16:21,040 --> 00:16:22,750
that file to run right there will be a

424
00:16:22,750 --> 00:16:24,190
stream of nulls that are present inside

425
00:16:24,190 --> 00:16:26,350
various locations inside P if I like

426
00:16:26,350 --> 00:16:29,200
those nulls might not be utilized those

427
00:16:29,200 --> 00:16:31,420
are called eco deicide and that can be

428
00:16:31,420 --> 00:16:32,950
used in order to fill your malicious

429
00:16:32,950 --> 00:16:35,920
code inside right so how P code k works

430
00:16:35,920 --> 00:16:37,630
is you basically find the code keys that

431
00:16:37,630 --> 00:16:40,870
exist inside the p5 you try to find

432
00:16:40,870 --> 00:16:43,000
those 4 KS that exists inside sections

433
00:16:43,000 --> 00:16:44,410
with execute permissions that is

434
00:16:44,410 --> 00:16:46,660
basically the tag section if you find

435
00:16:46,660 --> 00:16:48,640
such a for km you replace the nulls with

436
00:16:48,640 --> 00:16:50,410
the malicious code and then you change

437
00:16:50,410 --> 00:16:52,150
the entry point address of the entry

438
00:16:52,150 --> 00:16:53,830
point to point to your new shell code

439
00:16:53,830 --> 00:16:56,260
that you've injected right that is how P

440
00:16:56,260 --> 00:16:58,840
P code caving works can anyone of you

441
00:16:58,840 --> 00:17:00,010
tell me what is the problem with that

442
00:17:00,010 --> 00:17:02,680
approach like what could be the problem

443
00:17:02,680 --> 00:17:04,119
that you could face when you try to

444
00:17:04,119 --> 00:17:06,280
inject malicious code inside te code

445
00:17:06,280 --> 00:17:08,520
caves

446
00:17:14,339 --> 00:17:18,939
not really what what could be what are

447
00:17:18,939 --> 00:17:20,679
some of the limitations of trying to

448
00:17:20,679 --> 00:17:24,150
inject core using this technique

449
00:17:24,150 --> 00:17:26,210
you

450
00:17:27,069 --> 00:17:31,060
not a real function so when you talk

451
00:17:31,060 --> 00:17:33,430
about core caves there is a limitation

452
00:17:33,430 --> 00:17:35,380
of size that is present for the code

453
00:17:35,380 --> 00:17:37,480
caves that you have right first you need

454
00:17:37,480 --> 00:17:39,400
to find code caves inside the PE file

455
00:17:39,400 --> 00:17:41,590
say you were able to find those code

456
00:17:41,590 --> 00:17:43,780
caves then you want to find a code cave

457
00:17:43,780 --> 00:17:45,100
that is large enough to store your

458
00:17:45,100 --> 00:17:48,040
shellcode then you need that code cave

459
00:17:48,040 --> 00:17:49,810
to be present inside the executable

460
00:17:49,810 --> 00:17:52,780
section as well right so this technique

461
00:17:52,780 --> 00:17:56,230
is not really this is not something that

462
00:17:56,230 --> 00:17:58,750
you can execute that is not this is not

463
00:17:58,750 --> 00:18:00,370
something that you can do for each and

464
00:18:00,370 --> 00:18:02,500
every PE file that you have right this

465
00:18:02,500 --> 00:18:04,870
is so that these are some of the

466
00:18:04,870 --> 00:18:07,870
disadvantages of this approach right you

467
00:18:07,870 --> 00:18:09,670
need to be able to find for caves inside

468
00:18:09,670 --> 00:18:12,160
the PE file you need to find a code here

469
00:18:12,160 --> 00:18:13,930
that is large enough you need to find a

470
00:18:13,930 --> 00:18:15,550
for cave that is in the executable

471
00:18:15,550 --> 00:18:19,690
section right so why not just edit the

472
00:18:19,690 --> 00:18:22,770
dot text section instead

473
00:18:23,779 --> 00:18:25,789
problems that you face the dot tech

474
00:18:25,789 --> 00:18:28,519
section has the execute permissions that

475
00:18:28,519 --> 00:18:31,639
we need it has all the necessary things

476
00:18:31,639 --> 00:18:37,700
that we require why not just do that say

477
00:18:37,700 --> 00:18:40,989
you were able to edit the checksum

478
00:18:41,050 --> 00:18:43,390
that is one of the disadvantages but see

479
00:18:43,390 --> 00:18:46,170
you could edit edit the checksum

480
00:18:46,170 --> 00:18:48,030
what would be the problems that you

481
00:18:48,030 --> 00:18:50,400
could face when you change the peg

482
00:18:50,400 --> 00:18:54,390
section yes if you say yeah but it's

483
00:18:54,390 --> 00:18:56,820
just a stream of bytes right

484
00:18:56,820 --> 00:18:58,260
so you were able to find it X section

485
00:18:58,260 --> 00:19:00,110
inside the BFI you could basically just

486
00:19:00,110 --> 00:19:07,980
pull it out um exactly that is one of

487
00:19:07,980 --> 00:19:09,210
the reasons why this has been really

488
00:19:09,210 --> 00:19:11,310
difficult to until now right because

489
00:19:11,310 --> 00:19:12,810
when you change the text section text

490
00:19:12,810 --> 00:19:14,670
section is usually the first section

491
00:19:14,670 --> 00:19:16,620
that exists after the section headers

492
00:19:16,620 --> 00:19:18,750
right so when you change that you

493
00:19:18,750 --> 00:19:20,310
basically move everything that comes

494
00:19:20,310 --> 00:19:23,070
after it right so you need to be able to

495
00:19:23,070 --> 00:19:25,170
map everything inside the PE file in

496
00:19:25,170 --> 00:19:26,970
such a way that if you make one change

497
00:19:26,970 --> 00:19:29,100
inside the p5 all those changes are

498
00:19:29,100 --> 00:19:30,510
reflected back into everything that

499
00:19:30,510 --> 00:19:33,120
follows right that is where perfidious

500
00:19:33,120 --> 00:19:35,700
comes into picture right what perfidious

501
00:19:35,700 --> 00:19:37,740
is trying through is for Phidias is

502
00:19:37,740 --> 00:19:39,420
trying to fingerprint the PE file and

503
00:19:39,420 --> 00:19:41,010
convert it into a python-based class

504
00:19:41,010 --> 00:19:43,470
right so each and every data structure

505
00:19:43,470 --> 00:19:45,030
that is present inside the PE file is

506
00:19:45,030 --> 00:19:46,740
mapped into a class structure and

507
00:19:46,740 --> 00:19:48,480
whenever you make a single change inside

508
00:19:48,480 --> 00:19:50,160
any of these structures present inside

509
00:19:50,160 --> 00:19:51,930
that class you basically create

510
00:19:51,930 --> 00:19:54,540
appropriate changes inside for the

511
00:19:54,540 --> 00:19:56,190
sections that are dependent on that as

512
00:19:56,190 --> 00:19:59,010
well right so what you do is you use a

513
00:19:59,010 --> 00:20:00,960
function to directly import malicious

514
00:20:00,960 --> 00:20:03,540
code the perfidious extract the text

515
00:20:03,540 --> 00:20:05,160
section of the PE file and combines it

516
00:20:05,160 --> 00:20:07,380
with be malicious for in such a way that

517
00:20:07,380 --> 00:20:09,570
it changes changes it via the control

518
00:20:09,570 --> 00:20:13,140
flow graph jumps right so this is

519
00:20:13,140 --> 00:20:15,600
basically even more difficult to detect

520
00:20:15,600 --> 00:20:17,580
because now you don't have a single blob

521
00:20:17,580 --> 00:20:19,290
of malicious code present inside your PE

522
00:20:19,290 --> 00:20:21,390
file right you have connected those

523
00:20:21,390 --> 00:20:23,280
individual malicious chunks by jumps

524
00:20:23,280 --> 00:20:26,490
right so you don't have a single blob of

525
00:20:26,490 --> 00:20:28,260
code that can be detected by signature

526
00:20:28,260 --> 00:20:30,690
detection mechanisms right so that is

527
00:20:30,690 --> 00:20:33,270
what perfidious is trying to do now

528
00:20:33,270 --> 00:20:34,710
advantages of this approach it is

529
00:20:34,710 --> 00:20:36,570
relatively difficult to detect it and

530
00:20:36,570 --> 00:20:38,460
detect it statically if it has done

531
00:20:38,460 --> 00:20:40,620
really well and really write write the

532
00:20:40,620 --> 00:20:42,150
malicious code itself is split into

533
00:20:42,150 --> 00:20:43,740
smaller pieces so it is difficult to

534
00:20:43,740 --> 00:20:46,110
detect all the other parts of PD files

535
00:20:46,110 --> 00:20:47,940
are left relatively unchanged right you

536
00:20:47,940 --> 00:20:49,560
are just making changes through the dot

537
00:20:49,560 --> 00:20:52,490
text section and you're performing the

538
00:20:52,490 --> 00:20:56,250
in the individually dependent changes

539
00:20:56,250 --> 00:20:58,320
inside the PE file but not the entire B

540
00:20:58,320 --> 00:21:00,090
file is being changed right so it is

541
00:21:00,090 --> 00:21:02,880
relatively unchanged so these are some

542
00:21:02,880 --> 00:21:05,340
of the advantages of this approach how

543
00:21:05,340 --> 00:21:06,870
would you so how do you go about

544
00:21:06,870 --> 00:21:08,990
preventing such kind of

545
00:21:08,990 --> 00:21:11,720
detection like injection how would you

546
00:21:11,720 --> 00:21:14,640
prevent this kind of injection

547
00:21:14,640 --> 00:21:17,040
what would be the easiest way in which

548
00:21:17,040 --> 00:21:18,630
you could prevent this kind of injection

549
00:21:18,630 --> 00:21:20,790
of PE files on your system like how do

550
00:21:20,790 --> 00:21:24,559
you detect such an injected PE file

551
00:21:26,290 --> 00:21:28,750
so one of the easiest approach would be

552
00:21:28,750 --> 00:21:30,700
to only allow whitelist software on your

553
00:21:30,700 --> 00:21:32,950
network right only allow whitelisted

554
00:21:32,950 --> 00:21:34,900
checked software that has been verified

555
00:21:34,900 --> 00:21:37,000
that ok this software comes from this

556
00:21:37,000 --> 00:21:38,860
particular author on your network that

557
00:21:38,860 --> 00:21:41,380
is the easiest approach to basically

558
00:21:41,380 --> 00:21:43,450
stop malware on your network right but

559
00:21:43,450 --> 00:21:45,070
that is not really feasible for most

560
00:21:45,070 --> 00:21:47,350
enterprise network so the next approach

561
00:21:47,350 --> 00:21:49,930
would be to have dynamic analysis on all

562
00:21:49,930 --> 00:21:51,220
PE files that come through your network

563
00:21:51,220 --> 00:21:54,100
right the addition approach that you can

564
00:21:54,100 --> 00:21:55,870
use to detect because in dynamic

565
00:21:55,870 --> 00:21:57,460
analysis you are basically detecting the

566
00:21:57,460 --> 00:21:59,470
control flow of the program itself right

567
00:21:59,470 --> 00:22:01,060
so if it does something malicious

568
00:22:01,060 --> 00:22:03,400
it can be flag one of the approaches

569
00:22:03,400 --> 00:22:05,740
that the one of the third approaches

570
00:22:05,740 --> 00:22:07,600
that you could use to detect such kind

571
00:22:07,600 --> 00:22:09,910
of index injection is that you can use

572
00:22:09,910 --> 00:22:11,800
something called a graphs hash right

573
00:22:11,800 --> 00:22:13,150
this is something that I came across

574
00:22:13,150 --> 00:22:15,520
while I was in Singapore at hack in the

575
00:22:15,520 --> 00:22:17,740
box so the researchers they basically

576
00:22:17,740 --> 00:22:19,390
suggested developing a hash for the

577
00:22:19,390 --> 00:22:21,520
control flow of the program right inside

578
00:22:21,520 --> 00:22:23,200
in that way basically if the controller

579
00:22:23,200 --> 00:22:25,150
of the program changes the corresponding

580
00:22:25,150 --> 00:22:27,160
hash changes as well right so you can

581
00:22:27,160 --> 00:22:29,230
use that hash to detect basically how

582
00:22:29,230 --> 00:22:31,270
different a particular program is from

583
00:22:31,270 --> 00:22:33,730
another program right so those are some

584
00:22:33,730 --> 00:22:35,320
of the techniques that you can use to

585
00:22:35,320 --> 00:22:39,430
detect such kind of injections now even

586
00:22:39,430 --> 00:22:41,140
though this program is not completely

587
00:22:41,140 --> 00:22:43,990
ready I'll give you a demo of how it

588
00:22:43,990 --> 00:22:46,230
works

589
00:22:46,310 --> 00:22:49,990
so when you

590
00:22:51,160 --> 00:22:52,930
Rick so this is how it works you

591
00:22:52,930 --> 00:22:54,940
basically have the PE class structure

592
00:22:54,940 --> 00:22:58,450
you pass into a one of the PE files that

593
00:22:58,450 --> 00:23:01,120
you have and then when you print that

594
00:23:01,120 --> 00:23:02,620
particular class structure it basically

595
00:23:02,620 --> 00:23:04,000
shows you all the things that it found

596
00:23:04,000 --> 00:23:05,980
inside it it found the daus header it

597
00:23:05,980 --> 00:23:07,000
found the doorstop

598
00:23:07,000 --> 00:23:08,830
yeah it did not find the originator

599
00:23:08,830 --> 00:23:11,790
because it does not exist for this VI so

600
00:23:11,790 --> 00:23:14,710
it creates a P object at that particular

601
00:23:14,710 --> 00:23:20,560
address now if I try to print a

602
00:23:20,560 --> 00:23:24,150
particular data structure this is what

603
00:23:24,150 --> 00:23:37,180
it has for these individual data

604
00:23:37,180 --> 00:23:38,860
structure that is present inside the p5

605
00:23:38,860 --> 00:23:40,750
now can anyone of you tell me why that

606
00:23:40,750 --> 00:23:43,720
could be a useful thing to do why would

607
00:23:43,720 --> 00:23:45,940
you want individual check sums for

608
00:23:45,940 --> 00:23:47,560
various data structures inside the PE

609
00:23:47,560 --> 00:23:55,840
file yeah so basically you could use it

610
00:23:55,840 --> 00:23:59,050
to detect at specific granular level

611
00:23:59,050 --> 00:24:00,700
which part of the PE file has been

612
00:24:00,700 --> 00:24:02,920
changed right you can use this in order

613
00:24:02,920 --> 00:24:04,900
to detect injections in various parts of

614
00:24:04,900 --> 00:24:07,570
the PE file right so this is one of the

615
00:24:07,570 --> 00:24:09,790
things that it can do apart from doing

616
00:24:09,790 --> 00:24:13,210
this so this is the end there's a sort

617
00:24:13,210 --> 00:24:14,770
of the intermediate end goal of this

618
00:24:14,770 --> 00:24:16,750
project right so what I'm doing here is

619
00:24:16,750 --> 00:24:18,520
I am printing the original doorstep

620
00:24:18,520 --> 00:24:20,530
message of this particular PE file and

621
00:24:20,530 --> 00:24:22,420
changing that dot stuff message using

622
00:24:22,420 --> 00:24:24,790
just the equal to sign and placing it

623
00:24:24,790 --> 00:24:27,010
with mrs. Johnson and then I'm printing

624
00:24:27,010 --> 00:24:31,810
it again now if I try to run this this

625
00:24:31,810 --> 00:24:33,850
is what happens right this is the

626
00:24:33,850 --> 00:24:35,830
original message that is present inside

627
00:24:35,830 --> 00:24:37,630
the beef I like any other piece is right

628
00:24:37,630 --> 00:24:39,310
this program cannot be run in DOS mode

629
00:24:39,310 --> 00:24:41,440
but now this message has been changed to

630
00:24:41,440 --> 00:24:44,020
be such thousand in 2019 so this is my

631
00:24:44,020 --> 00:24:46,660
intermediate goal for January February

632
00:24:46,660 --> 00:24:49,960
29th 2020 that I should be able to do

633
00:24:49,960 --> 00:24:51,340
this for each and every data structure

634
00:24:51,340 --> 00:24:52,750
that is present inside the B if I write

635
00:24:52,750 --> 00:24:54,580
say I wanted to change an address to a

636
00:24:54,580 --> 00:24:56,020
particular function inside the import

637
00:24:56,020 --> 00:24:57,580
table I should be able to do that using

638
00:24:57,580 --> 00:24:59,710
just the equal to sign right so what

639
00:24:59,710 --> 00:25:01,810
this does is it gives me accessibility

640
00:25:01,810 --> 00:25:03,580
to every data structure that is present

641
00:25:03,580 --> 00:25:05,530
inside the pe5

642
00:25:05,530 --> 00:25:08,320
the next thing would be to develop a

643
00:25:08,320 --> 00:25:09,760
machine learning algorithm that could

644
00:25:09,760 --> 00:25:11,710
automatically develop class-based

645
00:25:11,710 --> 00:25:13,240
structure for the malware malware

646
00:25:13,240 --> 00:25:15,190
samples that are passing into this

647
00:25:15,190 --> 00:25:17,590
project and then find out okay what

648
00:25:17,590 --> 00:25:19,780
changes I could make in order to make a

649
00:25:19,780 --> 00:25:21,970
particular PFI is undetectable for the

650
00:25:21,970 --> 00:25:23,770
current and burn detection systems right

651
00:25:23,770 --> 00:25:26,169
once our finger didn't read the entire

652
00:25:26,169 --> 00:25:27,700
PE file that would be the next logical

653
00:25:27,700 --> 00:25:30,860
step to go about doing this

654
00:25:30,860 --> 00:25:34,470
so that's it from me thank you any

655
00:25:34,470 --> 00:25:38,179
questions yes

656
00:25:49,950 --> 00:25:53,070
ah so currently this thing is not open

657
00:25:53,070 --> 00:25:54,450
source because I am still trying to do

658
00:25:54,450 --> 00:25:57,270
so around January time I will be open

659
00:25:57,270 --> 00:25:58,530
sourcing this project because that is

660
00:25:58,530 --> 00:25:59,850
when I will have completed the

661
00:25:59,850 --> 00:26:01,980
fingerprinting part of it after that you

662
00:26:01,980 --> 00:26:03,600
could basically help me develop the

663
00:26:03,600 --> 00:26:05,640
machine learning part of things that is

664
00:26:05,640 --> 00:26:07,500
the next phase of this project or you

665
00:26:07,500 --> 00:26:09,900
can basically use it - it's just a

666
00:26:09,900 --> 00:26:11,670
Python library right you could develop

667
00:26:11,670 --> 00:26:13,680
your own detection systems using Python

668
00:26:13,680 --> 00:26:15,750
for it and you could plug it at the end

669
00:26:15,750 --> 00:26:18,600
of your network and basically say okay I

670
00:26:18,600 --> 00:26:20,580
want to detect these kind of injections

671
00:26:20,580 --> 00:26:22,380
into a particular structure inside the

672
00:26:22,380 --> 00:26:25,620
PE file you can use it to develop your

673
00:26:25,620 --> 00:26:28,110
own detections like that like that is

674
00:26:28,110 --> 00:26:31,669
what I have in mind until now

675
00:26:34,730 --> 00:26:37,850
any other questions

676
00:26:37,850 --> 00:26:40,160
awesome thank you for your time I have

677
00:26:40,160 --> 00:26:43,570
bad door and

