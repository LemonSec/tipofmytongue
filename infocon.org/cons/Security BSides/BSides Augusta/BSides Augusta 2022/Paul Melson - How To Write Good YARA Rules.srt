1
00:00:10,920 --> 00:00:13,380
all right hey

2
00:00:13,380 --> 00:00:15,420
all right I see you

3
00:00:15,420 --> 00:00:17,340
see I see we emptied out after the

4
00:00:17,340 --> 00:00:19,680
keynote that's about what I expected but

5
00:00:19,680 --> 00:00:22,920
that I'm going to take on faith then

6
00:00:22,920 --> 00:00:24,480
that everybody who's here in the room

7
00:00:24,480 --> 00:00:27,900
has a distinct interest in getting

8
00:00:27,900 --> 00:00:29,880
better at writing goodyara rules so

9
00:00:29,880 --> 00:00:31,800
we're going to go deep a little bit of

10
00:00:31,800 --> 00:00:33,600
this we're going to go fast but

11
00:00:33,600 --> 00:00:35,219
hopefully this will be fun and useful

12
00:00:35,219 --> 00:00:37,320
for those of you that are interested in

13
00:00:37,320 --> 00:00:39,840
in the topic of writing good Yara rules

14
00:00:39,840 --> 00:00:41,940
emphasis on good

15
00:00:41,940 --> 00:00:44,160
um the original title of this talk was

16
00:00:44,160 --> 00:00:46,020
the Derek Zoolander Center for analysts

17
00:00:46,020 --> 00:00:48,960
who can't write rules so good but they

18
00:00:48,960 --> 00:00:50,460
told me that's too long for the bulletin

19
00:00:50,460 --> 00:00:52,680
and no one would get the joke apparently

20
00:00:52,680 --> 00:00:54,239
they were right that's fine

21
00:00:54,239 --> 00:00:55,140
um

22
00:00:55,140 --> 00:00:57,719
so for those of you that are interested

23
00:00:57,719 --> 00:01:01,440
in playing along and want to do uh Yara

24
00:01:01,440 --> 00:01:03,840
things while we do Yara things uh

25
00:01:03,840 --> 00:01:06,240
there's a GitHub repo out there I just

26
00:01:06,240 --> 00:01:07,799
put it up this morning

27
00:01:07,799 --> 00:01:09,659
um so go out to P melison besides

28
00:01:09,659 --> 00:01:11,700
Augusta 2022

29
00:01:11,700 --> 00:01:12,900
um hey you can go ahead and clone that

30
00:01:12,900 --> 00:01:16,439
repo it has a bunch of sample rules that

31
00:01:16,439 --> 00:01:18,240
I'm going to be going through in the

32
00:01:18,240 --> 00:01:21,420
talk there's also a file out there a

33
00:01:21,420 --> 00:01:23,580
7-Zip file with a password if you've

34
00:01:23,580 --> 00:01:24,900
been doing this for a minute and you

35
00:01:24,900 --> 00:01:26,939
know the password then you also

36
00:01:26,939 --> 00:01:28,320
understand the value of that proceed

37
00:01:28,320 --> 00:01:30,600
with caution sign I'm not going to

38
00:01:30,600 --> 00:01:32,939
publicly admit to violating any GitHub

39
00:01:32,939 --> 00:01:34,619
terms of service it'll be up to them to

40
00:01:34,619 --> 00:01:36,840
figure out what's in that file

41
00:01:36,840 --> 00:01:37,920
um

42
00:01:37,920 --> 00:01:40,320
but we might talk about it at the end so

43
00:01:40,320 --> 00:01:41,700
that's the other thing by the way stick

44
00:01:41,700 --> 00:01:44,100
around because I think the best part is

45
00:01:44,100 --> 00:01:46,500
the live demo at the end uh where you're

46
00:01:46,500 --> 00:01:48,600
going to help me write a Yara rule for

47
00:01:48,600 --> 00:01:51,000
malware that's never been seen before so

48
00:01:51,000 --> 00:01:53,220
but first a little bit of grounding

49
00:01:53,220 --> 00:01:55,619
um so uh what's Yara Yara is an open

50
00:01:55,619 --> 00:01:57,659
source uh tool developed by virustotal

51
00:01:57,659 --> 00:01:59,280
they call it the pattern matching Swiss

52
00:01:59,280 --> 00:02:01,740
army knife but what it really is is a

53
00:02:01,740 --> 00:02:04,619
rule engine uh that provides a human

54
00:02:04,619 --> 00:02:07,140
readable like rule language a mnemonic

55
00:02:07,140 --> 00:02:09,720
rule language uh and it can and it

56
00:02:09,720 --> 00:02:11,220
supports sort of three key

57
00:02:11,220 --> 00:02:13,260
characteristics so user-defined patterns

58
00:02:13,260 --> 00:02:15,239
uh strings bytes regex we'll get into

59
00:02:15,239 --> 00:02:17,640
all of that in a little bit uh parsers

60
00:02:17,640 --> 00:02:19,260
they call them modules but what they

61
00:02:19,260 --> 00:02:22,379
really are is file parsers that give you

62
00:02:22,379 --> 00:02:24,360
um you know sort of direct shortcuts to

63
00:02:24,360 --> 00:02:25,739
be able to interact with particular

64
00:02:25,739 --> 00:02:27,840
types of files and file types and we'll

65
00:02:27,840 --> 00:02:29,400
play with some of those later and then a

66
00:02:29,400 --> 00:02:31,020
Boolean logic engine and that's really

67
00:02:31,020 --> 00:02:33,840
the Magic in this right um it's like

68
00:02:33,840 --> 00:02:36,420
grepanoc on steroids because you can do

69
00:02:36,420 --> 00:02:38,760
kind of all the things with that logic

70
00:02:38,760 --> 00:02:40,260
engine and some of the things that they

71
00:02:40,260 --> 00:02:42,420
expose in the in the conditional part of

72
00:02:42,420 --> 00:02:43,440
the rule

73
00:02:43,440 --> 00:02:46,440
um so let's ground a little bit on Yara

74
00:02:46,440 --> 00:02:49,019
syntax so this is an example rule this

75
00:02:49,019 --> 00:02:50,640
rule doesn't really do anything I wrote

76
00:02:50,640 --> 00:02:52,080
it specifically so that we could talk

77
00:02:52,080 --> 00:02:54,060
about rule structure

78
00:02:54,060 --> 00:02:56,940
so you'll notice the all rules begin

79
00:02:56,940 --> 00:02:59,819
with the verb Rule and then the name of

80
00:02:59,819 --> 00:03:01,379
the rule that's how you declare a rule

81
00:03:01,379 --> 00:03:03,720
and then open curly brace and everything

82
00:03:03,720 --> 00:03:05,580
that happens next is the rule until the

83
00:03:05,580 --> 00:03:07,319
following closed curly brace right

84
00:03:07,319 --> 00:03:09,480
fairly simple kind of straightforward

85
00:03:09,480 --> 00:03:11,940
markup and then there are sort of three

86
00:03:11,940 --> 00:03:14,879
sections meta is a is a section where

87
00:03:14,879 --> 00:03:17,040
you put your metadata fairly simple it's

88
00:03:17,040 --> 00:03:20,640
a key value kind of thing right so on

89
00:03:20,640 --> 00:03:22,920
the left is your key name equal sign and

90
00:03:22,920 --> 00:03:24,480
then whatever's in the double quotes is

91
00:03:24,480 --> 00:03:26,159
your value input or whatever you want in

92
00:03:26,159 --> 00:03:28,319
there this is completely free form but

93
00:03:28,319 --> 00:03:29,519
there are some things to think about

94
00:03:29,519 --> 00:03:31,920
when you're writing rules that you

95
00:03:31,920 --> 00:03:33,540
should consider

96
00:03:33,540 --> 00:03:36,959
um so uh does anybody have a thought as

97
00:03:36,959 --> 00:03:40,379
to what the most important field in The

98
00:03:40,379 --> 00:03:42,720
Meta section is

99
00:03:42,720 --> 00:03:44,400
I'll give you a hint it's not the first

100
00:03:44,400 --> 00:03:46,640
one

101
00:03:47,459 --> 00:03:49,680
ooh hash is a hash is a good one I like

102
00:03:49,680 --> 00:03:51,120
people that put hashes in their meta

103
00:03:51,120 --> 00:03:52,980
field but that's not it

104
00:03:52,980 --> 00:03:55,860
description right absolutely what does

105
00:03:55,860 --> 00:04:00,620
this do the second most important field

106
00:04:01,080 --> 00:04:04,680
nope not author not hash date exactly

107
00:04:04,680 --> 00:04:06,659
when did you do this what are you trying

108
00:04:06,659 --> 00:04:08,159
to do and when did you do this because

109
00:04:08,159 --> 00:04:10,140
the difference between if I'm looking

110
00:04:10,140 --> 00:04:12,599
for Yara rules to help me detect a

111
00:04:12,599 --> 00:04:15,239
particular piece of malware a rule that

112
00:04:15,239 --> 00:04:17,880
was written two months ago is different

113
00:04:17,880 --> 00:04:19,918
than a rule that was written six years

114
00:04:19,918 --> 00:04:22,260
ago not to say that the six-year-old

115
00:04:22,260 --> 00:04:24,600
rule doesn't necessarily have value but

116
00:04:24,600 --> 00:04:26,699
it changes my assumptions about what I'm

117
00:04:26,699 --> 00:04:28,139
looking at how effective it's going to

118
00:04:28,139 --> 00:04:29,699
be and what I might need to do to be

119
00:04:29,699 --> 00:04:32,520
able to leverage it right so

120
00:04:32,520 --> 00:04:34,500
I do think author is sort of an

121
00:04:34,500 --> 00:04:36,660
important field not just for the credit

122
00:04:36,660 --> 00:04:38,160
aspect of it

123
00:04:38,160 --> 00:04:40,320
um because frankly nobody ever has paid

124
00:04:40,320 --> 00:04:43,560
me for uh like releasing Yara rules but

125
00:04:43,560 --> 00:04:45,960
moreover because it gives the person

126
00:04:45,960 --> 00:04:47,520
who's looking at that rule down the road

127
00:04:47,520 --> 00:04:49,139
a touch point to come back to you if

128
00:04:49,139 --> 00:04:50,940
they have questions

129
00:04:50,940 --> 00:04:52,259
um another thing you'll notice so that

130
00:04:52,259 --> 00:04:53,460
the hashes

131
00:04:53,460 --> 00:04:55,080
what's the most important thing about

132
00:04:55,080 --> 00:04:56,400
that hash if you're going to put it in

133
00:04:56,400 --> 00:04:58,758
the rule

134
00:04:59,759 --> 00:05:01,800
well sure okay it's got to be accurate

135
00:05:01,800 --> 00:05:04,320
No but but the most important thing is

136
00:05:04,320 --> 00:05:06,419
it's got to be on a public repo right

137
00:05:06,419 --> 00:05:09,180
that that file needs to be on virustotal

138
00:05:09,180 --> 00:05:12,540
or abuse.ch or VX underground it's got

139
00:05:12,540 --> 00:05:14,699
to be somewhere people can get to it if

140
00:05:14,699 --> 00:05:16,620
you put a hash value up there that no

141
00:05:16,620 --> 00:05:18,780
one can get to

142
00:05:18,780 --> 00:05:21,660
um you're a jerk and I'm not going to

143
00:05:21,660 --> 00:05:24,720
name check uh any uh companies

144
00:05:24,720 --> 00:05:27,600
um that uh that do this on a regular

145
00:05:27,600 --> 00:05:30,780
basis but but there are a couple that

146
00:05:30,780 --> 00:05:33,000
like to release your rules with iocs

147
00:05:33,000 --> 00:05:34,560
that no one has access to and that's the

148
00:05:34,560 --> 00:05:35,639
most useless thing in the world because

149
00:05:35,639 --> 00:05:37,680
I can't check your work I can't validate

150
00:05:37,680 --> 00:05:39,539
what you're saying is actually true or

151
00:05:39,539 --> 00:05:41,940
not and now you're going to make me best

152
00:05:41,940 --> 00:05:43,139
case scenario you're going to make me

153
00:05:43,139 --> 00:05:44,699
burn a retro hunt to try and find

154
00:05:44,699 --> 00:05:46,800
something else so that I have a sample

155
00:05:46,800 --> 00:05:49,440
to work from right all right

156
00:05:49,440 --> 00:05:51,120
so enough about meta you can do all

157
00:05:51,120 --> 00:05:52,620
kinds of things with it you know ad

158
00:05:52,620 --> 00:05:55,440
tagging you know categorization you know

159
00:05:55,440 --> 00:05:58,080
I've seen our internal team has a whole

160
00:05:58,080 --> 00:06:01,020
uh standard for Yara rule headers uh

161
00:06:01,020 --> 00:06:02,940
that they leverage that makes it easy

162
00:06:02,940 --> 00:06:05,520
for them to index cross-reference you

163
00:06:05,520 --> 00:06:07,080
know actors and things like that right

164
00:06:07,080 --> 00:06:08,940
so you can put all kinds of data in the

165
00:06:08,940 --> 00:06:10,860
in them that you know that make them

166
00:06:10,860 --> 00:06:12,600
useful for whatever your internal Ops

167
00:06:12,600 --> 00:06:13,620
are but

168
00:06:13,620 --> 00:06:15,060
um so those are some some sort of

169
00:06:15,060 --> 00:06:16,800
Standards strings

170
00:06:16,800 --> 00:06:18,539
um fairly straightforward it's just

171
00:06:18,539 --> 00:06:21,300
pieces and pieces of values that you

172
00:06:21,300 --> 00:06:23,220
want to be able to reference these

173
00:06:23,220 --> 00:06:24,780
you'll notice the names start with the

174
00:06:24,780 --> 00:06:27,960
dollar signs variable name so uh and

175
00:06:27,960 --> 00:06:30,960
then whatever's in double quotes or as

176
00:06:30,960 --> 00:06:33,300
you move down to my first example

177
00:06:33,300 --> 00:06:35,340
um is just a is it just a regular like

178
00:06:35,340 --> 00:06:38,819
text string a utf-8 string you can also

179
00:06:38,819 --> 00:06:41,940
and you'll notice some of the lines have

180
00:06:41,940 --> 00:06:43,979
um additional modifiers after them that

181
00:06:43,979 --> 00:06:45,840
indicate what type of string we're

182
00:06:45,840 --> 00:06:47,639
looking for if you don't indicate

183
00:06:47,639 --> 00:06:50,280
something it's the same as putting ASCII

184
00:06:50,280 --> 00:06:52,979
in there so you can you can use ASCII to

185
00:06:52,979 --> 00:06:54,840
differentiate this is an ASCII string

186
00:06:54,840 --> 00:06:56,639
but if you don't that's the implication

187
00:06:56,639 --> 00:06:59,100
the implied value the next one is a wide

188
00:06:59,100 --> 00:07:02,340
string so wide sometimes also called

189
00:07:02,340 --> 00:07:05,639
long or utf-16 it just means that when

190
00:07:05,639 --> 00:07:08,220
Yara looks at that there the compiler is

191
00:07:08,220 --> 00:07:10,979
going to insert a null between each of

192
00:07:10,979 --> 00:07:12,660
those characters before it begins its

193
00:07:12,660 --> 00:07:14,100
search

194
00:07:14,100 --> 00:07:16,020
no case fairly straightforward case

195
00:07:16,020 --> 00:07:19,020
insensitive I camel case that just to to

196
00:07:19,020 --> 00:07:21,120
emphasize that but obviously the camel

197
00:07:21,120 --> 00:07:22,800
casing inside of a thing that I put no

198
00:07:22,800 --> 00:07:24,419
case in is sort of redundant and silly

199
00:07:24,419 --> 00:07:25,800
again you wouldn't really do this in a

200
00:07:25,800 --> 00:07:27,360
real rule

201
00:07:27,360 --> 00:07:28,919
regex

202
00:07:28,919 --> 00:07:33,599
regular Expressions pcre ish

203
00:07:33,599 --> 00:07:35,280
um I say ish because there are some

204
00:07:35,280 --> 00:07:37,500
things that happen with escaping

205
00:07:37,500 --> 00:07:41,039
characters in in Yara regexes that make

206
00:07:41,039 --> 00:07:43,139
them a little different

207
00:07:43,139 --> 00:07:46,259
um but I would say you know for the most

208
00:07:46,259 --> 00:07:48,060
for the most part it's it's pcre

209
00:07:48,060 --> 00:07:50,699
compliant you can do I would say 99 of

210
00:07:50,699 --> 00:07:51,960
the things you would want to do in a

211
00:07:51,960 --> 00:07:54,120
regex and probably a hundred percent of

212
00:07:54,120 --> 00:07:56,900
the things you should do in a regex

213
00:07:56,900 --> 00:07:59,639
but uh but so regular expression support

214
00:07:59,639 --> 00:08:01,919
and then byte strings and bite strings

215
00:08:01,919 --> 00:08:03,780
are fun because you can you can

216
00:08:03,780 --> 00:08:05,160
essentially you know you have full

217
00:08:05,160 --> 00:08:08,099
access to the entire character set and

218
00:08:08,099 --> 00:08:09,840
bite strings also have some cool

219
00:08:09,840 --> 00:08:11,819
features they support you know regex

220
00:08:11,819 --> 00:08:14,400
style alternates and wild cards and some

221
00:08:14,400 --> 00:08:16,139
of those things which are which are

222
00:08:16,139 --> 00:08:18,840
Super handy so especially when you start

223
00:08:18,840 --> 00:08:20,400
getting into op codes and things like

224
00:08:20,400 --> 00:08:23,340
that bite strings are the way to go

225
00:08:23,340 --> 00:08:24,120
um

226
00:08:24,120 --> 00:08:26,039
and then conditions

227
00:08:26,039 --> 00:08:28,080
um I just put the you know so you would

228
00:08:28,080 --> 00:08:29,580
never actually use

229
00:08:29,580 --> 00:08:33,299
um so any of them so them refers to

230
00:08:33,299 --> 00:08:35,820
every string in the string block so any

231
00:08:35,820 --> 00:08:37,200
of them would mean if any of these

232
00:08:37,200 --> 00:08:38,520
strings is present in the file the

233
00:08:38,520 --> 00:08:40,080
condition becomes true it returns are

234
00:08:40,080 --> 00:08:43,080
true all of them it means that every

235
00:08:43,080 --> 00:08:45,060
string listed has to appear at least

236
00:08:45,060 --> 00:08:47,220
once in order for the condition to be

237
00:08:47,220 --> 00:08:49,140
true and obviously if you're any good at

238
00:08:49,140 --> 00:08:50,519
Boolean logic you know that this is

239
00:08:50,519 --> 00:08:53,339
stupid because any of them supersedes

240
00:08:53,339 --> 00:08:55,860
all of them if any of them or all of

241
00:08:55,860 --> 00:08:57,779
them can be true then it's just in any

242
00:08:57,779 --> 00:08:59,820
of them statement but I did it mostly to

243
00:08:59,820 --> 00:09:01,260
show off the parentheses and the fact

244
00:09:01,260 --> 00:09:02,640
that you can chain conditions together

245
00:09:02,640 --> 00:09:05,040
with ores and ands uh and we'll get into

246
00:09:05,040 --> 00:09:06,839
some more interesting versions of that

247
00:09:06,839 --> 00:09:07,980
later

248
00:09:07,980 --> 00:09:09,420
and this is what it looks like when we

249
00:09:09,420 --> 00:09:13,080
run it so our test file is hw.txt says

250
00:09:13,080 --> 00:09:15,120
hello world our

251
00:09:15,120 --> 00:09:17,580
rule we were just looking at is hw.yaro

252
00:09:17,580 --> 00:09:21,060
which is our hello uh hello world rule

253
00:09:21,060 --> 00:09:22,740
run it against it you can see the match

254
00:09:22,740 --> 00:09:25,860
the output you get is Rule name followed

255
00:09:25,860 --> 00:09:27,779
by file name and that's the default

256
00:09:27,779 --> 00:09:29,880
output I also added the dash s switch

257
00:09:29,880 --> 00:09:31,560
which is like my favorite debugging

258
00:09:31,560 --> 00:09:33,180
switch it just shows you all the string

259
00:09:33,180 --> 00:09:35,339
matches at position so you can see we

260
00:09:35,339 --> 00:09:38,220
matched on everything but the utf-16 the

261
00:09:38,220 --> 00:09:41,880
the wide string in that rule because

262
00:09:41,880 --> 00:09:44,399
our you know our file doesn't contain

263
00:09:44,399 --> 00:09:45,500
that value

264
00:09:45,500 --> 00:09:48,120
some interesting things to note with the

265
00:09:48,120 --> 00:09:50,399
case insensitive match we didn't get the

266
00:09:50,399 --> 00:09:51,839
value of the string we got the value of

267
00:09:51,839 --> 00:09:53,640
the block from the file and the same

268
00:09:53,640 --> 00:09:55,440
with the regular expression string we

269
00:09:55,440 --> 00:09:56,459
didn't get the value of the regular

270
00:09:56,459 --> 00:09:58,620
expression output we got the value that

271
00:09:58,620 --> 00:10:00,839
it matched on interestingly enough with

272
00:10:00,839 --> 00:10:02,940
the byte string we still got the value

273
00:10:02,940 --> 00:10:04,860
that it matched on but it gives it to us

274
00:10:04,860 --> 00:10:08,540
in HEX format and not in text format

275
00:10:08,540 --> 00:10:11,820
I I'm assuming that's just a default to

276
00:10:11,820 --> 00:10:13,440
make processing the output easier

277
00:10:13,440 --> 00:10:15,660
because obviously you can access you

278
00:10:15,660 --> 00:10:18,660
know non-ascii values and non-escaped

279
00:10:18,660 --> 00:10:21,360
values in byte strings but so

280
00:10:21,360 --> 00:10:23,399
interesting that it would that it would

281
00:10:23,399 --> 00:10:25,080
output that way but it's worth noting

282
00:10:25,080 --> 00:10:26,459
for those of you that don't speak hacks

283
00:10:26,459 --> 00:10:28,260
that that is in fact the exact same

284
00:10:28,260 --> 00:10:30,720
hello world string that the other

285
00:10:30,720 --> 00:10:33,000
strings are matching on

286
00:10:33,000 --> 00:10:36,959
oh and uh 0x0 that's the offset of the

287
00:10:36,959 --> 00:10:39,420
beginning of each of the matches um and

288
00:10:39,420 --> 00:10:41,580
that's a super super handy feature when

289
00:10:41,580 --> 00:10:43,380
you're doing rule development to know

290
00:10:43,380 --> 00:10:45,720
where in a file you can find the match

291
00:10:45,720 --> 00:10:47,820
strings that your rule is is connecting

292
00:10:47,820 --> 00:10:48,779
on

293
00:10:48,779 --> 00:10:51,240
all right um so a little more

294
00:10:51,240 --> 00:10:53,279
um this one is uh this is Hello World

295
00:10:53,279 --> 00:10:56,640
take two the point of this is really to

296
00:10:56,640 --> 00:10:58,320
um to demonstrate some of the more

297
00:10:58,320 --> 00:11:00,300
advanced functionality in the conditions

298
00:11:00,300 --> 00:11:01,680
block so we'll just skip straight to

299
00:11:01,680 --> 00:11:02,760
that

300
00:11:02,760 --> 00:11:03,720
um

301
00:11:03,720 --> 00:11:06,120
so file size is an internal mnemonic in

302
00:11:06,120 --> 00:11:08,820
this case we're going to say any file

303
00:11:08,820 --> 00:11:12,240
um so by the way hello world hw.txt is

304
00:11:12,240 --> 00:11:15,240
exactly 12 bytes so file size less than

305
00:11:15,240 --> 00:11:17,579
13 is a condition any file over that

306
00:11:17,579 --> 00:11:22,560
we're not going to match on and so we

307
00:11:22,560 --> 00:11:24,000
can start calling into the variables

308
00:11:24,000 --> 00:11:27,060
directly so hello at position zero and

309
00:11:27,060 --> 00:11:30,779
world in the range of 4 to file size so

310
00:11:30,779 --> 00:11:32,820
file size just becomes a number it's

311
00:11:32,820 --> 00:11:34,800
essentially an integer that is exactly

312
00:11:34,800 --> 00:11:36,959
the number of bytes that the file that

313
00:11:36,959 --> 00:11:39,480
is currently open and the rule is but

314
00:11:39,480 --> 00:11:41,040
you can use it in a Range we could have

315
00:11:41,040 --> 00:11:43,740
said four to a hundred four to twelve if

316
00:11:43,740 --> 00:11:45,180
we knew what it was going to be before

317
00:11:45,180 --> 00:11:47,160
the file size lets us access that you

318
00:11:47,160 --> 00:11:49,680
know it just means end a file or hello

319
00:11:49,680 --> 00:11:53,640
world and or hello and world or all of

320
00:11:53,640 --> 00:11:56,399
and then this is a cool example I love

321
00:11:56,399 --> 00:11:58,160
doing this you'll see some of this later

322
00:11:58,160 --> 00:12:01,200
where I classify the strings like I'll

323
00:12:01,200 --> 00:12:03,060
give them like a like a grouping name

324
00:12:03,060 --> 00:12:05,519
and then usually an underscore to

325
00:12:05,519 --> 00:12:07,260
separate the individual value so that

326
00:12:07,260 --> 00:12:10,380
you can use the asterisks to call groups

327
00:12:10,380 --> 00:12:12,839
of things in a single item so you can

328
00:12:12,839 --> 00:12:14,940
wildcard your variable names inside the

329
00:12:14,940 --> 00:12:18,680
conditions and that's super handy too

330
00:12:19,860 --> 00:12:21,899
and so here's an example of this one and

331
00:12:21,899 --> 00:12:24,779
you'll see now with the with the output

332
00:12:24,779 --> 00:12:27,480
and the offsets we get hello is it zero

333
00:12:27,480 --> 00:12:29,459
but because hello and world are now two

334
00:12:29,459 --> 00:12:31,500
different string matches you see the

335
00:12:31,500 --> 00:12:33,839
offset for world has moved to the sixth

336
00:12:33,839 --> 00:12:36,300
position in the file

337
00:12:36,300 --> 00:12:38,220
um well the world was always at the

338
00:12:38,220 --> 00:12:40,079
sixth position but the match starts at

339
00:12:40,079 --> 00:12:42,120
six now because it's a separate value

340
00:12:42,120 --> 00:12:43,260
okay

341
00:12:43,260 --> 00:12:45,660
um a little bit about modules

342
00:12:45,660 --> 00:12:47,279
um so like I said we're going to start

343
00:12:47,279 --> 00:12:50,040
moving uh deep pretty quick

344
00:12:50,040 --> 00:12:52,560
um so modules are awesome highly

345
00:12:52,560 --> 00:12:54,060
recommend using them they save you a

346
00:12:54,060 --> 00:12:55,680
bunch of time somebody spent a lot of

347
00:12:55,680 --> 00:12:58,380
time writing a module because it saved

348
00:12:58,380 --> 00:12:59,820
them time so if it's going to save them

349
00:12:59,820 --> 00:13:02,339
time it'll save you time

350
00:13:02,339 --> 00:13:04,920
um that top rule is an example of a dll

351
00:13:04,920 --> 00:13:06,839
check you'll notice there's no strings

352
00:13:06,839 --> 00:13:08,579
it's just a single condition we import

353
00:13:08,579 --> 00:13:11,940
PE kind of python style laptop so PE is

354
00:13:11,940 --> 00:13:14,040
the module name and then that gives us

355
00:13:14,040 --> 00:13:16,500
access to all of the functionality

356
00:13:16,500 --> 00:13:18,899
within that module and typically the way

357
00:13:18,899 --> 00:13:20,339
that you access that is in the

358
00:13:20,339 --> 00:13:22,440
conditions and it'll begin with module

359
00:13:22,440 --> 00:13:24,660
name Dot and then the capability and you

360
00:13:24,660 --> 00:13:26,880
can have essentially subordinate

361
00:13:26,880 --> 00:13:28,800
functionality right where there's you

362
00:13:28,800 --> 00:13:30,660
know multi layers of functions each

363
00:13:30,660 --> 00:13:32,459
separated by a period but in this case

364
00:13:32,459 --> 00:13:37,500
is dll open and close parens so and all

365
00:13:37,500 --> 00:13:40,459
this does is if a file is in fact a

366
00:13:40,459 --> 00:13:43,200
Windows portable executable Dynamic

367
00:13:43,200 --> 00:13:45,779
loadable Library a dll file it will

368
00:13:45,779 --> 00:13:48,360
return true it'll match on all dlls in

369
00:13:48,360 --> 00:13:52,680
order to do this without doing without

370
00:13:52,680 --> 00:13:55,560
using the PE parser you end up with this

371
00:13:55,560 --> 00:13:57,180
condition stack down here and I'll walk

372
00:13:57,180 --> 00:13:58,500
you through kind of what we're testing

373
00:13:58,500 --> 00:14:00,240
for so the first is we're going to look

374
00:14:00,240 --> 00:14:03,300
for the magic number so everybody not

375
00:14:03,300 --> 00:14:05,940
everybody but you probably know that

376
00:14:05,940 --> 00:14:08,040
Windows executables the first two bytes

377
00:14:08,040 --> 00:14:10,500
or the capital m capital Z sometimes

378
00:14:10,500 --> 00:14:12,959
called 4D 5A

379
00:14:12,959 --> 00:14:15,540
in Yara you're going to interact with

380
00:14:15,540 --> 00:14:19,680
integers inside of conditions as as big

381
00:14:19,680 --> 00:14:21,720
Indian and you'll see this a little

382
00:14:21,720 --> 00:14:24,240
later if you do it in strings you do it

383
00:14:24,240 --> 00:14:27,240
in in byte order if you do it down in

384
00:14:27,240 --> 00:14:28,860
the conditions you're doing this big

385
00:14:28,860 --> 00:14:33,540
Indian so what you have is uint 16 so

386
00:14:33,540 --> 00:14:36,060
declare an integer at a position in this

387
00:14:36,060 --> 00:14:38,040
case we're taking position zero so the

388
00:14:38,040 --> 00:14:41,519
beginning of the file Unit 16 says give

389
00:14:41,519 --> 00:14:45,600
me you know a an unsigned integer a

390
00:14:45,600 --> 00:14:50,279
length of 16 16 bits which is two bytes

391
00:14:50,279 --> 00:14:52,500
right so the first two bytes of the file

392
00:14:52,500 --> 00:14:56,040
at position zero equals big Indian

393
00:14:56,040 --> 00:15:00,720
5A 4D which is 45a it's MZ right so just

394
00:15:00,720 --> 00:15:02,160
just to walk through that to explain

395
00:15:02,160 --> 00:15:04,440
what that's doing literally that first

396
00:15:04,440 --> 00:15:05,880
condition is just what are the first two

397
00:15:05,880 --> 00:15:07,860
bytes are they MZ

398
00:15:07,860 --> 00:15:12,000
the next one is looking at offset 3C and

399
00:15:12,000 --> 00:15:14,940
if Unit 16 is looking for two bytes U

400
00:15:14,940 --> 00:15:17,820
and 32 must be looking for

401
00:15:17,820 --> 00:15:20,100
four bytes right because 32 bits is four

402
00:15:20,100 --> 00:15:22,459
bytes um and again it's it's big Indian

403
00:15:22,459 --> 00:15:25,620
so what really all that is is that the

404
00:15:25,620 --> 00:15:27,899
letters P and E because that's how you

405
00:15:27,899 --> 00:15:30,180
declare a PE header followed by two

406
00:15:30,180 --> 00:15:32,820
nulls but you know again big Indian

407
00:15:32,820 --> 00:15:35,639
style so zero zero zero zero forty five

408
00:15:35,639 --> 00:15:36,720
fifty

409
00:15:36,720 --> 00:15:37,440
um

410
00:15:37,440 --> 00:15:40,019
and then the last piece is we're going

411
00:15:40,019 --> 00:15:42,540
to add an additional offset of 16

412
00:15:42,540 --> 00:15:47,279
because uh 16 16 bytes off of the

413
00:15:47,279 --> 00:15:49,860
beginning of the PE header starts the PE

414
00:15:49,860 --> 00:15:53,160
headers characteristics section and

415
00:15:53,160 --> 00:15:54,839
those four bytes at the characteristics

416
00:15:54,839 --> 00:15:56,760
section tell you what type of file it is

417
00:15:56,760 --> 00:15:59,459
and if the the you know essentially if

418
00:15:59,459 --> 00:16:01,440
if 2-0

419
00:16:01,440 --> 00:16:04,260
um you know if if the if 32 you know

420
00:16:04,260 --> 00:16:07,800
decimal 32 is set you know hex 2-0 is

421
00:16:07,800 --> 00:16:10,380
set in that position within those four

422
00:16:10,380 --> 00:16:13,740
bytes that indicates that it's a dll

423
00:16:13,740 --> 00:16:17,339
right and the whole point of showing you

424
00:16:17,339 --> 00:16:20,760
this is that in order to do this

425
00:16:20,760 --> 00:16:22,560
manually you have to really really

426
00:16:22,560 --> 00:16:25,380
understand at a deep level what the

427
00:16:25,380 --> 00:16:27,779
files do how the layout you like you

428
00:16:27,779 --> 00:16:29,160
actually have to go read that that

429
00:16:29,160 --> 00:16:31,800
Microsoft link that I included there uh

430
00:16:31,800 --> 00:16:34,079
that gives you the full breakdown of how

431
00:16:34,079 --> 00:16:36,420
image file dll gets set in the PE header

432
00:16:36,420 --> 00:16:37,800
flag

433
00:16:37,800 --> 00:16:39,779
or you can use the module and write that

434
00:16:39,779 --> 00:16:43,220
one line and never think about it again

435
00:16:44,699 --> 00:16:47,100
all right um and just uh just a proof of

436
00:16:47,100 --> 00:16:47,940
life

437
00:16:47,940 --> 00:16:50,820
um you know Randy so dll.yara contains

438
00:16:50,820 --> 00:16:53,100
both of these rules in it run them over

439
00:16:53,100 --> 00:16:54,660
the same files and you'll see they both

440
00:16:54,660 --> 00:16:56,519
match

441
00:16:56,519 --> 00:16:58,259
um and I just ran that against my Zoo so

442
00:16:58,259 --> 00:17:00,060
these are just some some loaded dlls in

443
00:17:00,060 --> 00:17:02,459
the in the in the wild all right

444
00:17:02,459 --> 00:17:04,859
so let's talk a little bit about Yara

445
00:17:04,859 --> 00:17:06,900
use cases right that syntax that's how

446
00:17:06,900 --> 00:17:10,260
to use it what can we do with Yara

447
00:17:10,260 --> 00:17:12,119
right uh and there's a variety of

448
00:17:12,119 --> 00:17:13,439
different use cases I'm going to move

449
00:17:13,439 --> 00:17:15,480
through these fairly quickly but I think

450
00:17:15,480 --> 00:17:17,579
it's worth understanding the four

451
00:17:17,579 --> 00:17:20,099
important use cases

452
00:17:20,099 --> 00:17:21,540
you know you're going to wonder why why

453
00:17:21,540 --> 00:17:23,819
is this guy that has dedicated so much

454
00:17:23,819 --> 00:17:25,740
of his career to detection saying

455
00:17:25,740 --> 00:17:26,939
detection is not a use case because

456
00:17:26,939 --> 00:17:29,700
that's all Yara does Yara Yara is a is a

457
00:17:29,700 --> 00:17:32,520
true false engine for matching that's

458
00:17:32,520 --> 00:17:34,500
detection done and done right like it

459
00:17:34,500 --> 00:17:36,240
either matches or it doesn't that's

460
00:17:36,240 --> 00:17:38,340
detection so let's talk a little bit

461
00:17:38,340 --> 00:17:40,980
more specifically about the intent that

462
00:17:40,980 --> 00:17:42,960
you need to have authoring a file

463
00:17:42,960 --> 00:17:44,280
especially when you're thinking about

464
00:17:44,280 --> 00:17:47,280
how to write detection so identification

465
00:17:47,280 --> 00:17:49,620
rules so an identification rule would be

466
00:17:49,620 --> 00:17:52,020
an example of a rule where you want to

467
00:17:52,020 --> 00:17:55,679
positively ID a file let's let's pick on

468
00:17:55,679 --> 00:17:58,799
malware right like I definitely want to

469
00:17:58,799 --> 00:18:00,919
like I want this rule to say

470
00:18:00,919 --> 00:18:03,480
definitively that what I'm looking at is

471
00:18:03,480 --> 00:18:06,179
in fact a plug X sample or a bonitu

472
00:18:06,179 --> 00:18:08,160
sample or whatever the the malware

473
00:18:08,160 --> 00:18:10,860
family is right and so the goals are

474
00:18:10,860 --> 00:18:12,179
going to be a really positive

475
00:18:12,179 --> 00:18:14,100
identification I'm going to want to be

476
00:18:14,100 --> 00:18:16,200
confident that what I'm looking at is in

477
00:18:16,200 --> 00:18:17,700
fact the malware family I'm looking for

478
00:18:17,700 --> 00:18:19,860
I also am going to want a really low

479
00:18:19,860 --> 00:18:22,380
false positive rate the downside of that

480
00:18:22,380 --> 00:18:23,880
though means that I'm engineering for

481
00:18:23,880 --> 00:18:25,679
specificity I'm going to include tool

482
00:18:25,679 --> 00:18:27,240
marks I'm going to include metadata I'm

483
00:18:27,240 --> 00:18:29,340
going to include functional code in

484
00:18:29,340 --> 00:18:30,660
those things that I'm looking for when

485
00:18:30,660 --> 00:18:32,760
I'm writing that rule the downside is

486
00:18:32,760 --> 00:18:35,100
there's a chance for false negative rate

487
00:18:35,100 --> 00:18:36,600
that rule is going to be a little bit

488
00:18:36,600 --> 00:18:37,980
brittle

489
00:18:37,980 --> 00:18:40,380
it may also be easy to bypass if I

490
00:18:40,380 --> 00:18:42,059
publish this rule the author may go out

491
00:18:42,059 --> 00:18:44,520
and say oh he's you know similar to uh

492
00:18:44,520 --> 00:18:46,380
to the the talk that Tim medine just

493
00:18:46,380 --> 00:18:49,559
gave on the The Defender bypass that was

494
00:18:49,559 --> 00:18:52,380
hooking on Tavis ormondy which by the

495
00:18:52,380 --> 00:18:53,640
way I'm proud of myself for not coming

496
00:18:53,640 --> 00:18:55,380
on hot mic and just saying yeah well

497
00:18:55,380 --> 00:18:57,600
Defenders get to be lazy too because if

498
00:18:57,600 --> 00:18:59,940
it works it's not if it's works it's not

499
00:18:59,940 --> 00:19:01,260
stupid

500
00:19:01,260 --> 00:19:03,660
um so and Tavis isn't on my list but

501
00:19:03,660 --> 00:19:05,340
there are a handful of offensive tool

502
00:19:05,340 --> 00:19:07,860
authors who I absolutely have detection

503
00:19:07,860 --> 00:19:10,020
just for their name just occurring in a

504
00:19:10,020 --> 00:19:11,460
file because it's always worth looking

505
00:19:11,460 --> 00:19:12,720
at

506
00:19:12,720 --> 00:19:14,460
um and bad guys don't strip out comments

507
00:19:14,460 --> 00:19:17,160
as often as they should so anyway but

508
00:19:17,160 --> 00:19:18,840
they might leverage that same

509
00:19:18,840 --> 00:19:20,880
information if you release a rule into

510
00:19:20,880 --> 00:19:22,919
the into the public Stratosphere you

511
00:19:22,919 --> 00:19:24,660
know they may go oh I can exchange that

512
00:19:24,660 --> 00:19:26,039
value and now your rule doesn't fire

513
00:19:26,039 --> 00:19:27,600
anymore so

514
00:19:27,600 --> 00:19:29,760
um when I think about identification

515
00:19:29,760 --> 00:19:31,559
rules I definitely want to function

516
00:19:31,559 --> 00:19:33,600
focus on those functional artifacts and

517
00:19:33,600 --> 00:19:35,400
required code to reduce the likelihood

518
00:19:35,400 --> 00:19:37,799
of false negatives you really want to

519
00:19:37,799 --> 00:19:40,980
hook into what those capabilities are so

520
00:19:40,980 --> 00:19:43,080
that in order to bypass a piece of

521
00:19:43,080 --> 00:19:45,480
detection the author has to change not

522
00:19:45,480 --> 00:19:47,640
just the the metadata and arbitrary

523
00:19:47,640 --> 00:19:49,799
values that don't mean anything that

524
00:19:49,799 --> 00:19:51,660
you're you're identifying it's not that

525
00:19:51,660 --> 00:19:53,460
you shouldn't use those but you

526
00:19:53,460 --> 00:19:56,039
shouldn't use only those because if you

527
00:19:56,039 --> 00:19:58,919
can hook into functional code well now

528
00:19:58,919 --> 00:20:00,539
they have to change how their tool works

529
00:20:00,539 --> 00:20:02,460
and at the end of the day if you can

530
00:20:02,460 --> 00:20:04,080
make an adversary have to change how

531
00:20:04,080 --> 00:20:05,520
their tool works every time you write

532
00:20:05,520 --> 00:20:08,100
detection you're eventually going to

533
00:20:08,100 --> 00:20:11,539
exhaust the resources and win

534
00:20:12,000 --> 00:20:15,360
classification rules so this is where

535
00:20:15,360 --> 00:20:16,740
we're looking for the existence of known

536
00:20:16,740 --> 00:20:18,539
values right we want to be able to say

537
00:20:18,539 --> 00:20:19,919
you know with a high degree of

538
00:20:19,919 --> 00:20:22,740
confidence that this thing does a

539
00:20:22,740 --> 00:20:24,960
particular thing right

540
00:20:24,960 --> 00:20:27,120
um you know so this is this file is is

541
00:20:27,120 --> 00:20:30,840
an executable that loads a series of you

542
00:20:30,840 --> 00:20:33,299
know functions like maybe from you know

543
00:20:33,299 --> 00:20:36,720
winsock 232 dll that you know establish

544
00:20:36,720 --> 00:20:40,080
outbound junk socket connections with uh

545
00:20:40,080 --> 00:20:42,419
with you know connect right that would

546
00:20:42,419 --> 00:20:43,799
be a really good one to have some

547
00:20:43,799 --> 00:20:46,140
detection for why because no modern

548
00:20:46,140 --> 00:20:48,660
application is using winsock 232 for

549
00:20:48,660 --> 00:20:50,340
outbound socket connections that's a

550
00:20:50,340 --> 00:20:52,140
terrible idea we quit doing that in the

551
00:20:52,140 --> 00:20:54,360
early 2000s but the functionality still

552
00:20:54,360 --> 00:20:55,799
exists and you know who does it all the

553
00:20:55,799 --> 00:20:58,380
time Cobalt strike

554
00:20:58,380 --> 00:20:59,700
boom

555
00:20:59,700 --> 00:21:02,940
and interpreter and sliver and right

556
00:21:02,940 --> 00:21:05,580
like so there's a there's a but that's

557
00:21:05,580 --> 00:21:07,140
just it right that's a that's almost

558
00:21:07,140 --> 00:21:09,720
like a code TTP like I don't want to say

559
00:21:09,720 --> 00:21:12,299
I I shouldn't have said TTP but it's a

560
00:21:12,299 --> 00:21:15,120
it's a code technique that isn't

561
00:21:15,120 --> 00:21:16,799
necessarily going to positively idea a

562
00:21:16,799 --> 00:21:18,360
thing but if a thing does that thing

563
00:21:18,360 --> 00:21:20,760
it's probably worth looking at and so

564
00:21:20,760 --> 00:21:22,440
that's the goal of a classification rule

565
00:21:22,440 --> 00:21:24,539
obviously you're going to run into some

566
00:21:24,539 --> 00:21:26,580
false positives because you know if

567
00:21:26,580 --> 00:21:29,039
you're if you're if you're um if you're

568
00:21:29,039 --> 00:21:31,919
capitalizing on the the functional

569
00:21:31,919 --> 00:21:34,500
selection and the bad coding practices

570
00:21:34,500 --> 00:21:36,360
of your adversaries who by the way most

571
00:21:36,360 --> 00:21:37,679
of your adversaries have really bad

572
00:21:37,679 --> 00:21:40,200
coding practices

573
00:21:40,200 --> 00:21:41,760
um if you're if you're focusing on those

574
00:21:41,760 --> 00:21:43,200
things eventually you're going to come

575
00:21:43,200 --> 00:21:46,500
across a developer who's not a criminal

576
00:21:46,500 --> 00:21:49,440
um or a spy who also is bad and wrote a

577
00:21:49,440 --> 00:21:50,940
bad thing and you're going to hook their

578
00:21:50,940 --> 00:21:52,799
stuff too oh well

579
00:21:52,799 --> 00:21:54,720
um and then you know this is also where

580
00:21:54,720 --> 00:21:55,919
you start to run into performance

581
00:21:55,919 --> 00:21:57,240
trade-offs right because one of the

582
00:21:57,240 --> 00:21:58,260
other things you want to do in this

583
00:21:58,260 --> 00:22:00,120
scenario is account for variables and

584
00:22:00,120 --> 00:22:02,220
variability how many different ways

585
00:22:02,220 --> 00:22:04,559
could this thing happen I'm gonna walk

586
00:22:04,559 --> 00:22:06,299
away from some of the specific context

587
00:22:06,299 --> 00:22:08,340
I've seen in specific samples and try

588
00:22:08,340 --> 00:22:09,659
and broaden my horizons a little bit

589
00:22:09,659 --> 00:22:11,220
when I think about how I write this rule

590
00:22:11,220 --> 00:22:13,679
the downside is is that that means you

591
00:22:13,679 --> 00:22:15,299
know the number of strings and the types

592
00:22:15,299 --> 00:22:16,799
of encoding and things like that that

593
00:22:16,799 --> 00:22:18,480
I'm going to include in the rule are

594
00:22:18,480 --> 00:22:21,419
going to go up some so that leads to the

595
00:22:21,419 --> 00:22:23,220
pro tip I have for writing this kind of

596
00:22:23,220 --> 00:22:25,679
rule if your rule is more than 20 lines

597
00:22:25,679 --> 00:22:29,100
it's probably not one rule

598
00:22:29,100 --> 00:22:30,900
um you know with with uh with the

599
00:22:30,900 --> 00:22:33,000
identification rules um and hunting

600
00:22:33,000 --> 00:22:35,340
rules go nuts one because you can sort

601
00:22:35,340 --> 00:22:37,200
of uh accept the perform you know you

602
00:22:37,200 --> 00:22:38,700
need the specificity for identification

603
00:22:38,700 --> 00:22:40,799
when we get to hunting with hunting you

604
00:22:40,799 --> 00:22:42,720
have uh more Cycles you can be more

605
00:22:42,720 --> 00:22:44,340
expensive

606
00:22:44,340 --> 00:22:46,440
but uh for classification rules

607
00:22:46,440 --> 00:22:48,240
especially if you do intend to use them

608
00:22:48,240 --> 00:22:50,100
for alerting purposes

609
00:22:50,100 --> 00:22:52,500
um it's it's important to keep them kind

610
00:22:52,500 --> 00:22:54,179
of tight and constrained and it's better

611
00:22:54,179 --> 00:22:56,520
to build groups of rules or families of

612
00:22:56,520 --> 00:22:58,559
rules rather than one rule to rule them

613
00:22:58,559 --> 00:23:00,740
all

614
00:23:01,500 --> 00:23:03,480
um so hunting rules you know distinguish

615
00:23:03,480 --> 00:23:06,000
anomalies or suspicious files

616
00:23:06,000 --> 00:23:07,020
um you know you want to match on

617
00:23:07,020 --> 00:23:08,640
suspicious content you want it to be

618
00:23:08,640 --> 00:23:10,200
flexible

619
00:23:10,200 --> 00:23:11,640
um you know potentially High false

620
00:23:11,640 --> 00:23:13,980
positive rates on things like this

621
00:23:13,980 --> 00:23:15,659
um and uh you'll never be done tuning

622
00:23:15,659 --> 00:23:16,799
these

623
00:23:16,799 --> 00:23:18,960
um and uh the other the other piece of

624
00:23:18,960 --> 00:23:21,120
advice and this is just this is just uh

625
00:23:21,120 --> 00:23:23,340
let me let me show you one of my scars

626
00:23:23,340 --> 00:23:26,460
uh is this is why this is why comments

627
00:23:26,460 --> 00:23:28,200
exist because you'll deploy a hunting

628
00:23:28,200 --> 00:23:30,600
Rule and it won't fire very often and

629
00:23:30,600 --> 00:23:31,980
you'll forget about it and then a year

630
00:23:31,980 --> 00:23:34,380
later it'll fire and if you just you

631
00:23:34,380 --> 00:23:35,700
know kind of

632
00:23:35,700 --> 00:23:37,799
pack that one up and shot it off into

633
00:23:37,799 --> 00:23:39,299
the stratosphere and you come back to it

634
00:23:39,299 --> 00:23:42,360
a year later and man what was I thinking

635
00:23:42,360 --> 00:23:45,720
right do you do future you a favor and

636
00:23:45,720 --> 00:23:47,940
comment your rules especially your

637
00:23:47,940 --> 00:23:49,200
hunting rules you should comment all

638
00:23:49,200 --> 00:23:51,240
your rules anyway but really really with

639
00:23:51,240 --> 00:23:53,460
your hunting rules if like there's no

640
00:23:53,460 --> 00:23:55,440
limit to the number of comment free tags

641
00:23:55,440 --> 00:23:56,940
that doesn't have any performance impact

642
00:23:56,940 --> 00:23:59,280
just go nuts be like well I saw this

643
00:23:59,280 --> 00:24:00,720
thing and I was thinking this thing and

644
00:24:00,720 --> 00:24:02,400
I'm not really sure but maybe this could

645
00:24:02,400 --> 00:24:04,380
work or maybe that'll work I'm not you

646
00:24:04,380 --> 00:24:06,240
know right like go nuts

647
00:24:06,240 --> 00:24:07,140
um

648
00:24:07,140 --> 00:24:09,480
and then finally triage rules these are

649
00:24:09,480 --> 00:24:10,740
my favorite and they're the most

650
00:24:10,740 --> 00:24:13,260
undervalued use case for Yara

651
00:24:13,260 --> 00:24:15,480
um but the whole point of triage rules

652
00:24:15,480 --> 00:24:18,360
is and this is the dash s flag use case

653
00:24:18,360 --> 00:24:21,360
right we're going to uh we're going to

654
00:24:21,360 --> 00:24:23,760
use Yara to extract interesting things

655
00:24:23,760 --> 00:24:25,919
from files before we even start our

656
00:24:25,919 --> 00:24:28,320
analysis of the file right

657
00:24:28,320 --> 00:24:30,179
um so the you know the downside to

658
00:24:30,179 --> 00:24:31,740
triage rules of course is they're

659
00:24:31,740 --> 00:24:34,260
completely useless for alerting you

660
00:24:34,260 --> 00:24:35,400
wouldn't put these out in the world

661
00:24:35,400 --> 00:24:36,900
right so I'll give you an example I have

662
00:24:36,900 --> 00:24:39,299
one that's my go-to that I call extract

663
00:24:39,299 --> 00:24:41,760
indicators it has some really tight

664
00:24:41,760 --> 00:24:43,380
regular expressions and a little bit of

665
00:24:43,380 --> 00:24:46,380
good Logic for finding um both you know

666
00:24:46,380 --> 00:24:49,980
encoded obfuscated and just plain URLs

667
00:24:49,980 --> 00:24:53,400
and fully qualified domain names and

668
00:24:53,400 --> 00:24:55,919
file paths in files right so if I'm

669
00:24:55,919 --> 00:24:57,600
looking in an executable file you know

670
00:24:57,600 --> 00:25:00,419
if there's right if there's you know pdb

671
00:25:00,419 --> 00:25:03,299
um you know references or there's a URL

672
00:25:03,299 --> 00:25:04,559
that's potentially really really

673
00:25:04,559 --> 00:25:06,120
interesting info to have as you're

674
00:25:06,120 --> 00:25:07,860
getting ready to look at a file and if I

675
00:25:07,860 --> 00:25:10,200
can get all of that in whatever context

676
00:25:10,200 --> 00:25:11,640
and you know instead of having to spend

677
00:25:11,640 --> 00:25:14,460
20 30 minutes you know slicing it up

678
00:25:14,460 --> 00:25:16,740
um in cyber Chef or whatever I can just

679
00:25:16,740 --> 00:25:19,020
run Yara over at Yara just pukes out the

680
00:25:19,020 --> 00:25:20,460
the things and tells me where they are

681
00:25:20,460 --> 00:25:21,900
in the file gives me some hints where to

682
00:25:21,900 --> 00:25:24,659
get started the downside of course is

683
00:25:24,659 --> 00:25:27,059
you would never ever use that for

684
00:25:27,059 --> 00:25:29,820
detection because how often is there a

685
00:25:29,820 --> 00:25:31,919
URL string somewhere in a Windows

686
00:25:31,919 --> 00:25:33,240
executable you might think to yourself

687
00:25:33,240 --> 00:25:35,700
well only if it does each no everything

688
00:25:35,700 --> 00:25:38,520
every sign binary everywhere has a URL

689
00:25:38,520 --> 00:25:41,100
in it minimum so don't terrible for

690
00:25:41,100 --> 00:25:42,900
detection never do that

691
00:25:42,900 --> 00:25:44,100
all right

692
00:25:44,100 --> 00:25:47,220
a little bit about Yara performance so

693
00:25:47,220 --> 00:25:48,900
some performance Concepts I want to talk

694
00:25:48,900 --> 00:25:51,539
a little bit about anchoring so some of

695
00:25:51,539 --> 00:25:53,220
these are really fancy fun academic

696
00:25:53,220 --> 00:25:54,240
words I'm going to break them down

697
00:25:54,240 --> 00:25:57,539
anchoring just means use a big string uh

698
00:25:57,539 --> 00:25:59,880
instead of a bunch of little strings why

699
00:25:59,880 --> 00:26:01,679
because the bigger string gives more

700
00:26:01,679 --> 00:26:04,440
context more positionality it reduces

701
00:26:04,440 --> 00:26:07,200
the the likelihood of that value being

702
00:26:07,200 --> 00:26:09,480
misinterpreted it also has some very

703
00:26:09,480 --> 00:26:11,940
real performance benefits I'll talk a

704
00:26:11,940 --> 00:26:13,740
little bit about specifically how the r

705
00:26:13,740 --> 00:26:15,900
compiler deals with performance and how

706
00:26:15,900 --> 00:26:17,340
you can think about writing your rules

707
00:26:17,340 --> 00:26:19,020
to help there

708
00:26:19,020 --> 00:26:20,880
um but so anchoring just means use a big

709
00:26:20,880 --> 00:26:24,480
string and minimize the amount of kind

710
00:26:24,480 --> 00:26:26,940
of wild cards that you're using in in

711
00:26:26,940 --> 00:26:30,360
those strings if you can right so for

712
00:26:30,360 --> 00:26:33,000
example in the hello world example using

713
00:26:33,000 --> 00:26:34,919
hello world as one string with the

714
00:26:34,919 --> 00:26:37,020
spaces and the you know and the the

715
00:26:37,020 --> 00:26:39,659
punctuation is far better than hello and

716
00:26:39,659 --> 00:26:42,360
world because those matches can happen

717
00:26:42,360 --> 00:26:44,220
in any order any place in the file

718
00:26:44,220 --> 00:26:46,799
versus you know hello world tells me

719
00:26:46,799 --> 00:26:48,779
this comes before this and is separated

720
00:26:48,779 --> 00:26:51,600
by this that's super useful

721
00:26:51,600 --> 00:26:53,580
cardinality cardinality is a really

722
00:26:53,580 --> 00:26:55,320
fancy word I recommend you learn it so

723
00:26:55,320 --> 00:26:56,700
that you sound smart but it just means

724
00:26:56,700 --> 00:26:58,500
Counting

725
00:26:58,500 --> 00:27:01,860
um so the cardinality of a thing is the

726
00:27:01,860 --> 00:27:03,840
anticipated number of times that we will

727
00:27:03,840 --> 00:27:07,500
count it so high cardinality means Lots

728
00:27:07,500 --> 00:27:11,580
low cardinality means not lots so anyway

729
00:27:11,580 --> 00:27:13,140
we're looking for things that are that

730
00:27:13,140 --> 00:27:14,940
are anticipated to be of low cardinality

731
00:27:14,940 --> 00:27:17,279
which means they shouldn't happen a lot

732
00:27:17,279 --> 00:27:20,520
of times in a given file right and I'll

733
00:27:20,520 --> 00:27:22,080
give you some examples of good and some

734
00:27:22,080 --> 00:27:25,020
examples of that regex performance uh

735
00:27:25,020 --> 00:27:26,779
you know use ranges

736
00:27:26,779 --> 00:27:29,460
if you're writing Yara rules with ranges

737
00:27:29,460 --> 00:27:31,620
the Stark curly brace one comma curly

738
00:27:31,620 --> 00:27:33,960
brace get out

739
00:27:33,960 --> 00:27:35,460
um you can do that for you on your local

740
00:27:35,460 --> 00:27:37,260
machine never deploy that never ever

741
00:27:37,260 --> 00:27:38,640
deploy that because that means literally

742
00:27:38,640 --> 00:27:40,320
every time it tries to match on that it

743
00:27:40,320 --> 00:27:41,820
is trying to match from a single byte to

744
00:27:41,820 --> 00:27:44,820
the end of the file the number of cycles

745
00:27:44,820 --> 00:27:46,200
and the amount of memory you're wasting

746
00:27:46,200 --> 00:27:49,440
is obscene you're you're you're the

747
00:27:49,440 --> 00:27:51,779
whole in the ozone layer okay

748
00:27:51,779 --> 00:27:54,120
um Wild Card same thing dot star please

749
00:27:54,120 --> 00:27:56,520
don't because dot star does the exact

750
00:27:56,520 --> 00:27:58,320
same thing if it's unbounded and then

751
00:27:58,320 --> 00:28:00,179
use alternation sparingly so for those

752
00:28:00,179 --> 00:28:02,640
of you that that know regex alternation

753
00:28:02,640 --> 00:28:05,520
right is parentheses value pipe value

754
00:28:05,520 --> 00:28:08,520
pipe value parentheses right and it

755
00:28:08,520 --> 00:28:11,159
means if any of those values exist in

756
00:28:11,159 --> 00:28:14,039
this position in the string that's valid

757
00:28:14,039 --> 00:28:16,080
it's okay to use that and actually I

758
00:28:16,080 --> 00:28:17,820
highly recommend it especially in the

759
00:28:17,820 --> 00:28:19,440
bite strings that's a super handy

760
00:28:19,440 --> 00:28:22,320
feature to to have but keep in mind if

761
00:28:22,320 --> 00:28:24,240
you have multiple alternates and a

762
00:28:24,240 --> 00:28:27,779
single regex you're that's not

763
00:28:27,779 --> 00:28:29,279
um that's not a coefficient right that's

764
00:28:29,279 --> 00:28:31,200
an exponent to the number of strings

765
00:28:31,200 --> 00:28:33,120
that have to be pre-computed in order to

766
00:28:33,120 --> 00:28:35,820
do your in order for your rule to run so

767
00:28:35,820 --> 00:28:37,799
keep those to a minimum and quite

768
00:28:37,799 --> 00:28:39,480
honestly if you're if you're if you're

769
00:28:39,480 --> 00:28:41,220
looking at your regex and you've got one

770
00:28:41,220 --> 00:28:43,919
that like line wraps and has a bunch of

771
00:28:43,919 --> 00:28:45,659
you know alternates and different tokens

772
00:28:45,659 --> 00:28:47,820
and things what you probably should have

773
00:28:47,820 --> 00:28:49,320
is a couple of smaller regular

774
00:28:49,320 --> 00:28:51,179
expressions and then work out the hard

775
00:28:51,179 --> 00:28:54,500
stuff in the conditions

776
00:28:54,779 --> 00:28:56,820
um and then finally order of operations

777
00:28:56,820 --> 00:28:58,799
uh you might think order of operations

778
00:28:58,799 --> 00:29:00,720
matters that Yara doesn't care about

779
00:29:00,720 --> 00:29:02,700
your order of operations

780
00:29:02,700 --> 00:29:04,500
um so a little bit about the r compiler

781
00:29:04,500 --> 00:29:07,020
and credit where credit is due um so I I

782
00:29:07,020 --> 00:29:09,659
will link it at the end but all of this

783
00:29:09,659 --> 00:29:12,600
information comes from uh uh you know

784
00:29:12,600 --> 00:29:14,880
it's a paper that Florian Roth wrote

785
00:29:14,880 --> 00:29:16,980
that's sitting out on GitHub it is the

786
00:29:16,980 --> 00:29:19,320
paper on Yara performance and how it

787
00:29:19,320 --> 00:29:21,600
works if you need to go deep on this

788
00:29:21,600 --> 00:29:22,559
especially if you're going to be

789
00:29:22,559 --> 00:29:24,179
scanning tens of thousands of files or

790
00:29:24,179 --> 00:29:25,740
trying to do real time you are a highly

791
00:29:25,740 --> 00:29:27,779
recommend reading it but I'll try and

792
00:29:27,779 --> 00:29:30,600
give you the high level overview so Yara

793
00:29:30,600 --> 00:29:31,980
does two things when it compiles your

794
00:29:31,980 --> 00:29:35,880
rule it optimizes strings and it does

795
00:29:35,880 --> 00:29:37,919
condition optimization with strings

796
00:29:37,919 --> 00:29:40,440
optimization there's this concept called

797
00:29:40,440 --> 00:29:42,960
atoms where it it will take a larger

798
00:29:42,960 --> 00:29:46,140
string so let's say a high a long string

799
00:29:46,140 --> 00:29:50,399
you know with good anchoring will it'll

800
00:29:50,399 --> 00:29:52,260
take three or four byte chunks out of it

801
00:29:52,260 --> 00:29:54,419
now it's got its own algorithm as to

802
00:29:54,419 --> 00:29:56,640
which you know it will try and take

803
00:29:56,640 --> 00:29:59,039
right but like if you you know if if you

804
00:29:59,039 --> 00:30:01,740
had a long string that on one end had a

805
00:30:01,740 --> 00:30:04,320
wide amount of variety and at the other

806
00:30:04,320 --> 00:30:08,039
end was like all A's right it's going to

807
00:30:08,039 --> 00:30:09,960
pick stuff where there's more variety

808
00:30:09,960 --> 00:30:11,640
right where there's distance between the

809
00:30:11,640 --> 00:30:13,020
bites

810
00:30:13,020 --> 00:30:14,760
and then once it builds that list of

811
00:30:14,760 --> 00:30:16,980
atoms it searches the entire length of

812
00:30:16,980 --> 00:30:19,620
the file from position zero to the end

813
00:30:19,620 --> 00:30:22,559
of the file and creates an index of all

814
00:30:22,559 --> 00:30:25,140
those atomic matches it doesn't matter

815
00:30:25,140 --> 00:30:27,000
what's in your condition statement so

816
00:30:27,000 --> 00:30:28,679
you might think your condition statement

817
00:30:28,679 --> 00:30:30,779
that says you know hey if this is if

818
00:30:30,779 --> 00:30:32,220
this isn't the first bite of the file

819
00:30:32,220 --> 00:30:34,440
quit and go away that seems like a good

820
00:30:34,440 --> 00:30:36,240
optimization strategy but it's actually

821
00:30:36,240 --> 00:30:38,760
not for Yara unfortunately it's still

822
00:30:38,760 --> 00:30:41,039
good for you from uh from a you know an

823
00:30:41,039 --> 00:30:43,080
assurance perspective but it doesn't

824
00:30:43,080 --> 00:30:46,080
make the rule faster doing it that way

825
00:30:46,080 --> 00:30:48,720
um and then finally then it after it

826
00:30:48,720 --> 00:30:50,220
builds that index it goes through and

827
00:30:50,220 --> 00:30:52,140
searches for each of the full string

828
00:30:52,140 --> 00:30:54,299
matches by expanding the strings looking

829
00:30:54,299 --> 00:30:56,880
at wild cards and regular Expressions so

830
00:30:56,880 --> 00:30:58,440
that's how it optimizes the matches

831
00:30:58,440 --> 00:31:00,059
right it picks what it thinks are going

832
00:31:00,059 --> 00:31:01,740
to be some good bite chunks comes up

833
00:31:01,740 --> 00:31:03,539
with an index and then expands each of

834
00:31:03,539 --> 00:31:06,000
the searches locally within those

835
00:31:06,000 --> 00:31:07,679
positions so that it doesn't have to run

836
00:31:07,679 --> 00:31:09,659
your terrible regex over the entirety of

837
00:31:09,659 --> 00:31:11,279
the file

838
00:31:11,279 --> 00:31:12,000
um

839
00:31:12,000 --> 00:31:15,120
and then condition optimization so it

840
00:31:15,120 --> 00:31:17,399
picks the which checks it runs first so

841
00:31:17,399 --> 00:31:19,799
simple logic right so this equals this

842
00:31:19,799 --> 00:31:22,799
this is present this is true uh imagine

843
00:31:22,799 --> 00:31:25,260
if you already and this is why it does

844
00:31:25,260 --> 00:31:26,760
the simple test first right if you're

845
00:31:26,760 --> 00:31:28,200
just checking for the presence of a

846
00:31:28,200 --> 00:31:30,600
string well it already has the the atoms

847
00:31:30,600 --> 00:31:33,240
in index that make up your string if any

848
00:31:33,240 --> 00:31:35,220
of those don't exist in the indices that

849
00:31:35,220 --> 00:31:38,039
are referenced in your condition then it

850
00:31:38,039 --> 00:31:40,980
can quit right then it then moves on to

851
00:31:40,980 --> 00:31:43,440
expensive operations like math and you

852
00:31:43,440 --> 00:31:44,880
know comparative so it'll do simple

853
00:31:44,880 --> 00:31:47,039
things like equal and then eventually

854
00:31:47,039 --> 00:31:49,140
moves on to comparatives like greater

855
00:31:49,140 --> 00:31:51,299
than less than and then eventually other

856
00:31:51,299 --> 00:31:54,720
things like ranges and then finally it

857
00:31:54,720 --> 00:31:58,440
does module calls last so uh and that

858
00:31:58,440 --> 00:32:00,179
and the re and so that's the performance

859
00:32:00,179 --> 00:32:01,919
trick for modules right is is that

860
00:32:01,919 --> 00:32:03,720
modules that last if if the other

861
00:32:03,720 --> 00:32:05,460
conditions aren't met the module never

862
00:32:05,460 --> 00:32:07,799
runs

863
00:32:07,799 --> 00:32:10,200
all right so example of good rule bad

864
00:32:10,200 --> 00:32:11,220
rule

865
00:32:11,220 --> 00:32:13,200
um so these two rules do the exact same

866
00:32:13,200 --> 00:32:15,779
thing they detect PE file similar to the

867
00:32:15,779 --> 00:32:19,440
dll rule I showed you earlier so

868
00:32:19,440 --> 00:32:22,020
in this case we have the good rule has a

869
00:32:22,020 --> 00:32:25,260
single string this program cannot you

870
00:32:25,260 --> 00:32:27,000
could do this program cannot be run in

871
00:32:27,000 --> 00:32:28,799
DOS mode except I will tell you that

872
00:32:28,799 --> 00:32:30,779
there are more variations of this string

873
00:32:30,779 --> 00:32:32,520
than you would think out there in the

874
00:32:32,520 --> 00:32:35,760
wild so I like I actually my personal

875
00:32:35,760 --> 00:32:38,159
for hunting is I use his program can

876
00:32:38,159 --> 00:32:40,440
that sounds silly but you get some

877
00:32:40,440 --> 00:32:43,500
variation in casing and and wording um

878
00:32:43,500 --> 00:32:46,200
in in DOS subheaders for whatever reason

879
00:32:46,200 --> 00:32:48,120
you know Delphi does some weird stuff

880
00:32:48,120 --> 00:32:50,940
things uh anyway but it's a nice it's a

881
00:32:50,940 --> 00:32:52,980
nice string High degree of cardinality

882
00:32:52,980 --> 00:32:55,559
or sorry low degree of cardinality good

883
00:32:55,559 --> 00:32:59,760
anchoring and then uh we're not creating

884
00:32:59,760 --> 00:33:01,679
um and then and then we go directly to

885
00:33:01,679 --> 00:33:04,500
the you know the byte comparisons for is

886
00:33:04,500 --> 00:33:06,779
it a is it you know are the first two

887
00:33:06,779 --> 00:33:09,120
bytes MZ does it have a PE header and

888
00:33:09,120 --> 00:33:11,100
then does this string exist and we give

889
00:33:11,100 --> 00:33:13,380
it a particular position

890
00:33:13,380 --> 00:33:16,799
the bad rule we declare these as

891
00:33:16,799 --> 00:33:19,080
um as strings so they all get searched

892
00:33:19,080 --> 00:33:20,460
first well what do you think happens

893
00:33:20,460 --> 00:33:22,980
when we search you know for two bytes

894
00:33:22,980 --> 00:33:25,200
right it can't atomize it so it's got to

895
00:33:25,200 --> 00:33:26,880
do a full strength you know full search

896
00:33:26,880 --> 00:33:30,120
for for everything across that we break

897
00:33:30,120 --> 00:33:32,159
those up which means that we lose the

898
00:33:32,159 --> 00:33:34,080
context and positioning and ordering

899
00:33:34,080 --> 00:33:36,120
among those strings and the PE header

900
00:33:36,120 --> 00:33:38,340
and then trying to do PE header in a

901
00:33:38,340 --> 00:33:40,919
Range rather than being specific about

902
00:33:40,919 --> 00:33:43,620
where it should be based on offset

903
00:33:43,620 --> 00:33:46,260
um you know so interestingly enough that

904
00:33:46,260 --> 00:33:50,039
uint 16 equals 5A 4D

905
00:33:50,039 --> 00:33:52,559
is significantly more performant than

906
00:33:52,559 --> 00:33:55,080
just declaring MZ and saying MZ at zero

907
00:33:55,080 --> 00:33:57,960
literally logically identical but from a

908
00:33:57,960 --> 00:33:59,880
performance standpoint because Yara

909
00:33:59,880 --> 00:34:01,980
doesn't care about your conditions until

910
00:34:01,980 --> 00:34:04,080
it's done searching the file you're

911
00:34:04,080 --> 00:34:07,500
running an expensive search before you

912
00:34:07,500 --> 00:34:09,780
get to the logic piece right so hence

913
00:34:09,780 --> 00:34:11,159
the optimization so it's a little

914
00:34:11,159 --> 00:34:14,040
counter-intuitive but this is uh trust

915
00:34:14,040 --> 00:34:16,440
me the the two rules uh perform very

916
00:34:16,440 --> 00:34:18,418
differently

917
00:34:18,418 --> 00:34:19,980
so but let's talk about a rule that

918
00:34:19,980 --> 00:34:23,179
performed even more differently

919
00:34:24,480 --> 00:34:27,239
so Yara added support for xor matching

920
00:34:27,239 --> 00:34:28,980
on strings which is awesome if you've

921
00:34:28,980 --> 00:34:31,440
ever run into xor as obfuscation

922
00:34:31,440 --> 00:34:34,320
this is super handy to to be able to uh

923
00:34:34,320 --> 00:34:37,199
to do this kind of uh detection this is

924
00:34:37,199 --> 00:34:39,659
actually a use case that I ran into not

925
00:34:39,659 --> 00:34:41,280
that long ago

926
00:34:41,280 --> 00:34:42,960
um and it was like oh well I'll just

927
00:34:42,960 --> 00:34:44,580
look for you know I'll go back and look

928
00:34:44,580 --> 00:34:46,918
over so what I found was a DOT lnk file

929
00:34:46,918 --> 00:34:49,379
right uh uh you know a Windows shortcut

930
00:34:49,379 --> 00:34:52,260
file that contained within it um some

931
00:34:52,260 --> 00:34:56,280
Powershell that actually uh took the

932
00:34:56,280 --> 00:34:59,700
file at a particular position and you

933
00:34:59,700 --> 00:35:02,640
know xored it by a single byte key and

934
00:35:02,640 --> 00:35:06,300
extracted a whole ass rat like on the

935
00:35:06,300 --> 00:35:08,220
disc and then ran the rat which is yo

936
00:35:08,220 --> 00:35:09,780
that's a nice trick if you can get it I

937
00:35:09,780 --> 00:35:11,400
had I had seen the Cobalt strike version

938
00:35:11,400 --> 00:35:13,980
of that where the where the the payloads

939
00:35:13,980 --> 00:35:15,900
actually in the base64 Powershell script

940
00:35:15,900 --> 00:35:17,220
but those are pretty easy to detect

941
00:35:17,220 --> 00:35:19,140
because you know it's base64 and a link

942
00:35:19,140 --> 00:35:20,339
file

943
00:35:20,339 --> 00:35:21,960
um this was a workaround for it which I

944
00:35:21,960 --> 00:35:24,300
thought was pretty novel but I thought

945
00:35:24,300 --> 00:35:26,099
you know hey well how do I how do I go

946
00:35:26,099 --> 00:35:27,119
about this right because I don't

947
00:35:27,119 --> 00:35:29,460
necessarily have a file structure to

948
00:35:29,460 --> 00:35:30,720
work from so I'm just going to look for

949
00:35:30,720 --> 00:35:32,940
some header artifacts and uh I got

950
00:35:32,940 --> 00:35:35,099
yelled at by Yara as you can see there

951
00:35:35,099 --> 00:35:36,960
at the bottom

952
00:35:36,960 --> 00:35:39,960
um so this particular link file is 88k

953
00:35:39,960 --> 00:35:41,760
it's a pretty small file in fact I'll be

954
00:35:41,760 --> 00:35:45,300
specific it was 89 878 bytes right

955
00:35:45,300 --> 00:35:48,660
that's a little file how many times do

956
00:35:48,660 --> 00:35:51,119
you think that the xor extrapolation of

957
00:35:51,119 --> 00:35:54,740
MZ appeared in that file

958
00:35:55,020 --> 00:35:56,579
it was

959
00:35:56,579 --> 00:35:59,480
a couple times

960
00:36:01,440 --> 00:36:03,780
um so if you guessed that it was 526

961
00:36:03,780 --> 00:36:08,099
matches in an 89k file then you must

962
00:36:08,099 --> 00:36:11,400
have downloaded the the GitHub repo at

963
00:36:11,400 --> 00:36:13,320
the beginning and be playing at home but

964
00:36:13,320 --> 00:36:16,260
yeah 1.2 percent of the file matches why

965
00:36:16,260 --> 00:36:18,599
well because M and Z you know capital m

966
00:36:18,599 --> 00:36:20,280
capital Z they're they're at a distance

967
00:36:20,280 --> 00:36:23,640
of 13 and basically by X or encoding

968
00:36:23,640 --> 00:36:27,119
them by all 256 potential values you

969
00:36:27,119 --> 00:36:29,579
essentially end up with

970
00:36:29,579 --> 00:36:31,980
um you know every two byte sequence that

971
00:36:31,980 --> 00:36:34,140
has an exact distance of 13 matches and

972
00:36:34,140 --> 00:36:37,440
happens a lot we'll just say a lot

973
00:36:37,440 --> 00:36:38,280
um

974
00:36:38,280 --> 00:36:40,260
it's a really terrible performance bad

975
00:36:40,260 --> 00:36:41,940
rule so if we were to go back and

976
00:36:41,940 --> 00:36:43,500
revisit this like how would you tune

977
00:36:43,500 --> 00:36:46,040
this rule

978
00:36:50,040 --> 00:36:51,660
the answer is pretty easy we just take

979
00:36:51,660 --> 00:36:53,700
that out we leave the the we leave the

980
00:36:53,700 --> 00:36:55,440
lower cardinality string in that only

981
00:36:55,440 --> 00:36:57,000
had one hit

982
00:36:57,000 --> 00:37:00,420
um and we take this out

983
00:37:00,420 --> 00:37:03,540
a better solution

984
00:37:03,540 --> 00:37:06,900
is to do this so this is my Pro tip on

985
00:37:06,900 --> 00:37:09,180
xor if you're going to be using Yara for

986
00:37:09,180 --> 00:37:11,880
xor they had this really cool feature

987
00:37:11,880 --> 00:37:13,740
where you actually get to find keys and

988
00:37:13,740 --> 00:37:15,960
key ranges so you can say xorbit just

989
00:37:15,960 --> 00:37:18,540
give the specific key or you can

990
00:37:18,540 --> 00:37:20,760
actually you know give it a range and so

991
00:37:20,760 --> 00:37:22,740
in this case I'm intentionally excluding

992
00:37:22,740 --> 00:37:25,079
two xor values

993
00:37:25,079 --> 00:37:28,380
um the first one is zero anybody know

994
00:37:28,380 --> 00:37:31,820
why we exclude X or zero

995
00:37:32,280 --> 00:37:34,200
if you X or a value by zero it's just

996
00:37:34,200 --> 00:37:35,940
the value it's like multiplying by one

997
00:37:35,940 --> 00:37:39,180
right and the other one and this one I

998
00:37:39,180 --> 00:37:40,619
only you know this is this is just me

999
00:37:40,619 --> 00:37:42,240
showing you another Scar the other one

1000
00:37:42,240 --> 00:37:45,180
is hexadecimal 20 which is decimal 32

1001
00:37:45,180 --> 00:37:49,500
and if you xor uh an ASCII character an

1002
00:37:49,500 --> 00:37:53,700
alpha an alphabetic character by xor hex

1003
00:37:53,700 --> 00:37:54,780
20.

1004
00:37:54,780 --> 00:37:57,900
you will get the case alternate so you

1005
00:37:57,900 --> 00:37:59,880
will take lowercase characters and make

1006
00:37:59,880 --> 00:38:01,260
them uppercase and uppercase characters

1007
00:38:01,260 --> 00:38:03,420
make them lowercase

1008
00:38:03,420 --> 00:38:07,500
I there's there's probably a PhD level

1009
00:38:07,500 --> 00:38:10,380
Computer Science History paper on how we

1010
00:38:10,380 --> 00:38:12,540
got there like going all the way back to

1011
00:38:12,540 --> 00:38:15,420
like ancient Greece and then decisions

1012
00:38:15,420 --> 00:38:18,240
made you know by antsy and things like

1013
00:38:18,240 --> 00:38:19,560
that when we decided what characters

1014
00:38:19,560 --> 00:38:22,619
were what you know what by values but

1015
00:38:22,619 --> 00:38:25,619
anyway so those are my tips though don't

1016
00:38:25,619 --> 00:38:27,240
use either of those if you're if you're

1017
00:38:27,240 --> 00:38:29,160
looking for obfuscation avoid using

1018
00:38:29,160 --> 00:38:32,099
those two particular X or keys

1019
00:38:32,099 --> 00:38:34,980
all right cool we're doing all right on

1020
00:38:34,980 --> 00:38:36,000
time

1021
00:38:36,000 --> 00:38:38,579
um so so now it's about to get weird

1022
00:38:38,579 --> 00:38:41,099
um we're gonna write a Yara rule today

1023
00:38:41,099 --> 00:38:43,680
well first let me uh let me let me let

1024
00:38:43,680 --> 00:38:46,260
me introduce you to my guy uh so this is

1025
00:38:46,260 --> 00:38:47,460
jaywow

1026
00:38:47,460 --> 00:38:49,560
um I I think I think the the appropriate

1027
00:38:49,560 --> 00:38:51,960
uh uh

1028
00:38:51,960 --> 00:38:53,880
Brazilian Portuguese pronounced in the

1029
00:38:53,880 --> 00:38:56,339
Asian is joao which I think is like an

1030
00:38:56,339 --> 00:38:58,140
equivalent to to John

1031
00:38:58,140 --> 00:39:01,920
um but uh uh but I've I've been stalking

1032
00:39:01,920 --> 00:39:04,200
this guy's malware for a few years now

1033
00:39:04,200 --> 00:39:06,420
um so he's he's JWoww this is an old

1034
00:39:06,420 --> 00:39:07,800
picture of him it's the only one I've

1035
00:39:07,800 --> 00:39:09,540
been able to find

1036
00:39:09,540 --> 00:39:11,520
um but uh but he's got a YouTube channel

1037
00:39:11,520 --> 00:39:14,400
and some other stuff he's uh you you can

1038
00:39:14,400 --> 00:39:16,140
find him on HF and a few other places

1039
00:39:16,140 --> 00:39:19,020
and this summer he started playing with

1040
00:39:19,020 --> 00:39:23,460
a new dropper that he wrote in uh in.net

1041
00:39:23,460 --> 00:39:25,800
uh and I didn't have any Yara for it I

1042
00:39:25,800 --> 00:39:28,260
hadn't seen it before and I knew that I

1043
00:39:28,260 --> 00:39:29,579
had to write I was working on this

1044
00:39:29,579 --> 00:39:31,920
presentation on Yara rules anyway for

1045
00:39:31,920 --> 00:39:34,260
b-sides Augustine I was like you know

1046
00:39:34,260 --> 00:39:37,740
what YOLO right like why not why not why

1047
00:39:37,740 --> 00:39:39,839
not write a Yara rule together and if

1048
00:39:39,839 --> 00:39:41,220
for no other reason than to kind of walk

1049
00:39:41,220 --> 00:39:43,200
you through how I approach this process

1050
00:39:43,200 --> 00:39:45,780
which may come as a disappointment to

1051
00:39:45,780 --> 00:39:48,839
some of you because it's not as hard or

1052
00:39:48,839 --> 00:39:51,180
as cool as it sounds but

1053
00:39:51,180 --> 00:39:52,200
um

1054
00:39:52,200 --> 00:39:53,700
so

1055
00:39:53,700 --> 00:39:56,339
let me see

1056
00:39:56,339 --> 00:39:59,400
can you all see my VM nice all right so

1057
00:39:59,400 --> 00:40:02,220
these are eight samples that I pulled

1058
00:40:02,220 --> 00:40:04,079
you're probably like well how are you

1059
00:40:04,079 --> 00:40:06,480
attributing to this guy I'm gonna just

1060
00:40:06,480 --> 00:40:07,980
ask that you trust me if you want to see

1061
00:40:07,980 --> 00:40:10,320
receipts later I'll walk you through it

1062
00:40:10,320 --> 00:40:12,599
um but you know I can tie most of this

1063
00:40:12,599 --> 00:40:15,359
stuff back to his username in a few

1064
00:40:15,359 --> 00:40:17,520
different places and and uh he hasn't

1065
00:40:17,520 --> 00:40:19,440
done a video on this one yet so the fun

1066
00:40:19,440 --> 00:40:20,940
thing is we're actually going to get to

1067
00:40:20,940 --> 00:40:23,700
see a couple of Dev versions that he's

1068
00:40:23,700 --> 00:40:27,000
been deploying in fact the other implant

1069
00:40:27,000 --> 00:40:30,000
that this drops is named teste which is

1070
00:40:30,000 --> 00:40:31,280
just the you know

1071
00:40:31,280 --> 00:40:34,200
Portuguese for test right and he's he's

1072
00:40:34,200 --> 00:40:36,480
got a dummy implant out there that he's

1073
00:40:36,480 --> 00:40:38,640
been deploying all over the place just

1074
00:40:38,640 --> 00:40:40,800
to get his attack chain working so

1075
00:40:40,800 --> 00:40:42,119
that's kind of fun right it's neat to

1076
00:40:42,119 --> 00:40:44,339
watch an adversary work uh live in the

1077
00:40:44,339 --> 00:40:45,599
wild

1078
00:40:45,599 --> 00:40:46,500
um

1079
00:40:46,500 --> 00:40:48,420
so first you know what do we know about

1080
00:40:48,420 --> 00:40:50,940
these samples

1081
00:40:50,940 --> 00:40:52,640
um I just hit them with file

1082
00:40:52,640 --> 00:40:55,619
and so uh can everybody read that okay

1083
00:40:55,619 --> 00:40:58,700
or is it too small

1084
00:40:59,280 --> 00:41:00,540
all right

1085
00:41:00,540 --> 00:41:02,040
um

1086
00:41:02,040 --> 00:41:05,040
see if I can so anyway if if you're if

1087
00:41:05,040 --> 00:41:07,320
you're not able to see um it's you know

1088
00:41:07,320 --> 00:41:10,140
uh they're they're all dlls so these are

1089
00:41:10,140 --> 00:41:11,940
drop dlls they're they're coming in

1090
00:41:11,940 --> 00:41:14,520
through it's a it's a it's a ugly

1091
00:41:14,520 --> 00:41:16,440
combination uh

1092
00:41:16,440 --> 00:41:19,200
Windows scripting host to Powershell

1093
00:41:19,200 --> 00:41:22,260
back to Windows scripting host uh

1094
00:41:22,260 --> 00:41:25,260
dropper to run32 dll

1095
00:41:25,260 --> 00:41:26,720
or run

1096
00:41:26,720 --> 00:41:30,780
dll32.exe sorry so anyway

1097
00:41:30,780 --> 00:41:32,579
so but these are roughly the same size

1098
00:41:32,579 --> 00:41:34,980
and have a similar origin so the first

1099
00:41:34,980 --> 00:41:36,480
thing that I like to do when I'm looking

1100
00:41:36,480 --> 00:41:38,339
at these especially now that I know okay

1101
00:41:38,339 --> 00:41:40,560
it's a dll and it's a DOT and it's dot

1102
00:41:40,560 --> 00:41:42,619
net so something that I already know

1103
00:41:42,619 --> 00:41:46,320
about.net is in a lot of cases there's a

1104
00:41:46,320 --> 00:41:49,140
there's a strings object uh that you

1105
00:41:49,140 --> 00:41:50,579
know and a bunch of different like

1106
00:41:50,579 --> 00:41:53,520
resource uh blocks in the in the.net

1107
00:41:53,520 --> 00:41:55,619
directory and when it stores strings it

1108
00:41:55,619 --> 00:41:58,140
stores them as wide strings so the first

1109
00:41:58,140 --> 00:41:59,820
thing we'll do is just extract all the

1110
00:41:59,820 --> 00:42:02,220
wide strings

1111
00:42:02,220 --> 00:42:05,339
um and in Linux that's Dash El so uh

1112
00:42:05,339 --> 00:42:07,800
Linux you know it's it's long strings as

1113
00:42:07,800 --> 00:42:10,380
opposed to wide strings but it means the

1114
00:42:10,380 --> 00:42:11,820
same thing

1115
00:42:11,820 --> 00:42:16,020
um all the files will just sort them

1116
00:42:16,020 --> 00:42:19,320
and then we'll use unique to get a count

1117
00:42:19,320 --> 00:42:20,940
and then we'll sort the output from

1118
00:42:20,940 --> 00:42:25,280
unique in Reverse numerical order

1119
00:42:25,619 --> 00:42:28,320
and pipe to less

1120
00:42:28,320 --> 00:42:30,060
and so what we get is this list of

1121
00:42:30,060 --> 00:42:33,000
strings and you can see so the first

1122
00:42:33,000 --> 00:42:35,460
thing we know is if the count on these

1123
00:42:35,460 --> 00:42:36,960
strings is less than eight because we

1124
00:42:36,960 --> 00:42:38,880
have eight samples then those strings

1125
00:42:38,880 --> 00:42:40,740
don't appear in all the files so we can

1126
00:42:40,740 --> 00:42:43,020
exclude them from detection doesn't mean

1127
00:42:43,020 --> 00:42:45,359
that they're not useful for later

1128
00:42:45,359 --> 00:42:48,119
analysis and intelligence purposes but

1129
00:42:48,119 --> 00:42:49,140
they're not going to make good detection

1130
00:42:49,140 --> 00:42:51,180
because they aren't Universal but

1131
00:42:51,180 --> 00:42:52,800
everything that's got an eight or better

1132
00:42:52,800 --> 00:42:55,500
next to it is fair game so now we're

1133
00:42:55,500 --> 00:42:57,780
going to look around and see you know I

1134
00:42:57,780 --> 00:42:59,040
don't know how many of you looked at the

1135
00:42:59,040 --> 00:43:01,020
tail end of.net binaries before but

1136
00:43:01,020 --> 00:43:02,520
you'll see a lot of things you recognize

1137
00:43:02,520 --> 00:43:04,740
in there like legal trademarks legal

1138
00:43:04,740 --> 00:43:06,540
copyright internal name right that's all

1139
00:43:06,540 --> 00:43:08,520
just the visual studio does for you when

1140
00:43:08,520 --> 00:43:10,920
you name a project if you decide to so

1141
00:43:10,920 --> 00:43:12,300
that just lets you know that he's using

1142
00:43:12,300 --> 00:43:14,640
visual Studios no surprise but tons of

1143
00:43:14,640 --> 00:43:16,140
stuff is going to match on those so

1144
00:43:16,140 --> 00:43:17,579
we're really only interested in a

1145
00:43:17,579 --> 00:43:19,980
handful of strings here that might be

1146
00:43:19,980 --> 00:43:22,440
unique so the first one at the top up

1147
00:43:22,440 --> 00:43:24,599
there that's odd that that sort of

1148
00:43:24,599 --> 00:43:27,599
random looking string would occur 32

1149
00:43:27,599 --> 00:43:28,980
times which would tell you there's

1150
00:43:28,980 --> 00:43:31,560
probably four copies in every file of

1151
00:43:31,560 --> 00:43:33,359
that

1152
00:43:33,359 --> 00:43:35,640
um so that's a good one we'll grab that

1153
00:43:35,640 --> 00:43:38,000
string

1154
00:43:41,060 --> 00:43:43,319
there's a couple others over there I

1155
00:43:43,319 --> 00:43:46,260
mean there's the name of the dll and

1156
00:43:46,260 --> 00:43:49,619
then resources so that's interesting

1157
00:43:49,619 --> 00:43:52,700
we'll grab those

1158
00:43:57,240 --> 00:43:59,339
and kind of looking around I'm not

1159
00:43:59,339 --> 00:44:01,800
seeing anything else in the eight count

1160
00:44:01,800 --> 00:44:04,560
that's necessarily super useful there so

1161
00:44:04,560 --> 00:44:06,540
let's switch over to the ASCII strings

1162
00:44:06,540 --> 00:44:10,740
or in this case s for short strings so

1163
00:44:10,740 --> 00:44:12,180
you see all I'm doing is just changing

1164
00:44:12,180 --> 00:44:13,980
the E to an l and now we're going to get

1165
00:44:13,980 --> 00:44:17,400
out the non-uh non-null padded string

1166
00:44:17,400 --> 00:44:19,560
values there's quite a few more of these

1167
00:44:19,560 --> 00:44:21,839
but again we're only looking for ones

1168
00:44:21,839 --> 00:44:25,260
that have eight or more 15 is always

1169
00:44:25,260 --> 00:44:26,640
scary because that would tell you that

1170
00:44:26,640 --> 00:44:30,359
there's two in every file except one

1171
00:44:30,359 --> 00:44:32,760
that only has one and but in those cases

1172
00:44:32,760 --> 00:44:34,260
in this case those aren't particularly

1173
00:44:34,260 --> 00:44:35,880
great strings either the dispose

1174
00:44:35,880 --> 00:44:38,700
instance create instance we can see pad

1175
00:44:38,700 --> 00:44:41,880
pad and a few other things but we see we

1176
00:44:41,880 --> 00:44:46,020
get a repeat of this y i p p h b so

1177
00:44:46,020 --> 00:44:49,020
we'll take that that's interesting

1178
00:44:49,020 --> 00:44:51,079
um

1179
00:44:59,460 --> 00:45:03,200
just Mark these up here

1180
00:45:04,579 --> 00:45:07,380
another interesting one that kind of

1181
00:45:07,380 --> 00:45:09,900
pops out to me is this version number

1182
00:45:09,900 --> 00:45:12,000
right here

1183
00:45:12,000 --> 00:45:14,000
um

1184
00:45:14,819 --> 00:45:18,740
so we'll steal that one oops

1185
00:45:31,079 --> 00:45:33,420
what am I doing wrong here I'm failing

1186
00:45:33,420 --> 00:45:35,940
it copy paste that's

1187
00:45:35,940 --> 00:45:39,020
doesn't bode well

1188
00:45:40,619 --> 00:45:43,220
happy

1189
00:45:44,099 --> 00:45:45,660
all right

1190
00:45:45,660 --> 00:45:46,859
um

1191
00:45:46,859 --> 00:45:49,020
so and as we as we look around you know

1192
00:45:49,020 --> 00:45:50,880
I see a bunch of other kind of code

1193
00:45:50,880 --> 00:45:52,260
related stuff that's potentially

1194
00:45:52,260 --> 00:45:55,380
interesting we do see that uh you know

1195
00:45:55,380 --> 00:45:57,839
further down we see that ppps

1196
00:45:57,839 --> 00:46:01,859
XT qiu does repeat so maybe we grab that

1197
00:46:01,859 --> 00:46:04,700
one as well

1198
00:46:11,400 --> 00:46:13,560
because that's

1199
00:46:13,560 --> 00:46:15,540
interesting and it shows up in both

1200
00:46:15,540 --> 00:46:18,060
cases we can see let's see what else

1201
00:46:18,060 --> 00:46:19,740
have we got there's quite a few oh

1202
00:46:19,740 --> 00:46:21,300
there's some interesting stuff down here

1203
00:46:21,300 --> 00:46:23,940
killed

1204
00:46:23,940 --> 00:46:27,060
hide module attribute name that's that's

1205
00:46:27,060 --> 00:46:30,140
potentially interesting

1206
00:46:31,319 --> 00:46:35,180
especially if it's actually being used

1207
00:46:36,720 --> 00:46:39,599
instances probably not super useful in

1208
00:46:39,599 --> 00:46:41,640
this case

1209
00:46:41,640 --> 00:46:42,660
um

1210
00:46:42,660 --> 00:46:47,819
we've got some uh debugger modes

1211
00:46:47,819 --> 00:46:51,440
debuggable attributes

1212
00:46:51,839 --> 00:46:53,760
by the way if you see things here that

1213
00:46:53,760 --> 00:46:55,079
you think are are potentially

1214
00:46:55,079 --> 00:46:56,819
interesting

1215
00:46:56,819 --> 00:46:57,420
um

1216
00:46:57,420 --> 00:46:59,700
you know as we're as we're kind of

1217
00:46:59,700 --> 00:47:02,099
scrolling through some of these

1218
00:47:02,099 --> 00:47:03,480
um

1219
00:47:03,480 --> 00:47:06,780
don't hesitate to shout them out

1220
00:47:06,780 --> 00:47:09,060
okay

1221
00:47:09,060 --> 00:47:11,160
ooh right process memory that's a good

1222
00:47:11,160 --> 00:47:12,300
one

1223
00:47:12,300 --> 00:47:16,160
but there's only seven of those

1224
00:47:16,800 --> 00:47:19,079
oh but there we go here we go

1225
00:47:19,079 --> 00:47:23,420
get processed by ID that's

1226
00:47:23,579 --> 00:47:26,599
maybe helpful

1227
00:47:44,760 --> 00:47:46,740
all right well that's a good start so

1228
00:47:46,740 --> 00:47:48,180
what we've done though is just go

1229
00:47:48,180 --> 00:47:50,099
through and look for a list of strings

1230
00:47:50,099 --> 00:47:52,200
that kind of exist across or what

1231
00:47:52,200 --> 00:47:54,240
probably exists across most of the files

1232
00:47:54,240 --> 00:47:56,220
the next thing though before we start

1233
00:47:56,220 --> 00:47:58,800
writing a rule is let's get an idea of

1234
00:47:58,800 --> 00:48:00,359
what the context of some of these things

1235
00:48:00,359 --> 00:48:01,859
is

1236
00:48:01,859 --> 00:48:03,420
so I'm going to flip over to my handy

1237
00:48:03,420 --> 00:48:06,720
flare VM machine where I've got dnspy

1238
00:48:06,720 --> 00:48:08,060
loaded

1239
00:48:08,060 --> 00:48:11,040
and you know so it's a live demo but

1240
00:48:11,040 --> 00:48:14,339
it's not totally uncooked there are two

1241
00:48:14,339 --> 00:48:15,900
there are two different samples from

1242
00:48:15,900 --> 00:48:18,119
that folder set shown here so you can

1243
00:48:18,119 --> 00:48:21,420
see one up top and one down below and

1244
00:48:21,420 --> 00:48:23,160
you'll notice there's a little bit of a

1245
00:48:23,160 --> 00:48:25,140
difference between the two where one of

1246
00:48:25,140 --> 00:48:31,440
them has pretty like crazy looking like

1247
00:48:31,440 --> 00:48:34,020
um you know resource names there

1248
00:48:34,020 --> 00:48:38,599
and the reason for that is that our our

1249
00:48:38,599 --> 00:48:44,160
adversary our actor has run

1250
00:48:44,160 --> 00:48:45,359
um

1251
00:48:45,359 --> 00:48:47,940
confuser acts over this which is a which

1252
00:48:47,940 --> 00:48:49,260
is a packer

1253
00:48:49,260 --> 00:48:51,180
um and so it's gone through and taken a

1254
00:48:51,180 --> 00:48:52,920
bunch of the variable names and so on

1255
00:48:52,920 --> 00:48:54,599
and renamed them to kind of ridiculous

1256
00:48:54,599 --> 00:48:56,339
unpredictable things and we could

1257
00:48:56,339 --> 00:48:57,960
anticipate that if he's going to rerun

1258
00:48:57,960 --> 00:49:01,140
confuser X over this file every time he

1259
00:49:01,140 --> 00:49:02,700
launch it you know every time he creates

1260
00:49:02,700 --> 00:49:04,619
a new build these names are going to be

1261
00:49:04,619 --> 00:49:08,040
you know uh changed each time right so

1262
00:49:08,040 --> 00:49:10,380
what's actually useful here is we get a

1263
00:49:10,380 --> 00:49:13,020
sense of which code artifacts you know

1264
00:49:13,020 --> 00:49:15,359
down in um

1265
00:49:15,359 --> 00:49:19,020
uh down in in uh in the unobfuscated

1266
00:49:19,020 --> 00:49:20,700
version right where we can come in here

1267
00:49:20,700 --> 00:49:22,560
and actually look at the class and see

1268
00:49:22,560 --> 00:49:25,020
you know this is pretty much gonna you

1269
00:49:25,020 --> 00:49:26,520
know this will be fairly close to the

1270
00:49:26,520 --> 00:49:29,640
code as as the actor wrote it

1271
00:49:29,640 --> 00:49:30,599
um

1272
00:49:30,599 --> 00:49:32,640
but as you can see in the upper example

1273
00:49:32,640 --> 00:49:36,000
right a lot of the a lot of the useful

1274
00:49:36,000 --> 00:49:38,040
um you know code names and strings have

1275
00:49:38,040 --> 00:49:39,540
been have been blown away which is why

1276
00:49:39,540 --> 00:49:42,420
they don't exist in all of the files

1277
00:49:42,420 --> 00:49:45,060
so the important thing then is to start

1278
00:49:45,060 --> 00:49:47,579
looking at what are those pieces of the

1279
00:49:47,579 --> 00:49:50,040
file that do kind of persist and repeat

1280
00:49:50,040 --> 00:49:53,940
right so we'll start by looking at the

1281
00:49:53,940 --> 00:49:57,680
the actual module itself so that yipp

1282
00:49:57,680 --> 00:50:00,599
hb.dll that's what he named the the

1283
00:50:00,599 --> 00:50:03,060
module in the uh in the visual studio

1284
00:50:03,060 --> 00:50:05,520
project and we can flip around and see a

1285
00:50:05,520 --> 00:50:07,920
few things here we do see module type is

1286
00:50:07,920 --> 00:50:09,900
dll so it sort of validates what we were

1287
00:50:09,900 --> 00:50:11,460
seeing earlier

1288
00:50:11,460 --> 00:50:13,260
um oh we had seen that string before

1289
00:50:13,260 --> 00:50:16,920
that is in fact the.net version string

1290
00:50:16,920 --> 00:50:18,599
so we can actually use that in

1291
00:50:18,599 --> 00:50:20,900
constructing the file and yara's.net

1292
00:50:20,900 --> 00:50:23,640
module will let us actually key in on

1293
00:50:23,640 --> 00:50:25,380
that so it isn't just the presence of

1294
00:50:25,380 --> 00:50:27,060
that string but we can actually specify

1295
00:50:27,060 --> 00:50:30,420
how that string is being used

1296
00:50:30,420 --> 00:50:33,300
which is potentially helpful a few other

1297
00:50:33,300 --> 00:50:36,119
things we can look around at well again

1298
00:50:36,119 --> 00:50:38,760
we know it's a dll oh let's see what

1299
00:50:38,760 --> 00:50:39,720
else

1300
00:50:39,720 --> 00:50:40,319
um

1301
00:50:40,319 --> 00:50:43,020
well we can get down into this class uh

1302
00:50:43,020 --> 00:50:47,460
here so that Pol wkb

1303
00:50:47,460 --> 00:50:49,579
um

1304
00:50:50,760 --> 00:50:52,920
and we can poke around in here

1305
00:50:52,920 --> 00:50:55,920
interfaces

1306
00:50:57,240 --> 00:50:59,359
um

1307
00:51:00,059 --> 00:51:02,640
here we go

1308
00:51:02,640 --> 00:51:06,200
edit the method

1309
00:51:06,300 --> 00:51:07,920
it's not setting a lot of custom

1310
00:51:07,920 --> 00:51:11,420
attributes on these things

1311
00:51:11,640 --> 00:51:14,640
oh we can show you characteristics while

1312
00:51:14,640 --> 00:51:16,559
we're standing here so you can see it

1313
00:51:16,559 --> 00:51:18,059
there about Midway down the screen on

1314
00:51:18,059 --> 00:51:20,400
the left and there's that's what the the

1315
00:51:20,400 --> 00:51:23,880
hex bytes look like that 2000 or you

1316
00:51:23,880 --> 00:51:26,640
know two zero zero zero in X in this

1317
00:51:26,640 --> 00:51:29,640
case it's two zero 22 but that 2-0 still

1318
00:51:29,640 --> 00:51:31,740
indicates it's dll

1319
00:51:31,740 --> 00:51:33,799
um

1320
00:51:34,859 --> 00:51:36,420
and then

1321
00:51:36,420 --> 00:51:40,339
another thing that we can do

1322
00:51:44,940 --> 00:51:49,880
Ctrl shift K there's my keyword search

1323
00:52:02,040 --> 00:52:05,099
I'm going to be in here

1324
00:52:05,099 --> 00:52:07,880
here we go

1325
00:52:40,740 --> 00:52:42,960
all right so a couple of the things that

1326
00:52:42,960 --> 00:52:44,819
we can compare as we're looking through

1327
00:52:44,819 --> 00:52:46,680
one thing you'll notice in the

1328
00:52:46,680 --> 00:52:49,859
obfuscated version of the code is there

1329
00:52:49,859 --> 00:52:50,819
um

1330
00:52:50,819 --> 00:52:52,619
so in the de-obficated version of the

1331
00:52:52,619 --> 00:52:55,500
code right we can

1332
00:52:55,500 --> 00:52:58,440
we can see that he's because it's VB

1333
00:52:58,440 --> 00:53:00,420
he's

1334
00:53:00,420 --> 00:53:02,819
manually calling dll import rather than

1335
00:53:02,819 --> 00:53:04,680
using native.net inclusion for these

1336
00:53:04,680 --> 00:53:06,480
functions so he's got to call the

1337
00:53:06,480 --> 00:53:08,579
function you've got to call the dll and

1338
00:53:08,579 --> 00:53:12,180
the function Name by name here using dll

1339
00:53:12,180 --> 00:53:14,040
import which is an interesting artifact

1340
00:53:14,040 --> 00:53:16,559
because when he goes to run his

1341
00:53:16,559 --> 00:53:18,540
obfuscator on this

1342
00:53:18,540 --> 00:53:20,579
we also see

1343
00:53:20,579 --> 00:53:23,220
that

1344
00:53:23,220 --> 00:53:25,619
he has to leave those values alone right

1345
00:53:25,619 --> 00:53:26,880
because if you obfuscate those

1346
00:53:26,880 --> 00:53:28,920
particular values now it's worth noting

1347
00:53:28,920 --> 00:53:31,619
right like and I'm he'll probably watch

1348
00:53:31,619 --> 00:53:33,960
this later online and and then fix this

1349
00:53:33,960 --> 00:53:35,640
and and I guess I just accept that

1350
00:53:35,640 --> 00:53:36,900
that's the cat and mouse game we're

1351
00:53:36,900 --> 00:53:38,400
playing here in the name of education

1352
00:53:38,400 --> 00:53:39,720
but

1353
00:53:39,720 --> 00:53:41,400
um the way that he's implemented this

1354
00:53:41,400 --> 00:53:45,180
now we can take the create process and

1355
00:53:45,180 --> 00:53:48,660
kernel 32 dll strings use those as Pairs

1356
00:53:48,660 --> 00:53:50,339
and basically call out all the functions

1357
00:53:50,339 --> 00:53:52,500
that he wants to use in here and some of

1358
00:53:52,500 --> 00:53:54,119
these are pretty useful right I mean

1359
00:53:54,119 --> 00:53:56,880
it's a dropper so

1360
00:53:56,880 --> 00:53:59,040
you know read process memory write

1361
00:53:59,040 --> 00:54:01,319
process memory unmapped viewer section

1362
00:54:01,319 --> 00:54:05,339
virtual Alec resume thread right and

1363
00:54:05,339 --> 00:54:07,800
it's the it's the same functions that

1364
00:54:07,800 --> 00:54:09,839
he's got to call for each of these so we

1365
00:54:09,839 --> 00:54:11,220
could just build that out as a string

1366
00:54:11,220 --> 00:54:13,140
list because the obfuscators he's using

1367
00:54:13,140 --> 00:54:14,400
aren't going to blow those away because

1368
00:54:14,400 --> 00:54:15,839
if they did because of the way they're

1369
00:54:15,839 --> 00:54:16,980
implemented it would break the

1370
00:54:16,980 --> 00:54:19,440
functionality right now he could do

1371
00:54:19,440 --> 00:54:20,700
something else where he creates another

1372
00:54:20,700 --> 00:54:22,920
function where he reconstructs those

1373
00:54:22,920 --> 00:54:25,619
strings and instead you know populates

1374
00:54:25,619 --> 00:54:28,020
them from an obfuscated string decodes

1375
00:54:28,020 --> 00:54:30,059
them in Crypts them whatever and then

1376
00:54:30,059 --> 00:54:31,680
puts them back in there as a variable

1377
00:54:31,680 --> 00:54:34,559
name inside of dll import he could do

1378
00:54:34,559 --> 00:54:37,140
that but he hasn't so this is still a

1379
00:54:37,140 --> 00:54:39,720
pretty good technique for us to use and

1380
00:54:39,720 --> 00:54:41,420
get a list of some of these other things

1381
00:54:41,420 --> 00:54:45,059
the other thing that I was trying to

1382
00:54:45,059 --> 00:54:48,079
kept working

1383
00:54:52,380 --> 00:54:54,180
there we go

1384
00:54:54,180 --> 00:54:56,640
so the other thing that we can do is we

1385
00:54:56,640 --> 00:54:58,800
can just come back and take some of the

1386
00:54:58,800 --> 00:55:01,559
interesting things that we found so we

1387
00:55:01,559 --> 00:55:03,300
already found that one that's a module

1388
00:55:03,300 --> 00:55:07,680
name but this guy here this string value

1389
00:55:07,680 --> 00:55:08,819
um

1390
00:55:08,819 --> 00:55:12,319
that we've been working with

1391
00:55:17,040 --> 00:55:19,500
to copy here

1392
00:55:19,500 --> 00:55:20,579
oh

1393
00:55:20,579 --> 00:55:23,359
there we go

1394
00:55:29,220 --> 00:55:32,579
that's whole words created so

1395
00:55:32,579 --> 00:55:34,579
um

1396
00:55:35,160 --> 00:55:38,058
where is

1397
00:55:38,280 --> 00:55:39,960
ah there we go that's why I was trying

1398
00:55:39,960 --> 00:55:41,700
okay now I'm now I'm feeling a little

1399
00:55:41,700 --> 00:55:42,780
better

1400
00:55:42,780 --> 00:55:45,960
um so you can see that that ppsx that

1401
00:55:45,960 --> 00:55:48,420
that's how he's actually filling out the

1402
00:55:48,420 --> 00:55:51,119
like the the company product name

1403
00:55:51,119 --> 00:55:52,800
whatever so it's metadata that he's

1404
00:55:52,800 --> 00:55:54,059
picked

1405
00:55:54,059 --> 00:55:57,300
um so we can go ahead and use that pull

1406
00:55:57,300 --> 00:55:58,800
these values back together and put them

1407
00:55:58,800 --> 00:56:01,380
in some context we're running a little

1408
00:56:01,380 --> 00:56:03,180
long so I will just go ahead and take

1409
00:56:03,180 --> 00:56:05,000
you straight to the cheater

1410
00:56:05,000 --> 00:56:07,859
which is this rule here

1411
00:56:07,859 --> 00:56:11,420
who we wound up writing

1412
00:56:32,339 --> 00:56:34,559
and you can see we've got a we've got a

1413
00:56:34,559 --> 00:56:36,960
solid matched rule there but um I'll

1414
00:56:36,960 --> 00:56:38,280
walk you through what I did real quick

1415
00:56:38,280 --> 00:56:39,540
and then we'll wrap

1416
00:56:39,540 --> 00:56:42,359
um so essentially took um the the meta

1417
00:56:42,359 --> 00:56:44,640
build values you know so for the

1418
00:56:44,640 --> 00:56:46,020
different assembly name the custom

1419
00:56:46,020 --> 00:56:47,520
attributes and the rest of that and

1420
00:56:47,520 --> 00:56:49,619
created a build meta section in my

1421
00:56:49,619 --> 00:56:51,359
variables and then took the function

1422
00:56:51,359 --> 00:56:52,920
names that he couldn't successfully

1423
00:56:52,920 --> 00:56:55,200
obfuscate and put those into a set of

1424
00:56:55,200 --> 00:56:58,260
functions then we use uh dot net and PE

1425
00:56:58,260 --> 00:57:01,079
so p e is dll and then the.net version

1426
00:57:01,079 --> 00:57:03,119
that we exploited and the one thing I

1427
00:57:03,119 --> 00:57:05,220
was unable to find and show you though

1428
00:57:05,220 --> 00:57:07,920
it shows up in strings is the type lib

1429
00:57:07,920 --> 00:57:10,020
which that's going to be exclusive to

1430
00:57:10,020 --> 00:57:12,480
our guy until he watches this video and

1431
00:57:12,480 --> 00:57:14,040
then blows away his Visual Studio

1432
00:57:14,040 --> 00:57:17,280
install but uh so quite honestly just

1433
00:57:17,280 --> 00:57:20,819
the just uh just those two.net uh

1434
00:57:20,819 --> 00:57:23,880
version and typelib uh pretty decent for

1435
00:57:23,880 --> 00:57:25,380
being able to follow our guy around the

1436
00:57:25,380 --> 00:57:27,960
internet right now as he's working

1437
00:57:27,960 --> 00:57:30,119
um but yeah this uh this rule should

1438
00:57:30,119 --> 00:57:33,420
probably burn his uh his dropper for uh

1439
00:57:33,420 --> 00:57:36,240
for some period of time to come uh so so

1440
00:57:36,240 --> 00:57:38,339
anyway thanks for for letting me uh live

1441
00:57:38,339 --> 00:57:40,559
work one up in in front of you uh trying

1442
00:57:40,559 --> 00:57:42,359
to write a a rule in front of a live

1443
00:57:42,359 --> 00:57:44,760
audience in uh in 10 minutes is a it was

1444
00:57:44,760 --> 00:57:46,079
a challenge and uh thank you for

1445
00:57:46,079 --> 00:57:48,660
indulging me while I tried it so

1446
00:57:48,660 --> 00:57:52,339
um and that's uh that's gonna be it

1447
00:57:57,540 --> 00:57:59,099
oh yeah

1448
00:57:59,099 --> 00:57:59,700
um

1449
00:57:59,700 --> 00:58:01,740
I got two things to give away

1450
00:58:01,740 --> 00:58:03,960
um so the first

1451
00:58:03,960 --> 00:58:06,420
um first question uh why don't you ever

1452
00:58:06,420 --> 00:58:11,599
xor something by the key uh hex 2-0

1453
00:58:13,140 --> 00:58:17,180
um I saw that Tom sand uh

1454
00:58:18,720 --> 00:58:20,339
correct all right you get your your

1455
00:58:20,339 --> 00:58:21,900
choice you want a bash bunny or the

1456
00:58:21,900 --> 00:58:24,300
blackout python the which one

1457
00:58:24,300 --> 00:58:26,400
the book all right awesome

1458
00:58:26,400 --> 00:58:29,579
and then uh second question uh where is

1459
00:58:29,579 --> 00:58:32,760
our guy JWoww from

1460
00:58:32,760 --> 00:58:35,720
who said Brazil

1461
00:58:38,180 --> 00:58:40,380
all right

1462
00:58:40,380 --> 00:58:42,180
all right awesome thank you so much for

1463
00:58:42,180 --> 00:58:43,319
hanging out

1464
00:58:43,319 --> 00:58:44,099
um

1465
00:58:44,099 --> 00:58:46,559
please uh the links on the uh on the the

1466
00:58:46,559 --> 00:58:48,000
last slide there

1467
00:58:48,000 --> 00:58:49,319
um you know take you to the docs take

1468
00:58:49,319 --> 00:58:51,900
you to Florian Ross awesome Yara tuning

1469
00:58:51,900 --> 00:58:54,780
paper and uh and the GitHub repo where

1470
00:58:54,780 --> 00:58:57,059
these rules are and the new rule will be

1471
00:58:57,059 --> 00:59:00,859
shortly so thanks so much

1472
00:59:02,940 --> 00:59:05,720
foreign

