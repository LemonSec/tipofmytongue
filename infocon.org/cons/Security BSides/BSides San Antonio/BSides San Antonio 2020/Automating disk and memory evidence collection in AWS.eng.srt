1
00:00:09,280 --> 00:00:09,760
tells

2
00:00:09,760 --> 00:00:12,000
all the commands run their status

3
00:00:12,000 --> 00:00:13,759
whether they succeeded or failed and the

4
00:00:13,759 --> 00:00:17,920
time stamps when they were attempted

5
00:00:19,039 --> 00:00:20,640
uh again this will be a pretty technical

6
00:00:20,640 --> 00:00:22,320
talk but before we deep dive we wanted

7
00:00:22,320 --> 00:00:23,039
to provide

8
00:00:23,039 --> 00:00:24,960
kind of some main takeaways to keep in

9
00:00:24,960 --> 00:00:26,320
mind as we go through the technical

10
00:00:26,320 --> 00:00:28,880
details

11
00:00:29,199 --> 00:00:30,960
so the first point we have here is going

12
00:00:30,960 --> 00:00:32,320
to emphasize that there's a lot more

13
00:00:32,320 --> 00:00:33,840
going on behind the scenes than you may

14
00:00:33,840 --> 00:00:34,800
originally think

15
00:00:34,800 --> 00:00:36,320
um as vaishnav stated before we're

16
00:00:36,320 --> 00:00:37,520
dealing with three different aws

17
00:00:37,520 --> 00:00:40,000
organizations that total over 3000 aws

18
00:00:40,000 --> 00:00:40,960
accounts

19
00:00:40,960 --> 00:00:42,800
not only in that but in each account we

20
00:00:42,800 --> 00:00:44,559
have various types of ec2 instances

21
00:00:44,559 --> 00:00:45,200
running

22
00:00:45,200 --> 00:00:47,360
um these instances all have varying

23
00:00:47,360 --> 00:00:49,200
forms of encryption and may or may not

24
00:00:49,200 --> 00:00:50,879
have some level of logging or network

25
00:00:50,879 --> 00:00:52,079
connectivity

26
00:00:52,079 --> 00:00:54,079
so our solution uh when we were

27
00:00:54,079 --> 00:00:55,760
designing it it really had to consider

28
00:00:55,760 --> 00:00:57,280
cross-scan access

29
00:00:57,280 --> 00:01:00,480
ebs and snapshot encryption sharing kms

30
00:01:00,480 --> 00:01:01,520
keys for example

31
00:01:01,520 --> 00:01:04,479
and varying levels of access logging so

32
00:01:04,479 --> 00:01:05,519
that's point one

33
00:01:05,519 --> 00:01:07,680
point two uh is pretty straightforward

34
00:01:07,680 --> 00:01:09,040
but if you automate a task correctly

35
00:01:09,040 --> 00:01:10,880
your mean time to respond

36
00:01:10,880 --> 00:01:12,560
your cost and your error rates should

37
00:01:12,560 --> 00:01:14,400
all go down this one again is pretty

38
00:01:14,400 --> 00:01:15,920
self-explanatory but even though we

39
00:01:15,920 --> 00:01:17,360
invested a lot of time in building this

40
00:01:17,360 --> 00:01:19,520
solution and getting it off the ground

41
00:01:19,520 --> 00:01:21,119
we believe that our return on investment

42
00:01:21,119 --> 00:01:22,799
is high and we're saving the firm money

43
00:01:22,799 --> 00:01:24,799
and time in the long run

44
00:01:24,799 --> 00:01:26,720
so next we wanted something that could

45
00:01:26,720 --> 00:01:27,920
scale easily

46
00:01:27,920 --> 00:01:30,159
uh you know given our footprint in aws

47
00:01:30,159 --> 00:01:31,439
we're dealing with a kind of a large

48
00:01:31,439 --> 00:01:32,479
magnitude

49
00:01:32,479 --> 00:01:34,240
of accounts and that's why we chose to

50
00:01:34,240 --> 00:01:36,880
use a lot of native aws services

51
00:01:36,880 --> 00:01:39,280
um all of our resources are spun up and

52
00:01:39,280 --> 00:01:40,000
used only

53
00:01:40,000 --> 00:01:41,680
when needed and when we don't need them

54
00:01:41,680 --> 00:01:43,600
they're not running so this really helps

55
00:01:43,600 --> 00:01:46,079
reduce cost and increase efficiency

56
00:01:46,079 --> 00:01:49,200
and uh lastly so we wanted to do this

57
00:01:49,200 --> 00:01:51,759
accomplish this to be independently to

58
00:01:51,759 --> 00:01:52,479
be done

59
00:01:52,479 --> 00:01:55,759
you know in a parallel manner so in a

60
00:01:55,759 --> 00:01:56,880
similar vein

61
00:01:56,880 --> 00:01:59,439
a collector vm instance is spun up per

62
00:01:59,439 --> 00:02:01,040
volume to be collected

63
00:02:01,040 --> 00:02:04,320
so that volumes that we collect

64
00:02:04,320 --> 00:02:08,080
are being processed in parallel so the

65
00:02:08,080 --> 00:02:09,679
second thing we want to talk about is

66
00:02:09,679 --> 00:02:12,480
full disc versus triage collection so we

67
00:02:12,480 --> 00:02:13,840
focused on a full

68
00:02:13,840 --> 00:02:17,200
dd image for this process mainly due to

69
00:02:17,200 --> 00:02:19,120
the regulatory requirements

70
00:02:19,120 --> 00:02:21,520
in our industry however triage

71
00:02:21,520 --> 00:02:23,200
collection could be appropriate for your

72
00:02:23,200 --> 00:02:24,319
use case

73
00:02:24,319 --> 00:02:25,840
uh we're basically doing the best of

74
00:02:25,840 --> 00:02:28,480
both worlds so we we do a full dd

75
00:02:28,480 --> 00:02:31,200
uh capture but we're also uh stream

76
00:02:31,200 --> 00:02:33,599
relevant log files uh via the cloudwatch

77
00:02:33,599 --> 00:02:34,560
logs agent

78
00:02:34,560 --> 00:02:36,959
uh from production ec2 instances to

79
00:02:36,959 --> 00:02:38,800
basically fulfill the use case of a

80
00:02:38,800 --> 00:02:40,560
triage collection so we have access to

81
00:02:40,560 --> 00:02:41,920
the logs before

82
00:02:41,920 --> 00:02:45,360
uh before we collect the full disk

83
00:02:45,360 --> 00:02:48,560
and then lastly or thirdly streaming

84
00:02:48,560 --> 00:02:50,879
evidence directly to s3

85
00:02:50,879 --> 00:02:53,519
so we stream the dc-3d output directly

86
00:02:53,519 --> 00:02:55,360
to s3 without

87
00:02:55,360 --> 00:02:58,400
any intermediary storage this is

88
00:02:58,400 --> 00:03:01,040
to reduce the resource consumption of

89
00:03:01,040 --> 00:03:04,480
our collector vm instance

90
00:03:04,480 --> 00:03:06,080
awesome so if we move on to point number

91
00:03:06,080 --> 00:03:07,680
four here um so

92
00:03:07,680 --> 00:03:09,599
our entire process is audible with

93
00:03:09,599 --> 00:03:11,840
cloudtrail and done with vpc endpoints

94
00:03:11,840 --> 00:03:13,120
to ensure that everything

95
00:03:13,120 --> 00:03:15,760
is transmitted over the backbone aws

96
00:03:15,760 --> 00:03:16,640
network

97
00:03:16,640 --> 00:03:18,800
and having an internal audit trail of

98
00:03:18,800 --> 00:03:20,720
our actions is always very important

99
00:03:20,720 --> 00:03:22,560
so you can tell someone specifically

100
00:03:22,560 --> 00:03:24,400
what you did and when you did it so our

101
00:03:24,400 --> 00:03:26,720
legal and risk team loved us for that

102
00:03:26,720 --> 00:03:30,720
um the next point here is basically how

103
00:03:30,840 --> 00:03:33,840
fast

104
00:04:56,320 --> 00:04:59,120
everybody else for being patient with us

105
00:04:59,120 --> 00:05:00,000
um

106
00:05:00,000 --> 00:05:02,960
all right i will let you take it away

107
00:05:02,960 --> 00:05:04,320
all right

108
00:05:04,320 --> 00:05:07,680
uh hello everyone today we'll talk about

109
00:05:07,680 --> 00:05:09,520
automating binary the obfuscation

110
00:05:09,520 --> 00:05:12,160
processes using dynamic taint analysis

111
00:05:12,160 --> 00:05:14,639
and symbolic code execution we'll be

112
00:05:14,639 --> 00:05:16,560
focusing uh solely on code

113
00:05:16,560 --> 00:05:17,600
virtualization

114
00:05:17,600 --> 00:05:20,800
and how we could obfuscate that my name

115
00:05:20,800 --> 00:05:21,680
is back

116
00:05:21,680 --> 00:05:24,880
i work as a threat intel analyst

117
00:05:24,880 --> 00:05:27,919
i'm a theater graduate and i have over

118
00:05:27,919 --> 00:05:28,960
five years

119
00:05:28,960 --> 00:05:30,560
experience in fan testing and red

120
00:05:30,560 --> 00:05:33,039
teaming my friend osama here

121
00:05:33,039 --> 00:05:35,280
is

122
00:05:36,800 --> 00:05:41,199
an rnd engineer at trap mine

123
00:05:48,350 --> 00:05:50,840
[Music]

124
00:05:50,840 --> 00:05:53,840
science

125
00:06:06,660 --> 00:06:09,879
[Music]

126
00:06:18,840 --> 00:06:21,840
uh

127
00:06:26,330 --> 00:06:32,840
[Music]

128
00:06:32,840 --> 00:06:35,840
bye

129
00:06:47,520 --> 00:06:50,720
okay hopefully you can still

130
00:06:50,720 --> 00:06:55,919
see my screen um this is wrong

131
00:06:56,960 --> 00:07:02,000
yeah all right

132
00:07:02,000 --> 00:07:07,120
so uh we will

133
00:07:07,120 --> 00:07:17,840
focus on code visualization

134
00:11:14,000 --> 00:11:15,760
everyone thanks for waiting we still

135
00:11:15,760 --> 00:11:17,120
have some significant

136
00:11:17,120 --> 00:11:20,000
av issues from the presenter we are

137
00:11:20,000 --> 00:11:21,440
still working through them as best we

138
00:11:21,440 --> 00:11:21,920
can

139
00:11:21,920 --> 00:11:29,839
sorry about this

140
00:12:40,880 --> 00:12:43,920
uh then everything is fine so you don't

141
00:12:43,920 --> 00:12:45,600
have to deal with words and bytes

142
00:12:45,600 --> 00:12:49,200
etc um great

143
00:12:49,200 --> 00:12:53,440
do i go to the all right great

144
00:12:53,440 --> 00:12:56,560
so um

145
00:12:59,360 --> 00:13:02,160
with uh 32 stack machines we said that

146
00:13:02,160 --> 00:13:02,480
we

147
00:13:02,480 --> 00:13:04,320
we can use less pop codes because of

148
00:13:04,320 --> 00:13:06,320
this and

149
00:13:06,320 --> 00:13:08,399
you have a minimal processor stack to

150
00:13:08,399 --> 00:13:10,240
keep track of

151
00:13:10,240 --> 00:13:13,360
uh an example can be maybe uh

152
00:13:13,360 --> 00:13:16,079
i think jvm used to be a 32-bit stack

153
00:13:16,079 --> 00:13:17,279
machine and then it

154
00:13:17,279 --> 00:13:20,079
they switched to a 32-bit stack and

155
00:13:20,079 --> 00:13:21,440
register mission

156
00:13:21,440 --> 00:13:23,519
so you also don't have you don't deal

157
00:13:23,519 --> 00:13:24,560
with registers

158
00:13:24,560 --> 00:13:27,839
and you don't deal with flags

159
00:13:27,839 --> 00:13:31,040
so uh for our code visualization

160
00:13:31,040 --> 00:13:34,639
uh we we we made this 32-bit stack

161
00:13:34,639 --> 00:13:36,079
machine and it supports

162
00:13:36,079 --> 00:13:40,639
11 instructions uh fairly simple

163
00:13:40,639 --> 00:13:42,639
uh we have arithmetic operations

164
00:13:42,639 --> 00:13:44,560
comparison store and load

165
00:13:44,560 --> 00:13:46,240
uh conditionals read and write

166
00:13:46,240 --> 00:13:49,199
instructions in addition we have a roth

167
00:13:49,199 --> 00:13:50,160
instruction

168
00:13:50,160 --> 00:13:52,560
uh this throat instruction allows us to

169
00:13:52,560 --> 00:13:54,399
rotate things on the stack which makes

170
00:13:54,399 --> 00:13:54,880
it just

171
00:13:54,880 --> 00:13:57,040
easier for us uh you can actually use

172
00:13:57,040 --> 00:13:58,480
any two instructions

173
00:13:58,480 --> 00:14:01,519
sorry like two instructions is enough to

174
00:14:01,519 --> 00:14:03,030
to do whatever you want to do

175
00:14:03,030 --> 00:14:05,519
[Music]

176
00:14:05,519 --> 00:14:08,160
but uh we were more comfortable with 11.

177
00:14:08,160 --> 00:14:08,639
so

178
00:14:08,639 --> 00:14:11,839
to illustrate uh how this would work

179
00:14:11,839 --> 00:14:15,040
it's basically like assembly uh but

180
00:14:15,040 --> 00:14:16,880
i'm just going to go over this one

181
00:14:16,880 --> 00:14:18,240
example that we uh

182
00:14:18,240 --> 00:14:20,320
we worked on uh getting the absolute

183
00:14:20,320 --> 00:14:21,360
value of an integer

184
00:14:21,360 --> 00:14:24,800
right so our input is

185
00:14:24,800 --> 00:14:28,240
-5 we get it using read

186
00:14:28,240 --> 00:14:31,680
and then we duplicate it we used to uh

187
00:14:31,680 --> 00:14:33,839
copy it on top of the stack and then we

188
00:14:33,839 --> 00:14:36,000
push zero now we will use this zero to

189
00:14:36,000 --> 00:14:38,880
to check if uh minus five is greater

190
00:14:38,880 --> 00:14:41,519
than or less than zero

191
00:14:41,519 --> 00:14:44,320
we use our gt instruction and it returns

192
00:14:44,320 --> 00:14:45,600
one

193
00:14:45,600 --> 00:14:49,120
if minus five is less than zero

194
00:14:49,120 --> 00:14:52,639
so now we push nine on top of the stack

195
00:14:52,639 --> 00:14:55,279
the reason why we push nine is because

196
00:14:55,279 --> 00:14:56,399
we would actually

197
00:14:56,399 --> 00:14:59,600
uh jump to instruction nine

198
00:14:59,600 --> 00:15:01,600
so this is where we're going to jump to

199
00:15:01,600 --> 00:15:02,639
uh after

200
00:15:02,639 --> 00:15:05,680
a conditional jump so here we have our

201
00:15:05,680 --> 00:15:07,279
conditional jump

202
00:15:07,279 --> 00:15:10,399
uh since it returned one that means it's

203
00:15:10,399 --> 00:15:13,360
less than zero so our input so it's a

204
00:15:13,360 --> 00:15:15,120
negative value

205
00:15:15,120 --> 00:15:17,680
now we basically push minus one on top

206
00:15:17,680 --> 00:15:18,959
of the stack

207
00:15:18,959 --> 00:15:22,000
and then uh we multiply minus one with

208
00:15:22,000 --> 00:15:24,800
minus five thus getting the absolute

209
00:15:24,800 --> 00:15:25,519
value

210
00:15:25,519 --> 00:15:28,880
of our given input and then of course we

211
00:15:28,880 --> 00:15:30,160
would have to write that

212
00:15:30,160 --> 00:15:33,440
back up onto standard output here in

213
00:15:33,440 --> 00:15:35,279
this case

214
00:15:35,279 --> 00:15:37,040
so our interpreter structure is fairly

215
00:15:37,040 --> 00:15:38,720
straightforward we fetch

216
00:15:38,720 --> 00:15:41,920
we decode so bytecode comes and we

217
00:15:41,920 --> 00:15:44,720
understand where this is going to go and

218
00:15:44,720 --> 00:15:46,240
then we handle it

219
00:15:46,240 --> 00:15:49,440
every uh so a handler is basically a

220
00:15:49,440 --> 00:15:50,000
routine

221
00:15:50,000 --> 00:15:53,040
that handles your uh virtual instruction

222
00:15:53,040 --> 00:15:56,079
for every uh

223
00:15:56,079 --> 00:15:57,360
for every instruction you need a

224
00:15:57,360 --> 00:15:59,199
different plan handler and then of

225
00:15:59,199 --> 00:16:01,120
course we terminate after we kill the

226
00:16:01,120 --> 00:16:01,680
process

227
00:16:01,680 --> 00:16:05,040
after all of the handlers uh or routines

228
00:16:05,040 --> 00:16:08,160
uh have been run so

229
00:16:08,160 --> 00:16:10,959
this is the diagram as you can see i'm

230
00:16:10,959 --> 00:16:11,360
just

231
00:16:11,360 --> 00:16:13,759
speeding up a little bit uh because

232
00:16:13,759 --> 00:16:15,040
we've lost

233
00:16:15,040 --> 00:16:18,560
quite an amount of time so here

234
00:16:18,560 --> 00:16:21,839
you can see uh if you can see our class

235
00:16:21,839 --> 00:16:24,720
named interpreter

236
00:16:24,720 --> 00:16:27,279
you can see that we have a pointer to

237
00:16:27,279 --> 00:16:28,480
the beginning of our stack

238
00:16:28,480 --> 00:16:30,560
a pointer to the program we're going to

239
00:16:30,560 --> 00:16:31,680
run

240
00:16:31,680 --> 00:16:34,000
the size of our program and the program

241
00:16:34,000 --> 00:16:35,199
counter to see

242
00:16:35,199 --> 00:16:37,440
which instruction we're going to run

243
00:16:37,440 --> 00:16:38,800
next

244
00:16:38,800 --> 00:16:40,399
there are commercial virtualization

245
00:16:40,399 --> 00:16:42,000
providers uh

246
00:16:42,000 --> 00:16:43,839
these do a much more complicated job

247
00:16:43,839 --> 00:16:45,440
than uh how

248
00:16:45,440 --> 00:16:48,880
our implementation does they actually

249
00:16:48,880 --> 00:16:50,800
also uh

250
00:16:50,800 --> 00:16:54,320
work as a crypter and a packer um

251
00:16:54,320 --> 00:16:57,040
the tigress c diversifier of the skater

252
00:16:57,040 --> 00:16:58,079
is a good one

253
00:16:58,079 --> 00:17:00,399
uh it's generally used for as far as

254
00:17:00,399 --> 00:17:01,120
we've seen

255
00:17:01,120 --> 00:17:04,799
academic uh research uh vm protect

256
00:17:04,799 --> 00:17:06,880
is we um protect them from either you

257
00:17:06,880 --> 00:17:08,079
can actually

258
00:17:08,079 --> 00:17:11,839
see it used by attackers uh vm protect

259
00:17:11,839 --> 00:17:12,559
even apt

260
00:17:12,559 --> 00:17:15,039
groups and then there are of course many

261
00:17:15,039 --> 00:17:16,079
other alternatives

262
00:17:16,079 --> 00:17:18,160
but please mind that these uh solutions

263
00:17:18,160 --> 00:17:19,199
are also used for

264
00:17:19,199 --> 00:17:22,000
digital rights management and uh for

265
00:17:22,000 --> 00:17:24,240
basically any non-malicious purpose

266
00:17:24,240 --> 00:17:25,760
uh where you don't want people reverse

267
00:17:25,760 --> 00:17:27,359
engineering your code

268
00:17:27,359 --> 00:17:29,919
now back to our uh the obfuscation

269
00:17:29,919 --> 00:17:32,000
techniques we mentioned earlier

270
00:17:32,000 --> 00:17:35,280
the first one is dynamic taint analysis

271
00:17:35,280 --> 00:17:38,160
taint analysis is uh we use it to track

272
00:17:38,160 --> 00:17:39,120
the flow of

273
00:17:39,120 --> 00:17:42,880
information in a program uh specifically

274
00:17:42,880 --> 00:17:46,160
to put it the track of information uh

275
00:17:46,160 --> 00:17:46,880
between

276
00:17:46,880 --> 00:17:50,000
two cert not two uh certain points

277
00:17:50,000 --> 00:17:52,720
uh in a program we do this by labeling

278
00:17:52,720 --> 00:17:55,280
certain memory locations uh as tainted

279
00:17:55,280 --> 00:17:58,000
and then we propagate the state uh

280
00:17:58,000 --> 00:17:58,559
throughout

281
00:17:58,559 --> 00:18:02,240
different memory locations uh so

282
00:18:02,240 --> 00:18:05,280
if a memory if any value

283
00:18:05,280 --> 00:18:07,840
uh gets generated or derived from a

284
00:18:07,840 --> 00:18:09,360
tainted memory location

285
00:18:09,360 --> 00:18:12,160
we also taint that uh memory location

286
00:18:12,160 --> 00:18:13,440
where that single value

287
00:18:13,440 --> 00:18:16,400
is being held we do that for everything

288
00:18:16,400 --> 00:18:17,440
that drives from

289
00:18:17,440 --> 00:18:21,840
uh obtained source uh and then

290
00:18:21,840 --> 00:18:25,200
we call uh we call the

291
00:18:25,200 --> 00:18:28,400
other tainted values uh sinks so

292
00:18:28,400 --> 00:18:31,440
portions of the memory uh so portions of

293
00:18:31,440 --> 00:18:33,200
the code that use that memory space

294
00:18:33,200 --> 00:18:36,559
sorry are these things so the way we

295
00:18:36,559 --> 00:18:38,720
track information we do it by attaining

296
00:18:38,720 --> 00:18:39,440
policies

297
00:18:39,440 --> 00:18:42,960
uh they're very important to us to get

298
00:18:42,960 --> 00:18:45,679
actual results that you can use so just

299
00:18:45,679 --> 00:18:47,440
to go over the terminology here

300
00:18:47,440 --> 00:18:51,039
if um if anything derives

301
00:18:51,039 --> 00:18:53,440
if any value addressed from a taint

302
00:18:53,440 --> 00:18:54,480
source

303
00:18:54,480 --> 00:18:57,840
that value is tainted and any other

304
00:18:57,840 --> 00:19:00,320
value that derives from a tainted source

305
00:19:00,320 --> 00:19:04,799
a tainted memory region is also tainted

306
00:19:04,799 --> 00:19:06,640
so when we talk about policy we have

307
00:19:06,640 --> 00:19:09,039
three properties uh taint introduction

308
00:19:09,039 --> 00:19:11,600
propagation and checking introduction is

309
00:19:11,600 --> 00:19:13,120
where we're going to introduce the taint

310
00:19:13,120 --> 00:19:15,600
propagation is how it's going to spread

311
00:19:15,600 --> 00:19:16,400
out in memory

312
00:19:16,400 --> 00:19:18,400
and tame checking is the action we're

313
00:19:18,400 --> 00:19:21,280
going to take once

314
00:19:21,280 --> 00:19:24,559
a certain condition is met so taint

315
00:19:24,559 --> 00:19:25,919
introduction generally

316
00:19:25,919 --> 00:19:28,960
uh we can introduce this to user input

317
00:19:28,960 --> 00:19:31,280
to library returns or cisco return

318
00:19:31,280 --> 00:19:32,080
values

319
00:19:32,080 --> 00:19:36,240
or memory you read from a file and

320
00:19:36,240 --> 00:19:38,480
values you read from a file and things

321
00:19:38,480 --> 00:19:40,480
like that

322
00:19:40,480 --> 00:19:42,640
uh this is a good example for obtain

323
00:19:42,640 --> 00:19:43,600
propagation it's

324
00:19:43,600 --> 00:19:46,880
very simple we have variable a that's

325
00:19:46,880 --> 00:19:47,760
user input

326
00:19:47,760 --> 00:19:50,000
now we decide to obtain user input in

327
00:19:50,000 --> 00:19:52,080
this example because we think that's

328
00:19:52,080 --> 00:19:55,200
uh good for our purpose right

329
00:19:55,200 --> 00:19:57,760
so you choose what you're going to think

330
00:19:57,760 --> 00:19:58,400
so

331
00:19:58,400 --> 00:20:01,120
we take variable a and we put that in a

332
00:20:01,120 --> 00:20:02,000
memory region

333
00:20:02,000 --> 00:20:05,679
a and then we taint that region manually

334
00:20:05,679 --> 00:20:09,600
and then in routine 2 when

335
00:20:09,600 --> 00:20:14,240
variable b is generated using a

336
00:20:14,720 --> 00:20:16,559
we also take the memory region where

337
00:20:16,559 --> 00:20:18,559
variable b is being stored

338
00:20:18,559 --> 00:20:22,880
and this will go on for

339
00:20:22,880 --> 00:20:25,280
now you can use this uh in exploitation

340
00:20:25,280 --> 00:20:26,320
prevention

341
00:20:26,320 --> 00:20:29,679
uh let's say we have a shell code

342
00:20:29,679 --> 00:20:31,440
let's talk about a sheltered override

343
00:20:31,440 --> 00:20:33,520
exploit example

344
00:20:33,520 --> 00:20:37,600
somebody has just uh managed to push uh

345
00:20:37,600 --> 00:20:39,919
shellcode on top of the stack so and

346
00:20:39,919 --> 00:20:41,600
this malicious child code will

347
00:20:41,600 --> 00:20:46,320
run right the moment um

348
00:20:46,320 --> 00:20:49,679
so how can we stop this is that if we

349
00:20:49,679 --> 00:20:52,799
taint all user input and if execution

350
00:20:52,799 --> 00:20:56,480
at one point uh in a in time ever

351
00:20:56,480 --> 00:21:01,360
uh goes to a place that is tainted

352
00:21:01,360 --> 00:21:03,760
that means we are executing user

353
00:21:03,760 --> 00:21:04,720
supplied

354
00:21:04,720 --> 00:21:09,679
uh code right user supplied region

355
00:21:09,679 --> 00:21:13,840
so we can actually stop this with um

356
00:21:13,840 --> 00:21:16,720
dynamic change analysis engines with

357
00:21:16,720 --> 00:21:18,640
rope exploits uh you can do something

358
00:21:18,640 --> 00:21:19,760
very similar

359
00:21:19,760 --> 00:21:21,440
you won't have shell code but you will

360
00:21:21,440 --> 00:21:23,200
have a function pointer

361
00:21:23,200 --> 00:21:25,200
that's overwritten or a return address

362
00:21:25,200 --> 00:21:26,480
that's all written so

363
00:21:26,480 --> 00:21:30,480
if any of these are overwritten with um

364
00:21:30,480 --> 00:21:33,039
tainted values which are coming from

365
00:21:33,039 --> 00:21:34,559
user input in this scenario

366
00:21:34,559 --> 00:21:37,919
you can actually stop execution so here

367
00:21:37,919 --> 00:21:40,880
an example is we have variable a again

368
00:21:40,880 --> 00:21:42,240
and then in routine two

369
00:21:42,240 --> 00:21:45,600
we are copying uh variable a on

370
00:21:45,600 --> 00:21:48,960
to uh b right we're using stir copy but

371
00:21:48,960 --> 00:21:52,880
uh as you can see a is twice as big as b

372
00:21:52,880 --> 00:21:54,720
so we'll be overwriting the return

373
00:21:54,720 --> 00:21:58,400
address now uh when execution uh

374
00:21:58,400 --> 00:22:00,480
the execution flow comes to the return

375
00:22:00,480 --> 00:22:02,480
address we will see that it's tainted

376
00:22:02,480 --> 00:22:05,840
and the dynamic taint analysis engine

377
00:22:05,840 --> 00:22:08,000
uh so the the dynamic binary

378
00:22:08,000 --> 00:22:09,600
instrumentation framework will actually

379
00:22:09,600 --> 00:22:12,080
stop execution there

380
00:22:12,080 --> 00:22:14,080
but i mean if this was the case

381
00:22:14,080 --> 00:22:16,000
everybody would stop exploitation

382
00:22:16,000 --> 00:22:17,679
the problem is that there is an

383
00:22:17,679 --> 00:22:20,799
expensive runtime overhead

384
00:22:20,799 --> 00:22:22,640
so i said we use dynamic binary

385
00:22:22,640 --> 00:22:24,080
instrumentation frameworks

386
00:22:24,080 --> 00:22:26,320
and the way that this would work is that

387
00:22:26,320 --> 00:22:27,840
the code would be executed in the

388
00:22:27,840 --> 00:22:29,120
framework before

389
00:22:29,120 --> 00:22:30,960
uh so portions of the code would be

390
00:22:30,960 --> 00:22:32,240
executed there

391
00:22:32,240 --> 00:22:35,360
before they're actually executed uh on

392
00:22:35,360 --> 00:22:38,640
the computer itself uh so this brings a

393
00:22:38,640 --> 00:22:39,360
very

394
00:22:39,360 --> 00:22:42,400
expensive runtime overhead another big

395
00:22:42,400 --> 00:22:43,120
challenge is

396
00:22:43,120 --> 00:22:46,159
how to define uh the tank profit

397
00:22:46,159 --> 00:22:48,480
to how to define the taint propagation

398
00:22:48,480 --> 00:22:50,000
uh because there's

399
00:22:50,000 --> 00:22:51,760
you'll be dealing with data dependency

400
00:22:51,760 --> 00:22:53,280
control flow dependency

401
00:22:53,280 --> 00:22:57,039
and implicit flows so a quick example

402
00:22:57,039 --> 00:23:00,240
uh you can use implicit flows as

403
00:23:00,240 --> 00:23:02,880
an anti-taint analysis method right you

404
00:23:02,880 --> 00:23:04,240
have variable a

405
00:23:04,240 --> 00:23:06,880
which is your tainted method but if the

406
00:23:06,880 --> 00:23:08,000
code basically

407
00:23:08,000 --> 00:23:11,200
uh generates b uh variable b

408
00:23:11,200 --> 00:23:14,559
so updates variable b using uh

409
00:23:14,559 --> 00:23:18,159
tainted value a but indirectly

410
00:23:18,159 --> 00:23:20,960
as you can see here it's uh it gets

411
00:23:20,960 --> 00:23:24,320
incremented uh twice the size of a

412
00:23:24,320 --> 00:23:27,760
now here you can choose to taint uh b

413
00:23:27,760 --> 00:23:29,919
as well but then you will also be

414
00:23:29,919 --> 00:23:31,440
tainting other things that you wouldn't

415
00:23:31,440 --> 00:23:32,720
like to taint and that would be

416
00:23:32,720 --> 00:23:35,039
overtainting

417
00:23:35,039 --> 00:23:36,799
and you won't get so good results the

418
00:23:36,799 --> 00:23:38,799
same thing goes for undertainting uh in

419
00:23:38,799 --> 00:23:39,679
this example

420
00:23:39,679 --> 00:23:41,679
there's underpainting so this is always

421
00:23:41,679 --> 00:23:42,880
a challenge you have to be

422
00:23:42,880 --> 00:23:46,240
dealing with all right

423
00:23:46,240 --> 00:23:51,279
um i will now

424
00:23:51,279 --> 00:23:53,760
give my screen to sama if that's

425
00:23:53,760 --> 00:23:56,240
possible

426
00:23:57,200 --> 00:24:01,039
and he can continue with symbolic code

427
00:24:02,840 --> 00:24:05,840
execution

428
00:24:49,279 --> 00:24:52,400
ah okay i'm so sorry uh

429
00:24:52,400 --> 00:24:55,440
i forgot to unmute myself all right

430
00:24:55,440 --> 00:24:57,919
i'll just repeat the few sentences that

431
00:24:57,919 --> 00:24:59,200
i spoke

432
00:24:59,200 --> 00:25:01,760
so burke covered uh the design and

433
00:25:01,760 --> 00:25:03,279
implementation of with it

434
00:25:03,279 --> 00:25:05,840
of the 32-bit virtual machine the stack

435
00:25:05,840 --> 00:25:06,640
machine

436
00:25:06,640 --> 00:25:08,320
that will we will be using to

437
00:25:08,320 --> 00:25:10,640
demonstrate the application of

438
00:25:10,640 --> 00:25:14,320
uh our de-obfuscation procedures uh our

439
00:25:14,320 --> 00:25:16,240
defecation procedure comprises of two

440
00:25:16,240 --> 00:25:18,000
techniques dynamic paint analysis and

441
00:25:18,000 --> 00:25:19,840
symbolic code execution

442
00:25:19,840 --> 00:25:23,200
so burke covered uh

443
00:25:23,200 --> 00:25:26,799
dynamic gained analysis and

444
00:25:26,799 --> 00:25:28,720
now we're moving on to symbolic code

445
00:25:28,720 --> 00:25:31,279
execution

446
00:25:32,480 --> 00:25:34,400
so fundamentally an execution of a

447
00:25:34,400 --> 00:25:37,039
program is a series of computations

448
00:25:37,039 --> 00:25:38,159
performed on

449
00:25:38,159 --> 00:25:41,360
data held in memory the data is read

450
00:25:41,360 --> 00:25:43,679
manipulated by the instructions and then

451
00:25:43,679 --> 00:25:46,480
it is stored back in memory

452
00:25:46,480 --> 00:25:48,400
symbolic code execution works in the

453
00:25:48,400 --> 00:25:49,840
same way except

454
00:25:49,840 --> 00:25:51,760
instead of actual values being

455
00:25:51,760 --> 00:25:53,600
manipulated we work with

456
00:25:53,600 --> 00:25:57,279
symbols that's the name uh the result of

457
00:25:57,279 --> 00:25:58,159
computations

458
00:25:58,159 --> 00:26:00,880
are stored as expressions involving

459
00:26:00,880 --> 00:26:01,919
these symbols

460
00:26:01,919 --> 00:26:05,200
so for example uh memory location one

461
00:26:05,200 --> 00:26:07,919
logical and memory location two will be

462
00:26:07,919 --> 00:26:09,520
stored explicitly

463
00:26:09,520 --> 00:26:13,279
like that uh so this allows us to

464
00:26:13,279 --> 00:26:15,760
consider logical formulas describing our

465
00:26:15,760 --> 00:26:17,440
program and the advantage of this is

466
00:26:17,440 --> 00:26:17,919
that

467
00:26:17,919 --> 00:26:20,000
it gives us the ability to reason about

468
00:26:20,000 --> 00:26:21,679
our program and answers

469
00:26:21,679 --> 00:26:24,240
a few important questions that help us

470
00:26:24,240 --> 00:26:25,760
with program analysis and binary

471
00:26:25,760 --> 00:26:26,480
analysis

472
00:26:26,480 --> 00:26:29,760
problems issues such as whether a

473
00:26:29,760 --> 00:26:32,880
particular program state is reachable

474
00:26:32,880 --> 00:26:37,200
and such things so

475
00:26:37,200 --> 00:26:39,679
i'll go over a few use cases briefly of

476
00:26:39,679 --> 00:26:41,279
symbolic code execution

477
00:26:41,279 --> 00:26:43,679
uh these include detecting infeasible

478
00:26:43,679 --> 00:26:44,320
paths

479
00:26:44,320 --> 00:26:46,960
uh generating test inputs to maximize

480
00:26:46,960 --> 00:26:48,240
code coverage

481
00:26:48,240 --> 00:26:51,360
uh symbolic code execution is

482
00:26:51,360 --> 00:26:53,200
also used in conjunction with sas

483
00:26:53,200 --> 00:26:55,200
solvers to generate input

484
00:26:55,200 --> 00:26:59,520
uh for automatic export generation

485
00:26:59,520 --> 00:27:01,440
uh however in this presentation the

486
00:27:01,440 --> 00:27:03,200
application of symbolic code execution

487
00:27:03,200 --> 00:27:05,200
we will be focusing on is backward

488
00:27:05,200 --> 00:27:06,400
slicing

489
00:27:06,400 --> 00:27:08,000
we will discuss in detail what it is

490
00:27:08,000 --> 00:27:10,320
later but uh briefly for now

491
00:27:10,320 --> 00:27:13,679
program slicing is used to find which

492
00:27:13,679 --> 00:27:15,760
set of instructions contribute to a

493
00:27:15,760 --> 00:27:18,159
value at a certain point

494
00:27:18,159 --> 00:27:21,600
in the execution of a program all right

495
00:27:21,600 --> 00:27:24,080
so uh in order to build an intuition of

496
00:27:24,080 --> 00:27:25,440
what symbolic execution

497
00:27:25,440 --> 00:27:29,200
is we will compare and contrast it with

498
00:27:29,200 --> 00:27:32,399
concrete execution so concrete execution

499
00:27:32,399 --> 00:27:35,440
over here is uh how normal execution

500
00:27:35,440 --> 00:27:38,080
happens ie execution actual data

501
00:27:38,080 --> 00:27:40,559
so uh as you can see in the table

502
00:27:40,559 --> 00:27:41,679
illustrated on the side

503
00:27:41,679 --> 00:27:44,000
slide over here symbolic execution

504
00:27:44,000 --> 00:27:46,240
executes in symbolic values whereas

505
00:27:46,240 --> 00:27:48,000
in concrete execution we use actual

506
00:27:48,000 --> 00:27:50,240
values with symbolic execution we

507
00:27:50,240 --> 00:27:52,240
compute logical formulas over

508
00:27:52,240 --> 00:27:54,799
these symbols whereas concrete execution

509
00:27:54,799 --> 00:27:57,440
determines exact values as determined by

510
00:27:57,440 --> 00:27:59,919
the execution

511
00:27:59,919 --> 00:28:01,919
in symbolic execution we also emulate

512
00:28:01,919 --> 00:28:03,840
all possible control flows

513
00:28:03,840 --> 00:28:06,240
the reason for this is that what we're

514
00:28:06,240 --> 00:28:07,440
doing when we

515
00:28:07,440 --> 00:28:09,279
reach a condition statement is just

516
00:28:09,279 --> 00:28:10,960
creating a formula for it and then

517
00:28:10,960 --> 00:28:12,480
continuing on all

518
00:28:12,480 --> 00:28:15,039
execution paths normally however in

519
00:28:15,039 --> 00:28:15,600
concrete

520
00:28:15,600 --> 00:28:19,200
execution during one run uh we can only

521
00:28:19,200 --> 00:28:20,720
execute along one

522
00:28:20,720 --> 00:28:24,240
uh control flow path

523
00:28:24,240 --> 00:28:28,559
all right so in order to uh

524
00:28:28,559 --> 00:28:30,960
yeah in order to explain um properly

525
00:28:30,960 --> 00:28:32,399
what symbolic execution

526
00:28:32,399 --> 00:28:36,080
is uh i will go over a small example

527
00:28:36,080 --> 00:28:37,679
uh but before that we'll have to

528
00:28:37,679 --> 00:28:39,760
understand uh

529
00:28:39,760 --> 00:28:42,840
a concept of the concept of symbolic

530
00:28:42,840 --> 00:28:44,640
state so

531
00:28:44,640 --> 00:28:46,799
uh symbolic state can be regarded as a

532
00:28:46,799 --> 00:28:48,559
parallel of concrete state of the

533
00:28:48,559 --> 00:28:52,240
program at any point in the execution

534
00:28:52,240 --> 00:28:54,799
and however in the symbolic state this

535
00:28:54,799 --> 00:28:55,520
uh this

536
00:28:55,520 --> 00:28:57,600
symbolic execution the state comprises

537
00:28:57,600 --> 00:28:58,960
of two components

538
00:28:58,960 --> 00:29:00,880
the symbolic expressions and the path

539
00:29:00,880 --> 00:29:02,240
constraints

540
00:29:02,240 --> 00:29:06,080
so symbolic expressions are

541
00:29:06,480 --> 00:29:08,320
is either a symbolic value or a

542
00:29:08,320 --> 00:29:10,000
combination of other symbolic

543
00:29:10,000 --> 00:29:11,679
expressions

544
00:29:11,679 --> 00:29:14,080
whereas path constraints encode the

545
00:29:14,080 --> 00:29:17,600
limitations on the symbolic expressions

546
00:29:17,600 --> 00:29:19,039
as determined by the condition

547
00:29:19,039 --> 00:29:20,720
statements

548
00:29:20,720 --> 00:29:24,000
so briefly

549
00:29:24,000 --> 00:29:26,240
going over this example what we see on

550
00:29:26,240 --> 00:29:28,240
the left is some code with certain

551
00:29:28,240 --> 00:29:29,919
with multiple different control flow

552
00:29:29,919 --> 00:29:31,679
paths and on the right what we see

553
00:29:31,679 --> 00:29:34,960
is uh a graphical illustration of

554
00:29:34,960 --> 00:29:38,399
what a symbolic state might look like so

555
00:29:38,399 --> 00:29:40,480
we have three symbolic variables in this

556
00:29:40,480 --> 00:29:42,320
case denoted by alpha

557
00:29:42,320 --> 00:29:45,360
beta and gamma and three concrete values

558
00:29:45,360 --> 00:29:47,840
x y and z uh concrete values actually

559
00:29:47,840 --> 00:29:49,840
take on actual data during the execution

560
00:29:49,840 --> 00:29:50,480
whereas

561
00:29:50,480 --> 00:29:54,559
the symbolic uh values are represented

562
00:29:54,559 --> 00:29:56,159
by their logical formula

563
00:29:56,159 --> 00:29:58,000
the important thing to note over here is

564
00:29:58,000 --> 00:30:00,880
at the the leaf nodes of the tree

565
00:30:00,880 --> 00:30:03,520
denoted by the diamonds have certain

566
00:30:03,520 --> 00:30:05,200
logical formulas in them

567
00:30:05,200 --> 00:30:09,200
these logical formulas uh describe

568
00:30:09,200 --> 00:30:11,679
under what conditions this particular

569
00:30:11,679 --> 00:30:14,640
control flow path will be taken

570
00:30:14,640 --> 00:30:17,039
all right so so far what we've done is

571
00:30:17,039 --> 00:30:18,159
we've covered uh

572
00:30:18,159 --> 00:30:20,240
the theory briefly the theory behind

573
00:30:20,240 --> 00:30:21,840
dynamic gained analysis and symbolic

574
00:30:21,840 --> 00:30:23,279
code execution

575
00:30:23,279 --> 00:30:26,399
so recapping uh

576
00:30:26,399 --> 00:30:29,360
dynamic analysis allows us to track

577
00:30:29,360 --> 00:30:31,679
information flow between

578
00:30:31,679 --> 00:30:33,360
different sections of the program

579
00:30:33,360 --> 00:30:35,520
whereas symbolic code execution gives us

580
00:30:35,520 --> 00:30:38,159
the ability to reason about the program

581
00:30:38,159 --> 00:30:41,840
by constructing logical formulae uh

582
00:30:41,840 --> 00:30:44,640
about the different uh logical formulas

583
00:30:44,640 --> 00:30:46,080
regarding the different control flow

584
00:30:46,080 --> 00:30:47,200
paths

585
00:30:47,200 --> 00:30:50,240
all right so for the obfuscation

586
00:30:50,240 --> 00:30:52,000
procedure the tool that we will be using

587
00:30:52,000 --> 00:30:53,279
is triton

588
00:30:53,279 --> 00:30:55,520
uh triton allows us to perform symbolic

589
00:30:55,520 --> 00:30:56,399
execution

590
00:30:56,399 --> 00:31:00,640
uh backward slicing and dynamic analysis

591
00:31:00,640 --> 00:31:03,200
so in order to contextualize our

592
00:31:03,200 --> 00:31:05,440
de-officiation procedure what we will do

593
00:31:05,440 --> 00:31:09,200
is we will uh run it over an example

594
00:31:09,200 --> 00:31:11,600
virtualized routine so in this case the

595
00:31:11,600 --> 00:31:12,720
virtualized routine that we'll be

596
00:31:12,720 --> 00:31:14,559
working with is a simple factorial

597
00:31:14,559 --> 00:31:15,760
algorithm

598
00:31:15,760 --> 00:31:17,519
i'm sure everybody is familiar with

599
00:31:17,519 --> 00:31:20,000
factorio uh

600
00:31:20,000 --> 00:31:22,320
just going over briefly what that code

601
00:31:22,320 --> 00:31:23,919
describes is that

602
00:31:23,919 --> 00:31:25,519
we begin by checking whether input is

603
00:31:25,519 --> 00:31:27,360
greater than zero input less than zero

604
00:31:27,360 --> 00:31:27,679
is

605
00:31:27,679 --> 00:31:30,000
obviously undefined uh the factorial

606
00:31:30,000 --> 00:31:31,600
function then begins

607
00:31:31,600 --> 00:31:34,399
with the structure this stack as

608
00:31:34,399 --> 00:31:36,480
illustrated on the slide

609
00:31:36,480 --> 00:31:37,760
with the top of the stack being the

610
00:31:37,760 --> 00:31:39,440
counter the second value being the

611
00:31:39,440 --> 00:31:41,440
running sum and the original value

612
00:31:41,440 --> 00:31:44,720
and the third uh item on the stack being

613
00:31:44,720 --> 00:31:45,760
the

614
00:31:45,760 --> 00:31:49,519
inputed value we then manipulate the

615
00:31:49,519 --> 00:31:50,080
stack

616
00:31:50,080 --> 00:31:52,480
according to the logic necessary and

617
00:31:52,480 --> 00:31:54,240
arrived at the sum

618
00:31:54,240 --> 00:31:57,919
so uh the defection procedure we will be

619
00:31:57,919 --> 00:31:58,640
presenting

620
00:31:58,640 --> 00:32:02,080
is a simple simplification of the

621
00:32:02,080 --> 00:32:04,399
approach described in the paper

622
00:32:04,399 --> 00:32:06,720
symbolic definition virtualized code

623
00:32:06,720 --> 00:32:09,760
back to the original

624
00:32:09,919 --> 00:32:12,840
the algorithm involves three steps

625
00:32:12,840 --> 00:32:14,240
primarily uh

626
00:32:14,240 --> 00:32:17,360
step one or step zero uh would be

627
00:32:17,360 --> 00:32:18,320
identifying

628
00:32:18,320 --> 00:32:20,799
the region to analyze the next step

629
00:32:20,799 --> 00:32:22,720
would be performing taint analysis to

630
00:32:22,720 --> 00:32:24,640
isolate pertinent instructions

631
00:32:24,640 --> 00:32:26,240
and the final step would be

632
00:32:26,240 --> 00:32:29,120
reconstructing the virtualized routine

633
00:32:29,120 --> 00:32:32,159
so uh the first step

634
00:32:32,159 --> 00:32:35,519
which is manually reverse requires you

635
00:32:35,519 --> 00:32:37,440
to manually reverse engineer the binary

636
00:32:37,440 --> 00:32:39,840
in order to identify whether

637
00:32:39,840 --> 00:32:42,159
uh a virtualized routine is present or

638
00:32:42,159 --> 00:32:44,240
not obviously this requires some

639
00:32:44,240 --> 00:32:46,480
uh experience handling and reverse

640
00:32:46,480 --> 00:32:47,519
engineering

641
00:32:47,519 --> 00:32:51,120
uh virtualized code uh there are some

642
00:32:51,120 --> 00:32:52,399
projects that attempt to do this

643
00:32:52,399 --> 00:32:54,080
automatically

644
00:32:54,080 --> 00:32:56,559
but they are such as vm hunt for example

645
00:32:56,559 --> 00:32:58,000
but they are not generic

646
00:32:58,000 --> 00:32:59,840
and what they generally do is look for

647
00:32:59,840 --> 00:33:01,120
heuristics

648
00:33:01,120 --> 00:33:05,200
uh of known uh

649
00:33:05,200 --> 00:33:06,480
they look for basically look for

650
00:33:06,480 --> 00:33:08,320
artifacts of known

651
00:33:08,320 --> 00:33:11,519
uh virtualization over virtual

652
00:33:11,519 --> 00:33:14,720
virtualization solution providers uh so

653
00:33:14,720 --> 00:33:17,679
they are pretty simple to circumvent by

654
00:33:17,679 --> 00:33:18,480
just

655
00:33:18,480 --> 00:33:21,360
designing your vm machine so that those

656
00:33:21,360 --> 00:33:23,600
artifacts are not present

657
00:33:23,600 --> 00:33:26,720
so uh dynamic gained analysis which is

658
00:33:26,720 --> 00:33:27,600
the second step

659
00:33:27,600 --> 00:33:30,080
uh we begin by identifying the source of

660
00:33:30,080 --> 00:33:32,480
input for the virtualized region

661
00:33:32,480 --> 00:33:36,080
so the main purpose of this step is to

662
00:33:36,080 --> 00:33:37,919
isolate the vm machinery

663
00:33:37,919 --> 00:33:39,360
meaning we want the set of the

664
00:33:39,360 --> 00:33:41,600
instructions that belong to the bytecode

665
00:33:41,600 --> 00:33:42,399
interpreter

666
00:33:42,399 --> 00:33:44,159
which executes the virtualized routine

667
00:33:44,159 --> 00:33:45,679
at runtime

668
00:33:45,679 --> 00:33:47,200
this step is conducted so we can

669
00:33:47,200 --> 00:33:49,120
pinpoint the region to emulate during

670
00:33:49,120 --> 00:33:50,960
symbolic execution

671
00:33:50,960 --> 00:33:52,799
the virtualized routine is likely to be

672
00:33:52,799 --> 00:33:54,320
taking input from

673
00:33:54,320 --> 00:33:56,799
some external source which determines

674
00:33:56,799 --> 00:33:58,640
its execution so for example

675
00:33:58,640 --> 00:34:01,360
in the factorial algorithm we presented

676
00:34:01,360 --> 00:34:02,159
the

677
00:34:02,159 --> 00:34:04,640
the routine takes input from the user

678
00:34:04,640 --> 00:34:05,440
but the input

679
00:34:05,440 --> 00:34:08,159
input could come from anywhere the uh

680
00:34:08,159 --> 00:34:09,918
any any source of in the external

681
00:34:09,918 --> 00:34:11,280
environment

682
00:34:11,280 --> 00:34:13,280
once the vm terminates the results of

683
00:34:13,280 --> 00:34:14,800
this computations can be used by the

684
00:34:14,800 --> 00:34:16,159
rest of the program

685
00:34:16,159 --> 00:34:19,280
uh so the approach is to identify where

686
00:34:19,280 --> 00:34:21,760
this input is taken from

687
00:34:21,760 --> 00:34:23,440
then paint the memory location where

688
00:34:23,440 --> 00:34:25,040
this value is held

689
00:34:25,040 --> 00:34:27,199
as the vm executes the taint will

690
00:34:27,199 --> 00:34:29,520
propagate until we reach a predefined

691
00:34:29,520 --> 00:34:34,159
sync where this input is then used

692
00:34:34,159 --> 00:34:36,800
the output of this instruction will be

693
00:34:36,800 --> 00:34:38,320
the output of this step will be an

694
00:34:38,320 --> 00:34:38,960
instruction

695
00:34:38,960 --> 00:34:41,760
trace of the vm execution by doing this

696
00:34:41,760 --> 00:34:43,918
what we have managed to do is to isolate

697
00:34:43,918 --> 00:34:47,280
the instructions uh

698
00:34:47,280 --> 00:34:49,280
to some degree of accuracy that

699
00:34:49,280 --> 00:34:51,119
illustrate uh

700
00:34:51,119 --> 00:34:53,520
illustrate that define the execution

701
00:34:53,520 --> 00:34:55,040
trace of the

702
00:34:55,040 --> 00:34:58,560
virtual machine so uh i'll briefly

703
00:34:58,560 --> 00:35:00,160
discuss how one can go about finding

704
00:35:00,160 --> 00:35:01,119
pain sources

705
00:35:01,119 --> 00:35:03,200
i mean one approach would be to use

706
00:35:03,200 --> 00:35:05,359
stress or else to identify

707
00:35:05,359 --> 00:35:07,839
a possible library and system calls and

708
00:35:07,839 --> 00:35:08,880
then

709
00:35:08,880 --> 00:35:10,880
viewing their use in the assembly to see

710
00:35:10,880 --> 00:35:13,200
whether the input is used anywhere

711
00:35:13,200 --> 00:35:15,920
in the suspected code portion but this

712
00:35:15,920 --> 00:35:16,400
is

713
00:35:16,400 --> 00:35:17,920
this approach is simple and may not

714
00:35:17,920 --> 00:35:20,560
scale very well to complicated programs

715
00:35:20,560 --> 00:35:22,480
so a better solution might be to use

716
00:35:22,480 --> 00:35:24,480
something like a binary instrumentation

717
00:35:24,480 --> 00:35:25,680
framework where we can

718
00:35:25,680 --> 00:35:28,160
automatically look at the values coming

719
00:35:28,160 --> 00:35:28,880
in from

720
00:35:28,880 --> 00:35:30,880
different sources track their progress

721
00:35:30,880 --> 00:35:32,480
through the execution

722
00:35:32,480 --> 00:35:35,280
and see whether they end up being used

723
00:35:35,280 --> 00:35:37,200
in the suspected portion of the code

724
00:35:37,200 --> 00:35:40,800
this might be a better approach for

725
00:35:40,800 --> 00:35:44,000
a more complicated program so

726
00:35:44,000 --> 00:35:45,599
the final step in our de-obfuscation

727
00:35:45,599 --> 00:35:48,160
procedure is symbolic execution

728
00:35:48,160 --> 00:35:50,720
uh so what we do is we perform symbolic

729
00:35:50,720 --> 00:35:51,920
execution

730
00:35:51,920 --> 00:35:53,839
uh and then compute the backward slice

731
00:35:53,839 --> 00:35:56,240
from the vm output to the painted input

732
00:35:56,240 --> 00:35:58,800
so i'll go over some of the details of

733
00:35:58,800 --> 00:36:00,560
these steps so we can understand what is

734
00:36:00,560 --> 00:36:02,160
going on over here

735
00:36:02,160 --> 00:36:05,280
so symbolically executing the code

736
00:36:05,280 --> 00:36:06,640
so what we do is we begin by

737
00:36:06,640 --> 00:36:08,480
symbolically executing the code from the

738
00:36:08,480 --> 00:36:10,800
paint source to the vm output

739
00:36:10,800 --> 00:36:14,960
uh the reason for this is so the

740
00:36:14,960 --> 00:36:17,119
so in order to do this what we need to

741
00:36:17,119 --> 00:36:20,480
do is we need to provide a memory map

742
00:36:20,480 --> 00:36:23,040
which is something like a snapshot of

743
00:36:23,040 --> 00:36:23,920
the

744
00:36:23,920 --> 00:36:27,119
memory before we enter the virtualized

745
00:36:27,119 --> 00:36:27,920
routine

746
00:36:27,920 --> 00:36:30,000
the reason we do this is because we only

747
00:36:30,000 --> 00:36:32,000
want to symbolically emulate

748
00:36:32,000 --> 00:36:34,800
uh the virtualized routine and not the

749
00:36:34,800 --> 00:36:36,320
entire program

750
00:36:36,320 --> 00:36:38,400
uh this is so that we can actually drive

751
00:36:38,400 --> 00:36:39,680
execution

752
00:36:39,680 --> 00:36:43,200
to the uh virtualized routine so that

753
00:36:43,200 --> 00:36:45,680
we can then begin to analyze it uh this

754
00:36:45,680 --> 00:36:46,240
memory mac

755
00:36:46,240 --> 00:36:48,079
and again we build using a dvr framework

756
00:36:48,079 --> 00:36:50,000
or a debugger

757
00:36:50,000 --> 00:36:53,040
and such things so as we symbolically

758
00:36:53,040 --> 00:36:54,720
execute each instruction we build a

759
00:36:54,720 --> 00:36:57,200
symbolic expression for them

760
00:36:57,200 --> 00:36:59,119
uh each instruction is defined as a

761
00:36:59,119 --> 00:37:01,440
function in brick vector logic

762
00:37:01,440 --> 00:37:05,200
uh so i i will skip

763
00:37:05,200 --> 00:37:08,400
uh some of the details about how

764
00:37:08,400 --> 00:37:11,920
the symbolic construction of each of the

765
00:37:11,920 --> 00:37:13,440
instructions happens

766
00:37:13,440 --> 00:37:15,839
but the main idea is that what we do as

767
00:37:15,839 --> 00:37:17,839
mentioned before what we do is we

768
00:37:17,839 --> 00:37:22,000
construct a logical formula associated

769
00:37:22,000 --> 00:37:25,119
with the memory locations being operated

770
00:37:25,119 --> 00:37:26,400
on

771
00:37:26,400 --> 00:37:29,520
so uh finally we reach the

772
00:37:29,520 --> 00:37:31,200
point where we're actually in a position

773
00:37:31,200 --> 00:37:33,760
to perform the backward slice

774
00:37:33,760 --> 00:37:35,599
the pseudocode for performing the back

775
00:37:35,599 --> 00:37:37,119
precise straightforward

776
00:37:37,119 --> 00:37:40,720
we start at a given address

777
00:37:40,960 --> 00:37:43,839
we continue symbolically executing each

778
00:37:43,839 --> 00:37:46,320
instructions until we reach the point

779
00:37:46,320 --> 00:37:48,960
determined

780
00:37:49,520 --> 00:37:51,760
until we reach the point from which we

781
00:37:51,760 --> 00:37:53,119
want to compute

782
00:37:53,119 --> 00:37:57,119
the backward slice uh once we reach this

783
00:37:57,119 --> 00:38:01,040
point uh what we do is uh

784
00:38:01,040 --> 00:38:02,720
yeah once we reach this point we can

785
00:38:02,720 --> 00:38:04,320
compute the backward slice which then

786
00:38:04,320 --> 00:38:04,720
gives

787
00:38:04,720 --> 00:38:07,280
us all of the previous instructions that

788
00:38:07,280 --> 00:38:09,680
contributed to the value

789
00:38:09,680 --> 00:38:12,960
of the instruction at that point uh what

790
00:38:12,960 --> 00:38:15,200
this will allow us to do is it will

791
00:38:15,200 --> 00:38:18,240
isolate the virtualized algorithm

792
00:38:18,240 --> 00:38:20,640
from all of the vm machinery so that we

793
00:38:20,640 --> 00:38:22,000
can actually look at the data

794
00:38:22,000 --> 00:38:23,839
manipulations that happen

795
00:38:23,839 --> 00:38:27,200
uh in order uh for the uh the routine

796
00:38:27,200 --> 00:38:29,040
the obligated routine to generate

797
00:38:29,040 --> 00:38:34,000
its output so uh

798
00:38:35,839 --> 00:38:38,720
yeah so

799
00:38:38,880 --> 00:38:42,800
basically uh what we end up with is uh

800
00:38:42,800 --> 00:38:46,160
uh we get a trace representing all of

801
00:38:46,160 --> 00:38:47,119
the

802
00:38:47,119 --> 00:38:48,800
instructions that contribute to the

803
00:38:48,800 --> 00:38:52,079
value at the slice address

804
00:38:52,079 --> 00:38:54,480
for our factorial function examples once

805
00:38:54,480 --> 00:38:56,000
we execute this program

806
00:38:56,000 --> 00:38:57,839
we get this neat little trace of

807
00:38:57,839 --> 00:38:59,359
alternating add and multiply

808
00:38:59,359 --> 00:39:00,960
instructions

809
00:39:00,960 --> 00:39:02,640
working through these in the debugger

810
00:39:02,640 --> 00:39:05,119
and observing how the

811
00:39:05,119 --> 00:39:07,119
the values actually change across the

812
00:39:07,119 --> 00:39:08,800
execution it's pretty simple to conclude

813
00:39:08,800 --> 00:39:11,280
that it's a factorial

814
00:39:11,280 --> 00:39:13,119
function however for more complicated

815
00:39:13,119 --> 00:39:15,359
routines it might not be that simple

816
00:39:15,359 --> 00:39:17,520
however at least what we have done so

817
00:39:17,520 --> 00:39:19,920
far is to completely isolate

818
00:39:19,920 --> 00:39:22,960
completely extract uh the virtualized

819
00:39:22,960 --> 00:39:23,520
routine

820
00:39:23,520 --> 00:39:25,599
from the entire office the virtualizing

821
00:39:25,599 --> 00:39:28,160
office station

822
00:39:28,160 --> 00:39:31,760
so uh to recap what we've done so far is

823
00:39:31,760 --> 00:39:34,079
uh by computing the backward slice we

824
00:39:34,079 --> 00:39:36,000
have gotten our virtualized routine

825
00:39:36,000 --> 00:39:37,839
which means we've effectively removed

826
00:39:37,839 --> 00:39:40,560
all instructions related to vm machinery

827
00:39:40,560 --> 00:39:42,320
and thus are left with the instructions

828
00:39:42,320 --> 00:39:44,160
that execute that or

829
00:39:44,160 --> 00:39:45,920
that execute the logic of the

830
00:39:45,920 --> 00:39:48,160
virtualized program

831
00:39:48,160 --> 00:39:50,560
so at this point what we've we've

832
00:39:50,560 --> 00:39:51,760
reached the final step

833
00:39:51,760 --> 00:39:54,560
we've managed to extract the offscated

834
00:39:54,560 --> 00:39:55,119
routine

835
00:39:55,119 --> 00:39:58,720
and now uh begins the grunt work of

836
00:39:58,720 --> 00:39:59,359
actually

837
00:39:59,359 --> 00:40:01,200
figuring out what that routine is trying

838
00:40:01,200 --> 00:40:02,560
to do

839
00:40:02,560 --> 00:40:05,440
and that is the end of a talk we are

840
00:40:05,440 --> 00:40:07,280
open to taking questions

841
00:40:07,280 --> 00:40:10,480
and if somebody cannot get their

842
00:40:10,480 --> 00:40:12,160
questions in right now they can get in

843
00:40:12,160 --> 00:40:12,640
touch

844
00:40:12,640 --> 00:40:15,359
with us over twitter and our handlers

845
00:40:15,359 --> 00:40:16,640
should be available on the screen right

846
00:40:16,640 --> 00:40:18,319
now

847
00:40:18,319 --> 00:40:24,160
thank you

848
00:40:24,160 --> 00:40:26,720
thank you burke and your sama for uh for

849
00:40:26,720 --> 00:40:27,440
uh

850
00:40:27,440 --> 00:40:29,119
bearing with us for working through the

851
00:40:29,119 --> 00:40:30,720
technical difficulties and still being

852
00:40:30,720 --> 00:40:32,160
able to deliver your talk

853
00:40:32,160 --> 00:40:35,920
um thank you for organizing this event

854
00:40:35,920 --> 00:40:37,520
especially during times like these and

855
00:40:37,520 --> 00:40:39,040
thank you for

856
00:40:39,040 --> 00:40:53,839
letting us present our work over here

857
00:41:12,640 --> 00:41:14,720
you

