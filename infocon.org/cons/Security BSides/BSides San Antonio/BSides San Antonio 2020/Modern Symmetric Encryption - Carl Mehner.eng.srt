1
00:00:00,799 --> 00:00:03,439
all right thanks

2
00:00:03,439 --> 00:00:05,440
really excited to be talking here at

3
00:00:05,440 --> 00:00:06,960
b-sides

4
00:00:06,960 --> 00:00:10,080
virtually so

5
00:00:10,080 --> 00:00:13,920
um if you haven't gone over to the

6
00:00:13,920 --> 00:00:16,400
crypto puzzles channel in slack uh

7
00:00:16,400 --> 00:00:18,000
highly encourage you to do so

8
00:00:18,000 --> 00:00:19,279
if you're coming here from the crypto

9
00:00:19,279 --> 00:00:21,359
puzzle channel in slack you

10
00:00:21,359 --> 00:00:23,199
might get some hints on the puzzle

11
00:00:23,199 --> 00:00:25,920
listening to the talk

12
00:00:25,920 --> 00:00:28,960
so here we are to talk about modern

13
00:00:28,960 --> 00:00:30,720
symmetric encryption

14
00:00:30,720 --> 00:00:32,479
hiding important messages sent between

15
00:00:32,479 --> 00:00:34,160
two people it's

16
00:00:34,160 --> 00:00:36,320
been in a goal of people from as far

17
00:00:36,320 --> 00:00:37,600
back as

18
00:00:37,600 --> 00:00:40,559
second grade it might actually go back a

19
00:00:40,559 --> 00:00:42,000
little bit farther

20
00:00:42,000 --> 00:00:46,160
in 1 500 bc uh mesopotamian potter

21
00:00:46,160 --> 00:00:48,320
encrypted the method for making his

22
00:00:48,320 --> 00:00:49,600
pottery glaze

23
00:00:49,600 --> 00:00:52,719
and inscribed it on a clay tablet this

24
00:00:52,719 --> 00:00:53,600
would have been really important

25
00:00:53,600 --> 00:00:56,320
information for him and valuable

26
00:00:56,320 --> 00:00:58,960
as a tradesman so the added effort of

27
00:00:58,960 --> 00:01:00,399
protecting the method for

28
00:01:00,399 --> 00:01:02,960
waterproofing and decorating his pottery

29
00:01:02,960 --> 00:01:04,959
totally makes sense

30
00:01:04,959 --> 00:01:07,040
ancient hebrew people also made use of

31
00:01:07,040 --> 00:01:09,520
encryption using a substitution cipher

32
00:01:09,520 --> 00:01:11,600
to encode the names of their enemies and

33
00:01:11,600 --> 00:01:12,720
parts of the bible

34
00:01:12,720 --> 00:01:16,320
as early as the 600s bc by the time the

35
00:01:16,320 --> 00:01:18,240
roman empire took over the greeks and

36
00:01:18,240 --> 00:01:21,680
population and power julius caesar

37
00:01:21,680 --> 00:01:23,360
improved the speed of encryption

38
00:01:23,360 --> 00:01:25,520
algorithms by taking each letter in a

39
00:01:25,520 --> 00:01:26,000
message

40
00:01:26,000 --> 00:01:28,720
and shifting it forward three places

41
00:01:28,720 --> 00:01:29,200
later

42
00:01:29,200 --> 00:01:32,159
his nephew augustus modified the cipher

43
00:01:32,159 --> 00:01:33,200
and instead of

44
00:01:33,200 --> 00:01:35,600
shifting messages three places only

45
00:01:35,600 --> 00:01:36,720
shifted them forward

46
00:01:36,720 --> 00:01:39,280
one letter i guess three was a little

47
00:01:39,280 --> 00:01:41,200
too hard

48
00:01:41,200 --> 00:01:44,159
by 1467 rather than encrypting just one

49
00:01:44,159 --> 00:01:45,200
letter at a time

50
00:01:45,200 --> 00:01:48,079
encryption schemes started using two

51
00:01:48,079 --> 00:01:49,280
block letters and

52
00:01:49,280 --> 00:01:52,399
keys based on words phrases rather than

53
00:01:52,399 --> 00:01:52,720
a

54
00:01:52,720 --> 00:01:56,240
rotation of just a number from 1 to 25

55
00:01:56,240 --> 00:01:58,079
like the caesar cipher

56
00:01:58,079 --> 00:01:59,680
this brought an important feature to in

57
00:01:59,680 --> 00:02:01,680
cypher messages previously

58
00:02:01,680 --> 00:02:04,159
any one of the plain text letters always

59
00:02:04,159 --> 00:02:05,600
translated to the same

60
00:02:05,600 --> 00:02:08,959
cipher letter but now there's lots more

61
00:02:08,959 --> 00:02:10,560
plain text possibilities for every

62
00:02:10,560 --> 00:02:12,319
letter in the cipher text making

63
00:02:12,319 --> 00:02:15,360
decryption much harder

64
00:02:15,360 --> 00:02:18,080
world war ii is often considered by many

65
00:02:18,080 --> 00:02:19,120
the start of

66
00:02:19,120 --> 00:02:22,560
modern cryptography with the advent

67
00:02:22,560 --> 00:02:24,480
of the use of machines rather than by

68
00:02:24,480 --> 00:02:26,400
hand calculations

69
00:02:26,400 --> 00:02:28,720
these cypher machines allowed for more

70
00:02:28,720 --> 00:02:31,360
complex ciphers to be executed faster

71
00:02:31,360 --> 00:02:33,599
and prevented calculations designed to

72
00:02:33,599 --> 00:02:35,040
break encryption

73
00:02:35,040 --> 00:02:38,239
from being effectively done by hand

74
00:02:38,239 --> 00:02:40,239
so various cipher designers from

75
00:02:40,239 --> 00:02:41,519
different countries

76
00:02:41,519 --> 00:02:43,519
contrived several machines for use in

77
00:02:43,519 --> 00:02:45,040
wartime and

78
00:02:45,040 --> 00:02:47,120
many continued the use of the improved

79
00:02:47,120 --> 00:02:48,800
versions of these cypher machines

80
00:02:48,800 --> 00:02:51,519
until the advent of modern computing

81
00:02:51,519 --> 00:02:52,560
systems

82
00:02:52,560 --> 00:02:54,720
which brought about the ability to

83
00:02:54,720 --> 00:02:56,720
greatly impact the effectiveness of

84
00:02:56,720 --> 00:03:00,400
those cypher machines at the same time

85
00:03:00,400 --> 00:03:01,920
cypher machine security was being

86
00:03:01,920 --> 00:03:03,440
improved and their internal

87
00:03:03,440 --> 00:03:05,200
complications increased

88
00:03:05,200 --> 00:03:06,800
mathematical advances in the field of

89
00:03:06,800 --> 00:03:09,519
cryptography likewise moved forward

90
00:03:09,519 --> 00:03:11,440
during the first half century or during

91
00:03:11,440 --> 00:03:13,680
the half century following world war ii

92
00:03:13,680 --> 00:03:17,120
increase it increased research into

93
00:03:17,120 --> 00:03:18,480
cryptography from both

94
00:03:18,480 --> 00:03:20,000
private companies and public

95
00:03:20,000 --> 00:03:21,760
universities and

96
00:03:21,760 --> 00:03:23,760
that research continued at a ever

97
00:03:23,760 --> 00:03:25,680
accelerating pace

98
00:03:25,680 --> 00:03:28,799
since it was critical for a war limits

99
00:03:28,799 --> 00:03:29,920
were imposed on

100
00:03:29,920 --> 00:03:32,879
the now much stronger cryptography these

101
00:03:32,879 --> 00:03:34,400
cryptographic systems were

102
00:03:34,400 --> 00:03:37,519
restricted from export from the us and

103
00:03:37,519 --> 00:03:40,560
put in the category with nuclear bombs

104
00:03:40,560 --> 00:03:44,159
design and even horses which

105
00:03:44,159 --> 00:03:47,920
probably came from a much earlier era

106
00:03:47,920 --> 00:03:50,879
this is the landscape that bore the data

107
00:03:50,879 --> 00:03:52,239
encryption standard or

108
00:03:52,239 --> 00:03:55,920
des or dez which is now considered

109
00:03:55,920 --> 00:03:57,680
woefully inadequate

110
00:03:57,680 --> 00:03:59,519
it could have been better though its

111
00:03:59,519 --> 00:04:00,959
original design had

112
00:04:00,959 --> 00:04:03,599
twice the key size but ended up getting

113
00:04:03,599 --> 00:04:04,720
curtailed by

114
00:04:04,720 --> 00:04:07,920
nsa's tweaks to the algorithm prior to

115
00:04:07,920 --> 00:04:10,879
standardization the restrictions on

116
00:04:10,879 --> 00:04:12,000
cryptography

117
00:04:12,000 --> 00:04:14,319
were relaxed a little bit in the 90s

118
00:04:14,319 --> 00:04:15,920
when the government realized that

119
00:04:15,920 --> 00:04:18,478
it was a lost battle largely due to the

120
00:04:18,478 --> 00:04:19,120
efforts of

121
00:04:19,120 --> 00:04:21,519
international publishers and open source

122
00:04:21,519 --> 00:04:22,960
enthusiasts

123
00:04:22,960 --> 00:04:24,960
in the mid 90s triple des was

124
00:04:24,960 --> 00:04:26,400
standardized publicly

125
00:04:26,400 --> 00:04:29,280
and another cipher called rc4 was leaked

126
00:04:29,280 --> 00:04:30,400
to the public

127
00:04:30,400 --> 00:04:32,160
and then nearing the 2000s nist

128
00:04:32,160 --> 00:04:33,520
announced that they would create an

129
00:04:33,520 --> 00:04:35,520
advanced encryption standard

130
00:04:35,520 --> 00:04:38,479
better known simply as aes and open up

131
00:04:38,479 --> 00:04:41,919
submissions for that to the world

132
00:04:41,919 --> 00:04:44,160
textbooks and cryptography classes

133
00:04:44,160 --> 00:04:46,639
and online examples have been created to

134
00:04:46,639 --> 00:04:47,759
explain

135
00:04:47,759 --> 00:04:51,199
those algorithms triple des rc4 and aes

136
00:04:51,199 --> 00:04:53,440
and depending on the level of course

137
00:04:53,440 --> 00:04:55,360
explanations of the ciphers can range

138
00:04:55,360 --> 00:04:55,840
from

139
00:04:55,840 --> 00:04:58,880
extremely simple like this or

140
00:04:58,880 --> 00:05:01,440
go down to the full cipher detail down

141
00:05:01,440 --> 00:05:01,919
to

142
00:05:01,919 --> 00:05:05,039
each individual byte like this

143
00:05:05,039 --> 00:05:08,080
or this or

144
00:05:08,080 --> 00:05:11,840
put into a more fun format like this one

145
00:05:11,840 --> 00:05:13,759
the problem is whenever you start trying

146
00:05:13,759 --> 00:05:16,400
to explain the algorithm at that level

147
00:05:16,400 --> 00:05:19,520
you end up looking like this

148
00:05:20,639 --> 00:05:22,400
each of these two different explanations

149
00:05:22,400 --> 00:05:24,000
are useful depending on the level

150
00:05:24,000 --> 00:05:26,240
of understanding that you need the

151
00:05:26,240 --> 00:05:27,520
problem comes when

152
00:05:27,520 --> 00:05:29,600
you try to extrapolate out of either

153
00:05:29,600 --> 00:05:31,120
just that deep knowledge

154
00:05:31,120 --> 00:05:33,680
or the very shallow knowledge with no

155
00:05:33,680 --> 00:05:35,440
additional context

156
00:05:35,440 --> 00:05:37,919
you end up with insecure systems these

157
00:05:37,919 --> 00:05:39,360
systems could be

158
00:05:39,360 --> 00:05:40,960
nearly anything encrypting data

159
00:05:40,960 --> 00:05:43,520
databases application storage

160
00:05:43,520 --> 00:05:45,440
transport mechanisms protecting data

161
00:05:45,440 --> 00:05:47,360
sent over the air

162
00:05:47,360 --> 00:05:49,360
in this talk i want to take the road in

163
00:05:49,360 --> 00:05:51,280
between these two views in order to give

164
00:05:51,280 --> 00:05:51,680
you

165
00:05:51,680 --> 00:05:53,759
a better understanding of what the

166
00:05:53,759 --> 00:05:55,360
current best practices are

167
00:05:55,360 --> 00:05:58,639
for safely encrypting data

168
00:05:58,639 --> 00:06:00,560
before we get too far though there is a

169
00:06:00,560 --> 00:06:02,080
little bit of background knowledge

170
00:06:02,080 --> 00:06:03,600
you need to get the most out of this

171
00:06:03,600 --> 00:06:05,440
talk first it's

172
00:06:05,440 --> 00:06:06,960
important to understand that there's two

173
00:06:06,960 --> 00:06:09,440
main types of symmetric key ciphers

174
00:06:09,440 --> 00:06:12,240
block ciphers and stream ciphers both of

175
00:06:12,240 --> 00:06:13,199
these types have an

176
00:06:13,199 --> 00:06:15,280
output indistinguishable from random

177
00:06:15,280 --> 00:06:17,120
noise as long as the algorithm is

178
00:06:17,120 --> 00:06:18,960
cryptographically secure

179
00:06:18,960 --> 00:06:21,360
both des and aes are examples of block

180
00:06:21,360 --> 00:06:22,800
ciphers by design

181
00:06:22,800 --> 00:06:25,680
and then rc4 and salsa 20 are both

182
00:06:25,680 --> 00:06:27,759
stream ciphers

183
00:06:27,759 --> 00:06:30,240
these block ciphers operate over chunks

184
00:06:30,240 --> 00:06:30,800
of data

185
00:06:30,800 --> 00:06:32,800
they take the data break it into blocks

186
00:06:32,800 --> 00:06:34,880
to operate over and the stream ciphers

187
00:06:34,880 --> 00:06:36,080
on the other hand

188
00:06:36,080 --> 00:06:37,919
generate a stream of randomness to

189
00:06:37,919 --> 00:06:39,680
combine with a message

190
00:06:39,680 --> 00:06:42,080
the combining here is done using a

191
00:06:42,080 --> 00:06:42,800
logical

192
00:06:42,800 --> 00:06:46,160
xor which looks at a pair of bits

193
00:06:46,160 --> 00:06:48,560
and then sets the bit or marks down a

194
00:06:48,560 --> 00:06:50,000
one as the answer if the inputs are

195
00:06:50,000 --> 00:06:51,120
different

196
00:06:51,120 --> 00:06:53,680
and then doesn't set or puts a zero if

197
00:06:53,680 --> 00:06:54,479
both of the

198
00:06:54,479 --> 00:06:57,120
inputs are the same the way i was taught

199
00:06:57,120 --> 00:06:58,479
about x4 was

200
00:06:58,479 --> 00:07:02,080
it's one or the other but not both

201
00:07:02,080 --> 00:07:04,639
one of the cool properties of xor is

202
00:07:04,639 --> 00:07:05,280
that it's

203
00:07:05,280 --> 00:07:07,280
fully commutative so if you think of

204
00:07:07,280 --> 00:07:08,560
columns a and b

205
00:07:08,560 --> 00:07:11,199
and the answer as cups in a cup and

206
00:07:11,199 --> 00:07:12,800
balls trick

207
00:07:12,800 --> 00:07:15,520
then to set a bit you can put a ball

208
00:07:15,520 --> 00:07:16,319
onto a cup

209
00:07:16,319 --> 00:07:19,120
so we'll set cup a and b which means

210
00:07:19,120 --> 00:07:20,160
that the answer

211
00:07:20,160 --> 00:07:24,639
because a and b are the same is not set

212
00:07:24,639 --> 00:07:26,319
so now we can take these three cups and

213
00:07:26,319 --> 00:07:28,160
then swish them around into every

214
00:07:28,160 --> 00:07:29,360
different position

215
00:07:29,360 --> 00:07:31,759
and no matter what the equation is still

216
00:07:31,759 --> 00:07:32,400
true

217
00:07:32,400 --> 00:07:34,800
no matter how you mix up the cups the

218
00:07:34,800 --> 00:07:36,560
math holds

219
00:07:36,560 --> 00:07:38,319
this is the math behind what a stream

220
00:07:38,319 --> 00:07:40,479
cipher does

221
00:07:40,479 --> 00:07:42,000
those previous iterations today went

222
00:07:42,000 --> 00:07:43,440
through all but one of the rows in that

223
00:07:43,440 --> 00:07:44,000
truth table

224
00:07:44,000 --> 00:07:46,720
we saw two slides ago the last one is if

225
00:07:46,720 --> 00:07:47,280
both a

226
00:07:47,280 --> 00:07:50,000
and b are not set and that means you

227
00:07:50,000 --> 00:07:52,000
don't set the answer cup either

228
00:07:52,000 --> 00:07:53,199
and of course at this point you can

229
00:07:53,199 --> 00:07:54,879
still slide all the cups around without

230
00:07:54,879 --> 00:07:56,240
changing the truth

231
00:07:56,240 --> 00:07:59,520
of this equation

232
00:07:59,520 --> 00:08:01,440
the random stream of data used with

233
00:08:01,440 --> 00:08:03,280
ciphers goes back to

234
00:08:03,280 --> 00:08:06,960
a really old idea described in 1882

235
00:08:06,960 --> 00:08:09,280
by frank miller used in securing the

236
00:08:09,280 --> 00:08:10,639
telegram

237
00:08:10,639 --> 00:08:13,759
the idea was further developed in 1917

238
00:08:13,759 --> 00:08:15,120
by somebody from bell labs in

239
00:08:15,120 --> 00:08:17,199
conjunction with the u.s army signal

240
00:08:17,199 --> 00:08:18,240
corps

241
00:08:18,240 --> 00:08:19,919
the idea was to have a really really

242
00:08:19,919 --> 00:08:21,520
long random strifer

243
00:08:21,520 --> 00:08:24,879
cipher or a one-time pad as a key

244
00:08:24,879 --> 00:08:27,919
and then combine that with the message a

245
00:08:27,919 --> 00:08:29,360
famous mathematician named claude

246
00:08:29,360 --> 00:08:31,759
shannon was working at bell labs and he

247
00:08:31,759 --> 00:08:33,279
mathematically proved that

248
00:08:33,279 --> 00:08:37,200
a one-time pad if it was truly random

249
00:08:37,200 --> 00:08:41,760
the cipher is completely unbreakable

250
00:08:41,760 --> 00:08:44,159
the goal of these stream ciphers is to

251
00:08:44,159 --> 00:08:45,839
approximate the idea of that

252
00:08:45,839 --> 00:08:47,839
by generating a pseudo-random stream of

253
00:08:47,839 --> 00:08:48,880
data

254
00:08:48,880 --> 00:08:50,959
it looks random but it was generated

255
00:08:50,959 --> 00:08:52,640
through a repeatable process

256
00:08:52,640 --> 00:08:54,480
and then combining that with a message

257
00:08:54,480 --> 00:08:56,560
to produce ciphertext

258
00:08:56,560 --> 00:08:58,080
one of the best things about xor is that

259
00:08:58,080 --> 00:09:00,080
commutative property and once you have

260
00:09:00,080 --> 00:09:02,000
the ciphertext

261
00:09:02,000 --> 00:09:04,240
by rearranging these like the cups and

262
00:09:04,240 --> 00:09:05,279
balls

263
00:09:05,279 --> 00:09:07,760
you can recreate the random stream if

264
00:09:07,760 --> 00:09:09,440
you can recreate that random stream

265
00:09:09,440 --> 00:09:12,560
by using like a keyed stream cipher or

266
00:09:12,560 --> 00:09:15,040
a really long one time pad you can xor

267
00:09:15,040 --> 00:09:16,640
the cipher text and the random stream

268
00:09:16,640 --> 00:09:17,519
together

269
00:09:17,519 --> 00:09:20,640
and get the plain text message back

270
00:09:20,640 --> 00:09:22,000
so now let's quickly turn to block

271
00:09:22,000 --> 00:09:24,880
ciphers this algorithm takes in

272
00:09:24,880 --> 00:09:27,200
data and a key and then outputs an array

273
00:09:27,200 --> 00:09:29,279
of random looking bits

274
00:09:29,279 --> 00:09:32,080
now if you remember earlier that overly

275
00:09:32,080 --> 00:09:33,920
simplistic diagrams can be dangerous if

276
00:09:33,920 --> 00:09:35,200
you try and combine it without the

277
00:09:35,200 --> 00:09:36,080
knowledge

278
00:09:36,080 --> 00:09:39,680
in a greater context here's why

279
00:09:39,680 --> 00:09:41,600
block ciphers have security properties

280
00:09:41,600 --> 00:09:44,000
that are really desirable they promise

281
00:09:44,000 --> 00:09:46,640
that with a secret key a message goes in

282
00:09:46,640 --> 00:09:48,000
random data comes out

283
00:09:48,000 --> 00:09:50,399
it's exactly what we want but what if

284
00:09:50,399 --> 00:09:52,000
the message going in the block is the

285
00:09:52,000 --> 00:09:52,399
same

286
00:09:52,399 --> 00:09:55,200
every single time the output every

287
00:09:55,200 --> 00:09:56,480
single time

288
00:09:56,480 --> 00:09:59,519
is also the same but good news each

289
00:09:59,519 --> 00:10:00,480
block of output is

290
00:10:00,480 --> 00:10:03,440
very random looking but only if you look

291
00:10:03,440 --> 00:10:05,920
at each block by itself

292
00:10:05,920 --> 00:10:07,600
one example of this effect was created

293
00:10:07,600 --> 00:10:10,800
by a student as part of a class paper

294
00:10:10,800 --> 00:10:12,800
and then added to the block cipher page

295
00:10:12,800 --> 00:10:14,880
of wikipedia

296
00:10:14,880 --> 00:10:17,760
this cool idea was greatly improved by

297
00:10:17,760 --> 00:10:19,279
philippa valdestora

298
00:10:19,279 --> 00:10:22,320
in 2013 with a cool pop art rendition of

299
00:10:22,320 --> 00:10:23,600
it

300
00:10:23,600 --> 00:10:26,000
of course understanding the effect of

301
00:10:26,000 --> 00:10:28,640
this because you can see that

302
00:10:28,640 --> 00:10:30,399
the background of the penguin although

303
00:10:30,399 --> 00:10:32,079
encrypted you can definitely tell

304
00:10:32,079 --> 00:10:33,680
there's a penguin there

305
00:10:33,680 --> 00:10:35,120
the cryptographers understood this and

306
00:10:35,120 --> 00:10:36,880
told people never use this mode of block

307
00:10:36,880 --> 00:10:38,880
ciphers from the beginning

308
00:10:38,880 --> 00:10:43,120
and some cryptographic apis like java's

309
00:10:43,120 --> 00:10:47,839
helpfully made at the default

310
00:10:47,839 --> 00:10:50,000
microsoft.net api has a different

311
00:10:50,000 --> 00:10:51,920
default that's a little bit safer it's

312
00:10:51,920 --> 00:10:54,160
called chaining block cipher mode or cbc

313
00:10:54,160 --> 00:10:54,959
mode

314
00:10:54,959 --> 00:10:57,079
this was a concept and developed back in

315
00:10:57,079 --> 00:10:58,240
1976

316
00:10:58,240 --> 00:11:00,880
the mode prevents this penguin problem

317
00:11:00,880 --> 00:11:02,560
by taking the ciphertext

318
00:11:02,560 --> 00:11:05,360
output from the previous block and

319
00:11:05,360 --> 00:11:07,120
xoring it with the input to the next

320
00:11:07,120 --> 00:11:08,480
block

321
00:11:08,480 --> 00:11:11,519
cbc mode is further improved by adding

322
00:11:11,519 --> 00:11:12,560
another input

323
00:11:12,560 --> 00:11:13,920
one that gets passed along with the

324
00:11:13,920 --> 00:11:16,160
ciphertext or it's agreed upon before

325
00:11:16,160 --> 00:11:18,240
beginning any of the encryption

326
00:11:18,240 --> 00:11:21,360
input's called an initialization vector

327
00:11:21,360 --> 00:11:24,240
and commonly is abbreviated iv and

328
00:11:24,240 --> 00:11:25,920
depending on the protocol this iv

329
00:11:25,920 --> 00:11:27,920
is combined somehow into the initial

330
00:11:27,920 --> 00:11:29,279
state of the cipher

331
00:11:29,279 --> 00:11:31,279
so encrypting the same message over and

332
00:11:31,279 --> 00:11:32,959
over with the same key

333
00:11:32,959 --> 00:11:35,680
but with a different iv can produce a

334
00:11:35,680 --> 00:11:37,680
different output as well

335
00:11:37,680 --> 00:11:39,200
because the iv is an input to the

336
00:11:39,200 --> 00:11:41,120
encryption function at the start

337
00:11:41,120 --> 00:11:42,640
it's not related to the key or the

338
00:11:42,640 --> 00:11:45,200
ciphertext it's considered a

339
00:11:45,200 --> 00:11:47,600
public value and can be sent or stored

340
00:11:47,600 --> 00:11:50,240
alongside the ciphertext

341
00:11:50,240 --> 00:11:52,720
cbc mode was used in protocols like tls

342
00:11:52,720 --> 00:11:53,360
for

343
00:11:53,360 --> 00:11:56,320
many many years because aes was fast

344
00:11:56,320 --> 00:11:57,920
built into processors and

345
00:11:57,920 --> 00:12:00,880
really secure but vulnerabilities arose

346
00:12:00,880 --> 00:12:01,920
in the way browsers

347
00:12:01,920 --> 00:12:04,639
implemented the cbc mode of encryption

348
00:12:04,639 --> 00:12:06,639
and it allowed attackers to determine

349
00:12:06,639 --> 00:12:08,160
private information that was encrypted

350
00:12:08,160 --> 00:12:09,680
on the browser side

351
00:12:09,680 --> 00:12:12,000
but allowed things like cookie theft or

352
00:12:12,000 --> 00:12:14,000
session hijacking

353
00:12:14,000 --> 00:12:16,639
one attack like that is called beast

354
00:12:16,639 --> 00:12:19,760
it's an attack back from

355
00:12:19,760 --> 00:12:23,040
2011. and another one is the lucky

356
00:12:23,040 --> 00:12:26,399
lucky 13 attack from 2013.

357
00:12:26,399 --> 00:12:27,760
and there's some great presentations out

358
00:12:27,760 --> 00:12:29,360
there on those that you should look up

359
00:12:29,360 --> 00:12:29,680
and

360
00:12:29,680 --> 00:12:32,160
watch if you're interested the stream

361
00:12:32,160 --> 00:12:34,560
cipher rc4 was used as a way to

362
00:12:34,560 --> 00:12:37,040
mitigate both of these vulnerabilities

363
00:12:37,040 --> 00:12:38,000
at least until a patch

364
00:12:38,000 --> 00:12:39,920
came out or a constant time

365
00:12:39,920 --> 00:12:41,519
implementation can be found

366
00:12:41,519 --> 00:12:45,760
in the case of lucky thirds lucky 13.

367
00:12:45,760 --> 00:12:47,760
but rc4 of course was not devoid of

368
00:12:47,760 --> 00:12:49,279
problems there was some

369
00:12:49,279 --> 00:12:52,079
it was a whole series of serious ssl

370
00:12:52,079 --> 00:12:54,639
security citations surrounding rc4

371
00:12:54,639 --> 00:12:57,440
starting in 2013 and stopping finally in

372
00:12:57,440 --> 00:12:58,959
2015

373
00:12:58,959 --> 00:13:01,920
with the no more attack which again

374
00:13:01,920 --> 00:13:02,399
follow

375
00:13:02,399 --> 00:13:05,600
allowed attackers to reveal private data

376
00:13:05,600 --> 00:13:08,800
about the encrypted text

377
00:13:08,800 --> 00:13:10,800
by themselves modern encryption and

378
00:13:10,800 --> 00:13:12,240
decryption constructs are

379
00:13:12,240 --> 00:13:13,760
excellent at protecting data they take

380
00:13:13,760 --> 00:13:16,079
data in put random data out with no bay

381
00:13:16,079 --> 00:13:17,680
to get back to the original

382
00:13:17,680 --> 00:13:20,079
without the key because of that there's

383
00:13:20,079 --> 00:13:22,079
no clear way to tell if the data being

384
00:13:22,079 --> 00:13:23,200
decrypted

385
00:13:23,200 --> 00:13:25,519
has been modified since it was encrypted

386
00:13:25,519 --> 00:13:27,040
and a lot of those attacks that i just

387
00:13:27,040 --> 00:13:28,160
described

388
00:13:28,160 --> 00:13:29,920
involved the ability for an attacker to

389
00:13:29,920 --> 00:13:32,079
re-inject encrypted blocks or

390
00:13:32,079 --> 00:13:33,839
inject specific blocks into the data

391
00:13:33,839 --> 00:13:35,200
stream or

392
00:13:35,200 --> 00:13:37,600
the receiving end to decrypt and after

393
00:13:37,600 --> 00:13:40,000
the receiver decrypted the data

394
00:13:40,000 --> 00:13:42,000
it would then go and check a checksum to

395
00:13:42,000 --> 00:13:43,440
make sure it was correct

396
00:13:43,440 --> 00:13:45,440
but the timing of that check were and

397
00:13:45,440 --> 00:13:46,560
the rejection or

398
00:13:46,560 --> 00:13:49,120
non-rejection of the decrypted data sent

399
00:13:49,120 --> 00:13:50,880
a signal back to the attacker

400
00:13:50,880 --> 00:13:52,639
allowing them to glean information about

401
00:13:52,639 --> 00:13:55,040
the nature of the plaintext

402
00:13:55,040 --> 00:13:58,240
and and for this reason

403
00:13:58,240 --> 00:14:02,480
modern encryption was modernized

404
00:14:02,480 --> 00:14:05,360
encryption was designed to detect

405
00:14:05,360 --> 00:14:06,720
intentional

406
00:14:06,720 --> 00:14:09,360
unauthorized modifications of the data

407
00:14:09,360 --> 00:14:10,399
as well as

408
00:14:10,399 --> 00:14:13,120
accidental modification in other words

409
00:14:13,120 --> 00:14:14,800
to protect against attacks

410
00:14:14,800 --> 00:14:17,680
modifying the ciphertext encryption

411
00:14:17,680 --> 00:14:18,480
constructs

412
00:14:18,480 --> 00:14:20,639
using authenticated encryption started

413
00:14:20,639 --> 00:14:22,800
appearing in 2000 with

414
00:14:22,800 --> 00:14:26,240
research from ibm universities rsa

415
00:14:26,240 --> 00:14:28,000
laboratories

416
00:14:28,000 --> 00:14:30,720
these contract constructs are specific

417
00:14:30,720 --> 00:14:32,959
ways to utilize an encryption cipher

418
00:14:32,959 --> 00:14:36,639
like aes to not only create ciphertext

419
00:14:36,639 --> 00:14:39,839
but also a tag that authenticates what

420
00:14:39,839 --> 00:14:40,560
was sent

421
00:14:40,560 --> 00:14:43,839
by the sender now there's several

422
00:14:43,839 --> 00:14:44,959
different ways to perform this

423
00:14:44,959 --> 00:14:46,240
authentication

424
00:14:46,240 --> 00:14:48,880
and it's easy to think of it like a

425
00:14:48,880 --> 00:14:51,120
secure hash of the data

426
00:14:51,120 --> 00:14:54,079
one way used by the original design of

427
00:14:54,079 --> 00:14:54,639
ssl

428
00:14:54,639 --> 00:14:57,680
and tls is to put the authentication tag

429
00:14:57,680 --> 00:15:00,240
over the plain text and then encrypt

430
00:15:00,240 --> 00:15:01,440
both the plain text

431
00:15:01,440 --> 00:15:04,240
and the tag together another way is to

432
00:15:04,240 --> 00:15:05,279
do the opposite

433
00:15:05,279 --> 00:15:07,279
you encrypt the text and then create an

434
00:15:07,279 --> 00:15:09,120
authentication tag from the encrypted

435
00:15:09,120 --> 00:15:10,480
value

436
00:15:10,480 --> 00:15:12,800
the final way is to combine the two

437
00:15:12,800 --> 00:15:13,519
ideas

438
00:15:13,519 --> 00:15:15,120
and encrypt both the plain text as well

439
00:15:15,120 --> 00:15:17,120
as the authentication tag that created

440
00:15:17,120 --> 00:15:19,040
from the plain text

441
00:15:19,040 --> 00:15:21,040
with any of these choices upon

442
00:15:21,040 --> 00:15:22,240
decryption

443
00:15:22,240 --> 00:15:23,760
if an authentication tag doesn't

444
00:15:23,760 --> 00:15:26,399
validate then the decryption returns an

445
00:15:26,399 --> 00:15:29,440
error rather than the plain text this is

446
00:15:29,440 --> 00:15:30,079
what's done

447
00:15:30,079 --> 00:15:33,920
in modernly modern cryptography

448
00:15:33,920 --> 00:15:35,680
now unlike basic encryption functions

449
00:15:35,680 --> 00:15:37,519
that just take in a key and a plain text

450
00:15:37,519 --> 00:15:39,199
and output a cipher text

451
00:15:39,199 --> 00:15:40,800
or even the slightly more advanced

452
00:15:40,800 --> 00:15:43,360
version that adds in an initialization

453
00:15:43,360 --> 00:15:44,320
vector

454
00:15:44,320 --> 00:15:46,480
which is sometimes called a nonce or a

455
00:15:46,480 --> 00:15:48,320
number used once

456
00:15:48,320 --> 00:15:51,360
authenticated encryption instead takes a

457
00:15:51,360 --> 00:15:52,320
plain text

458
00:15:52,320 --> 00:15:54,959
a key an initialization vector and

459
00:15:54,959 --> 00:15:55,680
something called

460
00:15:55,680 --> 00:15:59,519
associated data this associated data is

461
00:15:59,519 --> 00:16:00,480
used to

462
00:16:00,480 --> 00:16:04,160
calculate the tag but it doesn't get

463
00:16:04,160 --> 00:16:06,800
it does not get encrypted then you can

464
00:16:06,800 --> 00:16:08,000
notice that the associated

465
00:16:08,000 --> 00:16:10,160
data doesn't go into that encrypt

466
00:16:10,160 --> 00:16:11,920
function

467
00:16:11,920 --> 00:16:14,720
but what is associated data well imagine

468
00:16:14,720 --> 00:16:16,480
sending a postcard with a message

469
00:16:16,480 --> 00:16:18,639
using authenticated encryption you

470
00:16:18,639 --> 00:16:19,920
encrypt the message on the back of the

471
00:16:19,920 --> 00:16:20,720
card

472
00:16:20,720 --> 00:16:22,639
but you still have the two and the from

473
00:16:22,639 --> 00:16:24,720
addresses in plain text

474
00:16:24,720 --> 00:16:26,480
otherwise the postcard wouldn't arrive

475
00:16:26,480 --> 00:16:28,240
at its destination

476
00:16:28,240 --> 00:16:29,519
and you wouldn't be able to receive

477
00:16:29,519 --> 00:16:33,120
replies sent to the from address

478
00:16:33,120 --> 00:16:35,759
the issue is without us authenticated

479
00:16:35,759 --> 00:16:37,360
associated data

480
00:16:37,360 --> 00:16:39,600
anybody can copy the message and the

481
00:16:39,600 --> 00:16:40,959
authentication tag

482
00:16:40,959 --> 00:16:42,959
and any number of times and do things

483
00:16:42,959 --> 00:16:44,160
like reroute it or

484
00:16:44,160 --> 00:16:45,920
change the from address to make it look

485
00:16:45,920 --> 00:16:48,720
like it was sent by somebody else

486
00:16:48,720 --> 00:16:50,000
you'll know the message that you

487
00:16:50,000 --> 00:16:52,000
decrypted was correct

488
00:16:52,000 --> 00:16:53,680
but you would think that it came from

489
00:16:53,680 --> 00:16:55,839
another source

490
00:16:55,839 --> 00:16:58,959
associated data as an input into

491
00:16:58,959 --> 00:17:02,480
the algorithm is used by

492
00:17:02,480 --> 00:17:05,760
internet protocols like tls 1.3 or

493
00:17:05,760 --> 00:17:09,439
the quick method that google started to

494
00:17:09,439 --> 00:17:11,919
make a faster version of tls and it's

495
00:17:11,919 --> 00:17:13,039
used to provide

496
00:17:13,039 --> 00:17:15,760
authenticated proof over the plain text

497
00:17:15,760 --> 00:17:16,480
portions

498
00:17:16,480 --> 00:17:19,839
of the protocols with unauthenticated

499
00:17:19,839 --> 00:17:20,400
encryption

500
00:17:20,400 --> 00:17:22,480
the decrypt function always outputs a

501
00:17:22,480 --> 00:17:24,559
block or stream of ciphertext

502
00:17:24,559 --> 00:17:26,880
it's up to the application to validate

503
00:17:26,880 --> 00:17:29,200
and reject bad data

504
00:17:29,200 --> 00:17:31,280
with authenticated encryption there's

505
00:17:31,280 --> 00:17:32,880
only two options for output

506
00:17:32,880 --> 00:17:36,080
either the actual plain text or an error

507
00:17:36,080 --> 00:17:39,280
message saying that the input was bad

508
00:17:39,280 --> 00:17:41,600
this error output will occur if somebody

509
00:17:41,600 --> 00:17:43,600
changes any of the inputs

510
00:17:43,600 --> 00:17:46,799
ciphertext the tag initialization vector

511
00:17:46,799 --> 00:17:49,760
or the associated data and this ensures

512
00:17:49,760 --> 00:17:50,400
that the

513
00:17:50,400 --> 00:17:52,480
integrity of the plain text is

514
00:17:52,480 --> 00:17:55,039
maintained

515
00:17:55,039 --> 00:17:57,200
currently one of the most widely used

516
00:17:57,200 --> 00:17:59,039
authenticated algorithms

517
00:17:59,039 --> 00:18:02,559
is aes gcm this stands for

518
00:18:02,559 --> 00:18:05,760
galwa counter mode and it refers to the

519
00:18:05,760 --> 00:18:07,280
way that large amounts of data are

520
00:18:07,280 --> 00:18:08,240
encrypted

521
00:18:08,240 --> 00:18:10,559
the counter mode and the way that it's

522
00:18:10,559 --> 00:18:11,760
authenticated

523
00:18:11,760 --> 00:18:15,520
using a galway field in an algorithm

524
00:18:15,520 --> 00:18:16,880
the method for creating this

525
00:18:16,880 --> 00:18:18,880
authentication tag using the galway

526
00:18:18,880 --> 00:18:19,679
field

527
00:18:19,679 --> 00:18:21,840
it's just a mathematically defined group

528
00:18:21,840 --> 00:18:22,720
of a

529
00:18:22,720 --> 00:18:25,200
very very large set of numbers with

530
00:18:25,200 --> 00:18:27,200
defined ways of performing mathematical

531
00:18:27,200 --> 00:18:28,640
operations to ensure that

532
00:18:28,640 --> 00:18:31,679
all the values and operations fall into

533
00:18:31,679 --> 00:18:34,960
numbers within the specific set and

534
00:18:34,960 --> 00:18:36,480
it makes anything that would normally

535
00:18:36,480 --> 00:18:38,960
fall outside of the set

536
00:18:38,960 --> 00:18:41,440
wrap around to the start or to the end

537
00:18:41,440 --> 00:18:43,679
of the set depending on the calculation

538
00:18:43,679 --> 00:18:46,720
and you can see the

539
00:18:46,720 --> 00:18:49,520
function there on the screen the input

540
00:18:49,520 --> 00:18:51,520
and the output for gcm

541
00:18:51,520 --> 00:18:53,919
are the same typical in and out that

542
00:18:53,919 --> 00:18:54,960
you'd expect from

543
00:18:54,960 --> 00:18:57,440
any authentication authenticated

544
00:18:57,440 --> 00:18:59,120
encryption algorithm

545
00:18:59,120 --> 00:19:03,200
the counter mode part the cm of gcm

546
00:19:03,200 --> 00:19:05,600
takes an aes block cipher and turns it

547
00:19:05,600 --> 00:19:07,039
into a stream cipher

548
00:19:07,039 --> 00:19:09,039
by repeatedly feeding the counter into

549
00:19:09,039 --> 00:19:10,480
that aes block

550
00:19:10,480 --> 00:19:13,919
this means that aes in the gcm mode

551
00:19:13,919 --> 00:19:16,320
creates a strung together series of

552
00:19:16,320 --> 00:19:17,600
blocks of bits

553
00:19:17,600 --> 00:19:19,679
and then turns into a bunch of one time

554
00:19:19,679 --> 00:19:23,440
pads each one aes block size long

555
00:19:23,440 --> 00:19:26,559
that then gets xored with the plain text

556
00:19:26,559 --> 00:19:30,559
and the aes function output

557
00:19:30,559 --> 00:19:32,559
and the xor the plain text is stored off

558
00:19:32,559 --> 00:19:34,720
as a stream of ciphertext

559
00:19:34,720 --> 00:19:36,799
but at the same time that is fed back

560
00:19:36,799 --> 00:19:38,799
into a multi

561
00:19:38,799 --> 00:19:41,840
sorry a multiplication function from the

562
00:19:41,840 --> 00:19:44,160
field and each ciphertext block is

563
00:19:44,160 --> 00:19:46,080
multiplied by the previous one

564
00:19:46,080 --> 00:19:49,280
to create a small size a small constant

565
00:19:49,280 --> 00:19:51,200
size value

566
00:19:51,200 --> 00:19:53,760
and then that final block is ultimately

567
00:19:53,760 --> 00:19:54,880
xored

568
00:19:54,880 --> 00:19:57,120
with a value that's created by

569
00:19:57,120 --> 00:19:59,120
encrypting the initialization vector

570
00:19:59,120 --> 00:20:02,400
and the key with the key this provides

571
00:20:02,400 --> 00:20:04,640
security for that final tag value

572
00:20:04,640 --> 00:20:06,159
because while anybody can multiply the

573
00:20:06,159 --> 00:20:08,159
ciphertext blocks together

574
00:20:08,159 --> 00:20:10,159
only the key holder can do this final

575
00:20:10,159 --> 00:20:11,200
operation

576
00:20:11,200 --> 00:20:14,240
to seal the tag

577
00:20:14,799 --> 00:20:17,120
remember the the provably secure xor

578
00:20:17,120 --> 00:20:18,159
encryption

579
00:20:18,159 --> 00:20:20,720
with that we can't reuse or loop or

580
00:20:20,720 --> 00:20:21,280
replay

581
00:20:21,280 --> 00:20:23,760
any part of the one-time pad because

582
00:20:23,760 --> 00:20:25,760
doing that can lead to a situation where

583
00:20:25,760 --> 00:20:26,159
you

584
00:20:26,159 --> 00:20:28,559
end up revealing the plain text in the

585
00:20:28,559 --> 00:20:29,360
same way

586
00:20:29,360 --> 00:20:32,080
gcm works by creating a pseudo-random

587
00:20:32,080 --> 00:20:33,120
pad

588
00:20:33,120 --> 00:20:34,960
same iv and the key used together will

589
00:20:34,960 --> 00:20:37,039
always create that same

590
00:20:37,039 --> 00:20:39,600
padding stream that's great news though

591
00:20:39,600 --> 00:20:40,799
because if you didn't you wouldn't be

592
00:20:40,799 --> 00:20:42,000
able to decrypt

593
00:20:42,000 --> 00:20:44,320
any of the encrypted data given the same

594
00:20:44,320 --> 00:20:45,520
key

595
00:20:45,520 --> 00:20:49,120
however because of this the randomness

596
00:20:49,120 --> 00:20:49,840
of this

597
00:20:49,840 --> 00:20:52,000
initialization vector is just important

598
00:20:52,000 --> 00:20:53,919
as the randomness in the key

599
00:20:53,919 --> 00:20:55,760
and it's imperative that it's only used

600
00:20:55,760 --> 00:20:57,520
once otherwise

601
00:20:57,520 --> 00:21:00,559
it's like reusing a one-time pad and

602
00:21:00,559 --> 00:21:02,320
it destroys the security properties of

603
00:21:02,320 --> 00:21:04,240
the encryption scheme

604
00:21:04,240 --> 00:21:05,919
and there were several recent

605
00:21:05,919 --> 00:21:07,840
vulnerabilities that i'll touch on later

606
00:21:07,840 --> 00:21:08,799
that

607
00:21:08,799 --> 00:21:11,600
have taken advantage of this one of the

608
00:21:11,600 --> 00:21:12,159
other

609
00:21:12,159 --> 00:21:14,159
modernly modern cipher systems that's in

610
00:21:14,159 --> 00:21:15,200
heavy use today

611
00:21:15,200 --> 00:21:19,120
is called cha-cha 20 with poly 1305

612
00:21:19,120 --> 00:21:21,200
it's a descendant of the previously

613
00:21:21,200 --> 00:21:22,720
mentioned salsa 20

614
00:21:22,720 --> 00:21:26,960
cipher cha-cha 20 is a stream cipher

615
00:21:26,960 --> 00:21:28,799
and it's used to create a long

616
00:21:28,799 --> 00:21:30,480
pseudo-random string of bits

617
00:21:30,480 --> 00:21:32,559
that by using a counter similar to the

618
00:21:32,559 --> 00:21:34,799
way that aes gcm

619
00:21:34,799 --> 00:21:38,480
works with it the authentication portion

620
00:21:38,480 --> 00:21:39,280
of this cipher

621
00:21:39,280 --> 00:21:43,120
the poly1305 it refers to the polynomial

622
00:21:43,120 --> 00:21:44,240
equation that's

623
00:21:44,240 --> 00:21:46,159
creates that's used in the creation of

624
00:21:46,159 --> 00:21:48,159
the authentication tag

625
00:21:48,159 --> 00:21:51,039
well 1305 comes from the special prime

626
00:21:51,039 --> 00:21:51,440
number

627
00:21:51,440 --> 00:21:54,559
2 to the 130 minus 5 and it's used in

628
00:21:54,559 --> 00:21:55,600
the upper bound

629
00:21:55,600 --> 00:21:58,640
that of the values that

630
00:21:58,640 --> 00:22:00,880
are done when performing the math using

631
00:22:00,880 --> 00:22:03,440
the tag polynomial

632
00:22:03,440 --> 00:22:05,280
and it just wraps around to the

633
00:22:05,280 --> 00:22:07,440
beginning so let's step through how

634
00:22:07,440 --> 00:22:10,480
cha-cha 20 works

635
00:22:11,280 --> 00:22:13,360
in combination with the poly1305

636
00:22:13,360 --> 00:22:16,159
accumulator that creates the tag

637
00:22:16,159 --> 00:22:17,840
i wanted to create this diagram because

638
00:22:17,840 --> 00:22:19,360
i couldn't find anything online that

639
00:22:19,360 --> 00:22:21,039
went through the entire process in a

640
00:22:21,039 --> 00:22:21,919
visual format

641
00:22:21,919 --> 00:22:25,840
at this level so the same way that asgcm

642
00:22:25,840 --> 00:22:26,880
starts

643
00:22:26,880 --> 00:22:30,400
you take the key the iv and the counter

644
00:22:30,400 --> 00:22:35,200
and feed it into the encryption function

645
00:22:35,200 --> 00:22:37,840
then as you continue you wrap around the

646
00:22:37,840 --> 00:22:39,360
counter start adding one to it

647
00:22:39,360 --> 00:22:41,280
using the same key and initialization

648
00:22:41,280 --> 00:22:43,039
vector to create an

649
00:22:43,039 --> 00:22:46,000
output stream that's the same size as

650
00:22:46,000 --> 00:22:47,440
whatever plain text you're trying to

651
00:22:47,440 --> 00:22:49,360
encrypt

652
00:22:49,360 --> 00:22:51,280
that gets xored with the plain text and

653
00:22:51,280 --> 00:22:54,080
becomes your ciphertext

654
00:22:54,080 --> 00:22:57,280
after that you take the ciphertext

655
00:22:57,280 --> 00:22:59,840
and the associated data and you put

656
00:22:59,840 --> 00:23:01,280
those two together with some

657
00:23:01,280 --> 00:23:03,120
padding and the length of those two

658
00:23:03,120 --> 00:23:04,640
things

659
00:23:04,640 --> 00:23:08,320
and make a another buffer to

660
00:23:08,320 --> 00:23:11,840
push into the poly1305 algorithm

661
00:23:11,840 --> 00:23:13,760
now this is different from gcm because

662
00:23:13,760 --> 00:23:15,840
it actually uses a key

663
00:23:15,840 --> 00:23:19,919
to go into that poly1305

664
00:23:19,919 --> 00:23:21,840
so you do this you run through that in

665
00:23:21,840 --> 00:23:23,039
full encryption buffer

666
00:23:23,039 --> 00:23:25,120
through the tag generation method and

667
00:23:25,120 --> 00:23:26,320
then that outputs

668
00:23:26,320 --> 00:23:31,360
the final tag value for cha cha 20.

669
00:23:31,360 --> 00:23:34,240
this 1305 prime that's used for the tag

670
00:23:34,240 --> 00:23:34,960
generation

671
00:23:34,960 --> 00:23:37,120
it was chosen because it gives the

672
00:23:37,120 --> 00:23:38,400
ability to

673
00:23:38,400 --> 00:23:40,880
add optimizations in the way that the

674
00:23:40,880 --> 00:23:42,640
message is broken up

675
00:23:42,640 --> 00:23:44,960
to perform all the various cryptographic

676
00:23:44,960 --> 00:23:46,320
operations

677
00:23:46,320 --> 00:23:48,159
in fact almost all of the internal

678
00:23:48,159 --> 00:23:50,080
design of poly1305

679
00:23:50,080 --> 00:23:51,760
lends itself to a very fast

680
00:23:51,760 --> 00:23:53,200
implementation

681
00:23:53,200 --> 00:23:56,320
and this is an important consideration

682
00:23:56,320 --> 00:23:57,840
if adding in authentication to

683
00:23:57,840 --> 00:23:59,360
encryption created a really large

684
00:23:59,360 --> 00:24:00,000
overhead

685
00:24:00,000 --> 00:24:03,120
and calculations or in size

686
00:24:03,120 --> 00:24:05,679
nobody would want to adopt it and its

687
00:24:05,679 --> 00:24:06,480
use would be

688
00:24:06,480 --> 00:24:09,440
relegated to obscurity and that brings

689
00:24:09,440 --> 00:24:10,640
us to one of the

690
00:24:10,640 --> 00:24:12,960
important considerations for choosing an

691
00:24:12,960 --> 00:24:15,360
authenticated encryption scheme

692
00:24:15,360 --> 00:24:18,720
speed aes has been around since the year

693
00:24:18,720 --> 00:24:19,840
2000

694
00:24:19,840 --> 00:24:21,520
and it means over the last 20 years

695
00:24:21,520 --> 00:24:23,679
cryptographers programmers

696
00:24:23,679 --> 00:24:25,679
processor chip designers they've all

697
00:24:25,679 --> 00:24:28,159
been diligently working to ensure that

698
00:24:28,159 --> 00:24:30,159
the overhead of performing encryption

699
00:24:30,159 --> 00:24:31,440
with aes

700
00:24:31,440 --> 00:24:34,320
isn't a significant detractor to its use

701
00:24:34,320 --> 00:24:36,000
and adoption

702
00:24:36,000 --> 00:24:37,520
chip designers have started including

703
00:24:37,520 --> 00:24:39,200
special registers and

704
00:24:39,200 --> 00:24:41,360
specific instruction sets in the micro

705
00:24:41,360 --> 00:24:43,360
code of their processors

706
00:24:43,360 --> 00:24:45,200
that allow for very very fast

707
00:24:45,200 --> 00:24:46,880
performance of the different operations

708
00:24:46,880 --> 00:24:49,360
inside of aes

709
00:24:49,360 --> 00:24:51,919
and this makes aes faster than chacha 20

710
00:24:51,919 --> 00:24:52,880
by

711
00:24:52,880 --> 00:24:55,760
a fairly good margin at least on

712
00:24:55,760 --> 00:24:56,799
computers

713
00:24:56,799 --> 00:24:59,840
they use that particular chip without it

714
00:24:59,840 --> 00:25:00,640
however

715
00:25:00,640 --> 00:25:03,760
chacha 20 is actually superior it was

716
00:25:03,760 --> 00:25:05,360
designed to be especially fast in

717
00:25:05,360 --> 00:25:07,200
software implementations without

718
00:25:07,200 --> 00:25:09,600
requiring any special hardware tricks

719
00:25:09,600 --> 00:25:11,919
so phones and tablets and even some of

720
00:25:11,919 --> 00:25:13,520
the new laptops

721
00:25:13,520 --> 00:25:15,840
are able to encrypt using chat show 20

722
00:25:15,840 --> 00:25:17,600
much faster than they could do

723
00:25:17,600 --> 00:25:21,120
encryption with aes even still

724
00:25:21,120 --> 00:25:23,120
that didn't stop processor implementers

725
00:25:23,120 --> 00:25:24,159
from trying

726
00:25:24,159 --> 00:25:27,520
and in 2018 they introduced some new

727
00:25:27,520 --> 00:25:28,000
instruction

728
00:25:28,000 --> 00:25:30,559
sets on cpus that could actually boost

729
00:25:30,559 --> 00:25:32,159
cha cha 20's implementation

730
00:25:32,159 --> 00:25:35,440
speed over the aes

731
00:25:35,440 --> 00:25:39,279
on a chip in some certain circumstances

732
00:25:39,279 --> 00:25:42,159
cha cha 20 was designed to defeat the

733
00:25:42,159 --> 00:25:43,919
problematic side channels that plague

734
00:25:43,919 --> 00:25:44,480
aes

735
00:25:44,480 --> 00:25:47,520
implementations because of the way aes

736
00:25:47,520 --> 00:25:48,640
it was designed

737
00:25:48,640 --> 00:25:52,240
implementers had added in optimizations

738
00:25:52,240 --> 00:25:54,480
but that could lead to issues when these

739
00:25:54,480 --> 00:25:55,679
timing issues happen

740
00:25:55,679 --> 00:25:57,600
if an attacker is there looking closely

741
00:25:57,600 --> 00:25:59,679
at how long the operation performed

742
00:25:59,679 --> 00:26:01,520
it can actually lead them to be able to

743
00:26:01,520 --> 00:26:04,000
define the key

744
00:26:04,000 --> 00:26:06,559
completely destroying the security of

745
00:26:06,559 --> 00:26:08,000
the protocol

746
00:26:08,000 --> 00:26:10,880
but because of cha cha 20's design all

747
00:26:10,880 --> 00:26:13,120
the operations happen in constant time

748
00:26:13,120 --> 00:26:13,440
and

749
00:26:13,440 --> 00:26:15,440
there isn't an opportunity for any

750
00:26:15,440 --> 00:26:18,799
timing attacks with the encryption

751
00:26:18,799 --> 00:26:21,679
so since i managed to sneak this in the

752
00:26:21,679 --> 00:26:24,159
weeds talk into a in the cloud slot

753
00:26:24,159 --> 00:26:25,440
i figured i should probably talk a

754
00:26:25,440 --> 00:26:27,440
little bit about how this fits into the

755
00:26:27,440 --> 00:26:28,320
cloud

756
00:26:28,320 --> 00:26:30,159
so we can go through some of the the

757
00:26:30,159 --> 00:26:32,400
three big players in the cloud

758
00:26:32,400 --> 00:26:34,799
besides the transport layer encryption

759
00:26:34,799 --> 00:26:36,080
there's two different use

760
00:26:36,080 --> 00:26:37,520
main use cases for encryption in the

761
00:26:37,520 --> 00:26:39,120
cloud first there's

762
00:26:39,120 --> 00:26:42,240
data at rest and secondly i'll call

763
00:26:42,240 --> 00:26:44,559
encrypting application data i'll

764
00:26:44,559 --> 00:26:46,640
differentiate between these two by

765
00:26:46,640 --> 00:26:48,320
saying data at rest is anything that's

766
00:26:48,320 --> 00:26:51,919
done automatically by the cloud provider

767
00:26:51,919 --> 00:26:53,919
for all of one specific type or

768
00:26:53,919 --> 00:26:55,440
even all of the data that's stored by

769
00:26:55,440 --> 00:26:57,760
the cloud provider and then application

770
00:26:57,760 --> 00:26:59,039
data on the other hand

771
00:26:59,039 --> 00:27:01,120
is where the cloud provider provides a

772
00:27:01,120 --> 00:27:02,159
specific

773
00:27:02,159 --> 00:27:04,240
interface for applications that are

774
00:27:04,240 --> 00:27:06,880
running on the services to use keys to

775
00:27:06,880 --> 00:27:07,919
encrypt data

776
00:27:07,919 --> 00:27:11,840
within their actual application code

777
00:27:11,840 --> 00:27:16,000
so with data at rest in aws

778
00:27:16,000 --> 00:27:18,000
it allows administrators to set up

779
00:27:18,000 --> 00:27:20,000
encryption for their stored data

780
00:27:20,000 --> 00:27:23,360
using aes gcm which provides a nice

781
00:27:23,360 --> 00:27:25,120
authenticated option for them to use to

782
00:27:25,120 --> 00:27:26,960
protect all their data

783
00:27:26,960 --> 00:27:29,840
gcp uses the same by implementing aes

784
00:27:29,840 --> 00:27:31,679
gcm to protect data at rest in their

785
00:27:31,679 --> 00:27:33,279
environment

786
00:27:33,279 --> 00:27:36,159
some added bonus material here whenever

787
00:27:36,159 --> 00:27:38,559
google sends data across their networks

788
00:27:38,559 --> 00:27:41,600
they take that data instead of using tls

789
00:27:41,600 --> 00:27:45,039
like other places they have a special

790
00:27:45,039 --> 00:27:46,799
optimized protocol that's specific to

791
00:27:46,799 --> 00:27:48,559
their environment called alts

792
00:27:48,559 --> 00:27:51,840
or alts it allows them to transfer data

793
00:27:51,840 --> 00:27:53,840
using either aes gcm

794
00:27:53,840 --> 00:27:56,000
or a different algorithm they made

795
00:27:56,000 --> 00:27:57,039
called aes

796
00:27:57,039 --> 00:28:00,399
vcm which uses a special authenticated

797
00:28:00,399 --> 00:28:01,120
method

798
00:28:01,120 --> 00:28:03,200
authentication method that's based on

799
00:28:03,200 --> 00:28:05,279
integer arithmetic

800
00:28:05,279 --> 00:28:07,279
and it's designed to be especially fast

801
00:28:07,279 --> 00:28:10,880
on google's 64-bit processors

802
00:28:10,880 --> 00:28:14,320
microsoft azure on the other hand

803
00:28:14,640 --> 00:28:18,000
it does use aes for data arrest storage

804
00:28:18,000 --> 00:28:19,279
but disappointingly

805
00:28:19,279 --> 00:28:22,480
only uses the chaining block cipher mode

806
00:28:22,480 --> 00:28:25,600
and they cite the reason for this

807
00:28:25,600 --> 00:28:28,840
as making the retrieval of the storage

808
00:28:28,840 --> 00:28:30,799
faster

809
00:28:30,799 --> 00:28:32,960
on the application side every cloud

810
00:28:32,960 --> 00:28:33,840
provider here

811
00:28:33,840 --> 00:28:37,120
has the has an api that lets application

812
00:28:37,120 --> 00:28:38,720
teams

813
00:28:38,720 --> 00:28:40,720
to facilitate the encryption on specific

814
00:28:40,720 --> 00:28:42,159
pieces of data

815
00:28:42,159 --> 00:28:43,520
from their code that's running in the

816
00:28:43,520 --> 00:28:45,279
cloud

817
00:28:45,279 --> 00:28:47,760
with aws application data similar to

818
00:28:47,760 --> 00:28:48,799
their data at rest

819
00:28:48,799 --> 00:28:53,039
can be encrypted using aes gcm

820
00:28:53,039 --> 00:28:56,080
the interface here allows for providing

821
00:28:56,080 --> 00:28:58,320
additional associated data that extra

822
00:28:58,320 --> 00:29:00,159
non-encrypted data we talked about

823
00:29:00,159 --> 00:29:03,600
as well as an initialization vector

824
00:29:03,600 --> 00:29:05,600
but it's up to the developer to make

825
00:29:05,600 --> 00:29:07,440
sure that that's never reused

826
00:29:07,440 --> 00:29:10,480
and is always completely random in

827
00:29:10,480 --> 00:29:12,000
google's cloud

828
00:29:12,000 --> 00:29:13,600
applications are given the ability to do

829
00:29:13,600 --> 00:29:16,000
something called envelope encryption

830
00:29:16,000 --> 00:29:19,039
this encryption api allows developers to

831
00:29:19,039 --> 00:29:21,360
simply encrypt data by just passing a

832
00:29:21,360 --> 00:29:22,159
byte array

833
00:29:22,159 --> 00:29:24,720
and a key name under the covers it uses

834
00:29:24,720 --> 00:29:25,520
gcm

835
00:29:25,520 --> 00:29:27,600
and a key management scheme designed by

836
00:29:27,600 --> 00:29:28,960
google that

837
00:29:28,960 --> 00:29:32,399
uses a key encrypting key to protect the

838
00:29:32,399 --> 00:29:32,960
key

839
00:29:32,960 --> 00:29:35,600
that does the actual data encryption the

840
00:29:35,600 --> 00:29:36,720
data encryption key

841
00:29:36,720 --> 00:29:38,720
and the initialization vector used are

842
00:29:38,720 --> 00:29:40,799
randomly generated on the fly

843
00:29:40,799 --> 00:29:44,320
anytime new data needs to be written

844
00:29:44,320 --> 00:29:47,120
azure on the other hand doesn't provide

845
00:29:47,120 --> 00:29:49,679
an api for symmetric encryption of data

846
00:29:49,679 --> 00:29:52,399
at all it does provide an api that

847
00:29:52,399 --> 00:29:54,000
allows applications to create

848
00:29:54,000 --> 00:29:57,120
their own securely stored keys and then

849
00:29:57,120 --> 00:29:58,720
use them inside their application to

850
00:29:58,720 --> 00:29:59,760
encrypt data

851
00:29:59,760 --> 00:30:01,600
using any encryption methods supported

852
00:30:01,600 --> 00:30:04,559
by the programming language in use

853
00:30:04,559 --> 00:30:05,679
of course the examples in their

854
00:30:05,679 --> 00:30:07,600
documentation use the chaining block

855
00:30:07,600 --> 00:30:10,240
cipher mode

856
00:30:11,520 --> 00:30:14,000
but how does this protect you see the

857
00:30:14,000 --> 00:30:14,640
problem with

858
00:30:14,640 --> 00:30:16,880
encrypting data in the cloud is most

859
00:30:16,880 --> 00:30:18,399
people don't understand the threat model

860
00:30:18,399 --> 00:30:20,399
that it protects against

861
00:30:20,399 --> 00:30:22,399
cloud encryption doesn't protect against

862
00:30:22,399 --> 00:30:24,159
the cloud provider seeing your plaintext

863
00:30:24,159 --> 00:30:25,120
data

864
00:30:25,120 --> 00:30:26,720
they have to be able to decrypt the data

865
00:30:26,720 --> 00:30:29,200
so that they can store it sort it

866
00:30:29,200 --> 00:30:32,320
index it provide it back to you it also

867
00:30:32,320 --> 00:30:33,520
doesn't protect against

868
00:30:33,520 --> 00:30:35,279
operators setting permissions

869
00:30:35,279 --> 00:30:37,200
incorrectly on the data in the key

870
00:30:37,200 --> 00:30:39,200
where anybody could get access to it

871
00:30:39,200 --> 00:30:41,360
through a regular web interface or an

872
00:30:41,360 --> 00:30:42,799
application

873
00:30:42,799 --> 00:30:44,799
this happened at capital one about a

874
00:30:44,799 --> 00:30:45,840
year ago

875
00:30:45,840 --> 00:30:48,559
they had 140 000 social security numbers

876
00:30:48,559 --> 00:30:49,039
and

877
00:30:49,039 --> 00:30:52,960
80 000 bank account numbers accessed by

878
00:30:52,960 --> 00:30:55,600
an attacker even though they were all

879
00:30:55,600 --> 00:30:57,039
encrypted

880
00:30:57,039 --> 00:31:00,640
in the cloud the reason was because the

881
00:31:00,640 --> 00:31:01,600
access rights

882
00:31:01,600 --> 00:31:03,279
were set on the data interface allowed

883
00:31:03,279 --> 00:31:05,039
anybody hitting the cloud service to

884
00:31:05,039 --> 00:31:06,559
tell the provider and go get the keys

885
00:31:06,559 --> 00:31:07,840
and decrypt the data

886
00:31:07,840 --> 00:31:10,880
and then send it to them so what does

887
00:31:10,880 --> 00:31:11,600
cloud protect

888
00:31:11,600 --> 00:31:14,240
cloud encryption even protect against it

889
00:31:14,240 --> 00:31:15,279
prevents somebody with

890
00:31:15,279 --> 00:31:16,799
physical access to the hard drives from

891
00:31:16,799 --> 00:31:19,279
getting access to the raw data

892
00:31:19,279 --> 00:31:22,159
you could achieve this access by

893
00:31:22,159 --> 00:31:22,799
breaking in

894
00:31:22,799 --> 00:31:25,679
and yanking drives out finding unreached

895
00:31:25,679 --> 00:31:27,120
drives in the trash

896
00:31:27,120 --> 00:31:30,240
however unlikely that would be or by an

897
00:31:30,240 --> 00:31:32,240
insider working in the data center with

898
00:31:32,240 --> 00:31:35,440
access to the physical drives

899
00:31:35,440 --> 00:31:37,760
another way to use the cloud keying

900
00:31:37,760 --> 00:31:39,360
mechanisms to protect your data

901
00:31:39,360 --> 00:31:41,519
it depends on the particular way that

902
00:31:41,519 --> 00:31:43,360
the crypto systems in the cloud are set

903
00:31:43,360 --> 00:31:44,159
up

904
00:31:44,159 --> 00:31:45,840
cloud administrators can do something

905
00:31:45,840 --> 00:31:47,760
called bring your own key or

906
00:31:47,760 --> 00:31:51,039
byok this allows the admin to

907
00:31:51,039 --> 00:31:53,200
provide a key to the cloud from their

908
00:31:53,200 --> 00:31:54,640
local site

909
00:31:54,640 --> 00:31:56,559
you'd want to do this if you are worried

910
00:31:56,559 --> 00:31:58,240
about the key persisting in the cloud

911
00:31:58,240 --> 00:32:00,720
after you didn't want it to

912
00:32:00,720 --> 00:32:02,799
and trusted the cloud provider to delete

913
00:32:02,799 --> 00:32:03,760
copies of the key

914
00:32:03,760 --> 00:32:06,399
when asked in cloud consultants pitch

915
00:32:06,399 --> 00:32:08,480
this is a way to quickly remove the

916
00:32:08,480 --> 00:32:10,960
provider's access to a given key or set

917
00:32:10,960 --> 00:32:11,919
of keys

918
00:32:11,919 --> 00:32:14,480
that renders the data unreadable you'd

919
00:32:14,480 --> 00:32:15,279
want to do this

920
00:32:15,279 --> 00:32:17,279
after terminating a cloud agreement to

921
00:32:17,279 --> 00:32:18,480
make sure that they couldn't get to the

922
00:32:18,480 --> 00:32:19,679
data anymore

923
00:32:19,679 --> 00:32:22,159
or to quickly destroy the ability to

924
00:32:22,159 --> 00:32:25,279
decrypt the data for whatever reason

925
00:32:25,279 --> 00:32:27,440
a similar concept is called key caching

926
00:32:27,440 --> 00:32:28,720
it's one step

927
00:32:28,720 --> 00:32:30,880
removed from that and that's where every

928
00:32:30,880 --> 00:32:31,840
few minutes or

929
00:32:31,840 --> 00:32:34,399
hours the cloud provider makes a call

930
00:32:34,399 --> 00:32:35,200
back to the

931
00:32:35,200 --> 00:32:37,600
local company's key server to request

932
00:32:37,600 --> 00:32:38,240
the key

933
00:32:38,240 --> 00:32:39,679
in order to perform cryptographic

934
00:32:39,679 --> 00:32:42,399
operations on the data

935
00:32:42,399 --> 00:32:44,320
in an example not too far outside the

936
00:32:44,320 --> 00:32:45,679
realm of plausibility

937
00:32:45,679 --> 00:32:47,760
given their access to the keys a cloud

938
00:32:47,760 --> 00:32:49,360
provider could turn out

939
00:32:49,360 --> 00:32:52,080
turnover data without your knowing or

940
00:32:52,080 --> 00:32:53,120
intervention

941
00:32:53,120 --> 00:32:55,919
when faced with a court subpoena however

942
00:32:55,919 --> 00:32:56,480
if you

943
00:32:56,480 --> 00:32:58,000
knew that the request for the data was

944
00:32:58,000 --> 00:32:59,919
imminent and wanted to retain the

945
00:32:59,919 --> 00:33:01,600
ability to fight the subpoena

946
00:33:01,600 --> 00:33:03,120
to prevent the court from gaining access

947
00:33:03,120 --> 00:33:05,120
to it you could revoke the cloud

948
00:33:05,120 --> 00:33:07,120
providers access to the keys

949
00:33:07,120 --> 00:33:09,440
and with it prevent their ability to

950
00:33:09,440 --> 00:33:10,159
provide

951
00:33:10,159 --> 00:33:13,039
meaningful data another example where

952
00:33:13,039 --> 00:33:14,240
companies could use this cloud

953
00:33:14,240 --> 00:33:15,519
encryption is to

954
00:33:15,519 --> 00:33:18,880
help protect data using a more complex

955
00:33:18,880 --> 00:33:21,440
data access configuration you allow

956
00:33:21,440 --> 00:33:22,240
specific

957
00:33:22,240 --> 00:33:24,960
users access to the stored encrypted

958
00:33:24,960 --> 00:33:25,679
data

959
00:33:25,679 --> 00:33:27,679
where they could see things like the

960
00:33:27,679 --> 00:33:29,120
location of the data and

961
00:33:29,120 --> 00:33:32,000
possibly plain text information about

962
00:33:32,000 --> 00:33:34,799
what the encrypted data is associated to

963
00:33:34,799 --> 00:33:37,360
but then give the group access another

964
00:33:37,360 --> 00:33:38,080
group access

965
00:33:38,080 --> 00:33:41,279
to the data as well as the ability

966
00:33:41,279 --> 00:33:43,919
to decrypt it an example of this would

967
00:33:43,919 --> 00:33:45,200
be

968
00:33:45,200 --> 00:33:48,799
if a select group of people like doctors

969
00:33:48,799 --> 00:33:50,960
that needed to see images containing

970
00:33:50,960 --> 00:33:52,080
sensitive information

971
00:33:52,080 --> 00:33:54,320
like dental scans and there were other

972
00:33:54,320 --> 00:33:55,120
users like

973
00:33:55,120 --> 00:33:57,039
office staff that needed to have the

974
00:33:57,039 --> 00:33:58,960
ability to see information about people

975
00:33:58,960 --> 00:34:00,880
that have had dental scans

976
00:34:00,880 --> 00:34:03,279
but don't need to see the actual images

977
00:34:03,279 --> 00:34:05,200
as long as the access rights to the keys

978
00:34:05,200 --> 00:34:06,720
are managed correctly

979
00:34:06,720 --> 00:34:11,040
the data remains secure and protected

980
00:34:11,040 --> 00:34:12,800
now everything we've talked about so far

981
00:34:12,800 --> 00:34:14,879
has been in place for

982
00:34:14,879 --> 00:34:18,800
the last five years or so but of course

983
00:34:18,800 --> 00:34:20,639
there's still some not using all of

984
00:34:20,639 --> 00:34:22,719
those best practices

985
00:34:22,719 --> 00:34:25,839
others are finding ways to work on

986
00:34:25,839 --> 00:34:28,800
the next best thing for encryption and

987
00:34:28,800 --> 00:34:29,280
bringing

988
00:34:29,280 --> 00:34:31,918
that into modern libraries incorporating

989
00:34:31,918 --> 00:34:36,239
it into systems utilizing cryptography

990
00:34:36,239 --> 00:34:37,918
one of the things that you might have

991
00:34:37,918 --> 00:34:39,359
noticed is that

992
00:34:39,359 --> 00:34:43,119
aes gcm is extremely popular

993
00:34:43,119 --> 00:34:45,839
it's used all over browsers in the

994
00:34:45,839 --> 00:34:46,719
clouds

995
00:34:46,719 --> 00:34:49,040
applications protecting important data

996
00:34:49,040 --> 00:34:50,800
for all types of uses

997
00:34:50,800 --> 00:34:54,000
for all types of people one of the

998
00:34:54,000 --> 00:34:55,839
problems with aes

999
00:34:55,839 --> 00:34:59,040
is that not everybody with asgcm is not

1000
00:34:59,040 --> 00:35:00,960
everybody gets it right

1001
00:35:00,960 --> 00:35:02,960
very similar to the way that people see

1002
00:35:02,960 --> 00:35:05,599
aes and just jump on using it blindly

1003
00:35:05,599 --> 00:35:08,880
in electronic codebook mode

1004
00:35:08,880 --> 00:35:12,320
gcm allows implementers to easily and

1005
00:35:12,320 --> 00:35:14,000
hopefully accidentally shoot themselves

1006
00:35:14,000 --> 00:35:15,760
in the foot

1007
00:35:15,760 --> 00:35:17,440
if the same initialization vector is

1008
00:35:17,440 --> 00:35:19,040
used with the same key

1009
00:35:19,040 --> 00:35:21,040
but over different data you end up in a

1010
00:35:21,040 --> 00:35:22,400
situation where that data can be

1011
00:35:22,400 --> 00:35:23,760
decrypted

1012
00:35:23,760 --> 00:35:26,640
even without knowing the key there are

1013
00:35:26,640 --> 00:35:27,200
newer

1014
00:35:27,200 --> 00:35:29,280
encryption constructs that haven't quite

1015
00:35:29,280 --> 00:35:30,640
made it into the mainstream product

1016
00:35:30,640 --> 00:35:31,920
lines yet

1017
00:35:31,920 --> 00:35:33,520
but they've been designed to help

1018
00:35:33,520 --> 00:35:36,079
protect against this foot gun

1019
00:35:36,079 --> 00:35:38,560
by changing the algorithm to where using

1020
00:35:38,560 --> 00:35:40,400
the same initialization vector with the

1021
00:35:40,400 --> 00:35:41,200
same key

1022
00:35:41,200 --> 00:35:44,079
multiple times over different data

1023
00:35:44,079 --> 00:35:45,680
doesn't affect the security properties

1024
00:35:45,680 --> 00:35:48,160
of the encryption scheme as a whole

1025
00:35:48,160 --> 00:35:52,079
one of these methods is called aes siv

1026
00:35:52,079 --> 00:35:54,079
and rather than taking an initialization

1027
00:35:54,079 --> 00:35:55,119
vector as input

1028
00:35:55,119 --> 00:35:57,280
into the algorithm it takes the

1029
00:35:57,280 --> 00:35:58,400
plaintext data

1030
00:35:58,400 --> 00:36:01,200
and hashes it and then that resultant

1031
00:36:01,200 --> 00:36:02,079
hash is fed

1032
00:36:02,079 --> 00:36:06,240
into a block cipher or a like aes

1033
00:36:06,240 --> 00:36:09,680
as an initialization vector and

1034
00:36:09,680 --> 00:36:13,359
like gcm a counter mode here is used

1035
00:36:13,359 --> 00:36:17,520
for each new aes block that's created to

1036
00:36:17,520 --> 00:36:20,240
deliver that pseudo random string that

1037
00:36:20,240 --> 00:36:22,400
eventually gets xored with the plain

1038
00:36:22,400 --> 00:36:24,720
text

1039
00:36:24,880 --> 00:36:28,720
the caesar competition began in 2014

1040
00:36:28,720 --> 00:36:31,280
and it wrapped up last year it was

1041
00:36:31,280 --> 00:36:32,400
designed to

1042
00:36:32,400 --> 00:36:36,320
find a replacement for aes gcm

1043
00:36:36,320 --> 00:36:39,119
that was both robust and suitable for

1044
00:36:39,119 --> 00:36:40,960
mass adoption

1045
00:36:40,960 --> 00:36:42,560
there were several categories of

1046
00:36:42,560 --> 00:36:44,320
requirements as you can see here

1047
00:36:44,320 --> 00:36:45,760
and different algorithms were

1048
00:36:45,760 --> 00:36:48,480
recommended based on the needs

1049
00:36:48,480 --> 00:36:52,160
of the encrypter and

1050
00:36:52,160 --> 00:36:54,000
there's lots of different algorithm

1051
00:36:54,000 --> 00:36:57,280
names that probably haven't made it into

1052
00:36:57,280 --> 00:37:00,640
anybody's lexicon quite yet

1053
00:37:00,640 --> 00:37:02,960
but each of these categories here it was

1054
00:37:02,960 --> 00:37:04,880
either a

1055
00:37:04,880 --> 00:37:08,000
equal choice to use both of them just

1056
00:37:08,000 --> 00:37:09,680
depending on which one you liked or

1057
00:37:09,680 --> 00:37:11,280
which one happened to get implemented

1058
00:37:11,280 --> 00:37:13,520
the best within the software

1059
00:37:13,520 --> 00:37:16,720
or it was a preferential ordering

1060
00:37:16,720 --> 00:37:19,920
so use this one first or

1061
00:37:19,920 --> 00:37:22,000
and if problems are found in that later

1062
00:37:22,000 --> 00:37:24,720
we can switch this other one

1063
00:37:24,720 --> 00:37:27,760
one thing that's an ongoing process is

1064
00:37:27,760 --> 00:37:29,200
something that's designed to help

1065
00:37:29,200 --> 00:37:31,280
processors with

1066
00:37:31,280 --> 00:37:33,599
in smaller devices or constrained

1067
00:37:33,599 --> 00:37:34,880
environments

1068
00:37:34,880 --> 00:37:37,040
to look at the algorithms that are used

1069
00:37:37,040 --> 00:37:38,640
and then change the

1070
00:37:38,640 --> 00:37:42,480
insides to make sure that they're

1071
00:37:42,480 --> 00:37:44,960
they take as little time and as few

1072
00:37:44,960 --> 00:37:45,839
resources

1073
00:37:45,839 --> 00:37:48,800
as possible this search for the

1074
00:37:48,800 --> 00:37:50,640
algorithm this new type of algorithm

1075
00:37:50,640 --> 00:37:53,280
is headed up by nist or the national

1076
00:37:53,280 --> 00:37:55,920
institute of standards and technology

1077
00:37:55,920 --> 00:37:58,480
and it's currently ongoing and expected

1078
00:37:58,480 --> 00:38:00,079
to complete over

1079
00:38:00,079 --> 00:38:02,880
the next few years or so it's been

1080
00:38:02,880 --> 00:38:05,119
delayed a little bit

1081
00:38:05,119 --> 00:38:08,720
due to the current pandemic

1082
00:38:08,720 --> 00:38:11,839
the round three release of submissions

1083
00:38:11,839 --> 00:38:14,320
is currently scheduled to come out in

1084
00:38:14,320 --> 00:38:16,800
december

1085
00:38:16,800 --> 00:38:19,280
homomorphic encryption is another

1086
00:38:19,280 --> 00:38:20,800
encryption type

1087
00:38:20,800 --> 00:38:23,440
and it gives the ability to perform

1088
00:38:23,440 --> 00:38:24,240
tasks

1089
00:38:24,240 --> 00:38:28,640
or calculations over encrypted data

1090
00:38:28,640 --> 00:38:30,560
technically it's not new it's been

1091
00:38:30,560 --> 00:38:32,480
around since the 70s

1092
00:38:32,480 --> 00:38:34,079
it just hasn't seen much use until

1093
00:38:34,079 --> 00:38:35,599
recently

1094
00:38:35,599 --> 00:38:38,079
and with good reason because there's one

1095
00:38:38,079 --> 00:38:39,359
little problem with homomorphic

1096
00:38:39,359 --> 00:38:40,640
encryption

1097
00:38:40,640 --> 00:38:43,280
it's very very processing intensive and

1098
00:38:43,280 --> 00:38:45,359
can end up taking a long time to

1099
00:38:45,359 --> 00:38:46,000
complete

1100
00:38:46,000 --> 00:38:48,560
any operation in there and there are

1101
00:38:48,560 --> 00:38:50,640
several research institutions or

1102
00:38:50,640 --> 00:38:53,280
in companies that have products and

1103
00:38:53,280 --> 00:38:53,839
tools

1104
00:38:53,839 --> 00:38:57,359
that support homomorphic encryption ibm

1105
00:38:57,359 --> 00:38:59,839
recently released i think last week one

1106
00:38:59,839 --> 00:39:00,560
that works

1107
00:39:00,560 --> 00:39:03,920
on both mac os and ios and

1108
00:39:03,920 --> 00:39:05,599
they're going to be pulling out support

1109
00:39:05,599 --> 00:39:07,200
for linux and

1110
00:39:07,200 --> 00:39:10,399
android coming soon

1111
00:39:10,960 --> 00:39:14,000
last but not least is the

1112
00:39:14,000 --> 00:39:16,160
reaction to the threat of quantum

1113
00:39:16,160 --> 00:39:17,760
computing

1114
00:39:17,760 --> 00:39:22,079
and so quantum computing

1115
00:39:22,079 --> 00:39:23,760
by building these different types of

1116
00:39:23,760 --> 00:39:25,359
computers

1117
00:39:25,359 --> 00:39:28,240
it can affect both symmetric algorithms

1118
00:39:28,240 --> 00:39:29,280
and

1119
00:39:29,280 --> 00:39:31,040
the asymmetric algorithms that are used

1120
00:39:31,040 --> 00:39:33,040
in things like certificates and

1121
00:39:33,040 --> 00:39:36,960
within tls and those asymmetric

1122
00:39:36,960 --> 00:39:37,760
algorithms

1123
00:39:37,760 --> 00:39:39,920
are hit a lot harder by quantum

1124
00:39:39,920 --> 00:39:40,960
computing

1125
00:39:40,960 --> 00:39:43,680
so most of the focus has been on finding

1126
00:39:43,680 --> 00:39:45,359
something to replace

1127
00:39:45,359 --> 00:39:48,160
any encryption needs for new signing

1128
00:39:48,160 --> 00:39:49,680
algorithms

1129
00:39:49,680 --> 00:39:52,320
so new types of certificates new types

1130
00:39:52,320 --> 00:39:54,960
of code signing things like that

1131
00:39:54,960 --> 00:39:57,520
but there's another algorithm within

1132
00:39:57,520 --> 00:39:58,480
that was developed

1133
00:39:58,480 --> 00:40:01,280
i think back in the 80s that also

1134
00:40:01,280 --> 00:40:01,920
affects

1135
00:40:01,920 --> 00:40:03,599
symmetric cryptography like we've been

1136
00:40:03,599 --> 00:40:05,839
talking about today

1137
00:40:05,839 --> 00:40:09,200
luckily the this bit's easy all you have

1138
00:40:09,200 --> 00:40:11,119
to do to prevent the problem is

1139
00:40:11,119 --> 00:40:13,359
double the encryption security level in

1140
00:40:13,359 --> 00:40:15,359
other words take the minimum key size

1141
00:40:15,359 --> 00:40:16,400
you have

1142
00:40:16,400 --> 00:40:19,040
set for any of the symmetric algorithms

1143
00:40:19,040 --> 00:40:21,200
and just move it up from 128 to

1144
00:40:21,200 --> 00:40:25,680
256 and now your decryption of the data

1145
00:40:25,680 --> 00:40:27,920
is safe and protected from the the

1146
00:40:27,920 --> 00:40:31,440
threats of quantum computers

1147
00:40:31,680 --> 00:40:34,000
so that brings me to the end of my talk

1148
00:40:34,000 --> 00:40:35,520
i really hope that you've learned some

1149
00:40:35,520 --> 00:40:37,520
new things about symmetric encryption

1150
00:40:37,520 --> 00:40:38,000
and

1151
00:40:38,000 --> 00:40:40,160
that your brain has been stretched a

1152
00:40:40,160 --> 00:40:41,200
little bit

1153
00:40:41,200 --> 00:40:44,240
or a lot and that you have some

1154
00:40:44,240 --> 00:40:52,160
questions that i can help answer

1155
00:40:52,160 --> 00:40:55,359
we encourage the uh participants to

1156
00:40:55,359 --> 00:40:57,200
uh provide their questions on our

1157
00:40:57,200 --> 00:40:58,800
discord channel under

1158
00:40:58,800 --> 00:41:03,599
the uh track two uh

1159
00:41:04,000 --> 00:41:07,119
in the clouds yeah so one of the

1160
00:41:07,119 --> 00:41:09,200
questions is why does doubling the key

1161
00:41:09,200 --> 00:41:09,599
size

1162
00:41:09,599 --> 00:41:13,040
work or protecting the encryption types

1163
00:41:13,040 --> 00:41:13,599
from

1164
00:41:13,599 --> 00:41:17,280
quantum computers so the reason for that

1165
00:41:17,280 --> 00:41:21,359
is the particular algorithm that was

1166
00:41:21,359 --> 00:41:22,400
developed

1167
00:41:22,400 --> 00:41:26,000
by the researcher

1168
00:41:26,000 --> 00:41:29,040
his name was grover and

1169
00:41:29,040 --> 00:41:32,560
the algorithm that's used to

1170
00:41:32,560 --> 00:41:34,560
break symmetric encryption with a

1171
00:41:34,560 --> 00:41:36,400
quantum computer

1172
00:41:36,400 --> 00:41:39,280
ends up scaling at a rate that makes it

1173
00:41:39,280 --> 00:41:41,280
to where doubling the key size

1174
00:41:41,280 --> 00:41:44,720
prevents the attacks from taking place

1175
00:41:44,720 --> 00:41:47,200
so it works differently with the

1176
00:41:47,200 --> 00:41:49,839
asymmetric algorithms that

1177
00:41:49,839 --> 00:41:53,200
scales linear linearly and so

1178
00:41:53,200 --> 00:41:56,400
any doubling of key sizes with

1179
00:41:56,400 --> 00:41:59,359
asymmetric algorithms you you end up

1180
00:41:59,359 --> 00:42:00,720
having to just

1181
00:42:00,720 --> 00:42:02,319
increase the number of qubits in your

1182
00:42:02,319 --> 00:42:05,440
quantum computer by one

1183
00:42:08,960 --> 00:42:12,079
so next question again quantum computers

1184
00:42:12,079 --> 00:42:14,319
is if the issue is around prime

1185
00:42:14,319 --> 00:42:16,160
factorization or if there's something

1186
00:42:16,160 --> 00:42:17,359
else to it

1187
00:42:17,359 --> 00:42:20,160
so with with symmetric cryptography

1188
00:42:20,160 --> 00:42:22,480
there's no prime numbers

1189
00:42:22,480 --> 00:42:24,560
with things like rsa that use prime

1190
00:42:24,560 --> 00:42:25,839
numbers the

1191
00:42:25,839 --> 00:42:28,000
method to generate the private key is

1192
00:42:28,000 --> 00:42:29,520
you come up with the

1193
00:42:29,520 --> 00:42:31,599
biggest random number you can think of

1194
00:42:31,599 --> 00:42:33,440
make sure it's odd

1195
00:42:33,440 --> 00:42:36,079
and then start increasing that by two

1196
00:42:36,079 --> 00:42:38,640
until you find a prime number

1197
00:42:38,640 --> 00:42:41,680
and the algorithm that was used for

1198
00:42:41,680 --> 00:42:44,240
quantum computers to

1199
00:42:44,240 --> 00:42:47,200
quickly factor prime numbers is why

1200
00:42:47,200 --> 00:42:48,720
that's affected there

1201
00:42:48,720 --> 00:42:50,720
but since there's no prime numbers used

1202
00:42:50,720 --> 00:42:52,640
in symmetric encryption

1203
00:42:52,640 --> 00:42:58,240
it doesn't have any effect here

1204
00:42:58,240 --> 00:43:01,440
the the scale for breaking symmetric

1205
00:43:01,440 --> 00:43:02,560
encryption

1206
00:43:02,560 --> 00:43:08,319
using quantum uh you would have to

1207
00:43:09,520 --> 00:43:12,560
add qubits on a logarithmic scale in

1208
00:43:12,560 --> 00:43:13,359
order to get

1209
00:43:13,359 --> 00:43:16,720
up to the ability to break 256-bit

1210
00:43:16,720 --> 00:43:17,760
encryption

1211
00:43:17,760 --> 00:43:20,079
instead of at a linear scale like you

1212
00:43:20,079 --> 00:43:23,200
would for asymmetric

1213
00:43:25,680 --> 00:43:27,200
uh another question is how to get the

1214
00:43:27,200 --> 00:43:29,359
slides i will

1215
00:43:29,359 --> 00:43:32,480
post these on

1216
00:43:32,480 --> 00:43:37,040
on my website cem.me and i'll put a

1217
00:43:37,040 --> 00:43:38,800
i'll put a blog post together that kind

1218
00:43:38,800 --> 00:43:40,480
of goes through basically everything i

1219
00:43:40,480 --> 00:43:41,920
talked about today

1220
00:43:41,920 --> 00:43:44,800
plus a little bit more

1221
00:43:51,839 --> 00:43:53,119
cool what other questions do you all

1222
00:43:53,119 --> 00:43:54,800
have feel free to keep popping him in

1223
00:43:54,800 --> 00:44:09,839
the discord

1224
00:44:10,640 --> 00:44:13,119
all right make sure you also go check

1225
00:44:13,119 --> 00:44:13,680
out the

1226
00:44:13,680 --> 00:44:16,879
crypto challenge it's on

1227
00:44:17,400 --> 00:44:20,400
ctfscoreboard.bsidesatx.com

1228
00:44:21,359 --> 00:44:22,720
what would be some advice that you would

1229
00:44:22,720 --> 00:44:24,880
give somebody um

1230
00:44:24,880 --> 00:44:27,599
to kind of start those crypto challenges

1231
00:44:27,599 --> 00:44:29,200
like what would be some things they need

1232
00:44:29,200 --> 00:44:30,319
to think about or

1233
00:44:30,319 --> 00:44:33,040
minds that they have to go into it so

1234
00:44:33,040 --> 00:44:33,920
one of the

1235
00:44:33,920 --> 00:44:35,760
one of the things you could do is take

1236
00:44:35,760 --> 00:44:37,359
the clue and

1237
00:44:37,359 --> 00:44:39,040
put the word cipher after it and throw

1238
00:44:39,040 --> 00:44:40,800
that into google and see what you come

1239
00:44:40,800 --> 00:44:42,079
up with

1240
00:44:42,079 --> 00:44:43,920
that's a good way to find out what

1241
00:44:43,920 --> 00:44:46,000
algorithm is used to do the

1242
00:44:46,000 --> 00:44:49,040
encryption puzzles and the clues are

1243
00:44:49,040 --> 00:44:54,319
there on the ctf site intent

1244
00:44:56,240 --> 00:45:00,640
um all right somebody also mentioned

1245
00:45:00,640 --> 00:45:03,359
some of the the content on my website

1246
00:45:03,359 --> 00:45:05,280
the big versions of some of the posters

1247
00:45:05,280 --> 00:45:06,560
aren't available because

1248
00:45:06,560 --> 00:45:09,440
i haven't updated my cdn so yeah i think

1249
00:45:09,440 --> 00:45:19,839
i need to work on that

1250
00:45:20,000 --> 00:45:21,359
there's another question about your

1251
00:45:21,359 --> 00:45:24,720
thoughts on browser encryption

1252
00:45:26,480 --> 00:45:28,960
see uh browser encryption there's

1253
00:45:28,960 --> 00:45:29,839
actually some

1254
00:45:29,839 --> 00:45:32,319
new developments in that where browsers

1255
00:45:32,319 --> 00:45:33,040
have taken

1256
00:45:33,040 --> 00:45:36,480
and making made javascript versions

1257
00:45:36,480 --> 00:45:39,599
of these algorithms so you have a fast

1258
00:45:39,599 --> 00:45:43,200
javascript implementation of aes gcm

1259
00:45:43,200 --> 00:45:46,400
or cha cha 20 as well as

1260
00:45:46,400 --> 00:45:49,359
asymmetric algorithms like ecdsa that

1261
00:45:49,359 --> 00:45:50,720
are available there

1262
00:45:50,720 --> 00:45:53,359
in the in the browser for use to protect

1263
00:45:53,359 --> 00:45:54,319
data

1264
00:45:54,319 --> 00:45:58,160
and this can be useful if you're

1265
00:45:58,160 --> 00:46:01,839
making an application to do encryption

1266
00:46:01,839 --> 00:46:04,800
for communication between two parties or

1267
00:46:04,800 --> 00:46:07,200
if you're trying to

1268
00:46:07,200 --> 00:46:10,000
store something locally in a safe manner

1269
00:46:10,000 --> 00:46:11,599
um

1270
00:46:11,599 --> 00:46:13,839
otherwise the other browser encryption

1271
00:46:13,839 --> 00:46:15,520
that of course everybody knows and loves

1272
00:46:15,520 --> 00:46:18,960
is the tls which is a

1273
00:46:18,960 --> 00:46:21,280
great way to protect your data as long

1274
00:46:21,280 --> 00:46:24,480
as you configure it correctly

1275
00:46:25,119 --> 00:46:26,400
carl one of the questions that we

1276
00:46:26,400 --> 00:46:28,560
received on discord is

1277
00:46:28,560 --> 00:46:30,560
asking is it an appropriate takeaway

1278
00:46:30,560 --> 00:46:32,160
that all the hype around quantum

1279
00:46:32,160 --> 00:46:33,200
decryption

1280
00:46:33,200 --> 00:46:34,880
doom is overblown what are your thoughts

1281
00:46:34,880 --> 00:46:37,200
on that

1282
00:46:38,240 --> 00:46:42,000
so it depends on the method

1283
00:46:42,000 --> 00:46:44,240
that you're using for protecting the

1284
00:46:44,240 --> 00:46:45,520
data

1285
00:46:45,520 --> 00:46:48,800
so one of the reasons that

1286
00:46:48,800 --> 00:46:51,040
people are focusing on encryption

1287
00:46:51,040 --> 00:46:52,560
quantum

1288
00:46:52,560 --> 00:46:56,240
algorithms now to prevent decryption

1289
00:46:56,240 --> 00:46:58,800
or any cryptographic problems when

1290
00:46:58,800 --> 00:47:01,119
quantum computers are available

1291
00:47:01,119 --> 00:47:03,760
is the way specific algorithms work for

1292
00:47:03,760 --> 00:47:04,319
example

1293
00:47:04,319 --> 00:47:07,680
in tls you come to a key agreement

1294
00:47:07,680 --> 00:47:10,480
for the data to be encrypted with the

1295
00:47:10,480 --> 00:47:12,000
problem is that key agreement

1296
00:47:12,000 --> 00:47:15,119
happens with symmetric algorithms

1297
00:47:15,119 --> 00:47:17,440
and or sorry it happens with asymmetric

1298
00:47:17,440 --> 00:47:18,400
algorithms

1299
00:47:18,400 --> 00:47:20,960
which are highly brittle when exposed to

1300
00:47:20,960 --> 00:47:22,720
quantum computers

1301
00:47:22,720 --> 00:47:25,920
so think about your

1302
00:47:25,920 --> 00:47:28,240
facebook logon for a computer or mobile

1303
00:47:28,240 --> 00:47:29,200
device

1304
00:47:29,200 --> 00:47:30,559
when's the last time you entered in your

1305
00:47:30,559 --> 00:47:32,400
password for facebook or

1306
00:47:32,400 --> 00:47:35,359
for google the authentication cookies

1307
00:47:35,359 --> 00:47:36,800
that you're sending there

1308
00:47:36,800 --> 00:47:40,160
are extremely long-lived because people

1309
00:47:40,160 --> 00:47:42,240
the the developers of those websites

1310
00:47:42,240 --> 00:47:43,520
have decided that

1311
00:47:43,520 --> 00:47:45,119
they don't want to make people log in

1312
00:47:45,119 --> 00:47:46,640
continuously

1313
00:47:46,640 --> 00:47:48,640
so because of that we have really really

1314
00:47:48,640 --> 00:47:49,760
long-lived

1315
00:47:49,760 --> 00:47:52,160
sensitive data that's being run through

1316
00:47:52,160 --> 00:47:53,920
algorithms like tls

1317
00:47:53,920 --> 00:47:55,839
so if you take and store and capture

1318
00:47:55,839 --> 00:47:57,760
data today

1319
00:47:57,760 --> 00:48:00,079
that was encrypted with tls and a

1320
00:48:00,079 --> 00:48:02,160
quantum computer is developed

1321
00:48:02,160 --> 00:48:04,400
later they can go back to that data

1322
00:48:04,400 --> 00:48:06,480
today that they kept

1323
00:48:06,480 --> 00:48:09,520
and break that key agreement they're not

1324
00:48:09,520 --> 00:48:10,559
breaking aes

1325
00:48:10,559 --> 00:48:12,800
they're just breaking the the way that

1326
00:48:12,800 --> 00:48:15,119
the aes key is derived

1327
00:48:15,119 --> 00:48:17,119
because of that it puts that data that

1328
00:48:17,119 --> 00:48:18,319
was sent today

1329
00:48:18,319 --> 00:48:19,520
even though it was encrypted with a

1330
00:48:19,520 --> 00:48:21,119
really strong algorithm that's not

1331
00:48:21,119 --> 00:48:23,119
vulnerable to quantum encryption

1332
00:48:23,119 --> 00:48:25,359
it allows them to decrypt that and get

1333
00:48:25,359 --> 00:48:29,040
to the actual sensitive data

1334
00:48:30,640 --> 00:48:34,000
so it's not necessarily overblown but

1335
00:48:34,000 --> 00:48:36,480
you actually have to think of what the

1336
00:48:36,480 --> 00:48:37,599
algorithm is

1337
00:48:37,599 --> 00:48:38,880
what type of data you're trying to

1338
00:48:38,880 --> 00:48:41,119
protect with and

1339
00:48:41,119 --> 00:48:44,800
how you should best try to protect that

1340
00:48:46,839 --> 00:48:49,839
data

1341
00:48:51,200 --> 00:48:53,599
i'm trying to pull up the uh the right

1342
00:48:53,599 --> 00:48:56,240
channel to send for the crypto puzzle

1343
00:48:56,240 --> 00:48:59,599
to the other question in the chat here

1344
00:48:59,599 --> 00:49:02,640
you go there and look at the pinned

1345
00:49:02,640 --> 00:49:04,720
messages on that channel you'll get all

1346
00:49:04,720 --> 00:49:06,559
the links that you need for the

1347
00:49:06,559 --> 00:49:09,440
the crypto puzzle

1348
00:49:12,559 --> 00:49:15,359
all right another another question is

1349
00:49:15,359 --> 00:49:16,400
what hobbies i have

1350
00:49:16,400 --> 00:49:19,520
outside of doing crypto stuff um

1351
00:49:19,520 --> 00:49:23,200
i i enjoy music i have a banjo here

1352
00:49:23,200 --> 00:49:26,480
it's fun to play i also play a couple

1353
00:49:26,480 --> 00:49:27,280
other

1354
00:49:27,280 --> 00:49:29,839
different instruments too so really

1355
00:49:29,839 --> 00:49:32,319
enjoy that

1356
00:49:32,880 --> 00:49:35,920
reading as well nobody ever expects this

1357
00:49:35,920 --> 00:49:45,839
banjo it's like the spanish inquisition

1358
00:50:19,520 --> 00:50:21,599
you

