1
00:00:05,390 --> 00:00:13,590
come to speak next Mike is a developer

2
00:00:10,500 --> 00:00:16,289
with a passion for digital government he

3
00:00:13,590 --> 00:00:18,448
had a career in IT security in

4
00:00:16,289 --> 00:00:20,910
government where he left to do various

5
00:00:18,449 --> 00:00:24,949
startups he's gonna talk to us about

6
00:00:20,910 --> 00:00:32,809
graph QL and Lang SEC Mike take it away

7
00:00:24,949 --> 00:00:36,379
okay so I'm assuming you can hear me

8
00:00:32,809 --> 00:00:41,780
yeah just need to make you presenter

9
00:00:36,379 --> 00:00:48,239
okay let me know if you can see my

10
00:00:41,780 --> 00:00:55,109
screen yeah I think we can see it we're

11
00:00:48,239 --> 00:01:01,919
good okay Wow then what I shall do is go

12
00:00:55,109 --> 00:01:04,320
full screen and so with that I my name

13
00:01:01,920 --> 00:01:06,090
is Michael ensign I'm here to talk to

14
00:01:04,319 --> 00:01:08,580
you but applying high tech principles

15
00:01:06,090 --> 00:01:14,880
with graph QL and how those things can

16
00:01:08,580 --> 00:01:16,800
help us build super systems so as was

17
00:01:14,880 --> 00:01:19,320
mentioned I had left a number of years

18
00:01:16,800 --> 00:01:22,950
ago a career in IT security a kind of

19
00:01:19,320 --> 00:01:24,539
software developer before eventually

20
00:01:22,950 --> 00:01:28,670
arriving in the realization that this

21
00:01:24,540 --> 00:01:31,170
was actually the same career so that

22
00:01:28,670 --> 00:01:33,960
realization along with sort of my

23
00:01:31,170 --> 00:01:37,830
efforts to ensure that the system but I

24
00:01:33,960 --> 00:01:40,380
was now building didn't have the kind of

25
00:01:37,830 --> 00:01:43,080
like security problems that my that I

26
00:01:40,380 --> 00:01:44,970
was seeing in my previous life have led

27
00:01:43,080 --> 00:01:46,860
me to a corner of the world known as

28
00:01:44,970 --> 00:01:50,700
Lang SEC a corner of the security world

29
00:01:46,860 --> 00:01:53,909
known as Lang second and so the best

30
00:01:50,700 --> 00:01:56,550
definition I've seen of like Lang SEC

31
00:01:53,909 --> 00:01:59,490
language theoretic city is is this one

32
00:01:56,550 --> 00:02:02,009
and it's it's really as its highlighted

33
00:01:59,490 --> 00:02:04,470
here the many security issues in fact

34
00:02:02,010 --> 00:02:07,650
many of the most common security issues

35
00:02:04,470 --> 00:02:11,180
can be avoided by applying a standard

36
00:02:07,650 --> 00:02:15,769
process to input processing so that

37
00:02:11,180 --> 00:02:18,810
standard process is is simply this

38
00:02:15,769 --> 00:02:22,400
acceptable input to a program should be

39
00:02:18,810 --> 00:02:25,440
well defined but the caveats here are

40
00:02:22,400 --> 00:02:28,470
that well is the definition of well

41
00:02:25,440 --> 00:02:31,170
defined essentially so they have a

42
00:02:28,470 --> 00:02:33,359
pretty rigorous definition of well

43
00:02:31,170 --> 00:02:36,410
defined where well defined means

44
00:02:33,360 --> 00:02:39,890
treating your inputs as a language and

45
00:02:36,410 --> 00:02:43,380
defining a formal grammar for for

46
00:02:39,890 --> 00:02:46,200
recognizing that language and so then

47
00:02:43,380 --> 00:02:49,440
the next one is simple as possible again

48
00:02:46,200 --> 00:02:54,209
the rigorous definition here is that

49
00:02:49,440 --> 00:02:57,440
simple means simple on the Noam

50
00:02:54,209 --> 00:03:00,269
Chomsky's scale of kind of language

51
00:02:57,440 --> 00:03:02,459
complexity and so this is a thing that

52
00:03:00,269 --> 00:03:05,010
he had developed in the 1950s and so

53
00:03:02,459 --> 00:03:08,430
yeah big goal is to rank as low as

54
00:03:05,010 --> 00:03:11,280
possible Noam Chomsky's scale of

55
00:03:08,430 --> 00:03:14,819
syntactic complexity and then finally

56
00:03:11,280 --> 00:03:18,510
fully validated before use so the

57
00:03:14,819 --> 00:03:22,649
concept here is that you would basically

58
00:03:18,510 --> 00:03:24,810
write a custom parser for to determine

59
00:03:22,650 --> 00:03:27,420
whether or not like strings that are

60
00:03:24,810 --> 00:03:30,720
arriving at your system are actually a

61
00:03:27,420 --> 00:03:35,488
valid you know part of this language as

62
00:03:30,720 --> 00:03:37,230
defined by your your grammar so you kind

63
00:03:35,489 --> 00:03:38,970
of get a sense in here that as all of

64
00:03:37,230 --> 00:03:40,350
these things are kind of individually

65
00:03:38,970 --> 00:03:42,180
something and I think we'd all agree

66
00:03:40,350 --> 00:03:46,500
with but what separates links like out

67
00:03:42,180 --> 00:03:49,680
here is the academic rigor of their

68
00:03:46,500 --> 00:03:52,889
their definitions here and so the

69
00:03:49,680 --> 00:03:54,959
pattern that ends up coming out of kind

70
00:03:52,889 --> 00:03:57,030
of this this way of thinking

71
00:03:54,959 --> 00:03:59,609
one of the main patterns here is called

72
00:03:57,030 --> 00:04:04,019
the recognizer pattern so what you can

73
00:03:59,609 --> 00:04:06,630
see here is we have a recognizer that

74
00:04:04,019 --> 00:04:10,049
accepts as input that grammar

75
00:04:06,630 --> 00:04:12,720
specification and also accepts an input

76
00:04:10,049 --> 00:04:15,209
and so what it's going to do here is

77
00:04:12,720 --> 00:04:17,250
it's going to take this input string and

78
00:04:15,209 --> 00:04:19,289
it's going to determine whether or not

79
00:04:17,250 --> 00:04:21,660
this input string is actually a valid

80
00:04:19,289 --> 00:04:23,810
string in the language that you've

81
00:04:21,660 --> 00:04:28,650
defined with this grammar

82
00:04:23,810 --> 00:04:31,120
if it isn't the recognizers job is to

83
00:04:28,650 --> 00:04:32,830
turf festering immediately no further

84
00:04:31,120 --> 00:04:36,699
processing is going to Apple happen to

85
00:04:32,830 --> 00:04:38,948
it I if the input string is valid

86
00:04:36,699 --> 00:04:41,080
according to the grammar what the

87
00:04:38,949 --> 00:04:45,130
recognizer is going to do is transform

88
00:04:41,080 --> 00:04:47,229
this this you know whatever parts of the

89
00:04:45,130 --> 00:04:49,419
string make sense into some sort of

90
00:04:47,229 --> 00:04:52,000
structure the object whatever makes

91
00:04:49,419 --> 00:04:53,560
sense for the language it's going to

92
00:04:52,000 --> 00:04:55,690
transform it into the structured object

93
00:04:53,560 --> 00:05:01,810
and it's compasseth on to the actual

94
00:04:55,690 --> 00:05:03,820
business logic for for processing so the

95
00:05:01,810 --> 00:05:06,430
point of all of this kind of like

96
00:05:03,820 --> 00:05:08,349
rigorous specification and transforming

97
00:05:06,430 --> 00:05:10,180
your inputs into a language and writing

98
00:05:08,350 --> 00:05:14,050
parsers all that so that's some pretty

99
00:05:10,180 --> 00:05:16,750
intense computer science stuff P off the

100
00:05:14,050 --> 00:05:18,100
point of all of that work is that what

101
00:05:16,750 --> 00:05:21,280
you will have done is you will have

102
00:05:18,100 --> 00:05:23,320
created essentially the equivalent of an

103
00:05:21,280 --> 00:05:25,960
application firewall but this isn't

104
00:05:23,320 --> 00:05:28,479
going to be one of those generic

105
00:05:25,960 --> 00:05:30,190
application firewalls that you you you

106
00:05:28,479 --> 00:05:32,830
might used to sitting somewhere out on

107
00:05:30,190 --> 00:05:36,490
the network in front of your app this is

108
00:05:32,830 --> 00:05:41,530
a custom-built application firewall that

109
00:05:36,490 --> 00:05:44,289
is specifically designed for your and

110
00:05:41,530 --> 00:05:46,719
your data in fact it's built into your

111
00:05:44,289 --> 00:05:52,419
app and this is an insanely powerful

112
00:05:46,720 --> 00:05:56,700
thing so at this point I'm a graphic up

113
00:05:52,419 --> 00:06:01,060
enter stage right and this is a

114
00:05:56,700 --> 00:06:03,310
technology that's born of Facebook's you

115
00:06:01,060 --> 00:06:06,910
know a transition to a certainly a

116
00:06:03,310 --> 00:06:09,840
modern a mobile world so you know the

117
00:06:06,910 --> 00:06:13,389
iPhone I think launched around 2007 and

118
00:06:09,840 --> 00:06:16,989
between 2007 and 2012 basically there's

119
00:06:13,389 --> 00:06:21,370
this turn on a dime shift towards like

120
00:06:16,990 --> 00:06:23,530
people accessing Facebook from this new

121
00:06:21,370 --> 00:06:26,349
type of device and it

122
00:06:23,530 --> 00:06:29,770
it caused a real shift in how the

123
00:06:26,349 --> 00:06:31,150
company did things and so what faced

124
00:06:29,770 --> 00:06:33,310
with a whole bunch of these devices that

125
00:06:31,150 --> 00:06:34,750
are all having kind of asking for

126
00:06:33,310 --> 00:06:36,940
different bits of the same kind of data

127
00:06:34,750 --> 00:06:38,979
and various combinations they realized

128
00:06:36,940 --> 00:06:43,289
they had a kind of a permutations

129
00:06:38,979 --> 00:06:44,870
problem on their hand and that if their

130
00:06:43,289 --> 00:06:49,760
query if there

131
00:06:44,870 --> 00:06:53,720
API supported a query language well then

132
00:06:49,760 --> 00:06:55,880
all of these different you know clients

133
00:06:53,720 --> 00:06:59,140
that we're coming at them could

134
00:06:55,880 --> 00:07:01,880
basically it express their data needs

135
00:06:59,140 --> 00:07:04,219
using just this language that the server

136
00:07:01,880 --> 00:07:05,780
supported and at that point all of these

137
00:07:04,220 --> 00:07:08,410
things would essentially just be the

138
00:07:05,780 --> 00:07:12,619
same lease from the server's perspective

139
00:07:08,410 --> 00:07:14,930
so um this is I think a pretty brilliant

140
00:07:12,620 --> 00:07:17,000
piece of engineering and what was even

141
00:07:14,930 --> 00:07:21,290
more impressive to me is the way they

142
00:07:17,000 --> 00:07:22,640
actually went to did this so they when

143
00:07:21,290 --> 00:07:27,470
they released this as an open source

144
00:07:22,640 --> 00:07:29,180
project in 2015 they started not just

145
00:07:27,470 --> 00:07:30,760
with a credible working reference

146
00:07:29,180 --> 00:07:34,400
implementation but what they did is they

147
00:07:30,760 --> 00:07:37,210
started with a specification and so this

148
00:07:34,400 --> 00:07:40,700
specification you can find it online is

149
00:07:37,210 --> 00:07:43,580
this is the the the grammar of graphical

150
00:07:40,700 --> 00:07:47,810
effectively you can pick through this

151
00:07:43,580 --> 00:07:49,580
and explore and it's essentially if this

152
00:07:47,810 --> 00:07:54,200
specifies the formal language of

153
00:07:49,580 --> 00:08:01,070
graphical oh yeah assuming everything is

154
00:07:54,200 --> 00:08:03,710
well behaved there we go um so what's

155
00:08:01,070 --> 00:08:06,880
super interesting here is that what they

156
00:08:03,710 --> 00:08:09,919
did next was they allowed developers to

157
00:08:06,880 --> 00:08:12,440
essentially define the evap type system

158
00:08:09,920 --> 00:08:15,650
and it land developers to define new

159
00:08:12,440 --> 00:08:19,190
types in this type system and fields on

160
00:08:15,650 --> 00:08:22,219
those types and so what this a lot of

161
00:08:19,190 --> 00:08:27,710
people do is create their own nouns and

162
00:08:22,220 --> 00:08:29,600
verbs in this in this language all

163
00:08:27,710 --> 00:08:31,729
within this crappy old language and so

164
00:08:29,600 --> 00:08:33,980
your job is a developer when you're

165
00:08:31,730 --> 00:08:35,390
working this way is just effectively

166
00:08:33,980 --> 00:08:39,260
create these sort of inane nouns and

167
00:08:35,390 --> 00:08:43,490
verbs and then attach a function to them

168
00:08:39,260 --> 00:08:46,490
that should be called when when someone

169
00:08:43,490 --> 00:08:51,230
asks you for that noun or or tells you

170
00:08:46,490 --> 00:08:54,260
to do that for and so what that then

171
00:08:51,230 --> 00:08:57,110
gives you is basically a scenario where

172
00:08:54,260 --> 00:08:58,250
you're the queries that are coming at

173
00:08:57,110 --> 00:09:01,130
you the the input

174
00:08:58,250 --> 00:09:04,670
- the system is now written in the graph

175
00:09:01,130 --> 00:09:06,260
you all formal language which has all of

176
00:09:04,670 --> 00:09:08,689
the kind of structure that you would

177
00:09:06,260 --> 00:09:10,970
need you know this is sort of fit with

178
00:09:08,690 --> 00:09:12,890
the grammar and and these queries are

179
00:09:10,970 --> 00:09:15,410
the bendigo and a referent reference the

180
00:09:12,890 --> 00:09:20,990
nouns and verbs that you've defined for

181
00:09:15,410 --> 00:09:23,150
your server and service so as you start

182
00:09:20,990 --> 00:09:25,520
you know playing with the stuff you

183
00:09:23,150 --> 00:09:30,770
realize like there's a graphic you all

184
00:09:25,520 --> 00:09:33,260
function and so it is you know kind of

185
00:09:30,770 --> 00:09:36,199
fascinatingly has the same structure

186
00:09:33,260 --> 00:09:38,840
that we're familiar with so you can see

187
00:09:36,200 --> 00:09:40,490
we're passing in a schema and this is

188
00:09:38,840 --> 00:09:42,260
going to be the the thing that's going

189
00:09:40,490 --> 00:09:44,120
to define all of our little nouns and

190
00:09:42,260 --> 00:09:47,390
birds are all of our extensions to the

191
00:09:44,120 --> 00:09:49,310
graphical grammar and what we're doing

192
00:09:47,390 --> 00:09:51,939
is we're passing in input here where

193
00:09:49,310 --> 00:09:55,849
presumably this would normally come from

194
00:09:51,940 --> 00:09:58,460
an HTTP request or something and that

195
00:09:55,850 --> 00:09:59,810
we've gotten from the network and what

196
00:09:58,460 --> 00:10:04,900
the graphical function is going to do

197
00:09:59,810 --> 00:10:07,280
here is it's going to determine if the

198
00:10:04,900 --> 00:10:09,079
query the content of this query it's

199
00:10:07,280 --> 00:10:12,650
going to parse it according to the the

200
00:10:09,080 --> 00:10:14,150
grammar determine if it's valid not just

201
00:10:12,650 --> 00:10:17,060
accordingly the graphic you although

202
00:10:14,150 --> 00:10:18,319
grammar itself but our schema and the

203
00:10:17,060 --> 00:10:21,650
sort of the definitions that we've

204
00:10:18,320 --> 00:10:23,870
supplied Eric if it is it's going to

205
00:10:21,650 --> 00:10:27,589
pick relevant pieces out of the query

206
00:10:23,870 --> 00:10:30,350
and provide the functions that we've you

207
00:10:27,589 --> 00:10:34,010
know defined provide structured data to

208
00:10:30,350 --> 00:10:37,430
those functions in Burton's and return

209
00:10:34,010 --> 00:10:39,050
whatever comes out if not if not if the

210
00:10:37,430 --> 00:10:41,630
query isn't valid according to our

211
00:10:39,050 --> 00:10:44,530
schema it's just going to drop this this

212
00:10:41,630 --> 00:10:48,320
thing on the floor and return an error

213
00:10:44,530 --> 00:10:52,100
so it's really hard not to notice that

214
00:10:48,320 --> 00:10:55,910
this has exactly the form the ranks a

215
00:10:52,100 --> 00:10:58,580
quark admitted pattern and you know

216
00:10:55,910 --> 00:11:01,339
basically as I've sort of work with this

217
00:10:58,580 --> 00:11:03,830
and started folding it in to interview

218
00:11:01,339 --> 00:11:06,560
my work my work with my projects it's

219
00:11:03,830 --> 00:11:09,170
really interesting to just sort of note

220
00:11:06,560 --> 00:11:11,430
that you know that this this is that

221
00:11:09,170 --> 00:11:15,420
instance of the

222
00:11:11,430 --> 00:11:17,910
as a path so I think question at this

223
00:11:15,420 --> 00:11:19,860
point is okay cool that's that's

224
00:11:17,910 --> 00:11:22,860
handling input you're you're doing a

225
00:11:19,860 --> 00:11:26,850
great job recognizing it but whatever

226
00:11:22,860 --> 00:11:28,980
how does that get handled well so it

227
00:11:26,850 --> 00:11:30,390
won't surprise you to realize that it

228
00:11:28,980 --> 00:11:33,720
like like seconds actually done a fair

229
00:11:30,390 --> 00:11:36,390
bit of thinking about this and they have

230
00:11:33,720 --> 00:11:38,430
what is essentially the inverse of the

231
00:11:36,390 --> 00:11:43,649
recognizer pattern which they call the

232
00:11:38,430 --> 00:11:45,779
unperson so they think that what happens

233
00:11:43,649 --> 00:11:48,060
is you have the the recognizer of

234
00:11:45,779 --> 00:11:51,000
pattern which gets connected with their

235
00:11:48,060 --> 00:11:55,469
most restrictive input definition and a

236
00:11:51,000 --> 00:11:58,050
non parser and it like Voltron these

237
00:11:55,470 --> 00:12:02,760
things come together into like a

238
00:11:58,050 --> 00:12:06,329
transducer the names are awesome here so

239
00:12:02,760 --> 00:12:10,319
here is our transducer so all of the

240
00:12:06,330 --> 00:12:11,670
stuff on the left-hand side is you can

241
00:12:10,320 --> 00:12:14,070
see the input grammar and the parser

242
00:12:11,670 --> 00:12:16,290
accepting raw input it's gonna you know

243
00:12:14,070 --> 00:12:20,459
call this handler so this is sort of for

244
00:12:16,290 --> 00:12:24,900
those of you who speak this is this is

245
00:12:20,459 --> 00:12:26,279
this is free so what you can see here I

246
00:12:24,900 --> 00:12:28,650
don't want to dive too deep into it but

247
00:12:26,279 --> 00:12:31,500
the idea is that inputs going to flow in

248
00:12:28,650 --> 00:12:33,810
through this the parser to recognize a

249
00:12:31,500 --> 00:12:35,640
pattern hit the business logic you know

250
00:12:33,810 --> 00:12:37,529
structure data to pass to the business

251
00:12:35,640 --> 00:12:39,930
logic and that business logic band is

252
00:12:37,529 --> 00:12:41,550
going to create a bunch of structured

253
00:12:39,930 --> 00:12:43,920
objects that's going to get passed to

254
00:12:41,550 --> 00:12:45,209
the output the emitter which goes to the

255
00:12:43,920 --> 00:12:47,520
end of our server and then finally to

256
00:12:45,209 --> 00:12:49,469
arrive and so this now you have the

257
00:12:47,520 --> 00:12:53,400
business logic sandwiched between stuff

258
00:12:49,470 --> 00:12:55,140
that is previously rigorously kind of

259
00:12:53,400 --> 00:12:57,360
doing all the trigger checking of the

260
00:12:55,140 --> 00:13:04,100
input and something is you know

261
00:12:57,360 --> 00:13:06,779
rigorously checking the output so the

262
00:13:04,100 --> 00:13:10,910
that particular architecture if graph

263
00:13:06,779 --> 00:13:16,380
fuel is not quite the same but it does

264
00:13:10,910 --> 00:13:18,420
but because it does force the the output

265
00:13:16,380 --> 00:13:21,180
of the functions that you defined to

266
00:13:18,420 --> 00:13:23,010
conform to the same type system the

267
00:13:21,180 --> 00:13:25,878
argument I want to put forward here is

268
00:13:23,010 --> 00:13:29,490
that I believe that RQL

269
00:13:25,879 --> 00:13:32,819
kind of fulfills the contract that this

270
00:13:29,490 --> 00:13:34,620
transducer fulfills the requirements to

271
00:13:32,819 --> 00:13:36,120
qualify as sort of an alternate

272
00:13:34,620 --> 00:13:41,009
implementation of this transducer

273
00:13:36,120 --> 00:13:42,569
pattern and so that they saying here is

274
00:13:41,009 --> 00:13:46,290
that what you have with this transducer

275
00:13:42,569 --> 00:13:48,059
now is a transparent filter that's just

276
00:13:46,290 --> 00:13:50,040
like they're saying operating at the

277
00:13:48,059 --> 00:13:52,559
trust boundary of the system and this

278
00:13:50,040 --> 00:13:59,730
again this they kind of liken this to

279
00:13:52,559 --> 00:14:01,740
this you know syntactic firewall so the

280
00:13:59,730 --> 00:14:05,220
underlying point I think through for me

281
00:14:01,740 --> 00:14:08,699
with all of this is that I find this

282
00:14:05,220 --> 00:14:13,559
super exciting to see a pattern that was

283
00:14:08,699 --> 00:14:17,248
formerly kind of just in use in kind of

284
00:14:13,559 --> 00:14:20,910
only the most sort of high you know high

285
00:14:17,249 --> 00:14:24,769
assurance systems that is suddenly kind

286
00:14:20,910 --> 00:14:27,180
of made available to to us mere mortals

287
00:14:24,769 --> 00:14:30,420
so that it's not every project that can

288
00:14:27,180 --> 00:14:32,160
sit down and start with a you know a

289
00:14:30,420 --> 00:14:34,250
formal language definition of the

290
00:14:32,160 --> 00:14:36,449
writing of a custom person right so

291
00:14:34,250 --> 00:14:37,649
seeing this kind of stuff with someone

292
00:14:36,449 --> 00:14:40,709
who's hoping for an across the board

293
00:14:37,649 --> 00:14:42,779
kind of improvement in security watching

294
00:14:40,709 --> 00:14:47,279
a pattern like this suddenly become more

295
00:14:42,779 --> 00:14:50,639
accessible is is really exciting so all

296
00:14:47,279 --> 00:14:52,230
of that stuff is fairly abstract so we

297
00:14:50,639 --> 00:14:56,430
try to make this a little bit more

298
00:14:52,230 --> 00:15:00,509
concrete by showing some actual code so

299
00:14:56,430 --> 00:15:03,719
I want to start with a effectively like

300
00:15:00,509 --> 00:15:06,180
just a definition of the query part of

301
00:15:03,720 --> 00:15:10,769
our schema right so what you can see

302
00:15:06,180 --> 00:15:13,920
here is we're defining a widget field on

303
00:15:10,769 --> 00:15:16,410
a query type so this is basically a lot

304
00:15:13,920 --> 00:15:18,329
of people took ask us for a widget this

305
00:15:16,410 --> 00:15:21,689
is not super interesting but it just

306
00:15:18,329 --> 00:15:23,429
gives us the basics so we're providing

307
00:15:21,689 --> 00:15:25,920
here where the little eyeballs are

308
00:15:23,429 --> 00:15:27,540
looking we're providing our resolver

309
00:15:25,920 --> 00:15:30,120
function this is that business logic

310
00:15:27,540 --> 00:15:34,649
that we were seeing in the like set

311
00:15:30,120 --> 00:15:36,480
powers so that resolver function it

312
00:15:34,649 --> 00:15:39,570
could be anything property has no idea

313
00:15:36,480 --> 00:15:42,600
what a database is and and it's just

314
00:15:39,570 --> 00:15:44,760
executing arbitrary functions and so

315
00:15:42,600 --> 00:15:47,940
what we're going to do is I'm just going

316
00:15:44,760 --> 00:15:49,620
to return a string here a little sequel

317
00:15:47,940 --> 00:15:52,200
string so let's pretend that this is

318
00:15:49,620 --> 00:15:54,690
going to get pass off the database and

319
00:15:52,200 --> 00:16:00,180
we would normally return whatever comes

320
00:15:54,690 --> 00:16:02,460
back from that so the thing I want to

321
00:16:00,180 --> 00:16:05,489
draw your attention to here is this is

322
00:16:02,460 --> 00:16:07,680
sort of where that sort of the notion of

323
00:16:05,490 --> 00:16:12,450
this graph cabela's transducer comes

324
00:16:07,680 --> 00:16:15,540
from so this is where we make an

325
00:16:12,450 --> 00:16:17,910
assertion to graph QL that what comes

326
00:16:15,540 --> 00:16:22,319
out of the running of the result

327
00:16:17,910 --> 00:16:26,670
function must be on crack yo string aka

328
00:16:22,320 --> 00:16:29,700
just a string so this is this is a

329
00:16:26,670 --> 00:16:31,949
promise that the graph will enforce and

330
00:16:29,700 --> 00:16:33,900
if something that is not a string comes

331
00:16:31,950 --> 00:16:37,050
out of this function it will just drop

332
00:16:33,900 --> 00:16:40,189
that on the floor and return null so

333
00:16:37,050 --> 00:16:43,680
that little definition that we have

334
00:16:40,190 --> 00:16:45,780
allows us to basically accept a query

335
00:16:43,680 --> 00:16:47,719
like the one on the top here so I'm just

336
00:16:45,780 --> 00:16:51,180
query we did it right this is

337
00:16:47,720 --> 00:16:52,650
fundamentally kind of an interesting but

338
00:16:51,180 --> 00:16:55,020
and so to make things more interesting

339
00:16:52,650 --> 00:16:57,780
what we'd like to do is except some user

340
00:16:55,020 --> 00:17:00,090
input so this is what we want to do is

341
00:16:57,780 --> 00:17:02,189
we're going to modify our little query

342
00:17:00,090 --> 00:17:05,850
schema so we can now accept the input

343
00:17:02,190 --> 00:17:10,860
and and and process a query like the one

344
00:17:05,849 --> 00:17:12,869
you see in a bomb so if we're going to

345
00:17:10,859 --> 00:17:17,479
start here what we're going to do is

346
00:17:12,869 --> 00:17:20,520
basically add an arguments object here a

347
00:17:17,480 --> 00:17:23,310
property on this widget definition so

348
00:17:20,520 --> 00:17:24,660
what we're going to do next is add we

349
00:17:23,310 --> 00:17:27,208
have to say like what that argument is

350
00:17:24,660 --> 00:17:31,020
so we give it a name by saying okay this

351
00:17:27,209 --> 00:17:33,030
is my eat and an object here that gives

352
00:17:31,020 --> 00:17:35,610
us some details about what this ID

353
00:17:33,030 --> 00:17:39,030
argument actually is so you can see here

354
00:17:35,610 --> 00:17:41,610
we have a description that we supply

355
00:17:39,030 --> 00:17:43,889
graph QL so it is self documenting via

356
00:17:41,610 --> 00:17:45,260
this the inclusion of these little

357
00:17:43,890 --> 00:17:48,960
descriptions all over the place

358
00:17:45,260 --> 00:17:52,160
which is pretty spectacular and then

359
00:17:48,960 --> 00:17:53,310
this is the the super important part is

360
00:17:52,160 --> 00:17:55,920
you

361
00:17:53,310 --> 00:17:59,790
is saying the type of data that this

362
00:17:55,920 --> 00:18:01,410
input is actually going to be now for

363
00:17:59,790 --> 00:18:02,850
demonstration purposes I'm going to make

364
00:18:01,410 --> 00:18:07,170
the rather ill-advised choice of

365
00:18:02,850 --> 00:18:08,699
choosing a rectal string here and you

366
00:18:07,170 --> 00:18:10,080
can see what I'm also saying here is

367
00:18:08,700 --> 00:18:11,910
that this graphical string it's not

368
00:18:10,080 --> 00:18:14,939
allowed to be null so this is

369
00:18:11,910 --> 00:18:20,580
essentially the required argument in a

370
00:18:14,940 --> 00:18:22,980
in a gradual world so next up I'm you

371
00:18:20,580 --> 00:18:25,500
can see that this is going to now be

372
00:18:22,980 --> 00:18:28,200
available to us in the resolve function

373
00:18:25,500 --> 00:18:31,110
and I'm going to make the rather

374
00:18:28,200 --> 00:18:34,620
distressing choice - I think I need this

375
00:18:31,110 --> 00:18:37,800
stuff directly into the string giving us

376
00:18:34,620 --> 00:18:42,570
some vulnerable code that's gonna make

377
00:18:37,800 --> 00:18:45,149
this stuff way more interesting so this

378
00:18:42,570 --> 00:18:47,909
if you go and actually test this you can

379
00:18:45,150 --> 00:18:50,070
mount that little schema on you know as

380
00:18:47,910 --> 00:18:52,110
the middleware on all the little web

381
00:18:50,070 --> 00:18:53,790
frameworks that are out there and then

382
00:18:52,110 --> 00:18:57,899
you can just poke at it with with curl

383
00:18:53,790 --> 00:19:00,050
and so as as implemented this is exactly

384
00:18:57,900 --> 00:19:02,820
as bad as you think

385
00:19:00,050 --> 00:19:05,129
so what you can see here is where we're

386
00:19:02,820 --> 00:19:07,560
doing you know a kind of little buggy

387
00:19:05,130 --> 00:19:10,680
table style we're just going to draw our

388
00:19:07,560 --> 00:19:13,500
simple injection in there and it does

389
00:19:10,680 --> 00:19:15,900
exactly the badness that you think and

390
00:19:13,500 --> 00:19:18,560
you know where this actually handed off

391
00:19:15,900 --> 00:19:21,690
to a database hilarity wouldn't see you

392
00:19:18,560 --> 00:19:29,159
so never the point of all of this is

393
00:19:21,690 --> 00:19:31,320
really to show that Facebook arrived at

394
00:19:29,160 --> 00:19:35,460
this design I'm thinking about mobile

395
00:19:31,320 --> 00:19:38,340
data fetching not security the some of

396
00:19:35,460 --> 00:19:41,340
the defaults in here are are not amazing

397
00:19:38,340 --> 00:19:44,490
in terms of you know of the security

398
00:19:41,340 --> 00:19:47,780
properties but the actual architecture

399
00:19:44,490 --> 00:19:51,480
of graph you all the way it works is

400
00:19:47,780 --> 00:19:53,220
incredibly powerful and so to make the

401
00:19:51,480 --> 00:19:55,830
most of this what we need to do is draw

402
00:19:53,220 --> 00:19:57,480
some lessons from the world of lansac

403
00:19:55,830 --> 00:20:02,730
and so this is kind of what I want to

404
00:19:57,480 --> 00:20:03,780
dive into now so the first kind of blank

405
00:20:02,730 --> 00:20:05,940
side first of all or what I'm talking

406
00:20:03,780 --> 00:20:06,870
about here is this is sort of an

407
00:20:05,940 --> 00:20:12,390
anti-pattern

408
00:20:06,870 --> 00:20:14,149
accepting complex to do so in the leg

409
00:20:12,390 --> 00:20:17,640
psych literature there they're pretty

410
00:20:14,150 --> 00:20:19,710
clear upfront about you really just need

411
00:20:17,640 --> 00:20:21,660
to accept that you cannot just accept

412
00:20:19,710 --> 00:20:24,840
anything

413
00:20:21,660 --> 00:20:25,950
and so army fairly complex data when

414
00:20:24,840 --> 00:20:28,260
they're saying you just need to give up

415
00:20:25,950 --> 00:20:31,230
on this I think what they're saying here

416
00:20:28,260 --> 00:20:33,870
is what they have in mind when they're

417
00:20:31,230 --> 00:20:36,990
saying this is really like crazy stuff

418
00:20:33,870 --> 00:20:40,409
like accepting you know a giant enormous

419
00:20:36,990 --> 00:20:42,210
string of JavaScript and trying to

420
00:20:40,410 --> 00:20:45,420
invalid app to determine whether or not

421
00:20:42,210 --> 00:20:46,680
is actually safe or a theory of smart

422
00:20:45,420 --> 00:20:50,910
contracts or something terrible like

423
00:20:46,680 --> 00:20:52,890
that you know and then so yes in this

424
00:20:50,910 --> 00:20:54,770
case you're going to you know run into

425
00:20:52,890 --> 00:20:58,590
the halting problem and all this badness

426
00:20:54,770 --> 00:21:01,680
but I think the the rule that they're

427
00:20:58,590 --> 00:21:06,120
they're putting out here I think applies

428
00:21:01,680 --> 00:21:09,030
even to stuff like JSON which can

429
00:21:06,120 --> 00:21:13,709
actually be safely recognized but and

430
00:21:09,030 --> 00:21:16,350
people have done this with with graph QL

431
00:21:13,710 --> 00:21:18,840
so they've actually implemented really

432
00:21:16,350 --> 00:21:20,580
people have implemented these special

433
00:21:18,840 --> 00:21:22,590
types that allow you to basically just

434
00:21:20,580 --> 00:21:27,149
pass arbitraries for those shapeless

435
00:21:22,590 --> 00:21:33,300
blobs and json into your api um this

436
00:21:27,150 --> 00:21:36,180
isn't necessarily a security problem but

437
00:21:33,300 --> 00:21:38,730
it is definitely a step a step away from

438
00:21:36,180 --> 00:21:40,590
the kind of specificity that we need for

439
00:21:38,730 --> 00:21:44,550
sort of safety and you know

440
00:21:40,590 --> 00:21:46,980
predictability so this is really

441
00:21:44,550 --> 00:21:48,690
something that you may see but you

442
00:21:46,980 --> 00:21:50,220
really want to kind of get away from

443
00:21:48,690 --> 00:21:56,190
that pure if you're finding yourself

444
00:21:50,220 --> 00:21:58,260
doing doing this you're going down so

445
00:21:56,190 --> 00:22:01,710
yeah I don't I want to talk about is

446
00:21:58,260 --> 00:22:04,890
really common it is

447
00:22:01,710 --> 00:22:10,010
strings the reason string was kind of an

448
00:22:04,890 --> 00:22:12,420
anti-pattern is strings are unpervaded

449
00:22:10,010 --> 00:22:17,070
all of these things countess Turing

450
00:22:12,420 --> 00:22:20,519
sequel JavaScript XML be 64 encoded

451
00:22:17,070 --> 00:22:23,218
video all of these things canvas

452
00:22:20,519 --> 00:22:26,869
it can absolutely be passed through the

453
00:22:23,219 --> 00:22:29,369
graph QL a type system just by cleaning

454
00:22:26,869 --> 00:22:32,399
their straightness by asserting their

455
00:22:29,369 --> 00:22:34,799
straightness but you know that inside

456
00:22:32,399 --> 00:22:38,330
that string is a whole bunch of

457
00:22:34,799 --> 00:22:41,789
structure and meaning that something

458
00:22:38,330 --> 00:22:46,978
presumably behind graph QL now is going

459
00:22:41,789 --> 00:22:49,200
to handle properly this is this is a

460
00:22:46,979 --> 00:22:52,829
really distressing practice and it's

461
00:22:49,200 --> 00:22:56,549
distressing specifically because it's

462
00:22:52,829 --> 00:22:58,979
it's essentially smuggling you know

463
00:22:56,549 --> 00:23:01,859
structure data and meaningful data

464
00:22:58,979 --> 00:23:05,039
through the like pass the parser without

465
00:23:01,859 --> 00:23:09,928
actually properly authenticating and

466
00:23:05,039 --> 00:23:12,658
validating um so again if you dig into

467
00:23:09,929 --> 00:23:15,629
the literature here what you can see is

468
00:23:12,659 --> 00:23:18,499
that they're they're pretty clear on

469
00:23:15,629 --> 00:23:21,418
this they would they just say like look

470
00:23:18,499 --> 00:23:24,559
structured structured data instead of

471
00:23:21,419 --> 00:23:26,789
strings are preferable everywhere I

472
00:23:24,559 --> 00:23:28,649
don't have any illusions that we're

473
00:23:26,789 --> 00:23:34,079
gonna completely just get rid of strings

474
00:23:28,649 --> 00:23:38,779
but realistically we want to kind of go

475
00:23:34,079 --> 00:23:40,769
with the the lowest number possible so

476
00:23:38,779 --> 00:23:42,719
this kind of brings me to this thing

477
00:23:40,769 --> 00:23:44,849
getting the strings are are everywhere

478
00:23:42,719 --> 00:23:46,979
and we're kind of wanting to fight a

479
00:23:44,849 --> 00:23:49,320
bill a bit of a battle with them and try

480
00:23:46,979 --> 00:23:51,690
to reduce their number how do you go

481
00:23:49,320 --> 00:23:53,158
about doing this and so one of the

482
00:23:51,690 --> 00:23:55,950
things I think is super fascinating

483
00:23:53,159 --> 00:23:59,749
macaca well is that it'll actually help

484
00:23:55,950 --> 00:24:04,200
you in this battle so it turns in a bit

485
00:23:59,749 --> 00:24:08,070
graph QL has a like a metadata schema

486
00:24:04,200 --> 00:24:10,919
which allows you to essentially just ask

487
00:24:08,070 --> 00:24:13,950
any end point about the data it exposes

488
00:24:10,919 --> 00:24:18,539
and the inputs it accepts and what this

489
00:24:13,950 --> 00:24:21,119
means then is that you're able to you

490
00:24:18,539 --> 00:24:26,158
know use this kind of data that comes

491
00:24:21,119 --> 00:24:28,619
back to you know go in and like query

492
00:24:26,159 --> 00:24:31,710
these you know these types look at

493
00:24:28,619 --> 00:24:33,620
relationships between data types you

494
00:24:31,710 --> 00:24:37,130
know generate diagrams

495
00:24:33,620 --> 00:24:40,179
whatever you can think of and so this is

496
00:24:37,130 --> 00:24:42,500
like for me a profoundly exciting

497
00:24:40,180 --> 00:24:45,200
thought right as someone who's kind of

498
00:24:42,500 --> 00:24:47,600
working in security at the enterprise

499
00:24:45,200 --> 00:24:50,930
level the thought that I could someday

500
00:24:47,600 --> 00:24:52,790
find myself surrounded by you know tens

501
00:24:50,930 --> 00:24:55,460
of these api's that are all

502
00:24:52,790 --> 00:24:58,510
programmatically inspectable finally wow

503
00:24:55,460 --> 00:25:02,750
this is a world that I want to live in

504
00:24:58,510 --> 00:25:06,110
so how can we put this this feature to

505
00:25:02,750 --> 00:25:09,440
use to track down these string inputs

506
00:25:06,110 --> 00:25:11,209
well I wrote a little tool just put a

507
00:25:09,440 --> 00:25:13,429
couple hours that hurt me to building a

508
00:25:11,210 --> 00:25:16,070
little tool that would do this so this

509
00:25:13,429 --> 00:25:20,809
is a real thing you can run this command

510
00:25:16,070 --> 00:25:23,389
and it's actually it should work so this

511
00:25:20,809 --> 00:25:26,149
is if you have no js' installed this

512
00:25:23,390 --> 00:25:27,650
this should be all you need and and

513
00:25:26,150 --> 00:25:31,370
basically you can point this at an

514
00:25:27,650 --> 00:25:33,980
arbitrary unauthenticated a graphical

515
00:25:31,370 --> 00:25:37,850
endpoint and it's just going to query

516
00:25:33,980 --> 00:25:41,870
the graph Google API lets get up at

517
00:25:37,850 --> 00:25:46,040
itself and print out all of the you know

518
00:25:41,870 --> 00:25:47,659
the inputs except a string so this is

519
00:25:46,040 --> 00:25:48,830
kind of a useful thing so this is the

520
00:25:47,660 --> 00:25:52,910
kind of stuff that I think really

521
00:25:48,830 --> 00:25:55,720
enables security automation you know and

522
00:25:52,910 --> 00:25:58,520
hopefully is going to lead some

523
00:25:55,720 --> 00:26:01,220
conversations with between security and

524
00:25:58,520 --> 00:26:04,520
developers so now security is able to

525
00:26:01,220 --> 00:26:08,020
show up with a little list of inputs

526
00:26:04,520 --> 00:26:11,450
that are kind of loosely defined and

527
00:26:08,020 --> 00:26:14,750
maybe propose some alternatives so what

528
00:26:11,450 --> 00:26:17,600
alternatives might we propose so one of

529
00:26:14,750 --> 00:26:19,250
them is just be more specific

530
00:26:17,600 --> 00:26:21,050
there's actually a couple of like

531
00:26:19,250 --> 00:26:24,140
there's not loads but there are a few

532
00:26:21,050 --> 00:26:26,899
types in there that are definitely a

533
00:26:24,140 --> 00:26:28,910
better choice than didn't string and

534
00:26:26,900 --> 00:26:32,570
especially in this case right we're

535
00:26:28,910 --> 00:26:35,809
accepting an ID why is that a string so

536
00:26:32,570 --> 00:26:39,189
what we're able to do is just change the

537
00:26:35,809 --> 00:26:43,580
type to like an integer at this point

538
00:26:39,190 --> 00:26:46,550
this is I really like this nothing

539
00:26:43,580 --> 00:26:49,340
changed but even with our

540
00:26:46,550 --> 00:26:53,210
vulnerable code in plates what we're

541
00:26:49,340 --> 00:26:55,310
able to do is go and test this again and

542
00:26:53,210 --> 00:26:58,310
what you can see here is starting to see

543
00:26:55,310 --> 00:27:01,100
the benefit of this syntactic viral so

544
00:26:58,310 --> 00:27:04,419
what you're looking at here is the

545
00:27:01,100 --> 00:27:09,080
rejection by on our recognizer of

546
00:27:04,420 --> 00:27:11,210
invalid input that and importantly that

547
00:27:09,080 --> 00:27:12,290
rejection happened without ever running

548
00:27:11,210 --> 00:27:15,980
our code

549
00:27:12,290 --> 00:27:18,770
so our resolver was not executed because

550
00:27:15,980 --> 00:27:21,320
graph QL itself at the recognizer level

551
00:27:18,770 --> 00:27:24,170
determined that this is valid this input

552
00:27:21,320 --> 00:27:30,050
was invalid and and this is the result

553
00:27:24,170 --> 00:27:32,570
so another another alternative that's

554
00:27:30,050 --> 00:27:35,930
really good to explore in cases where

555
00:27:32,570 --> 00:27:41,870
you have say a finite and only small

556
00:27:35,930 --> 00:27:46,250
number of values that are long-lived is

557
00:27:41,870 --> 00:27:48,739
an you know now he knows are essentially

558
00:27:46,250 --> 00:27:50,690
this so think of like a drop list or

559
00:27:48,740 --> 00:27:53,570
something there's some list of values

560
00:27:50,690 --> 00:27:56,780
that you want to sort of offer to you

561
00:27:53,570 --> 00:27:58,790
know consumers of your API you know in

562
00:27:56,780 --> 00:28:01,670
this case the values on the Left all

563
00:27:58,790 --> 00:28:04,250
caps you know I guess that's called

564
00:28:01,670 --> 00:28:07,820
screaming snake case red widget green

565
00:28:04,250 --> 00:28:10,430
widgets blue those values are going to

566
00:28:07,820 --> 00:28:14,540
be something that are now exposed to the

567
00:28:10,430 --> 00:28:17,720
API and and users can ask you for but

568
00:28:14,540 --> 00:28:20,090
you can see on the right what we're

569
00:28:17,720 --> 00:28:23,600
doing is we're providing we're mapping

570
00:28:20,090 --> 00:28:25,610
that value that's exposed publicly to an

571
00:28:23,600 --> 00:28:28,669
internal value which is the one that's

572
00:28:25,610 --> 00:28:35,449
going to show up in and be passed into

573
00:28:28,670 --> 00:28:38,120
our our resolver functions so going and

574
00:28:35,450 --> 00:28:40,580
again going back and modifying our a

575
00:28:38,120 --> 00:28:45,739
little query schema thing we can now

576
00:28:40,580 --> 00:28:48,919
take this all-caps widget edom type and

577
00:28:45,740 --> 00:28:51,560
we can just switch our argument type to

578
00:28:48,920 --> 00:28:54,160
that you can see if i've renamed ID to

579
00:28:51,560 --> 00:28:57,679
name makes a little bit more sense here

580
00:28:54,160 --> 00:28:59,870
but our vulnerable code is still in

581
00:28:57,680 --> 00:29:04,850
place so let's see what

582
00:28:59,870 --> 00:29:07,550
or what but the effect is so this is

583
00:29:04,850 --> 00:29:12,110
interesting because even if you wanted

584
00:29:07,550 --> 00:29:15,500
to like try to run that query like these

585
00:29:12,110 --> 00:29:19,100
are now the only valid queries that can

586
00:29:15,500 --> 00:29:22,190
even be accepted by graph you all all so

587
00:29:19,100 --> 00:29:25,580
kind of like 1984 and duck speak were

588
00:29:22,190 --> 00:29:29,000
like the the works everybody to use a

589
00:29:25,580 --> 00:29:31,370
language that that doesn't allow them to

590
00:29:29,000 --> 00:29:33,860
express thoughts that are sort of

591
00:29:31,370 --> 00:29:36,169
against the regime this is kind of the

592
00:29:33,860 --> 00:29:40,070
same idea you're in a situation where

593
00:29:36,170 --> 00:29:41,990
now it's not possible with with

594
00:29:40,070 --> 00:29:45,110
something like this in place to even

595
00:29:41,990 --> 00:29:48,590
formulate a malicious query anymore

596
00:29:45,110 --> 00:29:53,178
and sure enough if you use one of the

597
00:29:48,590 --> 00:29:55,760
three ballot queries you can see the dot

598
00:29:53,179 --> 00:29:59,600
mapping between our sort of all caps red

599
00:29:55,760 --> 00:30:01,790
widget and that internal value that our

600
00:29:59,600 --> 00:30:04,639
beta dash widget then it gets passed to

601
00:30:01,790 --> 00:30:06,350
our our database begin vulnerable code

602
00:30:04,640 --> 00:30:09,710
is still there it's just that it's not

603
00:30:06,350 --> 00:30:11,300
exploitable anymore so in a final

604
00:30:09,710 --> 00:30:12,920
pattern of sort of the string

605
00:30:11,300 --> 00:30:16,399
alternative pattern I'm going to propose

606
00:30:12,920 --> 00:30:18,740
you is custom scalar types now scalar

607
00:30:16,400 --> 00:30:20,570
types you know when you're purchasing

608
00:30:18,740 --> 00:30:21,350
languages and stuff you end up with this

609
00:30:20,570 --> 00:30:24,620
tree structure

610
00:30:21,350 --> 00:30:26,570
most of these kind of know it's higher

611
00:30:24,620 --> 00:30:29,719
up in the tree are going to be complex

612
00:30:26,570 --> 00:30:32,570
objects so like literally an object so

613
00:30:29,720 --> 00:30:35,480
something that's like got other objects

614
00:30:32,570 --> 00:30:38,840
inside of it and so as an array or a

615
00:30:35,480 --> 00:30:40,460
list is also one of these examples but

616
00:30:38,840 --> 00:30:43,309
down on the bottom the leaves of the

617
00:30:40,460 --> 00:30:46,460
tree why trees are upside down it comes

618
00:30:43,309 --> 00:30:49,070
your sign and said oh no the leaves of

619
00:30:46,460 --> 00:30:51,410
this tree are primitive values like a

620
00:30:49,070 --> 00:30:54,710
floating-point numbers integers and

621
00:30:51,410 --> 00:30:56,150
strings and boolean's and stuff so this

622
00:30:54,710 --> 00:30:57,620
one we're talking about scalar types

623
00:30:56,150 --> 00:31:00,490
this is what we're talking about those

624
00:30:57,620 --> 00:31:00,489
primitive types

625
00:31:00,539 --> 00:31:06,690
so one of the things that fascinates me

626
00:31:02,639 --> 00:31:10,039
about a croc koala is they they allow

627
00:31:06,690 --> 00:31:13,499
you to build your own primitives now

628
00:31:10,039 --> 00:31:16,139
people have started doing this and it's

629
00:31:13,499 --> 00:31:19,879
pretty amazing so there's a bunch of

630
00:31:16,139 --> 00:31:22,918
these scalar types for their stuff like

631
00:31:19,879 --> 00:31:26,458
people defined a skillet head for ISBN

632
00:31:22,919 --> 00:31:31,849
numbers postal codes a latitude

633
00:31:26,459 --> 00:31:34,019
longitude values ipv4 and ipv6 addresses

634
00:31:31,849 --> 00:31:36,418
you name it there's a whole bunch of

635
00:31:34,019 --> 00:31:38,190
stuff there out there so anything that

636
00:31:36,419 --> 00:31:40,229
has a reasonable structure you can you

637
00:31:38,190 --> 00:31:42,929
build a custom scaler and you can force

638
00:31:40,229 --> 00:31:45,569
people to give you exactly that and

639
00:31:42,929 --> 00:31:51,119
importantly you can enforce that on the

640
00:31:45,569 --> 00:31:54,899
way as well and this is again so so

641
00:31:51,119 --> 00:31:56,819
powerful that you can do this so that's

642
00:31:54,899 --> 00:31:59,849
it's fine that we can do it what does it

643
00:31:56,819 --> 00:32:02,879
actually look like so here's a custom

644
00:31:59,849 --> 00:32:04,829
scaler I'm going to call this the rather

645
00:32:02,879 --> 00:32:06,689
awkwardly named alphabetic string

646
00:32:04,829 --> 00:32:09,690
because it sort of seems like to

647
00:32:06,690 --> 00:32:11,099
actually exploit that seal injection

648
00:32:09,690 --> 00:32:14,249
you're gonna have to pass me some funky

649
00:32:11,099 --> 00:32:17,729
characters so how about I just make sure

650
00:32:14,249 --> 00:32:22,169
that you can only pass me normal you

651
00:32:17,729 --> 00:32:24,029
know a to Zed and and spaces and so this

652
00:32:22,169 --> 00:32:27,299
is essentially all none of this type

653
00:32:24,029 --> 00:32:28,679
does so what we're able to do then is

654
00:32:27,299 --> 00:32:32,940
the same process that they're doing

655
00:32:28,679 --> 00:32:35,249
before take our ID our argument and just

656
00:32:32,940 --> 00:32:39,869
say this and this is alphabetic string

657
00:32:35,249 --> 00:32:43,649
type so once again we're in a situation

658
00:32:39,869 --> 00:32:46,079
where we can test this type you know

659
00:32:43,649 --> 00:32:48,389
with with our little sequel injection

660
00:32:46,079 --> 00:32:54,329
input and see that this is properly

661
00:32:48,389 --> 00:32:58,349
rejected as totally invalid so with all

662
00:32:54,329 --> 00:33:01,889
that I guess I want to point out the

663
00:32:58,349 --> 00:33:05,218
fact that like the 9sec view of the

664
00:33:01,889 --> 00:33:07,708
world of security their their assertion

665
00:33:05,219 --> 00:33:10,559
is that the existence of all of these

666
00:33:07,709 --> 00:33:12,989
exploitable bugs the the sort of that

667
00:33:10,559 --> 00:33:13,800
continues punish that we all see all are

668
00:33:12,989 --> 00:33:16,800
Emma's

669
00:33:13,800 --> 00:33:21,570
is a consequence of software designs

670
00:33:16,800 --> 00:33:26,220
that make input handling really it's not

671
00:33:21,570 --> 00:33:30,750
not rigorous rears enough and so for me

672
00:33:26,220 --> 00:33:34,080
graph QL is like are super fascinating

673
00:33:30,750 --> 00:33:37,170
technology because it democratizes a lot

674
00:33:34,080 --> 00:33:39,960
of patterns that were basically only

675
00:33:37,170 --> 00:33:44,250
accessible to using super well funded

676
00:33:39,960 --> 00:33:46,200
project with astonishingly brilliant you

677
00:33:44,250 --> 00:33:49,890
know computer scientists working on them

678
00:33:46,200 --> 00:33:52,440
so the fact that this these patterns are

679
00:33:49,890 --> 00:33:57,090
available for the rest of us now is is

680
00:33:52,440 --> 00:33:59,130
super exciting so we thought I want to

681
00:33:57,090 --> 00:34:01,139
point out here that this is like graph

682
00:33:59,130 --> 00:34:04,200
QL has given you these patterns this

683
00:34:01,140 --> 00:34:07,830
these patterns are now the tons of steel

684
00:34:04,200 --> 00:34:09,690
of the employed handling but but making

685
00:34:07,830 --> 00:34:12,179
the most of this you were going to have

686
00:34:09,690 --> 00:34:14,820
to learn the length x the the lessons

687
00:34:12,179 --> 00:34:19,520
lengths that has to teach you and so

688
00:34:14,820 --> 00:34:19,520
with that that is what I have

689
00:34:39,770 --> 00:34:49,409
thank you very much for that Mike that

690
00:34:43,530 --> 00:34:52,710
was excellent one question that we have

691
00:34:49,409 --> 00:34:57,359
right now is for a team that's you know

692
00:34:52,710 --> 00:34:59,430
a traditional rest api type team well it

693
00:34:57,360 --> 00:35:01,950
would be a really good way to start

694
00:34:59,430 --> 00:35:03,600
testing the waters in graph humility and

695
00:35:01,950 --> 00:35:07,200
Lang say well it would be a good place

696
00:35:03,600 --> 00:35:11,339
to start applying this if we're thinking

697
00:35:07,200 --> 00:35:16,230
about the normal nice rest api type of

698
00:35:11,340 --> 00:35:17,400
approach for sure so I guess one of the

699
00:35:16,230 --> 00:35:21,710
things I think that's super interesting

700
00:35:17,400 --> 00:35:24,330
is that essentially this idea that a

701
00:35:21,710 --> 00:35:26,910
curriculum has no opinion about what

702
00:35:24,330 --> 00:35:29,640
actually goes on in these resolvers so

703
00:35:26,910 --> 00:35:31,379
if you were just to say look I'm gonna

704
00:35:29,640 --> 00:35:34,020
stand up a little graphic you all API

705
00:35:31,380 --> 00:35:35,760
and you know what I'm gonna just do the

706
00:35:34,020 --> 00:35:38,630
input checking and then I'm gonna call

707
00:35:35,760 --> 00:35:41,430
the REST API this is totally legit

708
00:35:38,630 --> 00:35:44,450
and there's actually projects where

709
00:35:41,430 --> 00:35:47,970
people have sort of started generating

710
00:35:44,450 --> 00:35:50,100
REST API is from graph QL and even the

711
00:35:47,970 --> 00:35:54,450
reverse or you can generate graphical it

712
00:35:50,100 --> 00:35:56,250
goes from rest it's it's kind of a crazy

713
00:35:54,450 --> 00:35:58,049
roll but it's really really cool what

714
00:35:56,250 --> 00:35:59,340
they're doing and I think that's the

715
00:35:58,050 --> 00:36:03,120
thing if I wanted to get my feet wet

716
00:35:59,340 --> 00:36:04,860
with you know with this kind of stuff

717
00:36:03,120 --> 00:36:08,190
and and bringing this kind of rigorous

718
00:36:04,860 --> 00:36:09,780
input checking into you know my project

719
00:36:08,190 --> 00:36:12,300
and experiment with it I think that'd be

720
00:36:09,780 --> 00:36:15,630
the way to go is sort of see I think

721
00:36:12,300 --> 00:36:19,950
it's so good so for Jas or something

722
00:36:15,630 --> 00:36:22,050
like that so it's it's an interesting

723
00:36:19,950 --> 00:36:24,629
product to be able to Jerry kind of one

724
00:36:22,050 --> 00:36:27,410
one type of API from then next but it

725
00:36:24,630 --> 00:36:30,930
could be just as simple as you know

726
00:36:27,410 --> 00:36:37,080
wrapping your existing API and in the

727
00:36:30,930 --> 00:36:38,790
resolver calling it okay funny enough

728
00:36:37,080 --> 00:36:41,549
the next question is basically the

729
00:36:38,790 --> 00:36:44,400
inverse of it when would be a good time

730
00:36:41,550 --> 00:36:46,690
when would be a good time to not use the

731
00:36:44,400 --> 00:36:49,690
graph QL API

732
00:36:46,690 --> 00:36:55,500
so I think that that's an actually cool

733
00:36:49,690 --> 00:37:00,400
question so here's I I guess if you have

734
00:36:55,500 --> 00:37:02,590
if you're in a situation where it's

735
00:37:00,400 --> 00:37:05,710
difficult to be specific about inputs

736
00:37:02,590 --> 00:37:08,980
that's a bad place to be but nonetheless

737
00:37:05,710 --> 00:37:12,990
there's reality sometimes I sometimes

738
00:37:08,980 --> 00:37:16,510
it's hard so you know this can be a

739
00:37:12,990 --> 00:37:18,910
difficult thing um I think for me

740
00:37:16,510 --> 00:37:21,730
there's a lot of if you if you wait it

741
00:37:18,910 --> 00:37:23,259
to some of the gradual stuff online

742
00:37:21,730 --> 00:37:26,200
you'll see there's endless endless

743
00:37:23,260 --> 00:37:29,110
debates around sort of rest for spells

744
00:37:26,200 --> 00:37:34,960
it's like comparing these things I think

745
00:37:29,110 --> 00:37:38,440
for me what gets lost in there is is the

746
00:37:34,960 --> 00:37:40,510
the what I see is like a brand new kind

747
00:37:38,440 --> 00:37:43,000
of security primitive this is a new way

748
00:37:40,510 --> 00:37:45,220
to do a level of input checking and

749
00:37:43,000 --> 00:37:48,730
handling that we've never really had

750
00:37:45,220 --> 00:37:51,700
before and so sort of comparing it with

751
00:37:48,730 --> 00:37:54,700
rest I mean if you only think of it as

752
00:37:51,700 --> 00:37:56,850
an API yeah maybe these trade-offs are

753
00:37:54,700 --> 00:38:03,009
you know you can kind of kick it around

754
00:37:56,850 --> 00:38:07,180
you know but I think one of the thing is

755
00:38:03,010 --> 00:38:09,970
though there's no there's not really a

756
00:38:07,180 --> 00:38:15,270
substitute to like the level of input

757
00:38:09,970 --> 00:38:19,480
checking this provides so I think

758
00:38:15,270 --> 00:38:22,930
there's probably moments where you you

759
00:38:19,480 --> 00:38:26,340
would find it a hard fit but I think the

760
00:38:22,930 --> 00:38:29,140
in protecting is what I'm after

761
00:38:26,340 --> 00:38:35,500
and so I'll try and make it fit where I

762
00:38:29,140 --> 00:38:36,190
can I don't know it does one more

763
00:38:35,500 --> 00:38:39,400
question

764
00:38:36,190 --> 00:38:41,980
can you elaborate on the introspection

765
00:38:39,400 --> 00:38:47,500
query and how that's useful from a

766
00:38:41,980 --> 00:38:51,040
security standpoint cool so that is an

767
00:38:47,500 --> 00:38:53,740
awesome question so did that kind of

768
00:38:51,040 --> 00:38:55,509
introspection capability I think makes a

769
00:38:53,740 --> 00:39:00,520
lot of security people deeply

770
00:38:55,510 --> 00:39:03,520
uncomfortable it is I mean it's

771
00:39:00,520 --> 00:39:05,380
just saying what's available right like

772
00:39:03,520 --> 00:39:07,900
you're all the types and all the inputs

773
00:39:05,380 --> 00:39:09,160
and all this stuff and this just gives a

774
00:39:07,900 --> 00:39:10,510
lot of security people the

775
00:39:09,160 --> 00:39:13,839
heebie-jeebies right like they just

776
00:39:10,510 --> 00:39:18,940
don't want that much information about

777
00:39:13,840 --> 00:39:22,930
their systems that accessible and so the

778
00:39:18,940 --> 00:39:25,690
introspection query I think for me is I

779
00:39:22,930 --> 00:39:27,100
like once you sort of are familiar with

780
00:39:25,690 --> 00:39:30,400
their kind of the plumbing and the power

781
00:39:27,100 --> 00:39:32,830
that actually gives you I'm personally

782
00:39:30,400 --> 00:39:34,900
pretty comfortable the idea of like well

783
00:39:32,830 --> 00:39:36,580
I you know I'm going to make sure that

784
00:39:34,900 --> 00:39:41,590
through this stringent input checking

785
00:39:36,580 --> 00:39:43,770
that I can only accept values that I'm

786
00:39:41,590 --> 00:39:46,680
absolutely sure about and that are like

787
00:39:43,770 --> 00:39:51,910
no matter how naive my code is

788
00:39:46,680 --> 00:39:54,310
internally assumptions won't be violated

789
00:39:51,910 --> 00:40:00,879
because the type system will not allow a

790
00:39:54,310 --> 00:40:03,700
value that will surprise me I think if

791
00:40:00,880 --> 00:40:07,330
you've done that work having people

792
00:40:03,700 --> 00:40:09,189
being able to introspect on your on your

793
00:40:07,330 --> 00:40:11,529
service I think is astonishingly

794
00:40:09,190 --> 00:40:15,340
powerful and the kind of thing that when

795
00:40:11,530 --> 00:40:16,990
you start thinking about like you know

796
00:40:15,340 --> 00:40:19,270
you're going to be surrounded by dozens

797
00:40:16,990 --> 00:40:22,810
or hundreds of systems in a big

798
00:40:19,270 --> 00:40:25,240
organization anyway to be able to just

799
00:40:22,810 --> 00:40:26,980
ask them from the outside without

800
00:40:25,240 --> 00:40:29,859
getting all up in their business you

801
00:40:26,980 --> 00:40:32,320
know for ask them from the outside hey

802
00:40:29,860 --> 00:40:34,930
what are you capable of what inputs do

803
00:40:32,320 --> 00:40:37,750
you accept this is like this this is a

804
00:40:34,930 --> 00:40:39,129
magnificent thing so I've to me the

805
00:40:37,750 --> 00:40:40,840
introspection query is the key to

806
00:40:39,130 --> 00:40:49,560
unlocking a lot of those sort of

807
00:40:40,840 --> 00:40:51,960
security automation stuff perfect

808
00:40:49,560 --> 00:40:54,299
thank you so much for taking the time of

809
00:40:51,960 --> 00:40:57,329
your day to come present to us here and

810
00:40:54,300 --> 00:40:59,460
we really appreciate it I just also want

811
00:40:57,329 --> 00:41:01,410
to make a reminder to everyone that the

812
00:40:59,460 --> 00:41:04,319
security innovation CTF is still going

813
00:41:01,410 --> 00:41:06,420
on it will be going until five o'clock

814
00:41:04,319 --> 00:41:09,180
tonight as far as prizes are concerned

815
00:41:06,420 --> 00:41:12,420
that's the cutoff to win a prize however

816
00:41:09,180 --> 00:41:14,430
it will keep going until 6:00 tomorrow I

817
00:41:12,420 --> 00:41:17,040
believe 6 p.m. so you can continue to

818
00:41:14,430 --> 00:41:19,200
hack away try stuff out use what you've

819
00:41:17,040 --> 00:41:21,480
learned in other sessions and you know

820
00:41:19,200 --> 00:41:23,939
have fun with it

821
00:41:21,480 --> 00:41:25,109
also next we're going to have a about a

822
00:41:23,940 --> 00:41:27,359
15 minute break then we're gonna have

823
00:41:25,109 --> 00:41:30,540
Eric Conrad come and talk about threat

824
00:41:27,359 --> 00:41:32,839
hunting with DNS so stay tuned and we'll

825
00:41:30,540 --> 00:41:32,839
be back shortly

