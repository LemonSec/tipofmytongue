1
00:00:00,560 --> 00:00:02,080
good morning everyone this is breaking

2
00:00:02,080 --> 00:00:04,240
ground so you want to build a c2 uh

3
00:00:04,240 --> 00:00:05,600
before we kick off a few quick

4
00:00:05,600 --> 00:00:07,359
announcements as always like to thank

5
00:00:07,359 --> 00:00:08,960
our sponsors especially our diamond

6
00:00:08,960 --> 00:00:11,759
sponsors lastpass and palo alto networks

7
00:00:11,759 --> 00:00:14,400
gold sponsors intel google blue cat uh

8
00:00:14,400 --> 00:00:15,679
it's their support that makes this event

9
00:00:15,679 --> 00:00:17,760
possible uh because we are being

10
00:00:17,760 --> 00:00:19,840
streamed live please turn off your cell

11
00:00:19,840 --> 00:00:22,320
phones we do not have audience bikes in

12
00:00:22,320 --> 00:00:24,400
this room so raise your hand high after

13
00:00:24,400 --> 00:00:26,480
the talk and we will call on you

14
00:00:26,480 --> 00:00:28,880
uh and lastly uh just a reminder photo

15
00:00:28,880 --> 00:00:31,359
policy does not allow taking photos of

16
00:00:31,359 --> 00:00:33,360
other attendees and math should be kept

17
00:00:33,360 --> 00:00:35,120
on at all times with that please welcome

18
00:00:35,120 --> 00:00:37,599
i digital

19
00:00:42,840 --> 00:00:45,680
fan good morning everybody or afternoon

20
00:00:45,680 --> 00:00:47,680
as it feels like to me honestly uh

21
00:00:47,680 --> 00:00:50,800
welcome so so you want to build a c2

22
00:00:50,800 --> 00:00:52,800
um so i'm going to talk about some crazy

23
00:00:52,800 --> 00:00:55,360
stuff that went through uh me building a

24
00:00:55,360 --> 00:00:57,920
c2 that is fully in use today kind of

25
00:00:57,920 --> 00:00:59,440
actually in the current ctf that's

26
00:00:59,440 --> 00:01:02,800
literally running right next door to us

27
00:01:05,119 --> 00:01:06,720
okay cool so give a little bit of

28
00:01:06,720 --> 00:01:08,880
background to myself um obviously i'm a

29
00:01:08,880 --> 00:01:11,200
security guy i love to program i love

30
00:01:11,200 --> 00:01:12,560
linux a lot

31
00:01:12,560 --> 00:01:15,439
i love windows really because i've been

32
00:01:15,439 --> 00:01:17,920
forced a lot of my life to work on it

33
00:01:17,920 --> 00:01:20,560
i'm creator of too many projects account

34
00:01:20,560 --> 00:01:22,720
and at my day job i kind of do more

35
00:01:22,720 --> 00:01:24,640
social security architecture stuff some

36
00:01:24,640 --> 00:01:27,360
offensive purple teaming things and i do

37
00:01:27,360 --> 00:01:29,759
a lot of work for prosv joe's so mainly

38
00:01:29,759 --> 00:01:32,079
i do a lot of work with the red team as

39
00:01:32,079 --> 00:01:33,200
you can see

40
00:01:33,200 --> 00:01:35,280
but also i do a lot of work with the

41
00:01:35,280 --> 00:01:36,960
gold team maintaining

42
00:01:36,960 --> 00:01:38,560
infrastructure and architecture and kind

43
00:01:38,560 --> 00:01:40,159
of doing system administration stuff

44
00:01:40,159 --> 00:01:42,400
there

45
00:01:43,280 --> 00:01:45,759
so stupid beginnings as i say every

46
00:01:45,759 --> 00:01:49,119
project starts with a stupid idea

47
00:01:49,119 --> 00:01:51,119
so we're going to take take us back to

48
00:01:51,119 --> 00:01:54,320
2011 the dark ages of java a long time

49
00:01:54,320 --> 00:01:56,399
ago when i started college i was

50
00:01:56,399 --> 00:01:57,840
learning java as one of the programming

51
00:01:57,840 --> 00:01:59,520
languages you know in my stack that i

52
00:01:59,520 --> 00:02:01,840
know today and you know they say kind of

53
00:02:01,840 --> 00:02:03,920
laziness breeds innovation i kind of

54
00:02:03,920 --> 00:02:05,680
feel like it more breeds stupidity at

55
00:02:05,680 --> 00:02:07,439
least myself

56
00:02:07,439 --> 00:02:09,280
me being me i was really lazy and i

57
00:02:09,280 --> 00:02:11,120
wanted to encrypt data at rest and i

58
00:02:11,120 --> 00:02:12,720
looked at the implementation of aes in

59
00:02:12,720 --> 00:02:15,200
java and i said no screw that i don't

60
00:02:15,200 --> 00:02:17,200
want to do that that's too much so you

61
00:02:17,200 --> 00:02:18,480
know what i did i did the best thing

62
00:02:18,480 --> 00:02:20,800
possible i rolled my own crypto

63
00:02:20,800 --> 00:02:23,520
don't do that um it led to it's uh led

64
00:02:23,520 --> 00:02:25,840
to the invention of cbk which is a sort

65
00:02:25,840 --> 00:02:28,000
of lazy man's encryption um it stands

66
00:02:28,000 --> 00:02:30,239
for cipher block key it's like some like

67
00:02:30,239 --> 00:02:32,720
uh round cipher thing it's probably

68
00:02:32,720 --> 00:02:34,720
super duper insecure

69
00:02:34,720 --> 00:02:38,160
but i still listed on github

70
00:02:38,160 --> 00:02:41,280
so kind of going forward now um now it's

71
00:02:41,280 --> 00:02:44,160
like 2017. i started learning going uh

72
00:02:44,160 --> 00:02:46,640
because my work kind of wanted me to

73
00:02:46,640 --> 00:02:48,959
develop some projects that were kind of

74
00:02:48,959 --> 00:02:51,680
uh architecture and os independent so

75
00:02:51,680 --> 00:02:53,200
the the language at the time really to

76
00:02:53,200 --> 00:02:55,680
learn was go and i was like awesome so

77
00:02:55,680 --> 00:02:57,599
me being myself a person who kind of

78
00:02:57,599 --> 00:02:59,280
learns by doing i really needed a

79
00:02:59,280 --> 00:03:00,959
project to learn i needed something to

80
00:03:00,959 --> 00:03:03,040
do outside of my job like kind of the

81
00:03:03,040 --> 00:03:04,959
things i needed to do because i wanted

82
00:03:04,959 --> 00:03:07,040
to like dive into the actual stuff that

83
00:03:07,040 --> 00:03:09,760
go kind of provides so what i did is i

84
00:03:09,760 --> 00:03:12,480
revisited some old projects to rewrite

85
00:03:12,480 --> 00:03:15,120
um i ended up actually looking to cbk to

86
00:03:15,120 --> 00:03:16,959
rewrite i was like you know can i make

87
00:03:16,959 --> 00:03:19,040
this crap code run faster completely

88
00:03:19,040 --> 00:03:22,480
forgetting it's super insecure

89
00:03:22,480 --> 00:03:26,000
so uh we'll get to where that

90
00:03:26,000 --> 00:03:28,480
comes in but um so

91
00:03:28,480 --> 00:03:30,239
at the time currently i was doing a lot

92
00:03:30,239 --> 00:03:32,400
of red team development as well as most

93
00:03:32,400 --> 00:03:34,400
of my life in cyber security i was doing

94
00:03:34,400 --> 00:03:37,440
basically offensive stuff um now the

95
00:03:37,440 --> 00:03:38,640
thing was is

96
00:03:38,640 --> 00:03:40,080
while doing all this i never really

97
00:03:40,080 --> 00:03:42,239
found a tool that like worked correctly

98
00:03:42,239 --> 00:03:44,400
that really fit the needs that i wanted

99
00:03:44,400 --> 00:03:46,159
there was things that were missing like

100
00:03:46,159 --> 00:03:48,000
there were workarounds you had to do and

101
00:03:48,000 --> 00:03:50,159
they were like super clunky um things

102
00:03:50,159 --> 00:03:52,640
could be dependency heavy or you know

103
00:03:52,640 --> 00:03:55,439
the setup was like super annoying so you

104
00:03:55,439 --> 00:03:56,879
know that actually led me to a lot of

105
00:03:56,879 --> 00:03:59,040
the tools that i've you know built today

106
00:03:59,040 --> 00:04:01,120
there are some super c2-ish things that

107
00:04:01,120 --> 00:04:03,519
i've made like ws bind there's some like

108
00:04:03,519 --> 00:04:05,519
exploits and things i developed some of

109
00:04:05,519 --> 00:04:06,640
the things i've already previously

110
00:04:06,640 --> 00:04:08,400
talked on like in your mems which is a

111
00:04:08,400 --> 00:04:10,959
talk on antivirus evasion i've also made

112
00:04:10,959 --> 00:04:12,799
some utilities and i also made some

113
00:04:12,799 --> 00:04:14,080
stuff like kind of for trolling and

114
00:04:14,080 --> 00:04:16,798
shits and giggles realistically

115
00:04:16,798 --> 00:04:17,519
so

116
00:04:17,519 --> 00:04:20,639
that all leads to xmt xmt stands for the

117
00:04:20,639 --> 00:04:23,600
extensible malware toolkit

118
00:04:23,600 --> 00:04:26,160
so you might be asking what is xmt xmt

119
00:04:26,160 --> 00:04:28,240
is an offensive security framework it

120
00:04:28,240 --> 00:04:30,720
does a lot of malicious things really

121
00:04:30,720 --> 00:04:32,560
well and i say malicious things i mean

122
00:04:32,560 --> 00:04:34,479
like anything the miter attack framework

123
00:04:34,479 --> 00:04:37,120
may cover like you know dll injection

124
00:04:37,120 --> 00:04:39,520
assembly injection um you know processed

125
00:04:39,520 --> 00:04:44,080
doppelganging etc um and it provides c2

126
00:04:44,080 --> 00:04:45,840
functionality and the only thing that's

127
00:04:45,840 --> 00:04:47,360
missing from that c2 functionality

128
00:04:47,360 --> 00:04:49,680
honestly is a user interface and what i

129
00:04:49,680 --> 00:04:51,520
mean by that is there's no button i can

130
00:04:51,520 --> 00:04:53,840
click to say do this i'd have to script

131
00:04:53,840 --> 00:04:55,440
all that out but everything else is

132
00:04:55,440 --> 00:04:57,040
still there

133
00:04:57,040 --> 00:04:59,120
the one cool thing that i made this with

134
00:04:59,120 --> 00:05:01,280
and i like an idea with is that it can

135
00:05:01,280 --> 00:05:03,280
be extended for any purpose so i leave a

136
00:05:03,280 --> 00:05:06,000
lot of room for users to input functions

137
00:05:06,000 --> 00:05:08,400
to change how it works to add things to

138
00:05:08,400 --> 00:05:10,880
extend functionality there's pretty much

139
00:05:10,880 --> 00:05:12,639
like anything you can extend it to like

140
00:05:12,639 --> 00:05:13,919
anything that really you can put your

141
00:05:13,919 --> 00:05:15,280
mind to encode

142
00:05:15,280 --> 00:05:17,360
uh the one good thing about it it's

143
00:05:17,360 --> 00:05:18,960
since it's go it's multi-platform

144
00:05:18,960 --> 00:05:20,880
multi-operating system so i've actually

145
00:05:20,880 --> 00:05:22,479
took some time to make sure that it

146
00:05:22,479 --> 00:05:24,720
supports and it works on every operating

147
00:05:24,720 --> 00:05:26,880
system and every os that golang

148
00:05:26,880 --> 00:05:28,960
currently supports in mainline

149
00:05:28,960 --> 00:05:31,280
but however sorry

150
00:05:31,280 --> 00:05:33,039
but however it's currently windows

151
00:05:33,039 --> 00:05:34,960
favored so meaning like a lot of the

152
00:05:34,960 --> 00:05:37,199
kind of the toys and the cool things in

153
00:05:37,199 --> 00:05:39,680
windows uh that it does support really

154
00:05:39,680 --> 00:05:41,199
only work on windows at the moment i'm

155
00:05:41,199 --> 00:05:43,199
adding some linux support as i go but

156
00:05:43,199 --> 00:05:44,960
some of those are kind of hard to do one

157
00:05:44,960 --> 00:05:46,080
to one

158
00:05:46,080 --> 00:05:48,880
and uh currently on the picture on the

159
00:05:48,880 --> 00:05:50,320
right well it's on

160
00:05:50,320 --> 00:05:53,360
kind of my right um that's the status of

161
00:05:53,360 --> 00:05:55,120
the repo as it is right now and

162
00:05:55,120 --> 00:05:58,240
currently we're at 32 000 lines uh as we

163
00:05:58,240 --> 00:06:00,560
speak

164
00:06:00,720 --> 00:06:02,720
so what did i want in xmd when i was

165
00:06:02,720 --> 00:06:04,560
developing it i kind of wanted to be

166
00:06:04,560 --> 00:06:06,639
easy to use i want it to be modular

167
00:06:06,639 --> 00:06:09,199
flexible i want to be simple at the same

168
00:06:09,199 --> 00:06:10,880
time so i wanted something to be you

169
00:06:10,880 --> 00:06:13,120
know configurable to an extent where it

170
00:06:13,120 --> 00:06:15,120
works out the box but also i could you

171
00:06:15,120 --> 00:06:17,520
know kind of change up how it works i

172
00:06:17,520 --> 00:06:19,120
wanted things to be

173
00:06:19,120 --> 00:06:20,560
not dependency heavy so i didn't want to

174
00:06:20,560 --> 00:06:22,080
rely on a lot of things

175
00:06:22,080 --> 00:06:23,840
and i also wanted to have a small build

176
00:06:23,840 --> 00:06:25,199
footprint you know i shouldn't have to

177
00:06:25,199 --> 00:06:27,199
spend time building my implants i should

178
00:06:27,199 --> 00:06:29,199
spend more time like popping boxes and

179
00:06:29,199 --> 00:06:32,000
throwing shells

180
00:06:32,560 --> 00:06:34,800
so kind of giving a quick list of the

181
00:06:34,800 --> 00:06:36,319
things that make up xmc i know it's a

182
00:06:36,319 --> 00:06:39,759
lot uh we have the overlying c2 package

183
00:06:39,759 --> 00:06:41,360
which contains like most of the c2

184
00:06:41,360 --> 00:06:42,319
functions

185
00:06:42,319 --> 00:06:44,000
uh config transform wrapper we will

186
00:06:44,000 --> 00:06:46,319
actually talk about in the next slides

187
00:06:46,319 --> 00:06:48,800
uh there is also the task package which

188
00:06:48,800 --> 00:06:49,919
doesn't really make a super big

189
00:06:49,919 --> 00:06:51,199
appearance but it basically handles

190
00:06:51,199 --> 00:06:53,280
everything when it comes to tasking or

191
00:06:53,280 --> 00:06:55,120
uh you know if you want to create custom

192
00:06:55,120 --> 00:06:56,800
tasks for xmt to do

193
00:06:56,800 --> 00:06:58,319
then you have the cmd library which

194
00:06:58,319 --> 00:07:00,479
contains everything executable so like

195
00:07:00,479 --> 00:07:03,039
literally anything dsls assembly um you

196
00:07:03,039 --> 00:07:04,160
know etc

197
00:07:04,160 --> 00:07:06,319
uh the filter library the subpackage

198
00:07:06,319 --> 00:07:09,120
filter under it contains the cool filter

199
00:07:09,120 --> 00:07:11,520
um struct that we can use to literally

200
00:07:11,520 --> 00:07:13,599
select processes that we want to target

201
00:07:13,599 --> 00:07:15,199
so we can set parent processes or

202
00:07:15,199 --> 00:07:17,599
processes that own are like assembly or

203
00:07:17,599 --> 00:07:19,680
a dll et cetera and we have like cool

204
00:07:19,680 --> 00:07:21,199
things like setting the parent uh

205
00:07:21,199 --> 00:07:22,960
setting if it's like executable it's in

206
00:07:22,960 --> 00:07:25,840
a session or it's a service um like

207
00:07:25,840 --> 00:07:28,000
excluded processes etc then we have our

208
00:07:28,000 --> 00:07:29,440
communication library which contains

209
00:07:29,440 --> 00:07:31,039
most of our communication privilege uh

210
00:07:31,039 --> 00:07:33,280
primitives the limits library puts guard

211
00:07:33,280 --> 00:07:34,960
rails around some of the things we can

212
00:07:34,960 --> 00:07:35,759
do

213
00:07:35,759 --> 00:07:38,000
which is kind of cool then we have the

214
00:07:38,000 --> 00:07:41,120
pipe package which is actually a

215
00:07:41,120 --> 00:07:44,400
it's before the golang implemented

216
00:07:44,400 --> 00:07:46,240
name pipes and it's sublet it's standard

217
00:07:46,240 --> 00:07:48,479
library but this actually supports linux

218
00:07:48,479 --> 00:07:50,080
and windows and it supports setting

219
00:07:50,080 --> 00:07:51,520
security permissions on your pipes as

220
00:07:51,520 --> 00:07:52,879
well so you can do a lot more cool

221
00:07:52,879 --> 00:07:54,560
things with it

222
00:07:54,560 --> 00:07:58,639
wc2 is my own version of a web c2 are

223
00:07:58,639 --> 00:08:00,560
basically connections over http and

224
00:08:00,560 --> 00:08:02,720
we'll actually get into that as well

225
00:08:02,720 --> 00:08:04,879
data is just a package allows the right

226
00:08:04,879 --> 00:08:06,639
uh data primitives like any golang

227
00:08:06,639 --> 00:08:08,319
primitive it contains some like cool

228
00:08:08,319 --> 00:08:10,400
really util helper functions including

229
00:08:10,400 --> 00:08:13,039
some like memory buffers and such crypto

230
00:08:13,039 --> 00:08:14,479
same it's just some more cryptographic

231
00:08:14,479 --> 00:08:16,560
operation things

232
00:08:16,560 --> 00:08:18,000
device is actually one of the coolest

233
00:08:18,000 --> 00:08:19,599
packages and one of the largest it

234
00:08:19,599 --> 00:08:20,879
contains basically everything from

235
00:08:20,879 --> 00:08:22,319
interfacing directly with the device

236
00:08:22,319 --> 00:08:23,360
we're on

237
00:08:23,360 --> 00:08:24,960
so we have the evade package which does

238
00:08:24,960 --> 00:08:27,039
like defense evasion some other things

239
00:08:27,039 --> 00:08:28,879
like overriding hooks that might be

240
00:08:28,879 --> 00:08:31,120
placed in us by antivirus

241
00:08:31,120 --> 00:08:32,559
we have a local package that deals with

242
00:08:32,559 --> 00:08:34,080
identifying and detecting things on a

243
00:08:34,080 --> 00:08:35,360
local host

244
00:08:35,360 --> 00:08:36,799
we have the regedit package which is a

245
00:08:36,799 --> 00:08:38,240
high level interface for the windows

246
00:08:38,240 --> 00:08:39,760
registry

247
00:08:39,760 --> 00:08:41,519
then we have one api the window api

248
00:08:41,519 --> 00:08:43,839
registry and window api service when api

249
00:08:43,839 --> 00:08:45,519
is actually my own rewrite of the

250
00:08:45,519 --> 00:08:47,440
windows or the standard library windows

251
00:08:47,440 --> 00:08:49,279
package for golang and we'll talk about

252
00:08:49,279 --> 00:08:50,240
that one

253
00:08:50,240 --> 00:08:51,600
the registry package under is the same

254
00:08:51,600 --> 00:08:53,839
thing it's my rewrite of the golang

255
00:08:53,839 --> 00:08:56,480
register package and service is also

256
00:08:56,480 --> 00:08:58,959
again a rewrite

257
00:08:58,959 --> 00:09:02,160
man is the home of guardian and sentinel

258
00:09:02,160 --> 00:09:05,920
guardian is our sentinel is a loader for

259
00:09:05,920 --> 00:09:07,760
xmt and allows you to basically load it

260
00:09:07,760 --> 00:09:09,519
into like any process debate based on

261
00:09:09,519 --> 00:09:10,959
your rule settings like load it from

262
00:09:10,959 --> 00:09:13,279
like a http endpoint from a dll from a

263
00:09:13,279 --> 00:09:14,880
file and disk whatever

264
00:09:14,880 --> 00:09:16,399
guardian allows you to keep a singleton

265
00:09:16,399 --> 00:09:18,240
instance running current currently on

266
00:09:18,240 --> 00:09:19,760
the device and it will keep that

267
00:09:19,760 --> 00:09:21,920
instance regardless of you know what

268
00:09:21,920 --> 00:09:23,680
persistent mechanism you use so you're

269
00:09:23,680 --> 00:09:25,120
not like actually running a thousand

270
00:09:25,120 --> 00:09:27,279
implants on a host

271
00:09:27,279 --> 00:09:28,959
lastly of util it's just like a basic

272
00:09:28,959 --> 00:09:31,120
utilities directory uh contains some

273
00:09:31,120 --> 00:09:32,640
things we'll get into x error because

274
00:09:32,640 --> 00:09:34,720
it's a custom implementation of

275
00:09:34,720 --> 00:09:36,560
the errors package you go it does some

276
00:09:36,560 --> 00:09:38,959
really cool stuff that we'll get into

277
00:09:38,959 --> 00:09:40,640
bug tracks is a debugging library that

278
00:09:40,640 --> 00:09:43,200
allows uh you to to kind of log you know

279
00:09:43,200 --> 00:09:45,440
if the process crashes or anything super

280
00:09:45,440 --> 00:09:47,040
helpful

281
00:09:47,040 --> 00:09:50,640
text also contains a red regex free

282
00:09:50,640 --> 00:09:53,279
uh text matching algorithm and uh

283
00:09:53,279 --> 00:09:55,440
basically uh parser so you can do like

284
00:09:55,440 --> 00:09:56,720
some really cool textual expressions

285
00:09:56,720 --> 00:09:58,480
without all the bloat that the regex

286
00:09:58,480 --> 00:10:00,560
package in golang provides

287
00:10:00,560 --> 00:10:01,920
lastly we have crypt and i will talk

288
00:10:01,920 --> 00:10:03,360
about crypt in a little bit it's a sort

289
00:10:03,360 --> 00:10:05,200
of textual cryptographic helper that

290
00:10:05,200 --> 00:10:06,720
we'll get into that allows you to do

291
00:10:06,720 --> 00:10:09,519
defensive asian

292
00:10:09,680 --> 00:10:12,000
so i know that was a really long thing

293
00:10:12,000 --> 00:10:13,920
but i want to highlight now some of the

294
00:10:13,920 --> 00:10:15,360
things that actually and some of the

295
00:10:15,360 --> 00:10:16,480
interesting things that are actually

296
00:10:16,480 --> 00:10:19,839
take part into xmt itself

297
00:10:20,240 --> 00:10:21,680
so one of the first things if you're

298
00:10:21,680 --> 00:10:23,760
developing a c2 is identification it's

299
00:10:23,760 --> 00:10:25,680
like one of the most important things

300
00:10:25,680 --> 00:10:27,760
basically it's the process of getting to

301
00:10:27,760 --> 00:10:29,360
know our host device so it might be like

302
00:10:29,360 --> 00:10:32,480
the os version the architecture um the

303
00:10:32,480 --> 00:10:34,640
you know interfaces uh which and ip

304
00:10:34,640 --> 00:10:36,240
addresses it may have

305
00:10:36,240 --> 00:10:38,079
then also is basically generating unique

306
00:10:38,079 --> 00:10:39,519
identifiers that are unique to that host

307
00:10:39,519 --> 00:10:41,680
specifically as well as any environment

308
00:10:41,680 --> 00:10:44,240
info so like the username the domain it

309
00:10:44,240 --> 00:10:46,079
may be running under if it's windows and

310
00:10:46,079 --> 00:10:47,440
like your basic process and parent

311
00:10:47,440 --> 00:10:50,000
process id values for example

312
00:10:50,000 --> 00:10:51,920
and what this actually led me to is we

313
00:10:51,920 --> 00:10:54,480
ended up having to uh

314
00:10:54,480 --> 00:10:57,680
create our own ud uid library we

315
00:10:57,680 --> 00:11:00,480
originally used the machine id library

316
00:11:00,480 --> 00:11:02,079
but it seems it's abandoned now since

317
00:11:02,079 --> 00:11:05,360
like 2019 and unmaintained so we created

318
00:11:05,360 --> 00:11:06,959
our own which actually used some a

319
00:11:06,959 --> 00:11:08,800
little bit cooler features

320
00:11:08,800 --> 00:11:10,000
and used

321
00:11:10,000 --> 00:11:11,760
a better identification system in

322
00:11:11,760 --> 00:11:13,839
windows such as using the system sid

323
00:11:13,839 --> 00:11:15,839
instead of like the cryptographic hash

324
00:11:15,839 --> 00:11:18,079
of windows which doesn't change as much

325
00:11:18,079 --> 00:11:19,360
compared and is actually a little bit

326
00:11:19,360 --> 00:11:21,120
more unique

327
00:11:21,120 --> 00:11:22,640
and that actually led us to generating a

328
00:11:22,640 --> 00:11:25,279
32-bit or 32-bit identifier which

329
00:11:25,279 --> 00:11:27,600
generates a 32-byte machine specific id

330
00:11:27,600 --> 00:11:30,079
called the signature and a three-bit

331
00:11:30,079 --> 00:11:31,920
instance specific call just a device

332
00:11:31,920 --> 00:11:34,399
session id and basically these like uh

333
00:11:34,399 --> 00:11:37,120
these 32 bytes generate this session id

334
00:11:37,120 --> 00:11:38,959
that's unique across every single host

335
00:11:38,959 --> 00:11:42,079
that you connect to

336
00:11:42,079 --> 00:11:44,959
so networking speaking computer

337
00:11:44,959 --> 00:11:46,640
now developing this

338
00:11:46,640 --> 00:11:49,200
i wanted to be super protocol agnostic

339
00:11:49,200 --> 00:11:50,959
and you know honestly the lazy man in me

340
00:11:50,959 --> 00:11:52,320
really didn't want to write code for

341
00:11:52,320 --> 00:11:54,079
like different types of connections uh

342
00:11:54,079 --> 00:11:55,680
you know i wouldn't be able to handle

343
00:11:55,680 --> 00:11:57,279
pretty much anything without having to

344
00:11:57,279 --> 00:11:58,399
worry about what the underlying

345
00:11:58,399 --> 00:12:00,320
connection is i didn't want to have to

346
00:12:00,320 --> 00:12:02,000
you know write workarounds for something

347
00:12:02,000 --> 00:12:03,120
stupid

348
00:12:03,120 --> 00:12:04,399
and i also wanted to make complex

349
00:12:04,399 --> 00:12:06,800
connections well easy i didn't want to

350
00:12:06,800 --> 00:12:09,200
like i wanted i wanted to have complex

351
00:12:09,200 --> 00:12:11,519
connections but i didn't want myself or

352
00:12:11,519 --> 00:12:12,880
like anybody else on the other end to

353
00:12:12,880 --> 00:12:14,160
have to deal with

354
00:12:14,160 --> 00:12:15,760
all the bull crap of like managing that

355
00:12:15,760 --> 00:12:17,279
connection like i don't want to have to

356
00:12:17,279 --> 00:12:18,959
anybody deal with that

357
00:12:18,959 --> 00:12:20,959
and what i ended up doing is these

358
00:12:20,959 --> 00:12:22,399
things now basically operate on the

359
00:12:22,399 --> 00:12:24,160
net.com interface which is just you know

360
00:12:24,160 --> 00:12:26,880
basic to go

361
00:12:27,040 --> 00:12:28,800
so networking so some of the things that

362
00:12:28,800 --> 00:12:30,560
do go into networking we actually

363
00:12:30,560 --> 00:12:32,959
actually took the uh idea and split it

364
00:12:32,959 --> 00:12:34,720
out into a thing called connectors and

365
00:12:34,720 --> 00:12:36,000
basic connectors are the simple

366
00:12:36,000 --> 00:12:37,839
interface that provides the ability to

367
00:12:37,839 --> 00:12:39,920
listen and or connect

368
00:12:39,920 --> 00:12:41,680
and it's defined actually in code by two

369
00:12:41,680 --> 00:12:44,160
interfaces which is one the connector it

370
00:12:44,160 --> 00:12:45,680
accepts a context and a string you want

371
00:12:45,680 --> 00:12:47,760
to connect to and then it returns like a

372
00:12:47,760 --> 00:12:50,560
netcon and or an error and the acceptor

373
00:12:50,560 --> 00:12:52,399
interface which gives you a you provide

374
00:12:52,399 --> 00:12:54,639
a contacts and a bind address that

375
00:12:54,639 --> 00:12:57,600
returns a net listener and or an error

376
00:12:57,600 --> 00:12:59,360
some can actually support both

377
00:12:59,360 --> 00:13:02,000
some are you know one some are the other

378
00:13:02,000 --> 00:13:03,760
but most of them do have support for

379
00:13:03,760 --> 00:13:04,959
both built in

380
00:13:04,959 --> 00:13:06,800
so and we have for built-in current

381
00:13:06,800 --> 00:13:10,079
support we have tcp udp ip icmp http

382
00:13:10,079 --> 00:13:12,880
https tls mtls and you know like i said

383
00:13:12,880 --> 00:13:14,720
before a lot of things you can create

384
00:13:14,720 --> 00:13:17,360
custom ones for this so the

385
00:13:17,360 --> 00:13:18,720
the

386
00:13:18,720 --> 00:13:20,079
ability for you to create custom ones

387
00:13:20,079 --> 00:13:21,200
you just have to basically implement

388
00:13:21,200 --> 00:13:24,639
these interfaces then there you go

389
00:13:26,160 --> 00:13:28,000
okay so one special highlight i did want

390
00:13:28,000 --> 00:13:30,399
to talk about is the udp connector so

391
00:13:30,399 --> 00:13:32,320
all connectors at least by default as

392
00:13:32,320 --> 00:13:33,839
you would think they're stream sockets

393
00:13:33,839 --> 00:13:35,680
so meaning you know we're not like

394
00:13:35,680 --> 00:13:36,880
basically we're not looking at packets

395
00:13:36,880 --> 00:13:39,120
we're looking at a raw data stream

396
00:13:39,120 --> 00:13:41,360
now if you know anything about udp udp

397
00:13:41,360 --> 00:13:43,040
is completely packet based

398
00:13:43,040 --> 00:13:46,079
same with ip and icmp for example and we

399
00:13:46,079 --> 00:13:47,440
really needed a way to support streaming

400
00:13:47,440 --> 00:13:49,120
over udp i really don't want to deal

401
00:13:49,120 --> 00:13:51,120
with edp on its own separate thing

402
00:13:51,120 --> 00:13:52,880
so i ended up working on developing my

403
00:13:52,880 --> 00:13:54,800
own custom udp listener

404
00:13:54,800 --> 00:13:56,160
and what this listener does is it

405
00:13:56,160 --> 00:13:57,600
contains its like own connection ring

406
00:13:57,600 --> 00:14:00,160
buffer and what that does is it

407
00:14:00,160 --> 00:14:02,560
maintains a active connections map and

408
00:14:02,560 --> 00:14:04,800
this will take new connections and pipe

409
00:14:04,800 --> 00:14:07,839
them back to uh like the accept calls or

410
00:14:07,839 --> 00:14:09,760
if it already has connection that we are

411
00:14:09,760 --> 00:14:11,519
currently mapping it'll take the data

412
00:14:11,519 --> 00:14:13,279
and push it into the current socket

413
00:14:13,279 --> 00:14:15,279
buffer that we have

414
00:14:15,279 --> 00:14:17,120
and it this makes internal like a heavy

415
00:14:17,120 --> 00:14:19,519
use of channels uh to work uh work on

416
00:14:19,519 --> 00:14:21,440
multiple go routines at the same time

417
00:14:21,440 --> 00:14:23,680
but it actually works up really great

418
00:14:23,680 --> 00:14:25,519
and it's like super rock solid like you

419
00:14:25,519 --> 00:14:26,639
could talk over this as if you were

420
00:14:26,639 --> 00:14:28,320
talking over tcp and you wouldn't know

421
00:14:28,320 --> 00:14:29,279
the difference

422
00:14:29,279 --> 00:14:31,360
um you know i've used this to like send

423
00:14:31,360 --> 00:14:33,360
like hundreds of megabytes of data and

424
00:14:33,360 --> 00:14:34,959
it just goes

425
00:14:34,959 --> 00:14:37,360
um you know which is really awesome

426
00:14:37,360 --> 00:14:38,880
and i ended up taking the success of

427
00:14:38,880 --> 00:14:41,760
this one and using struct inheritance

428
00:14:41,760 --> 00:14:43,920
for the ip icmp connector so now you can

429
00:14:43,920 --> 00:14:46,079
talk over ping or like any kind of you

430
00:14:46,079 --> 00:14:48,560
know ip based protocol as well the same

431
00:14:48,560 --> 00:14:51,920
way and with easy support

432
00:14:52,320 --> 00:14:54,720
so next one the wc2 connector the wc2

433
00:14:54,720 --> 00:14:56,800
connector has the same problem as udp um

434
00:14:56,800 --> 00:14:58,639
you know it's http i didn't want to

435
00:14:58,639 --> 00:15:00,639
restrict just to post you know i didn't

436
00:15:00,639 --> 00:15:02,079
want to kind of send like a thousand

437
00:15:02,079 --> 00:15:03,360
post requests like every second that

438
00:15:03,360 --> 00:15:05,680
would be really suspicious

439
00:15:05,680 --> 00:15:07,920
so you know um i'm no stranger to web

440
00:15:07,920 --> 00:15:09,760
sockets and in fact i wrote the

441
00:15:09,760 --> 00:15:11,360
scoreboard over there which makes heavy

442
00:15:11,360 --> 00:15:13,199
use of websockets so i ain't no stranger

443
00:15:13,199 --> 00:15:14,800
to them but i was like man how can we

444
00:15:14,800 --> 00:15:16,000
implement these

445
00:15:16,000 --> 00:15:18,880
so i dove down into the code golang

446
00:15:18,880 --> 00:15:21,440
source code and it turns out golang will

447
00:15:21,440 --> 00:15:23,760
return some http bodies as read write if

448
00:15:23,760 --> 00:15:25,440
you play nice

449
00:15:25,440 --> 00:15:27,440
but you need really specific conditions

450
00:15:27,440 --> 00:15:30,000
uh one you need a 101 hd uh 101

451
00:15:30,000 --> 00:15:31,759
switching connections uh response from

452
00:15:31,759 --> 00:15:32,639
server

453
00:15:32,639 --> 00:15:34,639
can't be http2 and the server must

454
00:15:34,639 --> 00:15:36,560
hijack that connection and you know this

455
00:15:36,560 --> 00:15:37,759
is kind of obvious when you think about

456
00:15:37,759 --> 00:15:39,120
like web sockets like underneath the

457
00:15:39,120 --> 00:15:41,360
hood this is kind of how they operate

458
00:15:41,360 --> 00:15:42,800
but you need to all do this all in like

459
00:15:42,800 --> 00:15:44,560
a custom way so that way you can

460
00:15:44,560 --> 00:15:46,079
basically jack that connection right out

461
00:15:46,079 --> 00:15:48,800
of there and what happened is we ended

462
00:15:48,800 --> 00:15:50,560
up having to use reflect in order to

463
00:15:50,560 --> 00:15:51,920
grab this because we needed like the

464
00:15:51,920 --> 00:15:53,279
direct neck con

465
00:15:53,279 --> 00:15:56,399
but we can actually index inside the

466
00:15:56,399 --> 00:15:58,320
supplied struct and we can just pull the

467
00:15:58,320 --> 00:15:59,759
connection out of there and now just use

468
00:15:59,759 --> 00:16:03,440
that as if we're talking overall tcp

469
00:16:04,160 --> 00:16:04,880
so

470
00:16:04,880 --> 00:16:06,399
some of the other things that i had to

471
00:16:06,399 --> 00:16:07,600
implement to like kind of improve in

472
00:16:07,600 --> 00:16:08,399
this area

473
00:16:08,399 --> 00:16:10,320
is during my offensive security kind of

474
00:16:10,320 --> 00:16:13,360
lifetime uh and some pen tests is that a

475
00:16:13,360 --> 00:16:15,600
lot of firewalls would block uh http

476
00:16:15,600 --> 00:16:16,880
connections based on like their cookie

477
00:16:16,880 --> 00:16:19,279
state and basically like if it's not it

478
00:16:19,279 --> 00:16:21,199
doesn't recognize it as like a real like

479
00:16:21,199 --> 00:16:22,639
web session because it would basically

480
00:16:22,639 --> 00:16:24,639
apply a cookie to that session over the

481
00:16:24,639 --> 00:16:26,720
proxy and if that session came back

482
00:16:26,720 --> 00:16:28,160
without that cookie you'd be like no i

483
00:16:28,160 --> 00:16:30,240
ain't accepting you so i had to make

484
00:16:30,240 --> 00:16:31,600
sure that we actually like worked on

485
00:16:31,600 --> 00:16:34,560
keeping session state inside as well

486
00:16:34,560 --> 00:16:36,160
and the other thing is we had to add

487
00:16:36,160 --> 00:16:38,240
actually proxy support for it uh golang

488
00:16:38,240 --> 00:16:40,639
doesn't have any windows proxy support

489
00:16:40,639 --> 00:16:43,600
at all um it has like next proxy support

490
00:16:43,600 --> 00:16:45,279
super easy it's all environment variable

491
00:16:45,279 --> 00:16:47,920
based um so what we ended up doing is

492
00:16:47,920 --> 00:16:50,639
and ended up implementing our own uh

493
00:16:50,639 --> 00:16:52,000
proxy function and we call it

494
00:16:52,000 --> 00:16:54,000
device.proxy and it's literally a

495
00:16:54,000 --> 00:16:56,959
one-for-one drop-in of the http proxy

496
00:16:56,959 --> 00:16:58,639
from environment function

497
00:16:58,639 --> 00:17:00,240
which is great so now we can use this

498
00:17:00,240 --> 00:17:02,720
for linux and or windows and it'll just

499
00:17:02,720 --> 00:17:04,959
work out the box um and this uses the

500
00:17:04,959 --> 00:17:07,839
one api i call uh when http get default

501
00:17:07,839 --> 00:17:09,839
proxy configuration which is basically

502
00:17:09,839 --> 00:17:11,760
it returns the either system based or

503
00:17:11,760 --> 00:17:14,079
gpo based proxy config on the host and

504
00:17:14,079 --> 00:17:16,000
we can parse out that data and then get

505
00:17:16,000 --> 00:17:18,000
like any of the proxy like what the http

506
00:17:18,000 --> 00:17:20,559
proxy your http exceptions etc and we

507
00:17:20,559 --> 00:17:23,599
just pull it out and now use it

508
00:17:24,400 --> 00:17:26,000
now the funnest thing i like to talk

509
00:17:26,000 --> 00:17:28,880
about the hardest one uh routing routing

510
00:17:28,880 --> 00:17:31,200
is really super complex and i hate that

511
00:17:31,200 --> 00:17:33,520
it is complex but the reason i made it

512
00:17:33,520 --> 00:17:35,120
complex honestly is because we need to

513
00:17:35,120 --> 00:17:37,440
support like a lot of feature sets

514
00:17:37,440 --> 00:17:38,400
some of the features we didn't need

515
00:17:38,400 --> 00:17:41,120
support would be like multi packets so

516
00:17:41,120 --> 00:17:43,919
if i'm sending data to a host and or

517
00:17:43,919 --> 00:17:45,679
like a command to a host and that's like

518
00:17:45,679 --> 00:17:47,360
one packet for example i don't want to

519
00:17:47,360 --> 00:17:48,720
have to wait for it to connect back to

520
00:17:48,720 --> 00:17:50,320
me again to wait and go send the other

521
00:17:50,320 --> 00:17:51,840
one like i can just send both of them at

522
00:17:51,840 --> 00:17:53,600
the same time like if it hasn't talked

523
00:17:53,600 --> 00:17:54,960
to you back why am i going to wait

524
00:17:54,960 --> 00:17:57,039
another time to send it another packet

525
00:17:57,039 --> 00:17:58,880
so i can send multiple all at the same

526
00:17:58,880 --> 00:18:00,480
time downstream device so we're not

527
00:18:00,480 --> 00:18:02,080
wasting any time

528
00:18:02,080 --> 00:18:04,400
then we want to also handle fragments um

529
00:18:04,400 --> 00:18:06,559
so if the packet's like too big you know

530
00:18:06,559 --> 00:18:08,480
we want to cut it up into bite slices

531
00:18:08,480 --> 00:18:09,840
for example because i mean i don't know

532
00:18:09,840 --> 00:18:11,760
about you but sending a pack a 100 meg

533
00:18:11,760 --> 00:18:15,760
dns packet doesn't look okay

534
00:18:15,760 --> 00:18:18,400
um then also there's a mode we created

535
00:18:18,400 --> 00:18:20,160
called channeling mode channeling mode

536
00:18:20,160 --> 00:18:23,280
basically allows you to break the normal

537
00:18:23,280 --> 00:18:25,039
like kind of weight back for a packet

538
00:18:25,039 --> 00:18:27,200
response from the client or the implant

539
00:18:27,200 --> 00:18:28,480
and now you can act as if you're

540
00:18:28,480 --> 00:18:30,640
directly at the terminal of the machine

541
00:18:30,640 --> 00:18:32,720
so it's like instantaneous feedback or

542
00:18:32,720 --> 00:18:35,120
instantaneous file uploads downloads etc

543
00:18:35,120 --> 00:18:36,880
so we also need to kind of have a work

544
00:18:36,880 --> 00:18:38,160
around that make sure that works

545
00:18:38,160 --> 00:18:39,200
correctly

546
00:18:39,200 --> 00:18:40,960
and last thing proxy connections or

547
00:18:40,960 --> 00:18:42,480
pivoting if you know if you're familiar

548
00:18:42,480 --> 00:18:44,480
with that nomenclature where we wanted

549
00:18:44,480 --> 00:18:46,320
to be able to piggyback off of other

550
00:18:46,320 --> 00:18:48,240
implants connections

551
00:18:48,240 --> 00:18:49,760
and this kind of led us down this huge

552
00:18:49,760 --> 00:18:51,440
you know rabbit hole of basically

553
00:18:51,440 --> 00:18:53,280
working on the thing of routing the

554
00:18:53,280 --> 00:18:56,720
identity and flags

555
00:18:56,720 --> 00:18:59,520
so to kind of uh give a button to that

556
00:18:59,520 --> 00:19:01,120
uh basically we use a struct called

557
00:19:01,120 --> 00:19:02,400
packet which is the

558
00:19:02,400 --> 00:19:04,320
huge basis of enterprise communication

559
00:19:04,320 --> 00:19:06,240
and it contains a thing called flags and

560
00:19:06,240 --> 00:19:07,679
device id

561
00:19:07,679 --> 00:19:10,720
basically flags are a boolean uh state

562
00:19:10,720 --> 00:19:12,960
of a packet as it flows through like the

563
00:19:12,960 --> 00:19:15,840
network to the actual final c2 server

564
00:19:15,840 --> 00:19:18,240
and it totes it notates the fragment

565
00:19:18,240 --> 00:19:20,160
size uh the fragment state as well so

566
00:19:20,160 --> 00:19:21,760
meaning like the group id because we can

567
00:19:21,760 --> 00:19:23,520
wait on multiple fragments if we want to

568
00:19:23,520 --> 00:19:25,280
and then the fragment position inside

569
00:19:25,280 --> 00:19:27,520
that group and then the the total amount

570
00:19:27,520 --> 00:19:29,679
of frags we actually want to receive

571
00:19:29,679 --> 00:19:32,320
also these flags will actually determine

572
00:19:32,320 --> 00:19:34,080
how we want to act on a packet as we can

573
00:19:34,080 --> 00:19:36,240
like optimize the our receiving of

574
00:19:36,240 --> 00:19:37,919
packets like if every packet coming to

575
00:19:37,919 --> 00:19:40,000
us just goes to us we can just

576
00:19:40,000 --> 00:19:41,919
multi-batch process those immediately

577
00:19:41,919 --> 00:19:44,000
versus like if it's a flag multi-packet

578
00:19:44,000 --> 00:19:45,840
meaning that we have to now unpack it

579
00:19:45,840 --> 00:19:47,840
scrutinize and look to see if we can

580
00:19:47,840 --> 00:19:49,520
forward it to like a downstream client

581
00:19:49,520 --> 00:19:52,320
or upstream um so you know we can kind

582
00:19:52,320 --> 00:19:54,080
of use these to like speed up some of

583
00:19:54,080 --> 00:19:57,039
our processes as well

584
00:19:57,120 --> 00:19:59,120
so getting into channels that i talked

585
00:19:59,120 --> 00:20:00,640
about earlier so like i said channels

586
00:20:00,640 --> 00:20:02,400
are a direct connection to the c2 server

587
00:20:02,400 --> 00:20:04,080
like i said the easy way to describe it

588
00:20:04,080 --> 00:20:05,600
it's like you're at the terminal of that

589
00:20:05,600 --> 00:20:07,760
machine it's instantaneous communication

590
00:20:07,760 --> 00:20:09,600
it will work through proxies and pivots

591
00:20:09,600 --> 00:20:12,080
directly as well now the caveat of this

592
00:20:12,080 --> 00:20:15,120
is that every single hop between the uh

593
00:20:15,120 --> 00:20:17,200
implant and the c2 server it enables

594
00:20:17,200 --> 00:20:18,960
channeling mode through and through

595
00:20:18,960 --> 00:20:20,720
because i mean obviously if i'm waiting

596
00:20:20,720 --> 00:20:23,200
on a upstream packet from another device

597
00:20:23,200 --> 00:20:24,880
i you know it's not instantaneous

598
00:20:24,880 --> 00:20:27,200
anymore right so it's going to enable

599
00:20:27,200 --> 00:20:29,360
upstream through every single device so

600
00:20:29,360 --> 00:20:32,080
if whatever end uh sent the flag flag

601
00:20:32,080 --> 00:20:35,120
channel it'll then bam uh instant set

602
00:20:35,120 --> 00:20:37,280
that up and then once whatever sides

603
00:20:37,280 --> 00:20:38,720
like all right i'm done it just sends

604
00:20:38,720 --> 00:20:40,640
black channel end and the whole thing

605
00:20:40,640 --> 00:20:43,039
comes down however if one of the hops

606
00:20:43,039 --> 00:20:45,360
between like a and b

607
00:20:45,360 --> 00:20:47,840
is uh channeling on its own meaning like

608
00:20:47,840 --> 00:20:49,600
that device specifically has decided

609
00:20:49,600 --> 00:20:51,360
it's gonna channel that one stays up

610
00:20:51,360 --> 00:20:53,039
unless that device is like all right i'm

611
00:20:53,039 --> 00:20:54,640
done as well so we're not tearing down

612
00:20:54,640 --> 00:20:57,600
other people's connections

613
00:20:58,159 --> 00:21:01,280
so proxying uh implants can piggyback on

614
00:21:01,280 --> 00:21:03,440
another uh implant meaning like i can

615
00:21:03,440 --> 00:21:05,200
talk to another one behind if i'm like

616
00:21:05,200 --> 00:21:07,120
segmented behind a firewall or something

617
00:21:07,120 --> 00:21:09,039
um the implants don't need to know at

618
00:21:09,039 --> 00:21:10,799
all so like they don't even know they're

619
00:21:10,799 --> 00:21:11,840
talking to proxy they think they're

620
00:21:11,840 --> 00:21:13,520
talking to the c2 which is great we

621
00:21:13,520 --> 00:21:16,559
don't handle it like any any different

622
00:21:16,559 --> 00:21:18,480
and we can use a thing called packet

623
00:21:18,480 --> 00:21:20,400
tags to mark ownership and the reason we

624
00:21:20,400 --> 00:21:22,559
do this is so we can know where to route

625
00:21:22,559 --> 00:21:24,799
packets through we want to have packet

626
00:21:24,799 --> 00:21:27,039
routing super easy so we use a thing

627
00:21:27,039 --> 00:21:28,720
called packet tags which are hashes of

628
00:21:28,720 --> 00:21:31,600
the device id which the server will tap

629
00:21:31,600 --> 00:21:33,840
onto its uh packets that way there's no

630
00:21:33,840 --> 00:21:35,600
extra packets being like added so we're

631
00:21:35,600 --> 00:21:37,200
using less network traffic

632
00:21:37,200 --> 00:21:39,280
and now we can constantly update the

633
00:21:39,280 --> 00:21:40,880
server say hey yeah i still got this guy

634
00:21:40,880 --> 00:21:42,240
i still got this guy i still got this

635
00:21:42,240 --> 00:21:44,320
guy so the server still knows now what

636
00:21:44,320 --> 00:21:46,159
this allows us to do is if we have

637
00:21:46,159 --> 00:21:48,400
multiple instances inside of a network

638
00:21:48,400 --> 00:21:50,559
and there's an instance way down there

639
00:21:50,559 --> 00:21:52,480
deep in the net it can talk to multiple

640
00:21:52,480 --> 00:21:54,000
different hosts and keep switching back

641
00:21:54,000 --> 00:21:55,760
and forth you know and the server on the

642
00:21:55,760 --> 00:21:58,240
other end still knows where it's at and

643
00:21:58,240 --> 00:21:59,679
knows how to route its packets so

644
00:21:59,679 --> 00:22:02,080
nothing gets dropped nothing gets missed

645
00:22:02,080 --> 00:22:05,760
we can you know send them all correctly

646
00:22:06,559 --> 00:22:08,559
so getting into some of the things that

647
00:22:08,559 --> 00:22:10,000
actually make networking really fun at

648
00:22:10,000 --> 00:22:12,080
least for me as a red teamer there's a

649
00:22:12,080 --> 00:22:13,760
concept called wrappers and transforms

650
00:22:13,760 --> 00:22:15,200
and they allow you to augment c2

651
00:22:15,200 --> 00:22:17,200
connection and basically what this means

652
00:22:17,200 --> 00:22:18,880
it allows you to like obfuscate

653
00:22:18,880 --> 00:22:21,280
masquerade or encrypt your connection

654
00:22:21,280 --> 00:22:22,960
we have wrappers which literally wrap

655
00:22:22,960 --> 00:22:24,960
the connection they are stream based

656
00:22:24,960 --> 00:22:26,720
things they have unlimited uses they

657
00:22:26,720 --> 00:22:28,080
have an order so you can go like you

658
00:22:28,080 --> 00:22:30,880
know encryption compression obfuscation

659
00:22:30,880 --> 00:22:32,640
or you can go encryption compression

660
00:22:32,640 --> 00:22:35,039
compression if you want to um then we

661
00:22:35,039 --> 00:22:36,799
have transforms transforms actually

662
00:22:36,799 --> 00:22:38,559
transform the connection they are block

663
00:22:38,559 --> 00:22:40,640
based they access the entire binary

664
00:22:40,640 --> 00:22:42,000
payload before it actually gets written

665
00:22:42,000 --> 00:22:43,760
to the wire so what this means is you

666
00:22:43,760 --> 00:22:46,720
can completely rewrite your your um your

667
00:22:46,720 --> 00:22:48,559
data so you can reverse it if you want

668
00:22:48,559 --> 00:22:50,320
you can change it into a dns packet you

669
00:22:50,320 --> 00:22:52,320
can change it to an image doesn't matter

670
00:22:52,320 --> 00:22:54,720
you do whatever you want with it and but

671
00:22:54,720 --> 00:22:56,000
because of how they work they're only

672
00:22:56,000 --> 00:22:58,080
they can only be used once

673
00:22:58,080 --> 00:22:59,520
so some of the things we do build i have

674
00:22:59,520 --> 00:23:00,960
built-in support for for wrappers for

675
00:23:00,960 --> 00:23:03,919
example are encryption we have xor aes

676
00:23:03,919 --> 00:23:06,080
cbk because i'm funny

677
00:23:06,080 --> 00:23:08,480
we have compression uh gzip and lzo

678
00:23:08,480 --> 00:23:10,960
currently uh we have uh hex and base64

679
00:23:10,960 --> 00:23:12,960
for encoding then transforms right now

680
00:23:12,960 --> 00:23:15,200
we just have base64 and we have dns so

681
00:23:15,200 --> 00:23:17,200
for the dns one i really like that one

682
00:23:17,200 --> 00:23:18,720
because it literally masquerades as a

683
00:23:18,720 --> 00:23:22,080
perfect rfc uh like fitting packet so

684
00:23:22,080 --> 00:23:23,280
like wire shark and everything else is

685
00:23:23,280 --> 00:23:25,039
none the wiser that's a dns like

686
00:23:25,039 --> 00:23:27,360
communication between the two so these

687
00:23:27,360 --> 00:23:28,880
will like masquerade right through like

688
00:23:28,880 --> 00:23:30,400
a level seven firewall or a lighter

689
00:23:30,400 --> 00:23:33,120
seven firewall

690
00:23:33,360 --> 00:23:35,120
so now you may be wondering all this

691
00:23:35,120 --> 00:23:36,799
stuff's going on between like hosts well

692
00:23:36,799 --> 00:23:38,640
like am i wondering about like privacy

693
00:23:38,640 --> 00:23:40,960
or encryption or anything um well yeah i

694
00:23:40,960 --> 00:23:42,960
answered that with key swapping so key

695
00:23:42,960 --> 00:23:44,159
swapping is a thing that's enabled by

696
00:23:44,159 --> 00:23:45,679
default you can disable it by a build

697
00:23:45,679 --> 00:23:47,919
tag and it's basically a lazy mutual

698
00:23:47,919 --> 00:23:49,840
authentication between host and host are

699
00:23:49,840 --> 00:23:52,559
the server and the implant and basically

700
00:23:52,559 --> 00:23:55,840
what happens is when the implant talks

701
00:23:55,840 --> 00:23:58,240
to the server for the first time it will

702
00:23:58,240 --> 00:24:00,159
tag its packet with a specific flag it's

703
00:24:00,159 --> 00:24:02,000
opt-in but if it's built with it it

704
00:24:02,000 --> 00:24:04,559
always opts in and then it sends some

705
00:24:04,559 --> 00:24:06,799
randomized key material at the end of it

706
00:24:06,799 --> 00:24:08,000
and what it'll do is it sends it to the

707
00:24:08,000 --> 00:24:10,559
server the server will then do some math

708
00:24:10,559 --> 00:24:13,279
based on the identifier of the packet um

709
00:24:13,279 --> 00:24:16,640
and some time-based stuff and the um

710
00:24:16,640 --> 00:24:19,360
the mutual like data that the packet has

711
00:24:19,360 --> 00:24:21,200
been sent with then the client on the

712
00:24:21,200 --> 00:24:22,640
other side will do the exact same

713
00:24:22,640 --> 00:24:25,279
mathematic formula and basically now

714
00:24:25,279 --> 00:24:27,200
they have both generated key material or

715
00:24:27,200 --> 00:24:28,799
a key that

716
00:24:28,799 --> 00:24:30,480
neither side is sent across a network so

717
00:24:30,480 --> 00:24:32,480
now they both have a separate key that

718
00:24:32,480 --> 00:24:34,000
they can use to encrypt their packet

719
00:24:34,000 --> 00:24:36,240
data without you know anybody else in

720
00:24:36,240 --> 00:24:38,159
between knowing it

721
00:24:38,159 --> 00:24:40,480
now because of the fact that we use like

722
00:24:40,480 --> 00:24:42,159
uh the ids and the flags for routing we

723
00:24:42,159 --> 00:24:43,600
can only encrypt the actual contents of

724
00:24:43,600 --> 00:24:46,000
the packet so you know uh

725
00:24:46,000 --> 00:24:47,919
the actual data contents of it are

726
00:24:47,919 --> 00:24:50,480
encrypted using xor for speed but like

727
00:24:50,480 --> 00:24:52,000
everything else like the flags and stuff

728
00:24:52,000 --> 00:24:53,440
aren't really encrypted because we can't

729
00:24:53,440 --> 00:24:54,559
really do that

730
00:24:54,559 --> 00:24:56,880
um but the cool thing about it is is

731
00:24:56,880 --> 00:24:58,480
that if i'm sending packets through a

732
00:24:58,480 --> 00:25:00,320
proxy the proxy can't read my packet

733
00:25:00,320 --> 00:25:02,080
data like it has no idea what i'm

734
00:25:02,080 --> 00:25:02,960
sending it just looks like a bunch of

735
00:25:02,960 --> 00:25:04,799
gibberish but the server on the other

736
00:25:04,799 --> 00:25:06,400
end will read it and be like oh cool i

737
00:25:06,400 --> 00:25:08,080
know what this is

738
00:25:08,080 --> 00:25:10,240
and it's rotated regularly so every so

739
00:25:10,240 --> 00:25:12,159
often there's a chance that the client

740
00:25:12,159 --> 00:25:14,640
will say hey server let's do this again

741
00:25:14,640 --> 00:25:16,240
and the client will send some more key

742
00:25:16,240 --> 00:25:17,520
material back to the server and they'll

743
00:25:17,520 --> 00:25:19,279
do the whole song and dance as the

744
00:25:19,279 --> 00:25:21,679
beginning

745
00:25:22,159 --> 00:25:23,600
so now the kind of thing that wraps all

746
00:25:23,600 --> 00:25:25,919
this stuff together profiles

747
00:25:25,919 --> 00:25:27,360
these things bring implant settings

748
00:25:27,360 --> 00:25:29,120
together with a little bit of twists

749
00:25:29,120 --> 00:25:31,679
they are a binary table that are kind of

750
00:25:31,679 --> 00:25:34,960
like a uh type length value uh format

751
00:25:34,960 --> 00:25:37,120
but they can also be in json if you want

752
00:25:37,120 --> 00:25:39,520
to be like stealthier and smaller uh

753
00:25:39,520 --> 00:25:40,960
smaller in your binary size you can

754
00:25:40,960 --> 00:25:43,360
actually disable json parsing

755
00:25:43,360 --> 00:25:45,600
but it contains settings for containers

756
00:25:45,600 --> 00:25:47,679
wrappers and transforms

757
00:25:47,679 --> 00:25:50,240
excuse me and i contain multiple c2

758
00:25:50,240 --> 00:25:51,200
servers

759
00:25:51,200 --> 00:25:52,559
so if you have multiple hosts that you

760
00:25:52,559 --> 00:25:53,760
wanted to connect to it'll just select

761
00:25:53,760 --> 00:25:56,240
one and send it to

762
00:25:56,240 --> 00:25:58,000
but they can also tame things called

763
00:25:58,000 --> 00:25:59,360
selectors and groups which i'm going to

764
00:25:59,360 --> 00:26:01,440
talk about next slide

765
00:26:01,440 --> 00:26:02,960
selectors in groups they are one of the

766
00:26:02,960 --> 00:26:04,880
coolest things in my opinion they can

767
00:26:04,880 --> 00:26:06,720
basically break up a profile into

768
00:26:06,720 --> 00:26:09,600
multiple like separate like sub profiles

769
00:26:09,600 --> 00:26:11,520
and what this allows the implant to do

770
00:26:11,520 --> 00:26:14,400
is it changes its encryption or like it

771
00:26:14,400 --> 00:26:16,159
changes how it acts on the wire so like

772
00:26:16,159 --> 00:26:18,320
it's encryption who it's talking to how

773
00:26:18,320 --> 00:26:20,400
it acts it can completely change that up

774
00:26:20,400 --> 00:26:22,480
and that's without any interactions from

775
00:26:22,480 --> 00:26:24,240
the person like operating it like this

776
00:26:24,240 --> 00:26:26,640
will do it automatically so you know

777
00:26:26,640 --> 00:26:28,240
it'll switch it up like either you know

778
00:26:28,240 --> 00:26:29,600
based on like a time or based on

779
00:26:29,600 --> 00:26:31,919
randomization and um if the server's

780
00:26:31,919 --> 00:26:33,440
configured on the other end to accept

781
00:26:33,440 --> 00:26:35,840
this still then it just keeps going like

782
00:26:35,840 --> 00:26:38,480
nothing's nothing happened and basically

783
00:26:38,480 --> 00:26:40,080
we use selectors to kind of determine

784
00:26:40,080 --> 00:26:41,840
how we switch these then we have like

785
00:26:41,840 --> 00:26:43,600
last valid which says hey if you know

786
00:26:43,600 --> 00:26:45,679
the first one hits an error switch to

787
00:26:45,679 --> 00:26:48,480
the next one or random just as mad chaos

788
00:26:48,480 --> 00:26:50,080
just switch to one like every single

789
00:26:50,080 --> 00:26:50,960
time

790
00:26:50,960 --> 00:26:53,360
or we have round robin which is every

791
00:26:53,360 --> 00:26:55,360
connection operation switch to the next

792
00:26:55,360 --> 00:26:57,600
one on a weighted based order

793
00:26:57,600 --> 00:27:00,240
semi-round robin same thing but if

794
00:27:00,240 --> 00:27:03,679
there's a 25 chances hit then switch 75

795
00:27:03,679 --> 00:27:05,520
chance don't

796
00:27:05,520 --> 00:27:08,559
semirandom is again if you hit a 25

797
00:27:08,559 --> 00:27:11,200
chance then it will switch to the next

798
00:27:11,200 --> 00:27:12,559
profile

799
00:27:12,559 --> 00:27:14,400
but this is completely optional um and

800
00:27:14,400 --> 00:27:15,760
the great thing about it though is is we

801
00:27:15,760 --> 00:27:17,919
have a python script in the

802
00:27:17,919 --> 00:27:20,720
repo under tools config.pi that will

803
00:27:20,720 --> 00:27:22,240
actually like do all this for you it can

804
00:27:22,240 --> 00:27:24,240
either be used in api directly in python

805
00:27:24,240 --> 00:27:25,679
or it can be used as like a command line

806
00:27:25,679 --> 00:27:27,120
thing but allows you to build these like

807
00:27:27,120 --> 00:27:30,639
complex profiles pretty easily

808
00:27:30,720 --> 00:27:33,760
now defense itself so one of the things

809
00:27:33,760 --> 00:27:36,159
i spent a lot of time on uh for defense

810
00:27:36,159 --> 00:27:38,480
is limiting identification so we

811
00:27:38,480 --> 00:27:40,720
basically want to reduce the possibility

812
00:27:40,720 --> 00:27:41,919
that when a blue team looks at this

813
00:27:41,919 --> 00:27:43,760
binary and says oh obviously that's a go

814
00:27:43,760 --> 00:27:46,240
binary or obviously that's you know

815
00:27:46,240 --> 00:27:49,440
whatever it's it's c2 it's malware etc

816
00:27:49,440 --> 00:27:50,799
one of the things i do this by is

817
00:27:50,799 --> 00:27:52,640
reducing recognizable strings that do

818
00:27:52,640 --> 00:27:54,640
exist in the binary and this actually

819
00:27:54,640 --> 00:27:57,440
reduces our size which to be a plus

820
00:27:57,440 --> 00:27:59,279
we also do some things like some checks

821
00:27:59,279 --> 00:28:01,120
and some kind of work around to look not

822
00:28:01,120 --> 00:28:03,760
as malicious as we normally would

823
00:28:03,760 --> 00:28:05,440
one of the ways we do this is we enable

824
00:28:05,440 --> 00:28:07,039
a thing called implant mode which is

825
00:28:07,039 --> 00:28:09,039
enabled by a build tag it basically

826
00:28:09,039 --> 00:28:11,039
trims a bunch of unnecessary stuff off

827
00:28:11,039 --> 00:28:13,200
the binary and even though it's golang

828
00:28:13,200 --> 00:28:14,399
and gulen's

829
00:28:14,399 --> 00:28:16,320
compiler is supposed to be really good

830
00:28:16,320 --> 00:28:17,679
at like trimming the fat and things that

831
00:28:17,679 --> 00:28:19,279
aren't used it can sometimes leave

832
00:28:19,279 --> 00:28:22,080
things in there that it may use that are

833
00:28:22,080 --> 00:28:24,399
really never actually needed so we

834
00:28:24,399 --> 00:28:25,919
actually basically force it to remove

835
00:28:25,919 --> 00:28:28,399
these things completely from the binary

836
00:28:28,399 --> 00:28:29,919
it also converts errors to numbers so

837
00:28:29,919 --> 00:28:31,279
that x errors package i was talking

838
00:28:31,279 --> 00:28:33,919
about on the wire and in memory those

839
00:28:33,919 --> 00:28:36,559
are converted to a numeric version of

840
00:28:36,559 --> 00:28:38,159
the string so

841
00:28:38,159 --> 00:28:40,159
basically like in memory and everything

842
00:28:40,159 --> 00:28:41,679
there are numbers but like as the

843
00:28:41,679 --> 00:28:44,240
operator reporting back on the error you

844
00:28:44,240 --> 00:28:45,840
would only see the string so like it

845
00:28:45,840 --> 00:28:48,240
converts it back for you so the grass

846
00:28:48,240 --> 00:28:49,600
the great thing about it is that if

847
00:28:49,600 --> 00:28:51,200
somebody's doing memory forensics on it

848
00:28:51,200 --> 00:28:52,480
and for some reason you hit an error and

849
00:28:52,480 --> 00:28:54,000
it's like access denied or i don't know

850
00:28:54,000 --> 00:28:55,760
you cannot spawn this process for x

851
00:28:55,760 --> 00:28:57,600
reason it doesn't literally say that

852
00:28:57,600 --> 00:29:00,480
it's just like uh 256 or something you

853
00:29:00,480 --> 00:29:02,320
know so and it's great it saves us bytes

854
00:29:02,320 --> 00:29:04,320
over the wire and it's kind of less work

855
00:29:04,320 --> 00:29:07,279
for us to kind of do comparison

856
00:29:07,279 --> 00:29:08,880
and it also actually guts three

857
00:29:08,880 --> 00:29:10,559
megabytes of size for the binary which

858
00:29:10,559 --> 00:29:13,679
is pretty crazy um oh and it also cuts

859
00:29:13,679 --> 00:29:16,640
logging i don't expect an implant to log

860
00:29:16,640 --> 00:29:18,240
anything to stud out you know so it

861
00:29:18,240 --> 00:29:19,440
shouldn't even be printing anything to

862
00:29:19,440 --> 00:29:21,039
set out why would you have it do that

863
00:29:21,039 --> 00:29:23,039
but um but yeah it cuts it really small

864
00:29:23,039 --> 00:29:25,120
and it removes a lot of stuff

865
00:29:25,120 --> 00:29:27,440
now crypt mode crypt mode is a really

866
00:29:27,440 --> 00:29:29,600
cool mode

867
00:29:29,600 --> 00:29:32,559
it like implant mode uh is a build tag

868
00:29:32,559 --> 00:29:34,640
and it's based on the util crypt library

869
00:29:34,640 --> 00:29:37,279
now this actually is a way to compile in

870
00:29:37,279 --> 00:29:39,679
all of our strings as encoded and this

871
00:29:39,679 --> 00:29:41,440
removes 90

872
00:29:41,440 --> 00:29:43,600
of our strings from the binary and i

873
00:29:43,600 --> 00:29:45,279
mean are not like the runtime strings

874
00:29:45,279 --> 00:29:46,880
but like whatever we use like built-in

875
00:29:46,880 --> 00:29:50,320
file paths for like linux for example um

876
00:29:50,320 --> 00:29:51,600
and it's based on like an ldflags

877
00:29:51,600 --> 00:29:54,240
argument that like packs a string table

878
00:29:54,240 --> 00:29:55,520
and there's you don't have to do this by

879
00:29:55,520 --> 00:29:57,360
hand i think you'd be crazy to do that

880
00:29:57,360 --> 00:29:59,039
um we have automated scripts that will

881
00:29:59,039 --> 00:30:01,120
do this for you and they're included in

882
00:30:01,120 --> 00:30:03,279
the tools directory and what it does is

883
00:30:03,279 --> 00:30:04,720
it actually looks at your build tags and

884
00:30:04,720 --> 00:30:06,559
your build environment and will say hey

885
00:30:06,559 --> 00:30:08,159
are you building this for windows okay

886
00:30:08,159 --> 00:30:09,520
nix all the linux strings we all need

887
00:30:09,520 --> 00:30:10,960
them or oh you're building for linux we

888
00:30:10,960 --> 00:30:12,000
don't need the linux or we don't need

889
00:30:12,000 --> 00:30:13,600
the windows strings so it only uses

890
00:30:13,600 --> 00:30:15,600
exactly what you're needing

891
00:30:15,600 --> 00:30:17,200
but basically technically speaking what

892
00:30:17,200 --> 00:30:19,279
it does is it builds a base64 encoded

893
00:30:19,279 --> 00:30:21,919
string block and with that block is when

894
00:30:21,919 --> 00:30:24,320
the program is first and knitted um it

895
00:30:24,320 --> 00:30:26,399
unpacks that uh block which is also

896
00:30:26,399 --> 00:30:29,600
encrypted with xor and on first runtime

897
00:30:29,600 --> 00:30:31,760
it basically slots all those strings

898
00:30:31,760 --> 00:30:34,080
into a index on a string table and all

899
00:30:34,080 --> 00:30:35,760
the packages that have consumers for

900
00:30:35,760 --> 00:30:37,360
that will then basically load that

901
00:30:37,360 --> 00:30:39,679
string via index so then all those

902
00:30:39,679 --> 00:30:41,039
strings will come back and so where

903
00:30:41,039 --> 00:30:42,320
they're where they are like in their

904
00:30:42,320 --> 00:30:44,720
format

905
00:30:45,200 --> 00:30:48,559
so now defense i'll build my own loader

906
00:30:48,559 --> 00:30:51,039
so i actually um thought the assist

907
00:30:51,039 --> 00:30:53,120
windows package in golang was really

908
00:30:53,120 --> 00:30:55,120
heavy and what i mean by that is it

909
00:30:55,120 --> 00:30:57,440
pulls out a lot of dependencies it's

910
00:30:57,440 --> 00:30:59,679
super string heavy it adds a lot to your

911
00:30:59,679 --> 00:31:02,000
binary size and honestly one of my

912
00:31:02,000 --> 00:31:04,480
things it's a pain to deal with

913
00:31:04,480 --> 00:31:07,200
so i said screw it i'll build my own um

914
00:31:07,200 --> 00:31:09,039
what i ended up doing is it's almost the

915
00:31:09,039 --> 00:31:10,960
same-ish but i added a lot of

916
00:31:10,960 --> 00:31:12,640
optimizations to it especially some like

917
00:31:12,640 --> 00:31:14,559
memory optimizations

918
00:31:14,559 --> 00:31:16,880
and i also added some mutex locking and

919
00:31:16,880 --> 00:31:18,559
improvements as well so we're spending

920
00:31:18,559 --> 00:31:20,320
less run time like spinning on certain

921
00:31:20,320 --> 00:31:23,440
things that we really don't need to

922
00:31:23,440 --> 00:31:25,200
but one of the other reasons i really

923
00:31:25,200 --> 00:31:27,840
did it is because i wanted to load dll

924
00:31:27,840 --> 00:31:30,159
functions based on an fnv hash of their

925
00:31:30,159 --> 00:31:32,240
name instead of the actual function name

926
00:31:32,240 --> 00:31:33,679
so if you're not familiar when you load

927
00:31:33,679 --> 00:31:35,200
a function in windows you first load the

928
00:31:35,200 --> 00:31:37,600
dll by the name like kernel 32 dll then

929
00:31:37,600 --> 00:31:39,600
you load the function name so like get

930
00:31:39,600 --> 00:31:41,519
windows version for example then you

931
00:31:41,519 --> 00:31:43,519
load that so that's a string value so i

932
00:31:43,519 --> 00:31:44,640
didn't want to do that i wanted to load

933
00:31:44,640 --> 00:31:46,480
it by like i don't know one two three

934
00:31:46,480 --> 00:31:48,559
four five six and i wanted to load that

935
00:31:48,559 --> 00:31:50,880
so what end up doing is i built my own

936
00:31:50,880 --> 00:31:53,519
dll loader that actually um

937
00:31:53,519 --> 00:31:55,519
basically loaded these like this and how

938
00:31:55,519 --> 00:31:57,600
it works is when you receive a handle to

939
00:31:57,600 --> 00:32:00,000
a dll it's actually the address that it

940
00:32:00,000 --> 00:32:01,760
sits in memory in windows so what you

941
00:32:01,760 --> 00:32:03,519
can do is you can go to that mapped

942
00:32:03,519 --> 00:32:06,960
memory and start just reading it out raw

943
00:32:06,960 --> 00:32:09,919
so what we did is we started parsing and

944
00:32:09,919 --> 00:32:11,919
loading the virtual exports table which

945
00:32:11,919 --> 00:32:14,000
contains like all of the like an index

946
00:32:14,000 --> 00:32:16,240
array of all the functions and we hash

947
00:32:16,240 --> 00:32:18,399
the string names of them then we compare

948
00:32:18,399 --> 00:32:20,159
the string name or the string hash to

949
00:32:20,159 --> 00:32:23,440
what we had and then if so that matches

950
00:32:23,440 --> 00:32:25,360
then we look up the ordinal position

951
00:32:25,360 --> 00:32:27,360
match that to the function address and

952
00:32:27,360 --> 00:32:30,080
bam there's your function um

953
00:32:30,080 --> 00:32:31,840
we only do this once per dll it's loaded

954
00:32:31,840 --> 00:32:33,039
so we just load all the functions that

955
00:32:33,039 --> 00:32:35,519
we need then bam we're done now the only

956
00:32:35,519 --> 00:32:36,720
pain in the ass that had to deal with

957
00:32:36,720 --> 00:32:40,000
this is exported functions so exported

958
00:32:40,000 --> 00:32:41,440
functions if you're not familiar is when

959
00:32:41,440 --> 00:32:43,919
a dll points to another dll another

960
00:32:43,919 --> 00:32:45,760
process hey that function it's over

961
00:32:45,760 --> 00:32:47,519
there now windows does this for you

962
00:32:47,519 --> 00:32:48,880
automatically so you would never know it

963
00:32:48,880 --> 00:32:50,640
it exists but in this case it doesn't do

964
00:32:50,640 --> 00:32:51,840
it so

965
00:32:51,840 --> 00:32:53,519
it's basically a string

966
00:32:53,519 --> 00:32:55,519
instead of a function f pointer so we

967
00:32:55,519 --> 00:32:58,559
actually had to parse the string code

968
00:32:58,559 --> 00:33:00,720
do load library then get proc by name in

969
00:33:00,720 --> 00:33:02,559
order to actually grab that but now we

970
00:33:02,559 --> 00:33:05,120
had it automatically and that's it works

971
00:33:05,120 --> 00:33:07,440
perfectly and as you can see on the code

972
00:33:07,440 --> 00:33:09,600
on the right hand side that's actually

973
00:33:09,600 --> 00:33:11,360
literally the code that we use for this

974
00:33:11,360 --> 00:33:13,679
it's weirdly it looks weird i know

975
00:33:13,679 --> 00:33:15,039
because we're doing a lot of memory

976
00:33:15,039 --> 00:33:16,960
operations but like for example at the

977
00:33:16,960 --> 00:33:18,880
for loop the three lines after we're

978
00:33:18,880 --> 00:33:21,200
getting the the fnv hash of the string

979
00:33:21,200 --> 00:33:23,600
we're just like casting the string value

980
00:33:23,600 --> 00:33:26,320
to a 256 byte uh

981
00:33:26,320 --> 00:33:28,000
like array so we can just grab it from

982
00:33:28,000 --> 00:33:31,519
there then we just grab the uh the

983
00:33:31,519 --> 00:33:33,279
address of the function after that then

984
00:33:33,279 --> 00:33:35,760
we check if we need it then we just

985
00:33:35,760 --> 00:33:37,360
check if it's an exported function and

986
00:33:37,360 --> 00:33:39,760
if it is we go do that resolve that if

987
00:33:39,760 --> 00:33:42,080
it's not we just store it and that's it

988
00:33:42,080 --> 00:33:43,440
it's actually pretty simple once you

989
00:33:43,440 --> 00:33:46,240
kind of get around to it

990
00:33:46,240 --> 00:33:49,279
so and as you can see from the left and

991
00:33:49,279 --> 00:33:50,880
the right hand side so on the left hand

992
00:33:50,880 --> 00:33:53,679
side is what we had before when we had

993
00:33:53,679 --> 00:33:55,120
all of our functions loaded by string

994
00:33:55,120 --> 00:33:57,679
value and on the right side we have our

995
00:33:57,679 --> 00:34:00,080
function now loaded as their fmv hash

996
00:34:00,080 --> 00:34:02,640
value so now none of these string values

997
00:34:02,640 --> 00:34:05,039
will now be in our binary at all

998
00:34:05,039 --> 00:34:06,559
which is actually really cool so now we

999
00:34:06,559 --> 00:34:09,280
can like load like dangerous function

1000
00:34:09,280 --> 00:34:11,199
one and you know even strings for

1001
00:34:11,199 --> 00:34:12,719
dangerous function one it doesn't show

1002
00:34:12,719 --> 00:34:14,879
up

1003
00:34:15,679 --> 00:34:17,280
so i kind of remember a lot of like

1004
00:34:17,280 --> 00:34:21,040
highlights of things that um are like so

1005
00:34:21,040 --> 00:34:22,719
there's a lot of things in xmt that i

1006
00:34:22,719 --> 00:34:23,918
kind of wanted to go over but like i

1007
00:34:23,918 --> 00:34:25,679
don't have a super a lot of time so i

1008
00:34:25,679 --> 00:34:27,199
wanted to make sure i at least cover the

1009
00:34:27,199 --> 00:34:28,639
highlights of it

1010
00:34:28,639 --> 00:34:30,399
but you know what i did want to share as

1011
00:34:30,399 --> 00:34:32,159
well are some of the things that kind of

1012
00:34:32,159 --> 00:34:35,440
maybe really mash my head into the desk

1013
00:34:35,440 --> 00:34:36,960
when i was building this there's a lot

1014
00:34:36,960 --> 00:34:38,560
of those moments honestly

1015
00:34:38,560 --> 00:34:40,000
but um yeah i kind of wanted to cover

1016
00:34:40,000 --> 00:34:42,079
some of the funnier ones

1017
00:34:42,079 --> 00:34:44,239
so killing the unkillable this was a

1018
00:34:44,239 --> 00:34:45,760
really fun one

1019
00:34:45,760 --> 00:34:48,399
so the golang run time was never meant

1020
00:34:48,399 --> 00:34:50,560
to be killed it was never meant to be

1021
00:34:50,560 --> 00:34:52,960
like ended at all so like if you go

1022
00:34:52,960 --> 00:34:55,119
search for like closing the go runtime

1023
00:34:55,119 --> 00:34:56,639
on like google you get a bunch of stack

1024
00:34:56,639 --> 00:34:58,000
overflow results people like well how

1025
00:34:58,000 --> 00:34:59,760
can i close the runtime and they're like

1026
00:34:59,760 --> 00:35:02,000
good luck buddy like there is no way to

1027
00:35:02,000 --> 00:35:04,240
do it um the devs have even acknowledged

1028
00:35:04,240 --> 00:35:06,000
the fact there's like no way to do it

1029
00:35:06,000 --> 00:35:07,839
like i've looked in the code myself you

1030
00:35:07,839 --> 00:35:09,920
can't shut down the runtime so imagine

1031
00:35:09,920 --> 00:35:11,760
you had your own library legitimate

1032
00:35:11,760 --> 00:35:13,119
thing like it's like

1033
00:35:13,119 --> 00:35:17,200
legit library.dll you load it into a

1034
00:35:17,200 --> 00:35:18,960
process then you're like all right i'm

1035
00:35:18,960 --> 00:35:20,880
done you exit close all the proper

1036
00:35:20,880 --> 00:35:22,240
functions do all like the niceties that

1037
00:35:22,240 --> 00:35:23,200
windows want you to do when you're

1038
00:35:23,200 --> 00:35:25,119
unloading a dll cool

1039
00:35:25,119 --> 00:35:27,200
go back and look at that process in um

1040
00:35:27,200 --> 00:35:28,960
like task explorer process explorer

1041
00:35:28,960 --> 00:35:30,720
you'll notice the runtime's still just

1042
00:35:30,720 --> 00:35:33,440
chilling there it it didn't quit

1043
00:35:33,440 --> 00:35:35,599
and you know it might be oh this is fine

1044
00:35:35,599 --> 00:35:36,640
but like

1045
00:35:36,640 --> 00:35:38,880
when you're injecting into lsas

1046
00:35:38,880 --> 00:35:40,320
this ain't good

1047
00:35:40,320 --> 00:35:42,160
so you you wanna you know you know you

1048
00:35:42,160 --> 00:35:44,240
wanna get rid of this in some way shape

1049
00:35:44,240 --> 00:35:47,040
or form so i actually found a way to do

1050
00:35:47,040 --> 00:35:48,720
this and it's in my opinion really

1051
00:35:48,720 --> 00:35:50,880
clever we found a way to kind of clean

1052
00:35:50,880 --> 00:35:53,520
up all the go go routine functions and

1053
00:35:53,520 --> 00:35:55,359
go routine threats are going on

1054
00:35:55,359 --> 00:35:56,560
so

1055
00:35:56,560 --> 00:35:58,240
go actually doesn't keep track of its

1056
00:35:58,240 --> 00:36:00,240
threads that it creates it doesn't like

1057
00:36:00,240 --> 00:36:02,079
you go look at the code it doesn't care

1058
00:36:02,079 --> 00:36:03,920
it creates a thread closes the handle

1059
00:36:03,920 --> 00:36:07,520
all right whatever um so i was like crap

1060
00:36:07,520 --> 00:36:08,800
well how do i do this i can edit the

1061
00:36:08,800 --> 00:36:11,599
runtime which i can do that i've done it

1062
00:36:11,599 --> 00:36:13,359
i tweeted about it actually it's just

1063
00:36:13,359 --> 00:36:15,040
like i wanna add this but i know

1064
00:36:15,040 --> 00:36:17,119
nobody's gonna accept that commit um so

1065
00:36:17,119 --> 00:36:18,880
i was like okay well

1066
00:36:18,880 --> 00:36:20,560
i gotta find another way so i put on my

1067
00:36:20,560 --> 00:36:21,760
blue teamer hat and i said all right

1068
00:36:21,760 --> 00:36:23,760
well how am i gonna find a golang thread

1069
00:36:23,760 --> 00:36:26,079
inside a process so what i end up doing

1070
00:36:26,079 --> 00:36:26,800
is

1071
00:36:26,800 --> 00:36:29,040
you can actually all the golang threads

1072
00:36:29,040 --> 00:36:31,280
have the same base start address all of

1073
00:36:31,280 --> 00:36:33,680
them they literally do so if you look in

1074
00:36:33,680 --> 00:36:35,760
the at least for windows i can say this

1075
00:36:35,760 --> 00:36:37,280
if you look in the code then you look

1076
00:36:37,280 --> 00:36:40,000
you search for like create thread a

1077
00:36:40,000 --> 00:36:41,680
you go down it's the same it's the same

1078
00:36:41,680 --> 00:36:42,960
function so it's the same function

1079
00:36:42,960 --> 00:36:44,720
address every single time and you can

1080
00:36:44,720 --> 00:36:46,480
verify this by going into the process

1081
00:36:46,480 --> 00:36:48,320
explorer and looking at the threads same

1082
00:36:48,320 --> 00:36:50,160
base thread address i said okay cool

1083
00:36:50,160 --> 00:36:52,160
same base thread address

1084
00:36:52,160 --> 00:36:53,599
and the other thing is they're all

1085
00:36:53,599 --> 00:36:55,680
started roughly around the same time

1086
00:36:55,680 --> 00:36:58,320
cool so we can identify those so we say

1087
00:36:58,320 --> 00:37:00,640
all right now we enumerate through our

1088
00:37:00,640 --> 00:37:02,320
threads we say okay is it in the same

1089
00:37:02,320 --> 00:37:05,760
module as us yes cool same base address

1090
00:37:05,760 --> 00:37:07,839
cool um you know it started around the

1091
00:37:07,839 --> 00:37:10,800
same time cool all right kill it there

1092
00:37:10,800 --> 00:37:12,720
you go and then we just kill our own

1093
00:37:12,720 --> 00:37:13,680
process

1094
00:37:13,680 --> 00:37:16,160
go run time's gone so i

1095
00:37:16,160 --> 00:37:18,079
uh run this now and if you run this and

1096
00:37:18,079 --> 00:37:19,599
you look at the threat runtime is

1097
00:37:19,599 --> 00:37:21,440
cleaned so and this actually led to the

1098
00:37:21,440 --> 00:37:23,359
development of device.goexit which

1099
00:37:23,359 --> 00:37:25,280
eventually does call when api uh kill

1100
00:37:25,280 --> 00:37:27,200
runtime i'm trying to work on this for

1101
00:37:27,200 --> 00:37:28,640
linux it's a little bit harder in my

1102
00:37:28,640 --> 00:37:29,760
opinion because i have less linux

1103
00:37:29,760 --> 00:37:32,560
development experience um but on windows

1104
00:37:32,560 --> 00:37:34,079
you can just call kill runtime or go

1105
00:37:34,079 --> 00:37:36,079
exit and now it'll just completely clean

1106
00:37:36,079 --> 00:37:38,320
the go runtime and in fact i did a

1107
00:37:38,320 --> 00:37:40,400
commit literally a couple days ago to

1108
00:37:40,400 --> 00:37:43,200
fix a bug it was so good at killing the

1109
00:37:43,200 --> 00:37:45,839
go runtime that if you had two runtimes

1110
00:37:45,839 --> 00:37:47,520
loaded in a process completely for

1111
00:37:47,520 --> 00:37:49,119
different reasons like you gotta go

1112
00:37:49,119 --> 00:37:51,040
laying service running in a thing and

1113
00:37:51,040 --> 00:37:52,240
then you had a

1114
00:37:52,240 --> 00:37:54,400
injected dll and then ejected assembly

1115
00:37:54,400 --> 00:37:56,560
if you ran this it killed everything

1116
00:37:56,560 --> 00:37:58,800
which not good so i actually edited

1117
00:37:58,800 --> 00:38:00,480
edited some fixes that you know actually

1118
00:38:00,480 --> 00:38:02,640
make it only kill itself

1119
00:38:02,640 --> 00:38:03,599
so i thought that was kind of an

1120
00:38:03,599 --> 00:38:04,880
interesting way so now we can actually

1121
00:38:04,880 --> 00:38:07,520
kill the go runtime

1122
00:38:07,520 --> 00:38:10,480
uh second one crashing with style so i

1123
00:38:10,480 --> 00:38:12,480
actually had a problem that i actually

1124
00:38:12,480 --> 00:38:13,280
uh

1125
00:38:13,280 --> 00:38:14,880
blue screened a lot of boxes during a

1126
00:38:14,880 --> 00:38:17,520
ctf one time and i really didn't know

1127
00:38:17,520 --> 00:38:19,200
why and i ended up blue screening a lot

1128
00:38:19,200 --> 00:38:21,119
of my testing boxes too and i couldn't

1129
00:38:21,119 --> 00:38:23,440
figure out what the hell was going on

1130
00:38:23,440 --> 00:38:26,160
so and basically i kind of narrowed the

1131
00:38:26,160 --> 00:38:28,720
actual cost down to cfg which is control

1132
00:38:28,720 --> 00:38:30,960
flow guard in windows and this runs for

1133
00:38:30,960 --> 00:38:32,640
pretty much every operating system based

1134
00:38:32,640 --> 00:38:34,800
binary so like scope host or i don't

1135
00:38:34,800 --> 00:38:38,560
know uh colonel um lsas uh et cetera and

1136
00:38:38,560 --> 00:38:40,320
um basically strict handle checks are a

1137
00:38:40,320 --> 00:38:42,800
thing what that does is if you operate

1138
00:38:42,800 --> 00:38:44,160
on a valid handle doesn't matter what

1139
00:38:44,160 --> 00:38:47,440
you do it kills your process immediately

1140
00:38:47,440 --> 00:38:49,760
and so if you call closed handle on

1141
00:38:49,760 --> 00:38:50,720
invalid

1142
00:38:50,720 --> 00:38:51,839
uh if you call a closed handle on a

1143
00:38:51,839 --> 00:38:53,760
valid handle it still kills your process

1144
00:38:53,760 --> 00:38:55,040
which is like dude i'm just trying to

1145
00:38:55,040 --> 00:38:57,680
close the handle um which actually ended

1146
00:38:57,680 --> 00:38:59,280
up being the reason why my process was

1147
00:38:59,280 --> 00:39:02,400
crashing by the way um so and what was

1148
00:39:02,400 --> 00:39:04,079
causing it was there's a race condition

1149
00:39:04,079 --> 00:39:06,800
in the cmd process struct that the

1150
00:39:06,800 --> 00:39:09,680
process opened closed way too quickly in

1151
00:39:09,680 --> 00:39:12,960
the span of cpu time so my go run my go

1152
00:39:12,960 --> 00:39:14,800
routine that started to watch it

1153
00:39:14,800 --> 00:39:16,480
didn't start in time enough for that

1154
00:39:16,480 --> 00:39:17,920
process to close

1155
00:39:17,920 --> 00:39:20,079
then wait for single objects

1156
00:39:20,079 --> 00:39:22,640
for some reason uh not documented by the

1157
00:39:22,640 --> 00:39:25,520
way in the api documentation for windows

1158
00:39:25,520 --> 00:39:27,520
it will wait infinitely

1159
00:39:27,520 --> 00:39:30,640
for the um for the process to end er for

1160
00:39:30,640 --> 00:39:32,720
the process now because it's dead so

1161
00:39:32,720 --> 00:39:34,480
wait for a single object just waits

1162
00:39:34,480 --> 00:39:36,720
infinitely

1163
00:39:36,720 --> 00:39:39,359
so trying to close that would then you

1164
00:39:39,359 --> 00:39:41,520
would call close handle on it and that

1165
00:39:41,520 --> 00:39:42,720
would cause the crash so now you would

1166
00:39:42,720 --> 00:39:44,880
see a blue screen on your device and

1167
00:39:44,880 --> 00:39:46,960
windows wouldn't log this

1168
00:39:46,960 --> 00:39:48,480
i i couldn't get it to log it i

1169
00:39:48,480 --> 00:39:50,480
seriously there's nothing i could enable

1170
00:39:50,480 --> 00:39:52,480
like even syslog doesn't log this so

1171
00:39:52,480 --> 00:39:55,119
like i was like okay well maybe

1172
00:39:55,119 --> 00:39:56,400
there's i'm doing something weird with

1173
00:39:56,400 --> 00:39:58,079
memory because i've so done that before

1174
00:39:58,079 --> 00:39:59,920
but no and i kind of narrowed it down to

1175
00:39:59,920 --> 00:40:02,880
this so i ended up having to call uh

1176
00:40:02,880 --> 00:40:05,040
wait for multiple objects which works

1177
00:40:05,040 --> 00:40:06,160
properly

1178
00:40:06,160 --> 00:40:09,119
and we create our own event as well so

1179
00:40:09,119 --> 00:40:11,200
we now have our own event to signal so

1180
00:40:11,200 --> 00:40:13,040
that way we can actually end it properly

1181
00:40:13,040 --> 00:40:14,560
and detect that invalid handle if it

1182
00:40:14,560 --> 00:40:16,960
happens

1183
00:40:18,079 --> 00:40:21,520
last story time i have process dump woes

1184
00:40:21,520 --> 00:40:23,760
so the one api function uh midi dump

1185
00:40:23,760 --> 00:40:26,480
right dump is really weird it's really

1186
00:40:26,480 --> 00:40:27,839
weird um

1187
00:40:27,839 --> 00:40:30,960
in memory handle pipes behave oddly so i

1188
00:40:30,960 --> 00:40:32,560
actually um

1189
00:40:32,560 --> 00:40:34,079
i was using this to write a thing

1190
00:40:34,079 --> 00:40:35,359
because now you can dump process it

1191
00:40:35,359 --> 00:40:36,960
allows you have a native function dot

1192
00:40:36,960 --> 00:40:38,880
jump process memory and i was like all

1193
00:40:38,880 --> 00:40:40,640
right let's just dump process memory

1194
00:40:40,640 --> 00:40:41,760
dump across the memory and see if it

1195
00:40:41,760 --> 00:40:44,079
works um when you use it in uh it allows

1196
00:40:44,079 --> 00:40:46,160
you to specify a file handle so when you

1197
00:40:46,160 --> 00:40:47,920
specify like an in-memory file handle

1198
00:40:47,920 --> 00:40:50,480
like a memory pipe for example

1199
00:40:50,480 --> 00:40:51,359
it

1200
00:40:51,359 --> 00:40:53,760
dumps it works it drops 40 bytes off the

1201
00:40:53,760 --> 00:40:54,960
response

1202
00:40:54,960 --> 00:40:55,680
just

1203
00:40:55,680 --> 00:40:57,680
for no reason it just i

1204
00:40:57,680 --> 00:40:59,359
can't figure it out if anybody knows let

1205
00:40:59,359 --> 00:41:02,000
me know seriously but like that memory

1206
00:41:02,000 --> 00:41:04,800
pipe completes 40 bytes are gone and it

1207
00:41:04,800 --> 00:41:06,800
just val it's per those

1208
00:41:06,800 --> 00:41:09,599
bytes are important to the backup and it

1209
00:41:09,599 --> 00:41:11,520
basically invalidates it completely uh

1210
00:41:11,520 --> 00:41:13,280
which is great so

1211
00:41:13,280 --> 00:41:15,119
direct dump worked fine so i was like

1212
00:41:15,119 --> 00:41:18,000
huh so i ended up having to um work

1213
00:41:18,000 --> 00:41:20,880
using callback functions which uh

1214
00:41:20,880 --> 00:41:23,119
i actually found out about the uh i

1215
00:41:23,119 --> 00:41:24,319
actually found out about sliver and i

1216
00:41:24,319 --> 00:41:26,079
was like oh cool let me take a look at

1217
00:41:26,079 --> 00:41:26,880
what they're doing because they

1218
00:41:26,880 --> 00:41:28,319
implemented that as well and they had a

1219
00:41:28,319 --> 00:41:29,920
great example of like using that and i

1220
00:41:29,920 --> 00:41:31,440
was like all right so like i have to do

1221
00:41:31,440 --> 00:41:34,079
it this way apparently which is fun um

1222
00:41:34,079 --> 00:41:35,440
but yeah so

1223
00:41:35,440 --> 00:41:36,800
i had to basically do the long way just

1224
00:41:36,800 --> 00:41:39,680
to kind of get this to work

1225
00:41:39,680 --> 00:41:42,079
so demos

1226
00:41:42,079 --> 00:41:44,800
so i have some cool demos here wrong

1227
00:41:44,800 --> 00:41:47,920
button so i'm gonna do the second demo

1228
00:41:47,920 --> 00:41:50,160
first because my internet connection is

1229
00:41:50,160 --> 00:41:51,839
really bad in this room

1230
00:41:51,839 --> 00:41:54,000
so i apologize for that

1231
00:41:54,000 --> 00:41:55,119
so

1232
00:41:55,119 --> 00:41:58,160
okay so this is actually one of the real

1233
00:41:58,160 --> 00:42:01,440
implementations of xmt like as a proper

1234
00:42:01,440 --> 00:42:02,560
c2

1235
00:42:02,560 --> 00:42:04,800
it's called thunderstorm so thunderstorm

1236
00:42:04,800 --> 00:42:06,240
has things called bolts which are

1237
00:42:06,240 --> 00:42:08,960
implants and that this this uh c2 is

1238
00:42:08,960 --> 00:42:11,680
actually what we're using over there

1239
00:42:11,680 --> 00:42:12,480
so

1240
00:42:12,480 --> 00:42:14,400
i am go so currently there's nothing

1241
00:42:14,400 --> 00:42:16,960
here so i'm gonna go back into my

1242
00:42:16,960 --> 00:42:18,640
windows vm

1243
00:42:18,640 --> 00:42:20,400
and as you can see here there's a little

1244
00:42:20,400 --> 00:42:22,640
exe doesn't look harmless or it looks

1245
00:42:22,640 --> 00:42:27,799
harmless test exe so i'm gonna run it

1246
00:42:35,839 --> 00:42:37,119
i don't know why it didn't pop up it's

1247
00:42:37,119 --> 00:42:38,880
supposed to pop up but as you can see

1248
00:42:38,880 --> 00:42:40,640
now it shows we got a bolt here so we're

1249
00:42:40,640 --> 00:42:41,680
like cool

1250
00:42:41,680 --> 00:42:43,599
so we can actually go into it so

1251
00:42:43,599 --> 00:42:45,520
type it in and we now got interactive

1252
00:42:45,520 --> 00:42:46,480
shell

1253
00:42:46,480 --> 00:42:49,200
is that legible in the back i hope

1254
00:42:49,200 --> 00:42:50,240
um

1255
00:42:50,240 --> 00:42:53,280
so we can actually type in like net user

1256
00:42:53,280 --> 00:42:56,560
and it'll just take a sec

1257
00:42:56,560 --> 00:42:58,640
and then now the bolt has the bolt has

1258
00:42:58,640 --> 00:43:00,000
told us that we accept the job and most

1259
00:43:00,000 --> 00:43:01,920
of this is built into xmt it's just

1260
00:43:01,920 --> 00:43:03,200
literally the pretty front end is like

1261
00:43:03,200 --> 00:43:05,200
the only thing that's added onto this so

1262
00:43:05,200 --> 00:43:06,720
now we just got our output from our

1263
00:43:06,720 --> 00:43:07,680
command

1264
00:43:07,680 --> 00:43:09,839
and for example i can run channeling

1265
00:43:09,839 --> 00:43:11,839
mode that i talked about earlier

1266
00:43:11,839 --> 00:43:14,079
challenge mode says okay

1267
00:43:14,079 --> 00:43:16,319
so

1268
00:43:17,359 --> 00:43:19,760
and there you go so now we have like

1269
00:43:19,760 --> 00:43:21,839
we sort of have like direct interaction

1270
00:43:21,839 --> 00:43:23,839
with it we don't have to wait as you

1271
00:43:23,839 --> 00:43:25,760
notice there's no wait period at all for

1272
00:43:25,760 --> 00:43:28,640
it um

1273
00:43:30,319 --> 00:43:32,240
we just keep entering commands and there

1274
00:43:32,240 --> 00:43:33,920
you go so what we're going to do is

1275
00:43:33,920 --> 00:43:34,880
we're going to

1276
00:43:34,880 --> 00:43:36,960
do some other fun things

1277
00:43:36,960 --> 00:43:40,240
so now one cool thing is as we can tell

1278
00:43:40,240 --> 00:43:43,119
we go into here and type t

1279
00:43:43,119 --> 00:43:45,440
and we see test exe sitting here looking

1280
00:43:45,440 --> 00:43:47,440
all nice in our in our process list so

1281
00:43:47,440 --> 00:43:50,240
let's change that

1282
00:43:50,319 --> 00:43:53,200
so let's do a migrate so we do migrate

1283
00:43:53,200 --> 00:43:56,560
target explorer

1284
00:43:57,359 --> 00:43:59,760
exe method asm

1285
00:43:59,760 --> 00:44:01,680
and then we're going to point to a dll

1286
00:44:01,680 --> 00:44:04,240
let's test

1287
00:44:04,240 --> 00:44:07,879
make sure i have it

1288
00:44:08,079 --> 00:44:09,920
test v on yellow

1289
00:44:09,920 --> 00:44:12,960
so we're gonna hit enter

1290
00:44:14,800 --> 00:44:17,760
can't spell there you go okay so

1291
00:44:17,760 --> 00:44:19,920
now we did a migration

1292
00:44:19,920 --> 00:44:21,599
so

1293
00:44:21,599 --> 00:44:23,040
if we look

1294
00:44:23,040 --> 00:44:25,599
now across the idea is 3988 i don't

1295
00:44:25,599 --> 00:44:28,720
believe there was our one before

1296
00:44:28,880 --> 00:44:30,319
so we go back

1297
00:44:30,319 --> 00:44:32,160
it's gone

1298
00:44:32,160 --> 00:44:34,839
so we go to

1299
00:44:34,839 --> 00:44:37,359
398 so now we're running in our explorer

1300
00:44:37,359 --> 00:44:39,280
process so now we completely switch

1301
00:44:39,280 --> 00:44:41,119
contacts between process one and process

1302
00:44:41,119 --> 00:44:43,680
two and we're still running we haven't

1303
00:44:43,680 --> 00:44:45,839
switched uh we haven't lost any context

1304
00:44:45,839 --> 00:44:47,680
or anything we're still in channeling

1305
00:44:47,680 --> 00:44:49,599
mode running perfectly fine so our

1306
00:44:49,599 --> 00:44:51,200
network connection switched over to

1307
00:44:51,200 --> 00:44:53,520
explore exe and basically everything

1308
00:44:53,520 --> 00:44:55,440
else that we had the knowledge base if

1309
00:44:55,440 --> 00:44:57,920
you will uh switched over and that this

1310
00:44:57,920 --> 00:45:00,800
is still native to xmt it's not like any

1311
00:45:00,800 --> 00:45:02,480
pretty add-on that i've extended or

1312
00:45:02,480 --> 00:45:06,400
anything this is all default context

1313
00:45:06,400 --> 00:45:10,000
so let's do something uh see i can also

1314
00:45:10,000 --> 00:45:10,880
uh

1315
00:45:10,880 --> 00:45:12,720
do some other things like

1316
00:45:12,720 --> 00:45:15,359
okay windows so i can see what windows

1317
00:45:15,359 --> 00:45:16,880
on their machine there's a lot of

1318
00:45:16,880 --> 00:45:18,480
capabilities we built in like some

1319
00:45:18,480 --> 00:45:20,400
really stupid pretty stuff for windows

1320
00:45:20,400 --> 00:45:21,920
as you can see but those are some of the

1321
00:45:21,920 --> 00:45:23,200
examples

1322
00:45:23,200 --> 00:45:24,560
and let me see if i can get my wi-fi

1323
00:45:24,560 --> 00:45:27,680
working i will show you the live thing

1324
00:45:27,680 --> 00:45:30,319
because currently we have the live ctf

1325
00:45:30,319 --> 00:45:33,319
running

1326
00:45:35,200 --> 00:45:38,560
the reception in this room is really bad

1327
00:45:42,560 --> 00:45:43,440
all right

1328
00:45:43,440 --> 00:45:45,040
we'll worry about that later so

1329
00:45:45,040 --> 00:45:46,880
i can't show that demo because it's

1330
00:45:46,880 --> 00:45:49,359
really bad connected

1331
00:45:49,359 --> 00:45:50,960
it's really bad connectivity and i think

1332
00:45:50,960 --> 00:45:52,960
it's not playing nice but um these are

1333
00:45:52,960 --> 00:45:54,880
some resources that i have so we have to

1334
00:45:54,880 --> 00:45:57,599
get our repository it's just ditch.sh

1335
00:45:57,599 --> 00:45:59,680
xmt that's the direct thing all the code

1336
00:45:59,680 --> 00:46:01,200
for this by the way is public i don't i

1337
00:46:01,200 --> 00:46:02,720
don't close anything i don't believe in

1338
00:46:02,720 --> 00:46:05,680
closed source code so you know um if you

1339
00:46:05,680 --> 00:46:08,079
want to fork it or use it i don't care

1340
00:46:08,079 --> 00:46:09,920
um also thunderstorm the thing i was

1341
00:46:09,920 --> 00:46:13,119
using also all open source um as well so

1342
00:46:13,119 --> 00:46:14,640
if you ever want to use it you know just

1343
00:46:14,640 --> 00:46:16,000
for shits and giggles or you want to

1344
00:46:16,000 --> 00:46:17,520
poke at it and see how it works go for

1345
00:46:17,520 --> 00:46:19,520
it um it's at

1346
00:46:19,520 --> 00:46:21,839
sh slash ts and lastly there are some

1347
00:46:21,839 --> 00:46:23,520
other things that i looked at that

1348
00:46:23,520 --> 00:46:25,200
really helped me um

1349
00:46:25,200 --> 00:46:26,960
kind of get like a better handle on some

1350
00:46:26,960 --> 00:46:28,480
things and there was a really great talk

1351
00:46:28,480 --> 00:46:29,839
that resonated with me which was in

1352
00:46:29,839 --> 00:46:32,480
during defcon safe mode there is a talk

1353
00:46:32,480 --> 00:46:34,400
uh by ben kurtz and it was offensive

1354
00:46:34,400 --> 00:46:36,560
going uh bonanza if you haven't seen it

1355
00:46:36,560 --> 00:46:38,480
it's a really good talk i really love

1356
00:46:38,480 --> 00:46:40,319
his talk

1357
00:46:40,319 --> 00:46:42,880
so yeah uh we have about like 15 minutes

1358
00:46:42,880 --> 00:46:45,359
i can close up thank you guys for

1359
00:46:45,359 --> 00:46:47,520
listening to me rant for a little bit um

1360
00:46:47,520 --> 00:46:52,040
and then i will go for questions

1361
00:46:58,960 --> 00:47:02,760
if there is any uh

1362
00:47:11,040 --> 00:47:13,760
yeah so uh he asked um if uh if there

1363
00:47:13,760 --> 00:47:16,160
was any way that i made like uh see uh

1364
00:47:16,160 --> 00:47:18,720
cd traffic like web app traffic yes so

1365
00:47:18,720 --> 00:47:20,319
the wct listener i may not mention this

1366
00:47:20,319 --> 00:47:23,599
is my fault wc2 is basically a web http

1367
00:47:23,599 --> 00:47:26,240
c2 so it looks exactly like standard web

1368
00:47:26,240 --> 00:47:27,839
traffic if that's what you mean it

1369
00:47:27,839 --> 00:47:30,319
carries like all the default headers um

1370
00:47:30,319 --> 00:47:33,040
i did want to do like a direct get post

1371
00:47:33,040 --> 00:47:34,720
one or one that looked like looking like

1372
00:47:34,720 --> 00:47:37,280
posting images uh that's a connector i'm

1373
00:47:37,280 --> 00:47:39,280
planning to add but right now wc2 is

1374
00:47:39,280 --> 00:47:41,280
like the go-to for that so it'll do that

1375
00:47:41,280 --> 00:47:42,640
like all the proxy support and all the

1376
00:47:42,640 --> 00:47:44,720
fun junk um

1377
00:47:44,720 --> 00:47:47,200
and it will um

1378
00:47:47,200 --> 00:47:48,880
i'm missing the word here but that's the

1379
00:47:48,880 --> 00:47:50,720
one that will do that current currently

1380
00:47:50,720 --> 00:47:52,559
so there's a lot of options to it that i

1381
00:47:52,559 --> 00:47:53,920
it's more than i can explain and i'm

1382
00:47:53,920 --> 00:47:56,079
kind of a talk i feel like um but if

1383
00:47:56,079 --> 00:47:58,880
that answers your question

1384
00:48:02,480 --> 00:48:04,000
oh you're asking

1385
00:48:04,000 --> 00:48:05,839
gotcha oh you're asking does the url

1386
00:48:05,839 --> 00:48:07,599
change yes right that's what you're kind

1387
00:48:07,599 --> 00:48:11,040
of asking yeah so the text library is a

1388
00:48:11,040 --> 00:48:13,119
text uh replacement and matcher like

1389
00:48:13,119 --> 00:48:15,760
algorithm thing you can supply special

1390
00:48:15,760 --> 00:48:18,079
text routes that will do that so you can

1391
00:48:18,079 --> 00:48:19,760
say like i want a string route that

1392
00:48:19,760 --> 00:48:21,040
looks like this or i want a route that

1393
00:48:21,040 --> 00:48:22,400
looks like this so it changes every

1394
00:48:22,400 --> 00:48:24,400
single call is that what you're asking

1395
00:48:24,400 --> 00:48:26,319
yes we have support for that so yeah you

1396
00:48:26,319 --> 00:48:28,079
just have to write like a regex looking

1397
00:48:28,079 --> 00:48:30,079
string and it'll take that and then

1398
00:48:30,079 --> 00:48:32,160
parse it out as with and then the end

1399
00:48:32,160 --> 00:48:34,000
point can actually match those so you

1400
00:48:34,000 --> 00:48:35,599
can actually kind of catch blue teamers

1401
00:48:35,599 --> 00:48:36,720
trying to

1402
00:48:36,720 --> 00:48:39,520
do that so you can match on like the url

1403
00:48:39,520 --> 00:48:42,400
the header uh headers host names user

1404
00:48:42,400 --> 00:48:45,359
agents etc so um but yeah does that

1405
00:48:45,359 --> 00:48:46,720
answer that yeah

1406
00:48:46,720 --> 00:48:48,800
cool um i'm gonna try

1407
00:48:48,800 --> 00:48:50,240
the functionality that you were

1408
00:48:50,240 --> 00:48:51,920
describing under the profile section

1409
00:48:51,920 --> 00:48:53,280
that's kind of similar to football

1410
00:48:53,280 --> 00:48:54,960
strikes um

1411
00:48:54,960 --> 00:48:56,880
beacon shell um

1412
00:48:56,880 --> 00:48:59,280
would that be detectable with uh tools

1413
00:48:59,280 --> 00:49:03,119
like uh retail analysis that john

1414
00:49:04,480 --> 00:49:07,119
um so you were asking uh if the c2 uh

1415
00:49:07,119 --> 00:49:09,200
the profiles thing would be since it

1416
00:49:09,200 --> 00:49:12,319
looks like it looks like the uh see the

1417
00:49:12,319 --> 00:49:14,319
cobalt strikes uh kind of profiles

1418
00:49:14,319 --> 00:49:15,200
method

1419
00:49:15,200 --> 00:49:17,440
i don't think so if it is that's really

1420
00:49:17,440 --> 00:49:19,440
cool um i don't think so because it

1421
00:49:19,440 --> 00:49:20,559
probably sits in a different memory

1422
00:49:20,559 --> 00:49:21,839
layout and

1423
00:49:21,839 --> 00:49:23,440
for at least so for thunderstorm we

1424
00:49:23,440 --> 00:49:25,200
actually encrypt all this stuff as well

1425
00:49:25,200 --> 00:49:26,720
so it's actually xor wrapped in

1426
00:49:26,720 --> 00:49:29,200
everything in memory and after it's used

1427
00:49:29,200 --> 00:49:30,720
so i don't think it would fit i don't

1428
00:49:30,720 --> 00:49:32,240
think it would check it but if it does

1429
00:49:32,240 --> 00:49:35,839
that's awesome um but just because

1430
00:49:35,839 --> 00:49:38,640
it would be like uh

1431
00:49:41,119 --> 00:49:41,920
and we

1432
00:49:41,920 --> 00:49:43,359
yeah we do have jitter and stuff so you

1433
00:49:43,359 --> 00:49:45,680
might be able to match it on that um

1434
00:49:45,680 --> 00:49:47,680
he asked if it would he might be able to

1435
00:49:47,680 --> 00:49:49,200
match like the jitter or something which

1436
00:49:49,200 --> 00:49:51,359
yeah that could definitely match that uh

1437
00:49:51,359 --> 00:49:52,960
i would say um but i don't think it'll

1438
00:49:52,960 --> 00:49:54,640
match that traffic exactly if it does

1439
00:49:54,640 --> 00:49:55,920
you know that's pretty awesome but i

1440
00:49:55,920 --> 00:49:57,599
don't because the layout and everything

1441
00:49:57,599 --> 00:49:59,119
i don't think it exactly matches one to

1442
00:49:59,119 --> 00:50:02,480
one does that answer your question

1443
00:50:04,880 --> 00:50:06,559
blue teamers so blue teamers one of the

1444
00:50:06,559 --> 00:50:08,079
things i try to tell blue teamers all

1445
00:50:08,079 --> 00:50:10,800
the time is know your land so like know

1446
00:50:10,800 --> 00:50:12,000
what's running so i deal with a lot of

1447
00:50:12,000 --> 00:50:13,920
windows things and people forget like

1448
00:50:13,920 --> 00:50:15,680
what is actually like native on windows

1449
00:50:15,680 --> 00:50:16,880
and granted i don't expect you know

1450
00:50:16,880 --> 00:50:18,640
every dll but i want you to spot

1451
00:50:18,640 --> 00:50:20,640
inconsistencies in it like there are

1452
00:50:20,640 --> 00:50:22,800
some so i can make binaries and windows

1453
00:50:22,800 --> 00:50:24,559
that look like exactly like windows

1454
00:50:24,559 --> 00:50:26,400
binaries but there's things you can kind

1455
00:50:26,400 --> 00:50:27,040
of

1456
00:50:27,040 --> 00:50:28,160
look at like

1457
00:50:28,160 --> 00:50:30,640
that's kind of sus right there

1458
00:50:30,640 --> 00:50:31,520
okay

1459
00:50:31,520 --> 00:50:34,079
i'll give you one um so

1460
00:50:34,079 --> 00:50:35,839
a lot of people don't sign with binary

1461
00:50:35,839 --> 00:50:38,720
manifests so like examine your binary

1462
00:50:38,720 --> 00:50:40,319
manifests i've seen a lot of people

1463
00:50:40,319 --> 00:50:41,839
compile without them like resourcing is

1464
00:50:41,839 --> 00:50:43,119
becoming more popular a lot of people

1465
00:50:43,119 --> 00:50:44,720
don't resource so if you look at a

1466
00:50:44,720 --> 00:50:46,480
binary and go to its details tab that's

1467
00:50:46,480 --> 00:50:47,920
the resources of the binary so you can

1468
00:50:47,920 --> 00:50:49,680
like specify custom like values for its

1469
00:50:49,680 --> 00:50:51,920
name title description etc

1470
00:50:51,920 --> 00:50:53,520
you can analyze that first and if

1471
00:50:53,520 --> 00:50:54,800
they're smarter they'll put those in

1472
00:50:54,800 --> 00:50:56,880
there but then manifesto i think people

1473
00:50:56,880 --> 00:50:58,880
don't catch like compatibility manifest

1474
00:50:58,880 --> 00:51:00,079
process hacker too if you've ever used

1475
00:51:00,079 --> 00:51:02,000
process hacker look at it i found about

1476
00:51:02,000 --> 00:51:03,040
it last year because the blue team were

1477
00:51:03,040 --> 00:51:04,880
talking about it it's really awesome and

1478
00:51:04,880 --> 00:51:07,119
it can examine uh manifest and like

1479
00:51:07,119 --> 00:51:08,480
it'll say if it's manifested for this

1480
00:51:08,480 --> 00:51:09,920
windows like

1481
00:51:09,920 --> 00:51:12,079
um i'm running windows 10. why is this

1482
00:51:12,079 --> 00:51:14,000
program manifesto for windows 8 saying

1483
00:51:14,000 --> 00:51:16,480
it's lsas i don't know about that so you

1484
00:51:16,480 --> 00:51:17,920
know like that i would say would be a

1485
00:51:17,920 --> 00:51:21,040
first start um but also examining like

1486
00:51:21,040 --> 00:51:23,280
um you know like i used to love carbon

1487
00:51:23,280 --> 00:51:25,440
black for this is um you can examine

1488
00:51:25,440 --> 00:51:27,760
your threading and stuff like process uh

1489
00:51:27,760 --> 00:51:29,599
hollowing is a big deal that a lot of

1490
00:51:29,599 --> 00:51:32,400
people don't catch so like examine like

1491
00:51:32,400 --> 00:51:33,920
look like even process explorer be able

1492
00:51:33,920 --> 00:51:35,440
to show you like oh that thread doesn't

1493
00:51:35,440 --> 00:51:36,880
look right like notepad shouldn't have

1494
00:51:36,880 --> 00:51:38,079
more than one thread no pad single

1495
00:51:38,079 --> 00:51:39,520
threaded by the way like it shouldn't

1496
00:51:39,520 --> 00:51:41,680
have like multiple threads running in it

1497
00:51:41,680 --> 00:51:43,119
that's that kind of like answer i could

1498
00:51:43,119 --> 00:51:44,800
probably go on a lot about this like

1499
00:51:44,800 --> 00:51:47,280
like i talk a lot over there so but um i

1500
00:51:47,280 --> 00:51:49,359
hope that helps a little a little bit um

1501
00:51:49,359 --> 00:51:52,160
any other questions

1502
00:51:54,240 --> 00:51:55,839
um

1503
00:51:55,839 --> 00:51:58,960
yeah in terms of the uh payload on a

1504
00:51:58,960 --> 00:52:02,000
system do you have any options as far as

1505
00:52:02,000 --> 00:52:05,040
putting like a powershell

1506
00:52:06,160 --> 00:52:08,800
so i want to do that i don't have a

1507
00:52:08,800 --> 00:52:10,960
script and up for it i can do it um so

1508
00:52:10,960 --> 00:52:12,640
the thing you've noticed with migrate

1509
00:52:12,640 --> 00:52:14,240
i'm sorry you asked what are some of the

1510
00:52:14,240 --> 00:52:16,079
things i can use for uh loading like in

1511
00:52:16,079 --> 00:52:18,000
the initial compromise loading and um

1512
00:52:18,000 --> 00:52:19,680
you're saying about powershell loaders i

1513
00:52:19,680 --> 00:52:21,119
want to build that i haven't built that

1514
00:52:21,119 --> 00:52:23,359
yet but we can load via assembly we have

1515
00:52:23,359 --> 00:52:25,359
a there's a built-in i've i've built in

1516
00:52:25,359 --> 00:52:28,559
the srdi library into xmt at least the

1517
00:52:28,559 --> 00:52:31,520
the dll to asm loader and so you could

1518
00:52:31,520 --> 00:52:34,160
convert dlls asm on the fly and so we do

1519
00:52:34,160 --> 00:52:36,160
that a lot so that that migrate that we

1520
00:52:36,160 --> 00:52:38,000
noticed i did that all in asm but the

1521
00:52:38,000 --> 00:52:41,040
dll was an actual dll um but we have

1522
00:52:41,040 --> 00:52:42,960
that capability we have it for other

1523
00:52:42,960 --> 00:52:44,880
things so like there's a there's a

1524
00:52:44,880 --> 00:52:46,160
loader we have for thunderstorm that

1525
00:52:46,160 --> 00:52:48,319
does that like natively but not with

1526
00:52:48,319 --> 00:52:50,559
power shell it's it's on the road map i

1527
00:52:50,559 --> 00:52:54,559
guess is my answer uh does that answer

1528
00:52:58,800 --> 00:53:00,880
is

1529
00:53:12,559 --> 00:53:13,920
if you catch me around somewhere you can

1530
00:53:13,920 --> 00:53:15,440
ask me i will talk your ear off that's

1531
00:53:15,440 --> 00:53:17,280
okay um is there any other questions

1532
00:53:17,280 --> 00:53:19,200
before i close out

1533
00:53:19,200 --> 00:53:21,520
go ahead

1534
00:53:27,040 --> 00:53:28,400
i'm um

1535
00:53:28,400 --> 00:53:30,880
sorry so he has keep swapping out using

1536
00:53:30,880 --> 00:53:32,079
diffie-hellman

1537
00:53:32,079 --> 00:53:34,240
no because i'm too lazy to do that but i

1538
00:53:34,240 --> 00:53:37,359
would love to do that what

1539
00:53:37,359 --> 00:53:39,520
oh um i'm too lazy to do that i'm just

1540
00:53:39,520 --> 00:53:41,280
doing like a basic key swap and i'm

1541
00:53:41,280 --> 00:53:42,880
basically using the material on both

1542
00:53:42,880 --> 00:53:45,280
sides to do uh

1543
00:53:45,280 --> 00:53:46,880
basically basically the values only one

1544
00:53:46,880 --> 00:53:49,119
way if that makes sense so like i'm not

1545
00:53:49,119 --> 00:53:51,040
i'm not sending any of the key data like

1546
00:53:51,040 --> 00:53:52,480
at all i'm saying the basic source

1547
00:53:52,480 --> 00:53:54,559
material to generate from that but it's

1548
00:53:54,559 --> 00:53:56,240
not any any diffi helmet unfortunately

1549
00:53:56,240 --> 00:53:57,680
now

1550
00:53:57,680 --> 00:54:00,640
uh any other questions

1551
00:54:03,839 --> 00:54:05,760
uh cool so thank you guys again for

1552
00:54:05,760 --> 00:54:07,040
listening i hope you guys have a great

1553
00:54:07,040 --> 00:54:10,520
rest of your weekend

