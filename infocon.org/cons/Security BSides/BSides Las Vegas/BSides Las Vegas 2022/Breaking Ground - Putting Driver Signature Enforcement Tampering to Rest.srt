1
00:00:00,399 --> 00:00:02,720
hello everybody thank you for coming uh

2
00:00:02,720 --> 00:00:05,279
so we have omri every time omri comes to

3
00:00:05,279 --> 00:00:07,200
v sites we just make him talk because he

4
00:00:07,200 --> 00:00:08,880
does really cool stuff

5
00:00:08,880 --> 00:00:12,000
um so he's been to four here so far

6
00:00:12,000 --> 00:00:14,000
every time he comes to vegas he speaks

7
00:00:14,000 --> 00:00:15,440
uh he's going to be talking about

8
00:00:15,440 --> 00:00:17,520
installing rootkits on windows 11 so

9
00:00:17,520 --> 00:00:19,760
pretty cutting edge uh about as modern

10
00:00:19,760 --> 00:00:21,920
as it gets for what he's doing

11
00:00:21,920 --> 00:00:23,119
um

12
00:00:23,119 --> 00:00:25,920
so without further ado uh we have omri

13
00:00:25,920 --> 00:00:29,320
thank you for coming

14
00:00:31,279 --> 00:00:33,920
hi everyone

15
00:00:35,040 --> 00:00:37,040
thank you for coming i believe we are

16
00:00:37,040 --> 00:00:39,840
wrapping up today

17
00:00:39,840 --> 00:00:40,640
as

18
00:00:40,640 --> 00:00:42,800
i was introduced my name is omri

19
00:00:42,800 --> 00:00:47,520
i'm currently in charge of the security

20
00:00:47,520 --> 00:00:49,520
research

21
00:00:49,520 --> 00:00:51,840
in fortinet's r d

22
00:00:51,840 --> 00:00:53,440
site in israel

23
00:00:53,440 --> 00:00:55,600
and

24
00:00:55,600 --> 00:00:56,800
sorry

25
00:00:56,800 --> 00:00:58,800
yeah okay

26
00:00:58,800 --> 00:00:59,680
great

27
00:00:59,680 --> 00:01:01,120
um

28
00:01:01,120 --> 00:01:02,719
most of my work is around endpoint

29
00:01:02,719 --> 00:01:06,159
security um as i as

30
00:01:06,159 --> 00:01:08,000
i was introduced again i was i'm not the

31
00:01:08,000 --> 00:01:09,840
first it's not the first time i speak

32
00:01:09,840 --> 00:01:10,799
here

33
00:01:10,799 --> 00:01:13,600
and i've spoken in a few other besides

34
00:01:13,600 --> 00:01:15,600
events

35
00:01:15,600 --> 00:01:18,400
in other places as well

36
00:01:18,400 --> 00:01:19,840
what we're going to talk about today is

37
00:01:19,840 --> 00:01:22,880
a bit of a background and introduction

38
00:01:22,880 --> 00:01:26,240
about driver signing

39
00:01:26,240 --> 00:01:27,759
enforcement

40
00:01:27,759 --> 00:01:30,720
a bit how it's been being protected

41
00:01:30,720 --> 00:01:32,079
on windows

42
00:01:32,079 --> 00:01:34,640
and a couple of new techniques that we

43
00:01:34,640 --> 00:01:37,200
found in order to bypass those new

44
00:01:37,200 --> 00:01:38,960
protections

45
00:01:38,960 --> 00:01:42,240
and uh hopefully uh we'll show the live

46
00:01:42,240 --> 00:01:43,920
demos and everything will work without

47
00:01:43,920 --> 00:01:45,040
an each

48
00:01:45,040 --> 00:01:47,360
and then we'll talk about some

49
00:01:47,360 --> 00:01:50,159
suggestions that we have in order to

50
00:01:50,159 --> 00:01:51,360
prevent that

51
00:01:51,360 --> 00:01:55,040
and we'll give you a quick summary of

52
00:01:55,040 --> 00:01:58,560
basically everything we covered

53
00:01:59,040 --> 00:02:01,600
okay i'll just start off with a warning

54
00:02:01,600 --> 00:02:02,479
um

55
00:02:02,479 --> 00:02:04,320
what you're going to see here today is

56
00:02:04,320 --> 00:02:06,399
going to be rough and not because of the

57
00:02:06,399 --> 00:02:08,560
content it's because i do my own slides

58
00:02:08,560 --> 00:02:12,239
and i'm really really bad in photoshop

59
00:02:12,239 --> 00:02:15,680
so i apologize in advance

60
00:02:16,319 --> 00:02:18,720
so okay here we go

61
00:02:18,720 --> 00:02:20,000
basically

62
00:02:20,000 --> 00:02:22,000
what is driver signing enforcement or in

63
00:02:22,000 --> 00:02:23,440
short dsc

64
00:02:23,440 --> 00:02:25,840
uh coding trade integrity basically is a

65
00:02:25,840 --> 00:02:28,720
feature that has been introduced over 15

66
00:02:28,720 --> 00:02:31,200
years ago

67
00:02:31,200 --> 00:02:33,519
for drivers it means that

68
00:02:33,519 --> 00:02:35,360
basically you have to sign them in order

69
00:02:35,360 --> 00:02:36,879
for you to be able to

70
00:02:36,879 --> 00:02:40,160
load them into memory and execute them

71
00:02:40,160 --> 00:02:41,599
every time you want to do it they are

72
00:02:41,599 --> 00:02:44,000
being checked and validated and

73
00:02:44,000 --> 00:02:45,599
basically it gives you the option to

74
00:02:45,599 --> 00:02:47,200
improve the security of the operating

75
00:02:47,200 --> 00:02:49,680
system because then you can know once

76
00:02:49,680 --> 00:02:52,000
they're signed from where they came from

77
00:02:52,000 --> 00:02:53,920
and there is some assurance that they

78
00:02:53,920 --> 00:02:55,599
haven't been modified

79
00:02:55,599 --> 00:02:58,080
when they got to you

80
00:02:58,080 --> 00:03:00,560
the way it works is um

81
00:03:00,560 --> 00:03:02,800
during uh that basically

82
00:03:02,800 --> 00:03:04,640
the windows kernel when it starts

83
00:03:04,640 --> 00:03:05,680
running

84
00:03:05,680 --> 00:03:10,239
it uses another library called ci dll

85
00:03:10,239 --> 00:03:12,800
when it starts running and the

86
00:03:12,800 --> 00:03:14,879
machine boots

87
00:03:14,879 --> 00:03:17,120
basically it goes

88
00:03:17,120 --> 00:03:18,879
from

89
00:03:18,879 --> 00:03:21,040
the call flow you see on the left

90
00:03:21,040 --> 00:03:22,959
and eventually

91
00:03:22,959 --> 00:03:24,480
it said some

92
00:03:24,480 --> 00:03:27,040
global flag that says it's enabled and

93
00:03:27,040 --> 00:03:28,080
then

94
00:03:28,080 --> 00:03:29,200
calls

95
00:03:29,200 --> 00:03:34,319
ci dll with the ci initialize function

96
00:03:34,480 --> 00:03:37,200
giving it a pointer to a callback

97
00:03:37,200 --> 00:03:38,400
structure

98
00:03:38,400 --> 00:03:41,280
that that ci will initialize

99
00:03:41,280 --> 00:03:43,040
and set

100
00:03:43,040 --> 00:03:45,120
addresses of callbacks to it

101
00:03:45,120 --> 00:03:48,080
and it will set another internal flag

102
00:03:48,080 --> 00:03:50,879
the ci options that will state that it's

103
00:03:50,879 --> 00:03:53,440
also on

104
00:03:54,159 --> 00:03:56,799
then when you come to load the driver

105
00:03:56,799 --> 00:03:58,879
basically the operating system

106
00:03:58,879 --> 00:04:01,200
before it maps it into memory will

107
00:04:01,200 --> 00:04:02,799
validate

108
00:04:02,799 --> 00:04:04,879
the driver the signature itself on the

109
00:04:04,879 --> 00:04:09,040
driver it will call eventually

110
00:04:09,040 --> 00:04:11,840
two functions and validate the image

111
00:04:11,840 --> 00:04:14,799
adder and validate image data those are

112
00:04:14,799 --> 00:04:17,199
wrappers basically that will eventually

113
00:04:17,199 --> 00:04:18,798
cause the idl

114
00:04:18,798 --> 00:04:19,519
and

115
00:04:19,519 --> 00:04:21,759
on the right hand side we can see an

116
00:04:21,759 --> 00:04:23,040
example of

117
00:04:23,040 --> 00:04:25,759
the disassembly of one of those wrappers

118
00:04:25,759 --> 00:04:27,360
all he does is check

119
00:04:27,360 --> 00:04:28,479
the flags

120
00:04:28,479 --> 00:04:30,560
and check the global flag to see that

121
00:04:30,560 --> 00:04:33,759
the ci is that dst is actually enabled

122
00:04:33,759 --> 00:04:36,639
and uh check the the callback the

123
00:04:36,639 --> 00:04:38,479
specific object it

124
00:04:38,479 --> 00:04:41,199
it wraps is actually valid and not null

125
00:04:41,199 --> 00:04:42,720
and then

126
00:04:42,720 --> 00:04:44,160
it will just call it

127
00:04:44,160 --> 00:04:46,880
simple as that

128
00:04:47,440 --> 00:04:49,280
now there have been a few changes what

129
00:04:49,280 --> 00:04:52,320
i've described is pretty much uh

130
00:04:52,320 --> 00:04:54,320
how it looks on windows 7 which is

131
00:04:54,320 --> 00:04:58,000
pretty old by now along all the

132
00:04:58,000 --> 00:05:01,199
a few years later

133
00:05:01,199 --> 00:05:03,840
basically from one version one os

134
00:05:03,840 --> 00:05:05,759
version to another there have been

135
00:05:05,759 --> 00:05:07,520
slight changes

136
00:05:07,520 --> 00:05:09,520
from windows 8 we no longer have the

137
00:05:09,520 --> 00:05:12,000
global variable in the kernel itself

138
00:05:12,000 --> 00:05:14,160
only in cidl

139
00:05:14,160 --> 00:05:16,240
the callback structure

140
00:05:16,240 --> 00:05:18,639
also changed a bit they added

141
00:05:18,639 --> 00:05:20,479
a few other

142
00:05:20,479 --> 00:05:22,880
callbacks and some

143
00:05:22,880 --> 00:05:24,960
of the important callbacks that we

144
00:05:24,960 --> 00:05:26,240
mentioned before

145
00:05:26,240 --> 00:05:29,199
and the placement in the the structure

146
00:05:29,199 --> 00:05:30,720
changed but

147
00:05:30,720 --> 00:05:31,919
essentially

148
00:05:31,919 --> 00:05:34,160
those those callbacks are still

149
00:05:34,160 --> 00:05:35,759
still there

150
00:05:35,759 --> 00:05:38,479
and one other major thing is that

151
00:05:38,479 --> 00:05:39,440
uh

152
00:05:39,440 --> 00:05:41,199
basically now when

153
00:05:41,199 --> 00:05:43,440
the signature is validated

154
00:05:43,440 --> 00:05:46,160
then only this the image adder callback

155
00:05:46,160 --> 00:05:46,800
is

156
00:05:46,800 --> 00:05:49,039
a divided image header kodak is being

157
00:05:49,039 --> 00:05:52,039
used

158
00:05:52,400 --> 00:05:55,840
so um how do you pass bypass other

159
00:05:55,840 --> 00:05:57,600
bypass code integrity

160
00:05:57,600 --> 00:05:58,880
um so

161
00:05:58,880 --> 00:06:00,639
the easiest thing to do

162
00:06:00,639 --> 00:06:02,800
the most straightforward thing to do is

163
00:06:02,800 --> 00:06:06,319
use the digital certificate to just sign

164
00:06:06,319 --> 00:06:08,400
your payload

165
00:06:08,400 --> 00:06:11,360
either that you steal it or if you

166
00:06:11,360 --> 00:06:14,000
somehow trick some certificate authority

167
00:06:14,000 --> 00:06:14,960
to issue

168
00:06:14,960 --> 00:06:17,919
you such a certificate then you just you

169
00:06:17,919 --> 00:06:19,440
can just do it

170
00:06:19,440 --> 00:06:21,440
the other

171
00:06:21,440 --> 00:06:24,319
option is basically use some exploit and

172
00:06:24,319 --> 00:06:26,400
gain

173
00:06:26,400 --> 00:06:29,199
code execution in kernel usually

174
00:06:29,199 --> 00:06:31,600
some shell code or warp chain and then

175
00:06:31,600 --> 00:06:33,199
you can just

176
00:06:33,199 --> 00:06:35,360
load up your driver if you want to

177
00:06:35,360 --> 00:06:36,800
reflectively

178
00:06:36,800 --> 00:06:40,080
but it introduces some complexities

179
00:06:40,080 --> 00:06:41,600
and but

180
00:06:41,600 --> 00:06:43,360
so the last option that we have is

181
00:06:43,360 --> 00:06:44,639
basically just

182
00:06:44,639 --> 00:06:47,120
turn off driver signing enforcement on

183
00:06:47,120 --> 00:06:49,120
time and then load up the either and

184
00:06:49,120 --> 00:06:51,199
continue

185
00:06:51,199 --> 00:06:54,160
how is how it's actually being done as i

186
00:06:54,160 --> 00:06:55,759
said it's just

187
00:06:55,759 --> 00:06:57,360
flipping some flag

188
00:06:57,360 --> 00:06:59,599
um so one of the flags

189
00:06:59,599 --> 00:07:01,199
basically is being changed or run time

190
00:07:01,199 --> 00:07:02,880
you write to it you write to it and

191
00:07:02,880 --> 00:07:04,800
change the its value

192
00:07:04,800 --> 00:07:07,360
since it's not exported we need to find

193
00:07:07,360 --> 00:07:10,080
it somehow so

194
00:07:10,080 --> 00:07:12,639
basically there are simple

195
00:07:12,639 --> 00:07:14,960
a pattern that you can search for and

196
00:07:14,960 --> 00:07:17,680
then you can find those flags this is

197
00:07:17,680 --> 00:07:19,120
how it's being done

198
00:07:19,120 --> 00:07:22,880
um right now by some apt groups

199
00:07:22,880 --> 00:07:25,440
then you overwrite the value

200
00:07:25,440 --> 00:07:26,319
and

201
00:07:26,319 --> 00:07:28,639
you just load your onsite driver

202
00:07:28,639 --> 00:07:31,680
and once you're done and your driver or

203
00:07:31,680 --> 00:07:33,919
wood kit is loaded uh basically you have

204
00:07:33,919 --> 00:07:37,680
to quickly restore uh the flag because

205
00:07:37,680 --> 00:07:39,199
you want to avoid

206
00:07:39,199 --> 00:07:41,039
some protections like a patch guard that

207
00:07:41,039 --> 00:07:43,280
will cover in a bit

208
00:07:43,280 --> 00:07:45,919
the way that you get

209
00:07:45,919 --> 00:07:48,160
the ability to write to the kernel

210
00:07:48,160 --> 00:07:50,400
is

211
00:07:50,479 --> 00:07:53,280
usually by bringing your own

212
00:07:53,280 --> 00:07:55,120
signed driver

213
00:07:55,120 --> 00:07:57,680
or bring your own vulnerable driver and

214
00:07:57,680 --> 00:07:59,919
just use it in order to load it first

215
00:07:59,919 --> 00:08:02,240
because it is signed and then it will

216
00:08:02,240 --> 00:08:03,599
bypass the

217
00:08:03,599 --> 00:08:06,319
it will just go through the check uh

218
00:08:06,319 --> 00:08:08,720
sorry just just go for the check

219
00:08:08,720 --> 00:08:09,599
and

220
00:08:09,599 --> 00:08:11,440
the validation and then you can just use

221
00:08:11,440 --> 00:08:13,199
it to read and write to the kernel or

222
00:08:13,199 --> 00:08:14,720
wherever you want

223
00:08:14,720 --> 00:08:17,120
and then you can just flip the bits with

224
00:08:17,120 --> 00:08:19,360
it and load your the rest of your

225
00:08:19,360 --> 00:08:21,840
payload

226
00:08:21,919 --> 00:08:25,599
so in recent years there have been

227
00:08:25,599 --> 00:08:27,840
quite a lot of uh

228
00:08:27,840 --> 00:08:29,120
cases that

229
00:08:29,120 --> 00:08:33,120
use dc tampering um all of the we can

230
00:08:33,120 --> 00:08:36,000
see some of the statistics here um in

231
00:08:36,000 --> 00:08:38,320
the last couple of years

232
00:08:38,320 --> 00:08:39,360
basically

233
00:08:39,360 --> 00:08:41,519
there was quite a lot there's a bit of a

234
00:08:41,519 --> 00:08:44,399
spike here uh from an average of uh one

235
00:08:44,399 --> 00:08:45,279
a year

236
00:08:45,279 --> 00:08:46,880
uh one group a year that is being

237
00:08:46,880 --> 00:08:49,120
reported on we got to an average of

238
00:08:49,120 --> 00:08:50,000
about

239
00:08:50,000 --> 00:08:51,440
five and a half

240
00:08:51,440 --> 00:08:53,120
um

241
00:08:53,120 --> 00:08:55,680
so it's it's quite a lot

242
00:08:55,680 --> 00:08:58,640
uh in light of this critical attack path

243
00:08:58,640 --> 00:09:00,720
microsoft did try to

244
00:09:00,720 --> 00:09:03,920
uh mitigate it and fight against it

245
00:09:03,920 --> 00:09:05,680
and the first thing is the first

246
00:09:05,680 --> 00:09:07,680
protection that was used

247
00:09:07,680 --> 00:09:10,399
is a patch guard

248
00:09:10,399 --> 00:09:12,480
again it's quite

249
00:09:12,480 --> 00:09:15,360
quite an old feature it prevents from

250
00:09:15,360 --> 00:09:18,320
modifying the kernel or its code for

251
00:09:18,320 --> 00:09:20,399
long periods of time

252
00:09:20,399 --> 00:09:24,080
once it detects some change it basically

253
00:09:24,080 --> 00:09:24,959
will

254
00:09:24,959 --> 00:09:27,040
cause a blue screen and then

255
00:09:27,040 --> 00:09:29,600
what will make the system

256
00:09:29,600 --> 00:09:31,920
stop

257
00:09:32,399 --> 00:09:33,200
but

258
00:09:33,200 --> 00:09:35,440
in every

259
00:09:35,440 --> 00:09:37,120
in every with every new release of

260
00:09:37,120 --> 00:09:38,080
windows

261
00:09:38,080 --> 00:09:39,200
basically

262
00:09:39,200 --> 00:09:41,760
it's being improved and

263
00:09:41,760 --> 00:09:44,480
from windows 8 again

264
00:09:44,480 --> 00:09:46,640
it started protecting

265
00:09:46,640 --> 00:09:49,279
code integrity and the driver signing

266
00:09:49,279 --> 00:09:51,760
enforcement

267
00:09:51,760 --> 00:09:54,160
the next protection that microsoft tried

268
00:09:54,160 --> 00:09:56,399
to introduce is

269
00:09:56,399 --> 00:09:59,360
the signing policy itself

270
00:09:59,360 --> 00:10:02,880
so first off you can just sign

271
00:10:02,880 --> 00:10:06,160
you can just use any certificate to sign

272
00:10:06,160 --> 00:10:09,120
your driver uh you have to acquire a

273
00:10:09,120 --> 00:10:12,240
certificate from a specific subset of

274
00:10:12,240 --> 00:10:14,399
public series

275
00:10:14,399 --> 00:10:17,200
um so that pretty much prevents you of

276
00:10:17,200 --> 00:10:18,800
like installing your own ci on the

277
00:10:18,800 --> 00:10:21,360
machine and running your driver

278
00:10:21,360 --> 00:10:24,000
and then from windows 10

279
00:10:24,000 --> 00:10:27,200
they did a bit of a radical change here

280
00:10:27,200 --> 00:10:29,360
and they force you to

281
00:10:29,360 --> 00:10:31,519
provide

282
00:10:31,519 --> 00:10:34,560
their your driver to them in order for

283
00:10:34,560 --> 00:10:37,600
them to place for them as microsoft to

284
00:10:37,600 --> 00:10:41,040
sign your driver uh themselves

285
00:10:41,040 --> 00:10:43,279
so it's not only that you signed it but

286
00:10:43,279 --> 00:10:45,120
they have to sign it as well

287
00:10:45,120 --> 00:10:47,360
and if you are

288
00:10:47,360 --> 00:10:48,720
an attacker

289
00:10:48,720 --> 00:10:50,480
you don't really want to hand out your

290
00:10:50,480 --> 00:10:53,200
payload to the defender it's not

291
00:10:53,200 --> 00:10:55,200
not exactly something that

292
00:10:55,200 --> 00:10:56,959
you're aiming for

293
00:10:56,959 --> 00:10:58,720
usually you try to do the exact opposite

294
00:10:58,720 --> 00:11:02,560
of it and

295
00:11:02,560 --> 00:11:04,399
but still

296
00:11:04,399 --> 00:11:05,519
he didn't

297
00:11:05,519 --> 00:11:08,560
he didn't really

298
00:11:08,720 --> 00:11:10,880
really help because

299
00:11:10,880 --> 00:11:12,560
there are already drivers that are

300
00:11:12,560 --> 00:11:14,800
signed and you can they can be abused

301
00:11:14,800 --> 00:11:16,480
as we said

302
00:11:16,480 --> 00:11:19,040
so for that basically microsoft

303
00:11:19,040 --> 00:11:20,880
implemented a block list

304
00:11:20,880 --> 00:11:21,760
um

305
00:11:21,760 --> 00:11:22,800
just

306
00:11:22,800 --> 00:11:24,880
just in order to make it harder

307
00:11:24,880 --> 00:11:27,120
to gain that right

308
00:11:27,120 --> 00:11:29,760
that kernel right primitive

309
00:11:29,760 --> 00:11:32,560
it's enforced via windows defender

310
00:11:32,560 --> 00:11:34,640
application control

311
00:11:34,640 --> 00:11:37,200
but the downside for it is that

312
00:11:37,200 --> 00:11:39,279
basically if you got a new vulnerable

313
00:11:39,279 --> 00:11:41,680
driver that you're not aware of

314
00:11:41,680 --> 00:11:44,480
so attackers can just find some new

315
00:11:44,480 --> 00:11:46,959
samples like that and use that

316
00:11:46,959 --> 00:11:51,839
so it's really not a proactive measure

317
00:11:52,240 --> 00:11:53,920
the newest

318
00:11:53,920 --> 00:11:55,600
mitigation the newest protection that

319
00:11:55,600 --> 00:11:57,600
microsoft tried to use is basically it's

320
00:11:57,600 --> 00:12:02,480
called the kdp or canon data protection

321
00:12:02,639 --> 00:12:05,040
basically it uses the

322
00:12:05,040 --> 00:12:07,600
newest and more advanced features

323
00:12:07,600 --> 00:12:10,880
for virtualization-based security

324
00:12:10,880 --> 00:12:13,120
also known as vbs

325
00:12:13,120 --> 00:12:15,680
and leverage the the fact that

326
00:12:15,680 --> 00:12:17,600
now the kernel cannot do whatever he

327
00:12:17,600 --> 00:12:20,079
wants inside the

328
00:12:20,079 --> 00:12:21,360
inside of

329
00:12:21,360 --> 00:12:22,800
kernel space

330
00:12:22,800 --> 00:12:24,800
but he has another

331
00:12:24,800 --> 00:12:26,639
um

332
00:12:26,639 --> 00:12:28,800
another virtual machine that he has to

333
00:12:28,800 --> 00:12:31,120
cooperate with it's called the secure

334
00:12:31,120 --> 00:12:32,160
kernel

335
00:12:32,160 --> 00:12:33,760
um

336
00:12:33,760 --> 00:12:36,560
so basically drivers of every software

337
00:12:36,560 --> 00:12:39,279
in the kernel can now request

338
00:12:39,279 --> 00:12:41,200
from that secure colonel

339
00:12:41,200 --> 00:12:42,959
to basically

340
00:12:42,959 --> 00:12:45,200
remove the right permissions from

341
00:12:45,200 --> 00:12:47,600
certain locations in memory that he

342
00:12:47,600 --> 00:12:48,639
wants to

343
00:12:48,639 --> 00:12:50,639
keep as read only

344
00:12:50,639 --> 00:12:53,600
and hypervisor will basically enforce

345
00:12:53,600 --> 00:12:56,560
uh those protections

346
00:12:56,560 --> 00:12:58,399
but what's important to note to note

347
00:12:58,399 --> 00:13:00,720
here is it does it only for this the

348
00:13:00,720 --> 00:13:01,920
permissions

349
00:13:01,920 --> 00:13:04,160
not not for the mapping between

350
00:13:04,160 --> 00:13:06,639
uh the virtual address space and the

351
00:13:06,639 --> 00:13:10,720
physical address space at the end

352
00:13:10,720 --> 00:13:14,720
how it looks like in windows 11 so

353
00:13:14,720 --> 00:13:17,120
ci dll was opted in

354
00:13:17,120 --> 00:13:19,680
basically some programming in microsoft

355
00:13:19,680 --> 00:13:22,399
some developer went to the code base and

356
00:13:22,399 --> 00:13:23,360
added

357
00:13:23,360 --> 00:13:25,279
another api call

358
00:13:25,279 --> 00:13:27,440
as you can see here now ci options is

359
00:13:27,440 --> 00:13:29,440
being protected

360
00:13:29,440 --> 00:13:32,800
and the flag itself was moved the

361
00:13:32,800 --> 00:13:36,720
variable itself was moved to its own um

362
00:13:36,720 --> 00:13:39,040
its own separate and

363
00:13:39,040 --> 00:13:41,760
new section in the pe

364
00:13:41,760 --> 00:13:44,639
and basically

365
00:13:44,639 --> 00:13:47,839
it's it's all the and all with all along

366
00:13:47,839 --> 00:13:50,160
with all the data that needs to be

367
00:13:50,160 --> 00:13:54,959
used for the driver signing enforcement

368
00:13:55,199 --> 00:13:56,560
so

369
00:13:56,560 --> 00:13:59,440
let's talk about our new techniques now

370
00:13:59,440 --> 00:14:01,680
if we need to recap for a second the

371
00:14:01,680 --> 00:14:03,600
tampering procedure

372
00:14:03,600 --> 00:14:06,160
basically we first locate whatever we

373
00:14:06,160 --> 00:14:07,040
need to

374
00:14:07,040 --> 00:14:08,720
find whatever internal variable we need

375
00:14:08,720 --> 00:14:13,120
to find and then we overwrite it

376
00:14:13,120 --> 00:14:15,519
then we go to load our driver and revert

377
00:14:15,519 --> 00:14:16,880
the state

378
00:14:16,880 --> 00:14:19,120
and we'll focus on those two initial

379
00:14:19,120 --> 00:14:20,880
steps because those are what's matter

380
00:14:20,880 --> 00:14:23,040
here

381
00:14:23,040 --> 00:14:24,880
the first technique

382
00:14:24,880 --> 00:14:28,240
we called it page swapping it's very

383
00:14:28,240 --> 00:14:30,959
not very creative but kind of explain

384
00:14:30,959 --> 00:14:32,079
what he does

385
00:14:32,079 --> 00:14:35,199
um so instead of

386
00:14:35,199 --> 00:14:38,160
changing the value of the page um let's

387
00:14:38,160 --> 00:14:41,440
just point the page to another page and

388
00:14:41,440 --> 00:14:43,120
just this is how we're going to change

389
00:14:43,120 --> 00:14:44,800
the value

390
00:14:44,800 --> 00:14:48,320
and if we have the ci policy page

391
00:14:48,320 --> 00:14:50,959
if we can see the mapping here

392
00:14:50,959 --> 00:14:53,360
and the permissions on the pt is

393
00:14:53,360 --> 00:14:56,160
basically every every right we try to do

394
00:14:56,160 --> 00:14:58,480
to it won't matter

395
00:14:58,480 --> 00:15:01,360
but instead we can allocate can create a

396
00:15:01,360 --> 00:15:03,040
new page

397
00:15:03,040 --> 00:15:04,880
that we'll own

398
00:15:04,880 --> 00:15:07,839
and it will have the right permissions

399
00:15:07,839 --> 00:15:10,160
and we can set the value that we want

400
00:15:10,160 --> 00:15:11,120
for

401
00:15:11,120 --> 00:15:12,560
driver signing enforcement to be

402
00:15:12,560 --> 00:15:14,240
disabled

403
00:15:14,240 --> 00:15:17,839
but this still doesn't affect

404
00:15:17,839 --> 00:15:20,800
the dll doesn't affect the idle and we

405
00:15:20,800 --> 00:15:22,959
need to change how the virtual address

406
00:15:22,959 --> 00:15:25,359
mapping

407
00:15:25,680 --> 00:15:28,399
so all we need to do is change the pfn

408
00:15:28,399 --> 00:15:29,920
uh to point

409
00:15:29,920 --> 00:15:32,639
uh to a different physical page

410
00:15:32,639 --> 00:15:34,720
and the rest

411
00:15:34,720 --> 00:15:36,720
will do it the rest will just work the

412
00:15:36,720 --> 00:15:38,639
same

413
00:15:38,639 --> 00:15:39,600
um

414
00:15:39,600 --> 00:15:41,279
okay

415
00:15:41,279 --> 00:15:42,480
so

416
00:15:42,480 --> 00:15:44,639
how can we actually do it

417
00:15:44,639 --> 00:15:46,720
we just explained it in very high level

418
00:15:46,720 --> 00:15:47,839
terms

419
00:15:47,839 --> 00:15:49,839
we need to be able to access the page

420
00:15:49,839 --> 00:15:50,880
tables

421
00:15:50,880 --> 00:15:53,199
um those are fine those are found in the

422
00:15:53,199 --> 00:15:56,399
in a space called pte space in the in

423
00:15:56,399 --> 00:15:59,519
the kernel mode in killer space sorry

424
00:15:59,519 --> 00:16:02,160
and basically in that area we can access

425
00:16:02,160 --> 00:16:04,800
the ptes directly

426
00:16:04,800 --> 00:16:07,199
using the virtual addresses

427
00:16:07,199 --> 00:16:09,279
it really cuts down on the number of the

428
00:16:09,279 --> 00:16:12,240
reads and writes we need to do

429
00:16:12,240 --> 00:16:14,720
for inform user space to kernel and

430
00:16:14,720 --> 00:16:16,639
because we can just calculate everything

431
00:16:16,639 --> 00:16:17,279
in

432
00:16:17,279 --> 00:16:20,720
pretty much everything in advance

433
00:16:20,959 --> 00:16:23,839
and it really simplifies the

434
00:16:23,839 --> 00:16:26,079
implementation of the technique

435
00:16:26,079 --> 00:16:27,680
um now

436
00:16:27,680 --> 00:16:30,320
from windows 10 um

437
00:16:30,320 --> 00:16:33,440
the pt is based are basically randomized

438
00:16:33,440 --> 00:16:34,800
in the memory

439
00:16:34,800 --> 00:16:36,800
due to kslr

440
00:16:36,800 --> 00:16:40,160
but luckily for us we already

441
00:16:40,160 --> 00:16:42,320
presented some old research here in

442
00:16:42,320 --> 00:16:43,600
these sites

443
00:16:43,600 --> 00:16:44,639
that we show

444
00:16:44,639 --> 00:16:46,720
how we with a single

445
00:16:46,720 --> 00:16:47,920
kernel read

446
00:16:47,920 --> 00:16:49,680
basically we can find

447
00:16:49,680 --> 00:16:52,000
the new

448
00:16:52,000 --> 00:16:54,240
pte base

449
00:16:54,240 --> 00:16:56,079
basically there is an exported function

450
00:16:56,079 --> 00:16:57,279
in the kernel

451
00:16:57,279 --> 00:16:59,279
that holds

452
00:16:59,279 --> 00:17:02,079
the the address so we can just

453
00:17:02,079 --> 00:17:03,759
find it's a

454
00:17:03,759 --> 00:17:05,439
find

455
00:17:05,439 --> 00:17:06,240
its

456
00:17:06,240 --> 00:17:08,959
address of the function and then go to

457
00:17:08,959 --> 00:17:12,640
the offset and read from it the new

458
00:17:12,640 --> 00:17:15,919
randomized base

459
00:17:16,319 --> 00:17:17,280
so

460
00:17:17,280 --> 00:17:18,720
if we go again

461
00:17:18,720 --> 00:17:20,640
about the technique uh we need to

462
00:17:20,640 --> 00:17:22,640
allocate a new writable page in the

463
00:17:22,640 --> 00:17:23,919
kernel

464
00:17:23,919 --> 00:17:27,199
then we need to find ci options

465
00:17:27,199 --> 00:17:30,240
the flag just as we did before

466
00:17:30,240 --> 00:17:32,880
this is you this is done exactly as it's

467
00:17:32,880 --> 00:17:35,520
being done in the wild and nothing new

468
00:17:35,520 --> 00:17:38,160
new in this area

469
00:17:38,160 --> 00:17:39,679
then we're going to get we're going to

470
00:17:39,679 --> 00:17:42,000
read the new pte base

471
00:17:42,000 --> 00:17:44,080
and we're going to read

472
00:17:44,080 --> 00:17:45,520
pt

473
00:17:45,520 --> 00:17:47,280
for the

474
00:17:47,280 --> 00:17:48,320
flag

475
00:17:48,320 --> 00:17:50,320
for the flex page

476
00:17:50,320 --> 00:17:51,280
and

477
00:17:51,280 --> 00:17:52,720
read the pt

478
00:17:52,720 --> 00:17:55,360
for our page

479
00:17:55,360 --> 00:17:57,360
and from there we need to copy the

480
00:17:57,360 --> 00:18:00,400
entire page um

481
00:18:00,400 --> 00:18:02,640
from the old one and

482
00:18:02,640 --> 00:18:05,679
from the dll to ours and so

483
00:18:05,679 --> 00:18:08,559
nothing else we will break

484
00:18:08,559 --> 00:18:11,280
then we need to modify ci options in

485
00:18:11,280 --> 00:18:15,200
order to disable it in our new page

486
00:18:15,200 --> 00:18:17,520
and then we just swap the pfns as we

487
00:18:17,520 --> 00:18:20,160
talked about before

488
00:18:20,160 --> 00:18:21,600
load the driver

489
00:18:21,600 --> 00:18:24,000
and restore the original

490
00:18:24,000 --> 00:18:26,000
fn later on

491
00:18:26,000 --> 00:18:27,679
so this is

492
00:18:27,679 --> 00:18:30,640
a bit complicated

493
00:18:30,640 --> 00:18:32,799
i wasn't very happy with this

494
00:18:32,799 --> 00:18:34,559
it requires a lot of reads and writes

495
00:18:34,559 --> 00:18:36,000
into the kernel

496
00:18:36,000 --> 00:18:38,640
and it pretty much means that this

497
00:18:38,640 --> 00:18:40,840
technique is not really feasible

498
00:18:40,840 --> 00:18:43,440
um happily for us

499
00:18:43,440 --> 00:18:45,520
we found some workarounds

500
00:18:45,520 --> 00:18:48,000
and adjusted the technique so it will be

501
00:18:48,000 --> 00:18:49,360
a bit more

502
00:18:49,360 --> 00:18:50,240
more

503
00:18:50,240 --> 00:18:52,880
realistic

504
00:18:53,280 --> 00:18:55,280
so instead of allocating a page in

505
00:18:55,280 --> 00:18:57,600
kernel we can allocate the page in user

506
00:18:57,600 --> 00:18:58,480
space

507
00:18:58,480 --> 00:19:00,559
there's nothing fancy about it we're

508
00:19:00,559 --> 00:19:03,760
already running code in user space

509
00:19:03,760 --> 00:19:06,640
and then

510
00:19:06,640 --> 00:19:10,960
we do all the locating just as before

511
00:19:10,960 --> 00:19:13,600
nothing special here as well

512
00:19:13,600 --> 00:19:16,799
we need the three free kernel reads

513
00:19:16,799 --> 00:19:19,520
we initialize instead of copying the

514
00:19:19,520 --> 00:19:22,000
page we can just initialize it with the

515
00:19:22,000 --> 00:19:23,840
default values

516
00:19:23,840 --> 00:19:26,720
because this page is now

517
00:19:26,720 --> 00:19:28,960
all the variables in this page are now

518
00:19:28,960 --> 00:19:30,400
being placed

519
00:19:30,400 --> 00:19:34,160
in a separate section especially for kdp

520
00:19:34,160 --> 00:19:36,880
because of kdp

521
00:19:36,880 --> 00:19:39,440
it's quite easy to predict what those

522
00:19:39,440 --> 00:19:40,960
values are going to be

523
00:19:40,960 --> 00:19:43,840
uh so we could just set them in advance

524
00:19:43,840 --> 00:19:45,520
and then

525
00:19:45,520 --> 00:19:46,880
um

526
00:19:46,880 --> 00:19:49,520
we again we disabled once we initialized

527
00:19:49,520 --> 00:19:52,799
it we disabled the flag

528
00:19:52,799 --> 00:19:53,600
and

529
00:19:53,600 --> 00:19:55,120
we

530
00:19:55,120 --> 00:19:56,720
switched the peer fence

531
00:19:56,720 --> 00:19:59,520
we loaded the driver and

532
00:19:59,520 --> 00:20:01,039
restored original

533
00:20:01,039 --> 00:20:03,440
pfn

534
00:20:04,240 --> 00:20:09,720
so let's go and start our first demo

535
00:20:29,679 --> 00:20:31,919
okay

536
00:20:33,600 --> 00:20:35,919
so first off we'll see that we have a

537
00:20:35,919 --> 00:20:38,960
windows 11 here

538
00:20:43,039 --> 00:20:45,039
okay it's a pretty recent build i think

539
00:20:45,039 --> 00:20:47,520
it's from two or three weeks ago

540
00:20:47,520 --> 00:20:50,720
the insider preview build

541
00:20:50,720 --> 00:20:52,080
we can see that

542
00:20:52,080 --> 00:20:54,720
we have vbs running

543
00:20:54,720 --> 00:20:58,400
but only credential guard is on

544
00:20:58,559 --> 00:21:01,120
kdp doesn't appear here but

545
00:21:01,120 --> 00:21:02,720
in a second we're going to show you it's

546
00:21:02,720 --> 00:21:05,120
working

547
00:21:05,840 --> 00:21:07,919
so the first half

548
00:21:07,919 --> 00:21:09,120
basically we'll

549
00:21:09,120 --> 00:21:11,280
in order to show you to prove that kdp

550
00:21:11,280 --> 00:21:14,090
is actually working we're going to show

551
00:21:14,090 --> 00:21:15,360
[Music]

552
00:21:15,360 --> 00:21:18,480
the existing implementation of dc

553
00:21:18,480 --> 00:21:20,000
tampering in the world

554
00:21:20,000 --> 00:21:23,120
and it will result in a blue screen

555
00:21:23,120 --> 00:21:25,678
hopefully

556
00:21:26,720 --> 00:21:29,720
hey

557
00:21:30,799 --> 00:21:34,000
so if you can see it should say that

558
00:21:34,000 --> 00:21:37,039
there is an attempt to read to to write

559
00:21:37,039 --> 00:21:39,919
to a non-writable location

560
00:21:39,919 --> 00:21:43,039
and the screen is a bit far for me so i

561
00:21:43,039 --> 00:21:45,840
don't really see it

562
00:21:46,000 --> 00:21:49,440
revert to the snapshots

563
00:21:57,039 --> 00:21:58,320
and now we're going to hope for a

564
00:21:58,320 --> 00:22:00,320
different result that won't be a blue

565
00:22:00,320 --> 00:22:02,639
screen

566
00:22:05,840 --> 00:22:07,360
so first

567
00:22:07,360 --> 00:22:09,440
we're going to install

568
00:22:09,440 --> 00:22:12,720
our driver our rootkit

569
00:22:12,720 --> 00:22:14,640
and we're going to try to run it and we

570
00:22:14,640 --> 00:22:16,480
see we get an error that the driver is

571
00:22:16,480 --> 00:22:18,960
not signed

572
00:22:19,679 --> 00:22:21,760
just so you see i'm not

573
00:22:21,760 --> 00:22:24,240
messing with you

574
00:22:24,240 --> 00:22:27,280
what is right and there is no signature

575
00:22:27,280 --> 00:22:29,760
over here

576
00:22:36,080 --> 00:22:39,360
now we're going to run fade swapping

577
00:22:39,360 --> 00:22:41,120
and it's waiting for us to load the

578
00:22:41,120 --> 00:22:44,799
driver which we did

579
00:22:45,280 --> 00:22:46,320
and

580
00:22:46,320 --> 00:22:48,799
you can see our wood kit is

581
00:22:48,799 --> 00:22:50,799
doing some debug prints just to show us

582
00:22:50,799 --> 00:22:53,960
it's alive

583
00:22:54,880 --> 00:22:57,840
if we're gonna stop

584
00:22:59,520 --> 00:23:03,440
stop the rootkit now you see it stops

585
00:23:03,440 --> 00:23:07,039
and if i try to run it again

586
00:23:07,200 --> 00:23:10,240
i get there again

587
00:23:14,640 --> 00:23:17,039
thank you

588
00:23:21,360 --> 00:23:24,719
so to sum everything up

589
00:23:26,000 --> 00:23:29,039
so everything up um

590
00:23:29,039 --> 00:23:31,120
on the left we have what's called flag

591
00:23:31,120 --> 00:23:34,000
flipping and this is the what we named

592
00:23:34,000 --> 00:23:34,960
the

593
00:23:34,960 --> 00:23:37,039
the technique in the wild

594
00:23:37,039 --> 00:23:37,840
and

595
00:23:37,840 --> 00:23:39,919
we compared it to all of the variants

596
00:23:39,919 --> 00:23:41,600
for paint swapping

597
00:23:41,600 --> 00:23:44,159
and we got to a variant that

598
00:23:44,159 --> 00:23:46,559
it's quite decent it requires only three

599
00:23:46,559 --> 00:23:48,960
kernel reads or a bit more if we don't

600
00:23:48,960 --> 00:23:50,559
want to

601
00:23:50,559 --> 00:23:52,799
completely rely on the default values

602
00:23:52,799 --> 00:23:55,520
and the single kernel right

603
00:23:55,520 --> 00:23:57,360
but

604
00:23:57,360 --> 00:23:59,360
we still weren't exactly happy because

605
00:23:59,360 --> 00:24:01,679
if we if frequency

606
00:24:01,679 --> 00:24:04,159
on the column on the left

607
00:24:04,159 --> 00:24:05,440
the current

608
00:24:05,440 --> 00:24:07,200
technique in the white doesn't do any

609
00:24:07,200 --> 00:24:10,480
reads doesn't do any candlelits

610
00:24:10,480 --> 00:24:11,600
so

611
00:24:11,600 --> 00:24:14,880
we continue to look at how we can

612
00:24:14,880 --> 00:24:16,480
improve upon it

613
00:24:16,480 --> 00:24:18,960
and the next technique that we found is

614
00:24:18,960 --> 00:24:21,440
called callback swapping again very

615
00:24:21,440 --> 00:24:23,039
creative name

616
00:24:23,039 --> 00:24:24,960
um

617
00:24:24,960 --> 00:24:27,440
basically what we got what we'll try to

618
00:24:27,440 --> 00:24:29,360
look at now right now is

619
00:24:29,360 --> 00:24:32,080
find another point of data that is not

620
00:24:32,080 --> 00:24:34,000
protected

621
00:24:34,000 --> 00:24:38,240
even before that cidrl is used

622
00:24:38,240 --> 00:24:40,559
basically

623
00:24:40,559 --> 00:24:42,000
when

624
00:24:42,000 --> 00:24:44,559
the callback is being is being

625
00:24:44,559 --> 00:24:46,960
the c the callback in cidl is being

626
00:24:46,960 --> 00:24:49,840
executed at the end the expected result

627
00:24:49,840 --> 00:24:52,320
should be zero the callback should

628
00:24:52,320 --> 00:24:54,320
return zero

629
00:24:54,320 --> 00:24:55,919
um

630
00:24:55,919 --> 00:24:58,480
so what about if instead of

631
00:24:58,480 --> 00:25:00,559
going the all the way through it

632
00:25:00,559 --> 00:25:03,120
and hoping that it will return a zero

633
00:25:03,120 --> 00:25:04,960
what if we can just

634
00:25:04,960 --> 00:25:07,440
use another callback that returned zero

635
00:25:07,440 --> 00:25:09,440
directly for us immediately without any

636
00:25:09,440 --> 00:25:12,640
validation whatsoever

637
00:25:12,880 --> 00:25:14,799
happily for us the

638
00:25:14,799 --> 00:25:17,279
uh the callback structure in entity in

639
00:25:17,279 --> 00:25:20,240
in endosconal is not protected by get

640
00:25:20,240 --> 00:25:22,880
back by kdp

641
00:25:22,880 --> 00:25:24,799
so it means that we can freely write to

642
00:25:24,799 --> 00:25:26,720
those locations

643
00:25:26,720 --> 00:25:27,679
but

644
00:25:27,679 --> 00:25:30,880
we still need to find a way

645
00:25:30,880 --> 00:25:33,279
you know to locate it because again it's

646
00:25:33,279 --> 00:25:35,919
an internal variable

647
00:25:35,919 --> 00:25:38,720
um so how can we do it

648
00:25:38,720 --> 00:25:41,039
so basically

649
00:25:41,039 --> 00:25:43,120
um if we look

650
00:25:43,120 --> 00:25:45,919
at the initialization phase

651
00:25:45,919 --> 00:25:48,559
uh this the

652
00:25:48,559 --> 00:25:49,679
the ci

653
00:25:49,679 --> 00:25:52,240
initialize function is imported

654
00:25:52,240 --> 00:25:53,279
and

655
00:25:53,279 --> 00:25:54,559
then we can

656
00:25:54,559 --> 00:25:56,720
find we can look for a call that is

657
00:25:56,720 --> 00:25:58,400
actually referencing

658
00:25:58,400 --> 00:26:00,559
that

659
00:26:00,559 --> 00:26:01,919
import

660
00:26:01,919 --> 00:26:04,159
import table entry

661
00:26:04,159 --> 00:26:06,799
and once we we do find it

662
00:26:06,799 --> 00:26:09,279
we can just go back

663
00:26:09,279 --> 00:26:11,760
and look for the parameter assignment

664
00:26:11,760 --> 00:26:13,760
in the registers

665
00:26:13,760 --> 00:26:17,039
once we do find some

666
00:26:17,039 --> 00:26:17,919
some

667
00:26:17,919 --> 00:26:20,400
some such assignment

668
00:26:20,400 --> 00:26:21,919
we're just gonna

669
00:26:21,919 --> 00:26:23,520
check that

670
00:26:23,520 --> 00:26:25,520
the address that it points to will lead

671
00:26:25,520 --> 00:26:27,279
to the data section

672
00:26:27,279 --> 00:26:31,919
and the data there will be uninitialized

673
00:26:31,919 --> 00:26:33,279
and that's how we know we found the

674
00:26:33,279 --> 00:26:35,520
callback structure

675
00:26:35,520 --> 00:26:36,720
next up

676
00:26:36,720 --> 00:26:39,919
we need to find a new callback

677
00:26:39,919 --> 00:26:41,120
basically

678
00:26:41,120 --> 00:26:43,600
there is a very easy way to do it if we

679
00:26:43,600 --> 00:26:45,679
use exported functions from the kernel

680
00:26:45,679 --> 00:26:46,559
itself

681
00:26:46,559 --> 00:26:49,600
we can just use get pork address and get

682
00:26:49,600 --> 00:26:51,279
to get those functions get the address

683
00:26:51,279 --> 00:26:53,840
of those functions

684
00:26:54,000 --> 00:26:58,080
and if we want to be a bit more creative

685
00:26:58,080 --> 00:27:00,080
we can look for exported functions in

686
00:27:00,080 --> 00:27:02,480
cidrel itself

687
00:27:02,480 --> 00:27:05,279
all some gadgets that will

688
00:27:05,279 --> 00:27:07,919
result in the same

689
00:27:07,919 --> 00:27:09,520
return value

690
00:27:09,520 --> 00:27:13,520
for instance as we can see here in cidr

691
00:27:13,520 --> 00:27:15,600
the benefit for that is that the rights

692
00:27:15,600 --> 00:27:17,679
that we need to do to the kernel

693
00:27:17,679 --> 00:27:20,000
will be smaller because the addresses

694
00:27:20,000 --> 00:27:22,799
are not as far apart once we look in the

695
00:27:22,799 --> 00:27:25,360
dealer itself

696
00:27:25,360 --> 00:27:27,120
the hardest part here is finding the

697
00:27:27,120 --> 00:27:29,440
original callbacks

698
00:27:29,440 --> 00:27:30,720
basically

699
00:27:30,720 --> 00:27:33,120
we want to do it without reading the

700
00:27:33,120 --> 00:27:35,279
kernel and without looking in the kernel

701
00:27:35,279 --> 00:27:37,360
in the callback structure in the kernel

702
00:27:37,360 --> 00:27:40,000
and all of those functions are internal

703
00:27:40,000 --> 00:27:42,640
and not exported in any way

704
00:27:42,640 --> 00:27:43,440
so

705
00:27:43,440 --> 00:27:45,840
what we can do is look for in the in the

706
00:27:45,840 --> 00:27:48,480
dls initialization function

707
00:27:48,480 --> 00:27:50,399
for the assignment

708
00:27:50,399 --> 00:27:52,559
of the fields of the structure okay this

709
00:27:52,559 --> 00:27:54,720
pattern

710
00:27:54,720 --> 00:27:57,840
repeats itself pretty much in every

711
00:27:57,840 --> 00:28:00,640
version of the operating system

712
00:28:00,640 --> 00:28:03,840
and then uh in order to

713
00:28:03,840 --> 00:28:06,320
verify that we actually found

714
00:28:06,320 --> 00:28:09,360
uh the right addresses or

715
00:28:09,360 --> 00:28:11,039
that the addresses that we got are

716
00:28:11,039 --> 00:28:13,360
actually for for functions and not not

717
00:28:13,360 --> 00:28:15,520
just some random area

718
00:28:15,520 --> 00:28:17,039
we can check

719
00:28:17,039 --> 00:28:19,600
the exception directory

720
00:28:19,600 --> 00:28:21,279
for entries

721
00:28:21,279 --> 00:28:23,919
and that we have the same start address

722
00:28:23,919 --> 00:28:27,200
as the offset that we found

723
00:28:28,559 --> 00:28:31,120
so with that we completed our locate

724
00:28:31,120 --> 00:28:32,159
phase

725
00:28:32,159 --> 00:28:34,559
and the override is pretty easy we just

726
00:28:34,559 --> 00:28:36,880
write the callback

727
00:28:36,880 --> 00:28:38,559
and load the driver

728
00:28:38,559 --> 00:28:40,559
and restore the

729
00:28:40,559 --> 00:28:44,918
original callbacks again

730
00:28:45,120 --> 00:28:48,320
let's try another demo

731
00:28:54,640 --> 00:28:56,399
okay so

732
00:28:56,399 --> 00:28:58,960
i'll skip the reverting the machine

733
00:28:58,960 --> 00:29:00,880
because we already see that

734
00:29:00,880 --> 00:29:04,080
the driver isn't loading

735
00:29:04,640 --> 00:29:08,440
and it's already installed

736
00:29:20,720 --> 00:29:23,720
okay

737
00:29:31,760 --> 00:29:34,080
great

738
00:29:35,919 --> 00:29:37,919
so as you can see we

739
00:29:37,919 --> 00:29:41,600
first disabled dsc loaded our driver

740
00:29:41,600 --> 00:29:44,719
and then restored it

741
00:29:44,799 --> 00:29:46,320
for a second

742
00:29:46,320 --> 00:29:49,440
for us for one last try we're gonna just

743
00:29:49,440 --> 00:29:50,799
make sure

744
00:29:50,799 --> 00:29:54,679
the restoration worked

745
00:29:55,919 --> 00:29:58,159
just

746
00:30:01,279 --> 00:30:05,120
now we stop the the old kids

747
00:30:10,480 --> 00:30:13,840
and we can't load it again

748
00:30:16,960 --> 00:30:20,200
thank you

749
00:30:24,080 --> 00:30:27,679
so if we compare our techniques um

750
00:30:27,679 --> 00:30:30,399
we managed to find some

751
00:30:30,399 --> 00:30:33,679
some technique that will actually

752
00:30:33,679 --> 00:30:35,679
that actually looks

753
00:30:35,679 --> 00:30:37,679
pretty similar to the one that is used

754
00:30:37,679 --> 00:30:38,960
in the wild

755
00:30:38,960 --> 00:30:40,559
we can do everything that we need

756
00:30:40,559 --> 00:30:41,919
without with

757
00:30:41,919 --> 00:30:44,559
single kernel light

758
00:30:44,559 --> 00:30:47,440
in the demos that i used that i showed

759
00:30:47,440 --> 00:30:49,120
you i used

760
00:30:49,120 --> 00:30:51,760
the non-vulnerable drivers

761
00:30:51,760 --> 00:30:54,240
that are being used by

762
00:30:54,240 --> 00:30:56,640
attackers in the wild so it's completely

763
00:30:56,640 --> 00:30:58,640
feasible

764
00:30:58,640 --> 00:31:00,880
and

765
00:31:01,360 --> 00:31:03,679
for me for me we've tried to

766
00:31:03,679 --> 00:31:05,840
figure out some way that we can improve

767
00:31:05,840 --> 00:31:08,240
the situation and just and not just like

768
00:31:08,240 --> 00:31:10,159
show you new techniques that you need to

769
00:31:10,159 --> 00:31:11,440
worry about

770
00:31:11,440 --> 00:31:12,640
um

771
00:31:12,640 --> 00:31:14,799
what we thought about was

772
00:31:14,799 --> 00:31:17,919
basically why not just confirm the state

773
00:31:17,919 --> 00:31:20,320
of dsc when we know a driver is being

774
00:31:20,320 --> 00:31:21,279
loaded

775
00:31:21,279 --> 00:31:25,519
and once we do we can decide how to act

776
00:31:25,519 --> 00:31:29,360
we can find those internal variables

777
00:31:29,360 --> 00:31:30,799
ourselves

778
00:31:30,799 --> 00:31:33,120
same as attackers do

779
00:31:33,120 --> 00:31:35,200
they proving to be

780
00:31:35,200 --> 00:31:37,120
stable so far so

781
00:31:37,120 --> 00:31:40,159
why not do it also ourselves

782
00:31:40,159 --> 00:31:41,519
um so

783
00:31:41,519 --> 00:31:45,200
basically when we boot or when our

784
00:31:45,200 --> 00:31:47,360
when our protection starts

785
00:31:47,360 --> 00:31:49,200
we can kind of assume

786
00:31:49,200 --> 00:31:51,039
that this system is not currently

787
00:31:51,039 --> 00:31:52,559
compromised

788
00:31:52,559 --> 00:31:53,840
because

789
00:31:53,840 --> 00:31:56,080
uh because of all the other protection

790
00:31:56,080 --> 00:31:58,159
mechanisms that prevent the compromise

791
00:31:58,159 --> 00:31:59,120
to be

792
00:31:59,120 --> 00:32:03,678
to be for a very long period of time

793
00:32:03,919 --> 00:32:06,080
so when we start we kind of assume we're

794
00:32:06,080 --> 00:32:08,559
in a valid state and we can just capture

795
00:32:08,559 --> 00:32:09,760
it

796
00:32:09,760 --> 00:32:12,880
meaning that we're going to copy

797
00:32:12,880 --> 00:32:14,559
the callback structure and the values of

798
00:32:14,559 --> 00:32:15,679
the flags

799
00:32:15,679 --> 00:32:19,360
uh to a different location

800
00:32:19,360 --> 00:32:20,480
and then

801
00:32:20,480 --> 00:32:22,799
we need to figure out how how a driver

802
00:32:22,799 --> 00:32:25,120
is loaded or when a driver is loaded

803
00:32:25,120 --> 00:32:28,240
and not just that we need to be able to

804
00:32:28,240 --> 00:32:30,799
uh manipulate that that moment in time

805
00:32:30,799 --> 00:32:33,200
we need to be able to control it

806
00:32:33,200 --> 00:32:34,159
so

807
00:32:34,159 --> 00:32:36,080
this thing this can be

808
00:32:36,080 --> 00:32:38,960
the driver loading can be intercepted

809
00:32:38,960 --> 00:32:41,440
by placing a hook on in user space on

810
00:32:41,440 --> 00:32:43,120
the api call

811
00:32:43,120 --> 00:32:46,719
but that's not really robust

812
00:32:46,880 --> 00:32:48,559
and in kernel we can

813
00:32:48,559 --> 00:32:50,799
leverage some callbacks like

814
00:32:50,799 --> 00:32:52,799
the registry call register operation

815
00:32:52,799 --> 00:32:55,360
callbacks or file system callbacks using

816
00:32:55,360 --> 00:32:58,399
a mini filter driver

817
00:32:58,880 --> 00:33:01,200
for registry callbacks we can

818
00:33:01,200 --> 00:33:02,880
check

819
00:33:02,880 --> 00:33:04,799
once we see

820
00:33:04,799 --> 00:33:06,640
access to

821
00:33:06,640 --> 00:33:09,279
registry keys of drivers and then we

822
00:33:09,279 --> 00:33:13,279
know uh and if they are happening when

823
00:33:13,279 --> 00:33:14,240
um

824
00:33:14,240 --> 00:33:16,559
the the current process is

825
00:33:16,559 --> 00:33:19,360
is system is the kernel itself uh we'll

826
00:33:19,360 --> 00:33:22,480
know that it's most likely

827
00:33:22,480 --> 00:33:24,880
originates due to

828
00:33:24,880 --> 00:33:25,919
a

829
00:33:25,919 --> 00:33:28,559
driver loading attempt or when the

830
00:33:28,559 --> 00:33:31,360
driver is being loaded to memory

831
00:33:31,360 --> 00:33:33,120
uh in

832
00:33:33,120 --> 00:33:34,480
the driver file is being loaded to

833
00:33:34,480 --> 00:33:37,200
memory via a section uh

834
00:33:37,200 --> 00:33:40,320
oh it's being mapped into memory

835
00:33:40,320 --> 00:33:42,880
uh it's even before it's being loaded

836
00:33:42,880 --> 00:33:46,399
um then on those points we can just

837
00:33:46,399 --> 00:33:48,720
compare we can just find the variables

838
00:33:48,720 --> 00:33:49,919
again

839
00:33:49,919 --> 00:33:52,960
and compare them for any change

840
00:33:52,960 --> 00:33:54,720
if there was a change

841
00:33:54,720 --> 00:33:56,559
prevention is pretty easy we can just

842
00:33:56,559 --> 00:33:59,600
block the i o request in the callbacks

843
00:33:59,600 --> 00:34:01,919
or we can restore the

844
00:34:01,919 --> 00:34:03,840
values of the variables and let the

845
00:34:03,840 --> 00:34:08,639
system do its own work for us

846
00:34:10,480 --> 00:34:14,239
so just to summarize you

847
00:34:14,239 --> 00:34:15,440
i think that

848
00:34:15,440 --> 00:34:18,239
dc tampering is still feasible

849
00:34:18,239 --> 00:34:21,679
at least with callback swapping um

850
00:34:21,679 --> 00:34:26,239
data-oriented mitigations like kdp

851
00:34:26,239 --> 00:34:28,560
they are pretty tricky to implement and

852
00:34:28,560 --> 00:34:29,760
also

853
00:34:29,760 --> 00:34:31,918
some of the people in microsoft also

854
00:34:31,918 --> 00:34:33,040
think

855
00:34:33,040 --> 00:34:35,918
think so so i'm not really sure

856
00:34:35,918 --> 00:34:39,279
what was the goal behind it

857
00:34:40,320 --> 00:34:42,960
defenders can use the mitigation that we

858
00:34:42,960 --> 00:34:44,320
suggested

859
00:34:44,320 --> 00:34:46,639
we're gonna release hopefully the

860
00:34:46,639 --> 00:34:50,239
source code for it so it will help

861
00:34:50,239 --> 00:34:52,320
speed up the process

862
00:34:52,320 --> 00:34:53,520
and

863
00:34:53,520 --> 00:34:55,119
the final thing and i think it's the

864
00:34:55,119 --> 00:34:57,040
most important uh

865
00:34:57,040 --> 00:34:59,599
point of this talk is

866
00:34:59,599 --> 00:35:01,839
there is a real solution for it

867
00:35:01,839 --> 00:35:04,320
microsoft did a pretty good job

868
00:35:04,320 --> 00:35:06,480
on developing

869
00:35:06,480 --> 00:35:09,040
virtualization-based security mechanisms

870
00:35:09,040 --> 00:35:12,160
one such as hvci

871
00:35:12,160 --> 00:35:15,359
it exists for seven years now

872
00:35:15,359 --> 00:35:18,560
but it's still not as common out in the

873
00:35:18,560 --> 00:35:20,320
field

874
00:35:20,320 --> 00:35:22,000
hopefully it will be

875
00:35:22,000 --> 00:35:26,079
more adopted in the next few years

876
00:35:27,040 --> 00:35:30,000
basically what it does it's leveraging

877
00:35:30,000 --> 00:35:31,680
the fact that we have

878
00:35:31,680 --> 00:35:35,200
a secured space that is actually

879
00:35:35,200 --> 00:35:37,040
um

880
00:35:37,040 --> 00:35:39,520
is actually being separate

881
00:35:39,520 --> 00:35:41,440
from the kernel that the kernel can't

882
00:35:41,440 --> 00:35:43,200
really access

883
00:35:43,200 --> 00:35:45,280
and there it performs

884
00:35:45,280 --> 00:35:47,040
an additional validation once we load

885
00:35:47,040 --> 00:35:50,320
the driver it has its own set of

886
00:35:50,320 --> 00:35:53,520
policy and its own copy of the

887
00:35:53,520 --> 00:35:55,040
ci policy

888
00:35:55,040 --> 00:35:57,040
and it validates it as well

889
00:35:57,040 --> 00:36:00,160
and in order for you to get

890
00:36:00,160 --> 00:36:02,960
execution permissions in the kernel

891
00:36:02,960 --> 00:36:05,440
you have to go through it only it can

892
00:36:05,440 --> 00:36:07,920
actually set the execution permissions

893
00:36:07,920 --> 00:36:10,560
because you have two sets of pt's as we

894
00:36:10,560 --> 00:36:11,520
said

895
00:36:11,520 --> 00:36:12,880
that you need to

896
00:36:12,880 --> 00:36:14,240
be able to

897
00:36:14,240 --> 00:36:17,119
set the permissions on it same as for

898
00:36:17,119 --> 00:36:18,640
right you also have the execute

899
00:36:18,640 --> 00:36:21,839
permission on that pt

900
00:36:21,839 --> 00:36:23,839
and

901
00:36:23,839 --> 00:36:24,960
basically

902
00:36:24,960 --> 00:36:26,960
that's the real that's the in the end

903
00:36:26,960 --> 00:36:29,040
that's the real solution here

904
00:36:29,040 --> 00:36:31,440
so if you can just make sure you turn it

905
00:36:31,440 --> 00:36:33,599
on

906
00:36:34,160 --> 00:36:35,440
that's it

907
00:36:35,440 --> 00:36:38,680
any questions

908
00:36:43,359 --> 00:36:46,598
thank you

