1
00:00:00,160 --> 00:00:01,839
good afternoon this is breaking ground

2
00:00:01,839 --> 00:00:04,560
at b-sides las vegas uh this talk is see

3
00:00:04,560 --> 00:00:06,319
you later allocator before we get

4
00:00:06,319 --> 00:00:07,839
started some quick announcements first

5
00:00:07,839 --> 00:00:09,599
of all i'd like to thank our sponsors

6
00:00:09,599 --> 00:00:11,759
especially our diamond sponsors lastpass

7
00:00:11,759 --> 00:00:14,320
and palo alto networks our gold sponsors

8
00:00:14,320 --> 00:00:16,880
including intel google amazon

9
00:00:16,880 --> 00:00:18,160
their support is what makes this

10
00:00:18,160 --> 00:00:20,240
conference possible so please say hello

11
00:00:20,240 --> 00:00:22,480
to them outside uh as always we are

12
00:00:22,480 --> 00:00:25,519
streaming cell phones off please

13
00:00:25,519 --> 00:00:27,039
if you have questions there will be time

14
00:00:27,039 --> 00:00:28,160
for questions at the end of the talk

15
00:00:28,160 --> 00:00:29,119
just raise your hand we don't have

16
00:00:29,119 --> 00:00:30,800
speaker mics today

17
00:00:30,800 --> 00:00:32,719
and with that please welcome daniel

18
00:00:32,719 --> 00:00:35,120
danzi

19
00:00:39,360 --> 00:00:40,879
all right good afternoon everyone i just

20
00:00:40,879 --> 00:00:42,160
want to make sure can everyone hear me

21
00:00:42,160 --> 00:00:43,760
in the back

22
00:00:43,760 --> 00:00:45,200
awesome

23
00:00:45,200 --> 00:00:47,280
all right um i just want to do a quick

24
00:00:47,280 --> 00:00:49,039
survey uh so who decided to show up to

25
00:00:49,039 --> 00:00:52,079
this talk because of the pun

26
00:00:54,480 --> 00:00:56,480
who else uh decided to show up because

27
00:00:56,480 --> 00:00:59,280
volatility was in the name

28
00:00:59,280 --> 00:01:01,840
all right good show of hands um

29
00:01:01,840 --> 00:01:03,359
who showed up because they will really

30
00:01:03,359 --> 00:01:05,040
want to dig into some linux internals

31
00:01:05,040 --> 00:01:06,799
today

32
00:01:06,799 --> 00:01:08,159
wow

33
00:01:08,159 --> 00:01:10,560
all right let's get this started so

34
00:01:10,560 --> 00:01:12,640
a little bit about me i'm a recovering

35
00:01:12,640 --> 00:01:14,799
grad student i graduated from louisiana

36
00:01:14,799 --> 00:01:16,880
state university

37
00:01:16,880 --> 00:01:19,280
taking part in the lsu's applied cyber

38
00:01:19,280 --> 00:01:21,360
security lab

39
00:01:21,360 --> 00:01:23,200
we like to

40
00:01:23,200 --> 00:01:24,720
do a lot of hands-on cyber security

41
00:01:24,720 --> 00:01:27,040
activities try to bridge the gap between

42
00:01:27,040 --> 00:01:29,040
theory that's being taught and actually

43
00:01:29,040 --> 00:01:30,880
getting hands-on keyboards

44
00:01:30,880 --> 00:01:34,320
um and in a former life i was a software

45
00:01:34,320 --> 00:01:36,079
developer

46
00:01:36,079 --> 00:01:38,880
so memory forensics

47
00:01:38,880 --> 00:01:42,640
it is a branch part subset of digital

48
00:01:42,640 --> 00:01:44,240
forensics it kind of sits in between

49
00:01:44,240 --> 00:01:45,840
traditional disk forensics where you

50
00:01:45,840 --> 00:01:47,360
power off the machine

51
00:01:47,360 --> 00:01:49,280
yank the disk out go do analysis on it

52
00:01:49,280 --> 00:01:50,479
later

53
00:01:50,479 --> 00:01:52,640
and live forensics where you're looking

54
00:01:52,640 --> 00:01:54,640
at stuff coming through the network

55
00:01:54,640 --> 00:01:57,360
analyzing things as they're happening

56
00:01:57,360 --> 00:01:58,799
memory forensics kind of sits in the

57
00:01:58,799 --> 00:01:59,759
middle

58
00:01:59,759 --> 00:02:02,880
because you take a copy of the machine's

59
00:02:02,880 --> 00:02:04,719
memory as it's running which gives us a

60
00:02:04,719 --> 00:02:06,560
little bit of insight into the state of

61
00:02:06,560 --> 00:02:09,640
the machine

62
00:02:10,000 --> 00:02:12,319
and why would we want to do this

63
00:02:12,319 --> 00:02:14,640
well it gives us a number of very useful

64
00:02:14,640 --> 00:02:16,400
information such as the processes that

65
00:02:16,400 --> 00:02:18,000
are running on the system any kind of

66
00:02:18,000 --> 00:02:19,680
network connections it currently has

67
00:02:19,680 --> 00:02:21,760
engaged the network sockets that it

68
00:02:21,760 --> 00:02:23,120
represents

69
00:02:23,120 --> 00:02:24,560
potentially any passwords that are

70
00:02:24,560 --> 00:02:26,160
stored in memory

71
00:02:26,160 --> 00:02:28,640
or cached in memory as well as operating

72
00:02:28,640 --> 00:02:30,160
system hooks that may involve things

73
00:02:30,160 --> 00:02:33,360
like monitoring the keyboard or mouse

74
00:02:33,360 --> 00:02:35,200
memory forensics also gives us the power

75
00:02:35,200 --> 00:02:37,280
to look at who performed what action

76
00:02:37,280 --> 00:02:39,519
since we get to see which process has

77
00:02:39,519 --> 00:02:42,080
started which other processes

78
00:02:42,080 --> 00:02:44,879
which means we can attribute

79
00:02:44,879 --> 00:02:47,280
activities on machines to either users

80
00:02:47,280 --> 00:02:49,200
or potentially malware if we find it on

81
00:02:49,200 --> 00:02:51,519
the system

82
00:02:51,519 --> 00:02:52,879
and

83
00:02:52,879 --> 00:02:55,680
in more recent times

84
00:02:55,680 --> 00:02:57,920
there's becoming an increase in the

85
00:02:57,920 --> 00:03:00,319
number of memory only malware some

86
00:03:00,319 --> 00:03:02,640
examples are dooku and corelump

87
00:03:02,640 --> 00:03:04,239
um

88
00:03:04,239 --> 00:03:07,040
both reside exclusively in memory and if

89
00:03:07,040 --> 00:03:08,480
you try to do

90
00:03:08,480 --> 00:03:10,400
traditional disk forensics

91
00:03:10,400 --> 00:03:12,159
you'll never see it because it never

92
00:03:12,159 --> 00:03:15,040
gets written to disk and likewise

93
00:03:15,040 --> 00:03:16,720
if you try to do live forensics a lot of

94
00:03:16,720 --> 00:03:19,680
times there are anti-analysis

95
00:03:19,680 --> 00:03:21,519
mechanisms in place

96
00:03:21,519 --> 00:03:22,720
to make that

97
00:03:22,720 --> 00:03:24,319
not fun

98
00:03:24,319 --> 00:03:27,200
so how do we do memory forensics

99
00:03:27,200 --> 00:03:28,720
one of the

100
00:03:28,720 --> 00:03:31,120
very popular tools is volatility since

101
00:03:31,120 --> 00:03:34,000
it's open source it's plug and based so

102
00:03:34,000 --> 00:03:35,760
if you need to expand the functionality

103
00:03:35,760 --> 00:03:37,519
of volatility to suit a particular

104
00:03:37,519 --> 00:03:38,959
analysis need

105
00:03:38,959 --> 00:03:41,280
you are able to do that

106
00:03:41,280 --> 00:03:43,120
and volatility handles from a

107
00:03:43,120 --> 00:03:45,040
development standpoint a lot of

108
00:03:45,040 --> 00:03:46,959
grunt work behind the scenes it provides

109
00:03:46,959 --> 00:03:49,760
virtual to physical address translation

110
00:03:49,760 --> 00:03:51,840
which saves a lot of pain when you're

111
00:03:51,840 --> 00:03:54,400
trying to work with a memory sample

112
00:03:54,400 --> 00:03:57,120
which is just simply a copy of memory

113
00:03:57,120 --> 00:03:59,200
from a given time of the machine

114
00:03:59,200 --> 00:04:01,200
and it provides an interface to the

115
00:04:01,200 --> 00:04:04,080
kernel objects in the system so you can

116
00:04:04,080 --> 00:04:05,439
look at the data store in the kernel

117
00:04:05,439 --> 00:04:07,920
objects even manipulate it

118
00:04:07,920 --> 00:04:09,680
get a much deeper understanding of

119
00:04:09,680 --> 00:04:12,159
what's going on the system at the time

120
00:04:12,159 --> 00:04:13,439
so

121
00:04:13,439 --> 00:04:15,360
what exactly does this analysis look

122
00:04:15,360 --> 00:04:17,759
like involves running plug-ins as i

123
00:04:17,759 --> 00:04:19,440
mentioned previously

124
00:04:19,440 --> 00:04:22,160
um one such example is pslist which

125
00:04:22,160 --> 00:04:23,360
tries to

126
00:04:23,360 --> 00:04:25,199
emulate the

127
00:04:25,199 --> 00:04:28,639
ps commands on linux systems

128
00:04:28,639 --> 00:04:30,880
which i don't know how visible this is

129
00:04:30,880 --> 00:04:32,000
but

130
00:04:32,000 --> 00:04:33,680
it provides us with information such as

131
00:04:33,680 --> 00:04:35,600
name of the process is running the ids

132
00:04:35,600 --> 00:04:38,320
of the process any parent ids that have

133
00:04:38,320 --> 00:04:40,320
started that process when that process

134
00:04:40,320 --> 00:04:42,560
started and any user or group

135
00:04:42,560 --> 00:04:46,800
information that's associated with it

136
00:04:47,520 --> 00:04:49,600
likewise there's netstat which tries to

137
00:04:49,600 --> 00:04:51,440
emulate the

138
00:04:51,440 --> 00:04:54,000
identical name netstat command on linux

139
00:04:54,000 --> 00:04:55,759
which blocks the

140
00:04:55,759 --> 00:04:57,600
process list

141
00:04:57,600 --> 00:04:59,040
from a given memory sample and

142
00:04:59,040 --> 00:05:01,280
enumerates the sockets that each process

143
00:05:01,280 --> 00:05:02,160
has

144
00:05:02,160 --> 00:05:03,600
which gives us

145
00:05:03,600 --> 00:05:06,000
important network information

146
00:05:06,000 --> 00:05:08,400
um including both local and remote

147
00:05:08,400 --> 00:05:10,639
remote ports

148
00:05:10,639 --> 00:05:12,479
as well as

149
00:05:12,479 --> 00:05:14,080
the process that owns a particular

150
00:05:14,080 --> 00:05:16,320
socket which makes it easy to attribute

151
00:05:16,320 --> 00:05:18,080
network connections to a particular

152
00:05:18,080 --> 00:05:20,320
running process

153
00:05:20,320 --> 00:05:21,360
now

154
00:05:21,360 --> 00:05:23,759
both of these previous plugins use

155
00:05:23,759 --> 00:05:25,440
what's known as a list walking method

156
00:05:25,440 --> 00:05:27,680
where you just take the kernel data

157
00:05:27,680 --> 00:05:29,919
structure that contains

158
00:05:29,919 --> 00:05:31,919
the list of processes lists of network

159
00:05:31,919 --> 00:05:33,919
structures and so on and you just walk

160
00:05:33,919 --> 00:05:35,840
through that list the advantage of these

161
00:05:35,840 --> 00:05:37,199
approaches is that it's relatively

162
00:05:37,199 --> 00:05:39,039
straightforward to do you just find some

163
00:05:39,039 --> 00:05:40,880
point in memory and you know where they

164
00:05:40,880 --> 00:05:42,479
all get linked so you just follow those

165
00:05:42,479 --> 00:05:46,080
links until you've enumerated everything

166
00:05:46,080 --> 00:05:47,360
however

167
00:05:47,360 --> 00:05:49,440
a lot of times deleting things in memory

168
00:05:49,440 --> 00:05:51,280
is very lazy

169
00:05:51,280 --> 00:05:53,840
in that whenever something

170
00:05:53,840 --> 00:05:55,600
gets freed up such as when a process

171
00:05:55,600 --> 00:05:58,639
terminates a network connection

172
00:05:58,639 --> 00:06:01,360
is closed

173
00:06:02,400 --> 00:06:03,199
all

174
00:06:03,199 --> 00:06:05,039
a lot of operating systems do is just

175
00:06:05,039 --> 00:06:06,639
simply free up that space to be

176
00:06:06,639 --> 00:06:07,919
allocated by something else in the

177
00:06:07,919 --> 00:06:09,039
future

178
00:06:09,039 --> 00:06:11,840
so this data is still resident in memory

179
00:06:11,840 --> 00:06:14,160
and it's still important for us to look

180
00:06:14,160 --> 00:06:15,280
for it

181
00:06:15,280 --> 00:06:17,840
so there's carving approaches which just

182
00:06:17,840 --> 00:06:20,240
hunt for blobs of data that look like

183
00:06:20,240 --> 00:06:22,720
something in memory one example is ps

184
00:06:22,720 --> 00:06:24,639
scan for linux

185
00:06:24,639 --> 00:06:26,240
which

186
00:06:26,240 --> 00:06:27,759
provides us with very similar

187
00:06:27,759 --> 00:06:30,080
information to a ps list the only

188
00:06:30,080 --> 00:06:32,160
difference is since we are carving

189
00:06:32,160 --> 00:06:35,199
potentially terminated processes we can

190
00:06:35,199 --> 00:06:37,039
see that for some of these we have a

191
00:06:37,039 --> 00:06:38,960
user of negative one which would be

192
00:06:38,960 --> 00:06:41,280
invalid

193
00:06:41,280 --> 00:06:43,039
however this is associated with a

194
00:06:43,039 --> 00:06:44,639
process that had been terminated on

195
00:06:44,639 --> 00:06:45,600
linux

196
00:06:45,600 --> 00:06:50,400
and this becomes very useful because

197
00:06:51,680 --> 00:06:54,240
we don't want to miss out on

198
00:06:54,240 --> 00:06:56,160
processes or commands that are run on a

199
00:06:56,160 --> 00:06:57,599
system just because we took a memory

200
00:06:57,599 --> 00:07:00,719
sample at the wrong time

201
00:07:00,840 --> 00:07:04,080
now linux

202
00:07:04,080 --> 00:07:06,400
being open source allows us to look at

203
00:07:06,400 --> 00:07:08,960
the memory allocation process directly

204
00:07:08,960 --> 00:07:12,160
and we can create a targeted plugin to

205
00:07:12,160 --> 00:07:14,800
analyze linux memory systems so if

206
00:07:14,800 --> 00:07:16,560
anyone's run this beautiful command ps

207
00:07:16,560 --> 00:07:19,039
list cache you're presented with this

208
00:07:19,039 --> 00:07:21,440
glorious message

209
00:07:21,440 --> 00:07:22,560
so

210
00:07:22,560 --> 00:07:26,319
what's going on here um slub is one of

211
00:07:26,319 --> 00:07:28,880
linux's memory allocation processes it

212
00:07:28,880 --> 00:07:31,680
handles the quote unquote smaller

213
00:07:31,680 --> 00:07:34,800
allocations done in linux and

214
00:07:34,800 --> 00:07:37,120
ps list cache was written for slob's

215
00:07:37,120 --> 00:07:38,319
predecessor

216
00:07:38,319 --> 00:07:40,479
so why is this important

217
00:07:40,479 --> 00:07:42,840
um well slub's a kind of

218
00:07:42,840 --> 00:07:46,319
niche allocation system that is since

219
00:07:46,319 --> 00:07:49,599
about 72 percent of recorded kernels

220
00:07:49,599 --> 00:07:51,120
and

221
00:07:51,120 --> 00:07:54,639
it's also a little bit of a newer

222
00:07:54,720 --> 00:07:57,120
allocation system being added as the

223
00:07:57,120 --> 00:07:58,960
default memory allocator for linux

224
00:07:58,960 --> 00:08:01,199
around 2008-2009

225
00:08:01,199 --> 00:08:05,039
which is about a decade ago

226
00:08:05,039 --> 00:08:07,199
so

227
00:08:07,840 --> 00:08:09,840
really quick it's important i don't

228
00:08:09,840 --> 00:08:12,240
think i need to make too many points but

229
00:08:12,240 --> 00:08:14,720
linux is used somewhat widely twenty

230
00:08:14,720 --> 00:08:16,000
five percent of software developer

231
00:08:16,000 --> 00:08:18,960
workstations according to stack overflow

232
00:08:18,960 --> 00:08:21,520
use linux

233
00:08:21,520 --> 00:08:23,440
uh eighty percent of web servers are run

234
00:08:23,440 --> 00:08:25,840
on linux nearly all of these

235
00:08:25,840 --> 00:08:27,360
super computers are run on linux and

236
00:08:27,360 --> 00:08:28,720
linux serves as part of android's

237
00:08:28,720 --> 00:08:30,960
bootloader so being able to look at a

238
00:08:30,960 --> 00:08:33,279
linux system specifically any of the

239
00:08:33,279 --> 00:08:35,360
data structures allocated by the kernel

240
00:08:35,360 --> 00:08:37,440
is really important

241
00:08:37,440 --> 00:08:39,599
so how does memory allocation in linux

242
00:08:39,599 --> 00:08:42,240
happen it starts with k malek which if

243
00:08:42,240 --> 00:08:44,720
anyone in here has programmed in c has

244
00:08:44,720 --> 00:08:47,360
likely used a malik function where you

245
00:08:47,360 --> 00:08:50,160
just ask hey can i have a certain number

246
00:08:50,160 --> 00:08:52,320
of bytes in memory and it gives you a

247
00:08:52,320 --> 00:08:54,560
pointer to that memory

248
00:08:54,560 --> 00:08:56,320
the kernel has to handle its own memory

249
00:08:56,320 --> 00:08:58,720
as well so it has a k malloc function

250
00:08:58,720 --> 00:09:00,880
where they just slap the word k or the

251
00:09:00,880 --> 00:09:02,480
letter k in front of malik and called it

252
00:09:02,480 --> 00:09:03,720
a day

253
00:09:03,720 --> 00:09:05,440
[Music]

254
00:09:05,440 --> 00:09:07,279
how it works internally though is

255
00:09:07,279 --> 00:09:08,959
there's actually two subsystems that

256
00:09:08,959 --> 00:09:10,160
handle

257
00:09:10,160 --> 00:09:12,080
memory allocation at linux there is a

258
00:09:12,080 --> 00:09:14,720
large request handler which handle which

259
00:09:14,720 --> 00:09:17,120
is known as the page or zone allocator

260
00:09:17,120 --> 00:09:20,480
and a small request allocator which

261
00:09:20,480 --> 00:09:22,560
can be a number of

262
00:09:22,560 --> 00:09:23,760
allocators depending on the

263
00:09:23,760 --> 00:09:25,279
configuration of the kernel which is

264
00:09:25,279 --> 00:09:28,480
where we're talking or looking at now

265
00:09:28,480 --> 00:09:30,800
so the original small request allocator

266
00:09:30,800 --> 00:09:32,560
for linux was slab

267
00:09:32,560 --> 00:09:34,080
it

268
00:09:34,080 --> 00:09:36,480
whenever linux asked for memory

269
00:09:36,480 --> 00:09:39,200
it groups

270
00:09:39,440 --> 00:09:41,440
all the objects that are allocated by

271
00:09:41,440 --> 00:09:44,000
the kernel based on the object type so

272
00:09:44,000 --> 00:09:45,440
all of the process structures are put

273
00:09:45,440 --> 00:09:46,800
together all the network structures are

274
00:09:46,800 --> 00:09:49,440
put together it organizes it very nicely

275
00:09:49,440 --> 00:09:52,640
it tracks every single lowercase slab

276
00:09:52,640 --> 00:09:54,640
directly so

277
00:09:54,640 --> 00:09:56,000
from a memory forensic standpoint

278
00:09:56,000 --> 00:09:58,480
whenever we're looking for a slab we can

279
00:09:58,480 --> 00:10:00,959
just go through

280
00:10:00,959 --> 00:10:04,560
the structures for the capital slab and

281
00:10:04,560 --> 00:10:06,800
pull out everything and have a very nice

282
00:10:06,800 --> 00:10:10,320
and organized list there is slob

283
00:10:10,320 --> 00:10:11,920
which was originally an alternative to

284
00:10:11,920 --> 00:10:13,120
slab for

285
00:10:13,120 --> 00:10:15,200
limited memory or memory constrained

286
00:10:15,200 --> 00:10:16,320
systems

287
00:10:16,320 --> 00:10:18,720
oftentimes embedded or iot device

288
00:10:18,720 --> 00:10:21,200
systems

289
00:10:21,519 --> 00:10:24,399
and slob internally functions

290
00:10:24,399 --> 00:10:28,959
uh just as a basic keep essentially so

291
00:10:28,959 --> 00:10:32,399
in linux kernel 2.6.23 slub replaced

292
00:10:32,399 --> 00:10:33,839
slab

293
00:10:33,839 --> 00:10:35,279
and

294
00:10:35,279 --> 00:10:37,040
the reason for doing this was a number

295
00:10:37,040 --> 00:10:38,640
of internal

296
00:10:38,640 --> 00:10:40,320
optimizations

297
00:10:40,320 --> 00:10:42,160
but from a forensic standpoint the two

298
00:10:42,160 --> 00:10:44,000
key points

299
00:10:44,000 --> 00:10:46,800
that changed were slug no longer just

300
00:10:46,800 --> 00:10:50,079
groups objects based on their type it

301
00:10:50,079 --> 00:10:52,720
creates caches based on the object's

302
00:10:52,720 --> 00:10:55,680
size so

303
00:10:56,640 --> 00:11:00,079
like for example task structures

304
00:11:00,079 --> 00:11:01,519
wouldn't necessarily be grouped with

305
00:11:01,519 --> 00:11:04,320
other task structures but rather objects

306
00:11:04,320 --> 00:11:05,360
attached

307
00:11:05,360 --> 00:11:09,279
of a similar size to task structures

308
00:11:09,279 --> 00:11:12,079
slub also only

309
00:11:12,079 --> 00:11:14,800
tracks partially allocated slabs

310
00:11:14,800 --> 00:11:17,120
which are just slabs that

311
00:11:17,120 --> 00:11:18,640
still have space for more objects to be

312
00:11:18,640 --> 00:11:20,800
put on them so we're not given these

313
00:11:20,800 --> 00:11:22,959
clean lists anymore where we can just

314
00:11:22,959 --> 00:11:24,320
iterate through all the lists and pull

315
00:11:24,320 --> 00:11:27,200
out every slab in memory

316
00:11:27,200 --> 00:11:28,399
so

317
00:11:28,399 --> 00:11:30,480
digging in a little further what exactly

318
00:11:30,480 --> 00:11:32,160
does this lab look like it's just a

319
00:11:32,160 --> 00:11:34,720
pre-allocated chunk of memory

320
00:11:34,720 --> 00:11:36,880
that's contiguous

321
00:11:36,880 --> 00:11:38,800
and it

322
00:11:38,800 --> 00:11:41,920
aligns objects on a size boundary which

323
00:11:41,920 --> 00:11:43,839
is set by the cache that a slab is being

324
00:11:43,839 --> 00:11:46,000
allocated from

325
00:11:46,000 --> 00:11:49,120
very commonly these slabs are one two

326
00:11:49,120 --> 00:11:51,040
four or eight pages although it can vary

327
00:11:51,040 --> 00:11:54,240
depending on system optimizations and

328
00:11:54,240 --> 00:11:55,920
at the end of a slab is a free list

329
00:11:55,920 --> 00:11:57,519
pointer which just simply points to the

330
00:11:57,519 --> 00:11:59,760
next available space that an object can

331
00:11:59,760 --> 00:12:02,319
be stuck in

332
00:12:02,800 --> 00:12:04,079
so

333
00:12:04,079 --> 00:12:06,079
a brief high level overview of the slub

334
00:12:06,079 --> 00:12:08,320
internals as i've been mentioning

335
00:12:08,320 --> 00:12:10,720
previously there are caches

336
00:12:10,720 --> 00:12:12,720
and each of these caches are responsible

337
00:12:12,720 --> 00:12:14,959
for allocating objects of both a certain

338
00:12:14,959 --> 00:12:17,600
size and a certain allocation type the

339
00:12:17,600 --> 00:12:19,680
most common ones are just any old

340
00:12:19,680 --> 00:12:21,839
regular memory allocation and any memory

341
00:12:21,839 --> 00:12:23,760
allocation that needs to occur with

342
00:12:23,760 --> 00:12:26,480
direct memory access available

343
00:12:26,480 --> 00:12:28,800
all these caches are linked together in

344
00:12:28,800 --> 00:12:31,040
memory by a list so once the first cache

345
00:12:31,040 --> 00:12:32,560
is found the rest of the caches can be

346
00:12:32,560 --> 00:12:34,880
enumerated through

347
00:12:34,880 --> 00:12:37,040
and as i mentioned before

348
00:12:37,040 --> 00:12:38,399
in sub-internal

349
00:12:38,399 --> 00:12:41,120
internals there is a partial list

350
00:12:41,120 --> 00:12:43,200
of

351
00:12:43,200 --> 00:12:46,000
slabs that are not fully allocated and

352
00:12:46,000 --> 00:12:49,279
then if slub debug is enabled

353
00:12:49,279 --> 00:12:51,600
um there is also the list of fully

354
00:12:51,600 --> 00:12:53,279
allocated slabs however this cannot be

355
00:12:53,279 --> 00:12:54,480
relied on

356
00:12:54,480 --> 00:12:57,440
to always be there

357
00:12:58,000 --> 00:13:00,480
so how do we get objects out of slabs if

358
00:13:00,480 --> 00:13:02,560
we're given a slab we can start at the

359
00:13:02,560 --> 00:13:05,440
beginning of it and just carve every kmm

360
00:13:05,440 --> 00:13:09,680
cache size bites afterwards and once we

361
00:13:09,680 --> 00:13:11,760
step the size number of bytes afterwards

362
00:13:11,760 --> 00:13:13,760
we're at the start of the next object

363
00:13:13,760 --> 00:13:16,240
and we can just simply walk along

364
00:13:16,240 --> 00:13:18,160
the slab in these steps and pull out

365
00:13:18,160 --> 00:13:19,600
every object

366
00:13:19,600 --> 00:13:21,279
and in the case of slub where there may

367
00:13:21,279 --> 00:13:24,560
be mixed object types we can

368
00:13:24,560 --> 00:13:26,560
validate that these objects are what

369
00:13:26,560 --> 00:13:28,800
we're expecting them to be

370
00:13:28,800 --> 00:13:29,839
now

371
00:13:29,839 --> 00:13:31,519
because slub does not always have all

372
00:13:31,519 --> 00:13:33,760
the lists available

373
00:13:33,760 --> 00:13:35,360
we wanted to

374
00:13:35,360 --> 00:13:36,880
go a little bit further have a little

375
00:13:36,880 --> 00:13:38,480
bit more fun and assume that we didn't

376
00:13:38,480 --> 00:13:40,639
have access to any of the cash lists

377
00:13:40,639 --> 00:13:43,360
neither the partial nor full list so

378
00:13:43,360 --> 00:13:45,279
how do we go about extracting objects in

379
00:13:45,279 --> 00:13:46,839
this

380
00:13:46,839 --> 00:13:48,720
scenario well

381
00:13:48,720 --> 00:13:50,880
from other volatility plugins

382
00:13:50,880 --> 00:13:53,519
we have access to

383
00:13:53,519 --> 00:13:54,959
other kernel lists that are maintained

384
00:13:54,959 --> 00:13:56,880
by linux

385
00:13:56,880 --> 00:13:59,279
and since we know that slub handles all

386
00:13:59,279 --> 00:14:02,639
the small allocations done on a system

387
00:14:02,639 --> 00:14:04,800
if we have an object that is small by

388
00:14:04,800 --> 00:14:07,440
linux's standards that means if we have

389
00:14:07,440 --> 00:14:09,600
a pointer to the object we know where

390
00:14:09,600 --> 00:14:12,639
the object resides in memory

391
00:14:12,639 --> 00:14:14,880
from walking these other kernel lists

392
00:14:14,880 --> 00:14:17,600
then by having an object we have

393
00:14:17,600 --> 00:14:19,040
somewhere

394
00:14:19,040 --> 00:14:21,040
inside of a slab

395
00:14:21,040 --> 00:14:23,599
and from

396
00:14:24,639 --> 00:14:27,199
the cache that a slab would be allocated

397
00:14:27,199 --> 00:14:28,160
from

398
00:14:28,160 --> 00:14:29,120
we know

399
00:14:29,120 --> 00:14:31,360
how far a cache would extend in both

400
00:14:31,360 --> 00:14:34,240
directions so we can just walk both up

401
00:14:34,240 --> 00:14:37,680
and down in memory

402
00:14:38,000 --> 00:14:41,199
to pull out objects

403
00:14:41,360 --> 00:14:42,399
now

404
00:14:42,399 --> 00:14:44,000
i'm not sure how well this is visible in

405
00:14:44,000 --> 00:14:45,839
the back but

406
00:14:45,839 --> 00:14:47,760
this method will generate a lot of junk

407
00:14:47,760 --> 00:14:49,600
since we are going

408
00:14:49,600 --> 00:14:51,279
past the bounds of the slab in both

409
00:14:51,279 --> 00:14:52,880
directions but we're at least guaranteed

410
00:14:52,880 --> 00:14:56,800
to get every single object out of a slab

411
00:14:56,800 --> 00:14:59,519
so to test this um

412
00:14:59,519 --> 00:15:01,279
we set up virtual machines to like

413
00:15:01,279 --> 00:15:02,959
memory samples from because whenever you

414
00:15:02,959 --> 00:15:06,079
suspend or pause or create a

415
00:15:06,079 --> 00:15:09,839
snapshot of a virtual machine you create

416
00:15:09,839 --> 00:15:12,880
a copy of the memory of the virtual

417
00:15:12,880 --> 00:15:14,639
machine running

418
00:15:14,639 --> 00:15:16,880
so this gives us a memory file to work

419
00:15:16,880 --> 00:15:18,160
off of

420
00:15:18,160 --> 00:15:19,519
and then inside of these virtual

421
00:15:19,519 --> 00:15:21,760
machines we ran some pro just various

422
00:15:21,760 --> 00:15:24,320
command line usage and a artifact

423
00:15:24,320 --> 00:15:26,480
generating program which just created

424
00:15:26,480 --> 00:15:29,040
some sockets closed and freed them

425
00:15:29,040 --> 00:15:32,639
which gives us something to look for

426
00:15:33,279 --> 00:15:35,279
in memory that we know what it looks

427
00:15:35,279 --> 00:15:37,519
like

428
00:15:37,680 --> 00:15:39,759
so obvi so some of the goals we wanted

429
00:15:39,759 --> 00:15:43,120
to achieve was creating a new plugin

430
00:15:43,120 --> 00:15:45,680
updating an old plugin slab info to

431
00:15:45,680 --> 00:15:48,399
accommodate slub systems since it slab

432
00:15:48,399 --> 00:15:50,639
info has also not been updated to

433
00:15:50,639 --> 00:15:52,880
accommodate subsystems

434
00:15:52,880 --> 00:15:55,680
and recover any processor socket

435
00:15:55,680 --> 00:15:57,519
information that we can

436
00:15:57,519 --> 00:15:58,320
so

437
00:15:58,320 --> 00:16:01,360
this is the first part of the demo

438
00:16:01,360 --> 00:16:05,639
and hopefully all will go well

439
00:16:10,959 --> 00:16:13,439
all right

440
00:16:13,759 --> 00:16:17,279
oh i cannot read that at all

441
00:16:20,800 --> 00:16:22,639
i may just have to

442
00:16:22,639 --> 00:16:23,839
sorry folks a little technical

443
00:16:23,839 --> 00:16:26,560
difficulties

444
00:16:31,440 --> 00:16:33,759
all right um

445
00:16:33,759 --> 00:16:36,160
can everyone read that i know the glare

446
00:16:36,160 --> 00:16:38,320
is not the best

447
00:16:38,320 --> 00:16:41,600
not at all all right

448
00:16:41,920 --> 00:16:43,680
so

449
00:16:43,680 --> 00:16:45,920
i may just unfortunately have to resort

450
00:16:45,920 --> 00:16:50,360
to using the backup slides on this

451
00:16:51,360 --> 00:16:52,639
[Music]

452
00:16:52,639 --> 00:16:55,639
wow

453
00:17:05,520 --> 00:17:08,710
[Music]

454
00:17:10,559 --> 00:17:12,959
oh damn that windows

455
00:17:12,959 --> 00:17:14,640
you gotta love when windows decides to

456
00:17:14,640 --> 00:17:16,000
just revert back to settings because you

457
00:17:16,000 --> 00:17:18,319
didn't hit a button

458
00:17:18,319 --> 00:17:20,160
all right well we'll just have to wing

459
00:17:20,160 --> 00:17:21,199
it

460
00:17:21,199 --> 00:17:22,240
so

461
00:17:22,240 --> 00:17:24,880
unfortunately demo didn't work but

462
00:17:24,880 --> 00:17:27,119
this is just a snapshot of what you

463
00:17:27,119 --> 00:17:30,559
would have seen live so

464
00:17:30,559 --> 00:17:32,799
first we just had to test whether or not

465
00:17:32,799 --> 00:17:34,080
our

466
00:17:34,080 --> 00:17:36,000
well first we had to update the old slab

467
00:17:36,000 --> 00:17:37,919
info plugin to give us valid information

468
00:17:37,919 --> 00:17:40,480
for the caches

469
00:17:40,480 --> 00:17:43,360
this is just as simple as running the or

470
00:17:43,360 --> 00:17:47,039
reading from the um

471
00:17:47,039 --> 00:17:50,480
the slash proc slash slab info file on a

472
00:17:50,480 --> 00:17:52,960
linux system which runs

473
00:17:52,960 --> 00:17:55,360
this program prints out all the metadata

474
00:17:55,360 --> 00:17:58,080
information for

475
00:17:58,080 --> 00:17:58,960
the

476
00:17:58,960 --> 00:18:01,120
caches on linux and then we can validate

477
00:18:01,120 --> 00:18:02,160
that

478
00:18:02,160 --> 00:18:03,919
our

479
00:18:03,919 --> 00:18:06,240
program's working because

480
00:18:06,240 --> 00:18:08,400
the parts in the top match the parts in

481
00:18:08,400 --> 00:18:09,919
the bottom

482
00:18:09,919 --> 00:18:13,200
so moving on to a little more

483
00:18:13,200 --> 00:18:15,360
interesting stuff so how does this

484
00:18:15,360 --> 00:18:17,600
actually work with carving out

485
00:18:17,600 --> 00:18:19,919
objects that we're looking for so when

486
00:18:19,919 --> 00:18:22,240
we run netstat on

487
00:18:22,240 --> 00:18:25,360
the system we pull out a number of

488
00:18:25,360 --> 00:18:28,000
sockets and ports ranging from 1080 to

489
00:18:28,000 --> 00:18:32,320
about 1084 or 1094

490
00:18:32,720 --> 00:18:34,080
and there's some holes in the middle

491
00:18:34,080 --> 00:18:35,760
which are the sockets that the program

492
00:18:35,760 --> 00:18:38,720
has decided to

493
00:18:38,720 --> 00:18:40,320
close and free up

494
00:18:40,320 --> 00:18:42,080
and then whenever we go back with our

495
00:18:42,080 --> 00:18:44,160
carving approach we're able to pull out

496
00:18:44,160 --> 00:18:46,160
three of the sockets that were found or

497
00:18:46,160 --> 00:18:48,000
three of the sockets that

498
00:18:48,000 --> 00:18:50,960
were created on the system

499
00:18:50,960 --> 00:18:52,400
so

500
00:18:52,400 --> 00:18:54,320
likewise we can use this approach for

501
00:18:54,320 --> 00:18:56,640
carving out some of the processes that

502
00:18:56,640 --> 00:18:58,720
had ran and stopped which were just some

503
00:18:58,720 --> 00:18:59,600
of the

504
00:18:59,600 --> 00:19:01,200
command lines that had been ran

505
00:19:01,200 --> 00:19:02,320
previously

506
00:19:02,320 --> 00:19:03,840
additionally

507
00:19:03,840 --> 00:19:06,080
volatility by default hides the swapper

508
00:19:06,080 --> 00:19:09,280
processes from the linux from the ps lit

509
00:19:09,280 --> 00:19:12,160
or the ps list command so this is a

510
00:19:12,160 --> 00:19:13,760
little bit of sanity checking and that

511
00:19:13,760 --> 00:19:17,440
we're able to find it with carving

512
00:19:17,440 --> 00:19:19,520
so

513
00:19:19,520 --> 00:19:21,679
that was a little experiment now how

514
00:19:21,679 --> 00:19:23,600
does this actually fare against real

515
00:19:23,600 --> 00:19:25,520
world malware

516
00:19:25,520 --> 00:19:28,000
a little bit of background is bpf door

517
00:19:28,000 --> 00:19:31,200
was a targeted and incredibly invasive

518
00:19:31,200 --> 00:19:32,880
malware

519
00:19:32,880 --> 00:19:34,640
it

520
00:19:34,640 --> 00:19:37,600
whenever it ran on a linux system it

521
00:19:37,600 --> 00:19:40,080
wrote itself directly into memory

522
00:19:40,080 --> 00:19:42,080
killed the original process cleared out

523
00:19:42,080 --> 00:19:44,640
all of the related data

524
00:19:44,640 --> 00:19:47,360
for the previous process and the newly

525
00:19:47,360 --> 00:19:49,360
running process it used a berkeley

526
00:19:49,360 --> 00:19:50,640
packet filter

527
00:19:50,640 --> 00:19:52,559
to sniff traffic

528
00:19:52,559 --> 00:19:55,679
which allowed it to read um any traffic

529
00:19:55,679 --> 00:19:57,760
approaching the system before it hit the

530
00:19:57,760 --> 00:20:00,080
firewall since these packets are a

531
00:20:00,080 --> 00:20:02,240
filter below the firewall

532
00:20:02,240 --> 00:20:04,000
and so any packet that had the magic

533
00:20:04,000 --> 00:20:06,559
value in would get passed to this

534
00:20:06,559 --> 00:20:09,840
program which would just check basically

535
00:20:09,840 --> 00:20:12,159
whether it was one of three commands

536
00:20:12,159 --> 00:20:14,880
one being a reverse shell

537
00:20:14,880 --> 00:20:17,440
one being a reverse connect or a connect

538
00:20:17,440 --> 00:20:19,440
back shell and then the third was just a

539
00:20:19,440 --> 00:20:20,799
heartbeat

540
00:20:20,799 --> 00:20:21,600
um

541
00:20:21,600 --> 00:20:24,559
the program is still running

542
00:20:24,559 --> 00:20:25,760
so

543
00:20:25,760 --> 00:20:28,000
through traditional means this is very

544
00:20:28,000 --> 00:20:30,559
hard to detect on systems however

545
00:20:30,559 --> 00:20:33,360
normally through memory forensics

546
00:20:33,360 --> 00:20:36,559
um we can run the ps list command which

547
00:20:36,559 --> 00:20:39,520
shows us one of the aliases

548
00:20:39,520 --> 00:20:41,280
the bpf

549
00:20:41,280 --> 00:20:44,400
door malware uses

550
00:20:44,400 --> 00:20:47,520
one being slash user lib slash system

551
00:20:47,520 --> 00:20:49,360
which looks suspicious

552
00:20:49,360 --> 00:20:50,400
since

553
00:20:50,400 --> 00:20:51,919
normally

554
00:20:51,919 --> 00:20:53,919
the name is just the name of the program

555
00:20:53,919 --> 00:20:56,799
for the process not the actual path to

556
00:20:56,799 --> 00:20:59,200
that process

557
00:20:59,200 --> 00:21:01,360
and traditionally

558
00:21:01,360 --> 00:21:03,200
we can look at the socket filters and

559
00:21:03,200 --> 00:21:05,760
find the bpf filter set up by the

560
00:21:05,760 --> 00:21:06,799
process

561
00:21:06,799 --> 00:21:08,640
and this would look suspicious because

562
00:21:08,640 --> 00:21:10,720
it is a af packet

563
00:21:10,720 --> 00:21:12,720
with a stock type of raw so it's just

564
00:21:12,720 --> 00:21:14,320
reading the raw network data that's

565
00:21:14,320 --> 00:21:15,679
coming in

566
00:21:15,679 --> 00:21:17,600
which should trigger some alarms since

567
00:21:17,600 --> 00:21:20,159
usually only

568
00:21:20,159 --> 00:21:23,280
system level stuff should be running

569
00:21:23,280 --> 00:21:24,880
these packet filters

570
00:21:24,880 --> 00:21:26,080
now

571
00:21:26,080 --> 00:21:27,760
one of the other samples

572
00:21:27,760 --> 00:21:30,720
that we had run was the bpf door only it

573
00:21:30,720 --> 00:21:33,039
had additional root kick root kit

574
00:21:33,039 --> 00:21:35,120
functionality to hide itself

575
00:21:35,120 --> 00:21:37,360
from the kernel list

576
00:21:37,360 --> 00:21:39,600
so

577
00:21:42,559 --> 00:21:44,960
in the listing shown here if you are

578
00:21:44,960 --> 00:21:46,400
able to read it you'll see that there's

579
00:21:46,400 --> 00:21:49,280
no suspicious processes running

580
00:21:49,280 --> 00:21:53,360
and then likewise we don't find the

581
00:21:53,360 --> 00:21:55,760
packet filter set up by the malware

582
00:21:55,760 --> 00:21:58,080
because it's removed itself from linux's

583
00:21:58,080 --> 00:21:59,760
process list so

584
00:21:59,760 --> 00:22:01,600
since the socket filter relies on the

585
00:22:01,600 --> 00:22:04,400
linux process list

586
00:22:04,400 --> 00:22:06,080
to pull out any of the socket

587
00:22:06,080 --> 00:22:08,880
information it's also hidden there

588
00:22:08,880 --> 00:22:11,440
however with a carving approach we are

589
00:22:11,440 --> 00:22:14,240
able to ultimately find

590
00:22:14,240 --> 00:22:16,080
the malicious process running on the

591
00:22:16,080 --> 00:22:18,559
system

592
00:22:18,720 --> 00:22:21,840
and thus busting it

593
00:22:21,840 --> 00:22:23,600
so

594
00:22:23,600 --> 00:22:25,360
overall

595
00:22:25,360 --> 00:22:27,520
recovering free or hidden objects is

596
00:22:27,520 --> 00:22:28,480
important

597
00:22:28,480 --> 00:22:30,880
free objects provide additional context

598
00:22:30,880 --> 00:22:33,679
into the system

599
00:22:33,679 --> 00:22:35,919
and give a little bit more resiliency to

600
00:22:35,919 --> 00:22:38,159
when you take a memory sample

601
00:22:38,159 --> 00:22:41,039
and then likewise any objects that have

602
00:22:41,039 --> 00:22:45,760
been hidden through malicious methods

603
00:22:45,760 --> 00:22:50,720
you obviously those raise concerns

604
00:22:51,039 --> 00:22:52,559
and you would want to

605
00:22:52,559 --> 00:22:55,200
find those through

606
00:22:55,200 --> 00:22:57,120
memory forensics

607
00:22:57,120 --> 00:22:58,960
and then this approach is still useful

608
00:22:58,960 --> 00:23:00,720
even if a

609
00:23:00,720 --> 00:23:02,559
traditional full

610
00:23:02,559 --> 00:23:03,520
cache

611
00:23:03,520 --> 00:23:06,000
list extraction is available

612
00:23:06,000 --> 00:23:07,360
since

613
00:23:07,360 --> 00:23:10,480
one going through that process involves

614
00:23:10,480 --> 00:23:11,600
some

615
00:23:11,600 --> 00:23:13,600
back-end calculations that will slow it

616
00:23:13,600 --> 00:23:14,480
down

617
00:23:14,480 --> 00:23:18,880
as well as this still provides a

618
00:23:18,880 --> 00:23:21,280
solution for when slub debug is not

619
00:23:21,280 --> 00:23:23,520
enabled which would hide some of the

620
00:23:23,520 --> 00:23:27,039
slabs through traditional means

621
00:23:27,280 --> 00:23:28,159
um

622
00:23:28,159 --> 00:23:31,760
so just a quick summary

623
00:23:32,000 --> 00:23:34,880
the work we did developed a method for

624
00:23:34,880 --> 00:23:37,200
extracting objects from the slub

625
00:23:37,200 --> 00:23:39,679
allocator on linux systems which allows

626
00:23:39,679 --> 00:23:42,080
volatility to extract hidden data on

627
00:23:42,080 --> 00:23:44,799
memory samples

628
00:23:44,799 --> 00:23:47,039
created a new plugin to use as well as

629
00:23:47,039 --> 00:23:48,880
updating an old plugin to accommodate

630
00:23:48,880 --> 00:23:51,440
the new system

631
00:23:51,440 --> 00:23:53,279
and some of quickly some of the future

632
00:23:53,279 --> 00:23:54,960
work for this uh would be obviously

633
00:23:54,960 --> 00:23:56,480
updating the plug-in for volatility

634
00:23:56,480 --> 00:23:59,120
three volatility is currently in between

635
00:23:59,120 --> 00:24:00,320
version

636
00:24:00,320 --> 00:24:02,640
two and three so a lot of developments

637
00:24:02,640 --> 00:24:04,640
done for two but will ultimately be

638
00:24:04,640 --> 00:24:05,760
updated for three

639
00:24:05,760 --> 00:24:06,799
[Music]

640
00:24:06,799 --> 00:24:08,799
add some additional polish and filter to

641
00:24:08,799 --> 00:24:10,799
the plugin so it doesn't produce as much

642
00:24:10,799 --> 00:24:12,960
noise

643
00:24:12,960 --> 00:24:15,520
in the output and then finally linux is

644
00:24:15,520 --> 00:24:18,240
adding a new way of representing memory

645
00:24:18,240 --> 00:24:21,600
in newer linux kernel versions which

646
00:24:21,600 --> 00:24:25,600
will definitely impact memory forensics

647
00:24:25,840 --> 00:24:29,080
thank you

648
00:24:35,120 --> 00:24:35,919
um

649
00:24:35,919 --> 00:24:38,640
is there anyone with questions

650
00:24:38,640 --> 00:24:41,640
um

651
00:24:43,050 --> 00:24:46,200
[Music]

652
00:24:49,440 --> 00:24:51,760
scrub memory that you're free

653
00:24:51,760 --> 00:24:54,000
but in that case does that potentially

654
00:24:54,000 --> 00:24:55,960
limit your ability to detect some of

655
00:24:55,960 --> 00:25:01,200
these hits that might only manifold

656
00:25:01,679 --> 00:25:03,120
all right so just wanna make sure i

657
00:25:03,120 --> 00:25:04,400
heard everything right um so the

658
00:25:04,400 --> 00:25:06,400
question was uh how does this work in

659
00:25:06,400 --> 00:25:08,880
situations where a malicious process may

660
00:25:08,880 --> 00:25:11,360
try to uh scrub itself out of memory

661
00:25:11,360 --> 00:25:15,360
after it runs to unload so

662
00:25:15,360 --> 00:25:18,799
that would defeat this approach however

663
00:25:18,799 --> 00:25:20,880
approaches like that still have the

664
00:25:20,880 --> 00:25:23,120
possibility of creating other artifacts

665
00:25:23,120 --> 00:25:25,120
on the system that would indicate that a

666
00:25:25,120 --> 00:25:26,799
process tried to scrub itself out of

667
00:25:26,799 --> 00:25:29,520
memory as it was leaving which would

668
00:25:29,520 --> 00:25:33,200
still raise it as suspicious it may hide

669
00:25:33,200 --> 00:25:35,679
certain functionality of that depending

670
00:25:35,679 --> 00:25:37,520
on what it's trying to scrub but it

671
00:25:37,520 --> 00:25:38,559
would still

672
00:25:38,559 --> 00:25:40,320
ultimately create more artifacts that

673
00:25:40,320 --> 00:25:41,600
would point back to it as being

674
00:25:41,600 --> 00:25:43,840
suspicious

675
00:25:54,000 --> 00:25:55,600
that you're going through and basically

676
00:25:55,600 --> 00:25:57,279
saying even if i can't

677
00:25:57,279 --> 00:25:59,679
so to represent this i can characterize

678
00:25:59,679 --> 00:26:02,720
this very last thing

679
00:26:03,919 --> 00:26:05,760
you showed examples of places where you

680
00:26:05,760 --> 00:26:07,919
knew the types of lists in the walking

681
00:26:07,919 --> 00:26:09,039
process

682
00:26:09,039 --> 00:26:11,919
right do you think your technique is

683
00:26:11,919 --> 00:26:13,440
trying to just find

684
00:26:13,440 --> 00:26:15,279
blocks that have seemed to have similar

685
00:26:15,279 --> 00:26:18,000
characteristics

686
00:26:19,919 --> 00:26:21,679
so

687
00:26:21,679 --> 00:26:24,559
right the question is um could this

688
00:26:24,559 --> 00:26:26,960
approach be used to go through memory

689
00:26:26,960 --> 00:26:29,360
and categorize different regions as like

690
00:26:29,360 --> 00:26:32,240
similar yeah

691
00:26:34,480 --> 00:26:35,360
so

692
00:26:35,360 --> 00:26:37,200
not

693
00:26:37,200 --> 00:26:39,279
not the approach i directly implemented

694
00:26:39,279 --> 00:26:40,880
this um

695
00:26:40,880 --> 00:26:43,760
very much targets um

696
00:26:43,760 --> 00:26:46,320
a specific linux memory allocator

697
00:26:46,320 --> 00:26:48,559
um

698
00:26:48,559 --> 00:26:51,200
so this hunts for regions of memory

699
00:26:51,200 --> 00:26:52,720
allocated

700
00:26:52,720 --> 00:26:55,679
and you would know based on the cashier

701
00:26:55,679 --> 00:26:58,080
enumerating what types of objects would

702
00:26:58,080 --> 00:27:00,559
be there where whether it's a special

703
00:27:00,559 --> 00:27:02,320
cache that's been like specifically

704
00:27:02,320 --> 00:27:04,159
allocated for

705
00:27:04,159 --> 00:27:06,159
a certain object or a set of objects or

706
00:27:06,159 --> 00:27:08,240
just a general cache

707
00:27:08,240 --> 00:27:10,640
um so this still like pinpoints like

708
00:27:10,640 --> 00:27:12,640
regions of memory to analyze but it

709
00:27:12,640 --> 00:27:17,880
doesn't do entropy analysis itself

710
00:27:24,320 --> 00:27:27,320
uh

711
00:27:35,919 --> 00:27:38,320
so um the question was

712
00:27:38,320 --> 00:27:39,760
how would this approach fare in

713
00:27:39,760 --> 00:27:42,240
environments i use a lot of containers

714
00:27:42,240 --> 00:27:44,240
um so i don't have that much background

715
00:27:44,240 --> 00:27:48,760
on containers uh so

716
00:27:50,799 --> 00:27:53,440
so are you asking if

717
00:27:53,440 --> 00:27:55,520
like you're analyzing the memory of this

718
00:27:55,520 --> 00:27:57,039
like system running the containers or

719
00:27:57,039 --> 00:27:58,559
the memory inside of the containers

720
00:27:58,559 --> 00:28:01,559
themselves

721
00:28:14,240 --> 00:28:16,559
yeah so i think that would depend on the

722
00:28:16,559 --> 00:28:19,600
specific uh container you're looking at

723
00:28:19,600 --> 00:28:21,520
just how like that gets set up in memory

724
00:28:21,520 --> 00:28:22,880
and which kernel structures it would

725
00:28:22,880 --> 00:28:26,320
allocate because this ultimately is a

726
00:28:26,320 --> 00:28:28,320
kernel allocator so

727
00:28:28,320 --> 00:28:30,799
a lot of user land objects

728
00:28:30,799 --> 00:28:32,399
which i'm

729
00:28:32,399 --> 00:28:33,600
not being familiar enough with

730
00:28:33,600 --> 00:28:34,880
containers i don't know which parts of

731
00:28:34,880 --> 00:28:36,399
the container would fall under would

732
00:28:36,399 --> 00:28:38,320
create kernel objects versus user land

733
00:28:38,320 --> 00:28:39,520
objects

734
00:28:39,520 --> 00:28:40,559
um

735
00:28:40,559 --> 00:28:41,760
so you could definitely use it to

736
00:28:41,760 --> 00:28:44,000
analyze the kernel objects it creates

737
00:28:44,000 --> 00:28:46,559
especially if like it creates

738
00:28:46,559 --> 00:28:47,440
um

739
00:28:47,440 --> 00:28:49,440
when containers are being spun up or

740
00:28:49,440 --> 00:28:50,559
create any

741
00:28:50,559 --> 00:28:53,120
um allocations if they have like any

742
00:28:53,120 --> 00:28:55,440
mark like remarkable features

743
00:28:55,440 --> 00:28:58,880
that you can say like this like is a

744
00:28:58,880 --> 00:29:00,480
docker container

745
00:29:00,480 --> 00:29:03,200
object whatever

746
00:29:03,200 --> 00:29:05,520
based on some like specific markings or

747
00:29:05,520 --> 00:29:07,279
like a specific set of flags that get

748
00:29:07,279 --> 00:29:10,279
set

749
00:29:12,320 --> 00:29:14,399
right this is you're given a memory

750
00:29:14,399 --> 00:29:17,200
sample of linux how can you better

751
00:29:17,200 --> 00:29:18,880
analyze it using

752
00:29:18,880 --> 00:29:20,399
um

753
00:29:20,399 --> 00:29:25,000
the memory allocators present in linux

754
00:29:30,920 --> 00:29:34,019
[Applause]

755
00:29:38,880 --> 00:29:41,039
how

756
00:29:43,279 --> 00:29:46,799
defeating this technique um

757
00:29:50,159 --> 00:29:52,320
so probably the most direct way to

758
00:29:52,320 --> 00:29:54,080
defeat the so the question was how would

759
00:29:54,080 --> 00:29:56,159
you defeat this technique and the most

760
00:29:56,159 --> 00:29:57,679
direct way would be

761
00:29:57,679 --> 00:30:01,360
um doing your best to scrub

762
00:30:01,360 --> 00:30:03,600
um

763
00:30:04,080 --> 00:30:04,880
would

764
00:30:04,880 --> 00:30:05,919
it would probably

765
00:30:05,919 --> 00:30:08,000
you would have to mingle whatever like

766
00:30:08,000 --> 00:30:09,520
if you have a process you're trying to

767
00:30:09,520 --> 00:30:11,440
hide you would have to mangle it so that

768
00:30:11,440 --> 00:30:14,880
it wouldn't appear like a valid process

769
00:30:14,880 --> 00:30:16,520
if you were to apply um

770
00:30:16,520 --> 00:30:17,760
[Music]

771
00:30:17,760 --> 00:30:20,080
for a particular memory sample you would

772
00:30:20,080 --> 00:30:21,760
know it's linux

773
00:30:21,760 --> 00:30:23,279
x dot x

774
00:30:23,279 --> 00:30:24,960
you know what the task structure looks

775
00:30:24,960 --> 00:30:25,760
like

776
00:30:25,760 --> 00:30:29,360
so it has all the fields and set offsets

777
00:30:29,360 --> 00:30:31,440
um so you would have to mingle a process

778
00:30:31,440 --> 00:30:34,840
struct in a way where it would still run

779
00:30:34,840 --> 00:30:37,760
but if you were to try and fit the data

780
00:30:37,760 --> 00:30:39,440
into the mold of a task struct it

781
00:30:39,440 --> 00:30:41,679
wouldn't look valid

782
00:30:41,679 --> 00:30:43,760
but the risk of that is also in the

783
00:30:43,760 --> 00:30:46,399
process of mangling anything

784
00:30:46,399 --> 00:30:48,640
you also run the risk of creating more

785
00:30:48,640 --> 00:30:51,360
artifacts that points to the mangling

786
00:30:51,360 --> 00:30:53,120
which then raises suspicion about

787
00:30:53,120 --> 00:30:56,678
whatever gets mangled

788
00:31:04,480 --> 00:31:08,360
i'm good if there's no more questions

