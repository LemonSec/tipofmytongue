1
00:00:00,080 --> 00:00:01,439
uh what's up please welcome jonathan

2
00:00:01,439 --> 00:00:04,480
lightshoe and patrick white

3
00:00:08,720 --> 00:00:10,080
hello everybody

4
00:00:10,080 --> 00:00:12,960
uh good afternoon and welcome to uh

5
00:00:12,960 --> 00:00:14,240
scaling the security research to

6
00:00:14,240 --> 00:00:16,320
eliminate open source uh vulnerabilities

7
00:00:16,320 --> 00:00:17,760
once and for all

8
00:00:17,760 --> 00:00:21,199
um my name is jonathan leitchu i am a

9
00:00:21,199 --> 00:00:23,119
software engineer software security

10
00:00:23,119 --> 00:00:24,480
researcher

11
00:00:24,480 --> 00:00:26,880
i'm the first ever dan kaminski fellow

12
00:00:26,880 --> 00:00:29,199
at human security i'm a ghetto star and

13
00:00:29,199 --> 00:00:30,960
get up security ambassador um and you

14
00:00:30,960 --> 00:00:33,040
can find me on twitter at jlightshoe and

15
00:00:33,040 --> 00:00:35,280
on github at j light you as well

16
00:00:35,280 --> 00:00:37,760
and patrick

17
00:00:37,760 --> 00:00:40,079
uh yeah i'm patrick way i

18
00:00:40,079 --> 00:00:42,000
work from darren i'm the open rewrite

19
00:00:42,000 --> 00:00:44,800
team i've been writing software for 20

20
00:00:44,800 --> 00:00:46,800
years or more and excited to be here

21
00:00:46,800 --> 00:00:49,280
talking to you today

22
00:00:49,280 --> 00:00:52,000
so short disclaimer um

23
00:00:52,000 --> 00:00:53,920
uh we're going to be discussing so first

24
00:00:53,920 --> 00:00:55,600
off i'm sponsored by github second off

25
00:00:55,600 --> 00:00:57,760
we're discussing a sas solution

26
00:00:57,760 --> 00:00:59,920
that is sold however all the tools and

27
00:00:59,920 --> 00:01:01,280
infrastructure and everything discussed

28
00:01:01,280 --> 00:01:02,800
in this talk is available for free and

29
00:01:02,800 --> 00:01:05,519
free for open source uh are not free for

30
00:01:05,519 --> 00:01:07,119
corporate but free for open source and

31
00:01:07,119 --> 00:01:08,880
you can use this stuff in your own

32
00:01:08,880 --> 00:01:10,479
security research focused on open source

33
00:01:10,479 --> 00:01:12,240
software

34
00:01:12,240 --> 00:01:13,680
and with that other way i want to talk

35
00:01:13,680 --> 00:01:15,840
about so this uh the work and my

36
00:01:15,840 --> 00:01:17,520
employment is sponsored by the dan

37
00:01:17,520 --> 00:01:20,000
kaminski fellowship

38
00:01:20,000 --> 00:01:23,680
the dan kaminski fellowship was created

39
00:01:23,680 --> 00:01:26,799
after dan passed away last year i sadly

40
00:01:26,799 --> 00:01:29,200
never got the opportunity to meet dan um

41
00:01:29,200 --> 00:01:31,200
dan for those of you who don't know was

42
00:01:31,200 --> 00:01:33,119
the hero that was uh he was known as the

43
00:01:33,119 --> 00:01:34,960
hero of the internet for his incredible

44
00:01:34,960 --> 00:01:37,600
2008 dns vulnerability that he helped

45
00:01:37,600 --> 00:01:40,320
silently patch

46
00:01:40,320 --> 00:01:41,680
and the dan committee fellowship was

47
00:01:41,680 --> 00:01:43,439
created to celebrate dan's memory and

48
00:01:43,439 --> 00:01:45,759
legacy by funding open source work that

49
00:01:45,759 --> 00:01:47,360
makes the world a better and more secure

50
00:01:47,360 --> 00:01:49,040
place

51
00:01:49,040 --> 00:01:50,799
if you have a project that you want to

52
00:01:50,799 --> 00:01:51,920
work on

53
00:01:51,920 --> 00:01:53,439
that you think will help improve the

54
00:01:53,439 --> 00:01:55,119
security of the internet human is

55
00:01:55,119 --> 00:01:56,960
accepting applications for the 2022 dan

56
00:01:56,960 --> 00:02:00,079
kaminski fellow currently

57
00:02:00,880 --> 00:02:02,320
so this story started with a

58
00:02:02,320 --> 00:02:04,880
vulnerability a simple vulnerability

59
00:02:04,880 --> 00:02:06,320
and this vulnerability existed in my

60
00:02:06,320 --> 00:02:08,399
company's code

61
00:02:08,399 --> 00:02:10,399
it was the use of http to resolve

62
00:02:10,399 --> 00:02:12,400
dependencies in in my company's gradle

63
00:02:12,400 --> 00:02:14,480
build um and the reason this is

64
00:02:14,480 --> 00:02:16,560
important is because if you're using hdp

65
00:02:16,560 --> 00:02:18,319
to resolve your dependencies in a maven

66
00:02:18,319 --> 00:02:20,879
in your gradle or maven build um

67
00:02:20,879 --> 00:02:23,840
it uh you can have that connection get

68
00:02:23,840 --> 00:02:25,440
intercepted and people can maliciously

69
00:02:25,440 --> 00:02:27,040
inject additional code and be running

70
00:02:27,040 --> 00:02:28,560
additional code in your ci cd

71
00:02:28,560 --> 00:02:30,080
development pipeline or on your

72
00:02:30,080 --> 00:02:31,519
developer machines

73
00:02:31,519 --> 00:02:33,040
and this vulnerability didn't just exist

74
00:02:33,040 --> 00:02:35,680
in gradle builds uh i it can also exist

75
00:02:35,680 --> 00:02:37,680
in maven builds this is an example that

76
00:02:37,680 --> 00:02:38,879
where your dependencies are getting

77
00:02:38,879 --> 00:02:40,720
resolved uh for compiler and test

78
00:02:40,720 --> 00:02:43,120
dependencies and this is artifact upload

79
00:02:43,120 --> 00:02:45,040
so this is the final release artifact

80
00:02:45,040 --> 00:02:46,480
for a gradle

81
00:02:46,480 --> 00:02:48,080
for a maven build and with this

82
00:02:48,080 --> 00:02:49,440
credentials are also attached to it so

83
00:02:49,440 --> 00:02:50,640
you're also exposing credentials

84
00:02:50,640 --> 00:02:51,840
publicly

85
00:02:51,840 --> 00:02:54,160
and this vulnerability was everywhere

86
00:02:54,160 --> 00:02:57,440
it impacted organizations like spring

87
00:02:57,440 --> 00:02:59,760
apache foundation red hat kotlin

88
00:02:59,760 --> 00:03:02,959
jetbrains jenkins gradle groovy

89
00:03:02,959 --> 00:03:07,360
elasticsearch eclipse um oracle the nsa

90
00:03:07,360 --> 00:03:11,440
linkedin and stripe um and so i i found

91
00:03:11,440 --> 00:03:13,040
this vulnerability impacting all of the

92
00:03:13,040 --> 00:03:14,319
open source projects of all these

93
00:03:14,319 --> 00:03:15,760
different organizations across their

94
00:03:15,760 --> 00:03:17,040
getup accounts

95
00:03:17,040 --> 00:03:19,120
and at this point i realize i was like

96
00:03:19,120 --> 00:03:21,120
this is bigger than i thought um so i

97
00:03:21,120 --> 00:03:23,120
reached out to maven sauna type maven

98
00:03:23,120 --> 00:03:26,239
sonar type is is um the pip to the

99
00:03:26,239 --> 00:03:28,959
python ecosystem the uh npm to the

100
00:03:28,959 --> 00:03:30,959
javascript ecosystem maven sonotype is

101
00:03:30,959 --> 00:03:33,280
that to the java to the java ecosystem

102
00:03:33,280 --> 00:03:34,959
and they said that they looked at their

103
00:03:34,959 --> 00:03:37,040
traffic logs and saw that 25 of their

104
00:03:37,040 --> 00:03:39,040
traffic was still using hdp in june of

105
00:03:39,040 --> 00:03:40,480
2019

106
00:03:40,480 --> 00:03:42,480
and so i said all right how do we fix

107
00:03:42,480 --> 00:03:43,360
this

108
00:03:43,360 --> 00:03:45,680
so i pushed forward an initiative that

109
00:03:45,680 --> 00:03:48,400
on january 15th 2020 all the major

110
00:03:48,400 --> 00:03:50,640
artifact servers in the java ecosystem

111
00:03:50,640 --> 00:03:52,480
would decommission support for hdp in

112
00:03:52,480 --> 00:03:57,040
favor of hdp https only

113
00:03:57,439 --> 00:03:58,879
and uh

114
00:03:58,879 --> 00:04:00,879
and we published a blog post i published

115
00:04:00,879 --> 00:04:03,200
a blog post and then i reached out to me

116
00:04:03,200 --> 00:04:05,360
and sauna type again um in january of

117
00:04:05,360 --> 00:04:07,680
2020 and they said that 20 of their

118
00:04:07,680 --> 00:04:10,239
central traffic was still using hgb

119
00:04:10,239 --> 00:04:13,360
instead of https even after you know uh

120
00:04:13,360 --> 00:04:15,280
like three quarters of a year of trying

121
00:04:15,280 --> 00:04:17,358
to disclose this to people

122
00:04:17,358 --> 00:04:19,199
and so

123
00:04:19,199 --> 00:04:21,040
you can imagine what happened

124
00:04:21,040 --> 00:04:24,000
on january 15 2020

125
00:04:24,000 --> 00:04:25,840
broken software broken software

126
00:04:25,840 --> 00:04:26,840
everywhere

127
00:04:26,840 --> 00:04:30,800
um uh but we stopped the bleeding um

128
00:04:30,800 --> 00:04:32,720
but this didn't fix the whole problem

129
00:04:32,720 --> 00:04:34,960
what about the other repositories

130
00:04:34,960 --> 00:04:36,400
these are only the most commonly used

131
00:04:36,400 --> 00:04:38,639
repositories in the java system um maven

132
00:04:38,639 --> 00:04:40,639
central j center spring and and the

133
00:04:40,639 --> 00:04:43,199
gradle plug-in portal other companies

134
00:04:43,199 --> 00:04:45,600
post their own java artifacts on their

135
00:04:45,600 --> 00:04:47,360
own servers and so you'll see other

136
00:04:47,360 --> 00:04:50,800
companies uh urls are build your urls

137
00:04:50,800 --> 00:04:52,720
and other builds across the system so

138
00:04:52,720 --> 00:04:55,280
how do how do we fix the rest

139
00:04:55,280 --> 00:04:57,840
and i said well i mean

140
00:04:57,840 --> 00:04:59,440
opening issues is one way to do this but

141
00:04:59,440 --> 00:05:01,919
like let's just go fix the problem right

142
00:05:01,919 --> 00:05:04,000
um and so i said let i'm gonna try bulk

143
00:05:04,000 --> 00:05:05,759
pull request generation

144
00:05:05,759 --> 00:05:09,280
and so how did i do this the uh first

145
00:05:09,280 --> 00:05:10,639
off the first thing you need to do is

146
00:05:10,639 --> 00:05:12,240
you need to find the projects that are

147
00:05:12,240 --> 00:05:13,759
vulnerable right you need to identify

148
00:05:13,759 --> 00:05:15,199
the open source projects that have this

149
00:05:15,199 --> 00:05:17,199
vulnerability and so how i did this was

150
00:05:17,199 --> 00:05:19,199
i wrote a code query for it

151
00:05:19,199 --> 00:05:20,960
and uh this code code query looks for

152
00:05:20,960 --> 00:05:22,800
maven palm files that have the use of

153
00:05:22,800 --> 00:05:25,039
http in this sensitive location in the

154
00:05:25,039 --> 00:05:27,759
great in that file in that xml file and

155
00:05:27,759 --> 00:05:28,960
will flag it

156
00:05:28,960 --> 00:05:31,759
and by scanning uh codeql scans hundreds

157
00:05:31,759 --> 00:05:33,520
of thousands of open source projects on

158
00:05:33,520 --> 00:05:34,880
every single commit

159
00:05:34,880 --> 00:05:36,880
and you can run and they build databases

160
00:05:36,880 --> 00:05:40,000
for those for those projects that you as

161
00:05:40,000 --> 00:05:41,440
an open source security researcher can

162
00:05:41,440 --> 00:05:43,440
run queries against and find

163
00:05:43,440 --> 00:05:45,919
vulnerabilities in open source at scale

164
00:05:45,919 --> 00:05:48,000
and so they also will pay you for

165
00:05:48,000 --> 00:05:49,520
queries that you write and contribute

166
00:05:49,520 --> 00:05:50,880
back to github

167
00:05:50,880 --> 00:05:52,639
for the github for as part of the github

168
00:05:52,639 --> 00:05:55,120
security lab binding program and so for

169
00:05:55,120 --> 00:05:57,280
this simple query github bountied me at

170
00:05:57,280 --> 00:05:59,280
2 300 for this

171
00:05:59,280 --> 00:06:01,919
um and using the list of projects that

172
00:06:01,919 --> 00:06:04,080
were vulnerable from this query that i

173
00:06:04,080 --> 00:06:04,960
wrote

174
00:06:04,960 --> 00:06:06,960
i started generating pull requests and

175
00:06:06,960 --> 00:06:08,960
so the first bot the first thing that i

176
00:06:08,960 --> 00:06:10,720
ever the first

177
00:06:10,720 --> 00:06:12,319
pull request generation generator that i

178
00:06:12,319 --> 00:06:14,800
ever wrote was python based

179
00:06:14,800 --> 00:06:16,560
it used a wrapper over

180
00:06:16,560 --> 00:06:19,600
github's hub cli added one nasty regular

181
00:06:19,600 --> 00:06:21,199
expression and there was a lot of logic

182
00:06:21,199 --> 00:06:22,639
about bouncing off of github's rate

183
00:06:22,639 --> 00:06:24,160
limiting um

184
00:06:24,160 --> 00:06:27,120
and this was version one um it probably

185
00:06:27,120 --> 00:06:29,520
looks pretty washed out now but like um

186
00:06:29,520 --> 00:06:31,600
uh this was the first pull request

187
00:06:31,600 --> 00:06:33,440
generator uh it's the it's a there's an

188
00:06:33,440 --> 00:06:35,280
underlying engine but like this was the

189
00:06:35,280 --> 00:06:36,479
logic for

190
00:06:36,479 --> 00:06:38,639
generating pull requests to fix the

191
00:06:38,639 --> 00:06:40,400
security vulnerability and this is the

192
00:06:40,400 --> 00:06:42,639
secure this is the regular expression

193
00:06:42,639 --> 00:06:44,000
and the reason that we had to use a

194
00:06:44,000 --> 00:06:46,319
regular expression uh i'd use a regular

195
00:06:46,319 --> 00:06:48,160
expression instead of using an xml

196
00:06:48,160 --> 00:06:51,120
parser is because if you parse xml into

197
00:06:51,120 --> 00:06:53,680
an xml parser and then you modify that

198
00:06:53,680 --> 00:06:56,160
xml the xml that comes back out when you

199
00:06:56,160 --> 00:06:58,000
print it back out will be in the format

200
00:06:58,000 --> 00:07:00,560
of the xml parser's output not the

201
00:07:00,560 --> 00:07:03,039
output not in the format that came in

202
00:07:03,039 --> 00:07:05,360
and so if you're trying to modify tons

203
00:07:05,360 --> 00:07:06,720
and tons of different xml files that

204
00:07:06,720 --> 00:07:08,319
have tons of different formatting you're

205
00:07:08,319 --> 00:07:10,080
gonna end up with massive diffs and

206
00:07:10,080 --> 00:07:11,120
they're all gonna end up looking like

207
00:07:11,120 --> 00:07:12,720
the same thing and you're not gonna end

208
00:07:12,720 --> 00:07:13,440
up

209
00:07:13,440 --> 00:07:15,280
looking like the code the maintainer

210
00:07:15,280 --> 00:07:17,280
gave you are started with and they're

211
00:07:17,280 --> 00:07:18,560
not going to be happy they're going to

212
00:07:18,560 --> 00:07:20,400
be like great thank you for fixing this

213
00:07:20,400 --> 00:07:21,919
but it doesn't look like the code i

214
00:07:21,919 --> 00:07:23,440
wrote

215
00:07:23,440 --> 00:07:25,039
and the other problem is this is using a

216
00:07:25,039 --> 00:07:27,440
regular expression and

217
00:07:27,440 --> 00:07:28,560
when you have a problem that uses

218
00:07:28,560 --> 00:07:30,240
regular expressions you're gonna end up

219
00:07:30,240 --> 00:07:32,639
with two problems um because uh yeah

220
00:07:32,639 --> 00:07:34,240
anybody who's working with your regular

221
00:07:34,240 --> 00:07:36,880
expressions understands this um but it

222
00:07:36,880 --> 00:07:39,599
worked um

223
00:07:39,599 --> 00:07:40,560
this is

224
00:07:40,560 --> 00:07:43,440
my github contribution feed for pull

225
00:07:43,440 --> 00:07:46,160
requests um when i generated this and

226
00:07:46,160 --> 00:07:47,680
this is an example of the diff that was

227
00:07:47,680 --> 00:07:49,759
generated right you can see that the all

228
00:07:49,759 --> 00:07:51,440
the places where http is being used in

229
00:07:51,440 --> 00:07:53,759
this sensitive location was fixed

230
00:07:53,759 --> 00:07:56,199
and uh i generated

231
00:07:56,199 --> 00:07:59,919
1596 pull requests with this uh

232
00:07:59,919 --> 00:08:02,879
this python bot that i wrote and as of

233
00:08:02,879 --> 00:08:06,319
2020 to 2022 today um we've had about a

234
00:08:06,319 --> 00:08:09,280
40 merge rate of those 1596 pull

235
00:08:09,280 --> 00:08:10,400
requests

236
00:08:10,400 --> 00:08:13,280
and for this uh github awarded me a four

237
00:08:13,280 --> 00:08:14,800
thousand dollar bounty under the github

238
00:08:14,800 --> 00:08:17,680
security lab bug money program for uh

239
00:08:17,680 --> 00:08:18,960
not just that writing the query that

240
00:08:18,960 --> 00:08:20,400
found the vulnerability so this is in

241
00:08:20,400 --> 00:08:22,240
addition to the 2 300 for writing the

242
00:08:22,240 --> 00:08:24,240
query this is for actually using that

243
00:08:24,240 --> 00:08:26,000
query to try to fix the vulnerability at

244
00:08:26,000 --> 00:08:27,360
scale

245
00:08:27,360 --> 00:08:29,120
and i got hooked on this idea of bulk

246
00:08:29,120 --> 00:08:30,879
pull request generation as an idea that

247
00:08:30,879 --> 00:08:32,640
we could use to fix vulnerabilities at

248
00:08:32,640 --> 00:08:35,679
scale across the open source ecosystem

249
00:08:35,679 --> 00:08:37,360
this is my github contribution graph for

250
00:08:37,360 --> 00:08:38,958
2020

251
00:08:38,958 --> 00:08:41,200
you can see the two peaks i actually did

252
00:08:41,200 --> 00:08:44,399
two different campaigns uh in 2020 um

253
00:08:44,399 --> 00:08:46,720
and you know this this tells a

254
00:08:46,720 --> 00:08:49,279
complicated story uh

255
00:08:49,279 --> 00:08:50,240
so

256
00:08:50,240 --> 00:08:52,320
i have a problem

257
00:08:52,320 --> 00:08:53,279
um

258
00:08:53,279 --> 00:08:54,720
my problem

259
00:08:54,720 --> 00:08:58,080
uh i've adhd um that's not my problem um

260
00:08:58,080 --> 00:09:01,200
but my problem is that uh i love chasing

261
00:09:01,200 --> 00:09:04,160
squirrels and vulnerability disclosures

262
00:09:04,160 --> 00:09:06,560
are perfect places like you go read a

263
00:09:06,560 --> 00:09:08,240
vulnerability disclosure and you're like

264
00:09:08,240 --> 00:09:10,080
i wonder where else that is in open

265
00:09:10,080 --> 00:09:11,760
source like how many other places can i

266
00:09:11,760 --> 00:09:13,440
find that vulnerability

267
00:09:13,440 --> 00:09:15,360
and the problem for me is that if i use

268
00:09:15,360 --> 00:09:17,760
codeql or if i use code github code

269
00:09:17,760 --> 00:09:18,880
search

270
00:09:18,880 --> 00:09:20,160
i will find too many security

271
00:09:20,160 --> 00:09:21,519
vulnerabilities

272
00:09:21,519 --> 00:09:22,399
and

273
00:09:22,399 --> 00:09:25,920
for example this is um codeql results

274
00:09:25,920 --> 00:09:28,399
for zip slip right i can page through

275
00:09:28,399 --> 00:09:31,279
pages and pages and pages of results for

276
00:09:31,279 --> 00:09:32,720
zip lip vulnerabilities across open

277
00:09:32,720 --> 00:09:33,680
source

278
00:09:33,680 --> 00:09:35,920
so i'm finding too many vulnerabilities

279
00:09:35,920 --> 00:09:37,040
and so

280
00:09:37,040 --> 00:09:39,279
i need a way to fix this problem i can't

281
00:09:39,279 --> 00:09:40,800
just report to all these different

282
00:09:40,800 --> 00:09:43,519
projects i need a way to find to scale

283
00:09:43,519 --> 00:09:45,040
my knowledge of security vulnerabilities

284
00:09:45,040 --> 00:09:47,519
to fixing these vulnerabilities in in a

285
00:09:47,519 --> 00:09:49,200
more productive way and so i need

286
00:09:49,200 --> 00:09:50,399
automation

287
00:09:50,399 --> 00:09:51,600
and so at this point i'm going to pass

288
00:09:51,600 --> 00:09:54,800
it off to patrick to discuss um open

289
00:09:54,800 --> 00:09:56,480
rewrite

290
00:09:56,480 --> 00:09:58,720
thanks jonathan

291
00:09:58,720 --> 00:10:00,640
yeah so that is a challenge i mean

292
00:10:00,640 --> 00:10:02,399
jonathan really expressed a couple of

293
00:10:02,399 --> 00:10:04,480
challenges that he faced right like hey

294
00:10:04,480 --> 00:10:06,160
i want to use this regular expression

295
00:10:06,160 --> 00:10:08,720
and of course that's a problem or i'm

296
00:10:08,720 --> 00:10:11,200
going to use an xml parser and it's

297
00:10:11,200 --> 00:10:13,279
going to come back goblin goop and

298
00:10:13,279 --> 00:10:15,519
not be a viable pull request so and then

299
00:10:15,519 --> 00:10:17,680
there's scale how do we detect all these

300
00:10:17,680 --> 00:10:19,839
things

301
00:10:24,440 --> 00:10:27,739
[Music]

302
00:10:30,160 --> 00:10:31,360
all right

303
00:10:31,360 --> 00:10:32,800
all right so he needs automated

304
00:10:32,800 --> 00:10:35,279
transformations at scale

305
00:10:35,279 --> 00:10:36,720
and this is where this is where open

306
00:10:36,720 --> 00:10:39,360
rewrite comes in um

307
00:10:39,360 --> 00:10:41,680
you know somehow as software engineers

308
00:10:41,680 --> 00:10:43,519
we're professional automators we we

309
00:10:43,519 --> 00:10:44,720
automate

310
00:10:44,720 --> 00:10:46,320
anything that we can possibly automate

311
00:10:46,320 --> 00:10:48,480
it's just in our blood it's what we do

312
00:10:48,480 --> 00:10:51,760
but for some reason in 2022

313
00:10:51,760 --> 00:10:54,000
most of us are still slogging through

314
00:10:54,000 --> 00:10:56,079
the tedious task of updating that

315
00:10:56,079 --> 00:10:59,040
dependency finding the breaking change

316
00:10:59,040 --> 00:11:01,600
uh you know a framework upgrade whatever

317
00:11:01,600 --> 00:11:03,360
it may be it's a tedious task and we

318
00:11:03,360 --> 00:11:04,959
like burn our fingers on the keyboard to

319
00:11:04,959 --> 00:11:06,880
do it well finally

320
00:11:06,880 --> 00:11:08,560
finally we have an opportunity to do

321
00:11:08,560 --> 00:11:11,600
something different finally it is 2022

322
00:11:11,600 --> 00:11:14,000
and now as software engineers we can

323
00:11:14,000 --> 00:11:16,480
start automating our own tedious tasks

324
00:11:16,480 --> 00:11:17,200
and

325
00:11:17,200 --> 00:11:18,720
this is one of those projects when i

326
00:11:18,720 --> 00:11:20,560
learned about it for the first time i

327
00:11:20,560 --> 00:11:22,640
realized like this is something new this

328
00:11:22,640 --> 00:11:24,480
is this is game changing right we've

329
00:11:24,480 --> 00:11:27,120
been writing daos and business logic for

330
00:11:27,120 --> 00:11:29,519
who knows how many years but now

331
00:11:29,519 --> 00:11:31,040
now you get to write

332
00:11:31,040 --> 00:11:33,600
code for your own code the the model

333
00:11:33,600 --> 00:11:35,760
that you're working with is your code

334
00:11:35,760 --> 00:11:36,959
it's it's

335
00:11:36,959 --> 00:11:39,600
it's amazing and it's incredible

336
00:11:39,600 --> 00:11:41,760
so what what makes it amazing what makes

337
00:11:41,760 --> 00:11:45,680
it possible and and what really is it so

338
00:11:45,680 --> 00:11:48,079
there's a need to transform code and it

339
00:11:48,079 --> 00:11:51,279
was discovered that hey the compiler

340
00:11:51,279 --> 00:11:53,279
represents source code as an abstract

341
00:11:53,279 --> 00:11:56,000
syntax tree it's like compiler's

342
00:11:56,000 --> 00:11:58,240
representation of source code it's bare

343
00:11:58,240 --> 00:12:00,880
minimum but if you look at that tree you

344
00:12:00,880 --> 00:12:02,079
can kind of

345
00:12:02,079 --> 00:12:04,079
start to formulate ideas on like hey i

346
00:12:04,079 --> 00:12:06,639
could i could transform that tree

347
00:12:06,639 --> 00:12:08,639
i could write it back to a source file

348
00:12:08,639 --> 00:12:11,200
and i could i could make a diff i could

349
00:12:11,200 --> 00:12:14,000
make some change well

350
00:12:14,000 --> 00:12:16,000
that's a nice concept but

351
00:12:16,000 --> 00:12:19,120
again the compiler's ast is bare minimum

352
00:12:19,120 --> 00:12:20,639
there's no formatting the compiler

353
00:12:20,639 --> 00:12:22,800
doesn't compare but care about comments

354
00:12:22,800 --> 00:12:24,399
or spaces or tabs

355
00:12:24,399 --> 00:12:26,399
if you modify that and write it back to

356
00:12:26,399 --> 00:12:28,480
a file you're going to get

357
00:12:28,480 --> 00:12:30,320
not a pull request

358
00:12:30,320 --> 00:12:32,399
so one of the first challenges for open

359
00:12:32,399 --> 00:12:35,040
rewrite was to make this a fully format

360
00:12:35,040 --> 00:12:37,440
preserving abstract syntax tree so now

361
00:12:37,440 --> 00:12:39,200
we have an abstract syntax tree that

362
00:12:39,200 --> 00:12:41,200
preserves that precious white space and

363
00:12:41,200 --> 00:12:43,600
the comments and all that contextual

364
00:12:43,600 --> 00:12:45,040
information that's so valuable to

365
00:12:45,040 --> 00:12:47,440
developers and you can write that tree

366
00:12:47,440 --> 00:12:49,600
back to a file that's identical to its

367
00:12:49,600 --> 00:12:50,560
origin

368
00:12:50,560 --> 00:12:53,760
so that's a huge unlock

369
00:12:53,760 --> 00:12:55,600
if you're able to do that we're also

370
00:12:55,600 --> 00:12:58,560
able to auto detect the style so we need

371
00:12:58,560 --> 00:13:00,959
to write source we need to transform

372
00:13:00,959 --> 00:13:03,120
code and write it back according to the

373
00:13:03,120 --> 00:13:05,760
style of that particular project so open

374
00:13:05,760 --> 00:13:07,360
re-reg will detect like hey this is

375
00:13:07,360 --> 00:13:09,600
using spaces this is using tabs this

376
00:13:09,600 --> 00:13:12,240
maybe has two spaces in a tab uh you

377
00:13:12,240 --> 00:13:14,160
know the the nuance is like braces on a

378
00:13:14,160 --> 00:13:16,959
new line so all that is done for you by

379
00:13:16,959 --> 00:13:20,119
the framework

380
00:13:20,240 --> 00:13:22,480
but there's another challenge so we we

381
00:13:22,480 --> 00:13:25,360
got past the the fully uh you know the

382
00:13:25,360 --> 00:13:27,040
format preserving

383
00:13:27,040 --> 00:13:27,920
but

384
00:13:27,920 --> 00:13:30,079
again a compiler's ast is single level

385
00:13:30,079 --> 00:13:32,399
that the type information is not it's

386
00:13:32,399 --> 00:13:35,600
not fully typed so you you look at that

387
00:13:35,600 --> 00:13:39,360
log.info and is it log4j is it slf or j

388
00:13:39,360 --> 00:13:42,000
is it something custom you need you need

389
00:13:42,000 --> 00:13:44,240
the full depth of type information on

390
00:13:44,240 --> 00:13:45,920
that tree

391
00:13:45,920 --> 00:13:47,680
another problem that was solved by the

392
00:13:47,680 --> 00:13:49,120
open rewrite team

393
00:13:49,120 --> 00:13:51,519
and with that what you end up with is we

394
00:13:51,519 --> 00:13:54,240
have a fully type attributed format

395
00:13:54,240 --> 00:13:56,720
preserving abstract syntax tree it's

396
00:13:56,720 --> 00:13:59,360
syntactically and semantically aware

397
00:13:59,360 --> 00:14:01,120
and if you compare that to the compilers

398
00:14:01,120 --> 00:14:03,040
tree you can see like that's dense

399
00:14:03,040 --> 00:14:05,199
there's a lot of information there's a

400
00:14:05,199 --> 00:14:08,079
lot right there that you can use to make

401
00:14:08,079 --> 00:14:09,199
accurate

402
00:14:09,199 --> 00:14:12,320
transformations at scale that

403
00:14:12,320 --> 00:14:15,279
match the format of their source

404
00:14:15,279 --> 00:14:17,120
well

405
00:14:17,120 --> 00:14:20,000
even a simple simple tree

406
00:14:20,000 --> 00:14:22,639
is a complex ast right just a simple bit

407
00:14:22,639 --> 00:14:25,600
of code is a complex axt if jonathan is

408
00:14:25,600 --> 00:14:27,839
going to do this at scale we have to

409
00:14:27,839 --> 00:14:30,639
provide him with the tools to be able to

410
00:14:30,639 --> 00:14:33,600
get beyond the tedium

411
00:14:33,600 --> 00:14:36,560
one of the biggest challenges like so

412
00:14:36,560 --> 00:14:39,120
is is take take this little conditional

413
00:14:39,120 --> 00:14:40,880
statement here jonathan is going to

414
00:14:40,880 --> 00:14:42,800
share with you a recipe a zip slip

415
00:14:42,800 --> 00:14:45,440
recipe in a little bit and he needs to

416
00:14:45,440 --> 00:14:47,519
insert this conditional statement into a

417
00:14:47,519 --> 00:14:50,160
block of code

418
00:14:50,240 --> 00:14:52,079
to do that and to

419
00:14:52,079 --> 00:14:55,120
to handle the formatting and everything

420
00:14:55,120 --> 00:14:56,399
else for all the different projects

421
00:14:56,399 --> 00:14:57,839
would be nearly impossible so what we

422
00:14:57,839 --> 00:14:59,920
have is we have a templating engine the

423
00:14:59,920 --> 00:15:02,240
templating engine allows jonathan to

424
00:15:02,240 --> 00:15:04,399
build a tree

425
00:15:04,399 --> 00:15:06,800
out of a out of code so he can write

426
00:15:06,800 --> 00:15:09,040
code in in java and build an abstract

427
00:15:09,040 --> 00:15:11,120
syntax tree from it and he can do it in

428
00:15:11,120 --> 00:15:12,480
two statements

429
00:15:12,480 --> 00:15:14,639
so here here's an example of building up

430
00:15:14,639 --> 00:15:16,800
a java template you can see that there's

431
00:15:16,800 --> 00:15:18,560
the conditional statement it's got some

432
00:15:18,560 --> 00:15:21,920
handy features like uh

433
00:15:22,720 --> 00:15:25,519
parameter substitution and etc you'll

434
00:15:25,519 --> 00:15:26,639
notice that there's not a lot of

435
00:15:26,639 --> 00:15:28,000
formatting

436
00:15:28,000 --> 00:15:29,360
and this is where he's going to apply it

437
00:15:29,360 --> 00:15:31,120
to the tree it's got a coordinate system

438
00:15:31,120 --> 00:15:33,440
so you can say hey take this bit of code

439
00:15:33,440 --> 00:15:35,600
substitute these parameters and place it

440
00:15:35,600 --> 00:15:37,440
in this spot

441
00:15:37,440 --> 00:15:38,800
in the end

442
00:15:38,800 --> 00:15:40,639
he can go through thousands of

443
00:15:40,639 --> 00:15:43,440
repositories find a vulnerability and

444
00:15:43,440 --> 00:15:45,360
insert that conditional statement

445
00:15:45,360 --> 00:15:47,440
exactly where it belongs with the exact

446
00:15:47,440 --> 00:15:49,839
correct formatting

447
00:15:49,839 --> 00:15:51,279
and so with that i'll hand it back to

448
00:15:51,279 --> 00:15:52,720
jonathan so he can share with you some

449
00:15:52,720 --> 00:15:56,000
of the more work that he's done on it

450
00:15:56,480 --> 00:15:59,199
thank you patrick

451
00:16:02,720 --> 00:16:03,680
so

452
00:16:03,680 --> 00:16:06,079
with open rewrite

453
00:16:06,079 --> 00:16:08,000
with the with what ownvocal rewrite

454
00:16:08,000 --> 00:16:09,759
provides what other vulnerabilities can

455
00:16:09,759 --> 00:16:10,720
we fix

456
00:16:10,720 --> 00:16:13,839
um and what what's possible now so i'm

457
00:16:13,839 --> 00:16:14,800
going to talk to you about three

458
00:16:14,800 --> 00:16:15,839
different security security

459
00:16:15,839 --> 00:16:18,399
vulnerabilities and uh talk through open

460
00:16:18,399 --> 00:16:20,839
rewrites of application to fixing those

461
00:16:20,839 --> 00:16:22,240
vulnerabilities so the first

462
00:16:22,240 --> 00:16:24,320
vulnerability we're going to tackle is

463
00:16:24,320 --> 00:16:26,800
temporary directory hijacking

464
00:16:26,800 --> 00:16:29,040
so temporary directory hijacking the

465
00:16:29,040 --> 00:16:30,880
basis of temp directory hijacking is

466
00:16:30,880 --> 00:16:33,440
that on unix like systems the system

467
00:16:33,440 --> 00:16:35,040
temp directory is shared between all

468
00:16:35,040 --> 00:16:36,800
users this is not applicable to windows

469
00:16:36,800 --> 00:16:38,639
and mac os but on most other units like

470
00:16:38,639 --> 00:16:40,320
linux operating systems

471
00:16:40,320 --> 00:16:41,839
the temporary directory is shared shared

472
00:16:41,839 --> 00:16:43,680
between all users

473
00:16:43,680 --> 00:16:46,000
and this is the vulnerability

474
00:16:46,000 --> 00:16:48,800
this is the way that you will find a lot

475
00:16:48,800 --> 00:16:50,639
of java code creates a temporary

476
00:16:50,639 --> 00:16:52,399
directory in java where they will create

477
00:16:52,399 --> 00:16:54,639
a temporary file call delete and call

478
00:16:54,639 --> 00:16:55,839
minter

479
00:16:55,839 --> 00:16:57,839
and the reason that this pattern exists

480
00:16:57,839 --> 00:17:00,639
is because prior to java 1.7 there did

481
00:17:00,639 --> 00:17:02,639
not exist an api in the java standard

482
00:17:02,639 --> 00:17:05,119
library to create a temporary directory

483
00:17:05,119 --> 00:17:06,959
and so what people did was this pattern

484
00:17:06,959 --> 00:17:08,720
of creating a file deleting it and

485
00:17:08,720 --> 00:17:10,480
creating a temp directory and this

486
00:17:10,480 --> 00:17:12,880
creates a randomly named pseudorandom or

487
00:17:12,880 --> 00:17:15,119
using a pr uh

488
00:17:15,119 --> 00:17:16,640
secure random number generator generates

489
00:17:16,640 --> 00:17:18,880
a random name for the file

490
00:17:18,880 --> 00:17:20,880
um this also if you were to look up on

491
00:17:20,880 --> 00:17:22,480
stack overflow how do you create a

492
00:17:22,480 --> 00:17:24,400
temporary directory in java this would

493
00:17:24,400 --> 00:17:26,000
have been the solution and unfor

494
00:17:26,000 --> 00:17:27,359
unfortunately you'd end up with this

495
00:17:27,359 --> 00:17:28,799
vulnerability

496
00:17:28,799 --> 00:17:30,960
and so this vulnerability exists

497
00:17:30,960 --> 00:17:33,120
here it's a race condition between the

498
00:17:33,120 --> 00:17:35,280
delete and the make dir and the reason

499
00:17:35,280 --> 00:17:37,760
this vulnerability exists is because

500
00:17:37,760 --> 00:17:38,880
um

501
00:17:38,880 --> 00:17:40,799
an attacker can see the creation of the

502
00:17:40,799 --> 00:17:43,440
file and see that that file gets deleted

503
00:17:43,440 --> 00:17:45,840
and then race the java process to create

504
00:17:45,840 --> 00:17:47,840
the temporary directory before the java

505
00:17:47,840 --> 00:17:49,120
process does

506
00:17:49,120 --> 00:17:50,559
and the reason this is a vulnerability

507
00:17:50,559 --> 00:17:53,360
is because make dir if it fails returns

508
00:17:53,360 --> 00:17:54,480
false

509
00:17:54,480 --> 00:17:56,960
not it does not throw an exception

510
00:17:56,960 --> 00:17:58,720
and so the way to fix this vulnerability

511
00:17:58,720 --> 00:18:01,760
is to throw that logic into an if block

512
00:18:01,760 --> 00:18:03,200
that's one valid solution but it's

513
00:18:03,200 --> 00:18:04,960
imperfect and the reason that it's

514
00:18:04,960 --> 00:18:07,280
imperfect is because when you use maker

515
00:18:07,280 --> 00:18:10,320
you're using the default uh you name set

516
00:18:10,320 --> 00:18:12,799
uh the default u name and that will make

517
00:18:12,799 --> 00:18:15,039
the directory with all open permissions

518
00:18:15,039 --> 00:18:17,679
to let it be it will not be editable by

519
00:18:17,679 --> 00:18:18,880
other another user but it will be

520
00:18:18,880 --> 00:18:20,720
visible to all other users so if you're

521
00:18:20,720 --> 00:18:22,240
writing sensitive information into that

522
00:18:22,240 --> 00:18:24,480
directory that directory's contents can

523
00:18:24,480 --> 00:18:26,320
be viewed by all of the local users on

524
00:18:26,320 --> 00:18:27,760
the system

525
00:18:27,760 --> 00:18:29,919
and so this is the fix it's to use the

526
00:18:29,919 --> 00:18:32,240
new java files api which has a create

527
00:18:32,240 --> 00:18:35,600
temp directory call um which is secure

528
00:18:35,600 --> 00:18:37,919
and this vulnerability that i i found a

529
00:18:37,919 --> 00:18:39,679
bunch of different places has i've

530
00:18:39,679 --> 00:18:42,799
received a bunch of cvs for this um and

531
00:18:42,799 --> 00:18:44,400
so i said okay there's more of this than

532
00:18:44,400 --> 00:18:47,200
just these cvs let's try doing both pull

533
00:18:47,200 --> 00:18:48,559
request generation

534
00:18:48,559 --> 00:18:50,480
and so that's what we did

535
00:18:50,480 --> 00:18:53,200
um and so far um

536
00:18:53,200 --> 00:18:55,280
it's actually number is not up to date i

537
00:18:55,280 --> 00:18:57,919
i i did more last night but um i don't

538
00:18:57,919 --> 00:18:59,520
know exactly what it is all it's in a

539
00:18:59,520 --> 00:19:01,280
later slide but at least 64 pull

540
00:19:01,280 --> 00:19:02,320
requests

541
00:19:02,320 --> 00:19:04,000
and this is what the pull request looks

542
00:19:04,000 --> 00:19:05,919
like you can see that there's the

543
00:19:05,919 --> 00:19:08,240
deletion of the delete and the maker and

544
00:19:08,240 --> 00:19:10,559
the replacement with this new api call

545
00:19:10,559 --> 00:19:12,000
but we can do more complicated

546
00:19:12,000 --> 00:19:13,600
transformations than that

547
00:19:13,600 --> 00:19:15,600
let's say that those makers and deletes

548
00:19:15,600 --> 00:19:17,360
were used inside of an if block you can

549
00:19:17,360 --> 00:19:18,880
also remove those because they're no

550
00:19:18,880 --> 00:19:20,880
longer needed and just replace it with

551
00:19:20,880 --> 00:19:22,840
that single

552
00:19:22,840 --> 00:19:25,120
line vulnerability number two that i

553
00:19:25,120 --> 00:19:27,520
want to talk to you about is uh partial

554
00:19:27,520 --> 00:19:29,120
path traversal

555
00:19:29,120 --> 00:19:30,960
so the basis of partial past reversal

556
00:19:30,960 --> 00:19:32,640
let's assume that you have two local

557
00:19:32,640 --> 00:19:34,960
users on a fought on a system user sam

558
00:19:34,960 --> 00:19:37,200
and you want to isolate your logic to

559
00:19:37,200 --> 00:19:39,520
only operate within the directory user

560
00:19:39,520 --> 00:19:40,480
sam

561
00:19:40,480 --> 00:19:42,080
and you have another user on that system

562
00:19:42,080 --> 00:19:45,280
user slash samantha

563
00:19:46,000 --> 00:19:47,760
partial path traversal allows an

564
00:19:47,760 --> 00:19:49,679
attacker to access a sibling directory

565
00:19:49,679 --> 00:19:51,360
with the same prefix

566
00:19:51,360 --> 00:19:53,760
and so taking this example again

567
00:19:53,760 --> 00:19:55,919
um where user sam and we have user

568
00:19:55,919 --> 00:19:58,960
samantha um if you're sandboxing your

569
00:19:58,960 --> 00:20:01,600
logic to user sam it's vulner you can

570
00:20:01,600 --> 00:20:03,200
access user samantha because it's a it's

571
00:20:03,200 --> 00:20:05,679
just it's a prefix of user sam or sorry

572
00:20:05,679 --> 00:20:08,880
user sam is a prefix of user samantha

573
00:20:08,880 --> 00:20:11,120
and this is the vulnerability

574
00:20:11,120 --> 00:20:13,679
the vulnerability uh and the reason this

575
00:20:13,679 --> 00:20:15,600
vulnerability exists

576
00:20:15,600 --> 00:20:17,600
is because

577
00:20:17,600 --> 00:20:20,400
when you call a file

578
00:20:20,400 --> 00:20:22,320
when you call the method get canonical

579
00:20:22,320 --> 00:20:24,640
path on a java file

580
00:20:24,640 --> 00:20:26,640
you'll notice that

581
00:20:26,640 --> 00:20:29,039
the trailing slash gets dropped from the

582
00:20:29,039 --> 00:20:30,400
string

583
00:20:30,400 --> 00:20:31,840
and so

584
00:20:31,840 --> 00:20:34,000
what you're comparing is not when you're

585
00:20:34,000 --> 00:20:36,000
using this in a string comparison you're

586
00:20:36,000 --> 00:20:38,159
comparing paths without the trailing

587
00:20:38,159 --> 00:20:39,440
slash

588
00:20:39,440 --> 00:20:41,520
and so going back to this vulnerability

589
00:20:41,520 --> 00:20:44,320
the example is let's take user sam and

590
00:20:44,320 --> 00:20:45,919
put those into the two locations in code

591
00:20:45,919 --> 00:20:47,520
where they're going to end up

592
00:20:47,520 --> 00:20:49,200
and then we have a user supplied input

593
00:20:49,200 --> 00:20:51,039
that comes in which is dot dot slash

594
00:20:51,039 --> 00:20:53,200
samantha slash baz when that gets

595
00:20:53,200 --> 00:20:54,720
appended together you're going to end up

596
00:20:54,720 --> 00:20:57,600
with user slash samantha slash baz and

597
00:20:57,600 --> 00:20:59,679
this bypasses this

598
00:20:59,679 --> 00:21:01,200
guard

599
00:21:01,200 --> 00:21:02,320
and so what's the fix for this

600
00:21:02,320 --> 00:21:04,159
vulnerability well going back to the

601
00:21:04,159 --> 00:21:05,840
original example

602
00:21:05,840 --> 00:21:07,520
what we're looking for

603
00:21:07,520 --> 00:21:10,720
is um this is this is one valid fix

604
00:21:10,720 --> 00:21:13,440
where you re-add the slash back in

605
00:21:13,440 --> 00:21:14,960
however you're still doing string

606
00:21:14,960 --> 00:21:17,520
comparisons and that's less than ideal

607
00:21:17,520 --> 00:21:19,360
um a better solution

608
00:21:19,360 --> 00:21:21,840
is to um replace

609
00:21:21,840 --> 00:21:25,039
uh the uh get canonical path with get

610
00:21:25,039 --> 00:21:27,360
canonical file turn that into a path

611
00:21:27,360 --> 00:21:29,120
object and do starts with comparisons on

612
00:21:29,120 --> 00:21:30,400
the path object

613
00:21:30,400 --> 00:21:32,880
because java's path object will do this

614
00:21:32,880 --> 00:21:34,960
comparison and do this starts with check

615
00:21:34,960 --> 00:21:36,400
correctly

616
00:21:36,400 --> 00:21:37,919
so how do we find this vulnerability to

617
00:21:37,919 --> 00:21:39,360
actually fix it

618
00:21:39,360 --> 00:21:40,799
well first what we need to look for is

619
00:21:40,799 --> 00:21:43,679
we need to look for starts with calls on

620
00:21:43,679 --> 00:21:46,240
that you need to look for starts with

621
00:21:46,240 --> 00:21:48,400
you need to look for the string method

622
00:21:48,400 --> 00:21:50,240
starts with call and then you need to

623
00:21:50,240 --> 00:21:52,240
look before and after and see the get

624
00:21:52,240 --> 00:21:54,320
canonical paths on either side that

625
00:21:54,320 --> 00:21:56,960
starts with call but you also if you're

626
00:21:56,960 --> 00:21:58,320
going to fix this vulnerability

627
00:21:58,320 --> 00:22:00,159
correctly you also want to make sure

628
00:22:00,159 --> 00:22:02,400
that you're also filtering out cases

629
00:22:02,400 --> 00:22:03,520
where that

630
00:22:03,520 --> 00:22:04,720
slash that

631
00:22:04,720 --> 00:22:06,320
separator character is being appended

632
00:22:06,320 --> 00:22:07,520
correctly

633
00:22:07,520 --> 00:22:10,159
it can't be that easy though can it

634
00:22:10,159 --> 00:22:11,120
well

635
00:22:11,120 --> 00:22:13,600
developers also write code in a lot of

636
00:22:13,600 --> 00:22:15,360
different ways what happens if the

637
00:22:15,360 --> 00:22:17,120
developer doesn't just write this but

638
00:22:17,120 --> 00:22:19,200
they extract one half of this to a

639
00:22:19,200 --> 00:22:20,320
variable

640
00:22:20,320 --> 00:22:23,120
or they extract

641
00:22:23,679 --> 00:22:25,840
or they extract the second argument to a

642
00:22:25,840 --> 00:22:27,840
variable or let's say that the correct

643
00:22:27,840 --> 00:22:30,000
logic is extracted to a variable

644
00:22:30,000 --> 00:22:31,919
how do you identify this vulnerability

645
00:22:31,919 --> 00:22:34,799
still existing even in the context of

646
00:22:34,799 --> 00:22:36,320
of that logic being pulled out into a

647
00:22:36,320 --> 00:22:38,480
separate variable we need this concept

648
00:22:38,480 --> 00:22:40,559
called data flow analysis

649
00:22:40,559 --> 00:22:43,360
so data flow analysis lets us

650
00:22:43,360 --> 00:22:44,320
track

651
00:22:44,320 --> 00:22:47,840
the uh logic from the sources of

652
00:22:47,840 --> 00:22:49,600
variables and how they end up where

653
00:22:49,600 --> 00:22:51,280
they're uh how they end up flowing to

654
00:22:51,280 --> 00:22:54,720
variables and this lets us for example

655
00:22:54,720 --> 00:22:55,520
see

656
00:22:55,520 --> 00:22:57,360
that these variables are getting

657
00:22:57,360 --> 00:22:59,360
assigned to these different locations

658
00:22:59,360 --> 00:23:01,200
and it can be more complicated than this

659
00:23:01,200 --> 00:23:02,640
it can also go through intermediate

660
00:23:02,640 --> 00:23:04,159
variables

661
00:23:04,159 --> 00:23:06,240
so data flow allows us to uncover hard

662
00:23:06,240 --> 00:23:07,919
defined vulnerabilities and prevents

663
00:23:07,919 --> 00:23:09,760
false positives

664
00:23:09,760 --> 00:23:10,640
and

665
00:23:10,640 --> 00:23:13,840
um the data flow analysis api is very is

666
00:23:13,840 --> 00:23:15,440
modeled after coqls so if you're

667
00:23:15,440 --> 00:23:17,200
familiar with codeql or you learned open

668
00:23:17,200 --> 00:23:19,200
rewrite you can translate that knowledge

669
00:23:19,200 --> 00:23:20,400
back and forth between these two

670
00:23:20,400 --> 00:23:22,559
languages and these two frameworks to

671
00:23:22,559 --> 00:23:24,159
find these vulnerabilities and also fix

672
00:23:24,159 --> 00:23:25,600
them

673
00:23:25,600 --> 00:23:27,440
and putting it all together you can see

674
00:23:27,440 --> 00:23:29,120
in this example

675
00:23:29,120 --> 00:23:30,720
where the path

676
00:23:30,720 --> 00:23:32,559
was removed or this path that was

677
00:23:32,559 --> 00:23:34,720
vulnerable gets replaced in this place

678
00:23:34,720 --> 00:23:36,240
and so this is an example of the actual

679
00:23:36,240 --> 00:23:37,919
diff that was generated for partial path

680
00:23:37,919 --> 00:23:39,760
reversal

681
00:23:39,760 --> 00:23:41,840
um i have a brief aside story because

682
00:23:41,840 --> 00:23:44,080
it's just was just too funny not to tell

683
00:23:44,080 --> 00:23:45,600
um there's a case study of this

684
00:23:45,600 --> 00:23:49,039
vulnerability cve uh

685
00:23:49,039 --> 00:23:50,880
five 2022-31159 uh the vulnerability

686
00:23:50,880 --> 00:23:54,720
existed in the uh aws java sdk

687
00:23:54,720 --> 00:23:57,039
um and it was partial past reversal they

688
00:23:57,039 --> 00:23:58,480
were created this guard which was

689
00:23:58,480 --> 00:24:00,080
checking to see if

690
00:24:00,080 --> 00:24:02,400
while downloading the contents of an aws

691
00:24:02,400 --> 00:24:05,760
s3 bucket if the s3 bucket key

692
00:24:05,760 --> 00:24:06,799
um

693
00:24:06,799 --> 00:24:07,760
uh

694
00:24:07,760 --> 00:24:09,840
was was traversing outside of the

695
00:24:09,840 --> 00:24:11,120
destination directory while you were

696
00:24:11,120 --> 00:24:12,400
downloading the entire contents of the

697
00:24:12,400 --> 00:24:13,760
s3 bucket

698
00:24:13,760 --> 00:24:15,520
and you can see that this this partial

699
00:24:15,520 --> 00:24:17,440
path reversal vulnerability was being

700
00:24:17,440 --> 00:24:20,640
used as a guard against path traversal

701
00:24:20,640 --> 00:24:23,120
in this leaves root logic

702
00:24:23,120 --> 00:24:25,520
and uh so this got a vulnerability cv

703
00:24:25,520 --> 00:24:27,360
assigned to it everything went well fine

704
00:24:27,360 --> 00:24:28,559
on that

705
00:24:28,559 --> 00:24:29,919
but there was a little bit of drama in

706
00:24:29,919 --> 00:24:31,440
another way

707
00:24:31,440 --> 00:24:33,520
i had an email with the aws security

708
00:24:33,520 --> 00:24:36,000
team uh where they sent me this email

709
00:24:36,000 --> 00:24:37,840
and they said we'd like to award you a

710
00:24:37,840 --> 00:24:39,760
bug bounty uh however you need to sign

711
00:24:39,760 --> 00:24:41,760
an nda for this for the for us to award

712
00:24:41,760 --> 00:24:43,440
you this amount and i said i don't

713
00:24:43,440 --> 00:24:45,200
normally agree to ndas can i read it

714
00:24:45,200 --> 00:24:47,279
first potentially before agreeing

715
00:24:47,279 --> 00:24:49,679
and aws came back to me and said we're

716
00:24:49,679 --> 00:24:51,440
unable to share the bug bounty program

717
00:24:51,440 --> 00:24:53,360
nda because it and other legal other

718
00:24:53,360 --> 00:24:54,720
contract documents are considered

719
00:24:54,720 --> 00:24:57,919
sensitive by the legal team

720
00:24:59,200 --> 00:25:01,200
it was it was like

721
00:25:01,200 --> 00:25:03,360
amazon used uh legalese and it hurt

722
00:25:03,360 --> 00:25:06,879
itself in its confusion like

723
00:25:07,679 --> 00:25:10,320
so uh story that just could not be not

724
00:25:10,320 --> 00:25:12,400
told as a part of this um all right so

725
00:25:12,400 --> 00:25:14,400
the third vulnerability is zip slip

726
00:25:14,400 --> 00:25:16,400
um so people who have been hackers for a

727
00:25:16,400 --> 00:25:18,400
very very long time are probably know

728
00:25:18,400 --> 00:25:20,960
what this is but to summarize zip slip

729
00:25:20,960 --> 00:25:23,200
is a path traversal vulnerability that

730
00:25:23,200 --> 00:25:26,480
exists while unpacking zip file entries

731
00:25:26,480 --> 00:25:28,640
because zips are just you know a name of

732
00:25:28,640 --> 00:25:30,320
where you want the desk the pad the file

733
00:25:30,320 --> 00:25:32,159
to end up to the contents of the zip

734
00:25:32,159 --> 00:25:33,120
file

735
00:25:33,120 --> 00:25:34,480
um

736
00:25:34,480 --> 00:25:36,880
and so this this vulnerability can exist

737
00:25:36,880 --> 00:25:38,960
in java um because it's very easy to

738
00:25:38,960 --> 00:25:41,039
unpack zip files um

739
00:25:41,039 --> 00:25:43,520
and so this is the logic to un that

740
00:25:43,520 --> 00:25:45,120
you'll see in a lot of places to unpack

741
00:25:45,120 --> 00:25:47,520
zip files the snick team did a bunch of

742
00:25:47,520 --> 00:25:51,039
research back in 2018 to eliminate a lot

743
00:25:51,039 --> 00:25:52,240
of this vulnerability from the open

744
00:25:52,240 --> 00:25:54,720
source ecosystem they reported it to a

745
00:25:54,720 --> 00:25:56,080
bunch of different open source projects

746
00:25:56,080 --> 00:25:57,919
not just in java but other languages as

747
00:25:57,919 --> 00:25:58,720
well

748
00:25:58,720 --> 00:26:01,760
um and uh their fix was you know for the

749
00:26:01,760 --> 00:26:03,120
most part correct but there were certain

750
00:26:03,120 --> 00:26:04,159
cases that actually were still

751
00:26:04,159 --> 00:26:06,080
vulnerable to partial path reversal from

752
00:26:06,080 --> 00:26:09,440
zip slip um but you know that that's

753
00:26:09,440 --> 00:26:12,640
neither here nor there um the uh so this

754
00:26:12,640 --> 00:26:15,120
is the subset of the logic that that

755
00:26:15,120 --> 00:26:16,880
leaves you vulnerable

756
00:26:16,880 --> 00:26:19,760
um it's that the entry name

757
00:26:19,760 --> 00:26:21,600
um flows to

758
00:26:21,600 --> 00:26:24,240
this file output stream when you're and

759
00:26:24,240 --> 00:26:25,600
you're copying the contents of this file

760
00:26:25,600 --> 00:26:27,520
output stream so you're using

761
00:26:27,520 --> 00:26:29,679
potentially malicious zip files to

762
00:26:29,679 --> 00:26:32,000
download the con or to you're you're

763
00:26:32,000 --> 00:26:34,159
unpacking potentially malicious zip

764
00:26:34,159 --> 00:26:36,640
files into uh an

765
00:26:36,640 --> 00:26:37,919
outside of the destination directory

766
00:26:37,919 --> 00:26:39,520
potentially if there's a pat if the

767
00:26:39,520 --> 00:26:41,039
attacker has supplied a pass reversal

768
00:26:41,039 --> 00:26:43,279
payload in the entry name

769
00:26:43,279 --> 00:26:45,279
so zip slip is complicated

770
00:26:45,279 --> 00:26:47,200
the zip link is complicated because in

771
00:26:47,200 --> 00:26:48,559
order to fix it

772
00:26:48,559 --> 00:26:51,760
you need to add this guard

773
00:26:51,760 --> 00:26:53,520
that protects against this vulnerability

774
00:26:53,520 --> 00:26:54,559
existing

775
00:26:54,559 --> 00:26:56,480
um you're you're checking to make sure

776
00:26:56,480 --> 00:26:58,000
that the uh

777
00:26:58,000 --> 00:27:00,000
that the the file is within the

778
00:27:00,000 --> 00:27:01,919
destination directory

779
00:27:01,919 --> 00:27:03,279
but the further problem with this is

780
00:27:03,279 --> 00:27:05,360
that even though that's a valid fix

781
00:27:05,360 --> 00:27:08,080
there are other valid fixes as well

782
00:27:08,080 --> 00:27:09,919
this so this is one valid fix for it but

783
00:27:09,919 --> 00:27:11,919
this is another one where you just put

784
00:27:11,919 --> 00:27:14,400
the logic inside of an if check

785
00:27:14,400 --> 00:27:16,960
and so in order to determine if you are

786
00:27:16,960 --> 00:27:19,200
not going to be able to reach this logic

787
00:27:19,200 --> 00:27:21,200
you need a new concept and it's called

788
00:27:21,200 --> 00:27:23,120
control flow analysis

789
00:27:23,120 --> 00:27:25,120
and so control flow analysis lets us

790
00:27:25,120 --> 00:27:27,200
determine that

791
00:27:27,200 --> 00:27:29,200
is there a guard in place that protects

792
00:27:29,200 --> 00:27:31,039
against this vulnerability or not right

793
00:27:31,039 --> 00:27:32,480
so the version on the left does need to

794
00:27:32,480 --> 00:27:33,679
get fixed but the version on the right

795
00:27:33,679 --> 00:27:34,880
does not because there's a valid

796
00:27:34,880 --> 00:27:37,120
protection against this vulnerability

797
00:27:37,120 --> 00:27:39,520
and control flow analysis uh did not

798
00:27:39,520 --> 00:27:41,120
exist in open rewrite prior to the work

799
00:27:41,120 --> 00:27:44,240
that we were doing um but it it lets

800
00:27:44,240 --> 00:27:46,480
when we added it it enabled us

801
00:27:46,480 --> 00:27:49,360
to take um this you know take up take a

802
00:27:49,360 --> 00:27:51,679
chunk of java and produce a graph

803
00:27:51,679 --> 00:27:53,039
which is

804
00:27:53,039 --> 00:27:56,960
at every jump what uh what is you know

805
00:27:56,960 --> 00:27:59,919
what what chunks of logic are reachable

806
00:27:59,919 --> 00:28:02,640
and so that lets us for example for zip

807
00:28:02,640 --> 00:28:05,279
slip we can build a control flow graph

808
00:28:05,279 --> 00:28:08,080
or zip slip and traverse that graph and

809
00:28:08,080 --> 00:28:10,799
determine that if you reach the starts

810
00:28:10,799 --> 00:28:14,159
with call and that is false then there

811
00:28:14,159 --> 00:28:15,440
will be an exception thrown and that

812
00:28:15,440 --> 00:28:18,320
that untrusted logic will not be reached

813
00:28:18,320 --> 00:28:20,320
so you'll it's a valid guard against

814
00:28:20,320 --> 00:28:23,279
this against reaching um that potential

815
00:28:23,279 --> 00:28:25,679
vulnerability vulnerable logic

816
00:28:25,679 --> 00:28:27,440
and so when we put this all together

817
00:28:27,440 --> 00:28:28,799
this is the example of the diffs that

818
00:28:28,799 --> 00:28:30,640
you can generate

819
00:28:30,640 --> 00:28:33,200
um and you know here's another example

820
00:28:33,200 --> 00:28:34,559
where you can see we've not only you

821
00:28:34,559 --> 00:28:35,600
know

822
00:28:35,600 --> 00:28:37,360
fixed the code but we've also

823
00:28:37,360 --> 00:28:39,840
cleaned up the surrounding code as well

824
00:28:39,840 --> 00:28:42,159
and so uh pull request generation right

825
00:28:42,159 --> 00:28:43,760
let's go do some pull request generation

826
00:28:43,760 --> 00:28:45,279
if you've got security vulnerabilities

827
00:28:45,279 --> 00:28:47,039
you can get a pull request

828
00:28:47,039 --> 00:28:48,640
um so the problems with pull request

829
00:28:48,640 --> 00:28:50,399
generation one of the things that you'll

830
00:28:50,399 --> 00:28:52,720
run into really quickly is how fast can

831
00:28:52,720 --> 00:28:54,559
you generate pull requests

832
00:28:54,559 --> 00:28:56,880
when you're generating pull requests

833
00:28:56,880 --> 00:29:00,799
um i think i said real fast

834
00:29:02,320 --> 00:29:03,919
there are three different types of steps

835
00:29:03,919 --> 00:29:05,279
that you need to make

836
00:29:05,279 --> 00:29:07,200
there's file io

837
00:29:07,200 --> 00:29:09,279
there are git operations

838
00:29:09,279 --> 00:29:11,600
and there's the github api calls

839
00:29:11,600 --> 00:29:13,279
and file i o is basically free because

840
00:29:13,279 --> 00:29:14,720
it's happening on your local machine you

841
00:29:14,720 --> 00:29:16,880
have git operations on github those are

842
00:29:16,880 --> 00:29:18,480
free they're not rate limited but then

843
00:29:18,480 --> 00:29:20,240
you have github api calls that are rate

844
00:29:20,240 --> 00:29:21,840
limited

845
00:29:21,840 --> 00:29:23,279
so the first step is you check out the

846
00:29:23,279 --> 00:29:25,039
source code and download it

847
00:29:25,039 --> 00:29:27,520
which is a git operation and then you

848
00:29:27,520 --> 00:29:29,360
file i o which is branching applying the

849
00:29:29,360 --> 00:29:31,520
diff and committing the change then you

850
00:29:31,520 --> 00:29:34,240
fork the repository on github which

851
00:29:34,240 --> 00:29:37,760
does actually um

852
00:29:39,120 --> 00:29:41,679
um that so you fork the repository on

853
00:29:41,679 --> 00:29:44,080
github um which is an api call

854
00:29:44,080 --> 00:29:46,720
um and then uh you rename the repository

855
00:29:46,720 --> 00:29:49,760
and github and you push the changes um

856
00:29:49,760 --> 00:29:51,600
again a git operation and then you

857
00:29:51,600 --> 00:29:53,760
create a pull request on github so of

858
00:29:53,760 --> 00:29:56,799
these things there's three api calls

859
00:29:56,799 --> 00:29:58,960
and the three api calls

860
00:29:58,960 --> 00:30:00,399
um

861
00:30:00,399 --> 00:30:03,600
there's a story behind this

862
00:30:04,000 --> 00:30:06,000
there's a story behind this

863
00:30:06,000 --> 00:30:06,880
um

864
00:30:06,880 --> 00:30:10,640
the you have three api calls um that uh

865
00:30:10,640 --> 00:30:12,559
are neat that are rate limited by github

866
00:30:12,559 --> 00:30:15,360
right and so github recommends that for

867
00:30:15,360 --> 00:30:18,480
every um request or for every uh every

868
00:30:18,480 --> 00:30:19,840
between every request you wait at least

869
00:30:19,840 --> 00:30:21,039
one second

870
00:30:21,039 --> 00:30:22,960
um additionally there are other rate

871
00:30:22,960 --> 00:30:25,039
limits that are in place that they want

872
00:30:25,039 --> 00:30:27,679
to prevent you spam users or malicious

873
00:30:27,679 --> 00:30:31,120
users from generating more pull requests

874
00:30:31,120 --> 00:30:32,640
uh they don't want people spamming

875
00:30:32,640 --> 00:30:34,480
maintainers right they their users are

876
00:30:34,480 --> 00:30:35,840
maintainers they so they're trying to

877
00:30:35,840 --> 00:30:38,320
protect their users so if their their

878
00:30:38,320 --> 00:30:40,960
protection of users unfortunately

879
00:30:40,960 --> 00:30:42,399
limits our ability to do this work of

880
00:30:42,399 --> 00:30:45,039
security researchers um so if there's

881
00:30:45,039 --> 00:30:46,640
anybody github in the audience if you

882
00:30:46,640 --> 00:30:48,399
could stop rate limiting your api or at

883
00:30:48,399 --> 00:30:50,080
least not doing as much that'd be

884
00:30:50,080 --> 00:30:51,919
greatly appreciated

885
00:30:51,919 --> 00:30:53,760
so we've made it this far

886
00:30:53,760 --> 00:30:55,279
um we've vulnerabilities have been

887
00:30:55,279 --> 00:30:58,159
detected style's been detected um code

888
00:30:58,159 --> 00:30:59,600
has been fixed and the rate limit's been

889
00:30:59,600 --> 00:31:01,440
bypassed um

890
00:31:01,440 --> 00:31:03,279
how do we do this for all the open

891
00:31:03,279 --> 00:31:05,200
source repositories that we want to fix

892
00:31:05,200 --> 00:31:06,559
and i'm going to pass it back to uh

893
00:31:06,559 --> 00:31:09,440
patrick to discuss modern

894
00:31:09,440 --> 00:31:10,960
down button

895
00:31:10,960 --> 00:31:12,720
well first

896
00:31:12,720 --> 00:31:14,000
let me make sure i've got it right side

897
00:31:14,000 --> 00:31:14,960
up

898
00:31:14,960 --> 00:31:16,640
we'd like to the open rewrite team we

899
00:31:16,640 --> 00:31:18,480
would really like to thank jonathan and

900
00:31:18,480 --> 00:31:21,679
shawn for their work

901
00:31:21,679 --> 00:31:23,440
on behalf of open rewrite i'd really

902
00:31:23,440 --> 00:31:25,519
like to commend jonathan ansham for

903
00:31:25,519 --> 00:31:27,360
their work to add control flow and data

904
00:31:27,360 --> 00:31:29,519
flow to the project

905
00:31:29,519 --> 00:31:31,760
not an easy task these guys worked hard

906
00:31:31,760 --> 00:31:33,039
they put their heads down and they

907
00:31:33,039 --> 00:31:35,519
pulled it off so some context shawn is

908
00:31:35,519 --> 00:31:37,600
my intern who has been working he's in

909
00:31:37,600 --> 00:31:39,519
the back but he's he was essential to

910
00:31:39,519 --> 00:31:41,039
making control flow something that was

911
00:31:41,039 --> 00:31:43,440
possible nice nice job yeah you guys you

912
00:31:43,440 --> 00:31:45,120
guys rocked it

913
00:31:45,120 --> 00:31:47,919
all right so

914
00:31:47,919 --> 00:31:50,159
modern is a company that's supporting

915
00:31:50,159 --> 00:31:51,600
open rewrite

916
00:31:51,600 --> 00:31:54,640
and we we provide a uh a free service

917
00:31:54,640 --> 00:31:56,559
for open source projects

918
00:31:56,559 --> 00:31:59,919
um it allows you to run you know our 800

919
00:31:59,919 --> 00:32:04,080
plus recipes over 7000 plus repositories

920
00:32:04,080 --> 00:32:05,039
um

921
00:32:05,039 --> 00:32:06,720
you could do your transformations at

922
00:32:06,720 --> 00:32:09,440
scale you can you can find usages of

923
00:32:09,440 --> 00:32:11,840
types of method implications all across

924
00:32:11,840 --> 00:32:14,320
either all of all the seven repositories

925
00:32:14,320 --> 00:32:15,760
that we have ingested or whatever you

926
00:32:15,760 --> 00:32:17,519
have in your organization

927
00:32:17,519 --> 00:32:19,279
and it'll also generate an update pull

928
00:32:19,279 --> 00:32:21,279
request for you this is really what's

929
00:32:21,279 --> 00:32:24,080
allowing jonathan to scale

930
00:32:24,080 --> 00:32:26,559
so as i mentioned before

931
00:32:26,559 --> 00:32:28,480
the open rewrite the suite of projects

932
00:32:28,480 --> 00:32:30,240
we've got testing frameworks logging

933
00:32:30,240 --> 00:32:32,320
frameworks rewrite spring

934
00:32:32,320 --> 00:32:34,080
rewrite kubernetes

935
00:32:34,080 --> 00:32:35,760
you name it we've got a whole suite of

936
00:32:35,760 --> 00:32:38,880
projects we have more than 800 recipes

937
00:32:38,880 --> 00:32:40,960
including complete framework migration

938
00:32:40,960 --> 00:32:44,399
so uh you know j in it four to five is a

939
00:32:44,399 --> 00:32:46,880
really tedious uh transformation to make

940
00:32:46,880 --> 00:32:48,559
we have a recipe for that you want to

941
00:32:48,559 --> 00:32:50,240
get from spring boot one to two you need

942
00:32:50,240 --> 00:32:51,440
to do

943
00:32:51,440 --> 00:32:53,679
uh cheating at four to five

944
00:32:53,679 --> 00:32:55,679
we can bundle that all together so the

945
00:32:55,679 --> 00:32:57,919
developer is not having to sit there and

946
00:32:57,919 --> 00:32:59,200
bang their

947
00:32:59,200 --> 00:33:01,279
head on the keyboard and just work their

948
00:33:01,279 --> 00:33:03,760
fingers to the bone with all these

949
00:33:03,760 --> 00:33:06,000
tedious changes

950
00:33:06,000 --> 00:33:09,360
so back to pull request generation

951
00:33:09,360 --> 00:33:11,279
jonathan he's finding vulnerabilities

952
00:33:11,279 --> 00:33:13,360
everywhere he's got a handy-dandy recipe

953
00:33:13,360 --> 00:33:15,279
to fix them and now he needs to get

954
00:33:15,279 --> 00:33:16,720
those out

955
00:33:16,720 --> 00:33:19,919
madarin also provides the ability to

956
00:33:19,919 --> 00:33:22,399
to run that recipe costs all 7 000

957
00:33:22,399 --> 00:33:24,080
repositories that are indexed and

958
00:33:24,080 --> 00:33:25,600
generate pull requests for them you can

959
00:33:25,600 --> 00:33:27,840
see they have a message that's uh

960
00:33:27,840 --> 00:33:30,640
contextual and

961
00:33:30,640 --> 00:33:32,880
and

962
00:33:32,880 --> 00:33:35,279
yeah lots of results

963
00:33:35,279 --> 00:33:36,000
so

964
00:33:36,000 --> 00:33:37,440
i could talk about this or we can kind

965
00:33:37,440 --> 00:33:39,120
of give you a quick little demo of video

966
00:33:39,120 --> 00:33:41,200
here you can see it's it's run the

967
00:33:41,200 --> 00:33:42,320
recipe

968
00:33:42,320 --> 00:33:45,279
it's generated some results it's

969
00:33:45,279 --> 00:33:47,200
jonathan putting together a message he's

970
00:33:47,200 --> 00:33:50,159
put it signing his his pull request and

971
00:33:50,159 --> 00:33:53,279
off it goes it's it's running through

972
00:33:53,279 --> 00:33:56,399
building pull requests at scale so now

973
00:33:56,399 --> 00:33:58,240
as jonathan finds those squirrels

974
00:33:58,240 --> 00:33:59,360
everywhere

975
00:33:59,360 --> 00:34:03,120
he's got he's got the tool to fix him

976
00:34:03,120 --> 00:34:03,919
so

977
00:34:03,919 --> 00:34:06,919
now

978
00:34:07,600 --> 00:34:09,199
so there's more than seven thousand

979
00:34:09,199 --> 00:34:11,520
repositories in the world um how do we

980
00:34:11,520 --> 00:34:13,839
find the other vulnerable projects right

981
00:34:13,839 --> 00:34:15,760
and this circles back around to what we

982
00:34:15,760 --> 00:34:16,639
were talking about at the beginning of

983
00:34:16,639 --> 00:34:18,560
the talk codeql

984
00:34:18,560 --> 00:34:21,599
so codeql uh as i said before it uh

985
00:34:21,599 --> 00:34:23,918
index uh indexes over a hundred thousand

986
00:34:23,918 --> 00:34:26,719
open source projects and at least thirty

987
00:34:26,719 --> 00:34:29,119
five thousand open source java projects

988
00:34:29,119 --> 00:34:32,079
um it's they support python cubase plus

989
00:34:32,079 --> 00:34:35,839
um see python go

990
00:34:35,839 --> 00:34:36,879
uh

991
00:34:36,879 --> 00:34:37,918
and some i think there's some other

992
00:34:37,918 --> 00:34:39,760
languages in there too but um

993
00:34:39,760 --> 00:34:42,159
it lets you write queries to find these

994
00:34:42,159 --> 00:34:43,918
vulnerabilities at scale and so those

995
00:34:43,918 --> 00:34:45,918
queries because there's more than 7000

996
00:34:45,918 --> 00:34:48,639
open source projects out there you can

997
00:34:48,639 --> 00:34:50,560
use codeql to identify the vulnerable

998
00:34:50,560 --> 00:34:52,639
projects and then you need to make open

999
00:34:52,639 --> 00:34:54,879
rewrite aware of them or the modern sas

1000
00:34:54,879 --> 00:34:56,159
aware of them and the way to do that is

1001
00:34:56,159 --> 00:34:57,599
you just generate a poll or you open a

1002
00:34:57,599 --> 00:34:59,839
pull request against this repository and

1003
00:34:59,839 --> 00:35:02,240
add to the csv file and then open

1004
00:35:02,240 --> 00:35:03,599
rewrite will try to go out and build

1005
00:35:03,599 --> 00:35:05,200
that project

1006
00:35:05,200 --> 00:35:06,079
to

1007
00:35:06,079 --> 00:35:07,520
to index and let you generate pull

1008
00:35:07,520 --> 00:35:08,720
requests

1009
00:35:08,720 --> 00:35:10,720
so finally let's go generate some pull

1010
00:35:10,720 --> 00:35:13,279
requests

1011
00:35:13,760 --> 00:35:15,040
this is

1012
00:35:15,040 --> 00:35:17,280
basically all of the the giant pull

1013
00:35:17,280 --> 00:35:19,040
requests that are projects that i've

1014
00:35:19,040 --> 00:35:21,200
i've either been a part of are aware of

1015
00:35:21,200 --> 00:35:22,400
the only one that i actually was not

1016
00:35:22,400 --> 00:35:23,920
directly involved with is the our

1017
00:35:23,920 --> 00:35:27,280
hostname array uh one where github used

1018
00:35:27,280 --> 00:35:29,440
my python bot to generate those pull

1019
00:35:29,440 --> 00:35:31,520
requests to fix uh a

1020
00:35:31,520 --> 00:35:32,720
uh

1021
00:35:32,720 --> 00:35:35,440
array overflow vulnerability um but the

1022
00:35:35,440 --> 00:35:36,960
other ones and these are all pull

1023
00:35:36,960 --> 00:35:39,119
requests that i've generated and for new

1024
00:35:39,119 --> 00:35:41,280
pull requests as of 2020 i've generated

1025
00:35:41,280 --> 00:35:45,760
over 9 5 000 sorry wow 590 pull requests

1026
00:35:45,760 --> 00:35:48,560
um and to my name across my history as

1027
00:35:48,560 --> 00:35:50,400
an open source security researcher i've

1028
00:35:50,400 --> 00:35:53,599
generated over 5200 pull requests

1029
00:35:53,599 --> 00:35:56,000
and uh one of the projects funnily

1030
00:35:56,000 --> 00:35:57,920
enough the three different the three pro

1031
00:35:57,920 --> 00:35:58,640
uh

1032
00:35:58,640 --> 00:36:00,160
the three vulnerabilities discussed in

1033
00:36:00,160 --> 00:36:02,640
this talk um there was one unfortunate

1034
00:36:02,640 --> 00:36:04,800
open source project that received all

1035
00:36:04,800 --> 00:36:07,599
three pull requests um

1036
00:36:07,599 --> 00:36:10,000
uh so yeah and this is my github

1037
00:36:10,000 --> 00:36:12,720
contribution graph for 2022. uh it's not

1038
00:36:12,720 --> 00:36:14,800
done yet but you know you can see the

1039
00:36:14,800 --> 00:36:16,240
the impact of bulk holder across

1040
00:36:16,240 --> 00:36:18,079
generation on that

1041
00:36:18,079 --> 00:36:20,240
and so now i want to talk to you about

1042
00:36:20,240 --> 00:36:22,800
some of the best practices for uh bulk

1043
00:36:22,800 --> 00:36:24,640
polarized generation

1044
00:36:24,640 --> 00:36:26,880
first off messaging

1045
00:36:26,880 --> 00:36:27,760
um

1046
00:36:27,760 --> 00:36:29,520
you're dealing with maintainers you're

1047
00:36:29,520 --> 00:36:31,200
dealing with real people

1048
00:36:31,200 --> 00:36:32,560
um

1049
00:36:32,560 --> 00:36:34,400
there's a saying all software problems

1050
00:36:34,400 --> 00:36:36,640
are people problems in disguise this is

1051
00:36:36,640 --> 00:36:38,880
100 one of those cases right you're

1052
00:36:38,880 --> 00:36:40,960
dealing with actual people maintainers

1053
00:36:40,960 --> 00:36:44,000
of the software um and

1054
00:36:44,000 --> 00:36:45,359
you need to be sensitive about that

1055
00:36:45,359 --> 00:36:47,119
you're not just disclosing a security

1056
00:36:47,119 --> 00:36:48,640
vulnerability you're not just disclosing

1057
00:36:48,640 --> 00:36:50,800
a bug in this you're disclosing a

1058
00:36:50,800 --> 00:36:52,560
security vulnerability and so there's a

1059
00:36:52,560 --> 00:36:54,800
certain amount of ego that gets wrapped

1060
00:36:54,800 --> 00:36:56,960
up in this we're challenging not just

1061
00:36:56,960 --> 00:36:58,560
you've had a bug which maintainers have

1062
00:36:58,560 --> 00:37:00,400
been pretty normalized to but you've

1063
00:37:00,400 --> 00:37:01,839
developed you've had a security

1064
00:37:01,839 --> 00:37:03,440
vulnerability that could put your users

1065
00:37:03,440 --> 00:37:05,599
at risk you're you're hitting them in

1066
00:37:05,599 --> 00:37:06,640
somewhere that's different and they're

1067
00:37:06,640 --> 00:37:08,160
not used to and you need to be careful

1068
00:37:08,160 --> 00:37:09,760
about that

1069
00:37:09,760 --> 00:37:10,560
um

1070
00:37:10,560 --> 00:37:12,880
so lesson that's that's the you know

1071
00:37:12,880 --> 00:37:16,160
lesson zero so lesson one about this um

1072
00:37:16,160 --> 00:37:18,000
sign off on your commits

1073
00:37:18,000 --> 00:37:19,760
um and this is what github sign up this

1074
00:37:19,760 --> 00:37:21,359
is basically uh you add this to your

1075
00:37:21,359 --> 00:37:22,720
commit messages

1076
00:37:22,720 --> 00:37:27,599
um and why well the reason why is uh

1077
00:37:27,599 --> 00:37:29,119
there was a bunch of lawsuits a lotta

1078
00:37:29,119 --> 00:37:32,079
yada yada tldr lawyers

1079
00:37:32,079 --> 00:37:33,920
um

1080
00:37:33,920 --> 00:37:36,079
if you don't your pull requests will be

1081
00:37:36,079 --> 00:37:38,880
rejected by evil dragon bureaucrats uh

1082
00:37:38,880 --> 00:37:39,760
so

1083
00:37:39,760 --> 00:37:42,079
gpgs are sorry uh

1084
00:37:42,079 --> 00:37:44,400
sign off on your commits

1085
00:37:44,400 --> 00:37:46,800
lesson number two be a good commit is in

1086
00:37:46,800 --> 00:37:48,720
gpg sign your commits

1087
00:37:48,720 --> 00:37:51,040
um if you so this is what signing your

1088
00:37:51,040 --> 00:37:52,320
commits looks like it shows up as

1089
00:37:52,320 --> 00:37:55,359
verified um and you won't end up like

1090
00:37:55,359 --> 00:37:57,760
somebody impersonating linus tar torvald

1091
00:37:57,760 --> 00:38:00,640
on github because you know uh so if you

1092
00:38:00,640 --> 00:38:03,200
gpg sign your commits um it'll prevent

1093
00:38:03,200 --> 00:38:05,760
this lesson three um there's a commit

1094
00:38:05,760 --> 00:38:07,760
there's a standard called ccom which is

1095
00:38:07,760 --> 00:38:12,800
a commit format um and if you lay it out

1096
00:38:14,160 --> 00:38:17,040
thank you thank you

1097
00:38:17,040 --> 00:38:19,119
so the story i'll tell it when this is

1098
00:38:19,119 --> 00:38:20,560
over but yes

1099
00:38:20,560 --> 00:38:22,000
there's a story i'll tell this one this

1100
00:38:22,000 --> 00:38:24,320
is over so sec thank you so much i

1101
00:38:24,320 --> 00:38:27,880
appreciate i asked

1102
00:38:32,079 --> 00:38:34,160
we have a tradition where speakers are

1103
00:38:34,160 --> 00:38:35,760
allowed to make an outrageous request

1104
00:38:35,760 --> 00:38:37,440
when they submit their talk yes we

1105
00:38:37,440 --> 00:38:38,800
accept their talk and we like the

1106
00:38:38,800 --> 00:38:39,760
request

1107
00:38:39,760 --> 00:38:41,119
we'll fulfill it

1108
00:38:41,119 --> 00:38:43,440
however we often fulfill it in sort of a

1109
00:38:43,440 --> 00:38:47,680
slightly evil genie sort of way so

1110
00:38:47,680 --> 00:38:49,359
thank you you are quack quack thank you

1111
00:38:49,359 --> 00:38:51,680
i appreciate it yes

1112
00:38:51,680 --> 00:38:53,359
there's a longer story so this is not

1113
00:38:53,359 --> 00:38:55,040
the first duck that i've ever seen i

1114
00:38:55,040 --> 00:38:56,480
spoke i spoke about the zoom

1115
00:38:56,480 --> 00:38:58,560
vulnerability which i found in shmukon

1116
00:38:58,560 --> 00:39:00,400
and for some strange women somebody

1117
00:39:00,400 --> 00:39:02,640
brought a duck up on stage for me

1118
00:39:02,640 --> 00:39:04,880
because i also use the duck in that talk

1119
00:39:04,880 --> 00:39:06,960
so i try to put the duck in every talk

1120
00:39:06,960 --> 00:39:08,480
and so i just said hey if you want to

1121
00:39:08,480 --> 00:39:10,240
bring one that'd be great and lo and

1122
00:39:10,240 --> 00:39:12,480
behold they have

1123
00:39:12,480 --> 00:39:13,599
all right

1124
00:39:13,599 --> 00:39:15,440
taking a step back

1125
00:39:15,440 --> 00:39:17,760
um ccom so it's a commit message

1126
00:39:17,760 --> 00:39:19,440
standard for for putting all the

1127
00:39:19,440 --> 00:39:21,040
information in about a vulnerability

1128
00:39:21,040 --> 00:39:22,800
into the commit message so that it's

1129
00:39:22,800 --> 00:39:25,200
parsable um

1130
00:39:25,200 --> 00:39:26,640
uh yes

1131
00:39:26,640 --> 00:39:29,280
lesson number four um there are risks to

1132
00:39:29,280 --> 00:39:31,200
using your personal github account

1133
00:39:31,200 --> 00:39:32,880
um anybody here who's familiar with

1134
00:39:32,880 --> 00:39:35,760
github uh github's angry unicorn

1135
00:39:35,760 --> 00:39:37,440
this is github's angular unicorn that

1136
00:39:37,440 --> 00:39:41,119
occurs when you hit a 500 error

1137
00:39:41,440 --> 00:39:44,000
this is my github profile for most 2022.

1138
00:39:44,000 --> 00:39:46,320
sorry 2020. um

1139
00:39:46,320 --> 00:39:47,520
uh

1140
00:39:47,520 --> 00:39:48,800
and the only way that i was able to fix

1141
00:39:48,800 --> 00:39:50,400
it was by reaching out to github support

1142
00:39:50,400 --> 00:39:52,320
and i'm also github star talking to them

1143
00:39:52,320 --> 00:39:55,359
directly and and asking uh to help so

1144
00:39:55,359 --> 00:39:57,359
you can break your github account if you

1145
00:39:57,359 --> 00:40:00,560
do this uh fair warning um

1146
00:40:00,560 --> 00:40:02,400
coordinate with github uh there is

1147
00:40:02,400 --> 00:40:03,760
there's a benefit to doing this because

1148
00:40:03,760 --> 00:40:05,760
if you if you use your personal account

1149
00:40:05,760 --> 00:40:07,680
and p and maintainers have issues and

1150
00:40:07,680 --> 00:40:09,440
comments you'll get notifications and

1151
00:40:09,440 --> 00:40:11,040
you can engage with them which is

1152
00:40:11,040 --> 00:40:13,520
important from the communication side so

1153
00:40:13,520 --> 00:40:16,160
there are risks but there are also an ad

1154
00:40:16,160 --> 00:40:18,800
an advantage to doing it this way

1155
00:40:18,800 --> 00:40:19,160
um

1156
00:40:19,160 --> 00:40:20,640
[Music]

1157
00:40:20,640 --> 00:40:22,079
uh yes this is my github profile for

1158
00:40:22,079 --> 00:40:24,640
most of you coordinate with github

1159
00:40:24,640 --> 00:40:26,720
um i reached out to github before

1160
00:40:26,720 --> 00:40:28,480
attempting this um they want to know

1161
00:40:28,480 --> 00:40:29,599
that you're doing this so that you're

1162
00:40:29,599 --> 00:40:30,880
not spamming they want to make sure

1163
00:40:30,880 --> 00:40:32,240
you're not spamming people so it's a

1164
00:40:32,240 --> 00:40:33,760
good thing to do

1165
00:40:33,760 --> 00:40:35,760
and then lesson number five is consider

1166
00:40:35,760 --> 00:40:37,359
the implications

1167
00:40:37,359 --> 00:40:39,920
um shortly after engaging in my most

1168
00:40:39,920 --> 00:40:41,200
recent round of bulk plural quest

1169
00:40:41,200 --> 00:40:44,319
generation i received this issue on my

1170
00:40:44,319 --> 00:40:46,560
security research uh i have a j light

1171
00:40:46,560 --> 00:40:48,400
shoe slash security research uh get a

1172
00:40:48,400 --> 00:40:50,640
repository is this responsible

1173
00:40:50,640 --> 00:40:53,040
responsible disclosure now i use the

1174
00:40:53,040 --> 00:40:54,640
term coordinated disclosure when i do

1175
00:40:54,640 --> 00:40:56,079
vulnerability exposures which is the new

1176
00:40:56,079 --> 00:40:58,240
more nuanced term um

1177
00:40:58,240 --> 00:40:58,960
but

1178
00:40:58,960 --> 00:41:00,000
either way you're going to call it

1179
00:41:00,000 --> 00:41:01,359
coordinated disclosure responsible

1180
00:41:01,359 --> 00:41:03,520
disclosure the answer is no this is full

1181
00:41:03,520 --> 00:41:05,440
disclosure of a vulnerability you're

1182
00:41:05,440 --> 00:41:08,000
odaying them potentially and that there

1183
00:41:08,000 --> 00:41:09,280
are implications there that you need to

1184
00:41:09,280 --> 00:41:10,319
consider

1185
00:41:10,319 --> 00:41:11,119
um

1186
00:41:11,119 --> 00:41:13,920
i argue that given the scale of the

1187
00:41:13,920 --> 00:41:16,400
amount of vulnerabilities in open source

1188
00:41:16,400 --> 00:41:18,400
it it actually

1189
00:41:18,400 --> 00:41:20,480
is a better net good to fix

1190
00:41:20,480 --> 00:41:22,480
vulnerabilities like this than it is to

1191
00:41:22,480 --> 00:41:24,480
not report them at all because that's

1192
00:41:24,480 --> 00:41:26,000
the alternative that i'm facing there's

1193
00:41:26,000 --> 00:41:27,599
only so much time in a day that i have

1194
00:41:27,599 --> 00:41:30,400
as a researcher and so

1195
00:41:30,400 --> 00:41:31,680
you're gonna end up full disclosing this

1196
00:41:31,680 --> 00:41:32,960
vulnerability

1197
00:41:32,960 --> 00:41:35,040
but the net benefit to the security the

1198
00:41:35,040 --> 00:41:38,480
internet is more is positive

1199
00:41:38,480 --> 00:41:40,240
and so

1200
00:41:40,240 --> 00:41:43,599
i want to leave you this this conclusion

1201
00:41:43,599 --> 00:41:45,839
as security researchers

1202
00:41:45,839 --> 00:41:49,119
i feel we have an obligation to society

1203
00:41:49,119 --> 00:41:50,560
we know that these vulnerabilities are

1204
00:41:50,560 --> 00:41:51,520
out there

1205
00:41:51,520 --> 00:41:52,880
and we know how to fix them we've

1206
00:41:52,880 --> 00:41:55,200
written pen test reports we've seen them

1207
00:41:55,200 --> 00:41:57,359
in source code reviews we've had them

1208
00:41:57,359 --> 00:41:59,040
come in from you know a variety of

1209
00:41:59,040 --> 00:42:00,880
different places right we understand how

1210
00:42:00,880 --> 00:42:02,560
these vulnerabilities exist

1211
00:42:02,560 --> 00:42:04,960
there's this problem in the industry

1212
00:42:04,960 --> 00:42:07,040
for every 500 developers you only have

1213
00:42:07,040 --> 00:42:08,960
one security researcher this is from

1214
00:42:08,960 --> 00:42:10,880
github in 2020.

1215
00:42:10,880 --> 00:42:13,920
so we are vastly outnumbered right

1216
00:42:13,920 --> 00:42:14,880
and

1217
00:42:14,880 --> 00:42:18,079
spoiler a lot of developers don't watch

1218
00:42:18,079 --> 00:42:20,000
besides talks don't watch black hat

1219
00:42:20,000 --> 00:42:21,920
talks don't watch defcon talks right

1220
00:42:21,920 --> 00:42:23,440
it's the unfortunate nature of the world

1221
00:42:23,440 --> 00:42:25,680
right so how are we going to be able to

1222
00:42:25,680 --> 00:42:27,599
best scale our knowledge

1223
00:42:27,599 --> 00:42:28,319
of

1224
00:42:28,319 --> 00:42:30,800
math science technology security and the

1225
00:42:30,800 --> 00:42:32,640
vulnerabilities that are out there to do

1226
00:42:32,640 --> 00:42:34,560
the most good in the world

1227
00:42:34,560 --> 00:42:37,520
and i argue that security uh pull

1228
00:42:37,520 --> 00:42:38,960
request generation

1229
00:42:38,960 --> 00:42:41,680
in this manner is the best way

1230
00:42:41,680 --> 00:42:43,599
to have the most positive impact in the

1231
00:42:43,599 --> 00:42:46,160
in in the security world or in this for

1232
00:42:46,160 --> 00:42:48,560
the security of open source

1233
00:42:48,560 --> 00:42:49,680
and with that i want to leave you with

1234
00:42:49,680 --> 00:42:51,440
one final quote from dan

1235
00:42:51,440 --> 00:42:52,319
um

1236
00:42:52,319 --> 00:42:55,280
this is on dan's twitter account um

1237
00:42:55,280 --> 00:42:57,520
it's still there to this day

1238
00:42:57,520 --> 00:42:59,119
we can fix it

1239
00:42:59,119 --> 00:43:00,880
we have the technology

1240
00:43:00,880 --> 00:43:02,960
okay we need to create the technology

1241
00:43:02,960 --> 00:43:04,400
all right the policy guys are mucking

1242
00:43:04,400 --> 00:43:06,880
with the technology relax

1243
00:43:06,880 --> 00:43:09,440
we're on it

1244
00:43:11,599 --> 00:43:12,880
i want to leave you

1245
00:43:12,880 --> 00:43:15,359
uh with some uh sound bites uh learn

1246
00:43:15,359 --> 00:43:17,520
code ql uh it's a really powerful

1247
00:43:17,520 --> 00:43:20,000
language um it's not

1248
00:43:20,000 --> 00:43:22,480
easy but you'll get it like it takes a

1249
00:43:22,480 --> 00:43:24,160
learning curve but it's worth learning

1250
00:43:24,160 --> 00:43:27,359
um you can do a lot with it you can find

1251
00:43:27,359 --> 00:43:28,960
really cool vulnerabilities it's really

1252
00:43:28,960 --> 00:43:30,800
cool writing a query and just having

1253
00:43:30,800 --> 00:43:32,560
them fall out of open source it really

1254
00:43:32,560 --> 00:43:34,160
it's really that easy they just start

1255
00:43:34,160 --> 00:43:37,040
falling out of of the open source code

1256
00:43:37,040 --> 00:43:38,079
um

1257
00:43:38,079 --> 00:43:39,680
contribute to open rewrite and you can

1258
00:43:39,680 --> 00:43:41,920
deploy your security fixes at scale

1259
00:43:41,920 --> 00:43:43,599
and then join the github security lab

1260
00:43:43,599 --> 00:43:45,119
and open rewrite slack channels where

1261
00:43:45,119 --> 00:43:46,960
you can discuss with me and other

1262
00:43:46,960 --> 00:43:48,400
security researchers who are trying to

1263
00:43:48,400 --> 00:43:49,599
tackle this problem of open source

1264
00:43:49,599 --> 00:43:52,079
security um to fix these vulnerabilities

1265
00:43:52,079 --> 00:43:53,599
i'm also going to toss on there if

1266
00:43:53,599 --> 00:43:55,119
you're interested in open security open

1267
00:43:55,119 --> 00:43:57,599
source security in general um consider

1268
00:43:57,599 --> 00:43:59,040
joining the open source security

1269
00:43:59,040 --> 00:44:00,480
foundation which is a subs it's a

1270
00:44:00,480 --> 00:44:01,760
project on the under the linux

1271
00:44:01,760 --> 00:44:03,839
foundation where a lot of the security

1272
00:44:03,839 --> 00:44:05,359
the discussions around the security of

1273
00:44:05,359 --> 00:44:07,280
open source are being discussed in

1274
00:44:07,280 --> 00:44:10,000
working group meetings every single week

1275
00:44:10,000 --> 00:44:10,880
so

1276
00:44:10,880 --> 00:44:13,359
um and then finally i want to say thank

1277
00:44:13,359 --> 00:44:17,200
you to human my employer um modern uh

1278
00:44:17,200 --> 00:44:19,520
for being spectacular and enabling this

1279
00:44:19,520 --> 00:44:22,800
work to even be possible uh lydia uh who

1280
00:44:22,800 --> 00:44:25,440
uh helped we ran she was the black hat

1281
00:44:25,440 --> 00:44:27,680
speaker coach that we ran this by like

1282
00:44:27,680 --> 00:44:29,599
way too many times to get this into the

1283
00:44:29,599 --> 00:44:32,160
state it was in and then sean my intern

1284
00:44:32,160 --> 00:44:34,480
who uh was instrumental in allowing

1285
00:44:34,480 --> 00:44:37,599
control flow analysis to exist um

1286
00:44:37,599 --> 00:44:38,560
so

1287
00:44:38,560 --> 00:44:40,480
also the graphics for control flow or

1288
00:44:40,480 --> 00:44:43,440
where some of his work so um thank you

1289
00:44:43,440 --> 00:44:47,079
that's that's us

1290
00:44:50,400 --> 00:44:53,550
[Applause]

1291
00:45:02,800 --> 00:45:04,960
my

1292
00:45:16,640 --> 00:45:19,520
yeah so your question was um what other

1293
00:45:19,520 --> 00:45:21,440
languages does open rewrites support

1294
00:45:21,440 --> 00:45:24,000
besides java

1295
00:45:24,000 --> 00:45:27,839
we have a xml we let's see

1296
00:45:27,839 --> 00:45:29,599
xml javascript

1297
00:45:29,599 --> 00:45:31,839
we're working on javascript yes working

1298
00:45:31,839 --> 00:45:35,040
on cobalt yes um

1299
00:45:35,040 --> 00:45:36,480
hcl

1300
00:45:36,480 --> 00:45:39,440
um kotlin's in the works properties no

1301
00:45:39,440 --> 00:45:40,800
not just not javascript currently

1302
00:45:40,800 --> 00:45:43,440
javascript's in the works um java

1303
00:45:43,440 --> 00:45:44,560
uh

1304
00:45:44,560 --> 00:45:46,640
gradle build files that's right um

1305
00:45:46,640 --> 00:45:48,240
groovy groovy

1306
00:45:48,240 --> 00:45:50,240
uh

1307
00:45:50,240 --> 00:45:51,440
yeah so it's

1308
00:45:51,440 --> 00:45:53,280
dominant predominantly java currently

1309
00:45:53,280 --> 00:45:54,720
but there's there's a lot of other work

1310
00:45:54,720 --> 00:45:56,000
going on it needs to support a bunch of

1311
00:45:56,000 --> 00:45:58,160
other languages too so

1312
00:45:58,160 --> 00:46:02,799
um yeah anybody else

1313
00:46:06,319 --> 00:46:08,400
going once

1314
00:46:08,400 --> 00:46:10,640
we'll take any questions i promise

1315
00:46:10,640 --> 00:46:13,200
going twice

1316
00:46:20,319 --> 00:46:21,760
yeah so

1317
00:46:21,760 --> 00:46:23,760
yes i try to put the wack duck in every

1318
00:46:23,760 --> 00:46:26,160
single one of my talks and uh yes so

1319
00:46:26,160 --> 00:46:28,640
this is a callback to that but also to

1320
00:46:28,640 --> 00:46:31,520
my previous zoom talk uh about

1321
00:46:31,520 --> 00:46:33,119
the oday that i dropped in zoom back in

1322
00:46:33,119 --> 00:46:35,520
2019. so go back and if you're curious

1323
00:46:35,520 --> 00:46:36,960
about that vulnerability go back it's

1324
00:46:36,960 --> 00:46:39,040
shmukon i talked about the zoom

1325
00:46:39,040 --> 00:46:40,880
vulnerability that i found so

1326
00:46:40,880 --> 00:46:41,680
um

1327
00:46:41,680 --> 00:46:43,839
any yeah any last questions yes go for

1328
00:46:43,839 --> 00:46:47,400
it yeah

1329
00:46:57,200 --> 00:46:58,960
so the question is it's

1330
00:46:58,960 --> 00:47:01,040
the goal of the best practices

1331
00:47:01,040 --> 00:47:03,200
about about trying to mitigate being

1332
00:47:03,200 --> 00:47:04,000
evil

1333
00:47:04,000 --> 00:47:05,760
and it's not just about mitigating being

1334
00:47:05,760 --> 00:47:07,680
evil it's like you're dealing with real

1335
00:47:07,680 --> 00:47:11,040
people but you're also

1336
00:47:11,040 --> 00:47:12,480
you don't want to come across as a bad

1337
00:47:12,480 --> 00:47:15,280
actor right because get up will bank

1338
00:47:15,280 --> 00:47:18,240
if you're a bad actor right like i mean

1339
00:47:18,240 --> 00:47:20,000
they will take into account like you're

1340
00:47:20,000 --> 00:47:21,280
trying to do the right thing but like

1341
00:47:21,280 --> 00:47:23,280
you don't want to get banned from github

1342
00:47:23,280 --> 00:47:24,960
um so

1343
00:47:24,960 --> 00:47:26,000
yeah i

1344
00:47:26,000 --> 00:47:28,559
it's about trying to

1345
00:47:28,559 --> 00:47:31,200
uh do the right thing in the context of

1346
00:47:31,200 --> 00:47:32,640
also fully disclosing a security

1347
00:47:32,640 --> 00:47:34,960
vulnerability in public if there was a

1348
00:47:34,960 --> 00:47:36,480
way to do this quote you know in a way

1349
00:47:36,480 --> 00:47:38,079
that was private if github supported

1350
00:47:38,079 --> 00:47:40,000
private issues like creating a private

1351
00:47:40,000 --> 00:47:42,800
issue or a private uh pull request

1352
00:47:42,800 --> 00:47:44,800
i would 100 percent go down that route

1353
00:47:44,800 --> 00:47:46,400
it just does it's not it's not supported

1354
00:47:46,400 --> 00:47:48,319
by get a current

1355
00:47:48,319 --> 00:47:50,839
john hook like you have a

1356
00:47:50,839 --> 00:47:53,839
question no okay just checking

1357
00:47:53,839 --> 00:47:57,799
yes go for it um

1358
00:47:58,760 --> 00:48:01,899
[Music]

1359
00:48:18,600 --> 00:48:21,710
[Music]

1360
00:48:26,240 --> 00:48:27,680
um

1361
00:48:27,680 --> 00:48:29,520
are there so are there organization

1362
00:48:29,520 --> 00:48:31,599
bought organizational bodies around this

1363
00:48:31,599 --> 00:48:34,920
sort of effort

1364
00:48:35,680 --> 00:48:38,000
no there is no so

1365
00:48:38,000 --> 00:48:39,920
as far as i'm aware

1366
00:48:39,920 --> 00:48:41,760
work like this around fixing

1367
00:48:41,760 --> 00:48:44,480
vulnerabilities at scale in this way

1368
00:48:44,480 --> 00:48:46,880
i am not aware of any other large-scale

1369
00:48:46,880 --> 00:48:48,720
efforts besides the ones that i've

1370
00:48:48,720 --> 00:48:51,040
engaged in to do this now they've not

1371
00:48:51,040 --> 00:48:53,599
i've seen for example like i've seen the

1372
00:48:53,599 --> 00:48:55,599
jenkins project go and generate a bunch

1373
00:48:55,599 --> 00:48:57,119
of pull requests specifically for the

1374
00:48:57,119 --> 00:48:58,880
jenkins project so like that's the

1375
00:48:58,880 --> 00:49:00,400
security team from jenkins doing that

1376
00:49:00,400 --> 00:49:02,720
specifically but i have not seen there's

1377
00:49:02,720 --> 00:49:05,040
no major project

1378
00:49:05,040 --> 00:49:07,440
that is actively engaged in this um this

1379
00:49:07,440 --> 00:49:09,200
has been something that i've been it's

1380
00:49:09,200 --> 00:49:10,400
been a project that i've been passionate

1381
00:49:10,400 --> 00:49:12,000
about and that's why i applied to the

1382
00:49:12,000 --> 00:49:14,559
dan kaminsky fellowship saying

1383
00:49:14,559 --> 00:49:16,480
i do this thing i have done this thing i

1384
00:49:16,480 --> 00:49:18,160
want to do more of it and they accepted

1385
00:49:18,160 --> 00:49:21,680
my application to enable me to try to

1386
00:49:21,680 --> 00:49:23,680
see what i could do in a year to to

1387
00:49:23,680 --> 00:49:25,200
scale this thing that i've been doing as

1388
00:49:25,200 --> 00:49:27,440
a side project into a full-time job so

1389
00:49:27,440 --> 00:49:29,599
this was my full-time job for the past

1390
00:49:29,599 --> 00:49:31,359
since january was working on this

1391
00:49:31,359 --> 00:49:33,119
project um

1392
00:49:33,119 --> 00:49:34,400
and uh

1393
00:49:34,400 --> 00:49:36,000
so yeah so that that's that's what

1394
00:49:36,000 --> 00:49:38,960
enabled this um i would love to chat if

1395
00:49:38,960 --> 00:49:40,720
you want to do more of this because i

1396
00:49:40,720 --> 00:49:42,480
want to do more of this in like i think

1397
00:49:42,480 --> 00:49:47,359
that more of this is awesome um yeah

1398
00:49:47,920 --> 00:49:51,040
anybody else open to any questions

1399
00:49:51,040 --> 00:49:52,319
or you can also come chat with us

1400
00:49:52,319 --> 00:49:54,319
afterwards i think that's

1401
00:49:54,319 --> 00:49:56,559
anybody okay thank you all for coming i

1402
00:49:56,559 --> 00:49:58,079
really appreciate it thank you thank you

1403
00:49:58,079 --> 00:50:00,160
and if you want to chat with us or you

1404
00:50:00,160 --> 00:50:02,000
can reach out to me on twitter uh i'm

1405
00:50:02,000 --> 00:50:06,359
also available there so thank you

