1
00:00:00,399 --> 00:00:04,799
hello everyone welcome to bci las vegas

2
00:00:04,799 --> 00:00:06,480
back in person

3
00:00:06,480 --> 00:00:09,200
um i just say a few words uh first of

4
00:00:09,200 --> 00:00:11,440
all i want to say uh thanks to our

5
00:00:11,440 --> 00:00:13,920
sponsors uh diamond sponsor

6
00:00:13,920 --> 00:00:16,880
lastpass and palo alto networks as well

7
00:00:16,880 --> 00:00:19,439
as our gold sponsors i just named three

8
00:00:19,439 --> 00:00:22,880
here amazon envision and blue cat

9
00:00:22,880 --> 00:00:25,680
a little bit of housekeeping

10
00:00:25,680 --> 00:00:28,400
please silence your cell phones

11
00:00:28,400 --> 00:00:30,560
the talk is being recorded it'll be

12
00:00:30,560 --> 00:00:32,960
available on youtube we also streaming

13
00:00:32,960 --> 00:00:36,880
live so uh you know make it make it nice

14
00:00:36,880 --> 00:00:38,320
here

15
00:00:38,320 --> 00:00:41,520
if we have questions at the end

16
00:00:41,520 --> 00:00:43,600
make sure that you come closer to the

17
00:00:43,600 --> 00:00:45,280
podium we don't have microphone in the

18
00:00:45,280 --> 00:00:47,039
room so the presenter can hear you

19
00:00:47,039 --> 00:00:48,960
repeat the question for the stream and

20
00:00:48,960 --> 00:00:50,079
answer it

21
00:00:50,079 --> 00:00:51,360
um

22
00:00:51,360 --> 00:00:52,879
picture policy

23
00:00:52,879 --> 00:00:55,440
you should know by now besides a strict

24
00:00:55,440 --> 00:00:57,600
policy for taking pictures make sure

25
00:00:57,600 --> 00:00:59,760
that you have explicit content from

26
00:00:59,760 --> 00:01:02,000
everybody in the frame should you take

27
00:01:02,000 --> 00:01:03,840
pictures

28
00:01:03,840 --> 00:01:06,640
keep your mask at all the time

29
00:01:06,640 --> 00:01:08,880
before i introduce brad here vladimir

30
00:01:08,880 --> 00:01:12,560
turkey how many people can speak french

31
00:01:12,560 --> 00:01:14,400
okay so we'll do it in english but it's

32
00:01:14,400 --> 00:01:16,479
just because it's you so vladimir is

33
00:01:16,479 --> 00:01:18,000
going to talk about a certain form of

34
00:01:18,000 --> 00:01:19,759
pollution from what i understand so hey

35
00:01:19,759 --> 00:01:21,759
you have the flow

36
00:01:21,759 --> 00:01:23,280
mercy dimitri

37
00:01:23,280 --> 00:01:26,320
uh but thanks for coming to my talk

38
00:01:26,320 --> 00:01:28,080
i hope you will enjoy it there will be a

39
00:01:28,080 --> 00:01:30,400
lot of javascript inside but don't worry

40
00:01:30,400 --> 00:01:32,079
we will cover

41
00:01:32,079 --> 00:01:33,840
everything

42
00:01:33,840 --> 00:01:36,799
feel free to sign very widely if i'm not

43
00:01:36,799 --> 00:01:39,759
speaking properly in the microphone

44
00:01:39,759 --> 00:01:41,040
vladimir

45
00:01:41,040 --> 00:01:43,119
you everybody calls me vlad i'm a staff

46
00:01:43,119 --> 00:01:45,280
engineer at datadog

47
00:01:45,280 --> 00:01:47,360
i'm also a node.js core collaborator

48
00:01:47,360 --> 00:01:48,799
i've been working on

49
00:01:48,799 --> 00:01:50,880
application security for the last six

50
00:01:50,880 --> 00:01:53,119
years in a startup that got acquired by

51
00:01:53,119 --> 00:01:55,439
datadog last year so we are building

52
00:01:55,439 --> 00:01:57,280
application security products feel free

53
00:01:57,280 --> 00:01:58,399
to reach out

54
00:01:58,399 --> 00:02:02,079
also feel free to follow me on twitter

55
00:02:02,079 --> 00:02:05,119
at pauldefette

56
00:02:05,840 --> 00:02:08,878
today i will take a chronological

57
00:02:08,878 --> 00:02:11,360
approach on that talk so there will be a

58
00:02:11,360 --> 00:02:14,640
lot of context stuff technical stuff a

59
00:02:14,640 --> 00:02:17,080
bit of uh

60
00:02:17,080 --> 00:02:19,760
self-soul-searching uh it will be kind

61
00:02:19,760 --> 00:02:22,400
of a mix of a lot of things

62
00:02:22,400 --> 00:02:24,720
don't worry the technical part is still

63
00:02:24,720 --> 00:02:27,440
the biggest part

64
00:02:27,440 --> 00:02:29,920
and a few disclaimers

65
00:02:29,920 --> 00:02:31,920
there's a lot of storytelling that's a

66
00:02:31,920 --> 00:02:34,959
very personal presentation it will cover

67
00:02:34,959 --> 00:02:36,480
a lot of things i've done as an open

68
00:02:36,480 --> 00:02:39,040
source contributor not as a data dog no

69
00:02:39,040 --> 00:02:41,680
screen employee

70
00:02:41,680 --> 00:02:43,200
and there will be a lot of back and

71
00:02:43,200 --> 00:02:45,040
forth about what i had in mind back then

72
00:02:45,040 --> 00:02:46,560
and you will understand why i say that

73
00:02:46,560 --> 00:02:49,280
now also last disclaimer i've built some

74
00:02:49,280 --> 00:02:51,599
commercial content online trainings

75
00:02:51,599 --> 00:02:53,120
about javascript

76
00:02:53,120 --> 00:02:55,519
security including prototype pollution

77
00:02:55,519 --> 00:02:58,080
and i found it was fair to to predict

78
00:02:58,080 --> 00:03:00,720
the disclaimers

79
00:03:00,720 --> 00:03:04,319
okay so it all started uh

80
00:03:04,319 --> 00:03:06,319
with the backbone t program

81
00:03:06,319 --> 00:03:07,360
so

82
00:03:07,360 --> 00:03:09,440
how many of you are familiar with npm as

83
00:03:09,440 --> 00:03:12,000
a package ecosystem okay

84
00:03:12,000 --> 00:03:14,800
a fair amount of people so just quick

85
00:03:14,800 --> 00:03:16,959
reminders it's the most popular package

86
00:03:16,959 --> 00:03:18,400
ecosystem in the world

87
00:03:18,400 --> 00:03:21,440
and you can take this graph at any time

88
00:03:21,440 --> 00:03:23,280
in the past few years it will look the

89
00:03:23,280 --> 00:03:27,360
same npm as a javascript package hosting

90
00:03:27,360 --> 00:03:28,720
repository

91
00:03:28,720 --> 00:03:31,280
is the most growing and the most popular

92
00:03:31,280 --> 00:03:33,200
package repository in the world and

93
00:03:33,200 --> 00:03:36,400
that's been so for almost a decade now

94
00:03:36,400 --> 00:03:40,239
there are millions of packages on npm

95
00:03:40,239 --> 00:03:42,159
and npm serves

96
00:03:42,159 --> 00:03:45,120
a huge variety of content of course

97
00:03:45,120 --> 00:03:47,200
they're javascript backhand packages

98
00:03:47,200 --> 00:03:49,680
node modules but they're also javascript

99
00:03:49,680 --> 00:03:52,159
front-end modules like people get react

100
00:03:52,159 --> 00:03:54,879
bootstrap from npm so front-end

101
00:03:54,879 --> 00:03:58,000
libraries are also downloaded from npm

102
00:03:58,000 --> 00:04:00,480
you have webassembly code that is

103
00:04:00,480 --> 00:04:03,280
distributed over npm because it's used

104
00:04:03,280 --> 00:04:05,840
on the web so wait no why not and you

105
00:04:05,840 --> 00:04:08,080
have native executable uh those are the

106
00:04:08,080 --> 00:04:10,879
native add-ons used with node.js so if

107
00:04:10,879 --> 00:04:13,360
you want to for instance use sqlite

108
00:04:13,360 --> 00:04:15,599
you're likely to use the sqlite3 native

109
00:04:15,599 --> 00:04:18,160
addon on node.js and that might be

110
00:04:18,160 --> 00:04:20,160
pre-compiled or not

111
00:04:20,160 --> 00:04:22,000
for instance data.org as a couple

112
00:04:22,000 --> 00:04:23,520
pre-compiled

113
00:04:23,520 --> 00:04:27,280
native executable on npm to patch

114
00:04:27,280 --> 00:04:30,800
node.js directly or even code in cc plus

115
00:04:30,800 --> 00:04:32,639
plus rest

116
00:04:32,639 --> 00:04:35,440
that can be compiled at install time for

117
00:04:35,440 --> 00:04:39,759
node.js so why why do i say that well

118
00:04:39,759 --> 00:04:41,680
in 2016

119
00:04:41,680 --> 00:04:43,520
the question of vulnerable slash

120
00:04:43,520 --> 00:04:46,080
medicine's package was a bit undefined

121
00:04:46,080 --> 00:04:48,720
npm did not really npm as a commercial

122
00:04:48,720 --> 00:04:50,880
entity did not

123
00:04:50,880 --> 00:04:52,960
want to do any strong efforts in that

124
00:04:52,960 --> 00:04:55,040
direction they had a lot of other things

125
00:04:55,040 --> 00:04:56,639
to do and that was fair from their point

126
00:04:56,639 --> 00:04:59,759
of view um sneak existed but was still

127
00:04:59,759 --> 00:05:02,320
fair new and that's that's a commercial

128
00:05:02,320 --> 00:05:04,880
tool and the node security project which

129
00:05:04,880 --> 00:05:07,919
was basically an alternative to sneak

130
00:05:07,919 --> 00:05:10,000
was deprecating because they got

131
00:05:10,000 --> 00:05:12,560
acquired by npm to do something totally

132
00:05:12,560 --> 00:05:13,759
different

133
00:05:13,759 --> 00:05:14,560
than

134
00:05:14,560 --> 00:05:16,560
vulnerable package management

135
00:05:16,560 --> 00:05:19,120
so the node security project

136
00:05:19,120 --> 00:05:21,039
came to the node foundation and say hey

137
00:05:21,039 --> 00:05:23,199
we've got this database of vulnerable

138
00:05:23,199 --> 00:05:24,960
and malicious packages

139
00:05:24,960 --> 00:05:27,440
do you want it do you want to be in

140
00:05:27,440 --> 00:05:30,400
charge of npm security as the node.js

141
00:05:30,400 --> 00:05:33,680
foundation and we said yes

142
00:05:33,680 --> 00:05:37,440
we were probably young and crazy

143
00:05:37,440 --> 00:05:39,680
so we created a node.js ecosystem

144
00:05:39,680 --> 00:05:42,240
bugbunty program and hacker1 was

145
00:05:42,240 --> 00:05:43,919
extremely nice they offered us a free

146
00:05:43,919 --> 00:05:47,120
plan for the ecosystem and we also have

147
00:05:47,120 --> 00:05:49,120
a free plan for node core so if you find

148
00:05:49,120 --> 00:05:51,520
minorities in node.js feel free to

149
00:05:51,520 --> 00:05:53,199
report them on hacker1 i will be happy

150
00:05:53,199 --> 00:05:54,880
to review them

151
00:05:54,880 --> 00:05:57,360
uh and we started the backbone t without

152
00:05:57,360 --> 00:06:00,240
rewards and depending on the case

153
00:06:00,240 --> 00:06:02,240
sometimes the owners of the vulnerable

154
00:06:02,240 --> 00:06:04,479
packages would give rewards so for

155
00:06:04,479 --> 00:06:06,400
instance a versailles company had

156
00:06:06,400 --> 00:06:08,479
vulnerabilities in a package themselves

157
00:06:08,479 --> 00:06:12,160
and they rewarded the hackers with 500

158
00:06:12,160 --> 00:06:14,240
dollars from time to time which was very

159
00:06:14,240 --> 00:06:17,440
generous and that was a lot of work

160
00:06:17,440 --> 00:06:19,280
handling this burgmanty program

161
00:06:19,280 --> 00:06:21,360
especially when i was by my own for the

162
00:06:21,360 --> 00:06:22,720
first six months

163
00:06:22,720 --> 00:06:25,280
because we had hundreds and of reports

164
00:06:25,280 --> 00:06:28,080
and usually reports there are trends

165
00:06:28,080 --> 00:06:30,880
when people find a vulnerability

166
00:06:30,880 --> 00:06:32,960
in the in search ecosystem people will

167
00:06:32,960 --> 00:06:34,639
do everything they can to find the same

168
00:06:34,639 --> 00:06:37,280
vulnerabilities in similar packages and

169
00:06:37,280 --> 00:06:39,440
that's actually important for for the

170
00:06:39,440 --> 00:06:41,680
rest of the talk

171
00:06:41,680 --> 00:06:46,160
and then in 2018 january we get

172
00:06:46,160 --> 00:06:50,240
a super report because it impacts 12

173
00:06:50,240 --> 00:06:53,599
packages on the apm ecosystem comes from

174
00:06:53,599 --> 00:06:56,240
a security researcher from canada named

175
00:06:56,240 --> 00:06:57,680
olivier

176
00:06:57,680 --> 00:07:00,479
and there are 12 impacted modules but

177
00:07:00,479 --> 00:07:02,160
the weird part is it talks about

178
00:07:02,160 --> 00:07:04,240
prototype pollution

179
00:07:04,240 --> 00:07:06,880
and we had no idea what prototype

180
00:07:06,880 --> 00:07:09,360
pollution was back then that was the

181
00:07:09,360 --> 00:07:11,440
first time we heard about it all

182
00:07:11,440 --> 00:07:13,680
together and we did not find any

183
00:07:13,680 --> 00:07:16,080
literature

184
00:07:16,080 --> 00:07:18,639
so the summary was utilities function in

185
00:07:18,639 --> 00:07:20,880
the listed modules can be tricked into

186
00:07:20,880 --> 00:07:23,280
modifying the prototype of object when

187
00:07:23,280 --> 00:07:24,560
the attackers

188
00:07:24,560 --> 00:07:26,400
control part of the structure passed to

189
00:07:26,400 --> 00:07:28,240
this function this can let blah blah

190
00:07:28,240 --> 00:07:29,840
blah

191
00:07:29,840 --> 00:07:33,599
how can you override methods

192
00:07:33,599 --> 00:07:37,280
in the javascript standard library

193
00:07:37,280 --> 00:07:38,960
and that's where we start to go

194
00:07:38,960 --> 00:07:41,280
technical and we forget about history

195
00:07:41,280 --> 00:07:42,080
for

196
00:07:42,080 --> 00:07:44,560
for a bit

197
00:07:44,560 --> 00:07:47,280
so in javascript you've got basic tips

198
00:07:47,280 --> 00:07:50,080
types you've got booleans objects

199
00:07:50,080 --> 00:07:53,280
numbers big ends strings symbols and

200
00:07:53,280 --> 00:07:55,840
undefined and pretty much everything

201
00:07:55,840 --> 00:07:56,720
else

202
00:07:56,720 --> 00:08:00,400
is objects so dicts are objects strange

203
00:08:00,400 --> 00:08:02,879
objects are objects regular expressions

204
00:08:02,879 --> 00:08:05,919
are objects null is a specific object

205
00:08:05,919 --> 00:08:09,120
and objects are objects and map and sets

206
00:08:09,120 --> 00:08:11,919
all this higher level data structures

207
00:08:11,919 --> 00:08:14,720
they are objects too

208
00:08:14,720 --> 00:08:18,639
and objects have method so for instance

209
00:08:18,639 --> 00:08:22,879
if i call undedict foo 1 has on property

210
00:08:22,879 --> 00:08:25,599
foo it will return true

211
00:08:25,599 --> 00:08:28,240
and hazard property is actually a

212
00:08:28,240 --> 00:08:30,560
property available

213
00:08:30,560 --> 00:08:34,399
it's a method available on that object

214
00:08:34,399 --> 00:08:37,679
uh if i check has on property and has

215
00:08:37,679 --> 00:08:40,559
own property it's false and hazon

216
00:08:40,559 --> 00:08:43,679
property tells you if this object

217
00:08:43,679 --> 00:08:45,760
owns this property or if it's come from

218
00:08:45,760 --> 00:08:48,080
somewhere else so now we know that we

219
00:08:48,080 --> 00:08:50,959
can call a method named has on property

220
00:08:50,959 --> 00:08:52,880
but it does not exist

221
00:08:52,880 --> 00:08:54,560
on the object itself

222
00:08:54,560 --> 00:08:57,360
so how is it available

223
00:08:57,360 --> 00:08:59,040
where does it come from

224
00:08:59,040 --> 00:09:00,160
well

225
00:09:00,160 --> 00:09:01,680
let's use a debugger because the

226
00:09:01,680 --> 00:09:03,440
debugger is probably the most marvelous

227
00:09:03,440 --> 00:09:05,200
piece of software in the history of

228
00:09:05,200 --> 00:09:06,800
software

229
00:09:06,800 --> 00:09:09,200
yeah i'm terrible when i'm asked to

230
00:09:09,200 --> 00:09:10,880
mentor juniors i for them to learn the

231
00:09:10,880 --> 00:09:12,800
debugger rather than putting prints

232
00:09:12,800 --> 00:09:13,760
everywhere

233
00:09:13,760 --> 00:09:15,839
um

234
00:09:15,839 --> 00:09:18,160
i never force anyone to do any anybody

235
00:09:18,160 --> 00:09:19,760
ah anybody i'm doing anything don't

236
00:09:19,760 --> 00:09:23,120
worry so if we debug it we realize that

237
00:09:23,120 --> 00:09:24,959
there's actually a property named

238
00:09:24,959 --> 00:09:28,240
prototype and that has on property is

239
00:09:28,240 --> 00:09:31,760
actually attached to this prototype

240
00:09:31,760 --> 00:09:33,040
so

241
00:09:33,040 --> 00:09:37,519
how does that work

242
00:09:37,519 --> 00:09:40,880
in javascript objects can't can have a

243
00:09:40,880 --> 00:09:42,320
prototype

244
00:09:42,320 --> 00:09:45,360
and when a method or property

245
00:09:45,360 --> 00:09:47,839
basically methods are properties in

246
00:09:47,839 --> 00:09:49,120
javascript

247
00:09:49,120 --> 00:09:52,160
is not found on an object

248
00:09:52,160 --> 00:09:54,880
we look up on its prototype

249
00:09:54,880 --> 00:09:56,959
so if you want to access a property on

250
00:09:56,959 --> 00:09:59,360
an object and if not available on the

251
00:09:59,360 --> 00:10:01,440
object directly we take the object's

252
00:10:01,440 --> 00:10:04,160
prototype and we check on that and the

253
00:10:04,160 --> 00:10:08,319
prototype is actually an object itself

254
00:10:08,480 --> 00:10:09,760
but

255
00:10:09,760 --> 00:10:10,880
this

256
00:10:10,880 --> 00:10:13,760
prototype might have a prototype so if

257
00:10:13,760 --> 00:10:15,519
the prototype does not have the property

258
00:10:15,519 --> 00:10:18,240
you're looking for well by recursion you

259
00:10:18,240 --> 00:10:20,160
look on it on the prototype of the

260
00:10:20,160 --> 00:10:22,079
prototype or on the prototype of the

261
00:10:22,079 --> 00:10:24,000
prototype of the prototype until there's

262
00:10:24,000 --> 00:10:26,320
no prototype available and that's why we

263
00:10:26,320 --> 00:10:28,880
talk a lot about prototype chain in

264
00:10:28,880 --> 00:10:31,839
javascript so let's talk about prototype

265
00:10:31,839 --> 00:10:32,880
chain

266
00:10:32,880 --> 00:10:33,680
uh

267
00:10:33,680 --> 00:10:35,440
on the left hand side we define

268
00:10:35,440 --> 00:10:37,680
functions uh constructors and on the

269
00:10:37,680 --> 00:10:40,959
right hand side we use them so

270
00:10:40,959 --> 00:10:41,839
let's

271
00:10:41,839 --> 00:10:44,399
create an object that's called myproto

272
00:10:44,399 --> 00:10:46,560
that should be a prototype for certain

273
00:10:46,560 --> 00:10:49,040
objects and it has a function a property

274
00:10:49,040 --> 00:10:51,760
named foo that is a function

275
00:10:51,760 --> 00:10:54,640
then we define a class with the old

276
00:10:54,640 --> 00:10:57,360
style in javascript where you define

277
00:10:57,360 --> 00:11:00,399
just the constructor and you attach a

278
00:11:00,399 --> 00:11:03,519
prototype property on that constructor

279
00:11:03,519 --> 00:11:05,760
and here we put our own prototype with

280
00:11:05,760 --> 00:11:06,640
bar

281
00:11:06,640 --> 00:11:09,040
and hello world

282
00:11:09,040 --> 00:11:11,920
as properties and then we defined a new

283
00:11:11,920 --> 00:11:13,680
style class

284
00:11:13,680 --> 00:11:16,800
that extends the old style class and as

285
00:11:16,800 --> 00:11:17,920
bars

286
00:11:17,920 --> 00:11:18,880
as

287
00:11:18,880 --> 00:11:20,560
a property

288
00:11:20,560 --> 00:11:24,240
so if we create an item an object from

289
00:11:24,240 --> 00:11:26,399
this class here

290
00:11:26,399 --> 00:11:29,360
well it has the property hello available

291
00:11:29,360 --> 00:11:31,360
because it's available on the prototype

292
00:11:31,360 --> 00:11:34,959
of old class old styles class that is

293
00:11:34,959 --> 00:11:38,800
actually implemented in our new class so

294
00:11:38,800 --> 00:11:40,959
that's just basic inheritance in any

295
00:11:40,959 --> 00:11:43,600
object-oriented language but with

296
00:11:43,600 --> 00:11:45,040
prototypes

297
00:11:45,040 --> 00:11:47,360
and if we call baz it's available

298
00:11:47,360 --> 00:11:49,279
because it's on the prototype here and

299
00:11:49,279 --> 00:11:51,200
if we call bar it's available because

300
00:11:51,200 --> 00:11:53,279
it's on the prototype here

301
00:11:53,279 --> 00:11:55,200
same thing if we call

302
00:11:55,200 --> 00:11:58,399
two it will share the same prototypes

303
00:11:58,399 --> 00:12:00,720
and if we create item three and we call

304
00:12:00,720 --> 00:12:03,600
the method set prototype off because why

305
00:12:03,600 --> 00:12:06,079
it's why not we can this method exists

306
00:12:06,079 --> 00:12:09,680
and we use my proto well now

307
00:12:09,680 --> 00:12:12,320
the prototype for item three will be my

308
00:12:12,320 --> 00:12:14,800
proto and we have selected an arbitrary

309
00:12:14,800 --> 00:12:16,000
prototype

310
00:12:16,000 --> 00:12:18,000
and what's interesting is that

311
00:12:18,000 --> 00:12:20,480
prototypes are objects

312
00:12:20,480 --> 00:12:23,040
and they are not defined multiple times

313
00:12:23,040 --> 00:12:25,920
in the heap there's only one instance of

314
00:12:25,920 --> 00:12:29,279
the prototype as an object in the hip

315
00:12:29,279 --> 00:12:32,959
so for instance item 2 and item 1

316
00:12:32,959 --> 00:12:35,279
you know they are created with new

317
00:12:35,279 --> 00:12:37,760
on the new style class

318
00:12:37,760 --> 00:12:38,399
so

319
00:12:38,399 --> 00:12:41,680
their prototype is the same object we

320
00:12:41,680 --> 00:12:45,040
can check equality object equality on

321
00:12:45,040 --> 00:12:46,800
their prototype value

322
00:12:46,800 --> 00:12:48,800
but this prototype

323
00:12:48,800 --> 00:12:50,160
has

324
00:12:50,160 --> 00:12:51,760
another prototype that is the one from

325
00:12:51,760 --> 00:12:54,160
the old style class because

326
00:12:54,160 --> 00:12:56,880
inheritance because the new class is

327
00:12:56,880 --> 00:13:00,079
actually extending the old style class

328
00:13:00,079 --> 00:13:02,720
and all of these prototypes they

329
00:13:02,720 --> 00:13:04,800
actually have another higher level

330
00:13:04,800 --> 00:13:07,680
prototype that is the object.prototype

331
00:13:07,680 --> 00:13:09,920
the default prototype for objects in a

332
00:13:09,920 --> 00:13:11,360
javascript heap

333
00:13:11,360 --> 00:13:13,760
and on the other side item three it's

334
00:13:13,760 --> 00:13:15,839
prototype it's my proto and the

335
00:13:15,839 --> 00:13:18,839
prototype of its prototype is

336
00:13:18,839 --> 00:13:20,800
object.prototype okay

337
00:13:20,800 --> 00:13:24,000
so the gotchas are

338
00:13:24,000 --> 00:13:25,760
objective prototype

339
00:13:25,760 --> 00:13:27,920
properties come from the prototype or

340
00:13:27,920 --> 00:13:29,920
the object when they are not found on

341
00:13:29,920 --> 00:13:32,079
the object we look upon them on the

342
00:13:32,079 --> 00:13:35,440
prototype and prototypes are the same

343
00:13:35,440 --> 00:13:37,600
for two different objects multiple

344
00:13:37,600 --> 00:13:39,760
objects can have the same prototype that

345
00:13:39,760 --> 00:13:44,000
are exactly the same object in hip

346
00:13:44,639 --> 00:13:47,279
and we can access the prototype from the

347
00:13:47,279 --> 00:13:49,519
object directly that's where javascript

348
00:13:49,519 --> 00:13:51,680
is a bit special so here i've got a

349
00:13:51,680 --> 00:13:53,519
class

350
00:13:53,519 --> 00:13:56,560
and i create two instances of this class

351
00:13:56,560 --> 00:13:59,360
one with b sides and the other vegas

352
00:13:59,360 --> 00:14:02,399
and if we call my item temba that has on

353
00:14:02,399 --> 00:14:05,920
property show prop it will tell us false

354
00:14:05,920 --> 00:14:08,880
also it's worth noticing that hazon

355
00:14:08,880 --> 00:14:11,279
property is actually available on the

356
00:14:11,279 --> 00:14:13,839
object prototype it's coming from the

357
00:14:13,839 --> 00:14:15,920
higher highest prototype in the

358
00:14:15,920 --> 00:14:18,320
prototype chain

359
00:14:18,320 --> 00:14:21,040
okay so we can call object dot get

360
00:14:21,040 --> 00:14:23,920
prototype off and that will return the

361
00:14:23,920 --> 00:14:27,199
prototype so in our case show prop

362
00:14:27,199 --> 00:14:30,240
is accessible on the prototype of my

363
00:14:30,240 --> 00:14:32,800
item i don't think anyone has said that

364
00:14:32,800 --> 00:14:33,839
much

365
00:14:33,839 --> 00:14:38,079
prototyping talk in in few years

366
00:14:38,079 --> 00:14:40,000
then you can also access the prototype

367
00:14:40,000 --> 00:14:42,079
by calling underscore underscore proto

368
00:14:42,079 --> 00:14:44,160
underscore underscore that's a kind of

369
00:14:44,160 --> 00:14:47,360
outdated way to do it it's deprecated

370
00:14:47,360 --> 00:14:50,560
officially but we can't really remove it

371
00:14:50,560 --> 00:14:52,240
from the web platform whether that's the

372
00:14:52,240 --> 00:14:54,079
front end or the back end because it

373
00:14:54,079 --> 00:14:55,839
will break everything so there are

374
00:14:55,839 --> 00:14:57,920
options to disable it i will see that

375
00:14:57,920 --> 00:15:00,959
later but you can access the prototype

376
00:15:00,959 --> 00:15:02,959
through the underscore underscore proto

377
00:15:02,959 --> 00:15:05,760
underscore underscore property

378
00:15:05,760 --> 00:15:08,639
or each object in javascript has a

379
00:15:08,639 --> 00:15:11,440
reference to its constructor

380
00:15:11,440 --> 00:15:13,120
and remember

381
00:15:13,120 --> 00:15:16,079
the prototype is just a property on the

382
00:15:16,079 --> 00:15:18,639
constructor so if you access the

383
00:15:18,639 --> 00:15:20,639
constructor of an object

384
00:15:20,639 --> 00:15:23,199
then the prototype value on the

385
00:15:23,199 --> 00:15:24,720
constructor

386
00:15:24,720 --> 00:15:28,399
you have access to the prototype too

387
00:15:28,399 --> 00:15:31,440
and just to re-explain that prototypes

388
00:15:31,440 --> 00:15:34,000
are single instance of objects if i take

389
00:15:34,000 --> 00:15:36,639
my item and my item too and i compare

390
00:15:36,639 --> 00:15:38,880
their prototypes they are exactly the

391
00:15:38,880 --> 00:15:41,839
same objects

392
00:15:41,839 --> 00:15:44,480
okay i think i'm good with explaining

393
00:15:44,480 --> 00:15:46,800
your prototypes work in javascript

394
00:15:46,800 --> 00:15:50,320
hopefully it was not too confusing

395
00:15:50,320 --> 00:15:52,320
so what's a pollution now that we know

396
00:15:52,320 --> 00:15:56,160
what a prototype is let's pollute them

397
00:15:56,160 --> 00:15:58,399
a prototype pollution happens when an

398
00:15:58,399 --> 00:16:00,480
arbitrary payload handled by the

399
00:16:00,480 --> 00:16:03,360
javascript codebase can overwrite

400
00:16:03,360 --> 00:16:06,160
properties or methods on the prototype

401
00:16:06,160 --> 00:16:07,680
chain

402
00:16:07,680 --> 00:16:09,120
and that's pretty much it and that

403
00:16:09,120 --> 00:16:11,040
happens usually when a merge function is

404
00:16:11,040 --> 00:16:14,000
called we'll see why

405
00:16:14,000 --> 00:16:14,959
now

406
00:16:14,959 --> 00:16:16,959
so here i'm using the

407
00:16:16,959 --> 00:16:19,920
library in an outdated version

408
00:16:19,920 --> 00:16:22,560
it was part of the original

409
00:16:22,560 --> 00:16:24,959
report by olivier

410
00:16:24,959 --> 00:16:26,800
on prototype pollution

411
00:16:26,800 --> 00:16:29,279
so i create a malicious payload

412
00:16:29,279 --> 00:16:31,120
with a property name underscore

413
00:16:31,120 --> 00:16:33,120
underscore proto underscore underscore

414
00:16:33,120 --> 00:16:34,959
remember that's one of the way of

415
00:16:34,959 --> 00:16:38,240
accessing prototypes from an object

416
00:16:38,240 --> 00:16:41,199
and then i place a property named oops

417
00:16:41,199 --> 00:16:44,399
on it with it works

418
00:16:44,399 --> 00:16:47,920
i create an object named a

419
00:16:47,920 --> 00:16:49,279
and i don't

420
00:16:49,279 --> 00:16:51,600
mutate this object at all anymore

421
00:16:51,600 --> 00:16:54,480
because on the next line i say before

422
00:16:54,480 --> 00:16:56,720
and i check if a has a property named

423
00:16:56,720 --> 00:16:59,279
oops either an a is on the prototype

424
00:16:59,279 --> 00:17:02,320
chain and it will say undefined because

425
00:17:02,320 --> 00:17:05,599
there is no oops in the prototype chain

426
00:17:05,599 --> 00:17:08,079
or on a

427
00:17:08,079 --> 00:17:10,880
then i call hook.merge on a totally

428
00:17:10,880 --> 00:17:13,919
brand new object nothing to do with a

429
00:17:13,919 --> 00:17:16,959
and json.pass my malicious payload i

430
00:17:16,959 --> 00:17:19,280
will explain why we use json and pass

431
00:17:19,280 --> 00:17:21,839
right after that

432
00:17:21,839 --> 00:17:26,160
and then i recheck if a has a oops

433
00:17:26,160 --> 00:17:27,919
property

434
00:17:27,919 --> 00:17:30,880
and actually tells us it works

435
00:17:30,880 --> 00:17:33,760
because the call to the merge function

436
00:17:33,760 --> 00:17:36,320
actually mutated

437
00:17:36,320 --> 00:17:39,919
something in the prototype chain

438
00:17:39,919 --> 00:17:42,000
because when the merge function was

439
00:17:42,000 --> 00:17:45,760
called it checked if it could merge the

440
00:17:45,760 --> 00:17:46,960
proto

441
00:17:46,960 --> 00:17:50,559
property of this object and it did so it

442
00:17:50,559 --> 00:17:52,160
accessed the proto

443
00:17:52,160 --> 00:17:54,799
property the prototype of our brand new

444
00:17:54,799 --> 00:17:58,240
object and added a property name oops on

445
00:17:58,240 --> 00:18:00,360
this prototype but this prototype is

446
00:18:00,360 --> 00:18:02,640
object.prototype the global prototype

447
00:18:02,640 --> 00:18:05,679
for all objects so basically all our

448
00:18:05,679 --> 00:18:08,480
objects in this javascript group hit

449
00:18:08,480 --> 00:18:09,600
no

450
00:18:09,600 --> 00:18:12,480
real return it works when you call oops

451
00:18:12,480 --> 00:18:14,559
except if they have their own property

452
00:18:14,559 --> 00:18:16,240
name oops

453
00:18:16,240 --> 00:18:17,720
why do we use

454
00:18:17,720 --> 00:18:20,880
json.pass here because if you define the

455
00:18:20,880 --> 00:18:22,640
object directly

456
00:18:22,640 --> 00:18:23,520
well

457
00:18:23,520 --> 00:18:26,080
it will already have a proto property

458
00:18:26,080 --> 00:18:28,080
and it will be kinda ignored by the

459
00:18:28,080 --> 00:18:29,200
engine

460
00:18:29,200 --> 00:18:31,760
but there's a gotcha in the historical

461
00:18:31,760 --> 00:18:34,799
implementation of json.pass that makes

462
00:18:34,799 --> 00:18:37,440
this proto valid only if it comes

463
00:18:37,440 --> 00:18:39,280
outside of json.pass

464
00:18:39,280 --> 00:18:40,559
i won't go in the depth of the

465
00:18:40,559 --> 00:18:42,640
implementation of that but

466
00:18:42,640 --> 00:18:44,320
the gotcha is that for this exploit to

467
00:18:44,320 --> 00:18:47,440
work it must go through json.pass

468
00:18:47,440 --> 00:18:48,240
but

469
00:18:48,240 --> 00:18:50,240
so why

470
00:18:50,240 --> 00:18:52,640
then as i told you let's check the merge

471
00:18:52,640 --> 00:18:55,520
method and the merge method is actually

472
00:18:55,520 --> 00:18:59,360
recursive it calls merge again on itself

473
00:18:59,360 --> 00:19:02,080
because you want to merge objects

474
00:19:02,080 --> 00:19:04,080
recursively because you want to merge

475
00:19:04,080 --> 00:19:07,600
nested and sub-objects of your object

476
00:19:07,600 --> 00:19:09,919
and that's where the prototype pollution

477
00:19:09,919 --> 00:19:13,360
happens because once again you will

478
00:19:13,360 --> 00:19:16,000
check if the object that is the target

479
00:19:16,000 --> 00:19:17,360
right now

480
00:19:17,360 --> 00:19:19,919
the first one here has

481
00:19:19,919 --> 00:19:21,840
underscore underscore proto underscore

482
00:19:21,840 --> 00:19:24,240
underscore as a property this will

483
00:19:24,240 --> 00:19:25,760
return true

484
00:19:25,760 --> 00:19:28,960
so you will merge property

485
00:19:28,960 --> 00:19:32,240
on the prototype because recursiveness

486
00:19:32,240 --> 00:19:35,679
i hope that's not too confused

487
00:19:35,679 --> 00:19:38,559
okay other example in that case we don't

488
00:19:38,559 --> 00:19:42,160
need the json.pass version because

489
00:19:42,160 --> 00:19:44,559
remember all objects in javascript has

490
00:19:44,559 --> 00:19:46,480
access to their constructor

491
00:19:46,480 --> 00:19:48,320
so their own prototype through the

492
00:19:48,320 --> 00:19:51,360
constructor so there's another exploit

493
00:19:51,360 --> 00:19:53,039
there used to be another exploit in

494
00:19:53,039 --> 00:19:54,880
lodash

495
00:19:54,880 --> 00:19:57,039
where you would do basically the same so

496
00:19:57,039 --> 00:19:58,960
here we've got constructor prototype is

497
00:19:58,960 --> 00:20:00,720
that mean true

498
00:20:00,720 --> 00:20:02,799
we create a b object

499
00:20:02,799 --> 00:20:06,080
before we check b dot is mean it returns

500
00:20:06,080 --> 00:20:07,280
undefined

501
00:20:07,280 --> 00:20:08,480
we merge

502
00:20:08,480 --> 00:20:10,320
the payload on a totally different

503
00:20:10,320 --> 00:20:12,799
object and when we call b that is that

504
00:20:12,799 --> 00:20:15,039
mean it will return true because we

505
00:20:15,039 --> 00:20:18,960
polluted the prototype chain again

506
00:20:18,960 --> 00:20:20,720
and why does it matter

507
00:20:20,720 --> 00:20:23,440
well lowdash is actually one of the most

508
00:20:23,440 --> 00:20:26,320
popular javascript package on earth it's

509
00:20:26,320 --> 00:20:28,799
been downloaded more than 200 million

510
00:20:28,799 --> 00:20:29,760
times

511
00:20:29,760 --> 00:20:30,640
in

512
00:20:30,640 --> 00:20:33,360
april that's the downloads per month and

513
00:20:33,360 --> 00:20:36,799
it's been downloading 8 billion times

514
00:20:36,799 --> 00:20:39,120
since the package was created

515
00:20:39,120 --> 00:20:41,440
it's pretty much in most javascript code

516
00:20:41,440 --> 00:20:43,440
bases and it has been having multiple

517
00:20:43,440 --> 00:20:45,440
prototype pollutions meaning that the

518
00:20:45,440 --> 00:20:48,000
world javascript ecosystem was at risk

519
00:20:48,000 --> 00:20:50,240
with them

520
00:20:50,240 --> 00:20:51,200
okay

521
00:20:51,200 --> 00:20:53,200
let's take a break from the javascript

522
00:20:53,200 --> 00:20:54,640
and saying prototype prototype and

523
00:20:54,640 --> 00:20:56,400
prototype of prototype

524
00:20:56,400 --> 00:20:58,480
and recursion and recursion and

525
00:20:58,480 --> 00:21:00,960
recursion and go back to the report to

526
00:21:00,960 --> 00:21:03,440
go a bit slower so we started to discuss

527
00:21:03,440 --> 00:21:06,000
on hacker one and the report is still

528
00:21:06,000 --> 00:21:08,240
private for a lot of reason even four

529
00:21:08,240 --> 00:21:09,520
years later

530
00:21:09,520 --> 00:21:11,840
but he's the gist of the discussion

531
00:21:11,840 --> 00:21:13,600
first thing we did we acknowledge having

532
00:21:13,600 --> 00:21:14,840
the report

533
00:21:14,840 --> 00:21:18,320
and we just gathered as the bugbunty

534
00:21:18,320 --> 00:21:20,080
manager team and be like

535
00:21:20,080 --> 00:21:21,039
okay

536
00:21:21,039 --> 00:21:23,120
what do we do with that now is that

537
00:21:23,120 --> 00:21:26,080
really a security issue or is that a

538
00:21:26,080 --> 00:21:28,159
quality issue is that a widespread

539
00:21:28,159 --> 00:21:30,559
defect in the javascript ecosystem or is

540
00:21:30,559 --> 00:21:34,080
it something that actually can be used

541
00:21:34,080 --> 00:21:34,799
to

542
00:21:34,799 --> 00:21:37,600
impact applications on their security

543
00:21:37,600 --> 00:21:39,840
posture

544
00:21:39,840 --> 00:21:40,960
and

545
00:21:40,960 --> 00:21:43,200
discussions went on and on and at the

546
00:21:43,200 --> 00:21:45,200
same time i started to reach out to

547
00:21:45,200 --> 00:21:49,600
nathan la forest nathan la forest here

548
00:21:49,840 --> 00:21:51,840
with the main maintainer of hook the

549
00:21:51,840 --> 00:21:53,520
first library i showed

550
00:21:53,520 --> 00:21:55,679
today

551
00:21:55,679 --> 00:21:57,919
and i told him hey nothing i i don't

552
00:21:57,919 --> 00:22:00,799
understand how it works under the hood

553
00:22:00,799 --> 00:22:02,480
what i explained in the previous slide i

554
00:22:02,480 --> 00:22:04,480
did not understand back then

555
00:22:04,480 --> 00:22:06,320
just reading a report and it was hard to

556
00:22:06,320 --> 00:22:07,440
understand

557
00:22:07,440 --> 00:22:08,240
so

558
00:22:08,240 --> 00:22:11,039
we we sat together over the internet and

559
00:22:11,039 --> 00:22:13,360
started to put debug points and try to

560
00:22:13,360 --> 00:22:15,039
understand how

561
00:22:15,039 --> 00:22:17,840
how how that worked and that's how we

562
00:22:17,840 --> 00:22:19,600
understood prototype pollution and it

563
00:22:19,600 --> 00:22:20,960
blew our mind

564
00:22:20,960 --> 00:22:22,480
and

565
00:22:22,480 --> 00:22:24,000
we know

566
00:22:24,000 --> 00:22:26,480
that there is a systemic bug in a lot of

567
00:22:26,480 --> 00:22:29,440
javascript code base based on that uh we

568
00:22:29,440 --> 00:22:31,760
know that everything that's merged or

569
00:22:31,760 --> 00:22:33,120
deep clone

570
00:22:33,120 --> 00:22:35,440
with recursion might be vulnerable to

571
00:22:35,440 --> 00:22:38,400
that as long as it takes arbitrary

572
00:22:38,400 --> 00:22:41,840
payloads in input

573
00:22:42,240 --> 00:22:45,280
is it a security issue that that's a one

574
00:22:45,280 --> 00:22:47,280
billion dollar question maybe i'm a bit

575
00:22:47,280 --> 00:22:51,120
exaggerating but not that much

576
00:22:51,120 --> 00:22:53,600
so we challenged a bit and the reporter

577
00:22:53,600 --> 00:22:54,480
actually

578
00:22:54,480 --> 00:22:57,280
provided an exploit in an existing code

579
00:22:57,280 --> 00:22:58,320
base

580
00:22:58,320 --> 00:23:01,280
node.js code base some kind of cms

581
00:23:01,280 --> 00:23:03,679
blog management i won't name it because

582
00:23:03,679 --> 00:23:05,360
it's the reason why the report is not

583
00:23:05,360 --> 00:23:07,679
public yet because it's been fixed in it

584
00:23:07,679 --> 00:23:10,640
but never published properly um

585
00:23:10,640 --> 00:23:11,520
and

586
00:23:11,520 --> 00:23:14,240
they actually highlighted

587
00:23:14,240 --> 00:23:17,200
a crash in the application so node.js

588
00:23:17,200 --> 00:23:19,520
applications are writing in javascript

589
00:23:19,520 --> 00:23:21,520
and javascript is by definition single

590
00:23:21,520 --> 00:23:24,320
threaded like worker threads are an

591
00:23:24,320 --> 00:23:27,679
exception to that but no js applications

592
00:23:27,679 --> 00:23:29,360
they are thing they are usually single

593
00:23:29,360 --> 00:23:31,760
threaded and all http requests are

594
00:23:31,760 --> 00:23:34,080
handled by the same thread at the same

595
00:23:34,080 --> 00:23:36,960
time with a lot of asynchronicity so

596
00:23:36,960 --> 00:23:39,600
if you crash one thread in a node.js

597
00:23:39,600 --> 00:23:41,520
application well you crash the whole

598
00:23:41,520 --> 00:23:43,919
process because there's only one thread

599
00:23:43,919 --> 00:23:45,840
that's why error management is really

600
00:23:45,840 --> 00:23:48,159
critical and if you manage to find a

601
00:23:48,159 --> 00:23:50,640
crasher you're not crashing one request

602
00:23:50,640 --> 00:23:54,000
you're crashing the web server itself

603
00:23:54,000 --> 00:23:55,679
so they found

604
00:23:55,679 --> 00:23:59,279
a crash by replacing a method by a

605
00:23:59,279 --> 00:24:02,720
string which is fair and the codebase

606
00:24:02,720 --> 00:24:04,720
was calling this method and that was

607
00:24:04,720 --> 00:24:06,320
crashing because it was a string at this

608
00:24:06,320 --> 00:24:07,200
point

609
00:24:07,200 --> 00:24:08,880
um

610
00:24:08,880 --> 00:24:10,960
so we found the denial of service

611
00:24:10,960 --> 00:24:12,000
because that's

612
00:24:12,000 --> 00:24:13,440
that's the definition of a denial of

613
00:24:13,440 --> 00:24:15,679
service you crash to applicati

614
00:24:15,679 --> 00:24:18,080
application server

615
00:24:18,080 --> 00:24:22,400
and we also found cwe 471 a modification

616
00:24:22,400 --> 00:24:25,039
of assumed immutable data

617
00:24:25,039 --> 00:24:26,799
that was a good candidate back then with

618
00:24:26,799 --> 00:24:30,080
our knowledge so based on that we had

619
00:24:30,080 --> 00:24:32,000
okay we have an exploit at least one

620
00:24:32,000 --> 00:24:34,400
real life exploits that has an

621
00:24:34,400 --> 00:24:36,799
acceptable outcome

622
00:24:36,799 --> 00:24:40,080
has been acceptable a malicious outcome

623
00:24:40,080 --> 00:24:43,679
uh and we found some kind of reference

624
00:24:43,679 --> 00:24:47,360
in referential we found this cwe saying

625
00:24:47,360 --> 00:24:49,440
hey this has been acknowledged as a

626
00:24:49,440 --> 00:24:53,600
group of vulnerabilities by the industry

627
00:24:53,600 --> 00:24:56,080
so at this point we are mostly thinking

628
00:24:56,080 --> 00:24:58,480
yeah that's probably your proper

629
00:24:58,480 --> 00:25:01,760
vulnerability let's accept it as a

630
00:25:01,760 --> 00:25:04,240
vulnerability report

631
00:25:04,240 --> 00:25:06,240
so a bit of housekeeping

632
00:25:06,240 --> 00:25:09,919
we asked olivier to publish 12 reports

633
00:25:09,919 --> 00:25:12,080
instead of one single one because we had

634
00:25:12,080 --> 00:25:14,400
to communicate with library maintainers

635
00:25:14,400 --> 00:25:16,480
for them to fix and we didn't want them

636
00:25:16,480 --> 00:25:18,480
to know the list of other vulnerable

637
00:25:18,480 --> 00:25:20,000
packages

638
00:25:20,000 --> 00:25:22,320
uh we reached out to the maintainers

639
00:25:22,320 --> 00:25:26,080
shared the reports and we started

640
00:25:26,080 --> 00:25:29,120
publishing fix and publishing reports

641
00:25:29,120 --> 00:25:31,360
and we had like a few cwc

642
00:25:31,360 --> 00:25:35,840
cve going out in 2018

643
00:25:35,840 --> 00:25:38,400
and what happens after 2018. well that's

644
00:25:38,400 --> 00:25:41,200
a good question yeah since 2018 there

645
00:25:41,200 --> 00:25:43,440
have been 193

646
00:25:43,440 --> 00:25:47,840
cv published for prototype pollution

647
00:25:47,840 --> 00:25:50,640
2022 is not over

648
00:25:50,640 --> 00:25:51,919
um

649
00:25:51,919 --> 00:25:54,720
and not all projects attribute cves for

650
00:25:54,720 --> 00:25:58,080
instance if i'm not mistaken sneak does

651
00:25:58,080 --> 00:26:01,760
not apply uh published cvs on a lot of

652
00:26:01,760 --> 00:26:05,120
packages when they're not popular enough

653
00:26:05,120 --> 00:26:07,840
and the hacker one project for node

654
00:26:07,840 --> 00:26:10,400
ecosystem for npm ecosystem has been

655
00:26:10,400 --> 00:26:11,600
closed

656
00:26:11,600 --> 00:26:14,000
meaning there might be hundreds of other

657
00:26:14,000 --> 00:26:16,799
occurrences of prototype pollutions in

658
00:26:16,799 --> 00:26:18,640
the wild

659
00:26:18,640 --> 00:26:21,279
i kinda remember stats why it was one of

660
00:26:21,279 --> 00:26:22,880
the most

661
00:26:22,880 --> 00:26:24,640
the fastest

662
00:26:24,640 --> 00:26:28,320
publishing cv machines in terms of

663
00:26:28,320 --> 00:26:30,720
attack classes

664
00:26:30,720 --> 00:26:34,000
there have been one sce in chibana

665
00:26:34,000 --> 00:26:36,880
we'll go on that later and in december

666
00:26:36,880 --> 00:26:39,279
it was a repo there was a report about

667
00:26:39,279 --> 00:26:41,279
one cve

668
00:26:41,279 --> 00:26:44,159
on pass server we'll get to that a bit

669
00:26:44,159 --> 00:26:45,360
later too

670
00:26:45,360 --> 00:26:48,480
and more recently last month

671
00:26:48,480 --> 00:26:50,480
the royal institute of technology in

672
00:26:50,480 --> 00:26:53,679
sweden published

673
00:26:53,760 --> 00:26:55,760
published a really cool paper

674
00:26:55,760 --> 00:26:57,440
on the topic

675
00:26:57,440 --> 00:26:59,120
the reference will be at the end of the

676
00:26:59,120 --> 00:27:02,480
of the talk it's a good write

677
00:27:02,480 --> 00:27:05,440
so i told you let's talk about an se

678
00:27:05,440 --> 00:27:08,320
because we found dos but what about sce

679
00:27:08,320 --> 00:27:11,039
over prototype pollution

680
00:27:11,039 --> 00:27:12,880
okay so

681
00:27:12,880 --> 00:27:15,840
as i told you node.js is single threaded

682
00:27:15,840 --> 00:27:16,640
so

683
00:27:16,640 --> 00:27:18,880
if you want to do

684
00:27:18,880 --> 00:27:21,840
tasks that are cpu intensive you will be

685
00:27:21,840 --> 00:27:23,919
blo you will be monopolizing the single

686
00:27:23,919 --> 00:27:26,159
thread and node.js has been designed for

687
00:27:26,159 --> 00:27:28,960
ios for asynchronicity so if you block

688
00:27:28,960 --> 00:27:31,279
the main thread you block the wall up

689
00:27:31,279 --> 00:27:34,559
and you kinda does it temporarily

690
00:27:34,559 --> 00:27:36,799
so kibana use a hack

691
00:27:36,799 --> 00:27:38,960
when it has to do some computing it

692
00:27:38,960 --> 00:27:42,159
start a child process which is very fair

693
00:27:42,159 --> 00:27:44,480
until we had worker threads in node.js

694
00:27:44,480 --> 00:27:46,840
two years ago that was the only way to

695
00:27:46,840 --> 00:27:51,200
go and node.js shares the environment

696
00:27:51,200 --> 00:27:53,679
of the parent process to the children

697
00:27:53,679 --> 00:27:55,840
one

698
00:27:55,840 --> 00:27:57,679
and this is defined as a javascript

699
00:27:57,679 --> 00:27:59,919
object i think you kind of see where

700
00:27:59,919 --> 00:28:01,600
this is going right

701
00:28:01,600 --> 00:28:03,919
and node.js has an option

702
00:28:03,919 --> 00:28:05,520
that's called that's an environment

703
00:28:05,520 --> 00:28:08,240
variable called node options and

704
00:28:08,240 --> 00:28:10,640
basically that enables you to pass

705
00:28:10,640 --> 00:28:13,200
command lines argument to node.js but

706
00:28:13,200 --> 00:28:15,120
through an environment variable so

707
00:28:15,120 --> 00:28:17,679
instead of doing node.js dash something

708
00:28:17,679 --> 00:28:19,600
then your executable you can do node

709
00:28:19,600 --> 00:28:20,880
option

710
00:28:20,880 --> 00:28:23,760
your flags then load your executable

711
00:28:23,760 --> 00:28:26,159
which is something handy

712
00:28:26,159 --> 00:28:27,120
well

713
00:28:27,120 --> 00:28:29,679
what happened in kibana

714
00:28:29,679 --> 00:28:32,240
is that someone found a prototype

715
00:28:32,240 --> 00:28:33,440
pollution

716
00:28:33,440 --> 00:28:36,640
to actually write the node option

717
00:28:36,640 --> 00:28:39,120
property on the prototype chain

718
00:28:39,120 --> 00:28:41,440
so when the child process was starting

719
00:28:41,440 --> 00:28:43,600
it was inheriting the environment from

720
00:28:43,600 --> 00:28:44,960
the parents

721
00:28:44,960 --> 00:28:48,159
including the node option newly defined

722
00:28:48,159 --> 00:28:49,840
and their environment viable on the

723
00:28:49,840 --> 00:28:52,159
prototype chain and they would be able

724
00:28:52,159 --> 00:28:54,960
to call dash e for eval

725
00:28:54,960 --> 00:28:58,559
and run arbitrary javascript code

726
00:28:58,559 --> 00:29:00,399
from the command line through a

727
00:29:00,399 --> 00:29:02,000
prototype pollution

728
00:29:02,000 --> 00:29:03,919
and since you're running arbitrary

729
00:29:03,919 --> 00:29:06,240
node.js code you can call another child

730
00:29:06,240 --> 00:29:08,320
process with a shell in it you can call

731
00:29:08,320 --> 00:29:09,679
the file system

732
00:29:09,679 --> 00:29:13,120
you've got an sce directly on the server

733
00:29:13,120 --> 00:29:15,039
so that was pretty bad

734
00:29:15,039 --> 00:29:17,440
that's been fixed and i know that the

735
00:29:17,440 --> 00:29:20,080
kibana team has been doing a tremendous

736
00:29:20,080 --> 00:29:22,720
job on that

737
00:29:23,279 --> 00:29:26,399
the past vulnerability is more recent

738
00:29:26,399 --> 00:29:28,559
the report is from december

739
00:29:28,559 --> 00:29:32,320
but it has been published only this year

740
00:29:32,320 --> 00:29:34,000
if i'm not mistaken past was a

741
00:29:34,000 --> 00:29:35,520
standalone startup

742
00:29:35,520 --> 00:29:37,360
that got acquired by one of the major

743
00:29:37,360 --> 00:29:39,039
companies of the valley i'll let you

744
00:29:39,039 --> 00:29:40,960
google where that is

745
00:29:40,960 --> 00:29:43,039
but it's not google and they deprecated

746
00:29:43,039 --> 00:29:44,799
the project and the current version of

747
00:29:44,799 --> 00:29:48,080
pass is the open source community

748
00:29:48,080 --> 00:29:49,919
version of that

749
00:29:49,919 --> 00:29:52,559
and that's basically a rest api in front

750
00:29:52,559 --> 00:29:55,760
of mongodb it's used to build backends

751
00:29:55,760 --> 00:29:59,279
for mobile applications and

752
00:29:59,279 --> 00:30:00,399
basically

753
00:30:00,399 --> 00:30:02,559
it's it's an api it's a web api

754
00:30:02,559 --> 00:30:05,200
over mongodb so you can write objects

755
00:30:05,200 --> 00:30:08,960
you can read objects all of that

756
00:30:08,960 --> 00:30:10,799
and it's vulnerable to prototype

757
00:30:10,799 --> 00:30:13,279
pollution because it's called the merge

758
00:30:13,279 --> 00:30:15,440
function at some point that's that he

759
00:30:15,440 --> 00:30:18,399
exploits but also it uses a library

760
00:30:18,399 --> 00:30:19,679
named b

761
00:30:19,679 --> 00:30:23,120
bison.js which is the default library

762
00:30:23,120 --> 00:30:27,360
used by the mongodb driver in node.js

763
00:30:28,720 --> 00:30:32,880
so the attacker can upload a document

764
00:30:32,880 --> 00:30:35,039
on mongodb

765
00:30:35,039 --> 00:30:37,520
through pass that's basically the point

766
00:30:37,520 --> 00:30:39,679
of this piece of software you can upload

767
00:30:39,679 --> 00:30:41,919
upload and retrieve documents in mongodb

768
00:30:41,919 --> 00:30:43,360
so good

769
00:30:43,360 --> 00:30:45,120
and those documents are formatted in

770
00:30:45,120 --> 00:30:48,880
bison and bison actually allows you to

771
00:30:48,880 --> 00:30:51,600
register functions that will be executed

772
00:30:51,600 --> 00:30:54,320
when you deserialize code from mongodb

773
00:30:54,320 --> 00:30:56,720
but this is by default disabled

774
00:30:56,720 --> 00:30:58,480
you need to

775
00:30:58,480 --> 00:31:01,360
enable the eval functions property on

776
00:31:01,360 --> 00:31:03,600
the bison library to

777
00:31:03,600 --> 00:31:05,919
make the code executable

778
00:31:05,919 --> 00:31:08,559
but there's a prototype pollution so you

779
00:31:08,559 --> 00:31:10,159
can pollute

780
00:31:10,159 --> 00:31:13,039
eval function for all objects in the hip

781
00:31:13,039 --> 00:31:15,679
and when bison is checking oh is eval

782
00:31:15,679 --> 00:31:18,960
function to set to true yes it will be

783
00:31:18,960 --> 00:31:20,559
because of the pollution

784
00:31:20,559 --> 00:31:21,919
and because

785
00:31:21,919 --> 00:31:25,600
eval function is not default defined on

786
00:31:25,600 --> 00:31:29,279
the object in bason library because if

787
00:31:29,279 --> 00:31:31,760
the basin library had a real default

788
00:31:31,760 --> 00:31:34,799
version not a per default default

789
00:31:34,799 --> 00:31:35,919
property

790
00:31:35,919 --> 00:31:37,919
meaning that if

791
00:31:37,919 --> 00:31:41,360
the option object was updated with is

792
00:31:41,360 --> 00:31:44,320
this property existing on the object yes

793
00:31:44,320 --> 00:31:47,679
no if no its value is false

794
00:31:47,679 --> 00:31:50,000
then it will not be vulnerable but what

795
00:31:50,000 --> 00:31:52,000
they do is just does this property exist

796
00:31:52,000 --> 00:31:54,320
on the object or its prototype chain

797
00:31:54,320 --> 00:31:56,399
because it's easy to do and because of

798
00:31:56,399 --> 00:31:57,840
the prototype pollution you could do

799
00:31:57,840 --> 00:32:00,799
that so basically the outcome

800
00:32:00,799 --> 00:32:03,279
run arbitrary javascript code on the

801
00:32:03,279 --> 00:32:06,080
node.js server once again you can call

802
00:32:06,080 --> 00:32:08,960
any node.js module fork

803
00:32:08,960 --> 00:32:11,679
start spawn a shell do whatever you want

804
00:32:11,679 --> 00:32:15,519
that's that's your sce

805
00:32:15,519 --> 00:32:18,080
and that's a terrible slide ordering for

806
00:32:18,080 --> 00:32:20,559
me i'm so sorry let's go back to the

807
00:32:20,559 --> 00:32:24,080
cubana one for one sec

808
00:32:24,320 --> 00:32:27,200
oh we think that node does not allow the

809
00:32:27,200 --> 00:32:29,919
dash e in node options anymore

810
00:32:29,919 --> 00:32:32,080
so you can't evolve keyboard as fixed

811
00:32:32,080 --> 00:32:33,760
you can check the

812
00:32:33,760 --> 00:32:35,039
report

813
00:32:35,039 --> 00:32:36,480
sorry about that

814
00:32:36,480 --> 00:32:39,279
how to prevent

815
00:32:39,679 --> 00:32:42,320
well remember that our merge function in

816
00:32:42,320 --> 00:32:43,760
herck

817
00:32:43,760 --> 00:32:45,360
here is the fix

818
00:32:45,360 --> 00:32:47,039
basically

819
00:32:47,039 --> 00:32:50,399
we just needed to prevent the property

820
00:32:50,399 --> 00:32:52,960
proto to be taken in account and that

821
00:32:52,960 --> 00:32:54,720
was good enough because at the only

822
00:32:54,720 --> 00:32:57,760
vulnerable path to herc herc was not

823
00:32:57,760 --> 00:33:00,279
vulnerable to the prototype dot

824
00:33:00,279 --> 00:33:03,039
constructor.prototype path

825
00:33:03,039 --> 00:33:03,919
so

826
00:33:03,919 --> 00:33:06,080
there are other ways

827
00:33:06,080 --> 00:33:08,159
when you call an object in javascript

828
00:33:08,159 --> 00:33:10,880
when you call a property it's a good

829
00:33:10,880 --> 00:33:13,039
practice to actually check if the

830
00:33:13,039 --> 00:33:16,320
property exists on the object directly

831
00:33:16,320 --> 00:33:19,360
that's why we have has on property

832
00:33:19,360 --> 00:33:20,960
and you can make sure that the property

833
00:33:20,960 --> 00:33:24,880
is actually not inherited

834
00:33:24,880 --> 00:33:27,120
and there's an alternative

835
00:33:27,120 --> 00:33:29,679
you can actually create objects that

836
00:33:29,679 --> 00:33:32,880
won't have a prototype at all so null

837
00:33:32,880 --> 00:33:34,480
despite being an object does not have a

838
00:33:34,480 --> 00:33:36,159
prototype

839
00:33:36,159 --> 00:33:38,080
and you've got a method called

840
00:33:38,080 --> 00:33:41,200
object.create that takes a prototype as

841
00:33:41,200 --> 00:33:43,919
an argument and create a new object

842
00:33:43,919 --> 00:33:47,120
with the argument as a prototype

843
00:33:47,120 --> 00:33:50,000
so let's take our example again and here

844
00:33:50,000 --> 00:33:53,279
i create a with object that creates

845
00:33:53,279 --> 00:33:54,640
null

846
00:33:54,640 --> 00:33:56,960
so we run the attack

847
00:33:56,960 --> 00:33:59,760
and a is actually

848
00:33:59,760 --> 00:34:02,559
not vulnerable to this attack because it

849
00:34:02,559 --> 00:34:04,559
just doesn't have a prototype so there's

850
00:34:04,559 --> 00:34:06,399
nothing to pollute

851
00:34:06,399 --> 00:34:09,359
but there's there's a drawback is that i

852
00:34:09,359 --> 00:34:12,399
can't call has on property or the usual

853
00:34:12,399 --> 00:34:15,760
methods of the objects in javascript

854
00:34:15,760 --> 00:34:17,440
because they're generated from the

855
00:34:17,440 --> 00:34:20,839
object prototype

856
00:34:22,480 --> 00:34:24,239
i think one of the

857
00:34:24,239 --> 00:34:26,639
main way to prevent prototype pollution

858
00:34:26,639 --> 00:34:27,599
and that's actually pretty

859
00:34:27,599 --> 00:34:28,960
straightforward

860
00:34:28,960 --> 00:34:32,159
is data validation and sanitization

861
00:34:32,159 --> 00:34:35,199
just to make sure that the objects that

862
00:34:35,199 --> 00:34:37,599
are coming from the user that are by

863
00:34:37,599 --> 00:34:39,918
definition interested

864
00:34:39,918 --> 00:34:42,480
don't contain properties you're not

865
00:34:42,480 --> 00:34:43,599
expecting

866
00:34:43,599 --> 00:34:45,918
so there's a very very very cool library

867
00:34:45,918 --> 00:34:48,480
named joy for that and you define the

868
00:34:48,480 --> 00:34:51,440
shape of the object even the size of the

869
00:34:51,440 --> 00:34:53,679
integers on it regex to validate

870
00:34:53,679 --> 00:34:55,918
properties whatever you want it's a very

871
00:34:55,918 --> 00:34:58,400
good library to do proper type and

872
00:34:58,400 --> 00:35:01,440
validation on objects in javascript and

873
00:35:01,440 --> 00:35:04,079
by default it will prevent objects from

874
00:35:04,079 --> 00:35:08,880
having and and unplanned properties so

875
00:35:08,880 --> 00:35:11,200
shape your object and if properties are

876
00:35:11,200 --> 00:35:12,640
not expected

877
00:35:12,640 --> 00:35:15,440
they will be marked as invalid which is

878
00:35:15,440 --> 00:35:17,280
pretty cool

879
00:35:17,280 --> 00:35:18,640
sidenote

880
00:35:18,640 --> 00:35:20,720
object decentralization is timeless in

881
00:35:20,720 --> 00:35:24,480
javascript it's mostly json.pass and

882
00:35:24,480 --> 00:35:26,880
that opens the door to a lot of other

883
00:35:26,880 --> 00:35:30,800
issues over object injections one of the

884
00:35:30,800 --> 00:35:31,680
most

885
00:35:31,680 --> 00:35:34,960
impacting one is nosql injections

886
00:35:34,960 --> 00:35:36,560
you you can check my previous stroke

887
00:35:36,560 --> 00:35:39,200
just google my name and mongodb and

888
00:35:39,200 --> 00:35:41,280
you'll see a few talks on the topic if

889
00:35:41,280 --> 00:35:43,760
you're interested

890
00:35:43,760 --> 00:35:45,119
so

891
00:35:45,119 --> 00:35:47,440
that that's the conclusion now

892
00:35:47,440 --> 00:35:49,839
what do i think now what do i think four

893
00:35:49,839 --> 00:35:52,640
years later almost 200

894
00:35:52,640 --> 00:35:55,359
published vulnerabilities later

895
00:35:55,359 --> 00:35:58,720
did we open the pandora box or did we do

896
00:35:58,720 --> 00:36:00,480
the right thing

897
00:36:00,480 --> 00:36:01,839
well

898
00:36:01,839 --> 00:36:03,920
during the process of accepting the

899
00:36:03,920 --> 00:36:05,599
first prototype pollution report there

900
00:36:05,599 --> 00:36:07,920
was a lot of uncertainty

901
00:36:07,920 --> 00:36:10,880
i think we were good because we involved

902
00:36:10,880 --> 00:36:13,119
other people we trusted

903
00:36:13,119 --> 00:36:15,119
including community leaders as

904
00:36:15,119 --> 00:36:18,000
maintainers so we did not stay as a

905
00:36:18,000 --> 00:36:20,880
close mind team especially important

906
00:36:20,880 --> 00:36:24,000
because in that triage team under

907
00:36:24,000 --> 00:36:25,440
burgbunti

908
00:36:25,440 --> 00:36:27,920
i think i was the only one working full

909
00:36:27,920 --> 00:36:30,400
time no lyranto there was only two of us

910
00:36:30,400 --> 00:36:32,560
working full-time on application

911
00:36:32,560 --> 00:36:34,800
security and the other one were just

912
00:36:34,800 --> 00:36:37,440
node.js developers with

913
00:36:37,440 --> 00:36:39,359
no professional background in security

914
00:36:39,359 --> 00:36:40,560
especially

915
00:36:40,560 --> 00:36:42,320
so we did i think we did the right thing

916
00:36:42,320 --> 00:36:45,440
by gathering uh group intelligence on

917
00:36:45,440 --> 00:36:46,560
that

918
00:36:46,560 --> 00:36:47,920
uh

919
00:36:47,920 --> 00:36:50,320
i think we were fair in expecting an

920
00:36:50,320 --> 00:36:53,359
example of exploit saying hey okay that

921
00:36:53,359 --> 00:36:55,440
brand new that makes sense

922
00:36:55,440 --> 00:36:57,680
can you demonstrate that it can have a

923
00:36:57,680 --> 00:37:00,320
real life impact on an application that

924
00:37:00,320 --> 00:37:02,160
would help us a lot

925
00:37:02,160 --> 00:37:04,720
and try to link

926
00:37:04,720 --> 00:37:07,599
to as little as much literature we can

927
00:37:07,599 --> 00:37:09,599
even if it was just finding the right

928
00:37:09,599 --> 00:37:11,200
cwe

929
00:37:11,200 --> 00:37:12,800
um

930
00:37:12,800 --> 00:37:15,440
i think we missed a few opportunities

931
00:37:15,440 --> 00:37:17,200
under process 2

932
00:37:17,200 --> 00:37:20,000
because we had a brand new

933
00:37:20,000 --> 00:37:21,680
vulnerability class

934
00:37:21,680 --> 00:37:24,000
we knew it was largely impacting

935
00:37:24,000 --> 00:37:26,560
javascript as an ecosystem and we did

936
00:37:26,560 --> 00:37:29,040
not do what we should have done which is

937
00:37:29,040 --> 00:37:32,079
sit together with the node.js core team

938
00:37:32,079 --> 00:37:33,520
and say hey

939
00:37:33,520 --> 00:37:35,920
we need to compute the threat model and

940
00:37:35,920 --> 00:37:38,480
evaluate if there are something in node

941
00:37:38,480 --> 00:37:40,560
that could be

942
00:37:40,560 --> 00:37:43,200
abused over prototype pollution and

943
00:37:43,200 --> 00:37:45,440
maybe we would have found the kibana

944
00:37:45,440 --> 00:37:48,240
case one year before it was published

945
00:37:48,240 --> 00:37:51,520
by saying hey look you can redefine

946
00:37:51,520 --> 00:37:53,920
environment variables

947
00:37:53,920 --> 00:37:55,520
maybe

948
00:37:55,520 --> 00:37:57,119
and i think i was really bad on

949
00:37:57,119 --> 00:37:58,640
communication

950
00:37:58,640 --> 00:38:01,119
i let olivier gave the talks on that

951
00:38:01,119 --> 00:38:03,200
which is fair he was the one who found

952
00:38:03,200 --> 00:38:06,720
the vulnerabilities uh fun thing uh the

953
00:38:06,720 --> 00:38:08,720
next year at uh

954
00:38:08,720 --> 00:38:10,560
west california i was giving a talk

955
00:38:10,560 --> 00:38:11,599
about

956
00:38:11,599 --> 00:38:13,599
node.js security model and it was in the

957
00:38:13,599 --> 00:38:15,200
next room giving a talk about prototype

958
00:38:15,200 --> 00:38:16,839
pollution

959
00:38:16,839 --> 00:38:19,119
um and

960
00:38:19,119 --> 00:38:21,280
olivier moved to something else after

961
00:38:21,280 --> 00:38:23,200
because he's a security researcher and

962
00:38:23,200 --> 00:38:26,079
we probably should have uh run that bike

963
00:38:26,079 --> 00:38:28,640
as community leader and security leaders

964
00:38:28,640 --> 00:38:31,200
in the javascript ecosystem evangelize

965
00:38:31,200 --> 00:38:33,359
that's actually my first talk ever on

966
00:38:33,359 --> 00:38:35,440
prototype pollution and i think that's a

967
00:38:35,440 --> 00:38:38,079
missed opportunity on my side

968
00:38:38,079 --> 00:38:40,880
for the fun story a couple years ago

969
00:38:40,880 --> 00:38:42,320
someone tried to tell me there's a

970
00:38:42,320 --> 00:38:44,320
prototype pollution in my code and i

971
00:38:44,320 --> 00:38:47,200
demonstrate that it was unexploitable

972
00:38:47,200 --> 00:38:47,920
but

973
00:38:47,920 --> 00:38:49,359
sometimes you know

974
00:38:49,359 --> 00:38:53,040
um conclusion uh what now monitor

975
00:38:53,040 --> 00:38:56,000
incoming objects don't let proto or

976
00:38:56,000 --> 00:38:59,040
constructors come inside your hip from

977
00:38:59,040 --> 00:39:01,200
outside objects

978
00:39:01,200 --> 00:39:03,200
there's an option in node.js to disable

979
00:39:03,200 --> 00:39:06,320
proto altogether use at your own risk it

980
00:39:06,320 --> 00:39:07,119
might

981
00:39:07,119 --> 00:39:08,960
break some of your libraries

982
00:39:08,960 --> 00:39:09,680
but

983
00:39:09,680 --> 00:39:12,320
a good a good thing with same grip will

984
00:39:12,320 --> 00:39:14,560
help you know if you're if your code

985
00:39:14,560 --> 00:39:16,960
base or their dependencies actually use

986
00:39:16,960 --> 00:39:18,480
underscore underscore proto underscore

987
00:39:18,480 --> 00:39:20,320
underscore i'm saying i'm mentioning

988
00:39:20,320 --> 00:39:21,760
some rep not only because you're in the

989
00:39:21,760 --> 00:39:23,520
room

990
00:39:23,520 --> 00:39:26,960
and enforce sanitization and prototype

991
00:39:26,960 --> 00:39:30,240
less objects

992
00:39:30,240 --> 00:39:33,200
a few links

993
00:39:34,079 --> 00:39:36,400
the two last ones are actually my

994
00:39:36,400 --> 00:39:38,960
classes if you want to deep dive into

995
00:39:38,960 --> 00:39:40,480
that

996
00:39:40,480 --> 00:39:43,040
the one that's here pollute me it's

997
00:39:43,040 --> 00:39:45,040
actually a github repo

998
00:39:45,040 --> 00:39:47,520
where i have written a vulnerable code

999
00:39:47,520 --> 00:39:50,640
base you can download it start the

1000
00:39:50,640 --> 00:39:51,680
docker

1001
00:39:51,680 --> 00:39:54,480
repo and try to exploit it i did that in

1002
00:39:54,480 --> 00:39:57,119
10 minutes yesterday so maybe it's not

1003
00:39:57,119 --> 00:39:59,599
very good feel free to provide feedback

1004
00:39:59,599 --> 00:40:01,440
uh reach out on twitter if you want the

1005
00:40:01,440 --> 00:40:04,160
slides because i always forget to upload

1006
00:40:04,160 --> 00:40:06,480
them between jet lag and busy conference

1007
00:40:06,480 --> 00:40:10,400
time and the two first links are our

1008
00:40:10,400 --> 00:40:14,480
report the first one uh i think it's the

1009
00:40:14,480 --> 00:40:17,280
yeah it's the kth paper and the second

1010
00:40:17,280 --> 00:40:22,000
one is actually uh the sc in kibana

1011
00:40:22,000 --> 00:40:23,200
i think

1012
00:40:23,200 --> 00:40:28,079
i have time for some questions now

1013
00:40:28,079 --> 00:40:31,079
yes

1014
00:40:49,520 --> 00:40:51,359
so the question

1015
00:40:51,359 --> 00:40:53,599
is did we do any research to see if

1016
00:40:53,599 --> 00:40:55,680
other languages were very variable to a

1017
00:40:55,680 --> 00:40:58,640
similar class of attacks

1018
00:40:58,640 --> 00:41:01,119
i'm not aware of that and i was actually

1019
00:41:01,119 --> 00:41:02,880
reading the page about prototype

1020
00:41:02,880 --> 00:41:04,640
oriented programming this morning it was

1021
00:41:04,640 --> 00:41:06,319
like oh there's at least a few of the

1022
00:41:06,319 --> 00:41:08,240
prototype oriented languages that's

1023
00:41:08,240 --> 00:41:09,920
probably worth

1024
00:41:09,920 --> 00:41:10,960
checking

1025
00:41:10,960 --> 00:41:13,440
i think depending on the way inheritance

1026
00:41:13,440 --> 00:41:15,920
is implemented in other languages it

1027
00:41:15,920 --> 00:41:18,560
might make sense on the top of my head i

1028
00:41:18,560 --> 00:41:20,640
would consider that language the trend

1029
00:41:20,640 --> 00:41:24,160
on the jvm won't be vulnerable for that

1030
00:41:24,160 --> 00:41:27,839
but that probably needs to be checked

1031
00:41:33,359 --> 00:41:36,799
you can't yeah the application

1032
00:41:38,140 --> 00:41:41,210
[Music]

1033
00:41:45,280 --> 00:41:47,440
so the question is is there a go-to

1034
00:41:47,440 --> 00:41:50,160
payload uh a cheat sheet to find them

1035
00:41:50,160 --> 00:41:52,160
and because of those

1036
00:41:52,160 --> 00:41:53,280
uh

1037
00:41:53,280 --> 00:41:55,839
i i don't know if there is a list yet i

1038
00:41:55,839 --> 00:41:59,040
actually think

1039
00:42:00,960 --> 00:42:04,000
this one that replace has on property by

1040
00:42:04,000 --> 00:42:04,960
null

1041
00:42:04,960 --> 00:42:07,839
and same thing on that one uh that

1042
00:42:07,839 --> 00:42:10,400
should do the trick and just check the

1043
00:42:10,400 --> 00:42:12,560
object prototype on ndn

1044
00:42:12,560 --> 00:42:14,880
write a script and you can use one

1045
00:42:14,880 --> 00:42:17,119
single payload to override all of these

1046
00:42:17,119 --> 00:42:19,839
values so you will soon see

1047
00:42:19,839 --> 00:42:22,800
i think you've got a 70 chance of

1048
00:42:22,800 --> 00:42:24,800
crashing the application if you manage

1049
00:42:24,800 --> 00:42:28,480
to override them so yeah

1050
00:42:28,480 --> 00:42:30,240
i i can try to upload something on

1051
00:42:30,240 --> 00:42:33,118
github later

1052
00:42:37,119 --> 00:42:39,440
why was the back bounty shutdown for

1053
00:42:39,440 --> 00:42:42,480
node ecosystem not not core

1054
00:42:42,480 --> 00:42:44,560
mostly because

1055
00:42:44,560 --> 00:42:46,960
npm was acquired by github

1056
00:42:46,960 --> 00:42:48,560
and that was the best move for the

1057
00:42:48,560 --> 00:42:52,000
javascript ecosystem and no guitar

1058
00:42:52,000 --> 00:42:54,640
also npm started to do

1059
00:42:54,640 --> 00:42:57,119
bug bounty i mean vulnerability report

1060
00:42:57,119 --> 00:43:00,640
as a feature in npm within pm edit then

1061
00:43:00,640 --> 00:43:02,960
got acquired by github that has security

1062
00:43:02,960 --> 00:43:05,200
features so it did not make sense to

1063
00:43:05,200 --> 00:43:07,680
have like an extra

1064
00:43:07,680 --> 00:43:09,440
an extra

1065
00:43:09,440 --> 00:43:12,160
initiative on that especially since we

1066
00:43:12,160 --> 00:43:14,000
were doing that on our free time and

1067
00:43:14,000 --> 00:43:16,160
people like github are paid to do that

1068
00:43:16,160 --> 00:43:18,000
so they will do it 10 times better than

1069
00:43:18,000 --> 00:43:20,319
we do

1070
00:43:34,319 --> 00:43:37,520
uh do we have uh regression testing on

1071
00:43:37,520 --> 00:43:41,119
this vulnerable project um i

1072
00:43:41,119 --> 00:43:44,640
i don't know but that's the magic

1073
00:43:44,640 --> 00:43:45,520
about

1074
00:43:45,520 --> 00:43:47,200
um

1075
00:43:47,200 --> 00:43:50,400
about fashion in the bugbunty world is

1076
00:43:50,400 --> 00:43:51,920
that

1077
00:43:51,920 --> 00:43:53,680
so when we started the ecosystem but

1078
00:43:53,680 --> 00:43:54,880
bunty

1079
00:43:54,880 --> 00:43:57,920
the first report we get was a directory

1080
00:43:57,920 --> 00:43:59,520
traversal

1081
00:43:59,520 --> 00:44:01,680
in uh application used to serve static

1082
00:44:01,680 --> 00:44:02,800
content

1083
00:44:02,800 --> 00:44:04,560
and if you check the outcome of this bug

1084
00:44:04,560 --> 00:44:07,520
boonty i think the probably the first 50

1085
00:44:07,520 --> 00:44:10,079
reports were that then when proper

1086
00:44:10,079 --> 00:44:12,240
pollution was published we had probably

1087
00:44:12,240 --> 00:44:14,319
50 reports for prototype pollution so i

1088
00:44:14,319 --> 00:44:16,319
would say that people who are getting

1089
00:44:16,319 --> 00:44:18,880
trained to get karma and hacker1 are the

1090
00:44:18,880 --> 00:44:20,960
regression testing for that

1091
00:44:20,960 --> 00:44:23,839
if i may

1092
00:44:38,720 --> 00:44:39,680
um

1093
00:44:39,680 --> 00:44:41,520
if i rephrase

1094
00:44:41,520 --> 00:44:47,000
does googling search the code base now

1095
00:44:58,720 --> 00:45:00,240
um

1096
00:45:00,240 --> 00:45:03,200
i i i don't think we will online we've

1097
00:45:03,200 --> 00:45:05,119
been using that at all

1098
00:45:05,119 --> 00:45:06,720
i was actually discussing with two

1099
00:45:06,720 --> 00:45:08,800
people in this room earlier today

1100
00:45:08,800 --> 00:45:10,560
about the fact that this kind of attacks

1101
00:45:10,560 --> 00:45:12,640
are really hard to find a stat with

1102
00:45:12,640 --> 00:45:14,800
static analysis

1103
00:45:14,800 --> 00:45:17,280
if you read the kth paper

1104
00:45:17,280 --> 00:45:19,359
one of the point is that

1105
00:45:19,359 --> 00:45:21,280
they had a lot of false positives if i

1106
00:45:21,280 --> 00:45:23,280
remember properly don't misquote me on

1107
00:45:23,280 --> 00:45:24,079
that

1108
00:45:24,079 --> 00:45:25,520
they had a lot of false positive and

1109
00:45:25,520 --> 00:45:28,400
study static analysis

1110
00:45:28,400 --> 00:45:31,280
so i don't have a i don't think scanning

1111
00:45:31,280 --> 00:45:35,760
works yet for this class of attacks

1112
00:45:38,160 --> 00:45:40,319
okay if there are no more questions feel

1113
00:45:40,319 --> 00:45:42,560
free to follow me on twitter

1114
00:45:42,560 --> 00:45:45,119
ping me provide feedback i'm looking for

1115
00:45:45,119 --> 00:45:47,200
them too and ask for the slides and

1116
00:45:47,200 --> 00:45:48,640
thanks so much for being an amazing

1117
00:45:48,640 --> 00:45:51,640
crowd

1118
00:45:52,260 --> 00:45:55,159
[Applause]

