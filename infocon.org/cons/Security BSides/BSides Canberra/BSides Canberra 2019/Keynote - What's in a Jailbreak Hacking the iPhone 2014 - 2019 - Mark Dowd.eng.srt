1
00:00:01,600 --> 00:00:06,740
amazing keynote this morning we have

2
00:00:04,359 --> 00:00:09,710
such a privilege to have this speaker

3
00:00:06,740 --> 00:00:11,840
I'm talking to you guys and the keynote

4
00:00:09,710 --> 00:00:15,740
is about what's in a jailbreak hacking

5
00:00:11,840 --> 00:00:18,529
the iPhone 2014 to 2019 onwards with

6
00:00:15,740 --> 00:00:20,300
marked out and a lot of you probably

7
00:00:18,529 --> 00:00:22,300
have heard of mark there but mark dad is

8
00:00:20,300 --> 00:00:24,769
an expert in application security

9
00:00:22,300 --> 00:00:26,569
specializing primarily in low-level

10
00:00:24,769 --> 00:00:28,788
operating system vulnerability research

11
00:00:26,569 --> 00:00:31,130
for both desktops and popular mobile

12
00:00:28,789 --> 00:00:33,739
devices he is currently the director of

13
00:00:31,130 --> 00:00:35,329
azimuth security now l3 trenchant a

14
00:00:33,739 --> 00:00:37,038
security company founder that

15
00:00:35,329 --> 00:00:39,410
specializes in code review and

16
00:00:37,039 --> 00:00:40,969
cutting-edge security research prior to

17
00:00:39,410 --> 00:00:42,828
citing azimuth his professional

18
00:00:40,969 --> 00:00:44,480
experience includes several years as a

19
00:00:42,829 --> 00:00:46,910
senior researcher at a fortune 500

20
00:00:44,480 --> 00:00:48,678
company where he uncovered a variety of

21
00:00:46,910 --> 00:00:51,709
major vulnerabilities in ubiquitous

22
00:00:48,679 --> 00:00:53,510
Internet software he's also worked as a

23
00:00:51,710 --> 00:00:55,640
principal security architect for McAfee

24
00:00:53,510 --> 00:00:57,140
where he was responsible for internal

25
00:00:55,640 --> 00:01:00,219
code audits secure programming classes

26
00:00:57,140 --> 00:01:02,749
and undertaking new security initiatives

27
00:01:00,219 --> 00:01:04,580
markers also co-authored a book a very

28
00:01:02,749 --> 00:01:06,110
very well-known book actually on the

29
00:01:04,580 --> 00:01:08,120
subject of application security named

30
00:01:06,110 --> 00:01:09,550
the art of software security assessment

31
00:01:08,120 --> 00:01:12,350
and has spoken at several

32
00:01:09,550 --> 00:01:15,170
industry-recognized conferences this bio

33
00:01:12,350 --> 00:01:16,970
really doesn't give him justice but can

34
00:01:15,170 --> 00:01:19,180
we please welcome mark the out to the

35
00:01:16,970 --> 00:01:19,179
stage

36
00:01:23,290 --> 00:01:30,190
I think Sylvio so as Silvie I mentioned

37
00:01:28,540 --> 00:01:32,520
my name's marked out I'm going to be

38
00:01:30,190 --> 00:01:35,320
talking about what's in a jailbreak and

39
00:01:32,520 --> 00:01:37,479
essentially in this talk I want to

40
00:01:35,320 --> 00:01:40,630
basically go through the components that

41
00:01:37,480 --> 00:01:43,870
make up a typical jailbreak I'm going to

42
00:01:40,630 --> 00:01:47,280
be focusing on browser-based remote

43
00:01:43,870 --> 00:01:50,560
jailbreaks in the in the intro in the

44
00:01:47,280 --> 00:01:52,690
abstract I wanted to also mention that I

45
00:01:50,560 --> 00:01:55,420
was also going to go through usb-based

46
00:01:52,690 --> 00:01:56,800
ones but I quickly realized that that

47
00:01:55,420 --> 00:01:59,530
was going to take two and a half hours

48
00:01:56,800 --> 00:02:02,110
if I did that so I'm basically going to

49
00:01:59,530 --> 00:02:04,150
have to do two talks I suppose

50
00:02:02,110 --> 00:02:06,010
sílvio introduced me already so I don't

51
00:02:04,150 --> 00:02:07,440
need to go through this I would like to

52
00:02:06,010 --> 00:02:12,100
point out that I've rescued several

53
00:02:07,440 --> 00:02:13,900
people from Apple though so that they've

54
00:02:12,100 --> 00:02:17,620
been a great help for putting this

55
00:02:13,900 --> 00:02:20,140
speech together so the reason I wanted

56
00:02:17,620 --> 00:02:23,050
to talk about iPhone jailbreaking is you

57
00:02:20,140 --> 00:02:25,119
hear a lot about it there's a lot of you

58
00:02:23,050 --> 00:02:28,270
know jailbreaks are released to great

59
00:02:25,120 --> 00:02:30,400
fanfare and also you sees the Rodian

60
00:02:28,270 --> 00:02:32,890
bounties and they're offering millions

61
00:02:30,400 --> 00:02:35,470
of dollars for for a complete iPhone

62
00:02:32,890 --> 00:02:38,619
jailbreak and for people that are not as

63
00:02:35,470 --> 00:02:41,290
familiar with with how jailbreaks work

64
00:02:38,620 --> 00:02:44,530
this seems like a crazy amount of money

65
00:02:41,290 --> 00:02:48,390
and fanfare but I basically want to show

66
00:02:44,530 --> 00:02:51,459
that it's it's actually pretty difficult

67
00:02:48,390 --> 00:02:53,768
so when we talk about iOS jailbreaking

68
00:02:51,459 --> 00:02:55,420
we're talking about the removing of

69
00:02:53,769 --> 00:02:58,000
software and strict restrictions imposed

70
00:02:55,420 --> 00:03:00,100
by iOS which is Apple's operating system

71
00:02:58,000 --> 00:03:03,370
on devices running it through the use of

72
00:03:00,100 --> 00:03:05,410
software exploits and it's always been

73
00:03:03,370 --> 00:03:07,480
quite difficult but over the past five

74
00:03:05,410 --> 00:03:10,120
years and in the past two years in

75
00:03:07,480 --> 00:03:15,179
particular it's their bracelet bar quite

76
00:03:10,120 --> 00:03:19,690
significantly so in order to in order to

77
00:03:15,180 --> 00:03:21,970
talk about the anatomy of a jailbreak I

78
00:03:19,690 --> 00:03:24,070
sort of have to cover a little bit about

79
00:03:21,970 --> 00:03:26,410
the iPhone security model in general

80
00:03:24,070 --> 00:03:29,769
this is a topic that's sort of been

81
00:03:26,410 --> 00:03:32,569
covered a lot in the past however if

82
00:03:29,769 --> 00:03:34,370
you're a bit unfamiliar with it then

83
00:03:32,569 --> 00:03:36,738
the anatomy of a jailbreak wouldn't make

84
00:03:34,370 --> 00:03:38,689
much sense after that I'm going to go

85
00:03:36,739 --> 00:03:40,760
through a practical example which was

86
00:03:38,689 --> 00:03:46,219
the Pegasus jailbreak found in the wild

87
00:03:40,760 --> 00:03:49,099
and then the post Pegasus world which so

88
00:03:46,219 --> 00:03:52,840
Pegasus was found in iOS 9 and this is I

89
00:03:49,099 --> 00:03:58,429
don't know why this is going without me

90
00:03:52,840 --> 00:04:01,099
going from iOS to iOS 12 so we start off

91
00:03:58,430 --> 00:04:05,060
with the Apple security model basically

92
00:04:01,099 --> 00:04:06,738
I've identified the elements that I

93
00:04:05,060 --> 00:04:09,230
consider quarter apples security model

94
00:04:06,739 --> 00:04:11,359
which is code integrity isolation

95
00:04:09,230 --> 00:04:13,480
exploit mitigations and something that

96
00:04:11,359 --> 00:04:16,489
I've called environment preservation

97
00:04:13,480 --> 00:04:18,738
encryption and strong encryption and

98
00:04:16,488 --> 00:04:21,198
data privacy is also a large part of I

99
00:04:18,738 --> 00:04:22,969
phone security but it's not really

100
00:04:21,199 --> 00:04:26,090
relevant to remote jail breaks it's more

101
00:04:22,970 --> 00:04:27,320
relevant to the USB style attacks and so

102
00:04:26,090 --> 00:04:29,359
I'm not really going to cover that here

103
00:04:27,320 --> 00:04:31,400
but anyone that's interested should go

104
00:04:29,360 --> 00:04:33,259
and read Ivan Kerr sticks talk which is

105
00:04:31,400 --> 00:04:38,000
really excellent and covers it in great

106
00:04:33,259 --> 00:04:40,669
depth so with code integrity basically

107
00:04:38,000 --> 00:04:42,560
the idea with the iPhone ecosystem is

108
00:04:40,669 --> 00:04:45,770
that only Apple approved code is ever

109
00:04:42,560 --> 00:04:48,020
run on the system and this is quite a

110
00:04:45,770 --> 00:04:50,180
quite an impressive feat really and to

111
00:04:48,020 --> 00:04:52,729
achieve it they do a multi-pronged

112
00:04:50,180 --> 00:04:55,520
approach they have a trusted boot chain

113
00:04:52,729 --> 00:04:57,620
because if you're if you can't basically

114
00:04:55,520 --> 00:04:59,330
Trust your kernel or anything below it

115
00:04:57,620 --> 00:05:02,060
then you can't really trust the rest of

116
00:04:59,330 --> 00:05:04,190
the operating system at all and then

117
00:05:02,060 --> 00:05:06,169
following that they have user mode

118
00:05:04,190 --> 00:05:07,909
integrity essentially every single

119
00:05:06,169 --> 00:05:12,109
application that's run on an iPhone is

120
00:05:07,909 --> 00:05:14,030
signed by Apple and and then there's

121
00:05:12,110 --> 00:05:17,449
runtime integrity which is some

122
00:05:14,030 --> 00:05:22,880
additional security security features

123
00:05:17,449 --> 00:05:24,710
about the iPhone iOS runtime so with

124
00:05:22,880 --> 00:05:27,590
boot integrity this is a simplified

125
00:05:24,710 --> 00:05:29,448
version of what an iPhone what the

126
00:05:27,590 --> 00:05:31,580
iPhone boot chain looks like I say

127
00:05:29,449 --> 00:05:33,169
simplified because it doesn't account

128
00:05:31,580 --> 00:05:35,060
for some of the things that again are

129
00:05:33,169 --> 00:05:38,060
more relevant to USB such as the saffron

130
00:05:35,060 --> 00:05:40,669
SEP and booting to Deere for your

131
00:05:38,060 --> 00:05:44,880
recovery mode but for basically booting

132
00:05:40,669 --> 00:05:46,650
to iOS you have wrong which has the

133
00:05:44,880 --> 00:05:48,960
establishes a root of trust with apples

134
00:05:46,650 --> 00:05:51,419
certificate because it's immutable they

135
00:05:48,960 --> 00:05:53,430
can embed their certificate and they can

136
00:05:51,420 --> 00:05:55,890
know it's trusted and then each

137
00:05:53,430 --> 00:05:59,280
additional stage up until you load the

138
00:05:55,890 --> 00:06:02,430
iOS kernel each additional stage

139
00:05:59,280 --> 00:06:07,349
cryptographically verifies the stage

140
00:06:02,430 --> 00:06:08,610
before it so that each stage can be can

141
00:06:07,350 --> 00:06:11,930
be validated that it hasn't been

142
00:06:08,610 --> 00:06:11,930
modified by anyone

143
00:06:12,990 --> 00:06:18,600
user mode integrity like I said all user

144
00:06:15,870 --> 00:06:20,430
mode binaries are signed by Apple and by

145
00:06:18,600 --> 00:06:22,880
that essentially we mean all binaries

146
00:06:20,430 --> 00:06:25,440
contain a code signature that is

147
00:06:22,880 --> 00:06:28,040
cryptographically verified by the kernel

148
00:06:25,440 --> 00:06:31,080
or by a user mode service called MF ID

149
00:06:28,040 --> 00:06:32,610
which is trusted by Apple the code

150
00:06:31,080 --> 00:06:35,990
signature essentially contains

151
00:06:32,610 --> 00:06:38,820
information about the executable and

152
00:06:35,990 --> 00:06:41,370
most importantly a list of hashes about

153
00:06:38,820 --> 00:06:45,150
every page from the binary that's that

154
00:06:41,370 --> 00:06:46,920
gets mapped in and and then also

155
00:06:45,150 --> 00:06:48,330
entitlements granted to that binary

156
00:06:46,920 --> 00:06:56,160
which is something that we'll be

157
00:06:48,330 --> 00:07:00,510
discussing later so we have two methods

158
00:06:56,160 --> 00:07:01,860
for verifying binaries now the mechanics

159
00:07:00,510 --> 00:07:04,170
of how this works is not really

160
00:07:01,860 --> 00:07:06,630
important for this talk so I'm not

161
00:07:04,170 --> 00:07:08,640
really going to talk about it here but

162
00:07:06,630 --> 00:07:09,690
essentially I wanted to put it on the

163
00:07:08,640 --> 00:07:15,960
slide deck for people that are

164
00:07:09,690 --> 00:07:18,060
interested in following that up so after

165
00:07:15,960 --> 00:07:20,580
that we have runtime integrity so

166
00:07:18,060 --> 00:07:22,980
basically if you could just map

167
00:07:20,580 --> 00:07:25,530
readwrite executable memory and execute

168
00:07:22,980 --> 00:07:27,980
whatever code you like then essentially

169
00:07:25,530 --> 00:07:30,090
having all the verification of the

170
00:07:27,980 --> 00:07:32,670
binaries and all that kind of thing is

171
00:07:30,090 --> 00:07:35,070
not very valuable so the runtime

172
00:07:32,670 --> 00:07:40,170
integrity basically disallows read write

173
00:07:35,070 --> 00:07:42,120
execute mappings execute executable code

174
00:07:40,170 --> 00:07:44,970
must belong to something with a valid

175
00:07:42,120 --> 00:07:47,220
code directory and then they've done

176
00:07:44,970 --> 00:07:51,090
some additional runtime security checks

177
00:07:47,220 --> 00:07:52,979
to prevent you from doing some other

178
00:07:51,090 --> 00:07:54,840
things at runtime these were things that

179
00:07:52,979 --> 00:07:57,120
were introduced over time because of the

180
00:07:54,840 --> 00:07:59,349
result of jail breaks

181
00:07:57,120 --> 00:08:02,950
so the next thing we're talking about is

182
00:07:59,350 --> 00:08:07,360
isolation goals so essentially we want

183
00:08:02,950 --> 00:08:08,710
to prevent prevent compromised

184
00:08:07,360 --> 00:08:10,480
applications from being able to

185
00:08:08,710 --> 00:08:12,520
adversely affect the system so we want

186
00:08:10,480 --> 00:08:16,750
to sandbox them reduce the attack

187
00:08:12,520 --> 00:08:19,859
surface and enforce granular control

188
00:08:16,750 --> 00:08:22,540
over this over system resources so

189
00:08:19,860 --> 00:08:26,500
there's basically three factors that

190
00:08:22,540 --> 00:08:28,440
govern how an application is isolated it

191
00:08:26,500 --> 00:08:31,480
depends on the user running the system

192
00:08:28,440 --> 00:08:33,220
it depends on the entitlements granted

193
00:08:31,480 --> 00:08:35,860
to that application and it depends on

194
00:08:33,220 --> 00:08:40,720
the sandbox in restrictions imposed on

195
00:08:35,860 --> 00:08:42,270
it user is either route or mobile iPhone

196
00:08:40,720 --> 00:08:45,400
is essentially a to use a UNIX system

197
00:08:42,270 --> 00:08:48,689
most things run as mobile a couple of

198
00:08:45,400 --> 00:08:51,310
things run as route like system services

199
00:08:48,690 --> 00:08:53,320
entitlements special privileges that are

200
00:08:51,310 --> 00:08:55,390
granted to the application

201
00:08:53,320 --> 00:08:57,010
that'll that allow them to do something

202
00:08:55,390 --> 00:08:59,580
that isn't allowed by the system or

203
00:08:57,010 --> 00:09:02,020
isn't allowed by that particular user

204
00:08:59,580 --> 00:09:04,180
entitlements are immutable and they

205
00:09:02,020 --> 00:09:06,069
can't be modified at runtime so the

206
00:09:04,180 --> 00:09:07,810
entitlements that are present in the

207
00:09:06,070 --> 00:09:11,050
code signature is what that application

208
00:09:07,810 --> 00:09:13,660
has and that's it so this is some

209
00:09:11,050 --> 00:09:15,490
examples of entitlements and really the

210
00:09:13,660 --> 00:09:16,900
there's tons of them but the only one

211
00:09:15,490 --> 00:09:18,790
that really matters for us in the

212
00:09:16,900 --> 00:09:20,590
context of web shell breaks this dynamic

213
00:09:18,790 --> 00:09:22,719
code signing which is a special

214
00:09:20,590 --> 00:09:25,300
permission that allows you to map read

215
00:09:22,720 --> 00:09:27,910
write executable memory once in the

216
00:09:25,300 --> 00:09:31,089
lifetime of a process and specifically

217
00:09:27,910 --> 00:09:36,370
the web browser does it for dynamic

218
00:09:31,090 --> 00:09:40,990
generation of JIT code lastly we have

219
00:09:36,370 --> 00:09:44,110
isolation so obviously iOS has quite a

220
00:09:40,990 --> 00:09:47,470
robust sandbox nearly any resource that

221
00:09:44,110 --> 00:09:50,170
you want to access from the system is

222
00:09:47,470 --> 00:09:53,530
the request is proxied through the

223
00:09:50,170 --> 00:09:56,740
sandbox the sandbox kernel extension and

224
00:09:53,530 --> 00:10:00,030
it decides what you're allowed to access

225
00:09:56,740 --> 00:10:03,220
and that's based on a sandbox policy

226
00:10:00,030 --> 00:10:04,839
most App Store apps have a standardized

227
00:10:03,220 --> 00:10:06,850
app profile that only allowed them to

228
00:10:04,840 --> 00:10:10,750
access you know basically their

229
00:10:06,850 --> 00:10:13,120
container and system applications

230
00:10:10,750 --> 00:10:15,040
typically have their own sandbox which

231
00:10:13,120 --> 00:10:18,010
is based on a built-in profile that's

232
00:10:15,040 --> 00:10:20,199
bundled with in iOS there's actually a

233
00:10:18,010 --> 00:10:22,990
really excellent talk about about Sam

234
00:10:20,200 --> 00:10:24,850
boxing and the mechanics of it by

235
00:10:22,990 --> 00:10:27,510
Jonathan Levin which I've put the link

236
00:10:24,850 --> 00:10:27,510
up to there

237
00:10:28,330 --> 00:10:34,330
so essentially entitlements as Sam

238
00:10:32,980 --> 00:10:36,340
boxing is something that restricts

239
00:10:34,330 --> 00:10:38,350
access that the user would normally have

240
00:10:36,340 --> 00:10:41,320
and entitlements is something that

241
00:10:38,350 --> 00:10:43,060
permit access the the user or or no one

242
00:10:41,320 --> 00:10:51,000
would normally have such as being able

243
00:10:43,060 --> 00:10:54,430
to map executable memory okay so

244
00:10:51,000 --> 00:10:58,990
obviously um like any contemporary

245
00:10:54,430 --> 00:11:01,510
operating system iPhone has a gamut of

246
00:10:58,990 --> 00:11:04,570
exploit mitigations that have become

247
00:11:01,510 --> 00:11:07,630
increasingly complicated over there over

248
00:11:04,570 --> 00:11:09,400
the over the last few years and the idea

249
00:11:07,630 --> 00:11:13,030
is to prevent them from being reliably

250
00:11:09,400 --> 00:11:16,180
exploitable prevent vulnerabilities from

251
00:11:13,030 --> 00:11:18,069
being reliably exploitable I've sort of

252
00:11:16,180 --> 00:11:20,469
talked about before early stage

253
00:11:18,070 --> 00:11:24,160
mitigations which ones that attempt to

254
00:11:20,470 --> 00:11:27,250
detect or obscure critical data

255
00:11:24,160 --> 00:11:31,480
structures such as heap or saved return

256
00:11:27,250 --> 00:11:36,280
address and/or prevent basically you

257
00:11:31,480 --> 00:11:37,839
getting code execution and then there's

258
00:11:36,280 --> 00:11:39,880
late stage mitigations where you've

259
00:11:37,839 --> 00:11:41,410
completely corrupted data control

260
00:11:39,880 --> 00:11:43,810
structures but they want to try and

261
00:11:41,410 --> 00:11:45,699
prevent you from actually executing code

262
00:11:43,810 --> 00:11:48,069
so you have things like control flow

263
00:11:45,700 --> 00:11:50,050
integrity PAC in this case deep

264
00:11:48,070 --> 00:11:53,470
hardening code signing that kind of

265
00:11:50,050 --> 00:11:55,180
thing there's a lot of them that are

266
00:11:53,470 --> 00:11:58,060
present in iOS but these are the ones

267
00:11:55,180 --> 00:12:01,420
that are relevant for this talk firstly

268
00:11:58,060 --> 00:12:02,829
ksl are and ASLR is something you

269
00:12:01,420 --> 00:12:05,650
probably would have already heard of

270
00:12:02,830 --> 00:12:08,050
address space randomization in iOS they

271
00:12:05,650 --> 00:12:12,819
basically slide binaries by randomized

272
00:12:08,050 --> 00:12:16,000
amount the second thing is kernel he

273
00:12:12,820 --> 00:12:19,720
pardoning there's been multiple

274
00:12:16,000 --> 00:12:24,550
iterations of this over the span of iOS

275
00:12:19,720 --> 00:12:26,290
is lifetime and they've done Stephan

276
00:12:24,550 --> 00:12:28,240
Esther has done multiple talks about

277
00:12:26,290 --> 00:12:30,280
this but basically there's zone

278
00:12:28,240 --> 00:12:33,130
isolation which is essentially they

279
00:12:30,280 --> 00:12:35,560
create isolated zones for like data

280
00:12:33,130 --> 00:12:37,089
structures so that you can't replace one

281
00:12:35,560 --> 00:12:38,619
data structure with another one by

282
00:12:37,089 --> 00:12:41,350
grooming memory

283
00:12:38,620 --> 00:12:44,410
there's zone data structure hardening

284
00:12:41,350 --> 00:12:47,290
essentially encrypting encoding things

285
00:12:44,410 --> 00:12:49,780
in memory there's block verification

286
00:12:47,290 --> 00:12:51,099
which when you free a block it makes

287
00:12:49,780 --> 00:12:52,540
sure that you're freeing it to the

288
00:12:51,100 --> 00:12:56,290
correct zone

289
00:12:52,540 --> 00:12:58,569
there's poisoning where where they you

290
00:12:56,290 --> 00:13:00,849
know will write junk over a over a block

291
00:12:58,570 --> 00:13:03,030
so that for use after free type

292
00:13:00,850 --> 00:13:07,470
vulnerabilities you can't exploit them

293
00:13:03,030 --> 00:13:10,030
and there's free list randomization

294
00:13:07,470 --> 00:13:12,820
Safari has also done its own he

295
00:13:10,030 --> 00:13:14,949
pardoning again it's got an isolation

296
00:13:12,820 --> 00:13:17,860
strategy and one that's called the Giga

297
00:13:14,950 --> 00:13:21,370
cage most recently again the idea of

298
00:13:17,860 --> 00:13:23,140
this is that objects of certain types

299
00:13:21,370 --> 00:13:25,300
are segmented off from objects of other

300
00:13:23,140 --> 00:13:27,220
certain types in the heap and so when

301
00:13:25,300 --> 00:13:30,490
you try and do a use after free or

302
00:13:27,220 --> 00:13:33,370
something you can't replace a freed

303
00:13:30,490 --> 00:13:36,339
object with you know arbitrary data

304
00:13:33,370 --> 00:13:38,950
contents you're restricted by you're

305
00:13:36,339 --> 00:13:40,270
restricted by only being able to replace

306
00:13:38,950 --> 00:13:44,110
it with the other objects at the same

307
00:13:40,270 --> 00:13:46,930
time bulletproof jet is another

308
00:13:44,110 --> 00:13:50,530
important thing this has had two main

309
00:13:46,930 --> 00:13:52,719
iterations in the a-10 iPhones they had

310
00:13:50,530 --> 00:13:55,209
an execute only bit which means you

311
00:13:52,720 --> 00:13:59,709
could map pages that were executable but

312
00:13:55,209 --> 00:14:02,770
not readable and the way what they did

313
00:13:59,709 --> 00:14:04,959
with the jet mapping in Safari is to map

314
00:14:02,770 --> 00:14:06,970
it at two locations in memory one that

315
00:14:04,959 --> 00:14:08,829
was executable only but not readable and

316
00:14:06,970 --> 00:14:10,780
one that was writable but in a hidden

317
00:14:08,830 --> 00:14:13,630
location and they would only refer to it

318
00:14:10,780 --> 00:14:16,089
in the in executable only pages the idea

319
00:14:13,630 --> 00:14:18,010
was that even if you had full read and

320
00:14:16,089 --> 00:14:19,720
write access to memory you couldn't

321
00:14:18,010 --> 00:14:21,360
really find out where the writable pages

322
00:14:19,720 --> 00:14:25,300
were so you couldn't write arbitrary

323
00:14:21,360 --> 00:14:27,280
code into this region they switched that

324
00:14:25,300 --> 00:14:29,740
out in 11 for a different thing called

325
00:14:27,280 --> 00:14:32,459
fast permission switching where they

326
00:14:29,740 --> 00:14:35,100
went back to one mapping for the jet but

327
00:14:32,460 --> 00:14:37,050
a special system register would control

328
00:14:35,100 --> 00:14:41,460
whether it was writable or executable

329
00:14:37,050 --> 00:14:44,490
and they would basically enforce access

330
00:14:41,460 --> 00:14:46,920
to the access to the jet through through

331
00:14:44,490 --> 00:14:48,360
one gate that only that switch that bid

332
00:14:46,920 --> 00:14:52,770
around depending on what they wanted to

333
00:14:48,360 --> 00:14:53,910
do the last thing I guess I want to talk

334
00:14:52,770 --> 00:14:55,560
about here is pointer authentication

335
00:14:53,910 --> 00:14:57,810
which is something you probably would

336
00:14:55,560 --> 00:15:01,040
have heard a lot about it was something

337
00:14:57,810 --> 00:15:04,829
added in the arm 8.3 a spec and

338
00:15:01,040 --> 00:15:08,160
essentially it uses some unused bits in

339
00:15:04,830 --> 00:15:13,110
64-bit pointers to take a more or less a

340
00:15:08,160 --> 00:15:14,790
hash of the pointer encoded with another

341
00:15:13,110 --> 00:15:19,500
arbitrary piece of data that you can

342
00:15:14,790 --> 00:15:22,170
choose and so largely the idea was was

343
00:15:19,500 --> 00:15:24,000
that and they they introduced this in

344
00:15:22,170 --> 00:15:27,360
the H rolls the new iPhones that came

345
00:15:24,000 --> 00:15:29,850
out fairly recently in September so the

346
00:15:27,360 --> 00:15:34,110
idea with pact is that you can't

347
00:15:29,850 --> 00:15:35,970
overwrite you know do data point do

348
00:15:34,110 --> 00:15:39,630
pointer over writes because you won't

349
00:15:35,970 --> 00:15:41,850
know how to do the how to do how to do

350
00:15:39,630 --> 00:15:44,460
the correct hash and the hash will be

351
00:15:41,850 --> 00:15:50,370
invalid and the pointer will basically

352
00:15:44,460 --> 00:15:51,930
be rendered invalid so environment

353
00:15:50,370 --> 00:15:55,530
preservation is the last thing and I

354
00:15:51,930 --> 00:16:00,180
think this is fairly tip unique to Apple

355
00:15:55,530 --> 00:16:02,970
actually this is basically we talked

356
00:16:00,180 --> 00:16:05,550
about a you know a protected runtime and

357
00:16:02,970 --> 00:16:07,590
we're you know we've protected the boot

358
00:16:05,550 --> 00:16:10,380
chain we've protected the the code

359
00:16:07,590 --> 00:16:13,830
that's running only I you know only

360
00:16:10,380 --> 00:16:15,990
Apple things are running but Apple has

361
00:16:13,830 --> 00:16:18,510
recently done something that lets say

362
00:16:15,990 --> 00:16:20,490
you fully compromised the kernel in the

363
00:16:18,510 --> 00:16:23,010
past obviously if you compromised the

364
00:16:20,490 --> 00:16:24,900
kernel you can execute kernel code that

365
00:16:23,010 --> 00:16:27,960
you want you can execute user mode code

366
00:16:24,900 --> 00:16:29,910
that you want so they've started trying

367
00:16:27,960 --> 00:16:31,830
to limit the impact of even if you fully

368
00:16:29,910 --> 00:16:36,079
compromised the kernel to preserve the

369
00:16:31,830 --> 00:16:38,790
system integrity to some degree and

370
00:16:36,080 --> 00:16:41,580
there's there's several protections that

371
00:16:38,790 --> 00:16:45,390
they've done in in the in the attempt in

372
00:16:41,580 --> 00:16:46,380
an attempt to do that the first one is a

373
00:16:45,390 --> 00:16:49,140
PFS remount

374
00:16:46,380 --> 00:16:50,939
think so the the file system in the the

375
00:16:49,140 --> 00:16:53,819
root file system in iOS that contains

376
00:16:50,940 --> 00:16:57,090
all the system binaries is is mounted

377
00:16:53,820 --> 00:16:58,860
read-only usually when you're putting

378
00:16:57,090 --> 00:17:01,530
down a payload or something you want to

379
00:16:58,860 --> 00:17:04,230
remount it with with right access and

380
00:17:01,530 --> 00:17:07,230
this has typically never been especially

381
00:17:04,230 --> 00:17:09,060
difficult you have to modify some data

382
00:17:07,230 --> 00:17:13,110
structures in in memory in the kernel

383
00:17:09,060 --> 00:17:14,399
but once you get kernel access but but

384
00:17:13,109 --> 00:17:16,500
they never went out of their way to

385
00:17:14,400 --> 00:17:18,630
protect it but with the recent

386
00:17:16,500 --> 00:17:20,579
introduction of a new file system a PFS

387
00:17:18,630 --> 00:17:23,220
they started using snapshotting and they

388
00:17:20,579 --> 00:17:24,510
started also utilizing some of the other

389
00:17:23,220 --> 00:17:27,630
protections and I'm going to talk about

390
00:17:24,510 --> 00:17:31,830
shortly to try and protect the integrity

391
00:17:27,630 --> 00:17:34,100
of the data structures describing the

392
00:17:31,830 --> 00:17:38,070
mounts so that you couldn't easily

393
00:17:34,100 --> 00:17:39,750
remount the file system another really

394
00:17:38,070 --> 00:17:41,220
important late stage mitigation is

395
00:17:39,750 --> 00:17:42,990
something called pre map protected layer

396
00:17:41,220 --> 00:17:44,640
this is going to be something that's

397
00:17:42,990 --> 00:17:48,690
talked about a lot over the next year

398
00:17:44,640 --> 00:17:50,580
it's part of the the a12 by OS kernel

399
00:17:48,690 --> 00:17:52,160
and it works in conjunction with PAC

400
00:17:50,580 --> 00:17:55,830
which we already talked about

401
00:17:52,160 --> 00:17:58,080
essentially what PPL is is it isolates a

402
00:17:55,830 --> 00:18:01,530
certain amount of kernel memory and

403
00:17:58,080 --> 00:18:06,260
makes it not not executable except

404
00:18:01,530 --> 00:18:08,220
through a certain trampoline and also

405
00:18:06,260 --> 00:18:09,840
protects some data so that it's not

406
00:18:08,220 --> 00:18:13,260
writable even if you can write to other

407
00:18:09,840 --> 00:18:15,659
kernel memory what and then what they

408
00:18:13,260 --> 00:18:18,090
protect in this area is code that

409
00:18:15,660 --> 00:18:20,970
governs sensitive data structures such

410
00:18:18,090 --> 00:18:23,689
as page tables and codes code signing

411
00:18:20,970 --> 00:18:26,970
information the result of which is that

412
00:18:23,690 --> 00:18:29,460
even if you get kernel level access if

413
00:18:26,970 --> 00:18:32,910
you don't have a ppl bypass then it is

414
00:18:29,460 --> 00:18:35,640
it is quite difficult to be able to you

415
00:18:32,910 --> 00:18:39,260
know inject executable code into user

416
00:18:35,640 --> 00:18:44,100
mode processes modify entitlements and

417
00:18:39,260 --> 00:18:47,330
and and signatures at runtime and also

418
00:18:44,100 --> 00:18:49,620
add to the trust occasionally kernel

419
00:18:47,330 --> 00:18:51,230
code signing is something you're

420
00:18:49,620 --> 00:18:53,129
probably already very familiar with

421
00:18:51,230 --> 00:18:55,510
again it's been talked about at length

422
00:18:53,130 --> 00:18:58,300
so won't really cover that here

423
00:18:55,510 --> 00:19:00,730
and the last thing is a Katy RR which is

424
00:18:58,300 --> 00:19:04,120
the successor to something called KP p

425
00:19:00,730 --> 00:19:06,460
so KP p was an original kernel patch

426
00:19:04,120 --> 00:19:09,550
protection it was a hypervisor like

427
00:19:06,460 --> 00:19:11,560
technology that would um it it

428
00:19:09,550 --> 00:19:13,540
infrequently through execution of the

429
00:19:11,560 --> 00:19:15,669
kernel would try to validate that the

430
00:19:13,540 --> 00:19:19,149
kernel hasn't been patched and if it

431
00:19:15,670 --> 00:19:21,420
found something that it that that was

432
00:19:19,150 --> 00:19:23,920
patched then it would panic the kernel

433
00:19:21,420 --> 00:19:25,720
they they eventually abandon this for

434
00:19:23,920 --> 00:19:29,140
something called kernel text read-only

435
00:19:25,720 --> 00:19:31,180
region which is a newish Hardware

436
00:19:29,140 --> 00:19:34,420
mitigation and essentially what this

437
00:19:31,180 --> 00:19:37,090
does is it just marks they they mark an

438
00:19:34,420 --> 00:19:41,220
area of the kernel specifically with the

439
00:19:37,090 --> 00:19:43,959
kernel text segment and executable code

440
00:19:41,220 --> 00:19:47,170
read only after it's been mapped in

441
00:19:43,960 --> 00:19:50,350
initially and you you can't undo it so

442
00:19:47,170 --> 00:19:53,110
essentially even if you get a full

443
00:19:50,350 --> 00:19:55,750
read/write access to kernel memory if K

444
00:19:53,110 --> 00:19:59,050
trro is active and you don't know how to

445
00:19:55,750 --> 00:20:03,790
bypass it then you can't patch kernel

446
00:19:59,050 --> 00:20:07,899
code directly so that was a quick tour

447
00:20:03,790 --> 00:20:10,240
of iPhone security the the takeaways as

448
00:20:07,900 --> 00:20:14,170
far as remote jail breaks are concerned

449
00:20:10,240 --> 00:20:16,060
really is one thing is code integrity

450
00:20:14,170 --> 00:20:18,670
and the other is controlling the

451
00:20:16,060 --> 00:20:20,740
hardware so a big differentiator for

452
00:20:18,670 --> 00:20:23,230
Apple I think is code integrity

453
00:20:20,740 --> 00:20:25,300
basically nearly all the code that's run

454
00:20:23,230 --> 00:20:27,520
on the system with the exception of the

455
00:20:25,300 --> 00:20:30,250
the JIT mapping thing that I talked

456
00:20:27,520 --> 00:20:32,940
about code is essentially whitelisted

457
00:20:30,250 --> 00:20:35,890
all of it has been verified by Apple and

458
00:20:32,940 --> 00:20:37,810
rather than blacklisting or just using

459
00:20:35,890 --> 00:20:40,600
code integrity for a small part of the

460
00:20:37,810 --> 00:20:43,270
system like a boot chain it's it's very

461
00:20:40,600 --> 00:20:45,399
rigid and it's quite mature now whereas

462
00:20:43,270 --> 00:20:47,500
before when they first implemented it it

463
00:20:45,400 --> 00:20:50,680
was a little bit it had a lot of

464
00:20:47,500 --> 00:20:53,230
weaknesses code integrity has been done

465
00:20:50,680 --> 00:20:55,990
before of course for trusted boot chains

466
00:20:53,230 --> 00:20:57,970
and you know signed ActiveX controls and

467
00:20:55,990 --> 00:20:59,980
things but no one has really done it as

468
00:20:57,970 --> 00:21:02,980
completely as iOS in a commercial

469
00:20:59,980 --> 00:21:05,890
product Windows S is sort of getting

470
00:21:02,980 --> 00:21:07,720
there but not quite the second

471
00:21:05,890 --> 00:21:08,640
differentiator is that Apple controls

472
00:21:07,720 --> 00:21:11,010
their there

473
00:21:08,640 --> 00:21:13,770
where there their ecosystem so they can

474
00:21:11,010 --> 00:21:16,620
enforce security at the hardware level

475
00:21:13,770 --> 00:21:17,879
and they're increasingly doing that you

476
00:21:16,620 --> 00:21:21,000
know where where is someone like

477
00:21:17,880 --> 00:21:23,580
Microsoft's might do CF GE as a as a

478
00:21:21,000 --> 00:21:27,330
control flow integrity thing Apple can

479
00:21:23,580 --> 00:21:28,889
just go straight to hardware and and you

480
00:21:27,330 --> 00:21:31,379
know use pack and things like that and

481
00:21:28,890 --> 00:21:32,730
because they don't work with a committee

482
00:21:31,380 --> 00:21:34,470
or something like that they can

483
00:21:32,730 --> 00:21:35,610
generally get Hardware mitigations to

484
00:21:34,470 --> 00:21:40,380
market a lot more quickly than

485
00:21:35,610 --> 00:21:41,879
competitors so you know a lot of Android

486
00:21:40,380 --> 00:21:44,820
phones are likely going to have pack in

487
00:21:41,880 --> 00:21:46,410
the near future but you know Apple will

488
00:21:44,820 --> 00:21:52,080
have beaten them by like six months to a

489
00:21:46,410 --> 00:21:53,640
year some of the protections that I've

490
00:21:52,080 --> 00:21:54,960
gone through actually you'll notice that

491
00:21:53,640 --> 00:21:56,460
most of the protections that I've gone

492
00:21:54,960 --> 00:21:59,040
through have been implemented in

493
00:21:56,460 --> 00:22:04,580
hardware to some degree and that speaks

494
00:21:59,040 --> 00:22:07,168
to speaks to Apple's ongoing strategy

495
00:22:04,580 --> 00:22:09,570
hardware mitigations are often much more

496
00:22:07,169 --> 00:22:11,190
difficult to bypass it sort of depends

497
00:22:09,570 --> 00:22:14,220
how complicated they are and how much

498
00:22:11,190 --> 00:22:17,700
the software side of it has to do but

499
00:22:14,220 --> 00:22:21,120
they can provide a much more robust

500
00:22:17,700 --> 00:22:23,010
security mechanism there's a few gotchas

501
00:22:21,120 --> 00:22:25,799
of course with this with this approach

502
00:22:23,010 --> 00:22:27,960
one is you need the latest devices to

503
00:22:25,799 --> 00:22:31,679
get the latest mitigation benefits pack

504
00:22:27,960 --> 00:22:34,860
you need an a12 the iPhone XS and XR

505
00:22:31,679 --> 00:22:37,410
otherwise you just don't have it and in

506
00:22:34,860 --> 00:22:39,418
theory if you found a hardware level bug

507
00:22:37,410 --> 00:22:41,790
it they might not be able to work around

508
00:22:39,419 --> 00:22:44,940
it in software and you essentially just

509
00:22:41,790 --> 00:22:49,290
have to wait until the next device comes

510
00:22:44,940 --> 00:22:52,830
out so that's a really quick

511
00:22:49,290 --> 00:22:54,299
introduction to iOS security now we're

512
00:22:52,830 --> 00:22:56,970
going to talk about what constitutes a

513
00:22:54,299 --> 00:22:58,799
jailbreak so basically in order to

514
00:22:56,970 --> 00:23:02,220
bypass this we need a multitude of

515
00:22:58,799 --> 00:23:03,780
vulnerabilities into a chain and one of

516
00:23:02,220 --> 00:23:05,820
the difficulties of this is that any

517
00:23:03,780 --> 00:23:07,649
broken link in the chain might render

518
00:23:05,820 --> 00:23:11,370
the chain in partially or entirely

519
00:23:07,650 --> 00:23:15,330
useless so we're going to consider

520
00:23:11,370 --> 00:23:17,370
remote jail breaks today like I said USB

521
00:23:15,330 --> 00:23:19,770
is a really interesting use case in

522
00:23:17,370 --> 00:23:22,178
particular and it's worthy of its own

523
00:23:19,770 --> 00:23:24,549
talk but I just didn't have

524
00:23:22,179 --> 00:23:26,740
to fit it in there's also another kind

525
00:23:24,549 --> 00:23:28,418
of jailbreak a near access type one

526
00:23:26,740 --> 00:23:31,600
where you deliver an exploit via

527
00:23:28,419 --> 00:23:33,159
baseband or via Wi-Fi project zero has

528
00:23:31,600 --> 00:23:35,740
done a really good example of that

529
00:23:33,159 --> 00:23:39,669
before but again it would warrant its

530
00:23:35,740 --> 00:23:42,369
own talk so the goals of our jailbreak

531
00:23:39,669 --> 00:23:44,049
to compromise runtime integrity be able

532
00:23:42,369 --> 00:23:46,749
to execute arbitrary code at runtime and

533
00:23:44,049 --> 00:23:49,059
to compromise the bus trusted boot chain

534
00:23:46,749 --> 00:23:52,950
so that we can regain code execution

535
00:23:49,059 --> 00:23:56,918
after after the phone has been rebooted

536
00:23:52,950 --> 00:23:59,080
so basically this is the template for

537
00:23:56,919 --> 00:24:03,220
what a typical jailbreak will look like

538
00:23:59,080 --> 00:24:05,428
there's five real stages basically the

539
00:24:03,220 --> 00:24:09,009
five stages of grief

540
00:24:05,429 --> 00:24:11,440
firstly you want to compromise runtime

541
00:24:09,009 --> 00:24:13,419
integrity so this this essentially

542
00:24:11,440 --> 00:24:15,159
involves getting a foothold in the

543
00:24:13,419 --> 00:24:19,059
system in our case it's going to be

544
00:24:15,159 --> 00:24:21,429
Safari but you could also get it through

545
00:24:19,059 --> 00:24:23,769
like a messaging app an email client you

546
00:24:21,429 --> 00:24:25,659
know anything the second stage is

547
00:24:23,769 --> 00:24:28,840
extending access breaking out of a

548
00:24:25,659 --> 00:24:32,649
sandbox perhaps getting an unsigned code

549
00:24:28,840 --> 00:24:35,139
execution this is an optional step as

550
00:24:32,649 --> 00:24:37,268
we'll see the third step is getting

551
00:24:35,139 --> 00:24:39,340
kernel access so elevating your

552
00:24:37,269 --> 00:24:41,619
privileges to kernel and then getting

553
00:24:39,340 --> 00:24:42,820
complete control the system it's not

554
00:24:41,619 --> 00:24:48,158
really complete anymore because of

555
00:24:42,820 --> 00:24:50,559
pack-in ppl and then stage four once

556
00:24:48,159 --> 00:24:53,169
you've got kernel execution you want to

557
00:24:50,559 --> 00:24:55,450
weaken all the security mitigations as

558
00:24:53,169 --> 00:24:57,669
much as you can remove code signing at

559
00:24:55,450 --> 00:24:59,740
the entitlements you need inject into

560
00:24:57,669 --> 00:25:02,889
processes whatever whatever you happen

561
00:24:59,740 --> 00:25:04,960
to be doing and then to compromise the

562
00:25:02,889 --> 00:25:07,689
boot chain you basically want to place

563
00:25:04,960 --> 00:25:11,169
data on the system to so that when the

564
00:25:07,690 --> 00:25:12,639
phone is rebooted your data is passed or

565
00:25:11,169 --> 00:25:16,629
whatever it is you're using to get code

566
00:25:12,639 --> 00:25:20,469
execution each each each chain is

567
00:25:16,629 --> 00:25:23,498
generally about three bugs of this of a

568
00:25:20,470 --> 00:25:25,779
web race web-based jailbreak some stages

569
00:25:23,499 --> 00:25:27,869
may not be required but often stages

570
00:25:25,779 --> 00:25:30,340
require more than one bug in particular

571
00:25:27,869 --> 00:25:33,279
information leaking is often a separate

572
00:25:30,340 --> 00:25:36,459
bug but typically you'll have a safari

573
00:25:33,279 --> 00:25:39,280
exploit you'll have a kernel

574
00:25:36,460 --> 00:25:42,310
and either a code-signing bypass or some

575
00:25:39,280 --> 00:25:44,950
kind of boot time exploit so I don't

576
00:25:42,310 --> 00:25:48,250
know why PowerPoint keeps running ahead

577
00:25:44,950 --> 00:25:52,360
of me okay

578
00:25:48,250 --> 00:25:54,220
so the first step is you like I said you

579
00:25:52,360 --> 00:25:55,929
have a variety of potential vectors

580
00:25:54,220 --> 00:25:58,510
the reason the browser is the most

581
00:25:55,930 --> 00:26:00,640
attractive target is because it's got so

582
00:25:58,510 --> 00:26:02,530
many things going for it that are in the

583
00:26:00,640 --> 00:26:04,720
attackers favor it has a large attack

584
00:26:02,530 --> 00:26:06,850
surface it has interaction with a

585
00:26:04,720 --> 00:26:08,770
complex state a number of complex state

586
00:26:06,850 --> 00:26:12,760
machines the the Dom the JavaScript

587
00:26:08,770 --> 00:26:15,400
engine CSS etc you have the ability to

588
00:26:12,760 --> 00:26:16,810
groom memory is easily you have a

589
00:26:15,400 --> 00:26:19,120
programmatic feedback with the

590
00:26:16,810 --> 00:26:21,879
JavaScript language and most importantly

591
00:26:19,120 --> 00:26:23,800
for iOS you like I mentioned before you

592
00:26:21,880 --> 00:26:26,140
had the run unsigned code entitlement

593
00:26:23,800 --> 00:26:28,510
which means you don't need a code

594
00:26:26,140 --> 00:26:30,400
signing bypass once you corrupt critical

595
00:26:28,510 --> 00:26:34,120
data structures if you're able to write

596
00:26:30,400 --> 00:26:36,430
to the JED if you if you target and

597
00:26:34,120 --> 00:26:40,330
other things such as you know a

598
00:26:36,430 --> 00:26:41,380
messaging app or or a email client or

599
00:26:40,330 --> 00:26:43,990
something that doesn't have this

600
00:26:41,380 --> 00:26:46,570
entitlement then there's a huge problem

601
00:26:43,990 --> 00:26:49,600
in that you corrupt data there's several

602
00:26:46,570 --> 00:26:51,250
huge problems really one of them is that

603
00:26:49,600 --> 00:26:53,919
you don't have a programmatic interface

604
00:26:51,250 --> 00:26:57,070
it's often harder to groom memory but

605
00:26:53,920 --> 00:26:58,930
also you won't have you'll have to

606
00:26:57,070 --> 00:27:01,629
bypass code signing which might mean

607
00:26:58,930 --> 00:27:03,580
having to do everything in Rob and even

608
00:27:01,630 --> 00:27:08,290
Rob is might not be an option with pack

609
00:27:03,580 --> 00:27:10,360
on the a12 the second stage like I said

610
00:27:08,290 --> 00:27:12,220
it's optional if you can't go directly

611
00:27:10,360 --> 00:27:15,280
to kernel sometimes they'll be a sandbox

612
00:27:12,220 --> 00:27:20,260
escape stage or a partial sandbox escape

613
00:27:15,280 --> 00:27:22,149
or something like it after that you want

614
00:27:20,260 --> 00:27:26,290
to escalate to achieve kernel level

615
00:27:22,150 --> 00:27:28,870
access in in jailbreak parlance this is

616
00:27:26,290 --> 00:27:31,360
generally referred to as TFP 0 or task

617
00:27:28,870 --> 00:27:34,209
for pin 0 and essentially that means you

618
00:27:31,360 --> 00:27:38,199
get access to the kernel task so the

619
00:27:34,210 --> 00:27:40,060
kernel task is a mark port and when you

620
00:27:38,200 --> 00:27:41,670
have access to kernel task then

621
00:27:40,060 --> 00:27:44,760
basically you're able to read and write

622
00:27:41,670 --> 00:27:47,140
to kernel memory arbitrarily

623
00:27:44,760 --> 00:27:50,140
notwithstanding the protections that I

624
00:27:47,140 --> 00:27:50,410
mentioned earlier like I said this used

625
00:27:50,140 --> 00:27:51,940
to in

626
00:27:50,410 --> 00:27:56,440
like code execution but now it really

627
00:27:51,940 --> 00:27:58,090
doesn't the xposed kernel attack surface

628
00:27:56,440 --> 00:28:01,060
is very large and there's a lot of

629
00:27:58,090 --> 00:28:03,189
speeches on this but essentially you

630
00:28:01,060 --> 00:28:06,419
would you might be attacking in in

631
00:28:03,190 --> 00:28:11,080
kernel mark services system calls or

632
00:28:06,420 --> 00:28:13,510
iokit drivers to name a few things and

633
00:28:11,080 --> 00:28:15,159
again these are really restricted

634
00:28:13,510 --> 00:28:19,990
depending on what sandbox you're

635
00:28:15,160 --> 00:28:22,800
attacking from the next thing is post

636
00:28:19,990 --> 00:28:26,530
exploitation so once you've got TFP zero

637
00:28:22,800 --> 00:28:28,120
largely what you want to do is it

638
00:28:26,530 --> 00:28:29,560
depends on exactly what you're doing but

639
00:28:28,120 --> 00:28:32,320
essentially you want to weaken security

640
00:28:29,560 --> 00:28:33,820
controls and installed your persistence

641
00:28:32,320 --> 00:28:36,280
payloads so that when the phone reboots

642
00:28:33,820 --> 00:28:41,649
you're able to regain control of the

643
00:28:36,280 --> 00:28:44,770
phone often like I mentioned this

644
00:28:41,650 --> 00:28:51,760
involves remounting the file system with

645
00:28:44,770 --> 00:28:53,500
with right privileges so regaining code

646
00:28:51,760 --> 00:28:56,200
execution after reboot is actually

647
00:28:53,500 --> 00:28:58,270
really quite difficult because of the

648
00:28:56,200 --> 00:29:01,750
trust boot chain that we that we briefly

649
00:28:58,270 --> 00:29:06,250
mentioned before essentially you have to

650
00:29:01,750 --> 00:29:08,590
break the chain of trust somewhere now

651
00:29:06,250 --> 00:29:11,800
essentially you can do this by perhaps

652
00:29:08,590 --> 00:29:13,720
now creating a malformed file system

653
00:29:11,800 --> 00:29:16,540
that gets parsed you might be able to

654
00:29:13,720 --> 00:29:19,420
attack executable parses image theory

655
00:29:16,540 --> 00:29:22,330
image for parses which is a format that

656
00:29:19,420 --> 00:29:24,730
Apple uses to unpack a lot of its data

657
00:29:22,330 --> 00:29:26,470
structures or you might be looking for a

658
00:29:24,730 --> 00:29:31,750
logic floor a weakness in their

659
00:29:26,470 --> 00:29:34,150
cryptographic implementation so I've

660
00:29:31,750 --> 00:29:36,760
sort of gone over like what options you

661
00:29:34,150 --> 00:29:39,460
have here the exploiting the boot ROM is

662
00:29:36,760 --> 00:29:41,740
something that's happened once before a

663
00:29:39,460 --> 00:29:44,800
long time ago with an exploit called 24k

664
00:29:41,740 --> 00:29:47,860
pone if you're able to exploit the boot

665
00:29:44,800 --> 00:29:50,050
ROM it's pretty great because it's a ROM

666
00:29:47,860 --> 00:29:54,580
so the bug is ever-present until they

667
00:29:50,050 --> 00:29:56,740
release a new device in in reality

668
00:29:54,580 --> 00:29:59,199
though it's actually very difficult to

669
00:29:56,740 --> 00:30:00,910
to find a vulnerability in the boot ROM

670
00:29:59,200 --> 00:30:02,160
because it's very sparse it does nearly

671
00:30:00,910 --> 00:30:04,540
nothing

672
00:30:02,160 --> 00:30:07,720
specifically because of the the reason

673
00:30:04,540 --> 00:30:09,430
that they can't replace it there's also

674
00:30:07,720 --> 00:30:12,550
been a number of iboot exploits in the

675
00:30:09,430 --> 00:30:15,670
past I boot is is basically the thing

676
00:30:12,550 --> 00:30:18,430
that loads the iOS kernel it has some

677
00:30:15,670 --> 00:30:20,260
similar advantages to boot ROM but it

678
00:30:18,430 --> 00:30:23,500
does have some mitigations in place in

679
00:30:20,260 --> 00:30:25,450
particularly pack on the a12 and the

680
00:30:23,500 --> 00:30:27,250
attack surface is is larger than the

681
00:30:25,450 --> 00:30:28,660
boot rom but it's still fairly slim

682
00:30:27,250 --> 00:30:31,390
pickings and Apple has spent a lot of

683
00:30:28,660 --> 00:30:33,210
time working on it due to past

684
00:30:31,390 --> 00:30:35,860
jailbreaks

685
00:30:33,210 --> 00:30:39,040
the next stage is attacking the kernel

686
00:30:35,860 --> 00:30:41,020
itself I feel this is a very difficult

687
00:30:39,040 --> 00:30:43,080
target to attack if you're going for a

688
00:30:41,020 --> 00:30:45,340
memory corruption type flaw because

689
00:30:43,080 --> 00:30:47,260
basically the full scale of memory

690
00:30:45,340 --> 00:30:49,720
corruption mitigations are present you

691
00:30:47,260 --> 00:30:53,290
have to contend with a SLR you have to

692
00:30:49,720 --> 00:30:54,930
contend with pack perhaps you know he

693
00:30:53,290 --> 00:30:57,040
pardoning all that kind of thing and

694
00:30:54,930 --> 00:30:58,780
because you're not actually executing

695
00:30:57,040 --> 00:31:01,030
code yet your ability to grow in memory

696
00:30:58,780 --> 00:31:04,180
and perform race conditions and stuff is

697
00:31:01,030 --> 00:31:10,240
very low to non-existent so it's a very

698
00:31:04,180 --> 00:31:11,410
difficult target option for is attacking

699
00:31:10,240 --> 00:31:14,590
the user mode itself

700
00:31:11,410 --> 00:31:18,460
so basically there's a couple of options

701
00:31:14,590 --> 00:31:21,850
here firstly finding a logic flaw in the

702
00:31:18,460 --> 00:31:23,920
code signing machinery failing that you

703
00:31:21,850 --> 00:31:25,899
could try and find a memory corruption

704
00:31:23,920 --> 00:31:28,750
or similar floor in an Apple binary that

705
00:31:25,900 --> 00:31:32,200
runs at startup or you could replace an

706
00:31:28,750 --> 00:31:36,790
apple binary that runs at startup and

707
00:31:32,200 --> 00:31:38,440
exploit that again it's difficult for

708
00:31:36,790 --> 00:31:40,270
memory corruption because you aren't

709
00:31:38,440 --> 00:31:42,070
actually executing code yet so your

710
00:31:40,270 --> 00:31:44,950
ability to groom memory and things like

711
00:31:42,070 --> 00:31:47,470
that is quite limited however it's a bit

712
00:31:44,950 --> 00:31:49,090
less difficult from than the kernel in

713
00:31:47,470 --> 00:31:51,340
that you might be able to do multiple

714
00:31:49,090 --> 00:31:55,929
tries and have it keep crashing until it

715
00:31:51,340 --> 00:31:58,510
works essentially option 4 by the way is

716
00:31:55,930 --> 00:32:01,360
by far the most popular vector most jail

717
00:31:58,510 --> 00:32:06,250
breaks that you've heard of do something

718
00:32:01,360 --> 00:32:08,800
in this category finding finding a floor

719
00:32:06,250 --> 00:32:10,960
in the code signing machinery is is by

720
00:32:08,800 --> 00:32:13,300
far in my opinion and most desirable

721
00:32:10,960 --> 00:32:14,710
option firstly it's reliable you don't

722
00:32:13,300 --> 00:32:18,129
have to worry about grooming memory and

723
00:32:14,710 --> 00:32:20,470
like that it allows privilege escalation

724
00:32:18,130 --> 00:32:21,880
to be performed in in native code you

725
00:32:20,470 --> 00:32:25,510
don't have to worry about doing rap or

726
00:32:21,880 --> 00:32:27,669
anything like that which again is is you

727
00:32:25,510 --> 00:32:30,370
know Rob is a very significant cost to

728
00:32:27,669 --> 00:32:32,380
the attacker so being able to bypass

729
00:32:30,370 --> 00:32:34,979
that is really useful and like we said

730
00:32:32,380 --> 00:32:39,070
with PAC your ability to do Rob might be

731
00:32:34,980 --> 00:32:41,440
effectively mitigated anyway and then

732
00:32:39,070 --> 00:32:43,149
lastly if you have a code signing bypass

733
00:32:41,440 --> 00:32:45,399
you might be able to reuse it elsewhere

734
00:32:43,149 --> 00:32:47,260
in your chain such as if you're doing a

735
00:32:45,399 --> 00:32:48,820
zero click option where you're attacking

736
00:32:47,260 --> 00:32:51,820
a male client or something along those

737
00:32:48,820 --> 00:32:53,350
lines and you could control critical

738
00:32:51,820 --> 00:32:55,840
data structures you might be able to

739
00:32:53,350 --> 00:32:58,209
then launch your code signing attack and

740
00:32:55,840 --> 00:32:59,620
get unsigned code and then you gain back

741
00:32:58,210 --> 00:33:03,010
one of the advantages that the web

742
00:32:59,620 --> 00:33:05,529
browser would traditionally have there's

743
00:33:03,010 --> 00:33:07,929
various places to target this kind of

744
00:33:05,529 --> 00:33:10,929
vulnerability and in the past we've sort

745
00:33:07,929 --> 00:33:14,049
of seen ones attacking the kernel binary

746
00:33:10,929 --> 00:33:17,440
loader the Marko loader the dynamic

747
00:33:14,049 --> 00:33:20,230
loader you know dial D and user mode

748
00:33:17,440 --> 00:33:22,600
which is usually responsible for loading

749
00:33:20,230 --> 00:33:26,950
libraries and also loading the shared

750
00:33:22,600 --> 00:33:30,340
cache the code signing faulting in logic

751
00:33:26,950 --> 00:33:34,149
which is exists within the kernel or the

752
00:33:30,340 --> 00:33:37,510
Apple mobile Apple mobile file integrity

753
00:33:34,149 --> 00:33:41,709
daemon amf ID which is also responsible

754
00:33:37,510 --> 00:33:43,990
for verifying and validating code

755
00:33:41,710 --> 00:33:46,539
signatures so these are all attractive

756
00:33:43,990 --> 00:33:49,539
targets and they've been numerous

757
00:33:46,539 --> 00:33:52,149
they're been exploited many many times

758
00:33:49,539 --> 00:33:56,260
in the past I've put some examples up

759
00:33:52,149 --> 00:33:57,520
there one on iOS 9 by Pangu they talked

760
00:33:56,260 --> 00:33:59,919
about in their presentation they

761
00:33:57,520 --> 00:34:03,039
exploited a logic vulnerability in

762
00:33:59,919 --> 00:34:05,140
loading the shared cache the problem is

763
00:34:03,039 --> 00:34:06,940
like I said it is these areas have been

764
00:34:05,140 --> 00:34:10,929
rather regular rigorously attacked and

765
00:34:06,940 --> 00:34:12,429
undergoing a lot of scrutiny but so it's

766
00:34:10,929 --> 00:34:14,168
a lot more difficult target but then

767
00:34:12,429 --> 00:34:15,639
again that doesn't necessarily mean that

768
00:34:14,168 --> 00:34:20,129
there's nothing there and and be

769
00:34:15,639 --> 00:34:22,720
approved that with as recently as iOS 11

770
00:34:20,129 --> 00:34:25,929
so now that we've sort of talked about

771
00:34:22,719 --> 00:34:28,540
the device the five typical stages I

772
00:34:25,929 --> 00:34:32,050
wanted to look at the Pegasus jailbreak

773
00:34:28,540 --> 00:34:33,699
this was caught in the wild and targeted

774
00:34:32,050 --> 00:34:36,310
a number of iOS versions but basically

775
00:34:33,699 --> 00:34:42,089
iOS 9.3 was about current when it got

776
00:34:36,310 --> 00:34:44,620
found so this was a 2016 jailbreak and

777
00:34:42,090 --> 00:34:47,320
this guy max did a really excellent

778
00:34:44,620 --> 00:34:49,690
write-up of this and and a talk about it

779
00:34:47,320 --> 00:34:52,000
which you can go and look at more of the

780
00:34:49,690 --> 00:34:53,950
details about but I just wanted to show

781
00:34:52,000 --> 00:34:58,600
you how they follow the typical

782
00:34:53,949 --> 00:35:00,879
structure of the jailbreak like we

783
00:34:58,600 --> 00:35:04,120
talked about in the previous section

784
00:35:00,880 --> 00:35:07,330
so iOS was a tough target but not quite

785
00:35:04,120 --> 00:35:09,100
as tough back then so their first

786
00:35:07,330 --> 00:35:11,290
vulnerability was a JavaScript core

787
00:35:09,100 --> 00:35:16,000
exploit exploiting the JavaScript engine

788
00:35:11,290 --> 00:35:18,580
a use after free in something called the

789
00:35:16,000 --> 00:35:21,910
marked buffer implement marked argument

790
00:35:18,580 --> 00:35:25,210
buffer implementation this was triggered

791
00:35:21,910 --> 00:35:26,980
by JavaScript and there was limited heat

792
00:35:25,210 --> 00:35:30,250
protections I had to work around but

793
00:35:26,980 --> 00:35:32,380
like the chip hardening the bulletproof

794
00:35:30,250 --> 00:35:35,620
didn't exist yet at the time so they

795
00:35:32,380 --> 00:35:38,770
didn't need to worry about that so they

796
00:35:35,620 --> 00:35:40,960
basically had three stages that they

797
00:35:38,770 --> 00:35:43,720
needed to accomplish one was triggering

798
00:35:40,960 --> 00:35:45,580
the vulnerability which again max has

799
00:35:43,720 --> 00:35:49,569
done a really comprehensive write-up but

800
00:35:45,580 --> 00:35:50,980
essentially when defining when defining

801
00:35:49,570 --> 00:35:52,780
an object with a large amount of

802
00:35:50,980 --> 00:35:54,880
properties there was a vulnerability

803
00:35:52,780 --> 00:35:56,110
there was a mistake in the marked

804
00:35:54,880 --> 00:35:59,440
argument buffer thing that would

805
00:35:56,110 --> 00:36:01,510
essentially cause it to fail to mark

806
00:35:59,440 --> 00:36:04,840
some of the JavaScript objects that are

807
00:36:01,510 --> 00:36:06,610
in use so that if a garbage collection

808
00:36:04,840 --> 00:36:08,140
happens they would accidentally get

809
00:36:06,610 --> 00:36:10,990
freed but you would still have a

810
00:36:08,140 --> 00:36:12,490
JavaScript variable pointing to them so

811
00:36:10,990 --> 00:36:17,140
a use after free vulnerability

812
00:36:12,490 --> 00:36:20,379
essentially so they basically exploited

813
00:36:17,140 --> 00:36:24,160
this vulnerability and then had to and

814
00:36:20,380 --> 00:36:27,790
then had a stale reference to to you

815
00:36:24,160 --> 00:36:29,200
know to a JavaScript object and they

816
00:36:27,790 --> 00:36:31,000
would then create a new object that

817
00:36:29,200 --> 00:36:33,189
basically reallocated that same amount

818
00:36:31,000 --> 00:36:35,110
of that same memory but pointed to a

819
00:36:33,190 --> 00:36:37,150
different type of object and using this

820
00:36:35,110 --> 00:36:41,380
type confusion they were essentially

821
00:36:37,150 --> 00:36:42,340
able to then corrupt a UN 32 array

822
00:36:41,380 --> 00:36:44,620
object if you

823
00:36:42,340 --> 00:36:46,810
to type to raise in them in JavaScript

824
00:36:44,620 --> 00:36:49,210
before it's very common that you will

825
00:36:46,810 --> 00:36:51,130
corrupt an object such as this and then

826
00:36:49,210 --> 00:36:55,090
use it to sort of index the entire

827
00:36:51,130 --> 00:36:57,760
process address space after that they

828
00:36:55,090 --> 00:37:01,960
would get arbitrary code execution using

829
00:36:57,760 --> 00:37:04,030
a very standard method this basically

830
00:37:01,960 --> 00:37:06,100
what you do generally is create a new

831
00:37:04,030 --> 00:37:08,160
function call it repeatedly so that

832
00:37:06,100 --> 00:37:11,830
dynamic code gets generated it gets

833
00:37:08,160 --> 00:37:14,350
pointed into the JIT region then you use

834
00:37:11,830 --> 00:37:16,630
your a SLR primitive to find you know

835
00:37:14,350 --> 00:37:20,230
the J's function data structure in

836
00:37:16,630 --> 00:37:22,600
memory that will contain a pointer to

837
00:37:20,230 --> 00:37:25,720
the JIT code for this function you can

838
00:37:22,600 --> 00:37:27,220
then write over that JIT code and then

839
00:37:25,720 --> 00:37:29,319
you call the JavaScript function

840
00:37:27,220 --> 00:37:33,490
essentially and execute the code you

841
00:37:29,320 --> 00:37:34,990
wanted to Pegasus went straight to

842
00:37:33,490 --> 00:37:38,709
Colonels so they didn't have a sandbox

843
00:37:34,990 --> 00:37:41,649
escape so they got to skip stage 2 stage

844
00:37:38,710 --> 00:37:44,050
3 they had a pair of vulnerabilities

845
00:37:41,650 --> 00:37:46,090
like I said some stages require more

846
00:37:44,050 --> 00:37:49,120
than one vulnerability in this case I

847
00:37:46,090 --> 00:37:50,680
had a both in a function called OS uncie

848
00:37:49,120 --> 00:37:54,460
realized binary they had an information

849
00:37:50,680 --> 00:37:57,460
leak to bypass kernel a SLR and they had

850
00:37:54,460 --> 00:37:59,200
a use after free exploit as well they

851
00:37:57,460 --> 00:38:02,340
had to contend with various heap

852
00:37:59,200 --> 00:38:06,009
hardening things in particular internal

853
00:38:02,340 --> 00:38:11,920
randomization of free lists and block

854
00:38:06,010 --> 00:38:14,650
poisoning and of course KS allow so to

855
00:38:11,920 --> 00:38:17,140
defeat KS SLR essentially like I said

856
00:38:14,650 --> 00:38:20,820
they had a separate vulnerability which

857
00:38:17,140 --> 00:38:23,680
allowed him to read excess kernel memory

858
00:38:20,820 --> 00:38:26,170
adjacent to to a buffer that that they

859
00:38:23,680 --> 00:38:28,000
had allocated from doing that they were

860
00:38:26,170 --> 00:38:29,890
able to get a V table and from that they

861
00:38:28,000 --> 00:38:31,810
were able like a V table pointer and

862
00:38:29,890 --> 00:38:35,770
from that they were able to calculate

863
00:38:31,810 --> 00:38:39,310
the the slide that the kernel has been

864
00:38:35,770 --> 00:38:44,080
moved by so they know where the kernel

865
00:38:39,310 --> 00:38:46,620
is in memory furthermore then they go

866
00:38:44,080 --> 00:38:49,120
and trigger the bug again this was in

867
00:38:46,620 --> 00:38:51,029
effect not unlike the JavaScript

868
00:38:49,120 --> 00:38:52,180
vulnerability that they found in that

869
00:38:51,030 --> 00:38:54,070
there

870
00:38:52,180 --> 00:38:57,940
they were able to essentially cause a

871
00:38:54,070 --> 00:39:00,250
use after free and maintained a

872
00:38:57,940 --> 00:39:02,860
reference to a stale object that had

873
00:39:00,250 --> 00:39:09,240
been freed and reallocated as something

874
00:39:02,860 --> 00:39:09,240
else in in this particular instance

875
00:39:09,390 --> 00:39:15,040
basically later on this object will have

876
00:39:11,890 --> 00:39:17,529
a have the retained function called on

877
00:39:15,040 --> 00:39:20,440
it which basically involves going

878
00:39:17,530 --> 00:39:23,920
through a V table and so by over

879
00:39:20,440 --> 00:39:25,420
overriding by freeing the object then

880
00:39:23,920 --> 00:39:27,910
overwriting it with data that you can

881
00:39:25,420 --> 00:39:30,040
control you can craft your own fake V

882
00:39:27,910 --> 00:39:33,580
table pointer and then kick off a rope

883
00:39:30,040 --> 00:39:37,240
chain essentially and and you know get

884
00:39:33,580 --> 00:39:39,250
arbitrary code execution so once they

885
00:39:37,240 --> 00:39:41,410
did that in in their case they

886
00:39:39,250 --> 00:39:44,740
essentially installed a few rock chains

887
00:39:41,410 --> 00:39:46,270
in the kernel that allowed them to do D

888
00:39:44,740 --> 00:39:49,479
word reads and writes to kernel memory

889
00:39:46,270 --> 00:39:54,580
and also to perform an arbitrary kernel

890
00:39:49,480 --> 00:39:56,200
function call the post exploitation they

891
00:39:54,580 --> 00:39:58,420
had to contend with kernel patch

892
00:39:56,200 --> 00:40:02,169
protection like I said this was KTR

893
00:39:58,420 --> 00:40:08,410
hours predecessor and it worked okay but

894
00:40:02,170 --> 00:40:10,450
like I said it would infrequently check

895
00:40:08,410 --> 00:40:12,370
the kernel and so it was basically still

896
00:40:10,450 --> 00:40:15,490
possible to patch the kernel and then

897
00:40:12,370 --> 00:40:17,770
patch it back and avoid Kate kpp to some

898
00:40:15,490 --> 00:40:20,620
extent also there was some publicly

899
00:40:17,770 --> 00:40:24,700
known complete fairly complete by

900
00:40:20,620 --> 00:40:27,790
palaces of it so their fourth stage

901
00:40:24,700 --> 00:40:29,080
obviously they did a lot of implanting

902
00:40:27,790 --> 00:40:31,060
malware and stuff like that but we're

903
00:40:29,080 --> 00:40:32,950
really only interested in weakening the

904
00:40:31,060 --> 00:40:35,100
kernel because that's what's relevant to

905
00:40:32,950 --> 00:40:37,180
our talk so the first thing they do is

906
00:40:35,100 --> 00:40:40,060
instead of relying on their rock chain

907
00:40:37,180 --> 00:40:42,520
any further they get kernel tasks the

908
00:40:40,060 --> 00:40:45,880
way they do that is they patch the code

909
00:40:42,520 --> 00:40:49,540
in the kernel temporarily the task for

910
00:40:45,880 --> 00:40:51,070
bid functions so that they could perform

911
00:40:49,540 --> 00:40:53,680
that and get kernel tasks back into

912
00:40:51,070 --> 00:40:55,720
their process they escalate their own

913
00:40:53,680 --> 00:40:59,919
process to root by doing another kernel

914
00:40:55,720 --> 00:41:03,850
code patch on to set our a UID system

915
00:40:59,920 --> 00:41:05,319
call they then would go and beta

916
00:41:03,850 --> 00:41:10,359
basically new to

917
00:41:05,319 --> 00:41:13,329
the sandbox by modifying a policy that

918
00:41:10,359 --> 00:41:14,049
the sandbox installs disabled

919
00:41:13,329 --> 00:41:17,829
code-signing

920
00:41:14,049 --> 00:41:21,069
which is again they did by setting a

921
00:41:17,829 --> 00:41:24,279
couple of global variables and also some

922
00:41:21,069 --> 00:41:26,349
code patches in VM map enter and VM map

923
00:41:24,279 --> 00:41:29,650
protect which is that should have been

924
00:41:26,349 --> 00:41:33,009
VM fault enter sorry which is which is

925
00:41:29,650 --> 00:41:36,789
basically the entry points at which code

926
00:41:33,009 --> 00:41:38,680
signing at the time would you know

927
00:41:36,789 --> 00:41:41,380
examine pages and decide whether they're

928
00:41:38,680 --> 00:41:43,598
allowed to be mapped in or not lastly

929
00:41:41,380 --> 00:41:45,809
they would remap the the root file

930
00:41:43,599 --> 00:41:49,059
system with readwrite access which

931
00:41:45,809 --> 00:41:51,069
basically back then involved patching a

932
00:41:49,059 --> 00:41:59,499
partition array in one of the kernel

933
00:41:51,069 --> 00:42:01,269
extensions for stage 5 again the root

934
00:41:59,499 --> 00:42:03,368
filesystem back then was read-only but

935
00:42:01,269 --> 00:42:09,189
it wasn't really protected once you had

936
00:42:03,369 --> 00:42:11,410
tough app it 0 so in in in their

937
00:42:09,190 --> 00:42:13,209
persistence strategy basically what they

938
00:42:11,410 --> 00:42:15,160
did is they replaced a system binary

939
00:42:13,209 --> 00:42:18,368
with another Apple signed binary called

940
00:42:15,160 --> 00:42:20,078
JSC this is a JavaScript core

941
00:42:18,369 --> 00:42:23,789
command-line tool which is sort of a

942
00:42:20,079 --> 00:42:26,259
developer and debugging tool that Apple

943
00:42:23,789 --> 00:42:28,569
considered trusted at the time and

944
00:42:26,259 --> 00:42:31,299
essentially it's it's essentially the

945
00:42:28,569 --> 00:42:35,499
JavaScript engine from from from WebKit

946
00:42:31,299 --> 00:42:40,029
from Safari except that it also has some

947
00:42:35,499 --> 00:42:41,919
debugging like features and as a result

948
00:42:40,029 --> 00:42:44,349
of being a developer to all the code was

949
00:42:41,920 --> 00:42:47,289
subject to much less security scrutiny

950
00:42:44,349 --> 00:42:49,509
so it had some a lot a lot easier bugs

951
00:42:47,289 --> 00:42:53,369
than the actual JSC engine that's in

952
00:42:49,509 --> 00:42:56,799
WebKit so basically they would replace a

953
00:42:53,369 --> 00:43:00,069
binary one of the startup wineries on on

954
00:42:56,799 --> 00:43:02,469
disk with the JSC binary they can

955
00:43:00,069 --> 00:43:04,359
essentially then run a javascript file

956
00:43:02,469 --> 00:43:06,219
at boot they would exploit a

957
00:43:04,359 --> 00:43:08,078
vulnerability that they found you know

958
00:43:06,219 --> 00:43:11,650
in a function called set impure get a

959
00:43:08,079 --> 00:43:14,109
delegate and then that was a type

960
00:43:11,650 --> 00:43:18,700
confusion much like the other one and

961
00:43:14,109 --> 00:43:20,259
then exploit similarly to have

962
00:43:18,700 --> 00:43:22,210
exploited the other one it should be

963
00:43:20,260 --> 00:43:24,670
noted that the JSC binary also has to

964
00:43:22,210 --> 00:43:26,079
run unsigned code entitlement so again

965
00:43:24,670 --> 00:43:28,329
by exploiting this this is a very

966
00:43:26,079 --> 00:43:33,579
attractive target because you don't have

967
00:43:28,329 --> 00:43:36,510
to get around code signing so that's

968
00:43:33,579 --> 00:43:39,880
essentially how they did it back then a

969
00:43:36,510 --> 00:43:42,550
lot of things have changed in spaces iOS

970
00:43:39,880 --> 00:43:44,470
10 11 and 12 have added in a lot of new

971
00:43:42,550 --> 00:43:47,619
protections in various different areas

972
00:43:44,470 --> 00:43:50,348
and I've gone over a lot of those

973
00:43:47,619 --> 00:43:53,880
protections there's been some level of

974
00:43:50,349 --> 00:43:58,510
kernel heap hardening the Safari chip

975
00:43:53,880 --> 00:44:01,030
hardening the Safari Giga cage and then

976
00:43:58,510 --> 00:44:03,609
Katie RR introduction of the Apple file

977
00:44:01,030 --> 00:44:05,859
system and of course the pea map

978
00:44:03,609 --> 00:44:08,230
protected layer ppl and pointer

979
00:44:05,859 --> 00:44:11,730
authentication which is the things I

980
00:44:08,230 --> 00:44:11,730
talked about in the first section

981
00:44:12,690 --> 00:44:17,290
many of these mitigations have been

982
00:44:15,190 --> 00:44:19,060
talked about at length in the past and

983
00:44:17,290 --> 00:44:22,210
if you want to learn the machinery of

984
00:44:19,060 --> 00:44:23,109
how they all work Luca Tedesco did a

985
00:44:22,210 --> 00:44:25,500
really good talk

986
00:44:23,109 --> 00:44:28,630
last year and I've put a link up there

987
00:44:25,500 --> 00:44:30,460
the new mitigations with a 12 have not

988
00:44:28,630 --> 00:44:33,220
been talked about a great deal because

989
00:44:30,460 --> 00:44:35,680
they're new but they're going to be

990
00:44:33,220 --> 00:44:38,200
talked about at length over the over the

991
00:44:35,680 --> 00:44:40,240
next year and I'm sure blaka

992
00:44:38,200 --> 00:44:42,700
is gonna be full of of talks about these

993
00:44:40,240 --> 00:44:43,990
mitigations having said that there's a

994
00:44:42,700 --> 00:44:47,009
little bit of discussion available

995
00:44:43,990 --> 00:44:50,379
online there's a really good pack

996
00:44:47,010 --> 00:44:53,670
discussion by Brendon hazard at project

997
00:44:50,380 --> 00:44:58,200
zero that I put a link to there and

998
00:44:53,670 --> 00:45:01,180
there's a very brief overview of ppl

999
00:44:58,200 --> 00:45:02,828
available at the link I've put there ppl

1000
00:45:01,180 --> 00:45:05,470
has been barely mentioned at all in

1001
00:45:02,829 --> 00:45:09,849
public and is an interesting area for

1002
00:45:05,470 --> 00:45:13,000
further research so the biggest changes

1003
00:45:09,849 --> 00:45:15,369
in the post Pegasus world are Safari

1004
00:45:13,000 --> 00:45:18,280
exploit mitigations refinements which

1005
00:45:15,369 --> 00:45:20,170
affect our stage 1 the safari sandbox is

1006
00:45:18,280 --> 00:45:23,770
always getting tightened or restricting

1007
00:45:20,170 --> 00:45:28,810
your ability to do kernel exploits or to

1008
00:45:23,770 --> 00:45:31,520
reach vulnerable kernel code kernel

1009
00:45:28,810 --> 00:45:34,970
exploit mitigation refinements and

1010
00:45:31,520 --> 00:45:37,550
runtime integrity mitigations at this

1011
00:45:34,970 --> 00:45:40,700
point in speech I discovered about

1012
00:45:37,550 --> 00:45:42,860
SmartArt in PowerPoint and I thought it

1013
00:45:40,700 --> 00:45:44,660
looked way better than point slides so

1014
00:45:42,860 --> 00:45:49,070
basically all the rest of my slides look

1015
00:45:44,660 --> 00:45:55,850
awesome actually I found out about it

1016
00:45:49,070 --> 00:45:57,470
back here so with Safari hacking I've

1017
00:45:55,850 --> 00:46:02,630
gone through most of these already but

1018
00:45:57,470 --> 00:46:05,419
iOS 10 introduced the dual the dual

1019
00:46:02,630 --> 00:46:09,410
mapping went from the dual mapping thing

1020
00:46:05,420 --> 00:46:14,600
to the fast permission switching which

1021
00:46:09,410 --> 00:46:16,790
became a thing in iOS 11 again this is

1022
00:46:14,600 --> 00:46:19,490
to prevent the strategy exactly the

1023
00:46:16,790 --> 00:46:22,460
strategy the Pegasus used which is get a

1024
00:46:19,490 --> 00:46:24,439
you know run a JavaScript function a lot

1025
00:46:22,460 --> 00:46:26,720
of times to get it entered into the jet

1026
00:46:24,440 --> 00:46:29,720
find the pointer to the jet code and

1027
00:46:26,720 --> 00:46:31,279
then and then just overwrite the

1028
00:46:29,720 --> 00:46:33,290
destination with whatever code you want

1029
00:46:31,280 --> 00:46:35,030
this is a very common strategy and so

1030
00:46:33,290 --> 00:46:38,240
these jet mitigations are intended to

1031
00:46:35,030 --> 00:46:39,680
make that more difficult so that

1032
00:46:38,240 --> 00:46:44,810
complicates the arbitrary execution

1033
00:46:39,680 --> 00:46:48,560
stage the gig occasion is an isolated

1034
00:46:44,810 --> 00:46:51,320
heat mitigation that got added in in iOS

1035
00:46:48,560 --> 00:46:54,259
11 and this makes it very difficult to

1036
00:46:51,320 --> 00:46:56,030
exploit use after free vulnerabilities

1037
00:46:54,260 --> 00:46:58,820
and type confusions and think things

1038
00:46:56,030 --> 00:47:00,920
like that particularly because it

1039
00:46:58,820 --> 00:47:04,400
prevents you from being able to map

1040
00:47:00,920 --> 00:47:06,230
essentially arbitrary data over you know

1041
00:47:04,400 --> 00:47:09,650
what was previously a data structure

1042
00:47:06,230 --> 00:47:11,510
full of pointers and when you can't do

1043
00:47:09,650 --> 00:47:13,580
that then your ability to exploit some

1044
00:47:11,510 --> 00:47:18,050
of these vulnerabilities is is

1045
00:47:13,580 --> 00:47:22,990
restricted and then iOS 12 on the a12 s

1046
00:47:18,050 --> 00:47:22,990
at least prevents rhop with with pact

1047
00:47:24,280 --> 00:47:28,880
there's been various kernel hardening

1048
00:47:26,990 --> 00:47:31,180
mitigations the most important one that

1049
00:47:28,880 --> 00:47:33,500
I wanted to make sure I mentioned was

1050
00:47:31,180 --> 00:47:35,000
something I mentioned in passing in the

1051
00:47:33,500 --> 00:47:39,080
first section which is freeing to the

1052
00:47:35,000 --> 00:47:43,340
wrong zone so essentially the way that

1053
00:47:39,080 --> 00:47:45,100
the kernel API works in in iOS the

1054
00:47:43,340 --> 00:47:47,380
kernel allocator API is

1055
00:47:45,100 --> 00:47:49,690
you would specify a size that you wanted

1056
00:47:47,380 --> 00:47:51,250
to allocate in the allocation of

1057
00:47:49,690 --> 00:47:53,080
something and you would also specify it

1058
00:47:51,250 --> 00:47:55,690
when you're freeing it and it would use

1059
00:47:53,080 --> 00:47:57,549
that size to decide what zone it's what

1060
00:47:55,690 --> 00:48:03,550
zone it's going to go to in many cases

1061
00:47:57,550 --> 00:48:05,080
so essentially again Stefan Esther has

1062
00:48:03,550 --> 00:48:07,840
talked about the kernel heap in great

1063
00:48:05,080 --> 00:48:09,400
detail but there's basically different

1064
00:48:07,840 --> 00:48:12,760
areas of memory that are reserved for

1065
00:48:09,400 --> 00:48:17,280
different sized allocations and so

1066
00:48:12,760 --> 00:48:22,660
obviously if you got say a 16 byte block

1067
00:48:17,280 --> 00:48:25,030
accidentally freed to a 64 byte zone the

1068
00:48:22,660 --> 00:48:27,250
next person that allocates a 64 byte

1069
00:48:25,030 --> 00:48:29,200
allocation is going to get that 16 byte

1070
00:48:27,250 --> 00:48:31,390
block back and you can trigger that

1071
00:48:29,200 --> 00:48:33,460
vulnerability to then work it into an

1072
00:48:31,390 --> 00:48:38,589
overflow and do something useful

1073
00:48:33,460 --> 00:48:40,240
so they've eliminated that also by also

1074
00:48:38,590 --> 00:48:42,940
as an exploitation technique it was

1075
00:48:40,240 --> 00:48:45,910
quite useful because you know if you

1076
00:48:42,940 --> 00:48:48,370
overrode a data structure and such that

1077
00:48:45,910 --> 00:48:50,589
you got you know you override a pointer

1078
00:48:48,370 --> 00:48:52,900
and get it freed to the wrong zone then

1079
00:48:50,590 --> 00:48:54,850
you might be able to get it allocated

1080
00:48:52,900 --> 00:48:58,240
into a different zone that you weren't

1081
00:48:54,850 --> 00:49:00,640
easily able to access before and then

1082
00:48:58,240 --> 00:49:04,180
and then do some memory corruption in

1083
00:49:00,640 --> 00:49:08,400
that zone they also did a number of

1084
00:49:04,180 --> 00:49:10,330
metadata heap hardening techniques which

1085
00:49:08,400 --> 00:49:14,830
again has been talked about at length

1086
00:49:10,330 --> 00:49:17,220
but more or less moved metadata out of

1087
00:49:14,830 --> 00:49:23,500
the actual zone and into its own

1088
00:49:17,220 --> 00:49:26,709
isolated zone runtime integrity is the

1089
00:49:23,500 --> 00:49:29,770
thing that I think has changed the most

1090
00:49:26,710 --> 00:49:31,420
in the last few years remember the first

1091
00:49:29,770 --> 00:49:33,450
goal of a jailbreak is to compromise the

1092
00:49:31,420 --> 00:49:36,910
runtime and that took four stages to do

1093
00:49:33,450 --> 00:49:38,500
pre iOS 9 run time integrity was

1094
00:49:36,910 --> 00:49:41,770
completely undermined once you've got

1095
00:49:38,500 --> 00:49:43,210
task for pit zero basically once you've

1096
00:49:41,770 --> 00:49:45,100
got read and write access to kernel

1097
00:49:43,210 --> 00:49:48,010
memory you can patch the kernel you can

1098
00:49:45,100 --> 00:49:49,720
run arbitrary kernel code you can change

1099
00:49:48,010 --> 00:49:52,180
page permissions you can do anything you

1100
00:49:49,720 --> 00:49:53,859
want you can and that would also imply

1101
00:49:52,180 --> 00:49:56,950
that you could run arbitrary user mode

1102
00:49:53,860 --> 00:49:59,190
code because you could modify the trust

1103
00:49:56,950 --> 00:50:01,899
cache which is used to validate

1104
00:49:59,190 --> 00:50:04,870
you know system binary is so you could

1105
00:50:01,900 --> 00:50:06,040
add your own so you could run any binary

1106
00:50:04,870 --> 00:50:07,750
you want you could remove code

1107
00:50:06,040 --> 00:50:09,490
signatures you could replace them you

1108
00:50:07,750 --> 00:50:10,830
could inject entitlements all that kind

1109
00:50:09,490 --> 00:50:13,240
of thing

1110
00:50:10,830 --> 00:50:16,150
Apple is trying to address this

1111
00:50:13,240 --> 00:50:17,890
shortcoming quite aggressively and this

1112
00:50:16,150 --> 00:50:19,630
is the sort of environment presentation

1113
00:50:17,890 --> 00:50:24,700
stuff that I was kind of talking about

1114
00:50:19,630 --> 00:50:29,010
in the first section so this is another

1115
00:50:24,700 --> 00:50:32,830
awesome smart by the way so basically

1116
00:50:29,010 --> 00:50:37,630
with the a9 is the iOS 9 is where they

1117
00:50:32,830 --> 00:50:39,100
started started trying to do this and

1118
00:50:37,630 --> 00:50:41,680
that and the first attempt was with

1119
00:50:39,100 --> 00:50:44,580
kernel patch protection which again was

1120
00:50:41,680 --> 00:50:47,080
a hypervisor type technology that would

1121
00:50:44,580 --> 00:50:50,020
infrequently validate parts of the

1122
00:50:47,080 --> 00:50:54,279
kernel and cause a panic if any of the

1123
00:50:50,020 --> 00:50:56,350
kernel code had been modified so this

1124
00:50:54,280 --> 00:50:58,090
was a problem but you could sort of work

1125
00:50:56,350 --> 00:51:00,000
around it by temporary patching which is

1126
00:50:58,090 --> 00:51:04,060
what a lot of jail breaks sort of did

1127
00:51:00,000 --> 00:51:05,590
there was also a couple of bypasses that

1128
00:51:04,060 --> 00:51:08,350
have been published in particularly

1129
00:51:05,590 --> 00:51:12,520
Pangu mentioned one of them in a talk

1130
00:51:08,350 --> 00:51:15,360
that I that I gave a link to earlier the

1131
00:51:12,520 --> 00:51:17,259
a-10 then changed that and and

1132
00:51:15,360 --> 00:51:19,750
introduced in a new feature called

1133
00:51:17,260 --> 00:51:24,460
kernel text read-only region or ktdrr

1134
00:51:19,750 --> 00:51:29,410
which is intended to replace kpp this

1135
00:51:24,460 --> 00:51:31,930
one was much more a much more complete

1136
00:51:29,410 --> 00:51:34,420
solution you could basically set up a

1137
00:51:31,930 --> 00:51:37,419
kernel region in memory at early boot

1138
00:51:34,420 --> 00:51:39,010
and then say ok this can never be this

1139
00:51:37,420 --> 00:51:42,700
can never be written to from now on and

1140
00:51:39,010 --> 00:51:45,670
so the kernel text and the text segment

1141
00:51:42,700 --> 00:51:49,600
and executable code basically can't be

1142
00:51:45,670 --> 00:51:51,820
modified after that and so basically

1143
00:51:49,600 --> 00:51:53,620
that was a real problem because it

1144
00:51:51,820 --> 00:51:56,560
essentially means that even with tasks

1145
00:51:53,620 --> 00:51:58,240
for pin 0 you can't execute kernel code

1146
00:51:56,560 --> 00:52:02,920
anymore and you have to rely on kernel

1147
00:51:58,240 --> 00:52:05,680
rock which is not very nice and then the

1148
00:52:02,920 --> 00:52:08,320
a12 switch came out just late last year

1149
00:52:05,680 --> 00:52:12,480
in September they took this one step

1150
00:52:08,320 --> 00:52:14,190
further and added pack and

1151
00:52:12,480 --> 00:52:16,019
this now means that not only can you not

1152
00:52:14,190 --> 00:52:18,569
do kind of Rob even if you've got full

1153
00:52:16,019 --> 00:52:21,089
read/write access to kernel memory but

1154
00:52:18,569 --> 00:52:25,140
you need to buy a pack bypass enable to

1155
00:52:21,089 --> 00:52:28,230
even do kernel Rock so this makes it

1156
00:52:25,140 --> 00:52:32,640
really difficult to actually execute any

1157
00:52:28,230 --> 00:52:35,190
code in the context of the kernel the

1158
00:52:32,640 --> 00:52:38,129
other thing is injecting into user mode

1159
00:52:35,190 --> 00:52:40,109
is is also now quite difficult because

1160
00:52:38,130 --> 00:52:42,440
you can't easily run unsigned code

1161
00:52:40,109 --> 00:52:45,808
because the critical data structures

1162
00:52:42,440 --> 00:52:47,700
managing you know the code signatures

1163
00:52:45,809 --> 00:52:50,759
and page tables and things like that and

1164
00:52:47,700 --> 00:52:56,848
now protected by the ppl region which

1165
00:52:50,759 --> 00:52:59,250
even if even if you could Rob you you

1166
00:52:56,849 --> 00:53:01,170
can't just arbitrarily modify the kernel

1167
00:52:59,250 --> 00:53:03,180
data structures that you need to you

1168
00:53:01,170 --> 00:53:04,920
need to find a bypass in ppl you

1169
00:53:03,180 --> 00:53:07,348
basically need to find an entry point a

1170
00:53:04,920 --> 00:53:11,069
defined entry point in ppl that will

1171
00:53:07,349 --> 00:53:14,910
allow you to you know modify the trust

1172
00:53:11,069 --> 00:53:17,940
case or do arbitrary code manipulation

1173
00:53:14,910 --> 00:53:19,109
so this is our solution I don't know

1174
00:53:17,940 --> 00:53:21,269
what you guys are going to do but I'm

1175
00:53:19,109 --> 00:53:26,819
just gonna ask Cyril and Taji for the

1176
00:53:21,269 --> 00:53:29,008
answer for bypassing PAC so if you look

1177
00:53:26,819 --> 00:53:31,470
at how Pegasus worked and Pegasus was

1178
00:53:29,009 --> 00:53:33,769
only two years old the structural

1179
00:53:31,470 --> 00:53:36,089
changes that Apple have made have really

1180
00:53:33,769 --> 00:53:39,000
significantly impacted how a jailbreak

1181
00:53:36,089 --> 00:53:41,038
might work they used to gain code

1182
00:53:39,000 --> 00:53:42,569
execution just writing to the jet now

1183
00:53:41,039 --> 00:53:45,359
they have to worry about bulletproof jet

1184
00:53:42,569 --> 00:53:46,950
to get around that they used to do a V

1185
00:53:45,359 --> 00:53:49,500
table overwrite which is effectively

1186
00:53:46,950 --> 00:53:52,618
mitigated by pack they have they

1187
00:53:49,500 --> 00:53:55,289
previously installed Rob backdoors to

1188
00:53:52,619 --> 00:53:58,619
get started again pack is a problem

1189
00:53:55,289 --> 00:54:01,289
they're when they're weakening the the

1190
00:53:58,619 --> 00:54:04,200
controls for the system they did

1191
00:54:01,289 --> 00:54:06,869
multiple kernel patches now no longer an

1192
00:54:04,200 --> 00:54:08,368
option because KTR are remounting the

1193
00:54:06,869 --> 00:54:13,079
file system they have to get around the

1194
00:54:08,369 --> 00:54:14,849
AP FS integrity stuff and to backdoor

1195
00:54:13,079 --> 00:54:17,460
any user mode processes they now need a

1196
00:54:14,849 --> 00:54:20,309
ppl bypass and the other thing worth

1197
00:54:17,460 --> 00:54:22,440
noting is that JSC has been removed from

1198
00:54:20,309 --> 00:54:25,650
apple's trust case which means it's no

1199
00:54:22,440 --> 00:54:29,220
longer considered a trusted binary

1200
00:54:25,650 --> 00:54:34,200
much to the chagrin of many jailbreakers

1201
00:54:29,220 --> 00:54:37,319
so if you look at the iOS 9 jailbreak it

1202
00:54:34,200 --> 00:54:39,689
was a difficult task you needed Safari

1203
00:54:37,320 --> 00:54:42,930
possibly a sandbox escape kernel

1204
00:54:39,690 --> 00:54:44,970
maybe kpp bypass and persistence but if

1205
00:54:42,930 --> 00:54:46,830
you compare it to what we have today you

1206
00:54:44,970 --> 00:54:49,379
need to do all of those things plus a

1207
00:54:46,830 --> 00:54:51,990
bulletproof kit bypass a user mode pack

1208
00:54:49,380 --> 00:54:55,770
bypass potentially a kernel mode pack

1209
00:54:51,990 --> 00:54:59,060
bypass potentially ppl bypass and a PFS

1210
00:54:55,770 --> 00:55:02,940
remounting bug in order for persistence

1211
00:54:59,060 --> 00:55:05,790
so in summary it's always been a

1212
00:55:02,940 --> 00:55:08,700
difficult task to jailbreak an iPhone

1213
00:55:05,790 --> 00:55:11,490
but in particular with the recent

1214
00:55:08,700 --> 00:55:13,980
mitigations especially the a12 a full

1215
00:55:11,490 --> 00:55:18,390
compromise of the ecosystem is is really

1216
00:55:13,980 --> 00:55:20,730
difficult you know often your combined

1217
00:55:18,390 --> 00:55:22,410
to confined to rhop and don't have the

1218
00:55:20,730 --> 00:55:27,020
ability to do unconstrained code

1219
00:55:22,410 --> 00:55:29,310
execution and even then pack and ppl

1220
00:55:27,020 --> 00:55:32,009
once they have matured a little further

1221
00:55:29,310 --> 00:55:34,130
are going to represent a very

1222
00:55:32,010 --> 00:55:37,410
significant barrier to even doing that

1223
00:55:34,130 --> 00:55:40,050
so I think in the future we're going to

1224
00:55:37,410 --> 00:55:43,020
likely see increasingly relying on data

1225
00:55:40,050 --> 00:55:45,780
only attacks programming weird machines

1226
00:55:43,020 --> 00:55:47,759
and things like that and I expect in

1227
00:55:45,780 --> 00:55:50,520
turn that Apple will have newer

1228
00:55:47,760 --> 00:55:54,690
mitigations that will expand on this by

1229
00:55:50,520 --> 00:55:56,790
verifying data structure integrity and

1230
00:55:54,690 --> 00:55:58,800
you know making sure that you can't

1231
00:55:56,790 --> 00:56:00,390
modify critical data structures or that

1232
00:55:58,800 --> 00:56:03,470
they detect and panic or something along

1233
00:56:00,390 --> 00:56:06,299
those lines so that's the end of my talk

1234
00:56:03,470 --> 00:56:10,250
thanks for listening and if anyone has

1235
00:56:06,300 --> 00:56:10,250
any questions I can take them now

1236
00:56:14,270 --> 00:56:16,330
you

