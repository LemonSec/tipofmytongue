1
00:00:01,540 --> 00:00:07,029
right now we have a great speaker a

2
00:00:04,380 --> 00:00:08,710
Canberra local we have Adrian Herrera

3
00:00:07,029 --> 00:00:11,080
talking about diab for skating

4
00:00:08,710 --> 00:00:13,500
JavaScript malware so let's welcome him

5
00:00:11,080 --> 00:00:13,500
to the stage

6
00:00:16,530 --> 00:00:21,970
boom thank you thank you for sticking

7
00:00:19,390 --> 00:00:23,410
around and I'll try not to get it into

8
00:00:21,970 --> 00:00:26,590
too much of the lunch break

9
00:00:23,410 --> 00:00:29,109
weave my talk alright so yes Silvie I

10
00:00:26,590 --> 00:00:32,349
said I'm here to talk about JavaScript

11
00:00:29,109 --> 00:00:35,350
and specifically deal for skating ugly

12
00:00:32,348 --> 00:00:38,229
JavaScript malware all right so a little

13
00:00:35,350 --> 00:00:41,440
bit about myself so I wear two kind of

14
00:00:38,229 --> 00:00:43,388
hats in my day job one hat I'm a

15
00:00:41,440 --> 00:00:46,599
researcher with the defense Science and

16
00:00:43,389 --> 00:00:49,539
Technology Group here in Canberra and my

17
00:00:46,600 --> 00:00:52,600
other hat is my academic hat and I've

18
00:00:49,539 --> 00:00:55,299
recently started a PhD at the ANU also

19
00:00:52,600 --> 00:00:57,449
here in Canberra and my my manga

20
00:00:55,299 --> 00:01:00,010
research is around reverse engineering

21
00:00:57,449 --> 00:01:02,260
and applying what science program

22
00:01:00,010 --> 00:01:07,179
analysis to reverse engineering problems

23
00:01:02,260 --> 00:01:10,480
and today is one example of that alright

24
00:01:07,180 --> 00:01:11,890
so I'm not a JavaScript dev at all in

25
00:01:10,480 --> 00:01:13,300
fact I kind of just learned how to write

26
00:01:11,890 --> 00:01:16,240
JavaScript this week when I was

27
00:01:13,300 --> 00:01:18,880
preparing for this talk but I'm told

28
00:01:16,240 --> 00:01:20,520
there's very widely used and there are

29
00:01:18,880 --> 00:01:23,170
lots of different frameworks out there

30
00:01:20,520 --> 00:01:25,119
lots of different you know tough forms

31
00:01:23,170 --> 00:01:34,330
and tools and things for JavaScript and

32
00:01:25,120 --> 00:01:36,870
that's kind of what's happened let's

33
00:01:34,330 --> 00:01:36,870
bring that back up

34
00:01:40,180 --> 00:01:44,470
yes all right we're back that's not

35
00:01:41,980 --> 00:01:46,270
really the focus of today's talk what

36
00:01:44,470 --> 00:01:49,929
I'm more interested into talking about

37
00:01:46,270 --> 00:01:52,479
is this kind of JavaScript which is a

38
00:01:49,930 --> 00:01:54,670
malware sample that does some malicious

39
00:01:52,480 --> 00:01:56,920
stuff and has been heavily obfuscated by

40
00:01:54,670 --> 00:01:58,750
the author to make the reverse

41
00:01:56,920 --> 00:02:02,200
engineering process by the malware and

42
00:01:58,750 --> 00:02:05,620
it'll analyst really hard so I've kind

43
00:02:02,200 --> 00:02:07,480
of cut the sample off a bit to display

44
00:02:05,620 --> 00:02:09,880
it on the slide but if we look at the

45
00:02:07,480 --> 00:02:19,620
full thing here believe make this a bit

46
00:02:09,880 --> 00:02:19,620
bigger this one this one

47
00:02:24,800 --> 00:02:30,110
right so this is their original sample

48
00:02:27,050 --> 00:02:32,270
here and yeah it's pretty hard to make

49
00:02:30,110 --> 00:02:35,170
sense of it keeps going on and on and on

50
00:02:32,270 --> 00:02:39,110
and our aim is to apply static analysis

51
00:02:35,170 --> 00:02:41,209
to this kind of malware - you know strip

52
00:02:39,110 --> 00:02:43,430
it back to its bare minimum and figure

53
00:02:41,210 --> 00:02:45,470
out what it's doing so yeah so the

54
00:02:43,430 --> 00:02:48,100
ultimate aim is to make this kind of

55
00:02:45,470 --> 00:02:50,540
thing more readable to learn our analyst

56
00:02:48,100 --> 00:02:51,920
so why do we want to do this well if

57
00:02:50,540 --> 00:02:53,600
you're at mirror analyst you already

58
00:02:51,920 --> 00:02:55,459
kind of know that obfuscation you know

59
00:02:53,600 --> 00:02:58,400
hinders your analysis and makes it

60
00:02:55,460 --> 00:03:01,250
harder makes it more time-consuming it

61
00:02:58,400 --> 00:03:03,440
makes it just life a lot tougher and

62
00:03:01,250 --> 00:03:04,880
this is not just true of like JavaScript

63
00:03:03,440 --> 00:03:08,420
and scripting languages but you know you

64
00:03:04,880 --> 00:03:10,549
can you can obfuscate binaries and you

65
00:03:08,420 --> 00:03:12,380
can of the scape scripting languages

66
00:03:10,550 --> 00:03:15,860
other than Java Script so this is I

67
00:03:12,380 --> 00:03:17,210
believe vbscript it's pretty tricky to

68
00:03:15,860 --> 00:03:19,880
read it's not really clear what it's

69
00:03:17,210 --> 00:03:21,430
doing I guess other than the name start

70
00:03:19,880 --> 00:03:23,540
exploit maybe gives you some indication

71
00:03:21,430 --> 00:03:25,280
but other than that it's kind of tricky

72
00:03:23,540 --> 00:03:27,290
to understand what it's doing and then

73
00:03:25,280 --> 00:03:29,180
of course there's JavaScript as well so

74
00:03:27,290 --> 00:03:30,799
you know if I'm malware or thought and I

75
00:03:29,180 --> 00:03:32,420
want to make it hard for the analyst I

76
00:03:30,800 --> 00:03:36,080
would apply all these different kinds of

77
00:03:32,420 --> 00:03:39,350
escaping techniques and we want to kind

78
00:03:36,080 --> 00:03:41,570
of undo all of that work all right

79
00:03:39,350 --> 00:03:44,060
so the approach that I took when

80
00:03:41,570 --> 00:03:46,579
building a tool for Java skating

81
00:03:44,060 --> 00:03:50,180
JavaScript was to borrow a bunch of

82
00:03:46,580 --> 00:03:53,870
ideas from compiler theory and and apply

83
00:03:50,180 --> 00:03:55,610
them to the deification process and so a

84
00:03:53,870 --> 00:03:57,620
bit different to compiler theory you

85
00:03:55,610 --> 00:03:59,690
know instead with compilers we're trying

86
00:03:57,620 --> 00:04:01,940
to generate executable code at the end

87
00:03:59,690 --> 00:04:05,350
of it here we're trying to essentially

88
00:04:01,940 --> 00:04:09,709
get more readable source code instead

89
00:04:05,350 --> 00:04:11,780
and so what else are our goals so I I've

90
00:04:09,709 --> 00:04:13,400
got here you know focus on semantic

91
00:04:11,780 --> 00:04:15,709
transformations and what I mean by this

92
00:04:13,400 --> 00:04:17,540
is that we can you know there are a

93
00:04:15,709 --> 00:04:21,079
bunch of tools already out there that

94
00:04:17,540 --> 00:04:24,370
allow us to preprint source code so one

95
00:04:21,079 --> 00:04:27,050
of them for javascript is uglify yes

96
00:04:24,370 --> 00:04:29,540
which is the one I kind of accidentally

97
00:04:27,050 --> 00:04:31,550
did before and so you know by pretty

98
00:04:29,540 --> 00:04:34,700
printing I mean inserting white space

99
00:04:31,550 --> 00:04:36,620
indentation and new lines to make it you

100
00:04:34,700 --> 00:04:38,420
know more easier to read but it's still

101
00:04:36,620 --> 00:04:39,620
kind of hard to figure out what it

102
00:04:38,420 --> 00:04:42,290
doing there's still a lot of curried

103
00:04:39,620 --> 00:04:44,570
there to try and to try and get an

104
00:04:42,290 --> 00:04:45,830
understanding of so we're not really

105
00:04:44,570 --> 00:04:48,440
interested in that what we're interested

106
00:04:45,830 --> 00:04:50,870
in is doing some more I guess

107
00:04:48,440 --> 00:04:53,690
interesting transformations to to make

108
00:04:50,870 --> 00:04:56,300
this more very readable and we want to

109
00:04:53,690 --> 00:04:56,660
reuse a bunch of existing tools all

110
00:04:56,300 --> 00:04:58,250
right

111
00:04:56,660 --> 00:05:00,500
so for those who haven't studied

112
00:04:58,250 --> 00:05:02,090
compilers before or for those who have

113
00:05:00,500 --> 00:05:05,060
maybe you've seen a similar kind of

114
00:05:02,090 --> 00:05:07,159
diagram to this in a compilers course

115
00:05:05,060 --> 00:05:10,010
but this is a typical compiler workflow

116
00:05:07,160 --> 00:05:12,250
it starts with the lexer or the

117
00:05:10,010 --> 00:05:16,280
tokenizer which takes your source code

118
00:05:12,250 --> 00:05:18,110
breaks it up into tokens and assign some

119
00:05:16,280 --> 00:05:20,330
products and kind of category to those

120
00:05:18,110 --> 00:05:22,340
tokens so maybe you've got you know

121
00:05:20,330 --> 00:05:24,979
tokens for white space you've got tokens

122
00:05:22,340 --> 00:05:27,739
for keywords you've got tokens for

123
00:05:24,980 --> 00:05:30,530
variable names etc and then that stream

124
00:05:27,740 --> 00:05:31,820
of tokens goes into the parser and the

125
00:05:30,530 --> 00:05:35,059
parser there's some more kind of

126
00:05:31,820 --> 00:05:37,840
analysis on that and generates a par 3

127
00:05:35,060 --> 00:05:40,730
based on some kind of grammar and then

128
00:05:37,840 --> 00:05:42,799
from the pass 3 we can strip away the

129
00:05:40,730 --> 00:05:46,010
uninteresting things like whitespace for

130
00:05:42,800 --> 00:05:49,190
example and we get an AST or an abstract

131
00:05:46,010 --> 00:05:52,849
syntax tree which I mentioned in his

132
00:05:49,190 --> 00:05:56,360
first talk of today and then on that ast

133
00:05:52,850 --> 00:05:58,640
we can apply various optimizations and

134
00:05:56,360 --> 00:06:00,590
for a compiler the optimizations the

135
00:05:58,640 --> 00:06:02,960
name of those optimizations is to

136
00:06:00,590 --> 00:06:04,940
produce either smaller code or faster

137
00:06:02,960 --> 00:06:06,859
code and so there a bunch of different

138
00:06:04,940 --> 00:06:09,200
tricks the compilers used to do this and

139
00:06:06,860 --> 00:06:11,540
then after we've done that we want to

140
00:06:09,200 --> 00:06:13,280
generate executable machine code so

141
00:06:11,540 --> 00:06:16,220
that's kind of a typical compiler

142
00:06:13,280 --> 00:06:18,469
workflow now how can we apply this to

143
00:06:16,220 --> 00:06:20,990
the office Kishin well it's pretty

144
00:06:18,470 --> 00:06:22,880
similar so here's another diagram we've

145
00:06:20,990 --> 00:06:24,680
got three of the same four elements that

146
00:06:22,880 --> 00:06:26,800
we saw in the previous slide so we still

147
00:06:24,680 --> 00:06:29,120
got a lexer we still got a parser

148
00:06:26,800 --> 00:06:30,530
instead of a code generator at the end

149
00:06:29,120 --> 00:06:33,350
we just want to generate source code

150
00:06:30,530 --> 00:06:37,010
back out again and now instead of

151
00:06:33,350 --> 00:06:38,540
optimizing for speed or size we kind of

152
00:06:37,010 --> 00:06:40,789
want to optimize in a sense for

153
00:06:38,540 --> 00:06:45,230
readability so this is essentially what

154
00:06:40,790 --> 00:06:48,170
deification is and the nice thing about

155
00:06:45,230 --> 00:06:49,760
you reusing this kind of workflow is

156
00:06:48,170 --> 00:06:50,990
there are already a bunch of existing

157
00:06:49,760 --> 00:06:53,090
tools

158
00:06:50,990 --> 00:06:56,210
that give us parsers and lectures and

159
00:06:53,090 --> 00:06:59,299
generators for various kind of languages

160
00:06:56,210 --> 00:07:01,609
including Java scripts all right so I

161
00:06:59,300 --> 00:07:03,140
kind of touched on this before but the

162
00:07:01,610 --> 00:07:05,150
lecture turns the characters into words

163
00:07:03,140 --> 00:07:07,310
and then the pazzo is kind of the

164
00:07:05,150 --> 00:07:09,460
interesting thing so we take that

165
00:07:07,310 --> 00:07:12,290
extreme of words we generate a par 3

166
00:07:09,460 --> 00:07:14,180
according to some grammar and then we

167
00:07:12,290 --> 00:07:17,180
discard a bunch of uninteresting things

168
00:07:14,180 --> 00:07:19,340
to get the ast and then what we want to

169
00:07:17,180 --> 00:07:20,480
do is we want to apply some sort of

170
00:07:19,340 --> 00:07:25,340
analysis and some sort of

171
00:07:20,480 --> 00:07:28,010
transformations on the ast to do a deal

172
00:07:25,340 --> 00:07:31,159
for skating all right so the tool that I

173
00:07:28,010 --> 00:07:33,409
based my work on is this one it's called

174
00:07:31,160 --> 00:07:35,930
safe it's out of a research group in

175
00:07:33,410 --> 00:07:38,720
South Korea it's essentially a

176
00:07:35,930 --> 00:07:40,640
JavaScript analysis framework it was not

177
00:07:38,720 --> 00:07:42,920
really made for the purposes of security

178
00:07:40,640 --> 00:07:45,530
but just for a generic analysis of

179
00:07:42,920 --> 00:07:47,330
JavaScript code and it already gives us

180
00:07:45,530 --> 00:07:49,909
the things that we kind of need so it

181
00:07:47,330 --> 00:07:52,219
gives us the lexer gives us the POSIX

182
00:07:49,910 --> 00:07:54,200
generator it also gives us a bunch of

183
00:07:52,220 --> 00:07:56,990
its intermediate representations so we

184
00:07:54,200 --> 00:07:59,479
can go do different kinds of analyses on

185
00:07:56,990 --> 00:08:01,450
top of those ir's but in the end I

186
00:07:59,480 --> 00:08:05,360
didn't end up using that kind of stuff

187
00:08:01,450 --> 00:08:07,909
all right so this is a snippet of the

188
00:08:05,360 --> 00:08:10,070
sample we saw at the beginning again

189
00:08:07,910 --> 00:08:12,650
chosen so I can fit it on the single

190
00:08:10,070 --> 00:08:17,120
slide and this has been pretty printed

191
00:08:12,650 --> 00:08:20,270
with a graph ideas and so what we can do

192
00:08:17,120 --> 00:08:24,050
is we can run safe over this to generate

193
00:08:20,270 --> 00:08:27,650
an ast and kind of do some analysis on

194
00:08:24,050 --> 00:08:29,810
that ast all right so this is what the

195
00:08:27,650 --> 00:08:31,909
ast would look like if we were to

196
00:08:29,810 --> 00:08:37,360
visualize it as a tree because that's

197
00:08:31,910 --> 00:08:39,560
all it is and I've got it here as well

198
00:08:37,360 --> 00:08:41,120
interactively and so we can kind of look

199
00:08:39,559 --> 00:08:44,479
at the source code here this is the same

200
00:08:41,120 --> 00:08:46,160
source code on the left and the ast is

201
00:08:44,480 --> 00:08:47,600
on the right and we can kind of match up

202
00:08:46,160 --> 00:08:51,050
the different elements in the source

203
00:08:47,600 --> 00:08:52,670
code to the nodes in the tree so you

204
00:08:51,050 --> 00:08:55,189
know at the top level we have our entire

205
00:08:52,670 --> 00:08:58,130
program our program is made up of a

206
00:08:55,190 --> 00:09:00,500
number of source elements these are two

207
00:08:58,130 --> 00:09:03,350
variables which are these two here plus

208
00:09:00,500 --> 00:09:05,660
this if statement here

209
00:09:03,350 --> 00:09:07,910
and we can you know continue expanding

210
00:09:05,660 --> 00:09:09,890
out different elements of the tree so

211
00:09:07,910 --> 00:09:13,130
this variable is this one here and it's

212
00:09:09,890 --> 00:09:18,380
been assigned the undefined value and so

213
00:09:13,130 --> 00:09:20,030
on all right so let's look at actually I

214
00:09:18,380 --> 00:09:23,030
guess the meat of this work and that is

215
00:09:20,030 --> 00:09:26,630
how we build a deal for scalar to to do

216
00:09:23,030 --> 00:09:28,850
things to this ast so if you're familiar

217
00:09:26,630 --> 00:09:32,510
with compilers again many of these kind

218
00:09:28,850 --> 00:09:34,400
of terms may look familiar so these are

219
00:09:32,510 --> 00:09:36,140
typical compiler optimization techniques

220
00:09:34,400 --> 00:09:38,569
and it turns out that we can reuse a

221
00:09:36,140 --> 00:09:40,880
bunch of them to make code easier to

222
00:09:38,570 --> 00:09:43,580
read as well so I'm not going to talk

223
00:09:40,880 --> 00:09:45,820
about all of them today I'll just talk

224
00:09:43,580 --> 00:09:48,110
about a subset of them because of time

225
00:09:45,820 --> 00:09:50,360
which is the three highlighted here and

226
00:09:48,110 --> 00:09:52,310
what we essentially do in our D

227
00:09:50,360 --> 00:09:54,170
obfuscator is we keep running and

228
00:09:52,310 --> 00:09:57,140
applying these different transformations

229
00:09:54,170 --> 00:09:58,849
over the top of our ast until the tree

230
00:09:57,140 --> 00:10:00,770
stops changing or we've reached a fixed

231
00:09:58,850 --> 00:10:02,990
point and at that point we can kind of

232
00:10:00,770 --> 00:10:05,480
serialize the tree back to source code

233
00:10:02,990 --> 00:10:08,750
and hopefully at the end of it we've got

234
00:10:05,480 --> 00:10:11,300
more readable code all right so let's

235
00:10:08,750 --> 00:10:13,520
start with the simplest optimization

236
00:10:11,300 --> 00:10:15,589
which is constant folding and so a

237
00:10:13,520 --> 00:10:18,470
constant folding does is it looks for

238
00:10:15,590 --> 00:10:21,110
constant expressions in code and then

239
00:10:18,470 --> 00:10:23,810
just evaluates them statically rather

240
00:10:21,110 --> 00:10:26,930
than waiting for the code to run and to

241
00:10:23,810 --> 00:10:31,300
evaluate at runtime so if we go back to

242
00:10:26,930 --> 00:10:34,160
our example here and we change this one

243
00:10:31,300 --> 00:10:35,990
so if we look at our code here we can

244
00:10:34,160 --> 00:10:39,230
hopefully you can see a bunch of places

245
00:10:35,990 --> 00:10:40,670
where we can kind of pre evaluate what

246
00:10:39,230 --> 00:10:43,850
the result will be without actually

247
00:10:40,670 --> 00:10:46,550
having to run the code so for example in

248
00:10:43,850 --> 00:10:49,430
this if expression here we've got these

249
00:10:46,550 --> 00:10:51,829
three strings concatenated together and

250
00:10:49,430 --> 00:10:53,300
but what we can do is we can just pre

251
00:10:51,830 --> 00:10:55,100
compute this rather than doing this at

252
00:10:53,300 --> 00:10:57,890
runtime and just get a single stream

253
00:10:55,100 --> 00:11:01,700
which is easier to read and the other

254
00:10:57,890 --> 00:11:04,040
location is this one here so we have

255
00:11:01,700 --> 00:11:06,890
these two integers added together and it

256
00:11:04,040 --> 00:11:09,770
once again we can just combine them and

257
00:11:06,890 --> 00:11:13,550
spit out new code with the complaint or

258
00:11:09,770 --> 00:11:15,710
the added value of those two numbers so

259
00:11:13,550 --> 00:11:17,520
if we look at the tree and figure out

260
00:11:15,710 --> 00:11:19,670
how we're going to do this

261
00:11:17,520 --> 00:11:24,060
so if we look at this if statement here

262
00:11:19,670 --> 00:11:27,750
what that looks like in a s2 form we can

263
00:11:24,060 --> 00:11:30,780
see the tree in the if statement is made

264
00:11:27,750 --> 00:11:34,680
up of these two sub trees I guess which

265
00:11:30,780 --> 00:11:36,689
consists of two operations which are the

266
00:11:34,680 --> 00:11:38,670
addition or the concatenation I guess

267
00:11:36,690 --> 00:11:41,760
because they're strings and then we can

268
00:11:38,670 --> 00:11:46,680
see on either side of that operation we

269
00:11:41,760 --> 00:11:48,150
have two string literals and so if we if

270
00:11:46,680 --> 00:11:49,949
we recognize that pattern while we're

271
00:11:48,150 --> 00:11:52,380
walking the tree then we can essentially

272
00:11:49,950 --> 00:11:54,930
just perform that operation and replace

273
00:11:52,380 --> 00:11:57,210
this subtree here consisting of these

274
00:11:54,930 --> 00:12:00,260
three nodes with a single node which is

275
00:11:57,210 --> 00:12:03,060
the concatenation of those two strings

276
00:12:00,260 --> 00:12:04,140
all right so the slides kind of just

277
00:12:03,060 --> 00:12:07,020
repeat what I just said

278
00:12:04,140 --> 00:12:08,610
so here's the tree again and so you know

279
00:12:07,020 --> 00:12:10,680
we're running our D office Gator it's

280
00:12:08,610 --> 00:12:13,080
walking the tree it sees this kind of

281
00:12:10,680 --> 00:12:14,459
pattern and it says well they're just

282
00:12:13,080 --> 00:12:17,070
two string literals I can pre-compute

283
00:12:14,460 --> 00:12:18,840
the final value of that and then we get

284
00:12:17,070 --> 00:12:20,970
undefined

285
00:12:18,840 --> 00:12:23,940
what happens is we get a new subtree and

286
00:12:20,970 --> 00:12:26,730
once again we can pre-compute the result

287
00:12:23,940 --> 00:12:30,570
of that and we get a simplified string

288
00:12:26,730 --> 00:12:34,050
so very simple technique but it makes

289
00:12:30,570 --> 00:12:35,760
things slightly more readable so it's

290
00:12:34,050 --> 00:12:39,060
not just strings that we can do this to

291
00:12:35,760 --> 00:12:40,920
we can do this for integers so again in

292
00:12:39,060 --> 00:12:43,859
the code we had a hundred plus eighty

293
00:12:40,920 --> 00:12:46,709
eight so we can pre-compute that and get

294
00:12:43,860 --> 00:12:48,510
188 and because java scripts a terrible

295
00:12:46,710 --> 00:12:50,670
language and lets us do very terrible

296
00:12:48,510 --> 00:12:53,040
things we can have all sorts of

297
00:12:50,670 --> 00:12:56,610
different operations on different types

298
00:12:53,040 --> 00:12:59,280
of data so for the top one here we have

299
00:12:56,610 --> 00:13:00,810
a string and then int and so what

300
00:12:59,280 --> 00:13:03,420
happens if you're a JavaScript person

301
00:13:00,810 --> 00:13:04,890
you probably know that the the int

302
00:13:03,420 --> 00:13:07,620
becomes a string and then we get a

303
00:13:04,890 --> 00:13:10,290
string at the end of it what about this

304
00:13:07,620 --> 00:13:13,830
one here if we have ten - true so true

305
00:13:10,290 --> 00:13:15,750
becomes an integer value 1 and then we

306
00:13:13,830 --> 00:13:18,810
have 10 minus 1 so we can replace that

307
00:13:15,750 --> 00:13:22,350
with 9 not 1 is 0

308
00:13:18,810 --> 00:13:24,300
times that by float get 0 and this one

309
00:13:22,350 --> 00:13:26,790
here is the same as the top one just the

310
00:13:24,300 --> 00:13:29,939
types of reverse but it still we end up

311
00:13:26,790 --> 00:13:30,810
with a string and so we can encode all

312
00:13:29,940 --> 00:13:32,940
these rules

313
00:13:30,810 --> 00:13:35,699
in the obfuscator when we walk the tree

314
00:13:32,940 --> 00:13:38,700
and we just look for those that contain

315
00:13:35,700 --> 00:13:40,440
these types and you know we look up our

316
00:13:38,700 --> 00:13:43,890
rules and we say oh okay we can just

317
00:13:40,440 --> 00:13:45,330
replace this node with a simpler node

318
00:13:43,890 --> 00:13:48,689
and to do this we kind of have to

319
00:13:45,330 --> 00:13:50,010
understand what these operations mean so

320
00:13:48,690 --> 00:13:53,010
you know and this in this one this

321
00:13:50,010 --> 00:13:55,050
operator here means plus but for Strings

322
00:13:53,010 --> 00:13:57,060
that means concatenation and so this

323
00:13:55,050 --> 00:13:59,490
kind of requires I guess my point here

324
00:13:57,060 --> 00:14:01,410
is that it requires understanding of the

325
00:13:59,490 --> 00:14:04,830
semantics or what it actually means when

326
00:14:01,410 --> 00:14:11,250
you see this operator in your code all

327
00:14:04,830 --> 00:14:15,350
right so going back to our example so we

328
00:14:11,250 --> 00:14:18,660
run that and we get these collapsed

329
00:14:15,350 --> 00:14:19,890
strings here all right so how do we

330
00:14:18,660 --> 00:14:23,040
implement it I guess I've already

331
00:14:19,890 --> 00:14:24,750
described this we start with we write a

332
00:14:23,040 --> 00:14:26,849
bunch of rules we start with our root

333
00:14:24,750 --> 00:14:29,660
node in the tree we walk the tree and we

334
00:14:26,850 --> 00:14:31,920
just apply the rules to get simplified

335
00:14:29,660 --> 00:14:35,790
nodes and then we just keep recursing

336
00:14:31,920 --> 00:14:37,920
until again we reach a fixed point all

337
00:14:35,790 --> 00:14:40,260
right so that's constant folding a

338
00:14:37,920 --> 00:14:43,260
slightly different technique is constant

339
00:14:40,260 --> 00:14:45,930
propagation and so a constant folding

340
00:14:43,260 --> 00:14:48,330
looks for two literals with some

341
00:14:45,930 --> 00:14:50,670
operation applied to them constant

342
00:14:48,330 --> 00:14:53,700
propagation is that we know that a

343
00:14:50,670 --> 00:14:55,860
variable can only ever hold one value

344
00:14:53,700 --> 00:14:59,790
and therefore we can just replace every

345
00:14:55,860 --> 00:15:02,340
use of that variable with that value so

346
00:14:59,790 --> 00:15:05,640
here's our code again and if we look

347
00:15:02,340 --> 00:15:09,930
closely we can find some instances of

348
00:15:05,640 --> 00:15:11,930
where we can do this propagation which

349
00:15:09,930 --> 00:15:14,640
are here so in this function at the top

350
00:15:11,930 --> 00:15:16,469
we have this variable here which is set

351
00:15:14,640 --> 00:15:18,000
to null and then the only time that

352
00:15:16,470 --> 00:15:20,790
variable is ever used is this just

353
00:15:18,000 --> 00:15:23,070
return from that function and so we are

354
00:15:20,790 --> 00:15:26,610
we can kind of wreck it again recognize

355
00:15:23,070 --> 00:15:29,040
this pattern in the tree and just remove

356
00:15:26,610 --> 00:15:32,880
this variable and have the function just

357
00:15:29,040 --> 00:15:36,270
return null similarly here this variable

358
00:15:32,880 --> 00:15:36,660
here is only used is only written two up

359
00:15:36,270 --> 00:15:39,000
here

360
00:15:36,660 --> 00:15:40,829
it's set to undefined and it's not

361
00:15:39,000 --> 00:15:43,020
written to anywhere else in the code and

362
00:15:40,830 --> 00:15:44,760
so once again we can just replace that

363
00:15:43,020 --> 00:15:47,230
variable or to get

364
00:15:44,760 --> 00:15:50,319
all right so this is the substitution

365
00:15:47,230 --> 00:15:53,589
step so we substitute those variables

366
00:15:50,320 --> 00:15:55,240
values where they're used and then we

367
00:15:53,589 --> 00:15:57,310
can just delete those unused variables

368
00:15:55,240 --> 00:16:00,610
so once again we've removed a bunch of

369
00:15:57,310 --> 00:16:03,849
code with the aim of you know getting

370
00:16:00,610 --> 00:16:06,490
easier code to read and the the other

371
00:16:03,850 --> 00:16:09,330
benefit of this is that we can now start

372
00:16:06,490 --> 00:16:12,120
to see where we can reapply some of our

373
00:16:09,330 --> 00:16:14,830
the previous technique constant folding

374
00:16:12,120 --> 00:16:17,800
because we've now got a simpler AST so

375
00:16:14,830 --> 00:16:19,570
for example here we can make a rule in

376
00:16:17,800 --> 00:16:22,180
our constant folder to say that the type

377
00:16:19,570 --> 00:16:24,490
of undefined is the string undefined and

378
00:16:22,180 --> 00:16:26,349
so we can replace that and then we can

379
00:16:24,490 --> 00:16:29,800
have another rule that says if we have

380
00:16:26,350 --> 00:16:32,200
two strings on top of equality then we

381
00:16:29,800 --> 00:16:34,029
can just collapse that to true and then

382
00:16:32,200 --> 00:16:35,860
if we have you know if true then we know

383
00:16:34,029 --> 00:16:37,750
that that will always be the case so we

384
00:16:35,860 --> 00:16:39,910
can just remove the if condition

385
00:16:37,750 --> 00:16:42,130
altogether so you know by building this

386
00:16:39,910 --> 00:16:44,589
simple primitive we can you know keep

387
00:16:42,130 --> 00:16:48,880
applying them and stripping away the

388
00:16:44,589 --> 00:16:51,250
code to the bare minimum all right and

389
00:16:48,880 --> 00:16:52,959
then we delete darn use variables all

390
00:16:51,250 --> 00:16:55,600
right so constant propagation is a

391
00:16:52,959 --> 00:16:57,880
pretty easy idea to keep your head

392
00:16:55,600 --> 00:16:59,529
around the implementation compared to

393
00:16:57,880 --> 00:17:02,500
constant folding is a bit more trickier

394
00:16:59,529 --> 00:17:05,349
I have to pass over the ast a number of

395
00:17:02,500 --> 00:17:07,900
times one to propagate the constants and

396
00:17:05,349 --> 00:17:11,198
then go back and look for redundant

397
00:17:07,900 --> 00:17:13,270
assignments and remove them and because

398
00:17:11,199 --> 00:17:14,890
I'm a program analysis nerd this is

399
00:17:13,270 --> 00:17:17,290
implemented as an abstract

400
00:17:14,890 --> 00:17:20,980
interpretation which I won't go into the

401
00:17:17,290 --> 00:17:22,688
details of that today all right and so

402
00:17:20,980 --> 00:17:25,510
the third trick that I wanted to talk

403
00:17:22,689 --> 00:17:27,400
about is function inlining so this is

404
00:17:25,510 --> 00:17:29,740
another pretty easy one it's kind of

405
00:17:27,400 --> 00:17:31,750
obvious when you look at it so now we

406
00:17:29,740 --> 00:17:34,179
have this function here it doesn't do

407
00:17:31,750 --> 00:17:37,090
anything except for return null and so

408
00:17:34,179 --> 00:17:39,160
we can just replace any calls to this

409
00:17:37,090 --> 00:17:40,720
function with the value that it returns

410
00:17:39,160 --> 00:17:42,250
which we know is always going to be no

411
00:17:40,720 --> 00:17:45,730
and then we can just delete that

412
00:17:42,250 --> 00:17:48,250
functional together all right so it's

413
00:17:45,730 --> 00:17:50,410
called here in a switch statement so and

414
00:17:48,250 --> 00:17:53,470
we know it's always going to be null so

415
00:17:50,410 --> 00:17:56,470
we can expand it to that value that it

416
00:17:53,470 --> 00:17:57,310
returns and then we can just remove this

417
00:17:56,470 --> 00:17:58,720
function we

418
00:17:57,310 --> 00:18:01,240
it's no longer called anywhere in the

419
00:17:58,720 --> 00:18:04,000
program and so once again we've got even

420
00:18:01,240 --> 00:18:06,670
less code to look at and again we can

421
00:18:04,000 --> 00:18:08,710
apply other techniques so you know if

422
00:18:06,670 --> 00:18:11,380
we're switching on null or on a constant

423
00:18:08,710 --> 00:18:13,300
value than any of the other case cases

424
00:18:11,380 --> 00:18:15,580
in our switch statement they can never

425
00:18:13,300 --> 00:18:17,590
execute and so we can just delete them

426
00:18:15,580 --> 00:18:18,040
all together because they're essentially

427
00:18:17,590 --> 00:18:21,070
meaningless

428
00:18:18,040 --> 00:18:23,680
they're all dead code all right so

429
00:18:21,070 --> 00:18:25,000
function inlining again kind of easy to

430
00:18:23,680 --> 00:18:27,820
implement

431
00:18:25,000 --> 00:18:30,400
you just find what you know you define

432
00:18:27,820 --> 00:18:33,250
what it means to be inlinable so for me

433
00:18:30,400 --> 00:18:35,770
I guess I took the simplest path which

434
00:18:33,250 --> 00:18:37,870
is if a function I need contains a

435
00:18:35,770 --> 00:18:39,460
single return statement and that return

436
00:18:37,870 --> 00:18:41,949
statement only returns a literal

437
00:18:39,460 --> 00:18:44,440
expression then we consider that to be

438
00:18:41,950 --> 00:18:46,330
inlinable and then so once we've

439
00:18:44,440 --> 00:18:49,990
collected all those functions again we

440
00:18:46,330 --> 00:18:51,189
can just walk the tree and find where

441
00:18:49,990 --> 00:18:54,280
those functions are called and just

442
00:18:51,190 --> 00:18:57,280
we'll replace it with the value that it

443
00:18:54,280 --> 00:18:59,770
gets with that it returns so if we go

444
00:18:57,280 --> 00:19:02,590
back to our example where's my tree gone

445
00:18:59,770 --> 00:19:05,470
all right doesn't matter and then we

446
00:19:02,590 --> 00:19:08,830
keep it closing until again until we

447
00:19:05,470 --> 00:19:11,380
reach the fix point all right so I've

448
00:19:08,830 --> 00:19:14,770
talked about three kind of easy compiler

449
00:19:11,380 --> 00:19:17,320
optimizations I've yet there are a bunch

450
00:19:14,770 --> 00:19:18,730
more we can also talk about but

451
00:19:17,320 --> 00:19:21,550
essentially that aim is just to remove

452
00:19:18,730 --> 00:19:23,200
as much dead code as possible and by

453
00:19:21,550 --> 00:19:25,659
applying different ones they enable us

454
00:19:23,200 --> 00:19:28,780
to remove dead code that appears with

455
00:19:25,660 --> 00:19:30,550
another kind of optimization alright so

456
00:19:28,780 --> 00:19:33,310
let's go back to our malware that we

457
00:19:30,550 --> 00:19:37,960
were looking at before which is this one

458
00:19:33,310 --> 00:19:39,700
and so yeah so we can see that there's a

459
00:19:37,960 --> 00:19:42,340
lot of code here there's a lot of

460
00:19:39,700 --> 00:19:44,580
functions that just return you know

461
00:19:42,340 --> 00:19:47,470
single values so we can apply our

462
00:19:44,580 --> 00:19:49,360
function inlining to them they're a

463
00:19:47,470 --> 00:19:51,120
bunch of variables here that I only get

464
00:19:49,360 --> 00:19:53,290
assigned a single value so we can

465
00:19:51,120 --> 00:19:55,419
propagate those values throughout the

466
00:19:53,290 --> 00:20:00,159
code and we keep doing different things

467
00:19:55,420 --> 00:20:06,460
until we can't go any further so let's

468
00:20:00,160 --> 00:20:09,100
run the tool on top of that code so yeah

469
00:20:06,460 --> 00:20:11,090
so safe is the tool and I've just added

470
00:20:09,100 --> 00:20:13,070
a deal for skate sub command to it

471
00:20:11,090 --> 00:20:15,168
and then we give it you know the

472
00:20:13,070 --> 00:20:17,840
javascript file that we want and the

473
00:20:15,169 --> 00:20:21,679
output file that we wanted to go to and

474
00:20:17,840 --> 00:20:24,289
then we run it and then we get you know

475
00:20:21,679 --> 00:20:29,840
it terminates hopefully and then we can

476
00:20:24,289 --> 00:20:32,929
look at it and see what we get so now we

477
00:20:29,840 --> 00:20:35,658
had 460 odd lines of code before and now

478
00:20:32,929 --> 00:20:37,190
we've reduced it down to 11 so we've

479
00:20:35,659 --> 00:20:39,139
done a bunch of extra things here so

480
00:20:37,190 --> 00:20:40,940
I've renamed variables to make them more

481
00:20:39,139 --> 00:20:42,678
memorable so I just picked animal names

482
00:20:40,940 --> 00:20:45,320
so that's why we've got these funky

483
00:20:42,679 --> 00:20:47,450
animals all stare at the code but now

484
00:20:45,320 --> 00:20:50,029
hopefully we've got JavaScript that is

485
00:20:47,450 --> 00:20:51,889
much easier to understand what it's

486
00:20:50,029 --> 00:20:54,649
doing because we've stripped away or the

487
00:20:51,889 --> 00:20:57,709
craft that really had no effect on the

488
00:20:54,649 --> 00:21:00,320
on the mail at all all right so this is

489
00:20:57,710 --> 00:21:03,379
the same kind of slides here so we

490
00:21:00,320 --> 00:21:05,210
started with 680 lines of code once it

491
00:21:03,379 --> 00:21:07,519
was when it was pretty printed and then

492
00:21:05,210 --> 00:21:09,549
once we jump to skate it we reduce it

493
00:21:07,519 --> 00:21:11,059
down to 11 lines of code and

494
00:21:09,549 --> 00:21:13,190
congratulations we feel that our

495
00:21:11,059 --> 00:21:15,619
analysts now you have off the skated POW

496
00:21:13,190 --> 00:21:18,590
shell inside it that you have to deal

497
00:21:15,619 --> 00:21:20,840
for skate but again you know these these

498
00:21:18,590 --> 00:21:23,149
techniques are kind of generic and you

499
00:21:20,840 --> 00:21:25,039
could in theory you know build a static

500
00:21:23,149 --> 00:21:27,469
analysis for the powershell and do the

501
00:21:25,039 --> 00:21:29,658
exact same thing so this sample just

502
00:21:27,470 --> 00:21:31,159
happened to have PowerShell in it but

503
00:21:29,659 --> 00:21:33,860
you know I've tried this on a bunch of

504
00:21:31,159 --> 00:21:35,869
other samples and it has a similar

505
00:21:33,860 --> 00:21:40,039
effect it deletes lots of code and you

506
00:21:35,869 --> 00:21:42,439
kind of makes it much easier to read all

507
00:21:40,039 --> 00:21:44,600
right cool so by looking at IDs from

508
00:21:42,440 --> 00:21:47,350
compilers we can build some pretty

509
00:21:44,600 --> 00:21:50,539
powerful tools such as adding obfuscator

510
00:21:47,350 --> 00:21:52,969
this idea is not really that now but

511
00:21:50,539 --> 00:21:56,360
it's kind of effective I guess from

512
00:21:52,970 --> 00:21:58,070
malware analyst and you know it's

513
00:21:56,360 --> 00:22:00,110
applicable across different kind of

514
00:21:58,070 --> 00:22:01,789
languages not just JavaScript so as long

515
00:22:00,110 --> 00:22:03,649
as you can generate as long as you have

516
00:22:01,789 --> 00:22:07,610
a parser for a language that gives you

517
00:22:03,649 --> 00:22:08,719
AST that you can walk and transform then

518
00:22:07,610 --> 00:22:12,559
you can essentially apply these

519
00:22:08,720 --> 00:22:15,919
techniques to that ast to reduce it down

520
00:22:12,559 --> 00:22:17,450
to something more meaningful and yeah I

521
00:22:15,919 --> 00:22:20,210
guess that's a summary that's the end of

522
00:22:17,450 --> 00:22:22,270
my talk thank you very much

523
00:22:20,210 --> 00:22:22,270
you

