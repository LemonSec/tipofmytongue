1
00:00:01,599 --> 00:00:05,650
we have Pete Rankin who will be giving a

2
00:00:03,699 --> 00:00:07,540
talk on binary patching making the

3
00:00:05,650 --> 00:00:10,120
switch and who is also the person who

4
00:00:07,540 --> 00:00:11,889
wrote the firmware for this year's about

5
00:00:10,120 --> 00:00:13,809
so the person that wrote that snake and

6
00:00:11,889 --> 00:00:15,338
Tetris game is standing up on stage

7
00:00:13,809 --> 00:00:15,889
right now so let's welcome Pete to the

8
00:00:15,339 --> 00:00:17,700
stage

9
00:00:15,890 --> 00:00:24,399
[Applause]

10
00:00:17,700 --> 00:00:26,939
Wow thank you welcome I know it's 4

11
00:00:24,399 --> 00:00:30,640
o'clock but uh let's just get started

12
00:00:26,939 --> 00:00:32,980
Christmas 2017 I saw an ad for the

13
00:00:30,640 --> 00:00:37,240
Nintendo switch and I couldn't help but

14
00:00:32,980 --> 00:00:40,419
think I would buy that if only it was a

15
00:00:37,240 --> 00:00:42,550
phone and we do we ask this about a lot

16
00:00:40,420 --> 00:00:45,970
of different products I would get that

17
00:00:42,550 --> 00:00:47,019
if it could do blah but I don't think

18
00:00:45,970 --> 00:00:50,110
this is the right way to look at that

19
00:00:47,020 --> 00:00:56,380
problem should the switch be a phone or

20
00:00:50,110 --> 00:01:00,250
should my phone be a switch we should

21
00:00:56,380 --> 00:01:03,880
not have to buy new devices in order to

22
00:01:00,250 --> 00:01:06,130
get access to new features and we should

23
00:01:03,880 --> 00:01:08,890
not have to beg companies to add

24
00:01:06,130 --> 00:01:12,490
features to our stuff they should

25
00:01:08,890 --> 00:01:14,890
already be there and we should have to

26
00:01:12,490 --> 00:01:16,839
borrow from a range of devices when we

27
00:01:14,890 --> 00:01:20,409
need to go on a plane like an e-reader

28
00:01:16,840 --> 00:01:23,290
or an mp3 player and when we do make our

29
00:01:20,409 --> 00:01:24,850
stuff work the way that we want it to we

30
00:01:23,290 --> 00:01:29,409
should not feel like we're stealing

31
00:01:24,850 --> 00:01:32,559
anything I think we should be builders

32
00:01:29,409 --> 00:01:35,200
we should be hackers and we should be

33
00:01:32,560 --> 00:01:39,460
making devices do the things that they

34
00:01:35,200 --> 00:01:41,820
were never ever meant to do today's talk

35
00:01:39,460 --> 00:01:41,820
Oh

36
00:01:45,700 --> 00:01:50,750
my tour today is on binary patching and

37
00:01:48,740 --> 00:01:53,210
I think that this is one of the very

38
00:01:50,750 --> 00:01:55,580
many tools that you can use to make your

39
00:01:53,210 --> 00:02:00,289
devices do the things that they were

40
00:01:55,580 --> 00:02:02,000
never meant to do and so I'll get stuck

41
00:02:00,290 --> 00:02:06,500
into it and not leave you I know it's

42
00:02:02,000 --> 00:02:08,300
four o'clock my name is Peter and at the

43
00:02:06,500 --> 00:02:10,669
moment I am working for a company called

44
00:02:08,300 --> 00:02:13,250
Penton that does a lot of great hardware

45
00:02:10,669 --> 00:02:14,989
stuff and I think a lot of my skills and

46
00:02:13,250 --> 00:02:17,540
my ideas have come from them and feel

47
00:02:14,990 --> 00:02:19,370
free to ask me questions afterwards but

48
00:02:17,540 --> 00:02:21,920
I'm a software developer and researcher

49
00:02:19,370 --> 00:02:23,690
so I'd like to think that I can write as

50
00:02:21,920 --> 00:02:27,260
much code as what I can reverse engineer

51
00:02:23,690 --> 00:02:29,810
or understand but more importantly and I

52
00:02:27,260 --> 00:02:33,079
think this is the big part I'm big on

53
00:02:29,810 --> 00:02:35,570
retro Nintendo and gaming and emulators

54
00:02:33,080 --> 00:02:38,780
and I have very fond memories of long

55
00:02:35,570 --> 00:02:40,459
trips to places with my game boys and I

56
00:02:38,780 --> 00:02:43,190
hope that the nostalgia that maybe you

57
00:02:40,460 --> 00:02:45,489
feel with those Nokia phones brings back

58
00:02:43,190 --> 00:02:47,450
some of those memories of throwing your

59
00:02:45,489 --> 00:02:51,940
3310 to the ground and being able to

60
00:02:47,450 --> 00:02:55,670
pick it up without a broken screen and

61
00:02:51,940 --> 00:02:58,880
yes many hours went into the firm of the

62
00:02:55,670 --> 00:03:01,160
badge but also their echo who did the

63
00:02:58,880 --> 00:03:04,579
actual badge design went through many

64
00:03:01,160 --> 00:03:06,260
prototypes and so kudos to him who

65
00:03:04,580 --> 00:03:08,660
actually came up with the nokia theme

66
00:03:06,260 --> 00:03:11,570
they gave me the groundwork to actually

67
00:03:08,660 --> 00:03:14,450
build the firmware and also I'd like to

68
00:03:11,570 --> 00:03:16,970
say thank you to my partner Sarah who I

69
00:03:14,450 --> 00:03:19,160
love very much who supported me for the

70
00:03:16,970 --> 00:03:25,360
months that I spent on this for which I

71
00:03:19,160 --> 00:03:28,190
was not very pleasant all the time so

72
00:03:25,360 --> 00:03:30,320
it's about a 50 minute talk and I'm

73
00:03:28,190 --> 00:03:32,660
going to spend a few minutes going over

74
00:03:30,320 --> 00:03:34,519
the concept and then a bit of an

75
00:03:32,660 --> 00:03:36,829
introduction into binary patching where

76
00:03:34,520 --> 00:03:40,400
I talk about how I patched Android

77
00:03:36,830 --> 00:03:41,959
Bluetooth to fix an issue and then the

78
00:03:40,400 --> 00:03:43,610
talk kind of splits and goes off in a

79
00:03:41,959 --> 00:03:45,890
different direction because at that

80
00:03:43,610 --> 00:03:47,720
point I had learnt about Linux kernels

81
00:03:45,890 --> 00:03:49,130
and how to build them and I was looking

82
00:03:47,720 --> 00:03:52,160
for the next problem which is where I'll

83
00:03:49,130 --> 00:03:53,540
go into trust zone interception so I

84
00:03:52,160 --> 00:03:55,930
hope there's something for everyone in

85
00:03:53,540 --> 00:03:55,929
this talk today

86
00:03:57,080 --> 00:04:03,470
so the concepts I saw that ad for the

87
00:04:00,720 --> 00:04:06,150
Nintendo switch and it looks great a

88
00:04:03,470 --> 00:04:09,450
console and a portable combined and with

89
00:04:06,150 --> 00:04:10,560
suite suite controllers they really are

90
00:04:09,450 --> 00:04:12,299
they've actually got little connectors

91
00:04:10,560 --> 00:04:14,819
at the bottom of them that work at 1.8

92
00:04:12,300 --> 00:04:17,459
volts the screen is a good size good

93
00:04:14,819 --> 00:04:21,450
storage good processing power a great

94
00:04:17,459 --> 00:04:24,630
system but like many of you I have a

95
00:04:21,450 --> 00:04:27,479
phone why would I carry two devices and

96
00:04:24,630 --> 00:04:31,530
it has more power and more storage than

97
00:04:27,479 --> 00:04:34,260
the switch if only had buttons and this

98
00:04:31,530 --> 00:04:36,570
is a real problem so many devices are

99
00:04:34,260 --> 00:04:38,460
losing their buttons and I don't think

100
00:04:36,570 --> 00:04:40,620
it'll be that long before devices have

101
00:04:38,460 --> 00:04:43,500
no buttons or and and no inputs all

102
00:04:40,620 --> 00:04:45,210
together and it's really sad because

103
00:04:43,500 --> 00:04:51,810
buttons are a great way to interact with

104
00:04:45,210 --> 00:04:55,289
products so I hacked I had this idea get

105
00:04:51,810 --> 00:05:00,450
just the controllers for the switch get

106
00:04:55,290 --> 00:05:03,390
my phone 3d design and print a case that

107
00:05:00,450 --> 00:05:05,640
supported it 3d CAD is very accessible

108
00:05:03,390 --> 00:05:07,229
and I didn't even need a 3d printer I

109
00:05:05,640 --> 00:05:09,060
could just send my design away and

110
00:05:07,229 --> 00:05:13,740
someone mailed me a piece of plastic

111
00:05:09,060 --> 00:05:16,110
that didn't fit the first time but to

112
00:05:13,740 --> 00:05:20,669
know less you know 3d printing is

113
00:05:16,110 --> 00:05:23,669
definitely accessible and the

114
00:05:20,669 --> 00:05:25,740
controllers they paired by bluetooth but

115
00:05:23,669 --> 00:05:28,650
it lagged it lags to the point where it

116
00:05:25,740 --> 00:05:31,169
was unusable you'd press a button it

117
00:05:28,650 --> 00:05:37,229
would happen after about five seconds

118
00:05:31,169 --> 00:05:39,900
and then everything would happen so I

119
00:05:37,229 --> 00:05:42,360
looked around on forum after for him I

120
00:05:39,900 --> 00:05:44,580
tried to understand Bluetooth and it's

121
00:05:42,360 --> 00:05:47,940
complicated and it's hard and I don't

122
00:05:44,580 --> 00:05:50,580
understand all of it but if you just

123
00:05:47,940 --> 00:05:52,020
keep pursuing you can figure it out or

124
00:05:50,580 --> 00:05:54,330
you can find someone else you can help

125
00:05:52,020 --> 00:05:57,419
you or in this case someone else who had

126
00:05:54,330 --> 00:06:00,090
already figured it out open your

127
00:05:57,419 --> 00:06:02,400
Bluetooth default shared objects find

128
00:06:00,090 --> 00:06:05,159
this by pattern or replace it with this

129
00:06:02,400 --> 00:06:07,279
one or find this bike plan and replace

130
00:06:05,159 --> 00:06:09,829
it with this one

131
00:06:07,279 --> 00:06:12,139
and that's kind of where it gets started

132
00:06:09,829 --> 00:06:14,539
I have a binary patch that I want to

133
00:06:12,139 --> 00:06:20,749
apply so I can make my phone do the

134
00:06:14,539 --> 00:06:23,628
things it was never meant to do and you

135
00:06:20,749 --> 00:06:25,819
don't even need a rooted or broken

136
00:06:23,629 --> 00:06:28,489
device to begin with if you have an

137
00:06:25,819 --> 00:06:30,589
Android device you can pull any binary

138
00:06:28,489 --> 00:06:33,709
off that phone that you want without

139
00:06:30,589 --> 00:06:35,689
rooting it you can use ADB and there is

140
00:06:33,709 --> 00:06:38,179
lots of Google tutorials about how to do

141
00:06:35,689 --> 00:06:41,179
that you don't need roots you don't need

142
00:06:38,179 --> 00:06:42,708
boot boot loader unlocked and once

143
00:06:41,179 --> 00:06:44,448
you've got those files you can open them

144
00:06:42,709 --> 00:06:46,969
up in a hex editor which is just

145
00:06:44,449 --> 00:06:52,809
basically word for binaries and you do a

146
00:06:46,969 --> 00:06:55,099
find and replace unless you can't find

147
00:06:52,809 --> 00:06:57,709
which is really devastating because then

148
00:06:55,099 --> 00:06:58,789
you're like well what do I do now but

149
00:06:57,709 --> 00:07:02,779
there's a better question to ask

150
00:06:58,789 --> 00:07:05,919
yourself what exactly is the patch doing

151
00:07:02,779 --> 00:07:09,019
because we're talking about a network

152
00:07:05,919 --> 00:07:11,899
process something that does radio stuff

153
00:07:09,019 --> 00:07:14,360
is it making authentication completely

154
00:07:11,899 --> 00:07:18,619
disabled is it setting up a custom

155
00:07:14,360 --> 00:07:20,929
listening Bluetooth socket who knows so

156
00:07:18,619 --> 00:07:24,499
before you binary patch things try and

157
00:07:20,929 --> 00:07:26,029
understand it yourself first and so I

158
00:07:24,499 --> 00:07:28,219
went back to that forum where I found

159
00:07:26,029 --> 00:07:31,249
that patch and someone pointed me to

160
00:07:28,219 --> 00:07:34,039
this idea that it was on this SSR max

161
00:07:31,249 --> 00:07:36,259
latency value for Bluetooth and I can

162
00:07:34,039 --> 00:07:38,169
tell you now to this day I still don't

163
00:07:36,259 --> 00:07:40,969
fully comprehend what that feature does

164
00:07:38,169 --> 00:07:43,639
but Android source code is readily

165
00:07:40,969 --> 00:07:46,308
available and from that I was able to

166
00:07:43,639 --> 00:07:50,869
find the define that said it's the value

167
00:07:46,309 --> 00:07:53,239
800 which is hex 320 and if you look at

168
00:07:50,869 --> 00:07:56,269
this little bit of disassembly which you

169
00:07:53,239 --> 00:07:58,039
can get disassembled now on websites you

170
00:07:56,269 --> 00:07:59,959
don't even need a disassembler in your

171
00:07:58,039 --> 00:08:03,289
laptop and it will tell you that they're

172
00:07:59,959 --> 00:08:06,379
changing this 320 values 18 they are

173
00:08:03,289 --> 00:08:09,639
basically disabling the SSR max latency

174
00:08:06,379 --> 00:08:12,139
value so now that we know what it does

175
00:08:09,639 --> 00:08:15,139
we now need to find out where it is in

176
00:08:12,139 --> 00:08:18,019
our binary and for that you do need a

177
00:08:15,139 --> 00:08:18,979
disassembler but lucky for you as of I

178
00:08:18,019 --> 00:08:21,210
think a week or two ago

179
00:08:18,979 --> 00:08:23,940
deidre the NSA tool

180
00:08:21,210 --> 00:08:28,770
is available so feel free to let the NSA

181
00:08:23,940 --> 00:08:31,740
help you on your endeavors and so when

182
00:08:28,770 --> 00:08:33,809
you open up a binary like this in a

183
00:08:31,740 --> 00:08:35,310
disassembler there is lots and lots of

184
00:08:33,809 --> 00:08:38,399
things to look at and it's very

185
00:08:35,309 --> 00:08:40,468
overwhelming the important thing to

186
00:08:38,399 --> 00:08:42,120
remember is that you would like to find

187
00:08:40,469 --> 00:08:43,680
something so you're looking for

188
00:08:42,120 --> 00:08:48,120
something that's unique something that's

189
00:08:43,679 --> 00:08:50,069
constant and in my case that for hex 320

190
00:08:48,120 --> 00:08:52,980
value is the thing that I imagine would

191
00:08:50,070 --> 00:08:56,880
be unique but there was still like 1520

192
00:08:52,980 --> 00:08:58,290
occurrences of it so you kind of have to

193
00:08:56,880 --> 00:09:01,080
iterate through it and apply a bit of

194
00:08:58,290 --> 00:09:02,910
understanding and then I found this spot

195
00:09:01,080 --> 00:09:05,399
that look like it might be right and

196
00:09:02,910 --> 00:09:09,469
that gave me the bike pan at the bottom

197
00:09:05,399 --> 00:09:13,830
which was the fine pattern for my binary

198
00:09:09,470 --> 00:09:15,720
and again using online tools you can

199
00:09:13,830 --> 00:09:19,140
take that pan disassemble it online

200
00:09:15,720 --> 00:09:21,149
change the value reassemble it and there

201
00:09:19,140 --> 00:09:23,610
you are you have you created and ported

202
00:09:21,149 --> 00:09:25,680
your own binary patch it is that easy to

203
00:09:23,610 --> 00:09:30,270
make your devices do the things that

204
00:09:25,680 --> 00:09:31,500
they were never meant to do but this is

205
00:09:30,270 --> 00:09:34,140
kind of where some of the easy stuff

206
00:09:31,500 --> 00:09:35,910
starts to stop because unlike some of

207
00:09:34,140 --> 00:09:37,949
the earlier Android phones it is not as

208
00:09:35,910 --> 00:09:41,100
simple as pushing that binary back onto

209
00:09:37,950 --> 00:09:42,959
the phone and to kind of describe why

210
00:09:41,100 --> 00:09:47,970
that's the case I need to explain

211
00:09:42,959 --> 00:09:50,520
something about chain of trust so when

212
00:09:47,970 --> 00:09:53,339
you turn your phone on and you give it

213
00:09:50,520 --> 00:09:55,680
power there is a tiny bit of code that

214
00:09:53,339 --> 00:09:57,930
is baked into the chipset on your phone

215
00:09:55,680 --> 00:10:00,479
and it has the sole job and

216
00:09:57,930 --> 00:10:03,420
responsibility of verifying the

217
00:10:00,480 --> 00:10:05,490
signature of the next part and I I

218
00:10:03,420 --> 00:10:07,079
apologize on these details are a little

219
00:10:05,490 --> 00:10:09,930
bit with you off you for those who do

220
00:10:07,079 --> 00:10:12,209
this all the time but the gist is that

221
00:10:09,930 --> 00:10:15,810
it verifies the next stage before

222
00:10:12,209 --> 00:10:18,689
executing it which then loads a primary

223
00:10:15,810 --> 00:10:20,579
bootloader on your Android devices and

224
00:10:18,690 --> 00:10:23,490
it's got a bit more space because it's

225
00:10:20,579 --> 00:10:25,079
not in the actual wires on your chip but

226
00:10:23,490 --> 00:10:29,190
again it just really verifies and loads

227
00:10:25,079 --> 00:10:30,870
the secondary bootloader and this this

228
00:10:29,190 --> 00:10:33,850
is where your phone kind of splits into

229
00:10:30,870 --> 00:10:36,640
two phones if you have an Android device

230
00:10:33,850 --> 00:10:39,190
you've got your Android with its Linux

231
00:10:36,640 --> 00:10:42,699
kernel and then you've got the secure

232
00:10:39,190 --> 00:10:44,950
world which handles all your DRM your

233
00:10:42,700 --> 00:10:47,200
keys your device encryption your

234
00:10:44,950 --> 00:10:50,110
fingerprint scanner maybe even your

235
00:10:47,200 --> 00:10:52,150
facial recognition and it is this part

236
00:10:50,110 --> 00:10:55,360
of the boot chain that starts that and

237
00:10:52,150 --> 00:10:58,810
Android but for now let's focus on the

238
00:10:55,360 --> 00:11:00,580
Android part this is the Android

239
00:10:58,810 --> 00:11:03,869
bootloader that get flirted next if

240
00:11:00,580 --> 00:11:07,360
you've ever flashed a custom recovery or

241
00:11:03,870 --> 00:11:10,300
redid your phone or installed lineage or

242
00:11:07,360 --> 00:11:12,490
seijin mod you've used this tool to

243
00:11:10,300 --> 00:11:18,579
flash stuff onto your phone

244
00:11:12,490 --> 00:11:21,700
it's what fastboot talks to but it

245
00:11:18,580 --> 00:11:23,880
itself is not a Linux kernel so it loads

246
00:11:21,700 --> 00:11:26,710
the Linux kernel from the boot partition

247
00:11:23,880 --> 00:11:29,230
this is what actually does the DM Verity

248
00:11:26,710 --> 00:11:31,300
check on your Android system it checks

249
00:11:29,230 --> 00:11:35,140
that Android has not been modified and

250
00:11:31,300 --> 00:11:38,229
if all that is good we finally after all

251
00:11:35,140 --> 00:11:40,780
that have got to the point where Android

252
00:11:38,230 --> 00:11:43,600
starts up your processors start and

253
00:11:40,780 --> 00:11:46,630
that's where our Bluetooth object that

254
00:11:43,600 --> 00:11:49,150
we want to patch exists and the

255
00:11:46,630 --> 00:11:52,990
important moral of this story is that it

256
00:11:49,150 --> 00:11:55,689
is verified if you change a bit in this

257
00:11:52,990 --> 00:11:57,730
boot chain your phone is a brick to

258
00:11:55,690 --> 00:12:04,090
varying degrees depending on how high up

259
00:11:57,730 --> 00:12:06,580
the chain you change that bit I've

260
00:12:04,090 --> 00:12:13,000
gotten close to this very very many

261
00:12:06,580 --> 00:12:14,800
times so how do people then install

262
00:12:13,000 --> 00:12:17,740
custom roms on their Android device

263
00:12:14,800 --> 00:12:19,750
well they boot load around lock and the

264
00:12:17,740 --> 00:12:22,240
the thing to remember about bootloader

265
00:12:19,750 --> 00:12:25,300
like unlocking is all you're doing is

266
00:12:22,240 --> 00:12:27,790
you're telling a boot to check nothing

267
00:12:25,300 --> 00:12:31,180
in the boot partition not the Linux

268
00:12:27,790 --> 00:12:33,189
kernel not the round disk nothing boot

269
00:12:31,180 --> 00:12:36,339
will just get blindly loaded regardless

270
00:12:33,190 --> 00:12:38,590
of its state but at this point in time

271
00:12:36,340 --> 00:12:40,360
boot still has the code in it to check

272
00:12:38,590 --> 00:12:43,950
and verify the Android system so we

273
00:12:40,360 --> 00:12:43,950
still can't patch

274
00:12:44,180 --> 00:12:48,560
but that's when you can actually root

275
00:12:45,590 --> 00:12:51,200
your device and once you root your

276
00:12:48,560 --> 00:12:54,109
device this is what your phone security

277
00:12:51,200 --> 00:12:55,700
looks like someone who gets access to

278
00:12:54,110 --> 00:12:58,520
your phone can change your system

279
00:12:55,700 --> 00:13:01,280
petition and your boot petition and get

280
00:12:58,520 --> 00:13:02,900
access to anything on your device so

281
00:13:01,280 --> 00:13:08,300
just think about that next time you want

282
00:13:02,900 --> 00:13:10,340
a bootloader unlock now changing the

283
00:13:08,300 --> 00:13:11,959
system partition means that we're no

284
00:13:10,340 --> 00:13:14,660
longer eligible for updates

285
00:13:11,960 --> 00:13:16,310
but the routing community came up with

286
00:13:14,660 --> 00:13:18,230
the solution to this a while ago and

287
00:13:16,310 --> 00:13:20,300
they called it system less routing and

288
00:13:18,230 --> 00:13:22,280
what it means is that they don't make

289
00:13:20,300 --> 00:13:25,160
any changes to the Android system

290
00:13:22,280 --> 00:13:26,959
partition they do it in the boot

291
00:13:25,160 --> 00:13:29,000
partition they make changes to the Linux

292
00:13:26,960 --> 00:13:32,210
kernel such that the Android system

293
00:13:29,000 --> 00:13:37,900
remains unchanged and changed and still

294
00:13:32,210 --> 00:13:41,030
able to receive updates so let's do that

295
00:13:37,900 --> 00:13:44,390
we start off with our own Linux driver

296
00:13:41,030 --> 00:13:47,600
that we can build for our Android and it

297
00:13:44,390 --> 00:13:49,970
gets to sit in the Linux kernel and from

298
00:13:47,600 --> 00:13:54,500
there you can see all the processes

299
00:13:49,970 --> 00:13:57,860
running in Android we can search those

300
00:13:54,500 --> 00:14:00,320
processes to find the Bluetooth one then

301
00:13:57,860 --> 00:14:02,900
we can search that Bluetooth process to

302
00:14:00,320 --> 00:14:04,760
find our shared objects as it exists in

303
00:14:02,900 --> 00:14:08,270
memory and it's the same as what it is

304
00:14:04,760 --> 00:14:10,550
on disk for the most part and we can

305
00:14:08,270 --> 00:14:14,319
search that to find our bite pattern and

306
00:14:10,550 --> 00:14:14,319
patch it in memory from the kernel and

307
00:14:14,560 --> 00:14:18,439
that's pretty much it that is that is

308
00:14:16,910 --> 00:14:19,969
what system list means when they talk

309
00:14:18,440 --> 00:14:25,250
about system with root or system was

310
00:14:19,970 --> 00:14:27,800
patching so some useful tricks I know

311
00:14:25,250 --> 00:14:30,230
there's a bit of text on this slide the

312
00:14:27,800 --> 00:14:32,900
get user pages function is super cool

313
00:14:30,230 --> 00:14:36,440
from the Linux kernel you can ask for

314
00:14:32,900 --> 00:14:38,840
any page of any user mode process to be

315
00:14:36,440 --> 00:14:41,540
mapped into the kernel and with write

316
00:14:38,840 --> 00:14:44,570
Commission's so you can patch and change

317
00:14:41,540 --> 00:14:47,180
any byte in any user mo process without

318
00:14:44,570 --> 00:14:51,830
changing any permission on any of their

319
00:14:47,180 --> 00:14:54,530
pages it's super cool and then the other

320
00:14:51,830 --> 00:14:56,460
thing is that you might want to read

321
00:14:54,530 --> 00:14:58,290
this other file system called proc

322
00:14:56,460 --> 00:15:00,600
Maps to find out where things are loaded

323
00:14:58,290 --> 00:15:03,030
in memory but if you're in the kernel

324
00:15:00,600 --> 00:15:05,220
you've got access to the structures and

325
00:15:03,030 --> 00:15:06,870
the data that's used to store that

326
00:15:05,220 --> 00:15:12,120
information and you can get at it

327
00:15:06,870 --> 00:15:13,530
directly so if you've managed to get as

328
00:15:12,120 --> 00:15:15,570
far as building your Linux kernel and

329
00:15:13,530 --> 00:15:19,650
your Linux kernel should be made

330
00:15:15,570 --> 00:15:21,480
available it is GPL I built my phone's

331
00:15:19,650 --> 00:15:24,750
Linux kernel on the windows subsystem

332
00:15:21,480 --> 00:15:26,340
Linux so it is totally doable you can

333
00:15:24,750 --> 00:15:29,430
get the source code for your phones and

334
00:15:26,340 --> 00:15:32,490
build it and once you've built it you

335
00:15:29,430 --> 00:15:35,400
get this image GZ to a DTV file and it

336
00:15:32,490 --> 00:15:38,820
might vary depending on what Android or

337
00:15:35,400 --> 00:15:41,069
what device you're doing this for but to

338
00:15:38,820 --> 00:15:44,160
flash it you actually need to put it

339
00:15:41,070 --> 00:15:46,020
into a boot image but there's a

340
00:15:44,160 --> 00:15:48,569
wonderful tool called Android image

341
00:15:46,020 --> 00:15:50,310
kitchen that you can use the pool part

342
00:15:48,570 --> 00:15:52,680
of boot image into the individual parts

343
00:15:50,310 --> 00:15:54,390
and the only one that we care about is

344
00:15:52,680 --> 00:15:59,099
the Linux kernel device tree

345
00:15:54,390 --> 00:16:00,600
the Lynx kernel and device tree and we

346
00:15:59,100 --> 00:16:04,500
can replace that file once extracted

347
00:16:00,600 --> 00:16:06,630
with our built one and then repack that

348
00:16:04,500 --> 00:16:10,040
boot image and flash it onto our phone

349
00:16:06,630 --> 00:16:12,810
using fastboot and it is that easy to

350
00:16:10,040 --> 00:16:17,880
unpack and pack a boot image for your

351
00:16:12,810 --> 00:16:20,430
phone and this is the cool thing you can

352
00:16:17,880 --> 00:16:22,170
do these kind of cool things so I

353
00:16:20,430 --> 00:16:24,380
actually took it a step further after

354
00:16:22,170 --> 00:16:27,360
eyeing that driver and wrote my own

355
00:16:24,380 --> 00:16:30,840
Linux kernel input driver for the joy

356
00:16:27,360 --> 00:16:33,630
cons and I'd never done this before

357
00:16:30,840 --> 00:16:36,510
but there are lots of examples and I use

358
00:16:33,630 --> 00:16:41,580
the previous the Wii controller example

359
00:16:36,510 --> 00:16:43,680
from the Linux kernel to build mine and

360
00:16:41,580 --> 00:16:45,780
there are so many good emulators and now

361
00:16:43,680 --> 00:16:48,329
I'm pretty close to having my own phone

362
00:16:45,780 --> 00:16:52,770
as a switch which i think is pretty cool

363
00:16:48,330 --> 00:16:55,410
and if you're looking at doing this sort

364
00:16:52,770 --> 00:16:57,480
of stuff all my code is available so

365
00:16:55,410 --> 00:17:00,569
I've got my driver at the top which does

366
00:16:57,480 --> 00:17:03,090
the kernel to user mode patching the

367
00:17:00,570 --> 00:17:04,949
input driver and then someone else came

368
00:17:03,090 --> 00:17:06,900
across long this and actually built a

369
00:17:04,949 --> 00:17:10,820
better one so you can use their driver

370
00:17:06,900 --> 00:17:10,820
which I would recommend over my code

371
00:17:11,720 --> 00:17:17,819
but now I'm kind of at this point where

372
00:17:14,099 --> 00:17:20,159
I can build Linux kernels from my phone

373
00:17:17,819 --> 00:17:23,670
and I can build drivers from my phone

374
00:17:20,160 --> 00:17:26,490
what should my next project be well it's

375
00:17:23,670 --> 00:17:30,540
kind of like I'm standing this high one

376
00:17:26,490 --> 00:17:33,090
if I could go there and so I turned my

377
00:17:30,540 --> 00:17:35,040
attention to trusts own the operating

378
00:17:33,090 --> 00:17:39,990
system on your phone that is running

379
00:17:35,040 --> 00:17:42,780
that you don't even know is there so to

380
00:17:39,990 --> 00:17:45,300
give you a bit of background your phone

381
00:17:42,780 --> 00:17:46,980
is basically broken into two worlds the

382
00:17:45,300 --> 00:17:48,480
normal world that has your Linux kernel

383
00:17:46,980 --> 00:17:50,850
and your Android operating system and

384
00:17:48,480 --> 00:17:53,760
the trust own kernel that handles your

385
00:17:50,850 --> 00:17:58,730
DRM your keys all those security related

386
00:17:53,760 --> 00:18:02,340
features your fingerprint scanner so

387
00:17:58,730 --> 00:18:06,120
what if we wrote another driver and we

388
00:18:02,340 --> 00:18:08,760
load it into the Linux kernel again but

389
00:18:06,120 --> 00:18:13,949
we're below secure world we can't see it

390
00:18:08,760 --> 00:18:16,920
we can't interact with it but these

391
00:18:13,950 --> 00:18:19,230
processes so your YouTube has to talk to

392
00:18:16,920 --> 00:18:20,970
the trust 'let that is actually

393
00:18:19,230 --> 00:18:24,150
responsible for doing DRM decoding a

394
00:18:20,970 --> 00:18:25,230
video your fingerprint scanner has to

395
00:18:24,150 --> 00:18:27,030
talk to the trust that that's actually

396
00:18:25,230 --> 00:18:29,340
reading and verifying your fingerprint

397
00:18:27,030 --> 00:18:31,770
how does this communication happen and

398
00:18:29,340 --> 00:18:33,330
if you had this problem with computers

399
00:18:31,770 --> 00:18:35,370
and you had two computers and a wire

400
00:18:33,330 --> 00:18:37,860
running between them you'd want to see

401
00:18:35,370 --> 00:18:40,550
the messages right in the middle as I go

402
00:18:37,860 --> 00:18:45,750
across you'd want to sniff the traffic

403
00:18:40,550 --> 00:18:49,370
and the driver for Qualcomm devices is

404
00:18:45,750 --> 00:18:52,020
called QC Kong and it does this problem

405
00:18:49,370 --> 00:18:53,729
it basically allows messages to be

406
00:18:52,020 --> 00:18:56,040
transferred from processors to trust

407
00:18:53,730 --> 00:18:58,520
lats and back and forth to facilitate

408
00:18:56,040 --> 00:19:01,860
this but if we're in the Linux kernel

409
00:18:58,520 --> 00:19:04,379
we're in the same playing field and we

410
00:19:01,860 --> 00:19:09,270
can make binary patches to that to see

411
00:19:04,380 --> 00:19:11,490
what's happening and Linux source code

412
00:19:09,270 --> 00:19:13,620
it's a big place but you can totally

413
00:19:11,490 --> 00:19:16,950
find things with very little experience

414
00:19:13,620 --> 00:19:19,709
myself a quick find I found the source

415
00:19:16,950 --> 00:19:22,290
file and better yet the first function

416
00:19:19,710 --> 00:19:23,730
in that source file was the function I

417
00:19:22,290 --> 00:19:27,269
want to hook

418
00:19:23,730 --> 00:19:28,860
intercept messages so it is it is not

419
00:19:27,269 --> 00:19:31,200
that hard to find things in the links

420
00:19:28,860 --> 00:19:33,149
kernel and there's plenty of resources

421
00:19:31,200 --> 00:19:34,830
around you that can help you out if you

422
00:19:33,149 --> 00:19:38,580
if you're looking to solve these kind of

423
00:19:34,830 --> 00:19:41,039
problems but I probably should have said

424
00:19:38,580 --> 00:19:43,320
it was that simple because this is where

425
00:19:41,039 --> 00:19:49,610
you know things get a little bit harder

426
00:19:43,320 --> 00:19:55,200
so I want to hook a function in a kernel

427
00:19:49,610 --> 00:19:57,389
what are my options you can make source

428
00:19:55,200 --> 00:19:59,399
code changes so you can change the

429
00:19:57,389 --> 00:20:01,740
source code for their driver and rebuild

430
00:19:59,399 --> 00:20:03,090
it because it's the Linux kernel so if

431
00:20:01,740 --> 00:20:05,669
this is the function you want to

432
00:20:03,090 --> 00:20:08,610
intercept you write your own function

433
00:20:05,669 --> 00:20:10,500
nearby and you just make it call your

434
00:20:08,610 --> 00:20:15,059
function with the same args and you've

435
00:20:10,500 --> 00:20:16,260
basically done a hook in source code the

436
00:20:15,059 --> 00:20:18,899
only problem with this method is that

437
00:20:16,260 --> 00:20:20,490
what if you don't get the source code to

438
00:20:18,899 --> 00:20:23,428
your kernel what if it's not released

439
00:20:20,490 --> 00:20:24,769
for until two three years after what

440
00:20:23,429 --> 00:20:26,940
happens if they don't release it at all

441
00:20:24,769 --> 00:20:28,909
Samsung has been notorious for this in

442
00:20:26,940 --> 00:20:32,070
the past

443
00:20:28,909 --> 00:20:34,260
what happens if bootloader and locking

444
00:20:32,070 --> 00:20:36,120
and loading up your own kernel changes

445
00:20:34,260 --> 00:20:38,760
the behavior of these things that you

446
00:20:36,120 --> 00:20:42,199
want to observe so sometimes source code

447
00:20:38,760 --> 00:20:44,730
changes are not always the best option

448
00:20:42,200 --> 00:20:47,610
we can look for function pointers that

449
00:20:44,730 --> 00:20:49,049
point to our function and change them so

450
00:20:47,610 --> 00:20:51,629
again we have the function we want to

451
00:20:49,049 --> 00:20:55,320
intercept and we have a table of

452
00:20:51,630 --> 00:20:56,549
function pointers that will call it we

453
00:20:55,320 --> 00:21:00,600
can write a function that takes exactly

454
00:20:56,549 --> 00:21:02,460
the same args and redirect it to it the

455
00:21:00,600 --> 00:21:05,039
only problem is that in my case this

456
00:21:02,460 --> 00:21:09,269
doesn't exist so this is no good to me

457
00:21:05,039 --> 00:21:11,250
either the next one is to do inline

458
00:21:09,269 --> 00:21:14,340
hooks where you actually change the code

459
00:21:11,250 --> 00:21:17,220
at the beginning of a function so again

460
00:21:14,340 --> 00:21:19,260
we can write our own and we put a little

461
00:21:17,220 --> 00:21:23,929
jump so as soon as that function gets

462
00:21:19,260 --> 00:21:27,179
execution we send it somewhere else but

463
00:21:23,929 --> 00:21:28,889
we're putting code over existing code

464
00:21:27,179 --> 00:21:30,179
and at the start of the function is

465
00:21:28,889 --> 00:21:32,668
where some interesting things happen

466
00:21:30,179 --> 00:21:36,809
like how the stack gets set up how

467
00:21:32,669 --> 00:21:37,500
registers and variables get set up so we

468
00:21:36,809 --> 00:21:38,910
have to read

469
00:21:37,500 --> 00:21:40,710
do those things before we go to our

470
00:21:38,910 --> 00:21:42,870
function and we tend to write small code

471
00:21:40,710 --> 00:21:45,030
stubs to fix the stack to fix the

472
00:21:42,870 --> 00:21:46,770
registers and then ultimately call our

473
00:21:45,030 --> 00:21:48,870
function so it's kind of like the

474
00:21:46,770 --> 00:21:51,770
assembly binary form of source code

475
00:21:48,870 --> 00:21:55,229
cooking but this ends up being very

476
00:21:51,770 --> 00:21:57,710
function and kernel and version specific

477
00:21:55,230 --> 00:22:00,000
because every time a compiler is run

478
00:21:57,710 --> 00:22:02,520
maybe it up put slightly different code

479
00:22:00,000 --> 00:22:03,810
may be making a one-line change can

480
00:22:02,520 --> 00:22:06,620
cause it to think of all sorts of

481
00:22:03,810 --> 00:22:09,570
optimizations so this becomes very

482
00:22:06,620 --> 00:22:15,959
specific and that's not very useful all

483
00:22:09,570 --> 00:22:20,970
the time so let's think about what calls

484
00:22:15,960 --> 00:22:24,630
this function something else obviously

485
00:22:20,970 --> 00:22:27,180
has to use it for a purpose so what if

486
00:22:24,630 --> 00:22:29,880
we wrote our own and redirected that

487
00:22:27,180 --> 00:22:31,980
call to ours and as it turns out this is

488
00:22:29,880 --> 00:22:35,040
exactly the case there is only one other

489
00:22:31,980 --> 00:22:36,690
function call in the QC comm driver that

490
00:22:35,040 --> 00:22:43,649
cause the function that I want to hook

491
00:22:36,690 --> 00:22:47,040
so let's hook that instead the only

492
00:22:43,650 --> 00:22:50,400
problem with this though is that these

493
00:22:47,040 --> 00:22:52,080
functions are private the driver the QC

494
00:22:50,400 --> 00:22:54,000
comm driver does not make them expose

495
00:22:52,080 --> 00:22:57,389
you can't look them up with Cal Simms

496
00:22:54,000 --> 00:22:59,930
you can't do a this function name to

497
00:22:57,390 --> 00:23:03,120
function pointer lookup it doesn't work

498
00:22:59,930 --> 00:23:06,450
but again something has to call it

499
00:23:03,120 --> 00:23:08,310
something public has to call it and as

500
00:23:06,450 --> 00:23:10,830
it turns out the first thing that this

501
00:23:08,310 --> 00:23:12,629
other thing does QC comm unregister

502
00:23:10,830 --> 00:23:19,020
listen does is it calls the one that we

503
00:23:12,630 --> 00:23:23,340
want and functions are just bytes so we

504
00:23:19,020 --> 00:23:26,310
can disassemble them on the fly and find

505
00:23:23,340 --> 00:23:28,649
the instructions that are for our call

506
00:23:26,310 --> 00:23:30,210
and then we can work backwards to figure

507
00:23:28,650 --> 00:23:33,600
out where that addresses and so now we

508
00:23:30,210 --> 00:23:35,550
can mine private functions from public

509
00:23:33,600 --> 00:23:37,290
ones and so now you can find all the

510
00:23:35,550 --> 00:23:42,030
other API is dynamically in the links

511
00:23:37,290 --> 00:23:44,070
kernel that weren't there before and

512
00:23:42,030 --> 00:23:45,928
you're going to get a lot of crashes I'm

513
00:23:44,070 --> 00:23:50,090
surprised my phone actually still works

514
00:23:45,929 --> 00:23:53,450
after this point because changing bytes

515
00:23:50,090 --> 00:23:57,439
there is so much more to it but to show

516
00:23:53,450 --> 00:23:59,600
you the problems that I encountered my

517
00:23:57,440 --> 00:24:02,150
colonel for my phone is compiled to be

518
00:23:59,600 --> 00:24:05,080
read only there's a flag at compile time

519
00:24:02,150 --> 00:24:08,330
called config debug read-only data and

520
00:24:05,080 --> 00:24:10,909
with that enabled the kernel code is

521
00:24:08,330 --> 00:24:13,100
read-only and that's where the driver

522
00:24:10,910 --> 00:24:15,770
that I want to patch is so we can't

523
00:24:13,100 --> 00:24:19,490
change it so what if I recompiled my

524
00:24:15,770 --> 00:24:20,629
kernel without this flag well the

525
00:24:19,490 --> 00:24:25,400
problem with that is that then

526
00:24:20,630 --> 00:24:27,440
everything can catch my my kernel so

527
00:24:25,400 --> 00:24:30,230
malware that gets on to your phone can

528
00:24:27,440 --> 00:24:33,860
actually rootkit your device and we

529
00:24:30,230 --> 00:24:35,180
don't want that but this is kind of

530
00:24:33,860 --> 00:24:37,520
roughly what it looks like after it

531
00:24:35,180 --> 00:24:39,230
after this is done so that there is

532
00:24:37,520 --> 00:24:40,550
literally only read write there was no

533
00:24:39,230 --> 00:24:45,230
readwrite access for any part of the

534
00:24:40,550 --> 00:24:46,850
kernel but I thought about like what

535
00:24:45,230 --> 00:24:50,630
replies these protections and it turns

536
00:24:46,850 --> 00:24:52,669
out mark read-only data are ro is what

537
00:24:50,630 --> 00:24:55,250
gets call to apply these up in these

538
00:24:52,670 --> 00:24:58,760
protections and inside of it are two

539
00:24:55,250 --> 00:25:00,620
functions create mapping light and their

540
00:24:58,760 --> 00:25:05,629
job is to take the kernel and change it

541
00:25:00,620 --> 00:25:07,760
from readwrite X to read-only X but

542
00:25:05,630 --> 00:25:10,640
these are private functions inside a

543
00:25:07,760 --> 00:25:15,230
public function and so we can actually

544
00:25:10,640 --> 00:25:19,820
line those addresses so we take the mark

545
00:25:15,230 --> 00:25:21,590
read-only data disassembly and we find

546
00:25:19,820 --> 00:25:23,030
what we think is that creep mapping

547
00:25:21,590 --> 00:25:25,459
light and we do the same technique and

548
00:25:23,030 --> 00:25:27,860
we get the address and we call it and we

549
00:25:25,460 --> 00:25:30,290
get a crash but it turns out that

550
00:25:27,860 --> 00:25:32,750
compilers are very smart and they like

551
00:25:30,290 --> 00:25:35,629
to optimize code as much as possible and

552
00:25:32,750 --> 00:25:37,220
so instead of this call being crack

553
00:25:35,630 --> 00:25:39,470
mapping lights it ended up being the

554
00:25:37,220 --> 00:25:42,440
function for layers deeper in the code

555
00:25:39,470 --> 00:25:47,120
and it literally just inline them and

556
00:25:42,440 --> 00:25:49,010
this bothered me for weeks and I got to

557
00:25:47,120 --> 00:25:51,439
the point where I was struggling and I

558
00:25:49,010 --> 00:25:53,450
call on the help of a friend a friend of

559
00:25:51,440 --> 00:25:56,090
mine called Brad who came over and we

560
00:25:53,450 --> 00:25:58,250
kind of worked this problem together you

561
00:25:56,090 --> 00:25:59,959
don't have to be an expert yourself you

562
00:25:58,250 --> 00:26:02,340
can always reach out to others to help

563
00:25:59,960 --> 00:26:05,850
you when you get stuck

564
00:26:02,340 --> 00:26:08,820
and so with this on a read on the

565
00:26:05,850 --> 00:26:11,820
colonel you can make it read right patch

566
00:26:08,820 --> 00:26:14,460
and read only and this works for all

567
00:26:11,820 --> 00:26:16,110
Android kernels that I think it works

568
00:26:14,460 --> 00:26:18,630
for all Android kernels with the

569
00:26:16,110 --> 00:26:21,029
exception of Samsung that protects those

570
00:26:18,630 --> 00:26:27,419
permissions using a hypervisor using its

571
00:26:21,029 --> 00:26:30,830
Knox but just remember this all I'm

572
00:26:27,419 --> 00:26:34,020
doing is changing a flag in the kernel

573
00:26:30,830 --> 00:26:36,449
the kernel is on your boot image and if

574
00:26:34,020 --> 00:26:38,250
you've bootloader unlocked what stops

575
00:26:36,450 --> 00:26:40,529
some other piece of malware going in and

576
00:26:38,250 --> 00:26:43,200
flipping that bit there and turning

577
00:26:40,529 --> 00:26:45,390
read/write/execute back on or adding

578
00:26:43,200 --> 00:26:47,730
code to your kernel these are the risks

579
00:26:45,390 --> 00:26:52,590
that you take when you bootloader unlock

580
00:26:47,730 --> 00:26:54,000
your phone so now we're back at the

581
00:26:52,590 --> 00:26:58,439
problem where we actually want to hook

582
00:26:54,000 --> 00:26:59,909
we want to intercept messages and the

583
00:26:58,440 --> 00:27:03,809
problem is I'm still getting crashes

584
00:26:59,909 --> 00:27:07,049
because where this function is the qce

585
00:27:03,809 --> 00:27:09,889
SCM call is actually located too far

586
00:27:07,049 --> 00:27:13,289
away from my driver in address space so

587
00:27:09,890 --> 00:27:16,559
I actually need to do an absolute call

588
00:27:13,289 --> 00:27:19,340
in order to be able to reach it but

589
00:27:16,559 --> 00:27:23,820
backwards compatibility is your friend

590
00:27:19,340 --> 00:27:24,899
because that is SCM arm v8 call that's

591
00:27:23,820 --> 00:27:28,620
just checking whether you've got a

592
00:27:24,899 --> 00:27:31,350
32-bit or 64-bit phone which means that

593
00:27:28,620 --> 00:27:34,350
one of those code paths is never used on

594
00:27:31,350 --> 00:27:37,649
your device and we can use this to our

595
00:27:34,350 --> 00:27:38,879
advantage when we want to hook so we're

596
00:27:37,649 --> 00:27:43,889
going to take the disassembly of that

597
00:27:38,880 --> 00:27:45,750
function that we found we found the call

598
00:27:43,890 --> 00:27:49,230
to get architecture to check whether

599
00:27:45,750 --> 00:27:50,669
it's a 32-bit or a 64-bit phone it's

600
00:27:49,230 --> 00:27:54,240
then going to split whether it is the

601
00:27:50,669 --> 00:27:56,669
32-bit or 64-bit phone it's going to

602
00:27:54,240 --> 00:27:58,529
call the actual function that will send

603
00:27:56,669 --> 00:28:00,830
the message in the data across to secure

604
00:27:58,529 --> 00:28:03,720
world and trustzone

605
00:28:00,830 --> 00:28:06,240
which leaves these bytes here completely

606
00:28:03,720 --> 00:28:07,470
unused and because we've got this

607
00:28:06,240 --> 00:28:11,640
ability to change the channel to

608
00:28:07,470 --> 00:28:14,179
read/write X we can use them so we're

609
00:28:11,640 --> 00:28:16,290
going to set up a very small call stub

610
00:28:14,179 --> 00:28:17,910
inside that we're going to have the

611
00:28:16,290 --> 00:28:21,740
absolute address of our function where

612
00:28:17,910 --> 00:28:23,640
we're going to intercept all calls to

613
00:28:21,740 --> 00:28:26,610
we're going to load it into a register

614
00:28:23,640 --> 00:28:27,960
and call that address and then we're

615
00:28:26,610 --> 00:28:30,090
going to branch back to the original

616
00:28:27,960 --> 00:28:33,540
function and at this point we're set up

617
00:28:30,090 --> 00:28:35,760
a hook stub a way to basically go from a

618
00:28:33,540 --> 00:28:39,180
relative address call to an absolute

619
00:28:35,760 --> 00:28:41,879
address call to redirect flow of

620
00:28:39,180 --> 00:28:44,400
execution to anywhere in the kernel and

621
00:28:41,880 --> 00:28:46,790
in this case we're redirecting it to our

622
00:28:44,400 --> 00:28:49,980
driver so we can see what's going on and

623
00:28:46,790 --> 00:28:53,190
then to turn it on we'll just patch that

624
00:28:49,980 --> 00:28:56,970
call to jump into our stub and we have

625
00:28:53,190 --> 00:28:59,040
now seen every single request for a

626
00:28:56,970 --> 00:29:00,930
trust zone for secure world for trust

627
00:28:59,040 --> 00:29:03,870
let's for loading for unloading of trust

628
00:29:00,930 --> 00:29:05,910
let's all of that stuff we can now see

629
00:29:03,870 --> 00:29:10,290
our function will always get called

630
00:29:05,910 --> 00:29:11,850
first and with that capability you can

631
00:29:10,290 --> 00:29:13,560
do all sorts of kind of crazy stuff you

632
00:29:11,850 --> 00:29:15,719
could build your own firewall for trust

633
00:29:13,560 --> 00:29:17,669
let's so you could say I don't want to

634
00:29:15,720 --> 00:29:20,370
load wide vine so when I see loads for

635
00:29:17,670 --> 00:29:23,490
Widevine DRM I'm just going to drop them

636
00:29:20,370 --> 00:29:25,770
you can then see malicious activity you

637
00:29:23,490 --> 00:29:27,570
can use it for protocol analysis to kind

638
00:29:25,770 --> 00:29:29,070
of understand how you talk to trust

639
00:29:27,570 --> 00:29:36,689
let's in order to create better fuzzing

640
00:29:29,070 --> 00:29:39,330
rigs and so with the ability to

641
00:29:36,690 --> 00:29:43,350
intercept I thought how great would it

642
00:29:39,330 --> 00:29:48,750
be if I could treat a trust 'let like a

643
00:29:43,350 --> 00:29:51,449
Linux driver and to do this I need to be

644
00:29:48,750 --> 00:29:54,690
able to get access to some extra

645
00:29:51,450 --> 00:29:57,450
information the trust zone does not tell

646
00:29:54,690 --> 00:29:59,790
you what's loaded it does not tell you

647
00:29:57,450 --> 00:30:04,140
what trust lets have been loaded but the

648
00:29:59,790 --> 00:30:06,270
QC comm driver it keeps a list so let's

649
00:30:04,140 --> 00:30:08,810
find that list in the driver which again

650
00:30:06,270 --> 00:30:12,389
it's private we can't see it

651
00:30:08,810 --> 00:30:16,169
but some function has to use it that's

652
00:30:12,390 --> 00:30:19,080
public it turns out QC compro does a lot

653
00:30:16,170 --> 00:30:21,330
of initialization and so we can mind

654
00:30:19,080 --> 00:30:24,629
that function for the address of that

655
00:30:21,330 --> 00:30:28,620
structure that contains the list of all

656
00:30:24,630 --> 00:30:30,180
the things that are loaded and so we've

657
00:30:28,620 --> 00:30:33,090
got our probe function

658
00:30:30,180 --> 00:30:34,920
and one of the first thing it does is it

659
00:30:33,090 --> 00:30:38,429
loads up the page address who where that

660
00:30:34,920 --> 00:30:41,280
structure is and then it adds to that

661
00:30:38,430 --> 00:30:43,620
address the offset in that page and it's

662
00:30:41,280 --> 00:30:45,930
a arm arm 64 does this with two

663
00:30:43,620 --> 00:30:49,439
instructions and this is a problem

664
00:30:45,930 --> 00:30:51,090
because you can't guarantee the compiler

665
00:30:49,440 --> 00:30:52,620
is going to put them next to each other

666
00:30:51,090 --> 00:30:57,899
there could be all sorts of stuff in

667
00:30:52,620 --> 00:31:01,790
between but we can do this easier we

668
00:30:57,900 --> 00:31:06,690
don't have to find that add that offset

669
00:31:01,790 --> 00:31:08,490
if we know some magic values in that

670
00:31:06,690 --> 00:31:10,620
structure we can search for those in the

671
00:31:08,490 --> 00:31:12,840
page and it's very similar to the way

672
00:31:10,620 --> 00:31:15,689
that in the Android Bluetooth case I

673
00:31:12,840 --> 00:31:18,270
looked for the magic value of 320 in the

674
00:31:15,690 --> 00:31:19,950
disassembly so we're going to look for

675
00:31:18,270 --> 00:31:21,389
the two version numbers in that

676
00:31:19,950 --> 00:31:23,880
structure located next to each other

677
00:31:21,390 --> 00:31:28,620
because I can know ahead of her time

678
00:31:23,880 --> 00:31:31,140
what the version is and when I find that

679
00:31:28,620 --> 00:31:33,360
spot I also know the shape of the

680
00:31:31,140 --> 00:31:35,490
structure because I've got the Linux

681
00:31:33,360 --> 00:31:37,649
source code and I can subtract its

682
00:31:35,490 --> 00:31:41,100
offset to get the address of that

683
00:31:37,650 --> 00:31:42,750
structure in memory and this is really

684
00:31:41,100 --> 00:31:45,300
cool at this point because that

685
00:31:42,750 --> 00:31:47,760
structure has all the state for

686
00:31:45,300 --> 00:31:53,970
everything happening between android and

687
00:31:47,760 --> 00:31:56,910
secure world and so from this we can now

688
00:31:53,970 --> 00:32:00,680
set up our own calls to unload a trust

689
00:31:56,910 --> 00:32:03,570
let we can also load a trusted in memory

690
00:32:00,680 --> 00:32:07,380
and the way that trusts let's get loaded

691
00:32:03,570 --> 00:32:11,490
into secure world is using this thing

692
00:32:07,380 --> 00:32:14,040
called ion an ion is a Linux device

693
00:32:11,490 --> 00:32:16,170
driver sorry a Linux driver that's

694
00:32:14,040 --> 00:32:19,080
responsible for allocating large chunks

695
00:32:16,170 --> 00:32:20,810
of memory and it can align it can

696
00:32:19,080 --> 00:32:22,770
allocate those chunks of memory

697
00:32:20,810 --> 00:32:25,770
physically one after the other in

698
00:32:22,770 --> 00:32:27,990
physical memory and this is important

699
00:32:25,770 --> 00:32:31,100
because the only thing that's common

700
00:32:27,990 --> 00:32:35,790
between normal world and secure world is

701
00:32:31,100 --> 00:32:37,980
physical addresses and so with the eye

702
00:32:35,790 --> 00:32:39,990
on handle that we can get because we've

703
00:32:37,980 --> 00:32:42,960
got that structure we can allocate

704
00:32:39,990 --> 00:32:44,010
memory that will work perfectly for

705
00:32:42,960 --> 00:32:45,750
trust zone

706
00:32:44,010 --> 00:32:47,700
and then we can put our own trust lit

707
00:32:45,750 --> 00:32:50,220
image in memory into that buffer and

708
00:32:47,700 --> 00:32:53,730
send the advisee khalad rs.2 trust zone

709
00:32:50,220 --> 00:32:58,320
and if it loads we get back and identify

710
00:32:53,730 --> 00:32:59,820
our a 32b identifier and so what I'm

711
00:32:58,320 --> 00:33:03,270
going to do now is going to kind of show

712
00:32:59,820 --> 00:33:07,649
you this driver that I wrote to do this

713
00:33:03,270 --> 00:33:12,770
which I call danger zone so I'm going to

714
00:33:07,650 --> 00:33:12,770
just quickly cut over to Rory

715
00:33:38,090 --> 00:33:40,689
No

716
00:33:41,100 --> 00:33:52,260
oh wow this is gonna be fun all right so

717
00:33:46,890 --> 00:33:56,160
I've just plugged my phone in and I can

718
00:33:52,260 --> 00:33:58,530
connect to my phone using ADB and I can

719
00:33:56,160 --> 00:34:04,020
go to route where I've got permissions

720
00:33:58,530 --> 00:34:05,668
to see load and unload Linux drivers so

721
00:34:04,020 --> 00:34:07,679
there's my joke on drivers as they load

722
00:34:05,669 --> 00:34:11,359
in memory but now we want to actually

723
00:34:07,679 --> 00:34:11,359
load our dangerzone driver

724
00:34:17,409 --> 00:34:28,000
I knew I knew someone was gonna say that

725
00:34:21,429 --> 00:34:31,619
let's see if I can do this who this he's

726
00:34:28,000 --> 00:34:31,619
using the big screen like this is great

727
00:34:32,668 --> 00:34:42,388
that'd be better I'll leave it like this

728
00:34:40,389 --> 00:34:48,750
because in a second you'll see why

729
00:34:42,389 --> 00:34:48,750
okay cool so dangerous

730
00:34:52,440 --> 00:35:10,020
Oh trust me not to spell stuff properly

731
00:34:55,649 --> 00:35:12,270
in a live demo you know cool oh yeah so

732
00:35:10,020 --> 00:35:16,319
the drive is loaded so at the moment we

733
00:35:12,270 --> 00:35:18,809
are now intercepting Qualcomm calls so

734
00:35:16,319 --> 00:35:21,650
what can I do for you today well it

735
00:35:18,809 --> 00:35:26,640
turns out that if I just bring up my

736
00:35:21,650 --> 00:35:28,140
rock K Maciej I can see a log in my

737
00:35:26,640 --> 00:35:30,538
device and my function hook at the

738
00:35:28,140 --> 00:35:34,140
moment just basically logs our system

739
00:35:30,539 --> 00:35:35,579
calls so if I turn off my phone and then

740
00:35:34,140 --> 00:35:37,259
I try and run my finger over the

741
00:35:35,579 --> 00:35:39,180
fingerprint scanner you'll see a whole

742
00:35:37,260 --> 00:35:41,220
bunch of messages swimming by as it

743
00:35:39,180 --> 00:35:44,038
tries to talk to the fingerprint trust

744
00:35:41,220 --> 00:35:46,500
'let insecure lot on my phone and I can

745
00:35:44,039 --> 00:35:48,690
see the application in Android and its

746
00:35:46,500 --> 00:35:50,970
process ID and I can see the trust that

747
00:35:48,690 --> 00:35:52,230
that is talking to and I can see all the

748
00:35:50,970 --> 00:35:54,480
messages that they're sending between

749
00:35:52,230 --> 00:35:56,190
them now this might obviously not work

750
00:35:54,480 --> 00:35:58,980
if it's encrypted because then these

751
00:35:56,190 --> 00:36:01,470
might be encrypted buffers but you can

752
00:35:58,980 --> 00:36:03,000
see it which means you can dissect it so

753
00:36:01,470 --> 00:36:05,038
you can analyze it and then you can

754
00:36:03,000 --> 00:36:08,160
reverse-engineer it and fuzz it and

755
00:36:05,039 --> 00:36:11,250
potentially exploit it but you might

756
00:36:08,160 --> 00:36:15,509
also want as part of this stability to

757
00:36:11,250 --> 00:36:18,420
low trust let's so first my driver which

758
00:36:15,510 --> 00:36:21,119
is comes up under dev dezzy you can see

759
00:36:18,420 --> 00:36:23,880
the list of loaded trusts let's and we

760
00:36:21,119 --> 00:36:25,500
can actually load them as well and so

761
00:36:23,880 --> 00:36:28,289
for this I'm going to use Silvio as an

762
00:36:25,500 --> 00:36:30,029
example because as it turns out you can

763
00:36:28,289 --> 00:36:35,670
load trustless under whatever name you

764
00:36:30,029 --> 00:36:38,059
like so I'm going to send Silvio to the

765
00:36:35,670 --> 00:36:38,059
danger zone

766
00:36:40,830 --> 00:36:44,880
so all your trust lets or at least a lot

767
00:36:43,470 --> 00:36:48,270
of them are located under vendor

768
00:36:44,880 --> 00:36:51,230
firmware Widevine is like Google's DRM

769
00:36:48,270 --> 00:36:51,230
encryption trust let

770
00:36:57,059 --> 00:37:03,359
there we are we've just floated a truss

771
00:36:58,890 --> 00:37:04,828
let that easy just like a driver and you

772
00:37:03,359 --> 00:37:07,078
can load any trust lit but what's

773
00:37:04,829 --> 00:37:09,269
interesting is that if I try to load

774
00:37:07,079 --> 00:37:11,819
Widevine under a different name now it

775
00:37:09,269 --> 00:37:13,919
would fail so trust zone is keeping some

776
00:37:11,819 --> 00:37:17,219
kind of list of trusts lots that are

777
00:37:13,919 --> 00:37:20,219
loaded and because I've loaded this one

778
00:37:17,219 --> 00:37:22,529
as sylvio applications my phone that now

779
00:37:20,219 --> 00:37:24,419
want Widevine kind of she load it so

780
00:37:22,529 --> 00:37:28,829
I've actually dust my phone from being

781
00:37:24,419 --> 00:37:31,828
able to do DRM at the moment so maybe

782
00:37:28,829 --> 00:37:34,939
what we can do is we can unload silver

783
00:37:31,829 --> 00:37:34,939
we'll get Silvio out of the danger zone

784
00:37:42,760 --> 00:37:50,280
and it's back to the way it was and if

785
00:37:45,280 --> 00:37:52,330
we look at look at prop Kane message

786
00:37:50,280 --> 00:37:54,850
they can see the one above there which

787
00:37:52,330 --> 00:37:57,190
is our juicy comm app shutdown command

788
00:37:54,850 --> 00:37:58,690
so we can even see our loads and unload

789
00:37:57,190 --> 00:38:02,730
because we're hooked so high up in the

790
00:37:58,690 --> 00:38:05,740
kernel okay

791
00:38:02,730 --> 00:38:07,869
and so with that that kind of concludes

792
00:38:05,740 --> 00:38:09,640
my talk and all my code is available on

793
00:38:07,869 --> 00:38:12,430
my get lab page including the danger

794
00:38:09,640 --> 00:38:14,020
zone driver that's my twitter handle but

795
00:38:12,430 --> 00:38:15,730
if you want to contact me I would

796
00:38:14,020 --> 00:38:19,210
recommend emailing me if you have

797
00:38:15,730 --> 00:38:22,869
questions because I'm not I'm not a very

798
00:38:19,210 --> 00:38:24,790
competent Twitter user yet but yes if

799
00:38:22,869 --> 00:38:31,750
there are any questions I'm happy to

800
00:38:24,790 --> 00:38:34,770
answer I can't actually see anyone and

801
00:38:31,750 --> 00:38:34,770
see what is coming up to give me a hand

802
00:38:36,090 --> 00:38:40,619
do we have Mike runners just up the

803
00:38:38,380 --> 00:38:40,619
front

804
00:38:46,549 --> 00:38:49,549
okay

805
00:38:49,770 --> 00:38:52,820
I'll repeat the question

806
00:38:58,770 --> 00:39:03,460
okay so the question is do trust let's

807
00:39:01,600 --> 00:39:06,400
need signing before they'll be allowed

808
00:39:03,460 --> 00:39:08,050
to be loaded by the trusting and my

809
00:39:06,400 --> 00:39:09,940
understanding is that yes the trust zone

810
00:39:08,050 --> 00:39:12,430
itself checks the signatures of trust

811
00:39:09,940 --> 00:39:13,870
that's before they're loaded however I

812
00:39:12,430 --> 00:39:15,730
think depending on the implementation

813
00:39:13,870 --> 00:39:20,170
and the version and the age of your

814
00:39:15,730 --> 00:39:22,630
phone the whether it actually has a

815
00:39:20,170 --> 00:39:23,800
white list and a black list of bad trust

816
00:39:22,630 --> 00:39:26,860
'lets that have been proven to be

817
00:39:23,800 --> 00:39:29,020
vulnerable can vary so depending on your

818
00:39:26,860 --> 00:39:30,940
device you might have a signed trust

819
00:39:29,020 --> 00:39:34,810
that with a vulnerability that can

820
00:39:30,940 --> 00:39:36,370
actually still be loaded so yes they do

821
00:39:34,810 --> 00:39:38,950
need to be signed in order to be loaded

822
00:39:36,370 --> 00:39:40,240
although maybe this might help people

823
00:39:38,950 --> 00:39:44,200
fuzz that and actually see if there's

824
00:39:40,240 --> 00:39:46,589
any issues in that area any more

825
00:39:44,200 --> 00:39:46,589
questions

826
00:39:47,830 --> 00:39:53,259
so I'm just wondering can this technique

827
00:39:50,740 --> 00:39:55,509
be used to extract device encryption

828
00:39:53,260 --> 00:39:59,680
keys that are used for like full device

829
00:39:55,510 --> 00:40:03,430
encryption etc okay can this be used to

830
00:39:59,680 --> 00:40:05,169
extract device encryption keys so for

831
00:40:03,430 --> 00:40:07,330
those who aren't aware device encryption

832
00:40:05,170 --> 00:40:09,340
keys are very very special values that

833
00:40:07,330 --> 00:40:11,440
are kept secure and locked down inside

834
00:40:09,340 --> 00:40:13,030
the secured world they're the things

835
00:40:11,440 --> 00:40:15,910
that are back all your encryption

836
00:40:13,030 --> 00:40:19,720
including your full disk encryption on

837
00:40:15,910 --> 00:40:21,730
your Android devices for example in

838
00:40:19,720 --> 00:40:25,000
theory they should not be made available

839
00:40:21,730 --> 00:40:28,000
to anywhere outside their trust let let

840
00:40:25,000 --> 00:40:31,240
alone anywhere in the normal world in

841
00:40:28,000 --> 00:40:33,610
the Linux kernel but phones are built by

842
00:40:31,240 --> 00:40:35,770
a wide variety of manufacturers and I

843
00:40:33,610 --> 00:40:37,150
would not be surprised if you know

844
00:40:35,770 --> 00:40:39,759
someone conducting research in this

845
00:40:37,150 --> 00:40:42,880
space actually found some terrible phone

846
00:40:39,760 --> 00:40:45,370
that leaked a device key so the answer

847
00:40:42,880 --> 00:40:48,250
is no it shouldn't be possible but

848
00:40:45,370 --> 00:40:56,700
people in general including myself are

849
00:40:48,250 --> 00:40:56,700
terrible programmers any more questions

850
00:41:01,080 --> 00:41:05,390
so let's think pate for a great talk

851
00:41:05,410 --> 00:41:12,520
[Applause]

