1
00:00:03,160 --> 00:00:07,490
thanks everyone so I'm a whore and yeah

2
00:00:06,020 --> 00:00:08,840
I'm gonna talk about formal verification

3
00:00:07,490 --> 00:00:13,160
and whether that leads to better

4
00:00:08,840 --> 00:00:15,799
security I'm a systems engineer I'm not

5
00:00:13,160 --> 00:00:18,950
a formal methods person however I do

6
00:00:15,799 --> 00:00:21,200
work with I do work in the team that

7
00:00:18,950 --> 00:00:22,480
developed SEO for microkernel that's the

8
00:00:21,200 --> 00:00:25,130
world's first formally verified

9
00:00:22,480 --> 00:00:26,570
operating systems kernel and so I know a

10
00:00:25,130 --> 00:00:29,919
lot of formal methods peoples and I'm

11
00:00:26,570 --> 00:00:32,448
I'm also even friends with some of them

12
00:00:29,920 --> 00:00:33,920
I've heard a lot about formal methods

13
00:00:32,448 --> 00:00:35,360
and I've heard a lot about how formal

14
00:00:33,920 --> 00:00:38,210
verification is great and how it leads

15
00:00:35,360 --> 00:00:40,190
to better security and so on and slowly

16
00:00:38,210 --> 00:00:41,660
that message is sunk in but I really it

17
00:00:40,190 --> 00:00:43,430
took me a while to really kind of

18
00:00:41,660 --> 00:00:46,220
understand why that's the case as a

19
00:00:43,430 --> 00:00:48,340
systems person so I'm gonna try to

20
00:00:46,220 --> 00:00:50,660
distill some of that knowledge here and

21
00:00:48,340 --> 00:00:52,880
hopefully pass it on to you as well

22
00:00:50,660 --> 00:00:55,640
quick show of hands who here considers

23
00:00:52,880 --> 00:00:56,809
themselves a formal methods person all

24
00:00:55,640 --> 00:01:00,559
right that's what I thought not very

25
00:00:56,809 --> 00:01:06,979
many so that's good because I'm not one

26
00:01:00,559 --> 00:01:09,920
either so as I mentioned we're the

27
00:01:06,979 --> 00:01:12,709
trustworthy systems group and we

28
00:01:09,920 --> 00:01:14,149
developed a formally verified operating

29
00:01:12,709 --> 00:01:16,069
systems microkernel and when that got

30
00:01:14,149 --> 00:01:17,539
released when we started doing things we

31
00:01:16,069 --> 00:01:20,060
started seeing headlines like these

32
00:01:17,539 --> 00:01:25,490
hacker-proof coding hackers can't break

33
00:01:20,060 --> 00:01:28,819
this hacker proof it's unhackable etc

34
00:01:25,490 --> 00:01:31,039
etc so when you see these kinds of

35
00:01:28,819 --> 00:01:32,719
headlines you're either gonna cringe

36
00:01:31,039 --> 00:01:34,159
with dread or you're gonna get giddy

37
00:01:32,719 --> 00:01:40,520
with anticipation that you're gonna

38
00:01:34,159 --> 00:01:42,259
break this hacker proof code so I want

39
00:01:40,520 --> 00:01:44,630
to talk about whether form of

40
00:01:42,259 --> 00:01:47,959
verification really does lead to better

41
00:01:44,630 --> 00:01:50,359
security and whether that's the same as

42
00:01:47,959 --> 00:01:51,979
hacker-proof code so is it really true

43
00:01:50,359 --> 00:01:54,589
that we have hacker proof code or not

44
00:01:51,979 --> 00:01:57,799
I'll give you a bit of a spoiler yes it

45
00:01:54,590 --> 00:02:00,219
does lead to better security but no

46
00:01:57,799 --> 00:02:03,859
that's not the same as hacker-proof code

47
00:02:00,219 --> 00:02:06,020
so I'm gonna give an overview of form of

48
00:02:03,859 --> 00:02:09,318
verification in introduction to non FM

49
00:02:06,020 --> 00:02:10,910
people then I'm gonna talk about why we

50
00:02:09,318 --> 00:02:12,560
claim that form of verification does

51
00:02:10,910 --> 00:02:14,270
lead to better security so what is

52
00:02:12,560 --> 00:02:15,860
better security and why does it lead to

53
00:02:14,270 --> 00:02:18,290
and then I'm gonna talk about why that

54
00:02:15,860 --> 00:02:21,890
isn't the same as hack proof code why

55
00:02:18,290 --> 00:02:25,220
it's not a silver bullet so formal

56
00:02:21,890 --> 00:02:28,179
verification formal verification is

57
00:02:25,220 --> 00:02:30,710
proving properties about stuff with math

58
00:02:28,180 --> 00:02:31,250
now properties can be a lot of different

59
00:02:30,710 --> 00:02:34,340
things

60
00:02:31,250 --> 00:02:35,960
this can be correctness

61
00:02:34,340 --> 00:02:38,660
this can be security this can be things

62
00:02:35,960 --> 00:02:40,370
like liveness safety and so on and then

63
00:02:38,660 --> 00:02:42,680
stuff can also be a lot of different

64
00:02:40,370 --> 00:02:44,660
things this can be code this can be

65
00:02:42,680 --> 00:02:48,080
protocols this can be hardware

66
00:02:44,660 --> 00:02:51,170
this can be processes etc people prove

67
00:02:48,080 --> 00:02:54,080
stuff people prove properties about lots

68
00:02:51,170 --> 00:02:57,049
of different stuff so for this talk I'm

69
00:02:54,080 --> 00:03:01,670
gonna focus on proving correctness about

70
00:02:57,050 --> 00:03:02,990
code about software so if you think

71
00:03:01,670 --> 00:03:04,549
about if you ask anyone

72
00:03:02,990 --> 00:03:06,650
when is code correct when do you

73
00:03:04,550 --> 00:03:08,810
consider code correct mostly people will

74
00:03:06,650 --> 00:03:11,000
say well when it does the thing I expect

75
00:03:08,810 --> 00:03:12,800
it to do so I have some expectation of

76
00:03:11,000 --> 00:03:15,020
what the code should do I wrote it

77
00:03:12,800 --> 00:03:18,110
write it I run tests until it does what

78
00:03:15,020 --> 00:03:19,460
I think it should do more formally

79
00:03:18,110 --> 00:03:21,080
that's the specification you have a

80
00:03:19,460 --> 00:03:22,940
specification for what your code should

81
00:03:21,080 --> 00:03:25,490
do and it's correct when it meets that

82
00:03:22,940 --> 00:03:27,230
specification so if we want to do formal

83
00:03:25,490 --> 00:03:29,440
verification we need to have a formal

84
00:03:27,230 --> 00:03:31,940
specification of the code this is

85
00:03:29,440 --> 00:03:35,510
something that's precise something

86
00:03:31,940 --> 00:03:37,970
that's unambiguous and abstract it tells

87
00:03:35,510 --> 00:03:41,899
us what the code should do not

88
00:03:37,970 --> 00:03:43,550
necessarily how so as an example if we

89
00:03:41,900 --> 00:03:45,320
want to talk about lists and sorting

90
00:03:43,550 --> 00:03:49,160
lists we can have a formal specification

91
00:03:45,320 --> 00:03:51,440
of what a sorted list is informally we

92
00:03:49,160 --> 00:03:54,170
might well we have a function called

93
00:03:51,440 --> 00:03:57,079
sort list a for abstract that takes a

94
00:03:54,170 --> 00:04:00,079
input list and outputs a list so input

95
00:03:57,080 --> 00:04:02,390
is L output is L prime and informally we

96
00:04:00,080 --> 00:04:04,870
can say well this specification for

97
00:04:02,390 --> 00:04:07,459
sorting a list is that L prime is sorted

98
00:04:04,870 --> 00:04:09,710
which is nice but formally we want to be

99
00:04:07,460 --> 00:04:11,840
a little bit more specific so we provide

100
00:04:09,710 --> 00:04:13,220
a more formal definition the input list

101
00:04:11,840 --> 00:04:15,500
and the output list are the same length

102
00:04:13,220 --> 00:04:19,070
the output list is a permutation of the

103
00:04:15,500 --> 00:04:22,729
input list and the elements in the

104
00:04:19,070 --> 00:04:24,680
output list are increasingly larger we

105
00:04:22,729 --> 00:04:26,359
also deal with abstract data types

106
00:04:24,680 --> 00:04:28,310
rather than concrete data types so in

107
00:04:26,360 --> 00:04:30,980
our formal specifications we'll have

108
00:04:28,310 --> 00:04:32,960
an abstract list something that you can

109
00:04:30,980 --> 00:04:34,850
index something that you can take the

110
00:04:32,960 --> 00:04:36,049
length of and so on but it doesn't tell

111
00:04:34,850 --> 00:04:38,060
us how the list is necessarily

112
00:04:36,050 --> 00:04:39,470
implemented so it's different than an

113
00:04:38,060 --> 00:04:42,170
implementation which might be a linked

114
00:04:39,470 --> 00:04:45,530
list for example and then we have our

115
00:04:42,170 --> 00:04:47,060
implementation this is code for example

116
00:04:45,530 --> 00:04:49,429
the in the C language or another

117
00:04:47,060 --> 00:04:52,220
language and it's concrete it tells us

118
00:04:49,430 --> 00:04:54,770
how we do something not just what but

119
00:04:52,220 --> 00:04:57,080
how so we call the form of specification

120
00:04:54,770 --> 00:05:00,440
a we call the for abstract and we call

121
00:04:57,080 --> 00:05:02,450
the implantation C for concrete now when

122
00:05:00,440 --> 00:05:04,340
we're doing formal verification we use a

123
00:05:02,450 --> 00:05:06,530
formal model of the code so we don't use

124
00:05:04,340 --> 00:05:08,510
C source code directly but we use a

125
00:05:06,530 --> 00:05:10,039
formal representation of C code for

126
00:05:08,510 --> 00:05:12,469
example and that comes with a whole

127
00:05:10,040 --> 00:05:15,350
bunch of rules about what the semantics

128
00:05:12,470 --> 00:05:19,070
of the C code are is so what happens

129
00:05:15,350 --> 00:05:22,130
when you run certain instructions great

130
00:05:19,070 --> 00:05:25,430
so given this formal specification given

131
00:05:22,130 --> 00:05:29,180
this code we want to prove that it's

132
00:05:25,430 --> 00:05:30,800
correct so what does that mean a little

133
00:05:29,180 --> 00:05:33,610
bit more formally we want to prove that

134
00:05:30,800 --> 00:05:36,830
the state after executing the code

135
00:05:33,610 --> 00:05:40,220
fulfills the specification the abstract

136
00:05:36,830 --> 00:05:42,740
specification so what do we mean by the

137
00:05:40,220 --> 00:05:44,540
state well we have an initial state we

138
00:05:42,740 --> 00:05:47,960
have some state of the system some

139
00:05:44,540 --> 00:05:49,640
abstract state of the system we execute

140
00:05:47,960 --> 00:05:51,770
the code and then we have some state

141
00:05:49,640 --> 00:05:53,930
after executing the code so we have s as

142
00:05:51,770 --> 00:05:56,990
the initial state T is the state after

143
00:05:53,930 --> 00:05:59,080
execution and then execution is defined

144
00:05:56,990 --> 00:06:01,850
formally by the formal model of the code

145
00:05:59,080 --> 00:06:05,979
and it defines the behavior of each

146
00:06:01,850 --> 00:06:09,110
command and how it modifies the state so

147
00:06:05,980 --> 00:06:12,110
once we run the code we have some idea

148
00:06:09,110 --> 00:06:17,240
of how the initial state is modified to

149
00:06:12,110 --> 00:06:19,220
the final state so what do we want to

150
00:06:17,240 --> 00:06:21,560
prove well we want to prove that the

151
00:06:19,220 --> 00:06:24,140
final state after executing the code so

152
00:06:21,560 --> 00:06:26,480
state T fulfills whatever specification

153
00:06:24,140 --> 00:06:27,560
we have and there are two common

154
00:06:26,480 --> 00:06:29,780
approaches to doing that

155
00:06:27,560 --> 00:06:31,070
the first is whore logic the second is

156
00:06:29,780 --> 00:06:35,059
refinement so I'll talk about both of

157
00:06:31,070 --> 00:06:36,380
those the idea behind whore logic is to

158
00:06:35,060 --> 00:06:38,690
introduce these things called whore

159
00:06:36,380 --> 00:06:41,569
triples and a horrible consists of a

160
00:06:38,690 --> 00:06:46,399
precondition some code and a post

161
00:06:41,569 --> 00:06:48,469
condition in the intuition behind whore

162
00:06:46,399 --> 00:06:49,999
logic and doing proofs in her logics and

163
00:06:48,469 --> 00:06:53,779
these in these in these heart triples is

164
00:06:49,999 --> 00:06:57,830
that if the precondition P holds before

165
00:06:53,779 --> 00:07:00,289
you execute your code C then the post

166
00:06:57,830 --> 00:07:02,688
condition Q will hold as well in a

167
00:07:00,289 --> 00:07:04,759
correct program so if the program is

168
00:07:02,689 --> 00:07:09,199
correct if P holds and then you do

169
00:07:04,759 --> 00:07:11,300
execute C then Q will hold so as an

170
00:07:09,199 --> 00:07:13,580
example we could say that the

171
00:07:11,300 --> 00:07:16,969
precondition for our abstract sort

172
00:07:13,580 --> 00:07:19,128
function is that L is a valid list so

173
00:07:16,969 --> 00:07:21,498
the input list is a valid list and the

174
00:07:19,129 --> 00:07:24,289
post condition after we sort the list is

175
00:07:21,499 --> 00:07:27,949
that the output list is a valid list

176
00:07:24,289 --> 00:07:29,209
that there's a permutation and that the

177
00:07:27,949 --> 00:07:31,550
elements are increasing so this is

178
00:07:29,209 --> 00:07:33,409
basically our specification and so we

179
00:07:31,550 --> 00:07:35,539
find that when we're doing this kind of

180
00:07:33,409 --> 00:07:37,219
whore logic these are triples that our

181
00:07:35,539 --> 00:07:39,378
post condition is typically what

182
00:07:37,219 --> 00:07:42,498
represents our representing our

183
00:07:39,379 --> 00:07:46,039
specification it's a desired property of

184
00:07:42,499 --> 00:07:48,769
the code when we want to prove such a

185
00:07:46,039 --> 00:07:51,529
whore triple we need to prove that if P

186
00:07:48,769 --> 00:07:53,509
holds for the initial state when we then

187
00:07:51,529 --> 00:07:55,789
modify that state using the commands in

188
00:07:53,509 --> 00:07:59,119
to state T then Q will hold for that

189
00:07:55,789 --> 00:08:00,800
final state and in doing the proof we

190
00:07:59,119 --> 00:08:02,839
use the behaviors as defined in the

191
00:08:00,800 --> 00:08:05,449
formal model of the language of the

192
00:08:02,839 --> 00:08:07,430
implementation to show for each command

193
00:08:05,449 --> 00:08:09,439
how it modifies the state and that the

194
00:08:07,430 --> 00:08:11,240
final state matches Q if we have a

195
00:08:09,439 --> 00:08:14,839
larger program with a lot of commands

196
00:08:11,240 --> 00:08:16,999
then we break that up in 2 sub-goals so

197
00:08:14,839 --> 00:08:18,860
we have kind of sub post conditions and

198
00:08:16,999 --> 00:08:21,439
sub preconditions but we show that the

199
00:08:18,860 --> 00:08:25,759
overall chained fit matches those

200
00:08:21,439 --> 00:08:27,800
initial pre and post conditions the

201
00:08:25,759 --> 00:08:30,169
other approach is refinement so we say

202
00:08:27,800 --> 00:08:31,519
that the implementation refines the

203
00:08:30,169 --> 00:08:34,098
specification so the concrete

204
00:08:31,519 --> 00:08:36,289
implementation refines the abstract

205
00:08:34,099 --> 00:08:39,349
specification and the intuition behind

206
00:08:36,289 --> 00:08:42,139
that is that any behavior in the

207
00:08:39,349 --> 00:08:44,269
concrete implementation is allowed by

208
00:08:42,139 --> 00:08:47,870
the abstract specification as well as

209
00:08:44,269 --> 00:08:50,019
any behavior or sorry all the behaviors

210
00:08:47,870 --> 00:08:54,370
in the abstract specification are

211
00:08:50,019 --> 00:08:54,370
present in in the concrete code

212
00:08:54,540 --> 00:08:58,500
typically we'll separate the

213
00:08:56,860 --> 00:09:03,570
specification in the implementation and

214
00:08:58,500 --> 00:09:06,010
the specification will have an abstract

215
00:09:03,570 --> 00:09:08,140
version or abstract specification of

216
00:09:06,010 --> 00:09:11,700
every function that's in the concrete

217
00:09:08,140 --> 00:09:14,050
implementation so for example our

218
00:09:11,700 --> 00:09:15,880
abstract specification could be an

219
00:09:14,050 --> 00:09:17,770
abstract function to sort the list which

220
00:09:15,880 --> 00:09:19,390
again has the same properties that we

221
00:09:17,770 --> 00:09:21,460
talked about before the lengths are the

222
00:09:19,390 --> 00:09:25,720
same it's a permutation and the elements

223
00:09:21,460 --> 00:09:30,180
are increasing where we want to prove

224
00:09:25,720 --> 00:09:36,430
refinement what we need to show is that

225
00:09:30,180 --> 00:09:38,949
when the concrete code and the abstract

226
00:09:36,430 --> 00:09:41,729
code start in an initial State and then

227
00:09:38,950 --> 00:09:45,760
you execute them the state that they end

228
00:09:41,730 --> 00:09:47,410
up in is essentially equivalent so they

229
00:09:45,760 --> 00:09:49,420
start in a state that's essentially

230
00:09:47,410 --> 00:09:50,949
equivalent they end up in a state that's

231
00:09:49,420 --> 00:09:53,229
also essentially equivalent which means

232
00:09:50,950 --> 00:09:54,580
they do the same thing now we need to

233
00:09:53,230 --> 00:09:56,650
formalize this essentially equivalent

234
00:09:54,580 --> 00:10:00,520
idea and so we introduce a state

235
00:09:56,650 --> 00:10:02,890
relation and this talks about how the

236
00:10:00,520 --> 00:10:04,990
initial State or the concrete state maps

237
00:10:02,890 --> 00:10:06,850
to the abstract State what's the

238
00:10:04,990 --> 00:10:09,430
relation between the two states so

239
00:10:06,850 --> 00:10:11,680
here's an example of a state relation

240
00:10:09,430 --> 00:10:14,829
that says okay well the lengths are the

241
00:10:11,680 --> 00:10:17,199
same and the elements of the lists are

242
00:10:14,830 --> 00:10:18,760
the same so if we have two essentially

243
00:10:17,200 --> 00:10:22,210
equivalent States in the abstract and

244
00:10:18,760 --> 00:10:23,470
the concrete then they should two lists

245
00:10:22,210 --> 00:10:24,820
should have the same length and the same

246
00:10:23,470 --> 00:10:27,340
elements and then the states are the

247
00:10:24,820 --> 00:10:30,520
same we take this state relation and

248
00:10:27,340 --> 00:10:32,080
then we show that formally that if the

249
00:10:30,520 --> 00:10:35,560
state relation holds between the initial

250
00:10:32,080 --> 00:10:39,190
States s and s prime then after we

251
00:10:35,560 --> 00:10:41,319
execute C after we execute a the state T

252
00:10:39,190 --> 00:10:43,210
and T prime will also have the state

253
00:10:41,320 --> 00:10:45,880
relation between them hold and if that's

254
00:10:43,210 --> 00:10:52,150
the case then we can say that C refines

255
00:10:45,880 --> 00:10:52,720
a so we have this kind of nice square so

256
00:10:52,150 --> 00:10:55,060
that's nice

257
00:10:52,720 --> 00:10:56,890
so that's formal formal verification 101

258
00:10:55,060 --> 00:11:01,569
hopefully everyone now can go off and

259
00:10:56,890 --> 00:11:03,640
prove code correct but this still

260
00:11:01,570 --> 00:11:08,470
doesn't tell us how this formal

261
00:11:03,640 --> 00:11:10,630
verification leads to better security so

262
00:11:08,470 --> 00:11:14,620
before talking about that what do I mean

263
00:11:10,630 --> 00:11:18,160
by better security well bad security

264
00:11:14,620 --> 00:11:23,770
means we have vulnerabilities so better

265
00:11:18,160 --> 00:11:25,329
security means less vulnerabilities what

266
00:11:23,770 --> 00:11:27,430
do we mean by vulnerabilities well I

267
00:11:25,330 --> 00:11:29,530
don't really need to tell you much about

268
00:11:27,430 --> 00:11:31,030
them but just to make it complete we

269
00:11:29,530 --> 00:11:32,740
have three classes of vulnerabilities so

270
00:11:31,030 --> 00:11:34,510
there's the design vulnerabilities where

271
00:11:32,740 --> 00:11:36,430
you make a mistake in your design or

272
00:11:34,510 --> 00:11:38,590
your architecture of the system such

273
00:11:36,430 --> 00:11:39,969
that it doesn't actually fulfill the

274
00:11:38,590 --> 00:11:42,370
security policy that you want

275
00:11:39,970 --> 00:11:44,410
we've got implementation vulnerabilities

276
00:11:42,370 --> 00:11:46,840
where you make mistakes in your code

277
00:11:44,410 --> 00:11:49,630
that allow people to use those mistakes

278
00:11:46,840 --> 00:11:51,130
use those bugs to bypass your security

279
00:11:49,630 --> 00:11:52,870
policy in bypass your security

280
00:11:51,130 --> 00:11:54,460
mechanisms and then we've got

281
00:11:52,870 --> 00:11:56,320
operational vulnerabilities where you

282
00:11:54,460 --> 00:11:59,350
make mistakes in how you actually deploy

283
00:11:56,320 --> 00:12:01,060
or configure your system or people make

284
00:11:59,350 --> 00:12:02,800
mistakes so you get social engineering

285
00:12:01,060 --> 00:12:04,089
you get people who are just make

286
00:12:02,800 --> 00:12:07,630
mistakes or not very good at what they

287
00:12:04,090 --> 00:12:09,700
do formal verification can help us with

288
00:12:07,630 --> 00:12:11,110
the design vulnerabilities and the

289
00:12:09,700 --> 00:12:16,210
implementation vulnerabilities so I'll

290
00:12:11,110 --> 00:12:19,330
talk about how they do that I talked

291
00:12:16,210 --> 00:12:22,090
about how formal verification allows us

292
00:12:19,330 --> 00:12:23,800
to prove properties about code which is

293
00:12:22,090 --> 00:12:25,690
nice but typically those properties

294
00:12:23,800 --> 00:12:27,760
don't relate to security they talk about

295
00:12:25,690 --> 00:12:30,880
things like the list is sorted they talk

296
00:12:27,760 --> 00:12:32,439
about application domain properties

297
00:12:30,880 --> 00:12:35,860
which are not necessarily security

298
00:12:32,440 --> 00:12:38,320
however it gives us an extra benefit and

299
00:12:35,860 --> 00:12:39,880
it also helps us to prevent

300
00:12:38,320 --> 00:12:43,750
implementation vulnerabilities so that

301
00:12:39,880 --> 00:12:44,740
if we can prove these nice abstract

302
00:12:43,750 --> 00:12:47,350
properties these nice application

303
00:12:44,740 --> 00:12:49,570
specific properties about our code we

304
00:12:47,350 --> 00:12:51,280
can also prove that a bunch of

305
00:12:49,570 --> 00:12:55,089
implementation vulnerabilities don't

306
00:12:51,280 --> 00:12:58,209
exist in that code why is that well a

307
00:12:55,089 --> 00:13:00,070
lot of implementation bugs happen

308
00:12:58,210 --> 00:13:03,850
because they're actually undefined

309
00:13:00,070 --> 00:13:06,220
behavior this is things like array or

310
00:13:03,850 --> 00:13:08,920
list bound overflows if you access past

311
00:13:06,220 --> 00:13:11,800
the bound of a defined array that's

312
00:13:08,920 --> 00:13:13,870
really undefined behavior especially in

313
00:13:11,800 --> 00:13:15,430
your formal model integer overflow and

314
00:13:13,870 --> 00:13:17,320
underflow is if your integers don't have

315
00:13:15,430 --> 00:13:20,349
limits then you don't overflow or

316
00:13:17,320 --> 00:13:20,890
underflow them so that doesn't really

317
00:13:20,350 --> 00:13:22,329
exist

318
00:13:20,890 --> 00:13:24,369
following null pointers is

319
00:13:22,329 --> 00:13:26,410
to find behavior and so on so our

320
00:13:24,369 --> 00:13:28,119
specification formalisms in the

321
00:13:26,410 --> 00:13:29,589
languages we use for the specifications

322
00:13:28,119 --> 00:13:32,049
don't allow these things to happen

323
00:13:29,589 --> 00:13:36,009
you're not allowed to define it in that

324
00:13:32,049 --> 00:13:38,920
language because it's undefined so these

325
00:13:36,009 --> 00:13:41,769
kind of implementation bugs that most of

326
00:13:38,920 --> 00:13:45,219
you love don't happen in the formal

327
00:13:41,769 --> 00:13:47,769
specs of course they do happen in real

328
00:13:45,220 --> 00:13:50,100
code so writing past the end of array is

329
00:13:47,769 --> 00:13:54,910
something that C programmers love to do

330
00:13:50,100 --> 00:13:57,009
they do it all the time what we need to

331
00:13:54,910 --> 00:13:59,170
do is make sure that doesn't happen and

332
00:13:57,009 --> 00:14:02,739
so what happens is that if you try to

333
00:13:59,170 --> 00:14:05,019
prove that this kind of code fulfills

334
00:14:02,739 --> 00:14:06,369
its specification and again that

335
00:14:05,019 --> 00:14:07,839
specification may have nothing to do

336
00:14:06,369 --> 00:14:08,579
with array bounds it could be something

337
00:14:07,839 --> 00:14:11,980
else

338
00:14:08,579 --> 00:14:14,138
you'll fail you won't be able to prove

339
00:14:11,980 --> 00:14:16,089
that code that contains these kind of

340
00:14:14,139 --> 00:14:19,480
statements fulfill their specification

341
00:14:16,089 --> 00:14:23,369
so for example the end state after you

342
00:14:19,480 --> 00:14:26,829
try to access an array out of bounds

343
00:14:23,369 --> 00:14:29,679
formally is not defined there is no

344
00:14:26,829 --> 00:14:31,809
state and so trying to prove properties

345
00:14:29,679 --> 00:14:32,439
about something that has no state is not

346
00:14:31,809 --> 00:14:35,439
going to work

347
00:14:32,439 --> 00:14:38,469
furthermore there are no rules that you

348
00:14:35,439 --> 00:14:41,769
can apply in your proof about no state

349
00:14:38,470 --> 00:14:43,540
and so you can't continue your proof so

350
00:14:41,769 --> 00:14:45,730
trying to prove something with these

351
00:14:43,540 --> 00:14:49,059
kind of bugs in it just won't work you

352
00:14:45,730 --> 00:14:53,199
won't be able to prove it and so that

353
00:14:49,059 --> 00:14:56,079
forces you to either fix your code if

354
00:14:53,199 --> 00:14:58,540
you want to continue your proof or if

355
00:14:56,079 --> 00:15:00,969
you're sure that your code is not broken

356
00:14:58,540 --> 00:15:02,319
which you know none of us write broken

357
00:15:00,970 --> 00:15:05,379
code so we're sure of that

358
00:15:02,319 --> 00:15:06,759
you need to prove that the conditions

359
00:15:05,379 --> 00:15:09,189
that lead to the undefined behavior

360
00:15:06,759 --> 00:15:12,759
won't happen so if you're certain that

361
00:15:09,189 --> 00:15:14,618
your array indexing code will never you

362
00:15:12,759 --> 00:15:16,959
know Index the array out of bounds then

363
00:15:14,619 --> 00:15:19,149
you need to prove that in order to

364
00:15:16,959 --> 00:15:22,149
continue proof so once you get a fully

365
00:15:19,149 --> 00:15:26,619
proved system then you know these things

366
00:15:22,149 --> 00:15:29,379
don't exist the big benefit of that is

367
00:15:26,619 --> 00:15:31,389
that you're proving properties

368
00:15:29,379 --> 00:15:34,839
interesting properties about your system

369
00:15:31,389 --> 00:15:35,730
and without having to specify all of

370
00:15:34,839 --> 00:15:39,120
these implements

371
00:15:35,730 --> 00:15:42,480
vulnerabilities or bugs the proof for

372
00:15:39,120 --> 00:15:45,180
free finds those vulnerabilities for you

373
00:15:42,480 --> 00:15:47,459
finds those bugs for you and forces you

374
00:15:45,180 --> 00:15:48,930
to do something about them so you don't

375
00:15:47,459 --> 00:15:51,300
have to tell the system you know find me

376
00:15:48,930 --> 00:15:52,709
all the array bound overflows it finds

377
00:15:51,300 --> 00:15:55,160
this for you because those are undefined

378
00:15:52,709 --> 00:15:58,319
so whole classes of undefined behavior

379
00:15:55,160 --> 00:16:03,990
just disappear once you've proved your

380
00:15:58,320 --> 00:16:06,269
system so that's really great I want to

381
00:16:03,990 --> 00:16:08,370
go into a little bit more practical

382
00:16:06,269 --> 00:16:11,100
detail so I have said we've we have this

383
00:16:08,370 --> 00:16:14,220
verified operating system and I want to

384
00:16:11,100 --> 00:16:16,380
talk about what we've done how you apply

385
00:16:14,220 --> 00:16:18,360
this in practice so how would you apply

386
00:16:16,380 --> 00:16:19,980
what I've just talked about with this

387
00:16:18,360 --> 00:16:21,720
whore logic with this refinement and so

388
00:16:19,980 --> 00:16:24,959
on with proving properties to a real

389
00:16:21,720 --> 00:16:27,660
system so SEO for is is this microkernel

390
00:16:24,959 --> 00:16:29,719
we've developed it's small which means

391
00:16:27,660 --> 00:16:32,639
it's amenable to a formal verification

392
00:16:29,720 --> 00:16:35,490
it's fast which means it's useful for

393
00:16:32,639 --> 00:16:37,709
real world use it's capability-based

394
00:16:35,490 --> 00:16:39,480
which ultimately means that it has an

395
00:16:37,709 --> 00:16:41,279
explicit access control model so it's

396
00:16:39,480 --> 00:16:45,000
really good for talking about secure

397
00:16:41,279 --> 00:16:47,160
systems and it's the operating system

398
00:16:45,000 --> 00:16:49,350
kernel which means it runs in privileged

399
00:16:47,160 --> 00:16:50,819
mode which means it's one of the most

400
00:16:49,350 --> 00:16:52,980
critical parts of software so it's

401
00:16:50,819 --> 00:16:57,779
critically important to get it right and

402
00:16:52,980 --> 00:17:00,300
which is why we formally verified it so

403
00:16:57,779 --> 00:17:03,000
what did we verify what got verified

404
00:17:00,300 --> 00:17:05,188
about SEO for SEO for verification

405
00:17:03,000 --> 00:17:07,679
showed functional correctness which

406
00:17:05,189 --> 00:17:09,329
shows that the implementation refines

407
00:17:07,679 --> 00:17:11,130
the spec so that's the refinement I was

408
00:17:09,329 --> 00:17:13,559
talking about before the implementation

409
00:17:11,130 --> 00:17:17,010
of SEO for refines the specification of

410
00:17:13,559 --> 00:17:19,079
SEO for it means that the kernel does

411
00:17:17,010 --> 00:17:21,770
exactly what the specification says no

412
00:17:19,079 --> 00:17:23,668
more and no less which is nice

413
00:17:21,770 --> 00:17:25,230
hopefully the specification says

414
00:17:23,669 --> 00:17:26,730
something useful hopefully it says

415
00:17:25,230 --> 00:17:29,400
something about building secure systems

416
00:17:26,730 --> 00:17:33,570
and so on well what does it a spec say

417
00:17:29,400 --> 00:17:36,150
it talks about the behavior of system

418
00:17:33,570 --> 00:17:38,549
calls so it defines what each system

419
00:17:36,150 --> 00:17:39,960
called us so for example if you have a

420
00:17:38,549 --> 00:17:42,480
system call that sends a message from

421
00:17:39,960 --> 00:17:44,610
one thread to another it defines how

422
00:17:42,480 --> 00:17:46,470
invoking that system call is going to

423
00:17:44,610 --> 00:17:48,120
change the state of the kernel so you

424
00:17:46,470 --> 00:17:49,630
have an initial state you invoke a

425
00:17:48,120 --> 00:17:51,668
system call that sends a message

426
00:17:49,630 --> 00:17:55,059
what's the state after you've sent the

427
00:17:51,669 --> 00:17:57,779
message that's nice but that doesn't say

428
00:17:55,059 --> 00:18:00,549
anything about security so we don't

429
00:17:57,779 --> 00:18:02,350
explicitly talk about security in the

430
00:18:00,549 --> 00:18:06,460
specification that was proved about SCO

431
00:18:02,350 --> 00:18:08,139
for okay so what's the point if we if we

432
00:18:06,460 --> 00:18:09,850
want to have this kernel and we want to

433
00:18:08,139 --> 00:18:11,500
verify it in order to be able to say

434
00:18:09,850 --> 00:18:12,879
that it's secure but we don't say

435
00:18:11,500 --> 00:18:16,809
anything about security in the spec

436
00:18:12,880 --> 00:18:18,759
what's the point well we still get these

437
00:18:16,809 --> 00:18:20,379
proofs about lack of all this undefined

438
00:18:18,759 --> 00:18:22,240
behavior that it talked about before so

439
00:18:20,380 --> 00:18:24,759
improving the properties of the system

440
00:18:22,240 --> 00:18:27,309
calls we've also proved that there

441
00:18:24,759 --> 00:18:28,929
aren't buffer overflows there aren't

442
00:18:27,309 --> 00:18:31,509
null pointers being followed

443
00:18:28,929 --> 00:18:33,610
etc there aren't integer overflows or

444
00:18:31,509 --> 00:18:35,169
under floats etc so all this undefined

445
00:18:33,610 --> 00:18:36,939
behavior doesn't exist in the

446
00:18:35,169 --> 00:18:40,120
implementation of the kernel which makes

447
00:18:36,940 --> 00:18:42,279
it a lot harder for you to exploit the

448
00:18:40,120 --> 00:18:45,789
kernel which is good that's good for

449
00:18:42,279 --> 00:18:47,860
security but we can also prove

450
00:18:45,789 --> 00:18:50,230
properties above the specification

451
00:18:47,860 --> 00:18:53,168
itself so we can go a level higher and

452
00:18:50,230 --> 00:18:57,100
start making interesting proofs about

453
00:18:53,169 --> 00:18:58,840
the specification itself and because of

454
00:18:57,100 --> 00:19:00,519
refinement because we've shown that the

455
00:18:58,840 --> 00:19:01,959
implementation refines the specification

456
00:19:00,519 --> 00:19:04,240
if we make proofs above the

457
00:19:01,960 --> 00:19:06,700
specification we know that those proofs

458
00:19:04,240 --> 00:19:09,100
also hold for the implementation of the

459
00:19:06,700 --> 00:19:11,169
kernel so we know that if we actually

460
00:19:09,100 --> 00:19:12,908
invoke a system call and we prove that

461
00:19:11,169 --> 00:19:14,980
that has some other properties other

462
00:19:12,909 --> 00:19:19,389
than it's just correct then that will

463
00:19:14,980 --> 00:19:21,690
hold for the actually implementation so

464
00:19:19,389 --> 00:19:25,000
what are these properties that we proved

465
00:19:21,690 --> 00:19:28,240
about the specification well we wanted

466
00:19:25,000 --> 00:19:30,549
it to be secure so we wanted to show

467
00:19:28,240 --> 00:19:32,889
that given an access control policy

468
00:19:30,549 --> 00:19:35,799
which you can think of as an access

469
00:19:32,889 --> 00:19:38,350
control matrix or a specification of

470
00:19:35,799 --> 00:19:40,450
what authority subjects have two other

471
00:19:38,350 --> 00:19:43,928
subjects so who can for example modify

472
00:19:40,450 --> 00:19:46,600
who who can access who can read what

473
00:19:43,929 --> 00:19:50,169
data etc that the kernel will enforce

474
00:19:46,600 --> 00:19:52,240
that policy and this comes down to the

475
00:19:50,169 --> 00:19:53,799
classic security properties the classic

476
00:19:52,240 --> 00:19:56,200
CIA properties of confidentiality

477
00:19:53,799 --> 00:19:58,330
integrity and availability so we've

478
00:19:56,200 --> 00:20:00,220
proved confidentiality about the kernel

479
00:19:58,330 --> 00:20:02,110
spec we proved integrity about the

480
00:20:00,220 --> 00:20:02,680
kernel spec and we've partially proved

481
00:20:02,110 --> 00:20:08,949
available

482
00:20:02,680 --> 00:20:10,780
above the speck what does integrity mean

483
00:20:08,950 --> 00:20:12,790
in its context well generally the

484
00:20:10,780 --> 00:20:14,500
general definition of integrity is that

485
00:20:12,790 --> 00:20:17,110
you can't make authorized mod of

486
00:20:14,500 --> 00:20:19,960
unauthorized modifications more

487
00:20:17,110 --> 00:20:22,990
specifically and formally we have this

488
00:20:19,960 --> 00:20:25,290
nice whore triple that says given a pre

489
00:20:22,990 --> 00:20:27,580
precondition so the initial state s0

490
00:20:25,290 --> 00:20:29,860
that's what the precondition part means

491
00:20:27,580 --> 00:20:33,669
if we make one of these abstract kernel

492
00:20:29,860 --> 00:20:37,919
calls so a system call after the call

493
00:20:33,670 --> 00:20:41,370
the state afterwards which is state s

494
00:20:37,920 --> 00:20:45,400
the difference between initial state and

495
00:20:41,370 --> 00:20:47,559
final state will be authorized by the

496
00:20:45,400 --> 00:20:50,170
policy so there won't be any changes to

497
00:20:47,559 --> 00:20:52,720
the state that aren't authorized by this

498
00:20:50,170 --> 00:20:54,550
access control matrix that's the

499
00:20:52,720 --> 00:20:57,100
property that's been proved about the

500
00:20:54,550 --> 00:20:58,889
kernel specification I won't go into

501
00:20:57,100 --> 00:21:01,090
details about how that was proved

502
00:20:58,890 --> 00:21:02,950
there's a paper about that you can read

503
00:21:01,090 --> 00:21:04,120
if you're really interested the other

504
00:21:02,950 --> 00:21:06,429
property which is a little bit more

505
00:21:04,120 --> 00:21:09,550
complicated is confidentiality so

506
00:21:06,429 --> 00:21:13,630
confidentiality says that you can't read

507
00:21:09,550 --> 00:21:15,610
or learn unauthorized data and so

508
00:21:13,630 --> 00:21:17,830
there's this longer statement here that

509
00:21:15,610 --> 00:21:23,379
says if the initial states are

510
00:21:17,830 --> 00:21:26,020
equivalent then if we have initial

511
00:21:23,380 --> 00:21:28,390
states of the same Pro to different

512
00:21:26,020 --> 00:21:29,860
initial states are equivalent if we do

513
00:21:28,390 --> 00:21:32,020
the same executions on both of those

514
00:21:29,860 --> 00:21:33,879
states then the final states will also

515
00:21:32,020 --> 00:21:36,280
be equivalent with regards to the

516
00:21:33,880 --> 00:21:38,140
security policy and so the picture what

517
00:21:36,280 --> 00:21:40,480
it shows is on the Left these two

518
00:21:38,140 --> 00:21:42,429
initial states where the green parts are

519
00:21:40,480 --> 00:21:44,590
equivalent these are the non

520
00:21:42,429 --> 00:21:45,970
confidential parts and then the red and

521
00:21:44,590 --> 00:21:48,159
the yellow parts or the confidential

522
00:21:45,970 --> 00:21:51,880
parts and those are different if we then

523
00:21:48,160 --> 00:21:54,870
execute the same instructions for for

524
00:21:51,880 --> 00:21:57,250
for this subject let's say it's a it's a

525
00:21:54,870 --> 00:21:58,928
process if you actually look the same

526
00:21:57,250 --> 00:22:01,690
instruction schooler's process then the

527
00:21:58,929 --> 00:22:03,760
final state that they end up in will be

528
00:22:01,690 --> 00:22:05,530
the same even though the confidential

529
00:22:03,760 --> 00:22:07,360
states might be different so what that

530
00:22:05,530 --> 00:22:10,149
means is the confidential data doesn't

531
00:22:07,360 --> 00:22:12,159
leak into the non confidential parts of

532
00:22:10,150 --> 00:22:16,580
the system so we proved that about the

533
00:22:12,160 --> 00:22:18,440
kernel as well which is great

534
00:22:16,580 --> 00:22:20,990
this gives you a bit of an idea of how

535
00:22:18,440 --> 00:22:22,850
using formal method can method or form

536
00:22:20,990 --> 00:22:24,340
of verifications can lead to better very

537
00:22:22,850 --> 00:22:26,600
better security we can reduce

538
00:22:24,340 --> 00:22:29,379
implementation vulnerabilities but we

539
00:22:26,600 --> 00:22:32,299
can also have interesting abstract

540
00:22:29,380 --> 00:22:33,830
higher level property security

541
00:22:32,299 --> 00:22:35,480
properties that we can use to build our

542
00:22:33,830 --> 00:22:37,158
systems on top so I'm going to talk

543
00:22:35,480 --> 00:22:39,590
about why this is not a silver bullet

544
00:22:37,159 --> 00:22:42,679
why does it not mean that we have hack

545
00:22:39,590 --> 00:22:45,199
proof systems if we want to build a

546
00:22:42,679 --> 00:22:46,549
verified secure system we need to start

547
00:22:45,200 --> 00:22:48,110
with an overall threat model for the

548
00:22:46,549 --> 00:22:49,879
system which leads to security

549
00:22:48,110 --> 00:22:51,889
requirements it relates to properties

550
00:22:49,880 --> 00:22:55,880
that we have to have on the system and

551
00:22:51,889 --> 00:22:57,949
then we start at a high level

552
00:22:55,880 --> 00:23:00,139
architecture or a design and so we need

553
00:22:57,950 --> 00:23:01,639
to design an architecture system such

554
00:23:00,139 --> 00:23:03,199
that these properties hold these high

555
00:23:01,639 --> 00:23:05,928
level properties home so in this example

556
00:23:03,200 --> 00:23:08,330
it might be that information only flows

557
00:23:05,929 --> 00:23:09,769
from domain a to B and it always goes

558
00:23:08,330 --> 00:23:11,210
through some sort of trusted component

559
00:23:09,769 --> 00:23:16,639
that may be filters it or something like

560
00:23:11,210 --> 00:23:18,409
that so we want to prove that this

561
00:23:16,639 --> 00:23:20,870
architecture fulfills that property so

562
00:23:18,409 --> 00:23:23,210
we can do that we can do a high level

563
00:23:20,870 --> 00:23:24,439
architecture proof about that but then

564
00:23:23,210 --> 00:23:26,149
at some point we need to implement that

565
00:23:24,440 --> 00:23:27,500
so that architecture gets translated

566
00:23:26,149 --> 00:23:28,939
into a bunch of code that could be

567
00:23:27,500 --> 00:23:30,260
manually written code that could be

568
00:23:28,940 --> 00:23:32,600
existing tools that could be generated

569
00:23:30,260 --> 00:23:36,379
code and so on and then we need to show

570
00:23:32,600 --> 00:23:37,850
that this code also fulfills some

571
00:23:36,380 --> 00:23:38,960
properties and the properties might be

572
00:23:37,850 --> 00:23:43,639
that it's a refinement of the

573
00:23:38,960 --> 00:23:44,899
architecture so any data flows that are

574
00:23:43,639 --> 00:23:46,279
allowed in the architecture are also

575
00:23:44,899 --> 00:23:48,439
allowed in the code but the code doesn't

576
00:23:46,279 --> 00:23:51,169
allow other data flows so we can prove

577
00:23:48,440 --> 00:23:52,789
that as well which is nice we need to

578
00:23:51,169 --> 00:23:54,320
run that on something so we need to run

579
00:23:52,789 --> 00:23:57,110
it on an operating system and a bunch of

580
00:23:54,320 --> 00:23:58,610
services it relies on that operating

581
00:23:57,110 --> 00:24:01,219
system and services so we need to prove

582
00:23:58,610 --> 00:24:03,260
that as well well now we've got a bunch

583
00:24:01,220 --> 00:24:04,700
of code we need to actually load it into

584
00:24:03,260 --> 00:24:06,620
a running system so we'd also got a

585
00:24:04,700 --> 00:24:08,090
bootloader ideally we would need to

586
00:24:06,620 --> 00:24:11,059
verify that to make sure it does the

587
00:24:08,090 --> 00:24:14,360
right thing and that ultimately needs to

588
00:24:11,059 --> 00:24:17,928
run on hardware so we should also verify

589
00:24:14,360 --> 00:24:21,110
the hardware what I'm getting at here is

590
00:24:17,929 --> 00:24:25,520
that building a secure system requires

591
00:24:21,110 --> 00:24:26,689
different layers of abstraction and each

592
00:24:25,520 --> 00:24:28,970
of those layers have different

593
00:24:26,690 --> 00:24:30,350
properties and each of those layers need

594
00:24:28,970 --> 00:24:32,750
to be shown to be correct

595
00:24:30,350 --> 00:24:34,908
to fulfill those properties as well now

596
00:24:32,750 --> 00:24:37,669
we've got this idea of necessary versus

597
00:24:34,909 --> 00:24:39,980
sufficient it's not sufficient to just

598
00:24:37,669 --> 00:24:42,049
implement verify some of those layers

599
00:24:39,980 --> 00:24:44,029
and expect that you will have a verified

600
00:24:42,049 --> 00:24:45,620
secure system so if you just verify the

601
00:24:44,029 --> 00:24:47,179
top layer the architecture you can have

602
00:24:45,620 --> 00:24:49,610
a nice architecture but you can have

603
00:24:47,179 --> 00:24:50,990
implementation but bugs in the

604
00:24:49,610 --> 00:24:52,610
architecture you can have problems in

605
00:24:50,990 --> 00:24:54,350
the operating system in the loader in

606
00:24:52,610 --> 00:24:55,939
the hardware that allow you to bypass

607
00:24:54,350 --> 00:24:57,529
that and so you don't have a fully

608
00:24:55,940 --> 00:24:59,539
verified system so if you want a fully

609
00:24:57,529 --> 00:25:03,679
verified secure system you need to

610
00:24:59,539 --> 00:25:05,690
verify all of those layers and if you

611
00:25:03,679 --> 00:25:06,340
don't feel Nura bilities can sneak in

612
00:25:05,690 --> 00:25:09,590
there

613
00:25:06,340 --> 00:25:11,899
the other thing is that with formal

614
00:25:09,590 --> 00:25:14,120
verification we're working on models and

615
00:25:11,899 --> 00:25:15,709
models aren't necessarily the same as

616
00:25:14,120 --> 00:25:17,689
reality there's always some gap between

617
00:25:15,710 --> 00:25:19,309
the model and the reality you can try to

618
00:25:17,690 --> 00:25:22,250
make that gap as small as possible but

619
00:25:19,309 --> 00:25:25,610
there will be a gap and this manifests

620
00:25:22,250 --> 00:25:28,429
itself as assumptions so we have

621
00:25:25,610 --> 00:25:30,469
assumptions about the real world that

622
00:25:28,429 --> 00:25:32,330
are proofs our models and our proofs

623
00:25:30,470 --> 00:25:34,220
rely on so some examples of these

624
00:25:32,330 --> 00:25:37,370
assumptions practical assumptions are

625
00:25:34,220 --> 00:25:39,379
well we may assume that boot is correct

626
00:25:37,370 --> 00:25:41,928
so the hardware and the software

627
00:25:39,379 --> 00:25:43,939
environment are initialized correctly so

628
00:25:41,929 --> 00:25:46,129
that when our verified code run or our

629
00:25:43,940 --> 00:25:48,559
model runs that it has a particular

630
00:25:46,129 --> 00:25:50,330
environment we might make assumptions

631
00:25:48,559 --> 00:25:51,830
about how the hardware behaves we have

632
00:25:50,330 --> 00:25:53,750
to have a specification of the hardware

633
00:25:51,830 --> 00:25:55,100
we make assumptions that the hardware is

634
00:25:53,750 --> 00:25:57,379
implemented correctly so that it

635
00:25:55,100 --> 00:25:59,840
actually matches the specification we

636
00:25:57,379 --> 00:26:01,490
can make assumptions about semantics

637
00:25:59,840 --> 00:26:04,189
about our programming languages so if we

638
00:26:01,490 --> 00:26:05,929
take code in C and we transform it into

639
00:26:04,190 --> 00:26:07,669
a formal model we make some assumptions

640
00:26:05,929 --> 00:26:09,409
about the semantics of the programming

641
00:26:07,669 --> 00:26:12,259
languages so we need to assume that

642
00:26:09,409 --> 00:26:13,730
those are true we may have unverified

643
00:26:12,259 --> 00:26:15,409
code in our system so we may be using

644
00:26:13,730 --> 00:26:16,730
third-party libraries and stuff like

645
00:26:15,409 --> 00:26:19,429
that so we need to make assumptions

646
00:26:16,730 --> 00:26:21,409
about that code as well so there's lots

647
00:26:19,429 --> 00:26:24,100
of assumptions that might need to be

648
00:26:21,409 --> 00:26:27,769
made and if you want your verification

649
00:26:24,100 --> 00:26:29,928
to be believable to be good then you

650
00:26:27,769 --> 00:26:31,580
need to validate those assumptions and

651
00:26:29,929 --> 00:26:33,379
those assumptions as I showed in the

652
00:26:31,580 --> 00:26:35,509
previous case can be validated by doing

653
00:26:33,379 --> 00:26:37,370
formal verification as well or you can

654
00:26:35,509 --> 00:26:39,379
do your your testing and your hardening

655
00:26:37,370 --> 00:26:41,989
and so on on those things and so on and

656
00:26:39,379 --> 00:26:42,790
if you don't do that then this is where

657
00:26:41,990 --> 00:26:45,930
vulnerabilities can

658
00:26:42,790 --> 00:26:48,550
Nikken as well there's the the

659
00:26:45,930 --> 00:26:50,200
assumptions are fundamental right

660
00:26:48,550 --> 00:26:53,649
because of this gap between the model

661
00:26:50,200 --> 00:26:55,300
and reality but there are also other

662
00:26:53,650 --> 00:26:59,110
potential limitations that are more

663
00:26:55,300 --> 00:27:02,530
practical that can be dealt with but you

664
00:26:59,110 --> 00:27:04,990
need to put effort in into dealing with

665
00:27:02,530 --> 00:27:06,370
them so one as I've talked about is the

666
00:27:04,990 --> 00:27:07,630
specification should say something

667
00:27:06,370 --> 00:27:09,010
useful so you need to validate the

668
00:27:07,630 --> 00:27:10,390
specification you need to make sure that

669
00:27:09,010 --> 00:27:12,520
it says something useful for example

670
00:27:10,390 --> 00:27:15,670
like we did by verifying properties

671
00:27:12,520 --> 00:27:18,129
about SEO for specification the verified

672
00:27:15,670 --> 00:27:20,530
code needs to actually be used correctly

673
00:27:18,130 --> 00:27:22,060
so for example it needs to be configured

674
00:27:20,530 --> 00:27:24,610
correctly if you miss configure the code

675
00:27:22,060 --> 00:27:26,350
that might invalidate some assumptions

676
00:27:24,610 --> 00:27:29,979
that you make and therefore the proof

677
00:27:26,350 --> 00:27:32,679
might not hold if again this idea of

678
00:27:29,980 --> 00:27:35,170
necessary versus sufficient also holds

679
00:27:32,680 --> 00:27:38,530
if you use verified code but it relies

680
00:27:35,170 --> 00:27:40,230
on a bunch of unverified code then a lot

681
00:27:38,530 --> 00:27:42,790
of your assumptions might also break

682
00:27:40,230 --> 00:27:44,980
finally scalability is a big issue

683
00:27:42,790 --> 00:27:47,920
verification is hard one of the proof

684
00:27:44,980 --> 00:27:49,570
engineers in our group said that you

685
00:27:47,920 --> 00:27:52,210
know it punishes you for every mistake

686
00:27:49,570 --> 00:27:54,550
in a terrible unforgiving way so a lot

687
00:27:52,210 --> 00:27:56,290
of people don't become proof engineers

688
00:27:54,550 --> 00:27:59,050
because it's hard but it also takes a

689
00:27:56,290 --> 00:28:01,750
long time to do proofs and so you're

690
00:27:59,050 --> 00:28:02,850
limited in what you can verify and that

691
00:28:01,750 --> 00:28:05,500
means that you need to make decisions

692
00:28:02,850 --> 00:28:07,750
but important design decisions

693
00:28:05,500 --> 00:28:10,780
such that the parts of the system that

694
00:28:07,750 --> 00:28:13,270
you do verify support being able to use

695
00:28:10,780 --> 00:28:15,490
unverified code on top of that so for

696
00:28:13,270 --> 00:28:17,230
example in SEO for we have

697
00:28:15,490 --> 00:28:19,480
confidentiality integrity proofs which

698
00:28:17,230 --> 00:28:21,340
means that we can run unverified code on

699
00:28:19,480 --> 00:28:22,630
top of SEO for and still have guarantees

700
00:28:21,340 --> 00:28:24,610
that there's confidentially and

701
00:28:22,630 --> 00:28:26,020
integrity between them we don't

702
00:28:24,610 --> 00:28:28,209
necessarily need to verify that code

703
00:28:26,020 --> 00:28:29,590
running on top so we can use that to

704
00:28:28,210 --> 00:28:31,180
build secure systems on top of that

705
00:28:29,590 --> 00:28:34,209
without having to verify all the code

706
00:28:31,180 --> 00:28:35,320
but all of these things the fact that

707
00:28:34,210 --> 00:28:36,820
you don't necessarily verify all the

708
00:28:35,320 --> 00:28:38,470
code that you may miss configure and so

709
00:28:36,820 --> 00:28:41,679
on also can lead to vulnerability

710
00:28:38,470 --> 00:28:43,720
sneaking in so this comes back to the

711
00:28:41,680 --> 00:28:46,240
question does formal verification really

712
00:28:43,720 --> 00:28:48,250
lead to better security and the answer

713
00:28:46,240 --> 00:28:49,810
is yes it does

714
00:28:48,250 --> 00:28:53,400
in particular it can lead to better

715
00:28:49,810 --> 00:28:55,600
security because it makes you define

716
00:28:53,400 --> 00:28:56,650
specifications it makes you define

717
00:28:55,600 --> 00:28:59,530
security proper

718
00:28:56,650 --> 00:29:01,330
and you can have secure specs which is

719
00:28:59,530 --> 00:29:04,149
an important basis for building secure

720
00:29:01,330 --> 00:29:06,790
systems it also forces you if you prove

721
00:29:04,150 --> 00:29:08,710
a system to deal with all of the

722
00:29:06,790 --> 00:29:10,480
implementation bugs implementation

723
00:29:08,710 --> 00:29:12,910
vulnerabilities in the system so both of

724
00:29:10,480 --> 00:29:15,100
those lead to much better code much

725
00:29:12,910 --> 00:29:16,810
better security options of course it's

726
00:29:15,100 --> 00:29:18,909
not a silver bullet it does not

727
00:29:16,810 --> 00:29:21,399
guarantee hacker-proof code because

728
00:29:18,910 --> 00:29:23,680
we've got assumptions we've got the

729
00:29:21,400 --> 00:29:25,480
models the coverage of verification

730
00:29:23,680 --> 00:29:28,660
might not be complete people might

731
00:29:25,480 --> 00:29:30,220
misuse the verifications and so on so

732
00:29:28,660 --> 00:29:32,440
that's the end of my talk if you want to

733
00:29:30,220 --> 00:29:34,090
have more information about SEO for or

734
00:29:32,440 --> 00:29:36,490
what we do at trustworthy systems those

735
00:29:34,090 --> 00:29:38,110
are the URLs otherwise if you've become

736
00:29:36,490 --> 00:29:39,580
interested in formal verification and

737
00:29:38,110 --> 00:29:40,300
you want to explore this and see what it

738
00:29:39,580 --> 00:29:42,760
can do for you

739
00:29:40,300 --> 00:29:44,860
there's a nice blog post on proof craft

740
00:29:42,760 --> 00:29:46,510
orga about starting into verification

741
00:29:44,860 --> 00:29:49,530
how to become a proof engineer what you

742
00:29:46,510 --> 00:29:55,660
should do all right thank you

743
00:29:49,530 --> 00:29:55,660
[Applause]

