1
00:00:00,000 --> 00:00:10,230
this one's got a huge buyer so next week

2
00:00:07,109 --> 00:00:12,240
I think most people know is dr. Sylvia

3
00:00:10,230 --> 00:00:14,670
Cesare the managing director of info

4
00:00:12,240 --> 00:00:17,250
sect he's worked in technical roles and

5
00:00:14,670 --> 00:00:19,460
been involved in computer security for

6
00:00:17,250 --> 00:00:21,750
over 20 years

7
00:00:19,460 --> 00:00:23,609
including working in Silicon Valley in

8
00:00:21,750 --> 00:00:26,039
the US and working in France and of

9
00:00:23,609 --> 00:00:28,650
course Australia he's worked in

10
00:00:26,039 --> 00:00:30,119
defensive and offensive roles reported

11
00:00:28,650 --> 00:00:31,650
hundreds of software bugs and

12
00:00:30,119 --> 00:00:35,430
vulnerabilities in operating system

13
00:00:31,650 --> 00:00:38,370
kernels he used to work at UNSW Canberra

14
00:00:35,430 --> 00:00:41,100
sniper he's worked as the scanner

15
00:00:38,370 --> 00:00:43,169
architecture as a developer at koalas he

16
00:00:41,100 --> 00:00:45,050
is the co-founder of Bayside's camera

17
00:00:43,170 --> 00:00:48,539
and Seaside's

18
00:00:45,050 --> 00:00:52,399
he has a PhD from Deakin University a

19
00:00:48,539 --> 00:00:55,320
full-time black hat speaker done

20
00:00:52,399 --> 00:01:07,110
academic research commercialization and

21
00:00:55,320 --> 00:01:12,950
authored a book so we are will be

22
00:01:07,110 --> 00:01:12,950
speaking next about heap allocators

23
00:01:13,870 --> 00:01:26,159
[Music]

24
00:01:15,200 --> 00:01:28,009
ensure you're not on mute okay well

25
00:01:26,159 --> 00:01:30,479
thank you very much thank you for

26
00:01:28,009 --> 00:01:32,250
attending virtually the first see slides

27
00:01:30,479 --> 00:01:34,619
and I hope that you enjoyed our dance

28
00:01:32,250 --> 00:01:37,950
talk and I do enjoy my talk as well and

29
00:01:34,619 --> 00:01:42,658
I'm talking about the tax begins secure

30
00:01:37,950 --> 00:01:44,700
heap elevators so memory corruption

31
00:01:42,659 --> 00:01:46,619
I mean it's mean the detective memory

32
00:01:44,700 --> 00:01:49,200
corruption every year for the past 15

33
00:01:46,619 --> 00:01:52,860
years it's still a very common bug in

34
00:01:49,200 --> 00:01:54,840
systems software exploit mitigations

35
00:01:52,860 --> 00:01:57,030
certainly in the past you know 15 or 20

36
00:01:54,840 --> 00:01:59,100
years have made exploitation less common

37
00:01:57,030 --> 00:02:01,740
than they used to be when everything was

38
00:01:59,100 --> 00:02:03,689
pretty much exploitable and you know

39
00:02:01,740 --> 00:02:05,189
what I said over the pomace 15 years you

40
00:02:03,689 --> 00:02:08,519
know mitigations have increasingly

41
00:02:05,189 --> 00:02:11,970
raised the bar to actually deliver a

42
00:02:08,520 --> 00:02:13,630
working exploit people afraid is those

43
00:02:11,970 --> 00:02:16,150
things that are responsible for don't

44
00:02:13,630 --> 00:02:18,400
memory management have likewise also

45
00:02:16,150 --> 00:02:20,590
become more harm and more secure so

46
00:02:18,400 --> 00:02:22,000
we've certainly seen a lot of mediators

47
00:02:20,590 --> 00:02:28,660
in the past 15 years but they're very

48
00:02:22,000 --> 00:02:30,490
early safe unlinking in pto up to where

49
00:02:28,660 --> 00:02:33,940
we are today with many hardening

50
00:02:30,490 --> 00:02:36,520
techniques so this talk will look at

51
00:02:33,940 --> 00:02:39,460
some of the he pardoning techniques into

52
00:02:36,520 --> 00:02:42,550
ql lieutenants and looking at acts

53
00:02:39,460 --> 00:02:44,680
against them and how to bypass them so

54
00:02:42,550 --> 00:02:46,900
i'm going to talk about five things

55
00:02:44,680 --> 00:02:48,130
actually sent four things in my abstract

56
00:02:46,900 --> 00:02:49,570
but i'm gonna actually talk about flat

57
00:02:48,130 --> 00:02:52,810
because when I talk about pointy guard

58
00:02:49,570 --> 00:02:55,269
in jelly bean which is the Linux default

59
00:02:52,810 --> 00:02:57,760
standard c library implementation booty

60
00:02:55,270 --> 00:03:00,700
loop see regularly a heap allocated but

61
00:02:57,760 --> 00:03:03,519
it's very much related to protecting

62
00:03:00,700 --> 00:03:05,350
pointers and memory on the heap so not

63
00:03:03,520 --> 00:03:06,760
always on the heap but protecting memory

64
00:03:05,350 --> 00:03:07,989
and pointers and there's variable later

65
00:03:06,760 --> 00:03:10,239
to the other attacks and I'll talk about

66
00:03:07,990 --> 00:03:12,430
I'll talk about the Linux kernels

67
00:03:10,240 --> 00:03:14,350
default pig allocated which is known as

68
00:03:12,430 --> 00:03:16,720
the school of allocator that's the

69
00:03:14,350 --> 00:03:20,049
default Linux kernel elevator I'll talk

70
00:03:16,720 --> 00:03:22,840
about hardened allocator call I say a

71
00:03:20,050 --> 00:03:24,040
lot I'll go back to the slob allocator

72
00:03:22,840 --> 00:03:25,780
cause we've got another attack that I

73
00:03:24,040 --> 00:03:27,970
want to talk about and then finally I'll

74
00:03:25,780 --> 00:03:30,700
end up talking about the pseudo elevator

75
00:03:27,970 --> 00:03:34,240
which is the allocator used the Android

76
00:03:30,700 --> 00:03:35,890
evil and so quite a few alligators and

77
00:03:34,240 --> 00:03:38,950
I'll talk about individual attacks

78
00:03:35,890 --> 00:03:40,739
against each one of these elevators so

79
00:03:38,950 --> 00:03:44,350
we'll start off with plenty guard

80
00:03:40,740 --> 00:03:45,670
include we've seen now 20 guard is

81
00:03:44,350 --> 00:03:47,590
actually a mitigation

82
00:03:45,670 --> 00:03:49,119
it's the mitigation technically in G

83
00:03:47,590 --> 00:03:51,760
we've seen that they call pointy guard

84
00:03:49,120 --> 00:03:54,220
that protects against pointer corruption

85
00:03:51,760 --> 00:03:56,079
so if you have a winner and there's

86
00:03:54,220 --> 00:03:57,580
memory corruption and memory craft

87
00:03:56,080 --> 00:03:59,290
remote attacker over writes that pointer

88
00:03:57,580 --> 00:04:01,330
with something that they're choosing

89
00:03:59,290 --> 00:04:04,000
pointing out is meant to protect against

90
00:04:01,330 --> 00:04:05,950
them so you can't arbitrarily corrupt

91
00:04:04,000 --> 00:04:07,030
pointers and make them do other things

92
00:04:05,950 --> 00:04:09,310
there are other techniques one other

93
00:04:07,030 --> 00:04:10,750
after it's just iOS as one or a thin

94
00:04:09,310 --> 00:04:13,810
occasion and things like that that might

95
00:04:10,750 --> 00:04:17,589
be another Smoove method to do this type

96
00:04:13,810 --> 00:04:19,600
of pointer protection but quanti god

97
00:04:17,589 --> 00:04:23,710
effectively works by scrambling the

98
00:04:19,600 --> 00:04:25,540
pointer before it's sorting memory ok

99
00:04:23,710 --> 00:04:27,310
and then when the pointer is used at

100
00:04:25,540 --> 00:04:29,200
these scrambles up

101
00:04:27,310 --> 00:04:31,840
and it uses an internal secret that it

102
00:04:29,200 --> 00:04:34,270
travels up with so you're not meant to

103
00:04:31,840 --> 00:04:35,919
easily be able to get this secret from

104
00:04:34,270 --> 00:04:37,510
an interest point of view it's actually

105
00:04:35,919 --> 00:04:39,370
part of thread-local storage they can't

106
00:04:37,510 --> 00:04:41,580
really easily access that this secret

107
00:04:39,370 --> 00:04:44,550
that is using this scrambling operation

108
00:04:41,580 --> 00:04:46,900
now pointing out mostly focuses on

109
00:04:44,550 --> 00:04:48,880
function pointers that's typically what

110
00:04:46,900 --> 00:04:51,400
it protects it doesn't protect all the

111
00:04:48,880 --> 00:04:54,370
pointers in GMC it pretty much does

112
00:04:51,400 --> 00:04:56,010
protects most of the function points not

113
00:04:54,370 --> 00:04:58,450
all the function orders you still found

114
00:04:56,010 --> 00:05:00,550
plaintext function pointers in a process

115
00:04:58,450 --> 00:05:03,370
image like melons but we're going to

116
00:05:00,550 --> 00:05:05,020
talk about that and the idea of

117
00:05:03,370 --> 00:05:06,790
protecting function pointers with

118
00:05:05,020 --> 00:05:08,889
pointed out is that it mitigates the

119
00:05:06,790 --> 00:05:10,540
troll flow hijacking attacks so if an

120
00:05:08,889 --> 00:05:12,520
attacker overwrites a function pointer

121
00:05:10,540 --> 00:05:14,500
points points to the beginning of their

122
00:05:12,520 --> 00:05:16,450
rock chain will this stack if it all

123
00:05:14,500 --> 00:05:19,060
points to some sort of thing execute

124
00:05:16,450 --> 00:05:20,620
code well when he got protects against

125
00:05:19,060 --> 00:05:23,320
that it protects against an arbitrary

126
00:05:20,620 --> 00:05:25,479
write to memory and then check out would

127
00:05:23,320 --> 00:05:29,050
be able to use to override a function

128
00:05:25,479 --> 00:05:31,570
pointer with their arm treatment now if

129
00:05:29,050 --> 00:05:33,039
you looking at the G Lib C source since

130
00:05:31,570 --> 00:05:35,650
you'll see a bunch of references to

131
00:05:33,039 --> 00:05:39,060
point a mangle and point a D mangle it's

132
00:05:35,650 --> 00:05:41,440
sort of pseudo code that I've shown but

133
00:05:39,060 --> 00:05:44,979
this is sort of one of course my pointer

134
00:05:41,440 --> 00:05:46,630
mangle and pointed emailing and the way

135
00:05:44,979 --> 00:05:49,090
that plenty guard works is the

136
00:05:46,630 --> 00:05:51,460
scrambling operation works by X or in

137
00:05:49,090 --> 00:05:53,590
the pointer was the secret that secret

138
00:05:51,460 --> 00:05:56,080
is sorting tread local storage and that

139
00:05:53,590 --> 00:05:58,750
performs a bitwise left rotation and tax

140
00:05:56,080 --> 00:06:00,940
11 bits so that's that's the scrambling

141
00:05:58,750 --> 00:06:03,789
operation so explore the secret and then

142
00:06:00,940 --> 00:06:08,550
rotate it and D mangling is the reverse

143
00:06:03,789 --> 00:06:11,710
of that now the sort of the crux of this

144
00:06:08,550 --> 00:06:14,350
this mitigation is if the attacker knows

145
00:06:11,710 --> 00:06:16,210
the secret that the scrambling operation

146
00:06:14,350 --> 00:06:17,710
works with then the attacker wins they

147
00:06:16,210 --> 00:06:21,099
can mangle and that's okay can mangle

148
00:06:17,710 --> 00:06:23,320
and D mangle arbitrary pointers whenever

149
00:06:21,100 --> 00:06:24,550
they want providing they have lavatory

150
00:06:23,320 --> 00:06:26,080
right actually been a very memory

151
00:06:24,550 --> 00:06:29,110
corruption but we're attacking this

152
00:06:26,080 --> 00:06:33,340
mitigation point again so the idea is to

153
00:06:29,110 --> 00:06:36,760
get the secret now if you just wrap

154
00:06:33,340 --> 00:06:38,859
again through G loop C you can start to

155
00:06:36,760 --> 00:06:40,599
see where quantum angling is used and

156
00:06:38,860 --> 00:06:40,930
there's one particularly interesting

157
00:06:40,599 --> 00:06:43,050
case

158
00:06:40,930 --> 00:06:45,130
in the pthreads initialization code

159
00:06:43,050 --> 00:06:47,530
which I'll show you in this slide

160
00:06:45,130 --> 00:06:51,550
hopefully you can read that and it

161
00:06:47,530 --> 00:06:53,080
basically says that in p3 loop CP thread

162
00:06:51,550 --> 00:06:54,820
in it which is some peace friends

163
00:06:53,080 --> 00:06:57,940
initialization code there's pointer

164
00:06:54,820 --> 00:07:00,159
mangling happening with a function

165
00:06:57,940 --> 00:07:02,139
pointer table I think there's a function

166
00:07:00,160 --> 00:07:04,000
pointer table that's passed to this

167
00:07:02,139 --> 00:07:06,009
initialization routine and then there's

168
00:07:04,000 --> 00:07:08,680
one in mangling occurring in each of

169
00:07:06,009 --> 00:07:11,860
those function pointers now the thing

170
00:07:08,680 --> 00:07:16,300
that and you can defeat 20 God with is

171
00:07:11,860 --> 00:07:17,949
well if you know what pointer is being

172
00:07:16,300 --> 00:07:19,660
manually atlas of the point of that's

173
00:07:17,949 --> 00:07:22,930
been mangled you can recover the secret

174
00:07:19,660 --> 00:07:25,600
and in fact in part of this pthreads

175
00:07:22,930 --> 00:07:28,270
function pointer table we definitely

176
00:07:25,600 --> 00:07:30,520
know which function is being manual

177
00:07:28,270 --> 00:07:32,380
which which which function plan is being

178
00:07:30,520 --> 00:07:34,359
manly and if we have a loosely based

179
00:07:32,380 --> 00:07:37,060
leak then we know where that is in

180
00:07:34,360 --> 00:07:38,590
memory so we can reveal the secret so

181
00:07:37,060 --> 00:07:40,810
that's what we need we need an infant

182
00:07:38,590 --> 00:07:42,940
link to get the loop C base and then we

183
00:07:40,810 --> 00:07:44,470
simply say well we'll just take the

184
00:07:42,940 --> 00:07:46,570
address of this piece and absolute

185
00:07:44,470 --> 00:07:49,120
destroyed function and we can recover

186
00:07:46,570 --> 00:07:50,889
the secret from point agon so that

187
00:07:49,120 --> 00:07:52,720
reveals the secret because we have a

188
00:07:50,889 --> 00:07:54,520
fixed we only have a function pointer

189
00:07:52,720 --> 00:07:55,930
that we know about and we know the

190
00:07:54,520 --> 00:07:58,448
action will address it that's not random

191
00:07:55,930 --> 00:08:02,050
it's a well known addresses it's almost

192
00:07:58,449 --> 00:08:03,669
like 20 texts yeah if we can make this

193
00:08:02,050 --> 00:08:06,729
attack a bit more interesting in fact

194
00:08:03,669 --> 00:08:10,448
let's wonder let's let's have a question

195
00:08:06,729 --> 00:08:13,990
now are there any cases in G Lipsy where

196
00:08:10,449 --> 00:08:17,650
it tries to mangle a non pointer or

197
00:08:13,990 --> 00:08:20,320
another constant like negative 1 okay so

198
00:08:17,650 --> 00:08:23,380
is there a fixed constant that's getting

199
00:08:20,320 --> 00:08:24,490
mangled by pointing on and it turns out

200
00:08:23,380 --> 00:08:27,250
as part of that piece right

201
00:08:24,490 --> 00:08:29,800
initialization code the first item all

202
00:08:27,250 --> 00:08:31,870
the second item in this array there's a

203
00:08:29,800 --> 00:08:34,240
null pointer and that gets mangled

204
00:08:31,870 --> 00:08:36,159
so this is some known plaintext this is

205
00:08:34,240 --> 00:08:40,120
a constant that has been mangled and

206
00:08:36,159 --> 00:08:42,218
from that we can simply rotate our sort

207
00:08:40,120 --> 00:08:44,350
of mangled pointer and recover this

208
00:08:42,219 --> 00:08:46,510
secret and we can we can defeat when I

209
00:08:44,350 --> 00:08:48,640
dive like that if we have the ability to

210
00:08:46,510 --> 00:08:50,770
get an arbiter read and then so we need

211
00:08:48,640 --> 00:08:51,850
it in firmly but you know that's okay

212
00:08:50,770 --> 00:08:54,760
we're talking about memory corruption

213
00:08:51,850 --> 00:08:57,130
attacks and all of these mitigations

214
00:08:54,760 --> 00:08:58,600
assume that an attacker is able to

215
00:08:57,130 --> 00:09:00,490
corrupt memory and do something

216
00:08:58,600 --> 00:09:02,860
nefarious things in memory and it's

217
00:09:00,490 --> 00:09:04,900
trying to mitigate big sin on what they

218
00:09:02,860 --> 00:09:06,370
can do don't this type of defeat is

219
00:09:04,900 --> 00:09:08,949
known as a sort of a known plaintext

220
00:09:06,370 --> 00:09:10,690
attack there's point in mangling of a

221
00:09:08,950 --> 00:09:12,550
non point out and we can recover the

222
00:09:10,690 --> 00:09:15,760
secret it's almost in plane tickets to

223
00:09:12,550 --> 00:09:18,490
begin with so that's point ago that's an

224
00:09:15,760 --> 00:09:20,580
attack on point agon and really you

225
00:09:18,490 --> 00:09:23,440
shouldn't be mangling these constants

226
00:09:20,580 --> 00:09:24,850
you know it sort of you know pretty easy

227
00:09:23,440 --> 00:09:28,210
these for a couple of the secret if it

228
00:09:24,850 --> 00:09:29,830
is the next thing I look at is Linux

229
00:09:28,210 --> 00:09:34,500
kernel seep a locator the default

230
00:09:29,830 --> 00:09:34,500
elevator known as the slug allocator and

231
00:09:35,220 --> 00:09:41,860
the slob elevator uses what so is free

232
00:09:39,070 --> 00:09:44,740
lists and friend lists are chunks of

233
00:09:41,860 --> 00:09:46,540
memory that are free that a part of

234
00:09:44,740 --> 00:09:47,890
weakness part of these free list so that

235
00:09:46,540 --> 00:09:49,930
they can later be recycled by the

236
00:09:47,890 --> 00:09:52,060
elevator request memories Jesus what

237
00:09:49,930 --> 00:09:53,859
free list exists so the elevator can

238
00:09:52,060 --> 00:09:56,560
recycle the free chunk of memory without

239
00:09:53,860 --> 00:09:58,300
asking system memory for something so

240
00:09:56,560 --> 00:10:00,160
there's a well known heap corruption

241
00:09:58,300 --> 00:10:02,170
technique known as free was poisoning

242
00:10:00,160 --> 00:10:04,089
and it basically says you've got this

243
00:10:02,170 --> 00:10:05,620
free list me but these linked lists and

244
00:10:04,090 --> 00:10:07,090
these pointers in this linked list if

245
00:10:05,620 --> 00:10:08,620
you drop one of these one doesn't make a

246
00:10:07,090 --> 00:10:11,560
point to an arbitrary address

247
00:10:08,620 --> 00:10:15,580
well when the allocator recycles these

248
00:10:11,560 --> 00:10:18,250
chunks it'll return to you of mela and

249
00:10:15,580 --> 00:10:20,260
allocated no offer with the arbitrary

250
00:10:18,250 --> 00:10:23,770
address that a poison or corrupted the

251
00:10:20,260 --> 00:10:25,710
pointer in that free list length list so

252
00:10:23,770 --> 00:10:28,720
that's that's called free list was do it

253
00:10:25,710 --> 00:10:30,220
now you can actually turn this into an

254
00:10:28,720 --> 00:10:31,570
arbitrary right committed from an it

255
00:10:30,220 --> 00:10:34,690
from an attacker point of view if you

256
00:10:31,570 --> 00:10:36,730
have application logic that what's

257
00:10:34,690 --> 00:10:38,770
attacker controlled data to an allocated

258
00:10:36,730 --> 00:10:40,480
buffer and you make that allocated

259
00:10:38,770 --> 00:10:42,370
buffer point to an arbitral location

260
00:10:40,480 --> 00:10:44,110
that's basically the same as of white

261
00:10:42,370 --> 00:10:45,760
what we are in the commentary black for

262
00:10:44,110 --> 00:10:47,860
minute so it's a very powerful limited

263
00:10:45,760 --> 00:10:52,260
and many heap exploitation techniques

264
00:10:47,860 --> 00:10:54,100
work around that principle member

265
00:10:52,260 --> 00:10:56,770
historically you could actually be do

266
00:10:54,100 --> 00:10:59,760
freelee's poisoning sort of trivially in

267
00:10:56,770 --> 00:11:02,980
in the linux penalty panna cotta but

268
00:10:59,760 --> 00:11:04,840
some years ago 2017 over lose i'm not

269
00:11:02,980 --> 00:11:07,210
that many years ago they introduced a

270
00:11:04,840 --> 00:11:08,300
configuration option to make free list

271
00:11:07,210 --> 00:11:10,790
hardening

272
00:11:08,300 --> 00:11:13,969
as a mitigation and so they've got this

273
00:11:10,790 --> 00:11:16,640
cloak here and there's actually a patch

274
00:11:13,970 --> 00:11:18,529
that mitigates against one of this high

275
00:11:16,640 --> 00:11:20,120
seat naive friend is poison attack will

276
00:11:18,529 --> 00:11:22,279
simply overwrite one of these pointers

277
00:11:20,120 --> 00:11:25,850
with an arbitrary Atticus that will be

278
00:11:22,279 --> 00:11:28,520
returned by the Colonel jalapeno and the

279
00:11:25,850 --> 00:11:30,320
the key the scrambling function that

280
00:11:28,520 --> 00:11:31,640
they use they have sort of the sort of

281
00:11:30,320 --> 00:11:33,470
the same thing it's point and manually

282
00:11:31,640 --> 00:11:36,260
or deem Englund they use a scrambling

283
00:11:33,470 --> 00:11:39,649
function which takes the pointer excells

284
00:11:36,260 --> 00:11:41,480
that against a secret and then axles

285
00:11:39,649 --> 00:11:43,940
that against the address of the pointer

286
00:11:41,480 --> 00:11:46,100
and our attack we want to reveal the

287
00:11:43,940 --> 00:11:47,720
secret this is what we want to get we

288
00:11:46,100 --> 00:11:50,839
want to reveal that secret so that we

289
00:11:47,720 --> 00:11:52,970
can hopefully craft our own thang

290
00:11:50,839 --> 00:11:54,529
corrupt pointers and make the kernel

291
00:11:52,970 --> 00:11:57,170
memory allocator return an arbitrary

292
00:11:54,529 --> 00:12:00,980
address now the inside of this attack is

293
00:11:57,170 --> 00:12:03,949
that in the Linux kernel pointer and

294
00:12:00,980 --> 00:12:06,110
pointer address pretty much belong to

295
00:12:03,950 --> 00:12:08,959
the same region of memory so they're

296
00:12:06,110 --> 00:12:10,970
almost bitwise identical and because you

297
00:12:08,959 --> 00:12:13,729
have that extra identity we XOR

298
00:12:10,970 --> 00:12:16,790
something with itself equals zero you

299
00:12:13,730 --> 00:12:18,050
basically come to the situation where

300
00:12:16,790 --> 00:12:20,089
you have one an excellent

301
00:12:18,050 --> 00:12:22,760
with almost itself which comes to zero

302
00:12:20,089 --> 00:12:24,980
excellent with the secret thus revealing

303
00:12:22,760 --> 00:12:28,640
the secret so in fact this stolen

304
00:12:24,980 --> 00:12:30,410
pointer in the free list if these

305
00:12:28,640 --> 00:12:33,740
frameless pointers is actually the

306
00:12:30,410 --> 00:12:35,990
secret stone is plaintext and if we look

307
00:12:33,740 --> 00:12:38,540
at the kernel memory allocator and this

308
00:12:35,990 --> 00:12:39,980
was actually done by K school and then

309
00:12:38,540 --> 00:12:41,810
Alice's are currently the blog post on

310
00:12:39,980 --> 00:12:43,730
it only sort of waiting to patch this

311
00:12:41,810 --> 00:12:45,469
this particular problem if we look at

312
00:12:43,730 --> 00:12:48,470
the stored value that sword in that free

313
00:12:45,470 --> 00:12:50,690
list pointer it's almost identical to

314
00:12:48,470 --> 00:12:53,870
the secret value that is not meant to be

315
00:12:50,690 --> 00:12:58,910
known you know two-man attacker or all

316
00:12:53,870 --> 00:13:00,230
be plant accessing memory so hooligans

317
00:12:58,910 --> 00:13:02,029
kernel team acknowledge this as a

318
00:13:00,230 --> 00:13:05,779
weakness a main rotor pack to improve

319
00:13:02,029 --> 00:13:07,520
the security but okay she's not my blog

320
00:13:05,779 --> 00:13:10,459
post one external commit when they when

321
00:13:07,520 --> 00:13:12,800
they talk about this and now they use

322
00:13:10,459 --> 00:13:14,239
sort of the variation on that scrambling

323
00:13:12,800 --> 00:13:15,949
technique is why not application

324
00:13:14,240 --> 00:13:17,540
technique they take the point out they

325
00:13:15,950 --> 00:13:22,260
accelerate with the secret and then they

326
00:13:17,540 --> 00:13:24,870
XOR it with a Indian swap of the pointer

327
00:13:22,260 --> 00:13:27,930
so they simply added that Indiana swap

328
00:13:24,870 --> 00:13:29,490
that's 164 and this is actually much

329
00:13:27,930 --> 00:13:32,760
stronger it's actually a much stronger

330
00:13:29,490 --> 00:13:35,430
as much stronger mitigation and much

331
00:13:32,760 --> 00:13:37,200
harder to to corrupt that pointer and

332
00:13:35,430 --> 00:13:41,550
make it you know do what you wanted to

333
00:13:37,200 --> 00:13:45,390
do so that's the attack on an external

334
00:13:41,550 --> 00:13:49,859
peep the next allocated on a look at is

335
00:13:45,390 --> 00:13:52,800
called bicep outlook and I say L Bach is

336
00:13:49,860 --> 00:13:55,460
a hardened elevator with many security

337
00:13:52,800 --> 00:13:58,079
medications ugly a very good Allatoona

338
00:13:55,460 --> 00:14:00,600
now they actually use a similar strategy

339
00:13:58,080 --> 00:14:02,400
for the Linux kernel slot elevator in

340
00:14:00,600 --> 00:14:04,140
fact they take the pointer they

341
00:14:02,400 --> 00:14:06,750
accelerate again it's a secret and they

342
00:14:04,140 --> 00:14:08,760
XOR it against the pointers address and

343
00:14:06,750 --> 00:14:11,190
I'd be told and I sort of can't verify

344
00:14:08,760 --> 00:14:13,170
this that this sort of pattern actually

345
00:14:11,190 --> 00:14:16,350
came from gr security where apparently

346
00:14:13,170 --> 00:14:20,069
this bug at least exhibit this weakness

347
00:14:16,350 --> 00:14:22,200
existed certainly at least until a blog

348
00:14:20,070 --> 00:14:25,620
article about it let's look at the clue

349
00:14:22,200 --> 00:14:28,830
in I so color and we can actually see

350
00:14:25,620 --> 00:14:32,270
that there's this canary value which

351
00:14:28,830 --> 00:14:35,910
takes is be point of excellent against

352
00:14:32,270 --> 00:14:40,020
this address and then X was it against a

353
00:14:35,910 --> 00:14:45,510
secret and in fact when we print the

354
00:14:40,020 --> 00:14:49,260
value of the stored value and the secret

355
00:14:45,510 --> 00:14:51,270
all the highlights are the same so this

356
00:14:49,260 --> 00:14:53,880
is actually an identical class of bunk

357
00:14:51,270 --> 00:14:57,750
that we saw in a Linux kernel people

358
00:14:53,880 --> 00:14:59,790
look exactly the same but it's taking

359
00:14:57,750 --> 00:15:03,000
even a pointer X or neol with a plant

360
00:14:59,790 --> 00:15:07,020
address bitwise identical they become 0

361
00:15:03,000 --> 00:15:08,750
thus revealing the secret in memory so

362
00:15:07,020 --> 00:15:11,400
very interesting that we saw multiple

363
00:15:08,750 --> 00:15:14,160
elevators that have been hardened

364
00:15:11,400 --> 00:15:16,199
against one frameless poisoning at this

365
00:15:14,160 --> 00:15:19,860
same class of one or the same class of

366
00:15:16,200 --> 00:15:21,480
weakness so the IP male but water and

367
00:15:19,860 --> 00:15:23,610
why cell can eat all it took was the

368
00:15:21,480 --> 00:15:25,610
weakness and I recommended to do the

369
00:15:23,610 --> 00:15:28,020
same thing that moves from touch to

370
00:15:25,610 --> 00:15:30,990
simply use that Indian swap with that

371
00:15:28,020 --> 00:15:32,670
black water swap and I say I like

372
00:15:30,990 --> 00:15:34,750
implemented that change in less than a

373
00:15:32,670 --> 00:15:38,319
week after the initial report

374
00:15:34,750 --> 00:15:40,360
currently it's it is patched much like

375
00:15:38,320 --> 00:15:44,710
the Linux kernel patch and I talked

376
00:15:40,360 --> 00:15:47,020
about earlier so is that the end of

377
00:15:44,710 --> 00:15:49,270
attacking the Linux kernel if a locator

378
00:15:47,020 --> 00:15:51,460
and a lock is there anything we can do

379
00:15:49,270 --> 00:15:52,990
that you know that we haven't talked

380
00:15:51,460 --> 00:15:57,460
about you know there any other attacks

381
00:15:52,990 --> 00:15:59,530
you know is real is poisoning dead now

382
00:15:57,460 --> 00:16:01,150
this is sort of a theoretical attack so

383
00:15:59,530 --> 00:16:03,459
it gets a bit out there I think it's a

384
00:16:01,150 --> 00:16:05,350
bit sort of it's a it certainly more and

385
00:16:03,460 --> 00:16:09,460
more exotic attack than the earlier

386
00:16:05,350 --> 00:16:11,620
attacks now equipped ography there's a

387
00:16:09,460 --> 00:16:14,290
set of attacks known as be flippin

388
00:16:11,620 --> 00:16:17,050
attacks any Lukla attack see basically

389
00:16:14,290 --> 00:16:19,870
takes some ciphertext which you know the

390
00:16:17,050 --> 00:16:21,900
plane takes off and then you flip some

391
00:16:19,870 --> 00:16:24,520
bits in this life to text so that it

392
00:16:21,900 --> 00:16:26,260
decrypt to whatever you want and you can

393
00:16:24,520 --> 00:16:28,120
actually do that you can want to find

394
00:16:26,260 --> 00:16:31,780
the ciphertext even maybe you know the

395
00:16:28,120 --> 00:16:34,450
plaintext and when you know the victim D

396
00:16:31,780 --> 00:16:37,689
creeps the data it decrypts tilapias

397
00:16:34,450 --> 00:16:40,330
happen once that's called a flip and it

398
00:16:37,690 --> 00:16:43,150
turns out that in theory we can perform

399
00:16:40,330 --> 00:16:47,440
a similar attack on the Linux kernel

400
00:16:43,150 --> 00:16:50,500
deep allocator so there's actually some

401
00:16:47,440 --> 00:16:52,150
code in the Linux kernel it's unusual

402
00:16:50,500 --> 00:16:55,390
code and it basically says and you

403
00:16:52,150 --> 00:16:56,949
certainly need you need some recessions

404
00:16:55,390 --> 00:17:00,040
in the kernel to do this you need some

405
00:16:56,950 --> 00:17:01,450
point or restrict permissions to really

406
00:17:00,040 --> 00:17:04,209
on by default but it is there in the

407
00:17:01,450 --> 00:17:06,100
kernel there's some Linux kernel code

408
00:17:04,209 --> 00:17:08,770
that says when it tries to look at this

409
00:17:06,099 --> 00:17:10,958
friend list point up it checks to see if

410
00:17:08,770 --> 00:17:13,810
it's a valid pointer and if it isn't

411
00:17:10,959 --> 00:17:15,430
then it warns you tis an error and says

412
00:17:13,810 --> 00:17:18,609
the free pointer this friendlist point

413
00:17:15,430 --> 00:17:22,300
is corrupt and then it also prints what

414
00:17:18,609 --> 00:17:25,179
it decoded to will be mangled - okay so

415
00:17:22,300 --> 00:17:27,250
it's appointed the manual Oracle we can

416
00:17:25,180 --> 00:17:29,650
basically pass arbitrary corrupt

417
00:17:27,250 --> 00:17:31,510
pointers to our friend lists and that D

418
00:17:29,650 --> 00:17:33,760
manual operation with our pointer D on

419
00:17:31,510 --> 00:17:37,870
the station operation we can actually

420
00:17:33,760 --> 00:17:39,250
see what it comes to so this is the

421
00:17:37,870 --> 00:17:40,600
attack that we're going to do all the

422
00:17:39,250 --> 00:17:42,850
least in theory it's a sort of a

423
00:17:40,600 --> 00:17:45,209
theoretical attack with some sort of

424
00:17:42,850 --> 00:17:48,459
verification it's theoretical really

425
00:17:45,210 --> 00:17:49,840
they'll take a free list point up

426
00:17:48,460 --> 00:17:51,310
and we've got memory options we're gonna

427
00:17:49,840 --> 00:17:52,889
clear up that free list point up with

428
00:17:51,310 --> 00:17:55,690
the value of our choosing

429
00:17:52,890 --> 00:17:58,300
okay then we going to get the allocator

430
00:17:55,690 --> 00:18:01,990
2d naval using ante mangling Oracle and

431
00:17:58,300 --> 00:18:04,919
we're going to note the result given

432
00:18:01,990 --> 00:18:07,690
only that that we've got a demon world

433
00:18:04,920 --> 00:18:10,240
point up from a point of that where you

434
00:18:07,690 --> 00:18:11,860
sort of corrupted we can do a bit

435
00:18:10,240 --> 00:18:14,010
flipping attack and using that we can

436
00:18:11,860 --> 00:18:17,050
corrupt the free list planner again

437
00:18:14,010 --> 00:18:18,610
making it to the mangle to an arbitrary

438
00:18:17,050 --> 00:18:21,520
address of our choosing

439
00:18:18,610 --> 00:18:23,699
so that's a big flippin attack applied

440
00:18:21,520 --> 00:18:27,730
to the Linux kernel heap allocator and

441
00:18:23,700 --> 00:18:29,680
to do this what we're going to do is

442
00:18:27,730 --> 00:18:31,780
we're going to corrupt the free list

443
00:18:29,680 --> 00:18:33,970
pointer with the value and we're just

444
00:18:31,780 --> 00:18:37,060
going to corrupt it with the value 1 and

445
00:18:33,970 --> 00:18:38,710
we choose 1 not 0 because 0 has a very

446
00:18:37,060 --> 00:18:41,710
special meaning it's a null pointer so

447
00:18:38,710 --> 00:18:43,630
might sort of be sort of not work well

448
00:18:41,710 --> 00:18:46,150
why terminate whistles so forth but one

449
00:18:43,630 --> 00:18:47,470
is probably a safe thing ok so we're

450
00:18:46,150 --> 00:18:49,780
going to corrupt this free list pointer

451
00:18:47,470 --> 00:18:52,660
with 1 and then we're going to use that

452
00:18:49,780 --> 00:18:54,430
be mainly Oracle to tell us what it D

453
00:18:52,660 --> 00:18:58,570
mangled to now we're going to call that

454
00:18:54,430 --> 00:19:00,730
point 2 1 now I've got another chance at

455
00:18:58,570 --> 00:19:02,320
corrupting the same trailers pointer and

456
00:19:00,730 --> 00:19:05,650
we're going to take our target address

457
00:19:02,320 --> 00:19:08,370
exel that with one and XOR that with

458
00:19:05,650 --> 00:19:10,780
what adding mangling Oracle's Damus and

459
00:19:08,370 --> 00:19:11,979
this is our op the sanded pointer to

460
00:19:10,780 --> 00:19:14,379
we're going to corrupt the frameless

461
00:19:11,980 --> 00:19:17,350
under with that and guess what when the

462
00:19:14,380 --> 00:19:20,350
kernel tries to D mangle that point it

463
00:19:17,350 --> 00:19:22,240
actually gives you the target address so

464
00:19:20,350 --> 00:19:23,949
it's a big flippin attack and I've got

465
00:19:22,240 --> 00:19:26,050
them like a small proof here showing the

466
00:19:23,950 --> 00:19:27,760
the sequence of next to operations so

467
00:19:26,050 --> 00:19:29,680
that you get your target address out of

468
00:19:27,760 --> 00:19:30,730
it but basically we need to corrupt the

469
00:19:29,680 --> 00:19:32,890
free list point on what's the value

470
00:19:30,730 --> 00:19:34,960
about choosing use that the mainly

471
00:19:32,890 --> 00:19:37,180
Oracle and then re corrupt the pointer

472
00:19:34,960 --> 00:19:40,690
and we can make it to mangle to any

473
00:19:37,180 --> 00:19:43,590
target address that we want so to put

474
00:19:40,690 --> 00:19:45,760
the attack it's a theoretical attack

475
00:19:43,590 --> 00:19:48,669
certainly in sort of with test data of

476
00:19:45,760 --> 00:19:51,640
works but it's interesting that such an

477
00:19:48,670 --> 00:19:54,040
attack might be possible you know

478
00:19:51,640 --> 00:19:55,870
learning cryptography might actually be

479
00:19:54,040 --> 00:19:58,110
useful even to people to be memory

480
00:19:55,870 --> 00:19:58,110
crusher

481
00:19:58,340 --> 00:20:04,849
the final attack that I'm going to look

482
00:20:00,739 --> 00:20:07,429
at is the pseudo elevator and sciutto is

483
00:20:04,849 --> 00:20:10,369
a Highland alligator written and

484
00:20:07,429 --> 00:20:12,919
maintained by Google okay

485
00:20:10,369 --> 00:20:15,379
it's used in the Android easel and on

486
00:20:12,919 --> 00:20:17,479
mobile devices it's very easy to use to

487
00:20:15,379 --> 00:20:19,820
compiling you just use si lang and you

488
00:20:17,479 --> 00:20:23,419
pass that sanitizer word sudo and it

489
00:20:19,820 --> 00:20:28,189
uses a suite of free public beta now

490
00:20:23,419 --> 00:20:29,749
sudo does is the secure alligator tries

491
00:20:28,190 --> 00:20:31,099
to mitigate against mera question and

492
00:20:29,749 --> 00:20:32,869
one of the considered does to mitigate

493
00:20:31,099 --> 00:20:36,489
against memory corruption is that it

494
00:20:32,869 --> 00:20:39,080
puts checksums into mela chunk headers

495
00:20:36,489 --> 00:20:41,059
in an attempt to prevent an attacker

496
00:20:39,080 --> 00:20:44,658
from forging their own fate chance we

497
00:20:41,059 --> 00:20:47,710
can't pass to free a faint chunk because

498
00:20:44,659 --> 00:20:53,059
there's a checksum on the header that

499
00:20:47,710 --> 00:20:55,700
uses an internal secret and a crc32

500
00:20:53,059 --> 00:20:57,259
checksum algorithm to calculate that

501
00:20:55,700 --> 00:20:59,599
checksum so there's a secret that a

502
00:20:57,259 --> 00:21:02,330
cookie or 32-bits cookie that we don't

503
00:20:59,599 --> 00:21:04,609
know about as an attacker that prevents

504
00:21:02,330 --> 00:21:07,728
us from arbitrarily cranial on checksums

505
00:21:04,609 --> 00:21:13,249
only the allocator knows this this

506
00:21:07,729 --> 00:21:14,539
cookie and it uses a crc32 algorithm

507
00:21:13,249 --> 00:21:16,729
sort of a common checksum algorithm

508
00:21:14,539 --> 00:21:19,039
involving that secret involving the

509
00:21:16,729 --> 00:21:20,509
original chunk header you know sort of

510
00:21:19,039 --> 00:21:24,019
in a pseudo header and then it writes

511
00:21:20,509 --> 00:21:26,269
that new checks on to the chunkier so

512
00:21:24,019 --> 00:21:29,419
what we want to do ultimately we want to

513
00:21:26,269 --> 00:21:31,879
fake checksums ok we want to create fake

514
00:21:29,419 --> 00:21:35,719
checksums and we also want their secret

515
00:21:31,879 --> 00:21:38,779
cookie and what we're going to do is

516
00:21:35,719 --> 00:21:41,659
represent this secure checksum algorithm

517
00:21:38,779 --> 00:21:44,419
including that secret value as a set of

518
00:21:41,659 --> 00:21:47,299
SMT equations so a set of constraints

519
00:21:44,419 --> 00:21:50,359
and we're going to assume that we have

520
00:21:47,299 --> 00:21:53,509
an info link but we're able to read one

521
00:21:50,359 --> 00:21:55,999
chunk header of a valid chunk

522
00:21:53,509 --> 00:21:58,039
okay so we have a neat phone link we're

523
00:21:55,999 --> 00:22:00,139
able to read a chunk here we're gonna

524
00:21:58,039 --> 00:22:02,899
represent the checksum algorithm

525
00:22:00,139 --> 00:22:05,149
involving a secret cookie as a set of SN

526
00:22:02,899 --> 00:22:08,299
T equations and then when you cast a

527
00:22:05,149 --> 00:22:11,870
solver to see if it can compute a

528
00:22:08,299 --> 00:22:13,940
solution for the secret cooking

529
00:22:11,870 --> 00:22:16,459
and if it does actually do this well we

530
00:22:13,940 --> 00:22:21,400
can crash correct Chuck's checksums on

531
00:22:16,460 --> 00:22:24,380
fake errors using this secret cookie and

532
00:22:21,400 --> 00:22:27,830
this is a set of SMT equations

533
00:22:24,380 --> 00:22:29,539
represented in Python as entry and

534
00:22:27,830 --> 00:22:32,928
that's enough to represent the checksum

535
00:22:29,539 --> 00:22:34,820
algorithm it only does a crc32 checksum

536
00:22:32,929 --> 00:22:36,919
only on a few bytes for the it's not an

537
00:22:34,820 --> 00:22:38,510
arbitrary length amount of data so it's

538
00:22:36,919 --> 00:22:44,480
actually possible to represent this by

539
00:22:38,510 --> 00:22:46,760
effectively as a set of equations now we

540
00:22:44,480 --> 00:22:48,230
can ask SMT solver can we solve a

541
00:22:46,760 --> 00:22:50,419
solution to give us that cookie value

542
00:22:48,230 --> 00:22:52,159
that secret cookie value in fact we do

543
00:22:50,419 --> 00:22:54,620
get a solution in you know very quickly

544
00:22:52,159 --> 00:22:56,390
in less than a second and it's one of

545
00:22:54,620 --> 00:22:58,610
many solutions that it gives us and the

546
00:22:56,390 --> 00:23:01,220
solution that we get it's not actually

547
00:22:58,610 --> 00:23:03,668
going to be the real cookie okay there's

548
00:23:01,220 --> 00:23:06,890
many solutions that it sort of can solve

549
00:23:03,669 --> 00:23:08,390
that make that check something valid but

550
00:23:06,890 --> 00:23:10,490
it's not you know the real hook effects

551
00:23:08,390 --> 00:23:12,409
used by the system but it turns out it

552
00:23:10,490 --> 00:23:14,029
doesn't matter doesn't matter that it's

553
00:23:12,409 --> 00:23:16,700
not a real cookie because they're a

554
00:23:14,029 --> 00:23:20,179
secret cookie collisions and in fact the

555
00:23:16,700 --> 00:23:23,179
secret cookies that we determine or

556
00:23:20,179 --> 00:23:28,149
compute are good enough to build correct

557
00:23:23,179 --> 00:23:31,700
check sums for arbitrary fake chunks so

558
00:23:28,149 --> 00:23:34,370
you know what does a feint chunkiness

559
00:23:31,700 --> 00:23:36,140
you know why we trying to forward chunks

560
00:23:34,370 --> 00:23:39,139
or build fake chunks

561
00:23:36,140 --> 00:23:42,230
well in many allocators if you corrupt

562
00:23:39,140 --> 00:23:44,090
the slice more than a chunk it up you

563
00:23:42,230 --> 00:23:47,720
can free that chunk and it goes into the

564
00:23:44,090 --> 00:23:49,189
wrong size free list or bin and you can

565
00:23:47,720 --> 00:23:49,669
make the allocator believe that that

566
00:23:49,190 --> 00:23:52,070
chunk

567
00:23:49,669 --> 00:23:53,779
well that chunk header represent is much

568
00:23:52,070 --> 00:23:56,210
larger than what it is that chunk that

569
00:23:53,779 --> 00:23:58,029
it will also is much larger so a future

570
00:23:56,210 --> 00:24:00,860
allocation are quite large

571
00:23:58,029 --> 00:24:04,429
uses that even though it's much smaller

572
00:24:00,860 --> 00:24:05,658
and in fact that allocation overlaps

573
00:24:04,429 --> 00:24:07,640
because it's thinking that it's much

574
00:24:05,659 --> 00:24:10,070
bigger than it is it overlaps that

575
00:24:07,640 --> 00:24:12,740
adjacent chunk to the original chunk and

576
00:24:10,070 --> 00:24:14,960
an attacker can corrupt critical data

577
00:24:12,740 --> 00:24:17,419
structures overwrite function pointers

578
00:24:14,960 --> 00:24:20,299
or pointers themselves and do other

579
00:24:17,419 --> 00:24:23,600
things as well future work is the seat

580
00:24:20,299 --> 00:24:25,250
of such a text of possible on sciutto

581
00:24:23,600 --> 00:24:27,949
using these fake chunk

582
00:24:25,250 --> 00:24:30,950
but it's pretty good you can craft your

583
00:24:27,950 --> 00:24:35,750
own fake chunks given only one infant

584
00:24:30,950 --> 00:24:39,290
like 30 so i presented a number of

585
00:24:35,750 --> 00:24:41,600
attacks against hardened elevators the

586
00:24:39,290 --> 00:24:43,070
mitigations in these elevators all the

587
00:24:41,600 --> 00:24:45,830
steam and attack earth is able to

588
00:24:43,070 --> 00:24:47,620
corrupt memory so on one so this is the

589
00:24:45,830 --> 00:24:50,840
basis you know you can corrupt memory

590
00:24:47,620 --> 00:24:52,429
you know you've got some primitives what

591
00:24:50,840 --> 00:24:55,600
can you do with the allocator and can

592
00:24:52,430 --> 00:24:58,580
you bypass some of the mitigations and

593
00:24:55,600 --> 00:25:00,830
defenses that they implement to prevent

594
00:24:58,580 --> 00:25:02,480
or mitigate against exploitation and it

595
00:25:00,830 --> 00:25:04,820
turns out we can actually do a number of

596
00:25:02,480 --> 00:25:07,160
attacks against a number of hotend

597
00:25:04,820 --> 00:25:11,899
elevators and bypass a bunch of

598
00:25:07,160 --> 00:25:14,510
litigations so that's pretty much my

599
00:25:11,900 --> 00:25:15,860
twitter name is there i also do training

600
00:25:14,510 --> 00:25:18,830
eating face sick that's sort of my

601
00:25:15,860 --> 00:25:20,600
full-time job i do courses on code

602
00:25:18,830 --> 00:25:23,419
review and beep exploitation

603
00:25:20,600 --> 00:25:29,120
check out the website or ask me some

604
00:25:23,420 --> 00:25:30,970
questions in the slack them awesome

605
00:25:29,120 --> 00:25:40,550
that's great can you play the clapping

606
00:25:30,970 --> 00:25:44,630
Sylvie's great great so there are a few

607
00:25:40,550 --> 00:25:48,190
comments on slack sniff wanted you to

608
00:25:44,630 --> 00:25:48,190
know that we can hear you up the back

609
00:25:50,770 --> 00:25:57,970
and then we had one question was about

610
00:25:53,840 --> 00:25:57,970
when you were talking about scrambling

611
00:25:58,720 --> 00:26:09,440
is that the same as encryption yes so it

612
00:26:05,990 --> 00:26:11,170
is an attack - sort of - it is like the

613
00:26:09,440 --> 00:26:14,060
encryption it's like quickly

614
00:26:11,170 --> 00:26:15,770
cryptographically secure scrambler and i

615
00:26:14,060 --> 00:26:19,399
use the words family and city encryption

616
00:26:15,770 --> 00:26:20,750
because in these particular cases you

617
00:26:19,400 --> 00:26:23,210
know the goal is to learn these

618
00:26:20,750 --> 00:26:24,380
alligators to be very fast and they

619
00:26:23,210 --> 00:26:25,340
really just want to scramble in

620
00:26:24,380 --> 00:26:27,830
operation they're not really

621
00:26:25,340 --> 00:26:29,540
cryptographically secure operations and

622
00:26:27,830 --> 00:26:31,550
that's why I'm using the word scrambling

623
00:26:29,540 --> 00:26:35,870
instead of encryption but you know in

624
00:26:31,550 --> 00:26:37,520
one sense you know it is trying to sort

625
00:26:35,870 --> 00:26:38,610
of in encryption or a house or something

626
00:26:37,520 --> 00:26:40,710
you know it's

627
00:26:38,610 --> 00:26:43,350
trying to be you know a little element

628
00:26:40,710 --> 00:26:44,940
of you know how having a secret and not

629
00:26:43,350 --> 00:26:48,590
revealing it but they're not really

630
00:26:44,940 --> 00:26:48,590
encryption they're really more swim

631
00:26:49,820 --> 00:26:58,649
photography caitlin also observed that

632
00:26:56,670 --> 00:27:01,290
you did list your twitter handle before

633
00:26:58,650 --> 00:27:02,850
your actual full-time job so it was

634
00:27:01,290 --> 00:27:07,350
interesting to see the importance you

635
00:27:02,850 --> 00:27:10,139
placed on twitter versus your job it was

636
00:27:07,350 --> 00:27:11,610
quite funny that's great I mean you come

637
00:27:10,140 --> 00:27:13,350
come on to the seaside Channel

638
00:27:11,610 --> 00:27:14,790
afterwards I'm sure people have have

639
00:27:13,350 --> 00:27:17,189
questions

640
00:27:14,790 --> 00:27:19,290
it's always very caring that your

641
00:27:17,190 --> 00:27:22,440
research into that you into the heat

642
00:27:19,290 --> 00:27:25,530
alligator and other things so I guess

643
00:27:22,440 --> 00:27:27,540
this but that ends out our two

644
00:27:25,530 --> 00:27:31,370
presentations for tonight we did promise

645
00:27:27,540 --> 00:27:31,370
or do some great

