1
00:00:05,680 --> 00:00:08,000
okay

2
00:00:12,640 --> 00:00:15,519
[Music]

3
00:00:15,519 --> 00:00:17,920
okay um

4
00:00:17,920 --> 00:00:21,359
thanks everyone who joins uh joined uh

5
00:00:21,359 --> 00:00:24,320
my name is tal i'm a senior director for

6
00:00:24,320 --> 00:00:26,240
cloud native security research at

7
00:00:26,240 --> 00:00:28,640
contrast security and i'm going to talk

8
00:00:28,640 --> 00:00:32,320
to you about serverless security

9
00:00:32,320 --> 00:00:35,920
um just a few words about why me or who

10
00:00:35,920 --> 00:00:38,719
am i why am i doing

11
00:00:38,719 --> 00:00:39,680
so

12
00:00:39,680 --> 00:00:42,879
why me let's start with that

13
00:00:42,879 --> 00:00:46,239
i uh created or i started

14
00:00:46,239 --> 00:00:48,160
last year i started a

15
00:00:48,160 --> 00:00:49,520
company

16
00:00:49,520 --> 00:00:51,840
in israel called cloud essence we are

17
00:00:51,840 --> 00:00:54,160
doing cloud security testing

18
00:00:54,160 --> 00:00:57,280
um for serverless applications and we

19
00:00:57,280 --> 00:00:59,840
got acquired by contrast

20
00:00:59,840 --> 00:01:02,480
last year and previous to that i was

21
00:01:02,480 --> 00:01:05,119
heading the research at protego labs

22
00:01:05,119 --> 00:01:07,119
another serverless security

23
00:01:07,119 --> 00:01:08,000
um

24
00:01:08,000 --> 00:01:10,159
in protection that was acquired by

25
00:01:10,159 --> 00:01:13,280
checkpoint a year before in general you

26
00:01:13,280 --> 00:01:15,840
can reach me through social media on

27
00:01:15,840 --> 00:01:18,400
github twitter

28
00:01:18,400 --> 00:01:23,360
or my personal links i'm also teaching

29
00:01:23,360 --> 00:01:24,960
cyber security

30
00:01:24,960 --> 00:01:27,520
in the quinnipiac university a

31
00:01:27,520 --> 00:01:29,200
connecticut-based university in the

32
00:01:29,200 --> 00:01:32,159
united states which has a master's

33
00:01:32,159 --> 00:01:34,479
online full online program so if you're

34
00:01:34,479 --> 00:01:36,479
interested

35
00:01:36,479 --> 00:01:38,960
shoot me an email

36
00:01:38,960 --> 00:01:40,479
okay so

37
00:01:40,479 --> 00:01:43,200
why is service that important

38
00:01:43,200 --> 00:01:46,000
uh we'll get to server specific uh soon

39
00:01:46,000 --> 00:01:48,000
but cloud native in general servos is

40
00:01:48,000 --> 00:01:50,000
part of cloud native cloud native in

41
00:01:50,000 --> 00:01:53,119
general is presumed to be the future of

42
00:01:53,119 --> 00:01:55,439
application development idc predicts

43
00:01:55,439 --> 00:01:59,200
that this year by end of the year uh 70

44
00:01:59,200 --> 00:02:01,680
of all newly developed deployed

45
00:02:01,680 --> 00:02:03,360
enterprise application

46
00:02:03,360 --> 00:02:06,960
will be deployed as cloud native

47
00:02:06,960 --> 00:02:10,239
that is based on uh architecture which

48
00:02:10,239 --> 00:02:12,959
is hyper agile which uses containers

49
00:02:12,959 --> 00:02:16,000
microservice and service functions

50
00:02:16,000 --> 00:02:16,800
um

51
00:02:16,800 --> 00:02:19,360
in general we already see

52
00:02:19,360 --> 00:02:21,840
a massive transformation into cloud

53
00:02:21,840 --> 00:02:22,800
native

54
00:02:22,800 --> 00:02:24,400
we can find

55
00:02:24,400 --> 00:02:27,680
at the top irobot skyscanner netflix our

56
00:02:27,680 --> 00:02:30,560
company that already utilize everything

57
00:02:30,560 --> 00:02:33,360
almost everything as a cloud native

58
00:02:33,360 --> 00:02:36,160
environment and we can see some big

59
00:02:36,160 --> 00:02:38,400
companies not only startups like capital

60
00:02:38,400 --> 00:02:41,519
one walt disney ebay coca-cola etc they

61
00:02:41,519 --> 00:02:45,120
are moving there and they are still

62
00:02:45,120 --> 00:02:48,000
working in some kind of a hybrid

63
00:02:48,000 --> 00:02:50,239
solution some of their application are

64
00:02:50,239 --> 00:02:53,440
cloud native and some are monolith

65
00:02:53,440 --> 00:02:56,160
but cloud native what does it mean

66
00:02:56,160 --> 00:02:58,319
it's not just a development pattern it's

67
00:02:58,319 --> 00:03:00,800
not just using containers and servers

68
00:03:00,800 --> 00:03:02,800
it's a different a completely different

69
00:03:02,800 --> 00:03:05,360
architecture so we don't have

70
00:03:05,360 --> 00:03:07,920
one big flow that

71
00:03:07,920 --> 00:03:09,840
what we are used to know from the

72
00:03:09,840 --> 00:03:11,280
monoliths from the traditional

73
00:03:11,280 --> 00:03:13,920
application uh everything is deployed

74
00:03:13,920 --> 00:03:16,879
into one big logic

75
00:03:16,879 --> 00:03:19,680
instead uh what we do is we utilize

76
00:03:19,680 --> 00:03:22,080
microservices or

77
00:03:22,080 --> 00:03:23,760
nanoservices

78
00:03:23,760 --> 00:03:25,599
which basically

79
00:03:25,599 --> 00:03:28,720
tear everything apart to small pieces

80
00:03:28,720 --> 00:03:29,840
and then

81
00:03:29,840 --> 00:03:32,480
a lot of work in connecting them

82
00:03:32,480 --> 00:03:34,959
together into one flow

83
00:03:34,959 --> 00:03:37,920
so it's a combination of code and your

84
00:03:37,920 --> 00:03:41,920
infrastructure that together builds um

85
00:03:41,920 --> 00:03:42,879
the

86
00:03:42,879 --> 00:03:45,120
cloud native application the cycles are

87
00:03:45,120 --> 00:03:47,920
also different it's not a water flow

88
00:03:47,920 --> 00:03:51,280
life cycle which you build test and

89
00:03:51,280 --> 00:03:54,319
continue uh with the flow but instead

90
00:03:54,319 --> 00:03:56,319
there it's more of a devops or dev

91
00:03:56,319 --> 00:03:59,680
secops now it's also called uh operation

92
00:03:59,680 --> 00:04:01,840
where you work in a hyper-agile

93
00:04:01,840 --> 00:04:05,519
environment and every cycle is uh in in

94
00:04:05,519 --> 00:04:08,879
short cycles and you keep going

95
00:04:08,879 --> 00:04:12,720
with them so uh the process is different

96
00:04:12,720 --> 00:04:13,519
is

97
00:04:13,519 --> 00:04:17,199
last manual you don't have uh hey today

98
00:04:17,199 --> 00:04:20,399
we're updating the environment so uh

99
00:04:20,399 --> 00:04:23,199
let's have a full

100
00:04:23,199 --> 00:04:27,199
server update or uh downtime instead uh

101
00:04:27,199 --> 00:04:29,199
the process is complete almost

102
00:04:29,199 --> 00:04:32,400
completely automated and the decision is

103
00:04:32,400 --> 00:04:34,080
also taken by

104
00:04:34,080 --> 00:04:36,320
the developer themself which take cares

105
00:04:36,320 --> 00:04:39,919
or owns the security and

106
00:04:39,919 --> 00:04:42,800
code into production it's not

107
00:04:42,800 --> 00:04:46,720
managed by high hierarchy as before

108
00:04:46,720 --> 00:04:48,639
serverless architecture

109
00:04:48,639 --> 00:04:50,960
in general it's like a big puzzle it's a

110
00:04:50,960 --> 00:04:53,759
lot of resources could be hundreds in

111
00:04:53,759 --> 00:04:55,120
some

112
00:04:55,120 --> 00:04:56,720
applications that we saw it's even

113
00:04:56,720 --> 00:04:59,680
thousands of resources that each is

114
00:04:59,680 --> 00:05:02,160
connected to another using some kind of

115
00:05:02,160 --> 00:05:04,160
a glue over infrastructure or a

116
00:05:04,160 --> 00:05:06,880
configuration and all of that together

117
00:05:06,880 --> 00:05:09,759
becomes one big application

118
00:05:09,759 --> 00:05:10,720
but

119
00:05:10,720 --> 00:05:12,720
if we're talking about security here so

120
00:05:12,720 --> 00:05:15,120
we need to understand that

121
00:05:15,120 --> 00:05:16,320
these

122
00:05:16,320 --> 00:05:18,560
resources or services

123
00:05:18,560 --> 00:05:20,960
in many cases they are stateless or they

124
00:05:20,960 --> 00:05:23,440
don't really understand the entire flow

125
00:05:23,440 --> 00:05:26,240
but they own only the specific small

126
00:05:26,240 --> 00:05:28,160
piece of logic

127
00:05:28,160 --> 00:05:30,080
which means that in many cases we will

128
00:05:30,080 --> 00:05:32,479
have to apply security to each one of

129
00:05:32,479 --> 00:05:35,360
them in a separately

130
00:05:35,360 --> 00:05:38,960
so it has a lot of security challenges

131
00:05:38,960 --> 00:05:41,520
and we will discuss that

132
00:05:41,520 --> 00:05:44,080
okay when i talk about serverless what

133
00:05:44,080 --> 00:05:46,160
do i mean

134
00:05:46,160 --> 00:05:48,880
we'll ma discuss some of the biggest

135
00:05:48,880 --> 00:05:50,720
cloud providers but in general

136
00:05:50,720 --> 00:05:53,039
serverless means that

137
00:05:53,039 --> 00:05:55,680
you don't own the server where you run

138
00:05:55,680 --> 00:05:58,639
your application so the server is given

139
00:05:58,639 --> 00:06:00,639
the server we'll talk about it in a

140
00:06:00,639 --> 00:06:02,960
second is given by the cloud provider

141
00:06:02,960 --> 00:06:05,520
aws gcp

142
00:06:05,520 --> 00:06:09,600
et cetera and uh when the code of a

143
00:06:09,600 --> 00:06:11,600
serverless function for example needs to

144
00:06:11,600 --> 00:06:14,400
run basically the cloud provider spins

145
00:06:14,400 --> 00:06:15,600
up

146
00:06:15,600 --> 00:06:18,400
on demand a container runs the code

147
00:06:18,400 --> 00:06:20,240
executes the codes and then shuts this

148
00:06:20,240 --> 00:06:21,440
down

149
00:06:21,440 --> 00:06:22,800
the triggers

150
00:06:22,800 --> 00:06:25,440
for these type of executions are based

151
00:06:25,440 --> 00:06:28,319
on cloud events cloud events is so it's

152
00:06:28,319 --> 00:06:30,400
an event-driven architecture cloud

153
00:06:30,400 --> 00:06:33,120
events means that something happened in

154
00:06:33,120 --> 00:06:35,440
the cloud it could be an api like we're

155
00:06:35,440 --> 00:06:38,080
most familiar with but it could also be

156
00:06:38,080 --> 00:06:41,600
someone uploaded a file to a cloud

157
00:06:41,600 --> 00:06:43,199
storage somewhere

158
00:06:43,199 --> 00:06:44,880
or uh

159
00:06:44,880 --> 00:06:49,199
someone sent an email to someone or

160
00:06:49,199 --> 00:06:51,599
logs that arrived and collected or

161
00:06:51,599 --> 00:06:55,120
analytics and all of that is configured

162
00:06:55,120 --> 00:06:56,400
to allow

163
00:06:56,400 --> 00:06:59,280
the serverless function to run

164
00:06:59,280 --> 00:07:01,280
the environments are usually read only

165
00:07:01,280 --> 00:07:03,280
so you you cannot really

166
00:07:03,280 --> 00:07:05,120
change anything in environment in the

167
00:07:05,120 --> 00:07:07,360
container that runs the code it's a

168
00:07:07,360 --> 00:07:08,960
read-only environment

169
00:07:08,960 --> 00:07:11,520
in aws you have the slash temp directory

170
00:07:11,520 --> 00:07:13,840
so you can write the data there but all

171
00:07:13,840 --> 00:07:14,800
the

172
00:07:14,800 --> 00:07:16,960
environment itself is a read-only

173
00:07:16,960 --> 00:07:18,880
other cloud providers have a little bit

174
00:07:18,880 --> 00:07:22,400
different and we'll talk about that

175
00:07:22,479 --> 00:07:25,120
the code or the environment terminates

176
00:07:25,120 --> 00:07:27,759
when the code finishes the execution so

177
00:07:27,759 --> 00:07:31,280
once the code is completed the container

178
00:07:31,280 --> 00:07:32,639
itself

179
00:07:32,639 --> 00:07:34,400
shuts down so you don't really have

180
00:07:34,400 --> 00:07:35,919
access to it

181
00:07:35,919 --> 00:07:38,880
you cannot ssh to the to the environment

182
00:07:38,880 --> 00:07:40,479
to the runtime environment of the

183
00:07:40,479 --> 00:07:41,919
function

184
00:07:41,919 --> 00:07:44,080
it just executes the code so when it

185
00:07:44,080 --> 00:07:47,520
spins up it has the code already inside

186
00:07:47,520 --> 00:07:51,440
the data is also temporary so when the

187
00:07:51,440 --> 00:07:53,599
container shuts down or the execution is

188
00:07:53,599 --> 00:07:57,599
completed the data that was inside

189
00:07:57,599 --> 00:08:01,919
is uh deleted or just eliminated

190
00:08:01,919 --> 00:08:03,440
and we have a

191
00:08:03,440 --> 00:08:06,479
while an asterisk there because uh

192
00:08:06,479 --> 00:08:10,000
in order to um to maintain performance

193
00:08:10,000 --> 00:08:12,240
the cloud providers really just put

194
00:08:12,240 --> 00:08:15,280
those containers aside and reuse them

195
00:08:15,280 --> 00:08:17,759
so in some cases even though it's not

196
00:08:17,759 --> 00:08:20,240
controlled by us

197
00:08:20,240 --> 00:08:22,639
one execution can have

198
00:08:22,639 --> 00:08:24,879
data from previous execution but again

199
00:08:24,879 --> 00:08:27,919
we cannot rely on that or know that it's

200
00:08:27,919 --> 00:08:30,479
random from our side

201
00:08:30,479 --> 00:08:32,080
the code as i mentioned

202
00:08:32,080 --> 00:08:34,719
reside already inside the environment

203
00:08:34,719 --> 00:08:36,399
when we create the

204
00:08:36,399 --> 00:08:37,760
the functions

205
00:08:37,760 --> 00:08:40,958
uh also the keys for

206
00:08:40,958 --> 00:08:43,279
the function in order to be able to

207
00:08:43,279 --> 00:08:46,480
interact with other services is also

208
00:08:46,480 --> 00:08:47,760
inside the environment so when the

209
00:08:47,760 --> 00:08:49,360
environment spins up the keys are

210
00:08:49,360 --> 00:08:51,920
already in there so when you need to

211
00:08:51,920 --> 00:08:54,720
grab data from the database you have

212
00:08:54,720 --> 00:08:57,680
already access to that

213
00:08:57,680 --> 00:08:59,680
and we'll talk about that from a

214
00:08:59,680 --> 00:09:02,480
security perspective

215
00:09:02,480 --> 00:09:05,279
all right so i mentioned an event-driven

216
00:09:05,279 --> 00:09:08,240
architecture what does it actually mean

217
00:09:08,240 --> 00:09:10,880
it means that uh

218
00:09:10,880 --> 00:09:12,720
something happened

219
00:09:12,720 --> 00:09:13,920
in the cloud

220
00:09:13,920 --> 00:09:18,959
so api f3 bucket dynamodb iot rule etc

221
00:09:18,959 --> 00:09:22,720
that executes the code this is what we

222
00:09:22,720 --> 00:09:26,000
own this is our code it executes our

223
00:09:26,000 --> 00:09:29,040
code which usually processes some data

224
00:09:29,040 --> 00:09:31,760
and interacts with other services and

225
00:09:31,760 --> 00:09:33,519
there are many services that we can

226
00:09:33,519 --> 00:09:34,839
interact with

227
00:09:34,839 --> 00:09:38,080
and the security risk really mostly

228
00:09:38,080 --> 00:09:40,880
reside here

229
00:09:41,600 --> 00:09:44,320
all right so let's understand what is

230
00:09:44,320 --> 00:09:46,399
this single purpose container

231
00:09:46,399 --> 00:09:49,519
better so we have

232
00:09:49,519 --> 00:09:51,920
aws azure and gcp

233
00:09:51,920 --> 00:09:53,680
and there are many others but of course

234
00:09:53,680 --> 00:09:56,480
we cannot cover everyone those usually

235
00:09:56,480 --> 00:09:57,839
have the

236
00:09:57,839 --> 00:10:00,560
most uh the the highest part of the

237
00:10:00,560 --> 00:10:01,600
market

238
00:10:01,600 --> 00:10:05,680
share uh ephemeral so as i mentioned aws

239
00:10:05,680 --> 00:10:08,240
really just eliminates the container

240
00:10:08,240 --> 00:10:11,279
after it runs so it doesn't leave

241
00:10:11,279 --> 00:10:14,560
anymore on azure and gcp it resides a

242
00:10:14,560 --> 00:10:16,640
little more uh depends on the

243
00:10:16,640 --> 00:10:19,279
configuration

244
00:10:19,279 --> 00:10:21,839
aws has the read-only

245
00:10:21,839 --> 00:10:24,240
environment other than slash temp

246
00:10:24,240 --> 00:10:26,480
on gcp you have the slash stamp and

247
00:10:26,480 --> 00:10:27,600
flash home

248
00:10:27,600 --> 00:10:30,320
in azure it really just continues to

249
00:10:30,320 --> 00:10:32,800
leave again you can change that

250
00:10:32,800 --> 00:10:35,839
configuration different triggers aws is

251
00:10:35,839 --> 00:10:38,320
uh of course behind um

252
00:10:38,320 --> 00:10:40,160
in front of everyone with i think

253
00:10:40,160 --> 00:10:43,040
today's already almost 30 different

254
00:10:43,040 --> 00:10:47,120
triggers so email code sns sqs so queues

255
00:10:47,120 --> 00:10:49,920
authentication third parties etc uh

256
00:10:49,920 --> 00:10:54,160
azure and gcp are a little bit behind

257
00:10:54,160 --> 00:10:55,760
the source code

258
00:10:55,760 --> 00:10:58,880
is located under slash bar slash task

259
00:10:58,880 --> 00:11:00,959
you can also find it find it in this

260
00:11:00,959 --> 00:11:02,399
folder

261
00:11:02,399 --> 00:11:04,880
in aws as we know

262
00:11:04,880 --> 00:11:08,160
from previous monthly from application

263
00:11:08,160 --> 00:11:09,040
is

264
00:11:09,040 --> 00:11:12,800
www root and gcp had a user underscore

265
00:11:12,800 --> 00:11:15,839
code folder which holds holds

266
00:11:15,839 --> 00:11:18,800
the source code

267
00:11:19,440 --> 00:11:21,360
okay so

268
00:11:21,360 --> 00:11:23,600
what are the challenges there

269
00:11:23,600 --> 00:11:25,839
so when you would when you do

270
00:11:25,839 --> 00:11:27,839
some things in a small scale it doesn't

271
00:11:27,839 --> 00:11:30,320
really uh problem you can investigate

272
00:11:30,320 --> 00:11:32,720
you can put your efforts into it you can

273
00:11:32,720 --> 00:11:35,040
have security teams looking at it

274
00:11:35,040 --> 00:11:37,279
but when you need to scale that's a

275
00:11:37,279 --> 00:11:39,680
little bit different because uh if

276
00:11:39,680 --> 00:11:42,079
developers shift

277
00:11:42,079 --> 00:11:44,640
new or create new functions on a daily

278
00:11:44,640 --> 00:11:46,640
basis or at least change them on a daily

279
00:11:46,640 --> 00:11:49,120
basis the security teams cannot really

280
00:11:49,120 --> 00:11:51,200
keep up

281
00:11:51,200 --> 00:11:53,600
so you have a lot of services on aws you

282
00:11:53,600 --> 00:11:56,800
have almost 200 different services

283
00:11:56,800 --> 00:11:59,279
frequent deployments i know organization

284
00:11:59,279 --> 00:12:00,880
with

285
00:12:00,880 --> 00:12:03,279
hundreds of

286
00:12:03,279 --> 00:12:05,760
deployments to productions

287
00:12:05,760 --> 00:12:07,440
in a week

288
00:12:07,440 --> 00:12:09,920
that because you don't really need to

289
00:12:09,920 --> 00:12:13,519
wait for the entire service server to

290
00:12:13,519 --> 00:12:15,600
to update the server but instead

291
00:12:15,600 --> 00:12:18,079
developers push new small functions or

292
00:12:18,079 --> 00:12:20,160
changes into functions which run

293
00:12:20,160 --> 00:12:23,200
separate uh into production

294
00:12:23,200 --> 00:12:25,440
so think about how hard is it for

295
00:12:25,440 --> 00:12:27,680
security teams to follow

296
00:12:27,680 --> 00:12:30,560
uh what who is talking to who or exactly

297
00:12:30,560 --> 00:12:33,040
what is talking to what as you we've

298
00:12:33,040 --> 00:12:36,240
seen before with a complex uh puzzle

299
00:12:36,240 --> 00:12:39,600
there that the security teams really

300
00:12:39,600 --> 00:12:40,880
don't know

301
00:12:40,880 --> 00:12:42,720
what's going on in the environment yeah

302
00:12:42,720 --> 00:12:45,120
they know if there is an api that is

303
00:12:45,120 --> 00:12:47,360
exposed through the web the front end

304
00:12:47,360 --> 00:12:49,120
through the web application

305
00:12:49,120 --> 00:12:52,240
but in many cases it's just back

306
00:12:52,240 --> 00:12:55,120
back-end code that runs on

307
00:12:55,120 --> 00:12:57,120
based on other types of events which are

308
00:12:57,120 --> 00:12:59,519
not exposed to the world and security

309
00:12:59,519 --> 00:13:01,920
teams have no idea what's going on

310
00:13:01,920 --> 00:13:05,200
this is from experience

311
00:13:05,200 --> 00:13:06,959
many developers

312
00:13:06,959 --> 00:13:07,920
small

313
00:13:07,920 --> 00:13:10,320
security teams we know that in the best

314
00:13:10,320 --> 00:13:12,480
organization you'll have one security

315
00:13:12,480 --> 00:13:15,279
person for each 10 developers

316
00:13:15,279 --> 00:13:18,160
this is for mature organizations

317
00:13:18,160 --> 00:13:20,399
so it's hard for the security teams to

318
00:13:20,399 --> 00:13:22,720
follow

319
00:13:23,440 --> 00:13:26,240
how do you know what's important

320
00:13:26,240 --> 00:13:28,720
that's tricky questions you don't always

321
00:13:28,720 --> 00:13:31,120
know what's important unless you really

322
00:13:31,120 --> 00:13:33,200
talk to the engineering

323
00:13:33,200 --> 00:13:35,279
in this case you'll also have to talk to

324
00:13:35,279 --> 00:13:37,519
the devops or to the infras

325
00:13:37,519 --> 00:13:40,160
teams to understand really what is going

326
00:13:40,160 --> 00:13:41,600
on

327
00:13:41,600 --> 00:13:43,120
and uh

328
00:13:43,120 --> 00:13:45,839
the maybe the biggest uh question that

329
00:13:45,839 --> 00:13:48,480
we have is is the security

330
00:13:48,480 --> 00:13:51,760
even the same if we're approaching uh

331
00:13:51,760 --> 00:13:52,639
now

332
00:13:52,639 --> 00:13:54,240
security assessment for service

333
00:13:54,240 --> 00:13:55,440
application

334
00:13:55,440 --> 00:13:58,480
does my previous expertise uh

335
00:13:58,480 --> 00:14:00,959
enough or are they enough for

336
00:14:00,959 --> 00:14:03,279
understanding the security challenges

337
00:14:03,279 --> 00:14:05,519
here

338
00:14:05,519 --> 00:14:06,399
and

339
00:14:06,399 --> 00:14:08,560
uh as i mentioned part of the

340
00:14:08,560 --> 00:14:10,320
application is the infrastructure is the

341
00:14:10,320 --> 00:14:12,399
cloud so if we have a cloud

342
00:14:12,399 --> 00:14:14,399
infrastructure team of a devops team an

343
00:14:14,399 --> 00:14:16,399
engineering team and i have a security

344
00:14:16,399 --> 00:14:19,120
problems uh security issue

345
00:14:19,120 --> 00:14:21,519
in the cloud or in the application who

346
00:14:21,519 --> 00:14:24,560
takes care of it is it infra is it

347
00:14:24,560 --> 00:14:26,240
engineering

348
00:14:26,240 --> 00:14:28,959
who should i talk to

349
00:14:28,959 --> 00:14:32,000
okay let's try to understand what is the

350
00:14:32,000 --> 00:14:36,399
state of security in general so um

351
00:14:36,399 --> 00:14:38,800
recent checks that i did was showing

352
00:14:38,800 --> 00:14:41,040
that uh sorry

353
00:14:41,040 --> 00:14:43,440
serverless is keep keep rising of course

354
00:14:43,440 --> 00:14:46,160
this is quite old but it if you'll look

355
00:14:46,160 --> 00:14:48,560
it will be it will continue to grow as

356
00:14:48,560 --> 00:14:51,360
expected but the security really remains

357
00:14:51,360 --> 00:14:53,920
uh the same no one is actually

358
00:14:53,920 --> 00:14:56,000
interesting interest not no one but

359
00:14:56,000 --> 00:14:59,360
there are not enough um information or

360
00:14:59,360 --> 00:15:01,440
people that are checking

361
00:15:01,440 --> 00:15:04,639
specific security for serverless uh

362
00:15:04,639 --> 00:15:06,720
you can see it jumps between two in the

363
00:15:06,720 --> 00:15:09,279
best cases to one and i'm pretty sure

364
00:15:09,279 --> 00:15:11,279
this one is me

365
00:15:11,279 --> 00:15:14,160
from that period on i'm sure there are

366
00:15:14,160 --> 00:15:16,480
it can reach two or three but not more

367
00:15:16,480 --> 00:15:18,160
than that

368
00:15:18,160 --> 00:15:21,120
so we talked about uh

369
00:15:21,120 --> 00:15:24,399
is security the same so can we use the

370
00:15:24,399 --> 00:15:28,560
same appsec application security to uh

371
00:15:28,560 --> 00:15:30,639
to serve our serverless application does

372
00:15:30,639 --> 00:15:31,920
it apply

373
00:15:31,920 --> 00:15:34,959
let's uh understand some of the risks

374
00:15:34,959 --> 00:15:36,399
that we have

375
00:15:36,399 --> 00:15:38,480
in serverless applications so this is an

376
00:15:38,480 --> 00:15:41,120
example of a function a lambda function

377
00:15:41,120 --> 00:15:44,160
and aws lambda function is is their

378
00:15:44,160 --> 00:15:46,560
server's

379
00:15:46,800 --> 00:15:48,480
compute

380
00:15:48,480 --> 00:15:49,199
so

381
00:15:49,199 --> 00:15:52,079
small lines of code usually really the

382
00:15:52,079 --> 00:15:54,399
function doesn't do much here

383
00:15:54,399 --> 00:15:56,240
but you can see here that it it

384
00:15:56,240 --> 00:15:58,800
communicates with an orders table and

385
00:15:58,800 --> 00:16:02,800
the put item here is basically the uh um

386
00:16:02,800 --> 00:16:05,120
the api call that makes

387
00:16:05,120 --> 00:16:07,360
right into the database

388
00:16:07,360 --> 00:16:10,160
so what happens is the developer

389
00:16:10,160 --> 00:16:12,240
needs to give

390
00:16:12,240 --> 00:16:15,360
this function the permission the im

391
00:16:15,360 --> 00:16:16,959
policy

392
00:16:16,959 --> 00:16:18,959
for the function to interact with other

393
00:16:18,959 --> 00:16:21,199
services

394
00:16:21,199 --> 00:16:25,120
usually the developers as we know uh

395
00:16:25,120 --> 00:16:26,959
they will do something

396
00:16:26,959 --> 00:16:30,720
as quick as possible for it to work uh

397
00:16:30,720 --> 00:16:32,959
they will look into documentations and

398
00:16:32,959 --> 00:16:34,959
they will see what is what they need to

399
00:16:34,959 --> 00:16:37,040
do in order to make it work so if we

400
00:16:37,040 --> 00:16:39,120
look in the documentation or in stack

401
00:16:39,120 --> 00:16:41,360
overflow or things like this what we'll

402
00:16:41,360 --> 00:16:44,320
find is that we need to assign dynamodb

403
00:16:44,320 --> 00:16:45,440
uh

404
00:16:45,440 --> 00:16:46,399
access

405
00:16:46,399 --> 00:16:48,720
with a wildcard because the wildcard

406
00:16:48,720 --> 00:16:50,480
means that this function

407
00:16:50,480 --> 00:16:53,600
can do any operation so that would work

408
00:16:53,600 --> 00:16:55,600
of course when i'm saying

409
00:16:55,600 --> 00:16:57,920
that this is what developers will do

410
00:16:57,920 --> 00:16:59,920
it's not every developers of course we

411
00:16:59,920 --> 00:17:01,920
know that there are developers

412
00:17:01,920 --> 00:17:04,000
or organizations that take care of

413
00:17:04,000 --> 00:17:05,919
security or i am

414
00:17:05,919 --> 00:17:08,160
in a different manner

415
00:17:08,160 --> 00:17:09,760
but we'll talk about the problem at

416
00:17:09,760 --> 00:17:12,720
scale uh so the developer will assign a

417
00:17:12,720 --> 00:17:16,160
dynamodb wildcard policy here to any

418
00:17:16,160 --> 00:17:18,000
resource

419
00:17:18,000 --> 00:17:21,039
on the account id any table basically

420
00:17:21,039 --> 00:17:22,000
that's

421
00:17:22,000 --> 00:17:24,079
what what happens with this is that if

422
00:17:24,079 --> 00:17:25,919
this function is then

423
00:17:25,919 --> 00:17:28,240
identified as vulnerable

424
00:17:28,240 --> 00:17:30,320
someone who has access to

425
00:17:30,320 --> 00:17:33,120
this function can can execute any

426
00:17:33,120 --> 00:17:34,960
activity any action

427
00:17:34,960 --> 00:17:37,840
on any table in the cloud account so

428
00:17:37,840 --> 00:17:40,720
it's not just the application it's not

429
00:17:40,720 --> 00:17:42,880
just the database but basically it's any

430
00:17:42,880 --> 00:17:44,160
operation

431
00:17:44,160 --> 00:17:46,799
in the cloud account um it can be

432
00:17:46,799 --> 00:17:49,919
deleting tables modifying tables uh

433
00:17:49,919 --> 00:17:52,080
creating tables uh

434
00:17:52,080 --> 00:17:53,760
different even if they are not related

435
00:17:53,760 --> 00:17:56,720
to that specific application

436
00:17:56,720 --> 00:17:58,880
okay

437
00:17:58,880 --> 00:18:02,559
so as i said the wild card is uh bad

438
00:18:02,559 --> 00:18:04,880
because it's a bad practice because that

439
00:18:04,880 --> 00:18:07,280
gives the function a lot of

440
00:18:07,280 --> 00:18:09,520
permissions which it doesn't really need

441
00:18:09,520 --> 00:18:12,400
so what do we need to put here what we

442
00:18:12,400 --> 00:18:14,880
would need to do is to convert the put

443
00:18:14,880 --> 00:18:17,840
item here to the put item

444
00:18:17,840 --> 00:18:22,240
action in the aws uh im service and then

445
00:18:22,240 --> 00:18:24,240
put the table name here

446
00:18:24,240 --> 00:18:26,960
so in that case what will happen is that

447
00:18:26,960 --> 00:18:29,919
the function will only have access to

448
00:18:29,919 --> 00:18:30,880
write

449
00:18:30,880 --> 00:18:32,320
a single line

450
00:18:32,320 --> 00:18:35,440
each time it's it's a execution to this

451
00:18:35,440 --> 00:18:37,360
specific table

452
00:18:37,360 --> 00:18:38,799
think about this

453
00:18:38,799 --> 00:18:40,240
as a

454
00:18:40,240 --> 00:18:42,559
granularity that you would not be able

455
00:18:42,559 --> 00:18:43,760
to achieve

456
00:18:43,760 --> 00:18:46,080
in a monolith application because this

457
00:18:46,080 --> 00:18:49,039
really takes just the right

458
00:18:49,039 --> 00:18:51,039
action to the database just the activity

459
00:18:51,039 --> 00:18:53,760
of writing into the database and limits

460
00:18:53,760 --> 00:18:55,919
the attack surface here or the uh

461
00:18:55,919 --> 00:18:58,080
permission the access level to just this

462
00:18:58,080 --> 00:19:01,039
active action so if you could do if you

463
00:19:01,039 --> 00:19:03,200
take them a monolith application like a

464
00:19:03,200 --> 00:19:05,760
traditional application and you have

465
00:19:05,760 --> 00:19:07,760
thousands or millions lines of code and

466
00:19:07,760 --> 00:19:10,799
you could say no but inside this code

467
00:19:10,799 --> 00:19:13,120
this function this uh

468
00:19:13,120 --> 00:19:15,200
part of the code can only have

469
00:19:15,200 --> 00:19:16,799
permission to write

470
00:19:16,799 --> 00:19:18,559
to the fund to the database and this

471
00:19:18,559 --> 00:19:21,120
part could only uh will only be able to

472
00:19:21,120 --> 00:19:23,280
read this would be would have been great

473
00:19:23,280 --> 00:19:25,039
but it's not possible in monolith's

474
00:19:25,039 --> 00:19:27,520
application in serverless

475
00:19:27,520 --> 00:19:31,039
it does so it has a big opportunity here

476
00:19:31,039 --> 00:19:33,760
but the problem is when we try to scale

477
00:19:33,760 --> 00:19:35,520
things because if we have one function

478
00:19:35,520 --> 00:19:38,480
with 20 lines of code then it's easy to

479
00:19:38,480 --> 00:19:40,160
understand what's the security or what

480
00:19:40,160 --> 00:19:43,600
we need to put here but if we have a new

481
00:19:43,600 --> 00:19:46,240
code written every day

482
00:19:46,240 --> 00:19:48,720
and hundreds or thousands or tens of

483
00:19:48,720 --> 00:19:50,480
thousands and i know organization with

484
00:19:50,480 --> 00:19:52,160
millions

485
00:19:52,160 --> 00:19:54,559
then it's going to be hard to do it

486
00:19:54,559 --> 00:19:56,240
manually so you have to have some

487
00:19:56,240 --> 00:19:58,240
automated process there but how would

488
00:19:58,240 --> 00:19:59,200
you know

489
00:19:59,200 --> 00:20:02,320
it's if it's in the code

490
00:20:02,320 --> 00:20:04,320
another challenge that we have

491
00:20:04,320 --> 00:20:07,520
is um the loss of perimeter

492
00:20:07,520 --> 00:20:11,440
uh if before we had one way in well

493
00:20:11,440 --> 00:20:13,679
usually http or

494
00:20:13,679 --> 00:20:15,200
some kind of a gateway or a load

495
00:20:15,200 --> 00:20:18,799
balancer uh but we always had one way in

496
00:20:18,799 --> 00:20:21,760
what we would do is put all our security

497
00:20:21,760 --> 00:20:23,600
tools uh

498
00:20:23,600 --> 00:20:26,799
in front of it so we'll have dlps and

499
00:20:26,799 --> 00:20:30,000
firewalls and gateways and configuration

500
00:20:30,000 --> 00:20:31,679
everything in there

501
00:20:31,679 --> 00:20:33,520
but when we think about serverless

502
00:20:33,520 --> 00:20:35,120
application really we lose this

503
00:20:35,120 --> 00:20:37,919
perimeter and what happens is that

504
00:20:37,919 --> 00:20:40,640
developers can have access or sorry

505
00:20:40,640 --> 00:20:43,600
users can have access or users or maybe

506
00:20:43,600 --> 00:20:46,320
the system could execute code from

507
00:20:46,320 --> 00:20:49,360
various different of um of

508
00:20:49,360 --> 00:20:51,679
entry points it could be analytics it

509
00:20:51,679 --> 00:20:54,480
could be direct use apis you could be

510
00:20:54,480 --> 00:20:57,280
actually could be just calling the code

511
00:20:57,280 --> 00:20:59,679
so i can actually use an api to execute

512
00:20:59,679 --> 00:21:01,600
the code without going through any

513
00:21:01,600 --> 00:21:03,280
network component

514
00:21:03,280 --> 00:21:06,960
could be static assets uploads downloads

515
00:21:06,960 --> 00:21:11,600
or whatever mobile or whatever that is

516
00:21:15,039 --> 00:21:16,799
okay so let's get

517
00:21:16,799 --> 00:21:18,880
understand how we gain access to

518
00:21:18,880 --> 00:21:21,600
resources in different environments and

519
00:21:21,600 --> 00:21:24,240
by that i mean i have a function

520
00:21:24,240 --> 00:21:28,159
that runs the uh how from the function

521
00:21:28,159 --> 00:21:30,400
itself i can again access to different

522
00:21:30,400 --> 00:21:32,000
resources

523
00:21:32,000 --> 00:21:34,400
or services so to the database for

524
00:21:34,400 --> 00:21:38,080
example so if we take uh gcp

525
00:21:38,080 --> 00:21:40,640
inside the code we have a metadata

526
00:21:40,640 --> 00:21:41,919
service internal so

527
00:21:41,919 --> 00:21:44,080
metadata.google.internal

528
00:21:44,080 --> 00:21:45,679
where we can

529
00:21:45,679 --> 00:21:48,480
we can connect using the uh made to the

530
00:21:48,480 --> 00:21:50,240
meta flavor header

531
00:21:50,240 --> 00:21:53,840
with the access token and get a

532
00:21:53,840 --> 00:21:56,840
better token this very token or

533
00:21:56,840 --> 00:22:01,600
jwt can then translate to access

534
00:22:01,600 --> 00:22:05,120
this token can then be used to access or

535
00:22:05,120 --> 00:22:07,520
retrieve data so you can see here

536
00:22:07,520 --> 00:22:09,360
i'm doing a call to this metadata

537
00:22:09,360 --> 00:22:11,600
service i'm getting the token and then

538
00:22:11,600 --> 00:22:13,440
i'm doing a curl

539
00:22:13,440 --> 00:22:16,559
so in a simple request to a specific

540
00:22:16,559 --> 00:22:19,520
storage on a specific project and i'll

541
00:22:19,520 --> 00:22:21,280
get the data

542
00:22:21,280 --> 00:22:22,080
back

543
00:22:22,080 --> 00:22:25,360
so if i have access to the runtime

544
00:22:25,360 --> 00:22:27,200
and i can run this

545
00:22:27,200 --> 00:22:29,760
command i can get the token if i can get

546
00:22:29,760 --> 00:22:32,640
the token then from the internet no this

547
00:22:32,640 --> 00:22:34,640
is from the internal service but from

548
00:22:34,640 --> 00:22:36,720
the runtime of the function but this can

549
00:22:36,720 --> 00:22:39,280
be from my own computer and i can access

550
00:22:39,280 --> 00:22:41,520
the data

551
00:22:41,520 --> 00:22:42,880
on azure

552
00:22:42,880 --> 00:22:45,120
stuff something a little bit similar

553
00:22:45,120 --> 00:22:47,600
we'll do an and print and we'll see the

554
00:22:47,600 --> 00:22:50,640
endpoint and the secret and then we can

555
00:22:50,640 --> 00:22:52,159
use

556
00:22:52,159 --> 00:22:55,039
a curl command to an internal service to

557
00:22:55,039 --> 00:22:57,840
get the token using the secret header

558
00:22:57,840 --> 00:23:00,000
with the secret that we got

559
00:23:00,000 --> 00:23:02,880
and then we will get an access token

560
00:23:02,880 --> 00:23:05,200
from that using that access token we can

561
00:23:05,200 --> 00:23:06,000
then

562
00:23:06,000 --> 00:23:10,480
con connect to the other system or apis

563
00:23:10,480 --> 00:23:14,559
from the internet and then get get data

564
00:23:14,559 --> 00:23:16,400
so again if i'm running inside the

565
00:23:16,400 --> 00:23:17,520
function

566
00:23:17,520 --> 00:23:19,280
and i have access to

567
00:23:19,280 --> 00:23:21,840
uh to the to x to the execution to the

568
00:23:21,840 --> 00:23:24,559
runtime i can run this command

569
00:23:24,559 --> 00:23:26,799
get this data run this command get the

570
00:23:26,799 --> 00:23:28,799
token and then from my own computer and

571
00:23:28,799 --> 00:23:30,640
we'll see that in the demos in a sec in

572
00:23:30,640 --> 00:23:33,440
a few minutes i can interact with other

573
00:23:33,440 --> 00:23:36,159
information

574
00:23:36,159 --> 00:23:37,760
sorry

575
00:23:37,760 --> 00:23:39,440
the information

576
00:23:39,440 --> 00:23:42,240
that uh i can reach depends on the

577
00:23:42,240 --> 00:23:44,400
policy that is given to the function as

578
00:23:44,400 --> 00:23:47,039
we discussed before on aws it's a little

579
00:23:47,039 --> 00:23:48,240
bit similar

580
00:23:48,240 --> 00:23:50,159
running the end command will print the

581
00:23:50,159 --> 00:23:52,240
environment variables i will get the

582
00:23:52,240 --> 00:23:54,480
session token the access key and the key

583
00:23:54,480 --> 00:23:55,440
id

584
00:23:55,440 --> 00:23:58,960
these are permanent this is changing um

585
00:23:58,960 --> 00:23:59,919
and then

586
00:23:59,919 --> 00:24:04,559
using the aws cli or any uh api call

587
00:24:04,559 --> 00:24:07,440
that i want to make i can call aws

588
00:24:07,440 --> 00:24:10,080
dynamodb these tables get the list of

589
00:24:10,080 --> 00:24:14,240
tables using this token

590
00:24:14,720 --> 00:24:17,919
okay so we talked about the security

591
00:24:17,919 --> 00:24:19,200
challenges

592
00:24:19,200 --> 00:24:21,840
and we talked about how we

593
00:24:21,840 --> 00:24:22,880
get

594
00:24:22,880 --> 00:24:24,480
uh

595
00:24:24,480 --> 00:24:26,720
or how we connect to other services when

596
00:24:26,720 --> 00:24:29,200
we're in the runtime now let's try to

597
00:24:29,200 --> 00:24:31,440
understand how can i get into the

598
00:24:31,440 --> 00:24:33,679
runtime i told you there is no ssh to

599
00:24:33,679 --> 00:24:35,600
the environment so we cannot

600
00:24:35,600 --> 00:24:38,799
uh hope or do some network uh probing

601
00:24:38,799 --> 00:24:41,120
and try to understand maybe

602
00:24:41,120 --> 00:24:44,559
default credentials and and log into the

603
00:24:44,559 --> 00:24:46,799
ssh terminal and then do that no we

604
00:24:46,799 --> 00:24:47,840
cannot

605
00:24:47,840 --> 00:24:48,960
but

606
00:24:48,960 --> 00:24:51,600
uh the runtime execution if there is a

607
00:24:51,600 --> 00:24:54,559
vulnerability inside the function

608
00:24:54,559 --> 00:24:57,360
or in the configuration we can then

609
00:24:57,360 --> 00:24:59,760
uh try to execute commands in the

610
00:24:59,760 --> 00:25:02,080
runtime so this is an example over a

611
00:25:02,080 --> 00:25:03,520
scenario that will

612
00:25:03,520 --> 00:25:06,080
show a show now so there is a user

613
00:25:06,080 --> 00:25:08,480
interacting with the slack chat bot

614
00:25:08,480 --> 00:25:11,520
the chat bot communicates with the slack

615
00:25:11,520 --> 00:25:14,720
api of course which is configured to go

616
00:25:14,720 --> 00:25:17,279
through an api gateway the api gateway

617
00:25:17,279 --> 00:25:19,679
will execute the lambda function

618
00:25:19,679 --> 00:25:22,080
which will grab data from the database

619
00:25:22,080 --> 00:25:26,918
and we'll print it back to the user

620
00:25:30,400 --> 00:25:33,520
so this is the slack chat

621
00:25:33,520 --> 00:25:36,240
there is a chat uh chat bot here that

622
00:25:36,240 --> 00:25:37,200
just

623
00:25:37,200 --> 00:25:39,200
replies back

624
00:25:39,200 --> 00:25:40,840
to different

625
00:25:40,840 --> 00:25:44,480
messages there is a vulnerability inside

626
00:25:44,480 --> 00:25:46,559
the function the way that i know it is

627
00:25:46,559 --> 00:25:49,360
because i explored a little bit before

628
00:25:49,360 --> 00:25:53,120
this is a cve it's not like a specific

629
00:25:53,120 --> 00:25:56,799
vulnerability cve known using a specific

630
00:25:56,799 --> 00:25:59,440
dependency and you can see here i'm

631
00:25:59,440 --> 00:26:01,600
trying to run a command

632
00:26:01,600 --> 00:26:05,120
injection attack required child process

633
00:26:05,120 --> 00:26:06,880
and then

634
00:26:06,880 --> 00:26:08,799
run some

635
00:26:08,799 --> 00:26:12,720
some commands so i i'm doing here a curl

636
00:26:12,720 --> 00:26:15,200
or an an execution to

637
00:26:15,200 --> 00:26:17,640
uh curl to a

638
00:26:17,640 --> 00:26:20,720
hacker.androg.io which is uh an http

639
00:26:20,720 --> 00:26:23,200
tunnel that i have here

640
00:26:23,200 --> 00:26:25,600
and what i want to print

641
00:26:25,600 --> 00:26:28,320
is a test now that i figured out that

642
00:26:28,320 --> 00:26:30,880
it's vulnerable this request is coming

643
00:26:30,880 --> 00:26:33,200
from the function itself so now i can

644
00:26:33,200 --> 00:26:35,440
change the test to get some more

645
00:26:35,440 --> 00:26:36,960
interesting data

646
00:26:36,960 --> 00:26:38,559
and i can

647
00:26:38,559 --> 00:26:41,200
do unless for example get the file the

648
00:26:41,200 --> 00:26:42,159
function

649
00:26:42,159 --> 00:26:44,880
of the file inside the code

650
00:26:44,880 --> 00:26:47,279
inside the runtime now that i know the

651
00:26:47,279 --> 00:26:50,840
file i can try to read the

652
00:26:50,840 --> 00:26:56,159
file right so cat index.js

653
00:26:56,159 --> 00:26:59,679
and i probably want to base64 because we

654
00:26:59,679 --> 00:27:01,360
don't know what's inside

655
00:27:01,360 --> 00:27:04,080
maybe it's even binary

656
00:27:04,080 --> 00:27:08,320
so i got the base64 now i can go to

657
00:27:08,320 --> 00:27:11,120
the uh anger

658
00:27:11,120 --> 00:27:14,320
console get the data that i received

659
00:27:14,320 --> 00:27:16,799
uh it's basically a base64 a conversion

660
00:27:16,799 --> 00:27:17,840
of text

661
00:27:17,840 --> 00:27:21,639
i'll just copy that

662
00:27:21,679 --> 00:27:25,919
and decode it on my own computer

663
00:27:31,120 --> 00:27:33,279
then i got the source code of the

664
00:27:33,279 --> 00:27:34,559
function itself

665
00:27:34,559 --> 00:27:37,840
and i can see the api calls to the slack

666
00:27:37,840 --> 00:27:40,000
channel so now i know that there are

667
00:27:40,000 --> 00:27:42,000
some keys here that allows me to

668
00:27:42,000 --> 00:27:44,320
communicate with the channel and i can

669
00:27:44,320 --> 00:27:46,960
see in a dynamodb so a database call

670
00:27:46,960 --> 00:27:50,000
here so right now using the code i

671
00:27:50,000 --> 00:27:51,679
crafted

672
00:27:51,679 --> 00:27:52,559
sorry

673
00:27:52,559 --> 00:27:53,919
using the code

674
00:27:53,919 --> 00:27:57,919
i crafted a specific payload

675
00:28:01,039 --> 00:28:03,520
that i don't need uh

676
00:28:03,520 --> 00:28:06,880
to go through uh the the terminal

677
00:28:06,880 --> 00:28:08,720
anymore i can interact with slack

678
00:28:08,720 --> 00:28:10,559
because the code you can interact with

679
00:28:10,559 --> 00:28:12,640
slack so what i'm doing here is i'm

680
00:28:12,640 --> 00:28:16,240
creating a new dynamodb client this is

681
00:28:16,240 --> 00:28:19,440
just a syntax so require aws sdk allows

682
00:28:19,440 --> 00:28:23,039
me to create aws api calls i'm doing a

683
00:28:23,039 --> 00:28:24,240
scan scan

684
00:28:24,240 --> 00:28:25,279
brings

685
00:28:25,279 --> 00:28:27,760
reads the entire database and the table

686
00:28:27,760 --> 00:28:30,960
name as i saw here is inside the

687
00:28:30,960 --> 00:28:33,279
environment variable dynamodb table i

688
00:28:33,279 --> 00:28:35,360
don't even need to know the the name the

689
00:28:35,360 --> 00:28:37,520
bot token he's in the environment

690
00:28:37,520 --> 00:28:39,360
variable i can just use it because it's

691
00:28:39,360 --> 00:28:42,000
in the runtime and then i'm going to

692
00:28:42,000 --> 00:28:44,240
send it directly to the slack channel

693
00:28:44,240 --> 00:28:45,679
here

694
00:28:45,679 --> 00:28:48,320
and i got the entire

695
00:28:48,320 --> 00:28:51,439
the entire database

696
00:28:53,279 --> 00:28:55,440
this is because

697
00:28:55,440 --> 00:28:57,760
there is a vulnerability in the function

698
00:28:57,760 --> 00:29:00,799
but also because the function has

699
00:29:00,799 --> 00:29:03,520
um permission to scan or to read the

700
00:29:03,520 --> 00:29:05,919
entire database

701
00:29:05,919 --> 00:29:08,559
if this database if this function only

702
00:29:08,559 --> 00:29:10,880
writes to the database i should have

703
00:29:10,880 --> 00:29:13,679
only uh allow it to write into the

704
00:29:13,679 --> 00:29:16,000
database in the policy not that it's

705
00:29:16,000 --> 00:29:18,240
going to prevent the attack but it would

706
00:29:18,240 --> 00:29:21,520
limit the attack surface here

707
00:29:21,520 --> 00:29:22,399
all right

708
00:29:22,399 --> 00:29:25,200
so we saw one uh the entry point was in

709
00:29:25,200 --> 00:29:27,440
a third a third-party application but

710
00:29:27,440 --> 00:29:29,520
basically there is some kind of an api

711
00:29:29,520 --> 00:29:31,760
behind it now let's see something is it

712
00:29:31,760 --> 00:29:33,679
a little bit different than api which is

713
00:29:33,679 --> 00:29:36,399
a cloud storage what happens here is

714
00:29:36,399 --> 00:29:39,039
there i can upload files the files are

715
00:29:39,039 --> 00:29:41,919
going to sit in an s3 bucket

716
00:29:41,919 --> 00:29:44,640
once the file is uploaded to the bucket

717
00:29:44,640 --> 00:29:47,520
the bucket is configured to execute a

718
00:29:47,520 --> 00:29:50,640
lambda function so it's some code

719
00:29:50,640 --> 00:29:53,600
and the code uh sorry i'm uploading it

720
00:29:53,600 --> 00:29:55,679
through an api web api

721
00:29:55,679 --> 00:29:56,880
um

722
00:29:56,880 --> 00:29:59,279
the function gives me a token to upload

723
00:29:59,279 --> 00:30:02,000
directly to the bucket

724
00:30:02,000 --> 00:30:05,120
and then the the bucket interacts with

725
00:30:05,120 --> 00:30:08,080
the or triggers the code so let's see

726
00:30:08,080 --> 00:30:10,960
the demo sorry

727
00:30:13,039 --> 00:30:15,679
okay so what i'm using here is dbsa a

728
00:30:15,679 --> 00:30:17,440
damn vulnerable serverless application

729
00:30:17,440 --> 00:30:19,120
so it's a service

730
00:30:19,120 --> 00:30:22,720
a vulnerable by design serverless

731
00:30:22,720 --> 00:30:24,480
application with

732
00:30:24,480 --> 00:30:26,960
hundreds or dozens of services and

733
00:30:26,960 --> 00:30:29,039
resources behind it and there is a

734
00:30:29,039 --> 00:30:32,240
feedback channel here which like a page

735
00:30:32,240 --> 00:30:35,120
here which i can send messages and also

736
00:30:35,120 --> 00:30:37,360
uh add files

737
00:30:37,360 --> 00:30:40,159
so if i want to attach a file

738
00:30:40,159 --> 00:30:42,399
i'll just select the file

739
00:30:42,399 --> 00:30:47,760
and i can see from the um the response

740
00:30:47,760 --> 00:30:50,080
the request that i'm sending

741
00:30:50,080 --> 00:30:51,919
uploading a file and the response i get

742
00:30:51,919 --> 00:30:55,600
a talk a url which is a pre-signed url

743
00:30:55,600 --> 00:30:58,320
to upload a file directly to the s3

744
00:30:58,320 --> 00:31:01,279
bucket i'm not actually going through

745
00:31:01,279 --> 00:31:03,519
the application but i got from the

746
00:31:03,519 --> 00:31:04,799
application

747
00:31:04,799 --> 00:31:06,080
the uh

748
00:31:06,080 --> 00:31:08,640
the assigned url and i'm using the sign

749
00:31:08,640 --> 00:31:10,799
url to upload

750
00:31:10,799 --> 00:31:13,279
uh to a cloud storage

751
00:31:13,279 --> 00:31:16,320
but when i upload to the cloud storage

752
00:31:16,320 --> 00:31:19,600
uh it it uh executes a code that

753
00:31:19,600 --> 00:31:22,240
processes the file and this uh lambda

754
00:31:22,240 --> 00:31:24,240
function that executes that runs the

755
00:31:24,240 --> 00:31:27,760
code is vulnerable to command injection

756
00:31:27,760 --> 00:31:28,559
so

757
00:31:28,559 --> 00:31:31,120
uh what i'm doing here is

758
00:31:31,120 --> 00:31:33,120
doing a command injection that calls

759
00:31:33,120 --> 00:31:35,440
again this http channel i'm doing the

760
00:31:35,440 --> 00:31:37,440
http channel so i can get back the

761
00:31:37,440 --> 00:31:39,600
information because it doesn't come back

762
00:31:39,600 --> 00:31:42,480
in the response uh many servers

763
00:31:42,480 --> 00:31:44,720
functions are not synchronous so you

764
00:31:44,720 --> 00:31:46,799
don't have a request with the response

765
00:31:46,799 --> 00:31:49,200
data but instead it's more as i said

766
00:31:49,200 --> 00:31:52,080
asynchronous event driven

767
00:31:52,080 --> 00:31:54,240
so now that i have the file name

768
00:31:54,240 --> 00:31:57,120
set like this

769
00:31:58,799 --> 00:32:00,399
what i'm doing is i'm printing the

770
00:32:00,399 --> 00:32:02,399
environment variables which we saw

771
00:32:02,399 --> 00:32:07,840
before what they hold so i'll run that

772
00:32:09,230 --> 00:32:12,240
[Music]

773
00:32:12,240 --> 00:32:14,880
and you see i got some

774
00:32:14,880 --> 00:32:16,399
requests here

775
00:32:16,399 --> 00:32:18,719
and

776
00:32:19,600 --> 00:32:21,519
now that i have the data the environment

777
00:32:21,519 --> 00:32:24,960
variable i will decode it

778
00:32:27,039 --> 00:32:30,799
and i get the tokens as i said if we

779
00:32:30,799 --> 00:32:32,159
copy the

780
00:32:32,159 --> 00:32:35,679
session token the access key and the um

781
00:32:35,679 --> 00:32:39,360
secret key we can basically run commands

782
00:32:39,360 --> 00:32:41,679
from our own computer to interact with

783
00:32:41,679 --> 00:32:45,039
the cloud services that are allowed by

784
00:32:45,039 --> 00:32:47,600
the function

785
00:32:48,159 --> 00:32:51,679
so let's see how that happened

786
00:32:53,519 --> 00:32:55,679
aws cli

787
00:32:55,679 --> 00:32:58,240
interacting with s3 service

788
00:32:58,240 --> 00:33:01,279
i'm using the profile defcon here

789
00:33:01,279 --> 00:33:05,200
and now i got the all the buckets or all

790
00:33:05,200 --> 00:33:06,720
the cloud storage

791
00:33:06,720 --> 00:33:08,720
now because the function has permission

792
00:33:08,720 --> 00:33:12,080
to do more than that i can continue to

793
00:33:12,080 --> 00:33:14,640
uh interact with the

794
00:33:14,640 --> 00:33:17,279
uh with the services and get more and

795
00:33:17,279 --> 00:33:18,559
more data

796
00:33:18,559 --> 00:33:21,279
and you can see i got some

797
00:33:21,279 --> 00:33:22,720
receipts here

798
00:33:22,720 --> 00:33:24,480
and i can even modify

799
00:33:24,480 --> 00:33:27,279
a receipt and upload it back

800
00:33:27,279 --> 00:33:30,799
to the cloud because i the function has

801
00:33:30,799 --> 00:33:33,600
access to do so so my tokens my access

802
00:33:33,600 --> 00:33:38,600
keys also have access to do that

803
00:33:51,600 --> 00:33:54,640
so basically i uploaded a file

804
00:33:54,640 --> 00:33:55,679
and

805
00:33:55,679 --> 00:33:58,480
the case here would be that maybe i

806
00:33:58,480 --> 00:34:00,960
uploaded some file that i purchased

807
00:34:00,960 --> 00:34:03,600
something and then i can call uh support

808
00:34:03,600 --> 00:34:05,600
and tell them nothing happened nothing

809
00:34:05,600 --> 00:34:06,880
arrived

810
00:34:06,880 --> 00:34:09,199
and they'll see the receipt but anyway

811
00:34:09,199 --> 00:34:12,399
this is just an example

812
00:34:12,399 --> 00:34:13,520
okay

813
00:34:13,520 --> 00:34:14,879
let's continue

814
00:34:14,879 --> 00:34:16,159
so

815
00:34:16,159 --> 00:34:18,719
how do we understand or how do we find

816
00:34:18,719 --> 00:34:20,879
security vulnerabilities in a service

817
00:34:20,879 --> 00:34:23,520
environment can we use the same security

818
00:34:23,520 --> 00:34:24,560
tools

819
00:34:24,560 --> 00:34:26,960
uh that we used before

820
00:34:26,960 --> 00:34:29,839
to test for serverless application

821
00:34:29,839 --> 00:34:31,918
we can but it's not going to be as good

822
00:34:31,918 --> 00:34:33,599
as you think it would

823
00:34:33,599 --> 00:34:36,079
most of these tools are really ignorant

824
00:34:36,079 --> 00:34:37,599
to uh

825
00:34:37,599 --> 00:34:39,199
to the environment so they don't really

826
00:34:39,199 --> 00:34:42,960
understand anything else other than http

827
00:34:42,960 --> 00:34:44,719
or some kind of a

828
00:34:44,719 --> 00:34:46,480
tcp based

829
00:34:46,480 --> 00:34:49,119
interaction with the code they have the

830
00:34:49,119 --> 00:34:51,599
uh the request coming in so the sync and

831
00:34:51,599 --> 00:34:52,879
the source

832
00:34:52,879 --> 00:34:54,399
they follow but they don't really

833
00:34:54,399 --> 00:34:57,359
understand things like interaction and

834
00:34:57,359 --> 00:34:59,440
configurations which is cloud-based so

835
00:34:59,440 --> 00:35:02,320
they don't have the context uh if a

836
00:35:02,320 --> 00:35:03,680
function has

837
00:35:03,680 --> 00:35:04,960
access to

838
00:35:04,960 --> 00:35:07,520
uh has a vulnerability let's say

839
00:35:07,520 --> 00:35:10,560
but it cannot do anything because if the

840
00:35:10,560 --> 00:35:12,800
permission doesn't allow it then even if

841
00:35:12,800 --> 00:35:14,960
there is a vulnerability a potential

842
00:35:14,960 --> 00:35:16,880
vulnerability it's not

843
00:35:16,880 --> 00:35:18,880
uh it's not exploitable because the

844
00:35:18,880 --> 00:35:21,599
function cannot do it and it is going to

845
00:35:21,599 --> 00:35:24,000
be blocked by the infrastructure itself

846
00:35:24,000 --> 00:35:26,800
so they can produce would produce a lot

847
00:35:26,800 --> 00:35:28,880
of false positives and a lot of false

848
00:35:28,880 --> 00:35:30,560
negatives because they cannot see

849
00:35:30,560 --> 00:35:33,839
anything that it doesn't have uh a sync

850
00:35:33,839 --> 00:35:36,720
and a source or an http usually uh if

851
00:35:36,720 --> 00:35:39,280
something happens because there is an

852
00:35:39,280 --> 00:35:40,720
analytic service running in the

853
00:35:40,720 --> 00:35:43,200
background that uh

854
00:35:43,200 --> 00:35:45,119
and every uh

855
00:35:45,119 --> 00:35:48,000
and every part of of data processing

856
00:35:48,000 --> 00:35:51,280
runs uh a function then what happens is

857
00:35:51,280 --> 00:35:53,839
that when you run tests they cannot test

858
00:35:53,839 --> 00:35:55,920
it you can if you're using a tool like a

859
00:35:55,920 --> 00:35:58,480
das service for example you cannot even

860
00:35:58,480 --> 00:35:59,280
put

861
00:35:59,280 --> 00:36:00,880
point it to the endpoint because there

862
00:36:00,880 --> 00:36:03,440
are no endpoints in this case so what

863
00:36:03,440 --> 00:36:05,040
would you do

864
00:36:05,040 --> 00:36:07,359
slow executions

865
00:36:07,359 --> 00:36:09,680
it's not working as

866
00:36:09,680 --> 00:36:12,079
hey i have a new version of the server

867
00:36:12,079 --> 00:36:14,720
let's run a scan now to see that

868
00:36:14,720 --> 00:36:16,240
everything is in place no new

869
00:36:16,240 --> 00:36:19,119
vulnerabilities no different lambdas are

870
00:36:19,119 --> 00:36:20,800
run are

871
00:36:20,800 --> 00:36:23,040
added to production on a daily basis so

872
00:36:23,040 --> 00:36:25,599
it's hard to scan or to

873
00:36:25,599 --> 00:36:28,400
run some security testing for them

874
00:36:28,400 --> 00:36:30,320
so basically that stops blocks the

875
00:36:30,320 --> 00:36:32,960
developers and disruptive to the ci cd

876
00:36:32,960 --> 00:36:35,680
so security teams uh so developers and

877
00:36:35,680 --> 00:36:38,240
security teams don't really like using

878
00:36:38,240 --> 00:36:40,720
traditional tools and if they do it's

879
00:36:40,720 --> 00:36:42,640
because we have they have the licenses

880
00:36:42,640 --> 00:36:45,040
but they don't really have the ability

881
00:36:45,040 --> 00:36:46,800
to get the

882
00:36:46,800 --> 00:36:49,119
the best information and it's hard to

883
00:36:49,119 --> 00:36:50,160
scale

884
00:36:50,160 --> 00:36:52,079
in such a big environment

885
00:36:52,079 --> 00:36:56,000
uh what you should do uh is do something

886
00:36:56,000 --> 00:36:58,640
else because you have context of the

887
00:36:58,640 --> 00:37:00,720
cloud you can actually identify

888
00:37:00,720 --> 00:37:03,440
automatically everything that happens so

889
00:37:03,440 --> 00:37:05,440
if a developer pushes new or creates a

890
00:37:05,440 --> 00:37:08,400
new api connected to a code you can

891
00:37:08,400 --> 00:37:10,480
actually

892
00:37:10,480 --> 00:37:12,800
go through the entire process because

893
00:37:12,800 --> 00:37:15,760
these are all sitting in the same or

894
00:37:15,760 --> 00:37:18,079
sitting in the cloud and you have if you

895
00:37:18,079 --> 00:37:21,119
have the right tools you can actually

896
00:37:21,119 --> 00:37:23,520
monitor all of them and understand the

897
00:37:23,520 --> 00:37:26,000
flows and what's happening beside them

898
00:37:26,000 --> 00:37:27,119
what we do

899
00:37:27,119 --> 00:37:30,400
at contrast is that we send test those

900
00:37:30,400 --> 00:37:32,400
scenarios with malicious payloads and

901
00:37:32,400 --> 00:37:34,400
then we verify

902
00:37:34,400 --> 00:37:35,359
that

903
00:37:35,359 --> 00:37:37,839
each uh each of the resources to see if

904
00:37:37,839 --> 00:37:40,000
they are vulnerable or not and if they

905
00:37:40,000 --> 00:37:42,000
do we know also

906
00:37:42,000 --> 00:37:44,160
what is the impact what is the blast

907
00:37:44,160 --> 00:37:47,359
radius for the entire account

908
00:37:47,359 --> 00:37:49,359
there is a

909
00:37:49,359 --> 00:37:51,040
talk that i gave

910
00:37:51,040 --> 00:37:52,800
in black hat

911
00:37:52,800 --> 00:37:55,280
about attacking serverless function

912
00:37:55,280 --> 00:37:58,000
using alexa device so with my voice what

913
00:37:58,000 --> 00:38:00,880
i did was a sql injection using just my

914
00:38:00,880 --> 00:38:02,240
voice

915
00:38:02,240 --> 00:38:03,680
of course this is not something that you

916
00:38:03,680 --> 00:38:07,119
can run dust on uh or even sas because

917
00:38:07,119 --> 00:38:09,520
they don't know the uh the

918
00:38:09,520 --> 00:38:11,760
the source or the sink in this case

919
00:38:11,760 --> 00:38:14,240
um so this is a different approach that

920
00:38:14,240 --> 00:38:17,119
you should try to understand

921
00:38:17,119 --> 00:38:18,480
uh

922
00:38:18,480 --> 00:38:21,760
okay so we saw some examples but there

923
00:38:21,760 --> 00:38:24,720
are many more risks for serverless i'm

924
00:38:24,720 --> 00:38:26,880
not saying that service is not secure

925
00:38:26,880 --> 00:38:28,960
i'm just saying there are challenges and

926
00:38:28,960 --> 00:38:31,599
security risks which you we should

927
00:38:31,599 --> 00:38:33,599
account for and we should understand

928
00:38:33,599 --> 00:38:35,280
first of all so first of all is the

929
00:38:35,280 --> 00:38:37,520
event injection which is basically

930
00:38:37,520 --> 00:38:40,320
running injection attacks through events

931
00:38:40,320 --> 00:38:42,400
whether they are synchronous are

932
00:38:42,400 --> 00:38:45,839
synchronous direct or indirect

933
00:38:45,839 --> 00:38:48,160
authentication and we mentioned before

934
00:38:48,160 --> 00:38:50,000
we need to make sure

935
00:38:50,000 --> 00:38:52,160
our entire system is going through

936
00:38:52,160 --> 00:38:53,440
authentication

937
00:38:53,440 --> 00:38:56,160
zero trust maybe even if the

938
00:38:56,160 --> 00:38:59,839
services and resources are stateless

939
00:38:59,839 --> 00:39:02,079
sensitive data exposure relies

940
00:39:02,079 --> 00:39:04,480
everywhere over privileged function we

941
00:39:04,480 --> 00:39:06,640
discussed that vulnerable dependencies

942
00:39:06,640 --> 00:39:09,280
we all know i don't need to uh add more

943
00:39:09,280 --> 00:39:10,560
about that

944
00:39:10,560 --> 00:39:12,720
insufficient logging and monitoring so

945
00:39:12,720 --> 00:39:15,760
we don't have uh the ability well we

946
00:39:15,760 --> 00:39:18,480
have but we need designated tools to be

947
00:39:18,480 --> 00:39:21,119
able to monitor and log cloud-based

948
00:39:21,119 --> 00:39:23,200
application or serverless application

949
00:39:23,200 --> 00:39:26,079
because the data resides in locations

950
00:39:26,079 --> 00:39:29,119
that we do not own in most cases or as

951
00:39:29,119 --> 00:39:32,160
services so for example in aws you have

952
00:39:32,160 --> 00:39:33,119
the

953
00:39:33,119 --> 00:39:35,440
cloud trail and cloud watch logs which

954
00:39:35,440 --> 00:39:38,320
you should then uh monitor and get the

955
00:39:38,320 --> 00:39:39,920
information from

956
00:39:39,920 --> 00:39:42,240
open resources so basically resources

957
00:39:42,240 --> 00:39:45,040
which are misconfigured to have access

958
00:39:45,040 --> 00:39:46,240
externally

959
00:39:46,240 --> 00:39:48,160
denial of service versus denial of

960
00:39:48,160 --> 00:39:49,680
wallet

961
00:39:49,680 --> 00:39:51,040
shared

962
00:39:51,040 --> 00:39:54,640
space i mentioned before

963
00:39:54,720 --> 00:39:56,880
lambda lambda functions or functions in

964
00:39:56,880 --> 00:39:59,040
general can have data from

965
00:39:59,040 --> 00:40:02,400
uh previous executions by mistake

966
00:40:02,400 --> 00:40:05,280
and of course secret management

967
00:40:05,280 --> 00:40:07,040
you can read all of them

968
00:40:07,040 --> 00:40:10,400
in the os servers top 10 project

969
00:40:10,400 --> 00:40:12,560
right now it's an interpretation of the

970
00:40:12,560 --> 00:40:15,520
original top 10 uh into a serverless

971
00:40:15,520 --> 00:40:17,920
environment we're working on creating a

972
00:40:17,920 --> 00:40:21,200
new serverless and tailored top 10. uh

973
00:40:21,200 --> 00:40:23,040
you can participate if you work with

974
00:40:23,040 --> 00:40:25,760
servers so we would love to have your

975
00:40:25,760 --> 00:40:28,720
information uh participate in this open

976
00:40:28,720 --> 00:40:31,520
uh data data call

977
00:40:31,520 --> 00:40:34,160
also if you want to try it yourself you

978
00:40:34,160 --> 00:40:36,800
can use the os dvsa project it's an open

979
00:40:36,800 --> 00:40:39,119
source project you can install it and

980
00:40:39,119 --> 00:40:41,599
practice there are videos there are uh

981
00:40:41,599 --> 00:40:44,400
examples of how to use it

982
00:40:44,400 --> 00:40:46,640
and you can try it yourself make sure

983
00:40:46,640 --> 00:40:49,040
when you do if you do do not install it

984
00:40:49,040 --> 00:40:52,880
in production because it will deploy or

985
00:40:52,880 --> 00:40:55,520
production or any important aws account

986
00:40:55,520 --> 00:40:57,119
with sensitive data because it will

987
00:40:57,119 --> 00:40:59,040
deploy functions with a lot of

988
00:40:59,040 --> 00:41:02,560
permissions there which are vulnerable

989
00:41:02,560 --> 00:41:04,800
um with this

990
00:41:04,800 --> 00:41:07,359
i will uh conclude thank you very much

991
00:41:07,359 --> 00:41:11,040
to uh everyone who participated here uh

992
00:41:11,040 --> 00:41:13,599
if you have questions

993
00:41:13,599 --> 00:41:15,520
i'd love to answer

994
00:41:15,520 --> 00:41:18,480
in the remaining few minutes

995
00:41:18,480 --> 00:41:21,440
thank you very much oh that was uh

996
00:41:21,440 --> 00:41:22,720
interesting

997
00:41:22,720 --> 00:41:24,240
i knew about the

998
00:41:24,240 --> 00:41:26,319
serverless the dumb vulnerable set in

999
00:41:26,319 --> 00:41:28,240
this application but i have to say i

1000
00:41:28,240 --> 00:41:30,079
have never played with that

1001
00:41:30,079 --> 00:41:31,040
uh

1002
00:41:31,040 --> 00:41:33,119
yeah like most of the staff is like you

1003
00:41:33,119 --> 00:41:35,440
know it seems like the wheel repeats

1004
00:41:35,440 --> 00:41:37,599
itself with all the misconfigurations

1005
00:41:37,599 --> 00:41:38,319
and

1006
00:41:38,319 --> 00:41:40,880
uh that's usually kind of the

1007
00:41:40,880 --> 00:41:44,240
the main issue uh with all of this so i

1008
00:41:44,240 --> 00:41:46,000
was wondering like um

1009
00:41:46,000 --> 00:41:48,000
if you could share like any type of

1010
00:41:48,000 --> 00:41:49,440
story

1011
00:41:49,440 --> 00:41:50,560
where

1012
00:41:50,560 --> 00:41:52,960
there was an incident where the like the

1013
00:41:52,960 --> 00:41:55,680
entry point was one of these serverless

1014
00:41:55,680 --> 00:41:57,760
applications

1015
00:41:57,760 --> 00:41:59,520
um

1016
00:41:59,520 --> 00:42:02,640
so the example that i gave was from an

1017
00:42:02,640 --> 00:42:05,839
s3 bucket and and basically an api

1018
00:42:05,839 --> 00:42:09,520
gateway those mainly would be the most

1019
00:42:09,520 --> 00:42:11,440
common ones because

1020
00:42:11,440 --> 00:42:14,560
uh they are they are many times they are

1021
00:42:14,560 --> 00:42:17,200
configured or misconfigured to be open

1022
00:42:17,200 --> 00:42:20,319
but there are other services

1023
00:42:20,319 --> 00:42:23,280
i fi i have some uh or i saw some

1024
00:42:23,280 --> 00:42:25,280
security vulnerabilities in services

1025
00:42:25,280 --> 00:42:26,079
which

1026
00:42:26,079 --> 00:42:28,400
would be a little bit harder to exploit

1027
00:42:28,400 --> 00:42:29,599
because

1028
00:42:29,599 --> 00:42:32,079
they would not have an end point so you

1029
00:42:32,079 --> 00:42:33,839
cannot really reach them from the

1030
00:42:33,839 --> 00:42:36,319
internet they do have an endpoint but

1031
00:42:36,319 --> 00:42:39,280
it's uh an aws endpoint so you need to

1032
00:42:39,280 --> 00:42:42,839
have the right access credentials to

1033
00:42:42,839 --> 00:42:45,760
them the the maybe

1034
00:42:45,760 --> 00:42:48,960
the most interesting one was

1035
00:42:48,960 --> 00:42:50,000
um

1036
00:42:50,000 --> 00:42:52,240
using uh aws

1037
00:42:52,240 --> 00:42:54,480
pipelines and code commits so when

1038
00:42:54,480 --> 00:42:56,640
developers push new code there is a

1039
00:42:56,640 --> 00:42:58,720
process that spins

1040
00:42:58,720 --> 00:43:01,440
uh a function behind that

1041
00:43:01,440 --> 00:43:03,440
basically what it does it takes the code

1042
00:43:03,440 --> 00:43:06,319
push it into an um a container

1043
00:43:06,319 --> 00:43:08,560
and runs some processes in the

1044
00:43:08,560 --> 00:43:10,480
background to see tests and everything

1045
00:43:10,480 --> 00:43:13,520
to see that it's uh it's uh

1046
00:43:13,520 --> 00:43:15,920
not uh or it's running and going through

1047
00:43:15,920 --> 00:43:18,400
the uh end-to-end test or integration

1048
00:43:18,400 --> 00:43:21,280
test and in the function there was uh

1049
00:43:21,280 --> 00:43:23,599
um first of all the misconfiguration

1050
00:43:23,599 --> 00:43:25,440
like usual especially because it was

1051
00:43:25,440 --> 00:43:27,920
like a testing or a

1052
00:43:27,920 --> 00:43:30,400
pipeline function so it was not exposed

1053
00:43:30,400 --> 00:43:32,480
to the internet and they had paid less

1054
00:43:32,480 --> 00:43:34,319
attention to security

1055
00:43:34,319 --> 00:43:37,520
so it had multiple

1056
00:43:37,520 --> 00:43:40,480
permissions over permissions in uh in

1057
00:43:40,480 --> 00:43:42,400
containers and easy to use to spin up

1058
00:43:42,400 --> 00:43:44,319
spin down whatever

1059
00:43:44,319 --> 00:43:46,800
containers and it had

1060
00:43:46,800 --> 00:43:49,200
a vulnerability that you could basically

1061
00:43:49,200 --> 00:43:52,160
determine the location where the code

1062
00:43:52,160 --> 00:43:55,280
uh will uh will um

1063
00:43:55,280 --> 00:43:58,560
be downloaded to uh will be sent to the

1064
00:43:58,560 --> 00:44:00,560
container afterwards because it would

1065
00:44:00,560 --> 00:44:03,760
zip zip it in a way that you gave it and

1066
00:44:03,760 --> 00:44:06,880
then push it into the uh container and

1067
00:44:06,880 --> 00:44:09,200
what happened is that you could

1068
00:44:09,200 --> 00:44:10,240
change

1069
00:44:10,240 --> 00:44:14,400
the code structure so it would override

1070
00:44:14,400 --> 00:44:16,640
code in the container when it put when

1071
00:44:16,640 --> 00:44:20,319
it downloads it into the container

1072
00:44:20,319 --> 00:44:23,200
so if the developer or someone who has

1073
00:44:23,200 --> 00:44:25,280
access to it um

1074
00:44:25,280 --> 00:44:27,760
uh even that they don't really have

1075
00:44:27,760 --> 00:44:29,760
direct access to

1076
00:44:29,760 --> 00:44:31,920
run code on the container they have to

1077
00:44:31,920 --> 00:44:33,520
go through the pipeline

1078
00:44:33,520 --> 00:44:36,079
they could structure the code in a way

1079
00:44:36,079 --> 00:44:38,480
that they could run their own code

1080
00:44:38,480 --> 00:44:40,319
inside the container and do whatever

1081
00:44:40,319 --> 00:44:41,760
they want

1082
00:44:41,760 --> 00:44:44,079
that was a very complex but

1083
00:44:44,079 --> 00:44:45,440
very interesting

1084
00:44:45,440 --> 00:44:47,920
scenario

1085
00:44:47,920 --> 00:44:51,040
cool thanks for sharing that um

1086
00:44:51,040 --> 00:44:53,200
so we don't have any questions on the q

1087
00:44:53,200 --> 00:44:56,720
a and also we are out of time now

1088
00:44:56,720 --> 00:44:58,560
so thank you so much for for your

1089
00:44:58,560 --> 00:45:00,480
presentation i appreciate the time that

1090
00:45:00,480 --> 00:45:01,760
you took

1091
00:45:01,760 --> 00:45:03,280
to be with us today

1092
00:45:03,280 --> 00:45:06,920
thank you very much

