1
00:00:00,000 --> 00:00:03,419
so uh hi guys uh thanks for being here

2
00:00:03,419 --> 00:00:05,220
today uh today I'm gonna be talking

3
00:00:05,220 --> 00:00:08,580
about uh HTTP request logging so this is

4
00:00:08,580 --> 00:00:10,800
going to be a slightly technical talk uh

5
00:00:10,800 --> 00:00:13,259
it's gonna be covering specifically the

6
00:00:13,259 --> 00:00:15,120
vulnerability class um that is called

7
00:00:15,120 --> 00:00:16,920
HTTP request smuggling

8
00:00:16,920 --> 00:00:19,440
um which I have done some research on in

9
00:00:19,440 --> 00:00:21,000
the earlier part of this year and and

10
00:00:21,000 --> 00:00:23,100
this and today I want to just go over

11
00:00:23,100 --> 00:00:25,920
some of the findings that I have come

12
00:00:25,920 --> 00:00:27,960
across and some of the things that uh

13
00:00:27,960 --> 00:00:30,119
maybe I want to I want to bring to

14
00:00:30,119 --> 00:00:33,000
everyone's attention so uh let me just

15
00:00:33,000 --> 00:00:35,160
first formally introduce myself so I'm a

16
00:00:35,160 --> 00:00:37,079
I'm a student right now I'm not right

17
00:00:37,079 --> 00:00:39,300
now I'm currently actually in still in

18
00:00:39,300 --> 00:00:41,460
NS but I will be a student

19
00:00:41,460 --> 00:00:44,280
um I'm a developer I'm doing a full set

20
00:00:44,280 --> 00:00:46,440
web development in my free time I'm I'm

21
00:00:46,440 --> 00:00:48,600
also doing vulnerability research and

22
00:00:48,600 --> 00:00:51,660
specifically web security I play CTS

23
00:00:51,660 --> 00:00:54,000
with my team social engineering experts

24
00:00:54,000 --> 00:00:57,660
so uh today we are going to be covering

25
00:00:57,660 --> 00:00:59,640
um HTTP request plugging um I don't want

26
00:00:59,640 --> 00:01:01,500
to lose anyone right from the start so

27
00:01:01,500 --> 00:01:03,719
I'll be first going over a gentle

28
00:01:03,719 --> 00:01:05,459
introduction on what um this is all

29
00:01:05,459 --> 00:01:08,159
about and then we are going to talk more

30
00:01:08,159 --> 00:01:09,540
specifically about

31
00:01:09,540 --> 00:01:11,100
um some of the

32
00:01:11,100 --> 00:01:13,380
um some of the things that are

33
00:01:13,380 --> 00:01:16,380
um related to both HTTP 1 and HTTP 2 and

34
00:01:16,380 --> 00:01:18,600
how request marketing attacks can occur

35
00:01:18,600 --> 00:01:21,600
in both HTTP versions

36
00:01:21,600 --> 00:01:27,060
so uh the thing is uh for the CVS that I

37
00:01:27,060 --> 00:01:29,040
am going to discuss uh most of the most

38
00:01:29,040 --> 00:01:30,600
of it is

39
00:01:30,600 --> 00:01:33,720
um resulting from multiple passing flaws

40
00:01:33,720 --> 00:01:35,280
that I have compiled into a single

41
00:01:35,280 --> 00:01:38,100
report and then that one report is then

42
00:01:38,100 --> 00:01:40,860
converted into a CBE so it is in my

43
00:01:40,860 --> 00:01:42,060
opinion more meaningful to talk about

44
00:01:42,060 --> 00:01:44,340
the different types of passing flaws

45
00:01:44,340 --> 00:01:47,040
than about each CV individually but just

46
00:01:47,040 --> 00:01:50,759
as a general summary um this is the CV

47
00:01:50,759 --> 00:01:52,759
references that you can take a look at

48
00:01:52,759 --> 00:01:56,939
uh but I won't be you know talking about

49
00:01:56,939 --> 00:02:00,619
ecv individually because most of these

50
00:02:00,619 --> 00:02:04,740
types of behaviors are sort of like if

51
00:02:04,740 --> 00:02:06,439
you have one if you have one type of

52
00:02:06,439 --> 00:02:09,020
behavior that causes request smuggling

53
00:02:09,020 --> 00:02:11,459
most of the time you'll find that in

54
00:02:11,459 --> 00:02:14,580
more than one specific server or more

55
00:02:14,580 --> 00:02:17,220
than one specific proxy and so a lot of

56
00:02:17,220 --> 00:02:20,040
these CVS will overlap but I will be

57
00:02:20,040 --> 00:02:22,319
giving also a general summary table at

58
00:02:22,319 --> 00:02:24,780
the end of of each group of passing

59
00:02:24,780 --> 00:02:26,340
first I'll be talking about

60
00:02:26,340 --> 00:02:31,680
so uh so just in general what is HTTP in

61
00:02:31,680 --> 00:02:33,780
order to understand that we have to take

62
00:02:33,780 --> 00:02:35,040
a look at a brief history of the

63
00:02:35,040 --> 00:02:36,720
implementation of the HTTP protocol in

64
00:02:36,720 --> 00:02:39,540
the first place so

65
00:02:39,540 --> 00:02:41,819
the main difference between HTTP one and

66
00:02:41,819 --> 00:02:44,160
History 2 which is important to realize

67
00:02:44,160 --> 00:02:47,879
is that HTTP 1 is a purely text-based

68
00:02:47,879 --> 00:02:49,980
protocol what that means is that

69
00:02:49,980 --> 00:02:52,319
um it is essentially just plain text

70
00:02:52,319 --> 00:02:56,160
over TCP whereas for hdv2 it is a binary

71
00:02:56,160 --> 00:02:59,099
protocol which is consistent with most

72
00:02:59,099 --> 00:03:01,620
of the other protocols that are built on

73
00:03:01,620 --> 00:03:04,800
top of TCP where you kind of have

74
00:03:04,800 --> 00:03:07,560
um fields that are essentially just hex

75
00:03:07,560 --> 00:03:10,560
values not plain text right so for

76
00:03:10,560 --> 00:03:13,260
example the main the main impact of hgb2

77
00:03:13,260 --> 00:03:15,599
on request modeling is that it is that

78
00:03:15,599 --> 00:03:17,580
the data frames actually have a built-in

79
00:03:17,580 --> 00:03:19,920
length view into the protocol and that

80
00:03:19,920 --> 00:03:22,680
actually limits uh highly limits request

81
00:03:22,680 --> 00:03:26,640
marking in http 2. but for gb1 we know

82
00:03:26,640 --> 00:03:30,540
that each uh request is just a bunch of

83
00:03:30,540 --> 00:03:33,180
lines delimited by

84
00:03:33,180 --> 00:03:35,040
um the CRF sequence the new line

85
00:03:35,040 --> 00:03:38,580
sequence and the difference between HTTP

86
00:03:38,580 --> 00:03:42,239
1.0 and HD 1.1 is also important so

87
00:03:42,239 --> 00:03:44,879
history 1.1 allowed for connection we

88
00:03:44,879 --> 00:03:48,120
use whereas history 1.0 is doesn't allow

89
00:03:48,120 --> 00:03:49,799
for that um we will see how we will see

90
00:03:49,799 --> 00:03:51,599
what that means in a moment but

91
00:03:51,599 --> 00:03:53,340
essentially the most important thing is

92
00:03:53,340 --> 00:03:55,860
that for hb1 the length of each request

93
00:03:55,860 --> 00:03:58,680
is determined by either the content line

94
00:03:58,680 --> 00:04:01,019
feather or the transfer encoding chunk

95
00:04:01,019 --> 00:04:04,860
size and these are headers that are that

96
00:04:04,860 --> 00:04:08,280
are within the the HD protocol so for

97
00:04:08,280 --> 00:04:09,780
connection we use what this means is

98
00:04:09,780 --> 00:04:11,580
that for history 1.0

99
00:04:11,580 --> 00:04:15,540
um when it first uh when the most OG

100
00:04:15,540 --> 00:04:17,519
version is is just one connection for

101
00:04:17,519 --> 00:04:19,380
request so you have one TCP request

102
00:04:19,380 --> 00:04:22,260
which is for that specific

103
00:04:22,260 --> 00:04:24,300
um you have one TCP connection which is

104
00:04:24,300 --> 00:04:27,479
specific HTTP request and that

105
00:04:27,479 --> 00:04:29,520
corresponds to the multiple connections

106
00:04:29,520 --> 00:04:31,979
that we see on on the on the left

107
00:04:31,979 --> 00:04:34,320
diagram where you open a TCP connection

108
00:04:34,320 --> 00:04:37,740
you send a request you receive a HTTP

109
00:04:37,740 --> 00:04:40,320
response and then you close that TCP

110
00:04:40,320 --> 00:04:42,000
connection immediately

111
00:04:42,000 --> 00:04:43,500
and then for the next request and

112
00:04:43,500 --> 00:04:45,600
response you open another TCP connection

113
00:04:45,600 --> 00:04:48,479
so for HTTP 1.1 um it allowed for

114
00:04:48,479 --> 00:04:50,580
persistent connections and this is very

115
00:04:50,580 --> 00:04:52,740
important because persistent connections

116
00:04:52,740 --> 00:04:56,100
actually means that uh you can send a

117
00:04:56,100 --> 00:04:58,320
lot of HTTP replace and responses within

118
00:04:58,320 --> 00:05:02,160
the same TCP connection and why that is

119
00:05:02,160 --> 00:05:04,080
important is because that means that

120
00:05:04,080 --> 00:05:05,160
different requests can actually

121
00:05:05,160 --> 00:05:07,080
interfere with each other so if you are

122
00:05:07,080 --> 00:05:09,900
able to essentially affect one request

123
00:05:09,900 --> 00:05:12,540
um higher up in the TCP stream you can

124
00:05:12,540 --> 00:05:15,360
actually poison the the TCP stream and

125
00:05:15,360 --> 00:05:17,100
and affect the downstream request as

126
00:05:17,100 --> 00:05:19,020
well so this is where HTTP request login

127
00:05:19,020 --> 00:05:20,400
comes about

128
00:05:20,400 --> 00:05:22,380
um it is not possible in history 1.0

129
00:05:22,380 --> 00:05:24,960
because of the because of the specific

130
00:05:24,960 --> 00:05:27,000
TCP implementation where different

131
00:05:27,000 --> 00:05:28,620
requests cannot interfere with each

132
00:05:28,620 --> 00:05:30,539
other but the moment that we use HTTP

133
00:05:30,539 --> 00:05:31,680
1.1

134
00:05:31,680 --> 00:05:33,539
um that's when request margin came about

135
00:05:33,539 --> 00:05:36,960
so this is the most sort of vanilla or

136
00:05:36,960 --> 00:05:39,300
like the the original version of request

137
00:05:39,300 --> 00:05:41,340
marketing I'm just going to go to one

138
00:05:41,340 --> 00:05:43,500
example of that so that everyone can be

139
00:05:43,500 --> 00:05:46,380
on the same page so for example imagine

140
00:05:46,380 --> 00:05:48,780
that you have a front-end web proxy like

141
00:05:48,780 --> 00:05:52,199
nginx or Apache HTTP server implants

142
00:05:52,199 --> 00:05:54,720
access based control on a URL path so

143
00:05:54,720 --> 00:05:56,100
basically every everyone that is

144
00:05:56,100 --> 00:05:58,860
connecting to the web proxy cannot

145
00:05:58,860 --> 00:06:01,259
access slash internal

146
00:06:01,259 --> 00:06:04,680
um but essentially the the security is

147
00:06:04,680 --> 00:06:06,419
being implemented on the web proxy not

148
00:06:06,419 --> 00:06:09,479
the back-end server so if you have a web

149
00:06:09,479 --> 00:06:11,220
proxy and the front end proxy interprets

150
00:06:11,220 --> 00:06:13,560
the content length header it might see

151
00:06:13,560 --> 00:06:15,780
that in this specific request or the

152
00:06:15,780 --> 00:06:18,539
content length is 53 which means that

153
00:06:18,539 --> 00:06:20,820
this entire rate portion is is

154
00:06:20,820 --> 00:06:23,880
essentially gonna be uh is essentially

155
00:06:23,880 --> 00:06:26,819
going to be part of the request body and

156
00:06:26,819 --> 00:06:28,259
because it's part of the request body

157
00:06:28,259 --> 00:06:30,300
this this is this is inconsequential

158
00:06:30,300 --> 00:06:32,220
right I can put a get whatever here it

159
00:06:32,220 --> 00:06:33,479
doesn't matter it's part of the request

160
00:06:33,479 --> 00:06:35,160
body

161
00:06:35,160 --> 00:06:38,220
um and so the front end proxy only sees

162
00:06:38,220 --> 00:06:40,560
one request to the root URL path the

163
00:06:40,560 --> 00:06:43,199
entire body is forwarded to the back end

164
00:06:43,199 --> 00:06:44,639
but

165
00:06:44,639 --> 00:06:46,560
when we look at a request here we see

166
00:06:46,560 --> 00:06:48,180
that there is a transfer encoding header

167
00:06:48,180 --> 00:06:50,160
and um the transfer encoding is chunked

168
00:06:50,160 --> 00:06:52,800
so zero means that this is the end of

169
00:06:52,800 --> 00:06:54,660
the first request and then this is the

170
00:06:54,660 --> 00:06:57,240
start of the next required so this is uh

171
00:06:57,240 --> 00:07:00,000
this is so when when we look at this the

172
00:07:00,000 --> 00:07:01,620
main issue here is that the front end

173
00:07:01,620 --> 00:07:03,419
proxy is interpreting a Content length

174
00:07:03,419 --> 00:07:05,039
whereas the backend server is

175
00:07:05,039 --> 00:07:07,800
interpreting the transfer encoding and

176
00:07:07,800 --> 00:07:10,199
this is uh Illustrated here where

177
00:07:10,199 --> 00:07:12,300
essentially the finance says that okay I

178
00:07:12,300 --> 00:07:14,580
have a request the root URL containing a

179
00:07:14,580 --> 00:07:18,360
53 byte body this is the 53 byte body

180
00:07:18,360 --> 00:07:20,759
um and it assumed and and it assumes

181
00:07:20,759 --> 00:07:21,900
that the back end server would agree

182
00:07:21,900 --> 00:07:24,060
right so

183
00:07:24,060 --> 00:07:26,160
the brand server sees this um after the

184
00:07:26,160 --> 00:07:27,900
finance proxy forwards the request to

185
00:07:27,900 --> 00:07:30,180
the back-end server it sees that okay

186
00:07:30,180 --> 00:07:33,300
this is a chunked request and zero means

187
00:07:33,300 --> 00:07:34,979
that okay I'm gonna this is the end of

188
00:07:34,979 --> 00:07:37,740
the first request and then the start of

189
00:07:37,740 --> 00:07:39,780
the next request is um get slash

190
00:07:39,780 --> 00:07:41,580
internal so

191
00:07:41,580 --> 00:07:43,139
from the perspective of the backend

192
00:07:43,139 --> 00:07:45,479
server it actually sees two requests one

193
00:07:45,479 --> 00:07:48,060
to the root URL and one to internal

194
00:07:48,060 --> 00:07:52,860
and it sends back to um hdb replies one

195
00:07:52,860 --> 00:07:55,259
corresponding to the original URL and

196
00:07:55,259 --> 00:07:57,060
one corresponding to the slash internal

197
00:07:57,060 --> 00:08:01,199
request so in this case uh but in this

198
00:08:01,199 --> 00:08:03,539
case the the thought lies entirely with

199
00:08:03,539 --> 00:08:05,580
the finance proxy because

200
00:08:05,580 --> 00:08:07,680
um it is defined in RSC that transfer

201
00:08:07,680 --> 00:08:09,840
encoding headers will override content

202
00:08:09,840 --> 00:08:12,419
length so the the solution here is is

203
00:08:12,419 --> 00:08:14,099
that the finite proxy is vulnerable and

204
00:08:14,099 --> 00:08:15,960
and it should be looking at the transfer

205
00:08:15,960 --> 00:08:18,780
encoding instead so this is like the

206
00:08:18,780 --> 00:08:21,539
most uh simple to understand

207
00:08:21,539 --> 00:08:23,160
um request marketing Vector which is

208
00:08:23,160 --> 00:08:26,039
what was uh what was really widely

209
00:08:26,039 --> 00:08:27,960
publicized and widely discussed a few

210
00:08:27,960 --> 00:08:31,319
years back and so this is you you

211
00:08:31,319 --> 00:08:33,299
probably won't find this um anymore in

212
00:08:33,299 --> 00:08:34,320
the world

213
00:08:34,320 --> 00:08:37,500
um mainly because uh it it generated so

214
00:08:37,500 --> 00:08:39,659
much attention that everyone was hunting

215
00:08:39,659 --> 00:08:42,479
for it and most of the stuff that are

216
00:08:42,479 --> 00:08:45,240
affected by these vanilla so-called OG

217
00:08:45,240 --> 00:08:48,300
vectors are already patched

218
00:08:48,300 --> 00:08:49,500
um but that's not to say that there

219
00:08:49,500 --> 00:08:52,260
aren't any more um request marketing

220
00:08:52,260 --> 00:08:55,440
factors that we can discover so that's

221
00:08:55,440 --> 00:08:58,500
where uh this comes in so I I named this

222
00:08:58,500 --> 00:09:01,080
top um the Multiverse of passing flowers

223
00:09:01,080 --> 00:09:03,600
because it really seems to me that um

224
00:09:03,600 --> 00:09:05,459
there are a million and one ways where

225
00:09:05,459 --> 00:09:08,640
this is where HTTP passing can go wrong

226
00:09:08,640 --> 00:09:10,920
um because of the fact that the rrc is

227
00:09:10,920 --> 00:09:13,320
is so it's it's up to him first of all

228
00:09:13,320 --> 00:09:16,019
it's there are a lot of process and if

229
00:09:16,019 --> 00:09:17,880
you want to implement it strictly to the

230
00:09:17,880 --> 00:09:20,279
IRC that takes a lot of effort and a lot

231
00:09:20,279 --> 00:09:22,140
of times you miss something out and also

232
00:09:22,140 --> 00:09:23,820
it sometimes some some stuff are up to

233
00:09:23,820 --> 00:09:27,260
interpretation as well it's it's

234
00:09:27,260 --> 00:09:30,120
English interpretation right so um if

235
00:09:30,120 --> 00:09:32,399
some of the process aren't very clear

236
00:09:32,399 --> 00:09:35,339
um that can cause some Mixels as well so

237
00:09:35,339 --> 00:09:37,500
first of all some observations

238
00:09:37,500 --> 00:09:39,240
um there are a lot of research that is

239
00:09:39,240 --> 00:09:41,279
being done on the proxies like um nginx

240
00:09:41,279 --> 00:09:43,740
and Apache Ruby

241
00:09:43,740 --> 00:09:47,519
um KJ proxy to name a few so these so I

242
00:09:47,519 --> 00:09:49,080
I also noticed that the relative

243
00:09:49,080 --> 00:09:52,320
security against request mugging in the

244
00:09:52,320 --> 00:09:54,839
proxy servers versus like the actual web

245
00:09:54,839 --> 00:09:56,339
servers so for web servers what I'm

246
00:09:56,339 --> 00:09:58,080
referring to is things like

247
00:09:58,080 --> 00:10:01,800
um for example python runs um G unicorn

248
00:10:01,800 --> 00:10:05,339
um the node.js has its built-in hdb

249
00:10:05,339 --> 00:10:07,620
server um golang has a built-in hdb

250
00:10:07,620 --> 00:10:09,180
server as well

251
00:10:09,180 --> 00:10:11,339
um so these are like the the backend

252
00:10:11,339 --> 00:10:13,200
servers that the front end proxies

253
00:10:13,200 --> 00:10:15,300
actually route the request to so not a

254
00:10:15,300 --> 00:10:17,220
lot of research has been done on the

255
00:10:17,220 --> 00:10:19,200
backend server so but if you think about

256
00:10:19,200 --> 00:10:19,980
it

257
00:10:19,980 --> 00:10:22,860
um this vulnerability class actually

258
00:10:22,860 --> 00:10:26,580
depends on both the front end proxy and

259
00:10:26,580 --> 00:10:28,740
the back-end server agreeing on how to

260
00:10:28,740 --> 00:10:31,920
pass the HTTP request so as long as one

261
00:10:31,920 --> 00:10:34,860
of them is vulnerable then the whole

262
00:10:34,860 --> 00:10:36,660
setup is vulnerable and most of the

263
00:10:36,660 --> 00:10:38,339
times it actually takes

264
00:10:38,339 --> 00:10:40,640
um both of them to be vulnerable so

265
00:10:40,640 --> 00:10:43,260
sometimes it is also a bit difficult to

266
00:10:43,260 --> 00:10:45,180
show in show impact on this

267
00:10:45,180 --> 00:10:47,279
vulnerability class because of the fact

268
00:10:47,279 --> 00:10:49,620
that if you are just looking into one

269
00:10:49,620 --> 00:10:51,240
part of the equation like either the

270
00:10:51,240 --> 00:10:53,399
final proxy or the backend server

271
00:10:53,399 --> 00:10:55,140
um you actually have to qualify the

272
00:10:55,140 --> 00:10:56,640
impact by saying oh actually this

273
00:10:56,640 --> 00:10:58,440
requires this specific condition to be

274
00:10:58,440 --> 00:11:01,019
met on the other server in order for

275
00:11:01,019 --> 00:11:02,399
this whole setup to be vulnerable to

276
00:11:02,399 --> 00:11:04,800
replace marketing but it is not to say

277
00:11:04,800 --> 00:11:07,920
that then it doesn't mean that it's not

278
00:11:07,920 --> 00:11:09,779
a vulnerability because

279
00:11:09,779 --> 00:11:11,760
um I mean time and time again we see

280
00:11:11,760 --> 00:11:15,180
that uh we see that both the front end

281
00:11:15,180 --> 00:11:16,980
proxy and the back-end server

282
00:11:16,980 --> 00:11:18,540
um actually suffer from a vulnerability

283
00:11:18,540 --> 00:11:20,399
and and that causes

284
00:11:20,399 --> 00:11:24,000
um a lot of a lot of high impact bugs so

285
00:11:24,000 --> 00:11:26,579
most traditional in techniques um which

286
00:11:26,579 --> 00:11:29,160
I have covered one of them earlier have

287
00:11:29,160 --> 00:11:31,680
been etched so traditional meaning that

288
00:11:31,680 --> 00:11:34,380
well it is widely taught and widely

289
00:11:34,380 --> 00:11:36,720
publicized online and so most people

290
00:11:36,720 --> 00:11:39,720
would have founded or patched it but

291
00:11:39,720 --> 00:11:41,339
vulnerabilities can still arise due to

292
00:11:41,339 --> 00:11:43,019
subtle deviation so in the standard so

293
00:11:43,019 --> 00:11:45,000
later on we will see that actually

294
00:11:45,000 --> 00:11:46,800
um a lot of the the things that I'll be

295
00:11:46,800 --> 00:11:48,779
sharing is it's not not uh it's it's

296
00:11:48,779 --> 00:11:51,180
it's not super complicated it's just a

297
00:11:51,180 --> 00:11:52,680
very subtle deviation from the standard

298
00:11:52,680 --> 00:11:54,180
that can cause

299
00:11:54,180 --> 00:11:57,839
um different servers to pass us the same

300
00:11:57,839 --> 00:12:00,300
HTTP request differently

301
00:12:00,300 --> 00:12:02,820
so um if I mean this is more for the

302
00:12:02,820 --> 00:12:04,260
maintainer so when you doubt to

303
00:12:04,260 --> 00:12:06,000
implement all must and shoot process in

304
00:12:06,000 --> 00:12:07,800
the RFC

305
00:12:07,800 --> 00:12:09,480
so the first one we are going to start

306
00:12:09,480 --> 00:12:11,940
off with uh generally quite quite uh

307
00:12:11,940 --> 00:12:14,760
quite simple vulnerabilities is that

308
00:12:14,760 --> 00:12:16,860
um when you look at the RFC the rrc

309
00:12:16,860 --> 00:12:19,380
states that the content length can be um

310
00:12:19,380 --> 00:12:23,640
a a sequence of digits right and because

311
00:12:23,640 --> 00:12:26,880
the RC is is uh it speaks in ABN F

312
00:12:26,880 --> 00:12:28,920
standard a digit consists of should be

313
00:12:28,920 --> 00:12:30,600
zero to nine only

314
00:12:30,600 --> 00:12:32,040
um but some passes will accept strings

315
00:12:32,040 --> 00:12:33,420
that are not strictly digits simply

316
00:12:33,420 --> 00:12:37,440
because of um uh Lex regex or

317
00:12:37,440 --> 00:12:39,420
um because of the specific

318
00:12:39,420 --> 00:12:42,540
um programming language implementation

319
00:12:42,540 --> 00:12:44,880
so for example if if you so for example

320
00:12:44,880 --> 00:12:46,800
this is something that I found of you if

321
00:12:46,800 --> 00:12:49,380
you put a plus sign to the front of the

322
00:12:49,380 --> 00:12:51,060
of the content length actually a partial

323
00:12:51,060 --> 00:12:53,220
traffic server ends up ignoring the

324
00:12:53,220 --> 00:12:54,779
invalid content length in a previous

325
00:12:54,779 --> 00:12:56,279
version

326
00:12:56,279 --> 00:12:58,019
um and so if you are looking at this

327
00:12:58,019 --> 00:13:01,560
request um plus 23 is is not it's not

328
00:13:01,560 --> 00:13:04,740
strictly Allowed by the rrc and and so

329
00:13:04,740 --> 00:13:06,540
Apache traffic server actually ignores

330
00:13:06,540 --> 00:13:10,440
this but if you were to ignore that then

331
00:13:10,440 --> 00:13:12,000
that means that well there are two

332
00:13:12,000 --> 00:13:14,519
requests right so

333
00:13:14,519 --> 00:13:17,040
when these two repairs get to the

334
00:13:17,040 --> 00:13:19,320
backend server uh waitress actually

335
00:13:19,320 --> 00:13:22,139
passes the invalid content line feather

336
00:13:22,139 --> 00:13:24,779
um splitting the request into two so

337
00:13:24,779 --> 00:13:28,019
class 23 um if you if you count 23 bytes

338
00:13:28,019 --> 00:13:31,399
it goes up until here dummy and then

339
00:13:31,399 --> 00:13:34,139
instead of seeing two requests to the to

340
00:13:34,139 --> 00:13:35,579
the root URL

341
00:13:35,579 --> 00:13:37,139
um there's actually now one request to

342
00:13:37,139 --> 00:13:39,300
the root yeah and one request to slash

343
00:13:39,300 --> 00:13:41,519
forbidden so

344
00:13:41,519 --> 00:13:43,560
um this is very important to to note

345
00:13:43,560 --> 00:13:47,279
that actually if if waitress were to

346
00:13:47,279 --> 00:13:49,260
actually reject this

347
00:13:49,260 --> 00:13:51,839
um by or even to ignore it even though

348
00:13:51,839 --> 00:13:54,600
ignoring it is also against the RFC

349
00:13:54,600 --> 00:13:57,420
implementation but if Richard to reject

350
00:13:57,420 --> 00:13:59,339
that then this wouldn't happen so

351
00:13:59,339 --> 00:14:01,500
although we could spin the blame and say

352
00:14:01,500 --> 00:14:03,839
oh either a passage traffic server or

353
00:14:03,839 --> 00:14:07,139
waitress which is a python web server is

354
00:14:07,139 --> 00:14:10,200
is is that for here actually well I mean

355
00:14:10,200 --> 00:14:12,779
it's it's both of them right so again

356
00:14:12,779 --> 00:14:15,120
this makes it a bit difficult to to say

357
00:14:15,120 --> 00:14:17,040
that oh and sometimes when you're when

358
00:14:17,040 --> 00:14:19,320
you're when you are um I face this for

359
00:14:19,320 --> 00:14:21,420
myself when I'm trying to

360
00:14:21,420 --> 00:14:23,399
um disclose so if if I'm trying to

361
00:14:23,399 --> 00:14:26,040
disclose to ATS I can say that oh

362
00:14:26,040 --> 00:14:28,079
actually uh if you use your Apache

363
00:14:28,079 --> 00:14:30,720
traffic server together with waitress

364
00:14:30,720 --> 00:14:33,060
um then this can happen but then it

365
00:14:33,060 --> 00:14:34,800
would be kind of uh it would be kind of

366
00:14:34,800 --> 00:14:36,839
bad to say that oh actually I found

367
00:14:36,839 --> 00:14:38,880
something in races that isn't this close

368
00:14:38,880 --> 00:14:41,100
yet and and then I disclose that to the

369
00:14:41,100 --> 00:14:43,320
Apache traffic server team or a vice

370
00:14:43,320 --> 00:14:46,079
versa right so so that that kind of

371
00:14:46,079 --> 00:14:48,180
problem can arise as well

372
00:14:48,180 --> 00:14:49,980
so

373
00:14:49,980 --> 00:14:52,019
um again something that is a bit also

374
00:14:52,019 --> 00:14:53,940
interesting is that negative values

375
00:14:53,940 --> 00:14:56,519
result in weird Behavior as well so if

376
00:14:56,519 --> 00:14:58,139
you think about it it's not that weird

377
00:14:58,139 --> 00:14:59,220
because

378
00:14:59,220 --> 00:15:00,779
um if you are just using like negative

379
00:15:00,779 --> 00:15:02,699
indexing on the body

380
00:15:02,699 --> 00:15:04,800
um this will achieve the same result so

381
00:15:04,800 --> 00:15:06,660
on Twitter web which is another python

382
00:15:06,660 --> 00:15:09,000
python web server

383
00:15:09,000 --> 00:15:12,120
um this actually work and I will show it

384
00:15:12,120 --> 00:15:15,000
in the next slide so

385
00:15:15,000 --> 00:15:16,800
um this is the original request that is

386
00:15:16,800 --> 00:15:18,839
being sent to the

387
00:15:18,839 --> 00:15:20,820
um that is being sent to the server and

388
00:15:20,820 --> 00:15:23,760
you have a negative 31 content length so

389
00:15:23,760 --> 00:15:27,060
if you are counting from the back uh by

390
00:15:27,060 --> 00:15:30,480
negative indexing negative 31 would end

391
00:15:30,480 --> 00:15:33,540
right before the the get slash forbidden

392
00:15:33,540 --> 00:15:34,260
here

393
00:15:34,260 --> 00:15:37,740
and when that gets to the server um it

394
00:15:37,740 --> 00:15:38,699
will actually

395
00:15:38,699 --> 00:15:40,860
end up processing a negative 31 front

396
00:15:40,860 --> 00:15:42,420
end length and process this request

397
00:15:42,420 --> 00:15:46,380
first so it sees that okay there is one

398
00:15:46,380 --> 00:15:48,779
request to the root URL and then this

399
00:15:48,779 --> 00:15:49,680
one

400
00:15:49,680 --> 00:15:52,139
um because because it is not yet

401
00:15:52,139 --> 00:15:56,100
complete so um we know that for a hdb

402
00:15:56,100 --> 00:15:58,920
request to be completed it requires two

403
00:15:58,920 --> 00:16:01,680
new lines at the end right so so new

404
00:16:01,680 --> 00:16:04,320
line new line but for here because it's

405
00:16:04,320 --> 00:16:06,420
left hanging this is like a request that

406
00:16:06,420 --> 00:16:08,579
is like left hanging and the server will

407
00:16:08,579 --> 00:16:10,560
continue waiting for the rest of the

408
00:16:10,560 --> 00:16:12,240
request to come in maybe there's a

409
00:16:12,240 --> 00:16:14,040
network delay Etc

410
00:16:14,040 --> 00:16:16,260
um but of course here we we deliberately

411
00:16:16,260 --> 00:16:17,940
introduce it

412
00:16:17,940 --> 00:16:19,920
and we deliver we deliberately

413
00:16:19,920 --> 00:16:23,459
introduced the next uh next request

414
00:16:23,459 --> 00:16:25,860
to the to the to the front end proxy and

415
00:16:25,860 --> 00:16:27,300
then

416
00:16:27,300 --> 00:16:29,040
the buffered content is actually

417
00:16:29,040 --> 00:16:32,459
injected uh so the the buffer content is

418
00:16:32,459 --> 00:16:34,680
is the is the part that we cut out with

419
00:16:34,680 --> 00:16:36,240
the negative content length earlier on

420
00:16:36,240 --> 00:16:39,600
so this part is actually buffered um by

421
00:16:39,600 --> 00:16:42,660
Twisted and then when the next request

422
00:16:42,660 --> 00:16:44,639
comes in this this gets added to the end

423
00:16:44,639 --> 00:16:47,160
of the buffered content so this forms

424
00:16:47,160 --> 00:16:50,959
like the the next request

425
00:16:52,079 --> 00:16:54,899
so similar issues can also arise in

426
00:16:54,899 --> 00:16:56,519
chunk size passing so if you are looking

427
00:16:56,519 --> 00:16:58,199
at this request

428
00:16:58,199 --> 00:16:59,940
um transfer encoding chart the format

429
00:16:59,940 --> 00:17:02,040
for chunk request is that

430
00:17:02,040 --> 00:17:04,559
um you must have a hexadecimal number

431
00:17:04,559 --> 00:17:07,980
here which integrate which which means

432
00:17:07,980 --> 00:17:10,400
the chunk size so if you have

433
00:17:10,400 --> 00:17:13,020
0x12 actually that means that you will

434
00:17:13,020 --> 00:17:16,919
have um hex one two hex 12 bytes

435
00:17:16,919 --> 00:17:18,780
um which is which covers this green

436
00:17:18,780 --> 00:17:21,839
portion here but you are not supposed to

437
00:17:21,839 --> 00:17:24,540
have the zero X prefix at the front so

438
00:17:24,540 --> 00:17:27,780
if you if you are if you are like some

439
00:17:27,780 --> 00:17:30,000
programming languages like like Ruby for

440
00:17:30,000 --> 00:17:33,000
example if you are using the two two I

441
00:17:33,000 --> 00:17:36,000
function which is the function to to

442
00:17:36,000 --> 00:17:38,160
convert strings to integers actually

443
00:17:38,160 --> 00:17:41,220
that would stop passing the integer at

444
00:17:41,220 --> 00:17:44,640
the first invalid digit so if you are

445
00:17:44,640 --> 00:17:47,880
looking at this 0x12

446
00:17:47,880 --> 00:17:50,820
um it will actually stop at this x here

447
00:17:50,820 --> 00:17:52,440
which means that

448
00:17:52,440 --> 00:17:56,160
from the perspective of the parser this

449
00:17:56,160 --> 00:17:58,799
actually is the same as just zero right

450
00:17:58,799 --> 00:18:03,120
so if it's zero and because zero is it

451
00:18:03,120 --> 00:18:05,280
means that it's the end of the end of

452
00:18:05,280 --> 00:18:07,679
the chunk request for um transferring 20

453
00:18:07,679 --> 00:18:10,440
jump if you interpret zero that means

454
00:18:10,440 --> 00:18:11,460
that this is the end of the first

455
00:18:11,460 --> 00:18:13,679
request and then

456
00:18:13,679 --> 00:18:16,320
the next request starts uh with the

457
00:18:16,320 --> 00:18:19,140
green portion and you essentially manage

458
00:18:19,140 --> 00:18:21,600
to split the request into two

459
00:18:21,600 --> 00:18:23,580
so this is the case when you abort when

460
00:18:23,580 --> 00:18:26,580
encountering an embedded text character

461
00:18:26,580 --> 00:18:29,160
but if you accept the Xerox prefix then

462
00:18:29,160 --> 00:18:31,200
this is the behavior in other languages

463
00:18:31,200 --> 00:18:34,380
like like python for example then Xerox

464
00:18:34,380 --> 00:18:36,539
shelf will become well the correct value

465
00:18:36,539 --> 00:18:39,000
of 18 and this would

466
00:18:39,000 --> 00:18:40,980
um mean that this

467
00:18:40,980 --> 00:18:43,500
get this second get request is part of

468
00:18:43,500 --> 00:18:47,520
the first request body and so this would

469
00:18:47,520 --> 00:18:50,820
be one who repairs by itself

470
00:18:50,820 --> 00:18:52,620
so

471
00:18:52,620 --> 00:18:54,600
this is a summary

472
00:18:54,600 --> 00:18:56,580
um you can see that actually the the

473
00:18:56,580 --> 00:18:59,039
language specific implementations play A

474
00:18:59,039 --> 00:19:01,380
Part as well so for example

475
00:19:01,380 --> 00:19:03,600
um we are discussing rubies to I

476
00:19:03,600 --> 00:19:05,039
function for example it's actually quite

477
00:19:05,039 --> 00:19:07,740
interesting because if you put uh in

478
00:19:07,740 --> 00:19:09,900
Puma actually which when I was testing

479
00:19:09,900 --> 00:19:11,820
it out actually if you put content

480
00:19:11,820 --> 00:19:14,820
length like ABC it actually becomes zero

481
00:19:14,820 --> 00:19:16,799
as well so although that doesn't really

482
00:19:16,799 --> 00:19:18,299
have that much of an impact right itself

483
00:19:18,299 --> 00:19:20,400
it actually is quite interesting because

484
00:19:20,400 --> 00:19:23,820
it just passes until the first invalid

485
00:19:23,820 --> 00:19:25,740
character and if

486
00:19:25,740 --> 00:19:28,500
um it's just like 99 Balloons the first

487
00:19:28,500 --> 00:19:31,620
embedded character is B and that uh

488
00:19:31,620 --> 00:19:35,880
becomes 99. so at any number of invalid

489
00:19:35,880 --> 00:19:37,500
um content length for or transfer

490
00:19:37,500 --> 00:19:39,059
including chunk sizes is actually

491
00:19:39,059 --> 00:19:43,020
integrated as valid numbers by Puma

492
00:19:43,020 --> 00:19:46,980
which is the ruby red web server

493
00:19:46,980 --> 00:19:48,539
so

494
00:19:48,539 --> 00:19:50,400
um and for the python ones is also is

495
00:19:50,400 --> 00:19:52,020
also quite expected as well because for

496
00:19:52,020 --> 00:19:54,780
python if you use int the int uh

497
00:19:54,780 --> 00:19:56,700
function to convert a string to integer

498
00:19:56,700 --> 00:19:58,980
actually accepts it accepts the plus and

499
00:19:58,980 --> 00:20:01,440
minus signs right and also it accepts

500
00:20:01,440 --> 00:20:04,520
the zero X prefix

501
00:20:06,419 --> 00:20:09,900
okay so next um is white space so white

502
00:20:09,900 --> 00:20:12,240
space is more than 0x20 so um if you're

503
00:20:12,240 --> 00:20:13,799
not familiar with

504
00:20:13,799 --> 00:20:16,860
um 0x20 is is the is the ASCII code for

505
00:20:16,860 --> 00:20:19,620
the space character right but in this

506
00:20:19,620 --> 00:20:21,600
case uh when we are looking at the RFC

507
00:20:21,600 --> 00:20:23,640
the RC states that okay for the header

508
00:20:23,640 --> 00:20:25,559
field you can have the field name

509
00:20:25,559 --> 00:20:27,240
followed by a colon

510
00:20:27,240 --> 00:20:30,480
and there is optional white space before

511
00:20:30,480 --> 00:20:32,580
and after the field values

512
00:20:32,580 --> 00:20:34,740
but the optional white space consists of

513
00:20:34,740 --> 00:20:38,100
space and horizontal tab only so space

514
00:20:38,100 --> 00:20:42,140
bar and the the well tab right so but

515
00:20:42,140 --> 00:20:44,820
passwords actually use often use generic

516
00:20:44,820 --> 00:20:46,200
shipping functions that removes any

517
00:20:46,200 --> 00:20:49,140
white space right so if you have a proxy

518
00:20:49,140 --> 00:20:50,820
and a server that implements the white

519
00:20:50,820 --> 00:20:52,919
space passing differently

520
00:20:52,919 --> 00:20:54,960
um one of them might or might should be

521
00:20:54,960 --> 00:20:56,940
adhere to the RSC on only strip space

522
00:20:56,940 --> 00:21:00,120
and tabs but another one might say oh

523
00:21:00,120 --> 00:21:03,600
actually uh anything from from from any

524
00:21:03,600 --> 00:21:07,140
of the non-printable hex characters from

525
00:21:07,140 --> 00:21:10,020
um 0 to 0x20 is actually white space

526
00:21:10,020 --> 00:21:12,720
then that causes the problem as well

527
00:21:12,720 --> 00:21:14,820
um for example like like a new line is

528
00:21:14,820 --> 00:21:16,320
that a white space or the carriage

529
00:21:16,320 --> 00:21:18,240
return is there a white space if you are

530
00:21:18,240 --> 00:21:20,720
using like most programming languages

531
00:21:20,720 --> 00:21:23,520
that offer us generic stripping function

532
00:21:23,520 --> 00:21:24,900
on strings

533
00:21:24,900 --> 00:21:26,460
um then things like new line and

534
00:21:26,460 --> 00:21:28,320
carriage return are white space

535
00:21:28,320 --> 00:21:31,380
so for example if you have a transfer

536
00:21:31,380 --> 00:21:33,299
encoding jumped

537
00:21:33,299 --> 00:21:36,240
um and you have a carriage return at the

538
00:21:36,240 --> 00:21:38,400
at the start of of this of this request

539
00:21:38,400 --> 00:21:40,260
header

540
00:21:40,260 --> 00:21:42,419
um you might or might not interpret this

541
00:21:42,419 --> 00:21:46,320
as as a valid value right so the proxy

542
00:21:46,320 --> 00:21:48,780
ignores the transfer encoding value

543
00:21:48,780 --> 00:21:50,960
um because it is an invalid value right

544
00:21:50,960 --> 00:21:54,600
but then when and and and because of

545
00:21:54,600 --> 00:21:57,419
that uh the second request actually is

546
00:21:57,419 --> 00:22:00,000
the request and then it includes a 23

547
00:22:00,000 --> 00:22:01,260
byte body

548
00:22:01,260 --> 00:22:05,179
um including this get slash admin

549
00:22:06,360 --> 00:22:10,020
but then your server when this when this

550
00:22:10,020 --> 00:22:13,740
request gets uh sent to the server the

551
00:22:13,740 --> 00:22:16,020
server actually sees this and okay I'm

552
00:22:16,020 --> 00:22:17,940
gonna strip the white space so I'm gonna

553
00:22:17,940 --> 00:22:19,200
shift the white space and then you call

554
00:22:19,200 --> 00:22:20,760
the shipping function and then this

555
00:22:20,760 --> 00:22:23,159
carriage return gets stripped so it just

556
00:22:23,159 --> 00:22:24,600
becomes Trump right so the server

557
00:22:24,600 --> 00:22:26,100
interprets this request as a chunk

558
00:22:26,100 --> 00:22:27,120
request

559
00:22:27,120 --> 00:22:30,120
and then the delete the deleted request

560
00:22:30,120 --> 00:22:31,860
well this is interesting

561
00:22:31,860 --> 00:22:35,280
um so 0xde uh is the first two

562
00:22:35,280 --> 00:22:38,400
characters the first two uh valid hex

563
00:22:38,400 --> 00:22:40,260
characters so if you look at the very

564
00:22:40,260 --> 00:22:42,480
next one L is is not valid anymore so

565
00:22:42,480 --> 00:22:44,880
0xd is the first to valid hex character

566
00:22:44,880 --> 00:22:47,039
so if you are passing the hex value

567
00:22:47,039 --> 00:22:50,100
um you end up passing 0xde and then you

568
00:22:50,100 --> 00:22:52,860
can just Pat the request until you have

569
00:22:52,860 --> 00:22:54,480
um 0xde

570
00:22:54,480 --> 00:22:58,860
and then your your essentially

571
00:22:58,860 --> 00:23:02,760
uh yeah so this becomes like a second

572
00:23:02,760 --> 00:23:05,100
request to slash admin because you are

573
00:23:05,100 --> 00:23:07,080
you are passing Xerox you are you are

574
00:23:07,080 --> 00:23:09,780
interpreting this as part of the request

575
00:23:09,780 --> 00:23:13,200
body for the Post request and then 0xd

576
00:23:13,200 --> 00:23:15,780
you can pad until your request and until

577
00:23:15,780 --> 00:23:18,480
your your your this delete request is is

578
00:23:18,480 --> 00:23:21,320
that many bytes

579
00:23:22,679 --> 00:23:25,799
so uh this is a there are there are a

580
00:23:25,799 --> 00:23:27,179
variety of ways that this can go around

581
00:23:27,179 --> 00:23:29,340
so for example for Apache traffic server

582
00:23:29,340 --> 00:23:30,360
you have

583
00:23:30,360 --> 00:23:33,659
um 0b so this one uh this one in

584
00:23:33,659 --> 00:23:35,159
particular this one was this one can be

585
00:23:35,159 --> 00:23:37,140
used in combination with

586
00:23:37,140 --> 00:23:39,539
um G unicorn and an older version of G

587
00:23:39,539 --> 00:23:41,340
unicorn as well that essentially just

588
00:23:41,340 --> 00:23:42,480
stripped

589
00:23:42,480 --> 00:23:43,559
um this is

590
00:23:43,559 --> 00:23:44,600
um this

591
00:23:44,600 --> 00:23:47,880
invalid white space in the content line

592
00:23:47,880 --> 00:23:49,260
Trader and then it interprets this

593
00:23:49,260 --> 00:23:51,720
containing feather so the the behavior

594
00:23:51,720 --> 00:23:53,820
even if you are set the the the the

595
00:23:53,820 --> 00:23:55,799
invaluable space the behavior can vary

596
00:23:55,799 --> 00:23:57,600
so for example for a partial traffic

597
00:23:57,600 --> 00:23:58,679
server

598
00:23:58,679 --> 00:24:01,679
um this it although it accepts this but

599
00:24:01,679 --> 00:24:04,320
the content length header is not

600
00:24:04,320 --> 00:24:06,600
um considered the same as the containing

601
00:24:06,600 --> 00:24:08,220
feather that determines the request body

602
00:24:08,220 --> 00:24:11,280
size so it is interpreted as literally

603
00:24:11,280 --> 00:24:14,100
content length then 0x0b this is the

604
00:24:14,100 --> 00:24:16,320
literal string

605
00:24:16,320 --> 00:24:18,240
um but then if you use the the backend

606
00:24:18,240 --> 00:24:20,340
server as Geo Nikon then G unicorn will

607
00:24:20,340 --> 00:24:22,320
ship this um invalid white space and

608
00:24:22,320 --> 00:24:23,880
just say that okay this is content

609
00:24:23,880 --> 00:24:26,700
length and the content length is zero

610
00:24:26,700 --> 00:24:28,320
um MIT and proxy

611
00:24:28,320 --> 00:24:30,179
um a space before the colon this one was

612
00:24:30,179 --> 00:24:32,940
was actually quite common as well but

613
00:24:32,940 --> 00:24:35,700
um this I mean I think last year this

614
00:24:35,700 --> 00:24:37,980
one was was quite common as well and and

615
00:24:37,980 --> 00:24:40,799
I I think most of the most of those that

616
00:24:40,799 --> 00:24:42,600
have been patched would have patched

617
00:24:42,600 --> 00:24:44,220
this

618
00:24:44,220 --> 00:24:47,940
um for golang you have also the the case

619
00:24:47,940 --> 00:24:50,100
that I discovered that I uh discussed

620
00:24:50,100 --> 00:24:52,799
earlier you have the carriage return

621
00:24:52,799 --> 00:24:55,559
before the the before the chunk value in

622
00:24:55,559 --> 00:24:58,760
the transfer encoding header

623
00:25:00,299 --> 00:25:02,880
uh for transfer encoding headers this is

624
00:25:02,880 --> 00:25:04,440
actually quite interesting because of

625
00:25:04,440 --> 00:25:06,900
the just how many ways that you can

626
00:25:06,900 --> 00:25:09,600
actually how many ways that transfer

627
00:25:09,600 --> 00:25:12,600
encoding headers can vary so also the

628
00:25:12,600 --> 00:25:16,200
the the the RFC on this is also a bit a

629
00:25:16,200 --> 00:25:18,179
bit confusing so let's break this down

630
00:25:18,179 --> 00:25:20,460
if the transfer encoding interview is

631
00:25:20,460 --> 00:25:23,159
present in a request and the chunk

632
00:25:23,159 --> 00:25:26,400
coding is not the final encoding then

633
00:25:26,400 --> 00:25:28,679
the server must respond with the 400

634
00:25:28,679 --> 00:25:30,960
battery requests so this is the most

635
00:25:30,960 --> 00:25:34,140
this is the this is RFC 7230 the most

636
00:25:34,140 --> 00:25:36,960
updated version actually in a previous

637
00:25:36,960 --> 00:25:41,279
uh IRC rc2616

638
00:25:41,460 --> 00:25:45,000
um there is a another valid transfer

639
00:25:45,000 --> 00:25:48,120
encoding which is identity so uh we will

640
00:25:48,120 --> 00:25:49,380
discuss this data but essentially

641
00:25:49,380 --> 00:25:52,260
essentially this is now deprecated in in

642
00:25:52,260 --> 00:25:55,679
the latest IRC version

643
00:25:55,679 --> 00:25:57,419
and

644
00:25:57,419 --> 00:25:59,340
another part we must understand is that

645
00:25:59,340 --> 00:26:01,020
transfer encodings are actually

646
00:26:01,020 --> 00:26:02,640
are actually interpreted From First to

647
00:26:02,640 --> 00:26:04,200
Last so if you have a transferring if

648
00:26:04,200 --> 00:26:05,820
you have a value like transfer encoding

649
00:26:05,820 --> 00:26:09,419
colon gz chunk it means that the request

650
00:26:09,419 --> 00:26:11,880
is chunked and then after you decode the

651
00:26:11,880 --> 00:26:14,520
chunk request the content is in gz

652
00:26:14,520 --> 00:26:15,900
format

653
00:26:15,900 --> 00:26:18,659
so in this sense the that's why the

654
00:26:18,659 --> 00:26:20,159
chunk must be the final including

655
00:26:20,159 --> 00:26:22,200
because it is it is sequential right

656
00:26:22,200 --> 00:26:24,059
there is gzip and then you have chunk

657
00:26:24,059 --> 00:26:25,679
and then you forward the request so

658
00:26:25,679 --> 00:26:27,419
Chang must always be the final encoding

659
00:26:27,419 --> 00:26:31,140
in a HTTP request

660
00:26:31,140 --> 00:26:32,520
so

661
00:26:32,520 --> 00:26:36,000
in the deprecated encoding identity just

662
00:26:36,000 --> 00:26:38,159
means to tell the recipient to do

663
00:26:38,159 --> 00:26:39,120
nothing

664
00:26:39,120 --> 00:26:41,760
uh identity means that there is no

665
00:26:41,760 --> 00:26:43,860
transformation applied on the request

666
00:26:43,860 --> 00:26:46,620
body at all and you just do nothing

667
00:26:46,620 --> 00:26:49,260
so when passing transfer encoding

668
00:26:49,260 --> 00:26:52,740
uh Puma assumes chunk as long as any of

669
00:26:52,740 --> 00:26:54,240
the transfer encoding values is charged

670
00:26:54,240 --> 00:26:56,159
so

671
00:26:56,159 --> 00:26:59,340
it sees this chunk as the first value

672
00:26:59,340 --> 00:27:02,279
and it it just says that okay this whole

673
00:27:02,279 --> 00:27:03,840
HTTP request

674
00:27:03,840 --> 00:27:07,980
um is chunked but as we can see if we

675
00:27:07,980 --> 00:27:10,020
are going strictly by

676
00:27:10,020 --> 00:27:12,419
um first to last well the last

677
00:27:12,419 --> 00:27:14,220
transformation is actually identity

678
00:27:14,220 --> 00:27:18,600
which means that uh a proxy server that

679
00:27:18,600 --> 00:27:20,400
supports the identity and coding would

680
00:27:20,400 --> 00:27:22,620
actually say that no this this request

681
00:27:22,620 --> 00:27:23,760
is

682
00:27:23,760 --> 00:27:26,700
um not chunked it is just identity which

683
00:27:26,700 --> 00:27:31,860
means do nothing and then it becomes uh

684
00:27:31,860 --> 00:27:34,559
yeah you have a lot of problems because

685
00:27:34,559 --> 00:27:37,020
now now one system wants his identity

686
00:27:37,020 --> 00:27:40,760
and then that causes the best Market

687
00:27:41,460 --> 00:27:43,740
so football also silently ignore any

688
00:27:43,740 --> 00:27:46,500
invalid transfer encoding value so this

689
00:27:46,500 --> 00:27:49,740
specific specific one again is uh in a

690
00:27:49,740 --> 00:27:51,600
partial traffic server where a partial

691
00:27:51,600 --> 00:27:55,020
traffic services that uh I mean it's

692
00:27:55,020 --> 00:27:57,419
quite weird where you have a you have a

693
00:27:57,419 --> 00:27:59,520
double quote and then the chunk value

694
00:27:59,520 --> 00:28:01,140
within the double quote is actually

695
00:28:01,140 --> 00:28:02,640
interpreted as

696
00:28:02,640 --> 00:28:04,380
well transferring coding count right

697
00:28:04,380 --> 00:28:07,080
interprets this as a chunk request

698
00:28:07,080 --> 00:28:09,360
but when it gets forwarded to the

699
00:28:09,360 --> 00:28:11,520
backend server Puma would say

700
00:28:11,520 --> 00:28:13,799
um this is I don't see any Chunk in this

701
00:28:13,799 --> 00:28:16,980
value I'm not gonna accept this and

702
00:28:16,980 --> 00:28:19,140
therefore I'm going to just ignore the

703
00:28:19,140 --> 00:28:22,980
entire transfer encoding um header

704
00:28:22,980 --> 00:28:26,279
so the the correct thing to do here

705
00:28:26,279 --> 00:28:28,559
um apart from the proxy

706
00:28:28,559 --> 00:28:31,500
interpreting the correct version of

707
00:28:31,500 --> 00:28:34,020
transfer encoding chunk is also for the

708
00:28:34,020 --> 00:28:36,960
back-end server to reject the request if

709
00:28:36,960 --> 00:28:40,200
the last encoding is not charged so in

710
00:28:40,200 --> 00:28:42,299
this case the the spec compliant

711
00:28:42,299 --> 00:28:46,940
Behavior would be for Puma to reject it

712
00:28:47,820 --> 00:28:50,580
um this uses similarly the same

713
00:28:50,580 --> 00:28:53,520
technique as discussed previously if you

714
00:28:53,520 --> 00:28:55,500
have Apache traffic server that accepts

715
00:28:55,500 --> 00:28:58,080
this as chunk

716
00:28:58,080 --> 00:29:00,539
um the post requests includes in 0xd by

717
00:29:00,539 --> 00:29:02,400
body

718
00:29:02,400 --> 00:29:05,220
and then you go to the backend server

719
00:29:05,220 --> 00:29:07,260
Puma actually silently ignores this

720
00:29:07,260 --> 00:29:09,840
invalid transfer encoding header and

721
00:29:09,840 --> 00:29:10,919
then

722
00:29:10,919 --> 00:29:13,200
the delete request is interpreted as a

723
00:29:13,200 --> 00:29:15,539
second separate request so we see here

724
00:29:15,539 --> 00:29:18,360
actually the delete request is part of

725
00:29:18,360 --> 00:29:20,880
the first request body because of the

726
00:29:20,880 --> 00:29:23,399
fact that uh this is a chunk request and

727
00:29:23,399 --> 00:29:24,260
then

728
00:29:24,260 --> 00:29:28,020
0xd is the content is the chunk size

729
00:29:28,020 --> 00:29:30,720
so this is a challenge that I wrote for

730
00:29:30,720 --> 00:29:33,299
my team's uh a city after my team was

731
00:29:33,299 --> 00:29:36,539
third earlier this year uh I think uh

732
00:29:36,539 --> 00:29:38,760
what one China team managed to solve it

733
00:29:38,760 --> 00:29:42,240
uh so it is a quite interesting Factor

734
00:29:42,240 --> 00:29:43,140
because

735
00:29:43,140 --> 00:29:45,120
um when I when I read about this uh

736
00:29:45,120 --> 00:29:47,760
Delete uh delete Vector I was actually

737
00:29:47,760 --> 00:29:49,380
quite quite

738
00:29:49,380 --> 00:29:52,700
um quite surprised that this will work

739
00:29:55,440 --> 00:29:59,820
um and this one was uh was uh was in

740
00:29:59,820 --> 00:30:03,360
node.js so the HTTP server in node.js

741
00:30:03,360 --> 00:30:03,960
um

742
00:30:03,960 --> 00:30:05,880
I'm going to bring up the the source

743
00:30:05,880 --> 00:30:08,159
code and the patch here because it is uh

744
00:30:08,159 --> 00:30:10,020
I think it is the best way to explain

745
00:30:10,020 --> 00:30:11,820
this so

746
00:30:11,820 --> 00:30:13,799
um in the previous version actually when

747
00:30:13,799 --> 00:30:15,539
you look at um

748
00:30:15,539 --> 00:30:18,179
when it looks at the transfer encoding

749
00:30:18,179 --> 00:30:20,399
value it met it tries to match the the

750
00:30:20,399 --> 00:30:23,220
chunk transfer encoding and then if it

751
00:30:23,220 --> 00:30:26,460
matches it will try to match the CRF

752
00:30:26,460 --> 00:30:27,899
sequence

753
00:30:27,899 --> 00:30:31,380
uh because it it assumes that okay if

754
00:30:31,380 --> 00:30:32,940
like

755
00:30:32,940 --> 00:30:36,179
if like chunk is the final encoding then

756
00:30:36,179 --> 00:30:38,820
I would expect to see the next character

757
00:30:38,820 --> 00:30:41,760
is the is the new line separator right

758
00:30:41,760 --> 00:30:44,880
so this is the end of the current line

759
00:30:44,880 --> 00:30:47,039
but if it doesn't manage to match the CR

760
00:30:47,039 --> 00:30:50,640
sequence then it tries to it's this is a

761
00:30:50,640 --> 00:30:53,640
bit weird here otherwise it will go back

762
00:30:53,640 --> 00:30:56,700
to matching the the chunk value and so

763
00:30:56,700 --> 00:30:59,399
because of that that gives rise to quite

764
00:30:59,399 --> 00:31:02,460
an interesting behavior in that chunk is

765
00:31:02,460 --> 00:31:06,179
a valid transfer encoding so then if you

766
00:31:06,179 --> 00:31:08,640
look at the patch um this is well this

767
00:31:08,640 --> 00:31:10,559
is the the correct way to pass it

768
00:31:10,559 --> 00:31:13,260
because if you don't reach the crl

769
00:31:13,260 --> 00:31:16,679
sequence then there can be another

770
00:31:16,679 --> 00:31:18,960
um transfer coding followed

771
00:31:18,960 --> 00:31:22,140
um following after the the the chunks

772
00:31:22,140 --> 00:31:24,360
that you match right so you are supposed

773
00:31:24,360 --> 00:31:27,179
to look for the comma and then after the

774
00:31:27,179 --> 00:31:29,159
comma you try to match

775
00:31:29,159 --> 00:31:32,520
um the transfer encoding value again

776
00:31:32,520 --> 00:31:35,299
foreign

777
00:31:35,399 --> 00:31:38,340
so this logic allows for Chung Chung to

778
00:31:38,340 --> 00:31:40,440
be a valid transfer encoding value for

779
00:31:40,440 --> 00:31:42,539
encoding as and as we can see earlier

780
00:31:42,539 --> 00:31:43,700
actually

781
00:31:43,700 --> 00:31:46,200
uh that there are behaviors where the

782
00:31:46,200 --> 00:31:47,580
Upstream proxy actually ignores

783
00:31:47,580 --> 00:31:50,159
malformed transferring coding values and

784
00:31:50,159 --> 00:31:52,260
then that gives tries to request marking

785
00:31:52,260 --> 00:31:54,059
so

786
00:31:54,059 --> 00:31:56,460
uh just summary Puma does not check that

787
00:31:56,460 --> 00:31:58,080
chunk is the final encoding it suddenly

788
00:31:58,080 --> 00:32:00,899
ignores invalid encodings on the node.js

789
00:32:00,899 --> 00:32:03,240
HTTP parcel assets malform encodings for

790
00:32:03,240 --> 00:32:05,419
example

791
00:32:05,760 --> 00:32:06,539
um

792
00:32:06,539 --> 00:32:11,220
so again this is a I mean you could say

793
00:32:11,220 --> 00:32:14,100
that or it's because the the finance

794
00:32:14,100 --> 00:32:16,620
proxy doesn't reject the this malformed

795
00:32:16,620 --> 00:32:20,039
transfer coding but uh as you would I

796
00:32:20,039 --> 00:32:22,080
mean if you if you if you just Google

797
00:32:22,080 --> 00:32:24,000
that then actually there are a lot of

798
00:32:24,000 --> 00:32:26,279
funny and proxies that up until very

799
00:32:26,279 --> 00:32:29,039
recently did not uh did not reject

800
00:32:29,039 --> 00:32:31,140
invalid transfer encodings and just

801
00:32:31,140 --> 00:32:33,179
silently ignores them

802
00:32:33,179 --> 00:32:35,700
um and I I'm pretty sure if you were not

803
00:32:35,700 --> 00:32:38,100
looking for it you might be able to find

804
00:32:38,100 --> 00:32:42,659
more but I I mean I didn't I didn't put

805
00:32:42,659 --> 00:32:45,620
that much time into it

806
00:32:46,260 --> 00:32:47,880
so

807
00:32:47,880 --> 00:32:50,880
another interesting feature of uh of the

808
00:32:50,880 --> 00:32:52,740
HTTP request is that

809
00:32:52,740 --> 00:32:53,460
um

810
00:32:53,460 --> 00:32:56,700
some actually most uh HTTP pastels will

811
00:32:56,700 --> 00:33:00,179
support this uh this thing called Ops 4

812
00:33:00,179 --> 00:33:02,340
which is a

813
00:33:02,340 --> 00:33:05,100
uh it it it says in the RSC that is

814
00:33:05,100 --> 00:33:08,520
deprecated but then also the RSC says

815
00:33:08,520 --> 00:33:10,980
that you can support it for backwards

816
00:33:10,980 --> 00:33:12,960
compatibility reasons

817
00:33:12,960 --> 00:33:15,600
a lot of persons still supported because

818
00:33:15,600 --> 00:33:18,059
of very compatibility reasons so

819
00:33:18,059 --> 00:33:19,620
actually you can actually have a

820
00:33:19,620 --> 00:33:21,179
multi-line Transit you can have a

821
00:33:21,179 --> 00:33:25,440
multi-line header in um hdb1 so how that

822
00:33:25,440 --> 00:33:28,260
works is that uh you have a field value

823
00:33:28,260 --> 00:33:31,019
than the field content and then you can

824
00:33:31,019 --> 00:33:35,700
have a crr sequence and then a space or

825
00:33:35,700 --> 00:33:37,679
a horizontal tab

826
00:33:37,679 --> 00:33:40,200
so if you are looking at this header

827
00:33:40,200 --> 00:33:42,600
value one comma then new line space

828
00:33:42,600 --> 00:33:45,840
value two this is equivalent to header

829
00:33:45,840 --> 00:33:49,580
value one comma space value 2.

830
00:33:49,740 --> 00:33:51,779
so you can see the RC says that actually

831
00:33:51,779 --> 00:33:55,080
you can either reject the message or if

832
00:33:55,080 --> 00:33:58,320
you support it you can replace the Box

833
00:33:58,320 --> 00:34:00,419
fold which is this which is this new

834
00:34:00,419 --> 00:34:03,779
line plus space with one or more space

835
00:34:03,779 --> 00:34:07,559
of text prior to interpreting the field

836
00:34:07,559 --> 00:34:09,239
value or forwarding to the message

837
00:34:09,239 --> 00:34:10,560
Downstream

838
00:34:10,560 --> 00:34:14,399
so in this case the the node.js passer

839
00:34:14,399 --> 00:34:15,960
actually attempted to support Ops folk

840
00:34:15,960 --> 00:34:17,940
while also making the assumption that

841
00:34:17,940 --> 00:34:19,619
the transfer encoding here that ends

842
00:34:19,619 --> 00:34:21,780
with the crr sequence

843
00:34:21,780 --> 00:34:23,940
so we saw earlier that uh in the earlier

844
00:34:23,940 --> 00:34:26,399
code it tries to match chunk and then

845
00:34:26,399 --> 00:34:28,139
ciof

846
00:34:28,139 --> 00:34:31,199
but that in itself is

847
00:34:31,199 --> 00:34:34,619
flawed because uh if you match chunk and

848
00:34:34,619 --> 00:34:36,960
then CRF then but then at the same time

849
00:34:36,960 --> 00:34:39,060
you also want to support Ops 4

850
00:34:39,060 --> 00:34:44,339
then actually a RC compliant parcel uh

851
00:34:44,339 --> 00:34:46,320
would actually say that this is actually

852
00:34:46,320 --> 00:34:49,379
actually identity right the transfer

853
00:34:49,379 --> 00:34:52,159
encoding is supposed to be identity but

854
00:34:52,159 --> 00:34:55,379
uh when it gets passed to the downstream

855
00:34:55,379 --> 00:34:57,180
node.js server

856
00:34:57,180 --> 00:34:58,680
um it would say that oh actually it's

857
00:34:58,680 --> 00:35:04,380
Charmed so this this is uh I mean

858
00:35:04,380 --> 00:35:06,180
it is it is it is something that that

859
00:35:06,180 --> 00:35:08,040
you might over that I mean if you are

860
00:35:08,040 --> 00:35:10,380
implementing the entire RC this is

861
00:35:10,380 --> 00:35:11,460
something that you might Overlook

862
00:35:11,460 --> 00:35:14,400
because it's just one small sentence

863
00:35:14,400 --> 00:35:16,859
over here but essentially the fix is to

864
00:35:16,859 --> 00:35:17,880
actually

865
00:35:17,880 --> 00:35:20,579
um do exactly what it says to to replace

866
00:35:20,579 --> 00:35:23,339
the new line and space with just

867
00:35:23,339 --> 00:35:25,740
um one or more space of tests prior to

868
00:35:25,740 --> 00:35:27,359
interpreting the few values so you are

869
00:35:27,359 --> 00:35:29,339
supposed to interpret this as transfer

870
00:35:29,339 --> 00:35:34,520
including comma space uh identity

871
00:35:35,099 --> 00:35:36,000
thank you

872
00:35:36,000 --> 00:35:40,140
okay so uh we're gonna talk about so the

873
00:35:40,140 --> 00:35:43,500
entire portion just now was HTTP one so

874
00:35:43,500 --> 00:35:45,650
we're going to talk briefly about hb2

875
00:35:45,650 --> 00:35:46,020
[Music]

876
00:35:46,020 --> 00:35:47,160
um

877
00:35:47,160 --> 00:35:51,660
this specific uh I mean before before

878
00:35:51,660 --> 00:35:53,640
James cattle actually brought it up I

879
00:35:53,640 --> 00:35:55,800
think last year nobody actually thought

880
00:35:55,800 --> 00:35:58,020
that HTTP 2 will be vulnerable to

881
00:35:58,020 --> 00:35:59,820
replace my ring because

882
00:35:59,820 --> 00:36:02,400
um as we talked about earlier actually

883
00:36:02,400 --> 00:36:05,820
because HTTP 2 is a binary protocol the

884
00:36:05,820 --> 00:36:07,320
length field is actually built into the

885
00:36:07,320 --> 00:36:10,380
protocol itself so there is no

886
00:36:10,380 --> 00:36:12,720
um space for any

887
00:36:12,720 --> 00:36:15,540
um misinterpretation of the content uh

888
00:36:15,540 --> 00:36:17,880
content length of a request

889
00:36:17,880 --> 00:36:21,300
but uh essentially just to break it down

890
00:36:21,300 --> 00:36:22,090
simply

891
00:36:22,090 --> 00:36:23,520
[Music]

892
00:36:23,520 --> 00:36:26,940
so although hb2 can be used within a

893
00:36:26,940 --> 00:36:28,200
client and a finite proxy actually

894
00:36:28,200 --> 00:36:31,200
there's no real reason to use hv2

895
00:36:31,200 --> 00:36:33,480
between the front end proxy and the

896
00:36:33,480 --> 00:36:36,350
backend servers because

897
00:36:36,350 --> 00:36:36,359
[Music]

898
00:36:36,359 --> 00:36:37,560
um

899
00:36:37,560 --> 00:36:40,020
when you set up hdb2 you need to set up

900
00:36:40,020 --> 00:36:41,520
TRS as well

901
00:36:41,520 --> 00:36:43,859
you need to set up a

902
00:36:43,859 --> 00:36:46,320
you need to set up the the TRS

903
00:36:46,320 --> 00:36:49,200
certificates you need to set up https

904
00:36:49,200 --> 00:36:51,359
but

905
00:36:51,359 --> 00:36:53,579
um if you are just using this setup

906
00:36:53,579 --> 00:36:55,560
where you have a front-end proxy that

907
00:36:55,560 --> 00:36:57,480
communicates with clients using HTTP 2

908
00:36:57,480 --> 00:36:58,560
and then you have a bunch of backend

909
00:36:58,560 --> 00:36:59,520
servers

910
00:36:59,520 --> 00:37:01,980
I I mean most of the time nobody would

911
00:37:01,980 --> 00:37:04,020
bother to implement hdb 2 between the

912
00:37:04,020 --> 00:37:06,300
front and the back end because this

913
00:37:06,300 --> 00:37:09,599
entire setup lives within your your

914
00:37:09,599 --> 00:37:12,060
server architecture and it is never

915
00:37:12,060 --> 00:37:15,180
exposed to the public so it doesn't make

916
00:37:15,180 --> 00:37:17,280
sense to to say oh I want to encrypt

917
00:37:17,280 --> 00:37:19,619
everything between here I mean you can

918
00:37:19,619 --> 00:37:22,320
but most people don't bother to

919
00:37:22,320 --> 00:37:25,020
so what happens is that if you have a

920
00:37:25,020 --> 00:37:28,440
php2 front-end that communicates with

921
00:37:28,440 --> 00:37:30,960
HTTP one back-ends the Frontline proxy

922
00:37:30,960 --> 00:37:33,060
will downgrade the request to http 1

923
00:37:33,060 --> 00:37:35,599
before forwarding them to the back end

924
00:37:35,599 --> 00:37:39,540
and smuggling vectors would leverage on

925
00:37:39,540 --> 00:37:42,240
the hb1 content length and transfer

926
00:37:42,240 --> 00:37:46,079
encoding values after it is downgraded

927
00:37:46,079 --> 00:37:49,619
so this is an example that uh I've found

928
00:37:49,619 --> 00:37:53,460
in Apache traffic server again uh budget

929
00:37:53,460 --> 00:37:55,140
traffic server is is vulnerable to a

930
00:37:55,140 --> 00:37:56,460
bunch of stuff

931
00:37:56,460 --> 00:38:01,440
um I think in in recently but uh

932
00:38:01,440 --> 00:38:04,560
so in this specific request

933
00:38:04,560 --> 00:38:07,619
um it is it is interesting because HTTP

934
00:38:07,619 --> 00:38:09,540
2 doesn't

935
00:38:09,540 --> 00:38:12,240
uh use the CRF sequence to delimit

936
00:38:12,240 --> 00:38:15,240
anything anymore so if you are if if you

937
00:38:15,240 --> 00:38:17,520
recall from HTTP one each dying is

938
00:38:17,520 --> 00:38:20,280
delimited by the CRF sequence but

939
00:38:20,280 --> 00:38:23,400
because hv2 doesn't use that to delimit

940
00:38:23,400 --> 00:38:25,260
anything so we could actually include

941
00:38:25,260 --> 00:38:27,540
the CR sequence in the request headers

942
00:38:27,540 --> 00:38:29,579
without breaking the hb2 repair

943
00:38:29,579 --> 00:38:30,780
structure

944
00:38:30,780 --> 00:38:32,599
so

945
00:38:32,599 --> 00:38:36,300
if we are looking at uh this

946
00:38:36,300 --> 00:38:38,220
um I mean obviously this is uh I mean

947
00:38:38,220 --> 00:38:41,220
this this is presented in a human

948
00:38:41,220 --> 00:38:43,619
readable format but um it is important

949
00:38:43,619 --> 00:38:46,619
to realize that that under the hood this

950
00:38:46,619 --> 00:38:49,380
is actually uh this is actually a binary

951
00:38:49,380 --> 00:38:51,240
protocol which means that

952
00:38:51,240 --> 00:38:54,780
um this all the headers here is sent as

953
00:38:54,780 --> 00:38:57,780
a header's frame which is built on on

954
00:38:57,780 --> 00:39:00,660
top of TCP and it actually has

955
00:39:00,660 --> 00:39:02,339
um a bunch of um

956
00:39:02,339 --> 00:39:04,280
a bunch of

957
00:39:04,280 --> 00:39:08,099
so-called uh the protocol views so like

958
00:39:08,099 --> 00:39:09,599
the length field

959
00:39:09,599 --> 00:39:11,640
um for for the data frame essentially

960
00:39:11,640 --> 00:39:13,200
the length view is important so the

961
00:39:13,200 --> 00:39:14,940
length here means

962
00:39:14,940 --> 00:39:17,220
um the length will replace the content

963
00:39:17,220 --> 00:39:20,579
length um in egb2 where essentially this

964
00:39:20,579 --> 00:39:22,980
content is sent as a data frame and the

965
00:39:22,980 --> 00:39:24,839
data frame has a length Field built into

966
00:39:24,839 --> 00:39:27,000
the protocol itself

967
00:39:27,000 --> 00:39:29,579
so this entire thing is transmitted in a

968
00:39:29,579 --> 00:39:31,560
binary protocol it is no longer plain

969
00:39:31,560 --> 00:39:34,200
text it's the most important part and

970
00:39:34,200 --> 00:39:36,180
and because of that you could actually

971
00:39:36,180 --> 00:39:40,260
uh inject CR sequences into the hdb2

972
00:39:40,260 --> 00:39:42,960
request without breaking the request

973
00:39:42,960 --> 00:39:46,380
structure and we will see how this is

974
00:39:46,380 --> 00:39:48,180
relevant in just a moment so front end

975
00:39:48,180 --> 00:39:51,420
receives hdb2 which includes this uh

976
00:39:51,420 --> 00:39:54,780
these CR sequences

977
00:39:54,780 --> 00:39:58,619
here I I I present them as new lines but

978
00:39:58,619 --> 00:40:01,020
it is important to note that uh in the

979
00:40:01,020 --> 00:40:04,680
binary protocol itself this is just uh

980
00:40:04,680 --> 00:40:07,920
this is this is just one here right the

981
00:40:07,920 --> 00:40:10,440
the the CRI sequence is inconsequential

982
00:40:10,440 --> 00:40:15,140
to the binary protocol of hv2

983
00:40:15,780 --> 00:40:18,540
but when downgrading this request to hb1

984
00:40:18,540 --> 00:40:20,640
to the backend servers

985
00:40:20,640 --> 00:40:23,520
um Apache traffic server would interpret

986
00:40:23,520 --> 00:40:26,520
this CR sequences and then

987
00:40:26,520 --> 00:40:29,220
it would actually yeah it would actually

988
00:40:29,220 --> 00:40:31,079
literally it would actually literally

989
00:40:31,079 --> 00:40:34,440
reflect the CR sequences into the HB 1.1

990
00:40:34,440 --> 00:40:38,160
request and that allows you to inject a

991
00:40:38,160 --> 00:40:40,140
in that allows you to first of all

992
00:40:40,140 --> 00:40:42,359
inject more headers so you can inject

993
00:40:42,359 --> 00:40:45,060
the containing feather

994
00:40:45,060 --> 00:40:47,579
but also more interestingly

995
00:40:47,579 --> 00:40:50,700
if you use two CRF sequences in a row

996
00:40:50,700 --> 00:40:52,859
you could inject

997
00:40:52,859 --> 00:40:55,440
um stuff into the request body so you so

998
00:40:55,440 --> 00:40:57,480
here we are injecting this into the

999
00:40:57,480 --> 00:40:58,700
reverse body

1000
00:40:58,700 --> 00:41:04,380
and the way that this is used is um so

1001
00:41:04,380 --> 00:41:07,140
if again again going back to the vanilla

1002
00:41:07,140 --> 00:41:08,760
HD Repair smuggling

1003
00:41:08,760 --> 00:41:11,760
um technique this is you can see this is

1004
00:41:11,760 --> 00:41:14,820
the variation of that where the backend

1005
00:41:14,820 --> 00:41:16,500
server interprets the content length

1006
00:41:16,500 --> 00:41:18,960
rather than chunk transfer encoding

1007
00:41:18,960 --> 00:41:22,200
chunk and then because four bytes covers

1008
00:41:22,200 --> 00:41:25,140
three a and then the CR sequence

1009
00:41:25,140 --> 00:41:28,440
this is the start of the next request

1010
00:41:28,440 --> 00:41:29,520
right

1011
00:41:29,520 --> 00:41:32,760
and another interesting thing is that

1012
00:41:32,760 --> 00:41:34,560
if you notice here actually actually

1013
00:41:34,560 --> 00:41:37,140
this authorization header

1014
00:41:37,140 --> 00:41:39,359
gets pushed back into the request body

1015
00:41:39,359 --> 00:41:40,500
as a result

1016
00:41:40,500 --> 00:41:43,079
because we are in injecting now into the

1017
00:41:43,079 --> 00:41:45,540
request body this authorization header

1018
00:41:45,540 --> 00:41:47,339
is injected into the request body as a

1019
00:41:47,339 --> 00:41:48,119
result

1020
00:41:48,119 --> 00:41:52,079
and how this can be relevant is well if

1021
00:41:52,079 --> 00:41:53,940
you are looking at a post request that

1022
00:41:53,940 --> 00:41:57,000
stores some data into the backend server

1023
00:41:57,000 --> 00:41:59,820
it is not too not too far-fetched to

1024
00:41:59,820 --> 00:42:02,339
imagine a scenario where

1025
00:42:02,339 --> 00:42:04,619
um you can push sensitive headers into

1026
00:42:04,619 --> 00:42:06,480
the request body that are being stored

1027
00:42:06,480 --> 00:42:08,160
by the backend application maybe you are

1028
00:42:08,160 --> 00:42:10,280
saving a profile or something like that

1029
00:42:10,280 --> 00:42:15,800
uh and that can be quite interesting

1030
00:42:15,839 --> 00:42:17,579
so

1031
00:42:17,579 --> 00:42:19,320
um once again successful injection of

1032
00:42:19,320 --> 00:42:20,820
content length and transfer encoding

1033
00:42:20,820 --> 00:42:23,460
headers can lead to request smuggling

1034
00:42:23,460 --> 00:42:24,900
um sensitive headers can be pushed into

1035
00:42:24,900 --> 00:42:26,280
the request body and spot into the

1036
00:42:26,280 --> 00:42:28,440
back-end application so for example if

1037
00:42:28,440 --> 00:42:31,800
you have a heavy have another

1038
00:42:31,800 --> 00:42:34,320
have another layer or or another

1039
00:42:34,320 --> 00:42:36,599
application or another client that that

1040
00:42:36,599 --> 00:42:40,859
the user is using and the client injects

1041
00:42:40,859 --> 00:42:44,040
the so the client actually adds the

1042
00:42:44,040 --> 00:42:47,520
authorization header on behalf of of the

1043
00:42:47,520 --> 00:42:49,859
user and the user is not actually

1044
00:42:49,859 --> 00:42:52,680
supposed to know what is this secret

1045
00:42:52,680 --> 00:42:54,599
um but the user using the client can

1046
00:42:54,599 --> 00:42:57,900
actually inject uh inject the CRM

1047
00:42:57,900 --> 00:42:59,579
sequence and push this into the request

1048
00:42:59,579 --> 00:43:01,980
body it is not not too far-fetched to

1049
00:43:01,980 --> 00:43:03,780
imagine a scenario where the user can

1050
00:43:03,780 --> 00:43:05,099
then retrieve the information later

1051
00:43:05,099 --> 00:43:08,040
because of a post request that has

1052
00:43:08,040 --> 00:43:11,460
stored this into the backend application

1053
00:43:11,460 --> 00:43:14,060
foreign

1054
00:43:15,260 --> 00:43:19,680
as I Was preparing the slides uh James

1055
00:43:19,680 --> 00:43:21,300
Carter came up with another another

1056
00:43:21,300 --> 00:43:22,619
piece of research which is quite

1057
00:43:22,619 --> 00:43:24,300
interesting that I just want to dedicate

1058
00:43:24,300 --> 00:43:26,400
one slide to it to talk about

1059
00:43:26,400 --> 00:43:28,200
um so

1060
00:43:28,200 --> 00:43:30,060
it is essentially High inside the text

1061
00:43:30,060 --> 00:43:33,000
if request smuggling so this serves as a

1062
00:43:33,000 --> 00:43:35,520
nice conclusion to this to this topic

1063
00:43:35,520 --> 00:43:38,160
because uh so far everything that I've

1064
00:43:38,160 --> 00:43:41,460
been talking about was relying on a

1065
00:43:41,460 --> 00:43:43,680
front-end proxy and back-end server

1066
00:43:43,680 --> 00:43:44,940
architecture

1067
00:43:44,940 --> 00:43:47,640
and this actually requires two different

1068
00:43:47,640 --> 00:43:49,319
servers and

1069
00:43:49,319 --> 00:43:51,720
for either server or both servers to be

1070
00:43:51,720 --> 00:43:52,980
vulnerable

1071
00:43:52,980 --> 00:43:54,180
but

1072
00:43:54,180 --> 00:43:57,180
if you are able to to craft a perfectly

1073
00:43:57,180 --> 00:44:00,540
valid um request and if that perfectly

1074
00:44:00,540 --> 00:44:02,819
valid request is being interpreted by

1075
00:44:02,819 --> 00:44:06,119
the backend server wrongly then you

1076
00:44:06,119 --> 00:44:08,280
could actually craft a payload using

1077
00:44:08,280 --> 00:44:12,480
just the JavaScript fetch API and that

1078
00:44:12,480 --> 00:44:14,640
causes uh this thing between the

1079
00:44:14,640 --> 00:44:16,920
client's browser and a single web server

1080
00:44:16,920 --> 00:44:19,440
so you are you are essentially poisoning

1081
00:44:19,440 --> 00:44:21,960
the the the connection between the

1082
00:44:21,960 --> 00:44:24,420
client's browser and one single web

1083
00:44:24,420 --> 00:44:27,000
server and that actually challenges the

1084
00:44:27,000 --> 00:44:29,520
whole mindset of oh we actually need a

1085
00:44:29,520 --> 00:44:32,220
finance proxy and a backend server so

1086
00:44:32,220 --> 00:44:34,140
this can be fun to explore just putting

1087
00:44:34,140 --> 00:44:35,579
it out there in case anyone is

1088
00:44:35,579 --> 00:44:38,300
interested in this

1089
00:44:38,339 --> 00:44:40,980
um okay so that's the end of my

1090
00:44:40,980 --> 00:44:42,540
presentation if if anyone has any

1091
00:44:42,540 --> 00:44:44,880
questions I'll be happy to take them

1092
00:44:44,880 --> 00:44:47,099
uh if not

1093
00:44:47,099 --> 00:44:49,680
so I'll just yeah I guess I'll just wait

1094
00:44:49,680 --> 00:44:50,700
for a bit

1095
00:44:50,700 --> 00:44:52,260
um if there are no questions then thanks

1096
00:44:52,260 --> 00:44:53,520
for

1097
00:44:53,520 --> 00:44:55,560
um thanks for being here and and if you

1098
00:44:55,560 --> 00:44:58,700
want you can connect with me

