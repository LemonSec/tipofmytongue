1
00:00:02,159 --> 00:00:05,159
foreign

2
00:00:08,960 --> 00:00:12,120
good evening everyone I'll be speaking

3
00:00:12,120 --> 00:00:14,120
and doing this presentation in English

4
00:00:14,120 --> 00:00:17,340
and the topic for today I believe it's

5
00:00:17,340 --> 00:00:18,539
one of the

6
00:00:18,539 --> 00:00:21,840
most interesting ones in the uh

7
00:00:21,840 --> 00:00:24,720
kind of new trends

8
00:00:24,720 --> 00:00:26,220
we're going to speak about secure

9
00:00:26,220 --> 00:00:28,740
destroys oci images we're going to

10
00:00:28,740 --> 00:00:30,900
Define first of all what is an oci image

11
00:00:30,900 --> 00:00:33,899
what is this true list and what makes

12
00:00:33,899 --> 00:00:37,440
this combination secure by all means uh

13
00:00:37,440 --> 00:00:41,100
we also going to explore our approach to

14
00:00:41,100 --> 00:00:44,579
a new way of building what we have used

15
00:00:44,579 --> 00:00:47,399
to call Docker images via Docker files

16
00:00:47,399 --> 00:00:49,020
and we're going to perform this action

17
00:00:49,020 --> 00:00:51,180
via ammo files so we're going to focus

18
00:00:51,180 --> 00:00:55,140
on what the first presenter uh Bojo has

19
00:00:55,140 --> 00:00:57,960
talked about about the containers and

20
00:00:57,960 --> 00:00:59,760
how nothing is secure in the container

21
00:00:59,760 --> 00:01:02,280
world and at the same time we're going

22
00:01:02,280 --> 00:01:04,260
to leverage this we're going to look

23
00:01:04,260 --> 00:01:06,600
through some exploits and a lot of

24
00:01:06,600 --> 00:01:08,939
interesting stuff

25
00:01:08,939 --> 00:01:11,220
um first of all I kind of reminded

26
00:01:11,220 --> 00:01:15,479
myself to introduce myself and so I'm

27
00:01:15,479 --> 00:01:17,700
Victor bonif and I'm part of VMware

28
00:01:17,700 --> 00:01:21,540
carbon black team uh carbon black is the

29
00:01:21,540 --> 00:01:23,220
team that manages cyber security inside

30
00:01:23,220 --> 00:01:26,820
VMware and we kind of develop a lot of

31
00:01:26,820 --> 00:01:29,220
those Solutions which are the xdr MDR

32
00:01:29,220 --> 00:01:33,960
EDR uh words that you have heard about

33
00:01:33,960 --> 00:01:36,540
the previous presentations as well

34
00:01:36,540 --> 00:01:39,000
I'm a senior developer and I'm very

35
00:01:39,000 --> 00:01:40,799
happy to be here and discuss gather

36
00:01:40,799 --> 00:01:43,740
opinion from each one of you and

37
00:01:43,740 --> 00:01:46,320
hopefully you can learn something that's

38
00:01:46,320 --> 00:01:50,159
good and uh kind of the companies look

39
00:01:50,159 --> 00:01:52,259
for a lot

40
00:01:52,259 --> 00:01:54,119
let's go through the the table of

41
00:01:54,119 --> 00:01:56,280
contents so first of all we're going to

42
00:01:56,280 --> 00:01:58,500
focus on what is oci we're going to

43
00:01:58,500 --> 00:01:59,939
Define it we're going to have a little

44
00:01:59,939 --> 00:02:02,939
bit of a brainstorm with our view then

45
00:02:02,939 --> 00:02:04,680
we're going to speak about the oci

46
00:02:04,680 --> 00:02:06,479
isolation so we're going to do a crash

47
00:02:06,479 --> 00:02:08,280
course which is 101 crash course which

48
00:02:08,280 --> 00:02:10,220
you used to have at the University

49
00:02:10,220 --> 00:02:14,520
understand what is c groups what is file

50
00:02:14,520 --> 00:02:17,520
system and the container aspect talk

51
00:02:17,520 --> 00:02:20,700
about the change route or sea root and

52
00:02:20,700 --> 00:02:22,560
namespaces

53
00:02:22,560 --> 00:02:25,860
then on the third chapter we're going to

54
00:02:25,860 --> 00:02:29,400
show some exploits and we're going to

55
00:02:29,400 --> 00:02:31,920
take a brief overview of the key moments

56
00:02:31,920 --> 00:02:34,080
that have happened in the past year of

57
00:02:34,080 --> 00:02:36,180
course many things have happened I'm not

58
00:02:36,180 --> 00:02:38,580
going to show all of the exploits but

59
00:02:38,580 --> 00:02:40,620
this I'm going to focus on the more

60
00:02:40,620 --> 00:02:41,940
interesting ones

61
00:02:41,940 --> 00:02:44,940
and based on the previous presentation

62
00:02:44,940 --> 00:02:47,660
we had a bit of chat about Alpine Linux

63
00:02:47,660 --> 00:02:50,760
so we're going to talk about Alpine

64
00:02:50,760 --> 00:02:54,120
Linux loved by many hated by even more

65
00:02:54,120 --> 00:02:55,860
so we're going to understand why is that

66
00:02:55,860 --> 00:02:56,879
the case

67
00:02:56,879 --> 00:02:59,280
uh then we're going to talk about this

68
00:02:59,280 --> 00:03:02,660
release what makes this release image

69
00:03:02,660 --> 00:03:06,000
and it's yeah it is a lot of uh

70
00:03:06,000 --> 00:03:08,580
interesting topic and we're going to

71
00:03:08,580 --> 00:03:10,980
focus on the on the last chapter we're

72
00:03:10,980 --> 00:03:13,620
going to talk about project Micron or

73
00:03:13,620 --> 00:03:17,580
michaelian also it is a project that we

74
00:03:17,580 --> 00:03:19,800
try to develop internally inside VMware

75
00:03:19,800 --> 00:03:23,159
carbon black and it is our approach to

76
00:03:23,159 --> 00:03:25,500
solving some of the issues which we will

77
00:03:25,500 --> 00:03:27,239
outline during this presentation with LV

78
00:03:27,239 --> 00:03:28,680
together

79
00:03:28,680 --> 00:03:32,159
so let's talk about oci what is oci it

80
00:03:32,159 --> 00:03:34,440
is the open container initiative what

81
00:03:34,440 --> 00:03:36,980
you have all referred to Containers

82
00:03:36,980 --> 00:03:39,659
Dockers images

83
00:03:39,659 --> 00:03:42,900
that is basically oci and that's the

84
00:03:42,900 --> 00:03:46,080
right way to refer to the container

85
00:03:46,080 --> 00:03:48,480
world it is an oci image it's not a

86
00:03:48,480 --> 00:03:51,959
Docker image it's not a podman image

87
00:03:51,959 --> 00:03:54,180
it is the open container initiative

88
00:03:54,180 --> 00:03:57,120
that's the standard wire of

89
00:03:57,120 --> 00:03:58,560
you know how those things that we're

90
00:03:58,560 --> 00:04:01,319
going to talk about are based upon

91
00:04:01,319 --> 00:04:02,640
so we're going to have a little bit of

92
00:04:02,640 --> 00:04:04,980
introduction what is this all about

93
00:04:04,980 --> 00:04:08,040
you're most familiar I personally I

94
00:04:08,040 --> 00:04:09,360
believe that you're familiar with Docker

95
00:04:09,360 --> 00:04:10,439
you have heard it during this

96
00:04:10,439 --> 00:04:13,080
presentation you know what is it about

97
00:04:13,080 --> 00:04:15,919
and uh Docker is very popular

98
00:04:15,919 --> 00:04:19,320
historically it has been here for

99
00:04:19,320 --> 00:04:23,460
maybe a little bit less than 10 years

100
00:04:23,460 --> 00:04:25,020
yeah cool

101
00:04:25,020 --> 00:04:28,500
well kind of I guess that right all

102
00:04:28,500 --> 00:04:32,160
right so the next platform for oci

103
00:04:32,160 --> 00:04:34,259
images and I'm not going to refer as

104
00:04:34,259 --> 00:04:39,180
containers is kubernetes of course and I

105
00:04:39,180 --> 00:04:42,360
want to pay attention to all of you that

106
00:04:42,360 --> 00:04:45,360
those are totally two separate things no

107
00:04:45,360 --> 00:04:48,060
matter that they handle containers in

108
00:04:48,060 --> 00:04:49,139
the same way

109
00:04:49,139 --> 00:04:51,660
they're totally isolated we're going to

110
00:04:51,660 --> 00:04:53,639
look why is that the case

111
00:04:53,639 --> 00:04:56,280
first of all if you follow you know all

112
00:04:56,280 --> 00:04:59,040
those containers by behind the word

113
00:04:59,040 --> 00:05:01,580
container there are a lot of services

114
00:05:01,580 --> 00:05:05,100
and software behind and sub-components

115
00:05:05,100 --> 00:05:08,100
so we have to break down what this is

116
00:05:08,100 --> 00:05:10,560
all about what is behind that structure

117
00:05:10,560 --> 00:05:11,820
that makes

118
00:05:11,820 --> 00:05:14,699
isolated environments unique and why is

119
00:05:14,699 --> 00:05:16,380
it so popular

120
00:05:16,380 --> 00:05:20,220
so behind Docker there is a container G

121
00:05:20,220 --> 00:05:22,680
which is the

122
00:05:22,680 --> 00:05:26,220
container demon basically behind that's

123
00:05:26,220 --> 00:05:27,180
the

124
00:05:27,180 --> 00:05:28,460
um

125
00:05:28,460 --> 00:05:31,080
basically you can refer to it as an

126
00:05:31,080 --> 00:05:32,880
engine but it's actually a demon that

127
00:05:32,880 --> 00:05:36,440
does the work for you to spawn and

128
00:05:36,440 --> 00:05:40,440
basically handle behind the curtains uh

129
00:05:40,440 --> 00:05:43,500
and in preparation for the next step

130
00:05:43,500 --> 00:05:45,440
on the other hand for kubernetes

131
00:05:45,440 --> 00:05:48,780
kubernetes does not run on containerdy

132
00:05:48,780 --> 00:05:51,479
by default it used to have Docker shim

133
00:05:51,479 --> 00:05:54,240
which was removed it's no longer the

134
00:05:54,240 --> 00:05:56,880
case and kubernetes uses a different

135
00:05:56,880 --> 00:05:58,020
runtime

136
00:05:58,020 --> 00:06:02,280
uh demon it's called cryo or you can

137
00:06:02,280 --> 00:06:06,419
also see it as as CRI as well that's

138
00:06:06,419 --> 00:06:08,720
container runtime interface

139
00:06:08,720 --> 00:06:12,539
uh and cryo was supposed to be a very

140
00:06:12,539 --> 00:06:13,699
lightweight

141
00:06:13,699 --> 00:06:16,979
uh very performance oriented

142
00:06:16,979 --> 00:06:19,740
container runtime interface so there are

143
00:06:19,740 --> 00:06:23,160
more than this one uh but we're not

144
00:06:23,160 --> 00:06:25,380
going to observe the rest we're going to

145
00:06:25,380 --> 00:06:27,840
focus on those two

146
00:06:27,840 --> 00:06:32,400
so uh what comes after those demons uh

147
00:06:32,400 --> 00:06:34,860
of course that is the open container

148
00:06:34,860 --> 00:06:38,400
initiatives so uh dopen container

149
00:06:38,400 --> 00:06:41,699
initiative sets a standard of what a

150
00:06:41,699 --> 00:06:44,639
container is you can think of it as a

151
00:06:44,639 --> 00:06:47,819
protocol even though it is not but the

152
00:06:47,819 --> 00:06:50,400
same way of how for example

153
00:06:50,400 --> 00:06:53,520
TCP is defined in a big protocol in a

154
00:06:53,520 --> 00:06:57,419
RFC yeah it's very different but you can

155
00:06:57,419 --> 00:07:00,300
think of it of an analogy what makes a

156
00:07:00,300 --> 00:07:02,940
container you have to have a a checksum

157
00:07:02,940 --> 00:07:05,340
you have to have a file system you know

158
00:07:05,340 --> 00:07:07,680
a lot of stuff that needs to be there in

159
00:07:07,680 --> 00:07:11,419
order so we can call a container

160
00:07:11,419 --> 00:07:14,639
understandable by container D and by

161
00:07:14,639 --> 00:07:17,880
order container runtime interfaces

162
00:07:17,880 --> 00:07:20,039
it's a set of standards that we have our

163
00:07:20,039 --> 00:07:22,500
agreed upon and it's being

164
00:07:22,500 --> 00:07:26,880
a continuously developed updated so keep

165
00:07:26,880 --> 00:07:30,000
in mind the containers of today's might

166
00:07:30,000 --> 00:07:31,560
be totally different from the containers

167
00:07:31,560 --> 00:07:32,880
of tomorrow

168
00:07:32,880 --> 00:07:35,940
since all of those run times and

169
00:07:35,940 --> 00:07:37,800
container runtime interfaces keeps

170
00:07:37,800 --> 00:07:40,680
developing new features come in and

171
00:07:40,680 --> 00:07:43,340
that's why we need to certify

172
00:07:43,340 --> 00:07:47,400
pretty much every three years this holds

173
00:07:47,400 --> 00:07:50,160
for kubernetes as well so in order to

174
00:07:50,160 --> 00:07:52,139
get a certificate and say a certified

175
00:07:52,139 --> 00:07:54,240
kubernetes administrator I have to

176
00:07:54,240 --> 00:07:56,520
certify every every three years due to

177
00:07:56,520 --> 00:07:58,860
the fact that everything changes pretty

178
00:07:58,860 --> 00:08:00,240
much everything a lot of those things

179
00:08:00,240 --> 00:08:03,240
changes maybe not the core ones but a

180
00:08:03,240 --> 00:08:05,699
lot of those stuff change so what what

181
00:08:05,699 --> 00:08:11,460
is after oci and what comes after oci is

182
00:08:11,460 --> 00:08:13,259
basically run C

183
00:08:13,259 --> 00:08:16,639
run C if I'm not mistaken was first

184
00:08:16,639 --> 00:08:19,259
introduced in 2015

185
00:08:19,259 --> 00:08:21,660
it was version 0.1

186
00:08:21,660 --> 00:08:26,400
and this is the executable

187
00:08:26,400 --> 00:08:28,440
or maybe is curable is not the right

188
00:08:28,440 --> 00:08:31,500
word but it's the runtime of how your

189
00:08:31,500 --> 00:08:34,740
containers are being run in the Linux

190
00:08:34,740 --> 00:08:36,360
world

191
00:08:36,360 --> 00:08:39,000
and run C takes always a Json

192
00:08:39,000 --> 00:08:40,979
configuration if you have worked with

193
00:08:40,979 --> 00:08:43,559
containers you have probably seen that

194
00:08:43,559 --> 00:08:45,080
you have to

195
00:08:45,080 --> 00:08:48,600
provide a Docker file in order to build

196
00:08:48,600 --> 00:08:52,920
stuff and you have a lot of from run uh

197
00:08:52,920 --> 00:08:55,399
a lot of commands which are integrated

198
00:08:55,399 --> 00:08:58,980
and those commands basically bundle

199
00:08:58,980 --> 00:09:01,800
different Json files it could be a Json

200
00:09:01,800 --> 00:09:05,279
file for the networks it could be a Json

201
00:09:05,279 --> 00:09:08,820
file for your volume mounts so all those

202
00:09:08,820 --> 00:09:10,680
configurations and pretty much in the

203
00:09:10,680 --> 00:09:14,279
dockerwood uh everything is in in Json

204
00:09:14,279 --> 00:09:16,860
uh there's b-zone as well everything

205
00:09:16,860 --> 00:09:20,779
fits to run C it basically runs C

206
00:09:20,779 --> 00:09:22,440
executes

207
00:09:22,440 --> 00:09:25,800
all of those things all together as a

208
00:09:25,800 --> 00:09:27,180
big chain

209
00:09:27,180 --> 00:09:29,220
so that you can have what you have

210
00:09:29,220 --> 00:09:31,380
called container so far

211
00:09:31,380 --> 00:09:34,140
that's how it works behind the box in a

212
00:09:34,140 --> 00:09:35,600
short summary without

213
00:09:35,600 --> 00:09:39,540
the details but this would do just fine

214
00:09:39,540 --> 00:09:42,300
for our demonstrations later on the

215
00:09:42,300 --> 00:09:44,760
showcases which I have prepared for you

216
00:09:44,760 --> 00:09:47,820
what I want to take from our view

217
00:09:47,820 --> 00:09:50,640
together and if you

218
00:09:50,640 --> 00:09:53,279
have to remember something is always

219
00:09:53,279 --> 00:09:56,760
question the whatever you come across

220
00:09:56,760 --> 00:09:59,700
that doesn't apply only to containers

221
00:09:59,700 --> 00:10:02,640
and kubernetes Docker whatever you use

222
00:10:02,640 --> 00:10:04,620
always question

223
00:10:04,620 --> 00:10:09,060
how this works and by no means those are

224
00:10:09,060 --> 00:10:11,820
magical services or software which are

225
00:10:11,820 --> 00:10:14,519
unique something is happening and if you

226
00:10:14,519 --> 00:10:17,100
don't know the answer to it there is a

227
00:10:17,100 --> 00:10:18,420
very high chance that you'll be

228
00:10:18,420 --> 00:10:19,640
exploited

229
00:10:19,640 --> 00:10:22,920
why you can be exploited due to the fact

230
00:10:22,920 --> 00:10:25,500
that you don't know the stuff behind it

231
00:10:25,500 --> 00:10:27,360
simply as that

232
00:10:27,360 --> 00:10:29,580
this was stated by some presenter I

233
00:10:29,580 --> 00:10:30,720
don't know who

234
00:10:30,720 --> 00:10:34,500
so how it works understanding those

235
00:10:34,500 --> 00:10:37,080
pieces of software that do Leverage The

236
00:10:37,080 --> 00:10:39,200
Linux kernel system and its components

237
00:10:39,200 --> 00:10:43,500
alongside with it attributes is the key

238
00:10:43,500 --> 00:10:46,560
and as famously as the engineering from

239
00:10:46,560 --> 00:10:48,839
the Mandalorian have said it this is the

240
00:10:48,839 --> 00:10:51,480
way and this holds for everything does

241
00:10:51,480 --> 00:10:53,519
not apply only to oci containers to

242
00:10:53,519 --> 00:10:55,740
kubernetes you have to understand the

243
00:10:55,740 --> 00:10:57,420
concepts

244
00:10:57,420 --> 00:11:00,839
so we're going to talk about the oeci

245
00:11:00,839 --> 00:11:02,760
isolation what I'm going to do without

246
00:11:02,760 --> 00:11:07,500
you with our view is a crash course 101

247
00:11:07,500 --> 00:11:11,399
what makes sort of you probably have

248
00:11:11,399 --> 00:11:14,880
heard again uh why use containers in a

249
00:11:14,880 --> 00:11:17,339
company or if you ask someone in person

250
00:11:17,339 --> 00:11:19,200
well they provide an isolated

251
00:11:19,200 --> 00:11:21,480
environment and my question will be oh

252
00:11:21,480 --> 00:11:24,720
how so so in order to understand how

253
00:11:24,720 --> 00:11:25,980
that happens

254
00:11:25,980 --> 00:11:28,320
you might have heard you might have gone

255
00:11:28,320 --> 00:11:30,300
to the next level and probably heard

256
00:11:30,300 --> 00:11:32,579
well containers are a bunch of c groups

257
00:11:32,579 --> 00:11:35,459
and namespaces but

258
00:11:35,459 --> 00:11:38,820
what I have witnessed is that the

259
00:11:38,820 --> 00:11:40,920
questions about c groups and namespaces

260
00:11:40,920 --> 00:11:43,980
also are unanswered for most part so I

261
00:11:43,980 --> 00:11:47,640
wanted to show you and I I know that it

262
00:11:47,640 --> 00:11:51,600
might not be very visible which I'm

263
00:11:51,600 --> 00:11:54,899
I did my best but uh the kernel future

264
00:11:54,899 --> 00:11:57,420
basically c groups or control groups

265
00:11:57,420 --> 00:12:00,959
those are native kind of features and

266
00:12:00,959 --> 00:12:03,420
they provide resources isolation for

267
00:12:03,420 --> 00:12:05,279
example imagine you want to run a

268
00:12:05,279 --> 00:12:09,800
process and you want to allocate only

269
00:12:09,800 --> 00:12:13,200
256 megabytes of memory to that process

270
00:12:13,200 --> 00:12:15,540
you can do this via control group

271
00:12:15,540 --> 00:12:18,720
uh all of them resides under CIS slash

272
00:12:18,720 --> 00:12:22,320
FS C group what is unique is that you

273
00:12:22,320 --> 00:12:25,440
you can create your own c groups on most

274
00:12:25,440 --> 00:12:28,860
Linux distributions uh they're already

275
00:12:28,860 --> 00:12:32,339
predefined c groups those are mostly

276
00:12:32,339 --> 00:12:36,300
your memory management CPU uh something

277
00:12:36,300 --> 00:12:38,579
that's related with network something

278
00:12:38,579 --> 00:12:41,160
that's related with volume mounts and

279
00:12:41,160 --> 00:12:44,940
you already probably map the features

280
00:12:44,940 --> 00:12:46,860
that Docker provide are not so unique

281
00:12:46,860 --> 00:12:49,860
we've got some Docker or or kubernetes

282
00:12:49,860 --> 00:12:53,639
basically what is exposed through a lot

283
00:12:53,639 --> 00:12:56,639
of its Flags is actually goes to the

284
00:12:56,639 --> 00:13:00,480
native kernel feature which is C group

285
00:13:00,480 --> 00:13:04,680
of course container D and cryo which is

286
00:13:04,680 --> 00:13:06,959
a container runtime interface leverage

287
00:13:06,959 --> 00:13:10,139
this via flag and I'm going just to

288
00:13:10,139 --> 00:13:14,060
spell uh say out loud what is written

289
00:13:14,060 --> 00:13:17,760
below so I can do a Portman run or

290
00:13:17,760 --> 00:13:21,240
equivalent podman is different flavor of

291
00:13:21,240 --> 00:13:23,940
it's a different software similar to

292
00:13:23,940 --> 00:13:27,360
Docker I can do podman run with detached

293
00:13:27,360 --> 00:13:33,779
mode with uh hypnd and allocate uh minus

294
00:13:33,779 --> 00:13:37,320
m flag which will limit my memory usage

295
00:13:37,320 --> 00:13:40,440
to 256 megabytes and I'm going to spawn

296
00:13:40,440 --> 00:13:42,380
on nginx

297
00:13:42,380 --> 00:13:45,480
and latest nginx container what it's

298
00:13:45,480 --> 00:13:47,720
going to do is create a

299
00:13:47,720 --> 00:13:51,540
a separate C group under my

300
00:13:51,540 --> 00:13:54,060
parent process ID which is podman

301
00:13:54,060 --> 00:13:58,560
because podman course container D and

302
00:13:58,560 --> 00:14:01,920
it's it has it already knows the

303
00:14:01,920 --> 00:14:03,600
namespace isolation which we're going to

304
00:14:03,600 --> 00:14:05,579
talk in the next Slide the namespace

305
00:14:05,579 --> 00:14:07,260
isolation will be your container

306
00:14:07,260 --> 00:14:09,720
checksum and you have spawn containers

307
00:14:09,720 --> 00:14:12,120
you have observed that every container

308
00:14:12,120 --> 00:14:15,740
has a unique checksum a unique shot

309
00:14:15,740 --> 00:14:20,880
so basically what you use to reflex is

310
00:14:20,880 --> 00:14:23,040
controlling c groups and basically

311
00:14:23,040 --> 00:14:24,540
you're controlling kernel features

312
00:14:24,540 --> 00:14:26,579
there's no magic behind it

313
00:14:26,579 --> 00:14:30,000
and in that case if I simply Echo the

314
00:14:30,000 --> 00:14:32,519
value I will see that I have allocated

315
00:14:32,519 --> 00:14:34,079
uh

316
00:14:34,079 --> 00:14:37,139
like a 2 million 68

317
00:14:37,139 --> 00:14:39,480
000 bytes yeah the equivalent in bytes

318
00:14:39,480 --> 00:14:41,639
for 256 megabytes

319
00:14:41,639 --> 00:14:44,940
and it's present in my file system

320
00:14:44,940 --> 00:14:46,800
so we're going to

321
00:14:46,800 --> 00:14:49,139
take to the next level and talk about

322
00:14:49,139 --> 00:14:50,940
namespaces

323
00:14:50,940 --> 00:14:52,820
as you recall

324
00:14:52,820 --> 00:14:55,380
containers basically namespace in c

325
00:14:55,380 --> 00:14:58,019
groups so namespaces what are those

326
00:14:58,019 --> 00:15:00,540
those are even more important those are

327
00:15:00,540 --> 00:15:03,120
kernel features for resource partition

328
00:15:03,120 --> 00:15:06,720
partitioning into set of processes

329
00:15:06,720 --> 00:15:07,380
um

330
00:15:07,380 --> 00:15:10,199
if you compare this to c groups the c

331
00:15:10,199 --> 00:15:13,019
groups limits the resource usage while

332
00:15:13,019 --> 00:15:16,620
on the other hand the namespaces limits

333
00:15:16,620 --> 00:15:19,500
the resource a process can see

334
00:15:19,500 --> 00:15:22,139
what do you mean by that imagine you go

335
00:15:22,139 --> 00:15:24,240
to a shell into some server

336
00:15:24,240 --> 00:15:28,680
and you know just simply through that I

337
00:15:28,680 --> 00:15:31,620
can execute again I will run a container

338
00:15:31,620 --> 00:15:34,320
I'll do podman run with an interactive

339
00:15:34,320 --> 00:15:37,199
mode again with the same nginx latest

340
00:15:37,199 --> 00:15:40,139
image I'm going to execute a shell this

341
00:15:40,139 --> 00:15:42,959
will basically uh I'm going to use the

342
00:15:42,959 --> 00:15:45,660
no term don't use it SSH into the

343
00:15:45,660 --> 00:15:47,639
Container basically involve a bone sound

344
00:15:47,639 --> 00:15:50,399
bone shell session and I can list

345
00:15:50,399 --> 00:15:52,860
namespaces so the command to do that is

346
00:15:52,860 --> 00:15:54,899
lsns

347
00:15:54,899 --> 00:15:57,540
and I can see there are different

348
00:15:57,540 --> 00:16:00,540
namespaces each comes with an unique ID

349
00:16:00,540 --> 00:16:03,300
you can see it on the left column

350
00:16:03,300 --> 00:16:05,940
and there is a type of namespaces so we

351
00:16:05,940 --> 00:16:07,440
have now understand that there are

352
00:16:07,440 --> 00:16:09,300
namespaces and the different types of

353
00:16:09,300 --> 00:16:12,660
namespaces what is listed here we have

354
00:16:12,660 --> 00:16:16,079
time we have user we have net we have

355
00:16:16,079 --> 00:16:19,680
Mount we have UTC which is related to

356
00:16:19,680 --> 00:16:23,279
the universal time we have IPC which is

357
00:16:23,279 --> 00:16:26,040
inter-process communication we have pit

358
00:16:26,040 --> 00:16:28,199
which we you have heard in the previous

359
00:16:28,199 --> 00:16:30,180
presentation you know what Piet is for

360
00:16:30,180 --> 00:16:33,000
sure and you have C group out of those

361
00:16:33,000 --> 00:16:35,579
uh namespaces

362
00:16:35,579 --> 00:16:40,079
have Associated bit Associated user and

363
00:16:40,079 --> 00:16:41,759
what command has access to what

364
00:16:41,759 --> 00:16:44,100
namespace

365
00:16:44,100 --> 00:16:46,980
so now we're going to the more a bit in

366
00:16:46,980 --> 00:16:48,000
depth

367
00:16:48,000 --> 00:16:49,980
namespaces

368
00:16:49,980 --> 00:16:51,060
two

369
00:16:51,060 --> 00:16:53,339
and we're going to talk about what those

370
00:16:53,339 --> 00:16:55,680
kind of namespaces are and it's very

371
00:16:55,680 --> 00:16:58,079
important to understand the namespaces

372
00:16:58,079 --> 00:17:00,480
so we can provide security for our

373
00:17:00,480 --> 00:17:03,540
containers if we don't know that we can

374
00:17:03,540 --> 00:17:06,119
say that our container is secure so we

375
00:17:06,119 --> 00:17:09,000
have Mount we have process ID we have

376
00:17:09,000 --> 00:17:11,040
Network again interpros communication

377
00:17:11,040 --> 00:17:14,240
IPC Unix time sharing system

378
00:17:14,240 --> 00:17:18,419
UTC user ID and a control group

379
00:17:18,419 --> 00:17:19,619
so

380
00:17:19,619 --> 00:17:22,439
what is odat means

381
00:17:22,439 --> 00:17:26,699
well it all follows that those are

382
00:17:26,699 --> 00:17:28,919
simply attack vectors

383
00:17:28,919 --> 00:17:32,520
those are the primary targets of how you

384
00:17:32,520 --> 00:17:33,299
can

385
00:17:33,299 --> 00:17:36,419
exploit a container and we're going to

386
00:17:36,419 --> 00:17:38,940
observe some of those exploits that do

387
00:17:38,940 --> 00:17:41,580
leverage this some of those namespaces

388
00:17:41,580 --> 00:17:44,580
not all but at least some

389
00:17:44,580 --> 00:17:46,620
and you can see that there are a lot of

390
00:17:46,620 --> 00:17:49,440
attack vectors nothing again if you

391
00:17:49,440 --> 00:17:51,960
refer to the the first presentation for

392
00:17:51,960 --> 00:17:55,020
today maybe nothing is secure let's see

393
00:17:55,020 --> 00:17:57,120
containers do use namespaces to

394
00:17:57,120 --> 00:18:00,059
partition different resources imagine I

395
00:18:00,059 --> 00:18:02,580
want to run a podman with a BusyBox

396
00:18:02,580 --> 00:18:06,120
image I'm just going to give you uh an

397
00:18:06,120 --> 00:18:09,000
idea what busy box is BusyBox is one of

398
00:18:09,000 --> 00:18:10,919
the most lightweight

399
00:18:10,919 --> 00:18:14,460
images it's not a distribution by any

400
00:18:14,460 --> 00:18:17,280
means it's a type of a Linux image where

401
00:18:17,280 --> 00:18:20,100
all of your essential commands that the

402
00:18:20,100 --> 00:18:22,799
previous presenter have shown AOS cat

403
00:18:22,799 --> 00:18:26,000
Echo uh

404
00:18:26,000 --> 00:18:29,220
then netstat whatever you can think of

405
00:18:29,220 --> 00:18:34,679
ipss those are how bundled into one uh

406
00:18:34,679 --> 00:18:38,299
executable which is kind of a a greater

407
00:18:38,299 --> 00:18:42,299
uh set of those commands so they are not

408
00:18:42,299 --> 00:18:45,960
built each one by one they're bundled

409
00:18:45,960 --> 00:18:48,360
into one there is busy box and there is

410
00:18:48,360 --> 00:18:50,580
another flavor you might have heard it's

411
00:18:50,580 --> 00:18:53,160
called Toy Box same principle

412
00:18:53,160 --> 00:18:55,500
you out of your Linux command that you

413
00:18:55,500 --> 00:18:57,299
have used during your terminal sessions

414
00:18:57,299 --> 00:18:59,280
are basically bundled into one

415
00:18:59,280 --> 00:19:02,100
executable and once you refer it

416
00:19:02,100 --> 00:19:03,600
there is something that's happening

417
00:19:03,600 --> 00:19:06,900
that's closely to soft links and the

418
00:19:06,900 --> 00:19:09,500
soft links basically refer to different

419
00:19:09,500 --> 00:19:12,299
parts of the binary so you can command

420
00:19:12,299 --> 00:19:15,000
can run safely so what we do here that's

421
00:19:15,000 --> 00:19:16,620
what BusyBox is

422
00:19:16,620 --> 00:19:19,799
and we execute a shell

423
00:19:19,799 --> 00:19:23,700
what this does is it's going to create a

424
00:19:23,700 --> 00:19:26,460
separate namespace that will allocate my

425
00:19:26,460 --> 00:19:28,860
hostname and you know that if you spawn

426
00:19:28,860 --> 00:19:31,980
a container you see some checksum or

427
00:19:31,980 --> 00:19:34,140
maybe you don't see checks I mean

428
00:19:34,140 --> 00:19:36,660
depends on how this is configured and

429
00:19:36,660 --> 00:19:39,960
executed through runc and containerdy

430
00:19:39,960 --> 00:19:42,960
but usually behind you there is a

431
00:19:42,960 --> 00:19:44,520
hostname that's being created Network

432
00:19:44,520 --> 00:19:47,520
different types of c groups and a

433
00:19:47,520 --> 00:19:51,059
process apparent process ID

434
00:19:51,059 --> 00:19:52,320
so

435
00:19:52,320 --> 00:19:55,200
I can list you know I've now I'm into

436
00:19:55,200 --> 00:19:57,299
the Container interactively so I can

437
00:19:57,299 --> 00:19:59,700
interact from within

438
00:19:59,700 --> 00:20:02,640
so I can type yes and see what my

439
00:20:02,640 --> 00:20:04,980
processes are and currently there is not

440
00:20:04,980 --> 00:20:08,160
much not much of it going on I have

441
00:20:08,160 --> 00:20:12,380
shell and I have PS those are both

442
00:20:12,380 --> 00:20:16,080
root owned by root but what happens if I

443
00:20:16,080 --> 00:20:19,559
execute another shell so this

444
00:20:19,559 --> 00:20:21,840
if I execute another shell this will

445
00:20:21,840 --> 00:20:25,260
basically do shell within shell and if I

446
00:20:25,260 --> 00:20:27,780
do PS I will see that I have two shells

447
00:20:27,780 --> 00:20:30,840
so what is strange about this

448
00:20:30,840 --> 00:20:35,280
that I'm in my child shell process but

449
00:20:35,280 --> 00:20:37,500
I'm able to see the parent one

450
00:20:37,500 --> 00:20:40,740
observe here that my process idea is

451
00:20:40,740 --> 00:20:42,919
number one

452
00:20:42,919 --> 00:20:47,640
and if I invoke shell again I have a

453
00:20:47,640 --> 00:20:49,380
different process ID and this is the

454
00:20:49,380 --> 00:20:51,960
active one which is three

455
00:20:51,960 --> 00:20:54,840
but then I also am able to see the

456
00:20:54,840 --> 00:20:57,179
parent process ID which is in that case

457
00:20:57,179 --> 00:21:00,000
one that's the parent from which I have

458
00:21:00,000 --> 00:21:01,919
originated from

459
00:21:01,919 --> 00:21:05,580
and even if I spawn a PS3 which is same

460
00:21:05,580 --> 00:21:07,140
as three for file system but for

461
00:21:07,140 --> 00:21:10,080
processes I'm able to see that shell is

462
00:21:10,080 --> 00:21:14,280
my parent with Pros id1 I'm currently

463
00:21:14,280 --> 00:21:17,460
running on on the child process with bit

464
00:21:17,460 --> 00:21:21,480
number three and I've executed PS3 and

465
00:21:21,480 --> 00:21:27,020
that have allocated me uh process ID 11.

466
00:21:27,240 --> 00:21:30,500
so it is strange we're going to see why

467
00:21:30,500 --> 00:21:34,260
and before we go into the detail I want

468
00:21:34,260 --> 00:21:37,320
to do with our views on brainstorm and

469
00:21:37,320 --> 00:21:41,640
there is a simple process inheritance uh

470
00:21:41,640 --> 00:21:44,159
on the left we have a cluster it could

471
00:21:44,159 --> 00:21:45,840
be a Docker machine

472
00:21:45,840 --> 00:21:48,179
it could be a kubernetes cluster

473
00:21:48,179 --> 00:21:51,679
it's some sort of a cluster where many

474
00:21:51,679 --> 00:21:55,140
nodes or containers can run either

475
00:21:55,140 --> 00:21:58,620
through container D or through cryo for

476
00:21:58,620 --> 00:22:01,799
kubernetes and I have basically spawned

477
00:22:01,799 --> 00:22:04,380
a very traditional showcase I have my

478
00:22:04,380 --> 00:22:06,360
backend I have my nginx it doesn't

479
00:22:06,360 --> 00:22:08,220
matter where they run on containerd or

480
00:22:08,220 --> 00:22:11,179
they run on cryo I have four containers

481
00:22:11,179 --> 00:22:14,640
and I have my back end I have my nginx I

482
00:22:14,640 --> 00:22:16,679
have front end I have some metrics for

483
00:22:16,679 --> 00:22:22,020
logging uh which that's how it I love to

484
00:22:22,020 --> 00:22:24,480
do things there was a separate container

485
00:22:24,480 --> 00:22:26,100
that's responsible for logging it

486
00:22:26,100 --> 00:22:28,860
doesn't interfere when I update

487
00:22:28,860 --> 00:22:31,799
so imagine here that I have exposed for

488
00:22:31,799 --> 00:22:34,860
my nginx port 443

489
00:22:34,860 --> 00:22:39,360
and through kubernetes this is quite uh

490
00:22:39,360 --> 00:22:42,480
easy to do you have either cluster IP or

491
00:22:42,480 --> 00:22:45,539
you have node IP for your exposure there

492
00:22:45,539 --> 00:22:47,760
is another type of exposure but we're

493
00:22:47,760 --> 00:22:50,520
mostly focusing on this ones so for that

494
00:22:50,520 --> 00:22:52,440
case that is a note Port basically your

495
00:22:52,440 --> 00:22:56,340
Port is exposed and can be uh you know

496
00:22:56,340 --> 00:22:58,340
you can interact with it

497
00:22:58,340 --> 00:23:02,580
so my question to all of you is what is

498
00:23:02,580 --> 00:23:06,539
the worst scenario that can happen based

499
00:23:06,539 --> 00:23:08,340
on that picture yeah you don't have to

500
00:23:08,340 --> 00:23:09,960
use the mic if you have ideas please

501
00:23:09,960 --> 00:23:12,740
raise your hand

502
00:23:25,559 --> 00:23:28,200
yes so communicating with the

503
00:23:28,200 --> 00:23:30,240
inter-process communication that's why

504
00:23:30,240 --> 00:23:34,260
it is uh bad but it's not the worst but

505
00:23:34,260 --> 00:23:36,120
it's a great observation

506
00:23:36,120 --> 00:23:39,559
can we think about something else

507
00:23:40,559 --> 00:23:43,158
any ideas

508
00:23:46,740 --> 00:23:49,220
right

509
00:23:50,460 --> 00:23:53,179
precisely

510
00:23:54,480 --> 00:23:56,400
exactly so

511
00:23:56,400 --> 00:23:58,919
this is the root of the problem and the

512
00:23:58,919 --> 00:24:00,780
worst thing that can happen and there

513
00:24:00,780 --> 00:24:04,640
were cases like that in Amazon in Google

514
00:24:04,640 --> 00:24:09,059
in the major vendors for for clouds

515
00:24:09,059 --> 00:24:11,820
and what has happened is that you can

516
00:24:11,820 --> 00:24:15,539
escape outside of your container towards

517
00:24:15,539 --> 00:24:18,419
the cluster and now not only you have

518
00:24:18,419 --> 00:24:22,080
exploited like how I can do that imagine

519
00:24:22,080 --> 00:24:24,840
I have a vulnerability which I can

520
00:24:24,840 --> 00:24:26,700
exploit in nginx

521
00:24:26,700 --> 00:24:29,280
it's rare it doesn't happen I know but

522
00:24:29,280 --> 00:24:31,320
let's say it's not nginx it's software

523
00:24:31,320 --> 00:24:33,600
that I have written so I can exploit

524
00:24:33,600 --> 00:24:36,480
that it's either it could be buffer

525
00:24:36,480 --> 00:24:38,580
overflow it could be used after free

526
00:24:38,580 --> 00:24:42,020
those are two of the most commonly used

527
00:24:42,020 --> 00:24:44,100
vulnerabilities that are being exploited

528
00:24:44,100 --> 00:24:47,280
I load my shell and then I have access

529
00:24:47,280 --> 00:24:50,220
but I have access only towards that

530
00:24:50,220 --> 00:24:52,500
container so I'm isolated I can't see

531
00:24:52,500 --> 00:24:54,000
what is the back end doing what is the

532
00:24:54,000 --> 00:24:56,039
front end doing I have access to that

533
00:24:56,039 --> 00:24:58,500
particular service and

534
00:24:58,500 --> 00:25:00,780
you know miraculously

535
00:25:00,780 --> 00:25:04,620
their issues and exploits that can allow

536
00:25:04,620 --> 00:25:06,299
me not only to control that container

537
00:25:06,299 --> 00:25:07,679
but I can take control over the whole

538
00:25:07,679 --> 00:25:11,100
cluster and this is drawn exactly

539
00:25:11,100 --> 00:25:13,860
through exploits that are targeted on c

540
00:25:13,860 --> 00:25:17,760
groups and namespaces and uh mostly you

541
00:25:17,760 --> 00:25:20,039
can Target container D you can Target

542
00:25:20,039 --> 00:25:21,720
cryo

543
00:25:21,720 --> 00:25:24,059
and you can get leverage of the cluster

544
00:25:24,059 --> 00:25:26,820
and now you do not control only your own

545
00:25:26,820 --> 00:25:28,860
data the cluster can have thousands of

546
00:25:28,860 --> 00:25:31,380
notes and I don't know how many

547
00:25:31,380 --> 00:25:35,460
containers uh maybe about 10 000 if it's

548
00:25:35,460 --> 00:25:37,380
a big one and owned by the Enterprise

549
00:25:37,380 --> 00:25:40,500
Corporation and I can I can control

550
00:25:40,500 --> 00:25:42,000
pretty much everything

551
00:25:42,000 --> 00:25:45,900
doesn't matter I have hole control

552
00:25:45,900 --> 00:25:48,840
so I'm going to show you two of those

553
00:25:48,840 --> 00:25:53,840
exploits which do leverage Linux type of

554
00:25:53,840 --> 00:25:56,880
vulnerabilities the first actually the

555
00:25:56,880 --> 00:25:59,520
both of them were discovered last year

556
00:25:59,520 --> 00:26:04,039
uh the first one is CV 2022

557
00:26:04,039 --> 00:26:09,380
0847 the second one is CV 2022

558
00:26:09,380 --> 00:26:13,020
1085 and what is the CV just so we are

559
00:26:13,020 --> 00:26:15,659
on Common Ground that's the common

560
00:26:15,659 --> 00:26:18,779
vulnerability exploit so

561
00:26:18,779 --> 00:26:21,179
notice the word common those are

562
00:26:21,179 --> 00:26:23,400
vulnerabilities that we know that do

563
00:26:23,400 --> 00:26:25,799
exist there are many that we don't know

564
00:26:25,799 --> 00:26:28,879
that do exist

565
00:26:29,340 --> 00:26:33,059
so what are those exploits the first one

566
00:26:33,059 --> 00:26:36,120
main cause it is initialized by buffer

567
00:26:36,120 --> 00:26:37,500
flag variable

568
00:26:37,500 --> 00:26:40,620
and this is a future that's

569
00:26:40,620 --> 00:26:44,220
uh in the uh in the kernel it's back in

570
00:26:44,220 --> 00:26:45,779
the kernel that can be exploited

571
00:26:45,779 --> 00:26:48,900
basically page cache is always credible

572
00:26:48,900 --> 00:26:51,720
to the kernel imagine I have to write a

573
00:26:51,720 --> 00:26:54,419
specific file but I do it in such way

574
00:26:54,419 --> 00:26:58,020
and I can write a c program which I can

575
00:26:58,020 --> 00:27:01,260
write a cache but while writing the cash

576
00:27:01,260 --> 00:27:03,000
in a specific way of course I'll show

577
00:27:03,000 --> 00:27:05,460
you how this looks like I can write a

578
00:27:05,460 --> 00:27:07,799
cache without the kernel checking for my

579
00:27:07,799 --> 00:27:11,340
permissions so this came actually from a

580
00:27:11,340 --> 00:27:14,220
ticket the exploit is called uh dirty

581
00:27:14,220 --> 00:27:15,179
pipe

582
00:27:15,179 --> 00:27:17,940
you you have seen it probably in the

583
00:27:17,940 --> 00:27:19,620
previous presentation one of those

584
00:27:19,620 --> 00:27:22,140
presentations it was called dirty cow so

585
00:27:22,140 --> 00:27:24,059
basically that's the successor

586
00:27:24,059 --> 00:27:26,520
of that exploit

587
00:27:26,520 --> 00:27:30,900
and what it does I can write for example

588
00:27:30,900 --> 00:27:35,220
Etc uh password file and write it as a

589
00:27:35,220 --> 00:27:37,400
cache replace it with my own password

590
00:27:37,400 --> 00:27:40,320
elevate my privileges become root and

591
00:27:40,320 --> 00:27:42,720
then restore it from a backup so you

592
00:27:42,720 --> 00:27:44,520
know you wouldn't notice that those this

593
00:27:44,520 --> 00:27:47,580
file has been written down and then

594
00:27:47,580 --> 00:27:49,440
restored there's no way you can guess

595
00:27:49,440 --> 00:27:51,360
that of course if you don't have some

596
00:27:51,360 --> 00:27:53,940
kind of a audit monitoring of the

597
00:27:53,940 --> 00:27:56,220
actions that have been performed the

598
00:27:56,220 --> 00:27:58,799
second exploit is actually related to

599
00:27:58,799 --> 00:28:01,380
the Heap based buffer overflow in Legacy

600
00:28:01,380 --> 00:28:04,380
parse pyram function again it's a it's a

601
00:28:04,380 --> 00:28:07,260
bug in the links kernel and what it does

602
00:28:07,260 --> 00:28:11,760
is there are certain namespaces and the

603
00:28:11,760 --> 00:28:13,400
certain namespaces have different

604
00:28:13,400 --> 00:28:15,480
aspects that they can interact with

605
00:28:15,480 --> 00:28:18,840
certain kind of futures or or kernel

606
00:28:18,840 --> 00:28:19,740
classes

607
00:28:19,740 --> 00:28:22,799
an unprivileged local user say I'm uh

608
00:28:22,799 --> 00:28:25,980
non-root stating this clear I'm not root

609
00:28:25,980 --> 00:28:28,740
and I want to enable my capsys admin

610
00:28:28,740 --> 00:28:31,919
such that it opens its capsys admin is a

611
00:28:31,919 --> 00:28:36,419
is a Linux kind of definition of

612
00:28:36,419 --> 00:28:38,820
uh or something Legacy but it's we

613
00:28:38,820 --> 00:28:40,860
trigger it so it can execute that Legacy

614
00:28:40,860 --> 00:28:43,860
uh code and what it does it's open a

615
00:28:43,860 --> 00:28:45,720
file system that does not support the

616
00:28:45,720 --> 00:28:48,480
file system context API and then it

617
00:28:48,480 --> 00:28:51,120
falls back to Legacy handling where we

618
00:28:51,120 --> 00:28:54,299
hit that exact exploit so it's something

619
00:28:54,299 --> 00:28:56,940
that's very similar what bonjour have

620
00:28:56,940 --> 00:28:59,700
shown in the previous uh in the first

621
00:28:59,700 --> 00:29:02,400
presentation with the printer there was

622
00:29:02,400 --> 00:29:04,320
a printer that was printing something

623
00:29:04,320 --> 00:29:07,380
that's uh for legacy you know how you

624
00:29:07,380 --> 00:29:12,720
can send uh a gif on your phone and that

625
00:29:12,720 --> 00:29:14,640
gif becomes PDF and your phone gets

626
00:29:14,640 --> 00:29:16,500
exploited that's the same thing we're

627
00:29:16,500 --> 00:29:18,360
triggering a legacy function that's I

628
00:29:18,360 --> 00:29:20,340
don't know how many years old nobody

629
00:29:20,340 --> 00:29:23,039
knew it existed

630
00:29:23,039 --> 00:29:26,220
so a fast recap there is Docker there is

631
00:29:26,220 --> 00:29:27,659
kubernetes those are two different

632
00:29:27,659 --> 00:29:30,620
ecosystems and they run on different

633
00:29:30,620 --> 00:29:34,679
demons one is containerd one is cryo and

634
00:29:34,679 --> 00:29:37,620
what I want you to emphasize on is that

635
00:29:37,620 --> 00:29:39,419
kubernetes and Docker do behave

636
00:29:39,419 --> 00:29:40,500
differently

637
00:29:40,500 --> 00:29:44,100
in the aspect of the runtime

638
00:29:44,100 --> 00:29:45,840
so uh

639
00:29:45,840 --> 00:29:48,779
what I'm going to show

640
00:29:48,779 --> 00:29:51,480
I hope it's not very visible but I can

641
00:29:51,480 --> 00:29:55,020
share the slides with our view after the

642
00:29:55,020 --> 00:29:59,100
um the presentation I execute a busy box

643
00:29:59,100 --> 00:30:02,419
image and I do a PS so I can see that my

644
00:30:02,419 --> 00:30:06,059
uh process I have two bits both are

645
00:30:06,059 --> 00:30:09,539
owned by root and I have 5 15 49 for my

646
00:30:09,539 --> 00:30:12,059
Linux kernel version then I do an unsure

647
00:30:12,059 --> 00:30:15,320
and that's on the docker provisioned

648
00:30:15,320 --> 00:30:18,419
container when I do an unshare that's

649
00:30:18,419 --> 00:30:20,279
basically detaching myself from another

650
00:30:20,279 --> 00:30:22,620
namespace from the namespace and trying

651
00:30:22,620 --> 00:30:25,500
to create a new one it says oh unshare

652
00:30:25,500 --> 00:30:27,419
operation is not permitted that's on the

653
00:30:27,419 --> 00:30:31,140
docker if I execute the same thing on

654
00:30:31,140 --> 00:30:33,960
the kubernetes with the k run K is just

655
00:30:33,960 --> 00:30:38,100
an alias for cube CTL k run interactive

656
00:30:38,100 --> 00:30:40,140
same image busy box

657
00:30:40,140 --> 00:30:42,419
shell it's the bone shell it's the same

658
00:30:42,419 --> 00:30:47,760
shell and I try the same command unsure

659
00:30:47,760 --> 00:30:50,940
it will run so what I wanted to

660
00:30:50,940 --> 00:30:52,679
emphasize with this very

661
00:30:52,679 --> 00:30:55,500
simple example is that they behave

662
00:30:55,500 --> 00:30:57,899
differently if you test your application

663
00:30:57,899 --> 00:31:00,779
in a Docker local environment and say

664
00:31:00,779 --> 00:31:03,659
hey boss it's done we can deploy it to

665
00:31:03,659 --> 00:31:05,279
the cluster I've checked everything

666
00:31:05,279 --> 00:31:09,419
there is no way this can get exploited

667
00:31:09,419 --> 00:31:11,159
kubernetes

668
00:31:11,159 --> 00:31:12,960
do things differently

669
00:31:12,960 --> 00:31:17,520
of course this has been a

670
00:31:17,520 --> 00:31:20,159
much improved with the latest version of

671
00:31:20,159 --> 00:31:22,279
kubernetes they are now

672
00:31:22,279 --> 00:31:25,440
filters that you can leverage but you

673
00:31:25,440 --> 00:31:27,720
can state that explicitly so you have to

674
00:31:27,720 --> 00:31:29,279
know what you're doing

675
00:31:29,279 --> 00:31:30,899
uh

676
00:31:30,899 --> 00:31:34,200
so the lesson to take home is that they

677
00:31:34,200 --> 00:31:37,860
behave differently kubernetes and docker

678
00:31:37,860 --> 00:31:41,640
the next uh exploit that I wanted to

679
00:31:41,640 --> 00:31:45,299
show you is dirty pipe dirty pipe is an

680
00:31:45,299 --> 00:31:48,120
exploit which is the successor of the

681
00:31:48,120 --> 00:31:52,320
recall it's where I can write a cache to

682
00:31:52,320 --> 00:31:54,419
the Linux kernel without the Linux

683
00:31:54,419 --> 00:31:56,240
kernel checking for my right permission

684
00:31:56,240 --> 00:31:59,039
so I can write pretty much anything and

685
00:31:59,039 --> 00:32:02,820
I can override the ETC password d file

686
00:32:02,820 --> 00:32:06,059
so what I'm going to do here I have

687
00:32:06,059 --> 00:32:08,820
created a scenario where I use pound cat

688
00:32:08,820 --> 00:32:11,520
pound cat is a remote shell it's very

689
00:32:11,520 --> 00:32:14,460
similar to uh probably some of you have

690
00:32:14,460 --> 00:32:16,740
played with Metasploit and meterpreter

691
00:32:16,740 --> 00:32:19,740
it's again a sort of a remote shell and

692
00:32:19,740 --> 00:32:23,340
you can spawn sessions uh basically it's

693
00:32:23,340 --> 00:32:25,740
very interesting you can check it online

694
00:32:25,740 --> 00:32:29,100
it's called pound cats open source

695
00:32:29,100 --> 00:32:31,679
um what I do here is I trigger and

696
00:32:31,679 --> 00:32:35,039
compile that specific exploit it's

697
00:32:35,039 --> 00:32:39,179
written in C and that uh it triggers the

698
00:32:39,179 --> 00:32:41,039
vulnerability

699
00:32:41,039 --> 00:32:43,440
it's compiling it says compiling

700
00:32:43,440 --> 00:32:45,480
verified exploit attempting to run

701
00:32:45,480 --> 00:32:49,500
completed successfully and uh what I do

702
00:32:49,500 --> 00:32:51,600
I check my ID and I have become root

703
00:32:51,600 --> 00:32:56,340
initially I was not rude but then I once

704
00:32:56,340 --> 00:32:58,320
I do that exploit I have be I have

705
00:32:58,320 --> 00:33:01,559
elevated my privileges and you don't

706
00:33:01,559 --> 00:33:02,520
know

707
00:33:02,520 --> 00:33:05,880
how widely spread that exploit is

708
00:33:05,880 --> 00:33:09,980
that was fixed in the later versions of

709
00:33:09,980 --> 00:33:16,559
Linux kernel 5.15 by 29 so it's it was

710
00:33:16,559 --> 00:33:19,320
fixed in the last seven months

711
00:33:19,320 --> 00:33:21,840
or eight months

712
00:33:21,840 --> 00:33:24,240
um imagine how much it will take for the

713
00:33:24,240 --> 00:33:26,640
industry to catch up and update not

714
00:33:26,640 --> 00:33:30,419
everyone updates their kernels regularly

715
00:33:30,419 --> 00:33:33,960
so everyone makes makes them vulnerable

716
00:33:33,960 --> 00:33:37,860
and if we don't know again uh simply by

717
00:33:37,860 --> 00:33:40,799
attacking the kernel we can Elevate

718
00:33:40,799 --> 00:33:42,840
privileges become root now imagine what

719
00:33:42,840 --> 00:33:45,299
will happen if we find problems and

720
00:33:45,299 --> 00:33:47,039
combine different exploits so we can

721
00:33:47,039 --> 00:33:50,220
escape outside of this container and

722
00:33:50,220 --> 00:33:52,620
reach the cluster with root privileges

723
00:33:52,620 --> 00:33:55,200
it doesn't matter whether container

724
00:33:55,200 --> 00:33:57,240
whether our container is running with

725
00:33:57,240 --> 00:34:01,679
non-root we can Elevate our privileges

726
00:34:01,679 --> 00:34:05,760
the next exploit uh it's pretty much

727
00:34:05,760 --> 00:34:08,639
a key buffer overflow

728
00:34:08,639 --> 00:34:11,399
and for this I have prepared an image I

729
00:34:11,399 --> 00:34:14,040
have uploaded to the public Docker Hub

730
00:34:14,040 --> 00:34:18,719
under VP bonus besides hyphen Attack One

731
00:34:18,719 --> 00:34:21,000
and I create a pot which is called

732
00:34:21,000 --> 00:34:25,739
besides attack one then I SSH or

733
00:34:25,739 --> 00:34:28,619
spawn a bone cell session interactively

734
00:34:28,619 --> 00:34:31,219
and check what my uh

735
00:34:31,219 --> 00:34:33,780
my processor

736
00:34:33,780 --> 00:34:36,540
so I list my namespaces

737
00:34:36,540 --> 00:34:39,119
and the idea about this hacks that I can

738
00:34:39,119 --> 00:34:45,239
change my name space so uh if I do a

739
00:34:45,239 --> 00:34:48,960
captch print which is capture

740
00:34:48,960 --> 00:34:49,859
um

741
00:34:49,859 --> 00:34:52,500
uh basically capture the current the

742
00:34:52,500 --> 00:34:56,000
bounding and the current iib namespaces

743
00:34:56,000 --> 00:34:59,000
the I can do unshare

744
00:34:59,000 --> 00:35:04,020
urm and basically uh unshare urm tries

745
00:35:04,020 --> 00:35:06,420
to detach from the current namespace and

746
00:35:06,420 --> 00:35:09,300
spawn a new namespace and now I have

747
00:35:09,300 --> 00:35:12,420
elevated the capsys admin privileges for

748
00:35:12,420 --> 00:35:16,200
which I I was supposed not to you know I

749
00:35:16,200 --> 00:35:17,700
was outside of that namespace they

750
00:35:17,700 --> 00:35:20,160
didn't have access to it but simply by

751
00:35:20,160 --> 00:35:23,339
invoking unshare I'm able to change my

752
00:35:23,339 --> 00:35:25,380
content of visible namespaces and

753
00:35:25,380 --> 00:35:28,500
namespaces which I can reach to

754
00:35:28,500 --> 00:35:29,940
so

755
00:35:29,940 --> 00:35:33,240
that is one way of container escaping

756
00:35:33,240 --> 00:35:36,180
that was fixed in uh

757
00:35:36,180 --> 00:35:38,220
I believe quite recently

758
00:35:38,220 --> 00:35:40,280
but it's one attack that you can work

759
00:35:40,280 --> 00:35:43,560
and some vendors which I will not name

760
00:35:43,560 --> 00:35:46,619
have suffered from it

761
00:35:46,619 --> 00:35:48,060
so

762
00:35:48,060 --> 00:35:50,220
the tools that I have used I always want

763
00:35:50,220 --> 00:35:52,020
to uh

764
00:35:52,020 --> 00:35:54,540
State my software which I've used for

765
00:35:54,540 --> 00:35:56,760
that presentation the first one is

766
00:35:56,760 --> 00:36:01,020
asking Nemo for which I uh recorded my

767
00:36:01,020 --> 00:36:02,940
terminal sessions it's very useful I

768
00:36:02,940 --> 00:36:06,079
recommended it it's uh you can

769
00:36:06,079 --> 00:36:08,700
you'll remember the name because it's an

770
00:36:08,700 --> 00:36:11,400
an acronym for ASCII Cinema

771
00:36:11,400 --> 00:36:14,700
so it's asking Emma and the second one

772
00:36:14,700 --> 00:36:16,980
is a bind reverse shell it's called Palm

773
00:36:16,980 --> 00:36:19,140
cat you can check it out and you can

774
00:36:19,140 --> 00:36:22,800
also watch the uh the introduction from

775
00:36:22,800 --> 00:36:25,619
the guys that did invade it did invent

776
00:36:25,619 --> 00:36:29,760
that remote show uh they're great I mean

777
00:36:29,760 --> 00:36:32,040
I've learned by watching that session

778
00:36:32,040 --> 00:36:35,579
alone more than I have learned in five

779
00:36:35,579 --> 00:36:38,220
years and the session was 50 minutes

780
00:36:38,220 --> 00:36:42,180
about remote shells so

781
00:36:42,180 --> 00:36:44,280
another important point that I want to

782
00:36:44,280 --> 00:36:45,960
make during this presentation is that

783
00:36:45,960 --> 00:36:48,960
security moves with time and what is

784
00:36:48,960 --> 00:36:52,339
secure today will not be secure tomorrow

785
00:36:52,339 --> 00:36:54,900
what do you have observed so far are

786
00:36:54,900 --> 00:36:58,619
Kano exploits those two exploits that I

787
00:36:58,619 --> 00:37:00,960
have shown you

788
00:37:00,960 --> 00:37:03,960
and I want to again emphasize that the

789
00:37:03,960 --> 00:37:06,300
kernel kano.org

790
00:37:06,300 --> 00:37:09,720
is one of the most icing software ever

791
00:37:09,720 --> 00:37:13,680
developed you know this is watched by so

792
00:37:13,680 --> 00:37:16,140
many developers so many eyes are

793
00:37:16,140 --> 00:37:19,079
developing on this including our company

794
00:37:19,079 --> 00:37:20,880
sponsor building

795
00:37:20,880 --> 00:37:22,220
but

796
00:37:22,220 --> 00:37:26,160
it's so big that a certain developer

797
00:37:26,160 --> 00:37:28,619
takes a certain class there is a subset

798
00:37:28,619 --> 00:37:31,440
in that class for that future and there

799
00:37:31,440 --> 00:37:34,140
is just one little fragment that he's

800
00:37:34,140 --> 00:37:37,140
focusing on and that's reviewed by many

801
00:37:37,140 --> 00:37:40,140
this is one of the most secure software

802
00:37:40,140 --> 00:37:42,839
ever written and it does have exploits

803
00:37:42,839 --> 00:37:45,660
yeah despite it is at the root of

804
00:37:45,660 --> 00:37:48,240
everything it runs everywhere you'll not

805
00:37:48,240 --> 00:37:50,220
find something that does not run

806
00:37:50,220 --> 00:37:52,560
uh Linux kernel even now the new

807
00:37:52,560 --> 00:37:55,020
versions of Windows are shipped with

808
00:37:55,020 --> 00:37:57,980
Linux Kano and they support

809
00:37:57,980 --> 00:38:00,900
that it's very safe piece of software

810
00:38:00,900 --> 00:38:02,820
it's present everywhere

811
00:38:02,820 --> 00:38:04,980
now for a moment

812
00:38:04,980 --> 00:38:09,140
imagine how many common vulnerabilities

813
00:38:09,140 --> 00:38:13,140
uh other softwares could possess

814
00:38:13,140 --> 00:38:15,180
think of a moment about this

815
00:38:15,180 --> 00:38:19,380
because if one of the most observed

816
00:38:19,380 --> 00:38:21,300
piece of software

817
00:38:21,300 --> 00:38:23,579
have such vulnerabilities and those are

818
00:38:23,579 --> 00:38:24,660
criticals

819
00:38:24,660 --> 00:38:26,420
and of course

820
00:38:26,420 --> 00:38:29,280
the industry tries to catch a patch

821
00:38:29,280 --> 00:38:33,480
regularly Etc but the order software is

822
00:38:33,480 --> 00:38:35,040
not

823
00:38:35,040 --> 00:38:38,460
on such string monitoring usually you

824
00:38:38,460 --> 00:38:41,640
can have a developer pushed code and

825
00:38:41,640 --> 00:38:43,800
there could be buffer overflow that

826
00:38:43,800 --> 00:38:46,740
could be used after free and it's yeah

827
00:38:46,740 --> 00:38:48,599
it's a lot more dangerous in at least in

828
00:38:48,599 --> 00:38:50,640
my opinion

829
00:38:50,640 --> 00:38:51,900
um

830
00:38:51,900 --> 00:38:54,839
no not only that but this software can

831
00:38:54,839 --> 00:38:57,240
be added on top of public

832
00:38:57,240 --> 00:39:01,320
uh images Docker images or container

833
00:39:01,320 --> 00:39:03,720
images or all CI images they all refer

834
00:39:03,720 --> 00:39:05,280
to the same thing

835
00:39:05,280 --> 00:39:06,359
so

836
00:39:06,359 --> 00:39:08,880
the next time someone asks you oh I

837
00:39:08,880 --> 00:39:09,859
wanted to

838
00:39:09,859 --> 00:39:12,960
run that service very quickly you

839
00:39:12,960 --> 00:39:15,359
probably will just go to download the

840
00:39:15,359 --> 00:39:17,220
first Public Image that's available on

841
00:39:17,220 --> 00:39:19,619
Docker Hub not saying that you do it

842
00:39:19,619 --> 00:39:21,380
many many

843
00:39:21,380 --> 00:39:25,619
developers do that and those images are

844
00:39:25,619 --> 00:39:28,980
full of vulnerabilities even there is

845
00:39:28,980 --> 00:39:31,440
snuck now running on Docker Hub which is

846
00:39:31,440 --> 00:39:34,500
their scanner and you have approved and

847
00:39:34,500 --> 00:39:36,599
certified verified images and

848
00:39:36,599 --> 00:39:39,960
repositories it's still like tons of

849
00:39:39,960 --> 00:39:41,760
vulnerabilities everywhere inside those

850
00:39:41,760 --> 00:39:45,060
public images don't trust them

851
00:39:45,060 --> 00:39:46,500
so

852
00:39:46,500 --> 00:39:48,900
the next topic I want to to bring is

853
00:39:48,900 --> 00:39:52,320
bring on this table is Alpine Linux

854
00:39:52,320 --> 00:39:54,180
and my question towards you is Who

855
00:39:54,180 --> 00:39:57,200
currently uses Alpine

856
00:39:58,140 --> 00:40:00,359
okay

857
00:40:00,359 --> 00:40:02,339
you know this would be bad because this

858
00:40:02,339 --> 00:40:04,760
presentation is not about Alpine right

859
00:40:04,760 --> 00:40:08,160
okay so uh

860
00:40:08,160 --> 00:40:12,060
yeah Alpine is loved by many and hated

861
00:40:12,060 --> 00:40:14,040
by even more people

862
00:40:14,040 --> 00:40:16,020
why is that the case

863
00:40:16,020 --> 00:40:18,900
um usually the process towards coming to

864
00:40:18,900 --> 00:40:20,880
Alpine Linux

865
00:40:20,880 --> 00:40:24,060
goes through a size comparison and I

866
00:40:24,060 --> 00:40:25,920
have shown just an example showcase I

867
00:40:25,920 --> 00:40:28,800
want to build uh and provide basically

868
00:40:28,800 --> 00:40:31,619
an image that can be that can run go and

869
00:40:31,619 --> 00:40:33,780
build go whatever that the case is if

870
00:40:33,780 --> 00:40:36,359
you build go then it could be a larger

871
00:40:36,359 --> 00:40:38,579
image in size but I wanted to just

872
00:40:38,579 --> 00:40:40,800
provide a comparison

873
00:40:40,800 --> 00:40:44,400
um about how the choice to pick Alpine

874
00:40:44,400 --> 00:40:47,099
is usually done in in companies not only

875
00:40:47,099 --> 00:40:48,900
Enterprise companies

876
00:40:48,900 --> 00:40:51,420
one manager and that brings us to our

877
00:40:51,420 --> 00:40:53,700
previous talk one manager checks all

878
00:40:53,700 --> 00:40:55,740
that image about dividends one gigabyte

879
00:40:55,740 --> 00:40:58,980
that's a lot what's how can we bring

880
00:40:58,980 --> 00:41:01,320
this down into into a smaller image and

881
00:41:01,320 --> 00:41:03,599
developer checks say oh you know I saw

882
00:41:03,599 --> 00:41:05,940
this Alpine Linux they pretend to be

883
00:41:05,940 --> 00:41:08,400
pretty much small in size let's give

884
00:41:08,400 --> 00:41:10,859
them a kick see what happens

885
00:41:10,859 --> 00:41:13,320
usually the people don't know what the

886
00:41:13,320 --> 00:41:14,280
four

887
00:41:14,280 --> 00:41:17,780
other words mean below that graph

888
00:41:17,780 --> 00:41:19,940
meaning

889
00:41:19,940 --> 00:41:23,099
distrance busy box and scratch

890
00:41:23,099 --> 00:41:25,500
so I will explain those to you this

891
00:41:25,500 --> 00:41:27,180
stress we're going to talk about in the

892
00:41:27,180 --> 00:41:30,780
later slide uh scratch is basically you

893
00:41:30,780 --> 00:41:33,480
can refer to it as a no so it's a no

894
00:41:33,480 --> 00:41:36,240
image it's empty

895
00:41:36,240 --> 00:41:38,760
busy box I have explained that our recap

896
00:41:38,760 --> 00:41:41,099
that's an image that's pretty much

897
00:41:41,099 --> 00:41:43,800
scratch with the essential Linux command

898
00:41:43,800 --> 00:41:49,440
so you can still uh Echo Cat OS sort of

899
00:41:49,440 --> 00:41:51,660
those stuff that commands that you use

900
00:41:51,660 --> 00:41:53,000
day to day

901
00:41:53,000 --> 00:41:56,400
uh and you also have scratch Advance

902
00:41:56,400 --> 00:41:57,720
which is

903
00:41:57,720 --> 00:42:00,440
Advanced scratch but I still know

904
00:42:00,440 --> 00:42:03,720
so Alpine why why do people pick Alpine

905
00:42:03,720 --> 00:42:05,820
yeah you have package manager there you

906
00:42:05,820 --> 00:42:10,099
have APK and APK can install very easily

907
00:42:10,099 --> 00:42:12,900
additional software on top of your image

908
00:42:12,900 --> 00:42:16,859
I can do APK add and install I don't

909
00:42:16,859 --> 00:42:19,800
know Vim GCC music compiler

910
00:42:19,800 --> 00:42:23,180
whatever I want quite easily

911
00:42:23,180 --> 00:42:27,180
so understanding

912
00:42:27,480 --> 00:42:29,820
yeah again understanding how those

913
00:42:29,820 --> 00:42:31,980
pieces of software leverage links kernel

914
00:42:31,980 --> 00:42:34,440
system components and its attributes is

915
00:42:34,440 --> 00:42:36,900
the key and this is the way

916
00:42:36,900 --> 00:42:38,760
as the man who have said it

917
00:42:38,760 --> 00:42:41,940
so I will speak about why I personally

918
00:42:41,940 --> 00:42:43,760
never use Alpine

919
00:42:43,760 --> 00:42:46,859
uh the main reason for that is that

920
00:42:46,859 --> 00:42:48,599
Alpine uses muscle which is an

921
00:42:48,599 --> 00:42:50,339
implementation of the C standard Library

922
00:42:50,339 --> 00:42:53,400
so it doesn't use the traditional glitzy

923
00:42:53,400 --> 00:42:57,060
or the new C library it uses muscle

924
00:42:57,060 --> 00:42:58,980
what muscle does is it's more

925
00:42:58,980 --> 00:43:00,900
lightweight it's performance optimized

926
00:43:00,900 --> 00:43:03,720
so so with DOT it's faster and simpler

927
00:43:03,720 --> 00:43:07,440
than glitzy but it's used uh you know

928
00:43:07,440 --> 00:43:10,380
it's used by other Linux distribution in

929
00:43:10,380 --> 00:43:12,000
glip C is used by other lens

930
00:43:12,000 --> 00:43:14,520
distribution muscle is kind of specific

931
00:43:14,520 --> 00:43:16,140
to Alpine

932
00:43:16,140 --> 00:43:17,400
so

933
00:43:17,400 --> 00:43:20,520
what is the you know the backfire of

934
00:43:20,520 --> 00:43:23,099
using muscle in Alpine because Alpine

935
00:43:23,099 --> 00:43:25,859
size reduction strategy is based around

936
00:43:25,859 --> 00:43:28,140
muscle so they're compiling the whole

937
00:43:28,140 --> 00:43:29,099
stuff

938
00:43:29,099 --> 00:43:31,140
into a different lightweight C library

939
00:43:31,140 --> 00:43:33,599
which is obfuscated it doesn't present

940
00:43:33,599 --> 00:43:35,220
with the same features

941
00:43:35,220 --> 00:43:36,300
so

942
00:43:36,300 --> 00:43:38,339
the first thing that happens is native

943
00:43:38,339 --> 00:43:40,680
call hell software compiled against

944
00:43:40,680 --> 00:43:43,859
muscle runs only on muscle

945
00:43:43,859 --> 00:43:46,740
what is meant by that if I use Alpine

946
00:43:46,740 --> 00:43:48,960
during my cicd pipelines I do compound

947
00:43:48,960 --> 00:43:50,280
native code

948
00:43:50,280 --> 00:43:53,300
I have to run that code again muscle

949
00:43:53,300 --> 00:43:56,099
Lipsy will be immediately segmentation

950
00:43:56,099 --> 00:44:00,900
fault uh so I'm limited if I'm stuck

951
00:44:00,900 --> 00:44:04,079
with alpine I'm stuck for life I I can't

952
00:44:04,079 --> 00:44:07,380
run that on on other C library that's

953
00:44:07,380 --> 00:44:09,000
only for native code we're excluding

954
00:44:09,000 --> 00:44:12,960
Java we're excluding uh yeah other types

955
00:44:12,960 --> 00:44:16,140
of non-native interpretation or uh Tech

956
00:44:16,140 --> 00:44:18,839
Stacks talking about native code C go

957
00:44:18,839 --> 00:44:21,359
rust Etc

958
00:44:21,359 --> 00:44:24,680
next thing node.js and that's JavaScript

959
00:44:24,680 --> 00:44:28,200
node.js goes to the muscle compiled

960
00:44:28,200 --> 00:44:31,200
native code by node Gib so node.js can

961
00:44:31,200 --> 00:44:33,960
call native code by node gear basically

962
00:44:33,960 --> 00:44:36,540
you can access your

963
00:44:36,540 --> 00:44:41,579
um your C classes from JavaScript and

964
00:44:41,579 --> 00:44:43,680
that's done through a library which an

965
00:44:43,680 --> 00:44:46,740
awesome person wrote uh through an npm

966
00:44:46,740 --> 00:44:48,440
it's called not Gip

967
00:44:48,440 --> 00:44:51,660
false big time uh outside of muscle

968
00:44:51,660 --> 00:44:54,599
again we have the same problem and we're

969
00:44:54,599 --> 00:44:57,119
referring to the native called hell so

970
00:44:57,119 --> 00:45:00,839
if I compile node.js native code on

971
00:45:00,839 --> 00:45:02,280
muscle I have to run it on muscle

972
00:45:02,280 --> 00:45:05,880
otherwise I'll get memory uh hell I'll

973
00:45:05,880 --> 00:45:07,800
get segmentation fault immediately I'm

974
00:45:07,800 --> 00:45:11,220
not able to run my software uh on my or

975
00:45:11,220 --> 00:45:14,400
my service outside of muscle

976
00:45:14,400 --> 00:45:17,819
the next thing is very uh I believe it's

977
00:45:17,819 --> 00:45:19,560
it's one of the most interesting at

978
00:45:19,560 --> 00:45:22,260
least for which I have come across and

979
00:45:22,260 --> 00:45:27,300
it's DNS hell so it's funny so uh bear

980
00:45:27,300 --> 00:45:30,240
with me muscle by Design so we're

981
00:45:30,240 --> 00:45:32,880
talking about the muscle C library

982
00:45:32,880 --> 00:45:36,359
does not support DNS over TCP

983
00:45:36,359 --> 00:45:40,980
which means that uh usually you won't

984
00:45:40,980 --> 00:45:44,220
give up a damn about this right uh you

985
00:45:44,220 --> 00:45:47,700
just would notice and the chances to

986
00:45:47,700 --> 00:45:49,160
read that

987
00:45:49,160 --> 00:45:52,079
randomly anywhere is

988
00:45:52,079 --> 00:45:54,079
pretty much zero

989
00:45:54,079 --> 00:45:56,760
uh it will just explode at some point

990
00:45:56,760 --> 00:45:58,079
and

991
00:45:58,079 --> 00:46:01,380
the way DNS are being resolved the

992
00:46:01,380 --> 00:46:04,740
responses and so forth for muscle is

993
00:46:04,740 --> 00:46:07,440
done through UDP it's not through TCP

994
00:46:07,440 --> 00:46:09,119
it's done through UDP

995
00:46:09,119 --> 00:46:14,099
UDP is limited to 520 512 bytes and

996
00:46:14,099 --> 00:46:15,180
that's

997
00:46:15,180 --> 00:46:17,940
you know by by their standards they said

998
00:46:17,940 --> 00:46:20,700
ah that's enough you wouldn't need more

999
00:46:20,700 --> 00:46:21,740
than

1000
00:46:21,740 --> 00:46:25,680
512 bytes which kind of refers to the

1001
00:46:25,680 --> 00:46:27,839
Bill Gates famous saying who would use

1002
00:46:27,839 --> 00:46:31,380
4K of memory or something like that and

1003
00:46:31,380 --> 00:46:33,720
of course there are cases where you need

1004
00:46:33,720 --> 00:46:36,599
more and I want to tell you a story

1005
00:46:36,599 --> 00:46:41,460
about uh a case which we had running

1006
00:46:41,460 --> 00:46:44,700
kubernetes and again a manager came says

1007
00:46:44,700 --> 00:46:46,619
oh well you know I talked with other

1008
00:46:46,619 --> 00:46:49,319
managers they use Alpine and we should

1009
00:46:49,319 --> 00:46:51,119
use Alpine as well they're great they

1010
00:46:51,119 --> 00:46:53,099
stated that everything runs lightweight

1011
00:46:53,099 --> 00:46:55,980
slight ways it's fast awesome let's do

1012
00:46:55,980 --> 00:46:58,079
it let's onboard Alpine

1013
00:46:58,079 --> 00:47:00,000
though uh

1014
00:47:00,000 --> 00:47:03,300
the cluster starts throwing unknown host

1015
00:47:03,300 --> 00:47:06,240
exceptions and basically it seems every

1016
00:47:06,240 --> 00:47:09,960
it was seemed like liver breached we

1017
00:47:09,960 --> 00:47:12,300
were exploited big time we got unknown

1018
00:47:12,300 --> 00:47:13,260
host

1019
00:47:13,260 --> 00:47:16,079
and we had our Network so we verified

1020
00:47:16,079 --> 00:47:18,300
this but nothing worked everything

1021
00:47:18,300 --> 00:47:21,180
stopped working at some point and this

1022
00:47:21,180 --> 00:47:24,480
was the fact due to that kubernetes and

1023
00:47:24,480 --> 00:47:26,819
the internal DNS name resolutions they

1024
00:47:26,819 --> 00:47:31,140
used tremendously long DNS names so you

1025
00:47:31,140 --> 00:47:33,300
have something that's I don't know how

1026
00:47:33,300 --> 00:47:35,700
many you can get tremendously long and

1027
00:47:35,700 --> 00:47:40,040
five uh you know 512 bytes is not enough

1028
00:47:40,040 --> 00:47:43,560
and you just not get your DNS resolved

1029
00:47:43,560 --> 00:47:46,500
in kubernetes if you use Alpine and who

1030
00:47:46,500 --> 00:47:48,180
will have thought about this right what

1031
00:47:48,180 --> 00:47:52,400
are the chances uh and it was just a big

1032
00:47:52,400 --> 00:47:55,079
No-No for us once we have to get this

1033
00:47:55,079 --> 00:47:57,240
and gladly we hit this in an isolated

1034
00:47:57,240 --> 00:47:59,220
environment but at first it was like oh

1035
00:47:59,220 --> 00:48:01,260
God we got hacked

1036
00:48:01,260 --> 00:48:03,660
um we didn't know what what was causing

1037
00:48:03,660 --> 00:48:04,500
this

1038
00:48:04,500 --> 00:48:07,380
and we understood there was this DNS but

1039
00:48:07,380 --> 00:48:09,839
we thought it was DNS hijacking and

1040
00:48:09,839 --> 00:48:12,180
someone took control of our DNS that's

1041
00:48:12,180 --> 00:48:14,460
what we thought

1042
00:48:14,460 --> 00:48:17,579
so we're going to talk about what could

1043
00:48:17,579 --> 00:48:20,760
be a successor to Alpine and it's this

1044
00:48:20,760 --> 00:48:25,380
for Less so what this release is and I

1045
00:48:25,380 --> 00:48:29,280
want to again ask who I've heard or use

1046
00:48:29,280 --> 00:48:33,900
this through us right okay so two people

1047
00:48:33,900 --> 00:48:36,180
excellent

1048
00:48:36,180 --> 00:48:37,140
um

1049
00:48:37,140 --> 00:48:39,599
so this race is not a buzzword

1050
00:48:39,599 --> 00:48:43,079
I know that this bezel attack has you

1051
00:48:43,079 --> 00:48:45,240
know come across a lot of us but it's

1052
00:48:45,240 --> 00:48:48,480
not a buzzword it's the the the right

1053
00:48:48,480 --> 00:48:51,660
approach towards working with containers

1054
00:48:51,660 --> 00:48:54,300
especially uh in the kubernetes

1055
00:48:54,300 --> 00:48:55,800
ecosystem

1056
00:48:55,800 --> 00:48:58,140
so the initial concept is developed by

1057
00:48:58,140 --> 00:48:59,400
Google

1058
00:48:59,400 --> 00:49:03,839
and uh you know they started with some

1059
00:49:03,839 --> 00:49:06,060
of the rules what this release is they

1060
00:49:06,060 --> 00:49:08,040
started you know basically the same

1061
00:49:08,040 --> 00:49:10,440
approach where your manager can say oh

1062
00:49:10,440 --> 00:49:12,119
it let's use something that's smaller in

1063
00:49:12,119 --> 00:49:14,460
size but they were a poll you know they

1064
00:49:14,460 --> 00:49:16,680
were opposing this and said okay we're

1065
00:49:16,680 --> 00:49:19,619
going to develop our own stuff uh maybe

1066
00:49:19,619 --> 00:49:23,099
for usually it fails you know the

1067
00:49:23,099 --> 00:49:24,960
chances to succeed developing your own

1068
00:49:24,960 --> 00:49:25,980
ideas

1069
00:49:25,980 --> 00:49:28,020
have a great chance to fail but they

1070
00:49:28,020 --> 00:49:31,740
succeeded and their concept was right

1071
00:49:31,740 --> 00:49:35,460
so what this relates is it the name

1072
00:49:35,460 --> 00:49:39,599
refers that it is a Linux image without

1073
00:49:39,599 --> 00:49:41,520
the distribution

1074
00:49:41,520 --> 00:49:46,380
but it's not it's not the case right the

1075
00:49:46,380 --> 00:49:49,819
distress image means that you don't have

1076
00:49:49,819 --> 00:49:53,000
any command or anything that's present

1077
00:49:53,000 --> 00:49:56,400
you only have the things that are needed

1078
00:49:56,400 --> 00:49:59,460
so you can run your application no

1079
00:49:59,460 --> 00:50:02,400
matter if that's Java if it's native

1080
00:50:02,400 --> 00:50:07,200
code is go uh whatever you only have the

1081
00:50:07,200 --> 00:50:09,780
capabilities of the software you truly

1082
00:50:09,780 --> 00:50:10,619
need

1083
00:50:10,619 --> 00:50:12,900
and of course you can think of that

1084
00:50:12,900 --> 00:50:16,020
brings the size tremendously the base

1085
00:50:16,020 --> 00:50:18,720
displays images like three megabytes or

1086
00:50:18,720 --> 00:50:20,400
even less

1087
00:50:20,400 --> 00:50:23,040
so there are no package managers

1088
00:50:23,040 --> 00:50:25,200
that's why it's probably not understood

1089
00:50:25,200 --> 00:50:28,260
by many because you want to work with

1090
00:50:28,260 --> 00:50:30,599
package managers so so we thought there

1091
00:50:30,599 --> 00:50:33,000
are no shells or any programs there's no

1092
00:50:33,000 --> 00:50:34,680
less there's no more there's no Vim

1093
00:50:34,680 --> 00:50:36,599
there's no CAD there's no nothing

1094
00:50:36,599 --> 00:50:40,740
you cannot shout just you can run your

1095
00:50:40,740 --> 00:50:44,819
executable that's it in most cases

1096
00:50:44,819 --> 00:50:47,339
and it's perfect for kubernetes clusters

1097
00:50:47,339 --> 00:50:49,380
why is that the case because we are

1098
00:50:49,380 --> 00:50:51,720
limiting the attack surface

1099
00:50:51,720 --> 00:50:55,559
on our clusters so when we're packaging

1100
00:50:55,559 --> 00:50:58,559
our services in a distress image and

1101
00:50:58,559 --> 00:51:00,780
we're bundling this we can ensure that

1102
00:51:00,780 --> 00:51:02,760
we are only shipping the essential stuff

1103
00:51:02,760 --> 00:51:05,520
we don't have overhead on our traffic

1104
00:51:05,520 --> 00:51:06,599
cost

1105
00:51:06,599 --> 00:51:10,200
and we we are not you know

1106
00:51:10,200 --> 00:51:13,559
striking down our ECR repository if

1107
00:51:13,559 --> 00:51:16,079
we're on AWS by pulling tremendously

1108
00:51:16,079 --> 00:51:17,339
huge images

1109
00:51:17,339 --> 00:51:19,920
yeah maybe if you're doing that's

1110
00:51:19,920 --> 00:51:22,700
something that's very specific you might

1111
00:51:22,700 --> 00:51:25,380
you know this might not be the right fit

1112
00:51:25,380 --> 00:51:29,760
for you but this is currently something

1113
00:51:29,760 --> 00:51:31,200
that's

1114
00:51:31,200 --> 00:51:34,260
lost by many that approach it's perfect

1115
00:51:34,260 --> 00:51:37,859
for KR clusters and what Google did is

1116
00:51:37,859 --> 00:51:40,619
it provided different set of distress

1117
00:51:40,619 --> 00:51:43,800
images so you you have static Debian

1118
00:51:43,800 --> 00:51:47,760
bass based noise cell python Java Java

1119
00:51:47,760 --> 00:51:51,119
11 Java 17 node.js etc etc they come in

1120
00:51:51,119 --> 00:51:53,040
four flavors you have Nom root debug

1121
00:51:53,040 --> 00:51:55,680
debug Norm root in latest

1122
00:51:55,680 --> 00:51:56,579
um

1123
00:51:56,579 --> 00:51:58,800
and of course this release image does

1124
00:51:58,800 --> 00:52:03,900
differ in size the static file system is

1125
00:52:03,900 --> 00:52:06,240
around two megabytes if you add some

1126
00:52:06,240 --> 00:52:08,220
additional stuffs like certificates open

1127
00:52:08,220 --> 00:52:11,579
S cell handling Etc and of course Java

1128
00:52:11,579 --> 00:52:14,280
if you are Java Java is a giant it will

1129
00:52:14,280 --> 00:52:17,280
get the size will increase but relative

1130
00:52:17,280 --> 00:52:20,099
to the the things you need it's still

1131
00:52:20,099 --> 00:52:21,960
very small

1132
00:52:21,960 --> 00:52:24,240
so size is relative

1133
00:52:24,240 --> 00:52:28,800
and uh I wanted to demonstrate this with

1134
00:52:28,800 --> 00:52:31,680
something that we

1135
00:52:31,680 --> 00:52:34,619
we basically monitor our images and how

1136
00:52:34,619 --> 00:52:36,200
they behave

1137
00:52:36,200 --> 00:52:39,720
internally through plot and I've picked

1138
00:52:39,720 --> 00:52:40,940
some of the

1139
00:52:40,940 --> 00:52:43,980
images which are publicly available for

1140
00:52:43,980 --> 00:52:47,280
go reading top to bottom go node.js

1141
00:52:47,280 --> 00:52:50,040
nginx and we have developed our own kind

1142
00:52:50,040 --> 00:52:52,079
of a distressed version of those images

1143
00:52:52,079 --> 00:52:54,960
which I will call VMware slash go VMware

1144
00:52:54,960 --> 00:52:57,300
slash node.js vmos nginx those are not

1145
00:52:57,300 --> 00:52:59,940
public images so if you search them they

1146
00:52:59,940 --> 00:53:01,980
only own our private registry

1147
00:53:01,980 --> 00:53:05,339
If You observe the total CV count on the

1148
00:53:05,339 --> 00:53:08,880
public images like for go there 461

1149
00:53:08,880 --> 00:53:12,540
present on March 6. in comparison we

1150
00:53:12,540 --> 00:53:14,760
only had eight

1151
00:53:14,760 --> 00:53:17,400
that's how we have limited and addressed

1152
00:53:17,400 --> 00:53:18,839
the attack surface and it's the same

1153
00:53:18,839 --> 00:53:21,180
version of go

1154
00:53:21,180 --> 00:53:23,280
same goes for node.js and goes for nginx

1155
00:53:23,280 --> 00:53:25,440
and if You observe at the end of the

1156
00:53:25,440 --> 00:53:28,079
graph we basically we address them with

1157
00:53:28,079 --> 00:53:32,040
time and we work very close to zero

1158
00:53:32,040 --> 00:53:34,619
and those include high medium and low as

1159
00:53:34,619 --> 00:53:36,960
well so not only critical

1160
00:53:36,960 --> 00:53:40,200
so so some of the VMware inside and I'm

1161
00:53:40,200 --> 00:53:42,540
going to wrap it down we wanted to

1162
00:53:42,540 --> 00:53:44,099
create a symbiosis between package

1163
00:53:44,099 --> 00:53:45,960
managers because usually when you're

1164
00:53:45,960 --> 00:53:49,140
creating a Docker file you usually do a

1165
00:53:49,140 --> 00:53:51,780
run commands and those run commands

1166
00:53:51,780 --> 00:53:54,540
install different stuff so it's usually

1167
00:53:54,540 --> 00:53:58,020
how a Docker file looks it's one from

1168
00:53:58,020 --> 00:53:59,940
statement something that your image is

1169
00:53:59,940 --> 00:54:02,700
based upon which someone else developed

1170
00:54:02,700 --> 00:54:04,859
then you have a big chunks of a run

1171
00:54:04,859 --> 00:54:08,579
statement usually in one block to be in

1172
00:54:08,579 --> 00:54:10,800
one layer even so it can be a little bit

1173
00:54:10,800 --> 00:54:11,819
lightweight

1174
00:54:11,819 --> 00:54:13,859
and it's

1175
00:54:13,859 --> 00:54:16,200
there so many limitations with Docker

1176
00:54:16,200 --> 00:54:19,500
files that if we wanted to kind of do

1177
00:54:19,500 --> 00:54:21,839
then maybe add something that's better

1178
00:54:21,839 --> 00:54:24,540
than Docker files and again leverage the

1179
00:54:24,540 --> 00:54:26,220
package managers

1180
00:54:26,220 --> 00:54:28,859
so we ditch Docker files and we switch

1181
00:54:28,859 --> 00:54:30,660
to yaml syntaxis

1182
00:54:30,660 --> 00:54:34,520
and it was our plan to save big bucks

1183
00:54:34,520 --> 00:54:38,280
uh as we wanted to reduce our cost of

1184
00:54:38,280 --> 00:54:41,000
goods sold and basically our Cloud bill

1185
00:54:41,000 --> 00:54:44,819
on our Cloud vendor and overall

1186
00:54:44,819 --> 00:54:47,040
technical debt we wanted this to be very

1187
00:54:47,040 --> 00:54:49,020
easily maintainable because if you

1188
00:54:49,020 --> 00:54:51,599
developed uh images

1189
00:54:51,599 --> 00:54:53,760
container images you would observe that

1190
00:54:53,760 --> 00:54:57,619
if you want to bump the parent image

1191
00:54:57,619 --> 00:55:00,599
with and fix address vulnerabilities Etc

1192
00:55:00,599 --> 00:55:04,940
you have to build uh you know

1193
00:55:04,940 --> 00:55:07,800
synchronously the rest of the images so

1194
00:55:07,800 --> 00:55:10,800
it could be I don't know how many uh

1195
00:55:10,800 --> 00:55:14,160
built operations and constant bumps so

1196
00:55:14,160 --> 00:55:17,960
it's one parent another parent child the

1197
00:55:17,960 --> 00:55:21,540
child of a parent so it gets like I have

1198
00:55:21,540 --> 00:55:23,819
to build 10 images if I want to have a

1199
00:55:23,819 --> 00:55:25,859
proper inheritance

1200
00:55:25,859 --> 00:55:26,579
um

1201
00:55:26,579 --> 00:55:28,559
we wanted to have a far more security

1202
00:55:28,559 --> 00:55:31,559
and approach flexible built and dynamic

1203
00:55:31,559 --> 00:55:34,020
images so we something that we refer to

1204
00:55:34,020 --> 00:55:39,000
project Michael and it is a Insight name

1205
00:55:39,000 --> 00:55:42,300
something that we plan to

1206
00:55:42,300 --> 00:55:45,000
develop it's a new way to build distrust

1207
00:55:45,000 --> 00:55:46,800
images if you search on the internet

1208
00:55:46,800 --> 00:55:48,720
about this nothing will pop up something

1209
00:55:48,720 --> 00:55:51,119
that's internal so there's no

1210
00:55:51,119 --> 00:55:53,339
advertisement in this one so we

1211
00:55:53,339 --> 00:55:54,960
something that we understood is Docker

1212
00:55:54,960 --> 00:55:57,059
files are in the past

1213
00:55:57,059 --> 00:56:02,480
and there is one Docker file that's um

1214
00:56:02,640 --> 00:56:04,740
we used to have and we still maintained

1215
00:56:04,740 --> 00:56:08,460
you to several reasons but uh we wanted

1216
00:56:08,460 --> 00:56:10,619
to switch from Docker files to yaml

1217
00:56:10,619 --> 00:56:12,800
syntax I know that it's not very visible

1218
00:56:12,800 --> 00:56:16,140
but we wanted to build an oci image

1219
00:56:16,140 --> 00:56:17,160
against

1220
00:56:17,160 --> 00:56:20,400
ayamo and what is the good what what

1221
00:56:20,400 --> 00:56:23,160
this does to us is that we are no longer

1222
00:56:23,160 --> 00:56:26,280
relying on storage for our images in a

1223
00:56:26,280 --> 00:56:29,640
container registry we can do this

1224
00:56:29,640 --> 00:56:33,720
runtime and if you have watched or seen

1225
00:56:33,720 --> 00:56:36,119
kubernetes in action you can do a port

1226
00:56:36,119 --> 00:56:38,520
specification and you can specify an

1227
00:56:38,520 --> 00:56:41,220
image and there you can specify uh like

1228
00:56:41,220 --> 00:56:43,800
an a repository which is an oci

1229
00:56:43,800 --> 00:56:45,720
repository path towards your image with

1230
00:56:45,720 --> 00:56:48,180
the appropriate tag and so on you can

1231
00:56:48,180 --> 00:56:50,660
just include an yaml file which is local

1232
00:56:50,660 --> 00:56:53,460
and you don't have to pull I don't know

1233
00:56:53,460 --> 00:56:56,940
how many megabytes of image each time

1234
00:56:56,940 --> 00:56:59,640
and you do this runtime it's very

1235
00:56:59,640 --> 00:57:02,880
quickly it's like that and basically it

1236
00:57:02,880 --> 00:57:05,339
calls your package managers

1237
00:57:05,339 --> 00:57:10,980
uh it supports uh dignified uh DNA

1238
00:57:10,980 --> 00:57:16,020
um yum aptitude get uh APK even though

1239
00:57:16,020 --> 00:57:17,640
we don't use it we don't recommend using

1240
00:57:17,640 --> 00:57:19,819
it because it was breached

1241
00:57:19,819 --> 00:57:21,780
and

1242
00:57:21,780 --> 00:57:24,980
yeah usually you you just handle the

1243
00:57:24,980 --> 00:57:28,680
package managers accordingly so we

1244
00:57:28,680 --> 00:57:30,960
wanted to live even you know that was

1245
00:57:30,960 --> 00:57:32,640
the first iteration then the next

1246
00:57:32,640 --> 00:57:35,700
reiteration we wanted to use a cloud

1247
00:57:35,700 --> 00:57:38,460
native Foundation emerging project which

1248
00:57:38,460 --> 00:57:39,920
is build pack

1249
00:57:39,920 --> 00:57:43,020
uh and build packs IO so what build

1250
00:57:43,020 --> 00:57:45,980
packs IO does is it can look into your

1251
00:57:45,980 --> 00:57:49,740
repositories and

1252
00:57:49,740 --> 00:57:53,220
create a Docker file specification

1253
00:57:53,220 --> 00:57:56,040
it's it's an it's a tar at the end your

1254
00:57:56,040 --> 00:57:58,920
image is just an archive but it can

1255
00:57:58,920 --> 00:58:02,700
create the right capabilities in order

1256
00:58:02,700 --> 00:58:05,520
to build or run that specific image

1257
00:58:05,520 --> 00:58:07,680
imagine I I have a C plus plus

1258
00:58:07,680 --> 00:58:10,500
repository with some C code in it I

1259
00:58:10,500 --> 00:58:12,960
throw a bunch of stuff in it and I can

1260
00:58:12,960 --> 00:58:15,000
just uh

1261
00:58:15,000 --> 00:58:17,940
execute build pack against it and that

1262
00:58:17,940 --> 00:58:22,859
will create the the necessary recipe so

1263
00:58:22,859 --> 00:58:25,280
I can create my image without me

1264
00:58:25,280 --> 00:58:28,440
observing what's in there without adding

1265
00:58:28,440 --> 00:58:30,660
additional libraries and so on it does

1266
00:58:30,660 --> 00:58:32,640
it for JavaScript for rust for golang

1267
00:58:32,640 --> 00:58:35,520
for Java C plus plus C whatever you name

1268
00:58:35,520 --> 00:58:38,339
it so we combine this

1269
00:58:38,339 --> 00:58:40,260
and uh

1270
00:58:40,260 --> 00:58:43,400
we don't create a

1271
00:58:43,400 --> 00:58:46,319
atar archive but we create a yaml

1272
00:58:46,319 --> 00:58:48,140
specification which can be broken down

1273
00:58:48,140 --> 00:58:52,339
and you can inherit this leverage this

1274
00:58:52,339 --> 00:58:56,180
separate it into different pieces and

1275
00:58:56,180 --> 00:58:58,099
you can

1276
00:58:58,099 --> 00:59:01,619
of course develop on top of it without

1277
00:59:01,619 --> 00:59:03,839
bundling inch time separate image upload

1278
00:59:03,839 --> 00:59:07,619
and so forth so the process is uh it's

1279
00:59:07,619 --> 00:59:12,260
very unique in an aspect at least

1280
00:59:12,420 --> 00:59:15,900
I haven't seen anything so far and the

1281
00:59:15,900 --> 00:59:20,400
flow usually uses Co which is the code

1282
00:59:20,400 --> 00:59:23,819
build so if you go to GitHub and says uh

1283
00:59:23,819 --> 00:59:26,640
Co it it's something that's used in go

1284
00:59:26,640 --> 00:59:29,960
to produce a minimalistic tire archive

1285
00:59:29,960 --> 00:59:32,520
basically your file system for your

1286
00:59:32,520 --> 00:59:34,980
image and that's consumed by the

1287
00:59:34,980 --> 00:59:37,619
container runtime interface there are

1288
00:59:37,619 --> 00:59:39,059
two separate Sims that you can pick

1289
00:59:39,059 --> 00:59:41,040
either you do a build or you do a

1290
00:59:41,040 --> 00:59:44,099
runtime because the images that I do

1291
00:59:44,099 --> 00:59:45,900
requiring build are totally different

1292
00:59:45,900 --> 00:59:47,579
they're usually bigger they're not for

1293
00:59:47,579 --> 00:59:49,680
production runtime images on the other

1294
00:59:49,680 --> 00:59:52,380
hand means to be you know only the

1295
00:59:52,380 --> 00:59:54,180
things you need so you can run this in

1296
00:59:54,180 --> 00:59:55,380
production

1297
00:59:55,380 --> 00:59:58,140
so we have build we have run and we have

1298
00:59:58,140 --> 01:00:00,299
build packs that does feed what needs to

1299
01:00:00,299 --> 01:00:03,839
be added in terms of packages and we

1300
01:00:03,839 --> 01:00:06,720
have a process where those packages are

1301
01:00:06,720 --> 01:00:09,799
managed by different uh

1302
01:00:09,799 --> 01:00:12,480
package managers and you don't have to

1303
01:00:12,480 --> 01:00:14,280
use run or anything like that what's

1304
01:00:14,280 --> 01:00:16,440
used to be in the docker files Docker

1305
01:00:16,440 --> 01:00:19,380
file is pretty much outdated by now

1306
01:00:19,380 --> 01:00:21,480
um so each package is broken down into

1307
01:00:21,480 --> 01:00:24,780
capabilities and that's that's again a

1308
01:00:24,780 --> 01:00:27,359
feature which we uh it's not something

1309
01:00:27,359 --> 01:00:29,460
that we have invented but we have

1310
01:00:29,460 --> 01:00:32,040
improved upon so if You observe upon

1311
01:00:32,040 --> 01:00:35,460
nginx nginx if you do yum install nginx

1312
01:00:35,460 --> 01:00:38,280
or up to you get install nginx

1313
01:00:38,280 --> 01:00:40,440
um there are different capabilities

1314
01:00:40,440 --> 01:00:42,960
inside that image so nginx is a bundle

1315
01:00:42,960 --> 01:00:46,140
of its sub components sub-components or

1316
01:00:46,140 --> 01:00:50,700
capabilities yeah and we just uh it's

1317
01:00:50,700 --> 01:00:52,319
we're making a compatibility match

1318
01:00:52,319 --> 01:00:54,119
Matrix where we're matching only

1319
01:00:54,119 --> 01:00:56,339
capabilities that we do need for our

1320
01:00:56,339 --> 01:00:58,680
specific package the what is the end

1321
01:00:58,680 --> 01:01:01,079
result okay so what's all this doing

1322
01:01:01,079 --> 01:01:03,119
we're creating an image that's minimum

1323
01:01:03,119 --> 01:01:04,920
in size easily built and easily

1324
01:01:04,920 --> 01:01:08,480
maintainable and in comparison

1325
01:01:08,480 --> 01:01:10,799
you don't need to contain a registry

1326
01:01:10,799 --> 01:01:14,339
this is artifactory Nexus Hub ECR and

1327
01:01:14,339 --> 01:01:15,540
Amazon

1328
01:01:15,540 --> 01:01:18,780
you do just do things on the runtime

1329
01:01:18,780 --> 01:01:21,960
the cacd flows usually repository

1330
01:01:21,960 --> 01:01:24,059
cross-referenced by centralized

1331
01:01:24,059 --> 01:01:27,180
repository it executes a child job prior

1332
01:01:27,180 --> 01:01:29,880
to the build a reproducible Yaman spec

1333
01:01:29,880 --> 01:01:32,040
is created for that required image for

1334
01:01:32,040 --> 01:01:34,319
that specific repository in which is

1335
01:01:34,319 --> 01:01:37,980
using build packs uh it then it consists

1336
01:01:37,980 --> 01:01:39,839
of two yaml file specification one for

1337
01:01:39,839 --> 01:01:41,400
build and one for runtime pick your own

1338
01:01:41,400 --> 01:01:43,920
thing you know we just do both of them

1339
01:01:43,920 --> 01:01:46,440
at the same time our images are assigned

1340
01:01:46,440 --> 01:01:48,480
with cosine and with the appropriate

1341
01:01:48,480 --> 01:01:51,299
time stamp stamp and built on the Fly no

1342
01:01:51,299 --> 01:01:53,520
artifact storage no HDR

1343
01:01:53,520 --> 01:01:57,420
and last but not least uh just for a

1344
01:01:57,420 --> 01:02:00,960
comparison uh size wise image size is

1345
01:02:00,960 --> 01:02:03,720
drastically lower like the Public nginx

1346
01:02:03,720 --> 01:02:08,280
Image is 56 megabytes and by using all

1347
01:02:08,280 --> 01:02:10,140
this novel approach

1348
01:02:10,140 --> 01:02:13,020
we managed to bring it down to 3.8

1349
01:02:13,020 --> 01:02:15,180
megabytes that's fully functional nginx

1350
01:02:15,180 --> 01:02:17,819
as you can include in your uh a

1351
01:02:17,819 --> 01:02:19,980
kubernetes cluster for audio load

1352
01:02:19,980 --> 01:02:22,380
balancing works

1353
01:02:22,380 --> 01:02:27,200
um and you can fed it to your uh K9

1354
01:02:27,200 --> 01:02:31,020
kubernetes definition and you can

1355
01:02:31,020 --> 01:02:33,059
cross-reference it with a timestamp and

1356
01:02:33,059 --> 01:02:34,260
so forth

1357
01:02:34,260 --> 01:02:35,700
so

1358
01:02:35,700 --> 01:02:38,520
that's how I had guys and thank you very

1359
01:02:38,520 --> 01:02:40,740
much for your attention and do you have

1360
01:02:40,740 --> 01:02:43,279
any questions

