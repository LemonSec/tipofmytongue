1
00:00:00,000 --> 00:00:03,650
<font color="#CCCCCC">alright thanks everybody for sticking</font>

2
00:00:01,350 --> 00:00:06,750
around I know it's been<font color="#E5E5E5"> a long weekend</font>

3
00:00:03,650 --> 00:00:08,370
not literally but figuratively so

4
00:00:06,750 --> 00:00:15,780
hopefully<font color="#E5E5E5"> you're all still with me to</font>

5
00:00:08,370 --> 00:00:18,420
<font color="#CCCCCC">talks left to go somebody is all right</font>

6
00:00:15,780 --> 00:00:20,400
so who is this jerk<font color="#E5E5E5"> on stage my name is</font>

7
00:00:18,420 --> 00:00:22,769
<font color="#E5E5E5">Darren camp I do security research for</font>

8
00:00:20,400 --> 00:00:24,509
<font color="#E5E5E5">duo security co.labs team if you don't</font>

9
00:00:22,769 --> 00:00:26,788
know duo we do two-factor authentication

10
00:00:24,510 --> 00:00:29,789
and our labs group does proactive

11
00:00:26,789 --> 00:00:31,980
security research I'll know<font color="#E5E5E5"> quickly that</font>

12
00:00:29,789 --> 00:00:33,840
I did this research with my colleague

13
00:00:31,980 --> 00:00:36,300
<font color="#E5E5E5">Mikhail</font><font color="#CCCCCC"> davidoff who deserves a lot</font><font color="#E5E5E5"> of</font>

14
00:00:33,840 --> 00:00:39,300
the credit he's not here<font color="#CCCCCC"> today but he's</font>

15
00:00:36,300 --> 00:00:40,949
an equal partner in all<font color="#E5E5E5"> of this so what</font>

16
00:00:39,300 --> 00:00:43,890
the heck am I talking about I am talking

17
00:00:40,950 --> 00:00:46,379
<font color="#CCCCCC">about the windows while 64 subsystem</font>

18
00:00:43,890 --> 00:00:49,260
which<font color="#E5E5E5"> I will be tail in a bit and I am</font>

19
00:00:46,379 --> 00:00:53,070
demonstrating a mostly simple ahmet bye

20
00:00:49,260 --> 00:00:54,809
pass using that subsystem can<font color="#CCCCCC"> I get a</font>

21
00:00:53,070 --> 00:00:57,000
show<font color="#CCCCCC"> of hands</font><font color="#E5E5E5"> who knows what emed is or</font>

22
00:00:54,809 --> 00:00:58,320
if anybody's deployed or used it<font color="#CCCCCC"> okay if</font>

23
00:00:57,000 --> 00:00:59,609
<font color="#E5E5E5">you</font><font color="#CCCCCC"> don't</font><font color="#E5E5E5"> know what it</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> I'll mention</font>

24
00:00:58,320 --> 00:01:00,780
<font color="#E5E5E5">that a bit and if I could also go to</font>

25
00:00:59,609 --> 00:01:02,489
show of hands who's got like some

26
00:01:00,780 --> 00:01:04,049
exploit development experience or knows

27
00:01:02,489 --> 00:01:06,360
like what like return oriented

28
00:01:04,049 --> 00:01:10,740
programming and things like that are<font color="#CCCCCC"> ok</font>

29
00:01:06,360 --> 00:01:13,710
<font color="#CCCCCC">few you so if you don't don't worry I'll</font>

30
00:01:10,740 --> 00:01:15,149
also note that this research we figured

31
00:01:13,710 --> 00:01:17,279
it would be a blog post and then it

32
00:01:15,150 --> 00:01:18,960
became a 19-page paper and now<font color="#E5E5E5"> I'm</font>

33
00:01:17,280 --> 00:01:21,630
<font color="#E5E5E5">trying to trying to crush a 19-page</font>

34
00:01:18,960 --> 00:01:25,100
paper into a 30 page or 30 slide

35
00:01:21,630 --> 00:01:25,100
presentation so we'll see how that goes

36
00:01:26,540 --> 00:01:33,810
<font color="#CCCCCC">all right so just</font><font color="#E5E5E5"> a quick refresher x86</font>

37
00:01:31,770 --> 00:01:35,220
64 chips which is what you know most<font color="#E5E5E5"> of</font>

38
00:01:33,810 --> 00:01:38,970
you are running in your laptop's these

39
00:01:35,220 --> 00:01:41,490
days or on your desktops execute in one

40
00:01:38,970 --> 00:01:44,399
of two modes long mode which would be a

41
00:01:41,490 --> 00:01:46,740
<font color="#E5E5E5">64-bit operating system and legacy mode</font>

42
00:01:44,399 --> 00:01:49,290
which<font color="#CCCCCC"> is how you run a 16 or 32 bit</font>

43
00:01:46,740 --> 00:01:51,289
operating system when you're executing

44
00:01:49,290 --> 00:01:53,399
in long mode there's also the

45
00:01:51,290 --> 00:01:57,950
compatibility sub mode which allows you

46
00:01:53,399 --> 00:01:57,950
to execute 16 and 32 bit pieces of code

47
00:01:58,310 --> 00:02:05,009
so windows on<font color="#E5E5E5"> Windows is the or the</font>

48
00:02:02,100 --> 00:02:08,788
while 64 subsystem is how<font color="#E5E5E5"> windows</font>

49
00:02:05,009 --> 00:02:10,500
execute 32-bit software on a 64-bit

50
00:02:08,788 --> 00:02:13,049
operating system this<font color="#CCCCCC"> is what keeps all</font>

51
00:02:10,500 --> 00:02:15,270
of your you know 32-bit things running

52
00:02:13,050 --> 00:02:17,520
it's largely transparent to the

53
00:02:15,270 --> 00:02:18,990
applications that<font color="#CCCCCC"> are executing in that</font>

54
00:02:17,520 --> 00:02:20,640
environment however you can

55
00:02:18,990 --> 00:02:22,740
programmatically determine whether or

56
00:02:20,640 --> 00:02:24,299
<font color="#E5E5E5">not you're running inside of it it does</font>

57
00:02:22,740 --> 00:02:27,620
have implications<font color="#E5E5E5"> to how the registry</font>

58
00:02:24,300 --> 00:02:30,570
behaves how<font color="#E5E5E5"> file system i/o works</font>

59
00:02:27,620 --> 00:02:31,920
exception handling and how system calls

60
00:02:30,570 --> 00:02:33,450
or dispatch which is probably the<font color="#CCCCCC"> most</font>

61
00:02:31,920 --> 00:02:36,119
important thing for this<font color="#E5E5E5"> presentation</font>

62
00:02:33,450 --> 00:02:43,649
and it is<font color="#CCCCCC"> absolutely holding back system</font>

63
00:02:36,120 --> 00:02:46,020
security overall so there's a<font color="#E5E5E5"> lot of</font>

64
00:02:43,650 --> 00:02:47,700
prior work dealing with this subsystem I

65
00:02:46,020 --> 00:02:49,170
absolutely not the first person to

66
00:02:47,700 --> 00:02:53,310
tackle this and certainly won't be the

67
00:02:49,170 --> 00:02:55,019
last the closest presentation related to

68
00:02:53,310 --> 00:02:57,320
what I'm talking<font color="#CCCCCC"> about today is the</font>

69
00:02:55,020 --> 00:03:00,770
first one why user mode hooking sucks

70
00:02:57,320 --> 00:03:03,600
<font color="#CCCCCC">bypassing comodo internet security in</font>

71
00:03:00,770 --> 00:03:06,150
2003 @ can SEC West<font color="#CCCCCC"> and</font><font color="#E5E5E5"> Vancouver there</font>

72
00:03:03,600 --> 00:03:09,650
was a presentation on by passing a SLR

73
00:03:06,150 --> 00:03:12,200
and data execution prevention using a

74
00:03:09,650 --> 00:03:14,520
artifact of how this subsystem works

75
00:03:12,200 --> 00:03:18,030
really elegant attack which is now

76
00:03:14,520 --> 00:03:21,239
defunct there was a presentation at

77
00:03:18,030 --> 00:03:24,450
source Boston this year on developing

78
00:03:21,239 --> 00:03:26,550
interesting<font color="#E5E5E5"> Rob gadgets that abuse the</font>

79
00:03:24,450 --> 00:03:29,820
<font color="#E5E5E5">wild 64 subsystem at least that was part</font>

80
00:03:26,550 --> 00:03:32,480
of<font color="#E5E5E5"> the presentation and then a</font>

81
00:03:29,820 --> 00:03:34,739
presentation at source seattle on

82
00:03:32,480 --> 00:03:36,780
<font color="#E5E5E5">obfuscation to defeat static analysis</font>

83
00:03:34,739 --> 00:03:39,810
using cross mode coding which is<font color="#E5E5E5"> a super</font>

84
00:03:36,780 --> 00:03:41,970
long presentation name it beats mine but

85
00:03:39,810 --> 00:03:43,830
the point<font color="#CCCCCC"> here</font><font color="#E5E5E5"> is that you know</font>

86
00:03:41,970 --> 00:03:45,330
switching between modes can<font color="#CCCCCC"> confuse a</font>

87
00:03:43,830 --> 00:03:47,520
whole bunch of static analysis and

88
00:03:45,330 --> 00:03:49,440
dynamic analysis tools and of course

89
00:03:47,520 --> 00:03:51,120
<font color="#CCCCCC">there's a ton of different blog posts on</font>

90
00:03:49,440 --> 00:03:53,310
how the sub system works and different

91
00:03:51,120 --> 00:04:00,390
ways<font color="#E5E5E5"> to abuse it and</font><font color="#CCCCCC"> we're things</font><font color="#E5E5E5"> to do</font>

92
00:03:53,310 --> 00:04:02,610
with<font color="#CCCCCC"> it so why does this matter we took</font>

93
00:04:00,390 --> 00:04:04,380
a look at some<font color="#E5E5E5"> real-world authentication</font>

94
00:04:02,610 --> 00:04:06,120
data talking to our service I can't

95
00:04:04,380 --> 00:04:08,160
share the full numbers with you but I

96
00:04:06,120 --> 00:04:10,950
can assure you they're<font color="#CCCCCC"> sizeable eighty</font>

97
00:04:08,160 --> 00:04:12,420
percent of the<font color="#E5E5E5"> browsers based on the</font>

98
00:04:10,950 --> 00:04:15,149
user agent authenticating with our

99
00:04:12,420 --> 00:04:18,750
<font color="#E5E5E5">service or 32-bit processes running on</font>

100
00:04:15,150 --> 00:04:19,980
64-bit versions of<font color="#E5E5E5"> Windows so let's</font>

101
00:04:18,750 --> 00:04:26,400
think<font color="#E5E5E5"> about this a little bit the year</font>

102
00:04:19,980 --> 00:04:26,820
is 2015 the first x86 64 chips were

103
00:04:26,400 --> 00:04:29,520
released

104
00:04:26,820 --> 00:04:32,310
by md in 2003 and eighty percent of

105
00:04:29,520 --> 00:04:35,010
browsers are still 32 bit software it's

106
00:04:32,310 --> 00:04:36,960
<font color="#E5E5E5">kind of a sad state of affairs and of</font>

107
00:04:35,010 --> 00:04:39,420
course sixteen percent of those were

108
00:04:36,960 --> 00:04:44,669
actually just share<font color="#CCCCCC"> 32 bit and four</font>

109
00:04:39,420 --> 00:04:47,160
percent<font color="#CCCCCC"> claim to be 64-bit processes so</font>

110
00:04:44,670 --> 00:04:50,430
why is<font color="#CCCCCC"> this valuable to attackers I</font><font color="#E5E5E5"> kind</font>

111
00:04:47,160 --> 00:04:52,350
<font color="#E5E5E5">of briefly</font><font color="#CCCCCC"> mentioned this so there</font><font color="#E5E5E5"> are</font>

112
00:04:50,430 --> 00:04:54,000
some subsystem yo singh<font color="#CCCCCC"> Chrissy's in the</font>

113
00:04:52,350 --> 00:04:55,920
past that<font color="#E5E5E5"> have decreased overall system</font>

114
00:04:54,000 --> 00:04:59,090
security that was the can<font color="#CCCCCC"> sec</font>

115
00:04:55,920 --> 00:05:01,680
presentation that<font color="#E5E5E5"> i was</font><font color="#CCCCCC"> talking about</font>

116
00:04:59,090 --> 00:05:03,810
when<font color="#E5E5E5"> it</font><font color="#CCCCCC"> comes to developing rob chains</font>

117
00:05:01,680 --> 00:05:05,310
you're limited to what instructions are

118
00:05:03,810 --> 00:05:06,540
available to you you<font color="#E5E5E5"> know by switching</font>

119
00:05:05,310 --> 00:05:09,780
modes you get a different interpretation

120
00:05:06,540 --> 00:05:13,020
so you've got<font color="#E5E5E5"> more potential Rob gadgets</font>

121
00:05:09,780 --> 00:05:15,900
available to you anti emulation and

122
00:05:13,020 --> 00:05:19,530
obfuscation opportunities right so when

123
00:05:15,900 --> 00:05:22,080
I say anti emulations or obfuscation

124
00:05:19,530 --> 00:05:25,159
think about things like a piece of shell

125
00:05:22,080 --> 00:05:28,620
code that does a pivot to 64-bit mode

126
00:05:25,160 --> 00:05:30,300
decodes with an 8-byte xor key and then

127
00:05:28,620 --> 00:05:32,330
pivots back stuff that really trivial

128
00:05:30,300 --> 00:05:34,620
emulators are not going to handle well

129
00:05:32,330 --> 00:05:37,200
and of<font color="#E5E5E5"> course the focus of this</font>

130
00:05:34,620 --> 00:05:39,530
presentation is on bypassing quote by

131
00:05:37,200 --> 00:05:41,580
passing hooks in protected mode code

132
00:05:39,530 --> 00:05:45,929
which I'll get into in a little bit here

133
00:05:41,580 --> 00:05:47,550
so<font color="#CCCCCC"> some high-level internals the</font>

134
00:05:45,930 --> 00:05:49,350
<font color="#E5E5E5">subsystem is implemented implemented</font>

135
00:05:47,550 --> 00:05:53,310
entirely in user mode there's no<font color="#E5E5E5"> support</font>

136
00:05:49,350 --> 00:05:56,340
from the colonel all while 64 processes

137
00:05:53,310 --> 00:05:57,510
have for 64-bit modules in them the

138
00:05:56,340 --> 00:05:59,760
<font color="#E5E5E5">first three obviously make up that</font>

139
00:05:57,510 --> 00:06:02,849
subsystem and then the fourth being a

140
00:05:59,760 --> 00:06:06,420
64-bit copy of NT dll which contains all

141
00:06:02,850 --> 00:06:10,020
of<font color="#E5E5E5"> your all of your system calls and</font>

142
00:06:06,420 --> 00:06:12,090
things like that<font color="#E5E5E5"> so the while 64 dll is</font>

143
00:06:10,020 --> 00:06:13,859
the subsystem in entry point it's

144
00:06:12,090 --> 00:06:15,989
responsible for<font color="#CCCCCC"> marshalling system calls</font>

145
00:06:13,860 --> 00:06:18,090
exceptions<font color="#CCCCCC"> filesystem and registry</font>

146
00:06:15,990 --> 00:06:21,660
redirection that's the big one the

147
00:06:18,090 --> 00:06:25,020
<font color="#CCCCCC">second is primarily there to support</font>

148
00:06:21,660 --> 00:06:28,800
mode switches saving<font color="#CCCCCC"> cpu context</font><font color="#E5E5E5"> to and</font>

149
00:06:25,020 --> 00:06:31,680
from 32<font color="#E5E5E5"> and 64-bit mode and then the</font>

150
00:06:28,800 --> 00:06:33,480
<font color="#E5E5E5">while 64 wing dll does additional</font>

151
00:06:31,680 --> 00:06:35,520
<font color="#E5E5E5">marshalling for windowing and console</font>

152
00:06:33,480 --> 00:06:37,500
subsystems the details of how those

153
00:06:35,520 --> 00:06:39,510
behave isn't too important for this

154
00:06:37,500 --> 00:06:40,200
presentation but<font color="#E5E5E5"> i'll let you keep that</font>

155
00:06:39,510 --> 00:06:42,330
<font color="#E5E5E5">in mind</font>

156
00:06:40,200 --> 00:06:44,969
and then of course<font color="#E5E5E5"> there are 32-bit</font>

157
00:06:42,330 --> 00:06:46,710
copies of and 64-bit copies of important

158
00:06:44,970 --> 00:06:49,710
system management structures so each

159
00:06:46,710 --> 00:06:51,989
thread has a 32 and<font color="#E5E5E5"> 64-bit copy of the</font>

160
00:06:49,710 --> 00:06:54,330
threat environment block there's a 64

161
00:06:51,990 --> 00:06:56,670
and 32 bit process environment block and

162
00:06:54,330 --> 00:07:00,450
<font color="#E5E5E5">then there's 32 and 64-bit stacks and</font>

163
00:06:56,670 --> 00:07:03,000
keeps I'll let this slide ride for a

164
00:07:00,450 --> 00:07:04,320
little bit I stole this from a Microsoft

165
00:07:03,000 --> 00:07:06,900
presentation but this is<font color="#E5E5E5"> sort of how the</font>

166
00:07:04,320 --> 00:07:08,640
different components interact so the top

167
00:07:06,900 --> 00:07:09,659
you've got curl mode components and at

168
00:07:08,640 --> 00:07:13,610
the bottom we've got user mode

169
00:07:09,660 --> 00:07:16,920
components as you can see all<font color="#E5E5E5"> the</font>

170
00:07:13,610 --> 00:07:20,730
interaction proxies through well 64 and

171
00:07:16,920 --> 00:07:24,350
pops out at the end at anti dll with the

172
00:07:20,730 --> 00:07:24,350
exception<font color="#CCCCCC"> of the windowing subsystem</font>

173
00:07:27,350 --> 00:07:36,270
little liquid courage<font color="#CCCCCC"> all right so this</font>

174
00:07:33,270 --> 00:07:38,729
is what things look like in memory this

175
00:07:36,270 --> 00:07:41,789
is important for<font color="#CCCCCC"> X for the exploitation</font>

176
00:07:38,730 --> 00:07:44,160
stuff I'm going to demo so the tab and

177
00:07:41,790 --> 00:07:46,110
the peb<font color="#CCCCCC"> are it fixed offsets from</font><font color="#E5E5E5"> their</font>

178
00:07:44,160 --> 00:07:48,810
32-bit counterparts<font color="#E5E5E5"> so despite being</font>

179
00:07:46,110 --> 00:07:53,790
subject to address of a dress layout

180
00:07:48,810 --> 00:07:56,550
randomization or a SLR you can if you

181
00:07:53,790 --> 00:07:58,050
<font color="#CCCCCC">can find their 32-bit the 32-bit</font>

182
00:07:56,550 --> 00:08:01,830
structure you can<font color="#E5E5E5"> find the 64-bit</font>

183
00:07:58,050 --> 00:08:03,330
structure on<font color="#E5E5E5"> Windows 7 all of those</font>

184
00:08:01,830 --> 00:08:05,640
modules I was talking<font color="#CCCCCC"> about the load</font>

185
00:08:03,330 --> 00:08:08,760
order is fixed<font color="#E5E5E5"> so again they're subject</font>

186
00:08:05,640 --> 00:08:10,169
to a SLR but if you can find one of<font color="#E5E5E5"> them</font>

187
00:08:08,760 --> 00:08:13,039
everything is going to be predictably

188
00:08:10,170 --> 00:08:17,490
aligned from there additionally the

189
00:08:13,040 --> 00:08:20,760
<font color="#CCCCCC">64-bit copy of NT dll is always located</font>

190
00:08:17,490 --> 00:08:23,100
in a dress before below 4 gigabytes and

191
00:08:20,760 --> 00:08:25,710
it is at a fixed offset from the 32-bit

192
00:08:23,100 --> 00:08:27,240
copy of NT dll this particular factor

193
00:08:25,710 --> 00:08:30,330
was big and being able to make this

194
00:08:27,240 --> 00:08:31,950
exploit work easily on<font color="#CCCCCC"> Windows 8 this is</font>

195
00:08:30,330 --> 00:08:33,620
not true whether<font color="#CCCCCC"> or</font><font color="#E5E5E5"> not this</font><font color="#CCCCCC"> is an</font>

196
00:08:31,950 --> 00:08:35,819
explicit mitigation or just a

197
00:08:33,620 --> 00:08:38,880
architectural change microsoft made<font color="#CCCCCC"> i</font>

198
00:08:35,820 --> 00:08:41,849
don't know but<font color="#CCCCCC"> it's except it's it's</font>

199
00:08:38,880 --> 00:08:45,270
much more<font color="#CCCCCC"> difficult to pull this off on</font>

200
00:08:41,849 --> 00:08:48,480
<font color="#E5E5E5">windows 8 it's definitely possible but</font>

201
00:08:45,270 --> 00:08:51,030
that load order changes and the copy of

202
00:08:48,480 --> 00:08:54,890
NT dll 64 is always a map than an

203
00:08:51,030 --> 00:08:54,890
address above the above<font color="#E5E5E5"> 4 gigabytes</font>

204
00:08:58,040 --> 00:09:02,370
<font color="#CCCCCC">okay so long mode transition so how does</font>

205
00:09:00,630 --> 00:09:06,270
how<font color="#CCCCCC"> does this</font><font color="#E5E5E5"> stuff switch back and</font>

206
00:09:02,370 --> 00:09:10,140
forth windows uses<font color="#E5E5E5"> two special segment</font>

207
00:09:06,270 --> 00:09:13,170
numbers hex 23 for 32-bit and hex 33 for

208
00:09:10,140 --> 00:09:15,839
64-bit to switch between modes and this

209
00:09:13,170 --> 00:09:19,529
works with overlapping code segments so

210
00:09:15,839 --> 00:09:22,770
a code segment is determined<font color="#CCCCCC"> whether or</font>

211
00:09:19,529 --> 00:09:24,570
not it's 64 or 32 bit by the<font color="#E5E5E5"> L bit in</font>

212
00:09:22,770 --> 00:09:27,890
the segment descriptor if it's set it's

213
00:09:24,570 --> 00:09:30,330
64 bit if it's not<font color="#E5E5E5"> it's a 32-bit segment</font>

214
00:09:27,890 --> 00:09:33,870
all of these transitions are generally

215
00:09:30,330 --> 00:09:35,910
invoked through a far jump or call so as

216
00:09:33,870 --> 00:09:38,130
you can see here this is<font color="#CCCCCC"> the this is the</font>

217
00:09:35,910 --> 00:09:41,400
function that is typically<font color="#CCCCCC"> used to</font>

218
00:09:38,130 --> 00:09:43,290
transition modes and you'll see the hex

219
00:09:41,400 --> 00:09:45,089
33 at the beginning so that's the

220
00:09:43,290 --> 00:09:47,279
special segment number anything after

221
00:09:45,089 --> 00:09:54,390
that branch would be executed as 64<font color="#E5E5E5"> bit</font>

222
00:09:47,279 --> 00:09:56,160
code so system call invocation so if you

223
00:09:54,390 --> 00:10:00,720
think<font color="#E5E5E5"> back to the diagram I just showed</font>

224
00:09:56,160 --> 00:10:02,699
<font color="#CCCCCC">you this is this is sort of what it</font>

225
00:10:00,720 --> 00:10:05,070
looks like in code it's not the complete

226
00:10:02,700 --> 00:10:07,200
process but you can see there is<font color="#CCCCCC"> a</font>

227
00:10:05,070 --> 00:10:09,779
function pointer inside the thread

228
00:10:07,200 --> 00:10:11,190
environment block so a call<font color="#E5E5E5"> is made to</font>

229
00:10:09,779 --> 00:10:14,459
that function pointer which switches

230
00:10:11,190 --> 00:10:19,140
modes and from there there's<font color="#E5E5E5"> a bunch of</font>

231
00:10:14,459 --> 00:10:20,400
plumbing that basically deals with the

232
00:10:19,140 --> 00:10:21,900
different calling conventions and

233
00:10:20,400 --> 00:10:23,990
converting arguments and so on<font color="#E5E5E5"> and so</font>

234
00:10:21,900 --> 00:10:27,209
forth but that all ends up you know

235
00:10:23,990 --> 00:10:33,330
proxying through to the 64-bit copy of

236
00:10:27,209 --> 00:10:34,920
that system call after you switch<font color="#E5E5E5"> after</font>

237
00:10:33,330 --> 00:10:37,920
you switch modes you get<font color="#E5E5E5"> access to the</font>

238
00:10:34,920 --> 00:10:40,560
<font color="#E5E5E5">higher order registers this is not</font>

239
00:10:37,920 --> 00:10:42,630
necessary for pulling this trick off but

240
00:10:40,560 --> 00:10:44,939
it's useful especially on<font color="#E5E5E5"> Windows 8 or</font>

241
00:10:42,630 --> 00:10:47,070
<font color="#E5E5E5">10 the high-order registers contain a</font>

242
00:10:44,940 --> 00:10:49,320
lot<font color="#E5E5E5"> of useful information that will help</font>

243
00:10:47,070 --> 00:10:51,089
you gain context after you transition

244
00:10:49,320 --> 00:10:53,190
mode so this is really good if you need

245
00:10:51,089 --> 00:10:58,980
to do continuation of execution with

246
00:10:53,190 --> 00:11:00,839
your exploit or repair program state but

247
00:10:58,980 --> 00:11:04,730
like<font color="#E5E5E5"> I said it's not that's not</font>

248
00:11:00,839 --> 00:11:04,730
<font color="#E5E5E5">necessary for for everything</font>

249
00:11:05,270 --> 00:11:11,430
so by passing hooks so this is the meat

250
00:11:08,220 --> 00:11:14,100
of things first<font color="#E5E5E5"> and foremost this is a</font>

251
00:11:11,430 --> 00:11:15,839
pretty old trick like this concept dates

252
00:11:14,100 --> 00:11:17,880
back to like the<font color="#CCCCCC"> anti virtual dost</font>

253
00:11:15,840 --> 00:11:21,270
machine<font color="#E5E5E5"> and like old versions of Windows</font>

254
00:11:17,880 --> 00:11:24,720
NT this is not<font color="#E5E5E5"> really a new idea i'm</font>

255
00:11:21,270 --> 00:11:27,240
just putting a new spin on it the key

256
00:11:24,720 --> 00:11:29,600
<font color="#CCCCCC">here is that any time you have some sort</font>

257
00:11:27,240 --> 00:11:31,770
<font color="#CCCCCC">of security tool like an antivirus</font>

258
00:11:29,600 --> 00:11:33,390
Prioress or something like that they're

259
00:11:31,770 --> 00:11:35,040
gonna want to hook functionality inside

260
00:11:33,390 --> 00:11:36,569
things like anti dll because this is

261
00:11:35,040 --> 00:11:39,060
where<font color="#CCCCCC"> all your</font><font color="#E5E5E5"> low-level functionality</font>

262
00:11:36,570 --> 00:11:40,800
happens right module loading creating

263
00:11:39,060 --> 00:11:45,420
new processes all the things<font color="#CCCCCC"> that</font>

264
00:11:40,800 --> 00:11:48,420
attackers like to abuse the 64-bit copy

265
00:11:45,420 --> 00:11:51,300
in a 32-bit you're in a while 64 process

266
00:11:48,420 --> 00:11:53,219
i should say is often difficult or

267
00:11:51,300 --> 00:11:55,859
impractical the hook for a variety of

268
00:11:53,220 --> 00:11:58,040
architectural reasons this has been<font color="#E5E5E5"> used</font>

269
00:11:55,860 --> 00:12:00,540
in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> past as</font><font color="#E5E5E5"> i said that prior</font>

270
00:11:58,040 --> 00:12:02,880
presentation<font color="#E5E5E5"> i talked</font><font color="#CCCCCC"> about to defeat</font>

271
00:12:00,540 --> 00:12:05,939
things like antivirus but<font color="#E5E5E5"> i'm going to</font>

272
00:12:02,880 --> 00:12:08,250
<font color="#E5E5E5">do this in a shellcode payload which can</font>

273
00:12:05,940 --> 00:12:13,470
be a little bit finicky but you can make

274
00:12:08,250 --> 00:12:15,000
<font color="#E5E5E5">it work in practice so II met for those</font>

275
00:12:13,470 --> 00:12:17,460
of<font color="#E5E5E5"> you who</font><font color="#CCCCCC"> don't know II met is the</font>

276
00:12:15,000 --> 00:12:20,310
enhanced mitigation experience toolkit

277
00:12:17,460 --> 00:12:22,530
it is a runtime exploit mitigation tool

278
00:12:20,310 --> 00:12:25,739
provided by Microsoft what it does is

279
00:12:22,530 --> 00:12:28,020
inject a dll into the process that<font color="#CCCCCC"> you</font>

280
00:12:25,740 --> 00:12:31,680
want to protect<font color="#E5E5E5"> and that DLL hooks a</font>

281
00:12:28,020 --> 00:12:33,540
bunch of functionality inside ntg ll it

282
00:12:31,680 --> 00:12:35,729
sets a bunch of hardware breakpoints it

283
00:12:33,540 --> 00:12:37,380
does a bunch<font color="#E5E5E5"> of</font><font color="#CCCCCC"> stuff to intercept and</font>

284
00:12:35,730 --> 00:12:40,730
try and inspect things that you know

285
00:12:37,380 --> 00:12:43,650
exploit dev<font color="#E5E5E5"> like two of you abuse this</font>

286
00:12:40,730 --> 00:12:45,870
<font color="#CCCCCC">will break most off-the-shelf exploits</font>

287
00:12:43,650 --> 00:12:47,670
like pretty much anything in<font color="#CCCCCC"> metasploit</font>

288
00:12:45,870 --> 00:12:49,800
or something like that<font color="#E5E5E5"> you apply II met</font>

289
00:12:47,670 --> 00:12:53,310
to the process it probably won't work

290
00:12:49,800 --> 00:12:55,800
out<font color="#E5E5E5"> of the box and the key here</font><font color="#CCCCCC"> is that</font>

291
00:12:53,310 --> 00:13:01,079
most of the mitigations use<font color="#E5E5E5"> function</font>

292
00:12:55,800 --> 00:13:05,130
hooks and those hooks do not affect the

293
00:13:01,080 --> 00:13:09,780
64-bit copy of NT dll so look mom no

294
00:13:05,130 --> 00:13:11,370
hooks so this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the 32-bit copy that</font>

295
00:13:09,780 --> 00:13:13,260
has been intercepted by e met you can

296
00:13:11,370 --> 00:13:15,420
see that<font color="#CCCCCC"> the</font><font color="#E5E5E5"> function prologue has been</font>

297
00:13:13,260 --> 00:13:17,610
overwritten by an unconditional jump

298
00:13:15,420 --> 00:13:19,110
that jumped lands<font color="#E5E5E5"> in sight emed</font>

299
00:13:17,610 --> 00:13:21,000
where it does a bunch of additional

300
00:13:19,110 --> 00:13:23,010
processing to do sanity checks on the

301
00:13:21,000 --> 00:13:25,440
process if it if it thinks that things

302
00:13:23,010 --> 00:13:28,430
aren't saying it bails out if you look

303
00:13:25,440 --> 00:13:30,450
<font color="#E5E5E5">at</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> in the same process the 64-bit</font>

304
00:13:28,430 --> 00:13:32,069
implementation which is what ends up

305
00:13:30,450 --> 00:13:34,350
getting called at the very end there's

306
00:13:32,070 --> 00:13:41,970
obviously<font color="#CCCCCC"> no hook it's just a raw system</font>

307
00:13:34,350 --> 00:13:44,070
call so we got this to work sort of as a

308
00:13:41,970 --> 00:13:45,570
trial in a very contrived way and we

309
00:13:44,070 --> 00:13:46,769
<font color="#CCCCCC">decided that</font><font color="#E5E5E5"> you know we wanted to do</font>

310
00:13:45,570 --> 00:13:50,450
this<font color="#E5E5E5"> for real let's take a real-world</font>

311
00:13:46,769 --> 00:13:52,680
vulnerability and see if we can do this

312
00:13:50,450 --> 00:13:56,730
turns out getting it to work with a real

313
00:13:52,680 --> 00:13:59,459
vulnerability is a little harder but we

314
00:13:56,730 --> 00:14:01,769
got it to go we took a<font color="#CCCCCC"> metasploit</font>

315
00:13:59,459 --> 00:14:04,739
exploit that is obviously publicly

316
00:14:01,769 --> 00:14:08,430
available for a use after free flaw

317
00:14:04,740 --> 00:14:10,050
affecting<font color="#E5E5E5"> Adobe Flash you guys think</font>

318
00:14:08,430 --> 00:14:12,899
back to the rust presentation yesterday

319
00:14:10,050 --> 00:14:15,300
that was a dangling pointer example use

320
00:14:12,899 --> 00:14:16,620
after freefly is a dangling pointer so

321
00:14:15,300 --> 00:14:18,589
this<font color="#CCCCCC"> is exactly the kind</font><font color="#E5E5E5"> of stuff that</font>

322
00:14:16,620 --> 00:14:21,269
he was talking about trying<font color="#E5E5E5"> to prevent</font>

323
00:14:18,589 --> 00:14:23,640
<font color="#E5E5E5">I'm not going to go deep into the bug</font>

324
00:14:21,269 --> 00:14:25,290
but if you want to<font color="#CCCCCC"> know more about</font><font color="#E5E5E5"> it</font>

325
00:14:23,640 --> 00:14:27,390
there's really<font color="#E5E5E5"> great analysis from both</font>

326
00:14:25,290 --> 00:14:30,990
core security technologies and trend

327
00:14:27,390 --> 00:14:32,459
micro in order to make the exploit work

328
00:14:30,990 --> 00:14:34,350
we only had to make rather<font color="#E5E5E5"> minor</font>

329
00:14:32,459 --> 00:14:37,529
modifications we had to give it the

330
00:14:34,350 --> 00:14:42,120
<font color="#E5E5E5">ability to understand and parse pe32</font>

331
00:14:37,529 --> 00:14:44,670
plus modules being the 64-bit version of

332
00:14:42,120 --> 00:14:47,459
<font color="#CCCCCC">PE files which is portable executable or</font>

333
00:14:44,670 --> 00:14:49,050
the<font color="#CCCCCC"> X cubed format windows uses and of</font>

334
00:14:47,459 --> 00:14:53,160
course<font color="#CCCCCC"> we had to change how the rob</font>

335
00:14:49,050 --> 00:14:56,519
chain worked so a little<font color="#E5E5E5"> more in the</font>

336
00:14:53,160 --> 00:14:58,140
original exploit there was a<font color="#E5E5E5"> really</font>

337
00:14:56,519 --> 00:15:02,279
popular technique that was<font color="#CCCCCC"> recently</font>

338
00:14:58,140 --> 00:15:04,529
killed that uses it sprays the<font color="#CCCCCC"> heap with</font>

339
00:15:02,279 --> 00:15:06,750
vectors and then you smash the size of

340
00:15:04,529 --> 00:15:08,279
one of them<font color="#E5E5E5"> and what happens is you're</font>

341
00:15:06,750 --> 00:15:10,680
able to use<font color="#CCCCCC"> that to do an</font><font color="#E5E5E5"> outbound read</font>

342
00:15:08,279 --> 00:15:12,600
so you can use this as an<font color="#E5E5E5"> Oracle to</font>

343
00:15:10,680 --> 00:15:14,699
defeat things like a SLR you can read

344
00:15:12,600 --> 00:15:16,170
our betray process memory and figure out

345
00:15:14,699 --> 00:15:18,390
where<font color="#E5E5E5"> things are this is sort of the</font>

346
00:15:16,170 --> 00:15:21,449
<font color="#E5E5E5">first stage of the exploit it uses that</font>

347
00:15:18,390 --> 00:15:25,500
<font color="#E5E5E5">to scan backwards through memory looking</font>

348
00:15:21,449 --> 00:15:27,390
for the header of the flash module in

349
00:15:25,500 --> 00:15:30,240
memory and then from<font color="#CCCCCC"> there you can use</font>

350
00:15:27,390 --> 00:15:31,209
the import & exports it exports sections

351
00:15:30,240 --> 00:15:34,089
to forward

352
00:15:31,209 --> 00:15:36,969
all other modules and other functions<font color="#CCCCCC"> in</font>

353
00:15:34,089 --> 00:15:40,839
memory to build your payload and to

354
00:15:36,970 --> 00:15:43,929
build<font color="#E5E5E5"> Rob gadgets it doesn't actually</font>

355
00:15:40,839 --> 00:15:47,170
work on well 64 process of processes out

356
00:15:43,929 --> 00:15:51,160
of the box it's fairly easy to fix it's

357
00:15:47,170 --> 00:15:52,990
just a broken gadget search this<font color="#E5E5E5"> is</font>

358
00:15:51,160 --> 00:15:55,360
pretty much<font color="#CCCCCC"> the bar these days for like</font>

359
00:15:52,990 --> 00:15:57,850
a modern browser vulnerability right so

360
00:15:55,360 --> 00:15:59,709
you you build an information leak so

361
00:15:57,850 --> 00:16:02,980
that you can understand<font color="#E5E5E5"> the layout of</font>

362
00:15:59,709 --> 00:16:05,439
memory you discover your<font color="#E5E5E5"> Rob gadgets</font>

363
00:16:02,980 --> 00:16:07,689
assemble your you know your funky chain

364
00:16:05,439 --> 00:16:09,550
of things to disable you know

365
00:16:07,689 --> 00:16:13,029
non-executable memory permissions and

366
00:16:09,550 --> 00:16:15,189
stuff like that you cause what's called

367
00:16:13,029 --> 00:16:16,839
a stack pivot which means you know<font color="#E5E5E5"> often</font>

368
00:16:15,189 --> 00:16:18,490
you're taking control of an object

369
00:16:16,839 --> 00:16:20,499
that's<font color="#E5E5E5"> on the heap so you need to build</font>

370
00:16:18,490 --> 00:16:23,019
<font color="#E5E5E5">a synthetic stack since you're on the</font>

371
00:16:20,499 --> 00:16:24,670
heat you<font color="#CCCCCC"> often have you know at the time</font>

372
00:16:23,019 --> 00:16:27,009
crash you have a register that's

373
00:16:24,670 --> 00:16:30,099
pointing to that location on the heap so

374
00:16:27,009 --> 00:16:32,740
you use something<font color="#E5E5E5"> like an exchange espec</font>

375
00:16:30,100 --> 00:16:34,749
<font color="#E5E5E5">X or whatever register is pointing at</font>

376
00:16:32,740 --> 00:16:36,549
your object and you pivot the stack

377
00:16:34,749 --> 00:16:40,299
pointer to point at the heap and then

378
00:16:36,549 --> 00:16:41,470
you build a synthetic stack so<font color="#E5E5E5"> usually</font>

379
00:16:40,299 --> 00:16:43,660
your<font color="#CCCCCC"> wrap chain does something like</font>

380
00:16:41,470 --> 00:16:46,059
change memory protections so it'll do

381
00:16:43,660 --> 00:16:48,579
like a virtual protect change the memory

382
00:16:46,059 --> 00:16:51,040
permissions of your second stage payload

383
00:16:48,579 --> 00:16:52,540
you fall<font color="#E5E5E5"> into that you</font><font color="#CCCCCC"> know you do</font>

384
00:16:51,040 --> 00:16:54,429
whatever<font color="#CCCCCC"> a</font><font color="#E5E5E5"> nefarious thing it is you</font>

385
00:16:52,540 --> 00:16:58,089
want to<font color="#E5E5E5"> do and then you resume the</font>

386
00:16:54,429 --> 00:17:04,599
process and as I said<font color="#E5E5E5"> this the original</font>

387
00:16:58,089 --> 00:17:07,959
exploit won't survive a night so return

388
00:17:04,599 --> 00:17:10,349
oriented programming we didn't have<font color="#CCCCCC"> to</font>

389
00:17:07,959 --> 00:17:13,480
change a lot in<font color="#E5E5E5"> the original exploit</font>

390
00:17:10,349 --> 00:17:15,668
instead<font color="#E5E5E5"> of using the</font><font color="#CCCCCC"> higher-level</font><font color="#E5E5E5"> like</font>

391
00:17:13,480 --> 00:17:18,309
virtual protect function you have<font color="#CCCCCC"> to you</font>

392
00:17:15,669 --> 00:17:20,829
there's no<font color="#E5E5E5"> colonel 230</font><font color="#CCCCCC"> kernel32 or</font>

393
00:17:18,309 --> 00:17:22,599
Colonel base module in the 64-bit

394
00:17:20,829 --> 00:17:24,398
context so you don't get all those

395
00:17:22,599 --> 00:17:26,020
convenient high level functions you have

396
00:17:24,398 --> 00:17:28,119
to use the low-level implementations

397
00:17:26,020 --> 00:17:30,370
which tends to require you know a little

398
00:17:28,119 --> 00:17:32,860
more<font color="#E5E5E5"> initialization and effort on your</font>

399
00:17:30,370 --> 00:17:35,229
part so instead of<font color="#CCCCCC"> using virtual protect</font>

400
00:17:32,860 --> 00:17:36,908
you would use anti protect virtual

401
00:17:35,230 --> 00:17:39,929
memory and this this right here is

402
00:17:36,909 --> 00:17:39,929
pretty<font color="#E5E5E5"> much the crux</font>

403
00:17:40,419 --> 00:17:45,100
the entire technique is basically built

404
00:17:43,269 --> 00:17:46,659
on the red f instruction and instead<font color="#E5E5E5"> of</font>

405
00:17:45,100 --> 00:17:48,309
like a normal<font color="#CCCCCC"> function return which</font>

406
00:17:46,659 --> 00:17:50,429
would pop your return address off<font color="#CCCCCC"> the</font>

407
00:17:48,309 --> 00:17:53,889
stack when your<font color="#E5E5E5"> turn from a function</font>

408
00:17:50,429 --> 00:17:58,600
afar return will pop the code segment so

409
00:17:53,889 --> 00:18:00,399
you start your<font color="#CCCCCC"> wrap chain by popping the</font>

410
00:17:58,600 --> 00:18:02,918
code segment off the stack so that hex

411
00:18:00,399 --> 00:18:05,350
33 and you pivot modes and then you do

412
00:18:02,919 --> 00:18:08,980
<font color="#E5E5E5">everything off</font><font color="#CCCCCC"> of the 64-bit copy of NT</font>

413
00:18:05,350 --> 00:18:11,259
dll so this<font color="#E5E5E5"> is sort of what the sequence</font>

414
00:18:08,980 --> 00:18:13,749
looks like right you do the stack pivot

415
00:18:11,259 --> 00:18:16,929
as<font color="#CCCCCC"> I mentioned you return into log mode</font>

416
00:18:13,749 --> 00:18:18,759
you do your<font color="#E5E5E5"> reproduction of memory so</font>

417
00:18:16,929 --> 00:18:21,070
you can execute the shellcode you inject

418
00:18:18,759 --> 00:18:23,470
it into memory you fall into your second

419
00:18:21,070 --> 00:18:26,678
stage payload theoretically you profit

420
00:18:23,470 --> 00:18:28,570
and if you're not as lazy as I am<font color="#E5E5E5"> you</font>

421
00:18:26,679 --> 00:18:30,580
actually<font color="#CCCCCC"> repair the process state and</font>

422
00:18:28,570 --> 00:18:33,239
make everything run nicely which I

423
00:18:30,580 --> 00:18:36,009
didn't do cuz some way too lazy of

424
00:18:33,239 --> 00:18:43,299
course it's never that easy there's

425
00:18:36,009 --> 00:18:47,739
always<font color="#E5E5E5"> a catch so the first catch is</font>

426
00:18:43,299 --> 00:18:49,869
symbol resolution as I said the original

427
00:18:47,739 --> 00:18:51,190
exploits cancer memory resolves

428
00:18:49,869 --> 00:18:55,658
everything using import and export

429
00:18:51,190 --> 00:18:58,509
tables none<font color="#CCCCCC"> of those 32-bit modules</font>

430
00:18:55,659 --> 00:19:03,249
directly import code from the 64-bit

431
00:18:58,509 --> 00:19:05,679
modules so we need a way to find them as

432
00:19:03,249 --> 00:19:08,710
I said<font color="#CCCCCC"> this is way easier on</font><font color="#E5E5E5"> Windows 7</font>

433
00:19:05,679 --> 00:19:11,200
remember how<font color="#E5E5E5"> I mention that there</font>

434
00:19:08,710 --> 00:19:13,779
there's a static offset well as long as

435
00:19:11,200 --> 00:19:16,840
<font color="#E5E5E5">you can leak or resolve the base address</font>

436
00:19:13,779 --> 00:19:19,029
of the 32-bit copy of NT dll you can win

437
00:19:16,840 --> 00:19:21,519
because all you have to do is take that

438
00:19:19,029 --> 00:19:25,359
address subtract that hex value and

439
00:19:21,519 --> 00:19:26,769
you'll find the 64-bit copy on windows 8

440
00:19:25,359 --> 00:19:32,799
that won't work<font color="#E5E5E5"> you've got to be a</font>

441
00:19:26,769 --> 00:19:36,970
<font color="#E5E5E5">little more clever so the second thing</font>

442
00:19:32,799 --> 00:19:39,190
<font color="#E5E5E5">is payload development like I said you</font>

443
00:19:36,970 --> 00:19:40,899
don't<font color="#CCCCCC"> have access to Colonel 32 or</font>

444
00:19:39,190 --> 00:19:42,820
Colonel base so<font color="#E5E5E5"> you don't get all the</font>

445
00:19:40,899 --> 00:19:45,369
convenient<font color="#E5E5E5"> high level win API functions</font>

446
00:19:42,820 --> 00:19:47,619
you're used to you can't do<font color="#CCCCCC"> things like</font>

447
00:19:45,369 --> 00:19:49,449
<font color="#E5E5E5">just call load library or win exec you</font>

448
00:19:47,619 --> 00:19:52,570
have to use their load their low-level

449
00:19:49,450 --> 00:19:54,840
counterparts so LDR load dll NT curate

450
00:19:52,570 --> 00:19:57,010
create process

451
00:19:54,840 --> 00:19:59,199
in order to make these work there's a

452
00:19:57,010 --> 00:20:00,580
lot more initialization and and and

453
00:19:59,200 --> 00:20:02,410
stuff you have<font color="#CCCCCC"> to set up right it's</font>

454
00:20:00,580 --> 00:20:05,379
there's a lot<font color="#CCCCCC"> more going under the hood</font>

455
00:20:02,410 --> 00:20:07,360
when you<font color="#E5E5E5"> call those functions and we</font>

456
00:20:05,380 --> 00:20:09,790
<font color="#E5E5E5">take a lot of that for granted this</font>

457
00:20:07,360 --> 00:20:11,409
results in bigger uglier<font color="#E5E5E5"> shellcode in</font>

458
00:20:09,790 --> 00:20:12,760
the case of a browser vulnerability this

459
00:20:11,410 --> 00:20:15,610
isn't so bad<font color="#E5E5E5"> because you don't tend to</font>

460
00:20:12,760 --> 00:20:16,809
have a lot of problems with space to

461
00:20:15,610 --> 00:20:18,399
store things right<font color="#CCCCCC"> so like</font><font color="#E5E5E5"> you've got</font>

462
00:20:16,809 --> 00:20:19,899
this small stack buffer but you have to

463
00:20:18,400 --> 00:20:22,240
keep things in you've<font color="#E5E5E5"> got a giant heat</font>

464
00:20:19,900 --> 00:20:26,080
that you can stash everything on but it

465
00:20:22,240 --> 00:20:28,540
does result in much uglier shellcode so

466
00:20:26,080 --> 00:20:30,010
this<font color="#CCCCCC"> is pretty much the you know the C</font>

467
00:20:28,540 --> 00:20:32,350
equivalent<font color="#E5E5E5"> the high level approximation</font>

468
00:20:30,010 --> 00:20:34,600
of what we built I'll note<font color="#CCCCCC"> that this is</font>

469
00:20:32,350 --> 00:20:35,919
<font color="#CCCCCC">not doing all</font><font color="#E5E5E5"> the proper initialization</font>

470
00:20:34,600 --> 00:20:37,449
as<font color="#E5E5E5"> I mentioned so we're like this would</font>

471
00:20:35,920 --> 00:20:39,690
<font color="#CCCCCC">be a win exact call it would be</font>

472
00:20:37,450 --> 00:20:42,429
literally<font color="#CCCCCC"> like you know one line of code</font>

473
00:20:39,690 --> 00:20:44,410
this isn't even complete this is super

474
00:20:42,429 --> 00:20:46,929
hacky and if you were to do this you

475
00:20:44,410 --> 00:20:48,640
know as a<font color="#CCCCCC"> real-world</font><font color="#E5E5E5"> adversary this is</font>

476
00:20:46,929 --> 00:20:51,429
<font color="#E5E5E5">not</font><font color="#CCCCCC"> how you would</font><font color="#E5E5E5"> want to do it but this</font>

477
00:20:48,640 --> 00:20:53,440
works for a contrived example<font color="#CCCCCC"> all right</font>

478
00:20:51,429 --> 00:20:55,690
so I've got two<font color="#E5E5E5"> VMs ones just hosting</font>

479
00:20:53,440 --> 00:21:05,080
<font color="#CCCCCC">metasploit and the other is a vulnerable</font>

480
00:20:55,690 --> 00:21:06,970
system and this will just this will just

481
00:21:05,080 --> 00:21:10,080
execute an arbitrary command and run the

482
00:21:06,970 --> 00:21:10,080
calculator assuming it works

483
00:21:17,950 --> 00:21:30,519
you thank you<font color="#E5E5E5"> I was told not to put</font>

484
00:21:28,450 --> 00:21:38,799
memes in<font color="#E5E5E5"> my presentation so I put memes</font>

485
00:21:30,519 --> 00:21:42,039
in<font color="#E5E5E5"> my presentation take that mark okay</font>

486
00:21:38,799 --> 00:21:44,019
um so I didn't do this<font color="#E5E5E5"> on 18 but we have</font>

487
00:21:42,039 --> 00:21:45,669
<font color="#CCCCCC">a couple</font><font color="#E5E5E5"> potential solutions loser</font>

488
00:21:44,019 --> 00:21:47,769
you're familiar with windows shell code

489
00:21:45,669 --> 00:21:49,389
development you<font color="#E5E5E5"> can do it like</font><font color="#CCCCCC"> a more</font>

490
00:21:47,769 --> 00:21:51,460
traditional payload where you do symbol

491
00:21:49,389 --> 00:21:53,918
resolution via the 64-bit copy of the

492
00:21:51,460 --> 00:21:55,840
peb you might have to do this in pure

493
00:21:53,919 --> 00:21:58,149
Rob it's this is really vulnerability

494
00:21:55,840 --> 00:22:00,129
specific how you how you do this so

495
00:21:58,149 --> 00:22:02,309
<font color="#E5E5E5">really depends on</font><font color="#CCCCCC"> the context you have</font>

496
00:22:00,130 --> 00:22:04,480
in the vulnerability you're exploiting

497
00:22:02,309 --> 00:22:05,799
or if the vulnerability can be triggered

498
00:22:04,480 --> 00:22:08,980
more than once you might be able<font color="#E5E5E5"> to do</font>

499
00:22:05,799 --> 00:22:10,539
<font color="#CCCCCC">something like build a 32-bit chain</font>

500
00:22:08,980 --> 00:22:13,779
depending<font color="#CCCCCC"> on whether or</font><font color="#E5E5E5"> not you met</font>

501
00:22:10,539 --> 00:22:15,669
would mess with you they leaked contents

502
00:22:13,779 --> 00:22:17,470
of those higher order registers I

503
00:22:15,669 --> 00:22:19,149
mentioned earlier back and then you

504
00:22:17,470 --> 00:22:21,070
built a secondary stage and then

505
00:22:19,149 --> 00:22:22,600
triggered the bug again again this<font color="#CCCCCC"> is</font>

506
00:22:21,070 --> 00:22:26,010
all<font color="#E5E5E5"> very vulnerability specific as to</font>

507
00:22:22,600 --> 00:22:28,209
whether or<font color="#E5E5E5"> not it would work and</font>

508
00:22:26,010 --> 00:22:29,649
alternative payload implementation so I

509
00:22:28,210 --> 00:22:31,600
mentioned<font color="#CCCCCC"> that</font><font color="#E5E5E5"> you know you've got</font><font color="#CCCCCC"> to</font>

510
00:22:29,649 --> 00:22:33,219
write more complicated payloads it's not

511
00:22:31,600 --> 00:22:34,740
as simple as like you know one function

512
00:22:33,220 --> 00:22:37,750
call for a lot<font color="#E5E5E5"> of things you would do</font>

513
00:22:34,740 --> 00:22:39,610
well 64 dll actually has rapper

514
00:22:37,750 --> 00:22:42,190
functions that encapsulate all of that

515
00:22:39,610 --> 00:22:44,529
functionality the major problem is that

516
00:22:42,190 --> 00:22:46,450
they're not exported<font color="#E5E5E5"> so you have to</font>

517
00:22:44,529 --> 00:22:48,519
indirectly resolve them and a potential

518
00:22:46,450 --> 00:22:52,090
<font color="#E5E5E5">solution to that is there's a function</font>

519
00:22:48,519 --> 00:22:54,580
called<font color="#E5E5E5"> while 64 system service</font><font color="#CCCCCC"> yex that</font>

520
00:22:52,090 --> 00:22:57,610
function is exported and it uses a giant

521
00:22:54,580 --> 00:23:00,158
<font color="#CCCCCC">jung</font><font color="#E5E5E5"> table to dispatch all those mt dll</font>

522
00:22:57,610 --> 00:23:02,019
functions so you can<font color="#E5E5E5"> probably do</font>

523
00:23:00,159 --> 00:23:08,470
indirect resolution through the through

524
00:23:02,019 --> 00:23:11,350
that<font color="#E5E5E5"> but</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> haven't tested it so in</font>

525
00:23:08,470 --> 00:23:13,899
conclusion Yvette is significantly<font color="#CCCCCC"> more</font>

526
00:23:11,350 --> 00:23:15,189
effective on pure 32 or 64-bit processes

527
00:23:13,899 --> 00:23:16,539
I don't want to I don't<font color="#E5E5E5"> want to</font><font color="#CCCCCC"> play it</font>

528
00:23:15,190 --> 00:23:19,929
down like if you're not<font color="#E5E5E5"> using it you</font>

529
00:23:16,539 --> 00:23:22,179
probably should it said it'll break most

530
00:23:19,929 --> 00:23:24,639
office off-the-shelf stuff but it works

531
00:23:22,179 --> 00:23:27,129
far better if it's if it's protecting a

532
00:23:24,639 --> 00:23:31,600
<font color="#CCCCCC">peer 32 or</font><font color="#E5E5E5"> 64-bit processes well 64</font>

533
00:23:27,129 --> 00:23:33,189
processes and less effective and

534
00:23:31,600 --> 00:23:35,379
well 64 strikes again it's been the

535
00:23:33,190 --> 00:23:37,950
cause of like multiple security issues

536
00:23:35,380 --> 00:23:40,210
or at least multiple security bypasses

537
00:23:37,950 --> 00:23:43,059
this is a classic case<font color="#E5E5E5"> of you know</font>

538
00:23:40,210 --> 00:23:45,039
legacy components impeding security our

539
00:23:43,059 --> 00:23:49,200
desire for compatibility holding back

540
00:23:45,039 --> 00:23:51,879
you know enhancements to our software

541
00:23:49,200 --> 00:23:53,169
this is<font color="#E5E5E5"> this is an optional component in</font>

542
00:23:51,880 --> 00:23:55,660
server core so if you're<font color="#E5E5E5"> not running</font>

543
00:23:53,169 --> 00:23:56,830
32-bit software and you're running<font color="#E5E5E5"> a</font>

544
00:23:55,660 --> 00:23:59,530
<font color="#CCCCCC">Windows Server you</font><font color="#E5E5E5"> may want to make sure</font>

545
00:23:56,830 --> 00:24:01,689
that<font color="#CCCCCC"> that's not running of course this</font>

546
00:23:59,530 --> 00:24:03,370
technique does have limitations I had to

547
00:24:01,690 --> 00:24:05,860
jump<font color="#CCCCCC"> through a lot more hoops it's a lot</font>

548
00:24:03,370 --> 00:24:06,969
less reliable which is frankly proof

549
00:24:05,860 --> 00:24:08,350
that you should probably<font color="#E5E5E5"> be using</font>

550
00:24:06,970 --> 00:24:13,030
<font color="#E5E5E5">something like II met to protect</font>

551
00:24:08,350 --> 00:24:28,178
processes from exploitation that's all I

552
00:24:13,030 --> 00:24:29,770
got so questions it was 16 point 0 point

553
00:24:28,179 --> 00:24:31,510
0 points something it is in the slides

554
00:24:29,770 --> 00:24:33,190
so and it's also I should mention there

555
00:24:31,510 --> 00:24:35,980
is<font color="#E5E5E5"> the full paper is available on this</font>

556
00:24:33,190 --> 00:24:37,929
so to go to the duel labs website you

557
00:24:35,980 --> 00:24:39,490
can actually<font color="#E5E5E5"> read you know the full</font>

558
00:24:37,929 --> 00:24:41,140
explanation of how all this works all

559
00:24:39,490 --> 00:24:44,909
the<font color="#E5E5E5"> stuff that i glossed over and kind</font>

560
00:24:41,140 --> 00:24:47,980
<font color="#E5E5E5">of hand waved is better explained there</font>

561
00:24:44,909 --> 00:24:55,230
yes this is this is a vulnerability in

562
00:24:47,980 --> 00:24:58,030
patch for several months so yep yeah yes

563
00:24:55,230 --> 00:24:59,620
but I mean the technique is is you know

564
00:24:58,030 --> 00:25:01,000
agnostic of vulnerabilities it just

565
00:24:59,620 --> 00:25:03,850
happened<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be a good</font><font color="#CCCCCC"> phoner ability for</font>

566
00:25:01,000 --> 00:25:06,210
demonstrating it with<font color="#E5E5E5"> anybody else any</font>

567
00:25:03,850 --> 00:25:06,209
hecklers

568
00:25:09,059 --> 00:25:27,178
I have no<font color="#E5E5E5"> idea i mean that's that's why</font>

569
00:25:25,320 --> 00:25:29,279
i said i don't<font color="#E5E5E5"> know if that change is an</font>

570
00:25:27,179 --> 00:25:33,539
explicit mitigation or an architectural

571
00:25:29,279 --> 00:25:34,860
thing but the erase<font color="#E5E5E5"> i mean i'm</font><font color="#CCCCCC"> sure more</font>

572
00:25:33,539 --> 00:25:36,690
reverse engineering<font color="#CCCCCC"> i mean it's a</font>

573
00:25:34,860 --> 00:25:38,219
decent-sized subsystem so i'm sure<font color="#E5E5E5"> more</font>

574
00:25:36,690 --> 00:25:41,549
reverse engineering might reveal that

575
00:25:38,220 --> 00:25:45,299
but<font color="#E5E5E5"> i don't have an answer for you all i</font>

576
00:25:41,549 --> 00:25:48,019
know is it made my life easier that's it

577
00:25:45,299 --> 00:25:48,019
<font color="#CCCCCC">okay thanks guys</font>

