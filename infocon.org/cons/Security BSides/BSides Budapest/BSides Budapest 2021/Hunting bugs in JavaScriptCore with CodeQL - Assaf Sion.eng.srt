1
00:00:00,640 --> 00:00:02,639
greetings everyone and welcome to my

2
00:00:02,639 --> 00:00:04,880
talk about hunting bugs in javascript

3
00:00:04,880 --> 00:00:06,640
core with codeql

4
00:00:06,640 --> 00:00:08,639
our journey begins when we wake up in

5
00:00:08,639 --> 00:00:10,320
the middle of nowhere and this guy is

6
00:00:10,320 --> 00:00:12,639
approaching us and start talking to us

7
00:00:12,639 --> 00:00:15,599
saying hey you you're finally awake you

8
00:00:15,599 --> 00:00:17,279
were trying to find bugs in the realm of

9
00:00:17,279 --> 00:00:19,439
javascript core huh walked right into

10
00:00:19,439 --> 00:00:21,920
that ambush same as us and that hacker

11
00:00:21,920 --> 00:00:23,039
over there

12
00:00:23,039 --> 00:00:24,560
who are you

13
00:00:24,560 --> 00:00:26,640
so before i'll introduce myself if

14
00:00:26,640 --> 00:00:29,039
you're not if you're not recognizing the

15
00:00:29,039 --> 00:00:31,039
following reference congratulations

16
00:00:31,039 --> 00:00:32,880
you're not a complete nerd like i do

17
00:00:32,880 --> 00:00:35,680
this is from skyrim

18
00:00:35,680 --> 00:00:37,040
who am i

19
00:00:37,040 --> 00:00:39,680
my name is asafseon and i work as a

20
00:00:39,680 --> 00:00:42,640
security researcher at cyberlock i enjoy

21
00:00:42,640 --> 00:00:44,640
ctfing and playing video games in my

22
00:00:44,640 --> 00:00:45,920
free time

23
00:00:45,920 --> 00:00:48,960
uh here are my i'm level 24 of course

24
00:00:48,960 --> 00:00:51,360
here are my character my character stats

25
00:00:51,360 --> 00:00:54,160
so i'm somewhat skilled in code ql but

26
00:00:54,160 --> 00:00:55,840
i'm not so skilled in javascript core

27
00:00:55,840 --> 00:00:57,199
exploitation

28
00:00:57,199 --> 00:00:58,719
uh

29
00:00:58,719 --> 00:01:01,280
my goals my character goals are use

30
00:01:01,280 --> 00:01:04,640
codeql to find bugs in javascript core

31
00:01:04,640 --> 00:01:07,040
and of course have fun

32
00:01:07,040 --> 00:01:09,840
finally my character state of mind is

33
00:01:09,840 --> 00:01:13,920
that i'm 100 positive and 100 excited so

34
00:01:13,920 --> 00:01:17,280
without further further ado let's begin

35
00:01:17,280 --> 00:01:19,119
during this talk we'll have three major

36
00:01:19,119 --> 00:01:21,439
checkpoints the first checkpoint will

37
00:01:21,439 --> 00:01:24,240
cover the fundamentals of quad ql will

38
00:01:24,240 --> 00:01:26,720
get a very good cultural introduction

39
00:01:26,720 --> 00:01:29,040
we'll see some cool and basic examples

40
00:01:29,040 --> 00:01:31,439
with codeql and there is gonna be even a

41
00:01:31,439 --> 00:01:33,759
boss fight so stay tuned

42
00:01:33,759 --> 00:01:35,680
at the second part of our talk we'll

43
00:01:35,680 --> 00:01:38,000
review javascript core as a javascript

44
00:01:38,000 --> 00:01:40,159
engine we'll talk about how javascript

45
00:01:40,159 --> 00:01:43,520
core processes javascript instructions

46
00:01:43,520 --> 00:01:45,759
what type of jit engines there are in

47
00:01:45,759 --> 00:01:47,119
javascript core

48
00:01:47,119 --> 00:01:50,159
and what are side effects in javascript

49
00:01:50,159 --> 00:01:51,520
finally

50
00:01:51,520 --> 00:01:53,119
we'll talk about bed side effect

51
00:01:53,119 --> 00:01:54,399
modeling bugs

52
00:01:54,399 --> 00:01:57,040
a type of a bar class that exists in the

53
00:01:57,040 --> 00:01:59,680
in javascript engines and

54
00:01:59,680 --> 00:02:02,399
then finally after that we'll

55
00:02:02,399 --> 00:02:04,479
we'll find out how how we can use code

56
00:02:04,479 --> 00:02:06,840
ql to find these types of

57
00:02:06,840 --> 00:02:10,000
bugs let's begin

58
00:02:10,000 --> 00:02:11,680
this is going to be a very short

59
00:02:11,680 --> 00:02:13,920
introduction to code ql and i mean very

60
00:02:13,920 --> 00:02:18,480
short this is me on the left side

61
00:02:18,560 --> 00:02:21,120
what is codeql for whom of you are not

62
00:02:21,120 --> 00:02:24,000
familiar with codeql yet codeql is a

63
00:02:24,000 --> 00:02:26,160
framework created by a company called

64
00:02:26,160 --> 00:02:29,120
saml which is now owned and developed by

65
00:02:29,120 --> 00:02:30,319
github

66
00:02:30,319 --> 00:02:33,519
codeql in its core is a query language

67
00:02:33,519 --> 00:02:36,239
it is very similar to sql it lets a

68
00:02:36,239 --> 00:02:39,519
researcher listen with code using tools

69
00:02:39,519 --> 00:02:40,800
from logic

70
00:02:40,800 --> 00:02:42,800
it has some cool syntactic sugar from

71
00:02:42,800 --> 00:02:44,800
object oriented programming like

72
00:02:44,800 --> 00:02:47,840
inheritance and class methods we can use

73
00:02:47,840 --> 00:02:50,480
the code qlcli cli

74
00:02:50,480 --> 00:02:52,720
you should know that the code ul engine

75
00:02:52,720 --> 00:02:54,959
the code urcli is the codeul engine

76
00:02:54,959 --> 00:02:57,440
which can execute codeql queries so we

77
00:02:57,440 --> 00:03:00,319
can use the code qlcli cli

78
00:03:00,319 --> 00:03:04,159
to to turn codebase into database it

79
00:03:04,159 --> 00:03:06,000
supports many programming languages such

80
00:03:06,000 --> 00:03:08,959
as c plus plus java and many more

81
00:03:08,959 --> 00:03:11,840
it has tons i mean tons of great

82
00:03:11,840 --> 00:03:12,800
features

83
00:03:12,800 --> 00:03:15,920
to analyze code uh for example data flow

84
00:03:15,920 --> 00:03:18,319
analysis that we're gonna look like

85
00:03:18,319 --> 00:03:20,400
we're gonna review today but it has many

86
00:03:20,400 --> 00:03:21,680
more i

87
00:03:21,680 --> 00:03:25,200
i encourage you to read about it later

88
00:03:25,200 --> 00:03:27,360
when working with coql there is a

89
00:03:27,360 --> 00:03:29,360
general workflow that will

90
00:03:29,360 --> 00:03:31,120
that we will usually follow

91
00:03:31,120 --> 00:03:33,760
at first the researcher will choose the

92
00:03:33,760 --> 00:03:36,159
open source project and make sure he can

93
00:03:36,159 --> 00:03:37,280
build it

94
00:03:37,280 --> 00:03:38,640
after that

95
00:03:38,640 --> 00:03:41,280
clean the the solution and then rebuild

96
00:03:41,280 --> 00:03:43,280
it again but this time use the code

97
00:03:43,280 --> 00:03:45,200
qlcli

98
00:03:45,200 --> 00:03:47,599
next select a bug class that you want to

99
00:03:47,599 --> 00:03:50,000
discover analyze it understand that

100
00:03:50,000 --> 00:03:52,159
backlash very well and understand how

101
00:03:52,159 --> 00:03:54,480
that bad class might appear in the code

102
00:03:54,480 --> 00:03:57,200
base that you chose

103
00:03:57,200 --> 00:03:59,519
then write a query that finds the

104
00:03:59,519 --> 00:04:01,599
backlash and make sure it works by

105
00:04:01,599 --> 00:04:05,120
executing that query against the prior

106
00:04:05,120 --> 00:04:07,680
known vulnerable version of that project

107
00:04:07,680 --> 00:04:10,640
you chose to analyze that's a pro tip so

108
00:04:10,640 --> 00:04:13,519
make sure that the query finds all

109
00:04:13,519 --> 00:04:15,920
vulnerabilities from that same backlash

110
00:04:15,920 --> 00:04:18,079
in prior versions

111
00:04:18,079 --> 00:04:20,399
finally execute your query against an

112
00:04:20,399 --> 00:04:22,320
up-to-date database and hopefully find

113
00:04:22,320 --> 00:04:23,600
new bugs

114
00:04:23,600 --> 00:04:25,520
query structure so each query will

115
00:04:25,520 --> 00:04:27,759
consist out of three parts there are

116
00:04:27,759 --> 00:04:29,840
very similar that are very similar to

117
00:04:29,840 --> 00:04:32,880
sql we have the from class if you're not

118
00:04:32,880 --> 00:04:34,880
familiar with sql the front class this

119
00:04:34,880 --> 00:04:37,360
is where we're going to define all the

120
00:04:37,360 --> 00:04:40,479
codeql elements that we are going to use

121
00:04:40,479 --> 00:04:42,400
next the word class

122
00:04:42,400 --> 00:04:45,680
although this clause is optional uh it

123
00:04:45,680 --> 00:04:48,960
is the very essence of your query so uh

124
00:04:48,960 --> 00:04:51,040
this is where all the logic of your

125
00:04:51,040 --> 00:04:53,280
query will be in

126
00:04:53,280 --> 00:04:54,000
so

127
00:04:54,000 --> 00:04:55,520
although it is optional it's quite

128
00:04:55,520 --> 00:04:58,240
mandatory if you want to have uh

129
00:04:58,240 --> 00:05:00,720
complex uh queries

130
00:05:00,720 --> 00:05:03,280
finally this is the select clause this

131
00:05:03,280 --> 00:05:05,360
is where we choose how our output is

132
00:05:05,360 --> 00:05:07,919
going to look like

133
00:05:07,919 --> 00:05:09,759
now that we've learned what what is the

134
00:05:09,759 --> 00:05:12,240
general purpose of codeql we can start

135
00:05:12,240 --> 00:05:14,639
our training

136
00:05:14,639 --> 00:05:17,120
okay who is this lovely npc this lovely

137
00:05:17,120 --> 00:05:19,520
npc says hello there do you mind helping

138
00:05:19,520 --> 00:05:22,320
me with some code ql queries

139
00:05:22,320 --> 00:05:23,199
sure

140
00:05:23,199 --> 00:05:25,919
sure thing let's help her

141
00:05:25,919 --> 00:05:28,479
our first quest requires us to find all

142
00:05:28,479 --> 00:05:30,320
the variable declarations in a given

143
00:05:30,320 --> 00:05:34,160
code base and this task is very simple

144
00:05:34,160 --> 00:05:36,960
this is the first mini quest so

145
00:05:36,960 --> 00:05:39,039
this task is very simple at first

146
00:05:39,039 --> 00:05:41,360
we'll import c plus plus this tells

147
00:05:41,360 --> 00:05:43,680
codeql to use the c plus plus standard

148
00:05:43,680 --> 00:05:45,919
library that exists within the coqueur

149
00:05:45,919 --> 00:05:47,039
library

150
00:05:47,039 --> 00:05:49,039
we don't need a where clause in this

151
00:05:49,039 --> 00:05:51,120
query since we don't want to find since

152
00:05:51,120 --> 00:05:52,639
we want to find all the variable

153
00:05:52,639 --> 00:05:54,320
declarations

154
00:05:54,320 --> 00:05:56,400
so let's define the form clause

155
00:05:56,400 --> 00:05:58,880
variable you see form variable var so

156
00:05:58,880 --> 00:06:01,759
variable is a codeql element from the c

157
00:06:01,759 --> 00:06:03,759
plus plus library it represents a

158
00:06:03,759 --> 00:06:06,160
variable declaration form the abstract

159
00:06:06,160 --> 00:06:08,639
syntax tree that represents our code

160
00:06:08,639 --> 00:06:10,400
eventually

161
00:06:10,400 --> 00:06:12,880
then we simply have to select val this

162
00:06:12,880 --> 00:06:14,240
will select all the variable

163
00:06:14,240 --> 00:06:15,520
declarations

164
00:06:15,520 --> 00:06:17,199
amazing so let's see

165
00:06:17,199 --> 00:06:19,840
i use the vs code to run my queries and

166
00:06:19,840 --> 00:06:21,759
this is how the output should look like

167
00:06:21,759 --> 00:06:23,759
when executing that query against the

168
00:06:23,759 --> 00:06:26,639
database created from webkit

169
00:06:26,639 --> 00:06:28,800
we can even click the results and review

170
00:06:28,800 --> 00:06:32,479
them so let's click for example the host

171
00:06:32,479 --> 00:06:35,039
it will take us to the uh actual

172
00:06:35,039 --> 00:06:38,080
declaration of host in the webkit

173
00:06:38,080 --> 00:06:40,800
project and indeed we can see that uh

174
00:06:40,800 --> 00:06:44,479
this is the declaration of host

175
00:06:44,479 --> 00:06:46,000
awesome

176
00:06:46,000 --> 00:06:48,639
in our second quest we need to find all

177
00:06:48,639 --> 00:06:50,800
the function calls to the malloc

178
00:06:50,800 --> 00:06:53,199
function this is a bit more complicated

179
00:06:53,199 --> 00:06:56,960
than the previous one but not too much

180
00:06:56,960 --> 00:06:59,039
okay so import c plus plus we already

181
00:06:59,039 --> 00:07:01,360
talked about this earlier now we know

182
00:07:01,360 --> 00:07:03,919
that we need to extract the calls all

183
00:07:03,919 --> 00:07:06,000
the calls so let's use the

184
00:07:06,000 --> 00:07:07,520
element the codeql element that

185
00:07:07,520 --> 00:07:11,199
represents every call in our code

186
00:07:11,199 --> 00:07:13,520
from function call call to malloc call

187
00:07:13,520 --> 00:07:15,120
to malloc is now

188
00:07:15,120 --> 00:07:17,280
a representation of a function call in

189
00:07:17,280 --> 00:07:19,039
our codebase

190
00:07:19,039 --> 00:07:22,160
then before inserting any constraints

191
00:07:22,160 --> 00:07:24,880
let's select the call to malloc if we

192
00:07:24,880 --> 00:07:26,560
run this query

193
00:07:26,560 --> 00:07:28,639
this will extract all the calls to all

194
00:07:28,639 --> 00:07:30,880
the functions so let's narrow down it

195
00:07:30,880 --> 00:07:32,960
let's narrow it down by by adding the

196
00:07:32,960 --> 00:07:34,639
where clause

197
00:07:34,639 --> 00:07:38,560
well and then call to malloc dot get

198
00:07:38,560 --> 00:07:41,840
target get target will return the the

199
00:07:41,840 --> 00:07:43,360
actual function

200
00:07:43,360 --> 00:07:46,000
the that the function call element

201
00:07:46,000 --> 00:07:47,280
called to

202
00:07:47,280 --> 00:07:49,440
and then all we got to do is uh use the

203
00:07:49,440 --> 00:07:52,080
has name this will this way we make sure

204
00:07:52,080 --> 00:07:54,479
that the function we called has the name

205
00:07:54,479 --> 00:07:58,000
malloc and then execute the the query

206
00:07:58,000 --> 00:07:59,360
here are the results we can see that

207
00:07:59,360 --> 00:08:02,479
there are over 500 calls to malloc in

208
00:08:02,479 --> 00:08:05,599
the webkit project select one click it

209
00:08:05,599 --> 00:08:08,160
and here is the call to

210
00:08:08,160 --> 00:08:10,240
the relevant function

211
00:08:10,240 --> 00:08:13,840
maluk in our case of course

212
00:08:14,240 --> 00:08:16,560
okay we have a boss fight you think

213
00:08:16,560 --> 00:08:18,800
you're clever aren't you find every

214
00:08:18,800 --> 00:08:20,879
expression that controls an allocation

215
00:08:20,879 --> 00:08:22,400
size

216
00:08:22,400 --> 00:08:24,319
every expression that controls an

217
00:08:24,319 --> 00:08:26,400
allocation size

218
00:08:26,400 --> 00:08:27,360
okay

219
00:08:27,360 --> 00:08:29,520
in order to win the boss fight we would

220
00:08:29,520 --> 00:08:31,440
have to use some data flow analysis

221
00:08:31,440 --> 00:08:33,679
don't get intimidated by the phrase data

222
00:08:33,679 --> 00:08:36,320
flow analysis it's very simple

223
00:08:36,320 --> 00:08:38,080
we would simply need to find which

224
00:08:38,080 --> 00:08:39,360
expressions

225
00:08:39,360 --> 00:08:43,039
flow into the first argument of a malloc

226
00:08:43,039 --> 00:08:45,040
function call let me remind you the

227
00:08:45,040 --> 00:08:47,040
first argument of the malloc function

228
00:08:47,040 --> 00:08:50,160
call is the size the

229
00:08:50,160 --> 00:08:52,720
malloc receives one argument which tells

230
00:08:52,720 --> 00:08:55,040
malloc what's the size of the buffer you

231
00:08:55,040 --> 00:08:57,200
should allocate so we want to find every

232
00:08:57,200 --> 00:08:59,600
expression that flows into that first

233
00:08:59,600 --> 00:09:00,959
argument

234
00:09:00,959 --> 00:09:04,560
again import c plus plus very similar

235
00:09:04,560 --> 00:09:07,120
the first part of the query

236
00:09:07,120 --> 00:09:09,519
is practically the same only that we

237
00:09:09,519 --> 00:09:11,279
added a third

238
00:09:11,279 --> 00:09:13,360
uh a third

239
00:09:13,360 --> 00:09:16,560
element this element called expression

240
00:09:16,560 --> 00:09:19,440
uh it represents every expression in a

241
00:09:19,440 --> 00:09:22,160
codebase so it's very abstract it

242
00:09:22,160 --> 00:09:23,279
contains

243
00:09:23,279 --> 00:09:26,399
a lot a lot i mean a lot but we're gonna

244
00:09:26,399 --> 00:09:30,480
use it in a more precise matter later on

245
00:09:30,480 --> 00:09:32,000
uh okay

246
00:09:32,000 --> 00:09:34,480
now the this is the first part so uh

247
00:09:34,480 --> 00:09:37,120
right now uh the function call element

248
00:09:37,120 --> 00:09:38,880
fc

249
00:09:38,880 --> 00:09:42,000
holds all the calls to malloc like we

250
00:09:42,000 --> 00:09:43,760
did previously

251
00:09:43,760 --> 00:09:44,800
now

252
00:09:44,800 --> 00:09:47,279
let's use a predicate called local

253
00:09:47,279 --> 00:09:50,399
expression flow

254
00:09:50,399 --> 00:09:51,360
this

255
00:09:51,360 --> 00:09:53,120
this way we can define the source and

256
00:09:53,120 --> 00:09:55,920
the sink in our data flow analysis now

257
00:09:55,920 --> 00:09:57,760
this predicate says

258
00:09:57,760 --> 00:10:00,399
find all the flows all the expressions

259
00:10:00,399 --> 00:10:04,720
that flow into the first argument of fc

260
00:10:04,720 --> 00:10:06,959
fc is a call to malloc the first

261
00:10:06,959 --> 00:10:08,880
argument of fc

262
00:10:08,880 --> 00:10:10,160
is the

263
00:10:10,160 --> 00:10:12,720
size of that allocation and we want to

264
00:10:12,720 --> 00:10:14,720
make sure that source represents an

265
00:10:14,720 --> 00:10:17,519
expression that flows into that first

266
00:10:17,519 --> 00:10:19,519
argument if you don't understand it

267
00:10:19,519 --> 00:10:21,200
let's see an example how the results are

268
00:10:21,200 --> 00:10:22,880
going to look like

269
00:10:22,880 --> 00:10:25,040
okay on the left column we can see all

270
00:10:25,040 --> 00:10:27,040
the expressions that control the

271
00:10:27,040 --> 00:10:30,000
allocation size of a call to malloc

272
00:10:30,000 --> 00:10:32,000
on the right column we can see the

273
00:10:32,000 --> 00:10:34,480
corresponding call to the malloc so

274
00:10:34,480 --> 00:10:36,959
let's click one of the results uh here

275
00:10:36,959 --> 00:10:41,120
we chose a call to a jstring get maximum

276
00:10:41,120 --> 00:10:42,240
utf

277
00:10:42,240 --> 00:10:45,279
8 string size

278
00:10:45,279 --> 00:10:46,560
two uh

279
00:10:46,560 --> 00:10:48,880
to the size argument of the

280
00:10:48,880 --> 00:10:51,760
milo call let's click the

281
00:10:51,760 --> 00:10:53,120
the result

282
00:10:53,120 --> 00:10:55,760
uh and this is indeed what it's going to

283
00:10:55,760 --> 00:10:58,160
look like

284
00:10:58,160 --> 00:10:59,600
so we can see that

285
00:10:59,600 --> 00:11:02,000
by calling that function the returned

286
00:11:02,000 --> 00:11:06,480
value uh flows into the variable j size

287
00:11:06,480 --> 00:11:09,200
which is then passed as an argument

288
00:11:09,200 --> 00:11:11,120
to the mallow call

289
00:11:11,120 --> 00:11:12,800
awesome

290
00:11:12,800 --> 00:11:15,200
i think that was it yeah that was the

291
00:11:15,200 --> 00:11:17,440
first part of our talk congratulations

292
00:11:17,440 --> 00:11:20,480
that's the first checkpoint

293
00:11:20,480 --> 00:11:22,320
let's move on to the second part of our

294
00:11:22,320 --> 00:11:24,079
journey by entering the rem of

295
00:11:24,079 --> 00:11:26,240
javascript core

296
00:11:26,240 --> 00:11:29,200
that's me hello there

297
00:11:29,200 --> 00:11:31,680
so what is javascript core javascript

298
00:11:31,680 --> 00:11:34,800
call is the javascript engine for

299
00:11:34,800 --> 00:11:35,920
webkit

300
00:11:35,920 --> 00:11:38,320
meaning each javascript instruction

301
00:11:38,320 --> 00:11:42,000
executed via safari is actually handled

302
00:11:42,000 --> 00:11:44,959
and executed via javascript core now

303
00:11:44,959 --> 00:11:47,200
before we'll dive into the fundamentals

304
00:11:47,200 --> 00:11:49,600
of javascript core i want us to learn a

305
00:11:49,600 --> 00:11:51,519
little bit about side effects in

306
00:11:51,519 --> 00:11:53,360
javascript you'll understand why we have

307
00:11:53,360 --> 00:11:56,480
to do it now later on but what are side

308
00:11:56,480 --> 00:12:00,000
effects in javascript

309
00:12:00,000 --> 00:12:01,760
a javascript operation causes side

310
00:12:01,760 --> 00:12:02,639
effects

311
00:12:02,639 --> 00:12:05,440
if it modifies the state

312
00:12:05,440 --> 00:12:08,240
of other variables outside the local

313
00:12:08,240 --> 00:12:10,880
environment of that instruction

314
00:12:10,880 --> 00:12:13,040
that's a long way to define side effects

315
00:12:13,040 --> 00:12:16,959
in javascript so let's see a more uh

316
00:12:16,959 --> 00:12:18,800
real example

317
00:12:18,800 --> 00:12:22,240
let's review it this is an example for

318
00:12:22,240 --> 00:12:24,399
not triggering side effects in

319
00:12:24,399 --> 00:12:27,440
javascript so for example concutting a

320
00:12:27,440 --> 00:12:31,360
string with an empty object uh

321
00:12:31,360 --> 00:12:33,839
i'm sure you know the the answer a will

322
00:12:33,839 --> 00:12:37,200
now hold the this a will now have the

323
00:12:37,200 --> 00:12:40,160
string hello with curly braces at the

324
00:12:40,160 --> 00:12:41,920
end of it

325
00:12:41,920 --> 00:12:44,320
that's the that's a a is now a string

326
00:12:44,320 --> 00:12:47,440
with a low concatenated with the curly

327
00:12:47,440 --> 00:12:49,680
braces at the end of it

328
00:12:49,680 --> 00:12:51,680
but and this is

329
00:12:51,680 --> 00:12:54,240
very interesting but concatenating a

330
00:12:54,240 --> 00:12:55,120
string

331
00:12:55,120 --> 00:12:58,079
with an object that have a function

332
00:12:58,079 --> 00:12:59,279
uh

333
00:12:59,279 --> 00:13:01,600
the if the function if the object has a

334
00:13:01,600 --> 00:13:04,480
function property named to string

335
00:13:04,480 --> 00:13:06,639
this will set the value of a to

336
00:13:06,639 --> 00:13:09,040
something completely different

337
00:13:09,040 --> 00:13:11,519
the function to string does two things

338
00:13:11,519 --> 00:13:13,360
at first it will print to this to the

339
00:13:13,360 --> 00:13:15,920
console the string side effect here

340
00:13:15,920 --> 00:13:18,000
and then it will return the string b

341
00:13:18,000 --> 00:13:19,519
sides

342
00:13:19,519 --> 00:13:21,839
concurring a low with this object will

343
00:13:21,839 --> 00:13:25,920
trigger the call to tostring and we'll

344
00:13:25,920 --> 00:13:28,160
set the value of a to the string hello b

345
00:13:28,160 --> 00:13:29,839
sides

346
00:13:29,839 --> 00:13:31,600
and of course we'll print to the console

347
00:13:31,600 --> 00:13:34,639
the string side effects here now this is

348
00:13:34,639 --> 00:13:36,720
where the side effects occurs the mere

349
00:13:36,720 --> 00:13:38,800
fact that we were able to execute a

350
00:13:38,800 --> 00:13:40,959
different function that has nothing to

351
00:13:40,959 --> 00:13:43,760
do with the concatenation meaning that

352
00:13:43,760 --> 00:13:45,760
we managed to trigger side effects in

353
00:13:45,760 --> 00:13:48,240
javascript now i want to i want you to

354
00:13:48,240 --> 00:13:51,199
understand this is perfectly normal it's

355
00:13:51,199 --> 00:13:53,839
not a bug it's not i don't know a

356
00:13:53,839 --> 00:13:56,959
security flaw nothing like that side

357
00:13:56,959 --> 00:13:59,600
effects are perfectly normal they are

358
00:13:59,600 --> 00:14:02,639
part of the the way javascript works and

359
00:14:02,639 --> 00:14:05,279
they're crucial to it

360
00:14:05,279 --> 00:14:06,720
uh okay

361
00:14:06,720 --> 00:14:09,199
keep that in mind now let's dive into

362
00:14:09,199 --> 00:14:13,040
the implementation of js adnan number

363
00:14:13,040 --> 00:14:15,680
js adnan number is the

364
00:14:15,680 --> 00:14:17,839
is a function that written in c it's

365
00:14:17,839 --> 00:14:19,279
part from the

366
00:14:19,279 --> 00:14:22,079
javascript core engine so

367
00:14:22,079 --> 00:14:24,160
every time we're going to call the uh

368
00:14:24,160 --> 00:14:27,519
use the plus operator uh javascript call

369
00:14:27,519 --> 00:14:30,959
will execute c code and that c code is

370
00:14:30,959 --> 00:14:34,320
the function js adnan number

371
00:14:34,320 --> 00:14:37,279
uh this function implements uh adding a

372
00:14:37,279 --> 00:14:41,519
non-number in javascript core of course

373
00:14:42,839 --> 00:14:47,600
okay at first js adnan number will check

374
00:14:47,600 --> 00:14:50,639
if the first argument is a string let me

375
00:14:50,639 --> 00:14:52,959
remind you the first argument

376
00:14:52,959 --> 00:14:55,360
is the string hello and it is a string

377
00:14:55,360 --> 00:14:58,079
so it will continue next it will check

378
00:14:58,079 --> 00:15:01,600
if the second argument is not an object

379
00:15:01,600 --> 00:15:03,600
now let me remind you the second

380
00:15:03,600 --> 00:15:06,079
parameter the second argument

381
00:15:06,079 --> 00:15:09,120
is indeed an object so this

382
00:15:09,120 --> 00:15:11,120
check will return false

383
00:15:11,120 --> 00:15:13,440
if it will return false it will call a

384
00:15:13,440 --> 00:15:15,839
different function called js ed slow

385
00:15:15,839 --> 00:15:18,079
case which will call

386
00:15:18,079 --> 00:15:19,199
the method

387
00:15:19,199 --> 00:15:21,440
to primitive the this method will be

388
00:15:21,440 --> 00:15:24,240
called from the first argument

389
00:15:24,240 --> 00:15:26,399
it will try to convert the first

390
00:15:26,399 --> 00:15:28,320
argument which is the string hello into

391
00:15:28,320 --> 00:15:30,399
a primitive object a primitive object in

392
00:15:30,399 --> 00:15:32,959
javascript is basically a number or a

393
00:15:32,959 --> 00:15:34,240
string

394
00:15:34,240 --> 00:15:36,240
but the first argument is already a

395
00:15:36,240 --> 00:15:37,920
string which means it's already a

396
00:15:37,920 --> 00:15:39,920
primitive object so nothing will happen

397
00:15:39,920 --> 00:15:41,199
here

398
00:15:41,199 --> 00:15:42,959
it will try to convert the second

399
00:15:42,959 --> 00:15:45,839
argument to a primitive object now this

400
00:15:45,839 --> 00:15:46,800
is where the

401
00:15:46,800 --> 00:15:50,880
interesting part happens so when we

402
00:15:50,880 --> 00:15:53,519
try to concatenate an empty object what

403
00:15:53,519 --> 00:15:56,560
happened is that return we got a string

404
00:15:56,560 --> 00:15:59,199
with curly braces meaning that the chord

405
00:15:59,199 --> 00:16:01,759
to two primitive converted the object to

406
00:16:01,759 --> 00:16:04,880
the string curly braces but now we have

407
00:16:04,880 --> 00:16:06,800
a different function in the that's

408
00:16:06,800 --> 00:16:09,600
called tostring to primitive

409
00:16:09,600 --> 00:16:11,440
will search for the

410
00:16:11,440 --> 00:16:14,480
javascript property to string and if

411
00:16:14,480 --> 00:16:17,040
that property exists and it's a valid

412
00:16:17,040 --> 00:16:18,000
function

413
00:16:18,000 --> 00:16:21,199
javascript call will call that function

414
00:16:21,199 --> 00:16:23,279
and eventually this is where

415
00:16:23,279 --> 00:16:25,440
this function is a function that we

416
00:16:25,440 --> 00:16:27,279
completely control

417
00:16:27,279 --> 00:16:29,279
and this is where the side effects

418
00:16:29,279 --> 00:16:31,600
are triggered

419
00:16:31,600 --> 00:16:32,880
okay

420
00:16:32,880 --> 00:16:34,560
so now that we've learned a little bit

421
00:16:34,560 --> 00:16:36,480
about side effects we can focus on

422
00:16:36,480 --> 00:16:39,199
javascript code as promised

423
00:16:39,199 --> 00:16:41,360
so to understand the guts of javascript

424
00:16:41,360 --> 00:16:43,360
call we should first be familiar with

425
00:16:43,360 --> 00:16:45,920
the differences between javascript and c

426
00:16:45,920 --> 00:16:48,000
sometimes be compiled by a just-in-time

427
00:16:48,000 --> 00:16:49,360
compiler

428
00:16:49,360 --> 00:16:51,920
also c is statically typed meaning we

429
00:16:51,920 --> 00:16:54,160
must declare the argument types and the

430
00:16:54,160 --> 00:16:56,800
return value types when writing a new

431
00:16:56,800 --> 00:16:58,160
function

432
00:16:58,160 --> 00:17:00,079
on the other hand javascript is

433
00:17:00,079 --> 00:17:02,160
dynamically typed language meaning we

434
00:17:02,160 --> 00:17:03,600
don't have to declare anything when

435
00:17:03,600 --> 00:17:05,919
writing a new function the same function

436
00:17:05,919 --> 00:17:07,679
can choose to handle whatever type she

437
00:17:07,679 --> 00:17:09,119
wants to

438
00:17:09,119 --> 00:17:12,000
and finally c allows us to have low

439
00:17:12,000 --> 00:17:13,760
level controls such as

440
00:17:13,760 --> 00:17:15,439
direct memory management and even

441
00:17:15,439 --> 00:17:18,559
control over the stack or heap layout

442
00:17:18,559 --> 00:17:20,480
but javascript is pretty much powerful

443
00:17:20,480 --> 00:17:22,319
for everything else

444
00:17:22,319 --> 00:17:24,720
javascript can go fast

445
00:17:24,720 --> 00:17:26,799
this is where jit compilation comfort

446
00:17:26,799 --> 00:17:29,200
comes for the rescue there are photos

447
00:17:29,200 --> 00:17:31,679
that an instruction can live in

448
00:17:31,679 --> 00:17:33,600
javascript so

449
00:17:33,600 --> 00:17:35,760
the first deal we already talked about

450
00:17:35,760 --> 00:17:37,280
it it's the

451
00:17:37,280 --> 00:17:40,960
low level interpreter compiler

452
00:17:40,960 --> 00:17:43,280
this basically takes the javascript

453
00:17:43,280 --> 00:17:46,160
instructions and compiles them into byte

454
00:17:46,160 --> 00:17:48,240
code it's not

455
00:17:48,240 --> 00:17:50,160
it's not actual code that the processor

456
00:17:50,160 --> 00:17:51,919
can execute

457
00:17:51,919 --> 00:17:53,760
it's by code that the javascript engine

458
00:17:53,760 --> 00:17:55,679
can execute

459
00:17:55,679 --> 00:17:58,960
then we have the baseline jit

460
00:17:58,960 --> 00:18:00,799
there is no additional logic regarding

461
00:18:00,799 --> 00:18:03,360
the relation between other instruction

462
00:18:03,360 --> 00:18:05,679
what so on it simply takes the

463
00:18:05,679 --> 00:18:07,760
instructions find

464
00:18:07,760 --> 00:18:10,080
there are plenty of templates in the

465
00:18:10,080 --> 00:18:12,640
javascript call code base and it will

466
00:18:12,640 --> 00:18:14,480
take the template for example we want to

467
00:18:14,480 --> 00:18:16,400
add two numbers it will take the

468
00:18:16,400 --> 00:18:20,480
operation add numbers uh using a

469
00:18:20,480 --> 00:18:22,799
template and it will produce the byte

470
00:18:22,799 --> 00:18:25,679
the the assembly code that represents

471
00:18:25,679 --> 00:18:29,760
that very function that's very operation

472
00:18:29,760 --> 00:18:32,960
next we have the data flow graph jit

473
00:18:32,960 --> 00:18:35,200
compiler

474
00:18:35,200 --> 00:18:37,280
at first javascript

475
00:18:37,280 --> 00:18:39,200
core will represent a given piece of

476
00:18:39,200 --> 00:18:42,240
code or an operation and it will turn it

477
00:18:42,240 --> 00:18:45,120
into data flow graph we will then

478
00:18:45,120 --> 00:18:47,919
see how a data flow graph look like

479
00:18:47,919 --> 00:18:50,640
but it will apply several optimizations

480
00:18:50,640 --> 00:18:53,120
uh on that data flow graph depending on

481
00:18:53,120 --> 00:18:55,760
the relations between

482
00:18:55,760 --> 00:18:57,760
the nodes in the graph

483
00:18:57,760 --> 00:19:00,080
and finally it will compile the data

484
00:19:00,080 --> 00:19:03,760
flow graph using the jit compiler

485
00:19:03,760 --> 00:19:07,200
and the final tier is the ftl faster

486
00:19:07,200 --> 00:19:09,919
than light jit

487
00:19:09,919 --> 00:19:12,000
which highly focuses on optimizing the

488
00:19:12,000 --> 00:19:15,120
compiled code it will simply take all

489
00:19:15,120 --> 00:19:17,200
the optimizations that the data flow

490
00:19:17,200 --> 00:19:19,840
graph jit applied and will ignore the

491
00:19:19,840 --> 00:19:22,160
relation it will simply apply

492
00:19:22,160 --> 00:19:24,400
all the optimizations in it can to a

493
00:19:24,400 --> 00:19:27,120
given piece of code without taking uh in

494
00:19:27,120 --> 00:19:31,280
mind the cost it will take to do so

495
00:19:31,280 --> 00:19:34,080
okay so let's see an illustration of how

496
00:19:34,080 --> 00:19:36,640
javascript core creates a data for graph

497
00:19:36,640 --> 00:19:39,200
for a simple function here we have fu

498
00:19:39,200 --> 00:19:42,320
foo is very simple it simply takes an

499
00:19:42,320 --> 00:19:44,720
argument

500
00:19:44,720 --> 00:19:46,640
it returns the multiplication of the

501
00:19:46,640 --> 00:19:48,160
argument's first

502
00:19:48,160 --> 00:19:51,039
index property with the property y from

503
00:19:51,039 --> 00:19:52,640
this object

504
00:19:52,640 --> 00:19:54,480
now in order to compile the function

505
00:19:54,480 --> 00:19:57,200
using the dfg-jit compiler we need to

506
00:19:57,200 --> 00:20:00,000
execute that function approximately a

507
00:20:00,000 --> 00:20:01,280
thousand times

508
00:20:01,280 --> 00:20:04,400
so to do so we just put a for loop that

509
00:20:04,400 --> 00:20:07,039
will call that function a thousand times

510
00:20:07,039 --> 00:20:09,280
and by doing so uh

511
00:20:09,280 --> 00:20:10,559
we will

512
00:20:10,559 --> 00:20:14,320
compile that function using the dfg jit

513
00:20:14,320 --> 00:20:16,480
after doing so let's look at the pseudo

514
00:20:16,480 --> 00:20:18,320
data flow graph created for that

515
00:20:18,320 --> 00:20:19,440
function

516
00:20:19,440 --> 00:20:20,559
and of course

517
00:20:20,559 --> 00:20:23,200
at the beginning we set arg as the

518
00:20:23,200 --> 00:20:25,039
argument

519
00:20:25,039 --> 00:20:27,520
next we make sure that alg is an array

520
00:20:27,520 --> 00:20:30,240
the reason for that is that

521
00:20:30,240 --> 00:20:33,600
we access the first index property of

522
00:20:33,600 --> 00:20:37,120
out and therefore it must be an array

523
00:20:37,120 --> 00:20:39,440
if it is an array we're going to create

524
00:20:39,440 --> 00:20:43,679
and save this object into v0

525
00:20:43,679 --> 00:20:46,000
and then we will fetch the property y

526
00:20:46,000 --> 00:20:49,520
from this and save it under v1

527
00:20:49,520 --> 00:20:52,320
finally we load the index property 0

528
00:20:52,320 --> 00:20:53,760
from arg

529
00:20:53,760 --> 00:20:58,879
and multiply v1 with v2 and return it

530
00:20:59,039 --> 00:21:01,280
as mentioned earlier one of the biggest

531
00:21:01,280 --> 00:21:03,200
advantages of the telephone graph jit

532
00:21:03,200 --> 00:21:06,080
compiler is its optimizations redundancy

533
00:21:06,080 --> 00:21:08,720
elimination is a core optimization in

534
00:21:08,720 --> 00:21:11,200
the delfo graph jit compiler

535
00:21:11,200 --> 00:21:13,360
by using the relations between the nodes

536
00:21:13,360 --> 00:21:16,080
in the dataflow graph it can determine

537
00:21:16,080 --> 00:21:18,400
which guards are redundant and which are

538
00:21:18,400 --> 00:21:20,559
not which are crucial in a matter of

539
00:21:20,559 --> 00:21:22,640
fact each redundant guard will be

540
00:21:22,640 --> 00:21:25,760
removed pre-compilation and it will save

541
00:21:25,760 --> 00:21:29,200
time while executing that code

542
00:21:29,200 --> 00:21:30,559
so let's take a look at the following

543
00:21:30,559 --> 00:21:32,159
function which which returns the

544
00:21:32,159 --> 00:21:35,200
division of the two properties fetched

545
00:21:35,200 --> 00:21:37,120
from uh arg

546
00:21:37,120 --> 00:21:38,640
so the data flow graph will look like

547
00:21:38,640 --> 00:21:40,640
that at first we'll set alg as an

548
00:21:40,640 --> 00:21:41,919
argument

549
00:21:41,919 --> 00:21:43,840
then we'll make sure that algae is an

550
00:21:43,840 --> 00:21:45,280
object

551
00:21:45,280 --> 00:21:49,520
because we fetch properties from that uh

552
00:21:49,520 --> 00:21:50,799
argument

553
00:21:50,799 --> 00:21:53,600
then we'll fetch one one argument so for

554
00:21:53,600 --> 00:21:55,600
example we'll fetch y

555
00:21:55,600 --> 00:21:58,720
and then we'll check again that arg is

556
00:21:58,720 --> 00:22:01,120
still an object if it is an object will

557
00:22:01,120 --> 00:22:02,880
fetch x as well

558
00:22:02,880 --> 00:22:04,799
and finally we return the division

559
00:22:04,799 --> 00:22:07,679
between these two

560
00:22:08,159 --> 00:22:11,280
if property y exists the second check is

561
00:22:11,280 --> 00:22:12,559
redundant

562
00:22:12,559 --> 00:22:13,440
why

563
00:22:13,440 --> 00:22:14,720
because

564
00:22:14,720 --> 00:22:17,120
nothing has changed in object in our

565
00:22:17,120 --> 00:22:19,520
object so there is no reason to make

566
00:22:19,520 --> 00:22:21,280
sure that it's still an object nothing

567
00:22:21,280 --> 00:22:25,600
happens y exists everything is good

568
00:22:25,600 --> 00:22:27,440
let's save some time during the

569
00:22:27,440 --> 00:22:28,880
execution and that's exactly what

570
00:22:28,880 --> 00:22:31,200
javascript call does

571
00:22:31,200 --> 00:22:34,080
but what can go wrong

572
00:22:34,080 --> 00:22:36,480
if by fetching y it could cause side

573
00:22:36,480 --> 00:22:39,280
effects an attacker can change the value

574
00:22:39,280 --> 00:22:42,080
of alg and change it and change it from

575
00:22:42,080 --> 00:22:44,480
object to a different type

576
00:22:44,480 --> 00:22:47,360
then javascript call will think that alg

577
00:22:47,360 --> 00:22:49,120
is an object because we remove that

578
00:22:49,120 --> 00:22:51,360
check and even though it is not an

579
00:22:51,360 --> 00:22:52,960
object and this could

580
00:22:52,960 --> 00:22:55,280
lead into type confusion bugs which

581
00:22:55,280 --> 00:22:56,960
could help an attacker achieve remote

582
00:22:56,960 --> 00:22:59,200
code execution

583
00:22:59,200 --> 00:23:01,120
we know that removing necessary checks

584
00:23:01,120 --> 00:23:02,960
can allow an attacker to achieve remote

585
00:23:02,960 --> 00:23:04,480
code execution

586
00:23:04,480 --> 00:23:06,400
in order to deal with that issue

587
00:23:06,400 --> 00:23:08,640
javascript call must know which

588
00:23:08,640 --> 00:23:10,960
operation can cause side effects and

589
00:23:10,960 --> 00:23:12,480
under which terms

590
00:23:12,480 --> 00:23:15,520
for example adding two numbers cannot

591
00:23:15,520 --> 00:23:17,520
cause side effects

592
00:23:17,520 --> 00:23:20,000
but as we saw earlier adding a string

593
00:23:20,000 --> 00:23:22,240
with an object can indeed cause side

594
00:23:22,240 --> 00:23:24,000
effects and javascript core must be a

595
00:23:24,000 --> 00:23:24,960
well

596
00:23:24,960 --> 00:23:26,320
so javascript call must read the

597
00:23:26,320 --> 00:23:28,720
argument types as well

598
00:23:28,720 --> 00:23:30,880
the side effect modeling is done by the

599
00:23:30,880 --> 00:23:32,960
function execute effects you can see the

600
00:23:32,960 --> 00:23:34,480
full path

601
00:23:34,480 --> 00:23:36,559
in the slide

602
00:23:36,559 --> 00:23:38,400
under each case

603
00:23:38,400 --> 00:23:40,240
that function will hold a giant switch

604
00:23:40,240 --> 00:23:41,440
case

605
00:23:41,440 --> 00:23:43,520
each case represents a javascript

606
00:23:43,520 --> 00:23:45,279
operation

607
00:23:45,279 --> 00:23:47,520
javascript call under each case will

608
00:23:47,520 --> 00:23:50,080
determine uh if an operation can cause

609
00:23:50,080 --> 00:23:52,559
side effects and if that operation can

610
00:23:52,559 --> 00:23:54,240
cause side effects can cause side

611
00:23:54,240 --> 00:23:56,400
effects javascript core will call a

612
00:23:56,400 --> 00:23:58,799
function called clobber wall so let's

613
00:23:58,799 --> 00:24:00,559
take a look at an example

614
00:24:00,559 --> 00:24:01,360
uh

615
00:24:01,360 --> 00:24:03,760
right here this is a actual snippet from

616
00:24:03,760 --> 00:24:05,120
javascript core

617
00:24:05,120 --> 00:24:07,760
from the execute effects function

618
00:24:07,760 --> 00:24:09,840
you can see both upper operations can

619
00:24:09,840 --> 00:24:11,279
cause side effects according to the

620
00:24:11,279 --> 00:24:13,600
modeling of javascript call because

621
00:24:13,600 --> 00:24:16,400
under both cases there is a call to club

622
00:24:16,400 --> 00:24:18,559
a wall one here

623
00:24:18,559 --> 00:24:20,159
and one there

624
00:24:20,159 --> 00:24:22,159
but at the final

625
00:24:22,159 --> 00:24:25,039
uh operation at the third one we can see

626
00:24:25,039 --> 00:24:27,919
that the javascript call can assume that

627
00:24:27,919 --> 00:24:30,480
this operation cannot cause side effects

628
00:24:30,480 --> 00:24:32,720
because there is no call to global

629
00:24:32,720 --> 00:24:34,799
warming

630
00:24:34,799 --> 00:24:36,960
all right

631
00:24:36,960 --> 00:24:39,200
this was the second part of our talk

632
00:24:39,200 --> 00:24:41,039
we've learned that the data flow graph

633
00:24:41,039 --> 00:24:43,200
jit compiler can be an interesting

634
00:24:43,200 --> 00:24:46,240
surface for an attacker to find new bugs

635
00:24:46,240 --> 00:24:48,159
in javascript core of course when

636
00:24:48,159 --> 00:24:50,320
focusing on the redundancy elimination

637
00:24:50,320 --> 00:24:53,279
optimization combined with side effects

638
00:24:53,279 --> 00:24:56,080
in javascript

639
00:24:56,080 --> 00:24:58,640
now let's try to make the world a safer

640
00:24:58,640 --> 00:25:01,520
place by hunting this bug bugs ourself

641
00:25:01,520 --> 00:25:04,400
using codeql perfect

642
00:25:04,400 --> 00:25:06,799
that's me

643
00:25:07,200 --> 00:25:09,360
now before writing new and complex

644
00:25:09,360 --> 00:25:11,760
queries we should understand the bug

645
00:25:11,760 --> 00:25:14,559
that we're hunting as best as possible

646
00:25:14,559 --> 00:25:16,400
and this tip applies to every bug you're

647
00:25:16,400 --> 00:25:18,559
hunting especially if you're using code

648
00:25:18,559 --> 00:25:21,039
qr so let's analyze together a

649
00:25:21,039 --> 00:25:24,480
vulnerability found in 2018 that allowed

650
00:25:24,480 --> 00:25:27,039
an attacker to achieve full remote core

651
00:25:27,039 --> 00:25:29,679
execution via safari

652
00:25:29,679 --> 00:25:31,440
this vulnerability of course is

653
00:25:31,440 --> 00:25:34,400
triggered by bad side effect modeling

654
00:25:34,400 --> 00:25:38,400
of the instance of operation

655
00:25:39,600 --> 00:25:41,600
let's start with the let's start from

656
00:25:41,600 --> 00:25:42,480
the end

657
00:25:42,480 --> 00:25:44,320
by answering the question how did they

658
00:25:44,320 --> 00:25:46,400
patch the this bug

659
00:25:46,400 --> 00:25:48,720
uh and let's let's understand the patch

660
00:25:48,720 --> 00:25:49,919
it's very simple

661
00:25:49,919 --> 00:25:52,480
both snippets you can see

662
00:25:52,480 --> 00:25:55,440
it's divided to two both snippets were

663
00:25:55,440 --> 00:25:58,320
taken from the function execute effects

664
00:25:58,320 --> 00:25:59,600
the function

665
00:25:59,600 --> 00:26:00,400
that

666
00:26:00,400 --> 00:26:01,840
as we've mentioned earlier is

667
00:26:01,840 --> 00:26:05,120
responsible for modeling for side effect

668
00:26:05,120 --> 00:26:07,840
modeling in javascript core

669
00:26:07,840 --> 00:26:09,279
on the left side we can see the

670
00:26:09,279 --> 00:26:11,440
vulnerable version and on the right side

671
00:26:11,440 --> 00:26:13,760
the patched one the developers simply

672
00:26:13,760 --> 00:26:16,240
added a call to club of wall under the

673
00:26:16,240 --> 00:26:18,640
case that represent the instance of

674
00:26:18,640 --> 00:26:19,840
operation

675
00:26:19,840 --> 00:26:22,320
this is the only

676
00:26:22,320 --> 00:26:24,480
line that was added to the code in order

677
00:26:24,480 --> 00:26:26,080
to fix that bug

678
00:26:26,080 --> 00:26:28,000
so this will

679
00:26:28,000 --> 00:26:30,880
this tells us that the vulnerability

680
00:26:30,880 --> 00:26:34,559
is indeed uh around the uh side effect

681
00:26:34,559 --> 00:26:36,559
modeling the javascript call was doing

682
00:26:36,559 --> 00:26:38,880
to that operation

683
00:26:38,880 --> 00:26:40,799
you can see they only added a call to

684
00:26:40,799 --> 00:26:44,400
global wall in order to fix the bug

685
00:26:44,400 --> 00:26:46,400
we know that the instance of operation

686
00:26:46,400 --> 00:26:48,480
wasn't modeled correctly therefore we

687
00:26:48,480 --> 00:26:50,880
simply need to find how it is possible

688
00:26:50,880 --> 00:26:53,120
to trigger side effect using that

689
00:26:53,120 --> 00:26:54,480
operation

690
00:26:54,480 --> 00:26:56,880
to do so let's take a look at a part of

691
00:26:56,880 --> 00:26:58,480
the exploit

692
00:26:58,480 --> 00:26:59,760
at first

693
00:26:59,760 --> 00:27:02,000
we only need to create two classes two

694
00:27:02,000 --> 00:27:03,360
empty classes

695
00:27:03,360 --> 00:27:04,559
then

696
00:27:04,559 --> 00:27:07,279
we create a new object named handler

697
00:27:07,279 --> 00:27:08,960
that have a single function property

698
00:27:08,960 --> 00:27:11,360
called get prototype off

699
00:27:11,360 --> 00:27:13,840
uh the doesn't matter what the function

700
00:27:13,840 --> 00:27:15,600
does this is where we're gonna put the

701
00:27:15,600 --> 00:27:18,000
malicious exploit but eventually it will

702
00:27:18,000 --> 00:27:20,640
return a class prototype

703
00:27:20,640 --> 00:27:24,399
then we replace the prototype of trigger

704
00:27:24,399 --> 00:27:27,200
class with a proxy object this is very

705
00:27:27,200 --> 00:27:30,720
impro important we replace the prototype

706
00:27:30,720 --> 00:27:32,840
object with a proxy

707
00:27:32,840 --> 00:27:35,520
object and the pro the prototype the

708
00:27:35,520 --> 00:27:37,840
proxy object now has a

709
00:27:37,840 --> 00:27:40,240
the handler that we defined earlier

710
00:27:40,240 --> 00:27:43,360
and finally all we need to do is uh

711
00:27:43,360 --> 00:27:46,159
of course compile uh instance of using

712
00:27:46,159 --> 00:27:48,720
the data flow graph jit and then call

713
00:27:48,720 --> 00:27:51,360
instance of as follow this would

714
00:27:51,360 --> 00:27:53,120
trigger the bug

715
00:27:53,120 --> 00:27:55,520
the reason for that is that javascript

716
00:27:55,520 --> 00:27:57,679
call already thinks that

717
00:27:57,679 --> 00:28:00,000
instanceof cannot cause side effects

718
00:28:00,000 --> 00:28:02,720
meaning that we see now that in order to

719
00:28:02,720 --> 00:28:05,360
trigger side effects using the instance

720
00:28:05,360 --> 00:28:08,720
of operation we need to do something uh

721
00:28:08,720 --> 00:28:11,120
with the with replacing its prototype

722
00:28:11,120 --> 00:28:14,320
with a proxy object that's the final uh

723
00:28:14,320 --> 00:28:16,799
goal of that code snippet let's try to

724
00:28:16,799 --> 00:28:19,200
understand how the operation of instance

725
00:28:19,200 --> 00:28:21,039
off is implemented

726
00:28:21,039 --> 00:28:24,240
so this is the implementation of

727
00:28:24,240 --> 00:28:26,799
it that is inside the javascript call

728
00:28:26,799 --> 00:28:28,799
meaning it's written in c it's not the

729
00:28:28,799 --> 00:28:30,559
javascript implementation it's

730
00:28:30,559 --> 00:28:32,559
javascript core implementation

731
00:28:32,559 --> 00:28:34,720
uh at first it will call the default has

732
00:28:34,720 --> 00:28:36,080
instance

733
00:28:36,080 --> 00:28:37,360
uh

734
00:28:37,360 --> 00:28:40,480
which will eventually uh heal we'll call

735
00:28:40,480 --> 00:28:42,799
the method get prototype

736
00:28:42,799 --> 00:28:45,919
object is the argument so uh trigger

737
00:28:45,919 --> 00:28:48,559
class is our object and the method the

738
00:28:48,559 --> 00:28:50,480
method that will be called is get

739
00:28:50,480 --> 00:28:51,600
prototype

740
00:28:51,600 --> 00:28:54,240
uh of course trigger class is an object

741
00:28:54,240 --> 00:28:56,480
so we're gonna go to the implementation

742
00:28:56,480 --> 00:29:00,320
of get prototype from a js object and

743
00:29:00,320 --> 00:29:01,200
then

744
00:29:01,200 --> 00:29:02,799
oh okay

745
00:29:02,799 --> 00:29:05,200
well what happened here we replaced if

746
00:29:05,200 --> 00:29:07,200
you remember we replaced the prototype

747
00:29:07,200 --> 00:29:08,159
of

748
00:29:08,159 --> 00:29:10,960
of trigger class with a proxy object so

749
00:29:10,960 --> 00:29:12,399
the actual

750
00:29:12,399 --> 00:29:13,760
get prototype

751
00:29:13,760 --> 00:29:15,760
function that will be called is from

752
00:29:15,760 --> 00:29:18,480
proxy object not from js object but

753
00:29:18,480 --> 00:29:20,640
proxy object and that function has a

754
00:29:20,640 --> 00:29:23,120
completely different implementation

755
00:29:23,120 --> 00:29:24,960
this function

756
00:29:24,960 --> 00:29:28,559
uh will actually fetch the handler

757
00:29:28,559 --> 00:29:31,200
the proxy object handler and it will

758
00:29:31,200 --> 00:29:32,640
call the

759
00:29:32,640 --> 00:29:34,399
get prototype of

760
00:29:34,399 --> 00:29:37,120
a javascript function that we control

761
00:29:37,120 --> 00:29:41,399
and this is where the side effects occur

762
00:29:42,240 --> 00:29:43,200
great

763
00:29:43,200 --> 00:29:45,440
we are looking for okay so let's try to

764
00:29:45,440 --> 00:29:46,640
define the

765
00:29:46,640 --> 00:29:48,480
that bug and i hope you understood that

766
00:29:48,480 --> 00:29:49,840
bug

767
00:29:49,840 --> 00:29:52,000
let's try to define that bug using code

768
00:29:52,000 --> 00:29:53,200
ql

769
00:29:53,200 --> 00:29:56,320
are looking for an operation that a

770
00:29:56,320 --> 00:29:58,240
javascript call would not call

771
00:29:58,240 --> 00:29:59,440
cloverwall

772
00:29:59,440 --> 00:30:01,760
under the execute effect function

773
00:30:01,760 --> 00:30:02,799
and b

774
00:30:02,799 --> 00:30:05,200
that function can trigger side effects

775
00:30:05,200 --> 00:30:07,039
even though javascript code assumed it

776
00:30:07,039 --> 00:30:09,840
cannot

777
00:30:10,320 --> 00:30:12,720
how do we define the side effects at all

778
00:30:12,720 --> 00:30:15,520
so there are three major challenges

779
00:30:15,520 --> 00:30:17,520
we need to solve in order to make our

780
00:30:17,520 --> 00:30:19,760
query useful

781
00:30:19,760 --> 00:30:22,320
at first we need to model each operation

782
00:30:22,320 --> 00:30:24,960
for side effects ourselves using colquel

783
00:30:24,960 --> 00:30:26,559
although this challenge is very

784
00:30:26,559 --> 00:30:28,960
interesting to solve i've decided that

785
00:30:28,960 --> 00:30:31,600
we will not talk about this in this talk

786
00:30:31,600 --> 00:30:34,320
because due to time constraints but rest

787
00:30:34,320 --> 00:30:36,320
assured that the entire query is

788
00:30:36,320 --> 00:30:38,960
available in a public repo and i added a

789
00:30:38,960 --> 00:30:40,559
link to that report at the end of the

790
00:30:40,559 --> 00:30:41,840
slides

791
00:30:41,840 --> 00:30:43,760
we'll focus on solving the second

792
00:30:43,760 --> 00:30:45,039
challenge

793
00:30:45,039 --> 00:30:47,360
which is finding which operations can

794
00:30:47,360 --> 00:30:48,880
trigger side effects

795
00:30:48,880 --> 00:30:50,799
specifically speaking we're looking for

796
00:30:50,799 --> 00:30:53,600
operations that can trigger side effects

797
00:30:53,600 --> 00:30:56,159
using a proxy object

798
00:30:56,159 --> 00:30:57,190
so it's the same

799
00:30:57,190 --> 00:30:58,399
[Music]

800
00:30:58,399 --> 00:31:01,600
way that the instance of

801
00:31:01,600 --> 00:31:04,480
operation trigger side effects after

802
00:31:04,480 --> 00:31:06,720
this presentation i encourage you all to

803
00:31:06,720 --> 00:31:09,039
modify the query so that it will find

804
00:31:09,039 --> 00:31:12,559
other timeout strings that's

805
00:31:12,880 --> 00:31:14,960
defining the side effect this is like

806
00:31:14,960 --> 00:31:18,320
the crucial part of the query

807
00:31:18,320 --> 00:31:19,840
so the side effect that we're looking

808
00:31:19,840 --> 00:31:20,960
for

809
00:31:20,960 --> 00:31:23,039
is constructed out of three parts the

810
00:31:23,039 --> 00:31:25,440
first part receives a parameter with the

811
00:31:25,440 --> 00:31:28,159
type of js object or

812
00:31:28,159 --> 00:31:30,320
somewhere during the flow of that

813
00:31:30,320 --> 00:31:33,039
operation a parameter will be converted

814
00:31:33,039 --> 00:31:35,200
into a js object

815
00:31:35,200 --> 00:31:38,080
then there is a method called form that

816
00:31:38,080 --> 00:31:39,679
js object

817
00:31:39,679 --> 00:31:42,159
and finally there must be a different

818
00:31:42,159 --> 00:31:45,440
method from the class proxy object that

819
00:31:45,440 --> 00:31:48,080
shares the same name as the called

820
00:31:48,080 --> 00:31:51,760
method from js object

821
00:31:51,760 --> 00:31:54,159
let's remember we want to find operation

822
00:31:54,159 --> 00:31:57,600
that handles with js object

823
00:31:57,600 --> 00:31:59,840
the simplest scenario

824
00:31:59,840 --> 00:32:01,919
is the following where the operation

825
00:32:01,919 --> 00:32:04,000
receives as its input as one of its

826
00:32:04,000 --> 00:32:07,039
parameters adjacent objects like here

827
00:32:07,039 --> 00:32:09,519
let's write the query real quick

828
00:32:09,519 --> 00:32:11,670
we'll import c plus plus

829
00:32:11,670 --> 00:32:13,039
[Music]

830
00:32:13,039 --> 00:32:14,480
and we have two

831
00:32:14,480 --> 00:32:16,159
codeql elements the first one is

832
00:32:16,159 --> 00:32:17,519
variable which represents all the

833
00:32:17,519 --> 00:32:20,080
variable declarations and another one a

834
00:32:20,080 --> 00:32:23,120
variable x axis which represents all the

835
00:32:23,120 --> 00:32:25,919
accesses to a variable

836
00:32:25,919 --> 00:32:28,080
this way we tell codql that we are

837
00:32:28,080 --> 00:32:30,240
looking for a

838
00:32:30,240 --> 00:32:33,440
variable from the type js object

839
00:32:33,440 --> 00:32:35,760
and then all we got to do is link the

840
00:32:35,760 --> 00:32:38,320
variable access to that variable

841
00:32:38,320 --> 00:32:41,679
and now js object access represents an

842
00:32:41,679 --> 00:32:45,279
access to a js object variable

843
00:32:45,279 --> 00:32:47,120
but what if the operation receives a

844
00:32:47,120 --> 00:32:49,919
generic type and it will then convert

845
00:32:49,919 --> 00:32:53,600
that argument into a js object like this

846
00:32:53,600 --> 00:32:56,799
so here we see that the parameters

847
00:32:56,799 --> 00:32:59,919
are different from js object but

848
00:32:59,919 --> 00:33:02,159
somewhere in the code we convert base

849
00:33:02,159 --> 00:33:06,399
which is a parameter into a js object

850
00:33:06,399 --> 00:33:09,120
okay let's try to do it with coql at

851
00:33:09,120 --> 00:33:11,519
first let's define all the co-ql

852
00:33:11,519 --> 00:33:12,720
elements

853
00:33:12,720 --> 00:33:15,360
we have a function call which represents

854
00:33:15,360 --> 00:33:17,360
all the calls to function and variable

855
00:33:17,360 --> 00:33:19,679
axis which represents all the accesses

856
00:33:19,679 --> 00:33:21,519
to a variable

857
00:33:21,519 --> 00:33:23,600
now that we define the

858
00:33:23,600 --> 00:33:25,679
the expressions

859
00:33:25,679 --> 00:33:27,519
let's let's make sure that

860
00:33:27,519 --> 00:33:31,039
as object will point will hold all the

861
00:33:31,039 --> 00:33:33,760
calls to as object like here

862
00:33:33,760 --> 00:33:35,519
and then we can extract

863
00:33:35,519 --> 00:33:37,600
its argument we we're interested in the

864
00:33:37,600 --> 00:33:40,880
argument so let's link the variable uh

865
00:33:40,880 --> 00:33:43,200
the all the expressions as object

866
00:33:43,200 --> 00:33:46,480
arguments and make sure that they are

867
00:33:46,480 --> 00:33:47,600
inside

868
00:33:47,600 --> 00:33:50,000
that they received as an argument to the

869
00:33:50,000 --> 00:33:53,760
as object function this way

870
00:33:53,760 --> 00:33:56,640
then we'll use data flow analysis again

871
00:33:56,640 --> 00:33:58,720
to find the flow from the return value

872
00:33:58,720 --> 00:34:01,679
of the function as object to all the js

873
00:34:01,679 --> 00:34:03,519
object accesses

874
00:34:03,519 --> 00:34:04,640
like so

875
00:34:04,640 --> 00:34:06,399
the first dataflow analysis

876
00:34:06,399 --> 00:34:08,079
is from uh

877
00:34:08,079 --> 00:34:10,399
a parameter of a js object this is the

878
00:34:10,399 --> 00:34:12,239
first uh argument

879
00:34:12,239 --> 00:34:15,760
uh to the argument of a of the function

880
00:34:15,760 --> 00:34:17,199
js object

881
00:34:17,199 --> 00:34:19,520
like here and then we we simply need to

882
00:34:19,520 --> 00:34:20,480
find the

883
00:34:20,480 --> 00:34:22,320
data flow uh using the data flow

884
00:34:22,320 --> 00:34:23,679
analysis

885
00:34:23,679 --> 00:34:26,879
the second flow is from the return value

886
00:34:26,879 --> 00:34:29,280
of the function as object

887
00:34:29,280 --> 00:34:30,960
like here

888
00:34:30,960 --> 00:34:34,399
to every js object access js object

889
00:34:34,399 --> 00:34:36,719
access is like this one or this one and

890
00:34:36,719 --> 00:34:38,719
then we have to find the flow

891
00:34:38,719 --> 00:34:42,000
if there is a valid flow in a certain

892
00:34:42,000 --> 00:34:44,960
javascript core operation we know that

893
00:34:44,960 --> 00:34:48,000
somewhere doing that execution a

894
00:34:48,000 --> 00:34:50,239
parameter will be converted to a js

895
00:34:50,239 --> 00:34:51,839
object and this is exactly what we're

896
00:34:51,839 --> 00:34:53,679
looking for

897
00:34:53,679 --> 00:34:55,839
now that we find all the interesting js

898
00:34:55,839 --> 00:34:58,480
object accesses all we need to do is to

899
00:34:58,480 --> 00:35:00,560
make sure there is a method called

900
00:35:00,560 --> 00:35:02,560
form.js object

901
00:35:02,560 --> 00:35:04,640
and that there is a different method in

902
00:35:04,640 --> 00:35:07,359
the class proxy object that shares its

903
00:35:07,359 --> 00:35:10,560
name with the called method we found

904
00:35:10,560 --> 00:35:13,520
let's do it with coql

905
00:35:13,520 --> 00:35:16,079
a quick recap by now we were able to

906
00:35:16,079 --> 00:35:18,800
identify every operation that has an

907
00:35:18,800 --> 00:35:20,880
argument which is a js object or

908
00:35:20,880 --> 00:35:22,960
somewhere in the flow of the code will

909
00:35:22,960 --> 00:35:25,359
convert one of its argument into a js

910
00:35:25,359 --> 00:35:26,640
object

911
00:35:26,640 --> 00:35:28,880
now we need to find if somewhere in the

912
00:35:28,880 --> 00:35:31,359
code there is a call to a method from

913
00:35:31,359 --> 00:35:33,200
that js object

914
00:35:33,200 --> 00:35:35,599
not only that that method must share the

915
00:35:35,599 --> 00:35:37,680
same name with an existing method from

916
00:35:37,680 --> 00:35:39,359
proxy object

917
00:35:39,359 --> 00:35:41,280
let's start by defining the codeql

918
00:35:41,280 --> 00:35:43,599
elements so as usual

919
00:35:43,599 --> 00:35:44,800
as usual

920
00:35:44,800 --> 00:35:47,680
jsobject method will represent a method

921
00:35:47,680 --> 00:35:50,079
from the class js object

922
00:35:50,079 --> 00:35:54,320
and this is how we can do it with coql

923
00:35:54,320 --> 00:35:55,920
yeah so

924
00:35:55,920 --> 00:35:57,040
we

925
00:35:57,040 --> 00:36:00,240
we basically bound the js object get

926
00:36:00,240 --> 00:36:03,520
using get qualifier to the js object so

927
00:36:03,520 --> 00:36:05,599
the qualifier to the get prototype

928
00:36:05,599 --> 00:36:08,960
method is a object an object is a js

929
00:36:08,960 --> 00:36:10,560
object

930
00:36:10,560 --> 00:36:13,119
let's bound the element from the element

931
00:36:13,119 --> 00:36:15,599
from proxy this is supposed to represent

932
00:36:15,599 --> 00:36:19,599
a method called form the proxy class

933
00:36:19,599 --> 00:36:21,359
by the way this is

934
00:36:21,359 --> 00:36:24,400
not the only way to bound uh from proxy

935
00:36:24,400 --> 00:36:26,400
this is that's the way that i chose

936
00:36:26,400 --> 00:36:27,280
but

937
00:36:27,280 --> 00:36:29,520
from proxy is an object and we make sure

938
00:36:29,520 --> 00:36:32,240
that the scope of that function

939
00:36:32,240 --> 00:36:34,800
belongs to from proxy a proxy object

940
00:36:34,800 --> 00:36:36,560
sorry

941
00:36:36,560 --> 00:36:38,320
you can choose the different approach to

942
00:36:38,320 --> 00:36:40,640
achieve the same result

943
00:36:40,640 --> 00:36:42,720
finally

944
00:36:42,720 --> 00:36:45,680
we want both message methods to share

945
00:36:45,680 --> 00:36:48,400
the same name so we compare the js

946
00:36:48,400 --> 00:36:52,720
object method name with the from proxy

947
00:36:52,720 --> 00:36:53,520
name

948
00:36:53,520 --> 00:36:54,880
like so

949
00:36:54,880 --> 00:36:58,560
and eventually we need to execute it so

950
00:36:58,560 --> 00:37:00,160
this will find

951
00:37:00,160 --> 00:37:01,119
all the

952
00:37:01,119 --> 00:37:02,320
js

953
00:37:02,320 --> 00:37:04,000
js operations

954
00:37:04,000 --> 00:37:04,880
that

955
00:37:04,880 --> 00:37:06,720
handles with a

956
00:37:06,720 --> 00:37:08,480
proc with the

957
00:37:08,480 --> 00:37:11,599
sorry the handles js objects

958
00:37:11,599 --> 00:37:12,960
and uh

959
00:37:12,960 --> 00:37:16,160
that these js objects call methods that

960
00:37:16,160 --> 00:37:20,320
share the same name with a proxy object

961
00:37:20,320 --> 00:37:22,240
we can now extract all the operations

962
00:37:22,240 --> 00:37:25,040
that can cause side effects uh the side

963
00:37:25,040 --> 00:37:27,760
effect that we defined earlier but that

964
00:37:27,760 --> 00:37:30,000
javascript core assumes they cannot

965
00:37:30,000 --> 00:37:32,240
cause side effects and this is exactly

966
00:37:32,240 --> 00:37:34,320
where the bug lies in

967
00:37:34,320 --> 00:37:36,400
so finally after running our query

968
00:37:36,400 --> 00:37:38,960
against the database compiled

969
00:37:38,960 --> 00:37:40,640
from the vulnerable version of

970
00:37:40,640 --> 00:37:43,359
javascript code we got this result

971
00:37:43,359 --> 00:37:45,200
we can see that there are four potential

972
00:37:45,200 --> 00:37:47,920
vulnerable operations one of them is

973
00:37:47,920 --> 00:37:50,640
indeed the vulnerable instance of so

974
00:37:50,640 --> 00:37:53,200
this is a success already but what about

975
00:37:53,200 --> 00:37:55,598
the rest

976
00:37:56,320 --> 00:37:58,480
although i could not approve that all

977
00:37:58,480 --> 00:38:00,800
four operations are vulnerable i did

978
00:38:00,800 --> 00:38:03,359
found that the operation create this is

979
00:38:03,359 --> 00:38:05,520
indeed vulnerable and this is awesome

980
00:38:05,520 --> 00:38:07,280
this vulnerability was discovered by

981
00:38:07,280 --> 00:38:09,280
cielo and it shares the same

982
00:38:09,280 --> 00:38:11,920
characteristics as the instance of bug

983
00:38:11,920 --> 00:38:14,079
so this is definitely strength my

984
00:38:14,079 --> 00:38:16,480
intuition regarding the correctness of

985
00:38:16,480 --> 00:38:19,640
the query

986
00:38:21,200 --> 00:38:23,040
let's have a quick recap a summary of

987
00:38:23,040 --> 00:38:24,560
what we've talked about

988
00:38:24,560 --> 00:38:26,240
by now

989
00:38:26,240 --> 00:38:27,280
that's me

990
00:38:27,280 --> 00:38:29,440
we are a calculator tutorial

991
00:38:29,440 --> 00:38:32,000
we talked about what is codeql what's

992
00:38:32,000 --> 00:38:34,640
the structure of a query in codeql

993
00:38:34,640 --> 00:38:36,720
we've talked about the building blocks

994
00:38:36,720 --> 00:38:37,599
uh

995
00:38:37,599 --> 00:38:38,960
of codecoil

996
00:38:38,960 --> 00:38:40,960
for example variable function call and

997
00:38:40,960 --> 00:38:43,040
we even talked about data flow analysis

998
00:38:43,040 --> 00:38:44,880
in code ql

999
00:38:44,880 --> 00:38:47,440
then we talked about javascript core we

1000
00:38:47,440 --> 00:38:50,000
had a javascript core 101 session

1001
00:38:50,000 --> 00:38:52,240
talked about the differences between

1002
00:38:52,240 --> 00:38:54,720
javascript and c

1003
00:38:54,720 --> 00:38:56,560
javascript side effects

1004
00:38:56,560 --> 00:38:58,720
and javascript called execution tiers

1005
00:38:58,720 --> 00:39:02,400
the all the jit compilers that exist in

1006
00:39:02,400 --> 00:39:04,640
that

1007
00:39:05,920 --> 00:39:08,320
and finally we've talked about bad side

1008
00:39:08,320 --> 00:39:10,560
effect modeling bugs

1009
00:39:10,560 --> 00:39:12,800
what are the po what are the what is the

1010
00:39:12,800 --> 00:39:15,200
potential of these bugs how lo how to

1011
00:39:15,200 --> 00:39:17,520
look for them and how to translate these

1012
00:39:17,520 --> 00:39:20,400
bugs into cultural query queries if

1013
00:39:20,400 --> 00:39:22,640
you're interested in further reading uh

1014
00:39:22,640 --> 00:39:24,720
you can of course read about uh

1015
00:39:24,720 --> 00:39:26,800
a blog post that i posted that talks

1016
00:39:26,800 --> 00:39:30,480
about the codeul in more details

1017
00:39:30,480 --> 00:39:32,720
and then of course the blog post that i

1018
00:39:32,720 --> 00:39:34,960
posted about the mysterious realm of

1019
00:39:34,960 --> 00:39:37,760
javascript core

1020
00:39:37,760 --> 00:39:39,200
and the

1021
00:39:39,200 --> 00:39:41,119
github link

1022
00:39:41,119 --> 00:39:44,480
to the query itself

1023
00:39:44,720 --> 00:39:46,960
and that's it thank you very much

1024
00:39:46,960 --> 00:39:49,200
besides budapest i hope you enjoyed that

1025
00:39:49,200 --> 00:39:50,800
talk

1026
00:39:50,800 --> 00:39:52,240
and i'm

1027
00:39:52,240 --> 00:39:54,079
available for any questions that you

1028
00:39:54,079 --> 00:39:55,520
might have

1029
00:39:55,520 --> 00:39:58,240
via twitter or email

1030
00:39:58,240 --> 00:40:00,079
feel free to contact me

1031
00:40:00,079 --> 00:40:02,160
and thank you thank you very much

1032
00:40:02,160 --> 00:40:03,520
have a

1033
00:40:03,520 --> 00:40:06,880
nice day and enjoy the rest of the

1034
00:40:06,880 --> 00:40:09,760
the conference

