1
00:00:06,480 --> 00:00:07,520
all right hello everyone

2
00:00:07,520 --> 00:00:10,400
um so today i will speak about uh jump

3
00:00:10,400 --> 00:00:10,960
back to

4
00:00:10,960 --> 00:00:14,080
2016 ios jailbreaking um

5
00:00:14,080 --> 00:00:16,160
so yeah first of all who am i so my name

6
00:00:16,160 --> 00:00:17,119
is tommy turkic

7
00:00:17,119 --> 00:00:19,359
i'm 16 years old and i'm interested in

8
00:00:19,359 --> 00:00:21,359
ios jailbreaking since i started hacking

9
00:00:21,359 --> 00:00:22,080
which was

10
00:00:22,080 --> 00:00:24,880
about three years ago or so and in fact

11
00:00:24,880 --> 00:00:26,720
i actually started hacking

12
00:00:26,720 --> 00:00:29,439
um because of ios jailbreaking i i was

13
00:00:29,439 --> 00:00:31,119
always kind of interested in

14
00:00:31,119 --> 00:00:34,079
ios type of stuff however i only started

15
00:00:34,079 --> 00:00:36,559
working on ios about a year ago

16
00:00:36,559 --> 00:00:38,640
and this is due to the fact that i was

17
00:00:38,640 --> 00:00:40,239
actually working on small

18
00:00:40,239 --> 00:00:43,600
cdf challenges and stuff like that

19
00:00:43,600 --> 00:00:46,480
and i actually spoke here last year um

20
00:00:46,480 --> 00:00:46,879
and

21
00:00:46,879 --> 00:00:48,960
this year i actually got invited and i

22
00:00:48,960 --> 00:00:51,039
really appreciate the invitation so

23
00:00:51,039 --> 00:00:54,079
um yeah

24
00:00:54,079 --> 00:00:56,480
so this is the agenda for uh today so

25
00:00:56,480 --> 00:00:58,079
basically first of all i'm going to give

26
00:00:58,079 --> 00:00:59,760
a really really short introduction to

27
00:00:59,760 --> 00:01:01,199
ios jailbreaking

28
00:01:01,199 --> 00:01:02,559
and then we're going to move on to the

29
00:01:02,559 --> 00:01:04,239
main parts which is the

30
00:01:04,239 --> 00:01:07,360
r2 box and the um

31
00:01:07,360 --> 00:01:09,840
some few patches to escalate privileges

32
00:01:09,840 --> 00:01:10,960
so um

33
00:01:10,960 --> 00:01:14,560
basically what is an ios jailbreak well

34
00:01:14,560 --> 00:01:16,720
so for the most people it's actually

35
00:01:16,720 --> 00:01:17,600
cydia

36
00:01:17,600 --> 00:01:19,360
which is actually just a package manager

37
00:01:19,360 --> 00:01:20,880
where you can actually install tweaks

38
00:01:20,880 --> 00:01:21,680
from

39
00:01:21,680 --> 00:01:24,880
and so that way you it allows the user

40
00:01:24,880 --> 00:01:25,280
to

41
00:01:25,280 --> 00:01:30,240
to customize their iphones or ipads

42
00:01:30,320 --> 00:01:32,000
and if you download some tweaks from

43
00:01:32,000 --> 00:01:34,320
cydia you can modify your springboard

44
00:01:34,320 --> 00:01:36,720
which is the home screen of the iphone

45
00:01:36,720 --> 00:01:38,560
and this is actually a lot more behind

46
00:01:38,560 --> 00:01:40,880
the scenes and i actually wanted to

47
00:01:40,880 --> 00:01:43,200
learn more about this and so this is why

48
00:01:43,200 --> 00:01:44,320
i kind of started

49
00:01:44,320 --> 00:01:48,640
with um with ios jailbreaks um

50
00:01:48,640 --> 00:01:51,040
and today i will actually cover a 32-bit

51
00:01:51,040 --> 00:01:52,399
ios jailbreak

52
00:01:52,399 --> 00:01:54,960
so there will be no software hardware

53
00:01:54,960 --> 00:01:55,920
mitigations

54
00:01:55,920 --> 00:01:59,439
such as kpp ktrr pack etc

55
00:01:59,439 --> 00:02:01,200
which newer jailbreaks actually have to

56
00:02:01,200 --> 00:02:02,799
deal with so

57
00:02:02,799 --> 00:02:04,479
that also means that we can actually

58
00:02:04,479 --> 00:02:08,560
patch the tag segment so

59
00:02:08,560 --> 00:02:11,440
as we all know zero days are expensive

60
00:02:11,440 --> 00:02:13,440
most of the jailbreaks are rely on

61
00:02:13,440 --> 00:02:16,640
already um published vulnerabilities

62
00:02:16,640 --> 00:02:19,520
and so in these days once we have the

63
00:02:19,520 --> 00:02:21,360
vulnerability exploited what we actually

64
00:02:21,360 --> 00:02:22,879
want to set up some

65
00:02:22,879 --> 00:02:25,280
read-write primitives to uh perform

66
00:02:25,280 --> 00:02:26,720
further patches

67
00:02:26,720 --> 00:02:28,800
and so ios actually builds around

68
00:02:28,800 --> 00:02:30,560
message passing

69
00:02:30,560 --> 00:02:34,239
and in ios java breaking

70
00:02:34,239 --> 00:02:37,680
access to the tosport zero or or the pid

71
00:02:37,680 --> 00:02:38,400
0

72
00:02:38,400 --> 00:02:41,360
is a holy grail because that is the

73
00:02:41,360 --> 00:02:42,560
kernel pretty much

74
00:02:42,560 --> 00:02:44,319
and if you have a send right to your

75
00:02:44,319 --> 00:02:47,280
port that means you can actually modify

76
00:02:47,280 --> 00:02:49,599
so you can read write its virtual memory

77
00:02:49,599 --> 00:02:50,400
and obviously

78
00:02:50,400 --> 00:02:52,160
if you can read and write the kernel

79
00:02:52,160 --> 00:02:56,000
memory you can apply further patches

80
00:02:56,080 --> 00:02:59,599
now obviously apple knows this and

81
00:02:59,599 --> 00:03:02,959
they want to protect the user from

82
00:03:02,959 --> 00:03:06,560
having access to the pid 0

83
00:03:06,560 --> 00:03:09,200
and there is a call for tasks for pit 0

84
00:03:09,200 --> 00:03:10,959
which will get you a send right if

85
00:03:10,959 --> 00:03:13,440
it is allowed but obviously passing

86
00:03:13,440 --> 00:03:16,400
argument 0 will return an error

87
00:03:16,400 --> 00:03:18,480
and so we can see there is a comment in

88
00:03:18,480 --> 00:03:21,040
the code uh so if p

89
00:03:21,040 --> 00:03:24,480
equals to zero then an error is returned

90
00:03:24,480 --> 00:03:27,680
no matter who's going so um

91
00:03:27,680 --> 00:03:30,879
yeah we can see there is also some hard

92
00:03:30,879 --> 00:03:32,080
coded checks in

93
00:03:32,080 --> 00:03:34,879
inside the code codebase and uh we can

94
00:03:34,879 --> 00:03:36,640
patch this for example

95
00:03:36,640 --> 00:03:39,840
by uh uh in assembly checking for the

96
00:03:39,840 --> 00:03:41,200
comparator and instead of zero we're

97
00:03:41,200 --> 00:03:42,080
gonna set to

98
00:03:42,080 --> 00:03:45,360
for example 0xff

99
00:03:45,360 --> 00:03:48,799
and uh so with the access uh to the

100
00:03:48,799 --> 00:03:52,319
um or having sent back to the kernel

101
00:03:52,319 --> 00:03:54,560
we can read and write arbitrary bytes as

102
00:03:54,560 --> 00:03:56,000
i explained previously

103
00:03:56,000 --> 00:03:58,400
and many utilities needs this uh thus

104
00:03:58,400 --> 00:04:00,159
repeat zero patch

105
00:04:00,159 --> 00:04:03,439
for example newer jailbreaks uh use this

106
00:04:03,439 --> 00:04:06,080
in order to set boot nons so that the

107
00:04:06,080 --> 00:04:08,319
user can actually downgrade or upgrade

108
00:04:08,319 --> 00:04:11,840
to an unsigned ios version if other

109
00:04:11,840 --> 00:04:15,040
issues are not present and for example i

110
00:04:15,040 --> 00:04:17,040
made a very basic tool called vm read

111
00:04:17,040 --> 00:04:18,399
write which actually

112
00:04:18,399 --> 00:04:20,079
um does what the name suggests it's

113
00:04:20,079 --> 00:04:21,440
reads and writes

114
00:04:21,440 --> 00:04:25,040
uh the kernel memory if uh it actually

115
00:04:25,040 --> 00:04:28,720
have the toss for p0 patch enabled

116
00:04:28,720 --> 00:04:30,400
and so this is how my tool looks it's

117
00:04:30,400 --> 00:04:31,840
very very simple

118
00:04:31,840 --> 00:04:34,880
but it's actually useful and also

119
00:04:34,880 --> 00:04:37,919
i actually made use of during the

120
00:04:37,919 --> 00:04:40,240
jailbreak development

121
00:04:40,240 --> 00:04:43,919
so um yeah once we have sent right

122
00:04:43,919 --> 00:04:46,720
uh to the kernel task and we can write

123
00:04:46,720 --> 00:04:48,639
its memory we can actually escalate

124
00:04:48,639 --> 00:04:49,759
privileges

125
00:04:49,759 --> 00:04:53,199
and uh the main goal of this talk is to

126
00:04:53,199 --> 00:04:54,400
actually achieve root

127
00:04:54,400 --> 00:04:57,199
so escalating privileges and there are a

128
00:04:57,199 --> 00:04:59,919
bunch more things to do if we want to

129
00:04:59,919 --> 00:05:02,800
install cydia spawn ssh and so on we

130
00:05:02,800 --> 00:05:04,400
would need to

131
00:05:04,400 --> 00:05:07,199
escape the sandbox patch amfi remount

132
00:05:07,199 --> 00:05:09,360
the root file system and so on

133
00:05:09,360 --> 00:05:11,759
but i won't get into that in today's

134
00:05:11,759 --> 00:05:14,000
talk

135
00:05:14,160 --> 00:05:16,240
so yeah this is pretty much our plan for

136
00:05:16,240 --> 00:05:17,360
the jailbreak so

137
00:05:17,360 --> 00:05:19,199
we're gonna first make use of the info

138
00:05:19,199 --> 00:05:21,039
leak then the memory caption

139
00:05:21,039 --> 00:05:24,720
and then we're gonna make use of other

140
00:05:24,720 --> 00:05:25,199
stuff

141
00:05:25,199 --> 00:05:27,120
such as read write primitives and some

142
00:05:27,120 --> 00:05:28,800
patches

143
00:05:28,800 --> 00:05:31,120
uh so before anything i just want to

144
00:05:31,120 --> 00:05:32,800
mention that uh

145
00:05:32,800 --> 00:05:35,600
as far as i know this is and was the

146
00:05:35,600 --> 00:05:36,639
first

147
00:05:36,639 --> 00:05:39,360
um spider jailbreak that was actually

148
00:05:39,360 --> 00:05:40,720
used in the real

149
00:05:40,720 --> 00:05:43,919
wild and um

150
00:05:43,919 --> 00:05:46,960
they actually attacked uh this

151
00:05:46,960 --> 00:05:50,800
ahmed human rights defender and

152
00:05:50,800 --> 00:05:54,479
he actually received an sms text

153
00:05:54,479 --> 00:05:57,360
uh with a link and there was actually a

154
00:05:57,360 --> 00:05:59,680
trap a one-click rce

155
00:05:59,680 --> 00:06:01,759
and uh he didn't actually clicked on the

156
00:06:01,759 --> 00:06:04,160
link instead he actually sent to a group

157
00:06:04,160 --> 00:06:06,720
who analyzed the link and they realized

158
00:06:06,720 --> 00:06:07,600
that this was

159
00:06:07,600 --> 00:06:10,720
such an exploit and uh i won't get into

160
00:06:10,720 --> 00:06:11,840
the webkit

161
00:06:11,840 --> 00:06:14,080
or the persistence because they actually

162
00:06:14,080 --> 00:06:16,319
had persistent exploits as well

163
00:06:16,319 --> 00:06:19,520
uh but rather only the two bugs which

164
00:06:19,520 --> 00:06:21,120
they are used which is the infolec and

165
00:06:21,120 --> 00:06:24,160
the memory corruption

166
00:06:24,240 --> 00:06:26,960
so this is the kernel info leak and it's

167
00:06:26,960 --> 00:06:28,800
actually really really simple

168
00:06:28,800 --> 00:06:32,800
they have a function and they

169
00:06:32,800 --> 00:06:35,840
forget to check the length uh variable

170
00:06:35,840 --> 00:06:38,880
which we can see there and uh so pretty

171
00:06:38,880 --> 00:06:40,319
much that way we can actually press an

172
00:06:40,319 --> 00:06:41,680
arbitrary number

173
00:06:41,680 --> 00:06:45,039
and we can if we can read back uh we can

174
00:06:45,039 --> 00:06:47,120
leak some kernel stack

175
00:06:47,120 --> 00:06:49,599
which will be obviously the case and in

176
00:06:49,599 --> 00:06:51,680
order to exploit this we need to craft a

177
00:06:51,680 --> 00:06:53,039
special dictionary

178
00:06:53,039 --> 00:06:55,039
and so this is how the dictionary look

179
00:06:55,039 --> 00:06:57,520
like so first we have the magic number

180
00:06:57,520 --> 00:07:00,000
and this is actually needed in order to

181
00:07:00,000 --> 00:07:01,440
the function to accept

182
00:07:01,440 --> 00:07:03,199
our dictionary otherwise it will

183
00:07:03,199 --> 00:07:04,880
actually decline it

184
00:07:04,880 --> 00:07:06,560
then we have a dictionary with two

185
00:07:06,560 --> 00:07:08,240
entries

186
00:07:08,240 --> 00:07:10,800
then we have a three byte aaa plus a

187
00:07:10,800 --> 00:07:12,319
null termination

188
00:07:12,319 --> 00:07:15,440
and then we have our big size number

189
00:07:15,440 --> 00:07:19,120
and at least eight bytes for our big num

190
00:07:19,120 --> 00:07:21,759
big number and in a normal case scenario

191
00:07:21,759 --> 00:07:22,800
you would be only

192
00:07:22,800 --> 00:07:25,039
be able to read these eight bytes back

193
00:07:25,039 --> 00:07:26,080
but uh

194
00:07:26,080 --> 00:07:28,840
obviously that's not the case at this

195
00:07:28,840 --> 00:07:30,639
point

196
00:07:30,639 --> 00:07:32,560
and once we have our melissa's

197
00:07:32,560 --> 00:07:33,680
dictionary set up

198
00:07:33,680 --> 00:07:35,919
what we actually want to do is uh read

199
00:07:35,919 --> 00:07:37,199
those data back

200
00:07:37,199 --> 00:07:40,319
uh in order to leak the bytes for us and

201
00:07:40,319 --> 00:07:41,039
we're going to

202
00:07:41,039 --> 00:07:43,280
do this using io kit and if you don't

203
00:07:43,280 --> 00:07:45,039
know what is io kit i'm

204
00:07:45,039 --> 00:07:47,120
just gonna not gonna get into that but

205
00:07:47,120 --> 00:07:48,319
just gonna say that it's

206
00:07:48,319 --> 00:07:50,319
pretty much used for ios kernel and user

207
00:07:50,319 --> 00:07:51,840
space communication

208
00:07:51,840 --> 00:07:55,759
um yeah it's enough for that and

209
00:07:55,759 --> 00:07:58,160
but basically you can actually read

210
00:07:58,160 --> 00:08:00,240
these bytes back using iokit

211
00:08:00,240 --> 00:08:02,960
and uh we look for the aaa property and

212
00:08:02,960 --> 00:08:03,919
we're going to read

213
00:08:03,919 --> 00:08:07,520
from there and this is the full kslr

214
00:08:07,520 --> 00:08:08,479
defeat good

215
00:08:08,479 --> 00:08:10,960
now i don't know whether can you see

216
00:08:10,960 --> 00:08:12,400
clearly or not but

217
00:08:12,400 --> 00:08:14,000
it's actually really simple it's just

218
00:08:14,000 --> 00:08:15,840
like 50 lines of code

219
00:08:15,840 --> 00:08:18,080
i just want decided to throw it in here

220
00:08:18,080 --> 00:08:19,120
just to show that

221
00:08:19,120 --> 00:08:22,560
it in indeed it is very simple and

222
00:08:22,560 --> 00:08:24,879
running the program will result us with

223
00:08:24,879 --> 00:08:26,479
some debug messages that

224
00:08:26,479 --> 00:08:28,639
we can actually see the leaked address

225
00:08:28,639 --> 00:08:30,400
where the function returned from

226
00:08:30,400 --> 00:08:33,519
and uh taking the address and

227
00:08:33,519 --> 00:08:36,399
applies applying some calculations we

228
00:08:36,399 --> 00:08:36,958
can

229
00:08:36,958 --> 00:08:40,159
get the kernel base and so how we're

230
00:08:40,159 --> 00:08:41,679
going to do it well we're going to have

231
00:08:41,679 --> 00:08:42,080
the

232
00:08:42,080 --> 00:08:44,480
array which is the buffery plus we're

233
00:08:44,480 --> 00:08:45,519
going to add

234
00:08:45,519 --> 00:08:48,399
the the offset to it to actually have it

235
00:08:48,399 --> 00:08:50,240
in the ninth position because

236
00:08:50,240 --> 00:08:53,760
foreign is 36 some some mats and uh then

237
00:08:53,760 --> 00:08:54,880
we're gonna

238
00:08:54,880 --> 00:08:57,200
uh mask it to one megabyte because it's

239
00:08:57,200 --> 00:08:58,000
always

240
00:08:58,000 --> 00:09:01,360
uh gonna end with with five zeros and

241
00:09:01,360 --> 00:09:03,360
we're gonna add just by one page because

242
00:09:03,360 --> 00:09:06,560
it starts at what 8000 one thousand so

243
00:09:06,560 --> 00:09:09,279
um yeah and after this we actually have

244
00:09:09,279 --> 00:09:10,000
uh the

245
00:09:10,000 --> 00:09:11,680
kernel base and if you still want to

246
00:09:11,680 --> 00:09:13,519
calculate the case or slide

247
00:09:13,519 --> 00:09:15,760
then it's really simple what you want to

248
00:09:15,760 --> 00:09:17,200
do is take away

249
00:09:17,200 --> 00:09:19,680
the base address which is 8000 1000 and

250
00:09:19,680 --> 00:09:20,560
you will have

251
00:09:20,560 --> 00:09:24,080
the kernel aslr side so yeah we can see

252
00:09:24,080 --> 00:09:26,320
that this is the kernel base and

253
00:09:26,320 --> 00:09:29,600
this is uh the kernel side

254
00:09:29,600 --> 00:09:32,560
so this is the memory caption bug and

255
00:09:32,560 --> 00:09:34,640
this is actually a kernel user for free

256
00:09:34,640 --> 00:09:36,320
and this is due to a dangling of a

257
00:09:36,320 --> 00:09:38,000
string pointer in ossen serialized

258
00:09:38,000 --> 00:09:39,440
binary

259
00:09:39,440 --> 00:09:41,600
and so that means that again we will

260
00:09:41,600 --> 00:09:43,200
need to craft a special

261
00:09:43,200 --> 00:09:44,720
dictionary in order to exploit this

262
00:09:44,720 --> 00:09:46,480
vulnerability

263
00:09:46,480 --> 00:09:48,720
so um but before that i actually want to

264
00:09:48,720 --> 00:09:49,600
explain how

265
00:09:49,600 --> 00:09:52,720
the bug occurs so basically we have a

266
00:09:52,720 --> 00:09:53,600
setting

267
00:09:53,600 --> 00:09:56,640
index macro uh predefined for us and

268
00:09:56,640 --> 00:09:57,120
what

269
00:09:57,120 --> 00:09:59,920
what's interesting in here is that it

270
00:09:59,920 --> 00:10:01,120
will actually save

271
00:10:01,120 --> 00:10:04,240
our objects to an object array um

272
00:10:04,240 --> 00:10:06,880
and yeah pretty much there is a special

273
00:10:06,880 --> 00:10:07,839
case in here

274
00:10:07,839 --> 00:10:10,320
uh which called k of a serialized object

275
00:10:10,320 --> 00:10:11,920
which what it does is actually

276
00:10:11,920 --> 00:10:14,959
will uh call o retaining an object and

277
00:10:14,959 --> 00:10:16,800
so what that means is we'll actually add

278
00:10:16,800 --> 00:10:18,160
one reference to the object

279
00:10:18,160 --> 00:10:21,519
so the object can be freed when uh

280
00:10:21,519 --> 00:10:24,640
the when the count

281
00:10:24,640 --> 00:10:27,680
drops to zero but we can actually make

282
00:10:27,680 --> 00:10:27,920
it

283
00:10:27,920 --> 00:10:31,200
live again with the code to retain

284
00:10:31,200 --> 00:10:34,000
and so uh exactly what happens here is

285
00:10:34,000 --> 00:10:36,160
there is an o string to a symbol cost

286
00:10:36,160 --> 00:10:38,480
which will actually call o release which

287
00:10:38,480 --> 00:10:39,600
will free

288
00:10:39,600 --> 00:10:43,360
the um object save to the objects array

289
00:10:43,360 --> 00:10:46,800
which was just saved there and so

290
00:10:46,800 --> 00:10:49,040
we we can see there is the o release

291
00:10:49,040 --> 00:10:49,920
call

292
00:10:49,920 --> 00:10:53,440
and uh there is the call if you remember

293
00:10:53,440 --> 00:10:55,200
from case serialize object

294
00:10:55,200 --> 00:10:57,279
so we can actually relocate the data

295
00:10:57,279 --> 00:10:58,720
with our custom

296
00:10:58,720 --> 00:11:02,160
data and we can call actually or retain

297
00:11:02,160 --> 00:11:02,720
on it

298
00:11:02,720 --> 00:11:06,399
which makes it a uaf scenario

299
00:11:06,640 --> 00:11:09,920
and again for this we need to

300
00:11:09,920 --> 00:11:13,040
make a special dictionary as well so

301
00:11:13,040 --> 00:11:15,200
we're going to start by the magic again

302
00:11:15,200 --> 00:11:17,279
and then we have a

303
00:11:17,279 --> 00:11:19,360
dictionary now with three entries and

304
00:11:19,360 --> 00:11:21,120
we're going to start by triggering the o

305
00:11:21,120 --> 00:11:21,600
string the

306
00:11:21,600 --> 00:11:23,839
location where we actually cost it to

307
00:11:23,839 --> 00:11:25,120
another symbol

308
00:11:25,120 --> 00:11:28,959
and then we have uh the payload or

309
00:11:28,959 --> 00:11:31,519
pretty much where we're gonna replace uh

310
00:11:31,519 --> 00:11:33,440
the dangling read table pointer

311
00:11:33,440 --> 00:11:35,600
and so this is the payload uh with some

312
00:11:35,600 --> 00:11:36,560
random

313
00:11:36,560 --> 00:11:39,040
zero exported ones and then now we're

314
00:11:39,040 --> 00:11:39,760
gonna call

315
00:11:39,760 --> 00:11:43,920
the retain on the object so now

316
00:11:43,920 --> 00:11:47,600
it became now once we trigger the bug it

317
00:11:47,600 --> 00:11:47,920
will

318
00:11:47,920 --> 00:11:49,760
the kernel will actually crash because

319
00:11:49,760 --> 00:11:51,600
it will try to jump to an invalid

320
00:11:51,600 --> 00:11:55,040
address however if you actually run it

321
00:11:55,040 --> 00:11:57,760
it will result such that the fault

322
00:11:57,760 --> 00:11:59,519
address is 0x41

323
00:11:59,519 --> 00:12:01,200
but we do not actually control the

324
00:12:01,200 --> 00:12:03,440
program counter

325
00:12:03,440 --> 00:12:05,360
and so in order to do that we actually

326
00:12:05,360 --> 00:12:07,200
need to craft a fake v table

327
00:12:07,200 --> 00:12:09,680
and so we can see the retable pointer is

328
00:12:09,680 --> 00:12:10,480
pretty much

329
00:12:10,480 --> 00:12:13,440
a pointer to a weak table where there

330
00:12:13,440 --> 00:12:14,880
are function pointers

331
00:12:14,880 --> 00:12:16,880
and so what we're going to do is we're

332
00:12:16,880 --> 00:12:19,120
going to craft a fake way table where

333
00:12:19,120 --> 00:12:20,880
uh instead of retaining we can actually

334
00:12:20,880 --> 00:12:22,240
point to our

335
00:12:22,240 --> 00:12:25,040
militia cup b table which can hold

336
00:12:25,040 --> 00:12:26,160
pretty much any value

337
00:12:26,160 --> 00:12:29,040
and i decided to place 42 there for for

338
00:12:29,040 --> 00:12:29,760
the record

339
00:12:29,760 --> 00:12:33,519
and um yeah so pretty much

340
00:12:33,519 --> 00:12:35,360
but in order to pull this off what we

341
00:12:35,360 --> 00:12:36,720
actually need to do uh

342
00:12:36,720 --> 00:12:40,560
have is a control data and kernel memory

343
00:12:40,560 --> 00:12:44,240
at the no at a known location

344
00:12:44,240 --> 00:12:46,320
and there are a few ways to put control

345
00:12:46,320 --> 00:12:47,360
data to

346
00:12:47,360 --> 00:12:50,079
kernel memory from user land and

347
00:12:50,079 --> 00:12:51,600
training set is actually using a

348
00:12:51,600 --> 00:12:52,000
different

349
00:12:52,000 --> 00:12:55,680
technique but

350
00:12:55,680 --> 00:12:59,440
there are a few few ways as i said so

351
00:12:59,440 --> 00:13:01,680
uh i'm actually focusing on mac message

352
00:13:01,680 --> 00:13:02,560
at this point

353
00:13:02,560 --> 00:13:06,480
and mac messages use ipc

354
00:13:06,480 --> 00:13:09,200
and we can actually send or receive

355
00:13:09,200 --> 00:13:10,959
using a mac message call

356
00:13:10,959 --> 00:13:13,760
and there is no mac message sender

357
00:13:13,760 --> 00:13:14,720
receive

358
00:13:14,720 --> 00:13:16,639
instead there is an option which where

359
00:13:16,639 --> 00:13:18,560
we can specify whether we want to send

360
00:13:18,560 --> 00:13:20,560
the message or receive the message

361
00:13:20,560 --> 00:13:23,680
and so pretty much this is how sending

362
00:13:23,680 --> 00:13:24,800
your message works

363
00:13:24,800 --> 00:13:27,839
um visually

364
00:13:27,839 --> 00:13:30,240
so we have task 1 and we want to send to

365
00:13:30,240 --> 00:13:32,000
dos 2. what we're going to do is well

366
00:13:32,000 --> 00:13:32,480
we're going to

367
00:13:32,480 --> 00:13:35,040
send it to the kernel the kernel will

368
00:13:35,040 --> 00:13:36,800
allocate some space for the data and

369
00:13:36,800 --> 00:13:38,720
they will send it to you task 2

370
00:13:38,720 --> 00:13:40,880
and when the toster receives it the

371
00:13:40,880 --> 00:13:42,880
kernel will free

372
00:13:42,880 --> 00:13:45,600
its space and wait for another message

373
00:13:45,600 --> 00:13:47,440
to reallocate or

374
00:13:47,440 --> 00:13:51,920
it will stay there completely freed

375
00:13:51,920 --> 00:13:54,240
so basically i think you already guessed

376
00:13:54,240 --> 00:13:55,040
it what we'll

377
00:13:55,040 --> 00:13:58,639
what we will do we're gonna send uh

378
00:13:58,639 --> 00:14:01,120
again but instead now we're not going to

379
00:14:01,120 --> 00:14:02,320
receive it and so

380
00:14:02,320 --> 00:14:04,639
our data will stay in actually in the

381
00:14:04,639 --> 00:14:06,079
kernel

382
00:14:06,079 --> 00:14:08,240
so that way we can actually have control

383
00:14:08,240 --> 00:14:10,079
data in kernel memory where we actually

384
00:14:10,079 --> 00:14:10,880
send from

385
00:14:10,880 --> 00:14:14,800
user space and so he string can

386
00:14:14,800 --> 00:14:16,959
actually be achieved by sending a bunch

387
00:14:16,959 --> 00:14:17,920
of data

388
00:14:17,920 --> 00:14:20,639
but not actually receiving them so we

389
00:14:20,639 --> 00:14:22,560
can see that

390
00:14:22,560 --> 00:14:24,320
if you not receive it will actually stay

391
00:14:24,320 --> 00:14:26,480
in the kernel

392
00:14:26,480 --> 00:14:30,480
and also we can do here feng shui uh

393
00:14:30,480 --> 00:14:32,240
by sending a bunch of data and only

394
00:14:32,240 --> 00:14:33,600
receiving a few so

395
00:14:33,600 --> 00:14:36,079
we send a bunch of like for example aaa

396
00:14:36,079 --> 00:14:36,880
and we only

397
00:14:36,880 --> 00:14:39,120
receive a few we actually eventually

398
00:14:39,120 --> 00:14:40,320
poked holes

399
00:14:40,320 --> 00:14:44,800
around the heap but yeah

400
00:14:44,800 --> 00:14:48,160
and uh so going on with our

401
00:14:48,160 --> 00:14:49,839
technique what we're gonna what we are

402
00:14:49,839 --> 00:14:52,079
going to do we are going to allocate a

403
00:14:52,079 --> 00:14:53,120
mac port with

404
00:14:53,120 --> 00:14:56,079
macbook write receive and so we actually

405
00:14:56,079 --> 00:14:57,680
will have this and write to it

406
00:14:57,680 --> 00:15:00,800
and we're going to send a message to it

407
00:15:00,800 --> 00:15:03,920
in my case i'm going to send 0x42 to it

408
00:15:03,920 --> 00:15:07,760
and instead of receiving i choose not to

409
00:15:07,760 --> 00:15:11,199
and however now we left with one

410
00:15:11,199 --> 00:15:13,920
little problem and that is that okay we

411
00:15:13,920 --> 00:15:14,880
can actually send

412
00:15:14,880 --> 00:15:17,440
some data to the kernel but we don't

413
00:15:17,440 --> 00:15:18,160
know where

414
00:15:18,160 --> 00:15:22,079
the data will end up however uh

415
00:15:22,079 --> 00:15:24,320
when we are doing the info leak part

416
00:15:24,320 --> 00:15:25,199
we're making

417
00:15:25,199 --> 00:15:27,839
a use of a call to i or just re-enter

418
00:15:27,839 --> 00:15:28,240
you

419
00:15:28,240 --> 00:15:31,199
get property and the make command

420
00:15:31,199 --> 00:15:32,560
carries a

421
00:15:32,560 --> 00:15:35,199
map message pointer so eventually we'll

422
00:15:35,199 --> 00:15:36,880
send a mac message as well

423
00:15:36,880 --> 00:15:40,000
and it will actually free it but if we

424
00:15:40,000 --> 00:15:40,639
send

425
00:15:40,639 --> 00:15:42,560
our message at the right point in time

426
00:15:42,560 --> 00:15:44,480
we can actually relocate with our

427
00:15:44,480 --> 00:15:45,279
message

428
00:15:45,279 --> 00:15:48,480
so again the good thing about this

429
00:15:48,480 --> 00:15:51,440
is that we actually leaked this address

430
00:15:51,440 --> 00:15:52,720
while we're actually

431
00:15:52,720 --> 00:15:56,720
leaking other addresses and so

432
00:15:56,720 --> 00:15:58,720
the versions i tested is always ending

433
00:15:58,720 --> 00:16:00,320
with b8 so

434
00:16:00,320 --> 00:16:02,800
um if you're actually jailbreaking we

435
00:16:02,800 --> 00:16:05,519
can actually read from this address

436
00:16:05,519 --> 00:16:07,279
and this is actually sometimes it's

437
00:16:07,279 --> 00:16:08,959
really good to actually have an already

438
00:16:08,959 --> 00:16:11,199
jailbreaking device to actually develop

439
00:16:11,199 --> 00:16:12,720
a jar break

440
00:16:12,720 --> 00:16:16,320
so yeah we can see uh this is where i

441
00:16:16,320 --> 00:16:17,600
actually make use of

442
00:16:17,600 --> 00:16:20,560
my vm breed write tool where i actually

443
00:16:20,560 --> 00:16:21,040
got

444
00:16:21,040 --> 00:16:23,519
got that data and i started to read from

445
00:16:23,519 --> 00:16:25,759
it and eventually i saw

446
00:16:25,759 --> 00:16:28,959
my message appear in in the kernel heap

447
00:16:28,959 --> 00:16:33,040
and so i what we can do now is actually

448
00:16:33,040 --> 00:16:36,000
we craft our payload in such way that i

449
00:16:36,000 --> 00:16:38,800
will actually point here

450
00:16:38,800 --> 00:16:41,040
so yeah as i said we need to curve the

451
00:16:41,040 --> 00:16:43,199
payload uh with the messages rest

452
00:16:43,199 --> 00:16:45,199
and after that we actually have uh

453
00:16:45,199 --> 00:16:48,399
control over the program counter

454
00:16:48,399 --> 00:16:51,279
and so yeah we can see uh we actually do

455
00:16:51,279 --> 00:16:53,440
control the program counter if you

456
00:16:53,440 --> 00:16:56,800
do like this and uh yeah so

457
00:16:56,800 --> 00:17:01,279
we can actually now start um patching

458
00:17:01,759 --> 00:17:05,199
and uh however uh we actually

459
00:17:05,199 --> 00:17:07,439
have control over the program counter

460
00:17:07,439 --> 00:17:09,439
but when whenever we call this

461
00:17:09,439 --> 00:17:12,880
trigger uaf function or to your the uaf

462
00:17:12,880 --> 00:17:15,280
it will actually panic the device and we

463
00:17:15,280 --> 00:17:17,119
need a way to keep the kernel alive

464
00:17:17,119 --> 00:17:18,240
because obviously

465
00:17:18,240 --> 00:17:19,919
in order to jailbreak it you have to

466
00:17:19,919 --> 00:17:21,919
keep the kernel alive and apply

467
00:17:21,919 --> 00:17:24,959
patches in the runtime and uh

468
00:17:24,959 --> 00:17:27,039
we can actually do that by replacing uh

469
00:17:27,039 --> 00:17:28,640
retain with a

470
00:17:28,640 --> 00:17:32,480
legitimate function and uh

471
00:17:32,480 --> 00:17:35,360
yeah so that function will um be always

472
00:17:35,360 --> 00:17:36,799
serialized serialized

473
00:17:36,799 --> 00:17:38,799
and this is how the final payload should

474
00:17:38,799 --> 00:17:39,919
look like so

475
00:17:39,919 --> 00:17:43,440
we have the address of uh copying

476
00:17:43,440 --> 00:17:45,600
then we have some address from the stack

477
00:17:45,600 --> 00:17:46,640
and

478
00:17:46,640 --> 00:17:48,799
then we have our real address of the

479
00:17:48,799 --> 00:17:49,760
payload

480
00:17:49,760 --> 00:17:54,400
as some values and again the gadget

481
00:17:54,400 --> 00:17:56,720
and so this is how the os serialized

482
00:17:56,720 --> 00:17:58,880
serialized gadget looks like so

483
00:17:58,880 --> 00:18:02,000
first of all we actually do control r0

484
00:18:02,000 --> 00:18:03,760
so at this point in time we're gonna

485
00:18:03,760 --> 00:18:06,080
control r3 as well

486
00:18:06,080 --> 00:18:08,160
and then we're going to control r1 as

487
00:18:08,160 --> 00:18:10,720
well because again we control r0

488
00:18:10,720 --> 00:18:13,440
and lastly we're going to control r12 as

489
00:18:13,440 --> 00:18:14,000
well

490
00:18:14,000 --> 00:18:15,840
which is really good because we actually

491
00:18:15,840 --> 00:18:18,160
have a branch

492
00:18:18,160 --> 00:18:21,520
to r12 which means that we actually

493
00:18:21,520 --> 00:18:25,200
can have an executive primitive

494
00:18:25,520 --> 00:18:28,640
and this is how my payload actually

495
00:18:28,640 --> 00:18:29,600
looks like

496
00:18:29,600 --> 00:18:33,440
so again i have the address for copying

497
00:18:33,440 --> 00:18:35,679
from my payload and have some random

498
00:18:35,679 --> 00:18:36,559
data

499
00:18:36,559 --> 00:18:38,480
then we actually have the payload

500
00:18:38,480 --> 00:18:40,400
pointer which is the message where we

501
00:18:40,400 --> 00:18:41,039
send

502
00:18:41,039 --> 00:18:42,880
and you notice that i actually take away

503
00:18:42,880 --> 00:18:44,720
some bytes and this is due to the fact

504
00:18:44,720 --> 00:18:46,640
that it's not exactly located

505
00:18:46,640 --> 00:18:49,280
at the address where we actually send

506
00:18:49,280 --> 00:18:49,840
the message

507
00:18:49,840 --> 00:18:52,960
it will be a bit below but um we can

508
00:18:52,960 --> 00:18:54,000
actually

509
00:18:54,000 --> 00:18:56,640
locate that um again if you're

510
00:18:56,640 --> 00:18:58,400
jailbroken it's really really easy just

511
00:18:58,400 --> 00:18:59,840
a simple matter of reading from the

512
00:18:59,840 --> 00:19:01,600
address and uh

513
00:19:01,600 --> 00:19:04,160
then we have our gadget which will be

514
00:19:04,160 --> 00:19:05,760
the always serialized serialized gadget

515
00:19:05,760 --> 00:19:07,919
again

516
00:19:07,919 --> 00:19:10,080
so yeah i actually just kind of rush it

517
00:19:10,080 --> 00:19:11,600
but um

518
00:19:11,600 --> 00:19:15,039
yeah this is how it looks and uh

519
00:19:15,039 --> 00:19:18,559
so once we have that the kernel will

520
00:19:18,559 --> 00:19:19,760
stay alive

521
00:19:19,760 --> 00:19:21,600
so we actually need now to set up the

522
00:19:21,600 --> 00:19:22,960
read write primitives

523
00:19:22,960 --> 00:19:25,600
and i'm again i'm using the same gadgets

524
00:19:25,600 --> 00:19:27,120
as the shrine and using

525
00:19:27,120 --> 00:19:29,520
so um we are going to make use of some

526
00:19:29,520 --> 00:19:31,039
clock services and for the read

527
00:19:31,039 --> 00:19:32,960
primitive we're going to make use of the

528
00:19:32,960 --> 00:19:37,039
battery clock so um basically

529
00:19:37,039 --> 00:19:38,799
we're going to design the payload in

530
00:19:38,799 --> 00:19:40,400
such way that it will

531
00:19:40,400 --> 00:19:43,440
contain pointers to handler functions

532
00:19:43,440 --> 00:19:45,440
and when we actually call the callback

533
00:19:45,440 --> 00:19:47,440
functions the payload

534
00:19:47,440 --> 00:19:50,640
will replace the gata ttr handlers and

535
00:19:50,640 --> 00:19:54,160
get the ttr uh

536
00:19:54,160 --> 00:20:00,400
will actually point to our buff rttr cpx

537
00:20:00,480 --> 00:20:02,960
so yeah we can see that what it will do

538
00:20:02,960 --> 00:20:05,840
is actually reach from r0 to r0 so

539
00:20:05,840 --> 00:20:09,440
it's perfect for our read primitive and

540
00:20:09,440 --> 00:20:11,840
again for execute informative we're

541
00:20:11,840 --> 00:20:12,480
going to

542
00:20:12,480 --> 00:20:14,480
make use of the clock service and we're

543
00:20:14,480 --> 00:20:15,919
going to replace now

544
00:20:15,919 --> 00:20:18,080
instead of real time clock get a ttr

545
00:20:18,080 --> 00:20:18,960
function

546
00:20:18,960 --> 00:20:20,799
and we will replace it with the always

547
00:20:20,799 --> 00:20:23,760
serialized serializer serialize function

548
00:20:23,760 --> 00:20:25,520
which i actually explained earlier but

549
00:20:25,520 --> 00:20:27,039
it's used for

550
00:20:27,039 --> 00:20:29,360
uh for our executive primitive because

551
00:20:29,360 --> 00:20:30,400
we can actually have

552
00:20:30,400 --> 00:20:33,200
arguments and uh yeah we're gonna branch

553
00:20:33,200 --> 00:20:33,919
to our

554
00:20:33,919 --> 00:20:37,120
control address and this is how the

555
00:20:37,120 --> 00:20:38,000
payload

556
00:20:38,000 --> 00:20:40,720
uh will look like uh it will rely on

557
00:20:40,720 --> 00:20:41,360
some

558
00:20:41,360 --> 00:20:43,440
on the on this gadget so we we're gonna

559
00:20:43,440 --> 00:20:44,480
have the

560
00:20:44,480 --> 00:20:47,039
uh some bytes of random data to make it

561
00:20:47,039 --> 00:20:49,280
uh

562
00:20:49,280 --> 00:20:52,480
to make it executable and then we

563
00:20:52,480 --> 00:20:53,520
actually have

564
00:20:53,520 --> 00:20:56,240
two arguments and we have the adjust

565
00:20:56,240 --> 00:20:56,880
what we

566
00:20:56,880 --> 00:20:59,919
actually want to execute and in order to

567
00:20:59,919 --> 00:21:00,480
actually

568
00:21:00,480 --> 00:21:03,039
execute the code or the address we

569
00:21:03,039 --> 00:21:04,320
actually need

570
00:21:04,320 --> 00:21:06,480
to place some bytes before the first

571
00:21:06,480 --> 00:21:07,520
argument

572
00:21:07,520 --> 00:21:11,360
and after that we actually after we have

573
00:21:11,360 --> 00:21:12,960
actually have the executive primitive

574
00:21:12,960 --> 00:21:15,840
setup a right primitive is really really

575
00:21:15,840 --> 00:21:16,720
simple

576
00:21:16,720 --> 00:21:18,960
uh all we actually need is just the

577
00:21:18,960 --> 00:21:20,000
right gadget

578
00:21:20,000 --> 00:21:22,000
because we can actually execute the

579
00:21:22,000 --> 00:21:23,919
gadget

580
00:21:23,919 --> 00:21:26,880
using our executive primitive and so

581
00:21:26,880 --> 00:21:28,320
there is this uh

582
00:21:28,320 --> 00:21:29,919
right gadget which we're gonna make use

583
00:21:29,919 --> 00:21:32,240
of so pretty much we have

584
00:21:32,240 --> 00:21:34,320
a store instruction which we're gonna

585
00:21:34,320 --> 00:21:35,280
we're gonna store

586
00:21:35,280 --> 00:21:37,360
whatever inside r1 which we actually

587
00:21:37,360 --> 00:21:40,240
control to our zero plus zero xc

588
00:21:40,240 --> 00:21:42,559
but we're gonna take away zero c uh so

589
00:21:42,559 --> 00:21:43,679
12 from

590
00:21:43,679 --> 00:21:46,400
address so it will be actually correct

591
00:21:46,400 --> 00:21:48,159
where we're going to actually store

592
00:21:48,159 --> 00:21:52,559
uh the value or the data

593
00:21:52,559 --> 00:21:55,600
and so basically the post exploitation

594
00:21:55,600 --> 00:21:57,919
part which is actually not tied

595
00:21:57,919 --> 00:21:59,039
specifically to these

596
00:21:59,039 --> 00:22:02,320
exploit or these bugs um the this can be

597
00:22:02,320 --> 00:22:03,200
applied to

598
00:22:03,200 --> 00:22:06,159
pretty much 32 bits or um yeah any other

599
00:22:06,159 --> 00:22:06,880
jailbreaks

600
00:22:06,880 --> 00:22:09,360
um and yeah so first of all we're going

601
00:22:09,360 --> 00:22:11,280
to actually patch b map because

602
00:22:11,280 --> 00:22:14,159
at the mmu level pages are actually read

603
00:22:14,159 --> 00:22:15,120
execute and

604
00:22:15,120 --> 00:22:18,080
are not read write execute execute

605
00:22:18,080 --> 00:22:19,440
except for jit pages

606
00:22:19,440 --> 00:22:22,799
for mobile suffering and there are

607
00:22:22,799 --> 00:22:24,159
usually three levels

608
00:22:24,159 --> 00:22:27,679
of page tables and uh

609
00:22:27,679 --> 00:22:30,240
in order to actually patch this which is

610
00:22:30,240 --> 00:22:31,919
this is realistically not

611
00:22:31,919 --> 00:22:34,960
even a patch uh to actually get the

612
00:22:34,960 --> 00:22:37,679
pin of dress what we are actually going

613
00:22:37,679 --> 00:22:39,360
to do is get the address of

614
00:22:39,360 --> 00:22:42,320
the pmap printer and we're gonna check

615
00:22:42,320 --> 00:22:44,240
for page entries and block entries

616
00:22:44,240 --> 00:22:46,240
and in case if it's a page entry what

617
00:22:46,240 --> 00:22:47,360
we're gonna do is

618
00:22:47,360 --> 00:22:50,559
uh a physical address uh is actually

619
00:22:50,559 --> 00:22:52,720
another set of dtes so we're gonna

620
00:22:52,720 --> 00:22:55,840
loop one more time and unset the bits

621
00:22:55,840 --> 00:22:58,640
and in case it's a block entry we're

622
00:22:58,640 --> 00:23:00,400
gonna do is just simply unset

623
00:23:00,400 --> 00:23:04,240
the bits so yeah

624
00:23:04,240 --> 00:23:06,840
and after setting all the bits pages can

625
00:23:06,840 --> 00:23:07,760
be uh

626
00:23:07,760 --> 00:23:10,640
read write execute and now we can uh

627
00:23:10,640 --> 00:23:12,880
perform further patches

628
00:23:12,880 --> 00:23:15,440
and uh so this basically this is the

629
00:23:15,440 --> 00:23:17,120
task for p0 patch

630
00:23:17,120 --> 00:23:19,840
which again to uh this is needed in

631
00:23:19,840 --> 00:23:21,840
order to have a send right to the

632
00:23:21,840 --> 00:23:24,960
kernel task and once we have

633
00:23:24,960 --> 00:23:27,679
basically our right primitive uh we can

634
00:23:27,679 --> 00:23:28,320
pretty much

635
00:23:28,320 --> 00:23:31,360
patch really really easily um to allow

636
00:23:31,360 --> 00:23:34,720
zero as an argument uh thus for pit

637
00:23:34,720 --> 00:23:39,120
call and we can actually

638
00:23:39,120 --> 00:23:42,320
after we actually have this right uh vm

639
00:23:42,320 --> 00:23:42,880
right

640
00:23:42,880 --> 00:23:44,799
we can actually patch pretty much any

641
00:23:44,799 --> 00:23:46,000
other thing

642
00:23:46,000 --> 00:23:48,880
and so we're gonna actually patch only

643
00:23:48,880 --> 00:23:50,799
three compress it it's actually really

644
00:23:50,799 --> 00:23:53,120
really simple to patch for costs for pit

645
00:23:53,120 --> 00:23:53,840
zero

646
00:23:53,840 --> 00:23:57,440
but again uh on newer uh devices and

647
00:23:57,440 --> 00:23:58,400
newer versions

648
00:23:58,400 --> 00:24:00,720
uh this is actually not really possible

649
00:24:00,720 --> 00:24:01,600
anymore

650
00:24:01,600 --> 00:24:03,760
due to the fact that apple introduced

651
00:24:03,760 --> 00:24:05,760
kpp and ktrr

652
00:24:05,760 --> 00:24:07,600
and pack and basically all the other

653
00:24:07,600 --> 00:24:09,279
stuff

654
00:24:09,279 --> 00:24:12,000
and so but yeah we're gonna focus on the

655
00:24:12,000 --> 00:24:12,720
32b

656
00:24:12,720 --> 00:24:15,919
only so yeah this is the paycheck and

657
00:24:15,919 --> 00:24:18,320
uh so we can see there is the comparison

658
00:24:18,320 --> 00:24:20,080
which i actually showed earlier

659
00:24:20,080 --> 00:24:22,799
uh with the zero whether if pids equals

660
00:24:22,799 --> 00:24:23,679
to zero

661
00:24:23,679 --> 00:24:25,919
if it is it will just branch an error

662
00:24:25,919 --> 00:24:27,919
and so we actually want to patch this to

663
00:24:27,919 --> 00:24:29,679
compare within our value like

664
00:24:29,679 --> 00:24:32,720
ff once we have that what we actually

665
00:24:32,720 --> 00:24:33,679
want to do

666
00:24:33,679 --> 00:24:35,679
is actually we want to patch the posix

667
00:24:35,679 --> 00:24:37,919
check uh which is again a really really

668
00:24:37,919 --> 00:24:38,720
simple

669
00:24:38,720 --> 00:24:41,760
uh just a comparison to r0 with zero

670
00:24:41,760 --> 00:24:44,559
i'm going to patch that as well and then

671
00:24:44,559 --> 00:24:46,159
we have actually have the mac pro

672
00:24:46,159 --> 00:24:49,360
check and uh again if you

673
00:24:49,360 --> 00:24:51,760
just just pretty much dig around you you

674
00:24:51,760 --> 00:24:53,440
easily find this

675
00:24:53,440 --> 00:24:56,159
place and you you can actually patch uh

676
00:24:56,159 --> 00:24:58,080
this comparison as well

677
00:24:58,080 --> 00:25:01,039
and pretty much after this we can have

678
00:25:01,039 --> 00:25:03,279
uh

679
00:25:03,520 --> 00:25:05,760
send right to the kernel tasks so we can

680
00:25:05,760 --> 00:25:08,400
actually use the vm read and vm write

681
00:25:08,400 --> 00:25:10,320
calls so we can actually write the

682
00:25:10,320 --> 00:25:11,520
kernel memory

683
00:25:11,520 --> 00:25:13,279
and now we can actually escalate

684
00:25:13,279 --> 00:25:15,360
privileges which as i said

685
00:25:15,360 --> 00:25:18,000
was pretty much the main idea of this

686
00:25:18,000 --> 00:25:18,400
talk

687
00:25:18,400 --> 00:25:21,600
and yeah so there are

688
00:25:21,600 --> 00:25:24,159
other ways to patch it and you can

689
00:25:24,159 --> 00:25:26,480
either like null out the check

690
00:25:26,480 --> 00:25:28,880
and move out all these checks or you can

691
00:25:28,880 --> 00:25:30,559
actually skip the check which

692
00:25:30,559 --> 00:25:34,080
i actually did so pretty much we can see

693
00:25:34,080 --> 00:25:38,159
it's actually a branch to ab370

694
00:25:38,159 --> 00:25:42,000
and uh what what we actually want to do

695
00:25:42,000 --> 00:25:44,559
because that's actually the if case so

696
00:25:44,559 --> 00:25:46,080
what we want to do is dig around and

697
00:25:46,080 --> 00:25:46,720
find

698
00:25:46,720 --> 00:25:49,600
uh at the end of the uh the checks and

699
00:25:49,600 --> 00:25:51,760
we got we want to brush there

700
00:25:51,760 --> 00:25:54,480
so basically um once we found that what

701
00:25:54,480 --> 00:25:56,000
we actually want to do

702
00:25:56,000 --> 00:25:59,120
is uh write uh the new address

703
00:25:59,120 --> 00:26:01,679
the branch address instead so um the

704
00:26:01,679 --> 00:26:02,960
offset so instead

705
00:26:02,960 --> 00:26:06,000
it's actually gonna branch after the

706
00:26:06,000 --> 00:26:09,760
uh if check so we can see how it looks

707
00:26:09,760 --> 00:26:10,000
like

708
00:26:10,000 --> 00:26:13,600
so it's gonna branch here and uh uh

709
00:26:13,600 --> 00:26:15,919
this is how it looks in the hex editor

710
00:26:15,919 --> 00:26:17,240
so it's actually

711
00:26:17,240 --> 00:26:20,559
e009 the offset and so pretty much we're

712
00:26:20,559 --> 00:26:22,080
gonna patch this

713
00:26:22,080 --> 00:26:24,480
with four zero e0 and you actually have

714
00:26:24,480 --> 00:26:26,159
to calculate the offsets

715
00:26:26,159 --> 00:26:29,520
and uh you can then really easily um

716
00:26:29,520 --> 00:26:32,880
get with the hex to arm side which is

717
00:26:32,880 --> 00:26:34,159
really really helpful

718
00:26:34,159 --> 00:26:36,000
in this case because you can really

719
00:26:36,000 --> 00:26:37,520
really easily

720
00:26:37,520 --> 00:26:42,640
get what you actually need to put there

721
00:26:42,640 --> 00:26:44,720
so yeah um this is after the patch we

722
00:26:44,720 --> 00:26:45,679
can see it's a completely

723
00:26:45,679 --> 00:26:47,600
different address and it's just gonna

724
00:26:47,600 --> 00:26:49,760
pretty much skip the fks and so

725
00:26:49,760 --> 00:26:52,159
we can actually after this we can of

726
00:26:52,159 --> 00:26:53,760
course attribute id

727
00:26:53,760 --> 00:26:56,320
so yeah we can see this is the first

728
00:26:56,320 --> 00:26:57,520
case the original

729
00:26:57,520 --> 00:26:59,440
where it's actually not patched and it

730
00:26:59,440 --> 00:27:01,360
just goes uh

731
00:27:01,360 --> 00:27:03,360
goes to the if checks and this is the

732
00:27:03,360 --> 00:27:05,279
patch where it's a completely different

733
00:27:05,279 --> 00:27:06,159
address it's

734
00:27:06,159 --> 00:27:08,559
3de and they will just pretty much just

735
00:27:08,559 --> 00:27:09,600
keep the

736
00:27:09,600 --> 00:27:13,039
if case and after running uh uh

737
00:27:13,039 --> 00:27:15,120
this the dispatch we can actually call

738
00:27:15,120 --> 00:27:16,320
setup id

739
00:27:16,320 --> 00:27:18,640
with zero so after that we actually

740
00:27:18,640 --> 00:27:21,200
escalated privileges

741
00:27:21,200 --> 00:27:24,320
and so yeah there you go and we can see

742
00:27:24,320 --> 00:27:24,640
that

743
00:27:24,640 --> 00:27:28,320
uh i actually have uid 501 first which

744
00:27:28,320 --> 00:27:29,440
is mobile

745
00:27:29,440 --> 00:27:32,880
which is actually normal in in ios

746
00:27:32,880 --> 00:27:36,720
which well we are actually in normal his

747
00:27:36,720 --> 00:27:39,760
and after that we can see um i'm

748
00:27:39,760 --> 00:27:42,320
actually uid 0 which means i'm actually

749
00:27:42,320 --> 00:27:45,360
root and also if you don't believe me

750
00:27:45,360 --> 00:27:47,840
you can see the code is actually i'm

751
00:27:47,840 --> 00:27:49,120
calling get you id

752
00:27:49,120 --> 00:27:52,640
so um yeah

753
00:27:52,640 --> 00:27:54,000
and if you're actually interested in

754
00:27:54,000 --> 00:27:55,760
this project or just want to

755
00:27:55,760 --> 00:27:57,919
get the source code or just try it out

756
00:27:57,919 --> 00:28:00,640
you can actually get this on my github

757
00:28:00,640 --> 00:28:03,440
it's actually called broke and so yeah

758
00:28:03,440 --> 00:28:04,000
you can

759
00:28:04,000 --> 00:28:07,600
go ahead and download it and uh yeah

760
00:28:07,600 --> 00:28:09,520
and lastly i actually want to give a

761
00:28:09,520 --> 00:28:11,279
huge shout out to all these people

762
00:28:11,279 --> 00:28:11,840
because

763
00:28:11,840 --> 00:28:13,600
this project or the talk wouldn't be

764
00:28:13,600 --> 00:28:15,200
possible without them

765
00:28:15,200 --> 00:28:18,399
so um yeah i want to give them a big

766
00:28:18,399 --> 00:28:20,240
shout out to kwerty saguza

767
00:28:20,240 --> 00:28:23,760
jn doc benjamin ibisburgs uh ben

768
00:28:23,760 --> 00:28:25,520
and billy ellis because they really

769
00:28:25,520 --> 00:28:27,679
really helped me um

770
00:28:27,679 --> 00:28:30,240
while i was doing this and they yeah

771
00:28:30,240 --> 00:28:31,039
they

772
00:28:31,039 --> 00:28:34,320
they were really nice people so yeah

773
00:28:34,320 --> 00:28:35,679
and now if you actually have any

774
00:28:35,679 --> 00:28:38,080
questions i believe uh

775
00:28:38,080 --> 00:28:40,240
you can actually ask on discord i think

776
00:28:40,240 --> 00:28:41,760
but i'm not really sure

777
00:28:41,760 --> 00:28:44,399
but uh you can always tweet me at

778
00:28:44,399 --> 00:28:45,440
tomitake or

779
00:28:45,440 --> 00:28:49,200
at ion0uido so yeah

780
00:28:49,200 --> 00:28:53,200
thank you for your attention

