1
00:00:02,530 --> 00:00:08,020
alright so today I'm gonna talk about

2
00:00:05,140 --> 00:00:10,120
return oriented exploitation on arm so

3
00:00:08,020 --> 00:00:11,889
first of all I'm mine so my name is

4
00:00:10,120 --> 00:00:14,139
Tommy Turkish I'm a 15 year old iOS

5
00:00:11,889 --> 00:00:15,940
flashback USD before and I'm interested

6
00:00:14,139 --> 00:00:18,099
in arm bar security and server

7
00:00:15,940 --> 00:00:21,220
exploitation for about two to half is

8
00:00:18,099 --> 00:00:23,080
now also a continues to work in some

9
00:00:21,220 --> 00:00:25,180
private older Gerak's because my focus

10
00:00:23,080 --> 00:00:28,959
and kinda an iOS and is jailbreaking

11
00:00:25,180 --> 00:00:30,698
process but the main focuses of this

12
00:00:28,960 --> 00:00:33,070
talk is to cover the basics of Army

13
00:00:30,699 --> 00:00:34,540
seven an army research and also I'll

14
00:00:33,070 --> 00:00:37,630
show you a couple of differences between

15
00:00:34,540 --> 00:00:39,730
Army's abandoned army eight then cover

16
00:00:37,630 --> 00:00:43,079
defendants of robbed exploit techniques

17
00:00:39,730 --> 00:00:45,398
and in the end I'll show a demo exploit

18
00:00:43,079 --> 00:00:49,780
so let's start with the Army seven so

19
00:00:45,399 --> 00:00:52,149
army 7i k IA r32 army seven has a fixed

20
00:00:49,780 --> 00:00:55,780
size of 32 bits and there's a 16 bit

21
00:00:52,149 --> 00:00:58,120
mode available known as some mode and on

22
00:00:55,780 --> 00:01:00,219
number 7 we have a 15 general-purpose

23
00:00:58,120 --> 00:01:07,390
registers and these are labels from are

24
00:01:00,219 --> 00:01:09,400
0-2 or 15 and from R 0 to R 12 ok Ramar

25
00:01:07,390 --> 00:01:11,950
0 to R 12 these are the general ones and

26
00:01:09,400 --> 00:01:14,950
from our 13 2 or 15 those are the

27
00:01:11,950 --> 00:01:16,600
special types of registers so R 13 is

28
00:01:14,950 --> 00:01:18,640
the stack pointer which is always points

29
00:01:16,600 --> 00:01:20,289
to the top of stack or 14 is the link

30
00:01:18,640 --> 00:01:23,470
register which is always holds

31
00:01:20,290 --> 00:01:26,080
everything address from for example been

32
00:01:23,470 --> 00:01:27,759
a function call is made and I offered

33
00:01:26,080 --> 00:01:29,200
our 15 is the perma carrier which is

34
00:01:27,759 --> 00:01:32,560
always holds the next instruction to be

35
00:01:29,200 --> 00:01:37,180
executed now I'm rate on the other hand

36
00:01:32,560 --> 00:01:39,490
is armed 64 or AR 64 we have a lot more

37
00:01:37,180 --> 00:01:42,850
registers so like 30 general registers

38
00:01:39,490 --> 00:01:46,750
and these are labeled from X 0 to X 1 9

39
00:01:42,850 --> 00:01:48,880
and on 8 supports only 7 fullbacks

40
00:01:46,750 --> 00:01:51,490
backwards compatibility but when this

41
00:01:48,880 --> 00:01:53,949
mode is enabled the upper 30 bits or

42
00:01:51,490 --> 00:01:56,320
note and the register names are actually

43
00:01:53,950 --> 00:02:00,219
changes a slight bit so it's changes

44
00:01:56,320 --> 00:02:02,408
from X to W and so yeah we have from X 0

45
00:02:00,219 --> 00:02:04,719
to X 2 now in the general ones and we

46
00:02:02,409 --> 00:02:07,869
have the same special registers like an

47
00:02:04,719 --> 00:02:09,519
army 7 so X 30 is a link register the

48
00:02:07,869 --> 00:02:11,680
stack point is its own register so also

49
00:02:09,519 --> 00:02:13,450
repair this ax 31

50
00:02:11,680 --> 00:02:15,700
the program counter here is not directly

51
00:02:13,450 --> 00:02:17,798
modifiable means for example if you're

52
00:02:15,700 --> 00:02:20,500
writing you know in our in arm assembly

53
00:02:17,799 --> 00:02:23,500
or number seven you can just use our 15

54
00:02:20,500 --> 00:02:24,659
just got a as a program Cara but none

55
00:02:23,500 --> 00:02:27,549
are mate

56
00:02:24,659 --> 00:02:31,269
so army eight supports expression levels

57
00:02:27,549 --> 00:02:32,980
as well so from our r2 r3 and this is

58
00:02:31,269 --> 00:02:35,650
kind of a physical separation of levels

59
00:02:32,980 --> 00:02:38,290
even the kind of like rings but that's

60
00:02:35,650 --> 00:02:40,930
actually be a might up now there's a

61
00:02:38,290 --> 00:02:43,150
couple of differences so you can see

62
00:02:40,930 --> 00:02:46,780
first of all the register name so like I

63
00:02:43,150 --> 00:02:51,730
receiver and X 0 then instruction thanks

64
00:02:46,780 --> 00:02:53,769
I like move the W and Army 7 and the

65
00:02:51,730 --> 00:02:56,230
written instruction so like on Army 7 we

66
00:02:53,769 --> 00:02:58,239
branch to link register and an army 8 we

67
00:02:56,230 --> 00:03:02,260
just write which is basically the same

68
00:02:58,239 --> 00:03:04,720
thing just with a different name so yeah

69
00:03:02,260 --> 00:03:07,629
here's a difference is when adding items

70
00:03:04,720 --> 00:03:09,639
to the stack so an army 7 we have a per

71
00:03:07,629 --> 00:03:11,530
instruction which adds many saw

72
00:03:09,639 --> 00:03:14,859
specified registers to the top of the

73
00:03:11,530 --> 00:03:16,900
stack and on our mate it's actually I'm

74
00:03:14,859 --> 00:03:18,310
subtract from this sack minor so it's

75
00:03:16,900 --> 00:03:21,099
actually manually courage to stack

76
00:03:18,310 --> 00:03:23,590
because and here is actually the stack

77
00:03:21,099 --> 00:03:25,589
is first up exact opposite way waiting

78
00:03:23,590 --> 00:03:28,599
so it's actually grows downwards and

79
00:03:25,590 --> 00:03:30,280
then we have another instruction so it's

80
00:03:28,599 --> 00:03:34,899
actually stores a pair of register at a

81
00:03:30,280 --> 00:03:36,040
specified location now absence force so

82
00:03:34,900 --> 00:03:38,260
ever since for return-oriented

83
00:03:36,040 --> 00:03:40,750
programming and this is a modern ask boy

84
00:03:38,260 --> 00:03:42,489
technique the old-fashioned way was to

85
00:03:40,750 --> 00:03:44,139
actually use a child kid do you execute

86
00:03:42,489 --> 00:03:45,940
your malicious code but not it's

87
00:03:44,139 --> 00:03:49,479
actually you would change gadgets do you

88
00:03:45,940 --> 00:03:52,629
actually I executed or malicious code so

89
00:03:49,479 --> 00:03:54,220
here's what we artists are so Oh Rob

90
00:03:52,629 --> 00:03:56,798
gauges are found within the tech segment

91
00:03:54,220 --> 00:03:58,060
so the code segment and these

92
00:03:56,799 --> 00:03:59,949
Trowbridge's has students with our

93
00:03:58,060 --> 00:04:01,750
return instructions or right instruction

94
00:03:59,949 --> 00:04:03,970
we obviously that's how you can can

95
00:04:01,750 --> 00:04:05,319
chain them together and even though how

96
00:04:03,970 --> 00:04:07,540
this gadget could change the gary if

97
00:04:05,319 --> 00:04:11,530
their program how is you so here's a

98
00:04:07,540 --> 00:04:12,638
quick diagram of gadgets were so you see

99
00:04:11,530 --> 00:04:15,099
where we have this a return address

100
00:04:12,639 --> 00:04:17,079
that's where we override the perm

101
00:04:15,099 --> 00:04:19,269
carasau and repeat our first get it

102
00:04:17,079 --> 00:04:21,849
address there which I was getting

103
00:04:19,269 --> 00:04:24,050
printers first get it then once it's

104
00:04:21,849 --> 00:04:27,080
executed it's gonna jump back to the

105
00:04:24,050 --> 00:04:31,190
back to the stack and it's going on like

106
00:04:27,080 --> 00:04:33,440
with the kitchen to dress and so on most

107
00:04:31,190 --> 00:04:35,150
of all the old box / cooler abilities

108
00:04:33,440 --> 00:04:37,270
are different and sometimes you only

109
00:04:35,150 --> 00:04:40,068
have one gadget worth of execution for

110
00:04:37,270 --> 00:04:43,068
example when you doing with an on-site

111
00:04:40,069 --> 00:04:45,110
based function and there's a solution

112
00:04:43,069 --> 00:04:47,780
for that and it's called a step pivoting

113
00:04:45,110 --> 00:04:50,060
and the stuffing is type opening he

114
00:04:47,780 --> 00:04:51,859
create a fake stack and to be able to do

115
00:04:50,060 --> 00:04:54,830
that you need to control the stack

116
00:04:51,860 --> 00:04:56,330
pointer and to be able to control the

117
00:04:54,830 --> 00:05:00,469
sacrum here you need a special type of

118
00:04:56,330 --> 00:05:02,448
gadget called people get it seriously an

119
00:05:00,469 --> 00:05:04,639
example of people get this side it's

120
00:05:02,449 --> 00:05:07,280
very simple so I just actually actually

121
00:05:04,639 --> 00:05:08,780
removes the value of x1

122
00:05:07,280 --> 00:05:11,929
Digitek minor so it's just basically

123
00:05:08,780 --> 00:05:16,369
over right here and the last instruction

124
00:05:11,930 --> 00:05:18,289
just like X 30 and return so here's how

125
00:05:16,370 --> 00:05:21,190
kind of I'm stuck pivoting a stack

126
00:05:18,289 --> 00:05:23,628
pointer works so we have the memory and

127
00:05:21,190 --> 00:05:25,310
we can see that stack pointer now points

128
00:05:23,629 --> 00:05:28,009
to zero are see it means it's gonna

129
00:05:25,310 --> 00:05:29,900
execute from there so like 0 x4 even if

130
00:05:28,009 --> 00:05:33,110
you get an instruction to move down than

131
00:05:29,900 --> 00:05:36,739
our pop we can see is now the second I'm

132
00:05:33,110 --> 00:05:38,419
going to print points to 10 and 0 x4 one

133
00:05:36,740 --> 00:05:40,310
does not doesn't need to be cleared

134
00:05:38,419 --> 00:05:42,830
because it just doesn't count as a stack

135
00:05:40,310 --> 00:05:46,550
anymore now if you actually can control

136
00:05:42,830 --> 00:05:48,169
this set corner by our people get it you

137
00:05:46,550 --> 00:05:49,880
can actually move there and we can

138
00:05:48,169 --> 00:05:55,818
control the whole stack so you can just

139
00:05:49,880 --> 00:05:59,479
basically execute our rope chain so

140
00:05:55,819 --> 00:06:01,069
here's a stack based attack style the

141
00:05:59,479 --> 00:06:03,770
very basics on our stack buffer

142
00:06:01,069 --> 00:06:05,810
overflows and these types was targets

143
00:06:03,770 --> 00:06:07,310
the sack and the main goal is to

144
00:06:05,810 --> 00:06:10,069
override function pointer if it's a

145
00:06:07,310 --> 00:06:12,319
thicker control data all right so this

146
00:06:10,069 --> 00:06:14,210
occurs when program is run out of space

147
00:06:12,319 --> 00:06:14,840
and you essentially start of writing the

148
00:06:14,210 --> 00:06:17,049
function bars

149
00:06:14,840 --> 00:06:20,409
the aim is to control the program camera

150
00:06:17,050 --> 00:06:23,479
so here's some actually diagram of

151
00:06:20,409 --> 00:06:25,789
flavor so you see at the first picture

152
00:06:23,479 --> 00:06:27,409
is nothing delicate in a stack the

153
00:06:25,789 --> 00:06:29,300
second one you can see a few years okay

154
00:06:27,409 --> 00:06:31,580
and a third picture you can see an

155
00:06:29,300 --> 00:06:33,800
outflow and we can control this because

156
00:06:31,580 --> 00:06:37,789
we actually of wrote

157
00:06:33,800 --> 00:06:39,440
the Purim Caribee days our don't think

158
00:06:37,789 --> 00:06:41,568
this will work and when his sons because

159
00:06:39,440 --> 00:06:45,020
most winners some have protection

160
00:06:41,569 --> 00:06:46,669
against these over plays and Marisa's

161
00:06:45,020 --> 00:06:51,020
have a slower and definitely ruled as

162
00:06:46,669 --> 00:06:52,460
well so yeah I'm boys a large so well is

163
00:06:51,020 --> 00:06:53,539
a lessons for address space layout

164
00:06:52,460 --> 00:06:55,280
randomization

165
00:06:53,539 --> 00:06:57,680
I just basically renamed is I or

166
00:06:55,280 --> 00:07:01,190
addressing run time so I can see the

167
00:06:57,680 --> 00:07:04,550
first time it was a 0 X 16 at the 0 at 7

168
00:07:01,190 --> 00:07:08,990
9 0 and the second one was 16 half the e

169
00:07:04,550 --> 00:07:12,560
7 7 9 0 so the two addresses are kind of

170
00:07:08,990 --> 00:07:14,780
different so what is a lot of 4 so it's

171
00:07:12,560 --> 00:07:16,729
a lot for making the prim can control

172
00:07:14,780 --> 00:07:18,590
useless because even if you can control

173
00:07:16,729 --> 00:07:20,449
the program Cara you just can't jump to

174
00:07:18,590 --> 00:07:22,638
any bird because you just don't know

175
00:07:20,449 --> 00:07:24,080
where anything is so it's also for

176
00:07:22,639 --> 00:07:26,479
preventing shellcode from being

177
00:07:24,080 --> 00:07:30,080
successful because it's just you don't

178
00:07:26,479 --> 00:07:32,930
know where anything is Chris there are a

179
00:07:30,080 --> 00:07:34,609
few ways to defeat al salar so I wrote

180
00:07:32,930 --> 00:07:36,020
down two so the first one is a brute

181
00:07:34,610 --> 00:07:37,849
first thing which is not very practical

182
00:07:36,020 --> 00:07:40,250
because if you take a lot of time and

183
00:07:37,849 --> 00:07:43,370
the second one is an info week we shall

184
00:07:40,250 --> 00:07:45,110
talk about a little bit so the web basic

185
00:07:43,370 --> 00:07:47,990
info week one is a format string

186
00:07:45,110 --> 00:07:50,120
vulnerability and this is due to using

187
00:07:47,990 --> 00:07:52,430
printf in a wrong way so you can see the

188
00:07:50,120 --> 00:07:55,099
ethic can enter basically anything even

189
00:07:52,430 --> 00:07:57,349
percentage peace to leave the data from

190
00:07:55,099 --> 00:08:00,229
the cycle so if we actually try to

191
00:07:57,349 --> 00:08:03,229
compile that program the compiler will

192
00:08:00,229 --> 00:08:05,150
show some warnings so without the form a

193
00:08:03,229 --> 00:08:07,430
string is not a string literal potential

194
00:08:05,150 --> 00:08:09,979
integer and underlines the format string

195
00:08:07,430 --> 00:08:12,169
which is in the wrong way so you should

196
00:08:09,979 --> 00:08:15,620
actually use a form a cease-fire and

197
00:08:12,169 --> 00:08:19,340
then put the for machine so not this

198
00:08:15,620 --> 00:08:21,919
thing this app is our binary we see what

199
00:08:19,340 --> 00:08:23,539
we entered so we entered high and here's

200
00:08:21,919 --> 00:08:25,008
what the program printed out for us so

201
00:08:23,539 --> 00:08:28,190
it's basically simply high

202
00:08:25,009 --> 00:08:30,259
now I'm also a form and specify absorb

203
00:08:28,190 --> 00:08:32,929
is a percentage so what happens if you

204
00:08:30,259 --> 00:08:34,700
actually enter percentage high so here's

205
00:08:32,929 --> 00:08:36,828
what we entered and here's what the

206
00:08:34,700 --> 00:08:40,279
program print out for us some real a bit

207
00:08:36,828 --> 00:08:44,179
because it's treated the percentage as a

208
00:08:40,279 --> 00:08:46,459
for misfire so a percentage P purpose to

209
00:08:44,179 --> 00:08:47,300
print upon your relief and if you

210
00:08:46,459 --> 00:08:50,569
actually enter

211
00:08:47,300 --> 00:08:53,780
person in trees we can see the premium

212
00:08:50,570 --> 00:08:57,620
printing out for us some stick burners

213
00:08:53,780 --> 00:08:59,449
so yeah and usually one pointer from the

214
00:08:57,620 --> 00:09:01,880
stack is enough to defeat the whole ALR

215
00:08:59,450 --> 00:09:04,730
but finding the function in this is this

216
00:09:01,880 --> 00:09:07,340
slumber and compared to League dress

217
00:09:04,730 --> 00:09:09,860
what we actually just and then compared

218
00:09:07,340 --> 00:09:11,960
to this tactic address in this is lumber

219
00:09:09,860 --> 00:09:14,030
and the difference will be a slower side

220
00:09:11,960 --> 00:09:16,730
now anytime you want to jump to an

221
00:09:14,030 --> 00:09:18,620
interest from now what you want to do is

222
00:09:16,730 --> 00:09:22,000
usually get the interest where you want

223
00:09:18,620 --> 00:09:24,410
to jump to and at day slow slide to it

224
00:09:22,000 --> 00:09:27,770
so yeah um here's some heat based

225
00:09:24,410 --> 00:09:29,870
techniques so on the heap you have

226
00:09:27,770 --> 00:09:31,579
basically dynamic allocation and you can

227
00:09:29,870 --> 00:09:35,000
allocate by Mulliken specify the size

228
00:09:31,580 --> 00:09:37,760
and you can delegate by free and specify

229
00:09:35,000 --> 00:09:40,580
the pointer so the first technique is

230
00:09:37,760 --> 00:09:42,800
actually heaps way and he doesn't

231
00:09:40,580 --> 00:09:45,110
actually exploit any security issues so

232
00:09:42,800 --> 00:09:47,449
it's like can't really be fixed by an

233
00:09:45,110 --> 00:09:49,430
updated for program and he's praying

234
00:09:47,450 --> 00:09:52,490
attempts to put a certain sequence apart

235
00:09:49,430 --> 00:09:54,560
is at a pretty terminated location by

236
00:09:52,490 --> 00:09:56,900
allocating a large memory blocks on the

237
00:09:54,560 --> 00:09:59,540
heap and you want to kind of think of

238
00:09:56,900 --> 00:10:02,209
history as you would spray up with paint

239
00:09:59,540 --> 00:10:04,550
so here's a diagram how it works I mean

240
00:10:02,210 --> 00:10:07,010
say before the spray basically nothing

241
00:10:04,550 --> 00:10:09,620
allocated on the heap and off the spray

242
00:10:07,010 --> 00:10:12,800
you can see all of knobs located and

243
00:10:09,620 --> 00:10:15,260
then our shot code see when we went to

244
00:10:12,800 --> 00:10:17,719
put consecutive knobs or no operations

245
00:10:15,260 --> 00:10:18,830
buzzer track code use not touch the

246
00:10:17,720 --> 00:10:20,810
program to move on to the next

247
00:10:18,830 --> 00:10:22,790
instruction and this will happen until

248
00:10:20,810 --> 00:10:25,630
we actually reach our jacquard and it

249
00:10:22,790 --> 00:10:28,730
will essentially execute it who executed

250
00:10:25,630 --> 00:10:31,790
series I'm something show you so here

251
00:10:28,730 --> 00:10:35,780
Frankie you actually carefully place

252
00:10:31,790 --> 00:10:38,000
objects in the memory and repeating our

253
00:10:35,780 --> 00:10:40,490
allocations and we will have on

254
00:10:38,000 --> 00:10:42,490
consecutive memory blocks and after that

255
00:10:40,490 --> 00:10:46,490
the allocation

256
00:10:42,490 --> 00:10:49,160
Kempo calls so here's our generic hip

257
00:10:46,490 --> 00:10:52,970
area so you can see the orange is in use

258
00:10:49,160 --> 00:10:54,290
and the gray is a hole so we see we

259
00:10:52,970 --> 00:10:55,910
actually don't know how the hip look

260
00:10:54,290 --> 00:10:58,219
like so it's just like some of them are

261
00:10:55,910 --> 00:10:58,980
in use and some of them are actually our

262
00:10:58,220 --> 00:11:00,900
holes

263
00:10:58,980 --> 00:11:02,750
and now let's do the first up so

264
00:11:00,900 --> 00:11:05,160
allocation is repeated often enough so

265
00:11:02,750 --> 00:11:08,580
ovals will be close so let's just do

266
00:11:05,160 --> 00:11:10,319
that and I'll kidding a bit more and we

267
00:11:08,580 --> 00:11:12,570
will have consecutive memory blocks so

268
00:11:10,320 --> 00:11:14,310
now we actually kind of put our data to

269
00:11:12,570 --> 00:11:17,760
it so we kind of know how the heap looks

270
00:11:14,310 --> 00:11:21,319
like now and now they are kidding can

271
00:11:17,760 --> 00:11:23,610
poke holes so like we put the holes and

272
00:11:21,320 --> 00:11:26,370
essentially next location will be into

273
00:11:23,610 --> 00:11:28,530
our hole and so by this a buffer

274
00:11:26,370 --> 00:11:30,060
overflow can be controlled because if we

275
00:11:28,530 --> 00:11:33,300
actually control the data or between

276
00:11:30,060 --> 00:11:36,209
roof right after these the data before

277
00:11:33,300 --> 00:11:39,990
the new allocation we can essentially

278
00:11:36,210 --> 00:11:44,490
control this buffer or Floyd so ease of

279
00:11:39,990 --> 00:11:46,830
free is a free occurs when a program can

280
00:11:44,490 --> 00:11:49,320
use a pointer after it has been freed

281
00:11:46,830 --> 00:11:51,420
and we often call this dangling pointers

282
00:11:49,320 --> 00:11:52,140
and this could lead to your code

283
00:11:51,420 --> 00:11:55,500
execution

284
00:11:52,140 --> 00:11:58,160
I think this source code from iOS 9 pin

285
00:11:55,500 --> 00:12:01,110
0 is a kernel a current extension and

286
00:11:58,160 --> 00:12:04,110
what you want to care about is the if

287
00:12:01,110 --> 00:12:06,330
the device is not know then what will

288
00:12:04,110 --> 00:12:08,280
does is caused wise terminate and this

289
00:12:06,330 --> 00:12:11,490
course OSE release function and pass an

290
00:12:08,280 --> 00:12:14,189
argument as a device yeah so the OSU

291
00:12:11,490 --> 00:12:15,930
Feliz is the unsafe function is if you

292
00:12:14,190 --> 00:12:17,910
actually check out how Apple actually

293
00:12:15,930 --> 00:12:21,120
find it we can see the actual business

294
00:12:17,910 --> 00:12:23,400
at ends to know so I thought you user

295
00:12:21,120 --> 00:12:25,350
Feliz know oh yeah they actually cook

296
00:12:23,400 --> 00:12:29,459
with patch this by setting device and

297
00:12:25,350 --> 00:12:32,880
also a bit of shame so yeah now here's

298
00:12:29,460 --> 00:12:35,490
the demo so the target name is bi sabe

299
00:12:32,880 --> 00:12:37,650
and vulnerability is our use of free and

300
00:12:35,490 --> 00:12:41,370
the architecture which available on his

301
00:12:37,650 --> 00:12:43,350
army 17 army 8 so every time we went to

302
00:12:41,370 --> 00:12:45,210
exploit any upon your application we

303
00:12:43,350 --> 00:12:47,130
kind of always have a checklist so first

304
00:12:45,210 --> 00:12:49,740
we went to find the real very the

305
00:12:47,130 --> 00:12:52,140
vulnerability killer her and then find

306
00:12:49,740 --> 00:12:53,520
the addresses for a rope chain and in

307
00:12:52,140 --> 00:12:56,490
the end we're going to call up the

308
00:12:53,520 --> 00:12:59,040
exploit and tested sir is the first

309
00:12:56,490 --> 00:13:00,500
stage so by running the program you can

310
00:12:59,040 --> 00:13:02,939
see if you have actually six options

311
00:13:00,500 --> 00:13:05,090
we're interested in five because the six

312
00:13:02,940 --> 00:13:07,050
is just basically access the program so

313
00:13:05,090 --> 00:13:09,420
option number one we can basically

314
00:13:07,050 --> 00:13:12,949
allocate so you can see the program

315
00:13:09,420 --> 00:13:15,599
tells us to enter some data to our kit

316
00:13:12,950 --> 00:13:18,000
so maybe if we want to actually check

317
00:13:15,600 --> 00:13:20,700
this function because I'm a buffer of

318
00:13:18,000 --> 00:13:22,050
will make you Decker now I have access

319
00:13:20,700 --> 00:13:24,870
to the source code because I wrote this

320
00:13:22,050 --> 00:13:28,859
program but you could get this by

321
00:13:24,870 --> 00:13:30,660
decoding from Ida or hopper so you see

322
00:13:28,860 --> 00:13:32,850
we have by often number one we actually

323
00:13:30,660 --> 00:13:35,520
have a function called allocate object

324
00:13:32,850 --> 00:13:38,340
by user and it wasn't our argument as

325
00:13:35,520 --> 00:13:41,760
input for our look so I now check this

326
00:13:38,340 --> 00:13:43,590
function you can see at the scanf it's

327
00:13:41,760 --> 00:13:46,170
actually kind of safe because I put like

328
00:13:43,590 --> 00:13:48,390
a percentage 31 s which means this will

329
00:13:46,170 --> 00:13:50,280
only scan up the pilgrim bytes and we

330
00:13:48,390 --> 00:13:53,630
need plus 1 for the new termination and

331
00:13:50,280 --> 00:13:56,189
the buffer is 32 bytes ID is perfectly

332
00:13:53,630 --> 00:13:59,070
now I again use the safer function the

333
00:13:56,190 --> 00:14:00,930
storing copy not the store copy but we

334
00:13:59,070 --> 00:14:04,350
actually have a objects idea so you

335
00:14:00,930 --> 00:14:05,550
actually want to check out that Samina

336
00:14:04,350 --> 00:14:08,400
see it's actually defined by struct

337
00:14:05,550 --> 00:14:10,469
object and this object and here's a

338
00:14:08,400 --> 00:14:12,180
stroke how it looks like so this is

339
00:14:10,470 --> 00:14:13,950
basically a struct and what you want to

340
00:14:12,180 --> 00:14:17,479
know down is that we have to function

341
00:14:13,950 --> 00:14:19,560
pointer sitting there all right so now

342
00:14:17,480 --> 00:14:21,110
choosing option number two you can see

343
00:14:19,560 --> 00:14:23,609
it's actually opens at fall

344
00:14:21,110 --> 00:14:25,620
option number two we can see that the

345
00:14:23,610 --> 00:14:26,490
program is actually waiting for an input

346
00:14:25,620 --> 00:14:28,620
from the user

347
00:14:26,490 --> 00:14:31,770
now let's actually enter a party for a

348
00:14:28,620 --> 00:14:35,520
file to basically test this function and

349
00:14:31,770 --> 00:14:38,280
we can see that printout the data was

350
00:14:35,520 --> 00:14:40,260
created with how it besides with this is

351
00:14:38,280 --> 00:14:42,030
a test and if you actually check what

352
00:14:40,260 --> 00:14:44,100
the file contains it's basically

353
00:14:42,030 --> 00:14:47,310
contains the same thing but the program

354
00:14:44,100 --> 00:14:50,070
print ad for us so let's check option

355
00:14:47,310 --> 00:14:52,589
number two so we can see it's actually

356
00:14:50,070 --> 00:14:54,240
caused a great deal object-- so let's

357
00:14:52,590 --> 00:14:56,280
check this function so first of all we

358
00:14:54,240 --> 00:14:58,950
can see that it's basically allocator

359
00:14:56,280 --> 00:15:01,680
and your bytes in the heap now this part

360
00:14:58,950 --> 00:15:04,410
is just for scanning apart from the user

361
00:15:01,680 --> 00:15:06,180
and opening the file and we have the F

362
00:15:04,410 --> 00:15:06,900
read now have you done a turbo I've

363
00:15:06,180 --> 00:15:09,390
freed

364
00:15:06,900 --> 00:15:11,430
sync tax it says post in programming

365
00:15:09,390 --> 00:15:14,550
arguments and cannot be interested in

366
00:15:11,430 --> 00:15:16,709
and now the in the first one and the

367
00:15:14,550 --> 00:15:18,569
first one is a pointer and it says

368
00:15:16,710 --> 00:15:20,490
where's reference of an array or

369
00:15:18,570 --> 00:15:24,210
structure where the data will be stored

370
00:15:20,490 --> 00:15:26,630
off the reading so it means it will

371
00:15:24,210 --> 00:15:30,890
store it to object data which is on

372
00:15:26,630 --> 00:15:33,680
Hiep so let's continue our journey so

373
00:15:30,890 --> 00:15:35,510
you see I'm by ocean number four you can

374
00:15:33,680 --> 00:15:38,599
see that I should actually are kids

375
00:15:35,510 --> 00:15:41,300
twice yeah and we get a message that

376
00:15:38,600 --> 00:15:43,250
device was located so checking this

377
00:15:41,300 --> 00:15:45,439
function again which is basically what

378
00:15:43,250 --> 00:15:48,020
it does this all kids are two function

379
00:15:45,440 --> 00:15:51,530
pointers on the heat dart so yes again

380
00:15:48,020 --> 00:15:53,660
it's an instruction so now to actually

381
00:15:51,530 --> 00:15:56,930
free a data we actually need to allocate

382
00:15:53,660 --> 00:16:01,010
first um if we don't do this we might

383
00:15:56,930 --> 00:16:03,589
end up in a double free so yeah in

384
00:16:01,010 --> 00:16:05,930
theory this option number four is only

385
00:16:03,590 --> 00:16:08,930
free data what we entered by option

386
00:16:05,930 --> 00:16:11,030
number one but in reality this basically

387
00:16:08,930 --> 00:16:14,239
what we can see here there is a check so

388
00:16:11,030 --> 00:16:15,410
if the object is known oh then it's

389
00:16:14,240 --> 00:16:17,840
cause a function called terminal type

390
00:16:15,410 --> 00:16:20,689
check and is passes argument as object

391
00:16:17,840 --> 00:16:23,330
and the terminal objects just simply

392
00:16:20,690 --> 00:16:25,130
free a struct so now we actually know

393
00:16:23,330 --> 00:16:28,460
very deep own ability is because it just

394
00:16:25,130 --> 00:16:30,230
I use of free because the terminus

395
00:16:28,460 --> 00:16:32,930
object frees the object but it doesn't

396
00:16:30,230 --> 00:16:34,790
set know so checking the he player

397
00:16:32,930 --> 00:16:36,739
before executing option number three

398
00:16:34,790 --> 00:16:39,980
you'll see the there's nothing on the

399
00:16:36,740 --> 00:16:42,710
heap and continuing forget the message

400
00:16:39,980 --> 00:16:45,170
that device is all okay and let's see

401
00:16:42,710 --> 00:16:47,240
that our two function pointers are there

402
00:16:45,170 --> 00:16:50,150
so it's just basically allocated our two

403
00:16:47,240 --> 00:16:53,600
function pointers if you actually call

404
00:16:50,150 --> 00:16:55,579
number four or the term in it we can see

405
00:16:53,600 --> 00:17:00,200
that a few addresses are masked so I

406
00:16:55,580 --> 00:17:01,850
like three ones and three tens but most

407
00:17:00,200 --> 00:17:04,610
importantly our two function pointers

408
00:17:01,850 --> 00:17:07,339
aren't there so it means we can still

409
00:17:04,609 --> 00:17:10,609
somehow reference to these dresses and

410
00:17:07,339 --> 00:17:14,089
kind of overflow with a bit opening a

411
00:17:10,609 --> 00:17:17,119
big file bigger than 32 bits right so

412
00:17:14,089 --> 00:17:19,010
yeah we actually have this first part

413
00:17:17,119 --> 00:17:21,589
because we know where the vulnerability

414
00:17:19,010 --> 00:17:26,060
could occur now we want to find dresses

415
00:17:21,589 --> 00:17:30,610
so this is the name of the binary so

416
00:17:26,060 --> 00:17:30,610
this is the secret code now

417
00:17:32,510 --> 00:17:40,110
hey yeah so sucrets starts at zero X

418
00:17:36,330 --> 00:17:43,678
zero zero zero zero be 950 so yeah we

419
00:17:40,110 --> 00:17:45,510
can just jump there and be done but you

420
00:17:43,679 --> 00:17:48,150
can see if we actually jump to cigarette

421
00:17:45,510 --> 00:17:50,070
we have a check here which check

422
00:17:48,150 --> 00:17:52,140
wearable is if a check variables is your

423
00:17:50,070 --> 00:17:54,000
equals to zero then it's gonna print out

424
00:17:52,140 --> 00:17:58,080
for us that we are inside secret and

425
00:17:54,000 --> 00:18:00,360
terminating 10 minutes so checking out

426
00:17:58,080 --> 00:18:04,230
you see we have the check variable and

427
00:18:00,360 --> 00:18:07,709
it's set to zero so yeah now checking

428
00:18:04,230 --> 00:18:10,679
this variable in this is number if you

429
00:18:07,710 --> 00:18:12,330
can see it's in the day section which is

430
00:18:10,679 --> 00:18:14,280
good for us because it means we can

431
00:18:12,330 --> 00:18:16,320
actually write it because if this would

432
00:18:14,280 --> 00:18:18,510
be in the text segment you can write it

433
00:18:16,320 --> 00:18:21,149
because the text segment is a executable

434
00:18:18,510 --> 00:18:23,760
part not writable but this this is

435
00:18:21,150 --> 00:18:26,460
segment segment is not executable pop

436
00:18:23,760 --> 00:18:28,320
writable not actually a place directly

437
00:18:26,460 --> 00:18:31,500
to be in the data section

438
00:18:28,320 --> 00:18:33,600
anyways so this means that we actually

439
00:18:31,500 --> 00:18:35,790
have to write a rough chain to modify

440
00:18:33,600 --> 00:18:40,230
the check value and then jump to secret

441
00:18:35,790 --> 00:18:42,330
with holding check the correct value and

442
00:18:40,230 --> 00:18:43,890
you won't even know that it also means

443
00:18:42,330 --> 00:18:47,129
that we actually have to execute more

444
00:18:43,890 --> 00:18:49,740
than monkish so here's what we know so

445
00:18:47,130 --> 00:18:52,679
far so first we need to find a set up

446
00:18:49,740 --> 00:18:54,690
credit to set up our registers then we

447
00:18:52,679 --> 00:18:57,179
need to find a correct correct it to

448
00:18:54,690 --> 00:18:59,309
write the correct values to the correct

449
00:18:57,179 --> 00:19:02,220
address then we want to trigger the UAF

450
00:18:59,309 --> 00:19:05,460
mark and then execute our obtain here's

451
00:19:02,220 --> 00:19:06,720
the first part so we want to find the

452
00:19:05,460 --> 00:19:09,179
set up and the right get it

453
00:19:06,720 --> 00:19:11,970
so I actually post these gadgets into

454
00:19:09,179 --> 00:19:15,540
the banner because just to be easier to

455
00:19:11,970 --> 00:19:18,990
find it and yeah so we can see it's

456
00:19:15,540 --> 00:19:19,620
actually pops or 0 and R 1 R 2 and 4 in

457
00:19:18,990 --> 00:19:21,660
Haribo

458
00:19:19,620 --> 00:19:24,659
this means that we can control our 0 and

459
00:19:21,660 --> 00:19:28,650
our ROM so we basically have this set up

460
00:19:24,660 --> 00:19:30,150
gated now here's the bracket is what we

461
00:19:28,650 --> 00:19:32,970
can see here is the storage of all we

462
00:19:30,150 --> 00:19:34,679
find inside or 0 to a memory location

463
00:19:32,970 --> 00:19:36,990
pointed by varam

464
00:19:34,679 --> 00:19:38,760
now this is perfect for us because as I

465
00:19:36,990 --> 00:19:41,580
said earlier we actually can control our

466
00:19:38,760 --> 00:19:44,879
sewer and our pond bellies so we have

467
00:19:41,580 --> 00:19:45,419
put of them are set up in so

468
00:19:44,880 --> 00:19:47,100
now

469
00:19:45,420 --> 00:19:50,070
remember we are actually working on the

470
00:19:47,100 --> 00:19:53,040
Heath and we have won gauged worth of

471
00:19:50,070 --> 00:19:57,210
execution so we need a solution and that

472
00:19:53,040 --> 00:19:57,780
is stack pivoting so now we need to find

473
00:19:57,210 --> 00:20:00,780
a pivot good

474
00:19:57,780 --> 00:20:02,550
so I actually placed this aside in time

475
00:20:00,780 --> 00:20:05,820
I bury on each side you can see it just

476
00:20:02,550 --> 00:20:08,490
basically moves the value inside phones

477
00:20:05,820 --> 00:20:11,790
inside are to the the stack minor so it

478
00:20:08,490 --> 00:20:15,330
just basically alright so now we have

479
00:20:11,790 --> 00:20:17,460
all the gadgets set if so we can see but

480
00:20:15,330 --> 00:20:20,970
we can see that this is the secret code

481
00:20:17,460 --> 00:20:24,120
again this is the code man if it will

482
00:20:20,970 --> 00:20:26,430
check which equals to zero it's gonna

483
00:20:24,120 --> 00:20:28,919
jump here and it will exit now you're

484
00:20:26,430 --> 00:20:33,090
probably wondering why not June jump

485
00:20:28,920 --> 00:20:35,700
just here and skip the check oh that

486
00:20:33,090 --> 00:20:39,959
would be too easy and I wanted to demo

487
00:20:35,700 --> 00:20:42,090
how food chain works so yeah now we have

488
00:20:39,960 --> 00:20:44,850
churches now we need to occur up the

489
00:20:42,090 --> 00:20:48,000
exploit so here's how the exploit looks

490
00:20:44,850 --> 00:20:49,830
like so we are basically the search

491
00:20:48,000 --> 00:20:52,800
device which will essentially fill up

492
00:20:49,830 --> 00:20:56,970
the heap and this will overwrite our

493
00:20:52,800 --> 00:20:58,889
first function pointer and yeah so if

494
00:20:56,970 --> 00:21:02,010
you go we can beat the Phillip filled up

495
00:20:58,890 --> 00:21:03,420
heap and this is where we override the

496
00:21:02,010 --> 00:21:05,930
first function pointer and this is

497
00:21:03,420 --> 00:21:08,490
actually pointing to our paper credit so

498
00:21:05,930 --> 00:21:14,610
after executing the pivot gettest will

499
00:21:08,490 --> 00:21:16,080
actually jump here and this will this

500
00:21:14,610 --> 00:21:18,449
will the set up get it so this is the

501
00:21:16,080 --> 00:21:22,260
side of greatest address and now we will

502
00:21:18,450 --> 00:21:26,910
load 1 1 1 into R 0 and we will write

503
00:21:22,260 --> 00:21:29,250
the address of check into R 1 so now

504
00:21:26,910 --> 00:21:31,800
your some drunk characters and here's

505
00:21:29,250 --> 00:21:33,510
the dress with the bracket it you can

506
00:21:31,800 --> 00:21:36,510
hear some John characters and here's the

507
00:21:33,510 --> 00:21:40,320
address of the secret so after executing

508
00:21:36,510 --> 00:21:44,040
this exploit we can basically have full

509
00:21:40,320 --> 00:21:48,169
control over the program so yeah now all

510
00:21:44,040 --> 00:21:48,170
the checks are done and here's a test

511
00:21:48,940 --> 00:21:59,140
yeah so my in the pantry which doesn't

512
00:21:56,000 --> 00:21:59,140
really matter what we entered our

513
00:22:02,110 --> 00:22:07,310
reallocate device and I just called up

514
00:22:05,540 --> 00:22:09,080
to number five to just show you that is

515
00:22:07,310 --> 00:22:12,649
just basically print out that first

516
00:22:09,080 --> 00:22:17,600
trick was done in second request um yeah

517
00:22:12,650 --> 00:22:20,600
so this is the correct order and specify

518
00:22:17,600 --> 00:22:22,399
the path or exploit file now coding

519
00:22:20,600 --> 00:22:25,219
option number five we can see that pond

520
00:22:22,400 --> 00:22:28,460
and huge shower and is executed you name

521
00:22:25,220 --> 00:22:31,460
that recommend yeah the expert is

522
00:22:28,460 --> 00:22:33,530
complete and here's some useful wing so

523
00:22:31,460 --> 00:22:35,780
if you want to learn more bomb on

524
00:22:33,530 --> 00:22:37,910
exploitation so the top one is

525
00:22:35,780 --> 00:22:39,020
especially good one and the last one is

526
00:22:37,910 --> 00:22:40,880
my github prepared where you can

527
00:22:39,020 --> 00:22:45,860
download this challenge from and you can

528
00:22:40,880 --> 00:22:47,690
try out yourself so yeah this is my tree

529
00:22:45,860 --> 00:22:49,459
handle if you want to follow any of my

530
00:22:47,690 --> 00:22:52,970
work or if you have any questions later

531
00:22:49,460 --> 00:22:54,710
you can DM me but if you guys have any

532
00:22:52,970 --> 00:22:56,230
questions are feel free to ask and I

533
00:22:54,710 --> 00:22:58,890
will try to answer but that's a good

534
00:22:56,230 --> 00:23:03,739
thanks

535
00:22:58,890 --> 00:23:03,739
[Applause]

