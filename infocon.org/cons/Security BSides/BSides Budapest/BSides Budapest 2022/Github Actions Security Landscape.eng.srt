1
00:00:00,160 --> 00:00:02,000
guys

2
00:00:02,000 --> 00:00:04,640
hello everybody good morning we are ilya

3
00:00:04,640 --> 00:00:06,640
and alex from cyclode

4
00:00:06,640 --> 00:00:09,840
and in the next 45 minutes we will

5
00:00:09,840 --> 00:00:12,320
present our research

6
00:00:12,320 --> 00:00:15,040
on github actions internals

7
00:00:15,040 --> 00:00:17,039
including how we discovered and

8
00:00:17,039 --> 00:00:20,000
disclosed critical vulnerabilities in

9
00:00:20,000 --> 00:00:22,240
popular open source projects that were

10
00:00:22,240 --> 00:00:24,960
using those actions

11
00:00:24,960 --> 00:00:28,080
so on the agenda we will talk about what

12
00:00:28,080 --> 00:00:29,840
are github actions and why it's such a

13
00:00:29,840 --> 00:00:32,040
powerful build system which kind of

14
00:00:32,040 --> 00:00:34,480
misconfiguration it can have we will

15
00:00:34,480 --> 00:00:36,880
understand the consequences by exploring

16
00:00:36,880 --> 00:00:39,120
its internals and we will speak about

17
00:00:39,120 --> 00:00:41,760
possible mitigations

18
00:00:41,760 --> 00:00:44,480
so my name is ilya i previously worked

19
00:00:44,480 --> 00:00:46,399
as a developer and are in the team

20
00:00:46,399 --> 00:00:48,960
leader on the ips product in checkpoint

21
00:00:48,960 --> 00:00:50,879
i later on moved

22
00:00:50,879 --> 00:00:54,160
to fireglass a security startup which

23
00:00:54,160 --> 00:00:56,000
created the first

24
00:00:56,000 --> 00:00:59,359
web isolation solution and currently i'm

25
00:00:59,359 --> 00:01:01,840
working as a back-end technology lead at

26
00:01:01,840 --> 00:01:04,159
cycle

27
00:01:04,159 --> 00:01:06,320
and i'm alex silgaiv i'm a senior

28
00:01:06,320 --> 00:01:08,240
security researcher at cyclode

29
00:01:08,240 --> 00:01:10,400
previously i were investigating malwares

30
00:01:10,400 --> 00:01:12,560
at checkpoint research a reverse

31
00:01:12,560 --> 00:01:14,320
engineer with some interesting piece of

32
00:01:14,320 --> 00:01:15,840
malware both

33
00:01:15,840 --> 00:01:18,080
crimewares and apts

34
00:01:18,080 --> 00:01:20,560
and at the moment i'm

35
00:01:20,560 --> 00:01:22,159
searching vulnerabilities and

36
00:01:22,159 --> 00:01:24,479
researching mitigations for the software

37
00:01:24,479 --> 00:01:27,119
supply chain

38
00:01:27,119 --> 00:01:30,240
security that's it

39
00:01:30,400 --> 00:01:33,840
okay so you all know github

40
00:01:33,840 --> 00:01:36,640
and its code storing capabilities

41
00:01:36,640 --> 00:01:39,200
and in 2018 they stepped up their game

42
00:01:39,200 --> 00:01:41,840
and decided to create a cicd platform

43
00:01:41,840 --> 00:01:43,600
called github actions

44
00:01:43,600 --> 00:01:45,520
which allowed its developers to automate

45
00:01:45,520 --> 00:01:48,320
their development workflows

46
00:01:48,320 --> 00:01:50,720
it really became very popular

47
00:01:50,720 --> 00:01:52,000
quite fast

48
00:01:52,000 --> 00:01:53,040
and

49
00:01:53,040 --> 00:01:55,759
mainly due to its rich marketplace

50
00:01:55,759 --> 00:01:59,280
and currently it holds more than 2 000

51
00:01:59,280 --> 00:02:01,920
public actions on it marketplace

52
00:02:01,920 --> 00:02:05,119
and also provides free

53
00:02:05,119 --> 00:02:07,759
free ci cd for public repositories

54
00:02:07,759 --> 00:02:10,080
according to the their numbers github

55
00:02:10,080 --> 00:02:12,160
currently has more than 73 million

56
00:02:12,160 --> 00:02:13,280
developers

57
00:02:13,280 --> 00:02:14,160
and

58
00:02:14,160 --> 00:02:15,680
stores more than 200 million

59
00:02:15,680 --> 00:02:17,840
repositories

60
00:02:17,840 --> 00:02:19,920
so what are the possible usage of github

61
00:02:19,920 --> 00:02:22,959
actions the main usage is cicd as i

62
00:02:22,959 --> 00:02:24,560
mentioned

63
00:02:24,560 --> 00:02:27,599
for example running

64
00:02:27,599 --> 00:02:30,160
tests on open pull requests or static

65
00:02:30,160 --> 00:02:31,840
analysis

66
00:02:31,840 --> 00:02:32,800
you can

67
00:02:32,800 --> 00:02:34,800
build your code into containers and

68
00:02:34,800 --> 00:02:37,360
upload them to a chosen registry such as

69
00:02:37,360 --> 00:02:39,360
docker hub or ecr

70
00:02:39,360 --> 00:02:40,959
you can schedule tasks that will scan

71
00:02:40,959 --> 00:02:42,959
vulnerabilities in your code you can use

72
00:02:42,959 --> 00:02:44,959
it to automatically label issues and

73
00:02:44,959 --> 00:02:47,360
pull requests you can send issues to

74
00:02:47,360 --> 00:02:49,680
ticket handling systems and much much

75
00:02:49,680 --> 00:02:51,599
more

76
00:02:51,599 --> 00:02:54,959
so here's an example of a github action

77
00:02:54,959 --> 00:02:57,840
as you can see it is just a yaml file

78
00:02:57,840 --> 00:02:59,519
that contains

79
00:02:59,519 --> 00:03:01,519
when and what to run

80
00:03:01,519 --> 00:03:02,239
so

81
00:03:02,239 --> 00:03:04,480
in the you can see their own

82
00:03:04,480 --> 00:03:05,440
uh

83
00:03:05,440 --> 00:03:07,200
keyword which means that this action

84
00:03:07,200 --> 00:03:09,599
should run upon every push every new

85
00:03:09,599 --> 00:03:11,040
push to the

86
00:03:11,040 --> 00:03:13,840
repository and it contains a single job

87
00:03:13,840 --> 00:03:15,840
in the single step just to print hello

88
00:03:15,840 --> 00:03:16,959
world

89
00:03:16,959 --> 00:03:19,200
to create this workflow you simply need

90
00:03:19,200 --> 00:03:22,080
to put this code inside dot github slash

91
00:03:22,080 --> 00:03:23,280
workflows

92
00:03:23,280 --> 00:03:25,120
and that's it

93
00:03:25,120 --> 00:03:27,360
every next push will trigger that

94
00:03:27,360 --> 00:03:29,680
workflow

95
00:03:29,680 --> 00:03:32,080
so let's speak about a little bit about

96
00:03:32,080 --> 00:03:33,599
how it works

97
00:03:33,599 --> 00:03:35,920
so github runner is an open source

98
00:03:35,920 --> 00:03:38,560
project that what it connects to the

99
00:03:38,560 --> 00:03:41,040
github action service fetches the jobs

100
00:03:41,040 --> 00:03:42,959
and then executes them

101
00:03:42,959 --> 00:03:45,120
it can run on a github hosted machine

102
00:03:45,120 --> 00:03:47,519
which is the popular use case and you

103
00:03:47,519 --> 00:03:49,519
can also run it on your self-hosted

104
00:03:49,519 --> 00:03:51,120
environment

105
00:03:51,120 --> 00:03:53,280
the gita boasted runners will run as a

106
00:03:53,280 --> 00:03:55,360
thermal environment which means they're

107
00:03:55,360 --> 00:03:58,640
created upon a workflow triggering and

108
00:03:58,640 --> 00:04:01,040
will be destroyed after it ends and for

109
00:04:01,040 --> 00:04:03,040
each workflow a new temporary github

110
00:04:03,040 --> 00:04:05,439
token is created for the possible api

111
00:04:05,439 --> 00:04:06,959
interactions

112
00:04:06,959 --> 00:04:07,840
so be

113
00:04:07,840 --> 00:04:09,680
before we talk about

114
00:04:09,680 --> 00:04:12,400
the github token itself a few words

115
00:04:12,400 --> 00:04:14,480
about access tokens in general so in

116
00:04:14,480 --> 00:04:17,839
order to access and modify github assets

117
00:04:17,839 --> 00:04:19,759
you need to provide an authentication

118
00:04:19,759 --> 00:04:22,079
token that details your permissions

119
00:04:22,079 --> 00:04:23,840
so as you can see here when creating a

120
00:04:23,840 --> 00:04:26,000
token a developer can choose which

121
00:04:26,000 --> 00:04:28,320
permission the token will have which are

122
00:04:28,320 --> 00:04:30,479
basically a subset of the user's

123
00:04:30,479 --> 00:04:33,440
permissions uh inside that specific

124
00:04:33,440 --> 00:04:36,240
token so i as a user can have access to

125
00:04:36,240 --> 00:04:39,360
many organizations and many repositories

126
00:04:39,360 --> 00:04:42,639
and this this token will basically

127
00:04:42,639 --> 00:04:44,800
provide those permissions when i use

128
00:04:44,800 --> 00:04:46,160
them

129
00:04:46,160 --> 00:04:48,000
another thing you can see that these

130
00:04:48,000 --> 00:04:51,120
tokens can be created uh

131
00:04:51,120 --> 00:04:52,960
with with or without

132
00:04:52,960 --> 00:04:55,440
expiration which makes them a lot more

133
00:04:55,440 --> 00:04:56,560
strong

134
00:04:56,560 --> 00:04:59,600
meaning that these tokens have a

135
00:04:59,600 --> 00:05:02,639
privilege to do a lot of damage and it

136
00:05:02,639 --> 00:05:05,280
can even not expire at all

137
00:05:05,280 --> 00:05:07,039
so github when they designed their

138
00:05:07,039 --> 00:05:09,039
github actions they really wanted that

139
00:05:09,039 --> 00:05:11,600
developers would not use those personal

140
00:05:11,600 --> 00:05:14,240
access tokens inside their workflows

141
00:05:14,240 --> 00:05:16,320
so to overcome this they created

142
00:05:16,320 --> 00:05:18,400
something called github token

143
00:05:18,400 --> 00:05:20,720
and the github token is provided for

144
00:05:20,720 --> 00:05:24,479
every workflow that that starts running

145
00:05:24,479 --> 00:05:26,160
its default permissions are read and

146
00:05:26,160 --> 00:05:28,160
write for most of the events and the

147
00:05:28,160 --> 00:05:30,960
permissions are only for the repository

148
00:05:30,960 --> 00:05:32,960
in which the github actions is currently

149
00:05:32,960 --> 00:05:34,240
running

150
00:05:34,240 --> 00:05:36,800
the token is valid during its action the

151
00:05:36,800 --> 00:05:38,400
action execution period

152
00:05:38,400 --> 00:05:41,680
or 24 24 hours at most

153
00:05:41,680 --> 00:05:43,680
and it uses a default parameter in many

154
00:05:43,680 --> 00:05:44,639
actions

155
00:05:44,639 --> 00:05:46,560
and is this is the preferred method to

156
00:05:46,560 --> 00:05:48,639
invoke github api

157
00:05:48,639 --> 00:05:50,320
functionalities

158
00:05:50,320 --> 00:05:52,400
an important note are forked pull

159
00:05:52,400 --> 00:05:53,919
requests

160
00:05:53,919 --> 00:05:56,720
which which are basically used when uh

161
00:05:56,720 --> 00:05:58,880
contributors want to contribute to some

162
00:05:58,880 --> 00:06:01,120
open source project they fork the

163
00:06:01,120 --> 00:06:03,199
repository and create a pull request

164
00:06:03,199 --> 00:06:05,520
with the suggested changes

165
00:06:05,520 --> 00:06:07,440
and if you think about it if that

166
00:06:07,440 --> 00:06:09,840
specific repository has a github

167
00:06:09,840 --> 00:06:12,800
workflow which for example runs the cic

168
00:06:12,800 --> 00:06:15,039
test or static analysis

169
00:06:15,039 --> 00:06:16,240
this

170
00:06:16,240 --> 00:06:17,600
the developer

171
00:06:17,600 --> 00:06:19,680
can basically use that github token with

172
00:06:19,680 --> 00:06:21,680
the right permissions to modify the

173
00:06:21,680 --> 00:06:24,000
content of the repository by committing

174
00:06:24,000 --> 00:06:27,440
via api or stuff like that so github has

175
00:06:27,440 --> 00:06:28,400
different

176
00:06:28,400 --> 00:06:30,560
mitigations for forked pull requests but

177
00:06:30,560 --> 00:06:31,919
the basic one

178
00:06:31,919 --> 00:06:34,960
is in those scenarios the github token

179
00:06:34,960 --> 00:06:37,759
receives at most read permissions

180
00:06:37,759 --> 00:06:41,919
so these scenarios won't be possible

181
00:06:42,000 --> 00:06:44,080
another core mechanism in github are the

182
00:06:44,080 --> 00:06:47,039
secrets so any meaningful

183
00:06:47,039 --> 00:06:50,880
cicd workflow will need to use some

184
00:06:50,880 --> 00:06:54,880
secrets for example aws access tokens or

185
00:06:54,880 --> 00:06:57,120
or passwords for registries

186
00:06:57,120 --> 00:06:58,720
and gita

187
00:06:58,720 --> 00:07:01,039
gives us the option to store secrets

188
00:07:01,039 --> 00:07:03,039
they save it in a well encrypted manner

189
00:07:03,039 --> 00:07:05,680
and if the workflow wants to use them it

190
00:07:05,680 --> 00:07:07,759
decrypts and adds it to the to the

191
00:07:07,759 --> 00:07:09,360
payload of the workflow there are

192
00:07:09,360 --> 00:07:12,080
several options on how to create secrets

193
00:07:12,080 --> 00:07:13,759
some of them are on the

194
00:07:13,759 --> 00:07:17,120
organization scope on a repository scope

195
00:07:17,120 --> 00:07:19,120
or even a repository environment which

196
00:07:19,120 --> 00:07:22,319
we will talk about a bit later

197
00:07:22,319 --> 00:07:23,520
and here's

198
00:07:23,520 --> 00:07:26,160
the first example of a vulnerable action

199
00:07:26,160 --> 00:07:28,160
so the sample workflow you can see that

200
00:07:28,160 --> 00:07:29,120
the

201
00:07:29,120 --> 00:07:31,120
keyword is on

202
00:07:31,120 --> 00:07:33,280
issue created on opened this means that

203
00:07:33,280 --> 00:07:35,199
this work will run every time i will

204
00:07:35,199 --> 00:07:37,919
open an issue in github for a github

205
00:07:37,919 --> 00:07:40,240
repository you can see that it has a

206
00:07:40,240 --> 00:07:43,440
single step which runs a script

207
00:07:43,440 --> 00:07:45,520
and an important note here are the curly

208
00:07:45,520 --> 00:07:47,280
braces that are used throughout the

209
00:07:47,280 --> 00:07:48,319
script

210
00:07:48,319 --> 00:07:49,759
which allows

211
00:07:49,759 --> 00:07:52,160
developers to use dynamic parameters in

212
00:07:52,160 --> 00:07:54,800
their workflows so github provides

213
00:07:54,800 --> 00:07:56,960
parameters on the event triggered for

214
00:07:56,960 --> 00:07:59,599
example the issue title and the issue

215
00:07:59,599 --> 00:08:02,080
url and also the github token that we

216
00:08:02,080 --> 00:08:03,840
discussed previously

217
00:08:03,840 --> 00:08:06,319
and this specific workflow basically

218
00:08:06,319 --> 00:08:08,160
checks if the title contains the word

219
00:08:08,160 --> 00:08:09,039
bug

220
00:08:09,039 --> 00:08:12,160
and if so it performs an api call and

221
00:08:12,160 --> 00:08:14,960
adds a new label of type bug to that

222
00:08:14,960 --> 00:08:16,080
issue

223
00:08:16,080 --> 00:08:18,479
so this looks innocent enough

224
00:08:18,479 --> 00:08:22,240
but let's see how it can be exploited

225
00:08:22,240 --> 00:08:24,960
on the right you can see an issue title

226
00:08:24,960 --> 00:08:26,400
that we provided

227
00:08:26,400 --> 00:08:28,960
for that workflow and on the left you

228
00:08:28,960 --> 00:08:30,879
can see what happens when it is actually

229
00:08:30,879 --> 00:08:32,240
executed

230
00:08:32,240 --> 00:08:35,120
this title is planted inside the curly

231
00:08:35,120 --> 00:08:37,279
braces that we saw before and you see

232
00:08:37,279 --> 00:08:41,039
here that the if statement is is not

233
00:08:41,039 --> 00:08:44,560
non-existent it's it jumps over the if

234
00:08:44,560 --> 00:08:45,519
and then

235
00:08:45,519 --> 00:08:48,399
runs a code on the runner itself this

236
00:08:48,399 --> 00:08:52,320
example just prints cycle to the screen

237
00:08:52,320 --> 00:08:53,440
and

238
00:08:53,440 --> 00:08:56,880
the fact that this crafted issue uh

239
00:08:56,880 --> 00:08:58,959
knows how the workflow looks and it

240
00:08:58,959 --> 00:09:00,880
knows how to start the if and how to

241
00:09:00,880 --> 00:09:03,200
finish the if in in a way that the

242
00:09:03,200 --> 00:09:04,560
syntax is

243
00:09:04,560 --> 00:09:08,959
is valid and the workflow runs

244
00:09:08,959 --> 00:09:11,279
so is it a bug or a feature

245
00:09:11,279 --> 00:09:13,040
according to github's best practice

246
00:09:13,040 --> 00:09:15,360
papers it is well known

247
00:09:15,360 --> 00:09:17,519
and they cite when creating workflows

248
00:09:17,519 --> 00:09:19,120
you should always consider whether your

249
00:09:19,120 --> 00:09:21,360
code might execute untrusted input from

250
00:09:21,360 --> 00:09:22,480
attackers

251
00:09:22,480 --> 00:09:25,200
which is very nice and very friendly

252
00:09:25,200 --> 00:09:27,200
but i'm not sure that all developers in

253
00:09:27,200 --> 00:09:28,720
the world start by reading the best

254
00:09:28,720 --> 00:09:30,720
practices documents before they start

255
00:09:30,720 --> 00:09:32,959
using the platform itself

256
00:09:32,959 --> 00:09:36,959
so we wanted to know how how popular

257
00:09:36,959 --> 00:09:39,839
the usage of these batters are

258
00:09:39,839 --> 00:09:43,360
we used a tool called github search

259
00:09:43,360 --> 00:09:45,839
and which is currently in beta but it's

260
00:09:45,839 --> 00:09:47,680
a very nice tool you can just add

261
00:09:47,680 --> 00:09:49,440
keywords to the search here and it will

262
00:09:49,440 --> 00:09:51,680
search all public repositories in github

263
00:09:51,680 --> 00:09:54,000
and will return the results you can sign

264
00:09:54,000 --> 00:09:56,080
up and try it out it's really fast and

265
00:09:56,080 --> 00:09:57,360
really nice

266
00:09:57,360 --> 00:09:58,959
and you see that we search for the

267
00:09:58,959 --> 00:10:01,120
github event issue in curly braces and

268
00:10:01,120 --> 00:10:03,040
also

269
00:10:03,040 --> 00:10:05,120
the keyword run

270
00:10:05,120 --> 00:10:06,800
as you see we have

271
00:10:06,800 --> 00:10:08,560
two hits here

272
00:10:08,560 --> 00:10:09,519
in which

273
00:10:09,519 --> 00:10:11,839
we find workflows that indeed can be

274
00:10:11,839 --> 00:10:15,600
exploited in the way i just showed

275
00:10:15,600 --> 00:10:17,680
so is it widespread

276
00:10:17,680 --> 00:10:21,360
we saw we found many many a

277
00:10:21,360 --> 00:10:23,680
popular open source projects such as

278
00:10:23,680 --> 00:10:25,440
liquid base

279
00:10:25,440 --> 00:10:26,880
which is a

280
00:10:26,880 --> 00:10:28,560
tool for

281
00:10:28,560 --> 00:10:30,240
handling

282
00:10:30,240 --> 00:10:33,360
database schema changes wire which is an

283
00:10:33,360 --> 00:10:36,800
open communication platform and many

284
00:10:36,800 --> 00:10:37,760
more

285
00:10:37,760 --> 00:10:38,800
and

286
00:10:38,800 --> 00:10:40,320
we can see that according to the

287
00:10:40,320 --> 00:10:42,800
downloads of those open source projects

288
00:10:42,800 --> 00:10:44,480
and the their usage

289
00:10:44,480 --> 00:10:46,800
these vulnerabilities are are

290
00:10:46,800 --> 00:10:51,120
potentially affecting millions of users

291
00:10:51,839 --> 00:10:54,720
so here let's dive a bit into one of the

292
00:10:54,720 --> 00:10:58,240
use cases of the wire specific one and

293
00:10:58,240 --> 00:10:59,760
here you can see a part of their

294
00:10:59,760 --> 00:11:01,360
workflow you can see that it is

295
00:11:01,360 --> 00:11:04,079
triggered upon any issue comment

296
00:11:04,079 --> 00:11:06,640
and an important note here is that

297
00:11:06,640 --> 00:11:09,600
an issue comment is used when you add a

298
00:11:09,600 --> 00:11:11,279
comment to an issue and also when you

299
00:11:11,279 --> 00:11:13,040
add a comment to a pull request so

300
00:11:13,040 --> 00:11:14,959
github

301
00:11:14,959 --> 00:11:16,959
users are using the same event for both

302
00:11:16,959 --> 00:11:19,279
of these scenarios and you can see

303
00:11:19,279 --> 00:11:22,000
several steps the first step is

304
00:11:22,000 --> 00:11:24,720
basically checking that the github

305
00:11:24,720 --> 00:11:26,560
that the command body contains some

306
00:11:26,560 --> 00:11:29,839
keywords zenkin's review so if we add a

307
00:11:29,839 --> 00:11:32,000
pull request comment with the word

308
00:11:32,000 --> 00:11:34,959
zenkins review we will go past we will

309
00:11:34,959 --> 00:11:37,839
pass this if we go to the next one and

310
00:11:37,839 --> 00:11:40,720
here it just checks that whether the

311
00:11:40,720 --> 00:11:42,720
comment is on the pull request or not so

312
00:11:42,720 --> 00:11:45,600
if it is we continue to the next if

313
00:11:45,600 --> 00:11:47,839
here it checks whether the title starts

314
00:11:47,839 --> 00:11:49,200
with some keyword then end with some

315
00:11:49,200 --> 00:11:51,200
keyword and if it doesn't

316
00:11:51,200 --> 00:11:53,920
you can see the two echo commands and

317
00:11:53,920 --> 00:11:55,600
the second one is

318
00:11:55,600 --> 00:11:58,399
basically printing out the issue title

319
00:11:58,399 --> 00:12:01,279
for debug purposes and this is exactly

320
00:12:01,279 --> 00:12:04,959
what can be used to exploit this very

321
00:12:04,959 --> 00:12:07,279
popular workflow

322
00:12:07,279 --> 00:12:09,920
on the right you can see that after we

323
00:12:09,920 --> 00:12:12,240
disclosed this issue to wire they were

324
00:12:12,240 --> 00:12:15,279
very fast in patching the problem and it

325
00:12:15,279 --> 00:12:18,160
was very simple you simply need to use

326
00:12:18,160 --> 00:12:20,560
an environment variable so you see the

327
00:12:20,560 --> 00:12:21,839
end

328
00:12:21,839 --> 00:12:23,040
at the top

329
00:12:23,040 --> 00:12:24,639
storing the issue title in that

330
00:12:24,639 --> 00:12:26,720
environment variable and then you can

331
00:12:26,720 --> 00:12:29,600
just use that and it is already escaped

332
00:12:29,600 --> 00:12:32,079
and the code will not run when you use

333
00:12:32,079 --> 00:12:35,439
it in this format

334
00:12:35,600 --> 00:12:37,920
so what are the consequences of a build

335
00:12:37,920 --> 00:12:39,680
compromise

336
00:12:39,680 --> 00:12:44,399
you can expose secrets as we mentioned

337
00:12:44,720 --> 00:12:47,839
in order to create a meaningful cicd

338
00:12:47,839 --> 00:12:50,720
pipeline you are probably using secrets

339
00:12:50,720 --> 00:12:53,920
so in this way once we we have code that

340
00:12:53,920 --> 00:12:56,240
is running on the runner we can use it

341
00:12:56,240 --> 00:12:58,560
to expose the secrets to the sensitive

342
00:12:58,560 --> 00:12:59,920
assets

343
00:12:59,920 --> 00:13:02,560
we can also use the github token the one

344
00:13:02,560 --> 00:13:04,560
we discussed before to commit to the

345
00:13:04,560 --> 00:13:06,399
repository as i mentioned

346
00:13:06,399 --> 00:13:07,920
by default you have read write

347
00:13:07,920 --> 00:13:10,560
permissions to that repository so we can

348
00:13:10,560 --> 00:13:13,440
create a workflow an inject code that

349
00:13:13,440 --> 00:13:15,680
uses github api with that token to

350
00:13:15,680 --> 00:13:17,920
commit code that is not really part of

351
00:13:17,920 --> 00:13:21,760
the pull request inside that repository

352
00:13:21,760 --> 00:13:24,240
in such a way an attacker can really

353
00:13:24,240 --> 00:13:26,720
create critical supply chain incidents

354
00:13:26,720 --> 00:13:29,360
without being really reviewed or

355
00:13:29,360 --> 00:13:32,160
approved in that manner and the much

356
00:13:32,160 --> 00:13:33,760
smaller risk would be the malicious

357
00:13:33,760 --> 00:13:35,839
active ability to run botnets or crypto

358
00:13:35,839 --> 00:13:38,560
miners using runner infrastructure

359
00:13:38,560 --> 00:13:41,360
so in this point i will allow alex to

360
00:13:41,360 --> 00:13:44,000
dive a little bit deeper to the

361
00:13:44,000 --> 00:13:47,959
vulnerabilities and the mitigations

362
00:13:49,610 --> 00:13:52,720
[Applause]

363
00:13:52,720 --> 00:13:54,240
yeah

364
00:13:54,240 --> 00:13:55,920
so

365
00:13:55,920 --> 00:13:57,839
so thank you very much ilya

366
00:13:57,839 --> 00:14:00,720
let's dive a bit deeper

367
00:14:00,720 --> 00:14:02,560
technically deeper

368
00:14:02,560 --> 00:14:05,519
so ilia explained what could be the

369
00:14:05,519 --> 00:14:07,279
the consequences of such build

370
00:14:07,279 --> 00:14:08,560
compromise

371
00:14:08,560 --> 00:14:11,120
and will soon explore how an attacker

372
00:14:11,120 --> 00:14:14,320
could actually reach these consequences

373
00:14:14,320 --> 00:14:16,639
from technical perspective

374
00:14:16,639 --> 00:14:18,880
so for that we created this intentional

375
00:14:18,880 --> 00:14:21,279
vulnerable workflow which we'll explore

376
00:14:21,279 --> 00:14:23,279
through our example

377
00:14:23,279 --> 00:14:25,440
so this workflow first

378
00:14:25,440 --> 00:14:27,760
will be triggered whenever a new issue

379
00:14:27,760 --> 00:14:29,360
is created

380
00:14:29,360 --> 00:14:32,320
it defines the new environment variable

381
00:14:32,320 --> 00:14:34,000
for demonstration purposes soon we'll

382
00:14:34,000 --> 00:14:35,600
see while we're doing that

383
00:14:35,600 --> 00:14:39,360
and it has a three steps

384
00:14:40,079 --> 00:14:42,320
it has three steps the first one

385
00:14:42,320 --> 00:14:43,760
doing checkout

386
00:14:43,760 --> 00:14:46,000
this is an external action it's using

387
00:14:46,000 --> 00:14:47,839
the checkout command which basically

388
00:14:47,839 --> 00:14:51,199
does git clone to the code into the

389
00:14:51,199 --> 00:14:53,279
runner environment

390
00:14:53,279 --> 00:14:56,079
very simple and it has two additional

391
00:14:56,079 --> 00:14:59,360
run commands the first one just prints

392
00:14:59,360 --> 00:15:01,760
the issue title and description and the

393
00:15:01,760 --> 00:15:04,480
second one is run runs a

394
00:15:04,480 --> 00:15:05,760
c url

395
00:15:05,760 --> 00:15:08,480
to the github api to update

396
00:15:08,480 --> 00:15:13,360
this issue a label with a new issue

397
00:15:13,360 --> 00:15:14,480
so as

398
00:15:14,480 --> 00:15:18,079
ilia showed previously this echo

399
00:15:18,079 --> 00:15:20,000
is susceptible to injection attack

400
00:15:20,000 --> 00:15:22,160
because they are not sanitizing the

401
00:15:22,160 --> 00:15:22,880
the

402
00:15:22,880 --> 00:15:25,519
the title and the body so an attacker a

403
00:15:25,519 --> 00:15:27,920
malicious attacker could potentially

404
00:15:27,920 --> 00:15:28,880
run

405
00:15:28,880 --> 00:15:31,839
his code at this point exactly this

406
00:15:31,839 --> 00:15:34,000
exact point so what could he who is

407
00:15:34,000 --> 00:15:37,279
fetching in this uh in this sample he

408
00:15:37,279 --> 00:15:40,160
could get on the one side connect this

409
00:15:40,160 --> 00:15:42,240
this github token

410
00:15:42,240 --> 00:15:44,800
and use it for his malicious purposes or

411
00:15:44,800 --> 00:15:49,199
he could get this additional bot token

412
00:15:49,199 --> 00:15:51,920
which comes later in the strong command

413
00:15:51,920 --> 00:15:54,880
and see how we how he does that

414
00:15:54,880 --> 00:15:57,519
first in order to er

415
00:15:57,519 --> 00:16:00,079
to ease the testing of this random

416
00:16:00,079 --> 00:16:01,519
infrastructure instead of creating

417
00:16:01,519 --> 00:16:03,279
workflows and testing

418
00:16:03,279 --> 00:16:05,680
each workflow when he runs we created

419
00:16:05,680 --> 00:16:07,519
some lab environment

420
00:16:07,519 --> 00:16:08,660
in which we

421
00:16:08,660 --> 00:16:09,839
[Music]

422
00:16:09,839 --> 00:16:11,920
made a reverse shell from the runner

423
00:16:11,920 --> 00:16:15,040
environment to our personal computer

424
00:16:15,040 --> 00:16:17,279
for that we use the popular tool called

425
00:16:17,279 --> 00:16:20,480
ngrok which does basically a

426
00:16:20,480 --> 00:16:23,040
tcp or http tunneling

427
00:16:23,040 --> 00:16:25,440
even if you're behind firewall or not so

428
00:16:25,440 --> 00:16:28,639
it's really a really cool tool we just

429
00:16:28,639 --> 00:16:31,040
run the ngrok with the we installed the

430
00:16:31,040 --> 00:16:34,000
tool on our computer we run android tcp

431
00:16:34,000 --> 00:16:36,320
10000 tcp is the mode it could be run in

432
00:16:36,320 --> 00:16:38,800
each http also and ten thousand is the

433
00:16:38,800 --> 00:16:41,360
port in which we want to to listen

434
00:16:41,360 --> 00:16:43,839
after running it we received from a

435
00:16:43,839 --> 00:16:45,920
android android cloud received this end

436
00:16:45,920 --> 00:16:46,959
point

437
00:16:46,959 --> 00:16:49,519
which will use it later in their

438
00:16:49,519 --> 00:16:51,279
exploitation

439
00:16:51,279 --> 00:16:53,920
and then we just create a simple

440
00:16:53,920 --> 00:16:55,040
netcat

441
00:16:55,040 --> 00:16:57,600
listener on port 10000

442
00:16:57,600 --> 00:16:59,839
and at the end we created this

443
00:16:59,839 --> 00:17:02,160
simple bash script

444
00:17:02,160 --> 00:17:04,640
which does the the reversal it's you

445
00:17:04,640 --> 00:17:07,679
could find the script easily in google

446
00:17:07,679 --> 00:17:10,000
so combining all together

447
00:17:10,000 --> 00:17:13,119
when we were sending this issue title

448
00:17:13,119 --> 00:17:13,839
this

449
00:17:13,839 --> 00:17:15,679
looks quite complex but we explained how

450
00:17:15,679 --> 00:17:18,799
it really combined when we when we send

451
00:17:18,799 --> 00:17:21,359
this to the github repository and while

452
00:17:21,359 --> 00:17:23,760
we get our reversal

453
00:17:23,760 --> 00:17:26,079
we have a control on our computer on to

454
00:17:26,079 --> 00:17:28,400
the runner infrastructure so we can

455
00:17:28,400 --> 00:17:30,720
explore it and find it any interesting

456
00:17:30,720 --> 00:17:32,960
stuff in there so

457
00:17:32,960 --> 00:17:35,120
we won't overload you with all the

458
00:17:35,120 --> 00:17:38,000
reconnaissance with it on that machine

459
00:17:38,000 --> 00:17:40,160
you are welcome to check our full blog

460
00:17:40,160 --> 00:17:41,200
for that

461
00:17:41,200 --> 00:17:43,120
but we found some interesting

462
00:17:43,120 --> 00:17:45,360
pieces of data which we'll use later as

463
00:17:45,360 --> 00:17:49,120
we as we will show in this in the slides

464
00:17:49,120 --> 00:17:52,320
so let's go back to our previous example

465
00:17:52,320 --> 00:17:53,679
so first

466
00:17:53,679 --> 00:17:55,600
very simple thing an attacker could do

467
00:17:55,600 --> 00:17:57,520
if if we have a code execution

468
00:17:57,520 --> 00:17:58,799
capability

469
00:17:58,799 --> 00:18:01,200
is to print environment variable this

470
00:18:01,200 --> 00:18:03,760
simple command and find for some

471
00:18:03,760 --> 00:18:04,960
interesting

472
00:18:04,960 --> 00:18:06,799
stuff in the environment variable for

473
00:18:06,799 --> 00:18:08,480
example we have this github token

474
00:18:08,480 --> 00:18:10,320
defined

475
00:18:10,320 --> 00:18:11,600
as an environment variable which the

476
00:18:11,600 --> 00:18:12,799
attacker could

477
00:18:12,799 --> 00:18:14,720
just print the variable and get it and

478
00:18:14,720 --> 00:18:16,160
use it

479
00:18:16,160 --> 00:18:17,520
very simple

480
00:18:17,520 --> 00:18:19,600
it also happens in real world scenarios

481
00:18:19,600 --> 00:18:21,039
not in only our

482
00:18:21,039 --> 00:18:23,280
our sample

483
00:18:23,280 --> 00:18:26,080
a second scenario that attacker could do

484
00:18:26,080 --> 00:18:27,360
is

485
00:18:27,360 --> 00:18:29,760
use the checkout command

486
00:18:29,760 --> 00:18:32,400
as i said this command just does a git

487
00:18:32,400 --> 00:18:34,880
clone to the to the code

488
00:18:34,880 --> 00:18:38,640
but it also sends a default parameter

489
00:18:38,640 --> 00:18:40,720
which we are not seeing here but it

490
00:18:40,720 --> 00:18:42,400
sends the github token as a default

491
00:18:42,400 --> 00:18:46,000
parameter to the external checkout

492
00:18:46,000 --> 00:18:48,480
this github token is also used as a

493
00:18:48,480 --> 00:18:50,799
terminal authorization token

494
00:18:50,799 --> 00:18:52,559
for the git clone

495
00:18:52,559 --> 00:18:55,600
so wherever we're using a git

496
00:18:55,600 --> 00:18:57,679
the git set tooling also know that

497
00:18:57,679 --> 00:18:59,360
whenever you're doing git clone with

498
00:18:59,360 --> 00:19:03,360
some token it also saves that token in a

499
00:19:03,360 --> 00:19:07,120
that git slash config file

500
00:19:07,120 --> 00:19:09,760
so because we are running as an attacker

501
00:19:09,760 --> 00:19:12,000
after that checkout was made

502
00:19:12,000 --> 00:19:14,160
we can access this dot git slash config

503
00:19:14,160 --> 00:19:16,000
file

504
00:19:16,000 --> 00:19:19,120
find the authorization line in that file

505
00:19:19,120 --> 00:19:22,559
and just pipe it through base64 decoding

506
00:19:22,559 --> 00:19:25,600
and we get our github token which it

507
00:19:25,600 --> 00:19:27,840
will use which was sent to that action

508
00:19:27,840 --> 00:19:29,280
and used to

509
00:19:29,280 --> 00:19:31,600
to clone the code so as an attacker we

510
00:19:31,600 --> 00:19:32,559
have another

511
00:19:32,559 --> 00:19:34,799
method to to fetch this

512
00:19:34,799 --> 00:19:36,559
sensitive token

513
00:19:36,559 --> 00:19:38,559
this was the second scenario

514
00:19:38,559 --> 00:19:40,480
the first scenario is a a bit more

515
00:19:40,480 --> 00:19:42,320
complex and

516
00:19:42,320 --> 00:19:44,799
during a reconnaissance of the runner

517
00:19:44,799 --> 00:19:48,000
environment we noticed that each run

518
00:19:48,000 --> 00:19:51,280
command we have two of these here

519
00:19:51,280 --> 00:19:52,880
each one of this before it's been

520
00:19:52,880 --> 00:19:55,520
executed it's also is saved on the file

521
00:19:55,520 --> 00:19:57,679
system as a shell file

522
00:19:57,679 --> 00:19:59,679
and the runner saves it and then

523
00:19:59,679 --> 00:20:01,280
executes it

524
00:20:01,280 --> 00:20:03,120
so why it is interesting

525
00:20:03,120 --> 00:20:05,440
because in our case where

526
00:20:05,440 --> 00:20:07,120
as an attacker we have code execution at

527
00:20:07,120 --> 00:20:09,200
this point we didn't receive the second

528
00:20:09,200 --> 00:20:11,679
command yet so we have only this

529
00:20:11,679 --> 00:20:14,480
single run command you could see here as

530
00:20:14,480 --> 00:20:15,120
a

531
00:20:15,120 --> 00:20:16,720
as we're printing the directory the

532
00:20:16,720 --> 00:20:18,799
render type directory which saves this

533
00:20:18,799 --> 00:20:21,679
shell file we have a single shell file

534
00:20:21,679 --> 00:20:23,840
that contains the same content as this

535
00:20:23,840 --> 00:20:26,080
one but instead of the

536
00:20:26,080 --> 00:20:28,640
curly brackets placeholders we have the

537
00:20:28,640 --> 00:20:31,360
real values which were inserted

538
00:20:31,360 --> 00:20:32,840
as the action

539
00:20:32,840 --> 00:20:36,320
triggered so if we'll

540
00:20:36,320 --> 00:20:40,000
get this second-round comment somehow

541
00:20:40,000 --> 00:20:42,240
it contains also this secret the secret

542
00:20:42,240 --> 00:20:45,520
bot token which will be placed as a

543
00:20:45,520 --> 00:20:48,480
as a real value which as an attacker

544
00:20:48,480 --> 00:20:50,240
want to grab

545
00:20:50,240 --> 00:20:52,320
so if we get a foothold on this run

546
00:20:52,320 --> 00:20:54,000
comment we also

547
00:20:54,000 --> 00:20:56,559
get this bot token this secret

548
00:20:56,559 --> 00:20:58,240
but as i explained the attacker have

549
00:20:58,240 --> 00:21:00,480
caused execution at this point

550
00:21:00,480 --> 00:21:01,600
so how

551
00:21:01,600 --> 00:21:02,720
can we

552
00:21:02,720 --> 00:21:04,559
fetch the the next one that hasn't been

553
00:21:04,559 --> 00:21:06,640
executed yet

554
00:21:06,640 --> 00:21:08,559
we have many methods to do that a simple

555
00:21:08,559 --> 00:21:11,039
method either thought well off was just

556
00:21:11,039 --> 00:21:13,200
putting some persistent script on the

557
00:21:13,200 --> 00:21:14,480
runner

558
00:21:14,480 --> 00:21:17,200
uh what does it mean it means a simple

559
00:21:17,200 --> 00:21:18,480
uh

560
00:21:18,480 --> 00:21:20,400
you know our case was python script that

561
00:21:20,400 --> 00:21:23,679
was monitoring this directory

562
00:21:23,679 --> 00:21:25,440
and whenever a new shell file is written

563
00:21:25,440 --> 00:21:27,280
to the directory this file would be

564
00:21:27,280 --> 00:21:30,640
immediately sent to some control server

565
00:21:30,640 --> 00:21:32,640
as me as i'm simulating an attacker so i

566
00:21:32,640 --> 00:21:34,799
created the server and whenever the new

567
00:21:34,799 --> 00:21:37,440
file will be there it will be sent to me

568
00:21:37,440 --> 00:21:39,039
so

569
00:21:39,039 --> 00:21:40,640
what will be the steps

570
00:21:40,640 --> 00:21:43,440
creating a some server that records all

571
00:21:43,440 --> 00:21:45,840
the all requests creating some python

572
00:21:45,840 --> 00:21:48,080
script that records modified shell

573
00:21:48,080 --> 00:21:50,240
script in that directory

574
00:21:50,240 --> 00:21:52,559
i packaged it all into some docker

575
00:21:52,559 --> 00:21:55,280
container to ease the deployment and i

576
00:21:55,280 --> 00:21:58,400
run that container on the runner in a

577
00:21:58,400 --> 00:22:00,240
detached mode

578
00:22:00,240 --> 00:22:02,559
mapping the volume and

579
00:22:02,559 --> 00:22:04,799
and indicating the url which you would

580
00:22:04,799 --> 00:22:07,280
send the file to

581
00:22:07,280 --> 00:22:08,480
uh

582
00:22:08,480 --> 00:22:10,720
we'll soon see in demo how it works all

583
00:22:10,720 --> 00:22:13,200
together

584
00:22:13,200 --> 00:22:14,640
so these were the three scenarios we

585
00:22:14,640 --> 00:22:16,480
showed how to fetch secrets but there

586
00:22:16,480 --> 00:22:18,159
are many many more they were really

587
00:22:18,159 --> 00:22:20,080
simple and more sophisticated attackers

588
00:22:20,080 --> 00:22:22,559
applied sophisticated methods

589
00:22:22,559 --> 00:22:24,640
which we won't include in this

590
00:22:24,640 --> 00:22:26,559
in this slides or in the article

591
00:22:26,559 --> 00:22:29,120
additional methods could be inspecting

592
00:22:29,120 --> 00:22:31,200
the the memory layout of the process

593
00:22:31,200 --> 00:22:33,840
inside the runner try to extract some in

594
00:22:33,840 --> 00:22:35,440
sensitive information from within the

595
00:22:35,440 --> 00:22:38,240
memory it could be a

596
00:22:38,240 --> 00:22:40,240
monitoring created processes so maybe

597
00:22:40,240 --> 00:22:41,840
the secrets were sent through

598
00:22:41,840 --> 00:22:43,600
environment variables to the processes

599
00:22:43,600 --> 00:22:44,960
so we can

600
00:22:44,960 --> 00:22:46,640
fetch maybe interesting information

601
00:22:46,640 --> 00:22:47,440
there

602
00:22:47,440 --> 00:22:49,679
and there are many many more methods for

603
00:22:49,679 --> 00:22:50,880
further

604
00:22:50,880 --> 00:22:53,440
research

605
00:22:53,440 --> 00:22:56,080
so let's start with the demos uh for the

606
00:22:56,080 --> 00:22:57,679
first demo we'll show how can we

607
00:22:57,679 --> 00:23:00,240
exfiltrate secrets we will do it

608
00:23:00,240 --> 00:23:02,400
in two steps the first step will just

609
00:23:02,400 --> 00:23:05,120
send our simple github token as we

610
00:23:05,120 --> 00:23:06,799
explained through the environment

611
00:23:06,799 --> 00:23:09,200
variable and the second phase of the

612
00:23:09,200 --> 00:23:10,880
situation we'll put some persistent

613
00:23:10,880 --> 00:23:12,799
script on the machine and wait for the

614
00:23:12,799 --> 00:23:15,360
second command that will be sent

615
00:23:15,360 --> 00:23:18,400
also to our server

616
00:23:18,400 --> 00:23:20,480
so

617
00:23:20,480 --> 00:23:21,440
let's see

618
00:23:21,440 --> 00:23:22,400
first we

619
00:23:22,400 --> 00:23:25,840
set up the server

620
00:23:25,840 --> 00:23:27,520
our control server and we're sending the

621
00:23:27,520 --> 00:23:31,760
malicious issue to the repository

622
00:23:31,760 --> 00:23:33,760
this issue contains several commands if

623
00:23:33,760 --> 00:23:36,000
first it will

624
00:23:36,000 --> 00:23:38,720
call the github token

625
00:23:38,720 --> 00:23:40,240
which is the first phase and the second

626
00:23:40,240 --> 00:23:41,919
one will run the

627
00:23:41,919 --> 00:23:43,760
the docker run as you can see we got

628
00:23:43,760 --> 00:23:46,400
already the first token

629
00:23:46,400 --> 00:23:48,240
which were very simple through the

630
00:23:48,240 --> 00:23:51,840
environment variable and

631
00:23:51,840 --> 00:23:53,919
and we got also the second phase with

632
00:23:53,919 --> 00:23:56,559
the exfiltration you could see we have

633
00:23:56,559 --> 00:23:57,440
here

634
00:23:57,440 --> 00:23:58,720
i don't know if you remember but

635
00:23:58,720 --> 00:24:01,120
wherever the complete script that was

636
00:24:01,120 --> 00:24:03,279
the third step for in the sample

637
00:24:03,279 --> 00:24:05,679
workflow we have the conflict complete

638
00:24:05,679 --> 00:24:08,400
the best script including the

639
00:24:08,400 --> 00:24:09,360
token

640
00:24:09,360 --> 00:24:11,919
contained in that script

641
00:24:11,919 --> 00:24:15,200
so actually we managed to get it

642
00:24:15,200 --> 00:24:17,120
so for the second

643
00:24:17,120 --> 00:24:19,279
demo we'll show how we're able to commit

644
00:24:19,279 --> 00:24:20,880
malicious code into the repository

645
00:24:20,880 --> 00:24:23,200
without the knowing of the maintainer of

646
00:24:23,200 --> 00:24:24,960
that repository

647
00:24:24,960 --> 00:24:27,200
for that we have we provided is really

648
00:24:27,200 --> 00:24:30,480
simple a bash script that contains

649
00:24:30,480 --> 00:24:32,080
it that receives two parameters the

650
00:24:32,080 --> 00:24:34,240
first one is the the file that we want

651
00:24:34,240 --> 00:24:36,799
to commit is a url from where we

652
00:24:36,799 --> 00:24:38,400
fetching that file and the second

653
00:24:38,400 --> 00:24:40,960
parameter is the path in the in the

654
00:24:40,960 --> 00:24:42,400
directory where we want to commit the

655
00:24:42,400 --> 00:24:43,760
file to

656
00:24:43,760 --> 00:24:46,000
it's a really simple script it fetches

657
00:24:46,000 --> 00:24:47,200
the file

658
00:24:47,200 --> 00:24:48,799
and the does

659
00:24:48,799 --> 00:24:50,960
some several git commands like adding

660
00:24:50,960 --> 00:24:53,360
the file configuring the

661
00:24:53,360 --> 00:24:55,600
the code the committer we can put here

662
00:24:55,600 --> 00:24:57,760
whatever we want we want we can impart

663
00:24:57,760 --> 00:25:00,559
impersonate other committers and then we

664
00:25:00,559 --> 00:25:03,200
commit it and push the code

665
00:25:03,200 --> 00:25:05,360
so on the runner side we just

666
00:25:05,360 --> 00:25:06,559
we will

667
00:25:06,559 --> 00:25:09,360
fetch the script and write it with some

668
00:25:09,360 --> 00:25:12,240
a simple malicious file with simulated

669
00:25:12,240 --> 00:25:15,840
so let's see that in action

670
00:25:17,600 --> 00:25:20,000
you can see as a demo repository with a

671
00:25:20,000 --> 00:25:22,559
directory and a file

672
00:25:22,559 --> 00:25:27,720
then we we are adding a new issue

673
00:25:31,039 --> 00:25:33,440
this issue is previously show contains

674
00:25:33,440 --> 00:25:34,880
several comments

675
00:25:34,880 --> 00:25:38,000
first it fetches the script which uh

676
00:25:38,000 --> 00:25:40,720
which we saw previously it gives the

677
00:25:40,720 --> 00:25:42,480
proper permissions

678
00:25:42,480 --> 00:25:45,520
uh to run on the runner and then he runs

679
00:25:45,520 --> 00:25:48,799
it with the malicious file

680
00:25:48,799 --> 00:25:51,120
some some simple file

681
00:25:51,120 --> 00:25:52,640
uh

682
00:25:52,640 --> 00:25:54,799
so we we're going back to the repository

683
00:25:54,799 --> 00:25:59,279
we can see we have additional file added

684
00:25:59,360 --> 00:26:01,360
to the repository

685
00:26:01,360 --> 00:26:03,520
you also you could also

686
00:26:03,520 --> 00:26:06,159
notice that the latest commit was made

687
00:26:06,159 --> 00:26:08,240
by maintainer name with innocent commit

688
00:26:08,240 --> 00:26:10,000
message we have complete control over

689
00:26:10,000 --> 00:26:12,559
this data

690
00:26:13,120 --> 00:26:15,520
and the fir the third demo will be a bit

691
00:26:15,520 --> 00:26:16,960
more complex we are showing an

692
00:26:16,960 --> 00:26:18,960
additional concept

693
00:26:18,960 --> 00:26:21,520
for a for attack vector

694
00:26:21,520 --> 00:26:23,600
up at two to this point

695
00:26:23,600 --> 00:26:25,360
we show that we are

696
00:26:25,360 --> 00:26:27,279
exfiltrating secrets that were in that

697
00:26:27,279 --> 00:26:29,279
specific workflow

698
00:26:29,279 --> 00:26:31,600
but uh there are additional secrets that

699
00:26:31,600 --> 00:26:33,120
could be defined that weren't used in

700
00:26:33,120 --> 00:26:35,120
that workflow there could be it could be

701
00:26:35,120 --> 00:26:37,360
secrets defined on the repository level

702
00:26:37,360 --> 00:26:39,840
on organization level they could be used

703
00:26:39,840 --> 00:26:42,320
in other workflows not specifically that

704
00:26:42,320 --> 00:26:43,200
one

705
00:26:43,200 --> 00:26:45,039
it maybe we have some method to fetch

706
00:26:45,039 --> 00:26:46,640
them as well

707
00:26:46,640 --> 00:26:49,039
how can we do that we show that we have

708
00:26:49,039 --> 00:26:51,360
the ability to commit to the to the

709
00:26:51,360 --> 00:26:53,520
repository so let's commit a new

710
00:26:53,520 --> 00:26:56,960
workflow that all his always doing will

711
00:26:56,960 --> 00:26:59,360
be to exfiltrate all possible secrets

712
00:26:59,360 --> 00:27:02,000
that he is exposed to

713
00:27:02,000 --> 00:27:05,279
so how we do it we'll define this this

714
00:27:05,279 --> 00:27:06,640
workflow

715
00:27:06,640 --> 00:27:07,679
that

716
00:27:07,679 --> 00:27:09,440
that all it does is

717
00:27:09,440 --> 00:27:12,240
is a taking all the secrets is supposed

718
00:27:12,240 --> 00:27:15,120
to writing it to that secrets file and

719
00:27:15,120 --> 00:27:16,080
then

720
00:27:16,080 --> 00:27:20,640
run c url to our some control server

721
00:27:20,640 --> 00:27:22,640
but we have some minor issue because we

722
00:27:22,640 --> 00:27:24,799
need to trigger this workflow somehow

723
00:27:24,799 --> 00:27:26,399
from within our

724
00:27:26,399 --> 00:27:28,080
runner

725
00:27:28,080 --> 00:27:29,840
github has some

726
00:27:29,840 --> 00:27:31,760
it's not security mitigation but they're

727
00:27:31,760 --> 00:27:33,039
denying the

728
00:27:33,039 --> 00:27:34,960
the activation of workflows within other

729
00:27:34,960 --> 00:27:37,360
workflows it's to deny a circle of

730
00:27:37,360 --> 00:27:38,880
triggering

731
00:27:38,880 --> 00:27:41,200
so we already come with the idea with

732
00:27:41,200 --> 00:27:44,159
we're using workflow run which tells

733
00:27:44,159 --> 00:27:47,039
this workflow to run after another

734
00:27:47,039 --> 00:27:50,159
workflow that called vol will be will be

735
00:27:50,159 --> 00:27:53,200
finished uh running and this is the one

736
00:27:53,200 --> 00:27:55,360
that we injected in the first place

737
00:27:55,360 --> 00:27:58,640
so we are injected as a workflow and

738
00:27:58,640 --> 00:28:00,159
we're committing an additional one and

739
00:28:00,159 --> 00:28:02,320
when this one is over the one we created

740
00:28:02,320 --> 00:28:03,919
will be triggered automatically by

741
00:28:03,919 --> 00:28:06,000
github

742
00:28:06,000 --> 00:28:09,120
so this solves us our issue and also on

743
00:28:09,120 --> 00:28:10,000
the

744
00:28:10,000 --> 00:28:11,760
on the runner side we're just going to

745
00:28:11,760 --> 00:28:14,840
run this simple command invoking github

746
00:28:14,840 --> 00:28:19,039
api this comment contains the

747
00:28:19,039 --> 00:28:20,720
the commit message

748
00:28:20,720 --> 00:28:23,360
the email the content this content will

749
00:28:23,360 --> 00:28:26,559
be this workflow base64 encoded

750
00:28:26,559 --> 00:28:28,000
and we're

751
00:28:28,000 --> 00:28:29,840
telling the path in which we want to

752
00:28:29,840 --> 00:28:33,039
commit this file to

753
00:28:33,360 --> 00:28:36,799
so let's see how this works

754
00:28:40,880 --> 00:28:42,559
first we're set up in the server of

755
00:28:42,559 --> 00:28:45,559
course

756
00:28:48,159 --> 00:28:50,240
now we're running the malicious issue

757
00:28:50,240 --> 00:28:52,159
command it's quite long because it has

758
00:28:52,159 --> 00:28:54,480
has the complete workflow as a base

759
00:28:54,480 --> 00:28:55,840
base64

760
00:28:55,840 --> 00:28:59,039
data and it uh as we said running serial

761
00:28:59,039 --> 00:29:00,559
command with put

762
00:29:00,559 --> 00:29:03,120
i mean with using the github token which

763
00:29:03,120 --> 00:29:05,600
we as an attacker previously fetched

764
00:29:05,600 --> 00:29:08,640
to to invoke github api

765
00:29:08,640 --> 00:29:11,840
we using the contents api of github and

766
00:29:11,840 --> 00:29:14,640
adding the path of the file together

767
00:29:14,640 --> 00:29:16,960
with a commit message committer the

768
00:29:16,960 --> 00:29:18,240
email

769
00:29:18,240 --> 00:29:18,960
and

770
00:29:18,960 --> 00:29:21,520
everything

771
00:29:21,520 --> 00:29:23,840
so let's see what we have received in

772
00:29:23,840 --> 00:29:27,520
our server we received the the bot token

773
00:29:27,520 --> 00:29:29,360
which we previously

774
00:29:29,360 --> 00:29:32,720
get in our first demo from that

775
00:29:32,720 --> 00:29:34,720
for the second run command we received a

776
00:29:34,720 --> 00:29:37,120
github token for that specific

777
00:29:37,120 --> 00:29:38,640
uh repository

778
00:29:38,640 --> 00:29:41,120
for the specific run and we also got the

779
00:29:41,120 --> 00:29:42,480
two additional

780
00:29:42,480 --> 00:29:44,799
secrets that could be either defined in

781
00:29:44,799 --> 00:29:46,720
a repository level used for other

782
00:29:46,720 --> 00:29:51,360
workflows or in organization level and

783
00:29:51,360 --> 00:29:53,039
this is additional tokens called

784
00:29:53,039 --> 00:29:55,760
additional sensitive assets could be aws

785
00:29:55,760 --> 00:29:58,960
tokens could be azure tokens and etc

786
00:29:58,960 --> 00:30:01,600
this is pretty cool

787
00:30:01,600 --> 00:30:03,120
so

788
00:30:03,120 --> 00:30:05,360
now we'll show possible attacks and

789
00:30:05,360 --> 00:30:06,559
exploitation let's see how can we

790
00:30:06,559 --> 00:30:08,559
mitigate it

791
00:30:08,559 --> 00:30:11,440
the first mitigation is to avoid avoid

792
00:30:11,440 --> 00:30:13,760
any run steps possible

793
00:30:13,760 --> 00:30:16,399
for example instead of using this

794
00:30:16,399 --> 00:30:19,840
command that is susceptible to injection

795
00:30:19,840 --> 00:30:21,120
attack

796
00:30:21,120 --> 00:30:22,960
we could use an external action it's

797
00:30:22,960 --> 00:30:24,399
called labeler

798
00:30:24,399 --> 00:30:27,279
that does exactly the same as this

799
00:30:27,279 --> 00:30:28,399
command

800
00:30:28,399 --> 00:30:30,880
it also received the title but it's not

801
00:30:30,880 --> 00:30:32,960
susceptible to injection

802
00:30:32,960 --> 00:30:35,279
it's not always possible but whenever

803
00:30:35,279 --> 00:30:37,440
possible it's really recommended to do

804
00:30:37,440 --> 00:30:39,600
that

805
00:30:40,000 --> 00:30:42,399
the second method to mitigate this is to

806
00:30:42,399 --> 00:30:44,880
sanitizing the input which is probably

807
00:30:44,880 --> 00:30:46,559
the most effective method to mitigate

808
00:30:46,559 --> 00:30:49,760
this specific attack is instead of

809
00:30:49,760 --> 00:30:51,520
using the curly brackets

810
00:30:51,520 --> 00:30:52,960
inside the run

811
00:30:52,960 --> 00:30:55,279
you just define them outside in the

812
00:30:55,279 --> 00:30:57,200
environment variable and use that

813
00:30:57,200 --> 00:30:58,960
variable inside the

814
00:30:58,960 --> 00:31:01,760
inside the command

815
00:31:01,919 --> 00:31:02,960
this is

816
00:31:02,960 --> 00:31:06,320
this the this mitigation exactly as wire

817
00:31:06,320 --> 00:31:08,960
did as elias showed previously is very

818
00:31:08,960 --> 00:31:10,399
effective because

819
00:31:10,399 --> 00:31:13,039
we have uh the stronghold just simple

820
00:31:13,039 --> 00:31:14,399
best script

821
00:31:14,399 --> 00:31:17,679
which does this and it is sanitation uh

822
00:31:17,679 --> 00:31:20,080
for us

823
00:31:20,240 --> 00:31:23,679
another method for a post exploitation

824
00:31:23,679 --> 00:31:25,440
mitigation is to limit the token

825
00:31:25,440 --> 00:31:28,000
permissions we can add inside the

826
00:31:28,000 --> 00:31:30,240
workflow this permission tag that will

827
00:31:30,240 --> 00:31:33,200
define the maximum level of permissions

828
00:31:33,200 --> 00:31:36,640
that the github token will receive

829
00:31:37,039 --> 00:31:38,080
so

830
00:31:38,080 --> 00:31:42,720
even if will the attacker manage to uh

831
00:31:42,720 --> 00:31:45,440
to exploit and run code on our build you

832
00:31:45,440 --> 00:31:47,279
won't be able to do whatever you want

833
00:31:47,279 --> 00:31:49,760
because you will he will be limited for

834
00:31:49,760 --> 00:31:52,000
example in our case we have a

835
00:31:52,000 --> 00:31:53,919
we need only read permissions for

836
00:31:53,919 --> 00:31:56,399
contents we need to clone the code

837
00:31:56,399 --> 00:31:58,320
and we need right permission to issue

838
00:31:58,320 --> 00:31:59,919
because we need to update a label so

839
00:31:59,919 --> 00:32:01,039
this will

840
00:32:01,039 --> 00:32:05,600
be sufficient for our sample workflow

841
00:32:06,559 --> 00:32:09,440
another method that's uh effective for

842
00:32:09,440 --> 00:32:10,720
the third

843
00:32:10,720 --> 00:32:12,799
demo that we showed is to limit secret

844
00:32:12,799 --> 00:32:16,240
secret exposure every secret define

845
00:32:16,240 --> 00:32:18,080
secret defined organization level could

846
00:32:18,080 --> 00:32:19,760
be defined

847
00:32:19,760 --> 00:32:22,320
for what repository he could be exposed

848
00:32:22,320 --> 00:32:25,360
to so even if an attacker would be able

849
00:32:25,360 --> 00:32:27,039
to

850
00:32:27,039 --> 00:32:29,360
to expose it to ex filtered every second

851
00:32:29,360 --> 00:32:32,799
as possible you won't be able uh

852
00:32:32,799 --> 00:32:36,559
if this mitigation will be applied

853
00:32:36,720 --> 00:32:39,519
um and i another minor mitigation will

854
00:32:39,519 --> 00:32:41,200
be to require approval for outside

855
00:32:41,200 --> 00:32:42,880
collaborative collaborators it's

856
00:32:42,880 --> 00:32:45,600
additional mitigation by github

857
00:32:45,600 --> 00:32:47,440
the default parameter is to require

858
00:32:47,440 --> 00:32:50,399
approval for first-time contributors

859
00:32:50,399 --> 00:32:52,159
it's mainly applies for public

860
00:32:52,159 --> 00:32:55,519
repositories each if a contributor

861
00:32:55,519 --> 00:32:57,360
haven't committed

862
00:32:57,360 --> 00:32:59,840
code yet to the repository he should be

863
00:32:59,840 --> 00:33:02,480
allowed the manual by maintainers to run

864
00:33:02,480 --> 00:33:05,039
his code

865
00:33:05,360 --> 00:33:07,200
and the last one will be to use the

866
00:33:07,200 --> 00:33:11,279
environment in branch protections it's a

867
00:33:11,279 --> 00:33:12,880
second

868
00:33:12,880 --> 00:33:14,080
yeah

869
00:33:14,080 --> 00:33:14,560
it's a

870
00:33:14,560 --> 00:33:16,559
[Music]

871
00:33:16,559 --> 00:33:20,559
rather new mitigation by github that the

872
00:33:20,559 --> 00:33:22,159
only enterprises

873
00:33:22,159 --> 00:33:25,200
github enterprise allows it that

874
00:33:25,200 --> 00:33:27,120
gives you the ability to define secrets

875
00:33:27,120 --> 00:33:30,399
on environment level

876
00:33:31,760 --> 00:33:32,480
so

877
00:33:32,480 --> 00:33:35,440
what will be the takeaway from this talk

878
00:33:35,440 --> 00:33:36,799
first of all

879
00:33:36,799 --> 00:33:38,559
um

880
00:33:38,559 --> 00:33:40,640
even when github does

881
00:33:40,640 --> 00:33:42,480
most of the security

882
00:33:42,480 --> 00:33:45,360
for you for example it gives you a

883
00:33:45,360 --> 00:33:47,760
github hosted runners it gives you

884
00:33:47,760 --> 00:33:49,600
ephemeral environments it gives you vm

885
00:33:49,600 --> 00:33:51,679
based isolation etc

886
00:33:51,679 --> 00:33:53,519
we are wanted to to understand that your

887
00:33:53,519 --> 00:33:54,720
build

888
00:33:54,720 --> 00:33:56,960
pipeline still could be compromised and

889
00:33:56,960 --> 00:33:59,200
you should you should know that

890
00:33:59,200 --> 00:34:01,360
the second one is as we've seen in

891
00:34:01,360 --> 00:34:03,279
github best practices

892
00:34:03,279 --> 00:34:04,480
it does

893
00:34:04,480 --> 00:34:06,559
most of it's that some of the the it

894
00:34:06,559 --> 00:34:09,359
delegates some of the security to the

895
00:34:09,359 --> 00:34:10,719
developer

896
00:34:10,719 --> 00:34:12,320
i myself a developer and i know the

897
00:34:12,320 --> 00:34:14,639
developers do make mistakes so this

898
00:34:14,639 --> 00:34:17,119
should be handled carefully

899
00:34:17,119 --> 00:34:19,359
the third one is the the consequences

900
00:34:19,359 --> 00:34:20,879
that we've seen in the demo of such

901
00:34:20,879 --> 00:34:22,560
build co promise could be

902
00:34:22,560 --> 00:34:24,879
a really disastrous could be it could

903
00:34:24,879 --> 00:34:27,359
cause potential supply chain attack for

904
00:34:27,359 --> 00:34:29,280
that vendor it could attack many many

905
00:34:29,280 --> 00:34:30,879
clients

906
00:34:30,879 --> 00:34:32,960
and the the last one is that securing a

907
00:34:32,960 --> 00:34:34,960
pipeline isn't a matter of faith

908
00:34:34,960 --> 00:34:37,119
in we'll show that github as an example

909
00:34:37,119 --> 00:34:40,320
it supplies many security mitigations

910
00:34:40,320 --> 00:34:41,599
that

911
00:34:41,599 --> 00:34:43,199
all could be applied

912
00:34:43,199 --> 00:34:46,239
and we wrongly suggest you to use this

913
00:34:46,239 --> 00:34:48,159
as well

914
00:34:48,159 --> 00:34:49,199
and

915
00:34:49,199 --> 00:34:50,159
that's it

916
00:34:50,159 --> 00:34:51,839
thank you very much you are welcome to

917
00:34:51,839 --> 00:34:53,119
check the

918
00:34:53,119 --> 00:34:56,079
full technical blog in the cycled blog

919
00:34:56,079 --> 00:34:58,000
and thank you very much besides for

920
00:34:58,000 --> 00:34:59,440
hosting us here a really great

921
00:34:59,440 --> 00:35:01,520
conference

922
00:35:01,520 --> 00:35:02,640
that's it

923
00:35:02,640 --> 00:35:05,279
good question

924
00:35:10,160 --> 00:35:13,839
thank you alex and elia do we have any

925
00:35:13,839 --> 00:35:17,839
uh questions at this time

926
00:35:17,920 --> 00:35:19,680
yeah yeah

927
00:35:19,680 --> 00:35:22,399
okay here we go

928
00:35:23,040 --> 00:35:25,520
hey so yeah just one thing came to my

929
00:35:25,520 --> 00:35:27,680
mind that what what options do you have

930
00:35:27,680 --> 00:35:30,079
to check for attacks happened in the

931
00:35:30,079 --> 00:35:33,200
past like does github do any logging or

932
00:35:33,200 --> 00:35:34,720
you just search for

933
00:35:34,720 --> 00:35:36,800
like tickets with very strange names or

934
00:35:36,800 --> 00:35:38,720
like whatever do you asking how to check

935
00:35:38,720 --> 00:35:41,760
if you were attacked yeah kinda

936
00:35:41,760 --> 00:35:42,640
yeah

937
00:35:42,640 --> 00:35:44,720
unfortunately github doesn't supports

938
00:35:44,720 --> 00:35:47,760
many editing it has some but it's not

939
00:35:47,760 --> 00:35:50,720
very verbose and

940
00:35:51,359 --> 00:35:54,000
this entire like ecosystem of ci cd

941
00:35:54,000 --> 00:35:56,720
security it's really it

942
00:35:56,720 --> 00:35:59,520
hasn't developed yet like other standard

943
00:35:59,520 --> 00:36:01,599
security

944
00:36:01,599 --> 00:36:02,960
industry

945
00:36:02,960 --> 00:36:05,200
so the you know there isn't much of you

946
00:36:05,200 --> 00:36:06,240
to to

947
00:36:06,240 --> 00:36:08,880
to know that but that's why we're what

948
00:36:08,880 --> 00:36:11,359
we suggest like to to mitigate it from

949
00:36:11,359 --> 00:36:12,960
the start not to allow it in the first

950
00:36:12,960 --> 00:36:14,960
place and and of course for big

951
00:36:14,960 --> 00:36:16,880
organizations this is exactly what our

952
00:36:16,880 --> 00:36:19,200
company does it monitors automatically

953
00:36:19,200 --> 00:36:21,200
your commits your pull request

954
00:36:21,200 --> 00:36:22,160
looks for

955
00:36:22,160 --> 00:36:24,320
vulnerabilities such as this one and

956
00:36:24,320 --> 00:36:28,720
alerts the maintainers automatically

957
00:36:31,839 --> 00:36:35,520
anybody else at this time

958
00:36:35,520 --> 00:36:39,000
okay one more

959
00:36:42,480 --> 00:36:45,280
hello uh so my question is why the hell

960
00:36:45,280 --> 00:36:48,079
is github not sanitizing these uh like

961
00:36:48,079 --> 00:36:49,839
input fields like

962
00:36:49,839 --> 00:36:51,520
it should be shouldn't they

963
00:36:51,520 --> 00:36:53,599
yeah this is a terrible question yeah i

964
00:36:53,599 --> 00:36:55,119
was waiting for that

965
00:36:55,119 --> 00:36:55,550
um

966
00:36:55,550 --> 00:36:57,760
[Music]

967
00:36:57,760 --> 00:37:00,079
no i had this talking several times

968
00:37:00,079 --> 00:37:01,599
they're all asking it

969
00:37:01,599 --> 00:37:03,599
because they actually they can't

970
00:37:03,599 --> 00:37:05,599
i mean they're allowing you it's code

971
00:37:05,599 --> 00:37:07,359
execution as a service

972
00:37:07,359 --> 00:37:09,520
they can do that it's not really

973
00:37:09,520 --> 00:37:11,200
possible they're allowing you to run

974
00:37:11,200 --> 00:37:15,118
bash script they can't do that for you

975
00:37:15,839 --> 00:37:18,160
thank you but they can do other various

976
00:37:18,160 --> 00:37:19,359
stuff like

977
00:37:19,359 --> 00:37:21,599
warning you like telling me something

978
00:37:21,599 --> 00:37:23,119
alerting you or something like and they

979
00:37:23,119 --> 00:37:26,640
do don't do that unfortunately

980
00:37:26,640 --> 00:37:30,000
just as a note uh it's it started like

981
00:37:30,000 --> 00:37:33,520
very raw and people were starting to um

982
00:37:33,520 --> 00:37:35,280
approve pull requests from inside

983
00:37:35,280 --> 00:37:37,760
workflows so they added configuration

984
00:37:37,760 --> 00:37:40,320
whether you can or can't approve uh pull

985
00:37:40,320 --> 00:37:42,880
custom workflows and then the open

986
00:37:42,880 --> 00:37:45,839
source tools where people just were

987
00:37:45,839 --> 00:37:47,440
running

988
00:37:47,440 --> 00:37:49,680
the for pull request just running and

989
00:37:49,680 --> 00:37:51,520
using the token and then they understand

990
00:37:51,520 --> 00:37:52,960
there's a problem and added this

991
00:37:52,960 --> 00:37:55,520
mitigation to for the maintainer to

992
00:37:55,520 --> 00:37:57,760
manually approve one and then to

993
00:37:57,760 --> 00:37:59,920
manually prove everyone so

994
00:37:59,920 --> 00:38:02,000
as you can see they learn

995
00:38:02,000 --> 00:38:04,880
they they step up their security posture

996
00:38:04,880 --> 00:38:07,200
on the github actions but yeah they

997
00:38:07,200 --> 00:38:10,000
can't do it like

998
00:38:13,920 --> 00:38:17,560
anybody else

999
00:38:18,320 --> 00:38:19,359
well

1000
00:38:19,359 --> 00:38:21,200
in our case alex

1001
00:38:21,200 --> 00:38:22,790
thank you very much

1002
00:38:22,790 --> 00:38:32,320
[Applause]

1003
00:38:32,320 --> 00:38:34,400
you

