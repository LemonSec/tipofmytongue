1
00:00:01,439 --> 00:00:02,560
thank you

2
00:00:02,560 --> 00:00:05,359
so uh my name is philadelphia i

3
00:00:05,359 --> 00:00:07,919
graduated uh as an electrical engineer

4
00:00:07,919 --> 00:00:09,840
almost 20 years ago

5
00:00:09,840 --> 00:00:11,599
since then i have been working in i.t

6
00:00:11,599 --> 00:00:14,160
security so i'm not a typical electrical

7
00:00:14,160 --> 00:00:16,880
engineer but but an id guy i started my

8
00:00:16,880 --> 00:00:19,520
career as a software developer now i am

9
00:00:19,520 --> 00:00:21,520
a security evangelist as you can see on

10
00:00:21,520 --> 00:00:24,960
the slide i work at bolasis

11
00:00:24,960 --> 00:00:26,800
which is one of the few hungarianity

12
00:00:26,800 --> 00:00:28,720
security vendors

13
00:00:28,720 --> 00:00:30,640
earlier it was called balabit it was the

14
00:00:30,640 --> 00:00:33,760
vendor of the syslog ng uh now we are

15
00:00:33,760 --> 00:00:36,399
the vendor of the zorp obligation level

16
00:00:36,399 --> 00:00:38,719
firewall which has a gpr version open

17
00:00:38,719 --> 00:00:40,879
source one as you may know

18
00:00:40,879 --> 00:00:43,200
uh this story has started with my pet

19
00:00:43,200 --> 00:00:44,480
project

20
00:00:44,480 --> 00:00:46,320
which is a cryptographic setting

21
00:00:46,320 --> 00:00:47,680
analyzer

22
00:00:47,680 --> 00:00:50,320
called cryptolyzer the functionality is

23
00:00:50,320 --> 00:00:53,360
same as in the case of the test the test

24
00:00:53,360 --> 00:00:56,840
age ssr scan or

25
00:00:56,840 --> 00:00:59,680
sslice during the implementation i

26
00:00:59,680 --> 00:01:01,039
realized that

27
00:01:01,039 --> 00:01:03,440
i have to implement the cryptographic

28
00:01:03,440 --> 00:01:04,640
part

29
00:01:04,640 --> 00:01:07,040
of the cryptographic hand check

30
00:01:07,040 --> 00:01:10,560
to get some information from the server

31
00:01:10,560 --> 00:01:14,400
but i wanted to buy passwords somehow uh

32
00:01:14,400 --> 00:01:16,479
the cryptographic part because i am a

33
00:01:16,479 --> 00:01:18,640
lazy engineer and i don't want to care

34
00:01:18,640 --> 00:01:20,799
about the cryptography

35
00:01:20,799 --> 00:01:22,000
so

36
00:01:22,000 --> 00:01:24,159
i also realized that it is possible to

37
00:01:24,159 --> 00:01:25,360
send

38
00:01:25,360 --> 00:01:26,799
seemingly correct messages to the

39
00:01:26,799 --> 00:01:29,680
servers which are accepted by them and

40
00:01:29,680 --> 00:01:31,520
answered by them

41
00:01:31,520 --> 00:01:33,360
the question arises how

42
00:01:33,360 --> 00:01:34,960
this

43
00:01:34,960 --> 00:01:38,159
led to your denial of service attack

44
00:01:38,159 --> 00:01:40,400
the answer is relatively simple the

45
00:01:40,400 --> 00:01:42,560
messages i mentioned

46
00:01:42,560 --> 00:01:45,520
are simple short and preferably capable

47
00:01:45,520 --> 00:01:48,079
most of the times so they are suitable

48
00:01:48,079 --> 00:01:49,280
to

49
00:01:49,280 --> 00:01:51,600
cause significant load

50
00:01:51,600 --> 00:01:54,079
on the server side because the client

51
00:01:54,079 --> 00:01:55,360
should not need to

52
00:01:55,360 --> 00:01:57,759
calculate the messages connection by

53
00:01:57,759 --> 00:01:58,799
connection

54
00:01:58,799 --> 00:02:01,240
they it can break up

55
00:02:01,240 --> 00:02:04,399
pre-computed and it can send repeatedly

56
00:02:04,399 --> 00:02:06,159
to the servers

57
00:02:06,159 --> 00:02:07,680
in this presentation i would like to

58
00:02:07,680 --> 00:02:11,200
demonstrate how seriously um

59
00:02:11,200 --> 00:02:13,760
effects uh the cryptographic library a

60
00:02:13,760 --> 00:02:17,120
denial of service attack like this

61
00:02:17,120 --> 00:02:19,200
first of all let's see what is key

62
00:02:19,200 --> 00:02:20,840
exchange

63
00:02:20,840 --> 00:02:25,440
which why um what kind of exchange exist

64
00:02:25,440 --> 00:02:27,920
and why they are so important and why

65
00:02:27,920 --> 00:02:29,760
they are vulnerable to a denial of

66
00:02:29,760 --> 00:02:32,080
service attack

67
00:02:32,080 --> 00:02:34,879
all cryptographic protocols have a

68
00:02:34,879 --> 00:02:37,200
step during the cryptographic hatchet

69
00:02:37,200 --> 00:02:38,800
called key exchange

70
00:02:38,800 --> 00:02:40,080
what is it

71
00:02:40,080 --> 00:02:42,640
uh if parties tend to communicate with

72
00:02:42,640 --> 00:02:44,879
each other in a secure manner they need

73
00:02:44,879 --> 00:02:46,959
a key a shared secret which is

74
00:02:46,959 --> 00:02:49,519
practically a some kind of random data

75
00:02:49,519 --> 00:02:51,519
which will be used during the

76
00:02:51,519 --> 00:02:53,680
communication to encrypt and decrypt

77
00:02:53,680 --> 00:02:56,000
messages in a symmetric way

78
00:02:56,000 --> 00:02:56,879
these

79
00:02:56,879 --> 00:02:58,239
shared secret

80
00:02:58,239 --> 00:03:01,040
have to be exchanged without risking

81
00:03:01,040 --> 00:03:03,280
that the third party compromises

82
00:03:03,280 --> 00:03:05,440
this is the key exchange part

83
00:03:05,440 --> 00:03:07,120
there are some key exchange algorithms

84
00:03:07,120 --> 00:03:09,599
which can do that work

85
00:03:09,599 --> 00:03:10,720
why

86
00:03:10,720 --> 00:03:13,120
these keys change algorithms are

87
00:03:13,120 --> 00:03:17,040
expletive to a dnial service attack

88
00:03:17,040 --> 00:03:18,959
the reason is the fact that

89
00:03:18,959 --> 00:03:22,319
they they are cpu intensive depending on

90
00:03:22,319 --> 00:03:25,120
the specific key exchange algorithm

91
00:03:25,120 --> 00:03:28,239
they are also unauthenticated meaning

92
00:03:28,239 --> 00:03:29,040
that

93
00:03:29,040 --> 00:03:31,120
in the cryptographic handshake

94
00:03:31,120 --> 00:03:32,799
the key exchange is before the

95
00:03:32,799 --> 00:03:35,159
authentication so an

96
00:03:35,159 --> 00:03:37,680
unauthenticated client can force a

97
00:03:37,680 --> 00:03:39,840
server to do something to do cpu

98
00:03:39,840 --> 00:03:41,680
intensive operations

99
00:03:41,680 --> 00:03:42,879
and the third thing is that the

100
00:03:42,879 --> 00:03:45,120
messenger are most of the times

101
00:03:45,120 --> 00:03:47,519
pre-computable so

102
00:03:47,519 --> 00:03:49,680
a client can pre-compute all the

103
00:03:49,680 --> 00:03:51,920
messages need to be sent to the server

104
00:03:51,920 --> 00:03:54,879
to to force them to do the cpu intensive

105
00:03:54,879 --> 00:03:56,799
part of the handshake

106
00:03:56,799 --> 00:03:59,200
what kind of algorithms exist

107
00:03:59,200 --> 00:04:00,959
first of all i have to mention the

108
00:04:00,959 --> 00:04:03,599
elliptic curve version of the dpr monkey

109
00:04:03,599 --> 00:04:04,799
exchange

110
00:04:04,799 --> 00:04:07,280
which is considered the most secure and

111
00:04:07,280 --> 00:04:09,760
most effective key exchange nowadays it

112
00:04:09,760 --> 00:04:11,920
is still possible to use it to perform a

113
00:04:11,920 --> 00:04:15,519
denial of service attack but it requires

114
00:04:15,519 --> 00:04:20,959
significant throughput which does not um

115
00:04:21,120 --> 00:04:23,280
so it doesn't burst the coast

116
00:04:23,280 --> 00:04:26,320
the second uh mentionable key exchange

117
00:04:26,320 --> 00:04:28,880
other it means the rsa which is an

118
00:04:28,880 --> 00:04:31,600
unbalanced key exchange algorithm

119
00:04:31,600 --> 00:04:34,880
meaning that it requires much more

120
00:04:34,880 --> 00:04:38,560
cpu computation on the client side uh

121
00:04:38,560 --> 00:04:40,160
sorry on the server side than on the

122
00:04:40,160 --> 00:04:43,440
client side it makes it ideal to perform

123
00:04:43,440 --> 00:04:45,520
a denial of service attack because the

124
00:04:45,520 --> 00:04:48,000
client needs to

125
00:04:48,000 --> 00:04:49,520
perform

126
00:04:49,520 --> 00:04:52,639
less cpu computation than the server

127
00:04:52,639 --> 00:04:53,440
but

128
00:04:53,440 --> 00:04:55,759
it have to mention that the rsa key

129
00:04:55,759 --> 00:04:58,400
exchange algorithm is

130
00:04:58,400 --> 00:05:00,080
more effective

131
00:05:00,080 --> 00:05:02,800
and less cpu intensive than the original

132
00:05:02,800 --> 00:05:05,759
dv hellman key exchange algorithm

133
00:05:05,759 --> 00:05:06,560
so

134
00:05:06,560 --> 00:05:09,199
the last one is the original dpl monkey

135
00:05:09,199 --> 00:05:12,320
exchange which requires much more cbo

136
00:05:12,320 --> 00:05:15,360
computation uh than the all the earlier

137
00:05:15,360 --> 00:05:17,840
mentioned key exchange algorithms

138
00:05:17,840 --> 00:05:19,919
this algorithm is balanced

139
00:05:19,919 --> 00:05:21,919
meaning that it requires the same amount

140
00:05:21,919 --> 00:05:23,680
of cpu computation on the client and the

141
00:05:23,680 --> 00:05:25,759
server side

142
00:05:25,759 --> 00:05:27,440
it would make

143
00:05:27,440 --> 00:05:30,160
it ineffective to perform a denial of

144
00:05:30,160 --> 00:05:32,560
service attack except

145
00:05:32,560 --> 00:05:35,280
you can decrease somehow

146
00:05:35,280 --> 00:05:38,000
the necessary cpu computation on the

147
00:05:38,000 --> 00:05:40,560
client side

148
00:05:40,560 --> 00:05:43,280
how how it can be done

149
00:05:43,280 --> 00:05:46,560
to to to understand how we can decrease

150
00:05:46,560 --> 00:05:48,720
the cpu computation requirement on the

151
00:05:48,720 --> 00:05:50,320
client side

152
00:05:50,320 --> 00:05:53,919
i have to explain the dpr among key

153
00:05:53,919 --> 00:05:56,880
without going into the details

154
00:05:56,880 --> 00:05:58,800
uh the algorithm is balanced as i

155
00:05:58,800 --> 00:06:01,039
mentioned so the parties do the same

156
00:06:01,039 --> 00:06:03,520
operations but on different numbers as

157
00:06:03,520 --> 00:06:05,280
you can see on the slide

158
00:06:05,280 --> 00:06:06,720
the only

159
00:06:06,720 --> 00:06:09,600
cpu intensive operation is the modular

160
00:06:09,600 --> 00:06:11,199
exponentiation

161
00:06:11,199 --> 00:06:14,800
both parties do that twice

162
00:06:14,800 --> 00:06:18,080
they when they compute the public key

163
00:06:18,080 --> 00:06:19,919
their own public key this is the second

164
00:06:19,919 --> 00:06:22,000
step and when they compute the shared

165
00:06:22,000 --> 00:06:23,680
secret

166
00:06:23,680 --> 00:06:25,440
this is the fifth step

167
00:06:25,440 --> 00:06:28,160
in this way the computational capacity

168
00:06:28,160 --> 00:06:30,400
requirement is the same

169
00:06:30,400 --> 00:06:32,800
on the client and the server side which

170
00:06:32,800 --> 00:06:34,880
is not ideal if you want to perform the

171
00:06:34,880 --> 00:06:37,919
eye of service attack

172
00:06:39,360 --> 00:06:40,240
but

173
00:06:40,240 --> 00:06:42,880
in an ideal situation and attacker can

174
00:06:42,880 --> 00:06:45,360
enforce the victim to do

175
00:06:45,360 --> 00:06:48,880
a significant amount of cpu computation

176
00:06:48,880 --> 00:06:51,440
without making the same on the client

177
00:06:51,440 --> 00:06:54,479
side so the other car needs to cheat

178
00:06:54,479 --> 00:06:56,960
somehow this cryptographic protocol to

179
00:06:56,960 --> 00:06:58,720
do that

180
00:06:58,720 --> 00:07:02,240
it is possible because an other care

181
00:07:02,240 --> 00:07:04,160
does not really want to

182
00:07:04,160 --> 00:07:07,280
do the key exchange it just wants to to

183
00:07:07,280 --> 00:07:09,360
to force the server to do the cpu

184
00:07:09,360 --> 00:07:12,800
intensive part of the key exchange

185
00:07:12,800 --> 00:07:16,479
so it can send whatever number to the

186
00:07:16,479 --> 00:07:19,440
server which is accepted by the server

187
00:07:19,440 --> 00:07:20,800
that's the trick

188
00:07:20,800 --> 00:07:23,360
first of all the autocad should analyze

189
00:07:23,360 --> 00:07:25,680
the server to get the diffie-hellman

190
00:07:25,680 --> 00:07:27,919
parameters of the server

191
00:07:27,919 --> 00:07:30,319
especially the prime number why is it

192
00:07:30,319 --> 00:07:31,680
important

193
00:07:31,680 --> 00:07:33,280
because the other cash should pick a

194
00:07:33,280 --> 00:07:36,000
number a which is less than d prime

195
00:07:36,000 --> 00:07:38,800
because it is guaranteed that the

196
00:07:38,800 --> 00:07:41,199
result of the modular exponentiation the

197
00:07:41,199 --> 00:07:44,000
cpu intensified is less than the prime

198
00:07:44,000 --> 00:07:46,800
so you have to pick a number a

199
00:07:46,800 --> 00:07:49,039
after that the attacker can send this a

200
00:07:49,039 --> 00:07:51,440
number to the server and the server will

201
00:07:51,440 --> 00:07:53,840
accept it because it cannot distinguish

202
00:07:53,840 --> 00:07:56,080
it from a computed number it is just a

203
00:07:56,080 --> 00:07:58,879
cheated number it's just just a randomly

204
00:07:58,879 --> 00:08:01,280
picked one but it is the server cannot

205
00:08:01,280 --> 00:08:04,240
distinguish it from a computed number

206
00:08:04,240 --> 00:08:08,560
so uh it will uh do the cpu intensive

207
00:08:08,560 --> 00:08:10,639
part on this side

208
00:08:10,639 --> 00:08:11,919
um

209
00:08:11,919 --> 00:08:14,479
after that the autocad should receive

210
00:08:14,479 --> 00:08:17,039
the message from the server to be sure

211
00:08:17,039 --> 00:08:20,080
that the server has already done the cpu

212
00:08:20,080 --> 00:08:23,599
intensive computation

213
00:08:24,560 --> 00:08:26,800
with this mechanism a malicious client

214
00:08:26,800 --> 00:08:28,800
can force the server to do the cpu

215
00:08:28,800 --> 00:08:32,240
intensive computation on each side

216
00:08:32,240 --> 00:08:34,880
without doing the same thing uh on the

217
00:08:34,880 --> 00:08:37,200
other care side this is the day heat

218
00:08:37,200 --> 00:08:38,159
attack

219
00:08:38,159 --> 00:08:40,640
which is named under um named after the

220
00:08:40,640 --> 00:08:44,159
fact that it can heat the cpu using or

221
00:08:44,159 --> 00:08:48,320
forcing the diffie-hellman key exchange

222
00:08:48,320 --> 00:08:53,519
data got cva number uh 2002 2001.

223
00:08:53,519 --> 00:08:56,160
the first part of the cv a number is a

224
00:08:56,160 --> 00:08:57,279
date

225
00:08:57,279 --> 00:08:58,160
um

226
00:08:58,160 --> 00:09:01,839
actually it is 2002. uh this is a year

227
00:09:01,839 --> 00:09:04,399
number when the vulnerability was

228
00:09:04,399 --> 00:09:06,480
exploited but not the

229
00:09:06,480 --> 00:09:08,080
the year when the vulnerability was

230
00:09:08,080 --> 00:09:10,240
exploited for the first time but the

231
00:09:10,240 --> 00:09:13,040
year when the vulnerability was first uh

232
00:09:13,040 --> 00:09:14,480
published

233
00:09:14,480 --> 00:09:16,640
usually this year number is the same in

234
00:09:16,640 --> 00:09:19,360
most of the cases but in this case

235
00:09:19,360 --> 00:09:20,959
there was a publication about the

236
00:09:20,959 --> 00:09:24,640
theoretical vulnerability in 2002

237
00:09:24,640 --> 00:09:27,440
anyway i discovered that vulnerability

238
00:09:27,440 --> 00:09:29,040
independently from

239
00:09:29,040 --> 00:09:30,640
that publication

240
00:09:30,640 --> 00:09:32,800
there is a scoring mechanism to

241
00:09:32,800 --> 00:09:35,120
prioritize the vulnerabilities

242
00:09:35,120 --> 00:09:37,279
called commonwealth updated scoring

243
00:09:37,279 --> 00:09:39,279
system or cbss

244
00:09:39,279 --> 00:09:41,360
the day heat attack get

245
00:09:41,360 --> 00:09:44,880
7.5 as a score which is a relatively

246
00:09:44,880 --> 00:09:45,680
high

247
00:09:45,680 --> 00:09:47,920
score number but the question arises why

248
00:09:47,920 --> 00:09:49,600
is it higher

249
00:09:49,600 --> 00:09:52,160
the other complexity is low

250
00:09:52,160 --> 00:09:54,800
it's very simple to force

251
00:09:54,800 --> 00:09:56,880
the server to do the cpu intensive

252
00:09:56,880 --> 00:10:00,080
operation and the attack requires no

253
00:10:00,080 --> 00:10:02,079
privilege at all

254
00:10:02,079 --> 00:10:05,279
and requires no user interaction

255
00:10:05,279 --> 00:10:06,160
but

256
00:10:06,160 --> 00:10:08,320
it does not affect the confidentiality

257
00:10:08,320 --> 00:10:11,760
and the integrity so you cannot break

258
00:10:11,760 --> 00:10:14,959
the encryption algorithm by this way

259
00:10:14,959 --> 00:10:17,600
and it does not affect the scope so you

260
00:10:17,600 --> 00:10:20,320
you cannot uh do a privilege just

261
00:10:20,320 --> 00:10:22,480
collision using this attack it's a

262
00:10:22,480 --> 00:10:25,040
typical uh denial of service attack and

263
00:10:25,040 --> 00:10:27,519
practically uh deny of service cannot

264
00:10:27,519 --> 00:10:29,920
get a higher number than

265
00:10:29,920 --> 00:10:32,079
7.5

266
00:10:32,079 --> 00:10:33,120
anyway

267
00:10:33,120 --> 00:10:36,720
cbs code is a you need to measure

268
00:10:36,720 --> 00:10:39,120
the uh vulnerabilities impact on a

269
00:10:39,120 --> 00:10:42,320
software or on a cryptography protocol

270
00:10:42,320 --> 00:10:43,920
but it cannot measure

271
00:10:43,920 --> 00:10:46,640
the the the impact and the real world

272
00:10:46,640 --> 00:10:49,360
because it highly depends on

273
00:10:49,360 --> 00:10:51,200
how widespread is the vulnerable

274
00:10:51,200 --> 00:10:53,200
software or the burna labor cryptography

275
00:10:53,200 --> 00:10:54,240
protocol

276
00:10:54,240 --> 00:10:57,920
so i decided uh to do a research to find

277
00:10:57,920 --> 00:10:59,920
out the prevalence of the dpm and key

278
00:10:59,920 --> 00:11:02,720
exchange in the case of web servers

279
00:11:02,720 --> 00:11:04,320
first of all i have to mention that the

280
00:11:04,320 --> 00:11:05,920
d3 among key exchange is completely

281
00:11:05,920 --> 00:11:07,279
secure

282
00:11:07,279 --> 00:11:09,120
the openness offers it

283
00:11:09,120 --> 00:11:10,800
even in the highest

284
00:11:10,800 --> 00:11:14,320
security level and mozilla suggested by

285
00:11:14,320 --> 00:11:17,440
part of the its configuration generator

286
00:11:17,440 --> 00:11:19,920
as you can see on the slide in the top

287
00:11:19,920 --> 00:11:23,839
100 domains uh the support of the dpr

288
00:11:23,839 --> 00:11:26,959
monkey exchange is extremely low

289
00:11:26,959 --> 00:11:29,040
the reason maybe

290
00:11:29,040 --> 00:11:32,320
the fact that that that there is a

291
00:11:32,320 --> 00:11:34,320
performance issue with the dvr monkey

292
00:11:34,320 --> 00:11:37,519
exchange and maybe the fact that it is

293
00:11:37,519 --> 00:11:39,120
possible to provide backward

294
00:11:39,120 --> 00:11:41,040
compatibility with the older clients by

295
00:11:41,040 --> 00:11:43,839
using the rsae key exchange which has no

296
00:11:43,839 --> 00:11:45,519
performance issue

297
00:11:45,519 --> 00:11:47,920
in the case of the top

298
00:11:47,920 --> 00:11:49,760
10 000

299
00:11:49,760 --> 00:11:51,120
domains the

300
00:11:51,120 --> 00:11:54,959
ratio of the support is 25 which is

301
00:11:54,959 --> 00:11:57,040
still so high but

302
00:11:57,040 --> 00:11:58,560
if you see that

303
00:11:58,560 --> 00:12:00,639
if you can see in the case of the one

304
00:12:00,639 --> 00:12:04,279
top top 1 million servers the ratio is

305
00:12:04,279 --> 00:12:07,680
47 percent which can be so considered

306
00:12:07,680 --> 00:12:09,440
high

307
00:12:09,440 --> 00:12:11,839
in general we can say that there are

308
00:12:11,839 --> 00:12:15,920
more than 55 million https servers on

309
00:12:15,920 --> 00:12:17,920
the internet according to the showdown

310
00:12:17,920 --> 00:12:19,040
statistics

311
00:12:19,040 --> 00:12:21,120
and if we assume that the ratio is the

312
00:12:21,120 --> 00:12:22,959
same as it was in the case of the top 1

313
00:12:22,959 --> 00:12:24,880
million domains

314
00:12:24,880 --> 00:12:27,920
we can say that more than 10 million

315
00:12:27,920 --> 00:12:30,160
servers using dpm on key exchange

316
00:12:30,160 --> 00:12:32,480
nowadays

317
00:12:32,480 --> 00:12:34,639
after the theoretical explanation let's

318
00:12:34,639 --> 00:12:37,519
let's see a demo i will use a digital

319
00:12:37,519 --> 00:12:38,399
ocean

320
00:12:38,399 --> 00:12:40,720
instance with four cpus and eight

321
00:12:40,720 --> 00:12:44,639
gigabytes of memory i will use 2kbit dpr

322
00:12:44,639 --> 00:12:47,600
among key size

323
00:12:50,480 --> 00:12:52,880
i will use a docker container

324
00:12:52,880 --> 00:12:56,240
which which run apache app server

325
00:12:56,240 --> 00:13:00,959
uh with the mentioned 2kbp key size

326
00:13:03,040 --> 00:13:05,440
i implemented an application called the

327
00:13:05,440 --> 00:13:07,680
heater named after the attack which is

328
00:13:07,680 --> 00:13:09,839
they hitch

329
00:13:09,839 --> 00:13:11,839
which can which is a

330
00:13:11,839 --> 00:13:14,399
proof of constant implementation of the

331
00:13:14,399 --> 00:13:16,639
vulnerability

332
00:13:16,639 --> 00:13:19,360
let's start it

333
00:13:19,360 --> 00:13:21,760
but not in this terminal but the other

334
00:13:21,760 --> 00:13:24,000
one

335
00:13:26,639 --> 00:13:29,440
demo effect

336
00:13:29,920 --> 00:13:33,040
okay it has started and as you can see

337
00:13:33,040 --> 00:13:35,440
the cpu

338
00:13:35,440 --> 00:13:39,440
there is 100 percent cpu usage

339
00:13:39,440 --> 00:13:40,959
let's measure

340
00:13:40,959 --> 00:13:43,599
the attack

341
00:13:46,000 --> 00:13:50,800
i start the dcp dump

342
00:13:52,160 --> 00:13:53,839
or i hope so

343
00:13:53,839 --> 00:13:56,160
okay

344
00:13:58,880 --> 00:14:00,959
okay to starting

345
00:14:00,959 --> 00:14:04,479
let's wait just a few seconds

346
00:14:05,279 --> 00:14:08,240
one two three four five okay

347
00:14:08,240 --> 00:14:11,199
let's see the result

348
00:14:13,600 --> 00:14:19,279
if i can stop it once but okay

349
00:14:19,920 --> 00:14:22,959
i stopped the attack

350
00:14:25,279 --> 00:14:29,399
okay and let's see the result

351
00:14:53,120 --> 00:14:55,440
hmm

352
00:14:57,519 --> 00:14:59,519
yes okay

353
00:14:59,519 --> 00:15:02,800
okay it was uh 17 seconds almost 18

354
00:15:02,800 --> 00:15:04,560
seconds

355
00:15:04,560 --> 00:15:06,160
as you can see

356
00:15:06,160 --> 00:15:09,120
the incoming dates are outgoing date on

357
00:15:09,120 --> 00:15:11,600
the number of client hello messages was

358
00:15:11,600 --> 00:15:13,519
more than

359
00:15:13,519 --> 00:15:14,959
five

360
00:15:14,959 --> 00:15:17,359
thousand

361
00:15:18,000 --> 00:15:20,399
all the public keys were unique and as

362
00:15:20,399 --> 00:15:21,600
you can see

363
00:15:21,600 --> 00:15:22,880
um

364
00:15:22,880 --> 00:15:24,639
77

365
00:15:24,639 --> 00:15:27,680
requests per second was enough to cause

366
00:15:27,680 --> 00:15:33,719
100 cpu usage on one cpu core

367
00:15:40,160 --> 00:15:42,800
uh so as you see in the demo relatively

368
00:15:42,800 --> 00:15:45,519
low throughput was enough to cause uh

369
00:15:45,519 --> 00:15:47,040
100

370
00:15:47,040 --> 00:15:48,720
cpu usage

371
00:15:48,720 --> 00:15:51,120
but we can

372
00:15:51,120 --> 00:15:53,199
we can question that that

373
00:15:53,199 --> 00:15:54,720
how

374
00:15:54,720 --> 00:15:57,839
so is it is it a high or is it a low uh

375
00:15:57,839 --> 00:15:59,360
throughput

376
00:15:59,360 --> 00:16:01,360
i have to say that it depends

377
00:16:01,360 --> 00:16:04,160
if we uh consider the fact that cloud

378
00:16:04,160 --> 00:16:06,639
flare has mitigated a 15

379
00:16:06,639 --> 00:16:09,600
million requests per second denial of

380
00:16:09,600 --> 00:16:11,920
service attack last month we can say

381
00:16:11,920 --> 00:16:15,360
that it's a relatively low throughput

382
00:16:15,360 --> 00:16:17,600
but let's go back to the reality and the

383
00:16:17,600 --> 00:16:20,800
demo environment and let's

384
00:16:20,800 --> 00:16:23,279
compare the values if you use different

385
00:16:23,279 --> 00:16:25,839
version of openssl or tls and different

386
00:16:25,839 --> 00:16:27,519
key sizes

387
00:16:27,519 --> 00:16:29,279
as you can see on the slide if you use

388
00:16:29,279 --> 00:16:33,279
openssl version 1.1 and tls version 1.2

389
00:16:33,279 --> 00:16:35,839
there are significant differences in in

390
00:16:35,839 --> 00:16:38,639
bandwidth and throughput if we use eight

391
00:16:38,639 --> 00:16:41,519
kbit key size instead of two kbit key

392
00:16:41,519 --> 00:16:42,639
size

393
00:16:42,639 --> 00:16:44,959
uh it's not a surprise

394
00:16:44,959 --> 00:16:47,120
large the larger is the key size the

395
00:16:47,120 --> 00:16:48,480
better is the

396
00:16:48,480 --> 00:16:51,199
effectiveness as would expect it

397
00:16:51,199 --> 00:16:55,199
if you use openssl version 3.0

398
00:16:55,199 --> 00:16:57,440
which is the latest version of openssl

399
00:16:57,440 --> 00:16:59,759
and tls version 1.3

400
00:16:59,759 --> 00:17:02,000
the result is significantly different as

401
00:17:02,000 --> 00:17:04,640
it was in the case of tls 1.2 and open

402
00:17:04,640 --> 00:17:06,640
ssr 1.1

403
00:17:06,640 --> 00:17:08,480
um

404
00:17:08,480 --> 00:17:11,599
the if you use the uh

405
00:17:11,599 --> 00:17:15,919
8kb key size only 1.2 requests per

406
00:17:15,919 --> 00:17:19,439
second was enough to cause 100 cpu usage

407
00:17:19,439 --> 00:17:21,520
on a cpu car

408
00:17:21,520 --> 00:17:22,959
the reason

409
00:17:22,959 --> 00:17:24,079
could be

410
00:17:24,079 --> 00:17:25,919
a performance issue in the case of

411
00:17:25,919 --> 00:17:29,120
openssl 3.0 but it's just a speculation

412
00:17:29,120 --> 00:17:30,400
at that point

413
00:17:30,400 --> 00:17:33,120
to prove that i decided to measure the

414
00:17:33,120 --> 00:17:35,039
attack effectiveness

415
00:17:35,039 --> 00:17:36,400
um

416
00:17:36,400 --> 00:17:38,320
with the different cryptographic

417
00:17:38,320 --> 00:17:41,840
libraries and different key sizes to see

418
00:17:41,840 --> 00:17:44,000
how crypto libraries affect the denial

419
00:17:44,000 --> 00:17:46,080
of service attack

420
00:17:46,080 --> 00:17:48,240
before i started to measure i wanted to

421
00:17:48,240 --> 00:17:50,960
know how important is the key size is it

422
00:17:50,960 --> 00:17:53,200
true that the most popular key size is

423
00:17:53,200 --> 00:17:56,400
the 2 kbit key size

424
00:17:56,400 --> 00:17:59,039
the answer is it depends

425
00:17:59,039 --> 00:18:00,400
i measured the

426
00:18:00,400 --> 00:18:03,039
key sizes in the case of the the

427
00:18:03,039 --> 00:18:05,280
web servers in the top minimum

428
00:18:05,280 --> 00:18:07,360
domain which supported dpm on key

429
00:18:07,360 --> 00:18:08,400
exchange

430
00:18:08,400 --> 00:18:10,960
as you can see on the slide the 2 kbit

431
00:18:10,960 --> 00:18:13,679
key size is definitely the most popular

432
00:18:13,679 --> 00:18:16,240
one the base majority of the servers use

433
00:18:16,240 --> 00:18:19,520
that key size um one kbit key size is

434
00:18:19,520 --> 00:18:20,559
still

435
00:18:20,559 --> 00:18:22,960
so high considering the fact that the

436
00:18:22,960 --> 00:18:24,799
logjam attack states that it is

437
00:18:24,799 --> 00:18:28,640
vulnerable by a nation state a 4kbit key

438
00:18:28,640 --> 00:18:32,080
size is relatively high

439
00:18:32,080 --> 00:18:32,880
but

440
00:18:32,880 --> 00:18:35,200
it was a surprise for me that it is low

441
00:18:35,200 --> 00:18:37,360
as you can see

442
00:18:37,360 --> 00:18:39,120
so therefore

443
00:18:39,120 --> 00:18:42,080
we could say that i have to focus on

444
00:18:42,080 --> 00:18:43,919
2kbit key size

445
00:18:43,919 --> 00:18:45,679
but

446
00:18:45,679 --> 00:18:48,559
i have to mention something in the case

447
00:18:48,559 --> 00:18:52,720
of the tls 1.2 protocol originally it

448
00:18:52,720 --> 00:18:55,919
was only possible to use one key size

449
00:18:55,919 --> 00:18:58,000
but there is an extension in the dls

450
00:18:58,000 --> 00:19:00,799
version 1.2 which makes it possible to a

451
00:19:00,799 --> 00:19:02,080
client to

452
00:19:02,080 --> 00:19:04,720
choose between key sizes in the case of

453
00:19:04,720 --> 00:19:08,000
dpr monkey exchange this extension

454
00:19:08,000 --> 00:19:10,400
is part of the

455
00:19:10,400 --> 00:19:14,559
tls 1.3 protocol definition

456
00:19:14,559 --> 00:19:17,280
however unlike the less popular

457
00:19:17,280 --> 00:19:20,559
cryptographic libraries openssl 1.1 does

458
00:19:20,559 --> 00:19:21,919
not support

459
00:19:21,919 --> 00:19:24,640
the extension in tls 1.2 and does not

460
00:19:24,640 --> 00:19:27,679
support ddpmonkey exchange at all in tls

461
00:19:27,679 --> 00:19:30,480
1.3

462
00:19:30,480 --> 00:19:31,760
this is the case

463
00:19:31,760 --> 00:19:34,000
if you are talking about tls but day

464
00:19:34,000 --> 00:19:37,039
heat is a protocol independent attack

465
00:19:37,039 --> 00:19:39,039
you can use that attack in whatever

466
00:19:39,039 --> 00:19:40,160
protocol

467
00:19:40,160 --> 00:19:41,520
so let's see what

468
00:19:41,520 --> 00:19:44,000
what we can measure in the case of ssh

469
00:19:44,000 --> 00:19:45,679
for instance

470
00:19:45,679 --> 00:19:47,760
at the first dance it may seem that the

471
00:19:47,760 --> 00:19:50,320
situation is the same as it was in the

472
00:19:50,320 --> 00:19:53,039
case of the tls according to the

473
00:19:53,039 --> 00:19:54,880
showdown statistics

474
00:19:54,880 --> 00:19:56,880
the 2 gigabit key size is the most

475
00:19:56,880 --> 00:19:58,400
popular one

476
00:19:58,400 --> 00:19:59,280
but

477
00:19:59,280 --> 00:20:02,159
the 4 and 8gb key sizes

478
00:20:02,159 --> 00:20:05,120
are supported more than 60 percent

479
00:20:05,120 --> 00:20:06,880
of the servers

480
00:20:06,880 --> 00:20:08,799
which is so high so we can say that

481
00:20:08,799 --> 00:20:10,640
equity size

482
00:20:10,640 --> 00:20:12,559
can be

483
00:20:12,559 --> 00:20:15,919
indeed be forced in in 60 percent of the

484
00:20:15,919 --> 00:20:18,400
servers and

485
00:20:18,400 --> 00:20:20,559
there is a uh there is an important

486
00:20:20,559 --> 00:20:23,360
thing i have to mention that the ssh

487
00:20:23,360 --> 00:20:24,559
protocol

488
00:20:24,559 --> 00:20:27,120
just like the tls 1.2 with the extension

489
00:20:27,120 --> 00:20:31,440
and the tls 1.3 allows the client to

490
00:20:31,440 --> 00:20:34,000
choose between the key sizes so and

491
00:20:34,000 --> 00:20:36,960
autocare can force the server to use the

492
00:20:36,960 --> 00:20:39,280
largest key size which is enabled in the

493
00:20:39,280 --> 00:20:42,080
server configuration

494
00:20:42,080 --> 00:20:44,640
this is the variatic

495
00:20:44,640 --> 00:20:45,919
column in

496
00:20:45,919 --> 00:20:49,760
the on the chart so presently more than

497
00:20:49,760 --> 00:20:52,720
90 percent of the servers can be forced

498
00:20:52,720 --> 00:20:55,120
to use the 80b with key size as it is

499
00:20:55,120 --> 00:20:57,120
enabled in the default configuration of

500
00:20:57,120 --> 00:20:59,360
the openssh for instance

501
00:20:59,360 --> 00:21:01,360
so the key size matters

502
00:21:01,360 --> 00:21:04,000
especially in terry because

503
00:21:04,000 --> 00:21:06,559
the attack effectiveness highly depends

504
00:21:06,559 --> 00:21:08,159
on the key size

505
00:21:08,159 --> 00:21:10,080
moreover not linearly but

506
00:21:10,080 --> 00:21:11,760
logarithmically

507
00:21:11,760 --> 00:21:14,080
however it should be noted that

508
00:21:14,080 --> 00:21:16,960
some more components are imported

509
00:21:16,960 --> 00:21:19,520
such as the application

510
00:21:19,520 --> 00:21:22,720
server implementation and the protocol

511
00:21:22,720 --> 00:21:23,840
so

512
00:21:23,840 --> 00:21:26,320
i decided to measure

513
00:21:26,320 --> 00:21:27,840
so i decided to perform some

514
00:21:27,840 --> 00:21:29,120
measurements

515
00:21:29,120 --> 00:21:31,760
i wanted to focus on the cryptographic

516
00:21:31,760 --> 00:21:32,960
libraries

517
00:21:32,960 --> 00:21:33,760
so

518
00:21:33,760 --> 00:21:36,320
and i wanted to exclude as many other

519
00:21:36,320 --> 00:21:38,640
factors as possible i use the same

520
00:21:38,640 --> 00:21:41,360
environment that i used in the demo and

521
00:21:41,360 --> 00:21:44,159
i and to avoid to measure the details of

522
00:21:44,159 --> 00:21:45,840
the application servers instead of the

523
00:21:45,840 --> 00:21:48,240
details of the cryptographic library i

524
00:21:48,240 --> 00:21:50,320
have to find an application server which

525
00:21:50,320 --> 00:21:53,280
supports uh more than one cryptographic

526
00:21:53,280 --> 00:21:54,960
libraries

527
00:21:54,960 --> 00:21:57,840
this is the light httpd because it

528
00:21:57,840 --> 00:22:01,840
supports several cryptographic libraries

529
00:22:01,919 --> 00:22:04,159
not only openssl which is the most

530
00:22:04,159 --> 00:22:06,720
popular cryptographic library but also

531
00:22:06,720 --> 00:22:10,480
gnu tls which is another

532
00:22:10,480 --> 00:22:12,480
popular cryptographic library

533
00:22:12,480 --> 00:22:14,960
nss which is the cryptographic library

534
00:22:14,960 --> 00:22:18,240
of firefox and amp and tls which is an

535
00:22:18,240 --> 00:22:22,559
embedded system cryptographic library

536
00:22:22,880 --> 00:22:24,720
let's see the result of the measurement

537
00:22:24,720 --> 00:22:27,360
what we can see on the slide

538
00:22:27,360 --> 00:22:30,080
we can see how much throughput is

539
00:22:30,080 --> 00:22:32,080
necessary to cause

540
00:22:32,080 --> 00:22:34,960
100 cpu usage on the server this is the

541
00:22:34,960 --> 00:22:36,960
vertical axis

542
00:22:36,960 --> 00:22:39,280
and the horizontal axis is the different

543
00:22:39,280 --> 00:22:41,120
key size

544
00:22:41,120 --> 00:22:43,520
not surprisingly the larger is the key

545
00:22:43,520 --> 00:22:45,679
size the lower is the necessary

546
00:22:45,679 --> 00:22:48,480
throughput which can cause 100 person

547
00:22:48,480 --> 00:22:49,919
cpu usage

548
00:22:49,919 --> 00:22:52,320
as the computing capacity requirement is

549
00:22:52,320 --> 00:22:53,600
higher

550
00:22:53,600 --> 00:22:55,919
with the larger key sizes so a server

551
00:22:55,919 --> 00:22:57,600
can respond

552
00:22:57,600 --> 00:22:59,520
fewer requests

553
00:22:59,520 --> 00:23:01,600
the chart can demonstrate

554
00:23:01,600 --> 00:23:03,360
that there are significant differences

555
00:23:03,360 --> 00:23:06,320
between the cryptographic libraries

556
00:23:06,320 --> 00:23:09,600
in the case of nss it was uh

557
00:23:09,600 --> 00:23:14,240
uh 150 requests second was enough

558
00:23:14,240 --> 00:23:18,559
to to cause 100 cpu usage with two keys

559
00:23:18,559 --> 00:23:21,600
in the case of embed tls slightly more

560
00:23:21,600 --> 00:23:24,720
than 50 requests per second was enough

561
00:23:24,720 --> 00:23:25,440
to

562
00:23:25,440 --> 00:23:27,760
to to cause the same result in the case

563
00:23:27,760 --> 00:23:30,400
of the new tls less than

564
00:23:30,400 --> 00:23:33,039
100 requests per second throughput was

565
00:23:33,039 --> 00:23:35,840
enough to close this 100 percent cpu

566
00:23:35,840 --> 00:23:37,120
usage

567
00:23:37,120 --> 00:23:38,799
what is the conclusion

568
00:23:38,799 --> 00:23:40,960
the shape of the curve is

569
00:23:40,960 --> 00:23:42,960
is similar independently from the

570
00:23:42,960 --> 00:23:45,679
cryptographic library however the exact

571
00:23:45,679 --> 00:23:46,880
values

572
00:23:46,880 --> 00:23:48,559
demonstrate that there are significant

573
00:23:48,559 --> 00:23:51,360
differences in the effectiveness in the

574
00:23:51,360 --> 00:23:52,880
case of the different cryptographic

575
00:23:52,880 --> 00:23:54,320
libraries

576
00:23:54,320 --> 00:23:56,080
the next major event shows the

577
00:23:56,080 --> 00:23:59,279
differences between the tls version 1.2

578
00:23:59,279 --> 00:24:03,039
and the diaspora 1.3 solid lines are

579
00:24:03,039 --> 00:24:07,760
tls 1.2 and dashed lines are tls 1.3

580
00:24:07,760 --> 00:24:10,640
as you can see tls 1.3

581
00:24:10,640 --> 00:24:13,360
is significant in the case of 100 1.3

582
00:24:13,360 --> 00:24:15,600
significantly lower throughput was

583
00:24:15,600 --> 00:24:17,600
enough to cause

584
00:24:17,600 --> 00:24:21,120
the 100 person cp usage as it was in the

585
00:24:21,120 --> 00:24:23,760
case of the ls 1.2 the reason is the

586
00:24:23,760 --> 00:24:27,360
fact that in the case of tls 1.3

587
00:24:27,360 --> 00:24:30,080
the client is required to send

588
00:24:30,080 --> 00:24:32,240
its public key

589
00:24:32,240 --> 00:24:33,919
during the handshake in the initial

590
00:24:33,919 --> 00:24:35,360
message

591
00:24:35,360 --> 00:24:38,080
the result is the fact that after the

592
00:24:38,080 --> 00:24:40,480
server receives this is this initial

593
00:24:40,480 --> 00:24:41,600
message

594
00:24:41,600 --> 00:24:44,640
it can compute its public key

595
00:24:44,640 --> 00:24:49,279
and also the shared secret so it can um

596
00:24:49,279 --> 00:24:51,440
do the cpu intensive operation the

597
00:24:51,440 --> 00:24:53,919
modular exponentiation twice

598
00:24:53,919 --> 00:24:57,279
uh meaning that um

599
00:24:57,279 --> 00:25:00,320
that is causing the fewer requests is

600
00:25:00,320 --> 00:25:03,919
enough to cause 100 percent cpu usage

601
00:25:03,919 --> 00:25:06,320
at this point i decided to

602
00:25:06,320 --> 00:25:09,600
use a different unit of measurement

603
00:25:09,600 --> 00:25:11,360
to to make the different throughput

604
00:25:11,360 --> 00:25:13,840
values comparable with each other and to

605
00:25:13,840 --> 00:25:15,200
make

606
00:25:15,200 --> 00:25:16,400
the different

607
00:25:16,400 --> 00:25:17,679
the values comes from different

608
00:25:17,679 --> 00:25:19,360
environments and use different

609
00:25:19,360 --> 00:25:20,960
applications service compatible with

610
00:25:20,960 --> 00:25:23,200
each other

611
00:25:23,200 --> 00:25:25,039
this chart

612
00:25:25,039 --> 00:25:28,080
displays the same data as last one but

613
00:25:28,080 --> 00:25:31,039
with a different unit of measurement

614
00:25:31,039 --> 00:25:33,120
the star point is always one

615
00:25:33,120 --> 00:25:35,120
and the lines are increasing

616
00:25:35,120 --> 00:25:38,080
because the poisson the points show

617
00:25:38,080 --> 00:25:41,360
how many times less throughput

618
00:25:41,360 --> 00:25:44,320
was enough to cause the 100 percent cpu

619
00:25:44,320 --> 00:25:45,440
usage

620
00:25:45,440 --> 00:25:47,679
using a larger key size

621
00:25:47,679 --> 00:25:50,640
than using a smaller bond

622
00:25:50,640 --> 00:25:53,200
the vertical axis is not linear but

623
00:25:53,200 --> 00:25:55,840
logarithmical as the values are also

624
00:25:55,840 --> 00:25:57,200
logarithmical

625
00:25:57,200 --> 00:25:59,840
the curves demonstrate the auto effect

626
00:25:59,840 --> 00:26:02,080
devious it's not throughput it's out of

627
00:26:02,080 --> 00:26:04,799
effectiveness as you can see on the

628
00:26:04,799 --> 00:26:05,840
chart

629
00:26:05,840 --> 00:26:07,200
the adductive

630
00:26:07,200 --> 00:26:09,039
effectiveness can be twice

631
00:26:09,039 --> 00:26:12,159
using a 3 kbit key size

632
00:26:12,159 --> 00:26:16,799
compared to 2 kbit key size it can be

633
00:26:16,799 --> 00:26:18,480
5 times higher

634
00:26:18,480 --> 00:26:20,799
using 4 kbit key size

635
00:26:20,799 --> 00:26:24,000
compared to the 2gb key size and it can

636
00:26:24,000 --> 00:26:26,159
be uh up to

637
00:26:26,159 --> 00:26:29,440
40 times higher if you use

638
00:26:29,440 --> 00:26:31,919
8kbit key size instead of 2 gigabit key

639
00:26:31,919 --> 00:26:32,960
size

640
00:26:32,960 --> 00:26:35,039
so as you can see

641
00:26:35,039 --> 00:26:37,840
increasing the key size increases the

642
00:26:37,840 --> 00:26:40,640
auto effectiveness dramatically

643
00:26:40,640 --> 00:26:43,679
you might notice that data but the

644
00:26:43,679 --> 00:26:46,240
most popular cryptographic library open

645
00:26:46,240 --> 00:26:50,559
ssl has not a b yet it's not not a not

646
00:26:50,559 --> 00:26:53,520
cons coincident

647
00:26:53,520 --> 00:26:55,520
the red line demonstrate the attack

648
00:26:55,520 --> 00:26:57,679
effectiveness in the case of openness of

649
00:26:57,679 --> 00:27:02,159
version 1.1 with tls version 1.2 and as

650
00:27:02,159 --> 00:27:04,400
you can see there are some oddities on

651
00:27:04,400 --> 00:27:05,760
the chart

652
00:27:05,760 --> 00:27:08,640
in the case of uh three and four kbit

653
00:27:08,640 --> 00:27:11,360
key sizes the shape of the curve is the

654
00:27:11,360 --> 00:27:12,880
same as it was in the case of other

655
00:27:12,880 --> 00:27:15,279
cryptographic libraries but

656
00:27:15,279 --> 00:27:17,039
in the case of the uh

657
00:27:17,039 --> 00:27:18,640
six gigabit case size the auto

658
00:27:18,640 --> 00:27:20,880
effectiveness is much lower

659
00:27:20,880 --> 00:27:22,880
uh than as it was in the case of three

660
00:27:22,880 --> 00:27:24,799
kbit side key size

661
00:27:24,799 --> 00:27:28,240
as uh and um it is also lower uh but the

662
00:27:28,240 --> 00:27:28,960
other

663
00:27:28,960 --> 00:27:30,880
effectiveness is also lower than than it

664
00:27:30,880 --> 00:27:33,520
was in the case of two kbit cases which

665
00:27:33,520 --> 00:27:36,960
is quite surprising

666
00:27:36,960 --> 00:27:39,600
in the case of 8kb key size the attack

667
00:27:39,600 --> 00:27:41,840
effectiveness is almost the same as it

668
00:27:41,840 --> 00:27:44,399
was in the case of 3 kb key size which

669
00:27:44,399 --> 00:27:46,640
is quite strange for me

670
00:27:46,640 --> 00:27:49,360
at that point i decided to measure the

671
00:27:49,360 --> 00:27:52,559
openness by changing only one component

672
00:27:52,559 --> 00:27:54,880
at a time to find out what what is the

673
00:27:54,880 --> 00:27:57,679
reason of that anomaly

674
00:27:57,679 --> 00:27:59,440
the result was most

675
00:27:59,440 --> 00:28:03,039
most more serious more mysterious than

676
00:28:03,039 --> 00:28:05,679
the original measurement i started the

677
00:28:05,679 --> 00:28:07,520
investigation

678
00:28:07,520 --> 00:28:10,240
with openssl version 1.1

679
00:28:10,240 --> 00:28:12,640
tls version 1.2

680
00:28:12,640 --> 00:28:13,520
but

681
00:28:13,520 --> 00:28:16,000
i used different application servers the

682
00:28:16,000 --> 00:28:18,240
result

683
00:28:18,240 --> 00:28:20,320
the red line shows the result

684
00:28:20,320 --> 00:28:22,480
and the result is the same in the case

685
00:28:22,480 --> 00:28:25,120
of the different application servers so

686
00:28:25,120 --> 00:28:27,279
the anomaly is independent from the

687
00:28:27,279 --> 00:28:28,960
application server

688
00:28:28,960 --> 00:28:31,039
so i decided to continue the

689
00:28:31,039 --> 00:28:32,640
investigation

690
00:28:32,640 --> 00:28:34,159
by using

691
00:28:34,159 --> 00:28:34,880
the

692
00:28:34,880 --> 00:28:38,399
tls version 1.3

693
00:28:38,399 --> 00:28:41,440
with openssl version 3.0 only opens

694
00:28:41,440 --> 00:28:43,520
version 3.0 supports the amount key

695
00:28:43,520 --> 00:28:45,600
exchange so that's why i changed the

696
00:28:45,600 --> 00:28:47,679
open ssl version

697
00:28:47,679 --> 00:28:49,600
as the blue lines show

698
00:28:49,600 --> 00:28:51,679
the result is the same as it was in the

699
00:28:51,679 --> 00:28:53,360
case of the other cryptographic

700
00:28:53,360 --> 00:28:56,559
libraries and and there is no anomaly

701
00:28:56,559 --> 00:28:58,480
so i continued the investigation by

702
00:28:58,480 --> 00:29:01,279
using openssl version 1.1

703
00:29:01,279 --> 00:29:04,720
tls version 1.2 but i changed the

704
00:29:04,720 --> 00:29:07,039
diffie-hellman parameters to random

705
00:29:07,039 --> 00:29:08,240
months

706
00:29:08,240 --> 00:29:09,919
i used a

707
00:29:09,919 --> 00:29:11,039
dpm

708
00:29:11,039 --> 00:29:12,720
parameter which comes from

709
00:29:12,720 --> 00:29:15,679
another rfc and then random one

710
00:29:15,679 --> 00:29:17,520
and as you can as you can see as the

711
00:29:17,520 --> 00:29:20,240
gray line shows the result was similar

712
00:29:20,240 --> 00:29:22,320
to the other cryptographic libraries

713
00:29:22,320 --> 00:29:24,880
again and there is no anomaly

714
00:29:24,880 --> 00:29:26,720
so i continued the investigation with

715
00:29:26,720 --> 00:29:28,640
the open sssp2

716
00:29:28,640 --> 00:29:32,799
which measures just the diffie-hellman

717
00:29:32,799 --> 00:29:35,039
key generation not the whole key

718
00:29:35,039 --> 00:29:38,320
exchange just regeneration and and the

719
00:29:38,320 --> 00:29:40,799
solid and dashed white line shows the

720
00:29:40,799 --> 00:29:42,559
result is similar to the other

721
00:29:42,559 --> 00:29:44,480
cryptographic libraries and there is no

722
00:29:44,480 --> 00:29:45,919
anomaly

723
00:29:45,919 --> 00:29:48,880
so uh the anomaly exists only

724
00:29:48,880 --> 00:29:51,520
with openness version 1.20 as version

725
00:29:51,520 --> 00:29:54,960
1.2 at

726
00:29:59,600 --> 00:30:02,080
it is not fully clear for me what is the

727
00:30:02,080 --> 00:30:05,760
reason of that anomaly but i am going to

728
00:30:05,760 --> 00:30:07,919
continue the investigation anyway the

729
00:30:07,919 --> 00:30:10,080
developers of the open ssl know about

730
00:30:10,080 --> 00:30:10,880
that

731
00:30:10,880 --> 00:30:14,080
anomaly and they said it's strange so

732
00:30:14,080 --> 00:30:16,960
let me know if you have an answer why

733
00:30:16,960 --> 00:30:20,480
why what's the reason of that animal

734
00:30:20,480 --> 00:30:23,440
to sum up my presentation

735
00:30:23,440 --> 00:30:26,080
let's see what properties uh makes the

736
00:30:26,080 --> 00:30:28,880
cryptographic protocols uh more exposed

737
00:30:28,880 --> 00:30:32,159
uh to the um the heat attack first of

738
00:30:32,159 --> 00:30:34,480
all i have to mention the zero round

739
00:30:34,480 --> 00:30:36,559
trip um

740
00:30:36,559 --> 00:30:38,640
if it is necessary

741
00:30:38,640 --> 00:30:42,159
to send only one messages to a server to

742
00:30:42,159 --> 00:30:44,399
force them to do the cpu intensive

743
00:30:44,399 --> 00:30:47,440
operations the cryptographic protocol is

744
00:30:47,440 --> 00:30:50,320
more vulnerable this is the case if you

745
00:30:50,320 --> 00:30:52,640
are talking about tls

746
00:30:52,640 --> 00:30:56,159
and ike the in the case of ssh

747
00:30:56,159 --> 00:30:58,320
the client is required to require to

748
00:30:58,320 --> 00:31:01,440
send at least two or three messages

749
00:31:01,440 --> 00:31:03,840
to force the server

750
00:31:03,840 --> 00:31:06,159
another important aspect is

751
00:31:06,159 --> 00:31:08,399
the client client key size selection

752
00:31:08,399 --> 00:31:09,840
possibility

753
00:31:09,840 --> 00:31:12,799
as i mentioned this is the case

754
00:31:12,799 --> 00:31:15,679
in the case of ts 1.2 with an extension

755
00:31:15,679 --> 00:31:18,159
in the case of ts 1.3

756
00:31:18,159 --> 00:31:21,440
in the case of ssh and i key

757
00:31:21,440 --> 00:31:24,799
the third thing is the pre-computational

758
00:31:24,799 --> 00:31:27,279
ability if the client can

759
00:31:27,279 --> 00:31:29,440
pre-compute the messages the

760
00:31:29,440 --> 00:31:32,000
effectiveness is a little bit higher but

761
00:31:32,000 --> 00:31:34,880
i have to mention if it is not possible

762
00:31:34,880 --> 00:31:36,080
uh the auto

763
00:31:36,080 --> 00:31:38,000
effectiveness is a little bit lower but

764
00:31:38,000 --> 00:31:41,600
it cannot mitigate the attack itself

765
00:31:41,600 --> 00:31:43,519
you can compute the messages in the case

766
00:31:43,519 --> 00:31:44,880
of tls

767
00:31:44,880 --> 00:31:46,799
and ssh

768
00:31:46,799 --> 00:31:49,919
in one cases but in the case of openssh

769
00:31:49,919 --> 00:31:51,279
you have to

770
00:31:51,279 --> 00:31:53,360
compute the messages connection to

771
00:31:53,360 --> 00:31:55,600
connection

772
00:31:55,600 --> 00:31:57,279
in in the case of some cryptographic

773
00:31:57,279 --> 00:32:01,120
protocols there is a mechanism to

774
00:32:01,120 --> 00:32:02,960
protect again the denial of service

775
00:32:02,960 --> 00:32:05,279
attack discord cookie cookies just a

776
00:32:05,279 --> 00:32:06,720
random number

777
00:32:06,720 --> 00:32:09,279
the server sends this random number to

778
00:32:09,279 --> 00:32:10,960
the client and the client

779
00:32:10,960 --> 00:32:12,399
should repeat it

780
00:32:12,399 --> 00:32:14,399
and send it back to the server in this

781
00:32:14,399 --> 00:32:16,480
way uh you can decrease the

782
00:32:16,480 --> 00:32:18,960
effectiveness of the attack as you can

783
00:32:18,960 --> 00:32:20,880
as you should

784
00:32:20,880 --> 00:32:22,080
compute

785
00:32:22,080 --> 00:32:24,480
the messages connection by connection

786
00:32:24,480 --> 00:32:27,600
but it cannot mitigate the attack at all

787
00:32:27,600 --> 00:32:29,120
it can decrease the effectiveness a

788
00:32:29,120 --> 00:32:32,559
little bit but it cannot mitigate it so

789
00:32:32,559 --> 00:32:33,840
uh

790
00:32:33,840 --> 00:32:37,440
what method can uh a user

791
00:32:37,440 --> 00:32:40,000
use to to mitigate the data attack if

792
00:32:40,000 --> 00:32:42,799
you are talking about private services i

793
00:32:42,799 --> 00:32:44,880
would suggest to disable it if you have

794
00:32:44,880 --> 00:32:46,960
a monkey exchange and and that's the

795
00:32:46,960 --> 00:32:49,519
solution the elliptic conversion of the

796
00:32:49,519 --> 00:32:51,440
dpr monkey exchange is the most

797
00:32:51,440 --> 00:32:53,200
effective one nowadays and the most

798
00:32:53,200 --> 00:32:54,840
secure one

799
00:32:54,840 --> 00:32:57,840
so um if you are talking about private

800
00:32:57,840 --> 00:33:00,799
message private services it can be done

801
00:33:00,799 --> 00:33:03,840
uh if the backward compatibility is uh

802
00:33:03,840 --> 00:33:05,279
is a must

803
00:33:05,279 --> 00:33:07,600
in that case i would suggest

804
00:33:07,600 --> 00:33:11,519
to control the number of unauthenticated

805
00:33:11,519 --> 00:33:12,720
connections

806
00:33:12,720 --> 00:33:14,799
unfortunately there are just a few

807
00:33:14,799 --> 00:33:17,120
applications there as we support that a

808
00:33:17,120 --> 00:33:19,120
very good example for that is the open

809
00:33:19,120 --> 00:33:21,679
ssh where it is possible to

810
00:33:21,679 --> 00:33:23,840
control the number of unauthenticated

811
00:33:23,840 --> 00:33:25,840
connections

812
00:33:25,840 --> 00:33:27,440
so you can

813
00:33:27,440 --> 00:33:29,360
you can set a maximum number of

814
00:33:29,360 --> 00:33:32,880
unauthenticated connections and it can

815
00:33:32,880 --> 00:33:34,080
decrease

816
00:33:34,080 --> 00:33:37,279
the effectiveness of the attack

817
00:33:37,279 --> 00:33:40,240
another possibility is use a third-party

818
00:33:40,240 --> 00:33:41,679
tool

819
00:33:41,679 --> 00:33:45,200
such as fail to bond which can parse

820
00:33:45,200 --> 00:33:47,440
the ip address of a malicious client

821
00:33:47,440 --> 00:33:49,679
from the log messages

822
00:33:49,679 --> 00:33:52,799
and after that it can create uh fireball

823
00:33:52,799 --> 00:33:55,519
rules to bond that client

824
00:33:55,519 --> 00:33:57,279
it it's uh

825
00:33:57,279 --> 00:34:00,559
it's a very effective way to mitigate

826
00:34:00,559 --> 00:34:02,960
this attack but unfortunately the

827
00:34:02,960 --> 00:34:05,760
default load level is not enough in

828
00:34:05,760 --> 00:34:07,279
several cases

829
00:34:07,279 --> 00:34:09,520
so if you have to

830
00:34:09,520 --> 00:34:11,918
increase the lock level which may mean

831
00:34:11,918 --> 00:34:14,079
that it caused significant amount of log

832
00:34:14,079 --> 00:34:17,359
messages so you have to care about that

833
00:34:17,359 --> 00:34:20,719
if you are talking about public services

834
00:34:20,719 --> 00:34:22,800
i would say that you have to consider

835
00:34:22,800 --> 00:34:25,918
the compatibility with five to ten years

836
00:34:25,918 --> 00:34:28,560
clients i mean that the

837
00:34:28,560 --> 00:34:30,079
most browsers

838
00:34:30,079 --> 00:34:32,000
support the elliptical version of dpr

839
00:34:32,000 --> 00:34:34,719
monkey exchange for five to ten years

840
00:34:34,719 --> 00:34:36,800
other kind of clients also support the

841
00:34:36,800 --> 00:34:38,399
elliptic curve version of dpr monkey

842
00:34:38,399 --> 00:34:41,598
exchange for five years

843
00:34:41,918 --> 00:34:42,879
and

844
00:34:42,879 --> 00:34:44,800
in the in the case of the public

845
00:34:44,800 --> 00:34:46,159
services

846
00:34:46,159 --> 00:34:48,800
you can also use the rate limiting

847
00:34:48,800 --> 00:34:50,480
[Music]

848
00:34:50,480 --> 00:34:52,879
using the application server specific

849
00:34:52,879 --> 00:34:55,440
configuration or using the uh mentioned

850
00:34:55,440 --> 00:34:57,520
failed one

851
00:34:57,520 --> 00:34:59,839
on the github page of the application

852
00:34:59,839 --> 00:35:01,839
day heater you can find configuration

853
00:35:01,839 --> 00:35:04,240
snippets how to configure how to disable

854
00:35:04,240 --> 00:35:06,960
the dvr monkey exchange in a different

855
00:35:06,960 --> 00:35:09,040
application servers and how to read

856
00:35:09,040 --> 00:35:11,839
limit the number of concurrent

857
00:35:11,839 --> 00:35:13,440
connections

858
00:35:13,440 --> 00:35:16,160
this qr code contains the url of that

859
00:35:16,160 --> 00:35:18,640
github page where you can find the

860
00:35:18,640 --> 00:35:20,640
mentioned configurations

861
00:35:20,640 --> 00:35:22,610
thank you for your attention

862
00:35:22,610 --> 00:35:28,000
[Applause]

863
00:35:28,000 --> 00:35:29,200
thank you

864
00:35:29,200 --> 00:35:30,640
salad

865
00:35:30,640 --> 00:35:33,119
do we have any comment or for still out

866
00:35:33,119 --> 00:35:35,200
any questions for

867
00:35:35,200 --> 00:35:37,040
sillard

868
00:35:37,040 --> 00:35:39,359
at this time

869
00:35:39,359 --> 00:35:41,680
take a photograph of the qr for future

870
00:35:41,680 --> 00:35:44,000
reference if you have something later

871
00:35:44,000 --> 00:35:46,640
here's a question

872
00:35:51,680 --> 00:35:53,040
thank you

873
00:35:53,040 --> 00:35:55,520
have you done any measurements on the

874
00:35:55,520 --> 00:35:56,880
elliptic curve

875
00:35:56,880 --> 00:35:59,760
dhe and how

876
00:35:59,760 --> 00:36:03,200
how much better is the performance there

877
00:36:03,200 --> 00:36:04,640
yes

878
00:36:04,640 --> 00:36:06,800
i have done

879
00:36:06,800 --> 00:36:08,560
there are six there are significant

880
00:36:08,560 --> 00:36:11,119
differences i mean

881
00:36:11,119 --> 00:36:13,520
the elliptic curve uh version of the the

882
00:36:13,520 --> 00:36:14,480
amount

883
00:36:14,480 --> 00:36:18,240
is uh so you need that at at least uh

884
00:36:18,240 --> 00:36:20,640
um

885
00:36:20,800 --> 00:36:22,000
up to ten

886
00:36:22,000 --> 00:36:22,960
uh

887
00:36:22,960 --> 00:36:26,240
uh through puts to close the the same uh

888
00:36:26,240 --> 00:36:28,079
the same results so

889
00:36:28,079 --> 00:36:30,560
in in my humble opinion the elliptical

890
00:36:30,560 --> 00:36:32,720
version of the defeatment is not not so

891
00:36:32,720 --> 00:36:35,520
good if you want to perform uh deny of

892
00:36:35,520 --> 00:36:37,200
service attack but it highly depends on

893
00:36:37,200 --> 00:36:40,240
the curve anyway so there are

894
00:36:40,240 --> 00:36:43,119
several different curves and if you use

895
00:36:43,119 --> 00:36:45,839
a curve which has a

896
00:36:45,839 --> 00:36:49,280
larger key size it can be

897
00:36:49,280 --> 00:36:52,400
it can be suitable to to cause a

898
00:36:52,400 --> 00:36:55,119
significant load on the server

899
00:36:55,119 --> 00:36:57,200
and there is another uh

900
00:36:57,200 --> 00:36:59,440
important aspect the post quantum

901
00:36:59,440 --> 00:37:00,880
cryptography

902
00:37:00,880 --> 00:37:02,000
which can

903
00:37:02,000 --> 00:37:05,680
be useful to useful if it is useful uh

904
00:37:05,680 --> 00:37:09,040
so it can be useful if you want to

905
00:37:09,040 --> 00:37:11,119
to do or deny of service attack but but

906
00:37:11,119 --> 00:37:13,920
i have to measure it

907
00:37:18,560 --> 00:37:20,960
anybody with

908
00:37:20,960 --> 00:37:22,480
any

909
00:37:22,480 --> 00:37:23,760
question for

910
00:37:23,760 --> 00:37:26,240
zillard

911
00:37:27,280 --> 00:37:28,800
looks not so

912
00:37:28,800 --> 00:37:31,200
once again salad thank you very much

913
00:37:31,200 --> 00:37:32,520
thank you

914
00:37:32,520 --> 00:37:37,359
[Applause]

915
00:37:37,359 --> 00:37:39,440
you

