1
00:00:10,340 --> 00:00:12,660
yo hey everyone welcome to malware

2
00:00:12,660 --> 00:00:15,599
dev101 or miss me with that scan uh it's

3
00:00:15,599 --> 00:00:16,920
a little bit about me because Shameless

4
00:00:16,920 --> 00:00:18,960
self plug I'm a senior penetration

5
00:00:18,960 --> 00:00:21,960
tester with Verizon just.verizon uh some

6
00:00:21,960 --> 00:00:23,340
certifications that I have I love

7
00:00:23,340 --> 00:00:25,859
offsect so I'm gonna show offsec a

8
00:00:25,859 --> 00:00:27,480
little bit here and I like to make

9
00:00:27,480 --> 00:00:29,519
condiments like hot sauce and mustard I

10
00:00:29,519 --> 00:00:31,140
got a good habanero blueberry when

11
00:00:31,140 --> 00:00:32,940
fermenting right now

12
00:00:32,940 --> 00:00:35,460
so here's this talk for uh I'm looking

13
00:00:35,460 --> 00:00:37,020
at Red teams that want to know how to

14
00:00:37,020 --> 00:00:38,460
evade antivirus and develop their own

15
00:00:38,460 --> 00:00:40,739
tooling uh forensics teams if you want

16
00:00:40,739 --> 00:00:42,239
to know how malware works in the inner

17
00:00:42,239 --> 00:00:43,920
workings and how it's built and

18
00:00:43,920 --> 00:00:45,360
developers interested in developing

19
00:00:45,360 --> 00:00:46,920
offensive tools so if you're you know

20
00:00:46,920 --> 00:00:48,239
computer science student and you want to

21
00:00:48,239 --> 00:00:50,160
your red team build tools and push it on

22
00:00:50,160 --> 00:00:51,480
GitHub because that will get you a job

23
00:00:51,480 --> 00:00:52,860
it worked for me

24
00:00:52,860 --> 00:00:54,420
so what we're going to talk about in

25
00:00:54,420 --> 00:00:56,280
this some Shell Code Runner Theory and

26
00:00:56,280 --> 00:00:58,260
building some common Invasion techniques

27
00:00:58,260 --> 00:01:00,420
to avoid antivirus some c-sharp

28
00:01:00,420 --> 00:01:02,460
development I am not touching EDR with a

29
00:01:02,460 --> 00:01:04,619
10-foot pole but that might be next year

30
00:01:04,619 --> 00:01:06,720
so because that would be an hour and a

31
00:01:06,720 --> 00:01:07,740
half long

32
00:01:07,740 --> 00:01:09,180
so we're going to start out with the

33
00:01:09,180 --> 00:01:11,340
basics first what is malware uh

34
00:01:11,340 --> 00:01:13,140
dictionary definition software that's

35
00:01:13,140 --> 00:01:14,880
designed to disrupt damage or gain on

36
00:01:14,880 --> 00:01:16,500
authorized access to a computer system

37
00:01:16,500 --> 00:01:19,860
short malicious malware duh and some of

38
00:01:19,860 --> 00:01:21,900
the types of malware are ransomware you

39
00:01:21,900 --> 00:01:23,640
know encrypting files and asking for

40
00:01:23,640 --> 00:01:26,220
money spyware or you know stalker wear

41
00:01:26,220 --> 00:01:28,020
Shell Code loaders which we'll be

42
00:01:28,020 --> 00:01:30,060
talking about today and droppers which

43
00:01:30,060 --> 00:01:31,619
are effectively just malicious

44
00:01:31,619 --> 00:01:33,540
installers

45
00:01:33,540 --> 00:01:35,460
so we'll go to Rochelle cart first

46
00:01:35,460 --> 00:01:36,720
before we can get a Shell Code Runner

47
00:01:36,720 --> 00:01:38,280
what is Shell Code well it's a

48
00:01:38,280 --> 00:01:40,560
hexadecimal representation of assembly

49
00:01:40,560 --> 00:01:43,320
or just raw machine code uh can be 32 or

50
00:01:43,320 --> 00:01:45,720
64-bit like anything else quick example

51
00:01:45,720 --> 00:01:50,040
here xff xe4 is Jump ESP or jump to the

52
00:01:50,040 --> 00:01:52,320
Stacked or execution uh this is a quick

53
00:01:52,320 --> 00:01:55,860
example for 32-bit so Shell Code loaders

54
00:01:55,860 --> 00:01:57,720
uh what they do is they take a chunk of

55
00:01:57,720 --> 00:01:59,040
shell codes that are usually stored in

56
00:01:59,040 --> 00:02:01,439
an array in programming and then they

57
00:02:01,439 --> 00:02:04,140
essentially switch execution to them uh

58
00:02:04,140 --> 00:02:05,520
most command and control servers like

59
00:02:05,520 --> 00:02:08,280
Metasploit Powershell Empire or Cobalt

60
00:02:08,280 --> 00:02:10,020
strike does output the Shell Code format

61
00:02:10,020 --> 00:02:12,360
it's probably the most common output

62
00:02:12,360 --> 00:02:14,340
format there is and there's even custom

63
00:02:14,340 --> 00:02:16,560
applications that convert an existing PE

64
00:02:16,560 --> 00:02:19,020
file or Windows executable to Shell Code

65
00:02:19,020 --> 00:02:21,900
like the donut project or bin to sc.pi

66
00:02:21,900 --> 00:02:23,940
both done on GitHub

67
00:02:23,940 --> 00:02:26,160
so the architecture of Shell Code

68
00:02:26,160 --> 00:02:28,260
loaders are kind of different most of

69
00:02:28,260 --> 00:02:29,819
them will use either process injection

70
00:02:29,819 --> 00:02:32,780
or essentially taking this raw assembly

71
00:02:32,780 --> 00:02:35,640
getting a handle to another process and

72
00:02:35,640 --> 00:02:37,260
injecting a bunch of code into it and

73
00:02:37,260 --> 00:02:39,660
then switching the execution that way or

74
00:02:39,660 --> 00:02:41,160
it can just create its own thread within

75
00:02:41,160 --> 00:02:43,500
itself and execute it that way there's

76
00:02:43,500 --> 00:02:45,060
being a little bit more stealthy because

77
00:02:45,060 --> 00:02:46,860
you don't have the actual process and a

78
00:02:46,860 --> 00:02:48,780
rock going on in there it's going to

79
00:02:48,780 --> 00:02:50,760
require the following windows apis for a

80
00:02:50,760 --> 00:02:53,180
typical Shell Code Runner uh virtual

81
00:02:53,180 --> 00:02:57,000
which allocates memory create thread to

82
00:02:57,000 --> 00:02:59,099
actually create an executable space for

83
00:02:59,099 --> 00:03:01,560
the malware and then wait for single

84
00:03:01,560 --> 00:03:03,540
object to keep the process up while the

85
00:03:03,540 --> 00:03:06,239
Shell Code actually executes

86
00:03:06,239 --> 00:03:08,040
all right so now that we're of all the

87
00:03:08,040 --> 00:03:09,300
boring Theory out of the way we can

88
00:03:09,300 --> 00:03:10,680
actually start building one so if you

89
00:03:10,680 --> 00:03:12,840
want to follow along at home uh there is

90
00:03:12,840 --> 00:03:14,879
Visual Studio C Sharps needed we're

91
00:03:14,879 --> 00:03:16,920
going to use Metasploit as our pseudo C2

92
00:03:16,920 --> 00:03:18,840
here and we'll be taking some notes from

93
00:03:18,840 --> 00:03:20,640
pnvoke.net

94
00:03:20,640 --> 00:03:23,040
so building it out I'm going to start a

95
00:03:23,040 --> 00:03:25,800
new Visual Basic or Visual Studio C

96
00:03:25,800 --> 00:03:27,720
sharp NET Framework console app you're

97
00:03:27,720 --> 00:03:29,400
going to need to declare system runtime

98
00:03:29,400 --> 00:03:31,980
interop services at the top and you have

99
00:03:31,980 --> 00:03:33,180
to copy the following P invoke

100
00:03:33,180 --> 00:03:35,040
signatures to the app so if you don't

101
00:03:35,040 --> 00:03:36,659
know what P invoke is it's a way to call

102
00:03:36,659 --> 00:03:39,000
call the windows API in languages that

103
00:03:39,000 --> 00:03:40,739
are not C plus plus and not having to

104
00:03:40,739 --> 00:03:43,440
use windows.h as the header file here's

105
00:03:43,440 --> 00:03:45,720
an example of the virtual lockp invoke

106
00:03:45,720 --> 00:03:48,299
signature uh you can see the c-sharp

107
00:03:48,299 --> 00:03:49,620
signature here and we're just going to

108
00:03:49,620 --> 00:03:52,019
copy that right in our code like so

109
00:03:52,019 --> 00:03:55,379
here's all of them for virtual lock wait

110
00:03:55,379 --> 00:03:57,480
for static or wait for single object and

111
00:03:57,480 --> 00:03:59,099
create thread so this is what the

112
00:03:59,099 --> 00:04:01,500
program would look like typically

113
00:04:01,500 --> 00:04:03,299
and now we need our actual Shell Code to

114
00:04:03,299 --> 00:04:06,060
load so we'll be using msf Venom which

115
00:04:06,060 --> 00:04:08,940
for those who don't know is a payload

116
00:04:08,940 --> 00:04:10,500
generator for another metasploy project

117
00:04:10,500 --> 00:04:13,140
uh we're using a 64-bit windows from

118
00:04:13,140 --> 00:04:16,079
interpreter payload that uses https to

119
00:04:16,079 --> 00:04:18,899
Beacon back and it'll give report 443

120
00:04:18,899 --> 00:04:21,060
and Route 40 to a c-sharp friendly

121
00:04:21,060 --> 00:04:22,680
format

122
00:04:22,680 --> 00:04:24,900
so now to actually call the windows API

123
00:04:24,900 --> 00:04:26,040
now that it's loaded and we got our

124
00:04:26,040 --> 00:04:27,180
Shell Code

125
00:04:27,180 --> 00:04:29,040
all right virtual lock the real

126
00:04:29,040 --> 00:04:31,199
important thing here is the address size

127
00:04:31,199 --> 00:04:34,440
and type so here's a msdn function

128
00:04:34,440 --> 00:04:36,780
prototype for virtual lock

129
00:04:36,780 --> 00:04:38,699
uh the lp address is where to actually

130
00:04:38,699 --> 00:04:40,680
stick it in memory or to allocate memory

131
00:04:40,680 --> 00:04:42,900
we're going to use 0 here just to let

132
00:04:42,900 --> 00:04:45,240
the computer pick for us uh the size

133
00:04:45,240 --> 00:04:47,759
which we'll use a thousand bits that

134
00:04:47,759 --> 00:04:48,900
should be about right

135
00:04:48,900 --> 00:04:51,060
uh type of memory we're going to use to

136
00:04:51,060 --> 00:04:52,800
commit and Reserve so once it's accessed

137
00:04:52,800 --> 00:04:54,540
it doesn't delete itself and then the

138
00:04:54,540 --> 00:04:55,680
protection level we're going to just

139
00:04:55,680 --> 00:04:57,600
read write execute because we need to be

140
00:04:57,600 --> 00:04:59,580
able to access it right copy to it and

141
00:04:59,580 --> 00:05:01,380
actually run it

142
00:05:01,380 --> 00:05:03,300
great thread there's a lot of function

143
00:05:03,300 --> 00:05:04,440
arguments that we're going to skip over

144
00:05:04,440 --> 00:05:06,419
but the really important one is the lp

145
00:05:06,419 --> 00:05:08,639
start address which is where to actually

146
00:05:08,639 --> 00:05:12,180
start the execution uh in which case AKA

147
00:05:12,180 --> 00:05:14,160
our Shell Code

148
00:05:14,160 --> 00:05:16,800
and the DW creation flag zero being

149
00:05:16,800 --> 00:05:18,600
start immediately

150
00:05:18,600 --> 00:05:21,180
here's the msdn payload for you know

151
00:05:21,180 --> 00:05:24,060
function prototype for it that's boring

152
00:05:24,060 --> 00:05:25,259
we're going to skip through that and

153
00:05:25,259 --> 00:05:27,840
then wait for single object so when if

154
00:05:27,840 --> 00:05:28,800
we were to actually load this without

155
00:05:28,800 --> 00:05:30,840
wait for single object the program would

156
00:05:30,840 --> 00:05:33,180
finish itself and just close itself out

157
00:05:33,180 --> 00:05:36,000
with the thread you know not finished so

158
00:05:36,000 --> 00:05:37,560
this keeps our program open while the

159
00:05:37,560 --> 00:05:39,720
Shell Code actually runs uh we'll pass

160
00:05:39,720 --> 00:05:42,539
in our thread and then a negative one or

161
00:05:42,539 --> 00:05:45,180
all F's and hexadecimal do tell it to

162
00:05:45,180 --> 00:05:46,800
wait forever

163
00:05:46,800 --> 00:05:49,259
you can see it in the program and the

164
00:05:49,259 --> 00:05:51,300
main function you can see our long byte

165
00:05:51,300 --> 00:05:53,940
string along with the virtual Alec

166
00:05:53,940 --> 00:05:56,820
copying memory into it uh the create

167
00:05:56,820 --> 00:05:58,979
thread call with all of basically

168
00:05:58,979 --> 00:06:01,860
everything being default notice the hmm

169
00:06:01,860 --> 00:06:03,840
call here which aligns with virtual Alec

170
00:06:03,840 --> 00:06:06,240
and then wait for single object

171
00:06:06,240 --> 00:06:08,520
so now let's check our work

172
00:06:08,520 --> 00:06:10,440
uh we can use a bunch of sandbox

173
00:06:10,440 --> 00:06:13,380
Checkers to see if this is detected or

174
00:06:13,380 --> 00:06:14,699
things like threat check or Defender

175
00:06:14,699 --> 00:06:17,580
check we're going to use anti-scan.me as

176
00:06:17,580 --> 00:06:19,979
virustotal will actually send samples to

177
00:06:19,979 --> 00:06:21,900
the vendors and I don't want to burn my

178
00:06:21,900 --> 00:06:23,639
own techniques by suspending to virus

179
00:06:23,639 --> 00:06:25,319
total if there's one thing you can get

180
00:06:25,319 --> 00:06:27,180
out of this talk if you are a malware

181
00:06:27,180 --> 00:06:29,580
Dev do not upload to virustotal you're

182
00:06:29,580 --> 00:06:31,680
tattling on yourself

183
00:06:31,680 --> 00:06:34,380
so right now we're at 13 out of 26

184
00:06:34,380 --> 00:06:36,660
detected which is not bad but we can

185
00:06:36,660 --> 00:06:38,280
definitely do better then Defender

186
00:06:38,280 --> 00:06:40,020
caught it so basically anything we would

187
00:06:40,020 --> 00:06:41,340
ever try to run on this would get

188
00:06:41,340 --> 00:06:43,680
flagged by Defender so antivirus saved

189
00:06:43,680 --> 00:06:45,720
the day right well yes but actually no

190
00:06:45,720 --> 00:06:47,460
we can get around it and it's very

191
00:06:47,460 --> 00:06:49,440
trivial as some other uh talks that I

192
00:06:49,440 --> 00:06:50,880
had mentioned

193
00:06:50,880 --> 00:06:53,460
so if we actually go back to the

194
00:06:53,460 --> 00:06:55,500
anti-scan.me if you look down at Windows

195
00:06:55,500 --> 00:06:57,479
Defender and the bottom right it says

196
00:06:57,479 --> 00:06:58,860
interpreter which the only thing

197
00:06:58,860 --> 00:07:00,720
indicating interpreter in this payload

198
00:07:00,720 --> 00:07:02,580
so far is the Shell Code

199
00:07:02,580 --> 00:07:05,220
so we can just you know mangle the Shell

200
00:07:05,220 --> 00:07:07,080
Code a bit and it should just execute

201
00:07:07,080 --> 00:07:09,539
fine so we can either rewrite the Shell

202
00:07:09,539 --> 00:07:11,880
Code so it's custom or we can just

203
00:07:11,880 --> 00:07:13,620
obfuscate it a little bit obfuscation

204
00:07:13,620 --> 00:07:14,940
seems like less work so we're going to

205
00:07:14,940 --> 00:07:16,680
go that route uh some of the

206
00:07:16,680 --> 00:07:18,000
obfuscations methods that are common

207
00:07:18,000 --> 00:07:20,819
base64 string it uh we can use the

208
00:07:20,819 --> 00:07:23,099
Caesar Cipher so every hexadecimal bit

209
00:07:23,099 --> 00:07:25,020
just increases by one and we subtract it

210
00:07:25,020 --> 00:07:27,780
all by one at one time AES encryption

211
00:07:27,780 --> 00:07:29,520
but be wary of that one usually start

212
00:07:29,520 --> 00:07:30,960
triggering ransomware you know

213
00:07:30,960 --> 00:07:32,520
signatures when you start using AES and

214
00:07:32,520 --> 00:07:34,620
unsond executables or we can just plug

215
00:07:34,620 --> 00:07:36,120
it in backwards which is my absolute

216
00:07:36,120 --> 00:07:37,380
favorite

217
00:07:37,380 --> 00:07:38,699
so we're just going to plug it in

218
00:07:38,699 --> 00:07:40,319
backwards and then we'll just do a radar

219
00:07:40,319 --> 00:07:42,660
reverse runtime that'll uh now it has a

220
00:07:42,660 --> 00:07:44,400
different signature and it's super easy

221
00:07:44,400 --> 00:07:46,380
to implement we've added two lines of

222
00:07:46,380 --> 00:07:47,460
code

223
00:07:47,460 --> 00:07:49,259
so now we're down to 8 out of 26 after

224
00:07:49,259 --> 00:07:51,060
we do that and now we're beating

225
00:07:51,060 --> 00:07:52,620
Defender just by sticking the array in

226
00:07:52,620 --> 00:07:53,639
backwards

227
00:07:53,639 --> 00:07:55,139
so but because I think we can still do

228
00:07:55,139 --> 00:07:56,340
better

229
00:07:56,340 --> 00:07:58,139
here's the code so far in case I went

230
00:07:58,139 --> 00:07:59,699
through fast on anybody

231
00:07:59,699 --> 00:08:01,860
uh as you can see it's not a massive

232
00:08:01,860 --> 00:08:03,539
block now it's actually a single line

233
00:08:03,539 --> 00:08:05,039
because I just found it online site to

234
00:08:05,039 --> 00:08:07,199
reverse the array and then there's a DOT

235
00:08:07,199 --> 00:08:10,139
reverse at the end it cropping is hard

236
00:08:10,139 --> 00:08:12,599
but that's all we did so far and you

237
00:08:12,599 --> 00:08:15,240
know total side of the code

238
00:08:15,240 --> 00:08:17,520
so so far if we go back it seems like we

239
00:08:17,520 --> 00:08:19,199
have a lot of heuristic checks uh

240
00:08:19,199 --> 00:08:20,520
catching us

241
00:08:20,520 --> 00:08:24,060
uh I do want to point out that uh we can

242
00:08:24,060 --> 00:08:25,199
just change the behavior of the

243
00:08:25,199 --> 00:08:26,340
executable

244
00:08:26,340 --> 00:08:28,680
uh most heuristic bypass techniques

245
00:08:28,680 --> 00:08:31,560
really disproportionately affect the

246
00:08:31,560 --> 00:08:33,899
portability of your malware so I don't

247
00:08:33,899 --> 00:08:35,399
like doing a lot of just you know

248
00:08:35,399 --> 00:08:36,899
sandbox checks so we're going to start

249
00:08:36,899 --> 00:08:39,659
by changing it out so instead of using

250
00:08:39,659 --> 00:08:42,979
threads what if we use fibers

251
00:08:43,620 --> 00:08:46,260
so five bits fibers are a unit of

252
00:08:46,260 --> 00:08:48,540
execution scheduled by an executable

253
00:08:48,540 --> 00:08:50,399
that run it like inside threads think of

254
00:08:50,399 --> 00:08:52,380
it as like a thread and a thread or like

255
00:08:52,380 --> 00:08:56,399
a task and a task essentially so threads

256
00:08:56,399 --> 00:08:58,440
are monitored by the windows kernel so

257
00:08:58,440 --> 00:08:59,880
there's a lot of detections baked into

258
00:08:59,880 --> 00:09:01,920
them fibers are not baked into the

259
00:09:01,920 --> 00:09:03,839
windows kernel callbacks so they are

260
00:09:03,839 --> 00:09:05,640
inherently stealthier and are a lot

261
00:09:05,640 --> 00:09:07,140
simpler than threads

262
00:09:07,140 --> 00:09:09,420
so instead of using the create thread to

263
00:09:09,420 --> 00:09:11,399
wait for a single object we'll just need

264
00:09:11,399 --> 00:09:13,320
create thread to fiber switch create

265
00:09:13,320 --> 00:09:16,140
fiber and switch to fiber which are

266
00:09:16,140 --> 00:09:17,820
infinitely simpler than the first apis

267
00:09:17,820 --> 00:09:20,519
so convert thread to fiber only fibers

268
00:09:20,519 --> 00:09:23,519
can make fibers so at the beginning of

269
00:09:23,519 --> 00:09:26,040
our main function we have to you know

270
00:09:26,040 --> 00:09:28,760
convert the master thread to a fiber

271
00:09:28,760 --> 00:09:31,200
then we actually create a fiber instead

272
00:09:31,200 --> 00:09:34,440
of a thread which only takes a size how

273
00:09:34,440 --> 00:09:36,540
we want to start it and an optional

274
00:09:36,540 --> 00:09:38,339
variable which is doesn't need it which

275
00:09:38,339 --> 00:09:40,380
is so much simpler than a thread

276
00:09:40,380 --> 00:09:42,240
and then switch to fiber just to tell it

277
00:09:42,240 --> 00:09:44,040
what to run

278
00:09:44,040 --> 00:09:45,420
so now it looks like the following

279
00:09:45,420 --> 00:09:48,959
notice at the top uh by void static void

280
00:09:48,959 --> 00:09:51,420
main we have the master fiber call and

281
00:09:51,420 --> 00:09:53,399
then instead of having create thread and

282
00:09:53,399 --> 00:09:55,560
wait for single object we have create

283
00:09:55,560 --> 00:09:58,500
fiber and switch to fiber implemented

284
00:09:58,500 --> 00:10:00,120
now

285
00:10:00,120 --> 00:10:01,920
now we're down to 5 out of 26 just

286
00:10:01,920 --> 00:10:03,720
making a pretty simple switch

287
00:10:03,720 --> 00:10:05,100
uh still getting hit with some of the

288
00:10:05,100 --> 00:10:06,480
heuristics but we did manage to get

289
00:10:06,480 --> 00:10:07,980
around a few things but I think we can

290
00:10:07,980 --> 00:10:09,899
still do better

291
00:10:09,899 --> 00:10:13,680
so we made direct calls to the windows

292
00:10:13,680 --> 00:10:14,760
API

293
00:10:14,760 --> 00:10:16,620
uh instead of making the direct calls we

294
00:10:16,620 --> 00:10:18,480
can kind of go roundabout and make it

295
00:10:18,480 --> 00:10:20,040
stealthier so it's not you know showing

296
00:10:20,040 --> 00:10:22,440
plainest day that we're imported uh

297
00:10:22,440 --> 00:10:24,300
because we can do this with delegates in

298
00:10:24,300 --> 00:10:26,640
C sharp which are essentially you know

299
00:10:26,640 --> 00:10:29,600
custom data types

300
00:10:29,820 --> 00:10:31,860
uh this is really similar how D invoke

301
00:10:31,860 --> 00:10:33,779
works if anyone's show of hands who's

302
00:10:33,779 --> 00:10:36,300
familiar with the D invoke project

303
00:10:36,300 --> 00:10:37,740
okay

304
00:10:37,740 --> 00:10:40,560
so D invoke is just a custom stealthier

305
00:10:40,560 --> 00:10:42,060
way to call Windows apis without

306
00:10:42,060 --> 00:10:44,040
directly calling them which really

307
00:10:44,040 --> 00:10:46,140
messes up signature checking because if

308
00:10:46,140 --> 00:10:47,760
something's not creating a thread why

309
00:10:47,760 --> 00:10:49,260
search for you know why search threads

310
00:10:49,260 --> 00:10:50,519
if it's not showing up and it doesn't

311
00:10:50,519 --> 00:10:52,680
import so it's just stealthier way to

312
00:10:52,680 --> 00:10:55,800
call functions uh shorter or you know

313
00:10:55,800 --> 00:10:57,360
more simple

314
00:10:57,360 --> 00:11:00,060
so effectively works by running the load

315
00:11:00,060 --> 00:11:02,760
Library a and the get proc address apis

316
00:11:02,760 --> 00:11:05,040
calls from Windows which just loads a

317
00:11:05,040 --> 00:11:07,079
dll and then hunts for a function inside

318
00:11:07,079 --> 00:11:08,399
the dll

319
00:11:08,399 --> 00:11:10,320
and then we can just create a delegate

320
00:11:10,320 --> 00:11:13,260
based off of the pointer to it

321
00:11:13,260 --> 00:11:15,720
so this is a really messy import section

322
00:11:15,720 --> 00:11:18,300
bear with me but you can see we have the

323
00:11:18,300 --> 00:11:21,180
P invokes now or load library and get

324
00:11:21,180 --> 00:11:22,560
proc address

325
00:11:22,560 --> 00:11:24,600
and then we at the bottom here what used

326
00:11:24,600 --> 00:11:26,579
to be our direct calls from virtual

327
00:11:26,579 --> 00:11:28,560
protect convert thread to fiber create

328
00:11:28,560 --> 00:11:31,560
fiber Etc now they're unmanaged function

329
00:11:31,560 --> 00:11:34,200
pointers uh down there's the Bottom's

330
00:11:34,200 --> 00:11:35,820
the same the same data types but now

331
00:11:35,820 --> 00:11:38,480
it's a delegate

332
00:11:38,839 --> 00:11:41,519
so then we have to actually directly

333
00:11:41,519 --> 00:11:42,779
call the functions that we want to map

334
00:11:42,779 --> 00:11:45,060
to so you can see it here with get proc

335
00:11:45,060 --> 00:11:47,160
address and load Library

336
00:11:47,160 --> 00:11:48,839
and then we have to actually declare

337
00:11:48,839 --> 00:11:51,060
them as our unique functions which

338
00:11:51,060 --> 00:11:53,519
effectively do the same thing but more

339
00:11:53,519 --> 00:11:55,680
roundabout and are just inherently

340
00:11:55,680 --> 00:11:57,000
stealthier because we're not directly

341
00:11:57,000 --> 00:11:58,860
calling

342
00:11:58,860 --> 00:12:00,779
here's our new new main function we have

343
00:12:00,779 --> 00:12:02,940
our our long line of the data types

344
00:12:02,940 --> 00:12:05,160
there Master fiber is now the new

345
00:12:05,160 --> 00:12:07,920
function instead of switch to fiber

346
00:12:07,920 --> 00:12:10,019
and now instead of switch to fiber it's

347
00:12:10,019 --> 00:12:11,459
just called my switch and now we have

348
00:12:11,459 --> 00:12:13,320
creation instead of create fiber and

349
00:12:13,320 --> 00:12:15,240
that's as it'll show up in the windows

350
00:12:15,240 --> 00:12:17,040
address table instead of actually

351
00:12:17,040 --> 00:12:19,440
checking you know for the main Windows

352
00:12:19,440 --> 00:12:21,660
API

353
00:12:21,660 --> 00:12:24,899
I'm sorry I'm going kind of fast here

354
00:12:24,899 --> 00:12:26,880
but so just a quick note on background

355
00:12:26,880 --> 00:12:29,600
heuristics so we'll check here in a sec

356
00:12:29,600 --> 00:12:32,399
Windows whenever windows or any

357
00:12:32,399 --> 00:12:34,260
antivirus doesn't know what something is

358
00:12:34,260 --> 00:12:36,180
and runs it for the first time it'll run

359
00:12:36,180 --> 00:12:37,740
it for a few seconds inside of any

360
00:12:37,740 --> 00:12:40,140
sandbox and check what its behavior and

361
00:12:40,140 --> 00:12:41,940
then if the behavior does certain things

362
00:12:41,940 --> 00:12:45,600
it'll deny the actual execution flow of

363
00:12:45,600 --> 00:12:47,579
the malware or legitimate program in

364
00:12:47,579 --> 00:12:48,839
some cases

365
00:12:48,839 --> 00:12:51,000
so we can actually detect whether we're

366
00:12:51,000 --> 00:12:52,920
not in a sandbox with some code checks

367
00:12:52,920 --> 00:12:55,079
and see if it's running and if we are

368
00:12:55,079 --> 00:12:57,420
running in that sandbox just exit

369
00:12:57,420 --> 00:12:59,100
gracefully you know right through a file

370
00:12:59,100 --> 00:13:02,040
do something not malicious and then the

371
00:13:02,040 --> 00:13:03,839
sandbox or you know antivirus running

372
00:13:03,839 --> 00:13:06,480
the sandbox goes oh we're good never

373
00:13:06,480 --> 00:13:08,399
mind it's safe you can run it and then

374
00:13:08,399 --> 00:13:10,019
we actually you know phone home and have

375
00:13:10,019 --> 00:13:12,180
our you know fun starts

376
00:13:12,180 --> 00:13:14,040
uh this should really be done as a last

377
00:13:14,040 --> 00:13:15,060
resort

378
00:13:15,060 --> 00:13:16,500
as it really negatively

379
00:13:16,500 --> 00:13:18,480
disproportionately affects your

380
00:13:18,480 --> 00:13:21,120
portability of your malware so some

381
00:13:21,120 --> 00:13:22,920
really common checks is check the

382
00:13:22,920 --> 00:13:26,160
hosting or the executable name so when

383
00:13:26,160 --> 00:13:28,800
files run in a sandbox they're usually

384
00:13:28,800 --> 00:13:30,660
named gibberish it's the random like

385
00:13:30,660 --> 00:13:33,600
base64 encoded string so if you check

386
00:13:33,600 --> 00:13:36,079
you know is process name

387
00:13:36,079 --> 00:13:38,399
malware.exe you know exit Great you know

388
00:13:38,399 --> 00:13:40,440
actually do the malware or else you know

389
00:13:40,440 --> 00:13:42,540
write a file or just write a line and

390
00:13:42,540 --> 00:13:44,880
close that's one common one another

391
00:13:44,880 --> 00:13:48,480
common one is to check this amount of

392
00:13:48,480 --> 00:13:50,459
CPU cores or check the memory on the PC

393
00:13:50,459 --> 00:13:53,279
has these sandboxes are limited in their

394
00:13:53,279 --> 00:13:55,139
allocation and can't actually touch the

395
00:13:55,139 --> 00:13:57,899
main you know Master posts otherwise you

396
00:13:57,899 --> 00:13:59,279
could break out of them

397
00:13:59,279 --> 00:14:01,019
but you know the off chance you pop a

398
00:14:01,019 --> 00:14:02,820
really weak computer or you know an

399
00:14:02,820 --> 00:14:05,040
outdated system uh you're not going to

400
00:14:05,040 --> 00:14:05,940
run and that can be the difference

401
00:14:05,940 --> 00:14:07,740
between a good pen test and a bad pen

402
00:14:07,740 --> 00:14:08,579
test

403
00:14:08,579 --> 00:14:10,260
so that's typically you just want to do

404
00:14:10,260 --> 00:14:12,060
things like that as a last resort if it

405
00:14:12,060 --> 00:14:14,700
does come to that uh checkpoint uh they

406
00:14:14,700 --> 00:14:16,980
have a great resource guide as evasion

407
00:14:16,980 --> 00:14:20,579
technique so evasions.checkpoint.com

408
00:14:20,880 --> 00:14:22,560
all right so let's disable logging on

409
00:14:22,560 --> 00:14:24,300
our process now that we have a good

410
00:14:24,300 --> 00:14:27,360
functioning 3 out of 26 malware

411
00:14:27,360 --> 00:14:29,880
so Windows logs applications performance

412
00:14:29,880 --> 00:14:32,399
for every process this is known as event

413
00:14:32,399 --> 00:14:33,899
tracing for Windows so when you go to

414
00:14:33,899 --> 00:14:35,760
Event Viewer this is really the

415
00:14:35,760 --> 00:14:37,200
technology behind the scenes that's

416
00:14:37,200 --> 00:14:39,899
creating logs uh this happens both at

417
00:14:39,899 --> 00:14:42,420
user land and kernel level uh the

418
00:14:42,420 --> 00:14:44,100
function that's actually responsible for

419
00:14:44,100 --> 00:14:46,560
writing your logs to Event Viewer is etw

420
00:14:46,560 --> 00:14:49,860
event right and it's inside of ntdll

421
00:14:49,860 --> 00:14:51,959
we can use load library and get proc

422
00:14:51,959 --> 00:14:53,940
addressed actually to overwrite the

423
00:14:53,940 --> 00:14:56,040
function to just return and exit

424
00:14:56,040 --> 00:14:57,680
gracefully every time it's called

425
00:14:57,680 --> 00:14:59,940
effectively killing logging on our

426
00:14:59,940 --> 00:15:02,040
malware process

427
00:15:02,040 --> 00:15:03,899
uh we're gonna just take a page out of

428
00:15:03,899 --> 00:15:06,480
sharpsplate for example which is a known

429
00:15:06,480 --> 00:15:10,440
C sharp just a bass line kind of

430
00:15:10,440 --> 00:15:12,720
malicious Cypress C sharp it's on GitHub

431
00:15:12,720 --> 00:15:15,300
uh great Project Check It Out

432
00:15:15,300 --> 00:15:18,000
so effectively load Library a get proc

433
00:15:18,000 --> 00:15:20,339
address are called we're going to make

434
00:15:20,339 --> 00:15:22,980
that address you know in memory writable

435
00:15:22,980 --> 00:15:25,320
with virtual protect and we're just

436
00:15:25,320 --> 00:15:26,519
going to write over it so it just

437
00:15:26,519 --> 00:15:28,980
returns true

438
00:15:28,980 --> 00:15:32,339
uh this is different between x86 and x64

439
00:15:32,339 --> 00:15:34,620
as we discussed previously Shell Code

440
00:15:34,620 --> 00:15:37,620
can be 32 or 64-bit so we needed to

441
00:15:37,620 --> 00:15:39,420
check if we're actually 32 or 64-bit

442
00:15:39,420 --> 00:15:41,880
before we actually patch it

443
00:15:41,880 --> 00:15:44,760
so here's some more code uh you can see

444
00:15:44,760 --> 00:15:47,820
where kernel 30 ntdll and kernel 32 are

445
00:15:47,820 --> 00:15:50,040
loaded and we're getting the actual

446
00:15:50,040 --> 00:15:53,399
address of etw event right

447
00:15:53,399 --> 00:15:55,860
then you can see a conditional statement

448
00:15:55,860 --> 00:15:59,160
if we're a 64-bit process on a 64-bit

449
00:15:59,160 --> 00:16:00,060
host

450
00:16:00,060 --> 00:16:03,360
uh write this assembly in memory so

451
00:16:03,360 --> 00:16:04,800
every time this function is called it

452
00:16:04,800 --> 00:16:07,680
returns true and if it's 32-bit do these

453
00:16:07,680 --> 00:16:10,079
other lines so it always you know

454
00:16:10,079 --> 00:16:15,000
patches as true effectively killing etw

455
00:16:15,000 --> 00:16:16,980
uh here's a quick definition of virtual

456
00:16:16,980 --> 00:16:19,380
protects since we didn't cover it yet uh

457
00:16:19,380 --> 00:16:21,000
very this should look pretty similar to

458
00:16:21,000 --> 00:16:23,040
Virtual lock other than it just saves

459
00:16:23,040 --> 00:16:25,740
the old permissions of the chunk of

460
00:16:25,740 --> 00:16:27,720
memory

461
00:16:27,720 --> 00:16:30,600
and here we are actually patching it uh

462
00:16:30,600 --> 00:16:32,220
you can see the protect call which is

463
00:16:32,220 --> 00:16:34,440
virtual protect uh marking it as read

464
00:16:34,440 --> 00:16:36,720
write execute we're copying our little

465
00:16:36,720 --> 00:16:38,459
byte array and then we're setting it

466
00:16:38,459 --> 00:16:39,959
back to whatever the heck it was before

467
00:16:39,959 --> 00:16:41,399
we touched it

468
00:16:41,399 --> 00:16:43,740
and funny enough this didn't affect our

469
00:16:43,740 --> 00:16:46,199
you know detection at all so we've

470
00:16:46,199 --> 00:16:48,839
effectively broken all Sim detections on

471
00:16:48,839 --> 00:16:50,639
our process without you know doing

472
00:16:50,639 --> 00:16:52,620
anything like modifications without

473
00:16:52,620 --> 00:16:54,720
actually affecting our portability or

474
00:16:54,720 --> 00:16:56,880
increasing our detection score

475
00:16:56,880 --> 00:16:58,500
and we can do this with other functions

476
00:16:58,500 --> 00:17:00,839
too uh is that just show hands who knows

477
00:17:00,839 --> 00:17:02,459
what amsi is

478
00:17:02,459 --> 00:17:03,540
from

479
00:17:03,540 --> 00:17:06,240
okay so amsi effectively is Windows

480
00:17:06,240 --> 00:17:08,699
Defender in memory Defender by default

481
00:17:08,699 --> 00:17:10,919
really only checks the actual what's on

482
00:17:10,919 --> 00:17:13,439
disk for detected things if you get

483
00:17:13,439 --> 00:17:16,260
something straight into memory uh amsi

484
00:17:16,260 --> 00:17:17,939
takes over and it's the memory component

485
00:17:17,939 --> 00:17:20,760
of Windows Defender the same Technique

486
00:17:20,760 --> 00:17:23,099
we did just to patch out locking we can

487
00:17:23,099 --> 00:17:26,339
do with Windows Defender itself so every

488
00:17:26,339 --> 00:17:28,400
most processes will be patched in with

489
00:17:28,400 --> 00:17:31,799
amsi.dll as the kernel detects a new

490
00:17:31,799 --> 00:17:33,720
process has started it automatically

491
00:17:33,720 --> 00:17:36,419
patches amsi.dlln

492
00:17:36,419 --> 00:17:38,100
and we can just patch it out to avoid

493
00:17:38,100 --> 00:17:39,660
detection so we're going to use sharp

494
00:17:39,660 --> 00:17:41,640
split again as they have a great amsi

495
00:17:41,640 --> 00:17:42,600
sample

496
00:17:42,600 --> 00:17:45,900
we're going to call amsi.dll again

497
00:17:45,900 --> 00:17:48,660
Market read write executable throw some

498
00:17:48,660 --> 00:17:51,120
bytes at it to return true always and

499
00:17:51,120 --> 00:17:52,919
then just clean it up

500
00:17:52,919 --> 00:17:54,600
here's some more code if this looks

501
00:17:54,600 --> 00:17:57,240
similar to the etw event right great you

502
00:17:57,240 --> 00:17:59,760
are seeing patterns

503
00:17:59,760 --> 00:18:02,400
so we checked if it's 64-bit or 32-bit

504
00:18:02,400 --> 00:18:05,820
and we load in amsi.dll

505
00:18:05,820 --> 00:18:08,880
you know we Market read write execute we

506
00:18:08,880 --> 00:18:10,860
send our byte array in and then we set

507
00:18:10,860 --> 00:18:12,600
it back to whatever it was

508
00:18:12,600 --> 00:18:14,760
oh no this did actually increase our

509
00:18:14,760 --> 00:18:16,919
score not Defender but a couple of other

510
00:18:16,919 --> 00:18:17,880
ones

511
00:18:17,880 --> 00:18:21,360
so amsi is very common now especially in

512
00:18:21,360 --> 00:18:23,640
Powershell malware so anything that runs

513
00:18:23,640 --> 00:18:25,799
Powershell is just inherently in memory

514
00:18:25,799 --> 00:18:29,100
unless you download the dot PS1 to disk

515
00:18:29,100 --> 00:18:32,160
so this amsi is the first step to all

516
00:18:32,160 --> 00:18:33,840
Powershell malware so it's a little more

517
00:18:33,840 --> 00:18:36,179
signature than etw

518
00:18:36,179 --> 00:18:38,400
so just to wrap up Shell Code Runners

519
00:18:38,400 --> 00:18:40,260
are very popular for as a first stage

520
00:18:40,260 --> 00:18:41,960
for command and control servers

521
00:18:41,960 --> 00:18:44,280
signature checks on Shell Code Runners

522
00:18:44,280 --> 00:18:46,200
and malware in general is Trivial at

523
00:18:46,200 --> 00:18:48,299
best to bypass we can do things just

524
00:18:48,299 --> 00:18:49,740
like you know putting things in

525
00:18:49,740 --> 00:18:52,140
backwards and reversing it uh heuristic

526
00:18:52,140 --> 00:18:54,120
bypass methods exist but do affect

527
00:18:54,120 --> 00:18:56,220
portability so you're better off just

528
00:18:56,220 --> 00:18:57,780
changing your static you go another

529
00:18:57,780 --> 00:19:00,480
route like fibers instead of threads and

530
00:19:00,480 --> 00:19:03,000
you know just changing up your inherent

531
00:19:03,000 --> 00:19:05,220
behavior and I'm going to give a brief

532
00:19:05,220 --> 00:19:07,559
challenge to all of the viewers so all

533
00:19:07,559 --> 00:19:09,539
of this code will be available on my

534
00:19:09,539 --> 00:19:13,320
GitHub at github.com at Xerox Hub uh I

535
00:19:13,320 --> 00:19:15,059
want everyone to put in their own Shell

536
00:19:15,059 --> 00:19:15,780
Code

537
00:19:15,780 --> 00:19:20,299
uh play around with amsi uh bypasses and

538
00:19:20,299 --> 00:19:22,980
amsi.vale is an amazing website for

539
00:19:22,980 --> 00:19:26,039
generating amsi bypassing Scripts

540
00:19:26,039 --> 00:19:27,780
and just see if you can find your own

541
00:19:27,780 --> 00:19:29,299
coding in see how low you can get your

542
00:19:29,299 --> 00:19:31,620
anti-scan score it's honestly a really

543
00:19:31,620 --> 00:19:33,660
fun hobby just to try to write your own

544
00:19:33,660 --> 00:19:35,520
malware and it's almost like a puzzle to

545
00:19:35,520 --> 00:19:39,059
actually you know get a 0 out of 26 on

546
00:19:39,059 --> 00:19:42,020
Amazon you know on Amazon

547
00:19:42,020 --> 00:19:44,580
anti-scan.me excuse me and it's a great

548
00:19:44,580 --> 00:19:46,919
Pastime just exploring this is how I got

549
00:19:46,919 --> 00:19:48,780
my feet into red teaming and it's a

550
00:19:48,780 --> 00:19:50,400
great way to really get your feet wet

551
00:19:50,400 --> 00:19:52,620
and just change from Blue to red

552
00:19:52,620 --> 00:19:56,719
all right thank you uh how am I on time

553
00:19:56,840 --> 00:19:58,799
wow this is like wow every time I

554
00:19:58,799 --> 00:20:00,419
rehearse this I was like eight minutes

555
00:20:00,419 --> 00:20:02,160
over this does anyone have any questions

556
00:20:02,160 --> 00:20:04,740
I know that was really fast

557
00:20:04,740 --> 00:20:06,900
yes sir

558
00:20:06,900 --> 00:20:09,370
yeah oh constantly yeah yeah

559
00:20:09,370 --> 00:20:10,580
[Music]

560
00:20:10,580 --> 00:20:13,559
all the time yeah they uh

561
00:20:13,559 --> 00:20:15,000
I can't really talk what I write for

562
00:20:15,000 --> 00:20:16,440
them but I do write some custom things

563
00:20:16,440 --> 00:20:17,340
for them

564
00:20:17,340 --> 00:20:19,260
and honestly it's my favorite part of

565
00:20:19,260 --> 00:20:20,880
the job is just actually just knowing

566
00:20:20,880 --> 00:20:22,740
I'm helping the other red teamers and

567
00:20:22,740 --> 00:20:25,919
judge is getting around things

568
00:20:25,919 --> 00:20:28,679
any other questions

569
00:20:28,679 --> 00:20:31,220
yeah

570
00:20:32,700 --> 00:20:35,179
right

571
00:20:43,320 --> 00:20:46,559
okay so the question was uh I talked

572
00:20:46,559 --> 00:20:48,240
about delegates but am I seeing any kind

573
00:20:48,240 --> 00:20:50,280
of like reflection especially in like

574
00:20:50,280 --> 00:20:52,860
dot net like C sharp or Powershell uh

575
00:20:52,860 --> 00:20:54,679
yes we do do a lot of reflection

576
00:20:54,679 --> 00:20:58,080
especially in a lot of custom things uh

577
00:20:58,080 --> 00:21:01,620
so most uh staged payloads especially in

578
00:21:01,620 --> 00:21:03,480
like Metasploit and Cobalt strike

579
00:21:03,480 --> 00:21:06,660
actually use reflection for staged uh

580
00:21:06,660 --> 00:21:08,700
all staged payloads through Mana control

581
00:21:08,700 --> 00:21:12,240
well not all but most they open up a

582
00:21:12,240 --> 00:21:16,140
chunk of memory download a DOT dll file

583
00:21:16,140 --> 00:21:18,179
that the command and control server

584
00:21:18,179 --> 00:21:20,520
opens up to download and then they just

585
00:21:20,520 --> 00:21:22,440
inject the bytes into memory and execute

586
00:21:22,440 --> 00:21:23,820
them from there sometimes they're

587
00:21:23,820 --> 00:21:25,740
encoded sometimes they're they're not

588
00:21:25,740 --> 00:21:27,900
depends on you know the profile and how

589
00:21:27,900 --> 00:21:29,820
the C2 is set up but the reflections

590
00:21:29,820 --> 00:21:31,799
still very prevalent and it's very it's

591
00:21:31,799 --> 00:21:34,620
a good combo with um any kind of like

592
00:21:34,620 --> 00:21:36,900
anti-malware scan interface or amsi

593
00:21:36,900 --> 00:21:38,760
because it's not touching disk it's all

594
00:21:38,760 --> 00:21:41,039
in memory so if you if you take down

595
00:21:41,039 --> 00:21:44,520
amsi you know memory is blind unless

596
00:21:44,520 --> 00:21:45,480
you're running you know a really good

597
00:21:45,480 --> 00:21:47,340
EDR

598
00:21:47,340 --> 00:21:50,418
any other questions

599
00:21:56,340 --> 00:22:00,020
about the site uh amsi.fail

600
00:22:00,020 --> 00:22:03,720
actually I might be able to demo it

601
00:22:03,720 --> 00:22:04,919
[Music]

602
00:22:04,919 --> 00:22:08,760
I did I will be pushing the GitHub repo

603
00:22:08,760 --> 00:22:12,919
I wasn't all like oh dude uh

604
00:22:14,880 --> 00:22:16,860
is it back

605
00:22:16,860 --> 00:22:18,299
okay

606
00:22:18,299 --> 00:22:21,179
okay I don't have I do not have internet

607
00:22:21,179 --> 00:22:24,299
shoot I was gonna demo AMS I don't fail

608
00:22:24,299 --> 00:22:25,980
so

609
00:22:25,980 --> 00:22:28,080
but yeah

610
00:22:28,080 --> 00:22:30,840
okay I did not hook up the internet

611
00:22:30,840 --> 00:22:32,820
earlier but yeah the site is uh

612
00:22:32,820 --> 00:22:35,780
amsi.dale

613
00:22:37,380 --> 00:22:40,620
and my GitHub it'll be GitHub my GitHub

614
00:22:40,620 --> 00:22:44,100
profile is zero X hop hop and there will

615
00:22:44,100 --> 00:22:45,380
be a zero X

616
00:22:45,380 --> 00:22:47,760
hop.github.io where I do right now our

617
00:22:47,760 --> 00:22:50,100
development blogs which all of them are

618
00:22:50,100 --> 00:22:52,919
give or take this presentation

619
00:22:52,919 --> 00:22:55,100
foreign

620
00:23:13,340 --> 00:23:16,200
most of the oscp stuff essentially is

621
00:23:16,200 --> 00:23:17,940
taking a public exploit off of GitHub

622
00:23:17,940 --> 00:23:19,500
and just getting it to work friendly

623
00:23:19,500 --> 00:23:20,880
this would be more in line with

624
00:23:20,880 --> 00:23:24,240
offensive Securities pen 300 or their OS

625
00:23:24,240 --> 00:23:25,500
EP course

626
00:23:25,500 --> 00:23:27,720
uh it's an excellent course I went

627
00:23:27,720 --> 00:23:28,980
through it and it's actually how I

628
00:23:28,980 --> 00:23:30,780
really got my start and all this and if

629
00:23:30,780 --> 00:23:32,340
you guys liked this talk I highly

630
00:23:32,340 --> 00:23:34,620
recommend pen 300 legitimately the best

631
00:23:34,620 --> 00:23:35,940
course I've ever taken for offensive

632
00:23:35,940 --> 00:23:38,120
security

633
00:23:39,320 --> 00:23:41,760
pen 300 that's right

634
00:23:41,760 --> 00:23:43,799
Ellen the question was at what level was

635
00:23:43,799 --> 00:23:46,380
this uh presentation was this oscp or or

636
00:23:46,380 --> 00:23:48,919
above it

637
00:23:59,039 --> 00:24:02,000
no any other questions

638
00:24:05,580 --> 00:24:07,330
all right thank you

639
00:24:07,330 --> 00:24:12,780
[Applause]

640
00:24:12,780 --> 00:24:15,600
this talk was a part of our 2022 secure

641
00:24:15,600 --> 00:24:18,059
West Virginia Lucky 13 conference if you

642
00:24:18,059 --> 00:24:19,620
would like more information about this

643
00:24:19,620 --> 00:24:21,299
talk or our speaker check the

644
00:24:21,299 --> 00:24:23,520
description below and if you enjoyed the

645
00:24:23,520 --> 00:24:25,260
content consider liking and sharing this

646
00:24:25,260 --> 00:24:27,539
video for more information on secure

647
00:24:27,539 --> 00:24:29,039
West Virginia or you want to stay

648
00:24:29,039 --> 00:24:31,140
updated with the latest upcoming events

649
00:24:31,140 --> 00:24:34,799
follow us on Twitter at securewvcon or

650
00:24:34,799 --> 00:24:37,740
visit our website securewv.org

651
00:24:37,740 --> 00:24:39,960
we would like also like to thank our

652
00:24:39,960 --> 00:24:42,360
2022 sponsors for being a huge part of

653
00:24:42,360 --> 00:24:45,500
Lucky 13 success

