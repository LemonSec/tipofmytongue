1
00:00:56,640 --> 00:00:58,719
and here we are again

2
00:00:58,719 --> 00:01:01,359
and after having inspected the deepness

3
00:01:01,359 --> 00:01:02,719
of hardware-based

4
00:01:02,719 --> 00:01:05,360
firmware protection mechanism it's time

5
00:01:05,360 --> 00:01:08,720
to move to another deeply technical tool

6
00:01:08,720 --> 00:01:11,040
the next speaker works as security

7
00:01:11,040 --> 00:01:12,000
researcher for

8
00:01:12,000 --> 00:01:14,720
cyber art company actually i think he is

9
00:01:14,720 --> 00:01:16,880
probably one of the worst nightmares for

10
00:01:16,880 --> 00:01:18,960
a huge number of vendors

11
00:01:18,960 --> 00:01:21,040
the number of vulnerabilities that he

12
00:01:21,040 --> 00:01:22,080
discovered in fact

13
00:01:22,080 --> 00:01:25,040
is really impressive his name is iran

14
00:01:25,040 --> 00:01:27,520
shimoni and now he will show us

15
00:01:27,520 --> 00:01:31,040
how it's possible to find 16 cbe in 60

16
00:01:31,040 --> 00:01:31,680
days

17
00:01:31,680 --> 00:01:35,200
go around hello everyone and thanks for

18
00:01:35,200 --> 00:01:37,360
attending to this online session

19
00:01:37,360 --> 00:01:41,040
about how i found 60 cvs in 60 days

20
00:01:41,040 --> 00:01:42,640
since we are after launch let's start

21
00:01:42,640 --> 00:01:44,079
with a quick mind teaser

22
00:01:44,079 --> 00:01:45,680
how to find local elevation of

23
00:01:45,680 --> 00:01:49,759
privileged vulnerabilities on windows

24
00:01:50,159 --> 00:01:52,320
well i'm not here to talk about fuzzing

25
00:01:52,320 --> 00:01:54,000
or rather symbolic execution

26
00:01:54,000 --> 00:01:56,159
or any other approach that works with

27
00:01:56,159 --> 00:01:57,119
fuzziness

28
00:01:57,119 --> 00:01:58,960
here we will see a different approach to

29
00:01:58,960 --> 00:02:00,880
find security bugs that i developed

30
00:02:00,880 --> 00:02:01,759
which i called

31
00:02:01,759 --> 00:02:05,040
mte mt stands for

32
00:02:05,040 --> 00:02:08,080
monitor trace and exploit

33
00:02:08,080 --> 00:02:10,160
in the essence of it you monitor every

34
00:02:10,160 --> 00:02:11,840
privilege process that runs on the

35
00:02:11,840 --> 00:02:12,480
system

36
00:02:12,480 --> 00:02:14,720
followed by tracing its file operations

37
00:02:14,720 --> 00:02:16,800
if those privileged file operations are

38
00:02:16,800 --> 00:02:17,920
not done with care

39
00:02:17,920 --> 00:02:19,920
we might exploit them with two simple

40
00:02:19,920 --> 00:02:21,680
file manipulation attacks

41
00:02:21,680 --> 00:02:23,200
you're probably familiar with them

42
00:02:23,200 --> 00:02:25,120
because they're not that new dll

43
00:02:25,120 --> 00:02:27,360
hijacking goes back to the year of 2000

44
00:02:27,360 --> 00:02:29,120
and james forshaw first presented the

45
00:02:29,120 --> 00:02:31,120
abuse of object manager symbolic links

46
00:02:31,120 --> 00:02:33,280
in the year of 2015.

47
00:02:33,280 --> 00:02:34,959
still by using those two file

48
00:02:34,959 --> 00:02:37,040
manipulation attacks automatically

49
00:02:37,040 --> 00:02:39,840
i found many bugs across many vendors

50
00:02:39,840 --> 00:02:41,519
now a bit before we dive in

51
00:02:41,519 --> 00:02:44,959
i'll present myself i'm around shimoni

52
00:02:44,959 --> 00:02:46,959
and security researcher at cyberarc

53
00:02:46,959 --> 00:02:49,120
i mostly work on windows primarily at

54
00:02:49,120 --> 00:02:50,800
discovering logical bugs

55
00:02:50,800 --> 00:02:52,319
specifically speaking privilege

56
00:02:52,319 --> 00:02:54,160
escalation while i do

57
00:02:54,160 --> 00:02:56,480
look at other platforms windows is my

58
00:02:56,480 --> 00:02:57,599
main focus

59
00:02:57,599 --> 00:02:59,680
besides that i'm mysteriously known to

60
00:02:59,680 --> 00:03:01,680
blue screen my own windows machine and i

61
00:03:01,680 --> 00:03:03,920
really enjoy making and mixing cocktails

62
00:03:03,920 --> 00:03:04,800
and of course

63
00:03:04,800 --> 00:03:06,959
drinking them as well and i hope you see

64
00:03:06,959 --> 00:03:09,040
the connection between blue screens and

65
00:03:09,040 --> 00:03:10,400
cocktails

66
00:03:10,400 --> 00:03:12,640
so what are we going to talk about we

67
00:03:12,640 --> 00:03:15,040
will see how one might easily make usage

68
00:03:15,040 --> 00:03:16,800
of symbolic links for elevation of

69
00:03:16,800 --> 00:03:18,000
privilege attacks

70
00:03:18,000 --> 00:03:19,599
followed by looking how you can do

71
00:03:19,599 --> 00:03:21,519
something i call lazy privilege

72
00:03:21,519 --> 00:03:22,560
escalation

73
00:03:22,560 --> 00:03:24,319
waiting for a privileged code to load

74
00:03:24,319 --> 00:03:26,799
resources from unprotected directories

75
00:03:26,799 --> 00:03:29,920
and taking advantage of it after that we

76
00:03:29,920 --> 00:03:31,200
will visit mte

77
00:03:31,200 --> 00:03:33,440
and see that we can reliably check if a

78
00:03:33,440 --> 00:03:35,440
privilege process are vulnerable to fund

79
00:03:35,440 --> 00:03:36,959
manipulation attacks

80
00:03:36,959 --> 00:03:39,360
i believe you will see that finding eop

81
00:03:39,360 --> 00:03:40,159
bugs in mass

82
00:03:40,159 --> 00:03:41,920
is not that difficult and you can

83
00:03:41,920 --> 00:03:43,360
probably achieve the same results

84
00:03:43,360 --> 00:03:44,159
yourself

85
00:03:44,159 --> 00:03:46,239
you only need a way to properly define

86
00:03:46,239 --> 00:03:47,920
when a program is vulnerable to file

87
00:03:47,920 --> 00:03:49,280
manipulation attacks

88
00:03:49,280 --> 00:03:51,760
and how you can actually automate the

89
00:03:51,760 --> 00:03:55,200
entire exploitation process

90
00:03:55,519 --> 00:03:57,200
this slide is a slide that you almost

91
00:03:57,200 --> 00:03:59,439
find in any privileged escalation talk

92
00:03:59,439 --> 00:04:01,200
microsoft usually divides security

93
00:04:01,200 --> 00:04:02,959
boundaries as separation between the

94
00:04:02,959 --> 00:04:04,640
user's privilege levels

95
00:04:04,640 --> 00:04:06,799
in windows privilege violation is a sort

96
00:04:06,799 --> 00:04:07,840
of perspective

97
00:04:07,840 --> 00:04:10,239
of how an attack might be where an

98
00:04:10,239 --> 00:04:12,400
attacker wants to move between privilege

99
00:04:12,400 --> 00:04:13,360
levels

100
00:04:13,360 --> 00:04:15,360
anything that consists moving up the

101
00:04:15,360 --> 00:04:17,199
privilege level could be arguably

102
00:04:17,199 --> 00:04:19,279
considered a bypass of a security

103
00:04:19,279 --> 00:04:20,238
boundary

104
00:04:20,238 --> 00:04:22,240
in other words every vertical jump in

105
00:04:22,240 --> 00:04:24,479
the hierarchy will cause most vendors to

106
00:04:24,479 --> 00:04:25,120
fix it

107
00:04:25,120 --> 00:04:27,919
and will end up with a cve this is true

108
00:04:27,919 --> 00:04:29,600
aside from a transition between an

109
00:04:29,600 --> 00:04:31,440
administrator to the kernel

110
00:04:31,440 --> 00:04:34,000
in this case it falls to the uac bypass

111
00:04:34,000 --> 00:04:34,880
category

112
00:04:34,880 --> 00:04:36,800
which is not considered a vulnerability

113
00:04:36,800 --> 00:04:38,720
by microsoft eyes

114
00:04:38,720 --> 00:04:42,720
which i do not entirely agree with

115
00:04:42,720 --> 00:04:44,320
all different abilities that i found

116
00:04:44,320 --> 00:04:46,880
originated in services or installers

117
00:04:46,880 --> 00:04:48,800
the reasons behind focusing on those

118
00:04:48,800 --> 00:04:50,479
pieces of software is that they are

119
00:04:50,479 --> 00:04:50,960
almost

120
00:04:50,960 --> 00:04:53,840
always privileged hence every bug in

121
00:04:53,840 --> 00:04:54,240
there

122
00:04:54,240 --> 00:04:56,560
is a bug in a privileged code that will

123
00:04:56,560 --> 00:04:58,240
probably lead you to some kind of

124
00:04:58,240 --> 00:04:59,840
elevation of privilege

125
00:04:59,840 --> 00:05:01,840
besides that most bugs in those

126
00:05:01,840 --> 00:05:03,919
components are relatively easy to find

127
00:05:03,919 --> 00:05:06,320
and not that too hard to implement

128
00:05:06,320 --> 00:05:08,240
we can probably automate the entire

129
00:05:08,240 --> 00:05:09,600
process

130
00:05:09,600 --> 00:05:11,360
now if the word symbolic link sounds

131
00:05:11,360 --> 00:05:13,840
familiar it because this concept exists

132
00:05:13,840 --> 00:05:15,759
on unix platform for many years

133
00:05:15,759 --> 00:05:17,680
only unique symbolic links are files

134
00:05:17,680 --> 00:05:19,759
that contain the path of the file they

135
00:05:19,759 --> 00:05:20,560
point on

136
00:05:20,560 --> 00:05:22,479
so when the kernel tries to access the

137
00:05:22,479 --> 00:05:24,639
symbolic link it will parse the value

138
00:05:24,639 --> 00:05:26,880
in the symbolic file followed by

139
00:05:26,880 --> 00:05:29,199
following the symbolic links path

140
00:05:29,199 --> 00:05:31,039
in windows symbology links are a

141
00:05:31,039 --> 00:05:32,400
different thing

142
00:05:32,400 --> 00:05:34,320
at the beginning of the empty days we

143
00:05:34,320 --> 00:05:36,479
only had object manager symbolic links

144
00:05:36,479 --> 00:05:38,720
and registry symbolic links an object

145
00:05:38,720 --> 00:05:40,720
manager symbolic links is an object that

146
00:05:40,720 --> 00:05:42,639
used to translate a reference

147
00:05:42,639 --> 00:05:45,199
to one named object into another name

148
00:05:45,199 --> 00:05:47,600
when created it links the name of the

149
00:05:47,600 --> 00:05:49,680
symbolic links to the name of the target

150
00:05:49,680 --> 00:05:51,199
object this target

151
00:05:51,199 --> 00:05:54,080
object could be of any type that object

152
00:05:54,080 --> 00:05:55,120
manager supports

153
00:05:55,120 --> 00:05:57,520
including another symbolic link this

154
00:05:57,520 --> 00:05:59,440
type of link was supposed to be used by

155
00:05:59,440 --> 00:06:00,720
driver developers

156
00:06:00,720 --> 00:06:03,919
and by the system only the second

157
00:06:03,919 --> 00:06:06,000
or whether the third type of symbolic

158
00:06:06,000 --> 00:06:08,319
link is the ntfs small point

159
00:06:08,319 --> 00:06:11,120
or directory junctions the ntfs mine

160
00:06:11,120 --> 00:06:12,880
points were first introduced in windows

161
00:06:12,880 --> 00:06:14,400
2000 and they allow

162
00:06:14,400 --> 00:06:16,479
system to have a directory like symbolic

163
00:06:16,479 --> 00:06:17,759
link

164
00:06:17,759 --> 00:06:19,360
both the creations of object manager

165
00:06:19,360 --> 00:06:21,759
symbolic links and ndfs mount points do

166
00:06:21,759 --> 00:06:23,680
not require special privileges

167
00:06:23,680 --> 00:06:26,400
and can be done by the regular user

168
00:06:26,400 --> 00:06:28,880
which is not root for the ntfs symbolic

169
00:06:28,880 --> 00:06:31,360
links presented in windows vista

170
00:06:31,360 --> 00:06:33,120
those are real file system symbolic

171
00:06:33,120 --> 00:06:35,280
links that are like the ones in unix

172
00:06:35,280 --> 00:06:35,919
platform

173
00:06:35,919 --> 00:06:37,840
still they require the user to be an

174
00:06:37,840 --> 00:06:39,520
administrator so they are not

175
00:06:39,520 --> 00:06:41,360
useful in the case of elevation of

176
00:06:41,360 --> 00:06:42,639
privilege attacks

177
00:06:42,639 --> 00:06:45,199
to use object manager symbolic links we

178
00:06:45,199 --> 00:06:46,960
must first learn about the object

179
00:06:46,960 --> 00:06:48,000
manager

180
00:06:48,000 --> 00:06:49,599
here we have a snippet of the

181
00:06:49,599 --> 00:06:52,319
sysinternal tool called winobj

182
00:06:52,319 --> 00:06:54,319
which showcases us the object manager

183
00:06:54,319 --> 00:06:55,599
file system

184
00:06:55,599 --> 00:06:57,680
now the object manager has a different

185
00:06:57,680 --> 00:07:00,240
subsystem than the regular file system

186
00:07:00,240 --> 00:07:02,800
and it resides in the windows executive

187
00:07:02,800 --> 00:07:05,039
its main job is to maintain

188
00:07:05,039 --> 00:07:07,280
a wide catalog of all objects in the

189
00:07:07,280 --> 00:07:09,680
system another job of the object manager

190
00:07:09,680 --> 00:07:12,080
is to parse names passed by it by the io

191
00:07:12,080 --> 00:07:12,800
manager

192
00:07:12,800 --> 00:07:15,120
whenever a create file request is been

193
00:07:15,120 --> 00:07:16,720
received

194
00:07:16,720 --> 00:07:18,720
now the object manager namespace is

195
00:07:18,720 --> 00:07:20,880
organized in a hierarchy tree

196
00:07:20,880 --> 00:07:23,199
each level is an object of the type of

197
00:07:23,199 --> 00:07:24,560
object directory

198
00:07:24,560 --> 00:07:27,840
each object directory has a name and can

199
00:07:27,840 --> 00:07:30,000
have multiple nested object directories

200
00:07:30,000 --> 00:07:30,880
within and

201
00:07:30,880 --> 00:07:33,919
start with the backslash root directory

202
00:07:33,919 --> 00:07:36,000
one of the most famous directories in

203
00:07:36,000 --> 00:07:36,960
windows is the c

204
00:07:36,960 --> 00:07:39,599
directory the c directory is not a real

205
00:07:39,599 --> 00:07:41,039
directory on disk

206
00:07:41,039 --> 00:07:43,599
instead the c directory is an object in

207
00:07:43,599 --> 00:07:45,759
the object manager of the type of a

208
00:07:45,759 --> 00:07:48,160
symbolic link

209
00:07:48,160 --> 00:07:50,720
this object holds the value of the real

210
00:07:50,720 --> 00:07:52,240
path of the device

211
00:07:52,240 --> 00:07:55,440
the hard drive in our case sees repairs

212
00:07:55,440 --> 00:07:57,599
to backslash device backslash hard disk

213
00:07:57,599 --> 00:07:58,080
volume

214
00:07:58,080 --> 00:08:00,560
4. every time you do file operations on

215
00:08:00,560 --> 00:08:01,759
files inside the c

216
00:08:01,759 --> 00:08:04,319
volume you get the value of the symbolic

217
00:08:04,319 --> 00:08:06,080
link

218
00:08:06,080 --> 00:08:08,319
every object directory is a securable

219
00:08:08,319 --> 00:08:09,199
resource

220
00:08:09,199 --> 00:08:11,360
not everyone can access any object in

221
00:08:11,360 --> 00:08:13,360
the object manager namespace

222
00:08:13,360 --> 00:08:15,360
and you need the relevant permissions

223
00:08:15,360 --> 00:08:17,440
with you if you want to edit it

224
00:08:17,440 --> 00:08:20,160
but what if we can create new symbolic

225
00:08:20,160 --> 00:08:20,639
links

226
00:08:20,639 --> 00:08:23,759
that will point to files of our desire

227
00:08:23,759 --> 00:08:26,000
what can we do with it it turns out

228
00:08:26,000 --> 00:08:27,520
there is such a place

229
00:08:27,520 --> 00:08:29,680
in the object directory backslash rpc

230
00:08:29,680 --> 00:08:30,800
control

231
00:08:30,800 --> 00:08:33,599
which can be mounted from a regular user

232
00:08:33,599 --> 00:08:34,320
we will see

233
00:08:34,320 --> 00:08:36,958
shortly how to use it by calling create

234
00:08:36,958 --> 00:08:37,839
file with the

235
00:08:37,839 --> 00:08:40,159
create new flag we can re-parse the

236
00:08:40,159 --> 00:08:42,479
create operations to achieve arbitrary

237
00:08:42,479 --> 00:08:43,360
file creation

238
00:08:43,360 --> 00:08:46,560
in arbitrary locations we can also

239
00:08:46,560 --> 00:08:47,040
change

240
00:08:47,040 --> 00:08:49,760
the file output file name because we can

241
00:08:49,760 --> 00:08:50,160
set

242
00:08:50,160 --> 00:08:52,480
any names we wish in the object manager

243
00:08:52,480 --> 00:08:53,680
symbolic link

244
00:08:53,680 --> 00:08:55,839
this however will only allow us to

245
00:08:55,839 --> 00:08:57,120
create empty files

246
00:08:57,120 --> 00:08:58,880
because the default permissions of a

247
00:08:58,880 --> 00:09:01,120
file created by a service do not allow

248
00:09:01,120 --> 00:09:03,120
editing

249
00:09:03,120 --> 00:09:05,680
the second type of bugs is a process

250
00:09:05,680 --> 00:09:07,600
that does a write file operation

251
00:09:07,600 --> 00:09:10,240
on a file in an unprotected directory

252
00:09:10,240 --> 00:09:12,480
using its privileged access token

253
00:09:12,480 --> 00:09:14,399
we can do the same as before and now the

254
00:09:14,399 --> 00:09:16,560
reports file will contain the content of

255
00:09:16,560 --> 00:09:17,920
the write operation

256
00:09:17,920 --> 00:09:20,560
but we won't have the option to edit it

257
00:09:20,560 --> 00:09:21,279
luckily

258
00:09:21,279 --> 00:09:23,680
sometimes the privilege code will call

259
00:09:23,680 --> 00:09:26,160
set security file api on the file

260
00:09:26,160 --> 00:09:28,640
changing changing its permission and

261
00:09:28,640 --> 00:09:29,360
allowing

262
00:09:29,360 --> 00:09:32,080
regular users to edit it this is also

263
00:09:32,080 --> 00:09:32,560
called

264
00:09:32,560 --> 00:09:34,880
an arbitrary right vulnerability from

265
00:09:34,880 --> 00:09:36,000
there we can either

266
00:09:36,000 --> 00:09:38,640
replace the file contents with a dll and

267
00:09:38,640 --> 00:09:40,720
just escalate to system via dll

268
00:09:40,720 --> 00:09:42,240
hijacking

269
00:09:42,240 --> 00:09:44,240
luckily sometimes the privilege code

270
00:09:44,240 --> 00:09:47,120
will call the set security file api on

271
00:09:47,120 --> 00:09:48,000
the file

272
00:09:48,000 --> 00:09:50,160
changing its permissions and allowing

273
00:09:50,160 --> 00:09:51,360
regular users

274
00:09:51,360 --> 00:09:53,680
the option to edit it this is also

275
00:09:53,680 --> 00:09:56,080
called an arbitrary write vulnerability

276
00:09:56,080 --> 00:09:58,000
from there we can replace the file's

277
00:09:58,000 --> 00:09:59,600
content with a dll

278
00:09:59,600 --> 00:10:02,000
and just escalate to system via dll

279
00:10:02,000 --> 00:10:03,200
hijacking

280
00:10:03,200 --> 00:10:05,519
the call of set security file also

281
00:10:05,519 --> 00:10:07,200
rarely happens

282
00:10:07,200 --> 00:10:09,760
in our first case of the create file but

283
00:10:09,760 --> 00:10:12,079
it's more common here

284
00:10:12,079 --> 00:10:15,279
lastly if we find a service that calls

285
00:10:15,279 --> 00:10:17,120
the delete file on a file in an

286
00:10:17,120 --> 00:10:18,880
unprotected path we can repulse the

287
00:10:18,880 --> 00:10:20,880
delete operation and delete an arbitrary

288
00:10:20,880 --> 00:10:22,320
protected file

289
00:10:22,320 --> 00:10:24,399
deleting every desired file in the

290
00:10:24,399 --> 00:10:26,480
context of a trust privilege process

291
00:10:26,480 --> 00:10:29,040
is useful for malware and alike to

292
00:10:29,040 --> 00:10:31,120
escalate into system you usually need

293
00:10:31,120 --> 00:10:32,800
another primitive unless

294
00:10:32,800 --> 00:10:34,800
you just want to do some denial of

295
00:10:34,800 --> 00:10:38,319
service to the local machine

296
00:10:39,279 --> 00:10:41,600
let's see how this can be done the first

297
00:10:41,600 --> 00:10:42,320
thing

298
00:10:42,320 --> 00:10:44,800
is we want to create a mount point we

299
00:10:44,800 --> 00:10:46,560
take advantage of the fact that the

300
00:10:46,560 --> 00:10:48,320
object manager has a bunch of object

301
00:10:48,320 --> 00:10:49,760
directories

302
00:10:49,760 --> 00:10:51,760
since there is at least one object

303
00:10:51,760 --> 00:10:54,320
directory we have some permissions

304
00:10:54,320 --> 00:10:57,360
over it to create new objects there we

305
00:10:57,360 --> 00:10:58,800
can create a mounting point

306
00:10:58,800 --> 00:11:01,600
there this directory is the object

307
00:11:01,600 --> 00:11:04,640
directory backslash rpc control

308
00:11:04,640 --> 00:11:06,959
we basically mount a local directory

309
00:11:06,959 --> 00:11:08,079
that will be linked

310
00:11:08,079 --> 00:11:09,760
to the object manager namespace by

311
00:11:09,760 --> 00:11:12,079
calling create directory api

312
00:11:12,079 --> 00:11:14,160
followed by calling device io control

313
00:11:14,160 --> 00:11:16,720
with a set repos point flag will do the

314
00:11:16,720 --> 00:11:18,160
trick

315
00:11:18,160 --> 00:11:21,040
it cannot be that easy right well we do

316
00:11:21,040 --> 00:11:22,480
have some limitations

317
00:11:22,480 --> 00:11:24,880
the directory must be empty before we

318
00:11:24,880 --> 00:11:25,680
change it

319
00:11:25,680 --> 00:11:28,000
into a mount point therefore we need to

320
00:11:28,000 --> 00:11:30,079
have the permission to delete every file

321
00:11:30,079 --> 00:11:30,880
there

322
00:11:30,880 --> 00:11:33,519
also we need to have write permissions

323
00:11:33,519 --> 00:11:35,120
over the directory

324
00:11:35,120 --> 00:11:37,200
interestingly we do not need to have

325
00:11:37,200 --> 00:11:39,839
full permissions over the directory like

326
00:11:39,839 --> 00:11:42,800
we do not need to have the permission to

327
00:11:42,800 --> 00:11:44,160
actually delete

328
00:11:44,160 --> 00:11:47,920
the directory the second thing we need

329
00:11:47,920 --> 00:11:49,920
for a successful attack is to create an

330
00:11:49,920 --> 00:11:52,160
object manager symbolic link

331
00:11:52,160 --> 00:11:54,399
the great thing about it is that anyone

332
00:11:54,399 --> 00:11:55,680
can create them

333
00:11:55,680 --> 00:11:58,000
unfortunately you are somehow limited in

334
00:11:58,000 --> 00:11:59,440
the namespace selection

335
00:11:59,440 --> 00:12:01,680
and you cannot create permanent links

336
00:12:01,680 --> 00:12:03,360
this because it requires admin

337
00:12:03,360 --> 00:12:04,959
privileges to do so

338
00:12:04,959 --> 00:12:06,800
sadly if the symbolic links are not

339
00:12:06,800 --> 00:12:09,360
permanent the same link will get deleted

340
00:12:09,360 --> 00:12:12,800
if every handle to this object is closed

341
00:12:12,800 --> 00:12:15,519
therefore upon restart the symbolic link

342
00:12:15,519 --> 00:12:16,959
object will be gone

343
00:12:16,959 --> 00:12:19,519
so persisting the system in this way is

344
00:12:19,519 --> 00:12:21,360
not going to work unless you're under

345
00:12:21,360 --> 00:12:23,760
you are an administrator but

346
00:12:23,760 --> 00:12:25,120
non-permanent links

347
00:12:25,120 --> 00:12:27,680
are still very useful for elevation of

348
00:12:27,680 --> 00:12:29,680
privileged attacks

349
00:12:29,680 --> 00:12:32,079
okay so let's see what happens under the

350
00:12:32,079 --> 00:12:33,040
hood

351
00:12:33,040 --> 00:12:36,399
if we look at how path translation works

352
00:12:36,399 --> 00:12:38,560
we have a service that does create file

353
00:12:38,560 --> 00:12:40,079
operations on

354
00:12:40,079 --> 00:12:43,120
cdir file the attacker created a mount

355
00:12:43,120 --> 00:12:44,880
point on the deer directory

356
00:12:44,880 --> 00:12:47,440
to point to backslash rpc control and

357
00:12:47,440 --> 00:12:49,360
the symbolic link in the object manager

358
00:12:49,360 --> 00:12:51,440
with the source value of file txt

359
00:12:51,440 --> 00:12:55,839
that will point on some dll in system 32

360
00:12:55,839 --> 00:12:58,240
we start with a call to rtl dos path

361
00:12:58,240 --> 00:13:01,200
name to antipath name api

362
00:13:01,200 --> 00:13:03,920
this just changes the win32 path to its

363
00:13:03,920 --> 00:13:06,639
anti-path notation

364
00:13:06,639 --> 00:13:09,040
the object manager takes the input name

365
00:13:09,040 --> 00:13:09,680
the nt

366
00:13:09,680 --> 00:13:12,320
path and parses its components which are

367
00:13:12,320 --> 00:13:14,240
each separated by a backslash

368
00:13:14,240 --> 00:13:16,720
until it finds the object that is the

369
00:13:16,720 --> 00:13:18,320
target of the request

370
00:13:18,320 --> 00:13:20,560
basically every component of the path

371
00:13:20,560 --> 00:13:21,600
will be called with

372
00:13:21,600 --> 00:13:24,560
lookup function with the obp-lookup

373
00:13:24,560 --> 00:13:26,720
object in the object manager

374
00:13:26,720 --> 00:13:30,000
the c directory will get the device path

375
00:13:30,000 --> 00:13:33,040
we saw earlier the

376
00:13:33,040 --> 00:13:35,760
directory will be translated to its

377
00:13:35,760 --> 00:13:37,120
mount point directory

378
00:13:37,120 --> 00:13:39,360
the object directory backslash rpc

379
00:13:39,360 --> 00:13:40,720
control

380
00:13:40,720 --> 00:13:42,880
and the file name file.txt will be

381
00:13:42,880 --> 00:13:45,279
translated to the sim link we created

382
00:13:45,279 --> 00:13:47,519
in this case the symlink value of c

383
00:13:47,519 --> 00:13:49,120
windows system 482

384
00:13:49,120 --> 00:13:52,560
windows score device info dll so the

385
00:13:52,560 --> 00:13:54,800
create file operation the service did

386
00:13:54,800 --> 00:13:57,440
thinking it works on cd or file txt will

387
00:13:57,440 --> 00:14:00,079
be re-parsed to see windows system 48

388
00:14:00,079 --> 00:14:03,199
windows score device info.dll

389
00:14:03,199 --> 00:14:06,399
now let's go through a real example this

390
00:14:06,399 --> 00:14:08,639
is a bug in windows service called still

391
00:14:08,639 --> 00:14:10,800
image acquisition events

392
00:14:10,800 --> 00:14:13,920
now i really don't know even one bit

393
00:14:13,920 --> 00:14:15,839
about this service and i almost fell

394
00:14:15,839 --> 00:14:19,199
asleep by reading the msdn description

395
00:14:19,199 --> 00:14:20,880
luckily when you do bug hunting and

396
00:14:20,880 --> 00:14:22,880
doing it automatically you do not need

397
00:14:22,880 --> 00:14:24,800
to familiarize yourself with the target

398
00:14:24,800 --> 00:14:26,800
in most cases

399
00:14:26,800 --> 00:14:29,199
the vulnerability here is pretty simple

400
00:14:29,199 --> 00:14:30,880
we have a service that is

401
00:14:30,880 --> 00:14:34,079
implemented in a dll w i

402
00:14:34,079 --> 00:14:37,279
a rpc as you can probably guess it is an

403
00:14:37,279 --> 00:14:38,320
rpc service

404
00:14:38,320 --> 00:14:41,040
that allows the user to interact by

405
00:14:41,040 --> 00:14:43,680
interacting with wya rpc

406
00:14:43,680 --> 00:14:45,839
in turn this service creates a log file

407
00:14:45,839 --> 00:14:48,560
in windyr debug wia

408
00:14:48,560 --> 00:14:51,600
which is writable by a regular user so

409
00:14:51,600 --> 00:14:52,720
far so good

410
00:14:52,720 --> 00:14:55,440
and it continues to write to the file

411
00:14:55,440 --> 00:14:58,000
followed by a call to set security file

412
00:14:58,000 --> 00:15:00,480
allowing a regular user the option to

413
00:15:00,480 --> 00:15:02,959
edit its content

414
00:15:02,959 --> 00:15:05,199
we can easily abuse it by placing a

415
00:15:05,199 --> 00:15:06,000
mount point

416
00:15:06,000 --> 00:15:08,399
and a symbolic link over it the amount

417
00:15:08,399 --> 00:15:10,160
point will point to backslash rpc

418
00:15:10,160 --> 00:15:11,120
control

419
00:15:11,120 --> 00:15:13,920
and the sim link will point to a new dll

420
00:15:13,920 --> 00:15:15,600
that will be loaded by the system

421
00:15:15,600 --> 00:15:17,760
service we can easily abuse it

422
00:15:17,760 --> 00:15:19,760
placing a mount point and a sim link

423
00:15:19,760 --> 00:15:22,079
over it the mount point will point to

424
00:15:22,079 --> 00:15:24,560
backslash rpc control and the sim link

425
00:15:24,560 --> 00:15:25,600
will point to

426
00:15:25,600 --> 00:15:28,320
the new dll that can be loaded by some

427
00:15:28,320 --> 00:15:30,160
of the system services

428
00:15:30,160 --> 00:15:32,320
we can add it the target file because of

429
00:15:32,320 --> 00:15:33,600
the call to

430
00:15:33,600 --> 00:15:35,600
security file which changes its

431
00:15:35,600 --> 00:15:37,279
permissions without it

432
00:15:37,279 --> 00:15:39,199
we could just create an arbitrary file

433
00:15:39,199 --> 00:15:40,880
in arbitrary location

434
00:15:40,880 --> 00:15:42,959
but without having the ability to edit

435
00:15:42,959 --> 00:15:44,320
it

436
00:15:44,320 --> 00:15:47,279
so how did microsoft fix it and how can

437
00:15:47,279 --> 00:15:49,120
we prevent similar bugs

438
00:15:49,120 --> 00:15:51,440
for starters you can just make sure the

439
00:15:51,440 --> 00:15:53,360
directory that holds the log file will

440
00:15:53,360 --> 00:15:53,680
be

441
00:15:53,680 --> 00:15:56,480
admin acld preventing a regular user

442
00:15:56,480 --> 00:15:56,880
from

443
00:15:56,880 --> 00:15:59,040
having write permissions and breaking

444
00:15:59,040 --> 00:16:00,880
the first part of the exploit

445
00:16:00,880 --> 00:16:03,839
which is creating a mount point besides

446
00:16:03,839 --> 00:16:04,480
that

447
00:16:04,480 --> 00:16:06,839
privileged software should do token

448
00:16:06,839 --> 00:16:08,320
impersonation

449
00:16:08,320 --> 00:16:11,440
on the user whenever it's possible

450
00:16:11,440 --> 00:16:14,000
if the service would have impersonated

451
00:16:14,000 --> 00:16:14,800
the user

452
00:16:14,800 --> 00:16:17,120
then we couldn't abuse this this is

453
00:16:17,120 --> 00:16:18,959
somewhat easier said than done

454
00:16:18,959 --> 00:16:21,040
because there are many code paths and in

455
00:16:21,040 --> 00:16:23,600
some of the cases we would actually need

456
00:16:23,600 --> 00:16:26,560
the our system level token and in other

457
00:16:26,560 --> 00:16:28,639
cases we should use an impersonation

458
00:16:28,639 --> 00:16:29,920
token

459
00:16:29,920 --> 00:16:32,000
this alongside incorrect file

460
00:16:32,000 --> 00:16:34,000
permissions are the root causes of so

461
00:16:34,000 --> 00:16:36,160
many bugs

462
00:16:36,160 --> 00:16:38,320
let's go to our second simpler attacking

463
00:16:38,320 --> 00:16:40,720
method i know this is a silly image but

464
00:16:40,720 --> 00:16:42,079
we'll be told that almost

465
00:16:42,079 --> 00:16:44,320
any product that i checked created by a

466
00:16:44,320 --> 00:16:45,519
pc vendor

467
00:16:45,519 --> 00:16:48,240
suffered from dll hijacking i assume

468
00:16:48,240 --> 00:16:50,320
you're familiar with dll hijacking so

469
00:16:50,320 --> 00:16:52,160
i'll speed around my explanation about

470
00:16:52,160 --> 00:16:53,920
this attack

471
00:16:53,920 --> 00:16:56,399
dll hijacking is a simple and effective

472
00:16:56,399 --> 00:16:58,399
way to inject code into a process

473
00:16:58,399 --> 00:17:00,639
that almost every security product

474
00:17:00,639 --> 00:17:01,839
failed to catch

475
00:17:01,839 --> 00:17:04,400
because of the fear of false positive

476
00:17:04,400 --> 00:17:05,679
the way it works is that

477
00:17:05,679 --> 00:17:07,919
executables want to load additional code

478
00:17:07,919 --> 00:17:09,679
on the runtime

479
00:17:09,679 --> 00:17:11,679
the thread calls load library in order

480
00:17:11,679 --> 00:17:13,280
to load a dll

481
00:17:13,280 --> 00:17:15,599
we get the h model back and the dll file

482
00:17:15,599 --> 00:17:17,439
will be mopped into the caller's address

483
00:17:17,439 --> 00:17:18,480
space

484
00:17:18,480 --> 00:17:20,880
a function named dll main will soon be

485
00:17:20,880 --> 00:17:23,039
called which is unsurprisingly inside

486
00:17:23,039 --> 00:17:24,640
the dll binary

487
00:17:24,640 --> 00:17:26,679
this function is supposed to be used for

488
00:17:26,679 --> 00:17:28,079
initialization

489
00:17:28,079 --> 00:17:30,320
of variables but in our case we just put

490
00:17:30,320 --> 00:17:33,679
malicious code inside the dll main

491
00:17:33,679 --> 00:17:35,919
unfortunately there is one annoying

492
00:17:35,919 --> 00:17:37,760
thing about dll hijacking

493
00:17:37,760 --> 00:17:40,080
which is implementing all its export

494
00:17:40,080 --> 00:17:40,880
points

495
00:17:40,880 --> 00:17:43,360
you see the lordo won't be happy if you

496
00:17:43,360 --> 00:17:45,679
do not have all the exported function as

497
00:17:45,679 --> 00:17:47,520
the original dll has

498
00:17:47,520 --> 00:17:49,039
and it will terminate your privilege

499
00:17:49,039 --> 00:17:52,000
process upon loading the malicious dll

500
00:17:52,000 --> 00:17:54,720
which is a thing we certainly don't want

501
00:17:54,720 --> 00:17:56,160
here we can see that we have to

502
00:17:56,160 --> 00:17:58,799
implement a large number of functions

503
00:17:58,799 --> 00:18:01,120
surprisingly there is an elegant way to

504
00:18:01,120 --> 00:18:02,240
overcome it

505
00:18:02,240 --> 00:18:04,400
by the wonderful feature called dll

506
00:18:04,400 --> 00:18:07,039
proxy we can specify it to the linker to

507
00:18:07,039 --> 00:18:08,080
forward the request

508
00:18:08,080 --> 00:18:10,320
on a given export point to a different

509
00:18:10,320 --> 00:18:11,200
dll

510
00:18:11,200 --> 00:18:12,880
the compiled binary will have a

511
00:18:12,880 --> 00:18:14,720
reference to the actual function it

512
00:18:14,720 --> 00:18:16,000
intends to call

513
00:18:16,000 --> 00:18:18,559
this makes the attack a lot simpler just

514
00:18:18,559 --> 00:18:20,880
forward an export point to the real dll

515
00:18:20,880 --> 00:18:24,640
and proceed as normal it is also easy to

516
00:18:24,640 --> 00:18:26,960
generate a bunch of semi-malicious dlls

517
00:18:26,960 --> 00:18:27,520
for

518
00:18:27,520 --> 00:18:29,280
all the dls that are being used on

519
00:18:29,280 --> 00:18:31,760
windows so every time a component tries

520
00:18:31,760 --> 00:18:33,120
to load the dll

521
00:18:33,120 --> 00:18:36,240
we can forward it to the real dll

522
00:18:36,240 --> 00:18:39,919
now where is this attack most useful

523
00:18:39,919 --> 00:18:42,480
well the answer is installers installers

524
00:18:42,480 --> 00:18:44,400
are arguably one of the worst software

525
00:18:44,400 --> 00:18:45,919
components ever written

526
00:18:45,919 --> 00:18:48,080
and they're the prime targets of dll

527
00:18:48,080 --> 00:18:50,960
hijacking attacks and the reasons are

528
00:18:50,960 --> 00:18:53,919
there are almost always privilege they

529
00:18:53,919 --> 00:18:55,760
need to write many new files

530
00:18:55,760 --> 00:18:58,640
into systems directory edit the registry

531
00:18:58,640 --> 00:19:00,320
and sometimes install

532
00:19:00,320 --> 00:19:02,640
drivers therefore they need to have

533
00:19:02,640 --> 00:19:04,880
privileges to do so

534
00:19:04,880 --> 00:19:06,720
installers often use unpatched

535
00:19:06,720 --> 00:19:08,480
installation frameworks like install

536
00:19:08,480 --> 00:19:10,000
shield and in a setup

537
00:19:10,000 --> 00:19:12,480
just a few names that pop into mind

538
00:19:12,480 --> 00:19:14,799
software developers do not emphasize on

539
00:19:14,799 --> 00:19:16,400
upgrading the installer

540
00:19:16,400 --> 00:19:18,480
they emphasize on upgrading what it

541
00:19:18,480 --> 00:19:19,440
installs

542
00:19:19,440 --> 00:19:21,440
the product they installed could be very

543
00:19:21,440 --> 00:19:24,000
secure but its wrapper software

544
00:19:24,000 --> 00:19:26,799
is like a swiss cheese piece in other

545
00:19:26,799 --> 00:19:27,440
words

546
00:19:27,440 --> 00:19:29,520
installers can be compared to a diamond

547
00:19:29,520 --> 00:19:31,840
ring inside a plastic bag

548
00:19:31,840 --> 00:19:34,880
yes it is that bad also

549
00:19:34,880 --> 00:19:37,280
they do not have any security checks

550
00:19:37,280 --> 00:19:39,280
like they do not check the dlls that

551
00:19:39,280 --> 00:19:40,880
they are about to be loaded

552
00:19:40,880 --> 00:19:43,200
to be digitally signed even though it's

553
00:19:43,200 --> 00:19:46,080
an option since windows vista

554
00:19:46,080 --> 00:19:48,080
weirdly enough even microsoft that

555
00:19:48,080 --> 00:19:50,480
recommends it does not do it

556
00:19:50,480 --> 00:19:53,120
i have checked around 120 installers in

557
00:19:53,120 --> 00:19:54,320
my research and only

558
00:19:54,320 --> 00:19:56,160
four of them checked if they would be

559
00:19:56,160 --> 00:19:57,520
loaded dlls

560
00:19:57,520 --> 00:20:00,080
are a digitally sign they're also prime

561
00:20:00,080 --> 00:20:02,400
target of symlink attacks because they

562
00:20:02,400 --> 00:20:04,880
they create a lot of log files inside

563
00:20:04,880 --> 00:20:06,960
subdirectories of the program data

564
00:20:06,960 --> 00:20:07,760
folder

565
00:20:07,760 --> 00:20:10,080
and this directory on default is not

566
00:20:10,080 --> 00:20:12,000
admin protected

567
00:20:12,000 --> 00:20:14,240
so this is another thing that installers

568
00:20:14,240 --> 00:20:15,840
are not safe

569
00:20:15,840 --> 00:20:18,000
an example of it will be a vulnerability

570
00:20:18,000 --> 00:20:19,840
inside dell's dupe installation

571
00:20:19,840 --> 00:20:21,120
framework

572
00:20:21,120 --> 00:20:23,360
the bug is straightforward one dell

573
00:20:23,360 --> 00:20:25,760
created an installation framework called

574
00:20:25,760 --> 00:20:28,240
dupe which unifies a bunch of software

575
00:20:28,240 --> 00:20:29,520
into one place

576
00:20:29,520 --> 00:20:31,520
the dope installer is a framework that

577
00:20:31,520 --> 00:20:33,840
rides on the install sheet framework

578
00:20:33,840 --> 00:20:35,840
it is known that upon a load library

579
00:20:35,840 --> 00:20:38,240
call windows starts looking for the dll

580
00:20:38,240 --> 00:20:40,159
in the local folder first

581
00:20:40,159 --> 00:20:42,480
then in other places like the system

582
00:20:42,480 --> 00:20:43,520
folders

583
00:20:43,520 --> 00:20:47,039
so the developers decided to copy the

584
00:20:47,039 --> 00:20:49,440
dope installer into program data

585
00:20:49,440 --> 00:20:52,159
dell drivers and subgrid followed by

586
00:20:52,159 --> 00:20:54,960
trying to load a bunch of dlls

587
00:20:54,960 --> 00:20:57,280
these dll files do not exist in the

588
00:20:57,280 --> 00:20:59,039
newly created directory

589
00:20:59,039 --> 00:21:01,600
so we can put our malicious dll there

590
00:21:01,600 --> 00:21:03,440
and it will be happily loaded by the

591
00:21:03,440 --> 00:21:04,159
installer

592
00:21:04,159 --> 00:21:05,679
since the default permissions of the

593
00:21:05,679 --> 00:21:07,440
directory of program data

594
00:21:07,440 --> 00:21:10,159
are permissive there are probably two

595
00:21:10,159 --> 00:21:11,679
things you ask yourself

596
00:21:11,679 --> 00:21:13,679
why does the installer try to load to

597
00:21:13,679 --> 00:21:15,760
load many dls that do not exist there in

598
00:21:15,760 --> 00:21:18,080
the first place and what is that good

599
00:21:18,080 --> 00:21:21,520
can we guess it first those dlls are

600
00:21:21,520 --> 00:21:22,240
being sought

601
00:21:22,240 --> 00:21:24,640
after an outdated installation framework

602
00:21:24,640 --> 00:21:26,400
without no good reason

603
00:21:26,400 --> 00:21:28,559
the installer doesn't care if it

604
00:21:28,559 --> 00:21:30,720
actually loads them or not

605
00:21:30,720 --> 00:21:33,360
also these dlls actually exist in the

606
00:21:33,360 --> 00:21:35,120
system32 directory

607
00:21:35,120 --> 00:21:37,679
but they are being searched first in the

608
00:21:37,679 --> 00:21:39,520
current directory because that's how

609
00:21:39,520 --> 00:21:40,720
windows search and load

610
00:21:40,720 --> 00:21:44,080
dll algorithm works getting the guide

611
00:21:44,080 --> 00:21:46,080
before the attack is also easy

612
00:21:46,080 --> 00:21:48,000
because you do not really need to know

613
00:21:48,000 --> 00:21:50,400
it you can just wait for the new

614
00:21:50,400 --> 00:21:53,520
created directory to be created inside

615
00:21:53,520 --> 00:21:56,159
c program.dell drivers all you need is

616
00:21:56,159 --> 00:21:58,000
to create a file system watcher or

617
00:21:58,000 --> 00:22:00,320
use a projected file system that watches

618
00:22:00,320 --> 00:22:01,520
on this path

619
00:22:01,520 --> 00:22:03,600
it will fire desired behavior upon the

620
00:22:03,600 --> 00:22:05,600
directory creation event

621
00:22:05,600 --> 00:22:07,760
then you can copy your malicious dll

622
00:22:07,760 --> 00:22:09,600
into the newly created installation

623
00:22:09,600 --> 00:22:10,240
framework

624
00:22:10,240 --> 00:22:12,400
and the installer will load it with no

625
00:22:12,400 --> 00:22:14,080
question asked

626
00:22:14,080 --> 00:22:15,840
it is important to add that you need

627
00:22:15,840 --> 00:22:18,320
admin privileges to install the product

628
00:22:18,320 --> 00:22:21,120
many installers are being executed by an

629
00:22:21,120 --> 00:22:22,960
update in programs on demand or

630
00:22:22,960 --> 00:22:24,880
automatically on your machine

631
00:22:24,880 --> 00:22:27,039
those update programs are of course run

632
00:22:27,039 --> 00:22:28,720
in a privileged context

633
00:22:28,720 --> 00:22:30,799
this is why i called it earlier lazy

634
00:22:30,799 --> 00:22:32,400
privilege escalation

635
00:22:32,400 --> 00:22:34,159
you wait for installers to make those

636
00:22:34,159 --> 00:22:36,559
mistakes and you just wait with a file

637
00:22:36,559 --> 00:22:39,120
system watchers and some dlls and you

638
00:22:39,120 --> 00:22:39,520
can

639
00:22:39,520 --> 00:22:41,760
get privileged escalation format

640
00:22:41,760 --> 00:22:44,000
mitigating it is easy instead of using

641
00:22:44,000 --> 00:22:46,080
the old load library api

642
00:22:46,080 --> 00:22:48,720
you can use load library eex api this

643
00:22:48,720 --> 00:22:50,480
api is a lot more secure

644
00:22:50,480 --> 00:22:52,559
allowing developers to add flags that

645
00:22:52,559 --> 00:22:54,320
prevent dlls loading

646
00:22:54,320 --> 00:22:56,240
from the directories that are not the

647
00:22:56,240 --> 00:22:57,760
system directories

648
00:22:57,760 --> 00:23:00,880
you can also specify the full dls path

649
00:23:00,880 --> 00:23:03,039
and of course you can also check the dll

650
00:23:03,039 --> 00:23:04,720
to be digitally signed

651
00:23:04,720 --> 00:23:07,039
so many options we have let's see some

652
00:23:07,039 --> 00:23:09,840
people using them

653
00:23:10,080 --> 00:23:11,840
after viewing those two exploitation

654
00:23:11,840 --> 00:23:14,080
methods we can ask ourselves how we can

655
00:23:14,080 --> 00:23:16,080
automate the entire loop of

656
00:23:16,080 --> 00:23:17,919
finding privileged file operations and

657
00:23:17,919 --> 00:23:20,000
exploiting them automatically

658
00:23:20,000 --> 00:23:22,240
so i developed a system called iknaya

659
00:23:22,240 --> 00:23:23,840
ignite tries to implement the whole

660
00:23:23,840 --> 00:23:25,039
chain of attack

661
00:23:25,039 --> 00:23:28,400
monitoring tracing and exploiting ignite

662
00:23:28,400 --> 00:23:30,559
does it automatically and it comes on

663
00:23:30,559 --> 00:23:32,000
two flavors

664
00:23:32,000 --> 00:23:34,320
the first one is constant monitoring in

665
00:23:34,320 --> 00:23:36,480
this mode we check every privileged file

666
00:23:36,480 --> 00:23:38,559
operations on the operating system

667
00:23:38,559 --> 00:23:40,799
except some operations form specific

668
00:23:40,799 --> 00:23:41,679
processes

669
00:23:41,679 --> 00:23:44,159
that we can safely ignore for over a

670
00:23:44,159 --> 00:23:45,120
lifetime

671
00:23:45,120 --> 00:23:47,200
services do actions upon specific

672
00:23:47,200 --> 00:23:48,159
triggers

673
00:23:48,159 --> 00:23:50,400
let it be an event or some other

674
00:23:50,400 --> 00:23:51,440
behavior

675
00:23:51,440 --> 00:23:54,480
therefore sampling each file operation

676
00:23:54,480 --> 00:23:56,559
allow us to know if a given service can

677
00:23:56,559 --> 00:23:58,000
be abused

678
00:23:58,000 --> 00:23:59,919
in this way the vulnerability in the

679
00:23:59,919 --> 00:24:01,440
service shown earlier

680
00:24:01,440 --> 00:24:04,880
has been found the second mode is

681
00:24:04,880 --> 00:24:07,279
checking if a given application is

682
00:24:07,279 --> 00:24:09,120
vulnerable to such attacks

683
00:24:09,120 --> 00:24:11,120
the data set is primarily speaking

684
00:24:11,120 --> 00:24:12,159
installers and

685
00:24:12,159 --> 00:24:15,039
object programs as we stated before

686
00:24:15,039 --> 00:24:17,120
installers are mostly executed by

687
00:24:17,120 --> 00:24:18,480
administrators

688
00:24:18,480 --> 00:24:20,400
they are also active for a shared period

689
00:24:20,400 --> 00:24:22,159
of time doing their privileged

690
00:24:22,159 --> 00:24:25,440
file operations on the initial execution

691
00:24:25,440 --> 00:24:27,520
this is how the vulnerability in dell's

692
00:24:27,520 --> 00:24:29,679
installation framework was discovered

693
00:24:29,679 --> 00:24:31,120
you can see that their behavioral

694
00:24:31,120 --> 00:24:32,799
profile is a bit different than

695
00:24:32,799 --> 00:24:35,520
services luckily it is easier to

696
00:24:35,520 --> 00:24:36,880
discover vulnerabilities

697
00:24:36,880 --> 00:24:39,520
in such situations because we are not

698
00:24:39,520 --> 00:24:42,080
limited to a specific execution sequence

699
00:24:42,080 --> 00:24:44,720
that often occurs in services the fun

700
00:24:44,720 --> 00:24:46,559
part is that we can make an impressive

701
00:24:46,559 --> 00:24:48,559
data set of installers and feed them to

702
00:24:48,559 --> 00:24:49,520
ignia

703
00:24:49,520 --> 00:24:51,120
another interesting thing is that

704
00:24:51,120 --> 00:24:53,120
occasionally the installers will create

705
00:24:53,120 --> 00:24:54,240
services

706
00:24:54,240 --> 00:24:56,880
and that we can later feed them back to

707
00:24:56,880 --> 00:24:58,480
the system

708
00:24:58,480 --> 00:25:00,320
now let's take a look at the technical

709
00:25:00,320 --> 00:25:01,679
details to monitor

710
00:25:01,679 --> 00:25:04,640
the file system operations of a program

711
00:25:04,640 --> 00:25:06,640
we must have a minifilter file system

712
00:25:06,640 --> 00:25:07,520
driver

713
00:25:07,520 --> 00:25:09,919
it allows us to hook relevant herbs that

714
00:25:09,919 --> 00:25:11,679
can be used to determine if a given

715
00:25:11,679 --> 00:25:13,840
application is vulnerable

716
00:25:13,840 --> 00:25:15,760
those that come from the background like

717
00:25:15,760 --> 00:25:18,159
linux or macos do not have herbs

718
00:25:18,159 --> 00:25:19,520
because of a different driver

719
00:25:19,520 --> 00:25:21,840
architecture in windows drivers are

720
00:25:21,840 --> 00:25:23,120
stuck on each other

721
00:25:23,120 --> 00:25:25,440
in contrast to linux each driver is a

722
00:25:25,440 --> 00:25:27,679
model that can be loaded and unloaded

723
00:25:27,679 --> 00:25:30,799
dynamically now herbs are ir packet data

724
00:25:30,799 --> 00:25:32,240
structures that are being used in

725
00:25:32,240 --> 00:25:34,080
communication between drivers

726
00:25:34,080 --> 00:25:36,559
with the operating system those herbs

727
00:25:36,559 --> 00:25:38,320
are packets represented by a single

728
00:25:38,320 --> 00:25:40,080
pointer to a data structure

729
00:25:40,080 --> 00:25:43,760
instead of many pointers to arguments

730
00:25:43,760 --> 00:25:46,000
herbs are often queued for easier usage

731
00:25:46,000 --> 00:25:46,880
of drivers

732
00:25:46,880 --> 00:25:48,880
the reasons we care about them is that

733
00:25:48,880 --> 00:25:51,360
in each file access operation done by a

734
00:25:51,360 --> 00:25:51,919
thread

735
00:25:51,919 --> 00:25:54,240
triggers an earp in the kernel in other

736
00:25:54,240 --> 00:25:56,240
words every create file operation

737
00:25:56,240 --> 00:25:58,559
causes our minifilter driver to receive

738
00:25:58,559 --> 00:26:00,320
an error

739
00:26:00,320 --> 00:26:02,240
i want to point out that almost every

740
00:26:02,240 --> 00:26:03,760
code piece in the driver

741
00:26:03,760 --> 00:26:06,000
is being taken from microsoft github

742
00:26:06,000 --> 00:26:07,840
where you can see an example for a mini

743
00:26:07,840 --> 00:26:09,200
filter that does

744
00:26:09,200 --> 00:26:11,440
filter create write and delete

745
00:26:11,440 --> 00:26:13,440
operations

746
00:26:13,440 --> 00:26:16,559
the herbs that we care about are

747
00:26:16,559 --> 00:26:19,840
mj create mj write and mg set

748
00:26:19,840 --> 00:26:21,120
information

749
00:26:21,120 --> 00:26:23,679
well the first one mg create is not

750
00:26:23,679 --> 00:26:24,559
surprising

751
00:26:24,559 --> 00:26:26,159
it's triggered by a create file

752
00:26:26,159 --> 00:26:27,679
operation so

753
00:26:27,679 --> 00:26:30,240
every time a thread calls create file

754
00:26:30,240 --> 00:26:31,760
this earp will pop

755
00:26:31,760 --> 00:26:33,919
identifying it allows arbitrary create

756
00:26:33,919 --> 00:26:35,919
primitives with a sim link attack and

757
00:26:35,919 --> 00:26:37,919
finding potential dll hijacking

758
00:26:37,919 --> 00:26:39,600
opportunities

759
00:26:39,600 --> 00:26:42,720
the erpmj right is being generated upon

760
00:26:42,720 --> 00:26:44,080
a write file operation

761
00:26:44,080 --> 00:26:46,480
this is useful to understand if we want

762
00:26:46,480 --> 00:26:47,200
to

763
00:26:47,200 --> 00:26:49,120
exploit the arbitrary right type of

764
00:26:49,120 --> 00:26:51,039
vulnerabilities

765
00:26:51,039 --> 00:26:53,840
lastly the erpmj set information is

766
00:26:53,840 --> 00:26:55,760
useful in case we want to achieve

767
00:26:55,760 --> 00:26:57,120
arbitrary delete

768
00:26:57,120 --> 00:26:59,120
we need to check the set information

769
00:26:59,120 --> 00:27:01,120
class to know if its type is

770
00:27:01,120 --> 00:27:03,919
set disposition information file or set

771
00:27:03,919 --> 00:27:06,240
disposition information filix

772
00:27:06,240 --> 00:27:09,279
which indicates the file to be deleted

773
00:27:09,279 --> 00:27:12,000
so after catching the herbs we need a

774
00:27:12,000 --> 00:27:13,919
way to identify the thread that

775
00:27:13,919 --> 00:27:16,240
generated europe runs in a privileged

776
00:27:16,240 --> 00:27:17,200
process

777
00:27:17,200 --> 00:27:20,000
we do it by calling zw open thread token

778
00:27:20,000 --> 00:27:20,880
ex

779
00:27:20,880 --> 00:27:22,880
we can grab the token and we can check

780
00:27:22,880 --> 00:27:25,679
if the privileged user owns it

781
00:27:25,679 --> 00:27:27,840
we do it instead of calling zw open

782
00:27:27,840 --> 00:27:29,679
process token ex because

783
00:27:29,679 --> 00:27:32,000
we want the thread specific token and

784
00:27:32,000 --> 00:27:34,080
not necessarily the primary token of a

785
00:27:34,080 --> 00:27:35,600
process

786
00:27:35,600 --> 00:27:37,360
in the case the thread uses its

787
00:27:37,360 --> 00:27:38,880
impersonation token

788
00:27:38,880 --> 00:27:40,799
this will help us to prevent false

789
00:27:40,799 --> 00:27:42,480
positives

790
00:27:42,480 --> 00:27:44,880
so what we do in the driver is log in

791
00:27:44,880 --> 00:27:45,520
the name

792
00:27:45,520 --> 00:27:47,200
the path and the command line of the

793
00:27:47,200 --> 00:27:49,600
current process followed by parsing the

794
00:27:49,600 --> 00:27:50,960
destination path

795
00:27:50,960 --> 00:27:52,960
which is the path the privileged code is

796
00:27:52,960 --> 00:27:54,399
trying to access

797
00:27:54,399 --> 00:27:56,880
this is done by extracting it from the

798
00:27:56,880 --> 00:27:58,000
our packet

799
00:27:58,000 --> 00:28:00,399
we continue by calling se access check

800
00:28:00,399 --> 00:28:01,279
on the file

801
00:28:01,279 --> 00:28:04,480
with the token of the local guest user

802
00:28:04,480 --> 00:28:06,480
by doing so we can know if a limited

803
00:28:06,480 --> 00:28:08,799
user has access to the file at the end

804
00:28:08,799 --> 00:28:10,880
of the path

805
00:28:10,880 --> 00:28:12,480
if we have access to the path we

806
00:28:12,480 --> 00:28:14,640
continue to the exploitation phase

807
00:28:14,640 --> 00:28:16,640
to help the driver i created a local

808
00:28:16,640 --> 00:28:18,159
service that implements

809
00:28:18,159 --> 00:28:20,960
either dll hijacking or sim link attack

810
00:28:20,960 --> 00:28:22,799
the minifilter driver sends to the

811
00:28:22,799 --> 00:28:24,880
service the herb type we got

812
00:28:24,880 --> 00:28:27,440
this is important because the way we try

813
00:28:27,440 --> 00:28:29,600
to exploit arbitrary create files is

814
00:28:29,600 --> 00:28:30,480
different

815
00:28:30,480 --> 00:28:33,279
than arbitrary delete the target path

816
00:28:33,279 --> 00:28:35,679
should be different also

817
00:28:35,679 --> 00:28:37,600
then we impersonate the limited local

818
00:28:37,600 --> 00:28:39,600
user and create a mount point and a sim

819
00:28:39,600 --> 00:28:41,760
link within the impersonated thread

820
00:28:41,760 --> 00:28:45,200
to the destination path this guarantees

821
00:28:45,200 --> 00:28:46,240
us to mimic

822
00:28:46,240 --> 00:28:48,640
an elevation of privilege attack since

823
00:28:48,640 --> 00:28:50,720
using the token of a logger service

824
00:28:50,720 --> 00:28:53,760
is not that useful the service checks if

825
00:28:53,760 --> 00:28:55,200
the file been accessed

826
00:28:55,200 --> 00:28:57,039
in case of a write operation check if

827
00:28:57,039 --> 00:28:58,799
it's been edited

828
00:28:58,799 --> 00:29:00,799
in delete well check if the destination

829
00:29:00,799 --> 00:29:01,919
file is gone

830
00:29:01,919 --> 00:29:03,760
after that look the results to know if

831
00:29:03,760 --> 00:29:06,240
the attack has been successful

832
00:29:06,240 --> 00:29:08,080
the monitor and exploitation process of

833
00:29:08,080 --> 00:29:10,480
dll hijacking is fairly similar

834
00:29:10,480 --> 00:29:12,960
here the driver also catches the earp of

835
00:29:12,960 --> 00:29:14,159
mj create

836
00:29:14,159 --> 00:29:16,000
then it checks if the target path ends

837
00:29:16,000 --> 00:29:17,600
with dll

838
00:29:17,600 --> 00:29:19,760
i know it sounds kind of lame i thought

839
00:29:19,760 --> 00:29:20,640
about it too

840
00:29:20,640 --> 00:29:22,960
but it works most of the create file

841
00:29:22,960 --> 00:29:24,960
operations done on files that end up

842
00:29:24,960 --> 00:29:25,760
with

843
00:29:25,760 --> 00:29:29,039
dll will follow up by loading it we can

844
00:29:29,039 --> 00:29:31,679
also use the pset load image notifying

845
00:29:31,679 --> 00:29:32,880
routine to verify

846
00:29:32,880 --> 00:29:35,840
it lastly we do the same as before

847
00:29:35,840 --> 00:29:37,440
checking if we can access the target

848
00:29:37,440 --> 00:29:38,399
path

849
00:29:38,399 --> 00:29:40,399
the service continues by impersonating

850
00:29:40,399 --> 00:29:42,320
the local user like in the same link

851
00:29:42,320 --> 00:29:43,440
exploitation

852
00:29:43,440 --> 00:29:45,360
followed by planting a semi-malicious

853
00:29:45,360 --> 00:29:48,240
dll that does dll proxy if it's a known

854
00:29:48,240 --> 00:29:49,360
dll

855
00:29:49,360 --> 00:29:52,000
otherwise we just create a dll with the

856
00:29:52,000 --> 00:29:53,360
desired name

857
00:29:53,360 --> 00:29:56,880
hoping it will be loaded now let's see a

858
00:29:56,880 --> 00:29:58,960
quick example of a very recent bug

859
00:29:58,960 --> 00:30:02,480
discovered and fully exploited by iknaya

860
00:30:02,480 --> 00:30:04,399
here we look at two venerabilities in

861
00:30:04,399 --> 00:30:06,000
intel support assistant

862
00:30:06,000 --> 00:30:09,039
which both have the same root source

863
00:30:09,039 --> 00:30:11,200
intel support assistant is an updater

864
00:30:11,200 --> 00:30:12,720
service that tries to download and

865
00:30:12,720 --> 00:30:14,480
install the latest drivers on your

866
00:30:14,480 --> 00:30:15,440
machine

867
00:30:15,440 --> 00:30:17,679
the code responsible for writing the new

868
00:30:17,679 --> 00:30:19,440
updates and the deletion of older

869
00:30:19,440 --> 00:30:20,080
versions

870
00:30:20,080 --> 00:30:23,120
do not impersonate the local user and

871
00:30:23,120 --> 00:30:25,120
therefore we have two vulnerabilities

872
00:30:25,120 --> 00:30:26,480
because of it

873
00:30:26,480 --> 00:30:28,399
for some reasons the service tries to

874
00:30:28,399 --> 00:30:30,240
delete previous versions of the

875
00:30:30,240 --> 00:30:32,960
updates inside into support assistance

876
00:30:32,960 --> 00:30:34,720
inside the downloads folder

877
00:30:34,720 --> 00:30:36,880
it might be a rollback mechanism of some

878
00:30:36,880 --> 00:30:38,080
sort

879
00:30:38,080 --> 00:30:40,720
also it tries to write the updated

880
00:30:40,720 --> 00:30:43,679
versions into the same very directory

881
00:30:43,679 --> 00:30:46,000
as unprivileged user we can ask the

882
00:30:46,000 --> 00:30:47,840
service to scan our machine

883
00:30:47,840 --> 00:30:50,159
for new versions and download them this

884
00:30:50,159 --> 00:30:52,080
will cause the service to do a clean up

885
00:30:52,080 --> 00:30:54,640
of its directory inside the downloads

886
00:30:54,640 --> 00:30:56,240
directory

887
00:30:56,240 --> 00:30:58,240
so we can place a mount point and a sim

888
00:30:58,240 --> 00:31:00,320
link on a file and it will be re-parsed

889
00:31:00,320 --> 00:31:03,440
to any file granting us arbitrary delete

890
00:31:03,440 --> 00:31:05,600
alternatively we can choose to download

891
00:31:05,600 --> 00:31:06,559
the updates

892
00:31:06,559 --> 00:31:08,399
if we put a mount point and a sim link

893
00:31:08,399 --> 00:31:09,760
the service will follow them

894
00:31:09,760 --> 00:31:12,720
writing the payload to whatever we want

895
00:31:12,720 --> 00:31:14,720
we also have lock on our side

896
00:31:14,720 --> 00:31:17,440
because it later calls a security file

897
00:31:17,440 --> 00:31:18,640
if things were not

898
00:31:18,640 --> 00:31:20,640
bad enough so we actually gained

899
00:31:20,640 --> 00:31:23,440
arbitrary right because of it

900
00:31:23,440 --> 00:31:27,200
so igni got irp mj set information

901
00:31:27,200 --> 00:31:29,600
it extracted the information class to

902
00:31:29,600 --> 00:31:30,399
determine

903
00:31:30,399 --> 00:31:32,720
if it's of the type of set disposition

904
00:31:32,720 --> 00:31:34,240
information file or a

905
00:31:34,240 --> 00:31:37,360
set disposition information file ex

906
00:31:37,360 --> 00:31:40,240
which this is actually the case then it

907
00:31:40,240 --> 00:31:41,840
checked the security context of the

908
00:31:41,840 --> 00:31:44,159
thread that did the delete operation

909
00:31:44,159 --> 00:31:46,320
this service was notified so we created

910
00:31:46,320 --> 00:31:47,919
a mount point and a sim link and the

911
00:31:47,919 --> 00:31:50,240
target file got deleted

912
00:31:50,240 --> 00:31:52,159
in the same way i cannot implement an

913
00:31:52,159 --> 00:31:53,760
arbitrary write attack

914
00:31:53,760 --> 00:31:56,799
we were later fortune because of the

915
00:31:56,799 --> 00:32:00,559
call of security file as we saw before

916
00:32:00,559 --> 00:32:02,399
having an automatic system that finds

917
00:32:02,399 --> 00:32:03,919
vulnerabilities in services and

918
00:32:03,919 --> 00:32:06,559
installers is not that hard thing to do

919
00:32:06,559 --> 00:32:08,399
everyone who has some experience on

920
00:32:08,399 --> 00:32:09,919
writing minifilter drivers could

921
00:32:09,919 --> 00:32:12,080
probably create a better one than i did

922
00:32:12,080 --> 00:32:14,480
i'm not a programmer by using the system

923
00:32:14,480 --> 00:32:17,120
i was able to find a vast number of bugs

924
00:32:17,120 --> 00:32:18,799
the system just looked if two

925
00:32:18,799 --> 00:32:20,559
exploitation methods could be used

926
00:32:20,559 --> 00:32:22,720
imagine in adding the automation of

927
00:32:22,720 --> 00:32:23,679
other methods

928
00:32:23,679 --> 00:32:26,399
to find even more vulnerabilities a

929
00:32:26,399 --> 00:32:28,320
similar system can be useful for both

930
00:32:28,320 --> 00:32:30,159
developers and security researchers

931
00:32:30,159 --> 00:32:31,120
alike

932
00:32:31,120 --> 00:32:32,480
mitigating against those two

933
00:32:32,480 --> 00:32:34,640
exploitation methods is not that hard

934
00:32:34,640 --> 00:32:36,880
it's pretty simple loading only signed

935
00:32:36,880 --> 00:32:38,880
dll has been an option since windows

936
00:32:38,880 --> 00:32:39,679
vista

937
00:32:39,679 --> 00:32:41,679
still no one seems to implement dll

938
00:32:41,679 --> 00:32:42,960
signature checking

939
00:32:42,960 --> 00:32:44,799
this all together will remove the risk

940
00:32:44,799 --> 00:32:47,120
of dll hijacking for good

941
00:32:47,120 --> 00:32:49,120
regarding the same vulnerabilities just

942
00:32:49,120 --> 00:32:50,799
change the access control list of the

943
00:32:50,799 --> 00:32:52,799
directory

944
00:32:52,799 --> 00:32:55,039
besides the joy of finding security bugs

945
00:32:55,039 --> 00:32:56,880
i now understand the danger of doing

946
00:32:56,880 --> 00:32:59,600
privileged file operations irresponsibly

947
00:32:59,600 --> 00:33:01,600
in other words i like less the amount of

948
00:33:01,600 --> 00:33:03,600
stuff vendors put on my machine right of

949
00:33:03,600 --> 00:33:04,559
the box

950
00:33:04,559 --> 00:33:06,320
as you can see the word to privilege

951
00:33:06,320 --> 00:33:08,480
escalation is not that long

952
00:33:08,480 --> 00:33:11,039
before we finish here is a picture that

953
00:33:11,039 --> 00:33:13,039
shows some numbers

954
00:33:13,039 --> 00:33:15,760
28 vendors were tested and were found to

955
00:33:15,760 --> 00:33:16,720
be vulnerable

956
00:33:16,720 --> 00:33:18,880
over 90 bugs were being discovered and

957
00:33:18,880 --> 00:33:21,600
over 120 cases were opened

958
00:33:21,600 --> 00:33:24,480
trust me those are a lot of emails and

959
00:33:24,480 --> 00:33:26,159
if you want any tip from me

960
00:33:26,159 --> 00:33:28,240
don't do it from your private account do

961
00:33:28,240 --> 00:33:30,399
not repeat the mistake i did

962
00:33:30,399 --> 00:33:32,480
and if you remember one thing from this

963
00:33:32,480 --> 00:33:34,880
talk do privilege escalations

964
00:33:34,880 --> 00:33:38,080
with care i did not start this research

965
00:33:38,080 --> 00:33:38,960
from scratch

966
00:33:38,960 --> 00:33:40,640
i want to thank james forshaw for his

967
00:33:40,640 --> 00:33:42,080
blogs and awesome tools

968
00:33:42,080 --> 00:33:43,840
specifically speaking his anti-object

969
00:33:43,840 --> 00:33:46,240
manager package also thanks for clement

970
00:33:46,240 --> 00:33:47,600
for his great blogs

971
00:33:47,600 --> 00:33:51,120
and lastly to microsoft for all examples

972
00:33:51,120 --> 00:33:52,000
about many filter

973
00:33:52,000 --> 00:33:54,720
drivers it will be very difficult to do

974
00:33:54,720 --> 00:33:56,559
it without them

975
00:33:56,559 --> 00:33:58,799
and that's it if you have any questions

976
00:33:58,799 --> 00:34:00,640
please feel free to ask

977
00:34:00,640 --> 00:34:03,039
you can also contact me on my email and

978
00:34:03,039 --> 00:34:07,840
on my twitter account

979
00:34:08,239 --> 00:34:11,440
thank you iran for having shared with us

980
00:34:11,440 --> 00:34:14,000
such a powerful methodology to identify

981
00:34:14,000 --> 00:34:16,159
high security vulnerabilities in windows

982
00:34:16,159 --> 00:34:17,520
systems

983
00:34:17,520 --> 00:34:20,320
and how our audience has some question

984
00:34:20,320 --> 00:34:21,599
for you

985
00:34:21,599 --> 00:34:24,879
let's go so uh

986
00:34:24,879 --> 00:34:28,480
the first one is about

987
00:34:28,480 --> 00:34:31,679
uh the installers so

988
00:34:31,679 --> 00:34:35,359
uh our do you do you have

989
00:34:35,359 --> 00:34:39,040
an idea of uh uh the percentage

990
00:34:39,040 --> 00:34:41,520
of installers you found to be vulnerable

991
00:34:41,520 --> 00:34:42,719
and are you aware

992
00:34:42,719 --> 00:34:45,040
if there are any malware in the y that

993
00:34:45,040 --> 00:34:46,960
is able to exploit this factor

994
00:34:46,960 --> 00:34:48,560
programmatically perform

995
00:34:48,560 --> 00:34:52,239
the previous escalation thanks lina

996
00:34:52,239 --> 00:34:54,480
well in the beginning of the research i

997
00:34:54,480 --> 00:34:56,079
think the number of vulnerable

998
00:34:56,079 --> 00:34:58,240
installers were around 95

999
00:34:58,240 --> 00:35:01,200
of them made by big vendors like

1000
00:35:01,200 --> 00:35:03,119
microsoft intel dell and

1001
00:35:03,119 --> 00:35:06,160
whatever i didn't check a smaller ones

1002
00:35:06,160 --> 00:35:10,000
after sending reports to them

1003
00:35:10,000 --> 00:35:12,880
i think the number reduced dramatically

1004
00:35:12,880 --> 00:35:13,760
to around the

1005
00:35:13,760 --> 00:35:16,560
10 percent so i feel a lot more secure

1006
00:35:16,560 --> 00:35:18,640
in that regard

1007
00:35:18,640 --> 00:35:21,839
and many more try to do privilege

1008
00:35:21,839 --> 00:35:22,720
escalation

1009
00:35:22,720 --> 00:35:24,800
especially trying to execute some one

1010
00:35:24,800 --> 00:35:25,760
day strategy

1011
00:35:25,760 --> 00:35:29,599
less of zero days but

1012
00:35:29,599 --> 00:35:32,160
since i think last several years i

1013
00:35:32,160 --> 00:35:33,280
haven't seen one that

1014
00:35:33,280 --> 00:35:36,400
actually exploited diadel hijacking

1015
00:35:36,400 --> 00:35:39,680
but i'm not that up to date in the last

1016
00:35:39,680 --> 00:35:40,480
few years

1017
00:35:40,480 --> 00:35:43,760
of that but it's pretty easy to actually

1018
00:35:43,760 --> 00:35:44,560
execute it

1019
00:35:44,560 --> 00:35:48,160
and anti-virus product do not do

1020
00:35:48,160 --> 00:35:50,320
anything because it's a feature of the

1021
00:35:50,320 --> 00:35:52,400
operating system

1022
00:35:52,400 --> 00:35:55,040
i hope it answers the question okay

1023
00:35:55,040 --> 00:35:55,760
thank you

1024
00:35:55,760 --> 00:36:00,079
the second one is regarding iknaya

1025
00:36:00,079 --> 00:36:03,200
one guy is asking us if it's an open

1026
00:36:03,200 --> 00:36:05,200
source tool available somewhere probably

1027
00:36:05,200 --> 00:36:06,480
the community wants to

1028
00:36:06,480 --> 00:36:10,800
contribute and such an interesting tool

1029
00:36:10,800 --> 00:36:12,880
so great and thanks for the question

1030
00:36:12,880 --> 00:36:14,000
well not

1031
00:36:14,000 --> 00:36:16,560
let's not be confused with the mozilla's

1032
00:36:16,560 --> 00:36:18,240
framework ikna which i

1033
00:36:18,240 --> 00:36:20,480
accidentally named the same i didn't

1034
00:36:20,480 --> 00:36:22,480
know about it when i developed it

1035
00:36:22,480 --> 00:36:25,200
i really hope to publish it and open it

1036
00:36:25,200 --> 00:36:26,079
soon at github

1037
00:36:26,079 --> 00:36:31,359
i do have some problems of it for my

1038
00:36:31,359 --> 00:36:34,320
the place where which i work in that

1039
00:36:34,320 --> 00:36:36,880
concern in it but

1040
00:36:36,880 --> 00:36:40,400
as you have seen it's pretty easy to do

1041
00:36:40,400 --> 00:36:42,400
the same as i did and you can contact me

1042
00:36:42,400 --> 00:36:44,079
on whatever

1043
00:36:44,079 --> 00:36:45,520
a question you have regarding mini

1044
00:36:45,520 --> 00:36:47,520
filtered drivers to actually

1045
00:36:47,520 --> 00:36:51,680
do the same and probably better

1046
00:36:51,920 --> 00:36:54,079
okay i really don't know it's so easy to

1047
00:36:54,079 --> 00:36:55,760
do it you do you

1048
00:36:55,760 --> 00:36:59,359
made a really good job and so maybe it's

1049
00:36:59,359 --> 00:37:01,119
a good starting point for you and for

1050
00:37:01,119 --> 00:37:03,119
community to contribute and

1051
00:37:03,119 --> 00:37:05,520
enlarge and announce this kind of tool

1052
00:37:05,520 --> 00:37:06,560
that could be really

1053
00:37:06,560 --> 00:37:10,400
really useful and the last one i think

1054
00:37:10,400 --> 00:37:13,680
is will you plan to further develop or

1055
00:37:13,680 --> 00:37:15,440
extend the tool you developed for

1056
00:37:15,440 --> 00:37:16,720
example for exploring

1057
00:37:16,720 --> 00:37:19,760
other current cases yeah the answer is

1058
00:37:19,760 --> 00:37:20,240
yes

1059
00:37:20,240 --> 00:37:22,480
even though my research subject a bit

1060
00:37:22,480 --> 00:37:23,359
shifted through

1061
00:37:23,359 --> 00:37:26,400
uh driver exploitation there's

1062
00:37:26,400 --> 00:37:29,200
there are some connections to be done

1063
00:37:29,200 --> 00:37:29,760
with this

1064
00:37:29,760 --> 00:37:32,079
and the backbone which is actually uh

1065
00:37:32,079 --> 00:37:32,960
the mini

1066
00:37:32,960 --> 00:37:36,560
driver is also very useful in

1067
00:37:36,560 --> 00:37:40,000
driver exploitation so yes i do believe

1068
00:37:40,000 --> 00:37:41,359
that i will find

1069
00:37:41,359 --> 00:37:44,720
more bugs in that area but i haven't

1070
00:37:44,720 --> 00:37:46,480
tested any other

1071
00:37:46,480 --> 00:37:49,599
file exploitation methods that i wish to

1072
00:37:49,599 --> 00:37:52,400
automate but if you have some examples

1073
00:37:52,400 --> 00:37:54,000
i'll be more than

1074
00:37:54,000 --> 00:37:57,440
happy to go for it

1075
00:37:57,440 --> 00:38:00,000
okay really interesting so maybe in all

1076
00:38:00,000 --> 00:38:00,599
hats

1077
00:38:00,599 --> 00:38:04,160
2021 we will have you to explain us how

1078
00:38:04,160 --> 00:38:05,839
to exploit drivers that is a

1079
00:38:05,839 --> 00:38:08,800
really another really interesting topic

1080
00:38:08,800 --> 00:38:09,280
yeah i

1081
00:38:09,280 --> 00:38:12,400
only found two bugs so far but not 16 16

1082
00:38:12,400 --> 00:38:14,240
days but let's

1083
00:38:14,240 --> 00:38:17,920
continue you have one year in order to

1084
00:38:17,920 --> 00:38:21,200
find other other facts so

1085
00:38:21,200 --> 00:38:23,920
thank you very much again iran for your

1086
00:38:23,920 --> 00:38:25,040
presentation

1087
00:38:25,040 --> 00:38:29,279
and see you thank you bye-bye

1088
00:38:30,839 --> 00:38:33,839
bye

1089
00:38:33,920 --> 00:38:36,000
you

