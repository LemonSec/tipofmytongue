1
00:00:56,559 --> 00:00:57,680
so the next

2
00:00:57,680 --> 00:01:01,120
so the dexter speaker is uh uh filippo

3
00:01:01,120 --> 00:01:04,479
felipe cremone uh is a

4
00:01:04,479 --> 00:01:06,799
is a security researcher he's

5
00:01:06,799 --> 00:01:08,080
specialized in uh

6
00:01:08,080 --> 00:01:10,880
um he is specializing web security

7
00:01:10,880 --> 00:01:12,240
cryptography

8
00:01:12,240 --> 00:01:15,520
and as we can see uh also reverse

9
00:01:15,520 --> 00:01:16,799
engineering

10
00:01:16,799 --> 00:01:19,840
and uh um and uh

11
00:01:19,840 --> 00:01:23,280
and uh binary analysis and uh and uh

12
00:01:23,280 --> 00:01:26,560
and uh and basically him so

13
00:01:26,560 --> 00:01:29,759
during the um so during the day he's

14
00:01:29,759 --> 00:01:31,680
working at a rev ng

15
00:01:31,680 --> 00:01:35,759
um uh he plays uh

16
00:01:35,759 --> 00:01:41,759
uh can you can you put the slide please

17
00:01:41,759 --> 00:01:44,240
martial

18
00:01:45,200 --> 00:01:48,479
during the day he he plays uh

19
00:01:48,479 --> 00:01:51,439
with uh with a binary analysis tool they

20
00:01:51,439 --> 00:01:54,399
develop at their riven g

21
00:01:54,399 --> 00:01:58,159
and at night and uh so during his spare

22
00:01:58,159 --> 00:02:01,119
time he plays ctf's with tower of hanoi

23
00:02:01,119 --> 00:02:04,240
so and also macaroni and the other

24
00:02:04,240 --> 00:02:07,680
other teams so uh he's uh

25
00:02:07,680 --> 00:02:10,160
working on his master thesis at

26
00:02:10,160 --> 00:02:11,840
polytechnic in the milano

27
00:02:11,840 --> 00:02:13,520
and uh aiming to discover

28
00:02:13,520 --> 00:02:15,040
vulnerabilities in the

29
00:02:15,040 --> 00:02:19,120
xa 509 parcels so the topic it will uh

30
00:02:19,120 --> 00:02:21,440
it will talk us about as a

31
00:02:21,440 --> 00:02:25,200
very hardcore it's a

32
00:02:25,200 --> 00:02:28,400
about a binary editing under high with

33
00:02:28,400 --> 00:02:31,440
high level languages so basically uh

34
00:02:31,440 --> 00:02:35,440
he will show us how to

35
00:02:35,440 --> 00:02:39,280
how he implemented a tool

36
00:02:39,280 --> 00:02:42,959
to patch an executive ball

37
00:02:42,959 --> 00:02:46,959
without having to rewrite a

38
00:02:46,959 --> 00:02:49,120
tedious assembly and doing complex

39
00:02:49,120 --> 00:02:50,959
binary manipulation

40
00:02:50,959 --> 00:02:54,000
um he did so by abusing

41
00:02:54,000 --> 00:02:57,760
the ll and llvm just in time engine

42
00:02:57,760 --> 00:03:01,760
and the tool will uh that is crispr

43
00:03:01,760 --> 00:03:04,319
allows you to statically rewrite

44
00:03:04,319 --> 00:03:05,599
individual function

45
00:03:05,599 --> 00:03:08,959
in an existing binary using c or any

46
00:03:08,959 --> 00:03:09,840
other language

47
00:03:09,840 --> 00:03:13,280
but it will explain why you use the c

48
00:03:13,280 --> 00:03:16,640
and possible to call

49
00:03:16,640 --> 00:03:19,360
existing functions or non-existing

50
00:03:19,360 --> 00:03:21,440
functions externally and also how to

51
00:03:21,440 --> 00:03:22,239
patch

52
00:03:22,239 --> 00:03:26,239
um how to how to tackle some challenges

53
00:03:26,239 --> 00:03:28,640
like having to patch

54
00:03:28,640 --> 00:03:31,680
binaries that ends up

55
00:03:31,680 --> 00:03:34,959
in a patched form bigger than uh than

56
00:03:34,959 --> 00:03:38,000
uh than they were initially

57
00:03:38,000 --> 00:03:41,280
um so it will also explain and

58
00:03:41,280 --> 00:03:44,560
and show us some example with uh

59
00:03:44,560 --> 00:03:46,959
with a alpha and explains also some

60
00:03:46,959 --> 00:03:48,239
peculiarities

61
00:03:48,239 --> 00:03:51,120
of alpha format and how these techniques

62
00:03:51,120 --> 00:03:51,920
applies to

63
00:03:51,920 --> 00:03:54,959
health and um

64
00:03:54,959 --> 00:03:58,159
so this this tool is a potentially a

65
00:03:58,159 --> 00:03:59,599
game changer

66
00:03:59,599 --> 00:04:02,080
in real world binary patching scenario

67
00:04:02,080 --> 00:04:02,879
or almost

68
00:04:02,879 --> 00:04:05,920
real world like a ctfs especially

69
00:04:05,920 --> 00:04:08,799
attack and defense etfs and it will

70
00:04:08,799 --> 00:04:09,519
release

71
00:04:09,519 --> 00:04:12,560
as open source so

72
00:04:12,560 --> 00:04:15,840
let's move on to the next talk

73
00:04:15,840 --> 00:04:19,840
and uh so filipino cremone

74
00:04:20,079 --> 00:04:23,359
so you will take the stage

75
00:04:24,080 --> 00:04:26,479
hi everyone and welcome to my talk about

76
00:04:26,479 --> 00:04:28,160
static binary patching using

77
00:04:28,160 --> 00:04:31,199
high-level languages now a

78
00:04:31,199 --> 00:04:33,680
couple of words about myself my name is

79
00:04:33,680 --> 00:04:35,199
filippo carmonese and i

80
00:04:35,199 --> 00:04:37,440
work for revenge we are a small company

81
00:04:37,440 --> 00:04:39,600
and we do all things binary so ranging

82
00:04:39,600 --> 00:04:41,360
from binary analysis to writing

83
00:04:41,360 --> 00:04:42,000
emulators

84
00:04:42,000 --> 00:04:46,000
and compilers we do a lot of interesting

85
00:04:46,000 --> 00:04:46,400
stuff

86
00:04:46,400 --> 00:04:48,400
for instance we are the maintainers of

87
00:04:48,400 --> 00:04:49,840
the hexagon support

88
00:04:49,840 --> 00:04:52,080
in qemu we also developed an

89
00:04:52,080 --> 00:04:54,000
architecture independent static binary

90
00:04:54,000 --> 00:04:54,720
translator

91
00:04:54,720 --> 00:04:57,040
and we are in the process of developing

92
00:04:57,040 --> 00:04:59,440
a new decompiler which we call revenge c

93
00:04:59,440 --> 00:05:02,240
for which we recently opened access for

94
00:05:02,240 --> 00:05:03,600
our nightly builds so if you're

95
00:05:03,600 --> 00:05:04,560
interested in that

96
00:05:04,560 --> 00:05:05,919
please check out our website and

97
00:05:05,919 --> 00:05:08,479
register to gain access

98
00:05:08,479 --> 00:05:11,360
now when we talk about binary patching

99
00:05:11,360 --> 00:05:11,919
we mean

100
00:05:11,919 --> 00:05:14,160
altering a compiled program behavior

101
00:05:14,160 --> 00:05:16,400
without recompiling it also because we

102
00:05:16,400 --> 00:05:19,280
may not have access to its source code

103
00:05:19,280 --> 00:05:21,440
now there are a wide range of reasons

104
00:05:21,440 --> 00:05:23,520
why you may want to do it

105
00:05:23,520 --> 00:05:25,840
and one of those is you may want to fix

106
00:05:25,840 --> 00:05:27,600
a bug or vulnerability that you find in

107
00:05:27,600 --> 00:05:28,400
a binary

108
00:05:28,400 --> 00:05:30,240
or maybe you want to add some dynamic

109
00:05:30,240 --> 00:05:32,080
analysis features to it so

110
00:05:32,080 --> 00:05:34,560
maybe trace function calls and function

111
00:05:34,560 --> 00:05:35,600
parameters

112
00:05:35,600 --> 00:05:37,440
or add some code that collects some

113
00:05:37,440 --> 00:05:39,759
statistics for instance

114
00:05:39,759 --> 00:05:41,759
patching a binary is also useful if you

115
00:05:41,759 --> 00:05:43,759
want to implement some cheats in a game

116
00:05:43,759 --> 00:05:44,160
or

117
00:05:44,160 --> 00:05:46,479
if you want to place a backdoor or

118
00:05:46,479 --> 00:05:49,280
bypass some pesky drm

119
00:05:49,280 --> 00:05:51,840
so i like to go by example and i will

120
00:05:51,840 --> 00:05:52,560
use

121
00:05:52,560 --> 00:05:55,600
a quote real world example taken from

122
00:05:55,600 --> 00:05:57,840
bruce tf 2018 finance

123
00:05:57,840 --> 00:06:00,720
ribbons challenge this challenge had a

124
00:06:00,720 --> 00:06:01,919
function

125
00:06:01,919 --> 00:06:04,479
which is this and it has a vulnerability

126
00:06:04,479 --> 00:06:06,479
in the mem copy usage

127
00:06:06,479 --> 00:06:08,639
as you can see you may already already

128
00:06:08,639 --> 00:06:11,280
have spotted it the main copy uses as x

129
00:06:11,280 --> 00:06:13,520
as its length the string length of the

130
00:06:13,520 --> 00:06:14,479
new password

131
00:06:14,479 --> 00:06:17,039
now the new password comes from the user

132
00:06:17,039 --> 00:06:18,000
so the user

133
00:06:18,000 --> 00:06:21,039
is able to provide a password which is

134
00:06:21,039 --> 00:06:23,360
too long to fit into the password field

135
00:06:23,360 --> 00:06:25,199
of the channel structure

136
00:06:25,199 --> 00:06:28,160
and you cannot see it from here but this

137
00:06:28,160 --> 00:06:28,639
allowed

138
00:06:28,639 --> 00:06:31,440
you to overwrite a pointer and by

139
00:06:31,440 --> 00:06:32,960
overwriting the pointer you can you

140
00:06:32,960 --> 00:06:34,560
could then leak memory

141
00:06:34,560 --> 00:06:36,639
and with that primitive leak passwords

142
00:06:36,639 --> 00:06:39,199
for other channels and ultimately

143
00:06:39,199 --> 00:06:42,720
leak some flags now the urus tf 2000

144
00:06:42,720 --> 00:06:46,160
and the rusty f is an attack defense ctf

145
00:06:46,160 --> 00:06:48,880
so during the child the the game you're

146
00:06:48,880 --> 00:06:49,360
not

147
00:06:49,360 --> 00:06:51,680
only required to exploit vulnerabilities

148
00:06:51,680 --> 00:06:53,199
but you're also required to

149
00:06:53,199 --> 00:06:55,520
patch yourself to defend it to defend

150
00:06:55,520 --> 00:06:56,960
against others

151
00:06:56,960 --> 00:06:59,919
so the usual approach to this is to

152
00:06:59,919 --> 00:07:00,400
patch

153
00:07:00,400 --> 00:07:02,720
manually so you have to go find the

154
00:07:02,720 --> 00:07:03,840
vulnerability

155
00:07:03,840 --> 00:07:07,039
and then write some assembly manually

156
00:07:07,039 --> 00:07:10,720
to patch the vulnerability out

157
00:07:10,720 --> 00:07:13,840
now this specific instance is not

158
00:07:13,840 --> 00:07:16,960
even that hard to do you for instance

159
00:07:16,960 --> 00:07:18,880
one way to do it is to

160
00:07:18,880 --> 00:07:21,919
change the call to string length into a

161
00:07:21,919 --> 00:07:24,960
correct move into eax to

162
00:07:24,960 --> 00:07:27,360
have the correct size that gets then

163
00:07:27,360 --> 00:07:30,160
passed to women copy

164
00:07:30,160 --> 00:07:33,599
but this is just

165
00:07:33,599 --> 00:07:36,880
not nice it's tedious

166
00:07:36,880 --> 00:07:39,520
to write possibly manually and it's also

167
00:07:39,520 --> 00:07:41,520
really error prone and when time is of

168
00:07:41,520 --> 00:07:43,039
the essence such as during

169
00:07:43,039 --> 00:07:45,680
ctf challenge or when you just don't

170
00:07:45,680 --> 00:07:47,520
want to get something wrong

171
00:07:47,520 --> 00:07:48,960
if you're a bank and you want to patch

172
00:07:48,960 --> 00:07:51,680
some program

173
00:07:51,919 --> 00:07:55,199
this is just not a nice approach so

174
00:07:55,199 --> 00:07:58,479
wouldn't it be nice instead if we

175
00:07:58,479 --> 00:08:01,360
to be able to decompile the function

176
00:08:01,360 --> 00:08:02,080
edit it

177
00:08:02,080 --> 00:08:04,960
and click apply without any hassle any

178
00:08:04,960 --> 00:08:06,240
manual

179
00:08:06,240 --> 00:08:09,039
work and this is what we're trying to

180
00:08:09,039 --> 00:08:09,840
build with

181
00:08:09,840 --> 00:08:12,960
crispr now crispr is a tool that

182
00:08:12,960 --> 00:08:15,919
applies arbitrary patches to binaries

183
00:08:15,919 --> 00:08:16,160
and

184
00:08:16,160 --> 00:08:19,039
does so in the least invasive way

185
00:08:19,039 --> 00:08:19,840
possible

186
00:08:19,840 --> 00:08:22,800
so if possible it does it even in place

187
00:08:22,800 --> 00:08:23,840
just as you would

188
00:08:23,840 --> 00:08:27,039
manually and this means that there is no

189
00:08:27,039 --> 00:08:27,919
size increase

190
00:08:27,919 --> 00:08:31,599
and minimal modifications to the binary

191
00:08:31,599 --> 00:08:33,599
but it also supports some advanced

192
00:08:33,599 --> 00:08:35,919
features such as the ability to link new

193
00:08:35,919 --> 00:08:37,919
dynamic libraries together with

194
00:08:37,919 --> 00:08:41,360
your patch it's also completely static

195
00:08:41,360 --> 00:08:43,120
and by that we mean that we do not

196
00:08:43,120 --> 00:08:44,480
require any runtime

197
00:08:44,480 --> 00:08:47,839
and there is so almost no performance

198
00:08:47,839 --> 00:08:49,120
overhead

199
00:08:49,120 --> 00:08:51,519
there is no reliance on any operating

200
00:08:51,519 --> 00:08:52,320
system or

201
00:08:52,320 --> 00:08:55,200
on any debug features we plan to

202
00:08:55,200 --> 00:08:56,160
integrate in

203
00:08:56,160 --> 00:08:59,120
to integrate crispr into revenge ui so

204
00:08:59,120 --> 00:09:00,399
you will be able

205
00:09:00,399 --> 00:09:03,200
uh to decompile a function edit it and

206
00:09:03,200 --> 00:09:04,000
click apply

207
00:09:04,000 --> 00:09:06,480
literally we also like to mention that

208
00:09:06,480 --> 00:09:07,600
we built it using

209
00:09:07,600 --> 00:09:11,040
lvn because we use a lvm every day for

210
00:09:11,040 --> 00:09:11,680
our work

211
00:09:11,680 --> 00:09:14,160
and we think that it's a really great

212
00:09:14,160 --> 00:09:14,880
framework

213
00:09:14,880 --> 00:09:18,480
suited for doing something like this

214
00:09:18,480 --> 00:09:22,240
now this is the high level overview of

215
00:09:22,240 --> 00:09:23,440
how crispr works

216
00:09:23,440 --> 00:09:25,760
we start from our original binary and

217
00:09:25,760 --> 00:09:26,720
using the

218
00:09:26,720 --> 00:09:28,880
tool of our choice we decompile it and

219
00:09:28,880 --> 00:09:31,279
we edit the source of the function that

220
00:09:31,279 --> 00:09:33,200
we want to patch

221
00:09:33,200 --> 00:09:35,680
from this we take the source code of our

222
00:09:35,680 --> 00:09:38,160
patch and we compile it using a custom

223
00:09:38,160 --> 00:09:40,560
compiler to an object file

224
00:09:40,560 --> 00:09:43,360
then we pass this object file and the

225
00:09:43,360 --> 00:09:45,120
symbols recovered from the original

226
00:09:45,120 --> 00:09:46,640
binary

227
00:09:46,640 --> 00:09:49,440
to a linker to produce some link code

228
00:09:49,440 --> 00:09:50,000
and then

229
00:09:50,000 --> 00:09:51,920
ultimately we pass it to a component

230
00:09:51,920 --> 00:09:53,600
which we call the patcher

231
00:09:53,600 --> 00:09:55,600
which takes the original binary and the

232
00:09:55,600 --> 00:09:57,360
new code that we produced

233
00:09:57,360 --> 00:09:59,839
and it merges them to produce a patch

234
00:09:59,839 --> 00:10:01,440
binary

235
00:10:01,440 --> 00:10:03,760
now this process is quite involved so i

236
00:10:03,760 --> 00:10:07,200
will start from a simple example

237
00:10:07,200 --> 00:10:09,040
and let's assume we want just to patch

238
00:10:09,040 --> 00:10:10,800
the original function with

239
00:10:10,800 --> 00:10:14,320
a correct version which uses string copy

240
00:10:14,320 --> 00:10:16,240
instead of mem copy

241
00:10:16,240 --> 00:10:18,800
to copy the password from the user of

242
00:10:18,800 --> 00:10:19,839
course using the

243
00:10:19,839 --> 00:10:22,160
correct size the correct size boundary

244
00:10:22,160 --> 00:10:24,000
and ensuring that the last byte

245
00:10:24,000 --> 00:10:27,040
is zeroed now to do this

246
00:10:27,040 --> 00:10:29,279
the first thing we want to do is to

247
00:10:29,279 --> 00:10:30,320
translate our c

248
00:10:30,320 --> 00:10:33,040
source code to llb mir because crispr

249
00:10:33,040 --> 00:10:34,720
takes llvmir

250
00:10:34,720 --> 00:10:37,279
as an input and not any link programming

251
00:10:37,279 --> 00:10:38,000
language

252
00:10:38,000 --> 00:10:41,120
source now to do this we just use a c

253
00:10:41,120 --> 00:10:42,800
length with a couple of

254
00:10:42,800 --> 00:10:44,959
flags that to instruct it to generate

255
00:10:44,959 --> 00:10:47,200
llb mir and to disable

256
00:10:47,200 --> 00:10:49,040
exception support because we don't need

257
00:10:49,040 --> 00:10:51,040
it and it will generate more compact

258
00:10:51,040 --> 00:10:52,000
code

259
00:10:52,000 --> 00:10:54,800
now notice that that because crispr uses

260
00:10:54,800 --> 00:10:57,120
llvmir as an input

261
00:10:57,120 --> 00:10:59,120
it is possible at least impressive to

262
00:10:59,120 --> 00:11:00,959
use any programming languages

263
00:11:00,959 --> 00:11:02,640
any programming language for which there

264
00:11:02,640 --> 00:11:05,279
is an llvm frontend

265
00:11:05,279 --> 00:11:07,839
now not all programming languages are

266
00:11:07,839 --> 00:11:09,760
well suited for this task

267
00:11:09,760 --> 00:11:12,800
because many programming languages

268
00:11:12,800 --> 00:11:17,120
require a complex runtime a big runtime

269
00:11:17,120 --> 00:11:20,480
to work so it would mean that you need

270
00:11:20,480 --> 00:11:21,600
also to include

271
00:11:21,600 --> 00:11:23,839
the runtime for the language together

272
00:11:23,839 --> 00:11:24,959
with the patch

273
00:11:24,959 --> 00:11:26,959
but you can write your patch basically

274
00:11:26,959 --> 00:11:29,680
in any language you want

275
00:11:29,680 --> 00:11:32,880
now the next step is to compile the llb

276
00:11:32,880 --> 00:11:33,519
mir

277
00:11:33,519 --> 00:11:36,640
to actual machine code and to do this

278
00:11:36,640 --> 00:11:40,079
we abuse the vmwork apis to create a

279
00:11:40,079 --> 00:11:41,760
custom compiler

280
00:11:41,760 --> 00:11:45,279
the vmwork apis are meant mainly

281
00:11:45,279 --> 00:11:48,160
to create just-in-time compilers but

282
00:11:48,160 --> 00:11:49,360
they're really flexible

283
00:11:49,360 --> 00:11:51,920
and they allow you to create your your

284
00:11:51,920 --> 00:11:53,519
own compiler by stacking

285
00:11:53,519 --> 00:11:56,079
layers and so we have a first layer

286
00:11:56,079 --> 00:11:56,959
which we call

287
00:11:56,959 --> 00:12:00,959
our isolate sections layer which

288
00:12:00,959 --> 00:12:03,360
places each function in its own separate

289
00:12:03,360 --> 00:12:05,360
section and this will be needed later

290
00:12:05,360 --> 00:12:08,880
at link stage and we'll see in a moment

291
00:12:08,880 --> 00:12:11,839
then we do some optimizations to

292
00:12:11,839 --> 00:12:13,839
increase performance and to decrease the

293
00:12:13,839 --> 00:12:15,200
size of the code that we're going to

294
00:12:15,200 --> 00:12:16,160
generate

295
00:12:16,160 --> 00:12:18,560
and then we have a compiler which takes

296
00:12:18,560 --> 00:12:19,680
the ir

297
00:12:19,680 --> 00:12:22,480
and lowers it to actual machine code

298
00:12:22,480 --> 00:12:24,639
generating an object file

299
00:12:24,639 --> 00:12:26,880
then there is a linking layer which

300
00:12:26,880 --> 00:12:28,959
takes the object file generated by the

301
00:12:28,959 --> 00:12:30,480
compiler and it forwards

302
00:12:30,480 --> 00:12:33,839
it to the level to the linker now we've

303
00:12:33,839 --> 00:12:35,040
chosen to use

304
00:12:35,040 --> 00:12:37,519
lsvmwork apis because we want to support

305
00:12:37,519 --> 00:12:38,880
cross-compilation

306
00:12:38,880 --> 00:12:42,480
and llvm or kpis are

307
00:12:42,480 --> 00:12:46,079
allow you to support cross-compilation

308
00:12:46,079 --> 00:12:49,360
really easily also they are in process

309
00:12:49,360 --> 00:12:51,519
you can use lvm as a library so you

310
00:12:51,519 --> 00:12:52,000
don't need

311
00:12:52,000 --> 00:12:54,240
to call any external binaries which is

312
00:12:54,240 --> 00:12:55,200
handy

313
00:12:55,200 --> 00:12:57,920
and lastly this is more of a personal

314
00:12:57,920 --> 00:13:00,079
reason but it provided me an opportunity

315
00:13:00,079 --> 00:13:01,600
to learn how llvm

316
00:13:01,600 --> 00:13:03,839
and jit compilers work so that's a nice

317
00:13:03,839 --> 00:13:05,680
blast

318
00:13:05,680 --> 00:13:08,639
okay after we have our object file we

319
00:13:08,639 --> 00:13:09,440
need to

320
00:13:09,440 --> 00:13:12,320
link it and to link our object file we

321
00:13:12,320 --> 00:13:14,320
need to tell our linker where the new

322
00:13:14,320 --> 00:13:16,480
functions that we are compiling

323
00:13:16,480 --> 00:13:18,720
will be loaded in memory at runtime and

324
00:13:18,720 --> 00:13:20,480
where the pre-existing functions

325
00:13:20,480 --> 00:13:24,000
can be located and now we have a bit of

326
00:13:24,000 --> 00:13:25,519
a problem because

327
00:13:25,519 --> 00:13:27,600
what is the location that we can use for

328
00:13:27,600 --> 00:13:29,839
string copy that we are using

329
00:13:29,839 --> 00:13:32,399
because if you think about it string

330
00:13:32,399 --> 00:13:33,519
copy is not a

331
00:13:33,519 --> 00:13:36,480
function proper of the program that you

332
00:13:36,480 --> 00:13:37,920
are trying to patch but that is a

333
00:13:37,920 --> 00:13:38,800
function

334
00:13:38,800 --> 00:13:42,160
of the c standard library and

335
00:13:42,160 --> 00:13:43,920
it turns out that there is an address

336
00:13:43,920 --> 00:13:45,279
that we can use for it

337
00:13:45,279 --> 00:13:48,560
in the program that we want to patch and

338
00:13:48,560 --> 00:13:51,040
that is due to how dynamic library

339
00:13:51,040 --> 00:13:52,160
function calls

340
00:13:52,160 --> 00:13:57,040
work so when a function wants to call

341
00:13:57,040 --> 00:13:59,920
a dynamic library function what it does

342
00:13:59,920 --> 00:14:00,720
is it calls

343
00:14:00,720 --> 00:14:02,800
a stub in a special section which is

344
00:14:02,800 --> 00:14:04,720
called the procedure linkage table

345
00:14:04,720 --> 00:14:08,079
now this special section is generated by

346
00:14:08,079 --> 00:14:10,240
the linker at run time together

347
00:14:10,240 --> 00:14:12,240
when it when the linker runs together

348
00:14:12,240 --> 00:14:14,079
with another section which is called the

349
00:14:14,079 --> 00:14:15,600
global offset table

350
00:14:15,600 --> 00:14:19,040
now these two sections

351
00:14:19,040 --> 00:14:22,399
are what's needed to call a dynamic

352
00:14:22,399 --> 00:14:23,440
library function

353
00:14:23,440 --> 00:14:27,519
so the procedure linkage table contains

354
00:14:27,519 --> 00:14:29,760
tabs for each and every library function

355
00:14:29,760 --> 00:14:31,519
that's needed by the

356
00:14:31,519 --> 00:14:34,639
program that we're linking so we'll find

357
00:14:34,639 --> 00:14:35,760
an entry in it

358
00:14:35,760 --> 00:14:38,079
that does the following the first

359
00:14:38,079 --> 00:14:39,680
instruction

360
00:14:39,680 --> 00:14:42,639
reads an offset inside the global offset

361
00:14:42,639 --> 00:14:43,360
table

362
00:14:43,360 --> 00:14:45,680
now this offset at the start of the

363
00:14:45,680 --> 00:14:46,800
program

364
00:14:46,800 --> 00:14:49,920
usually points to the instruction right

365
00:14:49,920 --> 00:14:51,920
next to the first instruction in the

366
00:14:51,920 --> 00:14:54,560
procedure linkage table entry

367
00:14:54,560 --> 00:14:57,120
what the second structure does is it

368
00:14:57,120 --> 00:14:59,440
pushes an identifier on the stack

369
00:14:59,440 --> 00:15:01,519
and then it jumps into the dynamic

370
00:15:01,519 --> 00:15:03,600
loader the dynamic loader is a

371
00:15:03,600 --> 00:15:07,040
special program that is loaded

372
00:15:07,040 --> 00:15:09,519
together with our original program and

373
00:15:09,519 --> 00:15:11,920
its job is to resolve to actually find

374
00:15:11,920 --> 00:15:13,519
the address of the

375
00:15:13,519 --> 00:15:15,360
library function that we want to call so

376
00:15:15,360 --> 00:15:17,279
in this case string copy

377
00:15:17,279 --> 00:15:19,760
it will also change the offset in the

378
00:15:19,760 --> 00:15:21,680
global offset table to point

379
00:15:21,680 --> 00:15:24,480
to the string copy function and then it

380
00:15:24,480 --> 00:15:26,480
will jam to string copy

381
00:15:26,480 --> 00:15:29,519
now on subsequent cause what will happen

382
00:15:29,519 --> 00:15:32,160
is that the procedural linkage table

383
00:15:32,160 --> 00:15:32,959
code will

384
00:15:32,959 --> 00:15:34,959
read the offset from the global offset

385
00:15:34,959 --> 00:15:36,959
table and now this offset

386
00:15:36,959 --> 00:15:38,880
has been patched by the dynamic loader

387
00:15:38,880 --> 00:15:41,120
two points directly through string copy

388
00:15:41,120 --> 00:15:43,839
so the execution flow of the program

389
00:15:43,839 --> 00:15:44,399
will go

390
00:15:44,399 --> 00:15:47,360
from our function to the procedure

391
00:15:47,360 --> 00:15:48,560
linkage tables tab

392
00:15:48,560 --> 00:15:50,560
to directly the string copy by passing

393
00:15:50,560 --> 00:15:53,199
the dynamic loader

394
00:15:53,199 --> 00:15:55,759
so now that we know that where we can

395
00:15:55,759 --> 00:15:56,240
find

396
00:15:56,240 --> 00:15:57,839
all the object that we need we can

397
00:15:57,839 --> 00:16:00,000
invoke the linker

398
00:16:00,000 --> 00:16:02,079
with something like this so we use

399
00:16:02,079 --> 00:16:03,040
section start

400
00:16:03,040 --> 00:16:05,519
to tell the linker where to place each

401
00:16:05,519 --> 00:16:06,160
and every

402
00:16:06,160 --> 00:16:08,320
function that we want to patch and since

403
00:16:08,320 --> 00:16:09,440
we're trying to

404
00:16:09,440 --> 00:16:12,240
build an in-place patch we tell that the

405
00:16:12,240 --> 00:16:13,920
section containing the change

406
00:16:13,920 --> 00:16:15,519
password function the new change

407
00:16:15,519 --> 00:16:18,399
password function that we are compiling

408
00:16:18,399 --> 00:16:20,560
will be at the same address of the

409
00:16:20,560 --> 00:16:22,639
change password function in the original

410
00:16:22,639 --> 00:16:24,560
binary that we want to patch

411
00:16:24,560 --> 00:16:26,480
then we have to define a couple of

412
00:16:26,480 --> 00:16:28,000
symbols for the functions

413
00:16:28,000 --> 00:16:30,480
that we used in our patch so we have to

414
00:16:30,480 --> 00:16:32,480
tell the link of where save channel

415
00:16:32,480 --> 00:16:34,959
the save the save channel function was

416
00:16:34,959 --> 00:16:38,079
and where the string copy

417
00:16:38,160 --> 00:16:40,079
function is in the procedure linkage

418
00:16:40,079 --> 00:16:42,479
table

419
00:16:43,120 --> 00:16:45,680
when we get the output from the linker

420
00:16:45,680 --> 00:16:46,639
we can then just

421
00:16:46,639 --> 00:16:49,519
look up where the new function is in the

422
00:16:49,519 --> 00:16:51,680
code for instance using objdump or

423
00:16:51,680 --> 00:16:53,040
parsing the file

424
00:16:53,040 --> 00:16:56,240
and we can basically just copy and paste

425
00:16:56,240 --> 00:16:58,160
the new code over the old one

426
00:16:58,160 --> 00:17:01,040
and we are done of course crispr does

427
00:17:01,040 --> 00:17:02,959
this all for you automatically and you

428
00:17:02,959 --> 00:17:04,720
do not have to invoke

429
00:17:04,720 --> 00:17:08,400
manually any command

430
00:17:08,400 --> 00:17:11,280
now let's go back to our example and

431
00:17:11,280 --> 00:17:13,839
instead

432
00:17:14,160 --> 00:17:16,559
try to what if you wanted to try to

433
00:17:16,559 --> 00:17:18,240
apply a more complex patch

434
00:17:18,240 --> 00:17:21,199
such as this so you can see we call

435
00:17:21,199 --> 00:17:22,000
printf

436
00:17:22,000 --> 00:17:24,079
each time change password is invoked to

437
00:17:24,079 --> 00:17:25,280
trace

438
00:17:25,280 --> 00:17:27,439
the function invocations and then we

439
00:17:27,439 --> 00:17:29,280
check if the new password

440
00:17:29,280 --> 00:17:31,360
that was supplied by the user is bigger

441
00:17:31,360 --> 00:17:32,559
than what's

442
00:17:32,559 --> 00:17:35,200
uh what should be allowed and if so we

443
00:17:35,200 --> 00:17:36,960
warned that an attack was detected

444
00:17:36,960 --> 00:17:39,520
and we sleep just for one second just to

445
00:17:39,520 --> 00:17:41,120
annoy the attackers and yeah this might

446
00:17:41,120 --> 00:17:43,120
not be the best idea but just

447
00:17:43,120 --> 00:17:45,280
stick with me for a moment and then we

448
00:17:45,280 --> 00:17:47,200
implement change password correctly

449
00:17:47,200 --> 00:17:48,559
using string copy and

450
00:17:48,559 --> 00:17:50,640
ensuring that last byte was zero just as

451
00:17:50,640 --> 00:17:52,640
before

452
00:17:52,640 --> 00:17:54,640
so there are a couple of issues with

453
00:17:54,640 --> 00:17:56,880
applying this kind of patch

454
00:17:56,880 --> 00:17:58,880
and the first issue is that we are using

455
00:17:58,880 --> 00:18:00,160
sleep so

456
00:18:00,160 --> 00:18:02,480
sleep was turns out was not actually

457
00:18:02,480 --> 00:18:04,640
imported in the original binary

458
00:18:04,640 --> 00:18:08,160
so there's no plt stub for it we have no

459
00:18:08,160 --> 00:18:09,120
address where

460
00:18:09,120 --> 00:18:12,880
we can jump to call sleep and the second

461
00:18:12,880 --> 00:18:14,480
issue maybe even bigger

462
00:18:14,480 --> 00:18:17,039
is that if we try to compile our code

463
00:18:17,039 --> 00:18:17,919
and

464
00:18:17,919 --> 00:18:20,640
we check how big the function that we

465
00:18:20,640 --> 00:18:21,360
compiled

466
00:18:21,360 --> 00:18:24,640
is we'll see that we will generate

467
00:18:24,640 --> 00:18:26,160
a function which is bigger than the

468
00:18:26,160 --> 00:18:28,720
original one so the new code won't fit

469
00:18:28,720 --> 00:18:30,559
over the old one we can just overwrite

470
00:18:30,559 --> 00:18:32,240
the existing function because we will

471
00:18:32,240 --> 00:18:35,039
also overwrite what comes after it

472
00:18:35,039 --> 00:18:38,080
and it turns out it's not enough to just

473
00:18:38,080 --> 00:18:41,120
append the new function and the new

474
00:18:41,120 --> 00:18:44,240
data at the end of the file because of

475
00:18:44,240 --> 00:18:47,840
how binaries work and so to solve these

476
00:18:47,840 --> 00:18:48,160
two

477
00:18:48,160 --> 00:18:50,799
issues we need to know a bit more about

478
00:18:50,799 --> 00:18:51,600
how

479
00:18:51,600 --> 00:18:54,640
what a binary file actually is

480
00:18:54,640 --> 00:18:56,400
and from now on we will talk

481
00:18:56,400 --> 00:18:59,520
specifically about how elf binaries

482
00:18:59,520 --> 00:19:01,919
are made but many of these concepts will

483
00:19:01,919 --> 00:19:03,919
also apply to other binary formats as

484
00:19:03,919 --> 00:19:05,200
well

485
00:19:05,200 --> 00:19:08,640
so what's an alpha anyway so alph is the

486
00:19:08,640 --> 00:19:10,000
file format for

487
00:19:10,000 --> 00:19:12,799
binaries as it's used in the linux ubsd

488
00:19:12,799 --> 00:19:14,799
and many many other platforms

489
00:19:14,799 --> 00:19:17,840
and the help files always start with a

490
00:19:17,840 --> 00:19:20,960
header which has this format

491
00:19:20,960 --> 00:19:24,320
now first of all there is some magic

492
00:19:24,320 --> 00:19:27,679
identifier if you've ever hex dumped a

493
00:19:27,679 --> 00:19:30,720
binary you a linux binary you will might

494
00:19:30,720 --> 00:19:32,320
have noticed that it will

495
00:19:32,320 --> 00:19:36,400
always start with x7f and then elf

496
00:19:36,400 --> 00:19:40,160
yes as in ascii elf then there is a type

497
00:19:40,160 --> 00:19:42,160
identifier which tells you if the elf

498
00:19:42,160 --> 00:19:44,320
you're looking at is an object file

499
00:19:44,320 --> 00:19:46,240
or if it is an executable file for

500
00:19:46,240 --> 00:19:48,400
instance uh there are many many other

501
00:19:48,400 --> 00:19:48,880
fields

502
00:19:48,880 --> 00:19:52,000
in the header for instance there is a

503
00:19:52,000 --> 00:19:54,000
the entry point address and that is the

504
00:19:54,000 --> 00:19:56,480
address where the program execution

505
00:19:56,480 --> 00:19:59,360
starts when the program is being run and

506
00:19:59,360 --> 00:20:01,200
there is also a couple of offset

507
00:20:01,200 --> 00:20:04,080
of offsets into the file which tell you

508
00:20:04,080 --> 00:20:05,679
where the program headers and the

509
00:20:05,679 --> 00:20:08,320
section headers are and what are those

510
00:20:08,320 --> 00:20:11,760
now an elf file can provide two views

511
00:20:11,760 --> 00:20:14,880
of the same program now the first view

512
00:20:14,880 --> 00:20:17,919
is provided by the sections in the

513
00:20:17,919 --> 00:20:22,000
section header table now sections are

514
00:20:22,000 --> 00:20:24,799
used by the compiler and by the linker

515
00:20:24,799 --> 00:20:26,000
and then what the

516
00:20:26,000 --> 00:20:29,039
compiler and the link are reason about

517
00:20:29,039 --> 00:20:30,720
section headers are not actually

518
00:20:30,720 --> 00:20:32,480
required for execution

519
00:20:32,480 --> 00:20:34,720
and and that's why when you run strip

520
00:20:34,720 --> 00:20:35,600
you it can

521
00:20:35,600 --> 00:20:37,440
safely strip out the section

522
00:20:37,440 --> 00:20:39,039
informations

523
00:20:39,039 --> 00:20:42,240
and the program will run just fine

524
00:20:42,240 --> 00:20:45,200
the second view is provided by program

525
00:20:45,200 --> 00:20:45,840
headers

526
00:20:45,840 --> 00:20:48,240
and those are required for execution and

527
00:20:48,240 --> 00:20:51,360
they're what the linker generates

528
00:20:51,360 --> 00:20:54,480
generated by the linker now they are

529
00:20:54,480 --> 00:20:55,039
required

530
00:20:55,039 --> 00:20:57,600
we can inspect the program headers of a

531
00:20:57,600 --> 00:20:58,799
binary using

532
00:20:58,799 --> 00:21:02,960
our trustee redel utility and

533
00:21:02,960 --> 00:21:05,600
there are many types of program headers

534
00:21:05,600 --> 00:21:07,919
but those are the main ones that we

535
00:21:07,919 --> 00:21:10,480
need for this talk now the probably the

536
00:21:10,480 --> 00:21:12,880
most important program header type

537
00:21:12,880 --> 00:21:15,360
is the load program header now load

538
00:21:15,360 --> 00:21:16,799
program headers are important because

539
00:21:16,799 --> 00:21:19,039
they describe the memory map so they

540
00:21:19,039 --> 00:21:23,200
tell what the program needs to have in

541
00:21:23,200 --> 00:21:26,400
memory in order to run

542
00:21:26,400 --> 00:21:29,039
also note that this program has two

543
00:21:29,039 --> 00:21:31,039
program headers of type interp

544
00:21:31,039 --> 00:21:33,200
and dynamic and you will find those two

545
00:21:33,200 --> 00:21:35,440
types of program headers in any

546
00:21:35,440 --> 00:21:37,600
dynamic program that is in any program

547
00:21:37,600 --> 00:21:40,159
that uses dynamic libraries

548
00:21:40,159 --> 00:21:44,080
now the first header the interp header

549
00:21:44,080 --> 00:21:46,320
specifies what's called an interpreter

550
00:21:46,320 --> 00:21:48,159
and it's also known as the dynamic

551
00:21:48,159 --> 00:21:49,280
linker

552
00:21:49,280 --> 00:21:51,760
and the second one is information needed

553
00:21:51,760 --> 00:21:54,559
by the dynamic linker to do its job

554
00:21:54,559 --> 00:21:58,000
now this is what happens when loading an

555
00:21:58,000 --> 00:22:01,280
elf dynamic elf program so

556
00:22:01,280 --> 00:22:03,760
on the kernel side the kernel reads the

557
00:22:03,760 --> 00:22:05,760
header and it finds the program headers

558
00:22:05,760 --> 00:22:07,440
from the offset written in the

559
00:22:07,440 --> 00:22:10,640
header then if there is an inter

560
00:22:10,640 --> 00:22:13,039
header it loads the interpreter which is

561
00:22:13,039 --> 00:22:14,960
just another program

562
00:22:14,960 --> 00:22:16,880
then what it does what the current does

563
00:22:16,880 --> 00:22:18,799
is it sets up the memory map of the

564
00:22:18,799 --> 00:22:19,360
program

565
00:22:19,360 --> 00:22:21,840
by following what's written in the load

566
00:22:21,840 --> 00:22:23,919
program headers

567
00:22:23,919 --> 00:22:26,720
it does a lot of other things but the

568
00:22:26,720 --> 00:22:27,679
other thing that

569
00:22:27,679 --> 00:22:30,000
concerns us that the kernel does is it

570
00:22:30,000 --> 00:22:31,440
allocates the stack

571
00:22:31,440 --> 00:22:33,440
and it fits the argument vector so that

572
00:22:33,440 --> 00:22:35,200
is the vector that contains

573
00:22:35,200 --> 00:22:37,600
the arguments passed by the on the

574
00:22:37,600 --> 00:22:38,799
command line

575
00:22:38,799 --> 00:22:40,960
and also fix the auxiliary vector and

576
00:22:40,960 --> 00:22:42,559
that's a little known vector of

577
00:22:42,559 --> 00:22:44,480
parameters that the kernel passes

578
00:22:44,480 --> 00:22:47,440
to programs that are being run and one

579
00:22:47,440 --> 00:22:48,720
of those entries we

580
00:22:48,720 --> 00:22:51,679
care about because it contains the

581
00:22:51,679 --> 00:22:53,120
address of the program

582
00:22:53,120 --> 00:22:55,679
header or the of the program headers

583
00:22:55,679 --> 00:22:57,520
then the kernel will jump into the

584
00:22:57,520 --> 00:22:59,039
dynamic loader

585
00:22:59,039 --> 00:23:01,280
so the dynamic loader remember its job

586
00:23:01,280 --> 00:23:03,600
is to load dynamic libraries and to do

587
00:23:03,600 --> 00:23:04,960
so it needs to find

588
00:23:04,960 --> 00:23:08,320
the content of the dynamic section

589
00:23:08,320 --> 00:23:10,960
to do so it finds the address of the

590
00:23:10,960 --> 00:23:13,200
program headers by reading the auxiliary

591
00:23:13,200 --> 00:23:13,760
vector

592
00:23:13,760 --> 00:23:16,320
and from there it looks for the dynamic

593
00:23:16,320 --> 00:23:17,280
program header

594
00:23:17,280 --> 00:23:19,520
now the dynamic program header points to

595
00:23:19,520 --> 00:23:21,360
the dynamics section

596
00:23:21,360 --> 00:23:22,960
and in the dynamics section there are

597
00:23:22,960 --> 00:23:25,039
many types of

598
00:23:25,039 --> 00:23:28,240
entries and so these these are the

599
00:23:28,240 --> 00:23:31,440
main ones so there are needed type of

600
00:23:31,440 --> 00:23:32,240
entries and

601
00:23:32,240 --> 00:23:34,720
what those two is they specify the name

602
00:23:34,720 --> 00:23:36,960
of some required libraries for so for

603
00:23:36,960 --> 00:23:38,159
instance our

604
00:23:38,159 --> 00:23:41,760
uh ribbons binary needed two libraries

605
00:23:41,760 --> 00:23:42,480
and that

606
00:23:42,480 --> 00:23:45,679
would be the libc.so.6 so that is the c

607
00:23:45,679 --> 00:23:46,720
standard library

608
00:23:46,720 --> 00:23:50,400
and also leave micro httpd

609
00:23:50,400 --> 00:23:53,360
then there is the string table because

610
00:23:53,360 --> 00:23:54,240
actually

611
00:23:54,240 --> 00:23:57,520
what the needed entry do is specify an

612
00:23:57,520 --> 00:23:58,000
offset

613
00:23:58,000 --> 00:24:00,640
inside a string table on this table

614
00:24:00,640 --> 00:24:01,679
contains the names

615
00:24:01,679 --> 00:24:04,080
of required function and required

616
00:24:04,080 --> 00:24:05,919
library names

617
00:24:05,919 --> 00:24:08,080
there is also a symbol table which

618
00:24:08,080 --> 00:24:09,200
describes which

619
00:24:09,200 --> 00:24:12,240
symbols and that is basically which

620
00:24:12,240 --> 00:24:14,080
functions and which variables are

621
00:24:14,080 --> 00:24:15,360
referenced by

622
00:24:15,360 --> 00:24:18,559
the program being loaded

623
00:24:18,559 --> 00:24:21,360
then there is the rela entry type and

624
00:24:21,360 --> 00:24:23,600
this points to a table describing

625
00:24:23,600 --> 00:24:25,840
basically which operations are needed

626
00:24:25,840 --> 00:24:28,480
by the linker the dynamic linker needs

627
00:24:28,480 --> 00:24:29,200
to do

628
00:24:29,200 --> 00:24:32,400
to actually write the correct offset

629
00:24:32,400 --> 00:24:34,080
inside the global offset table that

630
00:24:34,080 --> 00:24:35,440
we've seen before

631
00:24:35,440 --> 00:24:38,240
there is an entry also to get the

632
00:24:38,240 --> 00:24:40,480
address of the global offset table

633
00:24:40,480 --> 00:24:42,320
and then there are a couple of entries

634
00:24:42,320 --> 00:24:43,919
needed by

635
00:24:43,919 --> 00:24:46,480
basically performance optimizations

636
00:24:46,480 --> 00:24:48,559
which point to some hash tables which

637
00:24:48,559 --> 00:24:50,480
are needed to improve the symbol lookup

638
00:24:50,480 --> 00:24:51,600
speed

639
00:24:51,600 --> 00:24:54,240
last but not least there's also some

640
00:24:54,240 --> 00:24:54,960
entries

641
00:24:54,960 --> 00:24:57,360
uh required for to implement symbol

642
00:24:57,360 --> 00:25:00,480
versioning and that's used for

643
00:25:00,480 --> 00:25:04,559
maintaining backwards compatibility um

644
00:25:04,559 --> 00:25:07,919
in libraries that need to do it so

645
00:25:07,919 --> 00:25:10,480
to be able to link new dynamic libraries

646
00:25:10,480 --> 00:25:11,200
or import

647
00:25:11,200 --> 00:25:14,320
new symbols inside our patch binary we

648
00:25:14,320 --> 00:25:15,279
need to

649
00:25:15,279 --> 00:25:19,200
basically adjust and extend all of those

650
00:25:19,200 --> 00:25:23,520
informations and this is what we do to

651
00:25:23,520 --> 00:25:26,240
implement an out of place patch we

652
00:25:26,240 --> 00:25:27,279
basically

653
00:25:27,279 --> 00:25:29,360
patch extend and append at the end of

654
00:25:29,360 --> 00:25:31,919
the binary all of what we've previously

655
00:25:31,919 --> 00:25:32,880
said so

656
00:25:32,880 --> 00:25:36,159
we get the new code the new data and the

657
00:25:36,159 --> 00:25:38,320
new read-only data that's needed by our

658
00:25:38,320 --> 00:25:38,960
patch

659
00:25:38,960 --> 00:25:41,120
and we append it to the end of the

660
00:25:41,120 --> 00:25:42,400
binary

661
00:25:42,400 --> 00:25:45,760
then we take the original symbol and the

662
00:25:45,760 --> 00:25:47,760
original string tables and we extend

663
00:25:47,760 --> 00:25:50,240
those and we append those at the end

664
00:25:50,240 --> 00:25:52,720
we also take the original relocations

665
00:25:52,720 --> 00:25:54,400
and extend them

666
00:25:54,400 --> 00:25:56,240
with the new relocation that are needed

667
00:25:56,240 --> 00:25:57,520
to import the

668
00:25:57,520 --> 00:26:00,400
new symbols from the dynamic library

669
00:26:00,400 --> 00:26:01,840
that we're importing

670
00:26:01,840 --> 00:26:04,320
and we place them at the end as well

671
00:26:04,320 --> 00:26:06,400
same thing goes for the dynamic headers

672
00:26:06,400 --> 00:26:07,440
which we now

673
00:26:07,440 --> 00:26:10,320
need to fix to point to the new patch

674
00:26:10,320 --> 00:26:12,799
information

675
00:26:12,799 --> 00:26:15,120
we also need to patch the symbol version

676
00:26:15,120 --> 00:26:16,240
information

677
00:26:16,240 --> 00:26:18,559
and to patch to create new program

678
00:26:18,559 --> 00:26:20,640
headers and section headers which

679
00:26:20,640 --> 00:26:22,960
map and point to the new data that we

680
00:26:22,960 --> 00:26:24,400
have patched

681
00:26:24,400 --> 00:26:26,320
so the last two things that we need to

682
00:26:26,320 --> 00:26:28,480
do then is to patch the elf header

683
00:26:28,480 --> 00:26:30,880
to point the new program and section

684
00:26:30,880 --> 00:26:31,840
headers

685
00:26:31,840 --> 00:26:34,159
and lastly we have to deter the original

686
00:26:34,159 --> 00:26:36,000
function to point to the new code so

687
00:26:36,000 --> 00:26:38,320
basically we insert a jump at the start

688
00:26:38,320 --> 00:26:38,559
of

689
00:26:38,559 --> 00:26:40,960
our original function so in this case

690
00:26:40,960 --> 00:26:42,400
save channel

691
00:26:42,400 --> 00:26:44,720
to jump into the new version of save

692
00:26:44,720 --> 00:26:47,039
channel

693
00:26:47,039 --> 00:26:49,200
now i've talked enough and i think it's

694
00:26:49,200 --> 00:26:50,840
time for a demo

695
00:26:50,840 --> 00:26:54,320
so here we have the original binary

696
00:26:54,320 --> 00:26:55,120
which is called

697
00:26:55,120 --> 00:26:58,240
ribbons of course and we can run

698
00:26:58,240 --> 00:27:01,760
this binary and what i have

699
00:27:01,760 --> 00:27:04,559
on the other terminal is an exploit for

700
00:27:04,559 --> 00:27:04,960
it

701
00:27:04,960 --> 00:27:08,000
so if we run this exploit

702
00:27:08,000 --> 00:27:11,600
what it will do it will add a number of

703
00:27:11,600 --> 00:27:12,320
channels

704
00:27:12,320 --> 00:27:15,679
to the service then it will use the

705
00:27:15,679 --> 00:27:17,440
vulnerability that we have described

706
00:27:17,440 --> 00:27:19,600
earlier to leak passwords for those

707
00:27:19,600 --> 00:27:20,320
channels

708
00:27:20,320 --> 00:27:22,320
so as you can see it has found many

709
00:27:22,320 --> 00:27:24,080
passwords for the channel that is

710
00:27:24,080 --> 00:27:28,320
for the channels that it has just added

711
00:27:28,320 --> 00:27:32,880
now we have a patch ready

712
00:27:32,880 --> 00:27:35,840
for it

713
00:27:36,880 --> 00:27:38,480
which looks like this it's basically

714
00:27:38,480 --> 00:27:40,799
what i've shown earlier so what we do is

715
00:27:40,799 --> 00:27:41,360
we call

716
00:27:41,360 --> 00:27:43,520
printf each time the change password

717
00:27:43,520 --> 00:27:44,799
function is

718
00:27:44,799 --> 00:27:47,760
invoked and we also check for the new

719
00:27:47,760 --> 00:27:49,679
password size

720
00:27:49,679 --> 00:27:53,039
if it exceeds what's uh the maximola

721
00:27:53,039 --> 00:27:54,000
allowed

722
00:27:54,000 --> 00:27:56,640
it warns us that an attack was detected

723
00:27:56,640 --> 00:27:58,000
it sleeps

724
00:27:58,000 --> 00:28:00,640
and it does nothing otherwise we have

725
00:28:00,640 --> 00:28:02,080
the correct implementation of the

726
00:28:02,080 --> 00:28:04,080
function just as before

727
00:28:04,080 --> 00:28:06,960
so we already have compiled the patch to

728
00:28:06,960 --> 00:28:07,919
lvmir

729
00:28:07,919 --> 00:28:17,840
and it's here

730
00:28:20,480 --> 00:28:22,960
and so this is basically a high level

731
00:28:22,960 --> 00:28:24,720
assembly it's not really that

732
00:28:24,720 --> 00:28:27,919
interesting to read it because uh it's

733
00:28:27,919 --> 00:28:31,520
compiler generated so we won't even be

734
00:28:31,520 --> 00:28:35,679
necessary to touch it and what we can do

735
00:28:35,679 --> 00:28:39,200
now is to apply the patch by calling

736
00:28:39,200 --> 00:28:40,960
crispr and i have script ready just

737
00:28:40,960 --> 00:28:41,760
because

738
00:28:41,760 --> 00:28:45,279
the demo gods are never

739
00:28:45,279 --> 00:28:49,360
kind so i will just call this crit which

740
00:28:49,360 --> 00:28:49,679
is

741
00:28:49,679 --> 00:28:52,080
which we'll call crispr and notice that

742
00:28:52,080 --> 00:28:53,760
i am passing a

743
00:28:53,760 --> 00:28:56,240
an argument that tells it to link the

744
00:28:56,240 --> 00:28:58,000
standard library again because

745
00:28:58,000 --> 00:29:00,720
we are now using sleep which was not

746
00:29:00,720 --> 00:29:01,520
imported by

747
00:29:01,520 --> 00:29:04,960
the original binary and the patch lvm ir

748
00:29:04,960 --> 00:29:06,480
file

749
00:29:06,480 --> 00:29:08,960
so i can now apply the patch and this

750
00:29:08,960 --> 00:29:11,600
will have generated

751
00:29:11,600 --> 00:29:17,600
a patch binary called ribbons.patched

752
00:29:19,120 --> 00:29:23,120
which we can then run and

753
00:29:23,120 --> 00:29:25,600
now i can run the xsplit again and the

754
00:29:25,600 --> 00:29:26,320
exploit will

755
00:29:26,320 --> 00:29:29,039
add the channels but then it will try to

756
00:29:29,039 --> 00:29:30,000
exploit

757
00:29:30,000 --> 00:29:33,440
the program failing because

758
00:29:33,440 --> 00:29:35,279
the change password was the password

759
00:29:35,279 --> 00:29:37,279
change was refused

760
00:29:37,279 --> 00:29:40,880
now as we can see the patch program

761
00:29:40,880 --> 00:29:42,960
printed the change password was called

762
00:29:42,960 --> 00:29:45,360
and also that an attack was detected so

763
00:29:45,360 --> 00:29:54,480
our code is being executed

764
00:29:54,480 --> 00:29:57,679
now i want to end by um be

765
00:29:57,679 --> 00:29:59,520
for being forthcoming about some

766
00:29:59,520 --> 00:30:01,679
limitations that we currently have

767
00:30:01,679 --> 00:30:04,399
um so the first one is that we cannot

768
00:30:04,399 --> 00:30:06,559
call the original function because we

769
00:30:06,559 --> 00:30:06,960
are

770
00:30:06,960 --> 00:30:09,200
altering it either by overwriting it in

771
00:30:09,200 --> 00:30:11,120
case of the completely in case of

772
00:30:11,120 --> 00:30:14,240
in in place patch or because we

773
00:30:14,240 --> 00:30:17,440
are detouring it by put placing a jump

774
00:30:17,440 --> 00:30:18,480
at the start

775
00:30:18,480 --> 00:30:21,600
so for us this is not really a big issue

776
00:30:21,600 --> 00:30:22,000
because

777
00:30:22,000 --> 00:30:24,399
our aim is to be able to decompile edit

778
00:30:24,399 --> 00:30:25,679
and replace the function

779
00:30:25,679 --> 00:30:28,480
so the functionality will be preserved

780
00:30:28,480 --> 00:30:29,120
and if you

781
00:30:29,120 --> 00:30:31,279
need to for some reason invoke the

782
00:30:31,279 --> 00:30:33,120
original version of the function you can

783
00:30:33,120 --> 00:30:33,600
just

784
00:30:33,600 --> 00:30:35,520
include that together with the patch and

785
00:30:35,520 --> 00:30:37,760
call that instead

786
00:30:37,760 --> 00:30:41,919
um we also currently only support x864

787
00:30:41,919 --> 00:30:45,039
and binaries this is not

788
00:30:45,039 --> 00:30:48,640
a an inherent limitation we just need

789
00:30:48,640 --> 00:30:50,320
more time and engineering effort to

790
00:30:50,320 --> 00:30:51,440
support other

791
00:30:51,440 --> 00:30:55,200
architectures and other binary formats

792
00:30:55,200 --> 00:30:58,080
we do not support self-modifying code or

793
00:30:58,080 --> 00:31:00,080
integrity checks or

794
00:31:00,080 --> 00:31:02,559
but that's pretty natural and to be

795
00:31:02,559 --> 00:31:03,440
expected

796
00:31:03,440 --> 00:31:06,480
and a bigger problem that we have is

797
00:31:06,480 --> 00:31:09,440
for inline functions because when a

798
00:31:09,440 --> 00:31:12,399
function gets inlined

799
00:31:12,399 --> 00:31:15,279
you lose the function boundary that you

800
00:31:15,279 --> 00:31:15,600
have

801
00:31:15,600 --> 00:31:17,519
normally when calling a function which

802
00:31:17,519 --> 00:31:19,039
was not in line so

803
00:31:19,039 --> 00:31:21,600
uh being able to replace that function

804
00:31:21,600 --> 00:31:22,799
basically means

805
00:31:22,799 --> 00:31:25,519
to patch the whole function when where

806
00:31:25,519 --> 00:31:27,519
the function that you want to patch was

807
00:31:27,519 --> 00:31:28,080
inlined

808
00:31:28,080 --> 00:31:31,279
into we also have

809
00:31:31,279 --> 00:31:33,200
a lot of optimizations that we can

810
00:31:33,200 --> 00:31:34,399
implement to

811
00:31:34,399 --> 00:31:36,799
basically optimize the size of the

812
00:31:36,799 --> 00:31:39,360
binary that we produce in case of an

813
00:31:39,360 --> 00:31:42,720
outline patch but this is because we

814
00:31:42,720 --> 00:31:44,399
want to prioritize

815
00:31:44,399 --> 00:31:47,039
creating a general solution before

816
00:31:47,039 --> 00:31:48,000
optimizing so

817
00:31:48,000 --> 00:31:51,120
the what we have implemented here should

818
00:31:51,120 --> 00:31:52,320
work basically for

819
00:31:52,320 --> 00:31:57,120
any binary and it's really general

820
00:31:57,279 --> 00:32:00,320
so that was it thanks for

821
00:32:00,320 --> 00:32:02,000
your attention and i will now be

822
00:32:02,000 --> 00:32:03,840
available for a live q a

823
00:32:03,840 --> 00:32:06,320
session

824
00:32:06,960 --> 00:32:10,080
well we are back so

825
00:32:10,080 --> 00:32:13,120
thank you filipo that was something

826
00:32:13,120 --> 00:32:14,559
really amazing so

827
00:32:14,559 --> 00:32:17,840
i'm uh uh so

828
00:32:17,840 --> 00:32:20,240
this is something some field that i'm

829
00:32:20,240 --> 00:32:21,440
not really

830
00:32:21,440 --> 00:32:24,159
enrolled not really skilled on but uh it

831
00:32:24,159 --> 00:32:25,679
sounded like some

832
00:32:25,679 --> 00:32:28,080
actual game changer this tool you you

833
00:32:28,080 --> 00:32:30,080
developed right

834
00:32:30,080 --> 00:32:32,030
um so

835
00:32:32,030 --> 00:32:33,279
[Music]

836
00:32:33,279 --> 00:32:36,159
so let's go with uh with the questions

837
00:32:36,159 --> 00:32:37,200
um

838
00:32:37,200 --> 00:32:39,840
first of all we had a question that uh

839
00:32:39,840 --> 00:32:40,960
that our

840
00:32:40,960 --> 00:32:43,120
moderator deleted but i wanted to share

841
00:32:43,120 --> 00:32:45,120
with you it wasn't a question

842
00:32:45,120 --> 00:32:47,120
it was just a message from from some of

843
00:32:47,120 --> 00:32:48,320
your groupies

844
00:32:48,320 --> 00:32:52,000
so it went like uh ef cremo you are

845
00:32:52,000 --> 00:32:56,960
handsome macaroni groupie

846
00:32:56,960 --> 00:32:59,279
so you have some you know some fans are

847
00:32:59,279 --> 00:33:01,760
over there

848
00:33:02,320 --> 00:33:04,559
apart from that so let's move to the

849
00:33:04,559 --> 00:33:05,679
first question

850
00:33:05,679 --> 00:33:09,120
uh so the first question is uh uh can

851
00:33:09,120 --> 00:33:11,200
you better clarify what to

852
00:33:11,200 --> 00:33:13,039
uh what what do you mean when you say

853
00:33:13,039 --> 00:33:14,640
that with this approach

854
00:33:14,640 --> 00:33:18,320
ll vm ir approach um

855
00:33:18,320 --> 00:33:21,519
allows you to work in process and no

856
00:33:21,519 --> 00:33:24,159
need to call external binaries and that

857
00:33:24,159 --> 00:33:24,799
is

858
00:33:24,799 --> 00:33:27,519
how does it compare to other known

859
00:33:27,519 --> 00:33:28,720
approaches

860
00:33:28,720 --> 00:33:32,240
um if you can name name any

861
00:33:32,240 --> 00:33:35,279
okay yeah so it's not the llvm

862
00:33:35,279 --> 00:33:38,399
using ldmir per se that allows us to

863
00:33:38,399 --> 00:33:41,440
work in process and

864
00:33:41,440 --> 00:33:45,279
it's mostly using orc as of now

865
00:33:45,279 --> 00:33:48,720
the tool is not fully

866
00:33:48,720 --> 00:33:51,919
capable to do in process because the the

867
00:33:51,919 --> 00:33:52,320
patch

868
00:33:52,320 --> 00:33:54,960
the battery is still written in python

869
00:33:54,960 --> 00:33:55,840
and because we

870
00:33:55,840 --> 00:33:59,679
are actually invoking an external linker

871
00:33:59,679 --> 00:34:02,880
but our our goal is to since our goal is

872
00:34:02,880 --> 00:34:03,919
to

873
00:34:03,919 --> 00:34:06,640
integrate this tool inside the revenge

874
00:34:06,640 --> 00:34:07,919
it would be nice to

875
00:34:07,919 --> 00:34:11,918
have something that we can

876
00:34:11,918 --> 00:34:14,079
have fully in process and not be enough

877
00:34:14,079 --> 00:34:15,760
and does not require to call external

878
00:34:15,760 --> 00:34:16,480
binaries or

879
00:34:16,480 --> 00:34:19,359
external scripts

880
00:34:19,520 --> 00:34:21,839
so i i guess that answers the the first

881
00:34:21,839 --> 00:34:23,520
question the second how does it compare

882
00:34:23,520 --> 00:34:25,359
to other known approaches

883
00:34:25,359 --> 00:34:29,040
um i i i don't know if you mean other

884
00:34:29,040 --> 00:34:30,879
approaches as in using lv

885
00:34:30,879 --> 00:34:34,800
vmir versus not using llvmir

886
00:34:34,800 --> 00:34:38,239
probably yes i i don't

887
00:34:38,239 --> 00:34:41,119
know of other tools that use lvmir but

888
00:34:41,119 --> 00:34:42,719
that's not the

889
00:34:42,719 --> 00:34:45,839
uh the focus on on patching because the

890
00:34:45,839 --> 00:34:47,679
llvmir is the

891
00:34:47,679 --> 00:34:50,560
i mean what's nice about using llvm as a

892
00:34:50,560 --> 00:34:51,359
tool as a

893
00:34:51,359 --> 00:34:54,480
toolchain is that we can

894
00:34:54,480 --> 00:34:56,159
at least in principle use any any

895
00:34:56,159 --> 00:34:58,240
language as a starting point for writing

896
00:34:58,240 --> 00:34:59,920
the patch

897
00:34:59,920 --> 00:35:02,720
with the caveats that i uh explained

898
00:35:02,720 --> 00:35:04,320
earlier that not only languages then are

899
00:35:04,320 --> 00:35:06,320
really suited for this because of their

900
00:35:06,320 --> 00:35:08,400
big runtime i don't think you're going

901
00:35:08,400 --> 00:35:10,640
to patching java something written in c

902
00:35:10,640 --> 00:35:13,280
no yeah yeah you probably don't want to

903
00:35:13,280 --> 00:35:14,240
do that

904
00:35:14,240 --> 00:35:16,800
but like would be interesting and uh at

905
00:35:16,800 --> 00:35:18,800
least possible in principle to use for

906
00:35:18,800 --> 00:35:19,760
instance uh

907
00:35:19,760 --> 00:35:22,160
objective c for which i am quite sure

908
00:35:22,160 --> 00:35:22,880
there is

909
00:35:22,880 --> 00:35:26,000
a an led my front end to patch an

910
00:35:26,000 --> 00:35:28,160
objective c a program that was written

911
00:35:28,160 --> 00:35:29,920
in object clip c so to use the same

912
00:35:29,920 --> 00:35:30,800
language that would

913
00:35:30,800 --> 00:35:33,520
use for the um for writing the original

914
00:35:33,520 --> 00:35:34,240
binary

915
00:35:34,240 --> 00:35:37,280
now that that that might be a challenge

916
00:35:37,280 --> 00:35:38,880
for instance for c plus plus there is

917
00:35:38,880 --> 00:35:39,200
the

918
00:35:39,200 --> 00:35:41,280
exceptions there are a lot of things

919
00:35:41,280 --> 00:35:43,520
that are hard to

920
00:35:43,520 --> 00:35:47,680
to handle but our goal is definitely to

921
00:35:47,680 --> 00:35:50,220
support some of these scenarios um

922
00:35:50,220 --> 00:35:51,839
[Music]

923
00:35:51,839 --> 00:35:53,599
if the other the other interpretation of

924
00:35:53,599 --> 00:35:55,040
the second question was how does it

925
00:35:55,040 --> 00:35:57,440
compare to other known approaches as

926
00:35:57,440 --> 00:35:59,119
other other tools that allow you to do

927
00:35:59,119 --> 00:36:01,440
this i'm not really aware of any

928
00:36:01,440 --> 00:36:05,140
um tool that allows you to do this

929
00:36:05,140 --> 00:36:07,119
[Music]

930
00:36:07,119 --> 00:36:09,920
either even in place i'm not aware of

931
00:36:09,920 --> 00:36:10,320
any

932
00:36:10,320 --> 00:36:12,320
open source widely used tool that allows

933
00:36:12,320 --> 00:36:13,760
to patch binaries in place but that's

934
00:36:13,760 --> 00:36:15,280
kind of uh

935
00:36:15,280 --> 00:36:17,200
you know the thing that you do manually

936
00:36:17,200 --> 00:36:18,320
uh by assembly

937
00:36:18,320 --> 00:36:19,680
assembling something that putting

938
00:36:19,680 --> 00:36:21,760
putting it in place uh the the cool

939
00:36:21,760 --> 00:36:22,800
thing that we've done

940
00:36:22,800 --> 00:36:24,880
and not that i have invented any of this

941
00:36:24,880 --> 00:36:27,200
because there are many

942
00:36:27,200 --> 00:36:29,760
at least answers on stack overflow where

943
00:36:29,760 --> 00:36:31,760
someone described the general idea and

944
00:36:31,760 --> 00:36:32,160
how

945
00:36:32,160 --> 00:36:33,680
you can do this but calling external

946
00:36:33,680 --> 00:36:35,200
libraries

947
00:36:35,200 --> 00:36:38,240
new functions that's the real pain to

948
00:36:38,240 --> 00:36:41,359
to get it working that's what i've spent

949
00:36:41,359 --> 00:36:44,079
most of the time getting into working so

950
00:36:44,079 --> 00:36:46,320
i'm not aware of any

951
00:36:46,320 --> 00:36:48,800
tool that allows you to do that never

952
00:36:48,800 --> 00:36:51,599
seen any of it

953
00:36:53,440 --> 00:36:56,560
okay thank you um another

954
00:36:56,560 --> 00:36:58,320
another question is that did you use the

955
00:36:58,320 --> 00:37:00,560
two to do massive patching during ctfs

956
00:37:00,560 --> 00:37:02,960
so probably it refers to the to the fact

957
00:37:02,960 --> 00:37:03,599
that you are

958
00:37:03,599 --> 00:37:06,720
ctf and

959
00:37:06,720 --> 00:37:09,760
did you find uh and and then uh

960
00:37:09,760 --> 00:37:12,320
if yes the last something about that and

961
00:37:12,320 --> 00:37:13,280
then uh

962
00:37:13,280 --> 00:37:15,920
any other real world scenario where you

963
00:37:15,920 --> 00:37:17,839
successfully used it so you mentioned

964
00:37:17,839 --> 00:37:19,440
some of them uh like

965
00:37:19,440 --> 00:37:22,640
we're like patching uh

966
00:37:22,640 --> 00:37:25,359
of binaries so for vulnerability

967
00:37:25,359 --> 00:37:26,800
remediation or

968
00:37:26,800 --> 00:37:30,880
or mitigation or and and

969
00:37:30,880 --> 00:37:34,800
backdooring other binaries or

970
00:37:34,800 --> 00:37:38,480
or drm so you if i if i can recall

971
00:37:38,480 --> 00:37:42,160
um no for us for um

972
00:37:42,160 --> 00:37:45,440
no i mean not yet at least um

973
00:37:45,440 --> 00:37:48,480
so no satisfying answer but

974
00:37:48,480 --> 00:37:50,320
okay and what about the first question

975
00:37:50,320 --> 00:37:51,680
related to ctfs

976
00:37:51,680 --> 00:37:54,400
yeah no i mean i did not use the tool uh

977
00:37:54,400 --> 00:37:55,359
no

978
00:37:55,359 --> 00:37:57,920
worse scenario yet uh because it has

979
00:37:57,920 --> 00:37:59,520
been i actually promised my teammates

980
00:37:59,520 --> 00:38:00,000
that

981
00:38:00,000 --> 00:38:02,240
the tool would have been ready uh a lot

982
00:38:02,240 --> 00:38:03,200
of time ago but

983
00:38:03,200 --> 00:38:06,480
uh you know how does things go

984
00:38:06,480 --> 00:38:08,320
so no not yet i'm quite convinced that

985
00:38:08,320 --> 00:38:09,599
this tool can be used

986
00:38:09,599 --> 00:38:12,160
in ctf scenarios and also in real-world

987
00:38:12,160 --> 00:38:13,200
scenarios to

988
00:38:13,200 --> 00:38:16,320
to passionate binaries though

989
00:38:16,320 --> 00:38:20,480
okay cool uh third and last question

990
00:38:20,480 --> 00:38:23,599
um so from andrea uh

991
00:38:23,599 --> 00:38:25,839
ciao philippo nice work thanks i was

992
00:38:25,839 --> 00:38:27,440
wondering if you tested the tool by

993
00:38:27,440 --> 00:38:29,520
verifying that the functionality of the

994
00:38:29,520 --> 00:38:30,000
patch

995
00:38:30,000 --> 00:38:32,720
program is preserved did you find any

996
00:38:32,720 --> 00:38:34,640
case where the patching broke the

997
00:38:34,640 --> 00:38:35,359
program

998
00:38:35,359 --> 00:38:39,440
i think so uh so there are definitely

999
00:38:39,440 --> 00:38:42,800
programs that will break when using this

1000
00:38:42,800 --> 00:38:47,200
this tool but we we have not done

1001
00:38:47,200 --> 00:38:48,720
extensive testing yet

1002
00:38:48,720 --> 00:38:51,680
uh the the the approach as i said is

1003
00:38:51,680 --> 00:38:53,839
pretty general and uh

1004
00:38:53,839 --> 00:38:56,960
there are not there are not that many

1005
00:38:56,960 --> 00:38:59,520
uh things that the binary can do that at

1006
00:38:59,520 --> 00:39:01,280
least the legit binary can do

1007
00:39:01,280 --> 00:39:05,119
to uh such that our approach does not

1008
00:39:05,119 --> 00:39:05,520
work

1009
00:39:05,520 --> 00:39:07,440
i mean one is to have a function so

1010
00:39:07,440 --> 00:39:09,119
small that even the jump

1011
00:39:09,119 --> 00:39:11,119
at the first of the at the beginning of

1012
00:39:11,119 --> 00:39:13,520
the function to jump to the patch code

1013
00:39:13,520 --> 00:39:15,680
is is a if the function is too small we

1014
00:39:15,680 --> 00:39:17,520
cannot do the even that

1015
00:39:17,520 --> 00:39:19,760
um but i know i'm not sure you can even

1016
00:39:19,760 --> 00:39:21,760
generate a function so small with a

1017
00:39:21,760 --> 00:39:23,119
compiler without using

1018
00:39:23,119 --> 00:39:25,920
line assembly or something like that and

1019
00:39:25,920 --> 00:39:27,200
the second approach is some

1020
00:39:27,200 --> 00:39:29,599
architectures actually in line

1021
00:39:29,599 --> 00:39:33,040
data inside the code uh that that's

1022
00:39:33,040 --> 00:39:35,280
that's still a problem for now if you go

1023
00:39:35,280 --> 00:39:36,320
if some

1024
00:39:36,320 --> 00:39:38,240
place some for some reason the program

1025
00:39:38,240 --> 00:39:39,520
goes to read that data back and we

1026
00:39:39,520 --> 00:39:40,400
overwritten it

1027
00:39:40,400 --> 00:39:42,800
um then that's a problem yes and we have

1028
00:39:42,800 --> 00:39:43,680
not

1029
00:39:43,680 --> 00:39:45,200
managed to do it and i anticipate that

1030
00:39:45,200 --> 00:39:46,800
that would break our

1031
00:39:46,800 --> 00:39:49,200
method

1032
00:39:50,480 --> 00:39:53,280
okay thank you very much so i didn't see

1033
00:39:53,280 --> 00:39:54,320
any other question

1034
00:39:54,320 --> 00:39:57,359
right now as uh usually as i saw for the

1035
00:39:57,359 --> 00:39:58,160
previous

1036
00:39:58,160 --> 00:40:02,160
talk i encourage the audience to

1037
00:40:02,160 --> 00:40:06,640
write to the slider chat you find in the

1038
00:40:06,640 --> 00:40:10,000
no hat.its live there is

1039
00:40:10,000 --> 00:40:12,400
a room dedicated for reach talk and uh

1040
00:40:12,400 --> 00:40:13,440
uh this is a

1041
00:40:13,440 --> 00:40:17,680
fk um so you can continue to write on

1042
00:40:17,680 --> 00:40:18,720
that and uh

1043
00:40:18,720 --> 00:40:21,599
and philippo will be updated on that uh

1044
00:40:21,599 --> 00:40:21,839
and

1045
00:40:21,839 --> 00:40:25,359
and provide your answer so

1046
00:40:25,359 --> 00:40:28,960
thank you very much philippo for so your

1047
00:40:28,960 --> 00:40:32,079
interests and for for providing such a

1048
00:40:32,079 --> 00:40:35,280
valuable work here and uh for presenting

1049
00:40:35,280 --> 00:40:36,839
it

1050
00:40:36,839 --> 00:40:39,520
uh thank you

1051
00:40:39,520 --> 00:40:42,480
enjoy the rest of the conference for the

1052
00:40:42,480 --> 00:40:43,520
audience

1053
00:40:43,520 --> 00:40:50,400
thank you

