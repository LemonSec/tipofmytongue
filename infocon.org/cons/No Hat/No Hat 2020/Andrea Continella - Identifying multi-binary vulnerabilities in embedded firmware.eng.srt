1
00:00:56,960 --> 00:00:57,600
let me

2
00:00:57,600 --> 00:01:00,719
introduce uh our next talk

3
00:01:00,719 --> 00:01:04,159
uh and our next speaker um

4
00:01:04,159 --> 00:01:07,680
his name is uh andrea continella

5
00:01:07,680 --> 00:01:10,720
uh he's a an assistant professor and

6
00:01:10,720 --> 00:01:13,119
postdoc at university of 20

7
00:01:13,119 --> 00:01:16,240
in the netherlands of course he is

8
00:01:16,240 --> 00:01:18,960
italian he comes from sicily

9
00:01:18,960 --> 00:01:22,080
previously he was a postdoc researcher

10
00:01:22,080 --> 00:01:24,720
in the computer science department at

11
00:01:24,720 --> 00:01:26,400
the uc santa barbara

12
00:01:26,400 --> 00:01:29,680
and obtain a ps phd laude

13
00:01:29,680 --> 00:01:32,079
in computer science engineering at the

14
00:01:32,079 --> 00:01:34,720
polytechnic of the milano

15
00:01:34,720 --> 00:01:38,320
so his research activity focuses on

16
00:01:38,320 --> 00:01:40,960
security system security malware

17
00:01:40,960 --> 00:01:42,640
analysis mobile iot

18
00:01:42,640 --> 00:01:45,759
security privacy uh automated

19
00:01:45,759 --> 00:01:47,200
vulnerability discovery

20
00:01:47,200 --> 00:01:50,240
as we will see in this next talk

21
00:01:50,240 --> 00:01:53,200
and large-scale measurement of security

22
00:01:53,200 --> 00:01:54,240
issues

23
00:01:54,240 --> 00:01:56,799
so he published several research papers

24
00:01:56,799 --> 00:01:58,240
academic papers and

25
00:01:58,240 --> 00:02:00,159
serves the program committees of

26
00:02:00,159 --> 00:02:02,000
well-known system security conference

27
00:02:02,000 --> 00:02:03,600
and workshops

28
00:02:03,600 --> 00:02:07,200
so he's also organizer of some cts

29
00:02:07,200 --> 00:02:10,800
uh and uh and participant to some ctfs

30
00:02:10,800 --> 00:02:13,920
uh is part of a shellfish

31
00:02:13,920 --> 00:02:17,599
team and uh and um and co-organized

32
00:02:17,599 --> 00:02:20,560
some some cts like like paul ectf and

33
00:02:20,560 --> 00:02:22,879
the ictf

34
00:02:22,879 --> 00:02:25,560
his next talk is about identifying

35
00:02:25,560 --> 00:02:27,680
multi-binary vulnerability

36
00:02:27,680 --> 00:02:30,959
embedded in firmware at scale so

37
00:02:30,959 --> 00:02:34,840
um the focus is specifically

38
00:02:34,840 --> 00:02:37,599
on embedded devices

39
00:02:37,599 --> 00:02:40,720
iot devices and basically

40
00:02:40,720 --> 00:02:43,280
low power single purpose embedded

41
00:02:43,280 --> 00:02:44,560
devices okay

42
00:02:44,560 --> 00:02:47,280
that have become ubiquitous uh we know

43
00:02:47,280 --> 00:02:48,080
of recent

44
00:02:48,080 --> 00:02:50,800
large-scale attacks for example in the

45
00:02:50,800 --> 00:02:52,319
mirai

46
00:02:52,319 --> 00:02:56,800
mirai batanet and similar buttons

47
00:02:56,800 --> 00:03:00,879
performing ddos large scale attacks

48
00:03:00,879 --> 00:03:04,400
and so with these uh

49
00:03:04,400 --> 00:03:07,360
the analysis of the malwares that have

50
00:03:07,360 --> 00:03:08,159
been uh

51
00:03:08,159 --> 00:03:10,400
that have become extremely common and

52
00:03:10,400 --> 00:03:12,400
extremely valuable in the cybercrime

53
00:03:12,400 --> 00:03:13,440
underground

54
00:03:13,440 --> 00:03:16,720
is quite complex so there are uh it's

55
00:03:16,720 --> 00:03:19,120
very hard dependent

56
00:03:19,120 --> 00:03:22,000
because it uses minimal environment with

57
00:03:22,000 --> 00:03:22,560
custom

58
00:03:22,560 --> 00:03:25,680
hardware components and moreover

59
00:03:25,680 --> 00:03:29,040
uh they often use a mod

60
00:03:29,040 --> 00:03:32,879
a model of based on multi

61
00:03:32,879 --> 00:03:36,239
multiple binaries so um

62
00:03:36,239 --> 00:03:38,720
these approach and these are tools that

63
00:03:38,720 --> 00:03:40,400
uh andrea will present

64
00:03:40,400 --> 00:03:44,000
currently that is the result of a

65
00:03:44,000 --> 00:03:47,920
very interesting research they did um

66
00:03:47,920 --> 00:03:51,680
is uh is uh uh suggesting and

67
00:03:51,680 --> 00:03:54,959
is uh implementing uh a new approach in

68
00:03:54,959 --> 00:03:55,439
the

69
00:03:55,439 --> 00:03:58,840
analysis of these multi-uh binary

70
00:03:58,840 --> 00:04:03,360
multi-binary multi-binary firmwares

71
00:04:03,360 --> 00:04:06,560
and especially applying a kind of a

72
00:04:06,560 --> 00:04:09,239
taint analysis approach on the

73
00:04:09,239 --> 00:04:11,599
multi-binary firmware

74
00:04:11,599 --> 00:04:14,799
of embedded devices so i want to add

75
00:04:14,799 --> 00:04:16,478
anything else apart that

76
00:04:16,478 --> 00:04:18,959
with this kind of approach they identify

77
00:04:18,959 --> 00:04:21,040
several zero days

78
00:04:21,040 --> 00:04:24,479
in uh in uh in several

79
00:04:24,479 --> 00:04:27,919
embedded devices and uh some of them are

80
00:04:27,919 --> 00:04:31,280
really valuable uh with a remote code

81
00:04:31,280 --> 00:04:34,320
execution and cvss

82
00:04:34,320 --> 00:04:38,400
above 9.6 and

83
00:04:38,400 --> 00:04:42,320
i will leave the stage to andrea

84
00:04:42,320 --> 00:04:45,120
in a few seconds

85
00:04:47,600 --> 00:04:50,240
hello everyone thank you for visually

86
00:04:50,240 --> 00:04:51,360
attending my talk

87
00:04:51,360 --> 00:04:53,600
i'm very happy to be part of this second

88
00:04:53,600 --> 00:04:54,400
edition of

89
00:04:54,400 --> 00:04:57,280
no heads even if unfortunately not in

90
00:04:57,280 --> 00:04:58,240
person

91
00:04:58,240 --> 00:04:59,919
my name is andre continella i'm an

92
00:04:59,919 --> 00:05:01,759
assistant professor at the university of

93
00:05:01,759 --> 00:05:03,440
tuente in the netherlands

94
00:05:03,440 --> 00:05:05,120
and today i'll talk about a research

95
00:05:05,120 --> 00:05:07,520
project on automated firmware analysis

96
00:05:07,520 --> 00:05:10,479
in collaboration with some folks at ucsb

97
00:05:10,479 --> 00:05:12,320
so first of all why do we want to

98
00:05:12,320 --> 00:05:13,600
analyze firmware

99
00:05:13,600 --> 00:05:15,440
well i'm sure you noticed that iot

100
00:05:15,440 --> 00:05:16,800
devices are nowadays

101
00:05:16,800 --> 00:05:18,639
quite popular i would say they're

102
00:05:18,639 --> 00:05:20,160
everywhere and

103
00:05:20,160 --> 00:05:22,000
there exists a very large amount of

104
00:05:22,000 --> 00:05:24,160
different devices right so we have smart

105
00:05:24,160 --> 00:05:25,039
toasters

106
00:05:25,039 --> 00:05:28,240
smart lights smart bulbs and now we also

107
00:05:28,240 --> 00:05:30,880
have a smart egg minder

108
00:05:30,880 --> 00:05:32,800
it's not clear to me what this is

109
00:05:32,800 --> 00:05:34,479
supposed to do

110
00:05:34,479 --> 00:05:36,560
but anyways the common thing is that we

111
00:05:36,560 --> 00:05:38,639
have seen all of these devices often

112
00:05:38,639 --> 00:05:40,080
being vulnerable

113
00:05:40,080 --> 00:05:42,720
and not only they contain indeed

114
00:05:42,720 --> 00:05:44,400
security vulnerabilities but we have

115
00:05:44,400 --> 00:05:45,280
seen

116
00:05:45,280 --> 00:05:47,440
such vulnerabilities being actively

117
00:05:47,440 --> 00:05:50,240
exploited by attackers in the wild

118
00:05:50,240 --> 00:05:52,320
and the most famous example is probably

119
00:05:52,320 --> 00:05:54,960
the uh mirai botnet where thousands of

120
00:05:54,960 --> 00:05:57,360
iot devices were compromised to

121
00:05:57,360 --> 00:05:59,520
perform a large distributed denial of

122
00:05:59,520 --> 00:06:01,039
service attack

123
00:06:01,039 --> 00:06:03,600
now one interesting aspect in this

124
00:06:03,600 --> 00:06:04,800
scenario is that

125
00:06:04,800 --> 00:06:06,560
often the vulnerabilities that we find

126
00:06:06,560 --> 00:06:08,880
in this device are quite all types of

127
00:06:08,880 --> 00:06:10,639
vulnerabilities or things that

128
00:06:10,639 --> 00:06:12,720
we have known for a long time and for

129
00:06:12,720 --> 00:06:14,720
which attackers do not really need

130
00:06:14,720 --> 00:06:17,919
advanced sophisticated exploitation

131
00:06:17,919 --> 00:06:18,880
techniques

132
00:06:18,880 --> 00:06:21,280
and in fact firmware often does not

133
00:06:21,280 --> 00:06:22,479
present

134
00:06:22,479 --> 00:06:24,800
many of the protection mechanism that we

135
00:06:24,800 --> 00:06:26,960
are used to in modern operating systems

136
00:06:26,960 --> 00:06:28,479
and here i'm thinking for instance at

137
00:06:28,479 --> 00:06:30,080
randomization or

138
00:06:30,080 --> 00:06:32,479
control for integrity and and so on but

139
00:06:32,479 --> 00:06:33,360
at the same time

140
00:06:33,360 --> 00:06:35,680
firmware presents some significant

141
00:06:35,680 --> 00:06:37,520
differences when compared to for

142
00:06:37,520 --> 00:06:39,360
instance desktop applications

143
00:06:39,360 --> 00:06:42,400
that make traditional security analysis

144
00:06:42,400 --> 00:06:45,520
hard to apply and the main reasons are

145
00:06:45,520 --> 00:06:47,440
first of all that

146
00:06:47,440 --> 00:06:49,440
firmware is heavily hardware dependent

147
00:06:49,440 --> 00:06:51,199
so it relies on

148
00:06:51,199 --> 00:06:53,680
many peripherals just think about a

149
00:06:53,680 --> 00:06:55,440
smart camera where the firmware is

150
00:06:55,440 --> 00:06:57,039
programmed to directly talk to the

151
00:06:57,039 --> 00:06:58,479
camera sensor

152
00:06:58,479 --> 00:07:01,199
to retrieve images but also fema lives

153
00:07:01,199 --> 00:07:02,720
in unique

154
00:07:02,720 --> 00:07:06,000
minimal and execution environments with

155
00:07:06,000 --> 00:07:07,759
non-standard configurations

156
00:07:07,759 --> 00:07:09,840
so for instance a shared memory are

157
00:07:09,840 --> 00:07:11,840
coded addresses but also custom

158
00:07:11,840 --> 00:07:12,960
interrupt enders that

159
00:07:12,960 --> 00:07:14,800
can be implemented within the firmware

160
00:07:14,800 --> 00:07:17,440
image and on top of this of course

161
00:07:17,440 --> 00:07:18,880
there are several architectures

162
00:07:18,880 --> 00:07:21,039
sometimes also property ones

163
00:07:21,039 --> 00:07:23,680
these things makes these things make

164
00:07:23,680 --> 00:07:24,240
things

165
00:07:24,240 --> 00:07:27,199
a little bit tricky to uh to implement

166
00:07:27,199 --> 00:07:27,840
so

167
00:07:27,840 --> 00:07:30,720
if you want to analyze a firmware image

168
00:07:30,720 --> 00:07:32,560
what we can do first of all we can try

169
00:07:32,560 --> 00:07:34,319
with dynamic analysis right so imagine

170
00:07:34,319 --> 00:07:35,120
that we can

171
00:07:35,120 --> 00:07:37,599
emulate our firmware image and we can

172
00:07:37,599 --> 00:07:38,479
run our

173
00:07:38,479 --> 00:07:40,960
uh coverage guided fuzzer well

174
00:07:40,960 --> 00:07:42,160
unfortunately

175
00:07:42,160 --> 00:07:44,800
this is not very generic and reliable at

176
00:07:44,800 --> 00:07:45,759
this time

177
00:07:45,759 --> 00:07:47,840
uh there have been recently some very

178
00:07:47,840 --> 00:07:50,000
promising walks in this direction

179
00:07:50,000 --> 00:07:52,080
but we're simply not there yet and the

180
00:07:52,080 --> 00:07:53,039
reasons uh

181
00:07:53,039 --> 00:07:55,840
uh are again that mostly because uh

182
00:07:55,840 --> 00:07:56,560
femur is

183
00:07:56,560 --> 00:07:59,120
uh heavily auto dependent so properly

184
00:07:59,120 --> 00:08:00,720
modeling and implementing

185
00:08:00,720 --> 00:08:02,479
uh dynamic analysis environment for

186
00:08:02,479 --> 00:08:04,000
firmware is

187
00:08:04,000 --> 00:08:06,080
challenging this because this

188
00:08:06,080 --> 00:08:07,520
environment has to model

189
00:08:07,520 --> 00:08:10,720
and implement peripherals dmas

190
00:08:10,720 --> 00:08:12,560
interrupt enders and so on so all these

191
00:08:12,560 --> 00:08:13,919
things are quite tricky to

192
00:08:13,919 --> 00:08:16,400
to deal with the alternative of course

193
00:08:16,400 --> 00:08:18,400
is that we could instead use static

194
00:08:18,400 --> 00:08:19,360
analysis

195
00:08:19,360 --> 00:08:21,520
which does not suffer from many of these

196
00:08:21,520 --> 00:08:22,720
limitations

197
00:08:22,720 --> 00:08:24,479
but here the problem is that current

198
00:08:24,479 --> 00:08:26,879
approaches do not scale and

199
00:08:26,879 --> 00:08:29,520
generate too many false positives and

200
00:08:29,520 --> 00:08:30,800
the reason for these

201
00:08:30,800 --> 00:08:33,839
that we found in our research is that

202
00:08:33,839 --> 00:08:36,958
femur is mostly a multi-binary in fact

203
00:08:36,958 --> 00:08:38,958
the vast majority of female images are

204
00:08:38,958 --> 00:08:40,080
linux based

205
00:08:40,080 --> 00:08:42,640
and in practice they consist in a squash

206
00:08:42,640 --> 00:08:43,519
file system

207
00:08:43,519 --> 00:08:46,080
that contains hundreds of executable

208
00:08:46,080 --> 00:08:46,959
binaries

209
00:08:46,959 --> 00:08:48,720
you can see an example here of a

210
00:08:48,720 --> 00:08:50,760
firmware image that contains

211
00:08:50,760 --> 00:08:54,160
240 binary programs but on a larger

212
00:08:54,160 --> 00:08:54,880
scale

213
00:08:54,880 --> 00:08:58,000
we found that on average a female sample

214
00:08:58,000 --> 00:09:01,519
contains more than 150

215
00:09:01,519 --> 00:09:04,720
executable binaries of course not all

216
00:09:04,720 --> 00:09:05,680
these binaries

217
00:09:05,680 --> 00:09:08,000
are indeed used and needed to implement

218
00:09:08,000 --> 00:09:09,440
the firm's functionality

219
00:09:09,440 --> 00:09:11,519
but some of them do and the tp

220
00:09:11,519 --> 00:09:13,200
architecture of a

221
00:09:13,200 --> 00:09:16,640
an embedded system consists in a

222
00:09:16,640 --> 00:09:19,040
binary in a program usually a web server

223
00:09:19,040 --> 00:09:20,080
that receives

224
00:09:20,080 --> 00:09:22,320
requests and forwards the request to one

225
00:09:22,320 --> 00:09:23,519
handle binary

226
00:09:23,519 --> 00:09:25,360
the under binary processes the request

227
00:09:25,360 --> 00:09:26,640
and then return

228
00:09:26,640 --> 00:09:29,440
returns a result in practice this is a

229
00:09:29,440 --> 00:09:30,720
little bit more complex

230
00:09:30,720 --> 00:09:32,480
because we can have multiple enter

231
00:09:32,480 --> 00:09:34,800
binaries and these binaries can

232
00:09:34,800 --> 00:09:36,560
further interact with with other

233
00:09:36,560 --> 00:09:38,720
programs so at this point the question

234
00:09:38,720 --> 00:09:39,440
becomes

235
00:09:39,440 --> 00:09:41,760
which binary we want to analyze because

236
00:09:41,760 --> 00:09:44,320
clearly on the one hand if we only

237
00:09:44,320 --> 00:09:47,279
select a random number of binaries uh or

238
00:09:47,279 --> 00:09:49,040
we only focus horizontally on the web

239
00:09:49,040 --> 00:09:49,760
server

240
00:09:49,760 --> 00:09:52,000
we might miss a large amount of

241
00:09:52,000 --> 00:09:53,120
vulnerability so

242
00:09:53,120 --> 00:09:55,440
we might have many false negatives but

243
00:09:55,440 --> 00:09:57,200
on the other hand if we analyze all

244
00:09:57,200 --> 00:09:58,959
these binaries individually

245
00:09:58,959 --> 00:10:00,880
then we will have a large amount of

246
00:10:00,880 --> 00:10:02,720
force positives

247
00:10:02,720 --> 00:10:05,760
and uh so you can see an example here

248
00:10:05,760 --> 00:10:07,760
uh this is from a real world firmware

249
00:10:07,760 --> 00:10:09,200
image where we have

250
00:10:09,200 --> 00:10:11,920
a the corresponding source code of a

251
00:10:11,920 --> 00:10:13,600
binary program on the right

252
00:10:13,600 --> 00:10:16,399
and this program uh receives uh and

253
00:10:16,399 --> 00:10:17,120
reads

254
00:10:17,120 --> 00:10:19,519
data from two environment variables if

255
00:10:19,519 --> 00:10:21,519
you assume that this is the input of the

256
00:10:21,519 --> 00:10:22,720
program and

257
00:10:22,720 --> 00:10:24,800
this is attacker control then this

258
00:10:24,800 --> 00:10:27,040
program contains two vulnerabilities

259
00:10:27,040 --> 00:10:27,839
because

260
00:10:27,839 --> 00:10:31,519
this data this input is used in two

261
00:10:31,519 --> 00:10:34,399
unsafe string copy uh uh that do not

262
00:10:34,399 --> 00:10:36,240
check without any check on the uh

263
00:10:36,240 --> 00:10:38,160
size of the next destination buffer so

264
00:10:38,160 --> 00:10:40,000
these are two buffer overflows

265
00:10:40,000 --> 00:10:44,160
easy uh two buttons in reality when we

266
00:10:44,160 --> 00:10:46,640
when in this specific firmware image

267
00:10:46,640 --> 00:10:48,000
this program on the right

268
00:10:48,000 --> 00:10:50,800
is only executed through this other

269
00:10:50,800 --> 00:10:52,000
program on the left

270
00:10:52,000 --> 00:10:53,680
and you can see here that this other

271
00:10:53,680 --> 00:10:55,680
program sets the values of these two

272
00:10:55,680 --> 00:10:57,760
environment variables and then execute

273
00:10:57,760 --> 00:10:59,200
the program on the right

274
00:10:59,200 --> 00:11:02,399
so now if we look at the big picture

275
00:11:02,399 --> 00:11:04,240
and we consider the interaction between

276
00:11:04,240 --> 00:11:05,440
these two binaries

277
00:11:05,440 --> 00:11:08,480
in this case we only have one bug

278
00:11:08,480 --> 00:11:12,399
in fact while the value of the quiz

279
00:11:12,399 --> 00:11:13,839
string

280
00:11:13,839 --> 00:11:17,760
can potentially be longer than 128 bytes

281
00:11:17,760 --> 00:11:18,320
so

282
00:11:18,320 --> 00:11:20,640
longer than the size of the destination

283
00:11:20,640 --> 00:11:21,519
buffer

284
00:11:21,519 --> 00:11:24,399
the log path variable is a coded and

285
00:11:24,399 --> 00:11:26,640
constrained to a string that is shorter

286
00:11:26,640 --> 00:11:27,200
than the

287
00:11:27,200 --> 00:11:29,519
destination buffer side so in this case

288
00:11:29,519 --> 00:11:30,880
not generating

289
00:11:30,880 --> 00:11:33,839
any uh buffer overflow and this is a

290
00:11:33,839 --> 00:11:36,399
again a quick example but

291
00:11:36,399 --> 00:11:39,600
of a false positive that occurs when we

292
00:11:39,600 --> 00:11:41,600
look at binaries individually

293
00:11:41,600 --> 00:11:43,440
but you can imagine how the number of

294
00:11:43,440 --> 00:11:45,279
false positives can quickly increase

295
00:11:45,279 --> 00:11:48,240
if we look at many binaries and we want

296
00:11:48,240 --> 00:11:49,839
to analyze many firmware

297
00:11:49,839 --> 00:11:53,440
images at scale so during our research

298
00:11:53,440 --> 00:11:55,600
we started from the observation that

299
00:11:55,600 --> 00:11:58,160
firmware is mostly composed of

300
00:11:58,160 --> 00:12:01,519
by multiple interacting binaries

301
00:12:01,519 --> 00:12:04,800
and we found out that modeling the

302
00:12:04,800 --> 00:12:06,399
interactions between these binaries

303
00:12:06,399 --> 00:12:09,040
is essential for an effective analysis

304
00:12:09,040 --> 00:12:11,279
we can model those interactions because

305
00:12:11,279 --> 00:12:14,000
programs and processes communicate

306
00:12:14,000 --> 00:12:14,399
through

307
00:12:14,399 --> 00:12:17,760
a finite set of channels a finite set of

308
00:12:17,760 --> 00:12:19,600
inter-process communication

309
00:12:19,600 --> 00:12:23,120
paradigms and

310
00:12:23,120 --> 00:12:25,360
we the modeling these these interactions

311
00:12:25,360 --> 00:12:26,320
we can actually

312
00:12:26,320 --> 00:12:28,639
we introduce uh static analysis

313
00:12:28,639 --> 00:12:30,720
techniques to perform multi-binary uh

314
00:12:30,720 --> 00:12:31,920
taint analysis

315
00:12:31,920 --> 00:12:33,839
so multiply intent analysis where the

316
00:12:33,839 --> 00:12:35,040
constraints

317
00:12:35,040 --> 00:12:36,880
of our tenth analysis are not only

318
00:12:36,880 --> 00:12:38,480
propagated within

319
00:12:38,480 --> 00:12:40,399
one single binaries but they are also

320
00:12:40,399 --> 00:12:43,519
propagated from one binary to another

321
00:12:43,519 --> 00:12:45,760
on top of this approach we built a

322
00:12:45,760 --> 00:12:47,360
prototype current

323
00:12:47,360 --> 00:12:49,200
and i'll show you in this presentation

324
00:12:49,200 --> 00:12:51,279
that current can

325
00:12:51,279 --> 00:12:53,519
discover unknown bugs but at the same

326
00:12:53,519 --> 00:12:55,440
time it can drastically

327
00:12:55,440 --> 00:12:58,560
reduce the number of false positives

328
00:12:58,560 --> 00:13:00,880
so if in a nutshell if you want to

329
00:13:00,880 --> 00:13:02,880
quickly summarize what currant

330
00:13:02,880 --> 00:13:06,880
does it takes as input a firmware image

331
00:13:06,880 --> 00:13:09,440
it unpacks the firmware image extracting

332
00:13:09,440 --> 00:13:10,399
all the

333
00:13:10,399 --> 00:13:12,560
existing binary programs and then it

334
00:13:12,560 --> 00:13:15,600
attacks it detects what we called a

335
00:13:15,600 --> 00:13:17,440
the border binaries so these are the

336
00:13:17,440 --> 00:13:18,880
binaries that accept

337
00:13:18,880 --> 00:13:21,519
user input from from the outside world

338
00:13:21,519 --> 00:13:23,360
once we have these border binaries

339
00:13:23,360 --> 00:13:25,920
current tracks the interaction with

340
00:13:25,920 --> 00:13:27,279
additional programs

341
00:13:27,279 --> 00:13:29,200
you can see here an example two programs

342
00:13:29,200 --> 00:13:31,040
that share data through one environment

343
00:13:31,040 --> 00:13:31,839
variable

344
00:13:31,839 --> 00:13:34,399
and what happens in practice is that

345
00:13:34,399 --> 00:13:35,519
these two programs

346
00:13:35,519 --> 00:13:37,600
know that the name of the environment

347
00:13:37,600 --> 00:13:38,880
variable that we call the

348
00:13:38,880 --> 00:13:40,800
data key of the communication in this

349
00:13:40,800 --> 00:13:42,320
case the string

350
00:13:42,320 --> 00:13:45,680
value and uh by knowing this data key

351
00:13:45,680 --> 00:13:46,959
they can actually

352
00:13:46,959 --> 00:13:49,440
share data and of course all of these

353
00:13:49,440 --> 00:13:50,160
binaries

354
00:13:50,160 --> 00:13:52,800
all these programs can then interact and

355
00:13:52,800 --> 00:13:55,519
communicate with additional programs

356
00:13:55,519 --> 00:13:58,800
now uh caronte has what we call a

357
00:13:58,800 --> 00:14:00,720
binary dependency graph so this graph

358
00:14:00,720 --> 00:14:02,079
that connects

359
00:14:02,079 --> 00:14:05,120
all the programs that communicate and

360
00:14:05,120 --> 00:14:07,839
we can run our multi-binary tenth

361
00:14:07,839 --> 00:14:08,959
analysis so we

362
00:14:08,959 --> 00:14:11,680
we start collecting constraints on the

363
00:14:11,680 --> 00:14:12,959
tainted data

364
00:14:12,959 --> 00:14:14,880
and in this case in this example we can

365
00:14:14,880 --> 00:14:17,199
see that these programs share data that

366
00:14:17,199 --> 00:14:20,240
is supposed to be up to 512 bytes

367
00:14:20,240 --> 00:14:22,560
but when this data reaches the very last

368
00:14:22,560 --> 00:14:23,600
binary

369
00:14:23,600 --> 00:14:26,880
of this chain it is copied into a buffer

370
00:14:26,880 --> 00:14:27,760
that is only

371
00:14:27,760 --> 00:14:31,839
500 bytes so in this case leading to a

372
00:14:31,839 --> 00:14:34,480
buffer overflow so now things are

373
00:14:34,480 --> 00:14:35,040
probably

374
00:14:35,040 --> 00:14:37,519
not super clear so let's have a look a

375
00:14:37,519 --> 00:14:39,519
closer look at the different steps that

376
00:14:39,519 --> 00:14:40,320
current

377
00:14:40,320 --> 00:14:43,440
performs so the first step as we said

378
00:14:43,440 --> 00:14:45,040
is unpacking the firmware image so we

379
00:14:45,040 --> 00:14:46,639
use bin work

380
00:14:46,639 --> 00:14:50,000
to unpack the firmware images and once

381
00:14:50,000 --> 00:14:50,800
we have

382
00:14:50,800 --> 00:14:54,560
extracted all the uh binary programs we

383
00:14:54,560 --> 00:14:55,920
want to automatically

384
00:14:55,920 --> 00:14:58,560
identify the border binaries so those

385
00:14:58,560 --> 00:14:59,760
programs that

386
00:14:59,760 --> 00:15:02,959
accept user input the intuition here

387
00:15:02,959 --> 00:15:05,440
to do so is that these programs will

388
00:15:05,440 --> 00:15:08,240
need to parse user data so they need

389
00:15:08,240 --> 00:15:11,040
parsers and there exists in the instead

390
00:15:11,040 --> 00:15:12,399
of the art techniques

391
00:15:12,399 --> 00:15:15,360
that allow to identify parsers in binary

392
00:15:15,360 --> 00:15:16,079
programs

393
00:15:16,079 --> 00:15:18,240
we extended these techniques by

394
00:15:18,240 --> 00:15:19,120
specifically

395
00:15:19,120 --> 00:15:22,160
focusing on network parsers and so uh

396
00:15:22,160 --> 00:15:24,320
what we do to identify this binary is

397
00:15:24,320 --> 00:15:26,000
that for each function in all

398
00:15:26,000 --> 00:15:27,680
of the binaries containing a firmware

399
00:15:27,680 --> 00:15:30,240
image we compute a set of features we

400
00:15:30,240 --> 00:15:32,079
compute the number of basic blocks

401
00:15:32,079 --> 00:15:34,160
the number of memory comparisons uh the

402
00:15:34,160 --> 00:15:35,680
number of branches

403
00:15:35,680 --> 00:15:38,000
the number of net related keywords and

404
00:15:38,000 --> 00:15:39,600
also we check whether there is any data

405
00:15:39,600 --> 00:15:40,480
flow between

406
00:15:40,480 --> 00:15:42,639
a receive function and a memory

407
00:15:42,639 --> 00:15:44,079
comparison

408
00:15:44,079 --> 00:15:46,399
all these features produce numerical

409
00:15:46,399 --> 00:15:47,120
values

410
00:15:47,120 --> 00:15:49,920
that we sum up together using this

411
00:15:49,920 --> 00:15:50,720
formula

412
00:15:50,720 --> 00:15:53,360
with some constants and weights but what

413
00:15:53,360 --> 00:15:54,000
happens here

414
00:15:54,000 --> 00:15:57,519
is that for each function we get a score

415
00:15:57,519 --> 00:16:00,880
and then we select as the score of each

416
00:16:00,880 --> 00:16:02,639
binary the highest score

417
00:16:02,639 --> 00:16:06,240
of its functions so now we have for each

418
00:16:06,240 --> 00:16:09,120
binary a parsing score and we want to

419
00:16:09,120 --> 00:16:09,680
identify

420
00:16:09,680 --> 00:16:12,320
border binaries so we use machine

421
00:16:12,320 --> 00:16:14,320
learning specifically

422
00:16:14,320 --> 00:16:17,920
clustering to identify those binaries

423
00:16:17,920 --> 00:16:19,199
if you're not familiar with machine

424
00:16:19,199 --> 00:16:21,360
learning imagine that given the

425
00:16:21,360 --> 00:16:22,000
distribution

426
00:16:22,000 --> 00:16:24,000
of the different party score we

427
00:16:24,000 --> 00:16:25,680
automatically

428
00:16:25,680 --> 00:16:27,680
select the group of binaries that

429
00:16:27,680 --> 00:16:30,240
present a significantly higher

430
00:16:30,240 --> 00:16:33,600
score than all the other binaries

431
00:16:33,600 --> 00:16:36,320
cool now we have our border binaries and

432
00:16:36,320 --> 00:16:38,079
the next step is that we want to

433
00:16:38,079 --> 00:16:40,000
identify interactions with other

434
00:16:40,000 --> 00:16:41,920
binaries so that we can build our binary

435
00:16:41,920 --> 00:16:43,360
dependency graph

436
00:16:43,360 --> 00:16:46,399
to do so we use a static tent engine

437
00:16:46,399 --> 00:16:50,000
and we start by tainting a data compare

438
00:16:50,000 --> 00:16:52,320
against the net related keywords the

439
00:16:52,320 --> 00:16:53,680
assumption here is that

440
00:16:53,680 --> 00:16:56,880
this is the input of the of our firmware

441
00:16:56,880 --> 00:17:00,560
and we also manually created a list of

442
00:17:00,560 --> 00:17:02,639
network keywords that we use for this

443
00:17:02,639 --> 00:17:03,600
step

444
00:17:03,600 --> 00:17:06,799
then we start the data exploration and

445
00:17:06,799 --> 00:17:09,599
we rely on some modules that we call

446
00:17:09,599 --> 00:17:11,520
cpfs

447
00:17:11,520 --> 00:17:13,679
communication paradigm finders that

448
00:17:13,679 --> 00:17:15,679
reason about the different inter-process

449
00:17:15,679 --> 00:17:17,039
communication paradigms

450
00:17:17,039 --> 00:17:18,559
so for instance we have a specific

451
00:17:18,559 --> 00:17:20,480
module for identifying

452
00:17:20,480 --> 00:17:22,160
socket-based communication another

453
00:17:22,160 --> 00:17:23,599
module for identifying

454
00:17:23,599 --> 00:17:26,640
file based communication and so on and

455
00:17:26,640 --> 00:17:28,480
so whenever

456
00:17:28,480 --> 00:17:31,120
a for each basic block that we analyzed

457
00:17:31,120 --> 00:17:32,960
during our 10th exploration

458
00:17:32,960 --> 00:17:36,000
these cpf modules identify whether there

459
00:17:36,000 --> 00:17:37,760
is any data being shared

460
00:17:37,760 --> 00:17:41,120
and if it is so they perform three tasks

461
00:17:41,120 --> 00:17:43,760
they first of all recover the data key

462
00:17:43,760 --> 00:17:45,600
of the communication

463
00:17:45,600 --> 00:17:47,760
then the second step is to determine the

464
00:17:47,760 --> 00:17:49,200
flow direction so whether the binary

465
00:17:49,200 --> 00:17:50,880
that we are analyzing is actually

466
00:17:50,880 --> 00:17:52,559
sending or receiving

467
00:17:52,559 --> 00:17:55,520
data and finally in the case the binary

468
00:17:55,520 --> 00:17:57,520
is sending data we want to find

469
00:17:57,520 --> 00:17:59,600
all the other binaries in our firmware

470
00:17:59,600 --> 00:18:00,640
image that

471
00:18:00,640 --> 00:18:04,080
using the same data key receive data

472
00:18:04,080 --> 00:18:07,840
so we can see this again in an example

473
00:18:07,840 --> 00:18:12,960
so here we have a comparison

474
00:18:12,960 --> 00:18:15,440
against network related keywords so in

475
00:18:15,440 --> 00:18:17,760
this case the swing shop is our keyword

476
00:18:17,760 --> 00:18:20,480
and so in this case we consider p the

477
00:18:20,480 --> 00:18:21,360
buffer p

478
00:18:21,360 --> 00:18:24,720
uh as our input so p is tainted and what

479
00:18:24,720 --> 00:18:26,320
happens is that this buffer is then

480
00:18:26,320 --> 00:18:28,720
returned by the parse uri function

481
00:18:28,720 --> 00:18:32,000
and so also the buffer data

482
00:18:32,000 --> 00:18:35,200
is tainted now and this buffer is later

483
00:18:35,200 --> 00:18:38,960
used in a set amp so here our

484
00:18:38,960 --> 00:18:41,600
cpf identifies that there is some data

485
00:18:41,600 --> 00:18:42,559
being shared

486
00:18:42,559 --> 00:18:45,679
it extracts the data key so that the the

487
00:18:45,679 --> 00:18:47,120
query string value

488
00:18:47,120 --> 00:18:49,360
and it looks for other binaries that

489
00:18:49,360 --> 00:18:51,679
receive data using the same data key

490
00:18:51,679 --> 00:18:53,919
and we can see here on the right the

491
00:18:53,919 --> 00:18:55,840
receiving binary that are using the

492
00:18:55,840 --> 00:18:56,880
saying that the key

493
00:18:56,880 --> 00:19:00,640
query string receives data from from the

494
00:19:00,640 --> 00:19:02,799
environment variable

495
00:19:02,799 --> 00:19:04,320
whenever this happens so whenever we

496
00:19:04,320 --> 00:19:06,640
find these communications

497
00:19:06,640 --> 00:19:09,679
we basically produce an edge in our

498
00:19:09,679 --> 00:19:11,039
binary dependency graph

499
00:19:11,039 --> 00:19:13,679
that connects these two binaries when we

500
00:19:13,679 --> 00:19:14,880
do this for all that

501
00:19:14,880 --> 00:19:16,880
all the binaries containing our in our

502
00:19:16,880 --> 00:19:18,400
image we have our

503
00:19:18,400 --> 00:19:20,960
fully built binary dependency graph we

504
00:19:20,960 --> 00:19:23,280
can start our multi binary uh

505
00:19:23,280 --> 00:19:26,400
data flow analysis so in this step we

506
00:19:26,400 --> 00:19:28,640
track our data is propagated from

507
00:19:28,640 --> 00:19:31,280
one binary to another and we collect

508
00:19:31,280 --> 00:19:32,160
constraints

509
00:19:32,160 --> 00:19:35,039
the constraints that each binary applies

510
00:19:35,039 --> 00:19:37,039
to the tainted data

511
00:19:37,039 --> 00:19:40,240
we implemented these uh on top of

512
00:19:40,240 --> 00:19:43,440
the of anger a popular binary analysis

513
00:19:43,440 --> 00:19:45,280
framework that also implements

514
00:19:45,280 --> 00:19:47,679
uh symbolic execution and you can

515
00:19:47,679 --> 00:19:49,039
imagine here that one of the

516
00:19:49,039 --> 00:19:52,320
the big steps the big problem here is

517
00:19:52,320 --> 00:19:53,280
that

518
00:19:53,280 --> 00:19:55,760
when we do so we should consider all the

519
00:19:55,760 --> 00:19:57,840
possible paths in a program

520
00:19:57,840 --> 00:20:00,559
that apply constraints to our tainted

521
00:20:00,559 --> 00:20:01,280
data

522
00:20:01,280 --> 00:20:03,360
this is of course unfeasible so what we

523
00:20:03,360 --> 00:20:06,000
do is that we explore paths within a

524
00:20:06,000 --> 00:20:07,440
certain time limit

525
00:20:07,440 --> 00:20:10,000
and we propagate only the least strict

526
00:20:10,000 --> 00:20:11,919
set of constraints to the

527
00:20:11,919 --> 00:20:14,799
next binaries why the list is set

528
00:20:14,799 --> 00:20:15,840
because we are looking for

529
00:20:15,840 --> 00:20:17,120
vulnerabilities

530
00:20:17,120 --> 00:20:19,840
and under constrained data is more

531
00:20:19,840 --> 00:20:20,960
likely to

532
00:20:20,960 --> 00:20:23,280
produce to lead to security

533
00:20:23,280 --> 00:20:24,240
vulnerabilities

534
00:20:24,240 --> 00:20:26,559
so let's come back to our example uh in

535
00:20:26,559 --> 00:20:28,880
this case this is the location where

536
00:20:28,880 --> 00:20:31,600
data is being shared and if we go back

537
00:20:31,600 --> 00:20:32,720
this data

538
00:20:32,720 --> 00:20:36,960
can be produced by two different paths

539
00:20:36,960 --> 00:20:38,960
the difference between these two paths

540
00:20:38,960 --> 00:20:41,760
is that in the second case

541
00:20:41,760 --> 00:20:45,159
the data is constrained and can be up to

542
00:20:45,159 --> 00:20:46,960
127 bytes

543
00:20:46,960 --> 00:20:49,039
while in the first path there is no

544
00:20:49,039 --> 00:20:50,880
constraint at all so that the size of

545
00:20:50,880 --> 00:20:52,240
the buffer p

546
00:20:52,240 --> 00:20:54,240
is not specified is unlimited

547
00:20:54,240 --> 00:20:55,600
potentially

548
00:20:55,600 --> 00:20:57,280
so in this case since we want to look

549
00:20:57,280 --> 00:20:59,760
for vulnerabilities what we do

550
00:20:59,760 --> 00:21:03,200
is that we select the least strict set

551
00:21:03,200 --> 00:21:05,039
of constraints so in this case we go for

552
00:21:05,039 --> 00:21:06,400
the first path

553
00:21:06,400 --> 00:21:09,360
and in the binary on the right we set

554
00:21:09,360 --> 00:21:10,559
the query

555
00:21:10,559 --> 00:21:14,240
buffer to be unconstrained

556
00:21:14,240 --> 00:21:16,799
okay nice now the last step of our

557
00:21:16,799 --> 00:21:17,360
approach

558
00:21:17,360 --> 00:21:20,960
while we do our uh data flow analysis we

559
00:21:20,960 --> 00:21:21,600
want to

560
00:21:21,600 --> 00:21:24,080
uncover vulnerabilities so the type of

561
00:21:24,080 --> 00:21:25,600
vulnerabilities that we look for

562
00:21:25,600 --> 00:21:28,400
are buffer overflows and denial of

563
00:21:28,400 --> 00:21:30,720
service vulnerabilities specifically

564
00:21:30,720 --> 00:21:33,280
attacker control loops and what karante

565
00:21:33,280 --> 00:21:34,400
does to do so

566
00:21:34,400 --> 00:21:38,159
is that of course we retain data

567
00:21:38,159 --> 00:21:39,919
sent and propagated from one binary to

568
00:21:39,919 --> 00:21:41,760
another and

569
00:21:41,760 --> 00:21:43,760
currently raises an alert whenever

570
00:21:43,760 --> 00:21:46,240
tainted and underconstrained data

571
00:21:46,240 --> 00:21:49,360
reaches async what's a thing for us i

572
00:21:49,360 --> 00:21:50,240
think it's

573
00:21:50,240 --> 00:21:53,280
a mem copy like function

574
00:21:53,280 --> 00:21:55,679
so any function that is semantically

575
00:21:55,679 --> 00:21:57,200
equivalent to

576
00:21:57,200 --> 00:21:59,919
a function that copies data from one

577
00:21:59,919 --> 00:22:00,720
source to

578
00:22:00,720 --> 00:22:04,240
a destination but also a

579
00:22:04,240 --> 00:22:07,520
difference of of tainted variable and

580
00:22:07,520 --> 00:22:10,559
a comparison of tented variables in in

581
00:22:10,559 --> 00:22:12,320
loop condition

582
00:22:12,320 --> 00:22:14,559
if we go back again to our example we

583
00:22:14,559 --> 00:22:15,760
can see here

584
00:22:15,760 --> 00:22:19,039
that this is the location where this

585
00:22:19,039 --> 00:22:21,440
binary receives

586
00:22:21,440 --> 00:22:25,120
painted data and this data is later used

587
00:22:25,120 --> 00:22:26,080
in the process

588
00:22:26,080 --> 00:22:29,280
request and after some processing uh it

589
00:22:29,280 --> 00:22:31,280
reaches a sink so there is an unsafe

590
00:22:31,280 --> 00:22:33,039
string copy here without

591
00:22:33,039 --> 00:22:35,760
any check on the destination sides on

592
00:22:35,760 --> 00:22:37,760
the sides of the destination buffer so

593
00:22:37,760 --> 00:22:41,039
in this case current produces an alert

594
00:22:41,039 --> 00:22:44,480
cool this is our approach to show that

595
00:22:44,480 --> 00:22:46,400
this really works in practice

596
00:22:46,400 --> 00:22:50,400
we first of all performed a

597
00:22:50,400 --> 00:22:54,559
in-depth evaluation and in this case we

598
00:22:54,559 --> 00:22:57,679
analyzed uh 53 firmware images from

599
00:22:57,679 --> 00:22:59,520
seven different vendors

600
00:22:59,520 --> 00:23:02,640
we actually found 46 new zero days

601
00:23:02,640 --> 00:23:06,080
uh we got a bunch of cvs uh but not only

602
00:23:06,080 --> 00:23:07,760
currently was able to

603
00:23:07,760 --> 00:23:10,480
detect these unknown bugs but it was

604
00:23:10,480 --> 00:23:12,320
able to decrease the number of alerts

605
00:23:12,320 --> 00:23:13,280
the average number of

606
00:23:13,280 --> 00:23:16,559
leds from more than 900 to uh

607
00:23:16,559 --> 00:23:19,679
five alerts per firmware image this is

608
00:23:19,679 --> 00:23:22,720
a an alert reduction of two orders of

609
00:23:22,720 --> 00:23:23,679
magnitude

610
00:23:23,679 --> 00:23:25,520
and but at the same time giving a very

611
00:23:25,520 --> 00:23:26,720
low

612
00:23:26,720 --> 00:23:29,200
force positive and force negative rates

613
00:23:29,200 --> 00:23:30,080
so we can see

614
00:23:30,080 --> 00:23:32,320
some numbers about this reduction in

615
00:23:32,320 --> 00:23:34,159
this table

616
00:23:34,159 --> 00:23:37,280
these are some statistics about

617
00:23:37,280 --> 00:23:38,880
the number of binaries the number of

618
00:23:38,880 --> 00:23:41,039
alerts and the execution time

619
00:23:41,039 --> 00:23:43,840
required to analyze these firmware

620
00:23:43,840 --> 00:23:44,799
images

621
00:23:44,799 --> 00:23:47,120
when using traditional static analysis

622
00:23:47,120 --> 00:23:48,480
approaches so when

623
00:23:48,480 --> 00:23:51,360
dealing with each binaries each binary

624
00:23:51,360 --> 00:23:52,880
individually

625
00:23:52,880 --> 00:23:54,480
here on the right instead you can see

626
00:23:54,480 --> 00:23:57,039
the same numbers when we apply

627
00:23:57,039 --> 00:23:59,039
karantes approach and you can see that

628
00:23:59,039 --> 00:24:01,520
there is a quite significant reduction

629
00:24:01,520 --> 00:24:04,559
both in terms of number of alerts but

630
00:24:04,559 --> 00:24:06,400
also execution time

631
00:24:06,400 --> 00:24:08,240
required for analyzing this this

632
00:24:08,240 --> 00:24:10,000
firmware image

633
00:24:10,000 --> 00:24:11,520
we also perform a larger scale

634
00:24:11,520 --> 00:24:13,520
evaluation so in this case we

635
00:24:13,520 --> 00:24:16,240
collected almost 900 female samples we

636
00:24:16,240 --> 00:24:17,039
found that

637
00:24:17,039 --> 00:24:19,039
almost 40 percent of them contain

638
00:24:19,039 --> 00:24:20,960
multi-binary interactions

639
00:24:20,960 --> 00:24:24,720
and we also manually uh inspected 100

640
00:24:24,720 --> 00:24:25,840
alerts out of

641
00:24:25,840 --> 00:24:29,120
out of the 1003 alerts that currently

642
00:24:29,120 --> 00:24:30,880
generated during this analysis

643
00:24:30,880 --> 00:24:33,440
we found that 44 were actually true

644
00:24:33,440 --> 00:24:34,559
positives

645
00:24:34,559 --> 00:24:37,440
and 30 of these 44 true positive were

646
00:24:37,440 --> 00:24:39,279
actually multi-binary

647
00:24:39,279 --> 00:24:42,480
vulnerabilities so just to give you a

648
00:24:42,480 --> 00:24:43,200
bit more

649
00:24:43,200 --> 00:24:47,120
insights about our analysis

650
00:24:47,120 --> 00:24:50,240
uh this is the distribution of the

651
00:24:50,240 --> 00:24:52,960
sides of the binary dependency graphs in

652
00:24:52,960 --> 00:24:53,760
our in our

653
00:24:53,760 --> 00:24:55,840
evaluation so you can see that the vast

654
00:24:55,840 --> 00:24:58,080
majority of firmware images

655
00:24:58,080 --> 00:25:01,440
uh produces um bdgs

656
00:25:01,440 --> 00:25:04,000
with five binaries that interact with

657
00:25:04,000 --> 00:25:04,559
each other

658
00:25:04,559 --> 00:25:07,919
but we also seem quite complex bdgs

659
00:25:07,919 --> 00:25:09,440
for instance there was one sample that

660
00:25:09,440 --> 00:25:11,520
produced a binary dependency graph

661
00:25:11,520 --> 00:25:12,400
containing

662
00:25:12,400 --> 00:25:15,279
16 binaries which was quite surprising

663
00:25:15,279 --> 00:25:17,520
for us i would say

664
00:25:17,520 --> 00:25:20,080
perfect then in terms of uh execution

665
00:25:20,080 --> 00:25:20,640
times

666
00:25:20,640 --> 00:25:24,000
uh execution time current it

667
00:25:24,000 --> 00:25:26,240
indeed takes a bit of time to analyze a

668
00:25:26,240 --> 00:25:28,000
firmware image on average

669
00:25:28,000 --> 00:25:30,799
15 hours but the good thing is that this

670
00:25:30,799 --> 00:25:31,600
time

671
00:25:31,600 --> 00:25:34,960
scales well when the the size

672
00:25:34,960 --> 00:25:38,320
and the complexity of the firmware image

673
00:25:38,320 --> 00:25:39,120
increases

674
00:25:39,120 --> 00:25:41,520
you can see in these two charts on the

675
00:25:41,520 --> 00:25:42,400
right

676
00:25:42,400 --> 00:25:44,240
and you can also see in this chart there

677
00:25:44,240 --> 00:25:46,080
are some spikes

678
00:25:46,080 --> 00:25:48,720
this was actually due to implementation

679
00:25:48,720 --> 00:25:49,440
issues

680
00:25:49,440 --> 00:25:52,080
specifically because karante is still

681
00:25:52,080 --> 00:25:53,200
using unfortunately

682
00:25:53,200 --> 00:25:56,000
another version of anger that was not

683
00:25:56,000 --> 00:25:57,200
optimized

684
00:25:57,200 --> 00:25:59,120
and was taking a lot of time to uh

685
00:25:59,120 --> 00:26:00,960
compute some counterflow graphs

686
00:26:00,960 --> 00:26:04,400
this is a now way faster in the in the

687
00:26:04,400 --> 00:26:06,480
latest version of anger and we will

688
00:26:06,480 --> 00:26:08,720
hopefully soon

689
00:26:08,720 --> 00:26:13,200
update our prototype of current

690
00:26:13,200 --> 00:26:16,559
so now uh you've seen you know how

691
00:26:16,559 --> 00:26:17,679
currently works

692
00:26:17,679 --> 00:26:20,640
let's see how to run it so we released

693
00:26:20,640 --> 00:26:22,080
all our code on github

694
00:26:22,080 --> 00:26:24,559
you can see you can find it at this url

695
00:26:24,559 --> 00:26:26,240
and in the same repository

696
00:26:26,240 --> 00:26:29,360
you'll find instructions on how to uh

697
00:26:29,360 --> 00:26:32,720
download a docker image that comes with

698
00:26:32,720 --> 00:26:35,919
uh karante already uh installed ready to

699
00:26:35,919 --> 00:26:37,039
be fired

700
00:26:37,039 --> 00:26:39,810
and if we look at this

701
00:26:39,810 --> 00:26:41,440
[Music]

702
00:26:41,440 --> 00:26:44,240
docker image you can see you can find

703
00:26:44,240 --> 00:26:46,960
here some folders in our code

704
00:26:46,960 --> 00:26:51,120
and to actually run the tool you need to

705
00:26:51,200 --> 00:26:53,279
create a configuration file so we have

706
00:26:53,279 --> 00:26:56,400
some examples here

707
00:27:02,080 --> 00:27:04,640
this is for instance a configuration

708
00:27:04,640 --> 00:27:05,360
file

709
00:27:05,360 --> 00:27:07,840
uh for a specific firmware image you can

710
00:27:07,840 --> 00:27:09,520
find on our repository

711
00:27:09,520 --> 00:27:14,159
all the instructions on on how to um

712
00:27:14,159 --> 00:27:16,480
what all these settings means and how to

713
00:27:16,480 --> 00:27:17,600
use them

714
00:27:17,600 --> 00:27:19,360
but then if you want to run the tool you

715
00:27:19,360 --> 00:27:22,320
actually need to only pass this

716
00:27:22,320 --> 00:27:25,200
configuration file in the command line

717
00:27:25,200 --> 00:27:27,120
so if we run this command

718
00:27:27,120 --> 00:27:30,320
now we should have a current running on

719
00:27:30,320 --> 00:27:31,039
this

720
00:27:31,039 --> 00:27:33,279
specific firmware image as i mentioned

721
00:27:33,279 --> 00:27:34,159
this will take

722
00:27:34,159 --> 00:27:36,320
quite a bit of time so i will not wait

723
00:27:36,320 --> 00:27:37,919
for this to finish

724
00:27:37,919 --> 00:27:41,039
but i want to show you what happens when

725
00:27:41,039 --> 00:27:43,440
this uh terminates so at the end of the

726
00:27:43,440 --> 00:27:45,039
analysis karante produces a

727
00:27:45,039 --> 00:27:48,000
log file you can see this here with all

728
00:27:48,000 --> 00:27:49,840
the information about the analysis

729
00:27:49,840 --> 00:27:51,120
but instead of looking at this

730
00:27:51,120 --> 00:27:53,679
text-based log file we recently

731
00:27:53,679 --> 00:27:55,279
implemented a

732
00:27:55,279 --> 00:27:58,240
very simple ui to visualize these

733
00:27:58,240 --> 00:27:59,520
results

734
00:27:59,520 --> 00:28:02,399
and if i run this command nothing really

735
00:28:02,399 --> 00:28:05,120
fancy but we should be able to see

736
00:28:05,120 --> 00:28:08,320
some information about this femur image

737
00:28:08,320 --> 00:28:10,159
and these specific analysis so we can

738
00:28:10,159 --> 00:28:12,520
see that this image contains

739
00:28:12,520 --> 00:28:16,799
128 binaries luckily not all of them

740
00:28:16,799 --> 00:28:18,559
process user input so we can see

741
00:28:18,559 --> 00:28:20,480
actually a rather simple

742
00:28:20,480 --> 00:28:23,440
binary dependency graph the light dots

743
00:28:23,440 --> 00:28:25,120
are the border binaries

744
00:28:25,120 --> 00:28:27,279
we can see additional information about

745
00:28:27,279 --> 00:28:28,559
for instance like the

746
00:28:28,559 --> 00:28:31,279
data keys that are used in the

747
00:28:31,279 --> 00:28:33,919
communication between different binaries

748
00:28:33,919 --> 00:28:35,360
but the nice thing is that we can

749
00:28:35,360 --> 00:28:37,279
actually look at the alerts uh

750
00:28:37,279 --> 00:28:39,440
generated by karante so if i select the

751
00:28:39,440 --> 00:28:40,480
first alert

752
00:28:40,480 --> 00:28:42,399
we can see that the path of this alert

753
00:28:42,399 --> 00:28:45,200
is highlighted in the in this graph

754
00:28:45,200 --> 00:28:47,360
and this is specifically an alert

755
00:28:47,360 --> 00:28:48,320
produced by

756
00:28:48,320 --> 00:28:51,919
a data flow which started in the httpd

757
00:28:51,919 --> 00:28:54,840
binary that communicates with the file

758
00:28:54,840 --> 00:28:56,320
access.cgi

759
00:28:56,320 --> 00:28:59,840
binary this communication happens over

760
00:28:59,840 --> 00:29:03,440
a content type data key this is the

761
00:29:03,440 --> 00:29:06,720
address of the uh buffer used to

762
00:29:06,720 --> 00:29:08,559
share data and this is the address of

763
00:29:08,559 --> 00:29:09,840
our sync so this is

764
00:29:09,840 --> 00:29:12,960
where our data flow ends up so this is

765
00:29:12,960 --> 00:29:13,760
this is where

766
00:29:13,760 --> 00:29:16,000
where potentially we might find a

767
00:29:16,000 --> 00:29:17,360
vulnerability

768
00:29:17,360 --> 00:29:20,080
and indeed we combine this with angus

769
00:29:20,080 --> 00:29:21,840
the compiler so if i click on the very

770
00:29:21,840 --> 00:29:23,520
last binary of this path

771
00:29:23,520 --> 00:29:26,799
anger is going to decompile the uh

772
00:29:26,799 --> 00:29:29,600
potentially vulnerable function uh the

773
00:29:29,600 --> 00:29:30,399
decompile

774
00:29:30,399 --> 00:29:31,919
in angular is still a work in progress

775
00:29:31,919 --> 00:29:34,000
so you'll see that the decompile code is

776
00:29:34,000 --> 00:29:35,679
not the quality is not great

777
00:29:35,679 --> 00:29:37,919
but it's still good enough for us to

778
00:29:37,919 --> 00:29:40,320
spot a real-world vulnerability

779
00:29:40,320 --> 00:29:43,840
so you can see that in this function

780
00:29:43,840 --> 00:29:46,799
this program receives uh tainted data

781
00:29:46,799 --> 00:29:48,880
from from an environment variable

782
00:29:48,880 --> 00:29:51,520
and later on uh believe me this this

783
00:29:51,520 --> 00:29:52,960
data is used

784
00:29:52,960 --> 00:29:57,279
in an unsafe string copy so leading to a

785
00:29:57,279 --> 00:30:00,559
buffer overflow this was a quick example

786
00:30:00,559 --> 00:30:02,240
and but this was indeed a real word

787
00:30:02,240 --> 00:30:05,360
vulnerability and of course we

788
00:30:05,360 --> 00:30:08,399
disclosed this vulnerability and

789
00:30:08,399 --> 00:30:10,159
everything else that we found to the

790
00:30:10,159 --> 00:30:11,600
responsible vendors

791
00:30:11,600 --> 00:30:13,919
many of which have already released

792
00:30:13,919 --> 00:30:15,039
patches for their

793
00:30:15,039 --> 00:30:17,760
for their devices so to wrap up this

794
00:30:17,760 --> 00:30:19,520
presentation uh

795
00:30:19,520 --> 00:30:21,679
briefly couple what we achieved we

796
00:30:21,679 --> 00:30:23,520
introduced static analysis techniques to

797
00:30:23,520 --> 00:30:24,480
perform

798
00:30:24,480 --> 00:30:27,039
multibinary tent analysis and our

799
00:30:27,039 --> 00:30:28,399
prototype current

800
00:30:28,399 --> 00:30:31,120
is indeed able to discover unknown bugs

801
00:30:31,120 --> 00:30:32,399
in embedded firmware

802
00:30:32,399 --> 00:30:34,880
by drastically reducing the number of

803
00:30:34,880 --> 00:30:36,080
false positives

804
00:30:36,080 --> 00:30:38,240
an interesting aspect of our research is

805
00:30:38,240 --> 00:30:39,200
that

806
00:30:39,200 --> 00:30:41,600
despite program analytics is quite a

807
00:30:41,600 --> 00:30:43,600
complex task even when applied to a

808
00:30:43,600 --> 00:30:45,120
single binary

809
00:30:45,120 --> 00:30:47,360
scaling program analysis and binary

810
00:30:47,360 --> 00:30:49,039
analysis to a

811
00:30:49,039 --> 00:30:51,760
multi-binary environment is possible

812
00:30:51,760 --> 00:30:53,279
because modeling the interactions

813
00:30:53,279 --> 00:30:54,960
between these binaries

814
00:30:54,960 --> 00:30:58,320
can make things uh quite easier

815
00:30:58,320 --> 00:31:00,480
perfect and thank you for for attending

816
00:31:00,480 --> 00:31:02,480
this talk just a reminder there is a

817
00:31:02,480 --> 00:31:05,120
an academic paper on this so feel free

818
00:31:05,120 --> 00:31:06,000
to check it out

819
00:31:06,000 --> 00:31:08,559
if you want to read more details and

820
00:31:08,559 --> 00:31:10,480
then i'd be happy to

821
00:31:10,480 --> 00:31:13,519
take any question on the live stream

822
00:31:13,519 --> 00:31:15,840
ciao

823
00:31:16,960 --> 00:31:20,159
andrea hello hi hello

824
00:31:20,159 --> 00:31:24,480
how are you good how are you all so good

825
00:31:24,480 --> 00:31:29,600
so uh that was an amazing work so

826
00:31:29,919 --> 00:31:32,960
and and as you can see uh

827
00:31:32,960 --> 00:31:36,080
for from the qn data uh

828
00:31:36,080 --> 00:31:39,200
it raises some uh some attention and

829
00:31:39,200 --> 00:31:42,240
uh some questions so uh let's start from

830
00:31:42,240 --> 00:31:42,640
uh

831
00:31:42,640 --> 00:31:45,360
from the from the first question it's uh

832
00:31:45,360 --> 00:31:46,880
um

833
00:31:46,880 --> 00:31:50,080
by by sukhdev uh he

834
00:31:50,080 --> 00:31:53,360
wrote what happens when someone like uh

835
00:31:53,360 --> 00:31:55,679
why like filippo cremeneze tries to

836
00:31:55,679 --> 00:31:57,600
manually and maliciously

837
00:31:57,600 --> 00:32:01,039
patch the binary file yeah

838
00:32:01,039 --> 00:32:03,679
that's a great question and uh first of

839
00:32:03,679 --> 00:32:05,279
all i hope that philippe

840
00:32:05,279 --> 00:32:07,360
can patch all our firmware so that we

841
00:32:07,360 --> 00:32:08,880
have uh

842
00:32:08,880 --> 00:32:12,320
more secure devices that's of course the

843
00:32:12,320 --> 00:32:13,840
end goal of our research right so we

844
00:32:13,840 --> 00:32:15,440
want to identify vulnerabilities because

845
00:32:15,440 --> 00:32:17,039
we want to patch them and make these

846
00:32:17,039 --> 00:32:18,720
devices more secure

847
00:32:18,720 --> 00:32:20,799
and patching is also something that we

848
00:32:20,799 --> 00:32:22,399
are working on

849
00:32:22,399 --> 00:32:25,120
the the tricky thing is that uh applying

850
00:32:25,120 --> 00:32:25,919
techniques

851
00:32:25,919 --> 00:32:29,200
like the ones that people described

852
00:32:29,200 --> 00:32:31,919
really nicely in the femur domain is a

853
00:32:31,919 --> 00:32:32,720
little bit more

854
00:32:32,720 --> 00:32:36,320
complex because female presents some

855
00:32:36,320 --> 00:32:38,159
characteristics that make this analysis

856
00:32:38,159 --> 00:32:40,159
particularly difficult to apply and i

857
00:32:40,159 --> 00:32:41,120
can give

858
00:32:41,120 --> 00:32:44,159
two examples for instance one is that uh

859
00:32:44,159 --> 00:32:46,799
female images are usually flashed into

860
00:32:46,799 --> 00:32:47,919
memories that have

861
00:32:47,919 --> 00:32:50,320
very small and fixed size right so it's

862
00:32:50,320 --> 00:32:52,159
often not possible to

863
00:32:52,159 --> 00:32:54,559
inject and add additional code in a

864
00:32:54,559 --> 00:32:56,640
female image so if you want to

865
00:32:56,640 --> 00:32:58,559
patch something by introducing and

866
00:32:58,559 --> 00:33:00,480
inject the new code we have to replace

867
00:33:00,480 --> 00:33:01,600
something that is already in the

868
00:33:01,600 --> 00:33:03,360
firmware image we can we don't have any

869
00:33:03,360 --> 00:33:04,399
any space left

870
00:33:04,399 --> 00:33:06,559
this is very common and the other the

871
00:33:06,559 --> 00:33:09,120
other thing is that

872
00:33:09,120 --> 00:33:12,240
firmware images often uh present

873
00:33:12,240 --> 00:33:15,360
uh integrity checks to avoid uh

874
00:33:15,360 --> 00:33:17,919
you know tampering if you modify and

875
00:33:17,919 --> 00:33:18,799
change anything

876
00:33:18,799 --> 00:33:22,159
in the uh in the firmware image then

877
00:33:22,159 --> 00:33:23,840
the signature check or the integrity

878
00:33:23,840 --> 00:33:26,000
check will be uh

879
00:33:26,000 --> 00:33:28,080
destroyed basically and so the firmware

880
00:33:28,080 --> 00:33:29,760
will not run so this is another

881
00:33:29,760 --> 00:33:31,840
challenge that when you want to patch

882
00:33:31,840 --> 00:33:33,279
firmware you have to deal with this you

883
00:33:33,279 --> 00:33:34,720
have to somehow

884
00:33:34,720 --> 00:33:39,840
adjust also the these checks

885
00:33:40,480 --> 00:33:47,039
okay nice so the second question is uh

886
00:33:47,039 --> 00:33:50,000
did you evaluate the false negative rate

887
00:33:50,000 --> 00:33:52,080
based on known vulnerabilities so you

888
00:33:52,080 --> 00:33:54,559
mentioned that uh this was proven very

889
00:33:54,559 --> 00:33:55,919
effective and uh

890
00:33:55,919 --> 00:33:58,960
and quite accurate but and you and you

891
00:33:58,960 --> 00:34:00,480
and you show some numbers about the

892
00:34:00,480 --> 00:34:03,279
force positive but probably the question

893
00:34:03,279 --> 00:34:03,519
is

894
00:34:03,519 --> 00:34:06,799
here is on false negative yeah

895
00:34:06,799 --> 00:34:08,800
yeah that's also a another great

896
00:34:08,800 --> 00:34:10,239
question we did

897
00:34:10,239 --> 00:34:12,480
we did it for the let's say a small

898
00:34:12,480 --> 00:34:14,079
scale experiment so well only when

899
00:34:14,079 --> 00:34:14,960
looking at the

900
00:34:14,960 --> 00:34:17,839
53 filmer images not in the large scale

901
00:34:17,839 --> 00:34:19,520
scenario because there would be

902
00:34:19,520 --> 00:34:23,599
a little bit say more difficult to do

903
00:34:23,599 --> 00:34:25,520
what with this i will look for cves

904
00:34:25,520 --> 00:34:26,879
non-cvs from the

905
00:34:26,879 --> 00:34:30,079
for the same firmware images and

906
00:34:30,079 --> 00:34:32,000
we found that the vast majority of them

907
00:34:32,000 --> 00:34:34,320
were covered by our approach we did find

908
00:34:34,320 --> 00:34:36,480
some false negatives i remember

909
00:34:36,480 --> 00:34:39,650
two for sure for sure and these were due

910
00:34:39,650 --> 00:34:40,879
[Music]

911
00:34:40,879 --> 00:34:44,078
to the fact that

912
00:34:44,320 --> 00:34:48,560
the binaries were presenting some weird

913
00:34:48,560 --> 00:34:52,480
ways to address a reference to strings

914
00:34:52,480 --> 00:34:54,960
if i remember correctly one of them was

915
00:34:54,960 --> 00:34:56,719
computing the address of

916
00:34:56,719 --> 00:34:59,280
a string by computing an offset from the

917
00:34:59,280 --> 00:34:59,839
global

918
00:34:59,839 --> 00:35:01,920
offset table but there were some things

919
00:35:01,920 --> 00:35:04,320
that anger our underlying analysis were

920
00:35:04,320 --> 00:35:06,960
was not able to properly track down and

921
00:35:06,960 --> 00:35:07,839
so we missed

922
00:35:07,839 --> 00:35:10,240
some strings and this resulted us in

923
00:35:10,240 --> 00:35:11,839
failing to identify

924
00:35:11,839 --> 00:35:13,599
the border binaries which is the let's

925
00:35:13,599 --> 00:35:15,200
say the initial

926
00:35:15,200 --> 00:35:18,320
part of our approach and uh and so this

927
00:35:18,320 --> 00:35:19,839
made the analysis failed

928
00:35:19,839 --> 00:35:22,160
what we did is that uh to check that

929
00:35:22,160 --> 00:35:22,960
this was still

930
00:35:22,960 --> 00:35:25,440
let's say the the the later part of our

931
00:35:25,440 --> 00:35:27,680
analysis was still working we

932
00:35:27,680 --> 00:35:30,079
manually added these binaries as border

933
00:35:30,079 --> 00:35:32,640
binaries and then currently was able to

934
00:35:32,640 --> 00:35:34,800
detect the vulnerabilities later on but

935
00:35:34,800 --> 00:35:36,160
indeed there are some of course some

936
00:35:36,160 --> 00:35:38,079
limitations

937
00:35:38,079 --> 00:35:42,480
nice and then the next question is uh

938
00:35:42,480 --> 00:35:44,560
did you test any enterprise grade

939
00:35:44,560 --> 00:35:45,920
network or security

940
00:35:45,920 --> 00:35:48,960
appliances uh do you see any

941
00:35:48,960 --> 00:35:51,599
in case you didn't uh do you see any

942
00:35:51,599 --> 00:35:52,800
limitation

943
00:35:52,800 --> 00:35:55,119
using this approach on stuff like client

944
00:35:55,119 --> 00:35:56,160
vpns

945
00:35:56,160 --> 00:35:59,119
load balancers etc for which we saw

946
00:35:59,119 --> 00:36:00,960
spike in disclosed vulnerabilities

947
00:36:00,960 --> 00:36:02,800
recently

948
00:36:02,800 --> 00:36:05,440
uh we did not test any of these uh

949
00:36:05,440 --> 00:36:06,880
security appliances

950
00:36:06,880 --> 00:36:10,160
uh on uh let's say on a high level i

951
00:36:10,160 --> 00:36:11,280
don't see any

952
00:36:11,280 --> 00:36:13,839
specific limitations that could prevent

953
00:36:13,839 --> 00:36:15,119
this approach to be

954
00:36:15,119 --> 00:36:18,480
to be applied there might be

955
00:36:18,480 --> 00:36:21,680
some you know engineering or technical

956
00:36:21,680 --> 00:36:23,839
uh difference that we might need to

957
00:36:23,839 --> 00:36:24,800
implement in

958
00:36:24,800 --> 00:36:27,839
the case these appliances present some

959
00:36:27,839 --> 00:36:30,160
differences but on the high level i

960
00:36:30,160 --> 00:36:31,359
would say that this

961
00:36:31,359 --> 00:36:34,880
can be applied even in these scenarios

962
00:36:34,880 --> 00:36:38,800
okay thank you and so so we look forward

963
00:36:38,800 --> 00:36:40,320
to have a

964
00:36:40,320 --> 00:36:42,560
huge number of cves coming from

965
00:36:42,560 --> 00:36:44,880
something like this no

966
00:36:44,880 --> 00:36:48,800
uh yes but also i would say also a

967
00:36:48,800 --> 00:36:51,200
va a number of a high number of patches

968
00:36:51,200 --> 00:36:52,800
right so we won't indeed we want to find

969
00:36:52,800 --> 00:36:54,000
vulnerabilities but we want

970
00:36:54,000 --> 00:36:58,000
also to patch those vulnerabilities and

971
00:36:58,000 --> 00:37:00,240
patching in the iot domain is

972
00:37:00,240 --> 00:37:01,599
particularly

973
00:37:01,599 --> 00:37:04,000
tricky i mentioned already some

974
00:37:04,000 --> 00:37:04,880
challenges

975
00:37:04,880 --> 00:37:06,480
but also in terms of deployment right

976
00:37:06,480 --> 00:37:08,640
because sometimes also deploying patches

977
00:37:08,640 --> 00:37:09,280
for

978
00:37:09,280 --> 00:37:11,920
iot device or smart embedded devices

979
00:37:11,920 --> 00:37:13,520
it's a little bit more uh

980
00:37:13,520 --> 00:37:16,400
complex and so yeah the goal is to find

981
00:37:16,400 --> 00:37:17,920
these vulnerabilities but also

982
00:37:17,920 --> 00:37:20,560
hopefully to to make sure that those are

983
00:37:20,560 --> 00:37:21,839
patched

984
00:37:21,839 --> 00:37:25,680
timely nice

985
00:37:25,680 --> 00:37:29,200
so some compliments

986
00:37:29,200 --> 00:37:33,839
from vinci and from protozoa

987
00:37:33,839 --> 00:37:36,400
how much time and effort was required to

988
00:37:36,400 --> 00:37:39,280
develop karunti

989
00:37:39,280 --> 00:37:42,480
ah that's a nice question um

990
00:37:42,480 --> 00:37:45,599
i think in terms of development

991
00:37:45,599 --> 00:37:50,400
it was about a year or maybe

992
00:37:50,400 --> 00:37:53,440
uh yeah i would say around a year

993
00:37:53,440 --> 00:37:56,720
uh but you know maybe many of these uh

994
00:37:56,720 --> 00:38:00,560
techniques are based also on anger which

995
00:38:00,560 --> 00:38:01,599
is this uh

996
00:38:01,599 --> 00:38:03,760
binary analysis framework that has been

997
00:38:03,760 --> 00:38:04,800
developed at

998
00:38:04,800 --> 00:38:07,680
ucsb and so this also results of many

999
00:38:07,680 --> 00:38:09,280
years of research right so anger has

1000
00:38:09,280 --> 00:38:10,400
been developed and

1001
00:38:10,400 --> 00:38:14,160
and increasingly being

1002
00:38:14,160 --> 00:38:18,000
you know improved uh over the past uh

1003
00:38:18,000 --> 00:38:21,440
five or more years so specifically for

1004
00:38:21,440 --> 00:38:23,359
currently one year but also

1005
00:38:23,359 --> 00:38:26,000
we use many of the results from previous

1006
00:38:26,000 --> 00:38:28,400
research

1007
00:38:29,040 --> 00:38:32,240
nice okay so

1008
00:38:32,240 --> 00:38:35,440
um thank you very much for

1009
00:38:35,440 --> 00:38:37,920
for your participation and uh thank you

1010
00:38:37,920 --> 00:38:38,880
very much for

1011
00:38:38,880 --> 00:38:42,320
for this amazing job uh so

1012
00:38:42,320 --> 00:38:46,880
um i we we have uh we have arrived at uh

1013
00:38:46,880 --> 00:38:50,560
our first uh break so have a nice uh

1014
00:38:50,560 --> 00:38:53,040
lunch i don't know what you are going to

1015
00:38:53,040 --> 00:38:54,160
to to eat

1016
00:38:54,160 --> 00:38:57,920
in in the netherlands

1017
00:38:59,680 --> 00:39:02,000
of um something is i think that's some

1018
00:39:02,000 --> 00:39:04,320
some nice pasta will be the the easy

1019
00:39:04,320 --> 00:39:11,520
solution for this

