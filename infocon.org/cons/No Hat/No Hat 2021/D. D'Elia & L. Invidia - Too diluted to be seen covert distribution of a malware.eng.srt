1
00:00:02,480 --> 00:00:05,260
uh

2
00:00:05,260 --> 00:00:08,500
[Music]

3
00:00:10,700 --> 00:00:21,039
[Music]

4
00:00:21,039 --> 00:00:24,039
me

5
00:00:24,410 --> 00:00:33,440
[Music]

6
00:00:33,440 --> 00:00:34,960
so

7
00:00:34,960 --> 00:00:37,760
on top of that i'm also a member of this

8
00:00:37,760 --> 00:00:39,840
support group for speakers that haven't

9
00:00:39,840 --> 00:00:42,239
been able to give a talk in person in

10
00:00:42,239 --> 00:00:44,399
the last two years it's great to speak

11
00:00:44,399 --> 00:00:46,480
finally not in front of a zoom

12
00:00:46,480 --> 00:00:49,120
screen but in front of a crowd and we

13
00:00:49,120 --> 00:00:52,399
hope we will entertain you or

14
00:00:52,399 --> 00:00:54,320
make you interested in our latest

15
00:00:54,320 --> 00:00:58,320
research this is a a joint work with

16
00:00:58,320 --> 00:01:01,760
lorenzo lorenzo nvidia holds a master

17
00:01:01,760 --> 00:01:03,600
degree in cyber security from my

18
00:01:03,600 --> 00:01:05,920
institution sapienza university of rome

19
00:01:05,920 --> 00:01:07,920
he is really passionate about windows

20
00:01:07,920 --> 00:01:11,119
internals and reverse engineering topics

21
00:01:11,119 --> 00:01:13,600
and is currently a junior researcher at

22
00:01:13,600 --> 00:01:16,640
my mentor labs while me uh

23
00:01:16,640 --> 00:01:19,119
i work on malware is

24
00:01:19,119 --> 00:01:21,520
probably my favorite topic i work also

25
00:01:21,520 --> 00:01:23,360
in other software and system security

26
00:01:23,360 --> 00:01:26,400
area fuzzing it's one of them um

27
00:01:26,400 --> 00:01:29,520
compiler-based mitigations and analysis

28
00:01:29,520 --> 00:01:30,320
for

29
00:01:30,320 --> 00:01:31,680
yeah for a few

30
00:01:31,680 --> 00:01:34,799
software security settings but today the

31
00:01:34,799 --> 00:01:38,799
topic is malware in particular uh how to

32
00:01:38,799 --> 00:01:40,960
to get around the defenses that you can

33
00:01:40,960 --> 00:01:42,799
obtain on any machine by having a

34
00:01:42,799 --> 00:01:45,360
state-of-the-art anti-virus or endpoint

35
00:01:45,360 --> 00:01:48,000
detection and response solution so those

36
00:01:48,000 --> 00:01:50,159
those kind of security solutions they

37
00:01:50,159 --> 00:01:52,240
should help you the moment that you have

38
00:01:52,240 --> 00:01:54,079
an entrusted piece of software that

39
00:01:54,079 --> 00:01:55,920
lands in your machine and you have to

40
00:01:55,920 --> 00:01:58,479
you know the user wants to execute it so

41
00:01:58,479 --> 00:02:00,560
when when you're dealing with a threat

42
00:02:00,560 --> 00:02:02,399
and it's a known threat something that

43
00:02:02,399 --> 00:02:04,000
you've seen before

44
00:02:04,000 --> 00:02:06,399
your security vendor has seen before

45
00:02:06,399 --> 00:02:08,878
what normally happens is that the the

46
00:02:08,878 --> 00:02:10,878
product can run a bunch of

47
00:02:10,878 --> 00:02:12,480
you know

48
00:02:12,480 --> 00:02:14,319
try to match it against some static

49
00:02:14,319 --> 00:02:16,239
signatures if this

50
00:02:16,239 --> 00:02:18,480
program resembles some threat that you

51
00:02:18,480 --> 00:02:20,160
already know you will just your your

52
00:02:20,160 --> 00:02:22,400
static signature will be fine but when

53
00:02:22,400 --> 00:02:24,480
when this is not the case and especially

54
00:02:24,480 --> 00:02:26,480
with the new threat

55
00:02:26,480 --> 00:02:28,720
you're only your only resource is really

56
00:02:28,720 --> 00:02:31,360
carrying a behavioral analysis by

57
00:02:31,360 --> 00:02:34,160
behavioral i mean that you

58
00:02:34,160 --> 00:02:36,640
start monitoring this program you keep

59
00:02:36,640 --> 00:02:38,640
this program on a titleish maybe at

60
00:02:38,640 --> 00:02:41,599
first and you you monitor specific

61
00:02:41,599 --> 00:02:43,519
events like the way that interacts with

62
00:02:43,519 --> 00:02:44,879
the file system with the windows

63
00:02:44,879 --> 00:02:47,040
registry network connection stuff like

64
00:02:47,040 --> 00:02:47,920
that

65
00:02:47,920 --> 00:02:50,239
and you try to see if any of those

66
00:02:50,239 --> 00:02:52,480
actions when you you analyze the

67
00:02:52,480 --> 00:02:54,640
sequence of events that take place

68
00:02:54,640 --> 00:02:57,200
they match some unknown patterns that

69
00:02:57,200 --> 00:02:58,879
that that is typically malicious so we

70
00:02:58,879 --> 00:03:01,200
can consider this some sort of dynamic

71
00:03:01,200 --> 00:03:03,280
signature the moment that the dynamic

72
00:03:03,280 --> 00:03:05,680
signature is met you you raise an alert

73
00:03:05,680 --> 00:03:07,519
but let's talk a little bit more about

74
00:03:07,519 --> 00:03:10,319
behavioral so um what you do i was

75
00:03:10,319 --> 00:03:12,080
saying before that initially you keep it

76
00:03:12,080 --> 00:03:14,560
on a tight leash by that i mean that

77
00:03:14,560 --> 00:03:16,239
in the early stages you can actually

78
00:03:16,239 --> 00:03:17,440
interpose

79
00:03:17,440 --> 00:03:19,920
on the execution on pretty much any api

80
00:03:19,920 --> 00:03:22,239
you can check the results and see what's

81
00:03:22,239 --> 00:03:24,799
going to happen next you can deny some

82
00:03:24,799 --> 00:03:26,959
operations but this is very very

83
00:03:26,959 --> 00:03:29,360
expensive to do so at some point you

84
00:03:29,360 --> 00:03:31,519
have to let this program go

85
00:03:31,519 --> 00:03:33,360
you still keep an eye on it so you will

86
00:03:33,360 --> 00:03:35,599
be still monitoring selected kinds of

87
00:03:35,599 --> 00:03:37,680
events like i was saying before the file

88
00:03:37,680 --> 00:03:40,400
system the network and you do so by

89
00:03:40,400 --> 00:03:43,200
using user space hooks so you are

90
00:03:43,200 --> 00:03:45,280
intercepting the execution of some

91
00:03:45,280 --> 00:03:46,640
functions using

92
00:03:46,640 --> 00:03:49,040
typically trampolines in user space and

93
00:03:49,040 --> 00:03:51,920
for file system you can use also mini

94
00:03:51,920 --> 00:03:54,720
filters in your kernel and you do this

95
00:03:54,720 --> 00:03:56,319
kind of monitoring

96
00:03:56,319 --> 00:03:59,439
on a per process basis pretty much and

97
00:03:59,439 --> 00:04:01,360
from time to time you can still kick in

98
00:04:01,360 --> 00:04:03,760
and the execution carry and

99
00:04:03,760 --> 00:04:05,920
in memory inspection so you look at the

100
00:04:05,920 --> 00:04:08,319
contents of the process address space

101
00:04:08,319 --> 00:04:10,640
but the issue here that the catch is

102
00:04:10,640 --> 00:04:12,720
that you do this on a pro one process at

103
00:04:12,720 --> 00:04:13,680
a time

104
00:04:13,680 --> 00:04:15,040
so there's

105
00:04:15,040 --> 00:04:17,358
one line of research that

106
00:04:17,358 --> 00:04:20,238
we call a distributed malware that tries

107
00:04:20,238 --> 00:04:21,759
to get around

108
00:04:21,759 --> 00:04:23,759
behavioral detection like that so i'm

109
00:04:23,759 --> 00:04:25,840
going to borrow a nice analogy that is

110
00:04:25,840 --> 00:04:28,560
from a recent work in the area they

111
00:04:28,560 --> 00:04:30,880
they mentioned this novel the naked sun

112
00:04:30,880 --> 00:04:33,360
where you have robots and those robots

113
00:04:33,360 --> 00:04:36,000
they're so low that prohibits them from

114
00:04:36,000 --> 00:04:38,400
hurting humans so a robot cannot

115
00:04:38,400 --> 00:04:40,639
deliberately carry an action that will

116
00:04:40,639 --> 00:04:44,000
harm a human being but what they do is

117
00:04:44,000 --> 00:04:46,800
essentially they start cooperating where

118
00:04:46,800 --> 00:04:49,759
no single robot will carry a task that

119
00:04:49,759 --> 00:04:52,240
is obviously against humor but if you

120
00:04:52,240 --> 00:04:54,080
take the aggregate of all those actions

121
00:04:54,080 --> 00:04:55,759
you actually end up with someone being

122
00:04:55,759 --> 00:04:57,680
killed and that's the story we

123
00:04:57,680 --> 00:05:00,240
distributed malware so you take

124
00:05:00,240 --> 00:05:02,960
multiple cooperating entities everyone

125
00:05:02,960 --> 00:05:05,120
will carry tests that they will not

126
00:05:05,120 --> 00:05:08,320
spook your aviarydr but in the end you

127
00:05:08,320 --> 00:05:10,560
will be carrying a distributed malicious

128
00:05:10,560 --> 00:05:12,160
computation

129
00:05:12,160 --> 00:05:14,320
so it seems that the problem is solved

130
00:05:14,320 --> 00:05:16,639
from at the same perspective it is but

131
00:05:16,639 --> 00:05:18,800
in practice you you end up with the

132
00:05:18,800 --> 00:05:21,280
current solutions that are kind of an

133
00:05:21,280 --> 00:05:24,720
easy prey of state-of-the-art avionidr

134
00:05:24,720 --> 00:05:27,520
products so there's one kind of one line

135
00:05:27,520 --> 00:05:29,840
of research that say okay we should just

136
00:05:29,840 --> 00:05:31,919
create a number of processes in the

137
00:05:31,919 --> 00:05:34,240
machine those processes that should be

138
00:05:34,240 --> 00:05:37,039
benign looking and they should carry the

139
00:05:37,039 --> 00:05:39,840
payload problem is that recent work

140
00:05:39,840 --> 00:05:43,120
still uses something like 20 processes

141
00:05:43,120 --> 00:05:45,440
creates 20 processes

142
00:05:45,440 --> 00:05:47,759
that try to behave nicely but it's still

143
00:05:47,759 --> 00:05:49,600
a big number that you have to introduce

144
00:05:49,600 --> 00:05:52,320
in a system plus uh the moment that you

145
00:05:52,320 --> 00:05:54,320
try to attempt correlation between these

146
00:05:54,320 --> 00:05:56,080
processes it's a bit difficult to you

147
00:05:56,080 --> 00:05:58,240
cannot say okay i'm gonna spoof my

148
00:05:58,240 --> 00:06:01,440
current process that won't get you far

149
00:06:01,440 --> 00:06:04,000
a much better approach in my opinion

150
00:06:04,000 --> 00:06:05,759
which by the way was pioneered by

151
00:06:05,759 --> 00:06:08,479
someone who is in the audience is to

152
00:06:08,479 --> 00:06:10,880
abuse the processes that you already

153
00:06:10,880 --> 00:06:12,560
have in your machine so you have

154
00:06:12,560 --> 00:06:14,960
applications that are long-running

155
00:06:14,960 --> 00:06:17,840
ideally and they do benign stuff so what

156
00:06:17,840 --> 00:06:20,720
you can do is you can try to inject code

157
00:06:20,720 --> 00:06:23,199
in these applications and

158
00:06:23,199 --> 00:06:25,039
your malicious actions will be

159
00:06:25,039 --> 00:06:27,360
interleaved with other

160
00:06:27,360 --> 00:06:30,080
events and it's it will be so diluted

161
00:06:30,080 --> 00:06:31,600
that you won't be able to see what's

162
00:06:31,600 --> 00:06:32,880
going on

163
00:06:32,880 --> 00:06:35,440
problem code injection is that i mean in

164
00:06:35,440 --> 00:06:37,919
the end you have to write executable

165
00:06:37,919 --> 00:06:40,240
memory so you will be either allocating

166
00:06:40,240 --> 00:06:43,280
or modifying existing executable memory

167
00:06:43,280 --> 00:06:45,919
and uh the current approaches they work

168
00:06:45,919 --> 00:06:48,479
on existing payloads so

169
00:06:48,479 --> 00:06:49,680
to support

170
00:06:49,680 --> 00:06:51,759
you take a standalone malware symbol and

171
00:06:51,759 --> 00:06:53,680
you want to retrofit this to work in a

172
00:06:53,680 --> 00:06:55,599
distributed fashion

173
00:06:55,599 --> 00:06:57,840
problem is that you should still support

174
00:06:57,840 --> 00:06:59,440
this execution and to provide

175
00:06:59,440 --> 00:07:01,520
infrastructure for compatibility and

176
00:07:01,520 --> 00:07:04,720
stuff you end up for instance allocating

177
00:07:04,720 --> 00:07:06,639
many memory regions one for each of

178
00:07:06,639 --> 00:07:09,199
these actions of that executable or

179
00:07:09,199 --> 00:07:11,440
still the supporting component the

180
00:07:11,440 --> 00:07:13,440
emulator would be

181
00:07:13,440 --> 00:07:16,080
will be quite big not that big but big

182
00:07:16,080 --> 00:07:18,880
enough to be fingerprinted so this seems

183
00:07:18,880 --> 00:07:21,280
promising but there's still some work to

184
00:07:21,280 --> 00:07:24,000
do and in the meantime there's also

185
00:07:24,000 --> 00:07:24,960
another

186
00:07:24,960 --> 00:07:26,160
player

187
00:07:26,160 --> 00:07:29,199
here and it's the recent availability of

188
00:07:29,199 --> 00:07:30,960
exploit and

189
00:07:30,960 --> 00:07:33,759
malware hardening mitigations in windows

190
00:07:33,759 --> 00:07:35,280
10 so

191
00:07:35,280 --> 00:07:38,000
windows defender exploit guard wdag has

192
00:07:38,000 --> 00:07:40,160
a number of defenses these are system

193
00:07:40,160 --> 00:07:42,560
level defenses plus others that you can

194
00:07:42,560 --> 00:07:44,800
enable for specific applications so you

195
00:07:44,800 --> 00:07:47,759
can harden your applications against

196
00:07:47,759 --> 00:07:50,639
injection and other kind of attempts and

197
00:07:50,639 --> 00:07:53,759
uh so those are advertised as

198
00:07:53,759 --> 00:07:55,680
reducing the attack surface against next

199
00:07:55,680 --> 00:07:57,120
generation malware that's the way

200
00:07:57,120 --> 00:07:58,720
they're put on the

201
00:07:58,720 --> 00:08:01,599
on the microsoft uh security pages and

202
00:08:01,599 --> 00:08:03,280
they say you can use for instance

203
00:08:03,280 --> 00:08:04,960
arbitrary code guard

204
00:08:04,960 --> 00:08:06,879
in a way that the process will not be

205
00:08:06,879 --> 00:08:09,120
able to allocate or modify executable

206
00:08:09,120 --> 00:08:11,759
memory or you can use code integrity

207
00:08:11,759 --> 00:08:14,400
guard which means that you can no longer

208
00:08:14,400 --> 00:08:17,440
load a code module like a dll unless

209
00:08:17,440 --> 00:08:20,560
it's signed digitally signed then you

210
00:08:20,560 --> 00:08:22,960
have some measures that are specific to

211
00:08:22,960 --> 00:08:25,840
break how the injected payloads work so

212
00:08:25,840 --> 00:08:27,680
typically when you have a shell code or

213
00:08:27,680 --> 00:08:28,639
any other

214
00:08:28,639 --> 00:08:30,479
injected payload you have to start

215
00:08:30,479 --> 00:08:33,120
looking up the apis you need to look up

216
00:08:33,120 --> 00:08:36,000
api addresses and you sk you will parse

217
00:08:36,000 --> 00:08:38,799
the export or import address table with

218
00:08:38,799 --> 00:08:40,958
these defenses you you will intercept

219
00:08:40,958 --> 00:08:43,839
those attempts and kill the execution so

220
00:08:43,839 --> 00:08:45,040
um

221
00:08:45,040 --> 00:08:47,839
i mean the what we we explored in our

222
00:08:47,839 --> 00:08:49,680
research is like how can we still

223
00:08:49,680 --> 00:08:51,360
achieve a distributed malware

224
00:08:51,360 --> 00:08:54,080
obstruction that will meet real world

225
00:08:54,080 --> 00:08:56,800
constraints or will work under even in

226
00:08:56,800 --> 00:08:58,080
the presence of those hardening

227
00:08:58,080 --> 00:09:00,480
mitigations and still deceive honey vr

228
00:09:00,480 --> 00:09:03,600
dr uh we didn't want to

229
00:09:03,600 --> 00:09:06,080
tie the design too much to a specific

230
00:09:06,080 --> 00:09:08,240
delivery primitive so a specific code

231
00:09:08,240 --> 00:09:10,160
injection technique so we want to be

232
00:09:10,160 --> 00:09:12,320
flexible in a way that we can even work

233
00:09:12,320 --> 00:09:14,959
with processes that we create or we can

234
00:09:14,959 --> 00:09:16,959
just leverage the best injection that

235
00:09:16,959 --> 00:09:19,600
you have in that moment in time

236
00:09:19,600 --> 00:09:22,560
and we also want to have a very small uh

237
00:09:22,560 --> 00:09:24,720
runtime component to support this

238
00:09:24,720 --> 00:09:28,160
distributed execution we want to comply

239
00:09:28,160 --> 00:09:30,720
with this uh mitigations of wdag you

240
00:09:30,720 --> 00:09:32,240
know windows and

241
00:09:32,240 --> 00:09:35,120
another thing that is about in-memory

242
00:09:35,120 --> 00:09:37,680
inspection so we want to keep code and

243
00:09:37,680 --> 00:09:40,640
data hidden from an anti-virus or adr as

244
00:09:40,640 --> 00:09:42,480
much as possible even if they start

245
00:09:42,480 --> 00:09:44,320
scanning our memory

246
00:09:44,320 --> 00:09:46,640
so what we did is we came up with this

247
00:09:46,640 --> 00:09:49,360
idea of rob it's a return-oriented

248
00:09:49,360 --> 00:09:51,440
programming based distributed driven

249
00:09:51,440 --> 00:09:52,640
execution

250
00:09:52,640 --> 00:09:53,600
um

251
00:09:53,600 --> 00:09:56,480
so with written oriented programming we

252
00:09:56,480 --> 00:09:59,920
actually uh no longer need to inject any

253
00:09:59,920 --> 00:10:01,680
code we don't know we don't modify

254
00:10:01,680 --> 00:10:04,480
executable memory and

255
00:10:04,480 --> 00:10:06,240
also we get around some of the

256
00:10:06,240 --> 00:10:08,560
mitigations of wdag which they are not

257
00:10:08,560 --> 00:10:11,120
meant to handle this kind of

258
00:10:11,120 --> 00:10:13,440
rope based encodings and we use

259
00:10:13,440 --> 00:10:15,839
transactional and tfs to build an

260
00:10:15,839 --> 00:10:18,079
unrespectable cover channel that we use

261
00:10:18,079 --> 00:10:20,240
for both sharing the payload and for

262
00:10:20,240 --> 00:10:21,920
orchestrating the

263
00:10:21,920 --> 00:10:24,160
execution and communications in more

264
00:10:24,160 --> 00:10:26,399
detail written oriented programming uh

265
00:10:26,399 --> 00:10:28,320
which i assume you're familiar with but

266
00:10:28,320 --> 00:10:29,920
it's an exploitation technique

267
00:10:29,920 --> 00:10:33,760
originally and then involved in a way of

268
00:10:33,760 --> 00:10:36,880
encoding an arbitrary payload by reusing

269
00:10:36,880 --> 00:10:38,480
code that is already present in a

270
00:10:38,480 --> 00:10:41,440
process so what we do is we borrow rob

271
00:10:41,440 --> 00:10:44,160
gadgets from some code module that all

272
00:10:44,160 --> 00:10:46,800
these victim processes that we use they

273
00:10:46,800 --> 00:10:49,680
will have this mod module already loaded

274
00:10:49,680 --> 00:10:50,480
and

275
00:10:50,480 --> 00:10:52,800
by doing so with sidestep the need of

276
00:10:52,800 --> 00:10:55,920
using writable and executable memory

277
00:10:55,920 --> 00:10:59,279
transactional ntfs is a bit

278
00:10:59,279 --> 00:11:02,399
different uh it works like by turning

279
00:11:02,399 --> 00:11:04,959
your file system into a database you can

280
00:11:04,959 --> 00:11:07,600
take a file and you can decide to

281
00:11:07,600 --> 00:11:10,480
to make transient changes to this to the

282
00:11:10,480 --> 00:11:13,360
contents of this file and only processes

283
00:11:13,360 --> 00:11:15,519
that have a handle to the transaction at

284
00:11:15,519 --> 00:11:18,480
txf handle can see those trends and

285
00:11:18,480 --> 00:11:21,200
changes that you you make any other

286
00:11:21,200 --> 00:11:24,240
process including an antivirus or adr

287
00:11:24,240 --> 00:11:26,399
won't be able to see this because this

288
00:11:26,399 --> 00:11:29,040
this contents they don't even reside on

289
00:11:29,040 --> 00:11:31,040
disk they will stay in the memory of the

290
00:11:31,040 --> 00:11:33,440
kernel so it's it's difficult to inspect

291
00:11:33,440 --> 00:11:36,240
what's going on within a transaction

292
00:11:36,240 --> 00:11:38,800
unless you're part of the transaction so

293
00:11:38,800 --> 00:11:41,519
we put this together and uh we came up

294
00:11:41,519 --> 00:11:44,399
with this design where we have another

295
00:11:44,399 --> 00:11:46,959
component that will select a number of

296
00:11:46,959 --> 00:11:49,200
victim processes to abuse

297
00:11:49,200 --> 00:11:50,800
and will inject

298
00:11:50,800 --> 00:11:53,680
a small runtime component the bootstrap

299
00:11:53,680 --> 00:11:54,800
component

300
00:11:54,800 --> 00:11:57,040
who is responsible for a bunch of things

301
00:11:57,040 --> 00:11:59,519
but most importantly uh supporting the

302
00:11:59,519 --> 00:12:01,839
execution of this payload malicious

303
00:12:01,839 --> 00:12:04,160
payload in a distributed fashion

304
00:12:04,160 --> 00:12:06,959
the payload becomes a sequence of chunks

305
00:12:06,959 --> 00:12:09,600
each chunk is a rope chain and the chunk

306
00:12:09,600 --> 00:12:12,160
can be executed

307
00:12:12,160 --> 00:12:15,360
in its entirety by a victim process

308
00:12:15,360 --> 00:12:17,360
the chunks are placed in a transacted

309
00:12:17,360 --> 00:12:20,560
file the rob txf along with a

310
00:12:20,560 --> 00:12:22,240
bunch of other

311
00:12:22,240 --> 00:12:23,120
fields

312
00:12:23,120 --> 00:12:25,360
and now i will hand over the mic to

313
00:12:25,360 --> 00:12:27,120
lorenzo who will be covering all the

314
00:12:27,120 --> 00:12:29,279
nice implementation details behind this

315
00:12:29,279 --> 00:12:33,200
and the drop txf

316
00:12:36,160 --> 00:12:38,160
so thank you daniela now let's see the

317
00:12:38,160 --> 00:12:40,320
details of our architecture

318
00:12:40,320 --> 00:12:42,079
so we will start from the loader

319
00:12:42,079 --> 00:12:44,000
component and the

320
00:12:44,000 --> 00:12:46,160
component is in charge of selecting the

321
00:12:46,160 --> 00:12:48,800
evicting processes and here as an

322
00:12:48,800 --> 00:12:50,560
attacker you may want to choose some

323
00:12:50,560 --> 00:12:52,240
principle for instance choosing

324
00:12:52,240 --> 00:12:54,279
processes that has similar

325
00:12:54,279 --> 00:12:57,519
characteristics to what on

326
00:12:57,519 --> 00:12:59,279
your malware payload

327
00:12:59,279 --> 00:13:02,399
so the other task of this component is

328
00:13:02,399 --> 00:13:05,120
to choose create or open an existing

329
00:13:05,120 --> 00:13:08,560
file in a transaction erase its content

330
00:13:08,560 --> 00:13:11,360
and add your content along with chains

331
00:13:11,360 --> 00:13:14,000
and metadata you need and then you

332
00:13:14,000 --> 00:13:16,320
duplicate basically the transaction

333
00:13:16,320 --> 00:13:18,800
handle to the victims so to allow them

334
00:13:18,800 --> 00:13:20,560
access to the file

335
00:13:20,560 --> 00:13:23,680
and last task of the loader is to inject

336
00:13:23,680 --> 00:13:25,920
of the the bootstrap component to the

337
00:13:25,920 --> 00:13:27,279
victim

338
00:13:27,279 --> 00:13:30,000
so the bootstrap component is the main

339
00:13:30,000 --> 00:13:33,200
is the core of rop and estas

340
00:13:33,200 --> 00:13:34,399
are to

341
00:13:34,399 --> 00:13:37,279
make the victims to load the

342
00:13:37,279 --> 00:13:40,000
the transaction the transacted file and

343
00:13:40,000 --> 00:13:42,959
schedule the execution of the wrap code

344
00:13:42,959 --> 00:13:44,720
while providing some sort of

345
00:13:44,720 --> 00:13:47,920
coordination with other unit in case is

346
00:13:47,920 --> 00:13:52,800
needed and last task is to solve the api

347
00:13:52,800 --> 00:13:55,120
so when setting the europtxf file this

348
00:13:55,120 --> 00:13:57,760
file is shared among the victim and here

349
00:13:57,760 --> 00:14:00,959
is where our payload will reside and

350
00:14:00,959 --> 00:14:03,440
this payload is basically organized in

351
00:14:03,440 --> 00:14:04,399
chunks

352
00:14:04,399 --> 00:14:07,760
and these chunks are executed in turn to

353
00:14:07,760 --> 00:14:10,639
from the victim you want to select

354
00:14:10,639 --> 00:14:13,199
and in this file is also contain the

355
00:14:13,199 --> 00:14:16,160
program memory so if global variables

356
00:14:16,160 --> 00:14:18,880
and handles and this file these files

357
00:14:18,880 --> 00:14:21,519
also contain basically an adder where we

358
00:14:21,519 --> 00:14:24,079
all the past executor and the next block

359
00:14:24,079 --> 00:14:27,120
to to execute

360
00:14:28,880 --> 00:14:31,279
so this this design brings us some

361
00:14:31,279 --> 00:14:34,639
advantages we don't need to allocate or

362
00:14:34,639 --> 00:14:37,920
modify executable memory we just have

363
00:14:37,920 --> 00:14:41,199
one single shared medium for both code

364
00:14:41,199 --> 00:14:42,399
and data

365
00:14:42,399 --> 00:14:45,199
and so now we can comply with the two

366
00:14:45,199 --> 00:14:48,240
mitigation wdag arbitrary code guard and

367
00:14:48,240 --> 00:14:50,160
code integrity guard

368
00:14:50,160 --> 00:14:51,360
and now

369
00:14:51,360 --> 00:14:54,560
the inspection is harder for a security

370
00:14:54,560 --> 00:14:56,959
solution like any v or adr since in the

371
00:14:56,959 --> 00:15:00,000
end what what this software will find is

372
00:15:00,000 --> 00:15:02,560
just a bunch of gadget addresses and

373
00:15:02,560 --> 00:15:05,680
data but definitely not called since of

374
00:15:05,680 --> 00:15:07,839
the level of indirection

375
00:15:07,839 --> 00:15:10,880
thanks to the robot design

376
00:15:10,880 --> 00:15:13,199
so concerning the execution we designed

377
00:15:13,199 --> 00:15:16,000
two execution modes the first is called

378
00:15:16,000 --> 00:15:18,320
we called continuous where basically any

379
00:15:18,320 --> 00:15:21,279
victim can execute any junk in any order

380
00:15:21,279 --> 00:15:24,240
but here an explicit coordination is

381
00:15:24,240 --> 00:15:25,440
needed

382
00:15:25,440 --> 00:15:27,680
while in the second execution mode we

383
00:15:27,680 --> 00:15:29,120
call staged

384
00:15:29,120 --> 00:15:32,240
where you can take a sequence of chunks

385
00:15:32,240 --> 00:15:34,959
and select a specific victim to run

386
00:15:34,959 --> 00:15:37,120
these chunks and here the coordination

387
00:15:37,120 --> 00:15:39,920
can be provided by rob itself or by your

388
00:15:39,920 --> 00:15:43,440
malware for instance this scenario is

389
00:15:43,440 --> 00:15:44,880
adapted for

390
00:15:44,880 --> 00:15:47,839
a the need in for instance in a download

391
00:15:47,839 --> 00:15:50,800
and execute scenario you may want to

392
00:15:50,800 --> 00:15:53,519
select a browser to perform the

393
00:15:53,519 --> 00:15:56,079
downloading part while delegating the

394
00:15:56,079 --> 00:16:00,240
execution part to another process

395
00:16:00,240 --> 00:16:01,040
so

396
00:16:01,040 --> 00:16:02,399
how we did it

397
00:16:02,399 --> 00:16:05,440
we have to talk about some challenges we

398
00:16:05,440 --> 00:16:06,959
struggle with

399
00:16:06,959 --> 00:16:09,519
and we start we are going to start

400
00:16:09,519 --> 00:16:12,000
talking about the delivering of the

401
00:16:12,000 --> 00:16:15,279
bootstrap component to each victim and

402
00:16:15,279 --> 00:16:17,360
at the same time we need to talk about

403
00:16:17,360 --> 00:16:20,320
how to find suitable gadgets

404
00:16:20,320 --> 00:16:23,120
and at the same time obviously we want

405
00:16:23,120 --> 00:16:26,160
to con we want to comply with the wdag

406
00:16:26,160 --> 00:16:27,440
mitigation

407
00:16:27,440 --> 00:16:31,360
we did it with two bypasses

408
00:16:31,360 --> 00:16:32,880
so we will start from the injection

409
00:16:32,880 --> 00:16:35,519
stage so we have to deliver the

410
00:16:35,519 --> 00:16:39,040
bootstrap component to the victims and

411
00:16:39,040 --> 00:16:41,680
also we need a shared source where we

412
00:16:41,680 --> 00:16:43,839
can take gadgets

413
00:16:43,839 --> 00:16:46,399
and in doing all of this we have some

414
00:16:46,399 --> 00:16:49,440
restrictions we want to only use and

415
00:16:49,440 --> 00:16:52,320
load only signed modules

416
00:16:52,320 --> 00:16:54,880
we don't want you know any conspicuous

417
00:16:54,880 --> 00:16:56,880
memory region that may trigger an

418
00:16:56,880 --> 00:16:59,279
analyst we don't want any read write

419
00:16:59,279 --> 00:17:02,000
executable pages and obviously we don't

420
00:17:02,000 --> 00:17:05,119
want to spook nav or adr install it on

421
00:17:05,119 --> 00:17:07,359
the target machine

422
00:17:07,359 --> 00:17:10,959
so we saw in the phantom dll wing has a

423
00:17:10,959 --> 00:17:13,599
suitable method for take two birds with

424
00:17:13,599 --> 00:17:14,799
one stones

425
00:17:14,799 --> 00:17:18,000
and basically we have a dll and those in

426
00:17:18,000 --> 00:17:20,000
this dll we can

427
00:17:20,000 --> 00:17:23,280
make we we can place our gadgets

428
00:17:23,280 --> 00:17:25,839
uh at the same time we can place also

429
00:17:25,839 --> 00:17:28,160
our bootstrap component

430
00:17:28,160 --> 00:17:30,400
and this component can basically written

431
00:17:30,400 --> 00:17:32,880
as rope as well or you can simply put in

432
00:17:32,880 --> 00:17:34,640
the text section

433
00:17:34,640 --> 00:17:38,240
and what the phantom dell wing do is to

434
00:17:38,240 --> 00:17:42,480
actually take a signed dll or ndl

435
00:17:42,480 --> 00:17:46,000
open it in a transaction modify their

436
00:17:46,000 --> 00:17:49,039
content with your content and then force

437
00:17:49,039 --> 00:17:52,240
the victim to map the dll you just

438
00:17:52,240 --> 00:17:53,440
always

439
00:17:53,440 --> 00:17:56,080
so the problem here is that

440
00:17:56,080 --> 00:17:59,440
this behavior is pretty known by

441
00:17:59,440 --> 00:18:02,880
nav and state of the art in the earth so

442
00:18:02,880 --> 00:18:06,400
we don't consider it this as scenario

443
00:18:06,400 --> 00:18:07,840
and

444
00:18:07,840 --> 00:18:08,799
then

445
00:18:08,799 --> 00:18:10,880
if you try to

446
00:18:10,880 --> 00:18:14,559
lo until do make the victim to try to

447
00:18:14,559 --> 00:18:16,880
create the section on their own

448
00:18:16,880 --> 00:18:19,039
they called to integrate section we

449
00:18:19,039 --> 00:18:22,240
failed with status invalid image

450
00:18:22,240 --> 00:18:25,120
in a protected victim that is a victim

451
00:18:25,120 --> 00:18:28,880
that has code integrity guard enabled

452
00:18:28,880 --> 00:18:32,640
so how to do that well our bypass will

453
00:18:32,640 --> 00:18:36,080
look like this we still open a sign the

454
00:18:36,080 --> 00:18:39,600
lsn module in a transaction and we

455
00:18:39,600 --> 00:18:43,120
create and we modified the content with

456
00:18:43,120 --> 00:18:46,160
our content so we create section from

457
00:18:46,160 --> 00:18:47,520
the loader

458
00:18:47,520 --> 00:18:50,160
and then we duplicate the handle the the

459
00:18:50,160 --> 00:18:52,480
transaction handle along with the needed

460
00:18:52,480 --> 00:18:54,240
handles to the victims

461
00:18:54,240 --> 00:18:56,799
and we basically inject a rock chain on

462
00:18:56,799 --> 00:18:58,240
the victim step

463
00:18:58,240 --> 00:19:00,640
so coming to the details what we are

464
00:19:00,640 --> 00:19:01,679
going to

465
00:19:01,679 --> 00:19:04,720
do is to hijack for a moment the

466
00:19:04,720 --> 00:19:07,360
execution of the thread in the victims

467
00:19:07,360 --> 00:19:09,919
injecting aware of chain and what this

468
00:19:09,919 --> 00:19:12,640
robbed chain does you can see that save

469
00:19:12,640 --> 00:19:15,679
the code here is to call the prepare the

470
00:19:15,679 --> 00:19:18,720
arguments and call intimacy section

471
00:19:18,720 --> 00:19:21,440
so upon the return we basically parse

472
00:19:21,440 --> 00:19:24,000
the return parameter and then we have

473
00:19:24,000 --> 00:19:26,799
the section base for which we add the

474
00:19:26,799 --> 00:19:29,600
entry point of the payload and the trick

475
00:19:29,600 --> 00:19:30,960
here is that

476
00:19:30,960 --> 00:19:32,720
when the payload when the boots up

477
00:19:32,720 --> 00:19:36,160
component start executing it just

478
00:19:36,160 --> 00:19:39,039
create an internal thread and returns

479
00:19:39,039 --> 00:19:42,000
immediately so that the rock chain will

480
00:19:42,000 --> 00:19:44,640
take over again and call the nt continue

481
00:19:44,640 --> 00:19:49,840
to restore the execution we just eject

482
00:19:49,840 --> 00:19:50,720
so

483
00:19:50,720 --> 00:19:54,720
doing this bring us some benefits

484
00:19:54,720 --> 00:19:57,600
we can actually make the victim to spawn

485
00:19:57,600 --> 00:20:00,000
the payload with an internal tread and

486
00:20:00,000 --> 00:20:02,640
there is no need of creating a remote

487
00:20:02,640 --> 00:20:06,000
tread and with this technique we can be

488
00:20:06,000 --> 00:20:08,559
we can just have a shared medium that

489
00:20:08,559 --> 00:20:09,440
holds

490
00:20:09,440 --> 00:20:12,000
our gadgets alongside with the bootstrap

491
00:20:12,000 --> 00:20:14,559
component so that if you don't don't

492
00:20:14,559 --> 00:20:16,159
want to look up

493
00:20:16,159 --> 00:20:17,919
the gadget

494
00:20:17,919 --> 00:20:20,559
you can add your custom gadgets in here

495
00:20:20,559 --> 00:20:21,840
we have that

496
00:20:21,840 --> 00:20:22,640
so

497
00:20:22,640 --> 00:20:26,000
this bypass is just an implementation

498
00:20:26,000 --> 00:20:29,679
shortcut but rob can actually work with

499
00:20:29,679 --> 00:20:33,120
other injection techniques

500
00:20:33,120 --> 00:20:35,840
so we just addressed the first two

501
00:20:35,840 --> 00:20:38,159
challenges now obviously we want to

502
00:20:38,159 --> 00:20:41,520
comply also with the wdeg mitigation

503
00:20:41,520 --> 00:20:42,480
and

504
00:20:42,480 --> 00:20:44,240
our chunks are

505
00:20:44,240 --> 00:20:47,679
rob based so we have to comply otherwise

506
00:20:47,679 --> 00:20:49,360
about those mitigation and this

507
00:20:49,360 --> 00:20:52,080
mitigation basically are the stack pivot

508
00:20:52,080 --> 00:20:54,880
which basically validate if monitored

509
00:20:54,880 --> 00:20:56,640
and look at the pi call

510
00:20:56,640 --> 00:20:58,480
is happening from the native stack of

511
00:20:58,480 --> 00:21:00,960
the application while color check sim

512
00:21:00,960 --> 00:21:03,600
exec basically works in the same manner

513
00:21:03,600 --> 00:21:06,080
they basically validate the calling site

514
00:21:06,080 --> 00:21:08,000
in the return site

515
00:21:08,000 --> 00:21:10,799
so for this tech pivot we simply make

516
00:21:10,799 --> 00:21:12,480
the call from the

517
00:21:12,480 --> 00:21:14,559
native stack we basically load the

518
00:21:14,559 --> 00:21:16,880
argument from the call and upon the

519
00:21:16,880 --> 00:21:17,919
return

520
00:21:17,919 --> 00:21:21,360
we jump back to our rockchain

521
00:21:21,360 --> 00:21:22,240
so

522
00:21:22,240 --> 00:21:24,320
concerning instead the color check and

523
00:21:24,320 --> 00:21:26,640
sim exec there are some options some

524
00:21:26,640 --> 00:21:29,440
documented option you can use the some

525
00:21:29,440 --> 00:21:31,360
techniques like the right of passage

526
00:21:31,360 --> 00:21:33,039
that is the techniques

527
00:21:33,039 --> 00:21:35,760
presented the defcon some years ago or

528
00:21:35,760 --> 00:21:38,640
you can use some custom long gadgets

529
00:21:38,640 --> 00:21:42,159
that breaks their now the analysis or

530
00:21:42,159 --> 00:21:44,480
last option is to actually

531
00:21:44,480 --> 00:21:47,440
code your the okay api from the text

532
00:21:47,440 --> 00:21:50,480
section of the the all the way dll

533
00:21:50,480 --> 00:21:52,880
we noticed that at least

534
00:21:52,880 --> 00:21:56,240
in windows 10 the wdag

535
00:21:56,240 --> 00:21:58,880
totally ignores the anti-mapping section

536
00:21:58,880 --> 00:22:03,200
that we use in our first bypassed

537
00:22:03,600 --> 00:22:06,799
so i mean writing a wrap code may be

538
00:22:06,799 --> 00:22:09,840
funny but we desired some automation all

539
00:22:09,840 --> 00:22:12,480
that wise this doesn't scale

540
00:22:12,480 --> 00:22:15,360
so there are some tools that are meant

541
00:22:15,360 --> 00:22:18,720
for exploit but they don't suit well the

542
00:22:18,720 --> 00:22:20,559
rock programming

543
00:22:20,559 --> 00:22:23,679
so what we did is to actually use a

544
00:22:23,679 --> 00:22:26,559
standard microsoft visual c compiler

545
00:22:26,559 --> 00:22:29,440
turning out some optimization and canary

546
00:22:29,440 --> 00:22:30,480
checks

547
00:22:30,480 --> 00:22:33,840
and basically we obtain an output that

548
00:22:33,840 --> 00:22:36,480
is similar to a shell code as a

549
00:22:36,480 --> 00:22:38,240
simplified design

550
00:22:38,240 --> 00:22:40,880
then we don't want to ruin the stack

551
00:22:40,880 --> 00:22:43,760
since we have the chain so we promote we

552
00:22:43,760 --> 00:22:46,159
are going to promote all stack variables

553
00:22:46,159 --> 00:22:48,880
to global variables and these global

554
00:22:48,880 --> 00:22:51,840
versables will become part of a single

555
00:22:51,840 --> 00:22:54,400
bit data structure that you can access

556
00:22:54,400 --> 00:22:57,200
so when you need some variables you can

557
00:22:57,200 --> 00:22:59,120
calculate the displacement from the

558
00:22:59,120 --> 00:23:01,919
start address of this structure so we

559
00:23:01,919 --> 00:23:05,360
obtain a simplified output for which we

560
00:23:05,360 --> 00:23:08,720
can look up some basic blocks and these

561
00:23:08,720 --> 00:23:12,559
blocks will become our chunks built with

562
00:23:12,559 --> 00:23:15,360
suitable gadget that you want to look up

563
00:23:15,360 --> 00:23:18,720
or borrow from the ones we we can put in

564
00:23:18,720 --> 00:23:20,640
the in our dll

565
00:23:20,640 --> 00:23:24,000
the future work is to use a recently

566
00:23:24,000 --> 00:23:26,559
available tool that is raindrop for

567
00:23:26,559 --> 00:23:29,919
fully automatic rope binary writing

568
00:23:29,919 --> 00:23:31,760
there are some fixes to do like

569
00:23:31,760 --> 00:23:34,320
supporting portable executable since

570
00:23:34,320 --> 00:23:37,919
it's for linux but it's very promising

571
00:23:37,919 --> 00:23:40,880
so last challenge is actually the lookup

572
00:23:40,880 --> 00:23:43,919
of apis in an arduino victim for which

573
00:23:43,919 --> 00:23:47,440
we came up with a bypass

574
00:23:47,440 --> 00:23:48,799
so the

575
00:23:48,799 --> 00:23:51,200
api are needed both in the bootstrap

576
00:23:51,200 --> 00:23:53,760
component and in your chunks you want to

577
00:23:53,760 --> 00:23:57,440
let your malware use any sort of apis

578
00:23:57,440 --> 00:24:00,960
um any sort of apis so

579
00:24:00,960 --> 00:24:04,559
what you do then is you can actually use

580
00:24:04,559 --> 00:24:07,840
the get procadus but this may be

581
00:24:07,840 --> 00:24:08,559
by

582
00:24:08,559 --> 00:24:10,640
security solution so we don't consider

583
00:24:10,640 --> 00:24:12,080
it as an option

584
00:24:12,080 --> 00:24:14,080
another possibility is to actually

585
00:24:14,080 --> 00:24:17,520
bringing the api addresses from the

586
00:24:17,520 --> 00:24:20,640
loader but i mean this is suspicious and

587
00:24:20,640 --> 00:24:23,520
you will give away a lot of information

588
00:24:23,520 --> 00:24:25,360
so what an attacker will do is to

589
00:24:25,360 --> 00:24:27,200
actually start

590
00:24:27,200 --> 00:24:28,960
programming their

591
00:24:28,960 --> 00:24:32,480
their solving routine to solve the api

592
00:24:32,480 --> 00:24:35,279
but there are wdag defenses in place

593
00:24:35,279 --> 00:24:37,279
that break those codes and those

594
00:24:37,279 --> 00:24:40,400
defenses uh export and import this

595
00:24:40,400 --> 00:24:42,880
filtering and they work in a similar

596
00:24:42,880 --> 00:24:46,000
manner they basically monitor access to

597
00:24:46,000 --> 00:24:49,840
the export and import other stables in

598
00:24:49,840 --> 00:24:53,120
modules by using a guard page so when

599
00:24:53,120 --> 00:24:55,760
your code try to access those memory the

600
00:24:55,760 --> 00:24:58,240
microsoft exception handle will kicks in

601
00:24:58,240 --> 00:25:00,320
and validate the access if it will

602
00:25:00,320 --> 00:25:03,440
happen from a legit module or not

603
00:25:03,440 --> 00:25:05,919
so how to do then

604
00:25:05,919 --> 00:25:09,200
you will use bypasses we basically

605
00:25:09,200 --> 00:25:12,400
locate locate inside the legit main

606
00:25:12,400 --> 00:25:15,679
module an arbitrary read or arbitrary

607
00:25:15,679 --> 00:25:17,120
write gadgets

608
00:25:17,120 --> 00:25:19,600
in based on what you need

609
00:25:19,600 --> 00:25:22,720
and we use these gadgets in our read

610
00:25:22,720 --> 00:25:25,120
primitive or write primitive so that

611
00:25:25,120 --> 00:25:27,200
when the exception handle kicks in will

612
00:25:27,200 --> 00:25:29,679
validate the access since the memory

613
00:25:29,679 --> 00:25:31,679
when with reference memory it will the

614
00:25:31,679 --> 00:25:33,679
code will will be happening from the

615
00:25:33,679 --> 00:25:35,600
legitimate mode for instance in the

616
00:25:35,600 --> 00:25:39,600
slide there is a gadget from kernel 32

617
00:25:39,600 --> 00:25:43,639
and now let's back to daniella

618
00:25:46,159 --> 00:25:48,400
so now we have to convince you that this

619
00:25:48,400 --> 00:25:51,600
also actually weights av and ddrs and so

620
00:25:51,600 --> 00:25:54,240
we tested 10 security solutions state of

621
00:25:54,240 --> 00:25:57,440
the art we tested six anti-viruses and

622
00:25:57,440 --> 00:26:00,080
six uh sorry four edrs

623
00:26:00,080 --> 00:26:02,799
we we consider a windows 10

624
00:26:02,799 --> 00:26:04,880
at the time was january

625
00:26:04,880 --> 00:26:07,840
yeah january 2021 build

626
00:26:07,840 --> 00:26:10,000
with all the system level but this still

627
00:26:10,000 --> 00:26:12,799
works it hasn't been fixed

628
00:26:12,799 --> 00:26:14,720
so if we consider all the defaults

629
00:26:14,720 --> 00:26:16,559
mitigations that you have system levels

630
00:26:16,559 --> 00:26:19,039
or your aslr all the

631
00:26:19,039 --> 00:26:21,360
patients um that execution prevention

632
00:26:21,360 --> 00:26:23,520
then we enabled for the victim

633
00:26:23,520 --> 00:26:25,679
applications all the opt-in wdeg

634
00:26:25,679 --> 00:26:28,400
hardening measures for arbitrary code

635
00:26:28,400 --> 00:26:30,240
guard called integrity guard and the

636
00:26:30,240 --> 00:26:32,000
expert import address filtering and the

637
00:26:32,000 --> 00:26:33,200
rope ones

638
00:26:33,200 --> 00:26:36,960
we um we test payloads that if you run

639
00:26:36,960 --> 00:26:39,279
them like as a standalone sample they

640
00:26:39,279 --> 00:26:41,679
will trigger all of these solutions so

641
00:26:41,679 --> 00:26:44,559
we try to see if writing them erop

642
00:26:44,559 --> 00:26:48,159
so you i mean gives you a free evasion

643
00:26:48,159 --> 00:26:50,080
and we also run a comparison with a

644
00:26:50,080 --> 00:26:52,159
state-of-the-art solution that uses

645
00:26:52,159 --> 00:26:53,840
injection technique traditional

646
00:26:53,840 --> 00:26:55,760
injection techniques for achieving a

647
00:26:55,760 --> 00:26:58,320
distributed execution

648
00:26:58,320 --> 00:27:00,480
more details the wdeg mitigations we

649
00:27:00,480 --> 00:27:02,799
tested them in audit mode we wanted to

650
00:27:02,799 --> 00:27:04,360
figure out when they were

651
00:27:04,360 --> 00:27:06,960
incompatibilities or they were spurious

652
00:27:06,960 --> 00:27:09,760
traces which were not caused by us so

653
00:27:09,760 --> 00:27:11,600
there were a couple of incompatibilities

654
00:27:11,600 --> 00:27:14,400
that we found out and we reported

655
00:27:14,400 --> 00:27:16,240
as victims we choose off the shelf

656
00:27:16,240 --> 00:27:18,559
productivity program so like your

657
00:27:18,559 --> 00:27:21,600
browser your dropbox telegram client

658
00:27:21,600 --> 00:27:23,520
this kind of like

659
00:27:23,520 --> 00:27:26,399
real world applications and we we test

660
00:27:26,399 --> 00:27:29,120
with only two processes because it's uh

661
00:27:29,120 --> 00:27:31,360
it's the most challenging setting where

662
00:27:31,360 --> 00:27:33,279
you have only two victims to spread your

663
00:27:33,279 --> 00:27:36,000
actions and we test two scenarios so we

664
00:27:36,000 --> 00:27:37,520
have one proof of concept for each

665
00:27:37,520 --> 00:27:39,840
scenario the first is for the continuous

666
00:27:39,840 --> 00:27:42,080
execution mode where any victim can

667
00:27:42,080 --> 00:27:45,120
execute any chunk and with the with this

668
00:27:45,120 --> 00:27:47,600
uh with this book we just

669
00:27:47,600 --> 00:27:49,840
persistent scenario so like where the

670
00:27:49,840 --> 00:27:51,279
malware sample tries to achieve

671
00:27:51,279 --> 00:27:54,559
persistence the other one

672
00:27:54,559 --> 00:27:57,840
exercises the staged execution so in

673
00:27:57,840 --> 00:28:00,159
this case we are simulating at the load

674
00:28:00,159 --> 00:28:02,559
and execute scenario there's one process

675
00:28:02,559 --> 00:28:04,159
uh one victim

676
00:28:04,159 --> 00:28:06,640
and it's a network active process like

677
00:28:06,640 --> 00:28:08,799
the browser will download a powershell

678
00:28:08,799 --> 00:28:11,520
script and then another process will

679
00:28:11,520 --> 00:28:14,399
execute this script all done with their

680
00:28:14,399 --> 00:28:17,200
respective chunks um so

681
00:28:17,200 --> 00:28:19,039
the result is no mitigation was

682
00:28:19,039 --> 00:28:21,760
triggered so we did our our own work

683
00:28:21,760 --> 00:28:24,000
well and in terms of evasion of

684
00:28:24,000 --> 00:28:27,279
behavioral analysis for eight products

685
00:28:27,279 --> 00:28:29,679
this would work just out of the box for

686
00:28:29,679 --> 00:28:32,880
two products we we saw that our loader

687
00:28:32,880 --> 00:28:35,279
couldn't complete its work the reason is

688
00:28:35,279 --> 00:28:37,279
that those processes sorry those

689
00:28:37,279 --> 00:28:39,360
solutions in the early stages of the

690
00:28:39,360 --> 00:28:42,159
execution they will just make some apis

691
00:28:42,159 --> 00:28:44,399
fail so like open process you want to

692
00:28:44,399 --> 00:28:46,320
open a process you have the rights to do

693
00:28:46,320 --> 00:28:48,880
so but you got the knight same thing if

694
00:28:48,880 --> 00:28:51,039
you want to duplicate the handle you get

695
00:28:51,039 --> 00:28:53,679
a broken handle in return this is a well

696
00:28:53,679 --> 00:28:55,919
studied problem it's not a detection but

697
00:28:55,919 --> 00:28:58,480
it's an um we can call it an emulation

698
00:28:58,480 --> 00:29:00,640
artifact of what happens in a beast

699
00:29:00,640 --> 00:29:03,200
that's uh there's a very nice paper uh

700
00:29:03,200 --> 00:29:05,120
which appeared in boot i think four

701
00:29:05,120 --> 00:29:07,120
years ago it's called av leak which

702
00:29:07,120 --> 00:29:08,960
documents this behavior and this

703
00:29:08,960 --> 00:29:12,320
behavior can be circumvented so

704
00:29:12,320 --> 00:29:14,080
this is not a real detection on the

705
00:29:14,080 --> 00:29:16,480
other hand when we tested the uh state

706
00:29:16,480 --> 00:29:18,480
of the earth solution that was detected

707
00:29:18,480 --> 00:29:22,000
by seven of the security products so we

708
00:29:22,000 --> 00:29:24,080
believe the results are interesting and

709
00:29:24,080 --> 00:29:27,440
promising and um so you might say okay

710
00:29:27,440 --> 00:29:29,679
so what what should i do to to stop your

711
00:29:29,679 --> 00:29:32,159
solution should i start i don't know

712
00:29:32,159 --> 00:29:35,120
um blocking you from using transactions

713
00:29:35,120 --> 00:29:37,679
or should i add some heuristic to detect

714
00:29:37,679 --> 00:29:40,000
return oriented programming so our

715
00:29:40,000 --> 00:29:42,000
feeling is that

716
00:29:42,000 --> 00:29:44,159
this is not a solution you should be

717
00:29:44,159 --> 00:29:45,600
looking for

718
00:29:45,600 --> 00:29:48,080
a comprehensive approach that will see

719
00:29:48,080 --> 00:29:50,080
distributed malware as a whole the

720
00:29:50,080 --> 00:29:51,840
reason is that this architecture is

721
00:29:51,840 --> 00:29:54,159
extensible you can just remove one piece

722
00:29:54,159 --> 00:29:55,840
and use a different one you can use a

723
00:29:55,840 --> 00:29:57,919
different code reuse primitive a

724
00:29:57,919 --> 00:30:00,000
different cover medium or if you say

725
00:30:00,000 --> 00:30:01,919
okay you're creating an internal thread

726
00:30:01,919 --> 00:30:03,679
fine you can use a different technique

727
00:30:03,679 --> 00:30:06,720
you can schedule an internal apc call

728
00:30:06,720 --> 00:30:08,399
which is not suspicious unlike the

729
00:30:08,399 --> 00:30:10,799
remote apc's you can eject your own

730
00:30:10,799 --> 00:30:12,720
import address table you can

731
00:30:12,720 --> 00:30:15,440
try many things and also this this kind

732
00:30:15,440 --> 00:30:17,600
of approach can be useful for

733
00:30:17,600 --> 00:30:19,840
implementing a truly fileless malware

734
00:30:19,840 --> 00:30:22,640
obstruction so what can you do then to

735
00:30:22,640 --> 00:30:25,279
defend yourselves um

736
00:30:25,279 --> 00:30:28,240
thing is to to make behavioral work uh

737
00:30:28,240 --> 00:30:30,880
you need to correlate those processes

738
00:30:30,880 --> 00:30:34,080
and see those processes as a whole

739
00:30:34,080 --> 00:30:36,640
to do that uh if you look at the

740
00:30:36,640 --> 00:30:38,720
execution units and you say okay this

741
00:30:38,720 --> 00:30:41,200
two might be related in in the end you

742
00:30:41,200 --> 00:30:43,840
you end up hitting the scalability world

743
00:30:43,840 --> 00:30:46,080
uh because it's it's not obvious to to

744
00:30:46,080 --> 00:30:48,399
see when you have to draw a line between

745
00:30:48,399 --> 00:30:50,960
these two processes they're correlated

746
00:30:50,960 --> 00:30:53,520
so and also to do so you have to keep

747
00:30:53,520 --> 00:30:55,360
track of every single injection that

748
00:30:55,360 --> 00:30:58,960
keeps appearing in down in that month um

749
00:30:58,960 --> 00:31:01,440
you won't get really far

750
00:31:01,440 --> 00:31:04,080
so what we we suggest instead is don't

751
00:31:04,080 --> 00:31:07,519
look at the execution flows like the

752
00:31:07,519 --> 00:31:09,360
control flow look at the data flow

753
00:31:09,360 --> 00:31:11,360
because every distributed abstraction

754
00:31:11,360 --> 00:31:13,360
will need to share objects we'll need to

755
00:31:13,360 --> 00:31:16,080
duplicate handles so if you follow the

756
00:31:16,080 --> 00:31:18,399
data the data trail then maybe you might

757
00:31:18,399 --> 00:31:20,640
be able to infer some better correlation

758
00:31:20,640 --> 00:31:22,880
strategies another thing that we will

759
00:31:22,880 --> 00:31:25,919
recommend would be to equip a vnddrs

760
00:31:25,919 --> 00:31:28,960
with uh techniques for understanding rob

761
00:31:28,960 --> 00:31:32,320
code the thing i mean there are now uh

762
00:31:32,320 --> 00:31:34,080
almost fully fledged

763
00:31:34,080 --> 00:31:35,760
writers and you can even write your

764
00:31:35,760 --> 00:31:38,080
standalone drop muller and you need

765
00:31:38,080 --> 00:31:39,600
something to analyze this code

766
00:31:39,600 --> 00:31:40,880
thankfully there are a couple of

767
00:31:40,880 --> 00:31:42,880
research prototypes out there so we

768
00:31:42,880 --> 00:31:45,039
believe this is something that will be

769
00:31:45,039 --> 00:31:47,279
will be nice to to having a security

770
00:31:47,279 --> 00:31:49,679
solution all right i hope that you

771
00:31:49,679 --> 00:31:52,000
enjoyed our research we are very glad

772
00:31:52,000 --> 00:31:54,640
and thank the organizer for having this

773
00:31:54,640 --> 00:31:56,960
opportunity to present our latest

774
00:31:56,960 --> 00:31:58,960
findings and thanks for your time we'll

775
00:31:58,960 --> 00:32:01,880
be happy to take questions

776
00:32:01,880 --> 00:32:07,350
[Applause]

777
00:32:07,350 --> 00:32:15,600
[Music]

778
00:32:15,600 --> 00:32:18,470
okay

779
00:32:18,470 --> 00:32:25,509
[Music]

