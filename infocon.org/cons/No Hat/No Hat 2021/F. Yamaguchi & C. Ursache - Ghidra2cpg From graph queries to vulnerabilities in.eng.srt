1
00:00:02,480 --> 00:00:05,260
uh

2
00:00:05,260 --> 00:00:08,500
[Music]

3
00:00:10,700 --> 00:00:21,039
[Music]

4
00:00:21,039 --> 00:00:24,039
me

5
00:00:24,410 --> 00:00:34,079
[Music]

6
00:00:36,000 --> 00:00:38,000
all right um yeah good morning everyone

7
00:00:38,000 --> 00:00:38,879
um

8
00:00:38,879 --> 00:00:41,200
very happy to be here um thank you marco

9
00:00:41,200 --> 00:00:42,800
for inviting us

10
00:00:42,800 --> 00:00:44,719
for me this is actually the first in

11
00:00:44,719 --> 00:00:47,440
person conference in uh two years so

12
00:00:47,440 --> 00:00:49,920
with a lockdown and all so it's just um

13
00:00:49,920 --> 00:00:51,600
yeah really nice to be doing something

14
00:00:51,600 --> 00:00:52,879
like this again

15
00:00:52,879 --> 00:00:54,640
um yeah so today we're going to be

16
00:00:54,640 --> 00:00:57,280
talking about guide to cpg

17
00:00:57,280 --> 00:01:00,160
and so this is all about creating graph

18
00:01:00,160 --> 00:01:02,640
queries that you can use to to find

19
00:01:02,640 --> 00:01:05,199
vulnerabilities in binary code

20
00:01:05,199 --> 00:01:06,080
and

21
00:01:06,080 --> 00:01:08,080
yeah i'm presenting today with claudio

22
00:01:08,080 --> 00:01:09,600
who's here

23
00:01:09,600 --> 00:01:11,040
and yeah

24
00:01:11,040 --> 00:01:13,200
nico who also works at our company he

25
00:01:13,200 --> 00:01:15,520
unfortunately is not here today but um

26
00:01:15,520 --> 00:01:16,479
yeah

27
00:01:16,479 --> 00:01:19,200
he did a lot of work um on this as well

28
00:01:19,200 --> 00:01:21,680
so i would just like to mention that

29
00:01:21,680 --> 00:01:23,840
um yeah a few words about

30
00:01:23,840 --> 00:01:25,840
us and about

31
00:01:25,840 --> 00:01:27,439
this talk

32
00:01:27,439 --> 00:01:29,840
so in our day jobs as

33
00:01:29,840 --> 00:01:30,799
marco

34
00:01:30,799 --> 00:01:34,560
already said we work at a startup and

35
00:01:34,560 --> 00:01:36,560
we're building

36
00:01:36,560 --> 00:01:38,720
we're building

37
00:01:38,720 --> 00:01:41,040
automatic vulnerability discovery so

38
00:01:41,040 --> 00:01:43,680
we're in static analysis uh meaning um

39
00:01:43,680 --> 00:01:47,200
yeah we we actually uh write programs to

40
00:01:47,200 --> 00:01:49,119
look for bugs in other programs that's

41
00:01:49,119 --> 00:01:50,880
essentially what we do

42
00:01:50,880 --> 00:01:52,880
and um

43
00:01:52,880 --> 00:01:54,799
the uh content that you're going to be

44
00:01:54,799 --> 00:01:57,119
seeing today is kind of a combination of

45
00:01:57,119 --> 00:01:59,280
what we do at our work but also just a

46
00:01:59,280 --> 00:02:00,640
hobby project

47
00:02:00,640 --> 00:02:02,799
and this was a hobby project that

48
00:02:02,799 --> 00:02:05,520
claudio started he thought that it would

49
00:02:05,520 --> 00:02:08,639
be really fun to take apart

50
00:02:08,639 --> 00:02:10,800
some routers that you would find you

51
00:02:10,800 --> 00:02:12,319
know like consumer grade routers stuff

52
00:02:12,319 --> 00:02:14,480
that you would find at home

53
00:02:14,480 --> 00:02:16,640
and so we took a look at the d-link

54
00:02:16,640 --> 00:02:18,160
routers

55
00:02:18,160 --> 00:02:20,080
and turned out to be a pretty juicy

56
00:02:20,080 --> 00:02:21,760
target so there's a lot of stuff in

57
00:02:21,760 --> 00:02:23,840
there and you'll see a lot of that stuff

58
00:02:23,840 --> 00:02:25,840
um as well today

59
00:02:25,840 --> 00:02:27,680
um yeah and it was just a great

60
00:02:27,680 --> 00:02:29,440
opportunity to test out whether our

61
00:02:29,440 --> 00:02:32,160
stuff really works and of course finding

62
00:02:32,160 --> 00:02:34,080
out where it does not work so that we

63
00:02:34,080 --> 00:02:35,040
can

64
00:02:35,040 --> 00:02:37,440
go ahead and improve that

65
00:02:37,440 --> 00:02:39,519
and so today i mean this is a talk

66
00:02:39,519 --> 00:02:41,760
mostly about methodology how would you

67
00:02:41,760 --> 00:02:43,519
approach such a target

68
00:02:43,519 --> 00:02:46,239
but we'll actually also look deeply into

69
00:02:46,239 --> 00:02:48,480
the bugs that we found

70
00:02:48,480 --> 00:02:53,599
as well as um into how we exported them

71
00:02:53,680 --> 00:02:55,599
uh so overall everything that you're

72
00:02:55,599 --> 00:02:57,440
seeing today i mean this is not

73
00:02:57,440 --> 00:02:59,920
commercial stuff this is open source you

74
00:02:59,920 --> 00:03:01,440
can download all of this and you can

75
00:03:01,440 --> 00:03:02,640
play with it

76
00:03:02,640 --> 00:03:05,440
this is very important to us um so it is

77
00:03:05,440 --> 00:03:08,159
um from a technological point of view uh

78
00:03:08,159 --> 00:03:10,480
something that we also um use in in

79
00:03:10,480 --> 00:03:13,599
products um but yeah we have a huge part

80
00:03:13,599 --> 00:03:15,840
of of it that we make available to the

81
00:03:15,840 --> 00:03:17,599
community

82
00:03:17,599 --> 00:03:21,200
and the platform is called yearn

83
00:03:21,200 --> 00:03:22,640
on yearn i o

84
00:03:22,640 --> 00:03:24,720
and the idea is to create a bug

85
00:03:24,720 --> 00:03:26,879
counter's workbench over time so

86
00:03:26,879 --> 00:03:29,440
something that you can use during your

87
00:03:29,440 --> 00:03:30,640
code audit

88
00:03:30,640 --> 00:03:32,560
that will support you in reading your

89
00:03:32,560 --> 00:03:33,599
code

90
00:03:33,599 --> 00:03:35,519
and that will also support you in in

91
00:03:35,519 --> 00:03:37,200
creating exploits for it

92
00:03:37,200 --> 00:03:39,760
um this is actually a quite old project

93
00:03:39,760 --> 00:03:42,959
at this point um it started off in 2013

94
00:03:42,959 --> 00:03:46,799
um it was just me at that point and

95
00:03:46,799 --> 00:03:49,440
yeah it was mainly for research

96
00:03:49,440 --> 00:03:51,440
and the initial idea was to create a

97
00:03:51,440 --> 00:03:53,599
fuzzy parser so that's a parser that's

98
00:03:53,599 --> 00:03:55,760
like very robust

99
00:03:55,760 --> 00:03:57,200
regardless of whether you have a build

100
00:03:57,200 --> 00:03:59,200
environment or not it will somehow

101
00:03:59,200 --> 00:04:01,680
translate into syntax trees and from

102
00:04:01,680 --> 00:04:03,360
there on to control flow graphs and so

103
00:04:03,360 --> 00:04:04,239
on

104
00:04:04,239 --> 00:04:06,480
because i was doing research on like

105
00:04:06,480 --> 00:04:08,319
pattern recognition for vulnerability

106
00:04:08,319 --> 00:04:11,200
discovery and so in that setting you

107
00:04:11,200 --> 00:04:13,040
can't go ahead and configure build

108
00:04:13,040 --> 00:04:14,879
environments for like a thousand debian

109
00:04:14,879 --> 00:04:16,880
packages or something like that um you

110
00:04:16,880 --> 00:04:18,560
know to get your experiments running so

111
00:04:18,560 --> 00:04:19,680
you need something that's a bit more

112
00:04:19,680 --> 00:04:22,160
robust and initially it was that fuzzy

113
00:04:22,160 --> 00:04:24,960
parser um today it's become more of an

114
00:04:24,960 --> 00:04:26,560
interactive programming shell for

115
00:04:26,560 --> 00:04:28,880
vulnerability discovery so you import

116
00:04:28,880 --> 00:04:31,759
code still with robust parsers then it's

117
00:04:31,759 --> 00:04:33,600
available in a graph database and you

118
00:04:33,600 --> 00:04:36,240
have a query language that you can use

119
00:04:36,240 --> 00:04:36,960
to

120
00:04:36,960 --> 00:04:38,960
then explore your code

121
00:04:38,960 --> 00:04:40,800
it's it's based on scala i realize

122
00:04:40,800 --> 00:04:43,919
that's not very uh popular in the

123
00:04:43,919 --> 00:04:46,800
vulnerability research community uh it's

124
00:04:46,800 --> 00:04:48,960
actually a very pretty language i hope

125
00:04:48,960 --> 00:04:51,120
you will agree after the talk and we do

126
00:04:51,120 --> 00:04:53,520
have the ability to script this with

127
00:04:53,520 --> 00:04:56,560
python as well at this point but yeah um

128
00:04:56,560 --> 00:04:58,400
you know scala is cool

129
00:04:58,400 --> 00:05:00,880
just wanna say that anyway at this point

130
00:05:00,880 --> 00:05:04,000
uh we can not only analyze c and c plus

131
00:05:04,000 --> 00:05:07,840
plus uh but also java javascript

132
00:05:07,840 --> 00:05:09,680
and then at some point we went more

133
00:05:09,680 --> 00:05:11,039
towards

134
00:05:11,039 --> 00:05:13,520
byte code analysis so jvm byte code and

135
00:05:13,520 --> 00:05:15,840
lvm bit code

136
00:05:15,840 --> 00:05:17,919
yeah and eventually binary which is what

137
00:05:17,919 --> 00:05:19,680
we're speaking about today

138
00:05:19,680 --> 00:05:21,280
there's a query collection that you can

139
00:05:21,280 --> 00:05:23,120
check out you know just a bunch of

140
00:05:23,120 --> 00:05:25,360
queries to get you started um so that

141
00:05:25,360 --> 00:05:26,880
kind of turns that whole thing into an

142
00:05:26,880 --> 00:05:28,960
automated scanner but i just want to say

143
00:05:28,960 --> 00:05:30,880
i mean we're not really about um at

144
00:05:30,880 --> 00:05:32,400
least in this open source project we're

145
00:05:32,400 --> 00:05:35,199
not about building this um you know

146
00:05:35,199 --> 00:05:37,360
scanner that just gives you the bugs and

147
00:05:37,360 --> 00:05:38,880
that's that it's more about building a

148
00:05:38,880 --> 00:05:41,280
code exploration platform something that

149
00:05:41,280 --> 00:05:43,919
you can actually use during your audits

150
00:05:43,919 --> 00:05:46,000
more in the style of let's say um you

151
00:05:46,000 --> 00:05:47,680
know ida or ghidra or something like

152
00:05:47,680 --> 00:05:48,479
that

153
00:05:48,479 --> 00:05:51,199
unless in the style of a yeah a linter

154
00:05:51,199 --> 00:05:54,400
or automatic scanner

155
00:05:56,080 --> 00:05:58,400
all right um so it works pretty well on

156
00:05:58,400 --> 00:06:00,160
source code

157
00:06:00,160 --> 00:06:01,840
we've seen that in the past so here's

158
00:06:01,840 --> 00:06:04,160
one of those typical queries

159
00:06:04,160 --> 00:06:07,440
here we look for an allocation

160
00:06:07,440 --> 00:06:09,680
and inside that allocation

161
00:06:09,680 --> 00:06:12,560
we perform arithmetic

162
00:06:12,560 --> 00:06:13,600
and

163
00:06:13,600 --> 00:06:15,759
then we look for a mem copy

164
00:06:15,759 --> 00:06:18,000
and we check that that allocated buffer

165
00:06:18,000 --> 00:06:19,600
actually

166
00:06:19,600 --> 00:06:21,680
goes into the first argument of that mem

167
00:06:21,680 --> 00:06:22,720
copy

168
00:06:22,720 --> 00:06:25,680
and then we make sure that

169
00:06:25,680 --> 00:06:28,479
yeah there's a

170
00:06:28,560 --> 00:06:29,600
there

171
00:06:29,600 --> 00:06:31,520
there is

172
00:06:31,520 --> 00:06:34,000
something in the amount that we copy

173
00:06:34,000 --> 00:06:35,680
that's not equal

174
00:06:35,680 --> 00:06:38,080
to that arithmetic expression and so

175
00:06:38,080 --> 00:06:40,560
that is something that uh

176
00:06:40,560 --> 00:06:42,560
yeah leads to heap-based buffer

177
00:06:42,560 --> 00:06:43,840
overflows a lot

178
00:06:43,840 --> 00:06:47,120
and we used this query in 2014

179
00:06:47,120 --> 00:06:48,960
found a buffer overflow in the automatic

180
00:06:48,960 --> 00:06:50,960
updater of vlc

181
00:06:50,960 --> 00:06:53,840
used the query again in 2020 and i found

182
00:06:53,840 --> 00:06:55,360
another one right

183
00:06:55,360 --> 00:06:57,360
same quote more or less

184
00:06:57,360 --> 00:06:59,039
different instance but you can see you

185
00:06:59,039 --> 00:07:00,880
can kind of generalize there and have a

186
00:07:00,880 --> 00:07:03,440
query ready that you can fire

187
00:07:03,440 --> 00:07:07,199
years later and it will return box again

188
00:07:07,199 --> 00:07:08,880
and so then the question is what do we

189
00:07:08,880 --> 00:07:11,599
do if all we have is binary

190
00:07:11,599 --> 00:07:13,360
and we've looked at that question before

191
00:07:13,360 --> 00:07:15,280
so if you've followed our work over the

192
00:07:15,280 --> 00:07:16,960
past years there used to be what's

193
00:07:16,960 --> 00:07:20,400
called bjorn so binary yearn

194
00:07:20,400 --> 00:07:23,680
and that was based on r2

195
00:07:23,680 --> 00:07:25,440
but the experience was not comparable to

196
00:07:25,440 --> 00:07:26,720
what you have with source code

197
00:07:26,720 --> 00:07:28,479
essentially what we did there was we

198
00:07:28,479 --> 00:07:30,560
imported the disassembly and started

199
00:07:30,560 --> 00:07:32,560
writing queries and realized oh wow this

200
00:07:32,560 --> 00:07:33,599
is actually

201
00:07:33,599 --> 00:07:35,599
not you know you can't just take

202
00:07:35,599 --> 00:07:37,360
something for source code and then

203
00:07:37,360 --> 00:07:39,120
import a binary and expect similar kinds

204
00:07:39,120 --> 00:07:41,759
of results and so the main learnings

205
00:07:41,759 --> 00:07:44,879
for us at that point was uh were that uh

206
00:07:44,879 --> 00:07:46,240
well it's it's hard to adapt these

207
00:07:46,240 --> 00:07:47,919
approaches to binary it's not trivial

208
00:07:47,919 --> 00:07:50,400
and the other thing is that uh it's it's

209
00:07:50,400 --> 00:07:52,879
um we actually spent quite a bit of time

210
00:07:52,879 --> 00:07:54,800
before we realized that so it's actually

211
00:07:54,800 --> 00:07:57,280
better if you have a platf if you have a

212
00:07:57,280 --> 00:08:00,160
target available and while you're

213
00:08:00,160 --> 00:08:01,840
building this you're already trying it

214
00:08:01,840 --> 00:08:03,840
out

215
00:08:03,840 --> 00:08:05,599
just a few words about how source code

216
00:08:05,599 --> 00:08:08,160
in binary is different so in source code

217
00:08:08,160 --> 00:08:10,560
often you have a vulnerability

218
00:08:10,560 --> 00:08:12,960
like a good candidate point that already

219
00:08:12,960 --> 00:08:15,599
concentrates itself in a single uh

220
00:08:15,599 --> 00:08:17,680
statement like for example if you have a

221
00:08:17,680 --> 00:08:20,960
string copy here a strn copy and you see

222
00:08:20,960 --> 00:08:22,960
that okay they're actually using the

223
00:08:22,960 --> 00:08:25,360
length of the source buffer um for for

224
00:08:25,360 --> 00:08:27,360
the copy operation that's already pretty

225
00:08:27,360 --> 00:08:29,599
indicative of a buffer overflow sure you

226
00:08:29,599 --> 00:08:31,520
want to make sure that you do some uh

227
00:08:31,520 --> 00:08:33,519
data flow analysis to actually ensure

228
00:08:33,519 --> 00:08:34,799
that you can get to that point stuff

229
00:08:34,799 --> 00:08:36,399
like that but that's already very

230
00:08:36,399 --> 00:08:38,958
indicative or for example this typical

231
00:08:38,958 --> 00:08:41,679
malloc bug width times height where you

232
00:08:41,679 --> 00:08:43,679
have an integer overflow that then leads

233
00:08:43,679 --> 00:08:45,680
to heat baseball for overflow or like a

234
00:08:45,680 --> 00:08:47,519
truncation here where somebody says into

235
00:08:47,519 --> 00:08:50,080
len and then assigns a string length to

236
00:08:50,080 --> 00:08:52,880
that to that variable and so syntax

237
00:08:52,880 --> 00:08:54,800
trees are already you know quite

238
00:08:54,800 --> 00:08:57,040
powerful to describe that and then you

239
00:08:57,040 --> 00:08:58,959
can do a data flow analysis to kind of

240
00:08:58,959 --> 00:09:02,399
uh narrow in on that

241
00:09:02,480 --> 00:09:04,720
all right for binary uh you know you

242
00:09:04,720 --> 00:09:06,320
have a call site and you see okay

243
00:09:06,320 --> 00:09:07,519
something's been called and then it

244
00:09:07,519 --> 00:09:10,560
tells you well the arguments are a1 a2

245
00:09:10,560 --> 00:09:12,399
and a3 and you're like okay

246
00:09:12,399 --> 00:09:14,959
thanks sherlock uh you know this is not

247
00:09:14,959 --> 00:09:16,880
very useful for us is it so

248
00:09:16,880 --> 00:09:19,440
reconstructing these arguments uh is

249
00:09:19,440 --> 00:09:20,880
crucial

250
00:09:20,880 --> 00:09:22,320
another problem is that you don't really

251
00:09:22,320 --> 00:09:24,320
have variables anymore like variables

252
00:09:24,320 --> 00:09:26,080
actually you know the programmer's

253
00:09:26,080 --> 00:09:27,360
telling you what he's doing with that

254
00:09:27,360 --> 00:09:30,000
memory location that's not the case in

255
00:09:30,000 --> 00:09:31,519
binary all you have is

256
00:09:31,519 --> 00:09:33,519
memory locations and registers and so a

257
00:09:33,519 --> 00:09:34,959
huge part of what you need to do is

258
00:09:34,959 --> 00:09:36,880
recover these

259
00:09:36,880 --> 00:09:38,160
high-level

260
00:09:38,160 --> 00:09:39,360
variables

261
00:09:39,360 --> 00:09:40,959
there's a good paper about that where

262
00:09:40,959 --> 00:09:42,720
they call that abstract locations i just

263
00:09:42,720 --> 00:09:44,320
put it here on the slides you can check

264
00:09:44,320 --> 00:09:47,120
that out later if you like

265
00:09:47,120 --> 00:09:48,399
yeah the good thing is what changed

266
00:09:48,399 --> 00:09:52,160
between 2016 and now is guidra

267
00:09:52,160 --> 00:09:53,440
was released

268
00:09:53,440 --> 00:09:55,279
and guidera just has

269
00:09:55,279 --> 00:09:57,920
apart from having a good disassembler

270
00:09:57,920 --> 00:09:59,680
it has an amazing decompiler and

271
00:09:59,680 --> 00:10:01,600
decompilation actually deals with these

272
00:10:01,600 --> 00:10:05,040
topics that i just talked about it does

273
00:10:05,040 --> 00:10:07,440
approximation of local variables uh

274
00:10:07,440 --> 00:10:09,519
intra procedure recovery of arguments

275
00:10:09,519 --> 00:10:11,040
within a function

276
00:10:11,040 --> 00:10:14,000
and even recover some control structures

277
00:10:14,000 --> 00:10:16,399
and so the idea was why don't we not

278
00:10:16,399 --> 00:10:18,880
just make available disassembly

279
00:10:18,880 --> 00:10:20,640
i mean that's good but why don't we just

280
00:10:20,640 --> 00:10:22,880
use the decompiled code and feed it into

281
00:10:22,880 --> 00:10:24,800
our robust parser i mean we have that

282
00:10:24,800 --> 00:10:26,959
parser right so let's try that

283
00:10:26,959 --> 00:10:28,880
and yeah that was actually that actually

284
00:10:28,880 --> 00:10:30,640
turned out to be

285
00:10:30,640 --> 00:10:33,200
a really good step to take

286
00:10:33,200 --> 00:10:36,320
so get rid of cpg extends yearn uh

287
00:10:36,320 --> 00:10:38,399
it imports the disassemblies you can

288
00:10:38,399 --> 00:10:40,240
also import the decompiled code we do

289
00:10:40,240 --> 00:10:42,399
both today and what you end up having is

290
00:10:42,399 --> 00:10:44,399
a polynomial time inter procedural data

291
00:10:44,399 --> 00:10:47,040
flow analysis for a binary which with

292
00:10:47,040 --> 00:10:48,800
gidra you don't really have you have an

293
00:10:48,800 --> 00:10:51,600
intra procedural uh reaching definition

294
00:10:51,600 --> 00:10:54,560
uh analysis with gitra and that's that

295
00:10:54,560 --> 00:10:56,959
it's still highly under development but

296
00:10:56,959 --> 00:10:59,200
we're developing out in the open so you

297
00:10:59,200 --> 00:11:01,120
can check it out

298
00:11:01,120 --> 00:11:04,800
and now uh yeah for our target

299
00:11:06,079 --> 00:11:07,120
so

300
00:11:07,120 --> 00:11:08,480
this was

301
00:11:08,480 --> 00:11:10,720
the first time i started doing iot

302
00:11:10,720 --> 00:11:12,959
security so i didn't know exactly what i

303
00:11:12,959 --> 00:11:16,959
was doing almost at all but i tried to

304
00:11:16,959 --> 00:11:18,320
go ahead and

305
00:11:18,320 --> 00:11:20,240
pick something that is interesting

306
00:11:20,240 --> 00:11:21,519
um and

307
00:11:21,519 --> 00:11:22,560
the way

308
00:11:22,560 --> 00:11:24,399
the targets these targets were chosen

309
00:11:24,399 --> 00:11:26,320
were basically just like go to a major

310
00:11:26,320 --> 00:11:28,399
router manufacturer website

311
00:11:28,399 --> 00:11:30,640
and see which products are on the main

312
00:11:30,640 --> 00:11:33,360
page and pick one that is like

313
00:11:33,360 --> 00:11:34,160
um

314
00:11:34,160 --> 00:11:36,800
more expensive on the expensive side

315
00:11:36,800 --> 00:11:39,680
like around 100 bucks 120 bucks

316
00:11:39,680 --> 00:11:42,240
and one that is more mid-range so maybe

317
00:11:42,240 --> 00:11:44,160
not something that your grandma would

318
00:11:44,160 --> 00:11:46,480
buy but you know your sister maybe or

319
00:11:46,480 --> 00:11:47,519
something

320
00:11:47,519 --> 00:11:50,880
um and the other uh consideration was um

321
00:11:50,880 --> 00:11:53,360
whether the firmwares were encrypted or

322
00:11:53,360 --> 00:11:54,240
not

323
00:11:54,240 --> 00:11:56,639
from the get-go and in this case they

324
00:11:56,639 --> 00:11:58,560
were both encrypted so that means that

325
00:11:58,560 --> 00:12:00,720
not a lot of security researchers uh

326
00:12:00,720 --> 00:12:03,440
looked at it as much as for farmers that

327
00:12:03,440 --> 00:12:05,920
um aren't

328
00:12:05,920 --> 00:12:09,040
um so these are the two targets the drx

329
00:12:09,040 --> 00:12:13,839
1860 and the dr842v2

330
00:12:13,839 --> 00:12:17,040
and there are both release date 2021 so

331
00:12:17,040 --> 00:12:19,440
they're fairly recent uh still on the

332
00:12:19,440 --> 00:12:21,120
market still on the

333
00:12:21,120 --> 00:12:22,839
on the web page of the

334
00:12:22,839 --> 00:12:26,000
provider and after the targets which

335
00:12:26,000 --> 00:12:28,720
were chosen um and if you want to do

336
00:12:28,720 --> 00:12:31,040
something um like this yourself

337
00:12:31,040 --> 00:12:32,639
basically you have to purchase a couple

338
00:12:32,639 --> 00:12:33,839
of tools

339
00:12:33,839 --> 00:12:36,320
so for example here you see

340
00:12:36,320 --> 00:12:38,639
a voltmeter

341
00:12:38,639 --> 00:12:41,440
and a uart converter

342
00:12:41,440 --> 00:12:43,279
a uh

343
00:12:43,279 --> 00:12:47,200
analyzer is an analyzer for this and a

344
00:12:47,200 --> 00:12:49,920
couple of wires um and basically

345
00:12:49,920 --> 00:12:52,000
when you have all of that you're ready

346
00:12:52,000 --> 00:12:56,320
to go all of the tools cost around 120

347
00:12:56,320 --> 00:12:58,160
dollars or if you don't want to spend

348
00:12:58,160 --> 00:13:00,240
the money you can just go to your local

349
00:13:00,240 --> 00:13:02,959
local hackerspace and they usually have

350
00:13:02,959 --> 00:13:05,200
all of this for example in berlin at c

351
00:13:05,200 --> 00:13:07,200
base they have all of this on and you

352
00:13:07,200 --> 00:13:09,440
can use it for free

353
00:13:09,440 --> 00:13:12,079
um so after all of the that is done uh

354
00:13:12,079 --> 00:13:13,920
what you have to do is to solder the

355
00:13:13,920 --> 00:13:16,560
stuff uh you solder a couple of three

356
00:13:16,560 --> 00:13:19,200
wires in this case um in

357
00:13:19,200 --> 00:13:21,680
one of the router in in the uart port of

358
00:13:21,680 --> 00:13:24,079
the router and just all the three wires

359
00:13:24,079 --> 00:13:25,839
in the connector and then you connect

360
00:13:25,839 --> 00:13:27,920
connect them both and then you're ready

361
00:13:27,920 --> 00:13:29,360
ready to go

362
00:13:29,360 --> 00:13:31,760
if you are as bad as soldering as i am

363
00:13:31,760 --> 00:13:33,440
you can also do

364
00:13:33,440 --> 00:13:35,440
uh go to your local

365
00:13:35,440 --> 00:13:37,279
provider of

366
00:13:37,279 --> 00:13:40,000
like a computer repair shop and they can

367
00:13:40,000 --> 00:13:42,959
do this for you for very cheaply this is

368
00:13:42,959 --> 00:13:45,519
berkai from berlin

369
00:13:45,519 --> 00:13:47,279
from computer handy shop

370
00:13:47,279 --> 00:13:49,920
he's watching right now hello bad guy

371
00:13:49,920 --> 00:13:52,480
and he did he did a wonderful soldiering

372
00:13:52,480 --> 00:13:55,199
job much better than the one i i could

373
00:13:55,199 --> 00:13:57,360
do

374
00:13:57,360 --> 00:13:59,199
and just to see how it looks like when

375
00:13:59,199 --> 00:14:01,519
your soldering job is very poor

376
00:14:01,519 --> 00:14:02,639
these are

377
00:14:02,639 --> 00:14:04,320
on the bottom there you see all those

378
00:14:04,320 --> 00:14:05,680
glitch chars

379
00:14:05,680 --> 00:14:08,000
and those are the things that you see

380
00:14:08,000 --> 00:14:10,720
when either the wires are bad or you set

381
00:14:10,720 --> 00:14:13,040
the incorrect baud rate on the

382
00:14:13,040 --> 00:14:15,360
connection

383
00:14:15,360 --> 00:14:17,199
yeah so this is uh this is the whole

384
00:14:17,199 --> 00:14:20,320
setup um you have you have the uart

385
00:14:20,320 --> 00:14:22,240
connection like with the with a good

386
00:14:22,240 --> 00:14:24,959
uart connection in place you have um

387
00:14:24,959 --> 00:14:26,880
uh you can just connect via screen and

388
00:14:26,880 --> 00:14:28,639
then you get in most of the cases you

389
00:14:28,639 --> 00:14:30,959
get the root shell not

390
00:14:30,959 --> 00:14:32,800
in all of the cases like some of the

391
00:14:32,800 --> 00:14:34,880
newer devices have like some protection

392
00:14:34,880 --> 00:14:37,120
mechanisms or a password in place but

393
00:14:37,120 --> 00:14:39,120
you can get around that uh usually

394
00:14:39,120 --> 00:14:42,800
pretty quickly with some tricks in uart

395
00:14:42,800 --> 00:14:45,199
uh sorry u-boots or

396
00:14:45,199 --> 00:14:49,199
um yeah just like trying stuff out

397
00:14:49,199 --> 00:14:50,160
so

398
00:14:50,160 --> 00:14:52,480
when you have all of this

399
00:14:52,480 --> 00:14:54,720
and you have a root shell basically or

400
00:14:54,720 --> 00:14:57,440
what you do is you just go in and you

401
00:14:57,440 --> 00:14:59,519
try to look try to understand the system

402
00:14:59,519 --> 00:15:01,360
a little bit how it works obviously the

403
00:15:01,360 --> 00:15:02,880
first thing that you want to do is just

404
00:15:02,880 --> 00:15:05,519
to look at how is the web interface

405
00:15:05,519 --> 00:15:08,399
shown right how the that when you go to

406
00:15:08,399 --> 00:15:11,440
the admin panel of the router uh what's

407
00:15:11,440 --> 00:15:13,360
uh what is the thing that is serving

408
00:15:13,360 --> 00:15:15,279
that um traffic

409
00:15:15,279 --> 00:15:18,560
and here um it's just basically

410
00:15:18,560 --> 00:15:20,959
there's in one of the targets there's

411
00:15:20,959 --> 00:15:24,480
like one old school cgi program uh dpd

412
00:15:24,480 --> 00:15:26,399
and basically has a couple of

413
00:15:26,399 --> 00:15:30,079
lua scripts as a configuration and um

414
00:15:30,079 --> 00:15:33,440
which point to two binaries like in

415
00:15:33,440 --> 00:15:36,800
one of the devices and um

416
00:15:36,800 --> 00:15:39,199
one of the binaries is used just one

417
00:15:39,199 --> 00:15:40,720
time in the

418
00:15:40,720 --> 00:15:43,440
html of the admin interface which means

419
00:15:43,440 --> 00:15:45,040
that that's probably an abandoned

420
00:15:45,040 --> 00:15:49,279
library or a lib or a binary or a binary

421
00:15:49,279 --> 00:15:51,600
that has been forgotten there

422
00:15:51,600 --> 00:15:53,360
so that makes it a much more interesting

423
00:15:53,360 --> 00:15:56,639
target and a target to look at

424
00:15:56,639 --> 00:15:57,440
so

425
00:15:57,440 --> 00:15:59,440
now you have the binary like you have

426
00:15:59,440 --> 00:16:01,360
like one of the interesting binaries and

427
00:16:01,360 --> 00:16:05,120
then um in my case um i just started get

428
00:16:05,120 --> 00:16:07,600
gidra and the yarn shell at the

429
00:16:07,600 --> 00:16:08,800
same time

430
00:16:08,800 --> 00:16:11,120
and started to look into

431
00:16:11,120 --> 00:16:14,639
the target a little bit more closely

432
00:16:17,279 --> 00:16:18,240
all right

433
00:16:18,240 --> 00:16:19,600
so yeah the first thing that you want to

434
00:16:19,600 --> 00:16:21,680
do is you want to kind of map out the

435
00:16:21,680 --> 00:16:23,759
attack surface so what's the code that

436
00:16:23,759 --> 00:16:25,440
actually needs to deal

437
00:16:25,440 --> 00:16:27,519
with the data that i can provide as an

438
00:16:27,519 --> 00:16:28,560
attacker

439
00:16:28,560 --> 00:16:30,480
and you'll see a query in a moment but

440
00:16:30,480 --> 00:16:32,320
you know let's be honest here there's a

441
00:16:32,320 --> 00:16:34,320
lot of tools that you can use to do that

442
00:16:34,320 --> 00:16:35,600
you essentially want to look at the

443
00:16:35,600 --> 00:16:37,120
external functions so what are the

444
00:16:37,120 --> 00:16:39,199
library functions that are being called

445
00:16:39,199 --> 00:16:41,440
and so we did that for uh

446
00:16:41,440 --> 00:16:43,279
the two binaries so for the two

447
00:16:43,279 --> 00:16:44,720
different devices

448
00:16:44,720 --> 00:16:46,079
the first one

449
00:16:46,079 --> 00:16:48,959
first binary was called

450
00:16:49,440 --> 00:16:51,839
u mtfw from that uh more expensive

451
00:16:51,839 --> 00:16:52,800
router

452
00:16:52,800 --> 00:16:56,000
and um it actually it uses lip c like

453
00:16:56,000 --> 00:16:58,160
very rarely uh to do string handling

454
00:16:58,160 --> 00:17:00,399
file operations and memory allocations

455
00:17:00,399 --> 00:17:02,079
so that's nice i mean there can be

456
00:17:02,079 --> 00:17:03,839
memory corruption in that and it's a web

457
00:17:03,839 --> 00:17:05,919
application you know don't forget that

458
00:17:05,919 --> 00:17:09,439
for http uh it is very old-school it

459
00:17:09,439 --> 00:17:12,959
uses get end so environment variables

460
00:17:12,959 --> 00:17:17,199
to uh to to get the http request data

461
00:17:17,199 --> 00:17:20,079
so extremely old-school stuff

462
00:17:20,079 --> 00:17:21,359
then for the other one this is actually

463
00:17:21,359 --> 00:17:23,359
the cheaper router but it's not as

464
00:17:23,359 --> 00:17:24,400
old-school

465
00:17:24,400 --> 00:17:26,799
so these guys also use lip c functions

466
00:17:26,799 --> 00:17:28,960
for string handling file operations

467
00:17:28,960 --> 00:17:32,160
memory allocation but then they have a

468
00:17:32,160 --> 00:17:34,000
library called mongoose that they use

469
00:17:34,000 --> 00:17:36,080
for http uh

470
00:17:36,080 --> 00:17:38,080
for all handling of http really

471
00:17:38,080 --> 00:17:40,880
including web sockets they have a json

472
00:17:40,880 --> 00:17:42,559
library called jansen we didn't really

473
00:17:42,559 --> 00:17:44,559
look into that much and there's an

474
00:17:44,559 --> 00:17:48,000
internal rpc library called djr

475
00:17:48,000 --> 00:17:50,720
rpc api we also didn't look into that

476
00:17:50,720 --> 00:17:52,480
too much um you'll see we didn't have to

477
00:17:52,480 --> 00:17:54,320
look very deep actually

478
00:17:54,320 --> 00:17:56,320
so i'll just talk about that cheaper

479
00:17:56,320 --> 00:17:59,200
router for now and then claudio will

480
00:17:59,200 --> 00:18:01,440
talk about the more expensive one so for

481
00:18:01,440 --> 00:18:03,840
the cheap router um i mean

482
00:18:03,840 --> 00:18:05,360
we just talked about how it gets all of

483
00:18:05,360 --> 00:18:08,559
it http data via mongoose and mongoose

484
00:18:08,559 --> 00:18:11,520
functions all start with mg mg

485
00:18:11,520 --> 00:18:13,200
underscore so the first thing that you

486
00:18:13,200 --> 00:18:15,919
can do is kind of like list all of the

487
00:18:15,919 --> 00:18:18,400
different calls to mg functions just to

488
00:18:18,400 --> 00:18:20,960
get an idea of um you know how do they

489
00:18:20,960 --> 00:18:22,559
how do they receive attacker controlled

490
00:18:22,559 --> 00:18:24,480
data and here you see there's a function

491
00:18:24,480 --> 00:18:26,720
called get header which yeah as the name

492
00:18:26,720 --> 00:18:29,280
would imply get some data from an http

493
00:18:29,280 --> 00:18:32,080
header then you have git cookie that

494
00:18:32,080 --> 00:18:34,080
gets stuff from cookies pretty center

495
00:18:34,080 --> 00:18:36,640
stuff and then what you can do is um

496
00:18:36,640 --> 00:18:39,520
yeah you can you can dump out

497
00:18:39,520 --> 00:18:40,960
all of the

498
00:18:40,960 --> 00:18:43,200
decompilations all of

499
00:18:43,200 --> 00:18:45,679
the decompiled functions

500
00:18:45,679 --> 00:18:48,720
of methods that call one of those mg

501
00:18:48,720 --> 00:18:50,160
functions you can just dump that to a

502
00:18:50,160 --> 00:18:52,080
file that's pretty nice that means you

503
00:18:52,080 --> 00:18:53,760
can scroll through it and you actually

504
00:18:53,760 --> 00:18:55,520
get a good idea

505
00:18:55,520 --> 00:18:58,480
yeah of of like the the first responders

506
00:18:58,480 --> 00:19:01,280
in in in the http chain right

507
00:19:01,280 --> 00:19:02,080
um

508
00:19:02,080 --> 00:19:04,080
and then you know as you as you try to

509
00:19:04,080 --> 00:19:06,480
automate this um

510
00:19:06,480 --> 00:19:08,799
you can just mark all of these functions

511
00:19:08,799 --> 00:19:10,480
to then use them later

512
00:19:10,480 --> 00:19:12,400
so here's a query that we use that

513
00:19:12,400 --> 00:19:14,960
essentially says take all the calls to

514
00:19:14,960 --> 00:19:17,120
mg functions

515
00:19:17,120 --> 00:19:19,760
and go to the methods that they're in

516
00:19:19,760 --> 00:19:22,320
and then just start walking the the

517
00:19:22,320 --> 00:19:25,600
calls the outgoing calls um and only

518
00:19:25,600 --> 00:19:27,600
take the internal ones and do that ten

519
00:19:27,600 --> 00:19:29,760
times so you're just kind of expanding

520
00:19:29,760 --> 00:19:32,320
into the code and along the core graph

521
00:19:32,320 --> 00:19:33,600
and you're just marking this you're

522
00:19:33,600 --> 00:19:37,360
saying okay this is attack surface right

523
00:19:37,360 --> 00:19:40,000
so with all queries that we show now

524
00:19:40,000 --> 00:19:42,320
we're just going to filter uh to only

525
00:19:42,320 --> 00:19:44,080
look at these functions so you're not

526
00:19:44,080 --> 00:19:45,600
looking at the entire binary you're

527
00:19:45,600 --> 00:19:47,440
looking at the functions that have

528
00:19:47,440 --> 00:19:50,320
something to do with the http handling

529
00:19:50,320 --> 00:19:53,840
directly or indirectly

530
00:19:53,840 --> 00:19:56,480
um yeah and so here was our first square

531
00:19:56,480 --> 00:19:59,280
query really and it's super simple and

532
00:19:59,280 --> 00:20:00,640
the fact that we found something with

533
00:20:00,640 --> 00:20:02,559
this is a bit problematic

534
00:20:02,559 --> 00:20:04,880
so the only thing we do here is we say

535
00:20:04,880 --> 00:20:07,919
okay look at look at string copies strn

536
00:20:07,919 --> 00:20:10,720
copies and mem copies and then look at

537
00:20:10,720 --> 00:20:12,480
the amounts here all right the amounts

538
00:20:12,480 --> 00:20:15,200
are in the third argument and uh they

539
00:20:15,200 --> 00:20:16,559
should not be

540
00:20:16,559 --> 00:20:18,080
literals

541
00:20:18,080 --> 00:20:20,000
it should not be a constant amount that

542
00:20:20,000 --> 00:20:21,760
we're copying because otherwise um you

543
00:20:21,760 --> 00:20:23,120
know there's probably no buffer flow in

544
00:20:23,120 --> 00:20:24,400
that right

545
00:20:24,400 --> 00:20:26,880
and then look at the first argument

546
00:20:26,880 --> 00:20:28,480
that's the destination of the copy

547
00:20:28,480 --> 00:20:31,360
operation and uh it should be a stack

548
00:20:31,360 --> 00:20:33,440
buffer right so stack buffer constant

549
00:20:33,440 --> 00:20:36,159
size but a non-constant amount that we

550
00:20:36,159 --> 00:20:38,480
copy into it and the last thing is just

551
00:20:38,480 --> 00:20:40,159
it should be part of the attack surface

552
00:20:40,159 --> 00:20:41,600
right which we marked with the previous

553
00:20:41,600 --> 00:20:42,720
query

554
00:20:42,720 --> 00:20:44,400
and that's it um

555
00:20:44,400 --> 00:20:46,240
and so you can already see the ability

556
00:20:46,240 --> 00:20:48,400
to inspect arguments here is really um

557
00:20:48,400 --> 00:20:49,840
important otherwise you could not do

558
00:20:49,840 --> 00:20:51,679
this thing here now the nice thing about

559
00:20:51,679 --> 00:20:54,159
this query is this is exactly the kind

560
00:20:54,159 --> 00:20:55,760
of query or

561
00:20:55,760 --> 00:20:57,520
that we would run on source code right

562
00:20:57,520 --> 00:20:59,200
the only thing that's a bit different

563
00:20:59,200 --> 00:21:01,360
here which we would need to clean up to

564
00:21:01,360 --> 00:21:03,760
have the exact same query is that thing

565
00:21:03,760 --> 00:21:05,280
here with a stack because here we're

566
00:21:05,280 --> 00:21:08,080
saying okay gidra has nicely marked this

567
00:21:08,080 --> 00:21:10,559
as a stack buffer so here we we would

568
00:21:10,559 --> 00:21:14,000
really need to say it's a local variable

569
00:21:14,000 --> 00:21:16,000
that is an array and stuff like that and

570
00:21:16,000 --> 00:21:17,919
so this is just shorter but this is the

571
00:21:17,919 --> 00:21:19,440
only thing that keeps you from running

572
00:21:19,440 --> 00:21:21,520
this thing on source code as well so

573
00:21:21,520 --> 00:21:23,760
exactly the same query

574
00:21:23,760 --> 00:21:28,159
um yeah and so we ran that and

575
00:21:28,159 --> 00:21:30,159
yeah there was immediately a buffer

576
00:21:30,159 --> 00:21:32,159
overflow that we found um so this is in

577
00:21:32,159 --> 00:21:34,559
the websocket data handler and you can

578
00:21:34,559 --> 00:21:36,320
see here um they're looking at the

579
00:21:36,320 --> 00:21:39,039
packet it's called param3 and if it

580
00:21:39,039 --> 00:21:41,440
starts with an init and then they're

581
00:21:41,440 --> 00:21:44,080
going to go into this block here and

582
00:21:44,080 --> 00:21:46,000
then they take the rest of the packet

583
00:21:46,000 --> 00:21:47,360
and they just copy it into a stack

584
00:21:47,360 --> 00:21:49,280
buffer and they really don't mind how

585
00:21:49,280 --> 00:21:51,280
big it is this is the amount that they

586
00:21:51,280 --> 00:21:54,320
copy so yeah you just overwrite it and

587
00:21:54,320 --> 00:21:56,000
the nice thing on this device is also

588
00:21:56,000 --> 00:21:56,840
that

589
00:21:56,840 --> 00:21:59,200
uh i mean from an attacker's point of

590
00:21:59,200 --> 00:22:01,440
view is uh they don't have any stack

591
00:22:01,440 --> 00:22:03,039
cookies or canneries or anything like

592
00:22:03,039 --> 00:22:04,640
that so you really just overwrite the

593
00:22:04,640 --> 00:22:06,480
return address and can you know start

594
00:22:06,480 --> 00:22:09,520
start exploiting this

595
00:22:09,520 --> 00:22:11,200
uh yeah there were really just two

596
00:22:11,200 --> 00:22:13,520
results right and this is the second one

597
00:22:13,520 --> 00:22:18,000
and uh this is in a code that is in a

598
00:22:18,000 --> 00:22:20,480
quality of websocket data handler so

599
00:22:20,480 --> 00:22:22,320
also a function that you can reach with

600
00:22:22,320 --> 00:22:24,240
your uh

601
00:22:24,240 --> 00:22:26,640
websocket packet and here's the second

602
00:22:26,640 --> 00:22:28,400
buffer overload it is also extremely

603
00:22:28,400 --> 00:22:30,080
simple right you have a stack buffer

604
00:22:30,080 --> 00:22:33,600
here's uh the uh what you control here's

605
00:22:33,600 --> 00:22:36,880
uh the size of that and there you go

606
00:22:36,880 --> 00:22:41,679
another um exploitable bug right um yeah

607
00:22:41,679 --> 00:22:42,720
i talked about how we have the

608
00:22:42,720 --> 00:22:44,720
disassembly so that's pretty nice what

609
00:22:44,720 --> 00:22:47,520
we could now do is extract gadgets for

610
00:22:47,520 --> 00:22:49,760
our exploit because what is a gadget

611
00:22:49,760 --> 00:22:52,240
right a gadget is really just

612
00:22:52,240 --> 00:22:55,760
a sequence of instructions that ends

613
00:22:55,760 --> 00:22:58,400
with a red right and so we could say

614
00:22:58,400 --> 00:23:02,240
okay um give me all of the uh yeah walk

615
00:23:02,240 --> 00:23:04,880
backwards through the uh control flow

616
00:23:04,880 --> 00:23:08,240
graph like five times in this case and

617
00:23:08,240 --> 00:23:11,120
um yeah just dump that to a file again

618
00:23:11,120 --> 00:23:13,200
so that gave us gadgets that we could

619
00:23:13,200 --> 00:23:15,760
use and we selected a few

620
00:23:15,760 --> 00:23:17,440
and you can put all this stuff in

621
00:23:17,440 --> 00:23:19,760
scripts and then uh yeah there are year

622
00:23:19,760 --> 00:23:21,679
on scripts which are just scala scripts

623
00:23:21,679 --> 00:23:24,400
really and you can then reuse that every

624
00:23:24,400 --> 00:23:26,720
time that you want to dump gadgets uh

625
00:23:26,720 --> 00:23:28,080
yeah and this this works across

626
00:23:28,080 --> 00:23:31,120
platforms as well because we map return

627
00:23:31,120 --> 00:23:33,120
um to yeah

628
00:23:33,120 --> 00:23:35,200
from different platforms to the the same

629
00:23:35,200 --> 00:23:38,720
intermediate representation

630
00:23:38,720 --> 00:23:39,840
yeah and

631
00:23:39,840 --> 00:23:40,880
you know

632
00:23:40,880 --> 00:23:42,480
you can also write

633
00:23:42,480 --> 00:23:44,480
binary experts in scala if you want to

634
00:23:44,480 --> 00:23:46,240
right so here's my binary expert in

635
00:23:46,240 --> 00:23:47,919
scala

636
00:23:47,919 --> 00:23:51,279
it contains three gadgets it's not a lot

637
00:23:51,279 --> 00:23:54,240
of magic that we need to do fix the gp

638
00:23:54,240 --> 00:23:57,200
make sure that a0 points to somewhere um

639
00:23:57,200 --> 00:24:00,240
that we control um yeah and then call p

640
00:24:00,240 --> 00:24:04,080
open right and you can see here um i'm

641
00:24:04,080 --> 00:24:05,760
actually passing in a shell command

642
00:24:05,760 --> 00:24:08,159
which is just echo the string owned into

643
00:24:08,159 --> 00:24:11,440
tmp lul and um yeah that's what we used

644
00:24:11,440 --> 00:24:13,520
as a proof of concept to show that we

645
00:24:13,520 --> 00:24:15,360
can actually write

646
00:24:15,360 --> 00:24:18,720
an arbitrary file on the device as root

647
00:24:18,720 --> 00:24:20,640
and then we send that over via websocket

648
00:24:20,640 --> 00:24:22,159
and that's that

649
00:24:22,159 --> 00:24:25,919
and yeah this is a 100 stable exploit

650
00:24:25,919 --> 00:24:27,279
luckily

651
00:24:27,279 --> 00:24:28,960
because

652
00:24:28,960 --> 00:24:29,840
they

653
00:24:29,840 --> 00:24:31,440
map the

654
00:24:31,440 --> 00:24:33,279
n-web

655
00:24:33,279 --> 00:24:37,919
base image at a fixed address every time

656
00:24:38,159 --> 00:24:41,919
yeah it's a remote root exploit because

657
00:24:41,919 --> 00:24:44,960
that n-web thing that web interface runs

658
00:24:44,960 --> 00:24:46,480
as a route

659
00:24:46,480 --> 00:24:47,840
so yeah it's pretty much everything that

660
00:24:47,840 --> 00:24:49,840
you want as an attacker right you can do

661
00:24:49,840 --> 00:24:51,679
whatever you like um

662
00:24:51,679 --> 00:24:53,919
yeah

663
00:24:54,880 --> 00:24:56,480
that's that yeah

664
00:24:56,480 --> 00:24:58,559
but that was really simple if you think

665
00:24:58,559 --> 00:25:01,120
about it right i mean we didn't even

666
00:25:01,120 --> 00:25:04,080
need data flow analysis which is a bit

667
00:25:04,080 --> 00:25:08,480
of a pity so we we looked for more right

668
00:25:08,480 --> 00:25:12,320
so we then looked for um typical uh

669
00:25:12,320 --> 00:25:14,640
directory traversals and so we were

670
00:25:14,640 --> 00:25:17,440
looking at f open calls and somewhere on

671
00:25:17,440 --> 00:25:19,679
the way in the data flow we want to make

672
00:25:19,679 --> 00:25:21,360
sure that there's a string cat so a

673
00:25:21,360 --> 00:25:23,840
concatenation

674
00:25:23,840 --> 00:25:25,600
that's pretty indicative usually means

675
00:25:25,600 --> 00:25:26,960
okay they're just putting strings

676
00:25:26,960 --> 00:25:28,799
together and you can specify dot dot

677
00:25:28,799 --> 00:25:31,120
slash and break out right and of course

678
00:25:31,120 --> 00:25:33,600
again in the attack surface

679
00:25:33,600 --> 00:25:35,360
also two hits

680
00:25:35,360 --> 00:25:38,480
both of them are directory traversals

681
00:25:38,480 --> 00:25:40,640
but that was not all actually when we

682
00:25:40,640 --> 00:25:42,480
tried to exploit this we realized

683
00:25:42,480 --> 00:25:44,320
there's another bug in this and you know

684
00:25:44,320 --> 00:25:46,720
we wanted a directory traversal but we

685
00:25:46,720 --> 00:25:49,120
got more like a heartbleed style bug

686
00:25:49,120 --> 00:25:51,679
which which is really funny actually so

687
00:25:51,679 --> 00:25:53,600
here's the code for that uh i'll try to

688
00:25:53,600 --> 00:25:54,799
speed up a bit

689
00:25:54,799 --> 00:25:57,200
um so

690
00:25:57,200 --> 00:25:59,679
this is the function concat endpoint

691
00:25:59,679 --> 00:26:02,320
it's a it's a it's a function that just

692
00:26:02,320 --> 00:26:04,240
reads an arbitrary file off of the

693
00:26:04,240 --> 00:26:07,600
device and on each line is another file

694
00:26:07,600 --> 00:26:09,600
name and then it will read all those

695
00:26:09,600 --> 00:26:11,039
files and put them together and send

696
00:26:11,039 --> 00:26:13,760
them back right and you have uh you have

697
00:26:13,760 --> 00:26:15,679
directory traversals in both of those

698
00:26:15,679 --> 00:26:17,600
file opens um

699
00:26:17,600 --> 00:26:21,679
now the funny thing is actually that um

700
00:26:21,679 --> 00:26:22,799
yeah

701
00:26:22,799 --> 00:26:25,360
as they try to write that file back

702
00:26:25,360 --> 00:26:26,400
um

703
00:26:26,400 --> 00:26:27,440
they will

704
00:26:27,440 --> 00:26:30,159
call f open here and if you specify a

705
00:26:30,159 --> 00:26:32,559
binary to read files from like these

706
00:26:32,559 --> 00:26:33,600
lines

707
00:26:33,600 --> 00:26:36,400
then very often you'll get back a an

708
00:26:36,400 --> 00:26:38,480
empty line

709
00:26:38,480 --> 00:26:40,320
so then this thing here f open by the

710
00:26:40,320 --> 00:26:42,640
way if you if you call that on a

711
00:26:42,640 --> 00:26:44,240
uh

712
00:26:44,240 --> 00:26:46,559
directory then this actually succeeds

713
00:26:46,559 --> 00:26:48,159
you get back a pointer you just can't do

714
00:26:48,159 --> 00:26:50,240
much with it right and then there's an f

715
00:26:50,240 --> 00:26:52,720
read operation here that they call on

716
00:26:52,720 --> 00:26:53,520
that

717
00:26:53,520 --> 00:26:55,919
and the f read uh

718
00:26:55,919 --> 00:26:57,279
they're not checking for the return

719
00:26:57,279 --> 00:26:59,919
value right so this f read will fail

720
00:26:59,919 --> 00:27:02,480
which means this buffer here ptr which

721
00:27:02,480 --> 00:27:04,720
is just some pointer onto the onto the

722
00:27:04,720 --> 00:27:05,520
heap

723
00:27:05,520 --> 00:27:08,000
uh it will be uninitialized

724
00:27:08,000 --> 00:27:10,000
and then they just write that back to us

725
00:27:10,000 --> 00:27:12,320
right so that's what it looks like you

726
00:27:12,320 --> 00:27:14,480
just say dot slash dot dot slash and so

727
00:27:14,480 --> 00:27:17,679
on bin ls right and then you get back

728
00:27:17,679 --> 00:27:20,080
memory and you run it again and you get

729
00:27:20,080 --> 00:27:20,880
back

730
00:27:20,880 --> 00:27:23,360
different memory right so typical hot

731
00:27:23,360 --> 00:27:26,000
bleed style kind of bug

732
00:27:26,000 --> 00:27:29,200
all right and then audio

733
00:27:29,200 --> 00:27:30,399
yeah

734
00:27:30,399 --> 00:27:32,159
so for my bug

735
00:27:32,159 --> 00:27:34,640
this was um

736
00:27:34,640 --> 00:27:36,960
yeah it was i i don't know

737
00:27:36,960 --> 00:27:38,159
to be honest it was a little bit

738
00:27:38,159 --> 00:27:40,080
disappointing uh that the

739
00:27:40,080 --> 00:27:41,919
the bug that they found so i definitely

740
00:27:41,919 --> 00:27:44,399
wanted to have a bug in my hand that is

741
00:27:44,399 --> 00:27:45,840
has a

742
00:27:45,840 --> 00:27:47,360
high impact

743
00:27:47,360 --> 00:27:50,960
um and i searched for a lot um and you

744
00:27:50,960 --> 00:27:53,679
know just because i've just started up i

745
00:27:53,679 --> 00:27:56,320
i wasn't really sure how to do it where

746
00:27:56,320 --> 00:27:57,919
to do it and so so there was a lot of

747
00:27:57,919 --> 00:27:59,840
trial and error involved but at some

748
00:27:59,840 --> 00:28:02,720
point i just stumbled upon this bug

749
00:28:02,720 --> 00:28:04,640
and i talked to a couple of people about

750
00:28:04,640 --> 00:28:06,000
it and they were like

751
00:28:06,000 --> 00:28:09,440
okay this could be pretty bad

752
00:28:09,440 --> 00:28:11,919
and also i found out that this is the

753
00:28:11,919 --> 00:28:13,520
kind of bug that

754
00:28:13,520 --> 00:28:16,720
router manufacturers have had

755
00:28:16,720 --> 00:28:18,480
you know problems with for a very long

756
00:28:18,480 --> 00:28:20,720
time and it was very surprising that

757
00:28:20,720 --> 00:28:23,360
this is still going on like hard-coded

758
00:28:23,360 --> 00:28:24,720
credentials

759
00:28:24,720 --> 00:28:26,240
so what's the bug

760
00:28:26,240 --> 00:28:29,840
um here the mtfwu

761
00:28:29,840 --> 00:28:33,520
binary of that more expensive device

762
00:28:33,520 --> 00:28:34,960
is um

763
00:28:34,960 --> 00:28:36,799
getting this is the git right the

764
00:28:36,799 --> 00:28:39,360
compiler output right so this is i this

765
00:28:39,360 --> 00:28:41,679
is how i started and um

766
00:28:41,679 --> 00:28:44,320
afterwards i'm going to show the query

767
00:28:44,320 --> 00:28:46,960
so the get m

768
00:28:46,960 --> 00:28:50,480
parameters here calls receive

769
00:28:50,480 --> 00:28:52,960
data from the outside and specifically

770
00:28:52,960 --> 00:28:55,120
three get m

771
00:28:55,120 --> 00:28:56,720
values are important

772
00:28:56,720 --> 00:29:01,360
http cookie http http act and http auth

773
00:29:01,360 --> 00:29:03,678
here

774
00:29:03,760 --> 00:29:05,919
if you look inside this function this is

775
00:29:05,919 --> 00:29:07,440
the main function

776
00:29:07,440 --> 00:29:08,480
you see

777
00:29:08,480 --> 00:29:09,840
at some point

778
00:29:09,840 --> 00:29:12,240
there is this string fw upload which

779
00:29:12,240 --> 00:29:14,000
looks like firmware upload so it could

780
00:29:14,000 --> 00:29:16,000
be something with the firmware and here

781
00:29:16,000 --> 00:29:17,520
we see now the string size of firmware

782
00:29:17,520 --> 00:29:19,440
is too large so that's very probably

783
00:29:19,440 --> 00:29:22,159
okay it's a firmware upload mechanism

784
00:29:22,159 --> 00:29:23,440
inside the

785
00:29:23,440 --> 00:29:25,440
admin web interface

786
00:29:25,440 --> 00:29:28,799
um and if we look further down here

787
00:29:28,799 --> 00:29:31,760
further up we see that the var

788
00:29:31,760 --> 00:29:34,399
ivar5 controls

789
00:29:34,399 --> 00:29:35,200
the

790
00:29:35,200 --> 00:29:37,840
uh this this call right

791
00:29:37,840 --> 00:29:41,120
so either five comes from the a eight

792
00:29:41,120 --> 00:29:43,760
eight f zero function so the return

793
00:29:43,760 --> 00:29:47,200
value of eight eight uh f zero and the

794
00:29:47,200 --> 00:29:49,520
this eight eight f zero so it should be

795
00:29:49,520 --> 00:29:51,679
some kind of authentication mechanism

796
00:29:51,679 --> 00:29:52,480
right

797
00:29:52,480 --> 00:29:55,840
and and the funny thing is it's it takes

798
00:29:55,840 --> 00:29:59,440
three uh variables here it takes pc r3

799
00:29:59,440 --> 00:30:01,520
which is the cookie and i've checked the

800
00:30:01,520 --> 00:30:02,960
cookie was indeed some kind of a

801
00:30:02,960 --> 00:30:04,640
mechanism um

802
00:30:04,640 --> 00:30:06,640
authentication mechanism by just

803
00:30:06,640 --> 00:30:08,080
checking the web requests that were

804
00:30:08,080 --> 00:30:10,080
being sent from the admin interface but

805
00:30:10,080 --> 00:30:13,760
also um two these these two which were a

806
00:30:13,760 --> 00:30:15,039
little bit efficient because we already

807
00:30:15,039 --> 00:30:17,840
have an authentication mechanism and why

808
00:30:17,840 --> 00:30:20,159
is it another auth right so why is there

809
00:30:20,159 --> 00:30:21,279
a second

810
00:30:21,279 --> 00:30:24,480
getamp here right and also the

811
00:30:24,480 --> 00:30:27,440
even weirder uh thing was

812
00:30:27,440 --> 00:30:29,200
this act here

813
00:30:29,200 --> 00:30:31,279
and this act is actually the variable

814
00:30:31,279 --> 00:30:34,320
that is being string compared over here

815
00:30:34,320 --> 00:30:35,279
so

816
00:30:35,279 --> 00:30:37,919
we have this action string that goes

817
00:30:37,919 --> 00:30:39,520
inside the authentication mechanism so

818
00:30:39,520 --> 00:30:41,760
that doesn't make any sense right

819
00:30:41,760 --> 00:30:44,480
um so let's look at the authentication

820
00:30:44,480 --> 00:30:45,520
uh

821
00:30:45,520 --> 00:30:47,679
function here ajf0

822
00:30:47,679 --> 00:30:50,399
and inside of it uh there are

823
00:30:50,399 --> 00:30:52,080
three interesting things so first of all

824
00:30:52,080 --> 00:30:53,600
we see that the

825
00:30:53,600 --> 00:30:55,919
first parameter here is only checked

826
00:30:55,919 --> 00:30:58,159
that it starts with the string uid

827
00:30:58,159 --> 00:30:59,360
equals

828
00:30:59,360 --> 00:31:04,000
and the first parameter of this ff 88 f0

829
00:31:04,000 --> 00:31:07,279
is pc bar 3 and pc r3 is the http cookie

830
00:31:07,279 --> 00:31:09,600
and the http cookie is exactly the value

831
00:31:09,600 --> 00:31:11,279
that is being used for normal

832
00:31:11,279 --> 00:31:13,360
authentication but in this case it's

833
00:31:13,360 --> 00:31:15,039
only checked for that it starts with the

834
00:31:15,039 --> 00:31:16,880
string uid equals

835
00:31:16,880 --> 00:31:20,559
so that's that's a bit weird and

836
00:31:20,559 --> 00:31:22,240
looking further down in the function we

837
00:31:22,240 --> 00:31:25,200
see another very weird thing is that the

838
00:31:25,200 --> 00:31:27,519
return value of this authentication

839
00:31:27,519 --> 00:31:29,519
function which controls the firmware up

840
00:31:29,519 --> 00:31:30,880
update mechanism

841
00:31:30,880 --> 00:31:31,919
is

842
00:31:31,919 --> 00:31:34,080
taking the value from string compare of

843
00:31:34,080 --> 00:31:36,000
its second parameter with this stack

844
00:31:36,000 --> 00:31:39,039
buffer and the stack second parameter pc

845
00:31:39,039 --> 00:31:40,159
part 2

846
00:31:40,159 --> 00:31:42,480
was this auth string

847
00:31:42,480 --> 00:31:44,480
and this odd string is compared with

848
00:31:44,480 --> 00:31:47,200
this stack buffer which is also a little

849
00:31:47,200 --> 00:31:49,360
bit weird and the stack buffer is just

850
00:31:49,360 --> 00:31:51,760
one line further up

851
00:31:51,760 --> 00:31:54,000
this is passed into another function

852
00:31:54,000 --> 00:31:55,760
eight four before together with

853
00:31:55,760 --> 00:31:58,640
parameter three and parameter three is

854
00:31:58,640 --> 00:32:01,760
pc bar one act so the action mechanisms

855
00:32:01,760 --> 00:32:03,600
so this is

856
00:32:03,600 --> 00:32:06,559
very very weird and if we look in eight

857
00:32:06,559 --> 00:32:09,600
four before a little bit closer we see

858
00:32:09,600 --> 00:32:11,679
there's a lot of things going going on

859
00:32:11,679 --> 00:32:14,000
here but we see mostly that we have this

860
00:32:14,000 --> 00:32:17,279
s printf call to the third parameter

861
00:32:17,279 --> 00:32:20,000
which means and this s printer of course

862
00:32:20,000 --> 00:32:23,200
has a format string with a hex value so

863
00:32:23,200 --> 00:32:25,919
it's it spits out a hex value of pb var

864
00:32:25,919 --> 00:32:27,039
3.

865
00:32:27,039 --> 00:32:28,880
so that means that somehow this

866
00:32:28,880 --> 00:32:31,760
parameter three is transformed through

867
00:32:31,760 --> 00:32:34,240
to a hex value of pb bar

868
00:32:34,240 --> 00:32:35,200
three

869
00:32:35,200 --> 00:32:37,840
parameter three from pb of r3 so this

870
00:32:37,840 --> 00:32:39,039
means

871
00:32:39,039 --> 00:32:39,919
that

872
00:32:39,919 --> 00:32:41,600
the actual

873
00:32:41,600 --> 00:32:44,399
the http cookie value that is usually

874
00:32:44,399 --> 00:32:46,240
used for authentication is completely

875
00:32:46,240 --> 00:32:49,120
ignored and instead the authentication

876
00:32:49,120 --> 00:32:52,559
of the firmware is a basically a

877
00:32:52,559 --> 00:32:54,399
transformation a hex let's say it could

878
00:32:54,399 --> 00:32:57,039
be md5 we could replace this this this

879
00:32:57,039 --> 00:33:01,360
function with md5 whatever um of

880
00:33:01,360 --> 00:33:04,000
of the other parameter act

881
00:33:04,000 --> 00:33:05,279
so

882
00:33:05,279 --> 00:33:06,799
actually

883
00:33:06,799 --> 00:33:10,640
it means that if you pass in a value for

884
00:33:10,640 --> 00:33:13,279
a a random value for http cookie that

885
00:33:13,279 --> 00:33:17,200
starts with uid equals and a hash value

886
00:33:17,200 --> 00:33:20,240
of uh hp act

887
00:33:20,240 --> 00:33:22,000
um

888
00:33:22,000 --> 00:33:25,760
act that equals the http auth then you

889
00:33:25,760 --> 00:33:28,640
can upload um replace the firmware of

890
00:33:28,640 --> 00:33:30,000
the device

891
00:33:30,000 --> 00:33:31,760
so this is not like a typical hardcoded

892
00:33:31,760 --> 00:33:33,519
credentials vulnerability where you just

893
00:33:33,519 --> 00:33:35,519
like string compare two things or where

894
00:33:35,519 --> 00:33:37,519
like whereas there's an actual string in

895
00:33:37,519 --> 00:33:39,760
the binary but it's a little bit more

896
00:33:39,760 --> 00:33:42,080
hidden inside the code

897
00:33:42,080 --> 00:33:43,120
okay

898
00:33:43,120 --> 00:33:43,919
so

899
00:33:43,919 --> 00:33:46,399
um let me show you the query

900
00:33:46,399 --> 00:33:47,840
so um

901
00:33:47,840 --> 00:33:49,840
this is just like a step-by-step guide

902
00:33:49,840 --> 00:33:52,159
how to build the query and the first one

903
00:33:52,159 --> 00:33:54,080
is just like you import the code you

904
00:33:54,080 --> 00:33:56,559
import the binary and after you have the

905
00:33:56,559 --> 00:33:58,240
binary you can look in the graph and you

906
00:33:58,240 --> 00:33:59,360
can see

907
00:33:59,360 --> 00:34:01,519
all these assembly instructions because

908
00:34:01,519 --> 00:34:03,519
now we're at the binary level

909
00:34:03,519 --> 00:34:05,440
but we don't want the assembly so we

910
00:34:05,440 --> 00:34:07,679
just take all the method nodes of the

911
00:34:07,679 --> 00:34:08,639
graph

912
00:34:08,639 --> 00:34:11,199
of the binary which contains the gidras

913
00:34:11,199 --> 00:34:14,719
decompiler output and we concat them to

914
00:34:14,719 --> 00:34:17,839
a large string with new lines and we

915
00:34:17,839 --> 00:34:21,119
import that we create a source c source

916
00:34:21,119 --> 00:34:22,079
based

917
00:34:22,079 --> 00:34:25,119
graph from that string

918
00:34:25,119 --> 00:34:27,918
so now we can run good

919
00:34:27,918 --> 00:34:31,599
data flow queries on it

920
00:34:31,599 --> 00:34:32,399
so

921
00:34:32,399 --> 00:34:34,079
now this is how it looks like right so

922
00:34:34,079 --> 00:34:35,599
we don't have the assembly instructions

923
00:34:35,599 --> 00:34:37,599
anymore now we see the actual code of

924
00:34:37,599 --> 00:34:40,560
the git right the compiler output

925
00:34:40,560 --> 00:34:42,960
and the same thing that fabs showed the

926
00:34:42,960 --> 00:34:46,239
attack surface tags um can be stored

927
00:34:46,239 --> 00:34:48,480
with like this type of command so that

928
00:34:48,480 --> 00:34:51,599
it's easier later to to reach those

929
00:34:51,599 --> 00:34:53,040
nodes

930
00:34:53,040 --> 00:34:55,040
um this is for example what you can do

931
00:34:55,040 --> 00:34:57,119
if we you've tagged the attack surface

932
00:34:57,119 --> 00:34:59,200
you can just like list all calls in the

933
00:34:59,200 --> 00:35:00,720
whole binary because you don't want to

934
00:35:00,720 --> 00:35:03,040
look like all over the code right you

935
00:35:03,040 --> 00:35:04,800
can just like do this and then you know

936
00:35:04,800 --> 00:35:06,480
exactly all the specific

937
00:35:06,480 --> 00:35:09,119
places where data comes in

938
00:35:09,119 --> 00:35:11,839
and um but now we want to write the

939
00:35:11,839 --> 00:35:15,200
actual query and the way it's um i did

940
00:35:15,200 --> 00:35:16,960
it i mean you can do it like any way you

941
00:35:16,960 --> 00:35:19,040
want but the way i did it was just to

942
00:35:19,040 --> 00:35:21,920
start at the the heart of the problem

943
00:35:21,920 --> 00:35:24,480
which was the s printf call to the third

944
00:35:24,480 --> 00:35:27,119
parameter so what you can just do is

945
00:35:27,119 --> 00:35:29,920
give me all nodes of s print f where the

946
00:35:29,920 --> 00:35:32,000
second argument is a literal that has

947
00:35:32,000 --> 00:35:34,720
this x uh that matches this regex which

948
00:35:34,720 --> 00:35:37,680
is uh the hex transform so it's like it

949
00:35:37,680 --> 00:35:39,359
basically takes the

950
00:35:39,359 --> 00:35:42,320
source parameter and it um makes a hex

951
00:35:42,320 --> 00:35:44,079
transformation to the destination

952
00:35:44,079 --> 00:35:45,680
parameter right

953
00:35:45,680 --> 00:35:47,839
so this is s printf transform which

954
00:35:47,839 --> 00:35:49,680
matches this one line

955
00:35:49,680 --> 00:35:52,400
for the second line we want the 84b4

956
00:35:52,400 --> 00:35:53,359
function

957
00:35:53,359 --> 00:35:56,240
right which actually calls as printf

958
00:35:56,240 --> 00:35:58,480
right so we want that that function to

959
00:35:58,480 --> 00:36:01,040
be passed some uh to to be identified by

960
00:36:01,040 --> 00:36:03,520
the query and in this case we just write

961
00:36:03,520 --> 00:36:04,960
s print f transform so this is the

962
00:36:04,960 --> 00:36:07,680
method that we just found and we take

963
00:36:07,680 --> 00:36:10,079
all of the method that contains s printf

964
00:36:10,079 --> 00:36:11,280
transforms

965
00:36:11,280 --> 00:36:13,839
and then we run two data flow queries to

966
00:36:13,839 --> 00:36:16,320
see if those methods actually reach the

967
00:36:16,320 --> 00:36:17,599
s printf

968
00:36:17,599 --> 00:36:19,599
so and and in this specific case you can

969
00:36:19,599 --> 00:36:22,240
see s printf this is that call over here

970
00:36:22,240 --> 00:36:23,839
and then we check if one of the

971
00:36:23,839 --> 00:36:26,000
parameters reaches the source and one of

972
00:36:26,000 --> 00:36:28,480
the parameters reaches the destination

973
00:36:28,480 --> 00:36:31,280
of the method s printf

974
00:36:31,280 --> 00:36:33,839
and we call this parameter hex transform

975
00:36:33,839 --> 00:36:36,000
this is this all made up names is just

976
00:36:36,000 --> 00:36:38,320
like easier to remember at least for in

977
00:36:38,320 --> 00:36:40,400
my case so we have parameter hex

978
00:36:40,400 --> 00:36:43,359
transform is the 84b4 function

979
00:36:43,359 --> 00:36:45,040
and we go back to our bug we remember

980
00:36:45,040 --> 00:36:47,040
that the 84b4 function was the fishy

981
00:36:47,040 --> 00:36:49,119
function that was that transformed the

982
00:36:49,119 --> 00:36:51,359
stack buffer here right

983
00:36:51,359 --> 00:36:53,040
so we have

984
00:36:53,040 --> 00:36:54,640
the parameter hex transform is the eight

985
00:36:54,640 --> 00:36:56,160
four before uh

986
00:36:56,160 --> 00:36:59,200
function so and we want to take all the

987
00:36:59,200 --> 00:37:01,040
callers of this function

988
00:37:01,040 --> 00:37:03,280
and we want to see if there

989
00:37:03,280 --> 00:37:05,200
is a string compare

990
00:37:05,200 --> 00:37:07,359
from one of it if there is a data flow

991
00:37:07,359 --> 00:37:10,000
from the parameter of this caller to the

992
00:37:10,000 --> 00:37:11,280
string compare

993
00:37:11,280 --> 00:37:14,720
and also if there is um if that same

994
00:37:14,720 --> 00:37:18,000
function that calls the the um parameter

995
00:37:18,000 --> 00:37:21,920
hex transform also has a data flow to

996
00:37:21,920 --> 00:37:24,960
the um parameter hex transform

997
00:37:24,960 --> 00:37:27,359
so then you have both of them together

998
00:37:27,359 --> 00:37:29,119
and this can be improved a little bit

999
00:37:29,119 --> 00:37:32,640
but um and i mean it

1000
00:37:32,640 --> 00:37:34,640
it's it's it's good enough to detect

1001
00:37:34,640 --> 00:37:37,440
this bug so then we have the compare

1002
00:37:37,440 --> 00:37:38,880
transform and then

1003
00:37:38,880 --> 00:37:40,400
the only thing we have to say is that

1004
00:37:40,400 --> 00:37:43,680
okay the is there a um data flow from

1005
00:37:43,680 --> 00:37:45,760
the attack surface from the get em calls

1006
00:37:45,760 --> 00:37:48,960
to this function and did we find that

1007
00:37:48,960 --> 00:37:51,520
and this is the the the whole query how

1008
00:37:51,520 --> 00:37:53,200
it looks like

1009
00:37:53,200 --> 00:37:56,000
um when you run it you get

1010
00:37:56,000 --> 00:37:56,800
this

1011
00:37:56,800 --> 00:37:58,560
you get this output so you get these

1012
00:37:58,560 --> 00:38:00,880
three environment variables and

1013
00:38:00,880 --> 00:38:02,079
obviously

1014
00:38:02,079 --> 00:38:03,520
the next step would be to actually

1015
00:38:03,520 --> 00:38:05,839
confirm the bug and you can do it in

1016
00:38:05,839 --> 00:38:08,880
many ways the way i did was just with

1017
00:38:08,880 --> 00:38:10,880
ld preload where you can just write a

1018
00:38:10,880 --> 00:38:13,680
custom version of string compare

1019
00:38:13,680 --> 00:38:15,760
in this case that prints out

1020
00:38:15,760 --> 00:38:18,800
the strings that are compared

1021
00:38:18,800 --> 00:38:21,119
and then you just run this on one of the

1022
00:38:21,119 --> 00:38:23,520
acts which is get device info and you

1023
00:38:23,520 --> 00:38:26,320
get the hard-coded credentials for that

1024
00:38:26,320 --> 00:38:27,599
specific action that gives you the

1025
00:38:27,599 --> 00:38:29,920
device information and then you can do

1026
00:38:29,920 --> 00:38:32,160
the same with firmware upload and

1027
00:38:32,160 --> 00:38:33,920
firmware update and then you get the

1028
00:38:33,920 --> 00:38:36,240
hard-coded credentials for those instead

1029
00:38:36,240 --> 00:38:37,760
of going inside the function and trying

1030
00:38:37,760 --> 00:38:39,200
to figure out what's going on and all

1031
00:38:39,200 --> 00:38:42,720
those bitwise operators and whatever

1032
00:38:42,720 --> 00:38:44,880
and this is all good but you know it's

1033
00:38:44,880 --> 00:38:46,320
not super interesting because it's a

1034
00:38:46,320 --> 00:38:49,200
land-based vulnerability uh so you know

1035
00:38:49,200 --> 00:38:51,119
it's like kind of hard to exploit but it

1036
00:38:51,119 --> 00:38:53,119
would be interesting if we were also

1037
00:38:53,119 --> 00:38:56,480
remotely exploitable right so um

1038
00:38:56,480 --> 00:38:58,720
a colleague of mine bernhard suggested i

1039
00:38:58,720 --> 00:39:01,440
should try a dns rebinding attack to

1040
00:39:01,440 --> 00:39:03,040
combine this with the dns rebinding

1041
00:39:03,040 --> 00:39:05,920
attack so um this is very easy to do

1042
00:39:05,920 --> 00:39:07,599
also it was my first time doing it but i

1043
00:39:07,599 --> 00:39:10,079
highly recommend you try it out um you

1044
00:39:10,079 --> 00:39:12,720
can just use the singularity from ncc

1045
00:39:12,720 --> 00:39:14,800
group this tool where you can just spin

1046
00:39:14,800 --> 00:39:17,040
up an aws instance you install the

1047
00:39:17,040 --> 00:39:18,720
single reality server it's very easy

1048
00:39:18,720 --> 00:39:21,839
it's like in five minutes um you open

1049
00:39:21,839 --> 00:39:24,320
you know the firewall ports on the aws

1050
00:39:24,320 --> 00:39:25,920
instance and you have to do a couple of

1051
00:39:25,920 --> 00:39:29,280
configurations you buy a domain name and

1052
00:39:29,280 --> 00:39:32,240
then you can just trigger a

1053
00:39:32,240 --> 00:39:34,480
dns reminding attack and what's going on

1054
00:39:34,480 --> 00:39:36,640
over here is that

1055
00:39:36,640 --> 00:39:39,440
i this grandma's secret recipe this was

1056
00:39:39,440 --> 00:39:41,680
on my local computer

1057
00:39:41,680 --> 00:39:42,400
and

1058
00:39:42,400 --> 00:39:43,520
um

1059
00:39:43,520 --> 00:39:46,320
the browser should actually protect

1060
00:39:46,320 --> 00:39:48,160
against this right should actually

1061
00:39:48,160 --> 00:39:50,800
protect against this this this type of

1062
00:39:50,800 --> 00:39:52,160
thing so you cannot just like go to a

1063
00:39:52,160 --> 00:39:54,160
web page and the web page can request

1064
00:39:54,160 --> 00:39:55,839
stuff from your local machine right so

1065
00:39:55,839 --> 00:39:57,760
this is what cores protect

1066
00:39:57,760 --> 00:40:00,160
against but if you

1067
00:40:00,160 --> 00:40:01,920
manage a dns rebinding attack which

1068
00:40:01,920 --> 00:40:04,400
works like you open a web page and the

1069
00:40:04,400 --> 00:40:07,520
web page gives back a dns response with

1070
00:40:07,520 --> 00:40:10,720
a very short time to live and the next

1071
00:40:10,720 --> 00:40:12,480
time the browser request of the the

1072
00:40:12,480 --> 00:40:14,960
webpage that the customer already shows

1073
00:40:14,960 --> 00:40:17,200
the next time the the request goes out

1074
00:40:17,200 --> 00:40:20,319
the dns response is to a local address

1075
00:40:20,319 --> 00:40:23,119
and then with that you can actually show

1076
00:40:23,119 --> 00:40:25,599
a web page to um

1077
00:40:25,599 --> 00:40:27,520
to a person and

1078
00:40:27,520 --> 00:40:28,560
then

1079
00:40:28,560 --> 00:40:29,920
you can

1080
00:40:29,920 --> 00:40:33,440
send hp request to any local

1081
00:40:33,440 --> 00:40:35,920
ip address or of the local network for

1082
00:40:35,920 --> 00:40:38,400
example the router so to combine this

1083
00:40:38,400 --> 00:40:39,520
with the bug

1084
00:40:39,520 --> 00:40:41,040
we can just show

1085
00:40:41,040 --> 00:40:45,040
a web page to the to anyone um and with

1086
00:40:45,040 --> 00:40:47,680
this router and then we can exchange the

1087
00:40:47,680 --> 00:40:49,920
firmware on the fly

1088
00:40:49,920 --> 00:40:51,280
which means

1089
00:40:51,280 --> 00:40:54,319
it's partnered ready

1090
00:41:02,720 --> 00:41:04,480
all right i'm just gonna wrap this up

1091
00:41:04,480 --> 00:41:06,560
now so notes on disclosure we did

1092
00:41:06,560 --> 00:41:09,119
contact the vendor over 90 days ago in

1093
00:41:09,119 --> 00:41:10,079
august

1094
00:41:10,079 --> 00:41:11,040
gave them

1095
00:41:11,040 --> 00:41:12,640
an initial bug

1096
00:41:12,640 --> 00:41:14,160
they said

1097
00:41:14,160 --> 00:41:16,400
that they would forward this to their r

1098
00:41:16,400 --> 00:41:17,920
d team

1099
00:41:17,920 --> 00:41:20,480
and they would contact us uh but they

1100
00:41:20,480 --> 00:41:22,240
never really got back to us so we

1101
00:41:22,240 --> 00:41:24,880
contacted them again uh like very early

1102
00:41:24,880 --> 00:41:27,119
in november uh because we wanted to talk

1103
00:41:27,119 --> 00:41:29,520
about this and we said hey you know

1104
00:41:29,520 --> 00:41:32,000
what happened to our bug and also uh

1105
00:41:32,000 --> 00:41:34,800
here is another bug you know

1106
00:41:34,800 --> 00:41:38,800
if you like but no response so um yeah i

1107
00:41:38,800 --> 00:41:40,880
mean i'm i'm hoping that um

1108
00:41:40,880 --> 00:41:42,160
i mean

1109
00:41:42,160 --> 00:41:43,599
maybe they'll see the talk maybe they'll

1110
00:41:43,599 --> 00:41:45,760
fix it maybe not but um you know we

1111
00:41:45,760 --> 00:41:48,000
tried we really tried so i just want to

1112
00:41:48,000 --> 00:41:49,680
say that

1113
00:41:49,680 --> 00:41:52,160
so uh to conclude um

1114
00:41:52,160 --> 00:41:54,160
yeah it's it's really nice to make a

1115
00:41:54,160 --> 00:41:55,839
disassembly available in a graph

1116
00:41:55,839 --> 00:41:58,079
database to then query it but where it

1117
00:41:58,079 --> 00:42:00,160
gets really powerful is you have if you

1118
00:42:00,160 --> 00:42:01,280
have something that's a bit more high

1119
00:42:01,280 --> 00:42:03,040
level something that you would get from

1120
00:42:03,040 --> 00:42:04,800
from a decompiler and that's what we're

1121
00:42:04,800 --> 00:42:06,560
using as our baseline now and it's just

1122
00:42:06,560 --> 00:42:08,240
amazing how

1123
00:42:08,240 --> 00:42:09,839
even though this is actually from a

1124
00:42:09,839 --> 00:42:13,119
binary it's sufficiently

1125
00:42:13,119 --> 00:42:16,480
c-ish to use the exact same queries

1126
00:42:16,480 --> 00:42:18,480
um and um

1127
00:42:18,480 --> 00:42:20,079
yeah uh

1128
00:42:20,079 --> 00:42:22,800
the you you saw two types of querying

1129
00:42:22,800 --> 00:42:25,200
one is like okay i'm gonna write about

1130
00:42:25,200 --> 00:42:27,280
something that i think is going to be

1131
00:42:27,280 --> 00:42:29,200
broken in a particular way and then just

1132
00:42:29,200 --> 00:42:31,040
get out the box and then what claudio

1133
00:42:31,040 --> 00:42:32,960
showed you is he had something that he

1134
00:42:32,960 --> 00:42:36,160
wanted to characterize across devices

1135
00:42:36,160 --> 00:42:38,880
kind of create a very complex signature

1136
00:42:38,880 --> 00:42:40,720
that generalizes enough to use this

1137
00:42:40,720 --> 00:42:42,400
across devices and those are like the

1138
00:42:42,400 --> 00:42:44,400
two use cases that you can go with with

1139
00:42:44,400 --> 00:42:46,480
those with those kinds of

1140
00:42:46,480 --> 00:42:47,839
queries

1141
00:42:47,839 --> 00:42:49,520
and the reason we do this on binary

1142
00:42:49,520 --> 00:42:51,599
really is that the parser that we have

1143
00:42:51,599 --> 00:42:54,800
in yeon is extremely robust meaning you

1144
00:42:54,800 --> 00:42:56,480
can feed it anything that kind of looks

1145
00:42:56,480 --> 00:42:58,319
like c and it will do its best job to

1146
00:42:58,319 --> 00:43:00,000
create abstract syntax trees and control

1147
00:43:00,000 --> 00:43:02,160
flow graphs and these kinds of things

1148
00:43:02,160 --> 00:43:03,920
so it is really a parser designed for

1149
00:43:03,920 --> 00:43:07,040
hackers if some code fell off a truck

1150
00:43:07,040 --> 00:43:08,640
you don't need to start configuring a

1151
00:43:08,640 --> 00:43:10,400
build environment because you can't

1152
00:43:10,400 --> 00:43:12,880
right you can use this on whatever code

1153
00:43:12,880 --> 00:43:15,280
that you have and the decompiler output

1154
00:43:15,280 --> 00:43:17,520
from gedra compared to code that just

1155
00:43:17,520 --> 00:43:21,200
fell off a truck is actually quite tame

1156
00:43:21,200 --> 00:43:23,119
oh yeah and finally i guess yeah it's

1157
00:43:23,119 --> 00:43:24,960
quite scary certain consumer-grade

1158
00:43:24,960 --> 00:43:27,839
routers they're remarkably insecure

1159
00:43:27,839 --> 00:43:30,560
we didn't have to try very hard

1160
00:43:30,560 --> 00:43:32,570
thank you

1161
00:43:32,570 --> 00:43:42,110
[Applause]

1162
00:43:42,110 --> 00:44:00,270
[Music]

