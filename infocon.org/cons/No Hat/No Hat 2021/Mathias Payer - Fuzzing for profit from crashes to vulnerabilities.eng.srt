1
00:00:02,480 --> 00:00:05,260
uh

2
00:00:05,260 --> 00:00:08,500
[Music]

3
00:00:10,700 --> 00:00:21,039
[Music]

4
00:00:21,039 --> 00:00:24,039
me

5
00:00:24,410 --> 00:00:30,720
[Music]

6
00:00:30,720 --> 00:00:33,440
very good uh it's a pleasure to be back

7
00:00:33,440 --> 00:00:35,280
on the conference circus

8
00:00:35,280 --> 00:00:37,120
um it's been a while

9
00:00:37,120 --> 00:00:39,680
many as many like

10
00:00:39,680 --> 00:00:41,680
as many of you had the same experience

11
00:00:41,680 --> 00:00:42,800
it's been

12
00:00:42,800 --> 00:00:45,120
a long time without actually going to

13
00:00:45,120 --> 00:00:47,120
on-site talks and this is a super

14
00:00:47,120 --> 00:00:49,440
amazing opportunity to actually talk to

15
00:00:49,440 --> 00:00:50,879
you about some of the fun stuff that we

16
00:00:50,879 --> 00:00:52,559
have been doing

17
00:00:52,559 --> 00:00:53,360
um

18
00:00:53,360 --> 00:00:55,680
this conference is called no hat

19
00:00:55,680 --> 00:00:58,559
and uh i figured well actually as we're

20
00:00:58,559 --> 00:01:00,399
riding the the fuzzing

21
00:01:00,399 --> 00:01:02,879
pipe train and trying to figure out if

22
00:01:02,879 --> 00:01:04,000
we can

23
00:01:04,000 --> 00:01:05,040
find

24
00:01:05,040 --> 00:01:07,040
vulnerabilities and use fuzzing to

25
00:01:07,040 --> 00:01:08,000
discover different kind of

26
00:01:08,000 --> 00:01:09,680
vulnerabilities we're still wearing some

27
00:01:09,680 --> 00:01:11,439
form of hat right

28
00:01:11,439 --> 00:01:13,520
but this can be an arbitrary warm hat

29
00:01:13,520 --> 00:01:15,439
this winter is coming and we'll see what

30
00:01:15,439 --> 00:01:17,520
uh what we can do a little bit about me

31
00:01:17,520 --> 00:01:19,840
i'm an academic but that shouldn't stop

32
00:01:19,840 --> 00:01:21,520
you from listening to me

33
00:01:21,520 --> 00:01:24,000
it just means that i'm giving you tools

34
00:01:24,000 --> 00:01:26,799
while you can still find bugs with them

35
00:01:26,799 --> 00:01:28,479
right so we've had this discussion a

36
00:01:28,479 --> 00:01:29,759
while and

37
00:01:29,759 --> 00:01:32,400
yesterday during dinner for example and

38
00:01:32,400 --> 00:01:34,320
one of the big differences is if

39
00:01:34,320 --> 00:01:36,479
security researchers give talk

40
00:01:36,479 --> 00:01:39,280
that are primarily interested in

41
00:01:39,280 --> 00:01:41,200
bug bounties they will only release

42
00:01:41,200 --> 00:01:43,680
their tools whenever their

43
00:01:43,680 --> 00:01:46,079
tool no longer finds any effective bugs

44
00:01:46,079 --> 00:01:48,560
what we researchers do is we try to get

45
00:01:48,560 --> 00:01:50,560
as much fame as possible and we want to

46
00:01:50,560 --> 00:01:53,520
release tools much earlier than than

47
00:01:53,520 --> 00:01:56,719
others so we do a proof of concept

48
00:01:56,719 --> 00:01:58,399
we show that a new technique is actually

49
00:01:58,399 --> 00:02:00,079
useful and

50
00:02:00,079 --> 00:02:02,079
as researchers or as academics we have

51
00:02:02,079 --> 00:02:04,560
to be poor so we're not trying to get as

52
00:02:04,560 --> 00:02:06,320
many as much money out of the bug bunty

53
00:02:06,320 --> 00:02:08,160
programs as possible but we're releasing

54
00:02:08,160 --> 00:02:11,120
tools so that you folks can actually use

55
00:02:11,120 --> 00:02:13,040
them so all the different things that

56
00:02:13,040 --> 00:02:15,840
i'm talking about today are open source

57
00:02:15,840 --> 00:02:17,440
you can download them you can play with

58
00:02:17,440 --> 00:02:18,879
them you can figure them out you can

59
00:02:18,879 --> 00:02:21,120
integrate them into your tool chains and

60
00:02:21,120 --> 00:02:23,760
you should right so

61
00:02:23,760 --> 00:02:25,599
just to give you a bit of perspective of

62
00:02:25,599 --> 00:02:27,200
what kind of research we are doing we

63
00:02:27,200 --> 00:02:29,760
are working on on three large areas in

64
00:02:29,760 --> 00:02:31,920
my uh in my group and i've got about

65
00:02:31,920 --> 00:02:34,400
20ish people working on on different

66
00:02:34,400 --> 00:02:37,360
aspects uh we do software testing we do

67
00:02:37,360 --> 00:02:39,760
mitigations and we do compartments

68
00:02:39,760 --> 00:02:41,680
um compartments is like you have large

69
00:02:41,680 --> 00:02:43,280
complex software you break it into small

70
00:02:43,280 --> 00:02:44,720
components you do fault domains and you

71
00:02:44,720 --> 00:02:46,800
try to figure out that this actually uh

72
00:02:46,800 --> 00:02:48,560
makes your system a bit more secure

73
00:02:48,560 --> 00:02:50,560
mitigations i'm sure you know control

74
00:02:50,560 --> 00:02:52,879
flow integrity shadow stacks and so on

75
00:02:52,879 --> 00:02:54,560
uh this is also an area that we're

76
00:02:54,560 --> 00:02:56,640
doubling in a bit but most interesting

77
00:02:56,640 --> 00:02:58,800
to you because you want to make money is

78
00:02:58,800 --> 00:03:01,360
software testing and software testing is

79
00:03:01,360 --> 00:03:03,440
a tool to help the developer to prune

80
00:03:03,440 --> 00:03:05,760
bugs

81
00:03:05,760 --> 00:03:07,200
using fuzzing to discover them and

82
00:03:07,200 --> 00:03:09,840
sanitization to detect them

83
00:03:09,840 --> 00:03:10,959
now

84
00:03:10,959 --> 00:03:12,720
that aside right we're going to focus on

85
00:03:12,720 --> 00:03:15,120
on fuzzing and bug finding and turning

86
00:03:15,120 --> 00:03:17,519
stuff into exploitable crashes from now

87
00:03:17,519 --> 00:03:19,280
on

88
00:03:19,280 --> 00:03:22,000
i've looked around at the last couple of

89
00:03:22,000 --> 00:03:24,319
conferences just this year

90
00:03:24,319 --> 00:03:26,159
academic and

91
00:03:26,159 --> 00:03:28,000
hacker conferences as well and all of

92
00:03:28,000 --> 00:03:29,440
these top conferences have something

93
00:03:29,440 --> 00:03:31,599
something in common just looking at the

94
00:03:31,599 --> 00:03:33,120
program each of these conferences has

95
00:03:33,120 --> 00:03:35,440
like a full session or two sessions or

96
00:03:35,440 --> 00:03:37,840
three sessions on fuzzing does using

97
00:03:37,840 --> 00:03:43,280
security um this is uh ndss this is um

98
00:03:43,280 --> 00:03:45,200
oh sorry first was smp this is using

99
00:03:45,200 --> 00:03:49,360
security and um there's there's raid ccs

100
00:03:49,360 --> 00:03:50,799
was just lost

101
00:03:50,799 --> 00:03:52,799
last week or this week it had two

102
00:03:52,799 --> 00:03:55,680
sessions on on fuzzing so fuzzing is a

103
00:03:55,680 --> 00:03:58,080
very hot and ongoing topic

104
00:03:58,080 --> 00:04:00,080
now you may wonder why why are we doing

105
00:04:00,080 --> 00:04:01,680
fuzzing right we've been uh we've just

106
00:04:01,680 --> 00:04:03,280
heard from david that we've been doing

107
00:04:03,280 --> 00:04:06,080
security for 20 30 years right

108
00:04:06,080 --> 00:04:07,760
why is this uh why is this still

109
00:04:07,760 --> 00:04:09,599
interesting right well

110
00:04:09,599 --> 00:04:12,239
bugs are still everywhere there's bugs

111
00:04:12,239 --> 00:04:13,920
wherever you look right and you just

112
00:04:13,920 --> 00:04:15,599
have to poke the software a little bit

113
00:04:15,599 --> 00:04:17,759
it's going to explode in your face and

114
00:04:17,759 --> 00:04:19,918
crash and some of these explosions can

115
00:04:19,918 --> 00:04:22,400
actually have some collateral damage and

116
00:04:22,400 --> 00:04:23,919
allow the attacker to take over your

117
00:04:23,919 --> 00:04:25,040
system

118
00:04:25,040 --> 00:04:27,280
uh as many bugs are exploitable right

119
00:04:27,280 --> 00:04:29,520
then this can result in your system

120
00:04:29,520 --> 00:04:31,759
being compromised by ransomware your

121
00:04:31,759 --> 00:04:34,400
virtual machine being taken over your

122
00:04:34,400 --> 00:04:37,120
super fancy new electric car being

123
00:04:37,120 --> 00:04:39,759
turned into a remotely controlled toy

124
00:04:39,759 --> 00:04:42,400
vehicle which is fun for the hacker on

125
00:04:42,400 --> 00:04:44,240
the control is not so much fun for you

126
00:04:44,240 --> 00:04:46,160
sitting in the car it can invade your

127
00:04:46,160 --> 00:04:48,639
physical spaces uh by turning smart

128
00:04:48,639 --> 00:04:51,040
locks into uh matching opening devices

129
00:04:51,040 --> 00:04:52,320
and so on

130
00:04:52,320 --> 00:04:53,120
right

131
00:04:53,120 --> 00:04:56,000
um going back to what what i said before

132
00:04:56,000 --> 00:04:57,440
there's the difference between software

133
00:04:57,440 --> 00:05:00,240
testing and mitigations we could now

134
00:05:00,240 --> 00:05:02,160
put in a lot of effort into mitigation

135
00:05:02,160 --> 00:05:03,919
making the exploitation of these bugs as

136
00:05:03,919 --> 00:05:06,400
hard as possible but this wouldn't

137
00:05:06,400 --> 00:05:07,919
help us in

138
00:05:07,919 --> 00:05:09,600
removing the bugs from the software

139
00:05:09,600 --> 00:05:11,199
right it would just make exploitation

140
00:05:11,199 --> 00:05:14,000
harder and you hackers are clever you

141
00:05:14,000 --> 00:05:16,000
will figure out a way to actually get

142
00:05:16,000 --> 00:05:18,160
around these mitigations and develop

143
00:05:18,160 --> 00:05:20,320
tooling and so on so it's not going to

144
00:05:20,320 --> 00:05:22,320
be super effective on the other hand if

145
00:05:22,320 --> 00:05:24,000
you actually use software testing to

146
00:05:24,000 --> 00:05:24,880
find

147
00:05:24,880 --> 00:05:26,320
all these vulnerabilities we have an

148
00:05:26,320 --> 00:05:28,000
opportunity to fix

149
00:05:28,000 --> 00:05:30,160
the code and actually make them reduce

150
00:05:30,160 --> 00:05:32,880
the exploitability

151
00:05:32,880 --> 00:05:35,520
you may remember from other academics

152
00:05:35,520 --> 00:05:37,600
there's tools like

153
00:05:37,600 --> 00:05:40,400
symbolic execution formal verification

154
00:05:40,400 --> 00:05:42,240
and so on these are all great if your

155
00:05:42,240 --> 00:05:44,800
code size is less than 100 lines of code

156
00:05:44,800 --> 00:05:46,320
right if you have a little bit more

157
00:05:46,320 --> 00:05:48,880
complex code than that

158
00:05:48,880 --> 00:05:50,960
it's a bit more difficult right and last

159
00:05:50,960 --> 00:05:54,320
time i checked and looked at our code

160
00:05:54,320 --> 00:05:56,400
for example the

161
00:05:56,400 --> 00:05:57,840
google chrome

162
00:05:57,840 --> 00:05:58,800
um

163
00:05:58,800 --> 00:06:01,360
the browser there's more than 100

164
00:06:01,360 --> 00:06:02,639
million lines of code that you're

165
00:06:02,639 --> 00:06:05,199
running as part of the software stack

166
00:06:05,199 --> 00:06:07,199
there's no way that you can formally

167
00:06:07,199 --> 00:06:08,880
verify this there's no way you can

168
00:06:08,880 --> 00:06:10,960
symbolically execute it and just for

169
00:06:10,960 --> 00:06:12,960
reference in code complexity because

170
00:06:12,960 --> 00:06:14,639
like 100 million lines of code is really

171
00:06:14,639 --> 00:06:17,039
really hard to imagine

172
00:06:17,039 --> 00:06:19,120
i i have two pictures here one of them

173
00:06:19,120 --> 00:06:21,199
is margaret hamilton who was responsible

174
00:06:21,199 --> 00:06:23,120
for the apollo guidance computer you're

175
00:06:23,120 --> 00:06:24,880
too young for that but that's that thing

176
00:06:24,880 --> 00:06:26,880
flew to the moon on very primitive

177
00:06:26,880 --> 00:06:29,039
hardware and they printed out the the

178
00:06:29,039 --> 00:06:30,479
software stack that was running on the

179
00:06:30,479 --> 00:06:32,639
system in assembly code and like if

180
00:06:32,639 --> 00:06:34,080
you're generous there's about two meters

181
00:06:34,080 --> 00:06:36,160
of software complexity right if you

182
00:06:36,160 --> 00:06:38,080
print out the google source code uh we

183
00:06:38,080 --> 00:06:40,560
have about 400 meters of complexity

184
00:06:40,560 --> 00:06:42,400
uh in a high-level language so this is

185
00:06:42,400 --> 00:06:44,560
much more much more complex and much

186
00:06:44,560 --> 00:06:46,720
harder to assess so we need some form of

187
00:06:46,720 --> 00:06:48,960
automated techniques to actually handle

188
00:06:48,960 --> 00:06:50,960
this massive amount of complexity

189
00:06:50,960 --> 00:06:53,039
without it breaking down

190
00:06:53,039 --> 00:06:55,520
david luckily already introduced fuzzing

191
00:06:55,520 --> 00:06:58,720
um i'm just gonna do it one more time

192
00:06:58,720 --> 00:07:00,800
because we saw that a lot of people

193
00:07:00,800 --> 00:07:03,280
actually did not work with fuzzing yet

194
00:07:03,280 --> 00:07:05,280
so if you regret not holding up your

195
00:07:05,280 --> 00:07:07,199
hand before i will bore you for two

196
00:07:07,199 --> 00:07:09,440
minutes about how fuzzing actually works

197
00:07:09,440 --> 00:07:12,000
um if you already do fuzzing bear with

198
00:07:12,000 --> 00:07:13,520
me this is going to get

199
00:07:13,520 --> 00:07:15,360
more interesting very very quickly so

200
00:07:15,360 --> 00:07:17,680
fuzzing international you have a target

201
00:07:17,680 --> 00:07:19,440
program a software under test as david

202
00:07:19,440 --> 00:07:21,840
called it you run it you pass it some

203
00:07:21,840 --> 00:07:25,039
parameters uh you see if it crashes

204
00:07:25,039 --> 00:07:27,599
a simple fuzzer is while true you just

205
00:07:27,599 --> 00:07:29,199
throw random stuff with it and you see

206
00:07:29,199 --> 00:07:31,840
if it you you remember if it crashes and

207
00:07:31,840 --> 00:07:32,880
the main

208
00:07:32,880 --> 00:07:34,880
goal of fuzzing is

209
00:07:34,880 --> 00:07:37,120
don't be clever don't spend too many

210
00:07:37,120 --> 00:07:40,080
cycles don't overthink it be fast as

211
00:07:40,080 --> 00:07:42,400
many executions as possible we want to

212
00:07:42,400 --> 00:07:44,960
know if this input crashes if the input

213
00:07:44,960 --> 00:07:47,520
crashes will set it aside and use it for

214
00:07:47,520 --> 00:07:49,440
later analysis

215
00:07:49,440 --> 00:07:52,080
um so we have this input we run the

216
00:07:52,080 --> 00:07:53,680
program under test in some kind of

217
00:07:53,680 --> 00:07:56,240
virtual environment we see if it crashes

218
00:07:56,240 --> 00:07:58,479
if it crashes we store the input set the

219
00:07:58,479 --> 00:07:59,919
input aside and keep it for later

220
00:07:59,919 --> 00:08:01,599
analysis this helps the developer to

221
00:08:01,599 --> 00:08:03,039
actually have a

222
00:08:03,039 --> 00:08:04,160
witness

223
00:08:04,160 --> 00:08:06,080
if you run the program with this input

224
00:08:06,080 --> 00:08:08,240
it's going to crash and

225
00:08:08,240 --> 00:08:10,080
you can use this for debugging to fix

226
00:08:10,080 --> 00:08:12,479
and identify the bug

227
00:08:12,479 --> 00:08:14,160
and there's obviously a loop right we

228
00:08:14,160 --> 00:08:15,599
run the program we create new we

229
00:08:15,599 --> 00:08:17,120
generate new input we run it again we

230
00:08:17,120 --> 00:08:18,800
run it again if it crashes we store it

231
00:08:18,800 --> 00:08:20,879
and we do this until we run out of

232
00:08:20,879 --> 00:08:22,080
resources

233
00:08:22,080 --> 00:08:24,479
now this is fairly dumped and this has

234
00:08:24,479 --> 00:08:26,800
been like that until

235
00:08:26,800 --> 00:08:30,000
2010 ish where we just do random random

236
00:08:30,000 --> 00:08:32,559
changes to the uh to the input

237
00:08:32,559 --> 00:08:34,399
and hope that we will trigger some more

238
00:08:34,399 --> 00:08:36,000
interesting behavior

239
00:08:36,000 --> 00:08:38,399
now if you use some form of information

240
00:08:38,399 --> 00:08:40,159
about the program just like a note of

241
00:08:40,159 --> 00:08:41,679
which kind of functionality has been

242
00:08:41,679 --> 00:08:44,720
executed we know which inputs that we

243
00:08:44,720 --> 00:08:46,880
randomly create trigger some kind of

244
00:08:46,880 --> 00:08:48,399
interesting behavior

245
00:08:48,399 --> 00:08:50,480
and then instead of

246
00:08:50,480 --> 00:08:53,040
just modifying the the root input or the

247
00:08:53,040 --> 00:08:55,200
empty input we can modify the input that

248
00:08:55,200 --> 00:08:57,120
already triggered some some interesting

249
00:08:57,120 --> 00:08:59,600
behavior before so this is a kind of

250
00:08:59,600 --> 00:09:02,000
change in in a thought pattern instead

251
00:09:02,000 --> 00:09:03,519
of just doing it from scratch every

252
00:09:03,519 --> 00:09:06,080
single time we create an input we

253
00:09:06,080 --> 00:09:08,160
modify input that has been successful

254
00:09:08,160 --> 00:09:10,080
before hoping that it will be successful

255
00:09:10,080 --> 00:09:12,240
again and more interesting again

256
00:09:12,240 --> 00:09:14,640
right so

257
00:09:14,640 --> 00:09:17,519
to make fuzzing effective

258
00:09:17,519 --> 00:09:19,519
and find more interesting bugs there's a

259
00:09:19,519 --> 00:09:21,040
couple of things we have to

260
00:09:21,040 --> 00:09:22,720
we have to look at when we're optimizing

261
00:09:22,720 --> 00:09:25,120
first our test cases should trigger bugs

262
00:09:25,120 --> 00:09:26,640
so we're using some fine kind of

263
00:09:26,640 --> 00:09:29,120
coverage guided fuzzing for that second

264
00:09:29,120 --> 00:09:30,800
the fuzzer must be able to detect the

265
00:09:30,800 --> 00:09:33,040
bugs right if it just silently passes

266
00:09:33,040 --> 00:09:34,640
the bugs and doesn't really figure out

267
00:09:34,640 --> 00:09:35,760
if there's a there's been a bug

268
00:09:35,760 --> 00:09:38,480
triggered or not yeah tough luck right

269
00:09:38,480 --> 00:09:41,200
and uh performance is key

270
00:09:41,200 --> 00:09:43,920
fuzzing is a zero-sum game

271
00:09:43,920 --> 00:09:46,240
uh going back to also the

272
00:09:46,240 --> 00:09:47,120
the

273
00:09:47,120 --> 00:09:49,360
introduction that david did using

274
00:09:49,360 --> 00:09:51,360
game theory right you have a finite

275
00:09:51,360 --> 00:09:53,360
amount of resources even if you're

276
00:09:53,360 --> 00:09:55,120
playing this game for

277
00:09:55,120 --> 00:09:56,720
an infinite amount of time at any point

278
00:09:56,720 --> 00:09:57,760
in time you have a finite amount of

279
00:09:57,760 --> 00:10:00,480
resources and you want to get as many

280
00:10:00,480 --> 00:10:02,720
bugs out of the cycles that you have

281
00:10:02,720 --> 00:10:04,399
available as possible

282
00:10:04,399 --> 00:10:07,040
so it's that's what as an engineer

283
00:10:07,040 --> 00:10:08,800
really really drives me right so i want

284
00:10:08,800 --> 00:10:12,000
to get like i know i have a cluster of a

285
00:10:12,000 --> 00:10:13,839
couple of hundred cores where we can run

286
00:10:13,839 --> 00:10:16,000
fuzzing i want to get as many bugs out

287
00:10:16,000 --> 00:10:18,160
of these cores as possible right so this

288
00:10:18,160 --> 00:10:19,680
is keep this in mind that this is an

289
00:10:19,680 --> 00:10:22,480
inherent optimization game

290
00:10:22,480 --> 00:10:24,160
let's focus on the first challenge

291
00:10:24,160 --> 00:10:25,760
tracking coverage

292
00:10:25,760 --> 00:10:28,000
and um

293
00:10:28,000 --> 00:10:30,399
the current state of the art is

294
00:10:30,399 --> 00:10:33,600
gray box box-based mutation coverage

295
00:10:33,600 --> 00:10:34,880
or

296
00:10:34,880 --> 00:10:38,800
fuzzing based on feedback from

297
00:10:38,800 --> 00:10:41,920
from simple code coverage that we have

298
00:10:41,920 --> 00:10:44,079
there's a different different kind of

299
00:10:44,079 --> 00:10:46,399
instrumentations that we can have and

300
00:10:46,399 --> 00:10:48,399
the the overarching goals you take the

301
00:10:48,399 --> 00:10:50,800
source code or the binary you instrument

302
00:10:50,800 --> 00:10:53,440
it and whenever a given code area is

303
00:10:53,440 --> 00:10:55,600
executed you you record it on your on

304
00:10:55,600 --> 00:10:57,120
your magic map

305
00:10:57,120 --> 00:10:58,800
there's different kind of coverages that

306
00:10:58,800 --> 00:11:00,480
are out there there's function coverage

307
00:11:00,480 --> 00:11:02,399
block coverage line coverage edge

308
00:11:02,399 --> 00:11:04,720
coverage what not and

309
00:11:04,720 --> 00:11:07,040
it's an it's an inherent trade-off on on

310
00:11:07,040 --> 00:11:09,040
how you want to record what areas you

311
00:11:09,040 --> 00:11:12,480
have executed the more cycles you spend

312
00:11:12,480 --> 00:11:15,040
on recording coverage the fewer cycles

313
00:11:15,040 --> 00:11:17,519
you're actually spending executing the

314
00:11:17,519 --> 00:11:19,680
uh the code on one hand you may get

315
00:11:19,680 --> 00:11:21,279
better information about what you're

316
00:11:21,279 --> 00:11:22,720
executing on the other hand it's more

317
00:11:22,720 --> 00:11:24,399
costly to collect so you'll have to

318
00:11:24,399 --> 00:11:26,000
figure out some form of

319
00:11:26,000 --> 00:11:27,680
of trade-off here

320
00:11:27,680 --> 00:11:29,120
and when we're looking at coverage

321
00:11:29,120 --> 00:11:31,920
collection the fuzzer keeps uh

322
00:11:31,920 --> 00:11:33,839
like as the fuzzer is running it keeps

323
00:11:33,839 --> 00:11:36,720
track of what kind of code areas have

324
00:11:36,720 --> 00:11:38,640
been executed what kind of

325
00:11:38,640 --> 00:11:40,959
functionalities have been triggered and

326
00:11:40,959 --> 00:11:43,120
the the fuzzer keeps us as part of some

327
00:11:43,120 --> 00:11:45,680
form of global coverage right and it's

328
00:11:45,680 --> 00:11:48,240
it's like a map of which edge has been

329
00:11:48,240 --> 00:11:51,120
executed as many times as in in my

330
00:11:51,120 --> 00:11:53,360
example here right and then for each

331
00:11:53,360 --> 00:11:55,440
execution the car the fuzzer keeps a

332
00:11:55,440 --> 00:11:58,240
local map and if the collector coverage

333
00:11:58,240 --> 00:12:01,120
is higher for the for the topmost bit

334
00:12:01,120 --> 00:12:02,880
then the global coverage will update the

335
00:12:02,880 --> 00:12:04,560
global coverage and set the c decide for

336
00:12:04,560 --> 00:12:06,000
further mutation

337
00:12:06,000 --> 00:12:07,760
right so the fuzzer is created as one

338
00:12:07,760 --> 00:12:09,680
input we executed

339
00:12:09,680 --> 00:12:12,320
we check the collector coverage

340
00:12:12,320 --> 00:12:14,399
yeah sure we've executed a couple of

341
00:12:14,399 --> 00:12:16,320
edges more time so for example the

342
00:12:16,320 --> 00:12:18,959
orange edge and the

343
00:12:18,959 --> 00:12:20,880
the pink edge has been executed more

344
00:12:20,880 --> 00:12:23,519
times but we haven't increased enough

345
00:12:23,519 --> 00:12:25,760
right so the the the highest the top

346
00:12:25,760 --> 00:12:27,600
highest most bit is not going to change

347
00:12:27,600 --> 00:12:29,600
so we're going to just keep it the same

348
00:12:29,600 --> 00:12:32,079
let's do one more input ah here now the

349
00:12:32,079 --> 00:12:35,120
the pink bit has changed uh the pink uh

350
00:12:35,120 --> 00:12:36,800
counter has changed from seven to eight

351
00:12:36,800 --> 00:12:38,880
so we've executed this loop more times

352
00:12:38,880 --> 00:12:40,480
we've gone through the loop on the on

353
00:12:40,480 --> 00:12:41,680
the right hand side and this control

354
00:12:41,680 --> 00:12:43,360
flow graph more times

355
00:12:43,360 --> 00:12:44,800
this is higher than the top most bit

356
00:12:44,800 --> 00:12:46,720
that we have stored so far therefore

357
00:12:46,720 --> 00:12:49,040
this is considered an interesting

358
00:12:49,040 --> 00:12:50,560
new seed therefore the fuzzer will set

359
00:12:50,560 --> 00:12:52,880
it aside and continue fuzzing with it

360
00:12:52,880 --> 00:12:53,920
right

361
00:12:53,920 --> 00:12:55,440
we'll store this and then figure out

362
00:12:55,440 --> 00:12:57,600
what the what to do and how to continue

363
00:12:57,600 --> 00:12:58,560
with it

364
00:12:58,560 --> 00:12:59,279
so

365
00:12:59,279 --> 00:13:03,439
fuzzing has been rather boring until

366
00:13:03,800 --> 00:13:08,160
2011 12-ish until uh afl actually came

367
00:13:08,160 --> 00:13:09,839
along and there there have been two

368
00:13:09,839 --> 00:13:12,480
events that happened on one hand there

369
00:13:12,480 --> 00:13:14,079
was the cyber grand challenge that kind

370
00:13:14,079 --> 00:13:16,560
of kicked off a lot of this this

371
00:13:16,560 --> 00:13:18,839
research who knows the cyber grand

372
00:13:18,839 --> 00:13:20,959
challenge okay so this was one of the

373
00:13:20,959 --> 00:13:24,160
darpa grand challenges darpa the

374
00:13:24,160 --> 00:13:26,000
u.s defense agency

375
00:13:26,000 --> 00:13:27,519
they kind of posed these large

376
00:13:27,519 --> 00:13:29,040
challenges out there to humanity and

377
00:13:29,040 --> 00:13:30,880
there's a

378
00:13:30,880 --> 00:13:32,240
researchers trying to find a way to

379
00:13:32,240 --> 00:13:34,000
solve it and the cyber grand challenge

380
00:13:34,000 --> 00:13:36,320
was figuring out a way to auto

381
00:13:36,320 --> 00:13:38,079
automatically find vulnerabilities and

382
00:13:38,079 --> 00:13:41,120
then exploit them in in some way

383
00:13:41,120 --> 00:13:43,519
there's been grand challenges for auto

384
00:13:43,519 --> 00:13:46,160
autonomous driving and

385
00:13:46,160 --> 00:13:48,079
location geolocation and so on and a

386
00:13:48,079 --> 00:13:50,160
bunch of others and this challenge was

387
00:13:50,160 --> 00:13:52,240
focused on vulnerability search and

388
00:13:52,240 --> 00:13:54,800
vulnerability discovery and this led to

389
00:13:54,800 --> 00:13:57,360
what i call the cambrian explosion of

390
00:13:57,360 --> 00:13:59,360
fuzzers if you've

391
00:13:59,360 --> 00:14:01,120
paid attention in biology the cambrian

392
00:14:01,120 --> 00:14:02,880
explosion is when life happened and it

393
00:14:02,880 --> 00:14:04,560
just exploded and there's all these life

394
00:14:04,560 --> 00:14:06,880
forms that that that came out and we see

395
00:14:06,880 --> 00:14:08,240
you see the same as all the fuzzers

396
00:14:08,240 --> 00:14:10,720
there's now hundreds of buzzers at each

397
00:14:10,720 --> 00:14:12,800
conference there's ten new fuzzers being

398
00:14:12,800 --> 00:14:15,839
uh being proposed and all the slight

399
00:14:15,839 --> 00:14:17,839
slight differences and deviations so

400
00:14:17,839 --> 00:14:20,240
we've been working on actually uh trying

401
00:14:20,240 --> 00:14:22,320
to categorize systematize all these

402
00:14:22,320 --> 00:14:24,560
differences to help other researchers

403
00:14:24,560 --> 00:14:26,800
also figuring out how they relate to

404
00:14:26,800 --> 00:14:29,040
each other and what they uh what they

405
00:14:29,040 --> 00:14:31,600
they belong to both on on the control

406
00:14:31,600 --> 00:14:34,240
flow coverage edge but also on the data

407
00:14:34,240 --> 00:14:36,240
flow coverage edge

408
00:14:36,240 --> 00:14:38,480
so this will help you choose what kind

409
00:14:38,480 --> 00:14:40,000
of fuzzer you want to have and also

410
00:14:40,000 --> 00:14:41,920
gives you a way to measure

411
00:14:41,920 --> 00:14:44,320
for a given program what kind of

412
00:14:44,320 --> 00:14:47,120
feedback will be most useful

413
00:14:47,120 --> 00:14:49,279
uh so as a summary for for tracking

414
00:14:49,279 --> 00:14:51,839
coverage coverage helps a fuzzer to

415
00:14:51,839 --> 00:14:53,920
effectively explore new code areas it's

416
00:14:53,920 --> 00:14:57,040
a feedback process that tells the fuzzer

417
00:14:57,040 --> 00:15:00,959
what areas actually are interesting

418
00:15:00,959 --> 00:15:03,279
code coverage and edge coverage but for

419
00:15:03,279 --> 00:15:05,199
example is very cheap to obtain it's

420
00:15:05,199 --> 00:15:07,360
like two or three percent overhead and

421
00:15:07,360 --> 00:15:09,279
precise enough in general so all the

422
00:15:09,279 --> 00:15:11,600
fuzzers pretty much uh rely on a form of

423
00:15:11,600 --> 00:15:13,680
code coverage there's many flavors of

424
00:15:13,680 --> 00:15:15,839
code coverage with subtle differences do

425
00:15:15,839 --> 00:15:17,920
check out and you may want to hand tune

426
00:15:17,920 --> 00:15:19,600
but it's very easy to just set up a

427
00:15:19,600 --> 00:15:22,000
fuzzer go with it and then tune along

428
00:15:22,000 --> 00:15:23,760
while you actually observe your fuzzing

429
00:15:23,760 --> 00:15:25,839
campaign future research so if you are

430
00:15:25,839 --> 00:15:27,199
interested in writing new more

431
00:15:27,199 --> 00:15:29,360
interesting fuzzers alternatives to code

432
00:15:29,360 --> 00:15:31,839
coverage what is a good approximation of

433
00:15:31,839 --> 00:15:33,920
code coverage for example in in areas

434
00:15:33,920 --> 00:15:35,680
where you cannot really

435
00:15:35,680 --> 00:15:37,759
instrument your binary think of

436
00:15:37,759 --> 00:15:40,720
embedded systems think of systems where

437
00:15:40,720 --> 00:15:42,240
you don't have uh

438
00:15:42,240 --> 00:15:44,880
debug primitives or like

439
00:15:44,880 --> 00:15:48,000
closed environments or other kind of

440
00:15:48,000 --> 00:15:49,759
binaries that make it hard for you to

441
00:15:49,759 --> 00:15:51,839
obtain this this information

442
00:15:51,839 --> 00:15:54,000
combining different coverages and also

443
00:15:54,000 --> 00:15:56,160
adjusting coverage as needed during the

444
00:15:56,160 --> 00:15:58,399
campaign for example after you finish

445
00:15:58,399 --> 00:16:00,560
the exploration campaign and you know

446
00:16:00,560 --> 00:16:01,519
how the

447
00:16:01,519 --> 00:16:03,040
how code actually works you want to go

448
00:16:03,040 --> 00:16:05,279
into into an exploitation phase where

449
00:16:05,279 --> 00:16:07,199
you figure out individual bugs and there

450
00:16:07,199 --> 00:16:09,120
some more fine-grained feedback may

451
00:16:09,120 --> 00:16:10,480
actually be fairly

452
00:16:10,480 --> 00:16:13,040
fairly useful

453
00:16:13,040 --> 00:16:15,600
second challenge detecting bugs

454
00:16:15,600 --> 00:16:18,720
well if we would just know that a bug is

455
00:16:18,720 --> 00:16:20,639
there this would be super easy right if

456
00:16:20,639 --> 00:16:22,160
the bug would just tell you hey this is

457
00:16:22,160 --> 00:16:25,040
the bug i'm on line 15 uh fifth

458
00:16:25,040 --> 00:16:27,600
character go fix me right unfortunately

459
00:16:27,600 --> 00:16:30,160
this doesn't work that that way and we

460
00:16:30,160 --> 00:16:33,120
need some form of oracle we need a way

461
00:16:33,120 --> 00:16:36,240
that tells us that hey there actually is

462
00:16:36,240 --> 00:16:37,360
a bug

463
00:16:37,360 --> 00:16:39,040
uh if you don't have source code you may

464
00:16:39,040 --> 00:16:41,519
just yolo it or you could statically

465
00:16:41,519 --> 00:16:44,000
rewrite the binary right something that

466
00:16:44,000 --> 00:16:46,399
you get like if if your program is hack

467
00:16:46,399 --> 00:16:47,440
faults

468
00:16:47,440 --> 00:16:49,600
yeah that's very likely a bug right so

469
00:16:49,600 --> 00:16:51,680
that's a that's a very cheap oracle if

470
00:16:51,680 --> 00:16:53,440
it's egg faults or not uh you can

471
00:16:53,440 --> 00:16:55,279
statically rewrite the binary to make it

472
00:16:55,279 --> 00:16:59,519
more likely to segfault to re retrofit

473
00:16:59,519 --> 00:17:02,160
some kind of

474
00:17:02,720 --> 00:17:04,640
fuzzing or address sanitization

475
00:17:04,640 --> 00:17:06,079
instrumentation into it and we'll talk

476
00:17:06,079 --> 00:17:08,880
about this in a in a bit um or if you do

477
00:17:08,880 --> 00:17:10,959
have source code that's the ideal case

478
00:17:10,959 --> 00:17:13,359
um and i i disagree a little bit with

479
00:17:13,359 --> 00:17:15,199
david here and i didn't pose a question

480
00:17:15,199 --> 00:17:16,880
so you cannot really shoot me down and i

481
00:17:16,880 --> 00:17:18,880
can just as a speaker now i can talk

482
00:17:18,880 --> 00:17:20,400
about it that often if you do have

483
00:17:20,400 --> 00:17:22,799
source code it makes fuzzing and bug

484
00:17:22,799 --> 00:17:24,880
finding much easier and you can actually

485
00:17:24,880 --> 00:17:28,079
spend some cycles on uh instrumenting it

486
00:17:28,079 --> 00:17:30,480
with different kind of

487
00:17:30,480 --> 00:17:33,520
sanitizers who knows sanitizers quick

488
00:17:33,520 --> 00:17:36,080
show of hands

489
00:17:36,240 --> 00:17:38,080
very few um

490
00:17:38,080 --> 00:17:40,480
the cheapest way to find bugs as i tell

491
00:17:40,480 --> 00:17:43,280
my students is

492
00:17:43,280 --> 00:17:45,280
sanitizers yes hand sanitizer everybody

493
00:17:45,280 --> 00:17:47,600
knows hand sanitizers right it gets rid

494
00:17:47,600 --> 00:17:50,400
of germs on uh on your hands especially

495
00:17:50,400 --> 00:17:52,960
over the last two two years right a

496
00:17:52,960 --> 00:17:55,120
sanitizer is the cheapest way when

497
00:17:55,120 --> 00:17:56,799
you're writing code to find

498
00:17:56,799 --> 00:18:00,240
vulnerabilities in your code um you do

499
00:18:00,240 --> 00:18:02,320
dash

500
00:18:02,320 --> 00:18:05,280
f sanitize equals address

501
00:18:05,280 --> 00:18:07,679
your code compiles and if you touch

502
00:18:07,679 --> 00:18:09,039
illegal memory

503
00:18:09,039 --> 00:18:10,880
you get a nice bug report that tells you

504
00:18:10,880 --> 00:18:13,039
hey there's a bug over here you should

505
00:18:13,039 --> 00:18:14,960
all during testing you should always

506
00:18:14,960 --> 00:18:17,280
compile your code with sanitization

507
00:18:17,280 --> 00:18:19,280
uh there's concurrency sanitizers or

508
00:18:19,280 --> 00:18:21,039
threat sanitizers there's type

509
00:18:21,039 --> 00:18:23,200
sanitizers um

510
00:18:23,200 --> 00:18:25,600
logic bugs ah we don't really have

511
00:18:25,600 --> 00:18:28,080
something useful for logic bugs yet so

512
00:18:28,080 --> 00:18:30,960
that's a that's a nice way for you for

513
00:18:30,960 --> 00:18:32,880
to to look at future research

514
00:18:32,880 --> 00:18:34,880
but i don't just want to talk about

515
00:18:34,880 --> 00:18:36,640
sanitizers because this research has

516
00:18:36,640 --> 00:18:38,640
already been done you should be using uh

517
00:18:38,640 --> 00:18:40,559
sanitization during fussing and we can

518
00:18:40,559 --> 00:18:42,559
talk about some of the the the

519
00:18:42,559 --> 00:18:44,559
trade-offs here but i'm happy to do that

520
00:18:44,559 --> 00:18:46,559
during the break but the the main goal

521
00:18:46,559 --> 00:18:47,919
or the main

522
00:18:47,919 --> 00:18:50,160
issue i want to talk about is that yes

523
00:18:50,160 --> 00:18:53,280
crashes are great but having actual bugs

524
00:18:53,280 --> 00:18:54,799
are much better

525
00:18:54,799 --> 00:18:57,679
um a fuzzing campaign produces n

526
00:18:57,679 --> 00:19:00,720
crashing seeds that map to m bucks right

527
00:19:00,720 --> 00:19:02,720
so after fuzzing you have n crushing

528
00:19:02,720 --> 00:19:04,640
seeds and your fuzzer tells you all of

529
00:19:04,640 --> 00:19:07,039
these seeds are unique bugs right but

530
00:19:07,039 --> 00:19:08,880
you don't know in in essence there's

531
00:19:08,880 --> 00:19:10,799
only going to be m actual bucks and

532
00:19:10,799 --> 00:19:14,559
often m is much smaller than n right so

533
00:19:14,559 --> 00:19:17,600
now given that you have the 7 000 uh

534
00:19:17,600 --> 00:19:19,840
total crashes or a thousand unique

535
00:19:19,840 --> 00:19:21,120
crashes

536
00:19:21,120 --> 00:19:22,000
um

537
00:19:22,000 --> 00:19:24,400
how do you distill them

538
00:19:24,400 --> 00:19:27,120
into the number of unique bugs

539
00:19:27,120 --> 00:19:29,360
right in this example here there were 7

540
00:19:29,360 --> 00:19:33,200
000 crashes on afl 124 unique and all of

541
00:19:33,200 --> 00:19:35,679
them were the same bug

542
00:19:35,679 --> 00:19:37,840
right you've got a couple of overhead a

543
00:19:37,840 --> 00:19:40,240
couple of orders of of magnitude

544
00:19:40,240 --> 00:19:42,000
difference between the number of real

545
00:19:42,000 --> 00:19:42,960
bugs

546
00:19:42,960 --> 00:19:44,640
and the the

547
00:19:44,640 --> 00:19:46,880
unique bugs that your fuzzer reports and

548
00:19:46,880 --> 00:19:48,320
this is going to cost you a lot of

549
00:19:48,320 --> 00:19:50,559
resources and if you are a bug bounty

550
00:19:50,559 --> 00:19:52,640
hunter you're only paid once per buck

551
00:19:52,640 --> 00:19:54,000
right so it doesn't matter if you say

552
00:19:54,000 --> 00:19:55,600
hey there's more but there's more bucks

553
00:19:55,600 --> 00:19:57,120
here right it just doesn't work like

554
00:19:57,120 --> 00:19:58,960
that now the challenge that we have is

555
00:19:58,960 --> 00:20:00,080
given n

556
00:20:00,080 --> 00:20:01,919
the number of crashing seats how do we

557
00:20:01,919 --> 00:20:04,480
distill them into the set of actual uh

558
00:20:04,480 --> 00:20:06,080
actual books

559
00:20:06,080 --> 00:20:06,880
well

560
00:20:06,880 --> 00:20:08,880
one approach is we could just do call

561
00:20:08,880 --> 00:20:11,360
stacks right group all the crashes based

562
00:20:11,360 --> 00:20:14,559
on the on the hash of top k frames well

563
00:20:14,559 --> 00:20:16,080
the issue here is that there's a whole

564
00:20:16,080 --> 00:20:18,320
bunch of type 1 errors

565
00:20:18,320 --> 00:20:19,840
so there's going to be duplicate bugs

566
00:20:19,840 --> 00:20:21,760
that crash at different uh different

567
00:20:21,760 --> 00:20:24,080
addresses and we'll uh will lose those

568
00:20:24,080 --> 00:20:25,840
uh the

569
00:20:25,840 --> 00:20:28,320
will will over count by about two orders

570
00:20:28,320 --> 00:20:30,320
of magnitude

571
00:20:30,320 --> 00:20:32,400
crash location that's another simple

572
00:20:32,400 --> 00:20:33,840
estimator

573
00:20:33,840 --> 00:20:35,440
so we just record the crash location and

574
00:20:35,440 --> 00:20:38,240
treat each crash location as a as a

575
00:20:38,240 --> 00:20:39,919
different book

576
00:20:39,919 --> 00:20:41,520
the prime counter example here are used

577
00:20:41,520 --> 00:20:43,520
after three bucks use after three bugs

578
00:20:43,520 --> 00:20:45,120
will crash anywhere right so the crash

579
00:20:45,120 --> 00:20:46,559
location has nothing to do with the

580
00:20:46,559 --> 00:20:47,440
actual

581
00:20:47,440 --> 00:20:48,799
actual bug that you're looking at this

582
00:20:48,799 --> 00:20:51,520
is pretty uh pretty useless as well

583
00:20:51,520 --> 00:20:52,960
unfortunately so both of these

584
00:20:52,960 --> 00:20:54,960
approaches over count by two to three

585
00:20:54,960 --> 00:20:57,760
orders of magnitude um wasting your your

586
00:20:57,760 --> 00:21:01,520
uh your developer time so if um

587
00:21:01,520 --> 00:21:04,640
like for 100

588
00:21:04,640 --> 00:21:06,960
potential bucks you spend 100 days

589
00:21:06,960 --> 00:21:08,240
analyzing them and then you have one

590
00:21:08,240 --> 00:21:10,320
final book that's not going to be super

591
00:21:10,320 --> 00:21:12,159
uh super versatile

592
00:21:12,159 --> 00:21:13,280
so

593
00:21:13,280 --> 00:21:15,039
we spent some resources

594
00:21:15,039 --> 00:21:18,159
we did 79 cpu years of fuzzing

595
00:21:18,159 --> 00:21:21,679
and we looked at 254 000 crashing seats

596
00:21:21,679 --> 00:21:23,280
that we got out of it

597
00:21:23,280 --> 00:21:25,039
that's actually a fairly substantial

598
00:21:25,039 --> 00:21:26,159
number

599
00:21:26,159 --> 00:21:29,039
um and then we analyzed the

600
00:21:29,039 --> 00:21:30,400
the different seats it's actually great

601
00:21:30,400 --> 00:21:31,840
if you have phd students they can

602
00:21:31,840 --> 00:21:33,280
actually do a lot of stuff and look at

603
00:21:33,280 --> 00:21:34,640
this manually so you can get ground

604
00:21:34,640 --> 00:21:37,679
truth um

605
00:21:37,840 --> 00:21:40,559
and the existing grouping that have been

606
00:21:40,559 --> 00:21:42,720
used both over and under approximate

607
00:21:42,720 --> 00:21:44,640
bugs this is bad

608
00:21:44,640 --> 00:21:46,320
each bug is triggerable by a unique

609
00:21:46,320 --> 00:21:48,320
trigger right like if you think about it

610
00:21:48,320 --> 00:21:50,320
each bug that is out there will have

611
00:21:50,320 --> 00:21:52,000
some form of unique trigger that you can

612
00:21:52,000 --> 00:21:55,200
use to actually trigger the bug

613
00:21:55,200 --> 00:21:57,760
and large sections if you trace the the

614
00:21:57,760 --> 00:22:00,159
program execution to the bug large

615
00:22:00,159 --> 00:22:02,320
sections of this execution path are

616
00:22:02,320 --> 00:22:05,360
irrelevant to the crash

617
00:22:05,360 --> 00:22:08,960
now if we could identify the small

618
00:22:08,960 --> 00:22:11,200
sequence of the paths that is actually

619
00:22:11,200 --> 00:22:13,039
responsible

620
00:22:13,039 --> 00:22:14,000
for

621
00:22:14,000 --> 00:22:16,320
the the vulnerability and for the crash

622
00:22:16,320 --> 00:22:18,640
we could use this to identify it based

623
00:22:18,640 --> 00:22:20,480
on the on the topology

624
00:22:20,480 --> 00:22:22,960
so our idea that we had is do we want to

625
00:22:22,960 --> 00:22:24,799
minimize the path prune all the

626
00:22:24,799 --> 00:22:26,559
irrelevant sections that do not

627
00:22:26,559 --> 00:22:28,799
correspond to the bug trigger and then

628
00:22:28,799 --> 00:22:31,679
cluster by by graph topology to match

629
00:22:31,679 --> 00:22:34,320
similar similar kind of sub-paths

630
00:22:34,320 --> 00:22:37,280
and we're introducing igor for that

631
00:22:37,280 --> 00:22:41,039
igors are if you if you know discworld

632
00:22:41,039 --> 00:22:42,720
and um

633
00:22:42,720 --> 00:22:45,039
i'm a huge fan of of the discworld

634
00:22:45,039 --> 00:22:47,200
novels you should totally read them

635
00:22:47,200 --> 00:22:49,520
in ank moorpark there's a

636
00:22:49,520 --> 00:22:51,600
a group of igors that are helpful

637
00:22:51,600 --> 00:22:55,120
servants to crazy scientists and we used

638
00:22:55,120 --> 00:22:57,200
to use the name for that terry pratchett

639
00:22:57,200 --> 00:22:58,960
is the author and you should all read

640
00:22:58,960 --> 00:23:01,120
read his books they are they're amazing

641
00:23:01,120 --> 00:23:03,039
so we're introducing igor to help us

642
00:23:03,039 --> 00:23:05,200
distill all these different crashes and

643
00:23:05,200 --> 00:23:06,880
the underlying pipeline looks like that

644
00:23:06,880 --> 00:23:08,880
we get all the crashes in we do some

645
00:23:08,880 --> 00:23:11,280
data processing filtering and then igor

646
00:23:11,280 --> 00:23:12,480
fuzzing

647
00:23:12,480 --> 00:23:15,039
uh and then we do graph clustering and

648
00:23:15,039 --> 00:23:17,280
then we get clustered crashes so for

649
00:23:17,280 --> 00:23:19,520
each of the bugs we get a cluster of the

650
00:23:19,520 --> 00:23:21,280
of the crashes out there

651
00:23:21,280 --> 00:23:23,840
you see fuzzing in the in the first

652
00:23:23,840 --> 00:23:25,280
in the first box i'm going to spend some

653
00:23:25,280 --> 00:23:27,440
more time on this on this fuzzing we're

654
00:23:27,440 --> 00:23:30,000
going to do fuzzing but different

655
00:23:30,000 --> 00:23:32,320
right so the the goal of fuzzing usually

656
00:23:32,320 --> 00:23:33,919
is we want to maximize coverage we want

657
00:23:33,919 --> 00:23:36,320
to trigger new and different bugs

658
00:23:36,320 --> 00:23:38,960
for igor fuzz we don't

659
00:23:38,960 --> 00:23:41,520
now with igor fuzz we flipped the

660
00:23:41,520 --> 00:23:44,799
fitness function and we want to have as

661
00:23:44,799 --> 00:23:47,760
little coverage as possible while

662
00:23:47,760 --> 00:23:50,720
triggering the same book original

663
00:23:50,720 --> 00:23:53,520
fuzzing is we want to get more coverage

664
00:23:53,520 --> 00:23:55,679
and hit different locations

665
00:23:55,679 --> 00:23:58,480
what we do is given a seat we want to

666
00:23:58,480 --> 00:23:59,279
hit

667
00:23:59,279 --> 00:24:00,799
less coverage

668
00:24:00,799 --> 00:24:03,279
and the same crash and this allows us to

669
00:24:03,279 --> 00:24:05,039
shrink and prune all of the code that is

670
00:24:05,039 --> 00:24:07,760
not necessary like imagine you spending

671
00:24:07,760 --> 00:24:09,919
hours and days trying to get rid of

672
00:24:09,919 --> 00:24:12,080
functionality that is not bug relevant

673
00:24:12,080 --> 00:24:14,159
this is using a machine that does that

674
00:24:14,159 --> 00:24:16,240
right so it gets rid of all the the

675
00:24:16,240 --> 00:24:17,840
nodes here on the on the right hand side

676
00:24:17,840 --> 00:24:20,000
there's a that's a lip png example that

677
00:24:20,000 --> 00:24:22,320
we triaged um

678
00:24:22,320 --> 00:24:24,320
you see all the the basic blocks the red

679
00:24:24,320 --> 00:24:26,799
ones are those that have been pruned um

680
00:24:26,799 --> 00:24:28,240
and the green ones are those that have

681
00:24:28,240 --> 00:24:30,000
been added to make they make the past

682
00:24:30,000 --> 00:24:32,960
simpler and making the execution much

683
00:24:32,960 --> 00:24:34,960
more much more efficient right this

684
00:24:34,960 --> 00:24:37,120
allows us to get rid of large chunks of

685
00:24:37,120 --> 00:24:38,960
the the pass and figuring out the

686
00:24:38,960 --> 00:24:42,080
details we then do clustering

687
00:24:42,080 --> 00:24:43,600
for

688
00:24:43,600 --> 00:24:46,240
the the different different bugs before

689
00:24:46,240 --> 00:24:47,919
our coverage decreased buzzing

690
00:24:47,919 --> 00:24:50,000
clustering was a bit of a show as

691
00:24:50,000 --> 00:24:51,520
you see on the left hand side it was

692
00:24:51,520 --> 00:24:53,919
very hard to distinguish these different

693
00:24:53,919 --> 00:24:56,240
crashes uh afterwards on the right hand

694
00:24:56,240 --> 00:24:57,919
side you see distinct clusters for all

695
00:24:57,919 --> 00:24:59,919
the different cvs so it is very

696
00:24:59,919 --> 00:25:02,559
effective at grouping

697
00:25:02,559 --> 00:25:05,279
grouping crashes into into small groups

698
00:25:05,279 --> 00:25:07,440
and this gives you a way of

699
00:25:07,440 --> 00:25:11,120
clustering 250 000

700
00:25:11,120 --> 00:25:15,440
crashes that we had into 40 bucks

701
00:25:15,440 --> 00:25:16,480
so

702
00:25:16,480 --> 00:25:18,480
the

703
00:25:18,480 --> 00:25:20,640
summary for for igor is it's fuzzing is

704
00:25:20,640 --> 00:25:22,559
great at producing crashes when using

705
00:25:22,559 --> 00:25:24,640
the right sanitizer of course but

706
00:25:24,640 --> 00:25:26,080
programmers are just overwhelmed by the

707
00:25:26,080 --> 00:25:28,320
thousands of crashes that we have we can

708
00:25:28,320 --> 00:25:30,240
minimize the path length of seats to

709
00:25:30,240 --> 00:25:33,279
enable this the similarity matching and

710
00:25:33,279 --> 00:25:36,320
using our tool we group these 254 4000

711
00:25:36,320 --> 00:25:39,600
crashes into 39 unique bugs and 48

712
00:25:39,600 --> 00:25:43,120
clusters so it's much easier for you to

713
00:25:43,120 --> 00:25:48,000
analyze 48 clusters than 254 000 seats

714
00:25:48,000 --> 00:25:50,320
i i would say so check out the

715
00:25:50,320 --> 00:25:52,960
the the paper the source is uh is online

716
00:25:52,960 --> 00:25:55,440
versus we are currently working on a

717
00:25:55,440 --> 00:25:57,679
tutorial and making it more usable for

718
00:25:57,679 --> 00:26:00,240
for analysts

719
00:26:00,240 --> 00:26:02,960
many of you are working on fuzzers

720
00:26:02,960 --> 00:26:05,520
about two to five percent according to a

721
00:26:05,520 --> 00:26:07,279
show of hands but i would guess much

722
00:26:07,279 --> 00:26:08,240
more

723
00:26:08,240 --> 00:26:09,440
because it's very hard for you to show

724
00:26:09,440 --> 00:26:11,039
hands but if you are if you're

725
00:26:11,039 --> 00:26:13,200
developing a new fuzzer for an area

726
00:26:13,200 --> 00:26:14,720
right you may not want to open sources

727
00:26:14,720 --> 00:26:16,480
or whatnot but you want to figure out is

728
00:26:16,480 --> 00:26:19,200
my fuzzer better than the fuzzer that

729
00:26:19,200 --> 00:26:21,200
already exists right is it worthwhile to

730
00:26:21,200 --> 00:26:24,000
invest my time into tuning this strategy

731
00:26:24,000 --> 00:26:26,880
so you want to find uh find a some kind

732
00:26:26,880 --> 00:26:28,880
of metrics to compare your fuzzer to

733
00:26:28,880 --> 00:26:30,159
other fuzzers

734
00:26:30,159 --> 00:26:31,600
it could be code coverage could be

735
00:26:31,600 --> 00:26:33,760
crashes it could be bugs well code

736
00:26:33,760 --> 00:26:35,679
coverage is subject subjective it's very

737
00:26:35,679 --> 00:26:38,080
hard to measure measure talk to me about

738
00:26:38,080 --> 00:26:40,159
this during the coffee break crashes are

739
00:26:40,159 --> 00:26:42,080
imprecise as we've just seen

740
00:26:42,080 --> 00:26:43,760
and for bugs you lack ground truths

741
00:26:43,760 --> 00:26:45,360
right you don't really know what how

742
00:26:45,360 --> 00:26:47,679
many bugs will be in the in the code

743
00:26:47,679 --> 00:26:50,960
so what we did is we created a benchmark

744
00:26:50,960 --> 00:26:52,640
using real software

745
00:26:52,640 --> 00:26:54,880
that allows you to test all these uh

746
00:26:54,880 --> 00:26:56,559
these different uh these different

747
00:26:56,559 --> 00:26:58,240
fuzzers including your foster it's very

748
00:26:58,240 --> 00:27:00,240
easy to set up and then you can evaluate

749
00:27:00,240 --> 00:27:02,000
if your fuzzer is actually better than

750
00:27:02,000 --> 00:27:04,320
uh than other fuzzers

751
00:27:04,320 --> 00:27:06,240
that just as a side note if you want to

752
00:27:06,240 --> 00:27:08,799
check it out it's called magma uh and it

753
00:27:08,799 --> 00:27:11,120
it contains a real world software that

754
00:27:11,120 --> 00:27:13,520
you can use to to drive your uh your

755
00:27:13,520 --> 00:27:16,000
your fuzz ring code

756
00:27:16,000 --> 00:27:18,159
two quick notes on on some fuzzing

757
00:27:18,159 --> 00:27:20,320
niches and techniques i want to mention

758
00:27:20,320 --> 00:27:22,720
and some some neat areas especially as

759
00:27:22,720 --> 00:27:24,559
the discussion came up

760
00:27:24,559 --> 00:27:27,520
today this morning and yesterday during

761
00:27:27,520 --> 00:27:29,840
during the dinner one of the areas where

762
00:27:29,840 --> 00:27:31,760
fuzzing is really really really really

763
00:27:31,760 --> 00:27:34,080
hard are embedded systems and with

764
00:27:34,080 --> 00:27:35,679
embedded systems i'm thinking about

765
00:27:35,679 --> 00:27:38,159
these small little embedded systems

766
00:27:38,159 --> 00:27:40,799
where you run firmware and you have some

767
00:27:40,799 --> 00:27:44,080
arm cortex m0 m4 or some other kind of

768
00:27:44,080 --> 00:27:46,159
kind of constrained environment

769
00:27:46,159 --> 00:27:47,520
and

770
00:27:47,520 --> 00:27:49,440
the the issue there is right they're not

771
00:27:49,440 --> 00:27:50,880
running an operating system they're

772
00:27:50,880 --> 00:27:52,960
running on the hardware itself they are

773
00:27:52,960 --> 00:27:55,279
heavily customized it's very hard to use

774
00:27:55,279 --> 00:27:57,440
it's very hard to look at uh the the

775
00:27:57,440 --> 00:28:00,320
firmware is task dependent there's a

776
00:28:00,320 --> 00:28:02,720
metric ton of different peripherals

777
00:28:02,720 --> 00:28:04,559
you would have to support and it's super

778
00:28:04,559 --> 00:28:07,039
hard right there's no way for you to uh

779
00:28:07,039 --> 00:28:08,080
to

780
00:28:08,080 --> 00:28:10,080
to do peripheral discovery and to

781
00:28:10,080 --> 00:28:11,600
actually support all these these

782
00:28:11,600 --> 00:28:13,120
different systems

783
00:28:13,120 --> 00:28:14,240
um

784
00:28:14,240 --> 00:28:16,080
one thing all of these systems have in

785
00:28:16,080 --> 00:28:19,679
common though is that they um they have

786
00:28:19,679 --> 00:28:22,320
some form of hell a hardware abstraction

787
00:28:22,320 --> 00:28:23,440
layer

788
00:28:23,440 --> 00:28:25,360
and there's a bunch of different help

789
00:28:25,360 --> 00:28:27,760
health and we use this so instead of

790
00:28:27,760 --> 00:28:30,159
implementing an emulator for each

791
00:28:30,159 --> 00:28:32,640
individual peripheral we implement an

792
00:28:32,640 --> 00:28:34,320
abstraction layer that allows you to

793
00:28:34,320 --> 00:28:35,120
hook

794
00:28:35,120 --> 00:28:37,919
when an individual uh hell function was

795
00:28:37,919 --> 00:28:40,320
called like whenever a half a function

796
00:28:40,320 --> 00:28:41,760
is called for example you are greed or

797
00:28:41,760 --> 00:28:43,039
you are right

798
00:28:43,039 --> 00:28:44,960
instead of implementing the and

799
00:28:44,960 --> 00:28:47,200
emulating the ur chip which would drive

800
00:28:47,200 --> 00:28:48,720
us insane

801
00:28:48,720 --> 00:28:50,720
we allow you to intercept and then

802
00:28:50,720 --> 00:28:52,159
replace it with a five-line python

803
00:28:52,159 --> 00:28:53,279
script

804
00:28:53,279 --> 00:28:55,760
so our hallucinator replaces the

805
00:28:55,760 --> 00:28:57,840
underlying hals and other libraries with

806
00:28:57,840 --> 00:28:59,600
high level implementations and gives you

807
00:28:59,600 --> 00:29:02,080
as the developer the the analyst the

808
00:29:02,080 --> 00:29:03,919
opportunity to to implement these

809
00:29:03,919 --> 00:29:06,080
high-level abstractions so this

810
00:29:06,080 --> 00:29:09,279
transforms the re-hosting problem of

811
00:29:09,279 --> 00:29:11,679
re-hosting and re-implementing all these

812
00:29:11,679 --> 00:29:13,279
different peripherals and supporting

813
00:29:13,279 --> 00:29:15,039
tens of thousands of devices into

814
00:29:15,039 --> 00:29:16,720
supporting a dozen of health and this is

815
00:29:16,720 --> 00:29:18,799
much uh much easier

816
00:29:18,799 --> 00:29:20,559
if you're looking at a modern firmware

817
00:29:20,559 --> 00:29:23,440
on such an embedded embedded system we

818
00:29:23,440 --> 00:29:25,120
have the off-chip hardware we have

819
00:29:25,120 --> 00:29:26,720
on-chip hardware and we have to firm our

820
00:29:26,720 --> 00:29:29,279
running running on top of it if you peek

821
00:29:29,279 --> 00:29:31,120
into the firmware a bit

822
00:29:31,120 --> 00:29:32,720
right we've got the vendor hell the

823
00:29:32,720 --> 00:29:34,559
platform hell and a bunch of other

824
00:29:34,559 --> 00:29:36,720
abstraction layers on top of that we may

825
00:29:36,720 --> 00:29:40,960
have rtos protocol stacks such as a

826
00:29:40,960 --> 00:29:43,200
low level ip sigbi

827
00:29:43,200 --> 00:29:44,960
peripheral libraries like sensors and so

828
00:29:44,960 --> 00:29:47,760
on and then the application code on top

829
00:29:47,760 --> 00:29:51,039
our rehosting uses qmu to run all the

830
00:29:51,039 --> 00:29:52,960
the low level instructions and then he

831
00:29:52,960 --> 00:29:56,799
finds interception points for whenever a

832
00:29:56,799 --> 00:29:58,640
hardware is accessed through the hell

833
00:29:58,640 --> 00:30:00,320
and you can then implement these these

834
00:30:00,320 --> 00:30:02,640
hal abstractions on top of it either

835
00:30:02,640 --> 00:30:05,039
running the the full stack application

836
00:30:05,039 --> 00:30:08,799
code rtos um the the real the real-time

837
00:30:08,799 --> 00:30:10,720
operating system protocol stacks or even

838
00:30:10,720 --> 00:30:13,360
going higher and abstracting these uh

839
00:30:13,360 --> 00:30:15,120
these low-level

840
00:30:15,120 --> 00:30:16,799
systems as well

841
00:30:16,799 --> 00:30:18,960
giving you an opportunity to intersect

842
00:30:18,960 --> 00:30:22,640
and intercept the application code so in

843
00:30:22,640 --> 00:30:24,960
hallucinator we do hal based firmware

844
00:30:24,960 --> 00:30:27,600
re-hosting and you can locate health

845
00:30:27,600 --> 00:30:29,520
functions in firmware in the firmware

846
00:30:29,520 --> 00:30:31,120
address space and then use this as

847
00:30:31,120 --> 00:30:32,720
individual hooks

848
00:30:32,720 --> 00:30:34,960
qmu translates the instructions we trap

849
00:30:34,960 --> 00:30:37,600
on peripheral axis based on the on the

850
00:30:37,600 --> 00:30:38,880
health functions and then enable fine

851
00:30:38,880 --> 00:30:40,720
grain introspection we just did a

852
00:30:40,720 --> 00:30:42,880
tutorial for uh

853
00:30:42,880 --> 00:30:45,679
for the folks at onr the tutorial is

854
00:30:45,679 --> 00:30:48,000
online on the on the website using the

855
00:30:48,000 --> 00:30:50,960
uh the different uh uh slides and so on

856
00:30:50,960 --> 00:30:52,080
as well so you can play through the

857
00:30:52,080 --> 00:30:54,399
tutorial and do some some re-hosting of

858
00:30:54,399 --> 00:30:55,919
your firmware as you are you're playing

859
00:30:55,919 --> 00:30:57,919
with it this is also great for firmware

860
00:30:57,919 --> 00:30:59,120
fuzzing

861
00:30:59,120 --> 00:31:01,120
if you if you're into that that kind of

862
00:31:01,120 --> 00:31:02,159
thing

863
00:31:02,159 --> 00:31:05,039
uh a second uh project i want to talk

864
00:31:05,039 --> 00:31:06,960
about that we've been pushing really

865
00:31:06,960 --> 00:31:09,200
really hard on also making it available

866
00:31:09,200 --> 00:31:12,559
to you folks is a retrowrite

867
00:31:12,559 --> 00:31:13,919
it's a tool that allows you to

868
00:31:13,919 --> 00:31:16,159
statically rewrite existing binary code

869
00:31:16,159 --> 00:31:20,720
for both x86 and arch 64. so you start

870
00:31:20,720 --> 00:31:21,679
with an

871
00:31:21,679 --> 00:31:23,760
elf binary that can be stripped you do

872
00:31:23,760 --> 00:31:26,000
symbolization so you recover all the

873
00:31:26,000 --> 00:31:27,039
different

874
00:31:27,039 --> 00:31:29,600
different offsets and the different code

875
00:31:29,600 --> 00:31:30,720
layouts

876
00:31:30,720 --> 00:31:32,159
resulting in the form of labeled

877
00:31:32,159 --> 00:31:34,159
assembly and then you can run a bunch of

878
00:31:34,159 --> 00:31:37,360
instrumentation passes on top of this um

879
00:31:37,360 --> 00:31:40,159
of this this reassembled code

880
00:31:40,159 --> 00:31:41,360
memory sanitization address

881
00:31:41,360 --> 00:31:43,679
synthesization fuzzing coverage or

882
00:31:43,679 --> 00:31:44,960
control flow integrity and then you

883
00:31:44,960 --> 00:31:47,039
compile it back down

884
00:31:47,039 --> 00:31:49,440
um features that retroright already has

885
00:31:49,440 --> 00:31:52,919
it is it's a zero overhead rewriter for

886
00:31:52,919 --> 00:31:56,480
ar-64 and x64 so it gives you a way to

887
00:31:56,480 --> 00:31:58,559
rewrite your binaries at very very high

888
00:31:58,559 --> 00:32:01,760
speed and very high compatibility

889
00:32:01,760 --> 00:32:04,880
fully symbolizes arm and x64 code and we

890
00:32:04,880 --> 00:32:06,799
provide as i said address and it is a

891
00:32:06,799 --> 00:32:09,279
sanitization fuzzing and coverage

892
00:32:09,279 --> 00:32:11,840
function shuffling exception handling

893
00:32:11,840 --> 00:32:14,720
basic control flow integrity and and

894
00:32:14,720 --> 00:32:16,240
shadow stacks

895
00:32:16,240 --> 00:32:19,279
we've got a tutorial on here as well um

896
00:32:19,279 --> 00:32:20,559
the

897
00:32:20,559 --> 00:32:23,120
c plus plus support is very iffy at the

898
00:32:23,120 --> 00:32:25,360
moment because c plus exceptions are

899
00:32:25,360 --> 00:32:26,159
hard

900
00:32:26,159 --> 00:32:28,640
but we're working on that if you're

901
00:32:28,640 --> 00:32:32,159
interested in using it the 60 uh the x86

902
00:32:32,159 --> 00:32:34,480
version is fairly stable the arm version

903
00:32:34,480 --> 00:32:36,399
is coming along if you're interested in

904
00:32:36,399 --> 00:32:38,559
the arm version please reach out

905
00:32:38,559 --> 00:32:41,519
we give early developer access so we'll

906
00:32:41,519 --> 00:32:43,279
be very interested in working with you

907
00:32:43,279 --> 00:32:44,559
on that

908
00:32:44,559 --> 00:32:45,919
i want to spend the last couple of

909
00:32:45,919 --> 00:32:47,679
minutes and talking about some of the

910
00:32:47,679 --> 00:32:49,120
unsolved challenges that i've seen

911
00:32:49,120 --> 00:32:51,600
fuzzing and also give you an opportunity

912
00:32:51,600 --> 00:32:52,399
to

913
00:32:52,399 --> 00:32:54,960
later during coffee hit me up and talk

914
00:32:54,960 --> 00:32:56,240
about all of these different things and

915
00:32:56,240 --> 00:32:57,919
would be very interested in in

916
00:32:57,919 --> 00:32:59,039
discussing those and if you have

917
00:32:59,039 --> 00:33:00,640
solutions please please please let me

918
00:33:00,640 --> 00:33:02,240
know these are very interesting and

919
00:33:02,240 --> 00:33:03,519
active areas

920
00:33:03,519 --> 00:33:05,600
areas of research

921
00:33:05,600 --> 00:33:08,559
first of metrics for starting seeds

922
00:33:08,559 --> 00:33:11,279
right we often have it that

923
00:33:11,279 --> 00:33:14,000
you have first a software before

924
00:33:14,000 --> 00:33:17,120
now you have 40 000 seats

925
00:33:17,120 --> 00:33:19,760
you've seen that

926
00:33:19,760 --> 00:33:21,679
you want to continue fuzzing because the

927
00:33:21,679 --> 00:33:22,799
software changed a bit or the

928
00:33:22,799 --> 00:33:24,399
configuration change of it which of

929
00:33:24,399 --> 00:33:26,480
these 40 000 seeds to use as your

930
00:33:26,480 --> 00:33:29,200
starting corpus

931
00:33:29,200 --> 00:33:31,200
how do you generate goods starting

932
00:33:31,200 --> 00:33:33,519
corpora right

933
00:33:33,519 --> 00:33:36,000
in academia papers are often evaluated

934
00:33:36,000 --> 00:33:39,120
we start with empty seats but any

935
00:33:39,120 --> 00:33:41,519
good analyst will spend 10 minutes to

936
00:33:41,519 --> 00:33:43,919
create a set of good starting seats and

937
00:33:43,919 --> 00:33:47,200
then use those to to actually jump start

938
00:33:47,200 --> 00:33:50,240
the the exploration and fuzzing process

939
00:33:50,240 --> 00:33:52,240
cross distillation to reuse seeds among

940
00:33:52,240 --> 00:33:53,679
targets

941
00:33:53,679 --> 00:33:56,240
we've had great success when we uh when

942
00:33:56,240 --> 00:33:59,120
we did usb kernel fuzzing where we

943
00:33:59,120 --> 00:34:01,440
found around 40

944
00:34:01,440 --> 00:34:03,840
000 days in the in the linux kernel

945
00:34:03,840 --> 00:34:04,840
where

946
00:34:04,840 --> 00:34:06,640
um the

947
00:34:06,640 --> 00:34:09,199
we fuzzed a usb target and then the

948
00:34:09,199 --> 00:34:11,440
seats that we we got from there we just

949
00:34:11,440 --> 00:34:14,320
replayed on on windows and and mac os

950
00:34:14,320 --> 00:34:15,679
and then found a couple of odays and

951
00:34:15,679 --> 00:34:19,359
windows and mac os as well with this

952
00:34:19,359 --> 00:34:21,918
incomplete usb parsing

953
00:34:21,918 --> 00:34:23,599
so this is an interesting way to do

954
00:34:23,599 --> 00:34:25,199
cross distillation between targets and

955
00:34:25,199 --> 00:34:27,520
it goes back to a bit to what david said

956
00:34:27,520 --> 00:34:29,199
with the with the a b

957
00:34:29,199 --> 00:34:31,520
a b testing with the different url url

958
00:34:31,520 --> 00:34:32,879
lips

959
00:34:32,879 --> 00:34:35,199
stateful programs and network protocols

960
00:34:35,199 --> 00:34:37,119
this is a really really hard target to

961
00:34:37,119 --> 00:34:38,000
look at

962
00:34:38,000 --> 00:34:40,560
handling more peripherals helping

963
00:34:40,560 --> 00:34:44,560
developers analyze discovered crashes

964
00:34:44,560 --> 00:34:47,599
and distinguishing the exploration phase

965
00:34:47,599 --> 00:34:49,520
from the exploitation phase during

966
00:34:49,520 --> 00:34:51,119
fuzzing and i think we need to break

967
00:34:51,119 --> 00:34:52,879
this into multiple phases where we're

968
00:34:52,879 --> 00:34:54,800
using different kinds of feedback

969
00:34:54,800 --> 00:34:56,320
different kind of mutators different

970
00:34:56,320 --> 00:34:57,520
kind of

971
00:34:57,520 --> 00:35:00,240
options there

972
00:35:00,240 --> 00:35:02,240
talk to me about this during the break

973
00:35:02,240 --> 00:35:04,480
or any time during the day i'll be i'll

974
00:35:04,480 --> 00:35:05,920
be around

975
00:35:05,920 --> 00:35:07,280
let me conclude

976
00:35:07,280 --> 00:35:09,359
please join me in riding the fuzzing

977
00:35:09,359 --> 00:35:11,839
hype train it's an amazing uh it's an

978
00:35:11,839 --> 00:35:14,079
amazing train bugs are everywhere and

979
00:35:14,079 --> 00:35:16,640
fuzzers allow you to find these bugs to

980
00:35:16,640 --> 00:35:19,359
uh to then do fun stuff with them

981
00:35:19,359 --> 00:35:21,599
it's easily integratable into the

982
00:35:21,599 --> 00:35:23,839
development chain as an analyst you can

983
00:35:23,839 --> 00:35:27,280
use it to uh to to target bug bounty

984
00:35:27,280 --> 00:35:28,640
programs

985
00:35:28,640 --> 00:35:30,960
the goal is that you leverage feedback

986
00:35:30,960 --> 00:35:33,280
uh from coverage to find more and

987
00:35:33,280 --> 00:35:36,000
interesting crashes and uh best feedback

988
00:35:36,000 --> 00:35:38,160
and mutations are program dependent so

989
00:35:38,160 --> 00:35:41,119
we'll we'll start or

990
00:35:41,119 --> 00:35:43,760
slowly move to an area where we will

991
00:35:43,760 --> 00:35:45,520
hand tune the fuzzers to the to the

992
00:35:45,520 --> 00:35:47,520
different use cases

993
00:35:47,520 --> 00:35:50,079
some interesting future research that

994
00:35:50,079 --> 00:35:52,640
you could look at increasing usability

995
00:35:52,640 --> 00:35:54,480
reducing startup costs

996
00:35:54,480 --> 00:35:55,760
that's also something that we are

997
00:35:55,760 --> 00:35:57,920
looking at we're providing the tutorials

998
00:35:57,920 --> 00:36:01,119
and on the websites and so on um

999
00:36:01,119 --> 00:36:02,400
specializing fuzzing for new

1000
00:36:02,400 --> 00:36:04,640
environments such as embedded systems

1001
00:36:04,640 --> 00:36:06,480
and then helping developers make sense

1002
00:36:06,480 --> 00:36:09,119
of the bugs this is what the igor system

1003
00:36:09,119 --> 00:36:12,400
for example uh was targeting at that's

1004
00:36:12,400 --> 00:36:14,160
all what i wanted to say today i hope

1005
00:36:14,160 --> 00:36:16,480
you have some time for questions um

1006
00:36:16,480 --> 00:36:19,359
thank you for your attention and

1007
00:36:19,359 --> 00:36:21,598
please

1008
00:36:23,200 --> 00:36:26,200
okay

1009
00:36:29,359 --> 00:36:30,990
uh

1010
00:36:30,990 --> 00:36:49,149
[Music]

