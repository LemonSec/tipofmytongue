1
00:00:18,810 --> 00:00:20,860
well thank you for the introduction

2
00:00:20,860 --> 00:00:27,160
first so I wanted to talk about micro

3
00:00:27,160 --> 00:00:29,680
architectural attacks and probably I

4
00:00:29,680 --> 00:00:34,510
will show huge to you during this talk

5
00:00:34,510 --> 00:00:36,610
but I also saw it like it this should be

6
00:00:36,610 --> 00:00:38,649
a keynote so I should have some some

7
00:00:38,649 --> 00:00:40,840
message that I give to you and it should

8
00:00:40,840 --> 00:00:43,270
be more high-level so I should only

9
00:00:43,270 --> 00:00:46,090
touch the surface and I saw like nah

10
00:00:46,090 --> 00:00:48,370
That's not me I will go deep down to the

11
00:00:48,370 --> 00:00:51,160
technical details and we will look at

12
00:00:51,160 --> 00:00:55,690
interesting problems so I would still

13
00:00:55,690 --> 00:00:57,100
have a message and the message will be

14
00:00:57,100 --> 00:00:58,800
something maybe along the lines of

15
00:00:58,800 --> 00:01:01,780
hardware is the new software right think

16
00:01:01,780 --> 00:01:03,579
about the conversation between some

17
00:01:03,579 --> 00:01:07,630
software engineers in the early 90s and

18
00:01:07,630 --> 00:01:09,970
then they talked about this problem of

19
00:01:09,970 --> 00:01:12,729
software bugs that is like becoming more

20
00:01:12,729 --> 00:01:14,619
and more of a problem and they are like

21
00:01:14,619 --> 00:01:17,140
yeah but with all these new techniques

22
00:01:17,140 --> 00:01:18,970
maybe with formal verification with

23
00:01:18,970 --> 00:01:21,190
static analyzers at some later point in

24
00:01:21,190 --> 00:01:24,970
the discussion a few years on maybe we

25
00:01:24,970 --> 00:01:27,250
will get hold of this problem and then

26
00:01:27,250 --> 00:01:29,170
we don't have to worry about software

27
00:01:29,170 --> 00:01:32,320
bugs anymore it even sounds ridiculous

28
00:01:32,320 --> 00:01:34,720
as I say it right but if we think about

29
00:01:34,720 --> 00:01:37,780
hardware problems like Marek inspector

30
00:01:37,780 --> 00:01:39,040
you are they will add formal

31
00:01:39,040 --> 00:01:40,930
verification and then these problems

32
00:01:40,930 --> 00:01:43,270
will disappear in the future like no

33
00:01:43,270 --> 00:01:45,189
that's not how we write Hardware we

34
00:01:45,189 --> 00:01:47,350
write Hardware the same as software in

35
00:01:47,350 --> 00:01:50,409
editors on a computer just like software

36
00:01:50,409 --> 00:01:54,760
um so yeah I probably want to talk a bit

37
00:01:54,760 --> 00:01:57,460
about my attacks and and the ideas that

38
00:01:57,460 --> 00:01:59,710
we had there and many of those are

39
00:01:59,710 --> 00:02:04,090
really nice ideas I would say but some

40
00:02:04,090 --> 00:02:06,220
of them also weren't like for instance

41
00:02:06,220 --> 00:02:08,378
this we made these t-shirts and run

42
00:02:08,378 --> 00:02:09,908
around at conferences with them and

43
00:02:09,908 --> 00:02:12,610
actually it's it's really they really

44
00:02:12,610 --> 00:02:17,379
have a very fundamental flaw I several

45
00:02:17,379 --> 00:02:19,599
times experienced that at conferences

46
00:02:19,599 --> 00:02:21,909
people would ask me like what does the

47
00:02:21,909 --> 00:02:25,360
code on your bag say and like I can't

48
00:02:25,360 --> 00:02:27,370
see it I can't explain you line by line

49
00:02:27,370 --> 00:02:28,760
what it does because like

50
00:02:28,760 --> 00:02:33,530
so we are not usability experts maybe we

51
00:02:33,530 --> 00:02:37,760
could use one I guess okay so the

52
00:02:37,760 --> 00:02:40,160
attacks now we we like to have fun at

53
00:02:40,160 --> 00:02:42,260
work the most important thing in life is

54
00:02:42,260 --> 00:02:45,050
having having fun enjoying life and that

55
00:02:45,050 --> 00:02:47,690
also goes for work so when we worked on

56
00:02:47,690 --> 00:02:50,450
a prime and probe cash attack in the

57
00:02:50,450 --> 00:02:52,640
Amazon Cloud we thought like well primal

58
00:02:52,640 --> 00:02:54,640
probe is already named that exists and

59
00:02:54,640 --> 00:02:57,410
Amazon Prime is already something that

60
00:02:57,410 --> 00:02:59,629
exists well let's just compile combine

61
00:02:59,629 --> 00:03:01,370
that then we have Amazon Prime and probe

62
00:03:01,370 --> 00:03:03,530
we will see that later on today or you

63
00:03:03,530 --> 00:03:06,260
probably know angularjs and that's like

64
00:03:06,260 --> 00:03:08,599
it says something like rich features for

65
00:03:08,599 --> 00:03:11,030
the web or something with the slogan

66
00:03:11,030 --> 00:03:13,489
underneath we changed it into roham rjs

67
00:03:13,489 --> 00:03:16,040
wrote privileges for web apps which is

68
00:03:16,040 --> 00:03:17,660
also nice I mean who doesn't want to

69
00:03:17,660 --> 00:03:19,459
have root privileges in a JavaScript app

70
00:03:19,459 --> 00:03:22,940
or fantastic timers and where to find

71
00:03:22,940 --> 00:03:25,360
them that we found high resolution high

72
00:03:25,360 --> 00:03:28,130
resolution timers in JavaScript for

73
00:03:28,130 --> 00:03:29,959
microarchitecture attacks and a nice

74
00:03:29,959 --> 00:03:32,569
thing about this one was this guy

75
00:03:32,569 --> 00:03:35,180
already holds the clock so it's already

76
00:03:35,180 --> 00:03:38,859
about timers or we try to mitigate

77
00:03:38,859 --> 00:03:40,569
javascript-based

78
00:03:40,569 --> 00:03:42,200
microarchitecture early texts or

79
00:03:42,200 --> 00:03:44,030
side-channel attacks and we call it

80
00:03:44,030 --> 00:03:46,010
javascript 0 it's more like a healthier

81
00:03:46,010 --> 00:03:48,950
variant of JavaScript all right with all

82
00:03:48,950 --> 00:03:51,920
the things that are dangerous so we are

83
00:03:51,920 --> 00:03:54,260
talking about side-channel attacks here

84
00:03:54,260 --> 00:03:57,410
so what is the factional attack you

85
00:03:57,410 --> 00:03:59,180
probably know this from the from maybe

86
00:03:59,180 --> 00:04:01,310
from old movies and where someone with a

87
00:04:01,310 --> 00:04:03,170
stethoscope listens to the clicking

88
00:04:03,170 --> 00:04:06,709
noises of the safe and when the latch

89
00:04:06,709 --> 00:04:09,200
snaps in you know that you have to turn

90
00:04:09,200 --> 00:04:12,560
the wheel the other direction so by that

91
00:04:12,560 --> 00:04:15,769
you can crack the combination of the

92
00:04:15,769 --> 00:04:18,560
code of the of the faith so this is a

93
00:04:18,560 --> 00:04:20,630
side channel attack because the safe

94
00:04:20,630 --> 00:04:22,160
doesn't directly tell you what the

95
00:04:22,160 --> 00:04:25,250
secret combination is unlike think about

96
00:04:25,250 --> 00:04:27,620
something like heartbleed in hard lead

97
00:04:27,620 --> 00:04:30,500
you directly get data through some

98
00:04:30,500 --> 00:04:32,450
vulnerability that's not a side channel

99
00:04:32,450 --> 00:04:34,160
attack but this is a side channel attack

100
00:04:34,160 --> 00:04:36,289
because this noise is just meta

101
00:04:36,289 --> 00:04:39,409
information that the safe by the way it

102
00:04:39,409 --> 00:04:42,090
is manufactured by design

103
00:04:42,090 --> 00:04:45,150
produces we can't avoid it somehow or we

104
00:04:45,150 --> 00:04:46,980
can we can make it more difficult for

105
00:04:46,980 --> 00:04:49,710
the attacker but we can't avoid it so my

106
00:04:49,710 --> 00:04:52,070
definition for citation attacks is

107
00:04:52,070 --> 00:04:55,200
obtaining metadata so the obtaining part

108
00:04:55,200 --> 00:04:56,820
is important the metadata part is

109
00:04:56,820 --> 00:04:59,130
important and then deriving data from it

110
00:04:59,130 --> 00:05:01,740
or deriving secret data secrets from it

111
00:05:01,740 --> 00:05:05,460
so let's make a quick check if I profile

112
00:05:05,460 --> 00:05:07,140
cache utilization with performance

113
00:05:07,140 --> 00:05:10,140
counters who thinks that's a side

114
00:05:10,140 --> 00:05:11,660
Channel

115
00:05:11,660 --> 00:05:13,860
okay I would say it's not a site

116
00:05:13,860 --> 00:05:15,540
generally because I just profile cache

117
00:05:15,540 --> 00:05:17,490
utilization right that's what I want to

118
00:05:17,490 --> 00:05:20,070
do but if I profile cache utilization or

119
00:05:20,070 --> 00:05:21,960
observed cache utilization with

120
00:05:21,960 --> 00:05:23,940
performance counters and use it to infer

121
00:05:23,940 --> 00:05:26,520
cryptokey does it become a side channel

122
00:05:26,520 --> 00:05:29,220
attack yes then it becomes a side

123
00:05:29,220 --> 00:05:31,260
channel attack so this inference step is

124
00:05:31,260 --> 00:05:33,420
an important part of side channel

125
00:05:33,420 --> 00:05:36,330
attacks usually if you directly get the

126
00:05:36,330 --> 00:05:39,060
entire key without having any inference

127
00:05:39,060 --> 00:05:41,310
step then we don't consider this a side

128
00:05:41,310 --> 00:05:44,400
channel attack same for measuring memory

129
00:05:44,400 --> 00:05:46,110
access latency with flush and reload I

130
00:05:46,110 --> 00:05:47,970
mean flush and reload is described as a

131
00:05:47,970 --> 00:05:50,760
side channel attack so is this already a

132
00:05:50,760 --> 00:05:52,050
side channel attack if I measure the

133
00:05:52,050 --> 00:05:53,850
memory access latency who thinks it's a

134
00:05:53,850 --> 00:05:54,720
side channel attack

135
00:05:54,720 --> 00:05:59,370
oh no basically no one but if I use it

136
00:05:59,370 --> 00:06:03,030
to infer keystroke timings or inter

137
00:06:03,030 --> 00:06:04,800
keystroke timings does it become a side

138
00:06:04,800 --> 00:06:07,950
channel attack yes okay great so we all

139
00:06:07,950 --> 00:06:11,280
agree on this terminology but then

140
00:06:11,280 --> 00:06:14,400
there's into it and they had this menu

141
00:06:14,400 --> 00:06:17,940
and maybe by now they also have a

142
00:06:17,940 --> 00:06:20,060
different opinion on that but maybe not

143
00:06:20,060 --> 00:06:22,680
but they have this menu or white paper

144
00:06:22,680 --> 00:06:24,300
where they say internalizes of

145
00:06:24,300 --> 00:06:27,030
speculative execution side channels now

146
00:06:27,030 --> 00:06:30,060
the question is what is that speculative

147
00:06:30,060 --> 00:06:32,010
execution science we have psytrance we

148
00:06:32,010 --> 00:06:34,230
know side channels right so these are

149
00:06:34,230 --> 00:06:36,840
traditional cache attacks maybe power

150
00:06:36,840 --> 00:06:38,490
side channel attacks a.m. attacks we

151
00:06:38,490 --> 00:06:40,770
know a lot of different scientists most

152
00:06:40,770 --> 00:06:42,210
of the time that I'm working in this

153
00:06:42,210 --> 00:06:44,400
area I'm focusing on cache attacks may

154
00:06:44,400 --> 00:06:46,860
be on crypto keys may be on keystrokes

155
00:06:46,860 --> 00:06:50,430
so this is usually this what I describe

156
00:06:50,430 --> 00:06:53,760
you infer something from metadata then

157
00:06:53,760 --> 00:06:55,820
there is miss speculation

158
00:06:55,820 --> 00:06:57,950
like Spectre hypertech's where you have

159
00:06:57,950 --> 00:06:59,930
a branch misprediction you speculate the

160
00:06:59,930 --> 00:07:02,720
wrong way and you leak data because the

161
00:07:02,720 --> 00:07:04,430
program does something it shouldn't do

162
00:07:04,430 --> 00:07:08,360
and then we have lazy exception handling

163
00:07:08,360 --> 00:07:10,910
like a text like meltdown for share of

164
00:07:10,910 --> 00:07:14,030
zombie load there the processor already

165
00:07:14,030 --> 00:07:16,730
knows I'm now going to do something that

166
00:07:16,730 --> 00:07:18,800
is that does not make any sense for me

167
00:07:18,800 --> 00:07:20,780
like I'm I'm just trying to clear the

168
00:07:20,780 --> 00:07:23,300
pipeline as fast as possible so the

169
00:07:23,300 --> 00:07:25,100
process of switches in this mode where

170
00:07:25,100 --> 00:07:28,130
anything is fine right so it switches in

171
00:07:28,130 --> 00:07:29,740
this mode it knows that this is not

172
00:07:29,740 --> 00:07:32,840
something useful to do now to access

173
00:07:32,840 --> 00:07:34,430
these memory locations because it

174
00:07:34,430 --> 00:07:37,280
already knows that it should fault so

175
00:07:37,280 --> 00:07:39,440
let's if these a better name miss

176
00:07:39,440 --> 00:07:41,360
speculation is the long word lazy

177
00:07:41,360 --> 00:07:43,790
exception handling even worse let's just

178
00:07:43,790 --> 00:07:45,710
call them meltdown type attacks and

179
00:07:45,710 --> 00:07:48,440
Spector type attacks because that is

180
00:07:48,440 --> 00:07:50,480
basically what they are and then also

181
00:07:50,480 --> 00:07:52,850
let's avoid the term speculative sachen

182
00:07:52,850 --> 00:07:54,860
attacks and I attended an Intel event

183
00:07:54,860 --> 00:07:56,870
earlier this year and either there they

184
00:07:56,870 --> 00:07:58,940
also had the slide and told them I think

185
00:07:58,940 --> 00:08:01,220
it would be better for you to avoid this

186
00:08:01,220 --> 00:08:04,160
term because scientists those people who

187
00:08:04,160 --> 00:08:06,560
are who are familiar with scientists for

188
00:08:06,560 --> 00:08:08,180
instance power psytrance are aware that

189
00:08:08,180 --> 00:08:11,120
we will never get rid of side channels

190
00:08:11,120 --> 00:08:13,610
entirely as long as you have some

191
00:08:13,610 --> 00:08:16,820
difference in what the algorithm or the

192
00:08:16,820 --> 00:08:19,310
specific implementation does in one or

193
00:08:19,310 --> 00:08:21,620
the other case even if you just have two

194
00:08:21,620 --> 00:08:24,410
wires for two cases you can measure the

195
00:08:24,410 --> 00:08:26,900
difference at some point so we will

196
00:08:26,900 --> 00:08:29,030
never get rid of this bubble but we can

197
00:08:29,030 --> 00:08:31,430
get rid of this bubble entirely throwing

198
00:08:31,430 --> 00:08:34,220
this altogether leaves a very unclear

199
00:08:34,220 --> 00:08:36,740
message to the customers what you will

200
00:08:36,740 --> 00:08:38,719
be able to mitigate and what you won't

201
00:08:38,719 --> 00:08:41,419
be able to mitigate so maybe let's talk

202
00:08:41,419 --> 00:08:44,059
about mitigations against these attacks

203
00:08:44,059 --> 00:08:46,520
but we only do that after we understood

204
00:08:46,520 --> 00:08:48,140
them and for that we first have to

205
00:08:48,140 --> 00:08:51,800
understand how they work and there's one

206
00:08:51,800 --> 00:08:53,990
thing that I all that I like to talk

207
00:08:53,990 --> 00:08:56,380
about a lot because I enjoy it a lot

208
00:08:56,380 --> 00:09:00,860
it's of course it's a food right I mean

209
00:09:00,860 --> 00:09:05,780
who doesn't like food so cooking I'm not

210
00:09:05,780 --> 00:09:09,220
very good at cooking but I it's nice

211
00:09:09,220 --> 00:09:14,620
to get something that is tasty right and

212
00:09:14,620 --> 00:09:17,260
when I cook I have to follow a recipe

213
00:09:17,260 --> 00:09:19,270
and usually you have all the ingredients

214
00:09:19,270 --> 00:09:22,090
and I set them all on the table so that

215
00:09:22,090 --> 00:09:24,430
I can check which ingredients are there

216
00:09:24,430 --> 00:09:26,470
and usually what I see is oh one thing

217
00:09:26,470 --> 00:09:27,160
is missing

218
00:09:27,160 --> 00:09:29,290
that's unfortunate so I can't start

219
00:09:29,290 --> 00:09:31,270
cooking so I have to go to the grocery

220
00:09:31,270 --> 00:09:34,570
store and then I get the ingredient

221
00:09:34,570 --> 00:09:36,550
there then I go back and I realized oh

222
00:09:36,550 --> 00:09:38,710
no there's something else missing yeah

223
00:09:38,710 --> 00:09:40,510
and then I go to the grocery store again

224
00:09:40,510 --> 00:09:42,430
that happens to me something like five

225
00:09:42,430 --> 00:09:44,290
to seven times and then I have all the

226
00:09:44,290 --> 00:09:47,950
ingredients at home yeah and I I came up

227
00:09:47,950 --> 00:09:51,190
with a very clever idea I I would argue

228
00:09:51,190 --> 00:09:52,720
that this is something you haven't seen

229
00:09:52,720 --> 00:09:56,130
before it's it's completely ingenious

230
00:09:56,130 --> 00:10:00,250
it's a device that allows you to store

231
00:10:00,250 --> 00:10:04,480
food I call it a food cache and it's

232
00:10:04,480 --> 00:10:06,760
really great so whenever you go to the

233
00:10:06,760 --> 00:10:08,440
grocery store you can store food in

234
00:10:08,440 --> 00:10:10,960
there and retrieve it from there without

235
00:10:10,960 --> 00:10:13,030
going to the grocery store and save a

236
00:10:13,030 --> 00:10:15,460
lot of time and I told that to my office

237
00:10:15,460 --> 00:10:19,350
colleagues and they were like seriously

238
00:10:19,350 --> 00:10:24,610
this already exists in processors since

239
00:10:24,610 --> 00:10:27,040
thirty years we call it a CPU cache and

240
00:10:27,040 --> 00:10:29,440
a CPU does exactly that whenever you

241
00:10:29,440 --> 00:10:32,440
access some memory location it will

242
00:10:32,440 --> 00:10:34,360
first have a cache miss so it will be

243
00:10:34,360 --> 00:10:36,280
slow because it has to go to the DRAM

244
00:10:36,280 --> 00:10:39,040
like the grocery store so it has to wait

245
00:10:39,040 --> 00:10:41,020
for the response and then the data is

246
00:10:41,020 --> 00:10:43,210
there it's stored in the cache and then

247
00:10:43,210 --> 00:10:45,250
you can continue so this takes a long

248
00:10:45,250 --> 00:10:47,200
time but the second time you access it

249
00:10:47,200 --> 00:10:49,350
it's fast because it's already there

250
00:10:49,350 --> 00:10:52,510
okay so if first time slow because of

251
00:10:52,510 --> 00:10:54,130
the DRM ex the second time is fast

252
00:10:54,130 --> 00:10:57,850
because of the cache and thats already

253
00:10:57,850 --> 00:10:59,170
interesting now we have a timing

254
00:10:59,170 --> 00:11:01,390
difference right and we just said if we

255
00:11:01,390 --> 00:11:03,550
have some difference if it even if it's

256
00:11:03,550 --> 00:11:06,310
just two wires then we have a side

257
00:11:06,310 --> 00:11:08,440
channel so in this case this is already

258
00:11:08,440 --> 00:11:09,970
clear that we must have a side channel

259
00:11:09,970 --> 00:11:11,170
here and the side channel attack works

260
00:11:11,170 --> 00:11:13,780
like this we explain flush and reload

261
00:11:13,780 --> 00:11:15,730
now and here we have some shared memory

262
00:11:15,730 --> 00:11:18,010
shared memory is shared in the processor

263
00:11:18,010 --> 00:11:20,560
cache so if we have an attacker process

264
00:11:20,560 --> 00:11:22,120
and a victim process they might share

265
00:11:22,120 --> 00:11:22,930
some memory

266
00:11:22,930 --> 00:11:26,470
library maybe and if it's cached for one

267
00:11:26,470 --> 00:11:27,730
of them it's cached for the other as

268
00:11:27,730 --> 00:11:29,290
well because she had memory shared in

269
00:11:29,290 --> 00:11:31,899
the cache and if the attacker now

270
00:11:31,899 --> 00:11:33,610
flushes this memory location the

271
00:11:33,610 --> 00:11:35,529
attacker knows what to expect

272
00:11:35,529 --> 00:11:38,290
the attacker now knows it shouldn't be

273
00:11:38,290 --> 00:11:41,610
in the cache anymore unless the victim

274
00:11:41,610 --> 00:11:44,529
excesses exactly that memory location

275
00:11:44,529 --> 00:11:46,779
and then at a later point in time

276
00:11:46,779 --> 00:11:49,540
because I know what I expect I can

277
00:11:49,540 --> 00:11:51,550
measure how long it takes to access this

278
00:11:51,550 --> 00:11:53,620
location and if it's fast I know the

279
00:11:53,620 --> 00:11:55,540
victim accessed this and if it's slow I

280
00:11:55,540 --> 00:11:57,870
know the victim didn't access this oh

281
00:11:57,870 --> 00:12:00,730
that's really nice because that's a

282
00:12:00,730 --> 00:12:02,440
that's a nice side Channel this is

283
00:12:02,440 --> 00:12:04,930
typically a 64 byte regions so I can

284
00:12:04,930 --> 00:12:07,690
track what other programs do on a 64

285
00:12:07,690 --> 00:12:10,750
byte granularity it's not as good as GDP

286
00:12:10,750 --> 00:12:15,040
but it's also not much worse okay so the

287
00:12:15,040 --> 00:12:16,690
question is how do we measure this time

288
00:12:16,690 --> 00:12:18,610
so this sounds very easy and right now

289
00:12:18,610 --> 00:12:19,990
you'll simply find a lot of things here

290
00:12:19,990 --> 00:12:22,230
so how does measuring time actually work

291
00:12:22,230 --> 00:12:24,580
and there are different approaches you

292
00:12:24,580 --> 00:12:26,770
can use zero serializing instructions

293
00:12:26,770 --> 00:12:29,110
actually serializing instructions and

294
00:12:29,110 --> 00:12:30,820
offenses you have to use those because

295
00:12:30,820 --> 00:12:33,040
modern processors work out of order so

296
00:12:33,040 --> 00:12:34,779
if you don't do that the process of my

297
00:12:34,779 --> 00:12:36,810
dream order all of these instructions

298
00:12:36,810 --> 00:12:41,350
and by doing that are DTS C or R DTS CP

299
00:12:41,350 --> 00:12:44,200
is usually the choice to to get a cycle

300
00:12:44,200 --> 00:12:46,270
something like a cycle accurate timer

301
00:12:46,270 --> 00:12:48,730
and because it's so complicated to

302
00:12:48,730 --> 00:12:53,650
actually measure like the the latency of

303
00:12:53,650 --> 00:12:57,160
small code snippets Intel wrote a white

304
00:12:57,160 --> 00:12:59,200
paper how to benchmark code execution

305
00:12:59,200 --> 00:13:02,320
time on intel ia-32 and IA 64

306
00:13:02,320 --> 00:13:04,060
instructions that architecture is

307
00:13:04,060 --> 00:13:07,630
December 2010 this is really nice

308
00:13:07,630 --> 00:13:10,390
because it tells you how to do these

309
00:13:10,390 --> 00:13:12,730
measurements but at the same time last

310
00:13:12,730 --> 00:13:14,170
year you might have seen this headline

311
00:13:14,170 --> 00:13:16,270
into a publishers microcode security

312
00:13:16,270 --> 00:13:18,490
patches no benchmarking or comparison

313
00:13:18,490 --> 00:13:22,630
allowed but it's unfortunate right if

314
00:13:22,630 --> 00:13:26,290
they have their own white paper okay but

315
00:13:26,290 --> 00:13:28,570
they later on updated and this was some

316
00:13:28,570 --> 00:13:30,610
someone being overly eager to avoid

317
00:13:30,610 --> 00:13:34,329
having negative press I guess about the

318
00:13:34,329 --> 00:13:36,270
benchmarks okay

319
00:13:36,270 --> 00:13:38,760
so we will do this benchmarking so how

320
00:13:38,760 --> 00:13:41,130
long does it take if I try to get a

321
00:13:41,130 --> 00:13:43,980
cache hit well most of the time this is

322
00:13:43,980 --> 00:13:45,750
the log scale histogram you can see the

323
00:13:45,750 --> 00:13:47,850
CPU cycles here most of the time I'm

324
00:13:47,850 --> 00:13:51,810
around 75 cycles for a cache hit for

325
00:13:51,810 --> 00:13:53,880
cache misses and this is really nice

326
00:13:53,880 --> 00:13:55,620
even if you have no background in

327
00:13:55,620 --> 00:13:58,140
statistics it will be very easy to put

328
00:13:58,140 --> 00:14:00,780
the threshold here and say if it's below

329
00:14:00,780 --> 00:14:02,670
this then it's a hit if it's above this

330
00:14:02,670 --> 00:14:06,300
and it's a Miss that's super easy but

331
00:14:06,300 --> 00:14:08,910
you see there are these gaps between the

332
00:14:08,910 --> 00:14:11,280
bars right and they are in this plot

333
00:14:11,280 --> 00:14:14,010
because I plotted it this way but

334
00:14:14,010 --> 00:14:16,770
actually if you would look at these bars

335
00:14:16,770 --> 00:14:20,040
on a raw a data set you would see that

336
00:14:20,040 --> 00:14:23,310
there are cycle numbers which have zero

337
00:14:23,310 --> 00:14:26,730
and right left and right of that you

338
00:14:26,730 --> 00:14:29,550
have very high bars so what is the

339
00:14:29,550 --> 00:14:31,410
reason for that because the process of

340
00:14:31,410 --> 00:14:34,140
the RT RT TC is not actually a cycle

341
00:14:34,140 --> 00:14:36,150
count I'd only approximate one and that

342
00:14:36,150 --> 00:14:38,150
means on some systems

343
00:14:38,150 --> 00:14:41,550
Reta C can be too inaccurate or also an

344
00:14:41,550 --> 00:14:43,290
armed systems you might not even have an

345
00:14:43,290 --> 00:14:44,970
instruction available to user space to

346
00:14:44,970 --> 00:14:47,730
do that and in these cases we also have

347
00:14:47,730 --> 00:14:49,890
a very interesting idea and I think that

348
00:14:49,890 --> 00:14:51,450
is the deepest we go in this

349
00:14:51,450 --> 00:14:54,750
presentation we can build our own timer

350
00:14:54,750 --> 00:14:56,460
does anyone have an idea how to build a

351
00:14:56,460 --> 00:14:58,700
timer

352
00:15:00,380 --> 00:15:03,990
well our idea was we start a thread and

353
00:15:03,990 --> 00:15:06,720
the thread continuously increments a

354
00:15:06,720 --> 00:15:10,050
global variable and with that we have a

355
00:15:10,050 --> 00:15:14,850
super nice timer right and the global

356
00:15:14,850 --> 00:15:16,470
variable is basically all our times then

357
00:15:16,470 --> 00:15:18,300
it doesn't give a psychic count but

358
00:15:18,300 --> 00:15:22,440
allows us to compare the time yeah I

359
00:15:22,440 --> 00:15:24,390
imagine this is a solution like this

360
00:15:24,390 --> 00:15:28,290
right and also I mean what are our

361
00:15:28,290 --> 00:15:30,630
expectations do you really think we can

362
00:15:30,630 --> 00:15:34,860
do better than the hardware No so on my

363
00:15:34,860 --> 00:15:37,920
processor our DTSC the RT TC can only

364
00:15:37,920 --> 00:15:41,070
return values in a distance of three so

365
00:15:41,070 --> 00:15:43,290
I could get the result three cycles or

366
00:15:43,290 --> 00:15:45,420
six cycles or nine cycles but nothing in

367
00:15:45,420 --> 00:15:48,030
between so I would say the resolution of

368
00:15:48,030 --> 00:15:49,980
RDT sees three cycles if I do

369
00:15:49,980 --> 00:15:54,570
this in a loop well if I try to measure

370
00:15:54,570 --> 00:15:57,420
the time if I try to get a timestamp by

371
00:15:57,420 --> 00:16:00,270
running this loop and see who thinks the

372
00:16:00,270 --> 00:16:02,460
resolution will be better than with ret

373
00:16:02,460 --> 00:16:07,950
SC who thinks it will be worse yeah okay

374
00:16:07,950 --> 00:16:10,680
I think the majority was forwards but

375
00:16:10,680 --> 00:16:12,780
there was not a strong participation in

376
00:16:12,780 --> 00:16:15,110
this vote yeah

377
00:16:15,110 --> 00:16:17,700
but majority is right of course I think

378
00:16:17,700 --> 00:16:19,710
what were we expecting yes of course

379
00:16:19,710 --> 00:16:21,120
this is low but then we learned

380
00:16:21,120 --> 00:16:24,300
something in university if C code is too

381
00:16:24,300 --> 00:16:27,930
slow we write it in assembly let's go

382
00:16:27,930 --> 00:16:31,590
for assembly okay so assembly we wrote

383
00:16:31,590 --> 00:16:33,540
this code we moved the timestamp

384
00:16:33,540 --> 00:16:35,130
variable the address of the variable

385
00:16:35,130 --> 00:16:38,580
into icx and then increment our CX like

386
00:16:38,580 --> 00:16:40,500
dereference r CX incremented all the

387
00:16:40,500 --> 00:16:42,420
time and this is an endless loop jump

388
00:16:42,420 --> 00:16:45,510
there who thinks if the resolution will

389
00:16:45,510 --> 00:16:49,140
be better than with fee who thinks the

390
00:16:49,140 --> 00:16:50,910
resolution will be better than with ret

391
00:16:50,910 --> 00:16:54,390
is see a few more hands than before and

392
00:16:54,390 --> 00:16:59,810
in fact it is better than see yes oh

393
00:16:59,810 --> 00:17:04,650
yeah okay that's not so impressive but

394
00:17:04,650 --> 00:17:06,750
then we thought well maybe we maybe the

395
00:17:06,750 --> 00:17:08,790
assembly code is not optimal right it

396
00:17:08,790 --> 00:17:10,290
only has two instructions two

397
00:17:10,290 --> 00:17:12,839
instructions maybe that's too much or

398
00:17:12,839 --> 00:17:14,880
too little so maybe if we add more

399
00:17:14,880 --> 00:17:17,310
instructions it gets faster we thought

400
00:17:17,310 --> 00:17:19,440
so what do we do here we increment a

401
00:17:19,440 --> 00:17:21,359
register and we move the register value

402
00:17:21,359 --> 00:17:23,579
to this memory location of the timestamp

403
00:17:23,579 --> 00:17:26,250
of the global variable who thinks this

404
00:17:26,250 --> 00:17:28,680
has a higher resolution than the

405
00:17:28,680 --> 00:17:30,860
previous assembly

406
00:17:30,860 --> 00:17:35,460
okay that's who thinks it doesn't yeah

407
00:17:35,460 --> 00:17:37,790
okay so majority is for it doesn't and

408
00:17:37,790 --> 00:17:40,650
who thinks it has a higher resolution

409
00:17:40,650 --> 00:17:48,350
than our DTSC ah who thinks it doesn't

410
00:17:48,350 --> 00:17:53,010
whoa how does that work why does that

411
00:17:53,010 --> 00:17:56,550
work out of order execution this

412
00:17:56,550 --> 00:17:58,350
instruction doesn't have any dependency

413
00:17:58,350 --> 00:18:00,180
on the timestamp our previous assembly

414
00:18:00,180 --> 00:18:03,250
code had to fetch the value

415
00:18:03,250 --> 00:18:05,290
and then increment it and then write it

416
00:18:05,290 --> 00:18:07,270
back this one increments in a register

417
00:18:07,270 --> 00:18:09,160
and just writes out to memory all the

418
00:18:09,160 --> 00:18:11,620
time so this is very nice can mount

419
00:18:11,620 --> 00:18:13,240
cache attacks this is a template cache

420
00:18:13,240 --> 00:18:15,460
template attack we press keystrokes in

421
00:18:15,460 --> 00:18:17,860
this editor and running then we just at

422
00:18:17,860 --> 00:18:20,650
some point stop this and pick any

423
00:18:20,650 --> 00:18:22,360
address which has a certain number of

424
00:18:22,360 --> 00:18:25,210
hits maybe this one this one looks good

425
00:18:25,210 --> 00:18:28,540
it's on letter that we press here one

426
00:18:28,540 --> 00:18:31,990
time and this is super nice because here

427
00:18:31,990 --> 00:18:34,690
we have the inter keystroke timing or

428
00:18:34,690 --> 00:18:36,250
here we have the inter k stroke timing

429
00:18:36,250 --> 00:18:38,800
and that can be used to infer the words

430
00:18:38,800 --> 00:18:41,380
that we actually typed here there was a

431
00:18:41,380 --> 00:18:44,080
recent attack just published a few days

432
00:18:44,080 --> 00:18:46,060
ago the netcat attack on our they also

433
00:18:46,060 --> 00:18:48,730
look at inter keystroke timings and by

434
00:18:48,730 --> 00:18:51,760
that infer words but with cache terminal

435
00:18:51,760 --> 00:18:53,080
attacks you can also just iterate over

436
00:18:53,080 --> 00:18:54,600
the address space and try to make

437
00:18:54,600 --> 00:18:57,100
distinction between different letters

438
00:18:57,100 --> 00:18:59,560
based on the address so here this is

439
00:18:59,560 --> 00:19:02,440
from lip GDK and they do a binary search

440
00:19:02,440 --> 00:19:04,960
to translate key codes and you know in a

441
00:19:04,960 --> 00:19:06,910
binary search there are these leaf nodes

442
00:19:06,910 --> 00:19:10,240
and the leaf nodes they are only

443
00:19:10,240 --> 00:19:12,430
accessed if it's exactly that key for

444
00:19:12,430 --> 00:19:15,430
instance for n this address great but

445
00:19:15,430 --> 00:19:17,470
also we can do other things with that

446
00:19:17,470 --> 00:19:20,470
for instance one night we thought it

447
00:19:20,470 --> 00:19:24,570
would be really a great idea to pipe

448
00:19:24,570 --> 00:19:29,650
generic tcp/ip traffic through the cache

449
00:19:29,650 --> 00:19:31,750
through a cache cover channel on the

450
00:19:31,750 --> 00:19:34,150
Amazon Cloud so here we will transfer a

451
00:19:34,150 --> 00:19:36,790
video from one Amazon ec2 instance to

452
00:19:36,790 --> 00:19:38,500
another which are co-located on the same

453
00:19:38,500 --> 00:19:41,710
physical machine and then we'll show the

454
00:19:41,710 --> 00:19:46,000
video in a local VLC client and they

455
00:19:46,000 --> 00:19:48,160
will transmit a video in this case

456
00:19:48,160 --> 00:19:51,640
without transmit having any network

457
00:19:51,640 --> 00:19:54,930
traffic you can see it here

458
00:20:00,930 --> 00:20:05,220
so hello from the other side

459
00:20:05,220 --> 00:20:07,500
[Music]

460
00:20:07,500 --> 00:20:11,410
remote shall throw the cash this time

461
00:20:11,410 --> 00:20:13,410
[Music]

462
00:20:13,410 --> 00:20:17,040
who runs through your system steal

463
00:20:17,040 --> 00:20:22,250
everything that I want and ask margin

464
00:20:22,910 --> 00:20:24,260
you

465
00:20:24,260 --> 00:20:26,789
[Music]

466
00:20:26,789 --> 00:20:29,789
me

467
00:20:31,830 --> 00:20:34,760
I don't

468
00:20:38,770 --> 00:20:40,400
[Music]

469
00:20:40,400 --> 00:20:44,150
I broke into your machine you catch my

470
00:20:44,150 --> 00:20:46,960
pattern

471
00:20:46,990 --> 00:20:50,309
doesn't save your

472
00:20:51,549 --> 00:20:53,779
and you can see there is no transmission

473
00:20:53,779 --> 00:20:57,049
on the sender side yes 0.01 nine

474
00:20:57,049 --> 00:20:59,479
megabytes 0.09 nine megabyte

475
00:20:59,479 --> 00:21:00,799
this is there's no transmission

476
00:21:00,799 --> 00:21:03,979
happening this was all transmitted

477
00:21:03,979 --> 00:21:05,210
through the cache we didn't have a

478
00:21:05,210 --> 00:21:06,440
single arrow and you can see the

479
00:21:06,440 --> 00:21:08,059
transmission rates through the cache

480
00:21:08,059 --> 00:21:12,769
here and this this is all like yeah okay

481
00:21:12,769 --> 00:21:14,119
you're laughing and like yeah this is

482
00:21:14,119 --> 00:21:16,070
fun and I hello from the other side you

483
00:21:16,070 --> 00:21:18,200
have it like we tried like the first

484
00:21:18,200 --> 00:21:20,419
word that Mukesh wants my co-author on

485
00:21:20,419 --> 00:21:22,940
this paper or one of the co-authors on

486
00:21:22,940 --> 00:21:25,070
his paper the first message that he

487
00:21:25,070 --> 00:21:26,659
transmitted over the channel was hello

488
00:21:26,659 --> 00:21:29,590
so he received hello from the other side

489
00:21:29,590 --> 00:21:34,039
so little is all fun but unless fork on

490
00:21:34,039 --> 00:21:36,109
Twitter said yeah this is all fun but

491
00:21:36,109 --> 00:21:38,659
imagine how many credit card credentials

492
00:21:38,659 --> 00:21:41,960
per second that is right it's a nice

493
00:21:41,960 --> 00:21:44,899
demo but it's a bit frightening also

494
00:21:44,899 --> 00:21:47,389
okay so let's take a look at something

495
00:21:47,389 --> 00:21:50,629
else I mean we all like Intel SGX which

496
00:21:50,629 --> 00:21:53,509
allows us to write insecure code and put

497
00:21:53,509 --> 00:21:55,159
it in an STX enclaves and then it's

498
00:21:55,159 --> 00:21:57,379
magically protected right that's not

499
00:21:57,379 --> 00:22:01,820
what STX does but unfortunately I've

500
00:22:01,820 --> 00:22:04,340
heard from from people from the industry

501
00:22:04,340 --> 00:22:06,919
that sometimes that this is the

502
00:22:06,919 --> 00:22:09,289
assumption that these tes give you this

503
00:22:09,289 --> 00:22:12,440
property and if you look through the STX

504
00:22:12,440 --> 00:22:14,349
developer guide the last chapter is like

505
00:22:14,349 --> 00:22:17,029
protection from side channel attacks and

506
00:22:17,029 --> 00:22:19,970
like who they thought about it and then

507
00:22:19,970 --> 00:22:22,009
it says Intel SGX does not provide

508
00:22:22,009 --> 00:22:23,539
explicit protection from side channel

509
00:22:23,539 --> 00:22:27,859
attacks it is the enclaves developer's

510
00:22:27,859 --> 00:22:29,720
responsibility to address scientific

511
00:22:29,720 --> 00:22:31,879
concerns and it's I think it's very

512
00:22:31,879 --> 00:22:33,580
clever right

513
00:22:33,580 --> 00:22:38,269
but if you look at the SGX Bitcoin

514
00:22:38,269 --> 00:22:40,789
wallets that are out there for instance

515
00:22:40,789 --> 00:22:43,309
if we look at T chain T chain and paper

516
00:22:43,309 --> 00:22:45,440
they say we assume the TE guarantees to

517
00:22:45,440 --> 00:22:47,330
hold and you're like ah ha yeah sounds

518
00:22:47,330 --> 00:22:48,109
good so far

519
00:22:48,109 --> 00:22:50,419
and do not consider side-channel attacks

520
00:22:50,419 --> 00:22:53,149
on the TE and we're like yeah okay that

521
00:22:53,149 --> 00:22:55,309
that is a problem because we can mount

522
00:22:55,309 --> 00:22:57,590
these attacks on sjx for instance this

523
00:22:57,590 --> 00:22:59,539
one this is a prime and prop attack on

524
00:22:59,539 --> 00:23:03,080
SGX on weak RSA implementation who can

525
00:23:03,080 --> 00:23:04,580
already see the key

526
00:23:04,580 --> 00:23:07,250
can anyone already see the key no let's

527
00:23:07,250 --> 00:23:09,590
I mean we're not so good on statistics

528
00:23:09,590 --> 00:23:11,630
right so let's just add a moving average

529
00:23:11,630 --> 00:23:13,610
moving average it's easy to understand

530
00:23:13,610 --> 00:23:14,630
moving average

531
00:23:14,630 --> 00:23:17,899
does anyone see the key now well let me

532
00:23:17,899 --> 00:23:19,970
add the solution here is the key all the

533
00:23:19,970 --> 00:23:23,470
peaks are ones and the valleys are zeros

534
00:23:23,470 --> 00:23:27,980
very nice yeah and then people are like

535
00:23:27,980 --> 00:23:29,870
no you can't do that we said it's out of

536
00:23:29,870 --> 00:23:32,330
scope the attackers don't care what is

537
00:23:32,330 --> 00:23:36,740
out of scope okay so let's get back to

538
00:23:36,740 --> 00:23:38,690
work so we want to continue cooking and

539
00:23:38,690 --> 00:23:40,850
something that always goes wrong when I

540
00:23:40,850 --> 00:23:42,889
cook following a recipe because I don't

541
00:23:42,889 --> 00:23:45,440
know how like who writes these recipes

542
00:23:45,440 --> 00:23:49,250
these must be very mean people because

543
00:23:49,250 --> 00:23:51,620
usually the last step is something like

544
00:23:51,620 --> 00:23:53,389
serve with cooked and peeled potatoes

545
00:23:53,389 --> 00:23:56,510
and I'm like yeah you could have told me

546
00:23:56,510 --> 00:23:58,639
that in step two that I should put them

547
00:23:58,639 --> 00:24:01,730
on the oven and then I have to wait for

548
00:24:01,730 --> 00:24:02,929
an hour and the parents-in-law are

549
00:24:02,929 --> 00:24:04,549
already in waiting waiting in front of

550
00:24:04,549 --> 00:24:06,679
the door and like ah we are here ah it's

551
00:24:06,679 --> 00:24:09,260
the food ready and I'm the girl well no

552
00:24:09,260 --> 00:24:12,529
I forgot the potatoes what will they

553
00:24:12,529 --> 00:24:14,990
think of me right so latency is bad not

554
00:24:14,990 --> 00:24:18,380
only for me but also for for others and

555
00:24:18,380 --> 00:24:20,840
therefore I came up with a very clever

556
00:24:20,840 --> 00:24:25,340
technique and when I go through a recipe

557
00:24:25,340 --> 00:24:28,100
now I first check all the steps and see

558
00:24:28,100 --> 00:24:30,679
which have a dependency and which ones I

559
00:24:30,679 --> 00:24:33,980
can paralyze right so I will reorder

560
00:24:33,980 --> 00:24:36,909
them I call it out of order cooking and

561
00:24:36,909 --> 00:24:39,200
I propose this to my colleagues and

562
00:24:39,200 --> 00:24:40,909
again they said well that already this

563
00:24:40,909 --> 00:24:43,190
processors do exactly the same they will

564
00:24:43,190 --> 00:24:45,380
reorder what they can reorder and if

565
00:24:45,380 --> 00:24:47,419
there are dependencies then well they

566
00:24:47,419 --> 00:24:49,610
run it after each other and that is

567
00:24:49,610 --> 00:24:51,529
already enough to know like we now know

568
00:24:51,529 --> 00:24:53,120
flush and reload we know out of order

569
00:24:53,120 --> 00:24:54,950
execution now we can build meltdown and

570
00:24:54,950 --> 00:24:56,779
the first test that we want to run for

571
00:24:56,779 --> 00:24:58,610
meltdown is this this code doesn't do

572
00:24:58,610 --> 00:25:00,620
anything meaningful right we dereference

573
00:25:00,620 --> 00:25:03,559
the null pointer and then we access an

574
00:25:03,559 --> 00:25:05,510
area location but this is the first

575
00:25:05,510 --> 00:25:07,100
check whether out of order execution

576
00:25:07,100 --> 00:25:09,710
actually works in the way we imagined it

577
00:25:09,710 --> 00:25:11,779
to work so we would expect that these

578
00:25:11,779 --> 00:25:13,909
are independent instructions so this one

579
00:25:13,909 --> 00:25:17,149
can already be executed and we check

580
00:25:17,149 --> 00:25:18,740
that and it works yeah

581
00:25:18,740 --> 00:25:20,240
is just out of our execution this will

582
00:25:20,240 --> 00:25:22,340
work on virtually all out-of-order

583
00:25:22,340 --> 00:25:28,340
processors yeah so this is so far not a

584
00:25:28,340 --> 00:25:29,990
problem but the exception was only

585
00:25:29,990 --> 00:25:32,809
thrown afterwards so the question is can

586
00:25:32,809 --> 00:25:38,120
we do actually something like this where

587
00:25:38,120 --> 00:25:42,080
we dereference the kernel address copy

588
00:25:42,080 --> 00:25:44,179
it into a local variable or a register

589
00:25:44,179 --> 00:25:46,580
in this case and then use this register

590
00:25:46,580 --> 00:25:48,230
value as an index for a second memory

591
00:25:48,230 --> 00:25:51,740
access and then check it whether any

592
00:25:51,740 --> 00:25:53,540
part of the area is cached and it turns

593
00:25:53,540 --> 00:25:57,320
out we can and yes the permission check

594
00:25:57,320 --> 00:25:58,910
is not fast enough and that was very

595
00:25:58,910 --> 00:26:01,580
scary when I ran this as first on my

596
00:26:01,580 --> 00:26:03,950
computer because it spat out a URL long

597
00:26:03,950 --> 00:26:05,929
URL and I never visited that website

598
00:26:05,929 --> 00:26:09,080
before I'm sure of that and it took me

599
00:26:09,080 --> 00:26:10,610
some time to figure out where the URL

600
00:26:10,610 --> 00:26:12,679
came from and it was from my ad blocker

601
00:26:12,679 --> 00:26:15,530
list and then I thought like okay if it

602
00:26:15,530 --> 00:26:17,720
can leak URLs from my ad blocker list it

603
00:26:17,720 --> 00:26:19,550
can leak anything else in memory just as

604
00:26:19,550 --> 00:26:22,070
well and if that's a bit scary but I

605
00:26:22,070 --> 00:26:24,290
mean by now we have the mitigations I

606
00:26:24,290 --> 00:26:27,050
guess so what this does this attack look

607
00:26:27,050 --> 00:26:30,890
like for instance here we if we know the

608
00:26:30,890 --> 00:26:33,140
physical address of this password buffer

609
00:26:33,140 --> 00:26:37,730
then we can write liveleak the the

610
00:26:37,730 --> 00:26:41,480
password but also for instance if you

611
00:26:41,480 --> 00:26:43,160
want to attack something like veracrypt

612
00:26:43,160 --> 00:26:46,370
which is like the follow-up of follow-up

613
00:26:46,370 --> 00:26:48,980
project of TrueCrypt we are trying to

614
00:26:48,980 --> 00:26:52,610
attack veracrypt now and the volume is

615
00:26:52,610 --> 00:26:54,260
mounted but we are in unprivileged

616
00:26:54,260 --> 00:26:56,000
attacker and we have a Python script

617
00:26:56,000 --> 00:26:58,490
which runs the marathon attack first to

618
00:26:58,490 --> 00:27:02,120
break case alarm then we use meltdown to

619
00:27:02,120 --> 00:27:05,059
search through the process drugs through

620
00:27:05,059 --> 00:27:07,520
the task structs to find all the

621
00:27:07,520 --> 00:27:09,920
properties of this process and then we

622
00:27:09,920 --> 00:27:14,330
will use that to infer the physical

623
00:27:14,330 --> 00:27:17,960
address of the key right we might know

624
00:27:17,960 --> 00:27:19,940
the virtual address but we're not the

625
00:27:19,940 --> 00:27:21,559
physical address then we read the key

626
00:27:21,559 --> 00:27:23,179
from this physical from this physical

627
00:27:23,179 --> 00:27:25,010
address then we decrypt using PI

628
00:27:25,010 --> 00:27:26,809
TrueCrypt and then you can see what is

629
00:27:26,809 --> 00:27:29,600
in there so my colleague moritz created

630
00:27:29,600 --> 00:27:32,600
this and you can see that

631
00:27:32,600 --> 00:27:42,230
yeah there's secret files hmm aiya its

632
00:27:42,230 --> 00:27:44,749
credit card PIN please don't look at now

633
00:27:44,749 --> 00:27:47,029
because it's a history credit card PIN

634
00:27:47,029 --> 00:27:52,009
right and the secret video okay okay

635
00:27:52,009 --> 00:27:54,619
okay oh no not this one again no we

636
00:27:54,619 --> 00:27:56,239
already had this so the countermeasure

637
00:27:56,239 --> 00:28:01,159
against marathon then is Kaiser and we

638
00:28:01,159 --> 00:28:04,070
saw an obvious connection between Kaiser

639
00:28:04,070 --> 00:28:06,919
and Linux Kaiser is a patch for Linux

640
00:28:06,919 --> 00:28:10,489
and it's basically it's an acronym for a

641
00:28:10,489 --> 00:28:12,049
current address isolation to have sites

642
00:28:12,049 --> 00:28:15,019
efficiently removed and we also thought

643
00:28:15,019 --> 00:28:18,919
it's like like Linux has something to do

644
00:28:18,919 --> 00:28:21,950
with penguins and Kaiser I mean in

645
00:28:21,950 --> 00:28:23,840
German it's the Kaiser penguin is the

646
00:28:23,840 --> 00:28:27,259
emperor penguin the largest penguin and

647
00:28:27,259 --> 00:28:28,399
we thought like this is a patch that

648
00:28:28,399 --> 00:28:32,499
will make Linux great again basically

649
00:28:32,499 --> 00:28:35,359
they didn't like it they changed it to

650
00:28:35,359 --> 00:28:37,850
something boring like kpti but the patch

651
00:28:37,850 --> 00:28:40,940
still until a very late stage was called

652
00:28:40,940 --> 00:28:44,690
Kaiser so only very very short time

653
00:28:44,690 --> 00:28:46,580
before it was merged it was actually

654
00:28:46,580 --> 00:28:48,919
renamed to kpti so there are still a lot

655
00:28:48,919 --> 00:28:51,169
of code lines that went under in the

656
00:28:51,169 --> 00:28:56,869
name Kaiser okay so what those guys are

657
00:28:56,869 --> 00:28:58,639
do without Kaiser we have something like

658
00:28:58,639 --> 00:29:01,340
a shared memory address space between

659
00:29:01,340 --> 00:29:03,230
user memory and kernel in memory and

660
00:29:03,230 --> 00:29:04,970
opponent context which we just switched

661
00:29:04,970 --> 00:29:07,519
to the upper half with Kaiser we

662
00:29:07,519 --> 00:29:09,080
separate this so now we have to address

663
00:29:09,080 --> 00:29:10,730
spaces a user address space and a kernel

664
00:29:10,730 --> 00:29:12,200
address space and we have to do one

665
00:29:12,200 --> 00:29:13,789
context switch here and then an

666
00:29:13,789 --> 00:29:15,529
additional context switch an address

667
00:29:15,529 --> 00:29:18,080
space switch to the kernel address space

668
00:29:18,080 --> 00:29:22,580
and this then mitigates Metin and I

669
00:29:22,580 --> 00:29:24,769
always as an operating system student in

670
00:29:24,769 --> 00:29:26,749
my undergraduate studies I always dreamt

671
00:29:26,749 --> 00:29:28,669
of having some feature that makes it

672
00:29:28,669 --> 00:29:31,789
into every operating system and I mean

673
00:29:31,789 --> 00:29:35,330
now I'm there now Linux has it Windows

674
00:29:35,330 --> 00:29:38,330
has it and always access it so it's in

675
00:29:38,330 --> 00:29:40,119
every computer and people love it right

676
00:29:40,119 --> 00:29:43,009
or maybe not that much because of the

677
00:29:43,009 --> 00:29:45,440
performance cost but still I mean I got

678
00:29:45,440 --> 00:29:46,160
I achieved

679
00:29:46,160 --> 00:29:47,960
goal is now in every operating system

680
00:29:47,960 --> 00:29:49,880
that was the goal not that everyone

681
00:29:49,880 --> 00:29:52,640
loves it okay

682
00:29:52,640 --> 00:29:55,700
so this was all about meltdown but we

683
00:29:55,700 --> 00:29:58,880
maybe want to talk about spectra as well

684
00:29:58,880 --> 00:30:01,340
and meltdown is about me doing something

685
00:30:01,340 --> 00:30:03,770
which I shouldn't do spectra is about

686
00:30:03,770 --> 00:30:06,140
someone else doing something that I that

687
00:30:06,140 --> 00:30:08,780
they shouldn't do and I I think we

688
00:30:08,780 --> 00:30:10,730
should go back to cooking and if I don't

689
00:30:10,730 --> 00:30:13,040
cook myself I can let someone else cook

690
00:30:13,040 --> 00:30:14,780
and there's this very nice pizza place

691
00:30:14,780 --> 00:30:18,920
close to our University in Graz and we

692
00:30:18,920 --> 00:30:20,570
go there often for lunch and usually

693
00:30:20,570 --> 00:30:22,220
what happens is one person or as the

694
00:30:22,220 --> 00:30:24,590
prosciutto pizza funghi and then Diablo

695
00:30:24,590 --> 00:30:26,900
Diablo Diablo we don't know why but the

696
00:30:26,900 --> 00:30:28,730
Diablo pizza seems to be very good there

697
00:30:28,730 --> 00:30:32,500
or we are we are a bunch of people maybe

698
00:30:32,500 --> 00:30:35,780
anyway if we call there by telephone and

699
00:30:35,780 --> 00:30:37,160
say we would like to have a table for

700
00:30:37,160 --> 00:30:39,590
six please for lunch today and they are

701
00:30:39,590 --> 00:30:45,290
like oh yeah if those guys again no clue

702
00:30:45,290 --> 00:30:46,790
what they will eat but I bet at least

703
00:30:46,790 --> 00:30:47,840
three Diablos

704
00:30:47,840 --> 00:30:50,330
and we observed that the Diablos always

705
00:30:50,330 --> 00:30:53,330
arrived first and that's suspicious

706
00:30:53,330 --> 00:30:55,520
right so I think what they are doing is

707
00:30:55,520 --> 00:30:59,030
speculative cooking so you can exploit

708
00:30:59,030 --> 00:31:01,430
that if you wouldn't know what we

709
00:31:01,430 --> 00:31:04,250
actually usually order if that would be

710
00:31:04,250 --> 00:31:06,530
a secret you could of course call there

711
00:31:06,530 --> 00:31:08,960
and say or your steel rods I would like

712
00:31:08,960 --> 00:31:10,880
to have a table for six please and he

713
00:31:10,880 --> 00:31:12,290
wouldn't recognize that this is a

714
00:31:12,290 --> 00:31:14,390
different voice right and then they

715
00:31:14,390 --> 00:31:16,400
would prepare the pizza and it's already

716
00:31:16,400 --> 00:31:18,350
there and then you show up and there I

717
00:31:18,350 --> 00:31:21,290
think the pizza cookie said it's a

718
00:31:21,290 --> 00:31:24,080
privacy conscious one right so the pizza

719
00:31:24,080 --> 00:31:26,450
cook would be like oh no this is not the

720
00:31:26,450 --> 00:31:27,890
right person I don't give you the pizza

721
00:31:27,890 --> 00:31:30,380
but this still lingers in the air and

722
00:31:30,380 --> 00:31:32,180
you can smell it and this is basically

723
00:31:32,180 --> 00:31:34,460
what Spectre does so you have some

724
00:31:34,460 --> 00:31:36,590
interface you control this index here

725
00:31:36,590 --> 00:31:38,810
and you have some data and it's

726
00:31:38,810 --> 00:31:40,310
protected with a bounced check so

727
00:31:40,310 --> 00:31:42,110
best-practice protect things with

728
00:31:42,110 --> 00:31:44,870
bounced checks and then you pass valid

729
00:31:44,870 --> 00:31:46,790
indices and you go into this code which

730
00:31:46,790 --> 00:31:50,030
will leak information and the processor

731
00:31:50,030 --> 00:31:53,570
will learn that it should always predict

732
00:31:53,570 --> 00:31:56,360
this direction here and as we pass an

733
00:31:56,360 --> 00:31:59,870
invalid index later on the processor

734
00:31:59,870 --> 00:32:01,909
already learned that we are in nice

735
00:32:01,909 --> 00:32:04,010
person always passing relative misses

736
00:32:04,010 --> 00:32:06,620
and speculate this way and leaks the key

737
00:32:06,620 --> 00:32:09,740
with that and lets of course unfortunate

738
00:32:09,740 --> 00:32:12,380
but that's how Spectre works it's a very

739
00:32:12,380 --> 00:32:15,049
simple attack and we actually don't know

740
00:32:15,049 --> 00:32:17,360
how to fully solve this problem because

741
00:32:17,360 --> 00:32:19,669
we want the processor to learn in this

742
00:32:19,669 --> 00:32:21,080
case this gives us a performance

743
00:32:21,080 --> 00:32:25,480
advantage but it's difficult to to only

744
00:32:25,480 --> 00:32:28,580
predict correct right you would have to

745
00:32:28,580 --> 00:32:31,850
tell the future for that ok there's also

746
00:32:31,850 --> 00:32:34,580
Spectre v2 which is a bit different that

747
00:32:34,580 --> 00:32:36,020
there are lots of different Spectre

748
00:32:36,020 --> 00:32:37,580
variants and got just explaining those

749
00:32:37,580 --> 00:32:39,890
two as examples and here I think of an

750
00:32:39,890 --> 00:32:41,899
example where I have an indirect call

751
00:32:41,899 --> 00:32:44,750
here to a method and for the bird it's a

752
00:32:44,750 --> 00:32:47,059
different method than for the fish for

753
00:32:47,059 --> 00:32:48,590
the fish it's swim for the birds it's

754
00:32:48,590 --> 00:32:51,470
fly and one of these methods leaks

755
00:32:51,470 --> 00:32:53,720
information from a member variable and

756
00:32:53,720 --> 00:32:56,809
the processor again will learn based on

757
00:32:56,809 --> 00:32:59,120
what object we passed through this

758
00:32:59,120 --> 00:33:01,250
interface what it should predict and

759
00:33:01,250 --> 00:33:03,559
then as we pass the fish the processor

760
00:33:03,559 --> 00:33:05,240
which they predict oh the fish should

761
00:33:05,240 --> 00:33:09,080
fly so it will leak the data here and

762
00:33:09,080 --> 00:33:13,039
yeah that's two attacks but by now we

763
00:33:13,039 --> 00:33:15,409
know that there are lot more attacks so

764
00:33:15,409 --> 00:33:18,440
we know that there are like this many

765
00:33:18,440 --> 00:33:20,659
attacks and all the different Spectre

766
00:33:20,659 --> 00:33:23,659
variants different marathon variants by

767
00:33:23,659 --> 00:33:25,580
now there are a few more because there's

768
00:33:25,580 --> 00:33:28,010
zombie load not even on there yet

769
00:33:28,010 --> 00:33:29,960
and then a question of course is like

770
00:33:29,960 --> 00:33:32,779
how do we mitigate this all right and

771
00:33:32,779 --> 00:33:35,149
one of the first mitigation proposals

772
00:33:35,149 --> 00:33:39,950
that I heard in January 2018 from a

773
00:33:39,950 --> 00:33:45,679
journalist was blockchain can we use the

774
00:33:45,679 --> 00:33:47,299
blockchain to mitigate Madonna inspector

775
00:33:47,299 --> 00:33:50,929
no but also if you've seen this this was

776
00:33:50,929 --> 00:33:53,630
earlier this year thing in January there

777
00:33:53,630 --> 00:33:56,000
was by the ACM SiC arch community so

778
00:33:56,000 --> 00:33:57,620
it's not the security community but the

779
00:33:57,620 --> 00:33:59,899
architecture community and it shows how

780
00:33:59,899 --> 00:34:03,409
far apart these communities are and the

781
00:34:03,409 --> 00:34:05,029
article that they published on their

782
00:34:05,029 --> 00:34:06,860
website was let's keep it to ourselves

783
00:34:06,860 --> 00:34:11,270
don't disclose vulnerabilities this is

784
00:34:11,270 --> 00:34:13,560
something that the community community

785
00:34:13,560 --> 00:34:16,500
already abandoned maybe 200 300 years

786
00:34:16,500 --> 00:34:22,080
ago mostly yeah so probably not a good

787
00:34:22,080 --> 00:34:25,620
idea anyway the real mitigations this is

788
00:34:25,620 --> 00:34:27,630
also a very frustrating picture because

789
00:34:27,630 --> 00:34:29,820
you can see all the empty squares and

790
00:34:29,820 --> 00:34:32,489
empty diamonds empty circles these are

791
00:34:32,489 --> 00:34:35,190
all not complete mitigations and to have

792
00:34:35,190 --> 00:34:38,280
complete mitigation you have to combine

793
00:34:38,280 --> 00:34:41,030
several of these countermeasures and

794
00:34:41,030 --> 00:34:43,590
that's of course a problem because all

795
00:34:43,590 --> 00:34:45,239
of these countermeasures cost

796
00:34:45,239 --> 00:34:46,830
performance so for instance just to

797
00:34:46,830 --> 00:34:48,750
mitigate specter v2 they would recommend

798
00:34:48,750 --> 00:34:51,179
this these three but then again this one

799
00:34:51,179 --> 00:34:55,469
also maybe in some cases so it costs a

800
00:34:55,469 --> 00:34:57,150
lot of performance if you all add that

801
00:34:57,150 --> 00:35:00,150
together but I mean who cares about

802
00:35:00,150 --> 00:35:05,220
performance the question then also is

803
00:35:05,220 --> 00:35:06,690
like how to find the next big thing

804
00:35:06,690 --> 00:35:08,310
people often ask me how to find the next

805
00:35:08,310 --> 00:35:10,410
big thing and I feel a bit like the

806
00:35:10,410 --> 00:35:12,270
things that we are doing feel more

807
00:35:12,270 --> 00:35:13,830
connected to something like a natural

808
00:35:13,830 --> 00:35:16,470
science we are exploring the field it

809
00:35:16,470 --> 00:35:18,750
would be like asking Newton like how do

810
00:35:18,750 --> 00:35:21,630
you find the next natural law and I'm

811
00:35:21,630 --> 00:35:25,560
like you look for effects and try to

812
00:35:25,560 --> 00:35:27,840
understand the effects that you see but

813
00:35:27,840 --> 00:35:29,670
this is a very high-level description of

814
00:35:29,670 --> 00:35:31,770
what we do so let me give you an

815
00:35:31,770 --> 00:35:33,690
impression of how we actually find the

816
00:35:33,690 --> 00:35:35,670
next big thing and of course the first

817
00:35:35,670 --> 00:35:37,860
thing that you need for for a

818
00:35:37,860 --> 00:35:40,080
vulnerability is the name so for

819
00:35:40,080 --> 00:35:41,430
instance if I would write a paper about

820
00:35:41,430 --> 00:35:43,740
an attack on iPhones or Apple products

821
00:35:43,740 --> 00:35:46,560
maybe I would call it izombie and then

822
00:35:46,560 --> 00:35:48,810
some some line afterwards that would be

823
00:35:48,810 --> 00:35:51,240
great a tech name right or if you have

824
00:35:51,240 --> 00:35:53,730
an attack where you have remote control

825
00:35:53,730 --> 00:35:55,890
over a robot and in theory could kill

826
00:35:55,890 --> 00:35:58,350
someone call it love death and robots

827
00:35:58,350 --> 00:36:01,620
great great paper title and then we saw

828
00:36:01,620 --> 00:36:03,690
this one zombie lent other tab like a

829
00:36:03,690 --> 00:36:05,520
zombie land sounds really cool and if

830
00:36:05,520 --> 00:36:07,080
you look at the logo we would also like

831
00:36:07,080 --> 00:36:10,290
to post like this on a poster and then

832
00:36:10,290 --> 00:36:12,930
we saw DL and doesn't really I mean

833
00:36:12,930 --> 00:36:14,610
there's kernel land and user land but

834
00:36:14,610 --> 00:36:17,580
also if you just switch to letters here

835
00:36:17,580 --> 00:36:19,890
you get to zombie load it's hack so then

836
00:36:19,890 --> 00:36:21,450
we thought this is the really cool thing

837
00:36:21,450 --> 00:36:21,780
right

838
00:36:21,780 --> 00:36:23,970
zombie load then we thought okay so what

839
00:36:23,970 --> 00:36:27,420
what zombie load actually be and

840
00:36:27,420 --> 00:36:29,309
we figured that uh yeah in the melt on

841
00:36:29,309 --> 00:36:31,530
paper we wrote that the CPU already

842
00:36:31,530 --> 00:36:33,510
issued the subsequent instructions are

843
00:36:33,510 --> 00:36:36,030
and then the question is what happens

844
00:36:36,030 --> 00:36:39,440
with loads that are already already

845
00:36:39,440 --> 00:36:42,869
issued so I entered into Google fault

846
00:36:42,869 --> 00:36:45,750
occurs load operation completed and then

847
00:36:45,750 --> 00:36:47,670
I was looking for patterns by Intel and

848
00:36:47,670 --> 00:36:50,549
then you see the second result here if a

849
00:36:50,549 --> 00:36:52,319
fault occurs with respect to the load

850
00:36:52,319 --> 00:36:54,559
operation it is marked as valid and

851
00:36:54,559 --> 00:36:57,540
completed so in the case where you know

852
00:36:57,540 --> 00:37:00,750
oh this is not doing anything useful the

853
00:37:00,750 --> 00:37:02,730
decision you make is oh yeah it's valid

854
00:37:02,730 --> 00:37:05,910
and completed and the rationale behind

855
00:37:05,910 --> 00:37:07,859
that is it will be thrown away

856
00:37:07,859 --> 00:37:10,770
anyway later on and after everyone was

857
00:37:10,770 --> 00:37:12,089
already working with it but

858
00:37:12,089 --> 00:37:14,670
architectural II you won't see it so if

859
00:37:14,670 --> 00:37:16,680
you run under the assumption that you

860
00:37:16,680 --> 00:37:18,299
can't see these micro architectural

861
00:37:18,299 --> 00:37:21,180
effect then this makes them and then

862
00:37:21,180 --> 00:37:24,480
this zombie load brought us to a deeper

863
00:37:24,480 --> 00:37:26,309
understanding of the underlying issue so

864
00:37:26,309 --> 00:37:27,960
actually looking at something like

865
00:37:27,960 --> 00:37:30,059
meltdown and foreshadowing zombie load

866
00:37:30,059 --> 00:37:32,609
is very similar attacks so you always

867
00:37:32,609 --> 00:37:34,619
have one memory access the memory access

868
00:37:34,619 --> 00:37:36,420
is not valid they take accesses an

869
00:37:36,420 --> 00:37:39,240
address which you cannot access and then

870
00:37:39,240 --> 00:37:41,299
you go to the load data execution port

871
00:37:41,299 --> 00:37:44,910
and then you go to the load buffer load

872
00:37:44,910 --> 00:37:46,680
buffer entries actually allocate at the

873
00:37:46,680 --> 00:37:48,630
same time as the reorder buffer and then

874
00:37:48,630 --> 00:37:50,250
we thought about what would a load

875
00:37:50,250 --> 00:37:51,839
buffer entry look like we don't know

876
00:37:51,839 --> 00:37:53,549
what it looks like but we imagine that

877
00:37:53,549 --> 00:37:54,990
it has to store at least something like

878
00:37:54,990 --> 00:37:56,819
the register number where it's stored

879
00:37:56,819 --> 00:38:00,540
the data should be stored the offset in

880
00:38:00,540 --> 00:38:02,309
the in the page the virtual page number

881
00:38:02,309 --> 00:38:03,780
the physical page number is something

882
00:38:03,780 --> 00:38:06,089
like this maybe other information but

883
00:38:06,089 --> 00:38:09,240
equivalent information that allows you

884
00:38:09,240 --> 00:38:10,890
to do the same things and then you would

885
00:38:10,890 --> 00:38:13,140
update these with the address that you

886
00:38:13,140 --> 00:38:15,150
have so the virtual address and also the

887
00:38:15,150 --> 00:38:17,880
target register and then you go check in

888
00:38:17,880 --> 00:38:20,880
the store buffer l1 TLB and in the lfb

889
00:38:20,880 --> 00:38:23,250
whether you get the data from somewhere

890
00:38:23,250 --> 00:38:26,400
and the TLB says oh yeah it's the

891
00:38:26,400 --> 00:38:28,049
present but it's not user space

892
00:38:28,049 --> 00:38:32,010
accessible so stop everything market as

893
00:38:32,010 --> 00:38:34,530
valid and completed and the data can go

894
00:38:34,530 --> 00:38:37,500
to the register and already be used in

895
00:38:37,500 --> 00:38:39,510
subsequent instructions and the same

896
00:38:39,510 --> 00:38:41,339
happens for for shadow VM

897
00:38:41,339 --> 00:38:42,930
so in this case we also go through the

898
00:38:42,930 --> 00:38:45,450
same pass but this time we can't check

899
00:38:45,450 --> 00:38:47,700
the TLB because there is no TLB entry

900
00:38:47,700 --> 00:38:49,680
because for share of EMM works with

901
00:38:49,680 --> 00:38:51,539
present faults so we have to do a page

902
00:38:51,539 --> 00:38:53,339
walk instead we first do the page walk

903
00:38:53,339 --> 00:38:54,539
for the guest for the virtual machine

904
00:38:54,539 --> 00:38:56,849
and there the present bit is already not

905
00:38:56,849 --> 00:38:59,519
set now the problem is you have to store

906
00:38:59,519 --> 00:39:01,619
this physical page number from the guest

907
00:39:01,619 --> 00:39:04,829
somewhere if you would continue and we

908
00:39:04,829 --> 00:39:07,410
assume that the guest physical page

909
00:39:07,410 --> 00:39:11,150
number is stored just here and already

910
00:39:11,150 --> 00:39:14,039
passed on for the comparison with the

911
00:39:14,039 --> 00:39:16,950
store buffer l1 data cache and lfp and

912
00:39:16,950 --> 00:39:19,229
if it matches well the data can go to

913
00:39:19,229 --> 00:39:21,599
the register this is of course a bit

914
00:39:21,599 --> 00:39:24,739
unfortunate yeah but that's how it is

915
00:39:24,739 --> 00:39:29,219
zombie load there we have again a memory

916
00:39:29,219 --> 00:39:31,469
access and you see the the attacker code

917
00:39:31,469 --> 00:39:33,719
looks very similar right it was even the

918
00:39:33,719 --> 00:39:35,700
same instruction in all three cases but

919
00:39:35,700 --> 00:39:37,559
the microarchitecture stayed is a bit

920
00:39:37,559 --> 00:39:39,690
different so in this case we will have

921
00:39:39,690 --> 00:39:42,150
already a problem around here we don't

922
00:39:42,150 --> 00:39:44,400
know exactly where the problem exists

923
00:39:44,400 --> 00:39:47,519
but it's a difficult situation the load

924
00:39:47,519 --> 00:39:50,219
needs to be reissued and therefore we

925
00:39:50,219 --> 00:39:52,349
stopped and then right away the

926
00:39:52,349 --> 00:39:53,999
processor already knows ok I don't even

927
00:39:53,999 --> 00:39:55,710
have to update these fields anymore just

928
00:39:55,710 --> 00:39:57,930
market valid and completed and the

929
00:39:57,930 --> 00:39:59,940
because this is all in a critical path

930
00:39:59,940 --> 00:40:02,609
some buffers will still be looked up and

931
00:40:02,609 --> 00:40:07,049
the data can go to the register so how

932
00:40:07,049 --> 00:40:09,960
did we actually find it actually we we

933
00:40:09,960 --> 00:40:12,779
looked at our met on PLC it always

934
00:40:12,779 --> 00:40:15,479
worked on non l1 memory fast so you if

935
00:40:15,479 --> 00:40:18,390
you look at the met on paper also the

936
00:40:18,390 --> 00:40:20,190
co-authors confirmed these experiments

937
00:40:20,190 --> 00:40:23,339
it works on non l1 memory and this was

938
00:40:23,339 --> 00:40:27,210
in December 2017 and we reported this to

939
00:40:27,210 --> 00:40:29,900
Intel and I said well we can't reproduce

940
00:40:29,900 --> 00:40:32,400
then we also had a pork where we

941
00:40:32,400 --> 00:40:34,109
explicitly mark the memory as

942
00:40:34,109 --> 00:40:36,630
uncatchable and we send this talk to

943
00:40:36,630 --> 00:40:39,749
Intel in March 2018 and then we also

944
00:40:39,749 --> 00:40:41,729
send an update that it's the lfb I think

945
00:40:41,729 --> 00:40:45,509
it was in May 2000 18 yeah I think it

946
00:40:45,509 --> 00:40:49,799
was in May 2000 18 then the question is

947
00:40:49,799 --> 00:40:51,719
also what about noise right there is

948
00:40:51,719 --> 00:40:54,630
noise may tone has noise and if you have

949
00:40:54,630 --> 00:40:55,340
uncashed

950
00:40:55,340 --> 00:40:56,330
you actually have a lower

951
00:40:56,330 --> 00:40:59,120
signal-to-noise ratio so this is already

952
00:40:59,120 --> 00:41:02,300
suspicious so that that means something

953
00:41:02,300 --> 00:41:05,450
and the question is noise we thought a

954
00:41:05,450 --> 00:41:08,270
lot about noise on a completely

955
00:41:08,270 --> 00:41:11,720
deterministic system I mean we built

956
00:41:11,720 --> 00:41:14,750
this machine and this is our new mantra

957
00:41:14,750 --> 00:41:16,880
in our group there is no noise noise is

958
00:41:16,880 --> 00:41:20,930
just someone else's data and if you try

959
00:41:20,930 --> 00:41:25,190
to do that now maybe yeah

960
00:41:25,190 --> 00:41:28,820
this idea that also was pursued in the

961
00:41:28,820 --> 00:41:30,350
riddle paper we didn't pursue this in

962
00:41:30,350 --> 00:41:32,210
our paper but we later on published this

963
00:41:32,210 --> 00:41:34,820
demo where we leaked the route hash with

964
00:41:34,820 --> 00:41:37,820
something like 2 bytes per second or

965
00:41:37,820 --> 00:41:41,330
something or one byte per second which

966
00:41:41,330 --> 00:41:42,740
is quite nice and then we have the root

967
00:41:42,740 --> 00:41:46,880
hash after a few minutes but also we

968
00:41:46,880 --> 00:41:49,220
tried to life leak audio that is played

969
00:41:49,220 --> 00:41:53,439
on the system and this is one demo here

970
00:41:57,589 --> 00:42:00,270
okay this is the original right this was

971
00:42:00,270 --> 00:42:02,730
not leaking yet but now we will run a

972
00:42:02,730 --> 00:42:05,270
player which plays this file in

973
00:42:05,270 --> 00:42:08,309
simultaneously leak it with zombie load

974
00:42:08,309 --> 00:42:10,170
attack which directly plays the sound on

975
00:42:10,170 --> 00:42:14,329
the on the sound card

976
00:42:21,930 --> 00:42:24,870
okay so this sounds funny but at the

977
00:42:24,870 --> 00:42:26,520
same time think about this not being

978
00:42:26,520 --> 00:42:29,100
just music but your Skype call where

979
00:42:29,100 --> 00:42:30,690
someone can infer what you're currently

980
00:42:30,690 --> 00:42:33,750
talking on the cause then also the

981
00:42:33,750 --> 00:42:34,200
question

982
00:42:34,200 --> 00:42:37,700
zombie processes I've seen this in

983
00:42:37,700 --> 00:42:41,220
stefanos talk but also there were lately

984
00:42:41,220 --> 00:42:44,580
others that criticized that oh this is

985
00:42:44,580 --> 00:42:47,460
fear-mongering basically zombie load but

986
00:42:47,460 --> 00:42:49,500
think about it we were talking about

987
00:42:49,500 --> 00:42:51,510
zombies threat zombie processes and

988
00:42:51,510 --> 00:42:53,190
zombie objects for a long time and

989
00:42:53,190 --> 00:42:55,260
they're also the problem is that the

990
00:42:55,260 --> 00:42:58,530
lifetime is not very well constrained

991
00:42:58,530 --> 00:43:00,210
and that's also the problem in zombie

992
00:43:00,210 --> 00:43:02,610
load that we don't kill the load early

993
00:43:02,610 --> 00:43:03,930
enough we have to kill it

994
00:43:03,930 --> 00:43:06,090
earlier stall the pipeline earlier and

995
00:43:06,090 --> 00:43:07,800
that's exactly the same mechanism

996
00:43:07,800 --> 00:43:10,140
therefore the name zombie load is just

997
00:43:10,140 --> 00:43:11,640
the technical reference to what is

998
00:43:11,640 --> 00:43:14,670
happening also why are we doing a tech

999
00:43:14,670 --> 00:43:18,750
research so when I was doing my PhD many

1000
00:43:18,750 --> 00:43:20,160
people told me oh you should work on

1001
00:43:20,160 --> 00:43:22,410
defenses and like try to swim to the

1002
00:43:22,410 --> 00:43:25,680
surface because we need to be better but

1003
00:43:25,680 --> 00:43:27,600
then again we overlooked met on

1004
00:43:27,600 --> 00:43:29,460
inspector for something like 20 years

1005
00:43:29,460 --> 00:43:32,910
right and we we don't even know whether

1006
00:43:32,910 --> 00:43:34,890
met on inspector are the thing that is

1007
00:43:34,890 --> 00:43:36,840
relevant maybe we overlooked a much

1008
00:43:36,840 --> 00:43:39,390
bigger threat right so maybe we should

1009
00:43:39,390 --> 00:43:41,390
think about what we are actually doing

1010
00:43:41,390 --> 00:43:47,280
okay so the question is what do we learn

1011
00:43:47,280 --> 00:43:51,810
from it and I would say we have a new

1012
00:43:51,810 --> 00:43:53,370
class of software based attacks we

1013
00:43:53,370 --> 00:43:55,530
didn't have this class before and there

1014
00:43:55,530 --> 00:43:57,180
are many problems to solve around these

1015
00:43:57,180 --> 00:43:58,710
micro architectural attacks and

1016
00:43:58,710 --> 00:44:00,300
especially transient execution attacks

1017
00:44:00,300 --> 00:44:03,570
it's like we are discovering the the

1018
00:44:03,570 --> 00:44:06,360
area of software bugs and now it's

1019
00:44:06,360 --> 00:44:08,580
hardware bugs and we should dedicate

1020
00:44:08,580 --> 00:44:11,520
more time into identifying problems and

1021
00:44:11,520 --> 00:44:13,320
not solely into mitigating known

1022
00:44:13,320 --> 00:44:15,360
problems and with that I would like to

1023
00:44:15,360 --> 00:44:17,460
close and thank you for your attention

1024
00:44:17,460 --> 00:44:34,730
[Applause]

1025
00:44:34,730 --> 00:44:37,580
so thank you Daniel

1026
00:44:37,580 --> 00:44:41,030
so I know we are very short in time but

1027
00:44:41,030 --> 00:44:44,160
do you have any question anyone with

1028
00:44:44,160 --> 00:44:46,200
questions so there is a microphone here

1029
00:44:46,200 --> 00:44:50,640
and another over there come on don't be

1030
00:44:50,640 --> 00:44:50,940
shy

1031
00:44:50,940 --> 00:44:55,650
oh yeah good I know this is a quite

1032
00:44:55,650 --> 00:45:02,010
complicated topic thank you for the nice

1033
00:45:02,010 --> 00:45:05,430
talk and my question is more on the

1034
00:45:05,430 --> 00:45:11,940
vision of the whole thing and from your

1035
00:45:11,940 --> 00:45:15,300
toes it merges that in some way there is

1036
00:45:15,300 --> 00:45:17,180
some tension between performance and

1037
00:45:17,180 --> 00:45:20,310
security yes I would argue that most of

1038
00:45:20,310 --> 00:45:21,590
the times there is a tension between

1039
00:45:21,590 --> 00:45:26,250
perform a point in which we can have

1040
00:45:26,250 --> 00:45:33,830
both or I mean we can be secure being

1041
00:45:33,830 --> 00:45:37,740
performant or you say if you want to be

1042
00:45:37,740 --> 00:45:41,970
secure you must be not so the problem is

1043
00:45:41,970 --> 00:45:43,590
that security is very difficult to

1044
00:45:43,590 --> 00:45:45,240
measure so the question is always what

1045
00:45:45,240 --> 00:45:48,030
you mean with secure and I think usually

1046
00:45:48,030 --> 00:45:50,610
it makes sense to define security by how

1047
00:45:50,610 --> 00:45:53,010
much does an attacker have to invest to

1048
00:45:53,010 --> 00:45:56,130
break your security assumptions and I

1049
00:45:56,130 --> 00:45:59,190
would say that we can definitely do

1050
00:45:59,190 --> 00:46:02,670
better than we currently do so while

1051
00:46:02,670 --> 00:46:05,700
keeping our performance up improve the

1052
00:46:05,700 --> 00:46:08,130
security we could do that for instance

1053
00:46:08,130 --> 00:46:10,320
we are looking into this area and also a

1054
00:46:10,320 --> 00:46:12,030
lot of other universities are right now

1055
00:46:12,030 --> 00:46:14,370
looking into this area of secure caches

1056
00:46:14,370 --> 00:46:17,370
which would prevent things like prime

1057
00:46:17,370 --> 00:46:19,170
and probe like the Amazon Prime and

1058
00:46:19,170 --> 00:46:21,150
probe attack it wouldn't work anymore or

1059
00:46:21,150 --> 00:46:22,890
not in the same way not with the same

1060
00:46:22,890 --> 00:46:23,490
performance

1061
00:46:23,490 --> 00:46:26,160
maybe we bring it down to a byte per

1062
00:46:26,160 --> 00:46:28,440
second and then of course leaking data

1063
00:46:28,440 --> 00:46:30,810
is much more difficult and the

1064
00:46:30,810 --> 00:46:32,820
investment that the attacker has to make

1065
00:46:32,820 --> 00:46:38,940
maybe does not does not justify mounting

1066
00:46:38,940 --> 00:46:42,120
this attack anymore so you are looking

1067
00:46:42,120 --> 00:46:43,220
for a security

1068
00:46:43,220 --> 00:46:45,809
solution and not forever yes yes because

1069
00:46:45,809 --> 00:46:49,579
I'm formed from parameters we search for

1070
00:46:49,579 --> 00:46:53,670
completely secure correct yeah but I

1071
00:46:53,670 --> 00:46:57,119
mean you're looking for almost yeah so

1072
00:46:57,119 --> 00:46:58,589
the the problem is that many of these

1073
00:46:58,589 --> 00:47:01,410
optimizations the goal of the

1074
00:47:01,410 --> 00:47:03,690
optimization is to make things faster

1075
00:47:03,690 --> 00:47:07,980
but not always right the problem is if

1076
00:47:07,980 --> 00:47:09,569
you could make it always faster you have

1077
00:47:09,569 --> 00:47:12,660
a better algorithm but or you can

1078
00:47:12,660 --> 00:47:15,630
increase the clock frequency maybe but

1079
00:47:15,630 --> 00:47:18,150
things like caches try to make it faster

1080
00:47:18,150 --> 00:47:19,799
for cases that you can't you know

1081
00:47:19,799 --> 00:47:21,839
generally optimize you can't make an

1082
00:47:21,839 --> 00:47:24,630
arbitrarily large cache so you always

1083
00:47:24,630 --> 00:47:26,460
have this sanction in there that things

1084
00:47:26,460 --> 00:47:28,290
can be in the cache or not in the cache

1085
00:47:28,290 --> 00:47:31,589
as long as you share a cache and if you

1086
00:47:31,589 --> 00:47:32,910
don't want to have this side channel

1087
00:47:32,910 --> 00:47:35,520
then you have to go to separate devices

1088
00:47:35,520 --> 00:47:44,390
or separate caches young anyone else

1089
00:47:50,450 --> 00:47:57,450
okay and wondering I was wondering I

1090
00:47:57,450 --> 00:48:00,359
mean particularly nest because we don't

1091
00:48:00,359 --> 00:48:02,220
have visibility inside the processor

1092
00:48:02,220 --> 00:48:06,030
structure but I mean why don't the

1093
00:48:06,030 --> 00:48:08,430
vendor like Intel has done their own

1094
00:48:08,430 --> 00:48:11,400
analysis and found these years ago and

1095
00:48:11,400 --> 00:48:14,010
patch it already why do we have to

1096
00:48:14,010 --> 00:48:16,760
discover it in a blackbox scenario yes

1097
00:48:16,760 --> 00:48:21,450
thanks for the question so the problem

1098
00:48:21,450 --> 00:48:24,119
that we are looking at is that the

1099
00:48:24,119 --> 00:48:26,210
complexity of our systems has outgrown

1100
00:48:26,210 --> 00:48:28,799
the capacity of the human mind I would

1101
00:48:28,799 --> 00:48:31,650
argue we have lots of engineers who work

1102
00:48:31,650 --> 00:48:34,530
with let's say linear progress on

1103
00:48:34,530 --> 00:48:36,839
increasing the complexity but if you put

1104
00:48:36,839 --> 00:48:38,640
the features of multiple engineers

1105
00:48:38,640 --> 00:48:41,280
together it draws more than just

1106
00:48:41,280 --> 00:48:44,130
linearly and this is the problem we

1107
00:48:44,130 --> 00:48:46,200
can't we can't keep up with the

1108
00:48:46,200 --> 00:48:49,200
complexity grows in our systems and if

1109
00:48:49,200 --> 00:48:51,900
the system is too complex for our minds

1110
00:48:51,900 --> 00:48:55,349
it starts becoming something like nature

1111
00:48:55,349 --> 00:48:57,119
this goes this idea ago

1112
00:48:57,119 --> 00:48:59,130
back to a book from herbert simon from

1113
00:48:59,130 --> 00:49:03,539
the 70's and he argued that we have to

1114
00:49:03,539 --> 00:49:06,690
study these complex systems like nature

1115
00:49:06,690 --> 00:49:09,930
it's like the study or the science of

1116
00:49:09,930 --> 00:49:12,359
the artificial and we apply the same

1117
00:49:12,359 --> 00:49:16,019
methods as a natural sciences so looking

1118
00:49:16,019 --> 00:49:17,670
at the source code wouldn't have

1119
00:49:17,670 --> 00:49:20,029
revealed these these vulnerabilities

1120
00:49:20,029 --> 00:49:24,150
because we would have had to look at too

1121
00:49:24,150 --> 00:49:25,769
many things in different places at the

1122
00:49:25,769 --> 00:49:28,410
same time and that's just beyond the

1123
00:49:28,410 --> 00:49:30,809
capacity of a mind to understand the

1124
00:49:30,809 --> 00:49:36,779
full process or in all its details maybe

1125
00:49:36,779 --> 00:49:38,869
there are some very clever people who

1126
00:49:38,869 --> 00:49:42,690
can do that but at the same time you

1127
00:49:42,690 --> 00:49:44,730
also to find these attacks and that's

1128
00:49:44,730 --> 00:49:46,259
the problem that I that I mentioned

1129
00:49:46,259 --> 00:49:48,289
earlier with the architecture community

1130
00:49:48,289 --> 00:49:50,640
the problem is that you also need the

1131
00:49:50,640 --> 00:49:52,680
right mindset to look at the problem so

1132
00:49:52,680 --> 00:49:54,569
very often when I was speaking with

1133
00:49:54,569 --> 00:49:56,670
people who are not from the security

1134
00:49:56,670 --> 00:49:57,210
field

1135
00:49:57,210 --> 00:50:00,059
I got responses like yeah ok yeah now I

1136
00:50:00,059 --> 00:50:01,650
understand why you can do these attacks

1137
00:50:01,650 --> 00:50:06,239
but why would anyone do that and if

1138
00:50:06,239 --> 00:50:07,769
that's the mindset with which you

1139
00:50:07,769 --> 00:50:11,249
develop these systems then of course you

1140
00:50:11,249 --> 00:50:15,089
you won't find all the attacks that are

1141
00:50:15,089 --> 00:50:19,200
possible thank you let's Thanks speaker

1142
00:50:19,200 --> 00:50:20,310
again

1143
00:50:20,310 --> 00:50:26,880
[Applause]

