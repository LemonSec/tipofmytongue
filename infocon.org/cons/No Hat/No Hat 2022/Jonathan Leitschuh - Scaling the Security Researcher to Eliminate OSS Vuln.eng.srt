1
00:00:00,850 --> 00:00:07,310
[Music]

2
00:00:11,000 --> 00:00:13,099
thank you

3
00:00:13,099 --> 00:00:16,379
and thank you all for coming uh it's uh

4
00:00:16,379 --> 00:00:18,119
late in the day and you're probably all

5
00:00:18,119 --> 00:00:19,440
exhausted from sitting in front of

6
00:00:19,440 --> 00:00:21,240
people's talking so uh thank you for

7
00:00:21,240 --> 00:00:23,039
coming and uh yeah I appreciate it so

8
00:00:23,039 --> 00:00:25,439
this talk is titled scaling the security

9
00:00:25,439 --> 00:00:27,480
researcher to eliminate open source

10
00:00:27,480 --> 00:00:29,279
security vulnerabilities once and for

11
00:00:29,279 --> 00:00:30,480
all

12
00:00:30,480 --> 00:00:33,180
um just a little bit of introduction uh

13
00:00:33,180 --> 00:00:35,820
who am I my name is Jonathan lychu I am

14
00:00:35,820 --> 00:00:37,559
a software engineer software security

15
00:00:37,559 --> 00:00:40,200
researcher I'm the first ever Dan

16
00:00:40,200 --> 00:00:42,000
Kaminsky fellow

17
00:00:42,000 --> 00:00:43,800
um I'm a get up star and a GitHub

18
00:00:43,800 --> 00:00:45,719
security Ambassador and you can find me

19
00:00:45,719 --> 00:00:48,360
on at Twitter or on Twitter at Jay light

20
00:00:48,360 --> 00:00:49,500
shoe

21
00:00:49,500 --> 00:00:51,239
um I'll put it up in the end of the

22
00:00:51,239 --> 00:00:53,760
slides too so

23
00:00:53,760 --> 00:00:55,860
um so a little bit of a disclaimer um

24
00:00:55,860 --> 00:00:58,500
this does cover a SAS tool

25
00:00:58,500 --> 00:01:00,780
um uh but it's available for free for

26
00:01:00,780 --> 00:01:02,520
open source and for use in your own

27
00:01:02,520 --> 00:01:04,739
security research also I'm legally

28
00:01:04,739 --> 00:01:06,060
obligated to tell you that I'm sponsored

29
00:01:06,060 --> 00:01:09,600
by GitHub so you know but uh again all

30
00:01:09,600 --> 00:01:11,159
the stuff in this talk is open source

31
00:01:11,159 --> 00:01:14,220
freely available to use yeah

32
00:01:14,220 --> 00:01:16,080
um this work is uh supported by the Dan

33
00:01:16,080 --> 00:01:18,540
Kaminsky fellowship at human security

34
00:01:18,540 --> 00:01:20,400
for those of you who don't know

35
00:01:20,400 --> 00:01:22,380
um Dan was best known for vulnerability

36
00:01:22,380 --> 00:01:26,100
in DNS back in 2008 um which he quietly

37
00:01:26,100 --> 00:01:28,439
fixed around the world

38
00:01:28,439 --> 00:01:30,720
um privately and then disclosed at black

39
00:01:30,720 --> 00:01:33,659
uh black hat and Defcon in 2008.

40
00:01:33,659 --> 00:01:35,400
um Dan was best known for his kindness

41
00:01:35,400 --> 00:01:37,140
and compassion in the security industry

42
00:01:37,140 --> 00:01:39,060
and I sadly never get never got the

43
00:01:39,060 --> 00:01:40,680
opportunity to meet Dan

44
00:01:40,680 --> 00:01:42,720
um uh and the Dan Kaminsky Fellowship

45
00:01:42,720 --> 00:01:44,700
was created to commemorate and celebrate

46
00:01:44,700 --> 00:01:47,040
Dan's memory and Legacy by funding open

47
00:01:47,040 --> 00:01:49,079
source work that helps make the world a

48
00:01:49,079 --> 00:01:51,299
better and more secure place and so this

49
00:01:51,299 --> 00:01:52,740
is the work that I've been doing under

50
00:01:52,740 --> 00:01:54,540
the Dan Kaminsky Fellowship for the past

51
00:01:54,540 --> 00:01:56,040
year

52
00:01:56,040 --> 00:01:56,820
um

53
00:01:56,820 --> 00:01:59,100
so spoilers

54
00:01:59,100 --> 00:02:01,439
uh I generated a bunch of pull requests

55
00:02:01,439 --> 00:02:03,960
to fix a vulnerability called zip slip

56
00:02:03,960 --> 00:02:05,939
across the Java ecosystem in particular

57
00:02:05,939 --> 00:02:09,000
I generated 152 pull requests to fix zip

58
00:02:09,000 --> 00:02:12,360
slip across the Java ecosystem but

59
00:02:12,360 --> 00:02:13,500
we'll get into if you don't know what

60
00:02:13,500 --> 00:02:16,260
zip slip is don't worry we'll get there

61
00:02:16,260 --> 00:02:19,980
um and uh also uh there's like a story

62
00:02:19,980 --> 00:02:22,319
for how we got here so let's start at

63
00:02:22,319 --> 00:02:23,640
the beginning

64
00:02:23,640 --> 00:02:25,379
um this whole story started with a

65
00:02:25,379 --> 00:02:27,239
simple vulnerability

66
00:02:27,239 --> 00:02:29,280
um and this was that vulnerability

67
00:02:29,280 --> 00:02:32,459
it was in my company's Gradle build and

68
00:02:32,459 --> 00:02:35,220
it was the use of HTTP instead of https

69
00:02:35,220 --> 00:02:38,220
to resolve our dependencies without any

70
00:02:38,220 --> 00:02:39,780
additional authentication because the

71
00:02:39,780 --> 00:02:41,220
job ecosystem doesn't have additional

72
00:02:41,220 --> 00:02:43,019
verification of artifacts being

73
00:02:43,019 --> 00:02:46,200
downloaded in your build build tool

74
00:02:46,200 --> 00:02:47,819
um and so this is why this is important

75
00:02:47,819 --> 00:02:49,560
right you know classic attacker in the

76
00:02:49,560 --> 00:02:51,599
middle vulnerability uh the use that can

77
00:02:51,599 --> 00:02:54,540
be result of using HTTP instead of https

78
00:02:54,540 --> 00:02:56,400
and this is an example of that same

79
00:02:56,400 --> 00:02:59,280
vulnerability existing in Maven Palm

80
00:02:59,280 --> 00:03:01,680
files so Gradle which is the first build

81
00:03:01,680 --> 00:03:03,300
tool file that I showed you is used to

82
00:03:03,300 --> 00:03:05,879
build 50 of the Java ecosystem and Maven

83
00:03:05,879 --> 00:03:07,440
is used to build the other 50 of the

84
00:03:07,440 --> 00:03:09,599
Java ecosystem and Gradle is also used

85
00:03:09,599 --> 00:03:11,940
as the build tool for 99 of the Android

86
00:03:11,940 --> 00:03:13,200
ecosystem so if you have an Android

87
00:03:13,200 --> 00:03:15,780
phone the apps on your phone some way

88
00:03:15,780 --> 00:03:17,040
got there through the supply chain

89
00:03:17,040 --> 00:03:19,560
supplied by Gradle

90
00:03:19,560 --> 00:03:22,319
um and uh this is what it looks like in

91
00:03:22,319 --> 00:03:24,300
artif in artifact upload and this is

92
00:03:24,300 --> 00:03:25,860
where credentials are also attached so

93
00:03:25,860 --> 00:03:27,120
they're also sending credentials Over

94
00:03:27,120 --> 00:03:28,019
The Wire

95
00:03:28,019 --> 00:03:30,060
and this vulnerability was everywhere

96
00:03:30,060 --> 00:03:32,159
it existed in the organizations of

97
00:03:32,159 --> 00:03:34,800
spring the project of spring Apache Red

98
00:03:34,800 --> 00:03:37,739
Hat kotlin jet brains Jenkins Gradle

99
00:03:37,739 --> 00:03:40,140
groovy elasticsearch

100
00:03:40,140 --> 00:03:42,840
um Eclipse Foundation

101
00:03:42,840 --> 00:03:46,140
um and who else was vulnerable

102
00:03:46,140 --> 00:03:49,620
um Oracle the NSA uh LinkedIn stripe

103
00:03:49,620 --> 00:03:52,200
this impacted uh open source projects of

104
00:03:52,200 --> 00:03:55,140
all of these different organizations

105
00:03:55,140 --> 00:03:57,480
so I reached out to maven's owner type

106
00:03:57,480 --> 00:04:01,319
and Maven sonar type is uh the python

107
00:04:01,319 --> 00:04:04,319
pip to the python ecosystem npm to the

108
00:04:04,319 --> 00:04:06,599
JavaScript ecosystem sonar type is that

109
00:04:06,599 --> 00:04:08,819
for the Java ecosystem and they reported

110
00:04:08,819 --> 00:04:12,060
that 25 of their traffic in June of 2020

111
00:04:12,060 --> 00:04:14,580
2019 was still using hdp to resolve

112
00:04:14,580 --> 00:04:16,978
dependencies instead of https

113
00:04:16,978 --> 00:04:19,079
and so how do we fix this

114
00:04:19,079 --> 00:04:22,079
well I pushed forward an initiative that

115
00:04:22,079 --> 00:04:24,600
on January 15 2020 all the major

116
00:04:24,600 --> 00:04:26,280
artifact servers in the Java ecosystem

117
00:04:26,280 --> 00:04:28,380
would decommission support for HTTP in

118
00:04:28,380 --> 00:04:31,139
favor of only supporting https

119
00:04:31,139 --> 00:04:33,360
and I got support the bit the major

120
00:04:33,360 --> 00:04:35,520
artifact servers all publish blog posts

121
00:04:35,520 --> 00:04:38,100
announcing it I published tweets we

122
00:04:38,100 --> 00:04:39,780
talked about it

123
00:04:39,780 --> 00:04:43,380
um and uh unfortunately

124
00:04:43,380 --> 00:04:47,040
um on uh January 2020

125
00:04:47,040 --> 00:04:49,560
um which was only you know 15 days away

126
00:04:49,560 --> 00:04:51,600
from decommissioning support for HTTP

127
00:04:51,600 --> 00:04:53,880
across the industry sonotype said that

128
00:04:53,880 --> 00:04:57,419
still 20 of the artifacts are of the of

129
00:04:57,419 --> 00:04:59,040
the industry was using HTTP to resolve

130
00:04:59,040 --> 00:05:01,199
dependencies instead of https

131
00:05:01,199 --> 00:05:03,060
so you can imagine

132
00:05:03,060 --> 00:05:04,740
what might have happened

133
00:05:04,740 --> 00:05:08,479
on January 15 2020

134
00:05:09,840 --> 00:05:13,280
lots of broken software

135
00:05:13,500 --> 00:05:14,160
um

136
00:05:14,160 --> 00:05:17,160
yeah but we stopped the bleeding

137
00:05:17,160 --> 00:05:18,600
um but what about the other repositories

138
00:05:18,600 --> 00:05:21,000
so these are only the most commonly used

139
00:05:21,000 --> 00:05:23,580
repositories in the job ecosystem

140
00:05:23,580 --> 00:05:25,320
um their other the thing about the Java

141
00:05:25,320 --> 00:05:27,120
ecosystem is our companies will host

142
00:05:27,120 --> 00:05:28,979
artifact servers organizations will host

143
00:05:28,979 --> 00:05:31,500
artifact servers so people are building

144
00:05:31,500 --> 00:05:33,960
their Java software from a variety of

145
00:05:33,960 --> 00:05:35,100
different sources pulling their

146
00:05:35,100 --> 00:05:36,300
components in from a variety of

147
00:05:36,300 --> 00:05:39,000
different repositories and so this only

148
00:05:39,000 --> 00:05:41,160
fixed the top four there's the rest of

149
00:05:41,160 --> 00:05:42,419
the industry and the rest of the open

150
00:05:42,419 --> 00:05:45,060
source ecosystem still vulnerable

151
00:05:45,060 --> 00:05:47,880
so how do we fix the rest

152
00:05:47,880 --> 00:05:49,800
and I said let's just generate pull

153
00:05:49,800 --> 00:05:51,720
requests let's let's fix this

154
00:05:51,720 --> 00:05:53,880
vulnerability at scale across and deal

155
00:05:53,880 --> 00:05:55,860
with the vulnerability at its source

156
00:05:55,860 --> 00:05:57,300
and so how

157
00:05:57,300 --> 00:05:59,100
well first you need to track down the

158
00:05:59,100 --> 00:06:01,020
vulnerable code and so I wrote a code ql

159
00:06:01,020 --> 00:06:04,320
query to find this vulnerability it's

160
00:06:04,320 --> 00:06:06,720
very simple and for this very and so

161
00:06:06,720 --> 00:06:09,479
codeql scans a hundred thousand uh open

162
00:06:09,479 --> 00:06:11,220
source projects

163
00:06:11,220 --> 00:06:12,720
um and so you can write a code to our

164
00:06:12,720 --> 00:06:14,340
query and run it against open source

165
00:06:14,340 --> 00:06:15,780
projects across the industry and find

166
00:06:15,780 --> 00:06:18,120
vulnerabilities just like this

167
00:06:18,120 --> 00:06:20,280
and for this little bit of query I

168
00:06:20,280 --> 00:06:21,900
submitted to the GitHub security lab bug

169
00:06:21,900 --> 00:06:23,819
bending program and got it merged into

170
00:06:23,819 --> 00:06:25,740
the main line so that any project that's

171
00:06:25,740 --> 00:06:28,259
using codeql to scan their projects are

172
00:06:28,259 --> 00:06:30,300
using this query now and for this GitHub

173
00:06:30,300 --> 00:06:34,100
awarded me a 2 300 bounty

174
00:06:35,340 --> 00:06:37,680
I'm getting a bit of a there we go

175
00:06:37,680 --> 00:06:39,539
um I was Echo back there and then I

176
00:06:39,539 --> 00:06:40,979
wrote a pull request generator using the

177
00:06:40,979 --> 00:06:42,720
list of vulnerable projects

178
00:06:42,720 --> 00:06:44,880
um it was python based it had a wrapper

179
00:06:44,880 --> 00:06:48,120
over github's Hub CLI one nasty regular

180
00:06:48,120 --> 00:06:50,220
expression and a lot of logic for

181
00:06:50,220 --> 00:06:52,500
bouncing off of github's rate limiter

182
00:06:52,500 --> 00:06:55,080
and this is the logic this is the uh the

183
00:06:55,080 --> 00:06:56,699
pull request engine

184
00:06:56,699 --> 00:06:58,740
um you can see the commit message the

185
00:06:58,740 --> 00:06:59,940
branch

186
00:06:59,940 --> 00:07:01,440
um there's an underlying engine behind

187
00:07:01,440 --> 00:07:03,240
all of this logic but this was the first

188
00:07:03,240 --> 00:07:04,740
thing that I wrote and this is that

189
00:07:04,740 --> 00:07:06,060
regular expression that I talked to you

190
00:07:06,060 --> 00:07:08,280
about and the re so this was for fixing

191
00:07:08,280 --> 00:07:10,979
it in XML files and the reason that I

192
00:07:10,979 --> 00:07:13,020
used a regular expression instead of an

193
00:07:13,020 --> 00:07:16,199
XML parser is that if you parse XML into

194
00:07:16,199 --> 00:07:18,840
an XML parser and then you modify that

195
00:07:18,840 --> 00:07:21,479
XML and then you dump it back out

196
00:07:21,479 --> 00:07:23,280
the XML parser is going to dump it back

197
00:07:23,280 --> 00:07:25,680
out into its format not the format of

198
00:07:25,680 --> 00:07:26,880
the source code that you originally

199
00:07:26,880 --> 00:07:29,580
imported and so the only way to fix

200
00:07:29,580 --> 00:07:32,099
vulnerabilities and not have a giant

201
00:07:32,099 --> 00:07:33,900
diff that the maintainer is going to see

202
00:07:33,900 --> 00:07:35,759
and be like great thanks for fixing a

203
00:07:35,759 --> 00:07:37,199
vulnerability I'm not merging that

204
00:07:37,199 --> 00:07:39,300
though because it changes everything

205
00:07:39,300 --> 00:07:42,000
else in the file you need to use regular

206
00:07:42,000 --> 00:07:43,319
expressions

207
00:07:43,319 --> 00:07:45,539
the problem is

208
00:07:45,539 --> 00:07:47,160
if you use regular Expressions to solve

209
00:07:47,160 --> 00:07:51,080
your problem now you have two problems

210
00:07:52,800 --> 00:07:53,400
um

211
00:07:53,400 --> 00:07:56,160
but it worked regardless

212
00:07:56,160 --> 00:07:58,740
um I generated pull requests

213
00:07:58,740 --> 00:08:00,479
um in fact I gen and this is an example

214
00:08:00,479 --> 00:08:01,979
of the diff right just a simple

215
00:08:01,979 --> 00:08:04,080
replacement HTTP to https in the right

216
00:08:04,080 --> 00:08:06,240
locations in these pom files

217
00:08:06,240 --> 00:08:09,360
and I generated 1596 pull requests to

218
00:08:09,360 --> 00:08:11,160
fix this vulnerability across the Java

219
00:08:11,160 --> 00:08:13,520
ecosystem

220
00:08:13,860 --> 00:08:18,300
um and as this was in 2020 as of 20 2022

221
00:08:18,300 --> 00:08:21,240
today there's about a 40 merge rate on

222
00:08:21,240 --> 00:08:23,220
that which is a solid number of projects

223
00:08:23,220 --> 00:08:25,740
that have been fixed as a result of this

224
00:08:25,740 --> 00:08:28,080
and for this additional work get up

225
00:08:28,080 --> 00:08:29,580
awarded me an additional four thousand

226
00:08:29,580 --> 00:08:32,219
dollar bounty for this work and fixing

227
00:08:32,219 --> 00:08:33,479
this vulnerability across GitHub under

228
00:08:33,479 --> 00:08:35,099
the GitHub security lab

229
00:08:35,099 --> 00:08:36,958
branding program

230
00:08:36,958 --> 00:08:38,880
so I got hooked on this idea of bulk

231
00:08:38,880 --> 00:08:40,679
pull request generation

232
00:08:40,679 --> 00:08:43,140
this is my GitHub contribution graph for

233
00:08:43,140 --> 00:08:44,880
uh 2020.

234
00:08:44,880 --> 00:08:46,200
um you can see I actually did two

235
00:08:46,200 --> 00:08:47,940
campaigns of different for different

236
00:08:47,940 --> 00:08:50,399
vulnerabilities in 2020.

237
00:08:50,399 --> 00:08:51,660
um

238
00:08:51,660 --> 00:08:54,300
I have a problem

239
00:08:54,300 --> 00:08:55,220
um

240
00:08:55,220 --> 00:08:57,000
ivadhd

241
00:08:57,000 --> 00:08:58,860
that's not my problem I don't think that

242
00:08:58,860 --> 00:09:01,200
ADHD is a problem the problem is that I

243
00:09:01,200 --> 00:09:04,080
love chasing squirrels and I will go and

244
00:09:04,080 --> 00:09:06,480
read vulnerability disclosure feeds and

245
00:09:06,480 --> 00:09:08,220
I'll be like I wonder where else that

246
00:09:08,220 --> 00:09:09,839
vulnerability is

247
00:09:09,839 --> 00:09:11,760
and the thing is

248
00:09:11,760 --> 00:09:14,279
I will find that same vulnerability in a

249
00:09:14,279 --> 00:09:16,800
lot of places using codeql using the

250
00:09:16,800 --> 00:09:19,980
GitHub security uh GitHub search

251
00:09:19,980 --> 00:09:21,360
um I'm finding too many security

252
00:09:21,360 --> 00:09:23,220
vulnerabilities

253
00:09:23,220 --> 00:09:26,519
uh this is an example of a codeql query

254
00:09:26,519 --> 00:09:28,320
result for zip slip I didn't write the

255
00:09:28,320 --> 00:09:30,000
query but you can look at this this is

256
00:09:30,000 --> 00:09:32,940
on lgtm.com and there are pages and

257
00:09:32,940 --> 00:09:35,279
pages and pages and pages of this result

258
00:09:35,279 --> 00:09:37,860
coming back with positive indications of

259
00:09:37,860 --> 00:09:39,180
this vulnerability existing in open

260
00:09:39,180 --> 00:09:41,279
source software this is a critical

261
00:09:41,279 --> 00:09:43,800
security vulnerability in a lot of cases

262
00:09:43,800 --> 00:09:46,200
and so if I'm finding too many security

263
00:09:46,200 --> 00:09:47,459
vulnerabilities

264
00:09:47,459 --> 00:09:50,940
I need a solution I need automation

265
00:09:50,940 --> 00:09:53,040
so this is where automated accurate

266
00:09:53,040 --> 00:09:54,959
transformation and massive scale comes

267
00:09:54,959 --> 00:09:56,700
in this is I need a solution that allows

268
00:09:56,700 --> 00:09:58,440
for Adam automated

269
00:09:58,440 --> 00:10:00,839
um accurate Transformations and this is

270
00:10:00,839 --> 00:10:02,700
where open rewrite comes in

271
00:10:02,700 --> 00:10:05,160
open rewrite is an open source Library

272
00:10:05,160 --> 00:10:08,339
available on GitHub and it lets us write

273
00:10:08,339 --> 00:10:10,320
recipes

274
00:10:10,320 --> 00:10:12,839
um to fix vulnerabilities at scale and

275
00:10:12,839 --> 00:10:16,399
the unlock that open rewrite provides so

276
00:10:16,399 --> 00:10:19,140
abstract syntax trees

277
00:10:19,140 --> 00:10:21,600
um abstract syntax trees represent the

278
00:10:21,600 --> 00:10:23,640
source code that you're looking at the

279
00:10:23,640 --> 00:10:25,320
pro so when you're running a compiler

280
00:10:25,320 --> 00:10:27,060
like the Java compiler the c-compile

281
00:10:27,060 --> 00:10:29,580
they transform that that source code

282
00:10:29,580 --> 00:10:31,860
into an abstract syntax tree

283
00:10:31,860 --> 00:10:33,899
the problem is that if you were to dump

284
00:10:33,899 --> 00:10:35,940
this abstract syntax tree back out into

285
00:10:35,940 --> 00:10:37,380
source code

286
00:10:37,380 --> 00:10:39,720
you'd get all the white space gone all

287
00:10:39,720 --> 00:10:41,700
the tabs all the comments are missing

288
00:10:41,700 --> 00:10:43,140
because the compiler doesn't care about

289
00:10:43,140 --> 00:10:44,399
that stuff

290
00:10:44,399 --> 00:10:46,500
and so which what open rewrite allows

291
00:10:46,500 --> 00:10:49,800
and what open rewrite unlocks is that it

292
00:10:49,800 --> 00:10:52,620
lets you preserve those white space tabs

293
00:10:52,620 --> 00:10:55,019
and stuff like that and so you can

294
00:10:55,019 --> 00:10:56,940
transform back and forth between the AST

295
00:10:56,940 --> 00:10:59,339
that open rewrite has into the source

296
00:10:59,339 --> 00:11:02,760
code that was originally the source this

297
00:11:02,760 --> 00:11:03,600
is the problem that I was trying to

298
00:11:03,600 --> 00:11:04,620
solve with that regular expression

299
00:11:04,620 --> 00:11:06,540
earlier

300
00:11:06,540 --> 00:11:08,640
and also there is a templating engine

301
00:11:08,640 --> 00:11:10,680
that allows you to generate new code

302
00:11:10,680 --> 00:11:12,240
that looks like the surrounding source

303
00:11:12,240 --> 00:11:14,519
code so if that project uses tabs or

304
00:11:14,519 --> 00:11:16,920
uses spaces or uses braces on a new line

305
00:11:16,920 --> 00:11:19,380
it can generate new code that looks like

306
00:11:19,380 --> 00:11:20,940
that surrounding code so the maintainer

307
00:11:20,940 --> 00:11:22,440
is not going to be like hey great thank

308
00:11:22,440 --> 00:11:23,579
you for changing this but it doesn't

309
00:11:23,579 --> 00:11:25,320
look like my formatting I'm not going to

310
00:11:25,320 --> 00:11:27,800
merge this

311
00:11:27,839 --> 00:11:31,620
and also it's fully type attributed

312
00:11:31,620 --> 00:11:35,519
um is this log for J slf for J log back

313
00:11:35,519 --> 00:11:37,320
those are all logging Frameworks in the

314
00:11:37,320 --> 00:11:38,640
Java ecosystem

315
00:11:38,640 --> 00:11:40,920
the type attribution lets you know what

316
00:11:40,920 --> 00:11:42,959
type that is I can't imagine this ever

317
00:11:42,959 --> 00:11:45,000
being relevant potentially if there was

318
00:11:45,000 --> 00:11:46,320
a big security vulnerability in a

319
00:11:46,320 --> 00:11:47,579
logging framework

320
00:11:47,579 --> 00:11:49,870
ever log for J

321
00:11:49,870 --> 00:11:51,660
[Music]

322
00:11:51,660 --> 00:11:53,279
um so

323
00:11:53,279 --> 00:11:55,560
um and also uh with the with the type

324
00:11:55,560 --> 00:11:57,360
attribution and formatting you end up

325
00:11:57,360 --> 00:11:59,820
with this really rich graph of data that

326
00:11:59,820 --> 00:12:01,320
you can work on

327
00:12:01,320 --> 00:12:02,700
um there's actually six thousand nodes

328
00:12:02,700 --> 00:12:04,079
missing from this graph on the left

329
00:12:04,079 --> 00:12:07,279
because otherwise it'll just be fuzz

330
00:12:07,500 --> 00:12:10,500
um and if you need to generate new code

331
00:12:10,500 --> 00:12:12,899
sometimes it generates you have really

332
00:12:12,899 --> 00:12:15,720
complex AST so if you need to insert new

333
00:12:15,720 --> 00:12:17,700
source code into the AST to fix the

334
00:12:17,700 --> 00:12:19,500
vulnerability it can be really

335
00:12:19,500 --> 00:12:22,079
complicated and so what if I need to

336
00:12:22,079 --> 00:12:23,880
inject this new bit of code to fix zip

337
00:12:23,880 --> 00:12:25,260
slip

338
00:12:25,260 --> 00:12:26,760
and we'll again we'll get into zip slip

339
00:12:26,760 --> 00:12:27,899
and what it is for those of you don't

340
00:12:27,899 --> 00:12:29,279
know but let's assume we need to inject

341
00:12:29,279 --> 00:12:31,380
this code to fix a vulnerability how do

342
00:12:31,380 --> 00:12:33,660
we do that well openreerite comes with a

343
00:12:33,660 --> 00:12:36,779
templating engine that lets you say

344
00:12:36,779 --> 00:12:39,540
provide variables and a template and say

345
00:12:39,540 --> 00:12:41,519
I need to inject this code generate for

346
00:12:41,519 --> 00:12:45,180
me the AST the the Java types required

347
00:12:45,180 --> 00:12:48,360
to to represent this source code and it

348
00:12:48,360 --> 00:12:50,100
also comes with a coordinate system that

349
00:12:50,100 --> 00:12:53,639
lets you place that source code exactly

350
00:12:53,639 --> 00:12:55,920
in the right location in the file or in

351
00:12:55,920 --> 00:12:59,100
the tree to fix the vulnerability

352
00:12:59,100 --> 00:13:01,139
and so we can go from this vulnerable

353
00:13:01,139 --> 00:13:03,540
code to this fixed version of the code

354
00:13:03,540 --> 00:13:05,880
very easily

355
00:13:05,880 --> 00:13:08,399
so what's possible now

356
00:13:08,399 --> 00:13:10,260
what vulnerabilities can we fix given

357
00:13:10,260 --> 00:13:13,019
the unlock that open rewrite provides

358
00:13:13,019 --> 00:13:14,880
I'm going to talk to you about three

359
00:13:14,880 --> 00:13:17,100
different vulnerabilities temporary

360
00:13:17,100 --> 00:13:19,139
directory hijacking partial past

361
00:13:19,139 --> 00:13:21,660
reversal and zip slip and the research

362
00:13:21,660 --> 00:13:23,399
that I engaged in using openreerite to

363
00:13:23,399 --> 00:13:25,860
fix these vulnerabilities at scale

364
00:13:25,860 --> 00:13:28,380
so vulnerability number one temporary

365
00:13:28,380 --> 00:13:30,660
directory hijacking

366
00:13:30,660 --> 00:13:32,700
um for those of you don't know the

367
00:13:32,700 --> 00:13:35,459
temporary directory on unix-like systems

368
00:13:35,459 --> 00:13:37,440
is shared between all users so if you

369
00:13:37,440 --> 00:13:39,060
write contents to file contents into

370
00:13:39,060 --> 00:13:40,980
that directory other local users will be

371
00:13:40,980 --> 00:13:43,620
able to view that those files

372
00:13:43,620 --> 00:13:45,060
and this is temporary directory

373
00:13:45,060 --> 00:13:46,260
hijacking

374
00:13:46,260 --> 00:13:48,300
and the vulnerability exists because

375
00:13:48,300 --> 00:13:50,540
well this bit of code you'll see a lot

376
00:13:50,540 --> 00:13:54,839
because prior to Java 1.7 there did not

377
00:13:54,839 --> 00:13:56,940
exist an API to create a temporary

378
00:13:56,940 --> 00:13:58,019
directory

379
00:13:58,019 --> 00:14:00,180
so people would create a temporary file

380
00:14:00,180 --> 00:14:02,519
which does create a file with a randomly

381
00:14:02,519 --> 00:14:05,600
named you know pseudo random or csprng

382
00:14:05,600 --> 00:14:08,519
like secure random number generator and

383
00:14:08,519 --> 00:14:10,380
then they call delete on it and then

384
00:14:10,380 --> 00:14:12,420
they call maker and this is because

385
00:14:12,420 --> 00:14:13,740
there wasn't an API to create

386
00:14:13,740 --> 00:14:16,139
directories directly

387
00:14:16,139 --> 00:14:18,600
and so you'd actually get this

388
00:14:18,600 --> 00:14:20,399
vulnerability if you looked on stack

389
00:14:20,399 --> 00:14:21,839
Overflow to say how do I create a

390
00:14:21,839 --> 00:14:23,459
temporary directory

391
00:14:23,459 --> 00:14:24,480
um

392
00:14:24,480 --> 00:14:26,339
so why is this vulnerable it's

393
00:14:26,339 --> 00:14:27,360
vulnerable because there's a race

394
00:14:27,360 --> 00:14:30,120
condition here the race condition exists

395
00:14:30,120 --> 00:14:31,920
between the delete and the maker an

396
00:14:31,920 --> 00:14:33,959
attacker can view the content the direct

397
00:14:33,959 --> 00:14:36,060
the file being created see that it gets

398
00:14:36,060 --> 00:14:38,279
deleted and then race the Java process

399
00:14:38,279 --> 00:14:40,320
to create the directory before the job

400
00:14:40,320 --> 00:14:42,959
before the uh the Java process does and

401
00:14:42,959 --> 00:14:45,899
if they do they own the directory

402
00:14:45,899 --> 00:14:49,019
and this directory returns false this

403
00:14:49,019 --> 00:14:52,079
maker returns false if it fails so if

404
00:14:52,079 --> 00:14:53,399
you're not checking the return code

405
00:14:53,399 --> 00:14:55,199
You're vulnerable it doesn't throw an

406
00:14:55,199 --> 00:14:57,899
exception if maker fails

407
00:14:57,899 --> 00:14:59,940
this is one valid fix for this

408
00:14:59,940 --> 00:15:01,620
vulnerability however it's still

409
00:15:01,620 --> 00:15:02,940
insufficient because when you use

410
00:15:02,940 --> 00:15:05,220
maketer it'll use the default you name

411
00:15:05,220 --> 00:15:07,199
permissions for the file that's being

412
00:15:07,199 --> 00:15:09,480
created and so this directory that's

413
00:15:09,480 --> 00:15:11,339
been created will still be visible to

414
00:15:11,339 --> 00:15:13,019
the con the contents of the directory

415
00:15:13,019 --> 00:15:15,300
will still be visible to other users and

416
00:15:15,300 --> 00:15:16,980
so you're still exposing the contents

417
00:15:16,980 --> 00:15:18,300
and so this is what's called temporary

418
00:15:18,300 --> 00:15:21,660
directory information disclosure

419
00:15:21,660 --> 00:15:23,579
and so this is the real effects you

420
00:15:23,579 --> 00:15:25,139
switch to this new API that was

421
00:15:25,139 --> 00:15:27,420
introduced in Java 1.7 we're currently

422
00:15:27,420 --> 00:15:30,420
on Java 17. so this API has been around

423
00:15:30,420 --> 00:15:32,880
for a while you can safely use it

424
00:15:32,880 --> 00:15:34,380
um and this will fix the vulnerability

425
00:15:34,380 --> 00:15:36,180
by setting the correct posix permissions

426
00:15:36,180 --> 00:15:39,060
on the directory that's being created

427
00:15:39,060 --> 00:15:40,440
and I got a bunch of CVS for this

428
00:15:40,440 --> 00:15:42,420
vulnerability

429
00:15:42,420 --> 00:15:45,779
um and uh I generated pull requests in

430
00:15:45,779 --> 00:15:47,699
this case I generated 64 pull requests

431
00:15:47,699 --> 00:15:49,440
across the open source ecosystem to fix

432
00:15:49,440 --> 00:15:53,040
this vulnerability across open source

433
00:15:53,040 --> 00:15:53,699
um

434
00:15:53,699 --> 00:15:55,620
and this is an example

435
00:15:55,620 --> 00:15:57,240
um you can see the removal of the delete

436
00:15:57,240 --> 00:15:59,399
in the maker but we can also do more

437
00:15:59,399 --> 00:16:01,260
complicated things if we need to remove

438
00:16:01,260 --> 00:16:03,060
those we need to remove those if checks

439
00:16:03,060 --> 00:16:04,800
because even though this is not

440
00:16:04,800 --> 00:16:06,480
vulnerable to Temporary hijacking it's

441
00:16:06,480 --> 00:16:07,860
still vulnerable to Temporary directory

442
00:16:07,860 --> 00:16:09,959
information disclosure so we still want

443
00:16:09,959 --> 00:16:11,519
to fix this vulnerability and clean it

444
00:16:11,519 --> 00:16:13,980
up and so you can see that open rewrite

445
00:16:13,980 --> 00:16:15,779
is able to generate this diff

446
00:16:15,779 --> 00:16:17,399
using the abstract syntax tree

447
00:16:17,399 --> 00:16:20,060
Transformer open

448
00:16:20,220 --> 00:16:22,560
and so vulnerability number two that I

449
00:16:22,560 --> 00:16:23,519
want to talk to you about is a

450
00:16:23,519 --> 00:16:24,899
vulnerability called partial path

451
00:16:24,899 --> 00:16:26,339
traversal

452
00:16:26,339 --> 00:16:28,320
partial path reversal let's assume that

453
00:16:28,320 --> 00:16:29,760
you have two local users on a system

454
00:16:29,760 --> 00:16:31,860
you've user Sam

455
00:16:31,860 --> 00:16:33,899
and user Samantha

456
00:16:33,899 --> 00:16:35,639
and you want to you have logic that you

457
00:16:35,639 --> 00:16:36,959
want to sandbox

458
00:16:36,959 --> 00:16:40,440
your file access to user Sam

459
00:16:40,440 --> 00:16:42,660
partial past reversal allows an attacker

460
00:16:42,660 --> 00:16:45,060
to access a sibling directory with the

461
00:16:45,060 --> 00:16:46,440
same prefix

462
00:16:46,440 --> 00:16:48,959
so again starting with user Sam

463
00:16:48,959 --> 00:16:51,060
if you have user Samantha

464
00:16:51,060 --> 00:16:52,860
the vulnerability exists because you

465
00:16:52,860 --> 00:16:54,600
haven't correctly sandboxed your logic

466
00:16:54,600 --> 00:16:56,459
and it allows an attacker to access user

467
00:16:56,459 --> 00:16:57,839
Samantha because they share a common

468
00:16:57,839 --> 00:16:59,759
prefix

469
00:16:59,759 --> 00:17:02,220
and this is the vulnerable code but

470
00:17:02,220 --> 00:17:03,600
let's dive into why this is vulnerable

471
00:17:03,600 --> 00:17:05,160
in particular

472
00:17:05,160 --> 00:17:06,780
um so

473
00:17:06,780 --> 00:17:09,119
get canonical path is actually the

474
00:17:09,119 --> 00:17:10,439
reason this is vulnerable and let's dive

475
00:17:10,439 --> 00:17:12,540
into why get canonical path is used to

476
00:17:12,540 --> 00:17:15,179
normalize a file so it gets rid of the

477
00:17:15,179 --> 00:17:17,520
dot uh the path rehearsals right it

478
00:17:17,520 --> 00:17:20,040
normalizes the file out

479
00:17:20,040 --> 00:17:21,839
um so the problem with get canonical

480
00:17:21,839 --> 00:17:23,040
path though is even though it does

481
00:17:23,040 --> 00:17:25,199
correctly normalize the file

482
00:17:25,199 --> 00:17:28,500
when you it returns a string and that

483
00:17:28,500 --> 00:17:30,299
string that gets returned when you call

484
00:17:30,299 --> 00:17:32,820
it a user spam it returns a string like

485
00:17:32,820 --> 00:17:33,720
this

486
00:17:33,720 --> 00:17:35,580
you notice

487
00:17:35,580 --> 00:17:37,740
there's a missing

488
00:17:37,740 --> 00:17:41,039
um trailing slash on that string

489
00:17:41,039 --> 00:17:42,960
and so if you're using this starts with

490
00:17:42,960 --> 00:17:43,919
call

491
00:17:43,919 --> 00:17:45,960
it's allows the vulnerability so let's

492
00:17:45,960 --> 00:17:47,520
take this input as an example let's say

493
00:17:47,520 --> 00:17:49,260
that we've sandboxed our logic to user

494
00:17:49,260 --> 00:17:50,280
Sam

495
00:17:50,280 --> 00:17:52,500
and we have a user controlled value

496
00:17:52,500 --> 00:17:54,419
coming in

497
00:17:54,419 --> 00:17:57,360
uh dot dot slash Samantha slash baz when

498
00:17:57,360 --> 00:18:00,240
get canonical path gets called on that

499
00:18:00,240 --> 00:18:03,059
user slash Samantha slash baz does start

500
00:18:03,059 --> 00:18:05,400
with user Sam

501
00:18:05,400 --> 00:18:07,559
and this i o exception does not get

502
00:18:07,559 --> 00:18:09,480
thrown and the guard that was in place

503
00:18:09,480 --> 00:18:11,520
gets bypassed

504
00:18:11,520 --> 00:18:13,140
and so what's the fix for partial path

505
00:18:13,140 --> 00:18:14,580
reversal

506
00:18:14,580 --> 00:18:18,360
so the fix one of the fixes is to re-add

507
00:18:18,360 --> 00:18:20,100
that pass separator value back into the

508
00:18:20,100 --> 00:18:21,539
starts with call

509
00:18:21,539 --> 00:18:24,840
the better fix though is to use the Java

510
00:18:24,840 --> 00:18:27,480
um set one point or 1.7 introduced API

511
00:18:27,480 --> 00:18:30,179
path and do a start which starts with

512
00:18:30,179 --> 00:18:32,220
comparison on it and that will do the

513
00:18:32,220 --> 00:18:34,919
correct comparisons

514
00:18:34,919 --> 00:18:36,780
um yes so how do we find this

515
00:18:36,780 --> 00:18:38,039
vulnerability

516
00:18:38,039 --> 00:18:40,020
well if you're looking at this code we

517
00:18:40,020 --> 00:18:41,220
need to identify the vulnerability in

518
00:18:41,220 --> 00:18:43,080
order to fix it with open rewrite so how

519
00:18:43,080 --> 00:18:44,160
do we do that

520
00:18:44,160 --> 00:18:46,140
so first thing we're looking for in this

521
00:18:46,140 --> 00:18:48,299
in the abstract syntax tree is a starts

522
00:18:48,299 --> 00:18:50,700
with call on the string object the Java

523
00:18:50,700 --> 00:18:52,020
string object

524
00:18:52,020 --> 00:18:54,720
and then we're looking for a subject get

525
00:18:54,720 --> 00:18:56,460
canonical path and also an argument

526
00:18:56,460 --> 00:18:58,740
which is get canonical path

527
00:18:58,740 --> 00:19:00,960
and we want to also look for cases where

528
00:19:00,960 --> 00:19:03,179
we have this path separator character

529
00:19:03,179 --> 00:19:05,100
uh present because we don't want to fix

530
00:19:05,100 --> 00:19:06,900
source code that's vulnerable not

531
00:19:06,900 --> 00:19:08,400
vulnerable right this is not vulnerable

532
00:19:08,400 --> 00:19:10,740
we don't want to fix it right so we need

533
00:19:10,740 --> 00:19:11,880
to differentiate that because we don't

534
00:19:11,880 --> 00:19:13,020
want to be generating pull requests

535
00:19:13,020 --> 00:19:14,400
where it's not necessary to fix this

536
00:19:14,400 --> 00:19:16,080
vulnerability

537
00:19:16,080 --> 00:19:18,539
so it can't just be that easy right

538
00:19:18,539 --> 00:19:20,580
well developers write code in a lot of

539
00:19:20,580 --> 00:19:21,780
different ways

540
00:19:21,780 --> 00:19:24,480
so what if a developer pulls that value

541
00:19:24,480 --> 00:19:26,580
into a variable

542
00:19:26,580 --> 00:19:28,799
or they pull the argument into a

543
00:19:28,799 --> 00:19:31,860
variable or they have the fix but it's

544
00:19:31,860 --> 00:19:34,260
also in a variable how do we know if

545
00:19:34,260 --> 00:19:36,000
this logic is vulnerable or not when

546
00:19:36,000 --> 00:19:37,500
looking at it from the abstract syntax

547
00:19:37,500 --> 00:19:38,760
tree

548
00:19:38,760 --> 00:19:41,100
and so we need data flow analysis

549
00:19:41,100 --> 00:19:43,740
data flow analysis allows us to track

550
00:19:43,740 --> 00:19:45,900
the value as it flows through the

551
00:19:45,900 --> 00:19:47,820
application and determine this starts

552
00:19:47,820 --> 00:19:49,559
with is being called on the return value

553
00:19:49,559 --> 00:19:51,419
of get canonical path

554
00:19:51,419 --> 00:19:53,940
and it also lets us determine that the

555
00:19:53,940 --> 00:19:55,679
argument is Flowing to this argument in

556
00:19:55,679 --> 00:19:57,419
this function but it also can do

557
00:19:57,419 --> 00:19:58,980
intermediate steps through the

558
00:19:58,980 --> 00:20:02,520
application as well and track that

559
00:20:02,520 --> 00:20:04,860
so dataflow allows us to uncover hard to

560
00:20:04,860 --> 00:20:06,960
find vulnerabilities and prevents false

561
00:20:06,960 --> 00:20:08,880
positives

562
00:20:08,880 --> 00:20:11,760
and this is the data flow analysis API

563
00:20:11,760 --> 00:20:13,380
um how many of you have written any code

564
00:20:13,380 --> 00:20:15,059
ql

565
00:20:15,059 --> 00:20:17,280
hey hey hey yeah we actually got some

566
00:20:17,280 --> 00:20:19,559
responses so if you've used codeql's

567
00:20:19,559 --> 00:20:21,840
data flow analysis API

568
00:20:21,840 --> 00:20:23,880
um this is very similar I wrote it

569
00:20:23,880 --> 00:20:25,679
intentionally to make my life sane and

570
00:20:25,679 --> 00:20:27,179
your life saying so you can translate

571
00:20:27,179 --> 00:20:28,980
your knowledge from data flow analysis

572
00:20:28,980 --> 00:20:33,120
for codeql to open rewrite very easily

573
00:20:33,120 --> 00:20:33,900
um

574
00:20:33,900 --> 00:20:36,179
and this is the fix right this is an

575
00:20:36,179 --> 00:20:37,500
example of actually generating the fix

576
00:20:37,500 --> 00:20:39,240
to fix this vulnerability

577
00:20:39,240 --> 00:20:40,860
um you can see we clean up the code and

578
00:20:40,860 --> 00:20:44,479
we put the correct call in place

579
00:20:44,640 --> 00:20:45,660
um there's an example of this

580
00:20:45,660 --> 00:20:48,900
vulnerability it was uh in the AWS Java

581
00:20:48,900 --> 00:20:51,780
SDK this is a funny story I promised you

582
00:20:51,780 --> 00:20:55,260
um and uh this vulnerability

583
00:20:55,260 --> 00:20:57,840
um existed in this little bit of logic

584
00:20:57,840 --> 00:21:01,140
that attempted to sandbox as you're

585
00:21:01,140 --> 00:21:03,000
downloading the contents of an AWS S3

586
00:21:03,000 --> 00:21:07,140
bucket uh to verify that the keys of

587
00:21:07,140 --> 00:21:09,539
that AWS S3 bucket are not path reversal

588
00:21:09,539 --> 00:21:11,160
payloads attempting to escape the

589
00:21:11,160 --> 00:21:12,419
destination directory when you're

590
00:21:12,419 --> 00:21:13,740
downloading the contents of the S3

591
00:21:13,740 --> 00:21:15,120
bucket

592
00:21:15,120 --> 00:21:17,039
and so they were using this logic this

593
00:21:17,039 --> 00:21:18,900
method called leaves root and you can

594
00:21:18,900 --> 00:21:20,520
see that vulnerability where that starts

595
00:21:20,520 --> 00:21:22,320
with call is that leads us to be

596
00:21:22,320 --> 00:21:23,580
vulnerable

597
00:21:23,580 --> 00:21:25,260
and they were using it in this guard

598
00:21:25,260 --> 00:21:27,660
here that says cannot download key as

599
00:21:27,660 --> 00:21:29,220
relative path resolves Outside The

600
00:21:29,220 --> 00:21:30,720
Parent Directory

601
00:21:30,720 --> 00:21:32,880
so it was vulnerable I reported it to

602
00:21:32,880 --> 00:21:35,100
the AWS team and

603
00:21:35,100 --> 00:21:36,120
um there was a little bit of

604
00:21:36,120 --> 00:21:38,100
vulnerability disclosure drama as with

605
00:21:38,100 --> 00:21:39,780
any good story

606
00:21:39,780 --> 00:21:43,860
the AWS security team uh said to me hey

607
00:21:43,860 --> 00:21:44,820
thank you for reporting this

608
00:21:44,820 --> 00:21:46,980
vulnerability we'd love like to award

609
00:21:46,980 --> 00:21:48,960
you a bug Bounty however we need you to

610
00:21:48,960 --> 00:21:50,580
sign an NDA

611
00:21:50,580 --> 00:21:52,440
and I said I don't normally sign any

612
00:21:52,440 --> 00:21:54,299
agree to ndas can I read it for first

613
00:21:54,299 --> 00:21:55,980
before agreeing

614
00:21:55,980 --> 00:21:58,559
and they said we are unable to share the

615
00:21:58,559 --> 00:22:00,539
bug binding program NDA since it and

616
00:22:00,539 --> 00:22:02,100
other contract documents are considered

617
00:22:02,100 --> 00:22:05,240
sensitive by the legal team

618
00:22:15,500 --> 00:22:19,700
anybody play Pokemon yeah

619
00:22:26,280 --> 00:22:29,280
so

620
00:22:29,280 --> 00:22:30,120
um

621
00:22:30,120 --> 00:22:33,600
ah there's drama there uh tell us I

622
00:22:33,600 --> 00:22:34,500
don't have the time to tell the rest

623
00:22:34,500 --> 00:22:35,880
anyways

624
00:22:35,880 --> 00:22:37,320
they haven't paid me yet that's the

625
00:22:37,320 --> 00:22:38,460
summary

626
00:22:38,460 --> 00:22:39,480
um

627
00:22:39,480 --> 00:22:41,700
uh all right so vulnerability number

628
00:22:41,700 --> 00:22:43,860
three zip slip

629
00:22:43,860 --> 00:22:47,159
um zip slip uh is a path to versatile

630
00:22:47,159 --> 00:22:49,440
vulnerability while unpacking zip files

631
00:22:49,440 --> 00:22:52,559
uh file entries

632
00:22:52,559 --> 00:22:54,419
um and this is zip slip it the reason

633
00:22:54,419 --> 00:22:58,200
the Ziploc is so a zip file is a key

634
00:22:58,200 --> 00:23:01,860
value pair with the file path to the

635
00:23:01,860 --> 00:23:02,940
contents of the file that's getting

636
00:23:02,940 --> 00:23:05,580
unpacked now if an attacker controls

637
00:23:05,580 --> 00:23:07,740
that zip file they can craft a zip file

638
00:23:07,740 --> 00:23:11,640
that has a path to versal payload in the

639
00:23:11,640 --> 00:23:12,659
key

640
00:23:12,659 --> 00:23:16,559
and then that contents if the zip unzip

641
00:23:16,559 --> 00:23:19,380
logic is vulnerable will unpack outside

642
00:23:19,380 --> 00:23:21,960
of the intended destination directory

643
00:23:21,960 --> 00:23:24,419
and so this is vulnerable because get

644
00:23:24,419 --> 00:23:26,400
name is that key

645
00:23:26,400 --> 00:23:28,380
and the output stream is being created

646
00:23:28,380 --> 00:23:31,559
with that file and the contents of that

647
00:23:31,559 --> 00:23:33,059
file are being FL are flowing to that

648
00:23:33,059 --> 00:23:35,460
output stream and so this can lead to

649
00:23:35,460 --> 00:23:37,080
remote code execution in certain cases

650
00:23:37,080 --> 00:23:39,179
if you're able to overwrite the correct

651
00:23:39,179 --> 00:23:41,340
directory or write contents to the

652
00:23:41,340 --> 00:23:43,919
correct location on the file system

653
00:23:43,919 --> 00:23:46,740
zip slip is complicated

654
00:23:46,740 --> 00:23:49,260
um zip is complicated because

655
00:23:49,260 --> 00:23:49,980
um

656
00:23:49,980 --> 00:23:53,520
this is a valid fix for zip slip and

657
00:23:53,520 --> 00:23:55,740
again we're looking not just to fix it

658
00:23:55,740 --> 00:23:57,419
ourselves but also looking at source

659
00:23:57,419 --> 00:23:59,400
asts and saying is this code vulnerable

660
00:23:59,400 --> 00:24:01,500
do I need to fix it right so this is a

661
00:24:01,500 --> 00:24:03,299
valid fix

662
00:24:03,299 --> 00:24:05,520
but the problem with zip slip is that

663
00:24:05,520 --> 00:24:07,500
while this is a valid fix

664
00:24:07,500 --> 00:24:10,200
so is this right and developers write

665
00:24:10,200 --> 00:24:12,480
code in a lot of different ways

666
00:24:12,480 --> 00:24:14,760
so how do we determine if we're looking

667
00:24:14,760 --> 00:24:17,100
at this bit of logic or this bit of

668
00:24:17,100 --> 00:24:20,419
logic guarding this

669
00:24:20,419 --> 00:24:23,580
uh unpack logic and so we need control

670
00:24:23,580 --> 00:24:25,380
flow analysis

671
00:24:25,380 --> 00:24:27,059
control flow analysis lets us

672
00:24:27,059 --> 00:24:28,740
differentiate between these two bits of

673
00:24:28,740 --> 00:24:30,360
code and the way that we do that is by

674
00:24:30,360 --> 00:24:33,360
generating a graph that represents

675
00:24:33,360 --> 00:24:38,820
the flow of the uh of the code and the

676
00:24:38,820 --> 00:24:41,220
graph is made up of basic blocks which

677
00:24:41,220 --> 00:24:43,020
are the set of contiguous operations

678
00:24:43,020 --> 00:24:44,760
that are going to occur in a program

679
00:24:44,760 --> 00:24:46,679
without jumps

680
00:24:46,679 --> 00:24:49,200
and then there are condition nodes like

681
00:24:49,200 --> 00:24:53,159
if checks where in where the logic in a

682
00:24:53,159 --> 00:24:55,679
program will branch and by representing

683
00:24:55,679 --> 00:24:58,740
the code in this way with control flow

684
00:24:58,740 --> 00:25:01,380
analysis we can analyze this graph and

685
00:25:01,380 --> 00:25:02,940
determine if the vulnerable logic will

686
00:25:02,940 --> 00:25:04,440
be reachable or not

687
00:25:04,440 --> 00:25:06,080
or if there's a guard in place

688
00:25:06,080 --> 00:25:08,100
preventing that vulnerability from being

689
00:25:08,100 --> 00:25:09,360
present

690
00:25:09,360 --> 00:25:11,120
and so we can look at this

691
00:25:11,120 --> 00:25:14,159
non-vulnerable code and see that when we

692
00:25:14,159 --> 00:25:15,840
present the control flow analysis graph

693
00:25:15,840 --> 00:25:18,179
for that code we can see that there is a

694
00:25:18,179 --> 00:25:21,120
valid guard in place f.2 path starts

695
00:25:21,120 --> 00:25:22,799
with destination to path

696
00:25:22,799 --> 00:25:24,360
that prevents this vulnerability from

697
00:25:24,360 --> 00:25:27,960
existing so we don't need to fix it

698
00:25:27,960 --> 00:25:30,360
and so when we put all this together we

699
00:25:30,360 --> 00:25:32,760
can actually generate pull requests and

700
00:25:32,760 --> 00:25:34,919
generate or generate diffs to fix this

701
00:25:34,919 --> 00:25:36,960
vulnerability

702
00:25:36,960 --> 00:25:38,880
and this is you know a more complicated

703
00:25:38,880 --> 00:25:40,200
we're even cleaning up the surrounding

704
00:25:40,200 --> 00:25:41,820
code a little bit to fix this

705
00:25:41,820 --> 00:25:43,860
vulnerability

706
00:25:43,860 --> 00:25:45,120
so let's talk about pull request

707
00:25:45,120 --> 00:25:46,500
generation

708
00:25:46,500 --> 00:25:48,659
got security vulnerabilities everybody

709
00:25:48,659 --> 00:25:51,360
can get a pull request

710
00:25:51,360 --> 00:25:53,279
so there's some problems with pull

711
00:25:53,279 --> 00:25:55,440
request generation

712
00:25:55,440 --> 00:25:57,360
um one of the questions you might ask is

713
00:25:57,360 --> 00:25:59,640
how fast can you generate pull requests

714
00:25:59,640 --> 00:26:02,100
on something like GitHub

715
00:26:02,100 --> 00:26:04,140
so for when you're generating a pull

716
00:26:04,140 --> 00:26:05,400
request or even if you're creating a

717
00:26:05,400 --> 00:26:06,900
pull request as a developer as a

718
00:26:06,900 --> 00:26:09,299
developer there are a bunch of steps you

719
00:26:09,299 --> 00:26:10,919
need to make some of them are file i o

720
00:26:10,919 --> 00:26:13,620
git operations GitHub API calls GitHub

721
00:26:13,620 --> 00:26:15,900
API calls are rate Limited

722
00:26:15,900 --> 00:26:17,580
so the first thing you need to do is

723
00:26:17,580 --> 00:26:18,900
check out and download the source code

724
00:26:18,900 --> 00:26:21,299
repository which is a git operation it's

725
00:26:21,299 --> 00:26:23,880
free on GitHub doesn't not rate Limited

726
00:26:23,880 --> 00:26:26,580
at all then you need to Branch apply the

727
00:26:26,580 --> 00:26:29,220
diff and commit the changes Fork the

728
00:26:29,220 --> 00:26:31,020
repository on GitHub

729
00:26:31,020 --> 00:26:33,179
rename the repository on GitHub and this

730
00:26:33,179 --> 00:26:35,820
is important because if you're forking

731
00:26:35,820 --> 00:26:38,159
hundreds or thousands of repositories

732
00:26:38,159 --> 00:26:39,840
which I have done you're going to end up

733
00:26:39,840 --> 00:26:41,760
with name conflicts and so you need to

734
00:26:41,760 --> 00:26:43,559
rename the repository every single time

735
00:26:43,559 --> 00:26:45,240
to avoid those name conflicts otherwise

736
00:26:45,240 --> 00:26:48,240
GitHub says you can't do that

737
00:26:48,240 --> 00:26:50,220
then you need to push the changes

738
00:26:50,220 --> 00:26:52,020
and then you need to create the uh the

739
00:26:52,020 --> 00:26:54,059
pull request on GitHub and you'll notice

740
00:26:54,059 --> 00:26:56,940
that three of these are API calls to

741
00:26:56,940 --> 00:26:59,640
GitHub and GitHub asks that you wait at

742
00:26:59,640 --> 00:27:02,340
least one second per API call that makes

743
00:27:02,340 --> 00:27:04,320
a right or a modification to their

744
00:27:04,320 --> 00:27:05,940
system

745
00:27:05,940 --> 00:27:08,220
um and then they also have two addition

746
00:27:08,220 --> 00:27:10,860
a secondary and tertiary rate limit the

747
00:27:10,860 --> 00:27:12,480
secondary rate limit is a response with

748
00:27:12,480 --> 00:27:14,100
a header that says wait at least this

749
00:27:14,100 --> 00:27:15,360
amount of time before doing another

750
00:27:15,360 --> 00:27:17,940
operation and the third one is just slow

751
00:27:17,940 --> 00:27:20,340
down you've gone too fast

752
00:27:20,340 --> 00:27:23,760
um and the latter one doesn't really

753
00:27:23,760 --> 00:27:27,299
have a defined when to wait two so

754
00:27:27,299 --> 00:27:29,520
GitHub if you could uh stop radio

755
00:27:29,520 --> 00:27:31,320
limiting your API so aggressively it

756
00:27:31,320 --> 00:27:34,740
would make my life he's here

757
00:27:34,740 --> 00:27:37,200
um yeah so

758
00:27:37,200 --> 00:27:39,840
um we made it this far we've detected

759
00:27:39,840 --> 00:27:41,460
the vulnerability we've detected the

760
00:27:41,460 --> 00:27:43,080
style

761
00:27:43,080 --> 00:27:44,640
um and we fixed the code and generated

762
00:27:44,640 --> 00:27:46,380
the diff in the style that looks like

763
00:27:46,380 --> 00:27:48,000
the surrounding source code

764
00:27:48,000 --> 00:27:50,580
and we've we've bypassed the rate limit

765
00:27:50,580 --> 00:27:53,340
by basically slowing down enough

766
00:27:53,340 --> 00:27:55,260
um to whatever that means to make GitHub

767
00:27:55,260 --> 00:27:56,340
happy

768
00:27:56,340 --> 00:27:58,380
how do we actually fix this for all the

769
00:27:58,380 --> 00:28:01,500
repositories on GitHub that we want

770
00:28:01,500 --> 00:28:02,880
so this is where I'm going to introduce

771
00:28:02,880 --> 00:28:03,779
modern

772
00:28:03,779 --> 00:28:06,000
modern is free for open source projects

773
00:28:06,000 --> 00:28:08,279
they have about 7 000 repositories

774
00:28:08,279 --> 00:28:12,360
indexed across the Java ecosystem and it

775
00:28:12,360 --> 00:28:14,539
allows you to run rewrite

776
00:28:14,539 --> 00:28:17,400
Transformations at scale and generate

777
00:28:17,400 --> 00:28:19,080
and update any pull requests that you

778
00:28:19,080 --> 00:28:21,299
may create using it

779
00:28:21,299 --> 00:28:23,940
and this is the um the SAS that they

780
00:28:23,940 --> 00:28:26,279
that they have they have recipes for

781
00:28:26,279 --> 00:28:27,720
things like

782
00:28:27,720 --> 00:28:30,419
um transforming uh your code from you

783
00:28:30,419 --> 00:28:33,000
know updating the version of spring for

784
00:28:33,000 --> 00:28:34,919
example we all as security practitioners

785
00:28:34,919 --> 00:28:37,020
know how important it is to keep an up

786
00:28:37,020 --> 00:28:39,120
dependency like spring up to date but

787
00:28:39,120 --> 00:28:40,799
also you might not think about your

788
00:28:40,799 --> 00:28:42,240
testing framework

789
00:28:42,240 --> 00:28:44,220
and your organization as a security

790
00:28:44,220 --> 00:28:45,240
critical

791
00:28:45,240 --> 00:28:47,100
but if you want to run the latest

792
00:28:47,100 --> 00:28:49,140
version of spring in your Java

793
00:28:49,140 --> 00:28:51,299
application you have to update your test

794
00:28:51,299 --> 00:28:53,940
framework to use junit 5. because the

795
00:28:53,940 --> 00:28:55,980
latest version of spring

796
00:28:55,980 --> 00:28:58,919
will only run its tests on the latest

797
00:28:58,919 --> 00:29:01,500
version of junit and the problem is

798
00:29:01,500 --> 00:29:03,900
between junit 4 and junit 5. there were

799
00:29:03,900 --> 00:29:05,760
a lot of API breaking changes it

800
00:29:05,760 --> 00:29:07,080
requires a lot of work to rewrite your

801
00:29:07,080 --> 00:29:09,240
source code your tests to use this new

802
00:29:09,240 --> 00:29:10,740
version of junit

803
00:29:10,740 --> 00:29:12,779
and so there's a migration for that you

804
00:29:12,779 --> 00:29:14,220
may not think of your tests as security

805
00:29:14,220 --> 00:29:16,320
critical but turns out if you can't

806
00:29:16,320 --> 00:29:19,380
update a dependency sometimes it is

807
00:29:19,380 --> 00:29:21,659
and then it also supports both pull

808
00:29:21,659 --> 00:29:24,179
request generation across your open

809
00:29:24,179 --> 00:29:26,159
source repository across your corporate

810
00:29:26,159 --> 00:29:27,659
repository

811
00:29:27,659 --> 00:29:29,460
um uh as well

812
00:29:29,460 --> 00:29:31,200
um inside of yeah

813
00:29:31,200 --> 00:29:33,539
um and so if I want to generate pull

814
00:29:33,539 --> 00:29:35,880
requests this is for example temporary

815
00:29:35,880 --> 00:29:37,799
directory hijacking

816
00:29:37,799 --> 00:29:39,840
um you can say I want to create a pull

817
00:29:39,840 --> 00:29:41,340
request from a fork you can set the

818
00:29:41,340 --> 00:29:43,260
branch name the commit name the

819
00:29:43,260 --> 00:29:44,460
organization you're going to create the

820
00:29:44,460 --> 00:29:47,460
fork from uh set the pull request title

821
00:29:47,460 --> 00:29:50,340
the pull request body add your gpg keys

822
00:29:50,340 --> 00:29:53,039
yes into a SAS I know I know

823
00:29:53,039 --> 00:29:55,559
um but then you know it'll just go and

824
00:29:55,559 --> 00:29:57,960
generate the pull request for you

825
00:29:57,960 --> 00:30:00,120
um you know on your behalf and it'll

826
00:30:00,120 --> 00:30:03,179
look like it's coming from your account

827
00:30:03,179 --> 00:30:06,059
um and so that's what I did

828
00:30:06,059 --> 00:30:08,340
so the problem is though I told you

829
00:30:08,340 --> 00:30:12,299
earlier open Modern is uh indexing 7 000

830
00:30:12,299 --> 00:30:14,760
open source projects but they're more

831
00:30:14,760 --> 00:30:16,380
than seven thousand open source Java

832
00:30:16,380 --> 00:30:17,940
projects in the world in the world how

833
00:30:17,940 --> 00:30:20,340
do we find the other vulnerable projects

834
00:30:20,340 --> 00:30:23,159
and this is where codeql comes in

835
00:30:23,159 --> 00:30:25,799
codeql scans a hundred thousand hundreds

836
00:30:25,799 --> 00:30:28,080
of thousands of Open Source projects and

837
00:30:28,080 --> 00:30:31,500
over 35 000 open source Java projects

838
00:30:31,500 --> 00:30:34,080
and so you can write a code QR query

839
00:30:34,080 --> 00:30:37,020
to find vulnerabilities at scale and get

840
00:30:37,020 --> 00:30:38,580
a list of projects that you know to be

841
00:30:38,580 --> 00:30:39,960
vulnerable

842
00:30:39,960 --> 00:30:43,260
and then make a pull request to add that

843
00:30:43,260 --> 00:30:46,020
list of projects that are vulnerable to

844
00:30:46,020 --> 00:30:48,720
this list here which is open source it's

845
00:30:48,720 --> 00:30:51,120
a CSE file and then modern will begin to

846
00:30:51,120 --> 00:30:53,039
ingest those open resource repositories

847
00:30:53,039 --> 00:30:54,960
as well so that you can run your open

848
00:30:54,960 --> 00:30:56,760
source your your open rewrite recipe

849
00:30:56,760 --> 00:30:59,399
across those projects as well

850
00:30:59,399 --> 00:31:01,799
so finally let's go generate some open

851
00:31:01,799 --> 00:31:03,600
source pull requests

852
00:31:03,600 --> 00:31:06,120
that's what I did you know this is some

853
00:31:06,120 --> 00:31:08,399
you know it's flashy not really but you

854
00:31:08,399 --> 00:31:10,740
know like and so let's look at the

855
00:31:10,740 --> 00:31:12,240
statistics

856
00:31:12,240 --> 00:31:13,980
um for temporary directory hijacking I

857
00:31:13,980 --> 00:31:16,320
generated 64 pull requests partial past

858
00:31:16,320 --> 00:31:19,520
reversal 50 pull requests and zip slip

859
00:31:19,520 --> 00:31:22,020
152 pull requests

860
00:31:22,020 --> 00:31:25,140
think about how much time it would take

861
00:31:25,140 --> 00:31:26,580
to report each one of these

862
00:31:26,580 --> 00:31:30,000
vulnerabilities by hand to a project and

863
00:31:30,000 --> 00:31:31,620
wait for its standard 90 days closure

864
00:31:31,620 --> 00:31:33,419
timeline

865
00:31:33,419 --> 00:31:36,059
a lot of time saved

866
00:31:36,059 --> 00:31:37,380
um so new pull requests that I've

867
00:31:37,380 --> 00:31:40,620
generated this year alone over 600.

868
00:31:40,620 --> 00:31:42,299
and I've personally been involved in

869
00:31:42,299 --> 00:31:45,360
generating over 5 200 pull requests to

870
00:31:45,360 --> 00:31:47,279
my name

871
00:31:47,279 --> 00:31:49,740
um one unlucky project was the recipient

872
00:31:49,740 --> 00:31:52,740
of all three of the vulnerability fixes

873
00:31:52,740 --> 00:31:55,980
that I uh generated uh this year

874
00:31:55,980 --> 00:31:57,899
um yes

875
00:31:57,899 --> 00:31:59,820
and this is my contribution graph for

876
00:31:59,820 --> 00:32:01,080
this year

877
00:32:01,080 --> 00:32:03,480
um I've continued refining the recipes

878
00:32:03,480 --> 00:32:05,279
and generating more pull requests and

879
00:32:05,279 --> 00:32:06,659
refining the recipes and getting more

880
00:32:06,659 --> 00:32:08,460
projects indexed

881
00:32:08,460 --> 00:32:10,080
um yeah

882
00:32:10,080 --> 00:32:12,059
um so with the time that I have less

883
00:32:12,059 --> 00:32:14,880
left I want to discuss some of the best

884
00:32:14,880 --> 00:32:16,260
practices for both Polar Express

885
00:32:16,260 --> 00:32:18,120
generation

886
00:32:18,120 --> 00:32:20,100
messaging

887
00:32:20,100 --> 00:32:21,659
you are dealing with real people when

888
00:32:21,659 --> 00:32:23,460
you're doing this with this

889
00:32:23,460 --> 00:32:25,980
um there's this saying all software

890
00:32:25,980 --> 00:32:28,080
problems are people problems in Disguise

891
00:32:28,080 --> 00:32:30,720
and I have just thrown a software

892
00:32:30,720 --> 00:32:33,179
solution at a people problem these are

893
00:32:33,179 --> 00:32:35,220
vulnerabilities in real software with

894
00:32:35,220 --> 00:32:37,140
real maintainers who are owning this

895
00:32:37,140 --> 00:32:37,919
code

896
00:32:37,919 --> 00:32:39,600
so you do need to consider the human

897
00:32:39,600 --> 00:32:42,059
element around the vulnerabilities that

898
00:32:42,059 --> 00:32:44,700
you're disclosing in this way

899
00:32:44,700 --> 00:32:46,919
um I include in my disclosures the

900
00:32:46,919 --> 00:32:49,260
vulnerability details like what the

901
00:32:49,260 --> 00:32:52,380
impact is how I fixed it why this fixes

902
00:32:52,380 --> 00:32:55,919
it but also how to opt out

903
00:32:55,919 --> 00:32:57,480
potentially if you don't want to receive

904
00:32:57,480 --> 00:32:59,760
more of these things

905
00:32:59,760 --> 00:33:02,760
and then some simpler lessons

906
00:33:02,760 --> 00:33:06,299
lesson one sign off on all your commits

907
00:33:06,299 --> 00:33:07,799
um this is what a sign off looks like

908
00:33:07,799 --> 00:33:10,200
inside of a commit message

909
00:33:10,200 --> 00:33:12,000
um and why would you want to do this

910
00:33:12,000 --> 00:33:14,820
well there's a bunch of lawsuits in open

911
00:33:14,820 --> 00:33:20,158
source a few years ago tldr lawyers

912
00:33:20,360 --> 00:33:22,559
uh otherwise you'll get your pull

913
00:33:22,559 --> 00:33:24,059
requests rejected by evil dragon

914
00:33:24,059 --> 00:33:26,840
bureaucrats

915
00:33:27,720 --> 00:33:30,179
um lesson number two be a good commit is

916
00:33:30,179 --> 00:33:33,360
in gpg sign your commits

917
00:33:33,360 --> 00:33:34,940
um that's where you get the verified

918
00:33:34,940 --> 00:33:38,159
logo in the bottom in the corner

919
00:33:38,159 --> 00:33:40,080
um or you'll end up like Linus Torvalds

920
00:33:40,080 --> 00:33:41,399
who's been impersonated on GitHub

921
00:33:41,399 --> 00:33:43,140
multiple times

922
00:33:43,140 --> 00:33:43,860
um

923
00:33:43,860 --> 00:33:45,779
so yeah

924
00:33:45,779 --> 00:33:48,240
um let's get is insecure by default not

925
00:33:48,240 --> 00:33:51,200
Linus yeah anyways um

926
00:33:51,200 --> 00:33:54,539
seacom it's a commit format for your

927
00:33:54,539 --> 00:33:56,220
commits uh that are secure that are

928
00:33:56,220 --> 00:33:57,600
fixing security vulnerabilities so if

929
00:33:57,600 --> 00:34:00,240
you want to put in your commit message a

930
00:34:00,240 --> 00:34:01,919
standardized format for the

931
00:34:01,919 --> 00:34:03,720
vulnerabilities you're fixing go look at

932
00:34:03,720 --> 00:34:05,039
ccom I don't have the time to dive into

933
00:34:05,039 --> 00:34:06,600
it right now but that's that's something

934
00:34:06,600 --> 00:34:08,820
to look into

935
00:34:08,820 --> 00:34:11,760
um Lesson Four there are risks to using

936
00:34:11,760 --> 00:34:14,339
your personal GitHub account

937
00:34:14,339 --> 00:34:16,679
um has anybody here buy a show of hands

938
00:34:16,679 --> 00:34:19,440
familiar with github's angry unicorn the

939
00:34:19,440 --> 00:34:21,359
one that like when GitHub crashes you

940
00:34:21,359 --> 00:34:23,339
get that error

941
00:34:23,339 --> 00:34:26,280
yeah I'm getting some nods yay okay

942
00:34:26,280 --> 00:34:28,339
um

943
00:34:28,739 --> 00:34:32,239
this is the angry unicorn

944
00:34:32,580 --> 00:34:34,379
this is my get up profile for most of

945
00:34:34,379 --> 00:34:35,940
2020.

946
00:34:35,940 --> 00:34:39,239
I broke my GitHub account doing this

947
00:34:39,239 --> 00:34:44,099
um so while I do recommend there is this

948
00:34:44,099 --> 00:34:45,179
risk

949
00:34:45,179 --> 00:34:46,859
I do actually recommend using your

950
00:34:46,859 --> 00:34:48,719
personal GitHub account and the reason

951
00:34:48,719 --> 00:34:49,918
that I recommend using your personal

952
00:34:49,918 --> 00:34:52,320
GitHub account is because it looks like

953
00:34:52,320 --> 00:34:54,060
it's coming from a real person instead

954
00:34:54,060 --> 00:34:56,760
of an organization or a bot and the

955
00:34:56,760 --> 00:34:58,740
maintainer is more likely to interact

956
00:34:58,740 --> 00:35:01,980
with you on a personal level

957
00:35:01,980 --> 00:35:04,920
um and feel less threatened if it's not

958
00:35:04,920 --> 00:35:06,420
coming from a bot account if it's coming

959
00:35:06,420 --> 00:35:08,520
from a real person with positive

960
00:35:08,520 --> 00:35:10,740
intentions and then also when they

961
00:35:10,740 --> 00:35:12,420
respond to those things I can respond

962
00:35:12,420 --> 00:35:13,920
back and say no no I am a real person

963
00:35:13,920 --> 00:35:16,440
this fixes the vulnerability and then if

964
00:35:16,440 --> 00:35:17,760
they merge it I can say hey do you need

965
00:35:17,760 --> 00:35:19,079
assistance with vulnerability disclosure

966
00:35:19,079 --> 00:35:21,119
do you need a cve I can put you in touch

967
00:35:21,119 --> 00:35:23,460
with Snick I can do it you can do it how

968
00:35:23,460 --> 00:35:24,599
do you want to get a voter how do you

969
00:35:24,599 --> 00:35:26,220
want to get this information out to your

970
00:35:26,220 --> 00:35:29,099
maintainers or to your to your users

971
00:35:29,099 --> 00:35:32,099
lesson five coordinate with GitHub

972
00:35:32,099 --> 00:35:34,140
I reached out to GitHub before I did

973
00:35:34,140 --> 00:35:35,339
this and let them know that I was doing

974
00:35:35,339 --> 00:35:37,800
this this is the GitHub security lab uh

975
00:35:37,800 --> 00:35:39,960
email address reach out to them and let

976
00:35:39,960 --> 00:35:40,859
them know you're going to do this so you

977
00:35:40,859 --> 00:35:42,960
don't get banned also so that they know

978
00:35:42,960 --> 00:35:45,119
what you're doing and can like run air

979
00:35:45,119 --> 00:35:47,280
support for you

980
00:35:47,280 --> 00:35:50,700
and then consider the implications

981
00:35:50,700 --> 00:35:53,940
shortly after I began this campaign I

982
00:35:53,940 --> 00:35:56,640
got this issue open against my security

983
00:35:56,640 --> 00:35:58,859
research GitHub account

984
00:35:58,859 --> 00:36:01,560
I are sorry get a get a repository

985
00:36:01,560 --> 00:36:03,960
J lights you slash security Dash

986
00:36:03,960 --> 00:36:08,220
research is this responsible disclosure

987
00:36:08,220 --> 00:36:10,140
and I use the more nuanced term

988
00:36:10,140 --> 00:36:12,240
coordinated disclosure but regardless of

989
00:36:12,240 --> 00:36:15,240
what you call it the answer is no this

990
00:36:15,240 --> 00:36:16,800
is full disclosure of a security

991
00:36:16,800 --> 00:36:19,560
vulnerability in an open source project

992
00:36:19,560 --> 00:36:21,720
that does not have a patch

993
00:36:21,720 --> 00:36:24,780
your odang a maintainer a project an

994
00:36:24,780 --> 00:36:26,880
ecosystem and so you need to consider

995
00:36:26,880 --> 00:36:28,859
the implications of that

996
00:36:28,859 --> 00:36:32,280
however the alternative in many cases is

997
00:36:32,280 --> 00:36:34,020
no disclosure at all

998
00:36:34,020 --> 00:36:36,240
because

999
00:36:36,240 --> 00:36:38,460
I don't have the time to go to every

1000
00:36:38,460 --> 00:36:40,560
single small project to report these

1001
00:36:40,560 --> 00:36:42,000
vulnerabilities individually there's

1002
00:36:42,000 --> 00:36:44,880
just not enough time in a day

1003
00:36:44,880 --> 00:36:46,280
and so

1004
00:36:46,280 --> 00:36:49,500
I've made this decision because I

1005
00:36:49,500 --> 00:36:52,020
believe the risks outweigh the potential

1006
00:36:52,020 --> 00:36:53,940
Rewards

1007
00:36:53,940 --> 00:36:55,980
fixed vulnerabilities in open source

1008
00:36:55,980 --> 00:36:57,060
software

1009
00:36:57,060 --> 00:36:59,460
so in conclusion

1010
00:36:59,460 --> 00:37:01,560
as security researchers

1011
00:37:01,560 --> 00:37:03,240
I believe we have an obligation to

1012
00:37:03,240 --> 00:37:04,920
society

1013
00:37:04,920 --> 00:37:06,540
we know these vulnerabilities are out

1014
00:37:06,540 --> 00:37:08,640
there we've written them up in pen test

1015
00:37:08,640 --> 00:37:10,380
reports we've been on the receiving end

1016
00:37:10,380 --> 00:37:12,599
of them we've seen them in source code

1017
00:37:12,599 --> 00:37:14,820
that we've audited we know that they're

1018
00:37:14,820 --> 00:37:17,040
out there we understand how they work

1019
00:37:17,040 --> 00:37:19,380
I'm going to give you a hint most

1020
00:37:19,380 --> 00:37:21,359
software developers don't watch black

1021
00:37:21,359 --> 00:37:23,940
hat talks don't watch Defcon talks some

1022
00:37:23,940 --> 00:37:27,119
of them do a lot of them do not so we

1023
00:37:27,119 --> 00:37:28,140
know how these vulnerabilities

1024
00:37:28,140 --> 00:37:30,480
vulnerabilities work and I believe we

1025
00:37:30,480 --> 00:37:32,940
have an obligation to the society out

1026
00:37:32,940 --> 00:37:34,560
there to use our knowledge of math

1027
00:37:34,560 --> 00:37:35,940
science technology to fix these

1028
00:37:35,940 --> 00:37:37,500
vulnerabilities at scale

1029
00:37:37,500 --> 00:37:39,240
there's the statistic that GitHub has

1030
00:37:39,240 --> 00:37:41,820
for every 500 developers you've won the

1031
00:37:41,820 --> 00:37:44,160
security researcher we're heavily

1032
00:37:44,160 --> 00:37:47,760
outnumbered in this industry

1033
00:37:47,760 --> 00:37:50,880
and so I believe that bulk polar Crush

1034
00:37:50,880 --> 00:37:52,680
generation is one of the best ways for

1035
00:37:52,680 --> 00:37:55,859
us to scale our knowledge of security

1036
00:37:55,859 --> 00:37:57,720
to fix these vulnerabilities that plague

1037
00:37:57,720 --> 00:38:00,660
the industry writ large

1038
00:38:00,660 --> 00:38:02,040
and with that I want to leave you with

1039
00:38:02,040 --> 00:38:03,540
one final quote

1040
00:38:03,540 --> 00:38:05,579
it's from Dan Kaminsky it's on his

1041
00:38:05,579 --> 00:38:09,000
Twitter profile it's there to this day

1042
00:38:09,000 --> 00:38:10,680
we can fix it

1043
00:38:10,680 --> 00:38:13,800
we have the technology okay we need to

1044
00:38:13,800 --> 00:38:15,660
create the technology all right the

1045
00:38:15,660 --> 00:38:16,800
policy guys are mucking with the

1046
00:38:16,800 --> 00:38:17,700
technology

1047
00:38:17,700 --> 00:38:19,320
relax

1048
00:38:19,320 --> 00:38:22,160
we're on it

1049
00:38:26,880 --> 00:38:30,599
so some final notes learn code ql it's

1050
00:38:30,599 --> 00:38:32,099
really powerful you can find

1051
00:38:32,099 --> 00:38:33,900
vulnerabilities at scale contribute to

1052
00:38:33,900 --> 00:38:35,940
open rewrite join the GitHub security

1053
00:38:35,940 --> 00:38:37,260
lab

1054
00:38:37,260 --> 00:38:39,240
um and openreact slack channels they're

1055
00:38:39,240 --> 00:38:40,619
both open

1056
00:38:40,619 --> 00:38:42,300
um and then also if you're interested

1057
00:38:42,300 --> 00:38:44,880
open source security at large across the

1058
00:38:44,880 --> 00:38:46,859
industry there's the open source

1059
00:38:46,859 --> 00:38:48,599
security Foundation which is a part of

1060
00:38:48,599 --> 00:38:50,400
the Linux foundation and they're having

1061
00:38:50,400 --> 00:38:52,320
open meetings there's an open calendar

1062
00:38:52,320 --> 00:38:54,119
you can join their meetings to discuss

1063
00:38:54,119 --> 00:38:56,280
open source security vulnerabilities and

1064
00:38:56,280 --> 00:38:59,400
open source at large securing it just by

1065
00:38:59,400 --> 00:39:00,960
joining their meetings

1066
00:39:00,960 --> 00:39:03,119
um and with that I want to thank human

1067
00:39:03,119 --> 00:39:05,940
my sponsor modern uh for working with me

1068
00:39:05,940 --> 00:39:07,200
on this project they've been awesome

1069
00:39:07,200 --> 00:39:09,060
Lydia Giuliano the black cat speaker

1070
00:39:09,060 --> 00:39:11,640
coach that I work with and Sham uh my

1071
00:39:11,640 --> 00:39:13,500
intern who created some of the graphics

1072
00:39:13,500 --> 00:39:15,960
for control flow that you saw earlier

1073
00:39:15,960 --> 00:39:17,190
um thank you

1074
00:39:17,190 --> 00:39:22,490
[Applause]

1075
00:39:22,490 --> 00:39:27,939
[Music]

