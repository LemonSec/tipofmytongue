1
00:00:00,850 --> 00:00:07,310
[Music]

2
00:00:11,000 --> 00:00:14,400
thank you hi

3
00:00:14,400 --> 00:00:16,859
thank you very much I'm really happy and

4
00:00:16,859 --> 00:00:19,080
glad to be here

5
00:00:19,080 --> 00:00:21,660
first one one word regarding the fact

6
00:00:21,660 --> 00:00:23,640
that I've not been present so much in

7
00:00:23,640 --> 00:00:25,920
Italian conferences and being Italian is

8
00:00:25,920 --> 00:00:28,080
actually really an honor for me to be

9
00:00:28,080 --> 00:00:29,880
here thank you so let's go ahead

10
00:00:29,880 --> 00:00:31,679
directly with glitching devices for code

11
00:00:31,679 --> 00:00:33,719
execution and the goals of this

12
00:00:33,719 --> 00:00:37,320
presentation are discuss how fi attacks

13
00:00:37,320 --> 00:00:38,820
fault injection attacks we're going to

14
00:00:38,820 --> 00:00:41,399
use fi along with the presentation uh

15
00:00:41,399 --> 00:00:43,620
for indicating fault injection they can

16
00:00:43,620 --> 00:00:45,480
be used to gain arbitrary code execution

17
00:00:45,480 --> 00:00:47,340
on devices actually on any Target which

18
00:00:47,340 --> 00:00:48,840
is glitchable what we are focusing here

19
00:00:48,840 --> 00:00:50,039
on devices

20
00:00:50,039 --> 00:00:51,840
and this can be done regardless of the

21
00:00:51,840 --> 00:00:54,120
CPU architectures and even in absence of

22
00:00:54,120 --> 00:00:56,340
soft vulnerabilities

23
00:00:56,340 --> 00:00:58,140
we are going also to show our

24
00:00:58,140 --> 00:00:59,820
software-based counter measures because

25
00:00:59,820 --> 00:01:00,899
you know you know you have fault

26
00:01:00,899 --> 00:01:02,760
injection attacks the industry in

27
00:01:02,760 --> 00:01:05,580
Academia have developed countermeasures

28
00:01:05,580 --> 00:01:07,320
against these attacks there are Hardware

29
00:01:07,320 --> 00:01:09,420
based and software-based ones we are

30
00:01:09,420 --> 00:01:12,119
going to show how with new techniques we

31
00:01:12,119 --> 00:01:14,100
can actually bypass the software-based

32
00:01:14,100 --> 00:01:15,720
counter measures

33
00:01:15,720 --> 00:01:17,820
we are going also to discuss how such

34
00:01:17,820 --> 00:01:20,900
techniques may allow to loosen timing

35
00:01:20,900 --> 00:01:22,979
requirements so one of the user

36
00:01:22,979 --> 00:01:24,720
requirements is that that you hear that

37
00:01:24,720 --> 00:01:26,340
fault injection attacks needs to be very

38
00:01:26,340 --> 00:01:28,320
precise you need to Target that

39
00:01:28,320 --> 00:01:30,240
instruction you need to be a very good

40
00:01:30,240 --> 00:01:31,979
time to have a good timing and a good

41
00:01:31,979 --> 00:01:33,840
synchronization instrument Target we're

42
00:01:33,840 --> 00:01:36,180
going to discuss how this can be

43
00:01:36,180 --> 00:01:39,900
loosened to the point that your trigger

44
00:01:39,900 --> 00:01:41,939
may actually not be very precise

45
00:01:41,939 --> 00:01:43,860
sometimes they don't even exist that's

46
00:01:43,860 --> 00:01:46,860
why just a bit provocative I'm talking

47
00:01:46,860 --> 00:01:50,159
about quasi triggerless attacks

48
00:01:50,159 --> 00:01:52,619
so basically we I hope that's this kind

49
00:01:52,619 --> 00:01:54,540
of reflection can contribute to the

50
00:01:54,540 --> 00:01:55,860
field and to the reflection of everybody

51
00:01:55,860 --> 00:01:58,320
doing fault injection attacks or any

52
00:01:58,320 --> 00:02:00,060
hardware security

53
00:02:00,060 --> 00:02:01,680
so the agenda here is that we're talking

54
00:02:01,680 --> 00:02:03,840
about the foundation

55
00:02:03,840 --> 00:02:05,219
um uh some introduction which is

56
00:02:05,219 --> 00:02:07,380
functional to what we need to discuss

57
00:02:07,380 --> 00:02:09,000
then we're trying to give a bit of

58
00:02:09,000 --> 00:02:11,940
systematization to what we we see and

59
00:02:11,940 --> 00:02:14,160
what we see often discussed trying to

60
00:02:14,160 --> 00:02:16,980
put some terminology and concept in the

61
00:02:16,980 --> 00:02:18,720
right place we are going to discuss

62
00:02:18,720 --> 00:02:21,120
which are these counter measures and

63
00:02:21,120 --> 00:02:23,340
also how it's possible to achieve

64
00:02:23,340 --> 00:02:26,220
program counter control and also by

65
00:02:26,220 --> 00:02:29,280
busting the countermeasure while also or

66
00:02:29,280 --> 00:02:31,080
right into the point that you may not

67
00:02:31,080 --> 00:02:33,480
need even a precise trigger anymore

68
00:02:33,480 --> 00:02:35,040
so let's dive directly into the

69
00:02:35,040 --> 00:02:35,940
foundation

70
00:02:35,940 --> 00:02:37,260
well the fault injection is not

71
00:02:37,260 --> 00:02:39,060
something that we invented actually

72
00:02:39,060 --> 00:02:41,819
nature invented that so the first report

73
00:02:41,819 --> 00:02:44,519
that we actually seized in 1979 were

74
00:02:44,519 --> 00:02:46,560
fault injection like cosmic rays have

75
00:02:46,560 --> 00:02:50,819
had a proven effect which were otherwise

76
00:02:50,819 --> 00:02:54,780
unexplainable on memories so this has

77
00:02:54,780 --> 00:02:56,879
been actually proven

78
00:02:56,879 --> 00:02:59,099
these are peer-reviewed scientific

79
00:02:59,099 --> 00:03:00,780
research by the way so it's not

80
00:03:00,780 --> 00:03:02,400
something that's it's really happen and

81
00:03:02,400 --> 00:03:03,440
proven

82
00:03:03,440 --> 00:03:06,660
uh also we see radiation being able to

83
00:03:06,660 --> 00:03:08,340
do that it's not something that we have

84
00:03:08,340 --> 00:03:10,080
created what we have created actually

85
00:03:10,080 --> 00:03:12,959
are the attacks that may leverage such

86
00:03:12,959 --> 00:03:15,900
such effects so the first known attacks

87
00:03:15,900 --> 00:03:17,519
at least known to me

88
00:03:17,519 --> 00:03:20,940
in terms of faulty injection was uh

89
00:03:20,940 --> 00:03:24,060
defined a way of breaking another state

90
00:03:24,060 --> 00:03:25,980
signature so if you actually perform

91
00:03:25,980 --> 00:03:28,860
your essay signature by using CFT which

92
00:03:28,860 --> 00:03:30,260
is actually the fastest way of

93
00:03:30,260 --> 00:03:32,580
performing a signature and you inject

94
00:03:32,580 --> 00:03:34,019
one single fold

95
00:03:34,019 --> 00:03:36,000
you just need a good signature and a

96
00:03:36,000 --> 00:03:38,040
wrong signature you get together and you

97
00:03:38,040 --> 00:03:39,360
get the private key

98
00:03:39,360 --> 00:03:42,480
that's what you need a single good fault

99
00:03:42,480 --> 00:03:44,900
this actually has been uh

100
00:03:44,900 --> 00:03:47,580
discussed and proven and demonstrated in

101
00:03:47,580 --> 00:03:50,040
1996 in terms of Academia so these

102
00:03:50,040 --> 00:03:52,680
attacks actually has been performed and

103
00:03:52,680 --> 00:03:55,019
this is also called umber attack so this

104
00:03:55,019 --> 00:03:57,780
shows that the Academia already in 1996

105
00:03:57,780 --> 00:03:59,819
had already figured out way of using

106
00:03:59,819 --> 00:04:00,900
false

107
00:04:00,900 --> 00:04:02,940
not only even attackers have used

108
00:04:02,940 --> 00:04:04,799
figured ways of using this

109
00:04:04,799 --> 00:04:06,840
post-injection attacks you may remember

110
00:04:06,840 --> 00:04:08,580
the end of the 90s

111
00:04:08,580 --> 00:04:10,400
some of you guys follow your grayers

112
00:04:10,400 --> 00:04:13,319
let's say using fault injection for

113
00:04:13,319 --> 00:04:15,840
using non-loopers so yeah this Market

114
00:04:15,840 --> 00:04:19,798
which was used for a payment of ADB then

115
00:04:19,798 --> 00:04:22,740
after some point in time or after some

116
00:04:22,740 --> 00:04:24,660
attacks these actually went to infinite

117
00:04:24,660 --> 00:04:26,580
Loop and using full injection you get

118
00:04:26,580 --> 00:04:28,440
them them out of the infinite Loop

119
00:04:28,440 --> 00:04:30,780
that's why they are called unloopers

120
00:04:30,780 --> 00:04:33,120
we was used for clock literally and was

121
00:04:33,120 --> 00:04:35,280
for Reviving haga smart card jump out on

122
00:04:35,280 --> 00:04:36,660
an infinite Loop

123
00:04:36,660 --> 00:04:38,699
so the traditional attacks are always

124
00:04:38,699 --> 00:04:42,360
aimed to either break some crypto so

125
00:04:42,360 --> 00:04:44,880
changing some data or bypassing checks

126
00:04:44,880 --> 00:04:48,000
this has been you the usual way of using

127
00:04:48,000 --> 00:04:49,740
faulty injection attacks I think you are

128
00:04:49,740 --> 00:04:51,419
more or less familiars I see people not

129
00:04:51,419 --> 00:04:53,340
doing and really happy about it

130
00:04:53,340 --> 00:04:56,160
so if you think about let's say the

131
00:04:56,160 --> 00:04:58,500
usual way of bypassing checks for

132
00:04:58,500 --> 00:05:01,080
bypassing as you reboot so this is the

133
00:05:01,080 --> 00:05:03,960
just a sample code of your book what you

134
00:05:03,960 --> 00:05:07,020
see there is that you have the uh the

135
00:05:07,020 --> 00:05:09,900
seal Roots actually loads the boot stage

136
00:05:09,900 --> 00:05:12,660
to be verified into memory and it loads

137
00:05:12,660 --> 00:05:14,820
to an address it's just image address

138
00:05:14,820 --> 00:05:16,320
over there

139
00:05:16,320 --> 00:05:18,180
then basically it actually loads the

140
00:05:18,180 --> 00:05:19,199
signature

141
00:05:19,199 --> 00:05:22,380
in order to into memory and then this

142
00:05:22,380 --> 00:05:24,539
signature is verified I will not go into

143
00:05:24,539 --> 00:05:26,280
the details but this involves more or

144
00:05:26,280 --> 00:05:30,559
less computing the hash from the stage

145
00:05:34,280 --> 00:05:36,720
that's more or less what it entails to

146
00:05:36,720 --> 00:05:39,539
verify the signature in general if this

147
00:05:39,539 --> 00:05:42,060
is wrong you actually reset the chip if

148
00:05:42,060 --> 00:05:43,860
this is correct you progress to the

149
00:05:43,860 --> 00:05:45,660
stage which has been verified

150
00:05:45,660 --> 00:05:46,979
of course I mean you need to have the

151
00:05:46,979 --> 00:05:48,360
private key in order to produce that

152
00:05:48,360 --> 00:05:50,160
signature so in general if you have a

153
00:05:50,160 --> 00:05:51,780
good process you would not be able to

154
00:05:51,780 --> 00:05:53,820
bypass it normally unless there are

155
00:05:53,820 --> 00:05:56,280
logical vulnerabilities

156
00:05:56,280 --> 00:05:59,100
so one of the usual attack of fault

157
00:05:59,100 --> 00:06:02,039
injection which are applied to for

158
00:06:02,039 --> 00:06:06,000
example but in any case to checks

159
00:06:06,000 --> 00:06:08,759
are you load the malicious boot stage of

160
00:06:08,759 --> 00:06:11,340
course the signature which will be still

161
00:06:11,340 --> 00:06:13,919
loaded will not match anymore because

162
00:06:13,919 --> 00:06:15,840
you don't have the priority so this

163
00:06:15,840 --> 00:06:18,840
verification actually would fail but if

164
00:06:18,840 --> 00:06:21,539
you actually usually the the approach is

165
00:06:21,539 --> 00:06:25,020
to glitch this verify signature in order

166
00:06:25,020 --> 00:06:28,139
to execute the image even if the boot

167
00:06:28,139 --> 00:06:30,500
stage is wrong so this is the typical

168
00:06:30,500 --> 00:06:33,900
textbook attack for a sugaboot okay so

169
00:06:33,900 --> 00:06:36,180
basically nothing special over here and

170
00:06:36,180 --> 00:06:38,340
this has been proven several times in

171
00:06:38,340 --> 00:06:40,199
the last 10 and 15 years so this is not

172
00:06:40,199 --> 00:06:43,380
not even use anymore news anymore this

173
00:06:43,380 --> 00:06:45,840
is where we start from though

174
00:06:45,840 --> 00:06:48,600
why does it work well the typical

175
00:06:48,600 --> 00:06:51,720
description why does work is that you

176
00:06:51,720 --> 00:06:54,199
are skipping instructions

177
00:06:54,199 --> 00:06:58,199
Asian instructions keeping between

178
00:06:58,199 --> 00:06:59,280
quotes

179
00:06:59,280 --> 00:07:01,139
because the glitches consumed to skip

180
00:07:01,139 --> 00:07:03,240
instruction regardless if this is true

181
00:07:03,240 --> 00:07:05,819
this is the effect that you see so you

182
00:07:05,819 --> 00:07:07,440
see this effect so it's actually

183
00:07:07,440 --> 00:07:09,720
legitimate to call it please like to

184
00:07:09,720 --> 00:07:12,479
skip video then we can always discuss if

185
00:07:12,479 --> 00:07:14,340
this is really happening that way or not

186
00:07:14,340 --> 00:07:16,680
but that's another Point what you see is

187
00:07:16,680 --> 00:07:19,139
that this structure is being skipped a

188
00:07:19,139 --> 00:07:21,720
conditional instruction skipped is then

189
00:07:21,720 --> 00:07:25,199
not executed so this means that that if

190
00:07:25,199 --> 00:07:27,900
would not be checked properly and the

191
00:07:27,900 --> 00:07:29,819
execution will continue on

192
00:07:29,819 --> 00:07:32,460
and this will lead you in many cases to

193
00:07:32,460 --> 00:07:34,620
execute the image the wrong image you

194
00:07:34,620 --> 00:07:35,880
have just loaded

195
00:07:35,880 --> 00:07:37,740
so this is the description that you

196
00:07:37,740 --> 00:07:39,840
usually you will find in Academia

197
00:07:39,840 --> 00:07:41,160
industry so

198
00:07:41,160 --> 00:07:44,340
I would say an estimate 80 90 of the

199
00:07:44,340 --> 00:07:48,060
papers that you see outside or talks or

200
00:07:48,060 --> 00:07:50,580
a blog posts that discuss about

201
00:07:50,580 --> 00:07:52,039
glitching

202
00:07:52,039 --> 00:07:54,840
basically they refer to you skip some

203
00:07:54,840 --> 00:07:57,840
instruction and you go ahead

204
00:07:57,840 --> 00:08:00,599
now this means that the attack modeling

205
00:08:00,599 --> 00:08:03,120
has been dominated for full injection as

206
00:08:03,120 --> 00:08:07,099
one moment I need to fix

207
00:08:08,759 --> 00:08:10,740
I hope this is better

208
00:08:10,740 --> 00:08:13,319
so these dominated attack modeling for

209
00:08:13,319 --> 00:08:16,259
fault injection for the last 30 years

210
00:08:16,259 --> 00:08:18,720
so this means that with this in mind we

211
00:08:18,720 --> 00:08:20,300
have also designed

212
00:08:20,300 --> 00:08:23,759
uh countermeasure in general along this

213
00:08:23,759 --> 00:08:26,879
idea this was the first fault model

214
00:08:26,879 --> 00:08:28,800
so when you actually need to execute an

215
00:08:28,800 --> 00:08:30,840
attack what do you need you need to skip

216
00:08:30,840 --> 00:08:33,000
the destruction so this requires

217
00:08:33,000 --> 00:08:35,640
accurate timing really that one or

218
00:08:35,640 --> 00:08:36,958
around that

219
00:08:36,958 --> 00:08:38,640
this means that you need to synchronize

220
00:08:38,640 --> 00:08:39,659
with the target

221
00:08:39,659 --> 00:08:41,399
because you need to make sure that

222
00:08:41,399 --> 00:08:44,659
you're hitting exactly that one

223
00:08:44,820 --> 00:08:46,620
actually this attack is usually executed

224
00:08:46,620 --> 00:08:49,980
blindly so this means that you don't

225
00:08:49,980 --> 00:08:52,200
assume that you have some type of fault

226
00:08:52,200 --> 00:08:54,240
or another you just say hey let me see

227
00:08:54,240 --> 00:08:56,640
if this actually bypasses you just load

228
00:08:56,640 --> 00:08:58,860
the bootloader it just glitches

229
00:08:58,860 --> 00:09:01,200
just send glitches around just let it go

230
00:09:01,200 --> 00:09:04,320
for a hours days weeks until it succeeds

231
00:09:04,320 --> 00:09:08,040
and then it succeeds usually

232
00:09:08,040 --> 00:09:10,440
I mean the way we this is what we call

233
00:09:10,440 --> 00:09:12,240
this called glitch and prey

234
00:09:12,240 --> 00:09:14,100
and it works it's fine there's nothing

235
00:09:14,100 --> 00:09:15,959
diminutive to that we're just saying

236
00:09:15,959 --> 00:09:19,620
that there is no attack not so much of

237
00:09:19,620 --> 00:09:23,459
an attack uh design and strategy

238
00:09:23,459 --> 00:09:25,920
so basically this is an example of our

239
00:09:25,920 --> 00:09:29,580
attack that we uh did on esp32 but we

240
00:09:29,580 --> 00:09:30,720
have been doing this on many devices

241
00:09:30,720 --> 00:09:32,760
it's just this is public research we can

242
00:09:32,760 --> 00:09:33,899
actually show

243
00:09:33,899 --> 00:09:37,320
so you can see that in these in the

244
00:09:37,320 --> 00:09:38,880
upper part the bootload risk of it

245
00:09:38,880 --> 00:09:41,160
Western what you are seeing is the chip

246
00:09:41,160 --> 00:09:43,080
selector of the SPI Flash

247
00:09:43,080 --> 00:09:45,839
when you read from flesh this activity

248
00:09:45,839 --> 00:09:47,940
from flesh so we are coping from flesh

249
00:09:47,940 --> 00:09:49,860
that pain is active it goes up and down

250
00:09:49,860 --> 00:09:51,660
so this means that this place is being

251
00:09:51,660 --> 00:09:54,540
used so by tracking that pin when now

252
00:09:54,540 --> 00:09:56,160
when the flesh is being used and we know

253
00:09:56,160 --> 00:09:58,080
that when bootloader is actually copied

254
00:09:58,080 --> 00:09:59,640
into a swamp

255
00:09:59,640 --> 00:10:02,279
and this is why we see that kind of

256
00:10:02,279 --> 00:10:04,260
those kind of patterns the flesh is

257
00:10:04,260 --> 00:10:07,320
being read is active after the bootload

258
00:10:07,320 --> 00:10:09,779
the scope into estrum at the end that is

259
00:10:09,779 --> 00:10:11,399
very likely the certificate the

260
00:10:11,399 --> 00:10:13,500
verification you cannot verify a

261
00:10:13,500 --> 00:10:16,920
bootloader until it's fully in memory

262
00:10:16,920 --> 00:10:19,500
so what you see here is also something

263
00:10:19,500 --> 00:10:20,760
trigger

264
00:10:20,760 --> 00:10:22,560
triggers you trigger lower trigger

265
00:10:22,560 --> 00:10:25,080
height so we wait for a bit in order to

266
00:10:25,080 --> 00:10:28,560
wait for a gap in the middle and then at

267
00:10:28,560 --> 00:10:31,140
that point in time we just string on the

268
00:10:31,140 --> 00:10:33,720
first Rising Edge and this is our

269
00:10:33,720 --> 00:10:35,399
trigger so we are synchronized with

270
00:10:35,399 --> 00:10:37,380
reading

271
00:10:37,380 --> 00:10:39,060
so basically we use Flash communication

272
00:10:39,060 --> 00:10:41,220
for synchronization we use the signal

273
00:10:41,220 --> 00:10:44,720
that tells us okay this is being loaded

274
00:10:44,720 --> 00:10:47,519
now in order to bypass it we need to

275
00:10:47,519 --> 00:10:50,160
glitch that instruction so at the end

276
00:10:50,160 --> 00:10:52,500
you know that bootloader is being loaded

277
00:10:52,500 --> 00:10:54,660
into restaurant you want to place that

278
00:10:54,660 --> 00:10:57,600
if so it's very likely at the end of

279
00:10:57,600 --> 00:10:58,980
that process

280
00:10:58,980 --> 00:11:01,680
so when the loading is finished we just

281
00:11:01,680 --> 00:11:03,540
start glitching around there glitch and

282
00:11:03,540 --> 00:11:06,360
pray we don't know what's happening go

283
00:11:06,360 --> 00:11:08,519
see you in three days if you succeeded

284
00:11:08,519 --> 00:11:11,300
it succeeded

285
00:11:11,399 --> 00:11:14,519
Mr accomplished well actually this was a

286
00:11:14,519 --> 00:11:16,200
pretty easy to do but in general your

287
00:11:16,200 --> 00:11:17,880
approach is that you glitch somewhere

288
00:11:17,880 --> 00:11:20,880
after the bootloader is copied it's more

289
00:11:20,880 --> 00:11:23,160
or less around there

290
00:11:23,160 --> 00:11:25,680
so there is no control whatsoever is it

291
00:11:25,680 --> 00:11:27,540
just Randomness and luck is this all

292
00:11:27,540 --> 00:11:29,279
everything that we can do

293
00:11:29,279 --> 00:11:31,440
well if you just stop at doing this and

294
00:11:31,440 --> 00:11:34,440
trying it it's pretty much that

295
00:11:34,440 --> 00:11:36,540
if you start thinking about how things

296
00:11:36,540 --> 00:11:38,220
work and that's what we are going to

297
00:11:38,220 --> 00:11:40,740
progress and you actually try to do some

298
00:11:40,740 --> 00:11:42,839
systematization of the concept but I

299
00:11:42,839 --> 00:11:45,300
think we can actually do some uh we will

300
00:11:45,300 --> 00:11:46,560
move forward

301
00:11:46,560 --> 00:11:48,180
so when you have a fold

302
00:11:48,180 --> 00:11:50,040
why does this fall happen happens

303
00:11:50,040 --> 00:11:51,660
because of physics

304
00:11:51,660 --> 00:11:54,420
you're putting the the device in an

305
00:11:54,420 --> 00:11:56,940
environment that it starts misbehaving

306
00:11:56,940 --> 00:11:58,680
while still functioning

307
00:11:58,680 --> 00:12:01,140
so it's not completely stopped but it's

308
00:12:01,140 --> 00:12:02,940
not completely functioning as intended

309
00:12:02,940 --> 00:12:05,579
so this means that there is a gray area

310
00:12:05,579 --> 00:12:08,100
where there are effects that allows it

311
00:12:08,100 --> 00:12:11,700
to misbe while still keeping on working

312
00:12:11,700 --> 00:12:13,800
now this these effects happen at the

313
00:12:13,800 --> 00:12:15,959
physical levels physics it might be

314
00:12:15,959 --> 00:12:18,120
let's say uh we're not going through the

315
00:12:18,120 --> 00:12:21,720
details of VCC clock and uh and Laser

316
00:12:21,720 --> 00:12:24,240
but maybe for example that the values at

317
00:12:24,240 --> 00:12:27,720
Gale at gate output are not sampled

318
00:12:27,720 --> 00:12:29,579
correctly because they are not ready

319
00:12:29,579 --> 00:12:31,920
clock glitching or because there is not

320
00:12:31,920 --> 00:12:33,959
enough energy for representing them

321
00:12:33,959 --> 00:12:36,480
voltage glitching so this is actually

322
00:12:36,480 --> 00:12:38,940
happening somewhere in the ship at the

323
00:12:38,940 --> 00:12:40,140
physically

324
00:12:40,140 --> 00:12:42,180
of course on top there is just the

325
00:12:42,180 --> 00:12:44,100
circuit there is not only the gate there

326
00:12:44,100 --> 00:12:45,120
is a net

327
00:12:45,120 --> 00:12:46,800
you know the net list that you might

328
00:12:46,800 --> 00:12:49,740
have heard all this thing it's a net so

329
00:12:49,740 --> 00:12:51,380
meaning that the

330
00:12:51,380 --> 00:12:54,000
misbehavior of one single gate was going

331
00:12:54,000 --> 00:12:56,519
to affect the logic on the rest

332
00:12:56,519 --> 00:12:58,980
then of course I mean if you go up there

333
00:12:58,980 --> 00:13:01,079
is the micro architectural level if you

334
00:13:01,079 --> 00:13:03,600
think of a CPU I mean x86 has a micro

335
00:13:03,600 --> 00:13:05,220
architectural instruction we have Micro

336
00:13:05,220 --> 00:13:06,959
architectural attack which are slightly

337
00:13:06,959 --> 00:13:08,940
below the instruction level

338
00:13:08,940 --> 00:13:10,920
all this happens here happens more or

339
00:13:10,920 --> 00:13:12,480
less in Hardware

340
00:13:12,480 --> 00:13:14,160
if you think about the boundary between

341
00:13:14,160 --> 00:13:16,500
hardware and software the software

342
00:13:16,500 --> 00:13:22,079
starts existing in in uh in a system on

343
00:13:22,079 --> 00:13:23,820
chip where the micro architecture is not

344
00:13:23,820 --> 00:13:25,320
configurable it's not existing a

345
00:13:25,320 --> 00:13:27,839
distraction level for chip where you can

346
00:13:27,839 --> 00:13:30,120
configure the city Behavior instruction

347
00:13:30,120 --> 00:13:32,839
with micro architectural instruction

348
00:13:32,839 --> 00:13:35,279
then the build the boundary between

349
00:13:35,279 --> 00:13:37,800
software always is a bit lower

350
00:13:37,800 --> 00:13:40,740
then after the instruction you have the

351
00:13:40,740 --> 00:13:42,959
program the control flow that's what

352
00:13:42,959 --> 00:13:45,300
basically you have we like to add an

353
00:13:45,300 --> 00:13:48,000
additional subsystem in the middle which

354
00:13:48,000 --> 00:13:49,980
actually represents whatever is not a

355
00:13:49,980 --> 00:13:52,800
CPU but it's a valid subsystem so for

356
00:13:52,800 --> 00:13:56,160
example uh uh at this level you can do

357
00:13:56,160 --> 00:13:58,560
glitching of things which are not a CPU

358
00:13:58,560 --> 00:14:00,540
you can actually open a JTAG with fault

359
00:14:00,540 --> 00:14:03,240
injection which is closed and this has

360
00:14:03,240 --> 00:14:05,399
nothing to do with CPU there is no

361
00:14:05,399 --> 00:14:07,260
software being listed you can actually

362
00:14:07,260 --> 00:14:09,899
glitch an OTP Behavior 110 programmable

363
00:14:09,899 --> 00:14:11,820
the configuration in Hardware

364
00:14:11,820 --> 00:14:14,040
and it has nothing to do with the CPU so

365
00:14:14,040 --> 00:14:15,839
you can affect the hardware logic

366
00:14:15,839 --> 00:14:18,860
basically how it works

367
00:14:19,019 --> 00:14:20,940
so what we have to understand is that

368
00:14:20,940 --> 00:14:24,300
once we have uh something which is

369
00:14:24,300 --> 00:14:27,899
misbehaving at the physical level

370
00:14:27,899 --> 00:14:30,420
this means that that kind of miss being

371
00:14:30,420 --> 00:14:32,519
at the physical level may cause the

372
00:14:32,519 --> 00:14:36,720
device to misbehave in multiple manners

373
00:14:36,720 --> 00:14:38,459
and it's not easily predictable so the

374
00:14:38,459 --> 00:14:40,920
changing of one bit let's say in the

375
00:14:40,920 --> 00:14:42,600
representation of a single gate it's

376
00:14:42,600 --> 00:14:43,980
very difficult to understand how it's

377
00:14:43,980 --> 00:14:45,480
going to propagate in the system you can

378
00:14:45,480 --> 00:14:47,760
really easily predict that the single

379
00:14:47,760 --> 00:14:50,699
bits can actually cause multiple effects

380
00:14:50,699 --> 00:14:53,459
not only once you actually glitch you

381
00:14:53,459 --> 00:14:55,260
might have situation where basically you

382
00:14:55,260 --> 00:14:58,320
are zeroing an entire register or you

383
00:14:58,320 --> 00:15:01,139
might flipping one single bit or you

384
00:15:01,139 --> 00:15:02,639
might silencing

385
00:15:02,639 --> 00:15:05,160
one single sub component you will not

386
00:15:05,160 --> 00:15:06,899
predict what is going to happen really

387
00:15:06,899 --> 00:15:09,480
at the in the in the device so that's

388
00:15:09,480 --> 00:15:11,940
single glitch if you repeat several

389
00:15:11,940 --> 00:15:14,940
times May yield different kind of

390
00:15:14,940 --> 00:15:18,300
effects in the system

391
00:15:18,300 --> 00:15:20,760
so basically what we call a first model

392
00:15:20,760 --> 00:15:22,139
the first model is something that

393
00:15:22,139 --> 00:15:24,120
describes what you're interested in we

394
00:15:24,120 --> 00:15:26,339
call instruction skipping all the faults

395
00:15:26,339 --> 00:15:27,959
that are allow you to give an effect

396
00:15:27,959 --> 00:15:30,360
which are similar to an instruction

397
00:15:30,360 --> 00:15:32,699
skipping we don't know if it's going to

398
00:15:32,699 --> 00:15:34,680
flip beta to zero something to science

399
00:15:34,680 --> 00:15:37,139
subsystem or component we have no idea

400
00:15:37,139 --> 00:15:40,440
the effects at the upper level is that

401
00:15:40,440 --> 00:15:42,720
you skip the distraction so we don't

402
00:15:42,720 --> 00:15:44,519
know if you really skipping instruction

403
00:15:44,519 --> 00:15:46,920
or not when you're doing a glitch but we

404
00:15:46,920 --> 00:15:48,420
need to understand when we are glitching

405
00:15:48,420 --> 00:15:51,480
many things happen or can happen

406
00:15:51,480 --> 00:15:53,519
so for example if you're thinking about

407
00:15:53,519 --> 00:15:55,380
using a structure skipping for an attack

408
00:15:55,380 --> 00:15:58,019
this is what we've been using before

409
00:15:58,019 --> 00:16:00,300
the secret boot we use instruction

410
00:16:00,300 --> 00:16:03,240
skipping we skip that if or at the

411
00:16:03,240 --> 00:16:05,459
assembly level and then we use it for an

412
00:16:05,459 --> 00:16:06,899
attack

413
00:16:06,899 --> 00:16:08,760
you can actually start thinking okay I

414
00:16:08,760 --> 00:16:10,560
can flip this bit I can zero this other

415
00:16:10,560 --> 00:16:13,560
one and then other attacks are possible

416
00:16:13,560 --> 00:16:15,360
but what we think we need to understand

417
00:16:15,360 --> 00:16:17,699
is that in order for this to be affected

418
00:16:17,699 --> 00:16:20,760
there must be a hardware vulnerability

419
00:16:20,760 --> 00:16:23,100
and this is actually is a modeling NFI

420
00:16:23,100 --> 00:16:24,660
attack allows us to understand how it

421
00:16:24,660 --> 00:16:25,860
works so there is a hardware

422
00:16:25,860 --> 00:16:27,360
vulnerability

423
00:16:27,360 --> 00:16:30,240
there is a technique inject that allows

424
00:16:30,240 --> 00:16:33,000
you to trigger his vulnerability with

425
00:16:33,000 --> 00:16:35,100
some parameters for example we need to

426
00:16:35,100 --> 00:16:38,699
do voltage Within These parameters that

427
00:16:38,699 --> 00:16:40,620
is going to generate at some fault and

428
00:16:40,620 --> 00:16:43,019
that fault may be different depending on

429
00:16:43,019 --> 00:16:44,579
what what kind of techniques you are

430
00:16:44,579 --> 00:16:45,300
using

431
00:16:45,300 --> 00:16:47,639
and then you have an exploit for example

432
00:16:47,639 --> 00:16:50,160
in our case the the skin fraction

433
00:16:50,160 --> 00:16:52,259
skipping can be used for bypassing

434
00:16:52,259 --> 00:16:55,019
severe checks in general

435
00:16:55,019 --> 00:16:57,180
of course I mean you can qualify you can

436
00:16:57,180 --> 00:17:00,420
describe uh more about this uh

437
00:17:00,420 --> 00:17:03,839
um about this single field of the single

438
00:17:03,839 --> 00:17:06,000
points in the in the in the modeling and

439
00:17:06,000 --> 00:17:07,679
if you want to you can actually go

440
00:17:07,679 --> 00:17:09,419
deeper into that

441
00:17:09,419 --> 00:17:11,699
what are the key points is that when you

442
00:17:11,699 --> 00:17:13,619
have a vulnerability it means that the

443
00:17:13,619 --> 00:17:17,299
target is sensitive to a technique

444
00:17:18,199 --> 00:17:20,819
whatever you do in software can only

445
00:17:20,819 --> 00:17:23,339
help or mitigate the exploitability of

446
00:17:23,339 --> 00:17:25,980
that you don't solve things in software

447
00:17:25,980 --> 00:17:28,020
in Fault injection you mitigate things

448
00:17:28,020 --> 00:17:31,140
in software if possible at all

449
00:17:31,140 --> 00:17:33,059
normally the same vulnerability when

450
00:17:33,059 --> 00:17:36,600
triggered will give different kind of

451
00:17:36,600 --> 00:17:38,760
uh or false

452
00:17:38,760 --> 00:17:42,000
and once you have a fault it can be it

453
00:17:42,000 --> 00:17:43,260
can generate things which are

454
00:17:43,260 --> 00:17:45,240
interesting for multiple fault models we

455
00:17:45,240 --> 00:17:46,980
are seeing this in a moment

456
00:17:46,980 --> 00:17:48,419
and once you have a different fault

457
00:17:48,419 --> 00:17:51,299
model like instead of skipping an

458
00:17:51,299 --> 00:17:54,419
instruction we can zero this register if

459
00:17:54,419 --> 00:17:56,280
you can zero this register again zero

460
00:17:56,280 --> 00:17:57,900
variables then I can think of another

461
00:17:57,900 --> 00:17:59,039
attacker

462
00:17:59,039 --> 00:18:00,780
or another kind of attack every time you

463
00:18:00,780 --> 00:18:02,820
think of a fault model you can build a

464
00:18:02,820 --> 00:18:04,980
different attack

465
00:18:04,980 --> 00:18:07,260
now this why I'm talking about this

466
00:18:07,260 --> 00:18:09,360
because all the guns are measured in

467
00:18:09,360 --> 00:18:10,799
software

468
00:18:10,799 --> 00:18:14,460
are based in implementation of software

469
00:18:14,460 --> 00:18:16,640
we are going to see a few a few of them

470
00:18:16,640 --> 00:18:19,260
example how do you implement the counter

471
00:18:19,260 --> 00:18:21,299
measure for the fear boot attack in the

472
00:18:21,299 --> 00:18:23,820
industry we've seen for example you do

473
00:18:23,820 --> 00:18:26,700
the verify signature multiple times this

474
00:18:26,700 --> 00:18:28,860
is a typical approach is one of the many

475
00:18:28,860 --> 00:18:30,059
actually

476
00:18:30,059 --> 00:18:33,840
and why the assumption is that a glitch

477
00:18:33,840 --> 00:18:36,299
is required in every check so if you can

478
00:18:36,299 --> 00:18:38,400
Target the first if

479
00:18:38,400 --> 00:18:40,679
then you need a second glitch or Target

480
00:18:40,679 --> 00:18:41,820
a second

481
00:18:41,820 --> 00:18:43,620
and then you need a third glitch for

482
00:18:43,620 --> 00:18:45,780
targeting the third glitch the third

483
00:18:45,780 --> 00:18:47,880
scene in centers of verification so this

484
00:18:47,880 --> 00:18:49,620
means that you're complexity of the

485
00:18:49,620 --> 00:18:51,480
attack is much higher under the

486
00:18:51,480 --> 00:18:52,860
assumption that you need really need

487
00:18:52,860 --> 00:18:55,559
three glitches because you are targeting

488
00:18:55,559 --> 00:18:59,299
that if your targeting condition

489
00:18:59,700 --> 00:19:01,559
of course I mean you still need to be

490
00:19:01,559 --> 00:19:02,580
precise

491
00:19:02,580 --> 00:19:05,760
so another counter measure is inserting

492
00:19:05,760 --> 00:19:07,200
random delays

493
00:19:07,200 --> 00:19:09,840
so that your target moves it's random

494
00:19:09,840 --> 00:19:11,460
where it is in time

495
00:19:11,460 --> 00:19:13,740
so this means that hitting the first if

496
00:19:13,740 --> 00:19:15,840
will be difficult the second Leaf will

497
00:19:15,840 --> 00:19:18,179
be even more difficult and the third if

498
00:19:18,179 --> 00:19:20,039
will be close to Impossible

499
00:19:20,039 --> 00:19:21,539
but I can tell you by experience that

500
00:19:21,539 --> 00:19:23,160
these techniques actually are effective

501
00:19:23,160 --> 00:19:25,080
against this fault model so if you start

502
00:19:25,080 --> 00:19:27,240
thinking of skipping checks or skipping

503
00:19:27,240 --> 00:19:29,220
instruction this can easily become a

504
00:19:29,220 --> 00:19:31,200
nightmare for an actual attack so they

505
00:19:31,200 --> 00:19:32,880
are effective

506
00:19:32,880 --> 00:19:35,460
but they are effective because again

507
00:19:35,460 --> 00:19:38,220
location does not fixed anymore

508
00:19:38,220 --> 00:19:40,440
under the assumption that you must hit

509
00:19:40,440 --> 00:19:44,000
that specific point in time

510
00:19:44,700 --> 00:19:46,740
and this is actually widely used in

511
00:19:46,740 --> 00:19:49,020
industry in Academia nowadays when you

512
00:19:49,020 --> 00:19:51,299
hear about yes we have implemented the

513
00:19:51,299 --> 00:19:53,340
defaulty injection countermeasures there

514
00:19:53,340 --> 00:19:55,740
are only two ways either you redo your

515
00:19:55,740 --> 00:19:56,700
Hardware

516
00:19:56,700 --> 00:19:58,620
or if you're lucky to have an fpga then

517
00:19:58,620 --> 00:20:00,179
probably you can reconfigure Hardware

518
00:20:00,179 --> 00:20:02,280
but that is not the case usually

519
00:20:02,280 --> 00:20:04,500
or if you're doing a software this is

520
00:20:04,500 --> 00:20:06,480
what you're doing or many of the things

521
00:20:06,480 --> 00:20:07,740
that you're doing are probably assuming

522
00:20:07,740 --> 00:20:09,600
like this these are not the only ones so

523
00:20:09,600 --> 00:20:12,240
these are just two prominent examples

524
00:20:12,240 --> 00:20:14,280
so this is commonly advised and

525
00:20:14,280 --> 00:20:18,020
implemented in a fire resistant Target

526
00:20:18,419 --> 00:20:20,100
of course I mean this makes the attack

527
00:20:20,100 --> 00:20:23,340
really difficult and there are

528
00:20:23,340 --> 00:20:26,700
studies of quantification which actually

529
00:20:26,700 --> 00:20:28,799
depends by Target

530
00:20:28,799 --> 00:20:32,940
now my goal here is to make you reflect

531
00:20:32,940 --> 00:20:38,220
that there is one big Untold assumption

532
00:20:38,220 --> 00:20:39,840
first that in order to have those

533
00:20:39,840 --> 00:20:42,179
counter measures in software this means

534
00:20:42,179 --> 00:20:44,460
that the software must be executed

535
00:20:44,460 --> 00:20:47,160
and that's the first one

536
00:20:47,160 --> 00:20:50,160
there is another fact that the attack

537
00:20:50,160 --> 00:20:52,679
the daily mind with this confirmation is

538
00:20:52,679 --> 00:20:56,340
expected to focus on those checks

539
00:20:56,340 --> 00:20:58,140
and also it needs to be very Precision

540
00:20:58,140 --> 00:21:01,380
Time so they're making us hit more times

541
00:21:01,380 --> 00:21:03,960
and with more of difficult targeting

542
00:21:03,960 --> 00:21:05,480
because of timing

543
00:21:05,480 --> 00:21:08,100
so this assumes that the fourth model

544
00:21:08,100 --> 00:21:09,539
usually for your attack is destruction

545
00:21:09,539 --> 00:21:11,340
skipping so this means that whatever you

546
00:21:11,340 --> 00:21:13,620
had in mind what you have created is

547
00:21:13,620 --> 00:21:16,500
based on skipping instruction

548
00:21:16,500 --> 00:21:18,840
but what if you switch to a completely

549
00:21:18,840 --> 00:21:21,740
different for the model

550
00:21:22,140 --> 00:21:24,360
the structural corruption I mean a

551
00:21:24,360 --> 00:21:26,400
glitch in principle can change stuff

552
00:21:26,400 --> 00:21:28,620
right it can affect the physics

553
00:21:28,620 --> 00:21:30,600
so it means it can affect instructions

554
00:21:30,600 --> 00:21:32,460
when they are loaded so in principle you

555
00:21:32,460 --> 00:21:35,159
can change those instructions

556
00:21:35,159 --> 00:21:36,900
so this means a glitches may go wrap the

557
00:21:36,900 --> 00:21:39,059
instruction for example numbers again

558
00:21:39,059 --> 00:21:41,580
this is not an hypothesis I'm telling

559
00:21:41,580 --> 00:21:43,200
you things which have very been proven

560
00:21:43,200 --> 00:21:45,780
by research so this is not

561
00:21:45,780 --> 00:21:47,940
something that I'm arguing is possible

562
00:21:47,940 --> 00:21:50,700
we have demonstrated not only us but

563
00:21:50,700 --> 00:21:52,440
mostly us I mean we have demonstrated

564
00:21:52,440 --> 00:21:54,600
this is possible in peer-reviewed papers

565
00:21:54,600 --> 00:21:56,940
just to tell you what this is reality

566
00:21:56,940 --> 00:21:59,820
it's not an assumption and about this

567
00:21:59,820 --> 00:22:02,039
which is in many cases corrupt

568
00:22:02,039 --> 00:22:04,380
instruction can think about that single

569
00:22:04,380 --> 00:22:06,539
bit correction you have a nut this is an

570
00:22:06,539 --> 00:22:08,940
M32 assembly I mean something

571
00:22:08,940 --> 00:22:10,440
understandable

572
00:22:10,440 --> 00:22:13,559
the register X3 by flipping a single bit

573
00:22:13,559 --> 00:22:16,380
is changing to X2 so this means that now

574
00:22:16,380 --> 00:22:21,780
you are loading into x0 the sum of X1

575
00:22:21,780 --> 00:22:25,740
and X2 instead of the sum of X1 and X3

576
00:22:25,740 --> 00:22:28,740
and this is just by flipping one bit how

577
00:22:28,740 --> 00:22:29,880
does it work when you fetch an

578
00:22:29,880 --> 00:22:31,860
instruction you fetch it from memory it

579
00:22:31,860 --> 00:22:34,559
goes over bus if you glitch the transfer

580
00:22:34,559 --> 00:22:39,059
and change that bit this is what you get

581
00:22:39,059 --> 00:22:41,820
of course even multi-bit corruption may

582
00:22:41,820 --> 00:22:43,500
happen and this is another example you

583
00:22:43,500 --> 00:22:44,760
don't control what really happened

584
00:22:44,760 --> 00:22:46,679
you're only interested if you said that

585
00:22:46,679 --> 00:22:49,260
actually happens because then you can

586
00:22:49,260 --> 00:22:50,940
use it

587
00:22:50,940 --> 00:22:52,679
most ships are actually affected by this

588
00:22:52,679 --> 00:22:54,659
fault model so which bits can be

589
00:22:54,659 --> 00:22:56,760
controlled how at which timing really

590
00:22:56,760 --> 00:22:59,220
depends on the characterization you need

591
00:22:59,220 --> 00:23:01,620
to do you need to study the target

592
00:23:01,620 --> 00:23:03,659
but in general this actually modifies

593
00:23:03,659 --> 00:23:05,760
software and if you get modify the

594
00:23:05,760 --> 00:23:07,679
software which has been executed the

595
00:23:07,679 --> 00:23:09,720
software security model brings

596
00:23:09,720 --> 00:23:11,700
I mean this seems abstract let's have a

597
00:23:11,700 --> 00:23:14,100
look at the actual practice of this

598
00:23:14,100 --> 00:23:16,440
now think about data transfer we

599
00:23:16,440 --> 00:23:18,299
actually transfer data in everyday

600
00:23:18,299 --> 00:23:20,880
revise every moment one of the most

601
00:23:20,880 --> 00:23:22,100
successful

602
00:23:22,100 --> 00:23:25,260
functions in history of software is mcpy

603
00:23:25,260 --> 00:23:29,100
we copy data between buffers

604
00:23:29,100 --> 00:23:31,860
all device transfer data from memory to

605
00:23:31,860 --> 00:23:33,720
memory from buffer to buffer in general

606
00:23:33,720 --> 00:23:36,240
also they use the external interfaces

607
00:23:36,240 --> 00:23:39,659
you have basically the theio ring in the

608
00:23:39,659 --> 00:23:41,039
kernel which can be used for

609
00:23:41,039 --> 00:23:43,500
transferring data somewhere else

610
00:23:43,500 --> 00:23:46,559
you have the uh the packets of network

611
00:23:46,559 --> 00:23:48,840
which go through the stack of course

612
00:23:48,840 --> 00:23:50,280
there is not much copying over there

613
00:23:50,280 --> 00:23:52,559
much sooner or later there will be a

614
00:23:52,559 --> 00:23:55,140
copying somewhere

615
00:23:55,140 --> 00:23:58,140
so there are situations where the data

616
00:23:58,140 --> 00:23:59,580
which is under transferring is under

617
00:23:59,580 --> 00:24:02,159
your control you are creating the data

618
00:24:02,159 --> 00:24:03,659
which is being submitted to the device

619
00:24:03,659 --> 00:24:06,000
when you're doing a Cisco you are the

620
00:24:06,000 --> 00:24:08,159
one controlling the data and submitting

621
00:24:08,159 --> 00:24:10,200
that to the Cisco for example

622
00:24:10,200 --> 00:24:13,140
so mem cpy basically it's everywhere

623
00:24:13,140 --> 00:24:15,539
I mean if you look at mcpy when we do

624
00:24:15,539 --> 00:24:17,460
software Security review we look at

625
00:24:17,460 --> 00:24:19,500
destination source and size

626
00:24:19,500 --> 00:24:21,059
yeah you need to make sure that the

627
00:24:21,059 --> 00:24:22,620
destination is within safe boundaries

628
00:24:22,620 --> 00:24:24,000
that the source is within safe

629
00:24:24,000 --> 00:24:25,380
boundaries that the amount of the

630
00:24:25,380 --> 00:24:28,440
decides being transferred is not too

631
00:24:28,440 --> 00:24:30,600
large for the destination buffer

632
00:24:30,600 --> 00:24:33,480
but what you actually transfer is not

633
00:24:33,480 --> 00:24:35,460
security political it's not considered

634
00:24:35,460 --> 00:24:38,580
as such you can trust with banana apples

635
00:24:38,580 --> 00:24:41,159
lime whatever it would be the same from

636
00:24:41,159 --> 00:24:43,440
a security point of view right

637
00:24:43,440 --> 00:24:44,700
now

638
00:24:44,700 --> 00:24:46,679
you start using this as a volt injection

639
00:24:46,679 --> 00:24:49,620
Target well there is something extremely

640
00:24:49,620 --> 00:24:51,419
relevant to the data which is being

641
00:24:51,419 --> 00:24:53,700
transferred now I think that you are

642
00:24:53,700 --> 00:24:55,440
basically is providing data over

643
00:24:55,440 --> 00:24:57,840
transfer over the interface of a USB

644
00:24:57,840 --> 00:25:00,000
there is an input buffer then this

645
00:25:00,000 --> 00:25:02,400
command is being handled somewhere

646
00:25:02,400 --> 00:25:04,860
common handle the processes this data

647
00:25:04,860 --> 00:25:06,840
and actually responds to you

648
00:25:06,840 --> 00:25:10,080
at some point in between there is mmcpy

649
00:25:10,080 --> 00:25:11,220
you see

650
00:25:11,220 --> 00:25:13,380
so what you're seeing that the attack

651
00:25:13,380 --> 00:25:15,179
data is being transferred you see those

652
00:25:15,179 --> 00:25:18,840
two instruction ldm R1 and STM are zero

653
00:25:18,840 --> 00:25:21,360
so this means that you take

654
00:25:21,360 --> 00:25:22,799
the

655
00:25:22,799 --> 00:25:23,340
um

656
00:25:23,340 --> 00:25:26,640
the data which is pointed by R1 and you

657
00:25:26,640 --> 00:25:28,620
store it into our three or four or five

658
00:25:28,620 --> 00:25:30,299
or six this is how you read that first

659
00:25:30,299 --> 00:25:31,200
instruction

660
00:25:31,200 --> 00:25:33,840
everyone is a pointer and you get data

661
00:25:33,840 --> 00:25:36,059
into those registers right and then you

662
00:25:36,059 --> 00:25:37,080
store

663
00:25:37,080 --> 00:25:39,059
the content of those register towards

664
00:25:39,059 --> 00:25:41,159
zero to the destination so R1 is your

665
00:25:41,159 --> 00:25:44,460
source nr0 is your destination right so

666
00:25:44,460 --> 00:25:46,860
the first instruction copies four times

667
00:25:46,860 --> 00:25:49,500
four byte so 16 byte and the second

668
00:25:49,500 --> 00:25:51,720
instruction stores at destination 16

669
00:25:51,720 --> 00:25:53,159
bytes

670
00:25:53,159 --> 00:25:56,760
now look at that line

671
00:25:56,760 --> 00:25:58,980
now if you glitch during that line and

672
00:25:58,980 --> 00:26:00,900
you change one of the bits of the

673
00:26:00,900 --> 00:26:03,480
register then one of the registers may

674
00:26:03,480 --> 00:26:06,179
become the program counter

675
00:26:06,179 --> 00:26:08,400
this means that the data that is being

676
00:26:08,400 --> 00:26:10,440
transferred goes directly into your

677
00:26:10,440 --> 00:26:13,200
program counter so what happens when you

678
00:26:13,200 --> 00:26:17,240
transfer something to a program counter

679
00:26:17,640 --> 00:26:19,020
basically

680
00:26:19,020 --> 00:26:22,679
your PC set to attacker data and the

681
00:26:22,679 --> 00:26:24,539
control flow is directly eject the

682
00:26:24,539 --> 00:26:26,159
continuation

683
00:26:26,159 --> 00:26:28,320
of the execution will go from the

684
00:26:28,320 --> 00:26:29,400
address

685
00:26:29,400 --> 00:26:30,960
that you have set

686
00:26:30,960 --> 00:26:33,720
this is pretty interesting you send data

687
00:26:33,720 --> 00:26:36,539
whatever you glitch it ends up in

688
00:26:36,539 --> 00:26:38,340
program counter and then you magically

689
00:26:38,340 --> 00:26:40,559
started shooting from somewhere else

690
00:26:40,559 --> 00:26:42,600
again this is what happens it's not what

691
00:26:42,600 --> 00:26:45,419
I argue it may happen this is has been

692
00:26:45,419 --> 00:26:47,220
proven to happen

693
00:26:47,220 --> 00:26:49,260
so this was an easy explanation for Ram

694
00:26:49,260 --> 00:26:50,400
32

695
00:26:50,400 --> 00:26:52,620
you basically go wrapped an instruction

696
00:26:52,620 --> 00:26:55,200
you mode modify this loading structure

697
00:26:55,200 --> 00:26:57,480
and then you modify the PC just because

698
00:26:57,480 --> 00:26:59,820
you flip one bit or a few bits in the

699
00:26:59,820 --> 00:27:01,380
destination

700
00:27:01,380 --> 00:27:03,419
we're using this several times we

701
00:27:03,419 --> 00:27:05,700
demonstrate this publicly I mean I will

702
00:27:05,700 --> 00:27:07,880
not go through this but there will be

703
00:27:07,880 --> 00:27:10,980
links around to investigate that would

704
00:27:10,980 --> 00:27:12,600
work for another architectures because

705
00:27:12,600 --> 00:27:14,820
in the end being able to change

706
00:27:14,820 --> 00:27:16,860
something to PC is specifically to

707
00:27:16,860 --> 00:27:20,400
Warren V7 arm32 only that

708
00:27:20,400 --> 00:27:22,440
there are very few architectural PCS

709
00:27:22,440 --> 00:27:24,779
addressable this is not a problem

710
00:27:24,779 --> 00:27:27,120
we have multiple violence that allow you

711
00:27:27,120 --> 00:27:30,000
to give you code execution

712
00:27:30,000 --> 00:27:31,860
and which are sufficiently genetic to

713
00:27:31,860 --> 00:27:33,960
work across multiple architecture for

714
00:27:33,960 --> 00:27:36,240
example you could corrupt the stock

715
00:27:36,240 --> 00:27:38,640
pointers it's still register instead of

716
00:27:38,640 --> 00:27:40,559
loading to PC you will see load of stack

717
00:27:40,559 --> 00:27:43,500
and then the entire world of rope

718
00:27:43,500 --> 00:27:47,279
and let's say shower stack and other

719
00:27:47,279 --> 00:27:48,960
things people would be voting for exact

720
00:27:48,960 --> 00:27:51,900
pivoting can actually be used

721
00:27:51,900 --> 00:27:54,240
so there are examples for this but let

722
00:27:54,240 --> 00:27:56,820
me show one which is important or in mb8

723
00:27:56,820 --> 00:27:57,960
you have an instruction which is called

724
00:27:57,960 --> 00:28:01,200
red you return from a subroutine

725
00:28:01,200 --> 00:28:03,360
usually usually

726
00:28:03,360 --> 00:28:06,299
the return address is in one register

727
00:28:06,299 --> 00:28:09,480
x30 so when you enter you don't store

728
00:28:09,480 --> 00:28:12,720
value on the stack immediately restore

729
00:28:12,720 --> 00:28:15,179
index 30. okay

730
00:28:15,179 --> 00:28:17,820
Define destruction is disencoding you

731
00:28:17,820 --> 00:28:19,799
see this in principle the instructional

732
00:28:19,799 --> 00:28:23,159
thread can encode more registers not

733
00:28:23,159 --> 00:28:26,100
only x30 many people see that and think

734
00:28:26,100 --> 00:28:28,200
they expect 30 but the instruction the

735
00:28:28,200 --> 00:28:30,840
assembly leaves room for encoding so if

736
00:28:30,840 --> 00:28:33,299
you flip one bit there you will return

737
00:28:33,299 --> 00:28:36,900
to the register to the address stored in

738
00:28:36,900 --> 00:28:39,600
a different register in order

739
00:28:39,600 --> 00:28:42,059
real good example this is Google bionic

740
00:28:42,059 --> 00:28:43,380
mem cpy

741
00:28:43,380 --> 00:28:46,860
we are copying that code look at that

742
00:28:46,860 --> 00:28:50,400
then the source is in X6 and the

743
00:28:50,400 --> 00:28:52,799
destination is next seven basically so

744
00:28:52,799 --> 00:28:56,700
sorry uh so data is Source data resource

745
00:28:56,700 --> 00:28:59,700
residing x67 so X6 and XML contains your

746
00:28:59,700 --> 00:29:02,220
data okay

747
00:29:02,220 --> 00:29:04,559
so this is something that you control X1

748
00:29:04,559 --> 00:29:07,740
is the source now if at the end

749
00:29:07,740 --> 00:29:10,500
of the function you bleach the threat

750
00:29:10,500 --> 00:29:14,100
to Red X6 or red X7 you will jump to the

751
00:29:14,100 --> 00:29:16,020
data that you control

752
00:29:16,020 --> 00:29:18,539
so this gives you

753
00:29:18,539 --> 00:29:21,360
the ability to control program counter

754
00:29:21,360 --> 00:29:23,159
on any architecture because this is what

755
00:29:23,159 --> 00:29:25,200
happens on basically

756
00:29:25,200 --> 00:29:27,299
any architecture in general so basically

757
00:29:27,299 --> 00:29:29,100
how do you do this

758
00:29:29,100 --> 00:29:31,440
first identify data transfers that you

759
00:29:31,440 --> 00:29:34,200
control I mean USB interfacing CD or

760
00:29:34,200 --> 00:29:35,399
whatever

761
00:29:35,399 --> 00:29:37,860
mem cpy being kernel

762
00:29:37,860 --> 00:29:39,480
okay

763
00:29:39,480 --> 00:29:41,700
put your shell put somewhere reachable

764
00:29:41,700 --> 00:29:43,320
in the data they will transfer put

765
00:29:43,320 --> 00:29:44,700
pointers

766
00:29:44,700 --> 00:29:47,520
and start glitching

767
00:29:47,520 --> 00:29:49,980
glitching during your mcpy you get PC

768
00:29:49,980 --> 00:29:51,960
control and then it's like having a

769
00:29:51,960 --> 00:29:53,640
stack Overflow but without any soft

770
00:29:53,640 --> 00:29:56,340
vulnerability you get control of PC

771
00:29:56,340 --> 00:29:58,679
but do you have not done any buffer

772
00:29:58,679 --> 00:30:01,500
overflow so stock canneries will not be

773
00:30:01,500 --> 00:30:04,080
relevant to anybody what will be

774
00:30:04,080 --> 00:30:05,760
relevant is from that point where you

775
00:30:05,760 --> 00:30:09,720
jump to aslr may be effective NX not

776
00:30:09,720 --> 00:30:11,220
executable memory pages will be

777
00:30:11,220 --> 00:30:13,640
effective

778
00:30:14,039 --> 00:30:17,100
so basically if you actually go like

779
00:30:17,100 --> 00:30:19,140
this and you actually set your payload

780
00:30:19,140 --> 00:30:22,080
your sled of pointers and you glitch

781
00:30:22,080 --> 00:30:25,500
during your pointer sled this means that

782
00:30:25,500 --> 00:30:27,960
your execution will be very similar like

783
00:30:27,960 --> 00:30:29,399
this

784
00:30:29,399 --> 00:30:32,039
when you load your pointers you glitch

785
00:30:32,039 --> 00:30:34,380
they go into the program counter your

786
00:30:34,380 --> 00:30:35,940
program counters are executing the

787
00:30:35,940 --> 00:30:38,700
payload which has not been verified

788
00:30:38,700 --> 00:30:41,279
nothing has been verified yet

789
00:30:41,279 --> 00:30:43,380
so you start executing your payload

790
00:30:43,380 --> 00:30:46,860
before any check actually happens

791
00:30:46,860 --> 00:30:48,600
why because the checks do not exist

792
00:30:48,600 --> 00:30:50,159
anymore

793
00:30:50,159 --> 00:30:52,080
because that software is not a trio that

794
00:30:52,080 --> 00:30:53,760
it's there but the program counters are

795
00:30:53,760 --> 00:30:55,740
executing from somewhere else

796
00:30:55,740 --> 00:30:57,779
yeah

797
00:30:57,779 --> 00:31:00,480
the key point is that the the software

798
00:31:00,480 --> 00:31:01,799
built countermeasure becomes completely

799
00:31:01,799 --> 00:31:04,200
ineffective all of them I'm talking

800
00:31:04,200 --> 00:31:05,760
about all the devices which have this

801
00:31:05,760 --> 00:31:07,440
kind of counter measures if you glitch

802
00:31:07,440 --> 00:31:09,299
during the data transfer

803
00:31:09,299 --> 00:31:12,419
and not glitch in the instruction then

804
00:31:12,419 --> 00:31:14,640
an entire world open up because the

805
00:31:14,640 --> 00:31:17,399
countermeasures are not there anymore

806
00:31:17,399 --> 00:31:19,020
so this means that you don't Target

807
00:31:19,020 --> 00:31:21,419
checks anymore you don't care all those

808
00:31:21,419 --> 00:31:22,860
contaminations which are in there

809
00:31:22,860 --> 00:31:24,720
basically

810
00:31:24,720 --> 00:31:26,640
they don't they're not even existing

811
00:31:26,640 --> 00:31:27,960
anymore

812
00:31:27,960 --> 00:31:29,880
this is very hard to protect against and

813
00:31:29,880 --> 00:31:32,279
then today is a typical to fault the

814
00:31:32,279 --> 00:31:34,559
injection resistant Target so when you

815
00:31:34,559 --> 00:31:36,360
see targets which are deemed to be

816
00:31:36,360 --> 00:31:38,279
faulty injection resistant instead of

817
00:31:38,279 --> 00:31:39,539
attacking

818
00:31:39,539 --> 00:31:42,840
the checks like everybody does from a

819
00:31:42,840 --> 00:31:44,340
textbook

820
00:31:44,340 --> 00:31:47,460
try to attack a transfer where you

821
00:31:47,460 --> 00:31:48,779
control the data

822
00:31:48,779 --> 00:31:50,340
if you look at the assembly and the

823
00:31:50,340 --> 00:31:53,279
reversing that your dsmcpy or any that

824
00:31:53,279 --> 00:31:55,919
data runs for instruction any load list

825
00:31:55,919 --> 00:31:57,179
there

826
00:31:57,179 --> 00:31:59,279
you will be probably be you will likely

827
00:31:59,279 --> 00:32:00,779
be successful

828
00:32:00,779 --> 00:32:03,299
and this is example what we did you see

829
00:32:03,299 --> 00:32:06,260
that those lines over there that small

830
00:32:06,260 --> 00:32:08,520
uh block

831
00:32:08,520 --> 00:32:12,659
of around 10 200 for 24 microseconds

832
00:32:12,659 --> 00:32:14,279
it's not at the end

833
00:32:14,279 --> 00:32:16,679
the area that we are glitching is within

834
00:32:16,679 --> 00:32:19,140
the copy now we are wishing why the data

835
00:32:19,140 --> 00:32:21,899
is complete the what is copied pointers

836
00:32:21,899 --> 00:32:23,580
we had the payload somewhere else it's

837
00:32:23,580 --> 00:32:25,380
just copying points

838
00:32:25,380 --> 00:32:27,179
nobody checks that your copying pointer

839
00:32:27,179 --> 00:32:28,860
because not nobody knows what you are

840
00:32:28,860 --> 00:32:30,240
transferring

841
00:32:30,240 --> 00:32:32,460
the transfer is agnostic to the data

842
00:32:32,460 --> 00:32:34,080
itself so you can put whatever you want

843
00:32:34,080 --> 00:32:36,419
if you control there so we're

844
00:32:36,419 --> 00:32:37,980
controlling a small attack window while

845
00:32:37,980 --> 00:32:41,279
the bootloader is being copied

846
00:32:41,279 --> 00:32:43,500
well to give you the proof of success

847
00:32:43,500 --> 00:32:45,799
this is what we achieved

848
00:32:45,799 --> 00:32:48,120
basically we got control of the program

849
00:32:48,120 --> 00:32:50,880
counter every 30 seconds with this

850
00:32:50,880 --> 00:32:53,220
technique regardless of all the checks

851
00:32:53,220 --> 00:32:54,539
there may have been

852
00:32:54,539 --> 00:32:57,179
afterwards

853
00:32:57,179 --> 00:33:00,240
so let me add something really relevant

854
00:33:00,240 --> 00:33:02,279
because people think that you need very

855
00:33:02,279 --> 00:33:04,679
precise synchronization timing now with

856
00:33:04,679 --> 00:33:06,179
this technique basically this actually

857
00:33:06,179 --> 00:33:08,580
goes away and there is a a few reason

858
00:33:08,580 --> 00:33:11,220
that allow me to

859
00:33:11,220 --> 00:33:12,019
um

860
00:33:12,019 --> 00:33:15,659
basically conclude my talk the memsip UI

861
00:33:15,659 --> 00:33:18,120
actually loads data into register there

862
00:33:18,120 --> 00:33:19,679
is load instruction

863
00:33:19,679 --> 00:33:22,200
that load is done in Loops how many

864
00:33:22,200 --> 00:33:24,480
Loops depends on the size which are

865
00:33:24,480 --> 00:33:27,120
being transferred

866
00:33:27,120 --> 00:33:28,740
when you glitch you modify the

867
00:33:28,740 --> 00:33:30,960
instruction so that loads this into

868
00:33:30,960 --> 00:33:32,940
another register

869
00:33:32,940 --> 00:33:35,039
and the control flow is eject only at

870
00:33:35,039 --> 00:33:38,399
function exit not during the transfer

871
00:33:38,399 --> 00:33:40,980
so this means that these Loops will

872
00:33:40,980 --> 00:33:43,019
happen so many times before the function

873
00:33:43,019 --> 00:33:44,279
exits

874
00:33:44,279 --> 00:33:46,980
that you will have several and many

875
00:33:46,980 --> 00:33:49,200
opportunities for glitching it's not

876
00:33:49,200 --> 00:33:51,419
anymore one thing or thing one single

877
00:33:51,419 --> 00:33:52,740
point to attack

878
00:33:52,740 --> 00:33:54,480
so basically you can reach anytime

879
00:33:54,480 --> 00:33:56,279
anywhere

880
00:33:56,279 --> 00:33:58,080
or you can you have a very big window

881
00:33:58,080 --> 00:34:00,539
where you can actually glitch

882
00:34:00,539 --> 00:34:03,419
and normally what you see is the example

883
00:34:03,419 --> 00:34:05,039
that even if you think there is only one

884
00:34:05,039 --> 00:34:07,320
single mem cpy actually the device is

885
00:34:07,320 --> 00:34:10,560
reality do transfer code and data many

886
00:34:10,560 --> 00:34:11,760
times

887
00:34:11,760 --> 00:34:15,119
so what you're seeing here is

888
00:34:15,119 --> 00:34:16,560
kernel

889
00:34:16,560 --> 00:34:18,599
transferring data

890
00:34:18,599 --> 00:34:21,659
after a Cisco so we did the Cisco we put

891
00:34:21,659 --> 00:34:23,399
data into register

892
00:34:23,399 --> 00:34:25,679
and we'll just start glitching until the

893
00:34:25,679 --> 00:34:27,239
end

894
00:34:27,239 --> 00:34:30,599
now we have successes of getting PC

895
00:34:30,599 --> 00:34:32,399
control into kernel

896
00:34:32,399 --> 00:34:35,339
at that time at that time

897
00:34:35,339 --> 00:34:38,520
at that time that time and that time so

898
00:34:38,520 --> 00:34:40,440
this tells you already that the data

899
00:34:40,440 --> 00:34:41,940
that you have been that you have used

900
00:34:41,940 --> 00:34:44,460
for submit to the Cisco have at least

901
00:34:44,460 --> 00:34:48,179
been transferred several times so if you

902
00:34:48,179 --> 00:34:50,159
start glitching during this time you may

903
00:34:50,159 --> 00:34:52,320
very well encounter any

904
00:34:52,320 --> 00:34:53,940
uh any

905
00:34:53,940 --> 00:34:55,679
trans data transfer so instead of

906
00:34:55,679 --> 00:34:57,960
transferring payloads

907
00:34:57,960 --> 00:35:00,839
of strategy Shell Code transfer pointers

908
00:35:00,839 --> 00:35:03,200
and start glitching and see what happens

909
00:35:03,200 --> 00:35:07,080
if you get your pointer into PC well you

910
00:35:07,080 --> 00:35:08,700
are directly into something which is

911
00:35:08,700 --> 00:35:10,140
definitely different from the usual

912
00:35:10,140 --> 00:35:11,460
attacks

913
00:35:11,460 --> 00:35:13,560
so basically you have very large time

914
00:35:13,560 --> 00:35:15,900
windows for glitching

915
00:35:15,900 --> 00:35:18,900
any data transfer can be a Target

916
00:35:18,900 --> 00:35:20,579
you'll need very loose synchronization

917
00:35:20,579 --> 00:35:21,960
you don't need to be precise anymore

918
00:35:21,960 --> 00:35:23,640
basically

919
00:35:23,640 --> 00:35:25,800
and sometimes the precise tree green is

920
00:35:25,800 --> 00:35:27,180
not required anymore because you have

921
00:35:27,180 --> 00:35:28,500
such a big window why do you even

922
00:35:28,500 --> 00:35:31,200
trigger precisely why do you spend so

923
00:35:31,200 --> 00:35:33,599
much time anything there you don't need

924
00:35:33,599 --> 00:35:36,720
there there is like this

925
00:35:36,720 --> 00:35:38,640
so this actually brings you to a

926
00:35:38,640 --> 00:35:40,500
situation where you're triggered becomes

927
00:35:40,500 --> 00:35:42,420
much more relevant your Precision is

928
00:35:42,420 --> 00:35:45,839
much more much less level I'm sorry

929
00:35:45,839 --> 00:35:49,260
so let me help Define the consideration

930
00:35:49,260 --> 00:35:51,359
all the confirmation in software all

931
00:35:51,359 --> 00:35:52,980
most of them are based on instruction

932
00:35:52,980 --> 00:35:55,320
skipping if you use another fault model

933
00:35:55,320 --> 00:35:58,560
they may like in this case completely

934
00:35:58,560 --> 00:36:00,599
disappear

935
00:36:00,599 --> 00:36:03,000
instruction corruption actually gives

936
00:36:03,000 --> 00:36:05,339
you code execution it's very natural

937
00:36:05,339 --> 00:36:07,680
because you get PC control with those

938
00:36:07,680 --> 00:36:09,420
kind of attacks

939
00:36:09,420 --> 00:36:11,700
what you only require are control of the

940
00:36:11,700 --> 00:36:14,339
data being transferred any data transfer

941
00:36:14,339 --> 00:36:16,560
can be a Target and your setup may

942
00:36:16,560 --> 00:36:18,180
become much easier in terms of

943
00:36:18,180 --> 00:36:19,800
synchronization you don't need very

944
00:36:19,800 --> 00:36:24,540
split microsecond or nanosecond precise

945
00:36:24,540 --> 00:36:26,579
and modern serum targets out there are

946
00:36:26,579 --> 00:36:28,440
still vulnerable to this kind of attacks

947
00:36:28,440 --> 00:36:31,440
so when you see a device or a say a

948
00:36:31,440 --> 00:36:32,820
Target which claims to defaulty

949
00:36:32,820 --> 00:36:35,339
injection resistant again my advice is

950
00:36:35,339 --> 00:36:38,880
not try to execute and by bus checks

951
00:36:38,880 --> 00:36:43,260
transfer data pointers and glitch still

952
00:36:43,260 --> 00:36:45,180
bleach from prey but it would be glitch

953
00:36:45,180 --> 00:36:46,560
and see

954
00:36:46,560 --> 00:36:48,839
because if your PC goes to one of your

955
00:36:48,839 --> 00:36:51,240
data then you get PC control

956
00:36:51,240 --> 00:36:53,520
and I hope that the actually is a this

957
00:36:53,520 --> 00:36:56,099
has been interesting for you because uh

958
00:36:56,099 --> 00:36:57,960
should shed some light on how to

959
00:36:57,960 --> 00:36:59,400
implement a different fault injection

960
00:36:59,400 --> 00:37:01,800
attacks

961
00:37:01,800 --> 00:37:02,420
thank you

962
00:37:02,420 --> 00:37:05,510
[Applause]

963
00:37:05,510 --> 00:37:11,799
[Music]

