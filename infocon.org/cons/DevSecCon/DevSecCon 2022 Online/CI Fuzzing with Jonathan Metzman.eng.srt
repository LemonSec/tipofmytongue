1
00:00:00,470 --> 00:00:04,160
[Music]

2
00:00:04,160 --> 00:00:06,720
folks let's jump right into our next

3
00:00:06,720 --> 00:00:08,240
session what do we got in store for

4
00:00:08,240 --> 00:00:11,040
everybody next eric you know next

5
00:00:11,040 --> 00:00:14,639
session is on ci fuzzing with uh

6
00:00:14,639 --> 00:00:17,920
jonathan metzman and um this is actually

7
00:00:17,920 --> 00:00:19,439
a great time i was just watching when i

8
00:00:19,439 --> 00:00:22,080
was at kubecon i was looking at fuzzing

9
00:00:22,080 --> 00:00:24,000
testing automation and things like that

10
00:00:24,000 --> 00:00:26,240
so i'm very curious to see jonathan's

11
00:00:26,240 --> 00:00:27,519
take on this

12
00:00:27,519 --> 00:00:29,279
so fuzzing is like well let's get

13
00:00:29,279 --> 00:00:31,760
jonathan in here i gotta know

14
00:00:31,760 --> 00:00:33,760
hey jonathan good to see you yeah good

15
00:00:33,760 --> 00:00:35,920
to be here uh i'll go over what uh

16
00:00:35,920 --> 00:00:38,079
fuzzing is so uh don't worry okay

17
00:00:38,079 --> 00:00:39,360
because i'm thinking like stuffed

18
00:00:39,360 --> 00:00:41,520
animals they're fuzzy i don't know i'm

19
00:00:41,520 --> 00:00:43,120
i'm still it's a lot it's a lot to do

20
00:00:43,120 --> 00:00:44,960
with it yeah oh really okay good i'm on

21
00:00:44,960 --> 00:00:46,960
the right track well without further ado

22
00:00:46,960 --> 00:00:48,640
i'll let you take it away and thank you

23
00:00:48,640 --> 00:00:50,239
for joining us

24
00:00:50,239 --> 00:00:53,038
yeah um

25
00:00:53,199 --> 00:00:55,920
so uh you know as i was introduced my

26
00:00:55,920 --> 00:00:58,719
name is jonathan um and you know today i

27
00:00:58,719 --> 00:01:01,199
want to talk to you all about uh ci

28
00:01:01,199 --> 00:01:03,280
fuzzing from first principles meaning i

29
00:01:03,280 --> 00:01:04,479
want to go through sort of like the

30
00:01:04,479 --> 00:01:06,720
history of fuzzing and how it went from

31
00:01:06,720 --> 00:01:07,600
like

32
00:01:07,600 --> 00:01:09,520
uh a tool for

33
00:01:09,520 --> 00:01:11,360
shadowy hackers into something that's

34
00:01:11,360 --> 00:01:13,600
just you know useful in any developers

35
00:01:13,600 --> 00:01:14,880
like toolkit

36
00:01:14,880 --> 00:01:16,799
um just a quick

37
00:01:16,799 --> 00:01:18,240
background on me

38
00:01:18,240 --> 00:01:20,000
uh i've been at google working on

39
00:01:20,000 --> 00:01:22,880
fuzzing for five years almost

40
00:01:22,880 --> 00:01:24,880
first on chrome's security team and then

41
00:01:24,880 --> 00:01:27,520
on google's open source security team uh

42
00:01:27,520 --> 00:01:29,040
today though i'm just only like

43
00:01:29,040 --> 00:01:32,560
representing myself not my company

44
00:01:32,560 --> 00:01:36,320
so uh some background on what fuzzing is

45
00:01:36,320 --> 00:01:40,479
so uh fuzzing is a process uh automated

46
00:01:40,479 --> 00:01:43,200
process where you take randomized inputs

47
00:01:43,200 --> 00:01:45,439
and feed them to a program in order to

48
00:01:45,439 --> 00:01:47,360
find bugs in that program

49
00:01:47,360 --> 00:01:50,000
and typically these bugs are crashes

50
00:01:50,000 --> 00:01:51,920
just because uh

51
00:01:51,920 --> 00:01:53,280
you know

52
00:01:53,280 --> 00:01:54,960
crashes are just like the easiest way to

53
00:01:54,960 --> 00:01:56,240
tell that there's something went wrong

54
00:01:56,240 --> 00:01:57,680
in a program it's not application

55
00:01:57,680 --> 00:01:58,880
specific

56
00:01:58,880 --> 00:02:01,200
and crashes are also pretty interesting

57
00:02:01,200 --> 00:02:03,520
um from a security perspective when

58
00:02:03,520 --> 00:02:06,399
dealing with uh cnc plus plus programs

59
00:02:06,399 --> 00:02:07,200
so

60
00:02:07,200 --> 00:02:09,919
in addition to uh possibly being denial

61
00:02:09,919 --> 00:02:12,319
of service issues uh crashes could mean

62
00:02:12,319 --> 00:02:14,160
that there's like sort of uh memory

63
00:02:14,160 --> 00:02:15,520
corruption going on like you know if

64
00:02:15,520 --> 00:02:18,319
there's a seg fault perhaps maybe like

65
00:02:18,319 --> 00:02:20,319
you know a more skilled attacker could

66
00:02:20,319 --> 00:02:22,319
use it to gain control of the program

67
00:02:22,319 --> 00:02:23,599
counter so

68
00:02:23,599 --> 00:02:24,640
um

69
00:02:24,640 --> 00:02:26,319
fuzzing has really been thought of as

70
00:02:26,319 --> 00:02:28,640
like a security technique although it's

71
00:02:28,640 --> 00:02:30,319
also good for finding you know sort of

72
00:02:30,319 --> 00:02:33,599
other like stability bugs

73
00:02:33,760 --> 00:02:34,959
now

74
00:02:34,959 --> 00:02:37,200
it basically works by uh

75
00:02:37,200 --> 00:02:40,239
similar to how this like uh

76
00:02:40,239 --> 00:02:42,400
snippet i have on the slide illustrates

77
00:02:42,400 --> 00:02:44,400
it you just basically in an infinite

78
00:02:44,400 --> 00:02:45,200
loop

79
00:02:45,200 --> 00:02:47,360
uh create a new input

80
00:02:47,360 --> 00:02:49,519
and pass that input to the code that you

81
00:02:49,519 --> 00:02:53,599
want to test and just watch for crashes

82
00:02:54,480 --> 00:02:55,519
now

83
00:02:55,519 --> 00:02:57,920
fuzzing um if you were to like

84
00:02:57,920 --> 00:03:00,080
have a just like a generic mutator that

85
00:03:00,080 --> 00:03:02,159
just flipped random bits and you were

86
00:03:02,159 --> 00:03:04,400
fuzzing something like a pdf reader

87
00:03:04,400 --> 00:03:06,319
you probably wouldn't get very far into

88
00:03:06,319 --> 00:03:08,400
the pdf reader just because you know

89
00:03:08,400 --> 00:03:10,000
it'll reject a lot of your inputs as

90
00:03:10,000 --> 00:03:11,440
invalid so

91
00:03:11,440 --> 00:03:14,480
typically uh at this stage in fuzzing

92
00:03:14,480 --> 00:03:17,519
people would write format aware fuzzers

93
00:03:17,519 --> 00:03:18,800
that

94
00:03:18,800 --> 00:03:20,319
that you know just are basically right

95
00:03:20,319 --> 00:03:22,239
they're aware of the format that they're

96
00:03:22,239 --> 00:03:23,599
uh targeting

97
00:03:23,599 --> 00:03:26,000
and so um like if we were fuzzing like a

98
00:03:26,000 --> 00:03:29,360
pdf reader you know my pdf mutator would

99
00:03:29,360 --> 00:03:31,760
know about pdf files and you know it

100
00:03:31,760 --> 00:03:33,840
could do things like add pages

101
00:03:33,840 --> 00:03:36,879
uh you know remove images add forms

102
00:03:36,879 --> 00:03:38,720
stuff like that rather than just like

103
00:03:38,720 --> 00:03:40,400
you know more like primitive uh

104
00:03:40,400 --> 00:03:42,560
operations like bitflips

105
00:03:42,560 --> 00:03:44,159
but this is obviously like a huge pain

106
00:03:44,159 --> 00:03:46,400
to do um you know like in order to do

107
00:03:46,400 --> 00:03:47,519
that you probably have to read like the

108
00:03:47,519 --> 00:03:50,239
pdf spec which uh someone who's done

109
00:03:50,239 --> 00:03:52,159
that i could tell you is not very fun

110
00:03:52,159 --> 00:03:53,760
and you know like we just want to find

111
00:03:53,760 --> 00:03:54,879
bugs like we don't want to spend our

112
00:03:54,879 --> 00:03:56,400
time doing this so

113
00:03:56,400 --> 00:03:58,480
uh at this point really fuzzing was just

114
00:03:58,480 --> 00:04:00,080
like a technique used by highly

115
00:04:00,080 --> 00:04:02,480
motivated individuals which really just

116
00:04:02,480 --> 00:04:05,439
means like attackers

117
00:04:07,200 --> 00:04:09,360
so around eight years ago though there

118
00:04:09,360 --> 00:04:11,599
was a big advance made in the fuzzing

119
00:04:11,599 --> 00:04:14,400
world called coverage guided fuzzing

120
00:04:14,400 --> 00:04:18,000
and this was pioneered by tools like afl

121
00:04:18,000 --> 00:04:20,798
and lib fuzzer and really helped uh

122
00:04:20,798 --> 00:04:23,040
shift fuzzing left and that you know it

123
00:04:23,040 --> 00:04:25,600
could become a tool that's accessible to

124
00:04:25,600 --> 00:04:27,919
ordinary developers who aren't maybe

125
00:04:27,919 --> 00:04:29,360
highly motivated but are just like

126
00:04:29,360 --> 00:04:31,759
somewhat motivated and so

127
00:04:31,759 --> 00:04:32,639
uh

128
00:04:32,639 --> 00:04:34,400
these fuzzers are

129
00:04:34,400 --> 00:04:36,960
uh have mutators that are generic

130
00:04:36,960 --> 00:04:39,600
their mutators do things like the bit

131
00:04:39,600 --> 00:04:41,600
flips and you know changing the values

132
00:04:41,600 --> 00:04:43,360
of ascii integers

133
00:04:43,360 --> 00:04:45,919
but the coverage guided magic is what

134
00:04:45,919 --> 00:04:48,000
allows it to actually effectively fuzz

135
00:04:48,000 --> 00:04:48,880
so

136
00:04:48,880 --> 00:04:52,000
after each uh iteration or

137
00:04:52,000 --> 00:04:54,080
execution on a test case provided by the

138
00:04:54,080 --> 00:04:55,040
fuzzer

139
00:04:55,040 --> 00:04:57,840
the fuzzer looks at what parts of the

140
00:04:57,840 --> 00:05:00,240
targeted code were executed

141
00:05:00,240 --> 00:05:03,520
and if anything new is executed it adds

142
00:05:03,520 --> 00:05:06,000
the test case that it just created to

143
00:05:06,000 --> 00:05:07,680
this list of test cases called like the

144
00:05:07,680 --> 00:05:11,120
corpus and it for further mutation and

145
00:05:11,120 --> 00:05:13,039
so you can see how like after a couple

146
00:05:13,039 --> 00:05:15,759
rounds of you know this we found some

147
00:05:15,759 --> 00:05:17,520
new behavior then another new behavior

148
00:05:17,520 --> 00:05:19,759
then another new behavior that we're

149
00:05:19,759 --> 00:05:21,680
getting deeper and deeper into the

150
00:05:21,680 --> 00:05:23,919
program and so this really like you know

151
00:05:23,919 --> 00:05:25,680
and with infinite time like you'd cover

152
00:05:25,680 --> 00:05:28,560
the entire state space of the program so

153
00:05:28,560 --> 00:05:31,199
um this really made it easy to fuzz

154
00:05:31,199 --> 00:05:33,520
without having to spend lots of time

155
00:05:33,520 --> 00:05:36,080
you know writing like custom mutators or

156
00:05:36,080 --> 00:05:39,080
generators

157
00:05:40,639 --> 00:05:42,800
and another uh

158
00:05:42,800 --> 00:05:44,880
development that really brought

159
00:05:44,880 --> 00:05:46,880
fuzzing into like i'd say like almost

160
00:05:46,880 --> 00:05:48,400
like the mainstream of just like

161
00:05:48,400 --> 00:05:51,759
software development was uh the

162
00:05:51,759 --> 00:05:53,840
birth of just sort of fuzzing

163
00:05:53,840 --> 00:05:56,639
infrastructure so i'm most familiar with

164
00:05:56,639 --> 00:05:59,120
cluster fuzz because that's google's

165
00:05:59,120 --> 00:06:01,199
fuzzing infrastructure which you know

166
00:06:01,199 --> 00:06:03,680
was made around the same time as afl

167
00:06:03,680 --> 00:06:05,199
and

168
00:06:05,199 --> 00:06:08,639
what it does is it automates a lot of

169
00:06:08,639 --> 00:06:10,319
the like sort of tedious work that you

170
00:06:10,319 --> 00:06:12,639
would have to do around fuzzing um such

171
00:06:12,639 --> 00:06:14,639
as like you know checking that your bugs

172
00:06:14,639 --> 00:06:17,280
are unique because you know fuzzers do

173
00:06:17,280 --> 00:06:18,560
like execute

174
00:06:18,560 --> 00:06:20,960
uh thousands and thousands of test cases

175
00:06:20,960 --> 00:06:22,400
and you'll probably get the same crash

176
00:06:22,400 --> 00:06:23,840
many times and so you're gonna wanna

177
00:06:23,840 --> 00:06:26,319
like you know root cause that and not

178
00:06:26,319 --> 00:06:27,919
you know look into each of those

179
00:06:27,919 --> 00:06:30,160
separately um you know crash

180
00:06:30,160 --> 00:06:31,759
minimization just

181
00:06:31,759 --> 00:06:33,120
uh you can take my word for that there's

182
00:06:33,120 --> 00:06:34,560
like a lot of tedious steps that you'd

183
00:06:34,560 --> 00:06:36,560
have to do as a developer uh fuzzing on

184
00:06:36,560 --> 00:06:37,840
your own machine

185
00:06:37,840 --> 00:06:39,120
and cluster buzz pretty much like

186
00:06:39,120 --> 00:06:41,520
automated all of that so that you could

187
00:06:41,520 --> 00:06:43,360
continuously fuzz and all you would need

188
00:06:43,360 --> 00:06:45,680
to do is sort of write fuzzers and fix

189
00:06:45,680 --> 00:06:48,319
bugs and the way it worked is uh you

190
00:06:48,319 --> 00:06:50,880
have uh automated builders that just

191
00:06:50,880 --> 00:06:54,560
continuously produce builds um of uh

192
00:06:54,560 --> 00:06:56,479
cluster buzz was developed for chrome so

193
00:06:56,479 --> 00:06:58,240
you know these builders are

194
00:06:58,240 --> 00:07:00,840
built chrome and chrome fuzzers

195
00:07:00,840 --> 00:07:04,479
and it uploaded uh those builds

196
00:07:04,479 --> 00:07:07,120
to uh google cloud storage where it was

197
00:07:07,120 --> 00:07:09,199
then consumed by cluster fuzz and what i

198
00:07:09,199 --> 00:07:11,039
mean by consumed is

199
00:07:11,039 --> 00:07:13,440
cluster fuzz ran the fuzzers and with

200
00:07:13,440 --> 00:07:15,759
any crashes it sort of triaged them

201
00:07:15,759 --> 00:07:18,080
automatically filed bugs against

202
00:07:18,080 --> 00:07:19,840
developers and then

203
00:07:19,840 --> 00:07:21,440
every day would check that the bug was

204
00:07:21,440 --> 00:07:23,360
fixed and if so it would close the bug

205
00:07:23,360 --> 00:07:24,960
and so right like as you can see like

206
00:07:24,960 --> 00:07:27,120
the only manual steps are these like

207
00:07:27,120 --> 00:07:29,919
sort of writing fuzzers and fixing bugs

208
00:07:29,919 --> 00:07:31,919
and this workflow like worked really

209
00:07:31,919 --> 00:07:34,639
well on chrome and we extended it to

210
00:07:34,639 --> 00:07:35,759
other parts

211
00:07:35,759 --> 00:07:38,319
of google like chrome os uh android like

212
00:07:38,319 --> 00:07:41,120
internal code

213
00:07:42,000 --> 00:07:44,960
and like it's very tailored towards uh

214
00:07:44,960 --> 00:07:47,120
what we can do as google right so you

215
00:07:47,120 --> 00:07:49,440
know we run cluster fuzz on hundreds of

216
00:07:49,440 --> 00:07:51,919
thousands of cores uh we run you know

217
00:07:51,919 --> 00:07:53,520
probably in like the thousands of

218
00:07:53,520 --> 00:07:56,800
fuzzers and we found uh over like 50 000

219
00:07:56,800 --> 00:07:58,319
bugs that we've reported with cluster

220
00:07:58,319 --> 00:08:00,000
fuzz like over the years

221
00:08:00,000 --> 00:08:01,039
um

222
00:08:01,039 --> 00:08:03,680
and you know other big companies like um

223
00:08:03,680 --> 00:08:06,080
you know microsoft uh has sort of has a

224
00:08:06,080 --> 00:08:07,840
similar tool called like one fuzz which

225
00:08:07,840 --> 00:08:09,039
is basically like their version of

226
00:08:09,039 --> 00:08:11,280
cluster fuzz right so i think this model

227
00:08:11,280 --> 00:08:13,039
works pretty well for

228
00:08:13,039 --> 00:08:14,000
um

229
00:08:14,000 --> 00:08:15,680
you know large company basically like

230
00:08:15,680 --> 00:08:18,720
the t the companies that have people um

231
00:08:18,720 --> 00:08:20,319
developing these tools just because it's

232
00:08:20,319 --> 00:08:22,319
just very tailored towards the needs of

233
00:08:22,319 --> 00:08:24,720
the company um but

234
00:08:24,720 --> 00:08:25,680
you know

235
00:08:25,680 --> 00:08:28,080
if you're just uh an ordinary developer

236
00:08:28,080 --> 00:08:29,919
who doesn't want to think too much about

237
00:08:29,919 --> 00:08:31,759
fuzzing but wants some of the benefits

238
00:08:31,759 --> 00:08:33,360
is this really sort of like what you

239
00:08:33,360 --> 00:08:36,719
want or need um you know are there costs

240
00:08:36,719 --> 00:08:39,839
to having such like a fancy uh arc fancy

241
00:08:39,839 --> 00:08:42,240
infrastructure

242
00:08:42,240 --> 00:08:44,480
and of course uh i wouldn't be here if

243
00:08:44,480 --> 00:08:46,399
there weren't um

244
00:08:46,399 --> 00:08:47,200
you know

245
00:08:47,200 --> 00:08:49,200
this fancy infrastructure uh is

246
00:08:49,200 --> 00:08:51,839
difficult to set up uh it's pretty heavy

247
00:08:51,839 --> 00:08:53,440
weight and so there's a lot of just like

248
00:08:53,440 --> 00:08:54,560
sort of like

249
00:08:54,560 --> 00:08:56,240
uh different like

250
00:08:56,240 --> 00:08:58,160
uh parts you have to set up

251
00:08:58,160 --> 00:08:59,200
um

252
00:08:59,200 --> 00:09:00,720
they're not these infrastructures are

253
00:09:00,720 --> 00:09:03,600
not very portable uh they tend to be

254
00:09:03,600 --> 00:09:05,519
written for the cloud of the company

255
00:09:05,519 --> 00:09:09,839
developing them so for example like uh

256
00:09:09,839 --> 00:09:12,640
cluster fuzz doesn't run that well it

257
00:09:12,640 --> 00:09:14,480
doesn't run as well outside of google

258
00:09:14,480 --> 00:09:16,399
cloud as it does inside of google cloud

259
00:09:16,399 --> 00:09:18,160
there's some features that you can't get

260
00:09:18,160 --> 00:09:20,000
and i think the same is uh true for one

261
00:09:20,000 --> 00:09:21,760
fuzz and azure you know microsoft's

262
00:09:21,760 --> 00:09:23,200
cloud

263
00:09:23,200 --> 00:09:24,800
um and

264
00:09:24,800 --> 00:09:26,800
another uh problem just like with this

265
00:09:26,800 --> 00:09:30,000
approach that uh in my mind is that um

266
00:09:30,000 --> 00:09:30,880
you know

267
00:09:30,880 --> 00:09:32,720
it's continuous but it's sort of not

268
00:09:32,720 --> 00:09:34,880
really continuous integration

269
00:09:34,880 --> 00:09:36,560
it's

270
00:09:36,560 --> 00:09:37,839
being done after the point of

271
00:09:37,839 --> 00:09:39,440
integration and you know i don't think

272
00:09:39,440 --> 00:09:41,200
that's ideal because

273
00:09:41,200 --> 00:09:42,959
a developer like after they've committed

274
00:09:42,959 --> 00:09:44,560
code like should be able to sort of like

275
00:09:44,560 --> 00:09:46,080
you know forget about it and move on to

276
00:09:46,080 --> 00:09:49,120
the next uh feature rather than you know

277
00:09:49,120 --> 00:09:50,560
having to fix issues in it that were

278
00:09:50,560 --> 00:09:52,080
discovered like a day or two later like

279
00:09:52,080 --> 00:09:55,040
that's never fun and so i think just

280
00:09:55,040 --> 00:09:57,040
sort of the the point at which cluster

281
00:09:57,040 --> 00:09:58,959
fuzz is sitting um

282
00:09:58,959 --> 00:10:03,160
is not ideal for this purpose

283
00:10:04,800 --> 00:10:07,600
so to address this problem uh we spent a

284
00:10:07,600 --> 00:10:09,440
fair amount of effort moving fuzzing

285
00:10:09,440 --> 00:10:11,200
into uh ci

286
00:10:11,200 --> 00:10:14,160
and to support fuzzing nci we uh wrote a

287
00:10:14,160 --> 00:10:16,560
tool called cluster fuzz light uh

288
00:10:16,560 --> 00:10:19,200
cluster buzz light can run in common uh

289
00:10:19,200 --> 00:10:21,760
ci systems such as like github actions

290
00:10:21,760 --> 00:10:23,040
and it's actually meant to be very

291
00:10:23,040 --> 00:10:24,720
portable to other ones

292
00:10:24,720 --> 00:10:25,600
um

293
00:10:25,600 --> 00:10:27,680
and what clusterfuzz light does is it

294
00:10:27,680 --> 00:10:29,440
can fuzz your code changes such as like

295
00:10:29,440 --> 00:10:32,079
your pull requests or commits and catch

296
00:10:32,079 --> 00:10:34,640
bugs in them before they land instead of

297
00:10:34,640 --> 00:10:37,120
you know fuzzing uh your code after it

298
00:10:37,120 --> 00:10:39,120
lands and giving you bugs like a few

299
00:10:39,120 --> 00:10:42,079
days later and because it's lightweight

300
00:10:42,079 --> 00:10:45,440
um it's very trivial to uh set up uh and

301
00:10:45,440 --> 00:10:47,120
like port to other platforms and just

302
00:10:47,120 --> 00:10:49,279
low maintenance in general um even

303
00:10:49,279 --> 00:10:51,519
though it actually is using uh

304
00:10:51,519 --> 00:10:53,680
cluster fuzz uh cluster fuzz's code base

305
00:10:53,680 --> 00:10:56,480
underneath the hood

306
00:10:56,480 --> 00:10:59,279
um and just like as proof of uh it being

307
00:10:59,279 --> 00:11:02,880
like effective and uh easy to use is uh

308
00:11:02,880 --> 00:11:05,440
our users like we have um

309
00:11:05,440 --> 00:11:07,519
you know over like a hundred users

310
00:11:07,519 --> 00:11:10,079
mostly from oss fuzz that are using

311
00:11:10,079 --> 00:11:12,800
uh cluster fuzz lite for finding bugs in

312
00:11:12,800 --> 00:11:15,760
their code you know before they land and

313
00:11:15,760 --> 00:11:18,880
you know we found hundreds of crashes in

314
00:11:18,880 --> 00:11:21,920
those projects code

315
00:11:22,800 --> 00:11:23,680
and so

316
00:11:23,680 --> 00:11:25,360
the way cluster fuzz light works is

317
00:11:25,360 --> 00:11:27,279
intended to make you know fuzzing like

318
00:11:27,279 --> 00:11:30,959
you would run unit tests uh in ci so

319
00:11:30,959 --> 00:11:32,880
pretty much like any other ci tool um

320
00:11:32,880 --> 00:11:34,720
this is cluster fuzz light in github

321
00:11:34,720 --> 00:11:35,760
actions

322
00:11:35,760 --> 00:11:37,440
you uh

323
00:11:37,440 --> 00:11:38,880
you get like a pull request and cluster

324
00:11:38,880 --> 00:11:41,360
fuzz light kicks off fuzzing it and if

325
00:11:41,360 --> 00:11:44,160
it finds a crash it uh reports like a

326
00:11:44,160 --> 00:11:47,120
failed status um by the way ci fuzz is

327
00:11:47,120 --> 00:11:48,640
just like an old name for cluster fuzz

328
00:11:48,640 --> 00:11:51,680
light uh so reports a failed status and

329
00:11:51,680 --> 00:11:53,519
you know makes available the inputs that

330
00:11:53,519 --> 00:11:55,440
cause the crash for you to uh you know

331
00:11:55,440 --> 00:11:57,600
so you could reproduce it on your own

332
00:11:57,600 --> 00:12:00,320
and lets you view uh the output of the

333
00:12:00,320 --> 00:12:03,120
crash so like here's the stack trace

334
00:12:03,120 --> 00:12:05,279
from a crash that cluster fuzz light

335
00:12:05,279 --> 00:12:06,240
found

336
00:12:06,240 --> 00:12:09,200
in open ssl uh and this crash

337
00:12:09,200 --> 00:12:11,600
or this bug rather wasn't actually

338
00:12:11,600 --> 00:12:13,680
merged into the open ssl code base

339
00:12:13,680 --> 00:12:15,279
because cluster fuzz light caught it

340
00:12:15,279 --> 00:12:18,320
before it could be merged

341
00:12:18,720 --> 00:12:21,519
so hopefully i sold you pretty well on

342
00:12:21,519 --> 00:12:24,560
um you know cluster fuzz light uh let's

343
00:12:24,560 --> 00:12:27,040
maybe dive into a bit uh for of how it

344
00:12:27,040 --> 00:12:29,839
works just because i think um you know

345
00:12:29,839 --> 00:12:31,839
there's a lot maybe i could learn from

346
00:12:31,839 --> 00:12:34,720
sort of you know the devops community on

347
00:12:34,720 --> 00:12:36,639
what works well in ci and maybe you know

348
00:12:36,639 --> 00:12:38,560
some people like will like some of the

349
00:12:38,560 --> 00:12:40,480
um you know compromises and trade-offs

350
00:12:40,480 --> 00:12:41,600
we made

351
00:12:41,600 --> 00:12:43,040
so

352
00:12:43,040 --> 00:12:45,279
fuzzing is not so like clusterify's

353
00:12:45,279 --> 00:12:46,480
light was not as simple as just like

354
00:12:46,480 --> 00:12:48,399
plopping uh

355
00:12:48,399 --> 00:12:50,399
fuzzing into ci and calling it a day

356
00:12:50,399 --> 00:12:51,839
just because fuzzing is sort of like

357
00:12:51,839 --> 00:12:54,160
ill-suited towards ci i think

358
00:12:54,160 --> 00:12:57,040
um or at least like how fuzzing was done

359
00:12:57,040 --> 00:12:58,959
before cluster buzz light

360
00:12:58,959 --> 00:13:01,680
uh fuzzing uh you know relies on like

361
00:13:01,680 --> 00:13:03,519
non-determinism uh you know there's

362
00:13:03,519 --> 00:13:05,519
randomized inputs and that's not great

363
00:13:05,519 --> 00:13:07,920
in a ci system because you want you know

364
00:13:07,920 --> 00:13:10,959
errors to be reproducible uh so that you

365
00:13:10,959 --> 00:13:13,600
know devs know what they did wrong um

366
00:13:13,600 --> 00:13:15,760
another problem is just like speed right

367
00:13:15,760 --> 00:13:17,760
so fuzzing uh

368
00:13:17,760 --> 00:13:18,880
may need

369
00:13:18,880 --> 00:13:20,160
like you never know really when you're

370
00:13:20,160 --> 00:13:22,560
done fuzzing necessarily um you know

371
00:13:22,560 --> 00:13:23,839
it's always possible that they're more

372
00:13:23,839 --> 00:13:25,440
bugs it's not like a sound technique

373
00:13:25,440 --> 00:13:27,760
that like proves the absence of bugs

374
00:13:27,760 --> 00:13:29,920
uh but we can't spend like hours so and

375
00:13:29,920 --> 00:13:32,160
you probably will find more bugs the

376
00:13:32,160 --> 00:13:34,079
longer you spend fuzzing uh but you

377
00:13:34,079 --> 00:13:35,519
can't you know we can't spend hours

378
00:13:35,519 --> 00:13:37,519
fuzzing on a pull request and block it

379
00:13:37,519 --> 00:13:39,279
from landing like you know no dev is

380
00:13:39,279 --> 00:13:40,880
gonna put up with that

381
00:13:40,880 --> 00:13:43,040
uh and finally um there's an issue of

382
00:13:43,040 --> 00:13:45,360
like fuzzer selection that i'm gonna uh

383
00:13:45,360 --> 00:13:49,639
touch on uh in a bit

384
00:13:51,440 --> 00:13:54,720
so first uh the non-determinism um

385
00:13:54,720 --> 00:13:56,480
there are two really bad ways that like

386
00:13:56,480 --> 00:13:58,639
non-determinism and fuzzing could really

387
00:13:58,639 --> 00:14:00,160
burn um

388
00:14:00,160 --> 00:14:02,720
someone use doing fuzzing in ci with

389
00:14:02,720 --> 00:14:04,639
like a naive approach so

390
00:14:04,639 --> 00:14:07,040
um if our fuzzers were non-deterministic

391
00:14:07,040 --> 00:14:08,160
in ci

392
00:14:08,160 --> 00:14:10,240
uh what they could do is convince

393
00:14:10,240 --> 00:14:12,160
developers that they introduced a bug

394
00:14:12,160 --> 00:14:14,320
that they didn't in fact introduce so

395
00:14:14,320 --> 00:14:17,199
for example suppose alice uh

396
00:14:17,199 --> 00:14:19,839
commits a code on monday that contains a

397
00:14:19,839 --> 00:14:22,320
bug and because you know fuzzers are

398
00:14:22,320 --> 00:14:24,639
like unsound it just happens to miss

399
00:14:24,639 --> 00:14:25,680
that bug

400
00:14:25,680 --> 00:14:29,519
uh but later bob on tuesday

401
00:14:29,519 --> 00:14:32,560
is has a pull request up and the fuzzer

402
00:14:32,560 --> 00:14:34,880
happens to find alice's bug now

403
00:14:34,880 --> 00:14:37,040
uh well like bob is not gonna be happy

404
00:14:37,040 --> 00:14:40,240
that you know we're failing on uh we're

405
00:14:40,240 --> 00:14:42,079
failing on his pull requests and not on

406
00:14:42,079 --> 00:14:45,680
alice's so that's one issue and another

407
00:14:45,680 --> 00:14:47,760
one that's perhaps even more insidious

408
00:14:47,760 --> 00:14:49,600
is convincing you that you fix the bug

409
00:14:49,600 --> 00:14:51,680
when you actually have it so

410
00:14:51,680 --> 00:14:54,160
uh the way this would work is you know

411
00:14:54,160 --> 00:14:57,760
if let's say suppose that uh

412
00:14:57,760 --> 00:15:00,480
ci fuzzing were capable of finding

413
00:15:00,480 --> 00:15:03,279
alice's bug like in her pull request uh

414
00:15:03,279 --> 00:15:04,959
and then she tried making a fix but the

415
00:15:04,959 --> 00:15:07,279
fix was incomplete and

416
00:15:07,279 --> 00:15:08,959
she puts up the pull request for review

417
00:15:08,959 --> 00:15:11,839
again and ci fuzzing kicks off and this

418
00:15:11,839 --> 00:15:14,079
time due to randomness like it misses uh

419
00:15:14,079 --> 00:15:16,959
her bug well to her it's gonna look like

420
00:15:16,959 --> 00:15:20,399
that bug was um fixed and so that's

421
00:15:20,399 --> 00:15:22,079
obviously like quite bad

422
00:15:22,079 --> 00:15:23,199
so

423
00:15:23,199 --> 00:15:24,880
to deal with this uh we do a couple

424
00:15:24,880 --> 00:15:26,800
different things um the first like the

425
00:15:26,800 --> 00:15:29,120
simplest uh like low hanging fruit was

426
00:15:29,120 --> 00:15:32,320
just you know using a fixed uh random

427
00:15:32,320 --> 00:15:34,480
see fixed seed for the uh random number

428
00:15:34,480 --> 00:15:35,600
generator

429
00:15:35,600 --> 00:15:38,000
uh and this kind of reduces the number

430
00:15:38,000 --> 00:15:40,560
of bugs that we find overall probably

431
00:15:40,560 --> 00:15:42,880
but it gives us more determinism which i

432
00:15:42,880 --> 00:15:44,639
think is more important in like a ci

433
00:15:44,639 --> 00:15:46,399
fuzzing system then you know

434
00:15:46,399 --> 00:15:48,480
completeness is not as important as some

435
00:15:48,480 --> 00:15:50,240
of these other properties

436
00:15:50,240 --> 00:15:51,440
um

437
00:15:51,440 --> 00:15:53,199
and then the other technique that we use

438
00:15:53,199 --> 00:15:56,320
is uh we only report novel crashes so

439
00:15:56,320 --> 00:15:58,639
back to like the alice and bob case

440
00:15:58,639 --> 00:15:59,839
um

441
00:15:59,839 --> 00:16:02,800
what cluster fuzz light actually does is

442
00:16:02,800 --> 00:16:04,639
uh if there's a crash in bob's pull

443
00:16:04,639 --> 00:16:07,600
request it'll download an old build of

444
00:16:07,600 --> 00:16:09,600
the fuzzers and see if that crash could

445
00:16:09,600 --> 00:16:11,600
be reproduced in the old build

446
00:16:11,600 --> 00:16:13,040
and if a crash could be reproduced in

447
00:16:13,040 --> 00:16:16,160
the old build then we know that the

448
00:16:16,160 --> 00:16:17,839
code that we're testing you know bob's

449
00:16:17,839 --> 00:16:21,040
pull request uh did not introduce it so

450
00:16:21,040 --> 00:16:22,720
classifies light actually won't report

451
00:16:22,720 --> 00:16:26,240
the bug in that case um and hopefully

452
00:16:26,240 --> 00:16:28,079
like if you're just doing that you might

453
00:16:28,079 --> 00:16:29,759
end up like missing bugs but hopefully

454
00:16:29,759 --> 00:16:31,920
like you'll have another um you know

455
00:16:31,920 --> 00:16:33,360
longer running fuzzing process that

456
00:16:33,360 --> 00:16:34,959
could catch that later

457
00:16:34,959 --> 00:16:37,600
uh

458
00:16:37,600 --> 00:16:39,920
so that's for non-determinism now uh

459
00:16:39,920 --> 00:16:42,240
speed is another problem right like i

460
00:16:42,240 --> 00:16:44,880
pointed out that we'll find less bugs

461
00:16:44,880 --> 00:16:47,120
uh if we will probably find less bugs if

462
00:16:47,120 --> 00:16:49,120
we fuzz for 10 minutes rather than two

463
00:16:49,120 --> 00:16:52,160
hours but you know what do we do so here

464
00:16:52,160 --> 00:16:54,720
i made the very scientific decision to

465
00:16:54,720 --> 00:16:56,639
fuzz for 10 minutes and you know of

466
00:16:56,639 --> 00:16:58,160
course that's the balance of two goals

467
00:16:58,160 --> 00:17:00,000
of how do we get results back to

468
00:17:00,000 --> 00:17:02,399
developers quick enough versus how do we

469
00:17:02,399 --> 00:17:03,279
um

470
00:17:03,279 --> 00:17:04,959
you know how do we find as many bugs as

471
00:17:04,959 --> 00:17:06,480
possible

472
00:17:06,480 --> 00:17:07,520
uh

473
00:17:07,520 --> 00:17:09,359
and i think there's some so and there's

474
00:17:09,359 --> 00:17:11,280
some anecdotal evidence that this like

475
00:17:11,280 --> 00:17:13,280
10 minutes is enough uh you know some

476
00:17:13,280 --> 00:17:14,640
developers say that like most of their

477
00:17:14,640 --> 00:17:16,799
issues are caught by cluster fuzz light

478
00:17:16,799 --> 00:17:19,760
uh before they even get to oss fuzz

479
00:17:19,760 --> 00:17:20,640
um

480
00:17:20,640 --> 00:17:22,240
and i've actually looked at like some

481
00:17:22,240 --> 00:17:24,959
data from oss fuzz and there's data to

482
00:17:24,959 --> 00:17:27,359
support this uh claim too

483
00:17:27,359 --> 00:17:29,840
about like 40 of bugs of new bugs that

484
00:17:29,840 --> 00:17:30,640
were

485
00:17:30,640 --> 00:17:33,520
found uh during fuzzing uh were found

486
00:17:33,520 --> 00:17:36,000
like pretty soon after the bug was

487
00:17:36,000 --> 00:17:38,080
introduced and so there's actually a

488
00:17:38,080 --> 00:17:39,760
reason to think that this bug could be

489
00:17:39,760 --> 00:17:42,160
found faster um on

490
00:17:42,160 --> 00:17:44,960
cluster fuzz light than it could in uh

491
00:17:44,960 --> 00:17:47,520
cluster fuzz but um

492
00:17:47,520 --> 00:17:50,000
but yeah like i there's at least like

493
00:17:50,000 --> 00:17:51,440
you know around like 40 percent of the

494
00:17:51,440 --> 00:17:53,360
bugs that we we could find if we could

495
00:17:53,360 --> 00:17:56,240
find uh around 40 of the bugs that we

496
00:17:56,240 --> 00:17:57,360
would find with this heavyweight

497
00:17:57,360 --> 00:17:59,200
infrastructure you know if cluster fuzz

498
00:17:59,200 --> 00:18:01,840
light can provide that and you know

499
00:18:01,840 --> 00:18:04,000
take like 10 of the effort and 10 of the

500
00:18:04,000 --> 00:18:08,480
cost i think that's like quite a big win

501
00:18:11,200 --> 00:18:13,520
and uh finally the last like smart

502
00:18:13,520 --> 00:18:16,320
feature of um or like adaptation we made

503
00:18:16,320 --> 00:18:17,200
uh

504
00:18:17,200 --> 00:18:20,080
to ci for cluster fuzz light was uh

505
00:18:20,080 --> 00:18:22,799
deciding which fuzzer to run so fuzzers

506
00:18:22,799 --> 00:18:24,240
are kind of like um

507
00:18:24,240 --> 00:18:26,880
chips in that like people who write one

508
00:18:26,880 --> 00:18:29,120
tend to do more than one so here you

509
00:18:29,120 --> 00:18:30,000
could see

510
00:18:30,000 --> 00:18:32,480
uh like fuzzers in systemd and you can

511
00:18:32,480 --> 00:18:33,760
see that there's at least like four that

512
00:18:33,760 --> 00:18:35,200
begin with the letter b right and there

513
00:18:35,200 --> 00:18:37,200
are actually many more fuzzers right so

514
00:18:37,200 --> 00:18:38,559
how do you when you have like a pull

515
00:18:38,559 --> 00:18:40,160
request that you're testing how do you

516
00:18:40,160 --> 00:18:42,960
know which one of these to run um

517
00:18:42,960 --> 00:18:45,520
and what cluster fuzz light does is it

518
00:18:45,520 --> 00:18:48,160
will download coverage reports for each

519
00:18:48,160 --> 00:18:51,280
buzzer and it'll take the diff uh that

520
00:18:51,280 --> 00:18:54,000
it's actually testing and see oh this

521
00:18:54,000 --> 00:18:55,679
fuzzer covers the code that's been

522
00:18:55,679 --> 00:18:56,400
changed

523
00:18:56,400 --> 00:18:58,320
i'll run that fuzzer and if the fuzzer

524
00:18:58,320 --> 00:19:00,160
doesn't cover that code then it doesn't

525
00:19:00,160 --> 00:19:02,080
get run and so we can more efficiently

526
00:19:02,080 --> 00:19:04,160
spend the 10 minutes

527
00:19:04,160 --> 00:19:06,160
that we have the fuzz running fuzzers

528
00:19:06,160 --> 00:19:08,240
that could actually find bugs introduced

529
00:19:08,240 --> 00:19:09,919
by the change

530
00:19:09,919 --> 00:19:11,440
than we would if we were just running

531
00:19:11,440 --> 00:19:14,400
every single fuzzer

532
00:19:16,880 --> 00:19:18,880
uh and customized light has a lot of

533
00:19:18,880 --> 00:19:21,120
like just features that cluster fuzz

534
00:19:21,120 --> 00:19:23,360
does

535
00:19:23,440 --> 00:19:24,960
such as like support for different

536
00:19:24,960 --> 00:19:27,679
sanitizers uh which are good for finding

537
00:19:27,679 --> 00:19:29,039
different kinds of like

538
00:19:29,039 --> 00:19:31,360
issues in c and c plus plus code like

539
00:19:31,360 --> 00:19:33,360
undefined behavior or use of

540
00:19:33,360 --> 00:19:36,559
uninitialized values uh it also supports

541
00:19:36,559 --> 00:19:37,440
um

542
00:19:37,440 --> 00:19:39,600
other languages such as like rust go

543
00:19:39,600 --> 00:19:40,720
python

544
00:19:40,720 --> 00:19:42,720
and java and i know i've sort of focused

545
00:19:42,720 --> 00:19:44,559
a little bit on c and c plus plus and

546
00:19:44,559 --> 00:19:45,840
that's just sort of where fuzzing has

547
00:19:45,840 --> 00:19:48,160
had the most success but um it's

548
00:19:48,160 --> 00:19:50,480
definitely a useful tool for non-cnc

549
00:19:50,480 --> 00:19:52,799
plus plus uh projects

550
00:19:52,799 --> 00:19:54,400
um

551
00:19:54,400 --> 00:19:56,080
and uh

552
00:19:56,080 --> 00:19:57,120
yeah so

553
00:19:57,120 --> 00:20:00,080
in addition to providing like

554
00:20:00,080 --> 00:20:02,080
ci style fuzzing where we're testing

555
00:20:02,080 --> 00:20:04,320
code changes uh cluster buzz light could

556
00:20:04,320 --> 00:20:05,600
actually um

557
00:20:05,600 --> 00:20:07,520
provide some of the

558
00:20:07,520 --> 00:20:10,000
core features of cluster fuzz

559
00:20:10,000 --> 00:20:12,720
uh for example like just long-running uh

560
00:20:12,720 --> 00:20:14,720
fuzzing jobs that take multiple hours

561
00:20:14,720 --> 00:20:16,799
and like asynchronously reports bugs

562
00:20:16,799 --> 00:20:18,080
which is just like the main thing

563
00:20:18,080 --> 00:20:21,120
cluster fuzz does uh that could be done

564
00:20:21,120 --> 00:20:23,200
by cluster fuzz light using just like

565
00:20:23,200 --> 00:20:24,559
the cron

566
00:20:24,559 --> 00:20:26,720
functionality of ci systems like github

567
00:20:26,720 --> 00:20:27,919
actions

568
00:20:27,919 --> 00:20:29,520
and another cool feature that classes

569
00:20:29,520 --> 00:20:31,280
resolve offers

570
00:20:31,280 --> 00:20:33,120
are coverage reports which i mentioned

571
00:20:33,120 --> 00:20:35,280
before are useful for determining which

572
00:20:35,280 --> 00:20:38,240
fuzzer to run but are also just nice for

573
00:20:38,240 --> 00:20:40,559
developers because they could see

574
00:20:40,559 --> 00:20:42,159
which parts of the code

575
00:20:42,159 --> 00:20:43,679
are being tested during fuzzing and

576
00:20:43,679 --> 00:20:47,480
which parts are being missed

577
00:20:48,640 --> 00:20:49,520
so

578
00:20:49,520 --> 00:20:52,000
now hopefully um

579
00:20:52,000 --> 00:20:54,640
you know we have enough background to

580
00:20:54,640 --> 00:20:56,320
like understand what cluster fuzz light

581
00:20:56,320 --> 00:20:58,640
does and you know maybe some of you are

582
00:20:58,640 --> 00:21:03,840
eager to see uh how you can use it so

583
00:21:04,000 --> 00:21:05,200
um

584
00:21:05,200 --> 00:21:06,960
as i said like it should be very easy to

585
00:21:06,960 --> 00:21:08,960
set up cluster fuzz light it's built for

586
00:21:08,960 --> 00:21:10,799
this purpose um you know we have many

587
00:21:10,799 --> 00:21:13,280
users and that sort of evidence for that

588
00:21:13,280 --> 00:21:15,280
uh the first thing you need to do to use

589
00:21:15,280 --> 00:21:16,799
cluster fuzz light

590
00:21:16,799 --> 00:21:17,760
is

591
00:21:17,760 --> 00:21:20,799
write lib fuzzer harnesses um this is

592
00:21:20,799 --> 00:21:22,559
basically just

593
00:21:22,559 --> 00:21:24,640
consists of implementing like an api

594
00:21:24,640 --> 00:21:26,960
that lib fuzzer will call into and this

595
00:21:26,960 --> 00:21:28,960
api just needs to accept like a byte

596
00:21:28,960 --> 00:21:31,280
buffer and you pass that byte buffer to

597
00:21:31,280 --> 00:21:33,280
the code you want to fuzz

598
00:21:33,280 --> 00:21:35,360
um

599
00:21:35,360 --> 00:21:37,600
this is fairly easy to do like you see

600
00:21:37,600 --> 00:21:40,159
this example uh from openssl or i think

601
00:21:40,159 --> 00:21:41,840
boring ssl

602
00:21:41,840 --> 00:21:43,919
is only about 20 lines

603
00:21:43,919 --> 00:21:45,120
and there's a lot more details on

604
00:21:45,120 --> 00:21:47,840
writing the buzzer harnesses uh at the

605
00:21:47,840 --> 00:21:50,000
lib buzzer documentation

606
00:21:50,000 --> 00:21:51,360
um

607
00:21:51,360 --> 00:21:52,720
and then the next step is just sort of

608
00:21:52,720 --> 00:21:54,799
like configuration so that cluster fuzz

609
00:21:54,799 --> 00:21:57,600
light can build your fuzzers

610
00:21:57,600 --> 00:21:58,720
this starts

611
00:21:58,720 --> 00:22:00,240
this just consists of a bunch of other

612
00:22:00,240 --> 00:22:03,679
small files so first you've got um

613
00:22:03,679 --> 00:22:06,720
a yaml file that just declares the

614
00:22:06,720 --> 00:22:09,440
language your project is written in um

615
00:22:09,440 --> 00:22:11,360
you got like a docker file just to

616
00:22:11,360 --> 00:22:12,799
install any dependencies you need to

617
00:22:12,799 --> 00:22:13,760
build

618
00:22:13,760 --> 00:22:16,000
the project and then finally you have a

619
00:22:16,000 --> 00:22:17,679
bash script that is really just a

620
00:22:17,679 --> 00:22:19,440
wrapper around your own build system to

621
00:22:19,440 --> 00:22:23,039
build uh fuzzers uh for your project

622
00:22:23,039 --> 00:22:25,200
and that's really all you need

623
00:22:25,200 --> 00:22:27,120
to like

624
00:22:27,120 --> 00:22:29,679
support any of the core functionality of

625
00:22:29,679 --> 00:22:31,280
cluster fuzz light

626
00:22:31,280 --> 00:22:33,360
but to actually uh run it you're going

627
00:22:33,360 --> 00:22:35,039
to need to you know figure out where

628
00:22:35,039 --> 00:22:36,799
where you want to do that and so

629
00:22:36,799 --> 00:22:38,960
um i think i've like mentioned it a few

630
00:22:38,960 --> 00:22:41,200
times but like it could be run uh

631
00:22:41,200 --> 00:22:42,320
cluster buzz light can be run in

632
00:22:42,320 --> 00:22:44,320
different ci systems so we sport like

633
00:22:44,320 --> 00:22:47,440
google cloud build uh we support pro um

634
00:22:47,440 --> 00:22:49,039
you know it's easy to add support for

635
00:22:49,039 --> 00:22:51,600
other systems and of course we support

636
00:22:51,600 --> 00:22:54,080
like github actions which i i think have

637
00:22:54,080 --> 00:22:55,600
probably like exploded somewhat in

638
00:22:55,600 --> 00:22:57,600
popularity just because you know so much

639
00:22:57,600 --> 00:22:59,440
code is developed on github and this

640
00:22:59,440 --> 00:23:03,679
just makes it convenient um so

641
00:23:03,679 --> 00:23:06,320
to to you know take advantage of cluster

642
00:23:06,320 --> 00:23:07,840
fuzz light once you've done those

643
00:23:07,840 --> 00:23:09,520
previous steps you basically could just

644
00:23:09,520 --> 00:23:12,240
like copy and paste uh these

645
00:23:12,240 --> 00:23:15,120
you know 20 line uh or 30 line workflow

646
00:23:15,120 --> 00:23:19,200
files uh to use uh cluster fuzz lite um

647
00:23:19,200 --> 00:23:21,200
so it you know it's really trivial to

648
00:23:21,200 --> 00:23:23,679
set up i think especially especially if

649
00:23:23,679 --> 00:23:25,760
you know like fuzzing already and that

650
00:23:25,760 --> 00:23:28,000
you're familiar with fuzzing um

651
00:23:28,000 --> 00:23:30,400
and you know actually the this previous

652
00:23:30,400 --> 00:23:32,880
process is actually quite similar to oss

653
00:23:32,880 --> 00:23:35,280
fuzz so you know if you've used oss fuzz

654
00:23:35,280 --> 00:23:38,480
on an open source project and you now

655
00:23:38,480 --> 00:23:40,559
are on a proprietary project and want to

656
00:23:40,559 --> 00:23:42,000
use um

657
00:23:42,000 --> 00:23:43,840
you know want to do fuzzing you should

658
00:23:43,840 --> 00:23:47,600
be pretty familiar with this process

659
00:23:48,000 --> 00:23:50,880
so uh some like future ideas uh for

660
00:23:50,880 --> 00:23:52,320
extending this even further that i've

661
00:23:52,320 --> 00:23:54,400
had um just because we got a bit of time

662
00:23:54,400 --> 00:23:55,200
left

663
00:23:55,200 --> 00:23:56,960
uh so i mentioned

664
00:23:56,960 --> 00:23:59,360
that uh clusterfuz lite can use

665
00:23:59,360 --> 00:24:02,159
uh coverage information and diffs to

666
00:24:02,159 --> 00:24:03,360
target

667
00:24:03,360 --> 00:24:05,039
you know to run fuzzers that actually

668
00:24:05,039 --> 00:24:05,919
affect

669
00:24:05,919 --> 00:24:07,840
the change code

670
00:24:07,840 --> 00:24:09,919
but one thing that would be interesting

671
00:24:09,919 --> 00:24:12,159
is if we know which code has changed

672
00:24:12,159 --> 00:24:14,640
could we tell the fuzzer to focus on

673
00:24:14,640 --> 00:24:16,960
that particular area of the code

674
00:24:16,960 --> 00:24:19,679
and there are some tools that uh have

675
00:24:19,679 --> 00:24:21,520
been released that do stuff like this

676
00:24:21,520 --> 00:24:24,080
and maybe they would be useful in a ci

677
00:24:24,080 --> 00:24:26,320
context actually one reason why i'm not

678
00:24:26,320 --> 00:24:27,360
using i think like the current

679
00:24:27,360 --> 00:24:29,360
generation of them is just because i

680
00:24:29,360 --> 00:24:31,360
think it's um i was a bit worried about

681
00:24:31,360 --> 00:24:32,640
like the speed

682
00:24:32,640 --> 00:24:34,000
uh

683
00:24:34,000 --> 00:24:36,240
like there's some extra steps and if it

684
00:24:36,240 --> 00:24:38,480
slows down fuzzing uh it's probably not

685
00:24:38,480 --> 00:24:40,640
worth it for me

686
00:24:40,640 --> 00:24:42,159
but if the fuzzer were capable of

687
00:24:42,159 --> 00:24:44,400
knowing um what it's fuzzing you know

688
00:24:44,400 --> 00:24:45,919
maybe we could use better heuristics

689
00:24:45,919 --> 00:24:47,360
than just quitting after 10 minutes like

690
00:24:47,360 --> 00:24:49,440
maybe we could say you know if we've

691
00:24:49,440 --> 00:24:52,000
tested this code like a billion times uh

692
00:24:52,000 --> 00:24:53,760
just quit because you know we're pretty

693
00:24:53,760 --> 00:24:55,760
confident there's no bugs in there

694
00:24:55,760 --> 00:24:58,320
and finally like i think one thing that

695
00:24:58,320 --> 00:25:00,480
is sort of lacking so right like i said

696
00:25:00,480 --> 00:25:02,400
fuzzing uh sort of started on people's

697
00:25:02,400 --> 00:25:04,640
like desktops and i want to make it user

698
00:25:04,640 --> 00:25:06,159
friendly like i want to make it maybe

699
00:25:06,159 --> 00:25:08,159
end up back on the user's desktop but be

700
00:25:08,159 --> 00:25:10,320
user friendly this time in a way that

701
00:25:10,320 --> 00:25:12,480
like developers would use and not just

702
00:25:12,480 --> 00:25:15,120
um you know like hackers would use so

703
00:25:15,120 --> 00:25:16,480
right like

704
00:25:16,480 --> 00:25:18,240
you don't only run unit tests into your

705
00:25:18,240 --> 00:25:20,480
ci you run it locally maybe like you

706
00:25:20,480 --> 00:25:22,240
should have a way to quickly run these

707
00:25:22,240 --> 00:25:24,320
uh fuzzers in like a cluster fuzz light

708
00:25:24,320 --> 00:25:28,520
style way uh locally

709
00:25:28,559 --> 00:25:30,480
so to conclude my talk uh you should

710
00:25:30,480 --> 00:25:32,080
fuzz your code because if you don't

711
00:25:32,080 --> 00:25:33,679
someone else will and find

712
00:25:33,679 --> 00:25:35,440
vulnerabilities in them

713
00:25:35,440 --> 00:25:37,679
uh in your code and

714
00:25:37,679 --> 00:25:40,720
ci fuzzing can really help catch a lot

715
00:25:40,720 --> 00:25:42,960
of vulnerabilities before they're merged

716
00:25:42,960 --> 00:25:46,880
into your code and really um you know

717
00:25:46,880 --> 00:25:48,880
really it's like a very cheap way to get

718
00:25:48,880 --> 00:25:51,039
a lot of the benefits of continuous

719
00:25:51,039 --> 00:25:53,760
fuzzing and finally cluster fuzz light

720
00:25:53,760 --> 00:25:58,799
makes it very easy to fuzz as part of ci

721
00:25:58,799 --> 00:26:01,279
so to end off um

722
00:26:01,279 --> 00:26:03,679
we can do a q a but

723
00:26:03,679 --> 00:26:06,080
here's just like my contact info and a

724
00:26:06,080 --> 00:26:09,120
link to the cluster fuzz light repo

725
00:26:09,120 --> 00:26:10,400
and if you have any questions you know

726
00:26:10,400 --> 00:26:12,960
feel free to ask them now or reach out

727
00:26:12,960 --> 00:26:16,240
to me by uh you know by email or file an

728
00:26:16,240 --> 00:26:18,480
issue i'm very eager to like help people

729
00:26:18,480 --> 00:26:20,799
thanks

730
00:26:21,919 --> 00:26:23,520
nice jonathan that was that was super

731
00:26:23,520 --> 00:26:26,640
insightful and interesting um thanks and

732
00:26:26,640 --> 00:26:28,400
i had i'll be honest with you i had to

733
00:26:28,400 --> 00:26:30,080
step away for a moment and i came back

734
00:26:30,080 --> 00:26:31,840
and the first thing i heard was cluster

735
00:26:31,840 --> 00:26:33,840
fuzz and i just burst it out laughing

736
00:26:33,840 --> 00:26:35,919
because you know i love the play on the

737
00:26:35,919 --> 00:26:37,679
name there yeah it's one of the better

738
00:26:37,679 --> 00:26:39,760
name tools we have yeah yeah and

739
00:26:39,760 --> 00:26:42,320
somebody zack curtis in the chat said uh

740
00:26:42,320 --> 00:26:44,080
please tell me the next name will be

741
00:26:44,080 --> 00:26:46,080
fuzz lightyear

742
00:26:46,080 --> 00:26:48,159
uh there there's some other like uh

743
00:26:48,159 --> 00:26:49,520
people involved in fuzzing that wanted

744
00:26:49,520 --> 00:26:51,840
to name some tool that but that's not uh

745
00:26:51,840 --> 00:26:53,039
i think we're not going to go with that

746
00:26:53,039 --> 00:26:55,440
name okay okay fair enough fair enough

747
00:26:55,440 --> 00:26:57,120
cool i was going to call it diet cluster

748
00:26:57,120 --> 00:27:00,080
fuzz initially though

749
00:27:00,960 --> 00:27:03,039
the european version apparently yeah

750
00:27:03,039 --> 00:27:05,200
yeah exactly the light beer

751
00:27:05,200 --> 00:27:07,120
so steve asked a couple questions i

752
00:27:07,120 --> 00:27:08,480
paraphrased one because i think you

753
00:27:08,480 --> 00:27:09,840
might have answered it when you show the

754
00:27:09,840 --> 00:27:12,000
demonstration but the the first being

755
00:27:12,000 --> 00:27:13,360
that and i'm

756
00:27:13,360 --> 00:27:14,880
forgive me steve if i paraphrase this

757
00:27:14,880 --> 00:27:16,559
incorrectly but does implementing

758
00:27:16,559 --> 00:27:17,919
fuzzing in our pipelines require

759
00:27:17,919 --> 00:27:19,600
deploying the applications and do you

760
00:27:19,600 --> 00:27:20,960
have any experiences employment

761
00:27:20,960 --> 00:27:22,399
implementing it like that

762
00:27:22,399 --> 00:27:23,600
so i'm not

763
00:27:23,600 --> 00:27:25,360
yeah do you want to go on no go go right

764
00:27:25,360 --> 00:27:28,000
ahead yeah so i'm not entirely uh

765
00:27:28,000 --> 00:27:30,720
100 sure what you mean by deploying like

766
00:27:30,720 --> 00:27:32,399
i think like i guess if you had some

767
00:27:32,399 --> 00:27:34,080
like sort of cms like you would mean

768
00:27:34,080 --> 00:27:36,080
like deploying the entire cms to like a

769
00:27:36,080 --> 00:27:39,679
web server um typically uh these fuzzers

770
00:27:39,679 --> 00:27:41,520
that i'm talking about are run on like

771
00:27:41,520 --> 00:27:43,520
almost like the unit test level

772
00:27:43,520 --> 00:27:44,880
uh so

773
00:27:44,880 --> 00:27:46,559
you know you wouldn't involve

774
00:27:46,559 --> 00:27:48,480
um deploying your whole application you

775
00:27:48,480 --> 00:27:49,919
would just like

776
00:27:49,919 --> 00:27:50,720
you know

777
00:27:50,720 --> 00:27:51,440
be

778
00:27:51,440 --> 00:27:52,880
writing something that looks like a unit

779
00:27:52,880 --> 00:27:55,279
has to test like a parser or

780
00:27:55,279 --> 00:27:56,640
you know just like a smaller component

781
00:27:56,640 --> 00:27:58,640
than like a whole web app i'd say yeah

782
00:27:58,640 --> 00:28:00,480
when you were showing it it reminded me

783
00:28:00,480 --> 00:28:02,080
of fixture testing where you write a

784
00:28:02,080 --> 00:28:04,799
harness around a a piece of code or a

785
00:28:04,799 --> 00:28:07,039
section or a library and and you're

786
00:28:07,039 --> 00:28:08,480
latching into it like you know like a

787
00:28:08,480 --> 00:28:10,240
wiring harness would be right yeah

788
00:28:10,240 --> 00:28:13,600
exactly yeah very cool uh a second

789
00:28:13,600 --> 00:28:16,960
question there was is there support for

790
00:28:16,960 --> 00:28:18,720
containers or does the application need

791
00:28:18,720 --> 00:28:20,480
to be running locally for cluster fuzz

792
00:28:20,480 --> 00:28:21,600
light

793
00:28:21,600 --> 00:28:23,840
um so all of the cluster fuzz light

794
00:28:23,840 --> 00:28:26,720
really sort of happens in docker um

795
00:28:26,720 --> 00:28:28,480
uh and that's actually like maybe like a

796
00:28:28,480 --> 00:28:30,000
restriction like you know if you can't

797
00:28:30,000 --> 00:28:32,880
build your project done like ubuntu um

798
00:28:32,880 --> 00:28:35,200
uh like right now we're not like

799
00:28:35,200 --> 00:28:37,919
uh supporting other other sorts of like

800
00:28:37,919 --> 00:28:41,360
you know distros or os's um

801
00:28:41,360 --> 00:28:42,799
it doesn't need the application doesn't

802
00:28:42,799 --> 00:28:44,559
need to be running at all really and not

803
00:28:44,559 --> 00:28:46,000
locally like you know cluster buzz

804
00:28:46,000 --> 00:28:47,840
lights really like up like it was really

805
00:28:47,840 --> 00:28:50,000
built to run on github actions and so

806
00:28:50,000 --> 00:28:51,440
you know it definitely doesn't need

807
00:28:51,440 --> 00:28:54,159
anything local

808
00:28:54,240 --> 00:28:56,320
very cool so i had a question my own

809
00:28:56,320 --> 00:28:57,760
actually while you're talking about it

810
00:28:57,760 --> 00:28:59,760
um so

811
00:28:59,760 --> 00:29:02,399
if fuzzing finds an actual defect in the

812
00:29:02,399 --> 00:29:04,399
code and um would it would it be a

813
00:29:04,399 --> 00:29:06,799
normal process then for me to go and add

814
00:29:06,799 --> 00:29:08,640
unit tests to

815
00:29:08,640 --> 00:29:09,919
wrap around that so i'm not having to

816
00:29:09,919 --> 00:29:12,000
rely just on the fuzzers to find you

817
00:29:12,000 --> 00:29:13,520
know you don't want to use a buzzer for

818
00:29:13,520 --> 00:29:15,520
regression i guess right

819
00:29:15,520 --> 00:29:17,840
yeah actually so um like we definitely

820
00:29:17,840 --> 00:29:19,919
recommended that uh in the past cluster

821
00:29:19,919 --> 00:29:22,320
buzz light actually uh will catch like

822
00:29:22,320 --> 00:29:24,159
just like automatically um you know

823
00:29:24,159 --> 00:29:25,360
catch any regressions that it's

824
00:29:25,360 --> 00:29:26,960
previously found so

825
00:29:26,960 --> 00:29:29,600
um yeah like you can rely like and it

826
00:29:29,600 --> 00:29:30,960
can determine like we can

827
00:29:30,960 --> 00:29:34,240
deterministically find them uh so like

828
00:29:34,240 --> 00:29:36,799
you can't you you can but yeah it's

829
00:29:36,799 --> 00:29:38,880
pretty common um like in chrome when

830
00:29:38,880 --> 00:29:41,760
someone uh would find like uh you know

831
00:29:41,760 --> 00:29:43,919
if they were like a bug in v8 chrome's

832
00:29:43,919 --> 00:29:46,080
javascript engine um that were found

833
00:29:46,080 --> 00:29:47,600
through fuzzing people would oftentimes

834
00:29:47,600 --> 00:29:50,000
write like a unit test uh just to ensure

835
00:29:50,000 --> 00:29:51,200
that you know that bug wasn't

836
00:29:51,200 --> 00:29:52,480
reintroduced right just to

837
00:29:52,480 --> 00:29:54,080
deterministically ensure it rather than

838
00:29:54,080 --> 00:29:57,279
like relying on the randomness

839
00:29:57,279 --> 00:29:59,679
very cool ryan anything you wanted to

840
00:29:59,679 --> 00:30:01,679
ask yeah yeah my so my question was i

841
00:30:01,679 --> 00:30:02,799
believe i saw at one point in your

842
00:30:02,799 --> 00:30:04,399
slides that the programming languages

843
00:30:04,399 --> 00:30:05,679
that are currently supported is there

844
00:30:05,679 --> 00:30:08,240
potential and it was like c c plus plus

845
00:30:08,240 --> 00:30:10,960
python rust is there potential in the

846
00:30:10,960 --> 00:30:12,960
future to expand what programming

847
00:30:12,960 --> 00:30:15,440
languages and ecosystems are supported

848
00:30:15,440 --> 00:30:18,320
yeah so i think like probably any ll any

849
00:30:18,320 --> 00:30:20,159
lvm language will be pretty easy to

850
00:30:20,159 --> 00:30:21,760
support um just because like a lot of

851
00:30:21,760 --> 00:30:23,919
our tooling works well with that

852
00:30:23,919 --> 00:30:25,200
uh

853
00:30:25,200 --> 00:30:26,640
i think we're looking to expand it to

854
00:30:26,640 --> 00:30:28,399
javascript but um

855
00:30:28,399 --> 00:30:30,240
i don't i don't know i'm not i'm not hip

856
00:30:30,240 --> 00:30:31,760
enough to know what other languages

857
00:30:31,760 --> 00:30:33,279
there are besides those that people

858
00:30:33,279 --> 00:30:34,559
would want to i guess maybe like

859
00:30:34,559 --> 00:30:37,039
php uh is probably another pretty

860
00:30:37,039 --> 00:30:38,880
popular one that we're gonna miss or

861
00:30:38,880 --> 00:30:40,000
pearl but

862
00:30:40,000 --> 00:30:42,480
yeah i i don't really see us

863
00:30:42,480 --> 00:30:44,320
uh at least like a lot of these tools

864
00:30:44,320 --> 00:30:46,399
end up um getting developed by like

865
00:30:46,399 --> 00:30:48,000
colleagues of mine and like since you

866
00:30:48,000 --> 00:30:50,080
know we don't really use like php very

867
00:30:50,080 --> 00:30:51,760
much like it's just probably

868
00:30:51,760 --> 00:30:52,880
you know someone else would have to

869
00:30:52,880 --> 00:30:54,640
implement it so you're telling me q

870
00:30:54,640 --> 00:30:56,480
basic is out of the question

871
00:30:56,480 --> 00:31:00,399
uh yeah probably okay damn all right

872
00:31:00,399 --> 00:31:02,240
well thank you so much jonathan this was

873
00:31:02,240 --> 00:31:04,080
uh super helpful appreciate you joining

874
00:31:04,080 --> 00:31:06,399
us and teaching me and everyone else

875
00:31:06,399 --> 00:31:09,360
here about fuzzing and uh yeah

876
00:31:09,360 --> 00:31:12,030
appreciate you yeah thanks

877
00:31:12,030 --> 00:31:15,500
[Music]

