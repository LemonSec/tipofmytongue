1
00:00:00,599 --> 00:00:03,120
our next session is from South Fargo a

2
00:00:03,120 --> 00:00:06,509
developer advocate from Google and we're

3
00:00:06,509 --> 00:00:07,950
going to be talking some secrets in

4
00:00:07,950 --> 00:00:12,290
service so please give it up for Seth

5
00:00:14,599 --> 00:00:22,199
all right hi everyone hi Jeff and

6
00:00:22,199 --> 00:00:24,539
everyone else cool so thank you all so

7
00:00:24,539 --> 00:00:25,890
much for coming

8
00:00:25,890 --> 00:00:31,529
I have zero slides I'm serious this is

9
00:00:31,529 --> 00:00:33,239
the only slide that I have and it's not

10
00:00:33,239 --> 00:00:36,570
even a slide it's just my Twitter handle

11
00:00:36,570 --> 00:00:38,040
feel free to tweet at me during the talk

12
00:00:38,040 --> 00:00:40,860
after the talk my DMS are also open but

13
00:00:40,860 --> 00:00:42,840
this is like this is a smaller group so

14
00:00:42,840 --> 00:00:43,800
we're gonna be a little bit interactive

15
00:00:43,800 --> 00:00:46,379
we're gonna write some code together but

16
00:00:46,379 --> 00:00:49,140
what we're doing is we are following the

17
00:00:49,140 --> 00:00:51,690
hypothetical journey of this application

18
00:00:51,690 --> 00:00:53,699
that I've written I'll show it to you in

19
00:00:53,699 --> 00:00:56,250
a minute please note that I have no

20
00:00:56,250 --> 00:00:58,320
design skills so please don't make fun

21
00:00:58,320 --> 00:01:01,109
of it when you see it but this app has a

22
00:01:01,109 --> 00:01:03,329
few requirements the biggest of which is

23
00:01:03,329 --> 00:01:05,369
it needs to talk to a third-party

24
00:01:05,369 --> 00:01:07,860
datastore Redis in this example but it

25
00:01:07,860 --> 00:01:09,180
could be any database that you might

26
00:01:09,180 --> 00:01:11,100
think of and we have to find a way to

27
00:01:11,100 --> 00:01:13,799
get the credential for our server list

28
00:01:13,799 --> 00:01:16,380
application to authenticate to our

29
00:01:16,380 --> 00:01:18,390
database so what we're gonna do is we're

30
00:01:18,390 --> 00:01:21,030
gonna follow kind of a journey of very

31
00:01:21,030 --> 00:01:23,340
insecure to as secure as we can possibly

32
00:01:23,340 --> 00:01:26,040
be by continuously deploying and

33
00:01:26,040 --> 00:01:27,900
iterating on this application so let's

34
00:01:27,900 --> 00:01:29,070
take a look at what the application

35
00:01:29,070 --> 00:01:30,420
looks like and then we'll take a look at

36
00:01:30,420 --> 00:01:32,250
the source code under the hood like I

37
00:01:32,250 --> 00:01:34,890
said not a designer this is the

38
00:01:34,890 --> 00:01:36,689
application I've written it's a very

39
00:01:36,689 --> 00:01:39,810
simple 1990s geo city site every time

40
00:01:39,810 --> 00:01:42,899
you visit the web site you increment the

41
00:01:42,899 --> 00:01:45,750
counselor so every time i refresh here

42
00:01:45,750 --> 00:01:48,509
were incrementing the visitor counter

43
00:01:48,509 --> 00:01:50,729
and then because I'm an admin and I'm

44
00:01:50,729 --> 00:01:53,369
logged in I can reset the counter and

45
00:01:53,369 --> 00:01:56,100
then it resets back to 1 and again every

46
00:01:56,100 --> 00:01:57,899
time someone visits this website they'll

47
00:01:57,899 --> 00:02:00,329
get a new hit counter and the way we're

48
00:02:00,329 --> 00:02:02,520
implementing that is on each visit to

49
00:02:02,520 --> 00:02:04,829
this website the application makes a

50
00:02:04,829 --> 00:02:07,020
connection to Redis database and

51
00:02:07,020 --> 00:02:08,970
increments a counter in the Redis

52
00:02:08,970 --> 00:02:11,970
database very straightforward lots of

53
00:02:11,970 --> 00:02:13,920
CSS and really good design as you

54
00:02:13,920 --> 00:02:16,950
I'll see and with that let's take a look

55
00:02:16,950 --> 00:02:19,590
at the code so the application is

56
00:02:19,590 --> 00:02:22,200
actually written and go which might be

57
00:02:22,200 --> 00:02:23,489
weird to some people you're like oh you

58
00:02:23,489 --> 00:02:24,780
see serverless and you kind of just

59
00:02:24,780 --> 00:02:26,520
assume no js' that's like the natural

60
00:02:26,520 --> 00:02:28,739
pairing that we make in our mind but

61
00:02:28,739 --> 00:02:30,060
I've actually written this application

62
00:02:30,060 --> 00:02:32,670
in go for a number of reasons the

63
00:02:32,670 --> 00:02:33,840
biggest of which is I think it breaks

64
00:02:33,840 --> 00:02:35,100
the paradigm of what we think is

65
00:02:35,100 --> 00:02:36,870
serverless and this is still an

66
00:02:36,870 --> 00:02:38,850
application that's going to scale

67
00:02:38,850 --> 00:02:40,290
independently both horizontally and

68
00:02:40,290 --> 00:02:42,480
vertically it's gonna be wrapped up in a

69
00:02:42,480 --> 00:02:44,190
container so it could be any language or

70
00:02:44,190 --> 00:02:47,910
any runtime but the key piece here is

71
00:02:47,910 --> 00:02:49,680
that our application needs some

72
00:02:49,680 --> 00:02:52,080
configuration and to start out I'm using

73
00:02:52,080 --> 00:02:54,540
environment variables to store that

74
00:02:54,540 --> 00:02:57,239
configuration specifically I'm asking

75
00:02:57,239 --> 00:03:01,049
for the Redis host which is the IP

76
00:03:01,049 --> 00:03:03,000
address where the Redis instance is

77
00:03:03,000 --> 00:03:05,370
living the port on which Redis is

78
00:03:05,370 --> 00:03:07,260
listening and I'm just gonna default

79
00:03:07,260 --> 00:03:09,660
those to localhost and 63 79 if they're

80
00:03:09,660 --> 00:03:12,060
not specified and then I have my Redis

81
00:03:12,060 --> 00:03:13,830
password which I'm also passing in via

82
00:03:13,830 --> 00:03:15,930
an environment variable and later down

83
00:03:15,930 --> 00:03:18,090
here when we connect to Redis we pass in

84
00:03:18,090 --> 00:03:20,160
that password to authenticate to Retta

85
00:03:20,160 --> 00:03:22,350
so we are being super secure we're not

86
00:03:22,350 --> 00:03:23,970
just leaving you know publicly exposed

87
00:03:23,970 --> 00:03:25,980
retinas with no authentication we're

88
00:03:25,980 --> 00:03:27,810
putting our password on our Redis

89
00:03:27,810 --> 00:03:29,430
authentication and we have to pass it

90
00:03:29,430 --> 00:03:31,980
into our application so now when we want

91
00:03:31,980 --> 00:03:35,670
to deploy our application I'm gonna

92
00:03:35,670 --> 00:03:37,650
package it up and deploy it as a darker

93
00:03:37,650 --> 00:03:39,989
container so what I'm gonna do is I'm

94
00:03:39,989 --> 00:03:42,810
gonna build this container and then I'm

95
00:03:42,810 --> 00:03:44,600
going to push that container to

96
00:03:44,600 --> 00:03:47,820
container registry and then I'm going to

97
00:03:47,820 --> 00:03:50,280
deploy that application now slight

98
00:03:50,280 --> 00:03:52,170
disclaimer I'm using all Google stuff

99
00:03:52,170 --> 00:03:53,400
because that's why I work and then I

100
00:03:53,400 --> 00:03:54,780
don't have to pay for it

101
00:03:54,780 --> 00:03:57,090
but all of this stuff is not Google

102
00:03:57,090 --> 00:03:59,010
specific like everything is very generic

103
00:03:59,010 --> 00:04:00,750
it applies to lambda it applies to Azure

104
00:04:00,750 --> 00:04:03,359
functions it applies to open fast and so

105
00:04:03,359 --> 00:04:05,250
if you see like g-cloud commands it's

106
00:04:05,250 --> 00:04:06,750
not a vendor pitch everything here is

107
00:04:06,750 --> 00:04:08,940
very like cloud agnostic and vendor

108
00:04:08,940 --> 00:04:11,760
agnostic so we're building a container

109
00:04:11,760 --> 00:04:12,750
we're pushing the container and then

110
00:04:12,750 --> 00:04:14,639
we're deploying the container and so I'm

111
00:04:14,639 --> 00:04:17,430
gonna go ahead and do that sorry I

112
00:04:17,430 --> 00:04:18,539
already did that that's what you're

113
00:04:18,539 --> 00:04:22,220
seeing here and there's a few

114
00:04:22,220 --> 00:04:24,030
vulnerabilities that I've introduced

115
00:04:24,030 --> 00:04:26,220
into this application and I hope to show

116
00:04:26,220 --> 00:04:26,950
you

117
00:04:26,950 --> 00:04:28,900
that storing plaintext secrets and

118
00:04:28,900 --> 00:04:31,270
environment variables is literally never

119
00:04:31,270 --> 00:04:33,490
the right solution you should never

120
00:04:33,490 --> 00:04:35,080
store plaintext passwords and

121
00:04:35,080 --> 00:04:36,670
environment variables and let me show

122
00:04:36,670 --> 00:04:39,250
you why so there's this run reset the

123
00:04:39,250 --> 00:04:40,720
counter button and every time I click

124
00:04:40,720 --> 00:04:43,180
that button it resets the counter now I

125
00:04:43,180 --> 00:04:45,550
was a security penetration tester and a

126
00:04:45,550 --> 00:04:47,560
previous life so I'm gonna actually like

127
00:04:47,560 --> 00:04:49,470
kind of inspect what this link does and

128
00:04:49,470 --> 00:04:54,970
it turns out that this link just sets a

129
00:04:54,970 --> 00:04:57,970
count parameter to this additional URL

130
00:04:57,970 --> 00:05:01,090
path reset counter so I'm curious what

131
00:05:01,090 --> 00:05:02,680
happens if I set the counter to like

132
00:05:02,680 --> 00:05:05,800
negative 100 Oh interesting there

133
00:05:05,800 --> 00:05:07,240
doesn't appear to be any validation on

134
00:05:07,240 --> 00:05:10,210
this endpoint and oh it's cool the site

135
00:05:10,210 --> 00:05:13,510
still functions as intended but what

136
00:05:13,510 --> 00:05:17,770
happens if I reset the counter to banana

137
00:05:17,770 --> 00:05:23,980
Oh crash the whole thing and if you work

138
00:05:23,980 --> 00:05:26,440
in any popular web framework like rails

139
00:05:26,440 --> 00:05:29,620
or Django they run in this really

140
00:05:29,620 --> 00:05:32,830
helpful mode where by default unless you

141
00:05:32,830 --> 00:05:34,330
set some extra configuration options

142
00:05:34,330 --> 00:05:36,130
they'll give you these really nice debug

143
00:05:36,130 --> 00:05:38,200
pages for local development which is

144
00:05:38,200 --> 00:05:40,630
like hey here's you know the request URI

145
00:05:40,630 --> 00:05:42,460
got here's all the packages here's all

146
00:05:42,460 --> 00:05:45,340
the system level dependencies and here's

147
00:05:45,340 --> 00:05:47,800
the entire environment for the

148
00:05:47,800 --> 00:05:50,110
application so we have this application

149
00:05:50,110 --> 00:05:51,460
this is deployed publicly you can

150
00:05:51,460 --> 00:05:52,930
actually hit the URL there and the

151
00:05:52,930 --> 00:05:54,730
browser bar and we can see that our

152
00:05:54,730 --> 00:05:57,580
Redis host our Redis password and our

153
00:05:57,580 --> 00:05:59,920
Retta support are all just in there in

154
00:05:59,920 --> 00:06:02,680
plain text and so reason number one why

155
00:06:02,680 --> 00:06:04,330
you don't want to store passwords in

156
00:06:04,330 --> 00:06:05,950
plain text in environment variables is

157
00:06:05,950 --> 00:06:07,420
that if you miss configure your

158
00:06:07,420 --> 00:06:09,850
application and I'm not trying to pick

159
00:06:09,850 --> 00:06:11,410
on any particular language or framework

160
00:06:11,410 --> 00:06:13,750
here you you run the risk of something

161
00:06:13,750 --> 00:06:15,760
like this happening write dotnet had

162
00:06:15,760 --> 00:06:17,260
this for a very long time where if you

163
00:06:17,260 --> 00:06:18,730
crash net and it wasn't in production

164
00:06:18,730 --> 00:06:20,080
mode it just gave you a full dump of

165
00:06:20,080 --> 00:06:21,820
everything and that was actually the

166
00:06:21,820 --> 00:06:23,920
cause of a number of vulnerabilities for

167
00:06:23,920 --> 00:06:26,950
dotnet applications right so we could

168
00:06:26,950 --> 00:06:28,750
fix this right we could set up C ICD

169
00:06:28,750 --> 00:06:30,040
pipelines to make sure that we always

170
00:06:30,040 --> 00:06:33,370
deploy with the environment variable

171
00:06:33,370 --> 00:06:36,100
production set to true or just set

172
00:06:36,100 --> 00:06:38,620
that's important it tells us that we

173
00:06:38,620 --> 00:06:40,310
need to do that

174
00:06:40,310 --> 00:06:41,270
but the other thing we could do is we

175
00:06:41,270 --> 00:06:42,260
could just not store environment

176
00:06:42,260 --> 00:06:44,660
variables in plain text so let me show

177
00:06:44,660 --> 00:06:46,820
you what it looks like if we fix this

178
00:06:46,820 --> 00:06:49,040
vulnerability so I'm just gonna come in

179
00:06:49,040 --> 00:06:50,870
here and I'm gonna add another

180
00:06:50,870 --> 00:06:53,510
environment variable to say M equals

181
00:06:53,510 --> 00:06:55,840
production oops

182
00:06:55,840 --> 00:06:58,460
I'm gonna save this and then I'm going

183
00:06:58,460 --> 00:07:06,169
to deploy the application and we built a

184
00:07:06,169 --> 00:07:07,850
new container and now we're pushing up

185
00:07:07,850 --> 00:07:09,410
that container and now we're deploying

186
00:07:09,410 --> 00:07:11,900
that container so it takes you know

187
00:07:11,900 --> 00:07:13,160
somewhere between five to ten seconds

188
00:07:13,160 --> 00:07:14,950
it's a pretty fast development loop

189
00:07:14,950 --> 00:07:20,030
we're out some traffic we wait maybe a

190
00:07:20,030 --> 00:07:23,390
little bit longer all right cool and

191
00:07:23,390 --> 00:07:24,740
then we come back here to the browser

192
00:07:24,740 --> 00:07:27,530
and we refresh and hopefully we get like

193
00:07:27,530 --> 00:07:29,540
a generic an error occurred right so

194
00:07:29,540 --> 00:07:30,800
we've patched the vulnerability we can't

195
00:07:30,800 --> 00:07:33,260
possibly be vulnerable anymore we've

196
00:07:33,260 --> 00:07:35,180
added that check to our CSE didn't pay

197
00:07:35,180 --> 00:07:36,380
planned so there's absolutely no way we

198
00:07:36,380 --> 00:07:37,900
could ever leak the credential right

199
00:07:37,900 --> 00:07:41,720
you're supposed to say problem so we've

200
00:07:41,720 --> 00:07:43,400
patched this vulnerability but we

201
00:07:43,400 --> 00:07:45,260
haven't addressed an entire other

202
00:07:45,260 --> 00:07:47,330
surface area which is a software supply

203
00:07:47,330 --> 00:07:50,000
chain attack so it turns out that

204
00:07:50,000 --> 00:07:53,330
because I wrote this application there

205
00:07:53,330 --> 00:07:57,020
is a vulnerable package in this

206
00:07:57,020 --> 00:07:59,120
particular application so if we jump

207
00:07:59,120 --> 00:08:00,410
back and look at the source code for

208
00:08:00,410 --> 00:08:02,840
this application it's actually importing

209
00:08:02,840 --> 00:08:06,800
this package called malice that again a

210
00:08:06,800 --> 00:08:08,990
lot of this is kind of fake but you can

211
00:08:08,990 --> 00:08:10,490
imagine this being a direct dependency

212
00:08:10,490 --> 00:08:12,020
or a transitive dependency of an

213
00:08:12,020 --> 00:08:14,120
otherwise very helpful package that is

214
00:08:14,120 --> 00:08:15,770
doing something like trying to steal

215
00:08:15,770 --> 00:08:18,050
your you know cryptocurrency mining or

216
00:08:18,050 --> 00:08:20,450
trying to take over your server or

217
00:08:20,450 --> 00:08:22,789
trying to execute arbitrary code and

218
00:08:22,789 --> 00:08:24,590
we've seen a lot of vulnerabilities in a

219
00:08:24,590 --> 00:08:25,970
number of different language ecosystems

220
00:08:25,970 --> 00:08:27,560
that are trying to do this where you

221
00:08:27,560 --> 00:08:29,000
just have an otherwise helpful package

222
00:08:29,000 --> 00:08:30,350
with a malicious dependency either

223
00:08:30,350 --> 00:08:32,839
direct or transitive and every time I

224
00:08:32,839 --> 00:08:35,210
deploy my application this package is

225
00:08:35,210 --> 00:08:38,539
getting included inadvertently and you

226
00:08:38,539 --> 00:08:39,530
might ask yourself well what does this

227
00:08:39,530 --> 00:08:42,500
package do well you could write like a

228
00:08:42,500 --> 00:08:46,850
very sophisticated attack vector package

229
00:08:46,850 --> 00:08:48,440
that targets a user that tries to do

230
00:08:48,440 --> 00:08:51,140
something very specific or you could do

231
00:08:51,140 --> 00:08:53,000
what this package does which is just

232
00:08:53,000 --> 00:08:53,990
dump the OS

233
00:08:53,990 --> 00:08:56,210
and send it to a random HTTP endpoint

234
00:08:56,210 --> 00:08:58,460
and you would be surprised how much

235
00:08:58,460 --> 00:09:00,650
information you can glean from just the

236
00:09:00,650 --> 00:09:03,110
request headers and the entire system

237
00:09:03,110 --> 00:09:05,480
environment and this has been running

238
00:09:05,480 --> 00:09:08,000
every time we make a request actually so

239
00:09:08,000 --> 00:09:11,750
if we jump in here to our logs for this

240
00:09:11,750 --> 00:09:13,640
application for our malice application

241
00:09:13,640 --> 00:09:17,180
you can see that every time we make a

242
00:09:17,180 --> 00:09:21,200
request the entire environment is

243
00:09:21,200 --> 00:09:23,210
getting dumped up to this rogue HTTP

244
00:09:23,210 --> 00:09:26,090
endpoint and that obviously includes our

245
00:09:26,090 --> 00:09:28,760
Redis host our Redis password the

246
00:09:28,760 --> 00:09:30,020
rightest port all of that information

247
00:09:30,020 --> 00:09:31,640
that was available in the debug output

248
00:09:31,640 --> 00:09:33,550
we're also sending this to an attacker

249
00:09:33,550 --> 00:09:35,600
and you might be thinking yourself well

250
00:09:35,600 --> 00:09:37,550
like oh this isn't so bad

251
00:09:37,550 --> 00:09:40,430
you could mitigate this you know doing

252
00:09:40,430 --> 00:09:42,800
XY and Z but this is actually like a

253
00:09:42,800 --> 00:09:46,430
publicly accessible reticent students so

254
00:09:46,430 --> 00:09:51,050
I'm gonna tell MIT into this thing and I

255
00:09:51,050 --> 00:09:53,300
can get ping and it says like Oh authors

256
00:09:53,300 --> 00:09:53,990
required

257
00:09:53,990 --> 00:09:57,020
well we've sorted every attacker I can

258
00:09:57,020 --> 00:09:59,060
off with my password which is super

259
00:09:59,060 --> 00:10:01,460
secret and now I can ping and I can get

260
00:10:01,460 --> 00:10:04,670
pong and I can like like I have whole

261
00:10:04,670 --> 00:10:06,050
permission over this reddit server at

262
00:10:06,050 --> 00:10:07,850
this point and that's all because I

263
00:10:07,850 --> 00:10:08,930
leaked the credential or the

264
00:10:08,930 --> 00:10:10,280
authentication for talking to this

265
00:10:10,280 --> 00:10:12,020
reticent students in an environment

266
00:10:12,020 --> 00:10:15,080
variable so hopefully now it's clear

267
00:10:15,080 --> 00:10:18,760
that I don't know how to exit tell MIT

268
00:10:19,870 --> 00:10:23,650
cool hopefully now it's clear that

269
00:10:23,650 --> 00:10:25,460
storing environment variables in

270
00:10:25,460 --> 00:10:28,580
plaintext is a bad idea how many people

271
00:10:28,580 --> 00:10:30,080
won't be honest do any of you know how

272
00:10:30,080 --> 00:10:31,670
to actually exit tell MIT it's really

273
00:10:31,670 --> 00:10:33,050
hard you just close the terminal window

274
00:10:33,050 --> 00:10:36,310
and open it up again

275
00:10:37,240 --> 00:10:40,010
cool so there's a few ways that we could

276
00:10:40,010 --> 00:10:41,420
mitigate this right like we could

277
00:10:41,420 --> 00:10:43,100
implement vulnerability scanning we can

278
00:10:43,100 --> 00:10:45,230
add C icd checks we could do a whole

279
00:10:45,230 --> 00:10:47,750
bunch of stuff but all of those assume

280
00:10:47,750 --> 00:10:48,980
that the vulnerability has already been

281
00:10:48,980 --> 00:10:51,200
found right this is a challenge which is

282
00:10:51,200 --> 00:10:53,120
that it doesn't matter how big your CVE

283
00:10:53,120 --> 00:10:55,130
database is that only includes things

284
00:10:55,130 --> 00:10:56,870
that people have already found we need

285
00:10:56,870 --> 00:10:58,280
to find a way to protect against attacks

286
00:10:58,280 --> 00:11:00,080
that haven't been found yet or haven't

287
00:11:00,080 --> 00:11:02,900
existed or been revealed in the wild and

288
00:11:02,900 --> 00:11:04,190
that's where we can move to something

289
00:11:04,190 --> 00:11:06,230
like encrypted environment variables so

290
00:11:06,230 --> 00:11:07,100
instead of store

291
00:11:07,100 --> 00:11:08,750
the plaintext environment variable we

292
00:11:08,750 --> 00:11:10,400
store the encrypted environment variable

293
00:11:10,400 --> 00:11:11,810
or the encrypted string in an

294
00:11:11,810 --> 00:11:14,120
environment variable and then at boot we

295
00:11:14,120 --> 00:11:16,370
decrypt that in store it in memory so

296
00:11:16,370 --> 00:11:18,140
let me take a look at what that looks

297
00:11:18,140 --> 00:11:22,160
like so I'm gonna run this fun encrypt

298
00:11:22,160 --> 00:11:24,200
string script that I wrote which

299
00:11:24,200 --> 00:11:26,930
encrypts the string that I give it with

300
00:11:26,930 --> 00:11:29,330
a key that's managed a the key

301
00:11:29,330 --> 00:11:31,220
management server again I'm using

302
00:11:31,220 --> 00:11:32,660
Google's key management server but you

303
00:11:32,660 --> 00:11:34,490
could also use Amazon or vault or

304
00:11:34,490 --> 00:11:36,250
whatever key management system you want

305
00:11:36,250 --> 00:11:38,900
it encrypted it and it gave me back this

306
00:11:38,900 --> 00:11:42,140
wonderful collection of base64 encoded

307
00:11:42,140 --> 00:11:43,850
and encrypted bits and I'm gonna give

308
00:11:43,850 --> 00:11:46,460
this over to my app so I'm gonna come

309
00:11:46,460 --> 00:11:51,610
over here and I'm going to say that

310
00:11:51,610 --> 00:11:53,930
instead of the Redis password being

311
00:11:53,930 --> 00:11:55,550
super secret which is hard-coded

312
00:11:55,550 --> 00:11:57,620
directly I'm just gonna set the Redis

313
00:11:57,620 --> 00:12:00,230
password to this really big long and

314
00:12:00,230 --> 00:12:02,000
cryptid string and then obviously we

315
00:12:02,000 --> 00:12:03,710
also have to update our application so

316
00:12:03,710 --> 00:12:05,240
that it knows to decrypt that string

317
00:12:05,240 --> 00:12:07,280
before doing anything else so I'll do

318
00:12:07,280 --> 00:12:09,320
that here in the main function I'm just

319
00:12:09,320 --> 00:12:14,200
gonna ask it to grab the Redis password

320
00:12:14,200 --> 00:12:18,490
and I'm just gonna say to decrypt that

321
00:12:18,490 --> 00:12:22,430
and if there's an error just panic

322
00:12:22,430 --> 00:12:24,080
because this is a live demo and that's

323
00:12:24,080 --> 00:12:25,060
what I would do

324
00:12:25,060 --> 00:12:27,800
cool so now what we've done is we've

325
00:12:27,800 --> 00:12:30,290
basically told our application hey when

326
00:12:30,290 --> 00:12:33,320
you boot up go pull the environment

327
00:12:33,320 --> 00:12:34,790
variable which is still in Redis pass

328
00:12:34,790 --> 00:12:38,630
and decrypt that using canvas and then

329
00:12:38,630 --> 00:12:40,790
pass the plaintext version it so if an

330
00:12:40,790 --> 00:12:42,650
attacker has access to our environment

331
00:12:42,650 --> 00:12:44,600
variables they're not going to see the

332
00:12:44,600 --> 00:12:45,920
actual plaintext they're only going to

333
00:12:45,920 --> 00:12:48,320
see the encrypted one but in memory and

334
00:12:48,320 --> 00:12:49,700
when we authenticate it will have the

335
00:12:49,700 --> 00:12:51,500
plaintext one and I'm actually going to

336
00:12:51,500 --> 00:12:53,390
jump back over here and take away MV

337
00:12:53,390 --> 00:12:54,620
equals production just because it's

338
00:12:54,620 --> 00:12:56,000
easier to show you what the environment

339
00:12:56,000 --> 00:12:59,840
looks like in that case so now let's

340
00:12:59,840 --> 00:13:03,110
jump over here to here will run deploy

341
00:13:03,110 --> 00:13:06,740
app again this is gonna take a little

342
00:13:06,740 --> 00:13:08,800
bit longer because it

343
00:13:08,800 --> 00:13:10,420
I guess it's not gonna take a little bit

344
00:13:10,420 --> 00:13:16,179
longer and we're packaging up our

345
00:13:16,179 --> 00:13:17,439
container we're deploying our container

346
00:13:17,439 --> 00:13:18,939
we're waiting for our container to

347
00:13:18,939 --> 00:13:21,790
become healthy and now it's routing

348
00:13:21,790 --> 00:13:27,279
traffic and the goal is that the

349
00:13:27,279 --> 00:13:30,129
application doesn't change right like

350
00:13:30,129 --> 00:13:31,569
the unbe havior of the application

351
00:13:31,569 --> 00:13:32,980
doesn't change I haven't edited any of

352
00:13:32,980 --> 00:13:35,170
my guests logic or my guestbook logic

353
00:13:35,170 --> 00:13:37,059
you'll notice here that like the Redis

354
00:13:37,059 --> 00:13:38,649
password is that really long encrypted

355
00:13:38,649 --> 00:13:43,689
string but if we fix the counter you can

356
00:13:43,689 --> 00:13:45,610
see that it's still the same perfectly

357
00:13:45,610 --> 00:13:47,470
functional application because at boot

358
00:13:47,470 --> 00:13:49,899
only one time only the first time the

359
00:13:49,899 --> 00:13:52,029
application was deployed it took the

360
00:13:52,029 --> 00:13:54,069
encrypted string decrypted it and then

361
00:13:54,069 --> 00:13:56,350
it's using that decrypted value to

362
00:13:56,350 --> 00:13:57,910
communicate so Redis moving forward

363
00:13:57,910 --> 00:14:00,249
again in our malice package if we were

364
00:14:00,249 --> 00:14:03,519
to jump over here that package is still

365
00:14:03,519 --> 00:14:05,649
in our supply chain but as you can see

366
00:14:05,649 --> 00:14:08,410
the payload is exactly what we're seeing

367
00:14:08,410 --> 00:14:09,999
on the screen it's the encrypted string

368
00:14:09,999 --> 00:14:12,040
it's not the plaintext string so an

369
00:14:12,040 --> 00:14:13,360
attacker doesn't have the right

370
00:14:13,360 --> 00:14:14,949
permissions to decrypt this string to

371
00:14:14,949 --> 00:14:17,290
get back the plain text value so we've

372
00:14:17,290 --> 00:14:19,569
we've pretty successfully mitigated this

373
00:14:19,569 --> 00:14:23,740
attack there's a few challenges here the

374
00:14:23,740 --> 00:14:26,470
first is that we lose any centralized

375
00:14:26,470 --> 00:14:28,660
management of these secrets once we

376
00:14:28,660 --> 00:14:30,639
encrypt that string and put it in the

377
00:14:30,639 --> 00:14:33,309
deployment we don't know how often it's

378
00:14:33,309 --> 00:14:34,660
being used we don't know which

379
00:14:34,660 --> 00:14:36,069
applications are still depending on it

380
00:14:36,069 --> 00:14:38,170
we get we don't get a lot of like

381
00:14:38,170 --> 00:14:40,749
auditing and logging out of it the

382
00:14:40,749 --> 00:14:42,309
second thing is that we're kind of

383
00:14:42,309 --> 00:14:44,619
relying on a key management system to do

384
00:14:44,619 --> 00:14:46,360
the encryption and decryption so we've

385
00:14:46,360 --> 00:14:48,069
just pushed the security problem further

386
00:14:48,069 --> 00:14:49,839
down the stack which is how are you

387
00:14:49,839 --> 00:14:51,699
authenticating your function to actually

388
00:14:51,699 --> 00:14:54,339
talk to the key management service and

389
00:14:54,339 --> 00:14:55,929
how are you doing key rotation how are

390
00:14:55,929 --> 00:14:58,600
you preventing like IV attacks and all

391
00:14:58,600 --> 00:15:00,100
of those things so we just made the

392
00:15:00,100 --> 00:15:01,660
security problem kind of someone else's

393
00:15:01,660 --> 00:15:04,929
problem but encrypted environment

394
00:15:04,929 --> 00:15:07,059
variables are still astronomically

395
00:15:07,059 --> 00:15:09,220
better than plaintext environment

396
00:15:09,220 --> 00:15:11,079
variables in fact you should like never

397
00:15:11,079 --> 00:15:13,350
use plaintext environment variables ever

398
00:15:13,350 --> 00:15:16,230
for any type of password or credential

399
00:15:16,230 --> 00:15:17,949
so if there's one thing you take away

400
00:15:17,949 --> 00:15:19,749
from this talk it's like please don't

401
00:15:19,749 --> 00:15:21,580
put passwords in environment

402
00:15:21,580 --> 00:15:23,710
variables if I could get that on a

403
00:15:23,710 --> 00:15:26,500
t-shirt I would the t-shirts are

404
00:15:26,500 --> 00:15:29,290
expensive when you buy them just for

405
00:15:29,290 --> 00:15:29,880
yourself

406
00:15:29,880 --> 00:15:34,180
cool the best way to actually secure

407
00:15:34,180 --> 00:15:36,010
this application is to not have a

408
00:15:36,010 --> 00:15:39,040
password at all and you might be

409
00:15:39,040 --> 00:15:40,930
thinking yourself away if my app has to

410
00:15:40,930 --> 00:15:43,930
talk to Redis like it needs a Redis

411
00:15:43,930 --> 00:15:46,630
password or if my app has to talk to my

412
00:15:46,630 --> 00:15:48,700
sequel it needs a my sequel password and

413
00:15:48,700 --> 00:15:52,600
that's not actually true you can if

414
00:15:52,600 --> 00:15:53,740
you're especially if you're on a cloud

415
00:15:53,740 --> 00:15:56,650
provider or some type of identity and

416
00:15:56,650 --> 00:15:58,540
access management system you can

417
00:15:58,540 --> 00:16:00,220
delegate the authentication and

418
00:16:00,220 --> 00:16:01,930
authorization to some third party system

419
00:16:01,930 --> 00:16:04,600
so instead of your application needing a

420
00:16:04,600 --> 00:16:05,950
username and password to talk to my

421
00:16:05,950 --> 00:16:08,260
sequel instead your application is

422
00:16:08,260 --> 00:16:10,840
authorized to talk to my sequel through

423
00:16:10,840 --> 00:16:12,460
like a cloud providers identity and

424
00:16:12,460 --> 00:16:14,500
access management system so anytime

425
00:16:14,500 --> 00:16:17,470
you're looking at a problem that you're

426
00:16:17,470 --> 00:16:19,420
trying to solve by injecting a secret

427
00:16:19,420 --> 00:16:21,700
into a service function or any

428
00:16:21,700 --> 00:16:23,770
application you do need to take a step

429
00:16:23,770 --> 00:16:25,450
back and ask yourself do I actually need

430
00:16:25,450 --> 00:16:27,880
a secret here or can I use like instance

431
00:16:27,880 --> 00:16:29,890
metadata authentication or some type of

432
00:16:29,890 --> 00:16:31,930
identity function in my cloud provider

433
00:16:31,930 --> 00:16:34,150
or my networking provider to do this

434
00:16:34,150 --> 00:16:35,740
authorization instead of injecting a

435
00:16:35,740 --> 00:16:37,840
secret into the runtime if you can bring

436
00:16:37,840 --> 00:16:39,640
that one level higher you make it a lot

437
00:16:39,640 --> 00:16:41,800
harder for an attacker to gain access

438
00:16:41,800 --> 00:16:46,030
and escalate privilege one of the main

439
00:16:46,030 --> 00:16:47,350
drawbacks of encrypted environment

440
00:16:47,350 --> 00:16:49,030
variables as I said is that you lose

441
00:16:49,030 --> 00:16:50,890
that centralized storage the centralized

442
00:16:50,890 --> 00:16:52,690
auditing and logging so if I'm going

443
00:16:52,690 --> 00:16:54,310
into my secret store and I'm like okay

444
00:16:54,310 --> 00:16:56,830
we have the Redis password who is using

445
00:16:56,830 --> 00:16:58,830
the Redis password with this

446
00:16:58,830 --> 00:17:00,760
architecture that's a really difficult

447
00:17:00,760 --> 00:17:03,310
question to answer I don't know how many

448
00:17:03,310 --> 00:17:04,990
of these functions are using the Redis

449
00:17:04,990 --> 00:17:07,449
password and worse because of the way

450
00:17:07,449 --> 00:17:09,400
that most key management services work

451
00:17:09,400 --> 00:17:11,290
you don't have convergent encryption

452
00:17:11,290 --> 00:17:13,900
which means that the even if you know

453
00:17:13,900 --> 00:17:16,359
what the password is the same string

454
00:17:16,359 --> 00:17:17,619
will generate a different set of

455
00:17:17,619 --> 00:17:19,959
encrypted bytes every time so for

456
00:17:19,959 --> 00:17:21,880
example if I if I jump back over here

457
00:17:21,880 --> 00:17:24,400
and I run the encrypt string function

458
00:17:24,400 --> 00:17:28,810
again with super secret I get back a

459
00:17:28,810 --> 00:17:30,280
different string every time it's not

460
00:17:30,280 --> 00:17:32,770
convergent encryption so I can't just

461
00:17:32,770 --> 00:17:34,240
encrypt the string and then you know

462
00:17:34,240 --> 00:17:35,809
search over all of my server let's

463
00:17:35,809 --> 00:17:37,730
to see which ones are using the

464
00:17:37,730 --> 00:17:38,960
encrypted string because it's not a

465
00:17:38,960 --> 00:17:41,090
convergent encryption algorithm most of

466
00:17:41,090 --> 00:17:43,940
them aren't so I lose the centralized

467
00:17:43,940 --> 00:17:46,100
management and this is where the third

468
00:17:46,100 --> 00:17:48,590
kind of approach if you consider

469
00:17:48,590 --> 00:17:50,899
plaintext and approach to secrets

470
00:17:50,899 --> 00:17:52,220
management and surveillance actually

471
00:17:52,220 --> 00:17:53,269
comes from and that's using a

472
00:17:53,269 --> 00:17:56,029
centralized storage system so there's a

473
00:17:56,029 --> 00:17:57,169
few different centralized storage

474
00:17:57,169 --> 00:17:59,350
systems for example on Amazon you have

475
00:17:59,350 --> 00:18:01,759
Amazon secret store or Amazon parameter

476
00:18:01,759 --> 00:18:04,100
store I'm sure has a thing called key

477
00:18:04,100 --> 00:18:06,259
vault on GCP you can use Google Cloud

478
00:18:06,259 --> 00:18:08,179
storage or you can use Berglas which is

479
00:18:08,179 --> 00:18:09,769
what we're gonna use here but the

480
00:18:09,769 --> 00:18:12,320
general architecture is instead of

481
00:18:12,320 --> 00:18:15,409
having your application encrypt a string

482
00:18:15,409 --> 00:18:17,059
and then decrypt it at runtime you

483
00:18:17,059 --> 00:18:19,249
actually store the secret material in a

484
00:18:19,249 --> 00:18:21,110
central place like a storage bucket for

485
00:18:21,110 --> 00:18:23,720
example or a filesystem and then at boot

486
00:18:23,720 --> 00:18:25,909
your application accesses the secret

487
00:18:25,909 --> 00:18:28,100
from that centralized store and the

488
00:18:28,100 --> 00:18:29,899
centralized store is responsible for all

489
00:18:29,899 --> 00:18:32,419
auditing logging alerting anomaly

490
00:18:32,419 --> 00:18:35,090
detection etc so I'm gonna use Berglas

491
00:18:35,090 --> 00:18:38,990
but again super generic this will work

492
00:18:38,990 --> 00:18:40,669
with like any secret store really

493
00:18:40,669 --> 00:18:42,230
including the file system if you want to

494
00:18:42,230 --> 00:18:43,330
build it yourself

495
00:18:43,330 --> 00:18:46,190
so I'm gonna go ahead and run this

496
00:18:46,190 --> 00:18:51,110
Berglas command which is super long but

497
00:18:51,110 --> 00:18:52,789
I'll tell you what it does so I'm

498
00:18:52,789 --> 00:18:56,090
creating a secret and this is the name

499
00:18:56,090 --> 00:18:58,009
of a Google Cloud Storage bucket this is

500
00:18:58,009 --> 00:19:00,769
my rat Espace word this is my actual

501
00:19:00,769 --> 00:19:02,419
password itself and then I'm encrypting

502
00:19:02,419 --> 00:19:04,999
it with a KMS key and so basically I'm

503
00:19:04,999 --> 00:19:07,279
taking the string encrypting it and

504
00:19:07,279 --> 00:19:09,470
putting in the storage bucket and then

505
00:19:09,470 --> 00:19:11,480
I'm granting permission to my cloud

506
00:19:11,480 --> 00:19:19,610
function to to access that particular

507
00:19:19,610 --> 00:19:22,700
secret and so again relying on dedenne

508
00:19:22,700 --> 00:19:24,080
and access management to control the

509
00:19:24,080 --> 00:19:25,490
authorization here so I don't have to

510
00:19:25,490 --> 00:19:27,740
pass in an authentication token I just

511
00:19:27,740 --> 00:19:29,629
authenticate the instance and then it

512
00:19:29,629 --> 00:19:31,970
has permission so there's no exchange of

513
00:19:31,970 --> 00:19:34,879
credentials and then back in our source

514
00:19:34,879 --> 00:19:38,539
code instead of running kms decrypt

515
00:19:38,539 --> 00:19:43,279
we're gonna run Berglas access and we

516
00:19:43,279 --> 00:19:45,200
will access the name of the secret which

517
00:19:45,200 --> 00:19:46,820
was Redis pass

518
00:19:46,820 --> 00:19:50,450
and that's it that's the only change you

519
00:19:50,450 --> 00:19:51,080
need to make

520
00:19:51,080 --> 00:19:52,670
oh it's yelling at me because this isn't

521
00:19:52,670 --> 00:19:56,390
used anymore that's fine and we'll come

522
00:19:56,390 --> 00:20:01,810
over here and we will run the play out

523
00:20:02,470 --> 00:20:04,580
and this is going to build a new

524
00:20:04,580 --> 00:20:06,230
container it's gonna build a new go

525
00:20:06,230 --> 00:20:09,530
binary this one's actually gonna take a

526
00:20:09,530 --> 00:20:11,360
couple seconds I have to like blabber

527
00:20:11,360 --> 00:20:15,680
incoherently for another minute my

528
00:20:15,680 --> 00:20:17,630
favorite color is blue I like sausage

529
00:20:17,630 --> 00:20:23,360
pizza pepperonis okay - if there's a

530
00:20:23,360 --> 00:20:25,930
question I can answer that right now

531
00:20:25,930 --> 00:20:30,800
yeah what's up so the question is what

532
00:20:30,800 --> 00:20:33,890
is it doing so I'm using I don't know if

533
00:20:33,890 --> 00:20:35,000
you're here for the very beginning I'm

534
00:20:35,000 --> 00:20:37,760
using cloud run to deploy it's similar

535
00:20:37,760 --> 00:20:39,590
to like Fargate which is like I'm

536
00:20:39,590 --> 00:20:41,420
building a container so you see like the

537
00:20:41,420 --> 00:20:43,070
docker contacts so I'm building a

538
00:20:43,070 --> 00:20:46,010
container I'm using go so part of the

539
00:20:46,010 --> 00:20:47,660
build steps of building that container

540
00:20:47,660 --> 00:20:49,700
is to actually compile to go binary so

541
00:20:49,700 --> 00:20:51,320
where were we spent the most time was

542
00:20:51,320 --> 00:20:53,210
actually on this step here which was the

543
00:20:53,210 --> 00:20:55,370
go build step so I'm taking my go source

544
00:20:55,370 --> 00:20:57,140
code I'm compiling it into a binary and

545
00:20:57,140 --> 00:20:58,280
then I'm putting that binary in a

546
00:20:58,280 --> 00:20:59,840
container and then I'm shipping that

547
00:20:59,840 --> 00:21:01,340
container up which includes the entire

548
00:21:01,340 --> 00:21:03,020
runtime that might happen EADS to

549
00:21:03,020 --> 00:21:05,930
function and I'm telling the server this

550
00:21:05,930 --> 00:21:07,280
run time which was just cloud run in

551
00:21:07,280 --> 00:21:11,510
this instance to run that container cool

552
00:21:11,510 --> 00:21:13,670
so that's done it's successfully shifted

553
00:21:13,670 --> 00:21:15,140
over the traffic and if we jump back

554
00:21:15,140 --> 00:21:19,130
over here to the app we can see that

555
00:21:19,130 --> 00:21:20,540
it's still functioning as intended so

556
00:21:20,540 --> 00:21:22,250
even though we've completely changed the

557
00:21:22,250 --> 00:21:25,010
underlying behavior of how the Redis

558
00:21:25,010 --> 00:21:26,360
password is getting injected into the

559
00:21:26,360 --> 00:21:28,490
application the app still functions the

560
00:21:28,490 --> 00:21:30,560
same we can still reset the counter we

561
00:21:30,560 --> 00:21:34,910
can still come in here and you reset the

562
00:21:34,910 --> 00:21:37,240
counter

563
00:21:39,730 --> 00:21:41,500
we can still come in here and reset the

564
00:21:41,500 --> 00:21:43,630
counter to banana and even though

565
00:21:43,630 --> 00:21:44,980
there's this Redis password environment

566
00:21:44,980 --> 00:21:45,909
variable in here we're not actually

567
00:21:45,909 --> 00:21:51,700
using that anymore and to prove that to

568
00:21:51,700 --> 00:21:53,529
you I will do what I was supposed to do

569
00:21:53,529 --> 00:21:56,919
during the initial deployment which is

570
00:21:56,919 --> 00:21:59,679
remove the Redis password from here and

571
00:21:59,679 --> 00:22:03,399
run deploy again to fill there further

572
00:22:03,399 --> 00:22:04,809
build on my answer to that question this

573
00:22:04,809 --> 00:22:06,580
one will be super fast because we've

574
00:22:06,580 --> 00:22:07,990
already built those layers in the docker

575
00:22:07,990 --> 00:22:09,460
container we already have the container

576
00:22:09,460 --> 00:22:10,929
locally we just have to push it up to

577
00:22:10,929 --> 00:22:12,460
the cloud and now it'll just deploy it

578
00:22:12,460 --> 00:22:14,440
so all future builds are super fast

579
00:22:14,440 --> 00:22:15,760
because the docker layer is already

580
00:22:15,760 --> 00:22:20,559
exists waiting waiting waiting still

581
00:22:20,559 --> 00:22:24,549
waiting okay and over here our our app

582
00:22:24,549 --> 00:22:28,450
is still functional and we can reset the

583
00:22:28,450 --> 00:22:30,460
counter and if I reset the counter to

584
00:22:30,460 --> 00:22:32,350
banana again you can see that even

585
00:22:32,350 --> 00:22:33,730
though the Redis password is nowhere in

586
00:22:33,730 --> 00:22:35,139
our environment we're still able to

587
00:22:35,139 --> 00:22:36,460
communicate with Redis and that's

588
00:22:36,460 --> 00:22:38,110
because we're now using a secret store

589
00:22:38,110 --> 00:22:40,059
for that communication instead of

590
00:22:40,059 --> 00:22:42,760
relying on the environment variables so

591
00:22:42,760 --> 00:22:47,169
v panner pattern that i want to talk

592
00:22:47,169 --> 00:22:49,539
about is using an actual secrets

593
00:22:49,539 --> 00:22:51,760
management solution so in this example

594
00:22:51,760 --> 00:22:54,309
I'm using a storage bucket with auditing

595
00:22:54,309 --> 00:22:55,840
and logging and a bunch of stuff in the

596
00:22:55,840 --> 00:22:57,399
background to make it look like a

597
00:22:57,399 --> 00:22:59,440
secrets management solution but there's

598
00:22:59,440 --> 00:23:01,720
also a lot of open source and enterprise

599
00:23:01,720 --> 00:23:03,220
secret management solutions out there

600
00:23:03,220 --> 00:23:05,019
like hash tag or vault and cyber or

601
00:23:05,019 --> 00:23:07,419
conjurer that are either free or paid

602
00:23:07,419 --> 00:23:10,149
solutions that act as this centralized

603
00:23:10,149 --> 00:23:11,679
secrets management storm they do things

604
00:23:11,679 --> 00:23:13,539
like dynamic credentials auditing

605
00:23:13,539 --> 00:23:16,059
logging anomaly detection etc so I just

606
00:23:16,059 --> 00:23:17,789
want to show you a quick sample of using

607
00:23:17,789 --> 00:23:20,559
vault open source for doing this type of

608
00:23:20,559 --> 00:23:22,179
secrets management because there is a

609
00:23:22,179 --> 00:23:23,559
little bit more complexity that comes

610
00:23:23,559 --> 00:23:25,929
with it because we can't rely on the

611
00:23:25,929 --> 00:23:27,309
built-in Identity and Access Management

612
00:23:27,309 --> 00:23:29,740
of the cloud provider we instead have to

613
00:23:29,740 --> 00:23:31,600
rely on vault to do some of the

614
00:23:31,600 --> 00:23:34,210
authentication bits for us and again I'm

615
00:23:34,210 --> 00:23:35,559
trying to be vendor agnostic this would

616
00:23:35,559 --> 00:23:37,090
be the same as if you were using conjure

617
00:23:37,090 --> 00:23:38,830
or any other secrets management solution

618
00:23:38,830 --> 00:23:43,539
the general principles still apply so

619
00:23:43,539 --> 00:23:46,110
the first thing we need to do is

620
00:23:46,110 --> 00:23:50,139
actually configure vault to be able to

621
00:23:50,139 --> 00:23:52,740
authenticate our server list application

622
00:23:52,740 --> 00:23:54,660
so our secret is just gonna live in

623
00:23:54,660 --> 00:23:59,970
vault key value store so vault KB put kV

624
00:23:59,970 --> 00:24:05,790
my app Redis pass and the value is super

625
00:24:05,790 --> 00:24:11,160
secret so we've created this key value

626
00:24:11,160 --> 00:24:12,679
store in volts

627
00:24:12,679 --> 00:24:14,910
very similar to any other key value

628
00:24:14,910 --> 00:24:20,820
store and now I have to tell vault or I

629
00:24:20,820 --> 00:24:23,010
have to give vault a policy that will

630
00:24:23,010 --> 00:24:24,809
enable my application to get this secret

631
00:24:24,809 --> 00:24:26,010
back out because right now when I

632
00:24:26,010 --> 00:24:27,630
interact with vault locally on the CLI

633
00:24:27,630 --> 00:24:30,000
I'm kind of like the root user but when

634
00:24:30,000 --> 00:24:31,740
we deploy our application our app won't

635
00:24:31,740 --> 00:24:33,809
have any permissions by default so we

636
00:24:33,809 --> 00:24:34,920
need to basically give it those

637
00:24:34,920 --> 00:24:36,390
permissions and the way we do that is by

638
00:24:36,390 --> 00:24:38,460
creating a policy so I'm gonna create a

639
00:24:38,460 --> 00:24:46,260
policy called my app my kV read and I

640
00:24:46,260 --> 00:24:48,059
wrote this policy in advance so I'll

641
00:24:48,059 --> 00:24:51,480
show you what that looks like it just

642
00:24:51,480 --> 00:24:53,730
gives the application permission to read

643
00:24:53,730 --> 00:24:57,900
from the key value store and now is the

644
00:24:57,900 --> 00:25:00,110
fun part which is we have to give our

645
00:25:00,110 --> 00:25:01,740
application or server oh this

646
00:25:01,740 --> 00:25:03,210
application the ability to authenticate

647
00:25:03,210 --> 00:25:05,640
to vault so that it can get the secret

648
00:25:05,640 --> 00:25:07,230
from vault the same way you would have

649
00:25:07,230 --> 00:25:08,730
to authenticate to cyber-ark

650
00:25:08,730 --> 00:25:10,679
so that you can get the password from

651
00:25:10,679 --> 00:25:14,240
condor and i'm gonna do that by running

652
00:25:14,240 --> 00:25:18,470
by enabling the GCP authentication

653
00:25:18,470 --> 00:25:22,890
plugin or back-end in vault so I'm gonna

654
00:25:22,890 --> 00:25:27,410
run UCB server this role my app and

655
00:25:27,410 --> 00:25:30,210
we're gonna allow I am login so

656
00:25:30,210 --> 00:25:31,260
basically what I'm doing is I'm telling

657
00:25:31,260 --> 00:25:33,120
vault hey you should trust Google's I am

658
00:25:33,120 --> 00:25:35,250
system like that's the source of truth

659
00:25:35,250 --> 00:25:37,620
for Identity and Access Management my

660
00:25:37,620 --> 00:25:41,190
project ID is a Google specific thing

661
00:25:41,190 --> 00:25:49,700
dev sec con Seattle 19 my policies are

662
00:25:49,700 --> 00:25:55,230
my app kV read and my bound service

663
00:25:55,230 --> 00:25:58,720
accounts it's my app

664
00:25:58,720 --> 00:26:00,580
this is the really boring part about

665
00:26:00,580 --> 00:26:03,249
this talk I have to type a lot South

666
00:26:03,249 --> 00:26:08,879
Fargo does SEC con Seattle 19 and I am I

667
00:26:08,879 --> 00:26:14,499
am a GE service account come in the max

668
00:26:14,499 --> 00:26:18,729
John expiration is 60 minutes okay did I

669
00:26:18,729 --> 00:26:21,190
make a typo no wow that's impressive

670
00:26:21,190 --> 00:26:23,349
alright and the last thing I have to do

671
00:26:23,349 --> 00:26:24,940
is I have to come in here and I have to

672
00:26:24,940 --> 00:26:29,979
run full access instead of Berglas

673
00:26:29,979 --> 00:26:34,119
access and the path is kV data my Redis

674
00:26:34,119 --> 00:26:37,869
pass so we'll save that and we will

675
00:26:37,869 --> 00:26:43,960
deploy this so it's also gonna take a

676
00:26:43,960 --> 00:26:45,580
little bit of time Excel we have to

677
00:26:45,580 --> 00:26:48,249
build the new layer one thing you might

678
00:26:48,249 --> 00:26:50,229
notice is that I'm I'm being a little

679
00:26:50,229 --> 00:26:52,179
bit magic and hand-wavy with these magic

680
00:26:52,179 --> 00:26:54,669
functions that call vault access and

681
00:26:54,669 --> 00:26:57,279
Berglas access and KMS decrypt all of

682
00:26:57,279 --> 00:26:58,989
this is open source you can find it on

683
00:26:58,989 --> 00:27:00,369
github it's just south fargo slash

684
00:27:00,369 --> 00:27:04,629
server list secrets talk but my point is

685
00:27:04,629 --> 00:27:06,639
that the way that your application gets

686
00:27:06,639 --> 00:27:08,499
secrets is an abstraction like

687
00:27:08,499 --> 00:27:10,210
fundamentally it is an abstraction and

688
00:27:10,210 --> 00:27:11,950
then the core of the application

689
00:27:11,950 --> 00:27:13,539
shouldn't change based off of how you

690
00:27:13,539 --> 00:27:16,509
access your secrets so all those stuff

691
00:27:16,509 --> 00:27:17,950
is in here right like here's the code

692
00:27:17,950 --> 00:27:20,440
for talking to kms here's the code for

693
00:27:20,440 --> 00:27:21,700
talking to fault here's the code for

694
00:27:21,700 --> 00:27:23,229
talking to Berglas they're not

695
00:27:23,229 --> 00:27:24,609
particularly complicated and they're

696
00:27:24,609 --> 00:27:26,409
only like you know 10 15 lines of code

697
00:27:26,409 --> 00:27:29,019
but I'm intentionally doing some hand

698
00:27:29,019 --> 00:27:33,580
waving here just to make it clear that I

699
00:27:33,580 --> 00:27:39,779
broke something what did I break

700
00:27:41,260 --> 00:27:44,970
the demo was going so well

701
00:27:49,520 --> 00:27:51,920
cool this is a great time to take

702
00:27:51,920 --> 00:27:57,650
questions are there any questions I will

703
00:27:57,650 --> 00:27:59,030
live to bug this while there's questions

704
00:27:59,030 --> 00:28:19,790
what's up yeah so the question is if I

705
00:28:19,790 --> 00:28:20,990
use the secrets management service

706
00:28:20,990 --> 00:28:23,120
that's third-party don't I have to worry

707
00:28:23,120 --> 00:28:24,410
about the availability of that service

708
00:28:24,410 --> 00:28:27,650
right or one that you built internally

709
00:28:27,650 --> 00:28:31,010
um it really depends rate security and

710
00:28:31,010 --> 00:28:32,510
availability often come with trade-offs

711
00:28:32,510 --> 00:28:34,670
and sometimes they're actually directly

712
00:28:34,670 --> 00:28:36,830
competing priorities oh I failed to

713
00:28:36,830 --> 00:28:39,170
authenticate the vault all right I'll do

714
00:28:39,170 --> 00:28:44,210
bug that leader it really depends if

715
00:28:44,210 --> 00:28:45,890
you're just using something like vault

716
00:28:45,890 --> 00:28:47,450
or cyber-ark for like the key value

717
00:28:47,450 --> 00:28:49,670
store and that's all you're using then

718
00:28:49,670 --> 00:28:50,929
you should probably just use like a

719
00:28:50,929 --> 00:28:53,360
native secrets manager or kubernetes

720
00:28:53,360 --> 00:28:54,470
secrets with application layer

721
00:28:54,470 --> 00:28:55,940
encryption or something like that if

722
00:28:55,940 --> 00:28:57,710
you're using like the dynamic secrets

723
00:28:57,710 --> 00:28:59,840
though that's where you start to get a

724
00:28:59,840 --> 00:29:02,630
significantly deeper level of security

725
00:29:02,630 --> 00:29:05,210
out of those products so you are trading

726
00:29:05,210 --> 00:29:06,920
like an additional overhead for

727
00:29:06,920 --> 00:29:08,300
operations and keeping that thing up and

728
00:29:08,300 --> 00:29:10,760
running and keeping it moving in favor

729
00:29:10,760 --> 00:29:13,100
of significantly increased security but

730
00:29:13,100 --> 00:29:14,690
if you're just looking at key value

731
00:29:14,690 --> 00:29:15,980
pairs we're like you have very static

732
00:29:15,980 --> 00:29:17,900
secrets that never change then it's not

733
00:29:17,900 --> 00:29:19,520
likely bringing you like the best

734
00:29:19,520 --> 00:29:21,080
benefit that I can in which case you

735
00:29:21,080 --> 00:29:22,670
should look to just using like a cloud

736
00:29:22,670 --> 00:29:28,360
native cloud space native solution yeah

737
00:29:35,330 --> 00:29:39,260
don't use kubernetes secrets

738
00:29:41,790 --> 00:29:43,590
so let me elaborate on that so I have

739
00:29:43,590 --> 00:29:44,730
another talk that I've given called

740
00:29:44,730 --> 00:29:47,820
base64 is not encryption a better story

741
00:29:47,820 --> 00:29:50,510
for kubernetes secrets by default

742
00:29:50,510 --> 00:29:52,980
kubernetes secrets are not encrypted at

743
00:29:52,980 --> 00:29:54,780
all they're stored in plain text in NCD

744
00:29:54,780 --> 00:29:57,000
and the only thing that guards them or

745
00:29:57,000 --> 00:29:58,590
are back permissions but if an attacker

746
00:29:58,590 --> 00:30:00,930
or an employee gets access to NCD they

747
00:30:00,930 --> 00:30:03,480
have all the secrets in plain text so

748
00:30:03,480 --> 00:30:05,460
because of that if you're going to use

749
00:30:05,460 --> 00:30:06,660
kubernetes secrets you should definitely

750
00:30:06,660 --> 00:30:08,220
enable what we call application layer

751
00:30:08,220 --> 00:30:10,890
encryption using a provider plug-in and

752
00:30:10,890 --> 00:30:12,120
again I have a talk on this that goes

753
00:30:12,120 --> 00:30:13,920
into like super deep detail but there's

754
00:30:13,920 --> 00:30:15,750
a mechanism in kubernetes that lets you

755
00:30:15,750 --> 00:30:17,220
encrypt secrets before they go to a CD

756
00:30:17,220 --> 00:30:20,400
in general though kubernetes secrets

757
00:30:20,400 --> 00:30:21,930
themselves have a number of challenges

758
00:30:21,930 --> 00:30:24,180
first they have to be key value pairs

759
00:30:24,180 --> 00:30:26,250
that doesn't fit everyone's mental model

760
00:30:26,250 --> 00:30:28,230
of what a secret needs to be and second

761
00:30:28,230 --> 00:30:30,090
you're restricted to again file system

762
00:30:30,090 --> 00:30:31,140
volume amounts or the environment

763
00:30:31,140 --> 00:30:34,200
variables there's a movement in some of

764
00:30:34,200 --> 00:30:36,390
the kubernetes SIG's to move towards

765
00:30:36,390 --> 00:30:38,490
container storage interface instead

766
00:30:38,490 --> 00:30:40,590
which is a CSI driver that's actually

767
00:30:40,590 --> 00:30:43,410
how as your key vault works basically

768
00:30:43,410 --> 00:30:46,530
you're mounting a virtual volume that

769
00:30:46,530 --> 00:30:48,480
every file system call when you call

770
00:30:48,480 --> 00:30:50,010
file dot read for example that gets

771
00:30:50,010 --> 00:30:51,570
mapped to an underlying API call which

772
00:30:51,570 --> 00:30:54,120
is hitting the cloud API and that's like

773
00:30:54,120 --> 00:30:57,540
how the vault one works as well and

774
00:30:57,540 --> 00:30:59,070
that's kind of like my personally

775
00:30:59,070 --> 00:31:00,390
preferred way for doing secrets in

776
00:31:00,390 --> 00:31:03,060
kubernetes if you are using kubernetes

777
00:31:03,060 --> 00:31:04,080
secrets because it's like a low

778
00:31:04,080 --> 00:31:06,210
developer friction thing you should at

779
00:31:06,210 --> 00:31:07,620
least encrypt them using the encryption

780
00:31:07,620 --> 00:31:09,510
provider configuration which is one

781
00:31:09,510 --> 00:31:16,220
tenor later other questions yeah

782
00:31:19,060 --> 00:31:24,160
so bear with me on this one okay in this

783
00:31:24,160 --> 00:31:25,960
particular example you have a Redis

784
00:31:25,960 --> 00:31:28,420
database that is specific to your

785
00:31:28,420 --> 00:31:31,690
application effectively the only client

786
00:31:31,690 --> 00:31:33,430
that readies database will ever have is

787
00:31:33,430 --> 00:31:36,040
your application right gated by access

788
00:31:36,040 --> 00:31:38,650
control security groups and whatnot why

789
00:31:38,650 --> 00:31:41,470
does it need a secret at all nobody else

790
00:31:41,470 --> 00:31:42,610
can talk to it but your application

791
00:31:42,610 --> 00:31:44,980
wouldn't it be possible to simplify the

792
00:31:44,980 --> 00:31:46,870
whole thing and just say we already have

793
00:31:46,870 --> 00:31:48,610
what the access controls we need we

794
00:31:48,610 --> 00:31:50,290
don't need a secret on top of everything

795
00:31:50,290 --> 00:31:52,510
else right so that's kind of what I'm

796
00:31:52,510 --> 00:31:53,560
saying with like Identity and Access

797
00:31:53,560 --> 00:31:56,950
Management right in this example it's a

798
00:31:56,950 --> 00:31:59,410
little bit contrived right but I have a

799
00:31:59,410 --> 00:32:01,800
publicly available Redis server that

800
00:32:01,800 --> 00:32:05,050
only is used by one app in a real

801
00:32:05,050 --> 00:32:06,280
production scenario I would never

802
00:32:06,280 --> 00:32:08,110
publicly expose my Redis right so that's

803
00:32:08,110 --> 00:32:09,840
an additional layer of protection

804
00:32:09,840 --> 00:32:11,860
additionally I would have internal

805
00:32:11,860 --> 00:32:13,630
firewalls so that only the applications

806
00:32:13,630 --> 00:32:16,030
that needed to talk to it have those

807
00:32:16,030 --> 00:32:19,480
authorized like network policies even on

808
00:32:19,480 --> 00:32:21,340
top of all of that like even if you have

809
00:32:21,340 --> 00:32:24,310
a Redis that is like dedicated to this

810
00:32:24,310 --> 00:32:26,050
instance and you have that Redis listen

811
00:32:26,050 --> 00:32:28,120
like only on localhost and they run on

812
00:32:28,120 --> 00:32:30,070
the same physical machine or they run in

813
00:32:30,070 --> 00:32:32,440
like a the same pod for example as like

814
00:32:32,440 --> 00:32:34,540
a sidecar container you're probably

815
00:32:34,540 --> 00:32:35,680
still gonna want to use a password

816
00:32:35,680 --> 00:32:38,020
because if an attacker is able to gain

817
00:32:38,020 --> 00:32:41,740
access to like another pod somewhere in

818
00:32:41,740 --> 00:32:43,390
the ecosystem you want to restrict

819
00:32:43,390 --> 00:32:45,150
things as much as possible right it's

820
00:32:45,150 --> 00:32:47,650
it's never about preventing an attacker

821
00:32:47,650 --> 00:32:50,020
it's about making it as really hard as

822
00:32:50,020 --> 00:32:53,290
possible to get that attacker to cause

823
00:32:53,290 --> 00:32:54,760
like significant damage and then being

824
00:32:54,760 --> 00:32:58,000
able to detect any type of infiltration

825
00:32:58,000 --> 00:33:03,070
before a large data breach occurs other

826
00:33:03,070 --> 00:33:04,860
questions

827
00:33:04,860 --> 00:33:06,840
this side of the room can ask questions

828
00:33:06,840 --> 00:33:09,139
too

829
00:33:13,110 --> 00:33:15,090
cool well if there's no other questions

830
00:33:15,090 --> 00:33:18,029
thank you all so much well thank you

831
00:33:18,029 --> 00:33:18,980
very much

832
00:33:18,980 --> 00:33:23,359
[Applause]

