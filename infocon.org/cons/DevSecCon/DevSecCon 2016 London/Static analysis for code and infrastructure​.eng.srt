1
00:00:00,560 --> 00:00:07,949
hello can everyone hear me okay at the

2
00:00:03,570 --> 00:00:10,290
back there fantastic okay so I'm going

3
00:00:07,950 --> 00:00:12,960
to be here talking about static analysis

4
00:00:10,290 --> 00:00:14,399
both for code and for infrastructure

5
00:00:12,960 --> 00:00:17,100
which is somewhere you don't often see

6
00:00:14,400 --> 00:00:21,480
it to give a bit of background to this

7
00:00:17,100 --> 00:00:25,230
talk the aim here is software developers

8
00:00:21,480 --> 00:00:27,000
make mistakes will make them mistakes

9
00:00:25,230 --> 00:00:28,920
means bugs bugs means security

10
00:00:27,000 --> 00:00:31,170
vulnerabilities the overall goal is

11
00:00:28,920 --> 00:00:32,430
fewer bugs sure something you recognize

12
00:00:31,170 --> 00:00:33,630
some of the logos down the bottom there

13
00:00:32,430 --> 00:00:35,610
over the last couple of years we've had

14
00:00:33,630 --> 00:00:37,469
some fairly catastrophic bugs and a

15
00:00:35,610 --> 00:00:40,769
variety of things shellshot was one of

16
00:00:37,469 --> 00:00:42,719
the worse these happen because someone

17
00:00:40,770 --> 00:00:44,610
somewhere screwed up so we're here to

18
00:00:42,719 --> 00:00:48,480
look at how we can how we can fix that

19
00:00:44,610 --> 00:00:49,710
Who am I I'm Nick Jones I work for MWR

20
00:00:48,480 --> 00:00:52,140
and flow security as a security

21
00:00:49,710 --> 00:00:53,629
consultant I work on web application

22
00:00:52,140 --> 00:00:56,430
infrastructure security usually and

23
00:00:53,629 --> 00:00:57,930
prior to this I was a software developer

24
00:00:56,430 --> 00:00:59,670
doing embedded systems development so

25
00:00:57,930 --> 00:01:02,820
have some idea of both sides of the coin

26
00:00:59,670 --> 00:01:05,850
here and which has helped out over the

27
00:01:02,820 --> 00:01:09,180
years so a brief overview of what we'll

28
00:01:05,850 --> 00:01:11,369
be covering why do we need static

29
00:01:09,180 --> 00:01:13,770
analysis what does that give us

30
00:01:11,369 --> 00:01:14,760
how do analyze is actually work give you

31
00:01:13,770 --> 00:01:15,810
a bit of a background so you can

32
00:01:14,760 --> 00:01:18,210
understand what these things are doing

33
00:01:15,810 --> 00:01:20,939
when they're running and a look at a few

34
00:01:18,210 --> 00:01:22,740
of the different applications of them

35
00:01:20,939 --> 00:01:24,270
what the kind of bugs you can you can

36
00:01:22,740 --> 00:01:26,929
catch with them and talk a bit about how

37
00:01:24,270 --> 00:01:31,380
that fits into dev sec ops as a whole

38
00:01:26,930 --> 00:01:33,259
and how that works so start off with why

39
00:01:31,380 --> 00:01:34,890
do we need static code analysis so and

40
00:01:33,259 --> 00:01:36,000
fundamentally the first question you

41
00:01:34,890 --> 00:01:39,119
need to answer is how do we actually

42
00:01:36,000 --> 00:01:41,189
find bugs two schools of thought on this

43
00:01:39,119 --> 00:01:43,560
or two different approaches and you have

44
00:01:41,189 --> 00:01:45,779
static analysis tor sassed as you'll

45
00:01:43,560 --> 00:01:47,820
hear gaunt and calling it and take an

46
00:01:45,780 --> 00:01:51,149
application analyze it in some fashion

47
00:01:47,820 --> 00:01:52,829
without executing it typically this is

48
00:01:51,149 --> 00:01:54,570
done by code review if you have access

49
00:01:52,829 --> 00:01:56,158
to the source code if you don't then

50
00:01:54,570 --> 00:01:59,369
either reverse engineering or some kind

51
00:01:56,159 --> 00:02:01,619
of binary analysis the other approach is

52
00:01:59,369 --> 00:02:03,719
dynamic analysis so you run the

53
00:02:01,619 --> 00:02:05,159
application you monitor it as it's

54
00:02:03,719 --> 00:02:06,990
running you interact with it in some

55
00:02:05,159 --> 00:02:09,810
fashion or another and with the aim of

56
00:02:06,990 --> 00:02:11,879
finding bugs so fuzzing tampering

57
00:02:09,810 --> 00:02:13,650
functional testing and the traditional

58
00:02:11,879 --> 00:02:15,298
penetration test and so on that will

59
00:02:13,650 --> 00:02:16,860
under dynamic analysis funnily enough

60
00:02:15,299 --> 00:02:20,280
given the talk title we're gonna be

61
00:02:16,860 --> 00:02:21,900
focusing on static analysis here we're

62
00:02:20,280 --> 00:02:23,459
looking mainly at code review I

63
00:02:21,900 --> 00:02:26,730
understand there's a quite a few vendors

64
00:02:23,459 --> 00:02:27,900
that do various binary static analysis

65
00:02:26,730 --> 00:02:29,310
tools I don't know a huge amount about

66
00:02:27,900 --> 00:02:33,150
those please don't answer me questions

67
00:02:29,310 --> 00:02:37,079
on them later so how do we do code

68
00:02:33,150 --> 00:02:38,870
review two approaches manual give it to

69
00:02:37,079 --> 00:02:41,069
someone who understands the code I

70
00:02:38,870 --> 00:02:42,930
expect them to find some bugs for you

71
00:02:41,069 --> 00:02:44,129
there's a lot of very smart people in

72
00:02:42,930 --> 00:02:45,690
the security industry a lot of them with

73
00:02:44,129 --> 00:02:48,060
a lot of experience finding obscure and

74
00:02:45,690 --> 00:02:49,980
esoteric bugs in software and that

75
00:02:48,060 --> 00:02:52,019
typically works quite well the other

76
00:02:49,980 --> 00:02:54,810
option is to do it an automated fashion

77
00:02:52,019 --> 00:02:57,359
pass your code to a tool and the tool

78
00:02:54,810 --> 00:02:59,220
will pause the code hunt for some issues

79
00:02:57,359 --> 00:03:00,840
that it understands and that's all has

80
00:02:59,220 --> 00:03:02,519
some understanding of how how the code

81
00:03:00,840 --> 00:03:05,579
operates and you you hunt classes of

82
00:03:02,519 --> 00:03:08,480
bugs based on that in terms of doing

83
00:03:05,579 --> 00:03:11,400
manual code review couple of examples a

84
00:03:08,480 --> 00:03:12,959
really basic buffer overflow here and no

85
00:03:11,400 --> 00:03:15,120
one's checking how much stuff is going

86
00:03:12,959 --> 00:03:16,799
into the the buffer you've got there and

87
00:03:15,120 --> 00:03:18,660
so there's a potential for the overflow

88
00:03:16,799 --> 00:03:20,010
in the printf statement and likewise if

89
00:03:18,660 --> 00:03:22,680
we've got any Android devs in the

90
00:03:20,010 --> 00:03:24,209
audience having JavaScript enabled on

91
00:03:22,680 --> 00:03:26,250
your Android web views generally doesn't

92
00:03:24,209 --> 00:03:27,660
end terribly well nice and easy to spot

93
00:03:26,250 --> 00:03:29,699
when you've got a couple of lines on the

94
00:03:27,660 --> 00:03:31,680
screen when you're looking at large code

95
00:03:29,699 --> 00:03:33,269
bases that starts getting very

96
00:03:31,680 --> 00:03:34,799
complicated and very expensive I pulled

97
00:03:33,269 --> 00:03:36,930
some numbers on the sort of sizes of

98
00:03:34,799 --> 00:03:40,620
some of the more famous code bases these

99
00:03:36,930 --> 00:03:43,199
days 86 million lines of code for Mac OS

100
00:03:40,620 --> 00:03:45,629
X was one of the bigger and but even the

101
00:03:43,199 --> 00:03:47,819
new joint strike fighters got about 24

102
00:03:45,629 --> 00:03:49,590
25 million lines there's an awful lot

103
00:03:47,819 --> 00:03:50,879
there to try and analyze in a manual

104
00:03:49,590 --> 00:03:53,340
fashion

105
00:03:50,879 --> 00:03:54,870
and Steve McConnell he wrote code

106
00:03:53,340 --> 00:03:57,389
complete reckons somewhere in the region

107
00:03:54,870 --> 00:03:59,669
of 10 to 20 defects of some sort not

108
00:03:57,389 --> 00:04:01,650
security bugs specifically but bugs of

109
00:03:59,669 --> 00:04:04,799
some class or another per thousand lines

110
00:04:01,650 --> 00:04:08,280
of code which works out with some pretty

111
00:04:04,799 --> 00:04:10,349
staggering numbers and 1.35 million for

112
00:04:08,280 --> 00:04:11,609
mac OS x apparently and but even in a

113
00:04:10,349 --> 00:04:13,369
you know what is supposedly a brand

114
00:04:11,609 --> 00:04:16,130
spanking u fighter jet you're looking at

115
00:04:13,370 --> 00:04:17,970
350,000 bugs of some sort or another

116
00:04:16,130 --> 00:04:19,440
that's an awful lot of bugs and

117
00:04:17,970 --> 00:04:21,989
expecting people to find that manually

118
00:04:19,440 --> 00:04:25,260
is probably too much so instead we do

119
00:04:21,988 --> 00:04:27,010
static code analysis automated searching

120
00:04:25,260 --> 00:04:30,340
your source code for issues in

121
00:04:27,010 --> 00:04:31,420
source code analysis higher upfront cost

122
00:04:30,340 --> 00:04:33,549
generally if you're developing the

123
00:04:31,420 --> 00:04:36,040
tooling from scratch but once you go to

124
00:04:33,550 --> 00:04:38,830
setup built with a decent rule set it's

125
00:04:36,040 --> 00:04:40,330
essentially free security you pass your

126
00:04:38,830 --> 00:04:41,469
code through the tool it gives you some

127
00:04:40,330 --> 00:04:44,109
results and will catch quite a few

128
00:04:41,470 --> 00:04:46,570
things for you and roll the sort of the

129
00:04:44,110 --> 00:04:48,220
low-hanging fruit will automatically be

130
00:04:46,570 --> 00:04:49,900
picked up by it and you're devs can fix

131
00:04:48,220 --> 00:04:53,230
it nice and early on in the development

132
00:04:49,900 --> 00:04:54,760
lifecycle so to understand a bit about

133
00:04:53,230 --> 00:04:57,310
how these tools work let's have a look

134
00:04:54,760 --> 00:04:58,390
at the some of the theory behind it so

135
00:04:57,310 --> 00:04:59,050
for those of you who did computer

136
00:04:58,390 --> 00:05:00,550
science degrees

137
00:04:59,050 --> 00:05:02,770
I apologize you've probably seen a bunch

138
00:05:00,550 --> 00:05:04,360
of this before and for everyone else I'm

139
00:05:02,770 --> 00:05:06,099
trying to compress a semester or so of

140
00:05:04,360 --> 00:05:08,110
compiler theory down into five minutes

141
00:05:06,100 --> 00:05:11,830
so this is a bit of a whistle-stop talk

142
00:05:08,110 --> 00:05:13,660
but nonetheless fundamentally

143
00:05:11,830 --> 00:05:15,669
programming languages are essentially

144
00:05:13,660 --> 00:05:17,560
just a set of strings of symbols that

145
00:05:15,670 --> 00:05:19,750
have been defined by some sort of rule

146
00:05:17,560 --> 00:05:21,100
set we call that rule set grammar and

147
00:05:19,750 --> 00:05:22,470
you have different grammars for

148
00:05:21,100 --> 00:05:25,750
different types of languages and

149
00:05:22,470 --> 00:05:28,240
depending on the rules for that language

150
00:05:25,750 --> 00:05:29,920
specifically it's a guy called Noam

151
00:05:28,240 --> 00:05:31,900
Chomsky who some of you will no doubt

152
00:05:29,920 --> 00:05:35,170
heard of defined a hierarchy of like

153
00:05:31,900 --> 00:05:39,400
hierarchy of languages and each language

154
00:05:35,170 --> 00:05:42,250
is a subset of another and as you get

155
00:05:39,400 --> 00:05:44,770
further down the list there the grammars

156
00:05:42,250 --> 00:05:46,720
that define them are stricter which also

157
00:05:44,770 --> 00:05:48,969
means it's easier to implement faster

158
00:05:46,720 --> 00:05:51,030
parsers for them most programming

159
00:05:48,970 --> 00:05:53,020
languages roughly fall under

160
00:05:51,030 --> 00:05:56,909
context-free so that's what we'll be

161
00:05:53,020 --> 00:05:56,909
talking about here for the most part a

162
00:05:57,030 --> 00:06:00,580
context-free language is anything that

163
00:05:58,870 --> 00:06:03,880
can be parsed by a context-free grammar

164
00:06:00,580 --> 00:06:06,300
and which will look at exactly what that

165
00:06:03,880 --> 00:06:09,070
means in a second when we get it down to

166
00:06:06,300 --> 00:06:10,600
how the pauses for that work and but

167
00:06:09,070 --> 00:06:12,820
we're looking at that like I say because

168
00:06:10,600 --> 00:06:15,850
for the most part program languages are

169
00:06:12,820 --> 00:06:17,170
context-free and this is why if any of

170
00:06:15,850 --> 00:06:18,280
you have ever tried to pass programming

171
00:06:17,170 --> 00:06:20,050
languages with regular expressions

172
00:06:18,280 --> 00:06:21,760
doesn't generally tend to end too well

173
00:06:20,050 --> 00:06:23,020
and there are limitations around what

174
00:06:21,760 --> 00:06:25,510
most regular expressions are capable of

175
00:06:23,020 --> 00:06:27,250
doing which makes this quite nasty and I

176
00:06:25,510 --> 00:06:28,990
also say mostly context-free because

177
00:06:27,250 --> 00:06:30,340
things like C++ with all its templates

178
00:06:28,990 --> 00:06:33,940
and macros throws all that off

179
00:06:30,340 --> 00:06:37,539
completely but context-free grammars get

180
00:06:33,940 --> 00:06:39,250
implemented as a pushdown automata which

181
00:06:37,540 --> 00:06:40,780
is essentially a finite state machine

182
00:06:39,250 --> 00:06:42,460
but with a stack bolted

183
00:06:40,780 --> 00:06:44,530
the side of it that you can push and pop

184
00:06:42,460 --> 00:06:46,000
from and allows you to decide

185
00:06:44,530 --> 00:06:47,650
transitions within your state machine

186
00:06:46,000 --> 00:06:51,790
based either on what's coming in from

187
00:06:47,650 --> 00:06:53,919
the tape what's on the stack or both so

188
00:06:51,790 --> 00:06:57,610
that's essentially how parsers for most

189
00:06:53,919 --> 00:06:59,409
programming languages function so you

190
00:06:57,610 --> 00:07:01,060
define a grammar that is then

191
00:06:59,410 --> 00:07:03,550
implemented as a state machine with a

192
00:07:01,060 --> 00:07:05,410
stack and that's used to convert the

193
00:07:03,550 --> 00:07:07,200
source code you pass into it into some

194
00:07:05,410 --> 00:07:10,300
kind of hierarchical data structure and

195
00:07:07,200 --> 00:07:11,950
usually an abstract syntax tree is what

196
00:07:10,300 --> 00:07:13,990
you're working with when you're doing

197
00:07:11,950 --> 00:07:17,770
static analysis and an abstract syntax

198
00:07:13,990 --> 00:07:20,080
tree is a tree of tokens so different

199
00:07:17,770 --> 00:07:21,490
bits of a piece of source code with

200
00:07:20,080 --> 00:07:23,560
information attached as to what they are

201
00:07:21,490 --> 00:07:27,370
whether they're function calls variables

202
00:07:23,560 --> 00:07:29,830
so on and so forth positively break down

203
00:07:27,370 --> 00:07:32,320
into two separate stages a lexer takes

204
00:07:29,830 --> 00:07:34,390
the source code as it is just a text

205
00:07:32,320 --> 00:07:37,300
file with no meaning and splits that

206
00:07:34,390 --> 00:07:38,560
into tokens identifiable pieces of a

207
00:07:37,300 --> 00:07:40,300
programming language being as I say a

208
00:07:38,560 --> 00:07:42,580
function call a variable line

209
00:07:40,300 --> 00:07:44,530
terminators so on and so forth and then

210
00:07:42,580 --> 00:07:46,690
once the tokenization process has been

211
00:07:44,530 --> 00:07:48,849
completed a parser then walks that and

212
00:07:46,690 --> 00:07:53,350
gain some understanding of actually what

213
00:07:48,850 --> 00:07:55,419
each of these tokens do and as an

214
00:07:53,350 --> 00:07:57,160
example of a lexer so we've got here and

215
00:07:55,419 --> 00:07:58,450
someone's doing something by outputting

216
00:07:57,160 --> 00:08:01,060
we've got some princess to princeton

217
00:07:58,450 --> 00:08:03,250
code and celexa after you've run it

218
00:08:01,060 --> 00:08:05,500
we'll pick out that we've got function

219
00:08:03,250 --> 00:08:07,510
calls some variables line terminators

220
00:08:05,500 --> 00:08:09,460
the the brackets to define a code block

221
00:08:07,510 --> 00:08:10,710
and so on and and then when that gets

222
00:08:09,460 --> 00:08:13,450
passed into the parser

223
00:08:10,710 --> 00:08:14,770
it finds the the if statement works out

224
00:08:13,450 --> 00:08:18,099
that we have a we have an if statement

225
00:08:14,770 --> 00:08:21,609
there bracket realizes we have a code

226
00:08:18,100 --> 00:08:24,340
block from there you then pick up the

227
00:08:21,610 --> 00:08:25,870
princess and close the code block off

228
00:08:24,340 --> 00:08:27,760
again but this gives you a hierarchical

229
00:08:25,870 --> 00:08:28,330
understanding of the program that you're

230
00:08:27,760 --> 00:08:29,860
looking at

231
00:08:28,330 --> 00:08:31,150
which means you then have a tree you

232
00:08:29,860 --> 00:08:32,740
could you can walk and gather

233
00:08:31,150 --> 00:08:34,838
information about so now that we've got

234
00:08:32,740 --> 00:08:39,969
an abstract syntax tree what does that

235
00:08:34,839 --> 00:08:41,380
actually buy us so you can search the

236
00:08:39,969 --> 00:08:42,760
ASA T at a basic level for things like

237
00:08:41,380 --> 00:08:46,510
calls the functions you know you don't

238
00:08:42,760 --> 00:08:47,710
want and debug guards if they should be

239
00:08:46,510 --> 00:08:50,530
there maybe they're not maybe you're

240
00:08:47,710 --> 00:08:52,180
outputting data to locations that you

241
00:08:50,530 --> 00:08:54,360
don't want it to in a in a production

242
00:08:52,180 --> 00:08:56,170
environment log files so on

243
00:08:54,360 --> 00:08:57,490
questionable imports potentially

244
00:08:56,170 --> 00:08:59,229
depending on the passes you're using and

245
00:08:57,490 --> 00:09:00,819
so on and so forth you can do this with

246
00:08:59,230 --> 00:09:03,220
regular expressions a lot of people do

247
00:09:00,819 --> 00:09:04,719
and having an understanding of that code

248
00:09:03,220 --> 00:09:06,310
structure that the abstract syntax tree

249
00:09:04,720 --> 00:09:08,889
gives you means you get far fewer false

250
00:09:06,310 --> 00:09:10,899
positives as a result but the real power

251
00:09:08,889 --> 00:09:13,689
of having an abstract syntax tree comes

252
00:09:10,899 --> 00:09:15,220
in from the control flow graphs that we

253
00:09:13,689 --> 00:09:18,519
can build off it and the various types

254
00:09:15,220 --> 00:09:22,319
analysis we can do from there so let's

255
00:09:18,519 --> 00:09:22,319
take a look at a control flow graph is a

256
00:09:22,560 --> 00:09:26,680
representation using graph notation of

257
00:09:24,939 --> 00:09:29,110
all the paths that may be traversed

258
00:09:26,680 --> 00:09:32,709
through a given piece of code as the

259
00:09:29,110 --> 00:09:36,490
analyzer has scan so each basic block

260
00:09:32,709 --> 00:09:38,949
within the control flow graph is defined

261
00:09:36,490 --> 00:09:41,680
as a set of statements with a jump

262
00:09:38,949 --> 00:09:44,139
target at the start and a jump at the

263
00:09:41,680 --> 00:09:46,479
end and so for instance if you have an

264
00:09:44,139 --> 00:09:48,790
if statement with an else clause as well

265
00:09:46,480 --> 00:09:50,350
your to base it or your three basic

266
00:09:48,790 --> 00:09:53,019
blocks there are the if statement itself

267
00:09:50,350 --> 00:09:55,060
the contents of the if block and the

268
00:09:53,019 --> 00:09:57,930
contents of the else block as defined by

269
00:09:55,060 --> 00:10:00,099
the the appropriate jumps either side um

270
00:09:57,930 --> 00:10:02,258
some of you might come across it for

271
00:10:00,100 --> 00:10:04,810
uses compile optimization it's a good

272
00:10:02,259 --> 00:10:06,810
way of filtering out unreachable dead

273
00:10:04,810 --> 00:10:09,489
code detection of infinite loops and

274
00:10:06,810 --> 00:10:12,630
optimizing arithmetic that kind of thing

275
00:10:09,490 --> 00:10:15,069
and to give you an example of a few and

276
00:10:12,630 --> 00:10:19,329
the one on the the far left there a is a

277
00:10:15,069 --> 00:10:20,979
very basic if-then-else block B is a

278
00:10:19,329 --> 00:10:22,329
while loop you have a loop going on with

279
00:10:20,980 --> 00:10:22,839
a jump condition that breaks you out of

280
00:10:22,329 --> 00:10:27,880
it

281
00:10:22,839 --> 00:10:30,040
C is a loop with a break clause in D is

282
00:10:27,880 --> 00:10:31,389
a loop with two entry points if

283
00:10:30,040 --> 00:10:32,410
someone's got some nasty go twos and

284
00:10:31,389 --> 00:10:34,060
their codes still and you're jumping

285
00:10:32,410 --> 00:10:35,529
into it that way and you end up you can

286
00:10:34,060 --> 00:10:37,649
end up with some some quite nasty

287
00:10:35,529 --> 00:10:40,930
control flow graphs as a result but

288
00:10:37,649 --> 00:10:42,250
having an understanding of that allows

289
00:10:40,930 --> 00:10:45,189
us to do quite a few fun things with it

290
00:10:42,250 --> 00:10:46,949
so now that we can trace execution

291
00:10:45,189 --> 00:10:49,750
without actually executing the program

292
00:10:46,949 --> 00:10:51,430
we can do a number of different types of

293
00:10:49,750 --> 00:10:53,920
analysis the core ones we're going to

294
00:10:51,430 --> 00:10:59,589
focus on here are taint analysis and

295
00:10:53,920 --> 00:11:02,469
pointer tracking so taint analysis look

296
00:10:59,589 --> 00:11:03,579
for sinks of data if you have a web

297
00:11:02,470 --> 00:11:05,920
application that's querying a database

298
00:11:03,579 --> 00:11:07,239
to the point at which the data goes into

299
00:11:05,920 --> 00:11:09,000
the database query function is an

300
00:11:07,240 --> 00:11:11,230
example of that

301
00:11:09,000 --> 00:11:12,760
when you see some input being passed

302
00:11:11,230 --> 00:11:14,620
into a function like that you can then

303
00:11:12,760 --> 00:11:17,079
walk back up your control flow graph to

304
00:11:14,620 --> 00:11:19,300
see where this data came in it's

305
00:11:17,079 --> 00:11:20,469
possible that the data sanitization was

306
00:11:19,300 --> 00:11:21,640
performed right at the beginning if

307
00:11:20,470 --> 00:11:22,779
you're scanning with regular expressions

308
00:11:21,640 --> 00:11:24,130
or you're just reading it through

309
00:11:22,779 --> 00:11:26,079
yourself it can often be quite difficult

310
00:11:24,130 --> 00:11:28,689
to track back exactly where that

311
00:11:26,079 --> 00:11:30,609
happened and but with the power of

312
00:11:28,690 --> 00:11:32,680
control flow graphs you can do that in a

313
00:11:30,610 --> 00:11:34,510
fairly automated fashion quite easily so

314
00:11:32,680 --> 00:11:37,209
there's an example of what we can do

315
00:11:34,510 --> 00:11:39,819
with taint in our system terrible PHP I

316
00:11:37,209 --> 00:11:41,199
threw together and you can see we've got

317
00:11:39,820 --> 00:11:44,290
a query happening down the bottom where

318
00:11:41,200 --> 00:11:46,660
someone is just passing in strings into

319
00:11:44,290 --> 00:11:48,519
a into a query there and that's not

320
00:11:46,660 --> 00:11:49,779
great but we don't automatically know if

321
00:11:48,519 --> 00:11:52,480
there's a vulnerability there looking

322
00:11:49,779 --> 00:11:55,029
purely at that function called down the

323
00:11:52,480 --> 00:11:57,190
bottom there so what we can do is track

324
00:11:55,029 --> 00:11:58,480
back up to where the two variables being

325
00:11:57,190 --> 00:11:59,829
passed into it came from here they're

326
00:11:58,480 --> 00:12:02,100
being passed into this log in query

327
00:11:59,829 --> 00:12:05,859
function okay where was that called

328
00:12:02,100 --> 00:12:07,300
back up again we have them being passed

329
00:12:05,860 --> 00:12:09,430
into the function call there and they

330
00:12:07,300 --> 00:12:11,800
came in term from the function call for

331
00:12:09,430 --> 00:12:14,469
that function and right back up the top

332
00:12:11,800 --> 00:12:16,630
there we have unsanitized user input

333
00:12:14,470 --> 00:12:18,190
being passed in we've not found any

334
00:12:16,630 --> 00:12:20,320
sanitization happening as part of that

335
00:12:18,190 --> 00:12:24,029
process so we can then say that there is

336
00:12:20,320 --> 00:12:24,029
an SQL injection vulnerability they're

337
00:12:24,600 --> 00:12:31,720
looking at pointer tracking when you're

338
00:12:28,899 --> 00:12:33,550
walking the graph we can track creation

339
00:12:31,720 --> 00:12:35,589
and destruction of pointers we can track

340
00:12:33,550 --> 00:12:37,930
where memory is allocated where it's the

341
00:12:35,589 --> 00:12:39,579
allocated and as a result of that you

342
00:12:37,930 --> 00:12:43,380
can then follow the control group flow

343
00:12:39,579 --> 00:12:45,819
graphs through and identify where your

344
00:12:43,380 --> 00:12:47,709
double freeing a pointer or your

345
00:12:45,820 --> 00:12:49,390
referencing memory that's been the

346
00:12:47,709 --> 00:12:52,149
allocated already so on and so forth so

347
00:12:49,390 --> 00:12:54,040
as an example here and we allocate some

348
00:12:52,149 --> 00:12:55,510
things we create a pointer and if we

349
00:12:54,040 --> 00:12:58,060
reach an error condition then we should

350
00:12:55,510 --> 00:13:00,279
free this pointer and if however we are

351
00:12:58,060 --> 00:13:01,959
also in debug mode and then maybe we

352
00:13:00,279 --> 00:13:05,050
want to print some stuff out but because

353
00:13:01,959 --> 00:13:07,149
that's happening after we freed it we

354
00:13:05,050 --> 00:13:08,859
get a memory corruption issue here the

355
00:13:07,149 --> 00:13:10,600
fundamental problem though is that in

356
00:13:08,860 --> 00:13:12,430
many cases you may not spot something

357
00:13:10,600 --> 00:13:14,079
like this the first few times it runs

358
00:13:12,430 --> 00:13:15,160
because let's say we're not in debug

359
00:13:14,079 --> 00:13:18,910
mode that's never going to actually

360
00:13:15,160 --> 00:13:21,069
crash and but walking through it we can

361
00:13:18,910 --> 00:13:21,969
see having followed off control flow

362
00:13:21,069 --> 00:13:24,069
graph we've got a malloc

363
00:13:21,970 --> 00:13:26,980
okay that's fine we'll register that and

364
00:13:24,069 --> 00:13:29,349
we then also notice that there's a free

365
00:13:26,980 --> 00:13:31,240
that happens here okay that's fine let's

366
00:13:29,350 --> 00:13:33,699
see if this this point is then used

367
00:13:31,240 --> 00:13:34,779
anywhere else and lo and behold we spot

368
00:13:33,699 --> 00:13:36,550
down the bottom that is also actually

369
00:13:34,779 --> 00:13:37,779
used here and so as a result there are

370
00:13:36,550 --> 00:13:40,120
certain conditions that can cause a

371
00:13:37,779 --> 00:13:42,250
memory corruption you can use it to find

372
00:13:40,120 --> 00:13:44,009
null pointers used after freeze dangling

373
00:13:42,250 --> 00:13:46,329
pointers a variety of issues like this

374
00:13:44,009 --> 00:13:48,490
now as we're at a dev stack ops

375
00:13:46,329 --> 00:13:51,239
conference let's take a look at what we

376
00:13:48,490 --> 00:13:53,740
can do with it in this context and

377
00:13:51,240 --> 00:13:55,060
static analysis is an ST LC is no doubt

378
00:13:53,740 --> 00:13:57,639
something with a few quite a few of you

379
00:13:55,060 --> 00:13:58,989
are using already and catching all the

380
00:13:57,639 --> 00:14:00,910
issues before it gets the stage where

381
00:13:58,990 --> 00:14:02,470
penetration testers are looking at your

382
00:14:00,910 --> 00:14:03,819
application and if you've got a couple

383
00:14:02,470 --> 00:14:05,680
of smart dev so you can build this kind

384
00:14:03,819 --> 00:14:07,269
of tooling or who can work with existing

385
00:14:05,680 --> 00:14:09,099
tools to develop rule sets for your

386
00:14:07,269 --> 00:14:10,569
application and then you can use that

387
00:14:09,100 --> 00:14:12,279
within the context of the rest of your

388
00:14:10,569 --> 00:14:14,790
development team without any real

389
00:14:12,279 --> 00:14:16,839
additional required effort on their part

390
00:14:14,790 --> 00:14:18,490
you can build into your continuous

391
00:14:16,839 --> 00:14:20,139
integration systems as a number of

392
00:14:18,490 --> 00:14:23,589
people do or you can just use it running

393
00:14:20,139 --> 00:14:25,240
on desktop as part of your IDs but it

394
00:14:23,589 --> 00:14:27,699
also helps catch regressions in code

395
00:14:25,240 --> 00:14:29,980
before save codes hits production and

396
00:14:27,699 --> 00:14:32,589
which is one of the issues that people

397
00:14:29,980 --> 00:14:34,300
often run into so one interesting

398
00:14:32,589 --> 00:14:36,160
anecdote there Marks and Spencers had a

399
00:14:34,300 --> 00:14:38,370
fairly major data breach a little while

400
00:14:36,160 --> 00:14:38,370
back

401
00:14:38,399 --> 00:14:42,399
basically they introduced a regression

402
00:14:40,720 --> 00:14:44,620
into their system as a result of a bug

403
00:14:42,399 --> 00:14:46,509
fix for some other issues and were

404
00:14:44,620 --> 00:14:48,220
presenting people's credit card

405
00:14:46,509 --> 00:14:50,589
information to other customers so I

406
00:14:48,220 --> 00:14:52,480
login as me and I receive credit card

407
00:14:50,589 --> 00:14:53,519
information in my in my view front from

408
00:14:52,480 --> 00:14:55,300
other customers thankfully it was only

409
00:14:53,519 --> 00:14:56,199
small parts of the credit card

410
00:14:55,300 --> 00:14:58,209
information but it's still a fairly

411
00:14:56,199 --> 00:15:00,128
damaging story for them and if they've

412
00:14:58,209 --> 00:15:01,479
had proper static analysis and

413
00:15:00,129 --> 00:15:03,009
regression testing and so on and so

414
00:15:01,480 --> 00:15:06,639
forth then this may not have happened

415
00:15:03,009 --> 00:15:08,800
necessarily so actually we use it for

416
00:15:06,639 --> 00:15:12,910
code we know about that can we also use

417
00:15:08,800 --> 00:15:14,469
it to analyze infrastructure so a lot of

418
00:15:12,910 --> 00:15:16,029
the the modern systems for doing

419
00:15:14,470 --> 00:15:18,399
infrastructure as code are essentially

420
00:15:16,029 --> 00:15:21,040
just more software in some fashion other

421
00:15:18,399 --> 00:15:22,149
it's more source code and I'm sure a lot

422
00:15:21,040 --> 00:15:23,829
of you are familiar with infrastructure

423
00:15:22,149 --> 00:15:27,550
as code as a concept but just for those

424
00:15:23,829 --> 00:15:29,709
who aren't and we're looking at systems

425
00:15:27,550 --> 00:15:31,359
definition stored in configuration files

426
00:15:29,709 --> 00:15:33,819
of one form or another being pushed and

427
00:15:31,360 --> 00:15:35,529
pulled by by agents or servers and and

428
00:15:33,819 --> 00:15:37,509
some of the names down

429
00:15:35,529 --> 00:15:43,569
will no doubt be familiar to quite a few

430
00:15:37,509 --> 00:15:46,269
people here so often if we want to test

431
00:15:43,569 --> 00:15:47,860
this it's being tested with a number of

432
00:15:46,269 --> 00:15:48,220
different unit and integration testing

433
00:15:47,860 --> 00:15:50,620
tools

434
00:15:48,220 --> 00:15:52,120
I understand continuum here today BDD

435
00:15:50,620 --> 00:15:53,920
security is one of the ones we see use

436
00:15:52,120 --> 00:15:55,990
quite a lot and there are a number of

437
00:15:53,920 --> 00:15:58,329
others as well the idea here being that

438
00:15:55,990 --> 00:16:00,730
you spin up your environment using your

439
00:15:58,329 --> 00:16:02,979
configuration files and what that gets

440
00:16:00,730 --> 00:16:04,240
us is a full environment we can test we

441
00:16:02,980 --> 00:16:05,949
have some definitions of what this

442
00:16:04,240 --> 00:16:08,439
environment should look like we validate

443
00:16:05,949 --> 00:16:10,240
that our configuration management tools

444
00:16:08,439 --> 00:16:12,219
have correctly setup the environment as

445
00:16:10,240 --> 00:16:13,389
it is expected and now that's great

446
00:16:12,220 --> 00:16:14,439
you've got to spin up a big

447
00:16:13,389 --> 00:16:15,699
infrastructure in the case of some

448
00:16:14,439 --> 00:16:17,439
organizations and you might be looking

449
00:16:15,699 --> 00:16:18,699
at hundreds of virtual machines and that

450
00:16:17,439 --> 00:16:24,610
can get quite time-consuming expensive

451
00:16:18,699 --> 00:16:25,930
potentially so what else can we do some

452
00:16:24,610 --> 00:16:27,519
people are already looking at this from

453
00:16:25,930 --> 00:16:29,620
a point of view of maintainability

454
00:16:27,519 --> 00:16:31,660
syntax style checking so on and so forth

455
00:16:29,620 --> 00:16:33,009
as a number of tools there and but we

456
00:16:31,660 --> 00:16:35,860
can actually also use this to catch

457
00:16:33,009 --> 00:16:37,689
security issues in the code bases for

458
00:16:35,860 --> 00:16:40,809
these tools as they're being pushed to

459
00:16:37,689 --> 00:16:41,829
your your repositories so as a few

460
00:16:40,809 --> 00:16:43,120
examples of the kind of things that

461
00:16:41,829 --> 00:16:45,189
would be pretty easy to find quite

462
00:16:43,120 --> 00:16:46,629
quickly and things like hard-coded

463
00:16:45,189 --> 00:16:48,399
passwords and I'm most familiar with

464
00:16:46,629 --> 00:16:50,529
ansible personally it's an example here

465
00:16:48,399 --> 00:16:52,420
a man's will has ansible volt and if

466
00:16:50,529 --> 00:16:54,220
you're just embedding your passwords in

467
00:16:52,420 --> 00:16:55,509
plain text in your config files and

468
00:16:54,220 --> 00:16:56,980
those are being pushed to get that's

469
00:16:55,509 --> 00:16:59,730
probably not a great thing to be doing

470
00:16:56,980 --> 00:17:01,779
so flagging issues like that it's great

471
00:16:59,730 --> 00:17:03,129
presence of unnecessary tooling on

472
00:17:01,779 --> 00:17:05,530
service so often if you're building a

473
00:17:03,129 --> 00:17:07,990
server you'll need GCC and the rest of

474
00:17:05,530 --> 00:17:09,129
the build tools but you might not

475
00:17:07,990 --> 00:17:11,079
necessarily need them on the production

476
00:17:09,130 --> 00:17:12,760
server once that's finished now as a

477
00:17:11,079 --> 00:17:14,948
penetration tester if I get on to a box

478
00:17:12,760 --> 00:17:16,599
and I've got GCC and a whole load of

479
00:17:14,949 --> 00:17:18,189
interpreters for languages you're not

480
00:17:16,599 --> 00:17:19,629
using and so on and so forth that makes

481
00:17:18,189 --> 00:17:20,589
my life an awful lot easier because

482
00:17:19,630 --> 00:17:22,240
rather than having to set up cross

483
00:17:20,589 --> 00:17:24,309
compilation tool chains and things I can

484
00:17:22,240 --> 00:17:26,709
just compile on the service so removing

485
00:17:24,309 --> 00:17:28,539
things like that is also worth noting in

486
00:17:26,709 --> 00:17:30,370
you can you can pick that up too and or

487
00:17:28,539 --> 00:17:31,658
equally just failure to apply some of

488
00:17:30,370 --> 00:17:34,600
the common hardening principles you see

489
00:17:31,659 --> 00:17:36,250
people applying and SSH configuration

490
00:17:34,600 --> 00:17:38,530
issues password authentication or root

491
00:17:36,250 --> 00:17:41,740
login and overly permissive firewall

492
00:17:38,530 --> 00:17:43,928
rules and maybe they're not applying the

493
00:17:41,740 --> 00:17:45,580
kernel hardening that's you're expecting

494
00:17:43,929 --> 00:17:47,559
them to use and things that your

495
00:17:45,580 --> 00:17:48,470
policies are defining must be in place

496
00:17:47,559 --> 00:17:50,120
we can

497
00:17:48,470 --> 00:17:53,230
a fair number of them probably and

498
00:17:50,120 --> 00:17:57,039
before even actually hits the repository

499
00:17:53,230 --> 00:17:59,570
what do we actually need for doing that

500
00:17:57,039 --> 00:18:01,340
parser for the configuration management

501
00:17:59,570 --> 00:18:02,689
tools domain-specific language often

502
00:18:01,340 --> 00:18:04,610
that's quite easy because they'll be

503
00:18:02,690 --> 00:18:05,990
either a programming language themselves

504
00:18:04,610 --> 00:18:08,928
in the case of a few and I Ruby's quite

505
00:18:05,990 --> 00:18:10,789
a common one oh yeah Mille in the case

506
00:18:08,929 --> 00:18:12,799
of ansible and they're all established

507
00:18:10,789 --> 00:18:14,530
languages very easy to find existing

508
00:18:12,799 --> 00:18:17,090
open source libraries to parse for you

509
00:18:14,530 --> 00:18:18,740
and you need some kind of rules engine

510
00:18:17,090 --> 00:18:20,299
essentially a list of rules that define

511
00:18:18,740 --> 00:18:22,580
what you expect goods to look like what

512
00:18:20,299 --> 00:18:23,870
you expect bad to look like such that

513
00:18:22,580 --> 00:18:26,330
the tool has some idea of what it's

514
00:18:23,870 --> 00:18:28,010
looking for and to analyze as we

515
00:18:26,330 --> 00:18:29,658
discussed before what the ast that

516
00:18:28,010 --> 00:18:32,419
you've created compare the tree nodes

517
00:18:29,659 --> 00:18:33,919
against your rules database and this

518
00:18:32,419 --> 00:18:35,809
actually in many respects is much easier

519
00:18:33,919 --> 00:18:37,370
than source code analysis because what

520
00:18:35,809 --> 00:18:39,320
is happening in these tools is less

521
00:18:37,370 --> 00:18:42,080
complex than a full programming language

522
00:18:39,320 --> 00:18:43,549
and so you don't need taint analysis you

523
00:18:42,080 --> 00:18:44,600
don't need your pointer tracking there's

524
00:18:43,549 --> 00:18:46,070
no pointers in any configuration

525
00:18:44,600 --> 00:18:48,918
management systems that I've come across

526
00:18:46,070 --> 00:18:50,809
and so building this is much easier in

527
00:18:48,919 --> 00:18:53,450
many respects than building a full

528
00:18:50,809 --> 00:18:57,980
source code static analysis tool as an

529
00:18:53,450 --> 00:19:01,150
example let's take a look at Samantha

530
00:18:57,980 --> 00:19:04,520
ball here we're setting up a or enabling

531
00:19:01,150 --> 00:19:06,710
ufw on a box and we're allowing some

532
00:19:04,520 --> 00:19:08,629
some password authentication through our

533
00:19:06,710 --> 00:19:09,770
SSH first ones probably pretty good

534
00:19:08,630 --> 00:19:11,270
second one not so much

535
00:19:09,770 --> 00:19:13,789
so we're you know we have some rules

536
00:19:11,270 --> 00:19:17,110
that catch these kinds of cases we look

537
00:19:13,789 --> 00:19:19,190
for password authentication we say if

538
00:19:17,110 --> 00:19:20,959
password authentication is yes then we

539
00:19:19,190 --> 00:19:23,240
should probably raise that as a as an

540
00:19:20,960 --> 00:19:25,520
issue and likewise if ufw is set with

541
00:19:23,240 --> 00:19:28,340
its default policy as allow that's also

542
00:19:25,520 --> 00:19:31,549
not great and so we run this over the

543
00:19:28,340 --> 00:19:33,830
static analysis re the configuration

544
00:19:31,549 --> 00:19:35,990
files we defined and so here we flag

545
00:19:33,830 --> 00:19:38,240
that we found the rule involving a task

546
00:19:35,990 --> 00:19:40,580
involving ufw our rule catch is that it

547
00:19:38,240 --> 00:19:42,380
then checks what the policy is and sees

548
00:19:40,580 --> 00:19:46,070
that the policy is set to deny that's

549
00:19:42,380 --> 00:19:48,710
fine everything's ok we now flag that

550
00:19:46,070 --> 00:19:52,309
we've got a line in file entry our

551
00:19:48,710 --> 00:19:53,870
previous rule if we if we check so we

552
00:19:52,309 --> 00:19:56,090
find a line in file we then look at the

553
00:19:53,870 --> 00:19:57,979
regular expression that defines the line

554
00:19:56,090 --> 00:20:01,010
in fire rule and then see what happens

555
00:19:57,980 --> 00:20:02,419
with that so here we find that the

556
00:20:01,010 --> 00:20:03,649
regular expression contains this part

557
00:20:02,419 --> 00:20:05,899
to an authentication thing which is what

558
00:20:03,649 --> 00:20:07,518
we're looking for and we then check what

559
00:20:05,899 --> 00:20:09,080
the contents of it is and lo and behold

560
00:20:07,519 --> 00:20:10,940
someone's decided that password

561
00:20:09,080 --> 00:20:12,799
authentication on SSH is great and they

562
00:20:10,940 --> 00:20:15,070
don't like keys and so that is something

563
00:20:12,799 --> 00:20:19,100
that you can then flag and get fixed and

564
00:20:15,070 --> 00:20:20,210
now what is this help relative to the

565
00:20:19,100 --> 00:20:22,428
usual testing methodologies for

566
00:20:20,210 --> 00:20:24,109
infrastructure and you can enforce

567
00:20:22,429 --> 00:20:25,850
common good practices in a environment

568
00:20:24,109 --> 00:20:27,289
agnostic manner if you've got a number

569
00:20:25,850 --> 00:20:30,379
of different environments across your

570
00:20:27,289 --> 00:20:31,549
enterprise often the BDD Suites and so

571
00:20:30,379 --> 00:20:32,779
on and so forth have to be customized a

572
00:20:31,549 --> 00:20:34,730
reasonable amount for each environment

573
00:20:32,779 --> 00:20:36,499
you're running it for and this is

574
00:20:34,730 --> 00:20:37,759
environment agnostic it raises the

575
00:20:36,499 --> 00:20:39,830
number of false positives potentially

576
00:20:37,759 --> 00:20:40,909
red learns it's a BDD you don't have as

577
00:20:39,830 --> 00:20:42,949
good an understanding of each

578
00:20:40,909 --> 00:20:43,999
environment and but again it means that

579
00:20:42,950 --> 00:20:45,200
you've got a couple of people that can

580
00:20:43,999 --> 00:20:47,659
write this and it can be spread out

581
00:20:45,200 --> 00:20:49,730
across your entire organization and it

582
00:20:47,659 --> 00:20:51,409
complements it your caching issues at a

583
00:20:49,730 --> 00:20:53,450
different stage in your development

584
00:20:51,409 --> 00:20:55,489
process and as I say it can be run

585
00:20:53,450 --> 00:20:56,989
locally on developers machine and if

586
00:20:55,489 --> 00:20:58,730
that might not be an issue for some

587
00:20:56,989 --> 00:21:00,080
people if you're only spinning up three

588
00:20:58,730 --> 00:21:03,109
or four VMs then doing that within

589
00:21:00,080 --> 00:21:04,699
vagrant is pretty easy and but if you've

590
00:21:03,109 --> 00:21:06,199
got a large infrastructure and you need

591
00:21:04,700 --> 00:21:07,789
to spin up 50 machines in order to get

592
00:21:06,200 --> 00:21:10,879
everything working that might be more of

593
00:21:07,789 --> 00:21:12,499
a concern and and it complements the

594
00:21:10,879 --> 00:21:16,039
automated integration testing as I say

595
00:21:12,499 --> 00:21:17,659
so um to conclude and all this kind of

596
00:21:16,039 --> 00:21:18,950
thing can catch quite a few classes of

597
00:21:17,659 --> 00:21:20,090
bugs cheaply you're never going to

598
00:21:18,950 --> 00:21:21,739
replace penetration testers

599
00:21:20,090 --> 00:21:24,139
unfortunately well good for me I'll

600
00:21:21,739 --> 00:21:25,340
still have a job but you can catch an

601
00:21:24,139 --> 00:21:27,699
awful lot of things quite cheaply

602
00:21:25,340 --> 00:21:29,720
comparatively by using these tools and

603
00:21:27,700 --> 00:21:32,210
you can build it into your continuous

604
00:21:29,720 --> 00:21:34,009
integration systems to get the automated

605
00:21:32,210 --> 00:21:35,119
security that brings for it and actually

606
00:21:34,009 --> 00:21:37,549
you can't you can do this with

607
00:21:35,119 --> 00:21:39,908
infrastructure as well as source code as

608
00:21:37,549 --> 00:21:42,109
is traditionally done so thankfully

609
00:21:39,909 --> 00:21:43,249
we're actually finishing early and so

610
00:21:42,109 --> 00:21:48,350
everyone can go get a beer but in the

611
00:21:43,249 --> 00:21:50,239
meantime do I have any questions I guess

612
00:21:48,350 --> 00:21:53,080
everyone just wants to be Lyn fantastic

613
00:21:50,239 --> 00:21:53,080
thanks guys

614
00:21:53,299 --> 00:21:55,360
you

