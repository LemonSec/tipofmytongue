1
00:00:00,240 --> 00:00:02,879
all right so next up we have the

2
00:00:02,879 --> 00:00:03,919
venerable

3
00:00:03,919 --> 00:00:06,080
then cat super monument he really needs

4
00:00:06,080 --> 00:00:07,839
no introduction because he's just

5
00:00:07,839 --> 00:00:10,480
awesome so take it away then cat hey

6
00:00:10,480 --> 00:00:12,080
matt uh thank you so much i want to

7
00:00:12,080 --> 00:00:13,120
first of all thank

8
00:00:13,120 --> 00:00:14,719
all the organizers so many people

9
00:00:14,719 --> 00:00:16,560
working behind the scenes

10
00:00:16,560 --> 00:00:17,920
and also thank you for everyone who is

11
00:00:17,920 --> 00:00:19,760
attending i want to talk about

12
00:00:19,760 --> 00:00:22,400
one specific class today which is the

13
00:00:22,400 --> 00:00:23,279
collectors

14
00:00:23,279 --> 00:00:25,840
i got really intrigued by collectors

15
00:00:25,840 --> 00:00:27,039
when i came across

16
00:00:27,039 --> 00:00:29,760
it and i have to be honest about it uh

17
00:00:29,760 --> 00:00:30,320
it

18
00:00:30,320 --> 00:00:31,920
is something that i've not still fully

19
00:00:31,920 --> 00:00:33,360
mastered in my opinion because there's

20
00:00:33,360 --> 00:00:34,480
so much to it

21
00:00:34,480 --> 00:00:36,559
and so i decided to just devote a talk

22
00:00:36,559 --> 00:00:38,800
on just collectors itself

23
00:00:38,800 --> 00:00:40,399
before we get into the collectors let's

24
00:00:40,399 --> 00:00:42,399
quickly talk about java and functional

25
00:00:42,399 --> 00:00:43,120
programming

26
00:00:43,120 --> 00:00:44,800
well one of the nice things starting in

27
00:00:44,800 --> 00:00:46,800
java 8 was we could do functional

28
00:00:46,800 --> 00:00:47,680
programming

29
00:00:47,680 --> 00:00:49,920
with java of course with that comes our

30
00:00:49,920 --> 00:00:52,000
good old functions like filter map and

31
00:00:52,000 --> 00:00:52,640
reduce

32
00:00:52,640 --> 00:00:54,399
so let's talk about that a little bit

33
00:00:54,399 --> 00:00:56,480
really quickly here is

34
00:00:56,480 --> 00:00:58,640
let's say a list of values we want to

35
00:00:58,640 --> 00:01:00,399
talk about we'll call it numbers

36
00:01:00,399 --> 00:01:02,480
and in this case we'll say numbers is

37
00:01:02,480 --> 00:01:03,680
equal to

38
00:01:03,680 --> 00:01:05,438
let's create a list of oh what do we

39
00:01:05,438 --> 00:01:07,119
want to say here well let's say let's

40
00:01:07,119 --> 00:01:08,560
start numbers 1 to 10

41
00:01:08,560 --> 00:01:10,960
if you will well we want to apply some

42
00:01:10,960 --> 00:01:13,040
functions like filter map and reduce

43
00:01:13,040 --> 00:01:15,119
so we could easily do that as you would

44
00:01:15,119 --> 00:01:16,960
know you could do some things like

45
00:01:16,960 --> 00:01:18,960
numbers for example and you could get a

46
00:01:18,960 --> 00:01:20,240
stream out of it

47
00:01:20,240 --> 00:01:22,159
you could do a filter on it given an

48
00:01:22,159 --> 00:01:24,320
element you could say give me all the

49
00:01:24,320 --> 00:01:26,240
even numbers in the collection for

50
00:01:26,240 --> 00:01:28,400
example then you could of course do a

51
00:01:28,400 --> 00:01:28,880
map

52
00:01:28,880 --> 00:01:31,280
on it and say give me the double of the

53
00:01:31,280 --> 00:01:32,079
values

54
00:01:32,079 --> 00:01:33,840
but the nice thing is we could also do a

55
00:01:33,840 --> 00:01:35,759
reduce at that particular point

56
00:01:35,759 --> 00:01:37,119
we could say we want to start with the

57
00:01:37,119 --> 00:01:39,920
value zero as a you know identifier in

58
00:01:39,920 --> 00:01:40,799
the beginning

59
00:01:40,799 --> 00:01:42,320
and then of course identity in the

60
00:01:42,320 --> 00:01:43,680
beginning and then you could say for

61
00:01:43,680 --> 00:01:44,560
example

62
00:01:44,560 --> 00:01:47,200
given a total and an element maybe we

63
00:01:47,200 --> 00:01:49,439
want to do a total plus the element to

64
00:01:49,439 --> 00:01:50,240
get the

65
00:01:50,240 --> 00:01:52,320
sum of all the values in that particular

66
00:01:52,320 --> 00:01:54,479
collection so we could use a reduced

67
00:01:54,479 --> 00:01:56,399
operation after a filter and map

68
00:01:56,399 --> 00:01:59,200
operation well so reduces a very common

69
00:01:59,200 --> 00:02:00,399
operation we perform

70
00:02:00,399 --> 00:02:02,479
in functional programming well one of

71
00:02:02,479 --> 00:02:04,880
the things we need to keep in mind is

72
00:02:04,880 --> 00:02:08,239
collect is actually a reduce so reduce

73
00:02:08,239 --> 00:02:10,639
so what does reduce really mean reduce

74
00:02:10,639 --> 00:02:11,360
doesn't mean

75
00:02:11,360 --> 00:02:14,480
a single value as in this example

76
00:02:14,480 --> 00:02:16,400
it could be a single value like 60 in

77
00:02:16,400 --> 00:02:17,520
this case but

78
00:02:17,520 --> 00:02:19,599
generally speaking what i look at it as

79
00:02:19,599 --> 00:02:21,599
is reduces an operation that takes you

80
00:02:21,599 --> 00:02:22,720
from a stream

81
00:02:22,720 --> 00:02:25,280
to a non-stream so from a stream to an

82
00:02:25,280 --> 00:02:26,000
integer

83
00:02:26,000 --> 00:02:28,080
stream to a list stream to a set

84
00:02:28,080 --> 00:02:30,000
whatever it is you're offloading

85
00:02:30,000 --> 00:02:32,160
yourselves getting out of the stream

86
00:02:32,160 --> 00:02:33,920
and that's a reduce or a terminal

87
00:02:33,920 --> 00:02:35,200
operation at that point

88
00:02:35,200 --> 00:02:37,599
to complete it so collect is a reducer

89
00:02:37,599 --> 00:02:38,560
when we think about

90
00:02:38,560 --> 00:02:41,680
reduce sum and max and min

91
00:02:41,680 --> 00:02:43,599
and collect all of them are reduced

92
00:02:43,599 --> 00:02:45,200
something we need to keep in mind

93
00:02:45,200 --> 00:02:47,599
when it comes to reduce of course how do

94
00:02:47,599 --> 00:02:49,680
we really take this collection of data

95
00:02:49,680 --> 00:02:50,000
that

96
00:02:50,000 --> 00:02:52,560
double of the values but let's say we

97
00:02:52,560 --> 00:02:54,239
don't want to total them

98
00:02:54,239 --> 00:02:57,120
but we want just a list of the

99
00:02:57,120 --> 00:02:58,640
collection of this data

100
00:02:58,640 --> 00:03:00,720
well this is where the collect function

101
00:03:00,720 --> 00:03:02,000
really comes in

102
00:03:02,000 --> 00:03:03,760
well what we can do is we could use a

103
00:03:03,760 --> 00:03:05,440
reduce to do that operation

104
00:03:05,440 --> 00:03:07,040
but that reduced would become really

105
00:03:07,040 --> 00:03:09,360
complex and very error prone

106
00:03:09,360 --> 00:03:12,000
if we were to write it well thankfully

107
00:03:12,000 --> 00:03:13,840
that reduce has been written for us

108
00:03:13,840 --> 00:03:14,640
already

109
00:03:14,640 --> 00:03:17,599
and so we can do a collect as a function

110
00:03:17,599 --> 00:03:18,800
in this particular case

111
00:03:18,800 --> 00:03:20,720
so when you call the collect function

112
00:03:20,720 --> 00:03:22,000
what does a collect function

113
00:03:22,000 --> 00:03:24,000
do the collect function can be

114
00:03:24,000 --> 00:03:25,280
instructed to do

115
00:03:25,280 --> 00:03:27,440
certain things for us and this is where

116
00:03:27,440 --> 00:03:29,120
the collectors

117
00:03:29,120 --> 00:03:31,680
really comes in and that's the utility

118
00:03:31,680 --> 00:03:32,959
class we're going to spend

119
00:03:32,959 --> 00:03:35,519
the next about 20 minutes on just

120
00:03:35,519 --> 00:03:37,440
talking about that collectors

121
00:03:37,440 --> 00:03:39,840
collectors is a utility class which

122
00:03:39,840 --> 00:03:41,840
contains a collection of functions but

123
00:03:41,840 --> 00:03:43,440
what's really intriguing about

124
00:03:43,440 --> 00:03:44,159
collectors

125
00:03:44,159 --> 00:03:46,400
is the nature of these functions i will

126
00:03:46,400 --> 00:03:47,280
dive into this

127
00:03:47,280 --> 00:03:49,280
as we go through these examples so what

128
00:03:49,280 --> 00:03:50,959
you can do here is

129
00:03:50,959 --> 00:03:54,400
you could say collectors dot to list

130
00:03:54,400 --> 00:03:56,000
for example and of course i've

131
00:03:56,000 --> 00:03:57,920
statically imported the two list

132
00:03:57,920 --> 00:03:58,560
function

133
00:03:58,560 --> 00:04:00,879
so we don't have to say collectors dot

134
00:04:00,879 --> 00:04:02,879
so the tool list is going to give us a

135
00:04:02,879 --> 00:04:04,480
list of those values

136
00:04:04,480 --> 00:04:06,879
so you can see a list of double of the

137
00:04:06,879 --> 00:04:07,599
values

138
00:04:07,599 --> 00:04:09,439
which are even numbers in this

139
00:04:09,439 --> 00:04:10,640
collection but

140
00:04:10,640 --> 00:04:12,879
unlike the to list function you could

141
00:04:12,879 --> 00:04:14,000
also do a two

142
00:04:14,000 --> 00:04:16,478
set function as well just to see the

143
00:04:16,478 --> 00:04:18,238
difference between the two

144
00:04:18,238 --> 00:04:21,120
let's go back here and put the four one

145
00:04:21,120 --> 00:04:23,040
more time here if you will

146
00:04:23,040 --> 00:04:25,919
notice that eight appears twice in this

147
00:04:25,919 --> 00:04:26,800
output

148
00:04:26,800 --> 00:04:28,880
obviously because 4 times 2 is 8 and we

149
00:04:28,880 --> 00:04:30,000
got 2 occurrences

150
00:04:30,000 --> 00:04:32,400
of that but we could ask it to give us

151
00:04:32,400 --> 00:04:33,440
not a list

152
00:04:33,440 --> 00:04:36,080
but a set itself so in this case as you

153
00:04:36,080 --> 00:04:36,960
can see

154
00:04:36,960 --> 00:04:39,840
it removed the duplicate values of

155
00:04:39,840 --> 00:04:41,120
course said stone

156
00:04:41,120 --> 00:04:43,840
guarantee ordering so the order is also

157
00:04:43,840 --> 00:04:45,040
not the same as

158
00:04:45,040 --> 00:04:47,600
the input was so we can do a two set we

159
00:04:47,600 --> 00:04:48,800
can do a two list

160
00:04:48,800 --> 00:04:50,720
we can even do a two map but we'll talk

161
00:04:50,720 --> 00:04:52,240
about that a little later

162
00:04:52,240 --> 00:04:54,560
but wait a minute though shouldn't we

163
00:04:54,560 --> 00:04:55,280
really be

164
00:04:55,280 --> 00:04:58,560
honoring immutability one of the essence

165
00:04:58,560 --> 00:04:58,880
of

166
00:04:58,880 --> 00:05:01,199
functional programming is to really

167
00:05:01,199 --> 00:05:02,560
honor immutability

168
00:05:02,560 --> 00:05:05,440
now why well the reason is immutability

169
00:05:05,440 --> 00:05:07,039
is very critical

170
00:05:07,039 --> 00:05:09,919
for operations to be correct when it

171
00:05:09,919 --> 00:05:10,560
comes to

172
00:05:10,560 --> 00:05:12,720
functional programming because function

173
00:05:12,720 --> 00:05:14,400
programming heavily uses

174
00:05:14,400 --> 00:05:17,520
lazy evaluation and in other words a

175
00:05:17,520 --> 00:05:19,120
code cannot be evaluated

176
00:05:19,120 --> 00:05:22,400
lazily in the presence of mutability

177
00:05:22,400 --> 00:05:24,080
and that's one of the reasons why

178
00:05:24,080 --> 00:05:26,000
functional programming emphasizes

179
00:05:26,000 --> 00:05:28,720
immutability but unfortunately in this

180
00:05:28,720 --> 00:05:29,759
example

181
00:05:29,759 --> 00:05:32,400
if i were to say integer let's call it

182
00:05:32,400 --> 00:05:33,039
as

183
00:05:33,039 --> 00:05:36,880
a double of let's say even is equal to

184
00:05:36,880 --> 00:05:39,680
and then i'm going to save this all into

185
00:05:39,680 --> 00:05:40,639
that variable

186
00:05:40,639 --> 00:05:43,280
and i'm going to output right in here or

187
00:05:43,280 --> 00:05:45,520
double off even of course i'll say

188
00:05:45,520 --> 00:05:48,000
a two list over here so when i run the

189
00:05:48,000 --> 00:05:48,560
code

190
00:05:48,560 --> 00:05:50,560
it gives us the double of the even

191
00:05:50,560 --> 00:05:52,320
values which is great

192
00:05:52,320 --> 00:05:55,479
and this is what we had in java 8 but

193
00:05:55,479 --> 00:05:57,280
unfortunately though

194
00:05:57,280 --> 00:05:59,520
in the spirit of functional programming

195
00:05:59,520 --> 00:06:00,639
we want to honor

196
00:06:00,639 --> 00:06:03,199
immutability but what if we take the

197
00:06:03,199 --> 00:06:04,560
double of even

198
00:06:04,560 --> 00:06:08,080
and add maybe a value oh let's say

199
00:06:08,080 --> 00:06:11,199
a 99 to it now look at the output it's

200
00:06:11,199 --> 00:06:12,639
got that 99

201
00:06:12,639 --> 00:06:15,199
which doesn't really make any sense well

202
00:06:15,199 --> 00:06:16,400
what can we do

203
00:06:16,400 --> 00:06:18,840
well this is where we could use an

204
00:06:18,840 --> 00:06:20,560
unmodifiable

205
00:06:20,560 --> 00:06:23,120
option that was introduced in i guess

206
00:06:23,120 --> 00:06:25,199
java 9 if i'm not mistaken

207
00:06:25,199 --> 00:06:28,479
uh and so this jdk has been enhanced to

208
00:06:28,479 --> 00:06:30,880
provide these kinds of functions so what

209
00:06:30,880 --> 00:06:31,680
we can do

210
00:06:31,680 --> 00:06:35,759
here is we can change it to unmodifiable

211
00:06:35,759 --> 00:06:37,520
and then list of course let's just

212
00:06:37,520 --> 00:06:39,440
comment this out for a moment

213
00:06:39,440 --> 00:06:41,840
and just run the code and still work the

214
00:06:41,840 --> 00:06:43,440
way it's supposed to work

215
00:06:43,440 --> 00:06:46,560
however if you try to mess with that

216
00:06:46,560 --> 00:06:49,120
list that was created you will get a

217
00:06:49,120 --> 00:06:50,240
stern runtime

218
00:06:50,240 --> 00:06:52,400
error because it's an immutable

219
00:06:52,400 --> 00:06:53,440
collection

220
00:06:53,440 --> 00:06:56,560
and you cannot mutate it you cannot

221
00:06:56,560 --> 00:06:58,800
change it once you create it so moving

222
00:06:58,800 --> 00:07:00,400
forward i would encourage you

223
00:07:00,400 --> 00:07:02,560
even though the name is not long then to

224
00:07:02,560 --> 00:07:04,199
list to use the two

225
00:07:04,199 --> 00:07:07,440
unmodifiable list to unmodifiable set

226
00:07:07,440 --> 00:07:10,160
to unmodifiable map instead of two lists

227
00:07:10,160 --> 00:07:12,479
two set and two map respectively

228
00:07:12,479 --> 00:07:14,960
those are better options but what if i

229
00:07:14,960 --> 00:07:16,080
really want to take

230
00:07:16,080 --> 00:07:18,479
this collection and put that into two

231
00:07:18,479 --> 00:07:19,840
different groups

232
00:07:19,840 --> 00:07:22,960
so for example let's say we want to take

233
00:07:22,960 --> 00:07:23,680
all the

234
00:07:23,680 --> 00:07:26,319
even numbers on one side all the odd

235
00:07:26,319 --> 00:07:27,840
numbers on the other side

236
00:07:27,840 --> 00:07:30,000
which is a common operation we tend to

237
00:07:30,000 --> 00:07:30,960
perform

238
00:07:30,960 --> 00:07:32,560
when it comes to working with a

239
00:07:32,560 --> 00:07:34,080
collection of data

240
00:07:34,080 --> 00:07:36,880
so what we could do here is we could say

241
00:07:36,880 --> 00:07:38,160
output

242
00:07:38,160 --> 00:07:40,880
we could take the stream in here but we

243
00:07:40,880 --> 00:07:42,800
could simply apply a collect

244
00:07:42,800 --> 00:07:46,160
on it and and again keep in mind collect

245
00:07:46,160 --> 00:07:47,199
is taking

246
00:07:47,199 --> 00:07:50,560
really a collect door so the collector

247
00:07:50,560 --> 00:07:54,240
is really a very fancy interface

248
00:07:54,240 --> 00:07:56,240
which gives us capabilities to perform

249
00:07:56,240 --> 00:07:57,440
some collection

250
00:07:57,440 --> 00:08:00,400
or reduce rather collecting as not a

251
00:08:00,400 --> 00:08:01,599
collection of data

252
00:08:01,599 --> 00:08:03,440
but picking up the data and putting that

253
00:08:03,440 --> 00:08:04,960
into a certain form

254
00:08:04,960 --> 00:08:07,039
reduce operation so these are really

255
00:08:07,039 --> 00:08:08,800
reducers that's what they are the

256
00:08:08,800 --> 00:08:10,080
collectors are

257
00:08:10,080 --> 00:08:12,319
so the collector that we want to use in

258
00:08:12,319 --> 00:08:13,520
this particular case

259
00:08:13,520 --> 00:08:15,360
earlier we used a tool list if you

260
00:08:15,360 --> 00:08:16,639
remember or a two

261
00:08:16,639 --> 00:08:19,199
unmodifiable list but what we could do

262
00:08:19,199 --> 00:08:20,599
instead is we could say

263
00:08:20,599 --> 00:08:24,160
partitioning so a partitioning

264
00:08:24,160 --> 00:08:28,160
by and we could provide to it a lambda

265
00:08:28,160 --> 00:08:30,879
where we could say mark 2 is equal to

266
00:08:30,879 --> 00:08:31,680
zero

267
00:08:31,680 --> 00:08:34,080
meaning we are simply telling it that we

268
00:08:34,080 --> 00:08:35,440
want to partition

269
00:08:35,440 --> 00:08:38,000
based on the even numbers so you can see

270
00:08:38,000 --> 00:08:40,240
all the odd numbers on one side

271
00:08:40,240 --> 00:08:42,958
all the even numbers on the other side

272
00:08:42,958 --> 00:08:45,120
and that's a nice way to partition and

273
00:08:45,120 --> 00:08:46,160
it doesn't have to be

274
00:08:46,160 --> 00:08:48,399
based on even an odd it could be

275
00:08:48,399 --> 00:08:49,200
anything you

276
00:08:49,200 --> 00:08:51,360
want it to be so for example in this

277
00:08:51,360 --> 00:08:53,440
case p is greater than

278
00:08:53,440 --> 00:08:56,000
let's say five and you can see all the

279
00:08:56,000 --> 00:08:57,200
numbers that are

280
00:08:57,200 --> 00:08:59,440
five or less is on one side numbers

281
00:08:59,440 --> 00:09:01,120
greater than five on the other side

282
00:09:01,120 --> 00:09:03,279
so you can provide a predicate whatever

283
00:09:03,279 --> 00:09:04,560
the predicate is

284
00:09:04,560 --> 00:09:06,160
and when based on that you can split

285
00:09:06,160 --> 00:09:07,680
them into two different pieces

286
00:09:07,680 --> 00:09:09,440
and and whatever that you want to split

287
00:09:09,440 --> 00:09:12,000
based on you can do a partitioning just

288
00:09:12,000 --> 00:09:13,279
split that into two

289
00:09:13,279 --> 00:09:15,120
and doesn't have to be equal halves

290
00:09:15,120 --> 00:09:17,040
sometimes it could be something which

291
00:09:17,040 --> 00:09:19,760
doesn't have a value for example greater

292
00:09:19,760 --> 00:09:21,519
than 50 if i said

293
00:09:21,519 --> 00:09:23,440
well obviously no value is greater than

294
00:09:23,440 --> 00:09:26,160
50 everything piles upon one side

295
00:09:26,160 --> 00:09:28,720
so that's basically partitioning well

296
00:09:28,720 --> 00:09:29,600
that's also

297
00:09:29,600 --> 00:09:32,240
good so far but the collectors is

298
00:09:32,240 --> 00:09:33,200
something that's

299
00:09:33,200 --> 00:09:36,080
absolutely powerful like i said it's a

300
00:09:36,080 --> 00:09:36,800
particular

301
00:09:36,800 --> 00:09:39,680
utility class you can spend quite a

302
00:09:39,680 --> 00:09:40,880
amount of time with

303
00:09:40,880 --> 00:09:43,519
it and there's so much to learn and when

304
00:09:43,519 --> 00:09:45,040
you're done with it you'll find

305
00:09:45,040 --> 00:09:47,200
there is so much more to learn in fact i

306
00:09:47,200 --> 00:09:48,160
would say

307
00:09:48,160 --> 00:09:51,519
collectors is really a wonderful class

308
00:09:51,519 --> 00:09:54,080
to spend your saturday night with if you

309
00:09:54,080 --> 00:09:55,120
really are bored

310
00:09:55,120 --> 00:09:56,880
don't know what to really do you're

311
00:09:56,880 --> 00:09:58,800
sitting there and scratching your head

312
00:09:58,800 --> 00:10:01,279
well just go ahead and invite collectors

313
00:10:01,279 --> 00:10:02,959
you'll have a wonderful time

314
00:10:02,959 --> 00:10:04,880
with that utility class so that's

315
00:10:04,880 --> 00:10:06,240
basically what collectors

316
00:10:06,240 --> 00:10:08,160
are but let's look at one other

317
00:10:08,160 --> 00:10:09,440
capability of it

318
00:10:09,440 --> 00:10:12,079
but for this let's switch over to a

319
00:10:12,079 --> 00:10:13,760
slightly different example

320
00:10:13,760 --> 00:10:16,320
in this case so let's bring in a

321
00:10:16,320 --> 00:10:18,000
collection of let's say

322
00:10:18,000 --> 00:10:21,040
a people object just for our purpose in

323
00:10:21,040 --> 00:10:21,440
here

324
00:10:21,440 --> 00:10:23,839
let's bring in a collection of people so

325
00:10:23,839 --> 00:10:24,880
this is going to be

326
00:10:24,880 --> 00:10:27,600
a bunch of person object we got people

327
00:10:27,600 --> 00:10:28,880
with the same name

328
00:10:28,880 --> 00:10:31,120
we have people with the same age as well

329
00:10:31,120 --> 00:10:33,519
that's basically the collection of data

330
00:10:33,519 --> 00:10:35,360
that we are dealing with so i want to

331
00:10:35,360 --> 00:10:37,279
work with this collection so let's go

332
00:10:37,279 --> 00:10:38,240
ahead and say

333
00:10:38,240 --> 00:10:41,279
a people is equal to create people

334
00:10:41,279 --> 00:10:43,040
we'll just save that into this people

335
00:10:43,040 --> 00:10:45,040
variable to start with

336
00:10:45,040 --> 00:10:48,240
now what i want to do here is we will

337
00:10:48,240 --> 00:10:49,040
say

338
00:10:49,040 --> 00:10:52,320
given these people we'll say print their

339
00:10:52,320 --> 00:10:55,920
names let's say in uppercase

340
00:10:55,920 --> 00:10:59,200
let's say comma separated now how would

341
00:10:59,200 --> 00:11:00,000
we do this

342
00:11:00,000 --> 00:11:01,680
well you may say gosh we've done

343
00:11:01,680 --> 00:11:03,279
programming and imperative stuff for a

344
00:11:03,279 --> 00:11:04,000
long time

345
00:11:04,000 --> 00:11:06,160
this should be really easy to do isn't

346
00:11:06,160 --> 00:11:07,279
it so we could say

347
00:11:07,279 --> 00:11:10,000
person person and we could say this

348
00:11:10,000 --> 00:11:12,320
comes from the people collection

349
00:11:12,320 --> 00:11:14,880
and we could simply say output person

350
00:11:14,880 --> 00:11:15,760
dot get

351
00:11:15,760 --> 00:11:17,760
name after all it shouldn't take a

352
00:11:17,760 --> 00:11:19,440
really hard time to get the names

353
00:11:19,440 --> 00:11:21,680
oh but the problem says an upper case so

354
00:11:21,680 --> 00:11:24,160
we could say two uppercase right here

355
00:11:24,160 --> 00:11:26,560
hey that's not a problem after all we

356
00:11:26,560 --> 00:11:28,560
can just get the names in uppercase

357
00:11:28,560 --> 00:11:30,880
that was very easy but it does say we

358
00:11:30,880 --> 00:11:33,360
should really printed commas separated

359
00:11:33,360 --> 00:11:36,399
so we could simply say plus a comma to

360
00:11:36,399 --> 00:11:37,839
separate them by comma

361
00:11:37,839 --> 00:11:40,240
and of course the intention was for all

362
00:11:40,240 --> 00:11:42,079
of them to be on the same exact

363
00:11:42,079 --> 00:11:44,560
line so when you run this code of course

364
00:11:44,560 --> 00:11:46,079
tada you got the output

365
00:11:46,079 --> 00:11:48,079
you're all in the same height but wait a

366
00:11:48,079 --> 00:11:51,040
minute notice that it's a stupid comma

367
00:11:51,040 --> 00:11:53,279
in the very end have you ever seen that

368
00:11:53,279 --> 00:11:54,399
problem before

369
00:11:54,399 --> 00:11:56,720
of course we have isn't it and how did

370
00:11:56,720 --> 00:11:57,920
you feel

371
00:11:57,920 --> 00:12:00,320
the first day you ran into it you were

372
00:12:00,320 --> 00:12:02,720
in denial this was happening isn't it

373
00:12:02,720 --> 00:12:05,040
because it turns out it's not so trivial

374
00:12:05,040 --> 00:12:06,800
to remove the karma

375
00:12:06,800 --> 00:12:09,200
you may say gosh that's not really hard

376
00:12:09,200 --> 00:12:10,399
somebody may tell you

377
00:12:10,399 --> 00:12:12,399
put it into a string and remove it all

378
00:12:12,399 --> 00:12:14,399
dawn its strings are immutable

379
00:12:14,399 --> 00:12:16,399
well maybe you can use a string builder

380
00:12:16,399 --> 00:12:18,160
you think and your colleague is like is

381
00:12:18,160 --> 00:12:19,600
a swing builder a string buffer

382
00:12:19,600 --> 00:12:21,600
now we have 30 minute discussion on it

383
00:12:21,600 --> 00:12:23,040
and then somebody tells you oh it's

384
00:12:23,040 --> 00:12:24,079
really simple

385
00:12:24,079 --> 00:12:27,040
all you have to do is simply do a for

386
00:12:27,040 --> 00:12:27,440
inf

387
00:12:27,440 --> 00:12:30,240
i equal to zero and of course you know

388
00:12:30,240 --> 00:12:32,000
this is never going to get us home on

389
00:12:32,000 --> 00:12:32,560
time

390
00:12:32,560 --> 00:12:35,519
because it only becomes a much bigger

391
00:12:35,519 --> 00:12:36,160
mess

392
00:12:36,160 --> 00:12:38,399
well simple problems have to be simple

393
00:12:38,399 --> 00:12:39,200
to solve

394
00:12:39,200 --> 00:12:40,959
and complex problems should be really

395
00:12:40,959 --> 00:12:42,399
affordable to solve

396
00:12:42,399 --> 00:12:44,560
well this is a really a simple problem

397
00:12:44,560 --> 00:12:46,560
we shouldn't sweat so much on it

398
00:12:46,560 --> 00:12:50,399
so output again we can say people dot

399
00:12:50,399 --> 00:12:53,839
stream and we can simply say over here

400
00:12:53,839 --> 00:12:57,519
map and given a person get me the name

401
00:12:57,519 --> 00:12:59,040
of the person great

402
00:12:59,040 --> 00:13:01,120
now i want to perform a map given a

403
00:13:01,120 --> 00:13:02,079
string

404
00:13:02,079 --> 00:13:04,880
i want to convert it to a two uppercase

405
00:13:04,880 --> 00:13:05,440
nice

406
00:13:05,440 --> 00:13:08,480
up functional transformation as you can

407
00:13:08,480 --> 00:13:09,200
see

408
00:13:09,200 --> 00:13:12,320
then we perform a collect and comes our

409
00:13:12,320 --> 00:13:14,000
friendly collector

410
00:13:14,000 --> 00:13:17,040
one more time and then we say joining

411
00:13:17,040 --> 00:13:19,760
and then we can simply ask you to join

412
00:13:19,760 --> 00:13:20,160
with

413
00:13:20,160 --> 00:13:22,720
a comma as you can see when you run the

414
00:13:22,720 --> 00:13:23,440
code

415
00:13:23,440 --> 00:13:26,000
we got the output we desire with no

416
00:13:26,000 --> 00:13:27,040
stupid comma

417
00:13:27,040 --> 00:13:29,040
in the end this is what coding should be

418
00:13:29,040 --> 00:13:31,440
really isn't it and again this joining

419
00:13:31,440 --> 00:13:32,959
is a unity function

420
00:13:32,959 --> 00:13:35,839
that returns a collector which knows to

421
00:13:35,839 --> 00:13:36,720
collect this

422
00:13:36,720 --> 00:13:39,680
data the output into a string comma

423
00:13:39,680 --> 00:13:40,800
separated very

424
00:13:40,800 --> 00:13:42,800
nicely all right those were really

425
00:13:42,800 --> 00:13:43,839
simple things

426
00:13:43,839 --> 00:13:46,480
let's up this by a notch what about

427
00:13:46,480 --> 00:13:47,519
grouping

428
00:13:47,519 --> 00:13:50,480
now going back to this example you will

429
00:13:50,480 --> 00:13:52,959
notice that the collection has people

430
00:13:52,959 --> 00:13:55,440
with different names on it we got sarah

431
00:13:55,440 --> 00:13:56,480
bob paula

432
00:13:56,480 --> 00:13:58,800
and so on maybe what i want to do is to

433
00:13:58,800 --> 00:14:00,480
group them all together

434
00:14:00,480 --> 00:14:03,120
i want to group all my sarahs into one

435
00:14:03,120 --> 00:14:03,600
group

436
00:14:03,600 --> 00:14:06,639
all my pauls into one group all my bob's

437
00:14:06,639 --> 00:14:07,600
into another group

438
00:14:07,600 --> 00:14:09,519
all my jack into another group started

439
00:14:09,519 --> 00:14:11,360
to use the word i want to put them into

440
00:14:11,360 --> 00:14:11,839
different

441
00:14:11,839 --> 00:14:13,760
buckets what that's exactly what you

442
00:14:13,760 --> 00:14:16,160
want to do you want to take every

443
00:14:16,160 --> 00:14:18,639
person and put them into a bucket based

444
00:14:18,639 --> 00:14:19,760
on the name

445
00:14:19,760 --> 00:14:21,839
so how do you really do this if you want

446
00:14:21,839 --> 00:14:24,079
to do this in the imperative style

447
00:14:24,079 --> 00:14:26,399
it'll be really really hard let's just

448
00:14:26,399 --> 00:14:27,920
go through a mental exercise

449
00:14:27,920 --> 00:14:31,199
hey take sarah do we have sarah as a key

450
00:14:31,199 --> 00:14:33,839
well we don't let's create a key sarah

451
00:14:33,839 --> 00:14:35,120
let's create a list

452
00:14:35,120 --> 00:14:38,240
for that add person sera to the list

453
00:14:38,240 --> 00:14:40,160
next one oh it turns out to be sarah do

454
00:14:40,160 --> 00:14:41,680
we have sarah in the key

455
00:14:41,680 --> 00:14:44,959
oh yes we do get the list and append

456
00:14:44,959 --> 00:14:47,440
this person to that list how would you

457
00:14:47,440 --> 00:14:48,240
do that

458
00:14:48,240 --> 00:14:50,560
well that looks like a lot of effort

459
00:14:50,560 --> 00:14:51,279
isn't it

460
00:14:51,279 --> 00:14:53,519
how do you write code with a lot of

461
00:14:53,519 --> 00:14:55,279
effort well that's why you hire the

462
00:14:55,279 --> 00:14:56,560
interns isn't it

463
00:14:56,560 --> 00:14:58,720
no just kidding poor interns you want to

464
00:14:58,720 --> 00:15:00,720
give them fun things to do not really

465
00:15:00,720 --> 00:15:03,199
these kinds of boring jobs well what if

466
00:15:03,199 --> 00:15:05,440
we can use a very fancy

467
00:15:05,440 --> 00:15:08,639
powerful api to do exactly that so let's

468
00:15:08,639 --> 00:15:09,600
give it a try

469
00:15:09,600 --> 00:15:11,760
so what we can do here is create a map

470
00:15:11,760 --> 00:15:13,120
of a string

471
00:15:13,120 --> 00:15:15,920
but the result is a list of person

472
00:15:15,920 --> 00:15:17,440
that's what i want to really do

473
00:15:17,440 --> 00:15:21,240
by name is equal to and we can say

474
00:15:21,240 --> 00:15:23,600
people.stream and

475
00:15:23,600 --> 00:15:26,800
now we can simply say dot collect

476
00:15:26,800 --> 00:15:29,040
and once again when we are done with

477
00:15:29,040 --> 00:15:30,560
that we will simply

478
00:15:30,560 --> 00:15:33,600
output the by name as an output right

479
00:15:33,600 --> 00:15:34,000
there

480
00:15:34,000 --> 00:15:35,279
so what are we going to do in the

481
00:15:35,279 --> 00:15:38,160
collect we're going to say grouping

482
00:15:38,160 --> 00:15:41,279
by and given a person

483
00:15:41,279 --> 00:15:44,800
i want to group it based on the name of

484
00:15:44,800 --> 00:15:45,600
the person

485
00:15:45,600 --> 00:15:47,600
so that's basically what i want to do i

486
00:15:47,600 --> 00:15:49,279
want to group based on the name of the

487
00:15:49,279 --> 00:15:50,079
person

488
00:15:50,079 --> 00:15:52,399
and that's basically our intention here

489
00:15:52,399 --> 00:15:55,040
to group it when you look at the output

490
00:15:55,040 --> 00:15:56,079
at this point

491
00:15:56,079 --> 00:15:59,199
notice bob is in bob's bucket the two

492
00:15:59,199 --> 00:16:01,600
seras are and the sarah bucket

493
00:16:01,600 --> 00:16:04,160
jill isn't the jill bucket and the jack

494
00:16:04,160 --> 00:16:05,759
and you can't see the rest of the output

495
00:16:05,759 --> 00:16:06,399
on the

496
00:16:06,399 --> 00:16:09,279
screen here are in the jack bucket well

497
00:16:09,279 --> 00:16:11,519
that was not really hard

498
00:16:11,519 --> 00:16:13,600
at all isn't it and of course you can

499
00:16:13,600 --> 00:16:15,680
shorten this a little bit further

500
00:16:15,680 --> 00:16:18,639
by using a method reference as well very

501
00:16:18,639 --> 00:16:19,360
easily

502
00:16:19,360 --> 00:16:21,680
as you can see and you can very much

503
00:16:21,680 --> 00:16:23,040
write that grouping

504
00:16:23,040 --> 00:16:24,880
well that's great so far but you know

505
00:16:24,880 --> 00:16:27,120
what it's obvious that bob is in bob's

506
00:16:27,120 --> 00:16:28,959
bucket series and sarah's bucket

507
00:16:28,959 --> 00:16:32,399
maybe i don't care about the full person

508
00:16:32,399 --> 00:16:34,959
object what i really want to care is

509
00:16:34,959 --> 00:16:36,000
maybe i want to store

510
00:16:36,000 --> 00:16:39,440
their age value well somebody correct me

511
00:16:39,440 --> 00:16:40,639
the other day and said

512
00:16:40,639 --> 00:16:42,480
if i want to store the age it better be

513
00:16:42,480 --> 00:16:44,560
a long well i kind of appreciate that

514
00:16:44,560 --> 00:16:45,279
sentiment

515
00:16:45,279 --> 00:16:46,800
but in this case i've kept it as an

516
00:16:46,800 --> 00:16:48,800
integer so in this case of course

517
00:16:48,800 --> 00:16:51,839
it's a integer so what do i want to do

518
00:16:51,839 --> 00:16:54,480
well i want to take the bob or a sarah

519
00:16:54,480 --> 00:16:56,320
or a paul or a paula

520
00:16:56,320 --> 00:16:58,000
i want to put them into a bucket but not

521
00:16:58,000 --> 00:16:59,519
the person itself

522
00:16:59,519 --> 00:17:01,759
but i want to take the age and put that

523
00:17:01,759 --> 00:17:02,560
into the bucket

524
00:17:02,560 --> 00:17:05,119
hey what is that that's a transformation

525
00:17:05,119 --> 00:17:07,439
what is another word for transformation

526
00:17:07,439 --> 00:17:10,559
mapping well that's exactly what it is

527
00:17:10,559 --> 00:17:14,480
so we we're going to say comma mapping

528
00:17:14,480 --> 00:17:18,240
and based on a person's get age

529
00:17:18,240 --> 00:17:20,559
and of course we want the result to be a

530
00:17:20,559 --> 00:17:23,359
list and so we are asking it to

531
00:17:23,359 --> 00:17:25,599
give the result into a list as you can

532
00:17:25,599 --> 00:17:26,880
see in here

533
00:17:26,880 --> 00:17:28,799
so when we run the code this time oops

534
00:17:28,799 --> 00:17:29,919
what did i do here

535
00:17:29,919 --> 00:17:32,160
a little bit one too many parenthesis i

536
00:17:32,160 --> 00:17:33,200
suppose so

537
00:17:33,200 --> 00:17:35,120
in this case of course when we finish

538
00:17:35,120 --> 00:17:37,280
this we can see our one less

539
00:17:37,280 --> 00:17:39,679
so we can run that code and we can see

540
00:17:39,679 --> 00:17:41,039
bob 20

541
00:17:41,039 --> 00:17:44,880
but sarah is 20 and 22 and jill is 11.

542
00:17:44,880 --> 00:17:47,919
jack is 3 and 72 and so on so we

543
00:17:47,919 --> 00:17:49,600
performed the grouping

544
00:17:49,600 --> 00:17:51,440
but we performed the mapping i want to

545
00:17:51,440 --> 00:17:52,720
pause right here

546
00:17:52,720 --> 00:17:55,039
and i want to observe something which is

547
00:17:55,039 --> 00:17:56,320
easy to miss but

548
00:17:56,320 --> 00:17:59,280
quite nice if we really get a hang of it

549
00:17:59,280 --> 00:18:00,000
i want you to

550
00:18:00,000 --> 00:18:03,360
notice this very closely for a minute

551
00:18:03,360 --> 00:18:06,240
this is what we had a few minutes ago in

552
00:18:06,240 --> 00:18:07,200
the beginning

553
00:18:07,200 --> 00:18:10,000
so what we had a few minutes ago was

554
00:18:10,000 --> 00:18:10,799
that

555
00:18:10,799 --> 00:18:13,440
now notice that grouping what is

556
00:18:13,440 --> 00:18:14,000
grouping

557
00:18:14,000 --> 00:18:16,640
returning to us grouping is returning a

558
00:18:16,640 --> 00:18:17,760
collector

559
00:18:17,760 --> 00:18:20,480
well that's great but notice this

560
00:18:20,480 --> 00:18:21,440
grouping

561
00:18:21,440 --> 00:18:25,360
which is returning a collector itself

562
00:18:25,360 --> 00:18:29,280
takes yet another collector

563
00:18:29,280 --> 00:18:32,880
as its second argument so this is

564
00:18:32,880 --> 00:18:35,840
this blew my mind because you can create

565
00:18:35,840 --> 00:18:37,440
a collector

566
00:18:37,440 --> 00:18:40,080
using a collector now obvious question

567
00:18:40,080 --> 00:18:40,480
there

568
00:18:40,480 --> 00:18:43,200
is is it possible for that collector to

569
00:18:43,200 --> 00:18:44,000
use

570
00:18:44,000 --> 00:18:46,640
another collector and the answer is yes

571
00:18:46,640 --> 00:18:48,240
because we already see that

572
00:18:48,240 --> 00:18:49,840
because you know that two list is a

573
00:18:49,840 --> 00:18:51,840
collector too because we use that

574
00:18:51,840 --> 00:18:54,880
as a argument to collect earlier on

575
00:18:54,880 --> 00:18:58,080
so you can take the collector

576
00:18:58,080 --> 00:19:01,520
and build a bigger collector in turn

577
00:19:01,520 --> 00:19:03,679
build a bigger collector you get the

578
00:19:03,679 --> 00:19:06,240
hang of the recursive structure here

579
00:19:06,240 --> 00:19:08,160
a collector can form a collector can

580
00:19:08,160 --> 00:19:09,600
form a collector

581
00:19:09,600 --> 00:19:12,480
well the only end to it is keeping

582
00:19:12,480 --> 00:19:14,559
ourselves sane at some point and say

583
00:19:14,559 --> 00:19:16,000
we're done we don't want to get any

584
00:19:16,000 --> 00:19:18,400
further with this so that's basically an

585
00:19:18,400 --> 00:19:19,600
example of how

586
00:19:19,600 --> 00:19:22,160
we are able to use the mapping now

587
00:19:22,160 --> 00:19:22,720
clearly

588
00:19:22,720 --> 00:19:25,520
in this case we can do a lot more than

589
00:19:25,520 --> 00:19:26,320
simply

590
00:19:26,320 --> 00:19:29,120
performing grouping and mapping well

591
00:19:29,120 --> 00:19:31,120
let's take an exercise for a minute

592
00:19:31,120 --> 00:19:34,000
what if i really want to find out how

593
00:19:34,000 --> 00:19:36,000
many of my friends

594
00:19:36,000 --> 00:19:39,760
have the same name now if you're really

595
00:19:39,760 --> 00:19:42,640
bored on a friday night you could go

596
00:19:42,640 --> 00:19:43,200
through this

597
00:19:43,200 --> 00:19:46,160
exercise you could think about all your

598
00:19:46,160 --> 00:19:46,640
friends

599
00:19:46,640 --> 00:19:49,200
i'm sure you have a lot of them and and

600
00:19:49,200 --> 00:19:50,160
find out

601
00:19:50,160 --> 00:19:52,320
what their names are and how many of

602
00:19:52,320 --> 00:19:53,679
your friends have

603
00:19:53,679 --> 00:19:55,760
the same name well you know this kind of

604
00:19:55,760 --> 00:19:56,720
blew my mind

605
00:19:56,720 --> 00:19:58,960
because i one day sat back and thought

606
00:19:58,960 --> 00:20:00,400
about it and then i

607
00:20:00,400 --> 00:20:03,200
quickly realized that i have you know a

608
00:20:03,200 --> 00:20:05,039
lot of friends thankfully i'm very

609
00:20:05,039 --> 00:20:08,159
happy for that but it turned out a lot

610
00:20:08,159 --> 00:20:10,720
of my friends have the first name

611
00:20:10,720 --> 00:20:14,320
as brian i don't know why and and

612
00:20:14,320 --> 00:20:16,880
you know every other friend seems to be

613
00:20:16,880 --> 00:20:18,240
having a name brian

614
00:20:18,240 --> 00:20:19,840
if somebody comes to me and tells me

615
00:20:19,840 --> 00:20:21,760
these days hey venket can i be your

616
00:20:21,760 --> 00:20:22,159
friend

617
00:20:22,159 --> 00:20:24,000
the first question i ask them is is the

618
00:20:24,000 --> 00:20:25,840
name brian and if they say yes i say i'm

619
00:20:25,840 --> 00:20:26,960
sorry it's taken

620
00:20:26,960 --> 00:20:30,559
well you can just find out account of

621
00:20:30,559 --> 00:20:32,400
how many of your friends have uh you

622
00:20:32,400 --> 00:20:33,600
know the same name

623
00:20:33,600 --> 00:20:35,600
well wouldn't it be nice to group them

624
00:20:35,600 --> 00:20:37,840
into that so here's an idea

625
00:20:37,840 --> 00:20:40,720
let's take this and say we want to

626
00:20:40,720 --> 00:20:42,240
create a map

627
00:20:42,240 --> 00:20:45,360
of a string but the result is a

628
00:20:45,360 --> 00:20:48,480
integer so a name value a

629
00:20:48,480 --> 00:20:51,760
dictionary a map but the name is the key

630
00:20:51,760 --> 00:20:54,480
but the value is going to be the count

631
00:20:54,480 --> 00:20:56,320
of the number of people

632
00:20:56,320 --> 00:20:58,559
with that first name so we're going to

633
00:20:58,559 --> 00:21:00,240
say account

634
00:21:00,240 --> 00:21:03,440
let's say by name is equal to

635
00:21:03,440 --> 00:21:05,039
and when we are done with that we want

636
00:21:05,039 --> 00:21:07,200
to output the count by name

637
00:21:07,200 --> 00:21:10,080
so how do we really count based on on

638
00:21:10,080 --> 00:21:10,799
the name

639
00:21:10,799 --> 00:21:13,360
so what we can do here is again keep in

640
00:21:13,360 --> 00:21:14,640
mind that bucket

641
00:21:14,640 --> 00:21:17,559
we talked about so we are going to say

642
00:21:17,559 --> 00:21:19,039
people.stream

643
00:21:19,039 --> 00:21:21,280
and and let's bring in the bucket so

644
00:21:21,280 --> 00:21:22,320
collect

645
00:21:22,320 --> 00:21:25,840
and we can then say a grouping

646
00:21:25,840 --> 00:21:29,440
by and this is going to be a person's

647
00:21:29,440 --> 00:21:32,480
a get named so we got the person's name

648
00:21:32,480 --> 00:21:34,799
so we are taking every person and saying

649
00:21:34,799 --> 00:21:37,039
oh brian go into that bucket oh paul go

650
00:21:37,039 --> 00:21:38,559
into this bucket oh sarah

651
00:21:38,559 --> 00:21:40,400
go into this bucket but rather than

652
00:21:40,400 --> 00:21:42,720
putting the person into the bucket

653
00:21:42,720 --> 00:21:45,919
we earlier saw to put the age into the

654
00:21:45,919 --> 00:21:48,559
bucket by doing a mapping function

655
00:21:48,559 --> 00:21:51,280
but we don't want to put the age also

656
00:21:51,280 --> 00:21:51,760
here

657
00:21:51,760 --> 00:21:54,559
but what we want to do means we want to

658
00:21:54,559 --> 00:21:56,880
count the number of person

659
00:21:56,880 --> 00:21:59,360
and then put that result into the bucket

660
00:21:59,360 --> 00:22:00,559
so in other words

661
00:22:00,559 --> 00:22:02,159
we don't want to put the object into the

662
00:22:02,159 --> 00:22:04,080
bucket we don't we don't want to put the

663
00:22:04,080 --> 00:22:06,880
age into the bucket we want to put the

664
00:22:06,880 --> 00:22:07,600
count

665
00:22:07,600 --> 00:22:10,880
of the number of objects into the bucket

666
00:22:10,880 --> 00:22:14,000
so this becomes a count thing

667
00:22:14,000 --> 00:22:16,559
but it turns out counting actually gives

668
00:22:16,559 --> 00:22:17,120
you

669
00:22:17,120 --> 00:22:19,919
a long value so that's basically what we

670
00:22:19,919 --> 00:22:20,799
are doing here

671
00:22:20,799 --> 00:22:23,919
is asking for a counting so when we do

672
00:22:23,919 --> 00:22:26,159
accounting it's going to tell us that

673
00:22:26,159 --> 00:22:26,799
how many

674
00:22:26,799 --> 00:22:29,440
elements exist off that so when i run

675
00:22:29,440 --> 00:22:30,799
the code this time

676
00:22:30,799 --> 00:22:33,280
there's only one bob here but there are

677
00:22:33,280 --> 00:22:35,200
two seras as you can see

678
00:22:35,200 --> 00:22:37,919
there's one jill but two jacks one paula

679
00:22:37,919 --> 00:22:38,799
but two paul

680
00:22:38,799 --> 00:22:41,440
as well you get the point but wait a

681
00:22:41,440 --> 00:22:42,559
second though

682
00:22:42,559 --> 00:22:44,720
this is a long well i was working with

683
00:22:44,720 --> 00:22:46,320
an application where

684
00:22:46,320 --> 00:22:49,520
my function that i had in my api was

685
00:22:49,520 --> 00:22:50,559
expecting an

686
00:22:50,559 --> 00:22:53,520
integer value well this one was giving a

687
00:22:53,520 --> 00:22:54,320
long

688
00:22:54,320 --> 00:22:56,960
and i was like gosh why do i go from

689
00:22:56,960 --> 00:22:57,919
along to an

690
00:22:57,919 --> 00:23:00,000
integer and then of course when you take

691
00:23:00,000 --> 00:23:02,559
the value you can call another function

692
00:23:02,559 --> 00:23:05,360
perform a casting and send it but that's

693
00:23:05,360 --> 00:23:07,600
very smelly even saying it really

694
00:23:07,600 --> 00:23:09,919
begins to smell bad isn't it so what i

695
00:23:09,919 --> 00:23:10,960
really want is

696
00:23:10,960 --> 00:23:13,600
integer but i want to make it really

697
00:23:13,600 --> 00:23:15,840
elegant to do it how can i do it

698
00:23:15,840 --> 00:23:18,159
well remember this principle of the

699
00:23:18,159 --> 00:23:20,159
collectors being recursive about

700
00:23:20,159 --> 00:23:21,679
collectors having collectors having

701
00:23:21,679 --> 00:23:22,880
collectors

702
00:23:22,880 --> 00:23:25,120
that's exactly what we're going to do so

703
00:23:25,120 --> 00:23:26,559
there's a collecting

704
00:23:26,559 --> 00:23:29,760
and then that we can use so what we can

705
00:23:29,760 --> 00:23:31,039
do here is

706
00:23:31,039 --> 00:23:33,760
we can say collecting and then and we

707
00:23:33,760 --> 00:23:36,400
can take the counting at this point

708
00:23:36,400 --> 00:23:39,760
and do that we can say long and provide

709
00:23:39,760 --> 00:23:40,000
an

710
00:23:40,000 --> 00:23:43,120
input value and ask it to convert that

711
00:23:43,120 --> 00:23:43,679
to a

712
00:23:43,679 --> 00:23:46,720
integer as you can see in here so as a

713
00:23:46,720 --> 00:23:47,520
result

714
00:23:47,520 --> 00:23:49,919
now you are not going to have a type

715
00:23:49,919 --> 00:23:51,520
conversion issues

716
00:23:51,520 --> 00:23:53,360
you have an integer conversion just to

717
00:23:53,360 --> 00:23:55,360
illustrate the point that it really did

718
00:23:55,360 --> 00:23:56,080
the job

719
00:23:56,080 --> 00:23:58,960
if i said long over here notice we get a

720
00:23:58,960 --> 00:24:01,520
compilation error type incompatibility

721
00:24:01,520 --> 00:24:04,320
if i said an integer here uh that one

722
00:24:04,320 --> 00:24:05,279
actually worked

723
00:24:05,279 --> 00:24:07,600
and again on the same note if i were to

724
00:24:07,600 --> 00:24:08,799
take that away

725
00:24:08,799 --> 00:24:11,200
from here and then if i were to simply

726
00:24:11,200 --> 00:24:12,559
say counting

727
00:24:12,559 --> 00:24:14,159
you would notice that that gives an

728
00:24:14,159 --> 00:24:16,640
error as well because you cannot put an

729
00:24:16,640 --> 00:24:19,120
integer that's got to be a long at this

730
00:24:19,120 --> 00:24:19,679
point

731
00:24:19,679 --> 00:24:22,320
but if i really wanted an integer i

732
00:24:22,320 --> 00:24:24,080
would have to then perform that

733
00:24:24,080 --> 00:24:26,320
operation but again the recursive

734
00:24:26,320 --> 00:24:27,919
structure really shines

735
00:24:27,919 --> 00:24:29,200
so if there's one thing i want you to

736
00:24:29,200 --> 00:24:31,600
take away from this i want you to keep

737
00:24:31,600 --> 00:24:32,559
in mind

738
00:24:32,559 --> 00:24:35,120
that collect is reduced okay more than

739
00:24:35,120 --> 00:24:35,760
one thing

740
00:24:35,760 --> 00:24:38,240
collectors are reduced and collect is

741
00:24:38,240 --> 00:24:39,200
taking

742
00:24:39,200 --> 00:24:42,400
a collector and the collector itself the

743
00:24:42,400 --> 00:24:43,440
collector's

744
00:24:43,440 --> 00:24:45,679
functions which is what we are focusing

745
00:24:45,679 --> 00:24:47,279
on this discussion

746
00:24:47,279 --> 00:24:50,960
is actually a set of utility functions

747
00:24:50,960 --> 00:24:53,840
but these functions themselves form a

748
00:24:53,840 --> 00:24:56,320
recursive structure of collectors

749
00:24:56,320 --> 00:24:59,120
you can build a collector using another

750
00:24:59,120 --> 00:25:01,360
collector which in turn can be used to

751
00:25:01,360 --> 00:25:03,279
build yet another collector

752
00:25:03,279 --> 00:25:06,159
and and that is where the real fun is

753
00:25:06,159 --> 00:25:08,159
and and after talking about all of this

754
00:25:08,159 --> 00:25:08,720
i still

755
00:25:08,720 --> 00:25:11,440
feel i have merely scratched the surface

756
00:25:11,440 --> 00:25:13,120
like i said in the beginning

757
00:25:13,120 --> 00:25:16,400
i don't really think i can say i've

758
00:25:16,400 --> 00:25:18,000
mastered collectors

759
00:25:18,000 --> 00:25:20,880
because collectors is so intriguing it

760
00:25:20,880 --> 00:25:23,440
contains a wealth of these functions

761
00:25:23,440 --> 00:25:25,279
and this is an exercise you can go

762
00:25:25,279 --> 00:25:26,799
through you can take a particular

763
00:25:26,799 --> 00:25:27,600
problem

764
00:25:27,600 --> 00:25:29,840
you know write the code imperatively

765
00:25:29,840 --> 00:25:31,520
write it in a functional style

766
00:25:31,520 --> 00:25:33,360
and then come back and refactor it to

767
00:25:33,360 --> 00:25:35,679
the elegance and the concise

768
00:25:35,679 --> 00:25:38,240
nature of collectors and of course it

769
00:25:38,240 --> 00:25:40,000
will be a hard journey because

770
00:25:40,000 --> 00:25:42,240
it can get a bit complex these are uh

771
00:25:42,240 --> 00:25:43,840
you know take an effort

772
00:25:43,840 --> 00:25:46,320
but when you have it working it does

773
00:25:46,320 --> 00:25:48,000
feel quite rewarding

774
00:25:48,000 --> 00:25:50,320
as you can see here hope that was useful

775
00:25:50,320 --> 00:25:51,919
i'll be delighted to

776
00:25:51,919 --> 00:25:54,840
take some of your questions at this

777
00:25:54,840 --> 00:25:56,240
point

778
00:25:56,240 --> 00:25:58,159
so thank you venkat that was excellent

779
00:25:58,159 --> 00:26:00,240
as always we have a couple questions the

780
00:26:00,240 --> 00:26:02,080
first one is their workshop or

781
00:26:02,080 --> 00:26:03,440
course you'd recommend to learn more

782
00:26:03,440 --> 00:26:05,360
about collectors and get hands-on

783
00:26:05,360 --> 00:26:06,080
experience

784
00:26:06,080 --> 00:26:09,200
using them uh uh i'm sure there are

785
00:26:09,200 --> 00:26:10,240
plenty of courses

786
00:26:10,240 --> 00:26:12,159
out there i i spent a lot of time

787
00:26:12,159 --> 00:26:14,080
teaching such courses in the industry as

788
00:26:14,080 --> 00:26:14,640
well

789
00:26:14,640 --> 00:26:16,640
uh i don't have anything off my head to

790
00:26:16,640 --> 00:26:18,720
really refer to but i would say

791
00:26:18,720 --> 00:26:22,080
shirts on the web so one of my favorite

792
00:26:22,080 --> 00:26:23,679
questions i saw this from when you spoke

793
00:26:23,679 --> 00:26:24,559
earlier

794
00:26:24,559 --> 00:26:27,840
is that what ide are you using uh this

795
00:26:27,840 --> 00:26:28,720
is textmate

796
00:26:28,720 --> 00:26:31,039
so if anyone is interested in looking at

797
00:26:31,039 --> 00:26:32,080
it uh

798
00:26:32,080 --> 00:26:35,679
go to agilelearner.com

799
00:26:35,679 --> 00:26:37,600
and there's a search box just type the

800
00:26:37,600 --> 00:26:39,039
word text mate on it

801
00:26:39,039 --> 00:26:41,039
i show how to set this up for java

802
00:26:41,039 --> 00:26:42,559
python groovy

803
00:26:42,559 --> 00:26:44,480
javascript so multiple different

804
00:26:44,480 --> 00:26:46,559
languages if you're not able to find it

805
00:26:46,559 --> 00:26:47,840
drop me an email

806
00:26:47,840 --> 00:26:51,200
or simply you know ping me on twitter

807
00:26:51,200 --> 00:26:53,520
i'll be more than happy to send the link

808
00:26:53,520 --> 00:26:55,440
cool maybe you could drop that link into

809
00:26:55,440 --> 00:26:57,600
the slack channel for the track java as

810
00:26:57,600 --> 00:26:59,120
well sure

811
00:26:59,120 --> 00:27:01,679
all right so that was awesome i really

812
00:27:01,679 --> 00:27:02,880
enjoyed that

813
00:27:02,880 --> 00:27:06,000
uh i think we're ready for brian to step

814
00:27:06,000 --> 00:27:09,120
in yeah all right um i've got one more

815
00:27:09,120 --> 00:27:10,400
question for you van get

816
00:27:10,400 --> 00:27:12,960
um in one of your examples you were

817
00:27:12,960 --> 00:27:13,760
using

818
00:27:13,760 --> 00:27:16,640
um the map function to get the first

819
00:27:16,640 --> 00:27:18,640
name of the person and then you

820
00:27:18,640 --> 00:27:21,039
use the map version function again to

821
00:27:21,039 --> 00:27:22,399
get a two uppercase

822
00:27:22,399 --> 00:27:25,039
why not combine these two and what is

823
00:27:25,039 --> 00:27:25,760
yeah

824
00:27:25,760 --> 00:27:28,399
awesome question uh so a premature

825
00:27:28,399 --> 00:27:30,960
optimization is the root of all evil

826
00:27:30,960 --> 00:27:33,279
we've been told by a very wise man isn't

827
00:27:33,279 --> 00:27:34,080
it and

828
00:27:34,080 --> 00:27:36,240
and 40 years later we try every day to

829
00:27:36,240 --> 00:27:37,360
disprove him

830
00:27:37,360 --> 00:27:39,039
um the reason i want to keep them

831
00:27:39,039 --> 00:27:40,399
separate brian it's a really good

832
00:27:40,399 --> 00:27:41,679
question and the reason i want to keep

833
00:27:41,679 --> 00:27:42,720
them separate is

834
00:27:42,720 --> 00:27:45,919
twofold one is if you put them

835
00:27:45,919 --> 00:27:47,919
in one line that's called lack of

836
00:27:47,919 --> 00:27:49,760
cohesion and software development isn't

837
00:27:49,760 --> 00:27:50,080
it

838
00:27:50,080 --> 00:27:52,000
cohesion is where a piece of code is

839
00:27:52,000 --> 00:27:53,440
narrow focused and does one thing and

840
00:27:53,440 --> 00:27:54,640
one thing really well

841
00:27:54,640 --> 00:27:56,080
so by keeping them in two different

842
00:27:56,080 --> 00:27:58,000
lines it's more cohesive

843
00:27:58,000 --> 00:28:00,480
secondly i'll illustrate with my hand

844
00:28:00,480 --> 00:28:01,120
here

845
00:28:01,120 --> 00:28:03,760
if if you have these lines of code it's

846
00:28:03,760 --> 00:28:06,559
easy for me to remove a few

847
00:28:06,559 --> 00:28:09,440
and bring back a few into it so this

848
00:28:09,440 --> 00:28:11,520
becomes easy to maintain the code when

849
00:28:11,520 --> 00:28:12,799
they are separate lines

850
00:28:12,799 --> 00:28:15,360
if i combine them into one that's more

851
00:28:15,360 --> 00:28:16,080
expensive

852
00:28:16,080 --> 00:28:18,320
more effort to really modify it so

853
00:28:18,320 --> 00:28:19,440
keeping them separate

854
00:28:19,440 --> 00:28:21,679
is better so from the code maintenance

855
00:28:21,679 --> 00:28:22,640
point of view

856
00:28:22,640 --> 00:28:24,720
code is cohesive easier to change easier

857
00:28:24,720 --> 00:28:26,320
to maintain of course the p

858
00:28:26,320 --> 00:28:28,080
word what about performance from the

859
00:28:28,080 --> 00:28:29,360
performance point of view

860
00:28:29,360 --> 00:28:32,960
we also benefit because internally

861
00:28:32,960 --> 00:28:35,919
those functions are fused together so we

862
00:28:35,919 --> 00:28:37,440
don't lose any performance

863
00:28:37,440 --> 00:28:39,440
internally we get the benefit of

864
00:28:39,440 --> 00:28:41,039
maintainable code outside

865
00:28:41,039 --> 00:28:42,480
so that's the reason it's important to

866
00:28:42,480 --> 00:28:44,240
keep them separate

867
00:28:44,240 --> 00:28:47,520
so in general you would say you prefer

868
00:28:47,520 --> 00:28:50,080
to make them or to keep the function

869
00:28:50,080 --> 00:28:51,039
small and use

870
00:28:51,039 --> 00:28:53,679
map and filter multiple times if needed

871
00:28:53,679 --> 00:28:54,559
absolutely

872
00:28:54,559 --> 00:28:56,240
not not not it's not a preference i

873
00:28:56,240 --> 00:28:58,720
would actually insist on it

874
00:28:58,720 --> 00:29:00,559
all right thank you i think that is uh

875
00:29:00,559 --> 00:29:02,080
that is very useful

876
00:29:02,080 --> 00:29:05,120
and uh with that venkat is uh

877
00:29:05,120 --> 00:29:08,240
basically uh well the last one on this

878
00:29:08,240 --> 00:29:08,559
part

879
00:29:08,559 --> 00:29:12,480
of the java track um within a few

880
00:29:12,480 --> 00:29:14,080
seconds the stream will move

881
00:29:14,080 --> 00:29:16,960
over to if i'm not mistaking uh simon

882
00:29:16,960 --> 00:29:18,559
and simon will uh host

883
00:29:18,559 --> 00:29:21,200
baruch who will uh who will do the next

884
00:29:21,200 --> 00:29:21,840
session

885
00:29:21,840 --> 00:29:24,880
so for now i want to uh sincerely uh

886
00:29:24,880 --> 00:29:27,360
thank you venkat and matt for hosting

887
00:29:27,360 --> 00:29:29,039
the last few hours here

888
00:29:29,039 --> 00:29:31,919
on the on the java track uh it's been a

889
00:29:31,919 --> 00:29:33,679
delight working with you uh

890
00:29:33,679 --> 00:29:36,399
and um well i think uh we had a lot of

891
00:29:36,399 --> 00:29:37,679
great content

892
00:29:37,679 --> 00:29:41,120
and uh a killer and with your talk uh in

893
00:29:41,120 --> 00:29:43,360
the end to vanguard so

894
00:29:43,360 --> 00:29:45,840
thank you so much for watching and um

895
00:29:45,840 --> 00:29:47,760
we'll be back in a sec or well

896
00:29:47,760 --> 00:29:49,679
simon will be back in a second thank you

897
00:29:49,679 --> 00:29:51,760
so much see you later it's great working

898
00:29:51,760 --> 00:29:54,879
with you

