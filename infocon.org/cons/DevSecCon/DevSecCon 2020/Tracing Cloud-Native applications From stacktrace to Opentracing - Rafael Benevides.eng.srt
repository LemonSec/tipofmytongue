1
00:00:00,080 --> 00:00:03,360
welcome thank you so much brian finally

2
00:00:03,360 --> 00:00:04,560
here

3
00:00:04,560 --> 00:00:07,680
no worries we we got you um we we're

4
00:00:07,680 --> 00:00:08,000
just

5
00:00:08,000 --> 00:00:10,000
uh we're just three minutes overdue so

6
00:00:10,000 --> 00:00:11,040
uh i want to say

7
00:00:11,040 --> 00:00:13,280
um i want to give the stage to you so if

8
00:00:13,280 --> 00:00:14,920
you can share your screen for me

9
00:00:14,920 --> 00:00:18,800
please then i can add that to the

10
00:00:18,800 --> 00:00:21,039
to the stream and then the floor is

11
00:00:21,039 --> 00:00:23,119
yours

12
00:00:23,119 --> 00:00:25,599
okay perfect i'm already i will see your

13
00:00:25,599 --> 00:00:26,400
screen

14
00:00:26,400 --> 00:00:28,960
yes your screen is visible so um let's

15
00:00:28,960 --> 00:00:30,720
go for it

16
00:00:30,720 --> 00:00:33,920
perfect so let me start by

17
00:00:33,920 --> 00:00:36,160
making these questions i will talk by

18
00:00:36,160 --> 00:00:37,760
the way for everyone to know what i'm

19
00:00:37,760 --> 00:00:38,800
talking about

20
00:00:38,800 --> 00:00:41,280
i'm talking about open tracing which is

21
00:00:41,280 --> 00:00:42,079
a part of

22
00:00:42,079 --> 00:00:45,840
uh observability in in a micro services

23
00:00:45,840 --> 00:00:48,079
environment and it's interesting because

24
00:00:48,079 --> 00:00:50,000
i know that among us there are a lot of

25
00:00:50,000 --> 00:00:51,199
developers

26
00:00:51,199 --> 00:00:54,399
and we call this is a a little joke

27
00:00:54,399 --> 00:00:57,360
we call it observability as seen it says

28
00:00:57,360 --> 00:00:58,079
in this twitter

29
00:00:58,079 --> 00:01:01,359
from 2017 because devs don't like to do

30
00:01:01,359 --> 00:01:02,559
money touring

31
00:01:02,559 --> 00:01:05,040
so we need to package it in a new normal

32
00:01:05,040 --> 00:01:05,760
clutter

33
00:01:05,760 --> 00:01:08,479
number clapper to make it palatable and

34
00:01:08,479 --> 00:01:09,119
trendy

35
00:01:09,119 --> 00:01:12,320
so i think that it's funny

36
00:01:12,320 --> 00:01:16,240
and it's true uh we need to remember

37
00:01:16,240 --> 00:01:16,640
that

38
00:01:16,640 --> 00:01:19,759
there are three pillars of observability

39
00:01:19,759 --> 00:01:22,000
tracing metrics and logging but

40
00:01:22,000 --> 00:01:23,200
specifically

41
00:01:23,200 --> 00:01:26,000
for this presentation i will focus on

42
00:01:26,000 --> 00:01:27,600
tracing

43
00:01:27,600 --> 00:01:30,880
and the reason is because

44
00:01:30,880 --> 00:01:32,880
if we look this architecture where we

45
00:01:32,880 --> 00:01:34,400
have a client

46
00:01:34,400 --> 00:01:36,240
making a communication with a web

47
00:01:36,240 --> 00:01:38,720
framework that is in a load balancer

48
00:01:38,720 --> 00:01:42,880
uh that also balances to a rpc request

49
00:01:42,880 --> 00:01:45,360
to resources api if you look this

50
00:01:45,360 --> 00:01:46,640
picture

51
00:01:46,640 --> 00:01:50,320
what you think is the invocation order

52
00:01:50,320 --> 00:01:52,880
what do you think that is the latency uh

53
00:01:52,880 --> 00:01:54,880
for example suppose that these

54
00:01:54,880 --> 00:01:58,240
uh single requests takes like 10 seconds

55
00:01:58,240 --> 00:01:59,280
to reply

56
00:01:59,280 --> 00:02:02,320
who is causing uh that delay in an

57
00:02:02,320 --> 00:02:04,320
architecture like that

58
00:02:04,320 --> 00:02:06,960
or if there is an error who caused an

59
00:02:06,960 --> 00:02:07,600
error

60
00:02:07,600 --> 00:02:11,120
it's hard to find out when we see

61
00:02:11,120 --> 00:02:14,160
just the architectural overview

62
00:02:14,160 --> 00:02:17,680
of a microservice so

63
00:02:17,680 --> 00:02:20,800
things get more clear when we use a

64
00:02:20,800 --> 00:02:22,000
timeline view so we can

65
00:02:22,000 --> 00:02:25,599
see the order uh we can see how long

66
00:02:25,599 --> 00:02:28,640
it is taking for each service to

67
00:02:28,640 --> 00:02:31,760
uh complete the request

68
00:02:31,760 --> 00:02:35,680
and plus what latency is important

69
00:02:35,680 --> 00:02:38,080
important because in a microservices

70
00:02:38,080 --> 00:02:39,760
environment

71
00:02:39,760 --> 00:02:42,560
where we have uh microservice a calling

72
00:02:42,560 --> 00:02:43,920
microservice b

73
00:02:43,920 --> 00:02:47,840
and so on we need to understand

74
00:02:47,840 --> 00:02:50,160
what's the critical path if something

75
00:02:50,160 --> 00:02:51,360
goes wrong

76
00:02:51,360 --> 00:02:53,840
why did it fail who failed what's the

77
00:02:53,840 --> 00:02:54,640
latency

78
00:02:54,640 --> 00:02:57,760
of those calls and that's why i'm

79
00:02:57,760 --> 00:02:59,200
presenting open tracing

80
00:02:59,200 --> 00:03:02,319
open trades that uh it needs to be clear

81
00:03:02,319 --> 00:03:06,159
that there are several implementations

82
00:03:06,159 --> 00:03:09,519
for distributed tracing all of them

83
00:03:09,519 --> 00:03:12,560
are based on the on a paper called

84
00:03:12,560 --> 00:03:15,760
dapper we have zip king we have

85
00:03:15,760 --> 00:03:19,360
we have the zip king we have uh jagger

86
00:03:19,360 --> 00:03:22,800
but cncf decided to

87
00:03:22,800 --> 00:03:26,000
uh give us this uh this

88
00:03:26,000 --> 00:03:29,200
spec to address a problem of

89
00:03:29,200 --> 00:03:30,319
incompatibility

90
00:03:30,319 --> 00:03:33,280
between the uh the different distributed

91
00:03:33,280 --> 00:03:35,120
tracings

92
00:03:35,120 --> 00:03:38,159
uh so the idea here uh

93
00:03:38,159 --> 00:03:41,280
is to be a

94
00:03:41,280 --> 00:03:46,000
vendor to be independent of vendors

95
00:03:46,000 --> 00:03:48,080
and to understand operant open tracing

96
00:03:48,080 --> 00:03:50,560
to to understand distribution tracing

97
00:03:50,560 --> 00:03:51,360
it's important

98
00:03:51,360 --> 00:03:54,400
also to understand the terminology so

99
00:03:54,400 --> 00:03:56,959
first what we need to understand what is

100
00:03:56,959 --> 00:03:58,000
a trace

101
00:03:58,000 --> 00:04:01,280
i will go through different uh words

102
00:04:01,280 --> 00:04:02,159
that are used

103
00:04:02,159 --> 00:04:05,200
in uh distributed tracing so

104
00:04:05,200 --> 00:04:07,760
we need to understand uh what we are

105
00:04:07,760 --> 00:04:08,799
talking about

106
00:04:08,799 --> 00:04:12,000
so the first one a trace a trace

107
00:04:12,000 --> 00:04:15,360
you can we can think about a trace as a

108
00:04:15,360 --> 00:04:16,320
single request

109
00:04:16,320 --> 00:04:19,440
a single request will be a single trace

110
00:04:19,440 --> 00:04:21,440
in a distributed tracing

111
00:04:21,440 --> 00:04:24,800
and it that all that a single trace

112
00:04:24,800 --> 00:04:28,080
consists of a collection of expanse

113
00:04:28,080 --> 00:04:31,440
so what is a span i spent is

114
00:04:31,440 --> 00:04:34,720
basically an operation so

115
00:04:34,720 --> 00:04:37,919
if you have a microservice a calling b

116
00:04:37,919 --> 00:04:41,120
there are several operations uh included

117
00:04:41,120 --> 00:04:44,160
in that request so each operation is a

118
00:04:44,160 --> 00:04:45,199
span

119
00:04:45,199 --> 00:04:48,240
and i spend carries an operation name

120
00:04:48,240 --> 00:04:51,759
i start and finish timestamp tags logs

121
00:04:51,759 --> 00:04:55,360
and a reference with other spans

122
00:04:55,360 --> 00:04:57,840
uh what kind of relationship with others

123
00:04:57,840 --> 00:04:58,720
fans

124
00:04:58,720 --> 00:05:02,000
can have well we can have a child of

125
00:05:02,000 --> 00:05:04,080
uh relationship or we can have a

126
00:05:04,080 --> 00:05:05,919
follow-from relationship

127
00:05:05,919 --> 00:05:09,520
it will be more clear when i demo that

128
00:05:09,520 --> 00:05:13,360
because uh we will see in a demo

129
00:05:13,360 --> 00:05:14,479
where i have three different

130
00:05:14,479 --> 00:05:17,120
microservices uh you one using a

131
00:05:17,120 --> 00:05:19,199
java micro profile another one using

132
00:05:19,199 --> 00:05:20,240
javascript

133
00:05:20,240 --> 00:05:22,840
spring boot and another one using

134
00:05:22,840 --> 00:05:24,320
node.js

135
00:05:24,320 --> 00:05:27,360
to see how a distributed tracing uh can

136
00:05:27,360 --> 00:05:30,000
work with different languages

137
00:05:30,000 --> 00:05:31,840
another thing that we can have inside a

138
00:05:31,840 --> 00:05:34,479
span is ice pen log

139
00:05:34,479 --> 00:05:37,120
so what is a span log it's a key value

140
00:05:37,120 --> 00:05:37,680
pair

141
00:05:37,680 --> 00:05:40,240
that we can place it inside the span so

142
00:05:40,240 --> 00:05:41,120
an example

143
00:05:41,120 --> 00:05:44,000
we can place a message like we we can

144
00:05:44,000 --> 00:05:44,800
see here

145
00:05:44,800 --> 00:05:47,520
uh opening a connection to my sql server

146
00:05:47,520 --> 00:05:50,160
or i can't connect to a mysql server

147
00:05:50,160 --> 00:05:53,680
uh it's used for debugging purpose or to

148
00:05:53,680 --> 00:05:55,120
give more information

149
00:05:55,120 --> 00:05:58,319
about what that operation is doing in

150
00:05:58,319 --> 00:06:01,759
specific moments of time we can also

151
00:06:01,759 --> 00:06:02,240
have

152
00:06:02,240 --> 00:06:05,520
tags the tags are also key value but

153
00:06:05,520 --> 00:06:07,440
they are

154
00:06:07,440 --> 00:06:10,000
they follow a semantic convention let me

155
00:06:10,000 --> 00:06:11,759
open this cement convention here so you

156
00:06:11,759 --> 00:06:12,319
can have an

157
00:06:12,319 --> 00:06:14,800
idea what i'm talking about so for

158
00:06:14,800 --> 00:06:16,479
example for a specific

159
00:06:16,479 --> 00:06:19,520
operation we can give the name of the

160
00:06:19,520 --> 00:06:20,400
component

161
00:06:20,400 --> 00:06:23,280
let me increase the font size here uh we

162
00:06:23,280 --> 00:06:23,840
can

163
00:06:23,840 --> 00:06:27,120
uh give the name of the instance the db

164
00:06:27,120 --> 00:06:29,600
instance the db statement that we are

165
00:06:29,600 --> 00:06:30,639
performing the b

166
00:06:30,639 --> 00:06:32,720
type the db user the error or the http

167
00:06:32,720 --> 00:06:33,680
method

168
00:06:33,680 --> 00:06:37,440
or is http status code and so on

169
00:06:37,440 --> 00:06:41,600
so they are keypad key value pairs

170
00:06:41,600 --> 00:06:44,000
that allows us to give a better

171
00:06:44,000 --> 00:06:45,120
documentation

172
00:06:45,120 --> 00:06:48,400
uh about that operation

173
00:06:48,400 --> 00:06:50,000
what else we can have we can have a

174
00:06:50,000 --> 00:06:51,599
baggage which is

175
00:06:51,599 --> 00:06:54,960
also key value pair but it cross

176
00:06:54,960 --> 00:06:58,080
the process the it

177
00:06:58,080 --> 00:07:01,039
is a cross press cross process bond

178
00:07:01,039 --> 00:07:01,759
there it's

179
00:07:01,759 --> 00:07:04,800
cross pressed sorry uh cross

180
00:07:04,800 --> 00:07:08,319
process boundaries which means that

181
00:07:08,319 --> 00:07:10,880
if you place something in the baggage

182
00:07:10,880 --> 00:07:14,160
that will propagate to other operations

183
00:07:14,160 --> 00:07:16,800
so this is an example of a span so we

184
00:07:16,800 --> 00:07:17,440
have

185
00:07:17,440 --> 00:07:20,000
the name of the operation a timestamp

186
00:07:20,000 --> 00:07:20,479
where

187
00:07:20,479 --> 00:07:23,199
when it starts when it ends we have the

188
00:07:23,199 --> 00:07:24,479
tags

189
00:07:24,479 --> 00:07:27,120
for that operation we have logs we have

190
00:07:27,120 --> 00:07:28,400
of course a context

191
00:07:28,400 --> 00:07:32,880
and and we can have baggage items

192
00:07:32,880 --> 00:07:36,639
and when we talk about open tracing

193
00:07:36,639 --> 00:07:39,680
the most common and the most adopted

194
00:07:39,680 --> 00:07:40,800
implementation

195
00:07:40,800 --> 00:07:43,840
is jagger jagger was also it was

196
00:07:43,840 --> 00:07:44,879
inspired by the

197
00:07:44,879 --> 00:07:48,000
dapper and zipkin and it was

198
00:07:48,000 --> 00:07:51,039
open sources by uber and it's nice

199
00:07:51,039 --> 00:07:52,400
because there are several

200
00:07:52,400 --> 00:07:54,639
clients for different languages we have

201
00:07:54,639 --> 00:07:56,639
clients for gold for java for node for

202
00:07:56,639 --> 00:07:57,280
python

203
00:07:57,280 --> 00:08:00,560
so if you're if your your microservices

204
00:08:00,560 --> 00:08:05,039
use the different languages

205
00:08:05,039 --> 00:08:07,360
then you can use jagger because you have

206
00:08:07,360 --> 00:08:08,479
support for

207
00:08:08,479 --> 00:08:10,840
at least those languages that are listed

208
00:08:10,840 --> 00:08:12,479
here

209
00:08:12,479 --> 00:08:15,599
jagger uh seems to be complex

210
00:08:15,599 --> 00:08:18,720
but it's not uh yes the idea here is

211
00:08:18,720 --> 00:08:20,560
that your application you

212
00:08:20,560 --> 00:08:23,599
use a jagger client to send

213
00:08:23,599 --> 00:08:26,319
udp packages for a jagger clients that

214
00:08:26,319 --> 00:08:27,680
will send

215
00:08:27,680 --> 00:08:29,599
uh that information to a jagger

216
00:08:29,599 --> 00:08:32,240
collector that will collect the

217
00:08:32,240 --> 00:08:34,719
information collect information for from

218
00:08:34,719 --> 00:08:35,599
from different

219
00:08:35,599 --> 00:08:38,958
agents will it will place that

220
00:08:38,958 --> 00:08:39,599
information

221
00:08:39,599 --> 00:08:43,120
on a database that later we can use a

222
00:08:43,120 --> 00:08:46,240
ui to to consume

223
00:08:46,240 --> 00:08:49,600
that information okay now

224
00:08:49,600 --> 00:08:52,640
the part that i like the most it's how

225
00:08:52,640 --> 00:08:53,120
to

226
00:08:53,120 --> 00:08:56,240
demo that well first let me

227
00:08:56,240 --> 00:09:00,640
explain uh my environment here

228
00:09:00,640 --> 00:09:03,839
let me increase the font size and

229
00:09:03,839 --> 00:09:07,200
i have three micro services that i

230
00:09:07,200 --> 00:09:10,080
let me open them here in my in visual

231
00:09:10,080 --> 00:09:11,839
studio code

232
00:09:11,839 --> 00:09:14,640
i have as i said a microservice a which

233
00:09:14,640 --> 00:09:16,720
is implemented using

234
00:09:16,720 --> 00:09:20,320
um microprofile

235
00:09:20,320 --> 00:09:24,240
so it's a simple jax rs uh

236
00:09:24,240 --> 00:09:27,760
end point with micro profile rest client

237
00:09:27,760 --> 00:09:28,880
to consume

238
00:09:28,880 --> 00:09:32,399
a microservice b we have a microservice

239
00:09:32,399 --> 00:09:33,040
b that

240
00:09:33,040 --> 00:09:36,800
is implemented as

241
00:09:36,800 --> 00:09:40,240
it's a spring framework okay so we have

242
00:09:40,240 --> 00:09:42,560
the request mapping here that will

243
00:09:42,560 --> 00:09:46,320
uh receive a parameter for from the

244
00:09:46,320 --> 00:09:49,279
microservice a and store it in a

245
00:09:49,279 --> 00:09:50,320
database

246
00:09:50,320 --> 00:09:54,399
and send it to a kafka topic and also

247
00:09:54,399 --> 00:09:58,560
perform a vocation to a microservices c

248
00:09:58,560 --> 00:10:02,720
and microserve c is

249
00:10:02,720 --> 00:10:06,160
a node.js implementation okay

250
00:10:06,160 --> 00:10:09,120
using express so three different

251
00:10:09,120 --> 00:10:10,079
languages let

252
00:10:10,079 --> 00:10:13,360
let's start all of them here by using

253
00:10:13,360 --> 00:10:16,320
docker compose

254
00:10:16,959 --> 00:10:19,200
to start all my micro services and my

255
00:10:19,200 --> 00:10:20,320
sequel and

256
00:10:20,320 --> 00:10:24,320
kafika everything together

257
00:10:27,200 --> 00:10:30,240
i am jagger of course by the way so i

258
00:10:30,240 --> 00:10:31,440
have jagger

259
00:10:31,440 --> 00:10:33,839
my sequel

260
00:10:34,560 --> 00:10:37,360
zookeeper needed by kafka kafka is

261
00:10:37,360 --> 00:10:39,839
starting

262
00:10:40,640 --> 00:10:44,000
and microserve's a b and c

263
00:10:44,000 --> 00:10:47,839
will start in a couple of seconds

264
00:10:48,800 --> 00:10:52,640
now that uh let me open

265
00:10:52,640 --> 00:10:56,000
also the jagger ui so as i said i'm

266
00:10:56,000 --> 00:10:58,000
using jagger as implementation for open

267
00:10:58,000 --> 00:10:59,120
trace

268
00:10:59,120 --> 00:11:01,920
it for now we can just consume a service

269
00:11:01,920 --> 00:11:03,040
it's empty because

270
00:11:03,040 --> 00:11:06,000
there is there are no spends collected

271
00:11:06,000 --> 00:11:07,279
by jagger

272
00:11:07,279 --> 00:11:10,320
so let's do our first request

273
00:11:10,320 --> 00:11:12,000
i have this endpoint here that will

274
00:11:12,000 --> 00:11:14,160
perform a serial invocation

275
00:11:14,160 --> 00:11:16,880
for those microservices so yeah it

276
00:11:16,880 --> 00:11:18,320
returned

277
00:11:18,320 --> 00:11:21,360
here as we can see a microservice a

278
00:11:21,360 --> 00:11:23,760
like that should be like a front-end

279
00:11:23,760 --> 00:11:24,720
received my

280
00:11:24,720 --> 00:11:27,839
parameter raphael it

281
00:11:27,839 --> 00:11:30,640
invoked microservice b to save that

282
00:11:30,640 --> 00:11:31,680
information

283
00:11:31,680 --> 00:11:34,480
in a database saved the information also

284
00:11:34,480 --> 00:11:36,160
in a kafka topic

285
00:11:36,160 --> 00:11:39,680
and invoked a microsoft c that says

286
00:11:39,680 --> 00:11:43,120
reload hello rafael let's see what's

287
00:11:43,120 --> 00:11:46,240
hap what happened inside jagger now

288
00:11:46,240 --> 00:11:49,040
so let's refresh the page we can see

289
00:11:49,040 --> 00:11:49,839
here that we

290
00:11:49,839 --> 00:11:52,720
have uh our services microservice a b

291
00:11:52,720 --> 00:11:53,920
and c

292
00:11:53,920 --> 00:11:57,120
and now i can look

293
00:11:57,120 --> 00:11:59,839
for that specific request in time you

294
00:11:59,839 --> 00:12:01,440
can see here that i have

295
00:12:01,440 --> 00:12:05,040
um information about the time

296
00:12:05,040 --> 00:12:08,560
information about the latency and

297
00:12:08,560 --> 00:12:11,360
if we open this single request we can

298
00:12:11,360 --> 00:12:12,160
explore

299
00:12:12,160 --> 00:12:15,360
what happened inside my

300
00:12:15,360 --> 00:12:19,839
my single request so that request

301
00:12:20,399 --> 00:12:23,200
if we open here uh the main entrance we

302
00:12:23,200 --> 00:12:26,079
can see the tags

303
00:12:27,360 --> 00:12:29,680
so we can easily identify that this is a

304
00:12:29,680 --> 00:12:30,959
jaxx rs

305
00:12:30,959 --> 00:12:33,920
server so we have this pen kind it's a

306
00:12:33,920 --> 00:12:36,000
server that received a request

307
00:12:36,000 --> 00:12:39,760
in this url uh we have details about the

308
00:12:39,760 --> 00:12:40,800
process the

309
00:12:40,800 --> 00:12:44,959
uh the jagger version the ip address

310
00:12:44,959 --> 00:12:47,600
uh for that container the id of the

311
00:12:47,600 --> 00:12:48,720
container

312
00:12:48,720 --> 00:12:51,680
then before calling microservice b we

313
00:12:51,680 --> 00:12:52,480
can see

314
00:12:52,480 --> 00:12:55,279
it that uh we can see that it's called

315
00:12:55,279 --> 00:12:56,399
another

316
00:12:56,399 --> 00:12:58,639
a method in another class the method

317
00:12:58,639 --> 00:12:59,760
call microservice b

318
00:12:59,760 --> 00:13:02,240
serial in the class my service so we

319
00:13:02,240 --> 00:13:03,519
have the detail here

320
00:13:03,519 --> 00:13:08,160
and look i have a parameter

321
00:13:08,160 --> 00:13:11,279
uh that parameter is a it's a log

322
00:13:11,279 --> 00:13:13,839
that i place it in inside my request

323
00:13:13,839 --> 00:13:14,399
then

324
00:13:14,399 --> 00:13:18,399
we have a jax rs client that we invoke

325
00:13:18,399 --> 00:13:20,560
the microservice be in this in a

326
00:13:20,560 --> 00:13:21,839
specific endpoint

327
00:13:21,839 --> 00:13:23,839
and so on in the microservice b we can

328
00:13:23,839 --> 00:13:25,519
see how deep

329
00:13:25,519 --> 00:13:28,880
the tracing can go so it can go

330
00:13:28,880 --> 00:13:32,160
through for example the java

331
00:13:32,160 --> 00:13:36,000
the jdbc uh request so it made

332
00:13:36,000 --> 00:13:39,120
a statement to get the next sequence

333
00:13:39,120 --> 00:13:40,720
from hibernate

334
00:13:40,720 --> 00:13:45,440
uh until it insert the message

335
00:13:45,440 --> 00:13:49,760
inside my database

336
00:13:49,760 --> 00:13:52,399
and so on the for kafka we have the same

337
00:13:52,399 --> 00:13:53,440
thing

338
00:13:53,440 --> 00:13:56,959
uh we can see that it's stored

339
00:13:56,959 --> 00:14:00,079
it used the producer to put to

340
00:14:00,079 --> 00:14:03,360
send my information to a

341
00:14:03,360 --> 00:14:07,199
topic called my topic

342
00:14:08,880 --> 00:14:12,639
and finally uh microsoft b will

343
00:14:12,639 --> 00:14:15,519
send uh will request we'll send the

344
00:14:15,519 --> 00:14:17,839
request to the to microsoft c

345
00:14:17,839 --> 00:14:20,240
let me stop microsoft c to see what

346
00:14:20,240 --> 00:14:22,240
happens in a case of error

347
00:14:22,240 --> 00:14:25,760
so let me open a new uh

348
00:14:25,760 --> 00:14:30,560
window here perform a docker compose

349
00:14:30,560 --> 00:14:33,600
stop micro service

350
00:14:33,600 --> 00:14:35,839
c

351
00:14:36,720 --> 00:14:40,240
micro service c

352
00:14:40,240 --> 00:14:45,839
you can see it stopping

353
00:14:50,320 --> 00:14:53,680
yeah it stopped now i'll pref

354
00:14:53,680 --> 00:14:56,160
perform the same request and now we have

355
00:14:56,160 --> 00:14:57,040
an error

356
00:14:57,040 --> 00:14:59,519
of course i didn't treat the error so we

357
00:14:59,519 --> 00:15:01,600
have a cascading failure

358
00:15:01,600 --> 00:15:05,199
and if i look the new request here

359
00:15:05,199 --> 00:15:08,560
i can see that it calls it three errors

360
00:15:08,560 --> 00:15:11,360
like if i open i can see that the

361
00:15:11,360 --> 00:15:12,560
cascading failure

362
00:15:12,560 --> 00:15:15,600
landed here on my microservice a uh

363
00:15:15,600 --> 00:15:18,959
i have details about the the log

364
00:15:18,959 --> 00:15:21,199
in and i i have details about that

365
00:15:21,199 --> 00:15:22,079
operation

366
00:15:22,079 --> 00:15:25,519
inside the log i can see the the error

367
00:15:25,519 --> 00:15:28,560
so no status it received a status quo

368
00:15:28,560 --> 00:15:31,680
500 and that 500 came from the

369
00:15:31,680 --> 00:15:33,519
microservice b

370
00:15:33,519 --> 00:15:37,199
because microservice b couldn't uh

371
00:15:37,199 --> 00:15:40,079
connect to microservice c we can see it

372
00:15:40,079 --> 00:15:40,480
here

373
00:15:40,480 --> 00:15:43,600
and no host exception so yeah

374
00:15:43,600 --> 00:15:46,959
uh distributed tracing can help us

375
00:15:46,959 --> 00:15:50,560
to debug our also our applications so

376
00:15:50,560 --> 00:15:53,120
let me return the microservc

377
00:15:53,120 --> 00:15:58,959
so we can understand how it works

378
00:16:01,279 --> 00:16:03,360
now that it started let me perform a

379
00:16:03,360 --> 00:16:04,560
request

380
00:16:04,560 --> 00:16:09,839
everything is working again

381
00:16:11,600 --> 00:16:15,600
and there it goes uh by the way i have

382
00:16:15,600 --> 00:16:16,720
also another

383
00:16:16,720 --> 00:16:20,399
implementation here in parallel

384
00:16:20,399 --> 00:16:23,839
we can just compare

385
00:16:27,120 --> 00:16:29,040
that the implementation now is happening

386
00:16:29,040 --> 00:16:31,360
in parallel so you can see

387
00:16:31,360 --> 00:16:34,320
it here that they almost started they

388
00:16:34,320 --> 00:16:34,800
the

389
00:16:34,800 --> 00:16:37,839
invocation to write

390
00:16:37,839 --> 00:16:40,560
to that to call the microsoft see it

391
00:16:40,560 --> 00:16:41,279
started

392
00:16:41,279 --> 00:16:44,880
even before uh the end of the uh of

393
00:16:44,880 --> 00:16:48,839
writing to a kafka topic and also

394
00:16:48,839 --> 00:16:52,240
the invocation to a database started

395
00:16:52,240 --> 00:16:54,160
even before the end of the invoking

396
00:16:54,160 --> 00:16:55,839
microservices so now it's happening

397
00:16:55,839 --> 00:16:57,360
parallel so we can

398
00:16:57,360 --> 00:17:00,639
uh analyze that as well

399
00:17:00,639 --> 00:17:04,319
well okay now that we see we saw how

400
00:17:04,319 --> 00:17:08,160
open tracing works we can we can

401
00:17:08,160 --> 00:17:11,280
understand how the api of open tracing

402
00:17:11,280 --> 00:17:14,319
works as well so first we need to get a

403
00:17:14,319 --> 00:17:16,079
tracer

404
00:17:16,079 --> 00:17:18,720
uh based on the language of or the

405
00:17:18,720 --> 00:17:19,520
framework

406
00:17:19,520 --> 00:17:21,599
there are different approaches to get

407
00:17:21,599 --> 00:17:23,280
the the tracer

408
00:17:23,280 --> 00:17:26,319
now that we have a tracing a tracer we

409
00:17:26,319 --> 00:17:27,119
can

410
00:17:27,119 --> 00:17:29,120
create ice pen by calling the method

411
00:17:29,120 --> 00:17:30,880
beauty span so you give the name of the

412
00:17:30,880 --> 00:17:31,679
operation

413
00:17:31,679 --> 00:17:35,120
and make it active if there are

414
00:17:35,120 --> 00:17:38,559
uh if there are other active spams

415
00:17:38,559 --> 00:17:42,320
in a tread local uh context

416
00:17:42,320 --> 00:17:44,960
then the newest fan will be a child of

417
00:17:44,960 --> 00:17:46,320
the parents fan

418
00:17:46,320 --> 00:17:49,039
so that's why we we need also to make it

419
00:17:49,039 --> 00:17:50,480
active

420
00:17:50,480 --> 00:17:54,000
and that that glue between the

421
00:17:54,000 --> 00:17:56,640
pattern spun its pattern span will be

422
00:17:56,640 --> 00:17:57,360
made

423
00:17:57,360 --> 00:18:00,320
automatically then with the span we can

424
00:18:00,320 --> 00:18:02,559
set a tag we can set logs we can get or

425
00:18:02,559 --> 00:18:04,080
set baggage items

426
00:18:04,080 --> 00:18:07,600
and then we can finish that span

427
00:18:07,600 --> 00:18:10,880
when we finish that span this pen

428
00:18:10,880 --> 00:18:14,400
will be automatically reported

429
00:18:14,400 --> 00:18:17,520
to uh to the jagger agents

430
00:18:17,520 --> 00:18:21,360
okay well

431
00:18:21,360 --> 00:18:25,200
as i said a child spam can easily find

432
00:18:25,200 --> 00:18:26,880
the parent spend

433
00:18:26,880 --> 00:18:30,240
in a thread local context but

434
00:18:30,240 --> 00:18:33,440
what happens what what causes the

435
00:18:33,440 --> 00:18:36,720
the context this pen context to

436
00:18:36,720 --> 00:18:39,600
propagate to another microservice that's

437
00:18:39,600 --> 00:18:41,200
running in another

438
00:18:41,200 --> 00:18:44,640
node with another language well that can

439
00:18:44,640 --> 00:18:47,679
be performed by using some

440
00:18:47,679 --> 00:18:50,480
special headers uh we can we can see

441
00:18:50,480 --> 00:18:51,039
here the

442
00:18:51,039 --> 00:18:55,200
b3 headers which is a uh

443
00:18:55,200 --> 00:18:59,440
a standard created by zipking

444
00:18:59,440 --> 00:19:02,000
they use this information so we we

445
00:19:02,000 --> 00:19:04,240
inform the trace id the parent span id

446
00:19:04,240 --> 00:19:08,000
this pen id and an assembled

447
00:19:08,000 --> 00:19:10,480
or we can use another format which is

448
00:19:10,480 --> 00:19:11,840
the format for uber

449
00:19:11,840 --> 00:19:14,559
uh uber headers they they have a header

450
00:19:14,559 --> 00:19:16,240
called uber trace id

451
00:19:16,240 --> 00:19:20,000
with a valor uh that uh

452
00:19:20,000 --> 00:19:23,440
informs the trace id they spam id

453
00:19:23,440 --> 00:19:26,559
the parents fan id and uh and all their

454
00:19:26,559 --> 00:19:28,320
flags as well

455
00:19:28,320 --> 00:19:31,520
there is a uh

456
00:19:31,520 --> 00:19:35,120
initiate initiative to create

457
00:19:35,120 --> 00:19:39,600
uh support at a w3c

458
00:19:39,600 --> 00:19:43,200
for standard headers for distributed

459
00:19:43,200 --> 00:19:44,320
tracing

460
00:19:44,320 --> 00:19:49,439
okay just as a matter of information

461
00:19:50,880 --> 00:19:54,960
okay now as a developer what we need to

462
00:19:54,960 --> 00:19:58,480
care about to uh use open trace and

463
00:19:58,480 --> 00:19:59,600
jagger

464
00:19:59,600 --> 00:20:04,559
if we are using with a micro profile

465
00:20:04,559 --> 00:20:07,760
every request to the jax rs server

466
00:20:07,760 --> 00:20:10,720
are traced automatically so we can look

467
00:20:10,720 --> 00:20:12,320
here at the source code

468
00:20:12,320 --> 00:20:16,960
for our microprofile application

469
00:20:16,960 --> 00:20:20,480
i don't have anything defines

470
00:20:20,480 --> 00:20:22,880
in my res resource to say that it needs

471
00:20:22,880 --> 00:20:24,720
to be traced

472
00:20:24,720 --> 00:20:28,000
but every method call in this case here

473
00:20:28,000 --> 00:20:29,280
i'm

474
00:20:29,280 --> 00:20:32,400
invoking a method inside my service i

475
00:20:32,400 --> 00:20:33,440
need to

476
00:20:33,440 --> 00:20:37,039
use this traced annotation to

477
00:20:37,039 --> 00:20:40,640
to make it trace it um traceable

478
00:20:40,640 --> 00:20:42,960
to propagate the context again if i'm

479
00:20:42,960 --> 00:20:44,480
using a jax is client

480
00:20:44,480 --> 00:20:46,960
or a microprofile rest client the

481
00:20:46,960 --> 00:20:48,320
requests on servers

482
00:20:48,320 --> 00:20:51,600
are priced automatically so here again

483
00:20:51,600 --> 00:20:54,640
if i'm performing

484
00:20:54,640 --> 00:20:59,280
a call to my microservice b

485
00:20:59,280 --> 00:21:03,440
all the client uh by using these

486
00:21:03,440 --> 00:21:07,120
uh annotation register client headers

487
00:21:07,120 --> 00:21:09,280
all the client all the headers that i

488
00:21:09,280 --> 00:21:10,640
received

489
00:21:10,640 --> 00:21:13,520
uh from the server will be propagated to

490
00:21:13,520 --> 00:21:13,840
the

491
00:21:13,840 --> 00:21:17,440
uh to this client and it will propagate

492
00:21:17,440 --> 00:21:20,559
also the context those headers uh

493
00:21:20,559 --> 00:21:23,760
to perform tracing of course there is a

494
00:21:23,760 --> 00:21:24,159
uh

495
00:21:24,159 --> 00:21:26,240
an issue if you are performing a single

496
00:21:26,240 --> 00:21:28,000
calls because

497
00:21:28,000 --> 00:21:31,280
uh we cannot have this pen

498
00:21:31,280 --> 00:21:33,120
in a thread local context because we are

499
00:21:33,120 --> 00:21:34,720
performing a single calls

500
00:21:34,720 --> 00:21:38,080
we need to do a trick

501
00:21:38,080 --> 00:21:45,840
and place let me open here

502
00:21:50,720 --> 00:21:55,600
i need to get the the server spam

503
00:21:55,600 --> 00:21:59,280
manually and inject it

504
00:21:59,280 --> 00:22:02,960
uh activate the server the service span

505
00:22:02,960 --> 00:22:06,559
inside my my task inside my async as a

506
00:22:06,559 --> 00:22:07,600
sync

507
00:22:07,600 --> 00:22:11,039
a synchronous call in this case inside

508
00:22:11,039 --> 00:22:14,880
my complete table future i

509
00:22:14,880 --> 00:22:18,559
start uh a new spam

510
00:22:18,559 --> 00:22:21,679
okay what about spring boot

511
00:22:21,679 --> 00:22:24,159
well spring boot does the same every

512
00:22:24,159 --> 00:22:26,559
rest controller endpoint will start a

513
00:22:26,559 --> 00:22:28,159
trace automatically

514
00:22:28,159 --> 00:22:31,600
but a spring does not does not have

515
00:22:31,600 --> 00:22:34,640
a traced annotation so in that case for

516
00:22:34,640 --> 00:22:37,280
example for a microservice b

517
00:22:37,280 --> 00:22:40,960
where we have

518
00:22:40,960 --> 00:22:42,880
let me reduce the font size so i cannot

519
00:22:42,880 --> 00:22:46,480
get it better

520
00:22:49,760 --> 00:22:55,440
here this method here

521
00:22:55,440 --> 00:22:58,960
since i don't have a traced annotation

522
00:22:58,960 --> 00:23:02,240
although there is a pull request

523
00:23:02,240 --> 00:23:06,840
to make it available so let me open it

524
00:23:06,840 --> 00:23:09,840
here

525
00:23:14,159 --> 00:23:16,559
oops

526
00:23:19,679 --> 00:23:21,840
in spring clouds they are they are

527
00:23:21,840 --> 00:23:24,240
planning to create a traced annotation

528
00:23:24,240 --> 00:23:28,320
and so on so because our time is short

529
00:23:28,320 --> 00:23:31,919
we can see um that methods

530
00:23:31,919 --> 00:23:35,200
method calls we need to use the tracer

531
00:23:35,200 --> 00:23:38,400
the open tracing api manually the

532
00:23:38,400 --> 00:23:40,080
context propagation

533
00:23:40,080 --> 00:23:43,120
for the rest template we need to uh

534
00:23:43,120 --> 00:23:46,000
define an interceptor a tracing rest

535
00:23:46,000 --> 00:23:47,360
template interceptor

536
00:23:47,360 --> 00:23:50,400
and i think you know a sync calls we

537
00:23:50,400 --> 00:23:50,720
need

538
00:23:50,720 --> 00:23:53,679
also check activate the tracer inside

539
00:23:53,679 --> 00:23:55,360
the async api

540
00:23:55,360 --> 00:23:58,320
for the database it's there are there is

541
00:23:58,320 --> 00:23:59,760
a java.js

542
00:23:59,760 --> 00:24:01,840
client where we just need to register

543
00:24:01,840 --> 00:24:03,200
the name of the driver

544
00:24:03,200 --> 00:24:06,320
the driver as a tracing driver and then

545
00:24:06,320 --> 00:24:09,360
place the tracing uh as a protocol

546
00:24:09,360 --> 00:24:12,320
in the connection string for kafka it's

547
00:24:12,320 --> 00:24:13,039
the same thing

548
00:24:13,039 --> 00:24:16,159
we have a java kafka client we just need

549
00:24:16,159 --> 00:24:17,360
to register

550
00:24:17,360 --> 00:24:20,400
the default kafka consumer factory and

551
00:24:20,400 --> 00:24:21,919
the folk

552
00:24:21,919 --> 00:24:24,720
the tracing producer factory as a

553
00:24:24,720 --> 00:24:26,559
decorator for a

554
00:24:26,559 --> 00:24:29,360
kafka producer factory and so on in that

555
00:24:29,360 --> 00:24:30,960
case it will make

556
00:24:30,960 --> 00:24:34,320
all the the requests to a kafka topic

557
00:24:34,320 --> 00:24:37,360
uh to be traceable okay and for node.js

558
00:24:37,360 --> 00:24:39,520
the same thing there is a

559
00:24:39,520 --> 00:24:43,039
uh express open tracing where we just

560
00:24:43,039 --> 00:24:44,720
need to register that in a

561
00:24:44,720 --> 00:24:47,919
express context we get the tracer and

562
00:24:47,919 --> 00:24:48,480
register

563
00:24:48,480 --> 00:24:51,760
it as a middleware of course we can

564
00:24:51,760 --> 00:24:54,240
configure the jagger service

565
00:24:54,240 --> 00:24:58,480
uh by giving some environment variables

566
00:24:58,480 --> 00:25:01,600
if we look here at the docker compose

567
00:25:01,600 --> 00:25:04,799
each service we can configure uh how it

568
00:25:04,799 --> 00:25:06,240
consumes the variable

569
00:25:06,240 --> 00:25:10,640
uh where jagger is located

570
00:25:11,279 --> 00:25:15,760
so because our time is short i will

571
00:25:15,760 --> 00:25:19,600
just let you know that this

572
00:25:19,600 --> 00:25:21,679
demo here you can run yourselves by

573
00:25:21,679 --> 00:25:22,720
going to this

574
00:25:22,720 --> 00:25:26,000
url right at github it's called tracing

575
00:25:26,000 --> 00:25:27,200
demo

576
00:25:27,200 --> 00:25:30,240
and now i will open for uh

577
00:25:30,240 --> 00:25:33,840
questions and answers all right

578
00:25:33,840 --> 00:25:36,000
thanks thank you rafael for this uh for

579
00:25:36,000 --> 00:25:36,880
this talk

580
00:25:36,880 --> 00:25:39,360
um somebody asked does this work with

581
00:25:39,360 --> 00:25:43,840
data docs

582
00:25:53,039 --> 00:25:56,000
me neither but what do you think is um a

583
00:25:56,000 --> 00:25:57,520
good source to get

584
00:25:57,520 --> 00:25:59,120
to get started with all this i mean

585
00:25:59,120 --> 00:26:00,720
there's a lot of information

586
00:26:00,720 --> 00:26:03,120
uh what you brought you presented i mean

587
00:26:03,120 --> 00:26:04,400
it's very valuable

588
00:26:04,400 --> 00:26:08,159
but how to get started ah cool uh

589
00:26:08,159 --> 00:26:12,159
in there is a nice tutorial

590
00:26:12,159 --> 00:26:14,400
for uh that covers different languages

591
00:26:14,400 --> 00:26:16,159
that let me start to share my screen

592
00:26:16,159 --> 00:26:19,360
real quick yeah we got a minute left or

593
00:26:19,360 --> 00:26:20,799
something so um

594
00:26:20,799 --> 00:26:24,080
okay uh here

595
00:26:24,080 --> 00:26:27,120
if we if we go to this url here

596
00:26:27,120 --> 00:26:31,200
bitly uh is slash cncf open tracing

597
00:26:31,200 --> 00:26:34,320
uh it's covered here hold on a second

598
00:26:34,320 --> 00:26:36,799
here at the bottom of the slide we can

599
00:26:36,799 --> 00:26:38,000
have access to the slide

600
00:26:38,000 --> 00:26:40,640
and there is one slide that i present uh

601
00:26:40,640 --> 00:26:41,520
excellent

602
00:26:41,520 --> 00:26:43,520
open tracing tutorials which is from

603
00:26:43,520 --> 00:26:44,880
this guy here that

604
00:26:44,880 --> 00:26:48,400
have uh c-sharp tutorial go tutorial

605
00:26:48,400 --> 00:26:49,679
java tutorial

606
00:26:49,679 --> 00:26:51,760
and if we go for example note that there

607
00:26:51,760 --> 00:26:53,679
are a lot of java developers here

608
00:26:53,679 --> 00:26:56,400
we can see lesson by lesson like a hello

609
00:26:56,400 --> 00:26:57,440
world like

610
00:26:57,440 --> 00:26:59,840
uh tracing functions tracing our pc

611
00:26:59,840 --> 00:27:00,559
requests

612
00:27:00,559 --> 00:27:02,799
the baggage and i asked her credit it's

613
00:27:02,799 --> 00:27:05,600
a valuable resource

614
00:27:05,600 --> 00:27:07,679
all right thank you i see my my camera

615
00:27:07,679 --> 00:27:08,960
is a little blurry but

616
00:27:08,960 --> 00:27:11,279
we're we are still online anyway i want

617
00:27:11,279 --> 00:27:13,520
to thank you for your great presentation

618
00:27:13,520 --> 00:27:16,880
and um we are moving directly along to

619
00:27:16,880 --> 00:27:17,200
the

620
00:27:17,200 --> 00:27:18,960
to the next person thank you for being

621
00:27:18,960 --> 00:27:20,240
here rafael

622
00:27:20,240 --> 00:27:22,399
and uh if you have any more questions

623
00:27:22,399 --> 00:27:24,559
please ping rafael on the slack because

624
00:27:24,559 --> 00:27:25,360
he's there

625
00:27:25,360 --> 00:27:28,480
and he is uh well well willing to

626
00:27:28,480 --> 00:27:30,320
to answer any questions you have about

627
00:27:30,320 --> 00:27:31,679
this topic

628
00:27:31,679 --> 00:27:35,840
thank you and uh

