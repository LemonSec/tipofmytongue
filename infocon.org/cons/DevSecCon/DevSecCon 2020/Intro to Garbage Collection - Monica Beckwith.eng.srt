1
00:00:00,000 --> 00:00:03,840
presentation here and then her webcam

2
00:00:03,840 --> 00:00:05,520
monica you might need to turn on your

3
00:00:05,520 --> 00:00:08,399
webcam there

4
00:00:09,599 --> 00:00:14,320
there we are all right take it away

5
00:00:15,360 --> 00:00:19,199
thank you man um and thank you josh

6
00:00:19,199 --> 00:00:21,119
it's an interesting um i just caught the

7
00:00:21,119 --> 00:00:23,039
tail end of it it's very interesting

8
00:00:23,039 --> 00:00:26,000
so thank you very much uh today i'm here

9
00:00:26,000 --> 00:00:28,160
to talk about garbage collection

10
00:00:28,160 --> 00:00:30,160
but it's going to be a little different

11
00:00:30,160 --> 00:00:32,558
talk because i'm going to introduce

12
00:00:32,558 --> 00:00:35,440
uh the native uh automatic memory

13
00:00:35,440 --> 00:00:36,640
management and then

14
00:00:36,640 --> 00:00:38,800
give a quick overview into open jdk

15
00:00:38,800 --> 00:00:40,160
collectors

16
00:00:40,160 --> 00:00:43,200
i'm monica beckwith and i am a jvm

17
00:00:43,200 --> 00:00:44,320
performance person

18
00:00:44,320 --> 00:00:47,039
at microsoft uh i've been working with

19
00:00:47,039 --> 00:00:48,079
the open jdk

20
00:00:48,079 --> 00:00:51,600
pretty much for all my life

21
00:00:51,600 --> 00:00:53,840
uh i was working with opengdk before it

22
00:00:53,840 --> 00:00:55,199
was open jdk

23
00:00:55,199 --> 00:00:58,000
so i should say the hotspot vm basically

24
00:00:58,000 --> 00:00:59,359
i've been working with it for all my

25
00:00:59,359 --> 00:01:00,239
life

26
00:01:00,239 --> 00:01:04,640
um and so let's get started

27
00:01:08,960 --> 00:01:11,680
so here's a quick agenda we are going to

28
00:01:11,680 --> 00:01:12,320
cover

29
00:01:12,320 --> 00:01:15,600
um just the basics uh today mostly and

30
00:01:15,600 --> 00:01:16,159
then

31
00:01:16,159 --> 00:01:18,880
like a quick overview into the gc

32
00:01:18,880 --> 00:01:20,240
algorithms

33
00:01:20,240 --> 00:01:23,600
um i want to talk about the need for gc

34
00:01:23,600 --> 00:01:26,640
and and set up why

35
00:01:26,640 --> 00:01:28,720
what is automatic memory management so

36
00:01:28,720 --> 00:01:29,680
the allocation

37
00:01:29,680 --> 00:01:32,320
and the reclamation part of it and then

38
00:01:32,320 --> 00:01:33,200
provide a few

39
00:01:33,200 --> 00:01:34,880
techniques that probably all of us are

40
00:01:34,880 --> 00:01:36,560
familiar with but just kind of

41
00:01:36,560 --> 00:01:40,000
put them uh in the right right flow

42
00:01:40,000 --> 00:01:43,280
order so to me

43
00:01:43,280 --> 00:01:46,000
gc is is memory management as i

44
00:01:46,000 --> 00:01:46,880
mentioned

45
00:01:46,880 --> 00:01:49,920
and memory management is not only about

46
00:01:49,920 --> 00:01:50,880
reclamation

47
00:01:50,880 --> 00:01:53,920
as in to get back heat space in in java

48
00:01:53,920 --> 00:01:55,520
heaps

49
00:01:55,520 --> 00:01:58,640
concepts but also it's about allocation

50
00:01:58,640 --> 00:02:00,320
so it's optimizing

51
00:02:00,320 --> 00:02:04,240
uh optimizing the space that you have so

52
00:02:04,240 --> 00:02:07,920
allocating and um and reclaiming kind of

53
00:02:07,920 --> 00:02:10,720
goes hand in hand

54
00:02:10,720 --> 00:02:14,160
so if if i were to ask you and if i give

55
00:02:14,160 --> 00:02:15,120
you some space

56
00:02:15,120 --> 00:02:17,920
um memory space and then you start

57
00:02:17,920 --> 00:02:19,040
allocating

58
00:02:19,040 --> 00:02:21,120
uh in that space your space would look

59
00:02:21,120 --> 00:02:23,440
like this and then your allocations will

60
00:02:23,440 --> 00:02:25,760
begin

61
00:02:25,760 --> 00:02:28,480
and eventually your space will get

62
00:02:28,480 --> 00:02:29,280
filled up

63
00:02:29,280 --> 00:02:31,920
right at this time we have we run out of

64
00:02:31,920 --> 00:02:32,879
space so

65
00:02:32,879 --> 00:02:34,720
naturally we want to make sure that we

66
00:02:34,720 --> 00:02:36,560
can reclaim things objects that we don't

67
00:02:36,560 --> 00:02:37,680
need anymore

68
00:02:37,680 --> 00:02:38,959
so we don't have to keep them around

69
00:02:38,959 --> 00:02:41,360
anymore so what we end up doing

70
00:02:41,360 --> 00:02:43,920
and because we all know about gc roots

71
00:02:43,920 --> 00:02:44,640
so we'll

72
00:02:44,640 --> 00:02:46,239
start from the root set okay so this

73
00:02:46,239 --> 00:02:48,560
would be like whatever thread local

74
00:02:48,560 --> 00:02:51,599
static variables so let's do that

75
00:02:51,599 --> 00:02:54,080
let's start from your root set and let's

76
00:02:54,080 --> 00:02:55,440
start

77
00:02:55,440 --> 00:02:57,599
tracing so we'll trace from the root set

78
00:02:57,599 --> 00:02:59,280
the object so that's why we're making

79
00:02:59,280 --> 00:03:00,159
our own

80
00:03:00,159 --> 00:03:03,360
live object graph right now and here are

81
00:03:03,360 --> 00:03:04,319
the objects

82
00:03:04,319 --> 00:03:07,519
that are pointed to by the root set

83
00:03:07,519 --> 00:03:10,959
okay they are highlighted here

84
00:03:10,959 --> 00:03:14,400
from that i try to trace objects um

85
00:03:14,400 --> 00:03:17,040
that are pointed to from that object so

86
00:03:17,040 --> 00:03:18,000
it's basically any

87
00:03:18,000 --> 00:03:20,720
incoming references to these objects are

88
00:03:20,720 --> 00:03:21,599
now

89
00:03:21,599 --> 00:03:24,640
all highlighted so eventually all the

90
00:03:24,640 --> 00:03:28,720
live objects i'm highlighting here and

91
00:03:28,720 --> 00:03:30,879
it seems to me because it's a manual

92
00:03:30,879 --> 00:03:33,280
process it seems to me that i'm done

93
00:03:33,280 --> 00:03:36,400
so i can reclaim the objects that i no

94
00:03:36,400 --> 00:03:37,440
longer need

95
00:03:37,440 --> 00:03:40,000
right so which means these objects right

96
00:03:40,000 --> 00:03:40,560
here

97
00:03:40,560 --> 00:03:44,080
in black okay

98
00:03:44,080 --> 00:03:48,159
so i go ahead and reclaim them

99
00:03:48,159 --> 00:03:50,400
but unfortunately when i was doing the

100
00:03:50,400 --> 00:03:51,680
reclamation

101
00:03:51,680 --> 00:03:54,239
i forgot to identify this one object

102
00:03:54,239 --> 00:03:54,879
which

103
00:03:54,879 --> 00:03:57,360
if because i have left it around this

104
00:03:57,360 --> 00:03:59,040
can lead to memory leak so if i don't

105
00:03:59,040 --> 00:04:00,080
reclaim it

106
00:04:00,080 --> 00:04:02,000
ever it's gonna eventually lead to

107
00:04:02,000 --> 00:04:03,680
memory leak and that's one of the

108
00:04:03,680 --> 00:04:05,760
reasons why you have memory leaks

109
00:04:05,760 --> 00:04:08,640
um in in your um you know even on your

110
00:04:08,640 --> 00:04:09,120
heat

111
00:04:09,120 --> 00:04:12,080
because you forget to um you forget that

112
00:04:12,080 --> 00:04:15,840
an object is kept live

113
00:04:15,840 --> 00:04:19,120
the other problem is the problem of

114
00:04:19,120 --> 00:04:20,560
dangling pointers

115
00:04:20,560 --> 00:04:24,560
so say for example i became overzealous

116
00:04:24,560 --> 00:04:26,639
and because i'm manually reclaiming i

117
00:04:26,639 --> 00:04:28,639
reclaim an object that's highlighted in

118
00:04:28,639 --> 00:04:29,919
red

119
00:04:29,919 --> 00:04:33,280
right there i reclaim that and now

120
00:04:33,280 --> 00:04:35,120
i have two dangling pointers right here

121
00:04:35,120 --> 00:04:36,479
so there were two pointers

122
00:04:36,479 --> 00:04:38,800
incoming pointers to that object but

123
00:04:38,800 --> 00:04:39,600
because i

124
00:04:39,600 --> 00:04:42,080
collected that object now we have two

125
00:04:42,080 --> 00:04:43,440
diagonal pointers

126
00:04:43,440 --> 00:04:46,720
so these are the drawbacks of manual

127
00:04:46,720 --> 00:04:50,560
reclamation so the

128
00:04:50,560 --> 00:04:53,280
so the suggestion is to of course go

129
00:04:53,280 --> 00:04:54,479
with

130
00:04:54,479 --> 00:04:58,080
with automatic management uh a couple of

131
00:04:58,080 --> 00:05:00,880
um examples that i'd like to provide of

132
00:05:00,880 --> 00:05:02,560
automatic memory management is

133
00:05:02,560 --> 00:05:04,240
sometimes one of the simplest form is

134
00:05:04,240 --> 00:05:06,320
the stack based allocation

135
00:05:06,320 --> 00:05:09,120
so you do push and pop and then most of

136
00:05:09,120 --> 00:05:11,360
these issues will be taken care of there

137
00:05:11,360 --> 00:05:13,520
uh for example we have the java bytecode

138
00:05:13,520 --> 00:05:15,280
interpreter so it's basically just a

139
00:05:15,280 --> 00:05:16,080
stack

140
00:05:16,080 --> 00:05:18,000
right push pop push button that's all

141
00:05:18,000 --> 00:05:19,919
you do with that

142
00:05:19,919 --> 00:05:21,520
then you get a little more sophisticated

143
00:05:21,520 --> 00:05:22,880
than you do something called hybrid

144
00:05:22,880 --> 00:05:24,800
allocation

145
00:05:24,800 --> 00:05:27,120
in that case by hybrid i mean you

146
00:05:27,120 --> 00:05:28,560
basically combine

147
00:05:28,560 --> 00:05:30,479
region based allocations people also

148
00:05:30,479 --> 00:05:31,680
known as

149
00:05:31,680 --> 00:05:34,800
call this as arena allocators

150
00:05:34,800 --> 00:05:38,320
in open jdk lingo we call it the t labs

151
00:05:38,320 --> 00:05:41,199
the thread local allocation buffers

152
00:05:41,199 --> 00:05:41,919
basically

153
00:05:41,919 --> 00:05:44,560
the concept is that you allocations are

154
00:05:44,560 --> 00:05:45,759
region based

155
00:05:45,759 --> 00:05:49,120
and then you combine that with

156
00:05:49,120 --> 00:05:51,440
reference counting or a tracing garbage

157
00:05:51,440 --> 00:05:52,960
collector which is what open jdk

158
00:05:52,960 --> 00:05:54,000
collectors are

159
00:05:54,000 --> 00:05:56,160
so and there you have it you have

160
00:05:56,160 --> 00:05:58,400
automatic memory management okay

161
00:05:58,400 --> 00:06:01,280
so as i provided examples already open

162
00:06:01,280 --> 00:06:07,280
jdk garbage collectors use team lamps

163
00:06:07,280 --> 00:06:11,440
um i wanted to um provide um

164
00:06:11,440 --> 00:06:13,280
an overview of both reference counting

165
00:06:13,280 --> 00:06:15,600
and tracing but just to save time

166
00:06:15,600 --> 00:06:17,120
i'm just going to compare them side by

167
00:06:17,120 --> 00:06:18,720
side here so

168
00:06:18,720 --> 00:06:21,280
reference counting uh you would use it

169
00:06:21,280 --> 00:06:22,720
because it has the lowest

170
00:06:22,720 --> 00:06:26,080
overall footprint okay so

171
00:06:26,080 --> 00:06:28,160
uh it's also non-moving so one of the

172
00:06:28,160 --> 00:06:29,600
things that you have to know about open

173
00:06:29,600 --> 00:06:31,199
channel k collectors

174
00:06:31,199 --> 00:06:33,199
is that they are moving collectors so

175
00:06:33,199 --> 00:06:35,360
you move live object from

176
00:06:35,360 --> 00:06:38,160
from an area from area one to area two

177
00:06:38,160 --> 00:06:39,759
and that's basically the whole uh

178
00:06:39,759 --> 00:06:42,880
idea of reclamation so to speak okay and

179
00:06:42,880 --> 00:06:44,080
i will talk about moving

180
00:06:44,080 --> 00:06:47,440
uh collection shortly uh

181
00:06:47,440 --> 00:06:48,960
reference counting is not moving so

182
00:06:48,960 --> 00:06:50,560
basically you have uh

183
00:06:50,560 --> 00:06:53,199
any incoming references are um are held

184
00:06:53,199 --> 00:06:53,840
in the

185
00:06:53,840 --> 00:06:55,759
account so if you have five employment

186
00:06:55,759 --> 00:06:57,120
references so the count

187
00:06:57,120 --> 00:07:00,800
will be five for that object and then

188
00:07:00,800 --> 00:07:03,360
you decrement it once you references are

189
00:07:03,360 --> 00:07:04,080
gone

190
00:07:04,080 --> 00:07:07,199
so but there is a disadvantage to it

191
00:07:07,199 --> 00:07:09,840
which is that it needs um to be able to

192
00:07:09,840 --> 00:07:13,119
handle cyclic references

193
00:07:13,280 --> 00:07:14,479
you you would have seen reference

194
00:07:14,479 --> 00:07:16,319
counting algorithm employed in

195
00:07:16,319 --> 00:07:19,120
uh for androids before the art before

196
00:07:19,120 --> 00:07:21,280
android runtime right now it's kind of

197
00:07:21,280 --> 00:07:24,000
similar to cms but previous prior to

198
00:07:24,000 --> 00:07:25,440
that it was reference counting

199
00:07:25,440 --> 00:07:26,960
and they they knew how to handle

200
00:07:26,960 --> 00:07:29,680
particular references

201
00:07:29,680 --> 00:07:32,240
um on the flip side is the tracing

202
00:07:32,240 --> 00:07:33,039
collector

203
00:07:33,039 --> 00:07:35,440
and it of course has a higher footprint

204
00:07:35,440 --> 00:07:37,039
because you have to have um

205
00:07:37,039 --> 00:07:39,360
you know mark and all this and safety

206
00:07:39,360 --> 00:07:40,960
marking uh

207
00:07:40,960 --> 00:07:44,000
arrays and um sophisticated algorithms

208
00:07:44,000 --> 00:07:47,280
um also need data structures so um

209
00:07:47,280 --> 00:07:48,560
of course the footprint is a little bit

210
00:07:48,560 --> 00:07:51,199
higher um

211
00:07:51,199 --> 00:07:54,560
there is also what it provides you

212
00:07:54,560 --> 00:07:56,080
because you're tracing and then

213
00:07:56,080 --> 00:07:57,680
eventually you're moving it

214
00:07:57,680 --> 00:08:00,720
so it provides you a co-location uh of

215
00:08:00,720 --> 00:08:02,080
your of your object so

216
00:08:02,080 --> 00:08:05,199
objects that are uh live together are

217
00:08:05,199 --> 00:08:07,759
also co-located together so it's kind of

218
00:08:07,759 --> 00:08:10,800
it's good for your hardware caches

219
00:08:10,800 --> 00:08:13,280
and of course you don't need any space

220
00:08:13,280 --> 00:08:14,879
for uh

221
00:08:14,879 --> 00:08:16,720
for for counting references so you don't

222
00:08:16,720 --> 00:08:17,919
need that count

223
00:08:17,919 --> 00:08:22,240
uh field for uh for your objects

224
00:08:22,240 --> 00:08:24,240
so if i had to quickly summarize

225
00:08:24,240 --> 00:08:25,919
reference counting i'll call it the

226
00:08:25,919 --> 00:08:28,160
continuous tracker because it has to be

227
00:08:28,160 --> 00:08:31,199
on at all times because anytime you add

228
00:08:31,199 --> 00:08:32,240
or delete a

229
00:08:32,240 --> 00:08:34,719
reference then you have to increment and

230
00:08:34,719 --> 00:08:36,000
decrement the count

231
00:08:36,000 --> 00:08:39,200
right on the flip side for tracing

232
00:08:39,200 --> 00:08:42,000
it only it's only active when you need

233
00:08:42,000 --> 00:08:44,000
it to be active so basically either you

234
00:08:44,000 --> 00:08:45,519
run out of sheep space

235
00:08:45,519 --> 00:08:48,399
or whatever's you know the uh the

236
00:08:48,399 --> 00:08:49,920
generational space

237
00:08:49,920 --> 00:08:52,800
or when a threshold is crossed and i'll

238
00:08:52,800 --> 00:08:54,560
talk more about what that means

239
00:08:54,560 --> 00:08:56,240
because that is really important when we

240
00:08:56,240 --> 00:08:57,680
talk about uh

241
00:08:57,680 --> 00:09:01,839
garbage collection efficiency okay

242
00:09:03,200 --> 00:09:05,680
so now that we know why we need

243
00:09:05,680 --> 00:09:07,600
automatic memory management let's try to

244
00:09:07,600 --> 00:09:08,080
design

245
00:09:08,080 --> 00:09:11,279
one so to design an automatic

246
00:09:11,279 --> 00:09:13,920
memory management system uh there are a

247
00:09:13,920 --> 00:09:15,839
few basic considerations that we should

248
00:09:15,839 --> 00:09:16,399
all

249
00:09:16,399 --> 00:09:19,200
think about as i mentioned collection

250
00:09:19,200 --> 00:09:21,279
efficiency comes to mind first

251
00:09:21,279 --> 00:09:24,959
so basically sometimes it's prudent

252
00:09:24,959 --> 00:09:28,000
to just let the garbage be so

253
00:09:28,000 --> 00:09:31,920
um for example i want to be able

254
00:09:31,920 --> 00:09:35,040
to get done with my garbage collection

255
00:09:35,040 --> 00:09:38,320
work as quickly as possible so i can

256
00:09:38,320 --> 00:09:41,279
make way for the application threads if

257
00:09:41,279 --> 00:09:43,600
especially if i'm in a stop the world

258
00:09:43,600 --> 00:09:46,640
collector i want to get out of the way

259
00:09:46,640 --> 00:09:50,320
of the application trends an example of

260
00:09:50,320 --> 00:09:50,800
this

261
00:09:50,800 --> 00:09:53,279
is um is the incremental compaction and

262
00:09:53,279 --> 00:09:55,440
we've got in g1 gc which is the garbage

263
00:09:55,440 --> 00:09:57,040
first cartridge collector

264
00:09:57,040 --> 00:10:00,560
in open jdk and it's also known as the

265
00:10:00,560 --> 00:10:02,480
the incremental compaction phase is also

266
00:10:02,480 --> 00:10:04,160
known as mix collection

267
00:10:04,160 --> 00:10:07,519
where we only have a few old regions

268
00:10:07,519 --> 00:10:09,680
that we can include as a part of a

269
00:10:09,680 --> 00:10:10,560
collection cycle

270
00:10:10,560 --> 00:10:12,640
and if time permits i'll go into that as

271
00:10:12,640 --> 00:10:14,030
well

272
00:10:14,030 --> 00:10:15,279
[Music]

273
00:10:15,279 --> 00:10:18,320
the next consideration for designing a

274
00:10:18,320 --> 00:10:21,360
gc algorithm would be the performance

275
00:10:21,360 --> 00:10:22,720
trifecta

276
00:10:22,720 --> 00:10:24,959
which is basically responsiveness

277
00:10:24,959 --> 00:10:26,399
throughput and footprint

278
00:10:26,399 --> 00:10:29,839
right so usually you design gc's

279
00:10:29,839 --> 00:10:32,000
keeping you know favoring one of the

280
00:10:32,000 --> 00:10:32,959
three

281
00:10:32,959 --> 00:10:36,240
um maybe two at a time as well so for

282
00:10:36,240 --> 00:10:37,360
example

283
00:10:37,360 --> 00:10:39,360
the oldest collector that you were known

284
00:10:39,360 --> 00:10:41,760
in openshirt case the serial collector

285
00:10:41,760 --> 00:10:43,839
and that's designed for low footprint

286
00:10:43,839 --> 00:10:46,399
okay it's single threaded and

287
00:10:46,399 --> 00:10:48,880
then comes the parallel gc which has

288
00:10:48,880 --> 00:10:49,839
parallel

289
00:10:49,839 --> 00:10:53,440
worker threads and it's designed to

290
00:10:53,440 --> 00:10:56,480
do the gc work in a stop the world pause

291
00:10:56,480 --> 00:10:58,320
it get done as quickly as possible and

292
00:10:58,320 --> 00:10:59,680
get out of the way so

293
00:10:59,680 --> 00:11:02,399
it increases your throughput efficiency

294
00:11:02,399 --> 00:11:04,720
and then the rest are like

295
00:11:04,720 --> 00:11:07,440
balanced somewhere between the

296
00:11:07,440 --> 00:11:09,200
responsiveness and

297
00:11:09,200 --> 00:11:12,000
throughput metric

298
00:11:13,360 --> 00:11:16,399
what other things would you consider i

299
00:11:16,399 --> 00:11:17,760
think

300
00:11:17,760 --> 00:11:20,560
then once you go past the basic you want

301
00:11:20,560 --> 00:11:22,720
to be more sophisticated so

302
00:11:22,720 --> 00:11:24,640
you want to take into consideration the

303
00:11:24,640 --> 00:11:27,200
generational hypothesis which is like

304
00:11:27,200 --> 00:11:30,480
most object style so you would find

305
00:11:30,480 --> 00:11:31,920
generational collectors

306
00:11:31,920 --> 00:11:35,440
in in parallel gc g1 gc

307
00:11:35,440 --> 00:11:38,000
so basically all open gtk gc's that you

308
00:11:38,000 --> 00:11:38,640
may know of

309
00:11:38,640 --> 00:11:40,839
are generational except for zgc and

310
00:11:40,839 --> 00:11:43,839
shenandoah

311
00:11:44,640 --> 00:11:46,000
the other thing that you want to make

312
00:11:46,000 --> 00:11:48,320
sure is that you you have a way

313
00:11:48,320 --> 00:11:52,399
to save out objects that are either

314
00:11:52,399 --> 00:11:55,360
not going to live long or are not going

315
00:11:55,360 --> 00:11:56,959
to be a part of your long-lived

316
00:11:56,959 --> 00:11:57,680
transients

317
00:11:57,680 --> 00:12:00,240
so that's called something like that

318
00:12:00,240 --> 00:12:01,200
that kind of notion

319
00:12:01,200 --> 00:12:04,240
is called the age threshold and

320
00:12:04,240 --> 00:12:06,560
that helps you promote only the

321
00:12:06,560 --> 00:12:08,160
long-lived object

322
00:12:08,160 --> 00:12:09,680
sometimes you want to leave the

323
00:12:09,680 --> 00:12:12,160
transients a long limb transient around

324
00:12:12,160 --> 00:12:14,800
and for that age threshold also matters

325
00:12:14,800 --> 00:12:16,320
because it

326
00:12:16,320 --> 00:12:19,519
these transients will be aged uh and

327
00:12:19,519 --> 00:12:22,160
kept around for longer if you uh have

328
00:12:22,160 --> 00:12:25,839
your thresholds adjusted properly

329
00:12:28,800 --> 00:12:31,519
and yeah so most of the gcs that are

330
00:12:31,519 --> 00:12:33,519
generational also understand the age

331
00:12:33,519 --> 00:12:36,480
threshold policy

332
00:12:36,880 --> 00:12:39,360
now um quickly diving into a little bit

333
00:12:39,360 --> 00:12:42,240
more details of open jelly key

334
00:12:42,240 --> 00:12:44,800
collectors

335
00:12:46,959 --> 00:12:50,399
so here we have um heap layout and

336
00:12:50,399 --> 00:12:53,839
regions and generations so

337
00:12:53,839 --> 00:12:56,480
if you know about the the java heap

338
00:12:56,480 --> 00:12:56,959
space

339
00:12:56,959 --> 00:12:58,560
it looks like this it's a contiguous

340
00:12:58,560 --> 00:13:01,040
heap space and then

341
00:13:01,040 --> 00:13:04,880
uh for g1 gc and ship mandela and

342
00:13:04,880 --> 00:13:06,880
every other gc that the newer gcses that

343
00:13:06,880 --> 00:13:08,480
you know of they're called as

344
00:13:08,480 --> 00:13:10,240
regionalized gcs

345
00:13:10,240 --> 00:13:12,399
and they would there's names such

346
00:13:12,399 --> 00:13:14,079
because their heap is divided into

347
00:13:14,079 --> 00:13:15,680
regions

348
00:13:15,680 --> 00:13:19,360
okay and um some of some of the times

349
00:13:19,360 --> 00:13:21,360
you would also have here the concept of

350
00:13:21,360 --> 00:13:23,200
generational gc that i mentioned

351
00:13:23,200 --> 00:13:25,120
for example serial parallel and of

352
00:13:25,120 --> 00:13:26,240
course g1

353
00:13:26,240 --> 00:13:28,560
uh you would it will basically means

354
00:13:28,560 --> 00:13:30,320
that you have two generations

355
00:13:30,320 --> 00:13:31,920
one is called the young generation and

356
00:13:31,920 --> 00:13:34,320
the other is called the old generation

357
00:13:34,320 --> 00:13:36,800
so if i if you talk about the latest the

358
00:13:36,800 --> 00:13:38,480
default as well as the

359
00:13:38,480 --> 00:13:41,279
the the two new collectors in open jdk

360
00:13:41,279 --> 00:13:43,600
as in cgc and shenandoah

361
00:13:43,600 --> 00:13:46,399
um you you would find that cgc engine

362
00:13:46,399 --> 00:13:48,399
and door are non-regionalized

363
00:13:48,399 --> 00:13:51,120
non-sorry non-generational but they are

364
00:13:51,120 --> 00:13:52,320
regionalized

365
00:13:52,320 --> 00:13:56,399
as and g1 is uh regionalized as well as

366
00:13:56,399 --> 00:13:57,199
generational

367
00:13:57,199 --> 00:14:02,959
as you can see here

368
00:14:02,959 --> 00:14:05,839
so now going back to the concept so i'm

369
00:14:05,839 --> 00:14:06,720
gonna

370
00:14:06,720 --> 00:14:10,240
try to keep this with it within g1

371
00:14:10,240 --> 00:14:13,199
cgc and shenandoah so because we have

372
00:14:13,199 --> 00:14:14,639
the generational concept and the

373
00:14:14,639 --> 00:14:16,240
non-generational concept

374
00:14:16,240 --> 00:14:19,199
i'm just going to simplify it to the

375
00:14:19,199 --> 00:14:20,079
basic

376
00:14:20,079 --> 00:14:24,480
form of collection which is copying so

377
00:14:24,480 --> 00:14:28,800
for for all the collectors in openglk

378
00:14:28,800 --> 00:14:30,800
we have when we are reclaiming we were

379
00:14:30,800 --> 00:14:31,920
claiming by

380
00:14:31,920 --> 00:14:34,880
by way of copying live objects okay and

381
00:14:34,880 --> 00:14:36,480
so we're moving them from one place to

382
00:14:36,480 --> 00:14:37,680
the other

383
00:14:37,680 --> 00:14:40,480
so there are many terminologies used for

384
00:14:40,480 --> 00:14:42,399
being collected a compacting collector

385
00:14:42,399 --> 00:14:44,000
or evacuating collector

386
00:14:44,000 --> 00:14:47,199
or evacuation phase and

387
00:14:47,199 --> 00:14:49,440
it basically means that the same heap

388
00:14:49,440 --> 00:14:50,959
that you have

389
00:14:50,959 --> 00:14:55,120
is divided into from space into space

390
00:14:55,120 --> 00:14:58,560
okay and as you allocate and we

391
00:14:58,560 --> 00:15:00,160
talked about this when i was talking

392
00:15:00,160 --> 00:15:02,000
about the manual process right

393
00:15:02,000 --> 00:15:04,079
so you're allocating into the front

394
00:15:04,079 --> 00:15:06,639
space and eventually the from space

395
00:15:06,639 --> 00:15:09,839
uh gets filled and then of course

396
00:15:09,839 --> 00:15:11,440
because this is an automatic memory

397
00:15:11,440 --> 00:15:12,959
management algorithm

398
00:15:12,959 --> 00:15:14,880
you start from the gc roots which are

399
00:15:14,880 --> 00:15:17,199
your static variables thread stack

400
00:15:17,199 --> 00:15:20,560
and ej references and then you start

401
00:15:20,560 --> 00:15:21,680
marking

402
00:15:21,680 --> 00:15:26,079
you know live objects and eventually

403
00:15:26,079 --> 00:15:28,399
you identify all the live objects and

404
00:15:28,399 --> 00:15:29,759
then you move

405
00:15:29,759 --> 00:15:32,880
or copy the live objects from the front

406
00:15:32,880 --> 00:15:33,440
space

407
00:15:33,440 --> 00:15:35,920
into the two space such that you can

408
00:15:35,920 --> 00:15:36,800
reclaim

409
00:15:36,800 --> 00:15:40,000
the front space so now after reclaiming

410
00:15:40,000 --> 00:15:42,880
the front space you literally swap the

411
00:15:42,880 --> 00:15:44,079
front and two spaces

412
00:15:44,079 --> 00:15:46,720
so now your two space becomes the front

413
00:15:46,720 --> 00:15:47,680
space

414
00:15:47,680 --> 00:15:49,519
and then your from space becomes the two

415
00:15:49,519 --> 00:15:51,279
space so all allocations

416
00:15:51,279 --> 00:15:54,079
will happen now in the formerly two

417
00:15:54,079 --> 00:15:54,639
space

418
00:15:54,639 --> 00:15:56,639
which is now the front space shown in

419
00:15:56,639 --> 00:15:58,560
green and the alec

420
00:15:58,560 --> 00:16:01,199
and then the promotions or when you're

421
00:16:01,199 --> 00:16:02,959
moving out aging objects

422
00:16:02,959 --> 00:16:06,240
that will happen into the two space

423
00:16:06,240 --> 00:16:08,560
on the left and that it keeps on moving

424
00:16:08,560 --> 00:16:09,519
back and forth

425
00:16:09,519 --> 00:16:12,800
okay um and that's how you achieve aging

426
00:16:12,800 --> 00:16:15,040
as well

427
00:16:15,040 --> 00:16:16,880
another concept that i wanted to

428
00:16:16,880 --> 00:16:18,720
introduce as i mentioned all

429
00:16:18,720 --> 00:16:21,120
the the newer garbage collectors are

430
00:16:21,120 --> 00:16:22,320
regionalized

431
00:16:22,320 --> 00:16:26,880
so let's talk what that means

432
00:16:26,959 --> 00:16:30,320
so at any given time

433
00:16:30,320 --> 00:16:32,079
the entire heap is just a bunch of

434
00:16:32,079 --> 00:16:33,839
regions and

435
00:16:33,839 --> 00:16:35,680
these bunch of regions should would be

436
00:16:35,680 --> 00:16:37,600
either occupied or free

437
00:16:37,600 --> 00:16:41,120
okay so for example here in green

438
00:16:41,120 --> 00:16:44,480
we have occupied regions and

439
00:16:44,480 --> 00:16:47,279
and then on the right we had unoccupied

440
00:16:47,279 --> 00:16:48,320
regions

441
00:16:48,320 --> 00:16:51,360
so uh let's see how an active

442
00:16:51,360 --> 00:16:54,959
uh heat may look like so we have these

443
00:16:54,959 --> 00:16:57,360
darker regions that are occupied and the

444
00:16:57,360 --> 00:16:59,120
rest are not occupied

445
00:16:59,120 --> 00:17:02,240
and and basically the ones

446
00:17:02,240 --> 00:17:04,559
that are not occupied are called free

447
00:17:04,559 --> 00:17:05,359
regions

448
00:17:05,359 --> 00:17:07,599
and there is a list maintained by the

449
00:17:07,599 --> 00:17:08,880
garbage collector

450
00:17:08,880 --> 00:17:11,119
and this list is basically tells you all

451
00:17:11,119 --> 00:17:13,439
the free regions that are available

452
00:17:13,439 --> 00:17:18,480
uh for uh for allocations or promotions

453
00:17:18,480 --> 00:17:21,119
so when you have a generational he like

454
00:17:21,119 --> 00:17:22,400
g1

455
00:17:22,400 --> 00:17:24,640
these occupied regions could be either

456
00:17:24,640 --> 00:17:26,480
from the young generation or it could be

457
00:17:26,480 --> 00:17:28,240
from the old generation

458
00:17:28,240 --> 00:17:30,640
jihan also has the concept of humongous

459
00:17:30,640 --> 00:17:31,360
objects

460
00:17:31,360 --> 00:17:33,440
so this these could be also humongous

461
00:17:33,440 --> 00:17:35,520
regions okay

462
00:17:35,520 --> 00:17:38,960
um let's look at um

463
00:17:38,960 --> 00:17:42,000
so now that we know that the heap is

464
00:17:42,000 --> 00:17:43,520
basically a bunch of regions

465
00:17:43,520 --> 00:17:46,640
and we have either free or occupied

466
00:17:46,640 --> 00:17:47,440
regions

467
00:17:47,440 --> 00:17:50,559
let's look at how uh and when

468
00:17:50,559 --> 00:17:54,320
we choose to collect uh as in reclaim

469
00:17:54,320 --> 00:17:57,440
heap space okay

470
00:17:57,440 --> 00:18:00,320
so again going back to the previous

471
00:18:00,320 --> 00:18:01,919
examples of the dark regions

472
00:18:01,919 --> 00:18:05,039
let's say that we have we are able to

473
00:18:05,039 --> 00:18:08,240
say that the highlighted objects are

474
00:18:08,240 --> 00:18:10,000
live and then the ones that are not

475
00:18:10,000 --> 00:18:13,600
highlighted are not live anymore

476
00:18:13,600 --> 00:18:16,320
uh so we go ahead and identify the

477
00:18:16,320 --> 00:18:18,080
regions that are full of garbage

478
00:18:18,080 --> 00:18:21,120
so we know that the highest return is

479
00:18:21,120 --> 00:18:22,720
are these regions because we can

480
00:18:22,720 --> 00:18:24,559
immediately reclaim that space

481
00:18:24,559 --> 00:18:26,880
because uh we really literally have to

482
00:18:26,880 --> 00:18:28,640
do nothing so the

483
00:18:28,640 --> 00:18:32,000
major work is is moving objects

484
00:18:32,000 --> 00:18:34,320
live objects from from region to the two

485
00:18:34,320 --> 00:18:35,440
region right

486
00:18:35,440 --> 00:18:37,840
so for objects that are dead we really

487
00:18:37,840 --> 00:18:39,360
don't have to do anything except for

488
00:18:39,360 --> 00:18:41,440
return them back to the free list right

489
00:18:41,440 --> 00:18:44,240
so that's easiest so let's do that first

490
00:18:44,240 --> 00:18:45,679
so now we have reclaimed that

491
00:18:45,679 --> 00:18:48,160
uh region those two regions the next

492
00:18:48,160 --> 00:18:49,520
thing we would find

493
00:18:49,520 --> 00:18:53,280
um are that these are the two regions

494
00:18:53,280 --> 00:18:55,679
that are have been identified to have

495
00:18:55,679 --> 00:18:57,039
the most garbage

496
00:18:57,039 --> 00:18:58,640
right they only have one live object in

497
00:18:58,640 --> 00:19:00,080
this particular case

498
00:19:00,080 --> 00:19:03,440
so let's uh let's go list them together

499
00:19:03,440 --> 00:19:04,880
and there you go so we have reclaimed

500
00:19:04,880 --> 00:19:06,640
two regions and we have

501
00:19:06,640 --> 00:19:09,039
started adding to a new region right

502
00:19:09,039 --> 00:19:10,080
there

503
00:19:10,080 --> 00:19:13,520
and so on and so forth so basically

504
00:19:13,520 --> 00:19:16,720
the collection priority is to reclaim

505
00:19:16,720 --> 00:19:18,640
regions with the most garbage and

506
00:19:18,640 --> 00:19:21,120
and g1 actually gets the name from that

507
00:19:21,120 --> 00:19:22,320
garbage first

508
00:19:22,320 --> 00:19:24,080
so let's get the regions which have the

509
00:19:24,080 --> 00:19:25,520
most garbage and

510
00:19:25,520 --> 00:19:27,360
and that's the first thing they can do

511
00:19:27,360 --> 00:19:30,160
that's quick easy peasy and done

512
00:19:30,160 --> 00:19:34,480
right the next thing um we want to be

513
00:19:34,480 --> 00:19:37,360
able to do is be able to identify

514
00:19:37,360 --> 00:19:39,360
regions that we want to collect

515
00:19:39,360 --> 00:19:41,760
before we actually go collect them right

516
00:19:41,760 --> 00:19:43,200
so this is done

517
00:19:43,200 --> 00:19:45,600
in something known as a collection set

518
00:19:45,600 --> 00:19:46,880
so

519
00:19:46,880 --> 00:19:48,720
any of the regions that we have added

520
00:19:48,720 --> 00:19:50,400
defined to be a part of the collection

521
00:19:50,400 --> 00:19:51,760
cycle

522
00:19:51,760 --> 00:19:55,280
be it a young collection cycle or

523
00:19:55,280 --> 00:19:58,000
an old or mixed collection cycle for a

524
00:19:58,000 --> 00:19:59,440
generational collector

525
00:19:59,440 --> 00:20:01,520
then those regions are a part of the

526
00:20:01,520 --> 00:20:02,559
collection set

527
00:20:02,559 --> 00:20:05,760
okay so

528
00:20:05,760 --> 00:20:09,120
in in g1's case and in even many of the

529
00:20:09,120 --> 00:20:10,960
newer collectors you have

530
00:20:10,960 --> 00:20:13,360
threshold-based collection

531
00:20:13,360 --> 00:20:16,080
so the thresholds are basically set on

532
00:20:16,080 --> 00:20:18,080
how expensive a region

533
00:20:18,080 --> 00:20:19,840
can be so if it's too expensive to

534
00:20:19,840 --> 00:20:21,520
collect a region we will

535
00:20:21,520 --> 00:20:24,400
leave it out of a collection set if we

536
00:20:24,400 --> 00:20:25,840
have already reached uh

537
00:20:25,840 --> 00:20:29,440
our time-bound thresholds then then

538
00:20:29,440 --> 00:20:31,200
we will leave those regions leave the

539
00:20:31,200 --> 00:20:32,640
remaining regions out of the collection

540
00:20:32,640 --> 00:20:33,200
zone

541
00:20:33,200 --> 00:20:36,000
so usually the regions are arranged

542
00:20:36,000 --> 00:20:36,960
based on

543
00:20:36,960 --> 00:20:40,480
um their collection efficiency okay

544
00:20:40,480 --> 00:20:42,320
and this is something that i had talked

545
00:20:42,320 --> 00:20:44,720
about earlier when i was talking about

546
00:20:44,720 --> 00:20:46,400
uh you know what are the considerations

547
00:20:46,400 --> 00:20:48,159
that they want to have for automatic

548
00:20:48,159 --> 00:20:49,600
memory management

549
00:20:49,600 --> 00:20:52,159
so efficiency is one of them so i give

550
00:20:52,159 --> 00:20:53,840
the example of incremental collection

551
00:20:53,840 --> 00:20:54,799
which is also known as

552
00:20:54,799 --> 00:20:56,799
incremental compaction or partial

553
00:20:56,799 --> 00:20:58,880
compaction or mixed collection

554
00:20:58,880 --> 00:21:02,000
so it's all it's all the same it just

555
00:21:02,000 --> 00:21:05,520
means that you are not going to collect

556
00:21:05,520 --> 00:21:07,600
the entirety of a generation but you

557
00:21:07,600 --> 00:21:09,600
will collect it incrementally so that

558
00:21:09,600 --> 00:21:10,720
you still

559
00:21:10,720 --> 00:21:13,760
respect your past-time goals okay

560
00:21:13,760 --> 00:21:17,200
um and the way we can do it

561
00:21:17,200 --> 00:21:18,799
is basically having these thresholds

562
00:21:18,799 --> 00:21:22,080
that i've mentioned okay

563
00:21:22,080 --> 00:21:25,600
so after you reach these um thresholds

564
00:21:25,600 --> 00:21:28,400
you stop collection and even if there is

565
00:21:28,400 --> 00:21:30,640
a bunch of garbage that's to be left

566
00:21:30,640 --> 00:21:33,120
that it will be left behind and that's

567
00:21:33,120 --> 00:21:34,640
brings us back to the first

568
00:21:34,640 --> 00:21:36,640
the consideration of you know let some

569
00:21:36,640 --> 00:21:38,080
garbage be

570
00:21:38,080 --> 00:21:42,720
okay um the

571
00:21:42,720 --> 00:21:44,640
the best part of it and then you will

572
00:21:44,640 --> 00:21:46,000
see that mostly with

573
00:21:46,000 --> 00:21:48,320
um with the newer collectors the low

574
00:21:48,320 --> 00:21:50,480
latency collectors that we have zgc and

575
00:21:50,480 --> 00:21:52,080
shenandoah

576
00:21:52,080 --> 00:21:55,360
that any any of this collection the

577
00:21:55,360 --> 00:21:56,960
movement of live objects from the from

578
00:21:56,960 --> 00:21:59,200
space to the two space it doesn't have

579
00:21:59,200 --> 00:22:00,559
to be stop the world

580
00:22:00,559 --> 00:22:03,200
so you can do it concurrently basically

581
00:22:03,200 --> 00:22:05,120
along with your mutated threads which is

582
00:22:05,120 --> 00:22:06,480
muted threads on your application

583
00:22:06,480 --> 00:22:07,120
threads

584
00:22:07,120 --> 00:22:08,799
so along with your application threads

585
00:22:08,799 --> 00:22:10,960
you can actually do this collection

586
00:22:10,960 --> 00:22:14,159
and um and and

587
00:22:14,159 --> 00:22:17,440
what that gives you is that you don't

588
00:22:17,440 --> 00:22:19,360
the the application feds don't have to

589
00:22:19,360 --> 00:22:20,880
stop uh

590
00:22:20,880 --> 00:22:24,000
while the gc is doing its work but also

591
00:22:24,000 --> 00:22:25,200
it gives you a little more

592
00:22:25,200 --> 00:22:28,400
complexity because now you are literally

593
00:22:28,400 --> 00:22:30,640
uh moving objects when your mutators are

594
00:22:30,640 --> 00:22:32,559
trying to access them too so

595
00:22:32,559 --> 00:22:36,080
you have to appreciate the um the pros

596
00:22:36,080 --> 00:22:37,760
and cons you know you have to weigh both

597
00:22:37,760 --> 00:22:39,039
and see which collection

598
00:22:39,039 --> 00:22:41,919
which collector uh is is a better it's

599
00:22:41,919 --> 00:22:44,400
better suited for your application

600
00:22:44,400 --> 00:22:45,679
but the good news is that it doesn't

601
00:22:45,679 --> 00:22:47,600
have to be stopped the wrong collection

602
00:22:47,600 --> 00:22:49,919
it doesn't have to be start the world

603
00:22:49,919 --> 00:22:52,960
okay so

604
00:22:52,960 --> 00:22:54,960
quick introduction here and that would

605
00:22:54,960 --> 00:22:56,640
this would probably be my last last

606
00:22:56,640 --> 00:22:57,760
slide

607
00:22:57,760 --> 00:23:00,080
what i'm going to do is quickly sort the

608
00:23:00,080 --> 00:23:00,880
three new

609
00:23:00,880 --> 00:23:04,320
collectors uh based on regionalized

610
00:23:04,320 --> 00:23:07,600
generational compaction uh algorithm

611
00:23:07,600 --> 00:23:09,919
target pass times or and if the

612
00:23:09,919 --> 00:23:11,440
confident marking if the

613
00:23:11,440 --> 00:23:14,080
marking algorithm is content or not so

614
00:23:14,080 --> 00:23:15,120
g1gc

615
00:23:15,120 --> 00:23:18,080
is yes to pretty much every everything

616
00:23:18,080 --> 00:23:20,480
but the compaction is stop the world

617
00:23:20,480 --> 00:23:23,280
basically gets the metered threads to a

618
00:23:23,280 --> 00:23:25,120
stopping point and collects

619
00:23:25,120 --> 00:23:28,159
the live objects um and moves the

620
00:23:28,159 --> 00:23:29,840
objects from the front space to the two

621
00:23:29,840 --> 00:23:32,080
space the target pass time for

622
00:23:32,080 --> 00:23:35,039
g1gc is 200 milliseconds so you see that

623
00:23:35,039 --> 00:23:36,000
it's straddling the

624
00:23:36,000 --> 00:23:39,120
transition the boundaries where it's

625
00:23:39,120 --> 00:23:40,559
designing itself for

626
00:23:40,559 --> 00:23:41,760
throughput efficiency because of the

627
00:23:41,760 --> 00:23:43,760
stop the world uh

628
00:23:43,760 --> 00:23:46,400
uh pauses as well as it's trying to like

629
00:23:46,400 --> 00:23:47,360
have um

630
00:23:47,360 --> 00:23:51,279
kind of soft real time uh goal for the

631
00:23:51,279 --> 00:23:54,320
past times shenandoah nzgc

632
00:23:54,320 --> 00:23:57,760
i'll put them both together so that

633
00:23:57,760 --> 00:24:01,120
we have enough time for q a um

634
00:24:01,120 --> 00:24:03,520
they both are regionalized they're both

635
00:24:03,520 --> 00:24:04,240
are right now

636
00:24:04,240 --> 00:24:06,880
not generational and they both do

637
00:24:06,880 --> 00:24:08,080
compaction

638
00:24:08,080 --> 00:24:11,679
and the compactions are concurrently

639
00:24:11,679 --> 00:24:12,720
done

640
00:24:12,720 --> 00:24:15,440
along with your application threads they

641
00:24:15,440 --> 00:24:16,640
both are trying to

642
00:24:16,640 --> 00:24:19,120
meet the 10 milliseconds past temple

643
00:24:19,120 --> 00:24:21,200
which is pretty aggressive

644
00:24:21,200 --> 00:24:23,760
and which is why they are considered low

645
00:24:23,760 --> 00:24:25,440
latency collectors

646
00:24:25,440 --> 00:24:28,880
and um just like g1 gc

647
00:24:28,880 --> 00:24:32,559
um shenandoah also employs the snapshot

648
00:24:32,559 --> 00:24:34,880
at the beginning marking algorithm

649
00:24:34,880 --> 00:24:36,799
and whereas concurrent marking algorithm

650
00:24:36,799 --> 00:24:38,000
for zgc is

651
00:24:38,000 --> 00:24:40,480
right i i don't have time to go into the

652
00:24:40,480 --> 00:24:42,400
details but definitely still read more

653
00:24:42,400 --> 00:24:43,360
about it

654
00:24:43,360 --> 00:24:46,799
um i may have put some links here

655
00:24:46,799 --> 00:24:50,400
oops um well maybe towards the end

656
00:24:50,400 --> 00:24:53,360
sorry about that these are just overflow

657
00:24:53,360 --> 00:24:54,400
slides that

658
00:24:54,400 --> 00:24:56,320
i wouldn't have time to collect uh time

659
00:24:56,320 --> 00:24:57,520
to

660
00:24:57,520 --> 00:25:00,240
get to today but i i will send out the

661
00:25:00,240 --> 00:25:01,679
links if i don't have it here

662
00:25:01,679 --> 00:25:04,880
uh up there you go yeah

663
00:25:04,880 --> 00:25:07,840
there you go so some of the links are

664
00:25:07,840 --> 00:25:09,440
here i'll send out more if you have any

665
00:25:09,440 --> 00:25:11,840
questions i'll take them now

666
00:25:11,840 --> 00:25:14,640
all right thank you monica so i'm

667
00:25:14,640 --> 00:25:15,440
looking

668
00:25:15,440 --> 00:25:18,080
in uh slack i don't see any in there if

669
00:25:18,080 --> 00:25:21,918
you have some questions please post them

670
00:25:26,840 --> 00:25:28,000
now

671
00:25:28,000 --> 00:25:30,720
ask a question okay what's your favorite

672
00:25:30,720 --> 00:25:34,000
part about being quarantined

673
00:25:35,279 --> 00:25:38,960
i don't know i i i'm

674
00:25:39,520 --> 00:25:42,799
since 2007 i've been remote workers

675
00:25:42,799 --> 00:25:45,279
like on and off so i've always been this

676
00:25:45,279 --> 00:25:47,279
the remote part is my favorite part

677
00:25:47,279 --> 00:25:50,400
but it's always been my favorite part of

678
00:25:50,400 --> 00:25:53,679
my job um so i would say just being with

679
00:25:53,679 --> 00:25:55,440
family

680
00:25:55,440 --> 00:25:58,720
right yeah trying to understand

681
00:25:58,720 --> 00:26:01,039
uh and work together with them which is

682
00:26:01,039 --> 00:26:02,559
interesting because usually

683
00:26:02,559 --> 00:26:04,799
i had the whole network to myself and

684
00:26:04,799 --> 00:26:06,559
everything to myself

685
00:26:06,559 --> 00:26:09,840
but now i have to share with them so

686
00:26:09,840 --> 00:26:10,799
right

687
00:26:10,799 --> 00:26:12,480
during my talk today i had to tell

688
00:26:12,480 --> 00:26:14,400
everyone everyone get off the internet

689
00:26:14,400 --> 00:26:17,200
for 30 minutes

690
00:26:17,760 --> 00:26:19,679
yeah it's like even my dogs and stuff

691
00:26:19,679 --> 00:26:20,880
like that i have like

692
00:26:20,880 --> 00:26:22,960
locked myself in here and the dogs are

693
00:26:22,960 --> 00:26:24,400
outside everybody's outside he's like

694
00:26:24,400 --> 00:26:24,880
nope

695
00:26:24,880 --> 00:26:26,640
because they're so everybody's so used

696
00:26:26,640 --> 00:26:28,559
to just like interrupting

697
00:26:28,559 --> 00:26:31,760
especially the dance so yeah

698
00:26:31,760 --> 00:26:33,520
my wife and i thought of getting a uh

699
00:26:33,520 --> 00:26:35,200
like on air sign right that we could

700
00:26:35,200 --> 00:26:35,840
like put

701
00:26:35,840 --> 00:26:37,840
their desks to be like hey burn

702
00:26:37,840 --> 00:26:38,880
interpreters now

703
00:26:38,880 --> 00:26:41,919
live right all right well

704
00:26:41,919 --> 00:26:45,360
thank you so much uh we have a break now

705
00:26:45,360 --> 00:26:47,039
and as far as i can tell it's a long

706
00:26:47,039 --> 00:26:48,960
break it's about an hour

707
00:26:48,960 --> 00:26:52,159
um so everyone can go and grab a meal

708
00:26:52,159 --> 00:26:52,480
and

709
00:26:52,480 --> 00:26:54,480
you know hang out with your families and

710
00:26:54,480 --> 00:26:55,760
come back at

711
00:26:55,760 --> 00:26:57,840
in an hour i would say 6 45 but i'm

712
00:26:57,840 --> 00:26:59,279
mountain time and i know that

713
00:26:59,279 --> 00:27:01,279
not everyone's on time so could be

714
00:27:01,279 --> 00:27:03,200
different for you but

715
00:27:03,200 --> 00:27:04,720
thanks for coming monica i really

716
00:27:04,720 --> 00:27:06,400
appreciate it and

717
00:27:06,400 --> 00:27:10,880
we'll see you all in an hour or so

