1
00:00:00,000 --> 00:00:03,750
hey thank you so much for having me so

2
00:00:03,750 --> 00:00:05,040
today I'm gonna give a talk on

3
00:00:05,040 --> 00:00:07,980
typescript called nothing generic about

4
00:00:07,980 --> 00:00:12,210
it how do we switch to my screen as

5
00:00:12,210 --> 00:00:14,759
opposed to me thank you cool umm cool so

6
00:00:14,759 --> 00:00:16,590
today's talk is called nothing at

7
00:00:16,590 --> 00:00:18,990
generic about it and it's about kind of

8
00:00:18,990 --> 00:00:20,970
generics and intermediate features in

9
00:00:20,970 --> 00:00:25,050
typescript so Who am I my name is Mathew

10
00:00:25,050 --> 00:00:27,119
Kurtzman I am a software engineer at

11
00:00:27,119 --> 00:00:29,070
Dropbox Dropbox has been using

12
00:00:29,070 --> 00:00:31,769
typescript since I want to say 2014 so

13
00:00:31,769 --> 00:00:33,450
we have a lot of experience with it I

14
00:00:33,450 --> 00:00:36,270
live and work in New York City which I

15
00:00:36,270 --> 00:00:37,920
love even though it's not doing so hot

16
00:00:37,920 --> 00:00:40,410
right now when I go outside I have this

17
00:00:40,410 --> 00:00:42,660
great face mask that you can see it is

18
00:00:42,660 --> 00:00:45,120
of just you know a face people like it

19
00:00:45,120 --> 00:00:47,550
but yeah you can find me on Twitter at

20
00:00:47,550 --> 00:00:48,870
Matthew Grossman that's usually the best

21
00:00:48,870 --> 00:00:51,270
way to contact me when I'm not giving a

22
00:00:51,270 --> 00:00:52,829
talk and you can find these slides at

23
00:00:52,829 --> 00:00:56,010
generic stop Matthew gerstmann calm now

24
00:00:56,010 --> 00:00:57,690
I kind of want to call this talk is very

25
00:00:57,690 --> 00:01:00,149
much a spiritual sequel to a different

26
00:01:00,149 --> 00:01:02,219
dog I used to give called typescript

27
00:01:02,219 --> 00:01:04,199
seeing past the hype which is very much

28
00:01:04,199 --> 00:01:06,180
the pros and cons of typescript and why

29
00:01:06,180 --> 00:01:08,070
you might want to use it and how it gets

30
00:01:08,070 --> 00:01:10,439
in your way this isn't really an intro

31
00:01:10,439 --> 00:01:13,439
to typescript talk this is a hey let's

32
00:01:13,439 --> 00:01:15,180
cover the intermediate features of

33
00:01:15,180 --> 00:01:18,840
typescript talk so I kind of like to

34
00:01:18,840 --> 00:01:20,490
frame it with some questions you've had

35
00:01:20,490 --> 00:01:22,320
unfortunately there's a little bit of a

36
00:01:22,320 --> 00:01:24,439
delay between me and you in the stream

37
00:01:24,439 --> 00:01:28,200
but I don't really have the luxury of

38
00:01:28,200 --> 00:01:29,880
having live interaction from all of you

39
00:01:29,880 --> 00:01:31,530
so the best we can do is the all the

40
00:01:31,530 --> 00:01:33,960
talk slack so if you are in the track

41
00:01:33,960 --> 00:01:35,880
JavaScript kiss channel can I just get

42
00:01:35,880 --> 00:01:38,280
several people or typing right now just

43
00:01:38,280 --> 00:01:39,960
anything I don't care what you type or

44
00:01:39,960 --> 00:01:42,390
what you say it's just it's kind of the

45
00:01:42,390 --> 00:01:43,950
best way for you to react to me so

46
00:01:43,950 --> 00:01:46,020
there's about 10 seconds between you and

47
00:01:46,020 --> 00:01:49,710
me so if you if something resonates with

48
00:01:49,710 --> 00:01:51,240
you please just several people are

49
00:01:51,240 --> 00:01:54,240
typing respond to gifts it's I enjoy it

50
00:01:54,240 --> 00:01:56,430
so let's let's cover some questions you

51
00:01:56,430 --> 00:01:57,869
might have had when you're working in

52
00:01:57,869 --> 00:02:00,240
typescript how do I create a function

53
00:02:00,240 --> 00:02:02,130
that returns multiple types feel free to

54
00:02:02,130 --> 00:02:04,469
just start typing if you've had this if

55
00:02:04,469 --> 00:02:07,020
you asked this question how do I get the

56
00:02:07,020 --> 00:02:11,160
type from inside of a promise can I use

57
00:02:11,160 --> 00:02:13,190
different types based on some

58
00:02:13,190 --> 00:02:16,850
to see how do I tell typescript that I

59
00:02:16,850 --> 00:02:20,450
know something is wrong and then finally

60
00:02:20,450 --> 00:02:22,520
how do i type the shiny new javascript

61
00:02:22,520 --> 00:02:24,350
pattern right like who remembers HSCs

62
00:02:24,350 --> 00:02:26,030
and ReactOS we're in nightmare too tight

63
00:02:26,030 --> 00:02:27,800
and then render props got a little bit

64
00:02:27,800 --> 00:02:29,630
easier and now fortunately hooks are

65
00:02:29,630 --> 00:02:31,520
very easy to type but you know these

66
00:02:31,520 --> 00:02:33,740
it's kind of we have to keep up with

67
00:02:33,740 --> 00:02:34,850
these patterns and figure how to type

68
00:02:34,850 --> 00:02:37,100
these things and you're first getting

69
00:02:37,100 --> 00:02:38,570
into typescript one of the first things

70
00:02:38,570 --> 00:02:41,210
you learn is it you can use any which

71
00:02:41,210 --> 00:02:44,840
you are initially told is trust me I

72
00:02:44,840 --> 00:02:46,310
know what I'm doing by the way if you

73
00:02:46,310 --> 00:02:48,320
are a Doctor Who fan please just type in

74
00:02:48,320 --> 00:02:50,150
the slack about Doctor Who it makes me

75
00:02:50,150 --> 00:02:54,230
happy so it's very much don't worry

76
00:02:54,230 --> 00:02:58,790
trust me but if it's less of a trust me

77
00:02:58,790 --> 00:03:00,290
I know what I'm doing and a little bit

78
00:03:00,290 --> 00:03:01,790
more like a trust fall right you learn

79
00:03:01,790 --> 00:03:03,230
that pretty quickly you need someone

80
00:03:03,230 --> 00:03:05,720
there to catch you because in any will

81
00:03:05,720 --> 00:03:07,280
start propagating through your codebase

82
00:03:07,280 --> 00:03:10,760
and surely after that you are and it's

83
00:03:10,760 --> 00:03:13,220
not actually a trust fall there's no one

84
00:03:13,220 --> 00:03:14,930
there to catch you any is just going to

85
00:03:14,930 --> 00:03:17,180
start breaking things and the reason for

86
00:03:17,180 --> 00:03:21,230
that is because any is a lot less like

87
00:03:21,230 --> 00:03:23,900
saying hey typescript touch trust me

88
00:03:23,900 --> 00:03:25,910
it's a lot more like saying hey

89
00:03:25,910 --> 00:03:28,550
typescript turn off as far as this

90
00:03:28,550 --> 00:03:30,170
variable is concerned or this argument

91
00:03:30,170 --> 00:03:32,810
is concerned so the first thing I want

92
00:03:32,810 --> 00:03:35,150
to tell you about is Enys twin which is

93
00:03:35,150 --> 00:03:37,070
unknown I like to say that any is the

94
00:03:37,070 --> 00:03:39,620
evil twin of unknown so what exactly is

95
00:03:39,620 --> 00:03:42,500
unknown unknown is the set of all

96
00:03:42,500 --> 00:03:45,050
possible types and the reason I bring it

97
00:03:45,050 --> 00:03:46,790
up is because a lot of the time you're

98
00:03:46,790 --> 00:03:49,040
using any when really you mean I don't

99
00:03:49,040 --> 00:03:51,650
know what type to expect here so unknown

100
00:03:51,650 --> 00:03:53,510
is this option where you can say hey

101
00:03:53,510 --> 00:03:56,360
this could be any possible type we're

102
00:03:56,360 --> 00:03:57,200
gonna figure that out

103
00:03:57,200 --> 00:03:59,239
I got this slide from blog rocket and is

104
00:03:59,239 --> 00:04:01,100
the only slide on set theory if you pull

105
00:04:01,100 --> 00:04:02,330
up these slides you can click on that

106
00:04:02,330 --> 00:04:04,370
but don't worry we're not going to cover

107
00:04:04,370 --> 00:04:07,519
set there today now unknown has some

108
00:04:07,519 --> 00:04:09,830
interesting properties first of all it

109
00:04:09,830 --> 00:04:12,140
has a value so it's it's not like a

110
00:04:12,140 --> 00:04:13,610
valueless type it really does have a

111
00:04:13,610 --> 00:04:16,399
value any value can be assigned to

112
00:04:16,399 --> 00:04:19,430
unknown but we have to determine the

113
00:04:19,430 --> 00:04:22,250
type of it at runtime in order to start

114
00:04:22,250 --> 00:04:23,720
doing stuff with it and I'll show you

115
00:04:23,720 --> 00:04:25,220
what the ergonomics of that look like

116
00:04:25,220 --> 00:04:26,389
now

117
00:04:26,389 --> 00:04:28,490
so let's say I have a function which

118
00:04:28,490 --> 00:04:32,180
takes X and X's of type unknown if I try

119
00:04:32,180 --> 00:04:35,539
to set a number to X it'll complain that

120
00:04:35,539 --> 00:04:37,849
unknown is not assignable it's a type

121
00:04:37,849 --> 00:04:41,210
number if I try to do X plus plus it's

122
00:04:41,210 --> 00:04:42,949
going to complain about arithmetic and

123
00:04:42,949 --> 00:04:45,080
if I try to do X plus seven it's gonna

124
00:04:45,080 --> 00:04:46,699
complain an operator won't work on

125
00:04:46,699 --> 00:04:49,789
unknown but the second I narrow down the

126
00:04:49,789 --> 00:04:53,509
type I can do all these operations just

127
00:04:53,509 --> 00:04:55,580
fine because now typescript is aware hey

128
00:04:55,580 --> 00:04:58,460
this is a number but that was just a

129
00:04:58,460 --> 00:04:59,960
number right like we have a simple check

130
00:04:59,960 --> 00:05:01,520
for that what about more advanced types

131
00:05:01,520 --> 00:05:04,729
well we do that with a process called

132
00:05:04,729 --> 00:05:07,939
type narrowing so what is type narrowing

133
00:05:07,939 --> 00:05:10,550
well we have all these dynamic checks in

134
00:05:10,550 --> 00:05:12,080
our code that can give us information

135
00:05:12,080 --> 00:05:15,229
about values at one time type narrowing

136
00:05:15,229 --> 00:05:16,939
is the process of reflecting this

137
00:05:16,939 --> 00:05:19,219
information in the type checker at

138
00:05:19,219 --> 00:05:23,930
compile time so my goal today is to give

139
00:05:23,930 --> 00:05:26,719
you the tools that you need to reflect

140
00:05:26,719 --> 00:05:28,699
this information in the compiler I don't

141
00:05:28,699 --> 00:05:31,279
expect you to memorize all of this or

142
00:05:31,279 --> 00:05:34,219
really digest and just like internalize

143
00:05:34,219 --> 00:05:35,689
everything we're going to talk about

144
00:05:35,689 --> 00:05:38,150
today what I really want to do is give

145
00:05:38,150 --> 00:05:39,860
you a lot of tools that you can google

146
00:05:39,860 --> 00:05:43,370
in the future so you know roughly hey I

147
00:05:43,370 --> 00:05:45,319
need to go solve this problem this is

148
00:05:45,319 --> 00:05:48,409
the thing that I need to go to do it but

149
00:05:48,409 --> 00:05:50,149
before we cover any of that we have to

150
00:05:50,149 --> 00:05:51,710
talk about the fact that typescript is a

151
00:05:51,710 --> 00:05:54,409
structurally typed language so what does

152
00:05:54,409 --> 00:05:57,409
that mean exactly well I have two types

153
00:05:57,409 --> 00:05:59,000
I have a person and an elf

154
00:05:59,000 --> 00:06:02,120
and they are structured the same so they

155
00:06:02,120 --> 00:06:04,069
both have a name property as far as

156
00:06:04,069 --> 00:06:05,629
typescript is concerned they are the

157
00:06:05,629 --> 00:06:09,349
exact same type so I have Harry and

158
00:06:09,349 --> 00:06:12,110
Dobby who are my person in my elf but if

159
00:06:12,110 --> 00:06:13,279
I could just get several people or

160
00:06:13,279 --> 00:06:14,839
typing for Harry Potter references that

161
00:06:14,839 --> 00:06:18,229
will make me happy and if I call this

162
00:06:18,229 --> 00:06:20,330
function get person name on a person

163
00:06:20,330 --> 00:06:22,399
it's gonna work just fine because

164
00:06:22,399 --> 00:06:23,839
they're structured the same I'm not

165
00:06:23,839 --> 00:06:26,629
gonna have any errors when I do this but

166
00:06:26,629 --> 00:06:29,659
if I add a property to person once they

167
00:06:29,659 --> 00:06:34,069
add this wand property II it's good a

168
00:06:34,069 --> 00:06:36,289
complaint immediately because it is

169
00:06:36,289 --> 00:06:39,930
missing a parameter on type 1 on

170
00:06:39,930 --> 00:06:46,110
person we can also use structural types

171
00:06:46,110 --> 00:06:48,330
to derive other types which is pretty

172
00:06:48,330 --> 00:06:52,169
cool so let's say we let's talk about

173
00:06:52,169 --> 00:06:54,840
intersection types so once I have my

174
00:06:54,840 --> 00:06:56,820
person in my spellcaster now more HP

175
00:06:56,820 --> 00:07:00,330
references and I can do an and on them

176
00:07:00,330 --> 00:07:02,910
to combine these two types into one type

177
00:07:02,910 --> 00:07:05,669
that contains both of them so in this

178
00:07:05,669 --> 00:07:07,590
case wizard which is of type person and

179
00:07:07,590 --> 00:07:09,389
spell caster is the combination of the

180
00:07:09,389 --> 00:07:11,340
two thank you so much Matt for the Harry

181
00:07:11,340 --> 00:07:14,550
Potter gift I appreciate it and if I do

182
00:07:14,550 --> 00:07:16,680
this in one time with person and spell

183
00:07:16,680 --> 00:07:19,380
caster I can splat over the person and

184
00:07:19,380 --> 00:07:20,940
splat over the spell caster and it's

185
00:07:20,940 --> 00:07:23,449
going to produce that wizard for me

186
00:07:23,449 --> 00:07:26,190
similarly we have union types where we

187
00:07:26,190 --> 00:07:29,520
can have a wizard which has name and

188
00:07:29,520 --> 00:07:31,590
string name and spells spells as an

189
00:07:31,590 --> 00:07:33,479
array of strings and then we have a

190
00:07:33,479 --> 00:07:35,099
muggle muggles can't cast spells and

191
00:07:35,099 --> 00:07:36,870
muggles are people too so we have tech

192
00:07:36,870 --> 00:07:39,210
person is wizard or muggle and I made

193
00:07:39,210 --> 00:07:41,520
this function called say my name and it

194
00:07:41,520 --> 00:07:44,010
returns the person's name and this works

195
00:07:44,010 --> 00:07:46,650
just fine because we are using the one

196
00:07:46,650 --> 00:07:49,050
shared property which is name and we're

197
00:07:49,050 --> 00:07:51,060
keying into it if I needed to get more

198
00:07:51,060 --> 00:07:53,070
advanced and figure out is this person a

199
00:07:53,070 --> 00:07:55,260
wizard I could make a type guard

200
00:07:55,260 --> 00:07:57,690
function which can take a person and

201
00:07:57,690 --> 00:08:00,120
then return a boolean whether or not

202
00:08:00,120 --> 00:08:02,099
that person is of the type we expect it

203
00:08:02,099 --> 00:08:04,710
to be which in this case is a wizard now

204
00:08:04,710 --> 00:08:06,389
it's worth noting this is kind of a

205
00:08:06,389 --> 00:08:07,949
runtime type assertion if you've never

206
00:08:07,949 --> 00:08:10,650
used the as keyword keyword in

207
00:08:10,650 --> 00:08:12,750
typescript it's very similar to that but

208
00:08:12,750 --> 00:08:14,490
it's allowing us to be a little more

209
00:08:14,490 --> 00:08:15,930
methodical about when we're just saying

210
00:08:15,930 --> 00:08:17,610
hey I'm very confident about what site

211
00:08:17,610 --> 00:08:22,289
this is total sidebar when I made the

212
00:08:22,289 --> 00:08:23,880
same my name function I tried really

213
00:08:23,880 --> 00:08:26,009
really hard to find a gif of Beyonce as

214
00:08:26,009 --> 00:08:28,199
a wizard and then I stumbled upon this

215
00:08:28,199 --> 00:08:30,659
horrifying thing which I just never want

216
00:08:30,659 --> 00:08:33,570
to see ever again so we're gonna move on

217
00:08:33,570 --> 00:08:35,669
I never want to say that but also never

218
00:08:35,669 --> 00:08:38,940
is a type and even if you've never used

219
00:08:38,940 --> 00:08:40,620
typescript how many of you left this

220
00:08:40,620 --> 00:08:42,690
comment in your code this should never

221
00:08:42,690 --> 00:08:46,230
happen right so never is a type that

222
00:08:46,230 --> 00:08:48,230
allows us to tell typescript hey I

223
00:08:48,230 --> 00:08:52,230
expect you to break let's look at the

224
00:08:52,230 --> 00:08:53,520
ergonomics of that

225
00:08:53,520 --> 00:08:55,110
so let's say I have this assert

226
00:08:55,110 --> 00:08:56,880
exhaustive function right which takes

227
00:08:56,880 --> 00:08:58,800
never so anything that's past two this

228
00:08:58,800 --> 00:09:00,030
will break type-checking

229
00:09:00,030 --> 00:09:02,250
and it returns never so if this function

230
00:09:02,250 --> 00:09:03,720
has ever returned from somewhere it's

231
00:09:03,720 --> 00:09:06,120
gonna also break type-checking so I have

232
00:09:06,120 --> 00:09:08,580
a test exhaustive function which has an

233
00:09:08,580 --> 00:09:10,170
enum over Wizards which right now is

234
00:09:10,170 --> 00:09:12,420
Harry and Hermione and the default case

235
00:09:12,420 --> 00:09:14,880
is assert exhaustive and if it ever gets

236
00:09:14,880 --> 00:09:17,250
to this line this function is now going

237
00:09:17,250 --> 00:09:19,350
to return never and it's going to break

238
00:09:19,350 --> 00:09:22,050
it's also going to be taking wizard

239
00:09:22,050 --> 00:09:26,550
which better not be of type never so if

240
00:09:26,550 --> 00:09:30,240
I go and add a third type to this enum

241
00:09:30,240 --> 00:09:32,340
it's going to complain because it knows

242
00:09:32,340 --> 00:09:34,320
I'm trying to assign a wizards not wrong

243
00:09:34,320 --> 00:09:37,020
to type never and what's cool about this

244
00:09:37,020 --> 00:09:38,850
is you can imagine that we probably have

245
00:09:38,850 --> 00:09:40,860
this enob you know deeply nested inside

246
00:09:40,860 --> 00:09:43,290
of our code base and then we have the

247
00:09:43,290 --> 00:09:44,880
actual function that's using it on the

248
00:09:44,880 --> 00:09:46,860
other side of the code base and two

249
00:09:46,860 --> 00:09:48,990
engineers who never talk could both be

250
00:09:48,990 --> 00:09:50,400
modifying this code and it'll catch

251
00:09:50,400 --> 00:09:53,180
these types of errors which is very cool

252
00:09:53,180 --> 00:09:55,950
now never an unknown have some really

253
00:09:55,950 --> 00:09:59,460
interesting transitive properties so if

254
00:09:59,460 --> 00:10:01,800
we look at a number and something that

255
00:10:01,800 --> 00:10:05,360
should never ever happen well it's gonna

256
00:10:05,360 --> 00:10:07,290
turn out to be something that should

257
00:10:07,290 --> 00:10:08,670
never ever happen that's what that

258
00:10:08,670 --> 00:10:13,620
intersection works out to but if we look

259
00:10:13,620 --> 00:10:15,450
at a number or something that should

260
00:10:15,450 --> 00:10:17,070
never ever happen or string or null

261
00:10:17,070 --> 00:10:19,290
cetera it's going to produce the type

262
00:10:19,290 --> 00:10:22,050
that can actually happen unknown is the

263
00:10:22,050 --> 00:10:27,360
opposite so if we do the intersection of

264
00:10:27,360 --> 00:10:31,860
a number and the set of all possible

265
00:10:31,860 --> 00:10:38,070
types it's going to produce a number but

266
00:10:38,070 --> 00:10:39,070
if we say hey

267
00:10:39,070 --> 00:10:41,769
this could either be a number or the set

268
00:10:41,769 --> 00:10:43,779
of all possible types it's gonna be the

269
00:10:43,779 --> 00:10:46,060
set of all possible types these

270
00:10:46,060 --> 00:10:48,040
properties hold up with net when you use

271
00:10:48,040 --> 00:10:50,079
never an unknown against each other so

272
00:10:50,079 --> 00:10:52,089
never and unknown is never and never or

273
00:10:52,089 --> 00:10:56,230
unknown is unknown but any ruins

274
00:10:56,230 --> 00:10:57,209
everything

275
00:10:57,209 --> 00:10:59,649
fact for the for the few Harry Potter

276
00:10:59,649 --> 00:11:02,050
fans in the audience and he just like

277
00:11:02,050 --> 00:11:03,910
cobblers everything up it's polished

278
00:11:03,910 --> 00:11:08,110
potion it's terrible I actually went to

279
00:11:08,110 --> 00:11:10,209
go see what does any do against never

280
00:11:10,209 --> 00:11:12,459
and unknown interestingly enough the one

281
00:11:12,459 --> 00:11:14,560
time any fails is when you do the

282
00:11:14,560 --> 00:11:16,060
intersection of something that should

283
00:11:16,060 --> 00:11:19,360
never ever happen and any and I have no

284
00:11:19,360 --> 00:11:21,819
idea why so if if you do please let me

285
00:11:21,819 --> 00:11:22,800
know

286
00:11:22,800 --> 00:11:25,750
cool this we're going to move on to

287
00:11:25,750 --> 00:11:27,519
generics which is the namesake of this

288
00:11:27,519 --> 00:11:29,680
talk I am very excited about generics so

289
00:11:29,680 --> 00:11:31,600
I am going to bring in a gif of my girl

290
00:11:31,600 --> 00:11:33,910
Tay because that's this is my feeling

291
00:11:33,910 --> 00:11:36,389
when I talk about she thinks and

292
00:11:36,389 --> 00:11:39,310
generics are like passing a type as an

293
00:11:39,310 --> 00:11:43,779
argument okay so let's look at a basic

294
00:11:43,779 --> 00:11:45,399
example so we have this identity

295
00:11:45,399 --> 00:11:47,620
function which takes an argument returns

296
00:11:47,620 --> 00:11:50,800
it but also in the type layer it's

297
00:11:50,800 --> 00:11:53,500
taking T the type as an argument and

298
00:11:53,500 --> 00:11:58,779
it's returning a value of type T so if I

299
00:11:58,779 --> 00:12:00,850
give it a string it'll return a string

300
00:12:00,850 --> 00:12:03,279
if I give it an array it'll return an

301
00:12:03,279 --> 00:12:05,110
array and if I give it a number it'll

302
00:12:05,110 --> 00:12:08,470
return a number now we can combine these

303
00:12:08,470 --> 00:12:09,850
with some of the features we talked

304
00:12:09,850 --> 00:12:12,579
about earlier so I have my person in my

305
00:12:12,579 --> 00:12:14,290
elf now right which come up with my name

306
00:12:14,290 --> 00:12:17,230
and one just name on the elf and now

307
00:12:17,230 --> 00:12:19,300
spellcaster instead of being its own

308
00:12:19,300 --> 00:12:21,550
type is going to be a generic type that

309
00:12:21,550 --> 00:12:24,970
does t intersected with this object

310
00:12:24,970 --> 00:12:28,089
spells of string so it adds spells to

311
00:12:28,089 --> 00:12:30,130
the object pasture so now when I produce

312
00:12:30,130 --> 00:12:32,290
wizard and house elf it's gonna compile

313
00:12:32,290 --> 00:12:34,329
down to spells and person or spells and

314
00:12:34,329 --> 00:12:36,339
elf and it'll produce this object in

315
00:12:36,339 --> 00:12:39,850
total with all of these properties now

316
00:12:39,850 --> 00:12:41,800
that's a little contrived but you're

317
00:12:41,800 --> 00:12:43,600
actually likely using these in the real

318
00:12:43,600 --> 00:12:46,000
world if you're using typescript so for

319
00:12:46,000 --> 00:12:47,889
example let's say you have a react

320
00:12:47,889 --> 00:12:49,990
component when you give it the props on

321
00:12:49,990 --> 00:12:51,820
that component that

322
00:12:51,820 --> 00:12:54,760
generic when you say hey this is what

323
00:12:54,760 --> 00:12:57,250
this promise results to that's also a

324
00:12:57,250 --> 00:12:59,260
generic we're passing that number as an

325
00:12:59,260 --> 00:13:02,140
argument in the type layer we net

326
00:13:02,140 --> 00:13:03,730
constraints to our generics which is

327
00:13:03,730 --> 00:13:04,510
pretty cool

328
00:13:04,510 --> 00:13:07,240
so a lot of the time we want to say we

329
00:13:07,240 --> 00:13:09,520
only want to be able to pass like one of

330
00:13:09,520 --> 00:13:13,240
these few types so back to my person on

331
00:13:13,240 --> 00:13:13,720
my elf

332
00:13:13,720 --> 00:13:16,600
I just keep using this example now my

333
00:13:16,600 --> 00:13:18,790
spell caster however has this constraint

334
00:13:18,790 --> 00:13:21,310
he extends person and if this doesn't

335
00:13:21,310 --> 00:13:23,440
evaluate to true my type checker is

336
00:13:23,440 --> 00:13:27,190
gonna complain so when I do spell caster

337
00:13:27,190 --> 00:13:28,780
of person is just fine it produces the

338
00:13:28,780 --> 00:13:31,210
wizard but if I try to create a magic

339
00:13:31,210 --> 00:13:33,190
carpet which I'm very proud of this line

340
00:13:33,190 --> 00:13:35,470
I thought it was clever it's going to

341
00:13:35,470 --> 00:13:37,240
complain type string does not satisfy

342
00:13:37,240 --> 00:13:40,150
the constraint person some way for house

343
00:13:40,150 --> 00:13:42,190
elf this is the exact same error when we

344
00:13:42,190 --> 00:13:44,350
tried to pass an elf to that get person

345
00:13:44,350 --> 00:13:46,120
named function when it was missing a

346
00:13:46,120 --> 00:13:47,890
property so it's telling us exactly what

347
00:13:47,890 --> 00:13:49,900
property is missing and why it doesn't

348
00:13:49,900 --> 00:13:53,440
match this constraint let's go to the

349
00:13:53,440 --> 00:13:56,650
next level player we also index in the

350
00:13:56,650 --> 00:13:58,960
type layer and then we can do it with

351
00:13:58,960 --> 00:14:02,590
generics so oh you have another talk on

352
00:14:02,590 --> 00:14:06,220
types code splitting a type tree next or

353
00:14:06,220 --> 00:14:08,470
and I probably spend ten minutes in that

354
00:14:08,470 --> 00:14:10,000
talk on this slide but we're gonna give

355
00:14:10,000 --> 00:14:14,620
a rough overhead of it a review of it so

356
00:14:14,620 --> 00:14:16,840
let's say I have this Redux state which

357
00:14:16,840 --> 00:14:21,010
has people and elves right I can look at

358
00:14:21,010 --> 00:14:23,380
the key people similarly to how I would

359
00:14:23,380 --> 00:14:25,990
in a real object in JavaScript and it'll

360
00:14:25,990 --> 00:14:28,150
return type for me so it allows me to

361
00:14:28,150 --> 00:14:30,610
index into the type layer and then I can

362
00:14:30,610 --> 00:14:33,370
use a generic and do that with a

363
00:14:33,370 --> 00:14:36,160
variable type so I have this function

364
00:14:36,160 --> 00:14:39,010
called get key from redux store and it

365
00:14:39,010 --> 00:14:40,690
takes the type redux state which is

366
00:14:40,690 --> 00:14:44,560
these people in these elves and now i

367
00:14:44,560 --> 00:14:45,910
have a generic

368
00:14:45,910 --> 00:14:49,120
t extends kiev redux state what is key

369
00:14:49,120 --> 00:14:54,400
arenak state well that is a union of all

370
00:14:54,400 --> 00:14:58,060
the keys on redox state so we're now

371
00:14:58,060 --> 00:15:00,700
saying that this key has to be one of

372
00:15:00,700 --> 00:15:02,830
the keys inside of the object that's

373
00:15:02,830 --> 00:15:05,460
given to it

374
00:15:05,590 --> 00:15:09,580
and it's returning a type of one of the

375
00:15:09,580 --> 00:15:12,670
values on that object by doing Redux

376
00:15:12,670 --> 00:15:15,160
state at T which will be whatever key

377
00:15:15,160 --> 00:15:17,440
we're looking for just pretty cool in my

378
00:15:17,440 --> 00:15:19,560
opinion

379
00:15:19,620 --> 00:15:21,880
so a lot of that was type narrowing

380
00:15:21,880 --> 00:15:24,130
where it's I want the compiler to figure

381
00:15:24,130 --> 00:15:27,550
out what type we have but sometimes we

382
00:15:27,550 --> 00:15:30,760
want to go from Taipei to type B we

383
00:15:30,760 --> 00:15:32,140
watching Doctor Who right now so I'm

384
00:15:32,140 --> 00:15:33,700
just like really into the doctor here

385
00:15:33,700 --> 00:15:36,790
yes so map types are an interesting case

386
00:15:36,790 --> 00:15:39,250
for these so we can do loops in the type

387
00:15:39,250 --> 00:15:41,320
layer as well so these two functions

388
00:15:41,320 --> 00:15:43,240
partial and pink are very popular in

389
00:15:43,240 --> 00:15:45,580
typescript and you can see here we're

390
00:15:45,580 --> 00:15:48,670
doing P in K or key of T so we are

391
00:15:48,670 --> 00:15:52,770
looping over something in the type layer

392
00:15:52,770 --> 00:15:55,300
so I want to look into how each of these

393
00:15:55,300 --> 00:15:56,920
work will start with partial and then

394
00:15:56,920 --> 00:15:59,230
then we'll do pick so for Dropbox we

395
00:15:59,230 --> 00:16:01,570
think about files a lot and let's say we

396
00:16:01,570 --> 00:16:04,060
want to have all the properties on a

397
00:16:04,060 --> 00:16:05,890
file will be optional right like maybe

398
00:16:05,890 --> 00:16:08,620
we have the name at the beginning but

399
00:16:08,620 --> 00:16:10,150
then we need to go fetch the size and

400
00:16:10,150 --> 00:16:12,670
permissions of the file so partial makes

401
00:16:12,670 --> 00:16:16,150
all these properties optional the way

402
00:16:16,150 --> 00:16:18,730
this works is partial take some generic

403
00:16:18,730 --> 00:16:21,640
it takes an object or type and then it

404
00:16:21,640 --> 00:16:24,010
produces key of that type inside of it

405
00:16:24,010 --> 00:16:25,660
which in this case is going to be name

406
00:16:25,660 --> 00:16:29,950
size and permissions so we are going to

407
00:16:29,950 --> 00:16:32,460
loop over that where P is each of those

408
00:16:32,460 --> 00:16:36,640
we make it optional and then we index in

409
00:16:36,640 --> 00:16:39,250
the type layer and return that type at

410
00:16:39,250 --> 00:16:44,680
that index look at one more example of

411
00:16:44,680 --> 00:16:48,370
this heck here's a function that allows

412
00:16:48,370 --> 00:16:50,920
us to get a subset of the properties on

413
00:16:50,920 --> 00:16:53,800
a type so we pass it file and then we

414
00:16:53,800 --> 00:16:56,500
say we want name or size and it gives us

415
00:16:56,500 --> 00:16:59,110
just the subset of those properties this

416
00:16:59,110 --> 00:17:01,630
works very similarly it takes T which is

417
00:17:01,630 --> 00:17:05,200
an odd generic but now we're doing now

418
00:17:05,200 --> 00:17:06,670
we're producing that array that we're

419
00:17:06,670 --> 00:17:08,230
going to loop over in the type signature

420
00:17:08,230 --> 00:17:10,390
because we have to have that constraint

421
00:17:10,390 --> 00:17:12,220
K must be one of the keys of there and

422
00:17:12,220 --> 00:17:13,839
we're doing that the signature so before

423
00:17:13,839 --> 00:17:15,760
we were doing into the body now we're

424
00:17:15,760 --> 00:17:18,190
doing this up in the signature we're

425
00:17:18,190 --> 00:17:18,929
looping through

426
00:17:18,929 --> 00:17:21,689
okay p NK and then we index into the

427
00:17:21,689 --> 00:17:24,209
type layer again and return the specific

428
00:17:24,209 --> 00:17:30,119
type now I know that was a lot like a

429
00:17:30,119 --> 00:17:33,600
lot of advanced typescript and yeah

430
00:17:33,600 --> 00:17:35,309
my brain was pretty fried the first time

431
00:17:35,309 --> 00:17:37,919
I gave that so I just want to give

432
00:17:37,919 --> 00:17:39,360
everyone a mental rest can y'all just

433
00:17:39,360 --> 00:17:41,159
start posting gifts in the slack shadow

434
00:17:41,159 --> 00:17:42,629
with any of your favorite things I don't

435
00:17:42,629 --> 00:17:44,669
care what just put some gifts give your

436
00:17:44,669 --> 00:17:45,629
brain a break

437
00:17:45,629 --> 00:17:47,249
cuz we're gonna move on to some even

438
00:17:47,249 --> 00:17:50,539
more advanced type scripts short light

439
00:17:50,749 --> 00:17:54,269
cool I'm like waiting for the catch it's

440
00:17:54,269 --> 00:17:56,580
happened yes thank you damn cool

441
00:17:56,580 --> 00:18:00,570
conditional types so we can have types

442
00:18:00,570 --> 00:18:04,710
and perform if-else logic in the type

443
00:18:04,710 --> 00:18:09,179
layer so I have this type number or null

444
00:18:09,179 --> 00:18:12,600
and it takes my generic and now we have

445
00:18:12,600 --> 00:18:15,600
a constraint t extends number and if

446
00:18:15,600 --> 00:18:19,169
this predicate evaluates it's true it's

447
00:18:19,169 --> 00:18:21,659
gonna return a number otherwise it's

448
00:18:21,659 --> 00:18:25,350
been a return null so if I give it a

449
00:18:25,350 --> 00:18:27,389
number it returns number if I give it a

450
00:18:27,389 --> 00:18:30,389
string a boolean or even no it returns

451
00:18:30,389 --> 00:18:33,269
null and we could do some pretty cool

452
00:18:33,269 --> 00:18:35,100
things with this so we could say hey I

453
00:18:35,100 --> 00:18:37,230
need the type I need to either the

454
00:18:37,230 --> 00:18:39,059
promise of a type or the type inside of

455
00:18:39,059 --> 00:18:41,159
it and we can say this is either going

456
00:18:41,159 --> 00:18:43,169
to extend the promise and it's going to

457
00:18:43,169 --> 00:18:44,460
return the promise or it's gonna be

458
00:18:44,460 --> 00:18:48,179
never sorry I skipped ahead so in this

459
00:18:48,179 --> 00:18:49,799
case we're saying hey this is either a

460
00:18:49,799 --> 00:18:52,110
promise of anything and we return the

461
00:18:52,110 --> 00:18:53,730
promise of anything or we return the

462
00:18:53,730 --> 00:18:56,009
type inside of it that's kind of weird

463
00:18:56,009 --> 00:18:57,330
right because like this is the set of

464
00:18:57,330 --> 00:18:58,950
all possible types and maybe we want to

465
00:18:58,950 --> 00:19:00,779
actually get the type out from inside

466
00:19:00,779 --> 00:19:03,779
the promise and this is where we use one

467
00:19:03,779 --> 00:19:04,950
of my favorite features of typescript

468
00:19:04,950 --> 00:19:06,480
this is called inference types and this

469
00:19:06,480 --> 00:19:08,009
is the last thing we're gonna cover and

470
00:19:08,009 --> 00:19:10,440
I like to think of inference types as

471
00:19:10,440 --> 00:19:11,940
what's in the box

472
00:19:11,940 --> 00:19:15,509
so we this func leave a type now called

473
00:19:15,509 --> 00:19:18,389
unwrap promise we have the sync string

474
00:19:18,389 --> 00:19:20,369
key extends promise but now we have

475
00:19:20,369 --> 00:19:23,820
infer a and what this does is as long as

476
00:19:23,820 --> 00:19:26,940
T extends promise it's going to return

477
00:19:26,940 --> 00:19:29,240
the type inside of that promise

478
00:19:29,240 --> 00:19:32,440
otherwise the type checker will break

479
00:19:32,440 --> 00:19:35,659
so when we look at a promise of string

480
00:19:35,659 --> 00:19:37,879
or number and we go to unwrap the

481
00:19:37,879 --> 00:19:40,159
promise it's gonna give us that inside

482
00:19:40,159 --> 00:19:42,350
type if we give it something that isn't

483
00:19:42,350 --> 00:19:44,659
a promise it's going to fail that that's

484
00:19:44,659 --> 00:19:46,820
the check and it's gonna break in the

485
00:19:46,820 --> 00:19:50,960
type wire it's going to return never we

486
00:19:50,960 --> 00:19:52,639
can use this for other things too like

487
00:19:52,639 --> 00:19:54,350
we can get the arguments of a function

488
00:19:54,350 --> 00:19:57,529
so if we can say hey if this T extends a

489
00:19:57,529 --> 00:20:00,110
function we can infer the arguments of

490
00:20:00,110 --> 00:20:03,169
it and return them so let's see whether

491
00:20:03,169 --> 00:20:04,549
the argument or we break the type

492
00:20:04,549 --> 00:20:05,990
checker so when I give it this function

493
00:20:05,990 --> 00:20:08,570
that takes a or B a and B it's going to

494
00:20:08,570 --> 00:20:10,100
return a tuple of titin number and

495
00:20:10,100 --> 00:20:14,269
string you knew this in react as well I

496
00:20:14,269 --> 00:20:15,559
had to have one more Taylor Swift

497
00:20:15,559 --> 00:20:18,139
reference so assuming that it is of type

498
00:20:18,139 --> 00:20:19,879
react component we can infer the props

499
00:20:19,879 --> 00:20:23,210
so now it'll return the props break the

500
00:20:23,210 --> 00:20:26,389
type checker and if we give it a taylor

501
00:20:26,389 --> 00:20:29,119
component we have the list of albums as

502
00:20:29,119 --> 00:20:32,539
props and this is effectively a function

503
00:20:32,539 --> 00:20:35,029
that gets those props out of the

504
00:20:35,029 --> 00:20:36,889
component in the type layer which in

505
00:20:36,889 --> 00:20:41,090
this case will return albums so let's

506
00:20:41,090 --> 00:20:42,139
review shall we because we've just

507
00:20:42,139 --> 00:20:45,409
covered a lot covered structural typing

508
00:20:45,409 --> 00:20:47,210
or two types of the same and covered

509
00:20:47,210 --> 00:20:48,799
never where we can tell typescript that

510
00:20:48,799 --> 00:20:51,019
something broke become an unknown where

511
00:20:51,019 --> 00:20:52,340
we can say hey I don't know what type is

512
00:20:52,340 --> 00:20:54,470
here we covered unions where we can look

513
00:20:54,470 --> 00:20:56,749
at type A or type B recovered

514
00:20:56,749 --> 00:20:58,519
intersections or a combining types we

515
00:20:58,519 --> 00:21:00,110
covered generics where we're using types

516
00:21:00,110 --> 00:21:01,730
as arguments recovered indexing we

517
00:21:01,730 --> 00:21:03,409
covered map types we covered conditional

518
00:21:03,409 --> 00:21:05,570
types and inference types and that is

519
00:21:05,570 --> 00:21:07,879
way too much I don't expect anyone to

520
00:21:07,879 --> 00:21:11,509
actually remember all of that here's

521
00:21:11,509 --> 00:21:13,610
what I what I hope for you here's the

522
00:21:13,610 --> 00:21:15,259
slide of everything we covered today

523
00:21:15,259 --> 00:21:17,509
this is what you can Google when you are

524
00:21:17,509 --> 00:21:19,340
digging into typescript code and you

525
00:21:19,340 --> 00:21:20,889
know how an overview of these things

526
00:21:20,889 --> 00:21:23,149
here's what I actually want you to take

527
00:21:23,149 --> 00:21:26,659
away from it from this I want you to

528
00:21:26,659 --> 00:21:30,200
avoid any at all costs I want you to

529
00:21:30,200 --> 00:21:32,779
start with unknown and see what happens

530
00:21:32,779 --> 00:21:35,809
and I want you to use never to tell

531
00:21:35,809 --> 00:21:38,509
typescript that something is broken so

532
00:21:38,509 --> 00:21:40,490
thank you so much my name is matthew

533
00:21:40,490 --> 00:21:43,249
Gerstmann and i think we can move on to

534
00:21:43,249 --> 00:21:44,629
questions we have a few minutes for

535
00:21:44,629 --> 00:21:46,840
those

536
00:21:49,380 --> 00:21:51,580
hey Thank You Matthew that was pretty

537
00:21:51,580 --> 00:21:54,610
awesome thank you and I also like the

538
00:21:54,610 --> 00:21:58,240
Harry Potter references now always for

539
00:21:58,240 --> 00:22:00,880
my own amusement so so a little

540
00:22:00,880 --> 00:22:03,550
philosophical there start from the

541
00:22:03,550 --> 00:22:05,880
unknown and see what happens

542
00:22:05,880 --> 00:22:12,610
yeah a little bit so so what are some of

543
00:22:12,610 --> 00:22:16,420
the disadvantages of typescript you you

544
00:22:16,420 --> 00:22:18,420
you gave us a really good picture of

545
00:22:18,420 --> 00:22:20,830
what's what's awesome about it and I

546
00:22:20,830 --> 00:22:22,330
loved it but what are the things we

547
00:22:22,330 --> 00:22:25,990
should be careful about the kind of so

548
00:22:25,990 --> 00:22:28,150
if you're new to typescript which this

549
00:22:28,150 --> 00:22:29,860
was very much not aimed at those at

550
00:22:29,860 --> 00:22:32,080
those people um the biggest thing I will

551
00:22:32,080 --> 00:22:33,820
tell you is that typescript will get in

552
00:22:33,820 --> 00:22:35,410
your way for the first few months and

553
00:22:35,410 --> 00:22:37,030
then it will quickly turn into something

554
00:22:37,030 --> 00:22:40,150
you can't live without so there's a lot

555
00:22:40,150 --> 00:22:41,590
of stuff where just like it's telling

556
00:22:41,590 --> 00:22:43,390
you in your editor what isn't isn't

557
00:22:43,390 --> 00:22:46,030
broken but when you're first figuring

558
00:22:46,030 --> 00:22:47,650
out how to type these advanced patterns

559
00:22:47,650 --> 00:22:49,840
or you're like like the first time you

560
00:22:49,840 --> 00:22:51,490
dig into a library and you have to look

561
00:22:51,490 --> 00:22:52,870
at all these generics or all these crazy

562
00:22:52,870 --> 00:22:54,970
features you're just like what is going

563
00:22:54,970 --> 00:22:57,130
on here um so it's really the the

564
00:22:57,130 --> 00:22:59,650
learning curve is the worst part of it I

565
00:22:59,650 --> 00:23:01,540
have no other complaints about

566
00:23:01,540 --> 00:23:05,020
typescript actually okay that's awesome

567
00:23:05,020 --> 00:23:07,750
types good compiles down to JavaScript

568
00:23:07,750 --> 00:23:11,710
right yeah so typescript is a superset

569
00:23:11,710 --> 00:23:12,550
of JavaScript

570
00:23:12,550 --> 00:23:16,270
it supports compiling down to you es 6

571
00:23:16,270 --> 00:23:19,150
es 5 or even es 3 there's a whole bunch

572
00:23:19,150 --> 00:23:21,520
of flags sometimes people use it with or

573
00:23:21,520 --> 00:23:23,440
without babel depending on what they're

574
00:23:23,440 --> 00:23:25,809
looking to do be guess it runs in the

575
00:23:25,809 --> 00:23:29,170
browser as JavaScript okay is there some

576
00:23:29,170 --> 00:23:32,260
some mismatch between typescript and

577
00:23:32,260 --> 00:23:34,500
JavaScript in that case where maybe

578
00:23:34,500 --> 00:23:38,110
typescript compiler down to something

579
00:23:38,110 --> 00:23:39,610
that isn't quite directly matched with

580
00:23:39,610 --> 00:23:41,710
JavaScript is that still the case or um

581
00:23:41,710 --> 00:23:45,700
so it's funny so theoretically and for

582
00:23:45,700 --> 00:23:48,730
all practical purposes the answer to

583
00:23:48,730 --> 00:23:51,070
that is typescript always compiles down

584
00:23:51,070 --> 00:23:54,000
to exactly equivalent JavaScript so

585
00:23:54,000 --> 00:23:56,740
typescript is a superset it's not really

586
00:23:56,740 --> 00:23:57,670
like CoffeeScript where there's

587
00:23:57,670 --> 00:23:59,080
different syntax is the exact

588
00:23:59,080 --> 00:24:00,760
same thing now I say this was an

589
00:24:00,760 --> 00:24:02,590
asterisk on it because funnily enough a

590
00:24:02,590 --> 00:24:05,019
security engineer at Dropbox found the

591
00:24:05,019 --> 00:24:06,789
one case where you have valid typescript

592
00:24:06,789 --> 00:24:09,250
that produces something different in

593
00:24:09,250 --> 00:24:12,070
JavaScript but that is a bug not so much

594
00:24:12,070 --> 00:24:14,860
a feature so let's go ahead and let's go

595
00:24:14,860 --> 00:24:18,419
with ninety-nine point a lot of noise

596
00:24:18,419 --> 00:24:20,409
well that's good that's good to know

597
00:24:20,409 --> 00:24:24,970
excellent where the things that you wish

598
00:24:24,970 --> 00:24:32,769
typescript did not have interesting so

599
00:24:32,769 --> 00:24:34,809
there's there's both interfaces and

600
00:24:34,809 --> 00:24:35,409
types

601
00:24:35,409 --> 00:24:37,720
I personally lean towards types I don't

602
00:24:37,720 --> 00:24:38,950
think it's very clear to people when to

603
00:24:38,950 --> 00:24:42,490
use which one I think that's the I think

604
00:24:42,490 --> 00:24:43,480
that's the biggest thing where it's like

605
00:24:43,480 --> 00:24:45,309
uh people are like I don't know which

606
00:24:45,309 --> 00:24:46,690
feature to use here and I still don't

607
00:24:46,690 --> 00:24:47,740
know which one to use most of the time

608
00:24:47,740 --> 00:24:50,049
um there's a great book I write called

609
00:24:50,049 --> 00:24:51,610
effective typescript and it pretty much

610
00:24:51,610 --> 00:24:53,260
the guidance in there was pretty much

611
00:24:53,260 --> 00:24:55,120
use whatever your code base started with

612
00:24:55,120 --> 00:24:59,139
um so I guess I'd probably kill one of

613
00:24:59,139 --> 00:25:02,740
those if I had to pick yeah well so I do

614
00:25:02,740 --> 00:25:04,899
agree with what you're saying it did

615
00:25:04,899 --> 00:25:06,909
throw me a little bit off especially

616
00:25:06,909 --> 00:25:11,500
with angular interfaces are so important

617
00:25:11,500 --> 00:25:13,750
and and to a great extent I would say

618
00:25:13,750 --> 00:25:16,539
typescript having you know interfaces

619
00:25:16,539 --> 00:25:18,789
kind of favors the angular way of

620
00:25:18,789 --> 00:25:21,010
developing things but it can get a

621
00:25:21,010 --> 00:25:22,840
little confusing as to like why would I

622
00:25:22,840 --> 00:25:27,100
need it so yeah excellent

623
00:25:27,100 --> 00:25:29,080
well that was an amazing talk really

624
00:25:29,080 --> 00:25:31,149
enjoyed it so thanks for your time

625
00:25:31,149 --> 00:25:32,740
let me check really quickly if there's

626
00:25:32,740 --> 00:25:35,019
any more questions I don't see any any

627
00:25:35,019 --> 00:25:37,419
more questions so thank you so much

628
00:25:37,419 --> 00:25:41,549
appreciate it cool thank you so much

629
00:25:45,860 --> 00:25:48,830
[Music]

