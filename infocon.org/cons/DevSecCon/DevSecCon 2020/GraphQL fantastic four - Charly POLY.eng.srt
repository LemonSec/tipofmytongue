1
00:00:00,000 --> 00:00:03,520
hi good evening it's night for me so

2
00:00:03,520 --> 00:00:05,440
i'm very happy to be here my name is

3
00:00:05,440 --> 00:00:07,600
charlie i'm a french software senior

4
00:00:07,600 --> 00:00:09,280
software engineer at double which is a

5
00:00:09,280 --> 00:00:10,960
startup base in new york

6
00:00:10,960 --> 00:00:13,599
and i'm in rome right now and i'm very

7
00:00:13,599 --> 00:00:15,440
happy to be here

8
00:00:15,440 --> 00:00:18,240
online with you because uh i'm not

9
00:00:18,240 --> 00:00:19,279
totally

10
00:00:19,279 --> 00:00:21,760
a fan of graphql for many years so let's

11
00:00:21,760 --> 00:00:24,320
get started

12
00:00:24,880 --> 00:00:27,359
so has that said i'm charlie senior

13
00:00:27,359 --> 00:00:28,720
software engineer double

14
00:00:28,720 --> 00:00:30,640
and i started to use graphql four years

15
00:00:30,640 --> 00:00:33,440
ago so one year after the public release

16
00:00:33,440 --> 00:00:35,680
and i immediately started to do site

17
00:00:35,680 --> 00:00:37,680
projects like for example the graphql

18
00:00:37,680 --> 00:00:38,640
api

19
00:00:38,640 --> 00:00:41,680
of spotify rest api as a psyc project

20
00:00:41,680 --> 00:00:44,960
using express etc and also i immediately

21
00:00:44,960 --> 00:00:46,320
started to use

22
00:00:46,320 --> 00:00:48,879
graphql in professional application in

23
00:00:48,879 --> 00:00:50,079
production applications

24
00:00:50,079 --> 00:00:53,600
with react and after two years of usage

25
00:00:53,600 --> 00:00:55,199
on different type of projects

26
00:00:55,199 --> 00:00:59,120
i decided to write a feedback on a blog

27
00:00:59,120 --> 00:01:01,680
i do with friends that was called why

28
00:01:01,680 --> 00:01:03,760
use graphql good and by reason on honest

29
00:01:03,760 --> 00:01:04,959
engineering

30
00:01:04,959 --> 00:01:07,280
and the purpose of this article was to

31
00:01:07,280 --> 00:01:09,439
provide a good feedback to people

32
00:01:09,439 --> 00:01:12,240
in terms of adoption or on whenever was

33
00:01:12,240 --> 00:01:14,960
a good and bad reason to use graphql

34
00:01:14,960 --> 00:01:18,080
and there was three main reasons of

35
00:01:18,080 --> 00:01:19,040
three main

36
00:01:19,040 --> 00:01:22,320
advantage of graphql at that time

37
00:01:22,320 --> 00:01:25,520
first is that graphql is good to build

38
00:01:25,520 --> 00:01:28,479
to build smooth user experience first

39
00:01:28,479 --> 00:01:29,200
because of the

40
00:01:29,200 --> 00:01:32,320
asks for what you want ideology

41
00:01:32,320 --> 00:01:34,720
which is based on the language itself

42
00:01:34,720 --> 00:01:35,520
that

43
00:01:35,520 --> 00:01:37,520
lets you get the data that you want only

44
00:01:37,520 --> 00:01:39,360
the field that you want but also

45
00:01:39,360 --> 00:01:41,439
in the same http request so it was

46
00:01:41,439 --> 00:01:43,119
reducing the overhead

47
00:01:43,119 --> 00:01:45,200
in term of network on both the type the

48
00:01:45,200 --> 00:01:47,119
size of the payload but the number of

49
00:01:47,119 --> 00:01:49,040
exchange that you do with the api so

50
00:01:49,040 --> 00:01:50,799
this was very very good

51
00:01:50,799 --> 00:01:53,520
for mobile first experience but also on

52
00:01:53,520 --> 00:01:55,119
the optimistic ui

53
00:01:55,119 --> 00:01:58,399
features features provided by the client

54
00:01:58,399 --> 00:02:00,479
so first by for example by the

55
00:02:00,479 --> 00:02:02,000
optimistic

56
00:02:02,000 --> 00:02:04,560
ui on the mutation so optimistic

57
00:02:04,560 --> 00:02:06,560
responses as we call it

58
00:02:06,560 --> 00:02:09,520
so being able to update the local what

59
00:02:09,520 --> 00:02:10,080
is

60
00:02:10,080 --> 00:02:11,680
displayed on the ui before having the

61
00:02:11,680 --> 00:02:13,440
answer from the the server

62
00:02:13,440 --> 00:02:15,440
from the api but also the different

63
00:02:15,440 --> 00:02:16,800
fetch policies

64
00:02:16,800 --> 00:02:21,200
uh provided by apollo the second one

65
00:02:21,200 --> 00:02:24,400
was graphql is good to solve data

66
00:02:24,400 --> 00:02:26,400
complexity issue on the front end

67
00:02:26,400 --> 00:02:29,680
so if you were working with big spa in

68
00:02:29,680 --> 00:02:30,239
the past

69
00:02:30,239 --> 00:02:32,800
or even now using rest api that provide

70
00:02:32,800 --> 00:02:33,440
only

71
00:02:33,440 --> 00:02:36,400
endpoints for models or for maybe

72
00:02:36,400 --> 00:02:37,840
relationships

73
00:02:37,840 --> 00:02:40,239
you will have to query a lot of apis and

74
00:02:40,239 --> 00:02:41,840
although all the crunching of the data

75
00:02:41,840 --> 00:02:42,959
on the client side

76
00:02:42,959 --> 00:02:46,560
and maybe eventually put this data in a

77
00:02:46,560 --> 00:02:46,959
cache

78
00:02:46,959 --> 00:02:50,879
like using redux or maybe mobx mobix3

79
00:02:50,879 --> 00:02:54,000
and all this is solved by on one side

80
00:02:54,000 --> 00:02:56,160
graphite itself by design because

81
00:02:56,160 --> 00:02:58,800
graphql queries and mutation

82
00:02:58,800 --> 00:03:01,360
does allow us to provide an api that is

83
00:03:01,360 --> 00:03:02,319
not

84
00:03:02,319 --> 00:03:04,480
directly linked to the models as a

85
00:03:04,480 --> 00:03:05,680
one-on-one

86
00:03:05,680 --> 00:03:08,480
relationship and also by the clients

87
00:03:08,480 --> 00:03:09,519
that provide the

88
00:03:09,519 --> 00:03:11,680
one a very powerful cache using

89
00:03:11,680 --> 00:03:13,360
observers either on

90
00:03:13,360 --> 00:03:16,480
relay on app or apollo also

91
00:03:16,480 --> 00:03:18,159
things that i find interesting is that

92
00:03:18,159 --> 00:03:19,760
the mutations are like

93
00:03:19,760 --> 00:03:22,560
typed and checked also on the client

94
00:03:22,560 --> 00:03:23,840
side so you don't have to duplicate

95
00:03:23,840 --> 00:03:26,239
anymore the very basic

96
00:03:26,239 --> 00:03:28,959
check that you have to do which are the

97
00:03:28,959 --> 00:03:31,440
same as the api

98
00:03:31,440 --> 00:03:34,720
the last point two years ago was really

99
00:03:34,720 --> 00:03:36,799
really really edgy but it was like

100
00:03:36,799 --> 00:03:38,640
using graphql for microservices

101
00:03:38,640 --> 00:03:39,840
orchestration

102
00:03:39,840 --> 00:03:43,440
so being able to do yeah macro services

103
00:03:43,440 --> 00:03:44,720
orchestration so having

104
00:03:44,720 --> 00:03:47,680
multiple graphical api and plug them

105
00:03:47,680 --> 00:03:49,040
together using apollo

106
00:03:49,040 --> 00:03:51,120
schema stitching which is now apple

107
00:03:51,120 --> 00:03:52,879
federation with more way

108
00:03:52,879 --> 00:03:56,319
way better features and more advanced

109
00:03:56,319 --> 00:03:58,159
the thing is that if you ask to someone

110
00:03:58,159 --> 00:04:00,720
today why they use graphql is very most

111
00:04:00,720 --> 00:04:01,760
likely that it's going to

112
00:04:01,760 --> 00:04:03,200
is they're going to answer something

113
00:04:03,200 --> 00:04:04,799
that's going to fit in those

114
00:04:04,799 --> 00:04:08,239
three reasons and i found that it's kind

115
00:04:08,239 --> 00:04:08,480
of

116
00:04:08,480 --> 00:04:11,599
a shame in quote because graphql brought

117
00:04:11,599 --> 00:04:12,480
a lot of things

118
00:04:12,480 --> 00:04:16,079
outside of just the scenario of

119
00:04:16,079 --> 00:04:18,959
front-end fetching data from the api so

120
00:04:18,959 --> 00:04:21,199
today i want to talk about graphql

121
00:04:21,199 --> 00:04:23,199
the fact that graphql is much more than

122
00:04:23,199 --> 00:04:24,960
an efficient way of fetching data from

123
00:04:24,960 --> 00:04:26,400
the client side

124
00:04:26,400 --> 00:04:28,160
so in order to cover the subject we're

125
00:04:28,160 --> 00:04:30,639
going to take a look at four examples

126
00:04:30,639 --> 00:04:33,759
of innovation that graphql growth

127
00:04:33,759 --> 00:04:35,840
in the web ecosystem that are not linked

128
00:04:35,840 --> 00:04:36,880
to only

129
00:04:36,880 --> 00:04:42,560
front-end fetching data from the backend

130
00:04:42,560 --> 00:04:45,680
but first graphql has application state

131
00:04:45,680 --> 00:04:48,000
management

132
00:04:48,000 --> 00:04:50,080
so nowadays if you build like a react

133
00:04:50,080 --> 00:04:51,199
app application

134
00:04:51,199 --> 00:04:53,280
you have to handle top-loading state

135
00:04:53,280 --> 00:04:54,479
management like

136
00:04:54,479 --> 00:04:56,240
that have to be shared in the whole

137
00:04:56,240 --> 00:04:58,000
application by all components

138
00:04:58,000 --> 00:04:59,840
it's very most likely your choice is

139
00:04:59,840 --> 00:05:01,199
gonna go

140
00:05:01,199 --> 00:05:03,759
on three main solutions either you're

141
00:05:03,759 --> 00:05:04,479
gonna

142
00:05:04,479 --> 00:05:06,560
stick to react itself and use context

143
00:05:06,560 --> 00:05:09,199
api if you have a very simple state

144
00:05:09,199 --> 00:05:12,800
that can be based on contexts

145
00:05:12,800 --> 00:05:14,240
or either you're going to use redux

146
00:05:14,240 --> 00:05:16,479
which is like for a very long time now

147
00:05:16,479 --> 00:05:20,240
or mobx the thing is that if you think

148
00:05:20,240 --> 00:05:23,120
about graphql graphql is a data query in

149
00:05:23,120 --> 00:05:25,600
manipulation language for api

150
00:05:25,600 --> 00:05:28,560
but what if your state your local states

151
00:05:28,560 --> 00:05:30,240
your application state behave like a

152
00:05:30,240 --> 00:05:32,800
local api

153
00:05:32,800 --> 00:05:34,800
this is exactly what the team from

154
00:05:34,800 --> 00:05:35,840
apollo

155
00:05:35,840 --> 00:05:37,919
thought two years ago they made like a

156
00:05:37,919 --> 00:05:40,080
kind of a poc that was a

157
00:05:40,080 --> 00:05:42,000
separated package that was called

158
00:05:42,000 --> 00:05:44,000
uploading states and that is not

159
00:05:44,000 --> 00:05:47,759
now part of the core apollo client

160
00:05:47,759 --> 00:05:49,360
and this feature is called apollo

161
00:05:49,360 --> 00:05:51,360
graphql local state management

162
00:05:51,360 --> 00:05:52,880
so let's take a look at what it means

163
00:05:52,880 --> 00:05:54,400
and what it brings

164
00:05:54,400 --> 00:05:57,199
and how it benchmark compared to the

165
00:05:57,199 --> 00:05:58,880
major solution that exists

166
00:05:58,880 --> 00:06:03,600
two days so we have a query

167
00:06:04,720 --> 00:06:06,639
here this is a graphical query that

168
00:06:06,639 --> 00:06:09,199
lists a set of alerts because we have an

169
00:06:09,199 --> 00:06:11,280
application and we want to list alerts

170
00:06:11,280 --> 00:06:13,120
alerts in order to get alerts we need to

171
00:06:13,120 --> 00:06:15,520
provide a workspace id

172
00:06:15,520 --> 00:06:17,840
and here you can first notice something

173
00:06:17,840 --> 00:06:19,520
very particular that you don't see in

174
00:06:19,520 --> 00:06:21,039
regular

175
00:06:21,039 --> 00:06:24,479
apollo or relay usage graphql usage

176
00:06:24,479 --> 00:06:26,560
this client directive and this client

177
00:06:26,560 --> 00:06:28,240
directive is here to

178
00:06:28,240 --> 00:06:30,639
say to apollo that this data has to be

179
00:06:30,639 --> 00:06:32,240
fetched locally it's not

180
00:06:32,240 --> 00:06:35,840
from the api

181
00:06:37,360 --> 00:06:40,000
here you can see something great that is

182
00:06:40,000 --> 00:06:40,479
bringing

183
00:06:40,479 --> 00:06:43,199
apollo is that you are using one

184
00:06:43,199 --> 00:06:45,039
language which is graphql

185
00:06:45,039 --> 00:06:47,919
and also one set of hooks or api

186
00:06:47,919 --> 00:06:49,360
javascript api

187
00:06:49,360 --> 00:06:51,120
to handle all your data either it's

188
00:06:51,120 --> 00:06:54,479
state or remote data

189
00:06:54,479 --> 00:06:56,319
and if you look closer you're going to

190
00:06:56,319 --> 00:06:57,680
see that here

191
00:06:57,680 --> 00:07:00,960
workspace id is actually

192
00:07:00,960 --> 00:07:03,759
exported as a variable to be used as a

193
00:07:03,759 --> 00:07:06,080
variable for the request that we do

194
00:07:06,080 --> 00:07:08,800
the query that we do remotely so just

195
00:07:08,800 --> 00:07:10,720
with this simple example you see all the

196
00:07:10,720 --> 00:07:11,840
power

197
00:07:11,840 --> 00:07:14,720
of apollo local states so let's see

198
00:07:14,720 --> 00:07:17,840
quickly how it works

199
00:07:18,319 --> 00:07:20,400
so if in your local state you have like

200
00:07:20,400 --> 00:07:22,479
what we call color scholar values

201
00:07:22,479 --> 00:07:25,280
so very simple value like boolean string

202
00:07:25,280 --> 00:07:26,240
etc

203
00:07:26,240 --> 00:07:29,039
not objects you can actually query those

204
00:07:29,039 --> 00:07:29,599
values

205
00:07:29,599 --> 00:07:31,199
if they exist in the cache without

206
00:07:31,199 --> 00:07:33,039
having to write anything in terms of

207
00:07:33,039 --> 00:07:34,160
configuration

208
00:07:34,160 --> 00:07:36,000
and if you want to update those value

209
00:07:36,000 --> 00:07:38,000
you can use or initialize the state as

210
00:07:38,000 --> 00:07:38,479
starting

211
00:07:38,479 --> 00:07:40,720
at the start of your application you can

212
00:07:40,720 --> 00:07:41,919
just use

213
00:07:41,919 --> 00:07:45,120
a client instance of upload.data

214
00:07:45,120 --> 00:07:47,919
so very simple for real use case of

215
00:07:47,919 --> 00:07:49,120
course you're going to have complex

216
00:07:49,120 --> 00:07:49,599
value

217
00:07:49,599 --> 00:07:51,840
like object or custom types so our

218
00:07:51,840 --> 00:07:52,960
computed value

219
00:07:52,960 --> 00:07:54,240
so for that it's going to be a little

220
00:07:54,240 --> 00:07:55,919
bit different so here for example we

221
00:07:55,919 --> 00:07:57,680
have a preferences object

222
00:07:57,680 --> 00:07:59,840
that gets the preferences from the user

223
00:07:59,840 --> 00:08:02,000
dark mode language notification etc

224
00:08:02,000 --> 00:08:04,000
for that you're going to have to provide

225
00:08:04,000 --> 00:08:05,680
locale resolver that you're not going to

226
00:08:05,680 --> 00:08:07,520
implement on your

227
00:08:07,520 --> 00:08:10,800
web application for mutation in queries

228
00:08:10,800 --> 00:08:12,240
so let's have a quick look on that

229
00:08:12,240 --> 00:08:13,840
because i want to show you that it's

230
00:08:13,840 --> 00:08:15,680
really easy and there is nothing needed

231
00:08:15,680 --> 00:08:17,360
in terms of complexity

232
00:08:17,360 --> 00:08:20,639
so here those preferences are stored

233
00:08:20,639 --> 00:08:23,919
using local storage so on the right

234
00:08:23,919 --> 00:08:25,759
on the left you have the reference query

235
00:08:25,759 --> 00:08:26,960
so it's very simple

236
00:08:26,960 --> 00:08:29,520
it's a simple object and here you're

237
00:08:29,520 --> 00:08:31,120
going to see that we have this this is

238
00:08:31,120 --> 00:08:33,039
the apologian configuration we have our

239
00:08:33,039 --> 00:08:34,880
cache we have a resolver object

240
00:08:34,880 --> 00:08:37,360
and then we have the custom resolver

241
00:08:37,360 --> 00:08:38,958
that we have to provide for a query and

242
00:08:38,958 --> 00:08:40,080
limitation

243
00:08:40,080 --> 00:08:41,679
so for the query we're gonna get the

244
00:08:41,679 --> 00:08:43,279
value from the custom edge we're gonna

245
00:08:43,279 --> 00:08:45,360
parse it if it exists

246
00:08:45,360 --> 00:08:46,959
very interesting thing in here in terms

247
00:08:46,959 --> 00:08:48,959
of performance small tips

248
00:08:48,959 --> 00:08:51,519
this resolver is only a is actually only

249
00:08:51,519 --> 00:08:52,839
called once

250
00:08:52,839 --> 00:08:56,480
to iterate the cache and then

251
00:08:56,480 --> 00:08:58,720
further call we'll be calling the cache

252
00:08:58,720 --> 00:08:59,760
only

253
00:08:59,760 --> 00:09:02,160
that's why for example the mutation that

254
00:09:02,160 --> 00:09:03,440
could be called from the

255
00:09:03,440 --> 00:09:04,720
anywhere any component from your

256
00:09:04,720 --> 00:09:07,040
application to update the preferences

257
00:09:07,040 --> 00:09:09,839
is updating both the local storage and

258
00:09:09,839 --> 00:09:11,440
the cache because app always going to

259
00:09:11,440 --> 00:09:12,480
rely on the cache

260
00:09:12,480 --> 00:09:15,279
and not calling the resolver every time

261
00:09:15,279 --> 00:09:18,959
very important point for performances

262
00:09:19,279 --> 00:09:21,920
okay so here we just add a very fast

263
00:09:21,920 --> 00:09:22,720
view

264
00:09:22,720 --> 00:09:25,360
on the fact that apollo is not providing

265
00:09:25,360 --> 00:09:26,640
like

266
00:09:26,640 --> 00:09:28,720
top-class features in terms of local

267
00:09:28,720 --> 00:09:30,080
state management and it's a real

268
00:09:30,080 --> 00:09:30,959
competitor

269
00:09:30,959 --> 00:09:33,519
to mobx and redux for the main reason

270
00:09:33,519 --> 00:09:35,040
that it has all the local tech

271
00:09:35,040 --> 00:09:36,640
management capabilities

272
00:09:36,640 --> 00:09:39,279
first the state is managed by apollo

273
00:09:39,279 --> 00:09:40,880
cache like it's already

274
00:09:40,880 --> 00:09:43,440
managing your data that you use with

275
00:09:43,440 --> 00:09:46,080
graphical api

276
00:09:46,080 --> 00:09:48,000
if you have computed value which is part

277
00:09:48,000 --> 00:09:49,920
of the

278
00:09:49,920 --> 00:09:52,240
proposal value from mobix for example

279
00:09:52,240 --> 00:09:54,320
you can use local reserver and as you we

280
00:09:54,320 --> 00:09:57,519
just saw it's very simple

281
00:09:57,600 --> 00:09:59,680
if you want to have actions if we take

282
00:09:59,680 --> 00:10:02,000
like the analogy with mobx

283
00:10:02,000 --> 00:10:04,320
then it will be mutations or writing

284
00:10:04,320 --> 00:10:08,240
directly in the cache using client.query

285
00:10:08,240 --> 00:10:11,440
if you want to react to some changes

286
00:10:11,440 --> 00:10:14,640
then it's again out of the box because

287
00:10:14,640 --> 00:10:17,680
query in apollo are based on observable

288
00:10:17,680 --> 00:10:19,440
which are called website observable

289
00:10:19,440 --> 00:10:21,760
query so if a query is using a part of

290
00:10:21,760 --> 00:10:23,279
the cache that has been updated

291
00:10:23,279 --> 00:10:25,200
even if it's a local cache it's going to

292
00:10:25,200 --> 00:10:26,640
be updated

293
00:10:26,640 --> 00:10:29,120
and finally the cherry on the cake is

294
00:10:29,120 --> 00:10:30,000
that

295
00:10:30,000 --> 00:10:32,720
since you're using apollo this local

296
00:10:32,720 --> 00:10:34,640
state is going to be inspectable

297
00:10:34,640 --> 00:10:36,399
and all the query that has been done

298
00:10:36,399 --> 00:10:37,839
that

299
00:10:37,839 --> 00:10:39,360
even for the local state are going to be

300
00:10:39,360 --> 00:10:41,040
inspectable in being

301
00:10:41,040 --> 00:10:42,480
being you're going to be able to debug

302
00:10:42,480 --> 00:10:46,240
them using the apple client devtool

303
00:10:46,240 --> 00:10:48,720
so that's all for the state management

304
00:10:48,720 --> 00:10:49,839
let's now

305
00:10:49,839 --> 00:10:51,920
stay in the front end but on another

306
00:10:51,920 --> 00:10:53,200
subject with

307
00:10:53,200 --> 00:10:55,519
another innovation in the graphql

308
00:10:55,519 --> 00:10:56,720
landscape

309
00:10:56,720 --> 00:10:58,640
but in web in the web ecosystem on the

310
00:10:58,640 --> 00:11:00,880
front end which are graphql generation

311
00:11:00,880 --> 00:11:03,279
powers

312
00:11:03,360 --> 00:11:05,760
so when the graphql specification and

313
00:11:05,760 --> 00:11:07,760
the in the public release was made i was

314
00:11:07,760 --> 00:11:09,440
really interested into the graphql

315
00:11:09,440 --> 00:11:10,720
introspection

316
00:11:10,720 --> 00:11:13,040
and as you know i was thinking for a

317
00:11:13,040 --> 00:11:14,000
long time that it was one

318
00:11:14,000 --> 00:11:16,000
one of the most powerful but underrated

319
00:11:16,000 --> 00:11:17,200
feature of the language

320
00:11:17,200 --> 00:11:19,760
it may be misunderstood it was not super

321
00:11:19,760 --> 00:11:20,560
explain it

322
00:11:20,560 --> 00:11:23,600
super well explaining in documentation

323
00:11:23,600 --> 00:11:26,160
what could be done with it and the thing

324
00:11:26,160 --> 00:11:26,959
is that

325
00:11:26,959 --> 00:11:29,839
in the last years we had the rise of at

326
00:11:29,839 --> 00:11:31,519
least almost the same time of typescript

327
00:11:31,519 --> 00:11:32,480
and graphql

328
00:11:32,480 --> 00:11:34,480
and a real passion for the javascript

329
00:11:34,480 --> 00:11:35,920
ecosystem

330
00:11:35,920 --> 00:11:39,360
for types and this brought a lot of

331
00:11:39,360 --> 00:11:42,720
projects using graphql introspection

332
00:11:42,720 --> 00:11:46,480
for generation one of the most famous

333
00:11:46,480 --> 00:11:49,040
project that we have right now that is a

334
00:11:49,040 --> 00:11:50,639
link between typescript or

335
00:11:50,639 --> 00:11:52,800
that is around generation when it comes

336
00:11:52,800 --> 00:11:53,839
to graphql

337
00:11:53,839 --> 00:11:57,279
is graphql code generator so given the

338
00:11:57,279 --> 00:12:00,079
graphql schema is going to provide the

339
00:12:00,079 --> 00:12:01,519
setup tool to generate all the

340
00:12:01,519 --> 00:12:03,360
typescript types for you

341
00:12:03,360 --> 00:12:06,000
but also generate chord which is super

342
00:12:06,000 --> 00:12:08,000
impressive because you can generate

343
00:12:08,000 --> 00:12:10,959
the react apollo hooks for you and the

344
00:12:10,959 --> 00:12:12,639
associated types

345
00:12:12,639 --> 00:12:14,560
so which pro which prevents you to have

346
00:12:14,560 --> 00:12:15,839
all the bowler play that you have to

347
00:12:15,839 --> 00:12:16,959
write all the time

348
00:12:16,959 --> 00:12:18,880
which is quite repetitive and it works

349
00:12:18,880 --> 00:12:20,959
also for other libraries on not only

350
00:12:20,959 --> 00:12:21,680
apollo

351
00:12:21,680 --> 00:12:25,040
like urql and for other types like flow

352
00:12:25,040 --> 00:12:28,000
java kotlin

353
00:12:29,760 --> 00:12:32,560
so here we have a schema so we have a

354
00:12:32,560 --> 00:12:34,079
schema when we have a query the only

355
00:12:34,079 --> 00:12:35,200
query is me that

356
00:12:35,200 --> 00:12:37,040
allows to get the current user which

357
00:12:37,040 --> 00:12:38,320
have user type

358
00:12:38,320 --> 00:12:40,720
and here just below you have a document

359
00:12:40,720 --> 00:12:41,680
which is used

360
00:12:41,680 --> 00:12:43,360
on our application the current user

361
00:12:43,360 --> 00:12:44,720
query

362
00:12:44,720 --> 00:12:48,800
and this is the generated code

363
00:12:48,800 --> 00:12:51,040
so we have all the typescript types the

364
00:12:51,040 --> 00:12:52,079
user types

365
00:12:52,079 --> 00:12:53,680
the type of the query and then we have

366
00:12:53,680 --> 00:12:55,440
the hooks generation

367
00:12:55,440 --> 00:12:56,800
and then in our application we're going

368
00:12:56,800 --> 00:12:59,040
to be able to use the use current user

369
00:12:59,040 --> 00:12:59,680
query

370
00:12:59,680 --> 00:13:02,639
hook in order to query the data in our

371
00:13:02,639 --> 00:13:04,399
application we won't have to

372
00:13:04,399 --> 00:13:07,200
manage all the complexity to maintain

373
00:13:07,200 --> 00:13:09,120
the types and also to bind them

374
00:13:09,120 --> 00:13:11,600
when it comes to for example providing

375
00:13:11,600 --> 00:13:14,000
the generics etc etc it will be

376
00:13:14,000 --> 00:13:16,639
automatically generated very easy to

377
00:13:16,639 --> 00:13:17,200
maintain

378
00:13:17,200 --> 00:13:20,800
and very strong because always depending

379
00:13:20,800 --> 00:13:22,720
on the real schema definition of the

380
00:13:22,720 --> 00:13:25,040
data

381
00:13:25,279 --> 00:13:28,560
another more advanced different but

382
00:13:28,560 --> 00:13:28,959
quite

383
00:13:28,959 --> 00:13:32,560
linked similar example of usage of

384
00:13:32,560 --> 00:13:36,000
graphql in suspension power is

385
00:13:36,000 --> 00:13:38,320
a library that allows to do graphql

386
00:13:38,320 --> 00:13:39,519
query without

387
00:13:39,519 --> 00:13:43,040
actually providing a query

388
00:13:43,199 --> 00:13:46,800
so gqls is a project that

389
00:13:46,800 --> 00:13:48,800
as you can see on the left we have code

390
00:13:48,800 --> 00:13:50,639
we have just a user component

391
00:13:50,639 --> 00:13:52,320
and every component is wrapped into a

392
00:13:52,320 --> 00:13:54,639
graphql function

393
00:13:54,639 --> 00:13:56,959
in here we have a global query value

394
00:13:56,959 --> 00:13:58,320
it's not really global it's like

395
00:13:58,320 --> 00:14:01,440
local query value and basically what it

396
00:14:01,440 --> 00:14:02,079
does is that

397
00:14:02,079 --> 00:14:04,720
it looks at all the properties that are

398
00:14:04,720 --> 00:14:05,440
being used

399
00:14:05,440 --> 00:14:08,320
have been used below query inside query

400
00:14:08,320 --> 00:14:08,800
and

401
00:14:08,800 --> 00:14:11,120
infer what is the graphql query that

402
00:14:11,120 --> 00:14:12,800
needs to be

403
00:14:12,800 --> 00:14:16,320
called so this is another example

404
00:14:16,320 --> 00:14:18,800
it's not production ready yet but it's

405
00:14:18,800 --> 00:14:20,399
kind of show also the

406
00:14:20,399 --> 00:14:21,839
different kind of thing that you can do

407
00:14:21,839 --> 00:14:24,639
with graphql

408
00:14:25,760 --> 00:14:29,199
and on the side note i also had

409
00:14:29,199 --> 00:14:32,320
my kind of fun times with graphql and i

410
00:14:32,320 --> 00:14:34,320
did a library that allows to generate

411
00:14:34,320 --> 00:14:35,120
react from

412
00:14:35,120 --> 00:14:38,000
given graphql mutation because since we

413
00:14:38,000 --> 00:14:40,320
know what kind of data we can provide

414
00:14:40,320 --> 00:14:42,079
we can remove a lot of boilerplates

415
00:14:42,079 --> 00:14:44,399
especially when it comes to forms

416
00:14:44,399 --> 00:14:46,639
so here for example we have frontier

417
00:14:46,639 --> 00:14:48,320
which is the name of the library

418
00:14:48,320 --> 00:14:50,399
we have a ui kit and ui kit is just

419
00:14:50,399 --> 00:14:52,079
objects that define

420
00:14:52,079 --> 00:14:54,959
for each graphql type what is the

421
00:14:54,959 --> 00:14:56,079
component to use

422
00:14:56,079 --> 00:14:57,760
we have the apollo clients we have the

423
00:14:57,760 --> 00:15:00,240
mutation we instantiate the components

424
00:15:00,240 --> 00:15:03,199
and it creates the form and and this is

425
00:15:03,199 --> 00:15:04,320
only working

426
00:15:04,320 --> 00:15:06,959
because of the graphql language because

427
00:15:06,959 --> 00:15:07,680
it's

428
00:15:07,680 --> 00:15:12,079
tight and easy to introspect

429
00:15:12,079 --> 00:15:15,440
so to sum up

430
00:15:15,440 --> 00:15:18,160
graphql special power introspection

431
00:15:18,160 --> 00:15:18,959
brings us

432
00:15:18,959 --> 00:15:22,720
stronger type a bootstrapping of client

433
00:15:22,720 --> 00:15:25,120
configuration and overall

434
00:15:25,120 --> 00:15:28,399
better developer experience

435
00:15:30,720 --> 00:15:32,959
okay let's now totally quit the front

436
00:15:32,959 --> 00:15:35,120
end and talk about what graphql

437
00:15:35,120 --> 00:15:37,440
is bringing right now to the backend

438
00:15:37,440 --> 00:15:40,160
world by seeing a use case of graphql

439
00:15:40,160 --> 00:15:43,279
for back-end to back-end

440
00:15:44,399 --> 00:15:46,399
so when we talk about client server most

441
00:15:46,399 --> 00:15:48,320
of the time people think about like okay

442
00:15:48,320 --> 00:15:50,079
client is front-end and server is

443
00:15:50,079 --> 00:15:52,480
back-end but in fact

444
00:15:52,480 --> 00:15:55,839
in the reward we can have back-end

445
00:15:55,839 --> 00:15:57,680
calling other back-end and this is why i

446
00:15:57,680 --> 00:15:58,160
call

447
00:15:58,160 --> 00:16:01,680
back-end to back-end so i want to show

448
00:16:01,680 --> 00:16:03,360
you

449
00:16:03,360 --> 00:16:05,440
sharing with you a story i had in my

450
00:16:05,440 --> 00:16:07,519
previous work at algolia

451
00:16:07,519 --> 00:16:09,440
when we use graphql to have a more

452
00:16:09,440 --> 00:16:10,800
flexible

453
00:16:10,800 --> 00:16:15,440
architecture so algoria is a search

454
00:16:15,440 --> 00:16:17,920
api services so we store some data in

455
00:16:17,920 --> 00:16:19,360
order to put them in

456
00:16:19,360 --> 00:16:21,839
such indices and we add an integration

457
00:16:21,839 --> 00:16:23,519
with shopify which is like an e-commerce

458
00:16:23,519 --> 00:16:24,079
platform

459
00:16:24,079 --> 00:16:26,079
install data about like products and

460
00:16:26,079 --> 00:16:27,199
inventory

461
00:16:27,199 --> 00:16:29,199
and we had an indexer that was taking

462
00:16:29,199 --> 00:16:31,279
all the product and put them in algoria

463
00:16:31,279 --> 00:16:34,000
and when we were indexing those products

464
00:16:34,000 --> 00:16:36,399
we needed to put to make requests

465
00:16:36,399 --> 00:16:38,880
to the shopify api in order to get meta

466
00:16:38,880 --> 00:16:39,839
properties

467
00:16:39,839 --> 00:16:42,240
called meta fields and then this for

468
00:16:42,240 --> 00:16:44,000
each product

469
00:16:44,000 --> 00:16:46,720
the issue that was that the shopify rest

470
00:16:46,720 --> 00:16:48,480
api was very limited

471
00:16:48,480 --> 00:16:51,519
and it was what we called request based

472
00:16:51,519 --> 00:16:53,759
limits meaning that we we could do

473
00:16:53,759 --> 00:16:55,759
maximum for each shop

474
00:16:55,759 --> 00:16:57,839
two requests per second and this was

475
00:16:57,839 --> 00:17:00,880
becoming a very very big issue for us

476
00:17:00,880 --> 00:17:02,480
in terms of performances especially for

477
00:17:02,480 --> 00:17:03,920
big clients or for clearance that have

478
00:17:03,920 --> 00:17:05,359
like a lot of flash sales

479
00:17:05,359 --> 00:17:07,439
so we need to have another solution so

480
00:17:07,439 --> 00:17:09,280
we start to look at

481
00:17:09,280 --> 00:17:13,039
the shopify graphql public graphql api

482
00:17:13,039 --> 00:17:15,359
especially because of a very different

483
00:17:15,359 --> 00:17:17,039
kind of rate limiting

484
00:17:17,039 --> 00:17:20,400
by design thanks to the the structure

485
00:17:20,400 --> 00:17:21,439
and the types

486
00:17:21,439 --> 00:17:23,919
and the way that graphql is working and

487
00:17:23,919 --> 00:17:25,439
what they provided is a different what

488
00:17:25,439 --> 00:17:26,400
we called

489
00:17:26,400 --> 00:17:29,360
calculated query cost rate limiting

490
00:17:29,360 --> 00:17:31,520
where when you do a query

491
00:17:31,520 --> 00:17:34,080
you had to count you have one point

492
00:17:34,080 --> 00:17:35,840
count for every field that you query in

493
00:17:35,840 --> 00:17:36,880
your query

494
00:17:36,880 --> 00:17:38,559
and then directly meeting was like okay

495
00:17:38,559 --> 00:17:41,840
you can use 50 point per second

496
00:17:41,840 --> 00:17:44,240
so let's have a so we decided to give a

497
00:17:44,240 --> 00:17:45,280
try to this

498
00:17:45,280 --> 00:17:48,080
so let's take a look here we are getting

499
00:17:48,080 --> 00:17:48,880
a product

500
00:17:48,880 --> 00:17:52,400
from shopify and each so as i said each

501
00:17:52,400 --> 00:17:53,520
field is one point

502
00:17:53,520 --> 00:17:56,000
but when when you nest the next thing is

503
00:17:56,000 --> 00:17:57,120
multiplicator

504
00:17:57,120 --> 00:18:00,000
so what does it mean here for example we

505
00:18:00,000 --> 00:18:01,840
have one point what is the cost of this

506
00:18:01,840 --> 00:18:02,640
query

507
00:18:02,640 --> 00:18:05,679
one point because product dot id

508
00:18:05,679 --> 00:18:07,840
and then each meta field has four

509
00:18:07,840 --> 00:18:09,600
properties so it's four points but we

510
00:18:09,600 --> 00:18:11,120
are getting ten of them

511
00:18:11,120 --> 00:18:13,440
so it's ten x four plus one forty 41

512
00:18:13,440 --> 00:18:15,760
points

513
00:18:16,400 --> 00:18:18,240
so we do this query and we get this

514
00:18:18,240 --> 00:18:19,760
answer

515
00:18:19,760 --> 00:18:21,520
so we get the data of course because

516
00:18:21,520 --> 00:18:23,280
it's still graphql and here we have a

517
00:18:23,280 --> 00:18:25,200
product in this project in fact had only

518
00:18:25,200 --> 00:18:26,799
one meta field

519
00:18:26,799 --> 00:18:29,679
and besides data we add this extension

520
00:18:29,679 --> 00:18:31,200
that provides some information about the

521
00:18:31,200 --> 00:18:32,480
current state

522
00:18:32,480 --> 00:18:34,960
of the throttling and basically what

523
00:18:34,960 --> 00:18:35,760
shopify said

524
00:18:35,760 --> 00:18:38,799
that okay the maximum cost of this query

525
00:18:38,799 --> 00:18:42,000
by definition the static cost was 41

526
00:18:42,000 --> 00:18:44,480
given the number of field theoretically

527
00:18:44,480 --> 00:18:45,280
you could get

528
00:18:45,280 --> 00:18:47,200
but in fact there was only one meta

529
00:18:47,200 --> 00:18:48,400
field so the cost was

530
00:18:48,400 --> 00:18:50,240
four property of the metaphysics one of

531
00:18:50,240 --> 00:18:51,679
the products of five

532
00:18:51,679 --> 00:18:54,160
so this query actually costs really five

533
00:18:54,160 --> 00:18:54,880
points

534
00:18:54,880 --> 00:18:56,880
and by the way this is your throttling

535
00:18:56,880 --> 00:18:59,760
status right now

536
00:18:59,919 --> 00:19:01,840
so this for us was very very very

537
00:19:01,840 --> 00:19:03,919
insightful because we were able to build

538
00:19:03,919 --> 00:19:05,360
what we call the flexible throttling

539
00:19:05,360 --> 00:19:08,080
indexing system using this graphql api

540
00:19:08,080 --> 00:19:10,880
and the algorithm in the big line was

541
00:19:10,880 --> 00:19:11,840
the following

542
00:19:11,840 --> 00:19:13,760
for each customer we add the number of

543
00:19:13,760 --> 00:19:15,919
points assigned

544
00:19:15,919 --> 00:19:17,520
we would add a maximum for example to

545
00:19:17,520 --> 00:19:19,360
say as we saw

546
00:19:19,360 --> 00:19:23,440
of uh yeah okay of one thousand

547
00:19:23,440 --> 00:19:25,360
so every time we had to invest a product

548
00:19:25,360 --> 00:19:26,960
we look at the score

549
00:19:26,960 --> 00:19:29,440
we compute the query static maximum cost

550
00:19:29,440 --> 00:19:30,960
and we see if we have enough points

551
00:19:30,960 --> 00:19:33,200
if we can we do the query and then after

552
00:19:33,200 --> 00:19:35,120
each query we update the shop score with

553
00:19:35,120 --> 00:19:36,400
the actual

554
00:19:36,400 --> 00:19:39,760
real cost of the query and this

555
00:19:39,760 --> 00:19:43,120
system allowed us to to go from two four

556
00:19:43,120 --> 00:19:44,480
products per second

557
00:19:44,480 --> 00:19:48,640
to ten to fifty product possible

558
00:19:49,600 --> 00:19:51,760
a lot of other companies are switching

559
00:19:51,760 --> 00:19:54,400
to public graphql api and provide this

560
00:19:54,400 --> 00:19:57,039
calculated cost rate limiting which is

561
00:19:57,039 --> 00:19:58,160
more flexible

562
00:19:58,160 --> 00:20:00,080
shopify is one of them there is also

563
00:20:00,080 --> 00:20:03,199
github and yelp

564
00:20:03,760 --> 00:20:06,960
so graphql brought also innovation

565
00:20:06,960 --> 00:20:09,440
in the backend to back end what are the

566
00:20:09,440 --> 00:20:11,280
main takeaway so as we saw

567
00:20:11,280 --> 00:20:13,120
there is this use case for the poll of

568
00:20:13,120 --> 00:20:14,400
having new kind

569
00:20:14,400 --> 00:20:17,919
of design of api and especially when it

570
00:20:17,919 --> 00:20:19,200
comes to rate limiting

571
00:20:19,200 --> 00:20:21,039
because of the type system in before

572
00:20:21,039 --> 00:20:23,440
because of the thanks to the granularity

573
00:20:23,440 --> 00:20:24,400
of the

574
00:20:24,400 --> 00:20:27,760
schema itself but also there is another

575
00:20:27,760 --> 00:20:29,760
thing i didn't have time to talk here

576
00:20:29,760 --> 00:20:32,080
it's also graphql when used in the

577
00:20:32,080 --> 00:20:34,159
backend to backend helps to be

578
00:20:34,159 --> 00:20:36,559
more maintainable data pipeline because

579
00:20:36,559 --> 00:20:37,200
we can have

580
00:20:37,200 --> 00:20:39,840
abstraction of what we query especially

581
00:20:39,840 --> 00:20:41,679
thanks to a new project that is that

582
00:20:41,679 --> 00:20:42,720
just arrived

583
00:20:42,720 --> 00:20:45,360
which is called graphql mesh and graphql

584
00:20:45,360 --> 00:20:45,840
nash

585
00:20:45,840 --> 00:20:48,559
is a project that allows you to query

586
00:20:48,559 --> 00:20:50,799
with graphql any type of api

587
00:20:50,799 --> 00:20:54,400
either it's graphql grpc swap or swagger

588
00:20:54,400 --> 00:20:57,280
which is rest so this is super nice

589
00:20:57,280 --> 00:20:59,120
because you don't have to

590
00:20:59,120 --> 00:21:00,960
worry about anything about the

591
00:21:00,960 --> 00:21:02,559
implementation of the api that you query

592
00:21:02,559 --> 00:21:04,240
you're just using graphql to create

593
00:21:04,240 --> 00:21:06,640
anything

594
00:21:08,240 --> 00:21:10,960
okay let's wrap up on the last point on

595
00:21:10,960 --> 00:21:12,159
the resolverless

596
00:21:12,159 --> 00:21:16,559
graphql still on the backend

597
00:21:16,559 --> 00:21:18,559
so what is the common point between

598
00:21:18,559 --> 00:21:20,480
graphql and sql

599
00:21:20,480 --> 00:21:23,840
except they are like off but one letter

600
00:21:23,840 --> 00:21:26,240
the common point is azure so i know it's

601
00:21:26,240 --> 00:21:27,440
not a new project

602
00:21:27,440 --> 00:21:31,280
but i think it's still a huge innovation

603
00:21:31,280 --> 00:21:34,400
in back end in servers

604
00:21:34,400 --> 00:21:37,760
so ashura is a is a

605
00:21:37,760 --> 00:21:39,520
not a product but it's a open source

606
00:21:39,520 --> 00:21:41,840
project that translates graphql

607
00:21:41,840 --> 00:21:44,640
app abstract syntax tree so queries into

608
00:21:44,640 --> 00:21:45,280
sql

609
00:21:45,280 --> 00:21:49,120
app263 ast on the flight meaning that

610
00:21:49,120 --> 00:21:50,799
it's not generating resolver it's not

611
00:21:50,799 --> 00:21:53,200
generating code that then run sql it

612
00:21:53,200 --> 00:21:53,760
takes

613
00:21:53,760 --> 00:21:57,200
graphql and translate it to sql directly

614
00:21:57,200 --> 00:22:01,440
and this provides super fast execution

615
00:22:01,440 --> 00:22:04,080
of query and it works out of the box on

616
00:22:04,080 --> 00:22:05,679
existing database

617
00:22:05,679 --> 00:22:07,919
so i'm going to say okay yeah it's nice

618
00:22:07,919 --> 00:22:09,120
it's super nice to do like

619
00:22:09,120 --> 00:22:11,520
small tests some small plc but it's not

620
00:22:11,520 --> 00:22:12,880
enough in terms of feature

621
00:22:12,880 --> 00:22:15,440
it's i'm pretty sure it's not stable

622
00:22:15,440 --> 00:22:16,880
that's not true

623
00:22:16,880 --> 00:22:18,799
actually ashrae is very stable it's used

624
00:22:18,799 --> 00:22:21,200
by a lot of very big company

625
00:22:21,200 --> 00:22:22,880
it's very good in performance it

626
00:22:22,880 --> 00:22:25,919
provides also access controller support

627
00:22:25,919 --> 00:22:27,600
advanced authentication authorization

628
00:22:27,600 --> 00:22:29,600
using individually

629
00:22:29,600 --> 00:22:31,200
remote schema support meaning that you

630
00:22:31,200 --> 00:22:32,880
can compose

631
00:22:32,880 --> 00:22:35,440
with ashrae you can you can create your

632
00:22:35,440 --> 00:22:36,880
ashra instance

633
00:22:36,880 --> 00:22:39,919
server and having it plugged on many

634
00:22:39,919 --> 00:22:41,520
progress instance but also

635
00:22:41,520 --> 00:22:44,799
many other graphql api so this is super

636
00:22:44,799 --> 00:22:46,159
powerful as one

637
00:22:46,159 --> 00:22:48,000
kind of apollo federation of our

638
00:22:48,000 --> 00:22:49,520
progress

639
00:22:49,520 --> 00:22:51,520
it supports subscription which is not

640
00:22:51,520 --> 00:22:54,720
the case of apollo federation for now

641
00:22:54,720 --> 00:22:58,480
you can try your web books and bonus

642
00:22:58,480 --> 00:23:00,240
ashrae provides provide one click

643
00:23:00,240 --> 00:23:02,960
install on most cloud provider at ws

644
00:23:02,960 --> 00:23:05,600
or iraku

645
00:23:06,480 --> 00:23:08,799
so let's have a conclusion of those

646
00:23:08,799 --> 00:23:09,919
innovations

647
00:23:09,919 --> 00:23:12,080
graphql is definitely more than just a

648
00:23:12,080 --> 00:23:15,200
front-end query api's

649
00:23:15,200 --> 00:23:18,640
language in libraries first

650
00:23:18,640 --> 00:23:21,440
we just saw that apollo graphql and i

651
00:23:21,440 --> 00:23:22,960
heard soon

652
00:23:22,960 --> 00:23:25,280
at least relay is considering also doing

653
00:23:25,280 --> 00:23:27,520
it is a reliable

654
00:23:27,520 --> 00:23:29,440
for local stack management it's very

655
00:23:29,440 --> 00:23:31,600
very powerful

656
00:23:31,600 --> 00:23:33,520
graphql is bringing a lot of flexibility

657
00:23:33,520 --> 00:23:34,960
when it comes to back end to back end

658
00:23:34,960 --> 00:23:36,559
it's only the beginning

659
00:23:36,559 --> 00:23:39,039
because not that much company migrated

660
00:23:39,039 --> 00:23:42,720
to public graphql api

661
00:23:43,120 --> 00:23:46,000
graphql introspection brought a lot of

662
00:23:46,000 --> 00:23:47,919
tool on front-end when it comes to

663
00:23:47,919 --> 00:23:51,520
typescript generation types generation

664
00:23:51,520 --> 00:23:53,360
code generation and i'm pretty sure

665
00:23:53,360 --> 00:23:55,760
we're gonna have way more use case

666
00:23:55,760 --> 00:23:57,279
that's gonna improve the developer

667
00:23:57,279 --> 00:23:59,760
experience

668
00:23:59,840 --> 00:24:03,360
and then we can even have now graphql

669
00:24:03,360 --> 00:24:04,799
without having to

670
00:24:04,799 --> 00:24:07,200
write the resolver that works out of the

671
00:24:07,200 --> 00:24:09,120
box on existing database or

672
00:24:09,120 --> 00:24:11,840
existing schema or you can even use

673
00:24:11,840 --> 00:24:13,440
graphcode for anything

674
00:24:13,440 --> 00:24:15,360
using graphcreate graphql mesh to create

675
00:24:15,360 --> 00:24:19,520
any kind of data

676
00:24:19,520 --> 00:24:22,159
thank you very much uh you can find me

677
00:24:22,159 --> 00:24:23,200
so i hope you liked

678
00:24:23,200 --> 00:24:24,880
the the presentation that you learned

679
00:24:24,880 --> 00:24:26,640
something about graphql that you have

680
00:24:26,640 --> 00:24:29,760
you are as excited by me as me

681
00:24:29,760 --> 00:24:32,799
um by graphql and what it's going to

682
00:24:32,799 --> 00:24:33,440
bring

683
00:24:33,440 --> 00:24:36,320
in the future you can find all my uh you

684
00:24:36,320 --> 00:24:38,559
can find the slide on magnus's profile

685
00:24:38,559 --> 00:24:41,520
also all my previous presentation follow

686
00:24:41,520 --> 00:24:43,520
me on twitter if you want to

687
00:24:43,520 --> 00:24:44,720
and also i'm going to write some

688
00:24:44,720 --> 00:24:47,200
articles about the graphql soon

689
00:24:47,200 --> 00:24:48,480
especially one of the on this

690
00:24:48,480 --> 00:24:50,799
presentation but with

691
00:24:50,799 --> 00:24:54,880
way more information thank you very much

692
00:24:54,880 --> 00:24:56,880
well charlie that's that's wonderful

693
00:24:56,880 --> 00:24:58,320
thank you so much for

694
00:24:58,320 --> 00:25:00,400
your time i know it's pretty late in the

695
00:25:00,400 --> 00:25:01,679
night as well over

696
00:25:01,679 --> 00:25:04,000
here so thanks thanks so much for

697
00:25:04,000 --> 00:25:06,080
spending the time for us

698
00:25:06,080 --> 00:25:09,760
uh i have one question here from uh aman

699
00:25:09,760 --> 00:25:13,279
um can we use apollo

700
00:25:13,279 --> 00:25:16,720
graphql with view for

701
00:25:16,720 --> 00:25:20,240
state management in the client side

702
00:25:20,240 --> 00:25:23,279
thank you jesus let me check i don't

703
00:25:23,279 --> 00:25:24,400
have the

704
00:25:24,400 --> 00:25:29,760
answer i guess it's really in the dark

705
00:25:29,760 --> 00:25:33,520
i'm not sure but we have to check uh

706
00:25:33,520 --> 00:25:36,559
yeah so okay i'm on the dock apparently

707
00:25:36,559 --> 00:25:37,919
there is something

708
00:25:37,919 --> 00:25:40,159
yeah you can use uh look what they call

709
00:25:40,159 --> 00:25:42,720
local state with a apollo view

710
00:25:42,720 --> 00:25:45,200
i'm not sure you have the same features

711
00:25:45,200 --> 00:25:46,720
as advanced

712
00:25:46,720 --> 00:25:50,480
but uh yeah it exists

713
00:25:50,480 --> 00:25:52,080
yeah it apparently is exactly the same

714
00:25:52,080 --> 00:25:54,320
as apollo react it's the same core

715
00:25:54,320 --> 00:25:57,440
so yes you can okay

716
00:25:57,440 --> 00:25:59,440
and and somebody else is putting a note

717
00:25:59,440 --> 00:26:00,480
here uh can't

718
00:26:00,480 --> 00:26:04,000
wait for your articles um that's the con

719
00:26:04,000 --> 00:26:04,960
thank you again

720
00:26:04,960 --> 00:26:06,960
yeah thank you uh and i'm in since

721
00:26:06,960 --> 00:26:08,720
thanks as well

722
00:26:08,720 --> 00:26:10,640
let me just give it a minute to see if

723
00:26:10,640 --> 00:26:12,240
there are any more questions

724
00:26:12,240 --> 00:26:25,840
or follow-up questions yep of course

725
00:26:27,840 --> 00:26:29,679
while we are waiting i'll i'll ask one

726
00:26:29,679 --> 00:26:31,039
question uh

727
00:26:31,039 --> 00:26:33,360
if if i am absolutely new to this and

728
00:26:33,360 --> 00:26:34,960
i'm considering whether to

729
00:26:34,960 --> 00:26:37,279
use it or not what would be some

730
00:26:37,279 --> 00:26:38,159
situation where

731
00:26:38,159 --> 00:26:41,200
maybe i should rethink about using

732
00:26:41,200 --> 00:26:45,200
and not jump into using uh graphql

733
00:26:45,200 --> 00:26:48,799
so what kind of you want like

734
00:26:48,799 --> 00:26:50,720
example of what would be the usage of

735
00:26:50,720 --> 00:26:52,400
yeah is there a reason i shouldn't use

736
00:26:52,400 --> 00:26:52,720
it

737
00:26:52,720 --> 00:26:55,840
at any time um

738
00:26:55,840 --> 00:26:58,559
i would say the bad reason to use

739
00:26:58,559 --> 00:26:59,600
graphql is like

740
00:26:59,600 --> 00:27:01,120
thinking that it's going to solve all

741
00:27:01,120 --> 00:27:03,200
the performance problem

742
00:27:03,200 --> 00:27:05,520
because it's not a feature of graphql it

743
00:27:05,520 --> 00:27:07,279
depends of how you use it so it's not

744
00:27:07,279 --> 00:27:08,960
like a magical

745
00:27:08,960 --> 00:27:11,200
thing

746
00:27:12,000 --> 00:27:15,279
what else it i think it really depends

747
00:27:15,279 --> 00:27:17,600
also of the time you have to invest

748
00:27:17,600 --> 00:27:20,000
i would say because we have to rewrite a

749
00:27:20,000 --> 00:27:22,080
lot of things on the front end

750
00:27:22,080 --> 00:27:25,760
but things i mean apollo team

751
00:27:25,760 --> 00:27:27,600
made like a really awesome work when it

752
00:27:27,600 --> 00:27:28,880
comes to have like a

753
00:27:28,880 --> 00:27:31,840
incremental adoption because you can you

754
00:27:31,840 --> 00:27:34,080
can actually use

755
00:27:34,080 --> 00:27:36,320
okay you can use apollo graphql clients

756
00:27:36,320 --> 00:27:37,200
to query

757
00:27:37,200 --> 00:27:40,240
rest api it works so you can have like a

758
00:27:40,240 --> 00:27:41,520
kind of an ebraid

759
00:27:41,520 --> 00:27:42,880
implementation when you have like part

760
00:27:42,880 --> 00:27:44,880
of your api that is like still in the

761
00:27:44,880 --> 00:27:46,720
old implementation in rest

762
00:27:46,720 --> 00:27:48,720
and part of your ipad is that is on

763
00:27:48,720 --> 00:27:49,760
graphql

764
00:27:49,760 --> 00:27:52,000
but i would say that graphql the the

765
00:27:52,000 --> 00:27:53,200
hardest thing is that you have to

766
00:27:53,200 --> 00:27:54,960
rewrite your backend which is super

767
00:27:54,960 --> 00:27:56,320
expensive

768
00:27:56,320 --> 00:27:58,080
but there is a lot of tool that comes

769
00:27:58,080 --> 00:28:00,159
like graphql mesh that allows to you to

770
00:28:00,159 --> 00:28:02,320
put like a gate away in front of it

771
00:28:02,320 --> 00:28:03,679
so i would say it really depends of your

772
00:28:03,679 --> 00:28:06,240
use case if i would say use graphql if

773
00:28:06,240 --> 00:28:06,559
you

774
00:28:06,559 --> 00:28:08,000
you feel like that you're struggling

775
00:28:08,000 --> 00:28:10,000
with your state management

776
00:28:10,000 --> 00:28:11,679
with keeping your data up to date with

777
00:28:11,679 --> 00:28:13,679
performances because of the stake

778
00:28:13,679 --> 00:28:14,320
management

779
00:28:14,320 --> 00:28:17,120
not because of your back end even if you

780
00:28:17,120 --> 00:28:18,000
can help

781
00:28:18,000 --> 00:28:19,679
or if you feel that you're your fronted

782
00:28:19,679 --> 00:28:21,039
application every time you load it

783
00:28:21,039 --> 00:28:22,240
you're loading like you're

784
00:28:22,240 --> 00:28:24,559
off of your database in memory because

785
00:28:24,559 --> 00:28:26,880
anyway it's too complicated to

786
00:28:26,880 --> 00:28:30,399
really query what you need um

787
00:28:30,399 --> 00:28:33,200
we have about 60 seconds with us so uh

788
00:28:33,200 --> 00:28:34,880
one follow-up question

789
00:28:34,880 --> 00:28:38,880
um does graphql

790
00:28:38,880 --> 00:28:41,600
is for both front-end and back-end

791
00:28:41,600 --> 00:28:43,679
development

792
00:28:43,679 --> 00:28:47,360
yes uh i don't know if i can get like an

793
00:28:47,360 --> 00:28:48,080
example but

794
00:28:48,080 --> 00:28:50,399
yeah you can use okay yeah so definitely

795
00:28:50,399 --> 00:28:51,279
for front-end yeah

796
00:28:51,279 --> 00:28:52,799
it's made for front-end it's made from

797
00:28:52,799 --> 00:28:55,039
front-end and mobile first

798
00:28:55,039 --> 00:28:56,640
and on the back-end you can use it in

799
00:28:56,640 --> 00:28:58,640
certain use case like i showed when if

800
00:28:58,640 --> 00:29:00,480
you have to create a very complex set of

801
00:29:00,480 --> 00:29:01,360
data

802
00:29:01,360 --> 00:29:03,120
and basically your back end is like kind

803
00:29:03,120 --> 00:29:05,520
of lost in all the quenching of data you

804
00:29:05,520 --> 00:29:06,080
can

805
00:29:06,080 --> 00:29:08,960
put this responsibility of crunching the

806
00:29:08,960 --> 00:29:09,600
data

807
00:29:09,600 --> 00:29:11,600
and doing all the mapping inside the

808
00:29:11,600 --> 00:29:13,440
either a graphql gateway

809
00:29:13,440 --> 00:29:16,480
or the graphql api itself so yes

810
00:29:16,480 --> 00:29:18,799
very good well thank you so much uh

811
00:29:18,799 --> 00:29:20,240
again thanks for your time and

812
00:29:20,240 --> 00:29:22,480
thanks for being safe thank you yeah and

813
00:29:22,480 --> 00:29:24,840
thanks everyone

814
00:29:24,840 --> 00:29:27,840
bye

