1
00:00:00,000 --> 00:00:02,960
talk about garbage collections i can't

2
00:00:02,960 --> 00:00:03,520
speak

3
00:00:03,520 --> 00:00:06,560
um and gc's in their jvm so

4
00:00:06,560 --> 00:00:08,960
if you want to share your screen we'll

5
00:00:08,960 --> 00:00:10,800
sync you up and get you started

6
00:00:10,800 --> 00:00:14,719
and not waste any time sounds good to me

7
00:00:14,719 --> 00:00:18,080
so hopefully you can see my screen

8
00:00:20,640 --> 00:00:23,039
you can see your screen and it's over to

9
00:00:23,039 --> 00:00:23,680
you

10
00:00:23,680 --> 00:00:25,359
excellent thanks a lot mark so hi

11
00:00:25,359 --> 00:00:27,199
everyone my name is alex blew it for

12
00:00:27,199 --> 00:00:28,800
those of you who don't know me i've been

13
00:00:28,800 --> 00:00:30,640
hanging around in java

14
00:00:30,640 --> 00:00:32,719
for quite a long time picked it up when

15
00:00:32,719 --> 00:00:34,960
it first came out in the 1.0 release

16
00:00:34,960 --> 00:00:36,399
and then on and off over the years i've

17
00:00:36,399 --> 00:00:38,079
been using java for

18
00:00:38,079 --> 00:00:39,360
a variety of different things in a

19
00:00:39,360 --> 00:00:41,040
variety of different companies most

20
00:00:41,040 --> 00:00:41,680
recently i

21
00:00:41,680 --> 00:00:44,800
write for info queue and you'll see some

22
00:00:44,800 --> 00:00:46,640
of my java posts there

23
00:00:46,640 --> 00:00:49,200
but for my commercial life i work at

24
00:00:49,200 --> 00:00:50,399
santander who've

25
00:00:50,399 --> 00:00:52,480
generously let me do this on my own

26
00:00:52,480 --> 00:00:54,000
personal behalf

27
00:00:54,000 --> 00:00:55,760
so this is going to be a talk about the

28
00:00:55,760 --> 00:00:58,000
garbage collectors in the jvm and the

29
00:00:58,000 --> 00:00:59,280
different ways that they work

30
00:00:59,280 --> 00:01:01,280
it's going to be aimed at a sort of an

31
00:01:01,280 --> 00:01:02,399
introductory level

32
00:01:02,399 --> 00:01:03,840
so you may know some of this stuff

33
00:01:03,840 --> 00:01:05,920
already but i have put some links at the

34
00:01:05,920 --> 00:01:08,080
end and i've uploaded this presentation

35
00:01:08,080 --> 00:01:09,760
so that you'll be able to see it later

36
00:01:09,760 --> 00:01:12,240
on as well so

37
00:01:12,240 --> 00:01:14,400
what is garbage collection in the jvm

38
00:01:14,400 --> 00:01:15,680
well the jvm

39
00:01:15,680 --> 00:01:17,520
has automatic memory management which

40
00:01:17,520 --> 00:01:18,960
means that when you create and run

41
00:01:18,960 --> 00:01:20,880
programs it will generate the

42
00:01:20,880 --> 00:01:23,920
objects in the garbage collected

43
00:01:23,920 --> 00:01:26,320
heap and then worry about freedom

44
00:01:26,320 --> 00:01:27,840
because when they go away they

45
00:01:27,840 --> 00:01:30,880
no longer get referenced and the jvmp

46
00:01:30,880 --> 00:01:33,360
cleans them most garbage collected

47
00:01:33,360 --> 00:01:34,479
programming languages

48
00:01:34,479 --> 00:01:35,600
depend on something called the

49
00:01:35,600 --> 00:01:37,280
generational hypothesis which is when

50
00:01:37,280 --> 00:01:37,920
you have

51
00:01:37,920 --> 00:01:41,040
an object that's created quite um soon

52
00:01:41,040 --> 00:01:43,439
then it will either die very soon or it

53
00:01:43,439 --> 00:01:44,079
will die

54
00:01:44,079 --> 00:01:46,560
quite some time into the future and so

55
00:01:46,560 --> 00:01:48,560
quite a lot of garbage collectors have a

56
00:01:48,560 --> 00:01:50,240
generational phase in them

57
00:01:50,240 --> 00:01:52,240
where they split the processing in a

58
00:01:52,240 --> 00:01:54,159
young and an old region

59
00:01:54,159 --> 00:01:55,600
when objects get created they get

60
00:01:55,600 --> 00:01:57,360
created in the young region if they

61
00:01:57,360 --> 00:01:58,960
outlive that then they get promoted to

62
00:01:58,960 --> 00:02:00,079
an old region

63
00:02:00,079 --> 00:02:03,680
and in fact in the jbm the young region

64
00:02:03,680 --> 00:02:05,280
and the old region can be

65
00:02:05,280 --> 00:02:06,840
cleaned with different garbage

66
00:02:06,840 --> 00:02:09,038
collectors so objects initially get

67
00:02:09,038 --> 00:02:09,598
created

68
00:02:09,598 --> 00:02:11,038
inside something called the eden space

69
00:02:11,038 --> 00:02:12,879
so the eden space or the nursery is

70
00:02:12,879 --> 00:02:13,280
where

71
00:02:13,280 --> 00:02:15,760
the object will first be created and

72
00:02:15,760 --> 00:02:16,319
although

73
00:02:16,319 --> 00:02:18,239
logically it is a block of memory in

74
00:02:18,239 --> 00:02:20,000
fact the way that it gets split up is

75
00:02:20,000 --> 00:02:21,360
into something called third local

76
00:02:21,360 --> 00:02:22,560
allocation buffers

77
00:02:22,560 --> 00:02:25,599
or t-labs and the t-lab is then specific

78
00:02:25,599 --> 00:02:27,280
to a particular thread that's doing

79
00:02:27,280 --> 00:02:28,160
allocating

80
00:02:28,160 --> 00:02:30,319
so the first time a third creates an

81
00:02:30,319 --> 00:02:32,720
object in this particular garbage cycle

82
00:02:32,720 --> 00:02:34,480
it will acquire a new t-lamp if it

83
00:02:34,480 --> 00:02:36,239
doesn't have one and then

84
00:02:36,239 --> 00:02:38,239
update objects in there simply by

85
00:02:38,239 --> 00:02:39,840
bumping appointment

86
00:02:39,840 --> 00:02:41,519
and other threads that get created will

87
00:02:41,519 --> 00:02:43,280
also have these as well

88
00:02:43,280 --> 00:02:45,599
now as a thread allocates it will fill

89
00:02:45,599 --> 00:02:47,519
up a t-lab until it gets to the end in

90
00:02:47,519 --> 00:02:49,120
which case it will then request a new

91
00:02:49,120 --> 00:02:50,160
t-lab

92
00:02:50,160 --> 00:02:52,800
to fill things up the reason why we have

93
00:02:52,800 --> 00:02:54,800
this is because it makes allocation very

94
00:02:54,800 --> 00:02:56,480
fast you can allocate gigabytes per

95
00:02:56,480 --> 00:02:57,120
second

96
00:02:57,120 --> 00:02:59,680
on a jvm because each thread

97
00:02:59,680 --> 00:03:00,959
individually

98
00:03:00,959 --> 00:03:03,519
is just bumping a pointer to append new

99
00:03:03,519 --> 00:03:04,000
objects

100
00:03:04,000 --> 00:03:06,159
into the current t lamp that it has and

101
00:03:06,159 --> 00:03:07,519
because different threads are working

102
00:03:07,519 --> 00:03:09,280
in different parts of the eden space

103
00:03:09,280 --> 00:03:10,720
they have their own

104
00:03:10,720 --> 00:03:12,239
bump pointers and it's only when you

105
00:03:12,239 --> 00:03:14,400
allocate something new inside

106
00:03:14,400 --> 00:03:15,920
when you allocate a new t-lab that you

107
00:03:15,920 --> 00:03:18,239
need to do any synchronization options

108
00:03:18,239 --> 00:03:20,080
but you can have allocations that happen

109
00:03:20,080 --> 00:03:21,360
outside the t-lab in a couple of

110
00:03:21,360 --> 00:03:22,400
different places

111
00:03:22,400 --> 00:03:24,480
one of them is when you want to create

112
00:03:24,480 --> 00:03:26,640
an object that's too large to fit in the

113
00:03:26,640 --> 00:03:27,760
current t-lab

114
00:03:27,760 --> 00:03:30,640
but if you just requested a new t-lab

115
00:03:30,640 --> 00:03:32,159
you'd waste a bunch of space

116
00:03:32,159 --> 00:03:34,400
in which case it effectively becomes its

117
00:03:34,400 --> 00:03:36,000
own separate tea lab its own object

118
00:03:36,000 --> 00:03:37,599
within the eden space

119
00:03:37,599 --> 00:03:39,519
and another type of allocation that will

120
00:03:39,519 --> 00:03:41,040
live outside of the tea lab

121
00:03:41,040 --> 00:03:42,879
is when you have an object that's too

122
00:03:42,879 --> 00:03:44,640
large to fit in the eden space

123
00:03:44,640 --> 00:03:46,000
and different garbage collectors have

124
00:03:46,000 --> 00:03:47,680
different ideas of what means too large

125
00:03:47,680 --> 00:03:48,000
but

126
00:03:48,000 --> 00:03:49,760
sometimes those objects are allocated

127
00:03:49,760 --> 00:03:51,440
directly into the old space

128
00:03:51,440 --> 00:03:54,159
to avoid the initial young cleaning

129
00:03:54,159 --> 00:03:55,519
operation

130
00:03:55,519 --> 00:03:57,280
because these allocations outside the

131
00:03:57,280 --> 00:03:58,640
t-lab are infrequent

132
00:03:58,640 --> 00:04:00,239
some profiling tools use these to

133
00:04:00,239 --> 00:04:02,400
monitor how much your objects are being

134
00:04:02,400 --> 00:04:03,200
created

135
00:04:03,200 --> 00:04:05,200
in the vm and then statistically can

136
00:04:05,200 --> 00:04:06,959
give you an idea of where your hotspots

137
00:04:06,959 --> 00:04:07,280
are

138
00:04:07,280 --> 00:04:10,239
in an allocation process when the t lab

139
00:04:10,239 --> 00:04:11,040
is finished

140
00:04:11,040 --> 00:04:13,040
the waste space inside there and the

141
00:04:13,040 --> 00:04:14,319
waste space inside eden

142
00:04:14,319 --> 00:04:15,840
is filled in with a dummy object which

143
00:04:15,840 --> 00:04:17,759
is actually just a variable sized array

144
00:04:17,759 --> 00:04:19,440
and this makes parsing heaps easier when

145
00:04:19,440 --> 00:04:21,120
you do a heat dump and for the garbage

146
00:04:21,120 --> 00:04:23,360
collector to step through

147
00:04:23,360 --> 00:04:25,199
so allocations happen inside the eden

148
00:04:25,199 --> 00:04:27,360
space but when the eden space is full

149
00:04:27,360 --> 00:04:29,120
they need to be cleaned up now the goal

150
00:04:29,120 --> 00:04:30,880
of a minor gc is to take everything

151
00:04:30,880 --> 00:04:32,080
inside the eden space

152
00:04:32,080 --> 00:04:34,320
decide if it's dead or alive and then

153
00:04:34,320 --> 00:04:36,240
move all of the alive ones into a

154
00:04:36,240 --> 00:04:38,240
survivor space so that the eden can be

155
00:04:38,240 --> 00:04:39,280
completely reset

156
00:04:39,280 --> 00:04:42,400
and start again afresh from new

157
00:04:42,400 --> 00:04:44,479
in fact the survivor space is split into

158
00:04:44,479 --> 00:04:46,240
two different parts the two space and

159
00:04:46,240 --> 00:04:47,440
the front space

160
00:04:47,440 --> 00:04:50,080
and these are logically different areas

161
00:04:50,080 --> 00:04:50,880
in memory

162
00:04:50,880 --> 00:04:52,320
uh which one is the form and which one

163
00:04:52,320 --> 00:04:53,680
is the two kind of alternates between

164
00:04:53,680 --> 00:04:55,040
every other garbage collection but

165
00:04:55,040 --> 00:04:56,400
logically there is a two-space that

166
00:04:56,400 --> 00:04:57,759
you're moving objects into

167
00:04:57,759 --> 00:04:59,040
and a form space which you're pulling

168
00:04:59,040 --> 00:05:01,280
objects from and the eden is a space

169
00:05:01,280 --> 00:05:02,479
that you're pulling objects from

170
00:05:02,479 --> 00:05:05,039
and the prior survivor space um is an

171
00:05:05,039 --> 00:05:06,880
object that you're pulling

172
00:05:06,880 --> 00:05:09,360
survivors from as well what happens at

173
00:05:09,360 --> 00:05:11,039
the end of that is that the form space

174
00:05:11,039 --> 00:05:13,120
is completely empty or filled with dead

175
00:05:13,120 --> 00:05:14,880
objects the eden space is empty or

176
00:05:14,880 --> 00:05:16,400
filled with dead objects and so both of

177
00:05:16,400 --> 00:05:18,080
those can be recycled a fresh

178
00:05:18,080 --> 00:05:20,080
now what happens is sometimes when you

179
00:05:20,080 --> 00:05:22,320
move objects into the two space the two

180
00:05:22,320 --> 00:05:23,600
space becomes full

181
00:05:23,600 --> 00:05:26,479
and so there's a first in last out type

182
00:05:26,479 --> 00:05:27,919
operation that goes on

183
00:05:27,919 --> 00:05:29,759
where it bumps objects from the two

184
00:05:29,759 --> 00:05:31,680
space into the old generation when they

185
00:05:31,680 --> 00:05:33,120
overflow

186
00:05:33,120 --> 00:05:35,759
and which one flows out depends on how

187
00:05:35,759 --> 00:05:37,600
old the objects are so each object has

188
00:05:37,600 --> 00:05:39,280
got an age associated with it which is

189
00:05:39,280 --> 00:05:39,919
essentially

190
00:05:39,919 --> 00:05:41,520
the number of garbage collection cycles

191
00:05:41,520 --> 00:05:43,120
that is survived so far

192
00:05:43,120 --> 00:05:45,360
and in fact when you process the two

193
00:05:45,360 --> 00:05:46,639
space if it goes behi

194
00:05:46,639 --> 00:05:48,320
above a certain threshold which it

195
00:05:48,320 --> 00:05:49,680
defaults to 15

196
00:05:49,680 --> 00:05:51,120
then it will automatically move those

197
00:05:51,120 --> 00:05:53,440
objects from the survivor space into the

198
00:05:53,440 --> 00:05:55,919
old generation

199
00:05:55,919 --> 00:05:57,680
now this threshold can be fixed at

200
00:05:57,680 --> 00:05:59,280
startup or you can customize it

201
00:05:59,280 --> 00:06:01,520
but quite a lot of garbage collector

202
00:06:01,520 --> 00:06:03,440
algorithms in the jvm will actually

203
00:06:03,440 --> 00:06:05,120
learn what the threshold should be so if

204
00:06:05,120 --> 00:06:06,319
you're generating lots and lots of

205
00:06:06,319 --> 00:06:07,840
objects which typically happens during

206
00:06:07,840 --> 00:06:08,560
startup

207
00:06:08,560 --> 00:06:10,080
you might have a lower tenuring

208
00:06:10,080 --> 00:06:11,840
threshold for being able to move objects

209
00:06:11,840 --> 00:06:12,319
into

210
00:06:12,319 --> 00:06:15,360
the old generation but as the program

211
00:06:15,360 --> 00:06:15,919
runs

212
00:06:15,919 --> 00:06:18,800
you may have a variable amount of

213
00:06:18,800 --> 00:06:20,560
objects being created or even no objects

214
00:06:20,560 --> 00:06:21,840
in the steady state in which case the

215
00:06:21,840 --> 00:06:23,440
tenuring threshold will be reset

216
00:06:23,440 --> 00:06:26,240
afterwards when you look at a heap dump

217
00:06:26,240 --> 00:06:27,280
you can actually get a

218
00:06:27,280 --> 00:06:29,280
an idea of which classes or which

219
00:06:29,280 --> 00:06:31,360
instances of classes have particular age

220
00:06:31,360 --> 00:06:31,919
bounds

221
00:06:31,919 --> 00:06:33,520
so if they have ages one or two then

222
00:06:33,520 --> 00:06:34,639
they've only survived a couple of

223
00:06:34,639 --> 00:06:36,160
collections before dying off

224
00:06:36,160 --> 00:06:37,840
you know those are transient objects

225
00:06:37,840 --> 00:06:39,440
that you're being created things like

226
00:06:39,440 --> 00:06:39,919
maybe

227
00:06:39,919 --> 00:06:41,759
java net urls that you create and then

228
00:06:41,759 --> 00:06:43,600
dispose of on the fly

229
00:06:43,600 --> 00:06:46,080
um if you have a lot of objects with a

230
00:06:46,080 --> 00:06:47,840
high number of 10 years

231
00:06:47,840 --> 00:06:48,960
then those are the ones that have

232
00:06:48,960 --> 00:06:51,199
outlasted the jvm

233
00:06:51,199 --> 00:06:54,720
uh your garbage collection program and

234
00:06:54,720 --> 00:06:56,400
they will be the old objects or the

235
00:06:56,400 --> 00:06:57,680
mature objects that you have in your

236
00:06:57,680 --> 00:06:58,479
application

237
00:06:58,479 --> 00:07:00,240
but when you see an object where it has

238
00:07:00,240 --> 00:07:02,720
a variety of different ages inside there

239
00:07:02,720 --> 00:07:04,000
it could indicate something like a

240
00:07:04,000 --> 00:07:05,360
memory leak because you're always

241
00:07:05,360 --> 00:07:07,280
creating new instances of these objects

242
00:07:07,280 --> 00:07:08,720
those objects are always going into the

243
00:07:08,720 --> 00:07:10,400
old space so that's something that you

244
00:07:10,400 --> 00:07:12,240
can look into

245
00:07:12,240 --> 00:07:13,680
now the algorithms that are used to

246
00:07:13,680 --> 00:07:15,199
process the garbage collectors actually

247
00:07:15,199 --> 00:07:16,560
vary depending on whether you're talking

248
00:07:16,560 --> 00:07:17,840
about the old generation or the young

249
00:07:17,840 --> 00:07:18,720
generation

250
00:07:18,720 --> 00:07:20,080
and so for the young generation you can

251
00:07:20,080 --> 00:07:21,840
have serial parallel new or parallel

252
00:07:21,840 --> 00:07:22,560
scavenge

253
00:07:22,560 --> 00:07:24,800
as options and for the old generation

254
00:07:24,800 --> 00:07:26,400
you can have serial parallel old or

255
00:07:26,400 --> 00:07:27,759
concurrent mark suite

256
00:07:27,759 --> 00:07:29,520
and you can actually turn on these on

257
00:07:29,520 --> 00:07:31,520
and off one of the problems with the jbm

258
00:07:31,520 --> 00:07:32,880
is that it has actually got quite a lot

259
00:07:32,880 --> 00:07:34,479
of potential combinations and there are

260
00:07:34,479 --> 00:07:36,160
other ones that aren't listed here

261
00:07:36,160 --> 00:07:38,960
and so over the last few jdk releases

262
00:07:38,960 --> 00:07:41,199
some of these less popular

263
00:07:41,199 --> 00:07:43,840
combinations have been taken out and in

264
00:07:43,840 --> 00:07:45,520
fact can come up mark sweep is something

265
00:07:45,520 --> 00:07:47,120
that is going to be deprecated and

266
00:07:47,120 --> 00:07:48,639
removed in the future as well so we'll

267
00:07:48,639 --> 00:07:50,560
just have the parallel and serial

268
00:07:50,560 --> 00:07:52,960
options for the young and for old

269
00:07:52,960 --> 00:07:53,599
however

270
00:07:53,599 --> 00:07:55,680
there are a bunch of new garbage

271
00:07:55,680 --> 00:07:57,280
collection algorithms which deal with

272
00:07:57,280 --> 00:07:57,680
the heap

273
00:07:57,680 --> 00:08:00,879
holistically so things like g1 shenaniga

274
00:08:00,879 --> 00:08:04,400
and zgc have a different approach to

275
00:08:04,400 --> 00:08:04,800
being

276
00:08:04,800 --> 00:08:06,560
able to manage the heap and they don't

277
00:08:06,560 --> 00:08:08,639
specifically have

278
00:08:08,639 --> 00:08:10,840
uh generations like young and old inside

279
00:08:10,840 --> 00:08:12,160
there

280
00:08:12,160 --> 00:08:15,440
now how does the jbm decide to pause

281
00:08:15,440 --> 00:08:17,680
to do its cleanup operations well let's

282
00:08:17,680 --> 00:08:18,720
say you have a multi-threaded

283
00:08:18,720 --> 00:08:20,160
application and all of these threads are

284
00:08:20,160 --> 00:08:21,280
running on

285
00:08:21,280 --> 00:08:24,000
when the jvm decides that it's time to

286
00:08:24,000 --> 00:08:25,440
do a garbage collection it will try and

287
00:08:25,440 --> 00:08:26,000
bring everything

288
00:08:26,000 --> 00:08:27,599
to a halt with something called a safe

289
00:08:27,599 --> 00:08:29,759
point trigger and depending on

290
00:08:29,759 --> 00:08:32,640
the version of the jvm that you're using

291
00:08:32,640 --> 00:08:33,679
or which flavor

292
00:08:33,679 --> 00:08:35,279
then there may be different options for

293
00:08:35,279 --> 00:08:37,279
doing this hotspot will simply set a

294
00:08:37,279 --> 00:08:38,399
region of memory

295
00:08:38,399 --> 00:08:40,958
to be non-readable and periodically

296
00:08:40,958 --> 00:08:42,880
within the jvm's execution

297
00:08:42,880 --> 00:08:45,519
either every couple of byte codes or um

298
00:08:45,519 --> 00:08:46,959
at the end of counted loops

299
00:08:46,959 --> 00:08:48,480
it will check to see if it can read from

300
00:08:48,480 --> 00:08:50,080
this location and as soon as it can no

301
00:08:50,080 --> 00:08:51,440
longer read from this location that

302
00:08:51,440 --> 00:08:52,640
indicates that there's been the safe

303
00:08:52,640 --> 00:08:53,519
point trigger

304
00:08:53,519 --> 00:08:55,200
and the threads are brought to a stop

305
00:08:55,200 --> 00:08:57,279
but there can be some time between when

306
00:08:57,279 --> 00:08:59,279
the jvm decides that it wants to trigger

307
00:08:59,279 --> 00:09:00,480
a safe point and

308
00:09:00,480 --> 00:09:02,240
the safe point actually having been

309
00:09:02,240 --> 00:09:03,519
reached with all of the application

310
00:09:03,519 --> 00:09:06,080
threads that are being run inside there

311
00:09:06,080 --> 00:09:08,320
once we're at a safe point the jvm can

312
00:09:08,320 --> 00:09:10,160
then do whatever cleaning it needs to do

313
00:09:10,160 --> 00:09:12,000
for example running garbage collection

314
00:09:12,000 --> 00:09:13,600
threads and then we end

315
00:09:13,600 --> 00:09:16,000
up at the end of that with the safepoint

316
00:09:16,000 --> 00:09:17,839
end and application feds can continue

317
00:09:17,839 --> 00:09:19,839
running after that fact

318
00:09:19,839 --> 00:09:21,839
so the time where the gc threads are

319
00:09:21,839 --> 00:09:23,279
running is actually the time where your

320
00:09:23,279 --> 00:09:24,959
garbage collection algorithm is actually

321
00:09:24,959 --> 00:09:26,000
doing work

322
00:09:26,000 --> 00:09:28,160
but the application stop time is the

323
00:09:28,160 --> 00:09:30,080
time between when the jvm wanted to go

324
00:09:30,080 --> 00:09:31,279
into a safe point and

325
00:09:31,279 --> 00:09:32,800
when it actually finished doing all of

326
00:09:32,800 --> 00:09:34,160
the work that it needed to and so

327
00:09:34,160 --> 00:09:35,200
there's something called the time to

328
00:09:35,200 --> 00:09:37,279
save point which is the gap between

329
00:09:37,279 --> 00:09:39,600
when the jvm decided to trigger the save

330
00:09:39,600 --> 00:09:41,279
point and when it could actually start

331
00:09:41,279 --> 00:09:43,040
doing some work in there

332
00:09:43,040 --> 00:09:45,040
if you have applications that are taking

333
00:09:45,040 --> 00:09:46,720
longer large amounts of time

334
00:09:46,720 --> 00:09:49,600
in garbage collection have a look at the

335
00:09:49,600 --> 00:09:50,320
logs

336
00:09:50,320 --> 00:09:52,320
um if you do print application stop time

337
00:09:52,320 --> 00:09:54,000
in older versions of the jvm

338
00:09:54,000 --> 00:09:56,640
or if you look in the log gc um debug

339
00:09:56,640 --> 00:09:58,160
flags you'll find out the application

340
00:09:58,160 --> 00:09:59,760
stop time and but that will be the

341
00:09:59,760 --> 00:10:01,680
actual time that it's taken

342
00:10:01,680 --> 00:10:04,480
out of your program's running time um in

343
00:10:04,480 --> 00:10:06,880
order to be able to do processing

344
00:10:06,880 --> 00:10:09,600
typically you'll find long times to save

345
00:10:09,600 --> 00:10:10,079
points

346
00:10:10,079 --> 00:10:12,320
are either going to be things like um

347
00:10:12,320 --> 00:10:14,320
your trig you've triggered loading in

348
00:10:14,320 --> 00:10:14,800
some

349
00:10:14,800 --> 00:10:16,880
unpaged memory and the os is doing some

350
00:10:16,880 --> 00:10:18,480
work behind the covers

351
00:10:18,480 --> 00:10:21,680
or you are doing some sort of processing

352
00:10:21,680 --> 00:10:24,240
uh in a lot in a large counted loop and

353
00:10:24,240 --> 00:10:26,079
that large counted loop because the jvm

354
00:10:26,079 --> 00:10:27,120
thinks it's going to terminate

355
00:10:27,120 --> 00:10:27,839
eventually

356
00:10:27,839 --> 00:10:29,120
we'll wait until the entire loop

357
00:10:29,120 --> 00:10:30,839
finishes before it brings it to a safe

358
00:10:30,839 --> 00:10:32,560
point

359
00:10:32,560 --> 00:10:34,240
now there's different combinations that

360
00:10:34,240 --> 00:10:36,079
you can have this is called a parallel

361
00:10:36,079 --> 00:10:37,920
garbage collector where at the garbage

362
00:10:37,920 --> 00:10:38,720
collection time

363
00:10:38,720 --> 00:10:40,320
you have multiple threads being able to

364
00:10:40,320 --> 00:10:42,320
run there is the cereal garbage

365
00:10:42,320 --> 00:10:42,880
collector

366
00:10:42,880 --> 00:10:44,560
which only has a single thread for doing

367
00:10:44,560 --> 00:10:46,480
garbage collection but garbage

368
00:10:46,480 --> 00:10:47,920
collectors can also be concurrent

369
00:10:47,920 --> 00:10:49,519
and concurrent means that it has garbage

370
00:10:49,519 --> 00:10:50,959
collection threads running at the same

371
00:10:50,959 --> 00:10:52,640
time as your application

372
00:10:52,640 --> 00:10:54,800
and so it's possible to have for example

373
00:10:54,800 --> 00:10:57,440
a concurrent parallel garbage collector

374
00:10:57,440 --> 00:10:59,120
why is this important well depending on

375
00:10:59,120 --> 00:11:00,720
what you're trying to optimize for

376
00:11:00,720 --> 00:11:02,880
in your application you may decide to

377
00:11:02,880 --> 00:11:04,560
choose one or other of these things

378
00:11:04,560 --> 00:11:06,560
the serial garbage collector for example

379
00:11:06,560 --> 00:11:08,800
is good on low heap and also

380
00:11:08,800 --> 00:11:11,440
on very low power devices because it's

381
00:11:11,440 --> 00:11:12,000
about

382
00:11:12,000 --> 00:11:14,000
computationally the most efficient one

383
00:11:14,000 --> 00:11:15,839
that you can run but if you've got spare

384
00:11:15,839 --> 00:11:17,760
energy and spare cores available

385
00:11:17,760 --> 00:11:19,920
then having a concurrent and parallel

386
00:11:19,920 --> 00:11:21,120
garbage collector

387
00:11:21,120 --> 00:11:23,040
is definitely the fastest way of being

388
00:11:23,040 --> 00:11:25,519
able to get through the work

389
00:11:25,519 --> 00:11:28,079
um we talk about in the jvm space about

390
00:11:28,079 --> 00:11:28,560
having

391
00:11:28,560 --> 00:11:30,560
uh throughput collector a throughput

392
00:11:30,560 --> 00:11:32,800
collector is really the generalized name

393
00:11:32,800 --> 00:11:34,640
of garbage collection algorithms which

394
00:11:34,640 --> 00:11:35,519
operate

395
00:11:35,519 --> 00:11:37,519
um as efficiently as possible in terms

396
00:11:37,519 --> 00:11:39,440
of getting through large amounts of data

397
00:11:39,440 --> 00:11:41,279
but don't necessarily have the best

398
00:11:41,279 --> 00:11:42,560
quality pause times

399
00:11:42,560 --> 00:11:46,560
inside there so how do we do the garbage

400
00:11:46,560 --> 00:11:47,760
collection well we go through

401
00:11:47,760 --> 00:11:49,279
what are called the root sets and the

402
00:11:49,279 --> 00:11:51,120
root sets are essentially

403
00:11:51,120 --> 00:11:52,320
things that are derived from

404
00:11:52,320 --> 00:11:54,000
thread-based roots so things like local

405
00:11:54,000 --> 00:11:55,680
variables method parameters

406
00:11:55,680 --> 00:11:59,040
any objects that you've created in the

407
00:11:59,040 --> 00:12:01,760
in the process of executing that method

408
00:12:01,760 --> 00:12:02,320
and

409
00:12:02,320 --> 00:12:04,720
other parts of the operating other parts

410
00:12:04,720 --> 00:12:06,800
of the jvm so things like intern strings

411
00:12:06,800 --> 00:12:08,320
or possibly handles that you

412
00:12:08,320 --> 00:12:11,200
created from jli references these are

413
00:12:11,200 --> 00:12:12,880
essentially starting points of the graph

414
00:12:12,880 --> 00:12:15,120
to find out all of the live objects so

415
00:12:15,120 --> 00:12:16,720
any object that's in a thread

416
00:12:16,720 --> 00:12:19,680
is assumed to be live on the stack and

417
00:12:19,680 --> 00:12:21,200
it will then chase those references down

418
00:12:21,200 --> 00:12:22,959
to find everything that that points to

419
00:12:22,959 --> 00:12:25,200
and so for example if you have um

420
00:12:25,200 --> 00:12:26,160
something like

421
00:12:26,160 --> 00:12:28,399
a class or a class person object that

422
00:12:28,399 --> 00:12:29,839
you've created inside there

423
00:12:29,839 --> 00:12:31,680
then that person will point to the class

424
00:12:31,680 --> 00:12:32,959
that class will point to the class

425
00:12:32,959 --> 00:12:34,240
loader that class load will then have

426
00:12:34,240 --> 00:12:35,839
other references inside it

427
00:12:35,839 --> 00:12:38,160
and the classes are where you store

428
00:12:38,160 --> 00:12:39,839
static variables and so they're followed

429
00:12:39,839 --> 00:12:40,800
as well

430
00:12:40,800 --> 00:12:43,440
so traversing the whole jvm essentially

431
00:12:43,440 --> 00:12:44,480
is a set of

432
00:12:44,480 --> 00:12:46,480
identified starting points and then

433
00:12:46,480 --> 00:12:47,519
iterating through

434
00:12:47,519 --> 00:12:49,519
and following all of the references from

435
00:12:49,519 --> 00:12:51,760
there

436
00:12:51,760 --> 00:12:53,920
most collectors that you have will have

437
00:12:53,920 --> 00:12:55,680
some form of being able to

438
00:12:55,680 --> 00:12:57,760
uh split apart the heap in a particular

439
00:12:57,760 --> 00:12:59,680
way we've talked about the young and old

440
00:12:59,680 --> 00:13:01,600
uh direction but you can also have

441
00:13:01,600 --> 00:13:02,880
regional collectors

442
00:13:02,880 --> 00:13:04,399
and regional collectors split the memory

443
00:13:04,399 --> 00:13:05,839
into different regions or pages

444
00:13:05,839 --> 00:13:07,200
depending on which garbage collector

445
00:13:07,200 --> 00:13:08,399
that you're talking about

446
00:13:08,399 --> 00:13:10,639
what will happen is that the jvm will

447
00:13:10,639 --> 00:13:12,079
decide to collect

448
00:13:12,079 --> 00:13:14,800
decide to process a subset of those

449
00:13:14,800 --> 00:13:16,720
regions or pages to

450
00:13:16,720 --> 00:13:18,839
clean up the most amount of space

451
00:13:18,839 --> 00:13:20,880
appropriately the reason why

452
00:13:20,880 --> 00:13:23,200
the new algorithms have started to move

453
00:13:23,200 --> 00:13:24,639
towards this kind of

454
00:13:24,639 --> 00:13:26,720
approach is that you can then control

455
00:13:26,720 --> 00:13:28,079
how long the pause times in the

456
00:13:28,079 --> 00:13:28,959
application

457
00:13:28,959 --> 00:13:31,680
can be because if you want to generate

458
00:13:31,680 --> 00:13:33,200
if you want to free up more memory then

459
00:13:33,200 --> 00:13:35,279
you can select a larger amount of pages

460
00:13:35,279 --> 00:13:37,279
if you want to do the smallest amount of

461
00:13:37,279 --> 00:13:38,560
processing possible then you can have

462
00:13:38,560 --> 00:13:39,760
smaller number of regions

463
00:13:39,760 --> 00:13:41,760
inside there and the regions generally

464
00:13:41,760 --> 00:13:44,240
have flavors that are equivalent to eden

465
00:13:44,240 --> 00:13:45,199
and the two

466
00:13:45,199 --> 00:13:48,639
spaces that we have looked at earlier

467
00:13:48,639 --> 00:13:51,519
zgc uses a slightly different way of

468
00:13:51,519 --> 00:13:52,240
handling

469
00:13:52,240 --> 00:13:54,240
the heap space in that it uses virtual

470
00:13:54,240 --> 00:13:55,680
memory and tank pointers

471
00:13:55,680 --> 00:13:57,279
to be able to identify what state

472
00:13:57,279 --> 00:13:58,959
individual objects are

473
00:13:58,959 --> 00:14:01,519
but for a lot of these the garbage

474
00:14:01,519 --> 00:14:03,440
collection algorithm has moved from

475
00:14:03,440 --> 00:14:04,480
being

476
00:14:04,480 --> 00:14:06,399
a lot of work done in the pause time to

477
00:14:06,399 --> 00:14:08,160
being more and more work being done

478
00:14:08,160 --> 00:14:09,920
concurrently whilst your application is

479
00:14:09,920 --> 00:14:11,519
running and in some cases co-opting the

480
00:14:11,519 --> 00:14:12,959
application feds to be able to do

481
00:14:12,959 --> 00:14:15,199
fix-ups on the fly

482
00:14:15,199 --> 00:14:18,000
so the garbage first collectible g1 is

483
00:14:18,000 --> 00:14:20,079
one that was designed to try and create

484
00:14:20,079 --> 00:14:22,480
collect as much garbage as it can so it

485
00:14:22,480 --> 00:14:24,079
identifies in the regions that you've

486
00:14:24,079 --> 00:14:24,480
got

487
00:14:24,480 --> 00:14:25,920
kind of like a rough percentage of how

488
00:14:25,920 --> 00:14:27,760
much that region is used and

489
00:14:27,760 --> 00:14:29,519
where you're going to be able to pull uh

490
00:14:29,519 --> 00:14:30,800
content from

491
00:14:30,800 --> 00:14:32,160
and what it will do is it will collect

492
00:14:32,160 --> 00:14:33,920
you know so-called eden and survivor

493
00:14:33,920 --> 00:14:34,560
regions

494
00:14:34,560 --> 00:14:36,160
and potentially some subset of old

495
00:14:36,160 --> 00:14:38,399
regions and then sweep them into

496
00:14:38,399 --> 00:14:40,639
one or more new two spaces that it's

497
00:14:40,639 --> 00:14:41,680
creating or

498
00:14:41,680 --> 00:14:45,040
old old regions for its processing um it

499
00:14:45,040 --> 00:14:46,880
does do concurrent marking for the

500
00:14:46,880 --> 00:14:48,560
application so once you've identified

501
00:14:48,560 --> 00:14:49,600
the route set

502
00:14:49,600 --> 00:14:51,440
and in general identifying the routes

503
00:14:51,440 --> 00:14:52,959
that is a stop the world operation for

504
00:14:52,959 --> 00:14:55,199
all garbage collectors

505
00:14:55,199 --> 00:14:56,720
it will then chase those references

506
00:14:56,720 --> 00:14:58,399
concurrently and whilst your application

507
00:14:58,399 --> 00:15:00,079
is continuing to run

508
00:15:00,079 --> 00:15:01,839
and it assumes that as you are running

509
00:15:01,839 --> 00:15:03,519
any objects that you have created since

510
00:15:03,519 --> 00:15:05,440
the start of the gc cycle are implicitly

511
00:15:05,440 --> 00:15:06,240
live

512
00:15:06,240 --> 00:15:07,920
um so it will concurrently mark all of

513
00:15:07,920 --> 00:15:09,600
the objects but

514
00:15:09,600 --> 00:15:11,519
garbage first will then have an

515
00:15:11,519 --> 00:15:13,519
evacuation or relocation phase

516
00:15:13,519 --> 00:15:15,760
and that has to run in g1 in the stop

517
00:15:15,760 --> 00:15:16,959
the world phase

518
00:15:16,959 --> 00:15:20,160
um so the garbage first jvm

519
00:15:20,160 --> 00:15:21,920
memory layout is split up into a number

520
00:15:21,920 --> 00:15:23,600
of different regions each of those

521
00:15:23,600 --> 00:15:25,279
regions you can think of as being either

522
00:15:25,279 --> 00:15:27,279
the eden or the survivor or the old

523
00:15:27,279 --> 00:15:30,240
from before it also has what are called

524
00:15:30,240 --> 00:15:31,920
humongous regions which are

525
00:15:31,920 --> 00:15:33,279
essentially objects that are too large

526
00:15:33,279 --> 00:15:35,440
to fit in one single one so a humongous

527
00:15:35,440 --> 00:15:37,519
region only has one object inside there

528
00:15:37,519 --> 00:15:39,920
typically large waves for example and

529
00:15:39,920 --> 00:15:41,360
what will happen is it will sweep

530
00:15:41,360 --> 00:15:44,079
through the eden spaces

531
00:15:44,079 --> 00:15:45,519
uh collect them into different survivor

532
00:15:45,519 --> 00:15:47,199
spaces and then create a new eden space

533
00:15:47,199 --> 00:15:49,040
for next time

534
00:15:49,040 --> 00:15:52,160
by doing this and focusing on the most

535
00:15:52,160 --> 00:15:54,160
recently created garbage first they can

536
00:15:54,160 --> 00:15:56,000
do the minimum amount of work possible

537
00:15:56,000 --> 00:15:57,360
but it does have a stop of the world

538
00:15:57,360 --> 00:16:00,880
phase for doing this relocation

539
00:16:00,880 --> 00:16:03,279
shenandoah is another new algorithm

540
00:16:03,279 --> 00:16:04,800
that's sponsored by red hat

541
00:16:04,800 --> 00:16:07,600
and has been available in the jvm since

542
00:16:07,600 --> 00:16:08,000
java

543
00:16:08,000 --> 00:16:11,199
11. and this works in a similar manner

544
00:16:11,199 --> 00:16:12,560
except that it does concurrent

545
00:16:12,560 --> 00:16:13,759
evacuations

546
00:16:13,759 --> 00:16:15,600
and the concurrent evacuations work by

547
00:16:15,600 --> 00:16:17,519
having what are called forward pointers

548
00:16:17,519 --> 00:16:18,800
um it used to be the case that

549
00:16:18,800 --> 00:16:20,720
shenandoah had an implementation

550
00:16:20,720 --> 00:16:22,240
specific for the forward pointers to

551
00:16:22,240 --> 00:16:24,240
then say that

552
00:16:24,240 --> 00:16:26,079
when you want to look in this object you

553
00:16:26,079 --> 00:16:27,120
have to go somewhere else but that

554
00:16:27,120 --> 00:16:28,639
forward pointer was stored in a separate

555
00:16:28,639 --> 00:16:29,279
word

556
00:16:29,279 --> 00:16:31,199
and that has been fixed in the recent

557
00:16:31,199 --> 00:16:32,959
versions of shenandoah and whilst it

558
00:16:32,959 --> 00:16:34,160
still stores the pointer

559
00:16:34,160 --> 00:16:36,000
it reuses part of the existing object

560
00:16:36,000 --> 00:16:38,079
space to store that forward pointer in

561
00:16:38,079 --> 00:16:40,000
so it doesn't take up any additional

562
00:16:40,000 --> 00:16:42,560
memory from for example what g1

563
00:16:42,560 --> 00:16:45,199
will do shenandoah employs what are

564
00:16:45,199 --> 00:16:46,560
called load barriers and those load

565
00:16:46,560 --> 00:16:48,000
barriers are when you want to

566
00:16:48,000 --> 00:16:50,240
pull up a reference it will check to see

567
00:16:50,240 --> 00:16:51,600
whether the object that you're looking

568
00:16:51,600 --> 00:16:52,000
at

569
00:16:52,000 --> 00:16:54,160
is actually one that has been relocated

570
00:16:54,160 --> 00:16:56,320
on the fly but it has fast paths so that

571
00:16:56,320 --> 00:16:56,800
if

572
00:16:56,800 --> 00:16:58,320
the there are no forwarding going on

573
00:16:58,320 --> 00:17:00,320
it's just a simple uh mask

574
00:17:00,320 --> 00:17:03,360
for the object itself um

575
00:17:03,360 --> 00:17:05,520
shenandoah also works on 64-bit and

576
00:17:05,520 --> 00:17:07,439
32-bit systems and can support

577
00:17:07,439 --> 00:17:09,760
uh compressed oops and so this uh this

578
00:17:09,760 --> 00:17:11,439
picture of the shenandoah algorithm was

579
00:17:11,439 --> 00:17:13,439
taken from the shenandoah page

580
00:17:13,439 --> 00:17:16,559
on the java.net site and what the blue

581
00:17:16,559 --> 00:17:18,400
regions indicate here are effectively

582
00:17:18,400 --> 00:17:20,079
the agent the eden regions they're the

583
00:17:20,079 --> 00:17:20,880
ones that have been

584
00:17:20,880 --> 00:17:23,599
newly allocated what happens after mark

585
00:17:23,599 --> 00:17:24,959
is that you then have an idea of what

586
00:17:24,959 --> 00:17:26,720
objects are live

587
00:17:26,720 --> 00:17:29,200
and then the concurrent evacuation takes

588
00:17:29,200 --> 00:17:31,280
some subset of those regions

589
00:17:31,280 --> 00:17:33,200
once them into a new region and then

590
00:17:33,200 --> 00:17:34,799
marks them up as three so

591
00:17:34,799 --> 00:17:37,840
in the third block in the one

592
00:17:37,840 --> 00:17:39,360
penultimate block on the left we've got

593
00:17:39,360 --> 00:17:41,120
some squares which have just got yellow

594
00:17:41,120 --> 00:17:44,400
squares inside them those yellow squares

595
00:17:44,400 --> 00:17:46,720
essentially our objects that have been

596
00:17:46,720 --> 00:17:47,679
evacuated

597
00:17:47,679 --> 00:17:49,520
but we are maintaining pointers to the

598
00:17:49,520 --> 00:17:51,440
new place so that any part of the

599
00:17:51,440 --> 00:17:53,039
application that's then loading up

600
00:17:53,039 --> 00:17:54,720
those references can fix it to point to

601
00:17:54,720 --> 00:17:56,559
the new location

602
00:17:56,559 --> 00:17:58,080
and then once all of those evacuations

603
00:17:58,080 --> 00:18:00,320
are done those areas are then free for

604
00:18:00,320 --> 00:18:02,400
additional use so in this particular

605
00:18:02,400 --> 00:18:04,000
case the only things that

606
00:18:04,000 --> 00:18:06,400
are stop the world related are the

607
00:18:06,400 --> 00:18:07,360
marking

608
00:18:07,360 --> 00:18:09,120
and update reference phases the ones

609
00:18:09,120 --> 00:18:10,480
that are marked in red inside here

610
00:18:10,480 --> 00:18:11,679
everything else is done concurrently

611
00:18:11,679 --> 00:18:12,799
with your application

612
00:18:12,799 --> 00:18:15,840
so it has a minimal stop time

613
00:18:15,840 --> 00:18:18,320
zgc is an algorithm that has been

614
00:18:18,320 --> 00:18:19,600
sponsored by oracle

615
00:18:19,600 --> 00:18:23,120
that's been around since java 11 as well

616
00:18:23,120 --> 00:18:26,000
but it has a similar sort of idea but

617
00:18:26,000 --> 00:18:28,000
rather than having separate spaces to be

618
00:18:28,000 --> 00:18:29,280
able to

619
00:18:29,280 --> 00:18:31,840
evacuate objects into it uses what are

620
00:18:31,840 --> 00:18:33,679
called colored or tanked pointers

621
00:18:33,679 --> 00:18:35,760
and those tag pointers are essentially

622
00:18:35,760 --> 00:18:37,440
multiple mappings of the virtual memory

623
00:18:37,440 --> 00:18:38,080
space

624
00:18:38,080 --> 00:18:40,400
to the single heap and then when you

625
00:18:40,400 --> 00:18:42,000
load an object again it uses

626
00:18:42,000 --> 00:18:44,880
a load barrier like shenandoah does and

627
00:18:44,880 --> 00:18:46,559
to figure out if it's looking at the

628
00:18:46,559 --> 00:18:47,919
right copy of the object

629
00:18:47,919 --> 00:18:50,000
through the virtual memory space it does

630
00:18:50,000 --> 00:18:51,679
use a lot more virtual memory

631
00:18:51,679 --> 00:18:54,320
it doesn't use much more physical memory

632
00:18:54,320 --> 00:18:54,799
and

633
00:18:54,799 --> 00:18:56,480
like with shenandoah it can concurrently

634
00:18:56,480 --> 00:18:58,400
fix up references that it looks at the

635
00:18:58,400 --> 00:18:59,919
wrong place that looks at

636
00:18:59,919 --> 00:19:03,200
the different place um one difference

637
00:19:03,200 --> 00:19:04,480
between shenandoah and

638
00:19:04,480 --> 00:19:07,760
zgc is that zgc will require 64-bit

639
00:19:07,760 --> 00:19:09,280
virtual memory to operate so it doesn't

640
00:19:09,280 --> 00:19:09,760
run

641
00:19:09,760 --> 00:19:12,720
on 32-bit systems um so this is an

642
00:19:12,720 --> 00:19:14,960
example of what zgc actually looks like

643
00:19:14,960 --> 00:19:16,400
we've got one heap memory which is the

644
00:19:16,400 --> 00:19:18,320
green box on the right with an object

645
00:19:18,320 --> 00:19:19,600
inside there

646
00:19:19,600 --> 00:19:21,360
that is then mapped multiple times

647
00:19:21,360 --> 00:19:23,840
they're called mapped

648
00:19:23,840 --> 00:19:26,880
map zero map one and we mapped i think

649
00:19:26,880 --> 00:19:28,640
um and what happens is if you've got an

650
00:19:28,640 --> 00:19:29,919
object that's pointing

651
00:19:29,919 --> 00:19:33,039
to an object in in the one flavor of the

652
00:19:33,039 --> 00:19:33,760
heap

653
00:19:33,760 --> 00:19:36,799
then when the object is moved the object

654
00:19:36,799 --> 00:19:38,080
reference can be updated

655
00:19:38,080 --> 00:19:39,760
to point to the white version and that

656
00:19:39,760 --> 00:19:41,039
can be done either by the garbage

657
00:19:41,039 --> 00:19:41,840
collector

658
00:19:41,840 --> 00:19:44,000
or by application threads being co-opted

659
00:19:44,000 --> 00:19:46,240
to do part of the application work

660
00:19:46,240 --> 00:19:49,120
and one of the differences with zgc is

661
00:19:49,120 --> 00:19:50,880
because it uses multiple threads

662
00:19:50,880 --> 00:19:52,799
to do processing inside here it can

663
00:19:52,799 --> 00:19:54,400
actually process multiple

664
00:19:54,400 --> 00:19:57,520
regions or pages in zgc terminology at a

665
00:19:57,520 --> 00:19:59,039
time so each thread will

666
00:19:59,039 --> 00:20:02,000
will work with a set of regions that it

667
00:20:02,000 --> 00:20:03,679
is responsible for cleaning

668
00:20:03,679 --> 00:20:05,360
and there may be some additional

669
00:20:05,360 --> 00:20:07,200
advantages from a new perspective by

670
00:20:07,200 --> 00:20:08,880
doing so

671
00:20:08,880 --> 00:20:10,640
so if we have a look at how the

672
00:20:10,640 --> 00:20:12,480
different collectors

673
00:20:12,480 --> 00:20:15,200
fit together um there are different

674
00:20:15,200 --> 00:20:16,559
regions that are involved

675
00:20:16,559 --> 00:20:18,720
with the garbage first shenandoah and

676
00:20:18,720 --> 00:20:21,120
zgc and not all of them are generational

677
00:20:21,120 --> 00:20:22,720
though they do have some slight flavors

678
00:20:22,720 --> 00:20:23,840
of generation

679
00:20:23,840 --> 00:20:25,919
the zgc is planning to add some

680
00:20:25,919 --> 00:20:26,880
generation support

681
00:20:26,880 --> 00:20:29,919
specifically for eden and

682
00:20:29,919 --> 00:20:32,480
later spaces as a means of being able to

683
00:20:32,480 --> 00:20:33,120
get

684
00:20:33,120 --> 00:20:35,039
further processing but the key benefit

685
00:20:35,039 --> 00:20:36,960
of either shenandoah or zgc is that they

686
00:20:36,960 --> 00:20:38,559
do concurrent evacuation

687
00:20:38,559 --> 00:20:41,200
and that evacuation is a stop the world

688
00:20:41,200 --> 00:20:42,320
phase in g1

689
00:20:42,320 --> 00:20:45,360
and is the biggest contributor to g1

690
00:20:45,360 --> 00:20:46,559
pauses

691
00:20:46,559 --> 00:20:48,000
um the other difference that's worth

692
00:20:48,000 --> 00:20:50,080
pulling out of this is that zgc doesn't

693
00:20:50,080 --> 00:20:52,240
work on 32-bit platforms so

694
00:20:52,240 --> 00:20:54,799
um shenandoah can still be used on java

695
00:20:54,799 --> 00:20:57,600
11 and java 8 with back ports

696
00:20:57,600 --> 00:21:00,720
um but they have the different um

697
00:21:00,720 --> 00:21:02,080
they have the support for being able to

698
00:21:02,080 --> 00:21:03,840
run a 32-bit and therefore because they

699
00:21:03,840 --> 00:21:06,080
can run a 32-bit or 64-bit they also

700
00:21:06,080 --> 00:21:07,520
have the support for compressed dupes

701
00:21:07,520 --> 00:21:09,919
which their gc doesn't do

702
00:21:09,919 --> 00:21:12,559
mostly speaking shenandoah and zgc are

703
00:21:12,559 --> 00:21:14,159
equivalent in terms of how much memory

704
00:21:14,159 --> 00:21:15,120
you can throw at them

705
00:21:15,120 --> 00:21:16,960
eight megabytes is a reasonable minimal

706
00:21:16,960 --> 00:21:18,400
limit for both of those ones

707
00:21:18,400 --> 00:21:20,720
said gc has a maximum upper limit of 16

708
00:21:20,720 --> 00:21:21,440
terabytes

709
00:21:21,440 --> 00:21:23,039
shenandoah i suspect will handle 16

710
00:21:23,039 --> 00:21:24,559
terabytes but given that i don't have a

711
00:21:24,559 --> 00:21:26,320
16 terabyte machine to test on

712
00:21:26,320 --> 00:21:27,520
i've not been able to prove that for

713
00:21:27,520 --> 00:21:29,679
myself but the maximum pause times for

714
00:21:29,679 --> 00:21:32,080
both shenandoah and zgc are in the order

715
00:21:32,080 --> 00:21:33,280
of milliseconds

716
00:21:33,280 --> 00:21:35,600
uh whereas g1 can be in the order of

717
00:21:35,600 --> 00:21:38,320
seconds depending on what you're doing

718
00:21:38,320 --> 00:21:41,600
um and lastly shenandoah and zgc need to

719
00:21:41,600 --> 00:21:44,000
have unlock experimental vm options

720
00:21:44,000 --> 00:21:47,200
at the moment but they plan in jdk 15 to

721
00:21:47,200 --> 00:21:49,280
move to non-experimental status

722
00:21:49,280 --> 00:21:51,600
so in jdk 15 and above you won't need to

723
00:21:51,600 --> 00:21:52,480
use that flag

724
00:21:52,480 --> 00:21:54,799
however alexey pointed out to me that

725
00:21:54,799 --> 00:21:56,240
the red hat builds of

726
00:21:56,240 --> 00:21:59,600
8u and 11u don't have don't

727
00:21:59,600 --> 00:22:01,280
require you to specify the unlock

728
00:22:01,280 --> 00:22:03,360
experimental vm options because red hat

729
00:22:03,360 --> 00:22:06,240
considers both 8u and 11u with zg's with

730
00:22:06,240 --> 00:22:07,360
shenandoah

731
00:22:07,360 --> 00:22:10,480
to be production ready

732
00:22:10,480 --> 00:22:13,280
so java garbage collectors have evolved

733
00:22:13,280 --> 00:22:14,960
forwards to deal with both larger

734
00:22:14,960 --> 00:22:16,880
amounts of memory and lower pauses for

735
00:22:16,880 --> 00:22:18,000
stop the world time

736
00:22:18,000 --> 00:22:20,400
and by taking advantage of more threads

737
00:22:20,400 --> 00:22:21,679
and more calls they'll be able to do

738
00:22:21,679 --> 00:22:22,320
things

739
00:22:22,320 --> 00:22:24,480
more concurrently and therefore be able

740
00:22:24,480 --> 00:22:25,760
to have um

741
00:22:25,760 --> 00:22:27,280
tighter response times for when you need

742
00:22:27,280 --> 00:22:29,039
to do it the pauses now

743
00:22:29,039 --> 00:22:30,799
are limited by the boot set so the

744
00:22:30,799 --> 00:22:32,400
number of threads the size of stacks the

745
00:22:32,400 --> 00:22:33,760
objects that you create on the threads

746
00:22:33,760 --> 00:22:34,559
themselves

747
00:22:34,559 --> 00:22:36,799
rather than the amount of heap space

748
00:22:36,799 --> 00:22:37,679
inside there

749
00:22:37,679 --> 00:22:39,200
and most operations are performed

750
00:22:39,200 --> 00:22:40,799
concurrently in these regional gcs

751
00:22:40,799 --> 00:22:41,200
although

752
00:22:41,200 --> 00:22:44,240
in g1 both the young and the evacuation

753
00:22:44,240 --> 00:22:45,840
phases in the old region are still stop

754
00:22:45,840 --> 00:22:46,799
the world which is why

755
00:22:46,799 --> 00:22:49,840
g1 although performance doesn't have the

756
00:22:49,840 --> 00:22:51,520
same low pause times that either

757
00:22:51,520 --> 00:22:53,600
shenandoah or zgc have

758
00:22:53,600 --> 00:22:55,120
and there are edge cases that continue

759
00:22:55,120 --> 00:22:57,440
towards more and more count operations

760
00:22:57,440 --> 00:22:59,039
and although there are still some stop

761
00:22:59,039 --> 00:23:01,280
the war pauses they are getting smaller

762
00:23:01,280 --> 00:23:03,760
and what we're seeing now as uh both

763
00:23:03,760 --> 00:23:05,520
shenandoah and zgc

764
00:23:05,520 --> 00:23:07,280
become productionized is that they're

765
00:23:07,280 --> 00:23:09,200
tidying up some of the loose ends like

766
00:23:09,200 --> 00:23:11,360
concurrent class unloading for example

767
00:23:11,360 --> 00:23:14,000
in their implementation details

768
00:23:14,000 --> 00:23:15,679
thank you very much for listening uh put

769
00:23:15,679 --> 00:23:17,039
some links down at the bottom here and

770
00:23:17,039 --> 00:23:18,799
i've uploaded the slide deck to speaker

771
00:23:18,799 --> 00:23:19,919
deck if you want to have a look on there

772
00:23:19,919 --> 00:23:23,840
and now happy to take any questions

773
00:23:26,960 --> 00:23:30,559
thanks alex thanks very much um so

774
00:23:30,559 --> 00:23:32,159
um i've got a question for you how does

775
00:23:32,159 --> 00:23:34,840
analytics tooling support the different

776
00:23:34,840 --> 00:23:36,000
gcs

777
00:23:36,000 --> 00:23:38,240
uh so by analytics tooling you mean uh

778
00:23:38,240 --> 00:23:40,080
in a heap dump mechanism or

779
00:23:40,080 --> 00:23:42,320
in terms of uh listening to the gc

780
00:23:42,320 --> 00:23:43,200
events

781
00:23:43,200 --> 00:23:46,159
what about k3 base okay so as far as the

782
00:23:46,159 --> 00:23:47,440
heat dumps are concerned

783
00:23:47,440 --> 00:23:49,520
the the heat dump information you're

784
00:23:49,520 --> 00:23:50,720
going to get is going to be pretty much

785
00:23:50,720 --> 00:23:52,320
identical between both of them

786
00:23:52,320 --> 00:23:54,240
because a heap dump is a snapshot in

787
00:23:54,240 --> 00:23:56,000
time of what your heap actually looked

788
00:23:56,000 --> 00:23:56,559
like

789
00:23:56,559 --> 00:23:58,000
in terms of the object references

790
00:23:58,000 --> 00:24:00,000
between them rather than specifically

791
00:24:00,000 --> 00:24:00,480
anything

792
00:24:00,480 --> 00:24:02,400
about how those object references are

793
00:24:02,400 --> 00:24:03,600
laid out

794
00:24:03,600 --> 00:24:05,600
as far as the profiling and monitoring

795
00:24:05,600 --> 00:24:06,720
tools go

796
00:24:06,720 --> 00:24:10,080
um there is a unified gc logging in

797
00:24:10,080 --> 00:24:13,440
newer versions of the jdk and so all of

798
00:24:13,440 --> 00:24:14,559
the

799
00:24:14,559 --> 00:24:16,799
gc operations now use that same unified

800
00:24:16,799 --> 00:24:18,400
logging format which makes it slightly

801
00:24:18,400 --> 00:24:18,880
easier

802
00:24:18,880 --> 00:24:20,640
for being able to understand what they

803
00:24:20,640 --> 00:24:21,520
are there are some different

804
00:24:21,520 --> 00:24:23,120
terminologies between

805
00:24:23,120 --> 00:24:25,840
things like minor gcs major gcs mixed

806
00:24:25,840 --> 00:24:27,760
gcs and so on

807
00:24:27,760 --> 00:24:30,480
that maybe tooling needs to be able to

808
00:24:30,480 --> 00:24:31,279
pick up on

809
00:24:31,279 --> 00:24:33,200
but the way that those memory spaces are

810
00:24:33,200 --> 00:24:34,400
represented to

811
00:24:34,400 --> 00:24:36,960
the user are still shown via for example

812
00:24:36,960 --> 00:24:38,880
the jmx memory pools

813
00:24:38,880 --> 00:24:42,159
so when you're running a vm with the

814
00:24:42,159 --> 00:24:44,159
uh with g1 you can ask it what the

815
00:24:44,159 --> 00:24:45,200
memory pools are and it'll tell you

816
00:24:45,200 --> 00:24:46,559
you've got an eden and an old and a

817
00:24:46,559 --> 00:24:48,240
survivor to inform it you can monitor

818
00:24:48,240 --> 00:24:49,039
the weights of

819
00:24:49,039 --> 00:24:51,679
turnaround for both of those things um

820
00:24:51,679 --> 00:24:52,480
don't think in

821
00:24:52,480 --> 00:24:54,400
zgc it will particularly expose the

822
00:24:54,400 --> 00:24:56,960
different levels of mapping inside there

823
00:24:56,960 --> 00:24:59,679
but all of them will have ability to

824
00:24:59,679 --> 00:25:00,000
find

825
00:25:00,000 --> 00:25:02,240
out for example what happens in t lab

826
00:25:02,240 --> 00:25:03,440
rollover and

827
00:25:03,440 --> 00:25:05,679
the if you're just looking at them for

828
00:25:05,679 --> 00:25:06,480
monitoring

829
00:25:06,480 --> 00:25:08,080
how many objects are being created then

830
00:25:08,080 --> 00:25:10,080
they'll hook into the same part of the

831
00:25:10,080 --> 00:25:11,919
process that's using t labs and

832
00:25:11,919 --> 00:25:13,440
therefore we'll be able to tell you

833
00:25:13,440 --> 00:25:17,520
how and when those t-labs roll over

834
00:25:18,320 --> 00:25:21,120
great stuff and also how do new gc type

835
00:25:21,120 --> 00:25:21,840
models

836
00:25:21,840 --> 00:25:24,640
um how can they be used in java 8 apart

837
00:25:24,640 --> 00:25:25,200
from

838
00:25:25,200 --> 00:25:28,640
zed is the question from naveen r

839
00:25:28,640 --> 00:25:31,919
uh so uh how do the

840
00:25:31,919 --> 00:25:34,400
um how can you use these things in a

841
00:25:34,400 --> 00:25:36,480
java 8 vm was that the question

842
00:25:36,480 --> 00:25:39,840
um i believe so yeah so g1 gc

843
00:25:39,840 --> 00:25:43,039
is available in java 8 it's not the

844
00:25:43,039 --> 00:25:43,600
default

845
00:25:43,600 --> 00:25:45,200
it became the default in java 9 but in

846
00:25:45,200 --> 00:25:46,960
java 8 if you wanted to use

847
00:25:46,960 --> 00:25:48,720
g1 then all you need to do is start the

848
00:25:48,720 --> 00:25:52,480
vm with you know xx plus use g1gc

849
00:25:52,480 --> 00:25:55,520
if you want to use shenandoah in java 8

850
00:25:55,520 --> 00:25:58,400
then you can download um the red hat

851
00:25:58,400 --> 00:26:00,240
java 8 builds because they will have

852
00:26:00,240 --> 00:26:02,240
shenandoah support enabled in them

853
00:26:02,240 --> 00:26:04,880
and in that case you can just use the

854
00:26:04,880 --> 00:26:06,320
use shenandoah gc

855
00:26:06,320 --> 00:26:10,320
for that one time if you are using a

856
00:26:10,320 --> 00:26:11,279
build

857
00:26:11,279 --> 00:26:14,320
for java 11 then from

858
00:26:14,320 --> 00:26:16,159
say adopt open jdk then you might need

859
00:26:16,159 --> 00:26:18,240
to have the unlock experimental vm

860
00:26:18,240 --> 00:26:19,760
options to be able to use

861
00:26:19,760 --> 00:26:22,960
the shenandoah but red hat specifically

862
00:26:22,960 --> 00:26:24,720
are back porting shenandoah into the

863
00:26:24,720 --> 00:26:27,279
java 8 and java 11 runtimes

864
00:26:27,279 --> 00:26:29,279
i'm not sure whether anyone other than

865
00:26:29,279 --> 00:26:31,200
red hat um

866
00:26:31,200 --> 00:26:34,000
provides builds for java 8 with

867
00:26:34,000 --> 00:26:35,200
shenandoah

868
00:26:35,200 --> 00:26:37,919
support enabled but certainly red hat do

869
00:26:37,919 --> 00:26:38,960
great stuff

870
00:26:38,960 --> 00:26:40,559
alex thanks very much for joining us

871
00:26:40,559 --> 00:26:42,000
today and

872
00:26:42,000 --> 00:26:45,039
um uh please stay safe stay home stay

873
00:26:45,039 --> 00:26:45,760
healthy

874
00:26:45,760 --> 00:26:48,080
um everybody we're gonna be taking a

875
00:26:48,080 --> 00:26:49,279
break fairly soon

876
00:26:49,279 --> 00:26:52,159
remember that this is um it's all been

877
00:26:52,159 --> 00:26:54,240
organized today for a worthy cause as

878
00:26:54,240 --> 00:26:55,679
well and we are raising money for

879
00:26:55,679 --> 00:26:56,799
charities

880
00:26:56,799 --> 00:26:59,840
um also so if you want to um help out on

881
00:26:59,840 --> 00:27:01,799
the effort there head on over to

882
00:27:01,799 --> 00:27:02,960
ordertalks.org

883
00:27:02,960 --> 00:27:04,640
forward slash tickets and you can find

884
00:27:04,640 --> 00:27:06,880
out more information on how to do that

885
00:27:06,880 --> 00:27:08,000
we're going to take a break now and

886
00:27:08,000 --> 00:27:10,720
we'll see you again in about 30 minutes

887
00:27:10,720 --> 00:27:13,760
please go and grab some beverages or

888
00:27:13,760 --> 00:27:17,840
refreshments take care

