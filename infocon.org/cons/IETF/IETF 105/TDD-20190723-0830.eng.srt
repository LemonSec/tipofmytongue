1
00:05:57,729 --> 00:06:01,058
no he told

2
00:06:42,950 --> 00:07:07,590
this control that I just look at the

3
00:06:59,760 --> 00:07:14,210
attendance unique oh I see it's really

4
00:07:07,590 --> 00:07:14,210
sweet stuff doesn't work yeah

5
00:07:34,250 --> 00:07:59,440
oh we got mythical yeah I did already I

6
00:07:53,720 --> 00:08:06,860
sent them brakes link know there's some

7
00:07:59,440 --> 00:08:13,160
Italian participate even verify oh they

8
00:08:06,860 --> 00:08:26,900
are okay

9
00:08:13,160 --> 00:08:28,730
I already had central yesterday okay so

10
00:08:26,900 --> 00:08:30,859
miracles occur

11
00:08:28,730 --> 00:08:39,430
okay is that supposed to are we supposed

12
00:08:30,860 --> 00:08:39,430
to see this this works

13
00:08:43,380 --> 00:08:50,460
this is not one of those cool ones where

14
00:08:45,700 --> 00:08:50,460
you go highlight any pictures

15
00:08:50,700 --> 00:09:17,370
hey so people who are registered can use

16
00:09:11,620 --> 00:09:17,370
this link if you send it to me I will

17
00:09:23,700 --> 00:09:30,630
okay yeah if you'd send me directly I

18
00:09:27,310 --> 00:09:30,630
can cost you two now mister

19
00:10:04,380 --> 00:10:10,750
ten ten minutes it was neat eight foot

20
00:10:07,630 --> 00:10:14,230
eight foot five no thank you

21
00:10:10,750 --> 00:10:22,029
all right I'll send after a sunset

22
00:10:14,230 --> 00:10:23,709
should I send this well I said I'm gonna

23
00:10:22,029 --> 00:10:27,459
send any material they'll be an investor

24
00:10:23,709 --> 00:10:30,670
I would say my name do you want to say

25
00:10:27,459 --> 00:10:31,829
your name is a chick so good morning

26
00:10:30,670 --> 00:10:35,439
everybody

27
00:10:31,829 --> 00:10:39,250
sorry for the slight delay but now we're

28
00:10:35,440 --> 00:10:42,610
also online that's great good morning

29
00:10:39,250 --> 00:10:44,260
this is the deep dive session that's

30
00:10:42,610 --> 00:10:46,240
kind of the second dipped ice type

31
00:10:44,260 --> 00:10:48,100
session we are having at ITF last

32
00:10:46,240 --> 00:10:51,310
meeting we had a deep type session on

33
00:10:48,100 --> 00:10:53,410
router architectures which people gave

34
00:10:51,310 --> 00:10:56,619
us a lot of positive feedback about so

35
00:10:53,410 --> 00:10:59,500
we thought we'd do it again this time we

36
00:10:56,620 --> 00:11:01,720
will look into Nicks and we have some

37
00:10:59,500 --> 00:11:03,820
people here who usually or some of them

38
00:11:01,720 --> 00:11:06,940
usually come to the ITF they're from the

39
00:11:03,820 --> 00:11:09,399
Linux Native community we will introduce

40
00:11:06,940 --> 00:11:11,410
them yes and where were you happy to

41
00:11:09,399 --> 00:11:16,450
have them here so my name is MIA KU

42
00:11:11,410 --> 00:11:21,610
Leuven I'm Jamal Hadi Salim and we will

43
00:11:16,450 --> 00:11:24,450
start it's a wrong machine the note well

44
00:11:21,610 --> 00:11:24,450
applies here as well

45
00:11:33,040 --> 00:11:39,160
so the note well applies here as well

46
00:11:35,080 --> 00:11:41,190
this is kind of a site meeting but we're

47
00:11:39,160 --> 00:11:45,310
still at the IDF so it applies and

48
00:11:41,190 --> 00:11:46,900
that's our today's agenda we have the

49
00:11:45,310 --> 00:11:51,699
user stuff we have to care about which

50
00:11:46,900 --> 00:11:54,280
is mostly now set up and Jamar will now

51
00:11:51,700 --> 00:11:56,770
do a quick introduction to scope our

52
00:11:54,280 --> 00:11:58,600
date or our morning meeting here and

53
00:11:56,770 --> 00:12:00,610
then we start the presentation and we

54
00:11:58,600 --> 00:12:05,980
have some time for questions at the end

55
00:12:00,610 --> 00:12:09,370
can we solicit a scribe somebody who's

56
00:12:05,980 --> 00:12:14,430
going to take minutes or come on

57
00:12:09,370 --> 00:12:25,480
volunteer scribe we have the record

58
00:12:14,430 --> 00:12:31,180
alright and the blue sheet okay so when

59
00:12:25,480 --> 00:12:32,680
we were scoping this talk an hour and a

60
00:12:31,180 --> 00:12:37,239
half didn't seem to do justice to the

61
00:12:32,680 --> 00:12:39,609
content so we had to limit the scope we

62
00:12:37,240 --> 00:12:43,120
could have a half-day discussion on not

63
00:12:39,610 --> 00:12:46,690
a tutorial but just high level topics so

64
00:12:43,120 --> 00:12:49,840
they what is in scope is we will talk

65
00:12:46,690 --> 00:12:55,210
about basic Nick's about how basic Nick

66
00:12:49,840 --> 00:13:00,130
works will proceed to medium range

67
00:12:55,210 --> 00:13:02,470
offload from the host stack to the cut

68
00:13:00,130 --> 00:13:04,450
to the hardware and slightly more

69
00:13:02,470 --> 00:13:07,270
advanced features we're going to use

70
00:13:04,450 --> 00:13:09,040
Linux kernel as a reference point not

71
00:13:07,270 --> 00:13:12,280
necessarily the only way the only

72
00:13:09,040 --> 00:13:13,449
operating system that does this once out

73
00:13:12,280 --> 00:13:16,480
of scope is we're not going to talk

74
00:13:13,450 --> 00:13:18,610
about kernel bypass so not the PDK

75
00:13:16,480 --> 00:13:23,260
discussions we're not going to talk

76
00:13:18,610 --> 00:13:25,540
about small CPE devices that use the

77
00:13:23,260 --> 00:13:29,319
same API on Linux at least or very large

78
00:13:25,540 --> 00:13:32,849
Essex multi terrible Essex which may use

79
00:13:29,320 --> 00:13:34,330
the same api's in some vendors Essex

80
00:13:32,850 --> 00:13:37,600
we're not going to talk about

81
00:13:34,330 --> 00:13:40,510
virtualization offload technologies s RI

82
00:13:37,600 --> 00:13:43,300
o VV m DQ and any newer schemes are out

83
00:13:40,510 --> 00:13:46,090
of topic and storage is also out of

84
00:13:43,300 --> 00:13:46,959
topic so this could be another session

85
00:13:46,090 --> 00:13:49,330
in the future

86
00:13:46,960 --> 00:13:51,790
should this session become exciting to

87
00:13:49,330 --> 00:13:56,170
the attendees we could have another

88
00:13:51,790 --> 00:13:59,280
session in the future the relationship

89
00:13:56,170 --> 00:14:03,280
to the ITF if you implementing protocols

90
00:13:59,280 --> 00:14:05,290
this is very relevant to you you're

91
00:14:03,280 --> 00:14:08,770
running on the host or some middleboxes

92
00:14:05,290 --> 00:14:16,170
which end up using NYX for nodes that

93
00:14:08,770 --> 00:14:20,350
perform both host level features or

94
00:14:16,170 --> 00:14:23,260
forwarding functions so NYX can process

95
00:14:20,350 --> 00:14:25,060
a lot accelerate as well a lot of and

96
00:14:23,260 --> 00:14:30,790
have a lot of helpers in the hardware

97
00:14:25,060 --> 00:14:34,479
for TCP UDP quake TLS IPSec a lot of the

98
00:14:30,790 --> 00:14:37,360
nvo 3 is mostly commodity offloading at

99
00:14:34,480 --> 00:14:40,420
this point in time you can accelerate

100
00:14:37,360 --> 00:14:44,610
any of the layer 2 to layer n forwarding

101
00:14:40,420 --> 00:14:49,510
and filtering a lot of QoS offloading

102
00:14:44,610 --> 00:14:52,300
it's a very condensed session so what

103
00:14:49,510 --> 00:14:54,819
we'll ask is you can will only allow for

104
00:14:52,300 --> 00:14:57,130
clarification questions and any other

105
00:14:54,820 --> 00:15:00,610
questions that you may have will come at

106
00:14:57,130 --> 00:15:05,410
the end I'm gonna introduce the

107
00:15:00,610 --> 00:15:08,560
presenters you have a very competent set

108
00:15:05,410 --> 00:15:13,000
of folks here on the left is Tom Hubbard

109
00:15:08,560 --> 00:15:15,520
from Intel and the Gospel Derek from

110
00:15:13,000 --> 00:15:17,770
Broadcom and Simon hormone from

111
00:15:15,520 --> 00:15:22,000
metronome and I'd like to acknowledge

112
00:15:17,770 --> 00:15:24,340
Boris where's Boris from Mellanox these

113
00:15:22,000 --> 00:15:26,020
are very competent folks they have they

114
00:15:24,340 --> 00:15:27,940
know how the implementations work they

115
00:15:26,020 --> 00:15:29,340
understand the hardware very well so

116
00:15:27,940 --> 00:15:34,240
you're in good hands

117
00:15:29,340 --> 00:15:35,650
having said that these slides took a lot

118
00:15:34,240 --> 00:15:39,670
of community effort from the native

119
00:15:35,650 --> 00:15:42,910
community in general and this is a list

120
00:15:39,670 --> 00:15:46,900
of people who in one way or another

121
00:15:42,910 --> 00:15:49,089
contributed shaped opinionated on what

122
00:15:46,900 --> 00:15:52,689
should be cut out what you became how

123
00:15:49,090 --> 00:15:53,890
the slides should be structured etc and

124
00:15:52,690 --> 00:15:56,610
with that I'm gonna hand it over to the

125
00:15:53,890 --> 00:15:56,610
first speaker Tom

126
00:16:10,649 --> 00:16:18,899
is it like working the mic is can you

127
00:16:16,569 --> 00:16:18,899
turn it on

128
00:16:22,470 --> 00:16:27,850
how's that yeah no much better okay so

129
00:16:26,139 --> 00:16:33,189
I'm going to present the fundamentals

130
00:16:27,850 --> 00:16:36,220
and basic offloads Nick's so a few

131
00:16:33,189 --> 00:16:38,860
definitions might be useful on Nick is a

132
00:16:36,220 --> 00:16:41,739
network interface card sometimes network

133
00:16:38,860 --> 00:16:44,350
interface controller this is the host

134
00:16:41,739 --> 00:16:49,170
interface physical interface to physical

135
00:16:44,350 --> 00:16:52,959
Network host ACK is the software that

136
00:16:49,170 --> 00:16:56,139
processes packets and does protocol

137
00:16:52,959 --> 00:16:58,290
processing in the host typically this is

138
00:16:56,139 --> 00:17:00,970
layer 2 layer 3 layer 4 processing a

139
00:16:58,290 --> 00:17:03,699
kernel stack is simply a host stack that

140
00:17:00,970 --> 00:17:05,880
runs inside a kernel and Esther mell

141
00:17:03,699 --> 00:17:09,520
mentioned for the most part will be

142
00:17:05,880 --> 00:17:13,389
referencing Linux for that offload is

143
00:17:09,520 --> 00:17:16,329
when we do something inside the NIC on

144
00:17:13,388 --> 00:17:20,229
behalf of the host so this is work that

145
00:17:16,329 --> 00:17:23,379
we move essentially from the host to the

146
00:17:20,230 --> 00:17:27,429
NIC for some purpose work that involves

147
00:17:23,380 --> 00:17:29,830
a networking and acceleration is offload

148
00:17:27,429 --> 00:17:33,460
that is done mostly for performance

149
00:17:29,830 --> 00:17:36,850
gains so what is a network interface

150
00:17:33,460 --> 00:17:39,490
card this shows a picture on the left of

151
00:17:36,850 --> 00:17:40,658
a card and most of you should be

152
00:17:39,490 --> 00:17:42,970
familiar with these

153
00:17:40,659 --> 00:17:44,950
whoever's had a PC for instance and

154
00:17:42,970 --> 00:17:46,990
that's not a plug these in so they go

155
00:17:44,950 --> 00:17:48,840
into the system bus I would point out

156
00:17:46,990 --> 00:17:51,549
this particular card very ancient

157
00:17:48,840 --> 00:17:53,949
actually it has a BNC connector so this

158
00:17:51,549 --> 00:17:57,330
is true Ethernet and ISO connectivity

159
00:17:53,950 --> 00:17:59,799
but nevertheless it's a NIC and

160
00:17:57,330 --> 00:18:01,418
modern-day NICs obviously look a little

161
00:17:59,799 --> 00:18:05,379
bit different but basically perform the

162
00:18:01,419 --> 00:18:08,200
same function so we NIC is the receiver

163
00:18:05,380 --> 00:18:10,120
and transmitter of packets to the

164
00:18:08,200 --> 00:18:12,190
network to the physical network it's the

165
00:18:10,120 --> 00:18:15,370
device that does that and on the right

166
00:18:12,190 --> 00:18:17,919
we have a stack and you can see that in

167
00:18:15,370 --> 00:18:20,408
the protocol stack the NIC is kind of at

168
00:18:17,919 --> 00:18:21,460
the bottom and on one side to the

169
00:18:20,409 --> 00:18:23,710
outside world

170
00:18:21,460 --> 00:18:29,409
connects to the physical media that

171
00:18:23,710 --> 00:18:31,750
could be fiber cat5 radio and we use

172
00:18:29,409 --> 00:18:35,640
some sort of encoding or framing over

173
00:18:31,750 --> 00:18:39,490
that media Ethernet Wi-Fi fibre channel

174
00:18:35,640 --> 00:18:42,730
on the other side of the NIC it connects

175
00:18:39,490 --> 00:18:46,450
into the system via the system bus so

176
00:18:42,730 --> 00:18:50,190
typically today this is PCIe or USB in

177
00:18:46,450 --> 00:18:52,870
the olden days like this card it was ISO

178
00:18:50,190 --> 00:18:55,870
so the way this works is that Knicks

179
00:18:52,870 --> 00:18:58,360
have queues typically they have a

180
00:18:55,870 --> 00:19:01,239
transmit Q and a receive Q and these

181
00:18:58,360 --> 00:19:04,059
queues store the packets or indicate the

182
00:19:01,240 --> 00:19:06,159
package for transmit and receive the

183
00:19:04,059 --> 00:19:08,918
queues are composed of a set of

184
00:19:06,159 --> 00:19:12,100
descriptors and the descriptors describe

185
00:19:08,919 --> 00:19:13,899
the packet for the NIC some of the

186
00:19:12,100 --> 00:19:15,399
important things in the scripters are

187
00:19:13,899 --> 00:19:17,500
where the packet is located in hosts

188
00:19:15,399 --> 00:19:20,559
memory what the length of the packet is

189
00:19:17,500 --> 00:19:22,750
and then some ancillary information that

190
00:19:20,559 --> 00:19:26,020
may have involved for instance if it was

191
00:19:22,750 --> 00:19:28,539
received as broadcast Ethernet and other

192
00:19:26,020 --> 00:19:31,539
information like that so in order to

193
00:19:28,539 --> 00:19:34,419
transmit the host stack fills out a

194
00:19:31,539 --> 00:19:36,789
transmit descriptor and most importantly

195
00:19:34,419 --> 00:19:38,919
it writes the information in that for

196
00:19:36,789 --> 00:19:41,049
the packet where the packet is located

197
00:19:38,919 --> 00:19:43,360
in its memory and what the length of the

198
00:19:41,049 --> 00:19:45,908
packet is it puts the transmit

199
00:19:43,360 --> 00:19:48,668
descriptor onto a cue and I should

200
00:19:45,909 --> 00:19:50,950
mention it's producer-consumer type of

201
00:19:48,669 --> 00:19:53,529
cue so it puts the transmit descriptor

202
00:19:50,950 --> 00:19:56,799
on the cue pumps the producer pointer

203
00:19:53,529 --> 00:19:59,649
and then it sends an indication to the

204
00:19:56,799 --> 00:20:01,750
NIC usually through a pci write register

205
00:19:59,649 --> 00:20:04,449
right that there's work to be done

206
00:20:01,750 --> 00:20:07,779
so the NIC wakes up it processes the

207
00:20:04,450 --> 00:20:10,000
transmit cue and it looks at each of the

208
00:20:07,779 --> 00:20:12,010
transmitted descriptors figures out

209
00:20:10,000 --> 00:20:14,289
where the packet is in hosts memory

210
00:20:12,010 --> 00:20:17,649
performs a DMA operation direct memory

211
00:20:14,289 --> 00:20:21,039
access to pull the packet into its local

212
00:20:17,649 --> 00:20:23,408
memory and then the NIC may perform some

213
00:20:21,039 --> 00:20:25,720
offload processing which we'll talk

214
00:20:23,409 --> 00:20:27,940
about in a bit but eventually the packet

215
00:20:25,720 --> 00:20:32,320
has to be sent on the network so there

216
00:20:27,940 --> 00:20:34,630
is a by an assertive serializer inside

217
00:20:32,320 --> 00:20:35,379
the device that takes the packet in its

218
00:20:34,630 --> 00:20:37,420
memory

219
00:20:35,380 --> 00:20:40,480
serializes the data and sends it out to

220
00:20:37,420 --> 00:20:43,360
the actual network receive is somewhat

221
00:20:40,480 --> 00:20:46,690
similar in the receive path the host

222
00:20:43,360 --> 00:20:48,729
sets up a number of packet buffers where

223
00:20:46,690 --> 00:20:53,200
packets will be stored in its memory and

224
00:20:48,730 --> 00:20:55,240
it puts these into the receive queue in

225
00:20:53,200 --> 00:20:57,370
the receive descriptors so again in each

226
00:20:55,240 --> 00:20:59,770
descriptor there's a memory location and

227
00:20:57,370 --> 00:21:04,840
in this case maximum length of the

228
00:20:59,770 --> 00:21:07,060
packet when the NIC receives a packet it

229
00:21:04,840 --> 00:21:10,629
deserialize it puts it in its memory

230
00:21:07,060 --> 00:21:12,129
again may do some offload processing but

231
00:21:10,630 --> 00:21:13,960
eventually wants to send that to the

232
00:21:12,130 --> 00:21:16,270
host so the way it works is the NIC

233
00:21:13,960 --> 00:21:19,210
takes the next received descriptor

234
00:21:16,270 --> 00:21:23,560
available on the queue gets the host

235
00:21:19,210 --> 00:21:26,230
memory location DMA is the packet into

236
00:21:23,560 --> 00:21:28,480
that host memory sets the length in the

237
00:21:26,230 --> 00:21:30,700
received descriptor increments the

238
00:21:28,480 --> 00:21:32,230
producer pointer or consumer it's

239
00:21:30,700 --> 00:21:35,020
consumer pointer in the receive queue

240
00:21:32,230 --> 00:21:37,420
and then it interrupts the host which is

241
00:21:35,020 --> 00:21:39,730
typically an actual system interrupt and

242
00:21:37,420 --> 00:21:41,170
the host wakes up and knows there's

243
00:21:39,730 --> 00:21:42,970
packets to process and there you see if

244
00:21:41,170 --> 00:21:45,550
queue so it actually reads the queue and

245
00:21:42,970 --> 00:21:47,680
then and get the packets that have been

246
00:21:45,550 --> 00:21:52,240
received and processes them in the stack

247
00:21:47,680 --> 00:21:55,720
so what I just described is kind of

248
00:21:52,240 --> 00:21:59,230
fundamental and that's the basics of the

249
00:21:55,720 --> 00:22:02,470
neck and be started in approximately the

250
00:21:59,230 --> 00:22:04,060
early 90s not soon after some of the

251
00:22:02,470 --> 00:22:05,890
basic off loads that I'll talk about in

252
00:22:04,060 --> 00:22:09,460
a minute came into being and we're

253
00:22:05,890 --> 00:22:14,130
developed and we can track the evolution

254
00:22:09,460 --> 00:22:16,840
of NICs since then so in the mid-2000s

255
00:22:14,130 --> 00:22:20,050
we have data plane accelerations so

256
00:22:16,840 --> 00:22:22,899
these are more advanced features inside

257
00:22:20,050 --> 00:22:26,409
the Nix IPSec offload for instance QoS

258
00:22:22,900 --> 00:22:28,750
off loads and more recently there's a

259
00:22:26,410 --> 00:22:31,660
general movement to make these devices

260
00:22:28,750 --> 00:22:33,550
programmable so at each phase of the

261
00:22:31,660 --> 00:22:35,500
evolution you can think of this as more

262
00:22:33,550 --> 00:22:39,010
advanced features more functionality

263
00:22:35,500 --> 00:22:40,840
more capabilities to process protocols

264
00:22:39,010 --> 00:22:42,400
and packets but fundamentally the

265
00:22:40,840 --> 00:22:44,740
operation of the NIC is the same it's

266
00:22:42,400 --> 00:22:48,880
the thing that transmits and receives

267
00:22:44,740 --> 00:22:51,760
packets to network

268
00:22:48,880 --> 00:22:53,860
so we'll talk a lot about offloads today

269
00:22:51,760 --> 00:22:56,080
I want to give a little bit of

270
00:22:53,860 --> 00:22:58,149
motivation one way you can think of

271
00:22:56,080 --> 00:23:00,490
offloads is these are just advanced

272
00:22:58,150 --> 00:23:03,190
features having to do with the packet

273
00:23:00,490 --> 00:23:05,560
processing or protocol processing that

274
00:23:03,190 --> 00:23:07,870
happens to be done in the neck so

275
00:23:05,560 --> 00:23:10,149
there's a few rationales for this one is

276
00:23:07,870 --> 00:23:14,290
we want to free up the host CPU cycles

277
00:23:10,150 --> 00:23:17,290
for application work this makes sense if

278
00:23:14,290 --> 00:23:19,899
the NIC can do the functions of

279
00:23:17,290 --> 00:23:22,030
networking in a more efficient way so

280
00:23:19,900 --> 00:23:23,410
since its specialized hardware that is

281
00:23:22,030 --> 00:23:26,110
often the case for instance we can

282
00:23:23,410 --> 00:23:30,190
compute a checksum more efficiently than

283
00:23:26,110 --> 00:23:31,959
going in the host CPU more generally one

284
00:23:30,190 --> 00:23:35,110
of the motivations is to save hosts

285
00:23:31,960 --> 00:23:38,620
resources so offloads may save not two

286
00:23:35,110 --> 00:23:42,490
CPU memory DMA operations memory

287
00:23:38,620 --> 00:23:44,169
movement a number of interrupts scaling

288
00:23:42,490 --> 00:23:45,940
performance is very important and

289
00:23:44,170 --> 00:23:47,730
offloads helped a lot there particularly

290
00:23:45,940 --> 00:23:50,260
in low latency and high throughput

291
00:23:47,730 --> 00:23:53,140
there's also some interesting use cases

292
00:23:50,260 --> 00:23:55,750
particularly in mobile where we might

293
00:23:53,140 --> 00:23:59,140
offload certain operations having to do

294
00:23:55,750 --> 00:24:01,720
with protocol processing to a device for

295
00:23:59,140 --> 00:24:04,840
the purposes of saving CPU cycles and

296
00:24:01,720 --> 00:24:10,420
saving power in particular on the core

297
00:24:04,840 --> 00:24:13,149
CPU so in short offloads makes sense as

298
00:24:10,420 --> 00:24:16,690
a cost-benefit trade off if the benefits

299
00:24:13,150 --> 00:24:18,730
of moving work into the neck you can

300
00:24:16,690 --> 00:24:21,460
think about its coat process or exceed

301
00:24:18,730 --> 00:24:24,070
the cost then it makes sense in practice

302
00:24:21,460 --> 00:24:25,780
this can be interesting analysis and we

303
00:24:24,070 --> 00:24:28,270
know that CPUs for instance are always

304
00:24:25,780 --> 00:24:30,100
increasing their capabilities on the

305
00:24:28,270 --> 00:24:33,040
other hand the network and things we

306
00:24:30,100 --> 00:24:35,260
want to do are always getting more

307
00:24:33,040 --> 00:24:37,120
complex so there's always a bit of a

308
00:24:35,260 --> 00:24:40,150
trade-off between whether to offload or

309
00:24:37,120 --> 00:24:40,989
run on the host CPU but in general we

310
00:24:40,150 --> 00:24:43,360
found offloads

311
00:24:40,990 --> 00:24:47,020
to be pretty useful on probably will

312
00:24:43,360 --> 00:24:50,500
continue that trend in terms of

313
00:24:47,020 --> 00:24:52,660
developing off loads and nic development

314
00:24:50,500 --> 00:24:55,030
in general in the Linux community at

315
00:24:52,660 --> 00:24:56,530
least we kind of enshrined some of the

316
00:24:55,030 --> 00:24:59,680
principles in something called less is

317
00:24:56,530 --> 00:25:02,030
more and I want to give three components

318
00:24:59,680 --> 00:25:04,430
of this so first of

319
00:25:02,030 --> 00:25:07,190
protocol agnostic mechanisms are better

320
00:25:04,430 --> 00:25:09,770
than protocol specific and this is

321
00:25:07,190 --> 00:25:12,320
somewhat of a formulism of trying to

322
00:25:09,770 --> 00:25:15,080
prevent proto classification but the

323
00:25:12,320 --> 00:25:17,720
idea is if we can develop an offload

324
00:25:15,080 --> 00:25:20,870
that supports say all transport

325
00:25:17,720 --> 00:25:23,630
protocols equally versus one that is

326
00:25:20,870 --> 00:25:26,330
only only works with TCP or plain TCP IP

327
00:25:23,630 --> 00:25:28,040
packets generally the offload that is

328
00:25:26,330 --> 00:25:32,060
more general it's going to be more

329
00:25:28,040 --> 00:25:35,389
applicable and better for the user in a

330
00:25:32,060 --> 00:25:39,500
similar vein common api's are better

331
00:25:35,390 --> 00:25:43,280
than proprietary a peons we have a lot

332
00:25:39,500 --> 00:25:46,390
of OSS a lot of NICs the more common the

333
00:25:43,280 --> 00:25:49,250
API is across those the easier it is for

334
00:25:46,390 --> 00:25:51,830
users to choose different pieces of

335
00:25:49,250 --> 00:25:53,630
hardware this is particularly important

336
00:25:51,830 --> 00:25:56,720
in that we want to avoid the concept of

337
00:25:53,630 --> 00:25:59,660
vendor lock-in which is where a vendor

338
00:25:56,720 --> 00:26:02,690
whether purposely or inadvertently kind

339
00:25:59,660 --> 00:26:04,990
of controls the API such that it's

340
00:26:02,690 --> 00:26:08,710
really difficult for the user to change

341
00:26:04,990 --> 00:26:12,230
vendor the vendors that they're using

342
00:26:08,710 --> 00:26:15,400
the third point is the program program

343
00:26:12,230 --> 00:26:18,470
ability is good so I put this in

344
00:26:15,400 --> 00:26:20,810
generally in parentheses one of the

345
00:26:18,470 --> 00:26:23,180
aspects of program ability is if we make

346
00:26:20,810 --> 00:26:25,970
it completely openly programmable

347
00:26:23,180 --> 00:26:28,610
especially user programmable and allow

348
00:26:25,970 --> 00:26:32,780
users to do whatever they want users

349
00:26:28,610 --> 00:26:35,179
will do whatever they want that as we

350
00:26:32,780 --> 00:26:37,610
know leads to some interesting

351
00:26:35,180 --> 00:26:40,220
fracturing of the market and can be

352
00:26:37,610 --> 00:26:41,870
precarious so we always want to make

353
00:26:40,220 --> 00:26:44,480
sure that if we're going to create a

354
00:26:41,870 --> 00:26:46,459
open program environment how do we

355
00:26:44,480 --> 00:26:50,060
develop the ecosystem properly and

356
00:26:46,460 --> 00:26:55,010
maintain some semblance of sanity across

357
00:26:50,060 --> 00:26:59,060
these and portability so we can turn and

358
00:26:55,010 --> 00:27:02,270
look at some of the basic offloads I'm

359
00:26:59,060 --> 00:27:04,639
gonna skip that slide so we'll talk

360
00:27:02,270 --> 00:27:07,400
about three basic offloads and these are

361
00:27:04,640 --> 00:27:10,310
kind of the oldest ones they're very

362
00:27:07,400 --> 00:27:11,810
common amongst Nicks most of these have

363
00:27:10,310 --> 00:27:14,120
been around since the 90s at least

364
00:27:11,810 --> 00:27:16,600
checksum offload segmentation offload

365
00:27:14,120 --> 00:27:21,800
and multi cure

366
00:27:16,600 --> 00:27:26,209
check some offload is the offload of the

367
00:27:21,800 --> 00:27:28,370
venerable TCP UDP transport checksum so

368
00:27:26,210 --> 00:27:30,950
the idea is that we want to offload the

369
00:27:28,370 --> 00:27:33,459
computation of the checksum so the ones

370
00:27:30,950 --> 00:27:36,830
complement summation in particular is

371
00:27:33,460 --> 00:27:41,120
CPU intensive if we offload that to the

372
00:27:36,830 --> 00:27:43,129
NIC we get a nice performance gain as I

373
00:27:41,120 --> 00:27:45,500
mentioned checksum offload is

374
00:27:43,130 --> 00:27:46,970
particularly ubiquitous it would

375
00:27:45,500 --> 00:27:48,380
probably be pretty hard to find a NIC

376
00:27:46,970 --> 00:27:49,070
and on the market today that does not

377
00:27:48,380 --> 00:27:52,280
sort

378
00:27:49,070 --> 00:27:54,290
support some form of this an interesting

379
00:27:52,280 --> 00:27:57,440
twist that's a little bit recent is

380
00:27:54,290 --> 00:28:00,260
encapsulation so what we found is that

381
00:27:57,440 --> 00:28:02,350
say IP nukkie encapsulation or

382
00:28:00,260 --> 00:28:04,610
particular udp-based encapsulations

383
00:28:02,350 --> 00:28:07,459
actually can have multiple transport

384
00:28:04,610 --> 00:28:10,100
protocols per packet that contain their

385
00:28:07,460 --> 00:28:13,040
own checksum so conceptually it's

386
00:28:10,100 --> 00:28:16,790
possible to have two three four five or

387
00:28:13,040 --> 00:28:18,920
six check sums in a single packet TCP

388
00:28:16,790 --> 00:28:23,120
check sum and UDP checksum a GRE

389
00:28:18,920 --> 00:28:26,630
checksum it's all possible so we want to

390
00:28:23,120 --> 00:28:28,429
offload all of those check sums and we

391
00:28:26,630 --> 00:28:30,440
found some techniques that can leverage

392
00:28:28,430 --> 00:28:32,830
rudimentary checksum offload of one

393
00:28:30,440 --> 00:28:36,580
checksum to actually support multiple

394
00:28:32,830 --> 00:28:39,710
check something even in the same packet

395
00:28:36,580 --> 00:28:42,470
so a little bit of detail so transmit

396
00:28:39,710 --> 00:28:45,740
checksum also offload has two forms one

397
00:28:42,470 --> 00:28:49,910
is protocol specific one is protocol

398
00:28:45,740 --> 00:28:53,240
agnostic the protocol specific one we

399
00:28:49,910 --> 00:28:55,570
the host sends a packet into the device

400
00:28:53,240 --> 00:28:57,800
the device actually parses a packet

401
00:28:55,570 --> 00:29:00,919
determines if there's a transport header

402
00:28:57,800 --> 00:29:02,899
and the checksum and if there is it does

403
00:29:00,920 --> 00:29:04,760
all the operations to set the checksum

404
00:29:02,900 --> 00:29:07,220
so to perform the ones complement

405
00:29:04,760 --> 00:29:09,740
checksum over the data it will compute

406
00:29:07,220 --> 00:29:11,540
the suit pseudo header checksum if

407
00:29:09,740 --> 00:29:14,210
there's one there and it will set the

408
00:29:11,540 --> 00:29:17,090
checksum in the appropriate field of the

409
00:29:14,210 --> 00:29:21,020
transport layer the more generic method

410
00:29:17,090 --> 00:29:23,030
is for the host to indicate in

411
00:29:21,020 --> 00:29:25,250
instructions exactly how to do the

412
00:29:23,030 --> 00:29:28,730
checksum so it provides two pieces of

413
00:29:25,250 --> 00:29:29,510
information to the device one is where

414
00:29:28,730 --> 00:29:32,060
the checksum

415
00:29:29,510 --> 00:29:34,280
arts starting offset in the packet and

416
00:29:32,060 --> 00:29:36,800
the other one is the offset to write to

417
00:29:34,280 --> 00:29:40,250
checksum which would typically be the

418
00:29:36,800 --> 00:29:42,620
checksum field of TCP for instance and

419
00:29:40,250 --> 00:29:46,190
then the start would be the offset of

420
00:29:42,620 --> 00:29:48,199
the TCP header the device gets this and

421
00:29:46,190 --> 00:29:50,510
it will perform the ones complement some

422
00:29:48,200 --> 00:29:54,020
starting from the starting point to the

423
00:29:50,510 --> 00:29:56,120
end of the packet and that some whatever

424
00:29:54,020 --> 00:29:58,370
it gets it basically adds it in to the

425
00:29:56,120 --> 00:30:01,489
existing value and the checksum field

426
00:29:58,370 --> 00:30:04,310
and checks then sets the field as long

427
00:30:01,490 --> 00:30:07,220
as the host set this up and initialize a

428
00:30:04,310 --> 00:30:09,830
checksum field correctly the device will

429
00:30:07,220 --> 00:30:11,540
set that's correct checksum has no idea

430
00:30:09,830 --> 00:30:13,550
what kind of checked something it is

431
00:30:11,540 --> 00:30:15,110
doesn't know if it's UDP or TCP it

432
00:30:13,550 --> 00:30:19,610
doesn't care it just knows it's the

433
00:30:15,110 --> 00:30:21,830
standard internet package checksum for

434
00:30:19,610 --> 00:30:23,990
receive we have an analogous situation

435
00:30:21,830 --> 00:30:26,990
there is a protocol generic and a

436
00:30:23,990 --> 00:30:28,670
protocol specific method the protocol

437
00:30:26,990 --> 00:30:32,210
specific method is called checksum

438
00:30:28,670 --> 00:30:35,660
unnecessary as packets are received the

439
00:30:32,210 --> 00:30:37,280
NIC parses the packet determines if

440
00:30:35,660 --> 00:30:39,830
there is a transport protocol that

441
00:30:37,280 --> 00:30:43,100
contains a checksum and performs a work

442
00:30:39,830 --> 00:30:44,510
to actually verify the checksum so it

443
00:30:43,100 --> 00:30:46,750
doesn't one's complement checksum

444
00:30:44,510 --> 00:30:49,910
computes the pseudo header adds them

445
00:30:46,750 --> 00:30:52,700
checks if the result is checksum zero if

446
00:30:49,910 --> 00:30:54,650
it is the checksum has been verified and

447
00:30:52,700 --> 00:30:57,680
sets a bit in the receive descriptor to

448
00:30:54,650 --> 00:31:00,290
inform the host that it's verified the

449
00:30:57,680 --> 00:31:03,170
checksum so again that is protocol

450
00:31:00,290 --> 00:31:05,510
specific it only really works with TCP

451
00:31:03,170 --> 00:31:08,500
and UDP packets that the device

452
00:31:05,510 --> 00:31:11,930
explicitly parses the more generic

453
00:31:08,500 --> 00:31:15,170
method is checksum complete in this case

454
00:31:11,930 --> 00:31:18,080
the device performs a one's complement

455
00:31:15,170 --> 00:31:19,790
some of the whole packet starting from

456
00:31:18,080 --> 00:31:23,389
the IP header through the end of the

457
00:31:19,790 --> 00:31:25,639
packet and it simply returns that some

458
00:31:23,390 --> 00:31:28,160
in the receive descriptor to the host

459
00:31:25,640 --> 00:31:30,320
the host can take that and actually use

460
00:31:28,160 --> 00:31:33,770
it through simple manipulations of

461
00:31:30,320 --> 00:31:36,899
checksum to verify any number of check

462
00:31:33,770 --> 00:31:39,779
sums in the packet so this is

463
00:31:36,899 --> 00:31:43,678
really efficient really a very generic

464
00:31:39,779 --> 00:31:47,850
and is able as I said to verify many

465
00:31:43,679 --> 00:31:50,220
checks on the attack so looking at

466
00:31:47,850 --> 00:31:52,559
segmentation offload one of the

467
00:31:50,220 --> 00:31:56,129
observations that we've made is that

468
00:31:52,559 --> 00:31:58,019
networking stacks are more efficient

469
00:31:56,129 --> 00:32:00,149
when they process large packets as

470
00:31:58,019 --> 00:32:02,070
opposed to small packets so in

471
00:32:00,149 --> 00:32:05,489
particular per packet processing per

472
00:32:02,070 --> 00:32:06,509
packet overhead in the stack is

473
00:32:05,490 --> 00:32:09,600
significant

474
00:32:06,509 --> 00:32:13,019
more than processing the data bytes

475
00:32:09,600 --> 00:32:14,699
usually so we want to see if we can

476
00:32:13,019 --> 00:32:18,320
arrange the system so we can cross this

477
00:32:14,700 --> 00:32:20,639
large packets instead of small packets

478
00:32:18,320 --> 00:32:23,189
so there's two forms of this is one on

479
00:32:20,639 --> 00:32:26,129
transmit and one receive on transmit

480
00:32:23,190 --> 00:32:31,700
segmentation offload the idea is the

481
00:32:26,129 --> 00:32:34,830
host produces a large packet say a 64k

482
00:32:31,700 --> 00:32:36,809
TCP segment and we want to break this

483
00:32:34,830 --> 00:32:39,418
packet up into smaller chunks for

484
00:32:36,809 --> 00:32:42,990
sending out into the network which may

485
00:32:39,419 --> 00:32:44,580
have say 1500 byte em to you so we want

486
00:32:42,990 --> 00:32:46,499
to do this as low as possible so the

487
00:32:44,580 --> 00:32:50,070
idea is the stack process is the big

488
00:32:46,499 --> 00:32:52,799
packet processes one IP header one TCP

489
00:32:50,070 --> 00:32:55,080
header and at the lowest point possible

490
00:32:52,799 --> 00:32:57,960
either in the software or even in the

491
00:32:55,080 --> 00:33:00,629
network device there's a type of

492
00:32:57,960 --> 00:33:03,210
segmentation or fragmentation so we

493
00:33:00,629 --> 00:33:05,969
slice up the data give each packet its

494
00:33:03,210 --> 00:33:09,539
own IP header on TCP header and send

495
00:33:05,970 --> 00:33:11,190
each one so there is a software variant

496
00:33:09,539 --> 00:33:13,139
Hardware variant of this software

497
00:33:11,190 --> 00:33:15,720
variant is called GSO generic

498
00:33:13,139 --> 00:33:18,479
segmentation offload the hardware

499
00:33:15,720 --> 00:33:21,409
variant is lsah large segmentation

500
00:33:18,480 --> 00:33:24,570
offload you might see it also called TSO

501
00:33:21,409 --> 00:33:28,710
TCP segmentation offload with this when

502
00:33:24,570 --> 00:33:31,649
this is specific to TCP received

503
00:33:28,710 --> 00:33:34,649
segmentation offload is the opposite so

504
00:33:31,649 --> 00:33:37,529
when small packets are received we try

505
00:33:34,649 --> 00:33:39,989
to coalesce these into larger segments

506
00:33:37,529 --> 00:33:44,369
and larger packets so again this is per

507
00:33:39,990 --> 00:33:46,559
flow similar operation and there are two

508
00:33:44,369 --> 00:33:48,389
variants of this one of the software one

509
00:33:46,559 --> 00:33:51,180
is the hardware the software is generic

510
00:33:48,389 --> 00:33:54,689
receive off the Jaro the hardware

511
00:33:51,180 --> 00:33:56,970
is LR a larger sieve offload this

512
00:33:54,690 --> 00:33:59,340
particular are flowed of all the checks

513
00:33:56,970 --> 00:34:02,790
or all the basic offload is probably the

514
00:33:59,340 --> 00:34:04,470
hardest one it does require the network

515
00:34:02,790 --> 00:34:06,180
device to be able to parse the packet

516
00:34:04,470 --> 00:34:09,420
and understand a lot of details of the

517
00:34:06,180 --> 00:34:11,370
protocol so for instance the

518
00:34:09,420 --> 00:34:13,590
implementation that do this really only

519
00:34:11,370 --> 00:34:17,100
understand TCP usually some of that

520
00:34:13,590 --> 00:34:19,290
encapsulation but until we have say a

521
00:34:17,100 --> 00:34:23,159
fully programmable environment it is

522
00:34:19,290 --> 00:34:24,929
hard to generalize this one one thing

523
00:34:23,159 --> 00:34:27,810
I'd like to mention about segmentation

524
00:34:24,929 --> 00:34:30,719
offload this really only works in

525
00:34:27,810 --> 00:34:34,199
conjunction with checksum offload so

526
00:34:30,719 --> 00:34:36,449
this is a good example of where we

527
00:34:34,199 --> 00:34:39,239
develop a more complex offload but it

528
00:34:36,449 --> 00:34:41,069
requires some of the basic offloads in

529
00:34:39,239 --> 00:34:43,109
order to operate and we definitely see

530
00:34:41,070 --> 00:34:44,760
this with some of the more advanced

531
00:34:43,110 --> 00:34:48,090
offloads that we'll talk about in a

532
00:34:44,760 --> 00:34:51,690
little bit the third basic offload is

533
00:34:48,090 --> 00:34:54,210
multi cue this is done in conjunction

534
00:34:51,690 --> 00:34:57,210
with multiprocessor systems and the idea

535
00:34:54,210 --> 00:34:58,650
is that the NIC has some number of

536
00:34:57,210 --> 00:35:02,220
received queues and some number of

537
00:34:58,650 --> 00:35:04,860
transmit kids where queues usually are

538
00:35:02,220 --> 00:35:08,520
assigned to a cpu and we get a sort of

539
00:35:04,860 --> 00:35:11,550
parallelism by the CPUC to queue

540
00:35:08,520 --> 00:35:13,530
affinity one of the interesting

541
00:35:11,550 --> 00:35:16,280
properties is that once we have kids we

542
00:35:13,530 --> 00:35:19,560
can assign properties to them

543
00:35:16,280 --> 00:35:21,180
particularly on transmit each queue can

544
00:35:19,560 --> 00:35:22,950
have its own attribute so for instance

545
00:35:21,180 --> 00:35:25,440
we kind of high priority kids and low

546
00:35:22,950 --> 00:35:27,960
priority kids one of the important

547
00:35:25,440 --> 00:35:29,610
aspects when we deal with multi queue we

548
00:35:27,960 --> 00:35:31,760
do want to try to keep packets in order

549
00:35:29,610 --> 00:35:33,930
so for instance we don't want to be

550
00:35:31,760 --> 00:35:35,700
distributing packets in the same flow

551
00:35:33,930 --> 00:35:37,620
across different queues either and

552
00:35:35,700 --> 00:35:41,540
transliteracy so there are some

553
00:35:37,620 --> 00:35:44,160
techniques in the model of queuing to

554
00:35:41,540 --> 00:35:49,860
try to enable that in order delivery as

555
00:35:44,160 --> 00:35:52,049
much as possible so on transmit there

556
00:35:49,860 --> 00:35:55,320
are essentially two methods to do this

557
00:35:52,050 --> 00:35:59,190
one is the easy method which is

558
00:35:55,320 --> 00:36:02,340
fundamentally each CPU is assigned to a

559
00:35:59,190 --> 00:36:04,980
queue so when an application is sending

560
00:36:02,340 --> 00:36:07,290
a packet for instance the

561
00:36:04,980 --> 00:36:10,800
Hieu chosen is the one associated with

562
00:36:07,290 --> 00:36:12,960
that cpu the applications running on and

563
00:36:10,800 --> 00:36:15,600
the advantage of this is that we get

564
00:36:12,960 --> 00:36:17,700
this sort of siloing locality for

565
00:36:15,600 --> 00:36:20,759
instance when a packet is sent on a

566
00:36:17,700 --> 00:36:23,009
queue we have to lock the queue in order

567
00:36:20,760 --> 00:36:26,760
to manipulate the queue pointer if we do

568
00:36:23,010 --> 00:36:28,530
this in cpu / queue then there's no

569
00:36:26,760 --> 00:36:30,180
contention for the lock and no

570
00:36:28,530 --> 00:36:31,040
contention for the structures of the

571
00:36:30,180 --> 00:36:34,589
queue

572
00:36:31,040 --> 00:36:36,840
these second method is when the driver

573
00:36:34,590 --> 00:36:39,840
selects the queue so as I mentioned

574
00:36:36,840 --> 00:36:42,240
queues can have some rich semantics such

575
00:36:39,840 --> 00:36:44,070
as priority what we've done there

576
00:36:42,240 --> 00:36:46,709
instead of trying to expose all possible

577
00:36:44,070 --> 00:36:48,450
combinations of this we allow the driver

578
00:36:46,710 --> 00:36:51,900
to basically understand

579
00:36:48,450 --> 00:36:54,000
the queue layout of the topology what

580
00:36:51,900 --> 00:36:55,500
the different queues are and when the

581
00:36:54,000 --> 00:36:58,619
host Jack wants to send it basically

582
00:36:55,500 --> 00:37:00,960
asked the driver that has intimate

583
00:36:58,619 --> 00:37:02,880
detail of the device what's the best

584
00:37:00,960 --> 00:37:04,710
queue to send this on the driver can do

585
00:37:02,880 --> 00:37:07,290
that so for instance if we're sending a

586
00:37:04,710 --> 00:37:09,210
high priority packet where the metadata

587
00:37:07,290 --> 00:37:12,720
associated with packet said this high

588
00:37:09,210 --> 00:37:15,300
priority when this goes into the driver

589
00:37:12,720 --> 00:37:17,490
it looks up the queue that's appropriate

590
00:37:15,300 --> 00:37:20,940
for that so they may have a CPU to queue

591
00:37:17,490 --> 00:37:22,470
affinity priority there's also other

592
00:37:20,940 --> 00:37:27,210
attributes you could apply like rate

593
00:37:22,470 --> 00:37:30,060
limit on the receive side this is

594
00:37:27,210 --> 00:37:32,730
normally called packet steering so the

595
00:37:30,060 --> 00:37:35,040
idea is when packets come in to the NIC

596
00:37:32,730 --> 00:37:37,530
they need to be distributed amongst the

597
00:37:35,040 --> 00:37:39,600
queues it turns out this is a lot like a

598
00:37:37,530 --> 00:37:40,950
CMP and some of the techniques are very

599
00:37:39,600 --> 00:37:46,380
similar where we're trying to distribute

600
00:37:40,950 --> 00:37:48,390
in a CMP to multiple interfaces on the

601
00:37:46,380 --> 00:37:49,830
state listen a stateless ID there are

602
00:37:48,390 --> 00:37:52,069
two forms of this one is called received

603
00:37:49,830 --> 00:37:55,440
packets jaring that's a software variant

604
00:37:52,070 --> 00:37:57,990
RSS we see site scaling is a hardware

605
00:37:55,440 --> 00:38:01,230
variant they both essentially work this

606
00:37:57,990 --> 00:38:03,359
the same when packets come in a hash is

607
00:38:01,230 --> 00:38:04,560
performed over the five tuple of the

608
00:38:03,359 --> 00:38:07,650
packet of the transport layer is

609
00:38:04,560 --> 00:38:09,779
available or three Chappel if we're

610
00:38:07,650 --> 00:38:13,020
using the flow label but the effect is

611
00:38:09,780 --> 00:38:15,570
to identify the flow by a hash take that

612
00:38:13,020 --> 00:38:18,390
hash and map that into one of the queues

613
00:38:15,570 --> 00:38:18,779
and that ways we're also consistent so

614
00:38:18,390 --> 00:38:20,759
for this

615
00:38:18,779 --> 00:38:23,099
particular flow it always has the same

616
00:38:20,759 --> 00:38:25,559
hash therefore we can always map that to

617
00:38:23,099 --> 00:38:29,189
the same queue in order to facilitate in

618
00:38:25,559 --> 00:38:30,749
order delivery an extension of this is

619
00:38:29,189 --> 00:38:34,499
something called receive flow steering

620
00:38:30,749 --> 00:38:37,589
in this case the host itself can

621
00:38:34,499 --> 00:38:40,890
actually sort of program for each flow

622
00:38:37,589 --> 00:38:43,439
which queue to use this is very powerful

623
00:38:40,890 --> 00:38:46,408
mechanism so on a per flow basis the

624
00:38:43,439 --> 00:38:48,689
host can indicate okay for this flow use

625
00:38:46,409 --> 00:38:50,789
this queue there are two variants of

626
00:38:48,689 --> 00:38:53,819
this also there is a software variant

627
00:38:50,789 --> 00:38:56,749
and hardware variant the advantage of

628
00:38:53,819 --> 00:39:00,029
this is to get a really good isolation

629
00:38:56,749 --> 00:39:02,488
some people use this where they pin an

630
00:39:00,029 --> 00:39:04,229
application to a CPU where that

631
00:39:02,489 --> 00:39:06,900
application only runs on that CPU and

632
00:39:04,229 --> 00:39:10,319
they associate a network queue with that

633
00:39:06,900 --> 00:39:12,959
application and receive flow steering

634
00:39:10,319 --> 00:39:15,509
can actually arrange it so that packets

635
00:39:12,959 --> 00:39:18,598
only for that applications flows go to

636
00:39:15,509 --> 00:39:20,880
that queue so it's very siloed the

637
00:39:18,599 --> 00:39:22,380
application acts like it's the the only

638
00:39:20,880 --> 00:39:26,789
application on the system we get a lot

639
00:39:22,380 --> 00:39:29,279
of performance gains that way so with

640
00:39:26,789 --> 00:39:31,169
that I will turn it over to Simon who

641
00:39:29,279 --> 00:39:40,769
will talk about some of the more

642
00:39:31,169 --> 00:39:44,609
advanced offloads thanks Dom so so far

643
00:39:40,769 --> 00:39:46,948
tom is taking us to some basic uploads

644
00:39:44,609 --> 00:39:50,909
and the basic functionality of the Nick

645
00:39:46,949 --> 00:39:53,069
itself well as the use cases the demands

646
00:39:50,909 --> 00:39:55,289
of the users evolve and the hardware

647
00:39:53,069 --> 00:39:57,259
evolves at the same time it only makes

648
00:39:55,289 --> 00:39:59,959
sense that more and more processing

649
00:39:57,259 --> 00:40:02,579
could be pushed down to the hardware and

650
00:39:59,959 --> 00:40:04,439
so in this section we'll look at at

651
00:40:02,579 --> 00:40:06,059
examples of that in terms of uploading

652
00:40:04,439 --> 00:40:09,509
more of the data plane or of the back of

653
00:40:06,059 --> 00:40:11,609
processing but before I get into some

654
00:40:09,509 --> 00:40:15,140
examples in that area I just like to

655
00:40:11,609 --> 00:40:17,549
quickly cover some of the hardware

656
00:40:15,140 --> 00:40:21,419
solutions that might be used in in this

657
00:40:17,549 --> 00:40:23,339
kind of area so it's important to note

658
00:40:21,419 --> 00:40:26,009
that these solutions are it's a little

659
00:40:23,339 --> 00:40:28,409
bit of a mix and match it depends very

660
00:40:26,009 --> 00:40:31,140
much on the use case which choice is

661
00:40:28,409 --> 00:40:32,700
appropriate and some hardware choices

662
00:40:31,140 --> 00:40:34,980
match some use cases more

663
00:40:32,700 --> 00:40:35,970
chillie than others but at the same time

664
00:40:34,980 --> 00:40:40,320
they're not necessarily mutually

665
00:40:35,970 --> 00:40:41,549
exclusive so so far the next we've

666
00:40:40,320 --> 00:40:43,589
talked about a fall in the first

667
00:40:41,550 --> 00:40:46,050
category where you have a fixed data

668
00:40:43,589 --> 00:40:49,859
plane so this will become kind of a sick

669
00:40:46,050 --> 00:40:54,180
that implements a pipeline in hardware

670
00:40:49,859 --> 00:40:56,040
and we can also use more programmable

671
00:40:54,180 --> 00:40:59,279
technologies and this kind of fall into

672
00:40:56,040 --> 00:41:01,800
three sub categories we have semi

673
00:40:59,280 --> 00:41:04,560
specialized processes called network

674
00:41:01,800 --> 00:41:07,050
flow process or NP or network processing

675
00:41:04,560 --> 00:41:09,299
unit and so in this it's a little bit

676
00:41:07,050 --> 00:41:14,150
similar to a general process a purpose

677
00:41:09,300 --> 00:41:17,130
processor like a CPU on a in in a server

678
00:41:14,150 --> 00:41:19,530
you have instructions it executes the

679
00:41:17,130 --> 00:41:23,490
program and that program describes the

680
00:41:19,530 --> 00:41:24,930
pipeline they differ from a general

681
00:41:23,490 --> 00:41:26,399
purpose CPU is that there are a little

682
00:41:24,930 --> 00:41:28,740
bit more specialized so they might have

683
00:41:26,400 --> 00:41:31,890
instructions to do a network related

684
00:41:28,740 --> 00:41:34,950
functionality or or they might have much

685
00:41:31,890 --> 00:41:36,240
higher thread density things along these

686
00:41:34,950 --> 00:41:40,169
lines to make them more suited to

687
00:41:36,240 --> 00:41:42,209
network processing and then you have the

688
00:41:40,170 --> 00:41:44,190
FPGA which is probably the most

689
00:41:42,210 --> 00:41:45,450
programmable solution possible here we

690
00:41:44,190 --> 00:41:48,240
have gate level programming so

691
00:41:45,450 --> 00:41:52,790
essentially you can program the hardware

692
00:41:48,240 --> 00:41:55,109
itself find it and so you can describe

693
00:41:52,790 --> 00:41:56,640
at the gate level what the pipeline

694
00:41:55,109 --> 00:41:58,828
should be and then we have

695
00:41:56,640 --> 00:42:01,680
general-purpose processes so this would

696
00:41:58,829 --> 00:42:06,540
be putting say an ARM processor onto the

697
00:42:01,680 --> 00:42:09,029
neck to execute the pipeline and and you

698
00:42:06,540 --> 00:42:10,560
will get back to to this the

699
00:42:09,030 --> 00:42:14,700
programmability aspects a little later

700
00:42:10,560 --> 00:42:16,230
in the presentation so back to data

701
00:42:14,700 --> 00:42:19,290
plane acceleration here we have a

702
00:42:16,230 --> 00:42:23,280
diagram that represents roughly how this

703
00:42:19,290 --> 00:42:25,230
works so we have applications and then

704
00:42:23,280 --> 00:42:28,440
in the corner we have a implementation

705
00:42:25,230 --> 00:42:30,270
of a data path and then down in the in

706
00:42:28,440 --> 00:42:32,220
the offload Nick we have a data plane

707
00:42:30,270 --> 00:42:34,770
which implements some more or maybe all

708
00:42:32,220 --> 00:42:37,859
of the functionality of the data path in

709
00:42:34,770 --> 00:42:40,410
the in the kernel and so this is able to

710
00:42:37,859 --> 00:42:44,009
afford for for example for packets

711
00:42:40,410 --> 00:42:47,490
around and so on so things

712
00:42:44,010 --> 00:42:48,930
advantage of this is that more more of

713
00:42:47,490 --> 00:42:51,359
the processing of the packets can be

714
00:42:48,930 --> 00:42:54,450
done in the hardware and this alleviates

715
00:42:51,360 --> 00:42:56,580
the hosts of this task so the CPU can be

716
00:42:54,450 --> 00:42:58,109
used for other things it also can lead

717
00:42:56,580 --> 00:43:06,180
to higher performance depending on the

718
00:42:58,110 --> 00:43:08,160
use case so here we're going to go to

719
00:43:06,180 --> 00:43:12,509
for topics in the data plane

720
00:43:08,160 --> 00:43:16,920
acceleration before I move on so the

721
00:43:12,510 --> 00:43:18,990
first one is match action so this is a

722
00:43:16,920 --> 00:43:21,990
foundational building block of a data

723
00:43:18,990 --> 00:43:26,490
path and an indeed of offloading and

724
00:43:21,990 --> 00:43:27,839
data path into the NIC so the first step

725
00:43:26,490 --> 00:43:30,209
is that we do some kind of header

726
00:43:27,840 --> 00:43:32,910
extraction so we pull out some fields

727
00:43:30,210 --> 00:43:34,770
for example the five Chuco but those we

728
00:43:32,910 --> 00:43:38,520
also have metadata for example the port

729
00:43:34,770 --> 00:43:41,400
that the packet arrived in other things

730
00:43:38,520 --> 00:43:44,610
can also be available then using this

731
00:43:41,400 --> 00:43:46,950
data we typically do a hash and then

732
00:43:44,610 --> 00:43:51,180
there has looking up in the hash table

733
00:43:46,950 --> 00:43:52,770
we try to find a match and if we do find

734
00:43:51,180 --> 00:43:54,299
a match then the match will supply some

735
00:43:52,770 --> 00:43:57,960
kind of action there should be executed

736
00:43:54,300 --> 00:43:59,400
or a list of actions even so this could

737
00:43:57,960 --> 00:44:01,800
be to forward to a different port it

738
00:43:59,400 --> 00:44:04,080
could be to drop it could be to move on

739
00:44:01,800 --> 00:44:07,140
to another table if you have multiple

740
00:44:04,080 --> 00:44:11,009
tables present it could be to do some

741
00:44:07,140 --> 00:44:13,319
kind of magnification of the packet we

742
00:44:11,010 --> 00:44:14,850
can also do more stateful things like do

743
00:44:13,320 --> 00:44:19,130
policing which I'll get to a little bit

744
00:44:14,850 --> 00:44:19,130
later or connection tracking

745
00:44:20,510 --> 00:44:29,160
so using this max action scheme we can

746
00:44:25,290 --> 00:44:30,900
create a forwarding pipeline and so here

747
00:44:29,160 --> 00:44:33,529
we have the matches and actions which we

748
00:44:30,900 --> 00:44:36,150
can use to for between physical ports

749
00:44:33,530 --> 00:44:38,850
the header extraction can operate at

750
00:44:36,150 --> 00:44:43,050
various levels of the protocol stack so

751
00:44:38,850 --> 00:44:45,270
you would begin with with l2 you can

752
00:44:43,050 --> 00:44:48,840
also extract the source and destination

753
00:44:45,270 --> 00:44:50,700
IP addresses from l3 and then you can

754
00:44:48,840 --> 00:44:52,910
also select for example the ports that

755
00:44:50,700 --> 00:44:56,460
layer for date so you can create a

756
00:44:52,910 --> 00:44:57,410
specific role to example do some kind of

757
00:44:56,460 --> 00:44:59,780
special treatment

758
00:44:57,410 --> 00:45:04,810
port 80 traffic possibly to a separate

759
00:44:59,780 --> 00:45:04,810
host it's fairly flexible in this regard

760
00:45:05,860 --> 00:45:11,960
oftentimes this is set up in such a way

761
00:45:08,420 --> 00:45:13,550
that if the offload data plane can't

762
00:45:11,960 --> 00:45:15,770
process a particular packet for some

763
00:45:13,550 --> 00:45:18,500
reason or perhaps it's for a protocol

764
00:45:15,770 --> 00:45:21,710
that it can't understand perhaps it's

765
00:45:18,500 --> 00:45:25,430
table capacity has been exceeded anyone

766
00:45:21,710 --> 00:45:26,960
a variety of reasons we may have you may

767
00:45:25,430 --> 00:45:29,120
have a mechanism in place that allows

768
00:45:26,960 --> 00:45:32,480
the processing of the packet to be

769
00:45:29,120 --> 00:45:34,370
pushed back to the to the host and the

770
00:45:32,480 --> 00:45:35,870
host marry after that in in various ways

771
00:45:34,370 --> 00:45:38,210
in my process the packet it might

772
00:45:35,870 --> 00:45:40,069
process the packet and then also program

773
00:45:38,210 --> 00:45:41,930
the hardware to tell it what to do the

774
00:45:40,070 --> 00:45:46,790
next time it sees a packet foot say for

775
00:45:41,930 --> 00:45:48,740
the same flow and we can also do tunnel

776
00:45:46,790 --> 00:45:51,050
encapsulation and decapsulation as well

777
00:45:48,740 --> 00:45:53,600
as tagging at this point and this is of

778
00:45:51,050 --> 00:45:58,130
course optional depending on what the

779
00:45:53,600 --> 00:45:59,870
desires of the system are and so so in

780
00:45:58,130 --> 00:46:02,710
this system we can see that essentially

781
00:45:59,870 --> 00:46:06,109
we have a pack of processing pipeline

782
00:46:02,710 --> 00:46:07,850
packets can come into the machine they

783
00:46:06,110 --> 00:46:09,920
can be processed they can be

784
00:46:07,850 --> 00:46:11,450
encapsulated or des capsulated and they

785
00:46:09,920 --> 00:46:17,720
can be pushed back out of the machine or

786
00:46:11,450 --> 00:46:20,710
towards the host so building on this a

787
00:46:17,720 --> 00:46:23,779
little further we can also implement QoS

788
00:46:20,710 --> 00:46:27,200
in the neck offload the QoS and your

789
00:46:23,780 --> 00:46:30,130
floating so in the ingress cases as

790
00:46:27,200 --> 00:46:32,419
packets that are arriving on the machine

791
00:46:30,130 --> 00:46:34,480
the interesting thing about this use

792
00:46:32,420 --> 00:46:38,480
case is that there's no queue available

793
00:46:34,480 --> 00:46:39,500
so the actions that can be applied are

794
00:46:38,480 --> 00:46:42,950
fairly limited

795
00:46:39,500 --> 00:46:45,830
we can release the packet perhaps by

796
00:46:42,950 --> 00:46:49,970
dropping it or marking it we can filter

797
00:46:45,830 --> 00:46:52,130
it and so us is a little bit more

798
00:46:49,970 --> 00:46:53,439
interesting or a little bit more complex

799
00:46:52,130 --> 00:46:56,210
perhaps is a better way to put it

800
00:46:53,440 --> 00:46:59,090
because we have a queue so we have the

801
00:46:56,210 --> 00:47:01,130
option of doing a much larger number of

802
00:46:59,090 --> 00:47:03,830
different things with the packets in

803
00:47:01,130 --> 00:47:07,490
order to for example enforcer decide

804
00:47:03,830 --> 00:47:10,200
packet rate we can delay packets we go

805
00:47:07,490 --> 00:47:12,959
of course drop them and so on

806
00:47:10,200 --> 00:47:14,730
and this is an area of which is received

807
00:47:12,960 --> 00:47:17,670
significant research over the years and

808
00:47:14,730 --> 00:47:19,710
also this research is applicable there

809
00:47:17,670 --> 00:47:23,070
of course are challenges in implementing

810
00:47:19,710 --> 00:47:25,290
individual algorithms on an offload NIC

811
00:47:23,070 --> 00:47:28,440
as opposed to a holster it's usually a

812
00:47:25,290 --> 00:47:29,759
more limited execution environment but

813
00:47:28,440 --> 00:47:32,850
nonetheless the same principles

814
00:47:29,760 --> 00:47:34,950
generally apply now in this diagram we

815
00:47:32,850 --> 00:47:39,720
have packets coming into the machine

816
00:47:34,950 --> 00:47:41,160
into the neck and also exiting the neck

817
00:47:39,720 --> 00:47:42,390
so they're being folded from one court

818
00:47:41,160 --> 00:47:45,029
to another of the neck that could be a

819
00:47:42,390 --> 00:47:47,609
virtual port or a physical port and the

820
00:47:45,030 --> 00:47:52,170
NIC is applying some kind of QoS as they

821
00:47:47,610 --> 00:47:53,880
traverse the neck in the next slide in

822
00:47:52,170 --> 00:47:57,990
this slide we have a slightly different

823
00:47:53,880 --> 00:48:00,330
setup so here we have packets of course

824
00:47:57,990 --> 00:48:02,220
it's two directional but I just will

825
00:48:00,330 --> 00:48:05,460
only talk about one direction which is

826
00:48:02,220 --> 00:48:07,950
Mac it's originating from an application

827
00:48:05,460 --> 00:48:09,900
running on the host and heading out

828
00:48:07,950 --> 00:48:13,980
towards the wire are the physical port

829
00:48:09,900 --> 00:48:16,170
of the neck and the neck is applying

830
00:48:13,980 --> 00:48:18,600
some kind of QoS policy to those packets

831
00:48:16,170 --> 00:48:20,550
as they traverse the NIC this is so in

832
00:48:18,600 --> 00:48:23,339
this particular case we have different

833
00:48:20,550 --> 00:48:26,250
applications and by some kind of

834
00:48:23,340 --> 00:48:29,040
selection mechanism they are allocated

835
00:48:26,250 --> 00:48:33,110
to different queues and each queue has a

836
00:48:29,040 --> 00:48:35,700
different read instance running on it

837
00:48:33,110 --> 00:48:37,170
and this could have could mark the

838
00:48:35,700 --> 00:48:39,419
packets or drop the packets if they're

839
00:48:37,170 --> 00:48:43,020
exceeding a certain rate and and so on

840
00:48:39,420 --> 00:48:46,910
and if this of course is not limited to

841
00:48:43,020 --> 00:48:49,620
read I just use this particular example

842
00:48:46,910 --> 00:48:51,779
so with the point I wanted to draw out

843
00:48:49,620 --> 00:48:54,029
here is that there are two fundamentally

844
00:48:51,780 --> 00:48:57,050
different models here one is of applying

845
00:48:54,030 --> 00:48:59,820
curious between ports of the neck and

846
00:48:57,050 --> 00:49:01,110
one is Carraway supplied two packets

847
00:48:59,820 --> 00:49:07,590
originating from the host and then

848
00:49:01,110 --> 00:49:10,200
passing through the neck so moving on to

849
00:49:07,590 --> 00:49:13,920
the last part of my section I talked

850
00:49:10,200 --> 00:49:15,390
about crypto offload a little bit so

851
00:49:13,920 --> 00:49:16,920
this is a little bit different to what

852
00:49:15,390 --> 00:49:19,170
I've talked about so far with the data

853
00:49:16,920 --> 00:49:22,599
plane a processing package in the sense

854
00:49:19,170 --> 00:49:24,099
that what we're really focusing now is

855
00:49:22,599 --> 00:49:26,259
or floating from the host a very

856
00:49:24,099 --> 00:49:30,690
computationally expensive part of packet

857
00:49:26,259 --> 00:49:34,210
forwarding if you are applying crypto

858
00:49:30,690 --> 00:49:37,299
and the crypto itself tends to be quite

859
00:49:34,210 --> 00:49:42,460
complex so what we have at the moment is

860
00:49:37,299 --> 00:49:44,739
we have an offload of TLS and this is

861
00:49:42,460 --> 00:49:46,749
only dealing with TLS connections which

862
00:49:44,739 --> 00:49:48,249
are in the established state so the the

863
00:49:46,749 --> 00:49:51,328
host is still responsible for the

864
00:49:48,249 --> 00:49:54,519
connection establishment it's still

865
00:49:51,329 --> 00:49:58,739
responsible for the TLS handshake the

866
00:49:54,519 --> 00:50:03,160
certificate negotiation and so on and

867
00:49:58,739 --> 00:50:05,079
once all connection is established then

868
00:50:03,160 --> 00:50:07,499
it is able to pass that connection to

869
00:50:05,079 --> 00:50:10,749
the Kay TLS module inside the kernel

870
00:50:07,499 --> 00:50:12,189
which in turn so at that point it's

871
00:50:10,749 --> 00:50:16,118
passing the credentials of the

872
00:50:12,190 --> 00:50:18,210
connection into the kts module which in

873
00:50:16,119 --> 00:50:20,470
turn can push those same credentials and

874
00:50:18,210 --> 00:50:26,130
connection information down to the

875
00:50:20,470 --> 00:50:29,558
hardware and then when we do transmit

876
00:50:26,130 --> 00:50:35,440
essentially what the host will do is the

877
00:50:29,559 --> 00:50:37,779
format a TLS frame but it does not

878
00:50:35,440 --> 00:50:40,119
perform the cryptographic operation so

879
00:50:37,779 --> 00:50:44,349
the authorization hash this space for it

880
00:50:40,119 --> 00:50:46,529
but it's not filled in and the packet or

881
00:50:44,349 --> 00:50:49,900
the the record payload is in plain text

882
00:50:46,529 --> 00:50:51,700
and then the offload Nick will receive

883
00:50:49,900 --> 00:50:53,650
this record and perform the

884
00:50:51,700 --> 00:50:57,519
cryptographic operations so it turns the

885
00:50:53,650 --> 00:51:01,779
plaintext into some text and it tends to

886
00:50:57,519 --> 00:51:03,939
fills in hash on rx things are reversed

887
00:51:01,779 --> 00:51:07,200
however it's worth noticing noticing

888
00:51:03,940 --> 00:51:09,609
that Rx is significantly more complex

889
00:51:07,200 --> 00:51:12,009
implementation wise than TX because we

890
00:51:09,609 --> 00:51:17,319
one needs to deal with things like out

891
00:51:12,009 --> 00:51:20,979
of order packets reassembly of fragments

892
00:51:17,319 --> 00:51:22,690
and so on essentially we you have much

893
00:51:20,979 --> 00:51:24,640
less control of what's coming into the

894
00:51:22,690 --> 00:51:26,880
box as opposed to what's going out of

895
00:51:24,640 --> 00:51:26,879
the box

896
00:51:29,859 --> 00:51:37,400
IPSec acceleration flow follows a

897
00:51:34,400 --> 00:51:39,559
similar principle to the TLS in the

898
00:51:37,400 --> 00:51:42,470
sense that some parts are floating and

899
00:51:39,559 --> 00:51:45,980
some parts are not and at this time we

900
00:51:42,470 --> 00:51:47,750
have two models for this one it's the

901
00:51:45,980 --> 00:51:51,529
crypto offer load which is very similar

902
00:51:47,750 --> 00:51:53,720
to what I described to two TLS in the

903
00:51:51,529 --> 00:51:56,450
sense that it is the hosts

904
00:51:53,720 --> 00:52:00,950
responsibility to add the IPSec headers

905
00:51:56,450 --> 00:52:02,569
to the packet but it does not perform

906
00:52:00,950 --> 00:52:05,660
the cryptographic operations which are

907
00:52:02,569 --> 00:52:11,720
left of the card it's worth noticing at

908
00:52:05,660 --> 00:52:14,000
this point that on the one hand in did

909
00:52:11,720 --> 00:52:15,348
this combines a number of different

910
00:52:14,000 --> 00:52:18,020
offloads which which we've already

911
00:52:15,349 --> 00:52:21,589
discussed the LSO the segmentation

912
00:52:18,020 --> 00:52:23,900
offload and I check some offload so one

913
00:52:21,589 --> 00:52:26,630
if one is offloading the crypto one also

914
00:52:23,900 --> 00:52:31,279
needs to upload those operations they

915
00:52:26,630 --> 00:52:33,349
conversely with IPSec traffic one cannot

916
00:52:31,279 --> 00:52:35,450
offload the segmentation offload or the

917
00:52:33,349 --> 00:52:37,190
checksum offload if one does not also

918
00:52:35,450 --> 00:52:41,000
offload the cryptographic so there's

919
00:52:37,190 --> 00:52:42,770
significant benefits to being able to

920
00:52:41,000 --> 00:52:44,720
build this stack but in a sense it's an

921
00:52:42,770 --> 00:52:46,759
evolution well one could not build this

922
00:52:44,720 --> 00:52:49,368
particular piece of technology without

923
00:52:46,760 --> 00:52:53,140
the other pieces that have come earlier

924
00:52:49,369 --> 00:52:53,140
that were the ones that Tom spoke about

925
00:52:53,859 --> 00:52:58,609
the other model we have in is a full

926
00:52:56,569 --> 00:53:01,250
offload so by full of load what you mean

927
00:52:58,609 --> 00:53:05,869
here is that Hunter is responsible for

928
00:53:01,250 --> 00:53:09,349
adding the IPSec headers transmitted and

929
00:53:05,869 --> 00:53:11,809
of course removing the Munn receive this

930
00:53:09,349 --> 00:53:14,059
can lead to additional savings and host

931
00:53:11,809 --> 00:53:18,190
resources it is clearly also more

932
00:53:14,059 --> 00:53:18,190
complicated to implement in the hardware

933
00:53:19,630 --> 00:53:25,760
in which regardless of which of these

934
00:53:22,670 --> 00:53:28,099
two models you use the DI key the key

935
00:53:25,760 --> 00:53:30,980
negotiation between the endpoints rate

936
00:53:28,099 --> 00:53:34,700
which itself is quite complex remains in

937
00:53:30,980 --> 00:53:38,059
the host there is got to offload this

938
00:53:34,700 --> 00:53:40,520
but the way that these things tend to

939
00:53:38,059 --> 00:53:42,560
evolve visible that start with something

940
00:53:40,520 --> 00:53:44,509
simple that has a very large benefits

941
00:53:42,560 --> 00:53:47,570
krypter offload and then we went to a

942
00:53:44,510 --> 00:53:49,340
fuller offload and potentially IKEA he

943
00:53:47,570 --> 00:53:53,540
could also be offloaded at some point in

944
00:53:49,340 --> 00:53:56,510
the future so with that I'd like to hand

945
00:53:53,540 --> 00:54:00,759
over to Andy who now addressed further

946
00:53:56,510 --> 00:54:00,760
evolutions in Nick technology thank you

947
00:54:04,990 --> 00:54:09,410
alright so you've already heard a pretty

948
00:54:07,730 --> 00:54:10,490
long discussion about how this how these

949
00:54:09,410 --> 00:54:11,750
things all works that's good I

950
00:54:10,490 --> 00:54:13,759
appreciate everyone who's still awake

951
00:54:11,750 --> 00:54:17,060
and it's finished checking all their

952
00:54:13,760 --> 00:54:18,950
email no no talk about programmability

953
00:54:17,060 --> 00:54:21,440
so you know what Simon and Tom talk

954
00:54:18,950 --> 00:54:23,200
about really all these offload features

955
00:54:21,440 --> 00:54:25,310
that were enabled exclusively by

956
00:54:23,200 --> 00:54:27,169
hardware providers or hardware vendors

957
00:54:25,310 --> 00:54:29,210
who feel like this is something useful

958
00:54:27,170 --> 00:54:32,270
probably from feedback based on users

959
00:54:29,210 --> 00:54:33,290
maybe not it sort of depends we're gonna

960
00:54:32,270 --> 00:54:34,730
we're gonna build on that and talk about

961
00:54:33,290 --> 00:54:37,100
how it's sort of the next evolution in

962
00:54:34,730 --> 00:54:39,950
this in this path is fully programmable

963
00:54:37,100 --> 00:54:43,670
mix so as time talked about those are

964
00:54:39,950 --> 00:54:45,020
could be good probably good but really

965
00:54:43,670 --> 00:54:46,880
there's a couple key features I want to

966
00:54:45,020 --> 00:54:49,210
highlight and think about and why

967
00:54:46,880 --> 00:54:51,410
programmability of a NIC would matter so

968
00:54:49,210 --> 00:54:53,150
right out of the gate I think one of the

969
00:54:51,410 --> 00:54:54,770
really important things is that it

970
00:54:53,150 --> 00:54:56,540
facilitates really a rapid protocol

971
00:54:54,770 --> 00:54:58,940
development so we're kind of in a phase

972
00:54:56,540 --> 00:55:03,320
right now where fixed-function offload

973
00:54:58,940 --> 00:55:05,210
is so powerful and so useful that if you

974
00:55:03,320 --> 00:55:06,410
if you want to deploy a new protocol or

975
00:55:05,210 --> 00:55:07,940
you think you want to help develop a new

976
00:55:06,410 --> 00:55:09,970
protocol and you want to rapidly iterate

977
00:55:07,940 --> 00:55:12,140
that one of the problems you find

978
00:55:09,970 --> 00:55:14,149
getting yourself into is that well are

979
00:55:12,140 --> 00:55:15,500
we gonna really cripple our current

980
00:55:14,150 --> 00:55:18,050
infrastructure are really gonna burn

981
00:55:15,500 --> 00:55:19,700
more cores processing packets just to

982
00:55:18,050 --> 00:55:21,290
support this new protocol what if we

983
00:55:19,700 --> 00:55:24,020
just live with the old one and deal with

984
00:55:21,290 --> 00:55:26,450
that so programmability gives that

985
00:55:24,020 --> 00:55:30,530
option to offload those operations to

986
00:55:26,450 --> 00:55:32,180
hardware and really still give you the

987
00:55:30,530 --> 00:55:34,670
efficiency you want in the new protocols

988
00:55:32,180 --> 00:55:37,069
so the other obvious one is to quickly

989
00:55:34,670 --> 00:55:40,310
fix bugs and security problems no one

990
00:55:37,070 --> 00:55:42,830
the Linux community likes to remember 15

991
00:55:40,310 --> 00:55:45,259
years ago when anytime you you had

992
00:55:42,830 --> 00:55:46,549
somebody report a problem with some TCP

993
00:55:45,260 --> 00:55:47,930
related thing on Linux

994
00:55:46,550 --> 00:55:49,520
one of the first suggestions on a

995
00:55:47,930 --> 00:55:51,200
mailing list or on a message board post

996
00:55:49,520 --> 00:55:53,120
was oh did you try turning off TSO

997
00:55:51,200 --> 00:55:55,460
because it was sort of famously it was

998
00:55:53,120 --> 00:55:56,509
problematic for for some nicks or some

999
00:55:55,460 --> 00:56:01,160
kernels at some

1000
00:55:56,510 --> 00:56:02,480
and you know that became that would be

1001
00:56:01,160 --> 00:56:03,950
something that if you had a programmable

1002
00:56:02,480 --> 00:56:06,920
Nick and you knew what the problem was

1003
00:56:03,950 --> 00:56:09,950
because probably you wrote it you could

1004
00:56:06,920 --> 00:56:12,470
go fix it so additionally rolling out

1005
00:56:09,950 --> 00:56:15,109
new security fixes always a great idea

1006
00:56:12,470 --> 00:56:17,359
there's this notion right that that if

1007
00:56:15,109 --> 00:56:19,100
you if you run a large or small scale

1008
00:56:17,359 --> 00:56:20,900
data center there's there is going to be

1009
00:56:19,100 --> 00:56:23,118
some magic packet that's going to melt

1010
00:56:20,900 --> 00:56:25,250
your network and this would give you

1011
00:56:23,119 --> 00:56:28,250
that opportunity to snuff that out and

1012
00:56:25,250 --> 00:56:29,869
hardware before it gets too far so so

1013
00:56:28,250 --> 00:56:31,970
today in the programmable Nick world

1014
00:56:29,869 --> 00:56:34,220
there's really two to sort of main types

1015
00:56:31,970 --> 00:56:37,339
one is special purpose hardware or FPGA

1016
00:56:34,220 --> 00:56:39,020
and P use that Simon is referenced

1017
00:56:37,340 --> 00:56:41,300
before so this is something that we're

1018
00:56:39,020 --> 00:56:43,070
going to program very specific hardware

1019
00:56:41,300 --> 00:56:44,660
we're going to write code for and then

1020
00:56:43,070 --> 00:56:45,740
the other one is really a new class of

1021
00:56:44,660 --> 00:56:47,180
Nick's that have appeared in the last

1022
00:56:45,740 --> 00:56:49,609
couple years that really just contain a

1023
00:56:47,180 --> 00:56:53,660
general-purpose processor so this might

1024
00:56:49,609 --> 00:56:55,850
be an arm and x86 a mips maybe in the

1025
00:56:53,660 --> 00:56:57,859
future like risk 5 but really just

1026
00:56:55,850 --> 00:57:00,890
something-something general-purpose they

1027
00:56:57,859 --> 00:57:03,740
can run any code so and and I think

1028
00:57:00,890 --> 00:57:06,020
really well this might seem today like

1029
00:57:03,740 --> 00:57:08,660
something that isn't exactly what what

1030
00:57:06,020 --> 00:57:10,820
you might want sort of looked at some of

1031
00:57:08,660 --> 00:57:13,399
the forwarding plane realities slides

1032
00:57:10,820 --> 00:57:14,359
from the last IETF I think there's a

1033
00:57:13,400 --> 00:57:15,619
really interesting quote at the

1034
00:57:14,359 --> 00:57:17,270
conclusion at the end of that that

1035
00:57:15,619 --> 00:57:19,340
what's what's niche today can be broad

1036
00:57:17,270 --> 00:57:21,290
tomorrow and I think that's generally

1037
00:57:19,340 --> 00:57:23,359
speaking what we've seen across the

1038
00:57:21,290 --> 00:57:24,950
board in networking and then Nick's that

1039
00:57:23,359 --> 00:57:26,509
there'll be someone that'll roll out a

1040
00:57:24,950 --> 00:57:27,230
new feature and someone will think I

1041
00:57:26,510 --> 00:57:29,510
don't know

1042
00:57:27,230 --> 00:57:32,450
before long everybody's got it and

1043
00:57:29,510 --> 00:57:33,920
everybody wants it so so I think

1044
00:57:32,450 --> 00:57:36,470
programmability is going to be that next

1045
00:57:33,920 --> 00:57:38,150
that next piece so kind of build on the

1046
00:57:36,470 --> 00:57:40,669
common language that we had for our

1047
00:57:38,150 --> 00:57:42,140
pictures earlier hopefully this language

1048
00:57:40,670 --> 00:57:43,280
resonates with people otherwise that's a

1049
00:57:42,140 --> 00:57:47,359
bummer because we use it in the whole

1050
00:57:43,280 --> 00:57:49,580
deck so so we really do in this case

1051
00:57:47,359 --> 00:57:51,500
when you have an FPGA or an NP you the

1052
00:57:49,580 --> 00:57:54,859
control plane is still gonna stay in

1053
00:57:51,500 --> 00:57:56,300
your host kernel so it's going to do if

1054
00:57:54,859 --> 00:57:57,799
you're running a routing daemon or

1055
00:57:56,300 --> 00:58:00,710
something else the setting up flows all

1056
00:57:57,800 --> 00:58:04,490
that still runs there but now we're in a

1057
00:58:00,710 --> 00:58:05,990
case where this this offload data plane

1058
00:58:04,490 --> 00:58:09,109
is going to run down in the FPGA or the

1059
00:58:05,990 --> 00:58:09,759
NPU and in fact one do unique pieces

1060
00:58:09,109 --> 00:58:11,470
with this is

1061
00:58:09,760 --> 00:58:14,020
we'll be cases where a software data

1062
00:58:11,470 --> 00:58:15,790
path does not exist in the kernel for

1063
00:58:14,020 --> 00:58:17,380
whatever feature you're adding now

1064
00:58:15,790 --> 00:58:18,880
that's it's a little bit different from

1065
00:58:17,380 --> 00:58:21,580
what we do in the Linux community where

1066
00:58:18,880 --> 00:58:23,170
there's Hardware offload capabilities

1067
00:58:21,580 --> 00:58:24,370
that are there and your hardware there's

1068
00:58:23,170 --> 00:58:26,380
sort of an insistence that there's a

1069
00:58:24,370 --> 00:58:28,540
software fallback data path that exists

1070
00:58:26,380 --> 00:58:30,070
and within Linux that's been extremely

1071
00:58:28,540 --> 00:58:31,840
helpful and we're going to continue I

1072
00:58:30,070 --> 00:58:34,270
think to push that but this is a case

1073
00:58:31,840 --> 00:58:36,990
where that might not be the case you may

1074
00:58:34,270 --> 00:58:38,950
just have a data path that's completely

1075
00:58:36,990 --> 00:58:42,129
done in the kernel with no software

1076
00:58:38,950 --> 00:58:44,319
fallback at your own risk I guess and

1077
00:58:42,130 --> 00:58:46,120
and in fact that data plane could be

1078
00:58:44,320 --> 00:58:49,150
expressed in a variety of languages so

1079
00:58:46,120 --> 00:58:51,490
you know maybe p4u vpf and PL or maybe

1080
00:58:49,150 --> 00:58:55,330
just a native instruction set for for

1081
00:58:51,490 --> 00:58:57,310
that that NP you as Simon talked about

1082
00:58:55,330 --> 00:58:59,440
many MP use have has something that

1083
00:58:57,310 --> 00:59:02,049
maybe have special instructions for

1084
00:58:59,440 --> 00:59:03,520
performing operations and the key that

1085
00:59:02,050 --> 00:59:06,700
we talked about too is that this is this

1086
00:59:03,520 --> 00:59:09,490
is dynamically program so in this you

1087
00:59:06,700 --> 00:59:12,700
know this is def packet that could exist

1088
00:59:09,490 --> 00:59:14,290
you can roll out new code quickly or if

1089
00:59:12,700 --> 00:59:15,580
you're rapidly developing a new protocol

1090
00:59:14,290 --> 00:59:18,190
and you start to say you know what maybe

1091
00:59:15,580 --> 00:59:20,920
I don't need 350 bytes of header to

1092
00:59:18,190 --> 00:59:22,630
describe this this new protocol maybe

1093
00:59:20,920 --> 00:59:23,380
will make it a little shorter like 324

1094
00:59:22,630 --> 00:59:26,230
or something

1095
00:59:23,380 --> 00:59:28,510
who knows so they ought to keep the

1096
00:59:26,230 --> 00:59:30,250
other the other piece is a really a

1097
00:59:28,510 --> 00:59:32,590
general-purpose processor and so this is

1098
00:59:30,250 --> 00:59:33,760
a little bit of a unique situation a

1099
00:59:32,590 --> 00:59:35,850
little different than we've had in the

1100
00:59:33,760 --> 00:59:38,620
past but it's becoming pretty popular

1101
00:59:35,850 --> 00:59:41,380
and so this is a case where we're moving

1102
00:59:38,620 --> 00:59:43,660
the entire host networking stack down on

1103
00:59:41,380 --> 00:59:45,250
to the NIC so and yes I said that right

1104
00:59:43,660 --> 00:59:48,040
so what that actually means is your NIC

1105
00:59:45,250 --> 00:59:51,310
could actually run another copy of an

1106
00:59:48,040 --> 00:59:52,660
operating system some people shudder at

1107
00:59:51,310 --> 00:59:56,650
this thought because maybe it sounds a

1108
00:59:52,660 --> 00:59:57,970
little more complex but the fact is if

1109
00:59:56,650 --> 00:59:59,590
you have this already implemented

1110
00:59:57,970 --> 01:00:01,060
software on your server you could

1111
00:59:59,590 --> 01:00:02,560
actually move it down to your NIC and

1112
01:00:01,060 --> 01:00:05,500
free up those server cores from doing

1113
01:00:02,560 --> 01:00:07,570
that work so in this case the data plane

1114
01:00:05,500 --> 01:00:10,180
offload is down on this general-purpose

1115
01:00:07,570 --> 01:00:12,220
processor as I mentioned and also the

1116
01:00:10,180 --> 01:00:13,629
control plane so now what if your

1117
01:00:12,220 --> 01:00:15,819
routing daemon was running on the neck

1118
01:00:13,630 --> 01:00:18,760
or what if your whatever was receiving

1119
01:00:15,820 --> 01:00:20,170
you know open flow messages from a

1120
01:00:18,760 --> 01:00:22,810
controller was running completely on the

1121
01:00:20,170 --> 01:00:23,589
NIC so now you've you found yourself

1122
01:00:22,810 --> 01:00:27,369
consuming

1123
01:00:23,589 --> 01:00:29,920
host resources server host not Nick host

1124
01:00:27,369 --> 01:00:31,450
you know sort of different CPU complexes

1125
01:00:29,920 --> 01:00:33,160
there are not sort of actually different

1126
01:00:31,450 --> 01:00:34,899
CPU complexes so now you're not

1127
01:00:33,160 --> 01:00:36,788
consuming any of the resources of your

1128
01:00:34,900 --> 01:00:38,890
server and you can free them up for

1129
01:00:36,789 --> 01:00:43,349
doing useful things whatever those may

1130
01:00:38,890 --> 01:00:45,759
be so this control plane offload is also

1131
01:00:43,349 --> 01:00:47,200
really nice if you have what some are

1132
01:00:45,759 --> 01:00:49,359
calling now a bare-metal deployment

1133
01:00:47,200 --> 01:00:50,828
where you're really you're setting up

1134
01:00:49,359 --> 01:00:51,999
servers you don't know exactly what

1135
01:00:50,829 --> 01:00:53,979
they're going to be used for but you're

1136
01:00:51,999 --> 01:00:55,149
responsible for networking you can feel

1137
01:00:53,979 --> 01:00:57,669
pretty confident that there's a good

1138
01:00:55,150 --> 01:00:58,960
chance that your server administrators

1139
01:00:57,670 --> 01:01:02,049
are not going to ruin whatever network

1140
01:00:58,960 --> 01:01:04,509
setup you want them to have pretty

1141
01:01:02,049 --> 01:01:05,859
confident also in the multi tenant

1142
01:01:04,509 --> 01:01:08,710
deployments this would be really good

1143
01:01:05,859 --> 01:01:10,509
you can can make sure that that no one

1144
01:01:08,710 --> 01:01:13,180
no one person has a chance to destroy

1145
01:01:10,509 --> 01:01:15,519
too much and it really it brings a lot

1146
01:01:13,180 --> 01:01:16,989
of the server networking administration

1147
01:01:15,519 --> 01:01:19,359
back into the purview of the network

1148
01:01:16,989 --> 01:01:20,920
admin I think that's a sort of a

1149
01:01:19,359 --> 01:01:24,069
constant struggle between those two

1150
01:01:20,920 --> 01:01:26,170
groups somewhat understandably so this

1151
01:01:24,069 --> 01:01:27,729
this gives networking networking

1152
01:01:26,170 --> 01:01:30,579
tentacles to get a little bit further

1153
01:01:27,729 --> 01:01:32,169
into the server if you will so kind of

1154
01:01:30,579 --> 01:01:33,940
in the same vein here's that picture

1155
01:01:32,170 --> 01:01:36,339
again so now we've got this

1156
01:01:33,940 --> 01:01:40,660
general-purpose processor running down

1157
01:01:36,339 --> 01:01:43,630
on our programmable NIC running whatever

1158
01:01:40,660 --> 01:01:45,519
OS you want and then this forwarding

1159
01:01:43,630 --> 01:01:47,109
functionality again moved completely

1160
01:01:45,519 --> 01:01:48,669
away from the server course down to the

1161
01:01:47,109 --> 01:01:50,589
NIC so this this would mean that

1162
01:01:48,670 --> 01:01:51,819
obviously if you have applications that

1163
01:01:50,589 --> 01:01:54,369
are running in your server they're still

1164
01:01:51,819 --> 01:01:56,650
going to get the data that they need but

1165
01:01:54,369 --> 01:01:59,190
you're not spending your time just

1166
01:01:56,650 --> 01:02:01,719
needlessly moving packets between

1167
01:01:59,190 --> 01:02:05,799
between different applications whatever

1168
01:02:01,719 --> 01:02:08,140
those look like and and the reality to

1169
01:02:05,799 --> 01:02:10,029
here and it doesn't get any more

1170
01:02:08,140 --> 01:02:12,339
recursive than this I promise is that

1171
01:02:10,029 --> 01:02:14,469
the programmable mix also have offload

1172
01:02:12,339 --> 01:02:17,859
capable devices these things are all

1173
01:02:14,469 --> 01:02:19,299
being put on the same die so you all

1174
01:02:17,859 --> 01:02:20,680
have a control and a data plane and a

1175
01:02:19,299 --> 01:02:22,690
fixed function device that's all

1176
01:02:20,680 --> 01:02:24,729
embedded down but like I said I promised

1177
01:02:22,690 --> 01:02:26,079
that that offloaded data path on the

1178
01:02:24,729 --> 01:02:27,218
fixed function device doesn't also

1179
01:02:26,079 --> 01:02:30,930
contain another general-purpose

1180
01:02:27,219 --> 01:02:34,599
processor and another one on down it's

1181
01:02:30,930 --> 01:02:36,759
just as simple I appreciate that it's

1182
01:02:34,599 --> 01:02:37,580
just just the simple the simple fact is

1183
01:02:36,759 --> 01:02:39,500
we're building

1184
01:02:37,580 --> 01:02:42,860
these chips that are pretty large and

1185
01:02:39,500 --> 01:02:44,840
have both the general purpose you know

1186
01:02:42,860 --> 01:02:47,150
maybe you know maybe armored MIPS cores

1187
01:02:44,840 --> 01:02:49,990
on the side with with a fixed function

1188
01:02:47,150 --> 01:02:52,190
ASIC there are also people building

1189
01:02:49,990 --> 01:02:56,629
building mix that in addition to that

1190
01:02:52,190 --> 01:02:59,300
have FPGA is RMP use as well so so I

1191
01:02:56,630 --> 01:03:02,410
think this is kind of a new world in a

1192
01:02:59,300 --> 01:03:06,770
lot of ways I think there's not a lot of

1193
01:03:02,410 --> 01:03:08,810
not a large number of users that are

1194
01:03:06,770 --> 01:03:10,910
doing this but I think this is a strong

1195
01:03:08,810 --> 01:03:12,259
case especially in a place like this

1196
01:03:10,910 --> 01:03:14,120
where we're seeing rapid protocol

1197
01:03:12,260 --> 01:03:16,850
development where the programmable NIC

1198
01:03:14,120 --> 01:03:20,920
is an extremely powerful option and an

1199
01:03:16,850 --> 01:03:24,440
extremely interesting going forward so I

1200
01:03:20,920 --> 01:03:26,510
think really the way that we want to

1201
01:03:24,440 --> 01:03:27,800
summarize this is that we think about

1202
01:03:26,510 --> 01:03:29,300
the networking trends going forward

1203
01:03:27,800 --> 01:03:31,700
there's an insatiable need for more

1204
01:03:29,300 --> 01:03:33,230
bandwidth and lower latency I think the

1205
01:03:31,700 --> 01:03:36,560
devices that we carry around in our

1206
01:03:33,230 --> 01:03:38,360
pockets every day that that help us

1207
01:03:36,560 --> 01:03:40,730
consume more and more data and not only

1208
01:03:38,360 --> 01:03:43,520
in the air but where the actual wires

1209
01:03:40,730 --> 01:03:45,790
are in the data centers there's just

1210
01:03:43,520 --> 01:03:47,810
people want want more all the time

1211
01:03:45,790 --> 01:03:49,730
I'm amazed how many people are walking

1212
01:03:47,810 --> 01:03:53,509
around doing video calls or driving

1213
01:03:49,730 --> 01:03:56,030
doing video calls I wish that was a joke

1214
01:03:53,510 --> 01:04:00,710
but it's not and I wish it was

1215
01:03:56,030 --> 01:04:02,480
passengers but anyway and I think

1216
01:04:00,710 --> 01:04:03,610
there's we're seeing more and more to

1217
01:04:02,480 --> 01:04:07,820
that there's an interest in deploying

1218
01:04:03,610 --> 01:04:10,790
new protocols we regularly hear requests

1219
01:04:07,820 --> 01:04:12,380
for things that you know we wonder how

1220
01:04:10,790 --> 01:04:14,330
we can make the hardware that is

1221
01:04:12,380 --> 01:04:15,860
fixed-function support how long it will

1222
01:04:14,330 --> 01:04:17,390
take to maybe support that so this this

1223
01:04:15,860 --> 01:04:20,690
gives a new option for people who want

1224
01:04:17,390 --> 01:04:22,580
to want to do this things quickly and I

1225
01:04:20,690 --> 01:04:25,040
think that that the Knicks are going to

1226
01:04:22,580 --> 01:04:27,350
work together with post operating

1227
01:04:25,040 --> 01:04:29,720
systems to make these things happen we

1228
01:04:27,350 --> 01:04:31,880
don't see offloads going away we see

1229
01:04:29,720 --> 01:04:35,959
offload it's becoming more powerful and

1230
01:04:31,880 --> 01:04:38,750
becoming more flexible and and continue

1231
01:04:35,960 --> 01:04:40,940
to be important so and I also think that

1232
01:04:38,750 --> 01:04:43,760
the programmability and this flexibility

1233
01:04:40,940 --> 01:04:45,410
will really spur innovation that that we

1234
01:04:43,760 --> 01:04:47,570
haven't thought of before I think that's

1235
01:04:45,410 --> 01:04:49,520
the magical part about about some of

1236
01:04:47,570 --> 01:04:51,470
these devices that that are completely

1237
01:04:49,520 --> 01:04:53,690
or not completely bare

1238
01:04:51,470 --> 01:04:55,098
the flexible is that is you get the

1239
01:04:53,690 --> 01:04:57,560
chance to do something that you would

1240
01:04:55,099 --> 01:05:00,080
have never thought possible a few years

1241
01:04:57,560 --> 01:05:02,630
ago and and who knows exactly what will

1242
01:05:00,080 --> 01:05:06,650
come next so I think that's to me really

1243
01:05:02,630 --> 01:05:13,490
exciting I think that's it thank you

1244
01:05:06,650 --> 01:05:15,170
thanks let's give them a hand okay we

1245
01:05:13,490 --> 01:05:16,879
don't have much time left so I will open

1246
01:05:15,170 --> 01:05:24,770
the mics now for anybody who wants to

1247
01:05:16,880 --> 01:05:28,119
ask it's a discussion please use a mic

1248
01:05:24,770 --> 01:05:32,380
state your name and it's being recorded

1249
01:05:28,119 --> 01:05:34,640
and who hasn't signed the blue sheets

1250
01:05:32,380 --> 01:05:43,550
everybody if you haven't signed the blue

1251
01:05:34,640 --> 01:05:46,160
sheets please sign david black first of

1252
01:05:43,550 --> 01:05:48,680
all many thanks for consistently using

1253
01:05:46,160 --> 01:05:51,200
the Linux example throughout the talks

1254
01:05:48,680 --> 01:05:52,609
everybody's on the same page you may not

1255
01:05:51,200 --> 01:05:53,419
be able to answer this question to ask

1256
01:05:52,609 --> 01:05:56,630
it anyway

1257
01:05:53,420 --> 01:05:59,210
can you say anything about significant

1258
01:05:56,630 --> 01:06:07,640
differences in other important operating

1259
01:05:59,210 --> 01:06:11,180
system environments I'm being told to

1260
01:06:07,640 --> 01:06:14,480
sit down here and share the - everyone

1261
01:06:11,180 --> 01:06:16,098
wants to answer this one so I think the

1262
01:06:14,480 --> 01:06:17,810
question was about whether or not we see

1263
01:06:16,099 --> 01:06:21,200
consistency across other operating

1264
01:06:17,810 --> 01:06:24,440
systems is that right the question in

1265
01:06:21,200 --> 01:06:27,049
particular was case anything about where

1266
01:06:24,440 --> 01:06:30,290
how you described things work in Linux

1267
01:06:27,050 --> 01:06:36,080
differ significantly in non Linux

1268
01:06:30,290 --> 01:06:39,800
operating systems I honestly don't have

1269
01:06:36,080 --> 01:06:41,000
a ton of visibility in that so it

1270
01:06:39,800 --> 01:06:44,480
answered the question I would point out

1271
01:06:41,000 --> 01:06:47,690
that some of the earlier work actually

1272
01:06:44,480 --> 01:06:51,440
came out of windows for instance RSS was

1273
01:06:47,690 --> 01:06:53,810
literally in Bennet I think it was

1274
01:06:51,440 --> 01:06:56,960
endeth described that and I believe they

1275
01:06:53,810 --> 01:07:00,670
had the early checksum offload and I

1276
01:06:56,960 --> 01:07:03,170
think what happened is as Linux became

1277
01:07:00,670 --> 01:07:04,670
kind of more popular and open-source we

1278
01:07:03,170 --> 01:07:05,180
had a lot of developers that are working

1279
01:07:04,670 --> 01:07:08,299
on that

1280
01:07:05,180 --> 01:07:10,669
and at some point the knick vendors as

1281
01:07:08,299 --> 01:07:13,640
the volumes go up they start to pay

1282
01:07:10,670 --> 01:07:18,319
attention that being said we do know

1283
01:07:13,640 --> 01:07:20,569
that FreeBSD may use some of these I

1284
01:07:18,319 --> 01:07:22,849
know that some of the work that we did

1285
01:07:20,569 --> 01:07:25,430
and package during was being applied and

1286
01:07:22,849 --> 01:07:26,270
that's a good thing so like I said in my

1287
01:07:25,430 --> 01:07:29,210
talk

1288
01:07:26,270 --> 01:07:32,180
we do want common api is across os's but

1289
01:07:29,210 --> 01:07:33,349
most importantly there is nothing I

1290
01:07:32,180 --> 01:07:34,940
don't think there's anything we're doing

1291
01:07:33,349 --> 01:07:38,299
in the Nick that would be specific to

1292
01:07:34,940 --> 01:07:39,740
Linux or any particular OS in fact I

1293
01:07:38,299 --> 01:07:41,720
think some of these techniques would

1294
01:07:39,740 --> 01:07:44,509
even be applied in something like DP DK

1295
01:07:41,720 --> 01:07:47,450
or kernel bypass so again we're just

1296
01:07:44,510 --> 01:07:50,299
using Linux of the reference you know

1297
01:07:47,450 --> 01:07:54,470
obviously major vendor support linux

1298
01:07:50,299 --> 01:07:56,288
freebsd windows and DP DK and the more

1299
01:07:54,470 --> 01:07:59,118
features we can have common across those

1300
01:07:56,289 --> 01:08:01,430
the better obviously and it's good for

1301
01:07:59,119 --> 01:08:02,960
us if it's the features are common

1302
01:08:01,430 --> 01:08:05,319
because then we have common support and

1303
01:08:02,960 --> 01:08:05,319
things like that

1304
01:08:09,069 --> 01:08:16,698
okay but let's go independent

1305
01:08:12,440 --> 01:08:18,440
in this sense you've talked a lot about

1306
01:08:16,698 --> 01:08:21,198
different features on different cards in

1307
01:08:18,439 --> 01:08:23,689
the list of it when you're writing the

1308
01:08:21,198 --> 01:08:25,339
code you've got to know what the car can

1309
01:08:23,689 --> 01:08:27,080
do that's on the machine

1310
01:08:25,339 --> 01:08:29,899
the your code happens to be running on

1311
01:08:27,080 --> 01:08:32,988
so I don't I don't want you to sort of

1312
01:08:29,899 --> 01:08:35,719
explain all about you guys now but it's

1313
01:08:32,988 --> 01:08:37,698
really the questions more about what up

1314
01:08:35,719 --> 01:08:39,520
from what I've seen is going on

1315
01:08:37,698 --> 01:08:42,948
essentially it's someone writes a page

1316
01:08:39,520 --> 01:08:47,239
to say you know what's the consensus on

1317
01:08:42,948 --> 01:08:49,818
what people do say for offload and does

1318
01:08:47,238 --> 01:08:52,669
that need standardization is it working

1319
01:08:49,819 --> 01:08:54,650
at the moment just having it done ad hoc

1320
01:08:52,670 --> 01:08:56,719
would it screw it up if it was

1321
01:08:54,649 --> 01:08:59,389
standardized I'm just thinking it seems

1322
01:08:56,719 --> 01:09:03,080
to be all very ad hoc at the moment how

1323
01:08:59,390 --> 01:09:06,199
the description of what's the hardware

1324
01:09:03,080 --> 01:09:10,818
is capable of so that you can write a

1325
01:09:06,198 --> 01:09:15,290
code to know what to use yeah so I think

1326
01:09:10,819 --> 01:09:16,790
I don't know that it might feel a little

1327
01:09:15,290 --> 01:09:19,040
bit ad hoc I feel like there's a fair

1328
01:09:16,790 --> 01:09:21,470
amount of communication within

1329
01:09:19,040 --> 01:09:22,549
the kernel development community - as if

1330
01:09:21,470 --> 01:09:24,830
to communicate up to the upper layer

1331
01:09:22,549 --> 01:09:26,569
stacks what's available we have lots of

1332
01:09:24,830 --> 01:09:30,229
feature flags and feature capabilities

1333
01:09:26,569 --> 01:09:32,750
that are enumerated but and and I think

1334
01:09:30,229 --> 01:09:33,919
part of what's done at some of the

1335
01:09:32,750 --> 01:09:36,560
different conferences throughout the

1336
01:09:33,920 --> 01:09:38,989
year whether it be net dev or Linux

1337
01:09:36,560 --> 01:09:40,580
plumbers or others is to help get people

1338
01:09:38,988 --> 01:09:42,469
together and come up with some of those

1339
01:09:40,580 --> 01:09:44,899
and I think as we've started with basic

1340
01:09:42,470 --> 01:09:48,109
offloads whether it was checksum or TSO

1341
01:09:44,899 --> 01:09:52,120
or things like that and we've gotten

1342
01:09:48,109 --> 01:09:55,790
beyond doing things like flow offload

1343
01:09:52,120 --> 01:09:59,030
that's been negotiated so to speak

1344
01:09:55,790 --> 01:10:00,320
fairly well it is it does feel a little

1345
01:09:59,030 --> 01:10:01,849
bit ad-hoc though especially I think

1346
01:10:00,320 --> 01:10:02,679
from the outside because what would

1347
01:10:01,850 --> 01:10:05,210
probably burn

1348
01:10:02,680 --> 01:10:07,040
outsides the wrong word to use it as an

1349
01:10:05,210 --> 01:10:09,140
observer it probably might feel ad-hoc

1350
01:10:07,040 --> 01:10:11,000
because you just see patches show up and

1351
01:10:09,140 --> 01:10:12,620
support exists and usually what happens

1352
01:10:11,000 --> 01:10:14,510
is one vendor will come up with it

1353
01:10:12,620 --> 01:10:15,769
another will say yeah me too and then

1354
01:10:14,510 --> 01:10:18,290
they'll they'll do it and maybe enhance

1355
01:10:15,770 --> 01:10:21,560
it a little bit more but I think that's

1356
01:10:18,290 --> 01:10:24,019
a the goal is to have you know write the

1357
01:10:21,560 --> 01:10:26,210
code once that's your application and

1358
01:10:24,020 --> 01:10:27,680
have it run across multiple vendors and

1359
01:10:26,210 --> 01:10:30,350
I think we do a really good job of that

1360
01:10:27,680 --> 01:10:33,020
right now okay so basically your answer

1361
01:10:30,350 --> 01:10:34,790
is process isn't broken it just looks

1362
01:10:33,020 --> 01:10:43,850
like it is from the outside that's

1363
01:10:34,790 --> 01:10:46,070
probably fair yeah I had a clarification

1364
01:10:43,850 --> 01:10:48,489
question for Tom I think did you mention

1365
01:10:46,070 --> 01:10:50,540
that I hear correctly that you said that

1366
01:10:48,489 --> 01:10:52,879
implementing any sort of receive uploads

1367
01:10:50,540 --> 01:10:57,800
requires checksum upload and if so why

1368
01:10:52,880 --> 01:11:03,250
or did I miss misinterpret what she said

1369
01:10:57,800 --> 01:11:06,380
so implementation for checksum offload

1370
01:11:03,250 --> 01:11:09,680
of course I think you said and I may be

1371
01:11:06,380 --> 01:11:12,200
mistaken that implementing anything like

1372
01:11:09,680 --> 01:11:13,940
jro or LRO requires checksum upload

1373
01:11:12,200 --> 01:11:16,610
otherwise that doesn't work and just

1374
01:11:13,940 --> 01:11:21,739
wanted to know why that is cuz I don't

1375
01:11:16,610 --> 01:11:25,040
know well so if you think about let's

1376
01:11:21,739 --> 01:11:27,139
look at large segmentation offload so in

1377
01:11:25,040 --> 01:11:31,830
the NIC this is splitting a packet up

1378
01:11:27,140 --> 01:11:35,130
into individual TCP segments each TCP

1379
01:11:31,830 --> 01:11:38,220
header has its own checksum so I need to

1380
01:11:35,130 --> 01:11:40,080
actually after I do the segmentation

1381
01:11:38,220 --> 01:11:42,660
then I need to set the checksum it has

1382
01:11:40,080 --> 01:11:45,510
to be perfect and this is actually one

1383
01:11:42,660 --> 01:11:48,090
of the trickier things with something

1384
01:11:45,510 --> 01:11:50,160
like segmentation offload the fewer

1385
01:11:48,090 --> 01:11:52,710
things I have to do per packet the

1386
01:11:50,160 --> 01:11:56,340
better if it's the case where I could

1387
01:11:52,710 --> 01:11:58,530
just copy all of the headers to each

1388
01:11:56,340 --> 01:12:02,220
segment that's a lot easier but each

1389
01:11:58,530 --> 01:12:04,190
time we have to consider like IP IDs

1390
01:12:02,220 --> 01:12:07,170
another good example in the IP header

1391
01:12:04,190 --> 01:12:10,049
but packet lengths are always

1392
01:12:07,170 --> 01:12:12,330
interesting and check sums the hardest

1393
01:12:10,050 --> 01:12:15,060
one so anytime I have to set something

1394
01:12:12,330 --> 01:12:17,940
that is unique for that packet I have to

1395
01:12:15,060 --> 01:12:19,890
do that in the nick and checksum offload

1396
01:12:17,940 --> 01:12:21,960
is definitely one of those so this is a

1397
01:12:19,890 --> 01:12:23,850
case where we kind of lose the ability

1398
01:12:21,960 --> 01:12:26,820
and make it completely generic though

1399
01:12:23,850 --> 01:12:31,410
there are other other avenues but at

1400
01:12:26,820 --> 01:12:33,690
some level we have to have the NIC have

1401
01:12:31,410 --> 01:12:35,849
a way to understand how to how to dice a

1402
01:12:33,690 --> 01:12:37,320
packet and for receive you have to do it

1403
01:12:35,850 --> 01:12:40,290
because you have to check the individual

1404
01:12:37,320 --> 01:12:42,299
check sums otherwise you you might end

1405
01:12:40,290 --> 01:12:45,750
up returning a corrupt bigger packet to

1406
01:12:42,300 --> 01:12:47,580
the stack and in terms of capabilities

1407
01:12:45,750 --> 01:12:49,230
you know for receive you also need

1408
01:12:47,580 --> 01:12:53,130
checks on the floater to receive upload

1409
01:12:49,230 --> 01:12:57,299
yeah okay yeah the other question I had

1410
01:12:53,130 --> 01:12:58,260
was do is there somewhere I mean it so

1411
01:12:57,300 --> 01:12:59,880
the earlier questions that have

1412
01:12:58,260 --> 01:13:01,620
essentially said there's a cabal of of

1413
01:12:59,880 --> 01:13:03,540
you know 10 people in the world who

1414
01:13:01,620 --> 01:13:06,870
actually know how to do this is there

1415
01:13:03,540 --> 01:13:09,060
any sort of documentation where we can

1416
01:13:06,870 --> 01:13:12,480
point you know vendors to say hey please

1417
01:13:09,060 --> 01:13:15,930
implement checksum upload and here's how

1418
01:13:12,480 --> 01:13:19,379
to do it because there exist cards that

1419
01:13:15,930 --> 01:13:22,710
don't do it today not you know PCIe

1420
01:13:19,380 --> 01:13:26,220
cards but I think it goes back to kind

1421
01:13:22,710 --> 01:13:30,570
of the ad hoc nature of it

1422
01:13:26,220 --> 01:13:33,090
so that's a no then we I mean do you

1423
01:13:30,570 --> 01:13:34,980
want it to be super formal or informal I

1424
01:13:33,090 --> 01:13:36,540
think when we're shooting for

1425
01:13:34,980 --> 01:13:39,450
programmability that will actually solve

1426
01:13:36,540 --> 01:13:41,850
a lot of that such that you can add

1427
01:13:39,450 --> 01:13:45,630
different protocols on the fly with

1428
01:13:41,850 --> 01:13:48,340
different characteristics Thanks

1429
01:13:45,630 --> 01:13:50,530
we quickly take a question from Java

1430
01:13:48,340 --> 01:13:53,710
actually so there's a question for

1431
01:13:50,530 --> 01:13:55,389
Mikael a person about path MTU he's

1432
01:13:53,710 --> 01:13:59,440
asking when doing hardware offload

1433
01:13:55,390 --> 01:14:01,780
doesn't matter how much the doesn't

1434
01:13:59,440 --> 01:14:04,239
matter much to the host OS if there is

1435
01:14:01,780 --> 01:14:07,870
no higher MTU or muwaiya

1436
01:14:04,239 --> 01:14:32,949
and with gr o it seems it shouldn't

1437
01:14:07,870 --> 01:14:39,480
matter so the question was about path

1438
01:14:32,949 --> 01:14:43,030
MTU and I suppose segmentation offload

1439
01:14:39,480 --> 01:14:46,809
so it doesn't matter and in fact when

1440
01:14:43,030 --> 01:14:50,110
we're doing something like LSO TSO we

1441
01:14:46,810 --> 01:14:53,230
aren't just chucking up packets per them

1442
01:14:50,110 --> 01:14:56,799
to you we want to abide by the path m to

1443
01:14:53,230 --> 01:15:00,218
you so the way it works is the host jack

1444
01:14:56,800 --> 01:15:02,980
actually tells what the size is of the

1445
01:15:00,219 --> 01:15:06,430
packets to go out so we can abide by

1446
01:15:02,980 --> 01:15:08,440
path into you one of the interesting

1447
01:15:06,430 --> 01:15:13,090
things that we try to do is when we're

1448
01:15:08,440 --> 01:15:15,879
sending LS o try to keep the packets the

1449
01:15:13,090 --> 01:15:17,830
same size except for the last one that

1450
01:15:15,880 --> 01:15:21,280
simplifies the problem that we just

1451
01:15:17,830 --> 01:15:22,930
talked about with lorenzo where we have

1452
01:15:21,280 --> 01:15:25,420
to set the length for each packet

1453
01:15:22,930 --> 01:15:28,560
easiest way to do that is to kind of

1454
01:15:25,420 --> 01:15:33,100
infer what the lengths are so we tell

1455
01:15:28,560 --> 01:15:35,530
the NIC this is the the length the

1456
01:15:33,100 --> 01:15:37,239
maximum length make all the packets the

1457
01:15:35,530 --> 01:15:39,670
same size except for the last one which

1458
01:15:37,239 --> 01:15:42,730
could be short and then that way we can

1459
01:15:39,670 --> 01:15:47,410
accommodate path m to you so in terms of

1460
01:15:42,730 --> 01:15:49,239
larger m to use in the data center we're

1461
01:15:47,410 --> 01:15:51,370
seeing like 9 km to use with jumbo

1462
01:15:49,239 --> 01:15:56,888
frames that's actually a little less

1463
01:15:51,370 --> 01:15:58,809
pertinent to l ro and Ella and LSO

1464
01:15:56,889 --> 01:16:01,840
in that case we're actually just using

1465
01:15:58,810 --> 01:16:04,600
the native MTU to accomplish the larger

1466
01:16:01,840 --> 01:16:06,429
packet size so in some circumstances

1467
01:16:04,600 --> 01:16:07,929
that's a little less important if we

1468
01:16:06,429 --> 01:16:14,949
have already have a large unto you or

1469
01:16:07,929 --> 01:16:17,380
path MTU to begin with raw chicken on

1470
01:16:14,949 --> 01:16:19,210
flaps I was wondering about the crypto

1471
01:16:17,380 --> 01:16:21,040
offloading that was sort of in the

1472
01:16:19,210 --> 01:16:22,510
middle of the presentation that sounds

1473
01:16:21,040 --> 01:16:24,730
very interesting but on what I'm

1474
01:16:22,510 --> 01:16:27,310
wondering about is to what extent does

1475
01:16:24,730 --> 01:16:28,928
that sort of repeat the risks of all of

1476
01:16:27,310 --> 01:16:31,000
these vulnerabilities such as the

1477
01:16:28,929 --> 01:16:33,400
padding Oracle's and all of that and

1478
01:16:31,000 --> 01:16:35,650
repeat that in the NIC implementations

1479
01:16:33,400 --> 01:16:37,570
is that is there any information about

1480
01:16:35,650 --> 01:16:39,690
that these are their experiences for

1481
01:16:37,570 --> 01:16:42,130
that all of the stuff that got solved in

1482
01:16:39,690 --> 01:16:44,489
crypto stacks that are just on normal

1483
01:16:42,130 --> 01:16:44,489
CPU

1484
01:16:49,630 --> 01:16:54,950
was a question of portability and the

1485
01:16:52,280 --> 01:16:56,269
neck now the question is I mean there

1486
01:16:54,950 --> 01:16:58,160
are all these vulnerabilities if you do

1487
01:16:56,270 --> 01:17:01,480
crypto implementation a climbing attacks

1488
01:16:58,160 --> 01:17:03,830
things like writing Oracle's specific to

1489
01:17:01,480 --> 01:17:05,900
symmetric implementations to what extent

1490
01:17:03,830 --> 01:17:08,780
are these what is the risk of these get

1491
01:17:05,900 --> 01:17:10,730
repeated in the NIC implementations and

1492
01:17:08,780 --> 01:17:12,519
if they are a your NIC how do you fix

1493
01:17:10,730 --> 01:17:15,169
that

1494
01:17:12,520 --> 01:17:17,990
yeah so though as I understand the

1495
01:17:15,170 --> 01:17:20,500
question is that if we look at crypto

1496
01:17:17,990 --> 01:17:24,170
there's a wide variety of attack vectors

1497
01:17:20,500 --> 01:17:26,000
varying complexity and any individual

1498
01:17:24,170 --> 01:17:29,000
implementation might be suffering from

1499
01:17:26,000 --> 01:17:30,560
any number of these so if we push adding

1500
01:17:29,000 --> 01:17:34,100
crypto implementation down to the

1501
01:17:30,560 --> 01:17:36,680
hardware what is what kind of problems

1502
01:17:34,100 --> 01:17:37,820
might we see there in this area yeah so

1503
01:17:36,680 --> 01:17:40,340
I think that that's a good point and

1504
01:17:37,820 --> 01:17:43,280
certainly we can't pretend that there is

1505
01:17:40,340 --> 01:17:46,910
not going to be any problems I think

1506
01:17:43,280 --> 01:17:49,040
that as the complexity of what you're as

1507
01:17:46,910 --> 01:17:50,840
sorry as the complexity of what's being

1508
01:17:49,040 --> 01:17:52,960
offered it increases so for example if

1509
01:17:50,840 --> 01:17:56,990
we use move from a crypto on the offload

1510
01:17:52,960 --> 01:17:58,460
towards a full offload then the surface

1511
01:17:56,990 --> 01:18:02,269
for these kind of problems must surely

1512
01:17:58,460 --> 01:18:05,450
exist in my mind I'm not really sure

1513
01:18:02,270 --> 01:18:06,920
what the the best way to move forward on

1514
01:18:05,450 --> 01:18:09,050
this certainly that the vendors or the

1515
01:18:06,920 --> 01:18:12,230
surprise of the code or ideally open

1516
01:18:09,050 --> 01:18:14,420
code we'd need to move rapidly but

1517
01:18:12,230 --> 01:18:18,410
perhaps we also need to have some kind

1518
01:18:14,420 --> 01:18:20,150
of communications in the system so I

1519
01:18:18,410 --> 01:18:21,860
don't know if they would be relevant to

1520
01:18:20,150 --> 01:18:23,540
something like a timing attack but if it

1521
01:18:21,860 --> 01:18:25,400
was say a packet of death type of

1522
01:18:23,540 --> 01:18:28,970
attacks you may have a facility in the

1523
01:18:25,400 --> 01:18:30,830
system to allow the user to maybe using

1524
01:18:28,970 --> 01:18:34,280
some programmable component or something

1525
01:18:30,830 --> 01:18:36,050
to to mitigate against that but you I

1526
01:18:34,280 --> 01:18:38,900
mean would it be a matter of flashing

1527
01:18:36,050 --> 01:18:40,550
the the NIC and putting new software in

1528
01:18:38,900 --> 01:18:42,379
to fix something like that or is it you

1529
01:18:40,550 --> 01:18:45,050
can throw away your NIC if the don't

1530
01:18:42,380 --> 01:18:46,820
already - you serious enough I didn't

1531
01:18:45,050 --> 01:18:48,230
quite catch that but I guess the

1532
01:18:46,820 --> 01:18:49,730
question is what would be the mechanism

1533
01:18:48,230 --> 01:18:52,160
to fix it a bit

1534
01:18:49,730 --> 01:18:53,809
I think the it would depend on the

1535
01:18:52,160 --> 01:18:56,389
implementation I mean if it's a if it's

1536
01:18:53,810 --> 01:18:57,980
a kind of a fixed device and you're

1537
01:18:56,390 --> 01:19:00,110
receiving firmware from the vendor then

1538
01:18:57,980 --> 01:19:01,790
I suppose the main avenue other the

1539
01:19:00,110 --> 01:19:03,019
mitigations would be to get an updated

1540
01:19:01,790 --> 01:19:05,180
firmware

1541
01:19:03,020 --> 01:19:10,070
okay Nina but as we move to a more

1542
01:19:05,180 --> 01:19:11,480
programmable world that that the user

1543
01:19:10,070 --> 01:19:13,820
should have more flexibility to address

1544
01:19:11,480 --> 01:19:16,610
these problems themselves and so to

1545
01:19:13,820 --> 01:19:20,690
react more more fluidly to the situation

1546
01:19:16,610 --> 01:19:23,269
thank you so the next session starts at

1547
01:19:20,690 --> 01:19:25,929
10:00 so we could have like very very

1548
01:19:23,270 --> 01:19:28,910
quick question oh we take this offline

1549
01:19:25,930 --> 01:19:32,660
romance it's a simple question okay

1550
01:19:28,910 --> 01:19:34,760
quick what what we see exactly what we

1551
01:19:32,660 --> 01:19:37,370
see is that there is a trend towards

1552
01:19:34,760 --> 01:19:40,880
moving protocol implementations to the

1553
01:19:37,370 --> 01:19:43,239
application space for bios reasons and

1554
01:19:40,880 --> 01:19:46,430
we see that with quake in particular

1555
01:19:43,239 --> 01:19:49,009
what I have seen in your presentation is

1556
01:19:46,430 --> 01:19:52,910
that the interfaces that are shown are

1557
01:19:49,010 --> 01:19:56,960
food camera at the system level

1558
01:19:52,910 --> 01:19:59,349
he still walk to enable api's that can

1559
01:19:56,960 --> 01:20:06,680
be used directly from the applications

1560
01:19:59,350 --> 01:20:08,120
to use the offload functions I think

1561
01:20:06,680 --> 01:20:12,080
within the Linux kernel there is a

1562
01:20:08,120 --> 01:20:13,790
little bit of that there is actually

1563
01:20:12,080 --> 01:20:16,040
there was a presentation done last year

1564
01:20:13,790 --> 01:20:19,400
in Prague the net dev conference about

1565
01:20:16,040 --> 01:20:20,150
actually offloading quick and and what

1566
01:20:19,400 --> 01:20:21,530
could be done

1567
01:20:20,150 --> 01:20:23,719
what kind of kernel interfaces are

1568
01:20:21,530 --> 01:20:28,489
needed in order to to make that possible

1569
01:20:23,719 --> 01:20:30,710
so I think that I think the move to

1570
01:20:28,489 --> 01:20:33,950
protocol implementations like that in

1571
01:20:30,710 --> 01:20:39,320
user space is may be a result of

1572
01:20:33,950 --> 01:20:43,309
hardware and flexibility so you could

1573
01:20:39,320 --> 01:20:47,090
say that but the move to user space is

1574
01:20:43,310 --> 01:20:51,020
also the idea that it's developed

1575
01:20:47,090 --> 01:20:53,180
independently of what the kernel does so

1576
01:20:51,020 --> 01:20:54,469
so actually christian i have to ask you

1577
01:20:53,180 --> 01:20:56,390
to take it off then because there could

1578
01:20:54,469 --> 01:21:02,090
be a whole another session to talk about

1579
01:20:56,390 --> 01:21:04,070
that right that was a simple question I

1580
01:21:02,090 --> 01:21:06,560
think you're still here for the rest of

1581
01:21:04,070 --> 01:21:07,940
the day all three of you right so people

1582
01:21:06,560 --> 01:21:09,980
can approach you with more questions

1583
01:21:07,940 --> 01:21:11,599
thank you everybody I hope you enjoyed

1584
01:21:09,980 --> 01:21:16,068
it

1585
01:21:11,600 --> 01:21:16,069
[Applause]

1586
01:21:42,470 --> 01:21:46,510
[Laughter]

