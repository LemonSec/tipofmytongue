1
00:00:12,449 --> 00:00:19,000
so this is the session on DNS and

2
00:00:15,760 --> 00:00:22,770
security it's a fairly packed agenda we

3
00:00:19,000 --> 00:00:25,560
have an invited talk on dragonblood

4
00:00:22,770 --> 00:00:28,240
discussing some problems with WPA three

5
00:00:25,560 --> 00:00:30,130
that will hopefully be a very much

6
00:00:28,240 --> 00:00:31,959
interest to the security and Qatar a few

7
00:00:30,130 --> 00:00:35,280
people in the room and we have several

8
00:00:31,960 --> 00:00:39,030
talks on DNS both with the lens on

9
00:00:35,280 --> 00:00:41,440
privacy performance and security so

10
00:00:39,030 --> 00:00:44,639
without further ado like to introduce

11
00:00:41,440 --> 00:00:47,170
Matthew fennhoff he is a postdoc at NYU

12
00:00:44,639 --> 00:00:54,670
let's give him a round of applause as

13
00:00:47,170 --> 00:00:56,889
you're started so thank you for the

14
00:00:54,670 --> 00:01:00,459
introduction so I'm going to be talking

15
00:00:56,889 --> 00:01:03,879
about WPA three on specifically about

16
00:01:00,459 --> 00:01:06,430
the dragonfly handshake that is used now

17
00:01:03,879 --> 00:01:10,179
in this protocol on this dragonfly

18
00:01:06,430 --> 00:01:12,400
handshake it's also used in EEP PWD on

19
00:01:10,180 --> 00:01:17,380
this research was done in collaboration

20
00:01:12,400 --> 00:01:21,510
with al Ronan so to give a very quick

21
00:01:17,380 --> 00:01:24,399
background dragonfly is a password

22
00:01:21,510 --> 00:01:28,090
authenticated key exchange which means

23
00:01:24,400 --> 00:01:30,490
it provides mutual authentication it

24
00:01:28,090 --> 00:01:32,950
negotiates a session key which you can

25
00:01:30,490 --> 00:01:36,009
after the handshake used to encrypt

26
00:01:32,950 --> 00:01:37,750
actual communications and more

27
00:01:36,010 --> 00:01:40,090
importantly it is a handshake that

28
00:01:37,750 --> 00:01:44,850
provides forward secrecy

29
00:01:40,090 --> 00:01:49,390
on it defense against dictionary attacks

30
00:01:44,850 --> 00:01:51,850
now in the case of dragonfly there is no

31
00:01:49,390 --> 00:01:55,120
protection against a server compromise

32
00:01:51,850 --> 00:01:57,908
so concretely let's say in the case of

33
00:01:55,120 --> 00:02:00,040
WPA 3 if not occur would somehow get

34
00:01:57,909 --> 00:02:01,750
access to the access points the attacker

35
00:02:00,040 --> 00:02:04,900
would obtain enough information to

36
00:02:01,750 --> 00:02:06,820
easily authenticate as a clients while

37
00:02:04,900 --> 00:02:08,709
recently there are also some pics that

38
00:02:06,820 --> 00:02:11,530
have been introduced that also protect

39
00:02:08,709 --> 00:02:16,659
against server compromise by introducing

40
00:02:11,530 --> 00:02:18,160
some kind of salts so what we did is we

41
00:02:16,659 --> 00:02:23,649
analyzed the

42
00:02:18,160 --> 00:02:25,660
of dragonfly the give a bit to explain

43
00:02:23,650 --> 00:02:28,630
the things that we found I'm going to

44
00:02:25,660 --> 00:02:32,200
quickly introduce the most important

45
00:02:28,630 --> 00:02:33,880
concepts of the Zen shake and to do this

46
00:02:32,200 --> 00:02:36,579
I'm going to assume that we have a

47
00:02:33,880 --> 00:02:39,420
client here that wants to connect to the

48
00:02:36,580 --> 00:02:42,250
access point and the first thing that

49
00:02:39,420 --> 00:02:44,820
has to be done with the dragonfly

50
00:02:42,250 --> 00:02:47,590
handshake is that we have shared

51
00:02:44,820 --> 00:02:51,250
passwords which can just be an ordinary

52
00:02:47,590 --> 00:02:55,090
s key string on this is converted to

53
00:02:51,250 --> 00:02:57,790
either an elliptic curve point or in

54
00:02:55,090 --> 00:03:00,700
general into a so called group elements

55
00:02:57,790 --> 00:03:04,350
that we call be on this peak and then be

56
00:03:00,700 --> 00:03:07,660
used in the cryptographic calculations

57
00:03:04,350 --> 00:03:10,329
so the handshake consists of two main

58
00:03:07,660 --> 00:03:13,000
phases not going to go into detail

59
00:03:10,330 --> 00:03:15,400
basically we first have the commit phase

60
00:03:13,000 --> 00:03:18,850
where the actual session key is being

61
00:03:15,400 --> 00:03:21,760
negotiated and then there is at least in

62
00:03:18,850 --> 00:03:24,340
the case of Wi-Fi a confirmed phase that

63
00:03:21,760 --> 00:03:27,160
confirms that both parties indeed used

64
00:03:24,340 --> 00:03:31,630
the same password on that day negotiated

65
00:03:27,160 --> 00:03:34,859
the same session key um the important

66
00:03:31,630 --> 00:03:39,190
question here is how is this password

67
00:03:34,860 --> 00:03:41,680
converted to a group element and I'm

68
00:03:39,190 --> 00:03:44,680
going to start with a simple case here

69
00:03:41,680 --> 00:03:46,989
where we are using so-called mod p

70
00:03:44,680 --> 00:03:49,120
groups so these are not yet elliptic

71
00:03:46,989 --> 00:03:52,330
curves because the dragonfly handshake

72
00:03:49,120 --> 00:03:53,950
also supports multiple groups and here

73
00:03:52,330 --> 00:03:56,489
the algorithm is a bit simpler to

74
00:03:53,950 --> 00:04:02,730
explain and it also nicely illustrates

75
00:03:56,489 --> 00:04:07,480
the flaws of this methods so an

76
00:04:02,730 --> 00:04:09,910
intuitive and naive way to convert the

77
00:04:07,480 --> 00:04:13,988
password into a group element is to

78
00:04:09,910 --> 00:04:16,659
simply take the hash of the password in

79
00:04:13,989 --> 00:04:19,418
the case of Wi-Fi we also combine it

80
00:04:16,660 --> 00:04:21,430
with MAC addresses of the client on the

81
00:04:19,418 --> 00:04:25,210
server so in other words we include the

82
00:04:21,430 --> 00:04:28,300
identities of the peers we then take the

83
00:04:25,210 --> 00:04:31,359
output of the that hash value we perform

84
00:04:28,300 --> 00:04:31,900
some calculations to get a p-value that

85
00:04:31,360 --> 00:04:33,910
is a

86
00:04:31,900 --> 00:04:36,520
element of the cryptographic group we

87
00:04:33,910 --> 00:04:40,110
are using and then we do a quick sanity

88
00:04:36,520 --> 00:04:43,870
check to make sure that we have

89
00:04:40,110 --> 00:04:49,830
basically valid on secure element in

90
00:04:43,870 --> 00:04:49,830
practice this check always succeeds so

91
00:04:50,160 --> 00:04:55,210
this would be the intuitive way to

92
00:04:53,140 --> 00:04:58,030
convert the passwords into a group

93
00:04:55,210 --> 00:05:00,430
elements but there is one thing that is

94
00:04:58,030 --> 00:05:04,989
missing here the problem is that our

95
00:05:00,430 --> 00:05:07,210
hash output here our value it can be

96
00:05:04,990 --> 00:05:10,090
bigger than the prime of the group that

97
00:05:07,210 --> 00:05:14,289
is being used and in this case the

98
00:05:10,090 --> 00:05:19,169
calculations that we did here wouldn't

99
00:05:14,290 --> 00:05:21,670
be valid so how do we avoid this well

100
00:05:19,170 --> 00:05:23,950
the way that it was decided to do this

101
00:05:21,670 --> 00:05:26,140
for dragonfly was to simply include an

102
00:05:23,950 --> 00:05:29,590
if test here if the value is bigger than

103
00:05:26,140 --> 00:05:32,500
the prime then well we try again in

104
00:05:29,590 --> 00:05:35,409
other words we include a counter here

105
00:05:32,500 --> 00:05:37,240
we always incremented by one until we

106
00:05:35,410 --> 00:05:40,590
get a hash output that is bigger than

107
00:05:37,240 --> 00:05:46,990
the prime and then we can continue now

108
00:05:40,590 --> 00:05:49,510
of course this leaks time there's a side

109
00:05:46,990 --> 00:05:52,540
channel here and in fact an in mailing

110
00:05:49,510 --> 00:05:55,180
lists of the ietf on the CFR gee people

111
00:05:52,540 --> 00:05:58,200
warned about this they said this doesn't

112
00:05:55,180 --> 00:06:01,150
look good you should do something else

113
00:05:58,200 --> 00:06:03,460
but unfortunately for the case with the

114
00:06:01,150 --> 00:06:06,510
mod P groups this recommendation was

115
00:06:03,460 --> 00:06:10,210
never included in a specification on

116
00:06:06,510 --> 00:06:16,480
this of course leads to a trivial well a

117
00:06:10,210 --> 00:06:18,909
rather easy timing attack so one thing

118
00:06:16,480 --> 00:06:22,900
that makes this timing attack a bit more

119
00:06:18,910 --> 00:06:25,930
interesting here is that we can pretend

120
00:06:22,900 --> 00:06:28,659
to be clients a we can then measure how

121
00:06:25,930 --> 00:06:31,840
many iterations it took to find the

122
00:06:28,660 --> 00:06:34,630
password and because the identities of

123
00:06:31,840 --> 00:06:36,520
the clients are included here in the

124
00:06:34,630 --> 00:06:38,740
case of Wi-Fi we can then spoof another

125
00:06:36,520 --> 00:06:40,570
MAC address we can try to connect with

126
00:06:38,740 --> 00:06:42,580
the access points and then we can see

127
00:06:40,570 --> 00:06:45,310
how many iterations are then to accusing

128
00:06:42,580 --> 00:06:47,140
another MAC address then we can spoof

129
00:06:45,310 --> 00:06:49,840
and we can spoof a lot of clients on

130
00:06:47,140 --> 00:06:52,210
each time we can do a timing attack to

131
00:06:49,840 --> 00:06:55,799
measure how many iterations this

132
00:06:52,210 --> 00:07:00,390
algorithm took to find the group element

133
00:06:55,800 --> 00:07:03,340
so we tried to dis attack by setting up

134
00:07:00,390 --> 00:07:06,400
Wi-Fi access point so it wp8 three

135
00:07:03,340 --> 00:07:09,580
access points on a bit of older

136
00:07:06,400 --> 00:07:12,250
raspberry pi um the reason we pick the

137
00:07:09,580 --> 00:07:13,990
raspberry pi here is because it's CPU is

138
00:07:12,250 --> 00:07:18,430
actually similar to the one of a

139
00:07:13,990 --> 00:07:21,160
professional Wi-Fi access point and when

140
00:07:18,430 --> 00:07:23,680
we then the dist IMing measurements we

141
00:07:21,160 --> 00:07:29,040
found out that indeed these differences

142
00:07:23,680 --> 00:07:31,630
can be easily measured simply over Wi-Fi

143
00:07:29,040 --> 00:07:33,790
so you can see the example here where we

144
00:07:31,630 --> 00:07:36,880
have the blue full line that corresponds

145
00:07:33,790 --> 00:07:39,820
to the timing response if the algorithm

146
00:07:36,880 --> 00:07:41,440
only takes one iteration then we have

147
00:07:39,820 --> 00:07:45,580
the case where it takes two iterations

148
00:07:41,440 --> 00:07:49,510
three iterations and so on in practice

149
00:07:45,580 --> 00:07:53,020
we found that against our target if we

150
00:07:49,510 --> 00:07:55,210
make 75 timing measurements then we can

151
00:07:53,020 --> 00:07:57,909
accurately tell how many iterations it

152
00:07:55,210 --> 00:08:01,599
did so this is the case against WPA 3

153
00:07:57,910 --> 00:08:04,660
and if we would perform a similar attack

154
00:08:01,600 --> 00:08:08,170
against the EEP PWD protocol against

155
00:08:04,660 --> 00:08:10,870
so-called IWD clients which is a Wi-Fi

156
00:08:08,170 --> 00:08:12,940
client in linux this implementation is a

157
00:08:10,870 --> 00:08:14,770
bit slower on here if you make 30

158
00:08:12,940 --> 00:08:19,870
connection attempts you can accurately

159
00:08:14,770 --> 00:08:22,659
determine how many loops where needed so

160
00:08:19,870 --> 00:08:25,600
we now know that there's a timing leak

161
00:08:22,660 --> 00:08:28,150
we can derive the number of iterations

162
00:08:25,600 --> 00:08:30,130
that were being used but now the

163
00:08:28,150 --> 00:08:34,120
question is does this really leak

164
00:08:30,130 --> 00:08:36,549
important information in other words can

165
00:08:34,120 --> 00:08:40,720
we abuse this to for example perform a

166
00:08:36,549 --> 00:08:44,469
dictionary attack on the answer is yes

167
00:08:40,720 --> 00:08:47,740
we can let me take the following example

168
00:08:44,470 --> 00:08:50,800
we are say again attacking a WPA three

169
00:08:47,740 --> 00:08:53,890
access point we spoofed a client's MAC

170
00:08:50,800 --> 00:08:56,020
address of a and we measured that in

171
00:08:53,890 --> 00:08:58,750
this case the access point took two

172
00:08:56,020 --> 00:09:02,170
iterations to derive this

173
00:08:58,750 --> 00:09:05,050
elements well what we can then do is we

174
00:09:02,170 --> 00:09:07,030
can guess some passwords and our example

175
00:09:05,050 --> 00:09:11,130
here we're trying three different

176
00:09:07,030 --> 00:09:13,780
passwords and we can then simulate this

177
00:09:11,130 --> 00:09:15,610
method that converts the password to a

178
00:09:13,780 --> 00:09:19,209
group map element we convert we can

179
00:09:15,610 --> 00:09:21,010
simulate it offline on our own PC and we

180
00:09:19,210 --> 00:09:23,860
can notice here that for example for

181
00:09:21,010 --> 00:09:26,200
password one it only uses one iteration

182
00:09:23,860 --> 00:09:28,360
which doesn't correspond with our

183
00:09:26,200 --> 00:09:31,660
measurements so we can exclude the

184
00:09:28,360 --> 00:09:35,950
password based on that on the other two

185
00:09:31,660 --> 00:09:38,680
passwords they're still possible so then

186
00:09:35,950 --> 00:09:40,660
we can spoof know MAC address B we can

187
00:09:38,680 --> 00:09:43,359
again measure how many iteration it

188
00:09:40,660 --> 00:09:46,390
takes in a real world we can compare

189
00:09:43,360 --> 00:09:50,080
this to our simulated results and we can

190
00:09:46,390 --> 00:09:54,069
continue this way on excludes passwords

191
00:09:50,080 --> 00:09:55,450
that don't match our observation and we

192
00:09:54,070 --> 00:09:58,960
can continue doing this until we

193
00:09:55,450 --> 00:10:03,550
uniquely determines the the password

194
00:09:58,960 --> 00:10:06,270
that is being used so in this example

195
00:10:03,550 --> 00:10:10,390
its password three that matches our

196
00:10:06,270 --> 00:10:13,120
observations and in general if for

197
00:10:10,390 --> 00:10:16,589
example you want to test a dictionary of

198
00:10:13,120 --> 00:10:19,270
10 to the power 7 passwords which is

199
00:10:16,589 --> 00:10:24,400
roughly the same size of the rock you

200
00:10:19,270 --> 00:10:28,300
database passwords leak then we need to

201
00:10:24,400 --> 00:10:30,850
do this attack for about 17 MAC

202
00:10:28,300 --> 00:10:33,339
addresses on the practice we found that

203
00:10:30,850 --> 00:10:37,930
this is quite feasible in just a few

204
00:10:33,339 --> 00:10:40,750
hours of time the conclusion here is

205
00:10:37,930 --> 00:10:43,449
that the number of iterations that are

206
00:10:40,750 --> 00:10:45,820
executed they essentially form a

207
00:10:43,450 --> 00:10:48,850
signature of the password that's being

208
00:10:45,820 --> 00:10:55,030
used and we can use that to then do an

209
00:10:48,850 --> 00:10:57,850
offline would force attack so I now

210
00:10:55,030 --> 00:11:01,270
covered the case when we used mod P

211
00:10:57,850 --> 00:11:03,280
groups but dragonfly also supports

212
00:11:01,270 --> 00:11:08,199
elliptic curves so the question is are

213
00:11:03,280 --> 00:11:09,839
they affected as well on luckily if we

214
00:11:08,200 --> 00:11:12,360
at least use NIST

215
00:11:09,840 --> 00:11:15,029
then dragonfly is not affected because

216
00:11:12,360 --> 00:11:17,730
in that case they essentially listened

217
00:11:15,029 --> 00:11:20,640
to the warnings of the IDF on the CR 4G

218
00:11:17,730 --> 00:11:24,050
mailing list people and they included

219
00:11:20,640 --> 00:11:24,050
some defenses against it

220
00:11:24,320 --> 00:11:32,760
unfortunately dragonfly also supports

221
00:11:27,330 --> 00:11:35,100
rain walkers and interestingly initially

222
00:11:32,760 --> 00:11:38,310
we didn't look at his brain pool curse

223
00:11:35,100 --> 00:11:41,580
because dragonfly supports of a lot of

224
00:11:38,310 --> 00:11:45,150
parameters so it's hard to analyze every

225
00:11:41,580 --> 00:11:47,010
possible scenario but the reason we did

226
00:11:45,150 --> 00:11:49,680
look at brain pool curse is because

227
00:11:47,010 --> 00:11:53,010
after our initial disclosure to the

228
00:11:49,680 --> 00:11:55,349
Wi-Fi Alliance they privately created

229
00:11:53,010 --> 00:11:57,900
some recommendations on how to avoid our

230
00:11:55,350 --> 00:12:00,750
attacks and in those recommendations

231
00:11:57,900 --> 00:12:03,390
they said ok you can use brain pool

232
00:12:00,750 --> 00:12:06,710
curves they are safe to use there are no

233
00:12:03,390 --> 00:12:10,050
timing attacks against them

234
00:12:06,710 --> 00:12:12,180
unfortunately when we check that there's

235
00:12:10,050 --> 00:12:15,810
bad news actually if you do use brain

236
00:12:12,180 --> 00:12:17,310
pool curves you are vulnerable so here

237
00:12:15,810 --> 00:12:19,920
we also fall back to the typical

238
00:12:17,310 --> 00:12:23,369
security advice don't write

239
00:12:19,920 --> 00:12:26,610
recommendations on security advice

240
00:12:23,370 --> 00:12:27,770
privately but we should all know that

241
00:12:26,610 --> 00:12:31,440
already

242
00:12:27,770 --> 00:12:35,189
so I want to briefly give some insight

243
00:12:31,440 --> 00:12:38,640
into why these brain pool curves also

244
00:12:35,190 --> 00:12:40,560
have timing leaks so to do this I'm

245
00:12:38,640 --> 00:12:42,000
going to do the same thing like I did

246
00:12:40,560 --> 00:12:45,209
with the mod P group I'm going to

247
00:12:42,000 --> 00:12:48,060
briefly explain how the algorithm works

248
00:12:45,210 --> 00:12:50,089
to convert a password into an elliptic

249
00:12:48,060 --> 00:12:53,250
curve point and I'm then going to

250
00:12:50,089 --> 00:12:57,270
explain where this timing information is

251
00:12:53,250 --> 00:12:59,790
leaked so if you would want to hash

252
00:12:57,270 --> 00:13:03,000
passwords to an elliptic curve point a

253
00:12:59,790 --> 00:13:06,000
naive ID would again me to just take the

254
00:13:03,000 --> 00:13:07,650
passwords this case we again combine it

255
00:13:06,000 --> 00:13:10,440
with the MAC addresses of the client and

256
00:13:07,650 --> 00:13:13,829
the access point we take the hash output

257
00:13:10,440 --> 00:13:15,870
as the x value and then we just find the

258
00:13:13,830 --> 00:13:19,680
corresponding Y value I don't use that

259
00:13:15,870 --> 00:13:22,110
as the elliptic curve point but you may

260
00:13:19,680 --> 00:13:25,290
probably now already have

261
00:13:22,110 --> 00:13:26,990
one remark about this namely there's not

262
00:13:25,290 --> 00:13:30,149
always a solution for why

263
00:13:26,990 --> 00:13:33,720
so what can we do well the first thing

264
00:13:30,149 --> 00:13:36,810
we can do is we can calculate this value

265
00:13:33,720 --> 00:13:38,880
here which is basically Y squared and we

266
00:13:36,810 --> 00:13:43,079
can see if it is a so-called

267
00:13:38,880 --> 00:13:45,510
quadratic residue if this value is a

268
00:13:43,079 --> 00:13:50,670
quadratic residue then we know that the

269
00:13:45,510 --> 00:13:53,579
solution for Y exists to handle the case

270
00:13:50,670 --> 00:13:56,010
if there is no solution we can just

271
00:13:53,579 --> 00:13:58,319
perform a loop in other words we include

272
00:13:56,010 --> 00:14:01,589
the counter in our values that are being

273
00:13:58,320 --> 00:14:08,060
hashed on we continue executing loops

274
00:14:01,589 --> 00:14:12,660
until we found a solution where we can

275
00:14:08,060 --> 00:14:14,609
where the square root exists now there's

276
00:14:12,660 --> 00:14:17,519
one problem with this and this is that

277
00:14:14,610 --> 00:14:20,940
now different passwords again have a

278
00:14:17,519 --> 00:14:23,370
different execution time now luckily in

279
00:14:20,940 --> 00:14:25,370
the case of elliptic curves they listen

280
00:14:23,370 --> 00:14:28,320
to the warnings and they include it

281
00:14:25,370 --> 00:14:32,579
suggested the defense of always

282
00:14:28,320 --> 00:14:36,420
executing K iterations no matter when

283
00:14:32,579 --> 00:14:38,880
the password was found I don't practice

284
00:14:36,420 --> 00:14:42,839
here they generally use a value of k

285
00:14:38,880 --> 00:14:43,800
equal to 40 so no matter when the

286
00:14:42,839 --> 00:14:47,060
password is found

287
00:14:43,800 --> 00:14:54,329
you're always executing 40 iterations

288
00:14:47,060 --> 00:14:59,518
and this prevents at least the timing

289
00:14:54,329 --> 00:15:01,649
attacks against NIST curse there is one

290
00:14:59,519 --> 00:15:04,410
other extra defense that they included

291
00:15:01,649 --> 00:15:06,750
here which is that once the password has

292
00:15:04,410 --> 00:15:08,660
been found they execute these extra

293
00:15:06,750 --> 00:15:12,269
iterations based on a random password

294
00:15:08,660 --> 00:15:13,980
now this is just defense in depth in

295
00:15:12,269 --> 00:15:16,920
case that there is something wrong with

296
00:15:13,980 --> 00:15:20,279
the code that's the best way to explain

297
00:15:16,920 --> 00:15:24,449
that for now now what is the problem

298
00:15:20,279 --> 00:15:27,240
here the problem is quite similar to the

299
00:15:24,449 --> 00:15:30,319
mod P case so maybe some of you can

300
00:15:27,240 --> 00:15:33,600
already figure it out the problem is

301
00:15:30,319 --> 00:15:36,099
again here this hash value that we get

302
00:15:33,600 --> 00:15:37,750
here as output can be bigger than

303
00:15:36,100 --> 00:15:40,180
the prime that is being used in the

304
00:15:37,750 --> 00:15:41,070
scripted graphic group what was the

305
00:15:40,180 --> 00:15:43,810
solution here

306
00:15:41,070 --> 00:15:46,630
well they again just say that if the

307
00:15:43,810 --> 00:15:49,810
value is bigger than the prime just go

308
00:15:46,630 --> 00:15:52,540
to the next loop and you can see the

309
00:15:49,810 --> 00:15:54,339
problem here the problem is that if this

310
00:15:52,540 --> 00:15:57,279
value is indeed bigger than the prime

311
00:15:54,339 --> 00:15:59,620
then we don't do these quadratic residue

312
00:15:57,279 --> 00:16:03,250
tests and we again get different

313
00:15:59,620 --> 00:16:05,769
execution times now the interesting

314
00:16:03,250 --> 00:16:07,959
thing here if we use NIST curves the

315
00:16:05,769 --> 00:16:11,290
probability of this condition being true

316
00:16:07,959 --> 00:16:14,229
is very low but with rain pool curves

317
00:16:11,290 --> 00:16:17,469
this has a probability of say between 10

318
00:16:14,230 --> 00:16:19,570
between 20 to close to 50 percent

319
00:16:17,470 --> 00:16:22,990
depending on the specific curve you're

320
00:16:19,570 --> 00:16:27,519
using on in that case no the quadratic

321
00:16:22,990 --> 00:16:31,360
quadratic test may be skipped so again

322
00:16:27,519 --> 00:16:35,350
we're in trouble now the timing attack

323
00:16:31,360 --> 00:16:37,930
against this case is a bit less

324
00:16:35,350 --> 00:16:40,300
straightforward because we do still have

325
00:16:37,930 --> 00:16:43,810
these extra iterations that are being

326
00:16:40,300 --> 00:16:46,359
executed and on top of that these extra

327
00:16:43,810 --> 00:16:49,060
iterations that are executed after the

328
00:16:46,360 --> 00:16:52,990
passwords element has been found they

329
00:16:49,060 --> 00:16:55,089
are based on a random password so to

330
00:16:52,990 --> 00:16:58,930
quickly illustrate the impact of this in

331
00:16:55,089 --> 00:17:01,779
practice let's say I perform some

332
00:16:58,930 --> 00:17:05,438
executions using the same MAC address

333
00:17:01,779 --> 00:17:07,809
then in this case here green illustrates

334
00:17:05,439 --> 00:17:09,970
that I executed the quadratic residue

335
00:17:07,809 --> 00:17:13,149
test in a loop the small bar here

336
00:17:09,970 --> 00:17:14,860
illustrates that - output was bigger

337
00:17:13,150 --> 00:17:18,280
than the prime so there's no quadratic

338
00:17:14,859 --> 00:17:21,250
test say that after four iterations we

339
00:17:18,280 --> 00:17:24,490
found the password so at that point

340
00:17:21,250 --> 00:17:27,130
extra iterations are executed based on a

341
00:17:24,490 --> 00:17:30,370
random password so we get some amount of

342
00:17:27,130 --> 00:17:33,970
extra time that the algorithm takes if

343
00:17:30,370 --> 00:17:36,159
you now execute the algorithm again we

344
00:17:33,970 --> 00:17:38,080
always have that the first iterations

345
00:17:36,160 --> 00:17:40,570
they are identical because they're based

346
00:17:38,080 --> 00:17:43,570
on the real password but these extra

347
00:17:40,570 --> 00:17:46,480
iterations they use a random password so

348
00:17:43,570 --> 00:17:48,760
each time we also get a random amount of

349
00:17:46,480 --> 00:17:50,489
extra time that is being added to the

350
00:17:48,760 --> 00:17:54,639
execute

351
00:17:50,489 --> 00:17:58,330
but even with this it leaks sensitive

352
00:17:54,639 --> 00:18:01,449
information because now the variance of

353
00:17:58,330 --> 00:18:05,918
the execution time depends on when the

354
00:18:01,450 --> 00:18:08,049
password was found for example if the

355
00:18:05,919 --> 00:18:10,119
password is immediately found after the

356
00:18:08,049 --> 00:18:12,700
first iteration you get a lot of

357
00:18:10,119 --> 00:18:15,488
variance but if the password was found

358
00:18:12,700 --> 00:18:19,749
say after 20 iterations you get a low

359
00:18:15,489 --> 00:18:22,539
amount of variance on top of that the

360
00:18:19,749 --> 00:18:25,239
average execution time also still leaks

361
00:18:22,539 --> 00:18:28,119
information because that depends on the

362
00:18:25,239 --> 00:18:31,090
number of iterations needed to find the

363
00:18:28,119 --> 00:18:36,070
password and how many of those

364
00:18:31,090 --> 00:18:37,869
iterations had a hash output bigger than

365
00:18:36,070 --> 00:18:41,590
the prime so there was no quadratic

366
00:18:37,869 --> 00:18:43,689
residue test so again we have the same

367
00:18:41,590 --> 00:18:45,999
case here that this forms a signature of

368
00:18:43,690 --> 00:18:51,070
the password and we can use that in an

369
00:18:45,999 --> 00:18:52,989
offline dictionary attack and if we

370
00:18:51,070 --> 00:18:55,960
perform this test again against a

371
00:18:52,989 --> 00:18:59,289
raspberry pi we again notice that this

372
00:18:55,960 --> 00:19:02,200
timing information can be measured over

373
00:18:59,289 --> 00:19:05,109
Wi-Fi in the case of brain pool we need

374
00:19:02,200 --> 00:19:07,299
to make more measurements or MAC address

375
00:19:05,109 --> 00:19:10,239
because the timing differences are

376
00:19:07,299 --> 00:19:13,330
smaller but it's still feasible to do

377
00:19:10,239 --> 00:19:18,429
this in practice and a few sorry in a

378
00:19:13,330 --> 00:19:20,590
few hours so another possibility here

379
00:19:18,429 --> 00:19:23,229
and I'm going to cover this very briefly

380
00:19:20,590 --> 00:19:25,478
instead of doing timing attacks we can

381
00:19:23,229 --> 00:19:27,479
also do cache attacks basically we have

382
00:19:25,479 --> 00:19:31,419
the same algorithm as before

383
00:19:27,479 --> 00:19:34,779
we can basically use flush plus reload

384
00:19:31,419 --> 00:19:36,940
to detect when the password was found we

385
00:19:34,779 --> 00:19:40,450
can do the same thing with brain pool we

386
00:19:36,940 --> 00:19:42,309
can use flush unreal out to detect when

387
00:19:40,450 --> 00:19:46,179
the hash output was bigger than the

388
00:19:42,309 --> 00:19:47,849
prime now I'm not going to discuss much

389
00:19:46,179 --> 00:19:50,499
more because I don't have time for this

390
00:19:47,849 --> 00:19:52,840
we actually found a lot more interesting

391
00:19:50,499 --> 00:19:55,840
things we also found some implementation

392
00:19:52,840 --> 00:19:58,059
specific vulnerabilities and EEP PWD on

393
00:19:55,840 --> 00:20:01,389
the one I want to highlight is that if

394
00:19:58,059 --> 00:20:03,830
you use bad randomness in dragonfly then

395
00:20:01,389 --> 00:20:06,019
you can recover the plaintext

396
00:20:03,830 --> 00:20:07,939
password so that's one thing to take

397
00:20:06,019 --> 00:20:10,220
into account maybe if you design a

398
00:20:07,940 --> 00:20:12,230
handshake like this I think it's good to

399
00:20:10,220 --> 00:20:15,760
also discuss what would be the impact if

400
00:20:12,230 --> 00:20:18,529
there is a flawed source of randomness

401
00:20:15,760 --> 00:20:20,629
we also found a text specific to Wi-Fi

402
00:20:18,529 --> 00:20:23,679
but I'm not going to mention them here

403
00:20:20,630 --> 00:20:26,929
and the interesting thing here is that

404
00:20:23,679 --> 00:20:29,510
finally the Wi-Fi standard is now being

405
00:20:26,929 --> 00:20:34,039
updated to use a constant time algorithm

406
00:20:29,510 --> 00:20:36,529
to find the password elements and maybe

407
00:20:34,039 --> 00:20:39,019
this will be included in WPA 3 I'm not

408
00:20:36,529 --> 00:20:41,889
sure but at least on the Wi-Fi on the

409
00:20:39,019 --> 00:20:45,289
altitude 11 group they are working on it

410
00:20:41,889 --> 00:20:53,750
so with that I'd like to conclude my

411
00:20:45,289 --> 00:20:55,070
talk thank you for your attention so we

412
00:20:53,750 --> 00:20:56,419
have time for probably one quick

413
00:20:55,070 --> 00:20:58,700
question and then we have to move on to

414
00:20:56,419 --> 00:21:02,200
the next presenter if that person come

415
00:20:58,700 --> 00:21:02,200
up get ready that'd be great

416
00:21:04,600 --> 00:21:09,559
I'm sorry at the first two attacks you

417
00:21:07,789 --> 00:21:14,210
showed looks like they could be easily

418
00:21:09,559 --> 00:21:17,389
beat well ative lee simply worked around

419
00:21:14,210 --> 00:21:20,929
by just by redesigning exactly how the

420
00:21:17,389 --> 00:21:26,949
code works by iterating as many times

421
00:21:20,929 --> 00:21:30,799
and always performing the the the quad

422
00:21:26,950 --> 00:21:37,250
the QR test even if P is greater than if

423
00:21:30,799 --> 00:21:39,730
the point is greater than P have are

424
00:21:37,250 --> 00:21:42,769
your other issues that you haven't

425
00:21:39,730 --> 00:21:45,409
addressed you hey you haven't talked

426
00:21:42,769 --> 00:21:51,169
about is are they also can be worked

427
00:21:45,409 --> 00:21:53,450
around so there are workarounds but they

428
00:21:51,169 --> 00:21:55,610
are not a deal in practice because we

429
00:21:53,450 --> 00:21:58,070
saw and practice that I mean

430
00:21:55,610 --> 00:22:00,110
theoretically speaking you can implement

431
00:21:58,070 --> 00:22:04,789
this in a secure way to avoid cache

432
00:22:00,110 --> 00:22:06,620
attacks to avoid timing attacks but the

433
00:22:04,789 --> 00:22:07,940
first problem is that this is very

434
00:22:06,620 --> 00:22:10,309
tedious in practice

435
00:22:07,940 --> 00:22:13,070
so there's a high chance of developers

436
00:22:10,309 --> 00:22:14,960
from accidentally still introducing a

437
00:22:13,070 --> 00:22:17,590
direct cache attack or a timing leak so

438
00:22:14,960 --> 00:22:20,390
I would not recommend that at all

439
00:22:17,590 --> 00:22:22,668
the other problem is that a lot of times

440
00:22:20,390 --> 00:22:25,240
the Wi-Fi handshake is offloaded to the

441
00:22:22,669 --> 00:22:28,309
Wi-Fi chip itself which is which has

442
00:22:25,240 --> 00:22:31,460
which is basically resource-limited and

443
00:22:28,309 --> 00:22:36,320
then always executing 40 iterations it's

444
00:22:31,460 --> 00:22:37,850
just way too costly if you wouldn't

445
00:22:36,320 --> 00:22:41,389
recommend it what solution would you

446
00:22:37,850 --> 00:22:45,230
recommend so that's the one one thing I

447
00:22:41,390 --> 00:22:47,179
would recommend is to make to allow the

448
00:22:45,230 --> 00:22:48,860
offline computation of basically the

449
00:22:47,179 --> 00:22:51,230
password elements so it doesn't have to

450
00:22:48,860 --> 00:22:53,840
be recomputed every time you perform the

451
00:22:51,230 --> 00:22:57,350
handshake on the second one is mentioned

452
00:22:53,840 --> 00:23:00,530
here to use a constant time way to do it

453
00:22:57,350 --> 00:23:02,540
and there's a RFC being written with

454
00:23:00,530 --> 00:23:05,320
several ways to do that in other words

455
00:23:02,540 --> 00:23:07,460
modify the protocol unfortunately yes

456
00:23:05,320 --> 00:23:09,678
I'm sorry question we don't have time

457
00:23:07,460 --> 00:23:11,809
for any more questions at this point I'm

458
00:23:09,679 --> 00:23:13,429
sure you could take it offline but I'm

459
00:23:11,809 --> 00:23:15,930
free to discuss things off line as well

460
00:23:13,429 --> 00:23:22,470
today thank you all sega's be here again

461
00:23:15,930 --> 00:23:22,470
[Applause]

462
00:23:48,410 --> 00:23:55,910
all right our next picture is Jolie he

463
00:23:52,410 --> 00:23:59,429
is a assistant professor at UC Irvine

464
00:23:55,910 --> 00:24:01,290
and he's going to be talking about DNS

465
00:23:59,429 --> 00:24:07,940
interception so let's give him a round

466
00:24:01,290 --> 00:24:10,139
of applause before he is deserted okay

467
00:24:07,940 --> 00:24:13,679
thank you for the nice introduction and

468
00:24:10,140 --> 00:24:16,200
welcome to my talk so my name is Tony

469
00:24:13,679 --> 00:24:18,750
I'm currently an assistant professor at

470
00:24:16,200 --> 00:24:21,750
the UC Irvine and this is a joint work

471
00:24:18,750 --> 00:24:25,049
with my causers from Shanghai University

472
00:24:21,750 --> 00:24:27,660
for the universities in China and UT

473
00:24:25,049 --> 00:24:30,330
Dallas and actually one of the causer as

474
00:24:27,660 --> 00:24:33,059
in do I sit in there so if you guys

475
00:24:30,330 --> 00:24:35,100
later has have questions regarding our

476
00:24:33,059 --> 00:24:38,160
talks you can come to us during the

477
00:24:35,100 --> 00:24:39,959
break so let's get it started so the

478
00:24:38,160 --> 00:24:47,970
topic of this talk is about the D s

479
00:24:39,960 --> 00:24:49,620
security and let's first give some ok so

480
00:24:47,970 --> 00:24:53,460
first let's give a quick background

481
00:24:49,620 --> 00:24:55,909
overview about the s so in this talk we

482
00:24:53,460 --> 00:24:59,429
focus on the ETS resolution process

483
00:24:55,910 --> 00:25:01,710
essentially say if you have a client you

484
00:24:59,429 --> 00:25:04,140
want to get an IP address of domain name

485
00:25:01,710 --> 00:25:05,850
for example RI RTF dot o-r-g so

486
00:25:04,140 --> 00:25:08,130
typically you work out your recursive

487
00:25:05,850 --> 00:25:10,080
resolver and then the recursive resolver

488
00:25:08,130 --> 00:25:12,150
will handle all those resolution process

489
00:25:10,080 --> 00:25:14,100
for you like going to the different

490
00:25:12,150 --> 00:25:16,320
authoritative servers like the to the

491
00:25:14,100 --> 00:25:18,270
name server top-level domain name server

492
00:25:16,320 --> 00:25:20,159
and a second level to my name is over to

493
00:25:18,270 --> 00:25:23,460
cut the IP address of you to me and then

494
00:25:20,160 --> 00:25:26,070
give back to the client so when you have

495
00:25:23,460 --> 00:25:28,260
a contract with ICP are typically they

496
00:25:26,070 --> 00:25:31,409
will give you a default recursive

497
00:25:28,260 --> 00:25:33,780
resolver for you to use but now it turns

498
00:25:31,410 --> 00:25:36,090
out and one more users prefer to use is

499
00:25:33,780 --> 00:25:38,370
public the answer is over we have Google

500
00:25:36,090 --> 00:25:41,730
we have open yes we also have called

501
00:25:38,370 --> 00:25:43,678
flare they are very good so I believe

502
00:25:41,730 --> 00:25:45,179
them the major three reasons for the

503
00:25:43,679 --> 00:25:47,160
users to switch the public theater

504
00:25:45,179 --> 00:25:50,220
observers could be the performance could

505
00:25:47,160 --> 00:25:52,020
it be the battery security and also the

506
00:25:50,220 --> 00:25:55,020
support for the t as extensions turn out

507
00:25:52,020 --> 00:25:57,660
to be may be better so the security

508
00:25:55,020 --> 00:25:59,010
issues we investigate English talk is

509
00:25:57,660 --> 00:26:02,010
that say

510
00:25:59,010 --> 00:26:04,559
as a users you choose Public DNS

511
00:26:02,010 --> 00:26:06,658
resolvers and you won this publicly as

512
00:26:04,559 --> 00:26:09,570
resolvers to handle your request you

513
00:26:06,659 --> 00:26:11,610
still send that dooming request the to

514
00:26:09,570 --> 00:26:13,830
this resolver but there are some

515
00:26:11,610 --> 00:26:16,830
unpassed middleboxes that can see your

516
00:26:13,830 --> 00:26:19,168
request and assume UTS request is not

517
00:26:16,830 --> 00:26:21,809
encrypted so what can really happen and

518
00:26:19,169 --> 00:26:25,740
in particular we look into this specific

519
00:26:21,809 --> 00:26:28,918
case say there's a guy on a path and

520
00:26:25,740 --> 00:26:31,919
basically intercept you OTS request and

521
00:26:28,919 --> 00:26:34,139
then redirected to one alternative

522
00:26:31,919 --> 00:26:36,840
resolver and that this alternative

523
00:26:34,139 --> 00:26:39,658
resolver to handle the resolution so

524
00:26:36,840 --> 00:26:41,580
then say the public das Google will be

525
00:26:39,659 --> 00:26:44,490
kicked out completely from his picture

526
00:26:41,580 --> 00:26:46,470
and this authoritative resolver well do

527
00:26:44,490 --> 00:26:48,570
the query and the response Hannity and I

528
00:26:46,470 --> 00:26:50,340
finally gave the request to the user so

529
00:26:48,570 --> 00:26:52,950
that's the limb problem when we look

530
00:26:50,340 --> 00:26:55,260
into in this work and it turns out this

531
00:26:52,950 --> 00:26:58,440
kind of a request tampering is really

532
00:26:55,260 --> 00:27:00,899
hard to detect because the alternative

533
00:26:58,440 --> 00:27:03,539
resolver can basically spoof the IP

534
00:27:00,899 --> 00:27:05,340
address so it can pretend to be Google

535
00:27:03,539 --> 00:27:08,220
and then if you are client you're

536
00:27:05,340 --> 00:27:10,529
looking to the source IP address of this

537
00:27:08,220 --> 00:27:14,700
of these packets it's really hard to

538
00:27:10,529 --> 00:27:16,679
discern those cases so we found that

539
00:27:14,700 --> 00:27:19,230
there are four types of it potential

540
00:27:16,679 --> 00:27:21,750
interceptors doing this network provider

541
00:27:19,230 --> 00:27:24,029
ISP is only one of them censorship fair

542
00:27:21,750 --> 00:27:25,740
also doing that now there have have

543
00:27:24,029 --> 00:27:27,960
already been some reports talking about

544
00:27:25,740 --> 00:27:29,940
that and then have our software now well

545
00:27:27,960 --> 00:27:33,000
doing that and also Enterprise proxies

546
00:27:29,940 --> 00:27:35,669
are doing that as I example for the SPE

547
00:27:33,000 --> 00:27:39,120
we found there has been some reports and

548
00:27:35,669 --> 00:27:41,070
news about these practices and actually

549
00:27:39,120 --> 00:27:44,489
this type of middleboxes is named as

550
00:27:41,070 --> 00:27:46,980
transparent yes proxy by those parties

551
00:27:44,490 --> 00:27:48,899
so it's kind of to be something known to

552
00:27:46,980 --> 00:27:51,269
the community but in this work we try to

553
00:27:48,899 --> 00:27:54,000
do a large-scale more comprehensive

554
00:27:51,269 --> 00:27:55,529
analysis instead of doing individual

555
00:27:54,000 --> 00:27:59,549
news reports so that's the main

556
00:27:55,529 --> 00:28:01,919
contribution of this work okay so

557
00:27:59,549 --> 00:28:05,039
basically the two main questions we want

558
00:28:01,919 --> 00:28:07,500
to answer in this research is first how

559
00:28:05,039 --> 00:28:09,559
prevalent is this approach is practice

560
00:28:07,500 --> 00:28:12,090
how prevalent is the as interception and

561
00:28:09,559 --> 00:28:12,710
second what are the characteristics of

562
00:28:12,090 --> 00:28:15,270
the tea

563
00:28:12,710 --> 00:28:18,390
interceptions was their strategy and

564
00:28:15,270 --> 00:28:21,980
what do they really like in practice

565
00:28:18,390 --> 00:28:25,110
so let's first come to the threat model

566
00:28:21,980 --> 00:28:27,300
so actually in a previous example we

567
00:28:25,110 --> 00:28:29,040
only introduced one way to do that yes

568
00:28:27,300 --> 00:28:31,980
interception and it turns out there are

569
00:28:29,040 --> 00:28:34,590
a few more ways to do that so let's

570
00:28:31,980 --> 00:28:37,050
first come to our basic picture say we

571
00:28:34,590 --> 00:28:39,629
have those five parties we have a client

572
00:28:37,050 --> 00:28:41,460
Public DNS and the authoritative server

573
00:28:39,630 --> 00:28:43,950
they are the normal parties handling you

574
00:28:41,460 --> 00:28:46,470
audience requests and responses and then

575
00:28:43,950 --> 00:28:48,840
now we have found has device and then

576
00:28:46,470 --> 00:28:51,090
one alternative resolvers likely to

577
00:28:48,840 --> 00:28:54,300
belong to a same owner of this on hosta

578
00:28:51,090 --> 00:28:56,490
on pass device so when the on pants

579
00:28:54,300 --> 00:28:59,909
device doesn't do anything anomalous

580
00:28:56,490 --> 00:29:01,560
anything suspicious either shoot just a

581
00:28:59,910 --> 00:29:04,470
forward your request that to the public

582
00:29:01,560 --> 00:29:07,169
dns and like the public the s to handle

583
00:29:04,470 --> 00:29:09,000
everything so the bad things happen when

584
00:29:07,170 --> 00:29:12,480
this some positive eyes try to change

585
00:29:09,000 --> 00:29:15,840
your a request so the first example we

586
00:29:12,480 --> 00:29:17,730
look into eases request retraction so in

587
00:29:15,840 --> 00:29:20,939
that case the unpassed device were

588
00:29:17,730 --> 00:29:23,640
simply block you request to public TS of

589
00:29:20,940 --> 00:29:25,470
example from google and then instead

590
00:29:23,640 --> 00:29:28,020
either word i mean whitter actual

591
00:29:25,470 --> 00:29:29,970
request to its own alternative resolver

592
00:29:28,020 --> 00:29:33,889
and then daughter deliveries over well

593
00:29:29,970 --> 00:29:36,960
duty resolution and response handling

594
00:29:33,890 --> 00:29:39,390
actually there's another case for the TS

595
00:29:36,960 --> 00:29:41,400
interception so in that case the

596
00:29:39,390 --> 00:29:44,550
unpassed device were replicated

597
00:29:41,400 --> 00:29:46,380
requested to different places so first

598
00:29:44,550 --> 00:29:49,290
you'll request the worst still go to the

599
00:29:46,380 --> 00:29:51,390
public dns and then gather resolved in

600
00:29:49,290 --> 00:29:53,550
the meantime damned past device will

601
00:29:51,390 --> 00:29:56,520
copy the same requests an issue that

602
00:29:53,550 --> 00:29:59,040
true to his own alternative resolvers

603
00:29:56,520 --> 00:30:00,930
so from the prospective authoritative

604
00:29:59,040 --> 00:30:02,850
server there are be two requests and

605
00:30:00,930 --> 00:30:05,010
then two responses were go to the

606
00:30:02,850 --> 00:30:07,980
clients and typically the first one go

607
00:30:05,010 --> 00:30:11,430
to the client will be cached and used by

608
00:30:07,980 --> 00:30:14,820
the client and there's also a third

609
00:30:11,430 --> 00:30:18,240
category of TS interception so in that

610
00:30:14,820 --> 00:30:21,149
case the request to public TS is still

611
00:30:18,240 --> 00:30:24,170
blocked and then the request or basanta

612
00:30:21,150 --> 00:30:26,510
2.30 authoritative resolver

613
00:30:24,170 --> 00:30:29,240
but when this happens the alternative

614
00:30:26,510 --> 00:30:30,890
resolver stops from being from ascending

615
00:30:29,240 --> 00:30:33,590
your request that you do certain ative

616
00:30:30,890 --> 00:30:36,350
server but instead you it work directly

617
00:30:33,590 --> 00:30:38,659
give you the response to the to the to

618
00:30:36,350 --> 00:30:41,240
the clients so in the end we are looking

619
00:30:38,660 --> 00:30:46,820
to those three types of issues during TS

620
00:30:41,240 --> 00:30:49,310
interception and next let let us take a

621
00:30:46,820 --> 00:30:52,280
look at the methodology we try to detect

622
00:30:49,310 --> 00:30:55,820
those kind of das interception practices

623
00:30:52,280 --> 00:30:57,980
so actually from the previous three

624
00:30:55,820 --> 00:31:00,889
examples you may already have some idea

625
00:30:57,980 --> 00:31:03,020
to detect this because say if you are

626
00:31:00,890 --> 00:31:04,970
able to control the clients and you are

627
00:31:03,020 --> 00:31:07,129
also able to control some other

628
00:31:04,970 --> 00:31:09,860
authoritative nameservers and you are

629
00:31:07,130 --> 00:31:11,480
able to direct your client to send them

630
00:31:09,860 --> 00:31:14,840
requests to your own authoritative

631
00:31:11,480 --> 00:31:17,930
servers and based and by looking to the

632
00:31:14,840 --> 00:31:20,419
differences between the requests the

633
00:31:17,930 --> 00:31:22,760
patterns from the public the ESRI

634
00:31:20,420 --> 00:31:26,360
servers and not arterial resolvers you

635
00:31:22,760 --> 00:31:29,030
are able to discern those cases the main

636
00:31:26,360 --> 00:31:31,129
reason is like if you if by looking to

637
00:31:29,030 --> 00:31:33,260
the source IP address of the requests

638
00:31:31,130 --> 00:31:35,240
that go into associative servers if the

639
00:31:33,260 --> 00:31:37,010
source IP address does not really belong

640
00:31:35,240 --> 00:31:39,290
to you for example Google belongs to

641
00:31:37,010 --> 00:31:41,180
something you have no idea about nothing

642
00:31:39,290 --> 00:31:43,280
relevant to Google and then you can

643
00:31:41,180 --> 00:31:45,650
figure out there may be some issues we

644
00:31:43,280 --> 00:31:47,980
see that yes resolution process so

645
00:31:45,650 --> 00:31:50,270
actually this is what we do we do this

646
00:31:47,980 --> 00:31:52,340
and to end data collection and the

647
00:31:50,270 --> 00:31:54,260
comparison we do control some clients

648
00:31:52,340 --> 00:31:56,810
and item to send a large number of

649
00:31:54,260 --> 00:31:59,030
requests and then we also can show some

650
00:31:56,810 --> 00:32:02,480
associative servers and to receive those

651
00:31:59,030 --> 00:32:05,060
requests and then do some comparison but

652
00:32:02,480 --> 00:32:07,640
still there are two major challenges we

653
00:32:05,060 --> 00:32:10,100
need to address first how can we gather

654
00:32:07,640 --> 00:32:12,470
those large number of the vantage points

655
00:32:10,100 --> 00:32:15,409
I mean those middle boxes some of them

656
00:32:12,470 --> 00:32:17,600
are very close to the clients so if you

657
00:32:15,410 --> 00:32:19,310
want to observe in novel of those yes

658
00:32:17,600 --> 00:32:21,560
interceptions will lead an odd number of

659
00:32:19,310 --> 00:32:24,050
1h points so we actually leverage the

660
00:32:21,560 --> 00:32:26,629
two platforms the first actually comes

661
00:32:24,050 --> 00:32:28,790
from proxy rack which is a Sox

662
00:32:26,630 --> 00:32:31,010
residential proxy networks actually as a

663
00:32:28,790 --> 00:32:33,320
client a customer you can buy it

664
00:32:31,010 --> 00:32:35,570
services and it's a peer-to-peer proxy

665
00:32:33,320 --> 00:32:37,370
network so you can actually send your

666
00:32:35,570 --> 00:32:40,309
request you skate away under

667
00:32:37,370 --> 00:32:42,590
we were fun to appear in his pourraient

668
00:32:40,309 --> 00:32:44,840
and that appeared to redirect you

669
00:32:42,590 --> 00:32:46,550
request that to some places else so we

670
00:32:44,840 --> 00:32:49,429
had to actually leverage a large number

671
00:32:46,550 --> 00:32:52,190
of IP for us to do this measurement

672
00:32:49,430 --> 00:32:54,559
Authority so in the end this is the

673
00:32:52,190 --> 00:32:56,660
first one we use but the limitation for

674
00:32:54,559 --> 00:33:00,230
that it only supports TCP and we will

675
00:32:56,660 --> 00:33:03,860
note yes is major based on UDP so to

676
00:33:00,230 --> 00:33:06,410
measure UDP IDs request what do we do is

677
00:33:03,860 --> 00:33:09,620
to actually work with a company in China

678
00:33:06,410 --> 00:33:12,410
who is who we have a good relationship

679
00:33:09,620 --> 00:33:14,899
with and allows us to write to to put

680
00:33:12,410 --> 00:33:17,000
our code in it's a network debugger

681
00:33:14,900 --> 00:33:19,610
modules so we actually implement how

682
00:33:17,000 --> 00:33:22,970
much Amanda logic and Latta to run on

683
00:33:19,610 --> 00:33:26,199
the client devices so by doing that we

684
00:33:22,970 --> 00:33:28,910
are able to measure both TCP and UDP and

685
00:33:26,200 --> 00:33:32,120
and then second the Challenger we need

686
00:33:28,910 --> 00:33:34,700
to address is how able to see the

687
00:33:32,120 --> 00:33:37,250
policies of interceptions of the middle

688
00:33:34,700 --> 00:33:38,960
boxes because they are kind of black box

689
00:33:37,250 --> 00:33:41,540
we cannot really go there and at the

690
00:33:38,960 --> 00:33:43,309
open the box and see how the implement

691
00:33:41,540 --> 00:33:45,500
there are rules so what we are trying to

692
00:33:43,309 --> 00:33:47,840
do in the end is to enumerate or the

693
00:33:45,500 --> 00:33:48,530
possible policies and this is a

694
00:33:47,840 --> 00:33:52,070
best-effort

695
00:33:48,530 --> 00:33:55,580
approach so we actually focus on five

696
00:33:52,070 --> 00:33:59,659
types of fields first is the public IDs

697
00:33:55,580 --> 00:34:01,790
resolvers that i mean a destined by the

698
00:33:59,660 --> 00:34:03,890
users to handle the requests and second

699
00:34:01,790 --> 00:34:06,800
the different protocols and third of

700
00:34:03,890 --> 00:34:08,720
different types of a requests and also

701
00:34:06,800 --> 00:34:10,940
we look into the different types of a TR

702
00:34:08,719 --> 00:34:13,549
DS and finally there's a particular

703
00:34:10,940 --> 00:34:15,649
challenge here is how we able to link

704
00:34:13,550 --> 00:34:17,840
the request from the clients to the

705
00:34:15,649 --> 00:34:20,179
requests into the associative servers

706
00:34:17,840 --> 00:34:23,330
because when the requests that come from

707
00:34:20,179 --> 00:34:25,429
comes through what those meter boxes the

708
00:34:23,330 --> 00:34:27,500
source IP address were be changed so

709
00:34:25,429 --> 00:34:29,600
there's an obvious way to to to link

710
00:34:27,500 --> 00:34:32,899
that so in the end the with you develop

711
00:34:29,600 --> 00:34:35,360
this trick say we actually encounter the

712
00:34:32,899 --> 00:34:37,638
unique ID for the source into the to my

713
00:34:35,360 --> 00:34:39,679
name and it turns out that those middle

714
00:34:37,639 --> 00:34:42,560
boxes don't really change the to me name

715
00:34:39,679 --> 00:34:44,929
so by doing that from the perspective or

716
00:34:42,560 --> 00:34:48,440
associative name servers so we can link

717
00:34:44,929 --> 00:34:52,450
the request from e Sorrentino cinders to

718
00:34:48,440 --> 00:34:56,059
the ones received by by themself

719
00:34:52,449 --> 00:34:58,098
okay so so in the end by using these two

720
00:34:56,059 --> 00:35:01,730
platforms we're able to send a six

721
00:34:58,099 --> 00:35:03,740
million requested to the public Athena's

722
00:35:01,730 --> 00:35:06,109
resolver send it to our authoritative

723
00:35:03,740 --> 00:35:08,868
nameservers and we have a good coverage

724
00:35:06,109 --> 00:35:12,650
of the geolocation so actually we have

725
00:35:08,869 --> 00:35:14,720
more than 170 countries observe we order

726
00:35:12,650 --> 00:35:18,019
that in our dataset and the more than

727
00:35:14,720 --> 00:35:19,910
3000 autonomous systems yes

728
00:35:18,019 --> 00:35:23,538
in order that said so we believe this is

729
00:35:19,910 --> 00:35:25,220
a really good data sets to look into so

730
00:35:23,539 --> 00:35:27,980
due to the time limit I will only talk

731
00:35:25,220 --> 00:35:30,200
about three major observations during

732
00:35:27,980 --> 00:35:31,579
our study so first question we want to

733
00:35:30,200 --> 00:35:35,000
answer is how many queries are

734
00:35:31,579 --> 00:35:37,339
intercepted actually we're looking to

735
00:35:35,000 --> 00:35:40,269
the two different platforms for the

736
00:35:37,339 --> 00:35:43,940
global wide analysis we have about so

737
00:35:40,269 --> 00:35:47,709
1,700 yes 19 turns out in the end there

738
00:35:43,940 --> 00:35:51,109
were there are 198 is doing interception

739
00:35:47,710 --> 00:35:55,519
and the for the experiments in China we

740
00:35:51,109 --> 00:35:58,549
found from those 356 yes there are 61

741
00:35:55,519 --> 00:36:01,220
yes to interception so those numbers

742
00:35:58,549 --> 00:36:03,140
actually are not small so we think this

743
00:36:01,220 --> 00:36:06,279
is this is contents out to be an issue

744
00:36:03,140 --> 00:36:09,558
we really need to take good care of and

745
00:36:06,279 --> 00:36:11,450
then we also look into the differences

746
00:36:09,559 --> 00:36:14,240
between the public es resolver sign

747
00:36:11,450 --> 00:36:16,519
turns out if you are trying to go to a

748
00:36:14,240 --> 00:36:19,129
more public more maybe more popular like

749
00:36:16,519 --> 00:36:21,098
well known publicly as resolvers the

750
00:36:19,130 --> 00:36:23,019
chances you'll request to get

751
00:36:21,099 --> 00:36:25,430
interception that may be higher so

752
00:36:23,019 --> 00:36:28,160
actually if you are in China and then

753
00:36:25,430 --> 00:36:30,649
you use Google's public dns if you're

754
00:36:28,160 --> 00:36:32,629
using UDP 28 the percent of a chance

755
00:36:30,650 --> 00:36:35,569
your requests are being intercepted and

756
00:36:32,630 --> 00:36:38,509
if you're using TCP the ratio is smaller

757
00:36:35,569 --> 00:36:40,788
and actually we have one recursive

758
00:36:38,509 --> 00:36:43,250
resolver set of ourselves actually under

759
00:36:40,789 --> 00:36:46,759
China's edu network and turns out the

760
00:36:43,250 --> 00:36:48,500
ratio is much smaller so actually I

761
00:36:46,759 --> 00:36:51,259
think it makes sense because I don't

762
00:36:48,500 --> 00:36:52,910
think I mean those CTO tes rêves overs

763
00:36:51,259 --> 00:36:56,269
are known to them and they are

764
00:36:52,910 --> 00:36:58,700
interested to them and the second

765
00:36:56,269 --> 00:37:01,160
question we want to answer is how are my

766
00:36:58,700 --> 00:37:04,819
queries intercepted we talked about

767
00:37:01,160 --> 00:37:07,009
three types of TS interceptions the

768
00:37:04,820 --> 00:37:09,140
Qwest redirection request replication

769
00:37:07,010 --> 00:37:12,170
and direct responding in terms of in

770
00:37:09,140 --> 00:37:14,600
most cases those middleboxes who are due

771
00:37:12,170 --> 00:37:16,310
to request a redirection of smooth as

772
00:37:14,600 --> 00:37:18,740
mauricio well to that request the

773
00:37:16,310 --> 00:37:22,160
replication and then for the directory

774
00:37:18,740 --> 00:37:23,959
responding is really really rare and the

775
00:37:22,160 --> 00:37:25,940
third question we want to answer is are

776
00:37:23,960 --> 00:37:27,470
my response that tempered I think for

777
00:37:25,940 --> 00:37:28,910
the security perspective this is the

778
00:37:27,470 --> 00:37:31,370
most important question we want to know

779
00:37:28,910 --> 00:37:34,370
and it turns out that actually the

780
00:37:31,370 --> 00:37:36,200
message is kinda positive I mean in some

781
00:37:34,370 --> 00:37:38,569
sense because most the responses are not

782
00:37:36,200 --> 00:37:41,779
tempered from the six media and

783
00:37:38,570 --> 00:37:43,520
responses responses only hundreds of

784
00:37:41,780 --> 00:37:45,980
them are going to change the result

785
00:37:43,520 --> 00:37:48,230
users consent and there's the one

786
00:37:45,980 --> 00:37:50,990
interesting case we want to briefly go

787
00:37:48,230 --> 00:37:52,790
through here is traffic monetization so

788
00:37:50,990 --> 00:37:54,680
actually if you are in China and then

789
00:37:52,790 --> 00:37:57,200
you belong to this China mobile group of

790
00:37:54,680 --> 00:37:59,060
Yunnan autonomous system if you use

791
00:37:57,200 --> 00:38:02,569
Google's public dns and you send the

792
00:37:59,060 --> 00:38:04,430
requested of Yahoo's IP address and then

793
00:38:02,570 --> 00:38:08,000
your response will be chained to this

794
00:38:04,430 --> 00:38:10,490
app advertisements IP so actually this

795
00:38:08,000 --> 00:38:12,590
app advertisements also belong to the

796
00:38:10,490 --> 00:38:17,600
same yes so they actually somehow

797
00:38:12,590 --> 00:38:21,740
monetize they are traffic from your from

798
00:38:17,600 --> 00:38:24,380
UTS requests okay so I will quickly go

799
00:38:21,740 --> 00:38:27,169
through some way we think about that can

800
00:38:24,380 --> 00:38:28,940
address this issue so first we think I

801
00:38:27,170 --> 00:38:31,070
mean this issue should still be taken

802
00:38:28,940 --> 00:38:32,840
care of even though it turns out the

803
00:38:31,070 --> 00:38:35,150
response temporary is not too much

804
00:38:32,840 --> 00:38:37,970
because I think from users perspective

805
00:38:35,150 --> 00:38:40,490
is their rise to know who is really the

806
00:38:37,970 --> 00:38:42,799
the person that the party handling their

807
00:38:40,490 --> 00:38:44,660
request and so fathers in a way for user

808
00:38:42,800 --> 00:38:46,820
to to to know that and certainly we

809
00:38:44,660 --> 00:38:50,060
found those open resolvers security is

810
00:38:46,820 --> 00:38:52,760
not really good actually only 43% of

811
00:38:50,060 --> 00:38:55,630
them support the s sec and we found for

812
00:38:52,760 --> 00:38:58,010
those resolvers using the pant yes

813
00:38:55,630 --> 00:39:00,560
resolution to kids it turns out all of

814
00:38:58,010 --> 00:39:02,900
those versions should be deprecated well

815
00:39:00,560 --> 00:39:04,850
before 2009 so they are using all those

816
00:39:02,900 --> 00:39:09,050
of very vulnerable versions that are

817
00:39:04,850 --> 00:39:11,600
really not good so two tips about

818
00:39:09,050 --> 00:39:14,030
addressing this problem first we think

819
00:39:11,600 --> 00:39:15,650
we think the attack is still a relevant

820
00:39:14,030 --> 00:39:16,470
technology to address this issue

821
00:39:15,650 --> 00:39:19,740
I mean you

822
00:39:16,470 --> 00:39:22,259
those recursive resolvers may ignore the

823
00:39:19,740 --> 00:39:25,169
asset as a client if you do verifying

824
00:39:22,260 --> 00:39:27,090
your response from I'm using PS ik

825
00:39:25,170 --> 00:39:29,849
there's a chance you can't detect such

826
00:39:27,090 --> 00:39:32,430
response tempering and then prevents

827
00:39:29,849 --> 00:39:34,320
these bad things from being happening an

828
00:39:32,430 --> 00:39:36,598
attack in the suggestion we want to give

829
00:39:34,320 --> 00:39:39,060
is to use encrypted DNS for example if

830
00:39:36,599 --> 00:39:40,950
you set up a tea house TRS connection

831
00:39:39,060 --> 00:39:43,650
between you and recursive resolvers and

832
00:39:40,950 --> 00:39:46,109
you can somehow use the certificate to

833
00:39:43,650 --> 00:39:47,910
verify ok this turns out to be the right

834
00:39:46,109 --> 00:39:50,940
recursive resolver what this turns out

835
00:39:47,910 --> 00:39:53,819
to be something I have no idea about so

836
00:39:50,940 --> 00:39:56,430
we we know there are some very very good

837
00:39:53,820 --> 00:39:58,050
very interesting RFC's working on this

838
00:39:56,430 --> 00:40:00,720
direction and we believe this is right

839
00:39:58,050 --> 00:40:02,550
way to go to and in the meantime we also

840
00:40:00,720 --> 00:40:04,740
provide this online checking torso even

841
00:40:02,550 --> 00:40:07,170
without encryption if you go to our

842
00:40:04,740 --> 00:40:09,089
website you can clearly see who is the

843
00:40:07,170 --> 00:40:12,630
real TS recursive resolver so you are

844
00:40:09,090 --> 00:40:14,640
using and to conclude we to the first

845
00:40:12,630 --> 00:40:17,310
large-scale measurement and to in the

846
00:40:14,640 --> 00:40:19,890
measurement on this issue of the s

847
00:40:17,310 --> 00:40:23,460
interception based on 32 alternative

848
00:40:19,890 --> 00:40:26,089
resolving and we have some interesting

849
00:40:23,460 --> 00:40:29,940
findings for example we found there are

850
00:40:26,089 --> 00:40:32,070
259 s doing this and if you if you are

851
00:40:29,940 --> 00:40:34,349
in China and you try to use coupons

852
00:40:32,070 --> 00:40:35,700
publicly s should be really careful

853
00:40:34,349 --> 00:40:38,730
about that and then there are some

854
00:40:35,700 --> 00:40:40,799
security concerns and finally we think

855
00:40:38,730 --> 00:40:42,900
there are some medications and we also

856
00:40:40,800 --> 00:40:44,580
propose online checking tor and in the

857
00:40:42,900 --> 00:40:47,880
end we should we think this issue should

858
00:40:44,580 --> 00:40:50,490
be I mean address that by the efforts of

859
00:40:47,880 --> 00:40:52,380
the community so we have more details in

860
00:40:50,490 --> 00:40:54,629
our paper which was published in unique

861
00:40:52,380 --> 00:40:57,060
security last year and here are some my

862
00:40:54,630 --> 00:41:00,330
personal informations if you want to

863
00:40:57,060 --> 00:41:02,310
send questions for discussions with me

864
00:41:00,330 --> 00:41:05,390
and if we saw the others feel free to do

865
00:41:02,310 --> 00:41:05,390
so thank you so much

866
00:41:09,640 --> 00:41:19,730
if time again for one quick question

867
00:41:12,670 --> 00:41:25,460
it's going up to the mic I'm sorry only

868
00:41:19,730 --> 00:41:30,440
only one I'm sorry for him by Bosco

869
00:41:25,460 --> 00:41:34,250
vodka in your measurement did you refer

870
00:41:30,440 --> 00:41:38,390
to mobile networks or fixed networks it

871
00:41:34,250 --> 00:41:41,300
is a case of mobile networks did you

872
00:41:38,390 --> 00:41:44,598
consider a local offload or did you

873
00:41:41,300 --> 00:41:48,500
consider internet vide invert it is sold

874
00:41:44,599 --> 00:41:50,359
through an operator network so so

875
00:41:48,500 --> 00:41:53,720
actually you have two platforms for the

876
00:41:50,359 --> 00:41:59,058
second one we the one with security

877
00:41:53,720 --> 00:42:01,459
software that is mobile network so so

878
00:41:59,059 --> 00:42:04,550
for the details of the network operators

879
00:42:01,460 --> 00:42:06,530
I I need to check the papers and was

880
00:42:04,550 --> 00:42:08,329
always the students but I think we can't

881
00:42:06,530 --> 00:42:10,250
discuss later we have the details in the

882
00:42:08,329 --> 00:42:12,190
paper yes I'm asking you because at

883
00:42:10,250 --> 00:42:15,079
least in the context is a mobile network

884
00:42:12,190 --> 00:42:17,660
the creation of the internet PDN which I

885
00:42:15,079 --> 00:42:20,540
assume that it is the one on which are

886
00:42:17,660 --> 00:42:23,839
operating directly provides you is a DNS

887
00:42:20,540 --> 00:42:29,000
solver and virtually ways the

888
00:42:23,839 --> 00:42:29,820
functionality is not afraid okay all

889
00:42:29,000 --> 00:42:47,820
right let's say the

890
00:42:29,820 --> 00:42:50,580
here again all right so the next talk

891
00:42:47,820 --> 00:42:52,980
will be on oblivious DNS given by Paul

892
00:42:50,580 --> 00:42:54,450
Schmidt who was an associate research

893
00:42:52,980 --> 00:42:56,040
scholar at the Center for information

894
00:42:54,450 --> 00:42:59,100
technology policy at Princeton

895
00:42:56,040 --> 00:43:09,210
University so let's give him a round of

896
00:42:59,100 --> 00:43:11,310
applause get started thank you so this

897
00:43:09,210 --> 00:43:14,130
is work where where this was actually

898
00:43:11,310 --> 00:43:18,420
presented at Pets symposium last week in

899
00:43:14,130 --> 00:43:20,490
Stockholm so in the interest of time

900
00:43:18,420 --> 00:43:22,470
I've got matching slides as the previous

901
00:43:20,490 --> 00:43:25,020
talk so I'm just going to sort of jump

902
00:43:22,470 --> 00:43:27,180
through this very quickly what we're

903
00:43:25,020 --> 00:43:29,430
looking at with with conventional DNS is

904
00:43:27,180 --> 00:43:31,980
you issue this query and you're sending

905
00:43:29,430 --> 00:43:34,140
it typically to your ISP which is

906
00:43:31,980 --> 00:43:35,730
running a recursive resolver and then it

907
00:43:34,140 --> 00:43:39,299
goes out to the the rest of the DNS

908
00:43:35,730 --> 00:43:41,580
hierarchy in the world and so the the

909
00:43:39,300 --> 00:43:44,420
problem with that is that the recursive

910
00:43:41,580 --> 00:43:47,640
DNS resolver has all kinds of insight

911
00:43:44,420 --> 00:43:49,140
that they can use to see both your

912
00:43:47,640 --> 00:43:52,109
identity in the form of your IP address

913
00:43:49,140 --> 00:43:54,330
and basically all of your your actions

914
00:43:52,110 --> 00:43:56,190
on the internet so you can easily put

915
00:43:54,330 --> 00:43:57,660
together a database of users and what

916
00:43:56,190 --> 00:43:59,160
they're doing like one users going to

917
00:43:57,660 --> 00:44:02,129
Google and Amazon and others going to

918
00:43:59,160 --> 00:44:04,140
Bing they can also see what types of

919
00:44:02,130 --> 00:44:07,130
devices you have on your network

920
00:44:04,140 --> 00:44:09,540
and so because of that these these

921
00:44:07,130 --> 00:44:11,400
recursive resolvers can be the targets

922
00:44:09,540 --> 00:44:12,990
for data requests so an oppressive

923
00:44:11,400 --> 00:44:15,750
regime can simply say hey you need to

924
00:44:12,990 --> 00:44:17,580
hand over all of your DNS logs and so

925
00:44:15,750 --> 00:44:19,740
it's this dangerous position where we're

926
00:44:17,580 --> 00:44:21,330
sort of trusting these ISPs or any

927
00:44:19,740 --> 00:44:24,359
recursive resolver to hold all of this

928
00:44:21,330 --> 00:44:28,680
information there are these cloud

929
00:44:24,360 --> 00:44:31,620
services Google quad nine CloudFlare

930
00:44:28,680 --> 00:44:34,080
that are offering recursive resolvers

931
00:44:31,620 --> 00:44:36,120
openly and they say you know obviously

932
00:44:34,080 --> 00:44:38,490
they're not going to keep logs which is

933
00:44:36,120 --> 00:44:40,109
likely true there's too much data it's

934
00:44:38,490 --> 00:44:42,899
actually sort of stored this kind of

935
00:44:40,110 --> 00:44:44,190
thing but it doesn't actually solve the

936
00:44:42,900 --> 00:44:46,200
problem

937
00:44:44,190 --> 00:44:48,029
there they're promising to throw things

938
00:44:46,200 --> 00:44:49,558
away it doesn't fix anything we're still

939
00:44:48,029 --> 00:44:52,799
trusting them we're just shifting trust

940
00:44:49,559 --> 00:44:54,450
from our ISPs to these resolvers and so

941
00:44:52,799 --> 00:44:56,910
that you know that's fundamentally

942
00:44:54,450 --> 00:44:59,308
there's still a problem there you may

943
00:44:56,910 --> 00:45:02,609
have heard of other DNS privacy focused

944
00:44:59,309 --> 00:45:04,319
work like DNS over TLS or HTTPS

945
00:45:02,609 --> 00:45:06,109
that's just encrypting the transport so

946
00:45:04,319 --> 00:45:07,890
that's going to fix things like

947
00:45:06,109 --> 00:45:09,479
eavesdroppers between you and the

948
00:45:07,890 --> 00:45:11,549
resolvers but their resolve are still

949
00:45:09,479 --> 00:45:14,549
gets to see all of your queries and your

950
00:45:11,549 --> 00:45:16,619
identity queue minimization it hides

951
00:45:14,549 --> 00:45:19,380
things from the the rest of the DNS

952
00:45:16,619 --> 00:45:22,049
hierarchy but it doesn't solve the

953
00:45:19,380 --> 00:45:23,729
fundamental problem here and so what

954
00:45:22,049 --> 00:45:25,710
we've done is we've designed the system

955
00:45:23,729 --> 00:45:28,439
that we call oblivious DNS which

956
00:45:25,710 --> 00:45:30,630
essentially separates the user identity

957
00:45:28,440 --> 00:45:34,200
from the queries at the recursive

958
00:45:30,630 --> 00:45:35,369
resolver we built this with requirements

959
00:45:34,200 --> 00:45:37,680
that we had to be compatible with

960
00:45:35,369 --> 00:45:41,910
existing infrastructure it's very hard

961
00:45:37,680 --> 00:45:44,509
to change DNS software on Thor taters or

962
00:45:41,910 --> 00:45:47,249
at recursive servers it's a really old

963
00:45:44,509 --> 00:45:49,140
ecosystem it's just not simple to sort

964
00:45:47,249 --> 00:45:51,629
of throw things out and build a new

965
00:45:49,140 --> 00:45:53,910
protocol altogether we also had to

966
00:45:51,630 --> 00:45:56,640
minimize overhead because DNS underpins

967
00:45:53,910 --> 00:46:00,149
basically all web traffic so what we did

968
00:45:56,640 --> 00:46:02,848
was we made a couple changes the first

969
00:46:00,150 --> 00:46:05,519
was we modified the stub stubs normally

970
00:46:02,849 --> 00:46:08,700
operate as lightweight processes on your

971
00:46:05,519 --> 00:46:10,649
OS they take care of DNS resolution for

972
00:46:08,700 --> 00:46:15,718
the applications on your on your machine

973
00:46:10,650 --> 00:46:17,789
and what we did was we use AES

974
00:46:15,719 --> 00:46:19,950
symmetric keys that we generate on the

975
00:46:17,789 --> 00:46:25,710
fly and we encrypt your query to a

976
00:46:19,950 --> 00:46:28,019
ciphertext we then append a a domain

977
00:46:25,710 --> 00:46:32,039
that we own something like imagine we

978
00:46:28,019 --> 00:46:35,819
own that the TLD Oh DNS so we append the

979
00:46:32,039 --> 00:46:37,140
this clear text domain which means the

980
00:46:35,819 --> 00:46:38,460
recursive servers not going to be able

981
00:46:37,140 --> 00:46:41,038
to understand your query

982
00:46:38,460 --> 00:46:43,200
it's just cipher text but it will use

983
00:46:41,039 --> 00:46:45,239
the existing DNS infrastructure to

984
00:46:43,200 --> 00:46:49,078
eventually reach our authoritative that

985
00:46:45,239 --> 00:46:51,119
we own say dot Oh DNS at that point

986
00:46:49,079 --> 00:46:53,549
we've got this Oh DNS authoritative

987
00:46:51,119 --> 00:46:55,289
server which is both an authoritative

988
00:46:53,549 --> 00:46:56,579
server and a recursive server

989
00:46:55,289 --> 00:46:58,499
it holds the

990
00:46:56,579 --> 00:47:01,019
public keys and/or the private key to

991
00:46:58,499 --> 00:47:03,479
decrypt the session key session key

992
00:47:01,019 --> 00:47:05,999
decrypt the query it then acts as a

993
00:47:03,479 --> 00:47:07,948
recursive and goes does the entire

994
00:47:05,999 --> 00:47:10,558
process over again going to route TLD

995
00:47:07,949 --> 00:47:15,749
and the actual genuine plaintext

996
00:47:10,559 --> 00:47:18,509
authoritative so this separates the the

997
00:47:15,749 --> 00:47:21,209
client identity because the that is held

998
00:47:18,509 --> 00:47:23,910
at the recursive server that the ISP

999
00:47:21,209 --> 00:47:25,439
recursive and the ODS or thorat ativ

1000
00:47:23,910 --> 00:47:26,999
gets to see the actual query but it

1001
00:47:25,439 --> 00:47:29,189
doesn't get to see the user because

1002
00:47:26,999 --> 00:47:32,428
we're essentially tunneling DNS over DNS

1003
00:47:29,189 --> 00:47:36,328
and we're abusing the existing recursive

1004
00:47:32,429 --> 00:47:38,609
resolvers out there of course we're

1005
00:47:36,329 --> 00:47:41,819
introducing these operations and there's

1006
00:47:38,609 --> 00:47:44,308
going to be some some overhead so what

1007
00:47:41,819 --> 00:47:46,199
we did was we measured this we

1008
00:47:44,309 --> 00:47:48,719
implemented a stub and our Oh DNS

1009
00:47:46,199 --> 00:47:50,189
resolver and go and these tests were

1010
00:47:48,719 --> 00:47:53,069
done on the same machine so there's no

1011
00:47:50,189 --> 00:47:55,288
sort of LAN latency and what we see is

1012
00:47:53,069 --> 00:47:56,759
as expected the symmetric crypto is

1013
00:47:55,289 --> 00:47:58,140
really lightweight you can you can

1014
00:47:56,759 --> 00:47:59,489
generate your keys you can encrypt your

1015
00:47:58,140 --> 00:48:01,019
domain so you can decrypt the domains

1016
00:47:59,489 --> 00:48:18,599
very very quickly

1017
00:48:01,019 --> 00:48:20,578
we used elliptic curve cryptography in

1018
00:48:18,599 --> 00:48:23,269
tech that's going to be much larger than

1019
00:48:20,579 --> 00:48:25,739
you can actually issue in a DNS query

1020
00:48:23,269 --> 00:48:34,348
and so we use this elliptic curve

1021
00:48:25,739 --> 00:48:37,170
cryptography query for doing this we use

1022
00:48:34,349 --> 00:48:39,900
standard libraries so if we imagine if

1023
00:48:37,170 --> 00:48:42,719
we use this and this is on my laptop so

1024
00:48:39,900 --> 00:48:44,219
if we use a server class machine with

1025
00:48:42,719 --> 00:48:49,529
optimized libraries things should work

1026
00:48:44,219 --> 00:48:53,099
better we then fed this fed the Alexa

1027
00:48:49,529 --> 00:48:57,420
top 10 K domains and we see conventional

1028
00:48:53,099 --> 00:48:59,640
DNS outperforms Oh DNS by about 1 to 2

1029
00:48:57,420 --> 00:49:01,439
milliseconds it over although we feel

1030
00:48:59,640 --> 00:49:03,949
like we're not doing too poorly just

1031
00:49:01,439 --> 00:49:06,629
with the standard libraries we're using

1032
00:49:03,949 --> 00:49:08,549
so that's one piece of the latency the

1033
00:49:06,630 --> 00:49:10,260
the other thing that we introduced is

1034
00:49:08,549 --> 00:49:13,020
LAN latency because we're tunneling

1035
00:49:10,260 --> 00:49:15,510
to this ode ENS resolver essentially

1036
00:49:13,020 --> 00:49:17,910
that round-trip time to to that resolver

1037
00:49:15,510 --> 00:49:20,010
is added to every query and so you can

1038
00:49:17,910 --> 00:49:22,109
see this illustrated in this figure

1039
00:49:20,010 --> 00:49:24,660
we've got conventional DNS this is our

1040
00:49:22,110 --> 00:49:28,080
client was in New Jersey and you can see

1041
00:49:24,660 --> 00:49:31,529
cloud players doing quite well you've

1042
00:49:28,080 --> 00:49:34,259
got Google and quad nine are the other

1043
00:49:31,530 --> 00:49:36,720
solid lines and then we we used OD NS

1044
00:49:34,260 --> 00:49:38,220
resolvers one was in New York City which

1045
00:49:36,720 --> 00:49:40,819
is about 4 and 1/2 milliseconds away

1046
00:49:38,220 --> 00:49:43,230
from us and the other was in Georgia

1047
00:49:40,820 --> 00:49:45,420
which is about 19 milliseconds away and

1048
00:49:43,230 --> 00:49:48,450
what happens is basically that our TT is

1049
00:49:45,420 --> 00:49:51,240
just appended to all queries so this

1050
00:49:48,450 --> 00:49:53,040
obviously motivates some kind of we need

1051
00:49:51,240 --> 00:49:54,509
a widespread deployment of OD NS

1052
00:49:53,040 --> 00:49:56,779
resolvers you can't just have a single

1053
00:49:54,510 --> 00:50:00,510
DNS resolver out there in the world

1054
00:49:56,780 --> 00:50:02,190
because you introduced a huge amount of

1055
00:50:00,510 --> 00:50:04,830
latency for a large number of people

1056
00:50:02,190 --> 00:50:07,140
so we argue for widespread anycast

1057
00:50:04,830 --> 00:50:11,610
employment in order to sort of get

1058
00:50:07,140 --> 00:50:13,049
nearby because we're using anycast this

1059
00:50:11,610 --> 00:50:15,180
introduces a problem because we're using

1060
00:50:13,050 --> 00:50:18,410
this public key crypto to decrypt the

1061
00:50:15,180 --> 00:50:21,180
queries or decrypt the session keys and

1062
00:50:18,410 --> 00:50:23,339
we can't just hand out the same public

1063
00:50:21,180 --> 00:50:26,370
key to all servers on any caste that

1064
00:50:23,340 --> 00:50:29,370
would be incredibly unwise and so what

1065
00:50:26,370 --> 00:50:32,339
we do is we we have a special request

1066
00:50:29,370 --> 00:50:34,410
that is sent on that anycast address and

1067
00:50:32,340 --> 00:50:37,320
at that point the OD NS resolver that

1068
00:50:34,410 --> 00:50:40,310
your nearest according to bgp will

1069
00:50:37,320 --> 00:50:43,530
respond with its name which is you know

1070
00:50:40,310 --> 00:50:47,400
us one dot ODS something like that and

1071
00:50:43,530 --> 00:50:49,020
it sends back a it's public key at that

1072
00:50:47,400 --> 00:50:50,460
point your client can do this

1073
00:50:49,020 --> 00:50:52,950
you know once a day once an hour

1074
00:50:50,460 --> 00:50:55,410
whatever in order to find the nearest

1075
00:50:52,950 --> 00:50:57,419
server and then use that domain

1076
00:50:55,410 --> 00:50:59,220
specifically to append all queries in

1077
00:50:57,420 --> 00:51:03,360
the future and you'll know the correct

1078
00:50:59,220 --> 00:51:05,189
public key to use so that's all fine and

1079
00:51:03,360 --> 00:51:07,110
good but what happens when you actually

1080
00:51:05,190 --> 00:51:09,120
use this on the internet and web page

1081
00:51:07,110 --> 00:51:14,310
load time is the metric we decided to

1082
00:51:09,120 --> 00:51:17,460
look at here we use 38 op alexa alexa

1083
00:51:14,310 --> 00:51:19,950
top 30 web sites and loaded them using

1084
00:51:17,460 --> 00:51:22,650
both conventional dns using the

1085
00:51:19,950 --> 00:51:23,700
princeton resolver and the OD NS

1086
00:51:22,650 --> 00:51:28,049
resolver that we had said

1087
00:51:23,700 --> 00:51:31,140
you can see a few of the right-hand bars

1088
00:51:28,049 --> 00:51:33,630
for each is is OD NS you can see for a

1089
00:51:31,140 --> 00:51:37,020
few pages were were decent amount slower

1090
00:51:33,630 --> 00:51:39,150
so Craigslist Instagram Facebook those

1091
00:51:37,020 --> 00:51:41,339
mostly things that had a lot of little

1092
00:51:39,150 --> 00:51:44,369
objects are what we are a little bit

1093
00:51:41,339 --> 00:51:47,369
slower on but overall were performing

1094
00:51:44,369 --> 00:51:49,589
pretty closely there was one that was

1095
00:51:47,369 --> 00:51:52,500
very odd live.com it turns out that's

1096
00:51:49,589 --> 00:51:56,430
because we were directed to entirely

1097
00:51:52,500 --> 00:51:59,069
different CDN and in the ODN s case we

1098
00:51:56,430 --> 00:52:02,430
were we had a single giant javascript

1099
00:51:59,069 --> 00:52:03,660
bundle and the traditional resolver went

1100
00:52:02,430 --> 00:52:07,049
to a CDN where there are lots and lots

1101
00:52:03,660 --> 00:52:09,720
of little javascript objects to download

1102
00:52:07,049 --> 00:52:11,730
so that was a little bit slower the

1103
00:52:09,720 --> 00:52:13,709
other one that we were curious about is

1104
00:52:11,730 --> 00:52:17,190
reddit in new york times how could we

1105
00:52:13,710 --> 00:52:19,740
possibly be faster than the conventional

1106
00:52:17,190 --> 00:52:22,020
dns in those cases because we are

1107
00:52:19,740 --> 00:52:23,520
introducing this latency and it turns

1108
00:52:22,020 --> 00:52:26,220
out if you look at the time to first

1109
00:52:23,520 --> 00:52:26,819
byte for those sites it's it's it starts

1110
00:52:26,220 --> 00:52:30,089
to make sense

1111
00:52:26,819 --> 00:52:32,299
essentially we were directed to CBN's

1112
00:52:30,089 --> 00:52:35,819
that were closer we just happened to be

1113
00:52:32,299 --> 00:52:38,190
our DNS resolver directed directed us to

1114
00:52:35,819 --> 00:52:40,500
a more optimal CDN for us rather than

1115
00:52:38,190 --> 00:52:42,960
the princeton resolver so this really

1116
00:52:40,500 --> 00:52:46,109
argues for again having this widespread

1117
00:52:42,960 --> 00:52:48,359
anycast network of ODMs or solvers

1118
00:52:46,109 --> 00:52:52,770
because you need to be directed to you

1119
00:52:48,359 --> 00:52:53,910
objects that are near you of course when

1120
00:52:52,770 --> 00:52:55,259
we do this when we're sending these

1121
00:52:53,910 --> 00:52:59,098
cipher text queries we're essentially

1122
00:52:55,260 --> 00:53:01,589
ruining the caches of existing recursive

1123
00:52:59,099 --> 00:53:04,109
resolvers and they're not going to like

1124
00:53:01,589 --> 00:53:05,578
that so we wanted to understand what

1125
00:53:04,109 --> 00:53:08,279
this would look like in terms of traffic

1126
00:53:05,579 --> 00:53:11,190
so we took a trace of around 8 million

1127
00:53:08,280 --> 00:53:13,079
queries and simulated users as we're

1128
00:53:11,190 --> 00:53:15,780
turning up and down the the percent of

1129
00:53:13,079 --> 00:53:17,430
users that are using au dns and you can

1130
00:53:15,780 --> 00:53:19,799
see when you have zero percent of ODS

1131
00:53:17,430 --> 00:53:22,379
users so the cache misses that the

1132
00:53:19,799 --> 00:53:24,210
recursive are relatively small as you

1133
00:53:22,380 --> 00:53:27,540
increase the percent that's obviously

1134
00:53:24,210 --> 00:53:30,210
growing however if you implement caching

1135
00:53:27,540 --> 00:53:32,270
at the stub which we do we actually

1136
00:53:30,210 --> 00:53:34,619
reduce the overall percentage of traffic

1137
00:53:32,270 --> 00:53:35,400
we're not inventing the wheel here there

1138
00:53:34,619 --> 00:53:37,230
are some stubs

1139
00:53:35,400 --> 00:53:40,500
I think windows stub actually

1140
00:53:37,230 --> 00:53:44,310
she's right now but not every every stub

1141
00:53:40,500 --> 00:53:45,900
does so just doing that actually helps

1142
00:53:44,310 --> 00:53:47,730
quite a bit even if you're cashing just

1143
00:53:45,900 --> 00:53:49,890
a single user you can get quite a

1144
00:53:47,730 --> 00:53:52,859
benefit so overall we don't think we're

1145
00:53:49,890 --> 00:53:54,690
introducing too much traffic we also

1146
00:53:52,859 --> 00:53:57,540
were worried about undesirable cash

1147
00:53:54,690 --> 00:53:59,880
entries so we set our responses with a

1148
00:53:57,540 --> 00:54:00,840
TTL zero which should mean do not cash

1149
00:53:59,880 --> 00:54:03,540
this

1150
00:54:00,840 --> 00:54:06,030
however some resolvers out there ignore

1151
00:54:03,540 --> 00:54:07,560
that value entirely some actually treat

1152
00:54:06,030 --> 00:54:11,100
Xero as a special value where they

1153
00:54:07,560 --> 00:54:14,070
permanently cash it and so we had to

1154
00:54:11,100 --> 00:54:16,710
measure this and try to understand it we

1155
00:54:14,070 --> 00:54:18,630
did the same same set of simulations

1156
00:54:16,710 --> 00:54:21,300
with where we were varying the percent

1157
00:54:18,630 --> 00:54:23,970
of ODMs users and then we varied the the

1158
00:54:21,300 --> 00:54:25,260
size of the cash at the recursive and

1159
00:54:23,970 --> 00:54:27,020
you can see if you have a very small

1160
00:54:25,260 --> 00:54:30,300
cash something like a thousand entries

1161
00:54:27,020 --> 00:54:32,970
odine s is going to be painful we're

1162
00:54:30,300 --> 00:54:35,250
introducing something like 15% of churn

1163
00:54:32,970 --> 00:54:37,919
in turn and entering these ciphertexts

1164
00:54:35,250 --> 00:54:40,680
queries into the cash which is not ideal

1165
00:54:37,920 --> 00:54:42,750
but really in reality recursive

1166
00:54:40,680 --> 00:54:45,240
resolvers have much larger caches than a

1167
00:54:42,750 --> 00:54:48,630
thousand and overall we we don't see it

1168
00:54:45,240 --> 00:54:51,720
it's not that bad so just to quickly

1169
00:54:48,630 --> 00:54:54,210
wrap up there are other things in the

1170
00:54:51,720 --> 00:54:56,939
full paper that we talked about we deal

1171
00:54:54,210 --> 00:54:59,010
with ET NS 0 client subnet which exposes

1172
00:54:56,940 --> 00:55:02,130
some of your IP address your your client

1173
00:54:59,010 --> 00:55:04,740
identity to the the rest to the OD NS

1174
00:55:02,130 --> 00:55:07,800
resolver we deal with queue name lengths

1175
00:55:04,740 --> 00:55:11,790
with the very limited space and then the

1176
00:55:07,800 --> 00:55:13,850
encoding that is used and then where do

1177
00:55:11,790 --> 00:55:16,560
we go with this we're thinking about

1178
00:55:13,850 --> 00:55:18,750
policy based routing where maybe users

1179
00:55:16,560 --> 00:55:21,240
might be interested in selecting Oh DNS

1180
00:55:18,750 --> 00:55:25,109
resolvers based on sort of location or

1181
00:55:21,240 --> 00:55:28,529
SPE or maybe they can choose to say us

1182
00:55:25,109 --> 00:55:31,440
dot Oh DNS to avoid certain locations

1183
00:55:28,530 --> 00:55:34,369
around the world so with that I'd be

1184
00:55:31,440 --> 00:55:34,369
happy to take any questions

1185
00:55:38,210 --> 00:55:51,690
any questions it seems there's a

1186
00:55:48,750 --> 00:55:53,310
potential issue here in that deployment

1187
00:55:51,690 --> 00:55:55,800
can be subverted if I was an ISP that

1188
00:55:53,310 --> 00:55:57,299
wanted subvert deployment of this and to

1189
00:55:55,800 --> 00:56:02,490
be clear I'm not

1190
00:55:57,300 --> 00:56:04,590
I could implement my recursive resolver

1191
00:56:02,490 --> 00:56:08,490
that advertised to transparently forward

1192
00:56:04,590 --> 00:56:10,800
Oh DNS queries which then subverts the

1193
00:56:08,490 --> 00:56:12,779
the whole purpose of not not putting the

1194
00:56:10,800 --> 00:56:14,520
OH DNS infrastructure in the position of

1195
00:56:12,780 --> 00:56:17,600
having to be the the third party that

1196
00:56:14,520 --> 00:56:19,770
the user is transferred their trust to I

1197
00:56:17,600 --> 00:56:21,750
think there's maybe a way to address

1198
00:56:19,770 --> 00:56:25,860
that and design if you have space to do

1199
00:56:21,750 --> 00:56:30,690
it but you might not have space yeah

1200
00:56:25,860 --> 00:56:32,220
that's a good question you there is the

1201
00:56:30,690 --> 00:56:34,290
the sort of issue that that we

1202
00:56:32,220 --> 00:56:36,629
essentially need need to count on the

1203
00:56:34,290 --> 00:56:39,540
fact that those who are separated that

1204
00:56:36,630 --> 00:56:46,080
the recursive and the DNS resolvers are

1205
00:56:39,540 --> 00:56:47,460
separate which in practice is yeah but

1206
00:56:46,080 --> 00:56:55,650
there's at least one recursive layer

1207
00:56:47,460 --> 00:56:57,510
that exists exactly and exactly yeah all

1208
00:56:55,650 --> 00:56:59,440
right if there are no other questions

1209
00:56:57,510 --> 00:57:06,239
let's thank the speaker one more time

1210
00:56:59,440 --> 00:57:06,239
[Applause]

1211
00:57:32,520 --> 00:57:36,090
just an early right

1212
00:57:53,920 --> 00:57:58,330
we's damn right I can go with movies

1213
01:00:18,090 --> 01:00:42,040
like all right thank you this is your

1214
01:00:22,480 --> 01:00:44,200
adapter okay all right sorry everyone

1215
01:00:42,040 --> 01:00:48,759
thank you for being with us so the last

1216
01:00:44,200 --> 01:00:50,740
presentation is on some costs of DNS DNS

1217
01:00:48,760 --> 01:00:54,850
regellius in DNS or HTTP for the modern

1218
01:00:50,740 --> 01:00:55,959
web given by Austin please let's give

1219
01:00:54,850 --> 01:01:03,160
him a round of applause before he gets

1220
01:00:55,960 --> 01:01:05,640
going all right thank you

1221
01:01:03,160 --> 01:01:06,850
[Music]

1222
01:01:05,640 --> 01:01:09,460
yeah

1223
01:01:06,850 --> 01:01:12,370
so DNS privacy's becomes a significant

1224
01:01:09,460 --> 01:01:14,700
concern we know that on path network

1225
01:01:12,370 --> 01:01:18,279
observers can't spy on and tamper with

1226
01:01:14,700 --> 01:01:20,169
DNS traffic this is the DNS that you all

1227
01:01:18,280 --> 01:01:21,400
know and love doe 53 let's all be

1228
01:01:20,170 --> 01:01:24,220
referring to it for the rest of the talk

1229
01:01:21,400 --> 01:01:26,500
and so two protocols been proposed to

1230
01:01:24,220 --> 01:01:29,490
encrypt DNS traffic there is DNS over

1231
01:01:26,500 --> 01:01:33,130
TLS or dot as well for us the talk

1232
01:01:29,490 --> 01:01:37,589
defined in RFC 75 8 and then there's DNS

1233
01:01:33,130 --> 01:01:40,330
over HTTP or doe and defined an RC 844

1234
01:01:37,590 --> 01:01:42,040
that's the next line so the

1235
01:01:40,330 --> 01:01:44,440
contributions of our work we for an

1236
01:01:42,040 --> 01:01:46,930
extensive performance study of doe 53

1237
01:01:44,440 --> 01:01:52,210
and doe and we give some general

1238
01:01:46,930 --> 01:01:54,580
insights to optimize DNS performance so

1239
01:01:52,210 --> 01:01:57,970
again we really want to understand how

1240
01:01:54,580 --> 01:01:59,529
doe 53 dot and Oh effect to the end user

1241
01:01:57,970 --> 01:02:03,100
experience and there are a couple of

1242
01:01:59,530 --> 01:02:03,340
metrics that we measure in order to give

1243
01:02:03,100 --> 01:02:06,400
us

1244
01:02:03,340 --> 01:02:09,220
understanding so first we measure quarry

1245
01:02:06,400 --> 01:02:11,920
response times we wanted to reproduce

1246
01:02:09,220 --> 01:02:13,330
Mozilla's findings so well you don't

1247
01:02:11,920 --> 01:02:16,270
know Mozilla did a couple of studies

1248
01:02:13,330 --> 01:02:18,520
where they measured doe query response

1249
01:02:16,270 --> 01:02:22,870
times they also measured the effect of

1250
01:02:18,520 --> 01:02:24,640
ECS on user performance things like that

1251
01:02:22,870 --> 01:02:28,060
we wanted to see we could reproduce the

1252
01:02:24,640 --> 01:02:30,310
results on doe query response times as

1253
01:02:28,060 --> 01:02:31,690
your page load times and again this is

1254
01:02:30,310 --> 01:02:33,190
what we think are really important to

1255
01:02:31,690 --> 01:02:36,760
users they want to see if they can load

1256
01:02:33,190 --> 01:02:38,770
new york times and how doe might affect

1257
01:02:36,760 --> 01:02:39,970
those page load times and we also wanted

1258
01:02:38,770 --> 01:02:41,770
to see if you've changed network

1259
01:02:39,970 --> 01:02:45,310
conditions things like additional

1260
01:02:41,770 --> 01:02:49,300
latency or loss how that affects your

1261
01:02:45,310 --> 01:02:51,850
user experience okay so this is kind of

1262
01:02:49,300 --> 01:02:53,470
a general overview of our set up very

1263
01:02:51,850 --> 01:02:56,259
simplified but the general idea is that

1264
01:02:53,470 --> 01:02:59,290
we have a client which is at Princeton

1265
01:02:56,260 --> 01:03:02,980
University we will perform traffic

1266
01:02:59,290 --> 01:03:05,290
shaping so an emulated 4G network lossy

1267
01:03:02,980 --> 01:03:07,030
4G and 3G and again these are not

1268
01:03:05,290 --> 01:03:09,300
actually connecting to mobile networks

1269
01:03:07,030 --> 01:03:12,820
these are just emulated conditions and

1270
01:03:09,300 --> 01:03:15,340
your performing queries to recurse

1271
01:03:12,820 --> 01:03:17,830
resolvers at and Princeton vault

1272
01:03:15,340 --> 01:03:21,310
Princeton's default resolver CloudFlare

1273
01:03:17,830 --> 01:03:23,529
Google quad 9 for each unique domain

1274
01:03:21,310 --> 01:03:26,080
name that is embedded in a web page for

1275
01:03:23,530 --> 01:03:27,940
images links things like that and then

1276
01:03:26,080 --> 01:03:30,819
you're actually in steps 3 & 4 going to

1277
01:03:27,940 --> 01:03:34,090
load content from these web pages that

1278
01:03:30,820 --> 01:03:36,070
you just perform DNS queries for and we

1279
01:03:34,090 --> 01:03:39,670
use the Trank of top list which I

1280
01:03:36,070 --> 01:03:42,340
believe was a presented and guess s it's

1281
01:03:39,670 --> 01:03:44,440
just taking basically Alexa other top

1282
01:03:42,340 --> 01:03:47,500
lists averaging it over a period of time

1283
01:03:44,440 --> 01:03:48,910
so you can think of this as a list of

1284
01:03:47,500 --> 01:03:51,910
just top websites and want to measure

1285
01:03:48,910 --> 01:03:55,990
again things like New York Times other

1286
01:03:51,910 --> 01:03:58,060
stuff so these are response times from

1287
01:03:55,990 --> 01:03:59,500
cloudburst resolver on Princeton Network

1288
01:03:58,060 --> 01:04:02,170
you can see in the legend at the bottom

1289
01:03:59,500 --> 01:04:05,080
in blue we have of CloudFlare settings

1290
01:04:02,170 --> 01:04:07,480
so CloudFlare dot Dovid III and doe and

1291
01:04:05,080 --> 01:04:09,520
then by default Doe 53 i'm referring to

1292
01:04:07,480 --> 01:04:13,480
the university resolver at Princeton

1293
01:04:09,520 --> 01:04:16,450
which only supports traditional doe 53

1294
01:04:13,480 --> 01:04:18,609
so if you go ahead and hit next you can

1295
01:04:16,450 --> 01:04:21,430
see some interesting characteristics one

1296
01:04:18,609 --> 01:04:24,460
is that for about 50% of queries you can

1297
01:04:21,430 --> 01:04:27,460
see that clatters dough actually takes

1298
01:04:24,460 --> 01:04:29,619
over CloudFlare dot and it's faster and

1299
01:04:27,460 --> 01:04:31,390
if you could hit next again you can also

1300
01:04:29,619 --> 01:04:34,420
see it's kind of hard to see right there

1301
01:04:31,390 --> 01:04:36,220
but actually at the very tail of query

1302
01:04:34,420 --> 01:04:39,700
response times that quite a flared dough

1303
01:04:36,220 --> 01:04:41,740
not only over takes its own dovid III

1304
01:04:39,700 --> 01:04:44,529
implementation but also the university's

1305
01:04:41,740 --> 01:04:47,529
dovid III resolver which we thought was

1306
01:04:44,530 --> 01:04:49,480
very interesting to see and you see

1307
01:04:47,530 --> 01:04:51,970
similar characteristics with google's

1308
01:04:49,480 --> 01:04:55,680
resolver that if you could hit next

1309
01:04:51,970 --> 01:05:00,730
please and that for about 20% of queries

1310
01:04:55,680 --> 01:05:03,098
again Doe seems to outperform dot and

1311
01:05:00,730 --> 01:05:06,070
you can see a similar phenomenon as you

1312
01:05:03,099 --> 01:05:08,170
saw with CloudFlare that dough is once

1313
01:05:06,070 --> 01:05:11,460
again outperforming dough 53 for the

1314
01:05:08,170 --> 01:05:14,650
very tail of query response times and

1315
01:05:11,460 --> 01:05:16,150
then lastly this is quad nine right so

1316
01:05:14,650 --> 01:05:18,609
you can see at the bottom that this is

1317
01:05:16,150 --> 01:05:20,829
quad nine dot and if you could hit next

1318
01:05:18,609 --> 01:05:23,589
please that for about 90 percent of

1319
01:05:20,829 --> 01:05:26,260
queries that doe is outperforming dot

1320
01:05:23,589 --> 01:05:29,349
and then you can see similar behavior

1321
01:05:26,260 --> 01:05:31,869
once again as with CloudFlare and google

1322
01:05:29,349 --> 01:05:36,369
that for some reason doe is

1323
01:05:31,869 --> 01:05:39,599
outperforming quad nines doe fifty-three

1324
01:05:36,369 --> 01:05:42,250
resolver it does not outperform our

1325
01:05:39,599 --> 01:05:43,630
universities so fifty-three resolver but

1326
01:05:42,250 --> 01:05:45,520
nonetheless you see this kind of similar

1327
01:05:43,630 --> 01:05:47,410
behavior that for some reason doe is

1328
01:05:45,520 --> 01:05:51,400
outperforming don't fifty three for the

1329
01:05:47,410 --> 01:05:53,649
tail of query response times so again

1330
01:05:51,400 --> 01:05:55,390
the takeaway sees baby to be that for

1331
01:05:53,650 --> 01:05:56,920
some reason doe is outperforming doe

1332
01:05:55,390 --> 01:05:59,980
fifty-three for some percentage of

1333
01:05:56,920 --> 01:06:02,020
queries there are multiple reasons we

1334
01:05:59,980 --> 01:06:05,290
think this might be one of which might

1335
01:06:02,020 --> 01:06:07,240
be caching of the dns wire format so for

1336
01:06:05,290 --> 01:06:11,920
example if the recursive resolver

1337
01:06:07,240 --> 01:06:14,649
already has the the answer in its cache

1338
01:06:11,920 --> 01:06:17,040
and maybe the transaction ID is some

1339
01:06:14,650 --> 01:06:19,510
fixed number as it is implemented in

1340
01:06:17,040 --> 01:06:21,060
Firefox's implementation of doe which I

1341
01:06:19,510 --> 01:06:24,220
believe it's set to zero

1342
01:06:21,060 --> 01:06:25,930
maybe they're caching the wire format of

1343
01:06:24,220 --> 01:06:28,029
the DNS response which allows them to

1344
01:06:25,930 --> 01:06:30,069
more quickly send a response back

1345
01:06:28,030 --> 01:06:33,490
instead of having to construct a being

1346
01:06:30,070 --> 01:06:37,270
response each time and this result that

1347
01:06:33,490 --> 01:06:39,279
you know doe is outperforming doe 53 in

1348
01:06:37,270 --> 01:06:43,270
the Taylor query response time seems to

1349
01:06:39,280 --> 01:06:44,860
support Mozilla's findings next we

1350
01:06:43,270 --> 01:06:47,170
wanted to measure page load times which

1351
01:06:44,860 --> 01:06:49,960
again we believe reflects the end user

1352
01:06:47,170 --> 01:06:51,520
experience and for this talk we're only

1353
01:06:49,960 --> 01:06:53,170
going to show page load times for

1354
01:06:51,520 --> 01:06:55,150
CloudFlare but if you look at our full

1355
01:06:53,170 --> 01:06:58,090
paper which we have the archive link for

1356
01:06:55,150 --> 01:07:02,920
at the bottom we also show page load

1357
01:06:58,090 --> 01:07:05,260
times for quad 9 and Google so as

1358
01:07:02,920 --> 01:07:07,480
mentioned before we also wanted to see

1359
01:07:05,260 --> 01:07:09,550
how changing network conditions affects

1360
01:07:07,480 --> 01:07:11,950
the ANU xur experience that affects

1361
01:07:09,550 --> 01:07:13,600
query response times page load times so

1362
01:07:11,950 --> 01:07:16,540
we perform some traffic shaping to

1363
01:07:13,600 --> 01:07:17,830
emulate mobile networks again want to

1364
01:07:16,540 --> 01:07:19,420
state that these are not actually

1365
01:07:17,830 --> 01:07:22,900
connecting to real mobile networks we

1366
01:07:19,420 --> 01:07:25,180
didn't tether a phone and but we wanted

1367
01:07:22,900 --> 01:07:27,100
to see just you know if we could emulate

1368
01:07:25,180 --> 01:07:29,259
network conditions how would these

1369
01:07:27,100 --> 01:07:32,920
protocols perform across different

1370
01:07:29,260 --> 01:07:34,030
recursos so for 4G to emulate that we

1371
01:07:32,920 --> 01:07:35,740
added fifty three point three

1372
01:07:34,030 --> 01:07:40,570
milliseconds of additional latency

1373
01:07:35,740 --> 01:07:42,100
well Sigma J dur 0.5% loss Wasi 4G same

1374
01:07:40,570 --> 01:07:43,810
amount of latency and jitter but now

1375
01:07:42,100 --> 01:07:46,930
we're doing one point five percent loss

1376
01:07:43,810 --> 01:07:49,060
and then lastly with 3G 150 milliseconds

1377
01:07:46,930 --> 01:07:52,660
additional latency eight milliseconds of

1378
01:07:49,060 --> 01:07:54,730
jitter and 2.5% loss this is based on

1379
01:07:52,660 --> 01:07:58,060
data that was provided in a report by

1380
01:07:54,730 --> 01:08:00,670
open signal and again we talked about

1381
01:07:58,060 --> 01:08:04,509
why we chose these networks in the full

1382
01:08:00,670 --> 01:08:08,080
paper so these are page loads when you

1383
01:08:04,510 --> 01:08:12,760
use CloudFlare resolver from Princeton's

1384
01:08:08,080 --> 01:08:14,740
network so you can see the way you can

1385
01:08:12,760 --> 01:08:16,390
read these graphs is that this is taking

1386
01:08:14,740 --> 01:08:19,210
all the page loads that were perform

1387
01:08:16,390 --> 01:08:21,820
using CloudFlare for example dot on the

1388
01:08:19,210 --> 01:08:23,859
Left graph - the page loads that were

1389
01:08:21,819 --> 01:08:26,410
performed using cloud flares Doe 53

1390
01:08:23,859 --> 01:08:28,600
implementation the vertical line is the

1391
01:08:26,410 --> 01:08:30,939
median right so this is the median

1392
01:08:28,600 --> 01:08:33,280
difference between dot and doe 53 in

1393
01:08:30,939 --> 01:08:35,229
terms of page load times the white

1394
01:08:33,279 --> 01:08:38,200
background indicates that this

1395
01:08:35,229 --> 01:08:41,229
difference is between plus or minus 30

1396
01:08:38,200 --> 01:08:43,438
milliseconds right so the kind of key

1397
01:08:41,229 --> 01:08:45,928
takeaway from this slide is that

1398
01:08:43,439 --> 01:08:47,429
if you're using dot or Doh the

1399
01:08:45,929 --> 01:08:50,158
difference in page load times on a

1400
01:08:47,429 --> 01:08:53,699
university network to cloth lawyers for

1401
01:08:50,158 --> 01:08:56,308
cursor is only 30 milliseconds you can

1402
01:08:53,698 --> 01:08:58,438
go to the next line and the picture

1403
01:08:56,309 --> 01:09:01,349
starts to change a little once you move

1404
01:08:58,439 --> 01:09:04,229
to an emulated 4G network you still see

1405
01:09:01,349 --> 01:09:06,479
on the Left plot that dot is performing

1406
01:09:04,229 --> 01:09:10,469
within plus or minus 30 milliseconds in

1407
01:09:06,479 --> 01:09:12,900
page load times compared to doe 53 right

1408
01:09:10,469 --> 01:09:15,839
now if you look at doe this picture

1409
01:09:12,899 --> 01:09:18,658
starts to change right so the background

1410
01:09:15,839 --> 01:09:21,630
indicates that the median difference

1411
01:09:18,658 --> 01:09:23,759
between doe and doe 53 is over 100

1412
01:09:21,630 --> 01:09:27,929
milliseconds right the actual median

1413
01:09:23,759 --> 01:09:31,889
here is about 153 milliseconds so again

1414
01:09:27,929 --> 01:09:34,109
once you go to a emulator 4G network doe

1415
01:09:31,889 --> 01:09:37,919
starts the drop in performance but dot

1416
01:09:34,109 --> 01:09:40,199
stays about the same and again the

1417
01:09:37,919 --> 01:09:42,538
picture changes so now the blue

1418
01:09:40,198 --> 01:09:44,728
background indicates that dot is

1419
01:09:42,538 --> 01:09:48,059
performing actually better than though

1420
01:09:44,729 --> 01:09:49,739
53 when you're on a lossy 4G network

1421
01:09:48,059 --> 01:09:53,400
which is a pretty surprising result

1422
01:09:49,738 --> 01:09:56,549
right and now doe has actually moved

1423
01:09:53,399 --> 01:09:59,938
back to being within plus or 30 plus or

1424
01:09:56,550 --> 01:10:01,050
minus 30 milliseconds from doe 53 so all

1425
01:09:59,939 --> 01:10:03,709
these numbers are starting to change

1426
01:10:01,050 --> 01:10:07,709
around but the picture seems to be that

1427
01:10:03,709 --> 01:10:09,869
across these three networks so far again

1428
01:10:07,709 --> 01:10:12,360
the university network the 4G network

1429
01:10:09,869 --> 01:10:14,598
and the lossy 4G network dot has

1430
01:10:12,360 --> 01:10:20,150
remained either indistinguishable or

1431
01:10:14,599 --> 01:10:23,459
slightly faster than though 53 and now

1432
01:10:20,150 --> 01:10:27,329
this is an emulated 3G network so now

1433
01:10:23,459 --> 01:10:32,188
both dot and doe are over a hundred

1434
01:10:27,329 --> 01:10:34,110
milliseconds slower than doe 53 so again

1435
01:10:32,189 --> 01:10:36,929
to remind you of the conditions for a

1436
01:10:34,110 --> 01:10:38,999
emulated 3G network we added 150

1437
01:10:36,929 --> 01:10:42,689
milliseconds of additional latency 8

1438
01:10:38,999 --> 01:10:44,669
milliseconds of jitter and 2.5% packet

1439
01:10:42,689 --> 01:10:50,159
loss so now the conditions have become

1440
01:10:44,669 --> 01:10:52,289
so dire that both doe and dot are

1441
01:10:50,159 --> 01:10:55,589
significantly slower than though 53 in

1442
01:10:52,289 --> 01:10:55,900
terms of page load times so what is this

1443
01:10:55,590 --> 01:10:57,880
me

1444
01:10:55,900 --> 01:11:02,199
putting this all together it seems to be

1445
01:10:57,880 --> 01:11:04,239
that if you're running DNS over TCP as a

1446
01:11:02,199 --> 01:11:07,928
transport that this can actually help

1447
01:11:04,239 --> 01:11:10,629
page load times we saw that across the

1448
01:11:07,929 --> 01:11:14,949
university network the 4G network lossy

1449
01:11:10,630 --> 01:11:16,870
4G that DNS over TLS was performing

1450
01:11:14,949 --> 01:11:19,059
either indistinguishably and by that I

1451
01:11:16,870 --> 01:11:22,090
mean plus or minus 30 milliseconds in

1452
01:11:19,060 --> 01:11:24,699
terms of page load times or informed

1453
01:11:22,090 --> 01:11:27,400
actually slightly faster than though 53

1454
01:11:24,699 --> 01:11:29,620
and we believe this is because TCP

1455
01:11:27,400 --> 01:11:32,500
packets can be retransmitted as soon as

1456
01:11:29,620 --> 01:11:34,570
two round-trips so as we're tweaking the

1457
01:11:32,500 --> 01:11:36,310
loss more and more DNS packets are

1458
01:11:34,570 --> 01:11:37,960
getting dropped and this means that they

1459
01:11:36,310 --> 01:11:39,670
could be retransmitted faster than

1460
01:11:37,960 --> 01:11:43,060
something that's being defined by a

1461
01:11:39,670 --> 01:11:44,679
time-out perhaps a couple of set on the

1462
01:11:43,060 --> 01:11:48,100
order a couple of seconds for a

1463
01:11:44,679 --> 01:11:52,780
traditional DNS over a traditional DNS

1464
01:11:48,100 --> 01:11:55,120
timeout so this helps dock it's okay

1465
01:11:52,780 --> 01:12:00,370
this helps dutton to perform well on

1466
01:11:55,120 --> 01:12:01,659
lossy networks okay so we think to

1467
01:12:00,370 --> 01:12:04,570
conclude that there are several

1468
01:12:01,659 --> 01:12:07,389
potential improvements for del 53 dot

1469
01:12:04,570 --> 01:12:08,860
and oh you could send what we believe

1470
01:12:07,390 --> 01:12:14,679
are called opportunistic partial

1471
01:12:08,860 --> 01:12:17,110
responses so maybe you say to a recur

1472
01:12:14,679 --> 01:12:19,750
sir here are all the different questions

1473
01:12:17,110 --> 01:12:21,549
I want the answers for and then the

1474
01:12:19,750 --> 01:12:24,040
recur sir as they get authoritative

1475
01:12:21,550 --> 01:12:27,310
answers we'll send them back to the

1476
01:12:24,040 --> 01:12:28,929
client right we also believe wire format

1477
01:12:27,310 --> 01:12:32,620
caching could help as previously

1478
01:12:28,929 --> 01:12:35,199
discussed so in Firefox is doe

1479
01:12:32,620 --> 01:12:37,420
implementation the transaction ID is

1480
01:12:35,199 --> 01:12:40,480
zero by default and so what this means

1481
01:12:37,420 --> 01:12:43,179
is that once an answer is cached on a

1482
01:12:40,480 --> 01:12:45,280
recur sir it knows what the exact format

1483
01:12:43,179 --> 01:12:47,320
of the response is going to be so you

1484
01:12:45,280 --> 01:12:49,780
could simply cache the entire what the

1485
01:12:47,320 --> 01:12:51,460
cache the entire wire format instead of

1486
01:12:49,780 --> 01:12:55,330
having to read the answer from cache

1487
01:12:51,460 --> 01:12:57,489
each time in terms of the DNS cache this

1488
01:12:55,330 --> 01:13:00,969
is could instead be an HTTP cache

1489
01:12:57,489 --> 01:13:03,388
lastly we believe that HTTP to push for

1490
01:13:00,969 --> 01:13:06,460
dokas significantly help performance so

1491
01:13:03,389 --> 01:13:08,139
it should be to push has been talked

1492
01:13:06,460 --> 01:13:09,700
about in the mailing list for doe for

1493
01:13:08,139 --> 01:13:11,490
quite some time but

1494
01:13:09,700 --> 01:13:13,900
this is something that we believe once

1495
01:13:11,490 --> 01:13:16,030
implemented widely could actually

1496
01:13:13,900 --> 01:13:19,540
significantly help doe performance

1497
01:13:16,030 --> 01:13:20,950
because you could push answers to the

1498
01:13:19,540 --> 01:13:23,500
client or the web servers could push

1499
01:13:20,950 --> 01:13:25,179
answers to the client for domain names

1500
01:13:23,500 --> 01:13:29,350
that it already knows the answer for

1501
01:13:25,180 --> 01:13:31,600
that are on the webpage so in conclusion

1502
01:13:29,350 --> 01:13:34,120
we seem to see that dot before it's

1503
01:13:31,600 --> 01:13:37,750
better than dough on average and even

1504
01:13:34,120 --> 01:13:39,460
sometimes better than though 53 but

1505
01:13:37,750 --> 01:13:41,110
nonetheless dough has potential

1506
01:13:39,460 --> 01:13:43,530
again as I previously discussed with

1507
01:13:41,110 --> 01:13:45,849
potential improvements with server push

1508
01:13:43,530 --> 01:13:48,759
dough could actually improve and

1509
01:13:45,850 --> 01:13:50,980
performance quite significantly the

1510
01:13:48,760 --> 01:13:53,380
choice of your cursor and the network

1511
01:13:50,980 --> 01:13:55,660
conditions matter and we believe the

1512
01:13:53,380 --> 01:13:59,440
transport characteristics of TCP should

1513
01:13:55,660 --> 01:14:01,480
be further explored thank you and you

1514
01:13:59,440 --> 01:14:03,669
can check out our full preprint at the

1515
01:14:01,480 --> 01:14:13,269
bottom with the archived fling let's

1516
01:14:03,670 --> 01:14:16,390
thank him I'm curious about if you tried

1517
01:14:13,270 --> 01:14:18,970
multiple UDP retry strategies because

1518
01:14:16,390 --> 01:14:20,260
that that sort of would really heavily

1519
01:14:18,970 --> 01:14:22,060
influence the results I know that the

1520
01:14:20,260 --> 01:14:23,320
Android is older has like a five-second

1521
01:14:22,060 --> 01:14:24,700
UDP retry time all right

1522
01:14:23,320 --> 01:14:27,880
which is basically you're gonna like

1523
01:14:24,700 --> 01:14:30,160
lose any race with with Gio tuh right we

1524
01:14:27,880 --> 01:14:31,480
do not try multiple strategies but we

1525
01:14:30,160 --> 01:14:33,190
think that's definitely something that

1526
01:14:31,480 --> 01:14:35,679
would fit in the future it is documented

1527
01:14:33,190 --> 01:14:37,990
which one you did use in the paper so we

1528
01:14:35,680 --> 01:14:39,970
used to use Debian as our default client

1529
01:14:37,990 --> 01:14:42,160
so I think that a fault timeout with

1530
01:14:39,970 --> 01:14:48,040
that was in resolved comm to make five

1531
01:14:42,160 --> 01:14:51,790
seconds as you said okay thanks mmm hi

1532
01:14:48,040 --> 01:14:53,500
banette from Google Public DNS so thank

1533
01:14:51,790 --> 01:14:55,990
you for doing this research it's good to

1534
01:14:53,500 --> 01:14:58,150
see all the detailed information here

1535
01:14:55,990 --> 01:14:59,710
the one thing as you mentioned in the

1536
01:14:58,150 --> 01:15:01,469
beginning and I'll point out again is

1537
01:14:59,710 --> 01:15:02,620
you've only done this from the

1538
01:15:01,470 --> 01:15:05,140
Princeton's

1539
01:15:02,620 --> 01:15:07,510
University campus in Northeast us right

1540
01:15:05,140 --> 01:15:09,730
correct so it's a heavily connected well

1541
01:15:07,510 --> 01:15:10,840
connected part of the world so the

1542
01:15:09,730 --> 01:15:12,910
results here not going to be

1543
01:15:10,840 --> 01:15:14,590
representative for people who are in

1544
01:15:12,910 --> 01:15:16,750
places where the connectivity is not as

1545
01:15:14,590 --> 01:15:18,280
good right so that's one important point

1546
01:15:16,750 --> 01:15:19,780
so I think the fact that you will share

1547
01:15:18,280 --> 01:15:23,619
the data that will help us get more

1548
01:15:19,780 --> 01:15:25,539
information from other sources

1549
01:15:23,619 --> 01:15:27,728
of the things which I think keeps coming

1550
01:15:25,539 --> 01:15:29,469
up here I want to point out is part of

1551
01:15:27,729 --> 01:15:33,099
the reason doe works better is because

1552
01:15:29,469 --> 01:15:36,999
it has an async API while the d-o-t and

1553
01:15:33,099 --> 01:15:39,849
DNS over 53 don't have that and I'm

1554
01:15:36,999 --> 01:15:42,340
curious if anyone has an async API for

1555
01:15:39,849 --> 01:15:45,280
the traditional DNS transport so we can

1556
01:15:42,340 --> 01:15:47,079
compare that right

1557
01:15:45,280 --> 01:15:48,969
so if actually you could include that

1558
01:15:47,079 --> 01:15:51,369
that would be great then we'll tease

1559
01:15:48,969 --> 01:15:53,229
apart the transport differences versus

1560
01:15:51,369 --> 01:15:55,268
the API differences yeah that's

1561
01:15:53,229 --> 01:15:57,309
something we've actually talked about in

1562
01:15:55,269 --> 01:15:58,959
our next work of doing if trying out

1563
01:15:57,309 --> 01:16:01,539
different asynchronous API is to kind of

1564
01:15:58,959 --> 01:16:02,619
tease that out so as you said that's

1565
01:16:01,539 --> 01:16:04,389
definitely something we want to let's

1566
01:16:02,619 --> 01:16:07,509
make sure you heard that that's get DNS

1567
01:16:04,389 --> 01:16:12,329
API is the asynchronous API for T got

1568
01:16:07,510 --> 01:16:15,090
additional DNS transports okay thank you

1569
01:16:12,329 --> 01:16:17,558
Eric Nygren Akamai also on the

1570
01:16:15,090 --> 01:16:19,989
perspective of only doing that from the

1571
01:16:17,559 --> 01:16:22,059
perspective of a Princeton vantage point

1572
01:16:19,989 --> 01:16:23,799
I think from a what is the impact on

1573
01:16:22,059 --> 01:16:24,669
that page load time performance is

1574
01:16:23,800 --> 01:16:27,669
really not going to be at all

1575
01:16:24,669 --> 01:16:32,379
representative of the impact on CDN on

1576
01:16:27,669 --> 01:16:35,949
CDN mapping because going to a like a

1577
01:16:32,379 --> 01:16:38,199
non ECS CloudFlare resolver from from

1578
01:16:35,949 --> 01:16:39,638
princeton versus going and using local

1579
01:16:38,199 --> 01:16:41,438
Princeton resolver is probably going to

1580
01:16:39,639 --> 01:16:43,149
get you to the same place for CDN just

1581
01:16:41,439 --> 01:16:44,979
given how to connected which is not

1582
01:16:43,149 --> 01:16:47,199
going to be which I mean whereas if

1583
01:16:44,979 --> 01:16:51,309
you're in some part of the world where

1584
01:16:47,199 --> 01:16:55,749
there's a local on that CDN cache that

1585
01:16:51,309 --> 01:16:57,340
may only be accessible via users within

1586
01:16:55,749 --> 01:16:59,019
that local network you're not you're not

1587
01:16:57,340 --> 01:17:00,039
that may have a performance impact on

1588
01:16:59,019 --> 01:17:04,749
page load time you just not gonna

1589
01:17:00,039 --> 01:17:07,599
observe in this case Thank You Giovanni

1590
01:17:04,749 --> 01:17:09,099
and say then glory flying question yeah

1591
01:17:07,599 --> 01:17:11,499
you told before that all the queries you

1592
01:17:09,099 --> 01:17:13,349
made we're like random or unique queries

1593
01:17:11,499 --> 01:17:16,959
is that what you did in two measurements

1594
01:17:13,349 --> 01:17:19,869
what do you mean random do you how you

1595
01:17:16,959 --> 01:17:21,760
handle my ask my question is is there

1596
01:17:19,869 --> 01:17:23,409
any caching involved in this process or

1597
01:17:21,760 --> 01:17:26,110
no we're starting with a clean cache

1598
01:17:23,409 --> 01:17:28,148
each time so our measurement is on a

1599
01:17:26,110 --> 01:17:30,219
docker image and each time we started up

1600
01:17:28,149 --> 01:17:32,229
we're getting a fresh DNS so each query

1601
01:17:30,219 --> 01:17:34,320
names are you sending so these are all

1602
01:17:32,229 --> 01:17:37,290
each time we're making a page load

1603
01:17:34,320 --> 01:17:38,429
we read so I guess this is something I

1604
01:17:37,290 --> 01:17:40,550
should have mentioned in the talk but we

1605
01:17:38,430 --> 01:17:44,820
actually have a separate client which

1606
01:17:40,550 --> 01:17:47,580
for DNS queries we're using dig for DNS

1607
01:17:44,820 --> 01:17:50,490
over port 53 for Don tweezing stubby and

1608
01:17:47,580 --> 01:17:51,720
for doe we're using curl and the reason

1609
01:17:50,490 --> 01:17:54,420
why we did that is we noticed some

1610
01:17:51,720 --> 01:17:56,160
peculiarities in the DNS response times

1611
01:17:54,420 --> 01:17:58,890
and the horrors that we collected to get

1612
01:17:56,160 --> 01:18:00,480
page load times this is something we

1613
01:17:58,890 --> 01:18:02,340
discussed more in the full paper but

1614
01:18:00,480 --> 01:18:07,169
we're starting with a fresh cache each

1615
01:18:02,340 --> 01:18:08,850
time and using again dig curl and stubby

1616
01:18:07,170 --> 01:18:10,680
in order to make these queries we're

1617
01:18:08,850 --> 01:18:12,330
pulling out the domain names that we saw

1618
01:18:10,680 --> 01:18:15,090
in the page loads and making those

1619
01:18:12,330 --> 01:18:17,190
queries separately yeah all right now

1620
01:18:15,090 --> 01:18:18,690
that makes sense if you thought to a

1621
01:18:17,190 --> 01:18:21,330
resolver every operator are you gonna

1622
01:18:18,690 --> 01:18:23,250
see that they have a very high cache hit

1623
01:18:21,330 --> 01:18:25,410
rate so maybe it'd be nice to extend

1624
01:18:23,250 --> 01:18:28,430
your work to Cobra also cases and where

1625
01:18:25,410 --> 01:18:30,780
there's cache it interesting thank you

1626
01:18:28,430 --> 01:18:32,340
yeah I guess you partially answered my

1627
01:18:30,780 --> 01:18:35,160
question already by saying they use curl

1628
01:18:32,340 --> 01:18:39,170
but do you include the connection time

1629
01:18:35,160 --> 01:18:43,019
in your your PC like when there is TCP

1630
01:18:39,170 --> 01:18:46,620
general over TLS and HTTPS no that's not

1631
01:18:43,020 --> 01:18:48,030
in our data all right thank you all

1632
01:18:46,620 --> 01:18:50,849
right let's thank the speaker one last

1633
01:18:48,030 --> 01:18:53,040
time as well allow speakers in this

1634
01:18:50,850 --> 01:18:54,750
particular session now we're going to

1635
01:18:53,040 --> 01:18:58,230
take a break for lunch which is in the

1636
01:18:54,750 --> 01:19:06,530
next room over and we will see you all

1637
01:18:58,230 --> 01:19:06,530
when we return at 12:15 at 1:15

