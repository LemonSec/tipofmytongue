1
00:00:05,020 --> 00:00:09,219
you're probably for coming sorry for the

2
00:00:07,300 --> 00:00:10,600
AV difficulties I guess that's what

3
00:00:09,219 --> 00:00:13,539
happens at the start of the week

4
00:00:10,600 --> 00:00:17,110
unfortunately that means you'll miss out

5
00:00:13,539 --> 00:00:18,880
on all my animations but under the

6
00:00:17,110 --> 00:00:23,439
circumstances we'll make do with the PDF

7
00:00:18,880 --> 00:00:27,009
version my name is Joe Shaw I did my

8
00:00:23,440 --> 00:00:29,980
degree in computer science at Cambridge

9
00:00:27,010 --> 00:00:31,960
I did my PhD at Stanford while I was

10
00:00:29,980 --> 00:00:34,629
there I was one of the few Mac users

11
00:00:31,960 --> 00:00:37,270
everybody else was running Linux and I

12
00:00:34,629 --> 00:00:39,250
got tired of all the other Stanford

13
00:00:37,270 --> 00:00:40,989
computer science PhD students coming to

14
00:00:39,250 --> 00:00:46,239
use my computer to print because they

15
00:00:40,989 --> 00:00:48,879
couldn't figure out how to do it I I was

16
00:00:46,239 --> 00:00:51,910
quite vocal about the terrible state of

17
00:00:48,880 --> 00:00:53,530
ease of use for IP back then compared to

18
00:00:51,910 --> 00:00:56,379
Apple talk where you just pull down the

19
00:00:53,530 --> 00:00:58,750
Apple menu and click on the chooser see

20
00:00:56,380 --> 00:01:00,399
a list of printers pick one I became

21
00:00:58,750 --> 00:01:03,010
co-chair of the ITF zero configuration

22
00:01:00,399 --> 00:01:05,829
working group I served a term on the IAB

23
00:01:03,010 --> 00:01:07,450
I wrote The O'Reilly book you see

24
00:01:05,829 --> 00:01:09,759
there's there a configuration networking

25
00:01:07,450 --> 00:01:14,350
and I am currently a distinguished

26
00:01:09,759 --> 00:01:16,659
engineer at Apple so apple talk in the

27
00:01:14,350 --> 00:01:20,439
80s was well known for its ease of use

28
00:01:16,659 --> 00:01:23,200
and what we'd like with zero

29
00:01:20,439 --> 00:01:25,329
configuration IP is nobody ever has to

30
00:01:23,200 --> 00:01:28,240
type an IP address not to configure a

31
00:01:25,329 --> 00:01:30,639
device to set it up and not to connect

32
00:01:28,240 --> 00:01:33,429
to some service on some other device and

33
00:01:30,639 --> 00:01:35,229
if you think about today nobody has to

34
00:01:33,429 --> 00:01:37,719
type MAC addresses we have this protocol

35
00:01:35,229 --> 00:01:40,060
called ARP that maps from IP addresses

36
00:01:37,719 --> 00:01:42,038
to MAC addresses we should do the same

37
00:01:40,060 --> 00:01:44,380
thing with IP addresses users should

38
00:01:42,039 --> 00:01:45,969
deal with names and we should map those

39
00:01:44,380 --> 00:01:50,829
programmatically to the current IP

40
00:01:45,969 --> 00:01:53,798
address of that service why do you care

41
00:01:50,829 --> 00:01:55,449
if you're making products it lowers the

42
00:01:53,799 --> 00:01:57,880
support costs if people are not calling

43
00:01:55,450 --> 00:01:59,349
because they can't make it work it saves

44
00:01:57,880 --> 00:02:01,119
you money people are not returning the

45
00:01:59,349 --> 00:02:04,090
product because they can't make it work

46
00:02:01,119 --> 00:02:07,179
it makes entirely new product category

47
00:02:04,090 --> 00:02:09,098
as possible which would not be possible

48
00:02:07,179 --> 00:02:10,690
there would not be a market for them if

49
00:02:09,098 --> 00:02:15,700
they were so difficult to use nobody

50
00:02:10,690 --> 00:02:16,280
bought them and perhaps last but still

51
00:02:15,700 --> 00:02:18,470
interested

52
00:02:16,280 --> 00:02:22,640
it makes products that are a pleasure to

53
00:02:18,470 --> 00:02:24,680
use instead of a pain we still see

54
00:02:22,640 --> 00:02:26,899
applications that look like this that

55
00:02:24,680 --> 00:02:30,500
ask users to type in the IP address of

56
00:02:26,900 --> 00:02:31,850
the thing they want to connect to these

57
00:02:30,500 --> 00:02:35,600
are some pictures from when Apple

58
00:02:31,850 --> 00:02:38,440
introduced air print you tap on print

59
00:02:35,600 --> 00:02:43,190
and you see the available printers

60
00:02:38,440 --> 00:02:45,980
nobody types in an IP address Apple uses

61
00:02:43,190 --> 00:02:49,100
zero configuration networking for things

62
00:02:45,980 --> 00:02:51,679
like air print airplay home kits you

63
00:02:49,100 --> 00:02:53,720
don't see anything in those UI where the

64
00:02:51,680 --> 00:02:56,060
user has to type in the IP address of

65
00:02:53,720 --> 00:02:59,180
what they're connecting to this is

66
00:02:56,060 --> 00:03:02,090
especially critical for devices that

67
00:02:59,180 --> 00:03:05,989
have no screening keyboard think about

68
00:03:02,090 --> 00:03:08,930
Wi-Fi access points the only way you can

69
00:03:05,989 --> 00:03:10,370
configure and manage a network device

70
00:03:08,930 --> 00:03:13,160
with no screening keyboard is over the

71
00:03:10,370 --> 00:03:15,410
network so you have to have absolutely

72
00:03:13,160 --> 00:03:17,390
reliable networking because if it can't

73
00:03:15,410 --> 00:03:20,510
be reached over the network there is no

74
00:03:17,390 --> 00:03:22,730
way to reach it 20 years ago we had

75
00:03:20,510 --> 00:03:24,980
serial ports and you'd connect a vt100

76
00:03:22,730 --> 00:03:26,480
terminal to its and manage it over the

77
00:03:24,980 --> 00:03:29,000
command line and there are still some

78
00:03:26,480 --> 00:03:32,030
products like that but more and more we

79
00:03:29,000 --> 00:03:33,860
want to move to a world where we don't

80
00:03:32,030 --> 00:03:35,989
need a serial port as a crutch to make a

81
00:03:33,860 --> 00:03:40,190
networking work the networking should be

82
00:03:35,989 --> 00:03:43,970
self-sufficient so how do we realize

83
00:03:40,190 --> 00:03:47,390
this vision there are three supporting

84
00:03:43,970 --> 00:03:49,160
technologies the first one is you're not

85
00:03:47,390 --> 00:03:54,170
going to do much IP networking without

86
00:03:49,160 --> 00:03:56,299
an IP address DHCP is great if you don't

87
00:03:54,170 --> 00:03:58,518
have a DHCP server you don't the product

88
00:03:56,299 --> 00:04:00,950
to fail so that's where self-assigned

89
00:03:58,519 --> 00:04:04,130
link-local addressing comes in this is

90
00:04:00,950 --> 00:04:06,048
really simple in v4 and in v6 you pick a

91
00:04:04,130 --> 00:04:08,090
random address within the designated

92
00:04:06,049 --> 00:04:09,980
range you send an ARP or neighbor

93
00:04:08,090 --> 00:04:12,350
discovery request to see if it's already

94
00:04:09,980 --> 00:04:17,510
in use and if it is you pick a different

95
00:04:12,350 --> 00:04:18,978
one and try again so that's great we now

96
00:04:17,510 --> 00:04:21,228
know that all our devices will have an

97
00:04:18,978 --> 00:04:23,840
IP address may be randomly picked or may

98
00:04:21,228 --> 00:04:26,390
be DHCP assigned but if we don't know

99
00:04:23,840 --> 00:04:30,260
what the address is that's only got us

100
00:04:26,390 --> 00:04:34,550
partway there so we want to do naming

101
00:04:30,260 --> 00:04:35,990
DNS is great if you have DNS setup and

102
00:04:34,550 --> 00:04:37,550
you have the infrastructure to do that

103
00:04:35,990 --> 00:04:40,250
then that's a great way of naming

104
00:04:37,550 --> 00:04:42,080
devices just like with link local

105
00:04:40,250 --> 00:04:45,080
addressing where we want to fall back

106
00:04:42,080 --> 00:04:47,359
when DHCP is not available we want to

107
00:04:45,080 --> 00:04:50,599
fall back when DNS is not available and

108
00:04:47,360 --> 00:04:53,930
that is multicast DNS which adopts as

109
00:04:50,600 --> 00:04:56,390
much as possible the same naming syntax

110
00:04:53,930 --> 00:05:00,380
the same record types and as much as

111
00:04:56,390 --> 00:05:02,419
possible the same semantics except it is

112
00:05:00,380 --> 00:05:04,670
just done using multicast where the

113
00:05:02,420 --> 00:05:07,340
query in client sends a multicast to all

114
00:05:04,670 --> 00:05:10,670
devices on the local link and if any

115
00:05:07,340 --> 00:05:12,710
match that name then they respond you

116
00:05:10,670 --> 00:05:14,810
can name your devices with anything

117
00:05:12,710 --> 00:05:16,700
ending and dot local and the dot local

118
00:05:14,810 --> 00:05:19,130
is what signifies to the underlying

119
00:05:16,700 --> 00:05:22,490
resolver infrastructure to look this up

120
00:05:19,130 --> 00:05:25,790
with multicast on the local link so once

121
00:05:22,490 --> 00:05:27,920
this is in place you can type printer

122
00:05:25,790 --> 00:05:30,200
dot local into your web browser to

123
00:05:27,920 --> 00:05:33,170
access the printers web UI to check the

124
00:05:30,200 --> 00:05:35,330
ink levels and things like that or for

125
00:05:33,170 --> 00:05:37,670
developers it's super convenient to be

126
00:05:35,330 --> 00:05:40,340
able to log in with SSH without having

127
00:05:37,670 --> 00:05:41,870
to remember IP addresses they can access

128
00:05:40,340 --> 00:05:44,560
their devices by name on the local

129
00:05:41,870 --> 00:05:47,240
network so this is a step forward but

130
00:05:44,560 --> 00:05:50,930
you still need to know what name to type

131
00:05:47,240 --> 00:05:53,300
and if you type it wrong or don't know

132
00:05:50,930 --> 00:05:55,870
what to type then it doesn't work and

133
00:05:53,300 --> 00:05:59,270
you don't get any helpful error message

134
00:05:55,870 --> 00:06:03,200
so the third thing we need is discovery

135
00:05:59,270 --> 00:06:06,200
and there are three basic operations in

136
00:06:03,200 --> 00:06:10,490
discovery that I call offer enumerate

137
00:06:06,200 --> 00:06:14,240
and use offering is the step where a

138
00:06:10,490 --> 00:06:17,840
device that has a listening socket TCP

139
00:06:14,240 --> 00:06:19,880
UDP quick SCTP any other protocol if

140
00:06:17,840 --> 00:06:22,130
it's listening for incoming requests

141
00:06:19,880 --> 00:06:24,560
then it can advertise that on the

142
00:06:22,130 --> 00:06:27,140
network clients that are looking for

143
00:06:24,560 --> 00:06:29,450
that type of service can then browse or

144
00:06:27,140 --> 00:06:31,340
enumerates the instances on the network

145
00:06:29,450 --> 00:06:34,670
that can meet their needs and then

146
00:06:31,340 --> 00:06:37,429
finally having picked one either the

147
00:06:34,670 --> 00:06:39,230
human user picking one or with

148
00:06:37,430 --> 00:06:41,350
machine-to-machine applications some

149
00:06:39,230 --> 00:06:43,640
algorithm chooses the appropriate one

150
00:06:41,350 --> 00:06:44,230
maybe just the first one it finds in

151
00:06:43,640 --> 00:06:46,659
some case

152
00:06:44,230 --> 00:06:49,030
as having made that choice the third

153
00:06:46,660 --> 00:06:51,250
step is actually using it which means

154
00:06:49,030 --> 00:06:54,429
finding the IP address making a

155
00:06:51,250 --> 00:06:57,400
connection and so on sometimes this

156
00:06:54,430 --> 00:07:00,130
happens once sometimes discovery is just

157
00:06:57,400 --> 00:07:03,880
used for onboarding a device onto the

158
00:07:00,130 --> 00:07:07,140
network I'll give an example with the

159
00:07:03,880 --> 00:07:09,700
homekit products that do home automation

160
00:07:07,140 --> 00:07:11,860
when you get them out the box they're

161
00:07:09,700 --> 00:07:13,870
advertising a service type which

162
00:07:11,860 --> 00:07:17,350
basically says I am a non configured

163
00:07:13,870 --> 00:07:19,390
device waiting to be set up the client

164
00:07:17,350 --> 00:07:22,240
in this case an iPhone browsers for that

165
00:07:19,390 --> 00:07:23,590
finds those devices communicates with

166
00:07:22,240 --> 00:07:26,680
them over the network using the setup

167
00:07:23,590 --> 00:07:28,090
protocol and once that done they're now

168
00:07:26,680 --> 00:07:31,780
set up they are no longer done

169
00:07:28,090 --> 00:07:34,179
configured device in other cases where

170
00:07:31,780 --> 00:07:37,450
you for example select your default

171
00:07:34,180 --> 00:07:40,090
printer then you may do that selection

172
00:07:37,450 --> 00:07:41,590
once but every time you hit command P

173
00:07:40,090 --> 00:07:48,429
and print to that you may do that

174
00:07:41,590 --> 00:07:50,890
multiple times per day so this discovery

175
00:07:48,430 --> 00:07:53,290
stuff sounds nice one of the things we

176
00:07:50,890 --> 00:07:55,750
want to keep in mind here is very

177
00:07:53,290 --> 00:07:59,860
constrained devices I talked about home

178
00:07:55,750 --> 00:08:01,800
kits building automation IOT a lot of

179
00:07:59,860 --> 00:08:07,620
these devices have limited resources

180
00:08:01,800 --> 00:08:11,830
we've already decided we need DHCP and

181
00:08:07,620 --> 00:08:14,770
self-assigned addresses we need DNS and

182
00:08:11,830 --> 00:08:17,469
multicast dns for naming if we can

183
00:08:14,770 --> 00:08:20,349
leverage that code that we have any way

184
00:08:17,470 --> 00:08:25,240
to do discovery as well then that saves

185
00:08:20,350 --> 00:08:27,670
us having a whole new body of code so

186
00:08:25,240 --> 00:08:30,040
let's get a bit deeper into the three

187
00:08:27,670 --> 00:08:33,700
operations they talked about the first

188
00:08:30,040 --> 00:08:35,970
step is offering a device a service

189
00:08:33,700 --> 00:08:40,060
running on a device a piece of software

190
00:08:35,970 --> 00:08:42,040
uses the discovery API to publish DNS

191
00:08:40,059 --> 00:08:45,250
records describing the service and those

192
00:08:42,039 --> 00:08:47,650
three record types are PTR SRV and text

193
00:08:45,250 --> 00:08:50,230
you might ask what are those records

194
00:08:47,650 --> 00:08:56,500
well when I show you the next steps that

195
00:08:50,230 --> 00:08:57,820
will become apparent so imagine you are

196
00:08:56,500 --> 00:09:00,160
trying to

197
00:08:57,820 --> 00:09:02,110
prints on your iPhone using AirPrint and

198
00:09:00,160 --> 00:09:04,780
you're looking for printers that support

199
00:09:02,110 --> 00:09:07,030
IPP you send out that query on the

200
00:09:04,780 --> 00:09:08,920
network and you get back in this case

201
00:09:07,030 --> 00:09:11,400
there are four different devices that

202
00:09:08,920 --> 00:09:14,290
answered each with different names and

203
00:09:11,400 --> 00:09:15,790
the user can then take a look at that

204
00:09:14,290 --> 00:09:19,689
list and decide which one they want to

205
00:09:15,790 --> 00:09:22,810
use this is the browsing or enumeration

206
00:09:19,690 --> 00:09:24,460
step once the user has picked one we go

207
00:09:22,810 --> 00:09:28,030
to the next step which is actually using

208
00:09:24,460 --> 00:09:31,300
it so in this case we look up the SRV

209
00:09:28,030 --> 00:09:33,730
record and the txt record for that name

210
00:09:31,300 --> 00:09:36,790
that the user picked the SRV record

211
00:09:33,730 --> 00:09:39,250
tells us the target host and the port on

212
00:09:36,790 --> 00:09:41,140
that host the txt record gives us a

213
00:09:39,250 --> 00:09:43,480
bunch of key value pairs that describe

214
00:09:41,140 --> 00:09:44,890
other attributes of the service in this

215
00:09:43,480 --> 00:09:46,780
case for example it says the page

216
00:09:44,890 --> 00:09:50,860
description language that this printer

217
00:09:46,780 --> 00:09:53,410
supports is PostScript also by the magic

218
00:09:50,860 --> 00:09:55,300
of DNS additional records even though

219
00:09:53,410 --> 00:09:56,500
the client didn't ask for the address

220
00:09:55,300 --> 00:09:59,770
record of the printer

221
00:09:56,500 --> 00:10:03,070
the responding device knows that he'll

222
00:09:59,770 --> 00:10:05,260
probably need that information so for

223
00:10:03,070 --> 00:10:07,950
the target host referenced in the SRP

224
00:10:05,260 --> 00:10:10,270
record it has an additional record

225
00:10:07,950 --> 00:10:11,710
giving the address of that to save the

226
00:10:10,270 --> 00:10:13,949
client doing another round-trip to look

227
00:10:11,710 --> 00:10:13,950
it up

228
00:10:14,040 --> 00:10:19,810
notice the port number in the SRV record

229
00:10:16,600 --> 00:10:23,350
this is incredibly helpful this frees us

230
00:10:19,810 --> 00:10:25,540
from having to use fixed well-known

231
00:10:23,350 --> 00:10:29,770
ports if you want to run multiple

232
00:10:25,540 --> 00:10:32,050
instances of a service type on the same

233
00:10:29,770 --> 00:10:35,980
device they can't all have the same port

234
00:10:32,050 --> 00:10:38,680
and this leads to very complicated

235
00:10:35,980 --> 00:10:42,250
workarounds HTTP has the host header

236
00:10:38,680 --> 00:10:46,949
which lets a server act as multiple

237
00:10:42,250 --> 00:10:49,750
virtual servers but it's kind of awkward

238
00:10:46,950 --> 00:10:50,980
IPP has similar demultiplexing but every

239
00:10:49,750 --> 00:10:53,080
application has to invent this

240
00:10:50,980 --> 00:10:54,700
demultiplexing if you just run each

241
00:10:53,080 --> 00:10:57,670
instance on its own port it's much

242
00:10:54,700 --> 00:10:59,710
simpler and that wasn't possible with

243
00:10:57,670 --> 00:11:01,180
well-known har code hard-coded ports but

244
00:10:59,710 --> 00:11:03,720
service discovery frees you from that

245
00:11:01,180 --> 00:11:03,719
restriction

246
00:11:05,320 --> 00:11:11,050
so going back to these results let's

247
00:11:08,800 --> 00:11:15,250
take a little bit of a closer look at

248
00:11:11,050 --> 00:11:17,709
that name on the left it is a structured

249
00:11:15,250 --> 00:11:21,160
name made up of three parts the first

250
00:11:17,710 --> 00:11:23,530
part is the user friendly visible name

251
00:11:21,160 --> 00:11:26,530
of that instance of the service it is

252
00:11:23,530 --> 00:11:28,750
arbitrary utf-8 text it can contain

253
00:11:26,530 --> 00:11:32,610
uppercase lowercase spaces punctuation

254
00:11:28,750 --> 00:11:36,430
anything you can represent in utf-8

255
00:11:32,610 --> 00:11:38,740
typically users don't have to type this

256
00:11:36,430 --> 00:11:40,569
name when they connect to a service

257
00:11:38,740 --> 00:11:43,180
typically they using a graphical user

258
00:11:40,570 --> 00:11:45,550
interface and they click or tap on it so

259
00:11:43,180 --> 00:11:47,680
keeping it short and easy to type is

260
00:11:45,550 --> 00:11:50,740
less important than have it be

261
00:11:47,680 --> 00:11:53,260
descriptive when you set up the device

262
00:11:50,740 --> 00:11:56,440
you name it however you want and having

263
00:11:53,260 --> 00:11:59,740
done that naming then other clients just

264
00:11:56,440 --> 00:12:01,750
select it by tapping the second part of

265
00:11:59,740 --> 00:12:04,390
the name is the service type which tells

266
00:12:01,750 --> 00:12:06,250
us what it does and the final part is

267
00:12:04,390 --> 00:12:09,310
the domain so let's look at those three

268
00:12:06,250 --> 00:12:13,420
in a bit closer detail starting with the

269
00:12:09,310 --> 00:12:15,609
instance name there are two kinds of

270
00:12:13,420 --> 00:12:18,699
names at play here there are the host

271
00:12:15,610 --> 00:12:20,560
names and the service names host names

272
00:12:18,700 --> 00:12:22,840
are what we're used to thinking about

273
00:12:20,560 --> 00:12:25,239
with DNS they're often typed on the

274
00:12:22,840 --> 00:12:27,550
command line with things like SSH

275
00:12:25,240 --> 00:12:29,380
commands in terminal windows and it's

276
00:12:27,550 --> 00:12:31,569
definitely convenient to have those to

277
00:12:29,380 --> 00:12:33,939
be short and memorable and easy to type

278
00:12:31,570 --> 00:12:36,820
and it's good if they don't have spaces

279
00:12:33,940 --> 00:12:40,870
Pickers shells get confused with spaces

280
00:12:36,820 --> 00:12:43,330
in arguments service names on the other

281
00:12:40,870 --> 00:12:47,770
hand should be as rich and varied as

282
00:12:43,330 --> 00:12:49,600
file names and we used to have dos 8.3

283
00:12:47,770 --> 00:12:52,150
file names all capitals but we've moved

284
00:12:49,600 --> 00:12:55,480
on from that and the same is true with

285
00:12:52,150 --> 00:12:57,730
service names having rich tests naming

286
00:12:55,480 --> 00:13:02,920
is something we should expect in today's

287
00:12:57,730 --> 00:13:05,470
world this is a point where I'll make a

288
00:13:02,920 --> 00:13:08,110
little digression something we see a lot

289
00:13:05,470 --> 00:13:10,450
of vendors do is they feel the need to

290
00:13:08,110 --> 00:13:12,160
make the names unique in the factory by

291
00:13:10,450 --> 00:13:17,620
stuffing the MAC address into the name

292
00:13:12,160 --> 00:13:19,120
and I it's a mystery to me why people

293
00:13:17,620 --> 00:13:26,230
sometimes think this is

294
00:13:19,120 --> 00:13:28,020
full thing to do because multicast DNS

295
00:13:26,230 --> 00:13:31,860
has name conflict detection and

296
00:13:28,020 --> 00:13:35,439
automatic renaming so let's consider

297
00:13:31,860 --> 00:13:37,750
three different scenarios one is the

298
00:13:35,440 --> 00:13:40,180
average home user has one printer they

299
00:13:37,750 --> 00:13:43,870
don't need a 12 character MAC address if

300
00:13:40,180 --> 00:13:46,810
the printer is called HP LaserJet then

301
00:13:43,870 --> 00:13:48,279
that's their printer now imagine a small

302
00:13:46,810 --> 00:13:50,349
dentist office where they have two

303
00:13:48,279 --> 00:13:52,210
printers they have one and it works fine

304
00:13:50,350 --> 00:13:54,970
and later they decide to get a new on

305
00:13:52,210 --> 00:13:57,700
the second one they add will detect the

306
00:13:54,970 --> 00:14:00,760
name conflicts and call itself HP

307
00:13:57,700 --> 00:14:02,980
LaserJet - now most people in the

308
00:14:00,760 --> 00:14:04,660
dentist office without even thinking

309
00:14:02,980 --> 00:14:06,520
about it will very instinctive to

310
00:14:04,660 --> 00:14:08,709
remember that's the old printer I've

311
00:14:06,520 --> 00:14:12,310
been using for years and the new one is

312
00:14:08,710 --> 00:14:14,529
printer - no confusion two different MAC

313
00:14:12,310 --> 00:14:17,229
addresses much harder to remember than

314
00:14:14,529 --> 00:14:19,900
the new one is number two third scenario

315
00:14:17,230 --> 00:14:20,680
is imagine you have ten printers well at

316
00:14:19,900 --> 00:14:23,650
this point

317
00:14:20,680 --> 00:14:26,199
memorizing ten MAC addresses is no use

318
00:14:23,650 --> 00:14:29,040
to anybody numbering them from one to

319
00:14:26,200 --> 00:14:31,930
ten is at least a little bit better in

320
00:14:29,040 --> 00:14:33,670
reality when you get up to these numbers

321
00:14:31,930 --> 00:14:35,469
what makes sense is for the

322
00:14:33,670 --> 00:14:37,360
administrator the person buying and

323
00:14:35,470 --> 00:14:39,160
installing this should go into the web

324
00:14:37,360 --> 00:14:41,080
UI of the device and give it some kind

325
00:14:39,160 --> 00:14:44,230
of more meaningful name but in none of

326
00:14:41,080 --> 00:14:45,730
these cases is MAC addresses any use to

327
00:14:44,230 --> 00:14:49,810
the end-user trying to tell what thing

328
00:14:45,730 --> 00:14:53,470
they've discovered so let's move on to

329
00:14:49,810 --> 00:14:55,930
the second part the service type this

330
00:14:53,470 --> 00:14:59,110
seems very simple but there are some

331
00:14:55,930 --> 00:15:00,400
subtleties here this is not displayed to

332
00:14:59,110 --> 00:15:03,100
the user this is something only

333
00:15:00,400 --> 00:15:05,529
programmers see so there is no value in

334
00:15:03,100 --> 00:15:08,140
rich text here they're limited to 15

335
00:15:05,529 --> 00:15:10,720
characters letters digits and hyphens

336
00:15:08,140 --> 00:15:12,970
just like traditional host names that is

337
00:15:10,720 --> 00:15:16,110
a big enough space that they're

338
00:15:12,970 --> 00:15:20,170
effectively unlimited the allocated

339
00:15:16,110 --> 00:15:22,779
first-come-first-served and there's no

340
00:15:20,170 --> 00:15:24,550
risk of running out on the other hand

341
00:15:22,779 --> 00:15:26,320
the identifier space is short enough

342
00:15:24,550 --> 00:15:28,120
that it's not wasteful in packets

343
00:15:26,320 --> 00:15:30,459
particularly for these IOT type

344
00:15:28,120 --> 00:15:32,140
applications I'm talking about you want

345
00:15:30,459 --> 00:15:34,560
to be mindful of wasting bytes in

346
00:15:32,140 --> 00:15:34,560
packets

347
00:15:34,720 --> 00:15:39,860
the second half the label is the

348
00:15:37,160 --> 00:15:43,279
protocol type string this was inherited

349
00:15:39,860 --> 00:15:46,460
from the definition of DNS SRV records

350
00:15:43,279 --> 00:15:49,180
in retrospect looking back it probably

351
00:15:46,460 --> 00:15:52,880
isn't necessary and it causes confusion

352
00:15:49,180 --> 00:15:57,140
but it's a legacy from what we adopted

353
00:15:52,880 --> 00:15:59,680
and the rule is if the protocol runs

354
00:15:57,140 --> 00:16:04,040
over TCP attention underscore TCP and

355
00:15:59,680 --> 00:16:06,170
everything else is under school UDP and

356
00:16:04,040 --> 00:16:08,020
that would include things that actually

357
00:16:06,170 --> 00:16:10,610
don't use UDP but they're pretty rare

358
00:16:08,020 --> 00:16:13,069
things like quick actually run over UDP

359
00:16:10,610 --> 00:16:14,720
so that's why the world is divided in

360
00:16:13,070 --> 00:16:17,140
two there is TCP and there is UDP and

361
00:16:14,720 --> 00:16:17,140
nothing else

362
00:16:17,410 --> 00:16:22,219
now the semantics of the surface type

363
00:16:20,089 --> 00:16:24,860
string are really important because they

364
00:16:22,220 --> 00:16:28,970
encode two things they encode what the

365
00:16:24,860 --> 00:16:32,630
service does and how it does it what it

366
00:16:28,970 --> 00:16:35,240
does is a user meaningful concept like

367
00:16:32,630 --> 00:16:37,400
say printing that is something somebody

368
00:16:35,240 --> 00:16:40,010
understands but there are many ways of

369
00:16:37,400 --> 00:16:44,000
printing there's IPP there's the old LPR

370
00:16:40,010 --> 00:16:46,220
protocol there is a collection of

371
00:16:44,000 --> 00:16:48,890
proprietary printing mechanisms that

372
00:16:46,220 --> 00:16:52,160
traditionally use port 9100 variously

373
00:16:48,890 --> 00:16:54,470
called apps or Couture jetdirect if you

374
00:16:52,160 --> 00:16:57,100
discover an IPP printer but your client

375
00:16:54,470 --> 00:17:01,880
doesn't support IPP that's no use to you

376
00:16:57,100 --> 00:17:04,130
so it's not sufficient just to have the

377
00:17:01,880 --> 00:17:05,179
logical service that the user wants you

378
00:17:04,130 --> 00:17:08,990
actually have to have a compatible

379
00:17:05,179 --> 00:17:10,490
implementation and this is important the

380
00:17:08,990 --> 00:17:13,370
other way around as well I can give an

381
00:17:10,490 --> 00:17:16,750
example the music streaming protocol

382
00:17:13,369 --> 00:17:21,770
built into YouTube into iTunes is

383
00:17:16,750 --> 00:17:23,510
actually just HTTP GET you can share

384
00:17:21,770 --> 00:17:26,329
your music library on your home network

385
00:17:23,510 --> 00:17:27,189
and other clients just do HTTP gets to

386
00:17:26,329 --> 00:17:31,040
fetch it

387
00:17:27,189 --> 00:17:34,640
so at some level the protocol is HTTP

388
00:17:31,040 --> 00:17:36,050
but semantically this is not something

389
00:17:34,640 --> 00:17:39,020
you would use a web browser to view

390
00:17:36,050 --> 00:17:42,470
there is no HTML formatted text for a

391
00:17:39,020 --> 00:17:45,679
human to look at so the service type for

392
00:17:42,470 --> 00:17:46,520
that is not HTTP it's a different string

393
00:17:45,679 --> 00:17:49,790
it's D

394
00:17:46,520 --> 00:17:51,889
a ap digital audio access protocol even

395
00:17:49,790 --> 00:17:54,020
though Wireshark would look at it and

396
00:17:51,890 --> 00:17:57,320
decode it and perfectly well say this is

397
00:17:54,020 --> 00:18:00,400
HTTP semantically it is a repurposing of

398
00:17:57,320 --> 00:18:03,050
HTTP so the service type encodes both

399
00:18:00,400 --> 00:18:06,500
what the user perceives they're doing

400
00:18:03,050 --> 00:18:10,370
and the protocol that's being used to do

401
00:18:06,500 --> 00:18:13,400
it here are some examples IP p is

402
00:18:10,370 --> 00:18:16,939
printing ssh remote login remote frame

403
00:18:13,400 --> 00:18:19,880
buffer is VNC screen sharing you can see

404
00:18:16,940 --> 00:18:21,800
all of these in use if you if you have

405
00:18:19,880 --> 00:18:23,780
max here in the terminal window press

406
00:18:21,800 --> 00:18:26,419
command shift K it will bring up a

407
00:18:23,780 --> 00:18:28,160
browser showing you or your fellow IT

408
00:18:26,420 --> 00:18:33,140
efforts you've got SSH turned on on

409
00:18:28,160 --> 00:18:37,010
their machines it's important that these

410
00:18:33,140 --> 00:18:39,860
service types don't collide so Ayana

411
00:18:37,010 --> 00:18:41,960
maintains a free registry like many of

412
00:18:39,860 --> 00:18:45,590
the other registries they maintain and

413
00:18:41,960 --> 00:18:47,810
it is first-come first-served within

414
00:18:45,590 --> 00:18:51,230
reason unless there's an abusive number

415
00:18:47,810 --> 00:18:52,820
of excessive registrations there are no

416
00:18:51,230 --> 00:18:55,070
restrictions on getting a service type

417
00:18:52,820 --> 00:18:56,659
assigned and you just fill in the form

418
00:18:55,070 --> 00:18:58,310
and you get one and it's yours in

419
00:18:56,660 --> 00:19:01,130
perpetuity it doesn't have to be renewed

420
00:18:58,310 --> 00:19:02,750
every year like a domain name before

421
00:19:01,130 --> 00:19:04,550
shipping your product do register your

422
00:19:02,750 --> 00:19:06,140
service types because it would be

423
00:19:04,550 --> 00:19:08,480
awkward if somebody else used the same

424
00:19:06,140 --> 00:19:12,500
name and then you have inadvertent

425
00:19:08,480 --> 00:19:14,300
conflicts on the network now let's get

426
00:19:12,500 --> 00:19:16,160
to the third part of this name the dot

427
00:19:14,300 --> 00:19:17,510
local well dot local tells the

428
00:19:16,160 --> 00:19:20,600
underlying system look this up with

429
00:19:17,510 --> 00:19:21,610
multicast but if the name is not dot

430
00:19:20,600 --> 00:19:25,520
local

431
00:19:21,610 --> 00:19:27,080
then that means used the standard DNS

432
00:19:25,520 --> 00:19:31,730
that we all know and love is there a

433
00:19:27,080 --> 00:19:41,389
question there okay am i not close

434
00:19:31,730 --> 00:19:47,570
enough is that okay thanks like that is

435
00:19:41,390 --> 00:19:49,440
that not towards my mouth okay okay

436
00:19:47,570 --> 00:19:55,918
we'll see how that works

437
00:19:49,440 --> 00:19:58,169
try to talk louder so when you're not

438
00:19:55,919 --> 00:20:01,710
using dot local when you're using some

439
00:19:58,169 --> 00:20:03,990
other domain then normal DNS that we

440
00:20:01,710 --> 00:20:07,769
know and love comes into play services

441
00:20:03,990 --> 00:20:11,190
can publish their information using DNS

442
00:20:07,769 --> 00:20:14,519
update and clients discover it using DNS

443
00:20:11,190 --> 00:20:18,210
queries and DNS is the largest

444
00:20:14,519 --> 00:20:20,129
distributed global database that I think

445
00:20:18,210 --> 00:20:22,139
the world has ever seen so it is

446
00:20:20,129 --> 00:20:23,789
incredibly scalable we use it for

447
00:20:22,139 --> 00:20:25,769
storing host names we can use that same

448
00:20:23,789 --> 00:20:30,210
distributed database for storing service

449
00:20:25,769 --> 00:20:33,269
information we've been doing this for

450
00:20:30,210 --> 00:20:35,129
many years at the IETF and you may have

451
00:20:33,269 --> 00:20:37,139
used this without even thinking about it

452
00:20:35,129 --> 00:20:39,019
if you print out your boarding pass or

453
00:20:37,139 --> 00:20:42,600
print out an internet draft to read

454
00:20:39,019 --> 00:20:45,389
sitting here you can find the printer in

455
00:20:42,600 --> 00:20:46,860
the terminal room and you're not in the

456
00:20:45,389 --> 00:20:50,039
terminal room you're not on the same

457
00:20:46,860 --> 00:20:52,769
local link as the terminal room but it

458
00:20:50,039 --> 00:20:54,929
still works and if it didn't work

459
00:20:52,769 --> 00:20:57,600
people would grumble and curse stupid

460
00:20:54,929 --> 00:21:00,840
multicast DNS doesn't work across links

461
00:20:57,600 --> 00:21:02,428
but when it does work nobody pauses to

462
00:21:00,840 --> 00:21:04,139
think what just happened there they just

463
00:21:02,429 --> 00:21:07,169
they hit print they get their boarding

464
00:21:04,139 --> 00:21:09,209
pass and they're happy so I wanted a bit

465
00:21:07,169 --> 00:21:10,490
of a walk through to demystify what's

466
00:21:09,210 --> 00:21:16,500
really going on here

467
00:21:10,490 --> 00:21:17,909
it starts with DHCP and you can walk

468
00:21:16,500 --> 00:21:20,070
through these commands and you'll see

469
00:21:17,909 --> 00:21:23,429
this happening here at the IETF meeting

470
00:21:20,070 --> 00:21:26,340
Network these commands are done on my

471
00:21:23,429 --> 00:21:28,110
Mac when we look at the information we

472
00:21:26,340 --> 00:21:30,928
got from the DHCP server we look at

473
00:21:28,110 --> 00:21:34,590
option 15 here it's displayed as hex but

474
00:21:30,929 --> 00:21:37,889
if we decode that it tells us that the

475
00:21:34,590 --> 00:21:39,629
domain that the DHCP server is reporting

476
00:21:37,889 --> 00:21:41,840
for this network is meeting not IETF

477
00:21:39,629 --> 00:21:46,019
Talk okay that's a good start

478
00:21:41,840 --> 00:21:51,720
so now we look up this special query

479
00:21:46,019 --> 00:21:54,750
with the prefix lb DNS SD prepended onto

480
00:21:51,720 --> 00:21:57,539
meeting dot ITF dot org and we do a PTR

481
00:21:54,750 --> 00:22:00,149
query and what that is asking of the DNS

482
00:21:57,539 --> 00:22:01,679
infrastructure specifically asking the

483
00:22:00,149 --> 00:22:03,169
people who run the authoritative server

484
00:22:01,679 --> 00:22:05,780
for meeting dot ITF tour

485
00:22:03,170 --> 00:22:07,700
dog is do you have any service discovery

486
00:22:05,780 --> 00:22:10,550
information and if so where should I

487
00:22:07,700 --> 00:22:12,860
look and here we get an answer and it's

488
00:22:10,550 --> 00:22:14,720
a sort of self referential referential

489
00:22:12,860 --> 00:22:16,429
answer it says look in meeting dot ITF

490
00:22:14,720 --> 00:22:20,390
go talk but because it's a pointer it

491
00:22:16,430 --> 00:22:24,230
could direct you to services ITF dog or

492
00:22:20,390 --> 00:22:26,930
wherever in this case it's simply self

493
00:22:24,230 --> 00:22:30,080
referential answer pointing to itself so

494
00:22:26,930 --> 00:22:31,730
now we know where to look we can start

495
00:22:30,080 --> 00:22:33,830
looking at services and one of the

496
00:22:31,730 --> 00:22:35,510
questions that people often ask me or

497
00:22:33,830 --> 00:22:37,610
what are the assumptions I hear people

498
00:22:35,510 --> 00:22:42,190
have is that you have to be quotes on

499
00:22:37,610 --> 00:22:44,330
the ietf network and that's sort of a

500
00:22:42,190 --> 00:22:46,640
loosely defined term what does it mean

501
00:22:44,330 --> 00:22:49,669
to be on the ietf network what is the

502
00:22:46,640 --> 00:22:52,160
ITF network DNS is global so here's an

503
00:22:49,670 --> 00:22:54,560
example doing the exact same query sent

504
00:22:52,160 --> 00:22:57,800
to Google's quad 8 service and it gives

505
00:22:54,560 --> 00:23:00,770
the same answer the answers that you get

506
00:22:57,800 --> 00:23:05,450
from dns for public names don't depend

507
00:23:00,770 --> 00:23:07,820
on where you are now VPN and internal

508
00:23:05,450 --> 00:23:10,160
DNS accompanies does muddy the waters a

509
00:23:07,820 --> 00:23:12,980
little bit here but broadly speaking for

510
00:23:10,160 --> 00:23:14,990
public names you can look them up on any

511
00:23:12,980 --> 00:23:16,550
resolver in the world that'll consult

512
00:23:14,990 --> 00:23:20,840
the same authoritative service and get

513
00:23:16,550 --> 00:23:24,680
the same answer so now we know where to

514
00:23:20,840 --> 00:23:27,080
look this is what happens when you go

515
00:23:24,680 --> 00:23:29,180
into system preferences on a Mac and

516
00:23:27,080 --> 00:23:32,990
click the plus button to add a new

517
00:23:29,180 --> 00:23:35,690
printer it does a PTR query on the

518
00:23:32,990 --> 00:23:38,510
network and here at the ITF we find one

519
00:23:35,690 --> 00:23:40,880
printer call term - printer they could

520
00:23:38,510 --> 00:23:42,650
have named that a bit nicer with capital

521
00:23:40,880 --> 00:23:46,910
letters and things but that's what they

522
00:23:42,650 --> 00:23:49,130
chose to do so when you do this on your

523
00:23:46,910 --> 00:23:51,350
Mac and click plus this is how it the

524
00:23:49,130 --> 00:23:54,620
ITF meeting you'll see that printer show

525
00:23:51,350 --> 00:23:57,409
up when you actually want to print this

526
00:23:54,620 --> 00:23:59,149
is the user you then look at the SRV

527
00:23:57,410 --> 00:24:01,760
record for that printer and you find

528
00:23:59,150 --> 00:24:04,820
that it is implementing that printing

529
00:24:01,760 --> 00:24:08,780
protocol on port 9100 and there's the

530
00:24:04,820 --> 00:24:11,330
ipv6 address and you can print if we do

531
00:24:08,780 --> 00:24:14,820
the same thing on iOS it does the query

532
00:24:11,330 --> 00:24:18,210
and it prints notice here

533
00:24:14,820 --> 00:24:20,970
that iOS is using IPP so it's a

534
00:24:18,210 --> 00:24:23,009
different service type and the port

535
00:24:20,970 --> 00:24:25,409
number is different so same hardware

536
00:24:23,009 --> 00:24:31,740
different protocol different ports same

537
00:24:25,409 --> 00:24:32,970
results Turner on paper now those of you

538
00:24:31,740 --> 00:24:35,250
who are watching closely would have

539
00:24:32,970 --> 00:24:39,710
noticed something there in the query

540
00:24:35,250 --> 00:24:43,909
that the iPhone did it has this prefix

541
00:24:39,710 --> 00:24:46,429
Universal which is a subtype of IPP

542
00:24:43,909 --> 00:24:48,720
subtypes are a little used feature of

543
00:24:46,429 --> 00:24:50,759
service discovery but I want to mention

544
00:24:48,720 --> 00:24:54,539
them here for completeness because they

545
00:24:50,759 --> 00:24:56,639
can be useful if you need that subtypes

546
00:24:54,539 --> 00:24:59,970
are aware of narrowing the scope of what

547
00:24:56,639 --> 00:25:01,740
you find so in the case here there is no

548
00:24:59,970 --> 00:25:05,519
way for vendors to install custom

549
00:25:01,740 --> 00:25:08,070
drivers on an iPhone iPhones only

550
00:25:05,519 --> 00:25:11,279
support driverless printing using the

551
00:25:08,070 --> 00:25:13,168
IPP protocol but specifically the print

552
00:25:11,279 --> 00:25:15,690
has to support a format called universal

553
00:25:13,169 --> 00:25:17,820
raster format and the printer can

554
00:25:15,690 --> 00:25:20,190
optionally support many other formats as

555
00:25:17,820 --> 00:25:23,120
well but the mandatory to implement

556
00:25:20,190 --> 00:25:27,090
format is it must support URF because

557
00:25:23,120 --> 00:25:29,279
that way you know that your device may

558
00:25:27,090 --> 00:25:31,139
not be able to send post group for PDF

559
00:25:29,279 --> 00:25:33,000
or JPEG to this printer but in the worst

560
00:25:31,139 --> 00:25:36,629
case it can send a raster image and the

561
00:25:33,000 --> 00:25:39,299
printer will print it so the underscore

562
00:25:36,629 --> 00:25:43,939
Universal subtype of IPP is the subset

563
00:25:39,299 --> 00:25:47,190
of IPP printers that also implements URF

564
00:25:43,940 --> 00:25:50,759
so if you have a use case where you want

565
00:25:47,190 --> 00:25:53,429
to narrow your search to a subset of a

566
00:25:50,759 --> 00:25:57,500
particular set of devices that have a

567
00:25:53,429 --> 00:25:57,500
service type sometimes let you do that

568
00:26:00,019 --> 00:26:06,809
so now

569
00:26:01,440 --> 00:26:08,759
get on to how you can use this it is

570
00:26:06,809 --> 00:26:11,970
included I'm sure everybody knows in Mac

571
00:26:08,759 --> 00:26:15,450
OS and iOS and has been for more than 15

572
00:26:11,970 --> 00:26:20,429
years most Linux distributions include

573
00:26:15,450 --> 00:26:24,269
the avahi LGPL implementation Android

574
00:26:20,429 --> 00:26:25,740
started including it in 2012 and Windows

575
00:26:24,269 --> 00:26:28,230
10 in 2015

576
00:26:25,740 --> 00:26:32,549
added their own native DNS service

577
00:26:28,230 --> 00:26:34,559
discovery ap is the best way to get

578
00:26:32,549 --> 00:26:38,070
started if you just want to play with

579
00:26:34,559 --> 00:26:41,850
this and prototype is to use the DNS SD

580
00:26:38,070 --> 00:26:44,519
command-line tool which is installed on

581
00:26:41,850 --> 00:26:48,360
Macs if you get the NBS responder

582
00:26:44,519 --> 00:26:50,370
project for Linux or POSIX you just type

583
00:26:48,360 --> 00:26:52,258
make install and it will install the

584
00:26:50,370 --> 00:26:54,268
daemon and the same command-line tool if

585
00:26:52,259 --> 00:26:59,009
you have bonjour for Windows installed

586
00:26:54,269 --> 00:27:01,139
then the same tool is there this is not

587
00:26:59,009 --> 00:27:03,779
intended for you to embed it in scripts

588
00:27:01,139 --> 00:27:06,508
and use it in production software but as

589
00:27:03,779 --> 00:27:09,269
a quick and easy way to kick the tires

590
00:27:06,509 --> 00:27:11,970
and see whether this works for you it's

591
00:27:09,269 --> 00:27:14,759
a very low overhead way of trying things

592
00:27:11,970 --> 00:27:16,919
out and if any of you are interested in

593
00:27:14,759 --> 00:27:18,629
seeing this in more detail afterwards we

594
00:27:16,919 --> 00:27:21,509
can sit down and do some experiments

595
00:27:18,629 --> 00:27:23,189
together it supports the three

596
00:27:21,509 --> 00:27:27,559
operations I talked about offer

597
00:27:23,190 --> 00:27:29,610
enumerate and use the - are option

598
00:27:27,559 --> 00:27:32,428
registers your service with the

599
00:27:29,610 --> 00:27:34,320
underlying daemon use tell it the name

600
00:27:32,429 --> 00:27:35,909
type domain and port you're listening on

601
00:27:34,320 --> 00:27:39,149
and then that is published on the

602
00:27:35,909 --> 00:27:41,549
network either with multicast DNS if

603
00:27:39,149 --> 00:27:45,299
it's local or if it's some other domain

604
00:27:41,549 --> 00:27:48,059
with the DNS update when a client wants

605
00:27:45,299 --> 00:27:49,620
to find those it does a browse operation

606
00:27:48,059 --> 00:27:52,950
and you'll see the parameters are very

607
00:27:49,620 --> 00:27:54,449
similar except you miss out the name you

608
00:27:52,950 --> 00:27:56,850
say the type you're looking for in the

609
00:27:54,450 --> 00:27:58,230
domain you care about and the result you

610
00:27:56,850 --> 00:28:01,860
get back is the list of names

611
00:27:58,230 --> 00:28:04,769
and then finally the lookup or resolve

612
00:28:01,860 --> 00:28:06,418
step that you do prior to connecting you

613
00:28:04,769 --> 00:28:08,450
tell it name type and domain because

614
00:28:06,419 --> 00:28:11,429
that's what you learn from the browser

615
00:28:08,450 --> 00:28:13,580
what you get back is the target host and

616
00:28:11,429 --> 00:28:13,580
port

617
00:28:14,950 --> 00:28:21,650
how you select local and wide-area this

618
00:28:19,250 --> 00:28:24,590
is one of the benefits of having it

619
00:28:21,650 --> 00:28:27,440
designed on DNS this way is it's not a

620
00:28:24,590 --> 00:28:29,060
different API use the same API you get

621
00:28:27,440 --> 00:28:31,310
the same semantics you get the same

622
00:28:29,060 --> 00:28:38,240
behavior it just depends on where the

623
00:28:31,310 --> 00:28:40,639
domain is local or something else in

624
00:28:38,240 --> 00:28:43,760
terms of API usage if you're writing an

625
00:28:40,640 --> 00:28:46,190
application we recommend that you don't

626
00:28:43,760 --> 00:28:48,260
specify domain just past null or empty

627
00:28:46,190 --> 00:28:51,740
string and that lets the underlying

628
00:28:48,260 --> 00:28:54,350
system apply the users defaults most of

629
00:28:51,740 --> 00:28:56,810
the time that will just be local but as

630
00:28:54,350 --> 00:28:58,909
you saw at the ITF meeting where you get

631
00:28:56,810 --> 00:29:01,460
hints from the network that in addition

632
00:28:58,910 --> 00:29:03,170
to local there may be other domains that

633
00:29:01,460 --> 00:29:07,130
have interesting things for you to find

634
00:29:03,170 --> 00:29:09,500
if you pass null the system will do the

635
00:29:07,130 --> 00:29:11,420
union of all those discoveries if the

636
00:29:09,500 --> 00:29:12,770
printing system passed local as its

637
00:29:11,420 --> 00:29:14,960
domain parameter would only ever find

638
00:29:12,770 --> 00:29:18,110
local things by leaving that unspecified

639
00:29:14,960 --> 00:29:22,790
it allows the system defaults to come

640
00:29:18,110 --> 00:29:25,760
into effect so here are some examples

641
00:29:22,790 --> 00:29:27,830
which for those of you who have Mac's or

642
00:29:25,760 --> 00:29:31,190
windows with Bonjour windows installed

643
00:29:27,830 --> 00:29:32,659
you can try these on different terminal

644
00:29:31,190 --> 00:29:35,780
windows on one machine or on different

645
00:29:32,660 --> 00:29:37,940
machines that example shows advertising

646
00:29:35,780 --> 00:29:41,240
a service called test of service type

647
00:29:37,940 --> 00:29:43,490
underscore test browsing to find those

648
00:29:41,240 --> 00:29:48,950
instances and finally looking up the

649
00:29:43,490 --> 00:29:52,970
connection information so that's how you

650
00:29:48,950 --> 00:29:56,690
prototype with the command line tool for

651
00:29:52,970 --> 00:30:00,050
programming you'll want to use C API s'

652
00:29:56,690 --> 00:30:03,830
or Java or Python or whatever language

653
00:30:00,050 --> 00:30:07,070
you're using I'm going to talk here

654
00:30:03,830 --> 00:30:09,949
about the C API that are defined in DNS

655
00:30:07,070 --> 00:30:11,990
underscore SD dot H that is what has

656
00:30:09,950 --> 00:30:15,500
been used since we started doing this on

657
00:30:11,990 --> 00:30:17,450
Mac OS and iOS if you install MD and SD

658
00:30:15,500 --> 00:30:20,630
on Linux it's the same API if you

659
00:30:17,450 --> 00:30:22,520
install our he ever he has its own API

660
00:30:20,630 --> 00:30:24,260
but it also has a compatibility layer

661
00:30:22,520 --> 00:30:28,660
that supports the same API s-- and

662
00:30:24,260 --> 00:30:28,660
Bonjour for Windows has the same API

663
00:30:29,440 --> 00:30:35,680
Android additionally has its own Java

664
00:30:32,720 --> 00:30:39,290
based API so they were introduced in

665
00:30:35,680 --> 00:30:41,510
jellybean so there's a link there which

666
00:30:39,290 --> 00:30:45,320
you can get in the PDF to find the

667
00:30:41,510 --> 00:30:47,390
documentation for that Windows

668
00:30:45,320 --> 00:30:49,220
similarly when they did their own

669
00:30:47,390 --> 00:30:51,500
implementation they had a slightly

670
00:30:49,220 --> 00:30:55,730
different API and the documentation is

671
00:30:51,500 --> 00:30:58,180
there but I'm going to talk about the C

672
00:30:55,730 --> 00:31:01,100
API so that I'm most familiar with here

673
00:30:58,180 --> 00:31:03,260
this is how you register a service there

674
00:31:01,100 --> 00:31:05,870
are a bunch of parameters the first

675
00:31:03,260 --> 00:31:08,270
parameter is actually an out parameter

676
00:31:05,870 --> 00:31:10,239
that is the result of doing this call

677
00:31:08,270 --> 00:31:13,190
that is a service discovery reference

678
00:31:10,240 --> 00:31:15,620
there are some flags which are optional

679
00:31:13,190 --> 00:31:17,390
typically those are zero you can specify

680
00:31:15,620 --> 00:31:19,219
an interface index if you want to

681
00:31:17,390 --> 00:31:21,650
constrain it to one physical interface

682
00:31:19,220 --> 00:31:24,890
again normally you just pass 0 you

683
00:31:21,650 --> 00:31:28,700
advertise on all interfaces you specify

684
00:31:24,890 --> 00:31:30,890
the name type domain if you're

685
00:31:28,700 --> 00:31:34,070
advertising a service on a different

686
00:31:30,890 --> 00:31:37,550
host then you can do that that's for

687
00:31:34,070 --> 00:31:40,159
proxies typically don't be null you

688
00:31:37,550 --> 00:31:42,710
specify the port you're listening on if

689
00:31:40,160 --> 00:31:45,800
you have any key value pairs then you

690
00:31:42,710 --> 00:31:47,440
pass a txt record and this is all of

691
00:31:45,800 --> 00:31:49,399
these routines take a callback function

692
00:31:47,440 --> 00:31:51,590
which gives you a synchronous

693
00:31:49,400 --> 00:31:54,590
notifications of events now if you

694
00:31:51,590 --> 00:31:56,899
compare this function with the Browse

695
00:31:54,590 --> 00:31:59,419
function you'll see a bunch of the

696
00:31:56,900 --> 00:32:01,580
parameters are the same but with some

697
00:31:59,420 --> 00:32:03,020
missed out you don't specify the name

698
00:32:01,580 --> 00:32:04,879
because you don't know the name that

699
00:32:03,020 --> 00:32:08,030
you're looking for you don't specify

700
00:32:04,880 --> 00:32:09,980
host and port but the other parameters

701
00:32:08,030 --> 00:32:12,460
take the same form and likewise for

702
00:32:09,980 --> 00:32:14,900
resolve it's extremely similar

703
00:32:12,460 --> 00:32:17,270
you've now specify the name you're

704
00:32:14,900 --> 00:32:19,490
looking for but things like the port and

705
00:32:17,270 --> 00:32:23,330
the text record are the results you get

706
00:32:19,490 --> 00:32:26,330
when your callback is invoked so one

707
00:32:23,330 --> 00:32:29,679
thing you may have noticed here is all

708
00:32:26,330 --> 00:32:32,929
of these calls are asynchronous and

709
00:32:29,680 --> 00:32:36,230
that's because networking is at its

710
00:32:32,930 --> 00:32:39,410
heart asynchronous if you browse the

711
00:32:36,230 --> 00:32:41,240
network for services and the ethernet

712
00:32:39,410 --> 00:32:43,400
cable is not connected or the Wi-Fi

713
00:32:41,240 --> 00:32:47,000
non-associated you're not going to find

714
00:32:43,400 --> 00:32:49,490
anything and it's not helpful for the

715
00:32:47,000 --> 00:32:52,430
call to fail and the application has to

716
00:32:49,490 --> 00:32:55,130
then have a retry loop maybe wait for

717
00:32:52,430 --> 00:32:57,350
the configuration to change it's much

718
00:32:55,130 --> 00:33:00,530
easier to have the API just handle that

719
00:32:57,350 --> 00:33:03,050
so when you start a call going that call

720
00:33:00,530 --> 00:33:06,170
will run until you change your mind and

721
00:33:03,050 --> 00:33:07,430
tell it to stop and any changes in the

722
00:33:06,170 --> 00:33:09,530
environmental configuration that

723
00:33:07,430 --> 00:33:13,610
happened during that time I just handled

724
00:33:09,530 --> 00:33:15,470
automatically the way that a synchrony

725
00:33:13,610 --> 00:33:16,790
is handled because over the years there

726
00:33:15,470 --> 00:33:19,730
have been many different models of

727
00:33:16,790 --> 00:33:21,800
asynchrony threads used to be in fashion

728
00:33:19,730 --> 00:33:25,040
but it can be difficult to get that

729
00:33:21,800 --> 00:33:30,560
right with race conditions event loops

730
00:33:25,040 --> 00:33:34,220
are now more popular there are things

731
00:33:30,560 --> 00:33:37,429
like Apple has CF run loop there is Lib

732
00:33:34,220 --> 00:33:38,990
dispatch there's selects and Pole and K

733
00:33:37,430 --> 00:33:41,870
events there are many different ways to

734
00:33:38,990 --> 00:33:43,670
have an event-driven system the way you

735
00:33:41,870 --> 00:33:46,639
integrate this into whatever system

736
00:33:43,670 --> 00:33:49,910
you're using is you extract the

737
00:33:46,640 --> 00:33:53,060
underlying file descriptor from this SD

738
00:33:49,910 --> 00:33:54,710
reference object and then you add that

739
00:33:53,060 --> 00:33:56,899
file descriptor to whatever your event

740
00:33:54,710 --> 00:33:59,690
handling mechanism is and then when you

741
00:33:56,900 --> 00:34:02,120
get notified that there is data readable

742
00:33:59,690 --> 00:34:03,980
on that file descriptor you call DNS

743
00:34:02,120 --> 00:34:05,600
service process results it will parse

744
00:34:03,980 --> 00:34:09,889
that data and call your callback

745
00:34:05,600 --> 00:34:11,989
function as appropriate if you get the

746
00:34:09,889 --> 00:34:15,139
open source M&F responder codes that I

747
00:34:11,989 --> 00:34:17,149
pointed you to earlier then in there is

748
00:34:15,139 --> 00:34:19,520
the source code for the DNS SD command

749
00:34:17,150 --> 00:34:22,340
and that is a great source to crib

750
00:34:19,520 --> 00:34:25,280
little code snippets for the thing that

751
00:34:22,340 --> 00:34:27,170
you want to do the the main function of

752
00:34:25,280 --> 00:34:30,050
that is basically a big switch statement

753
00:34:27,170 --> 00:34:31,850
for each of the operations and you just

754
00:34:30,050 --> 00:34:33,050
pick the case in that switch statement

755
00:34:31,850 --> 00:34:34,370
that applies to what you're doing and

756
00:34:33,050 --> 00:34:37,360
that will show you how to register

757
00:34:34,370 --> 00:34:37,359
browser resolve

758
00:34:40,839 --> 00:34:47,469
a synchrony is really important for a

759
00:34:43,179 --> 00:34:49,859
good user experience and you may notice

760
00:34:47,469 --> 00:34:52,690
that you will not find a refresh button

761
00:34:49,859 --> 00:34:56,078
anywhere in any of the network browsing

762
00:34:52,690 --> 00:34:59,259
API a UI that Apple ships and that's

763
00:34:56,079 --> 00:35:01,359
because it simply calls the API the

764
00:34:59,259 --> 00:35:02,920
Browse call runs asynchronously as

765
00:35:01,359 --> 00:35:05,739
things come and go

766
00:35:02,920 --> 00:35:07,359
the results are updated if you do a

767
00:35:05,739 --> 00:35:09,339
browse with no networking you find

768
00:35:07,359 --> 00:35:11,170
nothing you associate with Wi-Fi you

769
00:35:09,339 --> 00:35:14,410
find some results you turn Wi-Fi off

770
00:35:11,170 --> 00:35:16,450
those results go away again if you roam

771
00:35:14,410 --> 00:35:18,279
to a different access point then the old

772
00:35:16,450 --> 00:35:21,129
results go away and new results are

773
00:35:18,279 --> 00:35:23,079
discovered this continuous change

774
00:35:21,130 --> 00:35:24,279
monitoring will happen indefinitely for

775
00:35:23,079 --> 00:35:27,700
as long as you leave that browser

776
00:35:24,279 --> 00:35:29,739
running for hours days weeks in

777
00:35:27,700 --> 00:35:31,299
principle if you can write an

778
00:35:29,739 --> 00:35:32,739
application please don't browse for

779
00:35:31,299 --> 00:35:37,420
weeks that's really hard on the network

780
00:35:32,739 --> 00:35:39,549
but if you did it would work the

781
00:35:37,420 --> 00:35:42,999
asynchronous results are worth

782
00:35:39,549 --> 00:35:44,920
mentioning in a bit more detail they

783
00:35:42,999 --> 00:35:47,319
also give us something really useful for

784
00:35:44,920 --> 00:35:49,390
free and that is event notification

785
00:35:47,319 --> 00:35:51,369
there are many systems then in addition

786
00:35:49,390 --> 00:35:53,319
to everything else they have a

787
00:35:51,369 --> 00:35:56,979
completely separate publish/subscribe

788
00:35:53,319 --> 00:36:00,279
mechanism for events well we don't need

789
00:35:56,979 --> 00:36:02,649
that because having the ability to do

790
00:36:00,279 --> 00:36:06,249
continuous operations that are updated

791
00:36:02,650 --> 00:36:09,009
as the environment changes means that

792
00:36:06,249 --> 00:36:13,660
those give us notifications as well so

793
00:36:09,009 --> 00:36:16,960
here is an example you have some service

794
00:36:13,660 --> 00:36:19,420
on the network it registers its service

795
00:36:16,960 --> 00:36:21,969
to published on the network as date

796
00:36:19,420 --> 00:36:23,589
Rebeck that service changes let's say

797
00:36:21,969 --> 00:36:26,589
the ink level in the printer or the

798
00:36:23,589 --> 00:36:28,869
paper in the paper tray it can call DNS

799
00:36:26,589 --> 00:36:32,410
service update record to update its text

800
00:36:28,869 --> 00:36:34,690
record with new data and a client that

801
00:36:32,410 --> 00:36:35,609
wants to be informed of those changes as

802
00:36:34,690 --> 00:36:38,890
they happen

803
00:36:35,609 --> 00:36:40,660
uses DNS service query record which is

804
00:36:38,890 --> 00:36:42,969
not a one-shot query it's an ongoing

805
00:36:40,660 --> 00:36:44,890
monitoring operation it will continue

806
00:36:42,969 --> 00:36:48,430
giving you callbacks until you cancel it

807
00:36:44,890 --> 00:36:50,348
and that would for example allow a

808
00:36:48,430 --> 00:36:52,239
client to monitor the ink level of the

809
00:36:50,349 --> 00:36:54,700
printer and see it going down over time

810
00:36:52,239 --> 00:36:57,160
without having to continuously Paul

811
00:36:54,700 --> 00:36:59,770
every five minutes or every five seconds

812
00:36:57,160 --> 00:37:01,569
to find out the data so if you need

813
00:36:59,770 --> 00:37:05,670
something like this this is an

814
00:37:01,570 --> 00:37:05,670
incredibly simple and powerful mechanism

815
00:37:05,970 --> 00:37:13,509
this works for both local and remote

816
00:37:09,330 --> 00:37:17,170
services for local services when the

817
00:37:13,510 --> 00:37:19,000
publisher updates the record a multicast

818
00:37:17,170 --> 00:37:21,790
announcement is sent out to all the

819
00:37:19,000 --> 00:37:24,480
peers on the local network and listening

820
00:37:21,790 --> 00:37:27,460
clients get a callback notifying them

821
00:37:24,480 --> 00:37:30,160
the remote case is more interesting and

822
00:37:27,460 --> 00:37:33,100
this was more work to build the

823
00:37:30,160 --> 00:37:36,390
publisher sends a DNS update to the

824
00:37:33,100 --> 00:37:39,160
registry to update its information and

825
00:37:36,390 --> 00:37:42,430
clients that are interested use dns push

826
00:37:39,160 --> 00:37:46,060
notifications to register that interest

827
00:37:42,430 --> 00:37:48,220
and when the data is updated the

828
00:37:46,060 --> 00:37:50,560
registry then automatically informs any

829
00:37:48,220 --> 00:37:53,259
interested clients so that lets remote

830
00:37:50,560 --> 00:37:56,140
clients across the building or across

831
00:37:53,260 --> 00:37:57,940
the world get live updates to

832
00:37:56,140 --> 00:38:04,540
information without having to

833
00:37:57,940 --> 00:38:07,720
continuously poll to find it so some

834
00:38:04,540 --> 00:38:11,350
tips if you're building browsing UI you

835
00:38:07,720 --> 00:38:13,919
don't need a refresh button we really

836
00:38:11,350 --> 00:38:17,170
request that you don't leave browse

837
00:38:13,920 --> 00:38:19,540
operations running indefinitely there is

838
00:38:17,170 --> 00:38:21,640
a temptation when your application

839
00:38:19,540 --> 00:38:23,290
launches to start a browser in the

840
00:38:21,640 --> 00:38:25,029
background and keep it running so that

841
00:38:23,290 --> 00:38:27,970
you keep a data structure in memory hot

842
00:38:25,030 --> 00:38:29,290
just in case the user wants it that is

843
00:38:27,970 --> 00:38:32,500
very expensive on the network

844
00:38:29,290 --> 00:38:36,210
particularly Wi-Fi multicast on Wi-Fi is

845
00:38:32,500 --> 00:38:40,690
very inefficient and very slow and

846
00:38:36,210 --> 00:38:46,210
consumes a lot of airtime unicast Wi-Fi

847
00:38:40,690 --> 00:38:48,460
goes up tens hundreds in theory up to

848
00:38:46,210 --> 00:38:52,330
1.3 gigabits per second and higher now

849
00:38:48,460 --> 00:38:56,290
with Wi-Fi six multicast is down at the

850
00:38:52,330 --> 00:38:59,290
single digit 1 to 6 megabits per second

851
00:38:56,290 --> 00:39:02,020
so a single multicast takes as much

852
00:38:59,290 --> 00:39:05,110
airtime as 100 unicast s' it is very

853
00:39:02,020 --> 00:39:07,060
very expensive so casually browsing in

854
00:39:05,110 --> 00:39:08,580
the background can consume a lot of

855
00:39:07,060 --> 00:39:12,369
shared network resources

856
00:39:08,580 --> 00:39:15,880
so the better way to do it is if the

857
00:39:12,369 --> 00:39:17,770
user brings up a browsing UI for

858
00:39:15,880 --> 00:39:20,440
instance they tap the air print button

859
00:39:17,770 --> 00:39:23,619
that's the time to start browsing show

860
00:39:20,440 --> 00:39:25,780
the results you will see that it is

861
00:39:23,619 --> 00:39:27,640
already fast enough that the results

862
00:39:25,780 --> 00:39:30,670
appear within less than a second so

863
00:39:27,640 --> 00:39:33,759
there's no real incentive to keep a list

864
00:39:30,670 --> 00:39:36,369
in memory in advance and then when the

865
00:39:33,760 --> 00:39:42,510
user dismisses the UI stop the Browse

866
00:39:36,369 --> 00:39:45,640
operation another tip as a general rule

867
00:39:42,510 --> 00:39:47,290
users get frustrated when menus change

868
00:39:45,640 --> 00:39:50,589
underneath the mouse as they're trying

869
00:39:47,290 --> 00:39:53,859
to select something whereas windows that

870
00:39:50,590 --> 00:39:56,680
change are still can be confusing but

871
00:39:53,859 --> 00:39:59,290
they're less objectionable so we really

872
00:39:56,680 --> 00:40:01,029
recommend that you bring up a window

873
00:39:59,290 --> 00:40:02,680
showing brows results rather than

874
00:40:01,030 --> 00:40:04,600
displaying it in a menu that then

875
00:40:02,680 --> 00:40:08,618
shuffles around underneath the user's

876
00:40:04,600 --> 00:40:10,390
mouse and the final step is that there

877
00:40:08,619 --> 00:40:13,210
is a very deliberate conscious reason

878
00:40:10,390 --> 00:40:18,040
that we have the three basic operations

879
00:40:13,210 --> 00:40:22,390
use enumerate offer user numerate they

880
00:40:18,040 --> 00:40:25,390
are they're separated so that they can

881
00:40:22,390 --> 00:40:28,029
be done separately the enumerate step

882
00:40:25,390 --> 00:40:30,520
will find everything on the network and

883
00:40:28,030 --> 00:40:31,990
show the use of the names at that point

884
00:40:30,520 --> 00:40:34,090
you don't need to look at the IP

885
00:40:31,990 --> 00:40:36,549
addresses because the user hasn't chosen

886
00:40:34,090 --> 00:40:38,350
which one to connect to yet or in the

887
00:40:36,550 --> 00:40:41,200
case of software the software client

888
00:40:38,350 --> 00:40:43,540
hasn't chosen which one to connect to so

889
00:40:41,200 --> 00:40:45,669
it's only when you actually want to

890
00:40:43,540 --> 00:40:51,220
connect that you then look up the

891
00:40:45,670 --> 00:40:54,340
address for that particular service in

892
00:40:51,220 --> 00:40:56,919
many cases you browse the network to

893
00:40:54,340 --> 00:40:59,890
find something so the familiar example

894
00:40:56,920 --> 00:41:01,510
is setting up a printer you go into the

895
00:40:59,890 --> 00:41:06,250
printer preferences you click plus you

896
00:41:01,510 --> 00:41:08,109
add a printer some tips here we have

897
00:41:06,250 --> 00:41:09,760
seen people make this mistake when you

898
00:41:08,109 --> 00:41:12,520
find the printer if you saved the IP

899
00:41:09,760 --> 00:41:14,610
address well with DHCP that might be a

900
00:41:12,520 --> 00:41:17,970
different address tomorrow

901
00:41:14,610 --> 00:41:20,160
if you save the address and port well

902
00:41:17,970 --> 00:41:23,310
with dynamic ports the port number might

903
00:41:20,160 --> 00:41:25,399
be different tomorrow so the right way

904
00:41:23,310 --> 00:41:28,440
to think about this is late binding

905
00:41:25,400 --> 00:41:31,440
store the name type domain tuple of the

906
00:41:28,440 --> 00:41:34,380
service that were selected and then at

907
00:41:31,440 --> 00:41:36,060
time of use you look that up to the

908
00:41:34,380 --> 00:41:43,800
current address and port that's in use

909
00:41:36,060 --> 00:41:48,980
at that moment in time so here's an

910
00:41:43,800 --> 00:41:52,470
example of information you can find and

911
00:41:48,980 --> 00:41:54,930
that first column on the left is what

912
00:41:52,470 --> 00:41:57,810
you find by browsing the network you get

913
00:41:54,930 --> 00:41:59,640
a list of names and that is a small

914
00:41:57,810 --> 00:42:03,540
amount it is seven bits of information

915
00:41:59,640 --> 00:42:06,000
and if you look at one row on that chart

916
00:42:03,540 --> 00:42:09,210
that is the detailed information about a

917
00:42:06,000 --> 00:42:11,120
particular service but if you browse the

918
00:42:09,210 --> 00:42:13,500
network and resolve everything you find

919
00:42:11,120 --> 00:42:15,450
you're finding all the information about

920
00:42:13,500 --> 00:42:18,300
all the services and that is a very

921
00:42:15,450 --> 00:42:20,279
expensive operation especially as I said

922
00:42:18,300 --> 00:42:22,170
on a shared network like Wi-Fi where

923
00:42:20,280 --> 00:42:23,670
you're consuming everybody else has

924
00:42:22,170 --> 00:42:27,860
shared resources to look at this

925
00:42:23,670 --> 00:42:27,860
information that you probably won't need

926
00:42:28,010 --> 00:42:35,900
so final advice here only resolved when

927
00:42:33,840 --> 00:42:40,230
you actually need the information

928
00:42:35,900 --> 00:42:41,670
because IP addresses change and you want

929
00:42:40,230 --> 00:42:46,920
to get the latest information at time of

930
00:42:41,670 --> 00:42:51,090
use another thing to note is when you

931
00:42:46,920 --> 00:42:53,490
resolve modern devices may have multiple

932
00:42:51,090 --> 00:42:55,680
addresses they may have v4 and v6 they

933
00:42:53,490 --> 00:42:59,129
have may have link local and larger

934
00:42:55,680 --> 00:43:01,859
scope addresses and if you just take the

935
00:42:59,130 --> 00:43:03,090
first one and that doesn't work and then

936
00:43:01,860 --> 00:43:05,670
you fail that's not a good user

937
00:43:03,090 --> 00:43:08,700
experience we have known this for a few

938
00:43:05,670 --> 00:43:10,560
years now we highly recommend you follow

939
00:43:08,700 --> 00:43:12,450
the guidance for happy eyeballs

940
00:43:10,560 --> 00:43:15,270
now you can implement this yourself

941
00:43:12,450 --> 00:43:18,120
which is a bunch of work or you can use

942
00:43:15,270 --> 00:43:21,420
an API that does it for you and here is

943
00:43:18,120 --> 00:43:23,580
an example from Apple suite of api's

944
00:43:21,420 --> 00:43:26,460
using network connection which is our

945
00:43:23,580 --> 00:43:30,930
current recommended API suite

946
00:43:26,460 --> 00:43:32,910
you simply tell it the service name type

947
00:43:30,930 --> 00:43:35,520
and domain you want to connect to and it

948
00:43:32,910 --> 00:43:37,618
will handle resolving getting

949
00:43:35,520 --> 00:43:40,410
asynchronous results sorting the

950
00:43:37,619 --> 00:43:42,720
candidates into a logical order trying

951
00:43:40,410 --> 00:43:45,058
each address in turn if it doesn't get

952
00:43:42,720 --> 00:43:45,899
an acknowledgement after some number of

953
00:43:45,059 --> 00:43:48,809
milliseconds

954
00:43:45,900 --> 00:43:50,550
moving on to start a second parallel

955
00:43:48,809 --> 00:43:54,300
connection attempt to the next candidate

956
00:43:50,550 --> 00:43:56,250
and so on so we really recommend you use

957
00:43:54,300 --> 00:44:04,220
api's that implement happy eyeballs it

958
00:43:56,250 --> 00:44:07,559
gives a much better user experience so

959
00:44:04,220 --> 00:44:11,490
this is the point where I often have

960
00:44:07,559 --> 00:44:13,109
people say this doesn't sound so hard we

961
00:44:11,490 --> 00:44:16,729
can just we invent our own broadcast

962
00:44:13,109 --> 00:44:19,348
protocol we don't need to use this and I

963
00:44:16,730 --> 00:44:21,450
understand why it seems that way because

964
00:44:19,349 --> 00:44:23,160
it doesn't seem like it's very hard you

965
00:44:21,450 --> 00:44:25,770
you broadcast some packets you listen

966
00:44:23,160 --> 00:44:26,819
you answer and when we started this it

967
00:44:25,770 --> 00:44:29,069
didn't seem that hard

968
00:44:26,819 --> 00:44:31,200
appletalk did name binding protocol we

969
00:44:29,069 --> 00:44:33,440
thought we'll do the same thing a year

970
00:44:31,200 --> 00:44:36,089
or two work this will be finished and

971
00:44:33,440 --> 00:44:37,829
what we found is to build a really

972
00:44:36,089 --> 00:44:39,569
really good service discovery protocol

973
00:44:37,829 --> 00:44:43,260
there are lots of things you have to

974
00:44:39,569 --> 00:44:46,170
take into account one obvious one is

975
00:44:43,260 --> 00:44:48,599
that Wi-Fi is very lossy so you have

976
00:44:46,170 --> 00:44:50,190
have retransmission okay no big deal

977
00:44:48,599 --> 00:44:52,650
everybody knows retransmission an

978
00:44:50,190 --> 00:44:55,500
exponential back-off there are questions

979
00:44:52,650 --> 00:44:59,579
about how you tune and tailor that to

980
00:44:55,500 --> 00:45:03,390
give the right performance Wi-Fi

981
00:44:59,579 --> 00:45:06,510
multicast is also very slow so we have a

982
00:45:03,390 --> 00:45:09,210
lot of techniques to maximize the

983
00:45:06,510 --> 00:45:13,020
efficiency of how we use the network one

984
00:45:09,210 --> 00:45:16,589
is if if you do a multicast query for

985
00:45:13,020 --> 00:45:18,599
IPP printers and I see it then because

986
00:45:16,589 --> 00:45:21,480
all the responses are sent by multicast

987
00:45:18,599 --> 00:45:24,510
and I see those responses and I

988
00:45:21,480 --> 00:45:27,089
opportunistically cache them if you do a

989
00:45:24,510 --> 00:45:30,150
query I will see the same answers you do

990
00:45:27,089 --> 00:45:33,000
so if later the user on this iPhone

991
00:45:30,150 --> 00:45:35,400
presses the air print button we don't

992
00:45:33,000 --> 00:45:37,559
need to do another browse because I got

993
00:45:35,400 --> 00:45:39,430
to piggyback on the Browse that you did

994
00:45:37,559 --> 00:45:42,400
and I already have the results

995
00:45:39,430 --> 00:45:44,440
so duplicate query suppression prevents

996
00:45:42,400 --> 00:45:48,460
multiple devices on the network from

997
00:45:44,440 --> 00:45:49,150
doing the same query to minimize network

998
00:45:48,460 --> 00:45:52,000
traffic

999
00:45:49,150 --> 00:45:54,040
we have long cache lifetimes so once

1000
00:45:52,000 --> 00:45:55,930
you've seen something it stays in the

1001
00:45:54,040 --> 00:45:59,440
cache for a long time now I'll come back

1002
00:45:55,930 --> 00:46:04,509
to how we manage that because of

1003
00:45:59,440 --> 00:46:07,569
retransmission there if you do it

1004
00:46:04,510 --> 00:46:09,819
naively every time you retransmit you

1005
00:46:07,569 --> 00:46:11,950
get the same set of devices answering so

1006
00:46:09,819 --> 00:46:14,500
you say I'm looking for IP printers and

1007
00:46:11,950 --> 00:46:16,598
you get 10 replies well there might be

1008
00:46:14,500 --> 00:46:18,430
packet loss maybe there's one that you

1009
00:46:16,599 --> 00:46:20,140
missed so Yuri transmitted and you get

1010
00:46:18,430 --> 00:46:21,848
the same 10 replace and Yuri transmit

1011
00:46:20,140 --> 00:46:26,410
and you get the same can replace this is

1012
00:46:21,849 --> 00:46:28,990
very wasteful so the queries include

1013
00:46:26,410 --> 00:46:31,569
known answer lists which in effect say

1014
00:46:28,990 --> 00:46:34,058
this is what I'm asking for this is what

1015
00:46:31,569 --> 00:46:35,980
I already know so if you're in the list

1016
00:46:34,059 --> 00:46:39,400
you can keep quiet is there anybody else

1017
00:46:35,980 --> 00:46:42,099
that I missed I don't know any other

1018
00:46:39,400 --> 00:46:44,559
discovery protocol that implements known

1019
00:46:42,099 --> 00:46:47,290
answer suppression there's also

1020
00:46:44,559 --> 00:46:49,599
duplicate answer suppression which comes

1021
00:46:47,290 --> 00:46:53,170
into play when you have proxies now for

1022
00:46:49,599 --> 00:46:55,059
various fault tolerance and reliability

1023
00:46:53,170 --> 00:46:57,250
reasons and other reasons I'll come to

1024
00:46:55,059 --> 00:46:58,839
later you can have proxies on the

1025
00:46:57,250 --> 00:47:00,160
network that answer on behalf of other

1026
00:46:58,839 --> 00:47:03,250
devices and you can have multiple

1027
00:47:00,160 --> 00:47:06,460
proxies but you don't want them all

1028
00:47:03,250 --> 00:47:08,859
answering so the answers are delayed by

1029
00:47:06,460 --> 00:47:12,220
a random interval and the answering

1030
00:47:08,859 --> 00:47:13,960
devices also listen for answers so if

1031
00:47:12,220 --> 00:47:15,430
they were planning to answer but then

1032
00:47:13,960 --> 00:47:16,930
they see the same answer come from

1033
00:47:15,430 --> 00:47:19,359
somebody else they can suppress their

1034
00:47:16,930 --> 00:47:22,180
own answer so this is another one of the

1035
00:47:19,359 --> 00:47:25,690
techniques that's used to minimize the

1036
00:47:22,180 --> 00:47:27,129
amount of multicast traffic now I talked

1037
00:47:25,690 --> 00:47:30,400
about the exponential back-off for

1038
00:47:27,130 --> 00:47:33,220
queries again if you do this naively you

1039
00:47:30,400 --> 00:47:36,339
get a very poor user experience because

1040
00:47:33,220 --> 00:47:36,879
you query you query again you wait a bit

1041
00:47:36,339 --> 00:47:38,759
longer

1042
00:47:36,880 --> 00:47:42,119
you query again you wait even longer

1043
00:47:38,760 --> 00:47:44,920
pretty soon it settles down to a

1044
00:47:42,119 --> 00:47:46,030
quiescent query rate of no more than one

1045
00:47:44,920 --> 00:47:48,069
query per hour

1046
00:47:46,030 --> 00:47:50,230
now if a new service comes on the

1047
00:47:48,069 --> 00:47:53,640
network waiting up to an hour to know

1048
00:47:50,230 --> 00:47:56,980
about it is a not a good user experience

1049
00:47:53,640 --> 00:47:59,109
so hand in hand with the queer is an

1050
00:47:56,980 --> 00:48:01,720
exponential back-off when a new service

1051
00:47:59,110 --> 00:48:05,530
joins the network and that includes both

1052
00:48:01,720 --> 00:48:07,810
starting up a service or starting up a

1053
00:48:05,530 --> 00:48:10,000
service and then connecting the cable or

1054
00:48:07,810 --> 00:48:12,400
then associating to Wi-Fi and those

1055
00:48:10,000 --> 00:48:15,280
linked change events are detected when

1056
00:48:12,400 --> 00:48:17,650
the new connectivity happens then the

1057
00:48:15,280 --> 00:48:19,840
service sends gratuitous announcements

1058
00:48:17,650 --> 00:48:21,850
so that if there are clients who have

1059
00:48:19,840 --> 00:48:23,710
been listening for a long time they

1060
00:48:21,850 --> 00:48:25,830
immediately get notified of the new

1061
00:48:23,710 --> 00:48:35,680
service so that gives you very rapid

1062
00:48:25,830 --> 00:48:39,460
discovery without rapid polling another

1063
00:48:35,680 --> 00:48:41,319
aspect is we manage name uniqueness

1064
00:48:39,460 --> 00:48:43,630
which is why you don't need to have

1065
00:48:41,320 --> 00:48:46,870
names unique from the factory you don't

1066
00:48:43,630 --> 00:48:49,690
need MAC addresses you can have simple

1067
00:48:46,870 --> 00:48:53,230
names and if the name is detected

1068
00:48:49,690 --> 00:48:55,660
already in use then the API will rename

1069
00:48:53,230 --> 00:48:57,940
your service with a two at the end or if

1070
00:48:55,660 --> 00:48:59,500
you prefer it will call your callback

1071
00:48:57,940 --> 00:49:04,030
function and give your code the

1072
00:48:59,500 --> 00:49:06,550
opportunity to pick a new name so I

1073
00:49:04,030 --> 00:49:11,020
talked about the long cache lifetimes

1074
00:49:06,550 --> 00:49:14,590
this is good for efficiency but it's not

1075
00:49:11,020 --> 00:49:16,540
good when things go away now if a

1076
00:49:14,590 --> 00:49:19,030
service shuts down cleanly it sends

1077
00:49:16,540 --> 00:49:22,630
goodbye packets on the network but

1078
00:49:19,030 --> 00:49:25,450
suppose the power fails then it goes

1079
00:49:22,630 --> 00:49:29,050
away without saying it's going away and

1080
00:49:25,450 --> 00:49:31,299
that data will remain in caches now as

1081
00:49:29,050 --> 00:49:33,820
long as the user doesn't try to use the

1082
00:49:31,300 --> 00:49:35,770
service that's kind of benign it's sort

1083
00:49:33,820 --> 00:49:40,660
of like if the tree falls in a forest

1084
00:49:35,770 --> 00:49:42,250
and nobody's there do they care but at

1085
00:49:40,660 --> 00:49:44,080
the moment that user actually tries to

1086
00:49:42,250 --> 00:49:46,150
use that service and it doesn't work

1087
00:49:44,080 --> 00:49:47,890
that's when they get frustrated and if

1088
00:49:46,150 --> 00:49:49,540
they get an error saying can't connect

1089
00:49:47,890 --> 00:49:51,400
and they go back to the browser and it's

1090
00:49:49,540 --> 00:49:54,730
still there then they get really

1091
00:49:51,400 --> 00:49:57,130
frustrated so we do this lazy cache

1092
00:49:54,730 --> 00:50:00,370
cleanup where if there's a connection

1093
00:49:57,130 --> 00:50:04,750
failure we even though the cache record

1094
00:50:00,370 --> 00:50:06,580
might have 45 minutes to go we decide we

1095
00:50:04,750 --> 00:50:07,210
don't trust that and we do a couple of

1096
00:50:06,580 --> 00:50:09,549
queries

1097
00:50:07,210 --> 00:50:11,559
and if it doesn't answer we remove it

1098
00:50:09,550 --> 00:50:13,420
prematurely from the cache so by the

1099
00:50:11,559 --> 00:50:17,589
time the user goes back to the Browse UI

1100
00:50:13,420 --> 00:50:18,940
that thing has disappeared and they at

1101
00:50:17,589 --> 00:50:21,578
least now have a mental model of what

1102
00:50:18,940 --> 00:50:23,559
happens they think oh somebody just

1103
00:50:21,579 --> 00:50:25,089
turned it off and they walk down hall

1104
00:50:23,559 --> 00:50:28,720
and find the printers turned off

1105
00:50:25,089 --> 00:50:30,369
well that's nest not necessarily true

1106
00:50:28,720 --> 00:50:32,439
maybe it wasn't just turned off maybe it

1107
00:50:30,369 --> 00:50:35,109
was turned off half an hour ago but it

1108
00:50:32,440 --> 00:50:36,790
doesn't matter because the user at least

1109
00:50:35,109 --> 00:50:38,020
has a mental model about what happened

1110
00:50:36,790 --> 00:50:42,069
and what to do about it that isn't

1111
00:50:38,020 --> 00:50:44,140
frustrating a refinement beyond that is

1112
00:50:42,069 --> 00:50:45,490
that if you try to print and fail and

1113
00:50:44,140 --> 00:50:48,129
remove the printer from your list

1114
00:50:45,490 --> 00:50:50,500
because it's turned off I passively

1115
00:50:48,130 --> 00:50:52,960
eavesdrop on that transaction I see you

1116
00:50:50,500 --> 00:50:56,290
querying I see no response coming back I

1117
00:50:52,960 --> 00:50:58,000
update my cache as well so one user

1118
00:50:56,290 --> 00:51:00,579
discovering that something is not

1119
00:50:58,000 --> 00:51:03,069
visible serves to inform all the devices

1120
00:51:00,579 --> 00:51:05,950
on the network to update their caches so

1121
00:51:03,069 --> 00:51:08,680
this is how we get rapid addition and

1122
00:51:05,950 --> 00:51:11,348
removal of entries without a high burden

1123
00:51:08,680 --> 00:51:14,470
of polling on the network and then a

1124
00:51:11,349 --> 00:51:15,910
final thing that is really important if

1125
00:51:14,470 --> 00:51:18,399
you want a good user experience is

1126
00:51:15,910 --> 00:51:20,680
mobility when you put a device to sleep

1127
00:51:18,400 --> 00:51:23,349
it sends goodbye messages saying its

1128
00:51:20,680 --> 00:51:26,109
services are no longer available with an

1129
00:51:23,349 --> 00:51:28,210
asterisk I'll come back to that and when

1130
00:51:26,109 --> 00:51:30,759
you wake it up it renounces when you

1131
00:51:28,210 --> 00:51:33,309
change your connectivity then it

1132
00:51:30,760 --> 00:51:35,829
reissues queries it renounces services

1133
00:51:33,309 --> 00:51:37,599
and that includes even subtle cases

1134
00:51:35,829 --> 00:51:40,299
where you roam to a different access

1135
00:51:37,599 --> 00:51:43,000
point you may be on the same Wi-Fi

1136
00:51:40,299 --> 00:51:45,280
network name with this same IP address

1137
00:51:43,000 --> 00:51:47,349
and the same default router address but

1138
00:51:45,280 --> 00:51:48,849
if you switch access points the

1139
00:51:47,349 --> 00:51:50,020
multicast domain you're in may be

1140
00:51:48,849 --> 00:51:52,750
different with a different set of

1141
00:51:50,020 --> 00:51:54,849
services handling all of these things in

1142
00:51:52,750 --> 00:51:57,900
your own code is really subtle which is

1143
00:51:54,849 --> 00:52:00,190
why you benefit if you use a very mature

1144
00:51:57,900 --> 00:52:04,089
implementation that has done all these

1145
00:52:00,190 --> 00:52:07,299
things I said the little asterisk about

1146
00:52:04,089 --> 00:52:12,190
going to sleep one of the things that we

1147
00:52:07,299 --> 00:52:14,259
support is a sleep proxy so you can have

1148
00:52:12,190 --> 00:52:16,569
a device if it supports wake-on-lan when

1149
00:52:14,260 --> 00:52:19,990
it goes to sleep it notifies a sleep

1150
00:52:16,569 --> 00:52:21,070
proxy of what its services are what its

1151
00:52:19,990 --> 00:52:23,109
name is what port it

1152
00:52:21,070 --> 00:52:24,880
listening on and that sleep proxy can

1153
00:52:23,110 --> 00:52:27,070
then act on its behalf and wake it up on

1154
00:52:24,880 --> 00:52:29,680
demand that way you can have devices

1155
00:52:27,070 --> 00:52:31,630
that offer services on the network that

1156
00:52:29,680 --> 00:52:36,089
are available even when they're asleep

1157
00:52:31,630 --> 00:52:39,280
to save power and finally using these

1158
00:52:36,090 --> 00:52:42,310
existing api's gives you remote

1159
00:52:39,280 --> 00:52:45,250
discovery like we use at the IETF it

1160
00:52:42,310 --> 00:52:46,870
also allows discovery via this thing

1161
00:52:45,250 --> 00:52:50,680
called the discovery proxy which I'll

1162
00:52:46,870 --> 00:52:52,779
mention so here's the example I was

1163
00:52:50,680 --> 00:52:54,640
talking about with a sleep proxy you may

1164
00:52:52,780 --> 00:52:56,890
have a USB printer plugged in with

1165
00:52:54,640 --> 00:52:59,770
printer sharing but the Macs are sleep

1166
00:52:56,890 --> 00:53:03,609
the sleep proxy on the network answers

1167
00:52:59,770 --> 00:53:08,350
on its behalf and wakes it up when the

1168
00:53:03,610 --> 00:53:12,420
client wants to talk to it a discovery

1169
00:53:08,350 --> 00:53:15,460
proxy is what lets you do discovery of

1170
00:53:12,420 --> 00:53:18,880
legacy multicast DNS devices from

1171
00:53:15,460 --> 00:53:20,800
multiple hops away now if this phone on

1172
00:53:18,880 --> 00:53:22,450
the Left sends multicast queries on the

1173
00:53:20,800 --> 00:53:24,940
local link it's not going to find the

1174
00:53:22,450 --> 00:53:27,759
printer because it's not on the same

1175
00:53:24,940 --> 00:53:29,440
link this is similar to the situation

1176
00:53:27,760 --> 00:53:34,180
here at the ITF when you're not in the

1177
00:53:29,440 --> 00:53:36,820
terminal room now at the IETF we have

1178
00:53:34,180 --> 00:53:38,589
expert volunteers who run the network

1179
00:53:36,820 --> 00:53:41,200
and the DNS and the Amanar you put the

1180
00:53:38,590 --> 00:53:43,000
records in but for normal users we want

1181
00:53:41,200 --> 00:53:45,669
to automate this and that's what the

1182
00:53:43,000 --> 00:53:49,060
discovery proxy does it acts like an

1183
00:53:45,670 --> 00:53:51,430
authoritative DNS server except when the

1184
00:53:49,060 --> 00:53:53,860
client sends it a query instead of

1185
00:53:51,430 --> 00:53:55,839
consulting a zone file that was typed in

1186
00:53:53,860 --> 00:53:57,820
by hand by an administrator it uses

1187
00:53:55,840 --> 00:54:00,550
multicast DNS on the local link to

1188
00:53:57,820 --> 00:54:02,950
discover what's available and then uses

1189
00:54:00,550 --> 00:54:07,060
that to generate the unicast answer back

1190
00:54:02,950 --> 00:54:10,810
to the client so using that we wouldn't

1191
00:54:07,060 --> 00:54:15,430
need the NOC volunteers at the IDF to

1192
00:54:10,810 --> 00:54:18,130
manually manage these records so to wrap

1193
00:54:15,430 --> 00:54:20,950
up there are some links in the PDF that

1194
00:54:18,130 --> 00:54:23,080
you can download if you're making a

1195
00:54:20,950 --> 00:54:25,720
hardware device then I strongly

1196
00:54:23,080 --> 00:54:27,700
recommend you do link local addressing

1197
00:54:25,720 --> 00:54:33,279
here are the RCS that tell you how to do

1198
00:54:27,700 --> 00:54:35,049
that for v4 and v6 here are the RFC

1199
00:54:33,280 --> 00:54:37,150
several years old at this point

1200
00:54:35,050 --> 00:54:39,220
for the basics of Discovery stuff that

1201
00:54:37,150 --> 00:54:42,870
I've been talking about and the Ayana

1202
00:54:39,220 --> 00:54:45,720
procedures for registering service types

1203
00:54:42,870 --> 00:54:48,759
there is a bunch of new work going on

1204
00:54:45,720 --> 00:54:52,330
the wide area unicast registration

1205
00:54:48,760 --> 00:54:54,160
builds on DNS dynamic updates with an

1206
00:54:52,330 --> 00:54:56,860
addition that Ted Levin has been working

1207
00:54:54,160 --> 00:54:59,830
on called Service registration protocol

1208
00:54:56,860 --> 00:55:03,130
which basically builds on DNS updates by

1209
00:54:59,830 --> 00:55:05,710
using 6/0 public keys to give a really

1210
00:55:03,130 --> 00:55:08,260
low overhead simple first-come

1211
00:55:05,710 --> 00:55:11,140
first-served but secure naming system

1212
00:55:08,260 --> 00:55:13,120
where any device can claim a name but

1213
00:55:11,140 --> 00:55:15,310
having claimed it and installed the key

1214
00:55:13,120 --> 00:55:16,990
it gives you some protection against

1215
00:55:15,310 --> 00:55:20,529
some other device coming along later and

1216
00:55:16,990 --> 00:55:22,540
masquerading as that DNS stateful

1217
00:55:20,530 --> 00:55:25,210
operations is the foundation for the

1218
00:55:22,540 --> 00:55:28,270
query side features we've been building

1219
00:55:25,210 --> 00:55:31,780
and that includes push notifications for

1220
00:55:28,270 --> 00:55:34,450
asynchronous change delivery and the

1221
00:55:31,780 --> 00:55:37,960
discovery proxy which lets you automate

1222
00:55:34,450 --> 00:55:40,569
this export of local multicast dns

1223
00:55:37,960 --> 00:55:41,710
information to the wider space and if

1224
00:55:40,570 --> 00:55:43,810
this seems like a mountain of

1225
00:55:41,710 --> 00:55:45,490
information you're right it is the final

1226
00:55:43,810 --> 00:55:48,310
link there is the roadmap documents

1227
00:55:45,490 --> 00:55:52,779
which gives you an overview of how all

1228
00:55:48,310 --> 00:55:55,420
these pieces fit together you can get

1229
00:55:52,780 --> 00:55:57,850
the source code from the ITF hackathon

1230
00:55:55,420 --> 00:56:00,250
github page that includes the source

1231
00:55:57,850 --> 00:56:02,529
code for the command-line tool there is

1232
00:56:00,250 --> 00:56:04,840
a great tool called discovery which is a

1233
00:56:02,530 --> 00:56:07,120
graphical version which is a free

1234
00:56:04,840 --> 00:56:08,800
download from the Mac App Store and then

1235
00:56:07,120 --> 00:56:12,279
finally if you're building a hardware

1236
00:56:08,800 --> 00:56:14,770
products you can get the Apple Bonjour

1237
00:56:12,280 --> 00:56:16,930
conformance test for free and run that

1238
00:56:14,770 --> 00:56:18,700
to validate your design because that is

1239
00:56:16,930 --> 00:56:20,649
designed to catch many of the common

1240
00:56:18,700 --> 00:56:22,919
implementation mistakes we've seen over

1241
00:56:20,650 --> 00:56:22,920
the earth

1242
00:56:23,070 --> 00:56:26,710
so the

1243
00:56:24,369 --> 00:56:28,779
- action here is if you're writing a

1244
00:56:26,710 --> 00:56:30,519
piece of software that currently expects

1245
00:56:28,779 --> 00:56:33,279
the use of the type in a name or an IP

1246
00:56:30,519 --> 00:56:35,439
address you can carry on doing that but

1247
00:56:33,279 --> 00:56:37,480
add a button for browsing as well so the

1248
00:56:35,440 --> 00:56:40,630
user can pick from what's available if

1249
00:56:37,480 --> 00:56:42,730
you're building a hardware product do

1250
00:56:40,630 --> 00:56:44,619
link local addressing because that what

1251
00:56:42,730 --> 00:56:48,130
gives your product bulletproof

1252
00:56:44,619 --> 00:56:51,190
reliability even when things like DHCP

1253
00:56:48,130 --> 00:56:54,880
are not available and use the

1254
00:56:51,190 --> 00:56:57,640
conformance test as a verification so

1255
00:56:54,880 --> 00:56:59,380
that is the end thank you for listening

1256
00:56:57,640 --> 00:57:03,368
and we have a minute or two for

1257
00:56:59,380 --> 00:57:05,289
questions if we have any oh and I do

1258
00:57:03,369 --> 00:57:08,079
remember to fill in the survey helps the

1259
00:57:05,289 --> 00:57:15,430
ED you team maintain the quality of the

1260
00:57:08,079 --> 00:57:17,710
tutorials we have a tie ATF sorry no

1261
00:57:15,430 --> 00:57:19,660
questions yeah the first one actually is

1262
00:57:17,710 --> 00:57:21,849
if our ten printers right bring at the

1263
00:57:19,660 --> 00:57:23,288
same time they will rename it their name

1264
00:57:21,849 --> 00:57:25,210
if on you know one to two hundred ten

1265
00:57:23,289 --> 00:57:27,460
yes but how physically you can identify

1266
00:57:25,210 --> 00:57:29,859
which printers with printer printer you

1267
00:57:27,460 --> 00:57:33,160
can print a test page which physically a

1268
00:57:29,859 --> 00:57:37,078
pizza but for IOT devices how can do

1269
00:57:33,160 --> 00:57:38,410
that is only the way is Madras right

1270
00:57:37,079 --> 00:57:40,059
questions right

1271
00:57:38,410 --> 00:57:42,190
the second question actually is if

1272
00:57:40,059 --> 00:57:45,970
printed number five I need to replace it

1273
00:57:42,190 --> 00:57:47,920
what is the procedure okay so there are

1274
00:57:45,970 --> 00:57:50,529
two questions there which is how do you

1275
00:57:47,920 --> 00:57:54,640
identify devices and how do you replace

1276
00:57:50,529 --> 00:57:57,549
devices excellent questions the way you

1277
00:57:54,640 --> 00:58:00,210
identify devices is somewhat

1278
00:57:57,549 --> 00:58:02,410
application-specific

1279
00:58:00,210 --> 00:58:06,700
there are a couple of ways this is done

1280
00:58:02,410 --> 00:58:09,640
in practice one is if you buy a device

1281
00:58:06,700 --> 00:58:11,980
and then buy another one the next one is

1282
00:58:09,640 --> 00:58:14,109
number two and then if a week later you

1283
00:58:11,980 --> 00:58:16,359
buy another one that's number three so

1284
00:58:14,109 --> 00:58:18,190
simply by virtue of the fact that you

1285
00:58:16,359 --> 00:58:20,848
had two device on the network and you

1286
00:58:18,190 --> 00:58:23,470
add a third one and now you have a

1287
00:58:20,849 --> 00:58:24,970
device number three on the network well

1288
00:58:23,470 --> 00:58:27,430
the one you just added is device number

1289
00:58:24,970 --> 00:58:32,738
three so in many cases that is not

1290
00:58:27,430 --> 00:58:34,299
confusing if you are getting 10 things

1291
00:58:32,739 --> 00:58:36,339
or a hundred things out of a box all at

1292
00:58:34,299 --> 00:58:38,460
the same time in connecting them then

1293
00:58:36,339 --> 00:58:41,160
you are absolutely right in

1294
00:58:38,460 --> 00:58:43,920
case the service discovery protocol is

1295
00:58:41,160 --> 00:58:47,790
not going to tell you which as which in

1296
00:58:43,920 --> 00:58:50,550
the case of IOT uh there is typically I

1297
00:58:47,790 --> 00:58:52,259
know with the home kit stuff is what I'm

1298
00:58:50,550 --> 00:58:54,119
familiar with but there are many IOT

1299
00:58:52,260 --> 00:58:56,849
home automation building automation

1300
00:58:54,119 --> 00:58:59,640
protocols there is normally a command to

1301
00:58:56,849 --> 00:59:02,490
have a device identify identify self by

1302
00:58:59,640 --> 00:59:04,920
blinking a status light so in your list

1303
00:59:02,490 --> 00:59:07,200
of things if you see number three and

1304
00:59:04,920 --> 00:59:12,109
you click identify you see which one has

1305
00:59:07,200 --> 00:59:12,109
the light blinking I still think that

1306
00:59:12,349 --> 00:59:17,880
saying device number three and seeing

1307
00:59:15,540 --> 00:59:19,710
the light is blinking and maybe getting

1308
00:59:17,880 --> 00:59:22,380
a post-it note and putting a three on it

1309
00:59:19,710 --> 00:59:24,660
is easier than putting a 12-digit MAC

1310
00:59:22,380 --> 00:59:26,250
address on it and then having to somehow

1311
00:59:24,660 --> 00:59:28,770
remember all those MAC addresses in your

1312
00:59:26,250 --> 00:59:30,060
head and remember this is often only the

1313
00:59:28,770 --> 00:59:32,130
bootstrap step this is the

1314
00:59:30,060 --> 00:59:34,619
out-of-the-box configuration what you

1315
00:59:32,130 --> 00:59:37,530
typically do with a bunch of IOT devices

1316
00:59:34,619 --> 00:59:38,339
is you give them names like bedroom

1317
00:59:37,530 --> 00:59:42,690
light switch

1318
00:59:38,339 --> 00:59:44,640
downstairs hallway you don't know user

1319
00:59:42,690 --> 00:59:46,260
wants to see a list of MAC addresses in

1320
00:59:44,640 --> 00:59:49,140
their home automation application they

1321
00:59:46,260 --> 00:59:51,410
want to see descriptive names so so that

1322
00:59:49,140 --> 00:59:53,670
is a case of the out-of-the-box

1323
00:59:51,410 --> 00:59:55,170
configuration step and then to answer

1324
00:59:53,670 --> 00:59:57,540
your second question what happens when

1325
00:59:55,170 --> 01:00:01,200
you replace it that is an excellent

1326
00:59:57,540 --> 01:00:05,009
example say printer number five breaks

1327
01:00:01,200 --> 01:00:07,109
and you go out and you replace it with

1328
01:00:05,010 --> 01:00:08,970
an identical printer because you love

1329
01:00:07,109 --> 01:00:10,980
the printer it was great that the

1330
01:00:08,970 --> 01:00:12,868
employees in your company loved it we

1331
01:00:10,980 --> 01:00:14,910
just want another one the same you buy

1332
01:00:12,869 --> 01:00:17,400
one exactly the same you give it the

1333
01:00:14,910 --> 01:00:19,710
same name through its web UI or whatever

1334
01:00:17,400 --> 01:00:23,460
configuration tool you put it on the

1335
01:00:19,710 --> 01:00:25,680
network and then because the names are

1336
01:00:23,460 --> 01:00:27,480
the primary identifier they could they

1337
01:00:25,680 --> 01:00:30,598
identify the logical service on the

1338
01:00:27,480 --> 01:00:31,890
network then the employees come to work

1339
01:00:30,599 --> 01:00:33,300
next day and they print on printed

1340
01:00:31,890 --> 01:00:35,520
number five and prints number five

1341
01:00:33,300 --> 01:00:37,530
answers and the paper comes out and the

1342
01:00:35,520 --> 01:00:40,710
fact that the atoms have been replaced

1343
01:00:37,530 --> 01:00:43,890
with new atoms doesn't change the fact

1344
01:00:40,710 --> 01:00:46,950
that the service is providing which is

1345
01:00:43,890 --> 01:00:48,990
printing paper in the copy room on the

1346
01:00:46,950 --> 01:00:50,520
third floor that service is the same

1347
01:00:48,990 --> 01:00:52,319
even though the physical thing has

1348
01:00:50,520 --> 01:00:55,259
changed and being able to give a

1349
01:00:52,320 --> 01:00:57,570
new thing the old name so it takes over

1350
01:00:55,260 --> 01:01:02,790
that role on the network is a really

1351
01:00:57,570 --> 01:01:04,380
useful capability okay I think we have

1352
01:01:02,790 --> 01:01:05,850
time for one more question because we

1353
01:01:04,380 --> 01:01:06,960
did start late and we're running over

1354
01:01:05,850 --> 01:01:08,520
but one more thing

1355
01:01:06,960 --> 01:01:10,740
this isn't even a question it's mostly a

1356
01:01:08,520 --> 01:01:12,780
comment as Stuart said seriously

1357
01:01:10,740 --> 01:01:15,000
registration is easy don't be

1358
01:01:12,780 --> 01:01:17,820
intimidated by the Ayane format you have

1359
01:01:15,000 --> 01:01:19,830
to fill out but please don't please be

1360
01:01:17,820 --> 01:01:23,010
sure that all you need is a service name

1361
01:01:19,830 --> 01:01:24,509
just ask the service name don't also ask

1362
01:01:23,010 --> 01:01:25,760
for the port you save yourself a lot of

1363
01:01:24,510 --> 01:01:30,360
hassle

1364
01:01:25,760 --> 01:01:33,030
yes I that the foremast lots of

1365
01:01:30,360 --> 01:01:35,250
questions ports are in short supply if

1366
01:01:33,030 --> 01:01:38,400
you ask for a well known port expect a

1367
01:01:35,250 --> 01:01:40,020
grilling about why you need it if you

1368
01:01:38,400 --> 01:01:43,020
leave the port number blank and say I

1369
01:01:40,020 --> 01:01:45,090
want a service type you'll get a a big

1370
01:01:43,020 --> 01:01:46,470
cheers from from my honor saying thank

1371
01:01:45,090 --> 01:01:48,630
you for not wasting a port number and

1372
01:01:46,470 --> 01:01:52,319
you'll get a very rapid confirmation of

1373
01:01:48,630 --> 01:01:53,790
your allocation okay well thank you all

1374
01:01:52,320 --> 01:01:55,830
for coming please do remember to fill

1375
01:01:53,790 --> 01:02:02,270
out that survey

1376
01:01:55,830 --> 01:02:02,270
[Applause]

