1
00:00:04,570 --> 00:00:20,649
okay okay that's why for you so let's

2
00:00:17,170 --> 00:00:25,480
start hi everyone here in the room for

3
00:00:20,649 --> 00:00:30,939
seaboard working group please note the

4
00:00:25,480 --> 00:00:33,790
note well we have minutes being taken by

5
00:00:30,939 --> 00:00:35,860
Michael thank you so much

6
00:00:33,790 --> 00:00:37,660
this meeting is recorded your presence

7
00:00:35,860 --> 00:00:39,490
is logged there are blue sheets going

8
00:00:37,660 --> 00:00:45,330
around and think your Jabra scribe as

9
00:00:39,490 --> 00:00:48,390
well and we have our chair gym in remote

10
00:00:45,330 --> 00:00:51,250
so for the agenda today we have a short

11
00:00:48,390 --> 00:00:55,570
introduction about the working group

12
00:00:51,250 --> 00:00:58,930
status these working group document

13
00:00:55,570 --> 00:01:02,110
status then Carsten is gonna walk us

14
00:00:58,930 --> 00:01:06,579
through some sibour specification issues

15
00:01:02,110 --> 00:01:09,820
left we talked about CDL the ways

16
00:01:06,579 --> 00:01:14,820
forward and we have some sex time and I

17
00:01:09,820 --> 00:01:17,649
times are definitely not final so we can

18
00:01:14,820 --> 00:01:22,720
we can move some time around if we need

19
00:01:17,650 --> 00:01:27,600
to finally we will wrap up any agenda

20
00:01:22,720 --> 00:01:30,670
bashing nope

21
00:01:27,600 --> 00:01:33,699
okay so status update

22
00:01:30,670 --> 00:01:36,070
we got six interim since ITF 105 I

23
00:01:33,700 --> 00:01:37,960
thought these were really useful we

24
00:01:36,070 --> 00:01:40,389
progress the documents you can find all

25
00:01:37,960 --> 00:01:43,298
the information about them the

26
00:01:40,390 --> 00:01:46,380
recordings are on on YouTube minutes

27
00:01:43,299 --> 00:01:49,659
slides everything we have on this link

28
00:01:46,380 --> 00:01:54,429
the chartering has been finalized

29
00:01:49,659 --> 00:01:57,070
since ITF 105 the sea beret tags and

30
00:01:54,430 --> 00:02:02,140
seaboard sequence sequences document or

31
00:01:57,070 --> 00:02:05,559
in RSC editor queue so great job with

32
00:02:02,140 --> 00:02:09,340
those and finally we have C Barbie's

33
00:02:05,560 --> 00:02:13,269
version 9 which has started it's working

34
00:02:09,340 --> 00:02:15,069
group last call in last week or yeah

35
00:02:13,269 --> 00:02:16,980
Thursday last week and that will go on

36
00:02:15,069 --> 00:02:18,238
until December 12

37
00:02:16,980 --> 00:02:22,220
it's a long working group last call

38
00:02:18,239 --> 00:02:25,069
because we have ITF week and also some

39
00:02:22,220 --> 00:02:30,440
holiday going on after that

40
00:02:25,069 --> 00:02:30,440
so please do send comments about this

41
00:02:31,730 --> 00:02:38,488
before we move on to the Super Bass I

42
00:02:35,390 --> 00:02:42,450
wanted to discuss in terms so now that

43
00:02:38,489 --> 00:02:45,750
basically Super Bass is almost done we

44
00:02:42,450 --> 00:02:51,119
might want to stop the interims every

45
00:02:45,750 --> 00:02:55,459
two weeks but we me and Jim were

46
00:02:51,120 --> 00:02:59,760
suggesting to have these three interims

47
00:02:55,459 --> 00:03:02,430
up to end of January so this are all on

48
00:02:59,760 --> 00:03:06,450
Wednesday December 18 January 15 and

49
00:03:02,430 --> 00:03:11,069
January 29 or Wednesdays in the same

50
00:03:06,450 --> 00:03:15,000
time slot and then we can have in dreams

51
00:03:11,069 --> 00:03:20,429
when we need them if we need them do you

52
00:03:15,000 --> 00:03:26,940
have any opinions about that thumbs-up

53
00:03:20,430 --> 00:03:30,959
from carsten 4 to 5 UTC is the time slot

54
00:03:26,940 --> 00:03:34,410
so let's make sure that they don't

55
00:03:30,959 --> 00:03:45,239
collide with the core in terms if those

56
00:03:34,410 --> 00:03:47,340
continue which I think they will they

57
00:03:45,239 --> 00:03:53,400
will but they will probably also go to a

58
00:03:47,340 --> 00:03:55,709
slightly slower pace so you're saying

59
00:03:53,400 --> 00:03:58,829
they will collide no they will go to a

60
00:03:55,709 --> 00:03:59,549
slower pace so we will also not have one

61
00:03:58,829 --> 00:04:07,879
every two weeks

62
00:03:59,549 --> 00:04:12,260
yes yeah okay great yeah then we can

63
00:04:07,879 --> 00:04:12,260
start talking about Super Bass

64
00:04:18,070 --> 00:04:21,880
yeah

65
00:04:19,250 --> 00:04:28,390
so I have one slide about cos it's done

66
00:04:21,880 --> 00:04:28,390
no it's not quite like that oops

67
00:04:34,520 --> 00:04:38,320
so just just as a reminder what this was

68
00:04:36,950 --> 00:04:43,330
about

69
00:04:38,320 --> 00:04:46,010
we were planning to take SIBO to

70
00:04:43,330 --> 00:04:49,190
internet Senate so this is not the time

71
00:04:46,010 --> 00:04:52,490
for great innovations this is the time

72
00:04:49,190 --> 00:04:56,170
for fixing things looking at it's Robert

73
00:04:52,490 --> 00:04:58,340
Horry making in particular making

74
00:04:56,170 --> 00:05:00,890
improvements in specification quality

75
00:04:58,340 --> 00:05:04,510
because that is probably the biggest

76
00:05:00,890 --> 00:05:11,270
source of potential into our ability

77
00:05:04,510 --> 00:05:16,460
problems and we had some some 29 issues

78
00:05:11,270 --> 00:05:19,219
that Poland is closed since IETF 105 so

79
00:05:16,460 --> 00:05:22,789
there was some work document does look a

80
00:05:19,220 --> 00:05:25,160
bit different now it still still has the

81
00:05:22,790 --> 00:05:29,360
same substance but it has a different

82
00:05:25,160 --> 00:05:33,680
structure and as Francesca said we we

83
00:05:29,360 --> 00:05:36,280
are now in the working of last call so I

84
00:05:33,680 --> 00:05:40,790
think the the biggest thing that we

85
00:05:36,280 --> 00:05:44,090
managed to do is understand the various

86
00:05:40,790 --> 00:05:47,210
kinds of errors in a better way and also

87
00:05:44,090 --> 00:05:51,890
I understood where these errors could

88
00:05:47,210 --> 00:05:54,409
potentially be handled so we clearly

89
00:05:51,890 --> 00:06:00,219
separated well non well-formed from non

90
00:05:54,410 --> 00:06:02,960
village in village situations and the

91
00:06:00,220 --> 00:06:04,910
document just surf the data item it's

92
00:06:02,960 --> 00:06:09,430
not well formed there's not really that

93
00:06:04,910 --> 00:06:11,720
much you can do and we now have

94
00:06:09,430 --> 00:06:13,520
corrected pseudocode for there there

95
00:06:11,720 --> 00:06:19,480
even was a small bug in the pseudocode

96
00:06:13,520 --> 00:06:22,190
and the appendix for well-formed and

97
00:06:19,480 --> 00:06:26,770
then the the other question is is the

98
00:06:22,190 --> 00:06:26,770
semantics okay and

99
00:06:26,780 --> 00:06:32,390
semantic errors are of course also

100
00:06:29,630 --> 00:06:35,690
errors but it may still be possible to

101
00:06:32,390 --> 00:06:38,890
present a data item with semantic errors

102
00:06:35,690 --> 00:06:42,710
to the application if there is a way to

103
00:06:38,890 --> 00:06:46,909
indicate those errors so the first two

104
00:06:42,710 --> 00:06:48,979
of the three levels levels that that

105
00:06:46,910 --> 00:06:51,620
happen at the level of C bar in the

106
00:06:48,980 --> 00:06:54,580
generic decoder for instance and then

107
00:06:51,620 --> 00:06:56,930
there is the third level of course the

108
00:06:54,580 --> 00:07:00,289
most applications will need some form of

109
00:06:56,930 --> 00:07:04,130
validation on top of the validation the

110
00:07:00,290 --> 00:07:06,919
generic decoder can do and this is out

111
00:07:04,130 --> 00:07:11,419
of the scope of this document and that's

112
00:07:06,919 --> 00:07:16,450
where either handwritten application

113
00:07:11,419 --> 00:07:20,150
code comes in and or some form of data

114
00:07:16,450 --> 00:07:23,570
definition language like CDL or JSON

115
00:07:20,150 --> 00:07:26,659
schema org or UD DF or JD DFO however

116
00:07:23,570 --> 00:07:28,820
it's called right now or JCR or there

117
00:07:26,660 --> 00:07:33,320
are lots of these that are out there and

118
00:07:28,820 --> 00:07:36,979
can potentially be used for SIBO data

119
00:07:33,320 --> 00:07:39,669
items so I think that's a good thing

120
00:07:36,979 --> 00:07:44,330
that has happened and I think we have

121
00:07:39,669 --> 00:07:47,990
pretty much completed this change other

122
00:07:44,330 --> 00:07:50,570
significant changes we now have not only

123
00:07:47,990 --> 00:07:53,510
have in appendix with working examples

124
00:07:50,570 --> 00:07:58,070
we also have an appendix with examples

125
00:07:53,510 --> 00:08:00,650
that have where from this errors we have

126
00:07:58,070 --> 00:08:02,930
discarded the concept of strict mode

127
00:08:00,650 --> 00:08:08,960
because it meant too many different

128
00:08:02,930 --> 00:08:15,620
things and we also do not paint the idea

129
00:08:08,960 --> 00:08:20,719
of a SIBO firewall that was probably a

130
00:08:15,620 --> 00:08:23,410
bit misguided we had a bit of tightening

131
00:08:20,720 --> 00:08:28,520
on the JSON to see what conversion

132
00:08:23,410 --> 00:08:31,610
issues so since C Bo has a richer data

133
00:08:28,520 --> 00:08:33,978
model then then Jason there sometimes

134
00:08:31,610 --> 00:08:37,490
the question how exactly do we interpret

135
00:08:33,979 --> 00:08:40,560
some jason in adjacent sasebo conversion

136
00:08:37,490 --> 00:08:43,740
we are not standardizing this

137
00:08:40,559 --> 00:08:46,800
but we are defining enough that an

138
00:08:43,740 --> 00:08:49,380
application a protocol can essentially

139
00:08:46,800 --> 00:08:51,810
just reference this section and and

140
00:08:49,380 --> 00:08:56,040
maybe provide a little bit more

141
00:08:51,810 --> 00:09:00,680
information how it wants its conversion

142
00:08:56,040 --> 00:09:02,730
being done instead we fixed a bug in the

143
00:09:00,680 --> 00:09:08,390
appendix with the pseudocode for

144
00:09:02,730 --> 00:09:14,220
detecting well-formed s and we worked on

145
00:09:08,390 --> 00:09:18,380
validity and there we now have the the

146
00:09:14,220 --> 00:09:23,460
validity in the basic generic data model

147
00:09:18,380 --> 00:09:27,540
which is exactly two things correct

148
00:09:23,460 --> 00:09:31,530
utf-8 syntax and non duplication of map

149
00:09:27,540 --> 00:09:33,810
keys and then we have tag validity and

150
00:09:31,530 --> 00:09:36,510
of course since we have dozens of tags

151
00:09:33,810 --> 00:09:40,229
we have dozens of different things that

152
00:09:36,510 --> 00:09:45,030
can go wrong there and given that the

153
00:09:40,230 --> 00:09:47,940
number of tags is supposed to grow the

154
00:09:45,030 --> 00:09:51,780
idea that a generic decoder is a

155
00:09:47,940 --> 00:09:55,080
completely validity checking decoders is

156
00:09:51,780 --> 00:09:58,709
rather unlikely all generic decoders

157
00:09:55,080 --> 00:10:00,000
will have limitations there and the

158
00:09:58,710 --> 00:10:02,610
important thing here is that these

159
00:10:00,000 --> 00:10:04,320
limitations are documented are

160
00:10:02,610 --> 00:10:06,510
communicated to the application so the

161
00:10:04,320 --> 00:10:08,370
application knows which parts of the

162
00:10:06,510 --> 00:10:10,760
validity checking has to do itself

163
00:10:08,370 --> 00:10:16,110
because it hasn't been done by the

164
00:10:10,760 --> 00:10:20,400
generic decoder so that is pretty much

165
00:10:16,110 --> 00:10:23,700
what what has changed of course there

166
00:10:20,400 --> 00:10:26,760
are 29 issues also that there were many

167
00:10:23,700 --> 00:10:29,640
things that on the editorial level even

168
00:10:26,760 --> 00:10:31,500
more complex editorial things and there

169
00:10:29,640 --> 00:10:33,360
is one open issue actually there are two

170
00:10:31,500 --> 00:10:35,640
open issues but one is just the tasks

171
00:10:33,360 --> 00:10:38,580
that we have to do it doesn't have

172
00:10:35,640 --> 00:10:43,620
anything to do with the document and the

173
00:10:38,580 --> 00:10:47,430
other open issue is what exactly what

174
00:10:43,620 --> 00:10:49,860
owners do we exactly put on an

175
00:10:47,430 --> 00:10:53,140
application protocol definition how to

176
00:10:49,860 --> 00:10:56,720
handle duplicate map

177
00:10:53,140 --> 00:10:59,330
so besides it's interesting that we are

178
00:10:56,720 --> 00:11:03,440
not even discussing this for utf-8

179
00:10:59,330 --> 00:11:06,490
for the utf-8 validity but for the map

180
00:11:03,440 --> 00:11:10,790
keys it's a little bit more a key

181
00:11:06,490 --> 00:11:13,280
because well different implementations

182
00:11:10,790 --> 00:11:17,030
handle it in a different way and that's

183
00:11:13,280 --> 00:11:19,400
not something that we have invented or

184
00:11:17,030 --> 00:11:22,270
Mis designed or something but it's

185
00:11:19,400 --> 00:11:24,920
something we inherited from JSON and

186
00:11:22,270 --> 00:11:29,920
interestingly nobody in the JSON world

187
00:11:24,920 --> 00:11:35,030
is as concerned about this issue and

188
00:11:29,920 --> 00:11:40,339
well yeah so how do we handle it and my

189
00:11:35,030 --> 00:11:44,000
proposal is to essentially punch and say

190
00:11:40,340 --> 00:11:47,270
well we live in a world where we're not

191
00:11:44,000 --> 00:11:51,440
all decoders will be validating in this

192
00:11:47,270 --> 00:11:54,260
space so it will be the unusual case

193
00:11:51,440 --> 00:11:58,870
that an application protocol says must

194
00:11:54,260 --> 00:12:01,819
error out on on a duplicate map key and

195
00:11:58,870 --> 00:12:05,050
the problem really is that many decoders

196
00:12:01,820 --> 00:12:09,400
by construction just silently discard

197
00:12:05,050 --> 00:12:13,939
duplicates so I spent a couple days

198
00:12:09,400 --> 00:12:18,020
between the IDF's trying to fix my main

199
00:12:13,940 --> 00:12:21,530
Zeebo implementation to detect duplicate

200
00:12:18,020 --> 00:12:23,750
map keys and it just turns out it's much

201
00:12:21,530 --> 00:12:25,910
more difficult in the platform I'm

202
00:12:23,750 --> 00:12:28,700
coding true then I thought it would be

203
00:12:25,910 --> 00:12:33,860
and I think other decoder writers will

204
00:12:28,700 --> 00:12:36,680
have a similar problem so the generic

205
00:12:33,860 --> 00:12:41,120
decoder may be discarding duplicates and

206
00:12:36,680 --> 00:12:44,270
may be discarding the the early ones or

207
00:12:41,120 --> 00:12:46,130
the late ones or something in between we

208
00:12:44,270 --> 00:12:50,620
don't know the application has little

209
00:12:46,130 --> 00:12:56,060
control because it only sees a very nice

210
00:12:50,620 --> 00:12:58,640
well-formed map and so that's the normal

211
00:12:56,060 --> 00:13:02,109
situation there may be some applications

212
00:12:58,640 --> 00:13:04,600
that actually have to require village

213
00:13:02,110 --> 00:13:08,620
validity checking so

214
00:13:04,600 --> 00:13:14,050
that's not outlawed but this is the

215
00:13:08,620 --> 00:13:18,430
unusual case so what there is actually a

216
00:13:14,050 --> 00:13:21,490
must in the text and the the must here

217
00:13:18,430 --> 00:13:26,290
is the application protocol designer

218
00:13:21,490 --> 00:13:29,530
needs to make up their mind so is it one

219
00:13:26,290 --> 00:13:31,150
that will work with most decoders or is

220
00:13:29,530 --> 00:13:36,610
it one that actually needs a decoder

221
00:13:31,150 --> 00:13:39,459
that does the validity checking so my

222
00:13:36,610 --> 00:13:41,410
proposal would be to put her bound

223
00:13:39,460 --> 00:13:47,980
tricks on the on the number three and

224
00:13:41,410 --> 00:13:48,730
Geoffrey you put this issue in luckily

225
00:13:47,980 --> 00:13:51,640
is here

226
00:13:48,730 --> 00:13:54,600
so maybe you can have an opinion on that

227
00:13:51,640 --> 00:13:59,020
I think he's reviewing the issue

228
00:13:54,600 --> 00:14:05,860
let's give it a couple of minutes yeah

229
00:13:59,020 --> 00:14:07,540
we can can Oh No okay Sean Leonard I

230
00:14:05,860 --> 00:14:12,250
actually just have an observation or a

231
00:14:07,540 --> 00:14:13,900
question given the extensive use of JSON

232
00:14:12,250 --> 00:14:18,160
and protocols and so forth

233
00:14:13,900 --> 00:14:20,250
are there a class of known security

234
00:14:18,160 --> 00:14:26,800
vulnerabilities that have been reported

235
00:14:20,250 --> 00:14:28,450
that exploit duplicate map key issues

236
00:14:26,800 --> 00:14:30,310
and the different ways that decoders

237
00:14:28,450 --> 00:14:33,580
handle it because I'm not personally

238
00:14:30,310 --> 00:14:36,369
aware of cases where it's actually been

239
00:14:33,580 --> 00:14:39,850
shown to be an exploitable problem and I

240
00:14:36,370 --> 00:14:41,440
think that if there are if it is then

241
00:14:39,850 --> 00:14:43,750
it's much more important but if it's not

242
00:14:41,440 --> 00:14:49,750
then maybe that just shows actually it's

243
00:14:43,750 --> 00:14:51,490
not that big of a deal Jef Raskin I'm

244
00:14:49,750 --> 00:14:54,160
gonna ask our security team about that

245
00:14:51,490 --> 00:14:56,650
question whether whether they can give

246
00:14:54,160 --> 00:15:00,730
some examples of JSON vulnerabilities

247
00:14:56,650 --> 00:15:03,430
caused by two keys I do feel like even

248
00:15:00,730 --> 00:15:07,180
if we don't want to require applications

249
00:15:03,430 --> 00:15:09,760
to to like require say picking the first

250
00:15:07,180 --> 00:15:12,250
key or something that the text still

251
00:15:09,760 --> 00:15:13,840
needs to change because right now it

252
00:15:12,250 --> 00:15:17,350
says like make an intentional decision

253
00:15:13,840 --> 00:15:18,520
and it's not clear what what they could

254
00:15:17,350 --> 00:15:21,420
decide if

255
00:15:18,520 --> 00:15:26,410
if these are the two choices that either

256
00:15:21,420 --> 00:15:28,420
kind of pick an arbitrary one or error

257
00:15:26,410 --> 00:15:30,130
like if those are the choices that are

258
00:15:28,420 --> 00:15:39,099
available we should just list them

259
00:15:30,130 --> 00:15:41,050
I think Paul Hoffman so it's not an

260
00:15:39,100 --> 00:15:45,640
arbitrary choice at least in the Jason

261
00:15:41,050 --> 00:15:48,699
we've seen ones where once you hit a

262
00:15:45,640 --> 00:15:51,010
duplicate it swaps in the duplicated it

263
00:15:48,700 --> 00:15:55,420
forgets the first one and we've seen

264
00:15:51,010 --> 00:15:58,300
them where once it sees one it it it

265
00:15:55,420 --> 00:16:01,089
ignores it so I'm going back to your

266
00:15:58,300 --> 00:16:03,430
question Shawn if there is a security

267
00:16:01,090 --> 00:16:05,890
vulnerability found it's likely to be in

268
00:16:03,430 --> 00:16:10,150
just one of those not both of them

269
00:16:05,890 --> 00:16:11,470
so if we say pick one then we're picking

270
00:16:10,150 --> 00:16:12,790
you know we're hoping that all the

271
00:16:11,470 --> 00:16:15,490
security vulnerabilities were in the

272
00:16:12,790 --> 00:16:17,469
other one which doesn't seem likely to

273
00:16:15,490 --> 00:16:18,730
me and certainly if we revisit this

274
00:16:17,470 --> 00:16:21,550
question five years from now it also

275
00:16:18,730 --> 00:16:24,340
doesn't seem likely the other situation

276
00:16:21,550 --> 00:16:28,770
here where why I agree with Carsten on

277
00:16:24,340 --> 00:16:33,580
no change is unlike Jason we have

278
00:16:28,770 --> 00:16:35,590
indefinite length maps so if we say you

279
00:16:33,580 --> 00:16:37,660
got to be careful you got to do it there

280
00:16:35,590 --> 00:16:39,520
are are you know given that we have

281
00:16:37,660 --> 00:16:42,630
indefinite length maps there are a whole

282
00:16:39,520 --> 00:16:44,560
class of applications that are very

283
00:16:42,630 --> 00:16:47,200
appropriate for seaboard that are

284
00:16:44,560 --> 00:16:49,000
completely inappropriate for Jason where

285
00:16:47,200 --> 00:16:51,520
we're now saying you have to remember

286
00:16:49,000 --> 00:16:53,410
every key you've seen whereas for some

287
00:16:51,520 --> 00:16:56,710
of these it would make great sense to

288
00:16:53,410 --> 00:16:58,360
say I'm only going to look at you know

289
00:16:56,710 --> 00:17:00,010
like like let's say the key is numeric

290
00:16:58,360 --> 00:17:01,540
I'm only going to look at ones that are

291
00:17:00,010 --> 00:17:03,160
divisible by 10 or wait you know like

292
00:17:01,540 --> 00:17:04,780
there's things like that and you don't

293
00:17:03,160 --> 00:17:06,399
care because there's all these down now

294
00:17:04,780 --> 00:17:10,569
if we're saying oh no you've got to save

295
00:17:06,400 --> 00:17:16,260
all the keys that's really bad okay so

296
00:17:10,569 --> 00:17:19,240
before Laurence Jim was in the queue so

297
00:17:16,260 --> 00:17:21,220
so so one of the types of cases where

298
00:17:19,240 --> 00:17:26,260
you actually could have a security

299
00:17:21,220 --> 00:17:30,310
vulnerability is in cozy if you use the

300
00:17:26,260 --> 00:17:31,720
the critical header parameter and you

301
00:17:30,310 --> 00:17:34,289
put two of them in

302
00:17:31,720 --> 00:17:37,330
to the protected header parameters

303
00:17:34,289 --> 00:17:39,039
different applications may pick up

304
00:17:37,330 --> 00:17:41,168
either the first one or the second one

305
00:17:39,039 --> 00:17:43,600
as being the one that they care about

306
00:17:41,169 --> 00:17:49,990
and that could produce a different

307
00:17:43,600 --> 00:17:52,000
security answer yeah I think that's

308
00:17:49,990 --> 00:17:54,450
exactly the the situation where the

309
00:17:52,000 --> 00:17:58,270
security problem comes in where you have

310
00:17:54,450 --> 00:18:02,440
one data item that is interpreted by

311
00:17:58,270 --> 00:18:05,710
multiple different implementations so

312
00:18:02,440 --> 00:18:09,250
for instance player a generates some

313
00:18:05,710 --> 00:18:12,640
some data structures player B signs it

314
00:18:09,250 --> 00:18:15,850
and player C interprets it and that's

315
00:18:12,640 --> 00:18:18,820
where these these problems come in so

316
00:18:15,850 --> 00:18:20,620
lauren slim blade so i actually wrote

317
00:18:18,820 --> 00:18:24,760
the code the gym was just talking about

318
00:18:20,620 --> 00:18:26,379
since the last IETF so and had to think

319
00:18:24,760 --> 00:18:29,350
about what was going to happen with

320
00:18:26,380 --> 00:18:35,220
duplicates because josé's specifically

321
00:18:29,350 --> 00:18:38,230
says no duplicate header parameters so

322
00:18:35,220 --> 00:18:41,500
that did that detection I wound up

323
00:18:38,230 --> 00:18:44,409
implementing it in the cozy layers not

324
00:18:41,500 --> 00:18:46,510
in the C bore layers so it was not a

325
00:18:44,409 --> 00:18:49,299
characteristic of the decoder it's a

326
00:18:46,510 --> 00:18:51,280
characteristic of the thing above the

327
00:18:49,299 --> 00:18:52,870
decoder above the generic decoder but

328
00:18:51,280 --> 00:18:54,549
you know you're not going to see the

329
00:18:52,870 --> 00:18:58,120
duplicates if the decoders from your

330
00:18:54,549 --> 00:19:01,870
discuss them depends on how the decoder

331
00:18:58,120 --> 00:19:05,889
works yes most decoders actually work by

332
00:19:01,870 --> 00:19:10,270
discarding one of the duplicate keys but

333
00:19:05,890 --> 00:19:15,220
some don't some don't yes and some don't

334
00:19:10,270 --> 00:19:16,720
and the ones that don't then the how you

335
00:19:15,220 --> 00:19:21,250
handle the duplicates is a

336
00:19:16,720 --> 00:19:28,289
characteristic of the thing on top so it

337
00:19:21,250 --> 00:19:28,289
seems I mean it's just I don't know

338
00:19:28,799 --> 00:19:37,100
seems it seems there's a lot of

339
00:19:30,789 --> 00:19:39,529
variability here I guess my question

340
00:19:37,100 --> 00:19:43,120
and so my brains not very working with

341
00:19:39,529 --> 00:19:44,870
unbounded map it's not the right word

342
00:19:43,120 --> 00:19:47,629
indefinite I knew that was the wrong

343
00:19:44,870 --> 00:19:51,199
word so so with a pull parser and an

344
00:19:47,630 --> 00:19:52,940
indefinite map you would not until you

345
00:19:51,200 --> 00:19:55,580
got to the end you wouldn't know if

346
00:19:52,940 --> 00:19:58,399
there was another key so you would in a

347
00:19:55,580 --> 00:20:01,539
pull parser return the first one and

348
00:19:58,399 --> 00:20:04,820
you're done you found it right and so

349
00:20:01,539 --> 00:20:06,799
any any ability to say you should

350
00:20:04,820 --> 00:20:09,678
validate means that you always have to

351
00:20:06,799 --> 00:20:11,120
go to the end of the stream right so not

352
00:20:09,679 --> 00:20:13,389
even a question of you'd have to

353
00:20:11,120 --> 00:20:16,879
remember it you have to process all

354
00:20:13,389 --> 00:20:19,279
gigabyte of data even though the thing

355
00:20:16,879 --> 00:20:21,860
you want was specially arranged to be in

356
00:20:19,279 --> 00:20:24,230
the first you know kilobyte so it would

357
00:20:21,860 --> 00:20:26,299
be the very end very bad to say

358
00:20:24,230 --> 00:20:29,659
something like this that's a fundamental

359
00:20:26,299 --> 00:20:33,830
issue with Matz yeah and and so I I

360
00:20:29,659 --> 00:20:36,200
would say that I think we should make

361
00:20:33,830 --> 00:20:39,230
some recommendation as to whether you

362
00:20:36,200 --> 00:20:44,299
should keep the first or the last okay

363
00:20:39,230 --> 00:20:47,919
but I also think that we should say very

364
00:20:44,299 --> 00:20:51,110
strongly that you know there probably

365
00:20:47,919 --> 00:20:53,889
that it's it's probably indefinite we

366
00:20:51,110 --> 00:20:57,699
should make a recommendation not a a

367
00:20:53,889 --> 00:21:00,379
must if you understand what I'm saying

368
00:20:57,700 --> 00:21:06,230
yeah except there's there is no good

369
00:21:00,379 --> 00:21:13,820
recommendation I think picking not none

370
00:21:06,230 --> 00:21:16,490
is is worse that's all okay Sean Leonard

371
00:21:13,820 --> 00:21:18,439
I think picking on might be okay so I

372
00:21:16,490 --> 00:21:20,990
respectfully disagree with that i think

373
00:21:18,440 --> 00:21:23,360
that no change is is okay I have another

374
00:21:20,990 --> 00:21:26,000
observation of about this duplicate map

375
00:21:23,360 --> 00:21:28,370
keys problem I think that it's much more

376
00:21:26,000 --> 00:21:32,059
serious when the attacker controls the

377
00:21:28,370 --> 00:21:35,000
production of the map keys so that when

378
00:21:32,059 --> 00:21:37,700
so if you ask for user supplied or

379
00:21:35,000 --> 00:21:41,840
attacker supply data and the attacker

380
00:21:37,700 --> 00:21:43,250
provides the map data as opposed to the

381
00:21:41,840 --> 00:21:45,470
map keys it's not really a big deal

382
00:21:43,250 --> 00:21:49,220
because the keys are chosen by the

383
00:21:45,470 --> 00:21:50,870
secured by the secured code base more or

384
00:21:49,220 --> 00:21:53,000
less it's it's when

385
00:21:50,870 --> 00:21:55,610
you ask a potential attacker to supply

386
00:21:53,000 --> 00:21:59,630
the keys themselves right or an open

387
00:21:55,610 --> 00:22:02,209
ended production of keys where it could

388
00:21:59,630 --> 00:22:05,450
intentionally construct pairs that have

389
00:22:02,210 --> 00:22:07,309
repeated keys that's a more that's a

390
00:22:05,450 --> 00:22:10,309
source of potential additional security

391
00:22:07,309 --> 00:22:12,170
vulnerabilities and that's really common

392
00:22:10,309 --> 00:22:19,220
to maps in general not a seaboard

393
00:22:12,170 --> 00:22:21,440
specific thing hey hi this is Hank so I

394
00:22:19,220 --> 00:22:24,860
think that's almost nothing left to say

395
00:22:21,440 --> 00:22:26,540
from here except that I'm Pro no change

396
00:22:24,860 --> 00:22:29,719
which is one strange when you say it out

397
00:22:26,540 --> 00:22:32,928
loud and I always assumed that the last

398
00:22:29,720 --> 00:22:35,120
key was the valid key with indefinite

399
00:22:32,929 --> 00:22:36,820
maps I think you should be very careful

400
00:22:35,120 --> 00:22:39,830
in case to allow them in any case

401
00:22:36,820 --> 00:22:42,740
because they can be a real big issue but

402
00:22:39,830 --> 00:22:45,199
still I would not recommend first hit

403
00:22:42,740 --> 00:22:47,679
but last hit in that case but just a

404
00:22:45,200 --> 00:22:51,440
personal opinion I don't think that is

405
00:22:47,679 --> 00:22:56,540
for me to decide but I am in favor of

406
00:22:51,440 --> 00:23:01,220
the proposal thank you and so actually

407
00:22:56,540 --> 00:23:04,750
if you look at the JSON objects they are

408
00:23:01,220 --> 00:23:08,090
a bit like indefinite maps in Siebel

409
00:23:04,750 --> 00:23:10,090
because you don't have information from

410
00:23:08,090 --> 00:23:14,230
the beginning how long they're going to

411
00:23:10,090 --> 00:23:18,678
be so I think we are quite close to what

412
00:23:14,230 --> 00:23:24,320
happens in Jason here and I haven't done

413
00:23:18,679 --> 00:23:28,660
a serious search about the check versus

414
00:23:24,320 --> 00:23:33,409
use problems that we are talking about

415
00:23:28,660 --> 00:23:36,500
so I'm not aware of any such problem

416
00:23:33,410 --> 00:23:38,690
that that exists in the JSON word but

417
00:23:36,500 --> 00:23:41,360
that doesn't mean it won't existed at

418
00:23:38,690 --> 00:23:43,850
some point there's Jim pointed out we

419
00:23:41,360 --> 00:23:48,010
even know places in our data structures

420
00:23:43,850 --> 00:23:48,010
where where it could become a problem

421
00:23:48,100 --> 00:23:52,100
my name is Joe Cheshire from Apple

422
00:23:50,540 --> 00:23:55,300
listen if this discussion I achieved

423
00:23:52,100 --> 00:23:58,280
lurkers you made me think to check RC

424
00:23:55,300 --> 00:24:00,409
67-63 for dns service discovery to see

425
00:23:58,280 --> 00:24:02,600
what language we had there and then we

426
00:24:00,410 --> 00:24:04,910
said if there are duplicates you take

427
00:24:02,600 --> 00:24:07,730
the first and ignore the rest

428
00:24:04,910 --> 00:24:10,309
and there's so there is some precedent

429
00:24:07,730 --> 00:24:12,740
for doing that and I think with the

430
00:24:10,309 --> 00:24:14,389
discussion of indefinite maps if the

431
00:24:12,740 --> 00:24:16,309
defined behaviors take the last you

432
00:24:14,390 --> 00:24:17,960
always have to read to the end whereas

433
00:24:16,309 --> 00:24:19,670
if you take the first when you find it

434
00:24:17,960 --> 00:24:21,530
you know you have it I think that

435
00:24:19,670 --> 00:24:23,480
language should specify which is the

436
00:24:21,530 --> 00:24:30,350
right thing to do otherwise different

437
00:24:23,480 --> 00:24:32,000
people do different things yeah I would

438
00:24:30,350 --> 00:24:33,350
I would be most happy with language

439
00:24:32,000 --> 00:24:36,710
saying kind of you can either pick the

440
00:24:33,350 --> 00:24:38,480
first or error I'd be fine with you

441
00:24:36,710 --> 00:24:40,220
closing with this with no change and

442
00:24:38,480 --> 00:24:41,780
I'll come back if the security team

443
00:24:40,220 --> 00:24:46,010
comes up with examples and we can reopen

444
00:24:41,780 --> 00:24:48,649
it but but that that change is what I

445
00:24:46,010 --> 00:24:52,610
prefer if you can do take the first you

446
00:24:48,650 --> 00:25:03,500
can fully validate so there's never a

447
00:24:52,610 --> 00:25:17,209
reason to do to the first if you read to

448
00:25:03,500 --> 00:25:18,830
the end yes I okay so I'm having a bit

449
00:25:17,210 --> 00:25:23,150
of a hard time reading the consensus

450
00:25:18,830 --> 00:25:25,639
here because I hear a lot of different

451
00:25:23,150 --> 00:25:31,850
opinions and people are nodding or

452
00:25:25,640 --> 00:25:34,929
shaking their heads yeah Alex a personal

453
00:25:31,850 --> 00:25:40,129
opinion again either take first or error

454
00:25:34,929 --> 00:25:42,290
but I hope no change doesn't mean not

455
00:25:40,130 --> 00:25:46,400
saying anything about the issue I would

456
00:25:42,290 --> 00:25:49,549
Rodgers so the document already said

457
00:25:46,400 --> 00:25:51,440
explain that this is a problem okay and

458
00:25:49,549 --> 00:25:54,950
it says the application and protocol is

459
00:25:51,440 --> 00:25:57,650
an must say how to handle this problem

460
00:25:54,950 --> 00:26:05,179
but it doesn't do what what Jeffery just

461
00:25:57,650 --> 00:26:07,460
said list the options but I would not be

462
00:26:05,179 --> 00:26:09,760
happy with requiring generate decoders

463
00:26:07,460 --> 00:26:14,620
to always take the first because that is

464
00:26:09,760 --> 00:26:14,620
expensive in certain situations

465
00:26:15,000 --> 00:26:20,860
yeah it's those situations where the

466
00:26:17,830 --> 00:26:25,059
generic order generates a platform

467
00:26:20,860 --> 00:26:28,959
dictionary from the data then you just

468
00:26:25,059 --> 00:26:30,428
take the key value pairs and stash the

469
00:26:28,960 --> 00:26:32,260
values under the keys into the

470
00:26:30,429 --> 00:26:43,270
dictionary and when you're done with

471
00:26:32,260 --> 00:26:49,480
this the last one has one Alexa is

472
00:26:43,270 --> 00:26:51,340
thinking there's Jim in the queue if you

473
00:26:49,480 --> 00:26:52,809
do that then you already can store the

474
00:26:51,340 --> 00:26:56,320
whole thing in memory so you can

475
00:26:52,809 --> 00:26:58,960
probably do the right thing well I'm not

476
00:26:56,320 --> 00:27:06,129
entirely sure I understand the argument

477
00:26:58,960 --> 00:27:09,490
for the for the decoder it may be twice

478
00:27:06,130 --> 00:27:12,880
the work to first look up the thing and

479
00:27:09,490 --> 00:27:26,130
and then only if the lookup fails - the

480
00:27:12,880 --> 00:27:26,130
thing Pete you want to go to the mic

481
00:27:27,120 --> 00:27:36,668
yeah so Jim Europe I mean I I don't know

482
00:27:35,080 --> 00:27:38,230
that I agree that it'd be twice the work

483
00:27:36,669 --> 00:27:40,150
since you kind of have to do the look up

484
00:27:38,230 --> 00:27:44,710
as part of inserting it into the

485
00:27:40,150 --> 00:27:48,820
dictionary I mean I think that that the

486
00:27:44,710 --> 00:27:52,290
answers are one take the first to error

487
00:27:48,820 --> 00:27:56,760
or three return all of them and let the

488
00:27:52,290 --> 00:27:59,350
the application deal with it

489
00:27:56,760 --> 00:28:00,700
because there are cases like you know

490
00:27:59,350 --> 00:28:02,080
when you're doing streaming that you are

491
00:28:00,700 --> 00:28:09,600
going to want to be able to return all

492
00:28:02,080 --> 00:28:09,600
of them exactly

493
00:28:13,140 --> 00:28:16,380
I was I was also going to say that if

494
00:28:14,669 --> 00:28:18,450
you're if you're filling a native map

495
00:28:16,380 --> 00:28:20,940
you can always check for presents before

496
00:28:18,450 --> 00:28:22,830
you insert and there are a lot of map

497
00:28:20,940 --> 00:28:23,360
api's where that does require two

498
00:28:22,830 --> 00:28:27,168
lookups

499
00:28:23,360 --> 00:28:27,168
but there are some where it doesn't

500
00:28:27,980 --> 00:28:33,750
michael so if you are processing a big

501
00:28:31,200 --> 00:28:36,210
map and you are interested in a subset

502
00:28:33,750 --> 00:28:38,549
of the keys which is a sort of a

503
00:28:36,210 --> 00:28:41,520
variation of the pull parser then for

504
00:28:38,549 --> 00:28:43,230
the subset of the keys you don't have to

505
00:28:41,520 --> 00:28:46,049
store them all you just care about the

506
00:28:43,230 --> 00:28:47,880
subset that you know so a gigabyte of

507
00:28:46,049 --> 00:28:51,059
map data and you're interested in twelve

508
00:28:47,880 --> 00:28:53,820
keys okay so you may have to read to the

509
00:28:51,059 --> 00:28:56,490
end of the data stream anyway to find it

510
00:28:53,820 --> 00:28:58,740
if all those keys are there if there are

511
00:28:56,490 --> 00:28:59,970
some that just don't appear right you're

512
00:28:58,740 --> 00:29:01,860
still looking and still looking and

513
00:28:59,970 --> 00:29:06,149
still looking and so that may not be so

514
00:29:01,860 --> 00:29:08,850
terrible most dictionaries lookups under

515
00:29:06,149 --> 00:29:10,799
the hood everyone said they have to find

516
00:29:08,850 --> 00:29:13,350
out where to put the item and so

517
00:29:10,799 --> 00:29:15,600
probably the check if it's already there

518
00:29:13,350 --> 00:29:19,469
while you're inserting it in other words

519
00:29:15,600 --> 00:29:21,539
insert if not already there is is

520
00:29:19,470 --> 00:29:23,370
probably does not require to trivet

521
00:29:21,539 --> 00:29:26,610
treat reversals if you have a good

522
00:29:23,370 --> 00:29:28,620
implementation unfortunately not patron

523
00:29:26,610 --> 00:29:30,658
so not all platforms are that smart but

524
00:29:28,620 --> 00:29:33,149
but but that's but under the hood they

525
00:29:30,659 --> 00:29:35,669
all do that right they all they're all

526
00:29:33,149 --> 00:29:36,809
looking up if they have a tree of some

527
00:29:35,669 --> 00:29:38,340
kind for a dictionary they're all

528
00:29:36,809 --> 00:29:40,289
they're all have to find out where to

529
00:29:38,340 --> 00:29:44,070
put the item and see if it's there or

530
00:29:40,289 --> 00:29:46,408
not and it's not it's not twice as much

531
00:29:44,070 --> 00:29:53,220
work it's order a number of entries in

532
00:29:46,409 --> 00:29:56,370
the map right it's may be much larger

533
00:29:53,220 --> 00:29:58,919
it's may be much larger if you have

534
00:29:56,370 --> 00:30:00,658
demanding myths this way you shouldn't

535
00:29:58,919 --> 00:30:06,240
be implementing stuff like this

536
00:30:00,659 --> 00:30:10,049
so most people implement maps using hash

537
00:30:06,240 --> 00:30:12,240
tables whether it's a hash table or a

538
00:30:10,049 --> 00:30:14,940
tree you have to find the location of

539
00:30:12,240 --> 00:30:17,669
the to put it yes okay there's different

540
00:30:14,940 --> 00:30:19,320
costs for doing that okay I agree but in

541
00:30:17,669 --> 00:30:20,899
both cases when you have the new item

542
00:30:19,320 --> 00:30:22,980
you have to find a place to put it and

543
00:30:20,899 --> 00:30:27,120
you would discover what

544
00:30:22,980 --> 00:30:28,559
they're already yes okay in that process

545
00:30:27,120 --> 00:30:30,479
that phone code will even discard the

546
00:30:28,559 --> 00:30:32,940
old video and some of them will out will

547
00:30:30,480 --> 00:30:34,320
replace yes someone will do their plays

548
00:30:32,940 --> 00:30:36,960
you're asking I agree

549
00:30:34,320 --> 00:30:43,168
may not have a good way to actually get

550
00:30:36,960 --> 00:30:45,870
at their code Laurence limb but it seems

551
00:30:43,169 --> 00:30:47,669
there's there's cases were you're not

552
00:30:45,870 --> 00:30:51,059
gonna store the whole thing ever you

553
00:30:47,669 --> 00:30:52,740
just don't want to do that because the

554
00:30:51,059 --> 00:30:54,600
way your protocol works or something

555
00:30:52,740 --> 00:30:57,600
like that I don't know maybe time you

556
00:30:54,600 --> 00:31:01,320
get a an entry you flash a light and

557
00:30:57,600 --> 00:31:04,199
that's all you're gonna do then you have

558
00:31:01,320 --> 00:31:06,000
no way to I mean you can't dude you

559
00:31:04,200 --> 00:31:08,940
can't do any detection or the first or

560
00:31:06,000 --> 00:31:10,620
the last because you just don't know so

561
00:31:08,940 --> 00:31:14,990
if you're not storing it you can't you

562
00:31:10,620 --> 00:31:14,989
can't do anything right what

563
00:31:16,789 --> 00:31:24,899
so could you could you huh could you

564
00:31:21,720 --> 00:31:34,950
clarify what that will be then you're a

565
00:31:24,899 --> 00:31:38,309
preferred option for this yes to the

566
00:31:34,950 --> 00:31:40,110
microphone please Sean Leonard if if

567
00:31:38,309 --> 00:31:42,570
you're just care about if one of the

568
00:31:40,110 --> 00:31:44,309
keys is there once you get a hit you

569
00:31:42,570 --> 00:31:46,408
stop processing the rest of the stream

570
00:31:44,309 --> 00:31:50,299
so you know you don't actually want to

571
00:31:46,409 --> 00:31:50,299
keep on going you you got it that's it

572
00:31:53,840 --> 00:32:00,480
Reznik I have hopefully a question that

573
00:31:56,639 --> 00:32:04,709
might drive us toward something if we

574
00:32:00,480 --> 00:32:07,860
find a security problem an actual like

575
00:32:04,710 --> 00:32:09,960
we've seen this before it really causes

576
00:32:07,860 --> 00:32:11,000
a security problem what are we going to

577
00:32:09,960 --> 00:32:14,880
do

578
00:32:11,000 --> 00:32:16,409
well we already have found it so we are

579
00:32:14,880 --> 00:32:17,070
standing here because we have found the

580
00:32:16,409 --> 00:32:20,610
problem okay

581
00:32:17,070 --> 00:32:24,620
little a security problem so an actual

582
00:32:20,610 --> 00:32:27,899
exploit that can be used because of this

583
00:32:24,620 --> 00:32:32,580
MU literature is full of check residuals

584
00:32:27,899 --> 00:32:34,989
products and the defect we happen not to

585
00:32:32,580 --> 00:32:36,899
know one for Jason

586
00:32:34,990 --> 00:32:40,630
just means that people have been

587
00:32:36,899 --> 00:32:43,809
reasonably prudent using Jason maybe so

588
00:32:40,630 --> 00:32:47,110
so we're saying that we are assuming

589
00:32:43,809 --> 00:32:50,740
that one such exploit one if not many

590
00:32:47,110 --> 00:32:52,418
exists and we're still some of us are

591
00:32:50,740 --> 00:32:57,820
still feeling like we should just leave

592
00:32:52,419 --> 00:33:01,980
it the way it is yes the reason is

593
00:32:57,820 --> 00:33:05,918
trying the reason is is we might find to

594
00:33:01,980 --> 00:33:07,870
one that relies on decoders that do this

595
00:33:05,919 --> 00:33:10,690
and one that relies on decoders to I

596
00:33:07,870 --> 00:33:14,709
guess we have three choices I have a

597
00:33:10,690 --> 00:33:16,870
hard time believing anyway there could

598
00:33:14,710 --> 00:33:18,100
be there could be two and so us finding

599
00:33:16,870 --> 00:33:20,529
one going Oh

600
00:33:18,100 --> 00:33:23,949
we'll do the other one isn't as a point

601
00:33:20,529 --> 00:33:27,190
of reference though we argued about this

602
00:33:23,950 --> 00:33:34,179
for I Jason and I Jason always said was

603
00:33:27,190 --> 00:33:37,169
must not produce whatever I think we

604
00:33:34,179 --> 00:33:39,549
hunted once it's okay to punt again I

605
00:33:37,169 --> 00:33:41,169
mean because just because I Jason really

606
00:33:39,549 --> 00:33:45,340
is one of those successful things that

607
00:33:41,169 --> 00:33:47,020
we did with Jason I don't know all the

608
00:33:45,340 --> 00:33:50,110
sudden we can do better because of the

609
00:33:47,020 --> 00:33:54,129
Seaboard brother we want to be better

610
00:33:50,110 --> 00:33:58,629
than Jason so that's one reason I think

611
00:33:54,130 --> 00:34:00,549
as long as we're no worse Alex yeah I'm

612
00:33:58,630 --> 00:34:02,380
not sure it would help but if we were

613
00:34:00,549 --> 00:34:07,779
designing new protocol we were we would

614
00:34:02,380 --> 00:34:11,409
have picked one right Geoffrey asking

615
00:34:07,779 --> 00:34:13,659
things you don't go away sorry it seems

616
00:34:11,409 --> 00:34:17,080
like the two options right now are say

617
00:34:13,659 --> 00:34:20,169
protocols have to decide between

618
00:34:17,080 --> 00:34:22,869
pick the first and error or we leave the

619
00:34:20,168 --> 00:34:24,580
text as it is as did I capture the two

620
00:34:22,869 --> 00:34:27,419
options correctly now pick the first is

621
00:34:24,580 --> 00:34:30,520
not a good option because it invalidates

622
00:34:27,418 --> 00:34:33,069
invalidates about half of the generic de

623
00:34:30,520 --> 00:34:40,199
corazon said that's not what we done

624
00:34:33,070 --> 00:34:43,659
from 75 implementations to so we I think

625
00:34:40,199 --> 00:34:46,178
alright I thought that the working group

626
00:34:43,659 --> 00:34:48,669
kind of has two options either we leave

627
00:34:46,179 --> 00:34:51,099
the text alone or we change the

628
00:34:48,668 --> 00:35:00,819
to say protocols must decide between

629
00:34:51,099 --> 00:35:02,440
pick the first and error yes I guess I

630
00:35:00,819 --> 00:35:05,079
guess yeah we could we could say

631
00:35:02,440 --> 00:35:07,200
protocols have to decide or they could

632
00:35:05,079 --> 00:35:09,609
leave that choice up to the application

633
00:35:07,200 --> 00:35:15,368
but there's kind of there would be to

634
00:35:09,609 --> 00:35:17,078
two valid choices which I think

635
00:35:15,369 --> 00:35:17,950
disagrees with Karstens statement that

636
00:35:17,079 --> 00:35:22,359
maybe you want to pick the last

637
00:35:17,950 --> 00:35:26,169
sometimes but it's not it's not picking

638
00:35:22,359 --> 00:35:28,119
it it's an accident of the way it can be

639
00:35:26,170 --> 00:35:30,549
efficiently implemented there was no

640
00:35:28,119 --> 00:35:32,109
conscious decision because all

641
00:35:30,549 --> 00:35:35,290
implementers of course know that you

642
00:35:32,109 --> 00:35:37,869
never get a duplicate lucky so they

643
00:35:35,290 --> 00:35:39,880
didn't kill I mean even even an

644
00:35:37,869 --> 00:35:42,400
accidental choice is a choice and I was

645
00:35:39,880 --> 00:35:49,240
suggesting maybe we hum between those

646
00:35:42,400 --> 00:35:51,970
options okay I think I think protocols

647
00:35:49,240 --> 00:35:54,069
you know in whatever we do protocols

648
00:35:51,970 --> 00:35:57,459
have to have the option to say they

649
00:35:54,069 --> 00:36:00,009
don't care you can't force a protocol

650
00:35:57,460 --> 00:36:02,950
into error or pick the first because

651
00:36:00,010 --> 00:36:06,910
then you to make a choice between those

652
00:36:02,950 --> 00:36:09,640
two you have to be tracking the key so

653
00:36:06,910 --> 00:36:12,790
to answer that if I understood Jeffrey

654
00:36:09,640 --> 00:36:14,950
correctly what he said is that if we do

655
00:36:12,790 --> 00:36:17,170
the change which is the second option

656
00:36:14,950 --> 00:36:20,710
that these working we put harm on if you

657
00:36:17,170 --> 00:36:25,420
do a hum the the change in the text will

658
00:36:20,710 --> 00:36:29,770
be either you don't care or if you care

659
00:36:25,420 --> 00:36:32,589
take the first or return or error so

660
00:36:29,770 --> 00:36:35,920
it's like it's like two choices and then

661
00:36:32,589 --> 00:36:38,890
two more choices on one side is that

662
00:36:35,920 --> 00:36:44,200
right Jeffrey that's that's what I

663
00:36:38,890 --> 00:36:46,509
understood so this is Paul I propose we

664
00:36:44,200 --> 00:36:49,390
don't hum here there's more people on

665
00:36:46,510 --> 00:36:51,190
the mailing list who count and hum with

666
00:36:49,390 --> 00:36:53,680
a small number of people is actually

667
00:36:51,190 --> 00:36:59,440
more dangerous than with a large number

668
00:36:53,680 --> 00:37:06,480
of people Alexi do you wanna

669
00:36:59,440 --> 00:37:15,099
put your ad half-done can I make you

670
00:37:06,480 --> 00:37:18,030
make a choice I don't know I might do it

671
00:37:15,099 --> 00:37:21,670
in one core if this issue is talking

672
00:37:18,030 --> 00:37:23,710
something before okay so there is a

673
00:37:21,670 --> 00:37:30,119
third option to those that Jeffrey said

674
00:37:23,710 --> 00:37:33,039
which is don't change don't change the

675
00:37:30,119 --> 00:37:34,960
processing and make sure that there is

676
00:37:33,039 --> 00:37:40,539
sufficient language around describing

677
00:37:34,960 --> 00:37:43,260
why all of the options are bad that's I

678
00:37:40,539 --> 00:37:48,910
would say that's option number three

679
00:37:43,260 --> 00:37:51,099
okay now you can go ahead yeah the

680
00:37:48,910 --> 00:37:55,420
comment about you know you some some

681
00:37:51,099 --> 00:37:59,920
implementation will be class so yes they

682
00:37:55,420 --> 00:38:01,480
might but I'm just thinking we have a

683
00:37:59,920 --> 00:38:04,240
protocol which is covered an issue of

684
00:38:01,480 --> 00:38:07,890
this okay well maybe I mean you but now

685
00:38:04,240 --> 00:38:11,950
most of us aware of it

686
00:38:07,890 --> 00:38:14,288
we could make implementations which we

687
00:38:11,950 --> 00:38:18,038
consider to be broken to be fixed by

688
00:38:14,289 --> 00:38:19,839
adding new requirements that's an option

689
00:38:18,039 --> 00:38:22,270
still available to us so this would be

690
00:38:19,839 --> 00:38:28,660
what I just said do not change the text

691
00:38:22,270 --> 00:38:32,288
and add text describing I suppose I'm

692
00:38:28,660 --> 00:38:38,520
saying more of adding text so ruling out

693
00:38:32,289 --> 00:38:38,520
certain choices if it helps

694
00:38:48,859 --> 00:38:56,069
Michael here I I'm I think that I think

695
00:38:54,419 --> 00:38:59,669
that if I understand the potential

696
00:38:56,069 --> 00:39:02,819
security threats that it only occurs if

697
00:38:59,669 --> 00:39:05,999
you haven't implementations that

698
00:39:02,819 --> 00:39:07,739
implement both ways that one is confused

699
00:39:05,999 --> 00:39:14,368
in one way in the other is confused the

700
00:39:07,739 --> 00:39:16,859
other way and there so so you said you

701
00:39:14,369 --> 00:39:19,169
know if we pick this baguette the first

702
00:39:16,859 --> 00:39:20,999
one that some group of people would have

703
00:39:19,169 --> 00:39:22,499
a exploit and we'll pick another well

704
00:39:20,999 --> 00:39:25,769
the other way another group of people

705
00:39:22,499 --> 00:39:27,718
have an exploit and I would say well I

706
00:39:25,769 --> 00:39:31,109
would say it differently if you pick one

707
00:39:27,719 --> 00:39:33,660
correct way then the people that did it

708
00:39:31,109 --> 00:39:35,459
the other way are exploited and if you

709
00:39:33,660 --> 00:39:36,419
pick the other correct way it's the

710
00:39:35,459 --> 00:39:38,788
other group of people that are

711
00:39:36,419 --> 00:39:40,739
potentially exploited okay but the

712
00:39:38,789 --> 00:39:43,739
exploit actually depends upon the fact

713
00:39:40,739 --> 00:39:46,650
that you have to two interpretations if

714
00:39:43,739 --> 00:39:49,499
you if we can rule one of the

715
00:39:46,650 --> 00:39:50,609
interpretations as being that invalid

716
00:39:49,499 --> 00:39:52,140
and I think that that's part of the

717
00:39:50,609 --> 00:39:53,729
point of going to internet standard is

718
00:39:52,140 --> 00:39:58,279
to remove any big you ities like there

719
00:39:53,729 --> 00:40:01,109
then we actually we closed the exploit

720
00:39:58,279 --> 00:40:02,400
okay regardless of which one we pick we

721
00:40:01,109 --> 00:40:04,439
closed the export because we make

722
00:40:02,400 --> 00:40:06,029
everyone interpret it the same way so

723
00:40:04,439 --> 00:40:08,038
now we're just simply arguing as to

724
00:40:06,029 --> 00:40:11,789
which is computationally more efficient

725
00:40:08,039 --> 00:40:13,880
or more convenient and how many

726
00:40:11,789 --> 00:40:17,159
implementations we would obsolete okay

727
00:40:13,880 --> 00:40:18,779
okay so that's why I'm don't feel

728
00:40:17,159 --> 00:40:20,579
comfortable leaving it as is because I

729
00:40:18,779 --> 00:40:22,739
think that the exploit is there because

730
00:40:20,579 --> 00:40:25,859
of the ambiguity not because of a

731
00:40:22,739 --> 00:40:28,049
specific choice a or b we require the

732
00:40:25,859 --> 00:40:35,069
ambiguity to be exposed in order to fort

733
00:40:28,049 --> 00:40:36,839
to make an exploit jeffrey askin we were

734
00:40:35,069 --> 00:40:39,179
looking for a JSON example of the

735
00:40:36,839 --> 00:40:43,529
exploit and the security team got back

736
00:40:39,179 --> 00:40:44,880
to me with a zip example yes in in

737
00:40:43,529 --> 00:40:47,089
android

738
00:40:44,880 --> 00:40:49,319
the signature checker checked the

739
00:40:47,089 --> 00:40:51,959
version of a file identified by the

740
00:40:49,319 --> 00:40:53,999
index and the parser that actually

741
00:40:51,959 --> 00:40:56,788
loaded content looked at the first one

742
00:40:53,999 --> 00:40:59,129
and when those were different it it

743
00:40:56,789 --> 00:41:01,429
allowed arbitrary content that was not

744
00:40:59,130 --> 00:41:01,429
signed

745
00:41:06,170 --> 00:41:17,130
Jim was in money go ahead what Michael

746
00:41:12,990 --> 00:41:21,060
said is true for cozy the only place

747
00:41:17,130 --> 00:41:23,610
that is an issue is with the protected

748
00:41:21,060 --> 00:41:25,320
attributes if you haven't happened in

749
00:41:23,610 --> 00:41:27,960
the unprotected attributes well you're

750
00:41:25,320 --> 00:41:30,780
not supposed to trust them anyway so if

751
00:41:27,960 --> 00:41:31,980
your code is screwing up because it

752
00:41:30,780 --> 00:41:41,550
picked up the wrong one it doesn't

753
00:41:31,980 --> 00:41:44,190
really matter all right so I think

754
00:41:41,550 --> 00:41:46,110
whether or not there was a security

755
00:41:44,190 --> 00:41:49,860
vulnerability is dependent on the

756
00:41:46,110 --> 00:41:54,300
protocol some protocols don't like just

757
00:41:49,860 --> 00:41:57,900
just as Jim said in the protected

758
00:41:54,300 --> 00:42:00,720
headers in in cozy it matters in the

759
00:41:57,900 --> 00:42:04,320
unprotected headers it does not in in

760
00:42:00,720 --> 00:42:08,040
the Jose says you can't have a duplicate

761
00:42:04,320 --> 00:42:10,980
header parameters so the text maybe

762
00:42:08,040 --> 00:42:13,440
should be if you are designing a

763
00:42:10,980 --> 00:42:18,390
protocol that has a security issue with

764
00:42:13,440 --> 00:42:21,600
duplicate headers pick one pick first

765
00:42:18,390 --> 00:42:23,730
or pick error one or whatever you do if

766
00:42:21,600 --> 00:42:26,250
you have a protocol that's the that has

767
00:42:23,730 --> 00:42:28,590
a has a would have encouraged our

768
00:42:26,250 --> 00:42:30,630
ability you need to pick one if you

769
00:42:28,590 --> 00:42:31,980
don't if there's no vulnerability if

770
00:42:30,630 --> 00:42:33,960
you're just flashing light or something

771
00:42:31,980 --> 00:42:41,430
like that then you don't have to pick

772
00:42:33,960 --> 00:42:45,570
one Sean Leonard I think that it sounds

773
00:42:41,430 --> 00:42:49,710
from Jeffrey's description the security

774
00:42:45,570 --> 00:42:54,210
problem comes from when you have whether

775
00:42:49,710 --> 00:42:58,560
you a second piece of software or a

776
00:42:54,210 --> 00:43:01,500
second process looks at in parses the

777
00:42:58,560 --> 00:43:04,490
data item from the original source

778
00:43:01,500 --> 00:43:08,370
material versus taking the results of

779
00:43:04,490 --> 00:43:09,509
the decoded item in the first pass when

780
00:43:08,370 --> 00:43:13,319
it was doing validation or

781
00:43:09,510 --> 00:43:17,400
authentication if the first process

782
00:43:13,320 --> 00:43:20,370
takes the map and it sees the first or

783
00:43:17,400 --> 00:43:23,970
the last or picks one arbitrarily and

784
00:43:20,370 --> 00:43:26,339
then passes that decoded Siebe or data

785
00:43:23,970 --> 00:43:28,560
item to the subsequent processes

786
00:43:26,340 --> 00:43:31,650
there should be no exploit either way

787
00:43:28,560 --> 00:43:33,630
because it's only gonna see one and and

788
00:43:31,650 --> 00:43:35,130
the result of that security check like

789
00:43:33,630 --> 00:43:37,050
authentication where I will be yes or no

790
00:43:35,130 --> 00:43:38,730
but but if they but if the check just

791
00:43:37,050 --> 00:43:41,340
says yes use this and they take the

792
00:43:38,730 --> 00:43:43,400
original blob of seaboard data and then

793
00:43:41,340 --> 00:43:46,650
reparse it using a different decoder

794
00:43:43,400 --> 00:43:48,840
then that different can can make a

795
00:43:46,650 --> 00:43:50,790
different choice than the original one

796
00:43:48,840 --> 00:43:52,650
that did the authentication or the

797
00:43:50,790 --> 00:43:54,840
validation it sounds like yeah you

798
00:43:52,650 --> 00:43:56,940
essentially cannot do that for signed

799
00:43:54,840 --> 00:44:00,120
data for that data you always have write

800
00:43:56,940 --> 00:44:01,650
work from from the original right well

801
00:44:00,120 --> 00:44:03,000
you have to work or you have to work

802
00:44:01,650 --> 00:44:05,310
from the original but then you take the

803
00:44:03,000 --> 00:44:09,420
results of the original for further

804
00:44:05,310 --> 00:44:11,220
processing of to get at the application

805
00:44:09,420 --> 00:44:16,500
layer semantics of what the data

806
00:44:11,220 --> 00:44:19,560
represents Paul Hoffman so I think we've

807
00:44:16,500 --> 00:44:24,200
gone down a rat hole here because this

808
00:44:19,560 --> 00:44:28,200
whole discussion is about valid a

809
00:44:24,200 --> 00:44:30,779
decoders that validate decoders that

810
00:44:28,200 --> 00:44:32,669
don't validate are perfectly valid the

811
00:44:30,780 --> 00:44:35,960
carbs are here perfectly good decoders

812
00:44:32,670 --> 00:44:39,840
so we can't make assumptions about

813
00:44:35,960 --> 00:44:43,320
receivers of the data because it might

814
00:44:39,840 --> 00:44:45,150
not be a validating decoder so who will

815
00:44:43,320 --> 00:44:46,830
look if we have to do this one we can

816
00:44:45,150 --> 00:44:48,810
make it safer we can't make it safer we

817
00:44:46,830 --> 00:44:50,580
can only make it safer for decoders that

818
00:44:48,810 --> 00:44:53,340
are validating and we don't know if

819
00:44:50,580 --> 00:44:57,529
decoders are validating so I'm still ok

820
00:44:53,340 --> 00:44:57,530
with no change from the current text

821
00:44:57,920 --> 00:45:04,170
geoffrey askin a validating decoder will

822
00:45:01,170 --> 00:45:06,800
error here a non validating one might

823
00:45:04,170 --> 00:45:11,280
pick one or more of the of the values

824
00:45:06,800 --> 00:45:13,140
and replying to Shawn it's it's

825
00:45:11,280 --> 00:45:15,300
absolutely true that you need kind of

826
00:45:13,140 --> 00:45:16,980
two mistakes in order to get a

827
00:45:15,300 --> 00:45:20,580
vulnerability here one of the mistakes

828
00:45:16,980 --> 00:45:22,380
is parsing the same data twice with two

829
00:45:20,580 --> 00:45:24,990
different parsers but the other one is a

830
00:45:22,380 --> 00:45:26,960
mistake in the in the specification of

831
00:45:24,990 --> 00:45:31,279
the format that that

832
00:45:26,960 --> 00:45:33,530
there are two legal parses or even in

833
00:45:31,280 --> 00:45:35,300
zip like one of the parses is not legal

834
00:45:33,530 --> 00:45:38,660
but it's still possible because the data

835
00:45:35,300 --> 00:45:41,570
is duplicated and and so we can we can

836
00:45:38,660 --> 00:45:43,399
avoid that second mistake by changing

837
00:45:41,570 --> 00:45:45,380
the definition of the format to require

838
00:45:43,400 --> 00:45:47,210
or the definition of the protocol to

839
00:45:45,380 --> 00:45:55,760
require that it that it pick one of the

840
00:45:47,210 --> 00:45:58,310
map keys well got to the mic so I I'm

841
00:45:55,760 --> 00:46:00,520
not saying Paul Paul said I was claiming

842
00:45:58,310 --> 00:46:02,630
that all parsers need to be validating I

843
00:46:00,520 --> 00:46:04,820
don't believe I'm claiming that I'm

844
00:46:02,630 --> 00:46:08,360
saying a validating parson will error an

845
00:46:04,820 --> 00:46:10,340
on validating parser must must return

846
00:46:08,360 --> 00:46:11,900
one of the values a particular one of

847
00:46:10,340 --> 00:46:15,410
the values and we need to pick which

848
00:46:11,900 --> 00:46:21,050
value an on validating parser returns so

849
00:46:15,410 --> 00:46:26,660
this is a proposal for a change like the

850
00:46:21,050 --> 00:46:30,380
proposal for change of text so that the

851
00:46:26,660 --> 00:46:33,410
duplicate detection can be done either

852
00:46:30,380 --> 00:46:35,690
in the generic decoder or in the

853
00:46:33,410 --> 00:46:38,089
software above it that is using the

854
00:46:35,690 --> 00:46:41,660
generic decoder if the decoder doesn't

855
00:46:38,090 --> 00:46:44,210
this card yeah that's right if it

856
00:46:41,660 --> 00:46:46,490
doesn't describe yes that's that's the

857
00:46:44,210 --> 00:46:54,770
problematic Dakota and unfortunately

858
00:46:46,490 --> 00:46:58,549
it's the common decoder so to go back

859
00:46:54,770 --> 00:47:01,100
what I was saying before then if your

860
00:46:58,550 --> 00:47:03,800
protocol can't tolerate duplicate map

861
00:47:01,100 --> 00:47:06,890
keys you should only use decoders that

862
00:47:03,800 --> 00:47:12,290
can facilitate the detection that you

863
00:47:06,890 --> 00:47:14,480
need or so either they either they do

864
00:47:12,290 --> 00:47:16,340
the detection that you need or they

865
00:47:14,480 --> 00:47:21,500
allow you to do the detection that you

866
00:47:16,340 --> 00:47:25,520
need Geoffrey askin

867
00:47:21,500 --> 00:47:30,050
I think I would be happy with I think

868
00:47:25,520 --> 00:47:34,520
three three results one is saying like

869
00:47:30,050 --> 00:47:38,210
see Bor uh all generic non validating

870
00:47:34,520 --> 00:47:40,480
decoders pick the first or say the

871
00:47:38,210 --> 00:47:46,090
protocol has to say which which

872
00:47:40,480 --> 00:47:48,430
to pick or the protocol has to either

873
00:47:46,090 --> 00:47:51,520
say which value to pick or declare that

874
00:47:48,430 --> 00:47:53,500
it's not a security critical value and

875
00:47:51,520 --> 00:47:55,000
an explicitly saying that if the

876
00:47:53,500 --> 00:47:56,560
protocol decides it's not important for

877
00:47:55,000 --> 00:47:59,170
security that that it doesn't have to

878
00:47:56,560 --> 00:48:02,259
say I think would be enough warning for

879
00:47:59,170 --> 00:48:05,950
me to be happy with it yeah so I think

880
00:48:02,260 --> 00:48:10,210
the net effect apart from improving the

881
00:48:05,950 --> 00:48:14,220
security of the world is that we declare

882
00:48:10,210 --> 00:48:17,020
a significant percentage of the existing

883
00:48:14,220 --> 00:48:18,490
decoders non-conforming which may be

884
00:48:17,020 --> 00:48:23,050
exactly what you want to do but we

885
00:48:18,490 --> 00:48:24,879
should do this okay so I think we need

886
00:48:23,050 --> 00:48:26,650
to stop the discussion I thought I

887
00:48:24,880 --> 00:48:32,530
thought she bore base would go really

888
00:48:26,650 --> 00:48:35,470
quickly today apparently not but okay

889
00:48:32,530 --> 00:48:39,369
we'll continue in the main list but what

890
00:48:35,470 --> 00:48:43,149
I'm hearing is mostly against no change

891
00:48:39,369 --> 00:48:48,850
and we need to work on what text we want

892
00:48:43,150 --> 00:48:50,590
to add yeah Alexei can I suggest that

893
00:48:48,850 --> 00:48:56,200
Jeffrey you send a message to the

894
00:48:50,590 --> 00:48:57,880
mailing list I don't know I maybe I'm

895
00:48:56,200 --> 00:48:59,589
just being talked to mistake but I

896
00:48:57,880 --> 00:49:02,619
almost felt like we're getting somewhere

897
00:48:59,590 --> 00:49:07,000
yes I thought and I know we need to stop

898
00:49:02,619 --> 00:49:10,240
because we're out of time yeah okay so

899
00:49:07,000 --> 00:49:13,240
great so there are also two new issues

900
00:49:10,240 --> 00:49:18,250
for super base that Lawrence has added

901
00:49:13,240 --> 00:49:19,779
into the github tracker I don't think we

902
00:49:18,250 --> 00:49:22,060
need to discuss them today

903
00:49:19,780 --> 00:49:24,940
Lawrence is shaking his head custom

904
00:49:22,060 --> 00:49:28,060
agrees yeah I would hope that everyone

905
00:49:24,940 --> 00:49:30,910
in this room submits two or three little

906
00:49:28,060 --> 00:49:33,250
editorial problems remaining so Lawrence

907
00:49:30,910 --> 00:49:37,540
started the trend change please do

908
00:49:33,250 --> 00:49:41,530
review the document yeah please go ahead

909
00:49:37,540 --> 00:49:45,420
and and submit reviews and you have

910
00:49:41,530 --> 00:49:45,420
until the 12th of December

911
00:49:52,340 --> 00:49:57,480
so now we can talk about CDL ways

912
00:49:55,109 --> 00:50:00,240
forward and we have ten minutes so we'll

913
00:49:57,480 --> 00:50:02,640
try to be quick we probably won't have

914
00:50:00,240 --> 00:50:05,750
time to go into the details that I was

915
00:50:02,640 --> 00:50:05,750
hoping we would

916
00:50:05,869 --> 00:50:15,780
so the what we started doing me and Jim

917
00:50:12,470 --> 00:50:19,259
we started identifying interesting

918
00:50:15,780 --> 00:50:21,450
features for CDL users to go forward so

919
00:50:19,260 --> 00:50:23,730
CDL features that are not in the city

920
00:50:21,450 --> 00:50:29,250
deal RC these are additional features

921
00:50:23,730 --> 00:50:33,740
like going to a CDL 2.0 and today I'm

922
00:50:29,250 --> 00:50:36,300
gonna give a report of the first

923
00:50:33,740 --> 00:50:39,779
investigations they started at the

924
00:50:36,300 --> 00:50:42,090
hackathon and the discussion today would

925
00:50:39,780 --> 00:50:43,770
probably not happen but if it did it

926
00:50:42,090 --> 00:50:46,440
shouldn't be focused on the technical

927
00:50:43,770 --> 00:50:50,190
solution rather on the scope of the

928
00:50:46,440 --> 00:50:55,200
features and possibly identify pitfalls

929
00:50:50,190 --> 00:50:57,930
so this is the list of new features that

930
00:50:55,200 --> 00:51:01,910
were identified those were taken from

931
00:50:57,930 --> 00:51:06,960
the mailing list and from C were the

932
00:51:01,910 --> 00:51:09,810
Karstens document CDL freezer so we have

933
00:51:06,960 --> 00:51:14,160
prepared the questionnaire a survey that

934
00:51:09,810 --> 00:51:16,619
we will end up send out and please fill

935
00:51:14,160 --> 00:51:19,589
it in even if you have been so kind to

936
00:51:16,619 --> 00:51:22,710
answer to all my questions and put in

937
00:51:19,590 --> 00:51:30,410
any feedback you have or any questions

938
00:51:22,710 --> 00:51:32,850
any questions you have about this so

939
00:51:30,410 --> 00:51:37,580
probably not gonna read them all but

940
00:51:32,850 --> 00:51:40,859
this is the result from the 11 responses

941
00:51:37,580 --> 00:51:43,410
so in green you have the yes response

942
00:51:40,859 --> 00:51:47,069
yes I want this or I'm interested the

943
00:51:43,410 --> 00:51:51,660
yellow is a maybe in the future possibly

944
00:51:47,070 --> 00:51:55,230
and the red is either no don't do this

945
00:51:51,660 --> 00:51:56,970
or it's mostly this worries me so it

946
00:51:55,230 --> 00:51:59,460
might not be a no don't do this but it

947
00:51:56,970 --> 00:52:04,770
might be a if we do this we need to be

948
00:51:59,460 --> 00:52:10,770
careful that this is done right so

949
00:52:04,770 --> 00:52:15,450
I I ordered them based on mostly on the

950
00:52:10,770 --> 00:52:18,450
yes and the top four features are the

951
00:52:15,450 --> 00:52:21,480
module superstructure import/export

952
00:52:18,450 --> 00:52:24,060
computed literals variants so both

953
00:52:21,480 --> 00:52:28,280
seaboard and Jason variants in one speck

954
00:52:24,060 --> 00:52:28,279
and do coke current constraints

955
00:52:28,650 --> 00:52:35,700
most of these are don't need too much

956
00:52:32,250 --> 00:52:38,400
explanation but I tried to summarize as

957
00:52:35,700 --> 00:52:42,649
well what what they mean

958
00:52:38,400 --> 00:52:47,040
so for module superstructure is about

959
00:52:42,650 --> 00:52:49,950
modules for Citadel definitions that can

960
00:52:47,040 --> 00:52:52,830
be referenced from under modules and we

961
00:52:49,950 --> 00:52:55,049
identify some of additional features

962
00:52:52,830 --> 00:52:58,590
that would be needed to be included in

963
00:52:55,050 --> 00:53:02,220
CDL like name spacing import/export

964
00:52:58,590 --> 00:53:04,530
module naming and versioning just

965
00:53:02,220 --> 00:53:12,000
checking time to see if we should have a

966
00:53:04,530 --> 00:53:13,650
discussion or maybe let's have a one or

967
00:53:12,000 --> 00:53:18,900
two minutes if you want to go to the my

968
00:53:13,650 --> 00:53:21,840
again so Carson said hard this is hard

969
00:53:18,900 --> 00:53:26,310
this is also the top feature that

970
00:53:21,840 --> 00:53:30,360
everybody wanted this is just Alexi you

971
00:53:26,310 --> 00:53:34,190
wanna say so yeah so another plus one

972
00:53:30,360 --> 00:53:36,900
for this feature which is hard but yeah

973
00:53:34,190 --> 00:53:39,780
so these are points that the working

974
00:53:36,900 --> 00:53:42,120
group would have to decide on if we get

975
00:53:39,780 --> 00:53:44,520
this and I think if I don't get this

976
00:53:42,120 --> 00:53:47,130
wrong yeah so we also have some this

977
00:53:44,520 --> 00:53:49,140
worries me about this feature so we need

978
00:53:47,130 --> 00:53:54,750
to get this right if you want to put it

979
00:53:49,140 --> 00:53:56,540
in next feature let's see if nothing

980
00:53:54,750 --> 00:53:59,340
from the jabber

981
00:53:56,540 --> 00:54:01,500
okay so cast is a piece of cake about

982
00:53:59,340 --> 00:54:04,560
this feature so these are all computed

983
00:54:01,500 --> 00:54:06,630
literals right now citadel is not

984
00:54:04,560 --> 00:54:08,660
defined to be able to compute and we are

985
00:54:06,630 --> 00:54:11,580
considering to add the functionality to

986
00:54:08,660 --> 00:54:14,549
define integers as components of a

987
00:54:11,580 --> 00:54:18,540
computer operation or string literals

988
00:54:14,550 --> 00:54:21,720
and operation being concatenation or so

989
00:54:18,540 --> 00:54:23,220
station or representative or tags a

990
00:54:21,720 --> 00:54:24,750
string literals tailored to their

991
00:54:23,220 --> 00:54:28,910
semantics rather than she realized

992
00:54:24,750 --> 00:54:33,200
Sieber so these are three options

993
00:54:28,910 --> 00:54:40,170
was that it thumbs up what

994
00:54:33,200 --> 00:54:45,689
thumbs up to three in in the room one

995
00:54:40,170 --> 00:54:48,320
and two easy to implement otherwise I

996
00:54:45,690 --> 00:54:51,600
have to repeat everything you say so

997
00:54:48,320 --> 00:54:55,080
Sean Leonard so what I was saying is I

998
00:54:51,600 --> 00:54:57,600
like three I'm in favor of three threes

999
00:54:55,080 --> 00:54:59,569
gonna require some design right because

1000
00:54:57,600 --> 00:55:01,350
there's an infinite number of tags

1001
00:54:59,570 --> 00:55:05,490
potentially so there could be infinite

1002
00:55:01,350 --> 00:55:07,350
numbers of representations one would

1003
00:55:05,490 --> 00:55:09,569
would depends on the tag right so it's

1004
00:55:07,350 --> 00:55:12,839
extensible for one and two it's easy to

1005
00:55:09,570 --> 00:55:15,420
implement as Carson said but I think

1006
00:55:12,840 --> 00:55:17,970
that it it will clutter specifications

1007
00:55:15,420 --> 00:55:22,560
and make them harder to read and make it

1008
00:55:17,970 --> 00:55:26,370
much less obvious right so right cuz the

1009
00:55:22,560 --> 00:55:29,549
literals then go all over the place yeah

1010
00:55:26,370 --> 00:55:34,520
okay thanks thank you so this is Hank

1011
00:55:29,550 --> 00:55:37,950
I'm to blame for one and this is due to

1012
00:55:34,520 --> 00:55:41,210
I'm writing a lot of CDL and a lot of

1013
00:55:37,950 --> 00:55:43,799
the content comes from the old world and

1014
00:55:41,210 --> 00:55:47,040
sometimes they have despite offsets and

1015
00:55:43,800 --> 00:55:50,490
you I'm ahead creating scripts to write

1016
00:55:47,040 --> 00:55:54,060
my own CDL and and I can compute them

1017
00:55:50,490 --> 00:55:56,490
and and and so this is why one exists is

1018
00:55:54,060 --> 00:55:57,870
this a convenient feature and an

1019
00:55:56,490 --> 00:56:01,200
inference or a convenience feature and

1020
00:55:57,870 --> 00:56:04,080
CTA per design should be full of

1021
00:56:01,200 --> 00:56:06,930
convenience features so that is why I'm

1022
00:56:04,080 --> 00:56:09,900
really also in favor of one and you can

1023
00:56:06,930 --> 00:56:11,580
do one thing and stop not printing the

1024
00:56:09,900 --> 00:56:14,010
other so when you can do both I say be

1025
00:56:11,580 --> 00:56:16,319
and I think it's not a bad thing and it

1026
00:56:14,010 --> 00:56:18,210
might be cluttering but if you're coming

1027
00:56:16,320 --> 00:56:19,350
from another specification and you're

1028
00:56:18,210 --> 00:56:22,260
new to seaboard

1029
00:56:19,350 --> 00:56:26,360
that's why CDI and and a translating it

1030
00:56:22,260 --> 00:56:26,360
it makes the work so much easier for you

1031
00:56:26,930 --> 00:56:30,470
Sean

1032
00:56:28,280 --> 00:56:32,090
so I'm all in favor of syntactic sugar

1033
00:56:30,470 --> 00:56:37,700
that makes things easier to read and

1034
00:56:32,090 --> 00:56:41,420
understand for one specifically can we

1035
00:56:37,700 --> 00:56:44,359
have a list or consecutive items where

1036
00:56:41,420 --> 00:56:46,100
increment is implied or essentially part

1037
00:56:44,360 --> 00:56:48,740
of the sugar are we talking about plus 1

1038
00:56:46,100 --> 00:56:50,470
plus 2 Plus 3 plus 4 plus 5 are we

1039
00:56:48,740 --> 00:56:54,529
actually talking about complicated

1040
00:56:50,470 --> 00:56:56,569
mathematical operations like x 2 mod 3

1041
00:56:54,530 --> 00:57:00,170
whatever for your different symbols

1042
00:56:56,570 --> 00:57:01,820
right I mean increments is is great that

1043
00:57:00,170 --> 00:57:04,580
makes a lot of sense but if you want

1044
00:57:01,820 --> 00:57:06,680
general-purpose Turing machine as a math

1045
00:57:04,580 --> 00:57:09,410
then that's that's a different thing

1046
00:57:06,680 --> 00:57:12,319
that it's not what I want but this is

1047
00:57:09,410 --> 00:57:15,049
what one implies so as an item one

1048
00:57:12,320 --> 00:57:17,000
implies so I I would not love to see

1049
00:57:15,050 --> 00:57:19,700
something I cannot powers anymore

1050
00:57:17,000 --> 00:57:22,040
because the equation is like two lines

1051
00:57:19,700 --> 00:57:24,620
long and no no no this is no this was

1052
00:57:22,040 --> 00:57:25,250
not my problem but but we figure out

1053
00:57:24,620 --> 00:57:27,319
you're right

1054
00:57:25,250 --> 00:57:30,110
it isn't there's not there's no scope to

1055
00:57:27,320 --> 00:57:32,630
item one and naturally we would have

1056
00:57:30,110 --> 00:57:34,820
been in scope so yeah I'm with you with

1057
00:57:32,630 --> 00:57:39,830
the complexity then I'm free and the

1058
00:57:34,820 --> 00:57:43,400
convenience in one and we have one

1059
00:57:39,830 --> 00:57:49,190
additional question which is can this be

1060
00:57:43,400 --> 00:57:55,340
done separately from CD do 2.0 so custom

1061
00:57:49,190 --> 00:58:00,740
saying yes Paul saying yes so some of

1062
00:57:55,340 --> 00:58:01,790
this what's the difference like you know

1063
00:58:00,740 --> 00:58:07,479
extension versa

1064
00:58:01,790 --> 00:58:19,490
CDL can you go to the mic

1065
00:58:07,480 --> 00:58:22,700
sorry custom CD less defined extension

1066
00:58:19,490 --> 00:58:27,680
points so some of these things can be

1067
00:58:22,700 --> 00:58:30,819
added without changing the language then

1068
00:58:27,680 --> 00:58:33,470
for instance the symbol plus operator

1069
00:58:30,820 --> 00:58:36,230
may be a substitute operator can be

1070
00:58:33,470 --> 00:58:40,430
added just as a control operator

1071
00:58:36,230 --> 00:58:41,930
okay let's we have two minutes left so

1072
00:58:40,430 --> 00:58:43,848
I'll just will

1073
00:58:41,930 --> 00:58:46,040
continuing the menu list anyway for all

1074
00:58:43,849 --> 00:58:50,450
these features and we'll get more data

1075
00:58:46,040 --> 00:58:53,558
with the survey as well variants both

1076
00:58:50,450 --> 00:58:57,069
Sieber and Jason variants in one's back

1077
00:58:53,559 --> 00:59:01,730
that's pretty self-explanatory I think

1078
00:58:57,069 --> 00:59:03,800
and co-occurrence constraints there's a

1079
00:59:01,730 --> 00:59:07,190
lot of text we don't have time so I will

1080
00:59:03,800 --> 00:59:11,000
stop here feel free to go in and read

1081
00:59:07,190 --> 00:59:15,980
the slides I also wanted to ask two

1082
00:59:11,000 --> 00:59:17,869
people I compile this I asked it to

1083
00:59:15,980 --> 00:59:21,619
compile this form if it's okay to put

1084
00:59:17,869 --> 00:59:27,380
this up since its I didn't ask you

1085
00:59:21,619 --> 00:59:29,359
before so like to upload it and or maybe

1086
00:59:27,380 --> 00:59:31,700
on the C bourgie tab and let everybody

1087
00:59:29,359 --> 00:59:34,160
see your answers or I can unknown

1088
00:59:31,700 --> 00:59:35,868
amaizing who prefer yeah that's the

1089
00:59:34,160 --> 00:59:38,509
thing under Mike the question is do you

1090
00:59:35,869 --> 00:59:39,800
want our permission to yes this close

1091
00:59:38,510 --> 00:59:45,470
our private information

1092
00:59:39,800 --> 00:59:50,240
Hank version information the context of

1093
00:59:45,470 --> 00:59:51,950
this Thanks I I think okay so if you

1094
00:59:50,240 --> 00:59:53,390
have objections I will have to check

1095
00:59:51,950 --> 00:59:55,848
anyway with people who are not in the

1096
00:59:53,390 --> 00:59:58,160
room but if you have objections to your

1097
00:59:55,849 --> 00:59:58,609
answers being uploaded please let me

1098
00:59:58,160 --> 01:00:07,430
know

1099
00:59:58,609 --> 01:00:10,250
either now or later I think yeah so the

1100
01:00:07,430 --> 01:00:13,399
ways forward the point would be to start

1101
01:00:10,250 --> 01:00:22,099
a CDL 2.0 document with the features

1102
01:00:13,400 --> 01:00:25,010
discussed today we could also hear I

1103
01:00:22,099 --> 01:00:28,460
would like to know who is interested in

1104
01:00:25,010 --> 01:00:34,400
working on this document helping writing

1105
01:00:28,460 --> 01:00:36,260
it up we have the usual suspects Hank

1106
01:00:34,400 --> 01:00:38,119
and Carsten but I would also like to

1107
01:00:36,260 --> 01:00:40,630
hear if anybody else would like to help

1108
01:00:38,119 --> 01:00:46,299
out more

1109
01:00:40,630 --> 01:00:46,299
no one is raising their hands

1110
01:00:49,010 --> 01:00:54,230
so this is Paul Hoffman I'm gonna

1111
01:00:51,470 --> 01:00:56,660
possibly volunteer other people I just

1112
01:00:54,230 --> 01:00:59,480
remember during the CDL during the end

1113
01:00:56,660 --> 01:01:01,250
of the CDL discussion there were lots of

1114
01:00:59,480 --> 01:01:03,500
people who aren't like you know the

1115
01:01:01,250 --> 01:01:05,210
people in the room who seemed interested

1116
01:01:03,500 --> 01:01:07,460
in it and they might be more interested

1117
01:01:05,210 --> 01:01:12,080
in as well so I don't think we were

1118
01:01:07,460 --> 01:01:15,830
restricted to it okay so please let's

1119
01:01:12,080 --> 01:01:17,600
continue this discussion as well yeah we

1120
01:01:15,830 --> 01:01:19,759
will send out the surveys to the mailing

1121
01:01:17,600 --> 01:01:21,890
list several million East and collect

1122
01:01:19,760 --> 01:01:24,500
more input and feedback also there were

1123
01:01:21,890 --> 01:01:26,480
several general comments about city DL

1124
01:01:24,500 --> 01:01:28,700
that we want to take into account about

1125
01:01:26,480 --> 01:01:31,850
usability and readability and

1126
01:01:28,700 --> 01:01:36,830
learnability so that's this will also be

1127
01:01:31,850 --> 01:01:39,890
reported and blue sheets if anybody

1128
01:01:36,830 --> 01:01:44,779
hasn't signed if Jim wants to say

1129
01:01:39,890 --> 01:01:48,470
anything else now is the time otherwise

1130
01:01:44,780 --> 01:01:53,630
I think we're done thank you everybody

1131
01:01:48,470 --> 01:01:56,120
so those who are interested interested

1132
01:01:53,630 --> 01:02:01,960
in the next ten minutes I will explain

1133
01:01:56,120 --> 01:02:04,460
what I will do and yeah so I don't have

1134
01:02:01,960 --> 01:02:06,680
answers for the hard problems

1135
01:02:04,460 --> 01:02:09,650
I think designing your good module

1136
01:02:06,680 --> 01:02:13,359
structure is hard and we require quite

1137
01:02:09,650 --> 01:02:17,950
something about requirements and so on

1138
01:02:13,360 --> 01:02:20,630
designing good co-occurrence mechanism

1139
01:02:17,950 --> 01:02:22,910
probably also is a significant exercise

1140
01:02:20,630 --> 01:02:25,220
because we need to understand what are

1141
01:02:22,910 --> 01:02:28,100
the actual requirements here and before

1142
01:02:25,220 --> 01:02:30,020
we don't want to invent this stuff just

1143
01:02:28,100 --> 01:02:33,710
as we didn't advance it IDL it's all

1144
01:02:30,020 --> 01:02:36,350
stolen from from other things but to

1145
01:02:33,710 --> 01:02:39,260
reuse things like ocl and schema tron

1146
01:02:36,350 --> 01:02:41,839
and there are lots of things to pick

1147
01:02:39,260 --> 01:02:44,030
from and we need to understand which of

1148
01:02:41,840 --> 01:02:47,570
these we want to pick for but for the

1149
01:02:44,030 --> 01:02:49,820
earth can you bring up my slides I don't

1150
01:02:47,570 --> 01:02:53,180
know if we'll lose mythical or remote

1151
01:02:49,820 --> 01:02:55,640
participants or if that is actually just

1152
01:02:53,180 --> 01:02:59,560
for the people here in this room okay

1153
01:02:55,640 --> 01:02:59,560
so this is not an official ITF meeting

1154
01:03:02,140 --> 01:03:11,560
okay so yeah that's why I wanted to

1155
01:03:09,560 --> 01:03:13,940
point through this freezer document it

1156
01:03:11,560 --> 01:03:16,820
hasn't been updated very much in a while

1157
01:03:13,940 --> 01:03:21,500
but it's so useful that there are pieces

1158
01:03:16,820 --> 01:03:26,450
of solutions already Indian I mentioned

1159
01:03:21,500 --> 01:03:30,710
that existing extension points can be

1160
01:03:26,450 --> 01:03:33,290
used for this and the two candidates

1161
01:03:30,710 --> 01:03:36,050
that I think are pretty much no-brainers

1162
01:03:33,290 --> 01:03:38,720
here are computed literals and embedded

1163
01:03:36,050 --> 01:03:40,780
a B and F of course embedded a B and F

1164
01:03:38,720 --> 01:03:43,459
is a significant amount of

1165
01:03:40,780 --> 01:03:46,610
implementation work but it's actually

1166
01:03:43,460 --> 01:03:51,320
almost trivial to specify so let's talk

1167
01:03:46,610 --> 01:03:53,270
about computed literals first those of

1168
01:03:51,320 --> 01:03:56,570
you who have programmed in Fortran will

1169
01:03:53,270 --> 01:04:00,410
almost feel at home here for the other C

1170
01:03:56,570 --> 01:04:02,720
it's not beautiful and maybe we can

1171
01:04:00,410 --> 01:04:05,629
limit it to two the things that we

1172
01:04:02,720 --> 01:04:08,529
really need at the moment which I think

1173
01:04:05,630 --> 01:04:11,480
are plus minus n CH and concatenation

1174
01:04:08,530 --> 01:04:16,090
but maybe we need a few more so let's

1175
01:04:11,480 --> 01:04:22,490
find out so that's really easy a B and F

1176
01:04:16,090 --> 01:04:24,320
well once we have not cared it's pretty

1177
01:04:22,490 --> 01:04:28,520
trivial how to do this

1178
01:04:24,320 --> 01:04:31,910
you need to pull one trick because text

1179
01:04:28,520 --> 01:04:34,759
strings in c DDL don't allow new lines

1180
01:04:31,910 --> 01:04:39,470
so we actually have to write the a B and

1181
01:04:34,760 --> 01:04:42,260
F pieces as byte strings yeah but with

1182
01:04:39,470 --> 01:04:45,649
this little syntactic a trick

1183
01:04:42,260 --> 01:04:48,470
this is really almost usable in in the

1184
01:04:45,650 --> 01:04:52,520
way it's on the slide right now so I

1185
01:04:48,470 --> 01:04:54,049
think we could just go for this and an

1186
01:04:52,520 --> 01:04:56,360
add syntactic sugar for it later

1187
01:04:54,050 --> 01:05:00,260
that's not a problem but for now all

1188
01:04:56,360 --> 01:05:02,750
that's I think pretty good wonder the

1189
01:05:00,260 --> 01:05:05,990
detail that that most people forget when

1190
01:05:02,750 --> 01:05:08,510
they talk about a PMF a B and F doesn't

1191
01:05:05,990 --> 01:05:11,390
tell you how the thing that you are

1192
01:05:08,510 --> 01:05:12,200
describing turns into a sequence of

1193
01:05:11,390 --> 01:05:14,990
numbers

1194
01:05:12,200 --> 01:05:17,540
then described by the grammar and there

1195
01:05:14,990 --> 01:05:19,879
are two different ways of usage of a B&F

1196
01:05:17,540 --> 01:05:21,890
one where the a B and F describes the

1197
01:05:19,880 --> 01:05:23,960
sequence of bytes and the other one

1198
01:05:21,890 --> 01:05:26,060
where where the ABF describes the

1199
01:05:23,960 --> 01:05:29,270
sequence of code points and I think we

1200
01:05:26,060 --> 01:05:31,759
need both so we actually will have to

1201
01:05:29,270 --> 01:05:39,710
dot a B and F operators and we have to

1202
01:05:31,760 --> 01:05:41,030
decide how to call them yeah in the

1203
01:05:39,710 --> 01:05:43,220
donor how many people are aware of that

1204
01:05:41,030 --> 01:05:51,800
but if you have worked with every other

1205
01:05:43,220 --> 01:05:57,200
for a while okay and a completely

1206
01:05:51,800 --> 01:06:00,440
different animal is taking CDL which is

1207
01:05:57,200 --> 01:06:03,109
essentially just a predicate on this

1208
01:06:00,440 --> 01:06:04,609
road say C bar in sense just a predicate

1209
01:06:03,109 --> 01:06:07,690
on a super instance and tells you

1210
01:06:04,609 --> 01:06:10,130
whether that instance matches or not and

1211
01:06:07,690 --> 01:06:12,650
turn it into something different which

1212
01:06:10,130 --> 01:06:16,010
returns quite different pieces of

1213
01:06:12,650 --> 01:06:18,650
information so defaulting is part of the

1214
01:06:16,010 --> 01:06:21,920
semantics organization's transformations

1215
01:06:18,650 --> 01:06:26,230
and so on this is a big thing and that

1216
01:06:21,920 --> 01:06:29,680
also requires significant design

1217
01:06:26,230 --> 01:06:33,680
extending the expressiveness of severe

1218
01:06:29,680 --> 01:06:37,759
requires design and that would be the

1219
01:06:33,680 --> 01:06:41,660
cuts a work that we have started and the

1220
01:06:37,760 --> 01:06:45,020
the co-occurrence constraints so

1221
01:06:41,660 --> 01:06:46,910
essentially the two things that need to

1222
01:06:45,020 --> 01:06:49,849
be done for co-occurrence constraints

1223
01:06:46,910 --> 01:06:51,799
are predicates because we need to be

1224
01:06:49,849 --> 01:06:55,280
able to say whether something is okay or

1225
01:06:51,800 --> 01:06:57,619
not and some form of selector so if we

1226
01:06:55,280 --> 01:06:59,960
say that one number here needs to be

1227
01:06:57,619 --> 01:07:03,020
less than some other number we need to

1228
01:06:59,960 --> 01:07:05,859
have a form to point to that other

1229
01:07:03,020 --> 01:07:11,859
number in the data item and that's

1230
01:07:05,859 --> 01:07:11,859
sometimes significant complexity

1231
01:07:13,310 --> 01:07:22,580
syntactic sugar that requires a way to

1232
01:07:18,080 --> 01:07:28,279
do transformations so we could pretty

1233
01:07:22,580 --> 01:07:32,150
easily say the the identifiers in front

1234
01:07:28,280 --> 01:07:35,420
of a single quoted string is another

1235
01:07:32,150 --> 01:07:38,180
extension point of CD DL so that would

1236
01:07:35,420 --> 01:07:40,850
be one way to get away without having an

1237
01:07:38,180 --> 01:07:44,740
expression language but to do it in a

1238
01:07:40,850 --> 01:07:48,020
general way requires the transformation

1239
01:07:44,740 --> 01:07:50,620
mechanism and then finally the the

1240
01:07:48,020 --> 01:07:56,240
module superstructure and the variants

1241
01:07:50,620 --> 01:08:01,040
are things that should be composed from

1242
01:07:56,240 --> 01:08:05,950
from components that are reusable in

1243
01:08:01,040 --> 01:08:05,950
some form so that requires some design

1244
01:08:06,640 --> 01:08:12,350
yeah and that's one of the features that

1245
01:08:09,170 --> 01:08:15,170
most people want so yeah we should start

1246
01:08:12,350 --> 01:08:19,309
their design now but we shouldn't that

1247
01:08:15,170 --> 01:08:23,450
shouldn't keep us from doing no-brainers

1248
01:08:19,310 --> 01:08:24,890
like like this and finally the the Jason

1249
01:08:23,450 --> 01:08:28,519
stuff really is coming from the other

1250
01:08:24,890 --> 01:08:32,240
side where we have a number of Jason

1251
01:08:28,520 --> 01:08:34,819
related requirements that Jason operator

1252
01:08:32,240 --> 01:08:37,490
is a no-brainer like we have dot C bar

1253
01:08:34,819 --> 01:08:41,600
we should have taught Jason and maybe

1254
01:08:37,490 --> 01:08:45,589
judge Jason see as well the variance

1255
01:08:41,600 --> 01:08:48,530
part essentially requires a way to

1256
01:08:45,589 --> 01:08:52,370
switch and then finally we have this CD

1257
01:08:48,529 --> 01:08:55,160
dij thing and I would love to hear from

1258
01:08:52,370 --> 01:08:59,029
people who are worried by that this is

1259
01:08:55,160 --> 01:09:03,309
the description of CD DL in CD DL so

1260
01:08:59,029 --> 01:09:08,540
this is this is the content of the of RC

1261
01:09:03,310 --> 01:09:13,839
86n and then you can can take an

1262
01:09:08,540 --> 01:09:20,060
existing CDN specification and make it

1263
01:09:13,839 --> 01:09:22,339
almost as ugly as json schema yeah and

1264
01:09:20,060 --> 01:09:26,060
one question is whether we we actually

1265
01:09:22,339 --> 01:09:28,220
should expose our planning

1266
01:09:26,060 --> 01:09:30,380
here a little bit maybe take the freezer

1267
01:09:28,220 --> 01:09:34,580
document and and actually say what we

1268
01:09:30,380 --> 01:09:37,490
are setting out to do and and put some

1269
01:09:34,580 --> 01:09:40,720
of the things that we might be doing in

1270
01:09:37,490 --> 01:09:43,849
the freezer a little longer why we are

1271
01:09:40,720 --> 01:09:45,590
working on the other things so that that

1272
01:09:43,850 --> 01:09:50,210
would be my proposal if we are a little

1273
01:09:45,590 --> 01:09:54,860
bit further advanced to actually make

1274
01:09:50,210 --> 01:09:57,320
this the working document Michael I

1275
01:09:54,860 --> 01:10:02,420
expressed concern about the CD DL in

1276
01:09:57,320 --> 01:10:06,740
Jason and I would like to understand the

1277
01:10:02,420 --> 01:10:10,970
use case more I'm worried about CD DL

1278
01:10:06,740 --> 01:10:15,740
becoming turing-complete and taking over

1279
01:10:10,970 --> 01:10:17,300
the same thing I realized that but you

1280
01:10:15,740 --> 01:10:19,160
know now that you can put it in Jason

1281
01:10:17,300 --> 01:10:21,260
then you can put it into your Turing

1282
01:10:19,160 --> 01:10:23,240
machine and change symbols on it right

1283
01:10:21,260 --> 01:10:25,790
oh you couldn't put pics strings

1284
01:10:23,240 --> 01:10:28,010
information that's Church yes I realize

1285
01:10:25,790 --> 01:10:29,930
that but I'm trying to understand that

1286
01:10:28,010 --> 01:10:32,270
the the use case better so that I

1287
01:10:29,930 --> 01:10:34,880
understand what what it is that we're

1288
01:10:32,270 --> 01:10:37,160
trying to do because if we if we're

1289
01:10:34,880 --> 01:10:39,230
making it adjacent representation then I

1290
01:10:37,160 --> 01:10:41,570
presume that part of the reasons we want

1291
01:10:39,230 --> 01:10:45,919
to write programs that both read and

1292
01:10:41,570 --> 01:10:48,139
write CTL yes and it's one thing you

1293
01:10:45,920 --> 01:10:50,450
said I want to read CD DL produced by

1294
01:10:48,140 --> 01:10:52,670
human and then it's another thing if I

1295
01:10:50,450 --> 01:10:54,860
start saying I want to produce CD DL by

1296
01:10:52,670 --> 01:10:59,260
a machine which I'm then going to feed

1297
01:10:54,860 --> 01:11:02,389
into a something to produce Jason or

1298
01:10:59,260 --> 01:11:05,510
something else from it right at which

1299
01:11:02,390 --> 01:11:07,520
point I get I I'm worried about what

1300
01:11:05,510 --> 01:11:09,170
happens to the debug ability of the

1301
01:11:07,520 --> 01:11:10,520
resulting protocol which has been

1302
01:11:09,170 --> 01:11:13,820
produced by sort of two layers of

1303
01:11:10,520 --> 01:11:15,440
machine interpretation right that's all

1304
01:11:13,820 --> 01:11:18,469
I'm trying to understand who wants to

1305
01:11:15,440 --> 01:11:20,349
use it in Y and that's why I'm really

1306
01:11:18,470 --> 01:11:24,500
concerned about the thing and and then

1307
01:11:20,350 --> 01:11:27,890
what what things they might prefer not

1308
01:11:24,500 --> 01:11:30,440
to have in their their version of CD DL

1309
01:11:27,890 --> 01:11:34,580
because it's inconvenient to to

1310
01:11:30,440 --> 01:11:36,919
round-trip through their machine let me

1311
01:11:34,580 --> 01:11:38,100
give you two reasons why where this is

1312
01:11:36,920 --> 01:11:40,320
useful

1313
01:11:38,100 --> 01:11:43,520
one is simply you want to write a tool

1314
01:11:40,320 --> 01:11:46,710
that does some fall-off consistency Jake

1315
01:11:43,520 --> 01:11:49,020
some form of search on a CD a

1316
01:11:46,710 --> 01:11:50,940
specification that's just easier if you

1317
01:11:49,020 --> 01:11:54,750
don't have to write a parser but but can

1318
01:11:50,940 --> 01:11:56,820
just ingest the CDL in past form the

1319
01:11:54,750 --> 01:11:58,770
other example what I really want to

1320
01:11:56,820 --> 01:12:03,480
write this and have written most of the

1321
01:11:58,770 --> 01:12:06,900
code already is that I want to write a

1322
01:12:03,480 --> 01:12:12,200
thing that converts from JSON schema org

1323
01:12:06,900 --> 01:12:14,670
and and other things of this kind to CDL

1324
01:12:12,200 --> 01:12:16,880
obviously the output of that conversion

1325
01:12:14,670 --> 01:12:21,650
will not be beautiful

1326
01:12:16,880 --> 01:12:27,780
but I did this once already in in in

1327
01:12:21,650 --> 01:12:30,599
2016 with the ocf specification at the

1328
01:12:27,780 --> 01:12:32,429
time and I found tons of bugs in there

1329
01:12:30,600 --> 01:12:36,390
Jason's email as soon as I could

1330
01:12:32,430 --> 01:12:39,300
look at the Infinity air for so it's

1331
01:12:36,390 --> 01:12:42,000
really useful thing to do and this

1332
01:12:39,300 --> 01:12:44,340
conversion is again to two parts the

1333
01:12:42,000 --> 01:12:47,010
actual conversion and the writing out of

1334
01:12:44,340 --> 01:12:49,140
the human readable city and again I

1335
01:12:47,010 --> 01:12:49,890
would like to have a tool that does the

1336
01:12:49,140 --> 01:12:53,400
letter apart

1337
01:12:49,890 --> 01:12:56,220
so it's easier to write the other kind

1338
01:12:53,400 --> 01:12:57,420
of Twitter and for those tools it's

1339
01:12:56,220 --> 01:13:00,150
really good if they are interoperable

1340
01:12:57,420 --> 01:13:00,840
that's why it's a good idea to write

1341
01:13:00,150 --> 01:13:03,750
this off

1342
01:13:00,840 --> 01:13:06,570
I also worry that you're gonna end up in

1343
01:13:03,750 --> 01:13:08,640
a situation where you're gonna have to

1344
01:13:06,570 --> 01:13:11,370
parse it and see the D out and parse it

1345
01:13:08,640 --> 01:13:16,440
in JSON and then say these two things

1346
01:13:11,370 --> 01:13:19,769
are the same thing it's really really

1347
01:13:16,440 --> 01:13:30,839
hard well you first solve the halting

1348
01:13:19,770 --> 01:13:32,550
problem and then it's quite easy Sean

1349
01:13:30,840 --> 01:13:34,910
Leonard I just also want to say since

1350
01:13:32,550 --> 01:13:39,180
since Carson's lists include

1351
01:13:34,910 --> 01:13:41,760
incorporating a B and F things I've

1352
01:13:39,180 --> 01:13:45,000
actually done some work along with Paul

1353
01:13:41,760 --> 01:13:47,430
cos via and others on improving and

1354
01:13:45,000 --> 01:13:50,340
extending a B and F so that it can

1355
01:13:47,430 --> 01:13:51,900
handle things like Unicode and and a few

1356
01:13:50,340 --> 01:13:54,330
other things that kind of

1357
01:13:51,900 --> 01:13:56,339
directly related to what CBL is trying

1358
01:13:54,330 --> 01:13:58,260
to do so I'll try to post some of those

1359
01:13:56,340 --> 01:14:00,060
drafts to the mailing lists you can see

1360
01:13:58,260 --> 01:14:03,650
that and see if it's useful to

1361
01:14:00,060 --> 01:14:07,890
incorporate and also resolve ambiguities

1362
01:14:03,650 --> 01:14:12,990
in how we can use a vnf more formally to

1363
01:14:07,890 --> 01:14:19,380
define stuff some things thank you okay

1364
01:14:12,990 --> 01:14:22,889
so I'm done stealing your time everybody

1365
01:14:19,380 --> 01:14:26,340
and thanks Mexico for staying on session

1366
01:14:22,890 --> 01:14:28,940
is site or hallway meeting is officially

1367
01:14:26,340 --> 01:14:28,940
over

